// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from R7FA2L1AB.svd, see https://github.com/cmsis-svd/cmsis-svd-data/tree/master/data/Renesas

//go:build renesas && r7fa2l1ab

/*
// Arm Cortex-M23 based Microcontroller RA2L1 group
*/
//     This software is supplied by Renesas Electronics Corporation and is only intended for
//     use with Renesas products. No other uses are authorized. This software is owned by
//     Renesas Electronics Corporation and is protected under all applicable laws, including
//     copyright laws.
//
//     THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
//     THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO
//     WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
//     ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM EXTENT PERMITTED NOT
//     PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED
//     COMPANIES SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
//     DAMAGES FOR ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
//     BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
//
//     Renesas reserves the right, without notice, to make changes to this software and to
//     discontinue the availability of this software. By using this software, you agree to
//     the additional terms and conditions found by accessing the following link:
//     http://www.renesas.com/disclaimer
//     \n
package renesas

import (
	"github.com/goplus/emb/runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "R7FA2L1AB"
	CPU          = "CM23"
	FPUPresent   = false
	NVICPrioBits = 2
)

// Interrupt numbers.
const (
	// ICU for CPU
	IRQ_IEL0 = 0

	// ICU for CPU
	IRQ_IEL1 = 1

	// ICU for CPU
	IRQ_IEL2 = 2

	// ICU for CPU
	IRQ_IEL3 = 3

	// ICU for CPU
	IRQ_IEL4 = 4

	// ICU for CPU
	IRQ_IEL5 = 5

	// ICU for CPU
	IRQ_IEL6 = 6

	// ICU for CPU
	IRQ_IEL7 = 7

	// ICU for CPU
	IRQ_IEL8 = 8

	// ICU for CPU
	IRQ_IEL9 = 9

	// ICU for CPU
	IRQ_IEL10 = 10

	// ICU for CPU
	IRQ_IEL11 = 11

	// ICU for CPU
	IRQ_IEL12 = 12

	// ICU for CPU
	IRQ_IEL13 = 13

	// ICU for CPU
	IRQ_IEL14 = 14

	// ICU for CPU
	IRQ_IEL15 = 15

	// ICU for CPU
	IRQ_IEL16 = 16

	// ICU for CPU
	IRQ_IEL17 = 17

	// ICU for CPU
	IRQ_IEL18 = 18

	// ICU for CPU
	IRQ_IEL19 = 19

	// ICU for CPU
	IRQ_IEL20 = 20

	// ICU for CPU
	IRQ_IEL21 = 21

	// ICU for CPU
	IRQ_IEL22 = 22

	// ICU for CPU
	IRQ_IEL23 = 23

	// ICU for CPU
	IRQ_IEL24 = 24

	// ICU for CPU
	IRQ_IEL25 = 25

	// ICU for CPU
	IRQ_IEL26 = 26

	// ICU for CPU
	IRQ_IEL27 = 27

	// ICU for CPU
	IRQ_IEL28 = 28

	// ICU for CPU
	IRQ_IEL29 = 29

	// ICU for CPU
	IRQ_IEL30 = 30

	// ICU for CPU
	IRQ_IEL31 = 31

	// Highest interrupt number on this device.
	IRQ_max = 31
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
// NOTE(zzy): runtime/interrupt.callHandlers is not yet implemented in LLGO
// Original linkname: //go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int) {
	// TODO: implement interrupt handler dispatch mechanism
}

//export IEL0_IRQHandler
func interruptIEL0() {
	callHandlers(IRQ_IEL0)
}

//export IEL1_IRQHandler
func interruptIEL1() {
	callHandlers(IRQ_IEL1)
}

//export IEL2_IRQHandler
func interruptIEL2() {
	callHandlers(IRQ_IEL2)
}

//export IEL3_IRQHandler
func interruptIEL3() {
	callHandlers(IRQ_IEL3)
}

//export IEL4_IRQHandler
func interruptIEL4() {
	callHandlers(IRQ_IEL4)
}

//export IEL5_IRQHandler
func interruptIEL5() {
	callHandlers(IRQ_IEL5)
}

//export IEL6_IRQHandler
func interruptIEL6() {
	callHandlers(IRQ_IEL6)
}

//export IEL7_IRQHandler
func interruptIEL7() {
	callHandlers(IRQ_IEL7)
}

//export IEL8_IRQHandler
func interruptIEL8() {
	callHandlers(IRQ_IEL8)
}

//export IEL9_IRQHandler
func interruptIEL9() {
	callHandlers(IRQ_IEL9)
}

//export IEL10_IRQHandler
func interruptIEL10() {
	callHandlers(IRQ_IEL10)
}

//export IEL11_IRQHandler
func interruptIEL11() {
	callHandlers(IRQ_IEL11)
}

//export IEL12_IRQHandler
func interruptIEL12() {
	callHandlers(IRQ_IEL12)
}

//export IEL13_IRQHandler
func interruptIEL13() {
	callHandlers(IRQ_IEL13)
}

//export IEL14_IRQHandler
func interruptIEL14() {
	callHandlers(IRQ_IEL14)
}

//export IEL15_IRQHandler
func interruptIEL15() {
	callHandlers(IRQ_IEL15)
}

//export IEL16_IRQHandler
func interruptIEL16() {
	callHandlers(IRQ_IEL16)
}

//export IEL17_IRQHandler
func interruptIEL17() {
	callHandlers(IRQ_IEL17)
}

//export IEL18_IRQHandler
func interruptIEL18() {
	callHandlers(IRQ_IEL18)
}

//export IEL19_IRQHandler
func interruptIEL19() {
	callHandlers(IRQ_IEL19)
}

//export IEL20_IRQHandler
func interruptIEL20() {
	callHandlers(IRQ_IEL20)
}

//export IEL21_IRQHandler
func interruptIEL21() {
	callHandlers(IRQ_IEL21)
}

//export IEL22_IRQHandler
func interruptIEL22() {
	callHandlers(IRQ_IEL22)
}

//export IEL23_IRQHandler
func interruptIEL23() {
	callHandlers(IRQ_IEL23)
}

//export IEL24_IRQHandler
func interruptIEL24() {
	callHandlers(IRQ_IEL24)
}

//export IEL25_IRQHandler
func interruptIEL25() {
	callHandlers(IRQ_IEL25)
}

//export IEL26_IRQHandler
func interruptIEL26() {
	callHandlers(IRQ_IEL26)
}

//export IEL27_IRQHandler
func interruptIEL27() {
	callHandlers(IRQ_IEL27)
}

//export IEL28_IRQHandler
func interruptIEL28() {
	callHandlers(IRQ_IEL28)
}

//export IEL29_IRQHandler
func interruptIEL29() {
	callHandlers(IRQ_IEL29)
}

//export IEL30_IRQHandler
func interruptIEL30() {
	callHandlers(IRQ_IEL30)
}

//export IEL31_IRQHandler
func interruptIEL31() {
	callHandlers(IRQ_IEL31)
}

// Peripherals.
var (
	// Renesas Memory Protection Unit
	RMPU = (*RMPU_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// SRAM Control
	SRAM = (*SRAM_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// BUS Control
	BUS = (*BUS_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Data Transfer Controller
	DTC = (*DTC_Type)(unsafe.Pointer(uintptr(0x40005400)))

	// ICU for CPU
	ICU = (*ICU_Type)(unsafe.Pointer(uintptr(0x40006000)))

	// Debug Function
	DBG = (*DBG_Type)(unsafe.Pointer(uintptr(0x4001b000)))

	// System Control
	SYSC = (*SYSC_Type)(unsafe.Pointer(uintptr(0x4001e000)))

	// Port 0 Control Registers
	PORT0 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040000)))

	// Port 1 Control Registers
	PORT1 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40040020)))

	// Port 2 Control Registers
	PORT2 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40040040)))

	// Port 3 Control Registers
	PORT3 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040060)))

	// Port 4 Control Registers
	PORT4 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040080)))

	// Port 5 Control Registers
	PORT5 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x400400a0)))

	// Port 6 Control Registers
	PORT6 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x400400c0)))

	// Port 7 Control Registers
	PORT7 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x400400e0)))

	// Port 8 Control Registers
	PORT8 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040100)))

	// Pmn Pin Function Control Register
	PFS = (*PFS_Type)(unsafe.Pointer(uintptr(0x40040800)))

	// Event Link Controller
	ELC = (*ELC_Type)(unsafe.Pointer(uintptr(0x40041000)))

	// Port Output Enable Module for GPT
	POEG = (*POEG_Type)(unsafe.Pointer(uintptr(0x40042000)))

	// Realtime Clock
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x40044000)))

	// Watchdog Timer
	WDT = (*WDT_Type)(unsafe.Pointer(uintptr(0x40044200)))

	// Independent Watchdog Timer
	IWDT = (*IWDT_Type)(unsafe.Pointer(uintptr(0x40044400)))

	// Clock Frequency Accuracy Measurement Circuit
	CAC = (*CAC_Type)(unsafe.Pointer(uintptr(0x40044600)))

	// Module Stop Control B, C, D
	MSTP = (*MSTP_Type)(unsafe.Pointer(uintptr(0x40047000)))

	// Controller Area Network
	CAN0 = (*CAN0_Type)(unsafe.Pointer(uintptr(0x40050000)))

	// Inter-Integrated Circuit 0
	IIC0 = (*IIC0_Type)(unsafe.Pointer(uintptr(0x40053000)))

	// Inter-Integrated Circuit 0 Wake-up Unit
	IIC0WU = (*IIC0WU_Type)(unsafe.Pointer(uintptr(0x40053014)))

	// Inter-Integrated Circuit 1
	IIC1 = (*IIC0_Type)(unsafe.Pointer(uintptr(0x40053100)))

	// Data Operation Circuit
	DOC = (*DOC_Type)(unsafe.Pointer(uintptr(0x40054100)))

	// 12-bit A/D Converter
	ADC120 = (*ADC120_Type)(unsafe.Pointer(uintptr(0x4005c000)))

	// 12-bit D/A converter
	DAC12 = (*DAC12_Type)(unsafe.Pointer(uintptr(0x4005e000)))

	// Serial Communication Interface 0
	SCI0 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x40070000)))

	// Serial Communication Interface 0
	SCI1 = (*SCI1_Type)(unsafe.Pointer(uintptr(0x40070020)))

	// Serial Communication Interface 0
	SCI2 = (*SCI1_Type)(unsafe.Pointer(uintptr(0x40070040)))

	// Serial Communication Interface 0
	SCI3 = (*SCI1_Type)(unsafe.Pointer(uintptr(0x40070060)))

	// Serial Communication Interface 0
	SCI9 = (*SCI1_Type)(unsafe.Pointer(uintptr(0x40070120)))

	// Serial Peripheral Interface 0
	SPI0 = (*SPI0_Type)(unsafe.Pointer(uintptr(0x40072000)))

	// Serial Peripheral Interface 1
	SPI1 = (*SPI0_Type)(unsafe.Pointer(uintptr(0x40072100)))

	// Cyclic Redundancy Check Calculator
	CRC = (*CRC_Type)(unsafe.Pointer(uintptr(0x40074000)))

	// General PWM 32-bit Timer 0
	GPT320 = (*GPT320_Type)(unsafe.Pointer(uintptr(0x40078000)))

	// General PWM 32-bit Timer 1
	GPT321 = (*GPT320_Type)(unsafe.Pointer(uintptr(0x40078100)))

	// General PWM 32-bit Timer 2
	GPT322 = (*GPT320_Type)(unsafe.Pointer(uintptr(0x40078200)))

	// General PWM 32-bit Timer 3
	GPT323 = (*GPT320_Type)(unsafe.Pointer(uintptr(0x40078300)))

	// General PWM 16-bit Timer 4
	GPT164 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40078400)))

	// General PWM 16-bit Timer 5
	GPT165 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40078500)))

	// General PWM 16-bit Timer 6
	GPT166 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40078600)))

	// General PWM 16-bit Timer 7
	GPT167 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40078700)))

	// General PWM 16-bit Timer 8
	GPT168 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40078800)))

	// General PWM 16-bit Timer 9
	GPT169 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40078900)))

	// Output Phase Switching Controller
	GPT_OPS = (*GPT_OPS_Type)(unsafe.Pointer(uintptr(0x40078ff0)))

	// Key Interrupt Function
	KINT = (*KINT_Type)(unsafe.Pointer(uintptr(0x40080000)))

	// Capacitive Touch Sensing Unit
	CTSU = (*CTSU_Type)(unsafe.Pointer(uintptr(0x40082000)))

	// Low Power Asynchronous General Purpose Timer 0
	AGT0 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x40084000)))

	// Low Power Asynchronous General Purpose Timer 1
	AGT1 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x40084100)))

	// Low-Power Analog Comparator
	ACMPLP = (*ACMPLP_Type)(unsafe.Pointer(uintptr(0x40085e00)))

	// Flash I/O Registers
	FLCN = (*FLCN_Type)(unsafe.Pointer(uintptr(0x407ec000)))
)

// Renesas Memory Protection Unit
type RMPU_Type struct {
	MMPUCTLA  volatile.Register16 // 0x0
	_         [256]byte
	MMPUPTA   volatile.Register16 // 0x102
	_         [252]byte
	MMPUACA0  volatile.Register16 // 0x200
	_         [2]byte
	MMPUSA0   volatile.Register32 // 0x204
	MMPUEA0   volatile.Register32 // 0x208
	_         [4]byte
	MMPUACA1  volatile.Register16 // 0x210
	_         [2]byte
	MMPUSA1   volatile.Register32 // 0x214
	MMPUEA1   volatile.Register32 // 0x218
	_         [4]byte
	MMPUACA2  volatile.Register16 // 0x220
	_         [2]byte
	MMPUSA2   volatile.Register32 // 0x224
	MMPUEA2   volatile.Register32 // 0x228
	_         [4]byte
	MMPUACA3  volatile.Register16 // 0x230
	_         [2]byte
	MMPUSA3   volatile.Register32 // 0x234
	MMPUEA3   volatile.Register32 // 0x238
	_         [2500]byte
	SMPUCTL   volatile.Register16 // 0xC00
	_         [14]byte
	SMPUMBIU  volatile.Register16 // 0xC10
	_         [2]byte
	SMPUFBIU  volatile.Register16 // 0xC14
	_         [2]byte
	SMPUSRAM0 volatile.Register16 // 0xC18
	_         [6]byte
	SMPUP0BIU volatile.Register16 // 0xC20
	_         [2]byte
	SMPUP2BIU volatile.Register16 // 0xC24
	_         [2]byte
	SMPUP6BIU volatile.Register16 // 0xC28
	_         [214]byte
	MSPMPUOAD volatile.Register16 // 0xD00
	_         [2]byte
	MSPMPUCTL volatile.Register16 // 0xD04
	MSPMPUPT  volatile.Register16 // 0xD06
	MSPMPUSA  volatile.Register32 // 0xD08
	MSPMPUEA  volatile.Register32 // 0xD0C
	PSPMPUOAD volatile.Register16 // 0xD10
	_         [2]byte
	PSPMPUCTL volatile.Register16 // 0xD14
	PSPMPUPT  volatile.Register16 // 0xD16
	PSPMPUSA  volatile.Register32 // 0xD18
	PSPMPUEA  volatile.Register32 // 0xD1C
}

// RMPU.MMPUCTLA: Bus Master MPU Control Register
func (o *RMPU_Type) SetMMPUCTLA_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUCTLA_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUCTLA_OAD(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUCTLA_OAD() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUCTLA_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetMMPUCTLA_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0xff00) >> 8
}

// RMPU.MMPUPTA: Group A Protection of Register
func (o *RMPU_Type) SetMMPUPTA_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MMPUPTA.Reg, volatile.LoadUint16(&o.MMPUPTA.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUPTA_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MMPUPTA.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUPTA_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUPTA.Reg, volatile.LoadUint16(&o.MMPUPTA.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetMMPUPTA_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUPTA.Reg) & 0xff00) >> 8
}

// RMPU.MMPUACA0: Group A Region %s access control register
func (o *RMPU_Type) SetMMPUACA0_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACA0_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA0.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACA0_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACA0_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA0.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACA0_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACA0_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA0.Reg) & 0x4) >> 2
}

// RMPU.MMPUSA0: Group A Region %s Start Address Register
func (o *RMPU_Type) SetMMPUSA0(value uint32) {
	volatile.StoreUint32(&o.MMPUSA0.Reg, value)
}
func (o *RMPU_Type) GetMMPUSA0() uint32 {
	return volatile.LoadUint32(&o.MMPUSA0.Reg)
}

// RMPU.MMPUEA0: Group A Region %s End Address Register
func (o *RMPU_Type) SetMMPUEA0(value uint32) {
	volatile.StoreUint32(&o.MMPUEA0.Reg, value)
}
func (o *RMPU_Type) GetMMPUEA0() uint32 {
	return volatile.LoadUint32(&o.MMPUEA0.Reg)
}

// RMPU.MMPUACA1: Group A Region %s access control register
func (o *RMPU_Type) SetMMPUACA1_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACA1_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA1.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACA1_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACA1_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA1.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACA1_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACA1_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA1.Reg) & 0x4) >> 2
}

// RMPU.MMPUSA1: Group A Region %s Start Address Register
func (o *RMPU_Type) SetMMPUSA1(value uint32) {
	volatile.StoreUint32(&o.MMPUSA1.Reg, value)
}
func (o *RMPU_Type) GetMMPUSA1() uint32 {
	return volatile.LoadUint32(&o.MMPUSA1.Reg)
}

// RMPU.MMPUEA1: Group A Region %s End Address Register
func (o *RMPU_Type) SetMMPUEA1(value uint32) {
	volatile.StoreUint32(&o.MMPUEA1.Reg, value)
}
func (o *RMPU_Type) GetMMPUEA1() uint32 {
	return volatile.LoadUint32(&o.MMPUEA1.Reg)
}

// RMPU.MMPUACA2: Group A Region %s access control register
func (o *RMPU_Type) SetMMPUACA2_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACA2_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA2.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACA2_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACA2_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA2.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACA2_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACA2_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA2.Reg) & 0x4) >> 2
}

// RMPU.MMPUSA2: Group A Region %s Start Address Register
func (o *RMPU_Type) SetMMPUSA2(value uint32) {
	volatile.StoreUint32(&o.MMPUSA2.Reg, value)
}
func (o *RMPU_Type) GetMMPUSA2() uint32 {
	return volatile.LoadUint32(&o.MMPUSA2.Reg)
}

// RMPU.MMPUEA2: Group A Region %s End Address Register
func (o *RMPU_Type) SetMMPUEA2(value uint32) {
	volatile.StoreUint32(&o.MMPUEA2.Reg, value)
}
func (o *RMPU_Type) GetMMPUEA2() uint32 {
	return volatile.LoadUint32(&o.MMPUEA2.Reg)
}

// RMPU.MMPUACA3: Group A Region %s access control register
func (o *RMPU_Type) SetMMPUACA3_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACA3_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA3.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACA3_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACA3_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA3.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACA3_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACA3_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA3.Reg) & 0x4) >> 2
}

// RMPU.MMPUSA3: Group A Region %s Start Address Register
func (o *RMPU_Type) SetMMPUSA3(value uint32) {
	volatile.StoreUint32(&o.MMPUSA3.Reg, value)
}
func (o *RMPU_Type) GetMMPUSA3() uint32 {
	return volatile.LoadUint32(&o.MMPUSA3.Reg)
}

// RMPU.MMPUEA3: Group A Region %s End Address Register
func (o *RMPU_Type) SetMMPUEA3(value uint32) {
	volatile.StoreUint32(&o.MMPUEA3.Reg, value)
}
func (o *RMPU_Type) GetMMPUEA3() uint32 {
	return volatile.LoadUint32(&o.MMPUEA3.Reg)
}

// RMPU.SMPUCTL: Slave MPU Control Register
func (o *RMPU_Type) SetSMPUCTL_OAD(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetSMPUCTL_OAD() uint16 {
	return volatile.LoadUint16(&o.SMPUCTL.Reg) & 0x1
}
func (o *RMPU_Type) SetSMPUCTL_PROTECT(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetSMPUCTL_PROTECT() uint16 {
	return (volatile.LoadUint16(&o.SMPUCTL.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetSMPUCTL_KEY(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetSMPUCTL_KEY() uint16 {
	return (volatile.LoadUint16(&o.SMPUCTL.Reg) & 0xff00) >> 8
}

// RMPU.SMPUMBIU: Access Control Register for Memory Bus 1
func (o *RMPU_Type) SetSMPUMBIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetSMPUMBIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x4) >> 2
}
func (o *RMPU_Type) SetSMPUMBIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x8)|value<<3)
}
func (o *RMPU_Type) GetSMPUMBIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x8) >> 3
}

// RMPU.SMPUFBIU: Access Control Register for Internal Peripheral Bus 9
func (o *RMPU_Type) SetSMPUFBIU_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetSMPUFBIU_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x1
}
func (o *RMPU_Type) SetSMPUFBIU_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetSMPUFBIU_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetSMPUFBIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetSMPUFBIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x4) >> 2
}
func (o *RMPU_Type) SetSMPUFBIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x8)|value<<3)
}
func (o *RMPU_Type) GetSMPUFBIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x8) >> 3
}

// RMPU.SMPUSRAM0: Access Control Register for Memory Bus 4
func (o *RMPU_Type) SetSMPUSRAM0_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetSMPUSRAM0_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x1
}
func (o *RMPU_Type) SetSMPUSRAM0_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetSMPUSRAM0_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetSMPUSRAM0_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetSMPUSRAM0_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x4) >> 2
}
func (o *RMPU_Type) SetSMPUSRAM0_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x8)|value<<3)
}
func (o *RMPU_Type) GetSMPUSRAM0_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x8) >> 3
}

// RMPU.SMPUP0BIU: Access Control Register for Internal Peripheral Bus 1
func (o *RMPU_Type) SetSMPUP0BIU_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetSMPUP0BIU_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x1
}
func (o *RMPU_Type) SetSMPUP0BIU_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetSMPUP0BIU_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetSMPUP0BIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetSMPUP0BIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x4) >> 2
}
func (o *RMPU_Type) SetSMPUP0BIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x8)|value<<3)
}
func (o *RMPU_Type) GetSMPUP0BIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x8) >> 3
}

// RMPU.SMPUP2BIU: Access Control Register for Internal Peripheral Bus 3
func (o *RMPU_Type) SetSMPUP2BIU_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetSMPUP2BIU_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x1
}
func (o *RMPU_Type) SetSMPUP2BIU_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetSMPUP2BIU_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetSMPUP2BIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetSMPUP2BIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x4) >> 2
}
func (o *RMPU_Type) SetSMPUP2BIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x8)|value<<3)
}
func (o *RMPU_Type) GetSMPUP2BIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x8) >> 3
}

// RMPU.SMPUP6BIU: Access Control Register for Internal Peripheral Bus 7
func (o *RMPU_Type) SetSMPUP6BIU_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetSMPUP6BIU_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x1
}
func (o *RMPU_Type) SetSMPUP6BIU_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetSMPUP6BIU_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetSMPUP6BIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetSMPUP6BIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x4) >> 2
}
func (o *RMPU_Type) SetSMPUP6BIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x8)|value<<3)
}
func (o *RMPU_Type) GetSMPUP6BIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x8) >> 3
}

// RMPU.MSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
func (o *RMPU_Type) SetMSPMPUOAD_OAD(value uint16) {
	volatile.StoreUint16(&o.MSPMPUOAD.Reg, volatile.LoadUint16(&o.MSPMPUOAD.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMSPMPUOAD_OAD() uint16 {
	return volatile.LoadUint16(&o.MSPMPUOAD.Reg) & 0x1
}
func (o *RMPU_Type) SetMSPMPUOAD_KEY(value uint16) {
	volatile.StoreUint16(&o.MSPMPUOAD.Reg, volatile.LoadUint16(&o.MSPMPUOAD.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetMSPMPUOAD_KEY() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUOAD.Reg) & 0xff00) >> 8
}

// RMPU.MSPMPUCTL: Stack Pointer Monitor Access Control Register
func (o *RMPU_Type) SetMSPMPUCTL_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MSPMPUCTL.Reg, volatile.LoadUint16(&o.MSPMPUCTL.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMSPMPUCTL_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MSPMPUCTL.Reg) & 0x1
}
func (o *RMPU_Type) SetMSPMPUCTL_ERROR(value uint16) {
	volatile.StoreUint16(&o.MSPMPUCTL.Reg, volatile.LoadUint16(&o.MSPMPUCTL.Reg)&^(0x100)|value<<8)
}
func (o *RMPU_Type) GetMSPMPUCTL_ERROR() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUCTL.Reg) & 0x100) >> 8
}

// RMPU.MSPMPUPT: Stack Pointer Monitor Protection Register
func (o *RMPU_Type) SetMSPMPUPT_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MSPMPUPT.Reg, volatile.LoadUint16(&o.MSPMPUPT.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMSPMPUPT_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MSPMPUPT.Reg) & 0x1
}
func (o *RMPU_Type) SetMSPMPUPT_KEY(value uint16) {
	volatile.StoreUint16(&o.MSPMPUPT.Reg, volatile.LoadUint16(&o.MSPMPUPT.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetMSPMPUPT_KEY() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUPT.Reg) & 0xff00) >> 8
}

// RMPU.MSPMPUSA: Main Stack Pointer (MSP) Monitor Start Address Register
func (o *RMPU_Type) SetMSPMPUSA(value uint32) {
	volatile.StoreUint32(&o.MSPMPUSA.Reg, value)
}
func (o *RMPU_Type) GetMSPMPUSA() uint32 {
	return volatile.LoadUint32(&o.MSPMPUSA.Reg)
}

// RMPU.MSPMPUEA: Main Stack Pointer (MSP) Monitor End Address Register
func (o *RMPU_Type) SetMSPMPUEA(value uint32) {
	volatile.StoreUint32(&o.MSPMPUEA.Reg, value)
}
func (o *RMPU_Type) GetMSPMPUEA() uint32 {
	return volatile.LoadUint32(&o.MSPMPUEA.Reg)
}

// RMPU.PSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
func (o *RMPU_Type) SetPSPMPUOAD_OAD(value uint16) {
	volatile.StoreUint16(&o.PSPMPUOAD.Reg, volatile.LoadUint16(&o.PSPMPUOAD.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetPSPMPUOAD_OAD() uint16 {
	return volatile.LoadUint16(&o.PSPMPUOAD.Reg) & 0x1
}
func (o *RMPU_Type) SetPSPMPUOAD_KEY(value uint16) {
	volatile.StoreUint16(&o.PSPMPUOAD.Reg, volatile.LoadUint16(&o.PSPMPUOAD.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetPSPMPUOAD_KEY() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUOAD.Reg) & 0xff00) >> 8
}

// RMPU.PSPMPUCTL: Stack Pointer Monitor Access Control Register
func (o *RMPU_Type) SetPSPMPUCTL_ENABLE(value uint16) {
	volatile.StoreUint16(&o.PSPMPUCTL.Reg, volatile.LoadUint16(&o.PSPMPUCTL.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetPSPMPUCTL_ENABLE() uint16 {
	return volatile.LoadUint16(&o.PSPMPUCTL.Reg) & 0x1
}
func (o *RMPU_Type) SetPSPMPUCTL_ERROR(value uint16) {
	volatile.StoreUint16(&o.PSPMPUCTL.Reg, volatile.LoadUint16(&o.PSPMPUCTL.Reg)&^(0x100)|value<<8)
}
func (o *RMPU_Type) GetPSPMPUCTL_ERROR() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUCTL.Reg) & 0x100) >> 8
}

// RMPU.PSPMPUPT: Stack Pointer Monitor Protection Register
func (o *RMPU_Type) SetPSPMPUPT_PROTECT(value uint16) {
	volatile.StoreUint16(&o.PSPMPUPT.Reg, volatile.LoadUint16(&o.PSPMPUPT.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetPSPMPUPT_PROTECT() uint16 {
	return volatile.LoadUint16(&o.PSPMPUPT.Reg) & 0x1
}
func (o *RMPU_Type) SetPSPMPUPT_KEY(value uint16) {
	volatile.StoreUint16(&o.PSPMPUPT.Reg, volatile.LoadUint16(&o.PSPMPUPT.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetPSPMPUPT_KEY() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUPT.Reg) & 0xff00) >> 8
}

// RMPU.PSPMPUSA: Process Stack Pointer (PSP) Monitor Start Address Register
func (o *RMPU_Type) SetPSPMPUSA(value uint32) {
	volatile.StoreUint32(&o.PSPMPUSA.Reg, value)
}
func (o *RMPU_Type) GetPSPMPUSA() uint32 {
	return volatile.LoadUint32(&o.PSPMPUSA.Reg)
}

// RMPU.PSPMPUEA: Process Stack Pointer (PSP) Monitor End Address Register
func (o *RMPU_Type) SetPSPMPUEA(value uint32) {
	volatile.StoreUint32(&o.PSPMPUEA.Reg, value)
}
func (o *RMPU_Type) GetPSPMPUEA() uint32 {
	return volatile.LoadUint32(&o.PSPMPUEA.Reg)
}

// SRAM Control
type SRAM_Type struct {
	PARIOAD   volatile.Register8 // 0x0
	_         [3]byte
	SRAMPRCR  volatile.Register8 // 0x4
	_         [187]byte
	ECCMODE   volatile.Register8 // 0xC0
	ECC2STS   volatile.Register8 // 0xC1
	ECC1STSEN volatile.Register8 // 0xC2
	ECC1STS   volatile.Register8 // 0xC3
	ECCPRCR   volatile.Register8 // 0xC4
	_         [11]byte
	ECCPRCR2  volatile.Register8 // 0xD0
	_         [3]byte
	ECCETST   volatile.Register8 // 0xD4
	_         [3]byte
	ECCOAD    volatile.Register8 // 0xD8
}

// SRAM.PARIOAD: SRAM Parity Error Operation After Detection Register
func (o *SRAM_Type) SetPARIOAD_OAD(value uint8) {
	volatile.StoreUint8(&o.PARIOAD.Reg, volatile.LoadUint8(&o.PARIOAD.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetPARIOAD_OAD() uint8 {
	return volatile.LoadUint8(&o.PARIOAD.Reg) & 0x1
}

// SRAM.SRAMPRCR: SRAM Protection Register
func (o *SRAM_Type) SetSRAMPRCR(value uint8) {
	volatile.StoreUint8(&o.SRAMPRCR.Reg, volatile.LoadUint8(&o.SRAMPRCR.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetSRAMPRCR() uint8 {
	return volatile.LoadUint8(&o.SRAMPRCR.Reg) & 0x1
}
func (o *SRAM_Type) SetSRAMPRCR_KW(value uint8) {
	volatile.StoreUint8(&o.SRAMPRCR.Reg, volatile.LoadUint8(&o.SRAMPRCR.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetSRAMPRCR_KW() uint8 {
	return (volatile.LoadUint8(&o.SRAMPRCR.Reg) & 0xfe) >> 1
}

// SRAM.ECCMODE: ECC Operating Mode Control Register
func (o *SRAM_Type) SetECCMODE_ECCMOD(value uint8) {
	volatile.StoreUint8(&o.ECCMODE.Reg, volatile.LoadUint8(&o.ECCMODE.Reg)&^(0x3)|value)
}
func (o *SRAM_Type) GetECCMODE_ECCMOD() uint8 {
	return volatile.LoadUint8(&o.ECCMODE.Reg) & 0x3
}

// SRAM.ECC2STS: ECC 2-Bit Error Status Register
func (o *SRAM_Type) SetECC2STS_ECC2ERR(value uint8) {
	volatile.StoreUint8(&o.ECC2STS.Reg, volatile.LoadUint8(&o.ECC2STS.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECC2STS_ECC2ERR() uint8 {
	return volatile.LoadUint8(&o.ECC2STS.Reg) & 0x1
}

// SRAM.ECC1STSEN: ECC 1-Bit Error Information Update Enable Register
func (o *SRAM_Type) SetECC1STSEN_E1STSEN(value uint8) {
	volatile.StoreUint8(&o.ECC1STSEN.Reg, volatile.LoadUint8(&o.ECC1STSEN.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECC1STSEN_E1STSEN() uint8 {
	return volatile.LoadUint8(&o.ECC1STSEN.Reg) & 0x1
}

// SRAM.ECC1STS: ECC 1-Bit Error Status Register
func (o *SRAM_Type) SetECC1STS_ECC1ERR(value uint8) {
	volatile.StoreUint8(&o.ECC1STS.Reg, volatile.LoadUint8(&o.ECC1STS.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECC1STS_ECC1ERR() uint8 {
	return volatile.LoadUint8(&o.ECC1STS.Reg) & 0x1
}

// SRAM.ECCPRCR: ECC Protection Register
func (o *SRAM_Type) SetECCPRCR(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR.Reg, volatile.LoadUint8(&o.ECCPRCR.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCPRCR() uint8 {
	return volatile.LoadUint8(&o.ECCPRCR.Reg) & 0x1
}
func (o *SRAM_Type) SetECCPRCR_KW(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR.Reg, volatile.LoadUint8(&o.ECCPRCR.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECCPRCR_KW() uint8 {
	return (volatile.LoadUint8(&o.ECCPRCR.Reg) & 0xfe) >> 1
}

// SRAM.ECCPRCR2: ECC Protection Register 2
func (o *SRAM_Type) SetECCPRCR2(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR2.Reg, volatile.LoadUint8(&o.ECCPRCR2.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCPRCR2() uint8 {
	return volatile.LoadUint8(&o.ECCPRCR2.Reg) & 0x1
}
func (o *SRAM_Type) SetECCPRCR2_KW2(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR2.Reg, volatile.LoadUint8(&o.ECCPRCR2.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECCPRCR2_KW2() uint8 {
	return (volatile.LoadUint8(&o.ECCPRCR2.Reg) & 0xfe) >> 1
}

// SRAM.ECCETST: ECC Test Control Register
func (o *SRAM_Type) SetECCETST_TSTBYP(value uint8) {
	volatile.StoreUint8(&o.ECCETST.Reg, volatile.LoadUint8(&o.ECCETST.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCETST_TSTBYP() uint8 {
	return volatile.LoadUint8(&o.ECCETST.Reg) & 0x1
}

// SRAM.ECCOAD: SRAM ECC Error Operation After Detection Register
func (o *SRAM_Type) SetECCOAD_OAD(value uint8) {
	volatile.StoreUint8(&o.ECCOAD.Reg, volatile.LoadUint8(&o.ECCOAD.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCOAD_OAD() uint8 {
	return volatile.LoadUint8(&o.ECCOAD.Reg) & 0x1
}

// BUS Control
type BUS_Type struct {
	_           [4104]byte
	BUSMCNTSYS  volatile.Register16 // 0x1008
	_           [2]byte
	BUSMCNTDMA  volatile.Register16 // 0x100C
	_           [2066]byte
	BUS3ERRADD  volatile.Register32 // 0x1820
	BUS3ERRSTAT volatile.Register8  // 0x1824
	_           [11]byte
	BUS4ERRADD  volatile.Register32 // 0x1830
	BUS4ERRSTAT volatile.Register8  // 0x1834
}

// BUS.BUSMCNTSYS: Master Bus Control Register SYS
func (o *BUS_Type) SetBUSMCNTSYS_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTSYS.Reg, volatile.LoadUint16(&o.BUSMCNTSYS.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTSYS_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTSYS.Reg) & 0x8000) >> 15
}

// BUS.BUSMCNTDMA: Master Bus Control Register DMA
func (o *BUS_Type) SetBUSMCNTDMA_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTDMA.Reg, volatile.LoadUint16(&o.BUSMCNTDMA.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTDMA_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTDMA.Reg) & 0x8000) >> 15
}

// BUS.BUS3ERRADD: Bus Error Address Register 3
func (o *BUS_Type) SetBUS3ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS3ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS3ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS3ERRADD.Reg)
}

// BUS.BUS3ERRSTAT: BUS Error Status Register 3
func (o *BUS_Type) SetBUS3ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS3ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x1
}
func (o *BUS_Type) SetBUS3ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS3ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x80) >> 7
}

// BUS.BUS4ERRADD: Bus Error Address Register 4
func (o *BUS_Type) SetBUS4ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS4ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS4ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS4ERRADD.Reg)
}

// BUS.BUS4ERRSTAT: BUS Error Status Register 4
func (o *BUS_Type) SetBUS4ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS4ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x1
}
func (o *BUS_Type) SetBUS4ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS4ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x80) >> 7
}

// Data Transfer Controller
type DTC_Type struct {
	DTCCR  volatile.Register8 // 0x0
	_      [3]byte
	DTCVBR volatile.Register32 // 0x4
	_      [4]byte
	DTCST  volatile.Register8 // 0xC
	_      byte
	DTCSTS volatile.Register16 // 0xE
}

// DTC.DTCCR: DTC Control Register
func (o *DTC_Type) SetDTCCR_RRS(value uint8) {
	volatile.StoreUint8(&o.DTCCR.Reg, volatile.LoadUint8(&o.DTCCR.Reg)&^(0x10)|value<<4)
}
func (o *DTC_Type) GetDTCCR_RRS() uint8 {
	return (volatile.LoadUint8(&o.DTCCR.Reg) & 0x10) >> 4
}

// DTC.DTCST: DTC Module Start Register
func (o *DTC_Type) SetDTCST(value uint8) {
	volatile.StoreUint8(&o.DTCST.Reg, volatile.LoadUint8(&o.DTCST.Reg)&^(0x1)|value)
}
func (o *DTC_Type) GetDTCST() uint8 {
	return volatile.LoadUint8(&o.DTCST.Reg) & 0x1
}

// DTC.DTCSTS: DTC Status Register
func (o *DTC_Type) SetDTCSTS_VECN(value uint16) {
	volatile.StoreUint16(&o.DTCSTS.Reg, volatile.LoadUint16(&o.DTCSTS.Reg)&^(0xff)|value)
}
func (o *DTC_Type) GetDTCSTS_VECN() uint16 {
	return volatile.LoadUint16(&o.DTCSTS.Reg) & 0xff
}
func (o *DTC_Type) SetDTCSTS_ACT(value uint16) {
	volatile.StoreUint16(&o.DTCSTS.Reg, volatile.LoadUint16(&o.DTCSTS.Reg)&^(0x8000)|value<<15)
}
func (o *DTC_Type) GetDTCSTS_ACT() uint16 {
	return (volatile.LoadUint16(&o.DTCSTS.Reg) & 0x8000) >> 15
}

// ICU for CPU
type ICU_Type struct {
	IRQCR0  volatile.Register8 // 0x0
	IRQCR1  volatile.Register8 // 0x1
	IRQCR2  volatile.Register8 // 0x2
	IRQCR3  volatile.Register8 // 0x3
	IRQCR4  volatile.Register8 // 0x4
	IRQCR5  volatile.Register8 // 0x5
	IRQCR6  volatile.Register8 // 0x6
	IRQCR7  volatile.Register8 // 0x7
	_       [248]byte
	NMICR   volatile.Register8 // 0x100
	_       [31]byte
	NMIER   volatile.Register16 // 0x120
	_       [14]byte
	NMICLR  volatile.Register16 // 0x130
	_       [14]byte
	NMISR   volatile.Register16 // 0x140
	_       [94]byte
	WUPEN   volatile.Register32 // 0x1A0
	_       [28]byte
	IELEN   volatile.Register8 // 0x1C0
	_       [63]byte
	SELSR0  volatile.Register16 // 0x200
	_       [254]byte
	IELSR0  volatile.Register32 // 0x300
	IELSR1  volatile.Register32 // 0x304
	IELSR2  volatile.Register32 // 0x308
	IELSR3  volatile.Register32 // 0x30C
	IELSR4  volatile.Register32 // 0x310
	IELSR5  volatile.Register32 // 0x314
	IELSR6  volatile.Register32 // 0x318
	IELSR7  volatile.Register32 // 0x31C
	IELSR8  volatile.Register32 // 0x320
	IELSR9  volatile.Register32 // 0x324
	IELSR10 volatile.Register32 // 0x328
	IELSR11 volatile.Register32 // 0x32C
	IELSR12 volatile.Register32 // 0x330
	IELSR13 volatile.Register32 // 0x334
	IELSR14 volatile.Register32 // 0x338
	IELSR15 volatile.Register32 // 0x33C
	IELSR16 volatile.Register32 // 0x340
	IELSR17 volatile.Register32 // 0x344
	IELSR18 volatile.Register32 // 0x348
	IELSR19 volatile.Register32 // 0x34C
	IELSR20 volatile.Register32 // 0x350
	IELSR21 volatile.Register32 // 0x354
	IELSR22 volatile.Register32 // 0x358
	IELSR23 volatile.Register32 // 0x35C
	IELSR24 volatile.Register32 // 0x360
	IELSR25 volatile.Register32 // 0x364
	IELSR26 volatile.Register32 // 0x368
	IELSR27 volatile.Register32 // 0x36C
	IELSR28 volatile.Register32 // 0x370
	IELSR29 volatile.Register32 // 0x374
	IELSR30 volatile.Register32 // 0x378
	IELSR31 volatile.Register32 // 0x37C
}

// ICU.IRQCR0: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR0_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR0_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR0.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR0_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR0_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR0_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR0_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0x80) >> 7
}

// ICU.IRQCR1: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR1_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR1_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR1.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR1_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR1_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR1_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR1_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0x80) >> 7
}

// ICU.IRQCR2: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR2_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR2_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR2.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR2_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR2_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR2_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR2_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0x80) >> 7
}

// ICU.IRQCR3: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR3_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR3_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR3.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR3_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR3_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR3_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR3_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0x80) >> 7
}

// ICU.IRQCR4: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR4_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR4_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR4.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR4_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR4_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR4_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR4_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0x80) >> 7
}

// ICU.IRQCR5: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR5_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR5_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR5.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR5_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR5_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR5_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR5_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0x80) >> 7
}

// ICU.IRQCR6: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR6_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR6_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR6.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR6_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR6_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR6_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR6_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0x80) >> 7
}

// ICU.IRQCR7: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR7_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR7_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR7.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR7_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR7_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR7_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR7_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0x80) >> 7
}

// ICU.NMICR: NMI Pin Interrupt Control Register
func (o *ICU_Type) SetNMICR_NMIMD(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMICR_NMIMD() uint8 {
	return volatile.LoadUint8(&o.NMICR.Reg) & 0x1
}
func (o *ICU_Type) SetNMICR_NFCLKSEL(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetNMICR_NFCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetNMICR_NFLTEN(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMICR_NFLTEN() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0x80) >> 7
}

// ICU.NMIER: Non-Maskable Interrupt Enable Register
func (o *ICU_Type) SetNMIER_IWDTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMIER_IWDTEN() uint16 {
	return volatile.LoadUint16(&o.NMIER.Reg) & 0x1
}
func (o *ICU_Type) SetNMIER_WDTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMIER_WDTEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMIER_LVD1EN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMIER_LVD1EN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMIER_LVD2EN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMIER_LVD2EN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMIER_OSTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMIER_OSTEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMIER_NMIEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMIER_NMIEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMIER_RPEEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMIER_RPEEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMIER_RECCEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetNMIER_RECCEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetNMIER_BUSSEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetNMIER_BUSSEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetNMIER_BUSMEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMIER_BUSMEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMIER_SPEEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetNMIER_SPEEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x1000) >> 12
}

// ICU.NMICLR: Non-Maskable Interrupt Status Clear Register
func (o *ICU_Type) SetNMICLR_IWDTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMICLR_IWDTCLR() uint16 {
	return volatile.LoadUint16(&o.NMICLR.Reg) & 0x1
}
func (o *ICU_Type) SetNMICLR_WDTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMICLR_WDTCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMICLR_LVD1CLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMICLR_LVD1CLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMICLR_LVD2CLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMICLR_LVD2CLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMICLR_OSTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMICLR_OSTCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMICLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMICLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMICLR_RPECLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMICLR_RPECLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMICLR_RECCCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetNMICLR_RECCCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetNMICLR_BUSSCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetNMICLR_BUSSCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetNMICLR_BUSMCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMICLR_BUSMCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMICLR_SPECLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetNMICLR_SPECLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x1000) >> 12
}

// ICU.NMISR: Non-Maskable Interrupt Status Register
func (o *ICU_Type) SetNMISR_IWDTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMISR_IWDTST() uint16 {
	return volatile.LoadUint16(&o.NMISR.Reg) & 0x1
}
func (o *ICU_Type) SetNMISR_WDTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMISR_WDTST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMISR_LVD1ST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMISR_LVD1ST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMISR_LVD2ST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMISR_LVD2ST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMISR_OSTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMISR_OSTST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMISR_NMIST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMISR_NMIST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMISR_RPEST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMISR_RPEST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMISR_RECCST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetNMISR_RECCST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetNMISR_BUSSST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetNMISR_BUSSST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetNMISR_BUSMST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMISR_BUSMST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMISR_SPEST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetNMISR_SPEST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x1000) >> 12
}

// ICU.WUPEN: Wake Up Interrupt Enable Register
func (o *ICU_Type) SetWUPEN_IRQWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN() uint32 {
	return volatile.LoadUint32(&o.WUPEN.Reg) & 0xff
}
func (o *ICU_Type) SetWUPEN_IWDTWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetWUPEN_IWDTWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetWUPEN_KEYWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x20000)|value<<17)
}
func (o *ICU_Type) GetWUPEN_KEYWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x20000) >> 17
}
func (o *ICU_Type) SetWUPEN_LVD1WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x40000)|value<<18)
}
func (o *ICU_Type) GetWUPEN_LVD1WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x40000) >> 18
}
func (o *ICU_Type) SetWUPEN_LVD2WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x80000)|value<<19)
}
func (o *ICU_Type) GetWUPEN_LVD2WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x80000) >> 19
}
func (o *ICU_Type) SetWUPEN_ACMPLP0WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x800000)|value<<23)
}
func (o *ICU_Type) GetWUPEN_ACMPLP0WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x800000) >> 23
}
func (o *ICU_Type) SetWUPEN_RTCALMWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetWUPEN_RTCALMWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetWUPEN_RTCPRDWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x2000000)|value<<25)
}
func (o *ICU_Type) GetWUPEN_RTCPRDWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x2000000) >> 25
}
func (o *ICU_Type) SetWUPEN_AGT1UDWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x10000000)|value<<28)
}
func (o *ICU_Type) GetWUPEN_AGT1UDWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x10000000) >> 28
}
func (o *ICU_Type) SetWUPEN_AGT1CAWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x20000000)|value<<29)
}
func (o *ICU_Type) GetWUPEN_AGT1CAWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x20000000) >> 29
}
func (o *ICU_Type) SetWUPEN_AGT1CBWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x40000000)|value<<30)
}
func (o *ICU_Type) GetWUPEN_AGT1CBWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x40000000) >> 30
}
func (o *ICU_Type) SetWUPEN_IIC0WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x80000000)|value<<31)
}
func (o *ICU_Type) GetWUPEN_IIC0WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x80000000) >> 31
}

// ICU.IELEN: ICU event Enable Register
func (o *ICU_Type) SetIELEN_RTCINTEN(value uint8) {
	volatile.StoreUint8(&o.IELEN.Reg, volatile.LoadUint8(&o.IELEN.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetIELEN_RTCINTEN() uint8 {
	return volatile.LoadUint8(&o.IELEN.Reg) & 0x1
}
func (o *ICU_Type) SetIELEN(value uint8) {
	volatile.StoreUint8(&o.IELEN.Reg, volatile.LoadUint8(&o.IELEN.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetIELEN() uint8 {
	return (volatile.LoadUint8(&o.IELEN.Reg) & 0x2) >> 1
}

// Debug Function
type DBG_Type struct {
	DBGSTR    volatile.Register32 // 0x0
	_         [12]byte
	DBGSTOPCR volatile.Register32 // 0x10
}

// DBG.DBGSTR: Debug Status Register
func (o *DBG_Type) SetDBGSTR_CDBGPWRUPREQ(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0x10000000)|value<<28)
}
func (o *DBG_Type) GetDBGSTR_CDBGPWRUPREQ() uint32 {
	return (volatile.LoadUint32(&o.DBGSTR.Reg) & 0x10000000) >> 28
}
func (o *DBG_Type) SetDBGSTR_CDBGPWRUPACK(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0x20000000)|value<<29)
}
func (o *DBG_Type) GetDBGSTR_CDBGPWRUPACK() uint32 {
	return (volatile.LoadUint32(&o.DBGSTR.Reg) & 0x20000000) >> 29
}

// DBG.DBGSTOPCR: Debug Stop Control Register
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_IWDT(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x1)|value)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_IWDT() uint32 {
	return volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x1
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_WDT(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x2)|value<<1)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_WDT() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x2) >> 1
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_LVD0(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x10000)|value<<16)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_LVD0() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x10000) >> 16
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_LVD1(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x20000)|value<<17)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_LVD1() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x20000) >> 17
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_LVD2(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x40000)|value<<18)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_LVD2() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x40000) >> 18
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_RPER(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_RPER() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x1000000) >> 24
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_RECCR(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x2000000)|value<<25)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_RECCR() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x2000000) >> 25
}

// System Control
type SYSC_Type struct {
	_         [12]byte
	SBYCR     volatile.Register16 // 0xC
	_         [14]byte
	MSTPCRA   volatile.Register32 // 0x1C
	SCKDIVCR  volatile.Register32 // 0x20
	_         [2]byte
	SCKSCR    volatile.Register8 // 0x26
	_         [10]byte
	MEMWAIT   volatile.Register8 // 0x31
	MOSCCR    volatile.Register8 // 0x32
	_         [3]byte
	HOCOCR    volatile.Register8 // 0x36
	_         byte
	MOCOCR    volatile.Register8 // 0x38
	_         [3]byte
	OSCSF     volatile.Register8 // 0x3C
	_         byte
	CKOCR     volatile.Register8 // 0x3E
	_         byte
	OSTDCR    volatile.Register8 // 0x40
	OSTDSR    volatile.Register8 // 0x41
	_         [10]byte
	LPOPT     volatile.Register8 // 0x4C
	_         [20]byte
	MOCOUTCR  volatile.Register8 // 0x61
	HOCOUTCR  volatile.Register8 // 0x62
	_         [47]byte
	SNZCR     volatile.Register8 // 0x92
	_         byte
	SNZEDCR0  volatile.Register8 // 0x94
	_         [3]byte
	SNZREQCR0 volatile.Register32 // 0x98
	_         [3]byte
	PSMCR     volatile.Register8 // 0x9F
	OPCCR     volatile.Register8 // 0xA0
	_         byte
	MOSCWTCR  volatile.Register8 // 0xA2
	_         [7]byte
	SOPCCR    volatile.Register8 // 0xAA
	_         [21]byte
	RSTSR1    volatile.Register16 // 0xC0
	_         [30]byte
	LVD1CR1   volatile.Register8 // 0xE0
	LVD1SR    volatile.Register8 // 0xE1
	LVD2CR1   volatile.Register8 // 0xE2
	LVD2SR    volatile.Register8 // 0xE3
	_         [794]byte
	PRCR      volatile.Register16 // 0x3FE
	_         [14]byte
	SYOCDCR   volatile.Register8 // 0x40E
	_         byte
	RSTSR0    volatile.Register8 // 0x410
	RSTSR2    volatile.Register8 // 0x411
	_         byte
	MOMCR     volatile.Register8 // 0x413
	_         [3]byte
	LVCMPCR   volatile.Register8 // 0x417
	LVDLVLR   volatile.Register8 // 0x418
	_         byte
	LVD1CR0   volatile.Register8 // 0x41A
	LVD2CR0   volatile.Register8 // 0x41B
	_         [36]byte
	DCDCCTL   volatile.Register8 // 0x440
	VCCSEL    volatile.Register8 // 0x441
	_         [62]byte
	SOSCCR    volatile.Register8 // 0x480
	SOMCR     volatile.Register8 // 0x481
	SOMRG     volatile.Register8 // 0x482
	_         [13]byte
	LOCOCR    volatile.Register8 // 0x490
	_         byte
	LOCOUTCR  volatile.Register8 // 0x492
}

// SYSC.SBYCR: Standby Control Register
func (o *SYSC_Type) SetSBYCR_SSBY(value uint16) {
	volatile.StoreUint16(&o.SBYCR.Reg, volatile.LoadUint16(&o.SBYCR.Reg)&^(0x8000)|value<<15)
}
func (o *SYSC_Type) GetSBYCR_SSBY() uint16 {
	return (volatile.LoadUint16(&o.SBYCR.Reg) & 0x8000) >> 15
}

// SYSC.MSTPCRA: Module Stop Control Register A
func (o *SYSC_Type) SetMSTPCRA_MSTPA22(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x400000)|value<<22)
}
func (o *SYSC_Type) GetMSTPCRA_MSTPA22() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x400000) >> 22
}

// SYSC.SCKDIVCR: System Clock Division Control Register
func (o *SYSC_Type) SetSCKDIVCR_PCKD(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x7)|value)
}
func (o *SYSC_Type) GetSCKDIVCR_PCKD() uint32 {
	return volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x7
}
func (o *SYSC_Type) SetSCKDIVCR_PCKB(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x700)|value<<8)
}
func (o *SYSC_Type) GetSCKDIVCR_PCKB() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x700) >> 8
}
func (o *SYSC_Type) SetSCKDIVCR_ICK(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x7000000)|value<<24)
}
func (o *SYSC_Type) GetSCKDIVCR_ICK() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x7000000) >> 24
}

// SYSC.SCKSCR: System Clock Source Control Register
func (o *SYSC_Type) SetSCKSCR_CKSEL(value uint8) {
	volatile.StoreUint8(&o.SCKSCR.Reg, volatile.LoadUint8(&o.SCKSCR.Reg)&^(0x7)|value)
}
func (o *SYSC_Type) GetSCKSCR_CKSEL() uint8 {
	return volatile.LoadUint8(&o.SCKSCR.Reg) & 0x7
}

// SYSC.MEMWAIT: Memory Wait Cycle Control Register for Code Flash
func (o *SYSC_Type) SetMEMWAIT(value uint8) {
	volatile.StoreUint8(&o.MEMWAIT.Reg, volatile.LoadUint8(&o.MEMWAIT.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetMEMWAIT() uint8 {
	return volatile.LoadUint8(&o.MEMWAIT.Reg) & 0x1
}

// SYSC.MOSCCR: Main Clock Oscillator Control Register
func (o *SYSC_Type) SetMOSCCR_MOSTP(value uint8) {
	volatile.StoreUint8(&o.MOSCCR.Reg, volatile.LoadUint8(&o.MOSCCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetMOSCCR_MOSTP() uint8 {
	return volatile.LoadUint8(&o.MOSCCR.Reg) & 0x1
}

// SYSC.HOCOCR: High-Speed On-Chip Oscillator Control Register
func (o *SYSC_Type) SetHOCOCR_HCSTP(value uint8) {
	volatile.StoreUint8(&o.HOCOCR.Reg, volatile.LoadUint8(&o.HOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetHOCOCR_HCSTP() uint8 {
	return volatile.LoadUint8(&o.HOCOCR.Reg) & 0x1
}

// SYSC.MOCOCR: Middle-Speed On-Chip Oscillator Control Register
func (o *SYSC_Type) SetMOCOCR_MCSTP(value uint8) {
	volatile.StoreUint8(&o.MOCOCR.Reg, volatile.LoadUint8(&o.MOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetMOCOCR_MCSTP() uint8 {
	return volatile.LoadUint8(&o.MOCOCR.Reg) & 0x1
}

// SYSC.OSCSF: Oscillation Stabilization Flag Register
func (o *SYSC_Type) SetOSCSF_HOCOSF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetOSCSF_HOCOSF() uint8 {
	return volatile.LoadUint8(&o.OSCSF.Reg) & 0x1
}
func (o *SYSC_Type) SetOSCSF_MOSCSF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetOSCSF_MOSCSF() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0x8) >> 3
}

// SYSC.CKOCR: Clock Out Control Register
func (o *SYSC_Type) SetCKOCR_CKOSEL(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x7)|value)
}
func (o *SYSC_Type) GetCKOCR_CKOSEL() uint8 {
	return volatile.LoadUint8(&o.CKOCR.Reg) & 0x7
}
func (o *SYSC_Type) SetCKOCR_CKODIV(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x70)|value<<4)
}
func (o *SYSC_Type) GetCKOCR_CKODIV() uint8 {
	return (volatile.LoadUint8(&o.CKOCR.Reg) & 0x70) >> 4
}
func (o *SYSC_Type) SetCKOCR_CKOEN(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetCKOCR_CKOEN() uint8 {
	return (volatile.LoadUint8(&o.CKOCR.Reg) & 0x80) >> 7
}

// SYSC.OSTDCR: Oscillation Stop Detection Control Register
func (o *SYSC_Type) SetOSTDCR_OSTDIE(value uint8) {
	volatile.StoreUint8(&o.OSTDCR.Reg, volatile.LoadUint8(&o.OSTDCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetOSTDCR_OSTDIE() uint8 {
	return volatile.LoadUint8(&o.OSTDCR.Reg) & 0x1
}
func (o *SYSC_Type) SetOSTDCR_OSTDE(value uint8) {
	volatile.StoreUint8(&o.OSTDCR.Reg, volatile.LoadUint8(&o.OSTDCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetOSTDCR_OSTDE() uint8 {
	return (volatile.LoadUint8(&o.OSTDCR.Reg) & 0x80) >> 7
}

// SYSC.OSTDSR: Oscillation Stop Detection Status Register
func (o *SYSC_Type) SetOSTDSR_OSTDF(value uint8) {
	volatile.StoreUint8(&o.OSTDSR.Reg, volatile.LoadUint8(&o.OSTDSR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetOSTDSR_OSTDF() uint8 {
	return volatile.LoadUint8(&o.OSTDSR.Reg) & 0x1
}

// SYSC.LPOPT: Lower Power Operation Control Register
func (o *SYSC_Type) SetLPOPT_MPUDIS(value uint8) {
	volatile.StoreUint8(&o.LPOPT.Reg, volatile.LoadUint8(&o.LPOPT.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetLPOPT_MPUDIS() uint8 {
	return volatile.LoadUint8(&o.LPOPT.Reg) & 0x1
}
func (o *SYSC_Type) SetLPOPT_DCLKDIS(value uint8) {
	volatile.StoreUint8(&o.LPOPT.Reg, volatile.LoadUint8(&o.LPOPT.Reg)&^(0x6)|value<<1)
}
func (o *SYSC_Type) GetLPOPT_DCLKDIS() uint8 {
	return (volatile.LoadUint8(&o.LPOPT.Reg) & 0x6) >> 1
}
func (o *SYSC_Type) SetLPOPT_BPFCLKDIS(value uint8) {
	volatile.StoreUint8(&o.LPOPT.Reg, volatile.LoadUint8(&o.LPOPT.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetLPOPT_BPFCLKDIS() uint8 {
	return (volatile.LoadUint8(&o.LPOPT.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetLPOPT_LPOPTEN(value uint8) {
	volatile.StoreUint8(&o.LPOPT.Reg, volatile.LoadUint8(&o.LPOPT.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetLPOPT_LPOPTEN() uint8 {
	return (volatile.LoadUint8(&o.LPOPT.Reg) & 0x80) >> 7
}

// SYSC.MOCOUTCR: MOCO User Trimming Control Register
func (o *SYSC_Type) SetMOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.MOCOUTCR.Reg, value)
}
func (o *SYSC_Type) GetMOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.MOCOUTCR.Reg)
}

// SYSC.HOCOUTCR: HOCO User Trimming Control Register
func (o *SYSC_Type) SetHOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.HOCOUTCR.Reg, value)
}
func (o *SYSC_Type) GetHOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.HOCOUTCR.Reg)
}

// SYSC.SNZCR: Snooze Control Register
func (o *SYSC_Type) SetSNZCR_RXDREQEN(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSNZCR_RXDREQEN() uint8 {
	return volatile.LoadUint8(&o.SNZCR.Reg) & 0x1
}
func (o *SYSC_Type) SetSNZCR_SNZDTCEN(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetSNZCR_SNZDTCEN() uint8 {
	return (volatile.LoadUint8(&o.SNZCR.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetSNZCR_SNZE(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetSNZCR_SNZE() uint8 {
	return (volatile.LoadUint8(&o.SNZCR.Reg) & 0x80) >> 7
}

// SYSC.SNZEDCR0: Snooze End Control Register 0
func (o *SYSC_Type) SetSNZEDCR0_AGTUNFED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR0.Reg, volatile.LoadUint8(&o.SNZEDCR0.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSNZEDCR0_AGTUNFED() uint8 {
	return volatile.LoadUint8(&o.SNZEDCR0.Reg) & 0x1
}
func (o *SYSC_Type) SetSNZEDCR0_DTCZRED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR0.Reg, volatile.LoadUint8(&o.SNZEDCR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetSNZEDCR0_DTCZRED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR0.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetSNZEDCR0_DTCNZRED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR0.Reg, volatile.LoadUint8(&o.SNZEDCR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetSNZEDCR0_DTCNZRED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR0.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetSNZEDCR0_AD0MATED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR0.Reg, volatile.LoadUint8(&o.SNZEDCR0.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetSNZEDCR0_AD0MATED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR0.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetSNZEDCR0_AD0UMTED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR0.Reg, volatile.LoadUint8(&o.SNZEDCR0.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetSNZEDCR0_AD0UMTED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR0.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetSNZEDCR0_SCI0UMTED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR0.Reg, volatile.LoadUint8(&o.SNZEDCR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetSNZEDCR0_SCI0UMTED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR0.Reg) & 0x80) >> 7
}

// SYSC.SNZREQCR0: Snooze Request Control Register 0
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN0(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN0() uint32 {
	return volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x1
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN1(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN1() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN2(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN2() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN3(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN3() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN4(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN4() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN5(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x20)|value<<5)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN5() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x20) >> 5
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN6(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN6() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN7(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN7() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x80) >> 7
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN17(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN17() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x20000) >> 17
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN23(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN23() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x800000) >> 23
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN24(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN24() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x1000000) >> 24
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN25(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN25() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x2000000) >> 25
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN28(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN28() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x10000000) >> 28
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN29(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN29() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x20000000) >> 29
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN30(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN30() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x40000000) >> 30
}

// SYSC.PSMCR: Power Save Memory Control Register
func (o *SYSC_Type) SetPSMCR_PSMC(value uint8) {
	volatile.StoreUint8(&o.PSMCR.Reg, volatile.LoadUint8(&o.PSMCR.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetPSMCR_PSMC() uint8 {
	return volatile.LoadUint8(&o.PSMCR.Reg) & 0x3
}

// SYSC.OPCCR: Operating Power Control Register
func (o *SYSC_Type) SetOPCCR_OPCM(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetOPCCR_OPCM() uint8 {
	return volatile.LoadUint8(&o.OPCCR.Reg) & 0x3
}
func (o *SYSC_Type) SetOPCCR_OPCMTSF(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetOPCCR_OPCMTSF() uint8 {
	return (volatile.LoadUint8(&o.OPCCR.Reg) & 0x10) >> 4
}

// SYSC.MOSCWTCR: Main Clock Oscillator Wait Control Register
func (o *SYSC_Type) SetMOSCWTCR_MSTS(value uint8) {
	volatile.StoreUint8(&o.MOSCWTCR.Reg, volatile.LoadUint8(&o.MOSCWTCR.Reg)&^(0xf)|value)
}
func (o *SYSC_Type) GetMOSCWTCR_MSTS() uint8 {
	return volatile.LoadUint8(&o.MOSCWTCR.Reg) & 0xf
}

// SYSC.SOPCCR: Sub Operating Power Control Register
func (o *SYSC_Type) SetSOPCCR_SOPCM(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSOPCCR_SOPCM() uint8 {
	return volatile.LoadUint8(&o.SOPCCR.Reg) & 0x1
}
func (o *SYSC_Type) SetSOPCCR_SOPCMTSF(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetSOPCCR_SOPCMTSF() uint8 {
	return (volatile.LoadUint8(&o.SOPCCR.Reg) & 0x10) >> 4
}

// SYSC.RSTSR1: Reset Status Register 1
func (o *SYSC_Type) SetRSTSR1_IWDTRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetRSTSR1_IWDTRF() uint16 {
	return volatile.LoadUint16(&o.RSTSR1.Reg) & 0x1
}
func (o *SYSC_Type) SetRSTSR1_WDTRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetRSTSR1_WDTRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetRSTSR1_SWRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetRSTSR1_SWRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetRSTSR1_RPERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x100)|value<<8)
}
func (o *SYSC_Type) GetRSTSR1_RPERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x100) >> 8
}
func (o *SYSC_Type) SetRSTSR1_REERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x200)|value<<9)
}
func (o *SYSC_Type) GetRSTSR1_REERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x200) >> 9
}
func (o *SYSC_Type) SetRSTSR1_BUSSRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x400)|value<<10)
}
func (o *SYSC_Type) GetRSTSR1_BUSSRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x400) >> 10
}
func (o *SYSC_Type) SetRSTSR1_BUSMRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x800)|value<<11)
}
func (o *SYSC_Type) GetRSTSR1_BUSMRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x800) >> 11
}
func (o *SYSC_Type) SetRSTSR1_SPERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x1000)|value<<12)
}
func (o *SYSC_Type) GetRSTSR1_SPERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x1000) >> 12
}

// SYSC.LVD1CR1: Voltage Monitor 1 Circuit Control Register
func (o *SYSC_Type) SetLVD1CR1_IDTSEL(value uint8) {
	volatile.StoreUint8(&o.LVD1CR1.Reg, volatile.LoadUint8(&o.LVD1CR1.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetLVD1CR1_IDTSEL() uint8 {
	return volatile.LoadUint8(&o.LVD1CR1.Reg) & 0x3
}
func (o *SYSC_Type) SetLVD1CR1_IRQSEL(value uint8) {
	volatile.StoreUint8(&o.LVD1CR1.Reg, volatile.LoadUint8(&o.LVD1CR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetLVD1CR1_IRQSEL() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR1.Reg) & 0x4) >> 2
}

// SYSC.LVD1SR: Voltage Monitor 1 Circuit Status Register
func (o *SYSC_Type) SetLVD1SR_DET(value uint8) {
	volatile.StoreUint8(&o.LVD1SR.Reg, volatile.LoadUint8(&o.LVD1SR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetLVD1SR_DET() uint8 {
	return volatile.LoadUint8(&o.LVD1SR.Reg) & 0x1
}
func (o *SYSC_Type) SetLVD1SR_MON(value uint8) {
	volatile.StoreUint8(&o.LVD1SR.Reg, volatile.LoadUint8(&o.LVD1SR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetLVD1SR_MON() uint8 {
	return (volatile.LoadUint8(&o.LVD1SR.Reg) & 0x2) >> 1
}

// SYSC.LVD2CR1: Voltage Monitor 2 Circuit Control Register 1
func (o *SYSC_Type) SetLVD2CR1_IDTSEL(value uint8) {
	volatile.StoreUint8(&o.LVD2CR1.Reg, volatile.LoadUint8(&o.LVD2CR1.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetLVD2CR1_IDTSEL() uint8 {
	return volatile.LoadUint8(&o.LVD2CR1.Reg) & 0x3
}
func (o *SYSC_Type) SetLVD2CR1_IRQSEL(value uint8) {
	volatile.StoreUint8(&o.LVD2CR1.Reg, volatile.LoadUint8(&o.LVD2CR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetLVD2CR1_IRQSEL() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR1.Reg) & 0x4) >> 2
}

// SYSC.LVD2SR: Voltage Monitor 2 Circuit Status Register
func (o *SYSC_Type) SetLVD2SR_DET(value uint8) {
	volatile.StoreUint8(&o.LVD2SR.Reg, volatile.LoadUint8(&o.LVD2SR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetLVD2SR_DET() uint8 {
	return volatile.LoadUint8(&o.LVD2SR.Reg) & 0x1
}
func (o *SYSC_Type) SetLVD2SR_MON(value uint8) {
	volatile.StoreUint8(&o.LVD2SR.Reg, volatile.LoadUint8(&o.LVD2SR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetLVD2SR_MON() uint8 {
	return (volatile.LoadUint8(&o.LVD2SR.Reg) & 0x2) >> 1
}

// SYSC.PRCR: Protect Register
func (o *SYSC_Type) SetPRCR_PRC0(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetPRCR_PRC0() uint16 {
	return volatile.LoadUint16(&o.PRCR.Reg) & 0x1
}
func (o *SYSC_Type) SetPRCR_PRC1(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetPRCR_PRC1() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetPRCR_PRC3(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetPRCR_PRC3() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetPRCR_PRKEY(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0xff00)|value<<8)
}
func (o *SYSC_Type) GetPRCR_PRKEY() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0xff00) >> 8
}

// SYSC.SYOCDCR: System Control OCD Control Register
func (o *SYSC_Type) SetSYOCDCR_DBGEN(value uint8) {
	volatile.StoreUint8(&o.SYOCDCR.Reg, volatile.LoadUint8(&o.SYOCDCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetSYOCDCR_DBGEN() uint8 {
	return (volatile.LoadUint8(&o.SYOCDCR.Reg) & 0x80) >> 7
}

// SYSC.RSTSR0: Reset Status Register 0
func (o *SYSC_Type) SetRSTSR0_PORF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetRSTSR0_PORF() uint8 {
	return volatile.LoadUint8(&o.RSTSR0.Reg) & 0x1
}
func (o *SYSC_Type) SetRSTSR0_LVD0RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetRSTSR0_LVD0RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetRSTSR0_LVD1RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetRSTSR0_LVD1RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetRSTSR0_LVD2RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetRSTSR0_LVD2RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x8) >> 3
}

// SYSC.RSTSR2: Reset Status Register 2
func (o *SYSC_Type) SetRSTSR2_CWSF(value uint8) {
	volatile.StoreUint8(&o.RSTSR2.Reg, volatile.LoadUint8(&o.RSTSR2.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetRSTSR2_CWSF() uint8 {
	return volatile.LoadUint8(&o.RSTSR2.Reg) & 0x1
}

// SYSC.MOMCR: Main Clock Oscillator Mode Oscillation Control Register
func (o *SYSC_Type) SetMOMCR_MODRV1(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetMOMCR_MODRV1() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetMOMCR_MOSEL(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetMOMCR_MOSEL() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x40) >> 6
}

// SYSC.LVCMPCR: Voltage Monitor Circuit Control Register
func (o *SYSC_Type) SetLVCMPCR_LVD1E(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0x20)|value<<5)
}
func (o *SYSC_Type) GetLVCMPCR_LVD1E() uint8 {
	return (volatile.LoadUint8(&o.LVCMPCR.Reg) & 0x20) >> 5
}
func (o *SYSC_Type) SetLVCMPCR_LVD2E(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetLVCMPCR_LVD2E() uint8 {
	return (volatile.LoadUint8(&o.LVCMPCR.Reg) & 0x40) >> 6
}

// SYSC.LVDLVLR: Voltage Detection Level Select Register
func (o *SYSC_Type) SetLVDLVLR_LVD1LVL(value uint8) {
	volatile.StoreUint8(&o.LVDLVLR.Reg, volatile.LoadUint8(&o.LVDLVLR.Reg)&^(0x1f)|value)
}
func (o *SYSC_Type) GetLVDLVLR_LVD1LVL() uint8 {
	return volatile.LoadUint8(&o.LVDLVLR.Reg) & 0x1f
}
func (o *SYSC_Type) SetLVDLVLR_LVD2LVL(value uint8) {
	volatile.StoreUint8(&o.LVDLVLR.Reg, volatile.LoadUint8(&o.LVDLVLR.Reg)&^(0xe0)|value<<5)
}
func (o *SYSC_Type) GetLVDLVLR_LVD2LVL() uint8 {
	return (volatile.LoadUint8(&o.LVDLVLR.Reg) & 0xe0) >> 5
}

// SYSC.LVD1CR0: Voltage Monitor 1 Circuit Control Register 0
func (o *SYSC_Type) SetLVD1CR0_RIE(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetLVD1CR0_RIE() uint8 {
	return volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x1
}
func (o *SYSC_Type) SetLVD1CR0_CMPE(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetLVD1CR0_CMPE() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetLVD1CR0_RI(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetLVD1CR0_RI() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetLVD1CR0_RN(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetLVD1CR0_RN() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x80) >> 7
}

// SYSC.LVD2CR0: Voltage Monitor 2 Circuit Control Register 0
func (o *SYSC_Type) SetLVD2CR0_RIE(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetLVD2CR0_RIE() uint8 {
	return volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x1
}
func (o *SYSC_Type) SetLVD2CR0_CMPE(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetLVD2CR0_CMPE() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetLVD2CR0_RI(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetLVD2CR0_RI() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetLVD2CR0_RN(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetLVD2CR0_RN() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x80) >> 7
}

// SYSC.DCDCCTL: DCDC/LDO Control Register
func (o *SYSC_Type) SetDCDCCTL_DCDCON(value uint8) {
	volatile.StoreUint8(&o.DCDCCTL.Reg, volatile.LoadUint8(&o.DCDCCTL.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetDCDCCTL_DCDCON() uint8 {
	return volatile.LoadUint8(&o.DCDCCTL.Reg) & 0x1
}
func (o *SYSC_Type) SetDCDCCTL_OCPEN(value uint8) {
	volatile.StoreUint8(&o.DCDCCTL.Reg, volatile.LoadUint8(&o.DCDCCTL.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetDCDCCTL_OCPEN() uint8 {
	return (volatile.LoadUint8(&o.DCDCCTL.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetDCDCCTL_STOPZA(value uint8) {
	volatile.StoreUint8(&o.DCDCCTL.Reg, volatile.LoadUint8(&o.DCDCCTL.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetDCDCCTL_STOPZA() uint8 {
	return (volatile.LoadUint8(&o.DCDCCTL.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetDCDCCTL_LCBOOST(value uint8) {
	volatile.StoreUint8(&o.DCDCCTL.Reg, volatile.LoadUint8(&o.DCDCCTL.Reg)&^(0x20)|value<<5)
}
func (o *SYSC_Type) GetDCDCCTL_LCBOOST() uint8 {
	return (volatile.LoadUint8(&o.DCDCCTL.Reg) & 0x20) >> 5
}
func (o *SYSC_Type) SetDCDCCTL_FST(value uint8) {
	volatile.StoreUint8(&o.DCDCCTL.Reg, volatile.LoadUint8(&o.DCDCCTL.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetDCDCCTL_FST() uint8 {
	return (volatile.LoadUint8(&o.DCDCCTL.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetDCDCCTL_PD(value uint8) {
	volatile.StoreUint8(&o.DCDCCTL.Reg, volatile.LoadUint8(&o.DCDCCTL.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetDCDCCTL_PD() uint8 {
	return (volatile.LoadUint8(&o.DCDCCTL.Reg) & 0x80) >> 7
}

// SYSC.VCCSEL: Voltage Level Selection Control Register
func (o *SYSC_Type) SetVCCSEL(value uint8) {
	volatile.StoreUint8(&o.VCCSEL.Reg, volatile.LoadUint8(&o.VCCSEL.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetVCCSEL() uint8 {
	return volatile.LoadUint8(&o.VCCSEL.Reg) & 0x3
}

// SYSC.SOSCCR: Sub-Clock Oscillator Control Register
func (o *SYSC_Type) SetSOSCCR_SOSTP(value uint8) {
	volatile.StoreUint8(&o.SOSCCR.Reg, volatile.LoadUint8(&o.SOSCCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSOSCCR_SOSTP() uint8 {
	return volatile.LoadUint8(&o.SOSCCR.Reg) & 0x1
}

// SYSC.SOMCR: Sub-Clock Oscillator Mode Control Register
func (o *SYSC_Type) SetSOMCR_SODRV(value uint8) {
	volatile.StoreUint8(&o.SOMCR.Reg, volatile.LoadUint8(&o.SOMCR.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetSOMCR_SODRV() uint8 {
	return volatile.LoadUint8(&o.SOMCR.Reg) & 0x3
}

// SYSC.SOMRG: Sub-Clock Oscillator Margin Check Register
func (o *SYSC_Type) SetSOMRG_SOSCMRG(value uint8) {
	volatile.StoreUint8(&o.SOMRG.Reg, volatile.LoadUint8(&o.SOMRG.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetSOMRG_SOSCMRG() uint8 {
	return volatile.LoadUint8(&o.SOMRG.Reg) & 0x3
}

// SYSC.LOCOCR: Low-Speed On-Chip Oscillator Control Register
func (o *SYSC_Type) SetLOCOCR_LCSTP(value uint8) {
	volatile.StoreUint8(&o.LOCOCR.Reg, volatile.LoadUint8(&o.LOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetLOCOCR_LCSTP() uint8 {
	return volatile.LoadUint8(&o.LOCOCR.Reg) & 0x1
}

// SYSC.LOCOUTCR: LOCO User Trimming Control Register
func (o *SYSC_Type) SetLOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.LOCOUTCR.Reg, value)
}
func (o *SYSC_Type) GetLOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.LOCOUTCR.Reg)
}

// Port 0 Control Registers
type PORT0_Type struct {
	PCNTR1 volatile.Register32 // 0x0
	PCNTR2 volatile.Register32 // 0x4
	PCNTR3 volatile.Register32 // 0x8
}

// PORT0.PCNTR1: Port Control Register 1
func (o *PORT0_Type) SetPCNTR1_PDR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x1)|value)
}
func (o *PORT0_Type) GetPCNTR1_PDR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR1.Reg) & 0x1
}
func (o *PORT0_Type) SetPCNTR1_PDR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x2)|value<<1)
}
func (o *PORT0_Type) GetPCNTR1_PDR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x2) >> 1
}
func (o *PORT0_Type) SetPCNTR1_PDR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x4)|value<<2)
}
func (o *PORT0_Type) GetPCNTR1_PDR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x4) >> 2
}
func (o *PORT0_Type) SetPCNTR1_PDR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x8)|value<<3)
}
func (o *PORT0_Type) GetPCNTR1_PDR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x8) >> 3
}
func (o *PORT0_Type) SetPCNTR1_PDR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x10)|value<<4)
}
func (o *PORT0_Type) GetPCNTR1_PDR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x10) >> 4
}
func (o *PORT0_Type) SetPCNTR1_PDR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x20)|value<<5)
}
func (o *PORT0_Type) GetPCNTR1_PDR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x20) >> 5
}
func (o *PORT0_Type) SetPCNTR1_PDR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x40)|value<<6)
}
func (o *PORT0_Type) GetPCNTR1_PDR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x40) >> 6
}
func (o *PORT0_Type) SetPCNTR1_PDR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x80)|value<<7)
}
func (o *PORT0_Type) GetPCNTR1_PDR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x80) >> 7
}
func (o *PORT0_Type) SetPCNTR1_PDR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x100)|value<<8)
}
func (o *PORT0_Type) GetPCNTR1_PDR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x100) >> 8
}
func (o *PORT0_Type) SetPCNTR1_PDR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x200)|value<<9)
}
func (o *PORT0_Type) GetPCNTR1_PDR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x200) >> 9
}
func (o *PORT0_Type) SetPCNTR1_PDR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x400)|value<<10)
}
func (o *PORT0_Type) GetPCNTR1_PDR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x400) >> 10
}
func (o *PORT0_Type) SetPCNTR1_PDR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x800)|value<<11)
}
func (o *PORT0_Type) GetPCNTR1_PDR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x800) >> 11
}
func (o *PORT0_Type) SetPCNTR1_PDR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x1000)|value<<12)
}
func (o *PORT0_Type) GetPCNTR1_PDR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x1000) >> 12
}
func (o *PORT0_Type) SetPCNTR1_PDR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x2000)|value<<13)
}
func (o *PORT0_Type) GetPCNTR1_PDR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x2000) >> 13
}
func (o *PORT0_Type) SetPCNTR1_PDR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x4000)|value<<14)
}
func (o *PORT0_Type) GetPCNTR1_PDR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x4000) >> 14
}
func (o *PORT0_Type) SetPCNTR1_PDR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x8000)|value<<15)
}
func (o *PORT0_Type) GetPCNTR1_PDR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x8000) >> 15
}
func (o *PORT0_Type) SetPCNTR1_PODR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x10000)|value<<16)
}
func (o *PORT0_Type) GetPCNTR1_PODR00() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x10000) >> 16
}
func (o *PORT0_Type) SetPCNTR1_PODR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x20000)|value<<17)
}
func (o *PORT0_Type) GetPCNTR1_PODR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x20000) >> 17
}
func (o *PORT0_Type) SetPCNTR1_PODR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x40000)|value<<18)
}
func (o *PORT0_Type) GetPCNTR1_PODR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x40000) >> 18
}
func (o *PORT0_Type) SetPCNTR1_PODR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x80000)|value<<19)
}
func (o *PORT0_Type) GetPCNTR1_PODR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x80000) >> 19
}
func (o *PORT0_Type) SetPCNTR1_PODR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x100000)|value<<20)
}
func (o *PORT0_Type) GetPCNTR1_PODR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x100000) >> 20
}
func (o *PORT0_Type) SetPCNTR1_PODR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x200000)|value<<21)
}
func (o *PORT0_Type) GetPCNTR1_PODR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x200000) >> 21
}
func (o *PORT0_Type) SetPCNTR1_PODR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x400000)|value<<22)
}
func (o *PORT0_Type) GetPCNTR1_PODR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x400000) >> 22
}
func (o *PORT0_Type) SetPCNTR1_PODR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x800000)|value<<23)
}
func (o *PORT0_Type) GetPCNTR1_PODR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x800000) >> 23
}
func (o *PORT0_Type) SetPCNTR1_PODR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT0_Type) GetPCNTR1_PODR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x1000000) >> 24
}
func (o *PORT0_Type) SetPCNTR1_PODR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT0_Type) GetPCNTR1_PODR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x2000000) >> 25
}
func (o *PORT0_Type) SetPCNTR1_PODR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT0_Type) GetPCNTR1_PODR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x4000000) >> 26
}
func (o *PORT0_Type) SetPCNTR1_PODR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT0_Type) GetPCNTR1_PODR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x8000000) >> 27
}
func (o *PORT0_Type) SetPCNTR1_PODR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT0_Type) GetPCNTR1_PODR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x10000000) >> 28
}
func (o *PORT0_Type) SetPCNTR1_PODR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT0_Type) GetPCNTR1_PODR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x20000000) >> 29
}
func (o *PORT0_Type) SetPCNTR1_PODR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT0_Type) GetPCNTR1_PODR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x40000000) >> 30
}
func (o *PORT0_Type) SetPCNTR1_PODR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT0_Type) GetPCNTR1_PODR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x80000000) >> 31
}

// PORT0.PCNTR2: Port Control Register 2
func (o *PORT0_Type) SetPCNTR2_PIDR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x1)|value)
}
func (o *PORT0_Type) GetPCNTR2_PIDR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR2.Reg) & 0x1
}
func (o *PORT0_Type) SetPCNTR2_PIDR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x2)|value<<1)
}
func (o *PORT0_Type) GetPCNTR2_PIDR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x2) >> 1
}
func (o *PORT0_Type) SetPCNTR2_PIDR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x4)|value<<2)
}
func (o *PORT0_Type) GetPCNTR2_PIDR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x4) >> 2
}
func (o *PORT0_Type) SetPCNTR2_PIDR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x8)|value<<3)
}
func (o *PORT0_Type) GetPCNTR2_PIDR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x8) >> 3
}
func (o *PORT0_Type) SetPCNTR2_PIDR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x10)|value<<4)
}
func (o *PORT0_Type) GetPCNTR2_PIDR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x10) >> 4
}
func (o *PORT0_Type) SetPCNTR2_PIDR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x20)|value<<5)
}
func (o *PORT0_Type) GetPCNTR2_PIDR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x20) >> 5
}
func (o *PORT0_Type) SetPCNTR2_PIDR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x40)|value<<6)
}
func (o *PORT0_Type) GetPCNTR2_PIDR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x40) >> 6
}
func (o *PORT0_Type) SetPCNTR2_PIDR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x80)|value<<7)
}
func (o *PORT0_Type) GetPCNTR2_PIDR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x80) >> 7
}
func (o *PORT0_Type) SetPCNTR2_PIDR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x100)|value<<8)
}
func (o *PORT0_Type) GetPCNTR2_PIDR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x100) >> 8
}
func (o *PORT0_Type) SetPCNTR2_PIDR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x200)|value<<9)
}
func (o *PORT0_Type) GetPCNTR2_PIDR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x200) >> 9
}
func (o *PORT0_Type) SetPCNTR2_PIDR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x400)|value<<10)
}
func (o *PORT0_Type) GetPCNTR2_PIDR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x400) >> 10
}
func (o *PORT0_Type) SetPCNTR2_PIDR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x800)|value<<11)
}
func (o *PORT0_Type) GetPCNTR2_PIDR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x800) >> 11
}
func (o *PORT0_Type) SetPCNTR2_PIDR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x1000)|value<<12)
}
func (o *PORT0_Type) GetPCNTR2_PIDR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x1000) >> 12
}
func (o *PORT0_Type) SetPCNTR2_PIDR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x2000)|value<<13)
}
func (o *PORT0_Type) GetPCNTR2_PIDR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x2000) >> 13
}
func (o *PORT0_Type) SetPCNTR2_PIDR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x4000)|value<<14)
}
func (o *PORT0_Type) GetPCNTR2_PIDR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x4000) >> 14
}
func (o *PORT0_Type) SetPCNTR2_PIDR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x8000)|value<<15)
}
func (o *PORT0_Type) GetPCNTR2_PIDR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x8000) >> 15
}

// PORT0.PCNTR3: Port Control Register 3
func (o *PORT0_Type) SetPCNTR3_POSR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x1)|value)
}
func (o *PORT0_Type) GetPCNTR3_POSR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR3.Reg) & 0x1
}
func (o *PORT0_Type) SetPCNTR3_POSR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x2)|value<<1)
}
func (o *PORT0_Type) GetPCNTR3_POSR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x2) >> 1
}
func (o *PORT0_Type) SetPCNTR3_POSR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x4)|value<<2)
}
func (o *PORT0_Type) GetPCNTR3_POSR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x4) >> 2
}
func (o *PORT0_Type) SetPCNTR3_POSR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x8)|value<<3)
}
func (o *PORT0_Type) GetPCNTR3_POSR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x8) >> 3
}
func (o *PORT0_Type) SetPCNTR3_POSR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x10)|value<<4)
}
func (o *PORT0_Type) GetPCNTR3_POSR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x10) >> 4
}
func (o *PORT0_Type) SetPCNTR3_POSR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x20)|value<<5)
}
func (o *PORT0_Type) GetPCNTR3_POSR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x20) >> 5
}
func (o *PORT0_Type) SetPCNTR3_POSR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x40)|value<<6)
}
func (o *PORT0_Type) GetPCNTR3_POSR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x40) >> 6
}
func (o *PORT0_Type) SetPCNTR3_POSR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x80)|value<<7)
}
func (o *PORT0_Type) GetPCNTR3_POSR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x80) >> 7
}
func (o *PORT0_Type) SetPCNTR3_POSR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x100)|value<<8)
}
func (o *PORT0_Type) GetPCNTR3_POSR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x100) >> 8
}
func (o *PORT0_Type) SetPCNTR3_POSR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x200)|value<<9)
}
func (o *PORT0_Type) GetPCNTR3_POSR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x200) >> 9
}
func (o *PORT0_Type) SetPCNTR3_POSR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x400)|value<<10)
}
func (o *PORT0_Type) GetPCNTR3_POSR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x400) >> 10
}
func (o *PORT0_Type) SetPCNTR3_POSR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x800)|value<<11)
}
func (o *PORT0_Type) GetPCNTR3_POSR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x800) >> 11
}
func (o *PORT0_Type) SetPCNTR3_POSR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x1000)|value<<12)
}
func (o *PORT0_Type) GetPCNTR3_POSR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x1000) >> 12
}
func (o *PORT0_Type) SetPCNTR3_POSR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x2000)|value<<13)
}
func (o *PORT0_Type) GetPCNTR3_POSR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x2000) >> 13
}
func (o *PORT0_Type) SetPCNTR3_POSR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x4000)|value<<14)
}
func (o *PORT0_Type) GetPCNTR3_POSR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x4000) >> 14
}
func (o *PORT0_Type) SetPCNTR3_POSR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x8000)|value<<15)
}
func (o *PORT0_Type) GetPCNTR3_POSR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x8000) >> 15
}
func (o *PORT0_Type) SetPCNTR3_PORR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x10000)|value<<16)
}
func (o *PORT0_Type) GetPCNTR3_PORR00() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x10000) >> 16
}
func (o *PORT0_Type) SetPCNTR3_PORR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x20000)|value<<17)
}
func (o *PORT0_Type) GetPCNTR3_PORR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x20000) >> 17
}
func (o *PORT0_Type) SetPCNTR3_PORR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x40000)|value<<18)
}
func (o *PORT0_Type) GetPCNTR3_PORR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x40000) >> 18
}
func (o *PORT0_Type) SetPCNTR3_PORR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x80000)|value<<19)
}
func (o *PORT0_Type) GetPCNTR3_PORR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x80000) >> 19
}
func (o *PORT0_Type) SetPCNTR3_PORR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x100000)|value<<20)
}
func (o *PORT0_Type) GetPCNTR3_PORR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x100000) >> 20
}
func (o *PORT0_Type) SetPCNTR3_PORR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x200000)|value<<21)
}
func (o *PORT0_Type) GetPCNTR3_PORR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x200000) >> 21
}
func (o *PORT0_Type) SetPCNTR3_PORR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x400000)|value<<22)
}
func (o *PORT0_Type) GetPCNTR3_PORR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x400000) >> 22
}
func (o *PORT0_Type) SetPCNTR3_PORR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x800000)|value<<23)
}
func (o *PORT0_Type) GetPCNTR3_PORR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x800000) >> 23
}
func (o *PORT0_Type) SetPCNTR3_PORR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT0_Type) GetPCNTR3_PORR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x1000000) >> 24
}
func (o *PORT0_Type) SetPCNTR3_PORR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT0_Type) GetPCNTR3_PORR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x2000000) >> 25
}
func (o *PORT0_Type) SetPCNTR3_PORR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT0_Type) GetPCNTR3_PORR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x4000000) >> 26
}
func (o *PORT0_Type) SetPCNTR3_PORR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT0_Type) GetPCNTR3_PORR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x8000000) >> 27
}
func (o *PORT0_Type) SetPCNTR3_PORR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT0_Type) GetPCNTR3_PORR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x10000000) >> 28
}
func (o *PORT0_Type) SetPCNTR3_PORR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT0_Type) GetPCNTR3_PORR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x20000000) >> 29
}
func (o *PORT0_Type) SetPCNTR3_PORR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT0_Type) GetPCNTR3_PORR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x40000000) >> 30
}
func (o *PORT0_Type) SetPCNTR3_PORR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT0_Type) GetPCNTR3_PORR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x80000000) >> 31
}

// Port 1 Control Registers
type PORT1_Type struct {
	PCNTR1 volatile.Register32 // 0x0
	PCNTR2 volatile.Register32 // 0x4
	PCNTR3 volatile.Register32 // 0x8
	PCNTR4 volatile.Register32 // 0xC
}

// PORT1.PCNTR1: Port Control Register 1
func (o *PORT1_Type) SetPCNTR1_PDR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x1)|value)
}
func (o *PORT1_Type) GetPCNTR1_PDR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR1.Reg) & 0x1
}
func (o *PORT1_Type) SetPCNTR1_PDR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x2)|value<<1)
}
func (o *PORT1_Type) GetPCNTR1_PDR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x2) >> 1
}
func (o *PORT1_Type) SetPCNTR1_PDR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x4)|value<<2)
}
func (o *PORT1_Type) GetPCNTR1_PDR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x4) >> 2
}
func (o *PORT1_Type) SetPCNTR1_PDR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x8)|value<<3)
}
func (o *PORT1_Type) GetPCNTR1_PDR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x8) >> 3
}
func (o *PORT1_Type) SetPCNTR1_PDR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x10)|value<<4)
}
func (o *PORT1_Type) GetPCNTR1_PDR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x10) >> 4
}
func (o *PORT1_Type) SetPCNTR1_PDR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x20)|value<<5)
}
func (o *PORT1_Type) GetPCNTR1_PDR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x20) >> 5
}
func (o *PORT1_Type) SetPCNTR1_PDR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x40)|value<<6)
}
func (o *PORT1_Type) GetPCNTR1_PDR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x40) >> 6
}
func (o *PORT1_Type) SetPCNTR1_PDR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x80)|value<<7)
}
func (o *PORT1_Type) GetPCNTR1_PDR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x80) >> 7
}
func (o *PORT1_Type) SetPCNTR1_PDR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x100)|value<<8)
}
func (o *PORT1_Type) GetPCNTR1_PDR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x100) >> 8
}
func (o *PORT1_Type) SetPCNTR1_PDR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x200)|value<<9)
}
func (o *PORT1_Type) GetPCNTR1_PDR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x200) >> 9
}
func (o *PORT1_Type) SetPCNTR1_PDR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x400)|value<<10)
}
func (o *PORT1_Type) GetPCNTR1_PDR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x400) >> 10
}
func (o *PORT1_Type) SetPCNTR1_PDR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x800)|value<<11)
}
func (o *PORT1_Type) GetPCNTR1_PDR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x800) >> 11
}
func (o *PORT1_Type) SetPCNTR1_PDR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x1000)|value<<12)
}
func (o *PORT1_Type) GetPCNTR1_PDR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x1000) >> 12
}
func (o *PORT1_Type) SetPCNTR1_PDR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x2000)|value<<13)
}
func (o *PORT1_Type) GetPCNTR1_PDR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x2000) >> 13
}
func (o *PORT1_Type) SetPCNTR1_PDR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x4000)|value<<14)
}
func (o *PORT1_Type) GetPCNTR1_PDR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x4000) >> 14
}
func (o *PORT1_Type) SetPCNTR1_PDR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x8000)|value<<15)
}
func (o *PORT1_Type) GetPCNTR1_PDR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x8000) >> 15
}
func (o *PORT1_Type) SetPCNTR1_PODR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x10000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR1_PODR00() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x10000) >> 16
}
func (o *PORT1_Type) SetPCNTR1_PODR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x20000)|value<<17)
}
func (o *PORT1_Type) GetPCNTR1_PODR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x20000) >> 17
}
func (o *PORT1_Type) SetPCNTR1_PODR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x40000)|value<<18)
}
func (o *PORT1_Type) GetPCNTR1_PODR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x40000) >> 18
}
func (o *PORT1_Type) SetPCNTR1_PODR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x80000)|value<<19)
}
func (o *PORT1_Type) GetPCNTR1_PODR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x80000) >> 19
}
func (o *PORT1_Type) SetPCNTR1_PODR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x100000)|value<<20)
}
func (o *PORT1_Type) GetPCNTR1_PODR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x100000) >> 20
}
func (o *PORT1_Type) SetPCNTR1_PODR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x200000)|value<<21)
}
func (o *PORT1_Type) GetPCNTR1_PODR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x200000) >> 21
}
func (o *PORT1_Type) SetPCNTR1_PODR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x400000)|value<<22)
}
func (o *PORT1_Type) GetPCNTR1_PODR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x400000) >> 22
}
func (o *PORT1_Type) SetPCNTR1_PODR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x800000)|value<<23)
}
func (o *PORT1_Type) GetPCNTR1_PODR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x800000) >> 23
}
func (o *PORT1_Type) SetPCNTR1_PODR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT1_Type) GetPCNTR1_PODR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x1000000) >> 24
}
func (o *PORT1_Type) SetPCNTR1_PODR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT1_Type) GetPCNTR1_PODR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x2000000) >> 25
}
func (o *PORT1_Type) SetPCNTR1_PODR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT1_Type) GetPCNTR1_PODR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x4000000) >> 26
}
func (o *PORT1_Type) SetPCNTR1_PODR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT1_Type) GetPCNTR1_PODR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x8000000) >> 27
}
func (o *PORT1_Type) SetPCNTR1_PODR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT1_Type) GetPCNTR1_PODR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x10000000) >> 28
}
func (o *PORT1_Type) SetPCNTR1_PODR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT1_Type) GetPCNTR1_PODR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x20000000) >> 29
}
func (o *PORT1_Type) SetPCNTR1_PODR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT1_Type) GetPCNTR1_PODR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x40000000) >> 30
}
func (o *PORT1_Type) SetPCNTR1_PODR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT1_Type) GetPCNTR1_PODR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x80000000) >> 31
}

// PORT1.PCNTR2: Port Control Register 2
func (o *PORT1_Type) SetPCNTR2_PIDR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x1)|value)
}
func (o *PORT1_Type) GetPCNTR2_PIDR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR2.Reg) & 0x1
}
func (o *PORT1_Type) SetPCNTR2_PIDR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x2)|value<<1)
}
func (o *PORT1_Type) GetPCNTR2_PIDR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x2) >> 1
}
func (o *PORT1_Type) SetPCNTR2_PIDR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x4)|value<<2)
}
func (o *PORT1_Type) GetPCNTR2_PIDR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x4) >> 2
}
func (o *PORT1_Type) SetPCNTR2_PIDR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x8)|value<<3)
}
func (o *PORT1_Type) GetPCNTR2_PIDR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x8) >> 3
}
func (o *PORT1_Type) SetPCNTR2_PIDR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x10)|value<<4)
}
func (o *PORT1_Type) GetPCNTR2_PIDR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x10) >> 4
}
func (o *PORT1_Type) SetPCNTR2_PIDR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x20)|value<<5)
}
func (o *PORT1_Type) GetPCNTR2_PIDR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x20) >> 5
}
func (o *PORT1_Type) SetPCNTR2_PIDR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x40)|value<<6)
}
func (o *PORT1_Type) GetPCNTR2_PIDR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x40) >> 6
}
func (o *PORT1_Type) SetPCNTR2_PIDR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x80)|value<<7)
}
func (o *PORT1_Type) GetPCNTR2_PIDR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x80) >> 7
}
func (o *PORT1_Type) SetPCNTR2_PIDR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x100)|value<<8)
}
func (o *PORT1_Type) GetPCNTR2_PIDR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x100) >> 8
}
func (o *PORT1_Type) SetPCNTR2_PIDR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x200)|value<<9)
}
func (o *PORT1_Type) GetPCNTR2_PIDR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x200) >> 9
}
func (o *PORT1_Type) SetPCNTR2_PIDR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x400)|value<<10)
}
func (o *PORT1_Type) GetPCNTR2_PIDR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x400) >> 10
}
func (o *PORT1_Type) SetPCNTR2_PIDR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x800)|value<<11)
}
func (o *PORT1_Type) GetPCNTR2_PIDR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x800) >> 11
}
func (o *PORT1_Type) SetPCNTR2_PIDR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x1000)|value<<12)
}
func (o *PORT1_Type) GetPCNTR2_PIDR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x1000) >> 12
}
func (o *PORT1_Type) SetPCNTR2_PIDR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x2000)|value<<13)
}
func (o *PORT1_Type) GetPCNTR2_PIDR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x2000) >> 13
}
func (o *PORT1_Type) SetPCNTR2_PIDR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x4000)|value<<14)
}
func (o *PORT1_Type) GetPCNTR2_PIDR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x4000) >> 14
}
func (o *PORT1_Type) SetPCNTR2_PIDR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x8000)|value<<15)
}
func (o *PORT1_Type) GetPCNTR2_PIDR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x8000) >> 15
}
func (o *PORT1_Type) SetPCNTR2_EIDR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x10000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR2_EIDR00() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x10000) >> 16
}
func (o *PORT1_Type) SetPCNTR2_EIDR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x20000)|value<<17)
}
func (o *PORT1_Type) GetPCNTR2_EIDR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x20000) >> 17
}
func (o *PORT1_Type) SetPCNTR2_EIDR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x40000)|value<<18)
}
func (o *PORT1_Type) GetPCNTR2_EIDR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x40000) >> 18
}
func (o *PORT1_Type) SetPCNTR2_EIDR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x80000)|value<<19)
}
func (o *PORT1_Type) GetPCNTR2_EIDR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x80000) >> 19
}
func (o *PORT1_Type) SetPCNTR2_EIDR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x100000)|value<<20)
}
func (o *PORT1_Type) GetPCNTR2_EIDR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x100000) >> 20
}
func (o *PORT1_Type) SetPCNTR2_EIDR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x200000)|value<<21)
}
func (o *PORT1_Type) GetPCNTR2_EIDR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x200000) >> 21
}
func (o *PORT1_Type) SetPCNTR2_EIDR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x400000)|value<<22)
}
func (o *PORT1_Type) GetPCNTR2_EIDR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x400000) >> 22
}
func (o *PORT1_Type) SetPCNTR2_EIDR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x800000)|value<<23)
}
func (o *PORT1_Type) GetPCNTR2_EIDR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x800000) >> 23
}
func (o *PORT1_Type) SetPCNTR2_EIDR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT1_Type) GetPCNTR2_EIDR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x1000000) >> 24
}
func (o *PORT1_Type) SetPCNTR2_EIDR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT1_Type) GetPCNTR2_EIDR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x2000000) >> 25
}
func (o *PORT1_Type) SetPCNTR2_EIDR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT1_Type) GetPCNTR2_EIDR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x4000000) >> 26
}
func (o *PORT1_Type) SetPCNTR2_EIDR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT1_Type) GetPCNTR2_EIDR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x8000000) >> 27
}
func (o *PORT1_Type) SetPCNTR2_EIDR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT1_Type) GetPCNTR2_EIDR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x10000000) >> 28
}
func (o *PORT1_Type) SetPCNTR2_EIDR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT1_Type) GetPCNTR2_EIDR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x20000000) >> 29
}
func (o *PORT1_Type) SetPCNTR2_EIDR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT1_Type) GetPCNTR2_EIDR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x40000000) >> 30
}
func (o *PORT1_Type) SetPCNTR2_EIDR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT1_Type) GetPCNTR2_EIDR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x80000000) >> 31
}

// PORT1.PCNTR3: Port Control Register 3
func (o *PORT1_Type) SetPCNTR3_POSR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x1)|value)
}
func (o *PORT1_Type) GetPCNTR3_POSR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR3.Reg) & 0x1
}
func (o *PORT1_Type) SetPCNTR3_POSR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x2)|value<<1)
}
func (o *PORT1_Type) GetPCNTR3_POSR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x2) >> 1
}
func (o *PORT1_Type) SetPCNTR3_POSR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x4)|value<<2)
}
func (o *PORT1_Type) GetPCNTR3_POSR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x4) >> 2
}
func (o *PORT1_Type) SetPCNTR3_POSR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x8)|value<<3)
}
func (o *PORT1_Type) GetPCNTR3_POSR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x8) >> 3
}
func (o *PORT1_Type) SetPCNTR3_POSR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x10)|value<<4)
}
func (o *PORT1_Type) GetPCNTR3_POSR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x10) >> 4
}
func (o *PORT1_Type) SetPCNTR3_POSR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x20)|value<<5)
}
func (o *PORT1_Type) GetPCNTR3_POSR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x20) >> 5
}
func (o *PORT1_Type) SetPCNTR3_POSR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x40)|value<<6)
}
func (o *PORT1_Type) GetPCNTR3_POSR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x40) >> 6
}
func (o *PORT1_Type) SetPCNTR3_POSR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x80)|value<<7)
}
func (o *PORT1_Type) GetPCNTR3_POSR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x80) >> 7
}
func (o *PORT1_Type) SetPCNTR3_POSR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x100)|value<<8)
}
func (o *PORT1_Type) GetPCNTR3_POSR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x100) >> 8
}
func (o *PORT1_Type) SetPCNTR3_POSR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x200)|value<<9)
}
func (o *PORT1_Type) GetPCNTR3_POSR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x200) >> 9
}
func (o *PORT1_Type) SetPCNTR3_POSR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x400)|value<<10)
}
func (o *PORT1_Type) GetPCNTR3_POSR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x400) >> 10
}
func (o *PORT1_Type) SetPCNTR3_POSR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x800)|value<<11)
}
func (o *PORT1_Type) GetPCNTR3_POSR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x800) >> 11
}
func (o *PORT1_Type) SetPCNTR3_POSR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x1000)|value<<12)
}
func (o *PORT1_Type) GetPCNTR3_POSR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x1000) >> 12
}
func (o *PORT1_Type) SetPCNTR3_POSR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x2000)|value<<13)
}
func (o *PORT1_Type) GetPCNTR3_POSR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x2000) >> 13
}
func (o *PORT1_Type) SetPCNTR3_POSR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x4000)|value<<14)
}
func (o *PORT1_Type) GetPCNTR3_POSR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x4000) >> 14
}
func (o *PORT1_Type) SetPCNTR3_POSR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x8000)|value<<15)
}
func (o *PORT1_Type) GetPCNTR3_POSR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x8000) >> 15
}
func (o *PORT1_Type) SetPCNTR3_PORR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x10000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR3_PORR00() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x10000) >> 16
}
func (o *PORT1_Type) SetPCNTR3_PORR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x20000)|value<<17)
}
func (o *PORT1_Type) GetPCNTR3_PORR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x20000) >> 17
}
func (o *PORT1_Type) SetPCNTR3_PORR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x40000)|value<<18)
}
func (o *PORT1_Type) GetPCNTR3_PORR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x40000) >> 18
}
func (o *PORT1_Type) SetPCNTR3_PORR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x80000)|value<<19)
}
func (o *PORT1_Type) GetPCNTR3_PORR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x80000) >> 19
}
func (o *PORT1_Type) SetPCNTR3_PORR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x100000)|value<<20)
}
func (o *PORT1_Type) GetPCNTR3_PORR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x100000) >> 20
}
func (o *PORT1_Type) SetPCNTR3_PORR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x200000)|value<<21)
}
func (o *PORT1_Type) GetPCNTR3_PORR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x200000) >> 21
}
func (o *PORT1_Type) SetPCNTR3_PORR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x400000)|value<<22)
}
func (o *PORT1_Type) GetPCNTR3_PORR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x400000) >> 22
}
func (o *PORT1_Type) SetPCNTR3_PORR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x800000)|value<<23)
}
func (o *PORT1_Type) GetPCNTR3_PORR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x800000) >> 23
}
func (o *PORT1_Type) SetPCNTR3_PORR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT1_Type) GetPCNTR3_PORR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x1000000) >> 24
}
func (o *PORT1_Type) SetPCNTR3_PORR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT1_Type) GetPCNTR3_PORR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x2000000) >> 25
}
func (o *PORT1_Type) SetPCNTR3_PORR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT1_Type) GetPCNTR3_PORR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x4000000) >> 26
}
func (o *PORT1_Type) SetPCNTR3_PORR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT1_Type) GetPCNTR3_PORR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x8000000) >> 27
}
func (o *PORT1_Type) SetPCNTR3_PORR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT1_Type) GetPCNTR3_PORR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x10000000) >> 28
}
func (o *PORT1_Type) SetPCNTR3_PORR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT1_Type) GetPCNTR3_PORR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x20000000) >> 29
}
func (o *PORT1_Type) SetPCNTR3_PORR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT1_Type) GetPCNTR3_PORR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x40000000) >> 30
}
func (o *PORT1_Type) SetPCNTR3_PORR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT1_Type) GetPCNTR3_PORR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x80000000) >> 31
}

// PORT1.PCNTR4: Port Control Register 4
func (o *PORT1_Type) SetPCNTR4_EOSR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x1)|value)
}
func (o *PORT1_Type) GetPCNTR4_EOSR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR4.Reg) & 0x1
}
func (o *PORT1_Type) SetPCNTR4_EOSR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x2)|value<<1)
}
func (o *PORT1_Type) GetPCNTR4_EOSR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x2) >> 1
}
func (o *PORT1_Type) SetPCNTR4_EOSR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x4)|value<<2)
}
func (o *PORT1_Type) GetPCNTR4_EOSR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x4) >> 2
}
func (o *PORT1_Type) SetPCNTR4_EOSR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x8)|value<<3)
}
func (o *PORT1_Type) GetPCNTR4_EOSR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x8) >> 3
}
func (o *PORT1_Type) SetPCNTR4_EOSR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x10)|value<<4)
}
func (o *PORT1_Type) GetPCNTR4_EOSR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x10) >> 4
}
func (o *PORT1_Type) SetPCNTR4_EOSR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x20)|value<<5)
}
func (o *PORT1_Type) GetPCNTR4_EOSR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x20) >> 5
}
func (o *PORT1_Type) SetPCNTR4_EOSR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x40)|value<<6)
}
func (o *PORT1_Type) GetPCNTR4_EOSR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x40) >> 6
}
func (o *PORT1_Type) SetPCNTR4_EOSR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x80)|value<<7)
}
func (o *PORT1_Type) GetPCNTR4_EOSR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x80) >> 7
}
func (o *PORT1_Type) SetPCNTR4_EOSR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x100)|value<<8)
}
func (o *PORT1_Type) GetPCNTR4_EOSR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x100) >> 8
}
func (o *PORT1_Type) SetPCNTR4_EOSR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x200)|value<<9)
}
func (o *PORT1_Type) GetPCNTR4_EOSR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x200) >> 9
}
func (o *PORT1_Type) SetPCNTR4_EOSR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x400)|value<<10)
}
func (o *PORT1_Type) GetPCNTR4_EOSR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x400) >> 10
}
func (o *PORT1_Type) SetPCNTR4_EOSR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x800)|value<<11)
}
func (o *PORT1_Type) GetPCNTR4_EOSR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x800) >> 11
}
func (o *PORT1_Type) SetPCNTR4_EOSR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x1000)|value<<12)
}
func (o *PORT1_Type) GetPCNTR4_EOSR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x1000) >> 12
}
func (o *PORT1_Type) SetPCNTR4_EOSR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x2000)|value<<13)
}
func (o *PORT1_Type) GetPCNTR4_EOSR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x2000) >> 13
}
func (o *PORT1_Type) SetPCNTR4_EOSR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x4000)|value<<14)
}
func (o *PORT1_Type) GetPCNTR4_EOSR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x4000) >> 14
}
func (o *PORT1_Type) SetPCNTR4_EOSR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x8000)|value<<15)
}
func (o *PORT1_Type) GetPCNTR4_EOSR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x8000) >> 15
}
func (o *PORT1_Type) SetPCNTR4_EORR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x10000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR4_EORR00() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x10000) >> 16
}
func (o *PORT1_Type) SetPCNTR4_EORR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x20000)|value<<17)
}
func (o *PORT1_Type) GetPCNTR4_EORR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x20000) >> 17
}
func (o *PORT1_Type) SetPCNTR4_EORR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x40000)|value<<18)
}
func (o *PORT1_Type) GetPCNTR4_EORR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x40000) >> 18
}
func (o *PORT1_Type) SetPCNTR4_EORR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x80000)|value<<19)
}
func (o *PORT1_Type) GetPCNTR4_EORR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x80000) >> 19
}
func (o *PORT1_Type) SetPCNTR4_EORR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x100000)|value<<20)
}
func (o *PORT1_Type) GetPCNTR4_EORR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x100000) >> 20
}
func (o *PORT1_Type) SetPCNTR4_EORR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x200000)|value<<21)
}
func (o *PORT1_Type) GetPCNTR4_EORR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x200000) >> 21
}
func (o *PORT1_Type) SetPCNTR4_EORR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x400000)|value<<22)
}
func (o *PORT1_Type) GetPCNTR4_EORR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x400000) >> 22
}
func (o *PORT1_Type) SetPCNTR4_EORR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x800000)|value<<23)
}
func (o *PORT1_Type) GetPCNTR4_EORR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x800000) >> 23
}
func (o *PORT1_Type) SetPCNTR4_EORR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT1_Type) GetPCNTR4_EORR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x1000000) >> 24
}
func (o *PORT1_Type) SetPCNTR4_EORR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT1_Type) GetPCNTR4_EORR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x2000000) >> 25
}
func (o *PORT1_Type) SetPCNTR4_EORR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT1_Type) GetPCNTR4_EORR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x4000000) >> 26
}
func (o *PORT1_Type) SetPCNTR4_EORR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT1_Type) GetPCNTR4_EORR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x8000000) >> 27
}
func (o *PORT1_Type) SetPCNTR4_EORR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT1_Type) GetPCNTR4_EORR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x10000000) >> 28
}
func (o *PORT1_Type) SetPCNTR4_EORR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT1_Type) GetPCNTR4_EORR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x20000000) >> 29
}
func (o *PORT1_Type) SetPCNTR4_EORR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT1_Type) GetPCNTR4_EORR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x40000000) >> 30
}
func (o *PORT1_Type) SetPCNTR4_EORR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT1_Type) GetPCNTR4_EORR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x80000000) >> 31
}

// Pmn Pin Function Control Register
type PFS_Type struct {
	P000PFS volatile.Register32 // 0x0
	P001PFS volatile.Register32 // 0x4
	P002PFS volatile.Register32 // 0x8
	P003PFS volatile.Register32 // 0xC
	P004PFS volatile.Register32 // 0x10
	P005PFS volatile.Register32 // 0x14
	P006PFS volatile.Register32 // 0x18
	P007PFS volatile.Register32 // 0x1C
	P008PFS volatile.Register32 // 0x20
	_       [4]byte
	P010PFS volatile.Register32 // 0x28
	P011PFS volatile.Register32 // 0x2C
	P012PFS volatile.Register32 // 0x30
	P013PFS volatile.Register32 // 0x34
	P014PFS volatile.Register32 // 0x38
	P015PFS volatile.Register32 // 0x3C
	P100PFS volatile.Register32 // 0x40
	P101PFS volatile.Register32 // 0x44
	P102PFS volatile.Register32 // 0x48
	P103PFS volatile.Register32 // 0x4C
	P104PFS volatile.Register32 // 0x50
	P105PFS volatile.Register32 // 0x54
	P106PFS volatile.Register32 // 0x58
	P107PFS volatile.Register32 // 0x5C
	P108PFS volatile.Register32 // 0x60
	P109PFS volatile.Register32 // 0x64
	P110PFS volatile.Register32 // 0x68
	P111PFS volatile.Register32 // 0x6C
	P112PFS volatile.Register32 // 0x70
	P113PFS volatile.Register32 // 0x74
	P114PFS volatile.Register32 // 0x78
	P115PFS volatile.Register32 // 0x7C
	P200PFS volatile.Register32 // 0x80
	P201PFS volatile.Register32 // 0x84
	P202PFS volatile.Register32 // 0x88
	P203PFS volatile.Register32 // 0x8C
	P204PFS volatile.Register32 // 0x90
	P205PFS volatile.Register32 // 0x94
	P206PFS volatile.Register32 // 0x98
	P207PFS volatile.Register32 // 0x9C
	P208PFS volatile.Register32 // 0xA0
	_       [12]byte
	P212PFS volatile.Register32 // 0xB0
	P213PFS volatile.Register32 // 0xB4
	P214PFS volatile.Register32 // 0xB8
	P215PFS volatile.Register32 // 0xBC
	P300PFS volatile.Register32 // 0xC0
	P301PFS volatile.Register32 // 0xC4
	P302PFS volatile.Register32 // 0xC8
	P303PFS volatile.Register32 // 0xCC
	P304PFS volatile.Register32 // 0xD0
	P305PFS volatile.Register32 // 0xD4
	P306PFS volatile.Register32 // 0xD8
	P307PFS volatile.Register32 // 0xDC
	_       [32]byte
	P400PFS volatile.Register32 // 0x100
	P401PFS volatile.Register32 // 0x104
	P402PFS volatile.Register32 // 0x108
	P403PFS volatile.Register32 // 0x10C
	P404PFS volatile.Register32 // 0x110
	P405PFS volatile.Register32 // 0x114
	P406PFS volatile.Register32 // 0x118
	P407PFS volatile.Register32 // 0x11C
	P408PFS volatile.Register32 // 0x120
	P409PFS volatile.Register32 // 0x124
	P410PFS volatile.Register32 // 0x128
	P411PFS volatile.Register32 // 0x12C
	P412PFS volatile.Register32 // 0x130
	P413PFS volatile.Register32 // 0x134
	P414PFS volatile.Register32 // 0x138
	P415PFS volatile.Register32 // 0x13C
	P500PFS volatile.Register32 // 0x140
	P501PFS volatile.Register32 // 0x144
	P502PFS volatile.Register32 // 0x148
	P503PFS volatile.Register32 // 0x14C
	P504PFS volatile.Register32 // 0x150
	P505PFS volatile.Register32 // 0x154
	_       [40]byte
	P600PFS volatile.Register32 // 0x180
	P601PFS volatile.Register32 // 0x184
	P602PFS volatile.Register32 // 0x188
	P603PFS volatile.Register32 // 0x18C
	_       [16]byte
	P608PFS volatile.Register32 // 0x1A0
	P609PFS volatile.Register32 // 0x1A4
	P610PFS volatile.Register32 // 0x1A8
	_       [52]byte
	P708PFS volatile.Register32 // 0x1E0
	_       [20]byte
	P714PFS volatile.Register32 // 0x1F8
	_       [36]byte
	P808PFS volatile.Register32 // 0x220
	P809PFS volatile.Register32 // 0x224
	_       [731]byte
	PWPR    volatile.Register8 // 0x503
	_       [11]byte
	PRWCNTR volatile.Register8 // 0x50F
}

// PFS.P000PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP000PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP000PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P000PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP000PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP000PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP000PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP000PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP000PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP000PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP000PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP000PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP000PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP000PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP000PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP000PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP000PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP000PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP000PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP000PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P001PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP001PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP001PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P001PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP001PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP001PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP001PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP001PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP001PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP001PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP001PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP001PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP001PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP001PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP001PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP001PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP001PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP001PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP001PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP001PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P002PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP002PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP002PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P002PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP002PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP002PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP002PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP002PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP002PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP002PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP002PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP002PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP002PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP002PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP002PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP002PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP002PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP002PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP002PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP002PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P003PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP003PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP003PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P003PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP003PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP003PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP003PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP003PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP003PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP003PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP003PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP003PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP003PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP003PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP003PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP003PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP003PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP003PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP003PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP003PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P004PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP004PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP004PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P004PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP004PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP004PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP004PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP004PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP004PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP004PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP004PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP004PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP004PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP004PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP004PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP004PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP004PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP004PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP004PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP004PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P005PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP005PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP005PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P005PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP005PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP005PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP005PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP005PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP005PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP005PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP005PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP005PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP005PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP005PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP005PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP005PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP005PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP005PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP005PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP005PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P006PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP006PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP006PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P006PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP006PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP006PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP006PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP006PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP006PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP006PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP006PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP006PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP006PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP006PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP006PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP006PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP006PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP006PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP006PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP006PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P007PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP007PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP007PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P007PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP007PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP007PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP007PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP007PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP007PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP007PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP007PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP007PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP007PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP007PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP007PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP007PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP007PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP007PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP007PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP007PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P008PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP008PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP008PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P008PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP008PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP008PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP008PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP008PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP008PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP008PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP008PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP008PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP008PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP008PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP008PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP008PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP008PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP008PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP008PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP008PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P010PFS: Port 0%s Pin Function Select Register
func (o *PFS_Type) SetP010PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P010PFS.Reg, volatile.LoadUint32(&o.P010PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP010PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P010PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP010PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P010PFS.Reg, volatile.LoadUint32(&o.P010PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP010PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P010PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP010PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P010PFS.Reg, volatile.LoadUint32(&o.P010PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP010PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P010PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP010PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P010PFS.Reg, volatile.LoadUint32(&o.P010PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP010PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P010PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP010PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P010PFS.Reg, volatile.LoadUint32(&o.P010PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP010PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P010PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP010PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P010PFS.Reg, volatile.LoadUint32(&o.P010PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP010PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P010PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP010PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P010PFS.Reg, volatile.LoadUint32(&o.P010PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP010PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P010PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP010PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P010PFS.Reg, volatile.LoadUint32(&o.P010PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP010PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P010PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP010PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P010PFS.Reg, volatile.LoadUint32(&o.P010PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP010PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P010PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P011PFS: Port 0%s Pin Function Select Register
func (o *PFS_Type) SetP011PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P011PFS.Reg, volatile.LoadUint32(&o.P011PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP011PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P011PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP011PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P011PFS.Reg, volatile.LoadUint32(&o.P011PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP011PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P011PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP011PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P011PFS.Reg, volatile.LoadUint32(&o.P011PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP011PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P011PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP011PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P011PFS.Reg, volatile.LoadUint32(&o.P011PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP011PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P011PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP011PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P011PFS.Reg, volatile.LoadUint32(&o.P011PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP011PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P011PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP011PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P011PFS.Reg, volatile.LoadUint32(&o.P011PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP011PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P011PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP011PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P011PFS.Reg, volatile.LoadUint32(&o.P011PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP011PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P011PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP011PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P011PFS.Reg, volatile.LoadUint32(&o.P011PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP011PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P011PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP011PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P011PFS.Reg, volatile.LoadUint32(&o.P011PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP011PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P011PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P012PFS: Port 0%s Pin Function Select Register
func (o *PFS_Type) SetP012PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P012PFS.Reg, volatile.LoadUint32(&o.P012PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP012PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P012PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP012PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P012PFS.Reg, volatile.LoadUint32(&o.P012PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP012PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P012PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP012PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P012PFS.Reg, volatile.LoadUint32(&o.P012PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP012PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P012PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP012PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P012PFS.Reg, volatile.LoadUint32(&o.P012PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP012PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P012PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP012PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P012PFS.Reg, volatile.LoadUint32(&o.P012PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP012PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P012PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP012PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P012PFS.Reg, volatile.LoadUint32(&o.P012PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP012PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P012PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP012PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P012PFS.Reg, volatile.LoadUint32(&o.P012PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP012PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P012PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP012PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P012PFS.Reg, volatile.LoadUint32(&o.P012PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP012PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P012PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP012PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P012PFS.Reg, volatile.LoadUint32(&o.P012PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP012PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P012PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P013PFS: Port 0%s Pin Function Select Register
func (o *PFS_Type) SetP013PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P013PFS.Reg, volatile.LoadUint32(&o.P013PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP013PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P013PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP013PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P013PFS.Reg, volatile.LoadUint32(&o.P013PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP013PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P013PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP013PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P013PFS.Reg, volatile.LoadUint32(&o.P013PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP013PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P013PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP013PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P013PFS.Reg, volatile.LoadUint32(&o.P013PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP013PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P013PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP013PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P013PFS.Reg, volatile.LoadUint32(&o.P013PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP013PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P013PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP013PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P013PFS.Reg, volatile.LoadUint32(&o.P013PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP013PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P013PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP013PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P013PFS.Reg, volatile.LoadUint32(&o.P013PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP013PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P013PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP013PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P013PFS.Reg, volatile.LoadUint32(&o.P013PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP013PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P013PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP013PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P013PFS.Reg, volatile.LoadUint32(&o.P013PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP013PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P013PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P014PFS: Port 0%s Pin Function Select Register
func (o *PFS_Type) SetP014PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP014PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P014PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP014PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP014PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP014PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP014PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP014PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP014PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP014PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP014PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP014PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP014PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP014PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP014PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP014PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP014PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP014PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP014PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P015PFS: Port 0%s Pin Function Select Register
func (o *PFS_Type) SetP015PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP015PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P015PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP015PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP015PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP015PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP015PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP015PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP015PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP015PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP015PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP015PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP015PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP015PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP015PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP015PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP015PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP015PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP015PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P100PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP100PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP100PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P100PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP100PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP100PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP100PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP100PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP100PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP100PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP100PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP100PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP100PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP100PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP100PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP100PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP100PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP100PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP100PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP100PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP100PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP100PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P101PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP101PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP101PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P101PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP101PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP101PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP101PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP101PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP101PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP101PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP101PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP101PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP101PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP101PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP101PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP101PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP101PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP101PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP101PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP101PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP101PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP101PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P102PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP102PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP102PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P102PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP102PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP102PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP102PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP102PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP102PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP102PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP102PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP102PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP102PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP102PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP102PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP102PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP102PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP102PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP102PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP102PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP102PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP102PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P103PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP103PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP103PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P103PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP103PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP103PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP103PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP103PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP103PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP103PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP103PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP103PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP103PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP103PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP103PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP103PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP103PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP103PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP103PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP103PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP103PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP103PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P104PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP104PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP104PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P104PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP104PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP104PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP104PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP104PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP104PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP104PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP104PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP104PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP104PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP104PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP104PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP104PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP104PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP104PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP104PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP104PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP104PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP104PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P105PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP105PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP105PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P105PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP105PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP105PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP105PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP105PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP105PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP105PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP105PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP105PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP105PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP105PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP105PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP105PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP105PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP105PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP105PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP105PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP105PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP105PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P106PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP106PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP106PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P106PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP106PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP106PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP106PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP106PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP106PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP106PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP106PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP106PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP106PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP106PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP106PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP106PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP106PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP106PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP106PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP106PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP106PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP106PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P107PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP107PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP107PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P107PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP107PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP107PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP107PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP107PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP107PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP107PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP107PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP107PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP107PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP107PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP107PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP107PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP107PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP107PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP107PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP107PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP107PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP107PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P108PFS: Port 108 Pin Function Select Register
func (o *PFS_Type) SetP108PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP108PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P108PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP108PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP108PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP108PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP108PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP108PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP108PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP108PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP108PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP108PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP108PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP108PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP108PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP108PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP108PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP108PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP108PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP108PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP108PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P109PFS: Port 109 Pin Function Select Register
func (o *PFS_Type) SetP109PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP109PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P109PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP109PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP109PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP109PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP109PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP109PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP109PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP109PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP109PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP109PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP109PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP109PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP109PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP109PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP109PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP109PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP109PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP109PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP109PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P110PFS: Port 1%s Pin Function Select Register
func (o *PFS_Type) SetP110PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP110PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P110PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP110PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP110PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP110PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP110PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP110PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP110PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP110PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP110PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP110PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP110PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP110PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP110PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP110PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP110PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP110PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP110PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP110PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP110PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P111PFS: Port 1%s Pin Function Select Register
func (o *PFS_Type) SetP111PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP111PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P111PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP111PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP111PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP111PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP111PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP111PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP111PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP111PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP111PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP111PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP111PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP111PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP111PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP111PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP111PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP111PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP111PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP111PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP111PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P112PFS: Port 1%s Pin Function Select Register
func (o *PFS_Type) SetP112PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP112PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P112PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP112PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP112PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP112PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP112PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP112PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP112PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP112PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP112PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP112PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP112PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP112PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP112PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP112PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP112PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP112PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP112PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP112PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP112PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P113PFS: Port 1%s Pin Function Select Register
func (o *PFS_Type) SetP113PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP113PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P113PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP113PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP113PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP113PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP113PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP113PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP113PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP113PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP113PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP113PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP113PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP113PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP113PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP113PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP113PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP113PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP113PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP113PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP113PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P114PFS: Port 1%s Pin Function Select Register
func (o *PFS_Type) SetP114PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP114PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P114PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP114PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP114PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP114PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP114PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP114PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP114PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP114PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP114PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP114PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP114PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP114PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP114PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP114PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP114PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP114PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP114PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP114PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP114PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P115PFS: Port 1%s Pin Function Select Register
func (o *PFS_Type) SetP115PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP115PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P115PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP115PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP115PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP115PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP115PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP115PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP115PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP115PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP115PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP115PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP115PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP115PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP115PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP115PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP115PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP115PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP115PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP115PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP115PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P200PFS: Port 200 Pin Function Select Register
func (o *PFS_Type) SetP200PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP200PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P200PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP200PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP200PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP200PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP200PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP200PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP200PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP200PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP200PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP200PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP200PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP200PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP200PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP200PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP200PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP200PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP200PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP200PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP200PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P201PFS: Port 201 Pin Function Select Register
func (o *PFS_Type) SetP201PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP201PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P201PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP201PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP201PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP201PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP201PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP201PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP201PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP201PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP201PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP201PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP201PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP201PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP201PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP201PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP201PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP201PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP201PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP201PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP201PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P202PFS: Port 20%s Pin Function Select Register
func (o *PFS_Type) SetP202PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P202PFS.Reg, volatile.LoadUint32(&o.P202PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP202PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P202PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP202PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P202PFS.Reg, volatile.LoadUint32(&o.P202PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP202PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P202PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP202PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P202PFS.Reg, volatile.LoadUint32(&o.P202PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP202PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P202PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP202PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P202PFS.Reg, volatile.LoadUint32(&o.P202PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP202PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P202PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP202PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P202PFS.Reg, volatile.LoadUint32(&o.P202PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP202PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P202PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP202PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P202PFS.Reg, volatile.LoadUint32(&o.P202PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP202PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P202PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP202PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P202PFS.Reg, volatile.LoadUint32(&o.P202PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP202PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P202PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP202PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P202PFS.Reg, volatile.LoadUint32(&o.P202PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP202PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P202PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP202PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P202PFS.Reg, volatile.LoadUint32(&o.P202PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP202PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P202PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP202PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P202PFS.Reg, volatile.LoadUint32(&o.P202PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP202PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P202PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P203PFS: Port 20%s Pin Function Select Register
func (o *PFS_Type) SetP203PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P203PFS.Reg, volatile.LoadUint32(&o.P203PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP203PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P203PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP203PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P203PFS.Reg, volatile.LoadUint32(&o.P203PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP203PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P203PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP203PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P203PFS.Reg, volatile.LoadUint32(&o.P203PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP203PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P203PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP203PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P203PFS.Reg, volatile.LoadUint32(&o.P203PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP203PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P203PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP203PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P203PFS.Reg, volatile.LoadUint32(&o.P203PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP203PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P203PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP203PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P203PFS.Reg, volatile.LoadUint32(&o.P203PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP203PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P203PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP203PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P203PFS.Reg, volatile.LoadUint32(&o.P203PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP203PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P203PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP203PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P203PFS.Reg, volatile.LoadUint32(&o.P203PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP203PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P203PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP203PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P203PFS.Reg, volatile.LoadUint32(&o.P203PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP203PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P203PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP203PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P203PFS.Reg, volatile.LoadUint32(&o.P203PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP203PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P203PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P204PFS: Port 20%s Pin Function Select Register
func (o *PFS_Type) SetP204PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P204PFS.Reg, volatile.LoadUint32(&o.P204PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP204PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P204PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP204PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P204PFS.Reg, volatile.LoadUint32(&o.P204PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP204PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P204PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP204PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P204PFS.Reg, volatile.LoadUint32(&o.P204PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP204PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P204PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP204PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P204PFS.Reg, volatile.LoadUint32(&o.P204PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP204PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P204PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP204PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P204PFS.Reg, volatile.LoadUint32(&o.P204PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP204PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P204PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP204PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P204PFS.Reg, volatile.LoadUint32(&o.P204PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP204PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P204PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP204PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P204PFS.Reg, volatile.LoadUint32(&o.P204PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP204PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P204PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP204PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P204PFS.Reg, volatile.LoadUint32(&o.P204PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP204PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P204PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP204PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P204PFS.Reg, volatile.LoadUint32(&o.P204PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP204PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P204PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP204PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P204PFS.Reg, volatile.LoadUint32(&o.P204PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP204PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P204PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P205PFS: Port 20%s Pin Function Select Register
func (o *PFS_Type) SetP205PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP205PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P205PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP205PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP205PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP205PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP205PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP205PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP205PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP205PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP205PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP205PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP205PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP205PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP205PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP205PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP205PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP205PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP205PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP205PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP205PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P206PFS: Port 20%s Pin Function Select Register
func (o *PFS_Type) SetP206PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP206PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P206PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP206PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP206PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP206PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP206PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP206PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP206PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP206PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP206PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP206PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP206PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP206PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP206PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP206PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP206PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP206PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP206PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP206PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP206PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P207PFS: Port 20%s Pin Function Select Register
func (o *PFS_Type) SetP207PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP207PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P207PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP207PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP207PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP207PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP207PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP207PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP207PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP207PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP207PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP207PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP207PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP207PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP207PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP207PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP207PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP207PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP207PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP207PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP207PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P208PFS: Port 20%s Pin Function Select Register
func (o *PFS_Type) SetP208PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP208PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P208PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP208PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP208PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP208PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP208PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP208PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP208PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP208PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP208PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP208PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP208PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP208PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP208PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP208PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP208PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP208PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP208PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP208PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP208PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P212PFS: Port 2%s Pin Function Select Register
func (o *PFS_Type) SetP212PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP212PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P212PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP212PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP212PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP212PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP212PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP212PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP212PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP212PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP212PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP212PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP212PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP212PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP212PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP212PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP212PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP212PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP212PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP212PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP212PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P213PFS: Port 2%s Pin Function Select Register
func (o *PFS_Type) SetP213PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP213PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P213PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP213PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP213PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP213PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP213PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP213PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP213PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP213PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP213PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP213PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP213PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP213PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP213PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP213PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP213PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP213PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP213PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP213PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP213PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P214PFS: Port 2%s Pin Function Select Register
func (o *PFS_Type) SetP214PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP214PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P214PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP214PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP214PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP214PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP214PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP214PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP214PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP214PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP214PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP214PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP214PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP214PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP214PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP214PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP214PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP214PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP214PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP214PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP214PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P215PFS: Port 2%s Pin Function Select Register
func (o *PFS_Type) SetP215PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P215PFS.Reg, volatile.LoadUint32(&o.P215PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP215PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P215PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP215PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P215PFS.Reg, volatile.LoadUint32(&o.P215PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP215PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P215PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP215PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P215PFS.Reg, volatile.LoadUint32(&o.P215PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP215PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P215PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP215PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P215PFS.Reg, volatile.LoadUint32(&o.P215PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP215PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P215PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP215PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P215PFS.Reg, volatile.LoadUint32(&o.P215PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP215PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P215PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP215PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P215PFS.Reg, volatile.LoadUint32(&o.P215PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP215PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P215PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP215PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P215PFS.Reg, volatile.LoadUint32(&o.P215PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP215PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P215PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP215PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P215PFS.Reg, volatile.LoadUint32(&o.P215PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP215PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P215PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP215PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P215PFS.Reg, volatile.LoadUint32(&o.P215PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP215PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P215PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP215PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P215PFS.Reg, volatile.LoadUint32(&o.P215PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP215PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P215PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P300PFS: Port 300 Pin Function Select Register
func (o *PFS_Type) SetP300PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP300PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P300PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP300PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP300PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP300PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP300PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP300PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP300PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP300PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP300PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP300PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP300PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP300PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP300PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP300PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP300PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP300PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP300PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P301PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP301PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP301PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P301PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP301PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP301PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP301PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP301PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP301PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP301PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP301PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP301PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP301PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP301PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP301PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP301PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP301PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP301PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP301PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP301PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P302PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP302PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP302PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P302PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP302PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP302PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP302PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP302PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP302PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP302PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP302PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP302PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP302PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP302PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP302PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP302PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP302PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP302PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP302PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP302PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P303PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP303PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP303PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P303PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP303PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP303PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP303PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP303PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP303PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP303PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP303PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP303PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP303PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP303PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP303PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP303PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP303PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP303PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP303PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP303PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P304PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP304PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP304PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P304PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP304PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP304PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP304PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP304PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP304PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP304PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP304PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP304PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP304PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP304PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP304PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP304PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP304PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP304PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP304PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP304PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P305PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP305PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP305PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P305PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP305PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP305PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP305PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP305PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP305PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP305PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP305PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP305PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP305PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP305PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP305PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP305PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP305PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP305PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP305PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP305PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P306PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP306PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP306PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P306PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP306PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP306PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP306PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP306PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP306PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP306PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP306PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP306PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP306PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP306PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP306PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP306PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP306PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP306PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP306PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP306PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P307PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP307PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP307PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P307PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP307PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP307PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP307PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP307PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP307PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP307PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP307PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP307PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP307PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP307PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP307PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP307PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP307PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP307PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP307PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP307PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P400PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP400PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP400PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P400PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP400PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP400PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP400PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP400PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP400PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP400PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP400PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP400PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP400PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP400PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP400PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP400PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP400PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP400PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP400PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP400PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P401PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP401PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP401PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P401PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP401PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP401PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP401PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP401PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP401PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP401PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP401PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP401PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP401PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP401PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP401PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP401PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP401PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP401PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP401PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP401PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P402PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP402PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP402PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P402PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP402PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP402PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP402PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP402PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP402PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP402PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP402PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP402PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP402PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP402PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP402PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP402PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP402PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP402PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP402PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP402PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P403PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP403PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP403PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P403PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP403PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP403PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP403PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP403PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP403PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP403PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP403PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP403PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP403PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP403PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP403PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP403PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP403PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP403PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP403PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP403PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P404PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP404PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP404PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P404PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP404PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP404PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP404PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP404PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP404PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP404PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP404PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP404PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP404PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP404PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP404PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP404PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP404PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP404PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP404PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP404PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P405PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP405PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP405PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P405PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP405PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP405PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP405PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP405PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP405PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP405PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP405PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP405PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP405PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP405PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP405PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP405PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP405PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP405PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP405PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP405PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P406PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP406PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP406PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P406PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP406PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP406PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP406PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP406PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP406PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP406PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP406PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP406PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP406PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP406PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP406PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP406PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP406PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP406PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP406PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP406PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P407PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP407PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP407PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P407PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP407PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP407PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP407PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP407PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP407PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP407PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP407PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP407PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP407PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP407PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP407PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP407PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP407PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP407PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP407PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP407PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P408PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP408PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP408PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P408PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP408PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP408PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP408PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP408PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP408PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP408PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP408PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP408PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP408PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP408PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP408PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP408PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP408PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP408PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP408PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP408PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P409PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP409PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP409PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P409PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP409PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP409PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP409PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP409PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP409PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP409PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP409PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP409PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP409PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP409PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP409PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP409PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP409PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP409PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP409PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP409PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P410PFS: Port 4%s Pin Function Select Register
func (o *PFS_Type) SetP410PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP410PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P410PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP410PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP410PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP410PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP410PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP410PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP410PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP410PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP410PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP410PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP410PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP410PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP410PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP410PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP410PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP410PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP410PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P411PFS: Port 4%s Pin Function Select Register
func (o *PFS_Type) SetP411PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP411PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P411PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP411PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP411PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP411PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP411PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP411PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP411PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP411PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP411PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP411PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP411PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP411PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP411PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP411PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP411PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP411PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP411PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P412PFS: Port 4%s Pin Function Select Register
func (o *PFS_Type) SetP412PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP412PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P412PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP412PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP412PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP412PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP412PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP412PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP412PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP412PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP412PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP412PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP412PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP412PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP412PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP412PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP412PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP412PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP412PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P413PFS: Port 4%s Pin Function Select Register
func (o *PFS_Type) SetP413PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP413PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P413PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP413PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP413PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP413PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP413PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP413PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP413PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP413PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP413PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP413PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP413PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP413PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP413PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP413PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP413PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP413PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP413PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P414PFS: Port 4%s Pin Function Select Register
func (o *PFS_Type) SetP414PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP414PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P414PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP414PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP414PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP414PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP414PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP414PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP414PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP414PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP414PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP414PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP414PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP414PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP414PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP414PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP414PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP414PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP414PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P415PFS: Port 4%s Pin Function Select Register
func (o *PFS_Type) SetP415PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP415PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P415PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP415PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP415PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP415PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP415PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP415PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP415PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP415PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP415PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP415PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP415PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP415PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP415PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP415PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP415PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP415PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP415PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P500PFS: Port 50%s Pin Function Select Register
func (o *PFS_Type) SetP500PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP500PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P500PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP500PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP500PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP500PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP500PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP500PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP500PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP500PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP500PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP500PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP500PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP500PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP500PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP500PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP500PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP500PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP500PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P501PFS: Port 50%s Pin Function Select Register
func (o *PFS_Type) SetP501PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP501PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P501PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP501PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP501PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP501PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP501PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP501PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP501PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP501PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP501PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP501PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP501PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP501PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP501PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP501PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP501PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP501PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP501PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P502PFS: Port 50%s Pin Function Select Register
func (o *PFS_Type) SetP502PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP502PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P502PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP502PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP502PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP502PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP502PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP502PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP502PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP502PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP502PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP502PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP502PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP502PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP502PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP502PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP502PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP502PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP502PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P503PFS: Port 50%s Pin Function Select Register
func (o *PFS_Type) SetP503PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP503PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P503PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP503PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP503PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP503PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP503PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP503PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP503PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP503PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP503PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP503PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP503PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP503PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP503PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP503PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP503PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP503PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP503PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P504PFS: Port 50%s Pin Function Select Register
func (o *PFS_Type) SetP504PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP504PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P504PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP504PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP504PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP504PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP504PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP504PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP504PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP504PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP504PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP504PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP504PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP504PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP504PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP504PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP504PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP504PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP504PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P505PFS: Port 50%s Pin Function Select Register
func (o *PFS_Type) SetP505PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP505PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P505PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP505PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP505PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP505PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP505PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP505PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP505PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP505PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP505PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP505PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP505PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP505PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP505PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP505PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP505PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP505PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP505PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P600PFS: Port 60%s Pin Function Select Register
func (o *PFS_Type) SetP600PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP600PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P600PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP600PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP600PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP600PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP600PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP600PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP600PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP600PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP600PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP600PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP600PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP600PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP600PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP600PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP600PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP600PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP600PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P601PFS: Port 60%s Pin Function Select Register
func (o *PFS_Type) SetP601PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP601PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P601PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP601PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP601PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP601PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP601PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP601PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP601PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP601PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP601PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP601PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP601PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP601PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP601PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP601PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP601PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP601PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP601PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P602PFS: Port 60%s Pin Function Select Register
func (o *PFS_Type) SetP602PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP602PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P602PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP602PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP602PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP602PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP602PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP602PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP602PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP602PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP602PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP602PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP602PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP602PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP602PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP602PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP602PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP602PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP602PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P603PFS: Port 60%s Pin Function Select Register
func (o *PFS_Type) SetP603PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P603PFS.Reg, volatile.LoadUint32(&o.P603PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP603PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P603PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP603PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P603PFS.Reg, volatile.LoadUint32(&o.P603PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP603PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P603PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP603PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P603PFS.Reg, volatile.LoadUint32(&o.P603PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP603PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P603PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP603PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P603PFS.Reg, volatile.LoadUint32(&o.P603PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP603PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P603PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP603PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P603PFS.Reg, volatile.LoadUint32(&o.P603PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP603PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P603PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP603PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P603PFS.Reg, volatile.LoadUint32(&o.P603PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP603PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P603PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP603PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P603PFS.Reg, volatile.LoadUint32(&o.P603PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP603PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P603PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP603PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P603PFS.Reg, volatile.LoadUint32(&o.P603PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP603PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P603PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP603PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P603PFS.Reg, volatile.LoadUint32(&o.P603PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP603PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P603PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P608PFS: Port 60%s Pin Function Select Register
func (o *PFS_Type) SetP608PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP608PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P608PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP608PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP608PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP608PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP608PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP608PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP608PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP608PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP608PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP608PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP608PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP608PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP608PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP608PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP608PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP608PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP608PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P609PFS: Port 60%s Pin Function Select Register
func (o *PFS_Type) SetP609PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP609PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P609PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP609PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP609PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP609PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP609PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP609PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP609PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP609PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP609PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP609PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP609PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP609PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP609PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP609PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP609PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP609PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP609PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P610PFS: Port 610 Pin Function Select Register
func (o *PFS_Type) SetP610PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP610PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P610PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP610PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP610PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP610PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP610PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP610PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP610PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP610PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP610PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP610PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP610PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP610PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP610PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP610PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP610PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP610PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP610PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P708PFS: Port 708 Pin Function Select Register
func (o *PFS_Type) SetP708PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP708PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P708PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP708PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP708PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP708PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP708PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP708PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP708PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP708PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP708PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP708PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP708PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP708PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP708PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP708PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP708PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP708PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP708PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P714PFS: Port 714 Pin Function Select Register
func (o *PFS_Type) SetP714PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P714PFS.Reg, volatile.LoadUint32(&o.P714PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP714PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P714PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP714PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P714PFS.Reg, volatile.LoadUint32(&o.P714PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP714PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P714PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP714PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P714PFS.Reg, volatile.LoadUint32(&o.P714PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP714PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P714PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP714PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P714PFS.Reg, volatile.LoadUint32(&o.P714PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP714PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P714PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP714PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P714PFS.Reg, volatile.LoadUint32(&o.P714PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP714PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P714PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP714PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P714PFS.Reg, volatile.LoadUint32(&o.P714PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP714PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P714PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP714PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P714PFS.Reg, volatile.LoadUint32(&o.P714PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP714PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P714PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP714PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P714PFS.Reg, volatile.LoadUint32(&o.P714PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP714PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P714PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP714PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P714PFS.Reg, volatile.LoadUint32(&o.P714PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP714PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P714PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P808PFS: Port 80%s Pin Function Select Register
func (o *PFS_Type) SetP808PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P808PFS.Reg, volatile.LoadUint32(&o.P808PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP808PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P808PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP808PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P808PFS.Reg, volatile.LoadUint32(&o.P808PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP808PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P808PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP808PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P808PFS.Reg, volatile.LoadUint32(&o.P808PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP808PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P808PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP808PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P808PFS.Reg, volatile.LoadUint32(&o.P808PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP808PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P808PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP808PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P808PFS.Reg, volatile.LoadUint32(&o.P808PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP808PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P808PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP808PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P808PFS.Reg, volatile.LoadUint32(&o.P808PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP808PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P808PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP808PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P808PFS.Reg, volatile.LoadUint32(&o.P808PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP808PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P808PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP808PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P808PFS.Reg, volatile.LoadUint32(&o.P808PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP808PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P808PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP808PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P808PFS.Reg, volatile.LoadUint32(&o.P808PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP808PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P808PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P809PFS: Port 80%s Pin Function Select Register
func (o *PFS_Type) SetP809PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P809PFS.Reg, volatile.LoadUint32(&o.P809PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP809PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P809PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP809PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P809PFS.Reg, volatile.LoadUint32(&o.P809PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP809PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P809PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP809PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P809PFS.Reg, volatile.LoadUint32(&o.P809PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP809PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P809PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP809PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P809PFS.Reg, volatile.LoadUint32(&o.P809PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP809PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P809PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP809PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P809PFS.Reg, volatile.LoadUint32(&o.P809PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP809PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P809PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP809PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P809PFS.Reg, volatile.LoadUint32(&o.P809PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP809PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P809PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP809PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P809PFS.Reg, volatile.LoadUint32(&o.P809PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP809PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P809PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP809PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P809PFS.Reg, volatile.LoadUint32(&o.P809PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP809PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P809PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP809PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P809PFS.Reg, volatile.LoadUint32(&o.P809PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP809PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P809PFS.Reg) & 0x1f000000) >> 24
}

// PFS.PWPR: Write-Protect Register
func (o *PFS_Type) SetPWPR_PFSWE(value uint8) {
	volatile.StoreUint8(&o.PWPR.Reg, volatile.LoadUint8(&o.PWPR.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetPWPR_PFSWE() uint8 {
	return (volatile.LoadUint8(&o.PWPR.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetPWPR_B0WI(value uint8) {
	volatile.StoreUint8(&o.PWPR.Reg, volatile.LoadUint8(&o.PWPR.Reg)&^(0x80)|value<<7)
}
func (o *PFS_Type) GetPWPR_B0WI() uint8 {
	return (volatile.LoadUint8(&o.PWPR.Reg) & 0x80) >> 7
}

// PFS.PRWCNTR: Port Read Wait Control Register
func (o *PFS_Type) SetPRWCNTR_WAIT(value uint8) {
	volatile.StoreUint8(&o.PRWCNTR.Reg, volatile.LoadUint8(&o.PRWCNTR.Reg)&^(0x3)|value)
}
func (o *PFS_Type) GetPRWCNTR_WAIT() uint8 {
	return volatile.LoadUint8(&o.PRWCNTR.Reg) & 0x3
}

// Event Link Controller
type ELC_Type struct {
	ELCR    volatile.Register8 // 0x0
	_       byte
	ELSEGR0 volatile.Register8 // 0x2
	_       byte
	ELSEGR1 volatile.Register8 // 0x4
	_       [11]byte
	ELSR0   volatile.Register16 // 0x10
	_       [2]byte
	ELSR1   volatile.Register16 // 0x14
	_       [2]byte
	ELSR2   volatile.Register16 // 0x18
	_       [2]byte
	ELSR3   volatile.Register16 // 0x1C
	_       [18]byte
	ELSR8   volatile.Register16 // 0x30
	_       [2]byte
	ELSR9   volatile.Register16 // 0x34
	_       [10]byte
	ELSR12  volatile.Register16 // 0x40
	_       [6]byte
	ELSR14  volatile.Register16 // 0x48
	_       [2]byte
	ELSR15  volatile.Register16 // 0x4C
	_       [10]byte
	ELSR18  volatile.Register16 // 0x58
}

// ELC.ELCR: Event Link Controller Register
func (o *ELC_Type) SetELCR_ELCON(value uint8) {
	volatile.StoreUint8(&o.ELCR.Reg, volatile.LoadUint8(&o.ELCR.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELCR_ELCON() uint8 {
	return (volatile.LoadUint8(&o.ELCR.Reg) & 0x80) >> 7
}

// ELC.ELSEGR0: Event Link Software Event Generation Register %s
func (o *ELC_Type) SetELSEGR0_SEG(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x1)|value)
}
func (o *ELC_Type) GetELSEGR0_SEG() uint8 {
	return volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x1
}
func (o *ELC_Type) SetELSEGR0_WE(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x40)|value<<6)
}
func (o *ELC_Type) GetELSEGR0_WE() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x40) >> 6
}
func (o *ELC_Type) SetELSEGR0_WI(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELSEGR0_WI() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x80) >> 7
}

// ELC.ELSEGR1: Event Link Software Event Generation Register %s
func (o *ELC_Type) SetELSEGR1_SEG(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x1)|value)
}
func (o *ELC_Type) GetELSEGR1_SEG() uint8 {
	return volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x1
}
func (o *ELC_Type) SetELSEGR1_WE(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x40)|value<<6)
}
func (o *ELC_Type) GetELSEGR1_WE() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x40) >> 6
}
func (o *ELC_Type) SetELSEGR1_WI(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELSEGR1_WI() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x80) >> 7
}

// ELC.ELSR0: Event Link Setting Register %s
func (o *ELC_Type) SetELSR0_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR0.Reg, volatile.LoadUint16(&o.ELSR0.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR0_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR0.Reg) & 0xff
}

// ELC.ELSR1: Event Link Setting Register %s
func (o *ELC_Type) SetELSR1_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR1.Reg, volatile.LoadUint16(&o.ELSR1.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR1_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR1.Reg) & 0xff
}

// ELC.ELSR2: Event Link Setting Register %s
func (o *ELC_Type) SetELSR2_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR2.Reg, volatile.LoadUint16(&o.ELSR2.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR2_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR2.Reg) & 0xff
}

// ELC.ELSR3: Event Link Setting Register %s
func (o *ELC_Type) SetELSR3_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR3.Reg, volatile.LoadUint16(&o.ELSR3.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR3_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR3.Reg) & 0xff
}

// ELC.ELSR8: Event Link Setting Register %s
func (o *ELC_Type) SetELSR8_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR8.Reg, volatile.LoadUint16(&o.ELSR8.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR8_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR8.Reg) & 0xff
}

// ELC.ELSR9: Event Link Setting Register %s
func (o *ELC_Type) SetELSR9_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR9.Reg, volatile.LoadUint16(&o.ELSR9.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR9_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR9.Reg) & 0xff
}

// ELC.ELSR12: Event Link Setting Register 12
func (o *ELC_Type) SetELSR12_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR12.Reg, volatile.LoadUint16(&o.ELSR12.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR12_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR12.Reg) & 0xff
}

// ELC.ELSR14: Event Link Setting Register %s
func (o *ELC_Type) SetELSR14_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR14.Reg, volatile.LoadUint16(&o.ELSR14.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR14_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR14.Reg) & 0xff
}

// ELC.ELSR15: Event Link Setting Register %s
func (o *ELC_Type) SetELSR15_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR15.Reg, volatile.LoadUint16(&o.ELSR15.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR15_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR15.Reg) & 0xff
}

// ELC.ELSR18: Event Link Setting Register 18
func (o *ELC_Type) SetELSR18_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR18.Reg, volatile.LoadUint16(&o.ELSR18.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR18_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR18.Reg) & 0xff
}

// Port Output Enable Module for GPT
type POEG_Type struct {
	POEGGA volatile.Register32 // 0x0
	_      [252]byte
	POEGGB volatile.Register32 // 0x100
}

// POEG.POEGGA: POEG Group A Setting Register
func (o *POEG_Type) SetPOEGGA_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGA_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGA.Reg) & 0x1
}
func (o *POEG_Type) SetPOEGGA_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGA_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGA_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGA_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGA_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGA_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGA_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGA_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGA_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGA_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGA_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGA_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGA_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGA_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGA_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGA_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGA_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGA_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGA_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGA_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0xc0000000) >> 30
}

// POEG.POEGGB: POEG Group B Setting Register
func (o *POEG_Type) SetPOEGGB_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGB_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGB.Reg) & 0x1
}
func (o *POEG_Type) SetPOEGGB_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGB_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGB_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGB_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGB_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGB_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGB_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGB_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGB_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGB_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGB_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGB_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGB_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGB_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGB_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGB_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGB_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGB_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGB_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGB_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0xc0000000) >> 30
}

// Realtime Clock
type RTC_Type struct {
	R64CNT   volatile.Register8 // 0x0
	_        byte
	BCNT0    volatile.Register8 // 0x2
	_        byte
	BCNT1    volatile.Register8 // 0x4
	_        byte
	BCNT2    volatile.Register8 // 0x6
	_        byte
	BCNT3    volatile.Register8 // 0x8
	_        byte
	RDAYCNT  volatile.Register8 // 0xA
	_        byte
	RMONCNT  volatile.Register8 // 0xC
	_        byte
	RYRCNT   volatile.Register16 // 0xE
	BCNT0AR  volatile.Register8  // 0x10
	_        byte
	BCNT1AR  volatile.Register8 // 0x12
	_        byte
	BCNT2AR  volatile.Register8 // 0x14
	_        byte
	BCNT3AR  volatile.Register8 // 0x16
	_        byte
	BCNT0AER volatile.Register8 // 0x18
	_        byte
	BCNT1AER volatile.Register8 // 0x1A
	_        byte
	BCNT2AER volatile.Register16 // 0x1C
	BCNT3AER volatile.Register8  // 0x1E
	_        [3]byte
	RCR1     volatile.Register8 // 0x22
	_        byte
	RCR2     volatile.Register8 // 0x24
	_        [3]byte
	RCR4     volatile.Register8 // 0x28
	_        byte
	RFRH     volatile.Register16 // 0x2A
	RFRL     volatile.Register16 // 0x2C
	RADJ     volatile.Register8  // 0x2E
}

// RTC.R64CNT: 64-Hz Counter
func (o *RTC_Type) SetR64CNT_F64HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetR64CNT_F64HZ() uint8 {
	return volatile.LoadUint8(&o.R64CNT.Reg) & 0x1
}
func (o *RTC_Type) SetR64CNT_F32HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetR64CNT_F32HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetR64CNT_F16HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetR64CNT_F16HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetR64CNT_F8HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetR64CNT_F8HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetR64CNT_F4HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetR64CNT_F4HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetR64CNT_F2HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetR64CNT_F2HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetR64CNT_F1HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetR64CNT_F1HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetR64CNT_R64OVF(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetR64CNT_R64OVF() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x80) >> 7
}

// RTC.BCNT0: Binary Counter %s
func (o *RTC_Type) SetBCNT0(value uint8) {
	volatile.StoreUint8(&o.BCNT0.Reg, value)
}
func (o *RTC_Type) GetBCNT0() uint8 {
	return volatile.LoadUint8(&o.BCNT0.Reg)
}

// RTC.BCNT1: Binary Counter %s
func (o *RTC_Type) SetBCNT1(value uint8) {
	volatile.StoreUint8(&o.BCNT1.Reg, value)
}
func (o *RTC_Type) GetBCNT1() uint8 {
	return volatile.LoadUint8(&o.BCNT1.Reg)
}

// RTC.BCNT2: Binary Counter %s
func (o *RTC_Type) SetBCNT2(value uint8) {
	volatile.StoreUint8(&o.BCNT2.Reg, value)
}
func (o *RTC_Type) GetBCNT2() uint8 {
	return volatile.LoadUint8(&o.BCNT2.Reg)
}

// RTC.BCNT3: Binary Counter %s
func (o *RTC_Type) SetBCNT3(value uint8) {
	volatile.StoreUint8(&o.BCNT3.Reg, value)
}
func (o *RTC_Type) GetBCNT3() uint8 {
	return volatile.LoadUint8(&o.BCNT3.Reg)
}

// RTC.RDAYCNT: Day Counter
func (o *RTC_Type) SetRDAYCNT_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYCNT.Reg, volatile.LoadUint8(&o.RDAYCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYCNT_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYCNT.Reg) & 0xf
}
func (o *RTC_Type) SetRDAYCNT_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYCNT.Reg, volatile.LoadUint8(&o.RDAYCNT.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYCNT_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYCNT.Reg) & 0x30) >> 4
}

// RTC.RMONCNT: Month Counter
func (o *RTC_Type) SetRMONCNT_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCNT.Reg, volatile.LoadUint8(&o.RMONCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCNT_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCNT.Reg) & 0xf
}
func (o *RTC_Type) SetRMONCNT_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCNT.Reg, volatile.LoadUint8(&o.RMONCNT.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCNT_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCNT.Reg) & 0x10) >> 4
}

// RTC.RYRCNT: Year Counter
func (o *RTC_Type) SetRYRCNT_YR1(value uint16) {
	volatile.StoreUint16(&o.RYRCNT.Reg, volatile.LoadUint16(&o.RYRCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRYRCNT_YR1() uint16 {
	return volatile.LoadUint16(&o.RYRCNT.Reg) & 0xf
}
func (o *RTC_Type) SetRYRCNT_YR10(value uint16) {
	volatile.StoreUint16(&o.RYRCNT.Reg, volatile.LoadUint16(&o.RYRCNT.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetRYRCNT_YR10() uint16 {
	return (volatile.LoadUint16(&o.RYRCNT.Reg) & 0xf0) >> 4
}

// RTC.BCNT0AR: Binary Counter %s Alarm Register
func (o *RTC_Type) SetBCNT0AR(value uint8) {
	volatile.StoreUint8(&o.BCNT0AR.Reg, value)
}
func (o *RTC_Type) GetBCNT0AR() uint8 {
	return volatile.LoadUint8(&o.BCNT0AR.Reg)
}

// RTC.BCNT1AR: Binary Counter %s Alarm Register
func (o *RTC_Type) SetBCNT1AR(value uint8) {
	volatile.StoreUint8(&o.BCNT1AR.Reg, value)
}
func (o *RTC_Type) GetBCNT1AR() uint8 {
	return volatile.LoadUint8(&o.BCNT1AR.Reg)
}

// RTC.BCNT2AR: Binary Counter %s Alarm Register
func (o *RTC_Type) SetBCNT2AR(value uint8) {
	volatile.StoreUint8(&o.BCNT2AR.Reg, value)
}
func (o *RTC_Type) GetBCNT2AR() uint8 {
	return volatile.LoadUint8(&o.BCNT2AR.Reg)
}

// RTC.BCNT3AR: Binary Counter %s Alarm Register
func (o *RTC_Type) SetBCNT3AR(value uint8) {
	volatile.StoreUint8(&o.BCNT3AR.Reg, value)
}
func (o *RTC_Type) GetBCNT3AR() uint8 {
	return volatile.LoadUint8(&o.BCNT3AR.Reg)
}

// RTC.BCNT0AER: Binary Counter %s Alarm Enable Register
func (o *RTC_Type) SetBCNT0AER(value uint8) {
	volatile.StoreUint8(&o.BCNT0AER.Reg, value)
}
func (o *RTC_Type) GetBCNT0AER() uint8 {
	return volatile.LoadUint8(&o.BCNT0AER.Reg)
}

// RTC.BCNT1AER: Binary Counter %s Alarm Enable Register
func (o *RTC_Type) SetBCNT1AER(value uint8) {
	volatile.StoreUint8(&o.BCNT1AER.Reg, value)
}
func (o *RTC_Type) GetBCNT1AER() uint8 {
	return volatile.LoadUint8(&o.BCNT1AER.Reg)
}

// RTC.BCNT2AER: Binary Counter 2 Alarm Enable Register
func (o *RTC_Type) SetBCNT2AER_ENB(value uint16) {
	volatile.StoreUint16(&o.BCNT2AER.Reg, volatile.LoadUint16(&o.BCNT2AER.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetBCNT2AER_ENB() uint16 {
	return volatile.LoadUint16(&o.BCNT2AER.Reg) & 0xff
}

// RTC.BCNT3AER: Binary Counter 3 Alarm Enable Register
func (o *RTC_Type) SetBCNT3AER(value uint8) {
	volatile.StoreUint8(&o.BCNT3AER.Reg, value)
}
func (o *RTC_Type) GetBCNT3AER() uint8 {
	return volatile.LoadUint8(&o.BCNT3AER.Reg)
}

// RTC.RCR1: RTC Control Register 1
func (o *RTC_Type) SetRCR1_AIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR1_AIE() uint8 {
	return volatile.LoadUint8(&o.RCR1.Reg) & 0x1
}
func (o *RTC_Type) SetRCR1_CIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetRCR1_CIE() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetRCR1_PIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRCR1_PIE() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRCR1_RTCOS(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRCR1_RTCOS() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRCR1_PES(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetRCR1_PES() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0xf0) >> 4
}

// RTC.RCR2: RTC Control Register 2 (in Calendar Count Mode)
func (o *RTC_Type) SetRCR2_START(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR2_START() uint8 {
	return volatile.LoadUint8(&o.RCR2.Reg) & 0x1
}
func (o *RTC_Type) SetRCR2_RESET(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetRCR2_RESET() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetRCR2_ADJ30(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRCR2_ADJ30() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRCR2_RTCOE(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRCR2_RTCOE() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRCR2_AADJE(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRCR2_AADJE() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRCR2_AADJP(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetRCR2_AADJP() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetRCR2_HR24(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRCR2_HR24() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRCR2_CNTMD(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRCR2_CNTMD() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x80) >> 7
}

// RTC.RCR4: RTC Control Register 4
func (o *RTC_Type) SetRCR4_RCKSEL(value uint8) {
	volatile.StoreUint8(&o.RCR4.Reg, volatile.LoadUint8(&o.RCR4.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR4_RCKSEL() uint8 {
	return volatile.LoadUint8(&o.RCR4.Reg) & 0x1
}
func (o *RTC_Type) SetRCR4_ROPSEL(value uint8) {
	volatile.StoreUint8(&o.RCR4.Reg, volatile.LoadUint8(&o.RCR4.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRCR4_ROPSEL() uint8 {
	return (volatile.LoadUint8(&o.RCR4.Reg) & 0x80) >> 7
}

// RTC.RFRH: Frequency Register H
func (o *RTC_Type) SetRFRH_RFC16(value uint16) {
	volatile.StoreUint16(&o.RFRH.Reg, volatile.LoadUint16(&o.RFRH.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRFRH_RFC16() uint16 {
	return volatile.LoadUint16(&o.RFRH.Reg) & 0x1
}

// RTC.RFRL: Frequency Register L
func (o *RTC_Type) SetRFRL(value uint16) {
	volatile.StoreUint16(&o.RFRL.Reg, value)
}
func (o *RTC_Type) GetRFRL() uint16 {
	return volatile.LoadUint16(&o.RFRL.Reg)
}

// RTC.RADJ: Time Error Adjustment Register
func (o *RTC_Type) SetRADJ_ADJ(value uint8) {
	volatile.StoreUint8(&o.RADJ.Reg, volatile.LoadUint8(&o.RADJ.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetRADJ_ADJ() uint8 {
	return volatile.LoadUint8(&o.RADJ.Reg) & 0x3f
}
func (o *RTC_Type) SetRADJ_PMADJ(value uint8) {
	volatile.StoreUint8(&o.RADJ.Reg, volatile.LoadUint8(&o.RADJ.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_Type) GetRADJ_PMADJ() uint8 {
	return (volatile.LoadUint8(&o.RADJ.Reg) & 0xc0) >> 6
}

// Watchdog Timer
type WDT_Type struct {
	WDTRR    volatile.Register8 // 0x0
	_        byte
	WDTCR    volatile.Register16 // 0x2
	WDTSR    volatile.Register16 // 0x4
	WDTRCR   volatile.Register8  // 0x6
	_        byte
	WDTCSTPR volatile.Register8 // 0x8
}

// WDT.WDTCR: WDT Control Register
func (o *WDT_Type) SetWDTCR_TOPS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x3)|value)
}
func (o *WDT_Type) GetWDTCR_TOPS() uint16 {
	return volatile.LoadUint16(&o.WDTCR.Reg) & 0x3
}
func (o *WDT_Type) SetWDTCR_CKS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0xf0)|value<<4)
}
func (o *WDT_Type) GetWDTCR_CKS() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0xf0) >> 4
}
func (o *WDT_Type) SetWDTCR_RPES(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x300)|value<<8)
}
func (o *WDT_Type) GetWDTCR_RPES() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0x300) >> 8
}
func (o *WDT_Type) SetWDTCR_RPSS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x3000)|value<<12)
}
func (o *WDT_Type) GetWDTCR_RPSS() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0x3000) >> 12
}

// WDT.WDTSR: WDT Status Register
func (o *WDT_Type) SetWDTSR_CNTVAL(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x3fff)|value)
}
func (o *WDT_Type) GetWDTSR_CNTVAL() uint16 {
	return volatile.LoadUint16(&o.WDTSR.Reg) & 0x3fff
}
func (o *WDT_Type) SetWDTSR_UNDFF(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x4000)|value<<14)
}
func (o *WDT_Type) GetWDTSR_UNDFF() uint16 {
	return (volatile.LoadUint16(&o.WDTSR.Reg) & 0x4000) >> 14
}
func (o *WDT_Type) SetWDTSR_REFEF(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x8000)|value<<15)
}
func (o *WDT_Type) GetWDTSR_REFEF() uint16 {
	return (volatile.LoadUint16(&o.WDTSR.Reg) & 0x8000) >> 15
}

// WDT.WDTRCR: WDT Reset Control Register
func (o *WDT_Type) SetWDTRCR_RSTIRQS(value uint8) {
	volatile.StoreUint8(&o.WDTRCR.Reg, volatile.LoadUint8(&o.WDTRCR.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetWDTRCR_RSTIRQS() uint8 {
	return (volatile.LoadUint8(&o.WDTRCR.Reg) & 0x80) >> 7
}

// WDT.WDTCSTPR: WDT Count Stop Control Register
func (o *WDT_Type) SetWDTCSTPR_SLCSTP(value uint8) {
	volatile.StoreUint8(&o.WDTCSTPR.Reg, volatile.LoadUint8(&o.WDTCSTPR.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetWDTCSTPR_SLCSTP() uint8 {
	return (volatile.LoadUint8(&o.WDTCSTPR.Reg) & 0x80) >> 7
}

// Independent Watchdog Timer
type IWDT_Type struct {
	IWDTRR volatile.Register8 // 0x0
	_      [3]byte
	IWDTSR volatile.Register16 // 0x4
}

// IWDT.IWDTSR: IWDT Status Register
func (o *IWDT_Type) SetIWDTSR_CNTVAL(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x3fff)|value)
}
func (o *IWDT_Type) GetIWDTSR_CNTVAL() uint16 {
	return volatile.LoadUint16(&o.IWDTSR.Reg) & 0x3fff
}
func (o *IWDT_Type) SetIWDTSR_UNDFF(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x4000)|value<<14)
}
func (o *IWDT_Type) GetIWDTSR_UNDFF() uint16 {
	return (volatile.LoadUint16(&o.IWDTSR.Reg) & 0x4000) >> 14
}
func (o *IWDT_Type) SetIWDTSR_REFEF(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x8000)|value<<15)
}
func (o *IWDT_Type) GetIWDTSR_REFEF() uint16 {
	return (volatile.LoadUint16(&o.IWDTSR.Reg) & 0x8000) >> 15
}

// Clock Frequency Accuracy Measurement Circuit
type CAC_Type struct {
	CACR0   volatile.Register8 // 0x0
	CACR1   volatile.Register8 // 0x1
	CACR2   volatile.Register8 // 0x2
	CAICR   volatile.Register8 // 0x3
	CASTR   volatile.Register8 // 0x4
	_       byte
	CAULVR  volatile.Register16 // 0x6
	CALLVR  volatile.Register16 // 0x8
	CACNTBR volatile.Register16 // 0xA
}

// CAC.CACR0: CAC Control Register 0
func (o *CAC_Type) SetCACR0_CFME(value uint8) {
	volatile.StoreUint8(&o.CACR0.Reg, volatile.LoadUint8(&o.CACR0.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR0_CFME() uint8 {
	return volatile.LoadUint8(&o.CACR0.Reg) & 0x1
}

// CAC.CACR1: CAC Control Register 1
func (o *CAC_Type) SetCACR1_CACREFE(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR1_CACREFE() uint8 {
	return volatile.LoadUint8(&o.CACR1.Reg) & 0x1
}
func (o *CAC_Type) SetCACR1_FMCS(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0xe)|value<<1)
}
func (o *CAC_Type) GetCACR1_FMCS() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0xe) >> 1
}
func (o *CAC_Type) SetCACR1_TCSS(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0x30)|value<<4)
}
func (o *CAC_Type) GetCACR1_TCSS() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0x30) >> 4
}
func (o *CAC_Type) SetCACR1_EDGES(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0xc0)|value<<6)
}
func (o *CAC_Type) GetCACR1_EDGES() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0xc0) >> 6
}

// CAC.CACR2: CAC Control Register 2
func (o *CAC_Type) SetCACR2_RPS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR2_RPS() uint8 {
	return volatile.LoadUint8(&o.CACR2.Reg) & 0x1
}
func (o *CAC_Type) SetCACR2_RSCS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0xe)|value<<1)
}
func (o *CAC_Type) GetCACR2_RSCS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0xe) >> 1
}
func (o *CAC_Type) SetCACR2_RCDS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0x30)|value<<4)
}
func (o *CAC_Type) GetCACR2_RCDS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0x30) >> 4
}
func (o *CAC_Type) SetCACR2_DFS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0xc0)|value<<6)
}
func (o *CAC_Type) GetCACR2_DFS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0xc0) >> 6
}

// CAC.CAICR: CAC Interrupt Control Register
func (o *CAC_Type) SetCAICR_FERRIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCAICR_FERRIE() uint8 {
	return volatile.LoadUint8(&o.CAICR.Reg) & 0x1
}
func (o *CAC_Type) SetCAICR_MENDIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x2)|value<<1)
}
func (o *CAC_Type) GetCAICR_MENDIE() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x2) >> 1
}
func (o *CAC_Type) SetCAICR_OVFIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x4)|value<<2)
}
func (o *CAC_Type) GetCAICR_OVFIE() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x4) >> 2
}
func (o *CAC_Type) SetCAICR_FERRFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x10)|value<<4)
}
func (o *CAC_Type) GetCAICR_FERRFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x10) >> 4
}
func (o *CAC_Type) SetCAICR_MENDFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x20)|value<<5)
}
func (o *CAC_Type) GetCAICR_MENDFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x20) >> 5
}
func (o *CAC_Type) SetCAICR_OVFFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x40)|value<<6)
}
func (o *CAC_Type) GetCAICR_OVFFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x40) >> 6
}

// CAC.CASTR: CAC Status Register
func (o *CAC_Type) SetCASTR_FERRF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCASTR_FERRF() uint8 {
	return volatile.LoadUint8(&o.CASTR.Reg) & 0x1
}
func (o *CAC_Type) SetCASTR_MENDF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x2)|value<<1)
}
func (o *CAC_Type) GetCASTR_MENDF() uint8 {
	return (volatile.LoadUint8(&o.CASTR.Reg) & 0x2) >> 1
}
func (o *CAC_Type) SetCASTR_OVFF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x4)|value<<2)
}
func (o *CAC_Type) GetCASTR_OVFF() uint8 {
	return (volatile.LoadUint8(&o.CASTR.Reg) & 0x4) >> 2
}

// Module Stop Control B, C, D
type MSTP_Type struct {
	MSTPCRB  volatile.Register32 // 0x0
	MSTPCRC  volatile.Register32 // 0x4
	MSTPCRD  volatile.Register32 // 0x8
	LSMRWDIS volatile.Register16 // 0xC
}

// MSTP.MSTPCRB: Module Stop Control Register B
func (o *MSTP_Type) SetMSTPCRB_MSTPB2(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB2() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x4) >> 2
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB8(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x100)|value<<8)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB8() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x100) >> 8
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB9(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x200)|value<<9)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB9() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x200) >> 9
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB18(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x40000)|value<<18)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB18() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x40000) >> 18
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB19(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x80000)|value<<19)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB19() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x80000) >> 19
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB22(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x400000)|value<<22)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB22() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x400000) >> 22
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB28(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x10000000)|value<<28)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB28() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x10000000) >> 28
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB29(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x20000000)|value<<29)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB29() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x20000000) >> 29
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB30(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x40000000)|value<<30)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB30() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x40000000) >> 30
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB31(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x80000000)|value<<31)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB31() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x80000000) >> 31
}

// MSTP.MSTPCRC: Module Stop Control Register C
func (o *MSTP_Type) SetMSTPCRC_MSTPC0(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x1)|value)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC0() uint32 {
	return volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x1
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC1(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x2)|value<<1)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC1() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x2) >> 1
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC3(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x8)|value<<3)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC3() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x8) >> 3
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC13(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x2000)|value<<13)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC13() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x2000) >> 13
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC14(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x4000)|value<<14)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC14() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x4000) >> 14
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC28(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x10000000)|value<<28)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC28() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x10000000) >> 28
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC31(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x80000000)|value<<31)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC31() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x80000000) >> 31
}

// MSTP.MSTPCRD: Module Stop Control Register D
func (o *MSTP_Type) SetMSTPCRD_MSTPD2(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD2() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x4) >> 2
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD3(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x8)|value<<3)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD3() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x8) >> 3
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD5(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x20)|value<<5)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD5() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x20) >> 5
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD6(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x40)|value<<6)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD6() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x40) >> 6
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD14(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x4000)|value<<14)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD14() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x4000) >> 14
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD16(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x10000)|value<<16)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD16() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x10000) >> 16
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD20(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x100000)|value<<20)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD20() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x100000) >> 20
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD29(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x20000000)|value<<29)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD29() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x20000000) >> 29
}

// MSTP.LSMRWDIS: Low Speed Module R/W Disable Control Register
func (o *MSTP_Type) SetLSMRWDIS_RTCRWDIS(value uint16) {
	volatile.StoreUint16(&o.LSMRWDIS.Reg, volatile.LoadUint16(&o.LSMRWDIS.Reg)&^(0x1)|value)
}
func (o *MSTP_Type) GetLSMRWDIS_RTCRWDIS() uint16 {
	return volatile.LoadUint16(&o.LSMRWDIS.Reg) & 0x1
}
func (o *MSTP_Type) SetLSMRWDIS_WDTDIS(value uint16) {
	volatile.StoreUint16(&o.LSMRWDIS.Reg, volatile.LoadUint16(&o.LSMRWDIS.Reg)&^(0x2)|value<<1)
}
func (o *MSTP_Type) GetLSMRWDIS_WDTDIS() uint16 {
	return (volatile.LoadUint16(&o.LSMRWDIS.Reg) & 0x2) >> 1
}
func (o *MSTP_Type) SetLSMRWDIS_IWDTIDS(value uint16) {
	volatile.StoreUint16(&o.LSMRWDIS.Reg, volatile.LoadUint16(&o.LSMRWDIS.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetLSMRWDIS_IWDTIDS() uint16 {
	return (volatile.LoadUint16(&o.LSMRWDIS.Reg) & 0x4) >> 2
}
func (o *MSTP_Type) SetLSMRWDIS_WREN(value uint16) {
	volatile.StoreUint16(&o.LSMRWDIS.Reg, volatile.LoadUint16(&o.LSMRWDIS.Reg)&^(0x80)|value<<7)
}
func (o *MSTP_Type) GetLSMRWDIS_WREN() uint16 {
	return (volatile.LoadUint16(&o.LSMRWDIS.Reg) & 0x80) >> 7
}
func (o *MSTP_Type) SetLSMRWDIS_PRKEY(value uint16) {
	volatile.StoreUint16(&o.LSMRWDIS.Reg, volatile.LoadUint16(&o.LSMRWDIS.Reg)&^(0xff00)|value<<8)
}
func (o *MSTP_Type) GetLSMRWDIS_PRKEY() uint16 {
	return (volatile.LoadUint16(&o.LSMRWDIS.Reg) & 0xff00) >> 8
}

// Controller Area Network
type CAN0_Type struct {
	_       [512]byte
	MB0_ID  volatile.Register32    // 0x200
	MB0_DL  volatile.Register16    // 0x204
	MB0_D0  volatile.Register8     // 0x206
	MB0_D1  volatile.Register8     // 0x207
	MB0_D2  volatile.Register8     // 0x208
	MB0_D3  volatile.Register8     // 0x209
	MB0_D4  volatile.Register8     // 0x20A
	MB0_D5  volatile.Register8     // 0x20B
	MB0_D6  volatile.Register8     // 0x20C
	MB0_D7  volatile.Register8     // 0x20D
	MB0_TS  volatile.Register16    // 0x20E
	MB1_ID  volatile.Register32    // 0x210
	MB1_DL  volatile.Register16    // 0x214
	MB1_D0  volatile.Register8     // 0x216
	MB1_D1  volatile.Register8     // 0x217
	MB1_D2  volatile.Register8     // 0x218
	MB1_D3  volatile.Register8     // 0x219
	MB1_D4  volatile.Register8     // 0x21A
	MB1_D5  volatile.Register8     // 0x21B
	MB1_D6  volatile.Register8     // 0x21C
	MB1_D7  volatile.Register8     // 0x21D
	MB1_TS  volatile.Register16    // 0x21E
	MB2_ID  volatile.Register32    // 0x220
	MB2_DL  volatile.Register16    // 0x224
	MB2_D0  volatile.Register8     // 0x226
	MB2_D1  volatile.Register8     // 0x227
	MB2_D2  volatile.Register8     // 0x228
	MB2_D3  volatile.Register8     // 0x229
	MB2_D4  volatile.Register8     // 0x22A
	MB2_D5  volatile.Register8     // 0x22B
	MB2_D6  volatile.Register8     // 0x22C
	MB2_D7  volatile.Register8     // 0x22D
	MB2_TS  volatile.Register16    // 0x22E
	MB3_ID  volatile.Register32    // 0x230
	MB3_DL  volatile.Register16    // 0x234
	MB3_D0  volatile.Register8     // 0x236
	MB3_D1  volatile.Register8     // 0x237
	MB3_D2  volatile.Register8     // 0x238
	MB3_D3  volatile.Register8     // 0x239
	MB3_D4  volatile.Register8     // 0x23A
	MB3_D5  volatile.Register8     // 0x23B
	MB3_D6  volatile.Register8     // 0x23C
	MB3_D7  volatile.Register8     // 0x23D
	MB3_TS  volatile.Register16    // 0x23E
	MB4_ID  volatile.Register32    // 0x240
	MB4_DL  volatile.Register16    // 0x244
	MB4_D0  volatile.Register8     // 0x246
	MB4_D1  volatile.Register8     // 0x247
	MB4_D2  volatile.Register8     // 0x248
	MB4_D3  volatile.Register8     // 0x249
	MB4_D4  volatile.Register8     // 0x24A
	MB4_D5  volatile.Register8     // 0x24B
	MB4_D6  volatile.Register8     // 0x24C
	MB4_D7  volatile.Register8     // 0x24D
	MB4_TS  volatile.Register16    // 0x24E
	MB5_ID  volatile.Register32    // 0x250
	MB5_DL  volatile.Register16    // 0x254
	MB5_D0  volatile.Register8     // 0x256
	MB5_D1  volatile.Register8     // 0x257
	MB5_D2  volatile.Register8     // 0x258
	MB5_D3  volatile.Register8     // 0x259
	MB5_D4  volatile.Register8     // 0x25A
	MB5_D5  volatile.Register8     // 0x25B
	MB5_D6  volatile.Register8     // 0x25C
	MB5_D7  volatile.Register8     // 0x25D
	MB5_TS  volatile.Register16    // 0x25E
	MB6_ID  volatile.Register32    // 0x260
	MB6_DL  volatile.Register16    // 0x264
	MB6_D0  volatile.Register8     // 0x266
	MB6_D1  volatile.Register8     // 0x267
	MB6_D2  volatile.Register8     // 0x268
	MB6_D3  volatile.Register8     // 0x269
	MB6_D4  volatile.Register8     // 0x26A
	MB6_D5  volatile.Register8     // 0x26B
	MB6_D6  volatile.Register8     // 0x26C
	MB6_D7  volatile.Register8     // 0x26D
	MB6_TS  volatile.Register16    // 0x26E
	MB7_ID  volatile.Register32    // 0x270
	MB7_DL  volatile.Register16    // 0x274
	MB7_D0  volatile.Register8     // 0x276
	MB7_D1  volatile.Register8     // 0x277
	MB7_D2  volatile.Register8     // 0x278
	MB7_D3  volatile.Register8     // 0x279
	MB7_D4  volatile.Register8     // 0x27A
	MB7_D5  volatile.Register8     // 0x27B
	MB7_D6  volatile.Register8     // 0x27C
	MB7_D7  volatile.Register8     // 0x27D
	MB7_TS  volatile.Register16    // 0x27E
	MB8_ID  volatile.Register32    // 0x280
	MB8_DL  volatile.Register16    // 0x284
	MB8_D0  volatile.Register8     // 0x286
	MB8_D1  volatile.Register8     // 0x287
	MB8_D2  volatile.Register8     // 0x288
	MB8_D3  volatile.Register8     // 0x289
	MB8_D4  volatile.Register8     // 0x28A
	MB8_D5  volatile.Register8     // 0x28B
	MB8_D6  volatile.Register8     // 0x28C
	MB8_D7  volatile.Register8     // 0x28D
	MB8_TS  volatile.Register16    // 0x28E
	MB9_ID  volatile.Register32    // 0x290
	MB9_DL  volatile.Register16    // 0x294
	MB9_D0  volatile.Register8     // 0x296
	MB9_D1  volatile.Register8     // 0x297
	MB9_D2  volatile.Register8     // 0x298
	MB9_D3  volatile.Register8     // 0x299
	MB9_D4  volatile.Register8     // 0x29A
	MB9_D5  volatile.Register8     // 0x29B
	MB9_D6  volatile.Register8     // 0x29C
	MB9_D7  volatile.Register8     // 0x29D
	MB9_TS  volatile.Register16    // 0x29E
	MB10_ID volatile.Register32    // 0x2A0
	MB10_DL volatile.Register16    // 0x2A4
	MB10_D0 volatile.Register8     // 0x2A6
	MB10_D1 volatile.Register8     // 0x2A7
	MB10_D2 volatile.Register8     // 0x2A8
	MB10_D3 volatile.Register8     // 0x2A9
	MB10_D4 volatile.Register8     // 0x2AA
	MB10_D5 volatile.Register8     // 0x2AB
	MB10_D6 volatile.Register8     // 0x2AC
	MB10_D7 volatile.Register8     // 0x2AD
	MB10_TS volatile.Register16    // 0x2AE
	MB11_ID volatile.Register32    // 0x2B0
	MB11_DL volatile.Register16    // 0x2B4
	MB11_D0 volatile.Register8     // 0x2B6
	MB11_D1 volatile.Register8     // 0x2B7
	MB11_D2 volatile.Register8     // 0x2B8
	MB11_D3 volatile.Register8     // 0x2B9
	MB11_D4 volatile.Register8     // 0x2BA
	MB11_D5 volatile.Register8     // 0x2BB
	MB11_D6 volatile.Register8     // 0x2BC
	MB11_D7 volatile.Register8     // 0x2BD
	MB11_TS volatile.Register16    // 0x2BE
	MB12_ID volatile.Register32    // 0x2C0
	MB12_DL volatile.Register16    // 0x2C4
	MB12_D0 volatile.Register8     // 0x2C6
	MB12_D1 volatile.Register8     // 0x2C7
	MB12_D2 volatile.Register8     // 0x2C8
	MB12_D3 volatile.Register8     // 0x2C9
	MB12_D4 volatile.Register8     // 0x2CA
	MB12_D5 volatile.Register8     // 0x2CB
	MB12_D6 volatile.Register8     // 0x2CC
	MB12_D7 volatile.Register8     // 0x2CD
	MB12_TS volatile.Register16    // 0x2CE
	MB13_ID volatile.Register32    // 0x2D0
	MB13_DL volatile.Register16    // 0x2D4
	MB13_D0 volatile.Register8     // 0x2D6
	MB13_D1 volatile.Register8     // 0x2D7
	MB13_D2 volatile.Register8     // 0x2D8
	MB13_D3 volatile.Register8     // 0x2D9
	MB13_D4 volatile.Register8     // 0x2DA
	MB13_D5 volatile.Register8     // 0x2DB
	MB13_D6 volatile.Register8     // 0x2DC
	MB13_D7 volatile.Register8     // 0x2DD
	MB13_TS volatile.Register16    // 0x2DE
	MB14_ID volatile.Register32    // 0x2E0
	MB14_DL volatile.Register16    // 0x2E4
	MB14_D0 volatile.Register8     // 0x2E6
	MB14_D1 volatile.Register8     // 0x2E7
	MB14_D2 volatile.Register8     // 0x2E8
	MB14_D3 volatile.Register8     // 0x2E9
	MB14_D4 volatile.Register8     // 0x2EA
	MB14_D5 volatile.Register8     // 0x2EB
	MB14_D6 volatile.Register8     // 0x2EC
	MB14_D7 volatile.Register8     // 0x2ED
	MB14_TS volatile.Register16    // 0x2EE
	MB15_ID volatile.Register32    // 0x2F0
	MB15_DL volatile.Register16    // 0x2F4
	MB15_D0 volatile.Register8     // 0x2F6
	MB15_D1 volatile.Register8     // 0x2F7
	MB15_D2 volatile.Register8     // 0x2F8
	MB15_D3 volatile.Register8     // 0x2F9
	MB15_D4 volatile.Register8     // 0x2FA
	MB15_D5 volatile.Register8     // 0x2FB
	MB15_D6 volatile.Register8     // 0x2FC
	MB15_D7 volatile.Register8     // 0x2FD
	MB15_TS volatile.Register16    // 0x2FE
	MB16_ID volatile.Register32    // 0x300
	MB16_DL volatile.Register16    // 0x304
	MB16_D0 volatile.Register8     // 0x306
	MB16_D1 volatile.Register8     // 0x307
	MB16_D2 volatile.Register8     // 0x308
	MB16_D3 volatile.Register8     // 0x309
	MB16_D4 volatile.Register8     // 0x30A
	MB16_D5 volatile.Register8     // 0x30B
	MB16_D6 volatile.Register8     // 0x30C
	MB16_D7 volatile.Register8     // 0x30D
	MB16_TS volatile.Register16    // 0x30E
	MB17_ID volatile.Register32    // 0x310
	MB17_DL volatile.Register16    // 0x314
	MB17_D0 volatile.Register8     // 0x316
	MB17_D1 volatile.Register8     // 0x317
	MB17_D2 volatile.Register8     // 0x318
	MB17_D3 volatile.Register8     // 0x319
	MB17_D4 volatile.Register8     // 0x31A
	MB17_D5 volatile.Register8     // 0x31B
	MB17_D6 volatile.Register8     // 0x31C
	MB17_D7 volatile.Register8     // 0x31D
	MB17_TS volatile.Register16    // 0x31E
	MB18_ID volatile.Register32    // 0x320
	MB18_DL volatile.Register16    // 0x324
	MB18_D0 volatile.Register8     // 0x326
	MB18_D1 volatile.Register8     // 0x327
	MB18_D2 volatile.Register8     // 0x328
	MB18_D3 volatile.Register8     // 0x329
	MB18_D4 volatile.Register8     // 0x32A
	MB18_D5 volatile.Register8     // 0x32B
	MB18_D6 volatile.Register8     // 0x32C
	MB18_D7 volatile.Register8     // 0x32D
	MB18_TS volatile.Register16    // 0x32E
	MB19_ID volatile.Register32    // 0x330
	MB19_DL volatile.Register16    // 0x334
	MB19_D0 volatile.Register8     // 0x336
	MB19_D1 volatile.Register8     // 0x337
	MB19_D2 volatile.Register8     // 0x338
	MB19_D3 volatile.Register8     // 0x339
	MB19_D4 volatile.Register8     // 0x33A
	MB19_D5 volatile.Register8     // 0x33B
	MB19_D6 volatile.Register8     // 0x33C
	MB19_D7 volatile.Register8     // 0x33D
	MB19_TS volatile.Register16    // 0x33E
	MB20_ID volatile.Register32    // 0x340
	MB20_DL volatile.Register16    // 0x344
	MB20_D0 volatile.Register8     // 0x346
	MB20_D1 volatile.Register8     // 0x347
	MB20_D2 volatile.Register8     // 0x348
	MB20_D3 volatile.Register8     // 0x349
	MB20_D4 volatile.Register8     // 0x34A
	MB20_D5 volatile.Register8     // 0x34B
	MB20_D6 volatile.Register8     // 0x34C
	MB20_D7 volatile.Register8     // 0x34D
	MB20_TS volatile.Register16    // 0x34E
	MB21_ID volatile.Register32    // 0x350
	MB21_DL volatile.Register16    // 0x354
	MB21_D0 volatile.Register8     // 0x356
	MB21_D1 volatile.Register8     // 0x357
	MB21_D2 volatile.Register8     // 0x358
	MB21_D3 volatile.Register8     // 0x359
	MB21_D4 volatile.Register8     // 0x35A
	MB21_D5 volatile.Register8     // 0x35B
	MB21_D6 volatile.Register8     // 0x35C
	MB21_D7 volatile.Register8     // 0x35D
	MB21_TS volatile.Register16    // 0x35E
	MB22_ID volatile.Register32    // 0x360
	MB22_DL volatile.Register16    // 0x364
	MB22_D0 volatile.Register8     // 0x366
	MB22_D1 volatile.Register8     // 0x367
	MB22_D2 volatile.Register8     // 0x368
	MB22_D3 volatile.Register8     // 0x369
	MB22_D4 volatile.Register8     // 0x36A
	MB22_D5 volatile.Register8     // 0x36B
	MB22_D6 volatile.Register8     // 0x36C
	MB22_D7 volatile.Register8     // 0x36D
	MB22_TS volatile.Register16    // 0x36E
	MB23_ID volatile.Register32    // 0x370
	MB23_DL volatile.Register16    // 0x374
	MB23_D0 volatile.Register8     // 0x376
	MB23_D1 volatile.Register8     // 0x377
	MB23_D2 volatile.Register8     // 0x378
	MB23_D3 volatile.Register8     // 0x379
	MB23_D4 volatile.Register8     // 0x37A
	MB23_D5 volatile.Register8     // 0x37B
	MB23_D6 volatile.Register8     // 0x37C
	MB23_D7 volatile.Register8     // 0x37D
	MB23_TS volatile.Register16    // 0x37E
	MB24_ID volatile.Register32    // 0x380
	MB24_DL volatile.Register16    // 0x384
	MB24_D0 volatile.Register8     // 0x386
	MB24_D1 volatile.Register8     // 0x387
	MB24_D2 volatile.Register8     // 0x388
	MB24_D3 volatile.Register8     // 0x389
	MB24_D4 volatile.Register8     // 0x38A
	MB24_D5 volatile.Register8     // 0x38B
	MB24_D6 volatile.Register8     // 0x38C
	MB24_D7 volatile.Register8     // 0x38D
	MB24_TS volatile.Register16    // 0x38E
	MB25_ID volatile.Register32    // 0x390
	MB25_DL volatile.Register16    // 0x394
	MB25_D0 volatile.Register8     // 0x396
	MB25_D1 volatile.Register8     // 0x397
	MB25_D2 volatile.Register8     // 0x398
	MB25_D3 volatile.Register8     // 0x399
	MB25_D4 volatile.Register8     // 0x39A
	MB25_D5 volatile.Register8     // 0x39B
	MB25_D6 volatile.Register8     // 0x39C
	MB25_D7 volatile.Register8     // 0x39D
	MB25_TS volatile.Register16    // 0x39E
	MB26_ID volatile.Register32    // 0x3A0
	MB26_DL volatile.Register16    // 0x3A4
	MB26_D0 volatile.Register8     // 0x3A6
	MB26_D1 volatile.Register8     // 0x3A7
	MB26_D2 volatile.Register8     // 0x3A8
	MB26_D3 volatile.Register8     // 0x3A9
	MB26_D4 volatile.Register8     // 0x3AA
	MB26_D5 volatile.Register8     // 0x3AB
	MB26_D6 volatile.Register8     // 0x3AC
	MB26_D7 volatile.Register8     // 0x3AD
	MB26_TS volatile.Register16    // 0x3AE
	MB27_ID volatile.Register32    // 0x3B0
	MB27_DL volatile.Register16    // 0x3B4
	MB27_D0 volatile.Register8     // 0x3B6
	MB27_D1 volatile.Register8     // 0x3B7
	MB27_D2 volatile.Register8     // 0x3B8
	MB27_D3 volatile.Register8     // 0x3B9
	MB27_D4 volatile.Register8     // 0x3BA
	MB27_D5 volatile.Register8     // 0x3BB
	MB27_D6 volatile.Register8     // 0x3BC
	MB27_D7 volatile.Register8     // 0x3BD
	MB27_TS volatile.Register16    // 0x3BE
	MB28_ID volatile.Register32    // 0x3C0
	MB28_DL volatile.Register16    // 0x3C4
	MB28_D0 volatile.Register8     // 0x3C6
	MB28_D1 volatile.Register8     // 0x3C7
	MB28_D2 volatile.Register8     // 0x3C8
	MB28_D3 volatile.Register8     // 0x3C9
	MB28_D4 volatile.Register8     // 0x3CA
	MB28_D5 volatile.Register8     // 0x3CB
	MB28_D6 volatile.Register8     // 0x3CC
	MB28_D7 volatile.Register8     // 0x3CD
	MB28_TS volatile.Register16    // 0x3CE
	MB29_ID volatile.Register32    // 0x3D0
	MB29_DL volatile.Register16    // 0x3D4
	MB29_D0 volatile.Register8     // 0x3D6
	MB29_D1 volatile.Register8     // 0x3D7
	MB29_D2 volatile.Register8     // 0x3D8
	MB29_D3 volatile.Register8     // 0x3D9
	MB29_D4 volatile.Register8     // 0x3DA
	MB29_D5 volatile.Register8     // 0x3DB
	MB29_D6 volatile.Register8     // 0x3DC
	MB29_D7 volatile.Register8     // 0x3DD
	MB29_TS volatile.Register16    // 0x3DE
	MB30_ID volatile.Register32    // 0x3E0
	MB30_DL volatile.Register16    // 0x3E4
	MB30_D0 volatile.Register8     // 0x3E6
	MB30_D1 volatile.Register8     // 0x3E7
	MB30_D2 volatile.Register8     // 0x3E8
	MB30_D3 volatile.Register8     // 0x3E9
	MB30_D4 volatile.Register8     // 0x3EA
	MB30_D5 volatile.Register8     // 0x3EB
	MB30_D6 volatile.Register8     // 0x3EC
	MB30_D7 volatile.Register8     // 0x3ED
	MB30_TS volatile.Register16    // 0x3EE
	MB31_ID volatile.Register32    // 0x3F0
	MB31_DL volatile.Register16    // 0x3F4
	MB31_D0 volatile.Register8     // 0x3F6
	MB31_D1 volatile.Register8     // 0x3F7
	MB31_D2 volatile.Register8     // 0x3F8
	MB31_D3 volatile.Register8     // 0x3F9
	MB31_D4 volatile.Register8     // 0x3FA
	MB31_D5 volatile.Register8     // 0x3FB
	MB31_D6 volatile.Register8     // 0x3FC
	MB31_D7 volatile.Register8     // 0x3FD
	MB31_TS volatile.Register16    // 0x3FE
	MKR     [8]volatile.Register32 // 0x400
	FIDCR0  volatile.Register32    // 0x420
	FIDCR1  volatile.Register32    // 0x424
	MKIVLR  volatile.Register32    // 0x428
	MIER    volatile.Register32    // 0x42C
	_       [1008]byte
	MCTL_RX [32]volatile.Register8 // 0x820
	CTLR    volatile.Register16    // 0x840
	STR     volatile.Register16    // 0x842
	BCR     volatile.Register32    // 0x844
	RFCR    volatile.Register8     // 0x848
	RFPCR   volatile.Register8     // 0x849
	TFCR    volatile.Register8     // 0x84A
	TFPCR   volatile.Register8     // 0x84B
	EIER    volatile.Register8     // 0x84C
	EIFR    volatile.Register8     // 0x84D
	RECR    volatile.Register8     // 0x84E
	TECR    volatile.Register8     // 0x84F
	ECSR    volatile.Register8     // 0x850
	CSSR    volatile.Register8     // 0x851
	MSSR    volatile.Register8     // 0x852
	MSMR    volatile.Register8     // 0x853
	TSR     volatile.Register16    // 0x854
	AFSR    volatile.Register16    // 0x856
	TCR     volatile.Register8     // 0x858
}

// CAN0.MB0_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB0_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB0_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB0_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB0_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB0_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB0_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB0_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB0_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB0_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB0_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB0_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB0_DL.Reg, volatile.LoadUint16(&o.MB0_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB0_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB0_DL.Reg) & 0xf
}

// CAN0.MB0_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D0(value uint8) {
	volatile.StoreUint8(&o.MB0_D0.Reg, value)
}
func (o *CAN0_Type) GetMB0_D0() uint8 {
	return volatile.LoadUint8(&o.MB0_D0.Reg)
}

// CAN0.MB0_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D1(value uint8) {
	volatile.StoreUint8(&o.MB0_D1.Reg, value)
}
func (o *CAN0_Type) GetMB0_D1() uint8 {
	return volatile.LoadUint8(&o.MB0_D1.Reg)
}

// CAN0.MB0_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D2(value uint8) {
	volatile.StoreUint8(&o.MB0_D2.Reg, value)
}
func (o *CAN0_Type) GetMB0_D2() uint8 {
	return volatile.LoadUint8(&o.MB0_D2.Reg)
}

// CAN0.MB0_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D3(value uint8) {
	volatile.StoreUint8(&o.MB0_D3.Reg, value)
}
func (o *CAN0_Type) GetMB0_D3() uint8 {
	return volatile.LoadUint8(&o.MB0_D3.Reg)
}

// CAN0.MB0_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D4(value uint8) {
	volatile.StoreUint8(&o.MB0_D4.Reg, value)
}
func (o *CAN0_Type) GetMB0_D4() uint8 {
	return volatile.LoadUint8(&o.MB0_D4.Reg)
}

// CAN0.MB0_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D5(value uint8) {
	volatile.StoreUint8(&o.MB0_D5.Reg, value)
}
func (o *CAN0_Type) GetMB0_D5() uint8 {
	return volatile.LoadUint8(&o.MB0_D5.Reg)
}

// CAN0.MB0_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D6(value uint8) {
	volatile.StoreUint8(&o.MB0_D6.Reg, value)
}
func (o *CAN0_Type) GetMB0_D6() uint8 {
	return volatile.LoadUint8(&o.MB0_D6.Reg)
}

// CAN0.MB0_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D7(value uint8) {
	volatile.StoreUint8(&o.MB0_D7.Reg, value)
}
func (o *CAN0_Type) GetMB0_D7() uint8 {
	return volatile.LoadUint8(&o.MB0_D7.Reg)
}

// CAN0.MB0_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB0_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB0_TS.Reg, volatile.LoadUint16(&o.MB0_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB0_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB0_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB0_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB0_TS.Reg, volatile.LoadUint16(&o.MB0_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB0_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB0_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB1_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB1_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB1_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB1_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB1_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB1_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB1_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB1_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB1_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB1_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB1_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB1_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB1_DL.Reg, volatile.LoadUint16(&o.MB1_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB1_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB1_DL.Reg) & 0xf
}

// CAN0.MB1_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D0(value uint8) {
	volatile.StoreUint8(&o.MB1_D0.Reg, value)
}
func (o *CAN0_Type) GetMB1_D0() uint8 {
	return volatile.LoadUint8(&o.MB1_D0.Reg)
}

// CAN0.MB1_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D1(value uint8) {
	volatile.StoreUint8(&o.MB1_D1.Reg, value)
}
func (o *CAN0_Type) GetMB1_D1() uint8 {
	return volatile.LoadUint8(&o.MB1_D1.Reg)
}

// CAN0.MB1_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D2(value uint8) {
	volatile.StoreUint8(&o.MB1_D2.Reg, value)
}
func (o *CAN0_Type) GetMB1_D2() uint8 {
	return volatile.LoadUint8(&o.MB1_D2.Reg)
}

// CAN0.MB1_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D3(value uint8) {
	volatile.StoreUint8(&o.MB1_D3.Reg, value)
}
func (o *CAN0_Type) GetMB1_D3() uint8 {
	return volatile.LoadUint8(&o.MB1_D3.Reg)
}

// CAN0.MB1_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D4(value uint8) {
	volatile.StoreUint8(&o.MB1_D4.Reg, value)
}
func (o *CAN0_Type) GetMB1_D4() uint8 {
	return volatile.LoadUint8(&o.MB1_D4.Reg)
}

// CAN0.MB1_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D5(value uint8) {
	volatile.StoreUint8(&o.MB1_D5.Reg, value)
}
func (o *CAN0_Type) GetMB1_D5() uint8 {
	return volatile.LoadUint8(&o.MB1_D5.Reg)
}

// CAN0.MB1_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D6(value uint8) {
	volatile.StoreUint8(&o.MB1_D6.Reg, value)
}
func (o *CAN0_Type) GetMB1_D6() uint8 {
	return volatile.LoadUint8(&o.MB1_D6.Reg)
}

// CAN0.MB1_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D7(value uint8) {
	volatile.StoreUint8(&o.MB1_D7.Reg, value)
}
func (o *CAN0_Type) GetMB1_D7() uint8 {
	return volatile.LoadUint8(&o.MB1_D7.Reg)
}

// CAN0.MB1_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB1_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB1_TS.Reg, volatile.LoadUint16(&o.MB1_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB1_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB1_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB1_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB1_TS.Reg, volatile.LoadUint16(&o.MB1_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB1_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB1_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB2_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB2_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB2_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB2_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB2_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB2_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB2_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB2_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB2_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB2_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB2_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB2_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB2_DL.Reg, volatile.LoadUint16(&o.MB2_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB2_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB2_DL.Reg) & 0xf
}

// CAN0.MB2_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D0(value uint8) {
	volatile.StoreUint8(&o.MB2_D0.Reg, value)
}
func (o *CAN0_Type) GetMB2_D0() uint8 {
	return volatile.LoadUint8(&o.MB2_D0.Reg)
}

// CAN0.MB2_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D1(value uint8) {
	volatile.StoreUint8(&o.MB2_D1.Reg, value)
}
func (o *CAN0_Type) GetMB2_D1() uint8 {
	return volatile.LoadUint8(&o.MB2_D1.Reg)
}

// CAN0.MB2_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D2(value uint8) {
	volatile.StoreUint8(&o.MB2_D2.Reg, value)
}
func (o *CAN0_Type) GetMB2_D2() uint8 {
	return volatile.LoadUint8(&o.MB2_D2.Reg)
}

// CAN0.MB2_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D3(value uint8) {
	volatile.StoreUint8(&o.MB2_D3.Reg, value)
}
func (o *CAN0_Type) GetMB2_D3() uint8 {
	return volatile.LoadUint8(&o.MB2_D3.Reg)
}

// CAN0.MB2_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D4(value uint8) {
	volatile.StoreUint8(&o.MB2_D4.Reg, value)
}
func (o *CAN0_Type) GetMB2_D4() uint8 {
	return volatile.LoadUint8(&o.MB2_D4.Reg)
}

// CAN0.MB2_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D5(value uint8) {
	volatile.StoreUint8(&o.MB2_D5.Reg, value)
}
func (o *CAN0_Type) GetMB2_D5() uint8 {
	return volatile.LoadUint8(&o.MB2_D5.Reg)
}

// CAN0.MB2_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D6(value uint8) {
	volatile.StoreUint8(&o.MB2_D6.Reg, value)
}
func (o *CAN0_Type) GetMB2_D6() uint8 {
	return volatile.LoadUint8(&o.MB2_D6.Reg)
}

// CAN0.MB2_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D7(value uint8) {
	volatile.StoreUint8(&o.MB2_D7.Reg, value)
}
func (o *CAN0_Type) GetMB2_D7() uint8 {
	return volatile.LoadUint8(&o.MB2_D7.Reg)
}

// CAN0.MB2_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB2_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB2_TS.Reg, volatile.LoadUint16(&o.MB2_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB2_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB2_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB2_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB2_TS.Reg, volatile.LoadUint16(&o.MB2_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB2_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB2_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB3_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB3_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB3_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB3_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB3_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB3_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB3_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB3_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB3_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB3_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB3_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB3_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB3_DL.Reg, volatile.LoadUint16(&o.MB3_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB3_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB3_DL.Reg) & 0xf
}

// CAN0.MB3_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D0(value uint8) {
	volatile.StoreUint8(&o.MB3_D0.Reg, value)
}
func (o *CAN0_Type) GetMB3_D0() uint8 {
	return volatile.LoadUint8(&o.MB3_D0.Reg)
}

// CAN0.MB3_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D1(value uint8) {
	volatile.StoreUint8(&o.MB3_D1.Reg, value)
}
func (o *CAN0_Type) GetMB3_D1() uint8 {
	return volatile.LoadUint8(&o.MB3_D1.Reg)
}

// CAN0.MB3_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D2(value uint8) {
	volatile.StoreUint8(&o.MB3_D2.Reg, value)
}
func (o *CAN0_Type) GetMB3_D2() uint8 {
	return volatile.LoadUint8(&o.MB3_D2.Reg)
}

// CAN0.MB3_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D3(value uint8) {
	volatile.StoreUint8(&o.MB3_D3.Reg, value)
}
func (o *CAN0_Type) GetMB3_D3() uint8 {
	return volatile.LoadUint8(&o.MB3_D3.Reg)
}

// CAN0.MB3_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D4(value uint8) {
	volatile.StoreUint8(&o.MB3_D4.Reg, value)
}
func (o *CAN0_Type) GetMB3_D4() uint8 {
	return volatile.LoadUint8(&o.MB3_D4.Reg)
}

// CAN0.MB3_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D5(value uint8) {
	volatile.StoreUint8(&o.MB3_D5.Reg, value)
}
func (o *CAN0_Type) GetMB3_D5() uint8 {
	return volatile.LoadUint8(&o.MB3_D5.Reg)
}

// CAN0.MB3_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D6(value uint8) {
	volatile.StoreUint8(&o.MB3_D6.Reg, value)
}
func (o *CAN0_Type) GetMB3_D6() uint8 {
	return volatile.LoadUint8(&o.MB3_D6.Reg)
}

// CAN0.MB3_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D7(value uint8) {
	volatile.StoreUint8(&o.MB3_D7.Reg, value)
}
func (o *CAN0_Type) GetMB3_D7() uint8 {
	return volatile.LoadUint8(&o.MB3_D7.Reg)
}

// CAN0.MB3_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB3_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB3_TS.Reg, volatile.LoadUint16(&o.MB3_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB3_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB3_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB3_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB3_TS.Reg, volatile.LoadUint16(&o.MB3_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB3_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB3_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB4_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB4_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB4_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB4_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB4_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB4_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB4_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB4_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB4_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB4_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB4_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB4_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB4_DL.Reg, volatile.LoadUint16(&o.MB4_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB4_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB4_DL.Reg) & 0xf
}

// CAN0.MB4_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D0(value uint8) {
	volatile.StoreUint8(&o.MB4_D0.Reg, value)
}
func (o *CAN0_Type) GetMB4_D0() uint8 {
	return volatile.LoadUint8(&o.MB4_D0.Reg)
}

// CAN0.MB4_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D1(value uint8) {
	volatile.StoreUint8(&o.MB4_D1.Reg, value)
}
func (o *CAN0_Type) GetMB4_D1() uint8 {
	return volatile.LoadUint8(&o.MB4_D1.Reg)
}

// CAN0.MB4_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D2(value uint8) {
	volatile.StoreUint8(&o.MB4_D2.Reg, value)
}
func (o *CAN0_Type) GetMB4_D2() uint8 {
	return volatile.LoadUint8(&o.MB4_D2.Reg)
}

// CAN0.MB4_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D3(value uint8) {
	volatile.StoreUint8(&o.MB4_D3.Reg, value)
}
func (o *CAN0_Type) GetMB4_D3() uint8 {
	return volatile.LoadUint8(&o.MB4_D3.Reg)
}

// CAN0.MB4_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D4(value uint8) {
	volatile.StoreUint8(&o.MB4_D4.Reg, value)
}
func (o *CAN0_Type) GetMB4_D4() uint8 {
	return volatile.LoadUint8(&o.MB4_D4.Reg)
}

// CAN0.MB4_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D5(value uint8) {
	volatile.StoreUint8(&o.MB4_D5.Reg, value)
}
func (o *CAN0_Type) GetMB4_D5() uint8 {
	return volatile.LoadUint8(&o.MB4_D5.Reg)
}

// CAN0.MB4_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D6(value uint8) {
	volatile.StoreUint8(&o.MB4_D6.Reg, value)
}
func (o *CAN0_Type) GetMB4_D6() uint8 {
	return volatile.LoadUint8(&o.MB4_D6.Reg)
}

// CAN0.MB4_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D7(value uint8) {
	volatile.StoreUint8(&o.MB4_D7.Reg, value)
}
func (o *CAN0_Type) GetMB4_D7() uint8 {
	return volatile.LoadUint8(&o.MB4_D7.Reg)
}

// CAN0.MB4_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB4_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB4_TS.Reg, volatile.LoadUint16(&o.MB4_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB4_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB4_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB4_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB4_TS.Reg, volatile.LoadUint16(&o.MB4_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB4_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB4_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB5_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB5_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB5_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB5_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB5_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB5_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB5_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB5_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB5_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB5_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB5_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB5_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB5_DL.Reg, volatile.LoadUint16(&o.MB5_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB5_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB5_DL.Reg) & 0xf
}

// CAN0.MB5_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D0(value uint8) {
	volatile.StoreUint8(&o.MB5_D0.Reg, value)
}
func (o *CAN0_Type) GetMB5_D0() uint8 {
	return volatile.LoadUint8(&o.MB5_D0.Reg)
}

// CAN0.MB5_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D1(value uint8) {
	volatile.StoreUint8(&o.MB5_D1.Reg, value)
}
func (o *CAN0_Type) GetMB5_D1() uint8 {
	return volatile.LoadUint8(&o.MB5_D1.Reg)
}

// CAN0.MB5_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D2(value uint8) {
	volatile.StoreUint8(&o.MB5_D2.Reg, value)
}
func (o *CAN0_Type) GetMB5_D2() uint8 {
	return volatile.LoadUint8(&o.MB5_D2.Reg)
}

// CAN0.MB5_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D3(value uint8) {
	volatile.StoreUint8(&o.MB5_D3.Reg, value)
}
func (o *CAN0_Type) GetMB5_D3() uint8 {
	return volatile.LoadUint8(&o.MB5_D3.Reg)
}

// CAN0.MB5_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D4(value uint8) {
	volatile.StoreUint8(&o.MB5_D4.Reg, value)
}
func (o *CAN0_Type) GetMB5_D4() uint8 {
	return volatile.LoadUint8(&o.MB5_D4.Reg)
}

// CAN0.MB5_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D5(value uint8) {
	volatile.StoreUint8(&o.MB5_D5.Reg, value)
}
func (o *CAN0_Type) GetMB5_D5() uint8 {
	return volatile.LoadUint8(&o.MB5_D5.Reg)
}

// CAN0.MB5_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D6(value uint8) {
	volatile.StoreUint8(&o.MB5_D6.Reg, value)
}
func (o *CAN0_Type) GetMB5_D6() uint8 {
	return volatile.LoadUint8(&o.MB5_D6.Reg)
}

// CAN0.MB5_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D7(value uint8) {
	volatile.StoreUint8(&o.MB5_D7.Reg, value)
}
func (o *CAN0_Type) GetMB5_D7() uint8 {
	return volatile.LoadUint8(&o.MB5_D7.Reg)
}

// CAN0.MB5_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB5_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB5_TS.Reg, volatile.LoadUint16(&o.MB5_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB5_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB5_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB5_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB5_TS.Reg, volatile.LoadUint16(&o.MB5_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB5_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB5_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB6_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB6_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB6_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB6_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB6_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB6_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB6_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB6_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB6_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB6_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB6_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB6_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB6_DL.Reg, volatile.LoadUint16(&o.MB6_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB6_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB6_DL.Reg) & 0xf
}

// CAN0.MB6_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D0(value uint8) {
	volatile.StoreUint8(&o.MB6_D0.Reg, value)
}
func (o *CAN0_Type) GetMB6_D0() uint8 {
	return volatile.LoadUint8(&o.MB6_D0.Reg)
}

// CAN0.MB6_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D1(value uint8) {
	volatile.StoreUint8(&o.MB6_D1.Reg, value)
}
func (o *CAN0_Type) GetMB6_D1() uint8 {
	return volatile.LoadUint8(&o.MB6_D1.Reg)
}

// CAN0.MB6_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D2(value uint8) {
	volatile.StoreUint8(&o.MB6_D2.Reg, value)
}
func (o *CAN0_Type) GetMB6_D2() uint8 {
	return volatile.LoadUint8(&o.MB6_D2.Reg)
}

// CAN0.MB6_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D3(value uint8) {
	volatile.StoreUint8(&o.MB6_D3.Reg, value)
}
func (o *CAN0_Type) GetMB6_D3() uint8 {
	return volatile.LoadUint8(&o.MB6_D3.Reg)
}

// CAN0.MB6_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D4(value uint8) {
	volatile.StoreUint8(&o.MB6_D4.Reg, value)
}
func (o *CAN0_Type) GetMB6_D4() uint8 {
	return volatile.LoadUint8(&o.MB6_D4.Reg)
}

// CAN0.MB6_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D5(value uint8) {
	volatile.StoreUint8(&o.MB6_D5.Reg, value)
}
func (o *CAN0_Type) GetMB6_D5() uint8 {
	return volatile.LoadUint8(&o.MB6_D5.Reg)
}

// CAN0.MB6_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D6(value uint8) {
	volatile.StoreUint8(&o.MB6_D6.Reg, value)
}
func (o *CAN0_Type) GetMB6_D6() uint8 {
	return volatile.LoadUint8(&o.MB6_D6.Reg)
}

// CAN0.MB6_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D7(value uint8) {
	volatile.StoreUint8(&o.MB6_D7.Reg, value)
}
func (o *CAN0_Type) GetMB6_D7() uint8 {
	return volatile.LoadUint8(&o.MB6_D7.Reg)
}

// CAN0.MB6_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB6_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB6_TS.Reg, volatile.LoadUint16(&o.MB6_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB6_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB6_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB6_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB6_TS.Reg, volatile.LoadUint16(&o.MB6_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB6_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB6_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB7_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB7_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB7_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB7_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB7_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB7_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB7_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB7_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB7_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB7_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB7_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB7_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB7_DL.Reg, volatile.LoadUint16(&o.MB7_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB7_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB7_DL.Reg) & 0xf
}

// CAN0.MB7_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D0(value uint8) {
	volatile.StoreUint8(&o.MB7_D0.Reg, value)
}
func (o *CAN0_Type) GetMB7_D0() uint8 {
	return volatile.LoadUint8(&o.MB7_D0.Reg)
}

// CAN0.MB7_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D1(value uint8) {
	volatile.StoreUint8(&o.MB7_D1.Reg, value)
}
func (o *CAN0_Type) GetMB7_D1() uint8 {
	return volatile.LoadUint8(&o.MB7_D1.Reg)
}

// CAN0.MB7_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D2(value uint8) {
	volatile.StoreUint8(&o.MB7_D2.Reg, value)
}
func (o *CAN0_Type) GetMB7_D2() uint8 {
	return volatile.LoadUint8(&o.MB7_D2.Reg)
}

// CAN0.MB7_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D3(value uint8) {
	volatile.StoreUint8(&o.MB7_D3.Reg, value)
}
func (o *CAN0_Type) GetMB7_D3() uint8 {
	return volatile.LoadUint8(&o.MB7_D3.Reg)
}

// CAN0.MB7_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D4(value uint8) {
	volatile.StoreUint8(&o.MB7_D4.Reg, value)
}
func (o *CAN0_Type) GetMB7_D4() uint8 {
	return volatile.LoadUint8(&o.MB7_D4.Reg)
}

// CAN0.MB7_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D5(value uint8) {
	volatile.StoreUint8(&o.MB7_D5.Reg, value)
}
func (o *CAN0_Type) GetMB7_D5() uint8 {
	return volatile.LoadUint8(&o.MB7_D5.Reg)
}

// CAN0.MB7_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D6(value uint8) {
	volatile.StoreUint8(&o.MB7_D6.Reg, value)
}
func (o *CAN0_Type) GetMB7_D6() uint8 {
	return volatile.LoadUint8(&o.MB7_D6.Reg)
}

// CAN0.MB7_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D7(value uint8) {
	volatile.StoreUint8(&o.MB7_D7.Reg, value)
}
func (o *CAN0_Type) GetMB7_D7() uint8 {
	return volatile.LoadUint8(&o.MB7_D7.Reg)
}

// CAN0.MB7_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB7_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB7_TS.Reg, volatile.LoadUint16(&o.MB7_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB7_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB7_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB7_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB7_TS.Reg, volatile.LoadUint16(&o.MB7_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB7_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB7_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB8_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB8_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB8_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB8_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB8_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB8_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB8_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB8_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB8_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB8_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB8_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB8_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB8_DL.Reg, volatile.LoadUint16(&o.MB8_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB8_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB8_DL.Reg) & 0xf
}

// CAN0.MB8_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D0(value uint8) {
	volatile.StoreUint8(&o.MB8_D0.Reg, value)
}
func (o *CAN0_Type) GetMB8_D0() uint8 {
	return volatile.LoadUint8(&o.MB8_D0.Reg)
}

// CAN0.MB8_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D1(value uint8) {
	volatile.StoreUint8(&o.MB8_D1.Reg, value)
}
func (o *CAN0_Type) GetMB8_D1() uint8 {
	return volatile.LoadUint8(&o.MB8_D1.Reg)
}

// CAN0.MB8_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D2(value uint8) {
	volatile.StoreUint8(&o.MB8_D2.Reg, value)
}
func (o *CAN0_Type) GetMB8_D2() uint8 {
	return volatile.LoadUint8(&o.MB8_D2.Reg)
}

// CAN0.MB8_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D3(value uint8) {
	volatile.StoreUint8(&o.MB8_D3.Reg, value)
}
func (o *CAN0_Type) GetMB8_D3() uint8 {
	return volatile.LoadUint8(&o.MB8_D3.Reg)
}

// CAN0.MB8_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D4(value uint8) {
	volatile.StoreUint8(&o.MB8_D4.Reg, value)
}
func (o *CAN0_Type) GetMB8_D4() uint8 {
	return volatile.LoadUint8(&o.MB8_D4.Reg)
}

// CAN0.MB8_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D5(value uint8) {
	volatile.StoreUint8(&o.MB8_D5.Reg, value)
}
func (o *CAN0_Type) GetMB8_D5() uint8 {
	return volatile.LoadUint8(&o.MB8_D5.Reg)
}

// CAN0.MB8_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D6(value uint8) {
	volatile.StoreUint8(&o.MB8_D6.Reg, value)
}
func (o *CAN0_Type) GetMB8_D6() uint8 {
	return volatile.LoadUint8(&o.MB8_D6.Reg)
}

// CAN0.MB8_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D7(value uint8) {
	volatile.StoreUint8(&o.MB8_D7.Reg, value)
}
func (o *CAN0_Type) GetMB8_D7() uint8 {
	return volatile.LoadUint8(&o.MB8_D7.Reg)
}

// CAN0.MB8_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB8_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB8_TS.Reg, volatile.LoadUint16(&o.MB8_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB8_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB8_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB8_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB8_TS.Reg, volatile.LoadUint16(&o.MB8_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB8_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB8_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB9_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB9_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB9_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB9_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB9_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB9_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB9_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB9_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB9_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB9_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB9_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB9_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB9_DL.Reg, volatile.LoadUint16(&o.MB9_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB9_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB9_DL.Reg) & 0xf
}

// CAN0.MB9_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D0(value uint8) {
	volatile.StoreUint8(&o.MB9_D0.Reg, value)
}
func (o *CAN0_Type) GetMB9_D0() uint8 {
	return volatile.LoadUint8(&o.MB9_D0.Reg)
}

// CAN0.MB9_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D1(value uint8) {
	volatile.StoreUint8(&o.MB9_D1.Reg, value)
}
func (o *CAN0_Type) GetMB9_D1() uint8 {
	return volatile.LoadUint8(&o.MB9_D1.Reg)
}

// CAN0.MB9_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D2(value uint8) {
	volatile.StoreUint8(&o.MB9_D2.Reg, value)
}
func (o *CAN0_Type) GetMB9_D2() uint8 {
	return volatile.LoadUint8(&o.MB9_D2.Reg)
}

// CAN0.MB9_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D3(value uint8) {
	volatile.StoreUint8(&o.MB9_D3.Reg, value)
}
func (o *CAN0_Type) GetMB9_D3() uint8 {
	return volatile.LoadUint8(&o.MB9_D3.Reg)
}

// CAN0.MB9_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D4(value uint8) {
	volatile.StoreUint8(&o.MB9_D4.Reg, value)
}
func (o *CAN0_Type) GetMB9_D4() uint8 {
	return volatile.LoadUint8(&o.MB9_D4.Reg)
}

// CAN0.MB9_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D5(value uint8) {
	volatile.StoreUint8(&o.MB9_D5.Reg, value)
}
func (o *CAN0_Type) GetMB9_D5() uint8 {
	return volatile.LoadUint8(&o.MB9_D5.Reg)
}

// CAN0.MB9_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D6(value uint8) {
	volatile.StoreUint8(&o.MB9_D6.Reg, value)
}
func (o *CAN0_Type) GetMB9_D6() uint8 {
	return volatile.LoadUint8(&o.MB9_D6.Reg)
}

// CAN0.MB9_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D7(value uint8) {
	volatile.StoreUint8(&o.MB9_D7.Reg, value)
}
func (o *CAN0_Type) GetMB9_D7() uint8 {
	return volatile.LoadUint8(&o.MB9_D7.Reg)
}

// CAN0.MB9_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB9_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB9_TS.Reg, volatile.LoadUint16(&o.MB9_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB9_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB9_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB9_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB9_TS.Reg, volatile.LoadUint16(&o.MB9_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB9_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB9_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB10_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB10_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB10_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB10_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB10_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB10_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB10_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB10_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB10_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB10_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB10_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB10_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB10_DL.Reg, volatile.LoadUint16(&o.MB10_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB10_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB10_DL.Reg) & 0xf
}

// CAN0.MB10_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D0(value uint8) {
	volatile.StoreUint8(&o.MB10_D0.Reg, value)
}
func (o *CAN0_Type) GetMB10_D0() uint8 {
	return volatile.LoadUint8(&o.MB10_D0.Reg)
}

// CAN0.MB10_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D1(value uint8) {
	volatile.StoreUint8(&o.MB10_D1.Reg, value)
}
func (o *CAN0_Type) GetMB10_D1() uint8 {
	return volatile.LoadUint8(&o.MB10_D1.Reg)
}

// CAN0.MB10_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D2(value uint8) {
	volatile.StoreUint8(&o.MB10_D2.Reg, value)
}
func (o *CAN0_Type) GetMB10_D2() uint8 {
	return volatile.LoadUint8(&o.MB10_D2.Reg)
}

// CAN0.MB10_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D3(value uint8) {
	volatile.StoreUint8(&o.MB10_D3.Reg, value)
}
func (o *CAN0_Type) GetMB10_D3() uint8 {
	return volatile.LoadUint8(&o.MB10_D3.Reg)
}

// CAN0.MB10_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D4(value uint8) {
	volatile.StoreUint8(&o.MB10_D4.Reg, value)
}
func (o *CAN0_Type) GetMB10_D4() uint8 {
	return volatile.LoadUint8(&o.MB10_D4.Reg)
}

// CAN0.MB10_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D5(value uint8) {
	volatile.StoreUint8(&o.MB10_D5.Reg, value)
}
func (o *CAN0_Type) GetMB10_D5() uint8 {
	return volatile.LoadUint8(&o.MB10_D5.Reg)
}

// CAN0.MB10_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D6(value uint8) {
	volatile.StoreUint8(&o.MB10_D6.Reg, value)
}
func (o *CAN0_Type) GetMB10_D6() uint8 {
	return volatile.LoadUint8(&o.MB10_D6.Reg)
}

// CAN0.MB10_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D7(value uint8) {
	volatile.StoreUint8(&o.MB10_D7.Reg, value)
}
func (o *CAN0_Type) GetMB10_D7() uint8 {
	return volatile.LoadUint8(&o.MB10_D7.Reg)
}

// CAN0.MB10_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB10_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB10_TS.Reg, volatile.LoadUint16(&o.MB10_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB10_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB10_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB10_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB10_TS.Reg, volatile.LoadUint16(&o.MB10_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB10_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB10_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB11_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB11_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB11_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB11_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB11_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB11_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB11_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB11_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB11_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB11_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB11_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB11_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB11_DL.Reg, volatile.LoadUint16(&o.MB11_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB11_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB11_DL.Reg) & 0xf
}

// CAN0.MB11_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D0(value uint8) {
	volatile.StoreUint8(&o.MB11_D0.Reg, value)
}
func (o *CAN0_Type) GetMB11_D0() uint8 {
	return volatile.LoadUint8(&o.MB11_D0.Reg)
}

// CAN0.MB11_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D1(value uint8) {
	volatile.StoreUint8(&o.MB11_D1.Reg, value)
}
func (o *CAN0_Type) GetMB11_D1() uint8 {
	return volatile.LoadUint8(&o.MB11_D1.Reg)
}

// CAN0.MB11_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D2(value uint8) {
	volatile.StoreUint8(&o.MB11_D2.Reg, value)
}
func (o *CAN0_Type) GetMB11_D2() uint8 {
	return volatile.LoadUint8(&o.MB11_D2.Reg)
}

// CAN0.MB11_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D3(value uint8) {
	volatile.StoreUint8(&o.MB11_D3.Reg, value)
}
func (o *CAN0_Type) GetMB11_D3() uint8 {
	return volatile.LoadUint8(&o.MB11_D3.Reg)
}

// CAN0.MB11_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D4(value uint8) {
	volatile.StoreUint8(&o.MB11_D4.Reg, value)
}
func (o *CAN0_Type) GetMB11_D4() uint8 {
	return volatile.LoadUint8(&o.MB11_D4.Reg)
}

// CAN0.MB11_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D5(value uint8) {
	volatile.StoreUint8(&o.MB11_D5.Reg, value)
}
func (o *CAN0_Type) GetMB11_D5() uint8 {
	return volatile.LoadUint8(&o.MB11_D5.Reg)
}

// CAN0.MB11_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D6(value uint8) {
	volatile.StoreUint8(&o.MB11_D6.Reg, value)
}
func (o *CAN0_Type) GetMB11_D6() uint8 {
	return volatile.LoadUint8(&o.MB11_D6.Reg)
}

// CAN0.MB11_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D7(value uint8) {
	volatile.StoreUint8(&o.MB11_D7.Reg, value)
}
func (o *CAN0_Type) GetMB11_D7() uint8 {
	return volatile.LoadUint8(&o.MB11_D7.Reg)
}

// CAN0.MB11_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB11_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB11_TS.Reg, volatile.LoadUint16(&o.MB11_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB11_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB11_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB11_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB11_TS.Reg, volatile.LoadUint16(&o.MB11_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB11_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB11_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB12_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB12_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB12_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB12_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB12_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB12_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB12_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB12_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB12_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB12_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB12_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB12_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB12_DL.Reg, volatile.LoadUint16(&o.MB12_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB12_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB12_DL.Reg) & 0xf
}

// CAN0.MB12_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D0(value uint8) {
	volatile.StoreUint8(&o.MB12_D0.Reg, value)
}
func (o *CAN0_Type) GetMB12_D0() uint8 {
	return volatile.LoadUint8(&o.MB12_D0.Reg)
}

// CAN0.MB12_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D1(value uint8) {
	volatile.StoreUint8(&o.MB12_D1.Reg, value)
}
func (o *CAN0_Type) GetMB12_D1() uint8 {
	return volatile.LoadUint8(&o.MB12_D1.Reg)
}

// CAN0.MB12_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D2(value uint8) {
	volatile.StoreUint8(&o.MB12_D2.Reg, value)
}
func (o *CAN0_Type) GetMB12_D2() uint8 {
	return volatile.LoadUint8(&o.MB12_D2.Reg)
}

// CAN0.MB12_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D3(value uint8) {
	volatile.StoreUint8(&o.MB12_D3.Reg, value)
}
func (o *CAN0_Type) GetMB12_D3() uint8 {
	return volatile.LoadUint8(&o.MB12_D3.Reg)
}

// CAN0.MB12_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D4(value uint8) {
	volatile.StoreUint8(&o.MB12_D4.Reg, value)
}
func (o *CAN0_Type) GetMB12_D4() uint8 {
	return volatile.LoadUint8(&o.MB12_D4.Reg)
}

// CAN0.MB12_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D5(value uint8) {
	volatile.StoreUint8(&o.MB12_D5.Reg, value)
}
func (o *CAN0_Type) GetMB12_D5() uint8 {
	return volatile.LoadUint8(&o.MB12_D5.Reg)
}

// CAN0.MB12_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D6(value uint8) {
	volatile.StoreUint8(&o.MB12_D6.Reg, value)
}
func (o *CAN0_Type) GetMB12_D6() uint8 {
	return volatile.LoadUint8(&o.MB12_D6.Reg)
}

// CAN0.MB12_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D7(value uint8) {
	volatile.StoreUint8(&o.MB12_D7.Reg, value)
}
func (o *CAN0_Type) GetMB12_D7() uint8 {
	return volatile.LoadUint8(&o.MB12_D7.Reg)
}

// CAN0.MB12_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB12_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB12_TS.Reg, volatile.LoadUint16(&o.MB12_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB12_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB12_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB12_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB12_TS.Reg, volatile.LoadUint16(&o.MB12_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB12_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB12_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB13_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB13_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB13_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB13_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB13_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB13_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB13_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB13_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB13_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB13_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB13_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB13_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB13_DL.Reg, volatile.LoadUint16(&o.MB13_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB13_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB13_DL.Reg) & 0xf
}

// CAN0.MB13_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D0(value uint8) {
	volatile.StoreUint8(&o.MB13_D0.Reg, value)
}
func (o *CAN0_Type) GetMB13_D0() uint8 {
	return volatile.LoadUint8(&o.MB13_D0.Reg)
}

// CAN0.MB13_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D1(value uint8) {
	volatile.StoreUint8(&o.MB13_D1.Reg, value)
}
func (o *CAN0_Type) GetMB13_D1() uint8 {
	return volatile.LoadUint8(&o.MB13_D1.Reg)
}

// CAN0.MB13_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D2(value uint8) {
	volatile.StoreUint8(&o.MB13_D2.Reg, value)
}
func (o *CAN0_Type) GetMB13_D2() uint8 {
	return volatile.LoadUint8(&o.MB13_D2.Reg)
}

// CAN0.MB13_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D3(value uint8) {
	volatile.StoreUint8(&o.MB13_D3.Reg, value)
}
func (o *CAN0_Type) GetMB13_D3() uint8 {
	return volatile.LoadUint8(&o.MB13_D3.Reg)
}

// CAN0.MB13_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D4(value uint8) {
	volatile.StoreUint8(&o.MB13_D4.Reg, value)
}
func (o *CAN0_Type) GetMB13_D4() uint8 {
	return volatile.LoadUint8(&o.MB13_D4.Reg)
}

// CAN0.MB13_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D5(value uint8) {
	volatile.StoreUint8(&o.MB13_D5.Reg, value)
}
func (o *CAN0_Type) GetMB13_D5() uint8 {
	return volatile.LoadUint8(&o.MB13_D5.Reg)
}

// CAN0.MB13_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D6(value uint8) {
	volatile.StoreUint8(&o.MB13_D6.Reg, value)
}
func (o *CAN0_Type) GetMB13_D6() uint8 {
	return volatile.LoadUint8(&o.MB13_D6.Reg)
}

// CAN0.MB13_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D7(value uint8) {
	volatile.StoreUint8(&o.MB13_D7.Reg, value)
}
func (o *CAN0_Type) GetMB13_D7() uint8 {
	return volatile.LoadUint8(&o.MB13_D7.Reg)
}

// CAN0.MB13_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB13_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB13_TS.Reg, volatile.LoadUint16(&o.MB13_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB13_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB13_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB13_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB13_TS.Reg, volatile.LoadUint16(&o.MB13_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB13_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB13_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB14_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB14_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB14_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB14_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB14_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB14_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB14_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB14_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB14_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB14_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB14_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB14_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB14_DL.Reg, volatile.LoadUint16(&o.MB14_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB14_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB14_DL.Reg) & 0xf
}

// CAN0.MB14_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D0(value uint8) {
	volatile.StoreUint8(&o.MB14_D0.Reg, value)
}
func (o *CAN0_Type) GetMB14_D0() uint8 {
	return volatile.LoadUint8(&o.MB14_D0.Reg)
}

// CAN0.MB14_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D1(value uint8) {
	volatile.StoreUint8(&o.MB14_D1.Reg, value)
}
func (o *CAN0_Type) GetMB14_D1() uint8 {
	return volatile.LoadUint8(&o.MB14_D1.Reg)
}

// CAN0.MB14_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D2(value uint8) {
	volatile.StoreUint8(&o.MB14_D2.Reg, value)
}
func (o *CAN0_Type) GetMB14_D2() uint8 {
	return volatile.LoadUint8(&o.MB14_D2.Reg)
}

// CAN0.MB14_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D3(value uint8) {
	volatile.StoreUint8(&o.MB14_D3.Reg, value)
}
func (o *CAN0_Type) GetMB14_D3() uint8 {
	return volatile.LoadUint8(&o.MB14_D3.Reg)
}

// CAN0.MB14_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D4(value uint8) {
	volatile.StoreUint8(&o.MB14_D4.Reg, value)
}
func (o *CAN0_Type) GetMB14_D4() uint8 {
	return volatile.LoadUint8(&o.MB14_D4.Reg)
}

// CAN0.MB14_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D5(value uint8) {
	volatile.StoreUint8(&o.MB14_D5.Reg, value)
}
func (o *CAN0_Type) GetMB14_D5() uint8 {
	return volatile.LoadUint8(&o.MB14_D5.Reg)
}

// CAN0.MB14_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D6(value uint8) {
	volatile.StoreUint8(&o.MB14_D6.Reg, value)
}
func (o *CAN0_Type) GetMB14_D6() uint8 {
	return volatile.LoadUint8(&o.MB14_D6.Reg)
}

// CAN0.MB14_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D7(value uint8) {
	volatile.StoreUint8(&o.MB14_D7.Reg, value)
}
func (o *CAN0_Type) GetMB14_D7() uint8 {
	return volatile.LoadUint8(&o.MB14_D7.Reg)
}

// CAN0.MB14_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB14_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB14_TS.Reg, volatile.LoadUint16(&o.MB14_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB14_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB14_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB14_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB14_TS.Reg, volatile.LoadUint16(&o.MB14_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB14_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB14_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB15_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB15_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB15_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB15_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB15_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB15_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB15_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB15_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB15_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB15_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB15_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB15_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB15_DL.Reg, volatile.LoadUint16(&o.MB15_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB15_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB15_DL.Reg) & 0xf
}

// CAN0.MB15_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D0(value uint8) {
	volatile.StoreUint8(&o.MB15_D0.Reg, value)
}
func (o *CAN0_Type) GetMB15_D0() uint8 {
	return volatile.LoadUint8(&o.MB15_D0.Reg)
}

// CAN0.MB15_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D1(value uint8) {
	volatile.StoreUint8(&o.MB15_D1.Reg, value)
}
func (o *CAN0_Type) GetMB15_D1() uint8 {
	return volatile.LoadUint8(&o.MB15_D1.Reg)
}

// CAN0.MB15_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D2(value uint8) {
	volatile.StoreUint8(&o.MB15_D2.Reg, value)
}
func (o *CAN0_Type) GetMB15_D2() uint8 {
	return volatile.LoadUint8(&o.MB15_D2.Reg)
}

// CAN0.MB15_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D3(value uint8) {
	volatile.StoreUint8(&o.MB15_D3.Reg, value)
}
func (o *CAN0_Type) GetMB15_D3() uint8 {
	return volatile.LoadUint8(&o.MB15_D3.Reg)
}

// CAN0.MB15_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D4(value uint8) {
	volatile.StoreUint8(&o.MB15_D4.Reg, value)
}
func (o *CAN0_Type) GetMB15_D4() uint8 {
	return volatile.LoadUint8(&o.MB15_D4.Reg)
}

// CAN0.MB15_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D5(value uint8) {
	volatile.StoreUint8(&o.MB15_D5.Reg, value)
}
func (o *CAN0_Type) GetMB15_D5() uint8 {
	return volatile.LoadUint8(&o.MB15_D5.Reg)
}

// CAN0.MB15_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D6(value uint8) {
	volatile.StoreUint8(&o.MB15_D6.Reg, value)
}
func (o *CAN0_Type) GetMB15_D6() uint8 {
	return volatile.LoadUint8(&o.MB15_D6.Reg)
}

// CAN0.MB15_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D7(value uint8) {
	volatile.StoreUint8(&o.MB15_D7.Reg, value)
}
func (o *CAN0_Type) GetMB15_D7() uint8 {
	return volatile.LoadUint8(&o.MB15_D7.Reg)
}

// CAN0.MB15_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB15_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB15_TS.Reg, volatile.LoadUint16(&o.MB15_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB15_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB15_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB15_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB15_TS.Reg, volatile.LoadUint16(&o.MB15_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB15_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB15_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB16_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB16_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB16_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB16_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB16_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB16_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB16_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB16_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB16_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB16_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB16_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB16_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB16_DL.Reg, volatile.LoadUint16(&o.MB16_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB16_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB16_DL.Reg) & 0xf
}

// CAN0.MB16_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D0(value uint8) {
	volatile.StoreUint8(&o.MB16_D0.Reg, value)
}
func (o *CAN0_Type) GetMB16_D0() uint8 {
	return volatile.LoadUint8(&o.MB16_D0.Reg)
}

// CAN0.MB16_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D1(value uint8) {
	volatile.StoreUint8(&o.MB16_D1.Reg, value)
}
func (o *CAN0_Type) GetMB16_D1() uint8 {
	return volatile.LoadUint8(&o.MB16_D1.Reg)
}

// CAN0.MB16_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D2(value uint8) {
	volatile.StoreUint8(&o.MB16_D2.Reg, value)
}
func (o *CAN0_Type) GetMB16_D2() uint8 {
	return volatile.LoadUint8(&o.MB16_D2.Reg)
}

// CAN0.MB16_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D3(value uint8) {
	volatile.StoreUint8(&o.MB16_D3.Reg, value)
}
func (o *CAN0_Type) GetMB16_D3() uint8 {
	return volatile.LoadUint8(&o.MB16_D3.Reg)
}

// CAN0.MB16_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D4(value uint8) {
	volatile.StoreUint8(&o.MB16_D4.Reg, value)
}
func (o *CAN0_Type) GetMB16_D4() uint8 {
	return volatile.LoadUint8(&o.MB16_D4.Reg)
}

// CAN0.MB16_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D5(value uint8) {
	volatile.StoreUint8(&o.MB16_D5.Reg, value)
}
func (o *CAN0_Type) GetMB16_D5() uint8 {
	return volatile.LoadUint8(&o.MB16_D5.Reg)
}

// CAN0.MB16_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D6(value uint8) {
	volatile.StoreUint8(&o.MB16_D6.Reg, value)
}
func (o *CAN0_Type) GetMB16_D6() uint8 {
	return volatile.LoadUint8(&o.MB16_D6.Reg)
}

// CAN0.MB16_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D7(value uint8) {
	volatile.StoreUint8(&o.MB16_D7.Reg, value)
}
func (o *CAN0_Type) GetMB16_D7() uint8 {
	return volatile.LoadUint8(&o.MB16_D7.Reg)
}

// CAN0.MB16_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB16_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB16_TS.Reg, volatile.LoadUint16(&o.MB16_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB16_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB16_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB16_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB16_TS.Reg, volatile.LoadUint16(&o.MB16_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB16_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB16_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB17_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB17_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB17_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB17_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB17_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB17_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB17_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB17_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB17_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB17_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB17_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB17_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB17_DL.Reg, volatile.LoadUint16(&o.MB17_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB17_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB17_DL.Reg) & 0xf
}

// CAN0.MB17_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D0(value uint8) {
	volatile.StoreUint8(&o.MB17_D0.Reg, value)
}
func (o *CAN0_Type) GetMB17_D0() uint8 {
	return volatile.LoadUint8(&o.MB17_D0.Reg)
}

// CAN0.MB17_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D1(value uint8) {
	volatile.StoreUint8(&o.MB17_D1.Reg, value)
}
func (o *CAN0_Type) GetMB17_D1() uint8 {
	return volatile.LoadUint8(&o.MB17_D1.Reg)
}

// CAN0.MB17_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D2(value uint8) {
	volatile.StoreUint8(&o.MB17_D2.Reg, value)
}
func (o *CAN0_Type) GetMB17_D2() uint8 {
	return volatile.LoadUint8(&o.MB17_D2.Reg)
}

// CAN0.MB17_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D3(value uint8) {
	volatile.StoreUint8(&o.MB17_D3.Reg, value)
}
func (o *CAN0_Type) GetMB17_D3() uint8 {
	return volatile.LoadUint8(&o.MB17_D3.Reg)
}

// CAN0.MB17_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D4(value uint8) {
	volatile.StoreUint8(&o.MB17_D4.Reg, value)
}
func (o *CAN0_Type) GetMB17_D4() uint8 {
	return volatile.LoadUint8(&o.MB17_D4.Reg)
}

// CAN0.MB17_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D5(value uint8) {
	volatile.StoreUint8(&o.MB17_D5.Reg, value)
}
func (o *CAN0_Type) GetMB17_D5() uint8 {
	return volatile.LoadUint8(&o.MB17_D5.Reg)
}

// CAN0.MB17_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D6(value uint8) {
	volatile.StoreUint8(&o.MB17_D6.Reg, value)
}
func (o *CAN0_Type) GetMB17_D6() uint8 {
	return volatile.LoadUint8(&o.MB17_D6.Reg)
}

// CAN0.MB17_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D7(value uint8) {
	volatile.StoreUint8(&o.MB17_D7.Reg, value)
}
func (o *CAN0_Type) GetMB17_D7() uint8 {
	return volatile.LoadUint8(&o.MB17_D7.Reg)
}

// CAN0.MB17_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB17_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB17_TS.Reg, volatile.LoadUint16(&o.MB17_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB17_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB17_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB17_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB17_TS.Reg, volatile.LoadUint16(&o.MB17_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB17_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB17_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB18_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB18_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB18_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB18_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB18_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB18_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB18_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB18_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB18_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB18_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB18_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB18_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB18_DL.Reg, volatile.LoadUint16(&o.MB18_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB18_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB18_DL.Reg) & 0xf
}

// CAN0.MB18_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D0(value uint8) {
	volatile.StoreUint8(&o.MB18_D0.Reg, value)
}
func (o *CAN0_Type) GetMB18_D0() uint8 {
	return volatile.LoadUint8(&o.MB18_D0.Reg)
}

// CAN0.MB18_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D1(value uint8) {
	volatile.StoreUint8(&o.MB18_D1.Reg, value)
}
func (o *CAN0_Type) GetMB18_D1() uint8 {
	return volatile.LoadUint8(&o.MB18_D1.Reg)
}

// CAN0.MB18_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D2(value uint8) {
	volatile.StoreUint8(&o.MB18_D2.Reg, value)
}
func (o *CAN0_Type) GetMB18_D2() uint8 {
	return volatile.LoadUint8(&o.MB18_D2.Reg)
}

// CAN0.MB18_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D3(value uint8) {
	volatile.StoreUint8(&o.MB18_D3.Reg, value)
}
func (o *CAN0_Type) GetMB18_D3() uint8 {
	return volatile.LoadUint8(&o.MB18_D3.Reg)
}

// CAN0.MB18_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D4(value uint8) {
	volatile.StoreUint8(&o.MB18_D4.Reg, value)
}
func (o *CAN0_Type) GetMB18_D4() uint8 {
	return volatile.LoadUint8(&o.MB18_D4.Reg)
}

// CAN0.MB18_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D5(value uint8) {
	volatile.StoreUint8(&o.MB18_D5.Reg, value)
}
func (o *CAN0_Type) GetMB18_D5() uint8 {
	return volatile.LoadUint8(&o.MB18_D5.Reg)
}

// CAN0.MB18_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D6(value uint8) {
	volatile.StoreUint8(&o.MB18_D6.Reg, value)
}
func (o *CAN0_Type) GetMB18_D6() uint8 {
	return volatile.LoadUint8(&o.MB18_D6.Reg)
}

// CAN0.MB18_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D7(value uint8) {
	volatile.StoreUint8(&o.MB18_D7.Reg, value)
}
func (o *CAN0_Type) GetMB18_D7() uint8 {
	return volatile.LoadUint8(&o.MB18_D7.Reg)
}

// CAN0.MB18_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB18_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB18_TS.Reg, volatile.LoadUint16(&o.MB18_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB18_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB18_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB18_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB18_TS.Reg, volatile.LoadUint16(&o.MB18_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB18_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB18_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB19_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB19_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB19_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB19_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB19_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB19_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB19_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB19_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB19_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB19_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB19_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB19_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB19_DL.Reg, volatile.LoadUint16(&o.MB19_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB19_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB19_DL.Reg) & 0xf
}

// CAN0.MB19_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D0(value uint8) {
	volatile.StoreUint8(&o.MB19_D0.Reg, value)
}
func (o *CAN0_Type) GetMB19_D0() uint8 {
	return volatile.LoadUint8(&o.MB19_D0.Reg)
}

// CAN0.MB19_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D1(value uint8) {
	volatile.StoreUint8(&o.MB19_D1.Reg, value)
}
func (o *CAN0_Type) GetMB19_D1() uint8 {
	return volatile.LoadUint8(&o.MB19_D1.Reg)
}

// CAN0.MB19_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D2(value uint8) {
	volatile.StoreUint8(&o.MB19_D2.Reg, value)
}
func (o *CAN0_Type) GetMB19_D2() uint8 {
	return volatile.LoadUint8(&o.MB19_D2.Reg)
}

// CAN0.MB19_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D3(value uint8) {
	volatile.StoreUint8(&o.MB19_D3.Reg, value)
}
func (o *CAN0_Type) GetMB19_D3() uint8 {
	return volatile.LoadUint8(&o.MB19_D3.Reg)
}

// CAN0.MB19_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D4(value uint8) {
	volatile.StoreUint8(&o.MB19_D4.Reg, value)
}
func (o *CAN0_Type) GetMB19_D4() uint8 {
	return volatile.LoadUint8(&o.MB19_D4.Reg)
}

// CAN0.MB19_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D5(value uint8) {
	volatile.StoreUint8(&o.MB19_D5.Reg, value)
}
func (o *CAN0_Type) GetMB19_D5() uint8 {
	return volatile.LoadUint8(&o.MB19_D5.Reg)
}

// CAN0.MB19_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D6(value uint8) {
	volatile.StoreUint8(&o.MB19_D6.Reg, value)
}
func (o *CAN0_Type) GetMB19_D6() uint8 {
	return volatile.LoadUint8(&o.MB19_D6.Reg)
}

// CAN0.MB19_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D7(value uint8) {
	volatile.StoreUint8(&o.MB19_D7.Reg, value)
}
func (o *CAN0_Type) GetMB19_D7() uint8 {
	return volatile.LoadUint8(&o.MB19_D7.Reg)
}

// CAN0.MB19_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB19_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB19_TS.Reg, volatile.LoadUint16(&o.MB19_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB19_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB19_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB19_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB19_TS.Reg, volatile.LoadUint16(&o.MB19_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB19_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB19_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB20_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB20_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB20_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB20_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB20_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB20_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB20_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB20_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB20_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB20_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB20_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB20_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB20_DL.Reg, volatile.LoadUint16(&o.MB20_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB20_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB20_DL.Reg) & 0xf
}

// CAN0.MB20_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D0(value uint8) {
	volatile.StoreUint8(&o.MB20_D0.Reg, value)
}
func (o *CAN0_Type) GetMB20_D0() uint8 {
	return volatile.LoadUint8(&o.MB20_D0.Reg)
}

// CAN0.MB20_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D1(value uint8) {
	volatile.StoreUint8(&o.MB20_D1.Reg, value)
}
func (o *CAN0_Type) GetMB20_D1() uint8 {
	return volatile.LoadUint8(&o.MB20_D1.Reg)
}

// CAN0.MB20_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D2(value uint8) {
	volatile.StoreUint8(&o.MB20_D2.Reg, value)
}
func (o *CAN0_Type) GetMB20_D2() uint8 {
	return volatile.LoadUint8(&o.MB20_D2.Reg)
}

// CAN0.MB20_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D3(value uint8) {
	volatile.StoreUint8(&o.MB20_D3.Reg, value)
}
func (o *CAN0_Type) GetMB20_D3() uint8 {
	return volatile.LoadUint8(&o.MB20_D3.Reg)
}

// CAN0.MB20_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D4(value uint8) {
	volatile.StoreUint8(&o.MB20_D4.Reg, value)
}
func (o *CAN0_Type) GetMB20_D4() uint8 {
	return volatile.LoadUint8(&o.MB20_D4.Reg)
}

// CAN0.MB20_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D5(value uint8) {
	volatile.StoreUint8(&o.MB20_D5.Reg, value)
}
func (o *CAN0_Type) GetMB20_D5() uint8 {
	return volatile.LoadUint8(&o.MB20_D5.Reg)
}

// CAN0.MB20_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D6(value uint8) {
	volatile.StoreUint8(&o.MB20_D6.Reg, value)
}
func (o *CAN0_Type) GetMB20_D6() uint8 {
	return volatile.LoadUint8(&o.MB20_D6.Reg)
}

// CAN0.MB20_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D7(value uint8) {
	volatile.StoreUint8(&o.MB20_D7.Reg, value)
}
func (o *CAN0_Type) GetMB20_D7() uint8 {
	return volatile.LoadUint8(&o.MB20_D7.Reg)
}

// CAN0.MB20_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB20_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB20_TS.Reg, volatile.LoadUint16(&o.MB20_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB20_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB20_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB20_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB20_TS.Reg, volatile.LoadUint16(&o.MB20_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB20_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB20_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB21_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB21_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB21_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB21_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB21_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB21_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB21_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB21_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB21_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB21_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB21_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB21_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB21_DL.Reg, volatile.LoadUint16(&o.MB21_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB21_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB21_DL.Reg) & 0xf
}

// CAN0.MB21_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D0(value uint8) {
	volatile.StoreUint8(&o.MB21_D0.Reg, value)
}
func (o *CAN0_Type) GetMB21_D0() uint8 {
	return volatile.LoadUint8(&o.MB21_D0.Reg)
}

// CAN0.MB21_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D1(value uint8) {
	volatile.StoreUint8(&o.MB21_D1.Reg, value)
}
func (o *CAN0_Type) GetMB21_D1() uint8 {
	return volatile.LoadUint8(&o.MB21_D1.Reg)
}

// CAN0.MB21_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D2(value uint8) {
	volatile.StoreUint8(&o.MB21_D2.Reg, value)
}
func (o *CAN0_Type) GetMB21_D2() uint8 {
	return volatile.LoadUint8(&o.MB21_D2.Reg)
}

// CAN0.MB21_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D3(value uint8) {
	volatile.StoreUint8(&o.MB21_D3.Reg, value)
}
func (o *CAN0_Type) GetMB21_D3() uint8 {
	return volatile.LoadUint8(&o.MB21_D3.Reg)
}

// CAN0.MB21_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D4(value uint8) {
	volatile.StoreUint8(&o.MB21_D4.Reg, value)
}
func (o *CAN0_Type) GetMB21_D4() uint8 {
	return volatile.LoadUint8(&o.MB21_D4.Reg)
}

// CAN0.MB21_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D5(value uint8) {
	volatile.StoreUint8(&o.MB21_D5.Reg, value)
}
func (o *CAN0_Type) GetMB21_D5() uint8 {
	return volatile.LoadUint8(&o.MB21_D5.Reg)
}

// CAN0.MB21_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D6(value uint8) {
	volatile.StoreUint8(&o.MB21_D6.Reg, value)
}
func (o *CAN0_Type) GetMB21_D6() uint8 {
	return volatile.LoadUint8(&o.MB21_D6.Reg)
}

// CAN0.MB21_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D7(value uint8) {
	volatile.StoreUint8(&o.MB21_D7.Reg, value)
}
func (o *CAN0_Type) GetMB21_D7() uint8 {
	return volatile.LoadUint8(&o.MB21_D7.Reg)
}

// CAN0.MB21_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB21_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB21_TS.Reg, volatile.LoadUint16(&o.MB21_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB21_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB21_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB21_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB21_TS.Reg, volatile.LoadUint16(&o.MB21_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB21_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB21_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB22_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB22_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB22_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB22_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB22_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB22_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB22_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB22_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB22_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB22_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB22_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB22_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB22_DL.Reg, volatile.LoadUint16(&o.MB22_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB22_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB22_DL.Reg) & 0xf
}

// CAN0.MB22_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D0(value uint8) {
	volatile.StoreUint8(&o.MB22_D0.Reg, value)
}
func (o *CAN0_Type) GetMB22_D0() uint8 {
	return volatile.LoadUint8(&o.MB22_D0.Reg)
}

// CAN0.MB22_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D1(value uint8) {
	volatile.StoreUint8(&o.MB22_D1.Reg, value)
}
func (o *CAN0_Type) GetMB22_D1() uint8 {
	return volatile.LoadUint8(&o.MB22_D1.Reg)
}

// CAN0.MB22_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D2(value uint8) {
	volatile.StoreUint8(&o.MB22_D2.Reg, value)
}
func (o *CAN0_Type) GetMB22_D2() uint8 {
	return volatile.LoadUint8(&o.MB22_D2.Reg)
}

// CAN0.MB22_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D3(value uint8) {
	volatile.StoreUint8(&o.MB22_D3.Reg, value)
}
func (o *CAN0_Type) GetMB22_D3() uint8 {
	return volatile.LoadUint8(&o.MB22_D3.Reg)
}

// CAN0.MB22_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D4(value uint8) {
	volatile.StoreUint8(&o.MB22_D4.Reg, value)
}
func (o *CAN0_Type) GetMB22_D4() uint8 {
	return volatile.LoadUint8(&o.MB22_D4.Reg)
}

// CAN0.MB22_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D5(value uint8) {
	volatile.StoreUint8(&o.MB22_D5.Reg, value)
}
func (o *CAN0_Type) GetMB22_D5() uint8 {
	return volatile.LoadUint8(&o.MB22_D5.Reg)
}

// CAN0.MB22_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D6(value uint8) {
	volatile.StoreUint8(&o.MB22_D6.Reg, value)
}
func (o *CAN0_Type) GetMB22_D6() uint8 {
	return volatile.LoadUint8(&o.MB22_D6.Reg)
}

// CAN0.MB22_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D7(value uint8) {
	volatile.StoreUint8(&o.MB22_D7.Reg, value)
}
func (o *CAN0_Type) GetMB22_D7() uint8 {
	return volatile.LoadUint8(&o.MB22_D7.Reg)
}

// CAN0.MB22_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB22_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB22_TS.Reg, volatile.LoadUint16(&o.MB22_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB22_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB22_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB22_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB22_TS.Reg, volatile.LoadUint16(&o.MB22_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB22_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB22_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB23_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB23_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB23_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB23_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB23_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB23_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB23_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB23_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB23_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB23_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB23_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB23_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB23_DL.Reg, volatile.LoadUint16(&o.MB23_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB23_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB23_DL.Reg) & 0xf
}

// CAN0.MB23_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D0(value uint8) {
	volatile.StoreUint8(&o.MB23_D0.Reg, value)
}
func (o *CAN0_Type) GetMB23_D0() uint8 {
	return volatile.LoadUint8(&o.MB23_D0.Reg)
}

// CAN0.MB23_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D1(value uint8) {
	volatile.StoreUint8(&o.MB23_D1.Reg, value)
}
func (o *CAN0_Type) GetMB23_D1() uint8 {
	return volatile.LoadUint8(&o.MB23_D1.Reg)
}

// CAN0.MB23_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D2(value uint8) {
	volatile.StoreUint8(&o.MB23_D2.Reg, value)
}
func (o *CAN0_Type) GetMB23_D2() uint8 {
	return volatile.LoadUint8(&o.MB23_D2.Reg)
}

// CAN0.MB23_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D3(value uint8) {
	volatile.StoreUint8(&o.MB23_D3.Reg, value)
}
func (o *CAN0_Type) GetMB23_D3() uint8 {
	return volatile.LoadUint8(&o.MB23_D3.Reg)
}

// CAN0.MB23_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D4(value uint8) {
	volatile.StoreUint8(&o.MB23_D4.Reg, value)
}
func (o *CAN0_Type) GetMB23_D4() uint8 {
	return volatile.LoadUint8(&o.MB23_D4.Reg)
}

// CAN0.MB23_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D5(value uint8) {
	volatile.StoreUint8(&o.MB23_D5.Reg, value)
}
func (o *CAN0_Type) GetMB23_D5() uint8 {
	return volatile.LoadUint8(&o.MB23_D5.Reg)
}

// CAN0.MB23_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D6(value uint8) {
	volatile.StoreUint8(&o.MB23_D6.Reg, value)
}
func (o *CAN0_Type) GetMB23_D6() uint8 {
	return volatile.LoadUint8(&o.MB23_D6.Reg)
}

// CAN0.MB23_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D7(value uint8) {
	volatile.StoreUint8(&o.MB23_D7.Reg, value)
}
func (o *CAN0_Type) GetMB23_D7() uint8 {
	return volatile.LoadUint8(&o.MB23_D7.Reg)
}

// CAN0.MB23_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB23_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB23_TS.Reg, volatile.LoadUint16(&o.MB23_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB23_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB23_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB23_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB23_TS.Reg, volatile.LoadUint16(&o.MB23_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB23_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB23_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB24_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB24_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB24_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB24_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB24_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB24_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB24_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB24_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB24_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB24_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB24_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB24_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB24_DL.Reg, volatile.LoadUint16(&o.MB24_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB24_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB24_DL.Reg) & 0xf
}

// CAN0.MB24_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D0(value uint8) {
	volatile.StoreUint8(&o.MB24_D0.Reg, value)
}
func (o *CAN0_Type) GetMB24_D0() uint8 {
	return volatile.LoadUint8(&o.MB24_D0.Reg)
}

// CAN0.MB24_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D1(value uint8) {
	volatile.StoreUint8(&o.MB24_D1.Reg, value)
}
func (o *CAN0_Type) GetMB24_D1() uint8 {
	return volatile.LoadUint8(&o.MB24_D1.Reg)
}

// CAN0.MB24_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D2(value uint8) {
	volatile.StoreUint8(&o.MB24_D2.Reg, value)
}
func (o *CAN0_Type) GetMB24_D2() uint8 {
	return volatile.LoadUint8(&o.MB24_D2.Reg)
}

// CAN0.MB24_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D3(value uint8) {
	volatile.StoreUint8(&o.MB24_D3.Reg, value)
}
func (o *CAN0_Type) GetMB24_D3() uint8 {
	return volatile.LoadUint8(&o.MB24_D3.Reg)
}

// CAN0.MB24_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D4(value uint8) {
	volatile.StoreUint8(&o.MB24_D4.Reg, value)
}
func (o *CAN0_Type) GetMB24_D4() uint8 {
	return volatile.LoadUint8(&o.MB24_D4.Reg)
}

// CAN0.MB24_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D5(value uint8) {
	volatile.StoreUint8(&o.MB24_D5.Reg, value)
}
func (o *CAN0_Type) GetMB24_D5() uint8 {
	return volatile.LoadUint8(&o.MB24_D5.Reg)
}

// CAN0.MB24_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D6(value uint8) {
	volatile.StoreUint8(&o.MB24_D6.Reg, value)
}
func (o *CAN0_Type) GetMB24_D6() uint8 {
	return volatile.LoadUint8(&o.MB24_D6.Reg)
}

// CAN0.MB24_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D7(value uint8) {
	volatile.StoreUint8(&o.MB24_D7.Reg, value)
}
func (o *CAN0_Type) GetMB24_D7() uint8 {
	return volatile.LoadUint8(&o.MB24_D7.Reg)
}

// CAN0.MB24_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB24_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB24_TS.Reg, volatile.LoadUint16(&o.MB24_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB24_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB24_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB24_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB24_TS.Reg, volatile.LoadUint16(&o.MB24_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB24_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB24_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB25_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB25_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB25_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB25_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB25_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB25_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB25_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB25_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB25_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB25_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB25_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB25_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB25_DL.Reg, volatile.LoadUint16(&o.MB25_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB25_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB25_DL.Reg) & 0xf
}

// CAN0.MB25_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D0(value uint8) {
	volatile.StoreUint8(&o.MB25_D0.Reg, value)
}
func (o *CAN0_Type) GetMB25_D0() uint8 {
	return volatile.LoadUint8(&o.MB25_D0.Reg)
}

// CAN0.MB25_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D1(value uint8) {
	volatile.StoreUint8(&o.MB25_D1.Reg, value)
}
func (o *CAN0_Type) GetMB25_D1() uint8 {
	return volatile.LoadUint8(&o.MB25_D1.Reg)
}

// CAN0.MB25_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D2(value uint8) {
	volatile.StoreUint8(&o.MB25_D2.Reg, value)
}
func (o *CAN0_Type) GetMB25_D2() uint8 {
	return volatile.LoadUint8(&o.MB25_D2.Reg)
}

// CAN0.MB25_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D3(value uint8) {
	volatile.StoreUint8(&o.MB25_D3.Reg, value)
}
func (o *CAN0_Type) GetMB25_D3() uint8 {
	return volatile.LoadUint8(&o.MB25_D3.Reg)
}

// CAN0.MB25_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D4(value uint8) {
	volatile.StoreUint8(&o.MB25_D4.Reg, value)
}
func (o *CAN0_Type) GetMB25_D4() uint8 {
	return volatile.LoadUint8(&o.MB25_D4.Reg)
}

// CAN0.MB25_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D5(value uint8) {
	volatile.StoreUint8(&o.MB25_D5.Reg, value)
}
func (o *CAN0_Type) GetMB25_D5() uint8 {
	return volatile.LoadUint8(&o.MB25_D5.Reg)
}

// CAN0.MB25_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D6(value uint8) {
	volatile.StoreUint8(&o.MB25_D6.Reg, value)
}
func (o *CAN0_Type) GetMB25_D6() uint8 {
	return volatile.LoadUint8(&o.MB25_D6.Reg)
}

// CAN0.MB25_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D7(value uint8) {
	volatile.StoreUint8(&o.MB25_D7.Reg, value)
}
func (o *CAN0_Type) GetMB25_D7() uint8 {
	return volatile.LoadUint8(&o.MB25_D7.Reg)
}

// CAN0.MB25_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB25_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB25_TS.Reg, volatile.LoadUint16(&o.MB25_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB25_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB25_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB25_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB25_TS.Reg, volatile.LoadUint16(&o.MB25_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB25_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB25_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB26_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB26_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB26_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB26_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB26_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB26_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB26_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB26_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB26_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB26_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB26_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB26_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB26_DL.Reg, volatile.LoadUint16(&o.MB26_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB26_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB26_DL.Reg) & 0xf
}

// CAN0.MB26_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D0(value uint8) {
	volatile.StoreUint8(&o.MB26_D0.Reg, value)
}
func (o *CAN0_Type) GetMB26_D0() uint8 {
	return volatile.LoadUint8(&o.MB26_D0.Reg)
}

// CAN0.MB26_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D1(value uint8) {
	volatile.StoreUint8(&o.MB26_D1.Reg, value)
}
func (o *CAN0_Type) GetMB26_D1() uint8 {
	return volatile.LoadUint8(&o.MB26_D1.Reg)
}

// CAN0.MB26_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D2(value uint8) {
	volatile.StoreUint8(&o.MB26_D2.Reg, value)
}
func (o *CAN0_Type) GetMB26_D2() uint8 {
	return volatile.LoadUint8(&o.MB26_D2.Reg)
}

// CAN0.MB26_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D3(value uint8) {
	volatile.StoreUint8(&o.MB26_D3.Reg, value)
}
func (o *CAN0_Type) GetMB26_D3() uint8 {
	return volatile.LoadUint8(&o.MB26_D3.Reg)
}

// CAN0.MB26_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D4(value uint8) {
	volatile.StoreUint8(&o.MB26_D4.Reg, value)
}
func (o *CAN0_Type) GetMB26_D4() uint8 {
	return volatile.LoadUint8(&o.MB26_D4.Reg)
}

// CAN0.MB26_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D5(value uint8) {
	volatile.StoreUint8(&o.MB26_D5.Reg, value)
}
func (o *CAN0_Type) GetMB26_D5() uint8 {
	return volatile.LoadUint8(&o.MB26_D5.Reg)
}

// CAN0.MB26_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D6(value uint8) {
	volatile.StoreUint8(&o.MB26_D6.Reg, value)
}
func (o *CAN0_Type) GetMB26_D6() uint8 {
	return volatile.LoadUint8(&o.MB26_D6.Reg)
}

// CAN0.MB26_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D7(value uint8) {
	volatile.StoreUint8(&o.MB26_D7.Reg, value)
}
func (o *CAN0_Type) GetMB26_D7() uint8 {
	return volatile.LoadUint8(&o.MB26_D7.Reg)
}

// CAN0.MB26_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB26_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB26_TS.Reg, volatile.LoadUint16(&o.MB26_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB26_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB26_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB26_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB26_TS.Reg, volatile.LoadUint16(&o.MB26_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB26_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB26_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB27_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB27_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB27_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB27_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB27_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB27_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB27_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB27_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB27_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB27_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB27_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB27_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB27_DL.Reg, volatile.LoadUint16(&o.MB27_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB27_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB27_DL.Reg) & 0xf
}

// CAN0.MB27_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D0(value uint8) {
	volatile.StoreUint8(&o.MB27_D0.Reg, value)
}
func (o *CAN0_Type) GetMB27_D0() uint8 {
	return volatile.LoadUint8(&o.MB27_D0.Reg)
}

// CAN0.MB27_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D1(value uint8) {
	volatile.StoreUint8(&o.MB27_D1.Reg, value)
}
func (o *CAN0_Type) GetMB27_D1() uint8 {
	return volatile.LoadUint8(&o.MB27_D1.Reg)
}

// CAN0.MB27_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D2(value uint8) {
	volatile.StoreUint8(&o.MB27_D2.Reg, value)
}
func (o *CAN0_Type) GetMB27_D2() uint8 {
	return volatile.LoadUint8(&o.MB27_D2.Reg)
}

// CAN0.MB27_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D3(value uint8) {
	volatile.StoreUint8(&o.MB27_D3.Reg, value)
}
func (o *CAN0_Type) GetMB27_D3() uint8 {
	return volatile.LoadUint8(&o.MB27_D3.Reg)
}

// CAN0.MB27_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D4(value uint8) {
	volatile.StoreUint8(&o.MB27_D4.Reg, value)
}
func (o *CAN0_Type) GetMB27_D4() uint8 {
	return volatile.LoadUint8(&o.MB27_D4.Reg)
}

// CAN0.MB27_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D5(value uint8) {
	volatile.StoreUint8(&o.MB27_D5.Reg, value)
}
func (o *CAN0_Type) GetMB27_D5() uint8 {
	return volatile.LoadUint8(&o.MB27_D5.Reg)
}

// CAN0.MB27_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D6(value uint8) {
	volatile.StoreUint8(&o.MB27_D6.Reg, value)
}
func (o *CAN0_Type) GetMB27_D6() uint8 {
	return volatile.LoadUint8(&o.MB27_D6.Reg)
}

// CAN0.MB27_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D7(value uint8) {
	volatile.StoreUint8(&o.MB27_D7.Reg, value)
}
func (o *CAN0_Type) GetMB27_D7() uint8 {
	return volatile.LoadUint8(&o.MB27_D7.Reg)
}

// CAN0.MB27_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB27_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB27_TS.Reg, volatile.LoadUint16(&o.MB27_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB27_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB27_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB27_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB27_TS.Reg, volatile.LoadUint16(&o.MB27_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB27_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB27_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB28_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB28_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB28_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB28_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB28_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB28_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB28_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB28_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB28_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB28_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB28_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB28_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB28_DL.Reg, volatile.LoadUint16(&o.MB28_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB28_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB28_DL.Reg) & 0xf
}

// CAN0.MB28_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D0(value uint8) {
	volatile.StoreUint8(&o.MB28_D0.Reg, value)
}
func (o *CAN0_Type) GetMB28_D0() uint8 {
	return volatile.LoadUint8(&o.MB28_D0.Reg)
}

// CAN0.MB28_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D1(value uint8) {
	volatile.StoreUint8(&o.MB28_D1.Reg, value)
}
func (o *CAN0_Type) GetMB28_D1() uint8 {
	return volatile.LoadUint8(&o.MB28_D1.Reg)
}

// CAN0.MB28_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D2(value uint8) {
	volatile.StoreUint8(&o.MB28_D2.Reg, value)
}
func (o *CAN0_Type) GetMB28_D2() uint8 {
	return volatile.LoadUint8(&o.MB28_D2.Reg)
}

// CAN0.MB28_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D3(value uint8) {
	volatile.StoreUint8(&o.MB28_D3.Reg, value)
}
func (o *CAN0_Type) GetMB28_D3() uint8 {
	return volatile.LoadUint8(&o.MB28_D3.Reg)
}

// CAN0.MB28_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D4(value uint8) {
	volatile.StoreUint8(&o.MB28_D4.Reg, value)
}
func (o *CAN0_Type) GetMB28_D4() uint8 {
	return volatile.LoadUint8(&o.MB28_D4.Reg)
}

// CAN0.MB28_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D5(value uint8) {
	volatile.StoreUint8(&o.MB28_D5.Reg, value)
}
func (o *CAN0_Type) GetMB28_D5() uint8 {
	return volatile.LoadUint8(&o.MB28_D5.Reg)
}

// CAN0.MB28_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D6(value uint8) {
	volatile.StoreUint8(&o.MB28_D6.Reg, value)
}
func (o *CAN0_Type) GetMB28_D6() uint8 {
	return volatile.LoadUint8(&o.MB28_D6.Reg)
}

// CAN0.MB28_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D7(value uint8) {
	volatile.StoreUint8(&o.MB28_D7.Reg, value)
}
func (o *CAN0_Type) GetMB28_D7() uint8 {
	return volatile.LoadUint8(&o.MB28_D7.Reg)
}

// CAN0.MB28_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB28_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB28_TS.Reg, volatile.LoadUint16(&o.MB28_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB28_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB28_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB28_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB28_TS.Reg, volatile.LoadUint16(&o.MB28_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB28_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB28_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB29_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB29_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB29_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB29_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB29_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB29_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB29_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB29_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB29_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB29_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB29_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB29_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB29_DL.Reg, volatile.LoadUint16(&o.MB29_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB29_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB29_DL.Reg) & 0xf
}

// CAN0.MB29_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D0(value uint8) {
	volatile.StoreUint8(&o.MB29_D0.Reg, value)
}
func (o *CAN0_Type) GetMB29_D0() uint8 {
	return volatile.LoadUint8(&o.MB29_D0.Reg)
}

// CAN0.MB29_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D1(value uint8) {
	volatile.StoreUint8(&o.MB29_D1.Reg, value)
}
func (o *CAN0_Type) GetMB29_D1() uint8 {
	return volatile.LoadUint8(&o.MB29_D1.Reg)
}

// CAN0.MB29_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D2(value uint8) {
	volatile.StoreUint8(&o.MB29_D2.Reg, value)
}
func (o *CAN0_Type) GetMB29_D2() uint8 {
	return volatile.LoadUint8(&o.MB29_D2.Reg)
}

// CAN0.MB29_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D3(value uint8) {
	volatile.StoreUint8(&o.MB29_D3.Reg, value)
}
func (o *CAN0_Type) GetMB29_D3() uint8 {
	return volatile.LoadUint8(&o.MB29_D3.Reg)
}

// CAN0.MB29_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D4(value uint8) {
	volatile.StoreUint8(&o.MB29_D4.Reg, value)
}
func (o *CAN0_Type) GetMB29_D4() uint8 {
	return volatile.LoadUint8(&o.MB29_D4.Reg)
}

// CAN0.MB29_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D5(value uint8) {
	volatile.StoreUint8(&o.MB29_D5.Reg, value)
}
func (o *CAN0_Type) GetMB29_D5() uint8 {
	return volatile.LoadUint8(&o.MB29_D5.Reg)
}

// CAN0.MB29_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D6(value uint8) {
	volatile.StoreUint8(&o.MB29_D6.Reg, value)
}
func (o *CAN0_Type) GetMB29_D6() uint8 {
	return volatile.LoadUint8(&o.MB29_D6.Reg)
}

// CAN0.MB29_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D7(value uint8) {
	volatile.StoreUint8(&o.MB29_D7.Reg, value)
}
func (o *CAN0_Type) GetMB29_D7() uint8 {
	return volatile.LoadUint8(&o.MB29_D7.Reg)
}

// CAN0.MB29_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB29_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB29_TS.Reg, volatile.LoadUint16(&o.MB29_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB29_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB29_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB29_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB29_TS.Reg, volatile.LoadUint16(&o.MB29_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB29_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB29_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB30_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB30_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB30_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB30_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB30_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB30_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB30_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB30_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB30_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB30_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB30_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB30_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB30_DL.Reg, volatile.LoadUint16(&o.MB30_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB30_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB30_DL.Reg) & 0xf
}

// CAN0.MB30_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D0(value uint8) {
	volatile.StoreUint8(&o.MB30_D0.Reg, value)
}
func (o *CAN0_Type) GetMB30_D0() uint8 {
	return volatile.LoadUint8(&o.MB30_D0.Reg)
}

// CAN0.MB30_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D1(value uint8) {
	volatile.StoreUint8(&o.MB30_D1.Reg, value)
}
func (o *CAN0_Type) GetMB30_D1() uint8 {
	return volatile.LoadUint8(&o.MB30_D1.Reg)
}

// CAN0.MB30_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D2(value uint8) {
	volatile.StoreUint8(&o.MB30_D2.Reg, value)
}
func (o *CAN0_Type) GetMB30_D2() uint8 {
	return volatile.LoadUint8(&o.MB30_D2.Reg)
}

// CAN0.MB30_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D3(value uint8) {
	volatile.StoreUint8(&o.MB30_D3.Reg, value)
}
func (o *CAN0_Type) GetMB30_D3() uint8 {
	return volatile.LoadUint8(&o.MB30_D3.Reg)
}

// CAN0.MB30_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D4(value uint8) {
	volatile.StoreUint8(&o.MB30_D4.Reg, value)
}
func (o *CAN0_Type) GetMB30_D4() uint8 {
	return volatile.LoadUint8(&o.MB30_D4.Reg)
}

// CAN0.MB30_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D5(value uint8) {
	volatile.StoreUint8(&o.MB30_D5.Reg, value)
}
func (o *CAN0_Type) GetMB30_D5() uint8 {
	return volatile.LoadUint8(&o.MB30_D5.Reg)
}

// CAN0.MB30_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D6(value uint8) {
	volatile.StoreUint8(&o.MB30_D6.Reg, value)
}
func (o *CAN0_Type) GetMB30_D6() uint8 {
	return volatile.LoadUint8(&o.MB30_D6.Reg)
}

// CAN0.MB30_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D7(value uint8) {
	volatile.StoreUint8(&o.MB30_D7.Reg, value)
}
func (o *CAN0_Type) GetMB30_D7() uint8 {
	return volatile.LoadUint8(&o.MB30_D7.Reg)
}

// CAN0.MB30_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB30_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB30_TS.Reg, volatile.LoadUint16(&o.MB30_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB30_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB30_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB30_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB30_TS.Reg, volatile.LoadUint16(&o.MB30_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB30_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB30_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB31_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB31_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB31_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB31_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB31_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB31_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB31_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB31_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB31_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB31_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB31_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB31_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB31_DL.Reg, volatile.LoadUint16(&o.MB31_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB31_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB31_DL.Reg) & 0xf
}

// CAN0.MB31_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D0(value uint8) {
	volatile.StoreUint8(&o.MB31_D0.Reg, value)
}
func (o *CAN0_Type) GetMB31_D0() uint8 {
	return volatile.LoadUint8(&o.MB31_D0.Reg)
}

// CAN0.MB31_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D1(value uint8) {
	volatile.StoreUint8(&o.MB31_D1.Reg, value)
}
func (o *CAN0_Type) GetMB31_D1() uint8 {
	return volatile.LoadUint8(&o.MB31_D1.Reg)
}

// CAN0.MB31_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D2(value uint8) {
	volatile.StoreUint8(&o.MB31_D2.Reg, value)
}
func (o *CAN0_Type) GetMB31_D2() uint8 {
	return volatile.LoadUint8(&o.MB31_D2.Reg)
}

// CAN0.MB31_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D3(value uint8) {
	volatile.StoreUint8(&o.MB31_D3.Reg, value)
}
func (o *CAN0_Type) GetMB31_D3() uint8 {
	return volatile.LoadUint8(&o.MB31_D3.Reg)
}

// CAN0.MB31_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D4(value uint8) {
	volatile.StoreUint8(&o.MB31_D4.Reg, value)
}
func (o *CAN0_Type) GetMB31_D4() uint8 {
	return volatile.LoadUint8(&o.MB31_D4.Reg)
}

// CAN0.MB31_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D5(value uint8) {
	volatile.StoreUint8(&o.MB31_D5.Reg, value)
}
func (o *CAN0_Type) GetMB31_D5() uint8 {
	return volatile.LoadUint8(&o.MB31_D5.Reg)
}

// CAN0.MB31_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D6(value uint8) {
	volatile.StoreUint8(&o.MB31_D6.Reg, value)
}
func (o *CAN0_Type) GetMB31_D6() uint8 {
	return volatile.LoadUint8(&o.MB31_D6.Reg)
}

// CAN0.MB31_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D7(value uint8) {
	volatile.StoreUint8(&o.MB31_D7.Reg, value)
}
func (o *CAN0_Type) GetMB31_D7() uint8 {
	return volatile.LoadUint8(&o.MB31_D7.Reg)
}

// CAN0.MB31_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB31_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB31_TS.Reg, volatile.LoadUint16(&o.MB31_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB31_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB31_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB31_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB31_TS.Reg, volatile.LoadUint16(&o.MB31_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB31_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB31_TS.Reg) & 0xff00) >> 8
}

// CAN0.MKR: Mask Register %s
func (o *CAN0_Type) SetMKR_EID(idx int, value uint32) {
	volatile.StoreUint32(&o.MKR[idx].Reg, volatile.LoadUint32(&o.MKR[idx].Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMKR_EID(idx int) uint32 {
	return volatile.LoadUint32(&o.MKR[idx].Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMKR_SID(idx int, value uint32) {
	volatile.StoreUint32(&o.MKR[idx].Reg, volatile.LoadUint32(&o.MKR[idx].Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMKR_SID(idx int) uint32 {
	return (volatile.LoadUint32(&o.MKR[idx].Reg) & 0x1ffc0000) >> 18
}

// CAN0.FIDCR0: FIFO Received ID Compare Register %s
func (o *CAN0_Type) SetFIDCR0_EID(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetFIDCR0_EID() uint32 {
	return volatile.LoadUint32(&o.FIDCR0.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetFIDCR0_SID(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetFIDCR0_SID() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetFIDCR0_RTR(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetFIDCR0_RTR() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetFIDCR0_IDE(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetFIDCR0_IDE() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x80000000) >> 31
}

// CAN0.FIDCR1: FIFO Received ID Compare Register %s
func (o *CAN0_Type) SetFIDCR1_EID(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetFIDCR1_EID() uint32 {
	return volatile.LoadUint32(&o.FIDCR1.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetFIDCR1_SID(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetFIDCR1_SID() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetFIDCR1_RTR(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetFIDCR1_RTR() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetFIDCR1_IDE(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetFIDCR1_IDE() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x80000000) >> 31
}

// CAN0.MKIVLR: Mask Invalid Register
func (o *CAN0_Type) SetMKIVLR_MB00(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMKIVLR_MB00() uint32 {
	return volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1
}
func (o *CAN0_Type) SetMKIVLR_MB01(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMKIVLR_MB01() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMKIVLR_MB02(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMKIVLR_MB02() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMKIVLR_MB03(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetMKIVLR_MB03() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetMKIVLR_MB04(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMKIVLR_MB04() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMKIVLR_MB05(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetMKIVLR_MB05() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetMKIVLR_MB06(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMKIVLR_MB06() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMKIVLR_MB07(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMKIVLR_MB07() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMKIVLR_MB08(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetMKIVLR_MB08() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetMKIVLR_MB09(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetMKIVLR_MB09() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetMKIVLR_MB10(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetMKIVLR_MB10() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetMKIVLR_MB11(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetMKIVLR_MB11() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetMKIVLR_MB12(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetMKIVLR_MB12() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetMKIVLR_MB13(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetMKIVLR_MB13() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetMKIVLR_MB14(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetMKIVLR_MB14() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetMKIVLR_MB15(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetMKIVLR_MB15() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetMKIVLR_MB16(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetMKIVLR_MB16() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetMKIVLR_MB17(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetMKIVLR_MB17() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetMKIVLR_MB18(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetMKIVLR_MB18() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetMKIVLR_MB19(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetMKIVLR_MB19() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetMKIVLR_MB20(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetMKIVLR_MB20() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetMKIVLR_MB21(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetMKIVLR_MB21() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetMKIVLR_MB22(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetMKIVLR_MB22() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetMKIVLR_MB23(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetMKIVLR_MB23() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetMKIVLR_MB24(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetMKIVLR_MB24() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetMKIVLR_MB25(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetMKIVLR_MB25() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetMKIVLR_MB26(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetMKIVLR_MB26() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetMKIVLR_MB27(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetMKIVLR_MB27() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetMKIVLR_MB28(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetMKIVLR_MB28() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetMKIVLR_MB29(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMKIVLR_MB29() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMKIVLR_MB30(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMKIVLR_MB30() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMKIVLR_MB31(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMKIVLR_MB31() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80000000) >> 31
}

// CAN0.MIER: Mailbox Interrupt Enable Register
func (o *CAN0_Type) SetMIER_MB00(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMIER_MB00() uint32 {
	return volatile.LoadUint32(&o.MIER.Reg) & 0x1
}
func (o *CAN0_Type) SetMIER_MB01(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMIER_MB01() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMIER_MB02(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMIER_MB02() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMIER_MB03(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetMIER_MB03() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetMIER_MB04(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMIER_MB04() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMIER_MB05(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetMIER_MB05() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetMIER_MB06(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMIER_MB06() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMIER_MB07(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMIER_MB07() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMIER_MB08(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetMIER_MB08() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetMIER_MB09(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetMIER_MB09() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetMIER_MB10(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetMIER_MB10() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetMIER_MB11(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetMIER_MB11() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetMIER_MB12(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetMIER_MB12() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetMIER_MB13(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetMIER_MB13() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetMIER_MB14(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetMIER_MB14() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetMIER_MB15(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetMIER_MB15() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetMIER_MB16(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetMIER_MB16() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetMIER_MB17(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetMIER_MB17() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetMIER_MB18(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetMIER_MB18() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetMIER_MB19(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetMIER_MB19() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetMIER_MB20(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetMIER_MB20() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetMIER_MB21(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetMIER_MB21() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetMIER_MB22(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetMIER_MB22() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetMIER_MB23(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetMIER_MB23() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetMIER_MB24(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetMIER_MB24() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetMIER_MB25(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetMIER_MB25() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetMIER_MB26(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetMIER_MB26() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetMIER_MB27(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetMIER_MB27() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetMIER_MB28(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetMIER_MB28() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetMIER_MB29(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMIER_MB29() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMIER_MB30(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMIER_MB30() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMIER_MB31(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMIER_MB31() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80000000) >> 31
}

// CAN0.MCTL_RX: Message Control Register for Receive
func (o *CAN0_Type) SetMCTL_RX_NEWDATA(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_RX[idx].Reg, volatile.LoadUint8(&o.MCTL_RX[idx].Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMCTL_RX_NEWDATA(idx int) uint8 {
	return volatile.LoadUint8(&o.MCTL_RX[idx].Reg) & 0x1
}
func (o *CAN0_Type) SetMCTL_RX_INVALDATA(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_RX[idx].Reg, volatile.LoadUint8(&o.MCTL_RX[idx].Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMCTL_RX_INVALDATA(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_RX[idx].Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMCTL_RX_MSGLOST(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_RX[idx].Reg, volatile.LoadUint8(&o.MCTL_RX[idx].Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMCTL_RX_MSGLOST(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_RX[idx].Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMCTL_RX_ONESHOT(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_RX[idx].Reg, volatile.LoadUint8(&o.MCTL_RX[idx].Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMCTL_RX_ONESHOT(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_RX[idx].Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMCTL_RX_RECREQ(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_RX[idx].Reg, volatile.LoadUint8(&o.MCTL_RX[idx].Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMCTL_RX_RECREQ(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_RX[idx].Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMCTL_RX_TRMREQ(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_RX[idx].Reg, volatile.LoadUint8(&o.MCTL_RX[idx].Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMCTL_RX_TRMREQ(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_RX[idx].Reg) & 0x80) >> 7
}

// CAN0.CTLR: Control Register
func (o *CAN0_Type) SetCTLR_MBM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetCTLR_MBM() uint16 {
	return volatile.LoadUint16(&o.CTLR.Reg) & 0x1
}
func (o *CAN0_Type) SetCTLR_IDFM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x6)|value<<1)
}
func (o *CAN0_Type) GetCTLR_IDFM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x6) >> 1
}
func (o *CAN0_Type) SetCTLR_MLM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetCTLR_MLM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetCTLR_TPM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetCTLR_TPM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetCTLR_TSRC(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetCTLR_TSRC() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetCTLR_TSPS(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0xc0)|value<<6)
}
func (o *CAN0_Type) GetCTLR_TSPS() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0xc0) >> 6
}
func (o *CAN0_Type) SetCTLR_CANM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x300)|value<<8)
}
func (o *CAN0_Type) GetCTLR_CANM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x300) >> 8
}
func (o *CAN0_Type) SetCTLR_SLPM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetCTLR_SLPM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetCTLR_BOM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x1800)|value<<11)
}
func (o *CAN0_Type) GetCTLR_BOM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x1800) >> 11
}
func (o *CAN0_Type) SetCTLR_RBOC(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetCTLR_RBOC() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x2000) >> 13
}

// CAN0.STR: Status Register
func (o *CAN0_Type) SetSTR_NDST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetSTR_NDST() uint16 {
	return volatile.LoadUint16(&o.STR.Reg) & 0x1
}
func (o *CAN0_Type) SetSTR_SDST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetSTR_SDST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetSTR_RFST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetSTR_RFST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetSTR_TFST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetSTR_TFST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetSTR_NMLST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetSTR_NMLST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetSTR_FMLST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetSTR_FMLST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetSTR_TABST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetSTR_TABST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetSTR_EST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetSTR_EST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetSTR_RSTST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetSTR_RSTST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetSTR_HLTST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetSTR_HLTST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetSTR_SLPST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetSTR_SLPST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetSTR_EPST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetSTR_EPST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetSTR_BOST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetSTR_BOST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetSTR_TRMST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetSTR_TRMST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetSTR_RECST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetSTR_RECST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x4000) >> 14
}

// CAN0.BCR: Bit Configuration Register
func (o *CAN0_Type) SetBCR_CCLKS(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetBCR_CCLKS() uint32 {
	return volatile.LoadUint32(&o.BCR.Reg) & 0x1
}
func (o *CAN0_Type) SetBCR_TSEG2(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x700)|value<<8)
}
func (o *CAN0_Type) GetBCR_TSEG2() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x700) >> 8
}
func (o *CAN0_Type) SetBCR_SJW(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x3000)|value<<12)
}
func (o *CAN0_Type) GetBCR_SJW() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x3000) >> 12
}
func (o *CAN0_Type) SetBCR_BRP(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *CAN0_Type) GetBCR_BRP() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x3ff0000) >> 16
}
func (o *CAN0_Type) SetBCR_TSEG1(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAN0_Type) GetBCR_TSEG1() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0xf0000000) >> 28
}

// CAN0.RFCR: Receive FIFO Control Register
func (o *CAN0_Type) SetRFCR_RFE(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRFCR_RFE() uint8 {
	return volatile.LoadUint8(&o.RFCR.Reg) & 0x1
}
func (o *CAN0_Type) SetRFCR_RFUST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0xe)|value<<1)
}
func (o *CAN0_Type) GetRFCR_RFUST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0xe) >> 1
}
func (o *CAN0_Type) SetRFCR_RFMLF(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRFCR_RFMLF() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRFCR_RFFST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRFCR_RFFST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRFCR_RFWST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRFCR_RFWST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRFCR_RFEST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRFCR_RFEST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x80) >> 7
}

// CAN0.TFCR: Transmit FIFO Control Register
func (o *CAN0_Type) SetTFCR_TFE(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetTFCR_TFE() uint8 {
	return volatile.LoadUint8(&o.TFCR.Reg) & 0x1
}
func (o *CAN0_Type) SetTFCR_TFUST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0xe)|value<<1)
}
func (o *CAN0_Type) GetTFCR_TFUST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0xe) >> 1
}
func (o *CAN0_Type) SetTFCR_TFFST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetTFCR_TFFST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetTFCR_TFEST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetTFCR_TFEST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0x80) >> 7
}

// CAN0.EIER: Error Interrupt Enable Register
func (o *CAN0_Type) SetEIER_BEIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetEIER_BEIE() uint8 {
	return volatile.LoadUint8(&o.EIER.Reg) & 0x1
}
func (o *CAN0_Type) SetEIER_EWIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetEIER_EWIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetEIER_EPIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetEIER_EPIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetEIER_BOEIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetEIER_BOEIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetEIER_BORIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetEIER_BORIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetEIER_ORIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetEIER_ORIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetEIER_OLIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetEIER_OLIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetEIER_BLIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetEIER_BLIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x80) >> 7
}

// CAN0.EIFR: Error Interrupt Factor Judge Register
func (o *CAN0_Type) SetEIFR_BEIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetEIFR_BEIF() uint8 {
	return volatile.LoadUint8(&o.EIFR.Reg) & 0x1
}
func (o *CAN0_Type) SetEIFR_EWIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetEIFR_EWIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetEIFR_EPIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetEIFR_EPIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetEIFR_BOEIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetEIFR_BOEIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetEIFR_BORIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetEIFR_BORIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetEIFR_ORIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetEIFR_ORIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetEIFR_OLIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetEIFR_OLIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetEIFR_BLIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetEIFR_BLIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x80) >> 7
}

// CAN0.ECSR: Error Code Store Register
func (o *CAN0_Type) SetECSR_SEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetECSR_SEF() uint8 {
	return volatile.LoadUint8(&o.ECSR.Reg) & 0x1
}
func (o *CAN0_Type) SetECSR_FEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetECSR_FEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetECSR_AEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetECSR_AEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetECSR_CEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetECSR_CEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetECSR_BE1F(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetECSR_BE1F() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetECSR_BE0F(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetECSR_BE0F() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetECSR_ADEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetECSR_ADEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetECSR_EDPM(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetECSR_EDPM() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x80) >> 7
}

// CAN0.MSSR: Mailbox Search Status Register
func (o *CAN0_Type) SetMSSR_MBNST(value uint8) {
	volatile.StoreUint8(&o.MSSR.Reg, volatile.LoadUint8(&o.MSSR.Reg)&^(0x1f)|value)
}
func (o *CAN0_Type) GetMSSR_MBNST() uint8 {
	return volatile.LoadUint8(&o.MSSR.Reg) & 0x1f
}
func (o *CAN0_Type) SetMSSR_SEST(value uint8) {
	volatile.StoreUint8(&o.MSSR.Reg, volatile.LoadUint8(&o.MSSR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMSSR_SEST() uint8 {
	return (volatile.LoadUint8(&o.MSSR.Reg) & 0x80) >> 7
}

// CAN0.MSMR: Mailbox Search Mode Register
func (o *CAN0_Type) SetMSMR_MBSM(value uint8) {
	volatile.StoreUint8(&o.MSMR.Reg, volatile.LoadUint8(&o.MSMR.Reg)&^(0x3)|value)
}
func (o *CAN0_Type) GetMSMR_MBSM() uint8 {
	return volatile.LoadUint8(&o.MSMR.Reg) & 0x3
}

// CAN0.TCR: Test Control Register
func (o *CAN0_Type) SetTCR_TSTE(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetTCR_TSTE() uint8 {
	return volatile.LoadUint8(&o.TCR.Reg) & 0x1
}
func (o *CAN0_Type) SetTCR_TSTM(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0x6)|value<<1)
}
func (o *CAN0_Type) GetTCR_TSTM() uint8 {
	return (volatile.LoadUint8(&o.TCR.Reg) & 0x6) >> 1
}

// Inter-Integrated Circuit 0
type IIC0_Type struct {
	ICCR1 volatile.Register8 // 0x0
	ICCR2 volatile.Register8 // 0x1
	ICMR1 volatile.Register8 // 0x2
	ICMR2 volatile.Register8 // 0x3
	ICMR3 volatile.Register8 // 0x4
	ICFER volatile.Register8 // 0x5
	ICSER volatile.Register8 // 0x6
	ICIER volatile.Register8 // 0x7
	ICSR1 volatile.Register8 // 0x8
	ICSR2 volatile.Register8 // 0x9
	SARL0 volatile.Register8 // 0xA
	SARU0 volatile.Register8 // 0xB
	SARL1 volatile.Register8 // 0xC
	SARU1 volatile.Register8 // 0xD
	SARL2 volatile.Register8 // 0xE
	SARU2 volatile.Register8 // 0xF
	ICBRL volatile.Register8 // 0x10
	ICBRH volatile.Register8 // 0x11
	ICDRT volatile.Register8 // 0x12
	ICDRR volatile.Register8 // 0x13
}

// IIC0.ICCR1: I2C Bus Control Register 1
func (o *IIC0_Type) SetICCR1_SDAI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICCR1_SDAI() uint8 {
	return volatile.LoadUint8(&o.ICCR1.Reg) & 0x1
}
func (o *IIC0_Type) SetICCR1_SCLI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICCR1_SCLI() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICCR1_SDAO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICCR1_SDAO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICCR1_SCLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICCR1_SCLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICCR1_SOWP(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICCR1_SOWP() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICCR1_CLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICCR1_CLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICCR1_IICRST(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICCR1_IICRST() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICCR1_ICE(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICCR1_ICE() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x80) >> 7
}

// IIC0.ICCR2: I2C Bus Control Register 2
func (o *IIC0_Type) SetICCR2_ST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICCR2_ST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICCR2_RS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICCR2_RS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICCR2_SP(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICCR2_SP() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICCR2_TRS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICCR2_TRS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICCR2_MST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICCR2_MST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICCR2_BBSY(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICCR2_BBSY() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x80) >> 7
}

// IIC0.ICMR1: I2C Bus Mode Register 1
func (o *IIC0_Type) SetICMR1_BC(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x7)|value)
}
func (o *IIC0_Type) GetICMR1_BC() uint8 {
	return volatile.LoadUint8(&o.ICMR1.Reg) & 0x7
}
func (o *IIC0_Type) SetICMR1_BCWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICMR1_BCWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICMR1_CKS(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x70)|value<<4)
}
func (o *IIC0_Type) GetICMR1_CKS() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x70) >> 4
}
func (o *IIC0_Type) SetICMR1_MTWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR1_MTWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x80) >> 7
}

// IIC0.ICMR2: I2C Bus Mode Register 2
func (o *IIC0_Type) SetICMR2_TMOS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICMR2_TMOS() uint8 {
	return volatile.LoadUint8(&o.ICMR2.Reg) & 0x1
}
func (o *IIC0_Type) SetICMR2_TMOL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICMR2_TMOL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICMR2_TMOH(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICMR2_TMOH() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICMR2_SDDL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x70)|value<<4)
}
func (o *IIC0_Type) GetICMR2_SDDL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x70) >> 4
}
func (o *IIC0_Type) SetICMR2_DLCS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR2_DLCS() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x80) >> 7
}

// IIC0.ICMR3: I2C Bus Mode Register 3
func (o *IIC0_Type) SetICMR3_NF(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x3)|value)
}
func (o *IIC0_Type) GetICMR3_NF() uint8 {
	return volatile.LoadUint8(&o.ICMR3.Reg) & 0x3
}
func (o *IIC0_Type) SetICMR3_ACKBR(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICMR3_ACKBR() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICMR3_ACKBT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICMR3_ACKBT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICMR3_ACKWP(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICMR3_ACKWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICMR3_RDRFS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICMR3_RDRFS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICMR3_WAIT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICMR3_WAIT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICMR3_SMBS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR3_SMBS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x80) >> 7
}

// IIC0.ICFER: I2C Bus Function Enable Register
func (o *IIC0_Type) SetICFER_TMOE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICFER_TMOE() uint8 {
	return volatile.LoadUint8(&o.ICFER.Reg) & 0x1
}
func (o *IIC0_Type) SetICFER_MALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICFER_MALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICFER_NALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICFER_NALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICFER_SALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICFER_SALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICFER_NACKE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICFER_NACKE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICFER_NFE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICFER_NFE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICFER_SCLE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICFER_SCLE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x40) >> 6
}

// IIC0.ICSER: I2C Bus Status Enable Register
func (o *IIC0_Type) SetICSER_SAR0E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSER_SAR0E() uint8 {
	return volatile.LoadUint8(&o.ICSER.Reg) & 0x1
}
func (o *IIC0_Type) SetICSER_SAR1E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSER_SAR1E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSER_SAR2E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSER_SAR2E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSER_GCAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSER_GCAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSER_DIDE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSER_DIDE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSER_HOAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSER_HOAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x80) >> 7
}

// IIC0.ICIER: I2C Bus Interrupt Enable Register
func (o *IIC0_Type) SetICIER_TMOIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICIER_TMOIE() uint8 {
	return volatile.LoadUint8(&o.ICIER.Reg) & 0x1
}
func (o *IIC0_Type) SetICIER_ALIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICIER_ALIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICIER_STIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICIER_STIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICIER_SPIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICIER_SPIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICIER_NAKIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICIER_NAKIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICIER_RIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICIER_RIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICIER_TEIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICIER_TEIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICIER_TIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICIER_TIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x80) >> 7
}

// IIC0.ICSR1: I2C Bus Status Register 1
func (o *IIC0_Type) SetICSR1_AAS0(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSR1_AAS0() uint8 {
	return volatile.LoadUint8(&o.ICSR1.Reg) & 0x1
}
func (o *IIC0_Type) SetICSR1_AAS1(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSR1_AAS1() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSR1_AAS2(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSR1_AAS2() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSR1_GCA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSR1_GCA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSR1_DID(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSR1_DID() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSR1_HOA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSR1_HOA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x80) >> 7
}

// IIC0.ICSR2: I2C Bus Status Register 2
func (o *IIC0_Type) SetICSR2_TMOF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSR2_TMOF() uint8 {
	return volatile.LoadUint8(&o.ICSR2.Reg) & 0x1
}
func (o *IIC0_Type) SetICSR2_AL(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSR2_AL() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSR2_START(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSR2_START() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSR2_STOP(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSR2_STOP() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSR2_NACKF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICSR2_NACKF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICSR2_RDRF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSR2_RDRF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSR2_TEND(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICSR2_TEND() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICSR2_TDRE(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSR2_TDRE() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x80) >> 7
}

// IIC0.SARL0: Slave Address Register Ly
func (o *IIC0_Type) SetSARL0_SVA0(value uint8) {
	volatile.StoreUint8(&o.SARL0.Reg, volatile.LoadUint8(&o.SARL0.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARL0_SVA0() uint8 {
	return volatile.LoadUint8(&o.SARL0.Reg) & 0x1
}
func (o *IIC0_Type) SetSARL0_SVA(value uint8) {
	volatile.StoreUint8(&o.SARL0.Reg, volatile.LoadUint8(&o.SARL0.Reg)&^(0xfe)|value<<1)
}
func (o *IIC0_Type) GetSARL0_SVA() uint8 {
	return (volatile.LoadUint8(&o.SARL0.Reg) & 0xfe) >> 1
}

// IIC0.SARU0: Slave Address Register Uy
func (o *IIC0_Type) SetSARU0_FS(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU0_FS() uint8 {
	return volatile.LoadUint8(&o.SARU0.Reg) & 0x1
}
func (o *IIC0_Type) SetSARU0_SVA(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x6)|value<<1)
}
func (o *IIC0_Type) GetSARU0_SVA() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x6) >> 1
}

// IIC0.SARL1: Slave Address Register Ly
func (o *IIC0_Type) SetSARL1_SVA0(value uint8) {
	volatile.StoreUint8(&o.SARL1.Reg, volatile.LoadUint8(&o.SARL1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARL1_SVA0() uint8 {
	return volatile.LoadUint8(&o.SARL1.Reg) & 0x1
}
func (o *IIC0_Type) SetSARL1_SVA(value uint8) {
	volatile.StoreUint8(&o.SARL1.Reg, volatile.LoadUint8(&o.SARL1.Reg)&^(0xfe)|value<<1)
}
func (o *IIC0_Type) GetSARL1_SVA() uint8 {
	return (volatile.LoadUint8(&o.SARL1.Reg) & 0xfe) >> 1
}

// IIC0.SARU1: Slave Address Register Uy
func (o *IIC0_Type) SetSARU1_FS(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU1_FS() uint8 {
	return volatile.LoadUint8(&o.SARU1.Reg) & 0x1
}
func (o *IIC0_Type) SetSARU1_SVA(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x6)|value<<1)
}
func (o *IIC0_Type) GetSARU1_SVA() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x6) >> 1
}

// IIC0.SARL2: Slave Address Register Ly
func (o *IIC0_Type) SetSARL2_SVA0(value uint8) {
	volatile.StoreUint8(&o.SARL2.Reg, volatile.LoadUint8(&o.SARL2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARL2_SVA0() uint8 {
	return volatile.LoadUint8(&o.SARL2.Reg) & 0x1
}
func (o *IIC0_Type) SetSARL2_SVA(value uint8) {
	volatile.StoreUint8(&o.SARL2.Reg, volatile.LoadUint8(&o.SARL2.Reg)&^(0xfe)|value<<1)
}
func (o *IIC0_Type) GetSARL2_SVA() uint8 {
	return (volatile.LoadUint8(&o.SARL2.Reg) & 0xfe) >> 1
}

// IIC0.SARU2: Slave Address Register Uy
func (o *IIC0_Type) SetSARU2_FS(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU2_FS() uint8 {
	return volatile.LoadUint8(&o.SARU2.Reg) & 0x1
}
func (o *IIC0_Type) SetSARU2_SVA(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x6)|value<<1)
}
func (o *IIC0_Type) GetSARU2_SVA() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x6) >> 1
}

// IIC0.ICBRL: I2C Bus Bit Rate Low-Level Register
func (o *IIC0_Type) SetICBRL_BRL(value uint8) {
	volatile.StoreUint8(&o.ICBRL.Reg, volatile.LoadUint8(&o.ICBRL.Reg)&^(0x1f)|value)
}
func (o *IIC0_Type) GetICBRL_BRL() uint8 {
	return volatile.LoadUint8(&o.ICBRL.Reg) & 0x1f
}

// IIC0.ICBRH: I2C Bus Bit Rate High-Level Register
func (o *IIC0_Type) SetICBRH_BRH(value uint8) {
	volatile.StoreUint8(&o.ICBRH.Reg, volatile.LoadUint8(&o.ICBRH.Reg)&^(0x1f)|value)
}
func (o *IIC0_Type) GetICBRH_BRH() uint8 {
	return volatile.LoadUint8(&o.ICBRH.Reg) & 0x1f
}

// Inter-Integrated Circuit 0 Wake-up Unit
type IIC0WU_Type struct {
	_      [2]byte
	ICWUR  volatile.Register8 // 0x2
	ICWUR2 volatile.Register8 // 0x3
}

// IIC0WU.ICWUR: I2C Bus Wakeup Unit Register
func (o *IIC0WU_Type) SetICWUR_WUAFA(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x1)|value)
}
func (o *IIC0WU_Type) GetICWUR_WUAFA() uint8 {
	return volatile.LoadUint8(&o.ICWUR.Reg) & 0x1
}
func (o *IIC0WU_Type) SetICWUR_WUACK(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x10)|value<<4)
}
func (o *IIC0WU_Type) GetICWUR_WUACK() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x10) >> 4
}
func (o *IIC0WU_Type) SetICWUR_WUF(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x20)|value<<5)
}
func (o *IIC0WU_Type) GetICWUR_WUF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x20) >> 5
}
func (o *IIC0WU_Type) SetICWUR_WUIE(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x40)|value<<6)
}
func (o *IIC0WU_Type) GetICWUR_WUIE() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x40) >> 6
}
func (o *IIC0WU_Type) SetICWUR_WUE(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x80)|value<<7)
}
func (o *IIC0WU_Type) GetICWUR_WUE() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x80) >> 7
}

// IIC0WU.ICWUR2: I2C Bus Wakeup Unit Register 2
func (o *IIC0WU_Type) SetICWUR2_WUSEN(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x1)|value)
}
func (o *IIC0WU_Type) GetICWUR2_WUSEN() uint8 {
	return volatile.LoadUint8(&o.ICWUR2.Reg) & 0x1
}
func (o *IIC0WU_Type) SetICWUR2_WUASYF(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0WU_Type) GetICWUR2_WUASYF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR2.Reg) & 0x2) >> 1
}
func (o *IIC0WU_Type) SetICWUR2_WUSYF(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0WU_Type) GetICWUR2_WUSYF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR2.Reg) & 0x4) >> 2
}

// Data Operation Circuit
type DOC_Type struct {
	DOCR  volatile.Register8 // 0x0
	_     byte
	DODIR volatile.Register16 // 0x2
	DODSR volatile.Register16 // 0x4
}

// DOC.DOCR: DOC Control Register
func (o *DOC_Type) SetDOCR_OMS(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x3)|value)
}
func (o *DOC_Type) GetDOCR_OMS() uint8 {
	return volatile.LoadUint8(&o.DOCR.Reg) & 0x3
}
func (o *DOC_Type) SetDOCR_DCSEL(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x4)|value<<2)
}
func (o *DOC_Type) GetDOCR_DCSEL() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x4) >> 2
}
func (o *DOC_Type) SetDOCR_DOPCF(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x20)|value<<5)
}
func (o *DOC_Type) GetDOCR_DOPCF() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x20) >> 5
}
func (o *DOC_Type) SetDOCR_DOPCFCL(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x40)|value<<6)
}
func (o *DOC_Type) GetDOCR_DOPCFCL() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x40) >> 6
}

// 12-bit A/D Converter
type ADC120_Type struct {
	ADCSR      volatile.Register16 // 0x0
	_          [2]byte
	ADANSA0    volatile.Register16 // 0x4
	ADANSA1    volatile.Register16 // 0x6
	ADADS0     volatile.Register16 // 0x8
	ADADS1     volatile.Register16 // 0xA
	ADADC      volatile.Register8  // 0xC
	_          byte
	ADCER      volatile.Register16 // 0xE
	ADSTRGR    volatile.Register16 // 0x10
	ADEXICR    volatile.Register16 // 0x12
	ADANSB0    volatile.Register16 // 0x14
	ADANSB1    volatile.Register16 // 0x16
	ADDBLDR    volatile.Register16 // 0x18
	ADTSDR     volatile.Register16 // 0x1A
	ADOCDR     volatile.Register16 // 0x1C
	ADRD       volatile.Register16 // 0x1E
	ADDR0      volatile.Register16 // 0x20
	ADDR1      volatile.Register16 // 0x22
	ADDR2      volatile.Register16 // 0x24
	ADDR3      volatile.Register16 // 0x26
	ADDR4      volatile.Register16 // 0x28
	ADDR5      volatile.Register16 // 0x2A
	ADDR6      volatile.Register16 // 0x2C
	ADDR7      volatile.Register16 // 0x2E
	ADDR8      volatile.Register16 // 0x30
	ADDR9      volatile.Register16 // 0x32
	ADDR10     volatile.Register16 // 0x34
	ADDR11     volatile.Register16 // 0x36
	ADDR12     volatile.Register16 // 0x38
	ADDR13     volatile.Register16 // 0x3A
	ADDR14     volatile.Register16 // 0x3C
	_          [2]byte
	ADCTDR     volatile.Register16 // 0x40
	ADDR17     volatile.Register16 // 0x42
	ADDR18     volatile.Register16 // 0x44
	ADDR19     volatile.Register16 // 0x46
	ADDR20     volatile.Register16 // 0x48
	_          [48]byte
	ADDISCR    volatile.Register8 // 0x7A
	_          [3]byte
	ADACSR     volatile.Register8 // 0x7E
	_          byte
	ADGSPCR    volatile.Register16 // 0x80
	_          [2]byte
	ADDBLDRA   volatile.Register16 // 0x84
	ADDBLDRB   volatile.Register16 // 0x86
	_          [2]byte
	ADHVREFCNT volatile.Register8 // 0x8A
	_          byte
	ADWINMON   volatile.Register8 // 0x8C
	_          [3]byte
	ADCMPCR    volatile.Register16 // 0x90
	ADCMPANSER volatile.Register8  // 0x92
	ADCMPLER   volatile.Register8  // 0x93
	ADCMPANSR0 volatile.Register16 // 0x94
	ADCMPANSR1 volatile.Register16 // 0x96
	ADCMPLR0   volatile.Register16 // 0x98
	ADCMPLR1   volatile.Register16 // 0x9A
	ADCMPDR0   volatile.Register16 // 0x9C
	ADCMPDR1   volatile.Register16 // 0x9E
	ADCMPSR0   volatile.Register16 // 0xA0
	ADCMPSR1   volatile.Register16 // 0xA2
	ADCMPSER   volatile.Register8  // 0xA4
	_          byte
	ADCMPBNSR  volatile.Register8 // 0xA6
	_          byte
	ADWINLLB   volatile.Register16 // 0xA8
	ADWINULB   volatile.Register16 // 0xAA
	ADCMPBSR   volatile.Register8  // 0xAC
	_          [48]byte
	ADSSTRL    volatile.Register8 // 0xDD
	ADSSTRT    volatile.Register8 // 0xDE
	ADSSTRO    volatile.Register8 // 0xDF
	ADSSTR0    volatile.Register8 // 0xE0
	ADSSTR1    volatile.Register8 // 0xE1
	ADSSTR2    volatile.Register8 // 0xE2
	ADSSTR3    volatile.Register8 // 0xE3
	ADSSTR4    volatile.Register8 // 0xE4
	ADSSTR5    volatile.Register8 // 0xE5
	ADSSTR6    volatile.Register8 // 0xE6
	ADSSTR7    volatile.Register8 // 0xE7
	ADSSTR8    volatile.Register8 // 0xE8
	ADSSTR9    volatile.Register8 // 0xE9
	ADSSTR10   volatile.Register8 // 0xEA
	ADSSTR11   volatile.Register8 // 0xEB
	ADSSTR12   volatile.Register8 // 0xEC
	ADSSTR13   volatile.Register8 // 0xED
	ADSSTR14   volatile.Register8 // 0xEE
}

// ADC120.ADCSR: A/D Control Register
func (o *ADC120_Type) SetADCSR_DBLANS(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x1f)|value)
}
func (o *ADC120_Type) GetADCSR_DBLANS() uint16 {
	return volatile.LoadUint16(&o.ADCSR.Reg) & 0x1f
}
func (o *ADC120_Type) SetADCSR_GBADIE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCSR_GBADIE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCSR_DBLE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCSR_DBLE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCSR_EXTRG(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADCSR_EXTRG() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADCSR_TRGE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADCSR_TRGE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADCSR_ADHSC(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADCSR_ADHSC() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADCSR_ADCS(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x6000)|value<<13)
}
func (o *ADC120_Type) GetADCSR_ADCS() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x6000) >> 13
}
func (o *ADC120_Type) SetADCSR_ADST(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCSR_ADST() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x8000) >> 15
}

// ADC120.ADANSA0: A/D Channel Select Register A0
func (o *ADC120_Type) SetADANSA0_ANSA00(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADANSA0_ANSA00() uint16 {
	return volatile.LoadUint16(&o.ADANSA0.Reg) & 0x1
}
func (o *ADC120_Type) SetADANSA0_ANSA01(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADANSA0_ANSA01() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADANSA0_ANSA02(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADANSA0_ANSA02() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADANSA0_ANSA03(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADANSA0_ANSA03() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADANSA0_ANSA04(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADANSA0_ANSA04() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADANSA0_ANSA05(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADANSA0_ANSA05() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADANSA0_ANSA06(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADANSA0_ANSA06() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADANSA0_ANSA07(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADANSA0_ANSA07() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADANSA0_ANSA08(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADANSA0_ANSA08() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADANSA0_ANSA09(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADANSA0_ANSA09() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADANSA0_ANSA10(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADANSA0_ANSA10() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADANSA0_ANSA11(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADANSA0_ANSA11() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADANSA0_ANSA12(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADANSA0_ANSA12() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADANSA0_ANSA13(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADANSA0_ANSA13() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADANSA0_ANSA14(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADANSA0_ANSA14() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADANSA0_ANSA15(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADANSA0_ANSA15() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x8000) >> 15
}

// ADC120.ADANSA1: A/D Channel Select Register A1
func (o *ADC120_Type) SetADANSA1_ANSA16(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADANSA1_ANSA16() uint16 {
	return volatile.LoadUint16(&o.ADANSA1.Reg) & 0x1
}
func (o *ADC120_Type) SetADANSA1_ANSA17(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADANSA1_ANSA17() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADANSA1_ANSA18(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADANSA1_ANSA18() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADANSA1_ANSA19(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADANSA1_ANSA19() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADANSA1_ANSA20(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADANSA1_ANSA20() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADANSA1_ANSA21(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADANSA1_ANSA21() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADANSA1_ANSA22(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADANSA1_ANSA22() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADANSA1_ANSA23(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADANSA1_ANSA23() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADANSA1_ANSA24(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADANSA1_ANSA24() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADANSA1_ANSA25(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADANSA1_ANSA25() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADANSA1_ANSA26(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADANSA1_ANSA26() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADANSA1_ANSA27(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADANSA1_ANSA27() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADANSA1_ANSA28(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADANSA1_ANSA28() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADANSA1_ANSA29(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADANSA1_ANSA29() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADANSA1_ANSA30(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADANSA1_ANSA30() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADANSA1_ANSA31(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADANSA1_ANSA31() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x8000) >> 15
}

// ADC120.ADADS0: A/D-Converted Value Addition/Average Channel Select Register 0
func (o *ADC120_Type) SetADADS0_ADS00(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADADS0_ADS00() uint16 {
	return volatile.LoadUint16(&o.ADADS0.Reg) & 0x1
}
func (o *ADC120_Type) SetADADS0_ADS01(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADADS0_ADS01() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADADS0_ADS02(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADADS0_ADS02() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADADS0_ADS03(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADADS0_ADS03() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADADS0_ADS04(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADADS0_ADS04() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADADS0_ADS05(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADADS0_ADS05() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADADS0_ADS06(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADADS0_ADS06() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADADS0_ADS07(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADADS0_ADS07() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADADS0_ADS08(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADADS0_ADS08() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADADS0_ADS09(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADADS0_ADS09() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADADS0_ADS10(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADADS0_ADS10() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADADS0_ADS11(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADADS0_ADS11() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADADS0_ADS12(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADADS0_ADS12() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADADS0_ADS13(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADADS0_ADS13() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADADS0_ADS14(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADADS0_ADS14() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADADS0_ADS15(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADADS0_ADS15() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x8000) >> 15
}

// ADC120.ADADS1: A/D-Converted Value Addition/Average Channel Select Register 1
func (o *ADC120_Type) SetADADS1_ADS16(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADADS1_ADS16() uint16 {
	return volatile.LoadUint16(&o.ADADS1.Reg) & 0x1
}
func (o *ADC120_Type) SetADADS1_ADS17(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADADS1_ADS17() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADADS1_ADS18(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADADS1_ADS18() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADADS1_ADS19(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADADS1_ADS19() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADADS1_ADS20(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADADS1_ADS20() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADADS1_ADS21(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADADS1_ADS21() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADADS1_ADS22(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADADS1_ADS22() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADADS1_ADS23(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADADS1_ADS23() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADADS1_ADS24(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADADS1_ADS24() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADADS1_ADS25(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADADS1_ADS25() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADADS1_ADS26(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADADS1_ADS26() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADADS1_ADS27(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADADS1_ADS27() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADADS1_ADS28(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADADS1_ADS28() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADADS1_ADS29(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADADS1_ADS29() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADADS1_ADS30(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADADS1_ADS30() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADADS1_ADS31(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADADS1_ADS31() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x8000) >> 15
}

// ADC120.ADADC: A/D-Converted Value Addition/Average Count Select Register
func (o *ADC120_Type) SetADADC_ADC(value uint8) {
	volatile.StoreUint8(&o.ADADC.Reg, volatile.LoadUint8(&o.ADADC.Reg)&^(0x7)|value)
}
func (o *ADC120_Type) GetADADC_ADC() uint8 {
	return volatile.LoadUint8(&o.ADADC.Reg) & 0x7
}
func (o *ADC120_Type) SetADADC_AVEE(value uint8) {
	volatile.StoreUint8(&o.ADADC.Reg, volatile.LoadUint8(&o.ADADC.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADADC_AVEE() uint8 {
	return (volatile.LoadUint8(&o.ADADC.Reg) & 0x80) >> 7
}

// ADC120.ADCER: A/D Control Extended Register
func (o *ADC120_Type) SetADCER_ACE(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCER_ACE() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCER_DIAGVAL(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x300)|value<<8)
}
func (o *ADC120_Type) GetADCER_DIAGVAL() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x300) >> 8
}
func (o *ADC120_Type) SetADCER_DIAGLD(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADCER_DIAGLD() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADCER_DIAGM(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADCER_DIAGM() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADCER_ADRFMT(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCER_ADRFMT() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x8000) >> 15
}

// ADC120.ADSTRGR: A/D Conversion Start Trigger Select Register
func (o *ADC120_Type) SetADSTRGR_TRSB(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0x3f)|value)
}
func (o *ADC120_Type) GetADSTRGR_TRSB() uint16 {
	return volatile.LoadUint16(&o.ADSTRGR.Reg) & 0x3f
}
func (o *ADC120_Type) SetADSTRGR_TRSA(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0x3f00)|value<<8)
}
func (o *ADC120_Type) GetADSTRGR_TRSA() uint16 {
	return (volatile.LoadUint16(&o.ADSTRGR.Reg) & 0x3f00) >> 8
}

// ADC120.ADEXICR: A/D Conversion Extended Input Control Registers
func (o *ADC120_Type) SetADEXICR_TSSAD(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADEXICR_TSSAD() uint16 {
	return volatile.LoadUint16(&o.ADEXICR.Reg) & 0x1
}
func (o *ADC120_Type) SetADEXICR_OCSAD(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADEXICR_OCSAD() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADEXICR_TSSA(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADEXICR_TSSA() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADEXICR_OCSA(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADEXICR_OCSA() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x200) >> 9
}

// ADC120.ADANSB0: A/D Channel Select Register B0
func (o *ADC120_Type) SetADANSB0_ANSB00(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADANSB0_ANSB00() uint16 {
	return volatile.LoadUint16(&o.ADANSB0.Reg) & 0x1
}
func (o *ADC120_Type) SetADANSB0_ANSB01(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADANSB0_ANSB01() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADANSB0_ANSB02(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADANSB0_ANSB02() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADANSB0_ANSB03(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADANSB0_ANSB03() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADANSB0_ANSB04(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADANSB0_ANSB04() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADANSB0_ANSB05(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADANSB0_ANSB05() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADANSB0_ANSB06(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADANSB0_ANSB06() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADANSB0_ANSB07(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADANSB0_ANSB07() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADANSB0_ANSB08(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADANSB0_ANSB08() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADANSB0_ANSB09(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADANSB0_ANSB09() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADANSB0_ANSB10(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADANSB0_ANSB10() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADANSB0_ANSB11(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADANSB0_ANSB11() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADANSB0_ANSB12(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADANSB0_ANSB12() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADANSB0_ANSB13(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADANSB0_ANSB13() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADANSB0_ANSB14(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADANSB0_ANSB14() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADANSB0_ANSB15(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADANSB0_ANSB15() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x8000) >> 15
}

// ADC120.ADANSB1: A/D Channel Select Register B1
func (o *ADC120_Type) SetADANSB1_ANSB16(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADANSB1_ANSB16() uint16 {
	return volatile.LoadUint16(&o.ADANSB1.Reg) & 0x1
}
func (o *ADC120_Type) SetADANSB1_ANSB17(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADANSB1_ANSB17() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADANSB1_ANSB18(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADANSB1_ANSB18() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADANSB1_ANSB19(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADANSB1_ANSB19() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADANSB1_ANSB20(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADANSB1_ANSB20() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADANSB1_ANSB21(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADANSB1_ANSB21() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADANSB1_ANSB22(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADANSB1_ANSB22() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADANSB1_ANSB23(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADANSB1_ANSB23() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADANSB1_ANSB24(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADANSB1_ANSB24() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADANSB1_ANSB25(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADANSB1_ANSB25() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADANSB1_ANSB26(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADANSB1_ANSB26() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADANSB1_ANSB27(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADANSB1_ANSB27() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADANSB1_ANSB28(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADANSB1_ANSB28() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADANSB1_ANSB29(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADANSB1_ANSB29() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADANSB1_ANSB30(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADANSB1_ANSB30() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADANSB1_ANSB31(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADANSB1_ANSB31() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x8000) >> 15
}

// ADC120.ADDBLDR: A/D Data Duplexing Register
func (o *ADC120_Type) SetADDBLDR(value uint16) {
	volatile.StoreUint16(&o.ADDBLDR.Reg, value)
}
func (o *ADC120_Type) GetADDBLDR() uint16 {
	return volatile.LoadUint16(&o.ADDBLDR.Reg)
}

// ADC120.ADTSDR: A/D Temperature Sensor Data Register
func (o *ADC120_Type) SetADTSDR(value uint16) {
	volatile.StoreUint16(&o.ADTSDR.Reg, value)
}
func (o *ADC120_Type) GetADTSDR() uint16 {
	return volatile.LoadUint16(&o.ADTSDR.Reg)
}

// ADC120.ADOCDR: A/D Internal Reference Voltage Data Register
func (o *ADC120_Type) SetADOCDR(value uint16) {
	volatile.StoreUint16(&o.ADOCDR.Reg, value)
}
func (o *ADC120_Type) GetADOCDR() uint16 {
	return volatile.LoadUint16(&o.ADOCDR.Reg)
}

// ADC120.ADRD: A/D Self-Diagnosis Data Register
func (o *ADC120_Type) SetADRD_AD(value uint16) {
	volatile.StoreUint16(&o.ADRD.Reg, volatile.LoadUint16(&o.ADRD.Reg)&^(0xfff)|value)
}
func (o *ADC120_Type) GetADRD_AD() uint16 {
	return volatile.LoadUint16(&o.ADRD.Reg) & 0xfff
}
func (o *ADC120_Type) SetADRD_DIAGST(value uint16) {
	volatile.StoreUint16(&o.ADRD.Reg, volatile.LoadUint16(&o.ADRD.Reg)&^(0xc000)|value<<14)
}
func (o *ADC120_Type) GetADRD_DIAGST() uint16 {
	return (volatile.LoadUint16(&o.ADRD.Reg) & 0xc000) >> 14
}

// ADC120.ADDR0: A/D Data Registers %s
func (o *ADC120_Type) SetADDR0(value uint16) {
	volatile.StoreUint16(&o.ADDR0.Reg, value)
}
func (o *ADC120_Type) GetADDR0() uint16 {
	return volatile.LoadUint16(&o.ADDR0.Reg)
}

// ADC120.ADDR1: A/D Data Registers %s
func (o *ADC120_Type) SetADDR1(value uint16) {
	volatile.StoreUint16(&o.ADDR1.Reg, value)
}
func (o *ADC120_Type) GetADDR1() uint16 {
	return volatile.LoadUint16(&o.ADDR1.Reg)
}

// ADC120.ADDR2: A/D Data Registers %s
func (o *ADC120_Type) SetADDR2(value uint16) {
	volatile.StoreUint16(&o.ADDR2.Reg, value)
}
func (o *ADC120_Type) GetADDR2() uint16 {
	return volatile.LoadUint16(&o.ADDR2.Reg)
}

// ADC120.ADDR3: A/D Data Registers %s
func (o *ADC120_Type) SetADDR3(value uint16) {
	volatile.StoreUint16(&o.ADDR3.Reg, value)
}
func (o *ADC120_Type) GetADDR3() uint16 {
	return volatile.LoadUint16(&o.ADDR3.Reg)
}

// ADC120.ADDR4: A/D Data Registers %s
func (o *ADC120_Type) SetADDR4(value uint16) {
	volatile.StoreUint16(&o.ADDR4.Reg, value)
}
func (o *ADC120_Type) GetADDR4() uint16 {
	return volatile.LoadUint16(&o.ADDR4.Reg)
}

// ADC120.ADDR5: A/D Data Registers %s
func (o *ADC120_Type) SetADDR5(value uint16) {
	volatile.StoreUint16(&o.ADDR5.Reg, value)
}
func (o *ADC120_Type) GetADDR5() uint16 {
	return volatile.LoadUint16(&o.ADDR5.Reg)
}

// ADC120.ADDR6: A/D Data Registers %s
func (o *ADC120_Type) SetADDR6(value uint16) {
	volatile.StoreUint16(&o.ADDR6.Reg, value)
}
func (o *ADC120_Type) GetADDR6() uint16 {
	return volatile.LoadUint16(&o.ADDR6.Reg)
}

// ADC120.ADDR7: A/D Data Registers %s
func (o *ADC120_Type) SetADDR7(value uint16) {
	volatile.StoreUint16(&o.ADDR7.Reg, value)
}
func (o *ADC120_Type) GetADDR7() uint16 {
	return volatile.LoadUint16(&o.ADDR7.Reg)
}

// ADC120.ADDR8: A/D Data Registers %s
func (o *ADC120_Type) SetADDR8(value uint16) {
	volatile.StoreUint16(&o.ADDR8.Reg, value)
}
func (o *ADC120_Type) GetADDR8() uint16 {
	return volatile.LoadUint16(&o.ADDR8.Reg)
}

// ADC120.ADDR9: A/D Data Registers %s
func (o *ADC120_Type) SetADDR9(value uint16) {
	volatile.StoreUint16(&o.ADDR9.Reg, value)
}
func (o *ADC120_Type) GetADDR9() uint16 {
	return volatile.LoadUint16(&o.ADDR9.Reg)
}

// ADC120.ADDR10: A/D Data Registers %s
func (o *ADC120_Type) SetADDR10(value uint16) {
	volatile.StoreUint16(&o.ADDR10.Reg, value)
}
func (o *ADC120_Type) GetADDR10() uint16 {
	return volatile.LoadUint16(&o.ADDR10.Reg)
}

// ADC120.ADDR11: A/D Data Registers %s
func (o *ADC120_Type) SetADDR11(value uint16) {
	volatile.StoreUint16(&o.ADDR11.Reg, value)
}
func (o *ADC120_Type) GetADDR11() uint16 {
	return volatile.LoadUint16(&o.ADDR11.Reg)
}

// ADC120.ADDR12: A/D Data Registers %s
func (o *ADC120_Type) SetADDR12(value uint16) {
	volatile.StoreUint16(&o.ADDR12.Reg, value)
}
func (o *ADC120_Type) GetADDR12() uint16 {
	return volatile.LoadUint16(&o.ADDR12.Reg)
}

// ADC120.ADDR13: A/D Data Registers %s
func (o *ADC120_Type) SetADDR13(value uint16) {
	volatile.StoreUint16(&o.ADDR13.Reg, value)
}
func (o *ADC120_Type) GetADDR13() uint16 {
	return volatile.LoadUint16(&o.ADDR13.Reg)
}

// ADC120.ADDR14: A/D Data Registers %s
func (o *ADC120_Type) SetADDR14(value uint16) {
	volatile.StoreUint16(&o.ADDR14.Reg, value)
}
func (o *ADC120_Type) GetADDR14() uint16 {
	return volatile.LoadUint16(&o.ADDR14.Reg)
}

// ADC120.ADCTDR: A/D CTSU TSCAP Voltage Data Register
func (o *ADC120_Type) SetADCTDR(value uint16) {
	volatile.StoreUint16(&o.ADCTDR.Reg, value)
}
func (o *ADC120_Type) GetADCTDR() uint16 {
	return volatile.LoadUint16(&o.ADCTDR.Reg)
}

// ADC120.ADDR17: A/D Data Registers %s
func (o *ADC120_Type) SetADDR17(value uint16) {
	volatile.StoreUint16(&o.ADDR17.Reg, value)
}
func (o *ADC120_Type) GetADDR17() uint16 {
	return volatile.LoadUint16(&o.ADDR17.Reg)
}

// ADC120.ADDR18: A/D Data Registers %s
func (o *ADC120_Type) SetADDR18(value uint16) {
	volatile.StoreUint16(&o.ADDR18.Reg, value)
}
func (o *ADC120_Type) GetADDR18() uint16 {
	return volatile.LoadUint16(&o.ADDR18.Reg)
}

// ADC120.ADDR19: A/D Data Registers %s
func (o *ADC120_Type) SetADDR19(value uint16) {
	volatile.StoreUint16(&o.ADDR19.Reg, value)
}
func (o *ADC120_Type) GetADDR19() uint16 {
	return volatile.LoadUint16(&o.ADDR19.Reg)
}

// ADC120.ADDR20: A/D Data Registers %s
func (o *ADC120_Type) SetADDR20(value uint16) {
	volatile.StoreUint16(&o.ADDR20.Reg, value)
}
func (o *ADC120_Type) GetADDR20() uint16 {
	return volatile.LoadUint16(&o.ADDR20.Reg)
}

// ADC120.ADDISCR: A/D Disconnection Detection Control Register
func (o *ADC120_Type) SetADDISCR_ADNDIS(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0xf)|value)
}
func (o *ADC120_Type) GetADDISCR_ADNDIS() uint8 {
	return volatile.LoadUint8(&o.ADDISCR.Reg) & 0xf
}
func (o *ADC120_Type) SetADDISCR_PCHG(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADDISCR_PCHG() uint8 {
	return (volatile.LoadUint8(&o.ADDISCR.Reg) & 0x10) >> 4
}

// ADC120.ADACSR: A/D Conversion Operation Mode Select Register
func (o *ADC120_Type) SetADACSR_ADSAC(value uint8) {
	volatile.StoreUint8(&o.ADACSR.Reg, volatile.LoadUint8(&o.ADACSR.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADACSR_ADSAC() uint8 {
	return (volatile.LoadUint8(&o.ADACSR.Reg) & 0x2) >> 1
}

// ADC120.ADGSPCR: A/D Group Scan Priority Control Register
func (o *ADC120_Type) SetADGSPCR_PGS(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADGSPCR_PGS() uint16 {
	return volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x1
}
func (o *ADC120_Type) SetADGSPCR_GBRSCN(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADGSPCR_GBRSCN() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADGSPCR_GBRP(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADGSPCR_GBRP() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x8000) >> 15
}

// ADC120.ADDBLDRA: A/D Data Duplexing Register A
func (o *ADC120_Type) SetADDBLDRA(value uint16) {
	volatile.StoreUint16(&o.ADDBLDRA.Reg, value)
}
func (o *ADC120_Type) GetADDBLDRA() uint16 {
	return volatile.LoadUint16(&o.ADDBLDRA.Reg)
}

// ADC120.ADDBLDRB: A/D Data Duplexing Register B
func (o *ADC120_Type) SetADDBLDRB(value uint16) {
	volatile.StoreUint16(&o.ADDBLDRB.Reg, value)
}
func (o *ADC120_Type) GetADDBLDRB() uint16 {
	return volatile.LoadUint16(&o.ADDBLDRB.Reg)
}

// ADC120.ADHVREFCNT: A/D High-Potential/Low-Potential Reference Voltage Control Register
func (o *ADC120_Type) SetADHVREFCNT_HVSEL(value uint8) {
	volatile.StoreUint8(&o.ADHVREFCNT.Reg, volatile.LoadUint8(&o.ADHVREFCNT.Reg)&^(0x3)|value)
}
func (o *ADC120_Type) GetADHVREFCNT_HVSEL() uint8 {
	return volatile.LoadUint8(&o.ADHVREFCNT.Reg) & 0x3
}
func (o *ADC120_Type) SetADHVREFCNT_LVSEL(value uint8) {
	volatile.StoreUint8(&o.ADHVREFCNT.Reg, volatile.LoadUint8(&o.ADHVREFCNT.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADHVREFCNT_LVSEL() uint8 {
	return (volatile.LoadUint8(&o.ADHVREFCNT.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADHVREFCNT_ADSLP(value uint8) {
	volatile.StoreUint8(&o.ADHVREFCNT.Reg, volatile.LoadUint8(&o.ADHVREFCNT.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADHVREFCNT_ADSLP() uint8 {
	return (volatile.LoadUint8(&o.ADHVREFCNT.Reg) & 0x80) >> 7
}

// ADC120.ADWINMON: A/D Compare Function Window A/B Status Monitor Register
func (o *ADC120_Type) SetADWINMON_MONCOMB(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADWINMON_MONCOMB() uint8 {
	return volatile.LoadUint8(&o.ADWINMON.Reg) & 0x1
}
func (o *ADC120_Type) SetADWINMON_MONCMPA(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADWINMON_MONCMPA() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADWINMON_MONCMPB(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADWINMON_MONCMPB() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0x20) >> 5
}

// ADC120.ADCMPCR: A/D Compare Function Control Register
func (o *ADC120_Type) SetADCMPCR_CMPAB(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x3)|value)
}
func (o *ADC120_Type) GetADCMPCR_CMPAB() uint16 {
	return volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x3
}
func (o *ADC120_Type) SetADCMPCR_CMPBE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADCMPCR_CMPBE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADCMPCR_CMPAE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADCMPCR_CMPAE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADCMPCR_CMPBIE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADCMPCR_CMPBIE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADCMPCR_WCMPE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADCMPCR_WCMPE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADCMPCR_CMPAIE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCMPCR_CMPAIE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x8000) >> 15
}

// ADC120.ADCMPANSER: A/D Compare Function Window A Extended Input Select Register
func (o *ADC120_Type) SetADCMPANSER_CMPTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPANSER.Reg, volatile.LoadUint8(&o.ADCMPANSER.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPANSER_CMPTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPANSER.Reg) & 0x1
}
func (o *ADC120_Type) SetADCMPANSER_CMPOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPANSER.Reg, volatile.LoadUint8(&o.ADCMPANSER.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPANSER_CMPOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPANSER.Reg) & 0x2) >> 1
}

// ADC120.ADCMPLER: A/D Compare Function Window A Extended Input Comparison Condition Setting Register
func (o *ADC120_Type) SetADCMPLER_CMPLTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPLER.Reg, volatile.LoadUint8(&o.ADCMPLER.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPLER_CMPLTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPLER.Reg) & 0x1
}
func (o *ADC120_Type) SetADCMPLER_CMPLOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPLER.Reg, volatile.LoadUint8(&o.ADCMPLER.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPLER_CMPLOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPLER.Reg) & 0x2) >> 1
}

// ADC120.ADCMPANSR0: A/D Compare Function Window A Channel Select Register 0
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x1
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA04(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA04() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA08(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA08() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA09(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA09() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA10(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA10() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA11(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA11() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA12(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA12() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA13(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA13() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA14(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA14() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA15(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA15() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x8000) >> 15
}

// ADC120.ADCMPANSR1: A/D Compare Function Window A Channel Select Register 1
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x1
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA20(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA20() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA21(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA21() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA22(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA22() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA23(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA23() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA24(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA24() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA25(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA25() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA26(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA26() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA27(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA27() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA28(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA28() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA29(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA29() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA30(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA30() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA31(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA31() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x8000) >> 15
}

// ADC120.ADCMPLR0: A/D Compare Function Window A Comparison Condition Setting Register 0
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x1
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA04(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA04() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA08(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA08() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA09(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA09() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA10(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA10() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA11(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA11() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA12(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA12() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA13(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA13() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA14(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA14() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA15(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA15() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x8000) >> 15
}

// ADC120.ADCMPLR1: A/D Compare Function Window A Comparison Condition Setting Register 1
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x1
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA20(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA20() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA21(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA21() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA22(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA22() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA23(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA23() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA24(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA24() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA25(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA25() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA26(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA26() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA27(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA27() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA28(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA28() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA29(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA29() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA30(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA30() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA31(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA31() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x8000) >> 15
}

// ADC120.ADCMPSR0: A/D Compare Function Window A Channel Status Register 0
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x1
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA04(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA04() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA08(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA08() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA09(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA09() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA10(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA10() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA11(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA11() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA12(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA12() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA13(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA13() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA14(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA14() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA15(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA15() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x8000) >> 15
}

// ADC120.ADCMPSR1: A/D Compare Function Window A Channel Status Register1
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x1
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA20(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA20() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA21(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA21() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA22(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA22() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA23(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA23() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA24(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA24() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA25(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA25() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA26(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA26() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA27(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA27() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA28(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA28() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA29(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA29() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA30(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA30() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA31(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA31() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x8000) >> 15
}

// ADC120.ADCMPSER: A/D Compare Function Window A Extended Input Channel Status Register
func (o *ADC120_Type) SetADCMPSER_CMPSTTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPSER.Reg, volatile.LoadUint8(&o.ADCMPSER.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPSER_CMPSTTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPSER.Reg) & 0x1
}
func (o *ADC120_Type) SetADCMPSER_CMPSTOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPSER.Reg, volatile.LoadUint8(&o.ADCMPSER.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPSER_CMPSTOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPSER.Reg) & 0x2) >> 1
}

// ADC120.ADCMPBNSR: A/D Compare Function Window B Channel Select Register
func (o *ADC120_Type) SetADCMPBNSR_CMPCHB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x3f)|value)
}
func (o *ADC120_Type) GetADCMPBNSR_CMPCHB() uint8 {
	return volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x3f
}
func (o *ADC120_Type) SetADCMPBNSR_CMPLB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPBNSR_CMPLB() uint8 {
	return (volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x80) >> 7
}

// ADC120.ADCMPBSR: A/D Compare Function Window B Status Register
func (o *ADC120_Type) SetADCMPBSR_CMPSTB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBSR.Reg, volatile.LoadUint8(&o.ADCMPBSR.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPBSR_CMPSTB() uint8 {
	return volatile.LoadUint8(&o.ADCMPBSR.Reg) & 0x1
}

// ADC120.ADSSTRL: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTRL(value uint8) {
	volatile.StoreUint8(&o.ADSSTRL.Reg, value)
}
func (o *ADC120_Type) GetADSSTRL() uint8 {
	return volatile.LoadUint8(&o.ADSSTRL.Reg)
}

// ADC120.ADSSTRT: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTRT(value uint8) {
	volatile.StoreUint8(&o.ADSSTRT.Reg, value)
}
func (o *ADC120_Type) GetADSSTRT() uint8 {
	return volatile.LoadUint8(&o.ADSSTRT.Reg)
}

// ADC120.ADSSTRO: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTRO(value uint8) {
	volatile.StoreUint8(&o.ADSSTRO.Reg, value)
}
func (o *ADC120_Type) GetADSSTRO() uint8 {
	return volatile.LoadUint8(&o.ADSSTRO.Reg)
}

// ADC120.ADSSTR0: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR0(value uint8) {
	volatile.StoreUint8(&o.ADSSTR0.Reg, value)
}
func (o *ADC120_Type) GetADSSTR0() uint8 {
	return volatile.LoadUint8(&o.ADSSTR0.Reg)
}

// ADC120.ADSSTR1: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR1(value uint8) {
	volatile.StoreUint8(&o.ADSSTR1.Reg, value)
}
func (o *ADC120_Type) GetADSSTR1() uint8 {
	return volatile.LoadUint8(&o.ADSSTR1.Reg)
}

// ADC120.ADSSTR2: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR2(value uint8) {
	volatile.StoreUint8(&o.ADSSTR2.Reg, value)
}
func (o *ADC120_Type) GetADSSTR2() uint8 {
	return volatile.LoadUint8(&o.ADSSTR2.Reg)
}

// ADC120.ADSSTR3: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR3(value uint8) {
	volatile.StoreUint8(&o.ADSSTR3.Reg, value)
}
func (o *ADC120_Type) GetADSSTR3() uint8 {
	return volatile.LoadUint8(&o.ADSSTR3.Reg)
}

// ADC120.ADSSTR4: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR4(value uint8) {
	volatile.StoreUint8(&o.ADSSTR4.Reg, value)
}
func (o *ADC120_Type) GetADSSTR4() uint8 {
	return volatile.LoadUint8(&o.ADSSTR4.Reg)
}

// ADC120.ADSSTR5: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR5(value uint8) {
	volatile.StoreUint8(&o.ADSSTR5.Reg, value)
}
func (o *ADC120_Type) GetADSSTR5() uint8 {
	return volatile.LoadUint8(&o.ADSSTR5.Reg)
}

// ADC120.ADSSTR6: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR6(value uint8) {
	volatile.StoreUint8(&o.ADSSTR6.Reg, value)
}
func (o *ADC120_Type) GetADSSTR6() uint8 {
	return volatile.LoadUint8(&o.ADSSTR6.Reg)
}

// ADC120.ADSSTR7: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR7(value uint8) {
	volatile.StoreUint8(&o.ADSSTR7.Reg, value)
}
func (o *ADC120_Type) GetADSSTR7() uint8 {
	return volatile.LoadUint8(&o.ADSSTR7.Reg)
}

// ADC120.ADSSTR8: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR8(value uint8) {
	volatile.StoreUint8(&o.ADSSTR8.Reg, value)
}
func (o *ADC120_Type) GetADSSTR8() uint8 {
	return volatile.LoadUint8(&o.ADSSTR8.Reg)
}

// ADC120.ADSSTR9: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR9(value uint8) {
	volatile.StoreUint8(&o.ADSSTR9.Reg, value)
}
func (o *ADC120_Type) GetADSSTR9() uint8 {
	return volatile.LoadUint8(&o.ADSSTR9.Reg)
}

// ADC120.ADSSTR10: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR10(value uint8) {
	volatile.StoreUint8(&o.ADSSTR10.Reg, value)
}
func (o *ADC120_Type) GetADSSTR10() uint8 {
	return volatile.LoadUint8(&o.ADSSTR10.Reg)
}

// ADC120.ADSSTR11: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR11(value uint8) {
	volatile.StoreUint8(&o.ADSSTR11.Reg, value)
}
func (o *ADC120_Type) GetADSSTR11() uint8 {
	return volatile.LoadUint8(&o.ADSSTR11.Reg)
}

// ADC120.ADSSTR12: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR12(value uint8) {
	volatile.StoreUint8(&o.ADSSTR12.Reg, value)
}
func (o *ADC120_Type) GetADSSTR12() uint8 {
	return volatile.LoadUint8(&o.ADSSTR12.Reg)
}

// ADC120.ADSSTR13: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR13(value uint8) {
	volatile.StoreUint8(&o.ADSSTR13.Reg, value)
}
func (o *ADC120_Type) GetADSSTR13() uint8 {
	return volatile.LoadUint8(&o.ADSSTR13.Reg)
}

// ADC120.ADSSTR14: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR14(value uint8) {
	volatile.StoreUint8(&o.ADSSTR14.Reg, value)
}
func (o *ADC120_Type) GetADSSTR14() uint8 {
	return volatile.LoadUint8(&o.ADSSTR14.Reg)
}

// 12-bit D/A converter
type DAC12_Type struct {
	DADR0    volatile.Register16 // 0x0
	_        [2]byte
	DACR     volatile.Register8 // 0x4
	DADPR    volatile.Register8 // 0x5
	DAADSCR  volatile.Register8 // 0x6
	DAVREFCR volatile.Register8 // 0x7
}

// DAC12.DACR: D/A Control Register
func (o *DAC12_Type) SetDACR_DAOE0(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x40)|value<<6)
}
func (o *DAC12_Type) GetDACR_DAOE0() uint8 {
	return (volatile.LoadUint8(&o.DACR.Reg) & 0x40) >> 6
}

// DAC12.DADPR: DADR0 Format Select Register
func (o *DAC12_Type) SetDADPR_DPSEL(value uint8) {
	volatile.StoreUint8(&o.DADPR.Reg, volatile.LoadUint8(&o.DADPR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDADPR_DPSEL() uint8 {
	return (volatile.LoadUint8(&o.DADPR.Reg) & 0x80) >> 7
}

// DAC12.DAADSCR: D/A A/D Synchronous Start Control Register
func (o *DAC12_Type) SetDAADSCR_DAADST(value uint8) {
	volatile.StoreUint8(&o.DAADSCR.Reg, volatile.LoadUint8(&o.DAADSCR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDAADSCR_DAADST() uint8 {
	return (volatile.LoadUint8(&o.DAADSCR.Reg) & 0x80) >> 7
}

// DAC12.DAVREFCR: D/A VREF Control Register
func (o *DAC12_Type) SetDAVREFCR_REF(value uint8) {
	volatile.StoreUint8(&o.DAVREFCR.Reg, volatile.LoadUint8(&o.DAVREFCR.Reg)&^(0x1)|value)
}
func (o *DAC12_Type) GetDAVREFCR_REF() uint8 {
	return volatile.LoadUint8(&o.DAVREFCR.Reg) & 0x1
}

// Serial Communication Interface 0
type SCI0_Type struct {
	SMR    volatile.Register8  // 0x0
	BRR    volatile.Register8  // 0x1
	SCR    volatile.Register8  // 0x2
	TDR    volatile.Register8  // 0x3
	SSR    volatile.Register8  // 0x4
	RDR    volatile.Register8  // 0x5
	SCMR   volatile.Register8  // 0x6
	SEMR   volatile.Register8  // 0x7
	SNFR   volatile.Register8  // 0x8
	SIMR1  volatile.Register8  // 0x9
	SIMR2  volatile.Register8  // 0xA
	SIMR3  volatile.Register8  // 0xB
	SISR   volatile.Register8  // 0xC
	SPMR   volatile.Register8  // 0xD
	FTDRHL volatile.Register16 // 0xE
	FRDRHL volatile.Register16 // 0x10
	MDDR   volatile.Register8  // 0x12
	DCCR   volatile.Register8  // 0x13
	FCR    volatile.Register16 // 0x14
	FDR    volatile.Register16 // 0x16
	LSR    volatile.Register16 // 0x18
	CDR    volatile.Register16 // 0x1A
	SPTR   volatile.Register8  // 0x1C
}

// SCI0.SMR: Serial Mode Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
func (o *SCI0_Type) SetSMR_CKS(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x3)|value)
}
func (o *SCI0_Type) GetSMR_CKS() uint8 {
	return volatile.LoadUint8(&o.SMR.Reg) & 0x3
}
func (o *SCI0_Type) SetSMR_MP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSMR_MP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSMR_STOP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSMR_STOP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSMR_PM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSMR_PM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSMR_PE(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSMR_PE() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSMR_CHR(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSMR_CHR() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSMR_CM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSMR_CM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x80) >> 7
}

// SCI0.SCR: Serial Control Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
func (o *SCI0_Type) SetSCR_CKE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x3)|value)
}
func (o *SCI0_Type) GetSCR_CKE() uint8 {
	return volatile.LoadUint8(&o.SCR.Reg) & 0x3
}
func (o *SCI0_Type) SetSCR_TEIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSCR_TEIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSCR_MPIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSCR_MPIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSCR_RE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSCR_RE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSCR_TE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSCR_TE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSCR_RIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSCR_RIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSCR_TIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSCR_TIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x80) >> 7
}

// SCI0.SSR: Serial Status Register for Non-Smart Card Interface and Non-FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0)
func (o *SCI0_Type) SetSSR_MPBT(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSSR_MPBT() uint8 {
	return volatile.LoadUint8(&o.SSR.Reg) & 0x1
}
func (o *SCI0_Type) SetSSR_MPB(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSSR_MPB() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSSR_TEND(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSSR_TEND() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSSR_PER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSSR_PER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSSR_FER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSSR_FER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSSR_ORER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSSR_ORER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSSR_RDRF(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSSR_RDRF() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSSR_TDRE(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSSR_TDRE() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x80) >> 7
}

// SCI0.SCMR: Smart Card Mode Register
func (o *SCI0_Type) SetSCMR_SMIF(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSCMR_SMIF() uint8 {
	return volatile.LoadUint8(&o.SCMR.Reg) & 0x1
}
func (o *SCI0_Type) SetSCMR_SINV(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSCMR_SINV() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSCMR_SDIR(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSCMR_SDIR() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSCMR_CHR1(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSCMR_CHR1() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSCMR_BCP2(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSCMR_BCP2() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x80) >> 7
}

// SCI0.SEMR: Serial Extended Mode Register
func (o *SCI0_Type) SetSEMR_BRME(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSEMR_BRME() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSEMR_ABCSE(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSEMR_ABCSE() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSEMR_ABCS(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSEMR_ABCS() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSEMR_NFEN(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSEMR_NFEN() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSEMR_BGDM(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSEMR_BGDM() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSEMR_RXDESEL(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSEMR_RXDESEL() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x80) >> 7
}

// SCI0.SNFR: Noise Filter Setting Register
func (o *SCI0_Type) SetSNFR_NFCS(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0x7)|value)
}
func (o *SCI0_Type) GetSNFR_NFCS() uint8 {
	return volatile.LoadUint8(&o.SNFR.Reg) & 0x7
}

// SCI0.SIMR1: IIC Mode Register 1
func (o *SCI0_Type) SetSIMR1_IICM(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR1_IICM() uint8 {
	return volatile.LoadUint8(&o.SIMR1.Reg) & 0x1
}
func (o *SCI0_Type) SetSIMR1_IICDL(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0xf8)|value<<3)
}
func (o *SCI0_Type) GetSIMR1_IICDL() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0xf8) >> 3
}

// SCI0.SIMR2: IIC Mode Register 2
func (o *SCI0_Type) SetSIMR2_IICINTM(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR2_IICINTM() uint8 {
	return volatile.LoadUint8(&o.SIMR2.Reg) & 0x1
}
func (o *SCI0_Type) SetSIMR2_IICCSC(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSIMR2_IICCSC() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSIMR2_IICACKT(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSIMR2_IICACKT() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x20) >> 5
}

// SCI0.SIMR3: IIC Mode Register 3
func (o *SCI0_Type) SetSIMR3_IICSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR3_IICSTAREQ() uint8 {
	return volatile.LoadUint8(&o.SIMR3.Reg) & 0x1
}
func (o *SCI0_Type) SetSIMR3_IICRSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSIMR3_IICRSTAREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSIMR3_IICSTPREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSIMR3_IICSTPREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSIMR3_IICSTIF(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSIMR3_IICSTIF() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSIMR3_IICSDAS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x30)|value<<4)
}
func (o *SCI0_Type) GetSIMR3_IICSDAS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x30) >> 4
}
func (o *SCI0_Type) SetSIMR3_IICSCLS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0xc0)|value<<6)
}
func (o *SCI0_Type) GetSIMR3_IICSCLS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0xc0) >> 6
}

// SCI0.SISR: IIC Status Register
func (o *SCI0_Type) SetSISR_IICACKR(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSISR_IICACKR() uint8 {
	return volatile.LoadUint8(&o.SISR.Reg) & 0x1
}

// SCI0.SPMR: SPI Mode Register
func (o *SCI0_Type) SetSPMR_SSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSPMR_SSE() uint8 {
	return volatile.LoadUint8(&o.SPMR.Reg) & 0x1
}
func (o *SCI0_Type) SetSPMR_CTSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSPMR_CTSE() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSPMR_MSS(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSPMR_MSS() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSPMR_MFF(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSPMR_MFF() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSPMR_CKPOL(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSPMR_CKPOL() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSPMR_CKPH(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSPMR_CKPH() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x80) >> 7
}

// SCI0.FTDRHL: Transmit FIFO Data Register
func (o *SCI0_Type) SetFTDRHL_TDAT(value uint16) {
	volatile.StoreUint16(&o.FTDRHL.Reg, volatile.LoadUint16(&o.FTDRHL.Reg)&^(0x1ff)|value)
}
func (o *SCI0_Type) GetFTDRHL_TDAT() uint16 {
	return volatile.LoadUint16(&o.FTDRHL.Reg) & 0x1ff
}
func (o *SCI0_Type) SetFTDRHL_MPBT(value uint16) {
	volatile.StoreUint16(&o.FTDRHL.Reg, volatile.LoadUint16(&o.FTDRHL.Reg)&^(0x200)|value<<9)
}
func (o *SCI0_Type) GetFTDRHL_MPBT() uint16 {
	return (volatile.LoadUint16(&o.FTDRHL.Reg) & 0x200) >> 9
}

// SCI0.FRDRHL: Receive FIFO Data Register
func (o *SCI0_Type) SetFRDRHL_RDAT(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x1ff)|value)
}
func (o *SCI0_Type) GetFRDRHL_RDAT() uint16 {
	return volatile.LoadUint16(&o.FRDRHL.Reg) & 0x1ff
}
func (o *SCI0_Type) SetFRDRHL_MPB(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x200)|value<<9)
}
func (o *SCI0_Type) GetFRDRHL_MPB() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x200) >> 9
}
func (o *SCI0_Type) SetFRDRHL_DR(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x400)|value<<10)
}
func (o *SCI0_Type) GetFRDRHL_DR() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x400) >> 10
}
func (o *SCI0_Type) SetFRDRHL_PER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x800)|value<<11)
}
func (o *SCI0_Type) GetFRDRHL_PER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x800) >> 11
}
func (o *SCI0_Type) SetFRDRHL_FER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x1000)|value<<12)
}
func (o *SCI0_Type) GetFRDRHL_FER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x1000) >> 12
}
func (o *SCI0_Type) SetFRDRHL_ORER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x2000)|value<<13)
}
func (o *SCI0_Type) GetFRDRHL_ORER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x2000) >> 13
}
func (o *SCI0_Type) SetFRDRHL_RDF(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x4000)|value<<14)
}
func (o *SCI0_Type) GetFRDRHL_RDF() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x4000) >> 14
}

// SCI0.DCCR: Data Compare Match Control Register
func (o *SCI0_Type) SetDCCR_DCMF(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetDCCR_DCMF() uint8 {
	return volatile.LoadUint8(&o.DCCR.Reg) & 0x1
}
func (o *SCI0_Type) SetDCCR_DPER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetDCCR_DPER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetDCCR_DFER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetDCCR_DFER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetDCCR_IDSEL(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetDCCR_IDSEL() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetDCCR_DCME(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetDCCR_DCME() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x80) >> 7
}

// SCI0.FCR: FIFO Control Register
func (o *SCI0_Type) SetFCR_FM(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetFCR_FM() uint16 {
	return volatile.LoadUint16(&o.FCR.Reg) & 0x1
}
func (o *SCI0_Type) SetFCR_RFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetFCR_RFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetFCR_TFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetFCR_TFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetFCR_DRES(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetFCR_DRES() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetFCR_TTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf0)|value<<4)
}
func (o *SCI0_Type) GetFCR_TTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf0) >> 4
}
func (o *SCI0_Type) SetFCR_RTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf00)|value<<8)
}
func (o *SCI0_Type) GetFCR_RTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf00) >> 8
}
func (o *SCI0_Type) SetFCR_RSTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf000)|value<<12)
}
func (o *SCI0_Type) GetFCR_RSTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf000) >> 12
}

// SCI0.FDR: FIFO Data Count Register
func (o *SCI0_Type) SetFDR_R(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f)|value)
}
func (o *SCI0_Type) GetFDR_R() uint16 {
	return volatile.LoadUint16(&o.FDR.Reg) & 0x1f
}
func (o *SCI0_Type) SetFDR_T(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI0_Type) GetFDR_T() uint16 {
	return (volatile.LoadUint16(&o.FDR.Reg) & 0x1f00) >> 8
}

// SCI0.LSR: Line Status Register
func (o *SCI0_Type) SetLSR_ORER(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetLSR_ORER() uint16 {
	return volatile.LoadUint16(&o.LSR.Reg) & 0x1
}
func (o *SCI0_Type) SetLSR_FNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x7c)|value<<2)
}
func (o *SCI0_Type) GetLSR_FNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x7c) >> 2
}
func (o *SCI0_Type) SetLSR_PNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI0_Type) GetLSR_PNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x1f00) >> 8
}

// SCI0.CDR: Compare Match Data Register
func (o *SCI0_Type) SetCDR_CMPD(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0x1ff)|value)
}
func (o *SCI0_Type) GetCDR_CMPD() uint16 {
	return volatile.LoadUint16(&o.CDR.Reg) & 0x1ff
}

// SCI0.SPTR: Serial Port Register
func (o *SCI0_Type) SetSPTR_RXDMON(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSPTR_RXDMON() uint8 {
	return volatile.LoadUint8(&o.SPTR.Reg) & 0x1
}
func (o *SCI0_Type) SetSPTR_SPB2DT(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSPTR_SPB2DT() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSPTR_SPB2IO(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSPTR_SPB2IO() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x4) >> 2
}

// Serial Communication Interface 0
type SCI1_Type struct {
	SMR   volatile.Register8  // 0x0
	BRR   volatile.Register8  // 0x1
	SCR   volatile.Register8  // 0x2
	TDR   volatile.Register8  // 0x3
	SSR   volatile.Register8  // 0x4
	RDR   volatile.Register8  // 0x5
	SCMR  volatile.Register8  // 0x6
	SEMR  volatile.Register8  // 0x7
	SNFR  volatile.Register8  // 0x8
	SIMR1 volatile.Register8  // 0x9
	SIMR2 volatile.Register8  // 0xA
	SIMR3 volatile.Register8  // 0xB
	SISR  volatile.Register8  // 0xC
	SPMR  volatile.Register8  // 0xD
	TDRHL volatile.Register16 // 0xE
	RDRHL volatile.Register16 // 0x10
	MDDR  volatile.Register8  // 0x12
}

// SCI1.SMR: Serial Mode Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
func (o *SCI1_Type) SetSMR_CKS(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x3)|value)
}
func (o *SCI1_Type) GetSMR_CKS() uint8 {
	return volatile.LoadUint8(&o.SMR.Reg) & 0x3
}
func (o *SCI1_Type) SetSMR_MP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSMR_MP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSMR_STOP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSMR_STOP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSMR_PM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSMR_PM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSMR_PE(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSMR_PE() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSMR_CHR(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSMR_CHR() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSMR_CM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSMR_CM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x80) >> 7
}

// SCI1.SCR: Serial Control Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
func (o *SCI1_Type) SetSCR_CKE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x3)|value)
}
func (o *SCI1_Type) GetSCR_CKE() uint8 {
	return volatile.LoadUint8(&o.SCR.Reg) & 0x3
}
func (o *SCI1_Type) SetSCR_TEIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSCR_TEIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSCR_MPIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSCR_MPIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSCR_RE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSCR_RE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSCR_TE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSCR_TE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSCR_RIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSCR_RIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSCR_TIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSCR_TIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x80) >> 7
}

// SCI1.SSR: Serial Status Register for Non-Smart Card Interface and Non-FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0)
func (o *SCI1_Type) SetSSR_MPBT(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSSR_MPBT() uint8 {
	return volatile.LoadUint8(&o.SSR.Reg) & 0x1
}
func (o *SCI1_Type) SetSSR_MPB(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSSR_MPB() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSSR_TEND(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSSR_TEND() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSSR_PER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSSR_PER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSSR_FER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSSR_FER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSSR_ORER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSSR_ORER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSSR_RDRF(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSSR_RDRF() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSSR_TDRE(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSSR_TDRE() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x80) >> 7
}

// SCI1.SCMR: Smart Card Mode Register
func (o *SCI1_Type) SetSCMR_SMIF(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSCMR_SMIF() uint8 {
	return volatile.LoadUint8(&o.SCMR.Reg) & 0x1
}
func (o *SCI1_Type) SetSCMR_SINV(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSCMR_SINV() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSCMR_SDIR(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSCMR_SDIR() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSCMR_CHR1(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSCMR_CHR1() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSCMR_BCP2(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSCMR_BCP2() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x80) >> 7
}

// SCI1.SEMR: Serial Extended Mode Register
func (o *SCI1_Type) SetSEMR_BRME(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSEMR_BRME() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSEMR_ABCSE(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSEMR_ABCSE() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSEMR_ABCS(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSEMR_ABCS() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSEMR_NFEN(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSEMR_NFEN() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSEMR_BGDM(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSEMR_BGDM() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSEMR_RXDESEL(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSEMR_RXDESEL() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x80) >> 7
}

// SCI1.SNFR: Noise Filter Setting Register
func (o *SCI1_Type) SetSNFR_NFCS(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0x7)|value)
}
func (o *SCI1_Type) GetSNFR_NFCS() uint8 {
	return volatile.LoadUint8(&o.SNFR.Reg) & 0x7
}

// SCI1.SIMR1: IIC Mode Register 1
func (o *SCI1_Type) SetSIMR1_IICM(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSIMR1_IICM() uint8 {
	return volatile.LoadUint8(&o.SIMR1.Reg) & 0x1
}
func (o *SCI1_Type) SetSIMR1_IICDL(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0xf8)|value<<3)
}
func (o *SCI1_Type) GetSIMR1_IICDL() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0xf8) >> 3
}

// SCI1.SIMR2: IIC Mode Register 2
func (o *SCI1_Type) SetSIMR2_IICINTM(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSIMR2_IICINTM() uint8 {
	return volatile.LoadUint8(&o.SIMR2.Reg) & 0x1
}
func (o *SCI1_Type) SetSIMR2_IICCSC(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSIMR2_IICCSC() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSIMR2_IICACKT(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSIMR2_IICACKT() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x20) >> 5
}

// SCI1.SIMR3: IIC Mode Register 3
func (o *SCI1_Type) SetSIMR3_IICSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSIMR3_IICSTAREQ() uint8 {
	return volatile.LoadUint8(&o.SIMR3.Reg) & 0x1
}
func (o *SCI1_Type) SetSIMR3_IICRSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSIMR3_IICRSTAREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSIMR3_IICSTPREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSIMR3_IICSTPREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSIMR3_IICSTIF(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSIMR3_IICSTIF() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSIMR3_IICSDAS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x30)|value<<4)
}
func (o *SCI1_Type) GetSIMR3_IICSDAS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x30) >> 4
}
func (o *SCI1_Type) SetSIMR3_IICSCLS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0xc0)|value<<6)
}
func (o *SCI1_Type) GetSIMR3_IICSCLS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0xc0) >> 6
}

// SCI1.SISR: IIC Status Register
func (o *SCI1_Type) SetSISR_IICACKR(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSISR_IICACKR() uint8 {
	return volatile.LoadUint8(&o.SISR.Reg) & 0x1
}

// SCI1.SPMR: SPI Mode Register
func (o *SCI1_Type) SetSPMR_SSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSPMR_SSE() uint8 {
	return volatile.LoadUint8(&o.SPMR.Reg) & 0x1
}
func (o *SCI1_Type) SetSPMR_CTSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSPMR_CTSE() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSPMR_MSS(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSPMR_MSS() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSPMR_MFF(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSPMR_MFF() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSPMR_CKPOL(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSPMR_CKPOL() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSPMR_CKPH(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSPMR_CKPH() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x80) >> 7
}

// SCI1.TDRHL: Transmit Data Register
func (o *SCI1_Type) SetTDRHL_TDAT(value uint16) {
	volatile.StoreUint16(&o.TDRHL.Reg, volatile.LoadUint16(&o.TDRHL.Reg)&^(0x1ff)|value)
}
func (o *SCI1_Type) GetTDRHL_TDAT() uint16 {
	return volatile.LoadUint16(&o.TDRHL.Reg) & 0x1ff
}

// SCI1.RDRHL: Receive Data Register
func (o *SCI1_Type) SetRDRHL_RDAT(value uint16) {
	volatile.StoreUint16(&o.RDRHL.Reg, volatile.LoadUint16(&o.RDRHL.Reg)&^(0x1ff)|value)
}
func (o *SCI1_Type) GetRDRHL_RDAT() uint16 {
	return volatile.LoadUint16(&o.RDRHL.Reg) & 0x1ff
}

// Serial Peripheral Interface 0
type SPI0_Type struct {
	SPCR   volatile.Register8  // 0x0
	SSLP   volatile.Register8  // 0x1
	SPPCR  volatile.Register8  // 0x2
	SPSR   volatile.Register8  // 0x3
	SPDR   volatile.Register32 // 0x4
	_      [2]byte
	SPBR   volatile.Register8  // 0xA
	SPDCR  volatile.Register8  // 0xB
	SPCKD  volatile.Register8  // 0xC
	SSLND  volatile.Register8  // 0xD
	SPND   volatile.Register8  // 0xE
	SPCR2  volatile.Register8  // 0xF
	SPCMD0 volatile.Register16 // 0x10
}

// SPI0.SPCR: SPI Control Register
func (o *SPI0_Type) SetSPCR_SPMS(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCR_SPMS() uint8 {
	return volatile.LoadUint8(&o.SPCR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCR_TXMD(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCR_TXMD() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCR_MODFEN(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPCR_MODFEN() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPCR_MSTR(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPCR_MSTR() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPCR_SPEIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPCR_SPEIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPCR_SPTIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPCR_SPTIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPCR_SPE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPCR_SPE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPCR_SPRIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCR_SPRIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x80) >> 7
}

// SPI0.SSLP: SPI Slave Select Polarity Register
func (o *SPI0_Type) SetSSLP_SSL0P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSSLP_SSL0P() uint8 {
	return volatile.LoadUint8(&o.SSLP.Reg) & 0x1
}
func (o *SPI0_Type) SetSSLP_SSL1P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSSLP_SSL1P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSSLP_SSL2P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSSLP_SSL2P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSSLP_SSL3P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSSLP_SSL3P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x8) >> 3
}

// SPI0.SPPCR: SPI Pin Control Register
func (o *SPI0_Type) SetSPPCR_SPLP(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPPCR_SPLP() uint8 {
	return volatile.LoadUint8(&o.SPPCR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPPCR_SPLP2(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPPCR_SPLP2() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPPCR_MOIFV(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPPCR_MOIFV() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPPCR_MOIFE(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPPCR_MOIFE() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x20) >> 5
}

// SPI0.SPSR: SPI Status Register
func (o *SPI0_Type) SetSPSR_OVRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPSR_OVRF() uint8 {
	return volatile.LoadUint8(&o.SPSR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPSR_IDLNF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPSR_IDLNF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPSR_MODF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPSR_MODF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPSR_PERF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPSR_PERF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPSR_UDRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPSR_UDRF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPSR_SPTEF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPSR_SPTEF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPSR_SPRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPSR_SPRF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x80) >> 7
}

// SPI0.SPDCR: SPI Data Control Register
func (o *SPI0_Type) SetSPDCR_SPRDTD(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPDCR_SPRDTD() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPDCR_SPLW(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPDCR_SPLW() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPDCR_SPBYT(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPDCR_SPBYT() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x40) >> 6
}

// SPI0.SPCKD: SPI Clock Delay Register
func (o *SPI0_Type) SetSPCKD_SCKDL(value uint8) {
	volatile.StoreUint8(&o.SPCKD.Reg, volatile.LoadUint8(&o.SPCKD.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPCKD_SCKDL() uint8 {
	return volatile.LoadUint8(&o.SPCKD.Reg) & 0x7
}

// SPI0.SSLND: SPI Slave Select Negation Delay Register
func (o *SPI0_Type) SetSSLND_SLNDL(value uint8) {
	volatile.StoreUint8(&o.SSLND.Reg, volatile.LoadUint8(&o.SSLND.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSSLND_SLNDL() uint8 {
	return volatile.LoadUint8(&o.SSLND.Reg) & 0x7
}

// SPI0.SPND: SPI Next-Access Delay Register
func (o *SPI0_Type) SetSPND_SPNDL(value uint8) {
	volatile.StoreUint8(&o.SPND.Reg, volatile.LoadUint8(&o.SPND.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPND_SPNDL() uint8 {
	return volatile.LoadUint8(&o.SPND.Reg) & 0x7
}

// SPI0.SPCR2: SPI Control Register 2
func (o *SPI0_Type) SetSPCR2_SPPE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCR2_SPPE() uint8 {
	return volatile.LoadUint8(&o.SPCR2.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCR2_SPOE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCR2_SPOE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCR2_SPIIE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPCR2_SPIIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPCR2_PTE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPCR2_PTE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPCR2_SCKASE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPCR2_SCKASE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x10) >> 4
}

// SPI0.SPCMD0: SPI Command Register 0
func (o *SPI0_Type) SetSPCMD0_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD0_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD0.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCMD0_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD0_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD0_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD0_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD0_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD0_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD0_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD0_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD0_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD0_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD0_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD0_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD0_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD0_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD0_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD0_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x8000) >> 15
}

// Cyclic Redundancy Check Calculator
type CRC_Type struct {
	CRCCR0 volatile.Register8 // 0x0
	CRCCR1 volatile.Register8 // 0x1
	_      [2]byte
	CRCDIR volatile.Register32 // 0x4
	CRCDOR volatile.Register32 // 0x8
	CRCSAR volatile.Register16 // 0xC
}

// CRC.CRCCR0: CRC Control Register 0
func (o *CRC_Type) SetCRCCR0_GPS(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x7)|value)
}
func (o *CRC_Type) GetCRCCR0_GPS() uint8 {
	return volatile.LoadUint8(&o.CRCCR0.Reg) & 0x7
}
func (o *CRC_Type) SetCRCCR0_LMS(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x40)|value<<6)
}
func (o *CRC_Type) GetCRCCR0_LMS() uint8 {
	return (volatile.LoadUint8(&o.CRCCR0.Reg) & 0x40) >> 6
}
func (o *CRC_Type) SetCRCCR0_DORCLR(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCRCCR0_DORCLR() uint8 {
	return (volatile.LoadUint8(&o.CRCCR0.Reg) & 0x80) >> 7
}

// CRC.CRCCR1: CRC Control Register 1
func (o *CRC_Type) SetCRCCR1_CRCSWR(value uint8) {
	volatile.StoreUint8(&o.CRCCR1.Reg, volatile.LoadUint8(&o.CRCCR1.Reg)&^(0x40)|value<<6)
}
func (o *CRC_Type) GetCRCCR1_CRCSWR() uint8 {
	return (volatile.LoadUint8(&o.CRCCR1.Reg) & 0x40) >> 6
}
func (o *CRC_Type) SetCRCCR1_CRCSEN(value uint8) {
	volatile.StoreUint8(&o.CRCCR1.Reg, volatile.LoadUint8(&o.CRCCR1.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCRCCR1_CRCSEN() uint8 {
	return (volatile.LoadUint8(&o.CRCCR1.Reg) & 0x80) >> 7
}

// CRC.CRCSAR: Snoop Address Register
func (o *CRC_Type) SetCRCSAR_CRCSA(value uint16) {
	volatile.StoreUint16(&o.CRCSAR.Reg, volatile.LoadUint16(&o.CRCSAR.Reg)&^(0x3fff)|value)
}
func (o *CRC_Type) GetCRCSAR_CRCSA() uint16 {
	return volatile.LoadUint16(&o.CRCSAR.Reg) & 0x3fff
}

// General PWM 32-bit Timer 0
type GPT320_Type struct {
	GTWP     volatile.Register32 // 0x0
	GTSTR    volatile.Register32 // 0x4
	GTSTP    volatile.Register32 // 0x8
	GTCLR    volatile.Register32 // 0xC
	GTSSR    volatile.Register32 // 0x10
	GTPSR    volatile.Register32 // 0x14
	GTCSR    volatile.Register32 // 0x18
	GTUPSR   volatile.Register32 // 0x1C
	GTDNSR   volatile.Register32 // 0x20
	GTICASR  volatile.Register32 // 0x24
	GTICBSR  volatile.Register32 // 0x28
	GTCR     volatile.Register32 // 0x2C
	GTUDDTYC volatile.Register32 // 0x30
	GTIOR    volatile.Register32 // 0x34
	GTINTAD  volatile.Register32 // 0x38
	GTST     volatile.Register32 // 0x3C
	GTBER    volatile.Register32 // 0x40
	_        [4]byte
	GTCNT    volatile.Register32 // 0x48
	GTCCRA   volatile.Register32 // 0x4C
	GTCCRB   volatile.Register32 // 0x50
	GTCCRC   volatile.Register32 // 0x54
	GTCCRE   volatile.Register32 // 0x58
	GTCCRD   volatile.Register32 // 0x5C
	GTCCRF   volatile.Register32 // 0x60
	GTPR     volatile.Register32 // 0x64
	GTPBR    volatile.Register32 // 0x68
	_        [28]byte
	GTDTCR   volatile.Register32 // 0x88
	GTDVU    volatile.Register32 // 0x8C
}

// GPT320.GTWP: General PWM Timer Write-Protection Register
func (o *GPT320_Type) SetGTWP_WP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTWP_WP() uint32 {
	return volatile.LoadUint32(&o.GTWP.Reg) & 0x1
}
func (o *GPT320_Type) SetGTWP_PRKEY(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xff00)|value<<8)
}
func (o *GPT320_Type) GetGTWP_PRKEY() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xff00) >> 8
}

// GPT320.GTSTR: General PWM Timer Software Start Register
func (o *GPT320_Type) SetGTSTR_CSTRT0(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTSTR_CSTRT0() uint32 {
	return volatile.LoadUint32(&o.GTSTR.Reg) & 0x1
}
func (o *GPT320_Type) SetGTSTR_CSTRT1(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTSTR_CSTRT1() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTSTR_CSTRT2(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTSTR_CSTRT2() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTSTR_CSTRT3(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTSTR_CSTRT3() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTSTR_CSTRT4(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x10)|value<<4)
}
func (o *GPT320_Type) GetGTSTR_CSTRT4() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x10) >> 4
}
func (o *GPT320_Type) SetGTSTR_CSTRT5(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTSTR_CSTRT5() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTSTR_CSTRT6(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTSTR_CSTRT6() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTSTR_CSTRT7(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x80)|value<<7)
}
func (o *GPT320_Type) GetGTSTR_CSTRT7() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x80) >> 7
}
func (o *GPT320_Type) SetGTSTR_CSTRT8(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTSTR_CSTRT8() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTSTR_CSTRT9(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTSTR_CSTRT9() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x200) >> 9
}

// GPT320.GTSTP: General PWM Timer Software Stop Register
func (o *GPT320_Type) SetGTSTP_CSTOP0(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTSTP_CSTOP0() uint32 {
	return volatile.LoadUint32(&o.GTSTP.Reg) & 0x1
}
func (o *GPT320_Type) SetGTSTP_CSTOP1(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTSTP_CSTOP1() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTSTP_CSTOP2(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTSTP_CSTOP2() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTSTP_CSTOP3(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTSTP_CSTOP3() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTSTP_CSTOP4(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x10)|value<<4)
}
func (o *GPT320_Type) GetGTSTP_CSTOP4() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x10) >> 4
}
func (o *GPT320_Type) SetGTSTP_CSTOP5(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTSTP_CSTOP5() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTSTP_CSTOP6(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTSTP_CSTOP6() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTSTP_CSTOP7(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x80)|value<<7)
}
func (o *GPT320_Type) GetGTSTP_CSTOP7() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x80) >> 7
}
func (o *GPT320_Type) SetGTSTP_CSTOP8(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTSTP_CSTOP8() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTSTP_CSTOP9(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTSTP_CSTOP9() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x200) >> 9
}

// GPT320.GTCLR: General PWM Timer Software Clear Register
func (o *GPT320_Type) SetGTCLR_CCLR0(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTCLR_CCLR0() uint32 {
	return volatile.LoadUint32(&o.GTCLR.Reg) & 0x1
}
func (o *GPT320_Type) SetGTCLR_CCLR1(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTCLR_CCLR1() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTCLR_CCLR2(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTCLR_CCLR2() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTCLR_CCLR3(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTCLR_CCLR3() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTCLR_CCLR4(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPT320_Type) GetGTCLR_CCLR4() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x10) >> 4
}
func (o *GPT320_Type) SetGTCLR_CCLR5(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTCLR_CCLR5() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTCLR_CCLR6(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTCLR_CCLR6() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTCLR_CCLR7(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPT320_Type) GetGTCLR_CCLR7() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x80) >> 7
}
func (o *GPT320_Type) SetGTCLR_CCLR8(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTCLR_CCLR8() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTCLR_CCLR9(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTCLR_CCLR9() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x200) >> 9
}

// GPT320.GTSSR: General PWM Timer Start Source Select Register
func (o *GPT320_Type) SetGTSSR_SSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTSSR_SSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTSSR.Reg) & 0x1
}
func (o *GPT320_Type) SetGTSSR_SSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTSSR_SSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTSSR_SSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTSSR_SSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTSSR_SSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTSSR_SSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTSSR_SSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTSSR_SSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTSSR_SSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTSSR_SSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTSSR_SSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTSSR_SSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTSSR_SSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTSSR_SSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTSSR_SSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTSSR_SSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTSSR_SSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTSSR_SSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTSSR_SSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTSSR_SSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTSSR_SSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTSSR_SSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTSSR_SSELCA(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTSSR_SSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTSSR_SSELCB(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTSSR_SSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTSSR_SSELCC(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTSSR_SSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTSSR_SSELCD(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTSSR_SSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTSSR_CSTRT(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT320_Type) GetGTSSR_CSTRT() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000000) >> 31
}

// GPT320.GTPSR: General PWM Timer Stop Source Select Register
func (o *GPT320_Type) SetGTPSR_PSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTPSR_PSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTPSR.Reg) & 0x1
}
func (o *GPT320_Type) SetGTPSR_PSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTPSR_PSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTPSR_PSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTPSR_PSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTPSR_PSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTPSR_PSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTPSR_PSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTPSR_PSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTPSR_PSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTPSR_PSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTPSR_PSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTPSR_PSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTPSR_PSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTPSR_PSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTPSR_PSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTPSR_PSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTPSR_PSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTPSR_PSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTPSR_PSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTPSR_PSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTPSR_PSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTPSR_PSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTPSR_PSELCA(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTPSR_PSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTPSR_PSELCB(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTPSR_PSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTPSR_PSELCC(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTPSR_PSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTPSR_PSELCD(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTPSR_PSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTPSR_CSTOP(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT320_Type) GetGTPSR_CSTOP() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000000) >> 31
}

// GPT320.GTCSR: General PWM Timer Clear Source Select Register
func (o *GPT320_Type) SetGTCSR_CSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTCSR_CSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTCSR.Reg) & 0x1
}
func (o *GPT320_Type) SetGTCSR_CSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTCSR_CSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTCSR_CSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTCSR_CSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTCSR_CSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTCSR_CSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTCSR_CSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTCSR_CSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTCSR_CSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTCSR_CSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTCSR_CSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTCSR_CSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTCSR_CSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTCSR_CSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTCSR_CSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTCSR_CSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTCSR_CSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTCSR_CSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTCSR_CSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTCSR_CSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTCSR_CSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTCSR_CSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTCSR_CSELCA(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTCSR_CSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTCSR_CSELCB(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTCSR_CSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTCSR_CSELCC(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTCSR_CSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTCSR_CSELCD(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTCSR_CSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTCSR_CCLR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT320_Type) GetGTCSR_CCLR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000000) >> 31
}

// GPT320.GTUPSR: General PWM Timer Up Count Source Select Register
func (o *GPT320_Type) SetGTUPSR_USGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTUPSR_USGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1
}
func (o *GPT320_Type) SetGTUPSR_USGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTUPSR_USGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTUPSR_USGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTUPSR_USGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTUPSR_USGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTUPSR_USGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTUPSR_USCARBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTUPSR_USCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTUPSR_USCARBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTUPSR_USCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTUPSR_USCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTUPSR_USCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTUPSR_USCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTUPSR_USCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTUPSR_USCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTUPSR_USCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTUPSR_USCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTUPSR_USCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTUPSR_USCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTUPSR_USCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTUPSR_USCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTUPSR_USCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTUPSR_USELCA(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTUPSR_USELCA() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTUPSR_USELCB(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTUPSR_USELCB() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTUPSR_USELCC(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTUPSR_USELCC() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTUPSR_USELCD(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTUPSR_USELCD() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80000) >> 19
}

// GPT320.GTDNSR: General PWM Timer Down Count Source Select Register
func (o *GPT320_Type) SetGTDNSR_DSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTDNSR_DSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1
}
func (o *GPT320_Type) SetGTDNSR_DSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTDNSR_DSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTDNSR_DSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTDNSR_DSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTDNSR_DSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTDNSR_DSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTDNSR_DSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTDNSR_DSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTDNSR_DSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTDNSR_DSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTDNSR_DSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTDNSR_DSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTDNSR_DSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTDNSR_DSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTDNSR_DSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTDNSR_DSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTDNSR_DSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTDNSR_DSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTDNSR_DSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTDNSR_DSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTDNSR_DSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTDNSR_DSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTDNSR_DSELCA(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTDNSR_DSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTDNSR_DSELCB(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTDNSR_DSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTDNSR_DSELCC(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTDNSR_DSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTDNSR_DSELCD(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTDNSR_DSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80000) >> 19
}

// GPT320.GTICASR: General PWM Timer Input Capture Source Select Register A
func (o *GPT320_Type) SetGTICASR_ASGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTICASR_ASGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICASR.Reg) & 0x1
}
func (o *GPT320_Type) SetGTICASR_ASGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTICASR_ASGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTICASR_ASGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTICASR_ASGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTICASR_ASGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTICASR_ASGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTICASR_ASCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTICASR_ASCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTICASR_ASCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTICASR_ASCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTICASR_ASCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTICASR_ASCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTICASR_ASCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTICASR_ASCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTICASR_ASCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTICASR_ASCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTICASR_ASCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTICASR_ASCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTICASR_ASCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTICASR_ASCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTICASR_ASCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTICASR_ASCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTICASR_ASELCA(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTICASR_ASELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTICASR_ASELCB(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTICASR_ASELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTICASR_ASELCC(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTICASR_ASELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTICASR_ASELCD(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTICASR_ASELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80000) >> 19
}

// GPT320.GTICBSR: General PWM Timer Input Capture Source Select Register B
func (o *GPT320_Type) SetGTICBSR_BSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTICBSR_BSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1
}
func (o *GPT320_Type) SetGTICBSR_BSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTICBSR_BSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTICBSR_BSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTICBSR_BSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTICBSR_BSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTICBSR_BSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTICBSR_BSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTICBSR_BSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTICBSR_BSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTICBSR_BSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTICBSR_BSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTICBSR_BSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTICBSR_BSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTICBSR_BSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTICBSR_BSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTICBSR_BSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTICBSR_BSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTICBSR_BSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTICBSR_BSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTICBSR_BSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTICBSR_BSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTICBSR_BSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTICBSR_BSELCA(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTICBSR_BSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTICBSR_BSELCB(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTICBSR_BSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTICBSR_BSELCC(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTICBSR_BSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTICBSR_BSELCD(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTICBSR_BSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80000) >> 19
}

// GPT320.GTCR: General PWM Timer Control Register
func (o *GPT320_Type) SetGTCR_CST(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTCR_CST() uint32 {
	return volatile.LoadUint32(&o.GTCR.Reg) & 0x1
}
func (o *GPT320_Type) SetGTCR_MD(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x70000)|value<<16)
}
func (o *GPT320_Type) GetGTCR_MD() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x70000) >> 16
}
func (o *GPT320_Type) SetGTCR_TPCS(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x7000000)|value<<24)
}
func (o *GPT320_Type) GetGTCR_TPCS() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x7000000) >> 24
}

// GPT320.GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
func (o *GPT320_Type) SetGTUDDTYC_UD(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTUDDTYC_UD() uint32 {
	return volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x1
}
func (o *GPT320_Type) SetGTUDDTYC_UDF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTUDDTYC_UDF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTUDDTYC_OADTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x30000)|value<<16)
}
func (o *GPT320_Type) GetGTUDDTYC_OADTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x30000) >> 16
}
func (o *GPT320_Type) SetGTUDDTYC_OADTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTUDDTYC_OADTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTUDDTYC_OADTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTUDDTYC_OADTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTUDDTYC_OBDTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT320_Type) GetGTUDDTYC_OBDTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x3000000) >> 24
}
func (o *GPT320_Type) SetGTUDDTYC_OBDTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT320_Type) GetGTUDDTYC_OBDTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x4000000) >> 26
}
func (o *GPT320_Type) SetGTUDDTYC_OBDTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x8000000)|value<<27)
}
func (o *GPT320_Type) GetGTUDDTYC_OBDTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x8000000) >> 27
}

// GPT320.GTIOR: General PWM Timer I/O Control Register
func (o *GPT320_Type) SetGTIOR_GTIOA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f)|value)
}
func (o *GPT320_Type) GetGTIOR_GTIOA() uint32 {
	return volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f
}
func (o *GPT320_Type) SetGTIOR_OADFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTIOR_OADFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTIOR_OAHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x80)|value<<7)
}
func (o *GPT320_Type) GetGTIOR_OAHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x80) >> 7
}
func (o *GPT320_Type) SetGTIOR_OAE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTIOR_OAE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTIOR_OADF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x600)|value<<9)
}
func (o *GPT320_Type) GetGTIOR_OADF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x600) >> 9
}
func (o *GPT320_Type) SetGTIOR_NFAEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTIOR_NFAEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTIOR_NFCSA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc000)|value<<14)
}
func (o *GPT320_Type) GetGTIOR_NFCSA() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc000) >> 14
}
func (o *GPT320_Type) SetGTIOR_GTIOB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f0000)|value<<16)
}
func (o *GPT320_Type) GetGTIOR_GTIOB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f0000) >> 16
}
func (o *GPT320_Type) SetGTIOR_OBDFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT320_Type) GetGTIOR_OBDFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x400000) >> 22
}
func (o *GPT320_Type) SetGTIOR_OBHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT320_Type) GetGTIOR_OBHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x800000) >> 23
}
func (o *GPT320_Type) SetGTIOR_OBE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT320_Type) GetGTIOR_OBE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1000000) >> 24
}
func (o *GPT320_Type) SetGTIOR_OBDF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x6000000)|value<<25)
}
func (o *GPT320_Type) GetGTIOR_OBDF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x6000000) >> 25
}
func (o *GPT320_Type) SetGTIOR_NFBEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT320_Type) GetGTIOR_NFBEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20000000) >> 29
}
func (o *GPT320_Type) SetGTIOR_NFCSB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT320_Type) GetGTIOR_NFCSB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc0000000) >> 30
}

// GPT320.GTINTAD: General PWM Timer Interrupt Output Setting Register
func (o *GPT320_Type) SetGTINTAD_GRP(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT320_Type) GetGTINTAD_GRP() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x3000000) >> 24
}
func (o *GPT320_Type) SetGTINTAD_GRPABH(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT320_Type) GetGTINTAD_GRPABH() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x20000000) >> 29
}
func (o *GPT320_Type) SetGTINTAD_GRPABL(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT320_Type) GetGTINTAD_GRPABL() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x40000000) >> 30
}

// GPT320.GTST: General PWM Timer Status Register
func (o *GPT320_Type) SetGTST_TCFA(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTST_TCFA() uint32 {
	return volatile.LoadUint32(&o.GTST.Reg) & 0x1
}
func (o *GPT320_Type) SetGTST_TCFB(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTST_TCFB() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTST_TCFC(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTST_TCFC() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTST_TCFD(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTST_TCFD() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTST_TCFE(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x10)|value<<4)
}
func (o *GPT320_Type) GetGTST_TCFE() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x10) >> 4
}
func (o *GPT320_Type) SetGTST_TCFF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTST_TCFF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTST_TCFPO(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTST_TCFPO() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTST_TCFPU(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x80)|value<<7)
}
func (o *GPT320_Type) GetGTST_TCFPU() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x80) >> 7
}
func (o *GPT320_Type) SetGTST_TUCF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTST_TUCF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTST_ODF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT320_Type) GetGTST_ODF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1000000) >> 24
}
func (o *GPT320_Type) SetGTST_OABHF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT320_Type) GetGTST_OABHF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20000000) >> 29
}
func (o *GPT320_Type) SetGTST_OABLF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT320_Type) GetGTST_OABLF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40000000) >> 30
}

// GPT320.GTBER: General PWM Timer Buffer Enable Register
func (o *GPT320_Type) SetGTBER_BD0(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTBER_BD0() uint32 {
	return volatile.LoadUint32(&o.GTBER.Reg) & 0x1
}
func (o *GPT320_Type) SetGTBER_BD1(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTBER_BD1() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTBER_CCRA(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x30000)|value<<16)
}
func (o *GPT320_Type) GetGTBER_CCRA() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x30000) >> 16
}
func (o *GPT320_Type) SetGTBER_CCRB(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPT320_Type) GetGTBER_CCRB() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0xc0000) >> 18
}
func (o *GPT320_Type) SetGTBER_PR(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x300000)|value<<20)
}
func (o *GPT320_Type) GetGTBER_PR() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x300000) >> 20
}
func (o *GPT320_Type) SetGTBER_CCRSWT(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x400000)|value<<22)
}
func (o *GPT320_Type) GetGTBER_CCRSWT() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x400000) >> 22
}

// GPT320.GTDTCR: General PWM Timer Dead Time Control Register
func (o *GPT320_Type) SetGTDTCR_TDE(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTDTCR_TDE() uint32 {
	return volatile.LoadUint32(&o.GTDTCR.Reg) & 0x1
}

// General PWM 16-bit Timer 4
type GPT164_Type struct {
	GTWP     volatile.Register32 // 0x0
	GTSTR    volatile.Register32 // 0x4
	GTSTP    volatile.Register32 // 0x8
	GTCLR    volatile.Register32 // 0xC
	GTSSR    volatile.Register32 // 0x10
	GTPSR    volatile.Register32 // 0x14
	GTCSR    volatile.Register32 // 0x18
	GTUPSR   volatile.Register32 // 0x1C
	GTDNSR   volatile.Register32 // 0x20
	GTICASR  volatile.Register32 // 0x24
	GTICBSR  volatile.Register32 // 0x28
	GTCR     volatile.Register32 // 0x2C
	GTUDDTYC volatile.Register32 // 0x30
	GTIOR    volatile.Register32 // 0x34
	GTINTAD  volatile.Register32 // 0x38
	GTST     volatile.Register32 // 0x3C
	GTBER    volatile.Register32 // 0x40
	_        [4]byte
	GTCNT    volatile.Register32 // 0x48
	GTCCRA   volatile.Register32 // 0x4C
	GTCCRB   volatile.Register32 // 0x50
	GTCCRC   volatile.Register32 // 0x54
	GTCCRE   volatile.Register32 // 0x58
	GTCCRD   volatile.Register32 // 0x5C
	GTCCRF   volatile.Register32 // 0x60
	GTPR     volatile.Register32 // 0x64
	GTPBR    volatile.Register32 // 0x68
	_        [28]byte
	GTDTCR   volatile.Register32 // 0x88
	GTDVU    volatile.Register32 // 0x8C
}

// GPT164.GTWP: General PWM Timer Write-Protection Register
func (o *GPT164_Type) SetGTWP_WP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTWP_WP() uint32 {
	return volatile.LoadUint32(&o.GTWP.Reg) & 0x1
}
func (o *GPT164_Type) SetGTWP_PRKEY(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xff00)|value<<8)
}
func (o *GPT164_Type) GetGTWP_PRKEY() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xff00) >> 8
}

// GPT164.GTSTR: General PWM Timer Software Start Register
func (o *GPT164_Type) SetGTSTR_CSTRT0(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTSTR_CSTRT0() uint32 {
	return volatile.LoadUint32(&o.GTSTR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTSTR_CSTRT1(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTSTR_CSTRT1() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTSTR_CSTRT2(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTSTR_CSTRT2() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTSTR_CSTRT3(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTSTR_CSTRT3() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTSTR_CSTRT4(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTSTR_CSTRT4() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTSTR_CSTRT5(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTSTR_CSTRT5() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTSTR_CSTRT6(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTSTR_CSTRT6() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTSTR_CSTRT7(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTSTR_CSTRT7() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTSTR_CSTRT8(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTSTR_CSTRT8() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTSTR_CSTRT9(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTSTR_CSTRT9() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x200) >> 9
}

// GPT164.GTSTP: General PWM Timer Software Stop Register
func (o *GPT164_Type) SetGTSTP_CSTOP0(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTSTP_CSTOP0() uint32 {
	return volatile.LoadUint32(&o.GTSTP.Reg) & 0x1
}
func (o *GPT164_Type) SetGTSTP_CSTOP1(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTSTP_CSTOP1() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTSTP_CSTOP2(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTSTP_CSTOP2() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTSTP_CSTOP3(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTSTP_CSTOP3() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTSTP_CSTOP4(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTSTP_CSTOP4() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTSTP_CSTOP5(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTSTP_CSTOP5() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTSTP_CSTOP6(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTSTP_CSTOP6() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTSTP_CSTOP7(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTSTP_CSTOP7() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTSTP_CSTOP8(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTSTP_CSTOP8() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTSTP_CSTOP9(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTSTP_CSTOP9() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x200) >> 9
}

// GPT164.GTCLR: General PWM Timer Software Clear Register
func (o *GPT164_Type) SetGTCLR_CCLR0(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTCLR_CCLR0() uint32 {
	return volatile.LoadUint32(&o.GTCLR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTCLR_CCLR1(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTCLR_CCLR1() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTCLR_CCLR2(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTCLR_CCLR2() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTCLR_CCLR3(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTCLR_CCLR3() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTCLR_CCLR4(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTCLR_CCLR4() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTCLR_CCLR5(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTCLR_CCLR5() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTCLR_CCLR6(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTCLR_CCLR6() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTCLR_CCLR7(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTCLR_CCLR7() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTCLR_CCLR8(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTCLR_CCLR8() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTCLR_CCLR9(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTCLR_CCLR9() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x200) >> 9
}

// GPT164.GTSSR: General PWM Timer Start Source Select Register
func (o *GPT164_Type) SetGTSSR_SSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTSSR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTSSR_SSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTSSR_SSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTSSR_SSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTSSR_SSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTSSR_SSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTSSR_SSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTSSR_SSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTSSR_SSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTSSR_SSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTSSR_SSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTSSR_SSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTSSR_SSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTSSR_SSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTSSR_SSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTSSR_SSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTSSR_SSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTSSR_SSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTSSR_SSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTSSR_SSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTSSR_SSELCA(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTSSR_SSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTSSR_SSELCB(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTSSR_SSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTSSR_SSELCC(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTSSR_SSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTSSR_SSELCD(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTSSR_SSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTSSR_CSTRT(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT164_Type) GetGTSSR_CSTRT() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000000) >> 31
}

// GPT164.GTPSR: General PWM Timer Stop Source Select Register
func (o *GPT164_Type) SetGTPSR_PSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTPSR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTPSR_PSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTPSR_PSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTPSR_PSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTPSR_PSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTPSR_PSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTPSR_PSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTPSR_PSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTPSR_PSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTPSR_PSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTPSR_PSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTPSR_PSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTPSR_PSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTPSR_PSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTPSR_PSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTPSR_PSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTPSR_PSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTPSR_PSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTPSR_PSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTPSR_PSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTPSR_PSELCA(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTPSR_PSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTPSR_PSELCB(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTPSR_PSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTPSR_PSELCC(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTPSR_PSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTPSR_PSELCD(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTPSR_PSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTPSR_CSTOP(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT164_Type) GetGTPSR_CSTOP() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000000) >> 31
}

// GPT164.GTCSR: General PWM Timer Clear Source Select Register
func (o *GPT164_Type) SetGTCSR_CSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTCSR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTCSR_CSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTCSR_CSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTCSR_CSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTCSR_CSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTCSR_CSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTCSR_CSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTCSR_CSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTCSR_CSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTCSR_CSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTCSR_CSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTCSR_CSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTCSR_CSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTCSR_CSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTCSR_CSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTCSR_CSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTCSR_CSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTCSR_CSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTCSR_CSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTCSR_CSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTCSR_CSELCA(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTCSR_CSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTCSR_CSELCB(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTCSR_CSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTCSR_CSELCC(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTCSR_CSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTCSR_CSELCD(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTCSR_CSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTCSR_CCLR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT164_Type) GetGTCSR_CCLR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000000) >> 31
}

// GPT164.GTUPSR: General PWM Timer Up Count Source Select Register
func (o *GPT164_Type) SetGTUPSR_USGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTUPSR_USGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTUPSR_USGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTUPSR_USGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTUPSR_USCARBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTUPSR_USCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTUPSR_USCARBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTUPSR_USCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTUPSR_USCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTUPSR_USCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTUPSR_USCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTUPSR_USCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTUPSR_USCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTUPSR_USCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTUPSR_USCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTUPSR_USCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTUPSR_USCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTUPSR_USCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTUPSR_USCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTUPSR_USCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTUPSR_USELCA(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTUPSR_USELCA() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTUPSR_USELCB(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTUPSR_USELCB() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTUPSR_USELCC(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTUPSR_USELCC() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTUPSR_USELCD(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTUPSR_USELCD() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80000) >> 19
}

// GPT164.GTDNSR: General PWM Timer Down Count Source Select Register
func (o *GPT164_Type) SetGTDNSR_DSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTDNSR_DSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTDNSR_DSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTDNSR_DSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTDNSR_DSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTDNSR_DSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTDNSR_DSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTDNSR_DSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTDNSR_DSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTDNSR_DSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTDNSR_DSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTDNSR_DSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTDNSR_DSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTDNSR_DSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTDNSR_DSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTDNSR_DSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTDNSR_DSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTDNSR_DSELCA(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTDNSR_DSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTDNSR_DSELCB(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTDNSR_DSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTDNSR_DSELCC(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTDNSR_DSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTDNSR_DSELCD(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTDNSR_DSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80000) >> 19
}

// GPT164.GTICASR: General PWM Timer Input Capture Source Select Register A
func (o *GPT164_Type) SetGTICASR_ASGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICASR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTICASR_ASGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTICASR_ASGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTICASR_ASGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTICASR_ASCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTICASR_ASCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTICASR_ASCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTICASR_ASCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTICASR_ASCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTICASR_ASCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTICASR_ASCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTICASR_ASCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTICASR_ASCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTICASR_ASCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTICASR_ASCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTICASR_ASCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTICASR_ASCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTICASR_ASCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTICASR_ASCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTICASR_ASCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTICASR_ASELCA(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTICASR_ASELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTICASR_ASELCB(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTICASR_ASELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTICASR_ASELCC(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTICASR_ASELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTICASR_ASELCD(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTICASR_ASELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80000) >> 19
}

// GPT164.GTICBSR: General PWM Timer Input Capture Source Select Register B
func (o *GPT164_Type) SetGTICBSR_BSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTICBSR_BSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTICBSR_BSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTICBSR_BSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTICBSR_BSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTICBSR_BSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTICBSR_BSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTICBSR_BSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTICBSR_BSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTICBSR_BSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTICBSR_BSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTICBSR_BSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTICBSR_BSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTICBSR_BSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTICBSR_BSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTICBSR_BSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTICBSR_BSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTICBSR_BSELCA(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTICBSR_BSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTICBSR_BSELCB(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTICBSR_BSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTICBSR_BSELCC(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTICBSR_BSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTICBSR_BSELCD(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTICBSR_BSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80000) >> 19
}

// GPT164.GTCR: General PWM Timer Control Register
func (o *GPT164_Type) SetGTCR_CST(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTCR_CST() uint32 {
	return volatile.LoadUint32(&o.GTCR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTCR_MD(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x70000)|value<<16)
}
func (o *GPT164_Type) GetGTCR_MD() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x70000) >> 16
}
func (o *GPT164_Type) SetGTCR_TPCS(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x7000000)|value<<24)
}
func (o *GPT164_Type) GetGTCR_TPCS() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x7000000) >> 24
}

// GPT164.GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
func (o *GPT164_Type) SetGTUDDTYC_UD(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTUDDTYC_UD() uint32 {
	return volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x1
}
func (o *GPT164_Type) SetGTUDDTYC_UDF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTUDDTYC_UDF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTUDDTYC_OADTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x30000)|value<<16)
}
func (o *GPT164_Type) GetGTUDDTYC_OADTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x30000) >> 16
}
func (o *GPT164_Type) SetGTUDDTYC_OADTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTUDDTYC_OADTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTUDDTYC_OADTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTUDDTYC_OADTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTUDDTYC_OBDTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT164_Type) GetGTUDDTYC_OBDTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x3000000) >> 24
}
func (o *GPT164_Type) SetGTUDDTYC_OBDTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT164_Type) GetGTUDDTYC_OBDTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x4000000) >> 26
}
func (o *GPT164_Type) SetGTUDDTYC_OBDTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x8000000)|value<<27)
}
func (o *GPT164_Type) GetGTUDDTYC_OBDTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x8000000) >> 27
}

// GPT164.GTIOR: General PWM Timer I/O Control Register
func (o *GPT164_Type) SetGTIOR_GTIOA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f)|value)
}
func (o *GPT164_Type) GetGTIOR_GTIOA() uint32 {
	return volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f
}
func (o *GPT164_Type) SetGTIOR_OADFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTIOR_OADFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTIOR_OAHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTIOR_OAHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTIOR_OAE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTIOR_OAE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTIOR_OADF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x600)|value<<9)
}
func (o *GPT164_Type) GetGTIOR_OADF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x600) >> 9
}
func (o *GPT164_Type) SetGTIOR_NFAEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTIOR_NFAEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTIOR_NFCSA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc000)|value<<14)
}
func (o *GPT164_Type) GetGTIOR_NFCSA() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc000) >> 14
}
func (o *GPT164_Type) SetGTIOR_GTIOB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f0000)|value<<16)
}
func (o *GPT164_Type) GetGTIOR_GTIOB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f0000) >> 16
}
func (o *GPT164_Type) SetGTIOR_OBDFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTIOR_OBDFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTIOR_OBHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTIOR_OBHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x800000) >> 23
}
func (o *GPT164_Type) SetGTIOR_OBE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT164_Type) GetGTIOR_OBE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1000000) >> 24
}
func (o *GPT164_Type) SetGTIOR_OBDF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x6000000)|value<<25)
}
func (o *GPT164_Type) GetGTIOR_OBDF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x6000000) >> 25
}
func (o *GPT164_Type) SetGTIOR_NFBEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT164_Type) GetGTIOR_NFBEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20000000) >> 29
}
func (o *GPT164_Type) SetGTIOR_NFCSB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT164_Type) GetGTIOR_NFCSB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc0000000) >> 30
}

// GPT164.GTINTAD: General PWM Timer Interrupt Output Setting Register
func (o *GPT164_Type) SetGTINTAD_GRP(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT164_Type) GetGTINTAD_GRP() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x3000000) >> 24
}
func (o *GPT164_Type) SetGTINTAD_GRPABH(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT164_Type) GetGTINTAD_GRPABH() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x20000000) >> 29
}
func (o *GPT164_Type) SetGTINTAD_GRPABL(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT164_Type) GetGTINTAD_GRPABL() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x40000000) >> 30
}

// GPT164.GTST: General PWM Timer Status Register
func (o *GPT164_Type) SetGTST_TCFA(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTST_TCFA() uint32 {
	return volatile.LoadUint32(&o.GTST.Reg) & 0x1
}
func (o *GPT164_Type) SetGTST_TCFB(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTST_TCFB() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTST_TCFC(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTST_TCFC() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTST_TCFD(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTST_TCFD() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTST_TCFE(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTST_TCFE() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTST_TCFF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTST_TCFF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTST_TCFPO(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTST_TCFPO() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTST_TCFPU(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTST_TCFPU() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTST_TUCF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTST_TUCF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTST_ODF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT164_Type) GetGTST_ODF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1000000) >> 24
}
func (o *GPT164_Type) SetGTST_OABHF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT164_Type) GetGTST_OABHF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20000000) >> 29
}
func (o *GPT164_Type) SetGTST_OABLF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT164_Type) GetGTST_OABLF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40000000) >> 30
}

// GPT164.GTBER: General PWM Timer Buffer Enable Register
func (o *GPT164_Type) SetGTBER_BD0(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTBER_BD0() uint32 {
	return volatile.LoadUint32(&o.GTBER.Reg) & 0x1
}
func (o *GPT164_Type) SetGTBER_BD1(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTBER_BD1() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTBER_CCRA(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x30000)|value<<16)
}
func (o *GPT164_Type) GetGTBER_CCRA() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x30000) >> 16
}
func (o *GPT164_Type) SetGTBER_CCRB(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPT164_Type) GetGTBER_CCRB() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0xc0000) >> 18
}
func (o *GPT164_Type) SetGTBER_PR(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x300000)|value<<20)
}
func (o *GPT164_Type) GetGTBER_PR() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x300000) >> 20
}
func (o *GPT164_Type) SetGTBER_CCRSWT(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTBER_CCRSWT() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x400000) >> 22
}

// GPT164.GTDTCR: General PWM Timer Dead Time Control Register
func (o *GPT164_Type) SetGTDTCR_TDE(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTDTCR_TDE() uint32 {
	return volatile.LoadUint32(&o.GTDTCR.Reg) & 0x1
}

// Output Phase Switching Controller
type GPT_OPS_Type struct {
	OPSCR volatile.Register32 // 0x0
}

// GPT_OPS.OPSCR: Output Phase Switching Control Register
func (o *GPT_OPS_Type) SetOPSCR_UF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x1)|value)
}
func (o *GPT_OPS_Type) GetOPSCR_UF() uint32 {
	return volatile.LoadUint32(&o.OPSCR.Reg) & 0x1
}
func (o *GPT_OPS_Type) SetOPSCR_VF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x2)|value<<1)
}
func (o *GPT_OPS_Type) GetOPSCR_VF() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x2) >> 1
}
func (o *GPT_OPS_Type) SetOPSCR_WF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x4)|value<<2)
}
func (o *GPT_OPS_Type) GetOPSCR_WF() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x4) >> 2
}
func (o *GPT_OPS_Type) SetOPSCR_U(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x10)|value<<4)
}
func (o *GPT_OPS_Type) GetOPSCR_U() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x10) >> 4
}
func (o *GPT_OPS_Type) SetOPSCR_V(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x20)|value<<5)
}
func (o *GPT_OPS_Type) GetOPSCR_V() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x20) >> 5
}
func (o *GPT_OPS_Type) SetOPSCR_W(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x40)|value<<6)
}
func (o *GPT_OPS_Type) GetOPSCR_W() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x40) >> 6
}
func (o *GPT_OPS_Type) SetOPSCR_EN(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x100)|value<<8)
}
func (o *GPT_OPS_Type) GetOPSCR_EN() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x100) >> 8
}
func (o *GPT_OPS_Type) SetOPSCR_FB(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT_OPS_Type) GetOPSCR_FB() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x10000) >> 16
}
func (o *GPT_OPS_Type) SetOPSCR_P(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT_OPS_Type) GetOPSCR_P() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x20000) >> 17
}
func (o *GPT_OPS_Type) SetOPSCR_N(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT_OPS_Type) GetOPSCR_N() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x40000) >> 18
}
func (o *GPT_OPS_Type) SetOPSCR_INV(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT_OPS_Type) GetOPSCR_INV() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x80000) >> 19
}
func (o *GPT_OPS_Type) SetOPSCR_RV(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT_OPS_Type) GetOPSCR_RV() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x100000) >> 20
}
func (o *GPT_OPS_Type) SetOPSCR_ALIGN(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT_OPS_Type) GetOPSCR_ALIGN() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x200000) >> 21
}
func (o *GPT_OPS_Type) SetOPSCR_GRP(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT_OPS_Type) GetOPSCR_GRP() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x3000000) >> 24
}
func (o *GPT_OPS_Type) SetOPSCR_GODF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT_OPS_Type) GetOPSCR_GODF() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x4000000) >> 26
}
func (o *GPT_OPS_Type) SetOPSCR_NFEN(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT_OPS_Type) GetOPSCR_NFEN() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x20000000) >> 29
}
func (o *GPT_OPS_Type) SetOPSCR_NFCS(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT_OPS_Type) GetOPSCR_NFCS() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0xc0000000) >> 30
}

// Key Interrupt Function
type KINT_Type struct {
	KRCTL volatile.Register8 // 0x0
	_     [3]byte
	KRF   volatile.Register8 // 0x4
	_     [3]byte
	KRM   volatile.Register8 // 0x8
}

// KINT.KRCTL: Key Return Control Register
func (o *KINT_Type) SetKRCTL_KREG(value uint8) {
	volatile.StoreUint8(&o.KRCTL.Reg, volatile.LoadUint8(&o.KRCTL.Reg)&^(0x1)|value)
}
func (o *KINT_Type) GetKRCTL_KREG() uint8 {
	return volatile.LoadUint8(&o.KRCTL.Reg) & 0x1
}
func (o *KINT_Type) SetKRCTL_KRMD(value uint8) {
	volatile.StoreUint8(&o.KRCTL.Reg, volatile.LoadUint8(&o.KRCTL.Reg)&^(0x80)|value<<7)
}
func (o *KINT_Type) GetKRCTL_KRMD() uint8 {
	return (volatile.LoadUint8(&o.KRCTL.Reg) & 0x80) >> 7
}

// KINT.KRF: Key Return Flag Register
func (o *KINT_Type) SetKRF_KIF0(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x1)|value)
}
func (o *KINT_Type) GetKRF_KIF0() uint8 {
	return volatile.LoadUint8(&o.KRF.Reg) & 0x1
}
func (o *KINT_Type) SetKRF_KIF1(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x2)|value<<1)
}
func (o *KINT_Type) GetKRF_KIF1() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x2) >> 1
}
func (o *KINT_Type) SetKRF_KIF2(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x4)|value<<2)
}
func (o *KINT_Type) GetKRF_KIF2() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x4) >> 2
}
func (o *KINT_Type) SetKRF_KIF3(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x8)|value<<3)
}
func (o *KINT_Type) GetKRF_KIF3() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x8) >> 3
}
func (o *KINT_Type) SetKRF_KIF4(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x10)|value<<4)
}
func (o *KINT_Type) GetKRF_KIF4() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x10) >> 4
}
func (o *KINT_Type) SetKRF_KIF5(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x20)|value<<5)
}
func (o *KINT_Type) GetKRF_KIF5() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x20) >> 5
}
func (o *KINT_Type) SetKRF_KIF6(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x40)|value<<6)
}
func (o *KINT_Type) GetKRF_KIF6() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x40) >> 6
}
func (o *KINT_Type) SetKRF_KIF7(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x80)|value<<7)
}
func (o *KINT_Type) GetKRF_KIF7() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x80) >> 7
}

// KINT.KRM: Key Return Mode Register
func (o *KINT_Type) SetKRM_KIMC0(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x1)|value)
}
func (o *KINT_Type) GetKRM_KIMC0() uint8 {
	return volatile.LoadUint8(&o.KRM.Reg) & 0x1
}
func (o *KINT_Type) SetKRM_KIMC1(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x2)|value<<1)
}
func (o *KINT_Type) GetKRM_KIMC1() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x2) >> 1
}
func (o *KINT_Type) SetKRM_KIMC2(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x4)|value<<2)
}
func (o *KINT_Type) GetKRM_KIMC2() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x4) >> 2
}
func (o *KINT_Type) SetKRM_KIMC3(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x8)|value<<3)
}
func (o *KINT_Type) GetKRM_KIMC3() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x8) >> 3
}
func (o *KINT_Type) SetKRM_KIMC4(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x10)|value<<4)
}
func (o *KINT_Type) GetKRM_KIMC4() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x10) >> 4
}
func (o *KINT_Type) SetKRM_KIMC5(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x20)|value<<5)
}
func (o *KINT_Type) GetKRM_KIMC5() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x20) >> 5
}
func (o *KINT_Type) SetKRM_KIMC6(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x40)|value<<6)
}
func (o *KINT_Type) GetKRM_KIMC6() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x40) >> 6
}
func (o *KINT_Type) SetKRM_KIMC7(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x80)|value<<7)
}
func (o *KINT_Type) GetKRM_KIMC7() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x80) >> 7
}

// Capacitive Touch Sensing Unit
type CTSU_Type struct {
	CTSUCRA    volatile.Register32 // 0x0
	CTSUCRB    volatile.Register32 // 0x4
	CTSUMCH    volatile.Register32 // 0x8
	CTSUCHACA  volatile.Register32 // 0xC
	CTSUCHACB  volatile.Register32 // 0x10
	CTSUCHTRCA volatile.Register32 // 0x14
	CTSUCHTRCB volatile.Register32 // 0x18
	CTSUSR     volatile.Register32 // 0x1C
	CTSUSO     volatile.Register32 // 0x20
	CTSUSCNT   volatile.Register32 // 0x24
	CTSUCALIB  volatile.Register32 // 0x28
	CTSUSUCLKA volatile.Register32 // 0x2C
	CTSUSUCLKB volatile.Register32 // 0x30
	CTSUCFCCNT volatile.Register32 // 0x34
}

// CTSU.CTSUCRA: CTSU Control Register A
func (o *CTSU_Type) SetCTSUCRA_STRT(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x1)|value)
}
func (o *CTSU_Type) GetCTSUCRA_STRT() uint32 {
	return volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x1
}
func (o *CTSU_Type) SetCTSUCRA_CAP(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x2)|value<<1)
}
func (o *CTSU_Type) GetCTSUCRA_CAP() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x2) >> 1
}
func (o *CTSU_Type) SetCTSUCRA_SNZ(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x4)|value<<2)
}
func (o *CTSU_Type) GetCTSUCRA_SNZ() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x4) >> 2
}
func (o *CTSU_Type) SetCTSUCRA_CFCON(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x8)|value<<3)
}
func (o *CTSU_Type) GetCTSUCRA_CFCON() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x8) >> 3
}
func (o *CTSU_Type) SetCTSUCRA_INIT(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x10)|value<<4)
}
func (o *CTSU_Type) GetCTSUCRA_INIT() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x10) >> 4
}
func (o *CTSU_Type) SetCTSUCRA_PUMPON(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x20)|value<<5)
}
func (o *CTSU_Type) GetCTSUCRA_PUMPON() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x20) >> 5
}
func (o *CTSU_Type) SetCTSUCRA_TXVSEL(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0xc0)|value<<6)
}
func (o *CTSU_Type) GetCTSUCRA_TXVSEL() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0xc0) >> 6
}
func (o *CTSU_Type) SetCTSUCRA_PON(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x100)|value<<8)
}
func (o *CTSU_Type) GetCTSUCRA_PON() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x100) >> 8
}
func (o *CTSU_Type) SetCTSUCRA_CSW(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x200)|value<<9)
}
func (o *CTSU_Type) GetCTSUCRA_CSW() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x200) >> 9
}
func (o *CTSU_Type) SetCTSUCRA_ATUNE0(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x400)|value<<10)
}
func (o *CTSU_Type) GetCTSUCRA_ATUNE0() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x400) >> 10
}
func (o *CTSU_Type) SetCTSUCRA_ATUNE1(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x800)|value<<11)
}
func (o *CTSU_Type) GetCTSUCRA_ATUNE1() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x800) >> 11
}
func (o *CTSU_Type) SetCTSUCRA_CLK(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x3000)|value<<12)
}
func (o *CTSU_Type) GetCTSUCRA_CLK() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x3000) >> 12
}
func (o *CTSU_Type) SetCTSUCRA_MD0(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x4000)|value<<14)
}
func (o *CTSU_Type) GetCTSUCRA_MD0() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x4000) >> 14
}
func (o *CTSU_Type) SetCTSUCRA_MD1(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x8000)|value<<15)
}
func (o *CTSU_Type) GetCTSUCRA_MD1() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x8000) >> 15
}
func (o *CTSU_Type) SetCTSUCRA_MD2(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x10000)|value<<16)
}
func (o *CTSU_Type) GetCTSUCRA_MD2() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x10000) >> 16
}
func (o *CTSU_Type) SetCTSUCRA_ATUNE2(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x20000)|value<<17)
}
func (o *CTSU_Type) GetCTSUCRA_ATUNE2() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x20000) >> 17
}
func (o *CTSU_Type) SetCTSUCRA_LOAD(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0xc0000)|value<<18)
}
func (o *CTSU_Type) GetCTSUCRA_LOAD() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0xc0000) >> 18
}
func (o *CTSU_Type) SetCTSUCRA_POSEL(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x300000)|value<<20)
}
func (o *CTSU_Type) GetCTSUCRA_POSEL() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x300000) >> 20
}
func (o *CTSU_Type) SetCTSUCRA_SDPSEL(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x400000)|value<<22)
}
func (o *CTSU_Type) GetCTSUCRA_SDPSEL() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x400000) >> 22
}
func (o *CTSU_Type) SetCTSUCRA_PCSEL(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x800000)|value<<23)
}
func (o *CTSU_Type) GetCTSUCRA_PCSEL() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x800000) >> 23
}
func (o *CTSU_Type) SetCTSUCRA_STCLK(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x3f000000)|value<<24)
}
func (o *CTSU_Type) GetCTSUCRA_STCLK() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x3f000000) >> 24
}
func (o *CTSU_Type) SetCTSUCRA_DCMODE(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x40000000)|value<<30)
}
func (o *CTSU_Type) GetCTSUCRA_DCMODE() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x40000000) >> 30
}
func (o *CTSU_Type) SetCTSUCRA_DCBACK(value uint32) {
	volatile.StoreUint32(&o.CTSUCRA.Reg, volatile.LoadUint32(&o.CTSUCRA.Reg)&^(0x80000000)|value<<31)
}
func (o *CTSU_Type) GetCTSUCRA_DCBACK() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRA.Reg) & 0x80000000) >> 31
}

// CTSU.CTSUCRB: CTSU Control Register B
func (o *CTSU_Type) SetCTSUCRB_PRRATIO(value uint32) {
	volatile.StoreUint32(&o.CTSUCRB.Reg, volatile.LoadUint32(&o.CTSUCRB.Reg)&^(0xf)|value)
}
func (o *CTSU_Type) GetCTSUCRB_PRRATIO() uint32 {
	return volatile.LoadUint32(&o.CTSUCRB.Reg) & 0xf
}
func (o *CTSU_Type) SetCTSUCRB_PRMODE(value uint32) {
	volatile.StoreUint32(&o.CTSUCRB.Reg, volatile.LoadUint32(&o.CTSUCRB.Reg)&^(0x30)|value<<4)
}
func (o *CTSU_Type) GetCTSUCRB_PRMODE() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRB.Reg) & 0x30) >> 4
}
func (o *CTSU_Type) SetCTSUCRB_SOFF(value uint32) {
	volatile.StoreUint32(&o.CTSUCRB.Reg, volatile.LoadUint32(&o.CTSUCRB.Reg)&^(0x40)|value<<6)
}
func (o *CTSU_Type) GetCTSUCRB_SOFF() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRB.Reg) & 0x40) >> 6
}
func (o *CTSU_Type) SetCTSUCRB_PROFF(value uint32) {
	volatile.StoreUint32(&o.CTSUCRB.Reg, volatile.LoadUint32(&o.CTSUCRB.Reg)&^(0x80)|value<<7)
}
func (o *CTSU_Type) GetCTSUCRB_PROFF() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRB.Reg) & 0x80) >> 7
}
func (o *CTSU_Type) SetCTSUCRB_SST(value uint32) {
	volatile.StoreUint32(&o.CTSUCRB.Reg, volatile.LoadUint32(&o.CTSUCRB.Reg)&^(0xff00)|value<<8)
}
func (o *CTSU_Type) GetCTSUCRB_SST() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRB.Reg) & 0xff00) >> 8
}
func (o *CTSU_Type) SetCTSUCRB_SSMOD(value uint32) {
	volatile.StoreUint32(&o.CTSUCRB.Reg, volatile.LoadUint32(&o.CTSUCRB.Reg)&^(0x7000000)|value<<24)
}
func (o *CTSU_Type) GetCTSUCRB_SSMOD() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRB.Reg) & 0x7000000) >> 24
}
func (o *CTSU_Type) SetCTSUCRB_SSCNT(value uint32) {
	volatile.StoreUint32(&o.CTSUCRB.Reg, volatile.LoadUint32(&o.CTSUCRB.Reg)&^(0x30000000)|value<<28)
}
func (o *CTSU_Type) GetCTSUCRB_SSCNT() uint32 {
	return (volatile.LoadUint32(&o.CTSUCRB.Reg) & 0x30000000) >> 28
}

// CTSU.CTSUMCH: CTSU Measurement Channel Register
func (o *CTSU_Type) SetCTSUMCH_MCH0(value uint32) {
	volatile.StoreUint32(&o.CTSUMCH.Reg, volatile.LoadUint32(&o.CTSUMCH.Reg)&^(0x3f)|value)
}
func (o *CTSU_Type) GetCTSUMCH_MCH0() uint32 {
	return volatile.LoadUint32(&o.CTSUMCH.Reg) & 0x3f
}
func (o *CTSU_Type) SetCTSUMCH_MCH1(value uint32) {
	volatile.StoreUint32(&o.CTSUMCH.Reg, volatile.LoadUint32(&o.CTSUMCH.Reg)&^(0x3f00)|value<<8)
}
func (o *CTSU_Type) GetCTSUMCH_MCH1() uint32 {
	return (volatile.LoadUint32(&o.CTSUMCH.Reg) & 0x3f00) >> 8
}
func (o *CTSU_Type) SetCTSUMCH_MCA0(value uint32) {
	volatile.StoreUint32(&o.CTSUMCH.Reg, volatile.LoadUint32(&o.CTSUMCH.Reg)&^(0x10000)|value<<16)
}
func (o *CTSU_Type) GetCTSUMCH_MCA0() uint32 {
	return (volatile.LoadUint32(&o.CTSUMCH.Reg) & 0x10000) >> 16
}
func (o *CTSU_Type) SetCTSUMCH_MCA1(value uint32) {
	volatile.StoreUint32(&o.CTSUMCH.Reg, volatile.LoadUint32(&o.CTSUMCH.Reg)&^(0x20000)|value<<17)
}
func (o *CTSU_Type) GetCTSUMCH_MCA1() uint32 {
	return (volatile.LoadUint32(&o.CTSUMCH.Reg) & 0x20000) >> 17
}
func (o *CTSU_Type) SetCTSUMCH_MCA2(value uint32) {
	volatile.StoreUint32(&o.CTSUMCH.Reg, volatile.LoadUint32(&o.CTSUMCH.Reg)&^(0x40000)|value<<18)
}
func (o *CTSU_Type) GetCTSUMCH_MCA2() uint32 {
	return (volatile.LoadUint32(&o.CTSUMCH.Reg) & 0x40000) >> 18
}
func (o *CTSU_Type) SetCTSUMCH_MCA3(value uint32) {
	volatile.StoreUint32(&o.CTSUMCH.Reg, volatile.LoadUint32(&o.CTSUMCH.Reg)&^(0x80000)|value<<19)
}
func (o *CTSU_Type) GetCTSUMCH_MCA3() uint32 {
	return (volatile.LoadUint32(&o.CTSUMCH.Reg) & 0x80000) >> 19
}

// CTSU.CTSUCHACA: CTSU Channel Enable Control Register A
func (o *CTSU_Type) SetCTSUCHACA_CHAC00(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x1)|value)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC00() uint32 {
	return volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x1
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC02(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x4)|value<<2)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC02() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x4) >> 2
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC04(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x10)|value<<4)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC04() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x10) >> 4
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC05(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x20)|value<<5)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC05() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x20) >> 5
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC06(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x40)|value<<6)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC06() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x40) >> 6
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC07(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x80)|value<<7)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC07() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x80) >> 7
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC08(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x100)|value<<8)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC08() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x100) >> 8
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC09(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x200)|value<<9)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC09() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x200) >> 9
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC10(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x400)|value<<10)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC10() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x400) >> 10
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC11(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x800)|value<<11)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC11() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x800) >> 11
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC12(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x1000)|value<<12)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC12() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x1000) >> 12
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC13(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x2000)|value<<13)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC13() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x2000) >> 13
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC14(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x4000)|value<<14)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC14() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x4000) >> 14
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC15(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x8000)|value<<15)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC15() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x8000) >> 15
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC16(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x10000)|value<<16)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC16() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x10000) >> 16
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC17(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x20000)|value<<17)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC17() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x20000) >> 17
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC18(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x40000)|value<<18)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC18() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x40000) >> 18
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC21(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x200000)|value<<21)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC21() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x200000) >> 21
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC22(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x400000)|value<<22)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC22() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x400000) >> 22
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC23(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x800000)|value<<23)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC23() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x800000) >> 23
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC24(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x1000000)|value<<24)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC24() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x1000000) >> 24
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC25(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x2000000)|value<<25)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC25() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x2000000) >> 25
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC26(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x4000000)|value<<26)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC26() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x4000000) >> 26
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC27(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x8000000)|value<<27)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC27() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x8000000) >> 27
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC28(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x10000000)|value<<28)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC28() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x10000000) >> 28
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC29(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x20000000)|value<<29)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC29() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x20000000) >> 29
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC30(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x40000000)|value<<30)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC30() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x40000000) >> 30
}
func (o *CTSU_Type) SetCTSUCHACA_CHAC31(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACA.Reg, volatile.LoadUint32(&o.CTSUCHACA.Reg)&^(0x80000000)|value<<31)
}
func (o *CTSU_Type) GetCTSUCHACA_CHAC31() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACA.Reg) & 0x80000000) >> 31
}

// CTSU.CTSUCHACB: CTSU Channel Enable Control Register B
func (o *CTSU_Type) SetCTSUCHACB_CHAC32(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACB.Reg, volatile.LoadUint32(&o.CTSUCHACB.Reg)&^(0x1)|value)
}
func (o *CTSU_Type) GetCTSUCHACB_CHAC32() uint32 {
	return volatile.LoadUint32(&o.CTSUCHACB.Reg) & 0x1
}
func (o *CTSU_Type) SetCTSUCHACB_CHAC33(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACB.Reg, volatile.LoadUint32(&o.CTSUCHACB.Reg)&^(0x2)|value<<1)
}
func (o *CTSU_Type) GetCTSUCHACB_CHAC33() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACB.Reg) & 0x2) >> 1
}
func (o *CTSU_Type) SetCTSUCHACB_CHAC34(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACB.Reg, volatile.LoadUint32(&o.CTSUCHACB.Reg)&^(0x4)|value<<2)
}
func (o *CTSU_Type) GetCTSUCHACB_CHAC34() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACB.Reg) & 0x4) >> 2
}
func (o *CTSU_Type) SetCTSUCHACB_CHAC35(value uint32) {
	volatile.StoreUint32(&o.CTSUCHACB.Reg, volatile.LoadUint32(&o.CTSUCHACB.Reg)&^(0x8)|value<<3)
}
func (o *CTSU_Type) GetCTSUCHACB_CHAC35() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHACB.Reg) & 0x8) >> 3
}

// CTSU.CTSUCHTRCA: CTSU Channel Transmit/Receive Control Register A
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC00(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x1)|value)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC00() uint32 {
	return volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x1
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC02(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x4)|value<<2)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC02() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x4) >> 2
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC04(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x10)|value<<4)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC04() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x10) >> 4
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC05(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x20)|value<<5)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC05() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x20) >> 5
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC06(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x40)|value<<6)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC06() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x40) >> 6
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC07(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x80)|value<<7)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC07() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x80) >> 7
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC08(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x100)|value<<8)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC08() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x100) >> 8
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC09(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x200)|value<<9)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC09() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x200) >> 9
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC10(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x400)|value<<10)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC10() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x400) >> 10
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC11(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x800)|value<<11)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC11() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x800) >> 11
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC12(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x1000)|value<<12)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC12() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x1000) >> 12
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC13(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x2000)|value<<13)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC13() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x2000) >> 13
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC14(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x4000)|value<<14)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC14() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x4000) >> 14
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC15(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x8000)|value<<15)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC15() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x8000) >> 15
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC16(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x10000)|value<<16)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC16() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x10000) >> 16
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC17(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x20000)|value<<17)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC17() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x20000) >> 17
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC18(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x40000)|value<<18)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC18() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x40000) >> 18
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC21(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x200000)|value<<21)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC21() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x200000) >> 21
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC22(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x400000)|value<<22)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC22() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x400000) >> 22
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC23(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x800000)|value<<23)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC23() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x800000) >> 23
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC24(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x1000000)|value<<24)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC24() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x1000000) >> 24
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC25(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x2000000)|value<<25)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC25() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x2000000) >> 25
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC26(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x4000000)|value<<26)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC26() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x4000000) >> 26
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC27(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x8000000)|value<<27)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC27() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x8000000) >> 27
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC28(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x10000000)|value<<28)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC28() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x10000000) >> 28
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC29(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x20000000)|value<<29)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC29() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x20000000) >> 29
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC30(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x40000000)|value<<30)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC30() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x40000000) >> 30
}
func (o *CTSU_Type) SetCTSUCHTRCA_CHTRC31(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCA.Reg, volatile.LoadUint32(&o.CTSUCHTRCA.Reg)&^(0x80000000)|value<<31)
}
func (o *CTSU_Type) GetCTSUCHTRCA_CHTRC31() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCA.Reg) & 0x80000000) >> 31
}

// CTSU.CTSUCHTRCB: CTSU Channel Transmit/Receive Control Register B
func (o *CTSU_Type) SetCTSUCHTRCB_CHTRC32(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCB.Reg, volatile.LoadUint32(&o.CTSUCHTRCB.Reg)&^(0x1)|value)
}
func (o *CTSU_Type) GetCTSUCHTRCB_CHTRC32() uint32 {
	return volatile.LoadUint32(&o.CTSUCHTRCB.Reg) & 0x1
}
func (o *CTSU_Type) SetCTSUCHTRCB_CHTRC33(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCB.Reg, volatile.LoadUint32(&o.CTSUCHTRCB.Reg)&^(0x2)|value<<1)
}
func (o *CTSU_Type) GetCTSUCHTRCB_CHTRC33() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCB.Reg) & 0x2) >> 1
}
func (o *CTSU_Type) SetCTSUCHTRCB_CHTRC34(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCB.Reg, volatile.LoadUint32(&o.CTSUCHTRCB.Reg)&^(0x4)|value<<2)
}
func (o *CTSU_Type) GetCTSUCHTRCB_CHTRC34() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCB.Reg) & 0x4) >> 2
}
func (o *CTSU_Type) SetCTSUCHTRCB_CHTRC35(value uint32) {
	volatile.StoreUint32(&o.CTSUCHTRCB.Reg, volatile.LoadUint32(&o.CTSUCHTRCB.Reg)&^(0x8)|value<<3)
}
func (o *CTSU_Type) GetCTSUCHTRCB_CHTRC35() uint32 {
	return (volatile.LoadUint32(&o.CTSUCHTRCB.Reg) & 0x8) >> 3
}

// CTSU.CTSUSR: CTSU Status Register
func (o *CTSU_Type) SetCTSUSR_MFC(value uint32) {
	volatile.StoreUint32(&o.CTSUSR.Reg, volatile.LoadUint32(&o.CTSUSR.Reg)&^(0x3)|value)
}
func (o *CTSU_Type) GetCTSUSR_MFC() uint32 {
	return volatile.LoadUint32(&o.CTSUSR.Reg) & 0x3
}
func (o *CTSU_Type) SetCTSUSR_ICOMPRST(value uint32) {
	volatile.StoreUint32(&o.CTSUSR.Reg, volatile.LoadUint32(&o.CTSUSR.Reg)&^(0x20)|value<<5)
}
func (o *CTSU_Type) GetCTSUSR_ICOMPRST() uint32 {
	return (volatile.LoadUint32(&o.CTSUSR.Reg) & 0x20) >> 5
}
func (o *CTSU_Type) SetCTSUSR_ICOMP1(value uint32) {
	volatile.StoreUint32(&o.CTSUSR.Reg, volatile.LoadUint32(&o.CTSUSR.Reg)&^(0x40)|value<<6)
}
func (o *CTSU_Type) GetCTSUSR_ICOMP1() uint32 {
	return (volatile.LoadUint32(&o.CTSUSR.Reg) & 0x40) >> 6
}
func (o *CTSU_Type) SetCTSUSR_ICOMP0(value uint32) {
	volatile.StoreUint32(&o.CTSUSR.Reg, volatile.LoadUint32(&o.CTSUSR.Reg)&^(0x80)|value<<7)
}
func (o *CTSU_Type) GetCTSUSR_ICOMP0() uint32 {
	return (volatile.LoadUint32(&o.CTSUSR.Reg) & 0x80) >> 7
}
func (o *CTSU_Type) SetCTSUSR_STC(value uint32) {
	volatile.StoreUint32(&o.CTSUSR.Reg, volatile.LoadUint32(&o.CTSUSR.Reg)&^(0x700)|value<<8)
}
func (o *CTSU_Type) GetCTSUSR_STC() uint32 {
	return (volatile.LoadUint32(&o.CTSUSR.Reg) & 0x700) >> 8
}
func (o *CTSU_Type) SetCTSUSR_DTSR(value uint32) {
	volatile.StoreUint32(&o.CTSUSR.Reg, volatile.LoadUint32(&o.CTSUSR.Reg)&^(0x1000)|value<<12)
}
func (o *CTSU_Type) GetCTSUSR_DTSR() uint32 {
	return (volatile.LoadUint32(&o.CTSUSR.Reg) & 0x1000) >> 12
}
func (o *CTSU_Type) SetCTSUSR_SENSOVF(value uint32) {
	volatile.StoreUint32(&o.CTSUSR.Reg, volatile.LoadUint32(&o.CTSUSR.Reg)&^(0x2000)|value<<13)
}
func (o *CTSU_Type) GetCTSUSR_SENSOVF() uint32 {
	return (volatile.LoadUint32(&o.CTSUSR.Reg) & 0x2000) >> 13
}
func (o *CTSU_Type) SetCTSUSR_SUOVF(value uint32) {
	volatile.StoreUint32(&o.CTSUSR.Reg, volatile.LoadUint32(&o.CTSUSR.Reg)&^(0x4000)|value<<14)
}
func (o *CTSU_Type) GetCTSUSR_SUOVF() uint32 {
	return (volatile.LoadUint32(&o.CTSUSR.Reg) & 0x4000) >> 14
}
func (o *CTSU_Type) SetCTSUSR_PS(value uint32) {
	volatile.StoreUint32(&o.CTSUSR.Reg, volatile.LoadUint32(&o.CTSUSR.Reg)&^(0x8000)|value<<15)
}
func (o *CTSU_Type) GetCTSUSR_PS() uint32 {
	return (volatile.LoadUint32(&o.CTSUSR.Reg) & 0x8000) >> 15
}
func (o *CTSU_Type) SetCTSUSR_CFCRDCH(value uint32) {
	volatile.StoreUint32(&o.CTSUSR.Reg, volatile.LoadUint32(&o.CTSUSR.Reg)&^(0x3f0000)|value<<16)
}
func (o *CTSU_Type) GetCTSUSR_CFCRDCH() uint32 {
	return (volatile.LoadUint32(&o.CTSUSR.Reg) & 0x3f0000) >> 16
}

// CTSU.CTSUSO: CTSU Sensor Offset Register
func (o *CTSU_Type) SetCTSUSO_SO(value uint32) {
	volatile.StoreUint32(&o.CTSUSO.Reg, volatile.LoadUint32(&o.CTSUSO.Reg)&^(0x3ff)|value)
}
func (o *CTSU_Type) GetCTSUSO_SO() uint32 {
	return volatile.LoadUint32(&o.CTSUSO.Reg) & 0x3ff
}
func (o *CTSU_Type) SetCTSUSO_SNUM(value uint32) {
	volatile.StoreUint32(&o.CTSUSO.Reg, volatile.LoadUint32(&o.CTSUSO.Reg)&^(0x3fc00)|value<<10)
}
func (o *CTSU_Type) GetCTSUSO_SNUM() uint32 {
	return (volatile.LoadUint32(&o.CTSUSO.Reg) & 0x3fc00) >> 10
}
func (o *CTSU_Type) SetCTSUSO_SSDIV(value uint32) {
	volatile.StoreUint32(&o.CTSUSO.Reg, volatile.LoadUint32(&o.CTSUSO.Reg)&^(0xf00000)|value<<20)
}
func (o *CTSU_Type) GetCTSUSO_SSDIV() uint32 {
	return (volatile.LoadUint32(&o.CTSUSO.Reg) & 0xf00000) >> 20
}
func (o *CTSU_Type) SetCTSUSO_SDPA(value uint32) {
	volatile.StoreUint32(&o.CTSUSO.Reg, volatile.LoadUint32(&o.CTSUSO.Reg)&^(0xff000000)|value<<24)
}
func (o *CTSU_Type) GetCTSUSO_SDPA() uint32 {
	return (volatile.LoadUint32(&o.CTSUSO.Reg) & 0xff000000) >> 24
}

// CTSU.CTSUSCNT: CTSU Sensor Counter Register
func (o *CTSU_Type) SetCTSUSCNT_SENSCNT(value uint32) {
	volatile.StoreUint32(&o.CTSUSCNT.Reg, volatile.LoadUint32(&o.CTSUSCNT.Reg)&^(0xffff)|value)
}
func (o *CTSU_Type) GetCTSUSCNT_SENSCNT() uint32 {
	return volatile.LoadUint32(&o.CTSUSCNT.Reg) & 0xffff
}
func (o *CTSU_Type) SetCTSUSCNT_SUCKCNT(value uint32) {
	volatile.StoreUint32(&o.CTSUSCNT.Reg, volatile.LoadUint32(&o.CTSUSCNT.Reg)&^(0xffff0000)|value<<16)
}
func (o *CTSU_Type) GetCTSUSCNT_SUCKCNT() uint32 {
	return (volatile.LoadUint32(&o.CTSUSCNT.Reg) & 0xffff0000) >> 16
}

// CTSU.CTSUCALIB: CTSU Calibration Register
func (o *CTSU_Type) SetCTSUCALIB_TSOD(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x4)|value<<2)
}
func (o *CTSU_Type) GetCTSUCALIB_TSOD() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x4) >> 2
}
func (o *CTSU_Type) SetCTSUCALIB_DRV(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x8)|value<<3)
}
func (o *CTSU_Type) GetCTSUCALIB_DRV() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x8) >> 3
}
func (o *CTSU_Type) SetCTSUCALIB_CLKSEL(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x30)|value<<4)
}
func (o *CTSU_Type) GetCTSUCALIB_CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x30) >> 4
}
func (o *CTSU_Type) SetCTSUCALIB_SUCLKEN(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x40)|value<<6)
}
func (o *CTSU_Type) GetCTSUCALIB_SUCLKEN() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x40) >> 6
}
func (o *CTSU_Type) SetCTSUCALIB_TSOC(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x80)|value<<7)
}
func (o *CTSU_Type) GetCTSUCALIB_TSOC() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x80) >> 7
}
func (o *CTSU_Type) SetCTSUCALIB_CNTRDSEL(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x100)|value<<8)
}
func (o *CTSU_Type) GetCTSUCALIB_CNTRDSEL() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x100) >> 8
}
func (o *CTSU_Type) SetCTSUCALIB_IOC(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x200)|value<<9)
}
func (o *CTSU_Type) GetCTSUCALIB_IOC() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x200) >> 9
}
func (o *CTSU_Type) SetCTSUCALIB_CFCRDMD(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x400)|value<<10)
}
func (o *CTSU_Type) GetCTSUCALIB_CFCRDMD() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x400) >> 10
}
func (o *CTSU_Type) SetCTSUCALIB_DCOFF(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x800)|value<<11)
}
func (o *CTSU_Type) GetCTSUCALIB_DCOFF() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x800) >> 11
}
func (o *CTSU_Type) SetCTSUCALIB_CFCSEL(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x3f0000)|value<<16)
}
func (o *CTSU_Type) GetCTSUCALIB_CFCSEL() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x3f0000) >> 16
}
func (o *CTSU_Type) SetCTSUCALIB_CFCMODE(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x400000)|value<<22)
}
func (o *CTSU_Type) GetCTSUCALIB_CFCMODE() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x400000) >> 22
}
func (o *CTSU_Type) SetCTSUCALIB_DACMSEL(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x1000000)|value<<24)
}
func (o *CTSU_Type) GetCTSUCALIB_DACMSEL() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x1000000) >> 24
}
func (o *CTSU_Type) SetCTSUCALIB_DACCARRY(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x2000000)|value<<25)
}
func (o *CTSU_Type) GetCTSUCALIB_DACCARRY() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x2000000) >> 25
}
func (o *CTSU_Type) SetCTSUCALIB_SUMSEL(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x4000000)|value<<26)
}
func (o *CTSU_Type) GetCTSUCALIB_SUMSEL() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x4000000) >> 26
}
func (o *CTSU_Type) SetCTSUCALIB_SUCARRY(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x8000000)|value<<27)
}
func (o *CTSU_Type) GetCTSUCALIB_SUCARRY() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x8000000) >> 27
}
func (o *CTSU_Type) SetCTSUCALIB_DACCLK(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x10000000)|value<<28)
}
func (o *CTSU_Type) GetCTSUCALIB_DACCLK() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x10000000) >> 28
}
func (o *CTSU_Type) SetCTSUCALIB_CCOCLK(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x20000000)|value<<29)
}
func (o *CTSU_Type) GetCTSUCALIB_CCOCLK() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x20000000) >> 29
}
func (o *CTSU_Type) SetCTSUCALIB_CCOCALIB(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x40000000)|value<<30)
}
func (o *CTSU_Type) GetCTSUCALIB_CCOCALIB() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x40000000) >> 30
}
func (o *CTSU_Type) SetCTSUCALIB_TXREV(value uint32) {
	volatile.StoreUint32(&o.CTSUCALIB.Reg, volatile.LoadUint32(&o.CTSUCALIB.Reg)&^(0x80000000)|value<<31)
}
func (o *CTSU_Type) GetCTSUCALIB_TXREV() uint32 {
	return (volatile.LoadUint32(&o.CTSUCALIB.Reg) & 0x80000000) >> 31
}

// CTSU.CTSUSUCLKB: CTSU Sensor Unit Clock Control Register B
func (o *CTSU_Type) SetCTSUSUCLKB_SUADJ2(value uint32) {
	volatile.StoreUint32(&o.CTSUSUCLKB.Reg, volatile.LoadUint32(&o.CTSUSUCLKB.Reg)&^(0xff)|value)
}
func (o *CTSU_Type) GetCTSUSUCLKB_SUADJ2() uint32 {
	return volatile.LoadUint32(&o.CTSUSUCLKB.Reg) & 0xff
}
func (o *CTSU_Type) SetCTSUSUCLKB_SUMULTI2(value uint32) {
	volatile.StoreUint32(&o.CTSUSUCLKB.Reg, volatile.LoadUint32(&o.CTSUSUCLKB.Reg)&^(0xff00)|value<<8)
}
func (o *CTSU_Type) GetCTSUSUCLKB_SUMULTI2() uint32 {
	return (volatile.LoadUint32(&o.CTSUSUCLKB.Reg) & 0xff00) >> 8
}
func (o *CTSU_Type) SetCTSUSUCLKB_SUADJ3(value uint32) {
	volatile.StoreUint32(&o.CTSUSUCLKB.Reg, volatile.LoadUint32(&o.CTSUSUCLKB.Reg)&^(0xff0000)|value<<16)
}
func (o *CTSU_Type) GetCTSUSUCLKB_SUADJ3() uint32 {
	return (volatile.LoadUint32(&o.CTSUSUCLKB.Reg) & 0xff0000) >> 16
}
func (o *CTSU_Type) SetCTSUSUCLKB_SUMULTI3(value uint32) {
	volatile.StoreUint32(&o.CTSUSUCLKB.Reg, volatile.LoadUint32(&o.CTSUSUCLKB.Reg)&^(0xff000000)|value<<24)
}
func (o *CTSU_Type) GetCTSUSUCLKB_SUMULTI3() uint32 {
	return (volatile.LoadUint32(&o.CTSUSUCLKB.Reg) & 0xff000000) >> 24
}

// CTSU.CTSUCFCCNT: CTSU CFC Counter Register
func (o *CTSU_Type) SetCTSUCFCCNT_CFCCNT(value uint32) {
	volatile.StoreUint32(&o.CTSUCFCCNT.Reg, volatile.LoadUint32(&o.CTSUCFCCNT.Reg)&^(0xffff)|value)
}
func (o *CTSU_Type) GetCTSUCFCCNT_CFCCNT() uint32 {
	return volatile.LoadUint32(&o.CTSUCFCCNT.Reg) & 0xffff
}

// Low Power Asynchronous General Purpose Timer 0
type AGT0_Type struct {
	AGT      volatile.Register16 // 0x0
	AGTCMA   volatile.Register16 // 0x2
	AGTCMB   volatile.Register16 // 0x4
	_        [2]byte
	AGTCR    volatile.Register8 // 0x8
	AGTMR1   volatile.Register8 // 0x9
	AGTMR2   volatile.Register8 // 0xA
	_        byte
	AGTIOC   volatile.Register8 // 0xC
	AGTISR   volatile.Register8 // 0xD
	AGTCMSR  volatile.Register8 // 0xE
	AGTIOSEL volatile.Register8 // 0xF
}

// AGT0.AGTCR: AGT Control Register
func (o *AGT0_Type) SetAGTCR_TSTART(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTCR_TSTART() uint8 {
	return volatile.LoadUint8(&o.AGTCR.Reg) & 0x1
}
func (o *AGT0_Type) SetAGTCR_TCSTF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x2)|value<<1)
}
func (o *AGT0_Type) GetAGTCR_TCSTF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x2) >> 1
}
func (o *AGT0_Type) SetAGTCR_TSTOP(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTCR_TSTOP() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTCR_TEDGF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTCR_TEDGF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x10) >> 4
}
func (o *AGT0_Type) SetAGTCR_TUNDF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x20)|value<<5)
}
func (o *AGT0_Type) GetAGTCR_TUNDF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x20) >> 5
}
func (o *AGT0_Type) SetAGTCR_TCMAF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x40)|value<<6)
}
func (o *AGT0_Type) GetAGTCR_TCMAF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x40) >> 6
}
func (o *AGT0_Type) SetAGTCR_TCMBF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTCR_TCMBF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x80) >> 7
}

// AGT0.AGTMR1: AGT Mode Register 1
func (o *AGT0_Type) SetAGTMR1_TMOD(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x7)|value)
}
func (o *AGT0_Type) GetAGTMR1_TMOD() uint8 {
	return volatile.LoadUint8(&o.AGTMR1.Reg) & 0x7
}
func (o *AGT0_Type) SetAGTMR1_TEDGPL(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x8)|value<<3)
}
func (o *AGT0_Type) GetAGTMR1_TEDGPL() uint8 {
	return (volatile.LoadUint8(&o.AGTMR1.Reg) & 0x8) >> 3
}
func (o *AGT0_Type) SetAGTMR1_TCK(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x70)|value<<4)
}
func (o *AGT0_Type) GetAGTMR1_TCK() uint8 {
	return (volatile.LoadUint8(&o.AGTMR1.Reg) & 0x70) >> 4
}

// AGT0.AGTMR2: AGT Mode Register 2
func (o *AGT0_Type) SetAGTMR2_CKS(value uint8) {
	volatile.StoreUint8(&o.AGTMR2.Reg, volatile.LoadUint8(&o.AGTMR2.Reg)&^(0x7)|value)
}
func (o *AGT0_Type) GetAGTMR2_CKS() uint8 {
	return volatile.LoadUint8(&o.AGTMR2.Reg) & 0x7
}
func (o *AGT0_Type) SetAGTMR2_LPM(value uint8) {
	volatile.StoreUint8(&o.AGTMR2.Reg, volatile.LoadUint8(&o.AGTMR2.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTMR2_LPM() uint8 {
	return (volatile.LoadUint8(&o.AGTMR2.Reg) & 0x80) >> 7
}

// AGT0.AGTIOC: AGT I/O Control Register
func (o *AGT0_Type) SetAGTIOC_TEDGSEL(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTIOC_TEDGSEL() uint8 {
	return volatile.LoadUint8(&o.AGTIOC.Reg) & 0x1
}
func (o *AGT0_Type) SetAGTIOC_TOE(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTIOC_TOE() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTIOC_TIPF(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x30)|value<<4)
}
func (o *AGT0_Type) GetAGTIOC_TIPF() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x30) >> 4
}
func (o *AGT0_Type) SetAGTIOC_TIOGT(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0xc0)|value<<6)
}
func (o *AGT0_Type) GetAGTIOC_TIOGT() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0xc0) >> 6
}

// AGT0.AGTISR: AGT Event Pin Select Register
func (o *AGT0_Type) SetAGTISR_EEPS(value uint8) {
	volatile.StoreUint8(&o.AGTISR.Reg, volatile.LoadUint8(&o.AGTISR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTISR_EEPS() uint8 {
	return (volatile.LoadUint8(&o.AGTISR.Reg) & 0x4) >> 2
}

// AGT0.AGTCMSR: AGT Compare Match Function Select Register
func (o *AGT0_Type) SetAGTCMSR_TCMEA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTCMSR_TCMEA() uint8 {
	return volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x1
}
func (o *AGT0_Type) SetAGTCMSR_TOEA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x2)|value<<1)
}
func (o *AGT0_Type) GetAGTCMSR_TOEA() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x2) >> 1
}
func (o *AGT0_Type) SetAGTCMSR_TOPOLA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTCMSR_TOPOLA() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTCMSR_TCMEB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTCMSR_TCMEB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x10) >> 4
}
func (o *AGT0_Type) SetAGTCMSR_TOEB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x20)|value<<5)
}
func (o *AGT0_Type) GetAGTCMSR_TOEB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x20) >> 5
}
func (o *AGT0_Type) SetAGTCMSR_TOPOLB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x40)|value<<6)
}
func (o *AGT0_Type) GetAGTCMSR_TOPOLB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x40) >> 6
}

// AGT0.AGTIOSEL: AGT Pin Select Register
func (o *AGT0_Type) SetAGTIOSEL_SEL(value uint8) {
	volatile.StoreUint8(&o.AGTIOSEL.Reg, volatile.LoadUint8(&o.AGTIOSEL.Reg)&^(0x3)|value)
}
func (o *AGT0_Type) GetAGTIOSEL_SEL() uint8 {
	return volatile.LoadUint8(&o.AGTIOSEL.Reg) & 0x3
}
func (o *AGT0_Type) SetAGTIOSEL_TIES(value uint8) {
	volatile.StoreUint8(&o.AGTIOSEL.Reg, volatile.LoadUint8(&o.AGTIOSEL.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTIOSEL_TIES() uint8 {
	return (volatile.LoadUint8(&o.AGTIOSEL.Reg) & 0x10) >> 4
}

// Low-Power Analog Comparator
type ACMPLP_Type struct {
	COMPMDR volatile.Register8 // 0x0
	COMPFIR volatile.Register8 // 0x1
	COMPOCR volatile.Register8 // 0x2
}

// ACMPLP.COMPMDR: ACMPLP Mode Setting Register
func (o *ACMPLP_Type) SetCOMPMDR_C0ENB(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x1)|value)
}
func (o *ACMPLP_Type) GetCOMPMDR_C0ENB() uint8 {
	return volatile.LoadUint8(&o.COMPMDR.Reg) & 0x1
}
func (o *ACMPLP_Type) SetCOMPMDR_C0WDE(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x2)|value<<1)
}
func (o *ACMPLP_Type) GetCOMPMDR_C0WDE() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x2) >> 1
}
func (o *ACMPLP_Type) SetCOMPMDR_C0VRF(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x4)|value<<2)
}
func (o *ACMPLP_Type) GetCOMPMDR_C0VRF() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x4) >> 2
}
func (o *ACMPLP_Type) SetCOMPMDR_C0MON(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x8)|value<<3)
}
func (o *ACMPLP_Type) GetCOMPMDR_C0MON() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x8) >> 3
}
func (o *ACMPLP_Type) SetCOMPMDR_C1ENB(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x10)|value<<4)
}
func (o *ACMPLP_Type) GetCOMPMDR_C1ENB() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x10) >> 4
}
func (o *ACMPLP_Type) SetCOMPMDR_C1WDE(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x20)|value<<5)
}
func (o *ACMPLP_Type) GetCOMPMDR_C1WDE() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x20) >> 5
}
func (o *ACMPLP_Type) SetCOMPMDR_C1VRF(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x40)|value<<6)
}
func (o *ACMPLP_Type) GetCOMPMDR_C1VRF() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x40) >> 6
}
func (o *ACMPLP_Type) SetCOMPMDR_C1MON(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x80)|value<<7)
}
func (o *ACMPLP_Type) GetCOMPMDR_C1MON() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x80) >> 7
}

// ACMPLP.COMPFIR: ACMPLP Filter Control Register
func (o *ACMPLP_Type) SetCOMPFIR_C0FCK(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x3)|value)
}
func (o *ACMPLP_Type) GetCOMPFIR_C0FCK() uint8 {
	return volatile.LoadUint8(&o.COMPFIR.Reg) & 0x3
}
func (o *ACMPLP_Type) SetCOMPFIR_C0EPO(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x4)|value<<2)
}
func (o *ACMPLP_Type) GetCOMPFIR_C0EPO() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x4) >> 2
}
func (o *ACMPLP_Type) SetCOMPFIR_C0EDG(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x8)|value<<3)
}
func (o *ACMPLP_Type) GetCOMPFIR_C0EDG() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x8) >> 3
}
func (o *ACMPLP_Type) SetCOMPFIR_C1FCK(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x30)|value<<4)
}
func (o *ACMPLP_Type) GetCOMPFIR_C1FCK() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x30) >> 4
}
func (o *ACMPLP_Type) SetCOMPFIR_C1EPO(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x40)|value<<6)
}
func (o *ACMPLP_Type) GetCOMPFIR_C1EPO() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x40) >> 6
}
func (o *ACMPLP_Type) SetCOMPFIR_C1EDG(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x80)|value<<7)
}
func (o *ACMPLP_Type) GetCOMPFIR_C1EDG() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x80) >> 7
}

// ACMPLP.COMPOCR: ACMPLP Output Control Register
func (o *ACMPLP_Type) SetCOMPOCR_C0OE(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x2)|value<<1)
}
func (o *ACMPLP_Type) GetCOMPOCR_C0OE() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x2) >> 1
}
func (o *ACMPLP_Type) SetCOMPOCR_C0OP(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x4)|value<<2)
}
func (o *ACMPLP_Type) GetCOMPOCR_C0OP() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x4) >> 2
}
func (o *ACMPLP_Type) SetCOMPOCR_C1OE(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x20)|value<<5)
}
func (o *ACMPLP_Type) GetCOMPOCR_C1OE() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x20) >> 5
}
func (o *ACMPLP_Type) SetCOMPOCR_C1OP(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x40)|value<<6)
}
func (o *ACMPLP_Type) GetCOMPOCR_C1OP() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x40) >> 6
}
func (o *ACMPLP_Type) SetCOMPOCR_SPDMD(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x80)|value<<7)
}
func (o *ACMPLP_Type) GetCOMPOCR_SPDMD() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x80) >> 7
}

// Flash I/O Registers
type FLCN_Type struct {
	_         [144]byte
	DFLCTL    volatile.Register8 // 0x90
	_         [111]byte
	FPMCR     volatile.Register8 // 0x100
	_         [3]byte
	FASR      volatile.Register8 // 0x104
	_         [3]byte
	FSARL     volatile.Register16 // 0x108
	_         [6]byte
	FSARH     volatile.Register16 // 0x110
	_         [2]byte
	FCR       volatile.Register8 // 0x114
	_         [3]byte
	FEARL     volatile.Register16 // 0x118
	_         [6]byte
	FEARH     volatile.Register16 // 0x120
	_         [2]byte
	FRESETR   volatile.Register8 // 0x124
	_         [7]byte
	FSTATR1   volatile.Register8 // 0x12C
	_         [3]byte
	FWBL0     volatile.Register16 // 0x130
	_         [6]byte
	FWBH0     volatile.Register16 // 0x138
	_         [70]byte
	FPR       volatile.Register8 // 0x180
	_         [3]byte
	FPSR      volatile.Register8 // 0x184
	_         [3]byte
	FRBL0     volatile.Register16 // 0x188
	_         [6]byte
	FRBH0     volatile.Register16 // 0x190
	_         [46]byte
	FSCMR     volatile.Register16 // 0x1C0
	_         [6]byte
	FAWSMR    volatile.Register16 // 0x1C8
	_         [6]byte
	FAWEMR    volatile.Register16 // 0x1D0
	_         [6]byte
	FISR      volatile.Register8 // 0x1D8
	_         [3]byte
	FEXCR     volatile.Register8 // 0x1DC
	_         [3]byte
	FEAML     volatile.Register16 // 0x1E0
	_         [6]byte
	FEAMH     volatile.Register16 // 0x1E8
	_         [6]byte
	FSTATR2   volatile.Register16 // 0x1F0
	_         [54]byte
	TSCDR     volatile.Register32 // 0x228
	_         [376]byte
	CTSUTRIMA volatile.Register32 // 0x3A4
	CTSUTRIMB volatile.Register32 // 0x3A8
	_         [15364]byte
	FENTRYR   volatile.Register16 // 0x3FB0
	_         [18]byte
	FLDWAITR  volatile.Register8 // 0x3FC4
	_         [3]byte
	PFBER     volatile.Register8 // 0x3FC8
}

// FLCN.DFLCTL: Data Flash Control Register
func (o *FLCN_Type) SetDFLCTL_DFLEN(value uint8) {
	volatile.StoreUint8(&o.DFLCTL.Reg, volatile.LoadUint8(&o.DFLCTL.Reg)&^(0x1)|value)
}
func (o *FLCN_Type) GetDFLCTL_DFLEN() uint8 {
	return volatile.LoadUint8(&o.DFLCTL.Reg) & 0x1
}

// FLCN.FPMCR: Flash P/E Mode Control Register
func (o *FLCN_Type) SetFPMCR_FMS0(value uint8) {
	volatile.StoreUint8(&o.FPMCR.Reg, volatile.LoadUint8(&o.FPMCR.Reg)&^(0x2)|value<<1)
}
func (o *FLCN_Type) GetFPMCR_FMS0() uint8 {
	return (volatile.LoadUint8(&o.FPMCR.Reg) & 0x2) >> 1
}
func (o *FLCN_Type) SetFPMCR_RPDIS(value uint8) {
	volatile.StoreUint8(&o.FPMCR.Reg, volatile.LoadUint8(&o.FPMCR.Reg)&^(0x8)|value<<3)
}
func (o *FLCN_Type) GetFPMCR_RPDIS() uint8 {
	return (volatile.LoadUint8(&o.FPMCR.Reg) & 0x8) >> 3
}
func (o *FLCN_Type) SetFPMCR_FMS1(value uint8) {
	volatile.StoreUint8(&o.FPMCR.Reg, volatile.LoadUint8(&o.FPMCR.Reg)&^(0x10)|value<<4)
}
func (o *FLCN_Type) GetFPMCR_FMS1() uint8 {
	return (volatile.LoadUint8(&o.FPMCR.Reg) & 0x10) >> 4
}

// FLCN.FASR: Flash Area Select Register
func (o *FLCN_Type) SetFASR_EXS(value uint8) {
	volatile.StoreUint8(&o.FASR.Reg, volatile.LoadUint8(&o.FASR.Reg)&^(0x1)|value)
}
func (o *FLCN_Type) GetFASR_EXS() uint8 {
	return volatile.LoadUint8(&o.FASR.Reg) & 0x1
}

// FLCN.FSARL: Flash Processing Start Address Register L
func (o *FLCN_Type) SetFSARL(value uint16) {
	volatile.StoreUint16(&o.FSARL.Reg, value)
}
func (o *FLCN_Type) GetFSARL() uint16 {
	return volatile.LoadUint16(&o.FSARL.Reg)
}

// FLCN.FSARH: Flash Processing Start Address Register H
func (o *FLCN_Type) SetFSARH(value uint16) {
	volatile.StoreUint16(&o.FSARH.Reg, value)
}
func (o *FLCN_Type) GetFSARH() uint16 {
	return volatile.LoadUint16(&o.FSARH.Reg)
}

// FLCN.FCR: Flash Control Register
func (o *FLCN_Type) SetFCR_CMD(value uint8) {
	volatile.StoreUint8(&o.FCR.Reg, volatile.LoadUint8(&o.FCR.Reg)&^(0xf)|value)
}
func (o *FLCN_Type) GetFCR_CMD() uint8 {
	return volatile.LoadUint8(&o.FCR.Reg) & 0xf
}
func (o *FLCN_Type) SetFCR_DRC(value uint8) {
	volatile.StoreUint8(&o.FCR.Reg, volatile.LoadUint8(&o.FCR.Reg)&^(0x10)|value<<4)
}
func (o *FLCN_Type) GetFCR_DRC() uint8 {
	return (volatile.LoadUint8(&o.FCR.Reg) & 0x10) >> 4
}
func (o *FLCN_Type) SetFCR_STOP(value uint8) {
	volatile.StoreUint8(&o.FCR.Reg, volatile.LoadUint8(&o.FCR.Reg)&^(0x40)|value<<6)
}
func (o *FLCN_Type) GetFCR_STOP() uint8 {
	return (volatile.LoadUint8(&o.FCR.Reg) & 0x40) >> 6
}
func (o *FLCN_Type) SetFCR_OPST(value uint8) {
	volatile.StoreUint8(&o.FCR.Reg, volatile.LoadUint8(&o.FCR.Reg)&^(0x80)|value<<7)
}
func (o *FLCN_Type) GetFCR_OPST() uint8 {
	return (volatile.LoadUint8(&o.FCR.Reg) & 0x80) >> 7
}

// FLCN.FEARL: Flash Processing End Address Register L
func (o *FLCN_Type) SetFEARL(value uint16) {
	volatile.StoreUint16(&o.FEARL.Reg, value)
}
func (o *FLCN_Type) GetFEARL() uint16 {
	return volatile.LoadUint16(&o.FEARL.Reg)
}

// FLCN.FEARH: Flash Processing End Address Register H
func (o *FLCN_Type) SetFEARH(value uint16) {
	volatile.StoreUint16(&o.FEARH.Reg, value)
}
func (o *FLCN_Type) GetFEARH() uint16 {
	return volatile.LoadUint16(&o.FEARH.Reg)
}

// FLCN.FRESETR: Flash Reset Register
func (o *FLCN_Type) SetFRESETR_FRESET(value uint8) {
	volatile.StoreUint8(&o.FRESETR.Reg, volatile.LoadUint8(&o.FRESETR.Reg)&^(0x1)|value)
}
func (o *FLCN_Type) GetFRESETR_FRESET() uint8 {
	return volatile.LoadUint8(&o.FRESETR.Reg) & 0x1
}

// FLCN.FSTATR1: Flash Status Register 1
func (o *FLCN_Type) SetFSTATR1_DRRDY(value uint8) {
	volatile.StoreUint8(&o.FSTATR1.Reg, volatile.LoadUint8(&o.FSTATR1.Reg)&^(0x2)|value<<1)
}
func (o *FLCN_Type) GetFSTATR1_DRRDY() uint8 {
	return (volatile.LoadUint8(&o.FSTATR1.Reg) & 0x2) >> 1
}
func (o *FLCN_Type) SetFSTATR1_FRDY(value uint8) {
	volatile.StoreUint8(&o.FSTATR1.Reg, volatile.LoadUint8(&o.FSTATR1.Reg)&^(0x40)|value<<6)
}
func (o *FLCN_Type) GetFSTATR1_FRDY() uint8 {
	return (volatile.LoadUint8(&o.FSTATR1.Reg) & 0x40) >> 6
}
func (o *FLCN_Type) SetFSTATR1_EXRDY(value uint8) {
	volatile.StoreUint8(&o.FSTATR1.Reg, volatile.LoadUint8(&o.FSTATR1.Reg)&^(0x80)|value<<7)
}
func (o *FLCN_Type) GetFSTATR1_EXRDY() uint8 {
	return (volatile.LoadUint8(&o.FSTATR1.Reg) & 0x80) >> 7
}

// FLCN.FWBL0: Flash Write Buffer Register L0
func (o *FLCN_Type) SetFWBL0(value uint16) {
	volatile.StoreUint16(&o.FWBL0.Reg, value)
}
func (o *FLCN_Type) GetFWBL0() uint16 {
	return volatile.LoadUint16(&o.FWBL0.Reg)
}

// FLCN.FWBH0: Flash Write Buffer Register H0
func (o *FLCN_Type) SetFWBH0(value uint16) {
	volatile.StoreUint16(&o.FWBH0.Reg, value)
}
func (o *FLCN_Type) GetFWBH0() uint16 {
	return volatile.LoadUint16(&o.FWBH0.Reg)
}

// FLCN.FPR: Protection Unlock Register
func (o *FLCN_Type) SetFPR(value uint8) {
	volatile.StoreUint8(&o.FPR.Reg, value)
}
func (o *FLCN_Type) GetFPR() uint8 {
	return volatile.LoadUint8(&o.FPR.Reg)
}

// FLCN.FPSR: Protection Unlock Status Register
func (o *FLCN_Type) SetFPSR_PERR(value uint8) {
	volatile.StoreUint8(&o.FPSR.Reg, volatile.LoadUint8(&o.FPSR.Reg)&^(0x1)|value)
}
func (o *FLCN_Type) GetFPSR_PERR() uint8 {
	return volatile.LoadUint8(&o.FPSR.Reg) & 0x1
}

// FLCN.FRBL0: Flash Read Buffer Register L0
func (o *FLCN_Type) SetFRBL0(value uint16) {
	volatile.StoreUint16(&o.FRBL0.Reg, value)
}
func (o *FLCN_Type) GetFRBL0() uint16 {
	return volatile.LoadUint16(&o.FRBL0.Reg)
}

// FLCN.FRBH0: Flash Read Buffer Register H0
func (o *FLCN_Type) SetFRBH0(value uint16) {
	volatile.StoreUint16(&o.FRBH0.Reg, value)
}
func (o *FLCN_Type) GetFRBH0() uint16 {
	return volatile.LoadUint16(&o.FRBH0.Reg)
}

// FLCN.FSCMR: Flash Start-Up Setting Monitor Register
func (o *FLCN_Type) SetFSCMR_SASMF(value uint16) {
	volatile.StoreUint16(&o.FSCMR.Reg, volatile.LoadUint16(&o.FSCMR.Reg)&^(0x100)|value<<8)
}
func (o *FLCN_Type) GetFSCMR_SASMF() uint16 {
	return (volatile.LoadUint16(&o.FSCMR.Reg) & 0x100) >> 8
}
func (o *FLCN_Type) SetFSCMR_FSPR(value uint16) {
	volatile.StoreUint16(&o.FSCMR.Reg, volatile.LoadUint16(&o.FSCMR.Reg)&^(0x4000)|value<<14)
}
func (o *FLCN_Type) GetFSCMR_FSPR() uint16 {
	return (volatile.LoadUint16(&o.FSCMR.Reg) & 0x4000) >> 14
}

// FLCN.FAWSMR: Flash Access Window Start Address Monitor Register
func (o *FLCN_Type) SetFAWSMR_FAWS(value uint16) {
	volatile.StoreUint16(&o.FAWSMR.Reg, volatile.LoadUint16(&o.FAWSMR.Reg)&^(0x7ff)|value)
}
func (o *FLCN_Type) GetFAWSMR_FAWS() uint16 {
	return volatile.LoadUint16(&o.FAWSMR.Reg) & 0x7ff
}
func (o *FLCN_Type) SetFAWSMR_FSPR(value uint16) {
	volatile.StoreUint16(&o.FAWSMR.Reg, volatile.LoadUint16(&o.FAWSMR.Reg)&^(0x8000)|value<<15)
}
func (o *FLCN_Type) GetFAWSMR_FSPR() uint16 {
	return (volatile.LoadUint16(&o.FAWSMR.Reg) & 0x8000) >> 15
}

// FLCN.FAWEMR: Flash Access Window End Address Monitor Register
func (o *FLCN_Type) SetFAWEMR_FAWE(value uint16) {
	volatile.StoreUint16(&o.FAWEMR.Reg, volatile.LoadUint16(&o.FAWEMR.Reg)&^(0x7ff)|value)
}
func (o *FLCN_Type) GetFAWEMR_FAWE() uint16 {
	return volatile.LoadUint16(&o.FAWEMR.Reg) & 0x7ff
}
func (o *FLCN_Type) SetFAWEMR_SASMF(value uint16) {
	volatile.StoreUint16(&o.FAWEMR.Reg, volatile.LoadUint16(&o.FAWEMR.Reg)&^(0x8000)|value<<15)
}
func (o *FLCN_Type) GetFAWEMR_SASMF() uint16 {
	return (volatile.LoadUint16(&o.FAWEMR.Reg) & 0x8000) >> 15
}

// FLCN.FISR: Flash Initial Setting Register
func (o *FLCN_Type) SetFISR_PCKA(value uint8) {
	volatile.StoreUint8(&o.FISR.Reg, volatile.LoadUint8(&o.FISR.Reg)&^(0x3f)|value)
}
func (o *FLCN_Type) GetFISR_PCKA() uint8 {
	return volatile.LoadUint8(&o.FISR.Reg) & 0x3f
}
func (o *FLCN_Type) SetFISR_SAS(value uint8) {
	volatile.StoreUint8(&o.FISR.Reg, volatile.LoadUint8(&o.FISR.Reg)&^(0xc0)|value<<6)
}
func (o *FLCN_Type) GetFISR_SAS() uint8 {
	return (volatile.LoadUint8(&o.FISR.Reg) & 0xc0) >> 6
}

// FLCN.FEXCR: Flash Extra Area Control Register
func (o *FLCN_Type) SetFEXCR_CMD(value uint8) {
	volatile.StoreUint8(&o.FEXCR.Reg, volatile.LoadUint8(&o.FEXCR.Reg)&^(0x7)|value)
}
func (o *FLCN_Type) GetFEXCR_CMD() uint8 {
	return volatile.LoadUint8(&o.FEXCR.Reg) & 0x7
}
func (o *FLCN_Type) SetFEXCR_OPST(value uint8) {
	volatile.StoreUint8(&o.FEXCR.Reg, volatile.LoadUint8(&o.FEXCR.Reg)&^(0x80)|value<<7)
}
func (o *FLCN_Type) GetFEXCR_OPST() uint8 {
	return (volatile.LoadUint8(&o.FEXCR.Reg) & 0x80) >> 7
}

// FLCN.FEAML: Flash Error Address Monitor Register L
func (o *FLCN_Type) SetFEAML(value uint16) {
	volatile.StoreUint16(&o.FEAML.Reg, value)
}
func (o *FLCN_Type) GetFEAML() uint16 {
	return volatile.LoadUint16(&o.FEAML.Reg)
}

// FLCN.FEAMH: Flash Error Address Monitor Register H
func (o *FLCN_Type) SetFEAMH(value uint16) {
	volatile.StoreUint16(&o.FEAMH.Reg, value)
}
func (o *FLCN_Type) GetFEAMH() uint16 {
	return volatile.LoadUint16(&o.FEAMH.Reg)
}

// FLCN.FSTATR2: Flash Status Register 2
func (o *FLCN_Type) SetFSTATR2_ERERR(value uint16) {
	volatile.StoreUint16(&o.FSTATR2.Reg, volatile.LoadUint16(&o.FSTATR2.Reg)&^(0x1)|value)
}
func (o *FLCN_Type) GetFSTATR2_ERERR() uint16 {
	return volatile.LoadUint16(&o.FSTATR2.Reg) & 0x1
}
func (o *FLCN_Type) SetFSTATR2_PRGERR(value uint16) {
	volatile.StoreUint16(&o.FSTATR2.Reg, volatile.LoadUint16(&o.FSTATR2.Reg)&^(0x2)|value<<1)
}
func (o *FLCN_Type) GetFSTATR2_PRGERR() uint16 {
	return (volatile.LoadUint16(&o.FSTATR2.Reg) & 0x2) >> 1
}
func (o *FLCN_Type) SetFSTATR2_PRGERR01(value uint16) {
	volatile.StoreUint16(&o.FSTATR2.Reg, volatile.LoadUint16(&o.FSTATR2.Reg)&^(0x4)|value<<2)
}
func (o *FLCN_Type) GetFSTATR2_PRGERR01() uint16 {
	return (volatile.LoadUint16(&o.FSTATR2.Reg) & 0x4) >> 2
}
func (o *FLCN_Type) SetFSTATR2_BCERR(value uint16) {
	volatile.StoreUint16(&o.FSTATR2.Reg, volatile.LoadUint16(&o.FSTATR2.Reg)&^(0x8)|value<<3)
}
func (o *FLCN_Type) GetFSTATR2_BCERR() uint16 {
	return (volatile.LoadUint16(&o.FSTATR2.Reg) & 0x8) >> 3
}
func (o *FLCN_Type) SetFSTATR2_ILGLERR(value uint16) {
	volatile.StoreUint16(&o.FSTATR2.Reg, volatile.LoadUint16(&o.FSTATR2.Reg)&^(0x10)|value<<4)
}
func (o *FLCN_Type) GetFSTATR2_ILGLERR() uint16 {
	return (volatile.LoadUint16(&o.FSTATR2.Reg) & 0x10) >> 4
}
func (o *FLCN_Type) SetFSTATR2_EILGLERR(value uint16) {
	volatile.StoreUint16(&o.FSTATR2.Reg, volatile.LoadUint16(&o.FSTATR2.Reg)&^(0x20)|value<<5)
}
func (o *FLCN_Type) GetFSTATR2_EILGLERR() uint16 {
	return (volatile.LoadUint16(&o.FSTATR2.Reg) & 0x20) >> 5
}

// FLCN.TSCDR: Temperature Sensor Calibration Data Register
func (o *FLCN_Type) SetTSCDR(value uint32) {
	volatile.StoreUint32(&o.TSCDR.Reg, volatile.LoadUint32(&o.TSCDR.Reg)&^(0xffff)|value)
}
func (o *FLCN_Type) GetTSCDR() uint32 {
	return volatile.LoadUint32(&o.TSCDR.Reg) & 0xffff
}

// FLCN.CTSUTRIMA: CTSU Trimming Register A
func (o *FLCN_Type) SetCTSUTRIMA_RTRIM(value uint32) {
	volatile.StoreUint32(&o.CTSUTRIMA.Reg, volatile.LoadUint32(&o.CTSUTRIMA.Reg)&^(0xff)|value)
}
func (o *FLCN_Type) GetCTSUTRIMA_RTRIM() uint32 {
	return volatile.LoadUint32(&o.CTSUTRIMA.Reg) & 0xff
}
func (o *FLCN_Type) SetCTSUTRIMA_DACTRIM(value uint32) {
	volatile.StoreUint32(&o.CTSUTRIMA.Reg, volatile.LoadUint32(&o.CTSUTRIMA.Reg)&^(0xff00)|value<<8)
}
func (o *FLCN_Type) GetCTSUTRIMA_DACTRIM() uint32 {
	return (volatile.LoadUint32(&o.CTSUTRIMA.Reg) & 0xff00) >> 8
}
func (o *FLCN_Type) SetCTSUTRIMA_SUADJD(value uint32) {
	volatile.StoreUint32(&o.CTSUTRIMA.Reg, volatile.LoadUint32(&o.CTSUTRIMA.Reg)&^(0xff0000)|value<<16)
}
func (o *FLCN_Type) GetCTSUTRIMA_SUADJD() uint32 {
	return (volatile.LoadUint32(&o.CTSUTRIMA.Reg) & 0xff0000) >> 16
}
func (o *FLCN_Type) SetCTSUTRIMA_SUADJTRIM(value uint32) {
	volatile.StoreUint32(&o.CTSUTRIMA.Reg, volatile.LoadUint32(&o.CTSUTRIMA.Reg)&^(0xff000000)|value<<24)
}
func (o *FLCN_Type) GetCTSUTRIMA_SUADJTRIM() uint32 {
	return (volatile.LoadUint32(&o.CTSUTRIMA.Reg) & 0xff000000) >> 24
}

// FLCN.CTSUTRIMB: CTSU Trimming Register B
func (o *FLCN_Type) SetCTSUTRIMB_TRESULT0(value uint32) {
	volatile.StoreUint32(&o.CTSUTRIMB.Reg, volatile.LoadUint32(&o.CTSUTRIMB.Reg)&^(0xff)|value)
}
func (o *FLCN_Type) GetCTSUTRIMB_TRESULT0() uint32 {
	return volatile.LoadUint32(&o.CTSUTRIMB.Reg) & 0xff
}
func (o *FLCN_Type) SetCTSUTRIMB_TRESULT1(value uint32) {
	volatile.StoreUint32(&o.CTSUTRIMB.Reg, volatile.LoadUint32(&o.CTSUTRIMB.Reg)&^(0xff00)|value<<8)
}
func (o *FLCN_Type) GetCTSUTRIMB_TRESULT1() uint32 {
	return (volatile.LoadUint32(&o.CTSUTRIMB.Reg) & 0xff00) >> 8
}
func (o *FLCN_Type) SetCTSUTRIMB_TRESULT2(value uint32) {
	volatile.StoreUint32(&o.CTSUTRIMB.Reg, volatile.LoadUint32(&o.CTSUTRIMB.Reg)&^(0xff0000)|value<<16)
}
func (o *FLCN_Type) GetCTSUTRIMB_TRESULT2() uint32 {
	return (volatile.LoadUint32(&o.CTSUTRIMB.Reg) & 0xff0000) >> 16
}
func (o *FLCN_Type) SetCTSUTRIMB_TRESULT3(value uint32) {
	volatile.StoreUint32(&o.CTSUTRIMB.Reg, volatile.LoadUint32(&o.CTSUTRIMB.Reg)&^(0xff000000)|value<<24)
}
func (o *FLCN_Type) GetCTSUTRIMB_TRESULT3() uint32 {
	return (volatile.LoadUint32(&o.CTSUTRIMB.Reg) & 0xff000000) >> 24
}

// FLCN.FENTRYR: Flash P/E Mode Entry Register
func (o *FLCN_Type) SetFENTRYR_FENTRY0(value uint16) {
	volatile.StoreUint16(&o.FENTRYR.Reg, volatile.LoadUint16(&o.FENTRYR.Reg)&^(0x1)|value)
}
func (o *FLCN_Type) GetFENTRYR_FENTRY0() uint16 {
	return volatile.LoadUint16(&o.FENTRYR.Reg) & 0x1
}
func (o *FLCN_Type) SetFENTRYR_FENTRYD(value uint16) {
	volatile.StoreUint16(&o.FENTRYR.Reg, volatile.LoadUint16(&o.FENTRYR.Reg)&^(0x80)|value<<7)
}
func (o *FLCN_Type) GetFENTRYR_FENTRYD() uint16 {
	return (volatile.LoadUint16(&o.FENTRYR.Reg) & 0x80) >> 7
}
func (o *FLCN_Type) SetFENTRYR_FEKEY(value uint16) {
	volatile.StoreUint16(&o.FENTRYR.Reg, volatile.LoadUint16(&o.FENTRYR.Reg)&^(0xff00)|value<<8)
}
func (o *FLCN_Type) GetFENTRYR_FEKEY() uint16 {
	return (volatile.LoadUint16(&o.FENTRYR.Reg) & 0xff00) >> 8
}

// FLCN.FLDWAITR: Memory Wait Cycle Control Register for Data Flash
func (o *FLCN_Type) SetFLDWAITR_FLDWAIT1(value uint8) {
	volatile.StoreUint8(&o.FLDWAITR.Reg, volatile.LoadUint8(&o.FLDWAITR.Reg)&^(0x1)|value)
}
func (o *FLCN_Type) GetFLDWAITR_FLDWAIT1() uint8 {
	return volatile.LoadUint8(&o.FLDWAITR.Reg) & 0x1
}

// FLCN.PFBER: Prefetch Buffer Enable Register
func (o *FLCN_Type) SetPFBER_PFBE(value uint8) {
	volatile.StoreUint8(&o.PFBER.Reg, volatile.LoadUint8(&o.PFBER.Reg)&^(0x1)|value)
}
func (o *FLCN_Type) GetPFBER_PFBE() uint8 {
	return volatile.LoadUint8(&o.PFBER.Reg) & 0x1
}

// Constants for RMPU: Renesas Memory Protection Unit
const (
	// MMPUCTLA: Bus Master MPU Control Register
	// Position of ENABLE field.
	RMPU_MMPUCTLA_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	RMPU_MMPUCTLA_ENABLE_Msk = 0x1
	// Bit ENABLE.
	RMPU_MMPUCTLA_ENABLE = 0x1
	// Master group A disabled
	RMPU_MMPUCTLA_ENABLE_0 = 0x0
	// Master group A enabled
	RMPU_MMPUCTLA_ENABLE_1 = 0x1
	// Position of OAD field.
	RMPU_MMPUCTLA_OAD_Pos = 0x1
	// Bit mask of OAD field.
	RMPU_MMPUCTLA_OAD_Msk = 0x2
	// Bit OAD.
	RMPU_MMPUCTLA_OAD = 0x2
	// Non-maskable interrupt
	RMPU_MMPUCTLA_OAD_0 = 0x0
	// Reset
	RMPU_MMPUCTLA_OAD_1 = 0x1
	// Position of KEY field.
	RMPU_MMPUCTLA_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_MMPUCTLA_KEY_Msk = 0xff00

	// MMPUPTA: Group A Protection of Register
	// Position of PROTECT field.
	RMPU_MMPUPTA_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	RMPU_MMPUPTA_PROTECT_Msk = 0x1
	// Bit PROTECT.
	RMPU_MMPUPTA_PROTECT = 0x1
	// All bus master MPU group A register writes are permitted.
	RMPU_MMPUPTA_PROTECT_0 = 0x0
	// All bus master MPU group A register writes are protected. Reads are permitted.
	RMPU_MMPUPTA_PROTECT_1 = 0x1
	// Position of KEY field.
	RMPU_MMPUPTA_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_MMPUPTA_KEY_Msk = 0xff00

	// MMPUACA0: Group A Region %s access control register
	// Position of ENABLE field.
	RMPU_MMPUACA_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	RMPU_MMPUACA_ENABLE_Msk = 0x1
	// Bit ENABLE.
	RMPU_MMPUACA_ENABLE = 0x1
	// Group A region n disabled
	RMPU_MMPUACA_ENABLE_0 = 0x0
	// Group A region n enabled
	RMPU_MMPUACA_ENABLE_1 = 0x1
	// Position of RP field.
	RMPU_MMPUACA_RP_Pos = 0x1
	// Bit mask of RP field.
	RMPU_MMPUACA_RP_Msk = 0x2
	// Bit RP.
	RMPU_MMPUACA_RP = 0x2
	// Read permission
	RMPU_MMPUACA_RP_0 = 0x0
	// Read protection
	RMPU_MMPUACA_RP_1 = 0x1
	// Position of WP field.
	RMPU_MMPUACA_WP_Pos = 0x2
	// Bit mask of WP field.
	RMPU_MMPUACA_WP_Msk = 0x4
	// Bit WP.
	RMPU_MMPUACA_WP = 0x4
	// Write permission
	RMPU_MMPUACA_WP_0 = 0x0
	// Write protection
	RMPU_MMPUACA_WP_1 = 0x1

	// MMPUSA0: Group A Region %s Start Address Register
	// Position of MMPUSA field.
	RMPU_MMPUSA_MMPUSA_Pos = 0x0
	// Bit mask of MMPUSA field.
	RMPU_MMPUSA_MMPUSA_Msk = 0xffffffff

	// MMPUEA0: Group A Region %s End Address Register
	// Position of MMPUEA field.
	RMPU_MMPUEA_MMPUEA_Pos = 0x0
	// Bit mask of MMPUEA field.
	RMPU_MMPUEA_MMPUEA_Msk = 0xffffffff

	// SMPUCTL: Slave MPU Control Register
	// Position of OAD field.
	RMPU_SMPUCTL_OAD_Pos = 0x0
	// Bit mask of OAD field.
	RMPU_SMPUCTL_OAD_Msk = 0x1
	// Bit OAD.
	RMPU_SMPUCTL_OAD = 0x1
	// Non-maskable interrupt
	RMPU_SMPUCTL_OAD_0 = 0x0
	// Reset
	RMPU_SMPUCTL_OAD_1 = 0x1
	// Position of PROTECT field.
	RMPU_SMPUCTL_PROTECT_Pos = 0x1
	// Bit mask of PROTECT field.
	RMPU_SMPUCTL_PROTECT_Msk = 0x2
	// Bit PROTECT.
	RMPU_SMPUCTL_PROTECT = 0x2
	// All bus slave register writes are permitted
	RMPU_SMPUCTL_PROTECT_0 = 0x0
	// All bus slave register writes are protected. Reads are permitted
	RMPU_SMPUCTL_PROTECT_1 = 0x1
	// Position of KEY field.
	RMPU_SMPUCTL_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_SMPUCTL_KEY_Msk = 0xff00

	// SMPUMBIU: Access Control Register for Memory Bus 1
	// Position of RPGRPA field.
	RMPU_SMPUMBIU_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	RMPU_SMPUMBIU_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	RMPU_SMPUMBIU_RPGRPA = 0x4
	// Memory protection read for master MPU group A disabled
	RMPU_SMPUMBIU_RPGRPA_0 = 0x0
	// Memory protection read for master MPU group A enabled
	RMPU_SMPUMBIU_RPGRPA_1 = 0x1
	// Position of WPGRPA field.
	RMPU_SMPUMBIU_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	RMPU_SMPUMBIU_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	RMPU_SMPUMBIU_WPGRPA = 0x8
	// Memory protection write for master MPU group A disabled
	RMPU_SMPUMBIU_WPGRPA_0 = 0x0
	// Memory protection write for master MPU group A enabled
	RMPU_SMPUMBIU_WPGRPA_1 = 0x1

	// SMPUFBIU: Access Control Register for Internal Peripheral Bus 9
	// Position of RPCPU field.
	RMPU_SMPUFBIU_RPCPU_Pos = 0x0
	// Bit mask of RPCPU field.
	RMPU_SMPUFBIU_RPCPU_Msk = 0x1
	// Bit RPCPU.
	RMPU_SMPUFBIU_RPCPU = 0x1
	// Memory protection for CPU read disabled
	RMPU_SMPUFBIU_RPCPU_0 = 0x0
	// Memory protection for CPU read enabled
	RMPU_SMPUFBIU_RPCPU_1 = 0x1
	// Position of WPCPU field.
	RMPU_SMPUFBIU_WPCPU_Pos = 0x1
	// Bit mask of WPCPU field.
	RMPU_SMPUFBIU_WPCPU_Msk = 0x2
	// Bit WPCPU.
	RMPU_SMPUFBIU_WPCPU = 0x2
	// Memory protection for CPU write disabled
	RMPU_SMPUFBIU_WPCPU_0 = 0x0
	// Memory protection for CPU write enabled
	RMPU_SMPUFBIU_WPCPU_1 = 0x1
	// Position of RPGRPA field.
	RMPU_SMPUFBIU_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	RMPU_SMPUFBIU_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	RMPU_SMPUFBIU_RPGRPA = 0x4
	// Memory protection for master MPU group A read disabled
	RMPU_SMPUFBIU_RPGRPA_0 = 0x0
	// Memory protection for master MPU group A read enabled
	RMPU_SMPUFBIU_RPGRPA_1 = 0x1
	// Position of WPGRPA field.
	RMPU_SMPUFBIU_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	RMPU_SMPUFBIU_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	RMPU_SMPUFBIU_WPGRPA = 0x8
	// Memory protection for master MPU group A write disabled
	RMPU_SMPUFBIU_WPGRPA_0 = 0x0
	// Memory protection for master MPU group A write enabled
	RMPU_SMPUFBIU_WPGRPA_1 = 0x1

	// SMPUSRAM0: Access Control Register for Memory Bus 4
	// Position of RPCPU field.
	RMPU_SMPUSRAM0_RPCPU_Pos = 0x0
	// Bit mask of RPCPU field.
	RMPU_SMPUSRAM0_RPCPU_Msk = 0x1
	// Bit RPCPU.
	RMPU_SMPUSRAM0_RPCPU = 0x1
	// Memory protection for CPU read disabled
	RMPU_SMPUSRAM0_RPCPU_0 = 0x0
	// Memory protection for CPU read enabled
	RMPU_SMPUSRAM0_RPCPU_1 = 0x1
	// Position of WPCPU field.
	RMPU_SMPUSRAM0_WPCPU_Pos = 0x1
	// Bit mask of WPCPU field.
	RMPU_SMPUSRAM0_WPCPU_Msk = 0x2
	// Bit WPCPU.
	RMPU_SMPUSRAM0_WPCPU = 0x2
	// Memory protection for CPU write disabled
	RMPU_SMPUSRAM0_WPCPU_0 = 0x0
	// Memory protection for CPU write enabled
	RMPU_SMPUSRAM0_WPCPU_1 = 0x1
	// Position of RPGRPA field.
	RMPU_SMPUSRAM0_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	RMPU_SMPUSRAM0_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	RMPU_SMPUSRAM0_RPGRPA = 0x4
	// Memory protection for master MPU group A read disabled
	RMPU_SMPUSRAM0_RPGRPA_0 = 0x0
	// Memory protection for master MPU group A read enabled
	RMPU_SMPUSRAM0_RPGRPA_1 = 0x1
	// Position of WPGRPA field.
	RMPU_SMPUSRAM0_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	RMPU_SMPUSRAM0_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	RMPU_SMPUSRAM0_WPGRPA = 0x8
	// Memory protection for master MPU group A write disabled
	RMPU_SMPUSRAM0_WPGRPA_0 = 0x0
	// Memory protection for master MPU group A write enabled
	RMPU_SMPUSRAM0_WPGRPA_1 = 0x1

	// SMPUP0BIU: Access Control Register for Internal Peripheral Bus 1
	// Position of RPCPU field.
	RMPU_SMPUP0BIU_RPCPU_Pos = 0x0
	// Bit mask of RPCPU field.
	RMPU_SMPUP0BIU_RPCPU_Msk = 0x1
	// Bit RPCPU.
	RMPU_SMPUP0BIU_RPCPU = 0x1
	// Memory protection for CPU read disabled
	RMPU_SMPUP0BIU_RPCPU_0 = 0x0
	// Memory protection for CPU read enabled
	RMPU_SMPUP0BIU_RPCPU_1 = 0x1
	// Position of WPCPU field.
	RMPU_SMPUP0BIU_WPCPU_Pos = 0x1
	// Bit mask of WPCPU field.
	RMPU_SMPUP0BIU_WPCPU_Msk = 0x2
	// Bit WPCPU.
	RMPU_SMPUP0BIU_WPCPU = 0x2
	// Memory protection for CPU write disabled
	RMPU_SMPUP0BIU_WPCPU_0 = 0x0
	// Memory protection for CPU write enabled
	RMPU_SMPUP0BIU_WPCPU_1 = 0x1
	// Position of RPGRPA field.
	RMPU_SMPUP0BIU_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	RMPU_SMPUP0BIU_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	RMPU_SMPUP0BIU_RPGRPA = 0x4
	// Memory protection for master MPU group A read disabled
	RMPU_SMPUP0BIU_RPGRPA_0 = 0x0
	// Memory protection for master MPU group A read enabled
	RMPU_SMPUP0BIU_RPGRPA_1 = 0x1
	// Position of WPGRPA field.
	RMPU_SMPUP0BIU_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	RMPU_SMPUP0BIU_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	RMPU_SMPUP0BIU_WPGRPA = 0x8
	// Memory protection for master MPU group A write disabled
	RMPU_SMPUP0BIU_WPGRPA_0 = 0x0
	// Memory protection for master MPU group A write enabled
	RMPU_SMPUP0BIU_WPGRPA_1 = 0x1

	// SMPUP2BIU: Access Control Register for Internal Peripheral Bus 3
	// Position of RPCPU field.
	RMPU_SMPUP2BIU_RPCPU_Pos = 0x0
	// Bit mask of RPCPU field.
	RMPU_SMPUP2BIU_RPCPU_Msk = 0x1
	// Bit RPCPU.
	RMPU_SMPUP2BIU_RPCPU = 0x1
	// Memory protection for CPU read disabled
	RMPU_SMPUP2BIU_RPCPU_0 = 0x0
	// Memory protection for CPU read enabled
	RMPU_SMPUP2BIU_RPCPU_1 = 0x1
	// Position of WPCPU field.
	RMPU_SMPUP2BIU_WPCPU_Pos = 0x1
	// Bit mask of WPCPU field.
	RMPU_SMPUP2BIU_WPCPU_Msk = 0x2
	// Bit WPCPU.
	RMPU_SMPUP2BIU_WPCPU = 0x2
	// Memory protection for CPU write disabled
	RMPU_SMPUP2BIU_WPCPU_0 = 0x0
	// Memory protection for CPU write enabled
	RMPU_SMPUP2BIU_WPCPU_1 = 0x1
	// Position of RPGRPA field.
	RMPU_SMPUP2BIU_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	RMPU_SMPUP2BIU_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	RMPU_SMPUP2BIU_RPGRPA = 0x4
	// Memory protection for master MPU group A read disabled
	RMPU_SMPUP2BIU_RPGRPA_0 = 0x0
	// Memory protection for master MPU group A read enabled
	RMPU_SMPUP2BIU_RPGRPA_1 = 0x1
	// Position of WPGRPA field.
	RMPU_SMPUP2BIU_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	RMPU_SMPUP2BIU_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	RMPU_SMPUP2BIU_WPGRPA = 0x8
	// Memory protection for master MPU group A write disabled
	RMPU_SMPUP2BIU_WPGRPA_0 = 0x0
	// Memory protection for master MPU group A write enabled
	RMPU_SMPUP2BIU_WPGRPA_1 = 0x1

	// SMPUP6BIU: Access Control Register for Internal Peripheral Bus 7
	// Position of RPCPU field.
	RMPU_SMPUP6BIU_RPCPU_Pos = 0x0
	// Bit mask of RPCPU field.
	RMPU_SMPUP6BIU_RPCPU_Msk = 0x1
	// Bit RPCPU.
	RMPU_SMPUP6BIU_RPCPU = 0x1
	// CPU read of memory protection disabled
	RMPU_SMPUP6BIU_RPCPU_0 = 0x0
	// CPU read of memory protection enabled
	RMPU_SMPUP6BIU_RPCPU_1 = 0x1
	// Position of WPCPU field.
	RMPU_SMPUP6BIU_WPCPU_Pos = 0x1
	// Bit mask of WPCPU field.
	RMPU_SMPUP6BIU_WPCPU_Msk = 0x2
	// Bit WPCPU.
	RMPU_SMPUP6BIU_WPCPU = 0x2
	// CPU write of memory protection disabled
	RMPU_SMPUP6BIU_WPCPU_0 = 0x0
	// CPU write of memory protection enabled
	RMPU_SMPUP6BIU_WPCPU_1 = 0x1
	// Position of RPGRPA field.
	RMPU_SMPUP6BIU_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	RMPU_SMPUP6BIU_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	RMPU_SMPUP6BIU_RPGRPA = 0x4
	// Master MPU group A read of memory protection disabled
	RMPU_SMPUP6BIU_RPGRPA_0 = 0x0
	// Master MPU group A read of memory protection enabled
	RMPU_SMPUP6BIU_RPGRPA_1 = 0x1
	// Position of WPGRPA field.
	RMPU_SMPUP6BIU_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	RMPU_SMPUP6BIU_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	RMPU_SMPUP6BIU_WPGRPA = 0x8
	// Master MPU group A write of memory protection disabled
	RMPU_SMPUP6BIU_WPGRPA_0 = 0x0
	// Master MPU group A write of memory protection enabled
	RMPU_SMPUP6BIU_WPGRPA_1 = 0x1

	// MSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
	// Position of OAD field.
	RMPU_MSPMPUOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	RMPU_MSPMPUOAD_OAD_Msk = 0x1
	// Bit OAD.
	RMPU_MSPMPUOAD_OAD = 0x1
	// Non-maskable interrupt
	RMPU_MSPMPUOAD_OAD_0 = 0x0
	// Reset
	RMPU_MSPMPUOAD_OAD_1 = 0x1
	// Position of KEY field.
	RMPU_MSPMPUOAD_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_MSPMPUOAD_KEY_Msk = 0xff00

	// MSPMPUCTL: Stack Pointer Monitor Access Control Register
	// Position of ENABLE field.
	RMPU_MSPMPUCTL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	RMPU_MSPMPUCTL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	RMPU_MSPMPUCTL_ENABLE = 0x1
	// Stack pointer monitor is disabled
	RMPU_MSPMPUCTL_ENABLE_0 = 0x0
	// Stack pointer monitor is enabled
	RMPU_MSPMPUCTL_ENABLE_1 = 0x1
	// Position of ERROR field.
	RMPU_MSPMPUCTL_ERROR_Pos = 0x8
	// Bit mask of ERROR field.
	RMPU_MSPMPUCTL_ERROR_Msk = 0x100
	// Bit ERROR.
	RMPU_MSPMPUCTL_ERROR = 0x100
	// Stack pointer has not overflowed or underflowed
	RMPU_MSPMPUCTL_ERROR_0 = 0x0
	// Stack pointer has overflowed or underflowed
	RMPU_MSPMPUCTL_ERROR_1 = 0x1

	// MSPMPUPT: Stack Pointer Monitor Protection Register
	// Position of PROTECT field.
	RMPU_MSPMPUPT_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	RMPU_MSPMPUPT_PROTECT_Msk = 0x1
	// Bit PROTECT.
	RMPU_MSPMPUPT_PROTECT = 0x1
	// Stack pointer monitor register writes are permitted.
	RMPU_MSPMPUPT_PROTECT_0 = 0x0
	// Stack pointer monitor register writes are protected. Reads are permitted
	RMPU_MSPMPUPT_PROTECT_1 = 0x1
	// Position of KEY field.
	RMPU_MSPMPUPT_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_MSPMPUPT_KEY_Msk = 0xff00

	// MSPMPUSA: Main Stack Pointer (MSP) Monitor Start Address Register
	// Position of MSPMPUSA field.
	RMPU_MSPMPUSA_MSPMPUSA_Pos = 0x0
	// Bit mask of MSPMPUSA field.
	RMPU_MSPMPUSA_MSPMPUSA_Msk = 0xffffffff

	// MSPMPUEA: Main Stack Pointer (MSP) Monitor End Address Register
	// Position of MSPMPUEA field.
	RMPU_MSPMPUEA_MSPMPUEA_Pos = 0x0
	// Bit mask of MSPMPUEA field.
	RMPU_MSPMPUEA_MSPMPUEA_Msk = 0xffffffff

	// PSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
	// Position of OAD field.
	RMPU_PSPMPUOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	RMPU_PSPMPUOAD_OAD_Msk = 0x1
	// Bit OAD.
	RMPU_PSPMPUOAD_OAD = 0x1
	// Non-maskable interrupt
	RMPU_PSPMPUOAD_OAD_0 = 0x0
	// Reset
	RMPU_PSPMPUOAD_OAD_1 = 0x1
	// Position of KEY field.
	RMPU_PSPMPUOAD_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_PSPMPUOAD_KEY_Msk = 0xff00

	// PSPMPUCTL: Stack Pointer Monitor Access Control Register
	// Position of ENABLE field.
	RMPU_PSPMPUCTL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	RMPU_PSPMPUCTL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	RMPU_PSPMPUCTL_ENABLE = 0x1
	// Stack pointer monitor is disabled
	RMPU_PSPMPUCTL_ENABLE_0 = 0x0
	// Stack pointer monitor is enabled
	RMPU_PSPMPUCTL_ENABLE_1 = 0x1
	// Position of ERROR field.
	RMPU_PSPMPUCTL_ERROR_Pos = 0x8
	// Bit mask of ERROR field.
	RMPU_PSPMPUCTL_ERROR_Msk = 0x100
	// Bit ERROR.
	RMPU_PSPMPUCTL_ERROR = 0x100
	// Stack pointer has not overflowed or underflowed
	RMPU_PSPMPUCTL_ERROR_0 = 0x0
	// Stack pointer has overflowed or underflowed
	RMPU_PSPMPUCTL_ERROR_1 = 0x1

	// PSPMPUPT: Stack Pointer Monitor Protection Register
	// Position of PROTECT field.
	RMPU_PSPMPUPT_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	RMPU_PSPMPUPT_PROTECT_Msk = 0x1
	// Bit PROTECT.
	RMPU_PSPMPUPT_PROTECT = 0x1
	// Stack pointer monitor register writes are permitted.
	RMPU_PSPMPUPT_PROTECT_0 = 0x0
	// Stack pointer monitor register writes are protected. Reads are permitted
	RMPU_PSPMPUPT_PROTECT_1 = 0x1
	// Position of KEY field.
	RMPU_PSPMPUPT_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_PSPMPUPT_KEY_Msk = 0xff00

	// PSPMPUSA: Process Stack Pointer (PSP) Monitor Start Address Register
	// Position of PSPMPUSA field.
	RMPU_PSPMPUSA_PSPMPUSA_Pos = 0x0
	// Bit mask of PSPMPUSA field.
	RMPU_PSPMPUSA_PSPMPUSA_Msk = 0xffffffff

	// PSPMPUEA: Process Stack Pointer (PSP) Monitor End Address Register
	// Position of PSPMPUEA field.
	RMPU_PSPMPUEA_PSPMPUEA_Pos = 0x0
	// Bit mask of PSPMPUEA field.
	RMPU_PSPMPUEA_PSPMPUEA_Msk = 0xffffffff
)

// Constants for SRAM: SRAM Control
const (
	// PARIOAD: SRAM Parity Error Operation After Detection Register
	// Position of OAD field.
	SRAM_PARIOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SRAM_PARIOAD_OAD_Msk = 0x1
	// Bit OAD.
	SRAM_PARIOAD_OAD = 0x1
	// Non-maskable interrupt
	SRAM_PARIOAD_OAD_0 = 0x0
	// Reset
	SRAM_PARIOAD_OAD_1 = 0x1

	// SRAMPRCR: SRAM Protection Register
	// Position of SRAMPRCR field.
	SRAM_SRAMPRCR_SRAMPRCR_Pos = 0x0
	// Bit mask of SRAMPRCR field.
	SRAM_SRAMPRCR_SRAMPRCR_Msk = 0x1
	// Bit SRAMPRCR.
	SRAM_SRAMPRCR_SRAMPRCR = 0x1
	// Disable writes to protected registers
	SRAM_SRAMPRCR_SRAMPRCR_0 = 0x0
	// Enable writes to protected registers
	SRAM_SRAMPRCR_SRAMPRCR_1 = 0x1
	// Position of KW field.
	SRAM_SRAMPRCR_KW_Pos = 0x1
	// Bit mask of KW field.
	SRAM_SRAMPRCR_KW_Msk = 0xfe

	// ECCMODE: ECC Operating Mode Control Register
	// Position of ECCMOD field.
	SRAM_ECCMODE_ECCMOD_Pos = 0x0
	// Bit mask of ECCMOD field.
	SRAM_ECCMODE_ECCMOD_Msk = 0x3
	// Disable ECC function
	SRAM_ECCMODE_ECCMOD_00 = 0x0
	// Setting prohibited
	SRAM_ECCMODE_ECCMOD_01 = 0x1
	// Enable ECC function without error checking
	SRAM_ECCMODE_ECCMOD_10 = 0x2
	// Enable ECC function with error checking
	SRAM_ECCMODE_ECCMOD_11 = 0x3

	// ECC2STS: ECC 2-Bit Error Status Register
	// Position of ECC2ERR field.
	SRAM_ECC2STS_ECC2ERR_Pos = 0x0
	// Bit mask of ECC2ERR field.
	SRAM_ECC2STS_ECC2ERR_Msk = 0x1
	// Bit ECC2ERR.
	SRAM_ECC2STS_ECC2ERR = 0x1
	// No 2-bit ECC error occurred
	SRAM_ECC2STS_ECC2ERR_0 = 0x0
	// 2-bit ECC error occurred
	SRAM_ECC2STS_ECC2ERR_1 = 0x1

	// ECC1STSEN: ECC 1-Bit Error Information Update Enable Register
	// Position of E1STSEN field.
	SRAM_ECC1STSEN_E1STSEN_Pos = 0x0
	// Bit mask of E1STSEN field.
	SRAM_ECC1STSEN_E1STSEN_Msk = 0x1
	// Bit E1STSEN.
	SRAM_ECC1STSEN_E1STSEN = 0x1
	// Disable updating of 1-bit ECC error information
	SRAM_ECC1STSEN_E1STSEN_0 = 0x0
	// Enable updating of 1-bit ECC error information
	SRAM_ECC1STSEN_E1STSEN_1 = 0x1

	// ECC1STS: ECC 1-Bit Error Status Register
	// Position of ECC1ERR field.
	SRAM_ECC1STS_ECC1ERR_Pos = 0x0
	// Bit mask of ECC1ERR field.
	SRAM_ECC1STS_ECC1ERR_Msk = 0x1
	// Bit ECC1ERR.
	SRAM_ECC1STS_ECC1ERR = 0x1
	// No 1-bit ECC error occurred
	SRAM_ECC1STS_ECC1ERR_0 = 0x0
	// 1-bit ECC error occurred
	SRAM_ECC1STS_ECC1ERR_1 = 0x1

	// ECCPRCR: ECC Protection Register
	// Position of ECCPRCR field.
	SRAM_ECCPRCR_ECCPRCR_Pos = 0x0
	// Bit mask of ECCPRCR field.
	SRAM_ECCPRCR_ECCPRCR_Msk = 0x1
	// Bit ECCPRCR.
	SRAM_ECCPRCR_ECCPRCR = 0x1
	// Disable writes to the protected registers
	SRAM_ECCPRCR_ECCPRCR_0 = 0x0
	// Enable writes to the protected registers
	SRAM_ECCPRCR_ECCPRCR_1 = 0x1
	// Position of KW field.
	SRAM_ECCPRCR_KW_Pos = 0x1
	// Bit mask of KW field.
	SRAM_ECCPRCR_KW_Msk = 0xfe
	// Enable write to the ECCPRCR bit
	SRAM_ECCPRCR_KW_0x78 = 0x78

	// ECCPRCR2: ECC Protection Register 2
	// Position of ECCPRCR2 field.
	SRAM_ECCPRCR2_ECCPRCR2_Pos = 0x0
	// Bit mask of ECCPRCR2 field.
	SRAM_ECCPRCR2_ECCPRCR2_Msk = 0x1
	// Bit ECCPRCR2.
	SRAM_ECCPRCR2_ECCPRCR2 = 0x1
	// Disable writes to the protected registers
	SRAM_ECCPRCR2_ECCPRCR2_0 = 0x0
	// Enable writes to the protected registers
	SRAM_ECCPRCR2_ECCPRCR2_1 = 0x1
	// Position of KW2 field.
	SRAM_ECCPRCR2_KW2_Pos = 0x1
	// Bit mask of KW2 field.
	SRAM_ECCPRCR2_KW2_Msk = 0xfe
	// Enable write to the ECCPRCR2 bit
	SRAM_ECCPRCR2_KW2_0x78 = 0x78

	// ECCETST: ECC Test Control Register
	// Position of TSTBYP field.
	SRAM_ECCETST_TSTBYP_Pos = 0x0
	// Bit mask of TSTBYP field.
	SRAM_ECCETST_TSTBYP_Msk = 0x1
	// Bit TSTBYP.
	SRAM_ECCETST_TSTBYP = 0x1
	// Disable ECC bypass
	SRAM_ECCETST_TSTBYP_0 = 0x0
	// Enable ECC bypass
	SRAM_ECCETST_TSTBYP_1 = 0x1

	// ECCOAD: SRAM ECC Error Operation After Detection Register
	// Position of OAD field.
	SRAM_ECCOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SRAM_ECCOAD_OAD_Msk = 0x1
	// Bit OAD.
	SRAM_ECCOAD_OAD = 0x1
	// Non-maskable interrupt
	SRAM_ECCOAD_OAD_0 = 0x0
	// Reset
	SRAM_ECCOAD_OAD_1 = 0x1
)

// Constants for BUS: BUS Control
const (
	// BUSMCNTSYS: Master Bus Control Register SYS
	// Position of IERES field.
	BUS_BUSMCNTSYS_IERES_Pos = 0xf
	// Bit mask of IERES field.
	BUS_BUSMCNTSYS_IERES_Msk = 0x8000
	// Bit IERES.
	BUS_BUSMCNTSYS_IERES = 0x8000
	// A bus error is reported.
	BUS_BUSMCNTSYS_IERES_0 = 0x0
	// A bus error is not reported.
	BUS_BUSMCNTSYS_IERES_1 = 0x1

	// BUSMCNTDMA: Master Bus Control Register DMA
	// Position of IERES field.
	BUS_BUSMCNTDMA_IERES_Pos = 0xf
	// Bit mask of IERES field.
	BUS_BUSMCNTDMA_IERES_Msk = 0x8000
	// Bit IERES.
	BUS_BUSMCNTDMA_IERES = 0x8000
	// A bus error is reported.
	BUS_BUSMCNTDMA_IERES_0 = 0x0
	// A bus error is not reported.
	BUS_BUSMCNTDMA_IERES_1 = 0x1

	// BUS3ERRADD: Bus Error Address Register 3
	// Position of BERAD field.
	BUS_BUS3ERRADD_BERAD_Pos = 0x0
	// Bit mask of BERAD field.
	BUS_BUS3ERRADD_BERAD_Msk = 0xffffffff

	// BUS3ERRSTAT: BUS Error Status Register 3
	// Position of ACCSTAT field.
	BUS_BUS3ERRSTAT_ACCSTAT_Pos = 0x0
	// Bit mask of ACCSTAT field.
	BUS_BUS3ERRSTAT_ACCSTAT_Msk = 0x1
	// Bit ACCSTAT.
	BUS_BUS3ERRSTAT_ACCSTAT = 0x1
	// Read access
	BUS_BUS3ERRSTAT_ACCSTAT_0 = 0x0
	// Write access
	BUS_BUS3ERRSTAT_ACCSTAT_1 = 0x1
	// Position of ERRSTAT field.
	BUS_BUS3ERRSTAT_ERRSTAT_Pos = 0x7
	// Bit mask of ERRSTAT field.
	BUS_BUS3ERRSTAT_ERRSTAT_Msk = 0x80
	// Bit ERRSTAT.
	BUS_BUS3ERRSTAT_ERRSTAT = 0x80
	// No bus error occurred.
	BUS_BUS3ERRSTAT_ERRSTAT_0 = 0x0
	// Bus error occurred.
	BUS_BUS3ERRSTAT_ERRSTAT_1 = 0x1

	// BUS4ERRADD: Bus Error Address Register 4
	// Position of BERAD field.
	BUS_BUS4ERRADD_BERAD_Pos = 0x0
	// Bit mask of BERAD field.
	BUS_BUS4ERRADD_BERAD_Msk = 0xffffffff

	// BUS4ERRSTAT: BUS Error Status Register 4
	// Position of ACCSTAT field.
	BUS_BUS4ERRSTAT_ACCSTAT_Pos = 0x0
	// Bit mask of ACCSTAT field.
	BUS_BUS4ERRSTAT_ACCSTAT_Msk = 0x1
	// Bit ACCSTAT.
	BUS_BUS4ERRSTAT_ACCSTAT = 0x1
	// Read access
	BUS_BUS4ERRSTAT_ACCSTAT_0 = 0x0
	// Write access
	BUS_BUS4ERRSTAT_ACCSTAT_1 = 0x1
	// Position of ERRSTAT field.
	BUS_BUS4ERRSTAT_ERRSTAT_Pos = 0x7
	// Bit mask of ERRSTAT field.
	BUS_BUS4ERRSTAT_ERRSTAT_Msk = 0x80
	// Bit ERRSTAT.
	BUS_BUS4ERRSTAT_ERRSTAT = 0x80
	// No bus error occurred.
	BUS_BUS4ERRSTAT_ERRSTAT_0 = 0x0
	// Bus error occurred.
	BUS_BUS4ERRSTAT_ERRSTAT_1 = 0x1
)

// Constants for DTC: Data Transfer Controller
const (
	// DTCCR: DTC Control Register
	// Position of RRS field.
	DTC_DTCCR_RRS_Pos = 0x4
	// Bit mask of RRS field.
	DTC_DTCCR_RRS_Msk = 0x10
	// Bit RRS.
	DTC_DTCCR_RRS = 0x10
	// Transfer information read is not skipped
	DTC_DTCCR_RRS_0 = 0x0
	// Transfer information read is skipped when vector numbers match
	DTC_DTCCR_RRS_1 = 0x1

	// DTCST: DTC Module Start Register
	// Position of DTCST field.
	DTC_DTCST_DTCST_Pos = 0x0
	// Bit mask of DTCST field.
	DTC_DTCST_DTCST_Msk = 0x1
	// Bit DTCST.
	DTC_DTCST_DTCST = 0x1
	// DTC module stopped.
	DTC_DTCST_DTCST_0 = 0x0
	// DTC module started.
	DTC_DTCST_DTCST_1 = 0x1

	// DTCSTS: DTC Status Register
	// Position of VECN field.
	DTC_DTCSTS_VECN_Pos = 0x0
	// Bit mask of VECN field.
	DTC_DTCSTS_VECN_Msk = 0xff
	// Position of ACT field.
	DTC_DTCSTS_ACT_Pos = 0xf
	// Bit mask of ACT field.
	DTC_DTCSTS_ACT_Msk = 0x8000
	// Bit ACT.
	DTC_DTCSTS_ACT = 0x8000
	// DTC transfer operation is not in progress.
	DTC_DTCSTS_ACT_0 = 0x0
	// DTC transfer operation is in progress.
	DTC_DTCSTS_ACT_1 = 0x1
)

// Constants for ICU: ICU for CPU
const (
	// IRQCR0: IRQ Control Register %s
	// Position of IRQMD field.
	ICU_IRQCR_IRQMD_Pos = 0x0
	// Bit mask of IRQMD field.
	ICU_IRQCR_IRQMD_Msk = 0x3
	// Falling edge
	ICU_IRQCR_IRQMD_00 = 0x0
	// Rising edge
	ICU_IRQCR_IRQMD_01 = 0x1
	// Rising and falling edges
	ICU_IRQCR_IRQMD_10 = 0x2
	// Low level
	ICU_IRQCR_IRQMD_11 = 0x3
	// Position of FCLKSEL field.
	ICU_IRQCR_FCLKSEL_Pos = 0x4
	// Bit mask of FCLKSEL field.
	ICU_IRQCR_FCLKSEL_Msk = 0x30
	// PCLKB
	ICU_IRQCR_FCLKSEL_00 = 0x0
	// PCLKB/8
	ICU_IRQCR_FCLKSEL_01 = 0x1
	// PCLKB/32
	ICU_IRQCR_FCLKSEL_10 = 0x2
	// PCLKB/64
	ICU_IRQCR_FCLKSEL_11 = 0x3
	// Position of FLTEN field.
	ICU_IRQCR_FLTEN_Pos = 0x7
	// Bit mask of FLTEN field.
	ICU_IRQCR_FLTEN_Msk = 0x80
	// Bit FLTEN.
	ICU_IRQCR_FLTEN = 0x80
	// Digital filter is disabled
	ICU_IRQCR_FLTEN_0 = 0x0
	// Digital filter is enabled.
	ICU_IRQCR_FLTEN_1 = 0x1

	// NMICR: NMI Pin Interrupt Control Register
	// Position of NMIMD field.
	ICU_NMICR_NMIMD_Pos = 0x0
	// Bit mask of NMIMD field.
	ICU_NMICR_NMIMD_Msk = 0x1
	// Bit NMIMD.
	ICU_NMICR_NMIMD = 0x1
	// Falling edge
	ICU_NMICR_NMIMD_0 = 0x0
	// Rising edge
	ICU_NMICR_NMIMD_1 = 0x1
	// Position of NFCLKSEL field.
	ICU_NMICR_NFCLKSEL_Pos = 0x4
	// Bit mask of NFCLKSEL field.
	ICU_NMICR_NFCLKSEL_Msk = 0x30
	// PCLKB
	ICU_NMICR_NFCLKSEL_00 = 0x0
	// PCLKB/8
	ICU_NMICR_NFCLKSEL_01 = 0x1
	// PCLKB/32
	ICU_NMICR_NFCLKSEL_10 = 0x2
	// PCLKB/64
	ICU_NMICR_NFCLKSEL_11 = 0x3
	// Position of NFLTEN field.
	ICU_NMICR_NFLTEN_Pos = 0x7
	// Bit mask of NFLTEN field.
	ICU_NMICR_NFLTEN_Msk = 0x80
	// Bit NFLTEN.
	ICU_NMICR_NFLTEN = 0x80
	// Disabled.
	ICU_NMICR_NFLTEN_0 = 0x0
	// Enabled.
	ICU_NMICR_NFLTEN_1 = 0x1

	// NMIER: Non-Maskable Interrupt Enable Register
	// Position of IWDTEN field.
	ICU_NMIER_IWDTEN_Pos = 0x0
	// Bit mask of IWDTEN field.
	ICU_NMIER_IWDTEN_Msk = 0x1
	// Bit IWDTEN.
	ICU_NMIER_IWDTEN = 0x1
	// Disabled
	ICU_NMIER_IWDTEN_0 = 0x0
	// Enabled.
	ICU_NMIER_IWDTEN_1 = 0x1
	// Position of WDTEN field.
	ICU_NMIER_WDTEN_Pos = 0x1
	// Bit mask of WDTEN field.
	ICU_NMIER_WDTEN_Msk = 0x2
	// Bit WDTEN.
	ICU_NMIER_WDTEN = 0x2
	// Disabled
	ICU_NMIER_WDTEN_0 = 0x0
	// Enabled
	ICU_NMIER_WDTEN_1 = 0x1
	// Position of LVD1EN field.
	ICU_NMIER_LVD1EN_Pos = 0x2
	// Bit mask of LVD1EN field.
	ICU_NMIER_LVD1EN_Msk = 0x4
	// Bit LVD1EN.
	ICU_NMIER_LVD1EN = 0x4
	// Disabled
	ICU_NMIER_LVD1EN_0 = 0x0
	// Enabled
	ICU_NMIER_LVD1EN_1 = 0x1
	// Position of LVD2EN field.
	ICU_NMIER_LVD2EN_Pos = 0x3
	// Bit mask of LVD2EN field.
	ICU_NMIER_LVD2EN_Msk = 0x8
	// Bit LVD2EN.
	ICU_NMIER_LVD2EN = 0x8
	// Disabled
	ICU_NMIER_LVD2EN_0 = 0x0
	// Enabled
	ICU_NMIER_LVD2EN_1 = 0x1
	// Position of OSTEN field.
	ICU_NMIER_OSTEN_Pos = 0x6
	// Bit mask of OSTEN field.
	ICU_NMIER_OSTEN_Msk = 0x40
	// Bit OSTEN.
	ICU_NMIER_OSTEN = 0x40
	// Disabled
	ICU_NMIER_OSTEN_0 = 0x0
	// Enabled
	ICU_NMIER_OSTEN_1 = 0x1
	// Position of NMIEN field.
	ICU_NMIER_NMIEN_Pos = 0x7
	// Bit mask of NMIEN field.
	ICU_NMIER_NMIEN_Msk = 0x80
	// Bit NMIEN.
	ICU_NMIER_NMIEN = 0x80
	// Disabled
	ICU_NMIER_NMIEN_0 = 0x0
	// Enabled
	ICU_NMIER_NMIEN_1 = 0x1
	// Position of RPEEN field.
	ICU_NMIER_RPEEN_Pos = 0x8
	// Bit mask of RPEEN field.
	ICU_NMIER_RPEEN_Msk = 0x100
	// Bit RPEEN.
	ICU_NMIER_RPEEN = 0x100
	// Disabled
	ICU_NMIER_RPEEN_0 = 0x0
	// Enabled
	ICU_NMIER_RPEEN_1 = 0x1
	// Position of RECCEN field.
	ICU_NMIER_RECCEN_Pos = 0x9
	// Bit mask of RECCEN field.
	ICU_NMIER_RECCEN_Msk = 0x200
	// Bit RECCEN.
	ICU_NMIER_RECCEN = 0x200
	// Disabled
	ICU_NMIER_RECCEN_0 = 0x0
	// Enabled
	ICU_NMIER_RECCEN_1 = 0x1
	// Position of BUSSEN field.
	ICU_NMIER_BUSSEN_Pos = 0xa
	// Bit mask of BUSSEN field.
	ICU_NMIER_BUSSEN_Msk = 0x400
	// Bit BUSSEN.
	ICU_NMIER_BUSSEN = 0x400
	// Disabled
	ICU_NMIER_BUSSEN_0 = 0x0
	// Enabled
	ICU_NMIER_BUSSEN_1 = 0x1
	// Position of BUSMEN field.
	ICU_NMIER_BUSMEN_Pos = 0xb
	// Bit mask of BUSMEN field.
	ICU_NMIER_BUSMEN_Msk = 0x800
	// Bit BUSMEN.
	ICU_NMIER_BUSMEN = 0x800
	// Disabled
	ICU_NMIER_BUSMEN_0 = 0x0
	// Enabled
	ICU_NMIER_BUSMEN_1 = 0x1
	// Position of SPEEN field.
	ICU_NMIER_SPEEN_Pos = 0xc
	// Bit mask of SPEEN field.
	ICU_NMIER_SPEEN_Msk = 0x1000
	// Bit SPEEN.
	ICU_NMIER_SPEEN = 0x1000
	// Disabled
	ICU_NMIER_SPEEN_0 = 0x0
	// Enabled
	ICU_NMIER_SPEEN_1 = 0x1

	// NMICLR: Non-Maskable Interrupt Status Clear Register
	// Position of IWDTCLR field.
	ICU_NMICLR_IWDTCLR_Pos = 0x0
	// Bit mask of IWDTCLR field.
	ICU_NMICLR_IWDTCLR_Msk = 0x1
	// Bit IWDTCLR.
	ICU_NMICLR_IWDTCLR = 0x1
	// No effect
	ICU_NMICLR_IWDTCLR_0 = 0x0
	// Clear the NMISR.IWDTST flag
	ICU_NMICLR_IWDTCLR_1 = 0x1
	// Position of WDTCLR field.
	ICU_NMICLR_WDTCLR_Pos = 0x1
	// Bit mask of WDTCLR field.
	ICU_NMICLR_WDTCLR_Msk = 0x2
	// Bit WDTCLR.
	ICU_NMICLR_WDTCLR = 0x2
	// No effect
	ICU_NMICLR_WDTCLR_0 = 0x0
	// Clear the NMISR.WDTST flag
	ICU_NMICLR_WDTCLR_1 = 0x1
	// Position of LVD1CLR field.
	ICU_NMICLR_LVD1CLR_Pos = 0x2
	// Bit mask of LVD1CLR field.
	ICU_NMICLR_LVD1CLR_Msk = 0x4
	// Bit LVD1CLR.
	ICU_NMICLR_LVD1CLR = 0x4
	// No effect
	ICU_NMICLR_LVD1CLR_0 = 0x0
	// Clear the NMISR.LVD1ST flag
	ICU_NMICLR_LVD1CLR_1 = 0x1
	// Position of LVD2CLR field.
	ICU_NMICLR_LVD2CLR_Pos = 0x3
	// Bit mask of LVD2CLR field.
	ICU_NMICLR_LVD2CLR_Msk = 0x8
	// Bit LVD2CLR.
	ICU_NMICLR_LVD2CLR = 0x8
	// No effect
	ICU_NMICLR_LVD2CLR_0 = 0x0
	// Clear the NMISR.LVD2ST flag.
	ICU_NMICLR_LVD2CLR_1 = 0x1
	// Position of OSTCLR field.
	ICU_NMICLR_OSTCLR_Pos = 0x6
	// Bit mask of OSTCLR field.
	ICU_NMICLR_OSTCLR_Msk = 0x40
	// Bit OSTCLR.
	ICU_NMICLR_OSTCLR = 0x40
	// No effect
	ICU_NMICLR_OSTCLR_0 = 0x0
	// Clear the NMISR.OSTST flag
	ICU_NMICLR_OSTCLR_1 = 0x1
	// Position of NMICLR field.
	ICU_NMICLR_NMICLR_Pos = 0x7
	// Bit mask of NMICLR field.
	ICU_NMICLR_NMICLR_Msk = 0x80
	// Bit NMICLR.
	ICU_NMICLR_NMICLR = 0x80
	// No effect
	ICU_NMICLR_NMICLR_0 = 0x0
	// Clear the NMISR.NMIST flag
	ICU_NMICLR_NMICLR_1 = 0x1
	// Position of RPECLR field.
	ICU_NMICLR_RPECLR_Pos = 0x8
	// Bit mask of RPECLR field.
	ICU_NMICLR_RPECLR_Msk = 0x100
	// Bit RPECLR.
	ICU_NMICLR_RPECLR = 0x100
	// No effect
	ICU_NMICLR_RPECLR_0 = 0x0
	// Clear the NMISR.RPEST flag
	ICU_NMICLR_RPECLR_1 = 0x1
	// Position of RECCCLR field.
	ICU_NMICLR_RECCCLR_Pos = 0x9
	// Bit mask of RECCCLR field.
	ICU_NMICLR_RECCCLR_Msk = 0x200
	// Bit RECCCLR.
	ICU_NMICLR_RECCCLR = 0x200
	// No effect
	ICU_NMICLR_RECCCLR_0 = 0x0
	// Clear the NMISR.RECCST flag
	ICU_NMICLR_RECCCLR_1 = 0x1
	// Position of BUSSCLR field.
	ICU_NMICLR_BUSSCLR_Pos = 0xa
	// Bit mask of BUSSCLR field.
	ICU_NMICLR_BUSSCLR_Msk = 0x400
	// Bit BUSSCLR.
	ICU_NMICLR_BUSSCLR = 0x400
	// No effect
	ICU_NMICLR_BUSSCLR_0 = 0x0
	// Clear the NMISR.BUSSST flag
	ICU_NMICLR_BUSSCLR_1 = 0x1
	// Position of BUSMCLR field.
	ICU_NMICLR_BUSMCLR_Pos = 0xb
	// Bit mask of BUSMCLR field.
	ICU_NMICLR_BUSMCLR_Msk = 0x800
	// Bit BUSMCLR.
	ICU_NMICLR_BUSMCLR = 0x800
	// No effect
	ICU_NMICLR_BUSMCLR_0 = 0x0
	// Clear the NMISR.BUSMST flag
	ICU_NMICLR_BUSMCLR_1 = 0x1
	// Position of SPECLR field.
	ICU_NMICLR_SPECLR_Pos = 0xc
	// Bit mask of SPECLR field.
	ICU_NMICLR_SPECLR_Msk = 0x1000
	// Bit SPECLR.
	ICU_NMICLR_SPECLR = 0x1000
	// No effect
	ICU_NMICLR_SPECLR_0 = 0x0
	// Clear the NMISR.SPEST flag
	ICU_NMICLR_SPECLR_1 = 0x1

	// NMISR: Non-Maskable Interrupt Status Register
	// Position of IWDTST field.
	ICU_NMISR_IWDTST_Pos = 0x0
	// Bit mask of IWDTST field.
	ICU_NMISR_IWDTST_Msk = 0x1
	// Bit IWDTST.
	ICU_NMISR_IWDTST = 0x1
	// Interrupt not requested
	ICU_NMISR_IWDTST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_IWDTST_1 = 0x1
	// Position of WDTST field.
	ICU_NMISR_WDTST_Pos = 0x1
	// Bit mask of WDTST field.
	ICU_NMISR_WDTST_Msk = 0x2
	// Bit WDTST.
	ICU_NMISR_WDTST = 0x2
	// Interrupt not requested
	ICU_NMISR_WDTST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_WDTST_1 = 0x1
	// Position of LVD1ST field.
	ICU_NMISR_LVD1ST_Pos = 0x2
	// Bit mask of LVD1ST field.
	ICU_NMISR_LVD1ST_Msk = 0x4
	// Bit LVD1ST.
	ICU_NMISR_LVD1ST = 0x4
	// Interrupt not requested
	ICU_NMISR_LVD1ST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_LVD1ST_1 = 0x1
	// Position of LVD2ST field.
	ICU_NMISR_LVD2ST_Pos = 0x3
	// Bit mask of LVD2ST field.
	ICU_NMISR_LVD2ST_Msk = 0x8
	// Bit LVD2ST.
	ICU_NMISR_LVD2ST = 0x8
	// Interrupt not requested
	ICU_NMISR_LVD2ST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_LVD2ST_1 = 0x1
	// Position of OSTST field.
	ICU_NMISR_OSTST_Pos = 0x6
	// Bit mask of OSTST field.
	ICU_NMISR_OSTST_Msk = 0x40
	// Bit OSTST.
	ICU_NMISR_OSTST = 0x40
	// Interrupt not requested for main clock oscillation stop
	ICU_NMISR_OSTST_0 = 0x0
	// Interrupt requested for main clock oscillation stop
	ICU_NMISR_OSTST_1 = 0x1
	// Position of NMIST field.
	ICU_NMISR_NMIST_Pos = 0x7
	// Bit mask of NMIST field.
	ICU_NMISR_NMIST_Msk = 0x80
	// Bit NMIST.
	ICU_NMISR_NMIST = 0x80
	// Interrupt not requested
	ICU_NMISR_NMIST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_NMIST_1 = 0x1
	// Position of RPEST field.
	ICU_NMISR_RPEST_Pos = 0x8
	// Bit mask of RPEST field.
	ICU_NMISR_RPEST_Msk = 0x100
	// Bit RPEST.
	ICU_NMISR_RPEST = 0x100
	// Interrupt not requested
	ICU_NMISR_RPEST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_RPEST_1 = 0x1
	// Position of RECCST field.
	ICU_NMISR_RECCST_Pos = 0x9
	// Bit mask of RECCST field.
	ICU_NMISR_RECCST_Msk = 0x200
	// Bit RECCST.
	ICU_NMISR_RECCST = 0x200
	// Interrupt not requested
	ICU_NMISR_RECCST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_RECCST_1 = 0x1
	// Position of BUSSST field.
	ICU_NMISR_BUSSST_Pos = 0xa
	// Bit mask of BUSSST field.
	ICU_NMISR_BUSSST_Msk = 0x400
	// Bit BUSSST.
	ICU_NMISR_BUSSST = 0x400
	// Interrupt not requested
	ICU_NMISR_BUSSST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_BUSSST_1 = 0x1
	// Position of BUSMST field.
	ICU_NMISR_BUSMST_Pos = 0xb
	// Bit mask of BUSMST field.
	ICU_NMISR_BUSMST_Msk = 0x800
	// Bit BUSMST.
	ICU_NMISR_BUSMST = 0x800
	// Interrupt not requested
	ICU_NMISR_BUSMST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_BUSMST_1 = 0x1
	// Position of SPEST field.
	ICU_NMISR_SPEST_Pos = 0xc
	// Bit mask of SPEST field.
	ICU_NMISR_SPEST_Msk = 0x1000
	// Bit SPEST.
	ICU_NMISR_SPEST = 0x1000
	// Interrupt not requested
	ICU_NMISR_SPEST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_SPEST_1 = 0x1

	// WUPEN: Wake Up Interrupt Enable Register
	// Position of IRQWUPEN field.
	ICU_WUPEN_IRQWUPEN_Pos = 0x0
	// Bit mask of IRQWUPEN field.
	ICU_WUPEN_IRQWUPEN_Msk = 0xff
	// Software Standby/Snooze Mode returns by IRQn interrupt disabled
	ICU_WUPEN_IRQWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by IRQn interrupt enabled
	ICU_WUPEN_IRQWUPEN_1 = 0x1
	// Position of IWDTWUPEN field.
	ICU_WUPEN_IWDTWUPEN_Pos = 0x10
	// Bit mask of IWDTWUPEN field.
	ICU_WUPEN_IWDTWUPEN_Msk = 0x10000
	// Bit IWDTWUPEN.
	ICU_WUPEN_IWDTWUPEN = 0x10000
	// Software Standby/Snooze Mode returns by IWDT interrupt disabled
	ICU_WUPEN_IWDTWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by IWDT interrupt enabled
	ICU_WUPEN_IWDTWUPEN_1 = 0x1
	// Position of KEYWUPEN field.
	ICU_WUPEN_KEYWUPEN_Pos = 0x11
	// Bit mask of KEYWUPEN field.
	ICU_WUPEN_KEYWUPEN_Msk = 0x20000
	// Bit KEYWUPEN.
	ICU_WUPEN_KEYWUPEN = 0x20000
	// Software Standby/Snooze Mode returns by KEY interrupt disabled
	ICU_WUPEN_KEYWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by KEY interrupt enabled
	ICU_WUPEN_KEYWUPEN_1 = 0x1
	// Position of LVD1WUPEN field.
	ICU_WUPEN_LVD1WUPEN_Pos = 0x12
	// Bit mask of LVD1WUPEN field.
	ICU_WUPEN_LVD1WUPEN_Msk = 0x40000
	// Bit LVD1WUPEN.
	ICU_WUPEN_LVD1WUPEN = 0x40000
	// Software Standby/Snooze Mode returns by LVD1 interrupt disabled
	ICU_WUPEN_LVD1WUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by LVD1 interrupt enabled
	ICU_WUPEN_LVD1WUPEN_1 = 0x1
	// Position of LVD2WUPEN field.
	ICU_WUPEN_LVD2WUPEN_Pos = 0x13
	// Bit mask of LVD2WUPEN field.
	ICU_WUPEN_LVD2WUPEN_Msk = 0x80000
	// Bit LVD2WUPEN.
	ICU_WUPEN_LVD2WUPEN = 0x80000
	// Software Standby/Snooze Mode returns by LVD2 interrupt disabled
	ICU_WUPEN_LVD2WUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by LVD2 interrupt enabled
	ICU_WUPEN_LVD2WUPEN_1 = 0x1
	// Position of ACMPLP0WUPEN field.
	ICU_WUPEN_ACMPLP0WUPEN_Pos = 0x17
	// Bit mask of ACMPLP0WUPEN field.
	ICU_WUPEN_ACMPLP0WUPEN_Msk = 0x800000
	// Bit ACMPLP0WUPEN.
	ICU_WUPEN_ACMPLP0WUPEN = 0x800000
	// Software Standby/Snooze Mode returns by ACMPLP0 interrupt disabled
	ICU_WUPEN_ACMPLP0WUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by ACMPLP0 interrupt enabled
	ICU_WUPEN_ACMPLP0WUPEN_1 = 0x1
	// Position of RTCALMWUPEN field.
	ICU_WUPEN_RTCALMWUPEN_Pos = 0x18
	// Bit mask of RTCALMWUPEN field.
	ICU_WUPEN_RTCALMWUPEN_Msk = 0x1000000
	// Bit RTCALMWUPEN.
	ICU_WUPEN_RTCALMWUPEN = 0x1000000
	// Software Standby/Snooze Mode returns by RTC alarm interrupt disabled
	ICU_WUPEN_RTCALMWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by RTC alarm interrupt enabled.
	ICU_WUPEN_RTCALMWUPEN_1 = 0x1
	// Position of RTCPRDWUPEN field.
	ICU_WUPEN_RTCPRDWUPEN_Pos = 0x19
	// Bit mask of RTCPRDWUPEN field.
	ICU_WUPEN_RTCPRDWUPEN_Msk = 0x2000000
	// Bit RTCPRDWUPEN.
	ICU_WUPEN_RTCPRDWUPEN = 0x2000000
	// Software Standby/Snooze Mode returns by RTC period interrupt disabled
	ICU_WUPEN_RTCPRDWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by RTC period interrupt enabled
	ICU_WUPEN_RTCPRDWUPEN_1 = 0x1
	// Position of AGT1UDWUPEN field.
	ICU_WUPEN_AGT1UDWUPEN_Pos = 0x1c
	// Bit mask of AGT1UDWUPEN field.
	ICU_WUPEN_AGT1UDWUPEN_Msk = 0x10000000
	// Bit AGT1UDWUPEN.
	ICU_WUPEN_AGT1UDWUPEN = 0x10000000
	// Software Standby/Snooze Mode returns by AGT1 underflow interrupt disabled
	ICU_WUPEN_AGT1UDWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by AGT1 underflow
	ICU_WUPEN_AGT1UDWUPEN_1 = 0x1
	// Position of AGT1CAWUPEN field.
	ICU_WUPEN_AGT1CAWUPEN_Pos = 0x1d
	// Bit mask of AGT1CAWUPEN field.
	ICU_WUPEN_AGT1CAWUPEN_Msk = 0x20000000
	// Bit AGT1CAWUPEN.
	ICU_WUPEN_AGT1CAWUPEN = 0x20000000
	// Software Standby/Snooze Mode returns by AGT1 compare match A interrupt disabled.
	ICU_WUPEN_AGT1CAWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by AGT1 compare match A interrupt enabled.
	ICU_WUPEN_AGT1CAWUPEN_1 = 0x1
	// Position of AGT1CBWUPEN field.
	ICU_WUPEN_AGT1CBWUPEN_Pos = 0x1e
	// Bit mask of AGT1CBWUPEN field.
	ICU_WUPEN_AGT1CBWUPEN_Msk = 0x40000000
	// Bit AGT1CBWUPEN.
	ICU_WUPEN_AGT1CBWUPEN = 0x40000000
	// Software Standby/Snooze Mode returns by AGT1 compare match B interrupt disabled.
	ICU_WUPEN_AGT1CBWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by AGT1 compare match B interrupt enabled.
	ICU_WUPEN_AGT1CBWUPEN_1 = 0x1
	// Position of IIC0WUPEN field.
	ICU_WUPEN_IIC0WUPEN_Pos = 0x1f
	// Bit mask of IIC0WUPEN field.
	ICU_WUPEN_IIC0WUPEN_Msk = 0x80000000
	// Bit IIC0WUPEN.
	ICU_WUPEN_IIC0WUPEN = 0x80000000
	// Software Standby/Snooze Mode returns by IIC0 address match interrupt disabled
	ICU_WUPEN_IIC0WUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by IIC0 address match interrupt enabled
	ICU_WUPEN_IIC0WUPEN_1 = 0x1

	// IELEN: ICU event Enable Register
	// Position of RTCINTEN field.
	ICU_IELEN_RTCINTEN_Pos = 0x0
	// Bit mask of RTCINTEN field.
	ICU_IELEN_RTCINTEN_Msk = 0x1
	// Bit RTCINTEN.
	ICU_IELEN_RTCINTEN = 0x1
	// Disabled
	ICU_IELEN_RTCINTEN_0 = 0x0
	// Enabled
	ICU_IELEN_RTCINTEN_1 = 0x1
	// Position of IELEN field.
	ICU_IELEN_IELEN_Pos = 0x1
	// Bit mask of IELEN field.
	ICU_IELEN_IELEN_Msk = 0x2
	// Bit IELEN.
	ICU_IELEN_IELEN = 0x2
	// Disabled
	ICU_IELEN_IELEN_0 = 0x0
	// Enabled
	ICU_IELEN_IELEN_1 = 0x1
)

// Constants for DBG: Debug Function
const (
	// DBGSTR: Debug Status Register
	// Position of CDBGPWRUPREQ field.
	DBG_DBGSTR_CDBGPWRUPREQ_Pos = 0x1c
	// Bit mask of CDBGPWRUPREQ field.
	DBG_DBGSTR_CDBGPWRUPREQ_Msk = 0x10000000
	// Bit CDBGPWRUPREQ.
	DBG_DBGSTR_CDBGPWRUPREQ = 0x10000000
	// OCD is not requesting debug power up
	DBG_DBGSTR_CDBGPWRUPREQ_0 = 0x0
	// OCD is requesting debug power up
	DBG_DBGSTR_CDBGPWRUPREQ_1 = 0x1
	// Position of CDBGPWRUPACK field.
	DBG_DBGSTR_CDBGPWRUPACK_Pos = 0x1d
	// Bit mask of CDBGPWRUPACK field.
	DBG_DBGSTR_CDBGPWRUPACK_Msk = 0x20000000
	// Bit CDBGPWRUPACK.
	DBG_DBGSTR_CDBGPWRUPACK = 0x20000000
	// Debug power-up request is not acknowledged
	DBG_DBGSTR_CDBGPWRUPACK_0 = 0x0
	// Debug power-up request is acknowledged
	DBG_DBGSTR_CDBGPWRUPACK_1 = 0x1

	// DBGSTOPCR: Debug Stop Control Register
	// Position of DBGSTOP_IWDT field.
	DBG_DBGSTOPCR_DBGSTOP_IWDT_Pos = 0x0
	// Bit mask of DBGSTOP_IWDT field.
	DBG_DBGSTOPCR_DBGSTOP_IWDT_Msk = 0x1
	// Bit DBGSTOP_IWDT.
	DBG_DBGSTOPCR_DBGSTOP_IWDT = 0x1
	// Enable IWDT reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_IWDT_0 = 0x0
	// Mask IWDT reset/interrupt and stop IWDT counter
	DBG_DBGSTOPCR_DBGSTOP_IWDT_1 = 0x1
	// Position of DBGSTOP_WDT field.
	DBG_DBGSTOPCR_DBGSTOP_WDT_Pos = 0x1
	// Bit mask of DBGSTOP_WDT field.
	DBG_DBGSTOPCR_DBGSTOP_WDT_Msk = 0x2
	// Bit DBGSTOP_WDT.
	DBG_DBGSTOPCR_DBGSTOP_WDT = 0x2
	// Enable WDT reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_WDT_0 = 0x0
	// Mask WDT reset/interrupt and stop WDT counter
	DBG_DBGSTOPCR_DBGSTOP_WDT_1 = 0x1
	// Position of DBGSTOP_LVD0 field.
	DBG_DBGSTOPCR_DBGSTOP_LVD0_Pos = 0x10
	// Bit mask of DBGSTOP_LVD0 field.
	DBG_DBGSTOPCR_DBGSTOP_LVD0_Msk = 0x10000
	// Bit DBGSTOP_LVD0.
	DBG_DBGSTOPCR_DBGSTOP_LVD0 = 0x10000
	// Enable LVD0 reset
	DBG_DBGSTOPCR_DBGSTOP_LVD0_0 = 0x0
	// Mask LVD0 reset
	DBG_DBGSTOPCR_DBGSTOP_LVD0_1 = 0x1
	// Position of DBGSTOP_LVD1 field.
	DBG_DBGSTOPCR_DBGSTOP_LVD1_Pos = 0x11
	// Bit mask of DBGSTOP_LVD1 field.
	DBG_DBGSTOPCR_DBGSTOP_LVD1_Msk = 0x20000
	// Bit DBGSTOP_LVD1.
	DBG_DBGSTOPCR_DBGSTOP_LVD1 = 0x20000
	// Enable LVD1 reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_LVD1_0 = 0x0
	// Mask LVD1 reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_LVD1_1 = 0x1
	// Position of DBGSTOP_LVD2 field.
	DBG_DBGSTOPCR_DBGSTOP_LVD2_Pos = 0x12
	// Bit mask of DBGSTOP_LVD2 field.
	DBG_DBGSTOPCR_DBGSTOP_LVD2_Msk = 0x40000
	// Bit DBGSTOP_LVD2.
	DBG_DBGSTOPCR_DBGSTOP_LVD2 = 0x40000
	// Enable LVD2 reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_LVD2_0 = 0x0
	// Mask LVD2 reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_LVD2_1 = 0x1
	// Position of DBGSTOP_RPER field.
	DBG_DBGSTOPCR_DBGSTOP_RPER_Pos = 0x18
	// Bit mask of DBGSTOP_RPER field.
	DBG_DBGSTOPCR_DBGSTOP_RPER_Msk = 0x1000000
	// Bit DBGSTOP_RPER.
	DBG_DBGSTOPCR_DBGSTOP_RPER = 0x1000000
	// Enable SRAM parity error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RPER_0 = 0x0
	// Mask SRAM parity error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RPER_1 = 0x1
	// Position of DBGSTOP_RECCR field.
	DBG_DBGSTOPCR_DBGSTOP_RECCR_Pos = 0x19
	// Bit mask of DBGSTOP_RECCR field.
	DBG_DBGSTOPCR_DBGSTOP_RECCR_Msk = 0x2000000
	// Bit DBGSTOP_RECCR.
	DBG_DBGSTOPCR_DBGSTOP_RECCR = 0x2000000
	// Enable SRAM ECC error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RECCR_0 = 0x0
	// Mask SRAM ECC error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RECCR_1 = 0x1
)

// Constants for SYSC: System Control
const (
	// SBYCR: Standby Control Register
	// Position of SSBY field.
	SYSC_SBYCR_SSBY_Pos = 0xf
	// Bit mask of SSBY field.
	SYSC_SBYCR_SSBY_Msk = 0x8000
	// Bit SSBY.
	SYSC_SBYCR_SSBY = 0x8000
	// Sleep mode
	SYSC_SBYCR_SSBY_0 = 0x0
	// Software Standby mode.
	SYSC_SBYCR_SSBY_1 = 0x1

	// MSTPCRA: Module Stop Control Register A
	// Position of MSTPA22 field.
	SYSC_MSTPCRA_MSTPA22_Pos = 0x16
	// Bit mask of MSTPA22 field.
	SYSC_MSTPCRA_MSTPA22_Msk = 0x400000
	// Bit MSTPA22.
	SYSC_MSTPCRA_MSTPA22 = 0x400000
	// Cancel the module-stop state
	SYSC_MSTPCRA_MSTPA22_0 = 0x0
	// Enter the module-stop state
	SYSC_MSTPCRA_MSTPA22_1 = 0x1

	// SCKDIVCR: System Clock Division Control Register
	// Position of PCKD field.
	SYSC_SCKDIVCR_PCKD_Pos = 0x0
	// Bit mask of PCKD field.
	SYSC_SCKDIVCR_PCKD_Msk = 0x7
	// x 1/1
	SYSC_SCKDIVCR_PCKD_000 = 0x0
	// x 1/2
	SYSC_SCKDIVCR_PCKD_001 = 0x1
	// x 1/4
	SYSC_SCKDIVCR_PCKD_010 = 0x2
	// x 1/8
	SYSC_SCKDIVCR_PCKD_011 = 0x3
	// x 1/16
	SYSC_SCKDIVCR_PCKD_100 = 0x4
	// x 1/32
	SYSC_SCKDIVCR_PCKD_101 = 0x5
	// x 1/64
	SYSC_SCKDIVCR_PCKD_110 = 0x6
	// Position of PCKB field.
	SYSC_SCKDIVCR_PCKB_Pos = 0x8
	// Bit mask of PCKB field.
	SYSC_SCKDIVCR_PCKB_Msk = 0x700
	// x 1/1
	SYSC_SCKDIVCR_PCKB_000 = 0x0
	// x 1/2
	SYSC_SCKDIVCR_PCKB_001 = 0x1
	// x 1/4
	SYSC_SCKDIVCR_PCKB_010 = 0x2
	// x 1/8
	SYSC_SCKDIVCR_PCKB_011 = 0x3
	// x 1/16
	SYSC_SCKDIVCR_PCKB_100 = 0x4
	// x 1/32
	SYSC_SCKDIVCR_PCKB_101 = 0x5
	// x 1/64
	SYSC_SCKDIVCR_PCKB_110 = 0x6
	// Position of ICK field.
	SYSC_SCKDIVCR_ICK_Pos = 0x18
	// Bit mask of ICK field.
	SYSC_SCKDIVCR_ICK_Msk = 0x7000000
	// x 1/1
	SYSC_SCKDIVCR_ICK_000 = 0x0
	// x 1/2
	SYSC_SCKDIVCR_ICK_001 = 0x1
	// x 1/4
	SYSC_SCKDIVCR_ICK_010 = 0x2
	// x 1/8
	SYSC_SCKDIVCR_ICK_011 = 0x3
	// x 1/16
	SYSC_SCKDIVCR_ICK_100 = 0x4
	// x 1/32
	SYSC_SCKDIVCR_ICK_101 = 0x5
	// x 1/64
	SYSC_SCKDIVCR_ICK_110 = 0x6

	// SCKSCR: System Clock Source Control Register
	// Position of CKSEL field.
	SYSC_SCKSCR_CKSEL_Pos = 0x0
	// Bit mask of CKSEL field.
	SYSC_SCKSCR_CKSEL_Msk = 0x7
	// HOCO
	SYSC_SCKSCR_CKSEL_000 = 0x0
	// MOCO
	SYSC_SCKSCR_CKSEL_001 = 0x1
	// LOCO
	SYSC_SCKSCR_CKSEL_010 = 0x2
	// Main clock oscillator (MOSC)
	SYSC_SCKSCR_CKSEL_011 = 0x3
	// Sub-clock oscillator (SOSC)
	SYSC_SCKSCR_CKSEL_100 = 0x4
	// Setting prohibited
	SYSC_SCKSCR_CKSEL_101 = 0x5
	// Setting prohibited
	SYSC_SCKSCR_CKSEL_110 = 0x6
	// Setting prohibited
	SYSC_SCKSCR_CKSEL_111 = 0x7

	// MEMWAIT: Memory Wait Cycle Control Register for Code Flash
	// Position of MEMWAIT field.
	SYSC_MEMWAIT_MEMWAIT_Pos = 0x0
	// Bit mask of MEMWAIT field.
	SYSC_MEMWAIT_MEMWAIT_Msk = 0x1
	// Bit MEMWAIT.
	SYSC_MEMWAIT_MEMWAIT = 0x1
	// No wait
	SYSC_MEMWAIT_MEMWAIT_0 = 0x0
	// Wait
	SYSC_MEMWAIT_MEMWAIT_1 = 0x1

	// MOSCCR: Main Clock Oscillator Control Register
	// Position of MOSTP field.
	SYSC_MOSCCR_MOSTP_Pos = 0x0
	// Bit mask of MOSTP field.
	SYSC_MOSCCR_MOSTP_Msk = 0x1
	// Bit MOSTP.
	SYSC_MOSCCR_MOSTP = 0x1
	// Operate the main clock oscillator
	SYSC_MOSCCR_MOSTP_0 = 0x0
	// Stop the main clock oscillator
	SYSC_MOSCCR_MOSTP_1 = 0x1

	// HOCOCR: High-Speed On-Chip Oscillator Control Register
	// Position of HCSTP field.
	SYSC_HOCOCR_HCSTP_Pos = 0x0
	// Bit mask of HCSTP field.
	SYSC_HOCOCR_HCSTP_Msk = 0x1
	// Bit HCSTP.
	SYSC_HOCOCR_HCSTP = 0x1
	// Operate the HOCO clock
	SYSC_HOCOCR_HCSTP_0 = 0x0
	// Stop the HOCO clock
	SYSC_HOCOCR_HCSTP_1 = 0x1

	// MOCOCR: Middle-Speed On-Chip Oscillator Control Register
	// Position of MCSTP field.
	SYSC_MOCOCR_MCSTP_Pos = 0x0
	// Bit mask of MCSTP field.
	SYSC_MOCOCR_MCSTP_Msk = 0x1
	// Bit MCSTP.
	SYSC_MOCOCR_MCSTP = 0x1
	// MOCO clock is operating
	SYSC_MOCOCR_MCSTP_0 = 0x0
	// MOCO clock is stopped
	SYSC_MOCOCR_MCSTP_1 = 0x1

	// OSCSF: Oscillation Stabilization Flag Register
	// Position of HOCOSF field.
	SYSC_OSCSF_HOCOSF_Pos = 0x0
	// Bit mask of HOCOSF field.
	SYSC_OSCSF_HOCOSF_Msk = 0x1
	// Bit HOCOSF.
	SYSC_OSCSF_HOCOSF = 0x1
	// The HOCO clock is stopped or is not yet stable
	SYSC_OSCSF_HOCOSF_0 = 0x0
	// The HOCO clock is stable, so is available for use as the system clock
	SYSC_OSCSF_HOCOSF_1 = 0x1
	// Position of MOSCSF field.
	SYSC_OSCSF_MOSCSF_Pos = 0x3
	// Bit mask of MOSCSF field.
	SYSC_OSCSF_MOSCSF_Msk = 0x8
	// Bit MOSCSF.
	SYSC_OSCSF_MOSCSF = 0x8
	// The main clock oscillator is stopped (MOSTP = 1) or is not yet stable
	SYSC_OSCSF_MOSCSF_0 = 0x0
	// The main clock oscillator is stable, so is available for use as the system clock
	SYSC_OSCSF_MOSCSF_1 = 0x1

	// CKOCR: Clock Out Control Register
	// Position of CKOSEL field.
	SYSC_CKOCR_CKOSEL_Pos = 0x0
	// Bit mask of CKOSEL field.
	SYSC_CKOCR_CKOSEL_Msk = 0x7
	// HOCO (value after reset)
	SYSC_CKOCR_CKOSEL_000 = 0x0
	// MOCO
	SYSC_CKOCR_CKOSEL_001 = 0x1
	// LOCO
	SYSC_CKOCR_CKOSEL_010 = 0x2
	// MOSC
	SYSC_CKOCR_CKOSEL_011 = 0x3
	// SOSC
	SYSC_CKOCR_CKOSEL_100 = 0x4
	// Setting prohibited
	SYSC_CKOCR_CKOSEL_101 = 0x5
	// Position of CKODIV field.
	SYSC_CKOCR_CKODIV_Pos = 0x4
	// Bit mask of CKODIV field.
	SYSC_CKOCR_CKODIV_Msk = 0x70
	// x 1/1
	SYSC_CKOCR_CKODIV_000 = 0x0
	// x 1/2
	SYSC_CKOCR_CKODIV_001 = 0x1
	// x 1/4
	SYSC_CKOCR_CKODIV_010 = 0x2
	// x 1/8
	SYSC_CKOCR_CKODIV_011 = 0x3
	// x 1/16
	SYSC_CKOCR_CKODIV_100 = 0x4
	// x 1/32
	SYSC_CKOCR_CKODIV_101 = 0x5
	// x 1/64
	SYSC_CKOCR_CKODIV_110 = 0x6
	// x 1/128
	SYSC_CKOCR_CKODIV_111 = 0x7
	// Position of CKOEN field.
	SYSC_CKOCR_CKOEN_Pos = 0x7
	// Bit mask of CKOEN field.
	SYSC_CKOCR_CKOEN_Msk = 0x80
	// Bit CKOEN.
	SYSC_CKOCR_CKOEN = 0x80
	// Disable clock out
	SYSC_CKOCR_CKOEN_0 = 0x0
	// Enable clock out
	SYSC_CKOCR_CKOEN_1 = 0x1

	// OSTDCR: Oscillation Stop Detection Control Register
	// Position of OSTDIE field.
	SYSC_OSTDCR_OSTDIE_Pos = 0x0
	// Bit mask of OSTDIE field.
	SYSC_OSTDCR_OSTDIE_Msk = 0x1
	// Bit OSTDIE.
	SYSC_OSTDCR_OSTDIE = 0x1
	// Disable oscillation stop detection interrupt (do not notify the POEG)
	SYSC_OSTDCR_OSTDIE_0 = 0x0
	// Enable oscillation stop detection interrupt (notify the POEG)
	SYSC_OSTDCR_OSTDIE_1 = 0x1
	// Position of OSTDE field.
	SYSC_OSTDCR_OSTDE_Pos = 0x7
	// Bit mask of OSTDE field.
	SYSC_OSTDCR_OSTDE_Msk = 0x80
	// Bit OSTDE.
	SYSC_OSTDCR_OSTDE = 0x80
	// Disable oscillation stop detection function
	SYSC_OSTDCR_OSTDE_0 = 0x0
	// Enable oscillation stop detection function
	SYSC_OSTDCR_OSTDE_1 = 0x1

	// OSTDSR: Oscillation Stop Detection Status Register
	// Position of OSTDF field.
	SYSC_OSTDSR_OSTDF_Pos = 0x0
	// Bit mask of OSTDF field.
	SYSC_OSTDSR_OSTDF_Msk = 0x1
	// Bit OSTDF.
	SYSC_OSTDSR_OSTDF = 0x1
	// Main clock oscillation stop not detected
	SYSC_OSTDSR_OSTDF_0 = 0x0
	// Main clock oscillation stop detected
	SYSC_OSTDSR_OSTDF_1 = 0x1

	// LPOPT: Lower Power Operation Control Register
	// Position of MPUDIS field.
	SYSC_LPOPT_MPUDIS_Pos = 0x0
	// Bit mask of MPUDIS field.
	SYSC_LPOPT_MPUDIS_Msk = 0x1
	// Bit MPUDIS.
	SYSC_LPOPT_MPUDIS = 0x1
	// MPU operates as normal
	SYSC_LPOPT_MPUDIS_0 = 0x0
	// MPU operate clock stops (MPU function disable).
	SYSC_LPOPT_MPUDIS_1 = 0x1
	// Position of DCLKDIS field.
	SYSC_LPOPT_DCLKDIS_Pos = 0x1
	// Bit mask of DCLKDIS field.
	SYSC_LPOPT_DCLKDIS_Msk = 0x6
	// Debug clock does not stop
	SYSC_LPOPT_DCLKDIS_00 = 0x0
	// Position of BPFCLKDIS field.
	SYSC_LPOPT_BPFCLKDIS_Pos = 0x3
	// Bit mask of BPFCLKDIS field.
	SYSC_LPOPT_BPFCLKDIS_Msk = 0x8
	// Bit BPFCLKDIS.
	SYSC_LPOPT_BPFCLKDIS = 0x8
	// Flash register R/W clock operates as normal
	SYSC_LPOPT_BPFCLKDIS_0 = 0x0
	// Flash register R/W clock stops.
	SYSC_LPOPT_BPFCLKDIS_1 = 0x1
	// Position of LPOPTEN field.
	SYSC_LPOPT_LPOPTEN_Pos = 0x7
	// Bit mask of LPOPTEN field.
	SYSC_LPOPT_LPOPTEN_Msk = 0x80
	// Bit LPOPTEN.
	SYSC_LPOPT_LPOPTEN = 0x80
	// All lower power counter measure disable
	SYSC_LPOPT_LPOPTEN_0 = 0x0
	// All lower power counter measure enable
	SYSC_LPOPT_LPOPTEN_1 = 0x1

	// MOCOUTCR: MOCO User Trimming Control Register
	// Position of MOCOUTRM field.
	SYSC_MOCOUTCR_MOCOUTRM_Pos = 0x0
	// Bit mask of MOCOUTRM field.
	SYSC_MOCOUTCR_MOCOUTRM_Msk = 0xff

	// HOCOUTCR: HOCO User Trimming Control Register
	// Position of HOCOUTRM field.
	SYSC_HOCOUTCR_HOCOUTRM_Pos = 0x0
	// Bit mask of HOCOUTRM field.
	SYSC_HOCOUTCR_HOCOUTRM_Msk = 0xff

	// SNZCR: Snooze Control Register
	// Position of RXDREQEN field.
	SYSC_SNZCR_RXDREQEN_Pos = 0x0
	// Bit mask of RXDREQEN field.
	SYSC_SNZCR_RXDREQEN_Msk = 0x1
	// Bit RXDREQEN.
	SYSC_SNZCR_RXDREQEN = 0x1
	// Ignore RXD0 falling edge in Software Standby mode
	SYSC_SNZCR_RXDREQEN_0 = 0x0
	// Detect RXD0 falling edge in Software Standby mode
	SYSC_SNZCR_RXDREQEN_1 = 0x1
	// Position of SNZDTCEN field.
	SYSC_SNZCR_SNZDTCEN_Pos = 0x1
	// Bit mask of SNZDTCEN field.
	SYSC_SNZCR_SNZDTCEN_Msk = 0x2
	// Bit SNZDTCEN.
	SYSC_SNZCR_SNZDTCEN = 0x2
	// Disable DTC operation
	SYSC_SNZCR_SNZDTCEN_0 = 0x0
	// Enable DTC operation
	SYSC_SNZCR_SNZDTCEN_1 = 0x1
	// Position of SNZE field.
	SYSC_SNZCR_SNZE_Pos = 0x7
	// Bit mask of SNZE field.
	SYSC_SNZCR_SNZE_Msk = 0x80
	// Bit SNZE.
	SYSC_SNZCR_SNZE = 0x80
	// Disable Snooze mode
	SYSC_SNZCR_SNZE_0 = 0x0
	// Enable Snooze mode
	SYSC_SNZCR_SNZE_1 = 0x1

	// SNZEDCR0: Snooze End Control Register 0
	// Position of AGTUNFED field.
	SYSC_SNZEDCR0_AGTUNFED_Pos = 0x0
	// Bit mask of AGTUNFED field.
	SYSC_SNZEDCR0_AGTUNFED_Msk = 0x1
	// Bit AGTUNFED.
	SYSC_SNZEDCR0_AGTUNFED = 0x1
	// Disable the snooze end request
	SYSC_SNZEDCR0_AGTUNFED_0 = 0x0
	// Enable the snooze end request
	SYSC_SNZEDCR0_AGTUNFED_1 = 0x1
	// Position of DTCZRED field.
	SYSC_SNZEDCR0_DTCZRED_Pos = 0x1
	// Bit mask of DTCZRED field.
	SYSC_SNZEDCR0_DTCZRED_Msk = 0x2
	// Bit DTCZRED.
	SYSC_SNZEDCR0_DTCZRED = 0x2
	// Disable the snooze end request
	SYSC_SNZEDCR0_DTCZRED_0 = 0x0
	// Enable the snooze end request
	SYSC_SNZEDCR0_DTCZRED_1 = 0x1
	// Position of DTCNZRED field.
	SYSC_SNZEDCR0_DTCNZRED_Pos = 0x2
	// Bit mask of DTCNZRED field.
	SYSC_SNZEDCR0_DTCNZRED_Msk = 0x4
	// Bit DTCNZRED.
	SYSC_SNZEDCR0_DTCNZRED = 0x4
	// Disable the snooze end request
	SYSC_SNZEDCR0_DTCNZRED_0 = 0x0
	// Enable the snooze end request
	SYSC_SNZEDCR0_DTCNZRED_1 = 0x1
	// Position of AD0MATED field.
	SYSC_SNZEDCR0_AD0MATED_Pos = 0x3
	// Bit mask of AD0MATED field.
	SYSC_SNZEDCR0_AD0MATED_Msk = 0x8
	// Bit AD0MATED.
	SYSC_SNZEDCR0_AD0MATED = 0x8
	// Disable the snooze end request
	SYSC_SNZEDCR0_AD0MATED_0 = 0x0
	// Enable the snooze end request
	SYSC_SNZEDCR0_AD0MATED_1 = 0x1
	// Position of AD0UMTED field.
	SYSC_SNZEDCR0_AD0UMTED_Pos = 0x4
	// Bit mask of AD0UMTED field.
	SYSC_SNZEDCR0_AD0UMTED_Msk = 0x10
	// Bit AD0UMTED.
	SYSC_SNZEDCR0_AD0UMTED = 0x10
	// Disable the snooze end request
	SYSC_SNZEDCR0_AD0UMTED_0 = 0x0
	// Enable the snooze end request
	SYSC_SNZEDCR0_AD0UMTED_1 = 0x1
	// Position of SCI0UMTED field.
	SYSC_SNZEDCR0_SCI0UMTED_Pos = 0x7
	// Bit mask of SCI0UMTED field.
	SYSC_SNZEDCR0_SCI0UMTED_Msk = 0x80
	// Bit SCI0UMTED.
	SYSC_SNZEDCR0_SCI0UMTED = 0x80
	// Disable the snooze end request
	SYSC_SNZEDCR0_SCI0UMTED_0 = 0x0
	// Enable the snooze end request
	SYSC_SNZEDCR0_SCI0UMTED_1 = 0x1

	// SNZREQCR0: Snooze Request Control Register 0
	// Position of SNZREQEN0 field.
	SYSC_SNZREQCR0_SNZREQEN0_Pos = 0x0
	// Bit mask of SNZREQEN0 field.
	SYSC_SNZREQCR0_SNZREQEN0_Msk = 0x1
	// Bit SNZREQEN0.
	SYSC_SNZREQCR0_SNZREQEN0 = 0x1
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN0_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN0_1 = 0x1
	// Position of SNZREQEN1 field.
	SYSC_SNZREQCR0_SNZREQEN1_Pos = 0x1
	// Bit mask of SNZREQEN1 field.
	SYSC_SNZREQCR0_SNZREQEN1_Msk = 0x2
	// Bit SNZREQEN1.
	SYSC_SNZREQCR0_SNZREQEN1 = 0x2
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN1_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN1_1 = 0x1
	// Position of SNZREQEN2 field.
	SYSC_SNZREQCR0_SNZREQEN2_Pos = 0x2
	// Bit mask of SNZREQEN2 field.
	SYSC_SNZREQCR0_SNZREQEN2_Msk = 0x4
	// Bit SNZREQEN2.
	SYSC_SNZREQCR0_SNZREQEN2 = 0x4
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN2_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN2_1 = 0x1
	// Position of SNZREQEN3 field.
	SYSC_SNZREQCR0_SNZREQEN3_Pos = 0x3
	// Bit mask of SNZREQEN3 field.
	SYSC_SNZREQCR0_SNZREQEN3_Msk = 0x8
	// Bit SNZREQEN3.
	SYSC_SNZREQCR0_SNZREQEN3 = 0x8
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN3_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN3_1 = 0x1
	// Position of SNZREQEN4 field.
	SYSC_SNZREQCR0_SNZREQEN4_Pos = 0x4
	// Bit mask of SNZREQEN4 field.
	SYSC_SNZREQCR0_SNZREQEN4_Msk = 0x10
	// Bit SNZREQEN4.
	SYSC_SNZREQCR0_SNZREQEN4 = 0x10
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN4_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN4_1 = 0x1
	// Position of SNZREQEN5 field.
	SYSC_SNZREQCR0_SNZREQEN5_Pos = 0x5
	// Bit mask of SNZREQEN5 field.
	SYSC_SNZREQCR0_SNZREQEN5_Msk = 0x20
	// Bit SNZREQEN5.
	SYSC_SNZREQCR0_SNZREQEN5 = 0x20
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN5_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN5_1 = 0x1
	// Position of SNZREQEN6 field.
	SYSC_SNZREQCR0_SNZREQEN6_Pos = 0x6
	// Bit mask of SNZREQEN6 field.
	SYSC_SNZREQCR0_SNZREQEN6_Msk = 0x40
	// Bit SNZREQEN6.
	SYSC_SNZREQCR0_SNZREQEN6 = 0x40
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN6_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN6_1 = 0x1
	// Position of SNZREQEN7 field.
	SYSC_SNZREQCR0_SNZREQEN7_Pos = 0x7
	// Bit mask of SNZREQEN7 field.
	SYSC_SNZREQCR0_SNZREQEN7_Msk = 0x80
	// Bit SNZREQEN7.
	SYSC_SNZREQCR0_SNZREQEN7 = 0x80
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN7_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN7_1 = 0x1
	// Position of SNZREQEN17 field.
	SYSC_SNZREQCR0_SNZREQEN17_Pos = 0x11
	// Bit mask of SNZREQEN17 field.
	SYSC_SNZREQCR0_SNZREQEN17_Msk = 0x20000
	// Bit SNZREQEN17.
	SYSC_SNZREQCR0_SNZREQEN17 = 0x20000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN17_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN17_1 = 0x1
	// Position of SNZREQEN23 field.
	SYSC_SNZREQCR0_SNZREQEN23_Pos = 0x17
	// Bit mask of SNZREQEN23 field.
	SYSC_SNZREQCR0_SNZREQEN23_Msk = 0x800000
	// Bit SNZREQEN23.
	SYSC_SNZREQCR0_SNZREQEN23 = 0x800000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN23_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN23_1 = 0x1
	// Position of SNZREQEN24 field.
	SYSC_SNZREQCR0_SNZREQEN24_Pos = 0x18
	// Bit mask of SNZREQEN24 field.
	SYSC_SNZREQCR0_SNZREQEN24_Msk = 0x1000000
	// Bit SNZREQEN24.
	SYSC_SNZREQCR0_SNZREQEN24 = 0x1000000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN24_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN24_1 = 0x1
	// Position of SNZREQEN25 field.
	SYSC_SNZREQCR0_SNZREQEN25_Pos = 0x19
	// Bit mask of SNZREQEN25 field.
	SYSC_SNZREQCR0_SNZREQEN25_Msk = 0x2000000
	// Bit SNZREQEN25.
	SYSC_SNZREQCR0_SNZREQEN25 = 0x2000000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN25_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN25_1 = 0x1
	// Position of SNZREQEN28 field.
	SYSC_SNZREQCR0_SNZREQEN28_Pos = 0x1c
	// Bit mask of SNZREQEN28 field.
	SYSC_SNZREQCR0_SNZREQEN28_Msk = 0x10000000
	// Bit SNZREQEN28.
	SYSC_SNZREQCR0_SNZREQEN28 = 0x10000000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN28_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN28_1 = 0x1
	// Position of SNZREQEN29 field.
	SYSC_SNZREQCR0_SNZREQEN29_Pos = 0x1d
	// Bit mask of SNZREQEN29 field.
	SYSC_SNZREQCR0_SNZREQEN29_Msk = 0x20000000
	// Bit SNZREQEN29.
	SYSC_SNZREQCR0_SNZREQEN29 = 0x20000000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN29_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN29_1 = 0x1
	// Position of SNZREQEN30 field.
	SYSC_SNZREQCR0_SNZREQEN30_Pos = 0x1e
	// Bit mask of SNZREQEN30 field.
	SYSC_SNZREQCR0_SNZREQEN30_Msk = 0x40000000
	// Bit SNZREQEN30.
	SYSC_SNZREQCR0_SNZREQEN30 = 0x40000000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN30_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN30_1 = 0x1

	// PSMCR: Power Save Memory Control Register
	// Position of PSMC field.
	SYSC_PSMCR_PSMC_Pos = 0x0
	// Bit mask of PSMC field.
	SYSC_PSMCR_PSMC_Msk = 0x3
	// All SRAMs are on in Software Standby mode
	SYSC_PSMCR_PSMC_00 = 0x0
	// 8 KB SRAM (0x2000_4000 to 0x2000_5FFF) is on in Software Standby mode
	SYSC_PSMCR_PSMC_01 = 0x1
	// Setting prohibited
	SYSC_PSMCR_PSMC_10 = 0x2
	// Setting prohibited
	SYSC_PSMCR_PSMC_11 = 0x3

	// OPCCR: Operating Power Control Register
	// Position of OPCM field.
	SYSC_OPCCR_OPCM_Pos = 0x0
	// Bit mask of OPCM field.
	SYSC_OPCCR_OPCM_Msk = 0x3
	// High-speed mode
	SYSC_OPCCR_OPCM_00 = 0x0
	// Middle-speed mode
	SYSC_OPCCR_OPCM_01 = 0x1
	// Setting prohibited
	SYSC_OPCCR_OPCM_10 = 0x2
	// Low-speed mode
	SYSC_OPCCR_OPCM_11 = 0x3
	// Position of OPCMTSF field.
	SYSC_OPCCR_OPCMTSF_Pos = 0x4
	// Bit mask of OPCMTSF field.
	SYSC_OPCCR_OPCMTSF_Msk = 0x10
	// Bit OPCMTSF.
	SYSC_OPCCR_OPCMTSF = 0x10
	// Transition completed
	SYSC_OPCCR_OPCMTSF_0 = 0x0
	// During transition
	SYSC_OPCCR_OPCMTSF_1 = 0x1

	// MOSCWTCR: Main Clock Oscillator Wait Control Register
	// Position of MSTS field.
	SYSC_MOSCWTCR_MSTS_Pos = 0x0
	// Bit mask of MSTS field.
	SYSC_MOSCWTCR_MSTS_Msk = 0xf
	// Wait time = 2 cycles (0.25 us)
	SYSC_MOSCWTCR_MSTS_0x0 = 0x0
	// Wait time = 1024 cycles (128 us)
	SYSC_MOSCWTCR_MSTS_0x1 = 0x1
	// Wait time = 2048 cycles (256 us)
	SYSC_MOSCWTCR_MSTS_0x2 = 0x2
	// Wait time = 4096 cycles (512 us)
	SYSC_MOSCWTCR_MSTS_0x3 = 0x3
	// Wait time = 8192 cycles (1024 us)
	SYSC_MOSCWTCR_MSTS_0x4 = 0x4
	// Wait time = 16384 cycles (2048 us)
	SYSC_MOSCWTCR_MSTS_0x5 = 0x5
	// Wait time = 32768 cycles (4096 us)
	SYSC_MOSCWTCR_MSTS_0x6 = 0x6
	// Wait time = 65536 cycles (8192 us)
	SYSC_MOSCWTCR_MSTS_0x7 = 0x7
	// Wait time = 131072 cycles (16384 us)
	SYSC_MOSCWTCR_MSTS_0x8 = 0x8
	// Wait time = 262144 cycles (32768 us)
	SYSC_MOSCWTCR_MSTS_0x9 = 0x9

	// SOPCCR: Sub Operating Power Control Register
	// Position of SOPCM field.
	SYSC_SOPCCR_SOPCM_Pos = 0x0
	// Bit mask of SOPCM field.
	SYSC_SOPCCR_SOPCM_Msk = 0x1
	// Bit SOPCM.
	SYSC_SOPCCR_SOPCM = 0x1
	// Other than Subosc-speed mode
	SYSC_SOPCCR_SOPCM_0 = 0x0
	// Subosc-speed mode
	SYSC_SOPCCR_SOPCM_1 = 0x1
	// Position of SOPCMTSF field.
	SYSC_SOPCCR_SOPCMTSF_Pos = 0x4
	// Bit mask of SOPCMTSF field.
	SYSC_SOPCCR_SOPCMTSF_Msk = 0x10
	// Bit SOPCMTSF.
	SYSC_SOPCCR_SOPCMTSF = 0x10
	// Transition completed
	SYSC_SOPCCR_SOPCMTSF_0 = 0x0
	// During transition
	SYSC_SOPCCR_SOPCMTSF_1 = 0x1

	// RSTSR1: Reset Status Register 1
	// Position of IWDTRF field.
	SYSC_RSTSR1_IWDTRF_Pos = 0x0
	// Bit mask of IWDTRF field.
	SYSC_RSTSR1_IWDTRF_Msk = 0x1
	// Bit IWDTRF.
	SYSC_RSTSR1_IWDTRF = 0x1
	// Independent watchdog timer reset not detected
	SYSC_RSTSR1_IWDTRF_0 = 0x0
	// Independent watchdog timer reset detected
	SYSC_RSTSR1_IWDTRF_1 = 0x1
	// Position of WDTRF field.
	SYSC_RSTSR1_WDTRF_Pos = 0x1
	// Bit mask of WDTRF field.
	SYSC_RSTSR1_WDTRF_Msk = 0x2
	// Bit WDTRF.
	SYSC_RSTSR1_WDTRF = 0x2
	// Watchdog timer reset not detected
	SYSC_RSTSR1_WDTRF_0 = 0x0
	// Watchdog timer reset detected
	SYSC_RSTSR1_WDTRF_1 = 0x1
	// Position of SWRF field.
	SYSC_RSTSR1_SWRF_Pos = 0x2
	// Bit mask of SWRF field.
	SYSC_RSTSR1_SWRF_Msk = 0x4
	// Bit SWRF.
	SYSC_RSTSR1_SWRF = 0x4
	// Software reset not detected
	SYSC_RSTSR1_SWRF_0 = 0x0
	// Software reset detected
	SYSC_RSTSR1_SWRF_1 = 0x1
	// Position of RPERF field.
	SYSC_RSTSR1_RPERF_Pos = 0x8
	// Bit mask of RPERF field.
	SYSC_RSTSR1_RPERF_Msk = 0x100
	// Bit RPERF.
	SYSC_RSTSR1_RPERF = 0x100
	// SRAM parity error reset not detected
	SYSC_RSTSR1_RPERF_0 = 0x0
	// SRAM parity error reset detected
	SYSC_RSTSR1_RPERF_1 = 0x1
	// Position of REERF field.
	SYSC_RSTSR1_REERF_Pos = 0x9
	// Bit mask of REERF field.
	SYSC_RSTSR1_REERF_Msk = 0x200
	// Bit REERF.
	SYSC_RSTSR1_REERF = 0x200
	// SRAM ECC error reset not detected
	SYSC_RSTSR1_REERF_0 = 0x0
	// SRAM ECC error reset detected
	SYSC_RSTSR1_REERF_1 = 0x1
	// Position of BUSSRF field.
	SYSC_RSTSR1_BUSSRF_Pos = 0xa
	// Bit mask of BUSSRF field.
	SYSC_RSTSR1_BUSSRF_Msk = 0x400
	// Bit BUSSRF.
	SYSC_RSTSR1_BUSSRF = 0x400
	// Bus slave MPU error reset not detected
	SYSC_RSTSR1_BUSSRF_0 = 0x0
	// Bus slave MPU error reset detected
	SYSC_RSTSR1_BUSSRF_1 = 0x1
	// Position of BUSMRF field.
	SYSC_RSTSR1_BUSMRF_Pos = 0xb
	// Bit mask of BUSMRF field.
	SYSC_RSTSR1_BUSMRF_Msk = 0x800
	// Bit BUSMRF.
	SYSC_RSTSR1_BUSMRF = 0x800
	// Bus master MPU error reset not detected
	SYSC_RSTSR1_BUSMRF_0 = 0x0
	// Bus master MPU error reset detected
	SYSC_RSTSR1_BUSMRF_1 = 0x1
	// Position of SPERF field.
	SYSC_RSTSR1_SPERF_Pos = 0xc
	// Bit mask of SPERF field.
	SYSC_RSTSR1_SPERF_Msk = 0x1000
	// Bit SPERF.
	SYSC_RSTSR1_SPERF = 0x1000
	// CPU stack pointer error reset not detected
	SYSC_RSTSR1_SPERF_0 = 0x0
	// CPU stack pointer error reset detected
	SYSC_RSTSR1_SPERF_1 = 0x1

	// LVD1CR1: Voltage Monitor 1 Circuit Control Register
	// Position of IDTSEL field.
	SYSC_LVD1CR1_IDTSEL_Pos = 0x0
	// Bit mask of IDTSEL field.
	SYSC_LVD1CR1_IDTSEL_Msk = 0x3
	// When VCC >= Vdet1 (rise) is detected
	SYSC_LVD1CR1_IDTSEL_00 = 0x0
	// When VCC < Vdet1 (fall) is detected
	SYSC_LVD1CR1_IDTSEL_01 = 0x1
	// When fall and rise are detected
	SYSC_LVD1CR1_IDTSEL_10 = 0x2
	// Settings prohibited
	SYSC_LVD1CR1_IDTSEL_11 = 0x3
	// Position of IRQSEL field.
	SYSC_LVD1CR1_IRQSEL_Pos = 0x2
	// Bit mask of IRQSEL field.
	SYSC_LVD1CR1_IRQSEL_Msk = 0x4
	// Bit IRQSEL.
	SYSC_LVD1CR1_IRQSEL = 0x4
	// Non-maskable interrupt
	SYSC_LVD1CR1_IRQSEL_0 = 0x0
	// Maskable interrupt
	SYSC_LVD1CR1_IRQSEL_1 = 0x1

	// LVD1SR: Voltage Monitor 1 Circuit Status Register
	// Position of DET field.
	SYSC_LVD1SR_DET_Pos = 0x0
	// Bit mask of DET field.
	SYSC_LVD1SR_DET_Msk = 0x1
	// Bit DET.
	SYSC_LVD1SR_DET = 0x1
	// Not detected
	SYSC_LVD1SR_DET_0 = 0x0
	// Vdet1 crossing is detected
	SYSC_LVD1SR_DET_1 = 0x1
	// Position of MON field.
	SYSC_LVD1SR_MON_Pos = 0x1
	// Bit mask of MON field.
	SYSC_LVD1SR_MON_Msk = 0x2
	// Bit MON.
	SYSC_LVD1SR_MON = 0x2
	// VCC < Vdet1
	SYSC_LVD1SR_MON_0 = 0x0
	// VCC >= Vdet1 or MON is disabled
	SYSC_LVD1SR_MON_1 = 0x1

	// LVD2CR1: Voltage Monitor 2 Circuit Control Register 1
	// Position of IDTSEL field.
	SYSC_LVD2CR1_IDTSEL_Pos = 0x0
	// Bit mask of IDTSEL field.
	SYSC_LVD2CR1_IDTSEL_Msk = 0x3
	// When VCC>= Vdet2 (rise) is detected
	SYSC_LVD2CR1_IDTSEL_00 = 0x0
	// When VCC < Vdet2 (fall) is detected
	SYSC_LVD2CR1_IDTSEL_01 = 0x1
	// When fall and rise are detected
	SYSC_LVD2CR1_IDTSEL_10 = 0x2
	// Settings prohibited
	SYSC_LVD2CR1_IDTSEL_11 = 0x3
	// Position of IRQSEL field.
	SYSC_LVD2CR1_IRQSEL_Pos = 0x2
	// Bit mask of IRQSEL field.
	SYSC_LVD2CR1_IRQSEL_Msk = 0x4
	// Bit IRQSEL.
	SYSC_LVD2CR1_IRQSEL = 0x4
	// Non-maskable interrupt
	SYSC_LVD2CR1_IRQSEL_0 = 0x0
	// Maskable interrupt
	SYSC_LVD2CR1_IRQSEL_1 = 0x1

	// LVD2SR: Voltage Monitor 2 Circuit Status Register
	// Position of DET field.
	SYSC_LVD2SR_DET_Pos = 0x0
	// Bit mask of DET field.
	SYSC_LVD2SR_DET_Msk = 0x1
	// Bit DET.
	SYSC_LVD2SR_DET = 0x1
	// Not detected
	SYSC_LVD2SR_DET_0 = 0x0
	// Vdet2 crossing is detected
	SYSC_LVD2SR_DET_1 = 0x1
	// Position of MON field.
	SYSC_LVD2SR_MON_Pos = 0x1
	// Bit mask of MON field.
	SYSC_LVD2SR_MON_Msk = 0x2
	// Bit MON.
	SYSC_LVD2SR_MON = 0x2
	// VCC < Vdet2
	SYSC_LVD2SR_MON_0 = 0x0
	// VCC>= Vdet2 or MON is disabled
	SYSC_LVD2SR_MON_1 = 0x1

	// PRCR: Protect Register
	// Position of PRC0 field.
	SYSC_PRCR_PRC0_Pos = 0x0
	// Bit mask of PRC0 field.
	SYSC_PRCR_PRC0_Msk = 0x1
	// Bit PRC0.
	SYSC_PRCR_PRC0 = 0x1
	// Disable writes
	SYSC_PRCR_PRC0_0 = 0x0
	// Enable writes
	SYSC_PRCR_PRC0_1 = 0x1
	// Position of PRC1 field.
	SYSC_PRCR_PRC1_Pos = 0x1
	// Bit mask of PRC1 field.
	SYSC_PRCR_PRC1_Msk = 0x2
	// Bit PRC1.
	SYSC_PRCR_PRC1 = 0x2
	// Disable writes
	SYSC_PRCR_PRC1_0 = 0x0
	// Enable writes
	SYSC_PRCR_PRC1_1 = 0x1
	// Position of PRC3 field.
	SYSC_PRCR_PRC3_Pos = 0x3
	// Bit mask of PRC3 field.
	SYSC_PRCR_PRC3_Msk = 0x8
	// Bit PRC3.
	SYSC_PRCR_PRC3 = 0x8
	// Disable writes
	SYSC_PRCR_PRC3_0 = 0x0
	// Enable writes
	SYSC_PRCR_PRC3_1 = 0x1
	// Position of PRKEY field.
	SYSC_PRCR_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	SYSC_PRCR_PRKEY_Msk = 0xff00

	// SYOCDCR: System Control OCD Control Register
	// Position of DBGEN field.
	SYSC_SYOCDCR_DBGEN_Pos = 0x7
	// Bit mask of DBGEN field.
	SYSC_SYOCDCR_DBGEN_Msk = 0x80
	// Bit DBGEN.
	SYSC_SYOCDCR_DBGEN = 0x80
	// On-chip debugger is disabled
	SYSC_SYOCDCR_DBGEN_0 = 0x0
	// On-chip debugger is enabled
	SYSC_SYOCDCR_DBGEN_1 = 0x1

	// RSTSR0: Reset Status Register 0
	// Position of PORF field.
	SYSC_RSTSR0_PORF_Pos = 0x0
	// Bit mask of PORF field.
	SYSC_RSTSR0_PORF_Msk = 0x1
	// Bit PORF.
	SYSC_RSTSR0_PORF = 0x1
	// Power-on reset not detected
	SYSC_RSTSR0_PORF_0 = 0x0
	// Power-on reset detected
	SYSC_RSTSR0_PORF_1 = 0x1
	// Position of LVD0RF field.
	SYSC_RSTSR0_LVD0RF_Pos = 0x1
	// Bit mask of LVD0RF field.
	SYSC_RSTSR0_LVD0RF_Msk = 0x2
	// Bit LVD0RF.
	SYSC_RSTSR0_LVD0RF = 0x2
	// Voltage monitor 0 reset not detected
	SYSC_RSTSR0_LVD0RF_0 = 0x0
	// Voltage monitor 0 reset detected
	SYSC_RSTSR0_LVD0RF_1 = 0x1
	// Position of LVD1RF field.
	SYSC_RSTSR0_LVD1RF_Pos = 0x2
	// Bit mask of LVD1RF field.
	SYSC_RSTSR0_LVD1RF_Msk = 0x4
	// Bit LVD1RF.
	SYSC_RSTSR0_LVD1RF = 0x4
	// Voltage monitor 1 reset not detected
	SYSC_RSTSR0_LVD1RF_0 = 0x0
	// Voltage monitor 1 reset detected
	SYSC_RSTSR0_LVD1RF_1 = 0x1
	// Position of LVD2RF field.
	SYSC_RSTSR0_LVD2RF_Pos = 0x3
	// Bit mask of LVD2RF field.
	SYSC_RSTSR0_LVD2RF_Msk = 0x8
	// Bit LVD2RF.
	SYSC_RSTSR0_LVD2RF = 0x8
	// Voltage monitor 2 reset not detected
	SYSC_RSTSR0_LVD2RF_0 = 0x0
	// Voltage monitor 2 reset detected
	SYSC_RSTSR0_LVD2RF_1 = 0x1

	// RSTSR2: Reset Status Register 2
	// Position of CWSF field.
	SYSC_RSTSR2_CWSF_Pos = 0x0
	// Bit mask of CWSF field.
	SYSC_RSTSR2_CWSF_Msk = 0x1
	// Bit CWSF.
	SYSC_RSTSR2_CWSF = 0x1
	// Cold start
	SYSC_RSTSR2_CWSF_0 = 0x0
	// Warm start
	SYSC_RSTSR2_CWSF_1 = 0x1

	// MOMCR: Main Clock Oscillator Mode Oscillation Control Register
	// Position of MODRV1 field.
	SYSC_MOMCR_MODRV1_Pos = 0x3
	// Bit mask of MODRV1 field.
	SYSC_MOMCR_MODRV1_Msk = 0x8
	// Bit MODRV1.
	SYSC_MOMCR_MODRV1 = 0x8
	// 10 MHz to 20 MHz
	SYSC_MOMCR_MODRV1_0 = 0x0
	// 1 MHz to 10 MHz
	SYSC_MOMCR_MODRV1_1 = 0x1
	// Position of MOSEL field.
	SYSC_MOMCR_MOSEL_Pos = 0x6
	// Bit mask of MOSEL field.
	SYSC_MOMCR_MOSEL_Msk = 0x40
	// Bit MOSEL.
	SYSC_MOMCR_MOSEL = 0x40
	// Resonator
	SYSC_MOMCR_MOSEL_0 = 0x0
	// External clock input
	SYSC_MOMCR_MOSEL_1 = 0x1

	// LVCMPCR: Voltage Monitor Circuit Control Register
	// Position of LVD1E field.
	SYSC_LVCMPCR_LVD1E_Pos = 0x5
	// Bit mask of LVD1E field.
	SYSC_LVCMPCR_LVD1E_Msk = 0x20
	// Bit LVD1E.
	SYSC_LVCMPCR_LVD1E = 0x20
	// Voltage detection 1 circuit disabled
	SYSC_LVCMPCR_LVD1E_0 = 0x0
	// Voltage detection 1 circuit enabled
	SYSC_LVCMPCR_LVD1E_1 = 0x1
	// Position of LVD2E field.
	SYSC_LVCMPCR_LVD2E_Pos = 0x6
	// Bit mask of LVD2E field.
	SYSC_LVCMPCR_LVD2E_Msk = 0x40
	// Bit LVD2E.
	SYSC_LVCMPCR_LVD2E = 0x40
	// Voltage detection 2 circuit disabled
	SYSC_LVCMPCR_LVD2E_0 = 0x0
	// Voltage detection 2 circuit enabled
	SYSC_LVCMPCR_LVD2E_1 = 0x1

	// LVDLVLR: Voltage Detection Level Select Register
	// Position of LVD1LVL field.
	SYSC_LVDLVLR_LVD1LVL_Pos = 0x0
	// Bit mask of LVD1LVL field.
	SYSC_LVDLVLR_LVD1LVL_Msk = 0x1f
	// Vdet1_0
	SYSC_LVDLVLR_LVD1LVL_0x00 = 0x0
	// Vdet1_1
	SYSC_LVDLVLR_LVD1LVL_0x01 = 0x1
	// Vdet1_2
	SYSC_LVDLVLR_LVD1LVL_0x02 = 0x2
	// Vdet1_3
	SYSC_LVDLVLR_LVD1LVL_0x03 = 0x3
	// Vdet1_4
	SYSC_LVDLVLR_LVD1LVL_0x04 = 0x4
	// Vdet1_5
	SYSC_LVDLVLR_LVD1LVL_0x05 = 0x5
	// Vdet1_6
	SYSC_LVDLVLR_LVD1LVL_0x06 = 0x6
	// Vdet1_7
	SYSC_LVDLVLR_LVD1LVL_0x07 = 0x7
	// Vdet1_8
	SYSC_LVDLVLR_LVD1LVL_0x08 = 0x8
	// Vdet1_9
	SYSC_LVDLVLR_LVD1LVL_0x09 = 0x9
	// Vdet1_A
	SYSC_LVDLVLR_LVD1LVL_0x0A = 0xa
	// Vdet1_B
	SYSC_LVDLVLR_LVD1LVL_0x0B = 0xb
	// Vdet1_C
	SYSC_LVDLVLR_LVD1LVL_0x0C = 0xc
	// Vdet1_D
	SYSC_LVDLVLR_LVD1LVL_0x0D = 0xd
	// Vdet1_E
	SYSC_LVDLVLR_LVD1LVL_0x0E = 0xe
	// Vdet1_F
	SYSC_LVDLVLR_LVD1LVL_0x0F = 0xf
	// Position of LVD2LVL field.
	SYSC_LVDLVLR_LVD2LVL_Pos = 0x5
	// Bit mask of LVD2LVL field.
	SYSC_LVDLVLR_LVD2LVL_Msk = 0xe0
	// Vdet2_0
	SYSC_LVDLVLR_LVD2LVL_000 = 0x0
	// Vdet2_1
	SYSC_LVDLVLR_LVD2LVL_001 = 0x1
	// Vdet2_2
	SYSC_LVDLVLR_LVD2LVL_010 = 0x2
	// Vdet2_3
	SYSC_LVDLVLR_LVD2LVL_011 = 0x3

	// LVD1CR0: Voltage Monitor 1 Circuit Control Register 0
	// Position of RIE field.
	SYSC_LVD1CR0_RIE_Pos = 0x0
	// Bit mask of RIE field.
	SYSC_LVD1CR0_RIE_Msk = 0x1
	// Bit RIE.
	SYSC_LVD1CR0_RIE = 0x1
	// Disable
	SYSC_LVD1CR0_RIE_0 = 0x0
	// Enable
	SYSC_LVD1CR0_RIE_1 = 0x1
	// Position of CMPE field.
	SYSC_LVD1CR0_CMPE_Pos = 0x2
	// Bit mask of CMPE field.
	SYSC_LVD1CR0_CMPE_Msk = 0x4
	// Bit CMPE.
	SYSC_LVD1CR0_CMPE = 0x4
	// Disable voltage monitor 1 circuit comparison result output
	SYSC_LVD1CR0_CMPE_0 = 0x0
	// Enable voltage monitor 1 circuit comparison result output
	SYSC_LVD1CR0_CMPE_1 = 0x1
	// Position of RI field.
	SYSC_LVD1CR0_RI_Pos = 0x6
	// Bit mask of RI field.
	SYSC_LVD1CR0_RI_Msk = 0x40
	// Bit RI.
	SYSC_LVD1CR0_RI = 0x40
	// Generate voltage monitor 1 interrupt on Vdet1 crossing
	SYSC_LVD1CR0_RI_0 = 0x0
	// Enable voltage monitor 1 reset when the voltage falls to and below Vdet1
	SYSC_LVD1CR0_RI_1 = 0x1
	// Position of RN field.
	SYSC_LVD1CR0_RN_Pos = 0x7
	// Bit mask of RN field.
	SYSC_LVD1CR0_RN_Msk = 0x80
	// Bit RN.
	SYSC_LVD1CR0_RN = 0x80
	// Negate after a stabilization time (tLVD1) when VCC > Vdet1 is detected
	SYSC_LVD1CR0_RN_0 = 0x0
	// Negate after a stabilization time (tLVD1) on assertion of the LVD1 reset
	SYSC_LVD1CR0_RN_1 = 0x1

	// LVD2CR0: Voltage Monitor 2 Circuit Control Register 0
	// Position of RIE field.
	SYSC_LVD2CR0_RIE_Pos = 0x0
	// Bit mask of RIE field.
	SYSC_LVD2CR0_RIE_Msk = 0x1
	// Bit RIE.
	SYSC_LVD2CR0_RIE = 0x1
	// Disable
	SYSC_LVD2CR0_RIE_0 = 0x0
	// Enable
	SYSC_LVD2CR0_RIE_1 = 0x1
	// Position of CMPE field.
	SYSC_LVD2CR0_CMPE_Pos = 0x2
	// Bit mask of CMPE field.
	SYSC_LVD2CR0_CMPE_Msk = 0x4
	// Bit CMPE.
	SYSC_LVD2CR0_CMPE = 0x4
	// Disable voltage monitor 2 circuit comparison result output
	SYSC_LVD2CR0_CMPE_0 = 0x0
	// Enable voltage monitor 2 circuit comparison result output
	SYSC_LVD2CR0_CMPE_1 = 0x1
	// Position of RI field.
	SYSC_LVD2CR0_RI_Pos = 0x6
	// Bit mask of RI field.
	SYSC_LVD2CR0_RI_Msk = 0x40
	// Bit RI.
	SYSC_LVD2CR0_RI = 0x40
	// Generate voltage monitor 2 interrupt on Vdet2 crossing
	SYSC_LVD2CR0_RI_0 = 0x0
	// Enable voltage monitor 2 reset when the voltage falls to and below Vdet2
	SYSC_LVD2CR0_RI_1 = 0x1
	// Position of RN field.
	SYSC_LVD2CR0_RN_Pos = 0x7
	// Bit mask of RN field.
	SYSC_LVD2CR0_RN_Msk = 0x80
	// Bit RN.
	SYSC_LVD2CR0_RN = 0x80
	// Negate after a stabilization time (tLVD2) when VCC > Vdet2 is detected
	SYSC_LVD2CR0_RN_0 = 0x0
	// Negate after a stabilization time (tLVD2) on assertion of the LVD2 reset
	SYSC_LVD2CR0_RN_1 = 0x1

	// DCDCCTL: DCDC/LDO Control Register
	// Position of DCDCON field.
	SYSC_DCDCCTL_DCDCON_Pos = 0x0
	// Bit mask of DCDCON field.
	SYSC_DCDCCTL_DCDCON_Msk = 0x1
	// Bit DCDCON.
	SYSC_DCDCCTL_DCDCON = 0x1
	// LDO is on and DCDC is off
	SYSC_DCDCCTL_DCDCON_0 = 0x0
	// LDO is off and DCDC is on
	SYSC_DCDCCTL_DCDCON_1 = 0x1
	// Position of OCPEN field.
	SYSC_DCDCCTL_OCPEN_Pos = 0x1
	// Bit mask of OCPEN field.
	SYSC_DCDCCTL_OCPEN_Msk = 0x2
	// Bit OCPEN.
	SYSC_DCDCCTL_OCPEN = 0x2
	// DCDC OCP (Over Current Protection) Function disable
	SYSC_DCDCCTL_OCPEN_0 = 0x0
	// DCDC OCP (Over Current Protection) Function enable
	SYSC_DCDCCTL_OCPEN_1 = 0x1
	// Position of STOPZA field.
	SYSC_DCDCCTL_STOPZA_Pos = 0x4
	// Bit mask of STOPZA field.
	SYSC_DCDCCTL_STOPZA_Msk = 0x10
	// Bit STOPZA.
	SYSC_DCDCCTL_STOPZA = 0x10
	// DCDC IO buffer power down
	SYSC_DCDCCTL_STOPZA_0 = 0x0
	// DCDC IO buffer power up
	SYSC_DCDCCTL_STOPZA_1 = 0x1
	// Position of LCBOOST field.
	SYSC_DCDCCTL_LCBOOST_Pos = 0x5
	// Bit mask of LCBOOST field.
	SYSC_DCDCCTL_LCBOOST_Msk = 0x20
	// Bit LCBOOST.
	SYSC_DCDCCTL_LCBOOST = 0x20
	// LDO power mode is other than LCBOOST
	SYSC_DCDCCTL_LCBOOST_0 = 0x0
	// LDO power mode is in LCBOOST
	SYSC_DCDCCTL_LCBOOST_1 = 0x1
	// Position of FST field.
	SYSC_DCDCCTL_FST_Pos = 0x6
	// Bit mask of FST field.
	SYSC_DCDCCTL_FST_Msk = 0x40
	// Bit FST.
	SYSC_DCDCCTL_FST = 0x40
	// Fast startupBecause it is a circuit-oriented expression, it is hard to understand. Reexamination of expression is necessary.
	SYSC_DCDCCTL_FST_0 = 0x0
	// Not fast startupBecause it is a circuit-oriented expression, it is hard to understand. Reexamination of expression is necessary.
	SYSC_DCDCCTL_FST_1 = 0x1
	// Position of PD field.
	SYSC_DCDCCTL_PD_Pos = 0x7
	// Bit mask of PD field.
	SYSC_DCDCCTL_PD_Msk = 0x80
	// Bit PD.
	SYSC_DCDCCTL_PD = 0x80
	// DCDC VREF BIAS output enable
	SYSC_DCDCCTL_PD_0 = 0x0
	// DCDC VREF BIAS output disable
	SYSC_DCDCCTL_PD_1 = 0x1

	// VCCSEL: Voltage Level Selection Control Register
	// Position of VCCSEL field.
	SYSC_VCCSEL_VCCSEL_Pos = 0x0
	// Bit mask of VCCSEL field.
	SYSC_VCCSEL_VCCSEL_Msk = 0x3
	// 2.7 V =< VCC < 3.6 V
	SYSC_VCCSEL_VCCSEL_00 = 0x0
	// 3.6 V =< VCC < 4.5 V
	SYSC_VCCSEL_VCCSEL_01 = 0x1
	// 4.5 V =< VCC ≤ 5.5 V
	SYSC_VCCSEL_VCCSEL_10 = 0x2
	// 2.4 V =< VCC < 2.7 V
	SYSC_VCCSEL_VCCSEL_11 = 0x3

	// SOSCCR: Sub-Clock Oscillator Control Register
	// Position of SOSTP field.
	SYSC_SOSCCR_SOSTP_Pos = 0x0
	// Bit mask of SOSTP field.
	SYSC_SOSCCR_SOSTP_Msk = 0x1
	// Bit SOSTP.
	SYSC_SOSCCR_SOSTP = 0x1
	// Operate the sub-clock oscillator
	SYSC_SOSCCR_SOSTP_0 = 0x0
	// Stop the sub-clock oscillator
	SYSC_SOSCCR_SOSTP_1 = 0x1

	// SOMCR: Sub-Clock Oscillator Mode Control Register
	// Position of SODRV field.
	SYSC_SOMCR_SODRV_Pos = 0x0
	// Bit mask of SODRV field.
	SYSC_SOMCR_SODRV_Msk = 0x3
	// Normal Mode
	SYSC_SOMCR_SODRV_00 = 0x0
	// Low Power Mode 1
	SYSC_SOMCR_SODRV_01 = 0x1
	// Low Power Mode 2
	SYSC_SOMCR_SODRV_10 = 0x2
	// Low Power Mode 3
	SYSC_SOMCR_SODRV_11 = 0x3

	// SOMRG: Sub-Clock Oscillator Margin Check Register
	// Position of SOSCMRG field.
	SYSC_SOMRG_SOSCMRG_Pos = 0x0
	// Bit mask of SOSCMRG field.
	SYSC_SOMRG_SOSCMRG_Msk = 0x3
	// Normal Current
	SYSC_SOMRG_SOSCMRG_00 = 0x0
	// Lower Margin check
	SYSC_SOMRG_SOSCMRG_01 = 0x1
	// Upper Margin check
	SYSC_SOMRG_SOSCMRG_10 = 0x2
	// Setting prohibited
	SYSC_SOMRG_SOSCMRG_11 = 0x3

	// LOCOCR: Low-Speed On-Chip Oscillator Control Register
	// Position of LCSTP field.
	SYSC_LOCOCR_LCSTP_Pos = 0x0
	// Bit mask of LCSTP field.
	SYSC_LOCOCR_LCSTP_Msk = 0x1
	// Bit LCSTP.
	SYSC_LOCOCR_LCSTP = 0x1
	// Operate the LOCO clock
	SYSC_LOCOCR_LCSTP_0 = 0x0
	// Stop the LOCO clock
	SYSC_LOCOCR_LCSTP_1 = 0x1

	// LOCOUTCR: LOCO User Trimming Control Register
	// Position of LOCOUTRM field.
	SYSC_LOCOUTCR_LOCOUTRM_Pos = 0x0
	// Bit mask of LOCOUTRM field.
	SYSC_LOCOUTCR_LOCOUTRM_Msk = 0xff
)

// Constants for PORT0: Port 0 Control Registers
const (
	// PCNTR1: Port Control Register 1
	// Position of PDR00 field.
	PORT0_PCNTR1_PDR00_Pos = 0x0
	// Bit mask of PDR00 field.
	PORT0_PCNTR1_PDR00_Msk = 0x1
	// Bit PDR00.
	PORT0_PCNTR1_PDR00 = 0x1
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR00_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR00_1 = 0x1
	// Position of PDR01 field.
	PORT0_PCNTR1_PDR01_Pos = 0x1
	// Bit mask of PDR01 field.
	PORT0_PCNTR1_PDR01_Msk = 0x2
	// Bit PDR01.
	PORT0_PCNTR1_PDR01 = 0x2
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR01_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR01_1 = 0x1
	// Position of PDR02 field.
	PORT0_PCNTR1_PDR02_Pos = 0x2
	// Bit mask of PDR02 field.
	PORT0_PCNTR1_PDR02_Msk = 0x4
	// Bit PDR02.
	PORT0_PCNTR1_PDR02 = 0x4
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR02_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR02_1 = 0x1
	// Position of PDR03 field.
	PORT0_PCNTR1_PDR03_Pos = 0x3
	// Bit mask of PDR03 field.
	PORT0_PCNTR1_PDR03_Msk = 0x8
	// Bit PDR03.
	PORT0_PCNTR1_PDR03 = 0x8
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR03_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR03_1 = 0x1
	// Position of PDR04 field.
	PORT0_PCNTR1_PDR04_Pos = 0x4
	// Bit mask of PDR04 field.
	PORT0_PCNTR1_PDR04_Msk = 0x10
	// Bit PDR04.
	PORT0_PCNTR1_PDR04 = 0x10
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR04_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR04_1 = 0x1
	// Position of PDR05 field.
	PORT0_PCNTR1_PDR05_Pos = 0x5
	// Bit mask of PDR05 field.
	PORT0_PCNTR1_PDR05_Msk = 0x20
	// Bit PDR05.
	PORT0_PCNTR1_PDR05 = 0x20
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR05_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR05_1 = 0x1
	// Position of PDR06 field.
	PORT0_PCNTR1_PDR06_Pos = 0x6
	// Bit mask of PDR06 field.
	PORT0_PCNTR1_PDR06_Msk = 0x40
	// Bit PDR06.
	PORT0_PCNTR1_PDR06 = 0x40
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR06_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR06_1 = 0x1
	// Position of PDR07 field.
	PORT0_PCNTR1_PDR07_Pos = 0x7
	// Bit mask of PDR07 field.
	PORT0_PCNTR1_PDR07_Msk = 0x80
	// Bit PDR07.
	PORT0_PCNTR1_PDR07 = 0x80
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR07_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR07_1 = 0x1
	// Position of PDR08 field.
	PORT0_PCNTR1_PDR08_Pos = 0x8
	// Bit mask of PDR08 field.
	PORT0_PCNTR1_PDR08_Msk = 0x100
	// Bit PDR08.
	PORT0_PCNTR1_PDR08 = 0x100
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR08_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR08_1 = 0x1
	// Position of PDR09 field.
	PORT0_PCNTR1_PDR09_Pos = 0x9
	// Bit mask of PDR09 field.
	PORT0_PCNTR1_PDR09_Msk = 0x200
	// Bit PDR09.
	PORT0_PCNTR1_PDR09 = 0x200
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR09_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR09_1 = 0x1
	// Position of PDR10 field.
	PORT0_PCNTR1_PDR10_Pos = 0xa
	// Bit mask of PDR10 field.
	PORT0_PCNTR1_PDR10_Msk = 0x400
	// Bit PDR10.
	PORT0_PCNTR1_PDR10 = 0x400
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR10_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR10_1 = 0x1
	// Position of PDR11 field.
	PORT0_PCNTR1_PDR11_Pos = 0xb
	// Bit mask of PDR11 field.
	PORT0_PCNTR1_PDR11_Msk = 0x800
	// Bit PDR11.
	PORT0_PCNTR1_PDR11 = 0x800
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR11_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR11_1 = 0x1
	// Position of PDR12 field.
	PORT0_PCNTR1_PDR12_Pos = 0xc
	// Bit mask of PDR12 field.
	PORT0_PCNTR1_PDR12_Msk = 0x1000
	// Bit PDR12.
	PORT0_PCNTR1_PDR12 = 0x1000
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR12_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR12_1 = 0x1
	// Position of PDR13 field.
	PORT0_PCNTR1_PDR13_Pos = 0xd
	// Bit mask of PDR13 field.
	PORT0_PCNTR1_PDR13_Msk = 0x2000
	// Bit PDR13.
	PORT0_PCNTR1_PDR13 = 0x2000
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR13_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR13_1 = 0x1
	// Position of PDR14 field.
	PORT0_PCNTR1_PDR14_Pos = 0xe
	// Bit mask of PDR14 field.
	PORT0_PCNTR1_PDR14_Msk = 0x4000
	// Bit PDR14.
	PORT0_PCNTR1_PDR14 = 0x4000
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR14_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR14_1 = 0x1
	// Position of PDR15 field.
	PORT0_PCNTR1_PDR15_Pos = 0xf
	// Bit mask of PDR15 field.
	PORT0_PCNTR1_PDR15_Msk = 0x8000
	// Bit PDR15.
	PORT0_PCNTR1_PDR15 = 0x8000
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR15_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR15_1 = 0x1
	// Position of PODR00 field.
	PORT0_PCNTR1_PODR00_Pos = 0x10
	// Bit mask of PODR00 field.
	PORT0_PCNTR1_PODR00_Msk = 0x10000
	// Bit PODR00.
	PORT0_PCNTR1_PODR00 = 0x10000
	// Low output
	PORT0_PCNTR1_PODR00_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR00_1 = 0x1
	// Position of PODR01 field.
	PORT0_PCNTR1_PODR01_Pos = 0x11
	// Bit mask of PODR01 field.
	PORT0_PCNTR1_PODR01_Msk = 0x20000
	// Bit PODR01.
	PORT0_PCNTR1_PODR01 = 0x20000
	// Low output
	PORT0_PCNTR1_PODR01_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR01_1 = 0x1
	// Position of PODR02 field.
	PORT0_PCNTR1_PODR02_Pos = 0x12
	// Bit mask of PODR02 field.
	PORT0_PCNTR1_PODR02_Msk = 0x40000
	// Bit PODR02.
	PORT0_PCNTR1_PODR02 = 0x40000
	// Low output
	PORT0_PCNTR1_PODR02_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR02_1 = 0x1
	// Position of PODR03 field.
	PORT0_PCNTR1_PODR03_Pos = 0x13
	// Bit mask of PODR03 field.
	PORT0_PCNTR1_PODR03_Msk = 0x80000
	// Bit PODR03.
	PORT0_PCNTR1_PODR03 = 0x80000
	// Low output
	PORT0_PCNTR1_PODR03_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR03_1 = 0x1
	// Position of PODR04 field.
	PORT0_PCNTR1_PODR04_Pos = 0x14
	// Bit mask of PODR04 field.
	PORT0_PCNTR1_PODR04_Msk = 0x100000
	// Bit PODR04.
	PORT0_PCNTR1_PODR04 = 0x100000
	// Low output
	PORT0_PCNTR1_PODR04_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR04_1 = 0x1
	// Position of PODR05 field.
	PORT0_PCNTR1_PODR05_Pos = 0x15
	// Bit mask of PODR05 field.
	PORT0_PCNTR1_PODR05_Msk = 0x200000
	// Bit PODR05.
	PORT0_PCNTR1_PODR05 = 0x200000
	// Low output
	PORT0_PCNTR1_PODR05_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR05_1 = 0x1
	// Position of PODR06 field.
	PORT0_PCNTR1_PODR06_Pos = 0x16
	// Bit mask of PODR06 field.
	PORT0_PCNTR1_PODR06_Msk = 0x400000
	// Bit PODR06.
	PORT0_PCNTR1_PODR06 = 0x400000
	// Low output
	PORT0_PCNTR1_PODR06_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR06_1 = 0x1
	// Position of PODR07 field.
	PORT0_PCNTR1_PODR07_Pos = 0x17
	// Bit mask of PODR07 field.
	PORT0_PCNTR1_PODR07_Msk = 0x800000
	// Bit PODR07.
	PORT0_PCNTR1_PODR07 = 0x800000
	// Low output
	PORT0_PCNTR1_PODR07_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR07_1 = 0x1
	// Position of PODR08 field.
	PORT0_PCNTR1_PODR08_Pos = 0x18
	// Bit mask of PODR08 field.
	PORT0_PCNTR1_PODR08_Msk = 0x1000000
	// Bit PODR08.
	PORT0_PCNTR1_PODR08 = 0x1000000
	// Low output
	PORT0_PCNTR1_PODR08_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR08_1 = 0x1
	// Position of PODR09 field.
	PORT0_PCNTR1_PODR09_Pos = 0x19
	// Bit mask of PODR09 field.
	PORT0_PCNTR1_PODR09_Msk = 0x2000000
	// Bit PODR09.
	PORT0_PCNTR1_PODR09 = 0x2000000
	// Low output
	PORT0_PCNTR1_PODR09_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR09_1 = 0x1
	// Position of PODR10 field.
	PORT0_PCNTR1_PODR10_Pos = 0x1a
	// Bit mask of PODR10 field.
	PORT0_PCNTR1_PODR10_Msk = 0x4000000
	// Bit PODR10.
	PORT0_PCNTR1_PODR10 = 0x4000000
	// Low output
	PORT0_PCNTR1_PODR10_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR10_1 = 0x1
	// Position of PODR11 field.
	PORT0_PCNTR1_PODR11_Pos = 0x1b
	// Bit mask of PODR11 field.
	PORT0_PCNTR1_PODR11_Msk = 0x8000000
	// Bit PODR11.
	PORT0_PCNTR1_PODR11 = 0x8000000
	// Low output
	PORT0_PCNTR1_PODR11_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR11_1 = 0x1
	// Position of PODR12 field.
	PORT0_PCNTR1_PODR12_Pos = 0x1c
	// Bit mask of PODR12 field.
	PORT0_PCNTR1_PODR12_Msk = 0x10000000
	// Bit PODR12.
	PORT0_PCNTR1_PODR12 = 0x10000000
	// Low output
	PORT0_PCNTR1_PODR12_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR12_1 = 0x1
	// Position of PODR13 field.
	PORT0_PCNTR1_PODR13_Pos = 0x1d
	// Bit mask of PODR13 field.
	PORT0_PCNTR1_PODR13_Msk = 0x20000000
	// Bit PODR13.
	PORT0_PCNTR1_PODR13 = 0x20000000
	// Low output
	PORT0_PCNTR1_PODR13_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR13_1 = 0x1
	// Position of PODR14 field.
	PORT0_PCNTR1_PODR14_Pos = 0x1e
	// Bit mask of PODR14 field.
	PORT0_PCNTR1_PODR14_Msk = 0x40000000
	// Bit PODR14.
	PORT0_PCNTR1_PODR14 = 0x40000000
	// Low output
	PORT0_PCNTR1_PODR14_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR14_1 = 0x1
	// Position of PODR15 field.
	PORT0_PCNTR1_PODR15_Pos = 0x1f
	// Bit mask of PODR15 field.
	PORT0_PCNTR1_PODR15_Msk = 0x80000000
	// Bit PODR15.
	PORT0_PCNTR1_PODR15 = 0x80000000
	// Low output
	PORT0_PCNTR1_PODR15_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR15_1 = 0x1

	// PODR: Port Control Register 1
	// Position of PODR00 field.
	PORT0_PODR_PODR00_Pos = 0x0
	// Bit mask of PODR00 field.
	PORT0_PODR_PODR00_Msk = 0x1
	// Bit PODR00.
	PORT0_PODR_PODR00 = 0x1
	// Low output
	PORT0_PODR_PODR00_0 = 0x0
	// High output
	PORT0_PODR_PODR00_1 = 0x1
	// Position of PODR01 field.
	PORT0_PODR_PODR01_Pos = 0x1
	// Bit mask of PODR01 field.
	PORT0_PODR_PODR01_Msk = 0x2
	// Bit PODR01.
	PORT0_PODR_PODR01 = 0x2
	// Low output
	PORT0_PODR_PODR01_0 = 0x0
	// High output
	PORT0_PODR_PODR01_1 = 0x1
	// Position of PODR02 field.
	PORT0_PODR_PODR02_Pos = 0x2
	// Bit mask of PODR02 field.
	PORT0_PODR_PODR02_Msk = 0x4
	// Bit PODR02.
	PORT0_PODR_PODR02 = 0x4
	// Low output
	PORT0_PODR_PODR02_0 = 0x0
	// High output
	PORT0_PODR_PODR02_1 = 0x1
	// Position of PODR03 field.
	PORT0_PODR_PODR03_Pos = 0x3
	// Bit mask of PODR03 field.
	PORT0_PODR_PODR03_Msk = 0x8
	// Bit PODR03.
	PORT0_PODR_PODR03 = 0x8
	// Low output
	PORT0_PODR_PODR03_0 = 0x0
	// High output
	PORT0_PODR_PODR03_1 = 0x1
	// Position of PODR04 field.
	PORT0_PODR_PODR04_Pos = 0x4
	// Bit mask of PODR04 field.
	PORT0_PODR_PODR04_Msk = 0x10
	// Bit PODR04.
	PORT0_PODR_PODR04 = 0x10
	// Low output
	PORT0_PODR_PODR04_0 = 0x0
	// High output
	PORT0_PODR_PODR04_1 = 0x1
	// Position of PODR05 field.
	PORT0_PODR_PODR05_Pos = 0x5
	// Bit mask of PODR05 field.
	PORT0_PODR_PODR05_Msk = 0x20
	// Bit PODR05.
	PORT0_PODR_PODR05 = 0x20
	// Low output
	PORT0_PODR_PODR05_0 = 0x0
	// High output
	PORT0_PODR_PODR05_1 = 0x1
	// Position of PODR06 field.
	PORT0_PODR_PODR06_Pos = 0x6
	// Bit mask of PODR06 field.
	PORT0_PODR_PODR06_Msk = 0x40
	// Bit PODR06.
	PORT0_PODR_PODR06 = 0x40
	// Low output
	PORT0_PODR_PODR06_0 = 0x0
	// High output
	PORT0_PODR_PODR06_1 = 0x1
	// Position of PODR07 field.
	PORT0_PODR_PODR07_Pos = 0x7
	// Bit mask of PODR07 field.
	PORT0_PODR_PODR07_Msk = 0x80
	// Bit PODR07.
	PORT0_PODR_PODR07 = 0x80
	// Low output
	PORT0_PODR_PODR07_0 = 0x0
	// High output
	PORT0_PODR_PODR07_1 = 0x1
	// Position of PODR08 field.
	PORT0_PODR_PODR08_Pos = 0x8
	// Bit mask of PODR08 field.
	PORT0_PODR_PODR08_Msk = 0x100
	// Bit PODR08.
	PORT0_PODR_PODR08 = 0x100
	// Low output
	PORT0_PODR_PODR08_0 = 0x0
	// High output
	PORT0_PODR_PODR08_1 = 0x1
	// Position of PODR09 field.
	PORT0_PODR_PODR09_Pos = 0x9
	// Bit mask of PODR09 field.
	PORT0_PODR_PODR09_Msk = 0x200
	// Bit PODR09.
	PORT0_PODR_PODR09 = 0x200
	// Low output
	PORT0_PODR_PODR09_0 = 0x0
	// High output
	PORT0_PODR_PODR09_1 = 0x1
	// Position of PODR10 field.
	PORT0_PODR_PODR10_Pos = 0xa
	// Bit mask of PODR10 field.
	PORT0_PODR_PODR10_Msk = 0x400
	// Bit PODR10.
	PORT0_PODR_PODR10 = 0x400
	// Low output
	PORT0_PODR_PODR10_0 = 0x0
	// High output
	PORT0_PODR_PODR10_1 = 0x1
	// Position of PODR11 field.
	PORT0_PODR_PODR11_Pos = 0xb
	// Bit mask of PODR11 field.
	PORT0_PODR_PODR11_Msk = 0x800
	// Bit PODR11.
	PORT0_PODR_PODR11 = 0x800
	// Low output
	PORT0_PODR_PODR11_0 = 0x0
	// High output
	PORT0_PODR_PODR11_1 = 0x1
	// Position of PODR12 field.
	PORT0_PODR_PODR12_Pos = 0xc
	// Bit mask of PODR12 field.
	PORT0_PODR_PODR12_Msk = 0x1000
	// Bit PODR12.
	PORT0_PODR_PODR12 = 0x1000
	// Low output
	PORT0_PODR_PODR12_0 = 0x0
	// High output
	PORT0_PODR_PODR12_1 = 0x1
	// Position of PODR13 field.
	PORT0_PODR_PODR13_Pos = 0xd
	// Bit mask of PODR13 field.
	PORT0_PODR_PODR13_Msk = 0x2000
	// Bit PODR13.
	PORT0_PODR_PODR13 = 0x2000
	// Low output
	PORT0_PODR_PODR13_0 = 0x0
	// High output
	PORT0_PODR_PODR13_1 = 0x1
	// Position of PODR14 field.
	PORT0_PODR_PODR14_Pos = 0xe
	// Bit mask of PODR14 field.
	PORT0_PODR_PODR14_Msk = 0x4000
	// Bit PODR14.
	PORT0_PODR_PODR14 = 0x4000
	// Low output
	PORT0_PODR_PODR14_0 = 0x0
	// High output
	PORT0_PODR_PODR14_1 = 0x1
	// Position of PODR15 field.
	PORT0_PODR_PODR15_Pos = 0xf
	// Bit mask of PODR15 field.
	PORT0_PODR_PODR15_Msk = 0x8000
	// Bit PODR15.
	PORT0_PODR_PODR15 = 0x8000
	// Low output
	PORT0_PODR_PODR15_0 = 0x0
	// High output
	PORT0_PODR_PODR15_1 = 0x1

	// PDR: Port Control Register 1
	// Position of PDR00 field.
	PORT0_PDR_PDR00_Pos = 0x0
	// Bit mask of PDR00 field.
	PORT0_PDR_PDR00_Msk = 0x1
	// Bit PDR00.
	PORT0_PDR_PDR00 = 0x1
	// Input (functions as an input pin)
	PORT0_PDR_PDR00_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR00_1 = 0x1
	// Position of PDR01 field.
	PORT0_PDR_PDR01_Pos = 0x1
	// Bit mask of PDR01 field.
	PORT0_PDR_PDR01_Msk = 0x2
	// Bit PDR01.
	PORT0_PDR_PDR01 = 0x2
	// Input (functions as an input pin)
	PORT0_PDR_PDR01_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR01_1 = 0x1
	// Position of PDR02 field.
	PORT0_PDR_PDR02_Pos = 0x2
	// Bit mask of PDR02 field.
	PORT0_PDR_PDR02_Msk = 0x4
	// Bit PDR02.
	PORT0_PDR_PDR02 = 0x4
	// Input (functions as an input pin)
	PORT0_PDR_PDR02_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR02_1 = 0x1
	// Position of PDR03 field.
	PORT0_PDR_PDR03_Pos = 0x3
	// Bit mask of PDR03 field.
	PORT0_PDR_PDR03_Msk = 0x8
	// Bit PDR03.
	PORT0_PDR_PDR03 = 0x8
	// Input (functions as an input pin)
	PORT0_PDR_PDR03_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR03_1 = 0x1
	// Position of PDR04 field.
	PORT0_PDR_PDR04_Pos = 0x4
	// Bit mask of PDR04 field.
	PORT0_PDR_PDR04_Msk = 0x10
	// Bit PDR04.
	PORT0_PDR_PDR04 = 0x10
	// Input (functions as an input pin)
	PORT0_PDR_PDR04_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR04_1 = 0x1
	// Position of PDR05 field.
	PORT0_PDR_PDR05_Pos = 0x5
	// Bit mask of PDR05 field.
	PORT0_PDR_PDR05_Msk = 0x20
	// Bit PDR05.
	PORT0_PDR_PDR05 = 0x20
	// Input (functions as an input pin)
	PORT0_PDR_PDR05_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR05_1 = 0x1
	// Position of PDR06 field.
	PORT0_PDR_PDR06_Pos = 0x6
	// Bit mask of PDR06 field.
	PORT0_PDR_PDR06_Msk = 0x40
	// Bit PDR06.
	PORT0_PDR_PDR06 = 0x40
	// Input (functions as an input pin)
	PORT0_PDR_PDR06_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR06_1 = 0x1
	// Position of PDR07 field.
	PORT0_PDR_PDR07_Pos = 0x7
	// Bit mask of PDR07 field.
	PORT0_PDR_PDR07_Msk = 0x80
	// Bit PDR07.
	PORT0_PDR_PDR07 = 0x80
	// Input (functions as an input pin)
	PORT0_PDR_PDR07_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR07_1 = 0x1
	// Position of PDR08 field.
	PORT0_PDR_PDR08_Pos = 0x8
	// Bit mask of PDR08 field.
	PORT0_PDR_PDR08_Msk = 0x100
	// Bit PDR08.
	PORT0_PDR_PDR08 = 0x100
	// Input (functions as an input pin)
	PORT0_PDR_PDR08_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR08_1 = 0x1
	// Position of PDR09 field.
	PORT0_PDR_PDR09_Pos = 0x9
	// Bit mask of PDR09 field.
	PORT0_PDR_PDR09_Msk = 0x200
	// Bit PDR09.
	PORT0_PDR_PDR09 = 0x200
	// Input (functions as an input pin)
	PORT0_PDR_PDR09_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR09_1 = 0x1
	// Position of PDR10 field.
	PORT0_PDR_PDR10_Pos = 0xa
	// Bit mask of PDR10 field.
	PORT0_PDR_PDR10_Msk = 0x400
	// Bit PDR10.
	PORT0_PDR_PDR10 = 0x400
	// Input (functions as an input pin)
	PORT0_PDR_PDR10_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR10_1 = 0x1
	// Position of PDR11 field.
	PORT0_PDR_PDR11_Pos = 0xb
	// Bit mask of PDR11 field.
	PORT0_PDR_PDR11_Msk = 0x800
	// Bit PDR11.
	PORT0_PDR_PDR11 = 0x800
	// Input (functions as an input pin)
	PORT0_PDR_PDR11_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR11_1 = 0x1
	// Position of PDR12 field.
	PORT0_PDR_PDR12_Pos = 0xc
	// Bit mask of PDR12 field.
	PORT0_PDR_PDR12_Msk = 0x1000
	// Bit PDR12.
	PORT0_PDR_PDR12 = 0x1000
	// Input (functions as an input pin)
	PORT0_PDR_PDR12_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR12_1 = 0x1
	// Position of PDR13 field.
	PORT0_PDR_PDR13_Pos = 0xd
	// Bit mask of PDR13 field.
	PORT0_PDR_PDR13_Msk = 0x2000
	// Bit PDR13.
	PORT0_PDR_PDR13 = 0x2000
	// Input (functions as an input pin)
	PORT0_PDR_PDR13_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR13_1 = 0x1
	// Position of PDR14 field.
	PORT0_PDR_PDR14_Pos = 0xe
	// Bit mask of PDR14 field.
	PORT0_PDR_PDR14_Msk = 0x4000
	// Bit PDR14.
	PORT0_PDR_PDR14 = 0x4000
	// Input (functions as an input pin)
	PORT0_PDR_PDR14_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR14_1 = 0x1
	// Position of PDR15 field.
	PORT0_PDR_PDR15_Pos = 0xf
	// Bit mask of PDR15 field.
	PORT0_PDR_PDR15_Msk = 0x8000
	// Bit PDR15.
	PORT0_PDR_PDR15 = 0x8000
	// Input (functions as an input pin)
	PORT0_PDR_PDR15_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR15_1 = 0x1

	// PCNTR2: Port Control Register 2
	// Position of PIDR00 field.
	PORT0_PCNTR2_PIDR00_Pos = 0x0
	// Bit mask of PIDR00 field.
	PORT0_PCNTR2_PIDR00_Msk = 0x1
	// Bit PIDR00.
	PORT0_PCNTR2_PIDR00 = 0x1
	// Low level
	PORT0_PCNTR2_PIDR00_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR00_1 = 0x1
	// Position of PIDR01 field.
	PORT0_PCNTR2_PIDR01_Pos = 0x1
	// Bit mask of PIDR01 field.
	PORT0_PCNTR2_PIDR01_Msk = 0x2
	// Bit PIDR01.
	PORT0_PCNTR2_PIDR01 = 0x2
	// Low level
	PORT0_PCNTR2_PIDR01_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR01_1 = 0x1
	// Position of PIDR02 field.
	PORT0_PCNTR2_PIDR02_Pos = 0x2
	// Bit mask of PIDR02 field.
	PORT0_PCNTR2_PIDR02_Msk = 0x4
	// Bit PIDR02.
	PORT0_PCNTR2_PIDR02 = 0x4
	// Low level
	PORT0_PCNTR2_PIDR02_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR02_1 = 0x1
	// Position of PIDR03 field.
	PORT0_PCNTR2_PIDR03_Pos = 0x3
	// Bit mask of PIDR03 field.
	PORT0_PCNTR2_PIDR03_Msk = 0x8
	// Bit PIDR03.
	PORT0_PCNTR2_PIDR03 = 0x8
	// Low level
	PORT0_PCNTR2_PIDR03_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR03_1 = 0x1
	// Position of PIDR04 field.
	PORT0_PCNTR2_PIDR04_Pos = 0x4
	// Bit mask of PIDR04 field.
	PORT0_PCNTR2_PIDR04_Msk = 0x10
	// Bit PIDR04.
	PORT0_PCNTR2_PIDR04 = 0x10
	// Low level
	PORT0_PCNTR2_PIDR04_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR04_1 = 0x1
	// Position of PIDR05 field.
	PORT0_PCNTR2_PIDR05_Pos = 0x5
	// Bit mask of PIDR05 field.
	PORT0_PCNTR2_PIDR05_Msk = 0x20
	// Bit PIDR05.
	PORT0_PCNTR2_PIDR05 = 0x20
	// Low level
	PORT0_PCNTR2_PIDR05_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR05_1 = 0x1
	// Position of PIDR06 field.
	PORT0_PCNTR2_PIDR06_Pos = 0x6
	// Bit mask of PIDR06 field.
	PORT0_PCNTR2_PIDR06_Msk = 0x40
	// Bit PIDR06.
	PORT0_PCNTR2_PIDR06 = 0x40
	// Low level
	PORT0_PCNTR2_PIDR06_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR06_1 = 0x1
	// Position of PIDR07 field.
	PORT0_PCNTR2_PIDR07_Pos = 0x7
	// Bit mask of PIDR07 field.
	PORT0_PCNTR2_PIDR07_Msk = 0x80
	// Bit PIDR07.
	PORT0_PCNTR2_PIDR07 = 0x80
	// Low level
	PORT0_PCNTR2_PIDR07_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR07_1 = 0x1
	// Position of PIDR08 field.
	PORT0_PCNTR2_PIDR08_Pos = 0x8
	// Bit mask of PIDR08 field.
	PORT0_PCNTR2_PIDR08_Msk = 0x100
	// Bit PIDR08.
	PORT0_PCNTR2_PIDR08 = 0x100
	// Low level
	PORT0_PCNTR2_PIDR08_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR08_1 = 0x1
	// Position of PIDR09 field.
	PORT0_PCNTR2_PIDR09_Pos = 0x9
	// Bit mask of PIDR09 field.
	PORT0_PCNTR2_PIDR09_Msk = 0x200
	// Bit PIDR09.
	PORT0_PCNTR2_PIDR09 = 0x200
	// Low level
	PORT0_PCNTR2_PIDR09_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR09_1 = 0x1
	// Position of PIDR10 field.
	PORT0_PCNTR2_PIDR10_Pos = 0xa
	// Bit mask of PIDR10 field.
	PORT0_PCNTR2_PIDR10_Msk = 0x400
	// Bit PIDR10.
	PORT0_PCNTR2_PIDR10 = 0x400
	// Low level
	PORT0_PCNTR2_PIDR10_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR10_1 = 0x1
	// Position of PIDR11 field.
	PORT0_PCNTR2_PIDR11_Pos = 0xb
	// Bit mask of PIDR11 field.
	PORT0_PCNTR2_PIDR11_Msk = 0x800
	// Bit PIDR11.
	PORT0_PCNTR2_PIDR11 = 0x800
	// Low level
	PORT0_PCNTR2_PIDR11_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR11_1 = 0x1
	// Position of PIDR12 field.
	PORT0_PCNTR2_PIDR12_Pos = 0xc
	// Bit mask of PIDR12 field.
	PORT0_PCNTR2_PIDR12_Msk = 0x1000
	// Bit PIDR12.
	PORT0_PCNTR2_PIDR12 = 0x1000
	// Low level
	PORT0_PCNTR2_PIDR12_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR12_1 = 0x1
	// Position of PIDR13 field.
	PORT0_PCNTR2_PIDR13_Pos = 0xd
	// Bit mask of PIDR13 field.
	PORT0_PCNTR2_PIDR13_Msk = 0x2000
	// Bit PIDR13.
	PORT0_PCNTR2_PIDR13 = 0x2000
	// Low level
	PORT0_PCNTR2_PIDR13_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR13_1 = 0x1
	// Position of PIDR14 field.
	PORT0_PCNTR2_PIDR14_Pos = 0xe
	// Bit mask of PIDR14 field.
	PORT0_PCNTR2_PIDR14_Msk = 0x4000
	// Bit PIDR14.
	PORT0_PCNTR2_PIDR14 = 0x4000
	// Low level
	PORT0_PCNTR2_PIDR14_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR14_1 = 0x1
	// Position of PIDR15 field.
	PORT0_PCNTR2_PIDR15_Pos = 0xf
	// Bit mask of PIDR15 field.
	PORT0_PCNTR2_PIDR15_Msk = 0x8000
	// Bit PIDR15.
	PORT0_PCNTR2_PIDR15 = 0x8000
	// Low level
	PORT0_PCNTR2_PIDR15_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR15_1 = 0x1

	// PIDR: Port Control Register 2
	// Position of PIDR00 field.
	PORT0_PIDR_PIDR00_Pos = 0x0
	// Bit mask of PIDR00 field.
	PORT0_PIDR_PIDR00_Msk = 0x1
	// Bit PIDR00.
	PORT0_PIDR_PIDR00 = 0x1
	// Low level
	PORT0_PIDR_PIDR00_0 = 0x0
	// High level
	PORT0_PIDR_PIDR00_1 = 0x1
	// Position of PIDR01 field.
	PORT0_PIDR_PIDR01_Pos = 0x1
	// Bit mask of PIDR01 field.
	PORT0_PIDR_PIDR01_Msk = 0x2
	// Bit PIDR01.
	PORT0_PIDR_PIDR01 = 0x2
	// Low level
	PORT0_PIDR_PIDR01_0 = 0x0
	// High level
	PORT0_PIDR_PIDR01_1 = 0x1
	// Position of PIDR02 field.
	PORT0_PIDR_PIDR02_Pos = 0x2
	// Bit mask of PIDR02 field.
	PORT0_PIDR_PIDR02_Msk = 0x4
	// Bit PIDR02.
	PORT0_PIDR_PIDR02 = 0x4
	// Low level
	PORT0_PIDR_PIDR02_0 = 0x0
	// High level
	PORT0_PIDR_PIDR02_1 = 0x1
	// Position of PIDR03 field.
	PORT0_PIDR_PIDR03_Pos = 0x3
	// Bit mask of PIDR03 field.
	PORT0_PIDR_PIDR03_Msk = 0x8
	// Bit PIDR03.
	PORT0_PIDR_PIDR03 = 0x8
	// Low level
	PORT0_PIDR_PIDR03_0 = 0x0
	// High level
	PORT0_PIDR_PIDR03_1 = 0x1
	// Position of PIDR04 field.
	PORT0_PIDR_PIDR04_Pos = 0x4
	// Bit mask of PIDR04 field.
	PORT0_PIDR_PIDR04_Msk = 0x10
	// Bit PIDR04.
	PORT0_PIDR_PIDR04 = 0x10
	// Low level
	PORT0_PIDR_PIDR04_0 = 0x0
	// High level
	PORT0_PIDR_PIDR04_1 = 0x1
	// Position of PIDR05 field.
	PORT0_PIDR_PIDR05_Pos = 0x5
	// Bit mask of PIDR05 field.
	PORT0_PIDR_PIDR05_Msk = 0x20
	// Bit PIDR05.
	PORT0_PIDR_PIDR05 = 0x20
	// Low level
	PORT0_PIDR_PIDR05_0 = 0x0
	// High level
	PORT0_PIDR_PIDR05_1 = 0x1
	// Position of PIDR06 field.
	PORT0_PIDR_PIDR06_Pos = 0x6
	// Bit mask of PIDR06 field.
	PORT0_PIDR_PIDR06_Msk = 0x40
	// Bit PIDR06.
	PORT0_PIDR_PIDR06 = 0x40
	// Low level
	PORT0_PIDR_PIDR06_0 = 0x0
	// High level
	PORT0_PIDR_PIDR06_1 = 0x1
	// Position of PIDR07 field.
	PORT0_PIDR_PIDR07_Pos = 0x7
	// Bit mask of PIDR07 field.
	PORT0_PIDR_PIDR07_Msk = 0x80
	// Bit PIDR07.
	PORT0_PIDR_PIDR07 = 0x80
	// Low level
	PORT0_PIDR_PIDR07_0 = 0x0
	// High level
	PORT0_PIDR_PIDR07_1 = 0x1
	// Position of PIDR08 field.
	PORT0_PIDR_PIDR08_Pos = 0x8
	// Bit mask of PIDR08 field.
	PORT0_PIDR_PIDR08_Msk = 0x100
	// Bit PIDR08.
	PORT0_PIDR_PIDR08 = 0x100
	// Low level
	PORT0_PIDR_PIDR08_0 = 0x0
	// High level
	PORT0_PIDR_PIDR08_1 = 0x1
	// Position of PIDR09 field.
	PORT0_PIDR_PIDR09_Pos = 0x9
	// Bit mask of PIDR09 field.
	PORT0_PIDR_PIDR09_Msk = 0x200
	// Bit PIDR09.
	PORT0_PIDR_PIDR09 = 0x200
	// Low level
	PORT0_PIDR_PIDR09_0 = 0x0
	// High level
	PORT0_PIDR_PIDR09_1 = 0x1
	// Position of PIDR10 field.
	PORT0_PIDR_PIDR10_Pos = 0xa
	// Bit mask of PIDR10 field.
	PORT0_PIDR_PIDR10_Msk = 0x400
	// Bit PIDR10.
	PORT0_PIDR_PIDR10 = 0x400
	// Low level
	PORT0_PIDR_PIDR10_0 = 0x0
	// High level
	PORT0_PIDR_PIDR10_1 = 0x1
	// Position of PIDR11 field.
	PORT0_PIDR_PIDR11_Pos = 0xb
	// Bit mask of PIDR11 field.
	PORT0_PIDR_PIDR11_Msk = 0x800
	// Bit PIDR11.
	PORT0_PIDR_PIDR11 = 0x800
	// Low level
	PORT0_PIDR_PIDR11_0 = 0x0
	// High level
	PORT0_PIDR_PIDR11_1 = 0x1
	// Position of PIDR12 field.
	PORT0_PIDR_PIDR12_Pos = 0xc
	// Bit mask of PIDR12 field.
	PORT0_PIDR_PIDR12_Msk = 0x1000
	// Bit PIDR12.
	PORT0_PIDR_PIDR12 = 0x1000
	// Low level
	PORT0_PIDR_PIDR12_0 = 0x0
	// High level
	PORT0_PIDR_PIDR12_1 = 0x1
	// Position of PIDR13 field.
	PORT0_PIDR_PIDR13_Pos = 0xd
	// Bit mask of PIDR13 field.
	PORT0_PIDR_PIDR13_Msk = 0x2000
	// Bit PIDR13.
	PORT0_PIDR_PIDR13 = 0x2000
	// Low level
	PORT0_PIDR_PIDR13_0 = 0x0
	// High level
	PORT0_PIDR_PIDR13_1 = 0x1
	// Position of PIDR14 field.
	PORT0_PIDR_PIDR14_Pos = 0xe
	// Bit mask of PIDR14 field.
	PORT0_PIDR_PIDR14_Msk = 0x4000
	// Bit PIDR14.
	PORT0_PIDR_PIDR14 = 0x4000
	// Low level
	PORT0_PIDR_PIDR14_0 = 0x0
	// High level
	PORT0_PIDR_PIDR14_1 = 0x1
	// Position of PIDR15 field.
	PORT0_PIDR_PIDR15_Pos = 0xf
	// Bit mask of PIDR15 field.
	PORT0_PIDR_PIDR15_Msk = 0x8000
	// Bit PIDR15.
	PORT0_PIDR_PIDR15 = 0x8000
	// Low level
	PORT0_PIDR_PIDR15_0 = 0x0
	// High level
	PORT0_PIDR_PIDR15_1 = 0x1

	// PCNTR3: Port Control Register 3
	// Position of POSR00 field.
	PORT0_PCNTR3_POSR00_Pos = 0x0
	// Bit mask of POSR00 field.
	PORT0_PCNTR3_POSR00_Msk = 0x1
	// Bit POSR00.
	PORT0_PCNTR3_POSR00 = 0x1
	// No effect on output
	PORT0_PCNTR3_POSR00_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR00_1 = 0x1
	// Position of POSR01 field.
	PORT0_PCNTR3_POSR01_Pos = 0x1
	// Bit mask of POSR01 field.
	PORT0_PCNTR3_POSR01_Msk = 0x2
	// Bit POSR01.
	PORT0_PCNTR3_POSR01 = 0x2
	// No effect on output
	PORT0_PCNTR3_POSR01_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR01_1 = 0x1
	// Position of POSR02 field.
	PORT0_PCNTR3_POSR02_Pos = 0x2
	// Bit mask of POSR02 field.
	PORT0_PCNTR3_POSR02_Msk = 0x4
	// Bit POSR02.
	PORT0_PCNTR3_POSR02 = 0x4
	// No effect on output
	PORT0_PCNTR3_POSR02_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR02_1 = 0x1
	// Position of POSR03 field.
	PORT0_PCNTR3_POSR03_Pos = 0x3
	// Bit mask of POSR03 field.
	PORT0_PCNTR3_POSR03_Msk = 0x8
	// Bit POSR03.
	PORT0_PCNTR3_POSR03 = 0x8
	// No effect on output
	PORT0_PCNTR3_POSR03_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR03_1 = 0x1
	// Position of POSR04 field.
	PORT0_PCNTR3_POSR04_Pos = 0x4
	// Bit mask of POSR04 field.
	PORT0_PCNTR3_POSR04_Msk = 0x10
	// Bit POSR04.
	PORT0_PCNTR3_POSR04 = 0x10
	// No effect on output
	PORT0_PCNTR3_POSR04_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR04_1 = 0x1
	// Position of POSR05 field.
	PORT0_PCNTR3_POSR05_Pos = 0x5
	// Bit mask of POSR05 field.
	PORT0_PCNTR3_POSR05_Msk = 0x20
	// Bit POSR05.
	PORT0_PCNTR3_POSR05 = 0x20
	// No effect on output
	PORT0_PCNTR3_POSR05_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR05_1 = 0x1
	// Position of POSR06 field.
	PORT0_PCNTR3_POSR06_Pos = 0x6
	// Bit mask of POSR06 field.
	PORT0_PCNTR3_POSR06_Msk = 0x40
	// Bit POSR06.
	PORT0_PCNTR3_POSR06 = 0x40
	// No effect on output
	PORT0_PCNTR3_POSR06_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR06_1 = 0x1
	// Position of POSR07 field.
	PORT0_PCNTR3_POSR07_Pos = 0x7
	// Bit mask of POSR07 field.
	PORT0_PCNTR3_POSR07_Msk = 0x80
	// Bit POSR07.
	PORT0_PCNTR3_POSR07 = 0x80
	// No effect on output
	PORT0_PCNTR3_POSR07_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR07_1 = 0x1
	// Position of POSR08 field.
	PORT0_PCNTR3_POSR08_Pos = 0x8
	// Bit mask of POSR08 field.
	PORT0_PCNTR3_POSR08_Msk = 0x100
	// Bit POSR08.
	PORT0_PCNTR3_POSR08 = 0x100
	// No effect on output
	PORT0_PCNTR3_POSR08_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR08_1 = 0x1
	// Position of POSR09 field.
	PORT0_PCNTR3_POSR09_Pos = 0x9
	// Bit mask of POSR09 field.
	PORT0_PCNTR3_POSR09_Msk = 0x200
	// Bit POSR09.
	PORT0_PCNTR3_POSR09 = 0x200
	// No effect on output
	PORT0_PCNTR3_POSR09_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR09_1 = 0x1
	// Position of POSR10 field.
	PORT0_PCNTR3_POSR10_Pos = 0xa
	// Bit mask of POSR10 field.
	PORT0_PCNTR3_POSR10_Msk = 0x400
	// Bit POSR10.
	PORT0_PCNTR3_POSR10 = 0x400
	// No effect on output
	PORT0_PCNTR3_POSR10_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR10_1 = 0x1
	// Position of POSR11 field.
	PORT0_PCNTR3_POSR11_Pos = 0xb
	// Bit mask of POSR11 field.
	PORT0_PCNTR3_POSR11_Msk = 0x800
	// Bit POSR11.
	PORT0_PCNTR3_POSR11 = 0x800
	// No effect on output
	PORT0_PCNTR3_POSR11_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR11_1 = 0x1
	// Position of POSR12 field.
	PORT0_PCNTR3_POSR12_Pos = 0xc
	// Bit mask of POSR12 field.
	PORT0_PCNTR3_POSR12_Msk = 0x1000
	// Bit POSR12.
	PORT0_PCNTR3_POSR12 = 0x1000
	// No effect on output
	PORT0_PCNTR3_POSR12_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR12_1 = 0x1
	// Position of POSR13 field.
	PORT0_PCNTR3_POSR13_Pos = 0xd
	// Bit mask of POSR13 field.
	PORT0_PCNTR3_POSR13_Msk = 0x2000
	// Bit POSR13.
	PORT0_PCNTR3_POSR13 = 0x2000
	// No effect on output
	PORT0_PCNTR3_POSR13_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR13_1 = 0x1
	// Position of POSR14 field.
	PORT0_PCNTR3_POSR14_Pos = 0xe
	// Bit mask of POSR14 field.
	PORT0_PCNTR3_POSR14_Msk = 0x4000
	// Bit POSR14.
	PORT0_PCNTR3_POSR14 = 0x4000
	// No effect on output
	PORT0_PCNTR3_POSR14_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR14_1 = 0x1
	// Position of POSR15 field.
	PORT0_PCNTR3_POSR15_Pos = 0xf
	// Bit mask of POSR15 field.
	PORT0_PCNTR3_POSR15_Msk = 0x8000
	// Bit POSR15.
	PORT0_PCNTR3_POSR15 = 0x8000
	// No effect on output
	PORT0_PCNTR3_POSR15_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR15_1 = 0x1
	// Position of PORR00 field.
	PORT0_PCNTR3_PORR00_Pos = 0x10
	// Bit mask of PORR00 field.
	PORT0_PCNTR3_PORR00_Msk = 0x10000
	// Bit PORR00.
	PORT0_PCNTR3_PORR00 = 0x10000
	// No effect on output
	PORT0_PCNTR3_PORR00_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR00_1 = 0x1
	// Position of PORR01 field.
	PORT0_PCNTR3_PORR01_Pos = 0x11
	// Bit mask of PORR01 field.
	PORT0_PCNTR3_PORR01_Msk = 0x20000
	// Bit PORR01.
	PORT0_PCNTR3_PORR01 = 0x20000
	// No effect on output
	PORT0_PCNTR3_PORR01_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR01_1 = 0x1
	// Position of PORR02 field.
	PORT0_PCNTR3_PORR02_Pos = 0x12
	// Bit mask of PORR02 field.
	PORT0_PCNTR3_PORR02_Msk = 0x40000
	// Bit PORR02.
	PORT0_PCNTR3_PORR02 = 0x40000
	// No effect on output
	PORT0_PCNTR3_PORR02_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR02_1 = 0x1
	// Position of PORR03 field.
	PORT0_PCNTR3_PORR03_Pos = 0x13
	// Bit mask of PORR03 field.
	PORT0_PCNTR3_PORR03_Msk = 0x80000
	// Bit PORR03.
	PORT0_PCNTR3_PORR03 = 0x80000
	// No effect on output
	PORT0_PCNTR3_PORR03_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR03_1 = 0x1
	// Position of PORR04 field.
	PORT0_PCNTR3_PORR04_Pos = 0x14
	// Bit mask of PORR04 field.
	PORT0_PCNTR3_PORR04_Msk = 0x100000
	// Bit PORR04.
	PORT0_PCNTR3_PORR04 = 0x100000
	// No effect on output
	PORT0_PCNTR3_PORR04_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR04_1 = 0x1
	// Position of PORR05 field.
	PORT0_PCNTR3_PORR05_Pos = 0x15
	// Bit mask of PORR05 field.
	PORT0_PCNTR3_PORR05_Msk = 0x200000
	// Bit PORR05.
	PORT0_PCNTR3_PORR05 = 0x200000
	// No effect on output
	PORT0_PCNTR3_PORR05_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR05_1 = 0x1
	// Position of PORR06 field.
	PORT0_PCNTR3_PORR06_Pos = 0x16
	// Bit mask of PORR06 field.
	PORT0_PCNTR3_PORR06_Msk = 0x400000
	// Bit PORR06.
	PORT0_PCNTR3_PORR06 = 0x400000
	// No effect on output
	PORT0_PCNTR3_PORR06_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR06_1 = 0x1
	// Position of PORR07 field.
	PORT0_PCNTR3_PORR07_Pos = 0x17
	// Bit mask of PORR07 field.
	PORT0_PCNTR3_PORR07_Msk = 0x800000
	// Bit PORR07.
	PORT0_PCNTR3_PORR07 = 0x800000
	// No effect on output
	PORT0_PCNTR3_PORR07_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR07_1 = 0x1
	// Position of PORR08 field.
	PORT0_PCNTR3_PORR08_Pos = 0x18
	// Bit mask of PORR08 field.
	PORT0_PCNTR3_PORR08_Msk = 0x1000000
	// Bit PORR08.
	PORT0_PCNTR3_PORR08 = 0x1000000
	// No effect on output
	PORT0_PCNTR3_PORR08_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR08_1 = 0x1
	// Position of PORR09 field.
	PORT0_PCNTR3_PORR09_Pos = 0x19
	// Bit mask of PORR09 field.
	PORT0_PCNTR3_PORR09_Msk = 0x2000000
	// Bit PORR09.
	PORT0_PCNTR3_PORR09 = 0x2000000
	// No effect on output
	PORT0_PCNTR3_PORR09_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR09_1 = 0x1
	// Position of PORR10 field.
	PORT0_PCNTR3_PORR10_Pos = 0x1a
	// Bit mask of PORR10 field.
	PORT0_PCNTR3_PORR10_Msk = 0x4000000
	// Bit PORR10.
	PORT0_PCNTR3_PORR10 = 0x4000000
	// No effect on output
	PORT0_PCNTR3_PORR10_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR10_1 = 0x1
	// Position of PORR11 field.
	PORT0_PCNTR3_PORR11_Pos = 0x1b
	// Bit mask of PORR11 field.
	PORT0_PCNTR3_PORR11_Msk = 0x8000000
	// Bit PORR11.
	PORT0_PCNTR3_PORR11 = 0x8000000
	// No effect on output
	PORT0_PCNTR3_PORR11_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR11_1 = 0x1
	// Position of PORR12 field.
	PORT0_PCNTR3_PORR12_Pos = 0x1c
	// Bit mask of PORR12 field.
	PORT0_PCNTR3_PORR12_Msk = 0x10000000
	// Bit PORR12.
	PORT0_PCNTR3_PORR12 = 0x10000000
	// No effect on output
	PORT0_PCNTR3_PORR12_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR12_1 = 0x1
	// Position of PORR13 field.
	PORT0_PCNTR3_PORR13_Pos = 0x1d
	// Bit mask of PORR13 field.
	PORT0_PCNTR3_PORR13_Msk = 0x20000000
	// Bit PORR13.
	PORT0_PCNTR3_PORR13 = 0x20000000
	// No effect on output
	PORT0_PCNTR3_PORR13_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR13_1 = 0x1
	// Position of PORR14 field.
	PORT0_PCNTR3_PORR14_Pos = 0x1e
	// Bit mask of PORR14 field.
	PORT0_PCNTR3_PORR14_Msk = 0x40000000
	// Bit PORR14.
	PORT0_PCNTR3_PORR14 = 0x40000000
	// No effect on output
	PORT0_PCNTR3_PORR14_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR14_1 = 0x1
	// Position of PORR15 field.
	PORT0_PCNTR3_PORR15_Pos = 0x1f
	// Bit mask of PORR15 field.
	PORT0_PCNTR3_PORR15_Msk = 0x80000000
	// Bit PORR15.
	PORT0_PCNTR3_PORR15 = 0x80000000
	// No effect on output
	PORT0_PCNTR3_PORR15_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR15_1 = 0x1

	// PORR: Port Control Register 3
	// Position of PORR00 field.
	PORT0_PORR_PORR00_Pos = 0x0
	// Bit mask of PORR00 field.
	PORT0_PORR_PORR00_Msk = 0x1
	// Bit PORR00.
	PORT0_PORR_PORR00 = 0x1
	// No effect on output
	PORT0_PORR_PORR00_0 = 0x0
	// Low output
	PORT0_PORR_PORR00_1 = 0x1
	// Position of PORR01 field.
	PORT0_PORR_PORR01_Pos = 0x1
	// Bit mask of PORR01 field.
	PORT0_PORR_PORR01_Msk = 0x2
	// Bit PORR01.
	PORT0_PORR_PORR01 = 0x2
	// No effect on output
	PORT0_PORR_PORR01_0 = 0x0
	// Low output
	PORT0_PORR_PORR01_1 = 0x1
	// Position of PORR02 field.
	PORT0_PORR_PORR02_Pos = 0x2
	// Bit mask of PORR02 field.
	PORT0_PORR_PORR02_Msk = 0x4
	// Bit PORR02.
	PORT0_PORR_PORR02 = 0x4
	// No effect on output
	PORT0_PORR_PORR02_0 = 0x0
	// Low output
	PORT0_PORR_PORR02_1 = 0x1
	// Position of PORR03 field.
	PORT0_PORR_PORR03_Pos = 0x3
	// Bit mask of PORR03 field.
	PORT0_PORR_PORR03_Msk = 0x8
	// Bit PORR03.
	PORT0_PORR_PORR03 = 0x8
	// No effect on output
	PORT0_PORR_PORR03_0 = 0x0
	// Low output
	PORT0_PORR_PORR03_1 = 0x1
	// Position of PORR04 field.
	PORT0_PORR_PORR04_Pos = 0x4
	// Bit mask of PORR04 field.
	PORT0_PORR_PORR04_Msk = 0x10
	// Bit PORR04.
	PORT0_PORR_PORR04 = 0x10
	// No effect on output
	PORT0_PORR_PORR04_0 = 0x0
	// Low output
	PORT0_PORR_PORR04_1 = 0x1
	// Position of PORR05 field.
	PORT0_PORR_PORR05_Pos = 0x5
	// Bit mask of PORR05 field.
	PORT0_PORR_PORR05_Msk = 0x20
	// Bit PORR05.
	PORT0_PORR_PORR05 = 0x20
	// No effect on output
	PORT0_PORR_PORR05_0 = 0x0
	// Low output
	PORT0_PORR_PORR05_1 = 0x1
	// Position of PORR06 field.
	PORT0_PORR_PORR06_Pos = 0x6
	// Bit mask of PORR06 field.
	PORT0_PORR_PORR06_Msk = 0x40
	// Bit PORR06.
	PORT0_PORR_PORR06 = 0x40
	// No effect on output
	PORT0_PORR_PORR06_0 = 0x0
	// Low output
	PORT0_PORR_PORR06_1 = 0x1
	// Position of PORR07 field.
	PORT0_PORR_PORR07_Pos = 0x7
	// Bit mask of PORR07 field.
	PORT0_PORR_PORR07_Msk = 0x80
	// Bit PORR07.
	PORT0_PORR_PORR07 = 0x80
	// No effect on output
	PORT0_PORR_PORR07_0 = 0x0
	// Low output
	PORT0_PORR_PORR07_1 = 0x1
	// Position of PORR08 field.
	PORT0_PORR_PORR08_Pos = 0x8
	// Bit mask of PORR08 field.
	PORT0_PORR_PORR08_Msk = 0x100
	// Bit PORR08.
	PORT0_PORR_PORR08 = 0x100
	// No effect on output
	PORT0_PORR_PORR08_0 = 0x0
	// Low output
	PORT0_PORR_PORR08_1 = 0x1
	// Position of PORR09 field.
	PORT0_PORR_PORR09_Pos = 0x9
	// Bit mask of PORR09 field.
	PORT0_PORR_PORR09_Msk = 0x200
	// Bit PORR09.
	PORT0_PORR_PORR09 = 0x200
	// No effect on output
	PORT0_PORR_PORR09_0 = 0x0
	// Low output
	PORT0_PORR_PORR09_1 = 0x1
	// Position of PORR10 field.
	PORT0_PORR_PORR10_Pos = 0xa
	// Bit mask of PORR10 field.
	PORT0_PORR_PORR10_Msk = 0x400
	// Bit PORR10.
	PORT0_PORR_PORR10 = 0x400
	// No effect on output
	PORT0_PORR_PORR10_0 = 0x0
	// Low output
	PORT0_PORR_PORR10_1 = 0x1
	// Position of PORR11 field.
	PORT0_PORR_PORR11_Pos = 0xb
	// Bit mask of PORR11 field.
	PORT0_PORR_PORR11_Msk = 0x800
	// Bit PORR11.
	PORT0_PORR_PORR11 = 0x800
	// No effect on output
	PORT0_PORR_PORR11_0 = 0x0
	// Low output
	PORT0_PORR_PORR11_1 = 0x1
	// Position of PORR12 field.
	PORT0_PORR_PORR12_Pos = 0xc
	// Bit mask of PORR12 field.
	PORT0_PORR_PORR12_Msk = 0x1000
	// Bit PORR12.
	PORT0_PORR_PORR12 = 0x1000
	// No effect on output
	PORT0_PORR_PORR12_0 = 0x0
	// Low output
	PORT0_PORR_PORR12_1 = 0x1
	// Position of PORR13 field.
	PORT0_PORR_PORR13_Pos = 0xd
	// Bit mask of PORR13 field.
	PORT0_PORR_PORR13_Msk = 0x2000
	// Bit PORR13.
	PORT0_PORR_PORR13 = 0x2000
	// No effect on output
	PORT0_PORR_PORR13_0 = 0x0
	// Low output
	PORT0_PORR_PORR13_1 = 0x1
	// Position of PORR14 field.
	PORT0_PORR_PORR14_Pos = 0xe
	// Bit mask of PORR14 field.
	PORT0_PORR_PORR14_Msk = 0x4000
	// Bit PORR14.
	PORT0_PORR_PORR14 = 0x4000
	// No effect on output
	PORT0_PORR_PORR14_0 = 0x0
	// Low output
	PORT0_PORR_PORR14_1 = 0x1
	// Position of PORR15 field.
	PORT0_PORR_PORR15_Pos = 0xf
	// Bit mask of PORR15 field.
	PORT0_PORR_PORR15_Msk = 0x8000
	// Bit PORR15.
	PORT0_PORR_PORR15 = 0x8000
	// No effect on output
	PORT0_PORR_PORR15_0 = 0x0
	// Low output
	PORT0_PORR_PORR15_1 = 0x1

	// POSR: Port Control Register 3
	// Position of POSR00 field.
	PORT0_POSR_POSR00_Pos = 0x0
	// Bit mask of POSR00 field.
	PORT0_POSR_POSR00_Msk = 0x1
	// Bit POSR00.
	PORT0_POSR_POSR00 = 0x1
	// No effect on output
	PORT0_POSR_POSR00_0 = 0x0
	// High output
	PORT0_POSR_POSR00_1 = 0x1
	// Position of POSR01 field.
	PORT0_POSR_POSR01_Pos = 0x1
	// Bit mask of POSR01 field.
	PORT0_POSR_POSR01_Msk = 0x2
	// Bit POSR01.
	PORT0_POSR_POSR01 = 0x2
	// No effect on output
	PORT0_POSR_POSR01_0 = 0x0
	// High output
	PORT0_POSR_POSR01_1 = 0x1
	// Position of POSR02 field.
	PORT0_POSR_POSR02_Pos = 0x2
	// Bit mask of POSR02 field.
	PORT0_POSR_POSR02_Msk = 0x4
	// Bit POSR02.
	PORT0_POSR_POSR02 = 0x4
	// No effect on output
	PORT0_POSR_POSR02_0 = 0x0
	// High output
	PORT0_POSR_POSR02_1 = 0x1
	// Position of POSR03 field.
	PORT0_POSR_POSR03_Pos = 0x3
	// Bit mask of POSR03 field.
	PORT0_POSR_POSR03_Msk = 0x8
	// Bit POSR03.
	PORT0_POSR_POSR03 = 0x8
	// No effect on output
	PORT0_POSR_POSR03_0 = 0x0
	// High output
	PORT0_POSR_POSR03_1 = 0x1
	// Position of POSR04 field.
	PORT0_POSR_POSR04_Pos = 0x4
	// Bit mask of POSR04 field.
	PORT0_POSR_POSR04_Msk = 0x10
	// Bit POSR04.
	PORT0_POSR_POSR04 = 0x10
	// No effect on output
	PORT0_POSR_POSR04_0 = 0x0
	// High output
	PORT0_POSR_POSR04_1 = 0x1
	// Position of POSR05 field.
	PORT0_POSR_POSR05_Pos = 0x5
	// Bit mask of POSR05 field.
	PORT0_POSR_POSR05_Msk = 0x20
	// Bit POSR05.
	PORT0_POSR_POSR05 = 0x20
	// No effect on output
	PORT0_POSR_POSR05_0 = 0x0
	// High output
	PORT0_POSR_POSR05_1 = 0x1
	// Position of POSR06 field.
	PORT0_POSR_POSR06_Pos = 0x6
	// Bit mask of POSR06 field.
	PORT0_POSR_POSR06_Msk = 0x40
	// Bit POSR06.
	PORT0_POSR_POSR06 = 0x40
	// No effect on output
	PORT0_POSR_POSR06_0 = 0x0
	// High output
	PORT0_POSR_POSR06_1 = 0x1
	// Position of POSR07 field.
	PORT0_POSR_POSR07_Pos = 0x7
	// Bit mask of POSR07 field.
	PORT0_POSR_POSR07_Msk = 0x80
	// Bit POSR07.
	PORT0_POSR_POSR07 = 0x80
	// No effect on output
	PORT0_POSR_POSR07_0 = 0x0
	// High output
	PORT0_POSR_POSR07_1 = 0x1
	// Position of POSR08 field.
	PORT0_POSR_POSR08_Pos = 0x8
	// Bit mask of POSR08 field.
	PORT0_POSR_POSR08_Msk = 0x100
	// Bit POSR08.
	PORT0_POSR_POSR08 = 0x100
	// No effect on output
	PORT0_POSR_POSR08_0 = 0x0
	// High output
	PORT0_POSR_POSR08_1 = 0x1
	// Position of POSR09 field.
	PORT0_POSR_POSR09_Pos = 0x9
	// Bit mask of POSR09 field.
	PORT0_POSR_POSR09_Msk = 0x200
	// Bit POSR09.
	PORT0_POSR_POSR09 = 0x200
	// No effect on output
	PORT0_POSR_POSR09_0 = 0x0
	// High output
	PORT0_POSR_POSR09_1 = 0x1
	// Position of POSR10 field.
	PORT0_POSR_POSR10_Pos = 0xa
	// Bit mask of POSR10 field.
	PORT0_POSR_POSR10_Msk = 0x400
	// Bit POSR10.
	PORT0_POSR_POSR10 = 0x400
	// No effect on output
	PORT0_POSR_POSR10_0 = 0x0
	// High output
	PORT0_POSR_POSR10_1 = 0x1
	// Position of POSR11 field.
	PORT0_POSR_POSR11_Pos = 0xb
	// Bit mask of POSR11 field.
	PORT0_POSR_POSR11_Msk = 0x800
	// Bit POSR11.
	PORT0_POSR_POSR11 = 0x800
	// No effect on output
	PORT0_POSR_POSR11_0 = 0x0
	// High output
	PORT0_POSR_POSR11_1 = 0x1
	// Position of POSR12 field.
	PORT0_POSR_POSR12_Pos = 0xc
	// Bit mask of POSR12 field.
	PORT0_POSR_POSR12_Msk = 0x1000
	// Bit POSR12.
	PORT0_POSR_POSR12 = 0x1000
	// No effect on output
	PORT0_POSR_POSR12_0 = 0x0
	// High output
	PORT0_POSR_POSR12_1 = 0x1
	// Position of POSR13 field.
	PORT0_POSR_POSR13_Pos = 0xd
	// Bit mask of POSR13 field.
	PORT0_POSR_POSR13_Msk = 0x2000
	// Bit POSR13.
	PORT0_POSR_POSR13 = 0x2000
	// No effect on output
	PORT0_POSR_POSR13_0 = 0x0
	// High output
	PORT0_POSR_POSR13_1 = 0x1
	// Position of POSR14 field.
	PORT0_POSR_POSR14_Pos = 0xe
	// Bit mask of POSR14 field.
	PORT0_POSR_POSR14_Msk = 0x4000
	// Bit POSR14.
	PORT0_POSR_POSR14 = 0x4000
	// No effect on output
	PORT0_POSR_POSR14_0 = 0x0
	// High output
	PORT0_POSR_POSR14_1 = 0x1
	// Position of POSR15 field.
	PORT0_POSR_POSR15_Pos = 0xf
	// Bit mask of POSR15 field.
	PORT0_POSR_POSR15_Msk = 0x8000
	// Bit POSR15.
	PORT0_POSR_POSR15 = 0x8000
	// No effect on output
	PORT0_POSR_POSR15_0 = 0x0
	// High output
	PORT0_POSR_POSR15_1 = 0x1
)

// Constants for PORT1: Port 1 Control Registers
const (
	// PCNTR1: Port Control Register 1
	// Position of PDR00 field.
	PORT1_PCNTR1_PDR00_Pos = 0x0
	// Bit mask of PDR00 field.
	PORT1_PCNTR1_PDR00_Msk = 0x1
	// Bit PDR00.
	PORT1_PCNTR1_PDR00 = 0x1
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR00_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR00_1 = 0x1
	// Position of PDR01 field.
	PORT1_PCNTR1_PDR01_Pos = 0x1
	// Bit mask of PDR01 field.
	PORT1_PCNTR1_PDR01_Msk = 0x2
	// Bit PDR01.
	PORT1_PCNTR1_PDR01 = 0x2
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR01_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR01_1 = 0x1
	// Position of PDR02 field.
	PORT1_PCNTR1_PDR02_Pos = 0x2
	// Bit mask of PDR02 field.
	PORT1_PCNTR1_PDR02_Msk = 0x4
	// Bit PDR02.
	PORT1_PCNTR1_PDR02 = 0x4
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR02_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR02_1 = 0x1
	// Position of PDR03 field.
	PORT1_PCNTR1_PDR03_Pos = 0x3
	// Bit mask of PDR03 field.
	PORT1_PCNTR1_PDR03_Msk = 0x8
	// Bit PDR03.
	PORT1_PCNTR1_PDR03 = 0x8
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR03_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR03_1 = 0x1
	// Position of PDR04 field.
	PORT1_PCNTR1_PDR04_Pos = 0x4
	// Bit mask of PDR04 field.
	PORT1_PCNTR1_PDR04_Msk = 0x10
	// Bit PDR04.
	PORT1_PCNTR1_PDR04 = 0x10
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR04_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR04_1 = 0x1
	// Position of PDR05 field.
	PORT1_PCNTR1_PDR05_Pos = 0x5
	// Bit mask of PDR05 field.
	PORT1_PCNTR1_PDR05_Msk = 0x20
	// Bit PDR05.
	PORT1_PCNTR1_PDR05 = 0x20
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR05_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR05_1 = 0x1
	// Position of PDR06 field.
	PORT1_PCNTR1_PDR06_Pos = 0x6
	// Bit mask of PDR06 field.
	PORT1_PCNTR1_PDR06_Msk = 0x40
	// Bit PDR06.
	PORT1_PCNTR1_PDR06 = 0x40
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR06_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR06_1 = 0x1
	// Position of PDR07 field.
	PORT1_PCNTR1_PDR07_Pos = 0x7
	// Bit mask of PDR07 field.
	PORT1_PCNTR1_PDR07_Msk = 0x80
	// Bit PDR07.
	PORT1_PCNTR1_PDR07 = 0x80
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR07_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR07_1 = 0x1
	// Position of PDR08 field.
	PORT1_PCNTR1_PDR08_Pos = 0x8
	// Bit mask of PDR08 field.
	PORT1_PCNTR1_PDR08_Msk = 0x100
	// Bit PDR08.
	PORT1_PCNTR1_PDR08 = 0x100
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR08_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR08_1 = 0x1
	// Position of PDR09 field.
	PORT1_PCNTR1_PDR09_Pos = 0x9
	// Bit mask of PDR09 field.
	PORT1_PCNTR1_PDR09_Msk = 0x200
	// Bit PDR09.
	PORT1_PCNTR1_PDR09 = 0x200
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR09_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR09_1 = 0x1
	// Position of PDR10 field.
	PORT1_PCNTR1_PDR10_Pos = 0xa
	// Bit mask of PDR10 field.
	PORT1_PCNTR1_PDR10_Msk = 0x400
	// Bit PDR10.
	PORT1_PCNTR1_PDR10 = 0x400
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR10_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR10_1 = 0x1
	// Position of PDR11 field.
	PORT1_PCNTR1_PDR11_Pos = 0xb
	// Bit mask of PDR11 field.
	PORT1_PCNTR1_PDR11_Msk = 0x800
	// Bit PDR11.
	PORT1_PCNTR1_PDR11 = 0x800
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR11_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR11_1 = 0x1
	// Position of PDR12 field.
	PORT1_PCNTR1_PDR12_Pos = 0xc
	// Bit mask of PDR12 field.
	PORT1_PCNTR1_PDR12_Msk = 0x1000
	// Bit PDR12.
	PORT1_PCNTR1_PDR12 = 0x1000
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR12_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR12_1 = 0x1
	// Position of PDR13 field.
	PORT1_PCNTR1_PDR13_Pos = 0xd
	// Bit mask of PDR13 field.
	PORT1_PCNTR1_PDR13_Msk = 0x2000
	// Bit PDR13.
	PORT1_PCNTR1_PDR13 = 0x2000
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR13_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR13_1 = 0x1
	// Position of PDR14 field.
	PORT1_PCNTR1_PDR14_Pos = 0xe
	// Bit mask of PDR14 field.
	PORT1_PCNTR1_PDR14_Msk = 0x4000
	// Bit PDR14.
	PORT1_PCNTR1_PDR14 = 0x4000
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR14_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR14_1 = 0x1
	// Position of PDR15 field.
	PORT1_PCNTR1_PDR15_Pos = 0xf
	// Bit mask of PDR15 field.
	PORT1_PCNTR1_PDR15_Msk = 0x8000
	// Bit PDR15.
	PORT1_PCNTR1_PDR15 = 0x8000
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR15_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR15_1 = 0x1
	// Position of PODR00 field.
	PORT1_PCNTR1_PODR00_Pos = 0x10
	// Bit mask of PODR00 field.
	PORT1_PCNTR1_PODR00_Msk = 0x10000
	// Bit PODR00.
	PORT1_PCNTR1_PODR00 = 0x10000
	// Low output
	PORT1_PCNTR1_PODR00_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR00_1 = 0x1
	// Position of PODR01 field.
	PORT1_PCNTR1_PODR01_Pos = 0x11
	// Bit mask of PODR01 field.
	PORT1_PCNTR1_PODR01_Msk = 0x20000
	// Bit PODR01.
	PORT1_PCNTR1_PODR01 = 0x20000
	// Low output
	PORT1_PCNTR1_PODR01_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR01_1 = 0x1
	// Position of PODR02 field.
	PORT1_PCNTR1_PODR02_Pos = 0x12
	// Bit mask of PODR02 field.
	PORT1_PCNTR1_PODR02_Msk = 0x40000
	// Bit PODR02.
	PORT1_PCNTR1_PODR02 = 0x40000
	// Low output
	PORT1_PCNTR1_PODR02_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR02_1 = 0x1
	// Position of PODR03 field.
	PORT1_PCNTR1_PODR03_Pos = 0x13
	// Bit mask of PODR03 field.
	PORT1_PCNTR1_PODR03_Msk = 0x80000
	// Bit PODR03.
	PORT1_PCNTR1_PODR03 = 0x80000
	// Low output
	PORT1_PCNTR1_PODR03_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR03_1 = 0x1
	// Position of PODR04 field.
	PORT1_PCNTR1_PODR04_Pos = 0x14
	// Bit mask of PODR04 field.
	PORT1_PCNTR1_PODR04_Msk = 0x100000
	// Bit PODR04.
	PORT1_PCNTR1_PODR04 = 0x100000
	// Low output
	PORT1_PCNTR1_PODR04_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR04_1 = 0x1
	// Position of PODR05 field.
	PORT1_PCNTR1_PODR05_Pos = 0x15
	// Bit mask of PODR05 field.
	PORT1_PCNTR1_PODR05_Msk = 0x200000
	// Bit PODR05.
	PORT1_PCNTR1_PODR05 = 0x200000
	// Low output
	PORT1_PCNTR1_PODR05_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR05_1 = 0x1
	// Position of PODR06 field.
	PORT1_PCNTR1_PODR06_Pos = 0x16
	// Bit mask of PODR06 field.
	PORT1_PCNTR1_PODR06_Msk = 0x400000
	// Bit PODR06.
	PORT1_PCNTR1_PODR06 = 0x400000
	// Low output
	PORT1_PCNTR1_PODR06_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR06_1 = 0x1
	// Position of PODR07 field.
	PORT1_PCNTR1_PODR07_Pos = 0x17
	// Bit mask of PODR07 field.
	PORT1_PCNTR1_PODR07_Msk = 0x800000
	// Bit PODR07.
	PORT1_PCNTR1_PODR07 = 0x800000
	// Low output
	PORT1_PCNTR1_PODR07_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR07_1 = 0x1
	// Position of PODR08 field.
	PORT1_PCNTR1_PODR08_Pos = 0x18
	// Bit mask of PODR08 field.
	PORT1_PCNTR1_PODR08_Msk = 0x1000000
	// Bit PODR08.
	PORT1_PCNTR1_PODR08 = 0x1000000
	// Low output
	PORT1_PCNTR1_PODR08_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR08_1 = 0x1
	// Position of PODR09 field.
	PORT1_PCNTR1_PODR09_Pos = 0x19
	// Bit mask of PODR09 field.
	PORT1_PCNTR1_PODR09_Msk = 0x2000000
	// Bit PODR09.
	PORT1_PCNTR1_PODR09 = 0x2000000
	// Low output
	PORT1_PCNTR1_PODR09_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR09_1 = 0x1
	// Position of PODR10 field.
	PORT1_PCNTR1_PODR10_Pos = 0x1a
	// Bit mask of PODR10 field.
	PORT1_PCNTR1_PODR10_Msk = 0x4000000
	// Bit PODR10.
	PORT1_PCNTR1_PODR10 = 0x4000000
	// Low output
	PORT1_PCNTR1_PODR10_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR10_1 = 0x1
	// Position of PODR11 field.
	PORT1_PCNTR1_PODR11_Pos = 0x1b
	// Bit mask of PODR11 field.
	PORT1_PCNTR1_PODR11_Msk = 0x8000000
	// Bit PODR11.
	PORT1_PCNTR1_PODR11 = 0x8000000
	// Low output
	PORT1_PCNTR1_PODR11_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR11_1 = 0x1
	// Position of PODR12 field.
	PORT1_PCNTR1_PODR12_Pos = 0x1c
	// Bit mask of PODR12 field.
	PORT1_PCNTR1_PODR12_Msk = 0x10000000
	// Bit PODR12.
	PORT1_PCNTR1_PODR12 = 0x10000000
	// Low output
	PORT1_PCNTR1_PODR12_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR12_1 = 0x1
	// Position of PODR13 field.
	PORT1_PCNTR1_PODR13_Pos = 0x1d
	// Bit mask of PODR13 field.
	PORT1_PCNTR1_PODR13_Msk = 0x20000000
	// Bit PODR13.
	PORT1_PCNTR1_PODR13 = 0x20000000
	// Low output
	PORT1_PCNTR1_PODR13_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR13_1 = 0x1
	// Position of PODR14 field.
	PORT1_PCNTR1_PODR14_Pos = 0x1e
	// Bit mask of PODR14 field.
	PORT1_PCNTR1_PODR14_Msk = 0x40000000
	// Bit PODR14.
	PORT1_PCNTR1_PODR14 = 0x40000000
	// Low output
	PORT1_PCNTR1_PODR14_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR14_1 = 0x1
	// Position of PODR15 field.
	PORT1_PCNTR1_PODR15_Pos = 0x1f
	// Bit mask of PODR15 field.
	PORT1_PCNTR1_PODR15_Msk = 0x80000000
	// Bit PODR15.
	PORT1_PCNTR1_PODR15 = 0x80000000
	// Low output
	PORT1_PCNTR1_PODR15_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR15_1 = 0x1

	// PODR: Port Control Register 1
	// Position of PODR00 field.
	PORT1_PODR_PODR00_Pos = 0x0
	// Bit mask of PODR00 field.
	PORT1_PODR_PODR00_Msk = 0x1
	// Bit PODR00.
	PORT1_PODR_PODR00 = 0x1
	// Low output
	PORT1_PODR_PODR00_0 = 0x0
	// High output
	PORT1_PODR_PODR00_1 = 0x1
	// Position of PODR01 field.
	PORT1_PODR_PODR01_Pos = 0x1
	// Bit mask of PODR01 field.
	PORT1_PODR_PODR01_Msk = 0x2
	// Bit PODR01.
	PORT1_PODR_PODR01 = 0x2
	// Low output
	PORT1_PODR_PODR01_0 = 0x0
	// High output
	PORT1_PODR_PODR01_1 = 0x1
	// Position of PODR02 field.
	PORT1_PODR_PODR02_Pos = 0x2
	// Bit mask of PODR02 field.
	PORT1_PODR_PODR02_Msk = 0x4
	// Bit PODR02.
	PORT1_PODR_PODR02 = 0x4
	// Low output
	PORT1_PODR_PODR02_0 = 0x0
	// High output
	PORT1_PODR_PODR02_1 = 0x1
	// Position of PODR03 field.
	PORT1_PODR_PODR03_Pos = 0x3
	// Bit mask of PODR03 field.
	PORT1_PODR_PODR03_Msk = 0x8
	// Bit PODR03.
	PORT1_PODR_PODR03 = 0x8
	// Low output
	PORT1_PODR_PODR03_0 = 0x0
	// High output
	PORT1_PODR_PODR03_1 = 0x1
	// Position of PODR04 field.
	PORT1_PODR_PODR04_Pos = 0x4
	// Bit mask of PODR04 field.
	PORT1_PODR_PODR04_Msk = 0x10
	// Bit PODR04.
	PORT1_PODR_PODR04 = 0x10
	// Low output
	PORT1_PODR_PODR04_0 = 0x0
	// High output
	PORT1_PODR_PODR04_1 = 0x1
	// Position of PODR05 field.
	PORT1_PODR_PODR05_Pos = 0x5
	// Bit mask of PODR05 field.
	PORT1_PODR_PODR05_Msk = 0x20
	// Bit PODR05.
	PORT1_PODR_PODR05 = 0x20
	// Low output
	PORT1_PODR_PODR05_0 = 0x0
	// High output
	PORT1_PODR_PODR05_1 = 0x1
	// Position of PODR06 field.
	PORT1_PODR_PODR06_Pos = 0x6
	// Bit mask of PODR06 field.
	PORT1_PODR_PODR06_Msk = 0x40
	// Bit PODR06.
	PORT1_PODR_PODR06 = 0x40
	// Low output
	PORT1_PODR_PODR06_0 = 0x0
	// High output
	PORT1_PODR_PODR06_1 = 0x1
	// Position of PODR07 field.
	PORT1_PODR_PODR07_Pos = 0x7
	// Bit mask of PODR07 field.
	PORT1_PODR_PODR07_Msk = 0x80
	// Bit PODR07.
	PORT1_PODR_PODR07 = 0x80
	// Low output
	PORT1_PODR_PODR07_0 = 0x0
	// High output
	PORT1_PODR_PODR07_1 = 0x1
	// Position of PODR08 field.
	PORT1_PODR_PODR08_Pos = 0x8
	// Bit mask of PODR08 field.
	PORT1_PODR_PODR08_Msk = 0x100
	// Bit PODR08.
	PORT1_PODR_PODR08 = 0x100
	// Low output
	PORT1_PODR_PODR08_0 = 0x0
	// High output
	PORT1_PODR_PODR08_1 = 0x1
	// Position of PODR09 field.
	PORT1_PODR_PODR09_Pos = 0x9
	// Bit mask of PODR09 field.
	PORT1_PODR_PODR09_Msk = 0x200
	// Bit PODR09.
	PORT1_PODR_PODR09 = 0x200
	// Low output
	PORT1_PODR_PODR09_0 = 0x0
	// High output
	PORT1_PODR_PODR09_1 = 0x1
	// Position of PODR10 field.
	PORT1_PODR_PODR10_Pos = 0xa
	// Bit mask of PODR10 field.
	PORT1_PODR_PODR10_Msk = 0x400
	// Bit PODR10.
	PORT1_PODR_PODR10 = 0x400
	// Low output
	PORT1_PODR_PODR10_0 = 0x0
	// High output
	PORT1_PODR_PODR10_1 = 0x1
	// Position of PODR11 field.
	PORT1_PODR_PODR11_Pos = 0xb
	// Bit mask of PODR11 field.
	PORT1_PODR_PODR11_Msk = 0x800
	// Bit PODR11.
	PORT1_PODR_PODR11 = 0x800
	// Low output
	PORT1_PODR_PODR11_0 = 0x0
	// High output
	PORT1_PODR_PODR11_1 = 0x1
	// Position of PODR12 field.
	PORT1_PODR_PODR12_Pos = 0xc
	// Bit mask of PODR12 field.
	PORT1_PODR_PODR12_Msk = 0x1000
	// Bit PODR12.
	PORT1_PODR_PODR12 = 0x1000
	// Low output
	PORT1_PODR_PODR12_0 = 0x0
	// High output
	PORT1_PODR_PODR12_1 = 0x1
	// Position of PODR13 field.
	PORT1_PODR_PODR13_Pos = 0xd
	// Bit mask of PODR13 field.
	PORT1_PODR_PODR13_Msk = 0x2000
	// Bit PODR13.
	PORT1_PODR_PODR13 = 0x2000
	// Low output
	PORT1_PODR_PODR13_0 = 0x0
	// High output
	PORT1_PODR_PODR13_1 = 0x1
	// Position of PODR14 field.
	PORT1_PODR_PODR14_Pos = 0xe
	// Bit mask of PODR14 field.
	PORT1_PODR_PODR14_Msk = 0x4000
	// Bit PODR14.
	PORT1_PODR_PODR14 = 0x4000
	// Low output
	PORT1_PODR_PODR14_0 = 0x0
	// High output
	PORT1_PODR_PODR14_1 = 0x1
	// Position of PODR15 field.
	PORT1_PODR_PODR15_Pos = 0xf
	// Bit mask of PODR15 field.
	PORT1_PODR_PODR15_Msk = 0x8000
	// Bit PODR15.
	PORT1_PODR_PODR15 = 0x8000
	// Low output
	PORT1_PODR_PODR15_0 = 0x0
	// High output
	PORT1_PODR_PODR15_1 = 0x1

	// PDR: Port Control Register 1
	// Position of PDR00 field.
	PORT1_PDR_PDR00_Pos = 0x0
	// Bit mask of PDR00 field.
	PORT1_PDR_PDR00_Msk = 0x1
	// Bit PDR00.
	PORT1_PDR_PDR00 = 0x1
	// Input (functions as an input pin)
	PORT1_PDR_PDR00_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR00_1 = 0x1
	// Position of PDR01 field.
	PORT1_PDR_PDR01_Pos = 0x1
	// Bit mask of PDR01 field.
	PORT1_PDR_PDR01_Msk = 0x2
	// Bit PDR01.
	PORT1_PDR_PDR01 = 0x2
	// Input (functions as an input pin)
	PORT1_PDR_PDR01_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR01_1 = 0x1
	// Position of PDR02 field.
	PORT1_PDR_PDR02_Pos = 0x2
	// Bit mask of PDR02 field.
	PORT1_PDR_PDR02_Msk = 0x4
	// Bit PDR02.
	PORT1_PDR_PDR02 = 0x4
	// Input (functions as an input pin)
	PORT1_PDR_PDR02_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR02_1 = 0x1
	// Position of PDR03 field.
	PORT1_PDR_PDR03_Pos = 0x3
	// Bit mask of PDR03 field.
	PORT1_PDR_PDR03_Msk = 0x8
	// Bit PDR03.
	PORT1_PDR_PDR03 = 0x8
	// Input (functions as an input pin)
	PORT1_PDR_PDR03_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR03_1 = 0x1
	// Position of PDR04 field.
	PORT1_PDR_PDR04_Pos = 0x4
	// Bit mask of PDR04 field.
	PORT1_PDR_PDR04_Msk = 0x10
	// Bit PDR04.
	PORT1_PDR_PDR04 = 0x10
	// Input (functions as an input pin)
	PORT1_PDR_PDR04_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR04_1 = 0x1
	// Position of PDR05 field.
	PORT1_PDR_PDR05_Pos = 0x5
	// Bit mask of PDR05 field.
	PORT1_PDR_PDR05_Msk = 0x20
	// Bit PDR05.
	PORT1_PDR_PDR05 = 0x20
	// Input (functions as an input pin)
	PORT1_PDR_PDR05_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR05_1 = 0x1
	// Position of PDR06 field.
	PORT1_PDR_PDR06_Pos = 0x6
	// Bit mask of PDR06 field.
	PORT1_PDR_PDR06_Msk = 0x40
	// Bit PDR06.
	PORT1_PDR_PDR06 = 0x40
	// Input (functions as an input pin)
	PORT1_PDR_PDR06_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR06_1 = 0x1
	// Position of PDR07 field.
	PORT1_PDR_PDR07_Pos = 0x7
	// Bit mask of PDR07 field.
	PORT1_PDR_PDR07_Msk = 0x80
	// Bit PDR07.
	PORT1_PDR_PDR07 = 0x80
	// Input (functions as an input pin)
	PORT1_PDR_PDR07_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR07_1 = 0x1
	// Position of PDR08 field.
	PORT1_PDR_PDR08_Pos = 0x8
	// Bit mask of PDR08 field.
	PORT1_PDR_PDR08_Msk = 0x100
	// Bit PDR08.
	PORT1_PDR_PDR08 = 0x100
	// Input (functions as an input pin)
	PORT1_PDR_PDR08_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR08_1 = 0x1
	// Position of PDR09 field.
	PORT1_PDR_PDR09_Pos = 0x9
	// Bit mask of PDR09 field.
	PORT1_PDR_PDR09_Msk = 0x200
	// Bit PDR09.
	PORT1_PDR_PDR09 = 0x200
	// Input (functions as an input pin)
	PORT1_PDR_PDR09_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR09_1 = 0x1
	// Position of PDR10 field.
	PORT1_PDR_PDR10_Pos = 0xa
	// Bit mask of PDR10 field.
	PORT1_PDR_PDR10_Msk = 0x400
	// Bit PDR10.
	PORT1_PDR_PDR10 = 0x400
	// Input (functions as an input pin)
	PORT1_PDR_PDR10_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR10_1 = 0x1
	// Position of PDR11 field.
	PORT1_PDR_PDR11_Pos = 0xb
	// Bit mask of PDR11 field.
	PORT1_PDR_PDR11_Msk = 0x800
	// Bit PDR11.
	PORT1_PDR_PDR11 = 0x800
	// Input (functions as an input pin)
	PORT1_PDR_PDR11_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR11_1 = 0x1
	// Position of PDR12 field.
	PORT1_PDR_PDR12_Pos = 0xc
	// Bit mask of PDR12 field.
	PORT1_PDR_PDR12_Msk = 0x1000
	// Bit PDR12.
	PORT1_PDR_PDR12 = 0x1000
	// Input (functions as an input pin)
	PORT1_PDR_PDR12_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR12_1 = 0x1
	// Position of PDR13 field.
	PORT1_PDR_PDR13_Pos = 0xd
	// Bit mask of PDR13 field.
	PORT1_PDR_PDR13_Msk = 0x2000
	// Bit PDR13.
	PORT1_PDR_PDR13 = 0x2000
	// Input (functions as an input pin)
	PORT1_PDR_PDR13_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR13_1 = 0x1
	// Position of PDR14 field.
	PORT1_PDR_PDR14_Pos = 0xe
	// Bit mask of PDR14 field.
	PORT1_PDR_PDR14_Msk = 0x4000
	// Bit PDR14.
	PORT1_PDR_PDR14 = 0x4000
	// Input (functions as an input pin)
	PORT1_PDR_PDR14_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR14_1 = 0x1
	// Position of PDR15 field.
	PORT1_PDR_PDR15_Pos = 0xf
	// Bit mask of PDR15 field.
	PORT1_PDR_PDR15_Msk = 0x8000
	// Bit PDR15.
	PORT1_PDR_PDR15 = 0x8000
	// Input (functions as an input pin)
	PORT1_PDR_PDR15_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR15_1 = 0x1

	// PCNTR2: Port Control Register 2
	// Position of PIDR00 field.
	PORT1_PCNTR2_PIDR00_Pos = 0x0
	// Bit mask of PIDR00 field.
	PORT1_PCNTR2_PIDR00_Msk = 0x1
	// Bit PIDR00.
	PORT1_PCNTR2_PIDR00 = 0x1
	// Low level
	PORT1_PCNTR2_PIDR00_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR00_1 = 0x1
	// Position of PIDR01 field.
	PORT1_PCNTR2_PIDR01_Pos = 0x1
	// Bit mask of PIDR01 field.
	PORT1_PCNTR2_PIDR01_Msk = 0x2
	// Bit PIDR01.
	PORT1_PCNTR2_PIDR01 = 0x2
	// Low level
	PORT1_PCNTR2_PIDR01_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR01_1 = 0x1
	// Position of PIDR02 field.
	PORT1_PCNTR2_PIDR02_Pos = 0x2
	// Bit mask of PIDR02 field.
	PORT1_PCNTR2_PIDR02_Msk = 0x4
	// Bit PIDR02.
	PORT1_PCNTR2_PIDR02 = 0x4
	// Low level
	PORT1_PCNTR2_PIDR02_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR02_1 = 0x1
	// Position of PIDR03 field.
	PORT1_PCNTR2_PIDR03_Pos = 0x3
	// Bit mask of PIDR03 field.
	PORT1_PCNTR2_PIDR03_Msk = 0x8
	// Bit PIDR03.
	PORT1_PCNTR2_PIDR03 = 0x8
	// Low level
	PORT1_PCNTR2_PIDR03_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR03_1 = 0x1
	// Position of PIDR04 field.
	PORT1_PCNTR2_PIDR04_Pos = 0x4
	// Bit mask of PIDR04 field.
	PORT1_PCNTR2_PIDR04_Msk = 0x10
	// Bit PIDR04.
	PORT1_PCNTR2_PIDR04 = 0x10
	// Low level
	PORT1_PCNTR2_PIDR04_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR04_1 = 0x1
	// Position of PIDR05 field.
	PORT1_PCNTR2_PIDR05_Pos = 0x5
	// Bit mask of PIDR05 field.
	PORT1_PCNTR2_PIDR05_Msk = 0x20
	// Bit PIDR05.
	PORT1_PCNTR2_PIDR05 = 0x20
	// Low level
	PORT1_PCNTR2_PIDR05_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR05_1 = 0x1
	// Position of PIDR06 field.
	PORT1_PCNTR2_PIDR06_Pos = 0x6
	// Bit mask of PIDR06 field.
	PORT1_PCNTR2_PIDR06_Msk = 0x40
	// Bit PIDR06.
	PORT1_PCNTR2_PIDR06 = 0x40
	// Low level
	PORT1_PCNTR2_PIDR06_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR06_1 = 0x1
	// Position of PIDR07 field.
	PORT1_PCNTR2_PIDR07_Pos = 0x7
	// Bit mask of PIDR07 field.
	PORT1_PCNTR2_PIDR07_Msk = 0x80
	// Bit PIDR07.
	PORT1_PCNTR2_PIDR07 = 0x80
	// Low level
	PORT1_PCNTR2_PIDR07_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR07_1 = 0x1
	// Position of PIDR08 field.
	PORT1_PCNTR2_PIDR08_Pos = 0x8
	// Bit mask of PIDR08 field.
	PORT1_PCNTR2_PIDR08_Msk = 0x100
	// Bit PIDR08.
	PORT1_PCNTR2_PIDR08 = 0x100
	// Low level
	PORT1_PCNTR2_PIDR08_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR08_1 = 0x1
	// Position of PIDR09 field.
	PORT1_PCNTR2_PIDR09_Pos = 0x9
	// Bit mask of PIDR09 field.
	PORT1_PCNTR2_PIDR09_Msk = 0x200
	// Bit PIDR09.
	PORT1_PCNTR2_PIDR09 = 0x200
	// Low level
	PORT1_PCNTR2_PIDR09_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR09_1 = 0x1
	// Position of PIDR10 field.
	PORT1_PCNTR2_PIDR10_Pos = 0xa
	// Bit mask of PIDR10 field.
	PORT1_PCNTR2_PIDR10_Msk = 0x400
	// Bit PIDR10.
	PORT1_PCNTR2_PIDR10 = 0x400
	// Low level
	PORT1_PCNTR2_PIDR10_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR10_1 = 0x1
	// Position of PIDR11 field.
	PORT1_PCNTR2_PIDR11_Pos = 0xb
	// Bit mask of PIDR11 field.
	PORT1_PCNTR2_PIDR11_Msk = 0x800
	// Bit PIDR11.
	PORT1_PCNTR2_PIDR11 = 0x800
	// Low level
	PORT1_PCNTR2_PIDR11_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR11_1 = 0x1
	// Position of PIDR12 field.
	PORT1_PCNTR2_PIDR12_Pos = 0xc
	// Bit mask of PIDR12 field.
	PORT1_PCNTR2_PIDR12_Msk = 0x1000
	// Bit PIDR12.
	PORT1_PCNTR2_PIDR12 = 0x1000
	// Low level
	PORT1_PCNTR2_PIDR12_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR12_1 = 0x1
	// Position of PIDR13 field.
	PORT1_PCNTR2_PIDR13_Pos = 0xd
	// Bit mask of PIDR13 field.
	PORT1_PCNTR2_PIDR13_Msk = 0x2000
	// Bit PIDR13.
	PORT1_PCNTR2_PIDR13 = 0x2000
	// Low level
	PORT1_PCNTR2_PIDR13_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR13_1 = 0x1
	// Position of PIDR14 field.
	PORT1_PCNTR2_PIDR14_Pos = 0xe
	// Bit mask of PIDR14 field.
	PORT1_PCNTR2_PIDR14_Msk = 0x4000
	// Bit PIDR14.
	PORT1_PCNTR2_PIDR14 = 0x4000
	// Low level
	PORT1_PCNTR2_PIDR14_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR14_1 = 0x1
	// Position of PIDR15 field.
	PORT1_PCNTR2_PIDR15_Pos = 0xf
	// Bit mask of PIDR15 field.
	PORT1_PCNTR2_PIDR15_Msk = 0x8000
	// Bit PIDR15.
	PORT1_PCNTR2_PIDR15 = 0x8000
	// Low level
	PORT1_PCNTR2_PIDR15_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR15_1 = 0x1
	// Position of EIDR00 field.
	PORT1_PCNTR2_EIDR00_Pos = 0x10
	// Bit mask of EIDR00 field.
	PORT1_PCNTR2_EIDR00_Msk = 0x10000
	// Bit EIDR00.
	PORT1_PCNTR2_EIDR00 = 0x10000
	// Low input
	PORT1_PCNTR2_EIDR00_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR00_1 = 0x1
	// Position of EIDR01 field.
	PORT1_PCNTR2_EIDR01_Pos = 0x11
	// Bit mask of EIDR01 field.
	PORT1_PCNTR2_EIDR01_Msk = 0x20000
	// Bit EIDR01.
	PORT1_PCNTR2_EIDR01 = 0x20000
	// Low input
	PORT1_PCNTR2_EIDR01_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR01_1 = 0x1
	// Position of EIDR02 field.
	PORT1_PCNTR2_EIDR02_Pos = 0x12
	// Bit mask of EIDR02 field.
	PORT1_PCNTR2_EIDR02_Msk = 0x40000
	// Bit EIDR02.
	PORT1_PCNTR2_EIDR02 = 0x40000
	// Low input
	PORT1_PCNTR2_EIDR02_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR02_1 = 0x1
	// Position of EIDR03 field.
	PORT1_PCNTR2_EIDR03_Pos = 0x13
	// Bit mask of EIDR03 field.
	PORT1_PCNTR2_EIDR03_Msk = 0x80000
	// Bit EIDR03.
	PORT1_PCNTR2_EIDR03 = 0x80000
	// Low input
	PORT1_PCNTR2_EIDR03_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR03_1 = 0x1
	// Position of EIDR04 field.
	PORT1_PCNTR2_EIDR04_Pos = 0x14
	// Bit mask of EIDR04 field.
	PORT1_PCNTR2_EIDR04_Msk = 0x100000
	// Bit EIDR04.
	PORT1_PCNTR2_EIDR04 = 0x100000
	// Low input
	PORT1_PCNTR2_EIDR04_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR04_1 = 0x1
	// Position of EIDR05 field.
	PORT1_PCNTR2_EIDR05_Pos = 0x15
	// Bit mask of EIDR05 field.
	PORT1_PCNTR2_EIDR05_Msk = 0x200000
	// Bit EIDR05.
	PORT1_PCNTR2_EIDR05 = 0x200000
	// Low input
	PORT1_PCNTR2_EIDR05_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR05_1 = 0x1
	// Position of EIDR06 field.
	PORT1_PCNTR2_EIDR06_Pos = 0x16
	// Bit mask of EIDR06 field.
	PORT1_PCNTR2_EIDR06_Msk = 0x400000
	// Bit EIDR06.
	PORT1_PCNTR2_EIDR06 = 0x400000
	// Low input
	PORT1_PCNTR2_EIDR06_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR06_1 = 0x1
	// Position of EIDR07 field.
	PORT1_PCNTR2_EIDR07_Pos = 0x17
	// Bit mask of EIDR07 field.
	PORT1_PCNTR2_EIDR07_Msk = 0x800000
	// Bit EIDR07.
	PORT1_PCNTR2_EIDR07 = 0x800000
	// Low input
	PORT1_PCNTR2_EIDR07_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR07_1 = 0x1
	// Position of EIDR08 field.
	PORT1_PCNTR2_EIDR08_Pos = 0x18
	// Bit mask of EIDR08 field.
	PORT1_PCNTR2_EIDR08_Msk = 0x1000000
	// Bit EIDR08.
	PORT1_PCNTR2_EIDR08 = 0x1000000
	// Low input
	PORT1_PCNTR2_EIDR08_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR08_1 = 0x1
	// Position of EIDR09 field.
	PORT1_PCNTR2_EIDR09_Pos = 0x19
	// Bit mask of EIDR09 field.
	PORT1_PCNTR2_EIDR09_Msk = 0x2000000
	// Bit EIDR09.
	PORT1_PCNTR2_EIDR09 = 0x2000000
	// Low input
	PORT1_PCNTR2_EIDR09_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR09_1 = 0x1
	// Position of EIDR10 field.
	PORT1_PCNTR2_EIDR10_Pos = 0x1a
	// Bit mask of EIDR10 field.
	PORT1_PCNTR2_EIDR10_Msk = 0x4000000
	// Bit EIDR10.
	PORT1_PCNTR2_EIDR10 = 0x4000000
	// Low input
	PORT1_PCNTR2_EIDR10_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR10_1 = 0x1
	// Position of EIDR11 field.
	PORT1_PCNTR2_EIDR11_Pos = 0x1b
	// Bit mask of EIDR11 field.
	PORT1_PCNTR2_EIDR11_Msk = 0x8000000
	// Bit EIDR11.
	PORT1_PCNTR2_EIDR11 = 0x8000000
	// Low input
	PORT1_PCNTR2_EIDR11_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR11_1 = 0x1
	// Position of EIDR12 field.
	PORT1_PCNTR2_EIDR12_Pos = 0x1c
	// Bit mask of EIDR12 field.
	PORT1_PCNTR2_EIDR12_Msk = 0x10000000
	// Bit EIDR12.
	PORT1_PCNTR2_EIDR12 = 0x10000000
	// Low input
	PORT1_PCNTR2_EIDR12_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR12_1 = 0x1
	// Position of EIDR13 field.
	PORT1_PCNTR2_EIDR13_Pos = 0x1d
	// Bit mask of EIDR13 field.
	PORT1_PCNTR2_EIDR13_Msk = 0x20000000
	// Bit EIDR13.
	PORT1_PCNTR2_EIDR13 = 0x20000000
	// Low input
	PORT1_PCNTR2_EIDR13_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR13_1 = 0x1
	// Position of EIDR14 field.
	PORT1_PCNTR2_EIDR14_Pos = 0x1e
	// Bit mask of EIDR14 field.
	PORT1_PCNTR2_EIDR14_Msk = 0x40000000
	// Bit EIDR14.
	PORT1_PCNTR2_EIDR14 = 0x40000000
	// Low input
	PORT1_PCNTR2_EIDR14_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR14_1 = 0x1
	// Position of EIDR15 field.
	PORT1_PCNTR2_EIDR15_Pos = 0x1f
	// Bit mask of EIDR15 field.
	PORT1_PCNTR2_EIDR15_Msk = 0x80000000
	// Bit EIDR15.
	PORT1_PCNTR2_EIDR15 = 0x80000000
	// Low input
	PORT1_PCNTR2_EIDR15_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR15_1 = 0x1

	// EIDR: Port Control Register 2
	// Position of EIDR00 field.
	PORT1_EIDR_EIDR00_Pos = 0x0
	// Bit mask of EIDR00 field.
	PORT1_EIDR_EIDR00_Msk = 0x1
	// Bit EIDR00.
	PORT1_EIDR_EIDR00 = 0x1
	// Low input
	PORT1_EIDR_EIDR00_0 = 0x0
	// High input
	PORT1_EIDR_EIDR00_1 = 0x1
	// Position of EIDR01 field.
	PORT1_EIDR_EIDR01_Pos = 0x1
	// Bit mask of EIDR01 field.
	PORT1_EIDR_EIDR01_Msk = 0x2
	// Bit EIDR01.
	PORT1_EIDR_EIDR01 = 0x2
	// Low input
	PORT1_EIDR_EIDR01_0 = 0x0
	// High input
	PORT1_EIDR_EIDR01_1 = 0x1
	// Position of EIDR02 field.
	PORT1_EIDR_EIDR02_Pos = 0x2
	// Bit mask of EIDR02 field.
	PORT1_EIDR_EIDR02_Msk = 0x4
	// Bit EIDR02.
	PORT1_EIDR_EIDR02 = 0x4
	// Low input
	PORT1_EIDR_EIDR02_0 = 0x0
	// High input
	PORT1_EIDR_EIDR02_1 = 0x1
	// Position of EIDR03 field.
	PORT1_EIDR_EIDR03_Pos = 0x3
	// Bit mask of EIDR03 field.
	PORT1_EIDR_EIDR03_Msk = 0x8
	// Bit EIDR03.
	PORT1_EIDR_EIDR03 = 0x8
	// Low input
	PORT1_EIDR_EIDR03_0 = 0x0
	// High input
	PORT1_EIDR_EIDR03_1 = 0x1
	// Position of EIDR04 field.
	PORT1_EIDR_EIDR04_Pos = 0x4
	// Bit mask of EIDR04 field.
	PORT1_EIDR_EIDR04_Msk = 0x10
	// Bit EIDR04.
	PORT1_EIDR_EIDR04 = 0x10
	// Low input
	PORT1_EIDR_EIDR04_0 = 0x0
	// High input
	PORT1_EIDR_EIDR04_1 = 0x1
	// Position of EIDR05 field.
	PORT1_EIDR_EIDR05_Pos = 0x5
	// Bit mask of EIDR05 field.
	PORT1_EIDR_EIDR05_Msk = 0x20
	// Bit EIDR05.
	PORT1_EIDR_EIDR05 = 0x20
	// Low input
	PORT1_EIDR_EIDR05_0 = 0x0
	// High input
	PORT1_EIDR_EIDR05_1 = 0x1
	// Position of EIDR06 field.
	PORT1_EIDR_EIDR06_Pos = 0x6
	// Bit mask of EIDR06 field.
	PORT1_EIDR_EIDR06_Msk = 0x40
	// Bit EIDR06.
	PORT1_EIDR_EIDR06 = 0x40
	// Low input
	PORT1_EIDR_EIDR06_0 = 0x0
	// High input
	PORT1_EIDR_EIDR06_1 = 0x1
	// Position of EIDR07 field.
	PORT1_EIDR_EIDR07_Pos = 0x7
	// Bit mask of EIDR07 field.
	PORT1_EIDR_EIDR07_Msk = 0x80
	// Bit EIDR07.
	PORT1_EIDR_EIDR07 = 0x80
	// Low input
	PORT1_EIDR_EIDR07_0 = 0x0
	// High input
	PORT1_EIDR_EIDR07_1 = 0x1
	// Position of EIDR08 field.
	PORT1_EIDR_EIDR08_Pos = 0x8
	// Bit mask of EIDR08 field.
	PORT1_EIDR_EIDR08_Msk = 0x100
	// Bit EIDR08.
	PORT1_EIDR_EIDR08 = 0x100
	// Low input
	PORT1_EIDR_EIDR08_0 = 0x0
	// High input
	PORT1_EIDR_EIDR08_1 = 0x1
	// Position of EIDR09 field.
	PORT1_EIDR_EIDR09_Pos = 0x9
	// Bit mask of EIDR09 field.
	PORT1_EIDR_EIDR09_Msk = 0x200
	// Bit EIDR09.
	PORT1_EIDR_EIDR09 = 0x200
	// Low input
	PORT1_EIDR_EIDR09_0 = 0x0
	// High input
	PORT1_EIDR_EIDR09_1 = 0x1
	// Position of EIDR10 field.
	PORT1_EIDR_EIDR10_Pos = 0xa
	// Bit mask of EIDR10 field.
	PORT1_EIDR_EIDR10_Msk = 0x400
	// Bit EIDR10.
	PORT1_EIDR_EIDR10 = 0x400
	// Low input
	PORT1_EIDR_EIDR10_0 = 0x0
	// High input
	PORT1_EIDR_EIDR10_1 = 0x1
	// Position of EIDR11 field.
	PORT1_EIDR_EIDR11_Pos = 0xb
	// Bit mask of EIDR11 field.
	PORT1_EIDR_EIDR11_Msk = 0x800
	// Bit EIDR11.
	PORT1_EIDR_EIDR11 = 0x800
	// Low input
	PORT1_EIDR_EIDR11_0 = 0x0
	// High input
	PORT1_EIDR_EIDR11_1 = 0x1
	// Position of EIDR12 field.
	PORT1_EIDR_EIDR12_Pos = 0xc
	// Bit mask of EIDR12 field.
	PORT1_EIDR_EIDR12_Msk = 0x1000
	// Bit EIDR12.
	PORT1_EIDR_EIDR12 = 0x1000
	// Low input
	PORT1_EIDR_EIDR12_0 = 0x0
	// High input
	PORT1_EIDR_EIDR12_1 = 0x1
	// Position of EIDR13 field.
	PORT1_EIDR_EIDR13_Pos = 0xd
	// Bit mask of EIDR13 field.
	PORT1_EIDR_EIDR13_Msk = 0x2000
	// Bit EIDR13.
	PORT1_EIDR_EIDR13 = 0x2000
	// Low input
	PORT1_EIDR_EIDR13_0 = 0x0
	// High input
	PORT1_EIDR_EIDR13_1 = 0x1
	// Position of EIDR14 field.
	PORT1_EIDR_EIDR14_Pos = 0xe
	// Bit mask of EIDR14 field.
	PORT1_EIDR_EIDR14_Msk = 0x4000
	// Bit EIDR14.
	PORT1_EIDR_EIDR14 = 0x4000
	// Low input
	PORT1_EIDR_EIDR14_0 = 0x0
	// High input
	PORT1_EIDR_EIDR14_1 = 0x1
	// Position of EIDR15 field.
	PORT1_EIDR_EIDR15_Pos = 0xf
	// Bit mask of EIDR15 field.
	PORT1_EIDR_EIDR15_Msk = 0x8000
	// Bit EIDR15.
	PORT1_EIDR_EIDR15 = 0x8000
	// Low input
	PORT1_EIDR_EIDR15_0 = 0x0
	// High input
	PORT1_EIDR_EIDR15_1 = 0x1

	// PIDR: Port Control Register 2
	// Position of PIDR00 field.
	PORT1_PIDR_PIDR00_Pos = 0x0
	// Bit mask of PIDR00 field.
	PORT1_PIDR_PIDR00_Msk = 0x1
	// Bit PIDR00.
	PORT1_PIDR_PIDR00 = 0x1
	// Low level
	PORT1_PIDR_PIDR00_0 = 0x0
	// High level
	PORT1_PIDR_PIDR00_1 = 0x1
	// Position of PIDR01 field.
	PORT1_PIDR_PIDR01_Pos = 0x1
	// Bit mask of PIDR01 field.
	PORT1_PIDR_PIDR01_Msk = 0x2
	// Bit PIDR01.
	PORT1_PIDR_PIDR01 = 0x2
	// Low level
	PORT1_PIDR_PIDR01_0 = 0x0
	// High level
	PORT1_PIDR_PIDR01_1 = 0x1
	// Position of PIDR02 field.
	PORT1_PIDR_PIDR02_Pos = 0x2
	// Bit mask of PIDR02 field.
	PORT1_PIDR_PIDR02_Msk = 0x4
	// Bit PIDR02.
	PORT1_PIDR_PIDR02 = 0x4
	// Low level
	PORT1_PIDR_PIDR02_0 = 0x0
	// High level
	PORT1_PIDR_PIDR02_1 = 0x1
	// Position of PIDR03 field.
	PORT1_PIDR_PIDR03_Pos = 0x3
	// Bit mask of PIDR03 field.
	PORT1_PIDR_PIDR03_Msk = 0x8
	// Bit PIDR03.
	PORT1_PIDR_PIDR03 = 0x8
	// Low level
	PORT1_PIDR_PIDR03_0 = 0x0
	// High level
	PORT1_PIDR_PIDR03_1 = 0x1
	// Position of PIDR04 field.
	PORT1_PIDR_PIDR04_Pos = 0x4
	// Bit mask of PIDR04 field.
	PORT1_PIDR_PIDR04_Msk = 0x10
	// Bit PIDR04.
	PORT1_PIDR_PIDR04 = 0x10
	// Low level
	PORT1_PIDR_PIDR04_0 = 0x0
	// High level
	PORT1_PIDR_PIDR04_1 = 0x1
	// Position of PIDR05 field.
	PORT1_PIDR_PIDR05_Pos = 0x5
	// Bit mask of PIDR05 field.
	PORT1_PIDR_PIDR05_Msk = 0x20
	// Bit PIDR05.
	PORT1_PIDR_PIDR05 = 0x20
	// Low level
	PORT1_PIDR_PIDR05_0 = 0x0
	// High level
	PORT1_PIDR_PIDR05_1 = 0x1
	// Position of PIDR06 field.
	PORT1_PIDR_PIDR06_Pos = 0x6
	// Bit mask of PIDR06 field.
	PORT1_PIDR_PIDR06_Msk = 0x40
	// Bit PIDR06.
	PORT1_PIDR_PIDR06 = 0x40
	// Low level
	PORT1_PIDR_PIDR06_0 = 0x0
	// High level
	PORT1_PIDR_PIDR06_1 = 0x1
	// Position of PIDR07 field.
	PORT1_PIDR_PIDR07_Pos = 0x7
	// Bit mask of PIDR07 field.
	PORT1_PIDR_PIDR07_Msk = 0x80
	// Bit PIDR07.
	PORT1_PIDR_PIDR07 = 0x80
	// Low level
	PORT1_PIDR_PIDR07_0 = 0x0
	// High level
	PORT1_PIDR_PIDR07_1 = 0x1
	// Position of PIDR08 field.
	PORT1_PIDR_PIDR08_Pos = 0x8
	// Bit mask of PIDR08 field.
	PORT1_PIDR_PIDR08_Msk = 0x100
	// Bit PIDR08.
	PORT1_PIDR_PIDR08 = 0x100
	// Low level
	PORT1_PIDR_PIDR08_0 = 0x0
	// High level
	PORT1_PIDR_PIDR08_1 = 0x1
	// Position of PIDR09 field.
	PORT1_PIDR_PIDR09_Pos = 0x9
	// Bit mask of PIDR09 field.
	PORT1_PIDR_PIDR09_Msk = 0x200
	// Bit PIDR09.
	PORT1_PIDR_PIDR09 = 0x200
	// Low level
	PORT1_PIDR_PIDR09_0 = 0x0
	// High level
	PORT1_PIDR_PIDR09_1 = 0x1
	// Position of PIDR10 field.
	PORT1_PIDR_PIDR10_Pos = 0xa
	// Bit mask of PIDR10 field.
	PORT1_PIDR_PIDR10_Msk = 0x400
	// Bit PIDR10.
	PORT1_PIDR_PIDR10 = 0x400
	// Low level
	PORT1_PIDR_PIDR10_0 = 0x0
	// High level
	PORT1_PIDR_PIDR10_1 = 0x1
	// Position of PIDR11 field.
	PORT1_PIDR_PIDR11_Pos = 0xb
	// Bit mask of PIDR11 field.
	PORT1_PIDR_PIDR11_Msk = 0x800
	// Bit PIDR11.
	PORT1_PIDR_PIDR11 = 0x800
	// Low level
	PORT1_PIDR_PIDR11_0 = 0x0
	// High level
	PORT1_PIDR_PIDR11_1 = 0x1
	// Position of PIDR12 field.
	PORT1_PIDR_PIDR12_Pos = 0xc
	// Bit mask of PIDR12 field.
	PORT1_PIDR_PIDR12_Msk = 0x1000
	// Bit PIDR12.
	PORT1_PIDR_PIDR12 = 0x1000
	// Low level
	PORT1_PIDR_PIDR12_0 = 0x0
	// High level
	PORT1_PIDR_PIDR12_1 = 0x1
	// Position of PIDR13 field.
	PORT1_PIDR_PIDR13_Pos = 0xd
	// Bit mask of PIDR13 field.
	PORT1_PIDR_PIDR13_Msk = 0x2000
	// Bit PIDR13.
	PORT1_PIDR_PIDR13 = 0x2000
	// Low level
	PORT1_PIDR_PIDR13_0 = 0x0
	// High level
	PORT1_PIDR_PIDR13_1 = 0x1
	// Position of PIDR14 field.
	PORT1_PIDR_PIDR14_Pos = 0xe
	// Bit mask of PIDR14 field.
	PORT1_PIDR_PIDR14_Msk = 0x4000
	// Bit PIDR14.
	PORT1_PIDR_PIDR14 = 0x4000
	// Low level
	PORT1_PIDR_PIDR14_0 = 0x0
	// High level
	PORT1_PIDR_PIDR14_1 = 0x1
	// Position of PIDR15 field.
	PORT1_PIDR_PIDR15_Pos = 0xf
	// Bit mask of PIDR15 field.
	PORT1_PIDR_PIDR15_Msk = 0x8000
	// Bit PIDR15.
	PORT1_PIDR_PIDR15 = 0x8000
	// Low level
	PORT1_PIDR_PIDR15_0 = 0x0
	// High level
	PORT1_PIDR_PIDR15_1 = 0x1

	// PCNTR3: Port Control Register 3
	// Position of POSR00 field.
	PORT1_PCNTR3_POSR00_Pos = 0x0
	// Bit mask of POSR00 field.
	PORT1_PCNTR3_POSR00_Msk = 0x1
	// Bit POSR00.
	PORT1_PCNTR3_POSR00 = 0x1
	// No effect on output
	PORT1_PCNTR3_POSR00_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR00_1 = 0x1
	// Position of POSR01 field.
	PORT1_PCNTR3_POSR01_Pos = 0x1
	// Bit mask of POSR01 field.
	PORT1_PCNTR3_POSR01_Msk = 0x2
	// Bit POSR01.
	PORT1_PCNTR3_POSR01 = 0x2
	// No effect on output
	PORT1_PCNTR3_POSR01_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR01_1 = 0x1
	// Position of POSR02 field.
	PORT1_PCNTR3_POSR02_Pos = 0x2
	// Bit mask of POSR02 field.
	PORT1_PCNTR3_POSR02_Msk = 0x4
	// Bit POSR02.
	PORT1_PCNTR3_POSR02 = 0x4
	// No effect on output
	PORT1_PCNTR3_POSR02_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR02_1 = 0x1
	// Position of POSR03 field.
	PORT1_PCNTR3_POSR03_Pos = 0x3
	// Bit mask of POSR03 field.
	PORT1_PCNTR3_POSR03_Msk = 0x8
	// Bit POSR03.
	PORT1_PCNTR3_POSR03 = 0x8
	// No effect on output
	PORT1_PCNTR3_POSR03_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR03_1 = 0x1
	// Position of POSR04 field.
	PORT1_PCNTR3_POSR04_Pos = 0x4
	// Bit mask of POSR04 field.
	PORT1_PCNTR3_POSR04_Msk = 0x10
	// Bit POSR04.
	PORT1_PCNTR3_POSR04 = 0x10
	// No effect on output
	PORT1_PCNTR3_POSR04_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR04_1 = 0x1
	// Position of POSR05 field.
	PORT1_PCNTR3_POSR05_Pos = 0x5
	// Bit mask of POSR05 field.
	PORT1_PCNTR3_POSR05_Msk = 0x20
	// Bit POSR05.
	PORT1_PCNTR3_POSR05 = 0x20
	// No effect on output
	PORT1_PCNTR3_POSR05_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR05_1 = 0x1
	// Position of POSR06 field.
	PORT1_PCNTR3_POSR06_Pos = 0x6
	// Bit mask of POSR06 field.
	PORT1_PCNTR3_POSR06_Msk = 0x40
	// Bit POSR06.
	PORT1_PCNTR3_POSR06 = 0x40
	// No effect on output
	PORT1_PCNTR3_POSR06_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR06_1 = 0x1
	// Position of POSR07 field.
	PORT1_PCNTR3_POSR07_Pos = 0x7
	// Bit mask of POSR07 field.
	PORT1_PCNTR3_POSR07_Msk = 0x80
	// Bit POSR07.
	PORT1_PCNTR3_POSR07 = 0x80
	// No effect on output
	PORT1_PCNTR3_POSR07_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR07_1 = 0x1
	// Position of POSR08 field.
	PORT1_PCNTR3_POSR08_Pos = 0x8
	// Bit mask of POSR08 field.
	PORT1_PCNTR3_POSR08_Msk = 0x100
	// Bit POSR08.
	PORT1_PCNTR3_POSR08 = 0x100
	// No effect on output
	PORT1_PCNTR3_POSR08_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR08_1 = 0x1
	// Position of POSR09 field.
	PORT1_PCNTR3_POSR09_Pos = 0x9
	// Bit mask of POSR09 field.
	PORT1_PCNTR3_POSR09_Msk = 0x200
	// Bit POSR09.
	PORT1_PCNTR3_POSR09 = 0x200
	// No effect on output
	PORT1_PCNTR3_POSR09_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR09_1 = 0x1
	// Position of POSR10 field.
	PORT1_PCNTR3_POSR10_Pos = 0xa
	// Bit mask of POSR10 field.
	PORT1_PCNTR3_POSR10_Msk = 0x400
	// Bit POSR10.
	PORT1_PCNTR3_POSR10 = 0x400
	// No effect on output
	PORT1_PCNTR3_POSR10_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR10_1 = 0x1
	// Position of POSR11 field.
	PORT1_PCNTR3_POSR11_Pos = 0xb
	// Bit mask of POSR11 field.
	PORT1_PCNTR3_POSR11_Msk = 0x800
	// Bit POSR11.
	PORT1_PCNTR3_POSR11 = 0x800
	// No effect on output
	PORT1_PCNTR3_POSR11_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR11_1 = 0x1
	// Position of POSR12 field.
	PORT1_PCNTR3_POSR12_Pos = 0xc
	// Bit mask of POSR12 field.
	PORT1_PCNTR3_POSR12_Msk = 0x1000
	// Bit POSR12.
	PORT1_PCNTR3_POSR12 = 0x1000
	// No effect on output
	PORT1_PCNTR3_POSR12_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR12_1 = 0x1
	// Position of POSR13 field.
	PORT1_PCNTR3_POSR13_Pos = 0xd
	// Bit mask of POSR13 field.
	PORT1_PCNTR3_POSR13_Msk = 0x2000
	// Bit POSR13.
	PORT1_PCNTR3_POSR13 = 0x2000
	// No effect on output
	PORT1_PCNTR3_POSR13_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR13_1 = 0x1
	// Position of POSR14 field.
	PORT1_PCNTR3_POSR14_Pos = 0xe
	// Bit mask of POSR14 field.
	PORT1_PCNTR3_POSR14_Msk = 0x4000
	// Bit POSR14.
	PORT1_PCNTR3_POSR14 = 0x4000
	// No effect on output
	PORT1_PCNTR3_POSR14_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR14_1 = 0x1
	// Position of POSR15 field.
	PORT1_PCNTR3_POSR15_Pos = 0xf
	// Bit mask of POSR15 field.
	PORT1_PCNTR3_POSR15_Msk = 0x8000
	// Bit POSR15.
	PORT1_PCNTR3_POSR15 = 0x8000
	// No effect on output
	PORT1_PCNTR3_POSR15_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR15_1 = 0x1
	// Position of PORR00 field.
	PORT1_PCNTR3_PORR00_Pos = 0x10
	// Bit mask of PORR00 field.
	PORT1_PCNTR3_PORR00_Msk = 0x10000
	// Bit PORR00.
	PORT1_PCNTR3_PORR00 = 0x10000
	// No effect on output
	PORT1_PCNTR3_PORR00_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR00_1 = 0x1
	// Position of PORR01 field.
	PORT1_PCNTR3_PORR01_Pos = 0x11
	// Bit mask of PORR01 field.
	PORT1_PCNTR3_PORR01_Msk = 0x20000
	// Bit PORR01.
	PORT1_PCNTR3_PORR01 = 0x20000
	// No effect on output
	PORT1_PCNTR3_PORR01_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR01_1 = 0x1
	// Position of PORR02 field.
	PORT1_PCNTR3_PORR02_Pos = 0x12
	// Bit mask of PORR02 field.
	PORT1_PCNTR3_PORR02_Msk = 0x40000
	// Bit PORR02.
	PORT1_PCNTR3_PORR02 = 0x40000
	// No effect on output
	PORT1_PCNTR3_PORR02_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR02_1 = 0x1
	// Position of PORR03 field.
	PORT1_PCNTR3_PORR03_Pos = 0x13
	// Bit mask of PORR03 field.
	PORT1_PCNTR3_PORR03_Msk = 0x80000
	// Bit PORR03.
	PORT1_PCNTR3_PORR03 = 0x80000
	// No effect on output
	PORT1_PCNTR3_PORR03_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR03_1 = 0x1
	// Position of PORR04 field.
	PORT1_PCNTR3_PORR04_Pos = 0x14
	// Bit mask of PORR04 field.
	PORT1_PCNTR3_PORR04_Msk = 0x100000
	// Bit PORR04.
	PORT1_PCNTR3_PORR04 = 0x100000
	// No effect on output
	PORT1_PCNTR3_PORR04_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR04_1 = 0x1
	// Position of PORR05 field.
	PORT1_PCNTR3_PORR05_Pos = 0x15
	// Bit mask of PORR05 field.
	PORT1_PCNTR3_PORR05_Msk = 0x200000
	// Bit PORR05.
	PORT1_PCNTR3_PORR05 = 0x200000
	// No effect on output
	PORT1_PCNTR3_PORR05_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR05_1 = 0x1
	// Position of PORR06 field.
	PORT1_PCNTR3_PORR06_Pos = 0x16
	// Bit mask of PORR06 field.
	PORT1_PCNTR3_PORR06_Msk = 0x400000
	// Bit PORR06.
	PORT1_PCNTR3_PORR06 = 0x400000
	// No effect on output
	PORT1_PCNTR3_PORR06_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR06_1 = 0x1
	// Position of PORR07 field.
	PORT1_PCNTR3_PORR07_Pos = 0x17
	// Bit mask of PORR07 field.
	PORT1_PCNTR3_PORR07_Msk = 0x800000
	// Bit PORR07.
	PORT1_PCNTR3_PORR07 = 0x800000
	// No effect on output
	PORT1_PCNTR3_PORR07_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR07_1 = 0x1
	// Position of PORR08 field.
	PORT1_PCNTR3_PORR08_Pos = 0x18
	// Bit mask of PORR08 field.
	PORT1_PCNTR3_PORR08_Msk = 0x1000000
	// Bit PORR08.
	PORT1_PCNTR3_PORR08 = 0x1000000
	// No effect on output
	PORT1_PCNTR3_PORR08_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR08_1 = 0x1
	// Position of PORR09 field.
	PORT1_PCNTR3_PORR09_Pos = 0x19
	// Bit mask of PORR09 field.
	PORT1_PCNTR3_PORR09_Msk = 0x2000000
	// Bit PORR09.
	PORT1_PCNTR3_PORR09 = 0x2000000
	// No effect on output
	PORT1_PCNTR3_PORR09_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR09_1 = 0x1
	// Position of PORR10 field.
	PORT1_PCNTR3_PORR10_Pos = 0x1a
	// Bit mask of PORR10 field.
	PORT1_PCNTR3_PORR10_Msk = 0x4000000
	// Bit PORR10.
	PORT1_PCNTR3_PORR10 = 0x4000000
	// No effect on output
	PORT1_PCNTR3_PORR10_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR10_1 = 0x1
	// Position of PORR11 field.
	PORT1_PCNTR3_PORR11_Pos = 0x1b
	// Bit mask of PORR11 field.
	PORT1_PCNTR3_PORR11_Msk = 0x8000000
	// Bit PORR11.
	PORT1_PCNTR3_PORR11 = 0x8000000
	// No effect on output
	PORT1_PCNTR3_PORR11_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR11_1 = 0x1
	// Position of PORR12 field.
	PORT1_PCNTR3_PORR12_Pos = 0x1c
	// Bit mask of PORR12 field.
	PORT1_PCNTR3_PORR12_Msk = 0x10000000
	// Bit PORR12.
	PORT1_PCNTR3_PORR12 = 0x10000000
	// No effect on output
	PORT1_PCNTR3_PORR12_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR12_1 = 0x1
	// Position of PORR13 field.
	PORT1_PCNTR3_PORR13_Pos = 0x1d
	// Bit mask of PORR13 field.
	PORT1_PCNTR3_PORR13_Msk = 0x20000000
	// Bit PORR13.
	PORT1_PCNTR3_PORR13 = 0x20000000
	// No effect on output
	PORT1_PCNTR3_PORR13_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR13_1 = 0x1
	// Position of PORR14 field.
	PORT1_PCNTR3_PORR14_Pos = 0x1e
	// Bit mask of PORR14 field.
	PORT1_PCNTR3_PORR14_Msk = 0x40000000
	// Bit PORR14.
	PORT1_PCNTR3_PORR14 = 0x40000000
	// No effect on output
	PORT1_PCNTR3_PORR14_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR14_1 = 0x1
	// Position of PORR15 field.
	PORT1_PCNTR3_PORR15_Pos = 0x1f
	// Bit mask of PORR15 field.
	PORT1_PCNTR3_PORR15_Msk = 0x80000000
	// Bit PORR15.
	PORT1_PCNTR3_PORR15 = 0x80000000
	// No effect on output
	PORT1_PCNTR3_PORR15_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR15_1 = 0x1

	// PORR: Port Control Register 3
	// Position of PORR00 field.
	PORT1_PORR_PORR00_Pos = 0x0
	// Bit mask of PORR00 field.
	PORT1_PORR_PORR00_Msk = 0x1
	// Bit PORR00.
	PORT1_PORR_PORR00 = 0x1
	// No effect on output
	PORT1_PORR_PORR00_0 = 0x0
	// Low output
	PORT1_PORR_PORR00_1 = 0x1
	// Position of PORR01 field.
	PORT1_PORR_PORR01_Pos = 0x1
	// Bit mask of PORR01 field.
	PORT1_PORR_PORR01_Msk = 0x2
	// Bit PORR01.
	PORT1_PORR_PORR01 = 0x2
	// No effect on output
	PORT1_PORR_PORR01_0 = 0x0
	// Low output
	PORT1_PORR_PORR01_1 = 0x1
	// Position of PORR02 field.
	PORT1_PORR_PORR02_Pos = 0x2
	// Bit mask of PORR02 field.
	PORT1_PORR_PORR02_Msk = 0x4
	// Bit PORR02.
	PORT1_PORR_PORR02 = 0x4
	// No effect on output
	PORT1_PORR_PORR02_0 = 0x0
	// Low output
	PORT1_PORR_PORR02_1 = 0x1
	// Position of PORR03 field.
	PORT1_PORR_PORR03_Pos = 0x3
	// Bit mask of PORR03 field.
	PORT1_PORR_PORR03_Msk = 0x8
	// Bit PORR03.
	PORT1_PORR_PORR03 = 0x8
	// No effect on output
	PORT1_PORR_PORR03_0 = 0x0
	// Low output
	PORT1_PORR_PORR03_1 = 0x1
	// Position of PORR04 field.
	PORT1_PORR_PORR04_Pos = 0x4
	// Bit mask of PORR04 field.
	PORT1_PORR_PORR04_Msk = 0x10
	// Bit PORR04.
	PORT1_PORR_PORR04 = 0x10
	// No effect on output
	PORT1_PORR_PORR04_0 = 0x0
	// Low output
	PORT1_PORR_PORR04_1 = 0x1
	// Position of PORR05 field.
	PORT1_PORR_PORR05_Pos = 0x5
	// Bit mask of PORR05 field.
	PORT1_PORR_PORR05_Msk = 0x20
	// Bit PORR05.
	PORT1_PORR_PORR05 = 0x20
	// No effect on output
	PORT1_PORR_PORR05_0 = 0x0
	// Low output
	PORT1_PORR_PORR05_1 = 0x1
	// Position of PORR06 field.
	PORT1_PORR_PORR06_Pos = 0x6
	// Bit mask of PORR06 field.
	PORT1_PORR_PORR06_Msk = 0x40
	// Bit PORR06.
	PORT1_PORR_PORR06 = 0x40
	// No effect on output
	PORT1_PORR_PORR06_0 = 0x0
	// Low output
	PORT1_PORR_PORR06_1 = 0x1
	// Position of PORR07 field.
	PORT1_PORR_PORR07_Pos = 0x7
	// Bit mask of PORR07 field.
	PORT1_PORR_PORR07_Msk = 0x80
	// Bit PORR07.
	PORT1_PORR_PORR07 = 0x80
	// No effect on output
	PORT1_PORR_PORR07_0 = 0x0
	// Low output
	PORT1_PORR_PORR07_1 = 0x1
	// Position of PORR08 field.
	PORT1_PORR_PORR08_Pos = 0x8
	// Bit mask of PORR08 field.
	PORT1_PORR_PORR08_Msk = 0x100
	// Bit PORR08.
	PORT1_PORR_PORR08 = 0x100
	// No effect on output
	PORT1_PORR_PORR08_0 = 0x0
	// Low output
	PORT1_PORR_PORR08_1 = 0x1
	// Position of PORR09 field.
	PORT1_PORR_PORR09_Pos = 0x9
	// Bit mask of PORR09 field.
	PORT1_PORR_PORR09_Msk = 0x200
	// Bit PORR09.
	PORT1_PORR_PORR09 = 0x200
	// No effect on output
	PORT1_PORR_PORR09_0 = 0x0
	// Low output
	PORT1_PORR_PORR09_1 = 0x1
	// Position of PORR10 field.
	PORT1_PORR_PORR10_Pos = 0xa
	// Bit mask of PORR10 field.
	PORT1_PORR_PORR10_Msk = 0x400
	// Bit PORR10.
	PORT1_PORR_PORR10 = 0x400
	// No effect on output
	PORT1_PORR_PORR10_0 = 0x0
	// Low output
	PORT1_PORR_PORR10_1 = 0x1
	// Position of PORR11 field.
	PORT1_PORR_PORR11_Pos = 0xb
	// Bit mask of PORR11 field.
	PORT1_PORR_PORR11_Msk = 0x800
	// Bit PORR11.
	PORT1_PORR_PORR11 = 0x800
	// No effect on output
	PORT1_PORR_PORR11_0 = 0x0
	// Low output
	PORT1_PORR_PORR11_1 = 0x1
	// Position of PORR12 field.
	PORT1_PORR_PORR12_Pos = 0xc
	// Bit mask of PORR12 field.
	PORT1_PORR_PORR12_Msk = 0x1000
	// Bit PORR12.
	PORT1_PORR_PORR12 = 0x1000
	// No effect on output
	PORT1_PORR_PORR12_0 = 0x0
	// Low output
	PORT1_PORR_PORR12_1 = 0x1
	// Position of PORR13 field.
	PORT1_PORR_PORR13_Pos = 0xd
	// Bit mask of PORR13 field.
	PORT1_PORR_PORR13_Msk = 0x2000
	// Bit PORR13.
	PORT1_PORR_PORR13 = 0x2000
	// No effect on output
	PORT1_PORR_PORR13_0 = 0x0
	// Low output
	PORT1_PORR_PORR13_1 = 0x1
	// Position of PORR14 field.
	PORT1_PORR_PORR14_Pos = 0xe
	// Bit mask of PORR14 field.
	PORT1_PORR_PORR14_Msk = 0x4000
	// Bit PORR14.
	PORT1_PORR_PORR14 = 0x4000
	// No effect on output
	PORT1_PORR_PORR14_0 = 0x0
	// Low output
	PORT1_PORR_PORR14_1 = 0x1
	// Position of PORR15 field.
	PORT1_PORR_PORR15_Pos = 0xf
	// Bit mask of PORR15 field.
	PORT1_PORR_PORR15_Msk = 0x8000
	// Bit PORR15.
	PORT1_PORR_PORR15 = 0x8000
	// No effect on output
	PORT1_PORR_PORR15_0 = 0x0
	// Low output
	PORT1_PORR_PORR15_1 = 0x1

	// POSR: Port Control Register 3
	// Position of POSR00 field.
	PORT1_POSR_POSR00_Pos = 0x0
	// Bit mask of POSR00 field.
	PORT1_POSR_POSR00_Msk = 0x1
	// Bit POSR00.
	PORT1_POSR_POSR00 = 0x1
	// No effect on output
	PORT1_POSR_POSR00_0 = 0x0
	// High output
	PORT1_POSR_POSR00_1 = 0x1
	// Position of POSR01 field.
	PORT1_POSR_POSR01_Pos = 0x1
	// Bit mask of POSR01 field.
	PORT1_POSR_POSR01_Msk = 0x2
	// Bit POSR01.
	PORT1_POSR_POSR01 = 0x2
	// No effect on output
	PORT1_POSR_POSR01_0 = 0x0
	// High output
	PORT1_POSR_POSR01_1 = 0x1
	// Position of POSR02 field.
	PORT1_POSR_POSR02_Pos = 0x2
	// Bit mask of POSR02 field.
	PORT1_POSR_POSR02_Msk = 0x4
	// Bit POSR02.
	PORT1_POSR_POSR02 = 0x4
	// No effect on output
	PORT1_POSR_POSR02_0 = 0x0
	// High output
	PORT1_POSR_POSR02_1 = 0x1
	// Position of POSR03 field.
	PORT1_POSR_POSR03_Pos = 0x3
	// Bit mask of POSR03 field.
	PORT1_POSR_POSR03_Msk = 0x8
	// Bit POSR03.
	PORT1_POSR_POSR03 = 0x8
	// No effect on output
	PORT1_POSR_POSR03_0 = 0x0
	// High output
	PORT1_POSR_POSR03_1 = 0x1
	// Position of POSR04 field.
	PORT1_POSR_POSR04_Pos = 0x4
	// Bit mask of POSR04 field.
	PORT1_POSR_POSR04_Msk = 0x10
	// Bit POSR04.
	PORT1_POSR_POSR04 = 0x10
	// No effect on output
	PORT1_POSR_POSR04_0 = 0x0
	// High output
	PORT1_POSR_POSR04_1 = 0x1
	// Position of POSR05 field.
	PORT1_POSR_POSR05_Pos = 0x5
	// Bit mask of POSR05 field.
	PORT1_POSR_POSR05_Msk = 0x20
	// Bit POSR05.
	PORT1_POSR_POSR05 = 0x20
	// No effect on output
	PORT1_POSR_POSR05_0 = 0x0
	// High output
	PORT1_POSR_POSR05_1 = 0x1
	// Position of POSR06 field.
	PORT1_POSR_POSR06_Pos = 0x6
	// Bit mask of POSR06 field.
	PORT1_POSR_POSR06_Msk = 0x40
	// Bit POSR06.
	PORT1_POSR_POSR06 = 0x40
	// No effect on output
	PORT1_POSR_POSR06_0 = 0x0
	// High output
	PORT1_POSR_POSR06_1 = 0x1
	// Position of POSR07 field.
	PORT1_POSR_POSR07_Pos = 0x7
	// Bit mask of POSR07 field.
	PORT1_POSR_POSR07_Msk = 0x80
	// Bit POSR07.
	PORT1_POSR_POSR07 = 0x80
	// No effect on output
	PORT1_POSR_POSR07_0 = 0x0
	// High output
	PORT1_POSR_POSR07_1 = 0x1
	// Position of POSR08 field.
	PORT1_POSR_POSR08_Pos = 0x8
	// Bit mask of POSR08 field.
	PORT1_POSR_POSR08_Msk = 0x100
	// Bit POSR08.
	PORT1_POSR_POSR08 = 0x100
	// No effect on output
	PORT1_POSR_POSR08_0 = 0x0
	// High output
	PORT1_POSR_POSR08_1 = 0x1
	// Position of POSR09 field.
	PORT1_POSR_POSR09_Pos = 0x9
	// Bit mask of POSR09 field.
	PORT1_POSR_POSR09_Msk = 0x200
	// Bit POSR09.
	PORT1_POSR_POSR09 = 0x200
	// No effect on output
	PORT1_POSR_POSR09_0 = 0x0
	// High output
	PORT1_POSR_POSR09_1 = 0x1
	// Position of POSR10 field.
	PORT1_POSR_POSR10_Pos = 0xa
	// Bit mask of POSR10 field.
	PORT1_POSR_POSR10_Msk = 0x400
	// Bit POSR10.
	PORT1_POSR_POSR10 = 0x400
	// No effect on output
	PORT1_POSR_POSR10_0 = 0x0
	// High output
	PORT1_POSR_POSR10_1 = 0x1
	// Position of POSR11 field.
	PORT1_POSR_POSR11_Pos = 0xb
	// Bit mask of POSR11 field.
	PORT1_POSR_POSR11_Msk = 0x800
	// Bit POSR11.
	PORT1_POSR_POSR11 = 0x800
	// No effect on output
	PORT1_POSR_POSR11_0 = 0x0
	// High output
	PORT1_POSR_POSR11_1 = 0x1
	// Position of POSR12 field.
	PORT1_POSR_POSR12_Pos = 0xc
	// Bit mask of POSR12 field.
	PORT1_POSR_POSR12_Msk = 0x1000
	// Bit POSR12.
	PORT1_POSR_POSR12 = 0x1000
	// No effect on output
	PORT1_POSR_POSR12_0 = 0x0
	// High output
	PORT1_POSR_POSR12_1 = 0x1
	// Position of POSR13 field.
	PORT1_POSR_POSR13_Pos = 0xd
	// Bit mask of POSR13 field.
	PORT1_POSR_POSR13_Msk = 0x2000
	// Bit POSR13.
	PORT1_POSR_POSR13 = 0x2000
	// No effect on output
	PORT1_POSR_POSR13_0 = 0x0
	// High output
	PORT1_POSR_POSR13_1 = 0x1
	// Position of POSR14 field.
	PORT1_POSR_POSR14_Pos = 0xe
	// Bit mask of POSR14 field.
	PORT1_POSR_POSR14_Msk = 0x4000
	// Bit POSR14.
	PORT1_POSR_POSR14 = 0x4000
	// No effect on output
	PORT1_POSR_POSR14_0 = 0x0
	// High output
	PORT1_POSR_POSR14_1 = 0x1
	// Position of POSR15 field.
	PORT1_POSR_POSR15_Pos = 0xf
	// Bit mask of POSR15 field.
	PORT1_POSR_POSR15_Msk = 0x8000
	// Bit POSR15.
	PORT1_POSR_POSR15 = 0x8000
	// No effect on output
	PORT1_POSR_POSR15_0 = 0x0
	// High output
	PORT1_POSR_POSR15_1 = 0x1

	// PCNTR4: Port Control Register 4
	// Position of EOSR00 field.
	PORT1_PCNTR4_EOSR00_Pos = 0x0
	// Bit mask of EOSR00 field.
	PORT1_PCNTR4_EOSR00_Msk = 0x1
	// Bit EOSR00.
	PORT1_PCNTR4_EOSR00 = 0x1
	// No effect on output
	PORT1_PCNTR4_EOSR00_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR00_1 = 0x1
	// Position of EOSR01 field.
	PORT1_PCNTR4_EOSR01_Pos = 0x1
	// Bit mask of EOSR01 field.
	PORT1_PCNTR4_EOSR01_Msk = 0x2
	// Bit EOSR01.
	PORT1_PCNTR4_EOSR01 = 0x2
	// No effect on output
	PORT1_PCNTR4_EOSR01_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR01_1 = 0x1
	// Position of EOSR02 field.
	PORT1_PCNTR4_EOSR02_Pos = 0x2
	// Bit mask of EOSR02 field.
	PORT1_PCNTR4_EOSR02_Msk = 0x4
	// Bit EOSR02.
	PORT1_PCNTR4_EOSR02 = 0x4
	// No effect on output
	PORT1_PCNTR4_EOSR02_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR02_1 = 0x1
	// Position of EOSR03 field.
	PORT1_PCNTR4_EOSR03_Pos = 0x3
	// Bit mask of EOSR03 field.
	PORT1_PCNTR4_EOSR03_Msk = 0x8
	// Bit EOSR03.
	PORT1_PCNTR4_EOSR03 = 0x8
	// No effect on output
	PORT1_PCNTR4_EOSR03_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR03_1 = 0x1
	// Position of EOSR04 field.
	PORT1_PCNTR4_EOSR04_Pos = 0x4
	// Bit mask of EOSR04 field.
	PORT1_PCNTR4_EOSR04_Msk = 0x10
	// Bit EOSR04.
	PORT1_PCNTR4_EOSR04 = 0x10
	// No effect on output
	PORT1_PCNTR4_EOSR04_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR04_1 = 0x1
	// Position of EOSR05 field.
	PORT1_PCNTR4_EOSR05_Pos = 0x5
	// Bit mask of EOSR05 field.
	PORT1_PCNTR4_EOSR05_Msk = 0x20
	// Bit EOSR05.
	PORT1_PCNTR4_EOSR05 = 0x20
	// No effect on output
	PORT1_PCNTR4_EOSR05_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR05_1 = 0x1
	// Position of EOSR06 field.
	PORT1_PCNTR4_EOSR06_Pos = 0x6
	// Bit mask of EOSR06 field.
	PORT1_PCNTR4_EOSR06_Msk = 0x40
	// Bit EOSR06.
	PORT1_PCNTR4_EOSR06 = 0x40
	// No effect on output
	PORT1_PCNTR4_EOSR06_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR06_1 = 0x1
	// Position of EOSR07 field.
	PORT1_PCNTR4_EOSR07_Pos = 0x7
	// Bit mask of EOSR07 field.
	PORT1_PCNTR4_EOSR07_Msk = 0x80
	// Bit EOSR07.
	PORT1_PCNTR4_EOSR07 = 0x80
	// No effect on output
	PORT1_PCNTR4_EOSR07_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR07_1 = 0x1
	// Position of EOSR08 field.
	PORT1_PCNTR4_EOSR08_Pos = 0x8
	// Bit mask of EOSR08 field.
	PORT1_PCNTR4_EOSR08_Msk = 0x100
	// Bit EOSR08.
	PORT1_PCNTR4_EOSR08 = 0x100
	// No effect on output
	PORT1_PCNTR4_EOSR08_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR08_1 = 0x1
	// Position of EOSR09 field.
	PORT1_PCNTR4_EOSR09_Pos = 0x9
	// Bit mask of EOSR09 field.
	PORT1_PCNTR4_EOSR09_Msk = 0x200
	// Bit EOSR09.
	PORT1_PCNTR4_EOSR09 = 0x200
	// No effect on output
	PORT1_PCNTR4_EOSR09_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR09_1 = 0x1
	// Position of EOSR10 field.
	PORT1_PCNTR4_EOSR10_Pos = 0xa
	// Bit mask of EOSR10 field.
	PORT1_PCNTR4_EOSR10_Msk = 0x400
	// Bit EOSR10.
	PORT1_PCNTR4_EOSR10 = 0x400
	// No effect on output
	PORT1_PCNTR4_EOSR10_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR10_1 = 0x1
	// Position of EOSR11 field.
	PORT1_PCNTR4_EOSR11_Pos = 0xb
	// Bit mask of EOSR11 field.
	PORT1_PCNTR4_EOSR11_Msk = 0x800
	// Bit EOSR11.
	PORT1_PCNTR4_EOSR11 = 0x800
	// No effect on output
	PORT1_PCNTR4_EOSR11_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR11_1 = 0x1
	// Position of EOSR12 field.
	PORT1_PCNTR4_EOSR12_Pos = 0xc
	// Bit mask of EOSR12 field.
	PORT1_PCNTR4_EOSR12_Msk = 0x1000
	// Bit EOSR12.
	PORT1_PCNTR4_EOSR12 = 0x1000
	// No effect on output
	PORT1_PCNTR4_EOSR12_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR12_1 = 0x1
	// Position of EOSR13 field.
	PORT1_PCNTR4_EOSR13_Pos = 0xd
	// Bit mask of EOSR13 field.
	PORT1_PCNTR4_EOSR13_Msk = 0x2000
	// Bit EOSR13.
	PORT1_PCNTR4_EOSR13 = 0x2000
	// No effect on output
	PORT1_PCNTR4_EOSR13_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR13_1 = 0x1
	// Position of EOSR14 field.
	PORT1_PCNTR4_EOSR14_Pos = 0xe
	// Bit mask of EOSR14 field.
	PORT1_PCNTR4_EOSR14_Msk = 0x4000
	// Bit EOSR14.
	PORT1_PCNTR4_EOSR14 = 0x4000
	// No effect on output
	PORT1_PCNTR4_EOSR14_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR14_1 = 0x1
	// Position of EOSR15 field.
	PORT1_PCNTR4_EOSR15_Pos = 0xf
	// Bit mask of EOSR15 field.
	PORT1_PCNTR4_EOSR15_Msk = 0x8000
	// Bit EOSR15.
	PORT1_PCNTR4_EOSR15 = 0x8000
	// No effect on output
	PORT1_PCNTR4_EOSR15_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR15_1 = 0x1
	// Position of EORR00 field.
	PORT1_PCNTR4_EORR00_Pos = 0x10
	// Bit mask of EORR00 field.
	PORT1_PCNTR4_EORR00_Msk = 0x10000
	// Bit EORR00.
	PORT1_PCNTR4_EORR00 = 0x10000
	// No effect on output
	PORT1_PCNTR4_EORR00_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR00_1 = 0x1
	// Position of EORR01 field.
	PORT1_PCNTR4_EORR01_Pos = 0x11
	// Bit mask of EORR01 field.
	PORT1_PCNTR4_EORR01_Msk = 0x20000
	// Bit EORR01.
	PORT1_PCNTR4_EORR01 = 0x20000
	// No effect on output
	PORT1_PCNTR4_EORR01_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR01_1 = 0x1
	// Position of EORR02 field.
	PORT1_PCNTR4_EORR02_Pos = 0x12
	// Bit mask of EORR02 field.
	PORT1_PCNTR4_EORR02_Msk = 0x40000
	// Bit EORR02.
	PORT1_PCNTR4_EORR02 = 0x40000
	// No effect on output
	PORT1_PCNTR4_EORR02_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR02_1 = 0x1
	// Position of EORR03 field.
	PORT1_PCNTR4_EORR03_Pos = 0x13
	// Bit mask of EORR03 field.
	PORT1_PCNTR4_EORR03_Msk = 0x80000
	// Bit EORR03.
	PORT1_PCNTR4_EORR03 = 0x80000
	// No effect on output
	PORT1_PCNTR4_EORR03_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR03_1 = 0x1
	// Position of EORR04 field.
	PORT1_PCNTR4_EORR04_Pos = 0x14
	// Bit mask of EORR04 field.
	PORT1_PCNTR4_EORR04_Msk = 0x100000
	// Bit EORR04.
	PORT1_PCNTR4_EORR04 = 0x100000
	// No effect on output
	PORT1_PCNTR4_EORR04_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR04_1 = 0x1
	// Position of EORR05 field.
	PORT1_PCNTR4_EORR05_Pos = 0x15
	// Bit mask of EORR05 field.
	PORT1_PCNTR4_EORR05_Msk = 0x200000
	// Bit EORR05.
	PORT1_PCNTR4_EORR05 = 0x200000
	// No effect on output
	PORT1_PCNTR4_EORR05_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR05_1 = 0x1
	// Position of EORR06 field.
	PORT1_PCNTR4_EORR06_Pos = 0x16
	// Bit mask of EORR06 field.
	PORT1_PCNTR4_EORR06_Msk = 0x400000
	// Bit EORR06.
	PORT1_PCNTR4_EORR06 = 0x400000
	// No effect on output
	PORT1_PCNTR4_EORR06_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR06_1 = 0x1
	// Position of EORR07 field.
	PORT1_PCNTR4_EORR07_Pos = 0x17
	// Bit mask of EORR07 field.
	PORT1_PCNTR4_EORR07_Msk = 0x800000
	// Bit EORR07.
	PORT1_PCNTR4_EORR07 = 0x800000
	// No effect on output
	PORT1_PCNTR4_EORR07_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR07_1 = 0x1
	// Position of EORR08 field.
	PORT1_PCNTR4_EORR08_Pos = 0x18
	// Bit mask of EORR08 field.
	PORT1_PCNTR4_EORR08_Msk = 0x1000000
	// Bit EORR08.
	PORT1_PCNTR4_EORR08 = 0x1000000
	// No effect on output
	PORT1_PCNTR4_EORR08_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR08_1 = 0x1
	// Position of EORR09 field.
	PORT1_PCNTR4_EORR09_Pos = 0x19
	// Bit mask of EORR09 field.
	PORT1_PCNTR4_EORR09_Msk = 0x2000000
	// Bit EORR09.
	PORT1_PCNTR4_EORR09 = 0x2000000
	// No effect on output
	PORT1_PCNTR4_EORR09_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR09_1 = 0x1
	// Position of EORR10 field.
	PORT1_PCNTR4_EORR10_Pos = 0x1a
	// Bit mask of EORR10 field.
	PORT1_PCNTR4_EORR10_Msk = 0x4000000
	// Bit EORR10.
	PORT1_PCNTR4_EORR10 = 0x4000000
	// No effect on output
	PORT1_PCNTR4_EORR10_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR10_1 = 0x1
	// Position of EORR11 field.
	PORT1_PCNTR4_EORR11_Pos = 0x1b
	// Bit mask of EORR11 field.
	PORT1_PCNTR4_EORR11_Msk = 0x8000000
	// Bit EORR11.
	PORT1_PCNTR4_EORR11 = 0x8000000
	// No effect on output
	PORT1_PCNTR4_EORR11_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR11_1 = 0x1
	// Position of EORR12 field.
	PORT1_PCNTR4_EORR12_Pos = 0x1c
	// Bit mask of EORR12 field.
	PORT1_PCNTR4_EORR12_Msk = 0x10000000
	// Bit EORR12.
	PORT1_PCNTR4_EORR12 = 0x10000000
	// No effect on output
	PORT1_PCNTR4_EORR12_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR12_1 = 0x1
	// Position of EORR13 field.
	PORT1_PCNTR4_EORR13_Pos = 0x1d
	// Bit mask of EORR13 field.
	PORT1_PCNTR4_EORR13_Msk = 0x20000000
	// Bit EORR13.
	PORT1_PCNTR4_EORR13 = 0x20000000
	// No effect on output
	PORT1_PCNTR4_EORR13_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR13_1 = 0x1
	// Position of EORR14 field.
	PORT1_PCNTR4_EORR14_Pos = 0x1e
	// Bit mask of EORR14 field.
	PORT1_PCNTR4_EORR14_Msk = 0x40000000
	// Bit EORR14.
	PORT1_PCNTR4_EORR14 = 0x40000000
	// No effect on output
	PORT1_PCNTR4_EORR14_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR14_1 = 0x1
	// Position of EORR15 field.
	PORT1_PCNTR4_EORR15_Pos = 0x1f
	// Bit mask of EORR15 field.
	PORT1_PCNTR4_EORR15_Msk = 0x80000000
	// Bit EORR15.
	PORT1_PCNTR4_EORR15 = 0x80000000
	// No effect on output
	PORT1_PCNTR4_EORR15_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR15_1 = 0x1

	// EORR: Port Control Register 4
	// Position of EORR00 field.
	PORT1_EORR_EORR00_Pos = 0x0
	// Bit mask of EORR00 field.
	PORT1_EORR_EORR00_Msk = 0x1
	// Bit EORR00.
	PORT1_EORR_EORR00 = 0x1
	// No effect on output
	PORT1_EORR_EORR00_0 = 0x0
	// Low output
	PORT1_EORR_EORR00_1 = 0x1
	// Position of EORR01 field.
	PORT1_EORR_EORR01_Pos = 0x1
	// Bit mask of EORR01 field.
	PORT1_EORR_EORR01_Msk = 0x2
	// Bit EORR01.
	PORT1_EORR_EORR01 = 0x2
	// No effect on output
	PORT1_EORR_EORR01_0 = 0x0
	// Low output
	PORT1_EORR_EORR01_1 = 0x1
	// Position of EORR02 field.
	PORT1_EORR_EORR02_Pos = 0x2
	// Bit mask of EORR02 field.
	PORT1_EORR_EORR02_Msk = 0x4
	// Bit EORR02.
	PORT1_EORR_EORR02 = 0x4
	// No effect on output
	PORT1_EORR_EORR02_0 = 0x0
	// Low output
	PORT1_EORR_EORR02_1 = 0x1
	// Position of EORR03 field.
	PORT1_EORR_EORR03_Pos = 0x3
	// Bit mask of EORR03 field.
	PORT1_EORR_EORR03_Msk = 0x8
	// Bit EORR03.
	PORT1_EORR_EORR03 = 0x8
	// No effect on output
	PORT1_EORR_EORR03_0 = 0x0
	// Low output
	PORT1_EORR_EORR03_1 = 0x1
	// Position of EORR04 field.
	PORT1_EORR_EORR04_Pos = 0x4
	// Bit mask of EORR04 field.
	PORT1_EORR_EORR04_Msk = 0x10
	// Bit EORR04.
	PORT1_EORR_EORR04 = 0x10
	// No effect on output
	PORT1_EORR_EORR04_0 = 0x0
	// Low output
	PORT1_EORR_EORR04_1 = 0x1
	// Position of EORR05 field.
	PORT1_EORR_EORR05_Pos = 0x5
	// Bit mask of EORR05 field.
	PORT1_EORR_EORR05_Msk = 0x20
	// Bit EORR05.
	PORT1_EORR_EORR05 = 0x20
	// No effect on output
	PORT1_EORR_EORR05_0 = 0x0
	// Low output
	PORT1_EORR_EORR05_1 = 0x1
	// Position of EORR06 field.
	PORT1_EORR_EORR06_Pos = 0x6
	// Bit mask of EORR06 field.
	PORT1_EORR_EORR06_Msk = 0x40
	// Bit EORR06.
	PORT1_EORR_EORR06 = 0x40
	// No effect on output
	PORT1_EORR_EORR06_0 = 0x0
	// Low output
	PORT1_EORR_EORR06_1 = 0x1
	// Position of EORR07 field.
	PORT1_EORR_EORR07_Pos = 0x7
	// Bit mask of EORR07 field.
	PORT1_EORR_EORR07_Msk = 0x80
	// Bit EORR07.
	PORT1_EORR_EORR07 = 0x80
	// No effect on output
	PORT1_EORR_EORR07_0 = 0x0
	// Low output
	PORT1_EORR_EORR07_1 = 0x1
	// Position of EORR08 field.
	PORT1_EORR_EORR08_Pos = 0x8
	// Bit mask of EORR08 field.
	PORT1_EORR_EORR08_Msk = 0x100
	// Bit EORR08.
	PORT1_EORR_EORR08 = 0x100
	// No effect on output
	PORT1_EORR_EORR08_0 = 0x0
	// Low output
	PORT1_EORR_EORR08_1 = 0x1
	// Position of EORR09 field.
	PORT1_EORR_EORR09_Pos = 0x9
	// Bit mask of EORR09 field.
	PORT1_EORR_EORR09_Msk = 0x200
	// Bit EORR09.
	PORT1_EORR_EORR09 = 0x200
	// No effect on output
	PORT1_EORR_EORR09_0 = 0x0
	// Low output
	PORT1_EORR_EORR09_1 = 0x1
	// Position of EORR10 field.
	PORT1_EORR_EORR10_Pos = 0xa
	// Bit mask of EORR10 field.
	PORT1_EORR_EORR10_Msk = 0x400
	// Bit EORR10.
	PORT1_EORR_EORR10 = 0x400
	// No effect on output
	PORT1_EORR_EORR10_0 = 0x0
	// Low output
	PORT1_EORR_EORR10_1 = 0x1
	// Position of EORR11 field.
	PORT1_EORR_EORR11_Pos = 0xb
	// Bit mask of EORR11 field.
	PORT1_EORR_EORR11_Msk = 0x800
	// Bit EORR11.
	PORT1_EORR_EORR11 = 0x800
	// No effect on output
	PORT1_EORR_EORR11_0 = 0x0
	// Low output
	PORT1_EORR_EORR11_1 = 0x1
	// Position of EORR12 field.
	PORT1_EORR_EORR12_Pos = 0xc
	// Bit mask of EORR12 field.
	PORT1_EORR_EORR12_Msk = 0x1000
	// Bit EORR12.
	PORT1_EORR_EORR12 = 0x1000
	// No effect on output
	PORT1_EORR_EORR12_0 = 0x0
	// Low output
	PORT1_EORR_EORR12_1 = 0x1
	// Position of EORR13 field.
	PORT1_EORR_EORR13_Pos = 0xd
	// Bit mask of EORR13 field.
	PORT1_EORR_EORR13_Msk = 0x2000
	// Bit EORR13.
	PORT1_EORR_EORR13 = 0x2000
	// No effect on output
	PORT1_EORR_EORR13_0 = 0x0
	// Low output
	PORT1_EORR_EORR13_1 = 0x1
	// Position of EORR14 field.
	PORT1_EORR_EORR14_Pos = 0xe
	// Bit mask of EORR14 field.
	PORT1_EORR_EORR14_Msk = 0x4000
	// Bit EORR14.
	PORT1_EORR_EORR14 = 0x4000
	// No effect on output
	PORT1_EORR_EORR14_0 = 0x0
	// Low output
	PORT1_EORR_EORR14_1 = 0x1
	// Position of EORR15 field.
	PORT1_EORR_EORR15_Pos = 0xf
	// Bit mask of EORR15 field.
	PORT1_EORR_EORR15_Msk = 0x8000
	// Bit EORR15.
	PORT1_EORR_EORR15 = 0x8000
	// No effect on output
	PORT1_EORR_EORR15_0 = 0x0
	// Low output
	PORT1_EORR_EORR15_1 = 0x1

	// EOSR: Port Control Register 4
	// Position of EOSR00 field.
	PORT1_EOSR_EOSR00_Pos = 0x0
	// Bit mask of EOSR00 field.
	PORT1_EOSR_EOSR00_Msk = 0x1
	// Bit EOSR00.
	PORT1_EOSR_EOSR00 = 0x1
	// No effect on output
	PORT1_EOSR_EOSR00_0 = 0x0
	// High output
	PORT1_EOSR_EOSR00_1 = 0x1
	// Position of EOSR01 field.
	PORT1_EOSR_EOSR01_Pos = 0x1
	// Bit mask of EOSR01 field.
	PORT1_EOSR_EOSR01_Msk = 0x2
	// Bit EOSR01.
	PORT1_EOSR_EOSR01 = 0x2
	// No effect on output
	PORT1_EOSR_EOSR01_0 = 0x0
	// High output
	PORT1_EOSR_EOSR01_1 = 0x1
	// Position of EOSR02 field.
	PORT1_EOSR_EOSR02_Pos = 0x2
	// Bit mask of EOSR02 field.
	PORT1_EOSR_EOSR02_Msk = 0x4
	// Bit EOSR02.
	PORT1_EOSR_EOSR02 = 0x4
	// No effect on output
	PORT1_EOSR_EOSR02_0 = 0x0
	// High output
	PORT1_EOSR_EOSR02_1 = 0x1
	// Position of EOSR03 field.
	PORT1_EOSR_EOSR03_Pos = 0x3
	// Bit mask of EOSR03 field.
	PORT1_EOSR_EOSR03_Msk = 0x8
	// Bit EOSR03.
	PORT1_EOSR_EOSR03 = 0x8
	// No effect on output
	PORT1_EOSR_EOSR03_0 = 0x0
	// High output
	PORT1_EOSR_EOSR03_1 = 0x1
	// Position of EOSR04 field.
	PORT1_EOSR_EOSR04_Pos = 0x4
	// Bit mask of EOSR04 field.
	PORT1_EOSR_EOSR04_Msk = 0x10
	// Bit EOSR04.
	PORT1_EOSR_EOSR04 = 0x10
	// No effect on output
	PORT1_EOSR_EOSR04_0 = 0x0
	// High output
	PORT1_EOSR_EOSR04_1 = 0x1
	// Position of EOSR05 field.
	PORT1_EOSR_EOSR05_Pos = 0x5
	// Bit mask of EOSR05 field.
	PORT1_EOSR_EOSR05_Msk = 0x20
	// Bit EOSR05.
	PORT1_EOSR_EOSR05 = 0x20
	// No effect on output
	PORT1_EOSR_EOSR05_0 = 0x0
	// High output
	PORT1_EOSR_EOSR05_1 = 0x1
	// Position of EOSR06 field.
	PORT1_EOSR_EOSR06_Pos = 0x6
	// Bit mask of EOSR06 field.
	PORT1_EOSR_EOSR06_Msk = 0x40
	// Bit EOSR06.
	PORT1_EOSR_EOSR06 = 0x40
	// No effect on output
	PORT1_EOSR_EOSR06_0 = 0x0
	// High output
	PORT1_EOSR_EOSR06_1 = 0x1
	// Position of EOSR07 field.
	PORT1_EOSR_EOSR07_Pos = 0x7
	// Bit mask of EOSR07 field.
	PORT1_EOSR_EOSR07_Msk = 0x80
	// Bit EOSR07.
	PORT1_EOSR_EOSR07 = 0x80
	// No effect on output
	PORT1_EOSR_EOSR07_0 = 0x0
	// High output
	PORT1_EOSR_EOSR07_1 = 0x1
	// Position of EOSR08 field.
	PORT1_EOSR_EOSR08_Pos = 0x8
	// Bit mask of EOSR08 field.
	PORT1_EOSR_EOSR08_Msk = 0x100
	// Bit EOSR08.
	PORT1_EOSR_EOSR08 = 0x100
	// No effect on output
	PORT1_EOSR_EOSR08_0 = 0x0
	// High output
	PORT1_EOSR_EOSR08_1 = 0x1
	// Position of EOSR09 field.
	PORT1_EOSR_EOSR09_Pos = 0x9
	// Bit mask of EOSR09 field.
	PORT1_EOSR_EOSR09_Msk = 0x200
	// Bit EOSR09.
	PORT1_EOSR_EOSR09 = 0x200
	// No effect on output
	PORT1_EOSR_EOSR09_0 = 0x0
	// High output
	PORT1_EOSR_EOSR09_1 = 0x1
	// Position of EOSR10 field.
	PORT1_EOSR_EOSR10_Pos = 0xa
	// Bit mask of EOSR10 field.
	PORT1_EOSR_EOSR10_Msk = 0x400
	// Bit EOSR10.
	PORT1_EOSR_EOSR10 = 0x400
	// No effect on output
	PORT1_EOSR_EOSR10_0 = 0x0
	// High output
	PORT1_EOSR_EOSR10_1 = 0x1
	// Position of EOSR11 field.
	PORT1_EOSR_EOSR11_Pos = 0xb
	// Bit mask of EOSR11 field.
	PORT1_EOSR_EOSR11_Msk = 0x800
	// Bit EOSR11.
	PORT1_EOSR_EOSR11 = 0x800
	// No effect on output
	PORT1_EOSR_EOSR11_0 = 0x0
	// High output
	PORT1_EOSR_EOSR11_1 = 0x1
	// Position of EOSR12 field.
	PORT1_EOSR_EOSR12_Pos = 0xc
	// Bit mask of EOSR12 field.
	PORT1_EOSR_EOSR12_Msk = 0x1000
	// Bit EOSR12.
	PORT1_EOSR_EOSR12 = 0x1000
	// No effect on output
	PORT1_EOSR_EOSR12_0 = 0x0
	// High output
	PORT1_EOSR_EOSR12_1 = 0x1
	// Position of EOSR13 field.
	PORT1_EOSR_EOSR13_Pos = 0xd
	// Bit mask of EOSR13 field.
	PORT1_EOSR_EOSR13_Msk = 0x2000
	// Bit EOSR13.
	PORT1_EOSR_EOSR13 = 0x2000
	// No effect on output
	PORT1_EOSR_EOSR13_0 = 0x0
	// High output
	PORT1_EOSR_EOSR13_1 = 0x1
	// Position of EOSR14 field.
	PORT1_EOSR_EOSR14_Pos = 0xe
	// Bit mask of EOSR14 field.
	PORT1_EOSR_EOSR14_Msk = 0x4000
	// Bit EOSR14.
	PORT1_EOSR_EOSR14 = 0x4000
	// No effect on output
	PORT1_EOSR_EOSR14_0 = 0x0
	// High output
	PORT1_EOSR_EOSR14_1 = 0x1
	// Position of EOSR15 field.
	PORT1_EOSR_EOSR15_Pos = 0xf
	// Bit mask of EOSR15 field.
	PORT1_EOSR_EOSR15_Msk = 0x8000
	// Bit EOSR15.
	PORT1_EOSR_EOSR15 = 0x8000
	// No effect on output
	PORT1_EOSR_EOSR15_0 = 0x0
	// High output
	PORT1_EOSR_EOSR15_1 = 0x1
)

// Constants for PFS: Pmn Pin Function Control Register
const (
	// P000PFS: Port 00%s Pin Function Select Register
	// Position of PODR field.
	PFS_P00PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P00PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P00PFS_PODR = 0x1
	// Output low
	PFS_P00PFS_PODR_0 = 0x0
	// Output high
	PFS_P00PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P00PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P00PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P00PFS_PIDR = 0x2
	// Low level
	PFS_P00PFS_PIDR_0 = 0x0
	// High level
	PFS_P00PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P00PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P00PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P00PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P00PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P00PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P00PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P00PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P00PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P00PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P00PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P00PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P00PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P00PFS_NCODR = 0x40
	// Output CMOS
	PFS_P00PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P00PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P00PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P00PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P00PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P00PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P00PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P00PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P00PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P00PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P00PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P00PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P00PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P00PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P00PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P00PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P00PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P00PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P00PFS_PSEL_Msk = 0x1f000000

	// P000PFS_HA: Port 00%s Pin Function Select Register
	// Position of PODR field.
	PFS_P00PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P00PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P00PFS_HA_PODR = 0x1
	// Output low
	PFS_P00PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P00PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P00PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P00PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P00PFS_HA_PIDR = 0x2
	// Low level
	PFS_P00PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P00PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P00PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P00PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P00PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P00PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P00PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P00PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P00PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P00PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P00PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P00PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P00PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P00PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P00PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P00PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P00PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P00PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P00PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P00PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P00PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P00PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P00PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P00PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P00PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P00PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P00PFS_HA_ASEL_1 = 0x1

	// P000PFS_BY: Port 00%s Pin Function Select Register
	// Position of PODR field.
	PFS_P00PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P00PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P00PFS_BY_PODR = 0x1
	// Output low
	PFS_P00PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P00PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P00PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P00PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P00PFS_BY_PIDR = 0x2
	// Low level
	PFS_P00PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P00PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P00PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P00PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P00PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P00PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P00PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P00PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P00PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P00PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P00PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P00PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P00PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P00PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P00PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P00PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P00PFS_BY_NCODR_1 = 0x1

	// P010PFS: Port 0%s Pin Function Select Register
	// Position of PODR field.
	PFS_P0PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P0PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P0PFS_PODR = 0x1
	// Output low
	PFS_P0PFS_PODR_0 = 0x0
	// Output high
	PFS_P0PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P0PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P0PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P0PFS_PIDR = 0x2
	// Low level
	PFS_P0PFS_PIDR_0 = 0x0
	// High level
	PFS_P0PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P0PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P0PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P0PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P0PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P0PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P0PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P0PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P0PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P0PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P0PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P0PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P0PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P0PFS_NCODR = 0x40
	// Output CMOS
	PFS_P0PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P0PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P0PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P0PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P0PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P0PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P0PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P0PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P0PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P0PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P0PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P0PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P0PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P0PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P0PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P0PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P0PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P0PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P0PFS_PSEL_Msk = 0x1f000000

	// P010PFS_HA: Port 0%s Pin Function Select Register
	// Position of PODR field.
	PFS_P0PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P0PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P0PFS_HA_PODR = 0x1
	// Output low
	PFS_P0PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P0PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P0PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P0PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P0PFS_HA_PIDR = 0x2
	// Low level
	PFS_P0PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P0PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P0PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P0PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P0PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P0PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P0PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P0PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P0PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P0PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P0PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P0PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P0PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P0PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P0PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P0PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P0PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P0PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P0PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P0PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P0PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P0PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P0PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P0PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P0PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P0PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P0PFS_HA_ASEL_1 = 0x1

	// P010PFS_BY: Port 0%s Pin Function Select Register
	// Position of PODR field.
	PFS_P0PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P0PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P0PFS_BY_PODR = 0x1
	// Output low
	PFS_P0PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P0PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P0PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P0PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P0PFS_BY_PIDR = 0x2
	// Low level
	PFS_P0PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P0PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P0PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P0PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P0PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P0PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P0PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P0PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P0PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P0PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P0PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P0PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P0PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P0PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P0PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P0PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P0PFS_BY_NCODR_1 = 0x1

	// P100PFS: Port 10%s Pin Function Select Register
	// Position of PODR field.
	PFS_P10PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P10PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P10PFS_PODR = 0x1
	// Output low
	PFS_P10PFS_PODR_0 = 0x0
	// Output high
	PFS_P10PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P10PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P10PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P10PFS_PIDR = 0x2
	// Low level
	PFS_P10PFS_PIDR_0 = 0x0
	// High level
	PFS_P10PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P10PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P10PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P10PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P10PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P10PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P10PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P10PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P10PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P10PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P10PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P10PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P10PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P10PFS_NCODR = 0x40
	// Output CMOS
	PFS_P10PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P10PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P10PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P10PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P10PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P10PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P10PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P10PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P10PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P10PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P10PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P10PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P10PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P10PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P10PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P10PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P10PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P10PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P10PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P10PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P10PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P10PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P10PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P10PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P10PFS_PSEL_Msk = 0x1f000000

	// P100PFS_HA: Port 10%s Pin Function Select Register
	// Position of PODR field.
	PFS_P10PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P10PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P10PFS_HA_PODR = 0x1
	// Output low
	PFS_P10PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P10PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P10PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P10PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P10PFS_HA_PIDR = 0x2
	// Low level
	PFS_P10PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P10PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P10PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P10PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P10PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P10PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P10PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P10PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P10PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P10PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P10PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P10PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P10PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P10PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P10PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P10PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P10PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P10PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P10PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P10PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P10PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P10PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P10PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P10PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P10PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P10PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P10PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P10PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P10PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P10PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P10PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P10PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P10PFS_HA_ASEL_1 = 0x1

	// P100PFS_BY: Port 10%s Pin Function Select Register
	// Position of PODR field.
	PFS_P10PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P10PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P10PFS_BY_PODR = 0x1
	// Output low
	PFS_P10PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P10PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P10PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P10PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P10PFS_BY_PIDR = 0x2
	// Low level
	PFS_P10PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P10PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P10PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P10PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P10PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P10PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P10PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P10PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P10PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P10PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P10PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P10PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P10PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P10PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P10PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P10PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P10PFS_BY_NCODR_1 = 0x1

	// P108PFS: Port 108 Pin Function Select Register
	// Position of PODR field.
	PFS_P108PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P108PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P108PFS_PODR = 0x1
	// Output low
	PFS_P108PFS_PODR_0 = 0x0
	// Output high
	PFS_P108PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P108PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P108PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P108PFS_PIDR = 0x2
	// Low level
	PFS_P108PFS_PIDR_0 = 0x0
	// High level
	PFS_P108PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P108PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P108PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P108PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P108PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P108PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P108PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P108PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P108PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P108PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P108PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P108PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P108PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P108PFS_NCODR = 0x40
	// Output CMOS
	PFS_P108PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P108PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P108PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P108PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P108PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P108PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P108PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P108PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P108PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P108PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P108PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P108PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P108PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P108PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P108PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P108PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P108PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P108PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P108PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P108PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P108PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P108PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P108PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P108PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P108PFS_PSEL_Msk = 0x1f000000

	// P108PFS_HA: Port 108 Pin Function Select Register
	// Position of PODR field.
	PFS_P108PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P108PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P108PFS_HA_PODR = 0x1
	// Output low
	PFS_P108PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P108PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P108PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P108PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P108PFS_HA_PIDR = 0x2
	// Low level
	PFS_P108PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P108PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P108PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P108PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P108PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P108PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P108PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P108PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P108PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P108PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P108PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P108PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P108PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P108PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P108PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P108PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P108PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P108PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P108PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P108PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P108PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P108PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P108PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P108PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P108PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P108PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P108PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P108PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P108PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P108PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P108PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P108PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P108PFS_HA_ASEL_1 = 0x1

	// P108PFS_BY: Port 108 Pin Function Select Register
	// Position of PODR field.
	PFS_P108PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P108PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P108PFS_BY_PODR = 0x1
	// Output low
	PFS_P108PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P108PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P108PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P108PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P108PFS_BY_PIDR = 0x2
	// Low level
	PFS_P108PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P108PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P108PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P108PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P108PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P108PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P108PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P108PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P108PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P108PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P108PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P108PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P108PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P108PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P108PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P108PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P108PFS_BY_NCODR_1 = 0x1

	// P109PFS: Port 109 Pin Function Select Register
	// Position of PODR field.
	PFS_P109PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P109PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P109PFS_PODR = 0x1
	// Output low
	PFS_P109PFS_PODR_0 = 0x0
	// Output high
	PFS_P109PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P109PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P109PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P109PFS_PIDR = 0x2
	// Low level
	PFS_P109PFS_PIDR_0 = 0x0
	// High level
	PFS_P109PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P109PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P109PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P109PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P109PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P109PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P109PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P109PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P109PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P109PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P109PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P109PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P109PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P109PFS_NCODR = 0x40
	// Output CMOS
	PFS_P109PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P109PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P109PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P109PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P109PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P109PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P109PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P109PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P109PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P109PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P109PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P109PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P109PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P109PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P109PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P109PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P109PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P109PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P109PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P109PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P109PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P109PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P109PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P109PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P109PFS_PSEL_Msk = 0x1f000000

	// P109PFS_HA: Port 109 Pin Function Select Register
	// Position of PODR field.
	PFS_P109PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P109PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P109PFS_HA_PODR = 0x1
	// Output low
	PFS_P109PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P109PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P109PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P109PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P109PFS_HA_PIDR = 0x2
	// Low level
	PFS_P109PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P109PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P109PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P109PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P109PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P109PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P109PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P109PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P109PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P109PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P109PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P109PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P109PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P109PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P109PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P109PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P109PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P109PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P109PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P109PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P109PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P109PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P109PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P109PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P109PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P109PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P109PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P109PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P109PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P109PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P109PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P109PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P109PFS_HA_ASEL_1 = 0x1

	// P109PFS_BY: Port 109 Pin Function Select Register
	// Position of PODR field.
	PFS_P109PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P109PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P109PFS_BY_PODR = 0x1
	// Output low
	PFS_P109PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P109PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P109PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P109PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P109PFS_BY_PIDR = 0x2
	// Low level
	PFS_P109PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P109PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P109PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P109PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P109PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P109PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P109PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P109PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P109PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P109PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P109PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P109PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P109PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P109PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P109PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P109PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P109PFS_BY_NCODR_1 = 0x1

	// P110PFS: Port 1%s Pin Function Select Register
	// Position of PODR field.
	PFS_P1PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P1PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P1PFS_PODR = 0x1
	// Output low
	PFS_P1PFS_PODR_0 = 0x0
	// Output high
	PFS_P1PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P1PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P1PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P1PFS_PIDR = 0x2
	// Low level
	PFS_P1PFS_PIDR_0 = 0x0
	// High level
	PFS_P1PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P1PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P1PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P1PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P1PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P1PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P1PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P1PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P1PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P1PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P1PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P1PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P1PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P1PFS_NCODR = 0x40
	// Output CMOS
	PFS_P1PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P1PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P1PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P1PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P1PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P1PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P1PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P1PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P1PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P1PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P1PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P1PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P1PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P1PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P1PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P1PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P1PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P1PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P1PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P1PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P1PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P1PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P1PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P1PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P1PFS_PSEL_Msk = 0x1f000000

	// P110PFS_HA: Port 1%s Pin Function Select Register
	// Position of PODR field.
	PFS_P1PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P1PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P1PFS_HA_PODR = 0x1
	// Output low
	PFS_P1PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P1PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P1PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P1PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P1PFS_HA_PIDR = 0x2
	// Low level
	PFS_P1PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P1PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P1PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P1PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P1PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P1PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P1PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P1PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P1PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P1PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P1PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P1PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P1PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P1PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P1PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P1PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P1PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P1PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P1PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P1PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P1PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P1PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P1PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P1PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P1PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P1PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P1PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P1PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P1PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P1PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P1PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P1PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P1PFS_HA_ASEL_1 = 0x1

	// P110PFS_BY: Port 1%s Pin Function Select Register
	// Position of PODR field.
	PFS_P1PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P1PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P1PFS_BY_PODR = 0x1
	// Output low
	PFS_P1PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P1PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P1PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P1PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P1PFS_BY_PIDR = 0x2
	// Low level
	PFS_P1PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P1PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P1PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P1PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P1PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P1PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P1PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P1PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P1PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P1PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P1PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P1PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P1PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P1PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P1PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P1PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P1PFS_BY_NCODR_1 = 0x1

	// P200PFS: Port 200 Pin Function Select Register
	// Position of PODR field.
	PFS_P200PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P200PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P200PFS_PODR = 0x1
	// Output low
	PFS_P200PFS_PODR_0 = 0x0
	// Output high
	PFS_P200PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P200PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P200PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P200PFS_PIDR = 0x2
	// Low level
	PFS_P200PFS_PIDR_0 = 0x0
	// High level
	PFS_P200PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P200PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P200PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P200PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P200PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P200PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P200PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P200PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P200PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P200PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P200PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P200PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P200PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P200PFS_NCODR = 0x40
	// Output CMOS
	PFS_P200PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P200PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P200PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P200PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P200PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P200PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P200PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P200PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P200PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P200PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P200PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P200PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P200PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P200PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P200PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P200PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P200PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P200PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P200PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P200PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P200PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P200PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P200PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P200PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P200PFS_PSEL_Msk = 0x1f000000

	// P200PFS_HA: Port 200 Pin Function Select Register
	// Position of PODR field.
	PFS_P200PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P200PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P200PFS_HA_PODR = 0x1
	// Output low
	PFS_P200PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P200PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P200PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P200PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P200PFS_HA_PIDR = 0x2
	// Low level
	PFS_P200PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P200PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P200PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P200PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P200PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P200PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P200PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P200PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P200PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P200PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P200PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P200PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P200PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P200PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P200PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P200PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P200PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P200PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P200PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P200PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P200PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P200PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P200PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P200PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P200PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P200PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P200PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P200PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P200PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P200PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P200PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P200PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P200PFS_HA_ASEL_1 = 0x1

	// P200PFS_BY: Port 200 Pin Function Select Register
	// Position of PODR field.
	PFS_P200PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P200PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P200PFS_BY_PODR = 0x1
	// Output low
	PFS_P200PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P200PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P200PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P200PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P200PFS_BY_PIDR = 0x2
	// Low level
	PFS_P200PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P200PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P200PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P200PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P200PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P200PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P200PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P200PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P200PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P200PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P200PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P200PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P200PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P200PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P200PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P200PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P200PFS_BY_NCODR_1 = 0x1

	// P201PFS: Port 201 Pin Function Select Register
	// Position of PODR field.
	PFS_P201PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P201PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P201PFS_PODR = 0x1
	// Output low
	PFS_P201PFS_PODR_0 = 0x0
	// Output high
	PFS_P201PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P201PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P201PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P201PFS_PIDR = 0x2
	// Low level
	PFS_P201PFS_PIDR_0 = 0x0
	// High level
	PFS_P201PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P201PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P201PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P201PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P201PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P201PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P201PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P201PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P201PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P201PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P201PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P201PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P201PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P201PFS_NCODR = 0x40
	// Output CMOS
	PFS_P201PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P201PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P201PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P201PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P201PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P201PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P201PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P201PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P201PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P201PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P201PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P201PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P201PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P201PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P201PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P201PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P201PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P201PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P201PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P201PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P201PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P201PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P201PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P201PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P201PFS_PSEL_Msk = 0x1f000000

	// P201PFS_HA: Port 201 Pin Function Select Register
	// Position of PODR field.
	PFS_P201PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P201PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P201PFS_HA_PODR = 0x1
	// Output low
	PFS_P201PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P201PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P201PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P201PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P201PFS_HA_PIDR = 0x2
	// Low level
	PFS_P201PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P201PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P201PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P201PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P201PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P201PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P201PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P201PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P201PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P201PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P201PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P201PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P201PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P201PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P201PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P201PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P201PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P201PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P201PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P201PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P201PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P201PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P201PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P201PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P201PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P201PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P201PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P201PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P201PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P201PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P201PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P201PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P201PFS_HA_ASEL_1 = 0x1

	// P201PFS_BY: Port 201 Pin Function Select Register
	// Position of PODR field.
	PFS_P201PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P201PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P201PFS_BY_PODR = 0x1
	// Output low
	PFS_P201PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P201PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P201PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P201PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P201PFS_BY_PIDR = 0x2
	// Low level
	PFS_P201PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P201PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P201PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P201PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P201PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P201PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P201PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P201PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P201PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P201PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P201PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P201PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P201PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P201PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P201PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P201PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P201PFS_BY_NCODR_1 = 0x1

	// P202PFS: Port 20%s Pin Function Select Register
	// Position of PODR field.
	PFS_P20PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P20PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P20PFS_PODR = 0x1
	// Output low
	PFS_P20PFS_PODR_0 = 0x0
	// Output high
	PFS_P20PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P20PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P20PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P20PFS_PIDR = 0x2
	// Low level
	PFS_P20PFS_PIDR_0 = 0x0
	// High level
	PFS_P20PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P20PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P20PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P20PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P20PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P20PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P20PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P20PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P20PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P20PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P20PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P20PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P20PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P20PFS_NCODR = 0x40
	// Output CMOS
	PFS_P20PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P20PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P20PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P20PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P20PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P20PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P20PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P20PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P20PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P20PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P20PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P20PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P20PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P20PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P20PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P20PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P20PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P20PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P20PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P20PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P20PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P20PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P20PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P20PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P20PFS_PSEL_Msk = 0x1f000000

	// P202PFS_HA: Port 20%s Pin Function Select Register
	// Position of PODR field.
	PFS_P20PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P20PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P20PFS_HA_PODR = 0x1
	// Output low
	PFS_P20PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P20PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P20PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P20PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P20PFS_HA_PIDR = 0x2
	// Low level
	PFS_P20PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P20PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P20PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P20PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P20PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P20PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P20PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P20PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P20PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P20PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P20PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P20PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P20PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P20PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P20PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P20PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P20PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P20PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P20PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P20PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P20PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P20PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P20PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P20PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P20PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P20PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P20PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P20PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P20PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P20PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P20PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P20PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P20PFS_HA_ASEL_1 = 0x1

	// P202PFS_BY: Port 20%s Pin Function Select Register
	// Position of PODR field.
	PFS_P20PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P20PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P20PFS_BY_PODR = 0x1
	// Output low
	PFS_P20PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P20PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P20PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P20PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P20PFS_BY_PIDR = 0x2
	// Low level
	PFS_P20PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P20PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P20PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P20PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P20PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P20PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P20PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P20PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P20PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P20PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P20PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P20PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P20PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P20PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P20PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P20PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P20PFS_BY_NCODR_1 = 0x1

	// P212PFS: Port 2%s Pin Function Select Register
	// Position of PODR field.
	PFS_P2PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P2PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P2PFS_PODR = 0x1
	// Output low
	PFS_P2PFS_PODR_0 = 0x0
	// Output high
	PFS_P2PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P2PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P2PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P2PFS_PIDR = 0x2
	// Low level
	PFS_P2PFS_PIDR_0 = 0x0
	// High level
	PFS_P2PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P2PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P2PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P2PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P2PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P2PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P2PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P2PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P2PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P2PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P2PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P2PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P2PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P2PFS_NCODR = 0x40
	// Output CMOS
	PFS_P2PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P2PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P2PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P2PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P2PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P2PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P2PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P2PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P2PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P2PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P2PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P2PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P2PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P2PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P2PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P2PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P2PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P2PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P2PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P2PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P2PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P2PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P2PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P2PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P2PFS_PSEL_Msk = 0x1f000000

	// P212PFS_HA: Port 2%s Pin Function Select Register
	// Position of PODR field.
	PFS_P2PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P2PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P2PFS_HA_PODR = 0x1
	// Output low
	PFS_P2PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P2PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P2PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P2PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P2PFS_HA_PIDR = 0x2
	// Low level
	PFS_P2PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P2PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P2PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P2PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P2PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P2PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P2PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P2PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P2PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P2PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P2PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P2PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P2PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P2PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P2PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P2PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P2PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P2PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P2PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P2PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P2PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P2PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P2PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P2PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P2PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P2PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P2PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P2PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P2PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P2PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P2PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P2PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P2PFS_HA_ASEL_1 = 0x1

	// P212PFS_BY: Port 2%s Pin Function Select Register
	// Position of PODR field.
	PFS_P2PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P2PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P2PFS_BY_PODR = 0x1
	// Output low
	PFS_P2PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P2PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P2PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P2PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P2PFS_BY_PIDR = 0x2
	// Low level
	PFS_P2PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P2PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P2PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P2PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P2PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P2PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P2PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P2PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P2PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P2PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P2PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P2PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P2PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P2PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P2PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P2PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P2PFS_BY_NCODR_1 = 0x1

	// P300PFS: Port 300 Pin Function Select Register
	// Position of PODR field.
	PFS_P300PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P300PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P300PFS_PODR = 0x1
	// Output low
	PFS_P300PFS_PODR_0 = 0x0
	// Output high
	PFS_P300PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P300PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P300PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P300PFS_PIDR = 0x2
	// Low level
	PFS_P300PFS_PIDR_0 = 0x0
	// High level
	PFS_P300PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P300PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P300PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P300PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P300PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P300PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P300PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P300PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P300PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P300PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P300PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P300PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P300PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P300PFS_NCODR = 0x40
	// Output CMOS
	PFS_P300PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P300PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P300PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P300PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P300PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P300PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P300PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P300PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P300PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P300PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P300PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P300PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P300PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P300PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P300PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P300PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P300PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P300PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P300PFS_PSEL_Msk = 0x1f000000

	// P300PFS_HA: Port 300 Pin Function Select Register
	// Position of PODR field.
	PFS_P300PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P300PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P300PFS_HA_PODR = 0x1
	// Output low
	PFS_P300PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P300PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P300PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P300PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P300PFS_HA_PIDR = 0x2
	// Low level
	PFS_P300PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P300PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P300PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P300PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P300PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P300PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P300PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P300PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P300PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P300PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P300PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P300PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P300PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P300PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P300PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P300PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P300PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P300PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P300PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P300PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P300PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P300PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P300PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P300PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P300PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P300PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P300PFS_HA_ASEL_1 = 0x1

	// P300PFS_BY: Port 300 Pin Function Select Register
	// Position of PODR field.
	PFS_P300PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P300PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P300PFS_BY_PODR = 0x1
	// Output low
	PFS_P300PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P300PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P300PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P300PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P300PFS_BY_PIDR = 0x2
	// Low level
	PFS_P300PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P300PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P300PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P300PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P300PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P300PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P300PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P300PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P300PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P300PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P300PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P300PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P300PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P300PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P300PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P300PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P300PFS_BY_NCODR_1 = 0x1

	// P301PFS: Port 30%s Pin Function Select Register
	// Position of PODR field.
	PFS_P30PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P30PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P30PFS_PODR = 0x1
	// Output low
	PFS_P30PFS_PODR_0 = 0x0
	// Output high
	PFS_P30PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P30PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P30PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P30PFS_PIDR = 0x2
	// Low level
	PFS_P30PFS_PIDR_0 = 0x0
	// High level
	PFS_P30PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P30PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P30PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P30PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P30PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P30PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P30PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P30PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P30PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P30PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P30PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P30PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P30PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P30PFS_NCODR = 0x40
	// Output CMOS
	PFS_P30PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P30PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P30PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P30PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P30PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P30PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P30PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P30PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P30PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P30PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P30PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P30PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P30PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P30PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P30PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P30PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P30PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P30PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P30PFS_PSEL_Msk = 0x1f000000

	// P301PFS_HA: Port 30%s Pin Function Select Register
	// Position of PODR field.
	PFS_P30PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P30PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P30PFS_HA_PODR = 0x1
	// Output low
	PFS_P30PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P30PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P30PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P30PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P30PFS_HA_PIDR = 0x2
	// Low level
	PFS_P30PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P30PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P30PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P30PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P30PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P30PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P30PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P30PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P30PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P30PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P30PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P30PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P30PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P30PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P30PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P30PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P30PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P30PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P30PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P30PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P30PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P30PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P30PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P30PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P30PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P30PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P30PFS_HA_ASEL_1 = 0x1

	// P301PFS_BY: Port 30%s Pin Function Select Register
	// Position of PODR field.
	PFS_P30PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P30PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P30PFS_BY_PODR = 0x1
	// Output low
	PFS_P30PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P30PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P30PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P30PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P30PFS_BY_PIDR = 0x2
	// Low level
	PFS_P30PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P30PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P30PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P30PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P30PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P30PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P30PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P30PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P30PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P30PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P30PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P30PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P30PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P30PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P30PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P30PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P30PFS_BY_NCODR_1 = 0x1

	// P400PFS: Port 40%s Pin Function Select Register
	// Position of PODR field.
	PFS_P40PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P40PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P40PFS_PODR = 0x1
	// Output low
	PFS_P40PFS_PODR_0 = 0x0
	// Output high
	PFS_P40PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P40PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P40PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P40PFS_PIDR = 0x2
	// Low level
	PFS_P40PFS_PIDR_0 = 0x0
	// High level
	PFS_P40PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P40PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P40PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P40PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P40PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P40PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P40PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P40PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P40PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P40PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P40PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P40PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P40PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P40PFS_NCODR = 0x40
	// Output CMOS
	PFS_P40PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P40PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P40PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P40PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P40PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P40PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P40PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P40PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P40PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P40PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P40PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P40PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P40PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P40PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P40PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P40PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P40PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P40PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P40PFS_PSEL_Msk = 0x1f000000

	// P400PFS_HA: Port 40%s Pin Function Select Register
	// Position of PODR field.
	PFS_P40PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P40PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P40PFS_HA_PODR = 0x1
	// Output low
	PFS_P40PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P40PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P40PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P40PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P40PFS_HA_PIDR = 0x2
	// Low level
	PFS_P40PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P40PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P40PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P40PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P40PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P40PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P40PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P40PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P40PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P40PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P40PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P40PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P40PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P40PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P40PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P40PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P40PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P40PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P40PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P40PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P40PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P40PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P40PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P40PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P40PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P40PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P40PFS_HA_ASEL_1 = 0x1

	// P400PFS_BY: Port 40%s Pin Function Select Register
	// Position of PODR field.
	PFS_P40PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P40PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P40PFS_BY_PODR = 0x1
	// Output low
	PFS_P40PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P40PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P40PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P40PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P40PFS_BY_PIDR = 0x2
	// Low level
	PFS_P40PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P40PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P40PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P40PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P40PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P40PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P40PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P40PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P40PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P40PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P40PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P40PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P40PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P40PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P40PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P40PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P40PFS_BY_NCODR_1 = 0x1

	// P410PFS: Port 4%s Pin Function Select Register
	// Position of PODR field.
	PFS_P4PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P4PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P4PFS_PODR = 0x1
	// Output low
	PFS_P4PFS_PODR_0 = 0x0
	// Output high
	PFS_P4PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P4PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P4PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P4PFS_PIDR = 0x2
	// Low level
	PFS_P4PFS_PIDR_0 = 0x0
	// High level
	PFS_P4PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P4PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P4PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P4PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P4PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P4PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P4PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P4PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P4PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P4PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P4PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P4PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P4PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P4PFS_NCODR = 0x40
	// Output CMOS
	PFS_P4PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P4PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P4PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P4PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P4PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P4PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P4PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P4PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P4PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P4PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P4PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P4PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P4PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P4PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P4PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P4PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P4PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P4PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P4PFS_PSEL_Msk = 0x1f000000

	// P410PFS_HA: Port 4%s Pin Function Select Register
	// Position of PODR field.
	PFS_P4PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P4PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P4PFS_HA_PODR = 0x1
	// Output low
	PFS_P4PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P4PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P4PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P4PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P4PFS_HA_PIDR = 0x2
	// Low level
	PFS_P4PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P4PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P4PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P4PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P4PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P4PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P4PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P4PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P4PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P4PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P4PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P4PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P4PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P4PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P4PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P4PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P4PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P4PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P4PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P4PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P4PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P4PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P4PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P4PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P4PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P4PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P4PFS_HA_ASEL_1 = 0x1

	// P410PFS_BY: Port 4%s Pin Function Select Register
	// Position of PODR field.
	PFS_P4PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P4PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P4PFS_BY_PODR = 0x1
	// Output low
	PFS_P4PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P4PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P4PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P4PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P4PFS_BY_PIDR = 0x2
	// Low level
	PFS_P4PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P4PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P4PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P4PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P4PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P4PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P4PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P4PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P4PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P4PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P4PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P4PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P4PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P4PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P4PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P4PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P4PFS_BY_NCODR_1 = 0x1

	// P500PFS: Port 50%s Pin Function Select Register
	// Position of PODR field.
	PFS_P50PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P50PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P50PFS_PODR = 0x1
	// Output low
	PFS_P50PFS_PODR_0 = 0x0
	// Output high
	PFS_P50PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P50PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P50PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P50PFS_PIDR = 0x2
	// Low level
	PFS_P50PFS_PIDR_0 = 0x0
	// High level
	PFS_P50PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P50PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P50PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P50PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P50PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P50PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P50PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P50PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P50PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P50PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P50PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P50PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P50PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P50PFS_NCODR = 0x40
	// Output CMOS
	PFS_P50PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P50PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P50PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P50PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P50PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P50PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P50PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P50PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P50PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P50PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P50PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P50PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P50PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P50PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P50PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P50PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P50PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P50PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P50PFS_PSEL_Msk = 0x1f000000

	// P500PFS_HA: Port 50%s Pin Function Select Register
	// Position of PODR field.
	PFS_P50PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P50PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P50PFS_HA_PODR = 0x1
	// Output low
	PFS_P50PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P50PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P50PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P50PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P50PFS_HA_PIDR = 0x2
	// Low level
	PFS_P50PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P50PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P50PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P50PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P50PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P50PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P50PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P50PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P50PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P50PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P50PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P50PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P50PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P50PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P50PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P50PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P50PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P50PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P50PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P50PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P50PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P50PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P50PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P50PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P50PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P50PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P50PFS_HA_ASEL_1 = 0x1

	// P500PFS_BY: Port 50%s Pin Function Select Register
	// Position of PODR field.
	PFS_P50PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P50PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P50PFS_BY_PODR = 0x1
	// Output low
	PFS_P50PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P50PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P50PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P50PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P50PFS_BY_PIDR = 0x2
	// Low level
	PFS_P50PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P50PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P50PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P50PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P50PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P50PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P50PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P50PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P50PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P50PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P50PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P50PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P50PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P50PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P50PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P50PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P50PFS_BY_NCODR_1 = 0x1

	// P600PFS: Port 60%s Pin Function Select Register
	// Position of PODR field.
	PFS_P60PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P60PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P60PFS_PODR = 0x1
	// Output low
	PFS_P60PFS_PODR_0 = 0x0
	// Output high
	PFS_P60PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P60PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P60PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P60PFS_PIDR = 0x2
	// Low level
	PFS_P60PFS_PIDR_0 = 0x0
	// High level
	PFS_P60PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P60PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P60PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P60PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P60PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P60PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P60PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P60PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P60PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P60PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P60PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P60PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P60PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P60PFS_NCODR = 0x40
	// Output CMOS
	PFS_P60PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P60PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P60PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P60PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P60PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P60PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P60PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P60PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P60PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P60PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P60PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P60PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P60PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P60PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P60PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P60PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P60PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P60PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P60PFS_PSEL_Msk = 0x1f000000

	// P600PFS_HA: Port 60%s Pin Function Select Register
	// Position of PODR field.
	PFS_P60PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P60PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P60PFS_HA_PODR = 0x1
	// Output low
	PFS_P60PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P60PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P60PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P60PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P60PFS_HA_PIDR = 0x2
	// Low level
	PFS_P60PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P60PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P60PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P60PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P60PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P60PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P60PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P60PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P60PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P60PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P60PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P60PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P60PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P60PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P60PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P60PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P60PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P60PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P60PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P60PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P60PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P60PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P60PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P60PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P60PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P60PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P60PFS_HA_ASEL_1 = 0x1

	// P600PFS_BY: Port 60%s Pin Function Select Register
	// Position of PODR field.
	PFS_P60PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P60PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P60PFS_BY_PODR = 0x1
	// Output low
	PFS_P60PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P60PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P60PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P60PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P60PFS_BY_PIDR = 0x2
	// Low level
	PFS_P60PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P60PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P60PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P60PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P60PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P60PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P60PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P60PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P60PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P60PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P60PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P60PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P60PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P60PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P60PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P60PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P60PFS_BY_NCODR_1 = 0x1

	// P608PFS: Port 60%s Pin Function Select Register
	// Position of PODR field.
	PFS_P60PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P60PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P60PFS_PODR = 0x1
	// Output low
	PFS_P60PFS_PODR_0 = 0x0
	// Output high
	PFS_P60PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P60PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P60PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P60PFS_PIDR = 0x2
	// Low level
	PFS_P60PFS_PIDR_0 = 0x0
	// High level
	PFS_P60PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P60PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P60PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P60PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P60PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P60PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P60PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P60PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P60PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P60PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P60PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P60PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P60PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P60PFS_NCODR = 0x40
	// Output CMOS
	PFS_P60PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P60PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P60PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P60PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P60PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P60PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P60PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P60PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P60PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P60PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P60PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P60PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P60PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P60PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P60PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P60PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P60PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P60PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P60PFS_PSEL_Msk = 0x1f000000

	// P608PFS_HA: Port 60%s Pin Function Select Register
	// Position of PODR field.
	PFS_P60PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P60PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P60PFS_HA_PODR = 0x1
	// Output low
	PFS_P60PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P60PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P60PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P60PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P60PFS_HA_PIDR = 0x2
	// Low level
	PFS_P60PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P60PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P60PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P60PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P60PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P60PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P60PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P60PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P60PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P60PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P60PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P60PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P60PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P60PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P60PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P60PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P60PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P60PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P60PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P60PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P60PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P60PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P60PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P60PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P60PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P60PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P60PFS_HA_ASEL_1 = 0x1

	// P608PFS_BY: Port 60%s Pin Function Select Register
	// Position of PODR field.
	PFS_P60PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P60PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P60PFS_BY_PODR = 0x1
	// Output low
	PFS_P60PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P60PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P60PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P60PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P60PFS_BY_PIDR = 0x2
	// Low level
	PFS_P60PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P60PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P60PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P60PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P60PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P60PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P60PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P60PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P60PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P60PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P60PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P60PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P60PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P60PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P60PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P60PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P60PFS_BY_NCODR_1 = 0x1

	// P610PFS: Port 610 Pin Function Select Register
	// Position of PODR field.
	PFS_P610PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P610PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P610PFS_PODR = 0x1
	// Output low
	PFS_P610PFS_PODR_0 = 0x0
	// Output high
	PFS_P610PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P610PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P610PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P610PFS_PIDR = 0x2
	// Low level
	PFS_P610PFS_PIDR_0 = 0x0
	// High level
	PFS_P610PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P610PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P610PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P610PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P610PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P610PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P610PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P610PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P610PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P610PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P610PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P610PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P610PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P610PFS_NCODR = 0x40
	// Output CMOS
	PFS_P610PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P610PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P610PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P610PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P610PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P610PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P610PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P610PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P610PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P610PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P610PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P610PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P610PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P610PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P610PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P610PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P610PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P610PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P610PFS_PSEL_Msk = 0x1f000000

	// P610PFS_HA: Port 610 Pin Function Select Register
	// Position of PODR field.
	PFS_P610PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P610PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P610PFS_HA_PODR = 0x1
	// Output low
	PFS_P610PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P610PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P610PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P610PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P610PFS_HA_PIDR = 0x2
	// Low level
	PFS_P610PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P610PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P610PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P610PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P610PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P610PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P610PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P610PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P610PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P610PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P610PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P610PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P610PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P610PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P610PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P610PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P610PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P610PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P610PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P610PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P610PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P610PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P610PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P610PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P610PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P610PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P610PFS_HA_ASEL_1 = 0x1

	// P610PFS_BY: Port 610 Pin Function Select Register
	// Position of PODR field.
	PFS_P610PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P610PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P610PFS_BY_PODR = 0x1
	// Output low
	PFS_P610PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P610PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P610PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P610PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P610PFS_BY_PIDR = 0x2
	// Low level
	PFS_P610PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P610PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P610PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P610PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P610PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P610PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P610PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P610PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P610PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P610PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P610PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P610PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P610PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P610PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P610PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P610PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P610PFS_BY_NCODR_1 = 0x1

	// P708PFS: Port 708 Pin Function Select Register
	// Position of PODR field.
	PFS_P708PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P708PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P708PFS_PODR = 0x1
	// Output low
	PFS_P708PFS_PODR_0 = 0x0
	// Output high
	PFS_P708PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P708PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P708PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P708PFS_PIDR = 0x2
	// Low level
	PFS_P708PFS_PIDR_0 = 0x0
	// High level
	PFS_P708PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P708PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P708PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P708PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P708PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P708PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P708PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P708PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P708PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P708PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P708PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P708PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P708PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P708PFS_NCODR = 0x40
	// Output CMOS
	PFS_P708PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P708PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P708PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P708PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P708PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P708PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P708PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P708PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P708PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P708PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P708PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P708PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P708PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P708PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P708PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P708PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P708PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P708PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P708PFS_PSEL_Msk = 0x1f000000

	// P708PFS_HA: Port 708 Pin Function Select Register
	// Position of PODR field.
	PFS_P708PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P708PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P708PFS_HA_PODR = 0x1
	// Output low
	PFS_P708PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P708PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P708PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P708PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P708PFS_HA_PIDR = 0x2
	// Low level
	PFS_P708PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P708PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P708PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P708PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P708PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P708PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P708PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P708PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P708PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P708PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P708PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P708PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P708PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P708PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P708PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P708PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P708PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P708PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P708PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P708PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P708PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P708PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P708PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P708PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P708PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P708PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P708PFS_HA_ASEL_1 = 0x1

	// P708PFS_BY: Port 708 Pin Function Select Register
	// Position of PODR field.
	PFS_P708PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P708PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P708PFS_BY_PODR = 0x1
	// Output low
	PFS_P708PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P708PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P708PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P708PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P708PFS_BY_PIDR = 0x2
	// Low level
	PFS_P708PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P708PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P708PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P708PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P708PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P708PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P708PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P708PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P708PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P708PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P708PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P708PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P708PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P708PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P708PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P708PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P708PFS_BY_NCODR_1 = 0x1

	// P714PFS: Port 714 Pin Function Select Register
	// Position of PODR field.
	PFS_P714PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P714PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P714PFS_PODR = 0x1
	// Output low
	PFS_P714PFS_PODR_0 = 0x0
	// Output high
	PFS_P714PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P714PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P714PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P714PFS_PIDR = 0x2
	// Low level
	PFS_P714PFS_PIDR_0 = 0x0
	// High level
	PFS_P714PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P714PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P714PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P714PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P714PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P714PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P714PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P714PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P714PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P714PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P714PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P714PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P714PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P714PFS_NCODR = 0x40
	// Output CMOS
	PFS_P714PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P714PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P714PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P714PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P714PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P714PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P714PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P714PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P714PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P714PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P714PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P714PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P714PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P714PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P714PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P714PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P714PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P714PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P714PFS_PSEL_Msk = 0x1f000000

	// P714PFS_HA: Port 714 Pin Function Select Register
	// Position of PODR field.
	PFS_P714PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P714PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P714PFS_HA_PODR = 0x1
	// Output low
	PFS_P714PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P714PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P714PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P714PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P714PFS_HA_PIDR = 0x2
	// Low level
	PFS_P714PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P714PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P714PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P714PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P714PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P714PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P714PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P714PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P714PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P714PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P714PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P714PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P714PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P714PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P714PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P714PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P714PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P714PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P714PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P714PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P714PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P714PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P714PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P714PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P714PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P714PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P714PFS_HA_ASEL_1 = 0x1

	// P714PFS_BY: Port 714 Pin Function Select Register
	// Position of PODR field.
	PFS_P714PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P714PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P714PFS_BY_PODR = 0x1
	// Output low
	PFS_P714PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P714PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P714PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P714PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P714PFS_BY_PIDR = 0x2
	// Low level
	PFS_P714PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P714PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P714PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P714PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P714PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P714PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P714PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P714PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P714PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P714PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P714PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P714PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P714PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P714PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P714PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P714PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P714PFS_BY_NCODR_1 = 0x1

	// P808PFS: Port 80%s Pin Function Select Register
	// Position of PODR field.
	PFS_P80PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P80PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P80PFS_PODR = 0x1
	// Output low
	PFS_P80PFS_PODR_0 = 0x0
	// Output high
	PFS_P80PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P80PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P80PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P80PFS_PIDR = 0x2
	// Low level
	PFS_P80PFS_PIDR_0 = 0x0
	// High level
	PFS_P80PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P80PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P80PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P80PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P80PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P80PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P80PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P80PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P80PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P80PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P80PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P80PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P80PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P80PFS_NCODR = 0x40
	// Output CMOS
	PFS_P80PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P80PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P80PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P80PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P80PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P80PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P80PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P80PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P80PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P80PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P80PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P80PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P80PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P80PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P80PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P80PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P80PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P80PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P80PFS_PSEL_Msk = 0x1f000000

	// P808PFS_HA: Port 80%s Pin Function Select Register
	// Position of PODR field.
	PFS_P80PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P80PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P80PFS_HA_PODR = 0x1
	// Output low
	PFS_P80PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P80PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P80PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P80PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P80PFS_HA_PIDR = 0x2
	// Low level
	PFS_P80PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P80PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P80PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P80PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P80PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P80PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P80PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P80PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P80PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P80PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P80PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P80PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P80PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P80PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P80PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P80PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P80PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P80PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P80PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P80PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P80PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P80PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P80PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P80PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P80PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P80PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P80PFS_HA_ASEL_1 = 0x1

	// P808PFS_BY: Port 80%s Pin Function Select Register
	// Position of PODR field.
	PFS_P80PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P80PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P80PFS_BY_PODR = 0x1
	// Output low
	PFS_P80PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P80PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P80PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P80PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P80PFS_BY_PIDR = 0x2
	// Low level
	PFS_P80PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P80PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P80PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P80PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P80PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P80PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P80PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P80PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P80PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P80PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P80PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P80PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P80PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P80PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P80PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P80PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P80PFS_BY_NCODR_1 = 0x1

	// PWPR: Write-Protect Register
	// Position of PFSWE field.
	PFS_PWPR_PFSWE_Pos = 0x6
	// Bit mask of PFSWE field.
	PFS_PWPR_PFSWE_Msk = 0x40
	// Bit PFSWE.
	PFS_PWPR_PFSWE = 0x40
	// Writing to the PmnPFS register is disabled
	PFS_PWPR_PFSWE_0 = 0x0
	// Writing to the PmnPFS register is enabled
	PFS_PWPR_PFSWE_1 = 0x1
	// Position of B0WI field.
	PFS_PWPR_B0WI_Pos = 0x7
	// Bit mask of B0WI field.
	PFS_PWPR_B0WI_Msk = 0x80
	// Bit B0WI.
	PFS_PWPR_B0WI = 0x80
	// Writing to the PFSWE bit is enabled
	PFS_PWPR_B0WI_0 = 0x0
	// Writing to the PFSWE bit is disabled
	PFS_PWPR_B0WI_1 = 0x1

	// PRWCNTR: Port Read Wait Control Register
	// Position of WAIT field.
	PFS_PRWCNTR_WAIT_Pos = 0x0
	// Bit mask of WAIT field.
	PFS_PRWCNTR_WAIT_Msk = 0x3
	// Setting prohibited
	PFS_PRWCNTR_WAIT_00 = 0x0
	// Insert a 1-cycle wait
	PFS_PRWCNTR_WAIT_01 = 0x1
	// Insert a 2-cycle wait
	PFS_PRWCNTR_WAIT_10 = 0x2
	// Insert a 3-cycle wait
	PFS_PRWCNTR_WAIT_11 = 0x3
)

// Constants for ELC: Event Link Controller
const (
	// ELCR: Event Link Controller Register
	// Position of ELCON field.
	ELC_ELCR_ELCON_Pos = 0x7
	// Bit mask of ELCON field.
	ELC_ELCR_ELCON_Msk = 0x80
	// Bit ELCON.
	ELC_ELCR_ELCON = 0x80
	// ELC function is disabled.
	ELC_ELCR_ELCON_0 = 0x0
	// ELC function is enabled.
	ELC_ELCR_ELCON_1 = 0x1

	// ELSEGR0: Event Link Software Event Generation Register %s
	// Position of SEG field.
	ELC_ELSEGR_SEG_Pos = 0x0
	// Bit mask of SEG field.
	ELC_ELSEGR_SEG_Msk = 0x1
	// Bit SEG.
	ELC_ELSEGR_SEG = 0x1
	// Normal operation
	ELC_ELSEGR_SEG_0 = 0x0
	// Software event is generated.
	ELC_ELSEGR_SEG_1 = 0x1
	// Position of WE field.
	ELC_ELSEGR_WE_Pos = 0x6
	// Bit mask of WE field.
	ELC_ELSEGR_WE_Msk = 0x40
	// Bit WE.
	ELC_ELSEGR_WE = 0x40
	// Write to SEG bit disabled.
	ELC_ELSEGR_WE_0 = 0x0
	// Write to SEG bit enabled.
	ELC_ELSEGR_WE_1 = 0x1
	// Position of WI field.
	ELC_ELSEGR_WI_Pos = 0x7
	// Bit mask of WI field.
	ELC_ELSEGR_WI_Msk = 0x80
	// Bit WI.
	ELC_ELSEGR_WI = 0x80
	// Write to ELSEGR register enabled.
	ELC_ELSEGR_WI_0 = 0x0
	// Write to ELSEGR register disabled.
	ELC_ELSEGR_WI_1 = 0x1

	// ELSR0: Event Link Setting Register %s
	// Position of ELS field.
	ELC_ELSR_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR_ELS_Msk = 0xff

	// ELSR8: Event Link Setting Register %s
	// Position of ELS field.
	ELC_ELSR_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR_ELS_Msk = 0xff

	// ELSR12: Event Link Setting Register 12
	// Position of ELS field.
	ELC_ELSR12_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR12_ELS_Msk = 0xff

	// ELSR14: Event Link Setting Register %s
	// Position of ELS field.
	ELC_ELSR_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR_ELS_Msk = 0xff

	// ELSR18: Event Link Setting Register 18
	// Position of ELS field.
	ELC_ELSR18_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR18_ELS_Msk = 0xff
)

// Constants for POEG: Port Output Enable Module for GPT
const (
	// POEGGA: POEG Group A Setting Register
	// Position of PIDF field.
	POEG_POEGGA_PIDF_Pos = 0x0
	// Bit mask of PIDF field.
	POEG_POEGGA_PIDF_Msk = 0x1
	// Bit PIDF.
	POEG_POEGGA_PIDF = 0x1
	// No output-disable request from the GTETRGn pin occurred
	POEG_POEGGA_PIDF_0 = 0x0
	// Output-disable request from the GTETRGn pin occurred.
	POEG_POEGGA_PIDF_1 = 0x1
	// Position of IOCF field.
	POEG_POEGGA_IOCF_Pos = 0x1
	// Bit mask of IOCF field.
	POEG_POEGGA_IOCF_Msk = 0x2
	// Bit IOCF.
	POEG_POEGGA_IOCF = 0x2
	// No output-disable request from GPT occurred.
	POEG_POEGGA_IOCF_0 = 0x0
	// Output-disable request from GPT occurred.
	POEG_POEGGA_IOCF_1 = 0x1
	// Position of OSTPF field.
	POEG_POEGGA_OSTPF_Pos = 0x2
	// Bit mask of OSTPF field.
	POEG_POEGGA_OSTPF_Msk = 0x4
	// Bit OSTPF.
	POEG_POEGGA_OSTPF = 0x4
	// No output-disable request from oscillation stop detection occurred
	POEG_POEGGA_OSTPF_0 = 0x0
	// Output-disable request from oscillation stop detection occurred
	POEG_POEGGA_OSTPF_1 = 0x1
	// Position of SSF field.
	POEG_POEGGA_SSF_Pos = 0x3
	// Bit mask of SSF field.
	POEG_POEGGA_SSF_Msk = 0x8
	// Bit SSF.
	POEG_POEGGA_SSF = 0x8
	// No output-disable request from software occurred
	POEG_POEGGA_SSF_0 = 0x0
	// Output-disable request from software occurred
	POEG_POEGGA_SSF_1 = 0x1
	// Position of PIDE field.
	POEG_POEGGA_PIDE_Pos = 0x4
	// Bit mask of PIDE field.
	POEG_POEGGA_PIDE_Msk = 0x10
	// Bit PIDE.
	POEG_POEGGA_PIDE = 0x10
	// Disable output-disable requests from the GTETRGn pins
	POEG_POEGGA_PIDE_0 = 0x0
	// Enable output-disable requests from the GTETRGn pins
	POEG_POEGGA_PIDE_1 = 0x1
	// Position of IOCE field.
	POEG_POEGGA_IOCE_Pos = 0x5
	// Bit mask of IOCE field.
	POEG_POEGGA_IOCE_Msk = 0x20
	// Bit IOCE.
	POEG_POEGGA_IOCE = 0x20
	// Disable output-disable requests from GPT
	POEG_POEGGA_IOCE_0 = 0x0
	// Enable output-disable requests from GPT
	POEG_POEGGA_IOCE_1 = 0x1
	// Position of OSTPE field.
	POEG_POEGGA_OSTPE_Pos = 0x6
	// Bit mask of OSTPE field.
	POEG_POEGGA_OSTPE_Msk = 0x40
	// Bit OSTPE.
	POEG_POEGGA_OSTPE = 0x40
	// Disable output-disable requests from oscillation stop detection
	POEG_POEGGA_OSTPE_0 = 0x0
	// Enable output-disable requests from oscillation stop detection
	POEG_POEGGA_OSTPE_1 = 0x1
	// Position of ST field.
	POEG_POEGGA_ST_Pos = 0x10
	// Bit mask of ST field.
	POEG_POEGGA_ST_Msk = 0x10000
	// Bit ST.
	POEG_POEGGA_ST = 0x10000
	// GTETRGn input after filtering was 0
	POEG_POEGGA_ST_0 = 0x0
	// GTETRGn input after filtering was 1
	POEG_POEGGA_ST_1 = 0x1
	// Position of INV field.
	POEG_POEGGA_INV_Pos = 0x1c
	// Bit mask of INV field.
	POEG_POEGGA_INV_Msk = 0x10000000
	// Bit INV.
	POEG_POEGGA_INV = 0x10000000
	// Input GTETRGn as-is
	POEG_POEGGA_INV_0 = 0x0
	// Input GTETRGn in reverse
	POEG_POEGGA_INV_1 = 0x1
	// Position of NFEN field.
	POEG_POEGGA_NFEN_Pos = 0x1d
	// Bit mask of NFEN field.
	POEG_POEGGA_NFEN_Msk = 0x20000000
	// Bit NFEN.
	POEG_POEGGA_NFEN = 0x20000000
	// Disable noise filtering
	POEG_POEGGA_NFEN_0 = 0x0
	// Enable noise filtering
	POEG_POEGGA_NFEN_1 = 0x1
	// Position of NFCS field.
	POEG_POEGGA_NFCS_Pos = 0x1e
	// Bit mask of NFCS field.
	POEG_POEGGA_NFCS_Msk = 0xc0000000
	// Sample GTETRGn pin input level three times every PCLKB
	POEG_POEGGA_NFCS_00 = 0x0
	// Sample GTETRGn pin input level three times every PCLKB/8
	POEG_POEGGA_NFCS_01 = 0x1
	// Sample GTETRGn pin input level three times every PCLKB/32
	POEG_POEGGA_NFCS_10 = 0x2
	// Sample GTETRGn pin input level three times every PCLKB/128
	POEG_POEGGA_NFCS_11 = 0x3

	// POEGGB: POEG Group B Setting Register
	// Position of PIDF field.
	POEG_POEGGB_PIDF_Pos = 0x0
	// Bit mask of PIDF field.
	POEG_POEGGB_PIDF_Msk = 0x1
	// Bit PIDF.
	POEG_POEGGB_PIDF = 0x1
	// No output-disable request from the GTETRGn pin occurred
	POEG_POEGGB_PIDF_0 = 0x0
	// Output-disable request from the GTETRGn pin occurred.
	POEG_POEGGB_PIDF_1 = 0x1
	// Position of IOCF field.
	POEG_POEGGB_IOCF_Pos = 0x1
	// Bit mask of IOCF field.
	POEG_POEGGB_IOCF_Msk = 0x2
	// Bit IOCF.
	POEG_POEGGB_IOCF = 0x2
	// No output-disable request from GPT occurred.
	POEG_POEGGB_IOCF_0 = 0x0
	// Output-disable request from GPT occurred.
	POEG_POEGGB_IOCF_1 = 0x1
	// Position of OSTPF field.
	POEG_POEGGB_OSTPF_Pos = 0x2
	// Bit mask of OSTPF field.
	POEG_POEGGB_OSTPF_Msk = 0x4
	// Bit OSTPF.
	POEG_POEGGB_OSTPF = 0x4
	// No output-disable request from oscillation stop detection occurred
	POEG_POEGGB_OSTPF_0 = 0x0
	// Output-disable request from oscillation stop detection occurred
	POEG_POEGGB_OSTPF_1 = 0x1
	// Position of SSF field.
	POEG_POEGGB_SSF_Pos = 0x3
	// Bit mask of SSF field.
	POEG_POEGGB_SSF_Msk = 0x8
	// Bit SSF.
	POEG_POEGGB_SSF = 0x8
	// No output-disable request from software occurred
	POEG_POEGGB_SSF_0 = 0x0
	// Output-disable request from software occurred
	POEG_POEGGB_SSF_1 = 0x1
	// Position of PIDE field.
	POEG_POEGGB_PIDE_Pos = 0x4
	// Bit mask of PIDE field.
	POEG_POEGGB_PIDE_Msk = 0x10
	// Bit PIDE.
	POEG_POEGGB_PIDE = 0x10
	// Disable output-disable requests from the GTETRGn pins
	POEG_POEGGB_PIDE_0 = 0x0
	// Enable output-disable requests from the GTETRGn pins
	POEG_POEGGB_PIDE_1 = 0x1
	// Position of IOCE field.
	POEG_POEGGB_IOCE_Pos = 0x5
	// Bit mask of IOCE field.
	POEG_POEGGB_IOCE_Msk = 0x20
	// Bit IOCE.
	POEG_POEGGB_IOCE = 0x20
	// Disable output-disable requests from GPT
	POEG_POEGGB_IOCE_0 = 0x0
	// Enable output-disable requests from GPT
	POEG_POEGGB_IOCE_1 = 0x1
	// Position of OSTPE field.
	POEG_POEGGB_OSTPE_Pos = 0x6
	// Bit mask of OSTPE field.
	POEG_POEGGB_OSTPE_Msk = 0x40
	// Bit OSTPE.
	POEG_POEGGB_OSTPE = 0x40
	// Disable output-disable requests from oscillation stop detection
	POEG_POEGGB_OSTPE_0 = 0x0
	// Enable output-disable requests from oscillation stop detection
	POEG_POEGGB_OSTPE_1 = 0x1
	// Position of ST field.
	POEG_POEGGB_ST_Pos = 0x10
	// Bit mask of ST field.
	POEG_POEGGB_ST_Msk = 0x10000
	// Bit ST.
	POEG_POEGGB_ST = 0x10000
	// GTETRGn input after filtering was 0
	POEG_POEGGB_ST_0 = 0x0
	// GTETRGn input after filtering was 1
	POEG_POEGGB_ST_1 = 0x1
	// Position of INV field.
	POEG_POEGGB_INV_Pos = 0x1c
	// Bit mask of INV field.
	POEG_POEGGB_INV_Msk = 0x10000000
	// Bit INV.
	POEG_POEGGB_INV = 0x10000000
	// Input GTETRGn as-is
	POEG_POEGGB_INV_0 = 0x0
	// Input GTETRGn in reverse
	POEG_POEGGB_INV_1 = 0x1
	// Position of NFEN field.
	POEG_POEGGB_NFEN_Pos = 0x1d
	// Bit mask of NFEN field.
	POEG_POEGGB_NFEN_Msk = 0x20000000
	// Bit NFEN.
	POEG_POEGGB_NFEN = 0x20000000
	// Disable noise filtering
	POEG_POEGGB_NFEN_0 = 0x0
	// Enable noise filtering
	POEG_POEGGB_NFEN_1 = 0x1
	// Position of NFCS field.
	POEG_POEGGB_NFCS_Pos = 0x1e
	// Bit mask of NFCS field.
	POEG_POEGGB_NFCS_Msk = 0xc0000000
	// Sample GTETRGn pin input level three times every PCLKB
	POEG_POEGGB_NFCS_00 = 0x0
	// Sample GTETRGn pin input level three times every PCLKB/8
	POEG_POEGGB_NFCS_01 = 0x1
	// Sample GTETRGn pin input level three times every PCLKB/32
	POEG_POEGGB_NFCS_10 = 0x2
	// Sample GTETRGn pin input level three times every PCLKB/128
	POEG_POEGGB_NFCS_11 = 0x3
)

// Constants for RTC: Realtime Clock
const (
	// R64CNT: 64-Hz Counter
	// Position of F64HZ field.
	RTC_R64CNT_F64HZ_Pos = 0x0
	// Bit mask of F64HZ field.
	RTC_R64CNT_F64HZ_Msk = 0x1
	// Bit F64HZ.
	RTC_R64CNT_F64HZ = 0x1
	// Position of F32HZ field.
	RTC_R64CNT_F32HZ_Pos = 0x1
	// Bit mask of F32HZ field.
	RTC_R64CNT_F32HZ_Msk = 0x2
	// Bit F32HZ.
	RTC_R64CNT_F32HZ = 0x2
	// Position of F16HZ field.
	RTC_R64CNT_F16HZ_Pos = 0x2
	// Bit mask of F16HZ field.
	RTC_R64CNT_F16HZ_Msk = 0x4
	// Bit F16HZ.
	RTC_R64CNT_F16HZ = 0x4
	// Position of F8HZ field.
	RTC_R64CNT_F8HZ_Pos = 0x3
	// Bit mask of F8HZ field.
	RTC_R64CNT_F8HZ_Msk = 0x8
	// Bit F8HZ.
	RTC_R64CNT_F8HZ = 0x8
	// Position of F4HZ field.
	RTC_R64CNT_F4HZ_Pos = 0x4
	// Bit mask of F4HZ field.
	RTC_R64CNT_F4HZ_Msk = 0x10
	// Bit F4HZ.
	RTC_R64CNT_F4HZ = 0x10
	// Position of F2HZ field.
	RTC_R64CNT_F2HZ_Pos = 0x5
	// Bit mask of F2HZ field.
	RTC_R64CNT_F2HZ_Msk = 0x20
	// Bit F2HZ.
	RTC_R64CNT_F2HZ = 0x20
	// Position of F1HZ field.
	RTC_R64CNT_F1HZ_Pos = 0x6
	// Bit mask of F1HZ field.
	RTC_R64CNT_F1HZ_Msk = 0x40
	// Bit F1HZ.
	RTC_R64CNT_F1HZ = 0x40
	// Position of R64OVF field.
	RTC_R64CNT_R64OVF_Pos = 0x7
	// Bit mask of R64OVF field.
	RTC_R64CNT_R64OVF_Msk = 0x80
	// Bit R64OVF.
	RTC_R64CNT_R64OVF = 0x80

	// BCNT0: Binary Counter %s
	// Position of BCNT field.
	RTC_BCNT_BCNT_Pos = 0x0
	// Bit mask of BCNT field.
	RTC_BCNT_BCNT_Msk = 0xff

	// RSECCNT: Second Counter (in Calendar Count Mode)
	// Position of SEC1 field.
	RTC_RSECCNT_SEC1_Pos = 0x0
	// Bit mask of SEC1 field.
	RTC_RSECCNT_SEC1_Msk = 0xf
	// Position of SEC10 field.
	RTC_RSECCNT_SEC10_Pos = 0x4
	// Bit mask of SEC10 field.
	RTC_RSECCNT_SEC10_Msk = 0x70

	// RMINCNT: Minute Counter (in Calendar Count Mode)
	// Position of MIN1 field.
	RTC_RMINCNT_MIN1_Pos = 0x0
	// Bit mask of MIN1 field.
	RTC_RMINCNT_MIN1_Msk = 0xf
	// Position of MIN10 field.
	RTC_RMINCNT_MIN10_Pos = 0x4
	// Bit mask of MIN10 field.
	RTC_RMINCNT_MIN10_Msk = 0x70

	// RHRCNT: Hour Counter (in Calendar Count Mode)
	// Position of HR1 field.
	RTC_RHRCNT_HR1_Pos = 0x0
	// Bit mask of HR1 field.
	RTC_RHRCNT_HR1_Msk = 0xf
	// Position of HR10 field.
	RTC_RHRCNT_HR10_Pos = 0x4
	// Bit mask of HR10 field.
	RTC_RHRCNT_HR10_Msk = 0x30
	// Position of PM field.
	RTC_RHRCNT_PM_Pos = 0x6
	// Bit mask of PM field.
	RTC_RHRCNT_PM_Msk = 0x40
	// Bit PM.
	RTC_RHRCNT_PM = 0x40
	// AM
	RTC_RHRCNT_PM_0 = 0x0
	// PM
	RTC_RHRCNT_PM_1 = 0x1

	// RWKCNT: Day-of-Week Counter (in Calendar Count Mode)
	// Position of DAYW field.
	RTC_RWKCNT_DAYW_Pos = 0x0
	// Bit mask of DAYW field.
	RTC_RWKCNT_DAYW_Msk = 0x7
	// Sunday
	RTC_RWKCNT_DAYW_000 = 0x0
	// Monday
	RTC_RWKCNT_DAYW_001 = 0x1
	// Tuesday
	RTC_RWKCNT_DAYW_010 = 0x2
	// Wednesday
	RTC_RWKCNT_DAYW_011 = 0x3
	// Thursday
	RTC_RWKCNT_DAYW_100 = 0x4
	// Friday
	RTC_RWKCNT_DAYW_101 = 0x5
	// Saturday
	RTC_RWKCNT_DAYW_110 = 0x6
	// Setting prohibited
	RTC_RWKCNT_DAYW_111 = 0x7

	// RDAYCNT: Day Counter
	// Position of DATE1 field.
	RTC_RDAYCNT_DATE1_Pos = 0x0
	// Bit mask of DATE1 field.
	RTC_RDAYCNT_DATE1_Msk = 0xf
	// Position of DATE10 field.
	RTC_RDAYCNT_DATE10_Pos = 0x4
	// Bit mask of DATE10 field.
	RTC_RDAYCNT_DATE10_Msk = 0x30

	// RMONCNT: Month Counter
	// Position of MON1 field.
	RTC_RMONCNT_MON1_Pos = 0x0
	// Bit mask of MON1 field.
	RTC_RMONCNT_MON1_Msk = 0xf
	// Position of MON10 field.
	RTC_RMONCNT_MON10_Pos = 0x4
	// Bit mask of MON10 field.
	RTC_RMONCNT_MON10_Msk = 0x10
	// Bit MON10.
	RTC_RMONCNT_MON10 = 0x10

	// RYRCNT: Year Counter
	// Position of YR1 field.
	RTC_RYRCNT_YR1_Pos = 0x0
	// Bit mask of YR1 field.
	RTC_RYRCNT_YR1_Msk = 0xf
	// Position of YR10 field.
	RTC_RYRCNT_YR10_Pos = 0x4
	// Bit mask of YR10 field.
	RTC_RYRCNT_YR10_Msk = 0xf0

	// BCNT0AR: Binary Counter %s Alarm Register
	// Position of BCNTAR field.
	RTC_BCNTAR_BCNTAR_Pos = 0x0
	// Bit mask of BCNTAR field.
	RTC_BCNTAR_BCNTAR_Msk = 0xff

	// RSECAR: Second Alarm Register (in Calendar Count Mode)
	// Position of SEC1 field.
	RTC_RSECAR_SEC1_Pos = 0x0
	// Bit mask of SEC1 field.
	RTC_RSECAR_SEC1_Msk = 0xf
	// Position of SEC10 field.
	RTC_RSECAR_SEC10_Pos = 0x4
	// Bit mask of SEC10 field.
	RTC_RSECAR_SEC10_Msk = 0x70
	// Position of ENB field.
	RTC_RSECAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RSECAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RSECAR_ENB = 0x80
	// Do not compare register value with RSECCNT counter value
	RTC_RSECAR_ENB_0 = 0x0
	// Compare register value with RSECCNT counter value
	RTC_RSECAR_ENB_1 = 0x1

	// RMINAR: Minute Alarm Register (in Calendar Count Mode)
	// Position of MIN1 field.
	RTC_RMINAR_MIN1_Pos = 0x0
	// Bit mask of MIN1 field.
	RTC_RMINAR_MIN1_Msk = 0xf
	// Position of MIN10 field.
	RTC_RMINAR_MIN10_Pos = 0x4
	// Bit mask of MIN10 field.
	RTC_RMINAR_MIN10_Msk = 0x70
	// Position of ENB field.
	RTC_RMINAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RMINAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RMINAR_ENB = 0x80
	// Do not compare register value with RMINCNT counter value
	RTC_RMINAR_ENB_0 = 0x0
	// Compare register value with RMINCNT counter value
	RTC_RMINAR_ENB_1 = 0x1

	// RHRAR: Hour Alarm Register (in Calendar Count Mode)
	// Position of HR1 field.
	RTC_RHRAR_HR1_Pos = 0x0
	// Bit mask of HR1 field.
	RTC_RHRAR_HR1_Msk = 0xf
	// Position of HR10 field.
	RTC_RHRAR_HR10_Pos = 0x4
	// Bit mask of HR10 field.
	RTC_RHRAR_HR10_Msk = 0x30
	// Position of PM field.
	RTC_RHRAR_PM_Pos = 0x6
	// Bit mask of PM field.
	RTC_RHRAR_PM_Msk = 0x40
	// Bit PM.
	RTC_RHRAR_PM = 0x40
	// AM
	RTC_RHRAR_PM_0 = 0x0
	// PM
	RTC_RHRAR_PM_1 = 0x1
	// Position of ENB field.
	RTC_RHRAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RHRAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RHRAR_ENB = 0x80
	// Do not compare register value with RHRCNT counter value
	RTC_RHRAR_ENB_0 = 0x0
	// Compare register value with RHRCNT counter value
	RTC_RHRAR_ENB_1 = 0x1

	// RWKAR: Day-of-Week Alarm Register (in Calendar Count Mode)
	// Position of DAYW field.
	RTC_RWKAR_DAYW_Pos = 0x0
	// Bit mask of DAYW field.
	RTC_RWKAR_DAYW_Msk = 0x7
	// Sunday
	RTC_RWKAR_DAYW_000 = 0x0
	// Monday
	RTC_RWKAR_DAYW_001 = 0x1
	// Tuesday
	RTC_RWKAR_DAYW_010 = 0x2
	// Wednesday
	RTC_RWKAR_DAYW_011 = 0x3
	// Thursday
	RTC_RWKAR_DAYW_100 = 0x4
	// Friday
	RTC_RWKAR_DAYW_101 = 0x5
	// Saturday
	RTC_RWKAR_DAYW_110 = 0x6
	// Setting prohibited
	RTC_RWKAR_DAYW_111 = 0x7
	// Position of ENB field.
	RTC_RWKAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RWKAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RWKAR_ENB = 0x80
	// Do not compare register value with RWKCNT counter value
	RTC_RWKAR_ENB_0 = 0x0
	// Compare register value with RWKCNT counter value
	RTC_RWKAR_ENB_1 = 0x1

	// BCNT0AER: Binary Counter %s Alarm Enable Register
	// Position of ENB field.
	RTC_BCNTAER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNTAER_ENB_Msk = 0xff

	// RDAYAR: Date Alarm Register (in Calendar Count Mode)
	// Position of DATE1 field.
	RTC_RDAYAR_DATE1_Pos = 0x0
	// Bit mask of DATE1 field.
	RTC_RDAYAR_DATE1_Msk = 0xf
	// Position of DATE10 field.
	RTC_RDAYAR_DATE10_Pos = 0x4
	// Bit mask of DATE10 field.
	RTC_RDAYAR_DATE10_Msk = 0x30
	// Position of ENB field.
	RTC_RDAYAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RDAYAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RDAYAR_ENB = 0x80
	// Do not compare register value with RDAYCNT counter value
	RTC_RDAYAR_ENB_0 = 0x0
	// Compare register value with RDAYCNT counter value
	RTC_RDAYAR_ENB_1 = 0x1

	// RMONAR: Month Alarm Register (in Calendar Count Mode)
	// Position of MON1 field.
	RTC_RMONAR_MON1_Pos = 0x0
	// Bit mask of MON1 field.
	RTC_RMONAR_MON1_Msk = 0xf
	// Position of MON10 field.
	RTC_RMONAR_MON10_Pos = 0x4
	// Bit mask of MON10 field.
	RTC_RMONAR_MON10_Msk = 0x10
	// Bit MON10.
	RTC_RMONAR_MON10 = 0x10
	// Position of ENB field.
	RTC_RMONAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RMONAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RMONAR_ENB = 0x80
	// Do not compare register value with RMONCNT counter value
	RTC_RMONAR_ENB_0 = 0x0
	// Compare register value with RMONCNT counter value
	RTC_RMONAR_ENB_1 = 0x1

	// BCNT2AER: Binary Counter 2 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT2AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT2AER_ENB_Msk = 0xff

	// RYRAR: Year Alarm Register (in Calendar Count Mode)
	// Position of YR1 field.
	RTC_RYRAR_YR1_Pos = 0x0
	// Bit mask of YR1 field.
	RTC_RYRAR_YR1_Msk = 0xf
	// Position of YR10 field.
	RTC_RYRAR_YR10_Pos = 0x4
	// Bit mask of YR10 field.
	RTC_RYRAR_YR10_Msk = 0xf0

	// BCNT3AER: Binary Counter 3 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT3AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT3AER_ENB_Msk = 0xff

	// RYRAREN: Year Alarm Enable Register (in Calendar Count Mode)
	// Position of ENB field.
	RTC_RYRAREN_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RYRAREN_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RYRAREN_ENB = 0x80
	// Do not compare register value with the RYRCNT counter value
	RTC_RYRAREN_ENB_0 = 0x0
	// Compare register value with the RYRCNT counter value
	RTC_RYRAREN_ENB_1 = 0x1

	// RCR1: RTC Control Register 1
	// Position of AIE field.
	RTC_RCR1_AIE_Pos = 0x0
	// Bit mask of AIE field.
	RTC_RCR1_AIE_Msk = 0x1
	// Bit AIE.
	RTC_RCR1_AIE = 0x1
	// Disable alarm interrupt requests
	RTC_RCR1_AIE_0 = 0x0
	// Enable alarm interrupt requests
	RTC_RCR1_AIE_1 = 0x1
	// Position of CIE field.
	RTC_RCR1_CIE_Pos = 0x1
	// Bit mask of CIE field.
	RTC_RCR1_CIE_Msk = 0x2
	// Bit CIE.
	RTC_RCR1_CIE = 0x2
	// Disable carry interrupt requests
	RTC_RCR1_CIE_0 = 0x0
	// Enable carry interrupt requests
	RTC_RCR1_CIE_1 = 0x1
	// Position of PIE field.
	RTC_RCR1_PIE_Pos = 0x2
	// Bit mask of PIE field.
	RTC_RCR1_PIE_Msk = 0x4
	// Bit PIE.
	RTC_RCR1_PIE = 0x4
	// Disable periodic interrupt requests
	RTC_RCR1_PIE_0 = 0x0
	// Enable periodic interrupt requests
	RTC_RCR1_PIE_1 = 0x1
	// Position of RTCOS field.
	RTC_RCR1_RTCOS_Pos = 0x3
	// Bit mask of RTCOS field.
	RTC_RCR1_RTCOS_Msk = 0x8
	// Bit RTCOS.
	RTC_RCR1_RTCOS = 0x8
	// Outputs 1 Hz on RTCOUT
	RTC_RCR1_RTCOS_0 = 0x0
	// Outputs 64 Hz RTCOUT
	RTC_RCR1_RTCOS_1 = 0x1
	// Position of PES field.
	RTC_RCR1_PES_Pos = 0x4
	// Bit mask of PES field.
	RTC_RCR1_PES_Msk = 0xf0
	// Generate periodic interrupt every 1/256 second
	RTC_RCR1_PES_0x6 = 0x6
	// Generate periodic interrupt every 1/128 second
	RTC_RCR1_PES_0x7 = 0x7
	// Generate periodic interrupt every 1/64 second
	RTC_RCR1_PES_0x8 = 0x8
	// Generate periodic interrupt every 1/32 second
	RTC_RCR1_PES_0x9 = 0x9
	// Generate periodic interrupt every 1/16 second
	RTC_RCR1_PES_0xA = 0xa
	// Generate periodic interrupt every 1/8 second
	RTC_RCR1_PES_0xB = 0xb
	// Generate periodic interrupt every 1/4 second
	RTC_RCR1_PES_0xC = 0xc
	// Generate periodic interrupt every 1/2 second
	RTC_RCR1_PES_0xD = 0xd
	// Generate periodic interrupt every 1 second
	RTC_RCR1_PES_0xE = 0xe
	// Generate periodic interrupt every 2 seconds
	RTC_RCR1_PES_0xF = 0xf

	// RCR2: RTC Control Register 2 (in Calendar Count Mode)
	// Position of START field.
	RTC_RCR2_START_Pos = 0x0
	// Bit mask of START field.
	RTC_RCR2_START_Msk = 0x1
	// Bit START.
	RTC_RCR2_START = 0x1
	// Stop prescaler and time counter
	RTC_RCR2_START_0 = 0x0
	// Operate prescaler and time counter normally
	RTC_RCR2_START_1 = 0x1
	// Position of RESET field.
	RTC_RCR2_RESET_Pos = 0x1
	// Bit mask of RESET field.
	RTC_RCR2_RESET_Msk = 0x2
	// Bit RESET.
	RTC_RCR2_RESET = 0x2
	// In writing: Invalid (writing 0 has no effect). In reading: Normal time operation in progress, or an RTC software reset has completed.
	RTC_RCR2_RESET_0 = 0x0
	// In writing: Initialize the prescaler and target registers for RTC software reset. In reading: RTC software reset in progress.
	RTC_RCR2_RESET_1 = 0x1
	// Position of ADJ30 field.
	RTC_RCR2_ADJ30_Pos = 0x2
	// Bit mask of ADJ30 field.
	RTC_RCR2_ADJ30_Msk = 0x4
	// Bit ADJ30.
	RTC_RCR2_ADJ30 = 0x4
	// In writing: Invalid (writing 0 has no effect). In reading: Normal time operation in progress, or 30-second adjustment has completed.
	RTC_RCR2_ADJ30_0 = 0x0
	// In writing: Execute 30-second adjustment. In reading: 30-second adjustment in progress.
	RTC_RCR2_ADJ30_1 = 0x1
	// Position of RTCOE field.
	RTC_RCR2_RTCOE_Pos = 0x3
	// Bit mask of RTCOE field.
	RTC_RCR2_RTCOE_Msk = 0x8
	// Bit RTCOE.
	RTC_RCR2_RTCOE = 0x8
	// Disable RTCOUT output
	RTC_RCR2_RTCOE_0 = 0x0
	// Enable RTCOUT output
	RTC_RCR2_RTCOE_1 = 0x1
	// Position of AADJE field.
	RTC_RCR2_AADJE_Pos = 0x4
	// Bit mask of AADJE field.
	RTC_RCR2_AADJE_Msk = 0x10
	// Bit AADJE.
	RTC_RCR2_AADJE = 0x10
	// Disable automatic adjustment
	RTC_RCR2_AADJE_0 = 0x0
	// Enable automatic adjustment
	RTC_RCR2_AADJE_1 = 0x1
	// Position of AADJP field.
	RTC_RCR2_AADJP_Pos = 0x5
	// Bit mask of AADJP field.
	RTC_RCR2_AADJP_Msk = 0x20
	// Bit AADJP.
	RTC_RCR2_AADJP = 0x20
	// In normal operation mode, adjust RADJ.ADJ[5:0] setting from the count value of the prescaler every minute. In low-consumption clock mode, adjust RADJ.ADJ[5:0] setting from the count value of the 64-Hz counter every day.
	RTC_RCR2_AADJP_0 = 0x0
	// In normal operation mode, adjust RADJ.ADJ[5:0] setting from the count value of the prescaler every 10 seconds. In low-consumption clock mode, adjust RADJ.ADJ[5:0] setting from the count value of the 64-Hz counter every hour.
	RTC_RCR2_AADJP_1 = 0x1
	// Position of HR24 field.
	RTC_RCR2_HR24_Pos = 0x6
	// Bit mask of HR24 field.
	RTC_RCR2_HR24_Msk = 0x40
	// Bit HR24.
	RTC_RCR2_HR24 = 0x40
	// Operate RTC in 12-hour mode
	RTC_RCR2_HR24_0 = 0x0
	// Operate RTC in 24-hour mode
	RTC_RCR2_HR24_1 = 0x1
	// Position of CNTMD field.
	RTC_RCR2_CNTMD_Pos = 0x7
	// Bit mask of CNTMD field.
	RTC_RCR2_CNTMD_Msk = 0x80
	// Bit CNTMD.
	RTC_RCR2_CNTMD = 0x80
	// Calendar count mode
	RTC_RCR2_CNTMD_0 = 0x0
	// Binary count mode
	RTC_RCR2_CNTMD_1 = 0x1

	// RCR2_BCNT: RTC Control Register 2 (in Binary Count Mode)
	// Position of START field.
	RTC_RCR2_BCNT_START_Pos = 0x0
	// Bit mask of START field.
	RTC_RCR2_BCNT_START_Msk = 0x1
	// Bit START.
	RTC_RCR2_BCNT_START = 0x1
	// Stop the 32-bit binary counter, 64-Hz counter, and prescaler
	RTC_RCR2_BCNT_START_0 = 0x0
	// Operate the 32-bit binary counter, 64-Hz counter, and prescaler normally
	RTC_RCR2_BCNT_START_1 = 0x1
	// Position of RESET field.
	RTC_RCR2_BCNT_RESET_Pos = 0x1
	// Bit mask of RESET field.
	RTC_RCR2_BCNT_RESET_Msk = 0x2
	// Bit RESET.
	RTC_RCR2_BCNT_RESET = 0x2
	// In writing: Invalid (writing 0 has no effect). In reading: Normal time operation in progress, or an RTC software reset has completed.
	RTC_RCR2_BCNT_RESET_0 = 0x0
	// In writing: Initialize the prescaler and target registers for RTC software reset. In reading: RTC software reset in progress.
	RTC_RCR2_BCNT_RESET_1 = 0x1
	// Position of RTCOE field.
	RTC_RCR2_BCNT_RTCOE_Pos = 0x3
	// Bit mask of RTCOE field.
	RTC_RCR2_BCNT_RTCOE_Msk = 0x8
	// Bit RTCOE.
	RTC_RCR2_BCNT_RTCOE = 0x8
	// Disable RTCOUT output
	RTC_RCR2_BCNT_RTCOE_0 = 0x0
	// Enable RTCOUT output
	RTC_RCR2_BCNT_RTCOE_1 = 0x1
	// Position of AADJE field.
	RTC_RCR2_BCNT_AADJE_Pos = 0x4
	// Bit mask of AADJE field.
	RTC_RCR2_BCNT_AADJE_Msk = 0x10
	// Bit AADJE.
	RTC_RCR2_BCNT_AADJE = 0x10
	// Disable automatic adjustment
	RTC_RCR2_BCNT_AADJE_0 = 0x0
	// Enable automatic adjustment
	RTC_RCR2_BCNT_AADJE_1 = 0x1
	// Position of AADJP field.
	RTC_RCR2_BCNT_AADJP_Pos = 0x5
	// Bit mask of AADJP field.
	RTC_RCR2_BCNT_AADJP_Msk = 0x20
	// Bit AADJP.
	RTC_RCR2_BCNT_AADJP = 0x20
	// In normal operation mode, add or subtract the RADJ.ADJ[5:0] bits from the prescaler count value every 32 seconds. In low-consumption clock mode, add or subtract the RADJ.ADJ[5:0] bits from the 64-Hz counter count value every 8192 seconds.
	RTC_RCR2_BCNT_AADJP_0 = 0x0
	// In normal operation mode, add or subtract the RADJ.ADJ[5:0] bits from the prescaler count value every 8 seconds. In low-consumption clock mode, add or subtract the RADJ.ADJ[5:0] bits from the 64-Hz counter count value every 2048 seconds.
	RTC_RCR2_BCNT_AADJP_1 = 0x1
	// Position of CNTMD field.
	RTC_RCR2_BCNT_CNTMD_Pos = 0x7
	// Bit mask of CNTMD field.
	RTC_RCR2_BCNT_CNTMD_Msk = 0x80
	// Bit CNTMD.
	RTC_RCR2_BCNT_CNTMD = 0x80
	// Calendar count mode
	RTC_RCR2_BCNT_CNTMD_0 = 0x0
	// Binary count mode
	RTC_RCR2_BCNT_CNTMD_1 = 0x1

	// RCR4: RTC Control Register 4
	// Position of RCKSEL field.
	RTC_RCR4_RCKSEL_Pos = 0x0
	// Bit mask of RCKSEL field.
	RTC_RCR4_RCKSEL_Msk = 0x1
	// Bit RCKSEL.
	RTC_RCR4_RCKSEL = 0x1
	// Sub-clock oscillator is selected
	RTC_RCR4_RCKSEL_0 = 0x0
	// LOCO is selected
	RTC_RCR4_RCKSEL_1 = 0x1
	// Position of ROPSEL field.
	RTC_RCR4_ROPSEL_Pos = 0x7
	// Bit mask of ROPSEL field.
	RTC_RCR4_ROPSEL_Msk = 0x80
	// Bit ROPSEL.
	RTC_RCR4_ROPSEL = 0x80
	// Normal operation mode is selected.
	RTC_RCR4_ROPSEL_0 = 0x0
	// Low-consumption clock mode is selected.
	RTC_RCR4_ROPSEL_1 = 0x1

	// RFRH: Frequency Register H
	// Position of RFC16 field.
	RTC_RFRH_RFC16_Pos = 0x0
	// Bit mask of RFC16 field.
	RTC_RFRH_RFC16_Msk = 0x1
	// Bit RFC16.
	RTC_RFRH_RFC16 = 0x1

	// RFRL: Frequency Register L
	// Position of RFC field.
	RTC_RFRL_RFC_Pos = 0x0
	// Bit mask of RFC field.
	RTC_RFRL_RFC_Msk = 0xffff

	// RADJ: Time Error Adjustment Register
	// Position of ADJ field.
	RTC_RADJ_ADJ_Pos = 0x0
	// Bit mask of ADJ field.
	RTC_RADJ_ADJ_Msk = 0x3f
	// Position of PMADJ field.
	RTC_RADJ_PMADJ_Pos = 0x6
	// Bit mask of PMADJ field.
	RTC_RADJ_PMADJ_Msk = 0xc0
	// Do not perform adjustment.
	RTC_RADJ_PMADJ_00 = 0x0
	// In normal operation mode, adjustment is performed by the addition to the prescaler. In low-consumption clock mode, adjustment is performed by the addition to the 64-Hz counter.
	RTC_RADJ_PMADJ_01 = 0x1
	// In normal operation mode, adjustment is performed by the subtraction from the prescaler. In low-consumption clock mode, adjustment is performed by the subtraction from the 64-Hz counter.
	RTC_RADJ_PMADJ_10 = 0x2
	// Setting prohibited.
	RTC_RADJ_PMADJ_11 = 0x3
)

// Constants for WDT: Watchdog Timer
const (
	// WDTCR: WDT Control Register
	// Position of TOPS field.
	WDT_WDTCR_TOPS_Pos = 0x0
	// Bit mask of TOPS field.
	WDT_WDTCR_TOPS_Msk = 0x3
	// 1024 cycles (0x03FF)
	WDT_WDTCR_TOPS_00 = 0x0
	// 4096 cycles (0x0FFF)
	WDT_WDTCR_TOPS_01 = 0x1
	// 8192 cycles (0x1FFF)
	WDT_WDTCR_TOPS_10 = 0x2
	// 16384 cycles (0x3FFF)
	WDT_WDTCR_TOPS_11 = 0x3
	// Position of CKS field.
	WDT_WDTCR_CKS_Pos = 0x4
	// Bit mask of CKS field.
	WDT_WDTCR_CKS_Msk = 0xf0
	// PCLKB/4
	WDT_WDTCR_CKS_0x1 = 0x1
	// PCLKB/64
	WDT_WDTCR_CKS_0x4 = 0x4
	// PCLKB/128
	WDT_WDTCR_CKS_0xF = 0xf
	// PCLKB/512
	WDT_WDTCR_CKS_0x6 = 0x6
	// PCLKB/2048
	WDT_WDTCR_CKS_0x7 = 0x7
	// PCLKB/8192
	WDT_WDTCR_CKS_0x8 = 0x8
	// Position of RPES field.
	WDT_WDTCR_RPES_Pos = 0x8
	// Bit mask of RPES field.
	WDT_WDTCR_RPES_Msk = 0x300
	// 75%
	WDT_WDTCR_RPES_00 = 0x0
	// 50%
	WDT_WDTCR_RPES_01 = 0x1
	// 25%
	WDT_WDTCR_RPES_10 = 0x2
	// 0% (do not specify window end position).
	WDT_WDTCR_RPES_11 = 0x3
	// Position of RPSS field.
	WDT_WDTCR_RPSS_Pos = 0xc
	// Bit mask of RPSS field.
	WDT_WDTCR_RPSS_Msk = 0x3000
	// 25%
	WDT_WDTCR_RPSS_00 = 0x0
	// 50%
	WDT_WDTCR_RPSS_01 = 0x1
	// 75%
	WDT_WDTCR_RPSS_10 = 0x2
	// 100% (do not specify window start position).
	WDT_WDTCR_RPSS_11 = 0x3

	// WDTSR: WDT Status Register
	// Position of CNTVAL field.
	WDT_WDTSR_CNTVAL_Pos = 0x0
	// Bit mask of CNTVAL field.
	WDT_WDTSR_CNTVAL_Msk = 0x3fff
	// Position of UNDFF field.
	WDT_WDTSR_UNDFF_Pos = 0xe
	// Bit mask of UNDFF field.
	WDT_WDTSR_UNDFF_Msk = 0x4000
	// Bit UNDFF.
	WDT_WDTSR_UNDFF = 0x4000
	// No underflow occurred
	WDT_WDTSR_UNDFF_0 = 0x0
	// Underflow occurred
	WDT_WDTSR_UNDFF_1 = 0x1
	// Position of REFEF field.
	WDT_WDTSR_REFEF_Pos = 0xf
	// Bit mask of REFEF field.
	WDT_WDTSR_REFEF_Msk = 0x8000
	// Bit REFEF.
	WDT_WDTSR_REFEF = 0x8000
	// No refresh error occurred
	WDT_WDTSR_REFEF_0 = 0x0
	// Refresh error occurred
	WDT_WDTSR_REFEF_1 = 0x1

	// WDTRCR: WDT Reset Control Register
	// Position of RSTIRQS field.
	WDT_WDTRCR_RSTIRQS_Pos = 0x7
	// Bit mask of RSTIRQS field.
	WDT_WDTRCR_RSTIRQS_Msk = 0x80
	// Bit RSTIRQS.
	WDT_WDTRCR_RSTIRQS = 0x80
	// Interrupt
	WDT_WDTRCR_RSTIRQS_0 = 0x0
	// Reset
	WDT_WDTRCR_RSTIRQS_1 = 0x1

	// WDTCSTPR: WDT Count Stop Control Register
	// Position of SLCSTP field.
	WDT_WDTCSTPR_SLCSTP_Pos = 0x7
	// Bit mask of SLCSTP field.
	WDT_WDTCSTPR_SLCSTP_Msk = 0x80
	// Bit SLCSTP.
	WDT_WDTCSTPR_SLCSTP = 0x80
	// Disable count stop
	WDT_WDTCSTPR_SLCSTP_0 = 0x0
	// Stop count on transition to Sleep mode
	WDT_WDTCSTPR_SLCSTP_1 = 0x1
)

// Constants for IWDT: Independent Watchdog Timer
const (
	// IWDTSR: IWDT Status Register
	// Position of CNTVAL field.
	IWDT_IWDTSR_CNTVAL_Pos = 0x0
	// Bit mask of CNTVAL field.
	IWDT_IWDTSR_CNTVAL_Msk = 0x3fff
	// Position of UNDFF field.
	IWDT_IWDTSR_UNDFF_Pos = 0xe
	// Bit mask of UNDFF field.
	IWDT_IWDTSR_UNDFF_Msk = 0x4000
	// Bit UNDFF.
	IWDT_IWDTSR_UNDFF = 0x4000
	// No underflow occurred
	IWDT_IWDTSR_UNDFF_0 = 0x0
	// Underflow occurred
	IWDT_IWDTSR_UNDFF_1 = 0x1
	// Position of REFEF field.
	IWDT_IWDTSR_REFEF_Pos = 0xf
	// Bit mask of REFEF field.
	IWDT_IWDTSR_REFEF_Msk = 0x8000
	// Bit REFEF.
	IWDT_IWDTSR_REFEF = 0x8000
	// No refresh error occurred
	IWDT_IWDTSR_REFEF_0 = 0x0
	// Refresh error occurred
	IWDT_IWDTSR_REFEF_1 = 0x1
)

// Constants for CAC: Clock Frequency Accuracy Measurement Circuit
const (
	// CACR0: CAC Control Register 0
	// Position of CFME field.
	CAC_CACR0_CFME_Pos = 0x0
	// Bit mask of CFME field.
	CAC_CACR0_CFME_Msk = 0x1
	// Bit CFME.
	CAC_CACR0_CFME = 0x1
	// Disable
	CAC_CACR0_CFME_0 = 0x0
	// Enable
	CAC_CACR0_CFME_1 = 0x1

	// CACR1: CAC Control Register 1
	// Position of CACREFE field.
	CAC_CACR1_CACREFE_Pos = 0x0
	// Bit mask of CACREFE field.
	CAC_CACR1_CACREFE_Msk = 0x1
	// Bit CACREFE.
	CAC_CACR1_CACREFE = 0x1
	// Disable
	CAC_CACR1_CACREFE_0 = 0x0
	// Enable
	CAC_CACR1_CACREFE_1 = 0x1
	// Position of FMCS field.
	CAC_CACR1_FMCS_Pos = 0x1
	// Bit mask of FMCS field.
	CAC_CACR1_FMCS_Msk = 0xe
	// Main clock oscillator
	CAC_CACR1_FMCS_000 = 0x0
	// Sub-clock oscillator
	CAC_CACR1_FMCS_001 = 0x1
	// HOCO clock
	CAC_CACR1_FMCS_010 = 0x2
	// MOCO
	CAC_CACR1_FMCS_011 = 0x3
	// LOCO clock
	CAC_CACR1_FMCS_100 = 0x4
	// Peripheral module clock B (PCLKB)
	CAC_CACR1_FMCS_101 = 0x5
	// IWDT-dedicated clock
	CAC_CACR1_FMCS_110 = 0x6
	// Setting prohibited
	CAC_CACR1_FMCS_111 = 0x7
	// Position of TCSS field.
	CAC_CACR1_TCSS_Pos = 0x4
	// Bit mask of TCSS field.
	CAC_CACR1_TCSS_Msk = 0x30
	// No division
	CAC_CACR1_TCSS_00 = 0x0
	// x 1/4 clock
	CAC_CACR1_TCSS_01 = 0x1
	// x 1/8 clock
	CAC_CACR1_TCSS_10 = 0x2
	// x 1/32 clock
	CAC_CACR1_TCSS_11 = 0x3
	// Position of EDGES field.
	CAC_CACR1_EDGES_Pos = 0x6
	// Bit mask of EDGES field.
	CAC_CACR1_EDGES_Msk = 0xc0
	// Rising edge
	CAC_CACR1_EDGES_00 = 0x0
	// Falling edge
	CAC_CACR1_EDGES_01 = 0x1
	// Both rising and falling edges
	CAC_CACR1_EDGES_10 = 0x2
	// Setting prohibited
	CAC_CACR1_EDGES_11 = 0x3

	// CACR2: CAC Control Register 2
	// Position of RPS field.
	CAC_CACR2_RPS_Pos = 0x0
	// Bit mask of RPS field.
	CAC_CACR2_RPS_Msk = 0x1
	// Bit RPS.
	CAC_CACR2_RPS = 0x1
	// CACREF pin input
	CAC_CACR2_RPS_0 = 0x0
	// Internal clock (internally generated signal)
	CAC_CACR2_RPS_1 = 0x1
	// Position of RSCS field.
	CAC_CACR2_RSCS_Pos = 0x1
	// Bit mask of RSCS field.
	CAC_CACR2_RSCS_Msk = 0xe
	// Main clock oscillator
	CAC_CACR2_RSCS_000 = 0x0
	// Sub-clock oscillator
	CAC_CACR2_RSCS_001 = 0x1
	// HOCO clock
	CAC_CACR2_RSCS_010 = 0x2
	// MOCO
	CAC_CACR2_RSCS_011 = 0x3
	// LOCO clock
	CAC_CACR2_RSCS_100 = 0x4
	// Peripheral module clock B (PCLKB)
	CAC_CACR2_RSCS_101 = 0x5
	// IWDT-dedicated clock
	CAC_CACR2_RSCS_110 = 0x6
	// Setting prohibited
	CAC_CACR2_RSCS_111 = 0x7
	// Position of RCDS field.
	CAC_CACR2_RCDS_Pos = 0x4
	// Bit mask of RCDS field.
	CAC_CACR2_RCDS_Msk = 0x30
	// x 1/32 clock
	CAC_CACR2_RCDS_00 = 0x0
	// x 1/128 clock
	CAC_CACR2_RCDS_01 = 0x1
	// x 1/1024 clock
	CAC_CACR2_RCDS_10 = 0x2
	// x 1/8192 clock
	CAC_CACR2_RCDS_11 = 0x3
	// Position of DFS field.
	CAC_CACR2_DFS_Pos = 0x6
	// Bit mask of DFS field.
	CAC_CACR2_DFS_Msk = 0xc0
	// Disable digital filtering
	CAC_CACR2_DFS_00 = 0x0
	// Use sampling clock for the digital filter as the frequency measuring clock
	CAC_CACR2_DFS_01 = 0x1
	// Use sampling clock for the digital filter as the frequency measuring clock divided by 4
	CAC_CACR2_DFS_10 = 0x2
	// Use sampling clock for the digital filter as the frequency measuring clock divided by 16.
	CAC_CACR2_DFS_11 = 0x3

	// CAICR: CAC Interrupt Control Register
	// Position of FERRIE field.
	CAC_CAICR_FERRIE_Pos = 0x0
	// Bit mask of FERRIE field.
	CAC_CAICR_FERRIE_Msk = 0x1
	// Bit FERRIE.
	CAC_CAICR_FERRIE = 0x1
	// Disable
	CAC_CAICR_FERRIE_0 = 0x0
	// Enable
	CAC_CAICR_FERRIE_1 = 0x1
	// Position of MENDIE field.
	CAC_CAICR_MENDIE_Pos = 0x1
	// Bit mask of MENDIE field.
	CAC_CAICR_MENDIE_Msk = 0x2
	// Bit MENDIE.
	CAC_CAICR_MENDIE = 0x2
	// Disable
	CAC_CAICR_MENDIE_0 = 0x0
	// Enable
	CAC_CAICR_MENDIE_1 = 0x1
	// Position of OVFIE field.
	CAC_CAICR_OVFIE_Pos = 0x2
	// Bit mask of OVFIE field.
	CAC_CAICR_OVFIE_Msk = 0x4
	// Bit OVFIE.
	CAC_CAICR_OVFIE = 0x4
	// Disable
	CAC_CAICR_OVFIE_0 = 0x0
	// Enable
	CAC_CAICR_OVFIE_1 = 0x1
	// Position of FERRFCL field.
	CAC_CAICR_FERRFCL_Pos = 0x4
	// Bit mask of FERRFCL field.
	CAC_CAICR_FERRFCL_Msk = 0x10
	// Bit FERRFCL.
	CAC_CAICR_FERRFCL = 0x10
	// No effect
	CAC_CAICR_FERRFCL_0 = 0x0
	// The CASTR.FERRF flag is cleared
	CAC_CAICR_FERRFCL_1 = 0x1
	// Position of MENDFCL field.
	CAC_CAICR_MENDFCL_Pos = 0x5
	// Bit mask of MENDFCL field.
	CAC_CAICR_MENDFCL_Msk = 0x20
	// Bit MENDFCL.
	CAC_CAICR_MENDFCL = 0x20
	// No effect
	CAC_CAICR_MENDFCL_0 = 0x0
	// The CASTR.MENDF flag is cleared
	CAC_CAICR_MENDFCL_1 = 0x1
	// Position of OVFFCL field.
	CAC_CAICR_OVFFCL_Pos = 0x6
	// Bit mask of OVFFCL field.
	CAC_CAICR_OVFFCL_Msk = 0x40
	// Bit OVFFCL.
	CAC_CAICR_OVFFCL = 0x40
	// No effect
	CAC_CAICR_OVFFCL_0 = 0x0
	// The CASTR.OVFF flag is cleared.
	CAC_CAICR_OVFFCL_1 = 0x1

	// CASTR: CAC Status Register
	// Position of FERRF field.
	CAC_CASTR_FERRF_Pos = 0x0
	// Bit mask of FERRF field.
	CAC_CASTR_FERRF_Msk = 0x1
	// Bit FERRF.
	CAC_CASTR_FERRF = 0x1
	// Clock frequency is within the allowable range
	CAC_CASTR_FERRF_0 = 0x0
	// Clock frequency has deviated beyond the allowable range (frequency error).
	CAC_CASTR_FERRF_1 = 0x1
	// Position of MENDF field.
	CAC_CASTR_MENDF_Pos = 0x1
	// Bit mask of MENDF field.
	CAC_CASTR_MENDF_Msk = 0x2
	// Bit MENDF.
	CAC_CASTR_MENDF = 0x2
	// Measurement is in progress
	CAC_CASTR_MENDF_0 = 0x0
	// Measurement ended
	CAC_CASTR_MENDF_1 = 0x1
	// Position of OVFF field.
	CAC_CASTR_OVFF_Pos = 0x2
	// Bit mask of OVFF field.
	CAC_CASTR_OVFF_Msk = 0x4
	// Bit OVFF.
	CAC_CASTR_OVFF = 0x4
	// Counter has not overflowed
	CAC_CASTR_OVFF_0 = 0x0
	// Counter overflowed
	CAC_CASTR_OVFF_1 = 0x1
)

// Constants for MSTP: Module Stop Control B, C, D
const (
	// MSTPCRB: Module Stop Control Register B
	// Position of MSTPB2 field.
	MSTP_MSTPCRB_MSTPB2_Pos = 0x2
	// Bit mask of MSTPB2 field.
	MSTP_MSTPCRB_MSTPB2_Msk = 0x4
	// Bit MSTPB2.
	MSTP_MSTPCRB_MSTPB2 = 0x4
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB2_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB2_1 = 0x1
	// Position of MSTPB8 field.
	MSTP_MSTPCRB_MSTPB8_Pos = 0x8
	// Bit mask of MSTPB8 field.
	MSTP_MSTPCRB_MSTPB8_Msk = 0x100
	// Bit MSTPB8.
	MSTP_MSTPCRB_MSTPB8 = 0x100
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB8_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB8_1 = 0x1
	// Position of MSTPB9 field.
	MSTP_MSTPCRB_MSTPB9_Pos = 0x9
	// Bit mask of MSTPB9 field.
	MSTP_MSTPCRB_MSTPB9_Msk = 0x200
	// Bit MSTPB9.
	MSTP_MSTPCRB_MSTPB9 = 0x200
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB9_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB9_1 = 0x1
	// Position of MSTPB18 field.
	MSTP_MSTPCRB_MSTPB18_Pos = 0x12
	// Bit mask of MSTPB18 field.
	MSTP_MSTPCRB_MSTPB18_Msk = 0x40000
	// Bit MSTPB18.
	MSTP_MSTPCRB_MSTPB18 = 0x40000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB18_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB18_1 = 0x1
	// Position of MSTPB19 field.
	MSTP_MSTPCRB_MSTPB19_Pos = 0x13
	// Bit mask of MSTPB19 field.
	MSTP_MSTPCRB_MSTPB19_Msk = 0x80000
	// Bit MSTPB19.
	MSTP_MSTPCRB_MSTPB19 = 0x80000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB19_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB19_1 = 0x1
	// Position of MSTPB22 field.
	MSTP_MSTPCRB_MSTPB22_Pos = 0x16
	// Bit mask of MSTPB22 field.
	MSTP_MSTPCRB_MSTPB22_Msk = 0x400000
	// Bit MSTPB22.
	MSTP_MSTPCRB_MSTPB22 = 0x400000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB22_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB22_1 = 0x1
	// Position of MSTPB28 field.
	MSTP_MSTPCRB_MSTPB28_Pos = 0x1c
	// Bit mask of MSTPB28 field.
	MSTP_MSTPCRB_MSTPB28_Msk = 0x10000000
	// Bit MSTPB28.
	MSTP_MSTPCRB_MSTPB28 = 0x10000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB28_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB28_1 = 0x1
	// Position of MSTPB29 field.
	MSTP_MSTPCRB_MSTPB29_Pos = 0x1d
	// Bit mask of MSTPB29 field.
	MSTP_MSTPCRB_MSTPB29_Msk = 0x20000000
	// Bit MSTPB29.
	MSTP_MSTPCRB_MSTPB29 = 0x20000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB29_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB29_1 = 0x1
	// Position of MSTPB30 field.
	MSTP_MSTPCRB_MSTPB30_Pos = 0x1e
	// Bit mask of MSTPB30 field.
	MSTP_MSTPCRB_MSTPB30_Msk = 0x40000000
	// Bit MSTPB30.
	MSTP_MSTPCRB_MSTPB30 = 0x40000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB30_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB30_1 = 0x1
	// Position of MSTPB31 field.
	MSTP_MSTPCRB_MSTPB31_Pos = 0x1f
	// Bit mask of MSTPB31 field.
	MSTP_MSTPCRB_MSTPB31_Msk = 0x80000000
	// Bit MSTPB31.
	MSTP_MSTPCRB_MSTPB31 = 0x80000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB31_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB31_1 = 0x1

	// MSTPCRC: Module Stop Control Register C
	// Position of MSTPC0 field.
	MSTP_MSTPCRC_MSTPC0_Pos = 0x0
	// Bit mask of MSTPC0 field.
	MSTP_MSTPCRC_MSTPC0_Msk = 0x1
	// Bit MSTPC0.
	MSTP_MSTPCRC_MSTPC0 = 0x1
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC0_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC0_1 = 0x1
	// Position of MSTPC1 field.
	MSTP_MSTPCRC_MSTPC1_Pos = 0x1
	// Bit mask of MSTPC1 field.
	MSTP_MSTPCRC_MSTPC1_Msk = 0x2
	// Bit MSTPC1.
	MSTP_MSTPCRC_MSTPC1 = 0x2
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC1_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC1_1 = 0x1
	// Position of MSTPC3 field.
	MSTP_MSTPCRC_MSTPC3_Pos = 0x3
	// Bit mask of MSTPC3 field.
	MSTP_MSTPCRC_MSTPC3_Msk = 0x8
	// Bit MSTPC3.
	MSTP_MSTPCRC_MSTPC3 = 0x8
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC3_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC3_1 = 0x1
	// Position of MSTPC13 field.
	MSTP_MSTPCRC_MSTPC13_Pos = 0xd
	// Bit mask of MSTPC13 field.
	MSTP_MSTPCRC_MSTPC13_Msk = 0x2000
	// Bit MSTPC13.
	MSTP_MSTPCRC_MSTPC13 = 0x2000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC13_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC13_1 = 0x1
	// Position of MSTPC14 field.
	MSTP_MSTPCRC_MSTPC14_Pos = 0xe
	// Bit mask of MSTPC14 field.
	MSTP_MSTPCRC_MSTPC14_Msk = 0x4000
	// Bit MSTPC14.
	MSTP_MSTPCRC_MSTPC14 = 0x4000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC14_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC14_1 = 0x1
	// Position of MSTPC28 field.
	MSTP_MSTPCRC_MSTPC28_Pos = 0x1c
	// Bit mask of MSTPC28 field.
	MSTP_MSTPCRC_MSTPC28_Msk = 0x10000000
	// Bit MSTPC28.
	MSTP_MSTPCRC_MSTPC28 = 0x10000000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC28_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC28_1 = 0x1
	// Position of MSTPC31 field.
	MSTP_MSTPCRC_MSTPC31_Pos = 0x1f
	// Bit mask of MSTPC31 field.
	MSTP_MSTPCRC_MSTPC31_Msk = 0x80000000
	// Bit MSTPC31.
	MSTP_MSTPCRC_MSTPC31 = 0x80000000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC31_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC31_1 = 0x1

	// MSTPCRD: Module Stop Control Register D
	// Position of MSTPD2 field.
	MSTP_MSTPCRD_MSTPD2_Pos = 0x2
	// Bit mask of MSTPD2 field.
	MSTP_MSTPCRD_MSTPD2_Msk = 0x4
	// Bit MSTPD2.
	MSTP_MSTPCRD_MSTPD2 = 0x4
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD2_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD2_1 = 0x1
	// Position of MSTPD3 field.
	MSTP_MSTPCRD_MSTPD3_Pos = 0x3
	// Bit mask of MSTPD3 field.
	MSTP_MSTPCRD_MSTPD3_Msk = 0x8
	// Bit MSTPD3.
	MSTP_MSTPCRD_MSTPD3 = 0x8
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD3_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD3_1 = 0x1
	// Position of MSTPD5 field.
	MSTP_MSTPCRD_MSTPD5_Pos = 0x5
	// Bit mask of MSTPD5 field.
	MSTP_MSTPCRD_MSTPD5_Msk = 0x20
	// Bit MSTPD5.
	MSTP_MSTPCRD_MSTPD5 = 0x20
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD5_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD5_1 = 0x1
	// Position of MSTPD6 field.
	MSTP_MSTPCRD_MSTPD6_Pos = 0x6
	// Bit mask of MSTPD6 field.
	MSTP_MSTPCRD_MSTPD6_Msk = 0x40
	// Bit MSTPD6.
	MSTP_MSTPCRD_MSTPD6 = 0x40
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD6_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD6_1 = 0x1
	// Position of MSTPD14 field.
	MSTP_MSTPCRD_MSTPD14_Pos = 0xe
	// Bit mask of MSTPD14 field.
	MSTP_MSTPCRD_MSTPD14_Msk = 0x4000
	// Bit MSTPD14.
	MSTP_MSTPCRD_MSTPD14 = 0x4000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD14_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD14_1 = 0x1
	// Position of MSTPD16 field.
	MSTP_MSTPCRD_MSTPD16_Pos = 0x10
	// Bit mask of MSTPD16 field.
	MSTP_MSTPCRD_MSTPD16_Msk = 0x10000
	// Bit MSTPD16.
	MSTP_MSTPCRD_MSTPD16 = 0x10000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD16_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD16_1 = 0x1
	// Position of MSTPD20 field.
	MSTP_MSTPCRD_MSTPD20_Pos = 0x14
	// Bit mask of MSTPD20 field.
	MSTP_MSTPCRD_MSTPD20_Msk = 0x100000
	// Bit MSTPD20.
	MSTP_MSTPCRD_MSTPD20 = 0x100000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD20_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD20_1 = 0x1
	// Position of MSTPD29 field.
	MSTP_MSTPCRD_MSTPD29_Pos = 0x1d
	// Bit mask of MSTPD29 field.
	MSTP_MSTPCRD_MSTPD29_Msk = 0x20000000
	// Bit MSTPD29.
	MSTP_MSTPCRD_MSTPD29 = 0x20000000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD29_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD29_1 = 0x1

	// LSMRWDIS: Low Speed Module R/W Disable Control Register
	// Position of RTCRWDIS field.
	MSTP_LSMRWDIS_RTCRWDIS_Pos = 0x0
	// Bit mask of RTCRWDIS field.
	MSTP_LSMRWDIS_RTCRWDIS_Msk = 0x1
	// Bit RTCRWDIS.
	MSTP_LSMRWDIS_RTCRWDIS = 0x1
	// RTC register R/W clock always on
	MSTP_LSMRWDIS_RTCRWDIS_0 = 0x0
	// RTC register R/W clock stops
	MSTP_LSMRWDIS_RTCRWDIS_1 = 0x1
	// Position of WDTDIS field.
	MSTP_LSMRWDIS_WDTDIS_Pos = 0x1
	// Bit mask of WDTDIS field.
	MSTP_LSMRWDIS_WDTDIS_Msk = 0x2
	// Bit WDTDIS.
	MSTP_LSMRWDIS_WDTDIS = 0x2
	// WDT operates as normal
	MSTP_LSMRWDIS_WDTDIS_0 = 0x0
	// Stop the WDT clock and register R/W clock
	MSTP_LSMRWDIS_WDTDIS_1 = 0x1
	// Position of IWDTIDS field.
	MSTP_LSMRWDIS_IWDTIDS_Pos = 0x2
	// Bit mask of IWDTIDS field.
	MSTP_LSMRWDIS_IWDTIDS_Msk = 0x4
	// Bit IWDTIDS.
	MSTP_LSMRWDIS_IWDTIDS = 0x4
	// IWDT operates as normal
	MSTP_LSMRWDIS_IWDTIDS_0 = 0x0
	// Stop the IWDT register R/W clock
	MSTP_LSMRWDIS_IWDTIDS_1 = 0x1
	// Position of WREN field.
	MSTP_LSMRWDIS_WREN_Pos = 0x7
	// Bit mask of WREN field.
	MSTP_LSMRWDIS_WREN_Msk = 0x80
	// Bit WREN.
	MSTP_LSMRWDIS_WREN = 0x80
	// Write protect for bits [2:0]
	MSTP_LSMRWDIS_WREN_0 = 0x0
	// Write enable for bits [2:0]
	MSTP_LSMRWDIS_WREN_1 = 0x1
	// Position of PRKEY field.
	MSTP_LSMRWDIS_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	MSTP_LSMRWDIS_PRKEY_Msk = 0xff00
)

// Constants for CAN0: Controller Area Network
const (
	// MB0_ID: Mailbox ID Register %s
	// Position of EID field.
	CAN0_MB_ID_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_MB_ID_EID_Msk = 0x3ffff
	// Position of SID field.
	CAN0_MB_ID_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_MB_ID_SID_Msk = 0x1ffc0000
	// Position of RTR field.
	CAN0_MB_ID_RTR_Pos = 0x1e
	// Bit mask of RTR field.
	CAN0_MB_ID_RTR_Msk = 0x40000000
	// Bit RTR.
	CAN0_MB_ID_RTR = 0x40000000
	// Data frame
	CAN0_MB_ID_RTR_0 = 0x0
	// Remote frame
	CAN0_MB_ID_RTR_1 = 0x1
	// Position of IDE field.
	CAN0_MB_ID_IDE_Pos = 0x1f
	// Bit mask of IDE field.
	CAN0_MB_ID_IDE_Msk = 0x80000000
	// Bit IDE.
	CAN0_MB_ID_IDE = 0x80000000
	// Standard ID
	CAN0_MB_ID_IDE_0 = 0x0
	// Extended ID
	CAN0_MB_ID_IDE_1 = 0x1

	// MB0_DL: Mailbox Data Length Register %s
	// Position of DLC field.
	CAN0_MB_DL_DLC_Pos = 0x0
	// Bit mask of DLC field.
	CAN0_MB_DL_DLC_Msk = 0xf
	// Data length = 0 byte
	CAN0_MB_DL_DLC_0x0 = 0x0
	// Data length = 1 byte
	CAN0_MB_DL_DLC_0x1 = 0x1
	// Data length = 2 bytes
	CAN0_MB_DL_DLC_0x2 = 0x2
	// Data length = 3 bytes
	CAN0_MB_DL_DLC_0x3 = 0x3
	// Data length = 4 bytes
	CAN0_MB_DL_DLC_0x4 = 0x4
	// Data length = 5 bytes
	CAN0_MB_DL_DLC_0x5 = 0x5
	// Data length = 6 bytes
	CAN0_MB_DL_DLC_0x6 = 0x6
	// Data length = 7 bytes
	CAN0_MB_DL_DLC_0x7 = 0x7

	// MB0_D0: Mailbox Data Register %s
	// Position of DATA0 field.
	CAN0_MB_D0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	CAN0_MB_D0_DATA0_Msk = 0xff

	// MB0_D1: Mailbox Data Register %s
	// Position of DATA1 field.
	CAN0_MB_D1_DATA1_Pos = 0x0
	// Bit mask of DATA1 field.
	CAN0_MB_D1_DATA1_Msk = 0xff

	// MB0_D2: Mailbox Data Register %s
	// Position of DATA2 field.
	CAN0_MB_D2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	CAN0_MB_D2_DATA2_Msk = 0xff

	// MB0_D3: Mailbox Data Register %s
	// Position of DATA3 field.
	CAN0_MB_D3_DATA3_Pos = 0x0
	// Bit mask of DATA3 field.
	CAN0_MB_D3_DATA3_Msk = 0xff

	// MB0_D4: Mailbox Data Register %s
	// Position of DATA4 field.
	CAN0_MB_D4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	CAN0_MB_D4_DATA4_Msk = 0xff

	// MB0_D5: Mailbox Data Register %s
	// Position of DATA5 field.
	CAN0_MB_D5_DATA5_Pos = 0x0
	// Bit mask of DATA5 field.
	CAN0_MB_D5_DATA5_Msk = 0xff

	// MB0_D6: Mailbox Data Register %s
	// Position of DATA6 field.
	CAN0_MB_D6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	CAN0_MB_D6_DATA6_Msk = 0xff

	// MB0_D7: Mailbox Data Register %s
	// Position of DATA7 field.
	CAN0_MB_D7_DATA7_Pos = 0x0
	// Bit mask of DATA7 field.
	CAN0_MB_D7_DATA7_Msk = 0xff

	// MB0_TS: Mailbox Time Stamp Register %s
	// Position of TSL field.
	CAN0_MB_TS_TSL_Pos = 0x0
	// Bit mask of TSL field.
	CAN0_MB_TS_TSL_Msk = 0xff
	// Position of TSH field.
	CAN0_MB_TS_TSH_Pos = 0x8
	// Bit mask of TSH field.
	CAN0_MB_TS_TSH_Msk = 0xff00

	// MKR: Mask Register %s
	// Position of EID field.
	CAN0_MKR_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_MKR_EID_Msk = 0x3ffff
	// Do not compare associated EID[17:0] bits
	CAN0_MKR_EID_0 = 0x0
	// Compare associated EID[17:0] bits
	CAN0_MKR_EID_1 = 0x1
	// Position of SID field.
	CAN0_MKR_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_MKR_SID_Msk = 0x1ffc0000
	// Do not compare associated SID[10:0] bits
	CAN0_MKR_SID_0 = 0x0
	// Compare associated SID[10:0] bits
	CAN0_MKR_SID_1 = 0x1

	// FIDCR0: FIFO Received ID Compare Register %s
	// Position of EID field.
	CAN0_FIDCR_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_FIDCR_EID_Msk = 0x3ffff
	// Position of SID field.
	CAN0_FIDCR_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_FIDCR_SID_Msk = 0x1ffc0000
	// Position of RTR field.
	CAN0_FIDCR_RTR_Pos = 0x1e
	// Bit mask of RTR field.
	CAN0_FIDCR_RTR_Msk = 0x40000000
	// Bit RTR.
	CAN0_FIDCR_RTR = 0x40000000
	// Data frame
	CAN0_FIDCR_RTR_0 = 0x0
	// Remote frame
	CAN0_FIDCR_RTR_1 = 0x1
	// Position of IDE field.
	CAN0_FIDCR_IDE_Pos = 0x1f
	// Bit mask of IDE field.
	CAN0_FIDCR_IDE_Msk = 0x80000000
	// Bit IDE.
	CAN0_FIDCR_IDE = 0x80000000
	// Standard ID
	CAN0_FIDCR_IDE_0 = 0x0
	// Extended ID
	CAN0_FIDCR_IDE_1 = 0x1

	// MKIVLR: Mask Invalid Register
	// Position of MB00 field.
	CAN0_MKIVLR_MB00_Pos = 0x0
	// Bit mask of MB00 field.
	CAN0_MKIVLR_MB00_Msk = 0x1
	// Bit MB00.
	CAN0_MKIVLR_MB00 = 0x1
	// Mask valid
	CAN0_MKIVLR_MB00_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB00_1 = 0x1
	// Position of MB01 field.
	CAN0_MKIVLR_MB01_Pos = 0x1
	// Bit mask of MB01 field.
	CAN0_MKIVLR_MB01_Msk = 0x2
	// Bit MB01.
	CAN0_MKIVLR_MB01 = 0x2
	// Mask valid
	CAN0_MKIVLR_MB01_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB01_1 = 0x1
	// Position of MB02 field.
	CAN0_MKIVLR_MB02_Pos = 0x2
	// Bit mask of MB02 field.
	CAN0_MKIVLR_MB02_Msk = 0x4
	// Bit MB02.
	CAN0_MKIVLR_MB02 = 0x4
	// Mask valid
	CAN0_MKIVLR_MB02_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB02_1 = 0x1
	// Position of MB03 field.
	CAN0_MKIVLR_MB03_Pos = 0x3
	// Bit mask of MB03 field.
	CAN0_MKIVLR_MB03_Msk = 0x8
	// Bit MB03.
	CAN0_MKIVLR_MB03 = 0x8
	// Mask valid
	CAN0_MKIVLR_MB03_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB03_1 = 0x1
	// Position of MB04 field.
	CAN0_MKIVLR_MB04_Pos = 0x4
	// Bit mask of MB04 field.
	CAN0_MKIVLR_MB04_Msk = 0x10
	// Bit MB04.
	CAN0_MKIVLR_MB04 = 0x10
	// Mask valid
	CAN0_MKIVLR_MB04_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB04_1 = 0x1
	// Position of MB05 field.
	CAN0_MKIVLR_MB05_Pos = 0x5
	// Bit mask of MB05 field.
	CAN0_MKIVLR_MB05_Msk = 0x20
	// Bit MB05.
	CAN0_MKIVLR_MB05 = 0x20
	// Mask valid
	CAN0_MKIVLR_MB05_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB05_1 = 0x1
	// Position of MB06 field.
	CAN0_MKIVLR_MB06_Pos = 0x6
	// Bit mask of MB06 field.
	CAN0_MKIVLR_MB06_Msk = 0x40
	// Bit MB06.
	CAN0_MKIVLR_MB06 = 0x40
	// Mask valid
	CAN0_MKIVLR_MB06_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB06_1 = 0x1
	// Position of MB07 field.
	CAN0_MKIVLR_MB07_Pos = 0x7
	// Bit mask of MB07 field.
	CAN0_MKIVLR_MB07_Msk = 0x80
	// Bit MB07.
	CAN0_MKIVLR_MB07 = 0x80
	// Mask valid
	CAN0_MKIVLR_MB07_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB07_1 = 0x1
	// Position of MB08 field.
	CAN0_MKIVLR_MB08_Pos = 0x8
	// Bit mask of MB08 field.
	CAN0_MKIVLR_MB08_Msk = 0x100
	// Bit MB08.
	CAN0_MKIVLR_MB08 = 0x100
	// Mask valid
	CAN0_MKIVLR_MB08_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB08_1 = 0x1
	// Position of MB09 field.
	CAN0_MKIVLR_MB09_Pos = 0x9
	// Bit mask of MB09 field.
	CAN0_MKIVLR_MB09_Msk = 0x200
	// Bit MB09.
	CAN0_MKIVLR_MB09 = 0x200
	// Mask valid
	CAN0_MKIVLR_MB09_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB09_1 = 0x1
	// Position of MB10 field.
	CAN0_MKIVLR_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MKIVLR_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MKIVLR_MB10 = 0x400
	// Mask valid
	CAN0_MKIVLR_MB10_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB10_1 = 0x1
	// Position of MB11 field.
	CAN0_MKIVLR_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MKIVLR_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MKIVLR_MB11 = 0x800
	// Mask valid
	CAN0_MKIVLR_MB11_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB11_1 = 0x1
	// Position of MB12 field.
	CAN0_MKIVLR_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MKIVLR_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MKIVLR_MB12 = 0x1000
	// Mask valid
	CAN0_MKIVLR_MB12_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB12_1 = 0x1
	// Position of MB13 field.
	CAN0_MKIVLR_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MKIVLR_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MKIVLR_MB13 = 0x2000
	// Mask valid
	CAN0_MKIVLR_MB13_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB13_1 = 0x1
	// Position of MB14 field.
	CAN0_MKIVLR_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MKIVLR_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MKIVLR_MB14 = 0x4000
	// Mask valid
	CAN0_MKIVLR_MB14_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB14_1 = 0x1
	// Position of MB15 field.
	CAN0_MKIVLR_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MKIVLR_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MKIVLR_MB15 = 0x8000
	// Mask valid
	CAN0_MKIVLR_MB15_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB15_1 = 0x1
	// Position of MB16 field.
	CAN0_MKIVLR_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MKIVLR_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MKIVLR_MB16 = 0x10000
	// Mask valid
	CAN0_MKIVLR_MB16_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB16_1 = 0x1
	// Position of MB17 field.
	CAN0_MKIVLR_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MKIVLR_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MKIVLR_MB17 = 0x20000
	// Mask valid
	CAN0_MKIVLR_MB17_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB17_1 = 0x1
	// Position of MB18 field.
	CAN0_MKIVLR_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MKIVLR_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MKIVLR_MB18 = 0x40000
	// Mask valid
	CAN0_MKIVLR_MB18_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB18_1 = 0x1
	// Position of MB19 field.
	CAN0_MKIVLR_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MKIVLR_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MKIVLR_MB19 = 0x80000
	// Mask valid
	CAN0_MKIVLR_MB19_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB19_1 = 0x1
	// Position of MB20 field.
	CAN0_MKIVLR_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MKIVLR_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MKIVLR_MB20 = 0x100000
	// Mask valid
	CAN0_MKIVLR_MB20_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB20_1 = 0x1
	// Position of MB21 field.
	CAN0_MKIVLR_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MKIVLR_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MKIVLR_MB21 = 0x200000
	// Mask valid
	CAN0_MKIVLR_MB21_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB21_1 = 0x1
	// Position of MB22 field.
	CAN0_MKIVLR_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MKIVLR_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MKIVLR_MB22 = 0x400000
	// Mask valid
	CAN0_MKIVLR_MB22_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB22_1 = 0x1
	// Position of MB23 field.
	CAN0_MKIVLR_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MKIVLR_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MKIVLR_MB23 = 0x800000
	// Mask valid
	CAN0_MKIVLR_MB23_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB23_1 = 0x1
	// Position of MB24 field.
	CAN0_MKIVLR_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MKIVLR_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MKIVLR_MB24 = 0x1000000
	// Mask valid
	CAN0_MKIVLR_MB24_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB24_1 = 0x1
	// Position of MB25 field.
	CAN0_MKIVLR_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MKIVLR_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MKIVLR_MB25 = 0x2000000
	// Mask valid
	CAN0_MKIVLR_MB25_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB25_1 = 0x1
	// Position of MB26 field.
	CAN0_MKIVLR_MB26_Pos = 0x1a
	// Bit mask of MB26 field.
	CAN0_MKIVLR_MB26_Msk = 0x4000000
	// Bit MB26.
	CAN0_MKIVLR_MB26 = 0x4000000
	// Mask valid
	CAN0_MKIVLR_MB26_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB26_1 = 0x1
	// Position of MB27 field.
	CAN0_MKIVLR_MB27_Pos = 0x1b
	// Bit mask of MB27 field.
	CAN0_MKIVLR_MB27_Msk = 0x8000000
	// Bit MB27.
	CAN0_MKIVLR_MB27 = 0x8000000
	// Mask valid
	CAN0_MKIVLR_MB27_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB27_1 = 0x1
	// Position of MB28 field.
	CAN0_MKIVLR_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MKIVLR_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MKIVLR_MB28 = 0x10000000
	// Mask valid
	CAN0_MKIVLR_MB28_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB28_1 = 0x1
	// Position of MB29 field.
	CAN0_MKIVLR_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MKIVLR_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MKIVLR_MB29 = 0x20000000
	// Mask valid
	CAN0_MKIVLR_MB29_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB29_1 = 0x1
	// Position of MB30 field.
	CAN0_MKIVLR_MB30_Pos = 0x1e
	// Bit mask of MB30 field.
	CAN0_MKIVLR_MB30_Msk = 0x40000000
	// Bit MB30.
	CAN0_MKIVLR_MB30 = 0x40000000
	// Mask valid
	CAN0_MKIVLR_MB30_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB30_1 = 0x1
	// Position of MB31 field.
	CAN0_MKIVLR_MB31_Pos = 0x1f
	// Bit mask of MB31 field.
	CAN0_MKIVLR_MB31_Msk = 0x80000000
	// Bit MB31.
	CAN0_MKIVLR_MB31 = 0x80000000
	// Mask valid
	CAN0_MKIVLR_MB31_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB31_1 = 0x1

	// MIER: Mailbox Interrupt Enable Register
	// Position of MB00 field.
	CAN0_MIER_MB00_Pos = 0x0
	// Bit mask of MB00 field.
	CAN0_MIER_MB00_Msk = 0x1
	// Bit MB00.
	CAN0_MIER_MB00 = 0x1
	// Disable interrupt
	CAN0_MIER_MB00_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB00_1 = 0x1
	// Position of MB01 field.
	CAN0_MIER_MB01_Pos = 0x1
	// Bit mask of MB01 field.
	CAN0_MIER_MB01_Msk = 0x2
	// Bit MB01.
	CAN0_MIER_MB01 = 0x2
	// Disable interrupt
	CAN0_MIER_MB01_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB01_1 = 0x1
	// Position of MB02 field.
	CAN0_MIER_MB02_Pos = 0x2
	// Bit mask of MB02 field.
	CAN0_MIER_MB02_Msk = 0x4
	// Bit MB02.
	CAN0_MIER_MB02 = 0x4
	// Disable interrupt
	CAN0_MIER_MB02_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB02_1 = 0x1
	// Position of MB03 field.
	CAN0_MIER_MB03_Pos = 0x3
	// Bit mask of MB03 field.
	CAN0_MIER_MB03_Msk = 0x8
	// Bit MB03.
	CAN0_MIER_MB03 = 0x8
	// Disable interrupt
	CAN0_MIER_MB03_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB03_1 = 0x1
	// Position of MB04 field.
	CAN0_MIER_MB04_Pos = 0x4
	// Bit mask of MB04 field.
	CAN0_MIER_MB04_Msk = 0x10
	// Bit MB04.
	CAN0_MIER_MB04 = 0x10
	// Disable interrupt
	CAN0_MIER_MB04_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB04_1 = 0x1
	// Position of MB05 field.
	CAN0_MIER_MB05_Pos = 0x5
	// Bit mask of MB05 field.
	CAN0_MIER_MB05_Msk = 0x20
	// Bit MB05.
	CAN0_MIER_MB05 = 0x20
	// Disable interrupt
	CAN0_MIER_MB05_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB05_1 = 0x1
	// Position of MB06 field.
	CAN0_MIER_MB06_Pos = 0x6
	// Bit mask of MB06 field.
	CAN0_MIER_MB06_Msk = 0x40
	// Bit MB06.
	CAN0_MIER_MB06 = 0x40
	// Disable interrupt
	CAN0_MIER_MB06_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB06_1 = 0x1
	// Position of MB07 field.
	CAN0_MIER_MB07_Pos = 0x7
	// Bit mask of MB07 field.
	CAN0_MIER_MB07_Msk = 0x80
	// Bit MB07.
	CAN0_MIER_MB07 = 0x80
	// Disable interrupt
	CAN0_MIER_MB07_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB07_1 = 0x1
	// Position of MB08 field.
	CAN0_MIER_MB08_Pos = 0x8
	// Bit mask of MB08 field.
	CAN0_MIER_MB08_Msk = 0x100
	// Bit MB08.
	CAN0_MIER_MB08 = 0x100
	// Disable interrupt
	CAN0_MIER_MB08_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB08_1 = 0x1
	// Position of MB09 field.
	CAN0_MIER_MB09_Pos = 0x9
	// Bit mask of MB09 field.
	CAN0_MIER_MB09_Msk = 0x200
	// Bit MB09.
	CAN0_MIER_MB09 = 0x200
	// Disable interrupt
	CAN0_MIER_MB09_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB09_1 = 0x1
	// Position of MB10 field.
	CAN0_MIER_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MIER_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MIER_MB10 = 0x400
	// Disable interrupt
	CAN0_MIER_MB10_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB10_1 = 0x1
	// Position of MB11 field.
	CAN0_MIER_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MIER_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MIER_MB11 = 0x800
	// Disable interrupt
	CAN0_MIER_MB11_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB11_1 = 0x1
	// Position of MB12 field.
	CAN0_MIER_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MIER_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MIER_MB12 = 0x1000
	// Disable interrupt
	CAN0_MIER_MB12_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB12_1 = 0x1
	// Position of MB13 field.
	CAN0_MIER_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MIER_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MIER_MB13 = 0x2000
	// Disable interrupt
	CAN0_MIER_MB13_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB13_1 = 0x1
	// Position of MB14 field.
	CAN0_MIER_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MIER_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MIER_MB14 = 0x4000
	// Disable interrupt
	CAN0_MIER_MB14_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB14_1 = 0x1
	// Position of MB15 field.
	CAN0_MIER_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MIER_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MIER_MB15 = 0x8000
	// Disable interrupt
	CAN0_MIER_MB15_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB15_1 = 0x1
	// Position of MB16 field.
	CAN0_MIER_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MIER_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MIER_MB16 = 0x10000
	// Disable interrupt
	CAN0_MIER_MB16_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB16_1 = 0x1
	// Position of MB17 field.
	CAN0_MIER_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MIER_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MIER_MB17 = 0x20000
	// Disable interrupt
	CAN0_MIER_MB17_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB17_1 = 0x1
	// Position of MB18 field.
	CAN0_MIER_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MIER_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MIER_MB18 = 0x40000
	// Disable interrupt
	CAN0_MIER_MB18_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB18_1 = 0x1
	// Position of MB19 field.
	CAN0_MIER_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MIER_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MIER_MB19 = 0x80000
	// Disable interrupt
	CAN0_MIER_MB19_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB19_1 = 0x1
	// Position of MB20 field.
	CAN0_MIER_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MIER_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MIER_MB20 = 0x100000
	// Disable interrupt
	CAN0_MIER_MB20_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB20_1 = 0x1
	// Position of MB21 field.
	CAN0_MIER_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MIER_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MIER_MB21 = 0x200000
	// Disable interrupt
	CAN0_MIER_MB21_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB21_1 = 0x1
	// Position of MB22 field.
	CAN0_MIER_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MIER_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MIER_MB22 = 0x400000
	// Disable interrupt
	CAN0_MIER_MB22_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB22_1 = 0x1
	// Position of MB23 field.
	CAN0_MIER_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MIER_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MIER_MB23 = 0x800000
	// Disable interrupt
	CAN0_MIER_MB23_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB23_1 = 0x1
	// Position of MB24 field.
	CAN0_MIER_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MIER_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MIER_MB24 = 0x1000000
	// Disable interrupt
	CAN0_MIER_MB24_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB24_1 = 0x1
	// Position of MB25 field.
	CAN0_MIER_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MIER_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MIER_MB25 = 0x2000000
	// Disable interrupt
	CAN0_MIER_MB25_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB25_1 = 0x1
	// Position of MB26 field.
	CAN0_MIER_MB26_Pos = 0x1a
	// Bit mask of MB26 field.
	CAN0_MIER_MB26_Msk = 0x4000000
	// Bit MB26.
	CAN0_MIER_MB26 = 0x4000000
	// Disable interrupt
	CAN0_MIER_MB26_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB26_1 = 0x1
	// Position of MB27 field.
	CAN0_MIER_MB27_Pos = 0x1b
	// Bit mask of MB27 field.
	CAN0_MIER_MB27_Msk = 0x8000000
	// Bit MB27.
	CAN0_MIER_MB27 = 0x8000000
	// Disable interrupt
	CAN0_MIER_MB27_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB27_1 = 0x1
	// Position of MB28 field.
	CAN0_MIER_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MIER_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MIER_MB28 = 0x10000000
	// Disable interrupt
	CAN0_MIER_MB28_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB28_1 = 0x1
	// Position of MB29 field.
	CAN0_MIER_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MIER_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MIER_MB29 = 0x20000000
	// Disable interrupt
	CAN0_MIER_MB29_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB29_1 = 0x1
	// Position of MB30 field.
	CAN0_MIER_MB30_Pos = 0x1e
	// Bit mask of MB30 field.
	CAN0_MIER_MB30_Msk = 0x40000000
	// Bit MB30.
	CAN0_MIER_MB30 = 0x40000000
	// Disable interrupt
	CAN0_MIER_MB30_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB30_1 = 0x1
	// Position of MB31 field.
	CAN0_MIER_MB31_Pos = 0x1f
	// Bit mask of MB31 field.
	CAN0_MIER_MB31_Msk = 0x80000000
	// Bit MB31.
	CAN0_MIER_MB31 = 0x80000000
	// Disable interrupt
	CAN0_MIER_MB31_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB31_1 = 0x1

	// MIER_FIFO: Mailbox Interrupt Enable Register for FIFO Mailbox Mode
	// Position of MB00 field.
	CAN0_MIER_FIFO_MB00_Pos = 0x0
	// Bit mask of MB00 field.
	CAN0_MIER_FIFO_MB00_Msk = 0x1
	// Bit MB00.
	CAN0_MIER_FIFO_MB00 = 0x1
	// Disable interrupt
	CAN0_MIER_FIFO_MB00_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB00_1 = 0x1
	// Position of MB01 field.
	CAN0_MIER_FIFO_MB01_Pos = 0x1
	// Bit mask of MB01 field.
	CAN0_MIER_FIFO_MB01_Msk = 0x2
	// Bit MB01.
	CAN0_MIER_FIFO_MB01 = 0x2
	// Disable interrupt
	CAN0_MIER_FIFO_MB01_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB01_1 = 0x1
	// Position of MB02 field.
	CAN0_MIER_FIFO_MB02_Pos = 0x2
	// Bit mask of MB02 field.
	CAN0_MIER_FIFO_MB02_Msk = 0x4
	// Bit MB02.
	CAN0_MIER_FIFO_MB02 = 0x4
	// Disable interrupt
	CAN0_MIER_FIFO_MB02_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB02_1 = 0x1
	// Position of MB03 field.
	CAN0_MIER_FIFO_MB03_Pos = 0x3
	// Bit mask of MB03 field.
	CAN0_MIER_FIFO_MB03_Msk = 0x8
	// Bit MB03.
	CAN0_MIER_FIFO_MB03 = 0x8
	// Disable interrupt
	CAN0_MIER_FIFO_MB03_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB03_1 = 0x1
	// Position of MB04 field.
	CAN0_MIER_FIFO_MB04_Pos = 0x4
	// Bit mask of MB04 field.
	CAN0_MIER_FIFO_MB04_Msk = 0x10
	// Bit MB04.
	CAN0_MIER_FIFO_MB04 = 0x10
	// Disable interrupt
	CAN0_MIER_FIFO_MB04_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB04_1 = 0x1
	// Position of MB05 field.
	CAN0_MIER_FIFO_MB05_Pos = 0x5
	// Bit mask of MB05 field.
	CAN0_MIER_FIFO_MB05_Msk = 0x20
	// Bit MB05.
	CAN0_MIER_FIFO_MB05 = 0x20
	// Disable interrupt
	CAN0_MIER_FIFO_MB05_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB05_1 = 0x1
	// Position of MB06 field.
	CAN0_MIER_FIFO_MB06_Pos = 0x6
	// Bit mask of MB06 field.
	CAN0_MIER_FIFO_MB06_Msk = 0x40
	// Bit MB06.
	CAN0_MIER_FIFO_MB06 = 0x40
	// Disable interrupt
	CAN0_MIER_FIFO_MB06_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB06_1 = 0x1
	// Position of MB07 field.
	CAN0_MIER_FIFO_MB07_Pos = 0x7
	// Bit mask of MB07 field.
	CAN0_MIER_FIFO_MB07_Msk = 0x80
	// Bit MB07.
	CAN0_MIER_FIFO_MB07 = 0x80
	// Disable interrupt
	CAN0_MIER_FIFO_MB07_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB07_1 = 0x1
	// Position of MB08 field.
	CAN0_MIER_FIFO_MB08_Pos = 0x8
	// Bit mask of MB08 field.
	CAN0_MIER_FIFO_MB08_Msk = 0x100
	// Bit MB08.
	CAN0_MIER_FIFO_MB08 = 0x100
	// Disable interrupt
	CAN0_MIER_FIFO_MB08_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB08_1 = 0x1
	// Position of MB09 field.
	CAN0_MIER_FIFO_MB09_Pos = 0x9
	// Bit mask of MB09 field.
	CAN0_MIER_FIFO_MB09_Msk = 0x200
	// Bit MB09.
	CAN0_MIER_FIFO_MB09 = 0x200
	// Disable interrupt
	CAN0_MIER_FIFO_MB09_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB09_1 = 0x1
	// Position of MB10 field.
	CAN0_MIER_FIFO_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MIER_FIFO_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MIER_FIFO_MB10 = 0x400
	// Disable interrupt
	CAN0_MIER_FIFO_MB10_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB10_1 = 0x1
	// Position of MB11 field.
	CAN0_MIER_FIFO_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MIER_FIFO_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MIER_FIFO_MB11 = 0x800
	// Disable interrupt
	CAN0_MIER_FIFO_MB11_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB11_1 = 0x1
	// Position of MB12 field.
	CAN0_MIER_FIFO_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MIER_FIFO_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MIER_FIFO_MB12 = 0x1000
	// Disable interrupt
	CAN0_MIER_FIFO_MB12_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB12_1 = 0x1
	// Position of MB13 field.
	CAN0_MIER_FIFO_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MIER_FIFO_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MIER_FIFO_MB13 = 0x2000
	// Disable interrupt
	CAN0_MIER_FIFO_MB13_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB13_1 = 0x1
	// Position of MB14 field.
	CAN0_MIER_FIFO_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MIER_FIFO_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MIER_FIFO_MB14 = 0x4000
	// Disable interrupt
	CAN0_MIER_FIFO_MB14_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB14_1 = 0x1
	// Position of MB15 field.
	CAN0_MIER_FIFO_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MIER_FIFO_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MIER_FIFO_MB15 = 0x8000
	// Disable interrupt
	CAN0_MIER_FIFO_MB15_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB15_1 = 0x1
	// Position of MB16 field.
	CAN0_MIER_FIFO_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MIER_FIFO_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MIER_FIFO_MB16 = 0x10000
	// Disable interrupt
	CAN0_MIER_FIFO_MB16_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB16_1 = 0x1
	// Position of MB17 field.
	CAN0_MIER_FIFO_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MIER_FIFO_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MIER_FIFO_MB17 = 0x20000
	// Disable interrupt
	CAN0_MIER_FIFO_MB17_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB17_1 = 0x1
	// Position of MB18 field.
	CAN0_MIER_FIFO_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MIER_FIFO_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MIER_FIFO_MB18 = 0x40000
	// Disable interrupt
	CAN0_MIER_FIFO_MB18_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB18_1 = 0x1
	// Position of MB19 field.
	CAN0_MIER_FIFO_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MIER_FIFO_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MIER_FIFO_MB19 = 0x80000
	// Disable interrupt
	CAN0_MIER_FIFO_MB19_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB19_1 = 0x1
	// Position of MB20 field.
	CAN0_MIER_FIFO_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MIER_FIFO_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MIER_FIFO_MB20 = 0x100000
	// Disable interrupt
	CAN0_MIER_FIFO_MB20_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB20_1 = 0x1
	// Position of MB21 field.
	CAN0_MIER_FIFO_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MIER_FIFO_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MIER_FIFO_MB21 = 0x200000
	// Disable interrupt
	CAN0_MIER_FIFO_MB21_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB21_1 = 0x1
	// Position of MB22 field.
	CAN0_MIER_FIFO_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MIER_FIFO_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MIER_FIFO_MB22 = 0x400000
	// Disable interrupt
	CAN0_MIER_FIFO_MB22_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB22_1 = 0x1
	// Position of MB23 field.
	CAN0_MIER_FIFO_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MIER_FIFO_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MIER_FIFO_MB23 = 0x800000
	// Disable interrupt
	CAN0_MIER_FIFO_MB23_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB23_1 = 0x1
	// Position of MB24 field.
	CAN0_MIER_FIFO_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MIER_FIFO_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MIER_FIFO_MB24 = 0x1000000
	// Disable interrupt
	CAN0_MIER_FIFO_MB24_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB24_1 = 0x1
	// Position of MB25 field.
	CAN0_MIER_FIFO_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MIER_FIFO_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MIER_FIFO_MB25 = 0x2000000
	// Generate every time transmission completes
	CAN0_MIER_FIFO_MB25_0 = 0x0
	// Generate when the transmit FIFO empties on transmission completion
	CAN0_MIER_FIFO_MB25_1 = 0x1
	// Position of MB28 field.
	CAN0_MIER_FIFO_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MIER_FIFO_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MIER_FIFO_MB28 = 0x10000000
	// Disable interrupt
	CAN0_MIER_FIFO_MB28_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB28_1 = 0x1
	// Position of MB29 field.
	CAN0_MIER_FIFO_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MIER_FIFO_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MIER_FIFO_MB29 = 0x20000000
	// Generate every time reception completes
	CAN0_MIER_FIFO_MB29_0 = 0x0
	// Generate when the receive FIFO becomes a buffer warning on reception completion
	CAN0_MIER_FIFO_MB29_1 = 0x1

	// MCTL_RX: Message Control Register for Receive
	// Position of NEWDATA field.
	CAN0_MCTL_RX_NEWDATA_Pos = 0x0
	// Bit mask of NEWDATA field.
	CAN0_MCTL_RX_NEWDATA_Msk = 0x1
	// Bit NEWDATA.
	CAN0_MCTL_RX_NEWDATA = 0x1
	// No data received, or 0 was written to the flag
	CAN0_MCTL_RX_NEWDATA_0 = 0x0
	// New message being stored or was stored in the mailbox
	CAN0_MCTL_RX_NEWDATA_1 = 0x1
	// Position of INVALDATA field.
	CAN0_MCTL_RX_INVALDATA_Pos = 0x1
	// Bit mask of INVALDATA field.
	CAN0_MCTL_RX_INVALDATA_Msk = 0x2
	// Bit INVALDATA.
	CAN0_MCTL_RX_INVALDATA = 0x2
	// Message valid
	CAN0_MCTL_RX_INVALDATA_0 = 0x0
	// Message being updated
	CAN0_MCTL_RX_INVALDATA_1 = 0x1
	// Position of MSGLOST field.
	CAN0_MCTL_RX_MSGLOST_Pos = 0x2
	// Bit mask of MSGLOST field.
	CAN0_MCTL_RX_MSGLOST_Msk = 0x4
	// Bit MSGLOST.
	CAN0_MCTL_RX_MSGLOST = 0x4
	// Message not overwritten or overrun
	CAN0_MCTL_RX_MSGLOST_0 = 0x0
	// Message overwritten or overrun
	CAN0_MCTL_RX_MSGLOST_1 = 0x1
	// Position of ONESHOT field.
	CAN0_MCTL_RX_ONESHOT_Pos = 0x4
	// Bit mask of ONESHOT field.
	CAN0_MCTL_RX_ONESHOT_Msk = 0x10
	// Bit ONESHOT.
	CAN0_MCTL_RX_ONESHOT = 0x10
	// Disable one-shot reception
	CAN0_MCTL_RX_ONESHOT_0 = 0x0
	// Enable one-shot reception
	CAN0_MCTL_RX_ONESHOT_1 = 0x1
	// Position of RECREQ field.
	CAN0_MCTL_RX_RECREQ_Pos = 0x6
	// Bit mask of RECREQ field.
	CAN0_MCTL_RX_RECREQ_Msk = 0x40
	// Bit RECREQ.
	CAN0_MCTL_RX_RECREQ = 0x40
	// Do not configure for reception
	CAN0_MCTL_RX_RECREQ_0 = 0x0
	// Configure for reception
	CAN0_MCTL_RX_RECREQ_1 = 0x1
	// Position of TRMREQ field.
	CAN0_MCTL_RX_TRMREQ_Pos = 0x7
	// Bit mask of TRMREQ field.
	CAN0_MCTL_RX_TRMREQ_Msk = 0x80
	// Bit TRMREQ.
	CAN0_MCTL_RX_TRMREQ = 0x80
	// Do not configure for transmission
	CAN0_MCTL_RX_TRMREQ_0 = 0x0
	// Configure for transmission
	CAN0_MCTL_RX_TRMREQ_1 = 0x1

	// MCTL_TX: Message Control Register for Transmit
	// Position of SENTDATA field.
	CAN0_MCTL_TX_SENTDATA_Pos = 0x0
	// Bit mask of SENTDATA field.
	CAN0_MCTL_TX_SENTDATA_Msk = 0x1
	// Bit SENTDATA.
	CAN0_MCTL_TX_SENTDATA = 0x1
	// Transmission not complete
	CAN0_MCTL_TX_SENTDATA_0 = 0x0
	// Transmission complete
	CAN0_MCTL_TX_SENTDATA_1 = 0x1
	// Position of TRMACTIVE field.
	CAN0_MCTL_TX_TRMACTIVE_Pos = 0x1
	// Bit mask of TRMACTIVE field.
	CAN0_MCTL_TX_TRMACTIVE_Msk = 0x2
	// Bit TRMACTIVE.
	CAN0_MCTL_TX_TRMACTIVE = 0x2
	// Transmission pending or not requested
	CAN0_MCTL_TX_TRMACTIVE_0 = 0x0
	// Transmission in progress
	CAN0_MCTL_TX_TRMACTIVE_1 = 0x1
	// Position of TRMABT field.
	CAN0_MCTL_TX_TRMABT_Pos = 0x2
	// Bit mask of TRMABT field.
	CAN0_MCTL_TX_TRMABT_Msk = 0x4
	// Bit TRMABT.
	CAN0_MCTL_TX_TRMABT = 0x4
	// Transmission started, transmission abort failed because transmission completed, or transmission abort not requested
	CAN0_MCTL_TX_TRMABT_0 = 0x0
	// Transmission abort complete
	CAN0_MCTL_TX_TRMABT_1 = 0x1
	// Position of ONESHOT field.
	CAN0_MCTL_TX_ONESHOT_Pos = 0x4
	// Bit mask of ONESHOT field.
	CAN0_MCTL_TX_ONESHOT_Msk = 0x10
	// Bit ONESHOT.
	CAN0_MCTL_TX_ONESHOT = 0x10
	// Disable one-shot transmission
	CAN0_MCTL_TX_ONESHOT_0 = 0x0
	// Enable one-shot transmission
	CAN0_MCTL_TX_ONESHOT_1 = 0x1
	// Position of RECREQ field.
	CAN0_MCTL_TX_RECREQ_Pos = 0x6
	// Bit mask of RECREQ field.
	CAN0_MCTL_TX_RECREQ_Msk = 0x40
	// Bit RECREQ.
	CAN0_MCTL_TX_RECREQ = 0x40
	// Do not configure for reception
	CAN0_MCTL_TX_RECREQ_0 = 0x0
	// Configure for reception
	CAN0_MCTL_TX_RECREQ_1 = 0x1
	// Position of TRMREQ field.
	CAN0_MCTL_TX_TRMREQ_Pos = 0x7
	// Bit mask of TRMREQ field.
	CAN0_MCTL_TX_TRMREQ_Msk = 0x80
	// Bit TRMREQ.
	CAN0_MCTL_TX_TRMREQ = 0x80
	// Do not configure for transmission
	CAN0_MCTL_TX_TRMREQ_0 = 0x0
	// Configure for transmission
	CAN0_MCTL_TX_TRMREQ_1 = 0x1

	// CTLR: Control Register
	// Position of MBM field.
	CAN0_CTLR_MBM_Pos = 0x0
	// Bit mask of MBM field.
	CAN0_CTLR_MBM_Msk = 0x1
	// Bit MBM.
	CAN0_CTLR_MBM = 0x1
	// Normal mailbox mode
	CAN0_CTLR_MBM_0 = 0x0
	// FIFO mailbox mode
	CAN0_CTLR_MBM_1 = 0x1
	// Position of IDFM field.
	CAN0_CTLR_IDFM_Pos = 0x1
	// Bit mask of IDFM field.
	CAN0_CTLR_IDFM_Msk = 0x6
	// Standard ID mode All mailboxes, including FIFO mailboxes, handle only standard IDs
	CAN0_CTLR_IDFM_00 = 0x0
	// Extended ID mode All mailboxes, including FIFO mailboxes, handle only extended IDs
	CAN0_CTLR_IDFM_01 = 0x1
	// Mixed ID mode All mailboxes, including FIFO mailboxes, handle both standard and extended IDs. In normal mailbox mode, use the associated IDE bit to differentiate standard and extended IDs. In FIFO mailbox mode, the associated IDE bits are used for mailboxes 0 to 23, the IDE bits in FIDCR0 and FIDCR1 are used for the receive FIFO, and the IDE bit associated with mailbox 24 is used for the transmit FIFO.
	CAN0_CTLR_IDFM_10 = 0x2
	// Setting prohibited
	CAN0_CTLR_IDFM_11 = 0x3
	// Position of MLM field.
	CAN0_CTLR_MLM_Pos = 0x3
	// Bit mask of MLM field.
	CAN0_CTLR_MLM_Msk = 0x8
	// Bit MLM.
	CAN0_CTLR_MLM = 0x8
	// Overwrite mode
	CAN0_CTLR_MLM_0 = 0x0
	// Overrun mode
	CAN0_CTLR_MLM_1 = 0x1
	// Position of TPM field.
	CAN0_CTLR_TPM_Pos = 0x4
	// Bit mask of TPM field.
	CAN0_CTLR_TPM_Msk = 0x10
	// Bit TPM.
	CAN0_CTLR_TPM = 0x10
	// ID priority transmit mode
	CAN0_CTLR_TPM_0 = 0x0
	// Mailbox number priority transmit mode
	CAN0_CTLR_TPM_1 = 0x1
	// Position of TSRC field.
	CAN0_CTLR_TSRC_Pos = 0x5
	// Bit mask of TSRC field.
	CAN0_CTLR_TSRC_Msk = 0x20
	// Bit TSRC.
	CAN0_CTLR_TSRC = 0x20
	// Do not reset time stamp counter
	CAN0_CTLR_TSRC_0 = 0x0
	// Reset time stamp counter
	CAN0_CTLR_TSRC_1 = 0x1
	// Position of TSPS field.
	CAN0_CTLR_TSPS_Pos = 0x6
	// Bit mask of TSPS field.
	CAN0_CTLR_TSPS_Msk = 0xc0
	// Every 1-bit time
	CAN0_CTLR_TSPS_00 = 0x0
	// Every 2-bit time
	CAN0_CTLR_TSPS_01 = 0x1
	// Every 4-bit time
	CAN0_CTLR_TSPS_10 = 0x2
	// Every 8-bit time
	CAN0_CTLR_TSPS_11 = 0x3
	// Position of CANM field.
	CAN0_CTLR_CANM_Pos = 0x8
	// Bit mask of CANM field.
	CAN0_CTLR_CANM_Msk = 0x300
	// CAN operation mode
	CAN0_CTLR_CANM_00 = 0x0
	// CAN reset mode
	CAN0_CTLR_CANM_01 = 0x1
	// CAN halt mode
	CAN0_CTLR_CANM_10 = 0x2
	// CAN reset mode (forced transition)
	CAN0_CTLR_CANM_11 = 0x3
	// Position of SLPM field.
	CAN0_CTLR_SLPM_Pos = 0xa
	// Bit mask of SLPM field.
	CAN0_CTLR_SLPM_Msk = 0x400
	// Bit SLPM.
	CAN0_CTLR_SLPM = 0x400
	// All other modes
	CAN0_CTLR_SLPM_0 = 0x0
	// CAN sleep mode
	CAN0_CTLR_SLPM_1 = 0x1
	// Position of BOM field.
	CAN0_CTLR_BOM_Pos = 0xb
	// Bit mask of BOM field.
	CAN0_CTLR_BOM_Msk = 0x1800
	// Normal mode (ISO11898-1-compliant)
	CAN0_CTLR_BOM_00 = 0x0
	// Enter CAN halt mode automatically on entering bus-off state
	CAN0_CTLR_BOM_01 = 0x1
	// Enter CAN halt mode automatically at the end of bus-off state
	CAN0_CTLR_BOM_10 = 0x2
	// Enter CAN halt mode during bus-off recovery period through a software request
	CAN0_CTLR_BOM_11 = 0x3
	// Position of RBOC field.
	CAN0_CTLR_RBOC_Pos = 0xd
	// Bit mask of RBOC field.
	CAN0_CTLR_RBOC_Msk = 0x2000
	// Bit RBOC.
	CAN0_CTLR_RBOC = 0x2000
	// No return occurred
	CAN0_CTLR_RBOC_0 = 0x0
	// Forced return from bus-off state
	CAN0_CTLR_RBOC_1 = 0x1

	// STR: Status Register
	// Position of NDST field.
	CAN0_STR_NDST_Pos = 0x0
	// Bit mask of NDST field.
	CAN0_STR_NDST_Msk = 0x1
	// Bit NDST.
	CAN0_STR_NDST = 0x1
	// No mailbox with NEWDATA = 1
	CAN0_STR_NDST_0 = 0x0
	// One or more mailboxes with NEWDATA = 1
	CAN0_STR_NDST_1 = 0x1
	// Position of SDST field.
	CAN0_STR_SDST_Pos = 0x1
	// Bit mask of SDST field.
	CAN0_STR_SDST_Msk = 0x2
	// Bit SDST.
	CAN0_STR_SDST = 0x2
	// No mailbox with SENTDATA = 1
	CAN0_STR_SDST_0 = 0x0
	// One or more mailboxes with SENTDATA = 1
	CAN0_STR_SDST_1 = 0x1
	// Position of RFST field.
	CAN0_STR_RFST_Pos = 0x2
	// Bit mask of RFST field.
	CAN0_STR_RFST_Msk = 0x4
	// Bit RFST.
	CAN0_STR_RFST = 0x4
	// Receive FIFO empty
	CAN0_STR_RFST_0 = 0x0
	// Message in receive FIFO
	CAN0_STR_RFST_1 = 0x1
	// Position of TFST field.
	CAN0_STR_TFST_Pos = 0x3
	// Bit mask of TFST field.
	CAN0_STR_TFST_Msk = 0x8
	// Bit TFST.
	CAN0_STR_TFST = 0x8
	// Transmit FIFO is full
	CAN0_STR_TFST_0 = 0x0
	// Transmit FIFO is not full
	CAN0_STR_TFST_1 = 0x1
	// Position of NMLST field.
	CAN0_STR_NMLST_Pos = 0x4
	// Bit mask of NMLST field.
	CAN0_STR_NMLST_Msk = 0x10
	// Bit NMLST.
	CAN0_STR_NMLST = 0x10
	// No mailbox with MSGLOST = 1
	CAN0_STR_NMLST_0 = 0x0
	// One or more mailboxes with MSGLOST = 1
	CAN0_STR_NMLST_1 = 0x1
	// Position of FMLST field.
	CAN0_STR_FMLST_Pos = 0x5
	// Bit mask of FMLST field.
	CAN0_STR_FMLST_Msk = 0x20
	// Bit FMLST.
	CAN0_STR_FMLST = 0x20
	// RFMLF = 0
	CAN0_STR_FMLST_0 = 0x0
	// RFMLF = 1
	CAN0_STR_FMLST_1 = 0x1
	// Position of TABST field.
	CAN0_STR_TABST_Pos = 0x6
	// Bit mask of TABST field.
	CAN0_STR_TABST_Msk = 0x40
	// Bit TABST.
	CAN0_STR_TABST = 0x40
	// No mailbox with TRMABT = 1
	CAN0_STR_TABST_0 = 0x0
	// One or more mailboxes with TRMABT = 1
	CAN0_STR_TABST_1 = 0x1
	// Position of EST field.
	CAN0_STR_EST_Pos = 0x7
	// Bit mask of EST field.
	CAN0_STR_EST_Msk = 0x80
	// Bit EST.
	CAN0_STR_EST = 0x80
	// No error occurred
	CAN0_STR_EST_0 = 0x0
	// Error occurred
	CAN0_STR_EST_1 = 0x1
	// Position of RSTST field.
	CAN0_STR_RSTST_Pos = 0x8
	// Bit mask of RSTST field.
	CAN0_STR_RSTST_Msk = 0x100
	// Bit RSTST.
	CAN0_STR_RSTST = 0x100
	// Not in CAN reset mode
	CAN0_STR_RSTST_0 = 0x0
	// In CAN reset mode
	CAN0_STR_RSTST_1 = 0x1
	// Position of HLTST field.
	CAN0_STR_HLTST_Pos = 0x9
	// Bit mask of HLTST field.
	CAN0_STR_HLTST_Msk = 0x200
	// Bit HLTST.
	CAN0_STR_HLTST = 0x200
	// Not in CAN halt mode
	CAN0_STR_HLTST_0 = 0x0
	// In CAN halt mode
	CAN0_STR_HLTST_1 = 0x1
	// Position of SLPST field.
	CAN0_STR_SLPST_Pos = 0xa
	// Bit mask of SLPST field.
	CAN0_STR_SLPST_Msk = 0x400
	// Bit SLPST.
	CAN0_STR_SLPST = 0x400
	// Not in CAN sleep mode
	CAN0_STR_SLPST_0 = 0x0
	// In CAN sleep mode
	CAN0_STR_SLPST_1 = 0x1
	// Position of EPST field.
	CAN0_STR_EPST_Pos = 0xb
	// Bit mask of EPST field.
	CAN0_STR_EPST_Msk = 0x800
	// Bit EPST.
	CAN0_STR_EPST = 0x800
	// Not in error-passive state
	CAN0_STR_EPST_0 = 0x0
	// In error-passive state
	CAN0_STR_EPST_1 = 0x1
	// Position of BOST field.
	CAN0_STR_BOST_Pos = 0xc
	// Bit mask of BOST field.
	CAN0_STR_BOST_Msk = 0x1000
	// Bit BOST.
	CAN0_STR_BOST = 0x1000
	// Not in bus-off state
	CAN0_STR_BOST_0 = 0x0
	// In bus-off state
	CAN0_STR_BOST_1 = 0x1
	// Position of TRMST field.
	CAN0_STR_TRMST_Pos = 0xd
	// Bit mask of TRMST field.
	CAN0_STR_TRMST_Msk = 0x2000
	// Bit TRMST.
	CAN0_STR_TRMST = 0x2000
	// Bus idle or reception in progress
	CAN0_STR_TRMST_0 = 0x0
	// Transmission in progress or module in bus-off state
	CAN0_STR_TRMST_1 = 0x1
	// Position of RECST field.
	CAN0_STR_RECST_Pos = 0xe
	// Bit mask of RECST field.
	CAN0_STR_RECST_Msk = 0x4000
	// Bit RECST.
	CAN0_STR_RECST = 0x4000
	// Bus idle or transmission in progress
	CAN0_STR_RECST_0 = 0x0
	// Reception in progress
	CAN0_STR_RECST_1 = 0x1

	// BCR: Bit Configuration Register
	// Position of CCLKS field.
	CAN0_BCR_CCLKS_Pos = 0x0
	// Bit mask of CCLKS field.
	CAN0_BCR_CCLKS_Msk = 0x1
	// Bit CCLKS.
	CAN0_BCR_CCLKS = 0x1
	// Reserved
	CAN0_BCR_CCLKS_0 = 0x0
	// CANMCLK (generated by the main clock oscillator)
	CAN0_BCR_CCLKS_1 = 0x1
	// Position of TSEG2 field.
	CAN0_BCR_TSEG2_Pos = 0x8
	// Bit mask of TSEG2 field.
	CAN0_BCR_TSEG2_Msk = 0x700
	// Setting prohibited
	CAN0_BCR_TSEG2_000 = 0x0
	// 2 Tq
	CAN0_BCR_TSEG2_001 = 0x1
	// 3 Tq
	CAN0_BCR_TSEG2_010 = 0x2
	// 4 Tq
	CAN0_BCR_TSEG2_011 = 0x3
	// 5 Tq
	CAN0_BCR_TSEG2_100 = 0x4
	// 6 Tq
	CAN0_BCR_TSEG2_101 = 0x5
	// 7 Tq
	CAN0_BCR_TSEG2_110 = 0x6
	// 8 Tq
	CAN0_BCR_TSEG2_111 = 0x7
	// Position of SJW field.
	CAN0_BCR_SJW_Pos = 0xc
	// Bit mask of SJW field.
	CAN0_BCR_SJW_Msk = 0x3000
	// 1 Tq
	CAN0_BCR_SJW_00 = 0x0
	// 2 Tq
	CAN0_BCR_SJW_01 = 0x1
	// 3 Tq
	CAN0_BCR_SJW_10 = 0x2
	// 4 Tq
	CAN0_BCR_SJW_11 = 0x3
	// Position of BRP field.
	CAN0_BCR_BRP_Pos = 0x10
	// Bit mask of BRP field.
	CAN0_BCR_BRP_Msk = 0x3ff0000
	// Position of TSEG1 field.
	CAN0_BCR_TSEG1_Pos = 0x1c
	// Bit mask of TSEG1 field.
	CAN0_BCR_TSEG1_Msk = 0xf0000000
	// 4 Tq
	CAN0_BCR_TSEG1_0x3 = 0x3
	// 5 Tq
	CAN0_BCR_TSEG1_0x4 = 0x4
	// 6 Tq
	CAN0_BCR_TSEG1_0x5 = 0x5
	// 7 Tq
	CAN0_BCR_TSEG1_0x6 = 0x6
	// 8 Tq
	CAN0_BCR_TSEG1_0x7 = 0x7
	// 9 Tq
	CAN0_BCR_TSEG1_0x8 = 0x8
	// 10 Tq
	CAN0_BCR_TSEG1_0x9 = 0x9
	// 11 Tq
	CAN0_BCR_TSEG1_0xA = 0xa
	// 12 Tq
	CAN0_BCR_TSEG1_0xB = 0xb
	// 13 Tq
	CAN0_BCR_TSEG1_0xC = 0xc
	// 14 Tq
	CAN0_BCR_TSEG1_0xD = 0xd
	// 15 Tq
	CAN0_BCR_TSEG1_0xE = 0xe
	// 16 Tq
	CAN0_BCR_TSEG1_0xF = 0xf

	// RFCR: Receive FIFO Control Register
	// Position of RFE field.
	CAN0_RFCR_RFE_Pos = 0x0
	// Bit mask of RFE field.
	CAN0_RFCR_RFE_Msk = 0x1
	// Bit RFE.
	CAN0_RFCR_RFE = 0x1
	// Disable receive FIFO
	CAN0_RFCR_RFE_0 = 0x0
	// Enable receive FIFO
	CAN0_RFCR_RFE_1 = 0x1
	// Position of RFUST field.
	CAN0_RFCR_RFUST_Pos = 0x1
	// Bit mask of RFUST field.
	CAN0_RFCR_RFUST_Msk = 0xe
	// No unread message
	CAN0_RFCR_RFUST_000 = 0x0
	// 1 unread message
	CAN0_RFCR_RFUST_001 = 0x1
	// 2 unread messages
	CAN0_RFCR_RFUST_010 = 0x2
	// 3 unread messages
	CAN0_RFCR_RFUST_011 = 0x3
	// 4 unread messages
	CAN0_RFCR_RFUST_100 = 0x4
	// Reserved
	CAN0_RFCR_RFUST_101 = 0x5
	// Reserved
	CAN0_RFCR_RFUST_110 = 0x6
	// Reserved
	CAN0_RFCR_RFUST_111 = 0x7
	// Position of RFMLF field.
	CAN0_RFCR_RFMLF_Pos = 0x4
	// Bit mask of RFMLF field.
	CAN0_RFCR_RFMLF_Msk = 0x10
	// Bit RFMLF.
	CAN0_RFCR_RFMLF = 0x10
	// Receive FIFO message not lost
	CAN0_RFCR_RFMLF_0 = 0x0
	// Receive FIFO message lost
	CAN0_RFCR_RFMLF_1 = 0x1
	// Position of RFFST field.
	CAN0_RFCR_RFFST_Pos = 0x5
	// Bit mask of RFFST field.
	CAN0_RFCR_RFFST_Msk = 0x20
	// Bit RFFST.
	CAN0_RFCR_RFFST = 0x20
	// Receive FIFO not full
	CAN0_RFCR_RFFST_0 = 0x0
	// Receive FIFO full (4 unread messages)
	CAN0_RFCR_RFFST_1 = 0x1
	// Position of RFWST field.
	CAN0_RFCR_RFWST_Pos = 0x6
	// Bit mask of RFWST field.
	CAN0_RFCR_RFWST_Msk = 0x40
	// Bit RFWST.
	CAN0_RFCR_RFWST = 0x40
	// Receive FIFO is not buffer warning
	CAN0_RFCR_RFWST_0 = 0x0
	// Receive FIFO is buffer warning (3 unread messages)
	CAN0_RFCR_RFWST_1 = 0x1
	// Position of RFEST field.
	CAN0_RFCR_RFEST_Pos = 0x7
	// Bit mask of RFEST field.
	CAN0_RFCR_RFEST_Msk = 0x80
	// Bit RFEST.
	CAN0_RFCR_RFEST = 0x80
	// Unread message in receive FIFO
	CAN0_RFCR_RFEST_0 = 0x0
	// No unread message in receive FIFO
	CAN0_RFCR_RFEST_1 = 0x1

	// TFCR: Transmit FIFO Control Register
	// Position of TFE field.
	CAN0_TFCR_TFE_Pos = 0x0
	// Bit mask of TFE field.
	CAN0_TFCR_TFE_Msk = 0x1
	// Bit TFE.
	CAN0_TFCR_TFE = 0x1
	// Disable transmit FIFO
	CAN0_TFCR_TFE_0 = 0x0
	// Enable transmit FIFO
	CAN0_TFCR_TFE_1 = 0x1
	// Position of TFUST field.
	CAN0_TFCR_TFUST_Pos = 0x1
	// Bit mask of TFUST field.
	CAN0_TFCR_TFUST_Msk = 0xe
	// 0 unsent messages
	CAN0_TFCR_TFUST_000 = 0x0
	// 1 unsent message
	CAN0_TFCR_TFUST_001 = 0x1
	// 2 unsent messages
	CAN0_TFCR_TFUST_010 = 0x2
	// 3 unread messages
	CAN0_TFCR_TFUST_011 = 0x3
	// 4 unread messages
	CAN0_TFCR_TFUST_100 = 0x4
	// Reserved
	CAN0_TFCR_TFUST_101 = 0x5
	// Reserved
	CAN0_TFCR_TFUST_110 = 0x6
	// Reserved
	CAN0_TFCR_TFUST_111 = 0x7
	// Position of TFFST field.
	CAN0_TFCR_TFFST_Pos = 0x6
	// Bit mask of TFFST field.
	CAN0_TFCR_TFFST_Msk = 0x40
	// Bit TFFST.
	CAN0_TFCR_TFFST = 0x40
	// Transmit FIFO not full
	CAN0_TFCR_TFFST_0 = 0x0
	// Transmit FIFO full (4 unsent messages)
	CAN0_TFCR_TFFST_1 = 0x1
	// Position of TFEST field.
	CAN0_TFCR_TFEST_Pos = 0x7
	// Bit mask of TFEST field.
	CAN0_TFCR_TFEST_Msk = 0x80
	// Bit TFEST.
	CAN0_TFCR_TFEST = 0x80
	// Unsent message in transmit FIFO
	CAN0_TFCR_TFEST_0 = 0x0
	// No unsent message in transmit FIFO
	CAN0_TFCR_TFEST_1 = 0x1

	// EIER: Error Interrupt Enable Register
	// Position of BEIE field.
	CAN0_EIER_BEIE_Pos = 0x0
	// Bit mask of BEIE field.
	CAN0_EIER_BEIE_Msk = 0x1
	// Bit BEIE.
	CAN0_EIER_BEIE = 0x1
	// Disable interrupt
	CAN0_EIER_BEIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_BEIE_1 = 0x1
	// Position of EWIE field.
	CAN0_EIER_EWIE_Pos = 0x1
	// Bit mask of EWIE field.
	CAN0_EIER_EWIE_Msk = 0x2
	// Bit EWIE.
	CAN0_EIER_EWIE = 0x2
	// Disable interrupt
	CAN0_EIER_EWIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_EWIE_1 = 0x1
	// Position of EPIE field.
	CAN0_EIER_EPIE_Pos = 0x2
	// Bit mask of EPIE field.
	CAN0_EIER_EPIE_Msk = 0x4
	// Bit EPIE.
	CAN0_EIER_EPIE = 0x4
	// Disable interrupt
	CAN0_EIER_EPIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_EPIE_1 = 0x1
	// Position of BOEIE field.
	CAN0_EIER_BOEIE_Pos = 0x3
	// Bit mask of BOEIE field.
	CAN0_EIER_BOEIE_Msk = 0x8
	// Bit BOEIE.
	CAN0_EIER_BOEIE = 0x8
	// Disable interrupt
	CAN0_EIER_BOEIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_BOEIE_1 = 0x1
	// Position of BORIE field.
	CAN0_EIER_BORIE_Pos = 0x4
	// Bit mask of BORIE field.
	CAN0_EIER_BORIE_Msk = 0x10
	// Bit BORIE.
	CAN0_EIER_BORIE = 0x10
	// Disable interrupt
	CAN0_EIER_BORIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_BORIE_1 = 0x1
	// Position of ORIE field.
	CAN0_EIER_ORIE_Pos = 0x5
	// Bit mask of ORIE field.
	CAN0_EIER_ORIE_Msk = 0x20
	// Bit ORIE.
	CAN0_EIER_ORIE = 0x20
	// Disable interrupt
	CAN0_EIER_ORIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_ORIE_1 = 0x1
	// Position of OLIE field.
	CAN0_EIER_OLIE_Pos = 0x6
	// Bit mask of OLIE field.
	CAN0_EIER_OLIE_Msk = 0x40
	// Bit OLIE.
	CAN0_EIER_OLIE = 0x40
	// Disable interrupt
	CAN0_EIER_OLIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_OLIE_1 = 0x1
	// Position of BLIE field.
	CAN0_EIER_BLIE_Pos = 0x7
	// Bit mask of BLIE field.
	CAN0_EIER_BLIE_Msk = 0x80
	// Bit BLIE.
	CAN0_EIER_BLIE = 0x80
	// Disable interrupt
	CAN0_EIER_BLIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_BLIE_1 = 0x1

	// EIFR: Error Interrupt Factor Judge Register
	// Position of BEIF field.
	CAN0_EIFR_BEIF_Pos = 0x0
	// Bit mask of BEIF field.
	CAN0_EIFR_BEIF_Msk = 0x1
	// Bit BEIF.
	CAN0_EIFR_BEIF = 0x1
	// No bus error detected
	CAN0_EIFR_BEIF_0 = 0x0
	// Bus error detected
	CAN0_EIFR_BEIF_1 = 0x1
	// Position of EWIF field.
	CAN0_EIFR_EWIF_Pos = 0x1
	// Bit mask of EWIF field.
	CAN0_EIFR_EWIF_Msk = 0x2
	// Bit EWIF.
	CAN0_EIFR_EWIF = 0x2
	// No error-warning detected
	CAN0_EIFR_EWIF_0 = 0x0
	// Error-warning detected
	CAN0_EIFR_EWIF_1 = 0x1
	// Position of EPIF field.
	CAN0_EIFR_EPIF_Pos = 0x2
	// Bit mask of EPIF field.
	CAN0_EIFR_EPIF_Msk = 0x4
	// Bit EPIF.
	CAN0_EIFR_EPIF = 0x4
	// No error-passive detected
	CAN0_EIFR_EPIF_0 = 0x0
	// Error-passive detected
	CAN0_EIFR_EPIF_1 = 0x1
	// Position of BOEIF field.
	CAN0_EIFR_BOEIF_Pos = 0x3
	// Bit mask of BOEIF field.
	CAN0_EIFR_BOEIF_Msk = 0x8
	// Bit BOEIF.
	CAN0_EIFR_BOEIF = 0x8
	// No bus-off entry detected
	CAN0_EIFR_BOEIF_0 = 0x0
	// Bus-off entry detected
	CAN0_EIFR_BOEIF_1 = 0x1
	// Position of BORIF field.
	CAN0_EIFR_BORIF_Pos = 0x4
	// Bit mask of BORIF field.
	CAN0_EIFR_BORIF_Msk = 0x10
	// Bit BORIF.
	CAN0_EIFR_BORIF = 0x10
	// No bus-off recovery detected
	CAN0_EIFR_BORIF_0 = 0x0
	// Bus-off recovery detected
	CAN0_EIFR_BORIF_1 = 0x1
	// Position of ORIF field.
	CAN0_EIFR_ORIF_Pos = 0x5
	// Bit mask of ORIF field.
	CAN0_EIFR_ORIF_Msk = 0x20
	// Bit ORIF.
	CAN0_EIFR_ORIF = 0x20
	// No receive overrun detected
	CAN0_EIFR_ORIF_0 = 0x0
	// Receive overrun detected
	CAN0_EIFR_ORIF_1 = 0x1
	// Position of OLIF field.
	CAN0_EIFR_OLIF_Pos = 0x6
	// Bit mask of OLIF field.
	CAN0_EIFR_OLIF_Msk = 0x40
	// Bit OLIF.
	CAN0_EIFR_OLIF = 0x40
	// No overload frame transmission detected
	CAN0_EIFR_OLIF_0 = 0x0
	// Overload frame transmission detected
	CAN0_EIFR_OLIF_1 = 0x1
	// Position of BLIF field.
	CAN0_EIFR_BLIF_Pos = 0x7
	// Bit mask of BLIF field.
	CAN0_EIFR_BLIF_Msk = 0x80
	// Bit BLIF.
	CAN0_EIFR_BLIF = 0x80
	// No bus lock detected
	CAN0_EIFR_BLIF_0 = 0x0
	// Bus lock detected
	CAN0_EIFR_BLIF_1 = 0x1

	// ECSR: Error Code Store Register
	// Position of SEF field.
	CAN0_ECSR_SEF_Pos = 0x0
	// Bit mask of SEF field.
	CAN0_ECSR_SEF_Msk = 0x1
	// Bit SEF.
	CAN0_ECSR_SEF = 0x1
	// No stuff error detected
	CAN0_ECSR_SEF_0 = 0x0
	// Stuff error detected
	CAN0_ECSR_SEF_1 = 0x1
	// Position of FEF field.
	CAN0_ECSR_FEF_Pos = 0x1
	// Bit mask of FEF field.
	CAN0_ECSR_FEF_Msk = 0x2
	// Bit FEF.
	CAN0_ECSR_FEF = 0x2
	// No form error detected
	CAN0_ECSR_FEF_0 = 0x0
	// Form error detected
	CAN0_ECSR_FEF_1 = 0x1
	// Position of AEF field.
	CAN0_ECSR_AEF_Pos = 0x2
	// Bit mask of AEF field.
	CAN0_ECSR_AEF_Msk = 0x4
	// Bit AEF.
	CAN0_ECSR_AEF = 0x4
	// No ACK error detected
	CAN0_ECSR_AEF_0 = 0x0
	// ACK error detected
	CAN0_ECSR_AEF_1 = 0x1
	// Position of CEF field.
	CAN0_ECSR_CEF_Pos = 0x3
	// Bit mask of CEF field.
	CAN0_ECSR_CEF_Msk = 0x8
	// Bit CEF.
	CAN0_ECSR_CEF = 0x8
	// No CRC error detected
	CAN0_ECSR_CEF_0 = 0x0
	// CRC error detected
	CAN0_ECSR_CEF_1 = 0x1
	// Position of BE1F field.
	CAN0_ECSR_BE1F_Pos = 0x4
	// Bit mask of BE1F field.
	CAN0_ECSR_BE1F_Msk = 0x10
	// Bit BE1F.
	CAN0_ECSR_BE1F = 0x10
	// No bit error (recessive) detected
	CAN0_ECSR_BE1F_0 = 0x0
	// Bit error (recessive) detected
	CAN0_ECSR_BE1F_1 = 0x1
	// Position of BE0F field.
	CAN0_ECSR_BE0F_Pos = 0x5
	// Bit mask of BE0F field.
	CAN0_ECSR_BE0F_Msk = 0x20
	// Bit BE0F.
	CAN0_ECSR_BE0F = 0x20
	// No bit error (dominant) detected
	CAN0_ECSR_BE0F_0 = 0x0
	// Bit error (dominant) detected
	CAN0_ECSR_BE0F_1 = 0x1
	// Position of ADEF field.
	CAN0_ECSR_ADEF_Pos = 0x6
	// Bit mask of ADEF field.
	CAN0_ECSR_ADEF_Msk = 0x40
	// Bit ADEF.
	CAN0_ECSR_ADEF = 0x40
	// No ACK delimiter error detected
	CAN0_ECSR_ADEF_0 = 0x0
	// ACK delimiter error detected
	CAN0_ECSR_ADEF_1 = 0x1
	// Position of EDPM field.
	CAN0_ECSR_EDPM_Pos = 0x7
	// Bit mask of EDPM field.
	CAN0_ECSR_EDPM_Msk = 0x80
	// Bit EDPM.
	CAN0_ECSR_EDPM = 0x80
	// Output first detected error code
	CAN0_ECSR_EDPM_0 = 0x0
	// Output accumulated error code
	CAN0_ECSR_EDPM_1 = 0x1

	// MSSR: Mailbox Search Status Register
	// Position of MBNST field.
	CAN0_MSSR_MBNST_Pos = 0x0
	// Bit mask of MBNST field.
	CAN0_MSSR_MBNST_Msk = 0x1f
	// Position of SEST field.
	CAN0_MSSR_SEST_Pos = 0x7
	// Bit mask of SEST field.
	CAN0_MSSR_SEST_Msk = 0x80
	// Bit SEST.
	CAN0_MSSR_SEST = 0x80
	// Search result found
	CAN0_MSSR_SEST_0 = 0x0
	// No search result
	CAN0_MSSR_SEST_1 = 0x1

	// MSMR: Mailbox Search Mode Register
	// Position of MBSM field.
	CAN0_MSMR_MBSM_Pos = 0x0
	// Bit mask of MBSM field.
	CAN0_MSMR_MBSM_Msk = 0x3
	// Receive mailbox search mode
	CAN0_MSMR_MBSM_00 = 0x0
	// Transmit mailbox search mode
	CAN0_MSMR_MBSM_01 = 0x1
	// Message lost search mode
	CAN0_MSMR_MBSM_10 = 0x2
	// Channel search mode
	CAN0_MSMR_MBSM_11 = 0x3

	// TCR: Test Control Register
	// Position of TSTE field.
	CAN0_TCR_TSTE_Pos = 0x0
	// Bit mask of TSTE field.
	CAN0_TCR_TSTE_Msk = 0x1
	// Bit TSTE.
	CAN0_TCR_TSTE = 0x1
	// Disable CAN test mode
	CAN0_TCR_TSTE_0 = 0x0
	// Enable CAN test mode
	CAN0_TCR_TSTE_1 = 0x1
	// Position of TSTM field.
	CAN0_TCR_TSTM_Pos = 0x1
	// Bit mask of TSTM field.
	CAN0_TCR_TSTM_Msk = 0x6
	// Not CAN test mode
	CAN0_TCR_TSTM_00 = 0x0
	// Listen-only mode
	CAN0_TCR_TSTM_01 = 0x1
	// Self-test mode 0 (external loopback)
	CAN0_TCR_TSTM_10 = 0x2
	// Self-test mode 1 (internal loopback)
	CAN0_TCR_TSTM_11 = 0x3
)

// Constants for IIC0: Inter-Integrated Circuit 0
const (
	// ICCR1: I2C Bus Control Register 1
	// Position of SDAI field.
	IIC0_ICCR1_SDAI_Pos = 0x0
	// Bit mask of SDAI field.
	IIC0_ICCR1_SDAI_Msk = 0x1
	// Bit SDAI.
	IIC0_ICCR1_SDAI = 0x1
	// SDAn line is low
	IIC0_ICCR1_SDAI_0 = 0x0
	// SDAn line is high
	IIC0_ICCR1_SDAI_1 = 0x1
	// Position of SCLI field.
	IIC0_ICCR1_SCLI_Pos = 0x1
	// Bit mask of SCLI field.
	IIC0_ICCR1_SCLI_Msk = 0x2
	// Bit SCLI.
	IIC0_ICCR1_SCLI = 0x2
	// SCLn line is low
	IIC0_ICCR1_SCLI_0 = 0x0
	// SCLn line is high
	IIC0_ICCR1_SCLI_1 = 0x1
	// Position of SDAO field.
	IIC0_ICCR1_SDAO_Pos = 0x2
	// Bit mask of SDAO field.
	IIC0_ICCR1_SDAO_Msk = 0x4
	// Bit SDAO.
	IIC0_ICCR1_SDAO = 0x4
	// Read: IIC drives SDAn pin low Write: IIC drives SDAn pin low
	IIC0_ICCR1_SDAO_0 = 0x0
	// Read: IIC releases SDAn pin Write: IIC releases SDAn pin
	IIC0_ICCR1_SDAO_1 = 0x1
	// Position of SCLO field.
	IIC0_ICCR1_SCLO_Pos = 0x3
	// Bit mask of SCLO field.
	IIC0_ICCR1_SCLO_Msk = 0x8
	// Bit SCLO.
	IIC0_ICCR1_SCLO = 0x8
	// Read: IIC drives SCLn pin low Write: IIC drives SCLn pin low
	IIC0_ICCR1_SCLO_0 = 0x0
	// Read: IIC releases SCLn pin Write: IIC releases SCLn pin
	IIC0_ICCR1_SCLO_1 = 0x1
	// Position of SOWP field.
	IIC0_ICCR1_SOWP_Pos = 0x4
	// Bit mask of SOWP field.
	IIC0_ICCR1_SOWP_Msk = 0x10
	// Bit SOWP.
	IIC0_ICCR1_SOWP = 0x10
	// Write enable SCLO and SDAO bits
	IIC0_ICCR1_SOWP_0 = 0x0
	// Write protect SCLO and SDAO bits
	IIC0_ICCR1_SOWP_1 = 0x1
	// Position of CLO field.
	IIC0_ICCR1_CLO_Pos = 0x5
	// Bit mask of CLO field.
	IIC0_ICCR1_CLO_Msk = 0x20
	// Bit CLO.
	IIC0_ICCR1_CLO = 0x20
	// Do not output extra SCL clock cycle (default)
	IIC0_ICCR1_CLO_0 = 0x0
	// Output extra SCL clock cycle
	IIC0_ICCR1_CLO_1 = 0x1
	// Position of IICRST field.
	IIC0_ICCR1_IICRST_Pos = 0x6
	// Bit mask of IICRST field.
	IIC0_ICCR1_IICRST_Msk = 0x40
	// Bit IICRST.
	IIC0_ICCR1_IICRST = 0x40
	// Release IIC reset or internal reset
	IIC0_ICCR1_IICRST_0 = 0x0
	// Initiate IIC reset or internal reset
	IIC0_ICCR1_IICRST_1 = 0x1
	// Position of ICE field.
	IIC0_ICCR1_ICE_Pos = 0x7
	// Bit mask of ICE field.
	IIC0_ICCR1_ICE_Msk = 0x80
	// Bit ICE.
	IIC0_ICCR1_ICE = 0x80
	// Disable (SCLn and SDAn pins in inactive state)
	IIC0_ICCR1_ICE_0 = 0x0
	// Enable (SCLn and SDAn pins in active state)
	IIC0_ICCR1_ICE_1 = 0x1

	// ICCR2: I2C Bus Control Register 2
	// Position of ST field.
	IIC0_ICCR2_ST_Pos = 0x1
	// Bit mask of ST field.
	IIC0_ICCR2_ST_Msk = 0x2
	// Bit ST.
	IIC0_ICCR2_ST = 0x2
	// Do not issue a start condition request
	IIC0_ICCR2_ST_0 = 0x0
	// Issue a start condition request
	IIC0_ICCR2_ST_1 = 0x1
	// Position of RS field.
	IIC0_ICCR2_RS_Pos = 0x2
	// Bit mask of RS field.
	IIC0_ICCR2_RS_Msk = 0x4
	// Bit RS.
	IIC0_ICCR2_RS = 0x4
	// Do not issue a restart condition request
	IIC0_ICCR2_RS_0 = 0x0
	// Issue a restart condition request
	IIC0_ICCR2_RS_1 = 0x1
	// Position of SP field.
	IIC0_ICCR2_SP_Pos = 0x3
	// Bit mask of SP field.
	IIC0_ICCR2_SP_Msk = 0x8
	// Bit SP.
	IIC0_ICCR2_SP = 0x8
	// Do not issue a stop condition request
	IIC0_ICCR2_SP_0 = 0x0
	// Issue a stop condition request
	IIC0_ICCR2_SP_1 = 0x1
	// Position of TRS field.
	IIC0_ICCR2_TRS_Pos = 0x5
	// Bit mask of TRS field.
	IIC0_ICCR2_TRS_Msk = 0x20
	// Bit TRS.
	IIC0_ICCR2_TRS = 0x20
	// Receive mode
	IIC0_ICCR2_TRS_0 = 0x0
	// Transmit mode
	IIC0_ICCR2_TRS_1 = 0x1
	// Position of MST field.
	IIC0_ICCR2_MST_Pos = 0x6
	// Bit mask of MST field.
	IIC0_ICCR2_MST_Msk = 0x40
	// Bit MST.
	IIC0_ICCR2_MST = 0x40
	// Slave mode
	IIC0_ICCR2_MST_0 = 0x0
	// Master mode
	IIC0_ICCR2_MST_1 = 0x1
	// Position of BBSY field.
	IIC0_ICCR2_BBSY_Pos = 0x7
	// Bit mask of BBSY field.
	IIC0_ICCR2_BBSY_Msk = 0x80
	// Bit BBSY.
	IIC0_ICCR2_BBSY = 0x80
	// I2C bus released (bus free state)
	IIC0_ICCR2_BBSY_0 = 0x0
	// I2C bus occupied (bus busy state)
	IIC0_ICCR2_BBSY_1 = 0x1

	// ICMR1: I2C Bus Mode Register 1
	// Position of BC field.
	IIC0_ICMR1_BC_Pos = 0x0
	// Bit mask of BC field.
	IIC0_ICMR1_BC_Msk = 0x7
	// 9 bits
	IIC0_ICMR1_BC_000 = 0x0
	// 2 bits
	IIC0_ICMR1_BC_001 = 0x1
	// 3 bits
	IIC0_ICMR1_BC_010 = 0x2
	// 4 bits
	IIC0_ICMR1_BC_011 = 0x3
	// 5 bits
	IIC0_ICMR1_BC_100 = 0x4
	// 6 bits
	IIC0_ICMR1_BC_101 = 0x5
	// 7 bits
	IIC0_ICMR1_BC_110 = 0x6
	// 8 bits
	IIC0_ICMR1_BC_111 = 0x7
	// Position of BCWP field.
	IIC0_ICMR1_BCWP_Pos = 0x3
	// Bit mask of BCWP field.
	IIC0_ICMR1_BCWP_Msk = 0x8
	// Bit BCWP.
	IIC0_ICMR1_BCWP = 0x8
	// Write enable BC[2:0] bits
	IIC0_ICMR1_BCWP_0 = 0x0
	// Write protect BC[2:0] bits
	IIC0_ICMR1_BCWP_1 = 0x1
	// Position of CKS field.
	IIC0_ICMR1_CKS_Pos = 0x4
	// Bit mask of CKS field.
	IIC0_ICMR1_CKS_Msk = 0x70
	// Position of MTWP field.
	IIC0_ICMR1_MTWP_Pos = 0x7
	// Bit mask of MTWP field.
	IIC0_ICMR1_MTWP_Msk = 0x80
	// Bit MTWP.
	IIC0_ICMR1_MTWP = 0x80
	// Write protect MST and TRS bits in ICCR2
	IIC0_ICMR1_MTWP_0 = 0x0
	// Write enable MST and TRS bits in ICCR2
	IIC0_ICMR1_MTWP_1 = 0x1

	// ICMR2: I2C Bus Mode Register 2
	// Position of TMOS field.
	IIC0_ICMR2_TMOS_Pos = 0x0
	// Bit mask of TMOS field.
	IIC0_ICMR2_TMOS_Msk = 0x1
	// Bit TMOS.
	IIC0_ICMR2_TMOS = 0x1
	// Select long mode
	IIC0_ICMR2_TMOS_0 = 0x0
	// Select short mode
	IIC0_ICMR2_TMOS_1 = 0x1
	// Position of TMOL field.
	IIC0_ICMR2_TMOL_Pos = 0x1
	// Bit mask of TMOL field.
	IIC0_ICMR2_TMOL_Msk = 0x2
	// Bit TMOL.
	IIC0_ICMR2_TMOL = 0x2
	// Disable count while SCLn line is low
	IIC0_ICMR2_TMOL_0 = 0x0
	// Enable count while SCLn line is low
	IIC0_ICMR2_TMOL_1 = 0x1
	// Position of TMOH field.
	IIC0_ICMR2_TMOH_Pos = 0x2
	// Bit mask of TMOH field.
	IIC0_ICMR2_TMOH_Msk = 0x4
	// Bit TMOH.
	IIC0_ICMR2_TMOH = 0x4
	// Disable count while SCLn line is high
	IIC0_ICMR2_TMOH_0 = 0x0
	// Enable count while SCLn line is high
	IIC0_ICMR2_TMOH_1 = 0x1
	// Position of SDDL field.
	IIC0_ICMR2_SDDL_Pos = 0x4
	// Bit mask of SDDL field.
	IIC0_ICMR2_SDDL_Msk = 0x70
	// No output delay
	IIC0_ICMR2_SDDL_000 = 0x0
	// 1 IIC-phi cycle (When ICMR2.DLCS = 0 (IIC-phi)) 1 or 2 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_001 = 0x1
	// 2 IIC-phi cycles (When ICMR2.DLCS = 0 (IIC-phi)) 3 or 4 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_010 = 0x2
	// 3 IIC-phi cycles (When ICMR2.DLCS = 0 (IIC-phi)) 5 or 6 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_011 = 0x3
	// 4 IIC-phi cycles (When ICMR2.DLCS = 0 (IIC-phi)) 7 or 8 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_100 = 0x4
	// 5 IIC-phi cycles (When ICMR2.DLCS = 0 (IIC-phi)) 9 or 10 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_101 = 0x5
	// 6 IIC-phi cycles (When ICMR2.DLCS = 0 (IIC-phi)) 11 or 12 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_110 = 0x6
	// 7 IIC-phi cycles (When ICMR2.DLCS = 0 (IIC-phi)) 13 or 14 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_111 = 0x7
	// Position of DLCS field.
	IIC0_ICMR2_DLCS_Pos = 0x7
	// Bit mask of DLCS field.
	IIC0_ICMR2_DLCS_Msk = 0x80
	// Bit DLCS.
	IIC0_ICMR2_DLCS = 0x80
	// Select internal reference clock (IIC-phi) as the clock source for SDA output delay counter
	IIC0_ICMR2_DLCS_0 = 0x0
	// Select internal reference clock divided by 2 (IIC-phi/2) as the clock source for SDA output delay counter
	IIC0_ICMR2_DLCS_1 = 0x1

	// ICMR3: I2C Bus Mode Register 3
	// Position of NF field.
	IIC0_ICMR3_NF_Pos = 0x0
	// Bit mask of NF field.
	IIC0_ICMR3_NF_Msk = 0x3
	// Filter out noise of up to 1 IIC-phi cycle (single-stage filter)
	IIC0_ICMR3_NF_00 = 0x0
	// Filter out noise of up to 2 IIC-phi cycles (2-stage filter)
	IIC0_ICMR3_NF_01 = 0x1
	// Filter out noise of up to 3 IIC-phi cycles (3-stage filter)
	IIC0_ICMR3_NF_10 = 0x2
	// Filter out noise of up to 4 IIC-phi cycles (4-stage filter)
	IIC0_ICMR3_NF_11 = 0x3
	// Position of ACKBR field.
	IIC0_ICMR3_ACKBR_Pos = 0x2
	// Bit mask of ACKBR field.
	IIC0_ICMR3_ACKBR_Msk = 0x4
	// Bit ACKBR.
	IIC0_ICMR3_ACKBR = 0x4
	// 0 received as the acknowledge bit (ACK reception)
	IIC0_ICMR3_ACKBR_0 = 0x0
	// 1 received as the acknowledge bit (NACK reception)
	IIC0_ICMR3_ACKBR_1 = 0x1
	// Position of ACKBT field.
	IIC0_ICMR3_ACKBT_Pos = 0x3
	// Bit mask of ACKBT field.
	IIC0_ICMR3_ACKBT_Msk = 0x8
	// Bit ACKBT.
	IIC0_ICMR3_ACKBT = 0x8
	// Send 0 as the acknowledge bit (ACK transmission)
	IIC0_ICMR3_ACKBT_0 = 0x0
	// Send 1 as the acknowledge bit (NACK transmission)
	IIC0_ICMR3_ACKBT_1 = 0x1
	// Position of ACKWP field.
	IIC0_ICMR3_ACKWP_Pos = 0x4
	// Bit mask of ACKWP field.
	IIC0_ICMR3_ACKWP_Msk = 0x10
	// Bit ACKWP.
	IIC0_ICMR3_ACKWP = 0x10
	// Write protect ACKBT bit
	IIC0_ICMR3_ACKWP_0 = 0x0
	// Write enable ACKBT bit
	IIC0_ICMR3_ACKWP_1 = 0x1
	// Position of RDRFS field.
	IIC0_ICMR3_RDRFS_Pos = 0x5
	// Bit mask of RDRFS field.
	IIC0_ICMR3_RDRFS_Msk = 0x20
	// Bit RDRFS.
	IIC0_ICMR3_RDRFS = 0x20
	// Set the RDRF flag on the rising edge of the 9th SCL clock cycle. The SCLn line is not held low on the falling edge of the 8th clock cycle.
	IIC0_ICMR3_RDRFS_0 = 0x0
	// Set the RDRF flag on the rising edge of the 8th SCL clock cycle. The SCLn line is held low on the falling edge of the 8th clock cycle.
	IIC0_ICMR3_RDRFS_1 = 0x1
	// Position of WAIT field.
	IIC0_ICMR3_WAIT_Pos = 0x6
	// Bit mask of WAIT field.
	IIC0_ICMR3_WAIT_Msk = 0x40
	// Bit WAIT.
	IIC0_ICMR3_WAIT = 0x40
	// No wait (The SCLn line is not held low during the period between the 9th clock cycle and the 1st clock cycle.)
	IIC0_ICMR3_WAIT_0 = 0x0
	// Wait (The SCLn line is held low during the period between the 9th clock cycle and the 1st clock cycle.)
	IIC0_ICMR3_WAIT_1 = 0x1
	// Position of SMBS field.
	IIC0_ICMR3_SMBS_Pos = 0x7
	// Bit mask of SMBS field.
	IIC0_ICMR3_SMBS_Msk = 0x80
	// Bit SMBS.
	IIC0_ICMR3_SMBS = 0x80
	// Select I2C Bus
	IIC0_ICMR3_SMBS_0 = 0x0
	// Select SMBus
	IIC0_ICMR3_SMBS_1 = 0x1

	// ICFER: I2C Bus Function Enable Register
	// Position of TMOE field.
	IIC0_ICFER_TMOE_Pos = 0x0
	// Bit mask of TMOE field.
	IIC0_ICFER_TMOE_Msk = 0x1
	// Bit TMOE.
	IIC0_ICFER_TMOE = 0x1
	// Disable
	IIC0_ICFER_TMOE_0 = 0x0
	// Enable
	IIC0_ICFER_TMOE_1 = 0x1
	// Position of MALE field.
	IIC0_ICFER_MALE_Pos = 0x1
	// Bit mask of MALE field.
	IIC0_ICFER_MALE_Msk = 0x2
	// Bit MALE.
	IIC0_ICFER_MALE = 0x2
	// Disable the arbitration-lost detection function and disable automatic clearing of the MST and TRS bits in ICCR2 when arbitration is lost
	IIC0_ICFER_MALE_0 = 0x0
	// Enable the arbitration-lost detection function and enable automatic clearing of the MST and TRS bits in ICCR2 when arbitration is lost
	IIC0_ICFER_MALE_1 = 0x1
	// Position of NALE field.
	IIC0_ICFER_NALE_Pos = 0x2
	// Bit mask of NALE field.
	IIC0_ICFER_NALE_Msk = 0x4
	// Bit NALE.
	IIC0_ICFER_NALE = 0x4
	// Disable
	IIC0_ICFER_NALE_0 = 0x0
	// Enable
	IIC0_ICFER_NALE_1 = 0x1
	// Position of SALE field.
	IIC0_ICFER_SALE_Pos = 0x3
	// Bit mask of SALE field.
	IIC0_ICFER_SALE_Msk = 0x8
	// Bit SALE.
	IIC0_ICFER_SALE = 0x8
	// Disable
	IIC0_ICFER_SALE_0 = 0x0
	// Enable
	IIC0_ICFER_SALE_1 = 0x1
	// Position of NACKE field.
	IIC0_ICFER_NACKE_Pos = 0x4
	// Bit mask of NACKE field.
	IIC0_ICFER_NACKE_Msk = 0x10
	// Bit NACKE.
	IIC0_ICFER_NACKE = 0x10
	// Do not suspend transfer operation during NACK reception (disable transfer suspension)
	IIC0_ICFER_NACKE_0 = 0x0
	// Suspend transfer operation during NACK reception (enable transfer suspension)
	IIC0_ICFER_NACKE_1 = 0x1
	// Position of NFE field.
	IIC0_ICFER_NFE_Pos = 0x5
	// Bit mask of NFE field.
	IIC0_ICFER_NFE_Msk = 0x20
	// Bit NFE.
	IIC0_ICFER_NFE = 0x20
	// Do not use the digital noise filter circuit
	IIC0_ICFER_NFE_0 = 0x0
	// Use the digital noise filter circuit
	IIC0_ICFER_NFE_1 = 0x1
	// Position of SCLE field.
	IIC0_ICFER_SCLE_Pos = 0x6
	// Bit mask of SCLE field.
	IIC0_ICFER_SCLE_Msk = 0x40
	// Bit SCLE.
	IIC0_ICFER_SCLE = 0x40
	// Do not use the SCL synchronous circuit
	IIC0_ICFER_SCLE_0 = 0x0
	// Use the SCL synchronous circuit
	IIC0_ICFER_SCLE_1 = 0x1

	// ICSER: I2C Bus Status Enable Register
	// Position of SAR0E field.
	IIC0_ICSER_SAR0E_Pos = 0x0
	// Bit mask of SAR0E field.
	IIC0_ICSER_SAR0E_Msk = 0x1
	// Bit SAR0E.
	IIC0_ICSER_SAR0E = 0x1
	// Disable slave address in SARL0 and SARU0
	IIC0_ICSER_SAR0E_0 = 0x0
	// Enable slave address in SARL0 and SARU0
	IIC0_ICSER_SAR0E_1 = 0x1
	// Position of SAR1E field.
	IIC0_ICSER_SAR1E_Pos = 0x1
	// Bit mask of SAR1E field.
	IIC0_ICSER_SAR1E_Msk = 0x2
	// Bit SAR1E.
	IIC0_ICSER_SAR1E = 0x2
	// Disable slave address in SARL1 and SARU1
	IIC0_ICSER_SAR1E_0 = 0x0
	// Enable slave address in SARL1 and SARU1
	IIC0_ICSER_SAR1E_1 = 0x1
	// Position of SAR2E field.
	IIC0_ICSER_SAR2E_Pos = 0x2
	// Bit mask of SAR2E field.
	IIC0_ICSER_SAR2E_Msk = 0x4
	// Bit SAR2E.
	IIC0_ICSER_SAR2E = 0x4
	// Disable slave address in SARL2 and SARU2
	IIC0_ICSER_SAR2E_0 = 0x0
	// Enable slave address in SARL2 and SARU2
	IIC0_ICSER_SAR2E_1 = 0x1
	// Position of GCAE field.
	IIC0_ICSER_GCAE_Pos = 0x3
	// Bit mask of GCAE field.
	IIC0_ICSER_GCAE_Msk = 0x8
	// Bit GCAE.
	IIC0_ICSER_GCAE = 0x8
	// Disable general call address detection
	IIC0_ICSER_GCAE_0 = 0x0
	// Enable general call address detection
	IIC0_ICSER_GCAE_1 = 0x1
	// Position of DIDE field.
	IIC0_ICSER_DIDE_Pos = 0x5
	// Bit mask of DIDE field.
	IIC0_ICSER_DIDE_Msk = 0x20
	// Bit DIDE.
	IIC0_ICSER_DIDE = 0x20
	// Disable device-ID address detection
	IIC0_ICSER_DIDE_0 = 0x0
	// Enable device-ID address detection
	IIC0_ICSER_DIDE_1 = 0x1
	// Position of HOAE field.
	IIC0_ICSER_HOAE_Pos = 0x7
	// Bit mask of HOAE field.
	IIC0_ICSER_HOAE_Msk = 0x80
	// Bit HOAE.
	IIC0_ICSER_HOAE = 0x80
	// Disable host address detection
	IIC0_ICSER_HOAE_0 = 0x0
	// Enable host address detection
	IIC0_ICSER_HOAE_1 = 0x1

	// ICIER: I2C Bus Interrupt Enable Register
	// Position of TMOIE field.
	IIC0_ICIER_TMOIE_Pos = 0x0
	// Bit mask of TMOIE field.
	IIC0_ICIER_TMOIE_Msk = 0x1
	// Bit TMOIE.
	IIC0_ICIER_TMOIE = 0x1
	// Disable timeout interrupt (TMOI) request
	IIC0_ICIER_TMOIE_0 = 0x0
	// Enable timeout interrupt (TMOI) request
	IIC0_ICIER_TMOIE_1 = 0x1
	// Position of ALIE field.
	IIC0_ICIER_ALIE_Pos = 0x1
	// Bit mask of ALIE field.
	IIC0_ICIER_ALIE_Msk = 0x2
	// Bit ALIE.
	IIC0_ICIER_ALIE = 0x2
	// Disable arbitration-lost interrupt (ALI) request
	IIC0_ICIER_ALIE_0 = 0x0
	// Enable arbitration-lost interrupt (ALI) request
	IIC0_ICIER_ALIE_1 = 0x1
	// Position of STIE field.
	IIC0_ICIER_STIE_Pos = 0x2
	// Bit mask of STIE field.
	IIC0_ICIER_STIE_Msk = 0x4
	// Bit STIE.
	IIC0_ICIER_STIE = 0x4
	// Disable start condition detection interrupt (STI) request
	IIC0_ICIER_STIE_0 = 0x0
	// Enable start condition detection interrupt (STI) request
	IIC0_ICIER_STIE_1 = 0x1
	// Position of SPIE field.
	IIC0_ICIER_SPIE_Pos = 0x3
	// Bit mask of SPIE field.
	IIC0_ICIER_SPIE_Msk = 0x8
	// Bit SPIE.
	IIC0_ICIER_SPIE = 0x8
	// Disable stop condition detection interrupt (SPI) request
	IIC0_ICIER_SPIE_0 = 0x0
	// Enable stop condition detection interrupt (SPI) request
	IIC0_ICIER_SPIE_1 = 0x1
	// Position of NAKIE field.
	IIC0_ICIER_NAKIE_Pos = 0x4
	// Bit mask of NAKIE field.
	IIC0_ICIER_NAKIE_Msk = 0x10
	// Bit NAKIE.
	IIC0_ICIER_NAKIE = 0x10
	// Disable NACK reception interrupt (NAKI) request
	IIC0_ICIER_NAKIE_0 = 0x0
	// Enable NACK reception interrupt (NAKI) request
	IIC0_ICIER_NAKIE_1 = 0x1
	// Position of RIE field.
	IIC0_ICIER_RIE_Pos = 0x5
	// Bit mask of RIE field.
	IIC0_ICIER_RIE_Msk = 0x20
	// Bit RIE.
	IIC0_ICIER_RIE = 0x20
	// Disable receive data full interrupt (IICn_RXI) request
	IIC0_ICIER_RIE_0 = 0x0
	// Enable receive data full interrupt (IICn_RXI) request
	IIC0_ICIER_RIE_1 = 0x1
	// Position of TEIE field.
	IIC0_ICIER_TEIE_Pos = 0x6
	// Bit mask of TEIE field.
	IIC0_ICIER_TEIE_Msk = 0x40
	// Bit TEIE.
	IIC0_ICIER_TEIE = 0x40
	// Disable transmit end interrupt (IICn_TEI) request
	IIC0_ICIER_TEIE_0 = 0x0
	// Enable transmit end interrupt (IICn_TEI) request
	IIC0_ICIER_TEIE_1 = 0x1
	// Position of TIE field.
	IIC0_ICIER_TIE_Pos = 0x7
	// Bit mask of TIE field.
	IIC0_ICIER_TIE_Msk = 0x80
	// Bit TIE.
	IIC0_ICIER_TIE = 0x80
	// Disable transmit data empty interrupt (IICn_TXI) request
	IIC0_ICIER_TIE_0 = 0x0
	// Enable transmit data empty interrupt (IICn_TXI) request
	IIC0_ICIER_TIE_1 = 0x1

	// ICSR1: I2C Bus Status Register 1
	// Position of AAS0 field.
	IIC0_ICSR1_AAS0_Pos = 0x0
	// Bit mask of AAS0 field.
	IIC0_ICSR1_AAS0_Msk = 0x1
	// Bit AAS0.
	IIC0_ICSR1_AAS0 = 0x1
	// Slave address 0 not detected
	IIC0_ICSR1_AAS0_0 = 0x0
	// Slave address 0 detected
	IIC0_ICSR1_AAS0_1 = 0x1
	// Position of AAS1 field.
	IIC0_ICSR1_AAS1_Pos = 0x1
	// Bit mask of AAS1 field.
	IIC0_ICSR1_AAS1_Msk = 0x2
	// Bit AAS1.
	IIC0_ICSR1_AAS1 = 0x2
	// Slave address 1 not detected
	IIC0_ICSR1_AAS1_0 = 0x0
	// Slave address 1 detected
	IIC0_ICSR1_AAS1_1 = 0x1
	// Position of AAS2 field.
	IIC0_ICSR1_AAS2_Pos = 0x2
	// Bit mask of AAS2 field.
	IIC0_ICSR1_AAS2_Msk = 0x4
	// Bit AAS2.
	IIC0_ICSR1_AAS2 = 0x4
	// Slave address 2 not detected
	IIC0_ICSR1_AAS2_0 = 0x0
	// Slave address 2 detected
	IIC0_ICSR1_AAS2_1 = 0x1
	// Position of GCA field.
	IIC0_ICSR1_GCA_Pos = 0x3
	// Bit mask of GCA field.
	IIC0_ICSR1_GCA_Msk = 0x8
	// Bit GCA.
	IIC0_ICSR1_GCA = 0x8
	// General call address not detected
	IIC0_ICSR1_GCA_0 = 0x0
	// General call address detected
	IIC0_ICSR1_GCA_1 = 0x1
	// Position of DID field.
	IIC0_ICSR1_DID_Pos = 0x5
	// Bit mask of DID field.
	IIC0_ICSR1_DID_Msk = 0x20
	// Bit DID.
	IIC0_ICSR1_DID = 0x20
	// Device-ID command not detected
	IIC0_ICSR1_DID_0 = 0x0
	// Device-ID command detected
	IIC0_ICSR1_DID_1 = 0x1
	// Position of HOA field.
	IIC0_ICSR1_HOA_Pos = 0x7
	// Bit mask of HOA field.
	IIC0_ICSR1_HOA_Msk = 0x80
	// Bit HOA.
	IIC0_ICSR1_HOA = 0x80
	// Host address not detected
	IIC0_ICSR1_HOA_0 = 0x0
	// Host address detected
	IIC0_ICSR1_HOA_1 = 0x1

	// ICSR2: I2C Bus Status Register 2
	// Position of TMOF field.
	IIC0_ICSR2_TMOF_Pos = 0x0
	// Bit mask of TMOF field.
	IIC0_ICSR2_TMOF_Msk = 0x1
	// Bit TMOF.
	IIC0_ICSR2_TMOF = 0x1
	// Timeout not detected
	IIC0_ICSR2_TMOF_0 = 0x0
	// Timeout detected
	IIC0_ICSR2_TMOF_1 = 0x1
	// Position of AL field.
	IIC0_ICSR2_AL_Pos = 0x1
	// Bit mask of AL field.
	IIC0_ICSR2_AL_Msk = 0x2
	// Bit AL.
	IIC0_ICSR2_AL = 0x2
	// Arbitration not lost
	IIC0_ICSR2_AL_0 = 0x0
	// Arbitration lost
	IIC0_ICSR2_AL_1 = 0x1
	// Position of START field.
	IIC0_ICSR2_START_Pos = 0x2
	// Bit mask of START field.
	IIC0_ICSR2_START_Msk = 0x4
	// Bit START.
	IIC0_ICSR2_START = 0x4
	// Start condition not detected
	IIC0_ICSR2_START_0 = 0x0
	// Start condition detected
	IIC0_ICSR2_START_1 = 0x1
	// Position of STOP field.
	IIC0_ICSR2_STOP_Pos = 0x3
	// Bit mask of STOP field.
	IIC0_ICSR2_STOP_Msk = 0x8
	// Bit STOP.
	IIC0_ICSR2_STOP = 0x8
	// Stop condition not detected
	IIC0_ICSR2_STOP_0 = 0x0
	// Stop condition detected
	IIC0_ICSR2_STOP_1 = 0x1
	// Position of NACKF field.
	IIC0_ICSR2_NACKF_Pos = 0x4
	// Bit mask of NACKF field.
	IIC0_ICSR2_NACKF_Msk = 0x10
	// Bit NACKF.
	IIC0_ICSR2_NACKF = 0x10
	// NACK not detected
	IIC0_ICSR2_NACKF_0 = 0x0
	// NACK detected
	IIC0_ICSR2_NACKF_1 = 0x1
	// Position of RDRF field.
	IIC0_ICSR2_RDRF_Pos = 0x5
	// Bit mask of RDRF field.
	IIC0_ICSR2_RDRF_Msk = 0x20
	// Bit RDRF.
	IIC0_ICSR2_RDRF = 0x20
	// ICDRR contains no receive data
	IIC0_ICSR2_RDRF_0 = 0x0
	// ICDRR contains receive data
	IIC0_ICSR2_RDRF_1 = 0x1
	// Position of TEND field.
	IIC0_ICSR2_TEND_Pos = 0x6
	// Bit mask of TEND field.
	IIC0_ICSR2_TEND_Msk = 0x40
	// Bit TEND.
	IIC0_ICSR2_TEND = 0x40
	// Data being transmitted
	IIC0_ICSR2_TEND_0 = 0x0
	// Data transmit complete
	IIC0_ICSR2_TEND_1 = 0x1
	// Position of TDRE field.
	IIC0_ICSR2_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	IIC0_ICSR2_TDRE_Msk = 0x80
	// Bit TDRE.
	IIC0_ICSR2_TDRE = 0x80
	// ICDRT contains transmit data
	IIC0_ICSR2_TDRE_0 = 0x0
	// ICDRT contains no transmit data
	IIC0_ICSR2_TDRE_1 = 0x1

	// SARL0: Slave Address Register Ly
	// Position of SVA0 field.
	IIC0_SARL_SVA0_Pos = 0x0
	// Bit mask of SVA0 field.
	IIC0_SARL_SVA0_Msk = 0x1
	// Bit SVA0.
	IIC0_SARL_SVA0 = 0x1
	// Position of SVA field.
	IIC0_SARL_SVA_Pos = 0x1
	// Bit mask of SVA field.
	IIC0_SARL_SVA_Msk = 0xfe

	// SARU0: Slave Address Register Uy
	// Position of FS field.
	IIC0_SARU_FS_Pos = 0x0
	// Bit mask of FS field.
	IIC0_SARU_FS_Msk = 0x1
	// Bit FS.
	IIC0_SARU_FS = 0x1
	// Select 7-bit address format
	IIC0_SARU_FS_0 = 0x0
	// Select 10-bit address format
	IIC0_SARU_FS_1 = 0x1
	// Position of SVA field.
	IIC0_SARU_SVA_Pos = 0x1
	// Bit mask of SVA field.
	IIC0_SARU_SVA_Msk = 0x6

	// ICBRL: I2C Bus Bit Rate Low-Level Register
	// Position of BRL field.
	IIC0_ICBRL_BRL_Pos = 0x0
	// Bit mask of BRL field.
	IIC0_ICBRL_BRL_Msk = 0x1f

	// ICBRH: I2C Bus Bit Rate High-Level Register
	// Position of BRH field.
	IIC0_ICBRH_BRH_Pos = 0x0
	// Bit mask of BRH field.
	IIC0_ICBRH_BRH_Msk = 0x1f
)

// Constants for IIC0WU: Inter-Integrated Circuit 0 Wake-up Unit
const (
	// ICWUR: I2C Bus Wakeup Unit Register
	// Position of WUAFA field.
	IIC0WU_ICWUR_WUAFA_Pos = 0x0
	// Bit mask of WUAFA field.
	IIC0WU_ICWUR_WUAFA_Msk = 0x1
	// Bit WUAFA.
	IIC0WU_ICWUR_WUAFA = 0x1
	// Do not add the wakeup analog filter
	IIC0WU_ICWUR_WUAFA_0 = 0x0
	// Add the wakeup analog filter
	IIC0WU_ICWUR_WUAFA_1 = 0x1
	// Position of WUACK field.
	IIC0WU_ICWUR_WUACK_Pos = 0x4
	// Bit mask of WUACK field.
	IIC0WU_ICWUR_WUACK_Msk = 0x10
	// Bit WUACK.
	IIC0WU_ICWUR_WUACK = 0x10
	// Position of WUF field.
	IIC0WU_ICWUR_WUF_Pos = 0x5
	// Bit mask of WUF field.
	IIC0WU_ICWUR_WUF_Msk = 0x20
	// Bit WUF.
	IIC0WU_ICWUR_WUF = 0x20
	// Slave address not matching during wakeup
	IIC0WU_ICWUR_WUF_0 = 0x0
	// Slave address matching during wakeup
	IIC0WU_ICWUR_WUF_1 = 0x1
	// Position of WUIE field.
	IIC0WU_ICWUR_WUIE_Pos = 0x6
	// Bit mask of WUIE field.
	IIC0WU_ICWUR_WUIE_Msk = 0x40
	// Bit WUIE.
	IIC0WU_ICWUR_WUIE = 0x40
	// Disable wakeup interrupt request (IIC0_WUI)
	IIC0WU_ICWUR_WUIE_0 = 0x0
	// Enable wakeup interrupt request (IIC0_WUI)
	IIC0WU_ICWUR_WUIE_1 = 0x1
	// Position of WUE field.
	IIC0WU_ICWUR_WUE_Pos = 0x7
	// Bit mask of WUE field.
	IIC0WU_ICWUR_WUE_Msk = 0x80
	// Bit WUE.
	IIC0WU_ICWUR_WUE = 0x80
	// Disable wakeup function
	IIC0WU_ICWUR_WUE_0 = 0x0
	// Enable wakeup function
	IIC0WU_ICWUR_WUE_1 = 0x1

	// ICWUR2: I2C Bus Wakeup Unit Register 2
	// Position of WUSEN field.
	IIC0WU_ICWUR2_WUSEN_Pos = 0x0
	// Bit mask of WUSEN field.
	IIC0WU_ICWUR2_WUSEN_Msk = 0x1
	// Bit WUSEN.
	IIC0WU_ICWUR2_WUSEN = 0x1
	// IIC asynchronous circuit enable
	IIC0WU_ICWUR2_WUSEN_0 = 0x0
	// IIC synchronous circuit enable
	IIC0WU_ICWUR2_WUSEN_1 = 0x1
	// Position of WUASYF field.
	IIC0WU_ICWUR2_WUASYF_Pos = 0x1
	// Bit mask of WUASYF field.
	IIC0WU_ICWUR2_WUASYF_Msk = 0x2
	// Bit WUASYF.
	IIC0WU_ICWUR2_WUASYF = 0x2
	// IIC synchronous circuit enable condition
	IIC0WU_ICWUR2_WUASYF_0 = 0x0
	// IIC asynchronous circuit enable condition
	IIC0WU_ICWUR2_WUASYF_1 = 0x1
	// Position of WUSYF field.
	IIC0WU_ICWUR2_WUSYF_Pos = 0x2
	// Bit mask of WUSYF field.
	IIC0WU_ICWUR2_WUSYF_Msk = 0x4
	// Bit WUSYF.
	IIC0WU_ICWUR2_WUSYF = 0x4
	// IIC asynchronous circuit enable condition
	IIC0WU_ICWUR2_WUSYF_0 = 0x0
	// IIC synchronous circuit enable condition
	IIC0WU_ICWUR2_WUSYF_1 = 0x1
)

// Constants for DOC: Data Operation Circuit
const (
	// DOCR: DOC Control Register
	// Position of OMS field.
	DOC_DOCR_OMS_Pos = 0x0
	// Bit mask of OMS field.
	DOC_DOCR_OMS_Msk = 0x3
	// Data comparison mode
	DOC_DOCR_OMS_00 = 0x0
	// Data addition mode
	DOC_DOCR_OMS_01 = 0x1
	// Data subtraction mode
	DOC_DOCR_OMS_10 = 0x2
	// Setting prohibited
	DOC_DOCR_OMS_11 = 0x3
	// Position of DCSEL field.
	DOC_DOCR_DCSEL_Pos = 0x2
	// Bit mask of DCSEL field.
	DOC_DOCR_DCSEL_Msk = 0x4
	// Bit DCSEL.
	DOC_DOCR_DCSEL = 0x4
	// Set DOPCF flag when data mismatch is detected
	DOC_DOCR_DCSEL_0 = 0x0
	// Set DOPCF flag when data match is detected
	DOC_DOCR_DCSEL_1 = 0x1
	// Position of DOPCF field.
	DOC_DOCR_DOPCF_Pos = 0x5
	// Bit mask of DOPCF field.
	DOC_DOCR_DOPCF_Msk = 0x20
	// Bit DOPCF.
	DOC_DOCR_DOPCF = 0x20
	// Position of DOPCFCL field.
	DOC_DOCR_DOPCFCL_Pos = 0x6
	// Bit mask of DOPCFCL field.
	DOC_DOCR_DOPCFCL_Msk = 0x40
	// Bit DOPCFCL.
	DOC_DOCR_DOPCFCL = 0x40
	// Retain DOPCF flag state
	DOC_DOCR_DOPCFCL_0 = 0x0
	// Clear DOPCF flag
	DOC_DOCR_DOPCFCL_1 = 0x1
)

// Constants for ADC120: 12-bit A/D Converter
const (
	// ADCSR: A/D Control Register
	// Position of DBLANS field.
	ADC120_ADCSR_DBLANS_Pos = 0x0
	// Bit mask of DBLANS field.
	ADC120_ADCSR_DBLANS_Msk = 0x1f
	// Position of GBADIE field.
	ADC120_ADCSR_GBADIE_Pos = 0x6
	// Bit mask of GBADIE field.
	ADC120_ADCSR_GBADIE_Msk = 0x40
	// Bit GBADIE.
	ADC120_ADCSR_GBADIE = 0x40
	// Disable ADC120_GBADI interrupt generation on group B scan completion.
	ADC120_ADCSR_GBADIE_0 = 0x0
	// Enable ADC120_GBADI interrupt generation on group B scan completion.
	ADC120_ADCSR_GBADIE_1 = 0x1
	// Position of DBLE field.
	ADC120_ADCSR_DBLE_Pos = 0x7
	// Bit mask of DBLE field.
	ADC120_ADCSR_DBLE_Msk = 0x80
	// Bit DBLE.
	ADC120_ADCSR_DBLE = 0x80
	// Deselect double-trigger mode.
	ADC120_ADCSR_DBLE_0 = 0x0
	// Select double-trigger mode.
	ADC120_ADCSR_DBLE_1 = 0x1
	// Position of EXTRG field.
	ADC120_ADCSR_EXTRG_Pos = 0x8
	// Bit mask of EXTRG field.
	ADC120_ADCSR_EXTRG_Msk = 0x100
	// Bit EXTRG.
	ADC120_ADCSR_EXTRG = 0x100
	// Start A/D conversion by the synchronous trigger (ELC).
	ADC120_ADCSR_EXTRG_0 = 0x0
	// Start A/D conversion by the asynchronous trigger (ADTRG0).
	ADC120_ADCSR_EXTRG_1 = 0x1
	// Position of TRGE field.
	ADC120_ADCSR_TRGE_Pos = 0x9
	// Bit mask of TRGE field.
	ADC120_ADCSR_TRGE_Msk = 0x200
	// Bit TRGE.
	ADC120_ADCSR_TRGE = 0x200
	// Disable A/D conversion to be started by the synchronous or asynchronous trigger
	ADC120_ADCSR_TRGE_0 = 0x0
	// Enable A/D conversion to be started by the synchronous or asynchronous trigger
	ADC120_ADCSR_TRGE_1 = 0x1
	// Position of ADHSC field.
	ADC120_ADCSR_ADHSC_Pos = 0xa
	// Bit mask of ADHSC field.
	ADC120_ADCSR_ADHSC_Msk = 0x400
	// Bit ADHSC.
	ADC120_ADCSR_ADHSC = 0x400
	// High-speed A/D conversion mode
	ADC120_ADCSR_ADHSC_0 = 0x0
	// Low-power A/D conversion mode
	ADC120_ADCSR_ADHSC_1 = 0x1
	// Position of ADCS field.
	ADC120_ADCSR_ADCS_Pos = 0xd
	// Bit mask of ADCS field.
	ADC120_ADCSR_ADCS_Msk = 0x6000
	// Single scan mode
	ADC120_ADCSR_ADCS_00 = 0x0
	// Group scan mode
	ADC120_ADCSR_ADCS_01 = 0x1
	// Continuous scan mode
	ADC120_ADCSR_ADCS_10 = 0x2
	// Setting prohibited
	ADC120_ADCSR_ADCS_11 = 0x3
	// Position of ADST field.
	ADC120_ADCSR_ADST_Pos = 0xf
	// Bit mask of ADST field.
	ADC120_ADCSR_ADST_Msk = 0x8000
	// Bit ADST.
	ADC120_ADCSR_ADST = 0x8000
	// Stop A/D conversion process.
	ADC120_ADCSR_ADST_0 = 0x0
	// Start A/D conversion process.
	ADC120_ADCSR_ADST_1 = 0x1

	// ADANSA0: A/D Channel Select Register A0
	// Position of ANSA00 field.
	ADC120_ADANSA0_ANSA00_Pos = 0x0
	// Bit mask of ANSA00 field.
	ADC120_ADANSA0_ANSA00_Msk = 0x1
	// Bit ANSA00.
	ADC120_ADANSA0_ANSA00 = 0x1
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA00_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA00_1 = 0x1
	// Position of ANSA01 field.
	ADC120_ADANSA0_ANSA01_Pos = 0x1
	// Bit mask of ANSA01 field.
	ADC120_ADANSA0_ANSA01_Msk = 0x2
	// Bit ANSA01.
	ADC120_ADANSA0_ANSA01 = 0x2
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA01_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA01_1 = 0x1
	// Position of ANSA02 field.
	ADC120_ADANSA0_ANSA02_Pos = 0x2
	// Bit mask of ANSA02 field.
	ADC120_ADANSA0_ANSA02_Msk = 0x4
	// Bit ANSA02.
	ADC120_ADANSA0_ANSA02 = 0x4
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA02_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA02_1 = 0x1
	// Position of ANSA03 field.
	ADC120_ADANSA0_ANSA03_Pos = 0x3
	// Bit mask of ANSA03 field.
	ADC120_ADANSA0_ANSA03_Msk = 0x8
	// Bit ANSA03.
	ADC120_ADANSA0_ANSA03 = 0x8
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA03_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA03_1 = 0x1
	// Position of ANSA04 field.
	ADC120_ADANSA0_ANSA04_Pos = 0x4
	// Bit mask of ANSA04 field.
	ADC120_ADANSA0_ANSA04_Msk = 0x10
	// Bit ANSA04.
	ADC120_ADANSA0_ANSA04 = 0x10
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA04_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA04_1 = 0x1
	// Position of ANSA05 field.
	ADC120_ADANSA0_ANSA05_Pos = 0x5
	// Bit mask of ANSA05 field.
	ADC120_ADANSA0_ANSA05_Msk = 0x20
	// Bit ANSA05.
	ADC120_ADANSA0_ANSA05 = 0x20
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA05_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA05_1 = 0x1
	// Position of ANSA06 field.
	ADC120_ADANSA0_ANSA06_Pos = 0x6
	// Bit mask of ANSA06 field.
	ADC120_ADANSA0_ANSA06_Msk = 0x40
	// Bit ANSA06.
	ADC120_ADANSA0_ANSA06 = 0x40
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA06_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA06_1 = 0x1
	// Position of ANSA07 field.
	ADC120_ADANSA0_ANSA07_Pos = 0x7
	// Bit mask of ANSA07 field.
	ADC120_ADANSA0_ANSA07_Msk = 0x80
	// Bit ANSA07.
	ADC120_ADANSA0_ANSA07 = 0x80
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA07_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA07_1 = 0x1
	// Position of ANSA08 field.
	ADC120_ADANSA0_ANSA08_Pos = 0x8
	// Bit mask of ANSA08 field.
	ADC120_ADANSA0_ANSA08_Msk = 0x100
	// Bit ANSA08.
	ADC120_ADANSA0_ANSA08 = 0x100
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA08_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA08_1 = 0x1
	// Position of ANSA09 field.
	ADC120_ADANSA0_ANSA09_Pos = 0x9
	// Bit mask of ANSA09 field.
	ADC120_ADANSA0_ANSA09_Msk = 0x200
	// Bit ANSA09.
	ADC120_ADANSA0_ANSA09 = 0x200
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA09_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA09_1 = 0x1
	// Position of ANSA10 field.
	ADC120_ADANSA0_ANSA10_Pos = 0xa
	// Bit mask of ANSA10 field.
	ADC120_ADANSA0_ANSA10_Msk = 0x400
	// Bit ANSA10.
	ADC120_ADANSA0_ANSA10 = 0x400
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA10_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA10_1 = 0x1
	// Position of ANSA11 field.
	ADC120_ADANSA0_ANSA11_Pos = 0xb
	// Bit mask of ANSA11 field.
	ADC120_ADANSA0_ANSA11_Msk = 0x800
	// Bit ANSA11.
	ADC120_ADANSA0_ANSA11 = 0x800
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA11_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA11_1 = 0x1
	// Position of ANSA12 field.
	ADC120_ADANSA0_ANSA12_Pos = 0xc
	// Bit mask of ANSA12 field.
	ADC120_ADANSA0_ANSA12_Msk = 0x1000
	// Bit ANSA12.
	ADC120_ADANSA0_ANSA12 = 0x1000
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA12_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA12_1 = 0x1
	// Position of ANSA13 field.
	ADC120_ADANSA0_ANSA13_Pos = 0xd
	// Bit mask of ANSA13 field.
	ADC120_ADANSA0_ANSA13_Msk = 0x2000
	// Bit ANSA13.
	ADC120_ADANSA0_ANSA13 = 0x2000
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA13_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA13_1 = 0x1
	// Position of ANSA14 field.
	ADC120_ADANSA0_ANSA14_Pos = 0xe
	// Bit mask of ANSA14 field.
	ADC120_ADANSA0_ANSA14_Msk = 0x4000
	// Bit ANSA14.
	ADC120_ADANSA0_ANSA14 = 0x4000
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA14_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA14_1 = 0x1
	// Position of ANSA15 field.
	ADC120_ADANSA0_ANSA15_Pos = 0xf
	// Bit mask of ANSA15 field.
	ADC120_ADANSA0_ANSA15_Msk = 0x8000
	// Bit ANSA15.
	ADC120_ADANSA0_ANSA15 = 0x8000
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA15_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA15_1 = 0x1

	// ADANSA1: A/D Channel Select Register A1
	// Position of ANSA16 field.
	ADC120_ADANSA1_ANSA16_Pos = 0x0
	// Bit mask of ANSA16 field.
	ADC120_ADANSA1_ANSA16_Msk = 0x1
	// Bit ANSA16.
	ADC120_ADANSA1_ANSA16 = 0x1
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA16_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA16_1 = 0x1
	// Position of ANSA17 field.
	ADC120_ADANSA1_ANSA17_Pos = 0x1
	// Bit mask of ANSA17 field.
	ADC120_ADANSA1_ANSA17_Msk = 0x2
	// Bit ANSA17.
	ADC120_ADANSA1_ANSA17 = 0x2
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA17_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA17_1 = 0x1
	// Position of ANSA18 field.
	ADC120_ADANSA1_ANSA18_Pos = 0x2
	// Bit mask of ANSA18 field.
	ADC120_ADANSA1_ANSA18_Msk = 0x4
	// Bit ANSA18.
	ADC120_ADANSA1_ANSA18 = 0x4
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA18_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA18_1 = 0x1
	// Position of ANSA19 field.
	ADC120_ADANSA1_ANSA19_Pos = 0x3
	// Bit mask of ANSA19 field.
	ADC120_ADANSA1_ANSA19_Msk = 0x8
	// Bit ANSA19.
	ADC120_ADANSA1_ANSA19 = 0x8
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA19_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA19_1 = 0x1
	// Position of ANSA20 field.
	ADC120_ADANSA1_ANSA20_Pos = 0x4
	// Bit mask of ANSA20 field.
	ADC120_ADANSA1_ANSA20_Msk = 0x10
	// Bit ANSA20.
	ADC120_ADANSA1_ANSA20 = 0x10
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA20_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA20_1 = 0x1
	// Position of ANSA21 field.
	ADC120_ADANSA1_ANSA21_Pos = 0x5
	// Bit mask of ANSA21 field.
	ADC120_ADANSA1_ANSA21_Msk = 0x20
	// Bit ANSA21.
	ADC120_ADANSA1_ANSA21 = 0x20
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA21_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA21_1 = 0x1
	// Position of ANSA22 field.
	ADC120_ADANSA1_ANSA22_Pos = 0x6
	// Bit mask of ANSA22 field.
	ADC120_ADANSA1_ANSA22_Msk = 0x40
	// Bit ANSA22.
	ADC120_ADANSA1_ANSA22 = 0x40
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA22_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA22_1 = 0x1
	// Position of ANSA23 field.
	ADC120_ADANSA1_ANSA23_Pos = 0x7
	// Bit mask of ANSA23 field.
	ADC120_ADANSA1_ANSA23_Msk = 0x80
	// Bit ANSA23.
	ADC120_ADANSA1_ANSA23 = 0x80
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA23_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA23_1 = 0x1
	// Position of ANSA24 field.
	ADC120_ADANSA1_ANSA24_Pos = 0x8
	// Bit mask of ANSA24 field.
	ADC120_ADANSA1_ANSA24_Msk = 0x100
	// Bit ANSA24.
	ADC120_ADANSA1_ANSA24 = 0x100
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA24_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA24_1 = 0x1
	// Position of ANSA25 field.
	ADC120_ADANSA1_ANSA25_Pos = 0x9
	// Bit mask of ANSA25 field.
	ADC120_ADANSA1_ANSA25_Msk = 0x200
	// Bit ANSA25.
	ADC120_ADANSA1_ANSA25 = 0x200
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA25_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA25_1 = 0x1
	// Position of ANSA26 field.
	ADC120_ADANSA1_ANSA26_Pos = 0xa
	// Bit mask of ANSA26 field.
	ADC120_ADANSA1_ANSA26_Msk = 0x400
	// Bit ANSA26.
	ADC120_ADANSA1_ANSA26 = 0x400
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA26_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA26_1 = 0x1
	// Position of ANSA27 field.
	ADC120_ADANSA1_ANSA27_Pos = 0xb
	// Bit mask of ANSA27 field.
	ADC120_ADANSA1_ANSA27_Msk = 0x800
	// Bit ANSA27.
	ADC120_ADANSA1_ANSA27 = 0x800
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA27_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA27_1 = 0x1
	// Position of ANSA28 field.
	ADC120_ADANSA1_ANSA28_Pos = 0xc
	// Bit mask of ANSA28 field.
	ADC120_ADANSA1_ANSA28_Msk = 0x1000
	// Bit ANSA28.
	ADC120_ADANSA1_ANSA28 = 0x1000
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA28_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA28_1 = 0x1
	// Position of ANSA29 field.
	ADC120_ADANSA1_ANSA29_Pos = 0xd
	// Bit mask of ANSA29 field.
	ADC120_ADANSA1_ANSA29_Msk = 0x2000
	// Bit ANSA29.
	ADC120_ADANSA1_ANSA29 = 0x2000
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA29_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA29_1 = 0x1
	// Position of ANSA30 field.
	ADC120_ADANSA1_ANSA30_Pos = 0xe
	// Bit mask of ANSA30 field.
	ADC120_ADANSA1_ANSA30_Msk = 0x4000
	// Bit ANSA30.
	ADC120_ADANSA1_ANSA30 = 0x4000
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA30_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA30_1 = 0x1
	// Position of ANSA31 field.
	ADC120_ADANSA1_ANSA31_Pos = 0xf
	// Bit mask of ANSA31 field.
	ADC120_ADANSA1_ANSA31_Msk = 0x8000
	// Bit ANSA31.
	ADC120_ADANSA1_ANSA31 = 0x8000
	// Do not select associated input channel.
	ADC120_ADANSA1_ANSA31_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA1_ANSA31_1 = 0x1

	// ADADS0: A/D-Converted Value Addition/Average Channel Select Register 0
	// Position of ADS00 field.
	ADC120_ADADS0_ADS00_Pos = 0x0
	// Bit mask of ADS00 field.
	ADC120_ADADS0_ADS00_Msk = 0x1
	// Bit ADS00.
	ADC120_ADADS0_ADS00 = 0x1
	// Do not select associated input channel.
	ADC120_ADADS0_ADS00_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS00_1 = 0x1
	// Position of ADS01 field.
	ADC120_ADADS0_ADS01_Pos = 0x1
	// Bit mask of ADS01 field.
	ADC120_ADADS0_ADS01_Msk = 0x2
	// Bit ADS01.
	ADC120_ADADS0_ADS01 = 0x2
	// Do not select associated input channel.
	ADC120_ADADS0_ADS01_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS01_1 = 0x1
	// Position of ADS02 field.
	ADC120_ADADS0_ADS02_Pos = 0x2
	// Bit mask of ADS02 field.
	ADC120_ADADS0_ADS02_Msk = 0x4
	// Bit ADS02.
	ADC120_ADADS0_ADS02 = 0x4
	// Do not select associated input channel.
	ADC120_ADADS0_ADS02_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS02_1 = 0x1
	// Position of ADS03 field.
	ADC120_ADADS0_ADS03_Pos = 0x3
	// Bit mask of ADS03 field.
	ADC120_ADADS0_ADS03_Msk = 0x8
	// Bit ADS03.
	ADC120_ADADS0_ADS03 = 0x8
	// Do not select associated input channel.
	ADC120_ADADS0_ADS03_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS03_1 = 0x1
	// Position of ADS04 field.
	ADC120_ADADS0_ADS04_Pos = 0x4
	// Bit mask of ADS04 field.
	ADC120_ADADS0_ADS04_Msk = 0x10
	// Bit ADS04.
	ADC120_ADADS0_ADS04 = 0x10
	// Do not select associated input channel.
	ADC120_ADADS0_ADS04_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS04_1 = 0x1
	// Position of ADS05 field.
	ADC120_ADADS0_ADS05_Pos = 0x5
	// Bit mask of ADS05 field.
	ADC120_ADADS0_ADS05_Msk = 0x20
	// Bit ADS05.
	ADC120_ADADS0_ADS05 = 0x20
	// Do not select associated input channel.
	ADC120_ADADS0_ADS05_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS05_1 = 0x1
	// Position of ADS06 field.
	ADC120_ADADS0_ADS06_Pos = 0x6
	// Bit mask of ADS06 field.
	ADC120_ADADS0_ADS06_Msk = 0x40
	// Bit ADS06.
	ADC120_ADADS0_ADS06 = 0x40
	// Do not select associated input channel.
	ADC120_ADADS0_ADS06_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS06_1 = 0x1
	// Position of ADS07 field.
	ADC120_ADADS0_ADS07_Pos = 0x7
	// Bit mask of ADS07 field.
	ADC120_ADADS0_ADS07_Msk = 0x80
	// Bit ADS07.
	ADC120_ADADS0_ADS07 = 0x80
	// Do not select associated input channel.
	ADC120_ADADS0_ADS07_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS07_1 = 0x1
	// Position of ADS08 field.
	ADC120_ADADS0_ADS08_Pos = 0x8
	// Bit mask of ADS08 field.
	ADC120_ADADS0_ADS08_Msk = 0x100
	// Bit ADS08.
	ADC120_ADADS0_ADS08 = 0x100
	// Do not select associated input channel.
	ADC120_ADADS0_ADS08_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS08_1 = 0x1
	// Position of ADS09 field.
	ADC120_ADADS0_ADS09_Pos = 0x9
	// Bit mask of ADS09 field.
	ADC120_ADADS0_ADS09_Msk = 0x200
	// Bit ADS09.
	ADC120_ADADS0_ADS09 = 0x200
	// Do not select associated input channel.
	ADC120_ADADS0_ADS09_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS09_1 = 0x1
	// Position of ADS10 field.
	ADC120_ADADS0_ADS10_Pos = 0xa
	// Bit mask of ADS10 field.
	ADC120_ADADS0_ADS10_Msk = 0x400
	// Bit ADS10.
	ADC120_ADADS0_ADS10 = 0x400
	// Do not select associated input channel.
	ADC120_ADADS0_ADS10_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS10_1 = 0x1
	// Position of ADS11 field.
	ADC120_ADADS0_ADS11_Pos = 0xb
	// Bit mask of ADS11 field.
	ADC120_ADADS0_ADS11_Msk = 0x800
	// Bit ADS11.
	ADC120_ADADS0_ADS11 = 0x800
	// Do not select associated input channel.
	ADC120_ADADS0_ADS11_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS11_1 = 0x1
	// Position of ADS12 field.
	ADC120_ADADS0_ADS12_Pos = 0xc
	// Bit mask of ADS12 field.
	ADC120_ADADS0_ADS12_Msk = 0x1000
	// Bit ADS12.
	ADC120_ADADS0_ADS12 = 0x1000
	// Do not select associated input channel.
	ADC120_ADADS0_ADS12_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS12_1 = 0x1
	// Position of ADS13 field.
	ADC120_ADADS0_ADS13_Pos = 0xd
	// Bit mask of ADS13 field.
	ADC120_ADADS0_ADS13_Msk = 0x2000
	// Bit ADS13.
	ADC120_ADADS0_ADS13 = 0x2000
	// Do not select associated input channel.
	ADC120_ADADS0_ADS13_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS13_1 = 0x1
	// Position of ADS14 field.
	ADC120_ADADS0_ADS14_Pos = 0xe
	// Bit mask of ADS14 field.
	ADC120_ADADS0_ADS14_Msk = 0x4000
	// Bit ADS14.
	ADC120_ADADS0_ADS14 = 0x4000
	// Do not select associated input channel.
	ADC120_ADADS0_ADS14_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS14_1 = 0x1
	// Position of ADS15 field.
	ADC120_ADADS0_ADS15_Pos = 0xf
	// Bit mask of ADS15 field.
	ADC120_ADADS0_ADS15_Msk = 0x8000
	// Bit ADS15.
	ADC120_ADADS0_ADS15 = 0x8000
	// Do not select associated input channel.
	ADC120_ADADS0_ADS15_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS15_1 = 0x1

	// ADADS1: A/D-Converted Value Addition/Average Channel Select Register 1
	// Position of ADS16 field.
	ADC120_ADADS1_ADS16_Pos = 0x0
	// Bit mask of ADS16 field.
	ADC120_ADADS1_ADS16_Msk = 0x1
	// Bit ADS16.
	ADC120_ADADS1_ADS16 = 0x1
	// Do not select associated input channel.
	ADC120_ADADS1_ADS16_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS16_1 = 0x1
	// Position of ADS17 field.
	ADC120_ADADS1_ADS17_Pos = 0x1
	// Bit mask of ADS17 field.
	ADC120_ADADS1_ADS17_Msk = 0x2
	// Bit ADS17.
	ADC120_ADADS1_ADS17 = 0x2
	// Do not select associated input channel.
	ADC120_ADADS1_ADS17_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS17_1 = 0x1
	// Position of ADS18 field.
	ADC120_ADADS1_ADS18_Pos = 0x2
	// Bit mask of ADS18 field.
	ADC120_ADADS1_ADS18_Msk = 0x4
	// Bit ADS18.
	ADC120_ADADS1_ADS18 = 0x4
	// Do not select associated input channel.
	ADC120_ADADS1_ADS18_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS18_1 = 0x1
	// Position of ADS19 field.
	ADC120_ADADS1_ADS19_Pos = 0x3
	// Bit mask of ADS19 field.
	ADC120_ADADS1_ADS19_Msk = 0x8
	// Bit ADS19.
	ADC120_ADADS1_ADS19 = 0x8
	// Do not select associated input channel.
	ADC120_ADADS1_ADS19_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS19_1 = 0x1
	// Position of ADS20 field.
	ADC120_ADADS1_ADS20_Pos = 0x4
	// Bit mask of ADS20 field.
	ADC120_ADADS1_ADS20_Msk = 0x10
	// Bit ADS20.
	ADC120_ADADS1_ADS20 = 0x10
	// Do not select associated input channel.
	ADC120_ADADS1_ADS20_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS20_1 = 0x1
	// Position of ADS21 field.
	ADC120_ADADS1_ADS21_Pos = 0x5
	// Bit mask of ADS21 field.
	ADC120_ADADS1_ADS21_Msk = 0x20
	// Bit ADS21.
	ADC120_ADADS1_ADS21 = 0x20
	// Do not select associated input channel.
	ADC120_ADADS1_ADS21_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS21_1 = 0x1
	// Position of ADS22 field.
	ADC120_ADADS1_ADS22_Pos = 0x6
	// Bit mask of ADS22 field.
	ADC120_ADADS1_ADS22_Msk = 0x40
	// Bit ADS22.
	ADC120_ADADS1_ADS22 = 0x40
	// Do not select associated input channel.
	ADC120_ADADS1_ADS22_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS22_1 = 0x1
	// Position of ADS23 field.
	ADC120_ADADS1_ADS23_Pos = 0x7
	// Bit mask of ADS23 field.
	ADC120_ADADS1_ADS23_Msk = 0x80
	// Bit ADS23.
	ADC120_ADADS1_ADS23 = 0x80
	// Do not select associated input channel.
	ADC120_ADADS1_ADS23_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS23_1 = 0x1
	// Position of ADS24 field.
	ADC120_ADADS1_ADS24_Pos = 0x8
	// Bit mask of ADS24 field.
	ADC120_ADADS1_ADS24_Msk = 0x100
	// Bit ADS24.
	ADC120_ADADS1_ADS24 = 0x100
	// Do not select associated input channel.
	ADC120_ADADS1_ADS24_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS24_1 = 0x1
	// Position of ADS25 field.
	ADC120_ADADS1_ADS25_Pos = 0x9
	// Bit mask of ADS25 field.
	ADC120_ADADS1_ADS25_Msk = 0x200
	// Bit ADS25.
	ADC120_ADADS1_ADS25 = 0x200
	// Do not select associated input channel.
	ADC120_ADADS1_ADS25_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS25_1 = 0x1
	// Position of ADS26 field.
	ADC120_ADADS1_ADS26_Pos = 0xa
	// Bit mask of ADS26 field.
	ADC120_ADADS1_ADS26_Msk = 0x400
	// Bit ADS26.
	ADC120_ADADS1_ADS26 = 0x400
	// Do not select associated input channel.
	ADC120_ADADS1_ADS26_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS26_1 = 0x1
	// Position of ADS27 field.
	ADC120_ADADS1_ADS27_Pos = 0xb
	// Bit mask of ADS27 field.
	ADC120_ADADS1_ADS27_Msk = 0x800
	// Bit ADS27.
	ADC120_ADADS1_ADS27 = 0x800
	// Do not select associated input channel.
	ADC120_ADADS1_ADS27_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS27_1 = 0x1
	// Position of ADS28 field.
	ADC120_ADADS1_ADS28_Pos = 0xc
	// Bit mask of ADS28 field.
	ADC120_ADADS1_ADS28_Msk = 0x1000
	// Bit ADS28.
	ADC120_ADADS1_ADS28 = 0x1000
	// Do not select associated input channel.
	ADC120_ADADS1_ADS28_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS28_1 = 0x1
	// Position of ADS29 field.
	ADC120_ADADS1_ADS29_Pos = 0xd
	// Bit mask of ADS29 field.
	ADC120_ADADS1_ADS29_Msk = 0x2000
	// Bit ADS29.
	ADC120_ADADS1_ADS29 = 0x2000
	// Do not select associated input channel.
	ADC120_ADADS1_ADS29_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS29_1 = 0x1
	// Position of ADS30 field.
	ADC120_ADADS1_ADS30_Pos = 0xe
	// Bit mask of ADS30 field.
	ADC120_ADADS1_ADS30_Msk = 0x4000
	// Bit ADS30.
	ADC120_ADADS1_ADS30 = 0x4000
	// Do not select associated input channel.
	ADC120_ADADS1_ADS30_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS30_1 = 0x1
	// Position of ADS31 field.
	ADC120_ADADS1_ADS31_Pos = 0xf
	// Bit mask of ADS31 field.
	ADC120_ADADS1_ADS31_Msk = 0x8000
	// Bit ADS31.
	ADC120_ADADS1_ADS31 = 0x8000
	// Do not select associated input channel.
	ADC120_ADADS1_ADS31_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS1_ADS31_1 = 0x1

	// ADADC: A/D-Converted Value Addition/Average Count Select Register
	// Position of ADC field.
	ADC120_ADADC_ADC_Pos = 0x0
	// Bit mask of ADC field.
	ADC120_ADADC_ADC_Msk = 0x7
	// 1-time conversion (no addition, same as normal conversion)
	ADC120_ADADC_ADC_000 = 0x0
	// 2-time conversion (1 addition)
	ADC120_ADADC_ADC_001 = 0x1
	// 3-time conversion (2 additions)
	ADC120_ADADC_ADC_010 = 0x2
	// 4-time conversion (3 additions)
	ADC120_ADADC_ADC_011 = 0x3
	// 16-time conversion (15 additions)
	ADC120_ADADC_ADC_101 = 0x5
	// Position of AVEE field.
	ADC120_ADADC_AVEE_Pos = 0x7
	// Bit mask of AVEE field.
	ADC120_ADADC_AVEE_Msk = 0x80
	// Bit AVEE.
	ADC120_ADADC_AVEE = 0x80
	// Enable addition mode
	ADC120_ADADC_AVEE_0 = 0x0
	// Enable average mode
	ADC120_ADADC_AVEE_1 = 0x1

	// ADCER: A/D Control Extended Register
	// Position of ACE field.
	ADC120_ADCER_ACE_Pos = 0x5
	// Bit mask of ACE field.
	ADC120_ADCER_ACE_Msk = 0x20
	// Bit ACE.
	ADC120_ADCER_ACE = 0x20
	// Disable automatic clearing
	ADC120_ADCER_ACE_0 = 0x0
	// Enable automatic clearing
	ADC120_ADCER_ACE_1 = 0x1
	// Position of DIAGVAL field.
	ADC120_ADCER_DIAGVAL_Pos = 0x8
	// Bit mask of DIAGVAL field.
	ADC120_ADCER_DIAGVAL_Msk = 0x300
	// Setting prohibited when self-diagnosis is enabled
	ADC120_ADCER_DIAGVAL_00 = 0x0
	// 0 volts
	ADC120_ADCER_DIAGVAL_01 = 0x1
	// Reference voltage × 1/2
	ADC120_ADCER_DIAGVAL_10 = 0x2
	// Reference voltage
	ADC120_ADCER_DIAGVAL_11 = 0x3
	// Position of DIAGLD field.
	ADC120_ADCER_DIAGLD_Pos = 0xa
	// Bit mask of DIAGLD field.
	ADC120_ADCER_DIAGLD_Msk = 0x400
	// Bit DIAGLD.
	ADC120_ADCER_DIAGLD = 0x400
	// Select rotation mode for self-diagnosis voltage
	ADC120_ADCER_DIAGLD_0 = 0x0
	// Select mixed mode for self-diagnosis voltage
	ADC120_ADCER_DIAGLD_1 = 0x1
	// Position of DIAGM field.
	ADC120_ADCER_DIAGM_Pos = 0xb
	// Bit mask of DIAGM field.
	ADC120_ADCER_DIAGM_Msk = 0x800
	// Bit DIAGM.
	ADC120_ADCER_DIAGM = 0x800
	// Disable ADC12 self-diagnosis
	ADC120_ADCER_DIAGM_0 = 0x0
	// Enable ADC12 self-diagnosis
	ADC120_ADCER_DIAGM_1 = 0x1
	// Position of ADRFMT field.
	ADC120_ADCER_ADRFMT_Pos = 0xf
	// Bit mask of ADRFMT field.
	ADC120_ADCER_ADRFMT_Msk = 0x8000
	// Bit ADRFMT.
	ADC120_ADCER_ADRFMT = 0x8000
	// Select right-justified for the A/D data register format
	ADC120_ADCER_ADRFMT_0 = 0x0
	// Select left-justified for the A/D data register format
	ADC120_ADCER_ADRFMT_1 = 0x1

	// ADSTRGR: A/D Conversion Start Trigger Select Register
	// Position of TRSB field.
	ADC120_ADSTRGR_TRSB_Pos = 0x0
	// Bit mask of TRSB field.
	ADC120_ADSTRGR_TRSB_Msk = 0x3f
	// Position of TRSA field.
	ADC120_ADSTRGR_TRSA_Pos = 0x8
	// Bit mask of TRSA field.
	ADC120_ADSTRGR_TRSA_Msk = 0x3f00

	// ADEXICR: A/D Conversion Extended Input Control Registers
	// Position of TSSAD field.
	ADC120_ADEXICR_TSSAD_Pos = 0x0
	// Bit mask of TSSAD field.
	ADC120_ADEXICR_TSSAD_Msk = 0x1
	// Bit TSSAD.
	ADC120_ADEXICR_TSSAD = 0x1
	// Do not select addition/average mode for temperature sensor output.
	ADC120_ADEXICR_TSSAD_0 = 0x0
	// Select addition/average mode for temperature sensor output.
	ADC120_ADEXICR_TSSAD_1 = 0x1
	// Position of OCSAD field.
	ADC120_ADEXICR_OCSAD_Pos = 0x1
	// Bit mask of OCSAD field.
	ADC120_ADEXICR_OCSAD_Msk = 0x2
	// Bit OCSAD.
	ADC120_ADEXICR_OCSAD = 0x2
	// Do not select addition/average mode for internal reference voltage.
	ADC120_ADEXICR_OCSAD_0 = 0x0
	// Select addition/average mode for internal reference voltage.
	ADC120_ADEXICR_OCSAD_1 = 0x1
	// Position of TSSA field.
	ADC120_ADEXICR_TSSA_Pos = 0x8
	// Bit mask of TSSA field.
	ADC120_ADEXICR_TSSA_Msk = 0x100
	// Bit TSSA.
	ADC120_ADEXICR_TSSA = 0x100
	// Disable A/D conversion of temperature sensor output
	ADC120_ADEXICR_TSSA_0 = 0x0
	// Enable A/D conversion of temperature sensor output
	ADC120_ADEXICR_TSSA_1 = 0x1
	// Position of OCSA field.
	ADC120_ADEXICR_OCSA_Pos = 0x9
	// Bit mask of OCSA field.
	ADC120_ADEXICR_OCSA_Msk = 0x200
	// Bit OCSA.
	ADC120_ADEXICR_OCSA = 0x200
	// Disable A/D conversion of internal reference voltage
	ADC120_ADEXICR_OCSA_0 = 0x0
	// Enable A/D conversion of internal reference voltage
	ADC120_ADEXICR_OCSA_1 = 0x1

	// ADANSB0: A/D Channel Select Register B0
	// Position of ANSB00 field.
	ADC120_ADANSB0_ANSB00_Pos = 0x0
	// Bit mask of ANSB00 field.
	ADC120_ADANSB0_ANSB00_Msk = 0x1
	// Bit ANSB00.
	ADC120_ADANSB0_ANSB00 = 0x1
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB00_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB00_1 = 0x1
	// Position of ANSB01 field.
	ADC120_ADANSB0_ANSB01_Pos = 0x1
	// Bit mask of ANSB01 field.
	ADC120_ADANSB0_ANSB01_Msk = 0x2
	// Bit ANSB01.
	ADC120_ADANSB0_ANSB01 = 0x2
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB01_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB01_1 = 0x1
	// Position of ANSB02 field.
	ADC120_ADANSB0_ANSB02_Pos = 0x2
	// Bit mask of ANSB02 field.
	ADC120_ADANSB0_ANSB02_Msk = 0x4
	// Bit ANSB02.
	ADC120_ADANSB0_ANSB02 = 0x4
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB02_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB02_1 = 0x1
	// Position of ANSB03 field.
	ADC120_ADANSB0_ANSB03_Pos = 0x3
	// Bit mask of ANSB03 field.
	ADC120_ADANSB0_ANSB03_Msk = 0x8
	// Bit ANSB03.
	ADC120_ADANSB0_ANSB03 = 0x8
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB03_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB03_1 = 0x1
	// Position of ANSB04 field.
	ADC120_ADANSB0_ANSB04_Pos = 0x4
	// Bit mask of ANSB04 field.
	ADC120_ADANSB0_ANSB04_Msk = 0x10
	// Bit ANSB04.
	ADC120_ADANSB0_ANSB04 = 0x10
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB04_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB04_1 = 0x1
	// Position of ANSB05 field.
	ADC120_ADANSB0_ANSB05_Pos = 0x5
	// Bit mask of ANSB05 field.
	ADC120_ADANSB0_ANSB05_Msk = 0x20
	// Bit ANSB05.
	ADC120_ADANSB0_ANSB05 = 0x20
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB05_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB05_1 = 0x1
	// Position of ANSB06 field.
	ADC120_ADANSB0_ANSB06_Pos = 0x6
	// Bit mask of ANSB06 field.
	ADC120_ADANSB0_ANSB06_Msk = 0x40
	// Bit ANSB06.
	ADC120_ADANSB0_ANSB06 = 0x40
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB06_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB06_1 = 0x1
	// Position of ANSB07 field.
	ADC120_ADANSB0_ANSB07_Pos = 0x7
	// Bit mask of ANSB07 field.
	ADC120_ADANSB0_ANSB07_Msk = 0x80
	// Bit ANSB07.
	ADC120_ADANSB0_ANSB07 = 0x80
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB07_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB07_1 = 0x1
	// Position of ANSB08 field.
	ADC120_ADANSB0_ANSB08_Pos = 0x8
	// Bit mask of ANSB08 field.
	ADC120_ADANSB0_ANSB08_Msk = 0x100
	// Bit ANSB08.
	ADC120_ADANSB0_ANSB08 = 0x100
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB08_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB08_1 = 0x1
	// Position of ANSB09 field.
	ADC120_ADANSB0_ANSB09_Pos = 0x9
	// Bit mask of ANSB09 field.
	ADC120_ADANSB0_ANSB09_Msk = 0x200
	// Bit ANSB09.
	ADC120_ADANSB0_ANSB09 = 0x200
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB09_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB09_1 = 0x1
	// Position of ANSB10 field.
	ADC120_ADANSB0_ANSB10_Pos = 0xa
	// Bit mask of ANSB10 field.
	ADC120_ADANSB0_ANSB10_Msk = 0x400
	// Bit ANSB10.
	ADC120_ADANSB0_ANSB10 = 0x400
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB10_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB10_1 = 0x1
	// Position of ANSB11 field.
	ADC120_ADANSB0_ANSB11_Pos = 0xb
	// Bit mask of ANSB11 field.
	ADC120_ADANSB0_ANSB11_Msk = 0x800
	// Bit ANSB11.
	ADC120_ADANSB0_ANSB11 = 0x800
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB11_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB11_1 = 0x1
	// Position of ANSB12 field.
	ADC120_ADANSB0_ANSB12_Pos = 0xc
	// Bit mask of ANSB12 field.
	ADC120_ADANSB0_ANSB12_Msk = 0x1000
	// Bit ANSB12.
	ADC120_ADANSB0_ANSB12 = 0x1000
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB12_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB12_1 = 0x1
	// Position of ANSB13 field.
	ADC120_ADANSB0_ANSB13_Pos = 0xd
	// Bit mask of ANSB13 field.
	ADC120_ADANSB0_ANSB13_Msk = 0x2000
	// Bit ANSB13.
	ADC120_ADANSB0_ANSB13 = 0x2000
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB13_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB13_1 = 0x1
	// Position of ANSB14 field.
	ADC120_ADANSB0_ANSB14_Pos = 0xe
	// Bit mask of ANSB14 field.
	ADC120_ADANSB0_ANSB14_Msk = 0x4000
	// Bit ANSB14.
	ADC120_ADANSB0_ANSB14 = 0x4000
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB14_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB14_1 = 0x1
	// Position of ANSB15 field.
	ADC120_ADANSB0_ANSB15_Pos = 0xf
	// Bit mask of ANSB15 field.
	ADC120_ADANSB0_ANSB15_Msk = 0x8000
	// Bit ANSB15.
	ADC120_ADANSB0_ANSB15 = 0x8000
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB15_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB15_1 = 0x1

	// ADANSB1: A/D Channel Select Register B1
	// Position of ANSB16 field.
	ADC120_ADANSB1_ANSB16_Pos = 0x0
	// Bit mask of ANSB16 field.
	ADC120_ADANSB1_ANSB16_Msk = 0x1
	// Bit ANSB16.
	ADC120_ADANSB1_ANSB16 = 0x1
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB16_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB16_1 = 0x1
	// Position of ANSB17 field.
	ADC120_ADANSB1_ANSB17_Pos = 0x1
	// Bit mask of ANSB17 field.
	ADC120_ADANSB1_ANSB17_Msk = 0x2
	// Bit ANSB17.
	ADC120_ADANSB1_ANSB17 = 0x2
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB17_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB17_1 = 0x1
	// Position of ANSB18 field.
	ADC120_ADANSB1_ANSB18_Pos = 0x2
	// Bit mask of ANSB18 field.
	ADC120_ADANSB1_ANSB18_Msk = 0x4
	// Bit ANSB18.
	ADC120_ADANSB1_ANSB18 = 0x4
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB18_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB18_1 = 0x1
	// Position of ANSB19 field.
	ADC120_ADANSB1_ANSB19_Pos = 0x3
	// Bit mask of ANSB19 field.
	ADC120_ADANSB1_ANSB19_Msk = 0x8
	// Bit ANSB19.
	ADC120_ADANSB1_ANSB19 = 0x8
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB19_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB19_1 = 0x1
	// Position of ANSB20 field.
	ADC120_ADANSB1_ANSB20_Pos = 0x4
	// Bit mask of ANSB20 field.
	ADC120_ADANSB1_ANSB20_Msk = 0x10
	// Bit ANSB20.
	ADC120_ADANSB1_ANSB20 = 0x10
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB20_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB20_1 = 0x1
	// Position of ANSB21 field.
	ADC120_ADANSB1_ANSB21_Pos = 0x5
	// Bit mask of ANSB21 field.
	ADC120_ADANSB1_ANSB21_Msk = 0x20
	// Bit ANSB21.
	ADC120_ADANSB1_ANSB21 = 0x20
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB21_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB21_1 = 0x1
	// Position of ANSB22 field.
	ADC120_ADANSB1_ANSB22_Pos = 0x6
	// Bit mask of ANSB22 field.
	ADC120_ADANSB1_ANSB22_Msk = 0x40
	// Bit ANSB22.
	ADC120_ADANSB1_ANSB22 = 0x40
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB22_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB22_1 = 0x1
	// Position of ANSB23 field.
	ADC120_ADANSB1_ANSB23_Pos = 0x7
	// Bit mask of ANSB23 field.
	ADC120_ADANSB1_ANSB23_Msk = 0x80
	// Bit ANSB23.
	ADC120_ADANSB1_ANSB23 = 0x80
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB23_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB23_1 = 0x1
	// Position of ANSB24 field.
	ADC120_ADANSB1_ANSB24_Pos = 0x8
	// Bit mask of ANSB24 field.
	ADC120_ADANSB1_ANSB24_Msk = 0x100
	// Bit ANSB24.
	ADC120_ADANSB1_ANSB24 = 0x100
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB24_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB24_1 = 0x1
	// Position of ANSB25 field.
	ADC120_ADANSB1_ANSB25_Pos = 0x9
	// Bit mask of ANSB25 field.
	ADC120_ADANSB1_ANSB25_Msk = 0x200
	// Bit ANSB25.
	ADC120_ADANSB1_ANSB25 = 0x200
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB25_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB25_1 = 0x1
	// Position of ANSB26 field.
	ADC120_ADANSB1_ANSB26_Pos = 0xa
	// Bit mask of ANSB26 field.
	ADC120_ADANSB1_ANSB26_Msk = 0x400
	// Bit ANSB26.
	ADC120_ADANSB1_ANSB26 = 0x400
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB26_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB26_1 = 0x1
	// Position of ANSB27 field.
	ADC120_ADANSB1_ANSB27_Pos = 0xb
	// Bit mask of ANSB27 field.
	ADC120_ADANSB1_ANSB27_Msk = 0x800
	// Bit ANSB27.
	ADC120_ADANSB1_ANSB27 = 0x800
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB27_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB27_1 = 0x1
	// Position of ANSB28 field.
	ADC120_ADANSB1_ANSB28_Pos = 0xc
	// Bit mask of ANSB28 field.
	ADC120_ADANSB1_ANSB28_Msk = 0x1000
	// Bit ANSB28.
	ADC120_ADANSB1_ANSB28 = 0x1000
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB28_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB28_1 = 0x1
	// Position of ANSB29 field.
	ADC120_ADANSB1_ANSB29_Pos = 0xd
	// Bit mask of ANSB29 field.
	ADC120_ADANSB1_ANSB29_Msk = 0x2000
	// Bit ANSB29.
	ADC120_ADANSB1_ANSB29 = 0x2000
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB29_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB29_1 = 0x1
	// Position of ANSB30 field.
	ADC120_ADANSB1_ANSB30_Pos = 0xe
	// Bit mask of ANSB30 field.
	ADC120_ADANSB1_ANSB30_Msk = 0x4000
	// Bit ANSB30.
	ADC120_ADANSB1_ANSB30 = 0x4000
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB30_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB30_1 = 0x1
	// Position of ANSB31 field.
	ADC120_ADANSB1_ANSB31_Pos = 0xf
	// Bit mask of ANSB31 field.
	ADC120_ADANSB1_ANSB31_Msk = 0x8000
	// Bit ANSB31.
	ADC120_ADANSB1_ANSB31 = 0x8000
	// Do not select associated input channel.
	ADC120_ADANSB1_ANSB31_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB1_ANSB31_1 = 0x1

	// ADDBLDR: A/D Data Duplexing Register
	// Position of ADDBLDR field.
	ADC120_ADDBLDR_ADDBLDR_Pos = 0x0
	// Bit mask of ADDBLDR field.
	ADC120_ADDBLDR_ADDBLDR_Msk = 0xffff

	// ADTSDR: A/D Temperature Sensor Data Register
	// Position of ADTSDR field.
	ADC120_ADTSDR_ADTSDR_Pos = 0x0
	// Bit mask of ADTSDR field.
	ADC120_ADTSDR_ADTSDR_Msk = 0xffff

	// ADOCDR: A/D Internal Reference Voltage Data Register
	// Position of ADOCDR field.
	ADC120_ADOCDR_ADOCDR_Pos = 0x0
	// Bit mask of ADOCDR field.
	ADC120_ADOCDR_ADOCDR_Msk = 0xffff

	// ADRD: A/D Self-Diagnosis Data Register
	// Position of AD field.
	ADC120_ADRD_AD_Pos = 0x0
	// Bit mask of AD field.
	ADC120_ADRD_AD_Msk = 0xfff
	// Position of DIAGST field.
	ADC120_ADRD_DIAGST_Pos = 0xe
	// Bit mask of DIAGST field.
	ADC120_ADRD_DIAGST_Msk = 0xc000
	// Self-diagnosis not executed after power-on.
	ADC120_ADRD_DIAGST_00 = 0x0
	// Self-diagnosis was executed using the 0 V voltage.
	ADC120_ADRD_DIAGST_01 = 0x1
	// Self-diagnosis was executed using the reference voltage × 1/2.
	ADC120_ADRD_DIAGST_10 = 0x2
	// Self-diagnosis was executed using the reference voltage .
	ADC120_ADRD_DIAGST_11 = 0x3

	// ADDR0: A/D Data Registers %s
	// Position of ADDR field.
	ADC120_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ADC120_ADDR_ADDR_Msk = 0xffff

	// ADCTDR: A/D CTSU TSCAP Voltage Data Register
	// Position of ADCTDR field.
	ADC120_ADCTDR_ADCTDR_Pos = 0x0
	// Bit mask of ADCTDR field.
	ADC120_ADCTDR_ADCTDR_Msk = 0xffff

	// ADDR17: A/D Data Registers %s
	// Position of ADDR field.
	ADC120_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ADC120_ADDR_ADDR_Msk = 0xffff

	// ADDISCR: A/D Disconnection Detection Control Register
	// Position of ADNDIS field.
	ADC120_ADDISCR_ADNDIS_Pos = 0x0
	// Bit mask of ADNDIS field.
	ADC120_ADDISCR_ADNDIS_Msk = 0xf
	// The disconnection detection assist function is disabled
	ADC120_ADDISCR_ADNDIS_0x0 = 0x0
	// Setting prohibited
	ADC120_ADDISCR_ADNDIS_0x1 = 0x1
	// Position of PCHG field.
	ADC120_ADDISCR_PCHG_Pos = 0x4
	// Bit mask of PCHG field.
	ADC120_ADDISCR_PCHG_Msk = 0x10
	// Bit PCHG.
	ADC120_ADDISCR_PCHG = 0x10
	// Discharge
	ADC120_ADDISCR_PCHG_0 = 0x0
	// Precharge
	ADC120_ADDISCR_PCHG_1 = 0x1

	// ADACSR: A/D Conversion Operation Mode Select Register
	// Position of ADSAC field.
	ADC120_ADACSR_ADSAC_Pos = 0x1
	// Bit mask of ADSAC field.
	ADC120_ADACSR_ADSAC_Msk = 0x2
	// Bit ADSAC.
	ADC120_ADACSR_ADSAC = 0x2
	// Normal conversion mode (default)
	ADC120_ADACSR_ADSAC_0 = 0x0
	// Fast conversion mode
	ADC120_ADACSR_ADSAC_1 = 0x1

	// ADGSPCR: A/D Group Scan Priority Control Register
	// Position of PGS field.
	ADC120_ADGSPCR_PGS_Pos = 0x0
	// Bit mask of PGS field.
	ADC120_ADGSPCR_PGS_Msk = 0x1
	// Bit PGS.
	ADC120_ADGSPCR_PGS = 0x1
	// Operate without group priority control.
	ADC120_ADGSPCR_PGS_0 = 0x0
	// Operate with group priority control.
	ADC120_ADGSPCR_PGS_1 = 0x1
	// Position of GBRSCN field.
	ADC120_ADGSPCR_GBRSCN_Pos = 0x1
	// Bit mask of GBRSCN field.
	ADC120_ADGSPCR_GBRSCN_Msk = 0x2
	// Bit GBRSCN.
	ADC120_ADGSPCR_GBRSCN = 0x2
	// Disable rescanning of the group that was stopped in group priority operation
	ADC120_ADGSPCR_GBRSCN_0 = 0x0
	// Enable rescanning of the group that was stopped in group priority operation.
	ADC120_ADGSPCR_GBRSCN_1 = 0x1
	// Position of GBRP field.
	ADC120_ADGSPCR_GBRP_Pos = 0xf
	// Bit mask of GBRP field.
	ADC120_ADGSPCR_GBRP_Msk = 0x8000
	// Bit GBRP.
	ADC120_ADGSPCR_GBRP = 0x8000
	// Single scan is not continuously activated.
	ADC120_ADGSPCR_GBRP_0 = 0x0
	// Single scan for the group with the lower-priority is continuously activated.
	ADC120_ADGSPCR_GBRP_1 = 0x1

	// ADDBLDRA: A/D Data Duplexing Register A
	// Position of ADDBLDR field.
	ADC120_ADDBLDRA_ADDBLDR_Pos = 0x0
	// Bit mask of ADDBLDR field.
	ADC120_ADDBLDRA_ADDBLDR_Msk = 0xffff

	// ADDBLDRB: A/D Data Duplexing Register B
	// Position of ADDBLDR field.
	ADC120_ADDBLDRB_ADDBLDR_Pos = 0x0
	// Bit mask of ADDBLDR field.
	ADC120_ADDBLDRB_ADDBLDR_Msk = 0xffff

	// ADHVREFCNT: A/D High-Potential/Low-Potential Reference Voltage Control Register
	// Position of HVSEL field.
	ADC120_ADHVREFCNT_HVSEL_Pos = 0x0
	// Bit mask of HVSEL field.
	ADC120_ADHVREFCNT_HVSEL_Msk = 0x3
	// AVCC0 is selected as the high-potential reference voltage
	ADC120_ADHVREFCNT_HVSEL_00 = 0x0
	// VREFH0 is selected as the high-potential reference voltage
	ADC120_ADHVREFCNT_HVSEL_01 = 0x1
	// Internal reference voltage is selected as the high-potential reference voltage
	ADC120_ADHVREFCNT_HVSEL_10 = 0x2
	// No reference voltage pin is selected (internal node discharge)
	ADC120_ADHVREFCNT_HVSEL_11 = 0x3
	// Position of LVSEL field.
	ADC120_ADHVREFCNT_LVSEL_Pos = 0x4
	// Bit mask of LVSEL field.
	ADC120_ADHVREFCNT_LVSEL_Msk = 0x10
	// Bit LVSEL.
	ADC120_ADHVREFCNT_LVSEL = 0x10
	// AVSS0 is selected as the low-potential reference voltage.
	ADC120_ADHVREFCNT_LVSEL_0 = 0x0
	// VREFL0 is selected as the low-potential reference voltage.
	ADC120_ADHVREFCNT_LVSEL_1 = 0x1
	// Position of ADSLP field.
	ADC120_ADHVREFCNT_ADSLP_Pos = 0x7
	// Bit mask of ADSLP field.
	ADC120_ADHVREFCNT_ADSLP_Msk = 0x80
	// Bit ADSLP.
	ADC120_ADHVREFCNT_ADSLP = 0x80
	// Normal operation
	ADC120_ADHVREFCNT_ADSLP_0 = 0x0
	// Standby state
	ADC120_ADHVREFCNT_ADSLP_1 = 0x1

	// ADWINMON: A/D Compare Function Window A/B Status Monitor Register
	// Position of MONCOMB field.
	ADC120_ADWINMON_MONCOMB_Pos = 0x0
	// Bit mask of MONCOMB field.
	ADC120_ADWINMON_MONCOMB_Msk = 0x1
	// Bit MONCOMB.
	ADC120_ADWINMON_MONCOMB = 0x1
	// Window A/B composite conditions are not met.
	ADC120_ADWINMON_MONCOMB_0 = 0x0
	// Window A/B composite conditions are met.
	ADC120_ADWINMON_MONCOMB_1 = 0x1
	// Position of MONCMPA field.
	ADC120_ADWINMON_MONCMPA_Pos = 0x4
	// Bit mask of MONCMPA field.
	ADC120_ADWINMON_MONCMPA_Msk = 0x10
	// Bit MONCMPA.
	ADC120_ADWINMON_MONCMPA = 0x10
	// Window A comparison conditions are not met.
	ADC120_ADWINMON_MONCMPA_0 = 0x0
	// Window A comparison conditions are met.
	ADC120_ADWINMON_MONCMPA_1 = 0x1
	// Position of MONCMPB field.
	ADC120_ADWINMON_MONCMPB_Pos = 0x5
	// Bit mask of MONCMPB field.
	ADC120_ADWINMON_MONCMPB_Msk = 0x20
	// Bit MONCMPB.
	ADC120_ADWINMON_MONCMPB = 0x20
	// Window B comparison conditions are not met.
	ADC120_ADWINMON_MONCMPB_0 = 0x0
	// Window B comparison conditions are met.
	ADC120_ADWINMON_MONCMPB_1 = 0x1

	// ADCMPCR: A/D Compare Function Control Register
	// Position of CMPAB field.
	ADC120_ADCMPCR_CMPAB_Pos = 0x0
	// Bit mask of CMPAB field.
	ADC120_ADCMPCR_CMPAB_Msk = 0x3
	// Output ADC120_WCMPM when window A OR window B comparison conditions are met. Otherwise, output ADC120_WCMPUM.
	ADC120_ADCMPCR_CMPAB_00 = 0x0
	// Output ADC120_WCMPM when window A EXOR window B comparison conditions are met. Otherwise, output ADC120_WCMPUM.
	ADC120_ADCMPCR_CMPAB_01 = 0x1
	// Output ADC120_WCMPM when window A AND window B comparison conditions are met. Otherwise, output ADC120_WCMPUM.
	ADC120_ADCMPCR_CMPAB_10 = 0x2
	// Setting prohibited.
	ADC120_ADCMPCR_CMPAB_11 = 0x3
	// Position of CMPBE field.
	ADC120_ADCMPCR_CMPBE_Pos = 0x9
	// Bit mask of CMPBE field.
	ADC120_ADCMPCR_CMPBE_Msk = 0x200
	// Bit CMPBE.
	ADC120_ADCMPCR_CMPBE = 0x200
	// Disable compare window B operation. Disable ADC120_WCMPM and ADC120_WCMPUM outputs.
	ADC120_ADCMPCR_CMPBE_0 = 0x0
	// Enable compare window B operation.
	ADC120_ADCMPCR_CMPBE_1 = 0x1
	// Position of CMPAE field.
	ADC120_ADCMPCR_CMPAE_Pos = 0xb
	// Bit mask of CMPAE field.
	ADC120_ADCMPCR_CMPAE_Msk = 0x800
	// Bit CMPAE.
	ADC120_ADCMPCR_CMPAE = 0x800
	// Disable compare window A operation. Disable ADC120_WCMPM and ADC120_WCMPUM outputs.
	ADC120_ADCMPCR_CMPAE_0 = 0x0
	// Enable compare window A operation.
	ADC120_ADCMPCR_CMPAE_1 = 0x1
	// Position of CMPBIE field.
	ADC120_ADCMPCR_CMPBIE_Pos = 0xd
	// Bit mask of CMPBIE field.
	ADC120_ADCMPCR_CMPBIE_Msk = 0x2000
	// Bit CMPBIE.
	ADC120_ADCMPCR_CMPBIE = 0x2000
	// Disable ADC120_CMPBI interrupt when comparison conditions (window B) are met.
	ADC120_ADCMPCR_CMPBIE_0 = 0x0
	// Enable ADC120_CMPBI interrupt when comparison conditions (window B) are met.
	ADC120_ADCMPCR_CMPBIE_1 = 0x1
	// Position of WCMPE field.
	ADC120_ADCMPCR_WCMPE_Pos = 0xe
	// Bit mask of WCMPE field.
	ADC120_ADCMPCR_WCMPE_Msk = 0x4000
	// Bit WCMPE.
	ADC120_ADCMPCR_WCMPE = 0x4000
	// Disable window function Window A and window B operate as a comparator to compare the single value on the lower side with the A/D conversion result.
	ADC120_ADCMPCR_WCMPE_0 = 0x0
	// Enable window function Window A and window B operate as a comparator to compare the two values on the upper and lower sides with the A/D conversion result.
	ADC120_ADCMPCR_WCMPE_1 = 0x1
	// Position of CMPAIE field.
	ADC120_ADCMPCR_CMPAIE_Pos = 0xf
	// Bit mask of CMPAIE field.
	ADC120_ADCMPCR_CMPAIE_Msk = 0x8000
	// Bit CMPAIE.
	ADC120_ADCMPCR_CMPAIE = 0x8000
	// Disable ADC120_CMPAI interrupt when comparison conditions (window A) are met.
	ADC120_ADCMPCR_CMPAIE_0 = 0x0
	// Enable ADC120_CMPAI interrupt when comparison conditions (window A) are met.
	ADC120_ADCMPCR_CMPAIE_1 = 0x1

	// ADCMPANSER: A/D Compare Function Window A Extended Input Select Register
	// Position of CMPTSA field.
	ADC120_ADCMPANSER_CMPTSA_Pos = 0x0
	// Bit mask of CMPTSA field.
	ADC120_ADCMPANSER_CMPTSA_Msk = 0x1
	// Bit CMPTSA.
	ADC120_ADCMPANSER_CMPTSA = 0x1
	// Exclude the temperature sensor output from the compare Window A target range.
	ADC120_ADCMPANSER_CMPTSA_0 = 0x0
	// Include the temperature sensor output in the compare Window A target range.
	ADC120_ADCMPANSER_CMPTSA_1 = 0x1
	// Position of CMPOCA field.
	ADC120_ADCMPANSER_CMPOCA_Pos = 0x1
	// Bit mask of CMPOCA field.
	ADC120_ADCMPANSER_CMPOCA_Msk = 0x2
	// Bit CMPOCA.
	ADC120_ADCMPANSER_CMPOCA = 0x2
	// Exclude the internal reference voltage from the compare Window A target range.
	ADC120_ADCMPANSER_CMPOCA_0 = 0x0
	// Include the internal reference voltage in the compare Window A target range.
	ADC120_ADCMPANSER_CMPOCA_1 = 0x1

	// ADCMPLER: A/D Compare Function Window A Extended Input Comparison Condition Setting Register
	// Position of CMPLTSA field.
	ADC120_ADCMPLER_CMPLTSA_Pos = 0x0
	// Bit mask of CMPLTSA field.
	ADC120_ADCMPLER_CMPLTSA_Msk = 0x1
	// Bit CMPLTSA.
	ADC120_ADCMPLER_CMPLTSA = 0x1
	// When window function is disabled (ADCMPCR.WCMPE = 0) : ADCMPDR0 value > A/D-converted valueCompare Window A Temperature Sensor Output Comparison Condition Select When window function is enabled (ADCMPCR.WCMPE = 1) : Compare Window A Temperature Sensor Output Comparison ConditionA/D-converted value < ADCMPDR0 value, or A/D-converted value > ADCMPDR1 value
	ADC120_ADCMPLER_CMPLTSA_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0) : ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1) : ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLER_CMPLTSA_1 = 0x1
	// Position of CMPLOCA field.
	ADC120_ADCMPLER_CMPLOCA_Pos = 0x1
	// Bit mask of CMPLOCA field.
	ADC120_ADCMPLER_CMPLOCA_Msk = 0x2
	// Bit CMPLOCA.
	ADC120_ADCMPLER_CMPLOCA = 0x2
	// When window function is disabled (ADCMPCR.WCMPE = 0) : ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or A/D-converted value > ADCMPDR1 value
	ADC120_ADCMPLER_CMPLOCA_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLER_CMPLOCA_1 = 0x1

	// ADCMPANSR0: A/D Compare Function Window A Channel Select Register 0
	// Position of CMPCHA00 field.
	ADC120_ADCMPANSR0_CMPCHA00_Pos = 0x0
	// Bit mask of CMPCHA00 field.
	ADC120_ADCMPANSR0_CMPCHA00_Msk = 0x1
	// Bit CMPCHA00.
	ADC120_ADCMPANSR0_CMPCHA00 = 0x1
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA00_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA00_1 = 0x1
	// Position of CMPCHA01 field.
	ADC120_ADCMPANSR0_CMPCHA01_Pos = 0x1
	// Bit mask of CMPCHA01 field.
	ADC120_ADCMPANSR0_CMPCHA01_Msk = 0x2
	// Bit CMPCHA01.
	ADC120_ADCMPANSR0_CMPCHA01 = 0x2
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA01_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA01_1 = 0x1
	// Position of CMPCHA02 field.
	ADC120_ADCMPANSR0_CMPCHA02_Pos = 0x2
	// Bit mask of CMPCHA02 field.
	ADC120_ADCMPANSR0_CMPCHA02_Msk = 0x4
	// Bit CMPCHA02.
	ADC120_ADCMPANSR0_CMPCHA02 = 0x4
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA02_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA02_1 = 0x1
	// Position of CMPCHA03 field.
	ADC120_ADCMPANSR0_CMPCHA03_Pos = 0x3
	// Bit mask of CMPCHA03 field.
	ADC120_ADCMPANSR0_CMPCHA03_Msk = 0x8
	// Bit CMPCHA03.
	ADC120_ADCMPANSR0_CMPCHA03 = 0x8
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA03_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA03_1 = 0x1
	// Position of CMPCHA04 field.
	ADC120_ADCMPANSR0_CMPCHA04_Pos = 0x4
	// Bit mask of CMPCHA04 field.
	ADC120_ADCMPANSR0_CMPCHA04_Msk = 0x10
	// Bit CMPCHA04.
	ADC120_ADCMPANSR0_CMPCHA04 = 0x10
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA04_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA04_1 = 0x1
	// Position of CMPCHA05 field.
	ADC120_ADCMPANSR0_CMPCHA05_Pos = 0x5
	// Bit mask of CMPCHA05 field.
	ADC120_ADCMPANSR0_CMPCHA05_Msk = 0x20
	// Bit CMPCHA05.
	ADC120_ADCMPANSR0_CMPCHA05 = 0x20
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA05_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA05_1 = 0x1
	// Position of CMPCHA06 field.
	ADC120_ADCMPANSR0_CMPCHA06_Pos = 0x6
	// Bit mask of CMPCHA06 field.
	ADC120_ADCMPANSR0_CMPCHA06_Msk = 0x40
	// Bit CMPCHA06.
	ADC120_ADCMPANSR0_CMPCHA06 = 0x40
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA06_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA06_1 = 0x1
	// Position of CMPCHA07 field.
	ADC120_ADCMPANSR0_CMPCHA07_Pos = 0x7
	// Bit mask of CMPCHA07 field.
	ADC120_ADCMPANSR0_CMPCHA07_Msk = 0x80
	// Bit CMPCHA07.
	ADC120_ADCMPANSR0_CMPCHA07 = 0x80
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA07_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA07_1 = 0x1
	// Position of CMPCHA08 field.
	ADC120_ADCMPANSR0_CMPCHA08_Pos = 0x8
	// Bit mask of CMPCHA08 field.
	ADC120_ADCMPANSR0_CMPCHA08_Msk = 0x100
	// Bit CMPCHA08.
	ADC120_ADCMPANSR0_CMPCHA08 = 0x100
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA08_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA08_1 = 0x1
	// Position of CMPCHA09 field.
	ADC120_ADCMPANSR0_CMPCHA09_Pos = 0x9
	// Bit mask of CMPCHA09 field.
	ADC120_ADCMPANSR0_CMPCHA09_Msk = 0x200
	// Bit CMPCHA09.
	ADC120_ADCMPANSR0_CMPCHA09 = 0x200
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA09_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA09_1 = 0x1
	// Position of CMPCHA10 field.
	ADC120_ADCMPANSR0_CMPCHA10_Pos = 0xa
	// Bit mask of CMPCHA10 field.
	ADC120_ADCMPANSR0_CMPCHA10_Msk = 0x400
	// Bit CMPCHA10.
	ADC120_ADCMPANSR0_CMPCHA10 = 0x400
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA10_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA10_1 = 0x1
	// Position of CMPCHA11 field.
	ADC120_ADCMPANSR0_CMPCHA11_Pos = 0xb
	// Bit mask of CMPCHA11 field.
	ADC120_ADCMPANSR0_CMPCHA11_Msk = 0x800
	// Bit CMPCHA11.
	ADC120_ADCMPANSR0_CMPCHA11 = 0x800
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA11_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA11_1 = 0x1
	// Position of CMPCHA12 field.
	ADC120_ADCMPANSR0_CMPCHA12_Pos = 0xc
	// Bit mask of CMPCHA12 field.
	ADC120_ADCMPANSR0_CMPCHA12_Msk = 0x1000
	// Bit CMPCHA12.
	ADC120_ADCMPANSR0_CMPCHA12 = 0x1000
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA12_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA12_1 = 0x1
	// Position of CMPCHA13 field.
	ADC120_ADCMPANSR0_CMPCHA13_Pos = 0xd
	// Bit mask of CMPCHA13 field.
	ADC120_ADCMPANSR0_CMPCHA13_Msk = 0x2000
	// Bit CMPCHA13.
	ADC120_ADCMPANSR0_CMPCHA13 = 0x2000
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA13_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA13_1 = 0x1
	// Position of CMPCHA14 field.
	ADC120_ADCMPANSR0_CMPCHA14_Pos = 0xe
	// Bit mask of CMPCHA14 field.
	ADC120_ADCMPANSR0_CMPCHA14_Msk = 0x4000
	// Bit CMPCHA14.
	ADC120_ADCMPANSR0_CMPCHA14 = 0x4000
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA14_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA14_1 = 0x1
	// Position of CMPCHA15 field.
	ADC120_ADCMPANSR0_CMPCHA15_Pos = 0xf
	// Bit mask of CMPCHA15 field.
	ADC120_ADCMPANSR0_CMPCHA15_Msk = 0x8000
	// Bit CMPCHA15.
	ADC120_ADCMPANSR0_CMPCHA15 = 0x8000
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA15_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA15_1 = 0x1

	// ADCMPANSR1: A/D Compare Function Window A Channel Select Register 1
	// Position of CMPCHA16 field.
	ADC120_ADCMPANSR1_CMPCHA16_Pos = 0x0
	// Bit mask of CMPCHA16 field.
	ADC120_ADCMPANSR1_CMPCHA16_Msk = 0x1
	// Bit CMPCHA16.
	ADC120_ADCMPANSR1_CMPCHA16 = 0x1
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA16_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA16_1 = 0x1
	// Position of CMPCHA17 field.
	ADC120_ADCMPANSR1_CMPCHA17_Pos = 0x1
	// Bit mask of CMPCHA17 field.
	ADC120_ADCMPANSR1_CMPCHA17_Msk = 0x2
	// Bit CMPCHA17.
	ADC120_ADCMPANSR1_CMPCHA17 = 0x2
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA17_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA17_1 = 0x1
	// Position of CMPCHA18 field.
	ADC120_ADCMPANSR1_CMPCHA18_Pos = 0x2
	// Bit mask of CMPCHA18 field.
	ADC120_ADCMPANSR1_CMPCHA18_Msk = 0x4
	// Bit CMPCHA18.
	ADC120_ADCMPANSR1_CMPCHA18 = 0x4
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA18_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA18_1 = 0x1
	// Position of CMPCHA19 field.
	ADC120_ADCMPANSR1_CMPCHA19_Pos = 0x3
	// Bit mask of CMPCHA19 field.
	ADC120_ADCMPANSR1_CMPCHA19_Msk = 0x8
	// Bit CMPCHA19.
	ADC120_ADCMPANSR1_CMPCHA19 = 0x8
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA19_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA19_1 = 0x1
	// Position of CMPCHA20 field.
	ADC120_ADCMPANSR1_CMPCHA20_Pos = 0x4
	// Bit mask of CMPCHA20 field.
	ADC120_ADCMPANSR1_CMPCHA20_Msk = 0x10
	// Bit CMPCHA20.
	ADC120_ADCMPANSR1_CMPCHA20 = 0x10
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA20_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA20_1 = 0x1
	// Position of CMPCHA21 field.
	ADC120_ADCMPANSR1_CMPCHA21_Pos = 0x5
	// Bit mask of CMPCHA21 field.
	ADC120_ADCMPANSR1_CMPCHA21_Msk = 0x20
	// Bit CMPCHA21.
	ADC120_ADCMPANSR1_CMPCHA21 = 0x20
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA21_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA21_1 = 0x1
	// Position of CMPCHA22 field.
	ADC120_ADCMPANSR1_CMPCHA22_Pos = 0x6
	// Bit mask of CMPCHA22 field.
	ADC120_ADCMPANSR1_CMPCHA22_Msk = 0x40
	// Bit CMPCHA22.
	ADC120_ADCMPANSR1_CMPCHA22 = 0x40
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA22_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA22_1 = 0x1
	// Position of CMPCHA23 field.
	ADC120_ADCMPANSR1_CMPCHA23_Pos = 0x7
	// Bit mask of CMPCHA23 field.
	ADC120_ADCMPANSR1_CMPCHA23_Msk = 0x80
	// Bit CMPCHA23.
	ADC120_ADCMPANSR1_CMPCHA23 = 0x80
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA23_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA23_1 = 0x1
	// Position of CMPCHA24 field.
	ADC120_ADCMPANSR1_CMPCHA24_Pos = 0x8
	// Bit mask of CMPCHA24 field.
	ADC120_ADCMPANSR1_CMPCHA24_Msk = 0x100
	// Bit CMPCHA24.
	ADC120_ADCMPANSR1_CMPCHA24 = 0x100
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA24_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA24_1 = 0x1
	// Position of CMPCHA25 field.
	ADC120_ADCMPANSR1_CMPCHA25_Pos = 0x9
	// Bit mask of CMPCHA25 field.
	ADC120_ADCMPANSR1_CMPCHA25_Msk = 0x200
	// Bit CMPCHA25.
	ADC120_ADCMPANSR1_CMPCHA25 = 0x200
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA25_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA25_1 = 0x1
	// Position of CMPCHA26 field.
	ADC120_ADCMPANSR1_CMPCHA26_Pos = 0xa
	// Bit mask of CMPCHA26 field.
	ADC120_ADCMPANSR1_CMPCHA26_Msk = 0x400
	// Bit CMPCHA26.
	ADC120_ADCMPANSR1_CMPCHA26 = 0x400
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA26_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA26_1 = 0x1
	// Position of CMPCHA27 field.
	ADC120_ADCMPANSR1_CMPCHA27_Pos = 0xb
	// Bit mask of CMPCHA27 field.
	ADC120_ADCMPANSR1_CMPCHA27_Msk = 0x800
	// Bit CMPCHA27.
	ADC120_ADCMPANSR1_CMPCHA27 = 0x800
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA27_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA27_1 = 0x1
	// Position of CMPCHA28 field.
	ADC120_ADCMPANSR1_CMPCHA28_Pos = 0xc
	// Bit mask of CMPCHA28 field.
	ADC120_ADCMPANSR1_CMPCHA28_Msk = 0x1000
	// Bit CMPCHA28.
	ADC120_ADCMPANSR1_CMPCHA28 = 0x1000
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA28_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA28_1 = 0x1
	// Position of CMPCHA29 field.
	ADC120_ADCMPANSR1_CMPCHA29_Pos = 0xd
	// Bit mask of CMPCHA29 field.
	ADC120_ADCMPANSR1_CMPCHA29_Msk = 0x2000
	// Bit CMPCHA29.
	ADC120_ADCMPANSR1_CMPCHA29 = 0x2000
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA29_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA29_1 = 0x1
	// Position of CMPCHA30 field.
	ADC120_ADCMPANSR1_CMPCHA30_Pos = 0xe
	// Bit mask of CMPCHA30 field.
	ADC120_ADCMPANSR1_CMPCHA30_Msk = 0x4000
	// Bit CMPCHA30.
	ADC120_ADCMPANSR1_CMPCHA30 = 0x4000
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA30_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA30_1 = 0x1
	// Position of CMPCHA31 field.
	ADC120_ADCMPANSR1_CMPCHA31_Pos = 0xf
	// Bit mask of CMPCHA31 field.
	ADC120_ADCMPANSR1_CMPCHA31_Msk = 0x8000
	// Bit CMPCHA31.
	ADC120_ADCMPANSR1_CMPCHA31 = 0x8000
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA31_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR1_CMPCHA31_1 = 0x1

	// ADCMPLR0: A/D Compare Function Window A Comparison Condition Setting Register 0
	// Position of CMPLCHA00 field.
	ADC120_ADCMPLR0_CMPLCHA00_Pos = 0x0
	// Bit mask of CMPLCHA00 field.
	ADC120_ADCMPLR0_CMPLCHA00_Msk = 0x1
	// Bit CMPLCHA00.
	ADC120_ADCMPLR0_CMPLCHA00 = 0x1
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA00_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA00_1 = 0x1
	// Position of CMPLCHA01 field.
	ADC120_ADCMPLR0_CMPLCHA01_Pos = 0x1
	// Bit mask of CMPLCHA01 field.
	ADC120_ADCMPLR0_CMPLCHA01_Msk = 0x2
	// Bit CMPLCHA01.
	ADC120_ADCMPLR0_CMPLCHA01 = 0x2
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA01_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA01_1 = 0x1
	// Position of CMPLCHA02 field.
	ADC120_ADCMPLR0_CMPLCHA02_Pos = 0x2
	// Bit mask of CMPLCHA02 field.
	ADC120_ADCMPLR0_CMPLCHA02_Msk = 0x4
	// Bit CMPLCHA02.
	ADC120_ADCMPLR0_CMPLCHA02 = 0x4
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA02_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA02_1 = 0x1
	// Position of CMPLCHA03 field.
	ADC120_ADCMPLR0_CMPLCHA03_Pos = 0x3
	// Bit mask of CMPLCHA03 field.
	ADC120_ADCMPLR0_CMPLCHA03_Msk = 0x8
	// Bit CMPLCHA03.
	ADC120_ADCMPLR0_CMPLCHA03 = 0x8
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA03_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA03_1 = 0x1
	// Position of CMPLCHA04 field.
	ADC120_ADCMPLR0_CMPLCHA04_Pos = 0x4
	// Bit mask of CMPLCHA04 field.
	ADC120_ADCMPLR0_CMPLCHA04_Msk = 0x10
	// Bit CMPLCHA04.
	ADC120_ADCMPLR0_CMPLCHA04 = 0x10
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA04_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA04_1 = 0x1
	// Position of CMPLCHA05 field.
	ADC120_ADCMPLR0_CMPLCHA05_Pos = 0x5
	// Bit mask of CMPLCHA05 field.
	ADC120_ADCMPLR0_CMPLCHA05_Msk = 0x20
	// Bit CMPLCHA05.
	ADC120_ADCMPLR0_CMPLCHA05 = 0x20
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA05_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA05_1 = 0x1
	// Position of CMPLCHA06 field.
	ADC120_ADCMPLR0_CMPLCHA06_Pos = 0x6
	// Bit mask of CMPLCHA06 field.
	ADC120_ADCMPLR0_CMPLCHA06_Msk = 0x40
	// Bit CMPLCHA06.
	ADC120_ADCMPLR0_CMPLCHA06 = 0x40
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA06_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA06_1 = 0x1
	// Position of CMPLCHA07 field.
	ADC120_ADCMPLR0_CMPLCHA07_Pos = 0x7
	// Bit mask of CMPLCHA07 field.
	ADC120_ADCMPLR0_CMPLCHA07_Msk = 0x80
	// Bit CMPLCHA07.
	ADC120_ADCMPLR0_CMPLCHA07 = 0x80
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA07_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA07_1 = 0x1
	// Position of CMPLCHA08 field.
	ADC120_ADCMPLR0_CMPLCHA08_Pos = 0x8
	// Bit mask of CMPLCHA08 field.
	ADC120_ADCMPLR0_CMPLCHA08_Msk = 0x100
	// Bit CMPLCHA08.
	ADC120_ADCMPLR0_CMPLCHA08 = 0x100
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA08_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA08_1 = 0x1
	// Position of CMPLCHA09 field.
	ADC120_ADCMPLR0_CMPLCHA09_Pos = 0x9
	// Bit mask of CMPLCHA09 field.
	ADC120_ADCMPLR0_CMPLCHA09_Msk = 0x200
	// Bit CMPLCHA09.
	ADC120_ADCMPLR0_CMPLCHA09 = 0x200
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA09_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA09_1 = 0x1
	// Position of CMPLCHA10 field.
	ADC120_ADCMPLR0_CMPLCHA10_Pos = 0xa
	// Bit mask of CMPLCHA10 field.
	ADC120_ADCMPLR0_CMPLCHA10_Msk = 0x400
	// Bit CMPLCHA10.
	ADC120_ADCMPLR0_CMPLCHA10 = 0x400
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA10_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA10_1 = 0x1
	// Position of CMPLCHA11 field.
	ADC120_ADCMPLR0_CMPLCHA11_Pos = 0xb
	// Bit mask of CMPLCHA11 field.
	ADC120_ADCMPLR0_CMPLCHA11_Msk = 0x800
	// Bit CMPLCHA11.
	ADC120_ADCMPLR0_CMPLCHA11 = 0x800
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA11_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA11_1 = 0x1
	// Position of CMPLCHA12 field.
	ADC120_ADCMPLR0_CMPLCHA12_Pos = 0xc
	// Bit mask of CMPLCHA12 field.
	ADC120_ADCMPLR0_CMPLCHA12_Msk = 0x1000
	// Bit CMPLCHA12.
	ADC120_ADCMPLR0_CMPLCHA12 = 0x1000
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA12_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA12_1 = 0x1
	// Position of CMPLCHA13 field.
	ADC120_ADCMPLR0_CMPLCHA13_Pos = 0xd
	// Bit mask of CMPLCHA13 field.
	ADC120_ADCMPLR0_CMPLCHA13_Msk = 0x2000
	// Bit CMPLCHA13.
	ADC120_ADCMPLR0_CMPLCHA13 = 0x2000
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA13_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA13_1 = 0x1
	// Position of CMPLCHA14 field.
	ADC120_ADCMPLR0_CMPLCHA14_Pos = 0xe
	// Bit mask of CMPLCHA14 field.
	ADC120_ADCMPLR0_CMPLCHA14_Msk = 0x4000
	// Bit CMPLCHA14.
	ADC120_ADCMPLR0_CMPLCHA14 = 0x4000
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA14_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA14_1 = 0x1
	// Position of CMPLCHA15 field.
	ADC120_ADCMPLR0_CMPLCHA15_Pos = 0xf
	// Bit mask of CMPLCHA15 field.
	ADC120_ADCMPLR0_CMPLCHA15_Msk = 0x8000
	// Bit CMPLCHA15.
	ADC120_ADCMPLR0_CMPLCHA15 = 0x8000
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA15_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA15_1 = 0x1

	// ADCMPLR1: A/D Compare Function Window A Comparison Condition Setting Register 1
	// Position of CMPLCHA16 field.
	ADC120_ADCMPLR1_CMPLCHA16_Pos = 0x0
	// Bit mask of CMPLCHA16 field.
	ADC120_ADCMPLR1_CMPLCHA16_Msk = 0x1
	// Bit CMPLCHA16.
	ADC120_ADCMPLR1_CMPLCHA16 = 0x1
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA16_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA16_1 = 0x1
	// Position of CMPLCHA17 field.
	ADC120_ADCMPLR1_CMPLCHA17_Pos = 0x1
	// Bit mask of CMPLCHA17 field.
	ADC120_ADCMPLR1_CMPLCHA17_Msk = 0x2
	// Bit CMPLCHA17.
	ADC120_ADCMPLR1_CMPLCHA17 = 0x2
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA17_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA17_1 = 0x1
	// Position of CMPLCHA18 field.
	ADC120_ADCMPLR1_CMPLCHA18_Pos = 0x2
	// Bit mask of CMPLCHA18 field.
	ADC120_ADCMPLR1_CMPLCHA18_Msk = 0x4
	// Bit CMPLCHA18.
	ADC120_ADCMPLR1_CMPLCHA18 = 0x4
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA18_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA18_1 = 0x1
	// Position of CMPLCHA19 field.
	ADC120_ADCMPLR1_CMPLCHA19_Pos = 0x3
	// Bit mask of CMPLCHA19 field.
	ADC120_ADCMPLR1_CMPLCHA19_Msk = 0x8
	// Bit CMPLCHA19.
	ADC120_ADCMPLR1_CMPLCHA19 = 0x8
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA19_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA19_1 = 0x1
	// Position of CMPLCHA20 field.
	ADC120_ADCMPLR1_CMPLCHA20_Pos = 0x4
	// Bit mask of CMPLCHA20 field.
	ADC120_ADCMPLR1_CMPLCHA20_Msk = 0x10
	// Bit CMPLCHA20.
	ADC120_ADCMPLR1_CMPLCHA20 = 0x10
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA20_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA20_1 = 0x1
	// Position of CMPLCHA21 field.
	ADC120_ADCMPLR1_CMPLCHA21_Pos = 0x5
	// Bit mask of CMPLCHA21 field.
	ADC120_ADCMPLR1_CMPLCHA21_Msk = 0x20
	// Bit CMPLCHA21.
	ADC120_ADCMPLR1_CMPLCHA21 = 0x20
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA21_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA21_1 = 0x1
	// Position of CMPLCHA22 field.
	ADC120_ADCMPLR1_CMPLCHA22_Pos = 0x6
	// Bit mask of CMPLCHA22 field.
	ADC120_ADCMPLR1_CMPLCHA22_Msk = 0x40
	// Bit CMPLCHA22.
	ADC120_ADCMPLR1_CMPLCHA22 = 0x40
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA22_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA22_1 = 0x1
	// Position of CMPLCHA23 field.
	ADC120_ADCMPLR1_CMPLCHA23_Pos = 0x7
	// Bit mask of CMPLCHA23 field.
	ADC120_ADCMPLR1_CMPLCHA23_Msk = 0x80
	// Bit CMPLCHA23.
	ADC120_ADCMPLR1_CMPLCHA23 = 0x80
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA23_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA23_1 = 0x1
	// Position of CMPLCHA24 field.
	ADC120_ADCMPLR1_CMPLCHA24_Pos = 0x8
	// Bit mask of CMPLCHA24 field.
	ADC120_ADCMPLR1_CMPLCHA24_Msk = 0x100
	// Bit CMPLCHA24.
	ADC120_ADCMPLR1_CMPLCHA24 = 0x100
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA24_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA24_1 = 0x1
	// Position of CMPLCHA25 field.
	ADC120_ADCMPLR1_CMPLCHA25_Pos = 0x9
	// Bit mask of CMPLCHA25 field.
	ADC120_ADCMPLR1_CMPLCHA25_Msk = 0x200
	// Bit CMPLCHA25.
	ADC120_ADCMPLR1_CMPLCHA25 = 0x200
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA25_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA25_1 = 0x1
	// Position of CMPLCHA26 field.
	ADC120_ADCMPLR1_CMPLCHA26_Pos = 0xa
	// Bit mask of CMPLCHA26 field.
	ADC120_ADCMPLR1_CMPLCHA26_Msk = 0x400
	// Bit CMPLCHA26.
	ADC120_ADCMPLR1_CMPLCHA26 = 0x400
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA26_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA26_1 = 0x1
	// Position of CMPLCHA27 field.
	ADC120_ADCMPLR1_CMPLCHA27_Pos = 0xb
	// Bit mask of CMPLCHA27 field.
	ADC120_ADCMPLR1_CMPLCHA27_Msk = 0x800
	// Bit CMPLCHA27.
	ADC120_ADCMPLR1_CMPLCHA27 = 0x800
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA27_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA27_1 = 0x1
	// Position of CMPLCHA28 field.
	ADC120_ADCMPLR1_CMPLCHA28_Pos = 0xc
	// Bit mask of CMPLCHA28 field.
	ADC120_ADCMPLR1_CMPLCHA28_Msk = 0x1000
	// Bit CMPLCHA28.
	ADC120_ADCMPLR1_CMPLCHA28 = 0x1000
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA28_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA28_1 = 0x1
	// Position of CMPLCHA29 field.
	ADC120_ADCMPLR1_CMPLCHA29_Pos = 0xd
	// Bit mask of CMPLCHA29 field.
	ADC120_ADCMPLR1_CMPLCHA29_Msk = 0x2000
	// Bit CMPLCHA29.
	ADC120_ADCMPLR1_CMPLCHA29 = 0x2000
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA29_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA29_1 = 0x1
	// Position of CMPLCHA30 field.
	ADC120_ADCMPLR1_CMPLCHA30_Pos = 0xe
	// Bit mask of CMPLCHA30 field.
	ADC120_ADCMPLR1_CMPLCHA30_Msk = 0x4000
	// Bit CMPLCHA30.
	ADC120_ADCMPLR1_CMPLCHA30 = 0x4000
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA30_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA30_1 = 0x1
	// Position of CMPLCHA31 field.
	ADC120_ADCMPLR1_CMPLCHA31_Pos = 0xf
	// Bit mask of CMPLCHA31 field.
	ADC120_ADCMPLR1_CMPLCHA31_Msk = 0x8000
	// Bit CMPLCHA31.
	ADC120_ADCMPLR1_CMPLCHA31 = 0x8000
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR1_CMPLCHA31_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR1_CMPLCHA31_1 = 0x1

	// ADCMPSR0: A/D Compare Function Window A Channel Status Register 0
	// Position of CMPSTCHA00 field.
	ADC120_ADCMPSR0_CMPSTCHA00_Pos = 0x0
	// Bit mask of CMPSTCHA00 field.
	ADC120_ADCMPSR0_CMPSTCHA00_Msk = 0x1
	// Bit CMPSTCHA00.
	ADC120_ADCMPSR0_CMPSTCHA00 = 0x1
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA00_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA00_1 = 0x1
	// Position of CMPSTCHA01 field.
	ADC120_ADCMPSR0_CMPSTCHA01_Pos = 0x1
	// Bit mask of CMPSTCHA01 field.
	ADC120_ADCMPSR0_CMPSTCHA01_Msk = 0x2
	// Bit CMPSTCHA01.
	ADC120_ADCMPSR0_CMPSTCHA01 = 0x2
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA01_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA01_1 = 0x1
	// Position of CMPSTCHA02 field.
	ADC120_ADCMPSR0_CMPSTCHA02_Pos = 0x2
	// Bit mask of CMPSTCHA02 field.
	ADC120_ADCMPSR0_CMPSTCHA02_Msk = 0x4
	// Bit CMPSTCHA02.
	ADC120_ADCMPSR0_CMPSTCHA02 = 0x4
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA02_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA02_1 = 0x1
	// Position of CMPSTCHA03 field.
	ADC120_ADCMPSR0_CMPSTCHA03_Pos = 0x3
	// Bit mask of CMPSTCHA03 field.
	ADC120_ADCMPSR0_CMPSTCHA03_Msk = 0x8
	// Bit CMPSTCHA03.
	ADC120_ADCMPSR0_CMPSTCHA03 = 0x8
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA03_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA03_1 = 0x1
	// Position of CMPSTCHA04 field.
	ADC120_ADCMPSR0_CMPSTCHA04_Pos = 0x4
	// Bit mask of CMPSTCHA04 field.
	ADC120_ADCMPSR0_CMPSTCHA04_Msk = 0x10
	// Bit CMPSTCHA04.
	ADC120_ADCMPSR0_CMPSTCHA04 = 0x10
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA04_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA04_1 = 0x1
	// Position of CMPSTCHA05 field.
	ADC120_ADCMPSR0_CMPSTCHA05_Pos = 0x5
	// Bit mask of CMPSTCHA05 field.
	ADC120_ADCMPSR0_CMPSTCHA05_Msk = 0x20
	// Bit CMPSTCHA05.
	ADC120_ADCMPSR0_CMPSTCHA05 = 0x20
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA05_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA05_1 = 0x1
	// Position of CMPSTCHA06 field.
	ADC120_ADCMPSR0_CMPSTCHA06_Pos = 0x6
	// Bit mask of CMPSTCHA06 field.
	ADC120_ADCMPSR0_CMPSTCHA06_Msk = 0x40
	// Bit CMPSTCHA06.
	ADC120_ADCMPSR0_CMPSTCHA06 = 0x40
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA06_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA06_1 = 0x1
	// Position of CMPSTCHA07 field.
	ADC120_ADCMPSR0_CMPSTCHA07_Pos = 0x7
	// Bit mask of CMPSTCHA07 field.
	ADC120_ADCMPSR0_CMPSTCHA07_Msk = 0x80
	// Bit CMPSTCHA07.
	ADC120_ADCMPSR0_CMPSTCHA07 = 0x80
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA07_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA07_1 = 0x1
	// Position of CMPSTCHA08 field.
	ADC120_ADCMPSR0_CMPSTCHA08_Pos = 0x8
	// Bit mask of CMPSTCHA08 field.
	ADC120_ADCMPSR0_CMPSTCHA08_Msk = 0x100
	// Bit CMPSTCHA08.
	ADC120_ADCMPSR0_CMPSTCHA08 = 0x100
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA08_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA08_1 = 0x1
	// Position of CMPSTCHA09 field.
	ADC120_ADCMPSR0_CMPSTCHA09_Pos = 0x9
	// Bit mask of CMPSTCHA09 field.
	ADC120_ADCMPSR0_CMPSTCHA09_Msk = 0x200
	// Bit CMPSTCHA09.
	ADC120_ADCMPSR0_CMPSTCHA09 = 0x200
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA09_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA09_1 = 0x1
	// Position of CMPSTCHA10 field.
	ADC120_ADCMPSR0_CMPSTCHA10_Pos = 0xa
	// Bit mask of CMPSTCHA10 field.
	ADC120_ADCMPSR0_CMPSTCHA10_Msk = 0x400
	// Bit CMPSTCHA10.
	ADC120_ADCMPSR0_CMPSTCHA10 = 0x400
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA10_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA10_1 = 0x1
	// Position of CMPSTCHA11 field.
	ADC120_ADCMPSR0_CMPSTCHA11_Pos = 0xb
	// Bit mask of CMPSTCHA11 field.
	ADC120_ADCMPSR0_CMPSTCHA11_Msk = 0x800
	// Bit CMPSTCHA11.
	ADC120_ADCMPSR0_CMPSTCHA11 = 0x800
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA11_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA11_1 = 0x1
	// Position of CMPSTCHA12 field.
	ADC120_ADCMPSR0_CMPSTCHA12_Pos = 0xc
	// Bit mask of CMPSTCHA12 field.
	ADC120_ADCMPSR0_CMPSTCHA12_Msk = 0x1000
	// Bit CMPSTCHA12.
	ADC120_ADCMPSR0_CMPSTCHA12 = 0x1000
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA12_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA12_1 = 0x1
	// Position of CMPSTCHA13 field.
	ADC120_ADCMPSR0_CMPSTCHA13_Pos = 0xd
	// Bit mask of CMPSTCHA13 field.
	ADC120_ADCMPSR0_CMPSTCHA13_Msk = 0x2000
	// Bit CMPSTCHA13.
	ADC120_ADCMPSR0_CMPSTCHA13 = 0x2000
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA13_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA13_1 = 0x1
	// Position of CMPSTCHA14 field.
	ADC120_ADCMPSR0_CMPSTCHA14_Pos = 0xe
	// Bit mask of CMPSTCHA14 field.
	ADC120_ADCMPSR0_CMPSTCHA14_Msk = 0x4000
	// Bit CMPSTCHA14.
	ADC120_ADCMPSR0_CMPSTCHA14 = 0x4000
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA14_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA14_1 = 0x1
	// Position of CMPSTCHA15 field.
	ADC120_ADCMPSR0_CMPSTCHA15_Pos = 0xf
	// Bit mask of CMPSTCHA15 field.
	ADC120_ADCMPSR0_CMPSTCHA15_Msk = 0x8000
	// Bit CMPSTCHA15.
	ADC120_ADCMPSR0_CMPSTCHA15 = 0x8000
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA15_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA15_1 = 0x1

	// ADCMPSR1: A/D Compare Function Window A Channel Status Register1
	// Position of CMPSTCHA16 field.
	ADC120_ADCMPSR1_CMPSTCHA16_Pos = 0x0
	// Bit mask of CMPSTCHA16 field.
	ADC120_ADCMPSR1_CMPSTCHA16_Msk = 0x1
	// Bit CMPSTCHA16.
	ADC120_ADCMPSR1_CMPSTCHA16 = 0x1
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA16_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA16_1 = 0x1
	// Position of CMPSTCHA17 field.
	ADC120_ADCMPSR1_CMPSTCHA17_Pos = 0x1
	// Bit mask of CMPSTCHA17 field.
	ADC120_ADCMPSR1_CMPSTCHA17_Msk = 0x2
	// Bit CMPSTCHA17.
	ADC120_ADCMPSR1_CMPSTCHA17 = 0x2
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA17_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA17_1 = 0x1
	// Position of CMPSTCHA18 field.
	ADC120_ADCMPSR1_CMPSTCHA18_Pos = 0x2
	// Bit mask of CMPSTCHA18 field.
	ADC120_ADCMPSR1_CMPSTCHA18_Msk = 0x4
	// Bit CMPSTCHA18.
	ADC120_ADCMPSR1_CMPSTCHA18 = 0x4
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA18_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA18_1 = 0x1
	// Position of CMPSTCHA19 field.
	ADC120_ADCMPSR1_CMPSTCHA19_Pos = 0x3
	// Bit mask of CMPSTCHA19 field.
	ADC120_ADCMPSR1_CMPSTCHA19_Msk = 0x8
	// Bit CMPSTCHA19.
	ADC120_ADCMPSR1_CMPSTCHA19 = 0x8
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA19_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA19_1 = 0x1
	// Position of CMPSTCHA20 field.
	ADC120_ADCMPSR1_CMPSTCHA20_Pos = 0x4
	// Bit mask of CMPSTCHA20 field.
	ADC120_ADCMPSR1_CMPSTCHA20_Msk = 0x10
	// Bit CMPSTCHA20.
	ADC120_ADCMPSR1_CMPSTCHA20 = 0x10
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA20_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA20_1 = 0x1
	// Position of CMPSTCHA21 field.
	ADC120_ADCMPSR1_CMPSTCHA21_Pos = 0x5
	// Bit mask of CMPSTCHA21 field.
	ADC120_ADCMPSR1_CMPSTCHA21_Msk = 0x20
	// Bit CMPSTCHA21.
	ADC120_ADCMPSR1_CMPSTCHA21 = 0x20
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA21_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA21_1 = 0x1
	// Position of CMPSTCHA22 field.
	ADC120_ADCMPSR1_CMPSTCHA22_Pos = 0x6
	// Bit mask of CMPSTCHA22 field.
	ADC120_ADCMPSR1_CMPSTCHA22_Msk = 0x40
	// Bit CMPSTCHA22.
	ADC120_ADCMPSR1_CMPSTCHA22 = 0x40
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA22_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA22_1 = 0x1
	// Position of CMPSTCHA23 field.
	ADC120_ADCMPSR1_CMPSTCHA23_Pos = 0x7
	// Bit mask of CMPSTCHA23 field.
	ADC120_ADCMPSR1_CMPSTCHA23_Msk = 0x80
	// Bit CMPSTCHA23.
	ADC120_ADCMPSR1_CMPSTCHA23 = 0x80
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA23_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA23_1 = 0x1
	// Position of CMPSTCHA24 field.
	ADC120_ADCMPSR1_CMPSTCHA24_Pos = 0x8
	// Bit mask of CMPSTCHA24 field.
	ADC120_ADCMPSR1_CMPSTCHA24_Msk = 0x100
	// Bit CMPSTCHA24.
	ADC120_ADCMPSR1_CMPSTCHA24 = 0x100
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA24_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA24_1 = 0x1
	// Position of CMPSTCHA25 field.
	ADC120_ADCMPSR1_CMPSTCHA25_Pos = 0x9
	// Bit mask of CMPSTCHA25 field.
	ADC120_ADCMPSR1_CMPSTCHA25_Msk = 0x200
	// Bit CMPSTCHA25.
	ADC120_ADCMPSR1_CMPSTCHA25 = 0x200
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA25_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA25_1 = 0x1
	// Position of CMPSTCHA26 field.
	ADC120_ADCMPSR1_CMPSTCHA26_Pos = 0xa
	// Bit mask of CMPSTCHA26 field.
	ADC120_ADCMPSR1_CMPSTCHA26_Msk = 0x400
	// Bit CMPSTCHA26.
	ADC120_ADCMPSR1_CMPSTCHA26 = 0x400
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA26_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA26_1 = 0x1
	// Position of CMPSTCHA27 field.
	ADC120_ADCMPSR1_CMPSTCHA27_Pos = 0xb
	// Bit mask of CMPSTCHA27 field.
	ADC120_ADCMPSR1_CMPSTCHA27_Msk = 0x800
	// Bit CMPSTCHA27.
	ADC120_ADCMPSR1_CMPSTCHA27 = 0x800
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA27_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA27_1 = 0x1
	// Position of CMPSTCHA28 field.
	ADC120_ADCMPSR1_CMPSTCHA28_Pos = 0xc
	// Bit mask of CMPSTCHA28 field.
	ADC120_ADCMPSR1_CMPSTCHA28_Msk = 0x1000
	// Bit CMPSTCHA28.
	ADC120_ADCMPSR1_CMPSTCHA28 = 0x1000
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA28_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA28_1 = 0x1
	// Position of CMPSTCHA29 field.
	ADC120_ADCMPSR1_CMPSTCHA29_Pos = 0xd
	// Bit mask of CMPSTCHA29 field.
	ADC120_ADCMPSR1_CMPSTCHA29_Msk = 0x2000
	// Bit CMPSTCHA29.
	ADC120_ADCMPSR1_CMPSTCHA29 = 0x2000
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA29_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA29_1 = 0x1
	// Position of CMPSTCHA30 field.
	ADC120_ADCMPSR1_CMPSTCHA30_Pos = 0xe
	// Bit mask of CMPSTCHA30 field.
	ADC120_ADCMPSR1_CMPSTCHA30_Msk = 0x4000
	// Bit CMPSTCHA30.
	ADC120_ADCMPSR1_CMPSTCHA30 = 0x4000
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA30_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA30_1 = 0x1
	// Position of CMPSTCHA31 field.
	ADC120_ADCMPSR1_CMPSTCHA31_Pos = 0xf
	// Bit mask of CMPSTCHA31 field.
	ADC120_ADCMPSR1_CMPSTCHA31_Msk = 0x8000
	// Bit CMPSTCHA31.
	ADC120_ADCMPSR1_CMPSTCHA31 = 0x8000
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA31_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA31_1 = 0x1

	// ADCMPSER: A/D Compare Function Window A Extended Input Channel Status Register
	// Position of CMPSTTSA field.
	ADC120_ADCMPSER_CMPSTTSA_Pos = 0x0
	// Bit mask of CMPSTTSA field.
	ADC120_ADCMPSER_CMPSTTSA_Msk = 0x1
	// Bit CMPSTTSA.
	ADC120_ADCMPSER_CMPSTTSA = 0x1
	// Comparison conditions are not met.
	ADC120_ADCMPSER_CMPSTTSA_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSER_CMPSTTSA_1 = 0x1
	// Position of CMPSTOCA field.
	ADC120_ADCMPSER_CMPSTOCA_Pos = 0x1
	// Bit mask of CMPSTOCA field.
	ADC120_ADCMPSER_CMPSTOCA_Msk = 0x2
	// Bit CMPSTOCA.
	ADC120_ADCMPSER_CMPSTOCA = 0x2
	// Comparison conditions are not met.
	ADC120_ADCMPSER_CMPSTOCA_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSER_CMPSTOCA_1 = 0x1

	// ADCMPBNSR: A/D Compare Function Window B Channel Select Register
	// Position of CMPCHB field.
	ADC120_ADCMPBNSR_CMPCHB_Pos = 0x0
	// Bit mask of CMPCHB field.
	ADC120_ADCMPBNSR_CMPCHB_Msk = 0x3f
	// Position of CMPLB field.
	ADC120_ADCMPBNSR_CMPLB_Pos = 0x7
	// Bit mask of CMPLB field.
	ADC120_ADCMPBNSR_CMPLB_Msk = 0x80
	// Bit CMPLB.
	ADC120_ADCMPBNSR_CMPLB = 0x80
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADWINLLB value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADWINLLB value, or ADWINULB value < A/D-converted value
	ADC120_ADCMPBNSR_CMPLB_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADWINLLB value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADWINLLB value < A/D-converted value < ADWINULB value
	ADC120_ADCMPBNSR_CMPLB_1 = 0x1

	// ADCMPBSR: A/D Compare Function Window B Status Register
	// Position of CMPSTB field.
	ADC120_ADCMPBSR_CMPSTB_Pos = 0x0
	// Bit mask of CMPSTB field.
	ADC120_ADCMPBSR_CMPSTB_Msk = 0x1
	// Bit CMPSTB.
	ADC120_ADCMPBSR_CMPSTB = 0x1
	// Comparison conditions are not met.
	ADC120_ADCMPBSR_CMPSTB_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPBSR_CMPSTB_1 = 0x1

	// ADSSTRL: A/D Sampling State Register
	// Position of SST field.
	ADC120_ADSSTRL_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC120_ADSSTRL_SST_Msk = 0xff

	// ADSSTRT: A/D Sampling State Register
	// Position of SST field.
	ADC120_ADSSTRT_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC120_ADSSTRT_SST_Msk = 0xff

	// ADSSTRO: A/D Sampling State Register
	// Position of SST field.
	ADC120_ADSSTRO_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC120_ADSSTRO_SST_Msk = 0xff

	// ADSSTR0: A/D Sampling State Register
	// Position of SST field.
	ADC120_ADSSTR_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC120_ADSSTR_SST_Msk = 0xff
)

// Constants for DAC12: 12-bit D/A converter
const (
	// DACR: D/A Control Register
	// Position of DAOE0 field.
	DAC12_DACR_DAOE0_Pos = 0x6
	// Bit mask of DAOE0 field.
	DAC12_DACR_DAOE0_Msk = 0x40
	// Bit DAOE0.
	DAC12_DACR_DAOE0 = 0x40
	// Disable analog output of channel 0 (DA0)
	DAC12_DACR_DAOE0_0 = 0x0
	// Enable D/A conversion of channel 0 (DA0)
	DAC12_DACR_DAOE0_1 = 0x1

	// DADPR: DADR0 Format Select Register
	// Position of DPSEL field.
	DAC12_DADPR_DPSEL_Pos = 0x7
	// Bit mask of DPSEL field.
	DAC12_DADPR_DPSEL_Msk = 0x80
	// Bit DPSEL.
	DAC12_DADPR_DPSEL = 0x80
	// Right-justified format
	DAC12_DADPR_DPSEL_0 = 0x0
	// Left-justified format
	DAC12_DADPR_DPSEL_1 = 0x1

	// DAADSCR: D/A A/D Synchronous Start Control Register
	// Position of DAADST field.
	DAC12_DAADSCR_DAADST_Pos = 0x7
	// Bit mask of DAADST field.
	DAC12_DAADSCR_DAADST_Msk = 0x80
	// Bit DAADST.
	DAC12_DAADSCR_DAADST = 0x80
	// Do not synchronize DAC12 with ADC12 operation (disable interference reduction between D/A and A/D conversion).
	DAC12_DAADSCR_DAADST_0 = 0x0
	// Synchronize DAC12 with ADC12 operation (enable interference reduction between D/A and A/D conversion).
	DAC12_DAADSCR_DAADST_1 = 0x1

	// DAVREFCR: D/A VREF Control Register
	// Position of REF field.
	DAC12_DAVREFCR_REF_Pos = 0x0
	// Bit mask of REF field.
	DAC12_DAVREFCR_REF_Msk = 0x1
	// Bit REF.
	DAC12_DAVREFCR_REF = 0x1
	// No reference voltage selected.
	DAC12_DAVREFCR_REF_0 = 0x0
	// AVCC0/AVSS0 selected.
	DAC12_DAVREFCR_REF_1 = 0x1
)

// Constants for SCI0: Serial Communication Interface 0
const (
	// SMR: Serial Mode Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
	// Position of CKS field.
	SCI0_SMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI0_SMR_CKS_Msk = 0x3
	// PCLK clock (n = 0)
	SCI0_SMR_CKS_00 = 0x0
	// PCLK/4 clock (n = 1)
	SCI0_SMR_CKS_01 = 0x1
	// PCLK/16 clock (n = 2)
	SCI0_SMR_CKS_10 = 0x2
	// PCLK/64 clock (n = 3)
	SCI0_SMR_CKS_11 = 0x3
	// Position of MP field.
	SCI0_SMR_MP_Pos = 0x2
	// Bit mask of MP field.
	SCI0_SMR_MP_Msk = 0x4
	// Bit MP.
	SCI0_SMR_MP = 0x4
	// Disable multi-processor communications function
	SCI0_SMR_MP_0 = 0x0
	// Enable multi-processor communications function
	SCI0_SMR_MP_1 = 0x1
	// Position of STOP field.
	SCI0_SMR_STOP_Pos = 0x3
	// Bit mask of STOP field.
	SCI0_SMR_STOP_Msk = 0x8
	// Bit STOP.
	SCI0_SMR_STOP = 0x8
	// 1 stop bit
	SCI0_SMR_STOP_0 = 0x0
	// 2 stop bits
	SCI0_SMR_STOP_1 = 0x1
	// Position of PM field.
	SCI0_SMR_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI0_SMR_PM_Msk = 0x10
	// Bit PM.
	SCI0_SMR_PM = 0x10
	// Even parity
	SCI0_SMR_PM_0 = 0x0
	// Odd parity
	SCI0_SMR_PM_1 = 0x1
	// Position of PE field.
	SCI0_SMR_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI0_SMR_PE_Msk = 0x20
	// Bit PE.
	SCI0_SMR_PE = 0x20
	// When transmitting: Do not add parity bit When receiving: Do not check parity bit
	SCI0_SMR_PE_0 = 0x0
	// When transmitting: Add parity bit When receiving: Check parity bit
	SCI0_SMR_PE_1 = 0x1
	// Position of CHR field.
	SCI0_SMR_CHR_Pos = 0x6
	// Bit mask of CHR field.
	SCI0_SMR_CHR_Msk = 0x40
	// Bit CHR.
	SCI0_SMR_CHR = 0x40
	// SCMR.CHR1 = 0: Transmit/receive in 9-bit data length SCMR.CHR1 = 1: Transmit/receive in 8-bit data length (initial value)
	SCI0_SMR_CHR_0 = 0x0
	// SCMR.CHR1 = 0: Transmit/receive in 9-bit data length SCMR.CHR1 = 1: Transmit/receive in 7-bit data length
	SCI0_SMR_CHR_1 = 0x1
	// Position of CM field.
	SCI0_SMR_CM_Pos = 0x7
	// Bit mask of CM field.
	SCI0_SMR_CM_Msk = 0x80
	// Bit CM.
	SCI0_SMR_CM = 0x80
	// Asynchronous mode or simple IIC mode
	SCI0_SMR_CM_0 = 0x0
	// Clock synchronous mode or simple SPI mode
	SCI0_SMR_CM_1 = 0x1

	// SMR_SMCI: Serial Mode Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of CKS field.
	SCI0_SMR_SMCI_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI0_SMR_SMCI_CKS_Msk = 0x3
	// PCLK clock (n = 0)
	SCI0_SMR_SMCI_CKS_00 = 0x0
	// PCLK/4 clock (n = 1)
	SCI0_SMR_SMCI_CKS_01 = 0x1
	// PCLK/16 clock (n = 2)
	SCI0_SMR_SMCI_CKS_10 = 0x2
	// PCLK/64 clock (n = 3)
	SCI0_SMR_SMCI_CKS_11 = 0x3
	// Position of BCP field.
	SCI0_SMR_SMCI_BCP_Pos = 0x2
	// Bit mask of BCP field.
	SCI0_SMR_SMCI_BCP_Msk = 0xc
	// Position of PM field.
	SCI0_SMR_SMCI_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI0_SMR_SMCI_PM_Msk = 0x10
	// Bit PM.
	SCI0_SMR_SMCI_PM = 0x10
	// Even parity
	SCI0_SMR_SMCI_PM_0 = 0x0
	// Odd parity
	SCI0_SMR_SMCI_PM_1 = 0x1
	// Position of PE field.
	SCI0_SMR_SMCI_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI0_SMR_SMCI_PE_Msk = 0x20
	// Bit PE.
	SCI0_SMR_SMCI_PE = 0x20
	// Position of BLK field.
	SCI0_SMR_SMCI_BLK_Pos = 0x6
	// Bit mask of BLK field.
	SCI0_SMR_SMCI_BLK_Msk = 0x40
	// Bit BLK.
	SCI0_SMR_SMCI_BLK = 0x40
	// Normal mode operation
	SCI0_SMR_SMCI_BLK_0 = 0x0
	// Block transfer mode operation
	SCI0_SMR_SMCI_BLK_1 = 0x1
	// Position of GM field.
	SCI0_SMR_SMCI_GM_Pos = 0x7
	// Bit mask of GM field.
	SCI0_SMR_SMCI_GM_Msk = 0x80
	// Bit GM.
	SCI0_SMR_SMCI_GM = 0x80
	// Normal mode operation
	SCI0_SMR_SMCI_GM_0 = 0x0
	// GSM mode operation
	SCI0_SMR_SMCI_GM_1 = 0x1

	// SCR: Serial Control Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
	// Position of CKE field.
	SCI0_SCR_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI0_SCR_CKE_Msk = 0x3
	// In asynchronous mode, the SCKn pin is available for use as an I/O port based on the I/O port settings. In clock synchronous mode, the SCKn pin functions as the clock output pin.
	SCI0_SCR_CKE_00 = 0x0
	// In asynchronous mode, a clock with the same frequency as the bit rate is output from the SCKn pin. In clock synchronous mode, the SCKn pin functions as the clock output pin.
	SCI0_SCR_CKE_01 = 0x1
	// Position of TEIE field.
	SCI0_SCR_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI0_SCR_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI0_SCR_TEIE = 0x4
	// Disable SCIn_TEI interrupt requests
	SCI0_SCR_TEIE_0 = 0x0
	// Enable SCIn_TEI interrupt requests
	SCI0_SCR_TEIE_1 = 0x1
	// Position of MPIE field.
	SCI0_SCR_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI0_SCR_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI0_SCR_MPIE = 0x8
	// Normal reception
	SCI0_SCR_MPIE_0 = 0x0
	// When data with the multi-processor bit set to 0 is received, the data is not read, and setting the status flags RDRF, ORER, and FER in SSR to 1. When data with the multi-processor bit set to 1 is received, the MPIE bit is automatically set to 0, and normal reception is resumed.
	SCI0_SCR_MPIE_1 = 0x1
	// Position of RE field.
	SCI0_SCR_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI0_SCR_RE_Msk = 0x10
	// Bit RE.
	SCI0_SCR_RE = 0x10
	// Disable serial reception
	SCI0_SCR_RE_0 = 0x0
	// Enable serial reception
	SCI0_SCR_RE_1 = 0x1
	// Position of TE field.
	SCI0_SCR_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI0_SCR_TE_Msk = 0x20
	// Bit TE.
	SCI0_SCR_TE = 0x20
	// Disable serial transmission
	SCI0_SCR_TE_0 = 0x0
	// Enable serial transmission
	SCI0_SCR_TE_1 = 0x1
	// Position of RIE field.
	SCI0_SCR_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI0_SCR_RIE_Msk = 0x40
	// Bit RIE.
	SCI0_SCR_RIE = 0x40
	// Disable SCIn_RXI and SCIn_ERI interrupt requests
	SCI0_SCR_RIE_0 = 0x0
	// Enable SCIn_RXI and SCIn_ERI interrupt requests
	SCI0_SCR_RIE_1 = 0x1
	// Position of TIE field.
	SCI0_SCR_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI0_SCR_TIE_Msk = 0x80
	// Bit TIE.
	SCI0_SCR_TIE = 0x80
	// Disable SCIn_TXI interrupt requests
	SCI0_SCR_TIE_0 = 0x0
	// Enable SCIn_TXI interrupt requests
	SCI0_SCR_TIE_1 = 0x1

	// SCR_SMCI: Serial Control Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of CKE field.
	SCI0_SCR_SMCI_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI0_SCR_SMCI_CKE_Msk = 0x3
	// When SMR_SMCI.GM = 0: Disable output The SCKn pin is available for use as an I/O port if set up in the I/O port settings When SMR_SMCI.GM = 1: Fix output low
	SCI0_SCR_SMCI_CKE_00 = 0x0
	// When SMR_SMCI.GM = 0: Output clock When SMR_SMCI.GM = 1: Output clock
	SCI0_SCR_SMCI_CKE_01 = 0x1
	// When SMR_SMCI.GM = 0: Setting prohibited When SMR_SMCI.GM = 1: Fix output high
	SCI0_SCR_SMCI_CKE_10 = 0x2
	// When SMR_SMCI.GM = 0: Setting prohibited When SMR_SMCI.GM = 1: Output clock
	SCI0_SCR_SMCI_CKE_11 = 0x3
	// Position of TEIE field.
	SCI0_SCR_SMCI_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI0_SCR_SMCI_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI0_SCR_SMCI_TEIE = 0x4
	// Position of MPIE field.
	SCI0_SCR_SMCI_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI0_SCR_SMCI_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI0_SCR_SMCI_MPIE = 0x8
	// Position of RE field.
	SCI0_SCR_SMCI_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI0_SCR_SMCI_RE_Msk = 0x10
	// Bit RE.
	SCI0_SCR_SMCI_RE = 0x10
	// Disable serial reception
	SCI0_SCR_SMCI_RE_0 = 0x0
	// Enable serial reception
	SCI0_SCR_SMCI_RE_1 = 0x1
	// Position of TE field.
	SCI0_SCR_SMCI_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI0_SCR_SMCI_TE_Msk = 0x20
	// Bit TE.
	SCI0_SCR_SMCI_TE = 0x20
	// Disable serial transmission
	SCI0_SCR_SMCI_TE_0 = 0x0
	// Enable serial transmission
	SCI0_SCR_SMCI_TE_1 = 0x1
	// Position of RIE field.
	SCI0_SCR_SMCI_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI0_SCR_SMCI_RIE_Msk = 0x40
	// Bit RIE.
	SCI0_SCR_SMCI_RIE = 0x40
	// Disable SCIn_RXI and SCIn_ERI interrupt requests
	SCI0_SCR_SMCI_RIE_0 = 0x0
	// Enable SCIn_RXI and SCIn_ERI interrupt requests
	SCI0_SCR_SMCI_RIE_1 = 0x1
	// Position of TIE field.
	SCI0_SCR_SMCI_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI0_SCR_SMCI_TIE_Msk = 0x80
	// Bit TIE.
	SCI0_SCR_SMCI_TIE = 0x80
	// Disable SCIn_TXI interrupt requests
	SCI0_SCR_SMCI_TIE_0 = 0x0
	// Enable SCIn_TXI interrupt requests
	SCI0_SCR_SMCI_TIE_1 = 0x1

	// SSR: Serial Status Register for Non-Smart Card Interface and Non-FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0)
	// Position of MPBT field.
	SCI0_SSR_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI0_SSR_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI0_SSR_MPBT = 0x1
	// Data transmission cycle
	SCI0_SSR_MPBT_0 = 0x0
	// ID transmission cycle
	SCI0_SSR_MPBT_1 = 0x1
	// Position of MPB field.
	SCI0_SSR_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_SSR_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_SSR_MPB = 0x2
	// Data transmission cycle
	SCI0_SSR_MPB_0 = 0x0
	// ID transmission cycle
	SCI0_SSR_MPB_1 = 0x1
	// Position of TEND field.
	SCI0_SSR_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_TEND = 0x4
	// A character is being transmitted
	SCI0_SSR_TEND_0 = 0x0
	// Character transfer is complete
	SCI0_SSR_TEND_1 = 0x1
	// Position of PER field.
	SCI0_SSR_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_PER = 0x8
	// No parity error occurred
	SCI0_SSR_PER_0 = 0x0
	// Parity error occurred
	SCI0_SSR_PER_1 = 0x1
	// Position of FER field.
	SCI0_SSR_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_SSR_FER_Msk = 0x10
	// Bit FER.
	SCI0_SSR_FER = 0x10
	// No framing error occurred
	SCI0_SSR_FER_0 = 0x0
	// Framing error occurred
	SCI0_SSR_FER_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_ORER_0 = 0x0
	// Overrun error occurred
	SCI0_SSR_ORER_1 = 0x1
	// Position of RDRF field.
	SCI0_SSR_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI0_SSR_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI0_SSR_RDRF = 0x40
	// No received data in RDR register
	SCI0_SSR_RDRF_0 = 0x0
	// Received data in RDR register
	SCI0_SSR_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI0_SSR_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI0_SSR_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI0_SSR_TDRE = 0x80
	// Transmit data in TDR register
	SCI0_SSR_TDRE_0 = 0x0
	// No transmit data in TDR register
	SCI0_SSR_TDRE_1 = 0x1

	// SSR_FIFO: Serial Status Register for Non-Smart Card Interface and FIFO Mode (SCMR.SMIF = 0, FCR.FM = 1)
	// Position of DR field.
	SCI0_SSR_FIFO_DR_Pos = 0x0
	// Bit mask of DR field.
	SCI0_SSR_FIFO_DR_Msk = 0x1
	// Bit DR.
	SCI0_SSR_FIFO_DR = 0x1
	// Receiving is in progress, or no received data remains in FRDRHL after successfully completed reception (receive FIFO empty)
	SCI0_SSR_FIFO_DR_0 = 0x0
	// Next receive data is not received for a period after normal receiving is complete, when the amount of data stored in the FIFO is equal to or less than the receive triggering number
	SCI0_SSR_FIFO_DR_1 = 0x1
	// Position of TEND field.
	SCI0_SSR_FIFO_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_FIFO_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_FIFO_TEND = 0x4
	// A character is being transmitted
	SCI0_SSR_FIFO_TEND_0 = 0x0
	// Character transfer is complete
	SCI0_SSR_FIFO_TEND_1 = 0x1
	// Position of PER field.
	SCI0_SSR_FIFO_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_FIFO_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_FIFO_PER = 0x8
	// No parity error occurred
	SCI0_SSR_FIFO_PER_0 = 0x0
	// Parity error occurred
	SCI0_SSR_FIFO_PER_1 = 0x1
	// Position of FER field.
	SCI0_SSR_FIFO_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_SSR_FIFO_FER_Msk = 0x10
	// Bit FER.
	SCI0_SSR_FIFO_FER = 0x10
	// No framing error occurred
	SCI0_SSR_FIFO_FER_0 = 0x0
	// Framing error occurred
	SCI0_SSR_FIFO_FER_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_FIFO_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_FIFO_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_FIFO_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_FIFO_ORER_0 = 0x0
	// Overrun error occurred
	SCI0_SSR_FIFO_ORER_1 = 0x1
	// Position of RDF field.
	SCI0_SSR_FIFO_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI0_SSR_FIFO_RDF_Msk = 0x40
	// Bit RDF.
	SCI0_SSR_FIFO_RDF = 0x40
	// The amount of receive data written in FRDRHL is less than the specified receive triggering number
	SCI0_SSR_FIFO_RDF_0 = 0x0
	// The amount of receive data written in FRDRHL is equal to or greater than the specified receive triggering number
	SCI0_SSR_FIFO_RDF_1 = 0x1
	// Position of TDFE field.
	SCI0_SSR_FIFO_TDFE_Pos = 0x7
	// Bit mask of TDFE field.
	SCI0_SSR_FIFO_TDFE_Msk = 0x80
	// Bit TDFE.
	SCI0_SSR_FIFO_TDFE = 0x80
	// The amount of transmit data written in FTDRHL exceeds the specified transmit triggering number
	SCI0_SSR_FIFO_TDFE_0 = 0x0
	// The amount of transmit data written in FTDRHL is equal to or less than the specified transmit triggering number
	SCI0_SSR_FIFO_TDFE_1 = 0x1

	// SSR_SMCI: Serial Status Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of MPBT field.
	SCI0_SSR_SMCI_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI0_SSR_SMCI_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI0_SSR_SMCI_MPBT = 0x1
	// Position of MPB field.
	SCI0_SSR_SMCI_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_SSR_SMCI_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_SSR_SMCI_MPB = 0x2
	// Position of TEND field.
	SCI0_SSR_SMCI_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_SMCI_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_SMCI_TEND = 0x4
	// A character is being transmitted
	SCI0_SSR_SMCI_TEND_0 = 0x0
	// Character transfer is complete
	SCI0_SSR_SMCI_TEND_1 = 0x1
	// Position of PER field.
	SCI0_SSR_SMCI_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_SMCI_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_SMCI_PER = 0x8
	// No parity error occurred
	SCI0_SSR_SMCI_PER_0 = 0x0
	// Parity error occurred
	SCI0_SSR_SMCI_PER_1 = 0x1
	// Position of ERS field.
	SCI0_SSR_SMCI_ERS_Pos = 0x4
	// Bit mask of ERS field.
	SCI0_SSR_SMCI_ERS_Msk = 0x10
	// Bit ERS.
	SCI0_SSR_SMCI_ERS = 0x10
	// No low error signal response
	SCI0_SSR_SMCI_ERS_0 = 0x0
	// Low error signal response occurred
	SCI0_SSR_SMCI_ERS_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_SMCI_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_SMCI_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_SMCI_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_SMCI_ORER_0 = 0x0
	// Overrun error occurred
	SCI0_SSR_SMCI_ORER_1 = 0x1
	// Position of RDRF field.
	SCI0_SSR_SMCI_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI0_SSR_SMCI_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI0_SSR_SMCI_RDRF = 0x40
	// No received data in RDR register
	SCI0_SSR_SMCI_RDRF_0 = 0x0
	// Received data in RDR register
	SCI0_SSR_SMCI_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI0_SSR_SMCI_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI0_SSR_SMCI_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI0_SSR_SMCI_TDRE = 0x80
	// Transmit data in TDR register
	SCI0_SSR_SMCI_TDRE_0 = 0x0
	// No transmit data in TDR register
	SCI0_SSR_SMCI_TDRE_1 = 0x1

	// SCMR: Smart Card Mode Register
	// Position of SMIF field.
	SCI0_SCMR_SMIF_Pos = 0x0
	// Bit mask of SMIF field.
	SCI0_SCMR_SMIF_Msk = 0x1
	// Bit SMIF.
	SCI0_SCMR_SMIF = 0x1
	// Non-smart card interface mode (asynchronous mode, clock synchronous mode, simple SPI mode, or simple IIC mode)
	SCI0_SCMR_SMIF_0 = 0x0
	// Smart card interface mode
	SCI0_SCMR_SMIF_1 = 0x1
	// Position of SINV field.
	SCI0_SCMR_SINV_Pos = 0x2
	// Bit mask of SINV field.
	SCI0_SCMR_SINV_Msk = 0x4
	// Bit SINV.
	SCI0_SCMR_SINV = 0x4
	// TDR contents are transmitted as they are. Received data is stored as received in the RDR register.
	SCI0_SCMR_SINV_0 = 0x0
	// TDR register contents are inverted before transmission. Receive data is stored in inverted form in the RDR register.
	SCI0_SCMR_SINV_1 = 0x1
	// Position of SDIR field.
	SCI0_SCMR_SDIR_Pos = 0x3
	// Bit mask of SDIR field.
	SCI0_SCMR_SDIR_Msk = 0x8
	// Bit SDIR.
	SCI0_SCMR_SDIR = 0x8
	// Transfer LSB-first
	SCI0_SCMR_SDIR_0 = 0x0
	// Transfer MSB-first
	SCI0_SCMR_SDIR_1 = 0x1
	// Position of CHR1 field.
	SCI0_SCMR_CHR1_Pos = 0x4
	// Bit mask of CHR1 field.
	SCI0_SCMR_CHR1_Msk = 0x10
	// Bit CHR1.
	SCI0_SCMR_CHR1 = 0x10
	// SMR.CHR = 0: Transmit/receive in 9-bit data length SMR.CHR = 1: Transmit/receive in 9-bit data length
	SCI0_SCMR_CHR1_0 = 0x0
	// SMR.CHR = 0: Transmit/receive in 8-bit data length (initial value) SMR.CHR = 1: Transmit/receive in 7-bit data length
	SCI0_SCMR_CHR1_1 = 0x1
	// Position of BCP2 field.
	SCI0_SCMR_BCP2_Pos = 0x7
	// Bit mask of BCP2 field.
	SCI0_SCMR_BCP2_Msk = 0x80
	// Bit BCP2.
	SCI0_SCMR_BCP2 = 0x80

	// SEMR: Serial Extended Mode Register
	// Position of BRME field.
	SCI0_SEMR_BRME_Pos = 0x2
	// Bit mask of BRME field.
	SCI0_SEMR_BRME_Msk = 0x4
	// Bit BRME.
	SCI0_SEMR_BRME = 0x4
	// Disable bit rate modulation function
	SCI0_SEMR_BRME_0 = 0x0
	// Enable bit rate modulation function
	SCI0_SEMR_BRME_1 = 0x1
	// Position of ABCSE field.
	SCI0_SEMR_ABCSE_Pos = 0x3
	// Bit mask of ABCSE field.
	SCI0_SEMR_ABCSE_Msk = 0x8
	// Bit ABCSE.
	SCI0_SEMR_ABCSE = 0x8
	// Clock cycles for 1-bit period determined by combination of the BGDM and ABCS bits in the SEMR register
	SCI0_SEMR_ABCSE_0 = 0x0
	// Baud rate is 6 base clock cycles for 1-bit period
	SCI0_SEMR_ABCSE_1 = 0x1
	// Position of ABCS field.
	SCI0_SEMR_ABCS_Pos = 0x4
	// Bit mask of ABCS field.
	SCI0_SEMR_ABCS_Msk = 0x10
	// Bit ABCS.
	SCI0_SEMR_ABCS = 0x10
	// Select 16 base clock cycles for 1-bit period
	SCI0_SEMR_ABCS_0 = 0x0
	// Select 8 base clock cycles for 1-bit period
	SCI0_SEMR_ABCS_1 = 0x1
	// Position of NFEN field.
	SCI0_SEMR_NFEN_Pos = 0x5
	// Bit mask of NFEN field.
	SCI0_SEMR_NFEN_Msk = 0x20
	// Bit NFEN.
	SCI0_SEMR_NFEN = 0x20
	// In asynchronous mode: Disable noise cancellation function for RXDn input signal In simple I2C mode: Disable noise cancellation function for SCLn and SDAn input signals
	SCI0_SEMR_NFEN_0 = 0x0
	// In asynchronous mode: Enable noise cancellation function for RXDn input signal In simple I2C mode: Enable noise cancellation function for SCLn and SDAn input signals
	SCI0_SEMR_NFEN_1 = 0x1
	// Position of BGDM field.
	SCI0_SEMR_BGDM_Pos = 0x6
	// Bit mask of BGDM field.
	SCI0_SEMR_BGDM_Msk = 0x40
	// Bit BGDM.
	SCI0_SEMR_BGDM = 0x40
	// Output clock from baud rate generator with normal frequency
	SCI0_SEMR_BGDM_0 = 0x0
	// Output clock from baud rate generator with doubled frequency
	SCI0_SEMR_BGDM_1 = 0x1
	// Position of RXDESEL field.
	SCI0_SEMR_RXDESEL_Pos = 0x7
	// Bit mask of RXDESEL field.
	SCI0_SEMR_RXDESEL_Msk = 0x80
	// Bit RXDESEL.
	SCI0_SEMR_RXDESEL = 0x80
	// Detect low level on RXDn pin as start bit
	SCI0_SEMR_RXDESEL_0 = 0x0
	// Detect falling edge of RXDn pin as start bit
	SCI0_SEMR_RXDESEL_1 = 0x1

	// SNFR: Noise Filter Setting Register
	// Position of NFCS field.
	SCI0_SNFR_NFCS_Pos = 0x0
	// Bit mask of NFCS field.
	SCI0_SNFR_NFCS_Msk = 0x7
	// In asynchronous mode: Use clock signal divided by 1 with noise filter In simple I2C mode: Setting prohibited
	SCI0_SNFR_NFCS_000 = 0x0
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 1 with noise filter
	SCI0_SNFR_NFCS_001 = 0x1
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 2 with noise filter
	SCI0_SNFR_NFCS_010 = 0x2
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 4 with noise filter
	SCI0_SNFR_NFCS_011 = 0x3
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 8 with noise filter
	SCI0_SNFR_NFCS_100 = 0x4

	// SIMR1: IIC Mode Register 1
	// Position of IICM field.
	SCI0_SIMR1_IICM_Pos = 0x0
	// Bit mask of IICM field.
	SCI0_SIMR1_IICM_Msk = 0x1
	// Bit IICM.
	SCI0_SIMR1_IICM = 0x1
	// SCMR.SMIF = 0: Asynchronous mode (including multi-processor mode), clock synchronous mode, or simple SPI mode SCMR.SMIF = 1: Smart card interface mode
	SCI0_SIMR1_IICM_0 = 0x0
	// SCMR.SMIF = 0: Simple IIC mode SCMR.SMIF = 1: Setting prohibited
	SCI0_SIMR1_IICM_1 = 0x1
	// Position of IICDL field.
	SCI0_SIMR1_IICDL_Pos = 0x3
	// Bit mask of IICDL field.
	SCI0_SIMR1_IICDL_Msk = 0xf8
	// No output delay
	SCI0_SIMR1_IICDL_0x00 = 0x0

	// SIMR2: IIC Mode Register 2
	// Position of IICINTM field.
	SCI0_SIMR2_IICINTM_Pos = 0x0
	// Bit mask of IICINTM field.
	SCI0_SIMR2_IICINTM_Msk = 0x1
	// Bit IICINTM.
	SCI0_SIMR2_IICINTM = 0x1
	// Use ACK/NACK interrupts
	SCI0_SIMR2_IICINTM_0 = 0x0
	// Use reception and transmission interrupts
	SCI0_SIMR2_IICINTM_1 = 0x1
	// Position of IICCSC field.
	SCI0_SIMR2_IICCSC_Pos = 0x1
	// Bit mask of IICCSC field.
	SCI0_SIMR2_IICCSC_Msk = 0x2
	// Bit IICCSC.
	SCI0_SIMR2_IICCSC = 0x2
	// Do not synchronize with clock signal
	SCI0_SIMR2_IICCSC_0 = 0x0
	// Synchronize with clock signal
	SCI0_SIMR2_IICCSC_1 = 0x1
	// Position of IICACKT field.
	SCI0_SIMR2_IICACKT_Pos = 0x5
	// Bit mask of IICACKT field.
	SCI0_SIMR2_IICACKT_Msk = 0x20
	// Bit IICACKT.
	SCI0_SIMR2_IICACKT = 0x20
	// ACK transmission
	SCI0_SIMR2_IICACKT_0 = 0x0
	// NACK transmission and ACK/NACK reception
	SCI0_SIMR2_IICACKT_1 = 0x1

	// SIMR3: IIC Mode Register 3
	// Position of IICSTAREQ field.
	SCI0_SIMR3_IICSTAREQ_Pos = 0x0
	// Bit mask of IICSTAREQ field.
	SCI0_SIMR3_IICSTAREQ_Msk = 0x1
	// Bit IICSTAREQ.
	SCI0_SIMR3_IICSTAREQ = 0x1
	// Do not generate start condition
	SCI0_SIMR3_IICSTAREQ_0 = 0x0
	// Generate start condition
	SCI0_SIMR3_IICSTAREQ_1 = 0x1
	// Position of IICRSTAREQ field.
	SCI0_SIMR3_IICRSTAREQ_Pos = 0x1
	// Bit mask of IICRSTAREQ field.
	SCI0_SIMR3_IICRSTAREQ_Msk = 0x2
	// Bit IICRSTAREQ.
	SCI0_SIMR3_IICRSTAREQ = 0x2
	// Do not generate restart condition
	SCI0_SIMR3_IICRSTAREQ_0 = 0x0
	// Generate restart condition
	SCI0_SIMR3_IICRSTAREQ_1 = 0x1
	// Position of IICSTPREQ field.
	SCI0_SIMR3_IICSTPREQ_Pos = 0x2
	// Bit mask of IICSTPREQ field.
	SCI0_SIMR3_IICSTPREQ_Msk = 0x4
	// Bit IICSTPREQ.
	SCI0_SIMR3_IICSTPREQ = 0x4
	// Do not generate stop condition
	SCI0_SIMR3_IICSTPREQ_0 = 0x0
	// Generate stop condition
	SCI0_SIMR3_IICSTPREQ_1 = 0x1
	// Position of IICSTIF field.
	SCI0_SIMR3_IICSTIF_Pos = 0x3
	// Bit mask of IICSTIF field.
	SCI0_SIMR3_IICSTIF_Msk = 0x8
	// Bit IICSTIF.
	SCI0_SIMR3_IICSTIF = 0x8
	// No requests are being made for generating conditions, or a condition is being generated
	SCI0_SIMR3_IICSTIF_0 = 0x0
	// Generation of start, restart, or stop condition is complete. When 0 is written to IICSTIF, it is set to 0
	SCI0_SIMR3_IICSTIF_1 = 0x1
	// Position of IICSDAS field.
	SCI0_SIMR3_IICSDAS_Pos = 0x4
	// Bit mask of IICSDAS field.
	SCI0_SIMR3_IICSDAS_Msk = 0x30
	// Output serial data
	SCI0_SIMR3_IICSDAS_00 = 0x0
	// Generate start, restart, or stop condition
	SCI0_SIMR3_IICSDAS_01 = 0x1
	// Output low on SDAn pin
	SCI0_SIMR3_IICSDAS_10 = 0x2
	// Drive SDAn pin to high-impedance state
	SCI0_SIMR3_IICSDAS_11 = 0x3
	// Position of IICSCLS field.
	SCI0_SIMR3_IICSCLS_Pos = 0x6
	// Bit mask of IICSCLS field.
	SCI0_SIMR3_IICSCLS_Msk = 0xc0
	// Output serial clock
	SCI0_SIMR3_IICSCLS_00 = 0x0
	// Generate start, restart, or stop condition
	SCI0_SIMR3_IICSCLS_01 = 0x1
	// Output low on SCLn pin
	SCI0_SIMR3_IICSCLS_10 = 0x2
	// Drive SCLn pin to high-impedance state
	SCI0_SIMR3_IICSCLS_11 = 0x3

	// SISR: IIC Status Register
	// Position of IICACKR field.
	SCI0_SISR_IICACKR_Pos = 0x0
	// Bit mask of IICACKR field.
	SCI0_SISR_IICACKR_Msk = 0x1
	// Bit IICACKR.
	SCI0_SISR_IICACKR = 0x1
	// ACK received
	SCI0_SISR_IICACKR_0 = 0x0
	// NACK received
	SCI0_SISR_IICACKR_1 = 0x1

	// SPMR: SPI Mode Register
	// Position of SSE field.
	SCI0_SPMR_SSE_Pos = 0x0
	// Bit mask of SSE field.
	SCI0_SPMR_SSE_Msk = 0x1
	// Bit SSE.
	SCI0_SPMR_SSE = 0x1
	// Disable SSn pin function
	SCI0_SPMR_SSE_0 = 0x0
	// Enable SSn pin function
	SCI0_SPMR_SSE_1 = 0x1
	// Position of CTSE field.
	SCI0_SPMR_CTSE_Pos = 0x1
	// Bit mask of CTSE field.
	SCI0_SPMR_CTSE_Msk = 0x2
	// Bit CTSE.
	SCI0_SPMR_CTSE = 0x2
	// Disable CTS function (enable RTS output function)
	SCI0_SPMR_CTSE_0 = 0x0
	// Enable CTS function
	SCI0_SPMR_CTSE_1 = 0x1
	// Position of MSS field.
	SCI0_SPMR_MSS_Pos = 0x2
	// Bit mask of MSS field.
	SCI0_SPMR_MSS_Msk = 0x4
	// Bit MSS.
	SCI0_SPMR_MSS = 0x4
	// Transmit through TXDn pin and receive through RXDn pin (master mode)
	SCI0_SPMR_MSS_0 = 0x0
	// Receive through TXDn pin and transmit through RXDn pin (slave mode)
	SCI0_SPMR_MSS_1 = 0x1
	// Position of MFF field.
	SCI0_SPMR_MFF_Pos = 0x4
	// Bit mask of MFF field.
	SCI0_SPMR_MFF_Msk = 0x10
	// Bit MFF.
	SCI0_SPMR_MFF = 0x10
	// No mode fault error
	SCI0_SPMR_MFF_0 = 0x0
	// Mode fault error
	SCI0_SPMR_MFF_1 = 0x1
	// Position of CKPOL field.
	SCI0_SPMR_CKPOL_Pos = 0x6
	// Bit mask of CKPOL field.
	SCI0_SPMR_CKPOL_Msk = 0x40
	// Bit CKPOL.
	SCI0_SPMR_CKPOL = 0x40
	// Do not invert clock polarity
	SCI0_SPMR_CKPOL_0 = 0x0
	// Invert clock polarity
	SCI0_SPMR_CKPOL_1 = 0x1
	// Position of CKPH field.
	SCI0_SPMR_CKPH_Pos = 0x7
	// Bit mask of CKPH field.
	SCI0_SPMR_CKPH_Msk = 0x80
	// Bit CKPH.
	SCI0_SPMR_CKPH = 0x80
	// Do not delay clock
	SCI0_SPMR_CKPH_0 = 0x0
	// Delay clock
	SCI0_SPMR_CKPH_1 = 0x1

	// FTDRHL: Transmit FIFO Data Register
	// Position of TDAT field.
	SCI0_FTDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI0_FTDRHL_TDAT_Msk = 0x1ff
	// Position of MPBT field.
	SCI0_FTDRHL_MPBT_Pos = 0x9
	// Bit mask of MPBT field.
	SCI0_FTDRHL_MPBT_Msk = 0x200
	// Bit MPBT.
	SCI0_FTDRHL_MPBT = 0x200
	// Data transmission cycle
	SCI0_FTDRHL_MPBT_0 = 0x0
	// ID transmission cycle
	SCI0_FTDRHL_MPBT_1 = 0x1

	// TDRHL: Transmit Data Register
	// Position of TDAT field.
	SCI0_TDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI0_TDRHL_TDAT_Msk = 0x1ff

	// FTDRH: Transmit FIFO Data Register
	// Position of MPBT field.
	SCI0_FTDRH_MPBT_Pos = 0x1
	// Bit mask of MPBT field.
	SCI0_FTDRH_MPBT_Msk = 0x2
	// Bit MPBT.
	SCI0_FTDRH_MPBT = 0x2
	// Data transmission cycle
	SCI0_FTDRH_MPBT_0 = 0x0
	// ID transmission cycle
	SCI0_FTDRH_MPBT_1 = 0x1

	// FTDRL: Transmit FIFO Data Register
	// Position of TDAT field.
	SCI0_FTDRL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI0_FTDRL_TDAT_Msk = 0xff

	// FRDRHL: Receive FIFO Data Register
	// Position of RDAT field.
	SCI0_FRDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI0_FRDRHL_RDAT_Msk = 0x1ff
	// Position of MPB field.
	SCI0_FRDRHL_MPB_Pos = 0x9
	// Bit mask of MPB field.
	SCI0_FRDRHL_MPB_Msk = 0x200
	// Bit MPB.
	SCI0_FRDRHL_MPB = 0x200
	// Data transmission cycle
	SCI0_FRDRHL_MPB_0 = 0x0
	// ID transmission cycle
	SCI0_FRDRHL_MPB_1 = 0x1
	// Position of DR field.
	SCI0_FRDRHL_DR_Pos = 0xa
	// Bit mask of DR field.
	SCI0_FRDRHL_DR_Msk = 0x400
	// Bit DR.
	SCI0_FRDRHL_DR = 0x400
	// Receiving is in progress, or no received data remains in the FRDRH and FRDRL registers after successfully completed reception
	SCI0_FRDRHL_DR_0 = 0x0
	// Next receive data is not received for a period after successfully completed reception
	SCI0_FRDRHL_DR_1 = 0x1
	// Position of PER field.
	SCI0_FRDRHL_PER_Pos = 0xb
	// Bit mask of PER field.
	SCI0_FRDRHL_PER_Msk = 0x800
	// Bit PER.
	SCI0_FRDRHL_PER = 0x800
	// No parity error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRHL_PER_0 = 0x0
	// Parity error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRHL_PER_1 = 0x1
	// Position of FER field.
	SCI0_FRDRHL_FER_Pos = 0xc
	// Bit mask of FER field.
	SCI0_FRDRHL_FER_Msk = 0x1000
	// Bit FER.
	SCI0_FRDRHL_FER = 0x1000
	// No framing error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRHL_FER_0 = 0x0
	// Framing error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRHL_FER_1 = 0x1
	// Position of ORER field.
	SCI0_FRDRHL_ORER_Pos = 0xd
	// Bit mask of ORER field.
	SCI0_FRDRHL_ORER_Msk = 0x2000
	// Bit ORER.
	SCI0_FRDRHL_ORER = 0x2000
	// No overrun error occurred
	SCI0_FRDRHL_ORER_0 = 0x0
	// Overrun error occurred
	SCI0_FRDRHL_ORER_1 = 0x1
	// Position of RDF field.
	SCI0_FRDRHL_RDF_Pos = 0xe
	// Bit mask of RDF field.
	SCI0_FRDRHL_RDF_Msk = 0x4000
	// Bit RDF.
	SCI0_FRDRHL_RDF = 0x4000
	// The amount of receive data written in FRDRH and FRDRL is less than the specified receive triggering number
	SCI0_FRDRHL_RDF_0 = 0x0
	// The amount of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number
	SCI0_FRDRHL_RDF_1 = 0x1

	// RDRHL: Receive Data Register
	// Position of RDAT field.
	SCI0_RDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI0_RDRHL_RDAT_Msk = 0x1ff

	// FRDRH: Receive FIFO Data Register
	// Position of MPB field.
	SCI0_FRDRH_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_FRDRH_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_FRDRH_MPB = 0x2
	// Data transmission cycle
	SCI0_FRDRH_MPB_0 = 0x0
	// ID transmission cycle
	SCI0_FRDRH_MPB_1 = 0x1
	// Position of DR field.
	SCI0_FRDRH_DR_Pos = 0x2
	// Bit mask of DR field.
	SCI0_FRDRH_DR_Msk = 0x4
	// Bit DR.
	SCI0_FRDRH_DR = 0x4
	// Receiving is in progress, or no received data remains in the FRDRH and FRDRL registers after successfully completed reception
	SCI0_FRDRH_DR_0 = 0x0
	// Next receive data is not received for a period after successfully completed reception
	SCI0_FRDRH_DR_1 = 0x1
	// Position of PER field.
	SCI0_FRDRH_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_FRDRH_PER_Msk = 0x8
	// Bit PER.
	SCI0_FRDRH_PER = 0x8
	// No parity error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRH_PER_0 = 0x0
	// Parity error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRH_PER_1 = 0x1
	// Position of FER field.
	SCI0_FRDRH_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_FRDRH_FER_Msk = 0x10
	// Bit FER.
	SCI0_FRDRH_FER = 0x10
	// No framing error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRH_FER_0 = 0x0
	// Framing error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRH_FER_1 = 0x1
	// Position of ORER field.
	SCI0_FRDRH_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_FRDRH_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_FRDRH_ORER = 0x20
	// No overrun error occurred
	SCI0_FRDRH_ORER_0 = 0x0
	// Overrun error occurred
	SCI0_FRDRH_ORER_1 = 0x1
	// Position of RDF field.
	SCI0_FRDRH_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI0_FRDRH_RDF_Msk = 0x40
	// Bit RDF.
	SCI0_FRDRH_RDF = 0x40
	// The amount of receive data written in FRDRH and FRDRL is less than the specified receive triggering number
	SCI0_FRDRH_RDF_0 = 0x0
	// The amount of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number
	SCI0_FRDRH_RDF_1 = 0x1

	// FRDRL: Receive FIFO Data Register
	// Position of RDAT field.
	SCI0_FRDRL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI0_FRDRL_RDAT_Msk = 0xff

	// DCCR: Data Compare Match Control Register
	// Position of DCMF field.
	SCI0_DCCR_DCMF_Pos = 0x0
	// Bit mask of DCMF field.
	SCI0_DCCR_DCMF_Msk = 0x1
	// Bit DCMF.
	SCI0_DCCR_DCMF = 0x1
	// Not matched
	SCI0_DCCR_DCMF_0 = 0x0
	// Matched
	SCI0_DCCR_DCMF_1 = 0x1
	// Position of DPER field.
	SCI0_DCCR_DPER_Pos = 0x3
	// Bit mask of DPER field.
	SCI0_DCCR_DPER_Msk = 0x8
	// Bit DPER.
	SCI0_DCCR_DPER = 0x8
	// No parity error occurred
	SCI0_DCCR_DPER_0 = 0x0
	// Parity error occurred
	SCI0_DCCR_DPER_1 = 0x1
	// Position of DFER field.
	SCI0_DCCR_DFER_Pos = 0x4
	// Bit mask of DFER field.
	SCI0_DCCR_DFER_Msk = 0x10
	// Bit DFER.
	SCI0_DCCR_DFER = 0x10
	// No framing error occurred
	SCI0_DCCR_DFER_0 = 0x0
	// Framing error occurred
	SCI0_DCCR_DFER_1 = 0x1
	// Position of IDSEL field.
	SCI0_DCCR_IDSEL_Pos = 0x6
	// Bit mask of IDSEL field.
	SCI0_DCCR_IDSEL_Msk = 0x40
	// Bit IDSEL.
	SCI0_DCCR_IDSEL = 0x40
	// Always compare data regardless of the MPB bit value
	SCI0_DCCR_IDSEL_0 = 0x0
	// Only compare data when MPB bit = 1 (ID frame)
	SCI0_DCCR_IDSEL_1 = 0x1
	// Position of DCME field.
	SCI0_DCCR_DCME_Pos = 0x7
	// Bit mask of DCME field.
	SCI0_DCCR_DCME_Msk = 0x80
	// Bit DCME.
	SCI0_DCCR_DCME = 0x80
	// Disable address match function
	SCI0_DCCR_DCME_0 = 0x0
	// Enable address match function
	SCI0_DCCR_DCME_1 = 0x1

	// FCR: FIFO Control Register
	// Position of FM field.
	SCI0_FCR_FM_Pos = 0x0
	// Bit mask of FM field.
	SCI0_FCR_FM_Msk = 0x1
	// Bit FM.
	SCI0_FCR_FM = 0x1
	// Non-FIFO mode. Selects TDR/RDR or TDRHL/RDRHL for communication.
	SCI0_FCR_FM_0 = 0x0
	// FIFO mode. Selects FTDRHL/FRDRHL for communication.
	SCI0_FCR_FM_1 = 0x1
	// Position of RFRST field.
	SCI0_FCR_RFRST_Pos = 0x1
	// Bit mask of RFRST field.
	SCI0_FCR_RFRST_Msk = 0x2
	// Bit RFRST.
	SCI0_FCR_RFRST = 0x2
	// Do not reset FRDRHL
	SCI0_FCR_RFRST_0 = 0x0
	// Reset FRDRHL
	SCI0_FCR_RFRST_1 = 0x1
	// Position of TFRST field.
	SCI0_FCR_TFRST_Pos = 0x2
	// Bit mask of TFRST field.
	SCI0_FCR_TFRST_Msk = 0x4
	// Bit TFRST.
	SCI0_FCR_TFRST = 0x4
	// Do not reset FTDRHL
	SCI0_FCR_TFRST_0 = 0x0
	// Reset FTDRHL
	SCI0_FCR_TFRST_1 = 0x1
	// Position of DRES field.
	SCI0_FCR_DRES_Pos = 0x3
	// Bit mask of DRES field.
	SCI0_FCR_DRES_Msk = 0x8
	// Bit DRES.
	SCI0_FCR_DRES = 0x8
	// Receive data full interrupt (SCIn_RXI)
	SCI0_FCR_DRES_0 = 0x0
	// Receive error interrupt (SCIn_ERI)
	SCI0_FCR_DRES_1 = 0x1
	// Position of TTRG field.
	SCI0_FCR_TTRG_Pos = 0x4
	// Bit mask of TTRG field.
	SCI0_FCR_TTRG_Msk = 0xf0
	// Position of RTRG field.
	SCI0_FCR_RTRG_Pos = 0x8
	// Bit mask of RTRG field.
	SCI0_FCR_RTRG_Msk = 0xf00
	// Position of RSTRG field.
	SCI0_FCR_RSTRG_Pos = 0xc
	// Bit mask of RSTRG field.
	SCI0_FCR_RSTRG_Msk = 0xf000

	// FDR: FIFO Data Count Register
	// Position of R field.
	SCI0_FDR_R_Pos = 0x0
	// Bit mask of R field.
	SCI0_FDR_R_Msk = 0x1f
	// Position of T field.
	SCI0_FDR_T_Pos = 0x8
	// Bit mask of T field.
	SCI0_FDR_T_Msk = 0x1f00

	// LSR: Line Status Register
	// Position of ORER field.
	SCI0_LSR_ORER_Pos = 0x0
	// Bit mask of ORER field.
	SCI0_LSR_ORER_Msk = 0x1
	// Bit ORER.
	SCI0_LSR_ORER = 0x1
	// No overrun error occurred
	SCI0_LSR_ORER_0 = 0x0
	// Overrun error occurred
	SCI0_LSR_ORER_1 = 0x1
	// Position of FNUM field.
	SCI0_LSR_FNUM_Pos = 0x2
	// Bit mask of FNUM field.
	SCI0_LSR_FNUM_Msk = 0x7c
	// Position of PNUM field.
	SCI0_LSR_PNUM_Pos = 0x8
	// Bit mask of PNUM field.
	SCI0_LSR_PNUM_Msk = 0x1f00

	// CDR: Compare Match Data Register
	// Position of CMPD field.
	SCI0_CDR_CMPD_Pos = 0x0
	// Bit mask of CMPD field.
	SCI0_CDR_CMPD_Msk = 0x1ff

	// SPTR: Serial Port Register
	// Position of RXDMON field.
	SCI0_SPTR_RXDMON_Pos = 0x0
	// Bit mask of RXDMON field.
	SCI0_SPTR_RXDMON_Msk = 0x1
	// Bit RXDMON.
	SCI0_SPTR_RXDMON = 0x1
	// Position of SPB2DT field.
	SCI0_SPTR_SPB2DT_Pos = 0x1
	// Bit mask of SPB2DT field.
	SCI0_SPTR_SPB2DT_Msk = 0x2
	// Bit SPB2DT.
	SCI0_SPTR_SPB2DT = 0x2
	// Position of SPB2IO field.
	SCI0_SPTR_SPB2IO_Pos = 0x2
	// Bit mask of SPB2IO field.
	SCI0_SPTR_SPB2IO_Msk = 0x4
	// Bit SPB2IO.
	SCI0_SPTR_SPB2IO = 0x4
	// Do not output value of SPB2DT bit on TXDn pin
	SCI0_SPTR_SPB2IO_0 = 0x0
	// Output value of SPB2DT bit on TXDn pin
	SCI0_SPTR_SPB2IO_1 = 0x1
)

// Constants for SCI1: Serial Communication Interface 0
const (
	// SMR: Serial Mode Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
	// Position of CKS field.
	SCI1_SMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI1_SMR_CKS_Msk = 0x3
	// PCLK clock (n = 0)
	SCI1_SMR_CKS_00 = 0x0
	// PCLK/4 clock (n = 1)
	SCI1_SMR_CKS_01 = 0x1
	// PCLK/16 clock (n = 2)
	SCI1_SMR_CKS_10 = 0x2
	// PCLK/64 clock (n = 3)
	SCI1_SMR_CKS_11 = 0x3
	// Position of MP field.
	SCI1_SMR_MP_Pos = 0x2
	// Bit mask of MP field.
	SCI1_SMR_MP_Msk = 0x4
	// Bit MP.
	SCI1_SMR_MP = 0x4
	// Disable multi-processor communications function
	SCI1_SMR_MP_0 = 0x0
	// Enable multi-processor communications function
	SCI1_SMR_MP_1 = 0x1
	// Position of STOP field.
	SCI1_SMR_STOP_Pos = 0x3
	// Bit mask of STOP field.
	SCI1_SMR_STOP_Msk = 0x8
	// Bit STOP.
	SCI1_SMR_STOP = 0x8
	// 1 stop bit
	SCI1_SMR_STOP_0 = 0x0
	// 2 stop bits
	SCI1_SMR_STOP_1 = 0x1
	// Position of PM field.
	SCI1_SMR_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI1_SMR_PM_Msk = 0x10
	// Bit PM.
	SCI1_SMR_PM = 0x10
	// Even parity
	SCI1_SMR_PM_0 = 0x0
	// Odd parity
	SCI1_SMR_PM_1 = 0x1
	// Position of PE field.
	SCI1_SMR_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI1_SMR_PE_Msk = 0x20
	// Bit PE.
	SCI1_SMR_PE = 0x20
	// When transmitting: Do not add parity bit When receiving: Do not check parity bit
	SCI1_SMR_PE_0 = 0x0
	// When transmitting: Add parity bit When receiving: Check parity bit
	SCI1_SMR_PE_1 = 0x1
	// Position of CHR field.
	SCI1_SMR_CHR_Pos = 0x6
	// Bit mask of CHR field.
	SCI1_SMR_CHR_Msk = 0x40
	// Bit CHR.
	SCI1_SMR_CHR = 0x40
	// SCMR.CHR1 = 0: Transmit/receive in 9-bit data length SCMR.CHR1 = 1: Transmit/receive in 8-bit data length (initial value)
	SCI1_SMR_CHR_0 = 0x0
	// SCMR.CHR1 = 0: Transmit/receive in 9-bit data length SCMR.CHR1 = 1: Transmit/receive in 7-bit data length
	SCI1_SMR_CHR_1 = 0x1
	// Position of CM field.
	SCI1_SMR_CM_Pos = 0x7
	// Bit mask of CM field.
	SCI1_SMR_CM_Msk = 0x80
	// Bit CM.
	SCI1_SMR_CM = 0x80
	// Asynchronous mode or simple IIC mode
	SCI1_SMR_CM_0 = 0x0
	// Clock synchronous mode or simple SPI mode
	SCI1_SMR_CM_1 = 0x1

	// SMR_SMCI: Serial Mode Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of CKS field.
	SCI1_SMR_SMCI_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI1_SMR_SMCI_CKS_Msk = 0x3
	// PCLK clock (n = 0)
	SCI1_SMR_SMCI_CKS_00 = 0x0
	// PCLK/4 clock (n = 1)
	SCI1_SMR_SMCI_CKS_01 = 0x1
	// PCLK/16 clock (n = 2)
	SCI1_SMR_SMCI_CKS_10 = 0x2
	// PCLK/64 clock (n = 3)
	SCI1_SMR_SMCI_CKS_11 = 0x3
	// Position of BCP field.
	SCI1_SMR_SMCI_BCP_Pos = 0x2
	// Bit mask of BCP field.
	SCI1_SMR_SMCI_BCP_Msk = 0xc
	// Position of PM field.
	SCI1_SMR_SMCI_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI1_SMR_SMCI_PM_Msk = 0x10
	// Bit PM.
	SCI1_SMR_SMCI_PM = 0x10
	// Even parity
	SCI1_SMR_SMCI_PM_0 = 0x0
	// Odd parity
	SCI1_SMR_SMCI_PM_1 = 0x1
	// Position of PE field.
	SCI1_SMR_SMCI_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI1_SMR_SMCI_PE_Msk = 0x20
	// Bit PE.
	SCI1_SMR_SMCI_PE = 0x20
	// Position of BLK field.
	SCI1_SMR_SMCI_BLK_Pos = 0x6
	// Bit mask of BLK field.
	SCI1_SMR_SMCI_BLK_Msk = 0x40
	// Bit BLK.
	SCI1_SMR_SMCI_BLK = 0x40
	// Normal mode operation
	SCI1_SMR_SMCI_BLK_0 = 0x0
	// Block transfer mode operation
	SCI1_SMR_SMCI_BLK_1 = 0x1
	// Position of GM field.
	SCI1_SMR_SMCI_GM_Pos = 0x7
	// Bit mask of GM field.
	SCI1_SMR_SMCI_GM_Msk = 0x80
	// Bit GM.
	SCI1_SMR_SMCI_GM = 0x80
	// Normal mode operation
	SCI1_SMR_SMCI_GM_0 = 0x0
	// GSM mode operation
	SCI1_SMR_SMCI_GM_1 = 0x1

	// SCR: Serial Control Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
	// Position of CKE field.
	SCI1_SCR_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI1_SCR_CKE_Msk = 0x3
	// In asynchronous mode, the SCKn pin is available for use as an I/O port based on the I/O port settings. In clock synchronous mode, the SCKn pin functions as the clock output pin.
	SCI1_SCR_CKE_00 = 0x0
	// In asynchronous mode, a clock with the same frequency as the bit rate is output from the SCKn pin. In clock synchronous mode, the SCKn pin functions as the clock output pin.
	SCI1_SCR_CKE_01 = 0x1
	// Position of TEIE field.
	SCI1_SCR_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI1_SCR_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI1_SCR_TEIE = 0x4
	// Disable SCIn_TEI interrupt requests
	SCI1_SCR_TEIE_0 = 0x0
	// Enable SCIn_TEI interrupt requests
	SCI1_SCR_TEIE_1 = 0x1
	// Position of MPIE field.
	SCI1_SCR_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI1_SCR_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI1_SCR_MPIE = 0x8
	// Normal reception
	SCI1_SCR_MPIE_0 = 0x0
	// When data with the multi-processor bit set to 0 is received, the data is not read, and setting the status flags RDRF, ORER, and FER in SSR to 1. When data with the multi-processor bit set to 1 is received, the MPIE bit is automatically set to 0, and normal reception is resumed.
	SCI1_SCR_MPIE_1 = 0x1
	// Position of RE field.
	SCI1_SCR_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI1_SCR_RE_Msk = 0x10
	// Bit RE.
	SCI1_SCR_RE = 0x10
	// Disable serial reception
	SCI1_SCR_RE_0 = 0x0
	// Enable serial reception
	SCI1_SCR_RE_1 = 0x1
	// Position of TE field.
	SCI1_SCR_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI1_SCR_TE_Msk = 0x20
	// Bit TE.
	SCI1_SCR_TE = 0x20
	// Disable serial transmission
	SCI1_SCR_TE_0 = 0x0
	// Enable serial transmission
	SCI1_SCR_TE_1 = 0x1
	// Position of RIE field.
	SCI1_SCR_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI1_SCR_RIE_Msk = 0x40
	// Bit RIE.
	SCI1_SCR_RIE = 0x40
	// Disable SCIn_RXI and SCIn_ERI interrupt requests
	SCI1_SCR_RIE_0 = 0x0
	// Enable SCIn_RXI and SCIn_ERI interrupt requests
	SCI1_SCR_RIE_1 = 0x1
	// Position of TIE field.
	SCI1_SCR_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI1_SCR_TIE_Msk = 0x80
	// Bit TIE.
	SCI1_SCR_TIE = 0x80
	// Disable SCIn_TXI interrupt requests
	SCI1_SCR_TIE_0 = 0x0
	// Enable SCIn_TXI interrupt requests
	SCI1_SCR_TIE_1 = 0x1

	// SCR_SMCI: Serial Control Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of CKE field.
	SCI1_SCR_SMCI_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI1_SCR_SMCI_CKE_Msk = 0x3
	// When SMR_SMCI.GM = 0: Disable output The SCKn pin is available for use as an I/O port if set up in the I/O port settings When SMR_SMCI.GM = 1: Fix output low
	SCI1_SCR_SMCI_CKE_00 = 0x0
	// When SMR_SMCI.GM = 0: Output clock When SMR_SMCI.GM = 1: Output clock
	SCI1_SCR_SMCI_CKE_01 = 0x1
	// When SMR_SMCI.GM = 0: Setting prohibited When SMR_SMCI.GM = 1: Fix output high
	SCI1_SCR_SMCI_CKE_10 = 0x2
	// When SMR_SMCI.GM = 0: Setting prohibited When SMR_SMCI.GM = 1: Output clock
	SCI1_SCR_SMCI_CKE_11 = 0x3
	// Position of TEIE field.
	SCI1_SCR_SMCI_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI1_SCR_SMCI_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI1_SCR_SMCI_TEIE = 0x4
	// Position of MPIE field.
	SCI1_SCR_SMCI_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI1_SCR_SMCI_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI1_SCR_SMCI_MPIE = 0x8
	// Position of RE field.
	SCI1_SCR_SMCI_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI1_SCR_SMCI_RE_Msk = 0x10
	// Bit RE.
	SCI1_SCR_SMCI_RE = 0x10
	// Disable serial reception
	SCI1_SCR_SMCI_RE_0 = 0x0
	// Enable serial reception
	SCI1_SCR_SMCI_RE_1 = 0x1
	// Position of TE field.
	SCI1_SCR_SMCI_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI1_SCR_SMCI_TE_Msk = 0x20
	// Bit TE.
	SCI1_SCR_SMCI_TE = 0x20
	// Disable serial transmission
	SCI1_SCR_SMCI_TE_0 = 0x0
	// Enable serial transmission
	SCI1_SCR_SMCI_TE_1 = 0x1
	// Position of RIE field.
	SCI1_SCR_SMCI_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI1_SCR_SMCI_RIE_Msk = 0x40
	// Bit RIE.
	SCI1_SCR_SMCI_RIE = 0x40
	// Disable SCIn_RXI and SCIn_ERI interrupt requests
	SCI1_SCR_SMCI_RIE_0 = 0x0
	// Enable SCIn_RXI and SCIn_ERI interrupt requests
	SCI1_SCR_SMCI_RIE_1 = 0x1
	// Position of TIE field.
	SCI1_SCR_SMCI_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI1_SCR_SMCI_TIE_Msk = 0x80
	// Bit TIE.
	SCI1_SCR_SMCI_TIE = 0x80
	// Disable SCIn_TXI interrupt requests
	SCI1_SCR_SMCI_TIE_0 = 0x0
	// Enable SCIn_TXI interrupt requests
	SCI1_SCR_SMCI_TIE_1 = 0x1

	// SSR: Serial Status Register for Non-Smart Card Interface and Non-FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0)
	// Position of MPBT field.
	SCI1_SSR_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI1_SSR_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI1_SSR_MPBT = 0x1
	// Data transmission cycle
	SCI1_SSR_MPBT_0 = 0x0
	// ID transmission cycle
	SCI1_SSR_MPBT_1 = 0x1
	// Position of MPB field.
	SCI1_SSR_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI1_SSR_MPB_Msk = 0x2
	// Bit MPB.
	SCI1_SSR_MPB = 0x2
	// Data transmission cycle
	SCI1_SSR_MPB_0 = 0x0
	// ID transmission cycle
	SCI1_SSR_MPB_1 = 0x1
	// Position of TEND field.
	SCI1_SSR_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI1_SSR_TEND_Msk = 0x4
	// Bit TEND.
	SCI1_SSR_TEND = 0x4
	// A character is being transmitted
	SCI1_SSR_TEND_0 = 0x0
	// Character transfer is complete
	SCI1_SSR_TEND_1 = 0x1
	// Position of PER field.
	SCI1_SSR_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI1_SSR_PER_Msk = 0x8
	// Bit PER.
	SCI1_SSR_PER = 0x8
	// No parity error occurred
	SCI1_SSR_PER_0 = 0x0
	// Parity error occurred
	SCI1_SSR_PER_1 = 0x1
	// Position of FER field.
	SCI1_SSR_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI1_SSR_FER_Msk = 0x10
	// Bit FER.
	SCI1_SSR_FER = 0x10
	// No framing error occurred
	SCI1_SSR_FER_0 = 0x0
	// Framing error occurred
	SCI1_SSR_FER_1 = 0x1
	// Position of ORER field.
	SCI1_SSR_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI1_SSR_ORER_Msk = 0x20
	// Bit ORER.
	SCI1_SSR_ORER = 0x20
	// No overrun error occurred
	SCI1_SSR_ORER_0 = 0x0
	// Overrun error occurred
	SCI1_SSR_ORER_1 = 0x1
	// Position of RDRF field.
	SCI1_SSR_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI1_SSR_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI1_SSR_RDRF = 0x40
	// No received data in RDR register
	SCI1_SSR_RDRF_0 = 0x0
	// Received data in RDR register
	SCI1_SSR_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI1_SSR_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI1_SSR_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI1_SSR_TDRE = 0x80
	// Transmit data in TDR register
	SCI1_SSR_TDRE_0 = 0x0
	// No transmit data in TDR register
	SCI1_SSR_TDRE_1 = 0x1

	// SSR_SMCI: Serial Status Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of MPBT field.
	SCI1_SSR_SMCI_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI1_SSR_SMCI_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI1_SSR_SMCI_MPBT = 0x1
	// Position of MPB field.
	SCI1_SSR_SMCI_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI1_SSR_SMCI_MPB_Msk = 0x2
	// Bit MPB.
	SCI1_SSR_SMCI_MPB = 0x2
	// Position of TEND field.
	SCI1_SSR_SMCI_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI1_SSR_SMCI_TEND_Msk = 0x4
	// Bit TEND.
	SCI1_SSR_SMCI_TEND = 0x4
	// A character is being transmitted
	SCI1_SSR_SMCI_TEND_0 = 0x0
	// Character transfer is complete
	SCI1_SSR_SMCI_TEND_1 = 0x1
	// Position of PER field.
	SCI1_SSR_SMCI_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI1_SSR_SMCI_PER_Msk = 0x8
	// Bit PER.
	SCI1_SSR_SMCI_PER = 0x8
	// No parity error occurred
	SCI1_SSR_SMCI_PER_0 = 0x0
	// Parity error occurred
	SCI1_SSR_SMCI_PER_1 = 0x1
	// Position of ERS field.
	SCI1_SSR_SMCI_ERS_Pos = 0x4
	// Bit mask of ERS field.
	SCI1_SSR_SMCI_ERS_Msk = 0x10
	// Bit ERS.
	SCI1_SSR_SMCI_ERS = 0x10
	// No low error signal response
	SCI1_SSR_SMCI_ERS_0 = 0x0
	// Low error signal response occurred
	SCI1_SSR_SMCI_ERS_1 = 0x1
	// Position of ORER field.
	SCI1_SSR_SMCI_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI1_SSR_SMCI_ORER_Msk = 0x20
	// Bit ORER.
	SCI1_SSR_SMCI_ORER = 0x20
	// No overrun error occurred
	SCI1_SSR_SMCI_ORER_0 = 0x0
	// Overrun error occurred
	SCI1_SSR_SMCI_ORER_1 = 0x1
	// Position of RDRF field.
	SCI1_SSR_SMCI_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI1_SSR_SMCI_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI1_SSR_SMCI_RDRF = 0x40
	// No received data in RDR register
	SCI1_SSR_SMCI_RDRF_0 = 0x0
	// Received data in RDR register
	SCI1_SSR_SMCI_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI1_SSR_SMCI_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI1_SSR_SMCI_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI1_SSR_SMCI_TDRE = 0x80
	// Transmit data in TDR register
	SCI1_SSR_SMCI_TDRE_0 = 0x0
	// No transmit data in TDR register
	SCI1_SSR_SMCI_TDRE_1 = 0x1

	// SCMR: Smart Card Mode Register
	// Position of SMIF field.
	SCI1_SCMR_SMIF_Pos = 0x0
	// Bit mask of SMIF field.
	SCI1_SCMR_SMIF_Msk = 0x1
	// Bit SMIF.
	SCI1_SCMR_SMIF = 0x1
	// Non-smart card interface mode (asynchronous mode, clock synchronous mode, simple SPI mode, or simple IIC mode)
	SCI1_SCMR_SMIF_0 = 0x0
	// Smart card interface mode
	SCI1_SCMR_SMIF_1 = 0x1
	// Position of SINV field.
	SCI1_SCMR_SINV_Pos = 0x2
	// Bit mask of SINV field.
	SCI1_SCMR_SINV_Msk = 0x4
	// Bit SINV.
	SCI1_SCMR_SINV = 0x4
	// TDR contents are transmitted as they are. Received data is stored as received in the RDR register.
	SCI1_SCMR_SINV_0 = 0x0
	// TDR register contents are inverted before transmission. Receive data is stored in inverted form in the RDR register.
	SCI1_SCMR_SINV_1 = 0x1
	// Position of SDIR field.
	SCI1_SCMR_SDIR_Pos = 0x3
	// Bit mask of SDIR field.
	SCI1_SCMR_SDIR_Msk = 0x8
	// Bit SDIR.
	SCI1_SCMR_SDIR = 0x8
	// Transfer LSB-first
	SCI1_SCMR_SDIR_0 = 0x0
	// Transfer MSB-first
	SCI1_SCMR_SDIR_1 = 0x1
	// Position of CHR1 field.
	SCI1_SCMR_CHR1_Pos = 0x4
	// Bit mask of CHR1 field.
	SCI1_SCMR_CHR1_Msk = 0x10
	// Bit CHR1.
	SCI1_SCMR_CHR1 = 0x10
	// SMR.CHR = 0: Transmit/receive in 9-bit data length SMR.CHR = 1: Transmit/receive in 9-bit data length
	SCI1_SCMR_CHR1_0 = 0x0
	// SMR.CHR = 0: Transmit/receive in 8-bit data length (initial value) SMR.CHR = 1: Transmit/receive in 7-bit data length
	SCI1_SCMR_CHR1_1 = 0x1
	// Position of BCP2 field.
	SCI1_SCMR_BCP2_Pos = 0x7
	// Bit mask of BCP2 field.
	SCI1_SCMR_BCP2_Msk = 0x80
	// Bit BCP2.
	SCI1_SCMR_BCP2 = 0x80

	// SEMR: Serial Extended Mode Register
	// Position of BRME field.
	SCI1_SEMR_BRME_Pos = 0x2
	// Bit mask of BRME field.
	SCI1_SEMR_BRME_Msk = 0x4
	// Bit BRME.
	SCI1_SEMR_BRME = 0x4
	// Disable bit rate modulation function
	SCI1_SEMR_BRME_0 = 0x0
	// Enable bit rate modulation function
	SCI1_SEMR_BRME_1 = 0x1
	// Position of ABCSE field.
	SCI1_SEMR_ABCSE_Pos = 0x3
	// Bit mask of ABCSE field.
	SCI1_SEMR_ABCSE_Msk = 0x8
	// Bit ABCSE.
	SCI1_SEMR_ABCSE = 0x8
	// Clock cycles for 1-bit period determined by combination of the BGDM and ABCS bits in the SEMR register
	SCI1_SEMR_ABCSE_0 = 0x0
	// Baud rate is 6 base clock cycles for 1-bit period
	SCI1_SEMR_ABCSE_1 = 0x1
	// Position of ABCS field.
	SCI1_SEMR_ABCS_Pos = 0x4
	// Bit mask of ABCS field.
	SCI1_SEMR_ABCS_Msk = 0x10
	// Bit ABCS.
	SCI1_SEMR_ABCS = 0x10
	// Select 16 base clock cycles for 1-bit period
	SCI1_SEMR_ABCS_0 = 0x0
	// Select 8 base clock cycles for 1-bit period
	SCI1_SEMR_ABCS_1 = 0x1
	// Position of NFEN field.
	SCI1_SEMR_NFEN_Pos = 0x5
	// Bit mask of NFEN field.
	SCI1_SEMR_NFEN_Msk = 0x20
	// Bit NFEN.
	SCI1_SEMR_NFEN = 0x20
	// In asynchronous mode: Disable noise cancellation function for RXDn input signal In simple I2C mode: Disable noise cancellation function for SCLn and SDAn input signals
	SCI1_SEMR_NFEN_0 = 0x0
	// In asynchronous mode: Enable noise cancellation function for RXDn input signal In simple I2C mode: Enable noise cancellation function for SCLn and SDAn input signals
	SCI1_SEMR_NFEN_1 = 0x1
	// Position of BGDM field.
	SCI1_SEMR_BGDM_Pos = 0x6
	// Bit mask of BGDM field.
	SCI1_SEMR_BGDM_Msk = 0x40
	// Bit BGDM.
	SCI1_SEMR_BGDM = 0x40
	// Output clock from baud rate generator with normal frequency
	SCI1_SEMR_BGDM_0 = 0x0
	// Output clock from baud rate generator with doubled frequency
	SCI1_SEMR_BGDM_1 = 0x1
	// Position of RXDESEL field.
	SCI1_SEMR_RXDESEL_Pos = 0x7
	// Bit mask of RXDESEL field.
	SCI1_SEMR_RXDESEL_Msk = 0x80
	// Bit RXDESEL.
	SCI1_SEMR_RXDESEL = 0x80
	// Detect low level on RXDn pin as start bit
	SCI1_SEMR_RXDESEL_0 = 0x0
	// Detect falling edge of RXDn pin as start bit
	SCI1_SEMR_RXDESEL_1 = 0x1

	// SNFR: Noise Filter Setting Register
	// Position of NFCS field.
	SCI1_SNFR_NFCS_Pos = 0x0
	// Bit mask of NFCS field.
	SCI1_SNFR_NFCS_Msk = 0x7
	// In asynchronous mode: Use clock signal divided by 1 with noise filter In simple I2C mode: Setting prohibited
	SCI1_SNFR_NFCS_000 = 0x0
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 1 with noise filter
	SCI1_SNFR_NFCS_001 = 0x1
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 2 with noise filter
	SCI1_SNFR_NFCS_010 = 0x2
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 4 with noise filter
	SCI1_SNFR_NFCS_011 = 0x3
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 8 with noise filter
	SCI1_SNFR_NFCS_100 = 0x4

	// SIMR1: IIC Mode Register 1
	// Position of IICM field.
	SCI1_SIMR1_IICM_Pos = 0x0
	// Bit mask of IICM field.
	SCI1_SIMR1_IICM_Msk = 0x1
	// Bit IICM.
	SCI1_SIMR1_IICM = 0x1
	// SCMR.SMIF = 0: Asynchronous mode (including multi-processor mode), clock synchronous mode, or simple SPI mode SCMR.SMIF = 1: Smart card interface mode
	SCI1_SIMR1_IICM_0 = 0x0
	// SCMR.SMIF = 0: Simple IIC mode SCMR.SMIF = 1: Setting prohibited
	SCI1_SIMR1_IICM_1 = 0x1
	// Position of IICDL field.
	SCI1_SIMR1_IICDL_Pos = 0x3
	// Bit mask of IICDL field.
	SCI1_SIMR1_IICDL_Msk = 0xf8
	// No output delay
	SCI1_SIMR1_IICDL_0x00 = 0x0

	// SIMR2: IIC Mode Register 2
	// Position of IICINTM field.
	SCI1_SIMR2_IICINTM_Pos = 0x0
	// Bit mask of IICINTM field.
	SCI1_SIMR2_IICINTM_Msk = 0x1
	// Bit IICINTM.
	SCI1_SIMR2_IICINTM = 0x1
	// Use ACK/NACK interrupts
	SCI1_SIMR2_IICINTM_0 = 0x0
	// Use reception and transmission interrupts
	SCI1_SIMR2_IICINTM_1 = 0x1
	// Position of IICCSC field.
	SCI1_SIMR2_IICCSC_Pos = 0x1
	// Bit mask of IICCSC field.
	SCI1_SIMR2_IICCSC_Msk = 0x2
	// Bit IICCSC.
	SCI1_SIMR2_IICCSC = 0x2
	// Do not synchronize with clock signal
	SCI1_SIMR2_IICCSC_0 = 0x0
	// Synchronize with clock signal
	SCI1_SIMR2_IICCSC_1 = 0x1
	// Position of IICACKT field.
	SCI1_SIMR2_IICACKT_Pos = 0x5
	// Bit mask of IICACKT field.
	SCI1_SIMR2_IICACKT_Msk = 0x20
	// Bit IICACKT.
	SCI1_SIMR2_IICACKT = 0x20
	// ACK transmission
	SCI1_SIMR2_IICACKT_0 = 0x0
	// NACK transmission and ACK/NACK reception
	SCI1_SIMR2_IICACKT_1 = 0x1

	// SIMR3: IIC Mode Register 3
	// Position of IICSTAREQ field.
	SCI1_SIMR3_IICSTAREQ_Pos = 0x0
	// Bit mask of IICSTAREQ field.
	SCI1_SIMR3_IICSTAREQ_Msk = 0x1
	// Bit IICSTAREQ.
	SCI1_SIMR3_IICSTAREQ = 0x1
	// Do not generate start condition
	SCI1_SIMR3_IICSTAREQ_0 = 0x0
	// Generate start condition
	SCI1_SIMR3_IICSTAREQ_1 = 0x1
	// Position of IICRSTAREQ field.
	SCI1_SIMR3_IICRSTAREQ_Pos = 0x1
	// Bit mask of IICRSTAREQ field.
	SCI1_SIMR3_IICRSTAREQ_Msk = 0x2
	// Bit IICRSTAREQ.
	SCI1_SIMR3_IICRSTAREQ = 0x2
	// Do not generate restart condition
	SCI1_SIMR3_IICRSTAREQ_0 = 0x0
	// Generate restart condition
	SCI1_SIMR3_IICRSTAREQ_1 = 0x1
	// Position of IICSTPREQ field.
	SCI1_SIMR3_IICSTPREQ_Pos = 0x2
	// Bit mask of IICSTPREQ field.
	SCI1_SIMR3_IICSTPREQ_Msk = 0x4
	// Bit IICSTPREQ.
	SCI1_SIMR3_IICSTPREQ = 0x4
	// Do not generate stop condition
	SCI1_SIMR3_IICSTPREQ_0 = 0x0
	// Generate stop condition
	SCI1_SIMR3_IICSTPREQ_1 = 0x1
	// Position of IICSTIF field.
	SCI1_SIMR3_IICSTIF_Pos = 0x3
	// Bit mask of IICSTIF field.
	SCI1_SIMR3_IICSTIF_Msk = 0x8
	// Bit IICSTIF.
	SCI1_SIMR3_IICSTIF = 0x8
	// No requests are being made for generating conditions, or a condition is being generated
	SCI1_SIMR3_IICSTIF_0 = 0x0
	// Generation of start, restart, or stop condition is complete. When 0 is written to IICSTIF, it is set to 0
	SCI1_SIMR3_IICSTIF_1 = 0x1
	// Position of IICSDAS field.
	SCI1_SIMR3_IICSDAS_Pos = 0x4
	// Bit mask of IICSDAS field.
	SCI1_SIMR3_IICSDAS_Msk = 0x30
	// Output serial data
	SCI1_SIMR3_IICSDAS_00 = 0x0
	// Generate start, restart, or stop condition
	SCI1_SIMR3_IICSDAS_01 = 0x1
	// Output low on SDAn pin
	SCI1_SIMR3_IICSDAS_10 = 0x2
	// Drive SDAn pin to high-impedance state
	SCI1_SIMR3_IICSDAS_11 = 0x3
	// Position of IICSCLS field.
	SCI1_SIMR3_IICSCLS_Pos = 0x6
	// Bit mask of IICSCLS field.
	SCI1_SIMR3_IICSCLS_Msk = 0xc0
	// Output serial clock
	SCI1_SIMR3_IICSCLS_00 = 0x0
	// Generate start, restart, or stop condition
	SCI1_SIMR3_IICSCLS_01 = 0x1
	// Output low on SCLn pin
	SCI1_SIMR3_IICSCLS_10 = 0x2
	// Drive SCLn pin to high-impedance state
	SCI1_SIMR3_IICSCLS_11 = 0x3

	// SISR: IIC Status Register
	// Position of IICACKR field.
	SCI1_SISR_IICACKR_Pos = 0x0
	// Bit mask of IICACKR field.
	SCI1_SISR_IICACKR_Msk = 0x1
	// Bit IICACKR.
	SCI1_SISR_IICACKR = 0x1
	// ACK received
	SCI1_SISR_IICACKR_0 = 0x0
	// NACK received
	SCI1_SISR_IICACKR_1 = 0x1

	// SPMR: SPI Mode Register
	// Position of SSE field.
	SCI1_SPMR_SSE_Pos = 0x0
	// Bit mask of SSE field.
	SCI1_SPMR_SSE_Msk = 0x1
	// Bit SSE.
	SCI1_SPMR_SSE = 0x1
	// Disable SSn pin function
	SCI1_SPMR_SSE_0 = 0x0
	// Enable SSn pin function
	SCI1_SPMR_SSE_1 = 0x1
	// Position of CTSE field.
	SCI1_SPMR_CTSE_Pos = 0x1
	// Bit mask of CTSE field.
	SCI1_SPMR_CTSE_Msk = 0x2
	// Bit CTSE.
	SCI1_SPMR_CTSE = 0x2
	// Disable CTS function (enable RTS output function)
	SCI1_SPMR_CTSE_0 = 0x0
	// Enable CTS function
	SCI1_SPMR_CTSE_1 = 0x1
	// Position of MSS field.
	SCI1_SPMR_MSS_Pos = 0x2
	// Bit mask of MSS field.
	SCI1_SPMR_MSS_Msk = 0x4
	// Bit MSS.
	SCI1_SPMR_MSS = 0x4
	// Transmit through TXDn pin and receive through RXDn pin (master mode)
	SCI1_SPMR_MSS_0 = 0x0
	// Receive through TXDn pin and transmit through RXDn pin (slave mode)
	SCI1_SPMR_MSS_1 = 0x1
	// Position of MFF field.
	SCI1_SPMR_MFF_Pos = 0x4
	// Bit mask of MFF field.
	SCI1_SPMR_MFF_Msk = 0x10
	// Bit MFF.
	SCI1_SPMR_MFF = 0x10
	// No mode fault error
	SCI1_SPMR_MFF_0 = 0x0
	// Mode fault error
	SCI1_SPMR_MFF_1 = 0x1
	// Position of CKPOL field.
	SCI1_SPMR_CKPOL_Pos = 0x6
	// Bit mask of CKPOL field.
	SCI1_SPMR_CKPOL_Msk = 0x40
	// Bit CKPOL.
	SCI1_SPMR_CKPOL = 0x40
	// Do not invert clock polarity
	SCI1_SPMR_CKPOL_0 = 0x0
	// Invert clock polarity
	SCI1_SPMR_CKPOL_1 = 0x1
	// Position of CKPH field.
	SCI1_SPMR_CKPH_Pos = 0x7
	// Bit mask of CKPH field.
	SCI1_SPMR_CKPH_Msk = 0x80
	// Bit CKPH.
	SCI1_SPMR_CKPH = 0x80
	// Do not delay clock
	SCI1_SPMR_CKPH_0 = 0x0
	// Delay clock
	SCI1_SPMR_CKPH_1 = 0x1

	// TDRHL: Transmit Data Register
	// Position of TDAT field.
	SCI1_TDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI1_TDRHL_TDAT_Msk = 0x1ff

	// RDRHL: Receive Data Register
	// Position of RDAT field.
	SCI1_RDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI1_RDRHL_RDAT_Msk = 0x1ff
)

// Constants for SPI0: Serial Peripheral Interface 0
const (
	// SPCR: SPI Control Register
	// Position of SPMS field.
	SPI0_SPCR_SPMS_Pos = 0x0
	// Bit mask of SPMS field.
	SPI0_SPCR_SPMS_Msk = 0x1
	// Bit SPMS.
	SPI0_SPCR_SPMS = 0x1
	// Select SPI operation (4-wire method)
	SPI0_SPCR_SPMS_0 = 0x0
	// Select clock synchronous operation (3-wire method)
	SPI0_SPCR_SPMS_1 = 0x1
	// Position of TXMD field.
	SPI0_SPCR_TXMD_Pos = 0x1
	// Bit mask of TXMD field.
	SPI0_SPCR_TXMD_Msk = 0x2
	// Bit TXMD.
	SPI0_SPCR_TXMD = 0x2
	// Select full-duplex synchronous serial communications
	SPI0_SPCR_TXMD_0 = 0x0
	// Select serial communications with transmit-only
	SPI0_SPCR_TXMD_1 = 0x1
	// Position of MODFEN field.
	SPI0_SPCR_MODFEN_Pos = 0x2
	// Bit mask of MODFEN field.
	SPI0_SPCR_MODFEN_Msk = 0x4
	// Bit MODFEN.
	SPI0_SPCR_MODFEN = 0x4
	// Disable detection of mode fault errors
	SPI0_SPCR_MODFEN_0 = 0x0
	// Enable detection of mode fault errors
	SPI0_SPCR_MODFEN_1 = 0x1
	// Position of MSTR field.
	SPI0_SPCR_MSTR_Pos = 0x3
	// Bit mask of MSTR field.
	SPI0_SPCR_MSTR_Msk = 0x8
	// Bit MSTR.
	SPI0_SPCR_MSTR = 0x8
	// Select slave mode
	SPI0_SPCR_MSTR_0 = 0x0
	// Select master mode
	SPI0_SPCR_MSTR_1 = 0x1
	// Position of SPEIE field.
	SPI0_SPCR_SPEIE_Pos = 0x4
	// Bit mask of SPEIE field.
	SPI0_SPCR_SPEIE_Msk = 0x10
	// Bit SPEIE.
	SPI0_SPCR_SPEIE = 0x10
	// Disable SPI error interrupt requests
	SPI0_SPCR_SPEIE_0 = 0x0
	// Enable SPI error interrupt requests
	SPI0_SPCR_SPEIE_1 = 0x1
	// Position of SPTIE field.
	SPI0_SPCR_SPTIE_Pos = 0x5
	// Bit mask of SPTIE field.
	SPI0_SPCR_SPTIE_Msk = 0x20
	// Bit SPTIE.
	SPI0_SPCR_SPTIE = 0x20
	// Disable transmit buffer empty interrupt requests
	SPI0_SPCR_SPTIE_0 = 0x0
	// Enable transmit buffer empty interrupt requests
	SPI0_SPCR_SPTIE_1 = 0x1
	// Position of SPE field.
	SPI0_SPCR_SPE_Pos = 0x6
	// Bit mask of SPE field.
	SPI0_SPCR_SPE_Msk = 0x40
	// Bit SPE.
	SPI0_SPCR_SPE = 0x40
	// Disable SPI function
	SPI0_SPCR_SPE_0 = 0x0
	// Enable SPI function
	SPI0_SPCR_SPE_1 = 0x1
	// Position of SPRIE field.
	SPI0_SPCR_SPRIE_Pos = 0x7
	// Bit mask of SPRIE field.
	SPI0_SPCR_SPRIE_Msk = 0x80
	// Bit SPRIE.
	SPI0_SPCR_SPRIE = 0x80
	// Disable SPI receive buffer full interrupt requests
	SPI0_SPCR_SPRIE_0 = 0x0
	// Enable SPI receive buffer full interrupt requests
	SPI0_SPCR_SPRIE_1 = 0x1

	// SSLP: SPI Slave Select Polarity Register
	// Position of SSL0P field.
	SPI0_SSLP_SSL0P_Pos = 0x0
	// Bit mask of SSL0P field.
	SPI0_SSLP_SSL0P_Msk = 0x1
	// Bit SSL0P.
	SPI0_SSLP_SSL0P = 0x1
	// Set SSLn0 signal to active-low
	SPI0_SSLP_SSL0P_0 = 0x0
	// Set SSLn0 signal to active-high
	SPI0_SSLP_SSL0P_1 = 0x1
	// Position of SSL1P field.
	SPI0_SSLP_SSL1P_Pos = 0x1
	// Bit mask of SSL1P field.
	SPI0_SSLP_SSL1P_Msk = 0x2
	// Bit SSL1P.
	SPI0_SSLP_SSL1P = 0x2
	// Set SSLn1 signal to active-low
	SPI0_SSLP_SSL1P_0 = 0x0
	// Set SSLn1 signal to active-high
	SPI0_SSLP_SSL1P_1 = 0x1
	// Position of SSL2P field.
	SPI0_SSLP_SSL2P_Pos = 0x2
	// Bit mask of SSL2P field.
	SPI0_SSLP_SSL2P_Msk = 0x4
	// Bit SSL2P.
	SPI0_SSLP_SSL2P = 0x4
	// Set SSLn2 signal to active-low
	SPI0_SSLP_SSL2P_0 = 0x0
	// Set SSLn2 signal to active-high
	SPI0_SSLP_SSL2P_1 = 0x1
	// Position of SSL3P field.
	SPI0_SSLP_SSL3P_Pos = 0x3
	// Bit mask of SSL3P field.
	SPI0_SSLP_SSL3P_Msk = 0x8
	// Bit SSL3P.
	SPI0_SSLP_SSL3P = 0x8
	// Set SSLn3 signal to active-low
	SPI0_SSLP_SSL3P_0 = 0x0
	// Set SSLn3 signal to active-high
	SPI0_SSLP_SSL3P_1 = 0x1

	// SPPCR: SPI Pin Control Register
	// Position of SPLP field.
	SPI0_SPPCR_SPLP_Pos = 0x0
	// Bit mask of SPLP field.
	SPI0_SPPCR_SPLP_Msk = 0x1
	// Bit SPLP.
	SPI0_SPPCR_SPLP = 0x1
	// Normal mode
	SPI0_SPPCR_SPLP_0 = 0x0
	// Loopback mode (receive data = inverted transmit data)
	SPI0_SPPCR_SPLP_1 = 0x1
	// Position of SPLP2 field.
	SPI0_SPPCR_SPLP2_Pos = 0x1
	// Bit mask of SPLP2 field.
	SPI0_SPPCR_SPLP2_Msk = 0x2
	// Bit SPLP2.
	SPI0_SPPCR_SPLP2 = 0x2
	// Normal mode
	SPI0_SPPCR_SPLP2_0 = 0x0
	// Loopback mode (receive data = transmit data)
	SPI0_SPPCR_SPLP2_1 = 0x1
	// Position of MOIFV field.
	SPI0_SPPCR_MOIFV_Pos = 0x4
	// Bit mask of MOIFV field.
	SPI0_SPPCR_MOIFV_Msk = 0x10
	// Bit MOIFV.
	SPI0_SPPCR_MOIFV = 0x10
	// Set level output on MOSIn pin during MOSI idling to low
	SPI0_SPPCR_MOIFV_0 = 0x0
	// Set level output on MOSIn pin during MOSI idling to high
	SPI0_SPPCR_MOIFV_1 = 0x1
	// Position of MOIFE field.
	SPI0_SPPCR_MOIFE_Pos = 0x5
	// Bit mask of MOIFE field.
	SPI0_SPPCR_MOIFE_Msk = 0x20
	// Bit MOIFE.
	SPI0_SPPCR_MOIFE = 0x20
	// Set MOSI output value to equal final data from previous transfer
	SPI0_SPPCR_MOIFE_0 = 0x0
	// Set MOSI output value to equal value set in the MOIFV bit
	SPI0_SPPCR_MOIFE_1 = 0x1

	// SPSR: SPI Status Register
	// Position of OVRF field.
	SPI0_SPSR_OVRF_Pos = 0x0
	// Bit mask of OVRF field.
	SPI0_SPSR_OVRF_Msk = 0x1
	// Bit OVRF.
	SPI0_SPSR_OVRF = 0x1
	// No overrun error occurred
	SPI0_SPSR_OVRF_0 = 0x0
	// Overrun error occurred
	SPI0_SPSR_OVRF_1 = 0x1
	// Position of IDLNF field.
	SPI0_SPSR_IDLNF_Pos = 0x1
	// Bit mask of IDLNF field.
	SPI0_SPSR_IDLNF_Msk = 0x2
	// Bit IDLNF.
	SPI0_SPSR_IDLNF = 0x2
	// SPI is in the idle state
	SPI0_SPSR_IDLNF_0 = 0x0
	// SPI is in the transfer state
	SPI0_SPSR_IDLNF_1 = 0x1
	// Position of MODF field.
	SPI0_SPSR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI0_SPSR_MODF_Msk = 0x4
	// Bit MODF.
	SPI0_SPSR_MODF = 0x4
	// No mode fault or underrun error occurred
	SPI0_SPSR_MODF_0 = 0x0
	// Mode fault error or underrun error occurred
	SPI0_SPSR_MODF_1 = 0x1
	// Position of PERF field.
	SPI0_SPSR_PERF_Pos = 0x3
	// Bit mask of PERF field.
	SPI0_SPSR_PERF_Msk = 0x8
	// Bit PERF.
	SPI0_SPSR_PERF = 0x8
	// No parity error occurred
	SPI0_SPSR_PERF_0 = 0x0
	// Parity error occurred
	SPI0_SPSR_PERF_1 = 0x1
	// Position of UDRF field.
	SPI0_SPSR_UDRF_Pos = 0x4
	// Bit mask of UDRF field.
	SPI0_SPSR_UDRF_Msk = 0x10
	// Bit UDRF.
	SPI0_SPSR_UDRF = 0x10
	// Mode fault error occurred (MODF = 1)
	SPI0_SPSR_UDRF_0 = 0x0
	// Underrun error occurred (MODF = 1)
	SPI0_SPSR_UDRF_1 = 0x1
	// Position of SPTEF field.
	SPI0_SPSR_SPTEF_Pos = 0x5
	// Bit mask of SPTEF field.
	SPI0_SPSR_SPTEF_Msk = 0x20
	// Bit SPTEF.
	SPI0_SPSR_SPTEF = 0x20
	// Data is in the transmit buffer
	SPI0_SPSR_SPTEF_0 = 0x0
	// No data is in the transmit buffer
	SPI0_SPSR_SPTEF_1 = 0x1
	// Position of SPRF field.
	SPI0_SPSR_SPRF_Pos = 0x7
	// Bit mask of SPRF field.
	SPI0_SPSR_SPRF_Msk = 0x80
	// Bit SPRF.
	SPI0_SPSR_SPRF = 0x80
	// No valid data is in SPDR/SPDR_HA
	SPI0_SPSR_SPRF_0 = 0x0
	// Valid data is in SPDR/SPDR_HA
	SPI0_SPSR_SPRF_1 = 0x1

	// SPDCR: SPI Data Control Register
	// Position of SPRDTD field.
	SPI0_SPDCR_SPRDTD_Pos = 0x4
	// Bit mask of SPRDTD field.
	SPI0_SPDCR_SPRDTD_Msk = 0x10
	// Bit SPRDTD.
	SPI0_SPDCR_SPRDTD = 0x10
	// Read SPDR/SPDR_HA values from receive buffer
	SPI0_SPDCR_SPRDTD_0 = 0x0
	// Read SPDR/SPDR_HA values from transmit buffer, but only if the transmit buffer is empty
	SPI0_SPDCR_SPRDTD_1 = 0x1
	// Position of SPLW field.
	SPI0_SPDCR_SPLW_Pos = 0x5
	// Bit mask of SPLW field.
	SPI0_SPDCR_SPLW_Msk = 0x20
	// Bit SPLW.
	SPI0_SPDCR_SPLW = 0x20
	// Set SPDR_HA to valid for halfword access
	SPI0_SPDCR_SPLW_0 = 0x0
	// Set SPDR to valid for word access
	SPI0_SPDCR_SPLW_1 = 0x1
	// Position of SPBYT field.
	SPI0_SPDCR_SPBYT_Pos = 0x6
	// Bit mask of SPBYT field.
	SPI0_SPDCR_SPBYT_Msk = 0x40
	// Bit SPBYT.
	SPI0_SPDCR_SPBYT = 0x40
	// SPDR/SPDR_HA is accessed in halfword or word (SPLW is valid)
	SPI0_SPDCR_SPBYT_0 = 0x0
	// SPDR_BY is accessed in byte (SPLW is invalid)
	SPI0_SPDCR_SPBYT_1 = 0x1

	// SPCKD: SPI Clock Delay Register
	// Position of SCKDL field.
	SPI0_SPCKD_SCKDL_Pos = 0x0
	// Bit mask of SCKDL field.
	SPI0_SPCKD_SCKDL_Msk = 0x7
	// 1 RSPCK
	SPI0_SPCKD_SCKDL_000 = 0x0
	// 2 RSPCK
	SPI0_SPCKD_SCKDL_001 = 0x1
	// 3 RSPCK
	SPI0_SPCKD_SCKDL_010 = 0x2
	// 4 RSPCK
	SPI0_SPCKD_SCKDL_011 = 0x3
	// 5 RSPCK
	SPI0_SPCKD_SCKDL_100 = 0x4
	// 6 RSPCK
	SPI0_SPCKD_SCKDL_101 = 0x5
	// 7 RSPCK
	SPI0_SPCKD_SCKDL_110 = 0x6
	// 8 RSPCK
	SPI0_SPCKD_SCKDL_111 = 0x7

	// SSLND: SPI Slave Select Negation Delay Register
	// Position of SLNDL field.
	SPI0_SSLND_SLNDL_Pos = 0x0
	// Bit mask of SLNDL field.
	SPI0_SSLND_SLNDL_Msk = 0x7
	// 1 RSPCK
	SPI0_SSLND_SLNDL_000 = 0x0
	// 2 RSPCK
	SPI0_SSLND_SLNDL_001 = 0x1
	// 3 RSPCK
	SPI0_SSLND_SLNDL_010 = 0x2
	// 4 RSPCK
	SPI0_SSLND_SLNDL_011 = 0x3
	// 5 RSPCK
	SPI0_SSLND_SLNDL_100 = 0x4
	// 6 RSPCK
	SPI0_SSLND_SLNDL_101 = 0x5
	// 7 RSPCK
	SPI0_SSLND_SLNDL_110 = 0x6
	// 8 RSPCK
	SPI0_SSLND_SLNDL_111 = 0x7

	// SPND: SPI Next-Access Delay Register
	// Position of SPNDL field.
	SPI0_SPND_SPNDL_Pos = 0x0
	// Bit mask of SPNDL field.
	SPI0_SPND_SPNDL_Msk = 0x7
	// 1 RSPCK + 2 PCLKB
	SPI0_SPND_SPNDL_000 = 0x0
	// 2 RSPCK + 2 PCLKB
	SPI0_SPND_SPNDL_001 = 0x1
	// 3 RSPCK + 2 PCLKB
	SPI0_SPND_SPNDL_010 = 0x2
	// 4 RSPCK + 2 PCLKB
	SPI0_SPND_SPNDL_011 = 0x3
	// 5 RSPCK + 2 PCLKB
	SPI0_SPND_SPNDL_100 = 0x4
	// 6 RSPCK + 2 PCLKB
	SPI0_SPND_SPNDL_101 = 0x5
	// 7 RSPCK + 2 PCLKB
	SPI0_SPND_SPNDL_110 = 0x6
	// 8 RSPCK + 2 PCLKB
	SPI0_SPND_SPNDL_111 = 0x7

	// SPCR2: SPI Control Register 2
	// Position of SPPE field.
	SPI0_SPCR2_SPPE_Pos = 0x0
	// Bit mask of SPPE field.
	SPI0_SPCR2_SPPE_Msk = 0x1
	// Bit SPPE.
	SPI0_SPCR2_SPPE = 0x1
	// Do not add parity bit to transmit data and do not check parity bit of receive data
	SPI0_SPCR2_SPPE_0 = 0x0
	// When SPCR.TXMD = 0: Add parity bit to transmit data and check parity bit of receive data When SPCR.TXMD = 1: Add parity bit to transmit data but do not check parity bit of receive data
	SPI0_SPCR2_SPPE_1 = 0x1
	// Position of SPOE field.
	SPI0_SPCR2_SPOE_Pos = 0x1
	// Bit mask of SPOE field.
	SPI0_SPCR2_SPOE_Msk = 0x2
	// Bit SPOE.
	SPI0_SPCR2_SPOE = 0x2
	// Select even parity for transmission and reception
	SPI0_SPCR2_SPOE_0 = 0x0
	// Select odd parity for transmission and reception
	SPI0_SPCR2_SPOE_1 = 0x1
	// Position of SPIIE field.
	SPI0_SPCR2_SPIIE_Pos = 0x2
	// Bit mask of SPIIE field.
	SPI0_SPCR2_SPIIE_Msk = 0x4
	// Bit SPIIE.
	SPI0_SPCR2_SPIIE = 0x4
	// Disable idle interrupt requests
	SPI0_SPCR2_SPIIE_0 = 0x0
	// Enable idle interrupt requests
	SPI0_SPCR2_SPIIE_1 = 0x1
	// Position of PTE field.
	SPI0_SPCR2_PTE_Pos = 0x3
	// Bit mask of PTE field.
	SPI0_SPCR2_PTE_Msk = 0x8
	// Bit PTE.
	SPI0_SPCR2_PTE = 0x8
	// Disable self-diagnosis function of the parity circuit
	SPI0_SPCR2_PTE_0 = 0x0
	// Enable self-diagnosis function of the parity circuit
	SPI0_SPCR2_PTE_1 = 0x1
	// Position of SCKASE field.
	SPI0_SPCR2_SCKASE_Pos = 0x4
	// Bit mask of SCKASE field.
	SPI0_SPCR2_SCKASE_Msk = 0x10
	// Bit SCKASE.
	SPI0_SPCR2_SCKASE = 0x10
	// Disable RSPCK auto-stop function
	SPI0_SPCR2_SCKASE_0 = 0x0
	// Enable RSPCK auto-stop function
	SPI0_SPCR2_SCKASE_1 = 0x1

	// SPCMD0: SPI Command Register 0
	// Position of CPHA field.
	SPI0_SPCMD0_CPHA_Pos = 0x0
	// Bit mask of CPHA field.
	SPI0_SPCMD0_CPHA_Msk = 0x1
	// Bit CPHA.
	SPI0_SPCMD0_CPHA = 0x1
	// Select data sampling on leading edge, data change on trailing edge
	SPI0_SPCMD0_CPHA_0 = 0x0
	// Select data change on leading edge, data sampling on trailing edge
	SPI0_SPCMD0_CPHA_1 = 0x1
	// Position of CPOL field.
	SPI0_SPCMD0_CPOL_Pos = 0x1
	// Bit mask of CPOL field.
	SPI0_SPCMD0_CPOL_Msk = 0x2
	// Bit CPOL.
	SPI0_SPCMD0_CPOL = 0x2
	// Set RSPCK low during idle
	SPI0_SPCMD0_CPOL_0 = 0x0
	// Set RSPCK high during idle
	SPI0_SPCMD0_CPOL_1 = 0x1
	// Position of BRDV field.
	SPI0_SPCMD0_BRDV_Pos = 0x2
	// Bit mask of BRDV field.
	SPI0_SPCMD0_BRDV_Msk = 0xc
	// Base bit rate
	SPI0_SPCMD0_BRDV_00 = 0x0
	// Base bit rate divided by 2
	SPI0_SPCMD0_BRDV_01 = 0x1
	// Base bit rate divided by 4
	SPI0_SPCMD0_BRDV_10 = 0x2
	// Base bit rate divided by 8
	SPI0_SPCMD0_BRDV_11 = 0x3
	// Position of SSLA field.
	SPI0_SPCMD0_SSLA_Pos = 0x4
	// Bit mask of SSLA field.
	SPI0_SPCMD0_SSLA_Msk = 0x70
	// SSL0
	SPI0_SPCMD0_SSLA_000 = 0x0
	// SSL1
	SPI0_SPCMD0_SSLA_001 = 0x1
	// SSL2
	SPI0_SPCMD0_SSLA_010 = 0x2
	// SSL3
	SPI0_SPCMD0_SSLA_011 = 0x3
	// Position of SPB field.
	SPI0_SPCMD0_SPB_Pos = 0x8
	// Bit mask of SPB field.
	SPI0_SPCMD0_SPB_Msk = 0xf00
	// 20 bits
	SPI0_SPCMD0_SPB_0x0 = 0x0
	// 24 bits
	SPI0_SPCMD0_SPB_0x1 = 0x1
	// 32 bits
	SPI0_SPCMD0_SPB_0x2 = 0x2
	// 32 bits
	SPI0_SPCMD0_SPB_0x3 = 0x3
	// 9 bits
	SPI0_SPCMD0_SPB_0x8 = 0x8
	// 10 bits
	SPI0_SPCMD0_SPB_0x9 = 0x9
	// 11 bits
	SPI0_SPCMD0_SPB_0xA = 0xa
	// 12 bits
	SPI0_SPCMD0_SPB_0xB = 0xb
	// 13 bits
	SPI0_SPCMD0_SPB_0xC = 0xc
	// 14 bits
	SPI0_SPCMD0_SPB_0xD = 0xd
	// 15 bits
	SPI0_SPCMD0_SPB_0xE = 0xe
	// 16 bits
	SPI0_SPCMD0_SPB_0xF = 0xf
	// Position of LSBF field.
	SPI0_SPCMD0_LSBF_Pos = 0xc
	// Bit mask of LSBF field.
	SPI0_SPCMD0_LSBF_Msk = 0x1000
	// Bit LSBF.
	SPI0_SPCMD0_LSBF = 0x1000
	// MSB-first
	SPI0_SPCMD0_LSBF_0 = 0x0
	// LSB-first
	SPI0_SPCMD0_LSBF_1 = 0x1
	// Position of SPNDEN field.
	SPI0_SPCMD0_SPNDEN_Pos = 0xd
	// Bit mask of SPNDEN field.
	SPI0_SPCMD0_SPNDEN_Msk = 0x2000
	// Bit SPNDEN.
	SPI0_SPCMD0_SPNDEN = 0x2000
	// Select next-access delay of 1 RSPCK + 2 PCLKB
	SPI0_SPCMD0_SPNDEN_0 = 0x0
	// Select next-access delay equal to the setting in the SPI Next-Access Delay Register (SPND)
	SPI0_SPCMD0_SPNDEN_1 = 0x1
	// Position of SLNDEN field.
	SPI0_SPCMD0_SLNDEN_Pos = 0xe
	// Bit mask of SLNDEN field.
	SPI0_SPCMD0_SLNDEN_Msk = 0x4000
	// Bit SLNDEN.
	SPI0_SPCMD0_SLNDEN = 0x4000
	// Select SSL negation delay of 1 RSPCK
	SPI0_SPCMD0_SLNDEN_0 = 0x0
	// Select SSL negation delay equal to the setting in the SPI Slave Select Negation Delay Register (SSLND)
	SPI0_SPCMD0_SLNDEN_1 = 0x1
	// Position of SCKDEN field.
	SPI0_SPCMD0_SCKDEN_Pos = 0xf
	// Bit mask of SCKDEN field.
	SPI0_SPCMD0_SCKDEN_Msk = 0x8000
	// Bit SCKDEN.
	SPI0_SPCMD0_SCKDEN = 0x8000
	// Select RSPCK delay of 1 RSPCK
	SPI0_SPCMD0_SCKDEN_0 = 0x0
	// Select RSPCK delay equal to the setting in the SPI Clock Delay Register (SPCKD)
	SPI0_SPCMD0_SCKDEN_1 = 0x1
)

// Constants for CRC: Cyclic Redundancy Check Calculator
const (
	// CRCCR0: CRC Control Register 0
	// Position of GPS field.
	CRC_CRCCR0_GPS_Pos = 0x0
	// Bit mask of GPS field.
	CRC_CRCCR0_GPS_Msk = 0x7
	// 8-bit CRC-8 (X8 + X2 + X + 1)
	CRC_CRCCR0_GPS_001 = 0x1
	// 16-bit CRC-16 (X16 + X15 + X2 + 1)
	CRC_CRCCR0_GPS_010 = 0x2
	// 16-bit CRC-CCITT (X16 + X12 + X5 + 1)
	CRC_CRCCR0_GPS_011 = 0x3
	// 32-bit CRC-32 (X32 + X26 + X23 + X22 + X16 + X12 + X11 +X10 + X8 + X7 + X5 + X4 + X2 + X + 1)
	CRC_CRCCR0_GPS_100 = 0x4
	// 32-bit CRC-32C (X32 + X28 + X27 + X26 + X25 + X23 + X22 + X20 + X19 + X18 + X14 + X13 + X11 + X10 + X9 + X8 + X6 + 1)
	CRC_CRCCR0_GPS_101 = 0x5
	// Position of LMS field.
	CRC_CRCCR0_LMS_Pos = 0x6
	// Bit mask of LMS field.
	CRC_CRCCR0_LMS_Msk = 0x40
	// Bit LMS.
	CRC_CRCCR0_LMS = 0x40
	// Generate CRC code for LSB-first communication
	CRC_CRCCR0_LMS_0 = 0x0
	// Generate CRC code for MSB-first communication
	CRC_CRCCR0_LMS_1 = 0x1
	// Position of DORCLR field.
	CRC_CRCCR0_DORCLR_Pos = 0x7
	// Bit mask of DORCLR field.
	CRC_CRCCR0_DORCLR_Msk = 0x80
	// Bit DORCLR.
	CRC_CRCCR0_DORCLR = 0x80
	// No effect
	CRC_CRCCR0_DORCLR_0 = 0x0
	// Clear the CRCDOR/CRCDOR_HA/CRCDOR_BY register
	CRC_CRCCR0_DORCLR_1 = 0x1

	// CRCCR1: CRC Control Register 1
	// Position of CRCSWR field.
	CRC_CRCCR1_CRCSWR_Pos = 0x6
	// Bit mask of CRCSWR field.
	CRC_CRCCR1_CRCSWR_Msk = 0x40
	// Bit CRCSWR.
	CRC_CRCCR1_CRCSWR = 0x40
	// Snoop-on-read
	CRC_CRCCR1_CRCSWR_0 = 0x0
	// Snoop-on-write
	CRC_CRCCR1_CRCSWR_1 = 0x1
	// Position of CRCSEN field.
	CRC_CRCCR1_CRCSEN_Pos = 0x7
	// Bit mask of CRCSEN field.
	CRC_CRCCR1_CRCSEN_Msk = 0x80
	// Bit CRCSEN.
	CRC_CRCCR1_CRCSEN = 0x80
	// Disabled
	CRC_CRCCR1_CRCSEN_0 = 0x0
	// Enabled
	CRC_CRCCR1_CRCSEN_1 = 0x1

	// CRCSAR: Snoop Address Register
	// Position of CRCSA field.
	CRC_CRCSAR_CRCSA_Pos = 0x0
	// Bit mask of CRCSA field.
	CRC_CRCSAR_CRCSA_Msk = 0x3fff
)

// Constants for GPT320: General PWM 32-bit Timer 0
const (
	// GTWP: General PWM Timer Write-Protection Register
	// Position of WP field.
	GPT320_GTWP_WP_Pos = 0x0
	// Bit mask of WP field.
	GPT320_GTWP_WP_Msk = 0x1
	// Bit WP.
	GPT320_GTWP_WP = 0x1
	// Write to the register enabled
	GPT320_GTWP_WP_0 = 0x0
	// Write to the register disabled
	GPT320_GTWP_WP_1 = 0x1
	// Position of PRKEY field.
	GPT320_GTWP_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	GPT320_GTWP_PRKEY_Msk = 0xff00

	// GTSTR: General PWM Timer Software Start Register
	// Position of CSTRT0 field.
	GPT320_GTSTR_CSTRT0_Pos = 0x0
	// Bit mask of CSTRT0 field.
	GPT320_GTSTR_CSTRT0_Msk = 0x1
	// Bit CSTRT0.
	GPT320_GTSTR_CSTRT0 = 0x1
	// GTCNT counter not start
	GPT320_GTSTR_CSTRT0_0 = 0x0
	// GTCNT counter start
	GPT320_GTSTR_CSTRT0_1 = 0x1
	// Position of CSTRT1 field.
	GPT320_GTSTR_CSTRT1_Pos = 0x1
	// Bit mask of CSTRT1 field.
	GPT320_GTSTR_CSTRT1_Msk = 0x2
	// Bit CSTRT1.
	GPT320_GTSTR_CSTRT1 = 0x2
	// GTCNT counter not start
	GPT320_GTSTR_CSTRT1_0 = 0x0
	// GTCNT counter start
	GPT320_GTSTR_CSTRT1_1 = 0x1
	// Position of CSTRT2 field.
	GPT320_GTSTR_CSTRT2_Pos = 0x2
	// Bit mask of CSTRT2 field.
	GPT320_GTSTR_CSTRT2_Msk = 0x4
	// Bit CSTRT2.
	GPT320_GTSTR_CSTRT2 = 0x4
	// GTCNT counter not start
	GPT320_GTSTR_CSTRT2_0 = 0x0
	// GTCNT counter start
	GPT320_GTSTR_CSTRT2_1 = 0x1
	// Position of CSTRT3 field.
	GPT320_GTSTR_CSTRT3_Pos = 0x3
	// Bit mask of CSTRT3 field.
	GPT320_GTSTR_CSTRT3_Msk = 0x8
	// Bit CSTRT3.
	GPT320_GTSTR_CSTRT3 = 0x8
	// GTCNT counter not start
	GPT320_GTSTR_CSTRT3_0 = 0x0
	// GTCNT counter start
	GPT320_GTSTR_CSTRT3_1 = 0x1
	// Position of CSTRT4 field.
	GPT320_GTSTR_CSTRT4_Pos = 0x4
	// Bit mask of CSTRT4 field.
	GPT320_GTSTR_CSTRT4_Msk = 0x10
	// Bit CSTRT4.
	GPT320_GTSTR_CSTRT4 = 0x10
	// GTCNT counter not start
	GPT320_GTSTR_CSTRT4_0 = 0x0
	// GTCNT counter start
	GPT320_GTSTR_CSTRT4_1 = 0x1
	// Position of CSTRT5 field.
	GPT320_GTSTR_CSTRT5_Pos = 0x5
	// Bit mask of CSTRT5 field.
	GPT320_GTSTR_CSTRT5_Msk = 0x20
	// Bit CSTRT5.
	GPT320_GTSTR_CSTRT5 = 0x20
	// GTCNT counter not start
	GPT320_GTSTR_CSTRT5_0 = 0x0
	// GTCNT counter start
	GPT320_GTSTR_CSTRT5_1 = 0x1
	// Position of CSTRT6 field.
	GPT320_GTSTR_CSTRT6_Pos = 0x6
	// Bit mask of CSTRT6 field.
	GPT320_GTSTR_CSTRT6_Msk = 0x40
	// Bit CSTRT6.
	GPT320_GTSTR_CSTRT6 = 0x40
	// GTCNT counter not start
	GPT320_GTSTR_CSTRT6_0 = 0x0
	// GTCNT counter start
	GPT320_GTSTR_CSTRT6_1 = 0x1
	// Position of CSTRT7 field.
	GPT320_GTSTR_CSTRT7_Pos = 0x7
	// Bit mask of CSTRT7 field.
	GPT320_GTSTR_CSTRT7_Msk = 0x80
	// Bit CSTRT7.
	GPT320_GTSTR_CSTRT7 = 0x80
	// GTCNT counter not start
	GPT320_GTSTR_CSTRT7_0 = 0x0
	// GTCNT counter start
	GPT320_GTSTR_CSTRT7_1 = 0x1
	// Position of CSTRT8 field.
	GPT320_GTSTR_CSTRT8_Pos = 0x8
	// Bit mask of CSTRT8 field.
	GPT320_GTSTR_CSTRT8_Msk = 0x100
	// Bit CSTRT8.
	GPT320_GTSTR_CSTRT8 = 0x100
	// GTCNT counter not start
	GPT320_GTSTR_CSTRT8_0 = 0x0
	// GTCNT counter start
	GPT320_GTSTR_CSTRT8_1 = 0x1
	// Position of CSTRT9 field.
	GPT320_GTSTR_CSTRT9_Pos = 0x9
	// Bit mask of CSTRT9 field.
	GPT320_GTSTR_CSTRT9_Msk = 0x200
	// Bit CSTRT9.
	GPT320_GTSTR_CSTRT9 = 0x200
	// GTCNT counter not start
	GPT320_GTSTR_CSTRT9_0 = 0x0
	// GTCNT counter start
	GPT320_GTSTR_CSTRT9_1 = 0x1

	// GTSTP: General PWM Timer Software Stop Register
	// Position of CSTOP0 field.
	GPT320_GTSTP_CSTOP0_Pos = 0x0
	// Bit mask of CSTOP0 field.
	GPT320_GTSTP_CSTOP0_Msk = 0x1
	// Bit CSTOP0.
	GPT320_GTSTP_CSTOP0 = 0x1
	// GTCNT counter not stop
	GPT320_GTSTP_CSTOP0_0 = 0x0
	// GTCNT counter stop
	GPT320_GTSTP_CSTOP0_1 = 0x1
	// Position of CSTOP1 field.
	GPT320_GTSTP_CSTOP1_Pos = 0x1
	// Bit mask of CSTOP1 field.
	GPT320_GTSTP_CSTOP1_Msk = 0x2
	// Bit CSTOP1.
	GPT320_GTSTP_CSTOP1 = 0x2
	// GTCNT counter not stop
	GPT320_GTSTP_CSTOP1_0 = 0x0
	// GTCNT counter stop
	GPT320_GTSTP_CSTOP1_1 = 0x1
	// Position of CSTOP2 field.
	GPT320_GTSTP_CSTOP2_Pos = 0x2
	// Bit mask of CSTOP2 field.
	GPT320_GTSTP_CSTOP2_Msk = 0x4
	// Bit CSTOP2.
	GPT320_GTSTP_CSTOP2 = 0x4
	// GTCNT counter not stop
	GPT320_GTSTP_CSTOP2_0 = 0x0
	// GTCNT counter stop
	GPT320_GTSTP_CSTOP2_1 = 0x1
	// Position of CSTOP3 field.
	GPT320_GTSTP_CSTOP3_Pos = 0x3
	// Bit mask of CSTOP3 field.
	GPT320_GTSTP_CSTOP3_Msk = 0x8
	// Bit CSTOP3.
	GPT320_GTSTP_CSTOP3 = 0x8
	// GTCNT counter not stop
	GPT320_GTSTP_CSTOP3_0 = 0x0
	// GTCNT counter stop
	GPT320_GTSTP_CSTOP3_1 = 0x1
	// Position of CSTOP4 field.
	GPT320_GTSTP_CSTOP4_Pos = 0x4
	// Bit mask of CSTOP4 field.
	GPT320_GTSTP_CSTOP4_Msk = 0x10
	// Bit CSTOP4.
	GPT320_GTSTP_CSTOP4 = 0x10
	// GTCNT counter not stop
	GPT320_GTSTP_CSTOP4_0 = 0x0
	// GTCNT counter stop
	GPT320_GTSTP_CSTOP4_1 = 0x1
	// Position of CSTOP5 field.
	GPT320_GTSTP_CSTOP5_Pos = 0x5
	// Bit mask of CSTOP5 field.
	GPT320_GTSTP_CSTOP5_Msk = 0x20
	// Bit CSTOP5.
	GPT320_GTSTP_CSTOP5 = 0x20
	// GTCNT counter not stop
	GPT320_GTSTP_CSTOP5_0 = 0x0
	// GTCNT counter stop
	GPT320_GTSTP_CSTOP5_1 = 0x1
	// Position of CSTOP6 field.
	GPT320_GTSTP_CSTOP6_Pos = 0x6
	// Bit mask of CSTOP6 field.
	GPT320_GTSTP_CSTOP6_Msk = 0x40
	// Bit CSTOP6.
	GPT320_GTSTP_CSTOP6 = 0x40
	// GTCNT counter not stop
	GPT320_GTSTP_CSTOP6_0 = 0x0
	// GTCNT counter stop
	GPT320_GTSTP_CSTOP6_1 = 0x1
	// Position of CSTOP7 field.
	GPT320_GTSTP_CSTOP7_Pos = 0x7
	// Bit mask of CSTOP7 field.
	GPT320_GTSTP_CSTOP7_Msk = 0x80
	// Bit CSTOP7.
	GPT320_GTSTP_CSTOP7 = 0x80
	// GTCNT counter not stop
	GPT320_GTSTP_CSTOP7_0 = 0x0
	// GTCNT counter stop
	GPT320_GTSTP_CSTOP7_1 = 0x1
	// Position of CSTOP8 field.
	GPT320_GTSTP_CSTOP8_Pos = 0x8
	// Bit mask of CSTOP8 field.
	GPT320_GTSTP_CSTOP8_Msk = 0x100
	// Bit CSTOP8.
	GPT320_GTSTP_CSTOP8 = 0x100
	// GTCNT counter not stop
	GPT320_GTSTP_CSTOP8_0 = 0x0
	// GTCNT counter stop
	GPT320_GTSTP_CSTOP8_1 = 0x1
	// Position of CSTOP9 field.
	GPT320_GTSTP_CSTOP9_Pos = 0x9
	// Bit mask of CSTOP9 field.
	GPT320_GTSTP_CSTOP9_Msk = 0x200
	// Bit CSTOP9.
	GPT320_GTSTP_CSTOP9 = 0x200
	// GTCNT counter not stop
	GPT320_GTSTP_CSTOP9_0 = 0x0
	// GTCNT counter stop
	GPT320_GTSTP_CSTOP9_1 = 0x1

	// GTCLR: General PWM Timer Software Clear Register
	// Position of CCLR0 field.
	GPT320_GTCLR_CCLR0_Pos = 0x0
	// Bit mask of CCLR0 field.
	GPT320_GTCLR_CCLR0_Msk = 0x1
	// Bit CCLR0.
	GPT320_GTCLR_CCLR0 = 0x1
	// GTCNT counter is not cleared
	GPT320_GTCLR_CCLR0_0 = 0x0
	// GTCNT counter is cleared
	GPT320_GTCLR_CCLR0_1 = 0x1
	// Position of CCLR1 field.
	GPT320_GTCLR_CCLR1_Pos = 0x1
	// Bit mask of CCLR1 field.
	GPT320_GTCLR_CCLR1_Msk = 0x2
	// Bit CCLR1.
	GPT320_GTCLR_CCLR1 = 0x2
	// GTCNT counter is not cleared
	GPT320_GTCLR_CCLR1_0 = 0x0
	// GTCNT counter is cleared
	GPT320_GTCLR_CCLR1_1 = 0x1
	// Position of CCLR2 field.
	GPT320_GTCLR_CCLR2_Pos = 0x2
	// Bit mask of CCLR2 field.
	GPT320_GTCLR_CCLR2_Msk = 0x4
	// Bit CCLR2.
	GPT320_GTCLR_CCLR2 = 0x4
	// GTCNT counter is not cleared
	GPT320_GTCLR_CCLR2_0 = 0x0
	// GTCNT counter is cleared
	GPT320_GTCLR_CCLR2_1 = 0x1
	// Position of CCLR3 field.
	GPT320_GTCLR_CCLR3_Pos = 0x3
	// Bit mask of CCLR3 field.
	GPT320_GTCLR_CCLR3_Msk = 0x8
	// Bit CCLR3.
	GPT320_GTCLR_CCLR3 = 0x8
	// GTCNT counter is not cleared
	GPT320_GTCLR_CCLR3_0 = 0x0
	// GTCNT counter is cleared
	GPT320_GTCLR_CCLR3_1 = 0x1
	// Position of CCLR4 field.
	GPT320_GTCLR_CCLR4_Pos = 0x4
	// Bit mask of CCLR4 field.
	GPT320_GTCLR_CCLR4_Msk = 0x10
	// Bit CCLR4.
	GPT320_GTCLR_CCLR4 = 0x10
	// GTCNT counter is not cleared
	GPT320_GTCLR_CCLR4_0 = 0x0
	// GTCNT counter is cleared
	GPT320_GTCLR_CCLR4_1 = 0x1
	// Position of CCLR5 field.
	GPT320_GTCLR_CCLR5_Pos = 0x5
	// Bit mask of CCLR5 field.
	GPT320_GTCLR_CCLR5_Msk = 0x20
	// Bit CCLR5.
	GPT320_GTCLR_CCLR5 = 0x20
	// GTCNT counter is not cleared
	GPT320_GTCLR_CCLR5_0 = 0x0
	// GTCNT counter is cleared
	GPT320_GTCLR_CCLR5_1 = 0x1
	// Position of CCLR6 field.
	GPT320_GTCLR_CCLR6_Pos = 0x6
	// Bit mask of CCLR6 field.
	GPT320_GTCLR_CCLR6_Msk = 0x40
	// Bit CCLR6.
	GPT320_GTCLR_CCLR6 = 0x40
	// GTCNT counter is not cleared
	GPT320_GTCLR_CCLR6_0 = 0x0
	// GTCNT counter is cleared
	GPT320_GTCLR_CCLR6_1 = 0x1
	// Position of CCLR7 field.
	GPT320_GTCLR_CCLR7_Pos = 0x7
	// Bit mask of CCLR7 field.
	GPT320_GTCLR_CCLR7_Msk = 0x80
	// Bit CCLR7.
	GPT320_GTCLR_CCLR7 = 0x80
	// GTCNT counter is not cleared
	GPT320_GTCLR_CCLR7_0 = 0x0
	// GTCNT counter is cleared
	GPT320_GTCLR_CCLR7_1 = 0x1
	// Position of CCLR8 field.
	GPT320_GTCLR_CCLR8_Pos = 0x8
	// Bit mask of CCLR8 field.
	GPT320_GTCLR_CCLR8_Msk = 0x100
	// Bit CCLR8.
	GPT320_GTCLR_CCLR8 = 0x100
	// GTCNT counter is not cleared
	GPT320_GTCLR_CCLR8_0 = 0x0
	// GTCNT counter is cleared
	GPT320_GTCLR_CCLR8_1 = 0x1
	// Position of CCLR9 field.
	GPT320_GTCLR_CCLR9_Pos = 0x9
	// Bit mask of CCLR9 field.
	GPT320_GTCLR_CCLR9_Msk = 0x200
	// Bit CCLR9.
	GPT320_GTCLR_CCLR9 = 0x200
	// GTCNT counter is not cleared
	GPT320_GTCLR_CCLR9_0 = 0x0
	// GTCNT counter is cleared
	GPT320_GTCLR_CCLR9_1 = 0x1

	// GTSSR: General PWM Timer Start Source Select Register
	// Position of SSGTRGAR field.
	GPT320_GTSSR_SSGTRGAR_Pos = 0x0
	// Bit mask of SSGTRGAR field.
	GPT320_GTSSR_SSGTRGAR_Msk = 0x1
	// Bit SSGTRGAR.
	GPT320_GTSSR_SSGTRGAR = 0x1
	// Counter start disabled on the rising edge of GTETRGA input
	GPT320_GTSSR_SSGTRGAR_0 = 0x0
	// Counter start enabled on the rising edge of GTETRGA input
	GPT320_GTSSR_SSGTRGAR_1 = 0x1
	// Position of SSGTRGAF field.
	GPT320_GTSSR_SSGTRGAF_Pos = 0x1
	// Bit mask of SSGTRGAF field.
	GPT320_GTSSR_SSGTRGAF_Msk = 0x2
	// Bit SSGTRGAF.
	GPT320_GTSSR_SSGTRGAF = 0x2
	// Counter start disabled on the falling edge of GTETRGA input
	GPT320_GTSSR_SSGTRGAF_0 = 0x0
	// Counter start enabled on the falling edge of GTETRGA input
	GPT320_GTSSR_SSGTRGAF_1 = 0x1
	// Position of SSGTRGBR field.
	GPT320_GTSSR_SSGTRGBR_Pos = 0x2
	// Bit mask of SSGTRGBR field.
	GPT320_GTSSR_SSGTRGBR_Msk = 0x4
	// Bit SSGTRGBR.
	GPT320_GTSSR_SSGTRGBR = 0x4
	// Counter start disabled on the rising edge of GTETRGB input
	GPT320_GTSSR_SSGTRGBR_0 = 0x0
	// Counter start enabled on the rising edge of GTETRGB input
	GPT320_GTSSR_SSGTRGBR_1 = 0x1
	// Position of SSGTRGBF field.
	GPT320_GTSSR_SSGTRGBF_Pos = 0x3
	// Bit mask of SSGTRGBF field.
	GPT320_GTSSR_SSGTRGBF_Msk = 0x8
	// Bit SSGTRGBF.
	GPT320_GTSSR_SSGTRGBF = 0x8
	// Counter start disabled on the falling edge of GTETRGB input
	GPT320_GTSSR_SSGTRGBF_0 = 0x0
	// Counter start enabled on the falling edge of GTETRGB input
	GPT320_GTSSR_SSGTRGBF_1 = 0x1
	// Position of SSCARBL field.
	GPT320_GTSSR_SSCARBL_Pos = 0x8
	// Bit mask of SSCARBL field.
	GPT320_GTSSR_SSCARBL_Msk = 0x100
	// Bit SSCARBL.
	GPT320_GTSSR_SSCARBL = 0x100
	// Counter start disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTSSR_SSCARBL_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTSSR_SSCARBL_1 = 0x1
	// Position of SSCARBH field.
	GPT320_GTSSR_SSCARBH_Pos = 0x9
	// Bit mask of SSCARBH field.
	GPT320_GTSSR_SSCARBH_Msk = 0x200
	// Bit SSCARBH.
	GPT320_GTSSR_SSCARBH = 0x200
	// Counter start disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTSSR_SSCARBH_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTSSR_SSCARBH_1 = 0x1
	// Position of SSCAFBL field.
	GPT320_GTSSR_SSCAFBL_Pos = 0xa
	// Bit mask of SSCAFBL field.
	GPT320_GTSSR_SSCAFBL_Msk = 0x400
	// Bit SSCAFBL.
	GPT320_GTSSR_SSCAFBL = 0x400
	// Counter start disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTSSR_SSCAFBL_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTSSR_SSCAFBL_1 = 0x1
	// Position of SSCAFBH field.
	GPT320_GTSSR_SSCAFBH_Pos = 0xb
	// Bit mask of SSCAFBH field.
	GPT320_GTSSR_SSCAFBH_Msk = 0x800
	// Bit SSCAFBH.
	GPT320_GTSSR_SSCAFBH = 0x800
	// Counter start disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTSSR_SSCAFBH_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTSSR_SSCAFBH_1 = 0x1
	// Position of SSCBRAL field.
	GPT320_GTSSR_SSCBRAL_Pos = 0xc
	// Bit mask of SSCBRAL field.
	GPT320_GTSSR_SSCBRAL_Msk = 0x1000
	// Bit SSCBRAL.
	GPT320_GTSSR_SSCBRAL = 0x1000
	// Counter start disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTSSR_SSCBRAL_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTSSR_SSCBRAL_1 = 0x1
	// Position of SSCBRAH field.
	GPT320_GTSSR_SSCBRAH_Pos = 0xd
	// Bit mask of SSCBRAH field.
	GPT320_GTSSR_SSCBRAH_Msk = 0x2000
	// Bit SSCBRAH.
	GPT320_GTSSR_SSCBRAH = 0x2000
	// Counter start disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTSSR_SSCBRAH_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTSSR_SSCBRAH_1 = 0x1
	// Position of SSCBFAL field.
	GPT320_GTSSR_SSCBFAL_Pos = 0xe
	// Bit mask of SSCBFAL field.
	GPT320_GTSSR_SSCBFAL_Msk = 0x4000
	// Bit SSCBFAL.
	GPT320_GTSSR_SSCBFAL = 0x4000
	// Counter start disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTSSR_SSCBFAL_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTSSR_SSCBFAL_1 = 0x1
	// Position of SSCBFAH field.
	GPT320_GTSSR_SSCBFAH_Pos = 0xf
	// Bit mask of SSCBFAH field.
	GPT320_GTSSR_SSCBFAH_Msk = 0x8000
	// Bit SSCBFAH.
	GPT320_GTSSR_SSCBFAH = 0x8000
	// Counter start disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTSSR_SSCBFAH_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTSSR_SSCBFAH_1 = 0x1
	// Position of SSELCA field.
	GPT320_GTSSR_SSELCA_Pos = 0x10
	// Bit mask of SSELCA field.
	GPT320_GTSSR_SSELCA_Msk = 0x10000
	// Bit SSELCA.
	GPT320_GTSSR_SSELCA = 0x10000
	// Counter start disabled at the ELC_GPTA input
	GPT320_GTSSR_SSELCA_0 = 0x0
	// Counter start enabled at the ELC_GPTA input
	GPT320_GTSSR_SSELCA_1 = 0x1
	// Position of SSELCB field.
	GPT320_GTSSR_SSELCB_Pos = 0x11
	// Bit mask of SSELCB field.
	GPT320_GTSSR_SSELCB_Msk = 0x20000
	// Bit SSELCB.
	GPT320_GTSSR_SSELCB = 0x20000
	// Counter start disabled at the ELC_GPTB input
	GPT320_GTSSR_SSELCB_0 = 0x0
	// Counter start enabled at the ELC_GPTB input
	GPT320_GTSSR_SSELCB_1 = 0x1
	// Position of SSELCC field.
	GPT320_GTSSR_SSELCC_Pos = 0x12
	// Bit mask of SSELCC field.
	GPT320_GTSSR_SSELCC_Msk = 0x40000
	// Bit SSELCC.
	GPT320_GTSSR_SSELCC = 0x40000
	// Counter start disabled at the ELC_GPTC input
	GPT320_GTSSR_SSELCC_0 = 0x0
	// Counter start enabled at the ELC_GPTC input
	GPT320_GTSSR_SSELCC_1 = 0x1
	// Position of SSELCD field.
	GPT320_GTSSR_SSELCD_Pos = 0x13
	// Bit mask of SSELCD field.
	GPT320_GTSSR_SSELCD_Msk = 0x80000
	// Bit SSELCD.
	GPT320_GTSSR_SSELCD = 0x80000
	// Counter start disabled at the ELC_GPTD input
	GPT320_GTSSR_SSELCD_0 = 0x0
	// Counter start enabled at the ELC_GPTD input
	GPT320_GTSSR_SSELCD_1 = 0x1
	// Position of CSTRT field.
	GPT320_GTSSR_CSTRT_Pos = 0x1f
	// Bit mask of CSTRT field.
	GPT320_GTSSR_CSTRT_Msk = 0x80000000
	// Bit CSTRT.
	GPT320_GTSSR_CSTRT = 0x80000000
	// Counter start disabled by the GTSTR register
	GPT320_GTSSR_CSTRT_0 = 0x0
	// Counter start enabled by the GTSTR register
	GPT320_GTSSR_CSTRT_1 = 0x1

	// GTPSR: General PWM Timer Stop Source Select Register
	// Position of PSGTRGAR field.
	GPT320_GTPSR_PSGTRGAR_Pos = 0x0
	// Bit mask of PSGTRGAR field.
	GPT320_GTPSR_PSGTRGAR_Msk = 0x1
	// Bit PSGTRGAR.
	GPT320_GTPSR_PSGTRGAR = 0x1
	// Counter stop disabled on the rising edge of GTETRGA input
	GPT320_GTPSR_PSGTRGAR_0 = 0x0
	// Counter stop enabled on the rising edge of GTETRGA input
	GPT320_GTPSR_PSGTRGAR_1 = 0x1
	// Position of PSGTRGAF field.
	GPT320_GTPSR_PSGTRGAF_Pos = 0x1
	// Bit mask of PSGTRGAF field.
	GPT320_GTPSR_PSGTRGAF_Msk = 0x2
	// Bit PSGTRGAF.
	GPT320_GTPSR_PSGTRGAF = 0x2
	// Counter stop disabled on the falling edge of GTETRGA input
	GPT320_GTPSR_PSGTRGAF_0 = 0x0
	// Counter stop enabled on the falling edge of GTETRGA input
	GPT320_GTPSR_PSGTRGAF_1 = 0x1
	// Position of PSGTRGBR field.
	GPT320_GTPSR_PSGTRGBR_Pos = 0x2
	// Bit mask of PSGTRGBR field.
	GPT320_GTPSR_PSGTRGBR_Msk = 0x4
	// Bit PSGTRGBR.
	GPT320_GTPSR_PSGTRGBR = 0x4
	// Counter stop disabled on the rising edge of GTETRGB input
	GPT320_GTPSR_PSGTRGBR_0 = 0x0
	// Counter stop enabled on the rising edge of GTETRGB input
	GPT320_GTPSR_PSGTRGBR_1 = 0x1
	// Position of PSGTRGBF field.
	GPT320_GTPSR_PSGTRGBF_Pos = 0x3
	// Bit mask of PSGTRGBF field.
	GPT320_GTPSR_PSGTRGBF_Msk = 0x8
	// Bit PSGTRGBF.
	GPT320_GTPSR_PSGTRGBF = 0x8
	// Counter stop disabled on the falling edge of GTETRGB input
	GPT320_GTPSR_PSGTRGBF_0 = 0x0
	// Counter stop enabled on the falling edge of GTETRGB input
	GPT320_GTPSR_PSGTRGBF_1 = 0x1
	// Position of PSCARBL field.
	GPT320_GTPSR_PSCARBL_Pos = 0x8
	// Bit mask of PSCARBL field.
	GPT320_GTPSR_PSCARBL_Msk = 0x100
	// Bit PSCARBL.
	GPT320_GTPSR_PSCARBL = 0x100
	// Counter stop disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTPSR_PSCARBL_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTPSR_PSCARBL_1 = 0x1
	// Position of PSCARBH field.
	GPT320_GTPSR_PSCARBH_Pos = 0x9
	// Bit mask of PSCARBH field.
	GPT320_GTPSR_PSCARBH_Msk = 0x200
	// Bit PSCARBH.
	GPT320_GTPSR_PSCARBH = 0x200
	// Counter stop disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTPSR_PSCARBH_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTPSR_PSCARBH_1 = 0x1
	// Position of PSCAFBL field.
	GPT320_GTPSR_PSCAFBL_Pos = 0xa
	// Bit mask of PSCAFBL field.
	GPT320_GTPSR_PSCAFBL_Msk = 0x400
	// Bit PSCAFBL.
	GPT320_GTPSR_PSCAFBL = 0x400
	// Counter stop disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTPSR_PSCAFBL_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTPSR_PSCAFBL_1 = 0x1
	// Position of PSCAFBH field.
	GPT320_GTPSR_PSCAFBH_Pos = 0xb
	// Bit mask of PSCAFBH field.
	GPT320_GTPSR_PSCAFBH_Msk = 0x800
	// Bit PSCAFBH.
	GPT320_GTPSR_PSCAFBH = 0x800
	// Counter stop disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTPSR_PSCAFBH_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTPSR_PSCAFBH_1 = 0x1
	// Position of PSCBRAL field.
	GPT320_GTPSR_PSCBRAL_Pos = 0xc
	// Bit mask of PSCBRAL field.
	GPT320_GTPSR_PSCBRAL_Msk = 0x1000
	// Bit PSCBRAL.
	GPT320_GTPSR_PSCBRAL = 0x1000
	// Counter stop disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTPSR_PSCBRAL_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTPSR_PSCBRAL_1 = 0x1
	// Position of PSCBRAH field.
	GPT320_GTPSR_PSCBRAH_Pos = 0xd
	// Bit mask of PSCBRAH field.
	GPT320_GTPSR_PSCBRAH_Msk = 0x2000
	// Bit PSCBRAH.
	GPT320_GTPSR_PSCBRAH = 0x2000
	// Counter stop disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTPSR_PSCBRAH_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTPSR_PSCBRAH_1 = 0x1
	// Position of PSCBFAL field.
	GPT320_GTPSR_PSCBFAL_Pos = 0xe
	// Bit mask of PSCBFAL field.
	GPT320_GTPSR_PSCBFAL_Msk = 0x4000
	// Bit PSCBFAL.
	GPT320_GTPSR_PSCBFAL = 0x4000
	// Counter stop disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTPSR_PSCBFAL_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTPSR_PSCBFAL_1 = 0x1
	// Position of PSCBFAH field.
	GPT320_GTPSR_PSCBFAH_Pos = 0xf
	// Bit mask of PSCBFAH field.
	GPT320_GTPSR_PSCBFAH_Msk = 0x8000
	// Bit PSCBFAH.
	GPT320_GTPSR_PSCBFAH = 0x8000
	// Counter stop disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTPSR_PSCBFAH_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTPSR_PSCBFAH_1 = 0x1
	// Position of PSELCA field.
	GPT320_GTPSR_PSELCA_Pos = 0x10
	// Bit mask of PSELCA field.
	GPT320_GTPSR_PSELCA_Msk = 0x10000
	// Bit PSELCA.
	GPT320_GTPSR_PSELCA = 0x10000
	// Counter stop disabled at the ELC_GPTA input
	GPT320_GTPSR_PSELCA_0 = 0x0
	// Counter stop enabled at the ELC_GPTA input
	GPT320_GTPSR_PSELCA_1 = 0x1
	// Position of PSELCB field.
	GPT320_GTPSR_PSELCB_Pos = 0x11
	// Bit mask of PSELCB field.
	GPT320_GTPSR_PSELCB_Msk = 0x20000
	// Bit PSELCB.
	GPT320_GTPSR_PSELCB = 0x20000
	// Counter stop disabled at the ELC_GPTB input
	GPT320_GTPSR_PSELCB_0 = 0x0
	// Counter stop enabled at the ELC_GPTB input
	GPT320_GTPSR_PSELCB_1 = 0x1
	// Position of PSELCC field.
	GPT320_GTPSR_PSELCC_Pos = 0x12
	// Bit mask of PSELCC field.
	GPT320_GTPSR_PSELCC_Msk = 0x40000
	// Bit PSELCC.
	GPT320_GTPSR_PSELCC = 0x40000
	// Counter stop disabled at the ELC_GPTC input
	GPT320_GTPSR_PSELCC_0 = 0x0
	// Counter stop enabled at the ELC_GPTC input
	GPT320_GTPSR_PSELCC_1 = 0x1
	// Position of PSELCD field.
	GPT320_GTPSR_PSELCD_Pos = 0x13
	// Bit mask of PSELCD field.
	GPT320_GTPSR_PSELCD_Msk = 0x80000
	// Bit PSELCD.
	GPT320_GTPSR_PSELCD = 0x80000
	// Counter stop disabled at the ELC_GPTD input
	GPT320_GTPSR_PSELCD_0 = 0x0
	// Counter stop enabled at the ELC_GPTD input
	GPT320_GTPSR_PSELCD_1 = 0x1
	// Position of CSTOP field.
	GPT320_GTPSR_CSTOP_Pos = 0x1f
	// Bit mask of CSTOP field.
	GPT320_GTPSR_CSTOP_Msk = 0x80000000
	// Bit CSTOP.
	GPT320_GTPSR_CSTOP = 0x80000000
	// Counter stop disabled by the GTSTP register
	GPT320_GTPSR_CSTOP_0 = 0x0
	// Counter stop enabled by the GTSTP register
	GPT320_GTPSR_CSTOP_1 = 0x1

	// GTCSR: General PWM Timer Clear Source Select Register
	// Position of CSGTRGAR field.
	GPT320_GTCSR_CSGTRGAR_Pos = 0x0
	// Bit mask of CSGTRGAR field.
	GPT320_GTCSR_CSGTRGAR_Msk = 0x1
	// Bit CSGTRGAR.
	GPT320_GTCSR_CSGTRGAR = 0x1
	// Counter clear disabled on the rising edge of GTETRGA input
	GPT320_GTCSR_CSGTRGAR_0 = 0x0
	// Counter clear enabled on the rising edge of GTETRGA input
	GPT320_GTCSR_CSGTRGAR_1 = 0x1
	// Position of CSGTRGAF field.
	GPT320_GTCSR_CSGTRGAF_Pos = 0x1
	// Bit mask of CSGTRGAF field.
	GPT320_GTCSR_CSGTRGAF_Msk = 0x2
	// Bit CSGTRGAF.
	GPT320_GTCSR_CSGTRGAF = 0x2
	// Counter clear disabled on the falling edge of GTETRGA input
	GPT320_GTCSR_CSGTRGAF_0 = 0x0
	// Counter clear enabled on the falling edge of GTETRGA input
	GPT320_GTCSR_CSGTRGAF_1 = 0x1
	// Position of CSGTRGBR field.
	GPT320_GTCSR_CSGTRGBR_Pos = 0x2
	// Bit mask of CSGTRGBR field.
	GPT320_GTCSR_CSGTRGBR_Msk = 0x4
	// Bit CSGTRGBR.
	GPT320_GTCSR_CSGTRGBR = 0x4
	// Disable counter clear on the rising edge of GTETRGB input
	GPT320_GTCSR_CSGTRGBR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGB input
	GPT320_GTCSR_CSGTRGBR_1 = 0x1
	// Position of CSGTRGBF field.
	GPT320_GTCSR_CSGTRGBF_Pos = 0x3
	// Bit mask of CSGTRGBF field.
	GPT320_GTCSR_CSGTRGBF_Msk = 0x8
	// Bit CSGTRGBF.
	GPT320_GTCSR_CSGTRGBF = 0x8
	// Counter clear disabled on the falling edge of GTETRGB input
	GPT320_GTCSR_CSGTRGBF_0 = 0x0
	// Counter clear enabled on the falling edge of GTETRGB input
	GPT320_GTCSR_CSGTRGBF_1 = 0x1
	// Position of CSCARBL field.
	GPT320_GTCSR_CSCARBL_Pos = 0x8
	// Bit mask of CSCARBL field.
	GPT320_GTCSR_CSCARBL_Msk = 0x100
	// Bit CSCARBL.
	GPT320_GTCSR_CSCARBL = 0x100
	// Counter clear disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTCSR_CSCARBL_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTCSR_CSCARBL_1 = 0x1
	// Position of CSCARBH field.
	GPT320_GTCSR_CSCARBH_Pos = 0x9
	// Bit mask of CSCARBH field.
	GPT320_GTCSR_CSCARBH_Msk = 0x200
	// Bit CSCARBH.
	GPT320_GTCSR_CSCARBH = 0x200
	// Counter clear disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTCSR_CSCARBH_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTCSR_CSCARBH_1 = 0x1
	// Position of CSCAFBL field.
	GPT320_GTCSR_CSCAFBL_Pos = 0xa
	// Bit mask of CSCAFBL field.
	GPT320_GTCSR_CSCAFBL_Msk = 0x400
	// Bit CSCAFBL.
	GPT320_GTCSR_CSCAFBL = 0x400
	// Counter clear disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTCSR_CSCAFBL_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTCSR_CSCAFBL_1 = 0x1
	// Position of CSCAFBH field.
	GPT320_GTCSR_CSCAFBH_Pos = 0xb
	// Bit mask of CSCAFBH field.
	GPT320_GTCSR_CSCAFBH_Msk = 0x800
	// Bit CSCAFBH.
	GPT320_GTCSR_CSCAFBH = 0x800
	// Counter clear disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTCSR_CSCAFBH_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTCSR_CSCAFBH_1 = 0x1
	// Position of CSCBRAL field.
	GPT320_GTCSR_CSCBRAL_Pos = 0xc
	// Bit mask of CSCBRAL field.
	GPT320_GTCSR_CSCBRAL_Msk = 0x1000
	// Bit CSCBRAL.
	GPT320_GTCSR_CSCBRAL = 0x1000
	// Counter clear disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTCSR_CSCBRAL_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTCSR_CSCBRAL_1 = 0x1
	// Position of CSCBRAH field.
	GPT320_GTCSR_CSCBRAH_Pos = 0xd
	// Bit mask of CSCBRAH field.
	GPT320_GTCSR_CSCBRAH_Msk = 0x2000
	// Bit CSCBRAH.
	GPT320_GTCSR_CSCBRAH = 0x2000
	// Counter clear disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTCSR_CSCBRAH_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTCSR_CSCBRAH_1 = 0x1
	// Position of CSCBFAL field.
	GPT320_GTCSR_CSCBFAL_Pos = 0xe
	// Bit mask of CSCBFAL field.
	GPT320_GTCSR_CSCBFAL_Msk = 0x4000
	// Bit CSCBFAL.
	GPT320_GTCSR_CSCBFAL = 0x4000
	// Counter clear disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTCSR_CSCBFAL_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTCSR_CSCBFAL_1 = 0x1
	// Position of CSCBFAH field.
	GPT320_GTCSR_CSCBFAH_Pos = 0xf
	// Bit mask of CSCBFAH field.
	GPT320_GTCSR_CSCBFAH_Msk = 0x8000
	// Bit CSCBFAH.
	GPT320_GTCSR_CSCBFAH = 0x8000
	// Counter clear disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTCSR_CSCBFAH_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTCSR_CSCBFAH_1 = 0x1
	// Position of CSELCA field.
	GPT320_GTCSR_CSELCA_Pos = 0x10
	// Bit mask of CSELCA field.
	GPT320_GTCSR_CSELCA_Msk = 0x10000
	// Bit CSELCA.
	GPT320_GTCSR_CSELCA = 0x10000
	// Counter clear disabled at the ELC_GPTA input
	GPT320_GTCSR_CSELCA_0 = 0x0
	// Counter clear enabled at the ELC_GPTA input
	GPT320_GTCSR_CSELCA_1 = 0x1
	// Position of CSELCB field.
	GPT320_GTCSR_CSELCB_Pos = 0x11
	// Bit mask of CSELCB field.
	GPT320_GTCSR_CSELCB_Msk = 0x20000
	// Bit CSELCB.
	GPT320_GTCSR_CSELCB = 0x20000
	// Counter clear disabled at the ELC_GPTB input
	GPT320_GTCSR_CSELCB_0 = 0x0
	// Counter clear enabled at the ELC_GPTB input
	GPT320_GTCSR_CSELCB_1 = 0x1
	// Position of CSELCC field.
	GPT320_GTCSR_CSELCC_Pos = 0x12
	// Bit mask of CSELCC field.
	GPT320_GTCSR_CSELCC_Msk = 0x40000
	// Bit CSELCC.
	GPT320_GTCSR_CSELCC = 0x40000
	// Counter clear disabled at the ELC_GPTC input
	GPT320_GTCSR_CSELCC_0 = 0x0
	// Counter clear enabled at the ELC_GPTC input
	GPT320_GTCSR_CSELCC_1 = 0x1
	// Position of CSELCD field.
	GPT320_GTCSR_CSELCD_Pos = 0x13
	// Bit mask of CSELCD field.
	GPT320_GTCSR_CSELCD_Msk = 0x80000
	// Bit CSELCD.
	GPT320_GTCSR_CSELCD = 0x80000
	// Counter clear disabled at the ELC_GPTD input
	GPT320_GTCSR_CSELCD_0 = 0x0
	// Counter clear enabled at the ELC_GPTD input
	GPT320_GTCSR_CSELCD_1 = 0x1
	// Position of CCLR field.
	GPT320_GTCSR_CCLR_Pos = 0x1f
	// Bit mask of CCLR field.
	GPT320_GTCSR_CCLR_Msk = 0x80000000
	// Bit CCLR.
	GPT320_GTCSR_CCLR = 0x80000000
	// Counter clear disabled by the GTCLR register
	GPT320_GTCSR_CCLR_0 = 0x0
	// Counter clear enabled by the GTCLR register
	GPT320_GTCSR_CCLR_1 = 0x1

	// GTUPSR: General PWM Timer Up Count Source Select Register
	// Position of USGTRGAR field.
	GPT320_GTUPSR_USGTRGAR_Pos = 0x0
	// Bit mask of USGTRGAR field.
	GPT320_GTUPSR_USGTRGAR_Msk = 0x1
	// Bit USGTRGAR.
	GPT320_GTUPSR_USGTRGAR = 0x1
	// Counter count up disabled on the rising edge of GTETRGA input
	GPT320_GTUPSR_USGTRGAR_0 = 0x0
	// Counter count up enabled on the rising edge of GTETRGA input
	GPT320_GTUPSR_USGTRGAR_1 = 0x1
	// Position of USGTRGAF field.
	GPT320_GTUPSR_USGTRGAF_Pos = 0x1
	// Bit mask of USGTRGAF field.
	GPT320_GTUPSR_USGTRGAF_Msk = 0x2
	// Bit USGTRGAF.
	GPT320_GTUPSR_USGTRGAF = 0x2
	// Counter count up disabled on the falling edge of GTETRGA input
	GPT320_GTUPSR_USGTRGAF_0 = 0x0
	// Counter count up enabled on the falling edge of GTETRGA input
	GPT320_GTUPSR_USGTRGAF_1 = 0x1
	// Position of USGTRGBR field.
	GPT320_GTUPSR_USGTRGBR_Pos = 0x2
	// Bit mask of USGTRGBR field.
	GPT320_GTUPSR_USGTRGBR_Msk = 0x4
	// Bit USGTRGBR.
	GPT320_GTUPSR_USGTRGBR = 0x4
	// Counter count up disabled on the rising edge of GTETRGB input
	GPT320_GTUPSR_USGTRGBR_0 = 0x0
	// Counter count up enabled on the rising edge of GTETRGB input
	GPT320_GTUPSR_USGTRGBR_1 = 0x1
	// Position of USGTRGBF field.
	GPT320_GTUPSR_USGTRGBF_Pos = 0x3
	// Bit mask of USGTRGBF field.
	GPT320_GTUPSR_USGTRGBF_Msk = 0x8
	// Bit USGTRGBF.
	GPT320_GTUPSR_USGTRGBF = 0x8
	// Counter count up disabled on the falling edge of GTETRGB input
	GPT320_GTUPSR_USGTRGBF_0 = 0x0
	// Counter count up enabled on the falling edge of GTETRGB input
	GPT320_GTUPSR_USGTRGBF_1 = 0x1
	// Position of USCARBL field.
	GPT320_GTUPSR_USCARBL_Pos = 0x8
	// Bit mask of USCARBL field.
	GPT320_GTUPSR_USCARBL_Msk = 0x100
	// Bit USCARBL.
	GPT320_GTUPSR_USCARBL = 0x100
	// Counter count up disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTUPSR_USCARBL_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTUPSR_USCARBL_1 = 0x1
	// Position of USCARBH field.
	GPT320_GTUPSR_USCARBH_Pos = 0x9
	// Bit mask of USCARBH field.
	GPT320_GTUPSR_USCARBH_Msk = 0x200
	// Bit USCARBH.
	GPT320_GTUPSR_USCARBH = 0x200
	// Counter count up disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTUPSR_USCARBH_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTUPSR_USCARBH_1 = 0x1
	// Position of USCAFBL field.
	GPT320_GTUPSR_USCAFBL_Pos = 0xa
	// Bit mask of USCAFBL field.
	GPT320_GTUPSR_USCAFBL_Msk = 0x400
	// Bit USCAFBL.
	GPT320_GTUPSR_USCAFBL = 0x400
	// Counter count up disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTUPSR_USCAFBL_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTUPSR_USCAFBL_1 = 0x1
	// Position of USCAFBH field.
	GPT320_GTUPSR_USCAFBH_Pos = 0xb
	// Bit mask of USCAFBH field.
	GPT320_GTUPSR_USCAFBH_Msk = 0x800
	// Bit USCAFBH.
	GPT320_GTUPSR_USCAFBH = 0x800
	// Counter count up disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTUPSR_USCAFBH_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTUPSR_USCAFBH_1 = 0x1
	// Position of USCBRAL field.
	GPT320_GTUPSR_USCBRAL_Pos = 0xc
	// Bit mask of USCBRAL field.
	GPT320_GTUPSR_USCBRAL_Msk = 0x1000
	// Bit USCBRAL.
	GPT320_GTUPSR_USCBRAL = 0x1000
	// Counter count up disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTUPSR_USCBRAL_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTUPSR_USCBRAL_1 = 0x1
	// Position of USCBRAH field.
	GPT320_GTUPSR_USCBRAH_Pos = 0xd
	// Bit mask of USCBRAH field.
	GPT320_GTUPSR_USCBRAH_Msk = 0x2000
	// Bit USCBRAH.
	GPT320_GTUPSR_USCBRAH = 0x2000
	// Counter count up disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTUPSR_USCBRAH_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTUPSR_USCBRAH_1 = 0x1
	// Position of USCBFAL field.
	GPT320_GTUPSR_USCBFAL_Pos = 0xe
	// Bit mask of USCBFAL field.
	GPT320_GTUPSR_USCBFAL_Msk = 0x4000
	// Bit USCBFAL.
	GPT320_GTUPSR_USCBFAL = 0x4000
	// Counter count up disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTUPSR_USCBFAL_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTUPSR_USCBFAL_1 = 0x1
	// Position of USCBFAH field.
	GPT320_GTUPSR_USCBFAH_Pos = 0xf
	// Bit mask of USCBFAH field.
	GPT320_GTUPSR_USCBFAH_Msk = 0x8000
	// Bit USCBFAH.
	GPT320_GTUPSR_USCBFAH = 0x8000
	// Counter count up disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTUPSR_USCBFAH_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTUPSR_USCBFAH_1 = 0x1
	// Position of USELCA field.
	GPT320_GTUPSR_USELCA_Pos = 0x10
	// Bit mask of USELCA field.
	GPT320_GTUPSR_USELCA_Msk = 0x10000
	// Bit USELCA.
	GPT320_GTUPSR_USELCA = 0x10000
	// Counter count up disabled at the ELC_GPTA input
	GPT320_GTUPSR_USELCA_0 = 0x0
	// Counter count up enabled at the ELC_GPTA input
	GPT320_GTUPSR_USELCA_1 = 0x1
	// Position of USELCB field.
	GPT320_GTUPSR_USELCB_Pos = 0x11
	// Bit mask of USELCB field.
	GPT320_GTUPSR_USELCB_Msk = 0x20000
	// Bit USELCB.
	GPT320_GTUPSR_USELCB = 0x20000
	// Counter count up disabled at the ELC_GPTB input
	GPT320_GTUPSR_USELCB_0 = 0x0
	// Counter count up enabled at the ELC_GPTB input
	GPT320_GTUPSR_USELCB_1 = 0x1
	// Position of USELCC field.
	GPT320_GTUPSR_USELCC_Pos = 0x12
	// Bit mask of USELCC field.
	GPT320_GTUPSR_USELCC_Msk = 0x40000
	// Bit USELCC.
	GPT320_GTUPSR_USELCC = 0x40000
	// Counter count up disabled at the ELC_GPTC input
	GPT320_GTUPSR_USELCC_0 = 0x0
	// Counter count up enabled at the ELC_GPTC input
	GPT320_GTUPSR_USELCC_1 = 0x1
	// Position of USELCD field.
	GPT320_GTUPSR_USELCD_Pos = 0x13
	// Bit mask of USELCD field.
	GPT320_GTUPSR_USELCD_Msk = 0x80000
	// Bit USELCD.
	GPT320_GTUPSR_USELCD = 0x80000
	// Counter count up disabled at the ELC_GPTD input
	GPT320_GTUPSR_USELCD_0 = 0x0
	// Counter count up enabled at the ELC_GPTD input
	GPT320_GTUPSR_USELCD_1 = 0x1

	// GTDNSR: General PWM Timer Down Count Source Select Register
	// Position of DSGTRGAR field.
	GPT320_GTDNSR_DSGTRGAR_Pos = 0x0
	// Bit mask of DSGTRGAR field.
	GPT320_GTDNSR_DSGTRGAR_Msk = 0x1
	// Bit DSGTRGAR.
	GPT320_GTDNSR_DSGTRGAR = 0x1
	// Counter count down disabled on the rising edge of GTETRGA input
	GPT320_GTDNSR_DSGTRGAR_0 = 0x0
	// Counter count down enabled on the rising edge of GTETRGA input
	GPT320_GTDNSR_DSGTRGAR_1 = 0x1
	// Position of DSGTRGAF field.
	GPT320_GTDNSR_DSGTRGAF_Pos = 0x1
	// Bit mask of DSGTRGAF field.
	GPT320_GTDNSR_DSGTRGAF_Msk = 0x2
	// Bit DSGTRGAF.
	GPT320_GTDNSR_DSGTRGAF = 0x2
	// Counter count down disabled on the falling edge of GTETRGA input
	GPT320_GTDNSR_DSGTRGAF_0 = 0x0
	// Counter count down enabled on the falling edge of GTETRGA input
	GPT320_GTDNSR_DSGTRGAF_1 = 0x1
	// Position of DSGTRGBR field.
	GPT320_GTDNSR_DSGTRGBR_Pos = 0x2
	// Bit mask of DSGTRGBR field.
	GPT320_GTDNSR_DSGTRGBR_Msk = 0x4
	// Bit DSGTRGBR.
	GPT320_GTDNSR_DSGTRGBR = 0x4
	// Counter count down disabled on the rising edge of GTETRGB input
	GPT320_GTDNSR_DSGTRGBR_0 = 0x0
	// Counter count down enabled on the rising edge of GTETRGB input
	GPT320_GTDNSR_DSGTRGBR_1 = 0x1
	// Position of DSGTRGBF field.
	GPT320_GTDNSR_DSGTRGBF_Pos = 0x3
	// Bit mask of DSGTRGBF field.
	GPT320_GTDNSR_DSGTRGBF_Msk = 0x8
	// Bit DSGTRGBF.
	GPT320_GTDNSR_DSGTRGBF = 0x8
	// Counter count down disabled on the falling edge of GTETRGB input
	GPT320_GTDNSR_DSGTRGBF_0 = 0x0
	// Counter count down enabled on the falling edge of GTETRGB input
	GPT320_GTDNSR_DSGTRGBF_1 = 0x1
	// Position of DSCARBL field.
	GPT320_GTDNSR_DSCARBL_Pos = 0x8
	// Bit mask of DSCARBL field.
	GPT320_GTDNSR_DSCARBL_Msk = 0x100
	// Bit DSCARBL.
	GPT320_GTDNSR_DSCARBL = 0x100
	// Counter count down disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTDNSR_DSCARBL_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTDNSR_DSCARBL_1 = 0x1
	// Position of DSCARBH field.
	GPT320_GTDNSR_DSCARBH_Pos = 0x9
	// Bit mask of DSCARBH field.
	GPT320_GTDNSR_DSCARBH_Msk = 0x200
	// Bit DSCARBH.
	GPT320_GTDNSR_DSCARBH = 0x200
	// Counter count down disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTDNSR_DSCARBH_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTDNSR_DSCARBH_1 = 0x1
	// Position of DSCAFBL field.
	GPT320_GTDNSR_DSCAFBL_Pos = 0xa
	// Bit mask of DSCAFBL field.
	GPT320_GTDNSR_DSCAFBL_Msk = 0x400
	// Bit DSCAFBL.
	GPT320_GTDNSR_DSCAFBL = 0x400
	// Counter count down disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTDNSR_DSCAFBL_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTDNSR_DSCAFBL_1 = 0x1
	// Position of DSCAFBH field.
	GPT320_GTDNSR_DSCAFBH_Pos = 0xb
	// Bit mask of DSCAFBH field.
	GPT320_GTDNSR_DSCAFBH_Msk = 0x800
	// Bit DSCAFBH.
	GPT320_GTDNSR_DSCAFBH = 0x800
	// Counter count down disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTDNSR_DSCAFBH_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTDNSR_DSCAFBH_1 = 0x1
	// Position of DSCBRAL field.
	GPT320_GTDNSR_DSCBRAL_Pos = 0xc
	// Bit mask of DSCBRAL field.
	GPT320_GTDNSR_DSCBRAL_Msk = 0x1000
	// Bit DSCBRAL.
	GPT320_GTDNSR_DSCBRAL = 0x1000
	// Counter count down disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTDNSR_DSCBRAL_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTDNSR_DSCBRAL_1 = 0x1
	// Position of DSCBRAH field.
	GPT320_GTDNSR_DSCBRAH_Pos = 0xd
	// Bit mask of DSCBRAH field.
	GPT320_GTDNSR_DSCBRAH_Msk = 0x2000
	// Bit DSCBRAH.
	GPT320_GTDNSR_DSCBRAH = 0x2000
	// Counter count down disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTDNSR_DSCBRAH_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTDNSR_DSCBRAH_1 = 0x1
	// Position of DSCBFAL field.
	GPT320_GTDNSR_DSCBFAL_Pos = 0xe
	// Bit mask of DSCBFAL field.
	GPT320_GTDNSR_DSCBFAL_Msk = 0x4000
	// Bit DSCBFAL.
	GPT320_GTDNSR_DSCBFAL = 0x4000
	// Counter count down disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTDNSR_DSCBFAL_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTDNSR_DSCBFAL_1 = 0x1
	// Position of DSCBFAH field.
	GPT320_GTDNSR_DSCBFAH_Pos = 0xf
	// Bit mask of DSCBFAH field.
	GPT320_GTDNSR_DSCBFAH_Msk = 0x8000
	// Bit DSCBFAH.
	GPT320_GTDNSR_DSCBFAH = 0x8000
	// Counter count down disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTDNSR_DSCBFAH_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTDNSR_DSCBFAH_1 = 0x1
	// Position of DSELCA field.
	GPT320_GTDNSR_DSELCA_Pos = 0x10
	// Bit mask of DSELCA field.
	GPT320_GTDNSR_DSELCA_Msk = 0x10000
	// Bit DSELCA.
	GPT320_GTDNSR_DSELCA = 0x10000
	// Counter count down disabled at the ELC_GPTA input
	GPT320_GTDNSR_DSELCA_0 = 0x0
	// Counter count down enabled at the ELC_GPTA input
	GPT320_GTDNSR_DSELCA_1 = 0x1
	// Position of DSELCB field.
	GPT320_GTDNSR_DSELCB_Pos = 0x11
	// Bit mask of DSELCB field.
	GPT320_GTDNSR_DSELCB_Msk = 0x20000
	// Bit DSELCB.
	GPT320_GTDNSR_DSELCB = 0x20000
	// Counter count down disabled at the ELC_GPTB input
	GPT320_GTDNSR_DSELCB_0 = 0x0
	// Counter count down enabled at the ELC_GPTB input
	GPT320_GTDNSR_DSELCB_1 = 0x1
	// Position of DSELCC field.
	GPT320_GTDNSR_DSELCC_Pos = 0x12
	// Bit mask of DSELCC field.
	GPT320_GTDNSR_DSELCC_Msk = 0x40000
	// Bit DSELCC.
	GPT320_GTDNSR_DSELCC = 0x40000
	// Counter count down disabled at the ELC_GPTC input
	GPT320_GTDNSR_DSELCC_0 = 0x0
	// Counter count down enabled at the ELC_GPTC input
	GPT320_GTDNSR_DSELCC_1 = 0x1
	// Position of DSELCD field.
	GPT320_GTDNSR_DSELCD_Pos = 0x13
	// Bit mask of DSELCD field.
	GPT320_GTDNSR_DSELCD_Msk = 0x80000
	// Bit DSELCD.
	GPT320_GTDNSR_DSELCD = 0x80000
	// Counter count down disabled at the ELC_GPTD input
	GPT320_GTDNSR_DSELCD_0 = 0x0
	// Counter count down enabled at the ELC_GPTD input
	GPT320_GTDNSR_DSELCD_1 = 0x1

	// GTICASR: General PWM Timer Input Capture Source Select Register A
	// Position of ASGTRGAR field.
	GPT320_GTICASR_ASGTRGAR_Pos = 0x0
	// Bit mask of ASGTRGAR field.
	GPT320_GTICASR_ASGTRGAR_Msk = 0x1
	// Bit ASGTRGAR.
	GPT320_GTICASR_ASGTRGAR = 0x1
	// GTCCRA input capture disabled on the rising edge of GTETRGA input
	GPT320_GTICASR_ASGTRGAR_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTETRGA input
	GPT320_GTICASR_ASGTRGAR_1 = 0x1
	// Position of ASGTRGAF field.
	GPT320_GTICASR_ASGTRGAF_Pos = 0x1
	// Bit mask of ASGTRGAF field.
	GPT320_GTICASR_ASGTRGAF_Msk = 0x2
	// Bit ASGTRGAF.
	GPT320_GTICASR_ASGTRGAF = 0x2
	// GTCCRA input capture disabled on the falling edge of GTETRGA input
	GPT320_GTICASR_ASGTRGAF_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTETRGA input
	GPT320_GTICASR_ASGTRGAF_1 = 0x1
	// Position of ASGTRGBR field.
	GPT320_GTICASR_ASGTRGBR_Pos = 0x2
	// Bit mask of ASGTRGBR field.
	GPT320_GTICASR_ASGTRGBR_Msk = 0x4
	// Bit ASGTRGBR.
	GPT320_GTICASR_ASGTRGBR = 0x4
	// GTCCRA input capture disabled on the rising edge of GTETRGB input
	GPT320_GTICASR_ASGTRGBR_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTETRGB input
	GPT320_GTICASR_ASGTRGBR_1 = 0x1
	// Position of ASGTRGBF field.
	GPT320_GTICASR_ASGTRGBF_Pos = 0x3
	// Bit mask of ASGTRGBF field.
	GPT320_GTICASR_ASGTRGBF_Msk = 0x8
	// Bit ASGTRGBF.
	GPT320_GTICASR_ASGTRGBF = 0x8
	// GTCCRA input capture disabled on the falling edge of GTETRGB input
	GPT320_GTICASR_ASGTRGBF_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTETRGB input
	GPT320_GTICASR_ASGTRGBF_1 = 0x1
	// Position of ASCARBL field.
	GPT320_GTICASR_ASCARBL_Pos = 0x8
	// Bit mask of ASCARBL field.
	GPT320_GTICASR_ASCARBL_Msk = 0x100
	// Bit ASCARBL.
	GPT320_GTICASR_ASCARBL = 0x100
	// GTCCRA input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTICASR_ASCARBL_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTICASR_ASCARBL_1 = 0x1
	// Position of ASCARBH field.
	GPT320_GTICASR_ASCARBH_Pos = 0x9
	// Bit mask of ASCARBH field.
	GPT320_GTICASR_ASCARBH_Msk = 0x200
	// Bit ASCARBH.
	GPT320_GTICASR_ASCARBH = 0x200
	// GTCCRA input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTICASR_ASCARBH_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTICASR_ASCARBH_1 = 0x1
	// Position of ASCAFBL field.
	GPT320_GTICASR_ASCAFBL_Pos = 0xa
	// Bit mask of ASCAFBL field.
	GPT320_GTICASR_ASCAFBL_Msk = 0x400
	// Bit ASCAFBL.
	GPT320_GTICASR_ASCAFBL = 0x400
	// GTCCRA input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTICASR_ASCAFBL_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTICASR_ASCAFBL_1 = 0x1
	// Position of ASCAFBH field.
	GPT320_GTICASR_ASCAFBH_Pos = 0xb
	// Bit mask of ASCAFBH field.
	GPT320_GTICASR_ASCAFBH_Msk = 0x800
	// Bit ASCAFBH.
	GPT320_GTICASR_ASCAFBH = 0x800
	// GTCCRA input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTICASR_ASCAFBH_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTICASR_ASCAFBH_1 = 0x1
	// Position of ASCBRAL field.
	GPT320_GTICASR_ASCBRAL_Pos = 0xc
	// Bit mask of ASCBRAL field.
	GPT320_GTICASR_ASCBRAL_Msk = 0x1000
	// Bit ASCBRAL.
	GPT320_GTICASR_ASCBRAL = 0x1000
	// GTCCRA input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTICASR_ASCBRAL_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTICASR_ASCBRAL_1 = 0x1
	// Position of ASCBRAH field.
	GPT320_GTICASR_ASCBRAH_Pos = 0xd
	// Bit mask of ASCBRAH field.
	GPT320_GTICASR_ASCBRAH_Msk = 0x2000
	// Bit ASCBRAH.
	GPT320_GTICASR_ASCBRAH = 0x2000
	// GTCCRA input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTICASR_ASCBRAH_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTICASR_ASCBRAH_1 = 0x1
	// Position of ASCBFAL field.
	GPT320_GTICASR_ASCBFAL_Pos = 0xe
	// Bit mask of ASCBFAL field.
	GPT320_GTICASR_ASCBFAL_Msk = 0x4000
	// Bit ASCBFAL.
	GPT320_GTICASR_ASCBFAL = 0x4000
	// GTCCRA input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTICASR_ASCBFAL_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTICASR_ASCBFAL_1 = 0x1
	// Position of ASCBFAH field.
	GPT320_GTICASR_ASCBFAH_Pos = 0xf
	// Bit mask of ASCBFAH field.
	GPT320_GTICASR_ASCBFAH_Msk = 0x8000
	// Bit ASCBFAH.
	GPT320_GTICASR_ASCBFAH = 0x8000
	// GTCCRA input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTICASR_ASCBFAH_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTICASR_ASCBFAH_1 = 0x1
	// Position of ASELCA field.
	GPT320_GTICASR_ASELCA_Pos = 0x10
	// Bit mask of ASELCA field.
	GPT320_GTICASR_ASELCA_Msk = 0x10000
	// Bit ASELCA.
	GPT320_GTICASR_ASELCA = 0x10000
	// GTCCRA input capture disabled at the ELC_GPTA input
	GPT320_GTICASR_ASELCA_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTA input
	GPT320_GTICASR_ASELCA_1 = 0x1
	// Position of ASELCB field.
	GPT320_GTICASR_ASELCB_Pos = 0x11
	// Bit mask of ASELCB field.
	GPT320_GTICASR_ASELCB_Msk = 0x20000
	// Bit ASELCB.
	GPT320_GTICASR_ASELCB = 0x20000
	// GTCCRA input capture disabled at the ELC_GPTB input
	GPT320_GTICASR_ASELCB_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTB input
	GPT320_GTICASR_ASELCB_1 = 0x1
	// Position of ASELCC field.
	GPT320_GTICASR_ASELCC_Pos = 0x12
	// Bit mask of ASELCC field.
	GPT320_GTICASR_ASELCC_Msk = 0x40000
	// Bit ASELCC.
	GPT320_GTICASR_ASELCC = 0x40000
	// GTCCRA input capture disabled at the ELC_GPTC input
	GPT320_GTICASR_ASELCC_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTC input
	GPT320_GTICASR_ASELCC_1 = 0x1
	// Position of ASELCD field.
	GPT320_GTICASR_ASELCD_Pos = 0x13
	// Bit mask of ASELCD field.
	GPT320_GTICASR_ASELCD_Msk = 0x80000
	// Bit ASELCD.
	GPT320_GTICASR_ASELCD = 0x80000
	// GTCCRA input capture disabled at the ELC_GPTD input
	GPT320_GTICASR_ASELCD_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTD input
	GPT320_GTICASR_ASELCD_1 = 0x1

	// GTICBSR: General PWM Timer Input Capture Source Select Register B
	// Position of BSGTRGAR field.
	GPT320_GTICBSR_BSGTRGAR_Pos = 0x0
	// Bit mask of BSGTRGAR field.
	GPT320_GTICBSR_BSGTRGAR_Msk = 0x1
	// Bit BSGTRGAR.
	GPT320_GTICBSR_BSGTRGAR = 0x1
	// GTCCRB input capture disabled on the rising edge of GTETRGA input
	GPT320_GTICBSR_BSGTRGAR_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTETRGA input
	GPT320_GTICBSR_BSGTRGAR_1 = 0x1
	// Position of BSGTRGAF field.
	GPT320_GTICBSR_BSGTRGAF_Pos = 0x1
	// Bit mask of BSGTRGAF field.
	GPT320_GTICBSR_BSGTRGAF_Msk = 0x2
	// Bit BSGTRGAF.
	GPT320_GTICBSR_BSGTRGAF = 0x2
	// GTCCRB input capture disabled on the falling edge of GTETRGA input
	GPT320_GTICBSR_BSGTRGAF_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTETRGA input
	GPT320_GTICBSR_BSGTRGAF_1 = 0x1
	// Position of BSGTRGBR field.
	GPT320_GTICBSR_BSGTRGBR_Pos = 0x2
	// Bit mask of BSGTRGBR field.
	GPT320_GTICBSR_BSGTRGBR_Msk = 0x4
	// Bit BSGTRGBR.
	GPT320_GTICBSR_BSGTRGBR = 0x4
	// GTCCRB input capture disabled on the rising edge of GTETRGB input
	GPT320_GTICBSR_BSGTRGBR_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTETRGB input
	GPT320_GTICBSR_BSGTRGBR_1 = 0x1
	// Position of BSGTRGBF field.
	GPT320_GTICBSR_BSGTRGBF_Pos = 0x3
	// Bit mask of BSGTRGBF field.
	GPT320_GTICBSR_BSGTRGBF_Msk = 0x8
	// Bit BSGTRGBF.
	GPT320_GTICBSR_BSGTRGBF = 0x8
	// GTCCRB input capture disabled on the falling edge of GTETRGB input
	GPT320_GTICBSR_BSGTRGBF_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTETRGB input
	GPT320_GTICBSR_BSGTRGBF_1 = 0x1
	// Position of BSCARBL field.
	GPT320_GTICBSR_BSCARBL_Pos = 0x8
	// Bit mask of BSCARBL field.
	GPT320_GTICBSR_BSCARBL_Msk = 0x100
	// Bit BSCARBL.
	GPT320_GTICBSR_BSCARBL = 0x100
	// GTCCRB input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTICBSR_BSCARBL_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTICBSR_BSCARBL_1 = 0x1
	// Position of BSCARBH field.
	GPT320_GTICBSR_BSCARBH_Pos = 0x9
	// Bit mask of BSCARBH field.
	GPT320_GTICBSR_BSCARBH_Msk = 0x200
	// Bit BSCARBH.
	GPT320_GTICBSR_BSCARBH = 0x200
	// GTCCRB input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTICBSR_BSCARBH_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTICBSR_BSCARBH_1 = 0x1
	// Position of BSCAFBL field.
	GPT320_GTICBSR_BSCAFBL_Pos = 0xa
	// Bit mask of BSCAFBL field.
	GPT320_GTICBSR_BSCAFBL_Msk = 0x400
	// Bit BSCAFBL.
	GPT320_GTICBSR_BSCAFBL = 0x400
	// GTCCRB input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTICBSR_BSCAFBL_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT320_GTICBSR_BSCAFBL_1 = 0x1
	// Position of BSCAFBH field.
	GPT320_GTICBSR_BSCAFBH_Pos = 0xb
	// Bit mask of BSCAFBH field.
	GPT320_GTICBSR_BSCAFBH_Msk = 0x800
	// Bit BSCAFBH.
	GPT320_GTICBSR_BSCAFBH = 0x800
	// GTCCRB input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTICBSR_BSCAFBH_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT320_GTICBSR_BSCAFBH_1 = 0x1
	// Position of BSCBRAL field.
	GPT320_GTICBSR_BSCBRAL_Pos = 0xc
	// Bit mask of BSCBRAL field.
	GPT320_GTICBSR_BSCBRAL_Msk = 0x1000
	// Bit BSCBRAL.
	GPT320_GTICBSR_BSCBRAL = 0x1000
	// GTCCRB input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTICBSR_BSCBRAL_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTICBSR_BSCBRAL_1 = 0x1
	// Position of BSCBRAH field.
	GPT320_GTICBSR_BSCBRAH_Pos = 0xd
	// Bit mask of BSCBRAH field.
	GPT320_GTICBSR_BSCBRAH_Msk = 0x2000
	// Bit BSCBRAH.
	GPT320_GTICBSR_BSCBRAH = 0x2000
	// GTCCRB input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTICBSR_BSCBRAH_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTICBSR_BSCBRAH_1 = 0x1
	// Position of BSCBFAL field.
	GPT320_GTICBSR_BSCBFAL_Pos = 0xe
	// Bit mask of BSCBFAL field.
	GPT320_GTICBSR_BSCBFAL_Msk = 0x4000
	// Bit BSCBFAL.
	GPT320_GTICBSR_BSCBFAL = 0x4000
	// GTCCRB input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTICBSR_BSCBFAL_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT320_GTICBSR_BSCBFAL_1 = 0x1
	// Position of BSCBFAH field.
	GPT320_GTICBSR_BSCBFAH_Pos = 0xf
	// Bit mask of BSCBFAH field.
	GPT320_GTICBSR_BSCBFAH_Msk = 0x8000
	// Bit BSCBFAH.
	GPT320_GTICBSR_BSCBFAH = 0x8000
	// GTCCRB input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTICBSR_BSCBFAH_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT320_GTICBSR_BSCBFAH_1 = 0x1
	// Position of BSELCA field.
	GPT320_GTICBSR_BSELCA_Pos = 0x10
	// Bit mask of BSELCA field.
	GPT320_GTICBSR_BSELCA_Msk = 0x10000
	// Bit BSELCA.
	GPT320_GTICBSR_BSELCA = 0x10000
	// GTCCRB input capture disabled at the ELC_GPTA input
	GPT320_GTICBSR_BSELCA_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTA input
	GPT320_GTICBSR_BSELCA_1 = 0x1
	// Position of BSELCB field.
	GPT320_GTICBSR_BSELCB_Pos = 0x11
	// Bit mask of BSELCB field.
	GPT320_GTICBSR_BSELCB_Msk = 0x20000
	// Bit BSELCB.
	GPT320_GTICBSR_BSELCB = 0x20000
	// GTCCRB input capture disabled at the ELC_GPTB input
	GPT320_GTICBSR_BSELCB_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTB input
	GPT320_GTICBSR_BSELCB_1 = 0x1
	// Position of BSELCC field.
	GPT320_GTICBSR_BSELCC_Pos = 0x12
	// Bit mask of BSELCC field.
	GPT320_GTICBSR_BSELCC_Msk = 0x40000
	// Bit BSELCC.
	GPT320_GTICBSR_BSELCC = 0x40000
	// GTCCRB input capture disabled at the ELC_GPTC input
	GPT320_GTICBSR_BSELCC_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTC input
	GPT320_GTICBSR_BSELCC_1 = 0x1
	// Position of BSELCD field.
	GPT320_GTICBSR_BSELCD_Pos = 0x13
	// Bit mask of BSELCD field.
	GPT320_GTICBSR_BSELCD_Msk = 0x80000
	// Bit BSELCD.
	GPT320_GTICBSR_BSELCD = 0x80000
	// GTCCRB input capture disabled at the ELC_GPTD input
	GPT320_GTICBSR_BSELCD_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTD input
	GPT320_GTICBSR_BSELCD_1 = 0x1

	// GTCR: General PWM Timer Control Register
	// Position of CST field.
	GPT320_GTCR_CST_Pos = 0x0
	// Bit mask of CST field.
	GPT320_GTCR_CST_Msk = 0x1
	// Bit CST.
	GPT320_GTCR_CST = 0x1
	// Count operation is stopped
	GPT320_GTCR_CST_0 = 0x0
	// Count operation is performed
	GPT320_GTCR_CST_1 = 0x1
	// Position of MD field.
	GPT320_GTCR_MD_Pos = 0x10
	// Bit mask of MD field.
	GPT320_GTCR_MD_Msk = 0x70000
	// Saw-wave PWM mode (single buffer or double buffer possible)
	GPT320_GTCR_MD_000 = 0x0
	// Saw-wave one-shot pulse mode (fixed buffer operation)
	GPT320_GTCR_MD_001 = 0x1
	// Setting prohibited
	GPT320_GTCR_MD_010 = 0x2
	// Setting prohibited
	GPT320_GTCR_MD_011 = 0x3
	// Triangle-wave PWM mode 1 (32-bit transfer at trough) (single buffer or double buffer is possible)
	GPT320_GTCR_MD_100 = 0x4
	// Triangle-wave PWM mode 2 (32-bit transfer at crest and trough) (single buffer or double buffer is possible)
	GPT320_GTCR_MD_101 = 0x5
	// Triangle-wave PWM mode 3 (64-bit transfer at trough) (fixed buffer operation)
	GPT320_GTCR_MD_110 = 0x6
	// Setting prohibited
	GPT320_GTCR_MD_111 = 0x7
	// Position of TPCS field.
	GPT320_GTCR_TPCS_Pos = 0x18
	// Bit mask of TPCS field.
	GPT320_GTCR_TPCS_Msk = 0x7000000
	// PCLKD/1
	GPT320_GTCR_TPCS_000 = 0x0
	// PCLKD/4
	GPT320_GTCR_TPCS_001 = 0x1
	// PCLKD/16
	GPT320_GTCR_TPCS_010 = 0x2
	// PCLKD/64
	GPT320_GTCR_TPCS_011 = 0x3
	// PCLKD/256
	GPT320_GTCR_TPCS_100 = 0x4
	// PCLKD/1024
	GPT320_GTCR_TPCS_101 = 0x5

	// GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
	// Position of UD field.
	GPT320_GTUDDTYC_UD_Pos = 0x0
	// Bit mask of UD field.
	GPT320_GTUDDTYC_UD_Msk = 0x1
	// Bit UD.
	GPT320_GTUDDTYC_UD = 0x1
	// GTCNT counts down
	GPT320_GTUDDTYC_UD_0 = 0x0
	// GTCNT counts up
	GPT320_GTUDDTYC_UD_1 = 0x1
	// Position of UDF field.
	GPT320_GTUDDTYC_UDF_Pos = 0x1
	// Bit mask of UDF field.
	GPT320_GTUDDTYC_UDF_Msk = 0x2
	// Bit UDF.
	GPT320_GTUDDTYC_UDF = 0x2
	// Not forcibly set
	GPT320_GTUDDTYC_UDF_0 = 0x0
	// Forcibly set
	GPT320_GTUDDTYC_UDF_1 = 0x1
	// Position of OADTY field.
	GPT320_GTUDDTYC_OADTY_Pos = 0x10
	// Bit mask of OADTY field.
	GPT320_GTUDDTYC_OADTY_Msk = 0x30000
	// GTIOCnA pin duty depends on the compare match
	GPT320_GTUDDTYC_OADTY_00 = 0x0
	// GTIOCnA pin duty depends on the compare match
	GPT320_GTUDDTYC_OADTY_01 = 0x1
	// GTIOCnA pin duty 0%
	GPT320_GTUDDTYC_OADTY_10 = 0x2
	// GTIOCnA pin duty 100%
	GPT320_GTUDDTYC_OADTY_11 = 0x3
	// Position of OADTYF field.
	GPT320_GTUDDTYC_OADTYF_Pos = 0x12
	// Bit mask of OADTYF field.
	GPT320_GTUDDTYC_OADTYF_Msk = 0x40000
	// Bit OADTYF.
	GPT320_GTUDDTYC_OADTYF = 0x40000
	// Not forcibly set
	GPT320_GTUDDTYC_OADTYF_0 = 0x0
	// Forcibly set
	GPT320_GTUDDTYC_OADTYF_1 = 0x1
	// Position of OADTYR field.
	GPT320_GTUDDTYC_OADTYR_Pos = 0x13
	// Bit mask of OADTYR field.
	GPT320_GTUDDTYC_OADTYR_Msk = 0x80000
	// Bit OADTYR.
	GPT320_GTUDDTYC_OADTYR = 0x80000
	// The function selected by the GTIOA[3:2] bits is applied to the output value when the duty cycle is set after release from the 0 or 100% duty-cycle setting.
	GPT320_GTUDDTYC_OADTYR_0 = 0x0
	// The function selected by the GTIOA[3:2] bits is applied to the compare match output value which is masked after release from the 0 or 100% duty-cycle setting.
	GPT320_GTUDDTYC_OADTYR_1 = 0x1
	// Position of OBDTY field.
	GPT320_GTUDDTYC_OBDTY_Pos = 0x18
	// Bit mask of OBDTY field.
	GPT320_GTUDDTYC_OBDTY_Msk = 0x3000000
	// GTIOCnB pin duty depends on the compare match
	GPT320_GTUDDTYC_OBDTY_00 = 0x0
	// GTIOCnB pin duty depends on the compare match
	GPT320_GTUDDTYC_OBDTY_01 = 0x1
	// GTIOCnB pin duty 0%
	GPT320_GTUDDTYC_OBDTY_10 = 0x2
	// GTIOCnB pin duty 100%
	GPT320_GTUDDTYC_OBDTY_11 = 0x3
	// Position of OBDTYF field.
	GPT320_GTUDDTYC_OBDTYF_Pos = 0x1a
	// Bit mask of OBDTYF field.
	GPT320_GTUDDTYC_OBDTYF_Msk = 0x4000000
	// Bit OBDTYF.
	GPT320_GTUDDTYC_OBDTYF = 0x4000000
	// Not forcibly set
	GPT320_GTUDDTYC_OBDTYF_0 = 0x0
	// Forcibly set
	GPT320_GTUDDTYC_OBDTYF_1 = 0x1
	// Position of OBDTYR field.
	GPT320_GTUDDTYC_OBDTYR_Pos = 0x1b
	// Bit mask of OBDTYR field.
	GPT320_GTUDDTYC_OBDTYR_Msk = 0x8000000
	// Bit OBDTYR.
	GPT320_GTUDDTYC_OBDTYR = 0x8000000
	// The function selected by the GTIOB[3:2] bits is applied to the output value when the duty cycle is set after release from the 0 or 100% duty-cycle setting.
	GPT320_GTUDDTYC_OBDTYR_0 = 0x0
	// The function selected by the GTIOB[3:2] bits is applied to the compare match output value which is masked after release from the 0 or 100% duty-cycle setting.
	GPT320_GTUDDTYC_OBDTYR_1 = 0x1

	// GTIOR: General PWM Timer I/O Control Register
	// Position of GTIOA field.
	GPT320_GTIOR_GTIOA_Pos = 0x0
	// Bit mask of GTIOA field.
	GPT320_GTIOR_GTIOA_Msk = 0x1f
	// Position of OADFLT field.
	GPT320_GTIOR_OADFLT_Pos = 0x6
	// Bit mask of OADFLT field.
	GPT320_GTIOR_OADFLT_Msk = 0x40
	// Bit OADFLT.
	GPT320_GTIOR_OADFLT = 0x40
	// The GTIOCnA pin outputs low when counting stops
	GPT320_GTIOR_OADFLT_0 = 0x0
	// The GTIOCnA pin outputs high when counting stops
	GPT320_GTIOR_OADFLT_1 = 0x1
	// Position of OAHLD field.
	GPT320_GTIOR_OAHLD_Pos = 0x7
	// Bit mask of OAHLD field.
	GPT320_GTIOR_OAHLD_Msk = 0x80
	// Bit OAHLD.
	GPT320_GTIOR_OAHLD = 0x80
	// The GTIOCnA pin output level at the start or stop of counting depends on the register setting
	GPT320_GTIOR_OAHLD_0 = 0x0
	// The GTIOCnA pin output level is retained at the start or stop of counting
	GPT320_GTIOR_OAHLD_1 = 0x1
	// Position of OAE field.
	GPT320_GTIOR_OAE_Pos = 0x8
	// Bit mask of OAE field.
	GPT320_GTIOR_OAE_Msk = 0x100
	// Bit OAE.
	GPT320_GTIOR_OAE = 0x100
	// Output is disabled
	GPT320_GTIOR_OAE_0 = 0x0
	// Output is enabled
	GPT320_GTIOR_OAE_1 = 0x1
	// Position of OADF field.
	GPT320_GTIOR_OADF_Pos = 0x9
	// Bit mask of OADF field.
	GPT320_GTIOR_OADF_Msk = 0x600
	// None of the below options are specified
	GPT320_GTIOR_OADF_00 = 0x0
	// GTIOCnA pin is set to Hi-Z in response to controlling the output negation
	GPT320_GTIOR_OADF_01 = 0x1
	// GTIOCnA pin is set to 0 in response to controlling the output negation
	GPT320_GTIOR_OADF_10 = 0x2
	// GTIOCnA pin is set to 1 in response to controlling the output negation
	GPT320_GTIOR_OADF_11 = 0x3
	// Position of NFAEN field.
	GPT320_GTIOR_NFAEN_Pos = 0xd
	// Bit mask of NFAEN field.
	GPT320_GTIOR_NFAEN_Msk = 0x2000
	// Bit NFAEN.
	GPT320_GTIOR_NFAEN = 0x2000
	// The noise filter for the GTIOCnA pin is disabled
	GPT320_GTIOR_NFAEN_0 = 0x0
	// The noise filter for the GTIOCnA pin is enabled
	GPT320_GTIOR_NFAEN_1 = 0x1
	// Position of NFCSA field.
	GPT320_GTIOR_NFCSA_Pos = 0xe
	// Bit mask of NFCSA field.
	GPT320_GTIOR_NFCSA_Msk = 0xc000
	// PCLKD/1
	GPT320_GTIOR_NFCSA_00 = 0x0
	// PCLKD/4
	GPT320_GTIOR_NFCSA_01 = 0x1
	// PCLKD/16
	GPT320_GTIOR_NFCSA_10 = 0x2
	// PCLKD/64
	GPT320_GTIOR_NFCSA_11 = 0x3
	// Position of GTIOB field.
	GPT320_GTIOR_GTIOB_Pos = 0x10
	// Bit mask of GTIOB field.
	GPT320_GTIOR_GTIOB_Msk = 0x1f0000
	// Position of OBDFLT field.
	GPT320_GTIOR_OBDFLT_Pos = 0x16
	// Bit mask of OBDFLT field.
	GPT320_GTIOR_OBDFLT_Msk = 0x400000
	// Bit OBDFLT.
	GPT320_GTIOR_OBDFLT = 0x400000
	// The GTIOCnB pin outputs low when counting stops
	GPT320_GTIOR_OBDFLT_0 = 0x0
	// The GTIOCnB pin outputs high when counting stops
	GPT320_GTIOR_OBDFLT_1 = 0x1
	// Position of OBHLD field.
	GPT320_GTIOR_OBHLD_Pos = 0x17
	// Bit mask of OBHLD field.
	GPT320_GTIOR_OBHLD_Msk = 0x800000
	// Bit OBHLD.
	GPT320_GTIOR_OBHLD = 0x800000
	// The GTIOCnB pin output level at the start/stop of counting depends on the register setting
	GPT320_GTIOR_OBHLD_0 = 0x0
	// The GTIOCnB pin output level is retained at the start/stop of counting
	GPT320_GTIOR_OBHLD_1 = 0x1
	// Position of OBE field.
	GPT320_GTIOR_OBE_Pos = 0x18
	// Bit mask of OBE field.
	GPT320_GTIOR_OBE_Msk = 0x1000000
	// Bit OBE.
	GPT320_GTIOR_OBE = 0x1000000
	// Output is disabled
	GPT320_GTIOR_OBE_0 = 0x0
	// Output is enabled
	GPT320_GTIOR_OBE_1 = 0x1
	// Position of OBDF field.
	GPT320_GTIOR_OBDF_Pos = 0x19
	// Bit mask of OBDF field.
	GPT320_GTIOR_OBDF_Msk = 0x6000000
	// None of the below options are specified
	GPT320_GTIOR_OBDF_00 = 0x0
	// GTIOCnB pin is set to Hi-Z in response to controlling the output negation
	GPT320_GTIOR_OBDF_01 = 0x1
	// GTIOCnB pin is set to 0 in response to controlling the output negation
	GPT320_GTIOR_OBDF_10 = 0x2
	// GTIOCnB pin is set to 1 in response to controlling the output negation
	GPT320_GTIOR_OBDF_11 = 0x3
	// Position of NFBEN field.
	GPT320_GTIOR_NFBEN_Pos = 0x1d
	// Bit mask of NFBEN field.
	GPT320_GTIOR_NFBEN_Msk = 0x20000000
	// Bit NFBEN.
	GPT320_GTIOR_NFBEN = 0x20000000
	// The noise filter for the GTIOCnB pin is disabled
	GPT320_GTIOR_NFBEN_0 = 0x0
	// The noise filter for the GTIOCnB pin is enabled
	GPT320_GTIOR_NFBEN_1 = 0x1
	// Position of NFCSB field.
	GPT320_GTIOR_NFCSB_Pos = 0x1e
	// Bit mask of NFCSB field.
	GPT320_GTIOR_NFCSB_Msk = 0xc0000000
	// PCLKD/1
	GPT320_GTIOR_NFCSB_00 = 0x0
	// PCLKD/4
	GPT320_GTIOR_NFCSB_01 = 0x1
	// PCLKD/16
	GPT320_GTIOR_NFCSB_10 = 0x2
	// PCLKD/64
	GPT320_GTIOR_NFCSB_11 = 0x3

	// GTINTAD: General PWM Timer Interrupt Output Setting Register
	// Position of GRP field.
	GPT320_GTINTAD_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT320_GTINTAD_GRP_Msk = 0x3000000
	// Group A output disable request is selected
	GPT320_GTINTAD_GRP_00 = 0x0
	// Group B output disable request is selected
	GPT320_GTINTAD_GRP_01 = 0x1
	// Position of GRPABH field.
	GPT320_GTINTAD_GRPABH_Pos = 0x1d
	// Bit mask of GRPABH field.
	GPT320_GTINTAD_GRPABH_Msk = 0x20000000
	// Bit GRPABH.
	GPT320_GTINTAD_GRPABH = 0x20000000
	// Same time output level high disable request disabled
	GPT320_GTINTAD_GRPABH_0 = 0x0
	// Same time output level high disable request enabled
	GPT320_GTINTAD_GRPABH_1 = 0x1
	// Position of GRPABL field.
	GPT320_GTINTAD_GRPABL_Pos = 0x1e
	// Bit mask of GRPABL field.
	GPT320_GTINTAD_GRPABL_Msk = 0x40000000
	// Bit GRPABL.
	GPT320_GTINTAD_GRPABL = 0x40000000
	// Same time output level low disable request disabled
	GPT320_GTINTAD_GRPABL_0 = 0x0
	// Same time output level low disable request enabled
	GPT320_GTINTAD_GRPABL_1 = 0x1

	// GTST: General PWM Timer Status Register
	// Position of TCFA field.
	GPT320_GTST_TCFA_Pos = 0x0
	// Bit mask of TCFA field.
	GPT320_GTST_TCFA_Msk = 0x1
	// Bit TCFA.
	GPT320_GTST_TCFA = 0x1
	// No input capture/compare match of GTCCRA is generated
	GPT320_GTST_TCFA_0 = 0x0
	// An input capture/compare match of GTCCRA is generated
	GPT320_GTST_TCFA_1 = 0x1
	// Position of TCFB field.
	GPT320_GTST_TCFB_Pos = 0x1
	// Bit mask of TCFB field.
	GPT320_GTST_TCFB_Msk = 0x2
	// Bit TCFB.
	GPT320_GTST_TCFB = 0x2
	// No input capture/compare match of GTCCRB is generated
	GPT320_GTST_TCFB_0 = 0x0
	// An input capture/compare match of GTCCRB is generated
	GPT320_GTST_TCFB_1 = 0x1
	// Position of TCFC field.
	GPT320_GTST_TCFC_Pos = 0x2
	// Bit mask of TCFC field.
	GPT320_GTST_TCFC_Msk = 0x4
	// Bit TCFC.
	GPT320_GTST_TCFC = 0x4
	// No compare match of GTCCRC is generated
	GPT320_GTST_TCFC_0 = 0x0
	// A compare match of GTCCRC is generated
	GPT320_GTST_TCFC_1 = 0x1
	// Position of TCFD field.
	GPT320_GTST_TCFD_Pos = 0x3
	// Bit mask of TCFD field.
	GPT320_GTST_TCFD_Msk = 0x8
	// Bit TCFD.
	GPT320_GTST_TCFD = 0x8
	// No compare match of GTCCRD is generated
	GPT320_GTST_TCFD_0 = 0x0
	// A compare match of GTCCRD is generated
	GPT320_GTST_TCFD_1 = 0x1
	// Position of TCFE field.
	GPT320_GTST_TCFE_Pos = 0x4
	// Bit mask of TCFE field.
	GPT320_GTST_TCFE_Msk = 0x10
	// Bit TCFE.
	GPT320_GTST_TCFE = 0x10
	// No compare match of GTCCRE is generated
	GPT320_GTST_TCFE_0 = 0x0
	// A compare match of GTCCRE is generated
	GPT320_GTST_TCFE_1 = 0x1
	// Position of TCFF field.
	GPT320_GTST_TCFF_Pos = 0x5
	// Bit mask of TCFF field.
	GPT320_GTST_TCFF_Msk = 0x20
	// Bit TCFF.
	GPT320_GTST_TCFF = 0x20
	// No compare match of GTCCRF is generated
	GPT320_GTST_TCFF_0 = 0x0
	// A compare match of GTCCRF is generated
	GPT320_GTST_TCFF_1 = 0x1
	// Position of TCFPO field.
	GPT320_GTST_TCFPO_Pos = 0x6
	// Bit mask of TCFPO field.
	GPT320_GTST_TCFPO_Msk = 0x40
	// Bit TCFPO.
	GPT320_GTST_TCFPO = 0x40
	// No overflow (crest) occurred
	GPT320_GTST_TCFPO_0 = 0x0
	// An overflow (crest) occurred
	GPT320_GTST_TCFPO_1 = 0x1
	// Position of TCFPU field.
	GPT320_GTST_TCFPU_Pos = 0x7
	// Bit mask of TCFPU field.
	GPT320_GTST_TCFPU_Msk = 0x80
	// Bit TCFPU.
	GPT320_GTST_TCFPU = 0x80
	// No underflow (trough) occurred
	GPT320_GTST_TCFPU_0 = 0x0
	// An underflow (trough) occurred
	GPT320_GTST_TCFPU_1 = 0x1
	// Position of TUCF field.
	GPT320_GTST_TUCF_Pos = 0xf
	// Bit mask of TUCF field.
	GPT320_GTST_TUCF_Msk = 0x8000
	// Bit TUCF.
	GPT320_GTST_TUCF = 0x8000
	// GTCNT counter counts downward
	GPT320_GTST_TUCF_0 = 0x0
	// GTCNT counter counts upward
	GPT320_GTST_TUCF_1 = 0x1
	// Position of ODF field.
	GPT320_GTST_ODF_Pos = 0x18
	// Bit mask of ODF field.
	GPT320_GTST_ODF_Msk = 0x1000000
	// Bit ODF.
	GPT320_GTST_ODF = 0x1000000
	// No output disable request is generated
	GPT320_GTST_ODF_0 = 0x0
	// An output disable request is generated
	GPT320_GTST_ODF_1 = 0x1
	// Position of OABHF field.
	GPT320_GTST_OABHF_Pos = 0x1d
	// Bit mask of OABHF field.
	GPT320_GTST_OABHF_Msk = 0x20000000
	// Bit OABHF.
	GPT320_GTST_OABHF = 0x20000000
	// No simultaneous generation of 1 both for the GTIOCA and GTIOCB pins has occurred.
	GPT320_GTST_OABHF_0 = 0x0
	// A simultaneous generation of 1 both for the GTIOCA and GTIOCB pins has occurred.
	GPT320_GTST_OABHF_1 = 0x1
	// Position of OABLF field.
	GPT320_GTST_OABLF_Pos = 0x1e
	// Bit mask of OABLF field.
	GPT320_GTST_OABLF_Msk = 0x40000000
	// Bit OABLF.
	GPT320_GTST_OABLF = 0x40000000
	// No simultaneous generation of 0 both for the GTIOCA and GTIOCB pins has occurred.
	GPT320_GTST_OABLF_0 = 0x0
	// A simultaneous generation of 0 both for the GTIOCA and GTIOCB pins has occurred.
	GPT320_GTST_OABLF_1 = 0x1

	// GTBER: General PWM Timer Buffer Enable Register
	// Position of BD0 field.
	GPT320_GTBER_BD0_Pos = 0x0
	// Bit mask of BD0 field.
	GPT320_GTBER_BD0_Msk = 0x1
	// Bit BD0.
	GPT320_GTBER_BD0 = 0x1
	// Buffer operation is enabled
	GPT320_GTBER_BD0_0 = 0x0
	// Buffer operation is disabled
	GPT320_GTBER_BD0_1 = 0x1
	// Position of BD1 field.
	GPT320_GTBER_BD1_Pos = 0x1
	// Bit mask of BD1 field.
	GPT320_GTBER_BD1_Msk = 0x2
	// Bit BD1.
	GPT320_GTBER_BD1 = 0x2
	// Buffer operation is enabled
	GPT320_GTBER_BD1_0 = 0x0
	// Buffer operation is disabled
	GPT320_GTBER_BD1_1 = 0x1
	// Position of CCRA field.
	GPT320_GTBER_CCRA_Pos = 0x10
	// Bit mask of CCRA field.
	GPT320_GTBER_CCRA_Msk = 0x30000
	// No buffer operation
	GPT320_GTBER_CCRA_00 = 0x0
	// Single buffer operation (GTCCRA <---->GTCCRC)
	GPT320_GTBER_CCRA_01 = 0x1
	// Position of CCRB field.
	GPT320_GTBER_CCRB_Pos = 0x12
	// Bit mask of CCRB field.
	GPT320_GTBER_CCRB_Msk = 0xc0000
	// No buffer operation
	GPT320_GTBER_CCRB_00 = 0x0
	// Single buffer operation (GTCCRB <----> GTCCRE)
	GPT320_GTBER_CCRB_01 = 0x1
	// Position of PR field.
	GPT320_GTBER_PR_Pos = 0x14
	// Bit mask of PR field.
	GPT320_GTBER_PR_Msk = 0x300000
	// No buffer operation
	GPT320_GTBER_PR_00 = 0x0
	// Single buffer operation (GTPBR --> GTPR)
	GPT320_GTBER_PR_01 = 0x1
	// Position of CCRSWT field.
	GPT320_GTBER_CCRSWT_Pos = 0x16
	// Bit mask of CCRSWT field.
	GPT320_GTBER_CCRSWT_Msk = 0x400000
	// Bit CCRSWT.
	GPT320_GTBER_CCRSWT = 0x400000

	// GTDTCR: General PWM Timer Dead Time Control Register
	// Position of TDE field.
	GPT320_GTDTCR_TDE_Pos = 0x0
	// Bit mask of TDE field.
	GPT320_GTDTCR_TDE_Msk = 0x1
	// Bit TDE.
	GPT320_GTDTCR_TDE = 0x1
	// GTCCRB is set without using GTDVU
	GPT320_GTDTCR_TDE_0 = 0x0
	// GTDVU is used to set the compare match value for negative-phase waveform with dead time automatically in GTCCRB
	GPT320_GTDTCR_TDE_1 = 0x1
)

// Constants for GPT164: General PWM 16-bit Timer 4
const (
	// GTWP: General PWM Timer Write-Protection Register
	// Position of WP field.
	GPT164_GTWP_WP_Pos = 0x0
	// Bit mask of WP field.
	GPT164_GTWP_WP_Msk = 0x1
	// Bit WP.
	GPT164_GTWP_WP = 0x1
	// Write to the register enabled
	GPT164_GTWP_WP_0 = 0x0
	// Write to the register disabled
	GPT164_GTWP_WP_1 = 0x1
	// Position of PRKEY field.
	GPT164_GTWP_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	GPT164_GTWP_PRKEY_Msk = 0xff00

	// GTSTR: General PWM Timer Software Start Register
	// Position of CSTRT0 field.
	GPT164_GTSTR_CSTRT0_Pos = 0x0
	// Bit mask of CSTRT0 field.
	GPT164_GTSTR_CSTRT0_Msk = 0x1
	// Bit CSTRT0.
	GPT164_GTSTR_CSTRT0 = 0x1
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT0_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT0_1 = 0x1
	// Position of CSTRT1 field.
	GPT164_GTSTR_CSTRT1_Pos = 0x1
	// Bit mask of CSTRT1 field.
	GPT164_GTSTR_CSTRT1_Msk = 0x2
	// Bit CSTRT1.
	GPT164_GTSTR_CSTRT1 = 0x2
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT1_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT1_1 = 0x1
	// Position of CSTRT2 field.
	GPT164_GTSTR_CSTRT2_Pos = 0x2
	// Bit mask of CSTRT2 field.
	GPT164_GTSTR_CSTRT2_Msk = 0x4
	// Bit CSTRT2.
	GPT164_GTSTR_CSTRT2 = 0x4
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT2_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT2_1 = 0x1
	// Position of CSTRT3 field.
	GPT164_GTSTR_CSTRT3_Pos = 0x3
	// Bit mask of CSTRT3 field.
	GPT164_GTSTR_CSTRT3_Msk = 0x8
	// Bit CSTRT3.
	GPT164_GTSTR_CSTRT3 = 0x8
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT3_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT3_1 = 0x1
	// Position of CSTRT4 field.
	GPT164_GTSTR_CSTRT4_Pos = 0x4
	// Bit mask of CSTRT4 field.
	GPT164_GTSTR_CSTRT4_Msk = 0x10
	// Bit CSTRT4.
	GPT164_GTSTR_CSTRT4 = 0x10
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT4_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT4_1 = 0x1
	// Position of CSTRT5 field.
	GPT164_GTSTR_CSTRT5_Pos = 0x5
	// Bit mask of CSTRT5 field.
	GPT164_GTSTR_CSTRT5_Msk = 0x20
	// Bit CSTRT5.
	GPT164_GTSTR_CSTRT5 = 0x20
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT5_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT5_1 = 0x1
	// Position of CSTRT6 field.
	GPT164_GTSTR_CSTRT6_Pos = 0x6
	// Bit mask of CSTRT6 field.
	GPT164_GTSTR_CSTRT6_Msk = 0x40
	// Bit CSTRT6.
	GPT164_GTSTR_CSTRT6 = 0x40
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT6_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT6_1 = 0x1
	// Position of CSTRT7 field.
	GPT164_GTSTR_CSTRT7_Pos = 0x7
	// Bit mask of CSTRT7 field.
	GPT164_GTSTR_CSTRT7_Msk = 0x80
	// Bit CSTRT7.
	GPT164_GTSTR_CSTRT7 = 0x80
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT7_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT7_1 = 0x1
	// Position of CSTRT8 field.
	GPT164_GTSTR_CSTRT8_Pos = 0x8
	// Bit mask of CSTRT8 field.
	GPT164_GTSTR_CSTRT8_Msk = 0x100
	// Bit CSTRT8.
	GPT164_GTSTR_CSTRT8 = 0x100
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT8_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT8_1 = 0x1
	// Position of CSTRT9 field.
	GPT164_GTSTR_CSTRT9_Pos = 0x9
	// Bit mask of CSTRT9 field.
	GPT164_GTSTR_CSTRT9_Msk = 0x200
	// Bit CSTRT9.
	GPT164_GTSTR_CSTRT9 = 0x200
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT9_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT9_1 = 0x1

	// GTSTP: General PWM Timer Software Stop Register
	// Position of CSTOP0 field.
	GPT164_GTSTP_CSTOP0_Pos = 0x0
	// Bit mask of CSTOP0 field.
	GPT164_GTSTP_CSTOP0_Msk = 0x1
	// Bit CSTOP0.
	GPT164_GTSTP_CSTOP0 = 0x1
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP0_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP0_1 = 0x1
	// Position of CSTOP1 field.
	GPT164_GTSTP_CSTOP1_Pos = 0x1
	// Bit mask of CSTOP1 field.
	GPT164_GTSTP_CSTOP1_Msk = 0x2
	// Bit CSTOP1.
	GPT164_GTSTP_CSTOP1 = 0x2
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP1_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP1_1 = 0x1
	// Position of CSTOP2 field.
	GPT164_GTSTP_CSTOP2_Pos = 0x2
	// Bit mask of CSTOP2 field.
	GPT164_GTSTP_CSTOP2_Msk = 0x4
	// Bit CSTOP2.
	GPT164_GTSTP_CSTOP2 = 0x4
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP2_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP2_1 = 0x1
	// Position of CSTOP3 field.
	GPT164_GTSTP_CSTOP3_Pos = 0x3
	// Bit mask of CSTOP3 field.
	GPT164_GTSTP_CSTOP3_Msk = 0x8
	// Bit CSTOP3.
	GPT164_GTSTP_CSTOP3 = 0x8
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP3_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP3_1 = 0x1
	// Position of CSTOP4 field.
	GPT164_GTSTP_CSTOP4_Pos = 0x4
	// Bit mask of CSTOP4 field.
	GPT164_GTSTP_CSTOP4_Msk = 0x10
	// Bit CSTOP4.
	GPT164_GTSTP_CSTOP4 = 0x10
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP4_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP4_1 = 0x1
	// Position of CSTOP5 field.
	GPT164_GTSTP_CSTOP5_Pos = 0x5
	// Bit mask of CSTOP5 field.
	GPT164_GTSTP_CSTOP5_Msk = 0x20
	// Bit CSTOP5.
	GPT164_GTSTP_CSTOP5 = 0x20
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP5_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP5_1 = 0x1
	// Position of CSTOP6 field.
	GPT164_GTSTP_CSTOP6_Pos = 0x6
	// Bit mask of CSTOP6 field.
	GPT164_GTSTP_CSTOP6_Msk = 0x40
	// Bit CSTOP6.
	GPT164_GTSTP_CSTOP6 = 0x40
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP6_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP6_1 = 0x1
	// Position of CSTOP7 field.
	GPT164_GTSTP_CSTOP7_Pos = 0x7
	// Bit mask of CSTOP7 field.
	GPT164_GTSTP_CSTOP7_Msk = 0x80
	// Bit CSTOP7.
	GPT164_GTSTP_CSTOP7 = 0x80
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP7_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP7_1 = 0x1
	// Position of CSTOP8 field.
	GPT164_GTSTP_CSTOP8_Pos = 0x8
	// Bit mask of CSTOP8 field.
	GPT164_GTSTP_CSTOP8_Msk = 0x100
	// Bit CSTOP8.
	GPT164_GTSTP_CSTOP8 = 0x100
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP8_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP8_1 = 0x1
	// Position of CSTOP9 field.
	GPT164_GTSTP_CSTOP9_Pos = 0x9
	// Bit mask of CSTOP9 field.
	GPT164_GTSTP_CSTOP9_Msk = 0x200
	// Bit CSTOP9.
	GPT164_GTSTP_CSTOP9 = 0x200
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP9_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP9_1 = 0x1

	// GTCLR: General PWM Timer Software Clear Register
	// Position of CCLR0 field.
	GPT164_GTCLR_CCLR0_Pos = 0x0
	// Bit mask of CCLR0 field.
	GPT164_GTCLR_CCLR0_Msk = 0x1
	// Bit CCLR0.
	GPT164_GTCLR_CCLR0 = 0x1
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR0_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR0_1 = 0x1
	// Position of CCLR1 field.
	GPT164_GTCLR_CCLR1_Pos = 0x1
	// Bit mask of CCLR1 field.
	GPT164_GTCLR_CCLR1_Msk = 0x2
	// Bit CCLR1.
	GPT164_GTCLR_CCLR1 = 0x2
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR1_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR1_1 = 0x1
	// Position of CCLR2 field.
	GPT164_GTCLR_CCLR2_Pos = 0x2
	// Bit mask of CCLR2 field.
	GPT164_GTCLR_CCLR2_Msk = 0x4
	// Bit CCLR2.
	GPT164_GTCLR_CCLR2 = 0x4
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR2_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR2_1 = 0x1
	// Position of CCLR3 field.
	GPT164_GTCLR_CCLR3_Pos = 0x3
	// Bit mask of CCLR3 field.
	GPT164_GTCLR_CCLR3_Msk = 0x8
	// Bit CCLR3.
	GPT164_GTCLR_CCLR3 = 0x8
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR3_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR3_1 = 0x1
	// Position of CCLR4 field.
	GPT164_GTCLR_CCLR4_Pos = 0x4
	// Bit mask of CCLR4 field.
	GPT164_GTCLR_CCLR4_Msk = 0x10
	// Bit CCLR4.
	GPT164_GTCLR_CCLR4 = 0x10
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR4_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR4_1 = 0x1
	// Position of CCLR5 field.
	GPT164_GTCLR_CCLR5_Pos = 0x5
	// Bit mask of CCLR5 field.
	GPT164_GTCLR_CCLR5_Msk = 0x20
	// Bit CCLR5.
	GPT164_GTCLR_CCLR5 = 0x20
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR5_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR5_1 = 0x1
	// Position of CCLR6 field.
	GPT164_GTCLR_CCLR6_Pos = 0x6
	// Bit mask of CCLR6 field.
	GPT164_GTCLR_CCLR6_Msk = 0x40
	// Bit CCLR6.
	GPT164_GTCLR_CCLR6 = 0x40
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR6_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR6_1 = 0x1
	// Position of CCLR7 field.
	GPT164_GTCLR_CCLR7_Pos = 0x7
	// Bit mask of CCLR7 field.
	GPT164_GTCLR_CCLR7_Msk = 0x80
	// Bit CCLR7.
	GPT164_GTCLR_CCLR7 = 0x80
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR7_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR7_1 = 0x1
	// Position of CCLR8 field.
	GPT164_GTCLR_CCLR8_Pos = 0x8
	// Bit mask of CCLR8 field.
	GPT164_GTCLR_CCLR8_Msk = 0x100
	// Bit CCLR8.
	GPT164_GTCLR_CCLR8 = 0x100
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR8_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR8_1 = 0x1
	// Position of CCLR9 field.
	GPT164_GTCLR_CCLR9_Pos = 0x9
	// Bit mask of CCLR9 field.
	GPT164_GTCLR_CCLR9_Msk = 0x200
	// Bit CCLR9.
	GPT164_GTCLR_CCLR9 = 0x200
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR9_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR9_1 = 0x1

	// GTSSR: General PWM Timer Start Source Select Register
	// Position of SSGTRGAR field.
	GPT164_GTSSR_SSGTRGAR_Pos = 0x0
	// Bit mask of SSGTRGAR field.
	GPT164_GTSSR_SSGTRGAR_Msk = 0x1
	// Bit SSGTRGAR.
	GPT164_GTSSR_SSGTRGAR = 0x1
	// Counter start disabled on the rising edge of GTETRGA input
	GPT164_GTSSR_SSGTRGAR_0 = 0x0
	// Counter start enabled on the rising edge of GTETRGA input
	GPT164_GTSSR_SSGTRGAR_1 = 0x1
	// Position of SSGTRGAF field.
	GPT164_GTSSR_SSGTRGAF_Pos = 0x1
	// Bit mask of SSGTRGAF field.
	GPT164_GTSSR_SSGTRGAF_Msk = 0x2
	// Bit SSGTRGAF.
	GPT164_GTSSR_SSGTRGAF = 0x2
	// Counter start disabled on the falling edge of GTETRGA input
	GPT164_GTSSR_SSGTRGAF_0 = 0x0
	// Counter start enabled on the falling edge of GTETRGA input
	GPT164_GTSSR_SSGTRGAF_1 = 0x1
	// Position of SSGTRGBR field.
	GPT164_GTSSR_SSGTRGBR_Pos = 0x2
	// Bit mask of SSGTRGBR field.
	GPT164_GTSSR_SSGTRGBR_Msk = 0x4
	// Bit SSGTRGBR.
	GPT164_GTSSR_SSGTRGBR = 0x4
	// Counter start disabled on the rising edge of GTETRGB input
	GPT164_GTSSR_SSGTRGBR_0 = 0x0
	// Counter start enabled on the rising edge of GTETRGB input
	GPT164_GTSSR_SSGTRGBR_1 = 0x1
	// Position of SSGTRGBF field.
	GPT164_GTSSR_SSGTRGBF_Pos = 0x3
	// Bit mask of SSGTRGBF field.
	GPT164_GTSSR_SSGTRGBF_Msk = 0x8
	// Bit SSGTRGBF.
	GPT164_GTSSR_SSGTRGBF = 0x8
	// Counter start disabled on the falling edge of GTETRGB input
	GPT164_GTSSR_SSGTRGBF_0 = 0x0
	// Counter start enabled on the falling edge of GTETRGB input
	GPT164_GTSSR_SSGTRGBF_1 = 0x1
	// Position of SSCARBL field.
	GPT164_GTSSR_SSCARBL_Pos = 0x8
	// Bit mask of SSCARBL field.
	GPT164_GTSSR_SSCARBL_Msk = 0x100
	// Bit SSCARBL.
	GPT164_GTSSR_SSCARBL = 0x100
	// Counter start disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTSSR_SSCARBL_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTSSR_SSCARBL_1 = 0x1
	// Position of SSCARBH field.
	GPT164_GTSSR_SSCARBH_Pos = 0x9
	// Bit mask of SSCARBH field.
	GPT164_GTSSR_SSCARBH_Msk = 0x200
	// Bit SSCARBH.
	GPT164_GTSSR_SSCARBH = 0x200
	// Counter start disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTSSR_SSCARBH_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTSSR_SSCARBH_1 = 0x1
	// Position of SSCAFBL field.
	GPT164_GTSSR_SSCAFBL_Pos = 0xa
	// Bit mask of SSCAFBL field.
	GPT164_GTSSR_SSCAFBL_Msk = 0x400
	// Bit SSCAFBL.
	GPT164_GTSSR_SSCAFBL = 0x400
	// Counter start disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTSSR_SSCAFBL_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTSSR_SSCAFBL_1 = 0x1
	// Position of SSCAFBH field.
	GPT164_GTSSR_SSCAFBH_Pos = 0xb
	// Bit mask of SSCAFBH field.
	GPT164_GTSSR_SSCAFBH_Msk = 0x800
	// Bit SSCAFBH.
	GPT164_GTSSR_SSCAFBH = 0x800
	// Counter start disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTSSR_SSCAFBH_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTSSR_SSCAFBH_1 = 0x1
	// Position of SSCBRAL field.
	GPT164_GTSSR_SSCBRAL_Pos = 0xc
	// Bit mask of SSCBRAL field.
	GPT164_GTSSR_SSCBRAL_Msk = 0x1000
	// Bit SSCBRAL.
	GPT164_GTSSR_SSCBRAL = 0x1000
	// Counter start disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTSSR_SSCBRAL_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTSSR_SSCBRAL_1 = 0x1
	// Position of SSCBRAH field.
	GPT164_GTSSR_SSCBRAH_Pos = 0xd
	// Bit mask of SSCBRAH field.
	GPT164_GTSSR_SSCBRAH_Msk = 0x2000
	// Bit SSCBRAH.
	GPT164_GTSSR_SSCBRAH = 0x2000
	// Counter start disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTSSR_SSCBRAH_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTSSR_SSCBRAH_1 = 0x1
	// Position of SSCBFAL field.
	GPT164_GTSSR_SSCBFAL_Pos = 0xe
	// Bit mask of SSCBFAL field.
	GPT164_GTSSR_SSCBFAL_Msk = 0x4000
	// Bit SSCBFAL.
	GPT164_GTSSR_SSCBFAL = 0x4000
	// Counter start disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTSSR_SSCBFAL_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTSSR_SSCBFAL_1 = 0x1
	// Position of SSCBFAH field.
	GPT164_GTSSR_SSCBFAH_Pos = 0xf
	// Bit mask of SSCBFAH field.
	GPT164_GTSSR_SSCBFAH_Msk = 0x8000
	// Bit SSCBFAH.
	GPT164_GTSSR_SSCBFAH = 0x8000
	// Counter start disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTSSR_SSCBFAH_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTSSR_SSCBFAH_1 = 0x1
	// Position of SSELCA field.
	GPT164_GTSSR_SSELCA_Pos = 0x10
	// Bit mask of SSELCA field.
	GPT164_GTSSR_SSELCA_Msk = 0x10000
	// Bit SSELCA.
	GPT164_GTSSR_SSELCA = 0x10000
	// Counter start disabled at the ELC_GPTA input
	GPT164_GTSSR_SSELCA_0 = 0x0
	// Counter start enabled at the ELC_GPTA input
	GPT164_GTSSR_SSELCA_1 = 0x1
	// Position of SSELCB field.
	GPT164_GTSSR_SSELCB_Pos = 0x11
	// Bit mask of SSELCB field.
	GPT164_GTSSR_SSELCB_Msk = 0x20000
	// Bit SSELCB.
	GPT164_GTSSR_SSELCB = 0x20000
	// Counter start disabled at the ELC_GPTB input
	GPT164_GTSSR_SSELCB_0 = 0x0
	// Counter start enabled at the ELC_GPTB input
	GPT164_GTSSR_SSELCB_1 = 0x1
	// Position of SSELCC field.
	GPT164_GTSSR_SSELCC_Pos = 0x12
	// Bit mask of SSELCC field.
	GPT164_GTSSR_SSELCC_Msk = 0x40000
	// Bit SSELCC.
	GPT164_GTSSR_SSELCC = 0x40000
	// Counter start disabled at the ELC_GPTC input
	GPT164_GTSSR_SSELCC_0 = 0x0
	// Counter start enabled at the ELC_GPTC input
	GPT164_GTSSR_SSELCC_1 = 0x1
	// Position of SSELCD field.
	GPT164_GTSSR_SSELCD_Pos = 0x13
	// Bit mask of SSELCD field.
	GPT164_GTSSR_SSELCD_Msk = 0x80000
	// Bit SSELCD.
	GPT164_GTSSR_SSELCD = 0x80000
	// Counter start disabled at the ELC_GPTD input
	GPT164_GTSSR_SSELCD_0 = 0x0
	// Counter start enabled at the ELC_GPTD input
	GPT164_GTSSR_SSELCD_1 = 0x1
	// Position of CSTRT field.
	GPT164_GTSSR_CSTRT_Pos = 0x1f
	// Bit mask of CSTRT field.
	GPT164_GTSSR_CSTRT_Msk = 0x80000000
	// Bit CSTRT.
	GPT164_GTSSR_CSTRT = 0x80000000
	// Counter start disabled by the GTSTR register
	GPT164_GTSSR_CSTRT_0 = 0x0
	// Counter start enabled by the GTSTR register
	GPT164_GTSSR_CSTRT_1 = 0x1

	// GTPSR: General PWM Timer Stop Source Select Register
	// Position of PSGTRGAR field.
	GPT164_GTPSR_PSGTRGAR_Pos = 0x0
	// Bit mask of PSGTRGAR field.
	GPT164_GTPSR_PSGTRGAR_Msk = 0x1
	// Bit PSGTRGAR.
	GPT164_GTPSR_PSGTRGAR = 0x1
	// Counter stop disabled on the rising edge of GTETRGA input
	GPT164_GTPSR_PSGTRGAR_0 = 0x0
	// Counter stop enabled on the rising edge of GTETRGA input
	GPT164_GTPSR_PSGTRGAR_1 = 0x1
	// Position of PSGTRGAF field.
	GPT164_GTPSR_PSGTRGAF_Pos = 0x1
	// Bit mask of PSGTRGAF field.
	GPT164_GTPSR_PSGTRGAF_Msk = 0x2
	// Bit PSGTRGAF.
	GPT164_GTPSR_PSGTRGAF = 0x2
	// Counter stop disabled on the falling edge of GTETRGA input
	GPT164_GTPSR_PSGTRGAF_0 = 0x0
	// Counter stop enabled on the falling edge of GTETRGA input
	GPT164_GTPSR_PSGTRGAF_1 = 0x1
	// Position of PSGTRGBR field.
	GPT164_GTPSR_PSGTRGBR_Pos = 0x2
	// Bit mask of PSGTRGBR field.
	GPT164_GTPSR_PSGTRGBR_Msk = 0x4
	// Bit PSGTRGBR.
	GPT164_GTPSR_PSGTRGBR = 0x4
	// Counter stop disabled on the rising edge of GTETRGB input
	GPT164_GTPSR_PSGTRGBR_0 = 0x0
	// Counter stop enabled on the rising edge of GTETRGB input
	GPT164_GTPSR_PSGTRGBR_1 = 0x1
	// Position of PSGTRGBF field.
	GPT164_GTPSR_PSGTRGBF_Pos = 0x3
	// Bit mask of PSGTRGBF field.
	GPT164_GTPSR_PSGTRGBF_Msk = 0x8
	// Bit PSGTRGBF.
	GPT164_GTPSR_PSGTRGBF = 0x8
	// Counter stop disabled on the falling edge of GTETRGB input
	GPT164_GTPSR_PSGTRGBF_0 = 0x0
	// Counter stop enabled on the falling edge of GTETRGB input
	GPT164_GTPSR_PSGTRGBF_1 = 0x1
	// Position of PSCARBL field.
	GPT164_GTPSR_PSCARBL_Pos = 0x8
	// Bit mask of PSCARBL field.
	GPT164_GTPSR_PSCARBL_Msk = 0x100
	// Bit PSCARBL.
	GPT164_GTPSR_PSCARBL = 0x100
	// Counter stop disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTPSR_PSCARBL_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTPSR_PSCARBL_1 = 0x1
	// Position of PSCARBH field.
	GPT164_GTPSR_PSCARBH_Pos = 0x9
	// Bit mask of PSCARBH field.
	GPT164_GTPSR_PSCARBH_Msk = 0x200
	// Bit PSCARBH.
	GPT164_GTPSR_PSCARBH = 0x200
	// Counter stop disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTPSR_PSCARBH_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTPSR_PSCARBH_1 = 0x1
	// Position of PSCAFBL field.
	GPT164_GTPSR_PSCAFBL_Pos = 0xa
	// Bit mask of PSCAFBL field.
	GPT164_GTPSR_PSCAFBL_Msk = 0x400
	// Bit PSCAFBL.
	GPT164_GTPSR_PSCAFBL = 0x400
	// Counter stop disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTPSR_PSCAFBL_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTPSR_PSCAFBL_1 = 0x1
	// Position of PSCAFBH field.
	GPT164_GTPSR_PSCAFBH_Pos = 0xb
	// Bit mask of PSCAFBH field.
	GPT164_GTPSR_PSCAFBH_Msk = 0x800
	// Bit PSCAFBH.
	GPT164_GTPSR_PSCAFBH = 0x800
	// Counter stop disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTPSR_PSCAFBH_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTPSR_PSCAFBH_1 = 0x1
	// Position of PSCBRAL field.
	GPT164_GTPSR_PSCBRAL_Pos = 0xc
	// Bit mask of PSCBRAL field.
	GPT164_GTPSR_PSCBRAL_Msk = 0x1000
	// Bit PSCBRAL.
	GPT164_GTPSR_PSCBRAL = 0x1000
	// Counter stop disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTPSR_PSCBRAL_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTPSR_PSCBRAL_1 = 0x1
	// Position of PSCBRAH field.
	GPT164_GTPSR_PSCBRAH_Pos = 0xd
	// Bit mask of PSCBRAH field.
	GPT164_GTPSR_PSCBRAH_Msk = 0x2000
	// Bit PSCBRAH.
	GPT164_GTPSR_PSCBRAH = 0x2000
	// Counter stop disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTPSR_PSCBRAH_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTPSR_PSCBRAH_1 = 0x1
	// Position of PSCBFAL field.
	GPT164_GTPSR_PSCBFAL_Pos = 0xe
	// Bit mask of PSCBFAL field.
	GPT164_GTPSR_PSCBFAL_Msk = 0x4000
	// Bit PSCBFAL.
	GPT164_GTPSR_PSCBFAL = 0x4000
	// Counter stop disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTPSR_PSCBFAL_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTPSR_PSCBFAL_1 = 0x1
	// Position of PSCBFAH field.
	GPT164_GTPSR_PSCBFAH_Pos = 0xf
	// Bit mask of PSCBFAH field.
	GPT164_GTPSR_PSCBFAH_Msk = 0x8000
	// Bit PSCBFAH.
	GPT164_GTPSR_PSCBFAH = 0x8000
	// Counter stop disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTPSR_PSCBFAH_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTPSR_PSCBFAH_1 = 0x1
	// Position of PSELCA field.
	GPT164_GTPSR_PSELCA_Pos = 0x10
	// Bit mask of PSELCA field.
	GPT164_GTPSR_PSELCA_Msk = 0x10000
	// Bit PSELCA.
	GPT164_GTPSR_PSELCA = 0x10000
	// Counter stop disabled at the ELC_GPTA input
	GPT164_GTPSR_PSELCA_0 = 0x0
	// Counter stop enabled at the ELC_GPTA input
	GPT164_GTPSR_PSELCA_1 = 0x1
	// Position of PSELCB field.
	GPT164_GTPSR_PSELCB_Pos = 0x11
	// Bit mask of PSELCB field.
	GPT164_GTPSR_PSELCB_Msk = 0x20000
	// Bit PSELCB.
	GPT164_GTPSR_PSELCB = 0x20000
	// Counter stop disabled at the ELC_GPTB input
	GPT164_GTPSR_PSELCB_0 = 0x0
	// Counter stop enabled at the ELC_GPTB input
	GPT164_GTPSR_PSELCB_1 = 0x1
	// Position of PSELCC field.
	GPT164_GTPSR_PSELCC_Pos = 0x12
	// Bit mask of PSELCC field.
	GPT164_GTPSR_PSELCC_Msk = 0x40000
	// Bit PSELCC.
	GPT164_GTPSR_PSELCC = 0x40000
	// Counter stop disabled at the ELC_GPTC input
	GPT164_GTPSR_PSELCC_0 = 0x0
	// Counter stop enabled at the ELC_GPTC input
	GPT164_GTPSR_PSELCC_1 = 0x1
	// Position of PSELCD field.
	GPT164_GTPSR_PSELCD_Pos = 0x13
	// Bit mask of PSELCD field.
	GPT164_GTPSR_PSELCD_Msk = 0x80000
	// Bit PSELCD.
	GPT164_GTPSR_PSELCD = 0x80000
	// Counter stop disabled at the ELC_GPTD input
	GPT164_GTPSR_PSELCD_0 = 0x0
	// Counter stop enabled at the ELC_GPTD input
	GPT164_GTPSR_PSELCD_1 = 0x1
	// Position of CSTOP field.
	GPT164_GTPSR_CSTOP_Pos = 0x1f
	// Bit mask of CSTOP field.
	GPT164_GTPSR_CSTOP_Msk = 0x80000000
	// Bit CSTOP.
	GPT164_GTPSR_CSTOP = 0x80000000
	// Counter stop disabled by the GTSTP register
	GPT164_GTPSR_CSTOP_0 = 0x0
	// Counter stop enabled by the GTSTP register
	GPT164_GTPSR_CSTOP_1 = 0x1

	// GTCSR: General PWM Timer Clear Source Select Register
	// Position of CSGTRGAR field.
	GPT164_GTCSR_CSGTRGAR_Pos = 0x0
	// Bit mask of CSGTRGAR field.
	GPT164_GTCSR_CSGTRGAR_Msk = 0x1
	// Bit CSGTRGAR.
	GPT164_GTCSR_CSGTRGAR = 0x1
	// Counter clear disabled on the rising edge of GTETRGA input
	GPT164_GTCSR_CSGTRGAR_0 = 0x0
	// Counter clear enabled on the rising edge of GTETRGA input
	GPT164_GTCSR_CSGTRGAR_1 = 0x1
	// Position of CSGTRGAF field.
	GPT164_GTCSR_CSGTRGAF_Pos = 0x1
	// Bit mask of CSGTRGAF field.
	GPT164_GTCSR_CSGTRGAF_Msk = 0x2
	// Bit CSGTRGAF.
	GPT164_GTCSR_CSGTRGAF = 0x2
	// Counter clear disabled on the falling edge of GTETRGA input
	GPT164_GTCSR_CSGTRGAF_0 = 0x0
	// Counter clear enabled on the falling edge of GTETRGA input
	GPT164_GTCSR_CSGTRGAF_1 = 0x1
	// Position of CSGTRGBR field.
	GPT164_GTCSR_CSGTRGBR_Pos = 0x2
	// Bit mask of CSGTRGBR field.
	GPT164_GTCSR_CSGTRGBR_Msk = 0x4
	// Bit CSGTRGBR.
	GPT164_GTCSR_CSGTRGBR = 0x4
	// Disable counter clear on the rising edge of GTETRGB input
	GPT164_GTCSR_CSGTRGBR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGB input
	GPT164_GTCSR_CSGTRGBR_1 = 0x1
	// Position of CSGTRGBF field.
	GPT164_GTCSR_CSGTRGBF_Pos = 0x3
	// Bit mask of CSGTRGBF field.
	GPT164_GTCSR_CSGTRGBF_Msk = 0x8
	// Bit CSGTRGBF.
	GPT164_GTCSR_CSGTRGBF = 0x8
	// Counter clear disabled on the falling edge of GTETRGB input
	GPT164_GTCSR_CSGTRGBF_0 = 0x0
	// Counter clear enabled on the falling edge of GTETRGB input
	GPT164_GTCSR_CSGTRGBF_1 = 0x1
	// Position of CSCARBL field.
	GPT164_GTCSR_CSCARBL_Pos = 0x8
	// Bit mask of CSCARBL field.
	GPT164_GTCSR_CSCARBL_Msk = 0x100
	// Bit CSCARBL.
	GPT164_GTCSR_CSCARBL = 0x100
	// Counter clear disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTCSR_CSCARBL_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTCSR_CSCARBL_1 = 0x1
	// Position of CSCARBH field.
	GPT164_GTCSR_CSCARBH_Pos = 0x9
	// Bit mask of CSCARBH field.
	GPT164_GTCSR_CSCARBH_Msk = 0x200
	// Bit CSCARBH.
	GPT164_GTCSR_CSCARBH = 0x200
	// Counter clear disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTCSR_CSCARBH_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTCSR_CSCARBH_1 = 0x1
	// Position of CSCAFBL field.
	GPT164_GTCSR_CSCAFBL_Pos = 0xa
	// Bit mask of CSCAFBL field.
	GPT164_GTCSR_CSCAFBL_Msk = 0x400
	// Bit CSCAFBL.
	GPT164_GTCSR_CSCAFBL = 0x400
	// Counter clear disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTCSR_CSCAFBL_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTCSR_CSCAFBL_1 = 0x1
	// Position of CSCAFBH field.
	GPT164_GTCSR_CSCAFBH_Pos = 0xb
	// Bit mask of CSCAFBH field.
	GPT164_GTCSR_CSCAFBH_Msk = 0x800
	// Bit CSCAFBH.
	GPT164_GTCSR_CSCAFBH = 0x800
	// Counter clear disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTCSR_CSCAFBH_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTCSR_CSCAFBH_1 = 0x1
	// Position of CSCBRAL field.
	GPT164_GTCSR_CSCBRAL_Pos = 0xc
	// Bit mask of CSCBRAL field.
	GPT164_GTCSR_CSCBRAL_Msk = 0x1000
	// Bit CSCBRAL.
	GPT164_GTCSR_CSCBRAL = 0x1000
	// Counter clear disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTCSR_CSCBRAL_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTCSR_CSCBRAL_1 = 0x1
	// Position of CSCBRAH field.
	GPT164_GTCSR_CSCBRAH_Pos = 0xd
	// Bit mask of CSCBRAH field.
	GPT164_GTCSR_CSCBRAH_Msk = 0x2000
	// Bit CSCBRAH.
	GPT164_GTCSR_CSCBRAH = 0x2000
	// Counter clear disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTCSR_CSCBRAH_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTCSR_CSCBRAH_1 = 0x1
	// Position of CSCBFAL field.
	GPT164_GTCSR_CSCBFAL_Pos = 0xe
	// Bit mask of CSCBFAL field.
	GPT164_GTCSR_CSCBFAL_Msk = 0x4000
	// Bit CSCBFAL.
	GPT164_GTCSR_CSCBFAL = 0x4000
	// Counter clear disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTCSR_CSCBFAL_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTCSR_CSCBFAL_1 = 0x1
	// Position of CSCBFAH field.
	GPT164_GTCSR_CSCBFAH_Pos = 0xf
	// Bit mask of CSCBFAH field.
	GPT164_GTCSR_CSCBFAH_Msk = 0x8000
	// Bit CSCBFAH.
	GPT164_GTCSR_CSCBFAH = 0x8000
	// Counter clear disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTCSR_CSCBFAH_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTCSR_CSCBFAH_1 = 0x1
	// Position of CSELCA field.
	GPT164_GTCSR_CSELCA_Pos = 0x10
	// Bit mask of CSELCA field.
	GPT164_GTCSR_CSELCA_Msk = 0x10000
	// Bit CSELCA.
	GPT164_GTCSR_CSELCA = 0x10000
	// Counter clear disabled at the ELC_GPTA input
	GPT164_GTCSR_CSELCA_0 = 0x0
	// Counter clear enabled at the ELC_GPTA input
	GPT164_GTCSR_CSELCA_1 = 0x1
	// Position of CSELCB field.
	GPT164_GTCSR_CSELCB_Pos = 0x11
	// Bit mask of CSELCB field.
	GPT164_GTCSR_CSELCB_Msk = 0x20000
	// Bit CSELCB.
	GPT164_GTCSR_CSELCB = 0x20000
	// Counter clear disabled at the ELC_GPTB input
	GPT164_GTCSR_CSELCB_0 = 0x0
	// Counter clear enabled at the ELC_GPTB input
	GPT164_GTCSR_CSELCB_1 = 0x1
	// Position of CSELCC field.
	GPT164_GTCSR_CSELCC_Pos = 0x12
	// Bit mask of CSELCC field.
	GPT164_GTCSR_CSELCC_Msk = 0x40000
	// Bit CSELCC.
	GPT164_GTCSR_CSELCC = 0x40000
	// Counter clear disabled at the ELC_GPTC input
	GPT164_GTCSR_CSELCC_0 = 0x0
	// Counter clear enabled at the ELC_GPTC input
	GPT164_GTCSR_CSELCC_1 = 0x1
	// Position of CSELCD field.
	GPT164_GTCSR_CSELCD_Pos = 0x13
	// Bit mask of CSELCD field.
	GPT164_GTCSR_CSELCD_Msk = 0x80000
	// Bit CSELCD.
	GPT164_GTCSR_CSELCD = 0x80000
	// Counter clear disabled at the ELC_GPTD input
	GPT164_GTCSR_CSELCD_0 = 0x0
	// Counter clear enabled at the ELC_GPTD input
	GPT164_GTCSR_CSELCD_1 = 0x1
	// Position of CCLR field.
	GPT164_GTCSR_CCLR_Pos = 0x1f
	// Bit mask of CCLR field.
	GPT164_GTCSR_CCLR_Msk = 0x80000000
	// Bit CCLR.
	GPT164_GTCSR_CCLR = 0x80000000
	// Counter clear disabled by the GTCLR register
	GPT164_GTCSR_CCLR_0 = 0x0
	// Counter clear enabled by the GTCLR register
	GPT164_GTCSR_CCLR_1 = 0x1

	// GTUPSR: General PWM Timer Up Count Source Select Register
	// Position of USGTRGAR field.
	GPT164_GTUPSR_USGTRGAR_Pos = 0x0
	// Bit mask of USGTRGAR field.
	GPT164_GTUPSR_USGTRGAR_Msk = 0x1
	// Bit USGTRGAR.
	GPT164_GTUPSR_USGTRGAR = 0x1
	// Counter count up disabled on the rising edge of GTETRGA input
	GPT164_GTUPSR_USGTRGAR_0 = 0x0
	// Counter count up enabled on the rising edge of GTETRGA input
	GPT164_GTUPSR_USGTRGAR_1 = 0x1
	// Position of USGTRGAF field.
	GPT164_GTUPSR_USGTRGAF_Pos = 0x1
	// Bit mask of USGTRGAF field.
	GPT164_GTUPSR_USGTRGAF_Msk = 0x2
	// Bit USGTRGAF.
	GPT164_GTUPSR_USGTRGAF = 0x2
	// Counter count up disabled on the falling edge of GTETRGA input
	GPT164_GTUPSR_USGTRGAF_0 = 0x0
	// Counter count up enabled on the falling edge of GTETRGA input
	GPT164_GTUPSR_USGTRGAF_1 = 0x1
	// Position of USGTRGBR field.
	GPT164_GTUPSR_USGTRGBR_Pos = 0x2
	// Bit mask of USGTRGBR field.
	GPT164_GTUPSR_USGTRGBR_Msk = 0x4
	// Bit USGTRGBR.
	GPT164_GTUPSR_USGTRGBR = 0x4
	// Counter count up disabled on the rising edge of GTETRGB input
	GPT164_GTUPSR_USGTRGBR_0 = 0x0
	// Counter count up enabled on the rising edge of GTETRGB input
	GPT164_GTUPSR_USGTRGBR_1 = 0x1
	// Position of USGTRGBF field.
	GPT164_GTUPSR_USGTRGBF_Pos = 0x3
	// Bit mask of USGTRGBF field.
	GPT164_GTUPSR_USGTRGBF_Msk = 0x8
	// Bit USGTRGBF.
	GPT164_GTUPSR_USGTRGBF = 0x8
	// Counter count up disabled on the falling edge of GTETRGB input
	GPT164_GTUPSR_USGTRGBF_0 = 0x0
	// Counter count up enabled on the falling edge of GTETRGB input
	GPT164_GTUPSR_USGTRGBF_1 = 0x1
	// Position of USCARBL field.
	GPT164_GTUPSR_USCARBL_Pos = 0x8
	// Bit mask of USCARBL field.
	GPT164_GTUPSR_USCARBL_Msk = 0x100
	// Bit USCARBL.
	GPT164_GTUPSR_USCARBL = 0x100
	// Counter count up disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTUPSR_USCARBL_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTUPSR_USCARBL_1 = 0x1
	// Position of USCARBH field.
	GPT164_GTUPSR_USCARBH_Pos = 0x9
	// Bit mask of USCARBH field.
	GPT164_GTUPSR_USCARBH_Msk = 0x200
	// Bit USCARBH.
	GPT164_GTUPSR_USCARBH = 0x200
	// Counter count up disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTUPSR_USCARBH_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTUPSR_USCARBH_1 = 0x1
	// Position of USCAFBL field.
	GPT164_GTUPSR_USCAFBL_Pos = 0xa
	// Bit mask of USCAFBL field.
	GPT164_GTUPSR_USCAFBL_Msk = 0x400
	// Bit USCAFBL.
	GPT164_GTUPSR_USCAFBL = 0x400
	// Counter count up disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTUPSR_USCAFBL_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTUPSR_USCAFBL_1 = 0x1
	// Position of USCAFBH field.
	GPT164_GTUPSR_USCAFBH_Pos = 0xb
	// Bit mask of USCAFBH field.
	GPT164_GTUPSR_USCAFBH_Msk = 0x800
	// Bit USCAFBH.
	GPT164_GTUPSR_USCAFBH = 0x800
	// Counter count up disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTUPSR_USCAFBH_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTUPSR_USCAFBH_1 = 0x1
	// Position of USCBRAL field.
	GPT164_GTUPSR_USCBRAL_Pos = 0xc
	// Bit mask of USCBRAL field.
	GPT164_GTUPSR_USCBRAL_Msk = 0x1000
	// Bit USCBRAL.
	GPT164_GTUPSR_USCBRAL = 0x1000
	// Counter count up disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTUPSR_USCBRAL_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTUPSR_USCBRAL_1 = 0x1
	// Position of USCBRAH field.
	GPT164_GTUPSR_USCBRAH_Pos = 0xd
	// Bit mask of USCBRAH field.
	GPT164_GTUPSR_USCBRAH_Msk = 0x2000
	// Bit USCBRAH.
	GPT164_GTUPSR_USCBRAH = 0x2000
	// Counter count up disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTUPSR_USCBRAH_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTUPSR_USCBRAH_1 = 0x1
	// Position of USCBFAL field.
	GPT164_GTUPSR_USCBFAL_Pos = 0xe
	// Bit mask of USCBFAL field.
	GPT164_GTUPSR_USCBFAL_Msk = 0x4000
	// Bit USCBFAL.
	GPT164_GTUPSR_USCBFAL = 0x4000
	// Counter count up disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTUPSR_USCBFAL_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTUPSR_USCBFAL_1 = 0x1
	// Position of USCBFAH field.
	GPT164_GTUPSR_USCBFAH_Pos = 0xf
	// Bit mask of USCBFAH field.
	GPT164_GTUPSR_USCBFAH_Msk = 0x8000
	// Bit USCBFAH.
	GPT164_GTUPSR_USCBFAH = 0x8000
	// Counter count up disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTUPSR_USCBFAH_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTUPSR_USCBFAH_1 = 0x1
	// Position of USELCA field.
	GPT164_GTUPSR_USELCA_Pos = 0x10
	// Bit mask of USELCA field.
	GPT164_GTUPSR_USELCA_Msk = 0x10000
	// Bit USELCA.
	GPT164_GTUPSR_USELCA = 0x10000
	// Counter count up disabled at the ELC_GPTA input
	GPT164_GTUPSR_USELCA_0 = 0x0
	// Counter count up enabled at the ELC_GPTA input
	GPT164_GTUPSR_USELCA_1 = 0x1
	// Position of USELCB field.
	GPT164_GTUPSR_USELCB_Pos = 0x11
	// Bit mask of USELCB field.
	GPT164_GTUPSR_USELCB_Msk = 0x20000
	// Bit USELCB.
	GPT164_GTUPSR_USELCB = 0x20000
	// Counter count up disabled at the ELC_GPTB input
	GPT164_GTUPSR_USELCB_0 = 0x0
	// Counter count up enabled at the ELC_GPTB input
	GPT164_GTUPSR_USELCB_1 = 0x1
	// Position of USELCC field.
	GPT164_GTUPSR_USELCC_Pos = 0x12
	// Bit mask of USELCC field.
	GPT164_GTUPSR_USELCC_Msk = 0x40000
	// Bit USELCC.
	GPT164_GTUPSR_USELCC = 0x40000
	// Counter count up disabled at the ELC_GPTC input
	GPT164_GTUPSR_USELCC_0 = 0x0
	// Counter count up enabled at the ELC_GPTC input
	GPT164_GTUPSR_USELCC_1 = 0x1
	// Position of USELCD field.
	GPT164_GTUPSR_USELCD_Pos = 0x13
	// Bit mask of USELCD field.
	GPT164_GTUPSR_USELCD_Msk = 0x80000
	// Bit USELCD.
	GPT164_GTUPSR_USELCD = 0x80000
	// Counter count up disabled at the ELC_GPTD input
	GPT164_GTUPSR_USELCD_0 = 0x0
	// Counter count up enabled at the ELC_GPTD input
	GPT164_GTUPSR_USELCD_1 = 0x1

	// GTDNSR: General PWM Timer Down Count Source Select Register
	// Position of DSGTRGAR field.
	GPT164_GTDNSR_DSGTRGAR_Pos = 0x0
	// Bit mask of DSGTRGAR field.
	GPT164_GTDNSR_DSGTRGAR_Msk = 0x1
	// Bit DSGTRGAR.
	GPT164_GTDNSR_DSGTRGAR = 0x1
	// Counter count down disabled on the rising edge of GTETRGA input
	GPT164_GTDNSR_DSGTRGAR_0 = 0x0
	// Counter count down enabled on the rising edge of GTETRGA input
	GPT164_GTDNSR_DSGTRGAR_1 = 0x1
	// Position of DSGTRGAF field.
	GPT164_GTDNSR_DSGTRGAF_Pos = 0x1
	// Bit mask of DSGTRGAF field.
	GPT164_GTDNSR_DSGTRGAF_Msk = 0x2
	// Bit DSGTRGAF.
	GPT164_GTDNSR_DSGTRGAF = 0x2
	// Counter count down disabled on the falling edge of GTETRGA input
	GPT164_GTDNSR_DSGTRGAF_0 = 0x0
	// Counter count down enabled on the falling edge of GTETRGA input
	GPT164_GTDNSR_DSGTRGAF_1 = 0x1
	// Position of DSGTRGBR field.
	GPT164_GTDNSR_DSGTRGBR_Pos = 0x2
	// Bit mask of DSGTRGBR field.
	GPT164_GTDNSR_DSGTRGBR_Msk = 0x4
	// Bit DSGTRGBR.
	GPT164_GTDNSR_DSGTRGBR = 0x4
	// Counter count down disabled on the rising edge of GTETRGB input
	GPT164_GTDNSR_DSGTRGBR_0 = 0x0
	// Counter count down enabled on the rising edge of GTETRGB input
	GPT164_GTDNSR_DSGTRGBR_1 = 0x1
	// Position of DSGTRGBF field.
	GPT164_GTDNSR_DSGTRGBF_Pos = 0x3
	// Bit mask of DSGTRGBF field.
	GPT164_GTDNSR_DSGTRGBF_Msk = 0x8
	// Bit DSGTRGBF.
	GPT164_GTDNSR_DSGTRGBF = 0x8
	// Counter count down disabled on the falling edge of GTETRGB input
	GPT164_GTDNSR_DSGTRGBF_0 = 0x0
	// Counter count down enabled on the falling edge of GTETRGB input
	GPT164_GTDNSR_DSGTRGBF_1 = 0x1
	// Position of DSCARBL field.
	GPT164_GTDNSR_DSCARBL_Pos = 0x8
	// Bit mask of DSCARBL field.
	GPT164_GTDNSR_DSCARBL_Msk = 0x100
	// Bit DSCARBL.
	GPT164_GTDNSR_DSCARBL = 0x100
	// Counter count down disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTDNSR_DSCARBL_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTDNSR_DSCARBL_1 = 0x1
	// Position of DSCARBH field.
	GPT164_GTDNSR_DSCARBH_Pos = 0x9
	// Bit mask of DSCARBH field.
	GPT164_GTDNSR_DSCARBH_Msk = 0x200
	// Bit DSCARBH.
	GPT164_GTDNSR_DSCARBH = 0x200
	// Counter count down disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTDNSR_DSCARBH_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTDNSR_DSCARBH_1 = 0x1
	// Position of DSCAFBL field.
	GPT164_GTDNSR_DSCAFBL_Pos = 0xa
	// Bit mask of DSCAFBL field.
	GPT164_GTDNSR_DSCAFBL_Msk = 0x400
	// Bit DSCAFBL.
	GPT164_GTDNSR_DSCAFBL = 0x400
	// Counter count down disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTDNSR_DSCAFBL_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTDNSR_DSCAFBL_1 = 0x1
	// Position of DSCAFBH field.
	GPT164_GTDNSR_DSCAFBH_Pos = 0xb
	// Bit mask of DSCAFBH field.
	GPT164_GTDNSR_DSCAFBH_Msk = 0x800
	// Bit DSCAFBH.
	GPT164_GTDNSR_DSCAFBH = 0x800
	// Counter count down disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTDNSR_DSCAFBH_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTDNSR_DSCAFBH_1 = 0x1
	// Position of DSCBRAL field.
	GPT164_GTDNSR_DSCBRAL_Pos = 0xc
	// Bit mask of DSCBRAL field.
	GPT164_GTDNSR_DSCBRAL_Msk = 0x1000
	// Bit DSCBRAL.
	GPT164_GTDNSR_DSCBRAL = 0x1000
	// Counter count down disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTDNSR_DSCBRAL_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTDNSR_DSCBRAL_1 = 0x1
	// Position of DSCBRAH field.
	GPT164_GTDNSR_DSCBRAH_Pos = 0xd
	// Bit mask of DSCBRAH field.
	GPT164_GTDNSR_DSCBRAH_Msk = 0x2000
	// Bit DSCBRAH.
	GPT164_GTDNSR_DSCBRAH = 0x2000
	// Counter count down disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTDNSR_DSCBRAH_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTDNSR_DSCBRAH_1 = 0x1
	// Position of DSCBFAL field.
	GPT164_GTDNSR_DSCBFAL_Pos = 0xe
	// Bit mask of DSCBFAL field.
	GPT164_GTDNSR_DSCBFAL_Msk = 0x4000
	// Bit DSCBFAL.
	GPT164_GTDNSR_DSCBFAL = 0x4000
	// Counter count down disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTDNSR_DSCBFAL_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTDNSR_DSCBFAL_1 = 0x1
	// Position of DSCBFAH field.
	GPT164_GTDNSR_DSCBFAH_Pos = 0xf
	// Bit mask of DSCBFAH field.
	GPT164_GTDNSR_DSCBFAH_Msk = 0x8000
	// Bit DSCBFAH.
	GPT164_GTDNSR_DSCBFAH = 0x8000
	// Counter count down disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTDNSR_DSCBFAH_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTDNSR_DSCBFAH_1 = 0x1
	// Position of DSELCA field.
	GPT164_GTDNSR_DSELCA_Pos = 0x10
	// Bit mask of DSELCA field.
	GPT164_GTDNSR_DSELCA_Msk = 0x10000
	// Bit DSELCA.
	GPT164_GTDNSR_DSELCA = 0x10000
	// Counter count down disabled at the ELC_GPTA input
	GPT164_GTDNSR_DSELCA_0 = 0x0
	// Counter count down enabled at the ELC_GPTA input
	GPT164_GTDNSR_DSELCA_1 = 0x1
	// Position of DSELCB field.
	GPT164_GTDNSR_DSELCB_Pos = 0x11
	// Bit mask of DSELCB field.
	GPT164_GTDNSR_DSELCB_Msk = 0x20000
	// Bit DSELCB.
	GPT164_GTDNSR_DSELCB = 0x20000
	// Counter count down disabled at the ELC_GPTB input
	GPT164_GTDNSR_DSELCB_0 = 0x0
	// Counter count down enabled at the ELC_GPTB input
	GPT164_GTDNSR_DSELCB_1 = 0x1
	// Position of DSELCC field.
	GPT164_GTDNSR_DSELCC_Pos = 0x12
	// Bit mask of DSELCC field.
	GPT164_GTDNSR_DSELCC_Msk = 0x40000
	// Bit DSELCC.
	GPT164_GTDNSR_DSELCC = 0x40000
	// Counter count down disabled at the ELC_GPTC input
	GPT164_GTDNSR_DSELCC_0 = 0x0
	// Counter count down enabled at the ELC_GPTC input
	GPT164_GTDNSR_DSELCC_1 = 0x1
	// Position of DSELCD field.
	GPT164_GTDNSR_DSELCD_Pos = 0x13
	// Bit mask of DSELCD field.
	GPT164_GTDNSR_DSELCD_Msk = 0x80000
	// Bit DSELCD.
	GPT164_GTDNSR_DSELCD = 0x80000
	// Counter count down disabled at the ELC_GPTD input
	GPT164_GTDNSR_DSELCD_0 = 0x0
	// Counter count down enabled at the ELC_GPTD input
	GPT164_GTDNSR_DSELCD_1 = 0x1

	// GTICASR: General PWM Timer Input Capture Source Select Register A
	// Position of ASGTRGAR field.
	GPT164_GTICASR_ASGTRGAR_Pos = 0x0
	// Bit mask of ASGTRGAR field.
	GPT164_GTICASR_ASGTRGAR_Msk = 0x1
	// Bit ASGTRGAR.
	GPT164_GTICASR_ASGTRGAR = 0x1
	// GTCCRA input capture disabled on the rising edge of GTETRGA input
	GPT164_GTICASR_ASGTRGAR_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTETRGA input
	GPT164_GTICASR_ASGTRGAR_1 = 0x1
	// Position of ASGTRGAF field.
	GPT164_GTICASR_ASGTRGAF_Pos = 0x1
	// Bit mask of ASGTRGAF field.
	GPT164_GTICASR_ASGTRGAF_Msk = 0x2
	// Bit ASGTRGAF.
	GPT164_GTICASR_ASGTRGAF = 0x2
	// GTCCRA input capture disabled on the falling edge of GTETRGA input
	GPT164_GTICASR_ASGTRGAF_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTETRGA input
	GPT164_GTICASR_ASGTRGAF_1 = 0x1
	// Position of ASGTRGBR field.
	GPT164_GTICASR_ASGTRGBR_Pos = 0x2
	// Bit mask of ASGTRGBR field.
	GPT164_GTICASR_ASGTRGBR_Msk = 0x4
	// Bit ASGTRGBR.
	GPT164_GTICASR_ASGTRGBR = 0x4
	// GTCCRA input capture disabled on the rising edge of GTETRGB input
	GPT164_GTICASR_ASGTRGBR_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTETRGB input
	GPT164_GTICASR_ASGTRGBR_1 = 0x1
	// Position of ASGTRGBF field.
	GPT164_GTICASR_ASGTRGBF_Pos = 0x3
	// Bit mask of ASGTRGBF field.
	GPT164_GTICASR_ASGTRGBF_Msk = 0x8
	// Bit ASGTRGBF.
	GPT164_GTICASR_ASGTRGBF = 0x8
	// GTCCRA input capture disabled on the falling edge of GTETRGB input
	GPT164_GTICASR_ASGTRGBF_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTETRGB input
	GPT164_GTICASR_ASGTRGBF_1 = 0x1
	// Position of ASCARBL field.
	GPT164_GTICASR_ASCARBL_Pos = 0x8
	// Bit mask of ASCARBL field.
	GPT164_GTICASR_ASCARBL_Msk = 0x100
	// Bit ASCARBL.
	GPT164_GTICASR_ASCARBL = 0x100
	// GTCCRA input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICASR_ASCARBL_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICASR_ASCARBL_1 = 0x1
	// Position of ASCARBH field.
	GPT164_GTICASR_ASCARBH_Pos = 0x9
	// Bit mask of ASCARBH field.
	GPT164_GTICASR_ASCARBH_Msk = 0x200
	// Bit ASCARBH.
	GPT164_GTICASR_ASCARBH = 0x200
	// GTCCRA input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICASR_ASCARBH_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICASR_ASCARBH_1 = 0x1
	// Position of ASCAFBL field.
	GPT164_GTICASR_ASCAFBL_Pos = 0xa
	// Bit mask of ASCAFBL field.
	GPT164_GTICASR_ASCAFBL_Msk = 0x400
	// Bit ASCAFBL.
	GPT164_GTICASR_ASCAFBL = 0x400
	// GTCCRA input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICASR_ASCAFBL_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICASR_ASCAFBL_1 = 0x1
	// Position of ASCAFBH field.
	GPT164_GTICASR_ASCAFBH_Pos = 0xb
	// Bit mask of ASCAFBH field.
	GPT164_GTICASR_ASCAFBH_Msk = 0x800
	// Bit ASCAFBH.
	GPT164_GTICASR_ASCAFBH = 0x800
	// GTCCRA input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICASR_ASCAFBH_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICASR_ASCAFBH_1 = 0x1
	// Position of ASCBRAL field.
	GPT164_GTICASR_ASCBRAL_Pos = 0xc
	// Bit mask of ASCBRAL field.
	GPT164_GTICASR_ASCBRAL_Msk = 0x1000
	// Bit ASCBRAL.
	GPT164_GTICASR_ASCBRAL = 0x1000
	// GTCCRA input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICASR_ASCBRAL_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICASR_ASCBRAL_1 = 0x1
	// Position of ASCBRAH field.
	GPT164_GTICASR_ASCBRAH_Pos = 0xd
	// Bit mask of ASCBRAH field.
	GPT164_GTICASR_ASCBRAH_Msk = 0x2000
	// Bit ASCBRAH.
	GPT164_GTICASR_ASCBRAH = 0x2000
	// GTCCRA input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICASR_ASCBRAH_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICASR_ASCBRAH_1 = 0x1
	// Position of ASCBFAL field.
	GPT164_GTICASR_ASCBFAL_Pos = 0xe
	// Bit mask of ASCBFAL field.
	GPT164_GTICASR_ASCBFAL_Msk = 0x4000
	// Bit ASCBFAL.
	GPT164_GTICASR_ASCBFAL = 0x4000
	// GTCCRA input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICASR_ASCBFAL_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICASR_ASCBFAL_1 = 0x1
	// Position of ASCBFAH field.
	GPT164_GTICASR_ASCBFAH_Pos = 0xf
	// Bit mask of ASCBFAH field.
	GPT164_GTICASR_ASCBFAH_Msk = 0x8000
	// Bit ASCBFAH.
	GPT164_GTICASR_ASCBFAH = 0x8000
	// GTCCRA input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICASR_ASCBFAH_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICASR_ASCBFAH_1 = 0x1
	// Position of ASELCA field.
	GPT164_GTICASR_ASELCA_Pos = 0x10
	// Bit mask of ASELCA field.
	GPT164_GTICASR_ASELCA_Msk = 0x10000
	// Bit ASELCA.
	GPT164_GTICASR_ASELCA = 0x10000
	// GTCCRA input capture disabled at the ELC_GPTA input
	GPT164_GTICASR_ASELCA_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTA input
	GPT164_GTICASR_ASELCA_1 = 0x1
	// Position of ASELCB field.
	GPT164_GTICASR_ASELCB_Pos = 0x11
	// Bit mask of ASELCB field.
	GPT164_GTICASR_ASELCB_Msk = 0x20000
	// Bit ASELCB.
	GPT164_GTICASR_ASELCB = 0x20000
	// GTCCRA input capture disabled at the ELC_GPTB input
	GPT164_GTICASR_ASELCB_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTB input
	GPT164_GTICASR_ASELCB_1 = 0x1
	// Position of ASELCC field.
	GPT164_GTICASR_ASELCC_Pos = 0x12
	// Bit mask of ASELCC field.
	GPT164_GTICASR_ASELCC_Msk = 0x40000
	// Bit ASELCC.
	GPT164_GTICASR_ASELCC = 0x40000
	// GTCCRA input capture disabled at the ELC_GPTC input
	GPT164_GTICASR_ASELCC_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTC input
	GPT164_GTICASR_ASELCC_1 = 0x1
	// Position of ASELCD field.
	GPT164_GTICASR_ASELCD_Pos = 0x13
	// Bit mask of ASELCD field.
	GPT164_GTICASR_ASELCD_Msk = 0x80000
	// Bit ASELCD.
	GPT164_GTICASR_ASELCD = 0x80000
	// GTCCRA input capture disabled at the ELC_GPTD input
	GPT164_GTICASR_ASELCD_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTD input
	GPT164_GTICASR_ASELCD_1 = 0x1

	// GTICBSR: General PWM Timer Input Capture Source Select Register B
	// Position of BSGTRGAR field.
	GPT164_GTICBSR_BSGTRGAR_Pos = 0x0
	// Bit mask of BSGTRGAR field.
	GPT164_GTICBSR_BSGTRGAR_Msk = 0x1
	// Bit BSGTRGAR.
	GPT164_GTICBSR_BSGTRGAR = 0x1
	// GTCCRB input capture disabled on the rising edge of GTETRGA input
	GPT164_GTICBSR_BSGTRGAR_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTETRGA input
	GPT164_GTICBSR_BSGTRGAR_1 = 0x1
	// Position of BSGTRGAF field.
	GPT164_GTICBSR_BSGTRGAF_Pos = 0x1
	// Bit mask of BSGTRGAF field.
	GPT164_GTICBSR_BSGTRGAF_Msk = 0x2
	// Bit BSGTRGAF.
	GPT164_GTICBSR_BSGTRGAF = 0x2
	// GTCCRB input capture disabled on the falling edge of GTETRGA input
	GPT164_GTICBSR_BSGTRGAF_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTETRGA input
	GPT164_GTICBSR_BSGTRGAF_1 = 0x1
	// Position of BSGTRGBR field.
	GPT164_GTICBSR_BSGTRGBR_Pos = 0x2
	// Bit mask of BSGTRGBR field.
	GPT164_GTICBSR_BSGTRGBR_Msk = 0x4
	// Bit BSGTRGBR.
	GPT164_GTICBSR_BSGTRGBR = 0x4
	// GTCCRB input capture disabled on the rising edge of GTETRGB input
	GPT164_GTICBSR_BSGTRGBR_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTETRGB input
	GPT164_GTICBSR_BSGTRGBR_1 = 0x1
	// Position of BSGTRGBF field.
	GPT164_GTICBSR_BSGTRGBF_Pos = 0x3
	// Bit mask of BSGTRGBF field.
	GPT164_GTICBSR_BSGTRGBF_Msk = 0x8
	// Bit BSGTRGBF.
	GPT164_GTICBSR_BSGTRGBF = 0x8
	// GTCCRB input capture disabled on the falling edge of GTETRGB input
	GPT164_GTICBSR_BSGTRGBF_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTETRGB input
	GPT164_GTICBSR_BSGTRGBF_1 = 0x1
	// Position of BSCARBL field.
	GPT164_GTICBSR_BSCARBL_Pos = 0x8
	// Bit mask of BSCARBL field.
	GPT164_GTICBSR_BSCARBL_Msk = 0x100
	// Bit BSCARBL.
	GPT164_GTICBSR_BSCARBL = 0x100
	// GTCCRB input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICBSR_BSCARBL_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICBSR_BSCARBL_1 = 0x1
	// Position of BSCARBH field.
	GPT164_GTICBSR_BSCARBH_Pos = 0x9
	// Bit mask of BSCARBH field.
	GPT164_GTICBSR_BSCARBH_Msk = 0x200
	// Bit BSCARBH.
	GPT164_GTICBSR_BSCARBH = 0x200
	// GTCCRB input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICBSR_BSCARBH_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICBSR_BSCARBH_1 = 0x1
	// Position of BSCAFBL field.
	GPT164_GTICBSR_BSCAFBL_Pos = 0xa
	// Bit mask of BSCAFBL field.
	GPT164_GTICBSR_BSCAFBL_Msk = 0x400
	// Bit BSCAFBL.
	GPT164_GTICBSR_BSCAFBL = 0x400
	// GTCCRB input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICBSR_BSCAFBL_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICBSR_BSCAFBL_1 = 0x1
	// Position of BSCAFBH field.
	GPT164_GTICBSR_BSCAFBH_Pos = 0xb
	// Bit mask of BSCAFBH field.
	GPT164_GTICBSR_BSCAFBH_Msk = 0x800
	// Bit BSCAFBH.
	GPT164_GTICBSR_BSCAFBH = 0x800
	// GTCCRB input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICBSR_BSCAFBH_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICBSR_BSCAFBH_1 = 0x1
	// Position of BSCBRAL field.
	GPT164_GTICBSR_BSCBRAL_Pos = 0xc
	// Bit mask of BSCBRAL field.
	GPT164_GTICBSR_BSCBRAL_Msk = 0x1000
	// Bit BSCBRAL.
	GPT164_GTICBSR_BSCBRAL = 0x1000
	// GTCCRB input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICBSR_BSCBRAL_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICBSR_BSCBRAL_1 = 0x1
	// Position of BSCBRAH field.
	GPT164_GTICBSR_BSCBRAH_Pos = 0xd
	// Bit mask of BSCBRAH field.
	GPT164_GTICBSR_BSCBRAH_Msk = 0x2000
	// Bit BSCBRAH.
	GPT164_GTICBSR_BSCBRAH = 0x2000
	// GTCCRB input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICBSR_BSCBRAH_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICBSR_BSCBRAH_1 = 0x1
	// Position of BSCBFAL field.
	GPT164_GTICBSR_BSCBFAL_Pos = 0xe
	// Bit mask of BSCBFAL field.
	GPT164_GTICBSR_BSCBFAL_Msk = 0x4000
	// Bit BSCBFAL.
	GPT164_GTICBSR_BSCBFAL = 0x4000
	// GTCCRB input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICBSR_BSCBFAL_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICBSR_BSCBFAL_1 = 0x1
	// Position of BSCBFAH field.
	GPT164_GTICBSR_BSCBFAH_Pos = 0xf
	// Bit mask of BSCBFAH field.
	GPT164_GTICBSR_BSCBFAH_Msk = 0x8000
	// Bit BSCBFAH.
	GPT164_GTICBSR_BSCBFAH = 0x8000
	// GTCCRB input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICBSR_BSCBFAH_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICBSR_BSCBFAH_1 = 0x1
	// Position of BSELCA field.
	GPT164_GTICBSR_BSELCA_Pos = 0x10
	// Bit mask of BSELCA field.
	GPT164_GTICBSR_BSELCA_Msk = 0x10000
	// Bit BSELCA.
	GPT164_GTICBSR_BSELCA = 0x10000
	// GTCCRB input capture disabled at the ELC_GPTA input
	GPT164_GTICBSR_BSELCA_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTA input
	GPT164_GTICBSR_BSELCA_1 = 0x1
	// Position of BSELCB field.
	GPT164_GTICBSR_BSELCB_Pos = 0x11
	// Bit mask of BSELCB field.
	GPT164_GTICBSR_BSELCB_Msk = 0x20000
	// Bit BSELCB.
	GPT164_GTICBSR_BSELCB = 0x20000
	// GTCCRB input capture disabled at the ELC_GPTB input
	GPT164_GTICBSR_BSELCB_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTB input
	GPT164_GTICBSR_BSELCB_1 = 0x1
	// Position of BSELCC field.
	GPT164_GTICBSR_BSELCC_Pos = 0x12
	// Bit mask of BSELCC field.
	GPT164_GTICBSR_BSELCC_Msk = 0x40000
	// Bit BSELCC.
	GPT164_GTICBSR_BSELCC = 0x40000
	// GTCCRB input capture disabled at the ELC_GPTC input
	GPT164_GTICBSR_BSELCC_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTC input
	GPT164_GTICBSR_BSELCC_1 = 0x1
	// Position of BSELCD field.
	GPT164_GTICBSR_BSELCD_Pos = 0x13
	// Bit mask of BSELCD field.
	GPT164_GTICBSR_BSELCD_Msk = 0x80000
	// Bit BSELCD.
	GPT164_GTICBSR_BSELCD = 0x80000
	// GTCCRB input capture disabled at the ELC_GPTD input
	GPT164_GTICBSR_BSELCD_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTD input
	GPT164_GTICBSR_BSELCD_1 = 0x1

	// GTCR: General PWM Timer Control Register
	// Position of CST field.
	GPT164_GTCR_CST_Pos = 0x0
	// Bit mask of CST field.
	GPT164_GTCR_CST_Msk = 0x1
	// Bit CST.
	GPT164_GTCR_CST = 0x1
	// Count operation is stopped
	GPT164_GTCR_CST_0 = 0x0
	// Count operation is performed
	GPT164_GTCR_CST_1 = 0x1
	// Position of MD field.
	GPT164_GTCR_MD_Pos = 0x10
	// Bit mask of MD field.
	GPT164_GTCR_MD_Msk = 0x70000
	// Saw-wave PWM mode (single buffer or double buffer possible)
	GPT164_GTCR_MD_000 = 0x0
	// Saw-wave one-shot pulse mode (fixed buffer operation)
	GPT164_GTCR_MD_001 = 0x1
	// Setting prohibited
	GPT164_GTCR_MD_010 = 0x2
	// Setting prohibited
	GPT164_GTCR_MD_011 = 0x3
	// Triangle-wave PWM mode 1 (32-bit transfer at trough) (single buffer or double buffer is possible)
	GPT164_GTCR_MD_100 = 0x4
	// Triangle-wave PWM mode 2 (32-bit transfer at crest and trough) (single buffer or double buffer is possible)
	GPT164_GTCR_MD_101 = 0x5
	// Triangle-wave PWM mode 3 (64-bit transfer at trough) (fixed buffer operation)
	GPT164_GTCR_MD_110 = 0x6
	// Setting prohibited
	GPT164_GTCR_MD_111 = 0x7
	// Position of TPCS field.
	GPT164_GTCR_TPCS_Pos = 0x18
	// Bit mask of TPCS field.
	GPT164_GTCR_TPCS_Msk = 0x7000000
	// PCLKD/1
	GPT164_GTCR_TPCS_000 = 0x0
	// PCLKD/4
	GPT164_GTCR_TPCS_001 = 0x1
	// PCLKD/16
	GPT164_GTCR_TPCS_010 = 0x2
	// PCLKD/64
	GPT164_GTCR_TPCS_011 = 0x3
	// PCLKD/256
	GPT164_GTCR_TPCS_100 = 0x4
	// PCLKD/1024
	GPT164_GTCR_TPCS_101 = 0x5

	// GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
	// Position of UD field.
	GPT164_GTUDDTYC_UD_Pos = 0x0
	// Bit mask of UD field.
	GPT164_GTUDDTYC_UD_Msk = 0x1
	// Bit UD.
	GPT164_GTUDDTYC_UD = 0x1
	// GTCNT counts down
	GPT164_GTUDDTYC_UD_0 = 0x0
	// GTCNT counts up
	GPT164_GTUDDTYC_UD_1 = 0x1
	// Position of UDF field.
	GPT164_GTUDDTYC_UDF_Pos = 0x1
	// Bit mask of UDF field.
	GPT164_GTUDDTYC_UDF_Msk = 0x2
	// Bit UDF.
	GPT164_GTUDDTYC_UDF = 0x2
	// Not forcibly set
	GPT164_GTUDDTYC_UDF_0 = 0x0
	// Forcibly set
	GPT164_GTUDDTYC_UDF_1 = 0x1
	// Position of OADTY field.
	GPT164_GTUDDTYC_OADTY_Pos = 0x10
	// Bit mask of OADTY field.
	GPT164_GTUDDTYC_OADTY_Msk = 0x30000
	// GTIOCnA pin duty depends on the compare match
	GPT164_GTUDDTYC_OADTY_00 = 0x0
	// GTIOCnA pin duty depends on the compare match
	GPT164_GTUDDTYC_OADTY_01 = 0x1
	// GTIOCnA pin duty 0%
	GPT164_GTUDDTYC_OADTY_10 = 0x2
	// GTIOCnA pin duty 100%
	GPT164_GTUDDTYC_OADTY_11 = 0x3
	// Position of OADTYF field.
	GPT164_GTUDDTYC_OADTYF_Pos = 0x12
	// Bit mask of OADTYF field.
	GPT164_GTUDDTYC_OADTYF_Msk = 0x40000
	// Bit OADTYF.
	GPT164_GTUDDTYC_OADTYF = 0x40000
	// Not forcibly set
	GPT164_GTUDDTYC_OADTYF_0 = 0x0
	// Forcibly set
	GPT164_GTUDDTYC_OADTYF_1 = 0x1
	// Position of OADTYR field.
	GPT164_GTUDDTYC_OADTYR_Pos = 0x13
	// Bit mask of OADTYR field.
	GPT164_GTUDDTYC_OADTYR_Msk = 0x80000
	// Bit OADTYR.
	GPT164_GTUDDTYC_OADTYR = 0x80000
	// The function selected by the GTIOA[3:2] bits is applied to the output value when the duty cycle is set after release from the 0 or 100% duty-cycle setting.
	GPT164_GTUDDTYC_OADTYR_0 = 0x0
	// The function selected by the GTIOA[3:2] bits is applied to the compare match output value which is masked after release from the 0 or 100% duty-cycle setting.
	GPT164_GTUDDTYC_OADTYR_1 = 0x1
	// Position of OBDTY field.
	GPT164_GTUDDTYC_OBDTY_Pos = 0x18
	// Bit mask of OBDTY field.
	GPT164_GTUDDTYC_OBDTY_Msk = 0x3000000
	// GTIOCnB pin duty depends on the compare match
	GPT164_GTUDDTYC_OBDTY_00 = 0x0
	// GTIOCnB pin duty depends on the compare match
	GPT164_GTUDDTYC_OBDTY_01 = 0x1
	// GTIOCnB pin duty 0%
	GPT164_GTUDDTYC_OBDTY_10 = 0x2
	// GTIOCnB pin duty 100%
	GPT164_GTUDDTYC_OBDTY_11 = 0x3
	// Position of OBDTYF field.
	GPT164_GTUDDTYC_OBDTYF_Pos = 0x1a
	// Bit mask of OBDTYF field.
	GPT164_GTUDDTYC_OBDTYF_Msk = 0x4000000
	// Bit OBDTYF.
	GPT164_GTUDDTYC_OBDTYF = 0x4000000
	// Not forcibly set
	GPT164_GTUDDTYC_OBDTYF_0 = 0x0
	// Forcibly set
	GPT164_GTUDDTYC_OBDTYF_1 = 0x1
	// Position of OBDTYR field.
	GPT164_GTUDDTYC_OBDTYR_Pos = 0x1b
	// Bit mask of OBDTYR field.
	GPT164_GTUDDTYC_OBDTYR_Msk = 0x8000000
	// Bit OBDTYR.
	GPT164_GTUDDTYC_OBDTYR = 0x8000000
	// The function selected by the GTIOB[3:2] bits is applied to the output value when the duty cycle is set after release from the 0 or 100% duty-cycle setting.
	GPT164_GTUDDTYC_OBDTYR_0 = 0x0
	// The function selected by the GTIOB[3:2] bits is applied to the compare match output value which is masked after release from the 0 or 100% duty-cycle setting.
	GPT164_GTUDDTYC_OBDTYR_1 = 0x1

	// GTIOR: General PWM Timer I/O Control Register
	// Position of GTIOA field.
	GPT164_GTIOR_GTIOA_Pos = 0x0
	// Bit mask of GTIOA field.
	GPT164_GTIOR_GTIOA_Msk = 0x1f
	// Position of OADFLT field.
	GPT164_GTIOR_OADFLT_Pos = 0x6
	// Bit mask of OADFLT field.
	GPT164_GTIOR_OADFLT_Msk = 0x40
	// Bit OADFLT.
	GPT164_GTIOR_OADFLT = 0x40
	// The GTIOCnA pin outputs low when counting stops
	GPT164_GTIOR_OADFLT_0 = 0x0
	// The GTIOCnA pin outputs high when counting stops
	GPT164_GTIOR_OADFLT_1 = 0x1
	// Position of OAHLD field.
	GPT164_GTIOR_OAHLD_Pos = 0x7
	// Bit mask of OAHLD field.
	GPT164_GTIOR_OAHLD_Msk = 0x80
	// Bit OAHLD.
	GPT164_GTIOR_OAHLD = 0x80
	// The GTIOCnA pin output level at the start or stop of counting depends on the register setting
	GPT164_GTIOR_OAHLD_0 = 0x0
	// The GTIOCnA pin output level is retained at the start or stop of counting
	GPT164_GTIOR_OAHLD_1 = 0x1
	// Position of OAE field.
	GPT164_GTIOR_OAE_Pos = 0x8
	// Bit mask of OAE field.
	GPT164_GTIOR_OAE_Msk = 0x100
	// Bit OAE.
	GPT164_GTIOR_OAE = 0x100
	// Output is disabled
	GPT164_GTIOR_OAE_0 = 0x0
	// Output is enabled
	GPT164_GTIOR_OAE_1 = 0x1
	// Position of OADF field.
	GPT164_GTIOR_OADF_Pos = 0x9
	// Bit mask of OADF field.
	GPT164_GTIOR_OADF_Msk = 0x600
	// None of the below options are specified
	GPT164_GTIOR_OADF_00 = 0x0
	// GTIOCnA pin is set to Hi-Z in response to controlling the output negation
	GPT164_GTIOR_OADF_01 = 0x1
	// GTIOCnA pin is set to 0 in response to controlling the output negation
	GPT164_GTIOR_OADF_10 = 0x2
	// GTIOCnA pin is set to 1 in response to controlling the output negation
	GPT164_GTIOR_OADF_11 = 0x3
	// Position of NFAEN field.
	GPT164_GTIOR_NFAEN_Pos = 0xd
	// Bit mask of NFAEN field.
	GPT164_GTIOR_NFAEN_Msk = 0x2000
	// Bit NFAEN.
	GPT164_GTIOR_NFAEN = 0x2000
	// The noise filter for the GTIOCnA pin is disabled
	GPT164_GTIOR_NFAEN_0 = 0x0
	// The noise filter for the GTIOCnA pin is enabled
	GPT164_GTIOR_NFAEN_1 = 0x1
	// Position of NFCSA field.
	GPT164_GTIOR_NFCSA_Pos = 0xe
	// Bit mask of NFCSA field.
	GPT164_GTIOR_NFCSA_Msk = 0xc000
	// PCLKD/1
	GPT164_GTIOR_NFCSA_00 = 0x0
	// PCLKD/4
	GPT164_GTIOR_NFCSA_01 = 0x1
	// PCLKD/16
	GPT164_GTIOR_NFCSA_10 = 0x2
	// PCLKD/64
	GPT164_GTIOR_NFCSA_11 = 0x3
	// Position of GTIOB field.
	GPT164_GTIOR_GTIOB_Pos = 0x10
	// Bit mask of GTIOB field.
	GPT164_GTIOR_GTIOB_Msk = 0x1f0000
	// Position of OBDFLT field.
	GPT164_GTIOR_OBDFLT_Pos = 0x16
	// Bit mask of OBDFLT field.
	GPT164_GTIOR_OBDFLT_Msk = 0x400000
	// Bit OBDFLT.
	GPT164_GTIOR_OBDFLT = 0x400000
	// The GTIOCnB pin outputs low when counting stops
	GPT164_GTIOR_OBDFLT_0 = 0x0
	// The GTIOCnB pin outputs high when counting stops
	GPT164_GTIOR_OBDFLT_1 = 0x1
	// Position of OBHLD field.
	GPT164_GTIOR_OBHLD_Pos = 0x17
	// Bit mask of OBHLD field.
	GPT164_GTIOR_OBHLD_Msk = 0x800000
	// Bit OBHLD.
	GPT164_GTIOR_OBHLD = 0x800000
	// The GTIOCnB pin output level at the start/stop of counting depends on the register setting
	GPT164_GTIOR_OBHLD_0 = 0x0
	// The GTIOCnB pin output level is retained at the start/stop of counting
	GPT164_GTIOR_OBHLD_1 = 0x1
	// Position of OBE field.
	GPT164_GTIOR_OBE_Pos = 0x18
	// Bit mask of OBE field.
	GPT164_GTIOR_OBE_Msk = 0x1000000
	// Bit OBE.
	GPT164_GTIOR_OBE = 0x1000000
	// Output is disabled
	GPT164_GTIOR_OBE_0 = 0x0
	// Output is enabled
	GPT164_GTIOR_OBE_1 = 0x1
	// Position of OBDF field.
	GPT164_GTIOR_OBDF_Pos = 0x19
	// Bit mask of OBDF field.
	GPT164_GTIOR_OBDF_Msk = 0x6000000
	// None of the below options are specified
	GPT164_GTIOR_OBDF_00 = 0x0
	// GTIOCnB pin is set to Hi-Z in response to controlling the output negation
	GPT164_GTIOR_OBDF_01 = 0x1
	// GTIOCnB pin is set to 0 in response to controlling the output negation
	GPT164_GTIOR_OBDF_10 = 0x2
	// GTIOCnB pin is set to 1 in response to controlling the output negation
	GPT164_GTIOR_OBDF_11 = 0x3
	// Position of NFBEN field.
	GPT164_GTIOR_NFBEN_Pos = 0x1d
	// Bit mask of NFBEN field.
	GPT164_GTIOR_NFBEN_Msk = 0x20000000
	// Bit NFBEN.
	GPT164_GTIOR_NFBEN = 0x20000000
	// The noise filter for the GTIOCnB pin is disabled
	GPT164_GTIOR_NFBEN_0 = 0x0
	// The noise filter for the GTIOCnB pin is enabled
	GPT164_GTIOR_NFBEN_1 = 0x1
	// Position of NFCSB field.
	GPT164_GTIOR_NFCSB_Pos = 0x1e
	// Bit mask of NFCSB field.
	GPT164_GTIOR_NFCSB_Msk = 0xc0000000
	// PCLKD/1
	GPT164_GTIOR_NFCSB_00 = 0x0
	// PCLKD/4
	GPT164_GTIOR_NFCSB_01 = 0x1
	// PCLKD/16
	GPT164_GTIOR_NFCSB_10 = 0x2
	// PCLKD/64
	GPT164_GTIOR_NFCSB_11 = 0x3

	// GTINTAD: General PWM Timer Interrupt Output Setting Register
	// Position of GRP field.
	GPT164_GTINTAD_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT164_GTINTAD_GRP_Msk = 0x3000000
	// Group A output disable request is selected
	GPT164_GTINTAD_GRP_00 = 0x0
	// Group B output disable request is selected
	GPT164_GTINTAD_GRP_01 = 0x1
	// Position of GRPABH field.
	GPT164_GTINTAD_GRPABH_Pos = 0x1d
	// Bit mask of GRPABH field.
	GPT164_GTINTAD_GRPABH_Msk = 0x20000000
	// Bit GRPABH.
	GPT164_GTINTAD_GRPABH = 0x20000000
	// Same time output level high disable request disabled
	GPT164_GTINTAD_GRPABH_0 = 0x0
	// Same time output level high disable request enabled
	GPT164_GTINTAD_GRPABH_1 = 0x1
	// Position of GRPABL field.
	GPT164_GTINTAD_GRPABL_Pos = 0x1e
	// Bit mask of GRPABL field.
	GPT164_GTINTAD_GRPABL_Msk = 0x40000000
	// Bit GRPABL.
	GPT164_GTINTAD_GRPABL = 0x40000000
	// Same time output level low disable request disabled
	GPT164_GTINTAD_GRPABL_0 = 0x0
	// Same time output level low disable request enabled
	GPT164_GTINTAD_GRPABL_1 = 0x1

	// GTST: General PWM Timer Status Register
	// Position of TCFA field.
	GPT164_GTST_TCFA_Pos = 0x0
	// Bit mask of TCFA field.
	GPT164_GTST_TCFA_Msk = 0x1
	// Bit TCFA.
	GPT164_GTST_TCFA = 0x1
	// No input capture/compare match of GTCCRA is generated
	GPT164_GTST_TCFA_0 = 0x0
	// An input capture/compare match of GTCCRA is generated
	GPT164_GTST_TCFA_1 = 0x1
	// Position of TCFB field.
	GPT164_GTST_TCFB_Pos = 0x1
	// Bit mask of TCFB field.
	GPT164_GTST_TCFB_Msk = 0x2
	// Bit TCFB.
	GPT164_GTST_TCFB = 0x2
	// No input capture/compare match of GTCCRB is generated
	GPT164_GTST_TCFB_0 = 0x0
	// An input capture/compare match of GTCCRB is generated
	GPT164_GTST_TCFB_1 = 0x1
	// Position of TCFC field.
	GPT164_GTST_TCFC_Pos = 0x2
	// Bit mask of TCFC field.
	GPT164_GTST_TCFC_Msk = 0x4
	// Bit TCFC.
	GPT164_GTST_TCFC = 0x4
	// No compare match of GTCCRC is generated
	GPT164_GTST_TCFC_0 = 0x0
	// A compare match of GTCCRC is generated
	GPT164_GTST_TCFC_1 = 0x1
	// Position of TCFD field.
	GPT164_GTST_TCFD_Pos = 0x3
	// Bit mask of TCFD field.
	GPT164_GTST_TCFD_Msk = 0x8
	// Bit TCFD.
	GPT164_GTST_TCFD = 0x8
	// No compare match of GTCCRD is generated
	GPT164_GTST_TCFD_0 = 0x0
	// A compare match of GTCCRD is generated
	GPT164_GTST_TCFD_1 = 0x1
	// Position of TCFE field.
	GPT164_GTST_TCFE_Pos = 0x4
	// Bit mask of TCFE field.
	GPT164_GTST_TCFE_Msk = 0x10
	// Bit TCFE.
	GPT164_GTST_TCFE = 0x10
	// No compare match of GTCCRE is generated
	GPT164_GTST_TCFE_0 = 0x0
	// A compare match of GTCCRE is generated
	GPT164_GTST_TCFE_1 = 0x1
	// Position of TCFF field.
	GPT164_GTST_TCFF_Pos = 0x5
	// Bit mask of TCFF field.
	GPT164_GTST_TCFF_Msk = 0x20
	// Bit TCFF.
	GPT164_GTST_TCFF = 0x20
	// No compare match of GTCCRF is generated
	GPT164_GTST_TCFF_0 = 0x0
	// A compare match of GTCCRF is generated
	GPT164_GTST_TCFF_1 = 0x1
	// Position of TCFPO field.
	GPT164_GTST_TCFPO_Pos = 0x6
	// Bit mask of TCFPO field.
	GPT164_GTST_TCFPO_Msk = 0x40
	// Bit TCFPO.
	GPT164_GTST_TCFPO = 0x40
	// No overflow (crest) occurred
	GPT164_GTST_TCFPO_0 = 0x0
	// An overflow (crest) occurred
	GPT164_GTST_TCFPO_1 = 0x1
	// Position of TCFPU field.
	GPT164_GTST_TCFPU_Pos = 0x7
	// Bit mask of TCFPU field.
	GPT164_GTST_TCFPU_Msk = 0x80
	// Bit TCFPU.
	GPT164_GTST_TCFPU = 0x80
	// No underflow (trough) occurred
	GPT164_GTST_TCFPU_0 = 0x0
	// An underflow (trough) occurred
	GPT164_GTST_TCFPU_1 = 0x1
	// Position of TUCF field.
	GPT164_GTST_TUCF_Pos = 0xf
	// Bit mask of TUCF field.
	GPT164_GTST_TUCF_Msk = 0x8000
	// Bit TUCF.
	GPT164_GTST_TUCF = 0x8000
	// GTCNT counter counts downward
	GPT164_GTST_TUCF_0 = 0x0
	// GTCNT counter counts upward
	GPT164_GTST_TUCF_1 = 0x1
	// Position of ODF field.
	GPT164_GTST_ODF_Pos = 0x18
	// Bit mask of ODF field.
	GPT164_GTST_ODF_Msk = 0x1000000
	// Bit ODF.
	GPT164_GTST_ODF = 0x1000000
	// No output disable request is generated
	GPT164_GTST_ODF_0 = 0x0
	// An output disable request is generated
	GPT164_GTST_ODF_1 = 0x1
	// Position of OABHF field.
	GPT164_GTST_OABHF_Pos = 0x1d
	// Bit mask of OABHF field.
	GPT164_GTST_OABHF_Msk = 0x20000000
	// Bit OABHF.
	GPT164_GTST_OABHF = 0x20000000
	// No simultaneous generation of 1 both for the GTIOCA and GTIOCB pins has occurred.
	GPT164_GTST_OABHF_0 = 0x0
	// A simultaneous generation of 1 both for the GTIOCA and GTIOCB pins has occurred.
	GPT164_GTST_OABHF_1 = 0x1
	// Position of OABLF field.
	GPT164_GTST_OABLF_Pos = 0x1e
	// Bit mask of OABLF field.
	GPT164_GTST_OABLF_Msk = 0x40000000
	// Bit OABLF.
	GPT164_GTST_OABLF = 0x40000000
	// No simultaneous generation of 0 both for the GTIOCA and GTIOCB pins has occurred.
	GPT164_GTST_OABLF_0 = 0x0
	// A simultaneous generation of 0 both for the GTIOCA and GTIOCB pins has occurred.
	GPT164_GTST_OABLF_1 = 0x1

	// GTBER: General PWM Timer Buffer Enable Register
	// Position of BD0 field.
	GPT164_GTBER_BD0_Pos = 0x0
	// Bit mask of BD0 field.
	GPT164_GTBER_BD0_Msk = 0x1
	// Bit BD0.
	GPT164_GTBER_BD0 = 0x1
	// Buffer operation is enabled
	GPT164_GTBER_BD0_0 = 0x0
	// Buffer operation is disabled
	GPT164_GTBER_BD0_1 = 0x1
	// Position of BD1 field.
	GPT164_GTBER_BD1_Pos = 0x1
	// Bit mask of BD1 field.
	GPT164_GTBER_BD1_Msk = 0x2
	// Bit BD1.
	GPT164_GTBER_BD1 = 0x2
	// Buffer operation is enabled
	GPT164_GTBER_BD1_0 = 0x0
	// Buffer operation is disabled
	GPT164_GTBER_BD1_1 = 0x1
	// Position of CCRA field.
	GPT164_GTBER_CCRA_Pos = 0x10
	// Bit mask of CCRA field.
	GPT164_GTBER_CCRA_Msk = 0x30000
	// No buffer operation
	GPT164_GTBER_CCRA_00 = 0x0
	// Single buffer operation (GTCCRA <---->GTCCRC)
	GPT164_GTBER_CCRA_01 = 0x1
	// Position of CCRB field.
	GPT164_GTBER_CCRB_Pos = 0x12
	// Bit mask of CCRB field.
	GPT164_GTBER_CCRB_Msk = 0xc0000
	// No buffer operation
	GPT164_GTBER_CCRB_00 = 0x0
	// Single buffer operation (GTCCRB <----> GTCCRE)
	GPT164_GTBER_CCRB_01 = 0x1
	// Position of PR field.
	GPT164_GTBER_PR_Pos = 0x14
	// Bit mask of PR field.
	GPT164_GTBER_PR_Msk = 0x300000
	// No buffer operation
	GPT164_GTBER_PR_00 = 0x0
	// Single buffer operation (GTPBR --> GTPR)
	GPT164_GTBER_PR_01 = 0x1
	// Position of CCRSWT field.
	GPT164_GTBER_CCRSWT_Pos = 0x16
	// Bit mask of CCRSWT field.
	GPT164_GTBER_CCRSWT_Msk = 0x400000
	// Bit CCRSWT.
	GPT164_GTBER_CCRSWT = 0x400000

	// GTDTCR: General PWM Timer Dead Time Control Register
	// Position of TDE field.
	GPT164_GTDTCR_TDE_Pos = 0x0
	// Bit mask of TDE field.
	GPT164_GTDTCR_TDE_Msk = 0x1
	// Bit TDE.
	GPT164_GTDTCR_TDE = 0x1
	// GTCCRB is set without using GTDVU
	GPT164_GTDTCR_TDE_0 = 0x0
	// GTDVU is used to set the compare match value for negative-phase waveform with dead time automatically in GTCCRB
	GPT164_GTDTCR_TDE_1 = 0x1
)

// Constants for GPT_OPS: Output Phase Switching Controller
const (
	// OPSCR: Output Phase Switching Control Register
	// Position of UF field.
	GPT_OPS_OPSCR_UF_Pos = 0x0
	// Bit mask of UF field.
	GPT_OPS_OPSCR_UF_Msk = 0x1
	// Bit UF.
	GPT_OPS_OPSCR_UF = 0x1
	// Position of VF field.
	GPT_OPS_OPSCR_VF_Pos = 0x1
	// Bit mask of VF field.
	GPT_OPS_OPSCR_VF_Msk = 0x2
	// Bit VF.
	GPT_OPS_OPSCR_VF = 0x2
	// Position of WF field.
	GPT_OPS_OPSCR_WF_Pos = 0x2
	// Bit mask of WF field.
	GPT_OPS_OPSCR_WF_Msk = 0x4
	// Bit WF.
	GPT_OPS_OPSCR_WF = 0x4
	// Position of U field.
	GPT_OPS_OPSCR_U_Pos = 0x4
	// Bit mask of U field.
	GPT_OPS_OPSCR_U_Msk = 0x10
	// Bit U.
	GPT_OPS_OPSCR_U = 0x10
	// Position of V field.
	GPT_OPS_OPSCR_V_Pos = 0x5
	// Bit mask of V field.
	GPT_OPS_OPSCR_V_Msk = 0x20
	// Bit V.
	GPT_OPS_OPSCR_V = 0x20
	// Position of W field.
	GPT_OPS_OPSCR_W_Pos = 0x6
	// Bit mask of W field.
	GPT_OPS_OPSCR_W_Msk = 0x40
	// Bit W.
	GPT_OPS_OPSCR_W = 0x40
	// Position of EN field.
	GPT_OPS_OPSCR_EN_Pos = 0x8
	// Bit mask of EN field.
	GPT_OPS_OPSCR_EN_Msk = 0x100
	// Bit EN.
	GPT_OPS_OPSCR_EN = 0x100
	// Do not output (Hi-Z external pin)
	GPT_OPS_OPSCR_EN_0 = 0x0
	// Output
	GPT_OPS_OPSCR_EN_1 = 0x1
	// Position of FB field.
	GPT_OPS_OPSCR_FB_Pos = 0x10
	// Bit mask of FB field.
	GPT_OPS_OPSCR_FB_Msk = 0x10000
	// Bit FB.
	GPT_OPS_OPSCR_FB = 0x10000
	// Select the external input
	GPT_OPS_OPSCR_FB_0 = 0x0
	// Select the soft setting (OPSCR.UF, VF, WF)
	GPT_OPS_OPSCR_FB_1 = 0x1
	// Position of P field.
	GPT_OPS_OPSCR_P_Pos = 0x11
	// Bit mask of P field.
	GPT_OPS_OPSCR_P_Msk = 0x20000
	// Bit P.
	GPT_OPS_OPSCR_P = 0x20000
	// Level signal output
	GPT_OPS_OPSCR_P_0 = 0x0
	// PWM signal output
	GPT_OPS_OPSCR_P_1 = 0x1
	// Position of N field.
	GPT_OPS_OPSCR_N_Pos = 0x12
	// Bit mask of N field.
	GPT_OPS_OPSCR_N_Msk = 0x40000
	// Bit N.
	GPT_OPS_OPSCR_N = 0x40000
	// Level signal output
	GPT_OPS_OPSCR_N_0 = 0x0
	// PWM signal output
	GPT_OPS_OPSCR_N_1 = 0x1
	// Position of INV field.
	GPT_OPS_OPSCR_INV_Pos = 0x13
	// Bit mask of INV field.
	GPT_OPS_OPSCR_INV_Msk = 0x80000
	// Bit INV.
	GPT_OPS_OPSCR_INV = 0x80000
	// Positive logic (active-high) output
	GPT_OPS_OPSCR_INV_0 = 0x0
	// Negative logic (active-low) output
	GPT_OPS_OPSCR_INV_1 = 0x1
	// Position of RV field.
	GPT_OPS_OPSCR_RV_Pos = 0x14
	// Bit mask of RV field.
	GPT_OPS_OPSCR_RV_Msk = 0x100000
	// Bit RV.
	GPT_OPS_OPSCR_RV = 0x100000
	// Positive rotation
	GPT_OPS_OPSCR_RV_0 = 0x0
	// Reverse rotation
	GPT_OPS_OPSCR_RV_1 = 0x1
	// Position of ALIGN field.
	GPT_OPS_OPSCR_ALIGN_Pos = 0x15
	// Bit mask of ALIGN field.
	GPT_OPS_OPSCR_ALIGN_Msk = 0x200000
	// Bit ALIGN.
	GPT_OPS_OPSCR_ALIGN = 0x200000
	// Input phase aligned to PCLKD
	GPT_OPS_OPSCR_ALIGN_0 = 0x0
	// Input phase aligned to the falling edge of PWM
	GPT_OPS_OPSCR_ALIGN_1 = 0x1
	// Position of GRP field.
	GPT_OPS_OPSCR_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT_OPS_OPSCR_GRP_Msk = 0x3000000
	// Position of GODF field.
	GPT_OPS_OPSCR_GODF_Pos = 0x1a
	// Bit mask of GODF field.
	GPT_OPS_OPSCR_GODF_Msk = 0x4000000
	// Bit GODF.
	GPT_OPS_OPSCR_GODF = 0x4000000
	// This bit function is ignored
	GPT_OPS_OPSCR_GODF_0 = 0x0
	// Group disable clears the OPSCR.EN bit
	GPT_OPS_OPSCR_GODF_1 = 0x1
	// Position of NFEN field.
	GPT_OPS_OPSCR_NFEN_Pos = 0x1d
	// Bit mask of NFEN field.
	GPT_OPS_OPSCR_NFEN_Msk = 0x20000000
	// Bit NFEN.
	GPT_OPS_OPSCR_NFEN = 0x20000000
	// Do not use a noise filter on the external input
	GPT_OPS_OPSCR_NFEN_0 = 0x0
	// Use a noise filter on the external input
	GPT_OPS_OPSCR_NFEN_1 = 0x1
	// Position of NFCS field.
	GPT_OPS_OPSCR_NFCS_Pos = 0x1e
	// Bit mask of NFCS field.
	GPT_OPS_OPSCR_NFCS_Msk = 0xc0000000
	// PCLKD/1
	GPT_OPS_OPSCR_NFCS_00 = 0x0
	// PCLKD/4
	GPT_OPS_OPSCR_NFCS_01 = 0x1
	// PCLKD/16
	GPT_OPS_OPSCR_NFCS_10 = 0x2
	// PCLKD/64
	GPT_OPS_OPSCR_NFCS_11 = 0x3
)

// Constants for KINT: Key Interrupt Function
const (
	// KRCTL: Key Return Control Register
	// Position of KREG field.
	KINT_KRCTL_KREG_Pos = 0x0
	// Bit mask of KREG field.
	KINT_KRCTL_KREG_Msk = 0x1
	// Bit KREG.
	KINT_KRCTL_KREG = 0x1
	// Falling edge
	KINT_KRCTL_KREG_0 = 0x0
	// Rising edge
	KINT_KRCTL_KREG_1 = 0x1
	// Position of KRMD field.
	KINT_KRCTL_KRMD_Pos = 0x7
	// Bit mask of KRMD field.
	KINT_KRCTL_KRMD_Msk = 0x80
	// Bit KRMD.
	KINT_KRCTL_KRMD = 0x80
	// Do not use key interrupt flags
	KINT_KRCTL_KRMD_0 = 0x0
	// Use key interrupt flags
	KINT_KRCTL_KRMD_1 = 0x1

	// KRF: Key Return Flag Register
	// Position of KIF0 field.
	KINT_KRF_KIF0_Pos = 0x0
	// Bit mask of KIF0 field.
	KINT_KRF_KIF0_Msk = 0x1
	// Bit KIF0.
	KINT_KRF_KIF0 = 0x1
	// No interrupt detected
	KINT_KRF_KIF0_0 = 0x0
	// Interrupt detected
	KINT_KRF_KIF0_1 = 0x1
	// Position of KIF1 field.
	KINT_KRF_KIF1_Pos = 0x1
	// Bit mask of KIF1 field.
	KINT_KRF_KIF1_Msk = 0x2
	// Bit KIF1.
	KINT_KRF_KIF1 = 0x2
	// No interrupt detected
	KINT_KRF_KIF1_0 = 0x0
	// Interrupt detected
	KINT_KRF_KIF1_1 = 0x1
	// Position of KIF2 field.
	KINT_KRF_KIF2_Pos = 0x2
	// Bit mask of KIF2 field.
	KINT_KRF_KIF2_Msk = 0x4
	// Bit KIF2.
	KINT_KRF_KIF2 = 0x4
	// No interrupt detected
	KINT_KRF_KIF2_0 = 0x0
	// Interrupt detected
	KINT_KRF_KIF2_1 = 0x1
	// Position of KIF3 field.
	KINT_KRF_KIF3_Pos = 0x3
	// Bit mask of KIF3 field.
	KINT_KRF_KIF3_Msk = 0x8
	// Bit KIF3.
	KINT_KRF_KIF3 = 0x8
	// No interrupt detected
	KINT_KRF_KIF3_0 = 0x0
	// Interrupt detected
	KINT_KRF_KIF3_1 = 0x1
	// Position of KIF4 field.
	KINT_KRF_KIF4_Pos = 0x4
	// Bit mask of KIF4 field.
	KINT_KRF_KIF4_Msk = 0x10
	// Bit KIF4.
	KINT_KRF_KIF4 = 0x10
	// No interrupt detected
	KINT_KRF_KIF4_0 = 0x0
	// Interrupt detected
	KINT_KRF_KIF4_1 = 0x1
	// Position of KIF5 field.
	KINT_KRF_KIF5_Pos = 0x5
	// Bit mask of KIF5 field.
	KINT_KRF_KIF5_Msk = 0x20
	// Bit KIF5.
	KINT_KRF_KIF5 = 0x20
	// No interrupt detected
	KINT_KRF_KIF5_0 = 0x0
	// Interrupt detected
	KINT_KRF_KIF5_1 = 0x1
	// Position of KIF6 field.
	KINT_KRF_KIF6_Pos = 0x6
	// Bit mask of KIF6 field.
	KINT_KRF_KIF6_Msk = 0x40
	// Bit KIF6.
	KINT_KRF_KIF6 = 0x40
	// No interrupt detected
	KINT_KRF_KIF6_0 = 0x0
	// Interrupt detected
	KINT_KRF_KIF6_1 = 0x1
	// Position of KIF7 field.
	KINT_KRF_KIF7_Pos = 0x7
	// Bit mask of KIF7 field.
	KINT_KRF_KIF7_Msk = 0x80
	// Bit KIF7.
	KINT_KRF_KIF7 = 0x80
	// No interrupt detected
	KINT_KRF_KIF7_0 = 0x0
	// Interrupt detected
	KINT_KRF_KIF7_1 = 0x1

	// KRM: Key Return Mode Register
	// Position of KIMC0 field.
	KINT_KRM_KIMC0_Pos = 0x0
	// Bit mask of KIMC0 field.
	KINT_KRM_KIMC0_Msk = 0x1
	// Bit KIMC0.
	KINT_KRM_KIMC0 = 0x1
	// Do not detect key interrupt signals
	KINT_KRM_KIMC0_0 = 0x0
	// Detect key interrupt signals
	KINT_KRM_KIMC0_1 = 0x1
	// Position of KIMC1 field.
	KINT_KRM_KIMC1_Pos = 0x1
	// Bit mask of KIMC1 field.
	KINT_KRM_KIMC1_Msk = 0x2
	// Bit KIMC1.
	KINT_KRM_KIMC1 = 0x2
	// Do not detect key interrupt signals
	KINT_KRM_KIMC1_0 = 0x0
	// Detect key interrupt signals
	KINT_KRM_KIMC1_1 = 0x1
	// Position of KIMC2 field.
	KINT_KRM_KIMC2_Pos = 0x2
	// Bit mask of KIMC2 field.
	KINT_KRM_KIMC2_Msk = 0x4
	// Bit KIMC2.
	KINT_KRM_KIMC2 = 0x4
	// Do not detect key interrupt signals
	KINT_KRM_KIMC2_0 = 0x0
	// Detect key interrupt signals
	KINT_KRM_KIMC2_1 = 0x1
	// Position of KIMC3 field.
	KINT_KRM_KIMC3_Pos = 0x3
	// Bit mask of KIMC3 field.
	KINT_KRM_KIMC3_Msk = 0x8
	// Bit KIMC3.
	KINT_KRM_KIMC3 = 0x8
	// Do not detect key interrupt signals
	KINT_KRM_KIMC3_0 = 0x0
	// Detect key interrupt signals
	KINT_KRM_KIMC3_1 = 0x1
	// Position of KIMC4 field.
	KINT_KRM_KIMC4_Pos = 0x4
	// Bit mask of KIMC4 field.
	KINT_KRM_KIMC4_Msk = 0x10
	// Bit KIMC4.
	KINT_KRM_KIMC4 = 0x10
	// Do not detect key interrupt signals
	KINT_KRM_KIMC4_0 = 0x0
	// Detect key interrupt signals
	KINT_KRM_KIMC4_1 = 0x1
	// Position of KIMC5 field.
	KINT_KRM_KIMC5_Pos = 0x5
	// Bit mask of KIMC5 field.
	KINT_KRM_KIMC5_Msk = 0x20
	// Bit KIMC5.
	KINT_KRM_KIMC5 = 0x20
	// Do not detect key interrupt signals
	KINT_KRM_KIMC5_0 = 0x0
	// Detect key interrupt signals
	KINT_KRM_KIMC5_1 = 0x1
	// Position of KIMC6 field.
	KINT_KRM_KIMC6_Pos = 0x6
	// Bit mask of KIMC6 field.
	KINT_KRM_KIMC6_Msk = 0x40
	// Bit KIMC6.
	KINT_KRM_KIMC6 = 0x40
	// Do not detect key interrupt signals
	KINT_KRM_KIMC6_0 = 0x0
	// Detect key interrupt signals
	KINT_KRM_KIMC6_1 = 0x1
	// Position of KIMC7 field.
	KINT_KRM_KIMC7_Pos = 0x7
	// Bit mask of KIMC7 field.
	KINT_KRM_KIMC7_Msk = 0x80
	// Bit KIMC7.
	KINT_KRM_KIMC7 = 0x80
	// Do not detect key interrupt signals
	KINT_KRM_KIMC7_0 = 0x0
	// Detect key interrupt signals
	KINT_KRM_KIMC7_1 = 0x1
)

// Constants for CTSU: Capacitive Touch Sensing Unit
const (
	// CTSUCRA: CTSU Control Register A
	// Position of STRT field.
	CTSU_CTSUCRA_STRT_Pos = 0x0
	// Bit mask of STRT field.
	CTSU_CTSUCRA_STRT_Msk = 0x1
	// Bit STRT.
	CTSU_CTSUCRA_STRT = 0x1
	// Stop measurement operation
	CTSU_CTSUCRA_STRT_0 = 0x0
	// Start measurement operation
	CTSU_CTSUCRA_STRT_1 = 0x1
	// Position of CAP field.
	CTSU_CTSUCRA_CAP_Pos = 0x1
	// Bit mask of CAP field.
	CTSU_CTSUCRA_CAP_Msk = 0x2
	// Bit CAP.
	CTSU_CTSUCRA_CAP = 0x2
	// Software trigger
	CTSU_CTSUCRA_CAP_0 = 0x0
	// External trigger
	CTSU_CTSUCRA_CAP_1 = 0x1
	// Position of SNZ field.
	CTSU_CTSUCRA_SNZ_Pos = 0x2
	// Bit mask of SNZ field.
	CTSU_CTSUCRA_SNZ_Msk = 0x4
	// Bit SNZ.
	CTSU_CTSUCRA_SNZ = 0x4
	// Disable power-saving function during wait state
	CTSU_CTSUCRA_SNZ_0 = 0x0
	// Enable power-saving function during wait state
	CTSU_CTSUCRA_SNZ_1 = 0x1
	// Position of CFCON field.
	CTSU_CTSUCRA_CFCON_Pos = 0x3
	// Bit mask of CFCON field.
	CTSU_CTSUCRA_CFCON_Msk = 0x8
	// Bit CFCON.
	CTSU_CTSUCRA_CFCON = 0x8
	// CFC power off
	CTSU_CTSUCRA_CFCON_0 = 0x0
	// CFC power on
	CTSU_CTSUCRA_CFCON_1 = 0x1
	// Position of INIT field.
	CTSU_CTSUCRA_INIT_Pos = 0x4
	// Bit mask of INIT field.
	CTSU_CTSUCRA_INIT_Msk = 0x10
	// Bit INIT.
	CTSU_CTSUCRA_INIT = 0x10
	// Position of PUMPON field.
	CTSU_CTSUCRA_PUMPON_Pos = 0x5
	// Bit mask of PUMPON field.
	CTSU_CTSUCRA_PUMPON_Msk = 0x20
	// Bit PUMPON.
	CTSU_CTSUCRA_PUMPON = 0x20
	// Boost circuit off
	CTSU_CTSUCRA_PUMPON_0 = 0x0
	// Boost circuit on
	CTSU_CTSUCRA_PUMPON_1 = 0x1
	// Position of TXVSEL field.
	CTSU_CTSUCRA_TXVSEL_Pos = 0x6
	// Bit mask of TXVSEL field.
	CTSU_CTSUCRA_TXVSEL_Msk = 0xc0
	// Selecting VCC as the power supply for the transmit pins of mutual capacitance method.
	CTSU_CTSUCRA_TXVSEL_00 = 0x0
	// Selecting VCC as the power supply for the transmit pins of the mutual capacitance method. In addition, noise is reduced during GPIO operation. (Recommended)
	CTSU_CTSUCRA_TXVSEL_01 = 0x1
	// Select VCC as the power source for the transmitter pins used as the active shield.
	CTSU_CTSUCRA_TXVSEL_10 = 0x2
	// Setting prohibited
	CTSU_CTSUCRA_TXVSEL_11 = 0x3
	// Position of PON field.
	CTSU_CTSUCRA_PON_Pos = 0x8
	// Bit mask of PON field.
	CTSU_CTSUCRA_PON_Msk = 0x100
	// Bit PON.
	CTSU_CTSUCRA_PON = 0x100
	// Power off the CTSU
	CTSU_CTSUCRA_PON_0 = 0x0
	// Power on the CTSU
	CTSU_CTSUCRA_PON_1 = 0x1
	// Position of CSW field.
	CTSU_CTSUCRA_CSW_Pos = 0x9
	// Bit mask of CSW field.
	CTSU_CTSUCRA_CSW_Msk = 0x200
	// Bit CSW.
	CTSU_CTSUCRA_CSW = 0x200
	// Disable
	CTSU_CTSUCRA_CSW_0 = 0x0
	// Enable
	CTSU_CTSUCRA_CSW_1 = 0x1
	// Position of ATUNE0 field.
	CTSU_CTSUCRA_ATUNE0_Pos = 0xa
	// Bit mask of ATUNE0 field.
	CTSU_CTSUCRA_ATUNE0_Msk = 0x400
	// Bit ATUNE0.
	CTSU_CTSUCRA_ATUNE0 = 0x400
	// VCC ≥ 2.4 V: Normal voltage operating mode VCC < 2.4 V: Setting prohibited
	CTSU_CTSUCRA_ATUNE0_0 = 0x0
	// Low-voltage operating mode
	CTSU_CTSUCRA_ATUNE0_1 = 0x1
	// Position of ATUNE1 field.
	CTSU_CTSUCRA_ATUNE1_Pos = 0xb
	// Bit mask of ATUNE1 field.
	CTSU_CTSUCRA_ATUNE1_Msk = 0x800
	// Bit ATUNE1.
	CTSU_CTSUCRA_ATUNE1 = 0x800
	// 80 µA when ATUNE2 = 0 20 µA when ATUNE2 = 1
	CTSU_CTSUCRA_ATUNE1_0 = 0x0
	// 40 µA when ATUNE2 = 0 160 µA when ATUNE2 = 1
	CTSU_CTSUCRA_ATUNE1_1 = 0x1
	// Position of CLK field.
	CTSU_CTSUCRA_CLK_Pos = 0xc
	// Bit mask of CLK field.
	CTSU_CTSUCRA_CLK_Msk = 0x3000
	// PCLKB
	CTSU_CTSUCRA_CLK_00 = 0x0
	// PCLKB/2 (PCLKB divided by 2)
	CTSU_CTSUCRA_CLK_01 = 0x1
	// PCLKB/4 (PCLKB divided by 4)
	CTSU_CTSUCRA_CLK_10 = 0x2
	// PCLKB/8 (PCLKB divided by 8)
	CTSU_CTSUCRA_CLK_11 = 0x3
	// Position of MD0 field.
	CTSU_CTSUCRA_MD0_Pos = 0xe
	// Bit mask of MD0 field.
	CTSU_CTSUCRA_MD0_Msk = 0x4000
	// Bit MD0.
	CTSU_CTSUCRA_MD0 = 0x4000
	// Single scan mode
	CTSU_CTSUCRA_MD0_0 = 0x0
	// Multi-scan mode
	CTSU_CTSUCRA_MD0_1 = 0x1
	// Position of MD1 field.
	CTSU_CTSUCRA_MD1_Pos = 0xf
	// Bit mask of MD1 field.
	CTSU_CTSUCRA_MD1_Msk = 0x8000
	// Bit MD1.
	CTSU_CTSUCRA_MD1 = 0x8000
	// One-time measurement (self-capacitance method)
	CTSU_CTSUCRA_MD1_0 = 0x0
	// Two times measurement (mutual capacitance method)
	CTSU_CTSUCRA_MD1_1 = 0x1
	// Position of MD2 field.
	CTSU_CTSUCRA_MD2_Pos = 0x10
	// Bit mask of MD2 field.
	CTSU_CTSUCRA_MD2_Msk = 0x10000
	// Bit MD2.
	CTSU_CTSUCRA_MD2 = 0x10000
	// Measure the switched capacitor current and the DC current
	CTSU_CTSUCRA_MD2_0 = 0x0
	// Measure the charge transfer by CFC circuit (parallel measurement)
	CTSU_CTSUCRA_MD2_1 = 0x1
	// Position of ATUNE2 field.
	CTSU_CTSUCRA_ATUNE2_Pos = 0x11
	// Bit mask of ATUNE2 field.
	CTSU_CTSUCRA_ATUNE2_Msk = 0x20000
	// Bit ATUNE2.
	CTSU_CTSUCRA_ATUNE2 = 0x20000
	// 80 µA when ATUNE1 = 0 40 µA when ATUNE1 = 1
	CTSU_CTSUCRA_ATUNE2_0 = 0x0
	// 20 µA when ATUNE1 = 0 160 µA when ATUNE1 = 1
	CTSU_CTSUCRA_ATUNE2_1 = 0x1
	// Position of LOAD field.
	CTSU_CTSUCRA_LOAD_Pos = 0x12
	// Bit mask of LOAD field.
	CTSU_CTSUCRA_LOAD_Msk = 0xc0000
	// 2.5 µA constant current load
	CTSU_CTSUCRA_LOAD_00 = 0x0
	// No load
	CTSU_CTSUCRA_LOAD_01 = 0x1
	// 20 µA constant current load and overcurrent detector disabled
	CTSU_CTSUCRA_LOAD_10 = 0x2
	// Resistance load for calibration. To set LOAD[1:0] bits to resistance load for calibration, set these bits to 10b before they are set to 11b.
	CTSU_CTSUCRA_LOAD_11 = 0x3
	// Position of POSEL field.
	CTSU_CTSUCRA_POSEL_Pos = 0x14
	// Bit mask of POSEL field.
	CTSU_CTSUCRA_POSEL_Msk = 0x300000
	// Output low
	CTSU_CTSUCRA_POSEL_00 = 0x0
	// Hi-Z
	CTSU_CTSUCRA_POSEL_01 = 0x1
	// Setting prohibited
	CTSU_CTSUCRA_POSEL_10 = 0x2
	// Output a pulse in phase with the transmit channel
	CTSU_CTSUCRA_POSEL_11 = 0x3
	// Position of SDPSEL field.
	CTSU_CTSUCRA_SDPSEL_Pos = 0x16
	// Bit mask of SDPSEL field.
	CTSU_CTSUCRA_SDPSEL_Msk = 0x400000
	// Bit SDPSEL.
	CTSU_CTSUCRA_SDPSEL = 0x400000
	// Random pulse
	CTSU_CTSUCRA_SDPSEL_0 = 0x0
	// Normal pulse using the sensor unit clock
	CTSU_CTSUCRA_SDPSEL_1 = 0x1
	// Position of PCSEL field.
	CTSU_CTSUCRA_PCSEL_Pos = 0x17
	// Bit mask of PCSEL field.
	CTSU_CTSUCRA_PCSEL_Msk = 0x800000
	// Bit PCSEL.
	CTSU_CTSUCRA_PCSEL = 0x800000
	// Sensor drive pulse divided by 2
	CTSU_CTSUCRA_PCSEL_0 = 0x0
	// STCLK
	CTSU_CTSUCRA_PCSEL_1 = 0x1
	// Position of STCLK field.
	CTSU_CTSUCRA_STCLK_Pos = 0x18
	// Bit mask of STCLK field.
	CTSU_CTSUCRA_STCLK_Msk = 0x3f000000
	// Position of DCMODE field.
	CTSU_CTSUCRA_DCMODE_Pos = 0x1e
	// Bit mask of DCMODE field.
	CTSU_CTSUCRA_DCMODE_Msk = 0x40000000
	// Bit DCMODE.
	CTSU_CTSUCRA_DCMODE = 0x40000000
	// Electrostatic capacitance measurement mode
	CTSU_CTSUCRA_DCMODE_0 = 0x0
	// Current measurement mode
	CTSU_CTSUCRA_DCMODE_1 = 0x1
	// Position of DCBACK field.
	CTSU_CTSUCRA_DCBACK_Pos = 0x1f
	// Bit mask of DCBACK field.
	CTSU_CTSUCRA_DCBACK_Msk = 0x80000000
	// Bit DCBACK.
	CTSU_CTSUCRA_DCBACK = 0x80000000
	// TSCAP pin is selected
	CTSU_CTSUCRA_DCBACK_0 = 0x0
	// Measurement pin is selected. It is recommended in the current measurement mode.
	CTSU_CTSUCRA_DCBACK_1 = 0x1

	// CTSUCRB: CTSU Control Register B
	// Position of PRRATIO field.
	CTSU_CTSUCRB_PRRATIO_Pos = 0x0
	// Bit mask of PRRATIO field.
	CTSU_CTSUCRB_PRRATIO_Msk = 0xf
	// Position of PRMODE field.
	CTSU_CTSUCRB_PRMODE_Pos = 0x4
	// Bit mask of PRMODE field.
	CTSU_CTSUCRB_PRMODE_Msk = 0x30
	// 510 pulses (512 pulses when PROFF = 1)
	CTSU_CTSUCRB_PRMODE_00 = 0x0
	// 126 pulses (128 pulses when PROFF = 1)
	CTSU_CTSUCRB_PRMODE_01 = 0x1
	// 62 pulses (64 pulses when PROFF = 1)
	CTSU_CTSUCRB_PRMODE_10 = 0x2
	// Setting prohibited
	CTSU_CTSUCRB_PRMODE_11 = 0x3
	// Position of SOFF field.
	CTSU_CTSUCRB_SOFF_Pos = 0x6
	// Bit mask of SOFF field.
	CTSU_CTSUCRB_SOFF_Msk = 0x40
	// Bit SOFF.
	CTSU_CTSUCRB_SOFF = 0x40
	// Turn the spread spectrum on
	CTSU_CTSUCRB_SOFF_0 = 0x0
	// Turn the spread spectrum off
	CTSU_CTSUCRB_SOFF_1 = 0x1
	// Position of PROFF field.
	CTSU_CTSUCRB_PROFF_Pos = 0x7
	// Bit mask of PROFF field.
	CTSU_CTSUCRB_PROFF_Msk = 0x80
	// Bit PROFF.
	CTSU_CTSUCRB_PROFF = 0x80
	// The drive pulse phase is controlled by random numbers.
	CTSU_CTSUCRB_PROFF_0 = 0x0
	// The drive pulse phase is not controlled by random numbers.
	CTSU_CTSUCRB_PROFF_1 = 0x1
	// Position of SST field.
	CTSU_CTSUCRB_SST_Pos = 0x8
	// Bit mask of SST field.
	CTSU_CTSUCRB_SST_Msk = 0xff00
	// Position of SSMOD field.
	CTSU_CTSUCRB_SSMOD_Pos = 0x18
	// Bit mask of SSMOD field.
	CTSU_CTSUCRB_SSMOD_Msk = 0x7000000
	// 125 kHz (recommended)
	CTSU_CTSUCRB_SSMOD_000 = 0x0
	// 83.3 kHz
	CTSU_CTSUCRB_SSMOD_001 = 0x1
	// 62.5 kHz
	CTSU_CTSUCRB_SSMOD_010 = 0x2
	// 31.3 kHz
	CTSU_CTSUCRB_SSMOD_011 = 0x3
	// Position of SSCNT field.
	CTSU_CTSUCRB_SSCNT_Pos = 0x1c
	// Bit mask of SSCNT field.
	CTSU_CTSUCRB_SSCNT_Msk = 0x30000000
	// CTSUTRIMA.SUADJD + 0x00 (SDPSEL = 0) CTSUSUCLKx.SUADJDn + 0x00 (SDPSEL = 1)
	CTSU_CTSUCRB_SSCNT_00 = 0x0
	// CTSUTRIMA.SUADJD + 0x10 (SDPSEL = 0) CTSUSUCLKx.SUADJDn + 0x20 (SDPSEL = 1)
	CTSU_CTSUCRB_SSCNT_01 = 0x1
	// CTSUTRIMA.SUADJD + 0x20 (SDPSEL = 0) CTSUSUCLKx.SUADJDn + 0x40 (SDPSEL = 1)
	CTSU_CTSUCRB_SSCNT_10 = 0x2
	// CTSUTRIMA.SUADJD + 0x30 (SDPSEL = 0) CTSUSUCLKx.SUADJDn + 0x40 (SDPSEL = 1)
	CTSU_CTSUCRB_SSCNT_11 = 0x3

	// CTSUMCH: CTSU Measurement Channel Register
	// Position of MCH0 field.
	CTSU_CTSUMCH_MCH0_Pos = 0x0
	// Bit mask of MCH0 field.
	CTSU_CTSUMCH_MCH0_Msk = 0x3f
	// TS00
	CTSU_CTSUMCH_MCH0_0x00 = 0x0
	// TS02
	CTSU_CTSUMCH_MCH0_0x02 = 0x2
	// TS04
	CTSU_CTSUMCH_MCH0_0x04 = 0x4
	// TS05
	CTSU_CTSUMCH_MCH0_0x05 = 0x5
	// TS06
	CTSU_CTSUMCH_MCH0_0x06 = 0x6
	// TS07
	CTSU_CTSUMCH_MCH0_0x07 = 0x7
	// TS08
	CTSU_CTSUMCH_MCH0_0x08 = 0x8
	// TS09
	CTSU_CTSUMCH_MCH0_0x09 = 0x9
	// TS10
	CTSU_CTSUMCH_MCH0_0x0A = 0xa
	// TS11
	CTSU_CTSUMCH_MCH0_0x0B = 0xb
	// TS12
	CTSU_CTSUMCH_MCH0_0x0C = 0xc
	// TS13
	CTSU_CTSUMCH_MCH0_0x0D = 0xd
	// TS14
	CTSU_CTSUMCH_MCH0_0x0E = 0xe
	// TS15
	CTSU_CTSUMCH_MCH0_0x0F = 0xf
	// TS16
	CTSU_CTSUMCH_MCH0_0x10 = 0x10
	// TS17
	CTSU_CTSUMCH_MCH0_0x11 = 0x11
	// TS18
	CTSU_CTSUMCH_MCH0_0x12 = 0x12
	// TS21
	CTSU_CTSUMCH_MCH0_0x15 = 0x15
	// TS22
	CTSU_CTSUMCH_MCH0_0x16 = 0x16
	// TS23
	CTSU_CTSUMCH_MCH0_0x17 = 0x17
	// TS24
	CTSU_CTSUMCH_MCH0_0x18 = 0x18
	// TS25
	CTSU_CTSUMCH_MCH0_0x19 = 0x19
	// TS26
	CTSU_CTSUMCH_MCH0_0x1A = 0x1a
	// TS27
	CTSU_CTSUMCH_MCH0_0x1B = 0x1b
	// TS28
	CTSU_CTSUMCH_MCH0_0x1C = 0x1c
	// TS29
	CTSU_CTSUMCH_MCH0_0x1D = 0x1d
	// TS30
	CTSU_CTSUMCH_MCH0_0x1E = 0x1e
	// TS31
	CTSU_CTSUMCH_MCH0_0x1F = 0x1f
	// TS32
	CTSU_CTSUMCH_MCH0_0x20 = 0x20
	// TS33
	CTSU_CTSUMCH_MCH0_0x21 = 0x21
	// TS34
	CTSU_CTSUMCH_MCH0_0x22 = 0x22
	// TS35
	CTSU_CTSUMCH_MCH0_0x23 = 0x23
	// Measurement is being stopped.
	CTSU_CTSUMCH_MCH0_0x3F = 0x3f
	// Position of MCH1 field.
	CTSU_CTSUMCH_MCH1_Pos = 0x8
	// Bit mask of MCH1 field.
	CTSU_CTSUMCH_MCH1_Msk = 0x3f00
	// TS00
	CTSU_CTSUMCH_MCH1_0x00 = 0x0
	// TS02
	CTSU_CTSUMCH_MCH1_0x02 = 0x2
	// TS04
	CTSU_CTSUMCH_MCH1_0x04 = 0x4
	// TS05
	CTSU_CTSUMCH_MCH1_0x05 = 0x5
	// TS06
	CTSU_CTSUMCH_MCH1_0x06 = 0x6
	// TS07
	CTSU_CTSUMCH_MCH1_0x07 = 0x7
	// TS08
	CTSU_CTSUMCH_MCH1_0x08 = 0x8
	// TS09
	CTSU_CTSUMCH_MCH1_0x09 = 0x9
	// TS10
	CTSU_CTSUMCH_MCH1_0x0A = 0xa
	// TS11
	CTSU_CTSUMCH_MCH1_0x0B = 0xb
	// TS12
	CTSU_CTSUMCH_MCH1_0x0C = 0xc
	// TS13
	CTSU_CTSUMCH_MCH1_0x0D = 0xd
	// TS14
	CTSU_CTSUMCH_MCH1_0x0E = 0xe
	// TS15
	CTSU_CTSUMCH_MCH1_0x0F = 0xf
	// TS16
	CTSU_CTSUMCH_MCH1_0x10 = 0x10
	// TS17
	CTSU_CTSUMCH_MCH1_0x11 = 0x11
	// TS18
	CTSU_CTSUMCH_MCH1_0x12 = 0x12
	// TS21
	CTSU_CTSUMCH_MCH1_0x15 = 0x15
	// TS22
	CTSU_CTSUMCH_MCH1_0x16 = 0x16
	// TS23
	CTSU_CTSUMCH_MCH1_0x17 = 0x17
	// TS24
	CTSU_CTSUMCH_MCH1_0x18 = 0x18
	// TS25
	CTSU_CTSUMCH_MCH1_0x19 = 0x19
	// TS26
	CTSU_CTSUMCH_MCH1_0x1A = 0x1a
	// TS27
	CTSU_CTSUMCH_MCH1_0x1B = 0x1b
	// TS28
	CTSU_CTSUMCH_MCH1_0x1C = 0x1c
	// TS29
	CTSU_CTSUMCH_MCH1_0x1D = 0x1d
	// TS30
	CTSU_CTSUMCH_MCH1_0x1E = 0x1e
	// TS31
	CTSU_CTSUMCH_MCH1_0x1F = 0x1f
	// TS32
	CTSU_CTSUMCH_MCH1_0x20 = 0x20
	// TS33
	CTSU_CTSUMCH_MCH1_0x21 = 0x21
	// TS34
	CTSU_CTSUMCH_MCH1_0x22 = 0x22
	// TS35
	CTSU_CTSUMCH_MCH1_0x23 = 0x23
	// Measurement is being stopped.
	CTSU_CTSUMCH_MCH1_0x3F = 0x3f
	// Position of MCA0 field.
	CTSU_CTSUMCH_MCA0_Pos = 0x10
	// Bit mask of MCA0 field.
	CTSU_CTSUMCH_MCA0_Msk = 0x10000
	// Bit MCA0.
	CTSU_CTSUMCH_MCA0 = 0x10000
	// Disable
	CTSU_CTSUMCH_MCA0_0 = 0x0
	// Enable
	CTSU_CTSUMCH_MCA0_1 = 0x1
	// Position of MCA1 field.
	CTSU_CTSUMCH_MCA1_Pos = 0x11
	// Bit mask of MCA1 field.
	CTSU_CTSUMCH_MCA1_Msk = 0x20000
	// Bit MCA1.
	CTSU_CTSUMCH_MCA1 = 0x20000
	// Disable
	CTSU_CTSUMCH_MCA1_0 = 0x0
	// Enable
	CTSU_CTSUMCH_MCA1_1 = 0x1
	// Position of MCA2 field.
	CTSU_CTSUMCH_MCA2_Pos = 0x12
	// Bit mask of MCA2 field.
	CTSU_CTSUMCH_MCA2_Msk = 0x40000
	// Bit MCA2.
	CTSU_CTSUMCH_MCA2 = 0x40000
	// Disable
	CTSU_CTSUMCH_MCA2_0 = 0x0
	// Enable
	CTSU_CTSUMCH_MCA2_1 = 0x1
	// Position of MCA3 field.
	CTSU_CTSUMCH_MCA3_Pos = 0x13
	// Bit mask of MCA3 field.
	CTSU_CTSUMCH_MCA3_Msk = 0x80000
	// Bit MCA3.
	CTSU_CTSUMCH_MCA3 = 0x80000
	// Disable
	CTSU_CTSUMCH_MCA3_0 = 0x0
	// Enable
	CTSU_CTSUMCH_MCA3_1 = 0x1

	// CTSUCHACA: CTSU Channel Enable Control Register A
	// Position of CHAC00 field.
	CTSU_CTSUCHACA_CHAC00_Pos = 0x0
	// Bit mask of CHAC00 field.
	CTSU_CTSUCHACA_CHAC00_Msk = 0x1
	// Bit CHAC00.
	CTSU_CTSUCHACA_CHAC00 = 0x1
	// Do not measure.
	CTSU_CTSUCHACA_CHAC00_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC00_1 = 0x1
	// Position of CHAC02 field.
	CTSU_CTSUCHACA_CHAC02_Pos = 0x2
	// Bit mask of CHAC02 field.
	CTSU_CTSUCHACA_CHAC02_Msk = 0x4
	// Bit CHAC02.
	CTSU_CTSUCHACA_CHAC02 = 0x4
	// Do not measure.
	CTSU_CTSUCHACA_CHAC02_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC02_1 = 0x1
	// Position of CHAC04 field.
	CTSU_CTSUCHACA_CHAC04_Pos = 0x4
	// Bit mask of CHAC04 field.
	CTSU_CTSUCHACA_CHAC04_Msk = 0x10
	// Bit CHAC04.
	CTSU_CTSUCHACA_CHAC04 = 0x10
	// Do not measure.
	CTSU_CTSUCHACA_CHAC04_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC04_1 = 0x1
	// Position of CHAC05 field.
	CTSU_CTSUCHACA_CHAC05_Pos = 0x5
	// Bit mask of CHAC05 field.
	CTSU_CTSUCHACA_CHAC05_Msk = 0x20
	// Bit CHAC05.
	CTSU_CTSUCHACA_CHAC05 = 0x20
	// Do not measure.
	CTSU_CTSUCHACA_CHAC05_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC05_1 = 0x1
	// Position of CHAC06 field.
	CTSU_CTSUCHACA_CHAC06_Pos = 0x6
	// Bit mask of CHAC06 field.
	CTSU_CTSUCHACA_CHAC06_Msk = 0x40
	// Bit CHAC06.
	CTSU_CTSUCHACA_CHAC06 = 0x40
	// Do not measure.
	CTSU_CTSUCHACA_CHAC06_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC06_1 = 0x1
	// Position of CHAC07 field.
	CTSU_CTSUCHACA_CHAC07_Pos = 0x7
	// Bit mask of CHAC07 field.
	CTSU_CTSUCHACA_CHAC07_Msk = 0x80
	// Bit CHAC07.
	CTSU_CTSUCHACA_CHAC07 = 0x80
	// Do not measure.
	CTSU_CTSUCHACA_CHAC07_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC07_1 = 0x1
	// Position of CHAC08 field.
	CTSU_CTSUCHACA_CHAC08_Pos = 0x8
	// Bit mask of CHAC08 field.
	CTSU_CTSUCHACA_CHAC08_Msk = 0x100
	// Bit CHAC08.
	CTSU_CTSUCHACA_CHAC08 = 0x100
	// Do not measure.
	CTSU_CTSUCHACA_CHAC08_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC08_1 = 0x1
	// Position of CHAC09 field.
	CTSU_CTSUCHACA_CHAC09_Pos = 0x9
	// Bit mask of CHAC09 field.
	CTSU_CTSUCHACA_CHAC09_Msk = 0x200
	// Bit CHAC09.
	CTSU_CTSUCHACA_CHAC09 = 0x200
	// Do not measure.
	CTSU_CTSUCHACA_CHAC09_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC09_1 = 0x1
	// Position of CHAC10 field.
	CTSU_CTSUCHACA_CHAC10_Pos = 0xa
	// Bit mask of CHAC10 field.
	CTSU_CTSUCHACA_CHAC10_Msk = 0x400
	// Bit CHAC10.
	CTSU_CTSUCHACA_CHAC10 = 0x400
	// Do not measure.
	CTSU_CTSUCHACA_CHAC10_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC10_1 = 0x1
	// Position of CHAC11 field.
	CTSU_CTSUCHACA_CHAC11_Pos = 0xb
	// Bit mask of CHAC11 field.
	CTSU_CTSUCHACA_CHAC11_Msk = 0x800
	// Bit CHAC11.
	CTSU_CTSUCHACA_CHAC11 = 0x800
	// Do not measure.
	CTSU_CTSUCHACA_CHAC11_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC11_1 = 0x1
	// Position of CHAC12 field.
	CTSU_CTSUCHACA_CHAC12_Pos = 0xc
	// Bit mask of CHAC12 field.
	CTSU_CTSUCHACA_CHAC12_Msk = 0x1000
	// Bit CHAC12.
	CTSU_CTSUCHACA_CHAC12 = 0x1000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC12_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC12_1 = 0x1
	// Position of CHAC13 field.
	CTSU_CTSUCHACA_CHAC13_Pos = 0xd
	// Bit mask of CHAC13 field.
	CTSU_CTSUCHACA_CHAC13_Msk = 0x2000
	// Bit CHAC13.
	CTSU_CTSUCHACA_CHAC13 = 0x2000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC13_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC13_1 = 0x1
	// Position of CHAC14 field.
	CTSU_CTSUCHACA_CHAC14_Pos = 0xe
	// Bit mask of CHAC14 field.
	CTSU_CTSUCHACA_CHAC14_Msk = 0x4000
	// Bit CHAC14.
	CTSU_CTSUCHACA_CHAC14 = 0x4000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC14_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC14_1 = 0x1
	// Position of CHAC15 field.
	CTSU_CTSUCHACA_CHAC15_Pos = 0xf
	// Bit mask of CHAC15 field.
	CTSU_CTSUCHACA_CHAC15_Msk = 0x8000
	// Bit CHAC15.
	CTSU_CTSUCHACA_CHAC15 = 0x8000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC15_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC15_1 = 0x1
	// Position of CHAC16 field.
	CTSU_CTSUCHACA_CHAC16_Pos = 0x10
	// Bit mask of CHAC16 field.
	CTSU_CTSUCHACA_CHAC16_Msk = 0x10000
	// Bit CHAC16.
	CTSU_CTSUCHACA_CHAC16 = 0x10000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC16_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC16_1 = 0x1
	// Position of CHAC17 field.
	CTSU_CTSUCHACA_CHAC17_Pos = 0x11
	// Bit mask of CHAC17 field.
	CTSU_CTSUCHACA_CHAC17_Msk = 0x20000
	// Bit CHAC17.
	CTSU_CTSUCHACA_CHAC17 = 0x20000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC17_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC17_1 = 0x1
	// Position of CHAC18 field.
	CTSU_CTSUCHACA_CHAC18_Pos = 0x12
	// Bit mask of CHAC18 field.
	CTSU_CTSUCHACA_CHAC18_Msk = 0x40000
	// Bit CHAC18.
	CTSU_CTSUCHACA_CHAC18 = 0x40000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC18_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC18_1 = 0x1
	// Position of CHAC21 field.
	CTSU_CTSUCHACA_CHAC21_Pos = 0x15
	// Bit mask of CHAC21 field.
	CTSU_CTSUCHACA_CHAC21_Msk = 0x200000
	// Bit CHAC21.
	CTSU_CTSUCHACA_CHAC21 = 0x200000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC21_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC21_1 = 0x1
	// Position of CHAC22 field.
	CTSU_CTSUCHACA_CHAC22_Pos = 0x16
	// Bit mask of CHAC22 field.
	CTSU_CTSUCHACA_CHAC22_Msk = 0x400000
	// Bit CHAC22.
	CTSU_CTSUCHACA_CHAC22 = 0x400000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC22_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC22_1 = 0x1
	// Position of CHAC23 field.
	CTSU_CTSUCHACA_CHAC23_Pos = 0x17
	// Bit mask of CHAC23 field.
	CTSU_CTSUCHACA_CHAC23_Msk = 0x800000
	// Bit CHAC23.
	CTSU_CTSUCHACA_CHAC23 = 0x800000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC23_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC23_1 = 0x1
	// Position of CHAC24 field.
	CTSU_CTSUCHACA_CHAC24_Pos = 0x18
	// Bit mask of CHAC24 field.
	CTSU_CTSUCHACA_CHAC24_Msk = 0x1000000
	// Bit CHAC24.
	CTSU_CTSUCHACA_CHAC24 = 0x1000000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC24_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC24_1 = 0x1
	// Position of CHAC25 field.
	CTSU_CTSUCHACA_CHAC25_Pos = 0x19
	// Bit mask of CHAC25 field.
	CTSU_CTSUCHACA_CHAC25_Msk = 0x2000000
	// Bit CHAC25.
	CTSU_CTSUCHACA_CHAC25 = 0x2000000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC25_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC25_1 = 0x1
	// Position of CHAC26 field.
	CTSU_CTSUCHACA_CHAC26_Pos = 0x1a
	// Bit mask of CHAC26 field.
	CTSU_CTSUCHACA_CHAC26_Msk = 0x4000000
	// Bit CHAC26.
	CTSU_CTSUCHACA_CHAC26 = 0x4000000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC26_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC26_1 = 0x1
	// Position of CHAC27 field.
	CTSU_CTSUCHACA_CHAC27_Pos = 0x1b
	// Bit mask of CHAC27 field.
	CTSU_CTSUCHACA_CHAC27_Msk = 0x8000000
	// Bit CHAC27.
	CTSU_CTSUCHACA_CHAC27 = 0x8000000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC27_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC27_1 = 0x1
	// Position of CHAC28 field.
	CTSU_CTSUCHACA_CHAC28_Pos = 0x1c
	// Bit mask of CHAC28 field.
	CTSU_CTSUCHACA_CHAC28_Msk = 0x10000000
	// Bit CHAC28.
	CTSU_CTSUCHACA_CHAC28 = 0x10000000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC28_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC28_1 = 0x1
	// Position of CHAC29 field.
	CTSU_CTSUCHACA_CHAC29_Pos = 0x1d
	// Bit mask of CHAC29 field.
	CTSU_CTSUCHACA_CHAC29_Msk = 0x20000000
	// Bit CHAC29.
	CTSU_CTSUCHACA_CHAC29 = 0x20000000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC29_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC29_1 = 0x1
	// Position of CHAC30 field.
	CTSU_CTSUCHACA_CHAC30_Pos = 0x1e
	// Bit mask of CHAC30 field.
	CTSU_CTSUCHACA_CHAC30_Msk = 0x40000000
	// Bit CHAC30.
	CTSU_CTSUCHACA_CHAC30 = 0x40000000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC30_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC30_1 = 0x1
	// Position of CHAC31 field.
	CTSU_CTSUCHACA_CHAC31_Pos = 0x1f
	// Bit mask of CHAC31 field.
	CTSU_CTSUCHACA_CHAC31_Msk = 0x80000000
	// Bit CHAC31.
	CTSU_CTSUCHACA_CHAC31 = 0x80000000
	// Do not measure.
	CTSU_CTSUCHACA_CHAC31_0 = 0x0
	// Measure.
	CTSU_CTSUCHACA_CHAC31_1 = 0x1

	// CTSUCHACB: CTSU Channel Enable Control Register B
	// Position of CHAC32 field.
	CTSU_CTSUCHACB_CHAC32_Pos = 0x0
	// Bit mask of CHAC32 field.
	CTSU_CTSUCHACB_CHAC32_Msk = 0x1
	// Bit CHAC32.
	CTSU_CTSUCHACB_CHAC32 = 0x1
	// Do not measure.
	CTSU_CTSUCHACB_CHAC32_0 = 0x0
	// Measure.
	CTSU_CTSUCHACB_CHAC32_1 = 0x1
	// Position of CHAC33 field.
	CTSU_CTSUCHACB_CHAC33_Pos = 0x1
	// Bit mask of CHAC33 field.
	CTSU_CTSUCHACB_CHAC33_Msk = 0x2
	// Bit CHAC33.
	CTSU_CTSUCHACB_CHAC33 = 0x2
	// Do not measure.
	CTSU_CTSUCHACB_CHAC33_0 = 0x0
	// Measure.
	CTSU_CTSUCHACB_CHAC33_1 = 0x1
	// Position of CHAC34 field.
	CTSU_CTSUCHACB_CHAC34_Pos = 0x2
	// Bit mask of CHAC34 field.
	CTSU_CTSUCHACB_CHAC34_Msk = 0x4
	// Bit CHAC34.
	CTSU_CTSUCHACB_CHAC34 = 0x4
	// Do not measure.
	CTSU_CTSUCHACB_CHAC34_0 = 0x0
	// Measure.
	CTSU_CTSUCHACB_CHAC34_1 = 0x1
	// Position of CHAC35 field.
	CTSU_CTSUCHACB_CHAC35_Pos = 0x3
	// Bit mask of CHAC35 field.
	CTSU_CTSUCHACB_CHAC35_Msk = 0x8
	// Bit CHAC35.
	CTSU_CTSUCHACB_CHAC35 = 0x8
	// Do not measure.
	CTSU_CTSUCHACB_CHAC35_0 = 0x0
	// Measure.
	CTSU_CTSUCHACB_CHAC35_1 = 0x1

	// CTSUCHTRCA: CTSU Channel Transmit/Receive Control Register A
	// Position of CHTRC00 field.
	CTSU_CTSUCHTRCA_CHTRC00_Pos = 0x0
	// Bit mask of CHTRC00 field.
	CTSU_CTSUCHTRCA_CHTRC00_Msk = 0x1
	// Bit CHTRC00.
	CTSU_CTSUCHTRCA_CHTRC00 = 0x1
	// Reception
	CTSU_CTSUCHTRCA_CHTRC00_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC00_1 = 0x1
	// Position of CHTRC02 field.
	CTSU_CTSUCHTRCA_CHTRC02_Pos = 0x2
	// Bit mask of CHTRC02 field.
	CTSU_CTSUCHTRCA_CHTRC02_Msk = 0x4
	// Bit CHTRC02.
	CTSU_CTSUCHTRCA_CHTRC02 = 0x4
	// Reception
	CTSU_CTSUCHTRCA_CHTRC02_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC02_1 = 0x1
	// Position of CHTRC04 field.
	CTSU_CTSUCHTRCA_CHTRC04_Pos = 0x4
	// Bit mask of CHTRC04 field.
	CTSU_CTSUCHTRCA_CHTRC04_Msk = 0x10
	// Bit CHTRC04.
	CTSU_CTSUCHTRCA_CHTRC04 = 0x10
	// Reception
	CTSU_CTSUCHTRCA_CHTRC04_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC04_1 = 0x1
	// Position of CHTRC05 field.
	CTSU_CTSUCHTRCA_CHTRC05_Pos = 0x5
	// Bit mask of CHTRC05 field.
	CTSU_CTSUCHTRCA_CHTRC05_Msk = 0x20
	// Bit CHTRC05.
	CTSU_CTSUCHTRCA_CHTRC05 = 0x20
	// Reception
	CTSU_CTSUCHTRCA_CHTRC05_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC05_1 = 0x1
	// Position of CHTRC06 field.
	CTSU_CTSUCHTRCA_CHTRC06_Pos = 0x6
	// Bit mask of CHTRC06 field.
	CTSU_CTSUCHTRCA_CHTRC06_Msk = 0x40
	// Bit CHTRC06.
	CTSU_CTSUCHTRCA_CHTRC06 = 0x40
	// Reception
	CTSU_CTSUCHTRCA_CHTRC06_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC06_1 = 0x1
	// Position of CHTRC07 field.
	CTSU_CTSUCHTRCA_CHTRC07_Pos = 0x7
	// Bit mask of CHTRC07 field.
	CTSU_CTSUCHTRCA_CHTRC07_Msk = 0x80
	// Bit CHTRC07.
	CTSU_CTSUCHTRCA_CHTRC07 = 0x80
	// Reception
	CTSU_CTSUCHTRCA_CHTRC07_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC07_1 = 0x1
	// Position of CHTRC08 field.
	CTSU_CTSUCHTRCA_CHTRC08_Pos = 0x8
	// Bit mask of CHTRC08 field.
	CTSU_CTSUCHTRCA_CHTRC08_Msk = 0x100
	// Bit CHTRC08.
	CTSU_CTSUCHTRCA_CHTRC08 = 0x100
	// Reception
	CTSU_CTSUCHTRCA_CHTRC08_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC08_1 = 0x1
	// Position of CHTRC09 field.
	CTSU_CTSUCHTRCA_CHTRC09_Pos = 0x9
	// Bit mask of CHTRC09 field.
	CTSU_CTSUCHTRCA_CHTRC09_Msk = 0x200
	// Bit CHTRC09.
	CTSU_CTSUCHTRCA_CHTRC09 = 0x200
	// Reception
	CTSU_CTSUCHTRCA_CHTRC09_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC09_1 = 0x1
	// Position of CHTRC10 field.
	CTSU_CTSUCHTRCA_CHTRC10_Pos = 0xa
	// Bit mask of CHTRC10 field.
	CTSU_CTSUCHTRCA_CHTRC10_Msk = 0x400
	// Bit CHTRC10.
	CTSU_CTSUCHTRCA_CHTRC10 = 0x400
	// Reception
	CTSU_CTSUCHTRCA_CHTRC10_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC10_1 = 0x1
	// Position of CHTRC11 field.
	CTSU_CTSUCHTRCA_CHTRC11_Pos = 0xb
	// Bit mask of CHTRC11 field.
	CTSU_CTSUCHTRCA_CHTRC11_Msk = 0x800
	// Bit CHTRC11.
	CTSU_CTSUCHTRCA_CHTRC11 = 0x800
	// Reception
	CTSU_CTSUCHTRCA_CHTRC11_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC11_1 = 0x1
	// Position of CHTRC12 field.
	CTSU_CTSUCHTRCA_CHTRC12_Pos = 0xc
	// Bit mask of CHTRC12 field.
	CTSU_CTSUCHTRCA_CHTRC12_Msk = 0x1000
	// Bit CHTRC12.
	CTSU_CTSUCHTRCA_CHTRC12 = 0x1000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC12_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC12_1 = 0x1
	// Position of CHTRC13 field.
	CTSU_CTSUCHTRCA_CHTRC13_Pos = 0xd
	// Bit mask of CHTRC13 field.
	CTSU_CTSUCHTRCA_CHTRC13_Msk = 0x2000
	// Bit CHTRC13.
	CTSU_CTSUCHTRCA_CHTRC13 = 0x2000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC13_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC13_1 = 0x1
	// Position of CHTRC14 field.
	CTSU_CTSUCHTRCA_CHTRC14_Pos = 0xe
	// Bit mask of CHTRC14 field.
	CTSU_CTSUCHTRCA_CHTRC14_Msk = 0x4000
	// Bit CHTRC14.
	CTSU_CTSUCHTRCA_CHTRC14 = 0x4000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC14_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC14_1 = 0x1
	// Position of CHTRC15 field.
	CTSU_CTSUCHTRCA_CHTRC15_Pos = 0xf
	// Bit mask of CHTRC15 field.
	CTSU_CTSUCHTRCA_CHTRC15_Msk = 0x8000
	// Bit CHTRC15.
	CTSU_CTSUCHTRCA_CHTRC15 = 0x8000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC15_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC15_1 = 0x1
	// Position of CHTRC16 field.
	CTSU_CTSUCHTRCA_CHTRC16_Pos = 0x10
	// Bit mask of CHTRC16 field.
	CTSU_CTSUCHTRCA_CHTRC16_Msk = 0x10000
	// Bit CHTRC16.
	CTSU_CTSUCHTRCA_CHTRC16 = 0x10000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC16_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC16_1 = 0x1
	// Position of CHTRC17 field.
	CTSU_CTSUCHTRCA_CHTRC17_Pos = 0x11
	// Bit mask of CHTRC17 field.
	CTSU_CTSUCHTRCA_CHTRC17_Msk = 0x20000
	// Bit CHTRC17.
	CTSU_CTSUCHTRCA_CHTRC17 = 0x20000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC17_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC17_1 = 0x1
	// Position of CHTRC18 field.
	CTSU_CTSUCHTRCA_CHTRC18_Pos = 0x12
	// Bit mask of CHTRC18 field.
	CTSU_CTSUCHTRCA_CHTRC18_Msk = 0x40000
	// Bit CHTRC18.
	CTSU_CTSUCHTRCA_CHTRC18 = 0x40000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC18_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC18_1 = 0x1
	// Position of CHTRC21 field.
	CTSU_CTSUCHTRCA_CHTRC21_Pos = 0x15
	// Bit mask of CHTRC21 field.
	CTSU_CTSUCHTRCA_CHTRC21_Msk = 0x200000
	// Bit CHTRC21.
	CTSU_CTSUCHTRCA_CHTRC21 = 0x200000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC21_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC21_1 = 0x1
	// Position of CHTRC22 field.
	CTSU_CTSUCHTRCA_CHTRC22_Pos = 0x16
	// Bit mask of CHTRC22 field.
	CTSU_CTSUCHTRCA_CHTRC22_Msk = 0x400000
	// Bit CHTRC22.
	CTSU_CTSUCHTRCA_CHTRC22 = 0x400000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC22_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC22_1 = 0x1
	// Position of CHTRC23 field.
	CTSU_CTSUCHTRCA_CHTRC23_Pos = 0x17
	// Bit mask of CHTRC23 field.
	CTSU_CTSUCHTRCA_CHTRC23_Msk = 0x800000
	// Bit CHTRC23.
	CTSU_CTSUCHTRCA_CHTRC23 = 0x800000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC23_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC23_1 = 0x1
	// Position of CHTRC24 field.
	CTSU_CTSUCHTRCA_CHTRC24_Pos = 0x18
	// Bit mask of CHTRC24 field.
	CTSU_CTSUCHTRCA_CHTRC24_Msk = 0x1000000
	// Bit CHTRC24.
	CTSU_CTSUCHTRCA_CHTRC24 = 0x1000000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC24_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC24_1 = 0x1
	// Position of CHTRC25 field.
	CTSU_CTSUCHTRCA_CHTRC25_Pos = 0x19
	// Bit mask of CHTRC25 field.
	CTSU_CTSUCHTRCA_CHTRC25_Msk = 0x2000000
	// Bit CHTRC25.
	CTSU_CTSUCHTRCA_CHTRC25 = 0x2000000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC25_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC25_1 = 0x1
	// Position of CHTRC26 field.
	CTSU_CTSUCHTRCA_CHTRC26_Pos = 0x1a
	// Bit mask of CHTRC26 field.
	CTSU_CTSUCHTRCA_CHTRC26_Msk = 0x4000000
	// Bit CHTRC26.
	CTSU_CTSUCHTRCA_CHTRC26 = 0x4000000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC26_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC26_1 = 0x1
	// Position of CHTRC27 field.
	CTSU_CTSUCHTRCA_CHTRC27_Pos = 0x1b
	// Bit mask of CHTRC27 field.
	CTSU_CTSUCHTRCA_CHTRC27_Msk = 0x8000000
	// Bit CHTRC27.
	CTSU_CTSUCHTRCA_CHTRC27 = 0x8000000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC27_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC27_1 = 0x1
	// Position of CHTRC28 field.
	CTSU_CTSUCHTRCA_CHTRC28_Pos = 0x1c
	// Bit mask of CHTRC28 field.
	CTSU_CTSUCHTRCA_CHTRC28_Msk = 0x10000000
	// Bit CHTRC28.
	CTSU_CTSUCHTRCA_CHTRC28 = 0x10000000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC28_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC28_1 = 0x1
	// Position of CHTRC29 field.
	CTSU_CTSUCHTRCA_CHTRC29_Pos = 0x1d
	// Bit mask of CHTRC29 field.
	CTSU_CTSUCHTRCA_CHTRC29_Msk = 0x20000000
	// Bit CHTRC29.
	CTSU_CTSUCHTRCA_CHTRC29 = 0x20000000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC29_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC29_1 = 0x1
	// Position of CHTRC30 field.
	CTSU_CTSUCHTRCA_CHTRC30_Pos = 0x1e
	// Bit mask of CHTRC30 field.
	CTSU_CTSUCHTRCA_CHTRC30_Msk = 0x40000000
	// Bit CHTRC30.
	CTSU_CTSUCHTRCA_CHTRC30 = 0x40000000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC30_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC30_1 = 0x1
	// Position of CHTRC31 field.
	CTSU_CTSUCHTRCA_CHTRC31_Pos = 0x1f
	// Bit mask of CHTRC31 field.
	CTSU_CTSUCHTRCA_CHTRC31_Msk = 0x80000000
	// Bit CHTRC31.
	CTSU_CTSUCHTRCA_CHTRC31 = 0x80000000
	// Reception
	CTSU_CTSUCHTRCA_CHTRC31_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCA_CHTRC31_1 = 0x1

	// CTSUCHTRCB: CTSU Channel Transmit/Receive Control Register B
	// Position of CHTRC32 field.
	CTSU_CTSUCHTRCB_CHTRC32_Pos = 0x0
	// Bit mask of CHTRC32 field.
	CTSU_CTSUCHTRCB_CHTRC32_Msk = 0x1
	// Bit CHTRC32.
	CTSU_CTSUCHTRCB_CHTRC32 = 0x1
	// Reception
	CTSU_CTSUCHTRCB_CHTRC32_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCB_CHTRC32_1 = 0x1
	// Position of CHTRC33 field.
	CTSU_CTSUCHTRCB_CHTRC33_Pos = 0x1
	// Bit mask of CHTRC33 field.
	CTSU_CTSUCHTRCB_CHTRC33_Msk = 0x2
	// Bit CHTRC33.
	CTSU_CTSUCHTRCB_CHTRC33 = 0x2
	// Reception
	CTSU_CTSUCHTRCB_CHTRC33_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCB_CHTRC33_1 = 0x1
	// Position of CHTRC34 field.
	CTSU_CTSUCHTRCB_CHTRC34_Pos = 0x2
	// Bit mask of CHTRC34 field.
	CTSU_CTSUCHTRCB_CHTRC34_Msk = 0x4
	// Bit CHTRC34.
	CTSU_CTSUCHTRCB_CHTRC34 = 0x4
	// Reception
	CTSU_CTSUCHTRCB_CHTRC34_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCB_CHTRC34_1 = 0x1
	// Position of CHTRC35 field.
	CTSU_CTSUCHTRCB_CHTRC35_Pos = 0x3
	// Bit mask of CHTRC35 field.
	CTSU_CTSUCHTRCB_CHTRC35_Msk = 0x8
	// Bit CHTRC35.
	CTSU_CTSUCHTRCB_CHTRC35 = 0x8
	// Reception
	CTSU_CTSUCHTRCB_CHTRC35_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRCB_CHTRC35_1 = 0x1

	// CTSUSR: CTSU Status Register
	// Position of MFC field.
	CTSU_CTSUSR_MFC_Pos = 0x0
	// Bit mask of MFC field.
	CTSU_CTSUSR_MFC_Msk = 0x3
	// Multi-clock 0
	CTSU_CTSUSR_MFC_00 = 0x0
	// Multi-clock 1
	CTSU_CTSUSR_MFC_01 = 0x1
	// Multi-clock 2
	CTSU_CTSUSR_MFC_10 = 0x2
	// Multi-clock 3
	CTSU_CTSUSR_MFC_11 = 0x3
	// Position of ICOMPRST field.
	CTSU_CTSUSR_ICOMPRST_Pos = 0x5
	// Bit mask of ICOMPRST field.
	CTSU_CTSUSR_ICOMPRST_Msk = 0x20
	// Bit ICOMPRST.
	CTSU_CTSUSR_ICOMPRST = 0x20
	// Position of ICOMP1 field.
	CTSU_CTSUSR_ICOMP1_Pos = 0x6
	// Bit mask of ICOMP1 field.
	CTSU_CTSUSR_ICOMP1_Msk = 0x40
	// Bit ICOMP1.
	CTSU_CTSUSR_ICOMP1 = 0x40
	// Normal sensor current
	CTSU_CTSUSR_ICOMP1_0 = 0x0
	// Abnormal sensor current
	CTSU_CTSUSR_ICOMP1_1 = 0x1
	// Position of ICOMP0 field.
	CTSU_CTSUSR_ICOMP0_Pos = 0x7
	// Bit mask of ICOMP0 field.
	CTSU_CTSUSR_ICOMP0_Msk = 0x80
	// Bit ICOMP0.
	CTSU_CTSUSR_ICOMP0 = 0x80
	// Normal TSCAP voltage
	CTSU_CTSUSR_ICOMP0_0 = 0x0
	// Abnormal TSCAP voltage
	CTSU_CTSUSR_ICOMP0_1 = 0x1
	// Position of STC field.
	CTSU_CTSUSR_STC_Pos = 0x8
	// Bit mask of STC field.
	CTSU_CTSUSR_STC_Msk = 0x700
	// Status 0
	CTSU_CTSUSR_STC_000 = 0x0
	// Status 1
	CTSU_CTSUSR_STC_001 = 0x1
	// Status 2
	CTSU_CTSUSR_STC_010 = 0x2
	// Status 3
	CTSU_CTSUSR_STC_011 = 0x3
	// Status 4
	CTSU_CTSUSR_STC_100 = 0x4
	// Status 5
	CTSU_CTSUSR_STC_101 = 0x5
	// Position of DTSR field.
	CTSU_CTSUSR_DTSR_Pos = 0xc
	// Bit mask of DTSR field.
	CTSU_CTSUSR_DTSR_Msk = 0x1000
	// Bit DTSR.
	CTSU_CTSUSR_DTSR = 0x1000
	// Read
	CTSU_CTSUSR_DTSR_0 = 0x0
	// Not read
	CTSU_CTSUSR_DTSR_1 = 0x1
	// Position of SENSOVF field.
	CTSU_CTSUSR_SENSOVF_Pos = 0xd
	// Bit mask of SENSOVF field.
	CTSU_CTSUSR_SENSOVF_Msk = 0x2000
	// Bit SENSOVF.
	CTSU_CTSUSR_SENSOVF = 0x2000
	// No overflow occurred
	CTSU_CTSUSR_SENSOVF_0 = 0x0
	// Overflow occurred
	CTSU_CTSUSR_SENSOVF_1 = 0x1
	// Position of SUOVF field.
	CTSU_CTSUSR_SUOVF_Pos = 0xe
	// Bit mask of SUOVF field.
	CTSU_CTSUSR_SUOVF_Msk = 0x4000
	// Bit SUOVF.
	CTSU_CTSUSR_SUOVF = 0x4000
	// No overflow occurred
	CTSU_CTSUSR_SUOVF_0 = 0x0
	// Overflow occurred
	CTSU_CTSUSR_SUOVF_1 = 0x1
	// Position of PS field.
	CTSU_CTSUSR_PS_Pos = 0xf
	// Bit mask of PS field.
	CTSU_CTSUSR_PS_Msk = 0x8000
	// Bit PS.
	CTSU_CTSUSR_PS = 0x8000
	// First measurement
	CTSU_CTSUSR_PS_0 = 0x0
	// Second measurement
	CTSU_CTSUSR_PS_1 = 0x1
	// Position of CFCRDCH field.
	CTSU_CTSUSR_CFCRDCH_Pos = 0x10
	// Bit mask of CFCRDCH field.
	CTSU_CTSUSR_CFCRDCH_Msk = 0x3f0000
	// TS00
	CTSU_CTSUSR_CFCRDCH_0x00 = 0x0
	// TS02 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x02 = 0x2
	// TS04
	CTSU_CTSUSR_CFCRDCH_0x04 = 0x4
	// TS05
	CTSU_CTSUSR_CFCRDCH_0x05 = 0x5
	// TS06
	CTSU_CTSUSR_CFCRDCH_0x06 = 0x6
	// TS07
	CTSU_CTSUSR_CFCRDCH_0x07 = 0x7
	// TS08 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x08 = 0x8
	// TS09 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x09 = 0x9
	// TS10 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x0A = 0xa
	// TS11 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x0B = 0xb
	// TS12 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x0C = 0xc
	// TS13 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x0D = 0xd
	// TS14 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x0E = 0xe
	// TS15 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x0F = 0xf
	// TS16 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x10 = 0x10
	// TS17
	CTSU_CTSUSR_CFCRDCH_0x11 = 0x11
	// TS18
	CTSU_CTSUSR_CFCRDCH_0x12 = 0x12
	// TS21
	CTSU_CTSUSR_CFCRDCH_0x15 = 0x15
	// TS22
	CTSU_CTSUSR_CFCRDCH_0x16 = 0x16
	// TS23
	CTSU_CTSUSR_CFCRDCH_0x17 = 0x17
	// TS24
	CTSU_CTSUSR_CFCRDCH_0x18 = 0x18
	// TS25
	CTSU_CTSUSR_CFCRDCH_0x19 = 0x19
	// TS26 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x1A = 0x1a
	// TS27 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x1B = 0x1b
	// TS28 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x1C = 0x1c
	// TS29 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x1D = 0x1d
	// TS30 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x1E = 0x1e
	// TS31 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x1F = 0x1f
	// TS32 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x20 = 0x20
	// TS33 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x21 = 0x21
	// TS34 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x22 = 0x22
	// TS35 (CFC)
	CTSU_CTSUSR_CFCRDCH_0x23 = 0x23

	// CTSUSO: CTSU Sensor Offset Register
	// Position of SO field.
	CTSU_CTSUSO_SO_Pos = 0x0
	// Bit mask of SO field.
	CTSU_CTSUSO_SO_Msk = 0x3ff
	// Position of SNUM field.
	CTSU_CTSUSO_SNUM_Pos = 0xa
	// Bit mask of SNUM field.
	CTSU_CTSUSO_SNUM_Msk = 0x3fc00
	// Position of SSDIV field.
	CTSU_CTSUSO_SSDIV_Pos = 0x14
	// Bit mask of SSDIV field.
	CTSU_CTSUSO_SSDIV_Msk = 0xf00000
	// Position of SDPA field.
	CTSU_CTSUSO_SDPA_Pos = 0x18
	// Bit mask of SDPA field.
	CTSU_CTSUSO_SDPA_Msk = 0xff000000

	// CTSUSCNT: CTSU Sensor Counter Register
	// Position of SENSCNT field.
	CTSU_CTSUSCNT_SENSCNT_Pos = 0x0
	// Bit mask of SENSCNT field.
	CTSU_CTSUSCNT_SENSCNT_Msk = 0xffff
	// Position of SUCKCNT field.
	CTSU_CTSUSCNT_SUCKCNT_Pos = 0x10
	// Bit mask of SUCKCNT field.
	CTSU_CTSUSCNT_SUCKCNT_Msk = 0xffff0000

	// CTSUCALIB: CTSU Calibration Register
	// Position of TSOD field.
	CTSU_CTSUCALIB_TSOD_Pos = 0x2
	// Bit mask of TSOD field.
	CTSU_CTSUCALIB_TSOD_Msk = 0x4
	// Bit TSOD.
	CTSU_CTSUCALIB_TSOD = 0x4
	// Capacitance measurement mode
	CTSU_CTSUCALIB_TSOD_0 = 0x0
	// Output high or low from TS terminals (controlling by the IOC bit)
	CTSU_CTSUCALIB_TSOD_1 = 0x1
	// Position of DRV field.
	CTSU_CTSUCALIB_DRV_Pos = 0x3
	// Bit mask of DRV field.
	CTSU_CTSUCALIB_DRV_Msk = 0x8
	// Bit DRV.
	CTSU_CTSUCALIB_DRV = 0x8
	// Capacitance measurement mode
	CTSU_CTSUCALIB_DRV_0 = 0x0
	// Power supply calibration mode
	CTSU_CTSUCALIB_DRV_1 = 0x1
	// Position of CLKSEL field.
	CTSU_CTSUCALIB_CLKSEL_Pos = 0x4
	// Bit mask of CLKSEL field.
	CTSU_CTSUCALIB_CLKSEL_Msk = 0x30
	// Not selected (L fixed output)
	CTSU_CTSUCALIB_CLKSEL_00 = 0x0
	// Measurement clock (divided by 8)
	CTSU_CTSUCALIB_CLKSEL_01 = 0x1
	// CFC clock (divided by 8)
	CTSU_CTSUCALIB_CLKSEL_10 = 0x2
	// SUCLK (divided by 8)
	CTSU_CTSUCALIB_CLKSEL_11 = 0x3
	// Position of SUCLKEN field.
	CTSU_CTSUCALIB_SUCLKEN_Pos = 0x6
	// Bit mask of SUCLKEN field.
	CTSU_CTSUCALIB_SUCLKEN_Msk = 0x40
	// Bit SUCLKEN.
	CTSU_CTSUCALIB_SUCLKEN = 0x40
	// SUCLK oscillation only during measurement
	CTSU_CTSUCALIB_SUCLKEN_0 = 0x0
	// SUCLK always oscillates
	CTSU_CTSUCALIB_SUCLKEN_1 = 0x1
	// Position of TSOC field.
	CTSU_CTSUCALIB_TSOC_Pos = 0x7
	// Bit mask of TSOC field.
	CTSU_CTSUCALIB_TSOC_Msk = 0x80
	// Bit TSOC.
	CTSU_CTSUCALIB_TSOC = 0x80
	// Capacitance measurement mode
	CTSU_CTSUCALIB_TSOC_0 = 0x0
	// Switched capacitor operation calibration mode
	CTSU_CTSUCALIB_TSOC_1 = 0x1
	// Position of CNTRDSEL field.
	CTSU_CTSUCALIB_CNTRDSEL_Pos = 0x8
	// Bit mask of CNTRDSEL field.
	CTSU_CTSUCALIB_CNTRDSEL_Msk = 0x100
	// Bit CNTRDSEL.
	CTSU_CTSUCALIB_CNTRDSEL = 0x100
	// Read once
	CTSU_CTSUCALIB_CNTRDSEL_0 = 0x0
	// Read twice
	CTSU_CTSUCALIB_CNTRDSEL_1 = 0x1
	// Position of IOC field.
	CTSU_CTSUCALIB_IOC_Pos = 0x9
	// Bit mask of IOC field.
	CTSU_CTSUCALIB_IOC_Msk = 0x200
	// Bit IOC.
	CTSU_CTSUCALIB_IOC = 0x200
	// Low level
	CTSU_CTSUCALIB_IOC_0 = 0x0
	// High level
	CTSU_CTSUCALIB_IOC_1 = 0x1
	// Position of CFCRDMD field.
	CTSU_CTSUCALIB_CFCRDMD_Pos = 0xa
	// Bit mask of CFCRDMD field.
	CTSU_CTSUCALIB_CFCRDMD_Msk = 0x400
	// Bit CFCRDMD.
	CTSU_CTSUCALIB_CFCRDMD = 0x400
	// Except for mutual capacitance parallel measurement mode
	CTSU_CTSUCALIB_CFCRDMD_0 = 0x0
	// Mutual capacitance parallel measurement mode
	CTSU_CTSUCALIB_CFCRDMD_1 = 0x1
	// Position of DCOFF field.
	CTSU_CTSUCALIB_DCOFF_Pos = 0xb
	// Bit mask of DCOFF field.
	CTSU_CTSUCALIB_DCOFF_Msk = 0x800
	// Bit DCOFF.
	CTSU_CTSUCALIB_DCOFF = 0x800
	// Voltage down converter operation (TSCAP voltage generation)
	CTSU_CTSUCALIB_DCOFF_0 = 0x0
	// The voltage down converter is off
	CTSU_CTSUCALIB_DCOFF_1 = 0x1
	// Position of CFCSEL field.
	CTSU_CTSUCALIB_CFCSEL_Pos = 0x10
	// Bit mask of CFCSEL field.
	CTSU_CTSUCALIB_CFCSEL_Msk = 0x3f0000
	// Position of CFCMODE field.
	CTSU_CTSUCALIB_CFCMODE_Pos = 0x16
	// Bit mask of CFCMODE field.
	CTSU_CTSUCALIB_CFCMODE_Msk = 0x400000
	// Bit CFCMODE.
	CTSU_CTSUCALIB_CFCMODE = 0x400000
	// CFC current measurement (Capacitance measurement mode)
	CTSU_CTSUCALIB_CFCMODE_0 = 0x0
	// External current measurement for calibration
	CTSU_CTSUCALIB_CFCMODE_1 = 0x1
	// Position of DACMSEL field.
	CTSU_CTSUCALIB_DACMSEL_Pos = 0x18
	// Bit mask of DACMSEL field.
	CTSU_CTSUCALIB_DACMSEL_Msk = 0x1000000
	// Bit DACMSEL.
	CTSU_CTSUCALIB_DACMSEL = 0x1000000
	// Capacitance measurement mode
	CTSU_CTSUCALIB_DACMSEL_0 = 0x0
	// Current offset DAC current Calibration mode
	CTSU_CTSUCALIB_DACMSEL_1 = 0x1
	// Position of DACCARRY field.
	CTSU_CTSUCALIB_DACCARRY_Pos = 0x19
	// Bit mask of DACCARRY field.
	CTSU_CTSUCALIB_DACCARRY_Msk = 0x2000000
	// Bit DACCARRY.
	CTSU_CTSUCALIB_DACCARRY = 0x2000000
	// Normal operation
	CTSU_CTSUCALIB_DACCARRY_0 = 0x0
	// All current sources can be turned on
	CTSU_CTSUCALIB_DACCARRY_1 = 0x1
	// Position of SUMSEL field.
	CTSU_CTSUCALIB_SUMSEL_Pos = 0x1a
	// Bit mask of SUMSEL field.
	CTSU_CTSUCALIB_SUMSEL_Msk = 0x4000000
	// Bit SUMSEL.
	CTSU_CTSUCALIB_SUMSEL = 0x4000000
	// Capacitance measurement mode
	CTSU_CTSUCALIB_SUMSEL_0 = 0x0
	// Current control oscillator input current matrix calibration mode
	CTSU_CTSUCALIB_SUMSEL_1 = 0x1
	// Position of SUCARRY field.
	CTSU_CTSUCALIB_SUCARRY_Pos = 0x1b
	// Bit mask of SUCARRY field.
	CTSU_CTSUCALIB_SUCARRY_Msk = 0x8000000
	// Bit SUCARRY.
	CTSU_CTSUCALIB_SUCARRY = 0x8000000
	// Normal operation
	CTSU_CTSUCALIB_SUCARRY_0 = 0x0
	// All current sources can be turned on
	CTSU_CTSUCALIB_SUCARRY_1 = 0x1
	// Position of DACCLK field.
	CTSU_CTSUCALIB_DACCLK_Pos = 0x1c
	// Bit mask of DACCLK field.
	CTSU_CTSUCALIB_DACCLK_Msk = 0x10000000
	// Bit DACCLK.
	CTSU_CTSUCALIB_DACCLK = 0x10000000
	// Operating clock selected by CTSUCRA.CLK [1:0]
	CTSU_CTSUCALIB_DACCLK_0 = 0x0
	// SUCLK
	CTSU_CTSUCALIB_DACCLK_1 = 0x1
	// Position of CCOCLK field.
	CTSU_CTSUCALIB_CCOCLK_Pos = 0x1d
	// Bit mask of CCOCLK field.
	CTSU_CTSUCALIB_CCOCLK_Msk = 0x20000000
	// Bit CCOCLK.
	CTSU_CTSUCALIB_CCOCLK = 0x20000000
	// Operating clock selected by CTSUCRA.CLK [1:0]
	CTSU_CTSUCALIB_CCOCLK_0 = 0x0
	// SUCLK
	CTSU_CTSUCALIB_CCOCLK_1 = 0x1
	// Position of CCOCALIB field.
	CTSU_CTSUCALIB_CCOCALIB_Pos = 0x1e
	// Bit mask of CCOCALIB field.
	CTSU_CTSUCALIB_CCOCALIB_Msk = 0x40000000
	// Bit CCOCALIB.
	CTSU_CTSUCALIB_CCOCALIB = 0x40000000
	// Capacitance measurement mode
	CTSU_CTSUCALIB_CCOCALIB_0 = 0x0
	// Oscillator calibration mode
	CTSU_CTSUCALIB_CCOCALIB_1 = 0x1
	// Position of TXREV field.
	CTSU_CTSUCALIB_TXREV_Pos = 0x1f
	// Bit mask of TXREV field.
	CTSU_CTSUCALIB_TXREV_Msk = 0x80000000
	// Bit TXREV.
	CTSU_CTSUCALIB_TXREV = 0x80000000
	// Normal
	CTSU_CTSUCALIB_TXREV_0 = 0x0
	// Invert
	CTSU_CTSUCALIB_TXREV_1 = 0x1

	// CTSUSUCLKB: CTSU Sensor Unit Clock Control Register B
	// Position of SUADJ2 field.
	CTSU_CTSUSUCLKB_SUADJ2_Pos = 0x0
	// Bit mask of SUADJ2 field.
	CTSU_CTSUSUCLKB_SUADJ2_Msk = 0xff
	// Position of SUMULTI2 field.
	CTSU_CTSUSUCLKB_SUMULTI2_Pos = 0x8
	// Bit mask of SUMULTI2 field.
	CTSU_CTSUSUCLKB_SUMULTI2_Msk = 0xff00
	// Position of SUADJ3 field.
	CTSU_CTSUSUCLKB_SUADJ3_Pos = 0x10
	// Bit mask of SUADJ3 field.
	CTSU_CTSUSUCLKB_SUADJ3_Msk = 0xff0000
	// Position of SUMULTI3 field.
	CTSU_CTSUSUCLKB_SUMULTI3_Pos = 0x18
	// Bit mask of SUMULTI3 field.
	CTSU_CTSUSUCLKB_SUMULTI3_Msk = 0xff000000

	// CTSUCFCCNT: CTSU CFC Counter Register
	// Position of CFCCNT field.
	CTSU_CTSUCFCCNT_CFCCNT_Pos = 0x0
	// Bit mask of CFCCNT field.
	CTSU_CTSUCFCCNT_CFCCNT_Msk = 0xffff
)

// Constants for AGT0: Low Power Asynchronous General Purpose Timer 0
const (
	// AGTCR: AGT Control Register
	// Position of TSTART field.
	AGT0_AGTCR_TSTART_Pos = 0x0
	// Bit mask of TSTART field.
	AGT0_AGTCR_TSTART_Msk = 0x1
	// Bit TSTART.
	AGT0_AGTCR_TSTART = 0x1
	// Count stops
	AGT0_AGTCR_TSTART_0 = 0x0
	// Count starts
	AGT0_AGTCR_TSTART_1 = 0x1
	// Position of TCSTF field.
	AGT0_AGTCR_TCSTF_Pos = 0x1
	// Bit mask of TCSTF field.
	AGT0_AGTCR_TCSTF_Msk = 0x2
	// Bit TCSTF.
	AGT0_AGTCR_TCSTF = 0x2
	// Count stopped
	AGT0_AGTCR_TCSTF_0 = 0x0
	// Count in progress
	AGT0_AGTCR_TCSTF_1 = 0x1
	// Position of TSTOP field.
	AGT0_AGTCR_TSTOP_Pos = 0x2
	// Bit mask of TSTOP field.
	AGT0_AGTCR_TSTOP_Msk = 0x4
	// Bit TSTOP.
	AGT0_AGTCR_TSTOP = 0x4
	// Writing is invalid
	AGT0_AGTCR_TSTOP_0 = 0x0
	// The count is forcibly stopped
	AGT0_AGTCR_TSTOP_1 = 0x1
	// Position of TEDGF field.
	AGT0_AGTCR_TEDGF_Pos = 0x4
	// Bit mask of TEDGF field.
	AGT0_AGTCR_TEDGF_Msk = 0x10
	// Bit TEDGF.
	AGT0_AGTCR_TEDGF = 0x10
	// No active edge received
	AGT0_AGTCR_TEDGF_0 = 0x0
	// Active edge received
	AGT0_AGTCR_TEDGF_1 = 0x1
	// Position of TUNDF field.
	AGT0_AGTCR_TUNDF_Pos = 0x5
	// Bit mask of TUNDF field.
	AGT0_AGTCR_TUNDF_Msk = 0x20
	// Bit TUNDF.
	AGT0_AGTCR_TUNDF = 0x20
	// No underflow
	AGT0_AGTCR_TUNDF_0 = 0x0
	// Underflow
	AGT0_AGTCR_TUNDF_1 = 0x1
	// Position of TCMAF field.
	AGT0_AGTCR_TCMAF_Pos = 0x6
	// Bit mask of TCMAF field.
	AGT0_AGTCR_TCMAF_Msk = 0x40
	// Bit TCMAF.
	AGT0_AGTCR_TCMAF = 0x40
	// No match
	AGT0_AGTCR_TCMAF_0 = 0x0
	// Match
	AGT0_AGTCR_TCMAF_1 = 0x1
	// Position of TCMBF field.
	AGT0_AGTCR_TCMBF_Pos = 0x7
	// Bit mask of TCMBF field.
	AGT0_AGTCR_TCMBF_Msk = 0x80
	// Bit TCMBF.
	AGT0_AGTCR_TCMBF = 0x80
	// No match
	AGT0_AGTCR_TCMBF_0 = 0x0
	// Match
	AGT0_AGTCR_TCMBF_1 = 0x1

	// AGTMR1: AGT Mode Register 1
	// Position of TMOD field.
	AGT0_AGTMR1_TMOD_Pos = 0x0
	// Bit mask of TMOD field.
	AGT0_AGTMR1_TMOD_Msk = 0x7
	// Timer mode
	AGT0_AGTMR1_TMOD_000 = 0x0
	// Pulse output mode
	AGT0_AGTMR1_TMOD_001 = 0x1
	// Event counter mode
	AGT0_AGTMR1_TMOD_010 = 0x2
	// Pulse width measurement mode
	AGT0_AGTMR1_TMOD_011 = 0x3
	// Pulse period measurement mode
	AGT0_AGTMR1_TMOD_100 = 0x4
	// Position of TEDGPL field.
	AGT0_AGTMR1_TEDGPL_Pos = 0x3
	// Bit mask of TEDGPL field.
	AGT0_AGTMR1_TEDGPL_Msk = 0x8
	// Bit TEDGPL.
	AGT0_AGTMR1_TEDGPL = 0x8
	// Single-edge
	AGT0_AGTMR1_TEDGPL_0 = 0x0
	// Both-edge
	AGT0_AGTMR1_TEDGPL_1 = 0x1
	// Position of TCK field.
	AGT0_AGTMR1_TCK_Pos = 0x4
	// Bit mask of TCK field.
	AGT0_AGTMR1_TCK_Msk = 0x70
	// PCLKB
	AGT0_AGTMR1_TCK_000 = 0x0
	// PCLKB/8
	AGT0_AGTMR1_TCK_001 = 0x1
	// PCLKB/2
	AGT0_AGTMR1_TCK_011 = 0x3
	// Divided clock AGTLCLK specified by CKS[2:0] bits in the AGTMR2 register
	AGT0_AGTMR1_TCK_100 = 0x4
	// Underflow event signal from AGT0
	AGT0_AGTMR1_TCK_101 = 0x5
	// Divided clock AGTSCLK specified by CKS[2:0] bits in the AGTMR2 register
	AGT0_AGTMR1_TCK_110 = 0x6

	// AGTMR2: AGT Mode Register 2
	// Position of CKS field.
	AGT0_AGTMR2_CKS_Pos = 0x0
	// Bit mask of CKS field.
	AGT0_AGTMR2_CKS_Msk = 0x7
	// 1/1
	AGT0_AGTMR2_CKS_000 = 0x0
	// 1/2
	AGT0_AGTMR2_CKS_001 = 0x1
	// 1/4
	AGT0_AGTMR2_CKS_010 = 0x2
	// 1/8
	AGT0_AGTMR2_CKS_011 = 0x3
	// 1/16
	AGT0_AGTMR2_CKS_100 = 0x4
	// 1/32
	AGT0_AGTMR2_CKS_101 = 0x5
	// 1/64
	AGT0_AGTMR2_CKS_110 = 0x6
	// 1/128
	AGT0_AGTMR2_CKS_111 = 0x7
	// Position of LPM field.
	AGT0_AGTMR2_LPM_Pos = 0x7
	// Bit mask of LPM field.
	AGT0_AGTMR2_LPM_Msk = 0x80
	// Bit LPM.
	AGT0_AGTMR2_LPM = 0x80
	// Normal mode
	AGT0_AGTMR2_LPM_0 = 0x0
	// Low power mode
	AGT0_AGTMR2_LPM_1 = 0x1

	// AGTIOC: AGT I/O Control Register
	// Position of TEDGSEL field.
	AGT0_AGTIOC_TEDGSEL_Pos = 0x0
	// Bit mask of TEDGSEL field.
	AGT0_AGTIOC_TEDGSEL_Msk = 0x1
	// Bit TEDGSEL.
	AGT0_AGTIOC_TEDGSEL = 0x1
	// Position of TOE field.
	AGT0_AGTIOC_TOE_Pos = 0x2
	// Bit mask of TOE field.
	AGT0_AGTIOC_TOE_Msk = 0x4
	// Bit TOE.
	AGT0_AGTIOC_TOE = 0x4
	// AGTOn pin output disabled
	AGT0_AGTIOC_TOE_0 = 0x0
	// AGTOn pin output enabled
	AGT0_AGTIOC_TOE_1 = 0x1
	// Position of TIPF field.
	AGT0_AGTIOC_TIPF_Pos = 0x4
	// Bit mask of TIPF field.
	AGT0_AGTIOC_TIPF_Msk = 0x30
	// No filter
	AGT0_AGTIOC_TIPF_00 = 0x0
	// Filter sampled at PCLKB
	AGT0_AGTIOC_TIPF_01 = 0x1
	// Filter sampled at PCLKB/8
	AGT0_AGTIOC_TIPF_10 = 0x2
	// Filter sampled at PCLKB/32
	AGT0_AGTIOC_TIPF_11 = 0x3
	// Position of TIOGT field.
	AGT0_AGTIOC_TIOGT_Pos = 0x6
	// Bit mask of TIOGT field.
	AGT0_AGTIOC_TIOGT_Msk = 0xc0
	// Event is always counted
	AGT0_AGTIOC_TIOGT_00 = 0x0
	// Event is counted during polarity period specified for AGTEEn pin
	AGT0_AGTIOC_TIOGT_01 = 0x1

	// AGTISR: AGT Event Pin Select Register
	// Position of EEPS field.
	AGT0_AGTISR_EEPS_Pos = 0x2
	// Bit mask of EEPS field.
	AGT0_AGTISR_EEPS_Msk = 0x4
	// Bit EEPS.
	AGT0_AGTISR_EEPS = 0x4
	// An event is counted during the low-level period
	AGT0_AGTISR_EEPS_0 = 0x0
	// An event is counted during the high-level period
	AGT0_AGTISR_EEPS_1 = 0x1

	// AGTCMSR: AGT Compare Match Function Select Register
	// Position of TCMEA field.
	AGT0_AGTCMSR_TCMEA_Pos = 0x0
	// Bit mask of TCMEA field.
	AGT0_AGTCMSR_TCMEA_Msk = 0x1
	// Bit TCMEA.
	AGT0_AGTCMSR_TCMEA = 0x1
	// AGT Compare match A register disabled
	AGT0_AGTCMSR_TCMEA_0 = 0x0
	// AGT Compare match A register enabled
	AGT0_AGTCMSR_TCMEA_1 = 0x1
	// Position of TOEA field.
	AGT0_AGTCMSR_TOEA_Pos = 0x1
	// Bit mask of TOEA field.
	AGT0_AGTCMSR_TOEA_Msk = 0x2
	// Bit TOEA.
	AGT0_AGTCMSR_TOEA = 0x2
	// AGTOAn pin output disabled
	AGT0_AGTCMSR_TOEA_0 = 0x0
	// AGTOAn pin output enabled
	AGT0_AGTCMSR_TOEA_1 = 0x1
	// Position of TOPOLA field.
	AGT0_AGTCMSR_TOPOLA_Pos = 0x2
	// Bit mask of TOPOLA field.
	AGT0_AGTCMSR_TOPOLA_Msk = 0x4
	// Bit TOPOLA.
	AGT0_AGTCMSR_TOPOLA = 0x4
	// AGTOAn pin output is started on low. i.e. normal output
	AGT0_AGTCMSR_TOPOLA_0 = 0x0
	// AGTOAn pin output is started on high. i.e. inverted output
	AGT0_AGTCMSR_TOPOLA_1 = 0x1
	// Position of TCMEB field.
	AGT0_AGTCMSR_TCMEB_Pos = 0x4
	// Bit mask of TCMEB field.
	AGT0_AGTCMSR_TCMEB_Msk = 0x10
	// Bit TCMEB.
	AGT0_AGTCMSR_TCMEB = 0x10
	// Compare match B register disabled
	AGT0_AGTCMSR_TCMEB_0 = 0x0
	// Compare match B register enabled
	AGT0_AGTCMSR_TCMEB_1 = 0x1
	// Position of TOEB field.
	AGT0_AGTCMSR_TOEB_Pos = 0x5
	// Bit mask of TOEB field.
	AGT0_AGTCMSR_TOEB_Msk = 0x20
	// Bit TOEB.
	AGT0_AGTCMSR_TOEB = 0x20
	// AGTOBn pin output disabled
	AGT0_AGTCMSR_TOEB_0 = 0x0
	// AGTOBn pin output enabled
	AGT0_AGTCMSR_TOEB_1 = 0x1
	// Position of TOPOLB field.
	AGT0_AGTCMSR_TOPOLB_Pos = 0x6
	// Bit mask of TOPOLB field.
	AGT0_AGTCMSR_TOPOLB_Msk = 0x40
	// Bit TOPOLB.
	AGT0_AGTCMSR_TOPOLB = 0x40
	// AGTOBn pin output is started on low. i.e. normal output
	AGT0_AGTCMSR_TOPOLB_0 = 0x0
	// AGTOBn pin output is started on high. i.e. inverted output
	AGT0_AGTCMSR_TOPOLB_1 = 0x1

	// AGTIOSEL: AGT Pin Select Register
	// Position of SEL field.
	AGT0_AGTIOSEL_SEL_Pos = 0x0
	// Bit mask of SEL field.
	AGT0_AGTIOSEL_SEL_Msk = 0x3
	// Select the AGTIOn except for the following pins
	AGT0_AGTIOSEL_SEL_00 = 0x0
	// Setting prohibited
	AGT0_AGTIOSEL_SEL_01 = 0x1
	// Select the P402/AGTIOn P402/AGTIOn as input only. It cannot be used for output.
	AGT0_AGTIOSEL_SEL_10 = 0x2
	// Select the P403/AGTIOn P403/AGTIOn as input only. It cannot be used for output.
	AGT0_AGTIOSEL_SEL_11 = 0x3
	// Position of TIES field.
	AGT0_AGTIOSEL_TIES_Pos = 0x4
	// Bit mask of TIES field.
	AGT0_AGTIOSEL_TIES_Msk = 0x10
	// Bit TIES.
	AGT0_AGTIOSEL_TIES = 0x10
	// External event input is disabled during Software Standby mode
	AGT0_AGTIOSEL_TIES_0 = 0x0
	// External event input is enabled during Software Standby mode
	AGT0_AGTIOSEL_TIES_1 = 0x1
)

// Constants for ACMPLP: Low-Power Analog Comparator
const (
	// COMPMDR: ACMPLP Mode Setting Register
	// Position of C0ENB field.
	ACMPLP_COMPMDR_C0ENB_Pos = 0x0
	// Bit mask of C0ENB field.
	ACMPLP_COMPMDR_C0ENB_Msk = 0x1
	// Bit C0ENB.
	ACMPLP_COMPMDR_C0ENB = 0x1
	// Disable comparator channel ACMPLP0
	ACMPLP_COMPMDR_C0ENB_0 = 0x0
	// Enable comparator channel ACMPLP0
	ACMPLP_COMPMDR_C0ENB_1 = 0x1
	// Position of C0WDE field.
	ACMPLP_COMPMDR_C0WDE_Pos = 0x1
	// Bit mask of C0WDE field.
	ACMPLP_COMPMDR_C0WDE_Msk = 0x2
	// Bit C0WDE.
	ACMPLP_COMPMDR_C0WDE = 0x2
	// Disable window function for ACMPLP0
	ACMPLP_COMPMDR_C0WDE_0 = 0x0
	// Enable window function for ACMPLP0
	ACMPLP_COMPMDR_C0WDE_1 = 0x1
	// Position of C0VRF field.
	ACMPLP_COMPMDR_C0VRF_Pos = 0x2
	// Bit mask of C0VRF field.
	ACMPLP_COMPMDR_C0VRF_Msk = 0x4
	// Bit C0VRF.
	ACMPLP_COMPMDR_C0VRF = 0x4
	// Select CMPREF0 input as ACMPLP0 reference voltage.
	ACMPLP_COMPMDR_C0VRF_0 = 0x0
	// Select internal reference voltage (Vref) as ACMPLP0 reference voltage.
	ACMPLP_COMPMDR_C0VRF_1 = 0x1
	// Position of C0MON field.
	ACMPLP_COMPMDR_C0MON_Pos = 0x3
	// Bit mask of C0MON field.
	ACMPLP_COMPMDR_C0MON_Msk = 0x8
	// Bit C0MON.
	ACMPLP_COMPMDR_C0MON = 0x8
	// Position of C1ENB field.
	ACMPLP_COMPMDR_C1ENB_Pos = 0x4
	// Bit mask of C1ENB field.
	ACMPLP_COMPMDR_C1ENB_Msk = 0x10
	// Bit C1ENB.
	ACMPLP_COMPMDR_C1ENB = 0x10
	// Disable ACMPLP1 operation
	ACMPLP_COMPMDR_C1ENB_0 = 0x0
	// Enable ACMPLP1 operation
	ACMPLP_COMPMDR_C1ENB_1 = 0x1
	// Position of C1WDE field.
	ACMPLP_COMPMDR_C1WDE_Pos = 0x5
	// Bit mask of C1WDE field.
	ACMPLP_COMPMDR_C1WDE_Msk = 0x20
	// Bit C1WDE.
	ACMPLP_COMPMDR_C1WDE = 0x20
	// Disable ACMPLP1 window function mode
	ACMPLP_COMPMDR_C1WDE_0 = 0x0
	// Enable ACMPLP1 window function mode
	ACMPLP_COMPMDR_C1WDE_1 = 0x1
	// Position of C1VRF field.
	ACMPLP_COMPMDR_C1VRF_Pos = 0x6
	// Bit mask of C1VRF field.
	ACMPLP_COMPMDR_C1VRF_Msk = 0x40
	// Bit C1VRF.
	ACMPLP_COMPMDR_C1VRF = 0x40
	// Select CMPREF1 input as ACMPLP1 reference voltage.
	ACMPLP_COMPMDR_C1VRF_0 = 0x0
	// Select internal reference voltage (Vref) as ACMPLP1 reference voltage.
	ACMPLP_COMPMDR_C1VRF_1 = 0x1
	// Position of C1MON field.
	ACMPLP_COMPMDR_C1MON_Pos = 0x7
	// Bit mask of C1MON field.
	ACMPLP_COMPMDR_C1MON_Msk = 0x80
	// Bit C1MON.
	ACMPLP_COMPMDR_C1MON = 0x80

	// COMPFIR: ACMPLP Filter Control Register
	// Position of C0FCK field.
	ACMPLP_COMPFIR_C0FCK_Pos = 0x0
	// Bit mask of C0FCK field.
	ACMPLP_COMPFIR_C0FCK_Msk = 0x3
	// No Sampling (bypass)
	ACMPLP_COMPFIR_C0FCK_00 = 0x0
	// Sampling at PCLKB
	ACMPLP_COMPFIR_C0FCK_01 = 0x1
	// Sampling at PCLKB/8
	ACMPLP_COMPFIR_C0FCK_10 = 0x2
	// Sampling at PCLKB/32
	ACMPLP_COMPFIR_C0FCK_11 = 0x3
	// Position of C0EPO field.
	ACMPLP_COMPFIR_C0EPO_Pos = 0x2
	// Bit mask of C0EPO field.
	ACMPLP_COMPFIR_C0EPO_Msk = 0x4
	// Bit C0EPO.
	ACMPLP_COMPFIR_C0EPO = 0x4
	// Interrupt and ELC event request on rising edge
	ACMPLP_COMPFIR_C0EPO_0 = 0x0
	// Interrupt and ELC event request on falling edge
	ACMPLP_COMPFIR_C0EPO_1 = 0x1
	// Position of C0EDG field.
	ACMPLP_COMPFIR_C0EDG_Pos = 0x3
	// Bit mask of C0EDG field.
	ACMPLP_COMPFIR_C0EDG_Msk = 0x8
	// Bit C0EDG.
	ACMPLP_COMPFIR_C0EDG = 0x8
	// Interrupt and ELC event request by one-edge detection
	ACMPLP_COMPFIR_C0EDG_0 = 0x0
	// Interrupt and ELC event request by both-edge detection
	ACMPLP_COMPFIR_C0EDG_1 = 0x1
	// Position of C1FCK field.
	ACMPLP_COMPFIR_C1FCK_Pos = 0x4
	// Bit mask of C1FCK field.
	ACMPLP_COMPFIR_C1FCK_Msk = 0x30
	// No Sampling (bypass)
	ACMPLP_COMPFIR_C1FCK_00 = 0x0
	// Sampling at PCLKB
	ACMPLP_COMPFIR_C1FCK_01 = 0x1
	// Sampling at PCLKB/8
	ACMPLP_COMPFIR_C1FCK_10 = 0x2
	// Sampling at PCLKB/32
	ACMPLP_COMPFIR_C1FCK_11 = 0x3
	// Position of C1EPO field.
	ACMPLP_COMPFIR_C1EPO_Pos = 0x6
	// Bit mask of C1EPO field.
	ACMPLP_COMPFIR_C1EPO_Msk = 0x40
	// Bit C1EPO.
	ACMPLP_COMPFIR_C1EPO = 0x40
	// Interrupt and ELC event request on rising edge
	ACMPLP_COMPFIR_C1EPO_0 = 0x0
	// Interrupt and ELC event request on falling edge
	ACMPLP_COMPFIR_C1EPO_1 = 0x1
	// Position of C1EDG field.
	ACMPLP_COMPFIR_C1EDG_Pos = 0x7
	// Bit mask of C1EDG field.
	ACMPLP_COMPFIR_C1EDG_Msk = 0x80
	// Bit C1EDG.
	ACMPLP_COMPFIR_C1EDG = 0x80
	// Interrupt and ELC event request by one-edge detection
	ACMPLP_COMPFIR_C1EDG_0 = 0x0
	// Interrupt and ELC event request by both-edge detection
	ACMPLP_COMPFIR_C1EDG_1 = 0x1

	// COMPOCR: ACMPLP Output Control Register
	// Position of C0OE field.
	ACMPLP_COMPOCR_C0OE_Pos = 0x1
	// Bit mask of C0OE field.
	ACMPLP_COMPOCR_C0OE_Msk = 0x2
	// Bit C0OE.
	ACMPLP_COMPOCR_C0OE = 0x2
	// Disabled
	ACMPLP_COMPOCR_C0OE_0 = 0x0
	// Enabled
	ACMPLP_COMPOCR_C0OE_1 = 0x1
	// Position of C0OP field.
	ACMPLP_COMPOCR_C0OP_Pos = 0x2
	// Bit mask of C0OP field.
	ACMPLP_COMPOCR_C0OP_Msk = 0x4
	// Bit C0OP.
	ACMPLP_COMPOCR_C0OP = 0x4
	// Non-inverted
	ACMPLP_COMPOCR_C0OP_0 = 0x0
	// Inverted
	ACMPLP_COMPOCR_C0OP_1 = 0x1
	// Position of C1OE field.
	ACMPLP_COMPOCR_C1OE_Pos = 0x5
	// Bit mask of C1OE field.
	ACMPLP_COMPOCR_C1OE_Msk = 0x20
	// Bit C1OE.
	ACMPLP_COMPOCR_C1OE = 0x20
	// Disabled
	ACMPLP_COMPOCR_C1OE_0 = 0x0
	// Enabled
	ACMPLP_COMPOCR_C1OE_1 = 0x1
	// Position of C1OP field.
	ACMPLP_COMPOCR_C1OP_Pos = 0x6
	// Bit mask of C1OP field.
	ACMPLP_COMPOCR_C1OP_Msk = 0x40
	// Bit C1OP.
	ACMPLP_COMPOCR_C1OP = 0x40
	// Non-inverted
	ACMPLP_COMPOCR_C1OP_0 = 0x0
	// Inverted
	ACMPLP_COMPOCR_C1OP_1 = 0x1
	// Position of SPDMD field.
	ACMPLP_COMPOCR_SPDMD_Pos = 0x7
	// Bit mask of SPDMD field.
	ACMPLP_COMPOCR_SPDMD_Msk = 0x80
	// Bit SPDMD.
	ACMPLP_COMPOCR_SPDMD = 0x80
	// Low-speed mode
	ACMPLP_COMPOCR_SPDMD_0 = 0x0
	// High-speed mode
	ACMPLP_COMPOCR_SPDMD_1 = 0x1
)

// Constants for FLCN: Flash I/O Registers
const (
	// DFLCTL: Data Flash Control Register
	// Position of DFLEN field.
	FLCN_DFLCTL_DFLEN_Pos = 0x0
	// Bit mask of DFLEN field.
	FLCN_DFLCTL_DFLEN_Msk = 0x1
	// Bit DFLEN.
	FLCN_DFLCTL_DFLEN = 0x1
	// Access to the data flash is disabled
	FLCN_DFLCTL_DFLEN_0 = 0x0
	// Access to the data flash is enabled
	FLCN_DFLCTL_DFLEN_1 = 0x1

	// FPMCR: Flash P/E Mode Control Register
	// Position of FMS0 field.
	FLCN_FPMCR_FMS0_Pos = 0x1
	// Bit mask of FMS0 field.
	FLCN_FPMCR_FMS0_Msk = 0x2
	// Bit FMS0.
	FLCN_FPMCR_FMS0 = 0x2
	// FMS1 = 0: Read mode FMS1 = 1: Data flash P/E mode.
	FLCN_FPMCR_FMS0_0 = 0x0
	// FMS1 = 0: Code flash P/E mode FMS1 = 1: Setting prohibited.
	FLCN_FPMCR_FMS0_1 = 0x1
	// Position of RPDIS field.
	FLCN_FPMCR_RPDIS_Pos = 0x3
	// Bit mask of RPDIS field.
	FLCN_FPMCR_RPDIS_Msk = 0x8
	// Bit RPDIS.
	FLCN_FPMCR_RPDIS = 0x8
	// Programming of the code flash is enabled
	FLCN_FPMCR_RPDIS_0 = 0x0
	// Programming of the code flash is disabled.
	FLCN_FPMCR_RPDIS_1 = 0x1
	// Position of FMS1 field.
	FLCN_FPMCR_FMS1_Pos = 0x4
	// Bit mask of FMS1 field.
	FLCN_FPMCR_FMS1_Msk = 0x10
	// Bit FMS1.
	FLCN_FPMCR_FMS1 = 0x10

	// FASR: Flash Area Select Register
	// Position of EXS field.
	FLCN_FASR_EXS_Pos = 0x0
	// Bit mask of EXS field.
	FLCN_FASR_EXS_Msk = 0x1
	// Bit EXS.
	FLCN_FASR_EXS = 0x1
	// User area or data area
	FLCN_FASR_EXS_0 = 0x0
	// Extra area.
	FLCN_FASR_EXS_1 = 0x1

	// FSARL: Flash Processing Start Address Register L
	// Position of FSARL field.
	FLCN_FSARL_FSARL_Pos = 0x0
	// Bit mask of FSARL field.
	FLCN_FSARL_FSARL_Msk = 0xffff

	// FSARH: Flash Processing Start Address Register H
	// Position of FSARH field.
	FLCN_FSARH_FSARH_Pos = 0x0
	// Bit mask of FSARH field.
	FLCN_FSARH_FSARH_Msk = 0xffff

	// FCR: Flash Control Register
	// Position of CMD field.
	FLCN_FCR_CMD_Pos = 0x0
	// Bit mask of CMD field.
	FLCN_FCR_CMD_Msk = 0xf
	// Program
	FLCN_FCR_CMD_0x1 = 0x1
	// Blank check (code flash)
	FLCN_FCR_CMD_0x3 = 0x3
	// Block erase
	FLCN_FCR_CMD_0x4 = 0x4
	// Consecutive read
	FLCN_FCR_CMD_0x5 = 0x5
	// Chip erase
	FLCN_FCR_CMD_0x6 = 0x6
	// Blank check (data flash)
	FLCN_FCR_CMD_0xB = 0xb
	// Position of DRC field.
	FLCN_FCR_DRC_Pos = 0x4
	// Bit mask of DRC field.
	FLCN_FCR_DRC_Msk = 0x10
	// Bit DRC.
	FLCN_FCR_DRC = 0x10
	// Data is not read or next data is requested
	FLCN_FCR_DRC_0 = 0x0
	// Data reading is complete.
	FLCN_FCR_DRC_1 = 0x1
	// Position of STOP field.
	FLCN_FCR_STOP_Pos = 0x6
	// Bit mask of STOP field.
	FLCN_FCR_STOP_Msk = 0x40
	// Bit STOP.
	FLCN_FCR_STOP = 0x40
	// Position of OPST field.
	FLCN_FCR_OPST_Pos = 0x7
	// Bit mask of OPST field.
	FLCN_FCR_OPST_Msk = 0x80
	// Bit OPST.
	FLCN_FCR_OPST = 0x80
	// Processing stops
	FLCN_FCR_OPST_0 = 0x0
	// Processing starts.
	FLCN_FCR_OPST_1 = 0x1

	// FEARL: Flash Processing End Address Register L
	// Position of FEARL field.
	FLCN_FEARL_FEARL_Pos = 0x0
	// Bit mask of FEARL field.
	FLCN_FEARL_FEARL_Msk = 0xffff

	// FEARH: Flash Processing End Address Register H
	// Position of FEARH field.
	FLCN_FEARH_FEARH_Pos = 0x0
	// Bit mask of FEARH field.
	FLCN_FEARH_FEARH_Msk = 0xffff

	// FRESETR: Flash Reset Register
	// Position of FRESET field.
	FLCN_FRESETR_FRESET_Pos = 0x0
	// Bit mask of FRESET field.
	FLCN_FRESETR_FRESET_Msk = 0x1
	// Bit FRESET.
	FLCN_FRESETR_FRESET = 0x1
	// The registers related to the flash programming are not reset
	FLCN_FRESETR_FRESET_0 = 0x0
	// The registers related to the flash programming are reset.
	FLCN_FRESETR_FRESET_1 = 0x1

	// FSTATR1: Flash Status Register 1
	// Position of DRRDY field.
	FLCN_FSTATR1_DRRDY_Pos = 0x1
	// Bit mask of DRRDY field.
	FLCN_FSTATR1_DRRDY_Msk = 0x2
	// Bit DRRDY.
	FLCN_FSTATR1_DRRDY = 0x2
	// The read processing of the consecutive read command at each address is not terminated.
	FLCN_FSTATR1_DRRDY_0 = 0x0
	// The read processing of the consecutive read command at each address is terminated and read data is stored to the FRBH and FRBL registers.
	FLCN_FSTATR1_DRRDY_1 = 0x1
	// Position of FRDY field.
	FLCN_FSTATR1_FRDY_Pos = 0x6
	// Bit mask of FRDY field.
	FLCN_FSTATR1_FRDY_Msk = 0x40
	// Bit FRDY.
	FLCN_FSTATR1_FRDY = 0x40
	// The software command of the FCR register is not terminated.
	FLCN_FSTATR1_FRDY_0 = 0x0
	// The software command of the FCR register is terminated.
	FLCN_FSTATR1_FRDY_1 = 0x1
	// Position of EXRDY field.
	FLCN_FSTATR1_EXRDY_Pos = 0x7
	// Bit mask of EXRDY field.
	FLCN_FSTATR1_EXRDY_Msk = 0x80
	// Bit EXRDY.
	FLCN_FSTATR1_EXRDY = 0x80
	// The software command of the FEXCR register is not terminated.
	FLCN_FSTATR1_EXRDY_0 = 0x0
	// The software command of the FEXCR register is terminated.
	FLCN_FSTATR1_EXRDY_1 = 0x1

	// FWBL0: Flash Write Buffer Register L0
	// Position of WDATA field.
	FLCN_FWBL0_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	FLCN_FWBL0_WDATA_Msk = 0xffff

	// FWBH0: Flash Write Buffer Register H0
	// Position of WDATA field.
	FLCN_FWBH0_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	FLCN_FWBH0_WDATA_Msk = 0xffff

	// FPR: Protection Unlock Register
	// Position of FPR field.
	FLCN_FPR_FPR_Pos = 0x0
	// Bit mask of FPR field.
	FLCN_FPR_FPR_Msk = 0xff

	// FPSR: Protection Unlock Status Register
	// Position of PERR field.
	FLCN_FPSR_PERR_Pos = 0x0
	// Bit mask of PERR field.
	FLCN_FPSR_PERR_Msk = 0x1
	// Bit PERR.
	FLCN_FPSR_PERR = 0x1
	// No error
	FLCN_FPSR_PERR_0 = 0x0
	// An error occurs
	FLCN_FPSR_PERR_1 = 0x1

	// FRBL0: Flash Read Buffer Register L0
	// Position of RDATA field.
	FLCN_FRBL0_RDATA_Pos = 0x0
	// Bit mask of RDATA field.
	FLCN_FRBL0_RDATA_Msk = 0xffff

	// FRBH0: Flash Read Buffer Register H0
	// Position of RDATA field.
	FLCN_FRBH0_RDATA_Pos = 0x0
	// Bit mask of RDATA field.
	FLCN_FRBH0_RDATA_Msk = 0xffff

	// FSCMR: Flash Start-Up Setting Monitor Register
	// Position of SASMF field.
	FLCN_FSCMR_SASMF_Pos = 0x8
	// Bit mask of SASMF field.
	FLCN_FSCMR_SASMF_Msk = 0x100
	// Bit SASMF.
	FLCN_FSCMR_SASMF = 0x100
	// Setting to start up using the alternative area
	FLCN_FSCMR_SASMF_0 = 0x0
	// Setting to start up using the default area
	FLCN_FSCMR_SASMF_1 = 0x1
	// Position of FSPR field.
	FLCN_FSCMR_FSPR_Pos = 0xe
	// Bit mask of FSPR field.
	FLCN_FSCMR_FSPR_Msk = 0x4000
	// Bit FSPR.
	FLCN_FSCMR_FSPR = 0x4000
	// Access window setting disabled.
	FLCN_FSCMR_FSPR_0 = 0x0
	// Access window setting enabled.
	FLCN_FSCMR_FSPR_1 = 0x1

	// FAWSMR: Flash Access Window Start Address Monitor Register
	// Position of FAWS field.
	FLCN_FAWSMR_FAWS_Pos = 0x0
	// Bit mask of FAWS field.
	FLCN_FAWSMR_FAWS_Msk = 0x7ff
	// Position of FSPR field.
	FLCN_FAWSMR_FSPR_Pos = 0xf
	// Bit mask of FSPR field.
	FLCN_FAWSMR_FSPR_Msk = 0x8000
	// Bit FSPR.
	FLCN_FAWSMR_FSPR = 0x8000

	// FAWEMR: Flash Access Window End Address Monitor Register
	// Position of FAWE field.
	FLCN_FAWEMR_FAWE_Pos = 0x0
	// Bit mask of FAWE field.
	FLCN_FAWEMR_FAWE_Msk = 0x7ff
	// Position of SASMF field.
	FLCN_FAWEMR_SASMF_Pos = 0xf
	// Bit mask of SASMF field.
	FLCN_FAWEMR_SASMF_Msk = 0x8000
	// Bit SASMF.
	FLCN_FAWEMR_SASMF = 0x8000

	// FISR: Flash Initial Setting Register
	// Position of PCKA field.
	FLCN_FISR_PCKA_Pos = 0x0
	// Bit mask of PCKA field.
	FLCN_FISR_PCKA_Msk = 0x3f
	// Position of SAS field.
	FLCN_FISR_SAS_Pos = 0x6
	// Bit mask of SAS field.
	FLCN_FISR_SAS_Msk = 0xc0
	// The startup area is switched to the default area temporarily
	FLCN_FISR_SAS_10 = 0x2
	// The startup area is switched to the alternate area temporarily.
	FLCN_FISR_SAS_11 = 0x3

	// FEXCR: Flash Extra Area Control Register
	// Position of CMD field.
	FLCN_FEXCR_CMD_Pos = 0x0
	// Bit mask of CMD field.
	FLCN_FEXCR_CMD_Msk = 0x7
	// Access window information program Startup area selection and security setting
	FLCN_FEXCR_CMD_010 = 0x2
	// OCDID1 program
	FLCN_FEXCR_CMD_011 = 0x3
	// OCDID2 program
	FLCN_FEXCR_CMD_100 = 0x4
	// OCDID3 program
	FLCN_FEXCR_CMD_101 = 0x5
	// OCDID4 program
	FLCN_FEXCR_CMD_110 = 0x6
	// Position of OPST field.
	FLCN_FEXCR_OPST_Pos = 0x7
	// Bit mask of OPST field.
	FLCN_FEXCR_OPST_Msk = 0x80
	// Bit OPST.
	FLCN_FEXCR_OPST = 0x80
	// Processing stops
	FLCN_FEXCR_OPST_0 = 0x0
	// Processing starts.
	FLCN_FEXCR_OPST_1 = 0x1

	// FEAML: Flash Error Address Monitor Register L
	// Position of FEAML field.
	FLCN_FEAML_FEAML_Pos = 0x0
	// Bit mask of FEAML field.
	FLCN_FEAML_FEAML_Msk = 0xffff

	// FEAMH: Flash Error Address Monitor Register H
	// Position of FEAMH field.
	FLCN_FEAMH_FEAMH_Pos = 0x0
	// Bit mask of FEAMH field.
	FLCN_FEAMH_FEAMH_Msk = 0xffff

	// FSTATR2: Flash Status Register 2
	// Position of ERERR field.
	FLCN_FSTATR2_ERERR_Pos = 0x0
	// Bit mask of ERERR field.
	FLCN_FSTATR2_ERERR_Msk = 0x1
	// Bit ERERR.
	FLCN_FSTATR2_ERERR = 0x1
	// Erasure terminates normally
	FLCN_FSTATR2_ERERR_0 = 0x0
	// An error occurs during erasure
	FLCN_FSTATR2_ERERR_1 = 0x1
	// Position of PRGERR field.
	FLCN_FSTATR2_PRGERR_Pos = 0x1
	// Bit mask of PRGERR field.
	FLCN_FSTATR2_PRGERR_Msk = 0x2
	// Bit PRGERR.
	FLCN_FSTATR2_PRGERR = 0x2
	// Programming terminates normally
	FLCN_FSTATR2_PRGERR_0 = 0x0
	// An error occurs during programming.
	FLCN_FSTATR2_PRGERR_1 = 0x1
	// Position of PRGERR01 field.
	FLCN_FSTATR2_PRGERR01_Pos = 0x2
	// Bit mask of PRGERR01 field.
	FLCN_FSTATR2_PRGERR01_Msk = 0x4
	// Bit PRGERR01.
	FLCN_FSTATR2_PRGERR01 = 0x4
	// Programming by the FEXCR register terminates normally
	FLCN_FSTATR2_PRGERR01_0 = 0x0
	// An error occurs during programming.
	FLCN_FSTATR2_PRGERR01_1 = 0x1
	// Position of BCERR field.
	FLCN_FSTATR2_BCERR_Pos = 0x3
	// Bit mask of BCERR field.
	FLCN_FSTATR2_BCERR_Msk = 0x8
	// Bit BCERR.
	FLCN_FSTATR2_BCERR = 0x8
	// Blank checking terminates normally
	FLCN_FSTATR2_BCERR_0 = 0x0
	// An error occurs during blank checking.
	FLCN_FSTATR2_BCERR_1 = 0x1
	// Position of ILGLERR field.
	FLCN_FSTATR2_ILGLERR_Pos = 0x4
	// Bit mask of ILGLERR field.
	FLCN_FSTATR2_ILGLERR_Msk = 0x10
	// Bit ILGLERR.
	FLCN_FSTATR2_ILGLERR = 0x10
	// No illegal software command or illegal access is detected
	FLCN_FSTATR2_ILGLERR_0 = 0x0
	// An illegal command or illegal access is detected.
	FLCN_FSTATR2_ILGLERR_1 = 0x1
	// Position of EILGLERR field.
	FLCN_FSTATR2_EILGLERR_Pos = 0x5
	// Bit mask of EILGLERR field.
	FLCN_FSTATR2_EILGLERR_Msk = 0x20
	// Bit EILGLERR.
	FLCN_FSTATR2_EILGLERR = 0x20
	// No illegal command or illegal access to the extra area is detected
	FLCN_FSTATR2_EILGLERR_0 = 0x0
	// An illegal command or illegal access to the extra area is detected.
	FLCN_FSTATR2_EILGLERR_1 = 0x1

	// TSCDR: Temperature Sensor Calibration Data Register
	// Position of TSCDR field.
	FLCN_TSCDR_TSCDR_Pos = 0x0
	// Bit mask of TSCDR field.
	FLCN_TSCDR_TSCDR_Msk = 0xffff

	// CTSUTRIMA: CTSU Trimming Register A
	// Position of RTRIM field.
	FLCN_CTSUTRIMA_RTRIM_Pos = 0x0
	// Bit mask of RTRIM field.
	FLCN_CTSUTRIMA_RTRIM_Msk = 0xff
	// Position of DACTRIM field.
	FLCN_CTSUTRIMA_DACTRIM_Pos = 0x8
	// Bit mask of DACTRIM field.
	FLCN_CTSUTRIMA_DACTRIM_Msk = 0xff00
	// Position of SUADJD field.
	FLCN_CTSUTRIMA_SUADJD_Pos = 0x10
	// Bit mask of SUADJD field.
	FLCN_CTSUTRIMA_SUADJD_Msk = 0xff0000
	// Position of SUADJTRIM field.
	FLCN_CTSUTRIMA_SUADJTRIM_Pos = 0x18
	// Bit mask of SUADJTRIM field.
	FLCN_CTSUTRIMA_SUADJTRIM_Msk = 0xff000000

	// CTSUTRIMB: CTSU Trimming Register B
	// Position of TRESULT0 field.
	FLCN_CTSUTRIMB_TRESULT0_Pos = 0x0
	// Bit mask of TRESULT0 field.
	FLCN_CTSUTRIMB_TRESULT0_Msk = 0xff
	// Position of TRESULT1 field.
	FLCN_CTSUTRIMB_TRESULT1_Pos = 0x8
	// Bit mask of TRESULT1 field.
	FLCN_CTSUTRIMB_TRESULT1_Msk = 0xff00
	// Position of TRESULT2 field.
	FLCN_CTSUTRIMB_TRESULT2_Pos = 0x10
	// Bit mask of TRESULT2 field.
	FLCN_CTSUTRIMB_TRESULT2_Msk = 0xff0000
	// Position of TRESULT3 field.
	FLCN_CTSUTRIMB_TRESULT3_Pos = 0x18
	// Bit mask of TRESULT3 field.
	FLCN_CTSUTRIMB_TRESULT3_Msk = 0xff000000

	// FENTRYR: Flash P/E Mode Entry Register
	// Position of FENTRY0 field.
	FLCN_FENTRYR_FENTRY0_Pos = 0x0
	// Bit mask of FENTRY0 field.
	FLCN_FENTRYR_FENTRY0_Msk = 0x1
	// Bit FENTRY0.
	FLCN_FENTRYR_FENTRY0 = 0x1
	// The code flash is the read mode
	FLCN_FENTRYR_FENTRY0_0 = 0x0
	// The code flash is the P/E mode.
	FLCN_FENTRYR_FENTRY0_1 = 0x1
	// Position of FENTRYD field.
	FLCN_FENTRYR_FENTRYD_Pos = 0x7
	// Bit mask of FENTRYD field.
	FLCN_FENTRYR_FENTRYD_Msk = 0x80
	// Bit FENTRYD.
	FLCN_FENTRYR_FENTRYD = 0x80
	// The data flash is the read mode
	FLCN_FENTRYR_FENTRYD_0 = 0x0
	// The data flash is the P/E mode.
	FLCN_FENTRYR_FENTRYD_1 = 0x1
	// Position of FEKEY field.
	FLCN_FENTRYR_FEKEY_Pos = 0x8
	// Bit mask of FEKEY field.
	FLCN_FENTRYR_FEKEY_Msk = 0xff00

	// FLDWAITR: Memory Wait Cycle Control Register for Data Flash
	// Position of FLDWAIT1 field.
	FLCN_FLDWAITR_FLDWAIT1_Pos = 0x0
	// Bit mask of FLDWAIT1 field.
	FLCN_FLDWAITR_FLDWAIT1_Msk = 0x1
	// Bit FLDWAIT1.
	FLCN_FLDWAITR_FLDWAIT1 = 0x1
	// 1 wait access (Default)
	FLCN_FLDWAITR_FLDWAIT1_0 = 0x0
	// 2 wait access
	FLCN_FLDWAITR_FLDWAIT1_1 = 0x1

	// PFBER: Prefetch Buffer Enable Register
	// Position of PFBE field.
	FLCN_PFBER_PFBE_Pos = 0x0
	// Bit mask of PFBE field.
	FLCN_PFBER_PFBE_Msk = 0x1
	// Bit PFBE.
	FLCN_PFBER_PFBE = 0x1
	// Prefetch buffer is disabled
	FLCN_PFBER_PFBE_0 = 0x0
	// Prefetch buffer is enabled
	FLCN_PFBER_PFBE_1 = 0x1
)
