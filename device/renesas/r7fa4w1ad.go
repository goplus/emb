// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from R7FA4W1AD.svd, see https://github.com/cmsis-svd/cmsis-svd-data/tree/master/data/Renesas

//go:build renesas && r7fa4w1ad

/*
// ARM 32-bit Cortex-M4F Microcontroller based device, CPU clock up to 48MHz, etc.
*/

package renesas

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "R7FA4W1AD"
	CPU          = "CM4"
	FPUPresent   = true
	NVICPrioBits = 4
)

// Interrupt numbers.
const (
	// Interrupt Controller
	IRQ_IEL0 = 0

	// Interrupt Controller
	IRQ_IEL1 = 1

	// Interrupt Controller
	IRQ_IEL2 = 2

	// Interrupt Controller
	IRQ_IEL3 = 3

	// Interrupt Controller
	IRQ_IEL4 = 4

	// Interrupt Controller
	IRQ_IEL5 = 5

	// Interrupt Controller
	IRQ_IEL6 = 6

	// Interrupt Controller
	IRQ_IEL7 = 7

	// Interrupt Controller
	IRQ_IEL8 = 8

	// Interrupt Controller
	IRQ_IEL9 = 9

	// Interrupt Controller
	IRQ_IEL10 = 10

	// Interrupt Controller
	IRQ_IEL11 = 11

	// Interrupt Controller
	IRQ_IEL12 = 12

	// Interrupt Controller
	IRQ_IEL13 = 13

	// Interrupt Controller
	IRQ_IEL14 = 14

	// Interrupt Controller
	IRQ_IEL15 = 15

	// Interrupt Controller
	IRQ_IEL16 = 16

	// Interrupt Controller
	IRQ_IEL17 = 17

	// Interrupt Controller
	IRQ_IEL18 = 18

	// Interrupt Controller
	IRQ_IEL19 = 19

	// Interrupt Controller
	IRQ_IEL20 = 20

	// Interrupt Controller
	IRQ_IEL21 = 21

	// Interrupt Controller
	IRQ_IEL22 = 22

	// Interrupt Controller
	IRQ_IEL23 = 23

	// Interrupt Controller
	IRQ_IEL24 = 24

	// Interrupt Controller
	IRQ_IEL25 = 25

	// Interrupt Controller
	IRQ_IEL26 = 26

	// Interrupt Controller
	IRQ_IEL27 = 27

	// Interrupt Controller
	IRQ_IEL28 = 28

	// Interrupt Controller
	IRQ_IEL29 = 29

	// Interrupt Controller
	IRQ_IEL30 = 30

	// Interrupt Controller
	IRQ_IEL31 = 31

	// Highest interrupt number on this device.
	IRQ_max = 31
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export IEL0_IRQHandler
func interruptIEL0() {
	callHandlers(IRQ_IEL0)
}

//export IEL1_IRQHandler
func interruptIEL1() {
	callHandlers(IRQ_IEL1)
}

//export IEL2_IRQHandler
func interruptIEL2() {
	callHandlers(IRQ_IEL2)
}

//export IEL3_IRQHandler
func interruptIEL3() {
	callHandlers(IRQ_IEL3)
}

//export IEL4_IRQHandler
func interruptIEL4() {
	callHandlers(IRQ_IEL4)
}

//export IEL5_IRQHandler
func interruptIEL5() {
	callHandlers(IRQ_IEL5)
}

//export IEL6_IRQHandler
func interruptIEL6() {
	callHandlers(IRQ_IEL6)
}

//export IEL7_IRQHandler
func interruptIEL7() {
	callHandlers(IRQ_IEL7)
}

//export IEL8_IRQHandler
func interruptIEL8() {
	callHandlers(IRQ_IEL8)
}

//export IEL9_IRQHandler
func interruptIEL9() {
	callHandlers(IRQ_IEL9)
}

//export IEL10_IRQHandler
func interruptIEL10() {
	callHandlers(IRQ_IEL10)
}

//export IEL11_IRQHandler
func interruptIEL11() {
	callHandlers(IRQ_IEL11)
}

//export IEL12_IRQHandler
func interruptIEL12() {
	callHandlers(IRQ_IEL12)
}

//export IEL13_IRQHandler
func interruptIEL13() {
	callHandlers(IRQ_IEL13)
}

//export IEL14_IRQHandler
func interruptIEL14() {
	callHandlers(IRQ_IEL14)
}

//export IEL15_IRQHandler
func interruptIEL15() {
	callHandlers(IRQ_IEL15)
}

//export IEL16_IRQHandler
func interruptIEL16() {
	callHandlers(IRQ_IEL16)
}

//export IEL17_IRQHandler
func interruptIEL17() {
	callHandlers(IRQ_IEL17)
}

//export IEL18_IRQHandler
func interruptIEL18() {
	callHandlers(IRQ_IEL18)
}

//export IEL19_IRQHandler
func interruptIEL19() {
	callHandlers(IRQ_IEL19)
}

//export IEL20_IRQHandler
func interruptIEL20() {
	callHandlers(IRQ_IEL20)
}

//export IEL21_IRQHandler
func interruptIEL21() {
	callHandlers(IRQ_IEL21)
}

//export IEL22_IRQHandler
func interruptIEL22() {
	callHandlers(IRQ_IEL22)
}

//export IEL23_IRQHandler
func interruptIEL23() {
	callHandlers(IRQ_IEL23)
}

//export IEL24_IRQHandler
func interruptIEL24() {
	callHandlers(IRQ_IEL24)
}

//export IEL25_IRQHandler
func interruptIEL25() {
	callHandlers(IRQ_IEL25)
}

//export IEL26_IRQHandler
func interruptIEL26() {
	callHandlers(IRQ_IEL26)
}

//export IEL27_IRQHandler
func interruptIEL27() {
	callHandlers(IRQ_IEL27)
}

//export IEL28_IRQHandler
func interruptIEL28() {
	callHandlers(IRQ_IEL28)
}

//export IEL29_IRQHandler
func interruptIEL29() {
	callHandlers(IRQ_IEL29)
}

//export IEL30_IRQHandler
func interruptIEL30() {
	callHandlers(IRQ_IEL30)
}

//export IEL31_IRQHandler
func interruptIEL31() {
	callHandlers(IRQ_IEL31)
}

// Peripherals.
var (
	// Port Output Enable Module for GPT
	POEG = (*POEG_Type)(unsafe.Pointer(uintptr(0x40042000)))

	// General PWM Timer 0 (32-bit)
	GPT320 = (*GPT320_Type)(unsafe.Pointer(uintptr(0x40078000)))

	// General PWM Timer 1 (32-bit)
	GPT321 = (*GPT320_Type)(unsafe.Pointer(uintptr(0x40078100)))

	// General PWM Timer 2 (32-bit)
	GPT322 = (*GPT320_Type)(unsafe.Pointer(uintptr(0x40078200)))

	// General PWM Timer 3 (32-bit)
	GPT323 = (*GPT320_Type)(unsafe.Pointer(uintptr(0x40078300)))

	// General PWM Timer 4 (16-bit)
	GPT164 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40078400)))

	// General PWM Timer 5 (16-bit)
	GPT165 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40078500)))

	// General PWM Timer 6 (16-bit)
	GPT166 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40078600)))

	// General PWM Timer 7 (16-bit)
	GPT167 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40078700)))

	// General PWM Timer 8 (16-bit)
	GPT168 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40078800)))

	// General PWM Timer 9 (16-bit)
	GPT169 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40078900)))

	// Output Phase Switching Controller
	GPT_OPS = (*GPT_OPS_Type)(unsafe.Pointer(uintptr(0x40078ff0)))

	// Asynchronous General purpose Timer 0
	AGT0 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x40084000)))

	// Asynchronous General purpose Timer 1
	AGT1 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x40084100)))

	// Realtime Clock
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x40044000)))

	// System Control
	SYSTEM = (*SYSTEM_Type)(unsafe.Pointer(uintptr(0x4001e000)))

	// Module Stop Control B,C,D
	MSTP = (*MSTP_Type)(unsafe.Pointer(uintptr(0x40047000)))

	// Flash Cache
	FCACHE = (*FCACHE_Type)(unsafe.Pointer(uintptr(0x4001c000)))

	// Interrupt Controller
	ICU = (*ICU_Type)(unsafe.Pointer(uintptr(0x40006000)))

	// Direct memory access controller 0
	DMAC0 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005000)))

	// Direct memory access controller 1
	DMAC1 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005040)))

	// Direct memory access controller 2
	DMAC2 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005080)))

	// Direct memory access controller 3
	DMAC3 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x400050c0)))

	// DMAC Module Activation
	DMA = (*DMA_Type)(unsafe.Pointer(uintptr(0x40005200)))

	// Debug Function
	DBG = (*DBG_Type)(unsafe.Pointer(uintptr(0x4001b000)))

	// BUS Control
	BUS = (*BUS_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// SRAM Control
	SRAM = (*SRAM_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// Bus Master MPU
	MMPU = (*MMPU_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Bus Slave MPU
	SMPU = (*SMPU_Type)(unsafe.Pointer(uintptr(0x40000c00)))

	// CPU Stack Pointer Monitor
	SPMON = (*SPMON_Type)(unsafe.Pointer(uintptr(0x40000d00)))

	// Memory Mirror Function
	MMF = (*MMF_Type)(unsafe.Pointer(uintptr(0x40001000)))

	// Serial Peripheral Interface 0
	SPI0 = (*SPI0_Type)(unsafe.Pointer(uintptr(0x40072000)))

	// Serial Peripheral Interface 1
	SPI1 = (*SPI1_Type)(unsafe.Pointer(uintptr(0x40072100)))

	// Serial Communication Interface 0
	SCI0 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x40070000)))

	// Serial Communication Interface 1
	SCI1 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x40070020)))

	// Serial Communication Interface 2
	SCI2 = (*SCI2_Type)(unsafe.Pointer(uintptr(0x40070040)))

	// Serial Communication Interface 3
	SCI3 = (*SCI2_Type)(unsafe.Pointer(uintptr(0x40070060)))

	// Serial Communication Interface 4
	SCI4 = (*SCI2_Type)(unsafe.Pointer(uintptr(0x40070080)))

	// Serial Communication Interface 9
	SCI9 = (*SCI2_Type)(unsafe.Pointer(uintptr(0x40070120)))

	// Inter-Integrated Circuit 0
	IIC0 = (*IIC0_Type)(unsafe.Pointer(uintptr(0x40053000)))

	// Inter-Integrated Circuit 1
	IIC1 = (*IIC1_Type)(unsafe.Pointer(uintptr(0x40053100)))

	// Inter-Integrated Circuit 2
	IIC2 = (*IIC1_Type)(unsafe.Pointer(uintptr(0x40053200)))

	// CAN0 Module
	CAN0 = (*CAN0_Type)(unsafe.Pointer(uintptr(0x40050000)))

	// Watchdog Timer
	WDT = (*WDT_Type)(unsafe.Pointer(uintptr(0x40044200)))

	// USB 2.0 FS Module
	USBFS = (*USBFS_Type)(unsafe.Pointer(uintptr(0x40090000)))

	// Independent Watchdog Timer
	IWDT = (*IWDT_Type)(unsafe.Pointer(uintptr(0x40044400)))

	// Port 0 Control Registers
	PORT0 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040000)))

	// Port 1 Control Registers
	PORT1 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40040020)))

	// Port 2 Control Registers
	PORT2 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40040040)))

	// Port 3 Control Registers
	PORT3 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40040060)))

	// Port 4 Control Registers
	PORT4 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40040080)))

	// Port 5 Control Registers
	PORT5 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x400400a0)))

	// Port 6 Control Registers
	PORT6 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x400400c0)))

	// Port 7 Control Registers
	PORT7 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x400400e0)))

	// Port 8 Control Registers
	PORT8 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040100)))

	// Port 9 Control Registers
	PORT9 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040120)))

	// Pmn Pin Function Control Register
	PFS = (*PFS_Type)(unsafe.Pointer(uintptr(0x40040800)))

	// Miscellaneous Port Control Register
	PMISC = (*PMISC_Type)(unsafe.Pointer(uintptr(0x40040d00)))

	// Event Link Controller
	ELC = (*ELC_Type)(unsafe.Pointer(uintptr(0x40041000)))

	// Data Operation Circuit
	DOC = (*DOC_Type)(unsafe.Pointer(uintptr(0x40054100)))

	// CRC Calculator
	CRC = (*CRC_Type)(unsafe.Pointer(uintptr(0x40074000)))

	// Clock Frequency Accuracy Measurement Circuit
	CAC = (*CAC_Type)(unsafe.Pointer(uintptr(0x40044600)))

	// 8-bit D/A converter
	DAC8 = (*DAC8_Type)(unsafe.Pointer(uintptr(0x4009e000)))

	// 12-bit D/A converter
	DAC12 = (*DAC12_Type)(unsafe.Pointer(uintptr(0x4005e000)))

	// Capacitive Touch Sensing Unit
	CTSU = (*CTSU_Type)(unsafe.Pointer(uintptr(0x40081000)))

	// 14bit A/D Converter
	ADC140 = (*ADC140_Type)(unsafe.Pointer(uintptr(0x4005c000)))

	// Low-Power Analog Comparator
	ACMPLP = (*ACMPLP_Type)(unsafe.Pointer(uintptr(0x40085e00)))

	// Temperature Sensor
	TSN = (*TSN_Type)(unsafe.Pointer(uintptr(0x407ec000)))

	// Segment LCD Controller/Driver
	SLCDC = (*SLCDC_Type)(unsafe.Pointer(uintptr(0x40082000)))

	// OperationalAmplifier
	OPAMP = (*OPAMP_Type)(unsafe.Pointer(uintptr(0x40086000)))

	// Data Transfer Controller
	DTC = (*DTC_Type)(unsafe.Pointer(uintptr(0x40005400)))

	// Key Interrupt Function
	KINT = (*KINT_Type)(unsafe.Pointer(uintptr(0x40080000)))
)

// Port Output Enable Module for GPT
type POEG_Type struct {
	POEGGA volatile.Register32 // 0x0
	_      [252]byte
	POEGGB volatile.Register32 // 0x100
}

// POEG.POEGGA: POEG Group %s Setting Register
func (o *POEG_Type) SetPOEGGA_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGA_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0xc0000000) >> 30
}
func (o *POEG_Type) SetPOEGGA_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGA_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGA_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGA_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGA_Reserved(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0xffe0000)|value<<17)
}
func (o *POEG_Type) GetPOEGGA_Reserved() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0xffe0000) >> 17
}
func (o *POEG_Type) SetPOEGGA_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGA_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGA_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGA_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGA_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGA_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGA_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGA_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGA_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGA_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGA_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGA_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGA_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGA_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGA_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGA_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGA.Reg) & 0x1
}

// POEG.POEGGB: POEG Group %s Setting Register
func (o *POEG_Type) SetPOEGGB_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGB_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0xc0000000) >> 30
}
func (o *POEG_Type) SetPOEGGB_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGB_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGB_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGB_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGB_Reserved(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0xffe0000)|value<<17)
}
func (o *POEG_Type) GetPOEGGB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0xffe0000) >> 17
}
func (o *POEG_Type) SetPOEGGB_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGB_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGB_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGB_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGB_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGB_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGB_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGB_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGB_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGB_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGB_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGB_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGB_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGB_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGB_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGB_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGB.Reg) & 0x1
}

// General PWM Timer 0 (32-bit)
type GPT320_Type struct {
	GTWP     volatile.Register32 // 0x0
	GTSTR    volatile.Register32 // 0x4
	GTSTP    volatile.Register32 // 0x8
	GTCLR    volatile.Register32 // 0xC
	GTSSR    volatile.Register32 // 0x10
	GTPSR    volatile.Register32 // 0x14
	GTCSR    volatile.Register32 // 0x18
	GTUPSR   volatile.Register32 // 0x1C
	GTDNSR   volatile.Register32 // 0x20
	GTICASR  volatile.Register32 // 0x24
	GTICBSR  volatile.Register32 // 0x28
	GTCR     volatile.Register32 // 0x2C
	GTUDDTYC volatile.Register32 // 0x30
	GTIOR    volatile.Register32 // 0x34
	GTINTAD  volatile.Register32 // 0x38
	GTST     volatile.Register32 // 0x3C
	GTBER    volatile.Register32 // 0x40
	_        [4]byte
	GTCNT    volatile.Register32 // 0x48
	GTCCRA   volatile.Register32 // 0x4C
	GTCCRB   volatile.Register32 // 0x50
	GTCCRC   volatile.Register32 // 0x54
	GTCCRE   volatile.Register32 // 0x58
	GTCCRD   volatile.Register32 // 0x5C
	GTCCRF   volatile.Register32 // 0x60
	GTPR     volatile.Register32 // 0x64
	GTPBR    volatile.Register32 // 0x68
	_        [28]byte
	GTDTCR   volatile.Register32 // 0x88
	GTDVU    volatile.Register32 // 0x8C
}

// GPT320.GTWP: General PWM Timer Write-Protection Register
func (o *GPT320_Type) SetGTWP_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPT320_Type) GetGTWP_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xffff0000) >> 16
}
func (o *GPT320_Type) SetGTWP_PRKEY(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xff00)|value<<8)
}
func (o *GPT320_Type) GetGTWP_PRKEY() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xff00) >> 8
}
func (o *GPT320_Type) SetGTWP_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xfe)|value<<1)
}
func (o *GPT320_Type) GetGTWP_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xfe) >> 1
}
func (o *GPT320_Type) SetGTWP_WP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTWP_WP() uint32 {
	return volatile.LoadUint32(&o.GTWP.Reg) & 0x1
}

// GPT320.GTSTR: General PWM Timer Software Start Register
func (o *GPT320_Type) SetGTSTR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *GPT320_Type) GetGTSTR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0xfffffc00) >> 10
}
func (o *GPT320_Type) SetGTSTR_CSTRT9(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTSTR_CSTRT9() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTSTR_CSTRT8(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTSTR_CSTRT8() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTSTR_CSTRT7(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x80)|value<<7)
}
func (o *GPT320_Type) GetGTSTR_CSTRT7() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x80) >> 7
}
func (o *GPT320_Type) SetGTSTR_CSTRT6(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTSTR_CSTRT6() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTSTR_CSTRT5(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTSTR_CSTRT5() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTSTR_CSTRT4(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x10)|value<<4)
}
func (o *GPT320_Type) GetGTSTR_CSTRT4() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x10) >> 4
}
func (o *GPT320_Type) SetGTSTR_CSTRT3(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTSTR_CSTRT3() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTSTR_CSTRT2(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTSTR_CSTRT2() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTSTR_CSTRT1(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTSTR_CSTRT1() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTSTR_CSTRT0(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTSTR_CSTRT0() uint32 {
	return volatile.LoadUint32(&o.GTSTR.Reg) & 0x1
}

// GPT320.GTSTP: General PWM Timer Software Stop Register
func (o *GPT320_Type) SetGTSTP_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0xfffffc00)|value<<10)
}
func (o *GPT320_Type) GetGTSTP_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0xfffffc00) >> 10
}
func (o *GPT320_Type) SetGTSTP_CSTOP9(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTSTP_CSTOP9() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTSTP_CSTOP8(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTSTP_CSTOP8() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTSTP_CSTOP7(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x80)|value<<7)
}
func (o *GPT320_Type) GetGTSTP_CSTOP7() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x80) >> 7
}
func (o *GPT320_Type) SetGTSTP_CSTOP6(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTSTP_CSTOP6() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTSTP_CSTOP5(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTSTP_CSTOP5() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTSTP_CSTOP4(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x10)|value<<4)
}
func (o *GPT320_Type) GetGTSTP_CSTOP4() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x10) >> 4
}
func (o *GPT320_Type) SetGTSTP_CSTOP3(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTSTP_CSTOP3() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTSTP_CSTOP2(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTSTP_CSTOP2() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTSTP_CSTOP1(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTSTP_CSTOP1() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTSTP_CSTOP0(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTSTP_CSTOP0() uint32 {
	return volatile.LoadUint32(&o.GTSTP.Reg) & 0x1
}

// GPT320.GTCLR: General PWM Timer Software Clear Register
func (o *GPT320_Type) SetGTCLR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *GPT320_Type) GetGTCLR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0xfffffc00) >> 10
}
func (o *GPT320_Type) SetGTCLR_CCLR9(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTCLR_CCLR9() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTCLR_CCLR8(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTCLR_CCLR8() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTCLR_CCLR7(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPT320_Type) GetGTCLR_CCLR7() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x80) >> 7
}
func (o *GPT320_Type) SetGTCLR_CCLR6(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTCLR_CCLR6() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTCLR_CCLR5(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTCLR_CCLR5() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTCLR_CCLR4(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPT320_Type) GetGTCLR_CCLR4() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x10) >> 4
}
func (o *GPT320_Type) SetGTCLR_CCLR3(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTCLR_CCLR3() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTCLR_CCLR2(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTCLR_CCLR2() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTCLR_CCLR1(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTCLR_CCLR1() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTCLR_CCLR0(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTCLR_CCLR0() uint32 {
	return volatile.LoadUint32(&o.GTCLR.Reg) & 0x1
}

// GPT320.GTSSR: General PWM Timer Start Source Select Register
func (o *GPT320_Type) SetGTSSR_CSTRT(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT320_Type) GetGTSSR_CSTRT() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000000) >> 31
}
func (o *GPT320_Type) SetGTSSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x7f000000)|value<<24)
}
func (o *GPT320_Type) GetGTSSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x7f000000) >> 24
}
func (o *GPT320_Type) SetGTSSR_SSELCH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT320_Type) GetGTSSR_SSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800000) >> 23
}
func (o *GPT320_Type) SetGTSSR_SSELCG(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT320_Type) GetGTSSR_SSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400000) >> 22
}
func (o *GPT320_Type) SetGTSSR_SSELCF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT320_Type) GetGTSSR_SSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200000) >> 21
}
func (o *GPT320_Type) SetGTSSR_SSELCE(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT320_Type) GetGTSSR_SSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100000) >> 20
}
func (o *GPT320_Type) SetGTSSR_SSELCD(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTSSR_SSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTSSR_SSELCC(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTSSR_SSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTSSR_SSELCB(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTSSR_SSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTSSR_SSELCA(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTSSR_SSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTSSR_SSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTSSR_SSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTSSR_SSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTSSR_SSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTSSR_SSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTSSR_SSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTSSR_SSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTSSR_SSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTSSR_SSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTSSR_SSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTSSR_SSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTSSR_SSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTSSR_SSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTSSR_SSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTSSR_SSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTSSR_SSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTSSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0xf0)|value<<4)
}
func (o *GPT320_Type) GetGTSSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0xf0) >> 4
}
func (o *GPT320_Type) SetGTSSR_SSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTSSR_SSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTSSR_SSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTSSR_SSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTSSR_SSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTSSR_SSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTSSR_SSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTSSR_SSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTSSR.Reg) & 0x1
}

// GPT320.GTPSR: General PWM Timer Stop Source Select Register
func (o *GPT320_Type) SetGTPSR_CSTOP(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT320_Type) GetGTPSR_CSTOP() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000000) >> 31
}
func (o *GPT320_Type) SetGTPSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x7f000000)|value<<24)
}
func (o *GPT320_Type) GetGTPSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x7f000000) >> 24
}
func (o *GPT320_Type) SetGTPSR_PSELCH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT320_Type) GetGTPSR_PSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800000) >> 23
}
func (o *GPT320_Type) SetGTPSR_PSELCG(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT320_Type) GetGTPSR_PSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400000) >> 22
}
func (o *GPT320_Type) SetGTPSR_PSELCF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT320_Type) GetGTPSR_PSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200000) >> 21
}
func (o *GPT320_Type) SetGTPSR_PSELCE(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT320_Type) GetGTPSR_PSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100000) >> 20
}
func (o *GPT320_Type) SetGTPSR_PSELCD(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTPSR_PSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTPSR_PSELCC(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTPSR_PSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTPSR_PSELCB(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTPSR_PSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTPSR_PSELCA(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTPSR_PSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTPSR_PSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTPSR_PSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTPSR_PSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTPSR_PSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTPSR_PSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTPSR_PSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTPSR_PSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTPSR_PSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTPSR_PSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTPSR_PSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTPSR_PSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTPSR_PSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTPSR_PSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTPSR_PSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTPSR_PSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTPSR_PSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTPSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0xf0)|value<<4)
}
func (o *GPT320_Type) GetGTPSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0xf0) >> 4
}
func (o *GPT320_Type) SetGTPSR_PSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTPSR_PSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTPSR_PSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTPSR_PSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTPSR_PSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTPSR_PSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTPSR_PSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTPSR_PSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTPSR.Reg) & 0x1
}

// GPT320.GTCSR: General PWM Timer Clear Source Select Register
func (o *GPT320_Type) SetGTCSR_CCLR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT320_Type) GetGTCSR_CCLR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000000) >> 31
}
func (o *GPT320_Type) SetGTCSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x7f000000)|value<<24)
}
func (o *GPT320_Type) GetGTCSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x7f000000) >> 24
}
func (o *GPT320_Type) SetGTCSR_CSELCH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT320_Type) GetGTCSR_CSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800000) >> 23
}
func (o *GPT320_Type) SetGTCSR_CSELCG(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT320_Type) GetGTCSR_CSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400000) >> 22
}
func (o *GPT320_Type) SetGTCSR_CSELCF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT320_Type) GetGTCSR_CSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200000) >> 21
}
func (o *GPT320_Type) SetGTCSR_CSELCE(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT320_Type) GetGTCSR_CSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100000) >> 20
}
func (o *GPT320_Type) SetGTCSR_CSELCD(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTCSR_CSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTCSR_CSELCC(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTCSR_CSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTCSR_CSELCB(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTCSR_CSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTCSR_CSELCA(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTCSR_CSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTCSR_CSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTCSR_CSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTCSR_CSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTCSR_CSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTCSR_CSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTCSR_CSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTCSR_CSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTCSR_CSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTCSR_CSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTCSR_CSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTCSR_CSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTCSR_CSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTCSR_CSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTCSR_CSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTCSR_CSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTCSR_CSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTCSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0xf0)|value<<4)
}
func (o *GPT320_Type) GetGTCSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0xf0) >> 4
}
func (o *GPT320_Type) SetGTCSR_CSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTCSR_CSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTCSR_CSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTCSR_CSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTCSR_CSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTCSR_CSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTCSR_CSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTCSR_CSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTCSR.Reg) & 0x1
}

// GPT320.GTUPSR: General PWM Timer Up Count Source Select Register
func (o *GPT320_Type) SetGTUPSR_USELCH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT320_Type) GetGTUPSR_USELCH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800000) >> 23
}
func (o *GPT320_Type) SetGTUPSR_USELCG(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT320_Type) GetGTUPSR_USELCG() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400000) >> 22
}
func (o *GPT320_Type) SetGTUPSR_USELCF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT320_Type) GetGTUPSR_USELCF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200000) >> 21
}
func (o *GPT320_Type) SetGTUPSR_USELCE(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT320_Type) GetGTUPSR_USELCE() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100000) >> 20
}
func (o *GPT320_Type) SetGTUPSR_USELCD(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTUPSR_USELCD() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTUPSR_USELCC(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTUPSR_USELCC() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTUPSR_USELCB(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTUPSR_USELCB() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTUPSR_USELCA(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTUPSR_USELCA() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTUPSR_USCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTUPSR_USCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTUPSR_USCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTUPSR_USCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTUPSR_USCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTUPSR_USCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTUPSR_USCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTUPSR_USCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTUPSR_USCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTUPSR_USCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTUPSR_USCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTUPSR_USCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTUPSR_USCARBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTUPSR_USCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTUPSR_USCARBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTUPSR_USCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTUPSR_USGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTUPSR_USGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTUPSR_USGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTUPSR_USGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTUPSR_USGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTUPSR_USGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTUPSR_USGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTUPSR_USGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1
}

// GPT320.GTDNSR: General PWM Timer Down Count Source Select Register
func (o *GPT320_Type) SetGTDNSR_DSELCH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT320_Type) GetGTDNSR_DSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800000) >> 23
}
func (o *GPT320_Type) SetGTDNSR_DSELCG(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT320_Type) GetGTDNSR_DSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400000) >> 22
}
func (o *GPT320_Type) SetGTDNSR_DSELCF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT320_Type) GetGTDNSR_DSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200000) >> 21
}
func (o *GPT320_Type) SetGTDNSR_DSELCE(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT320_Type) GetGTDNSR_DSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100000) >> 20
}
func (o *GPT320_Type) SetGTDNSR_DSELCD(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTDNSR_DSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTDNSR_DSELCC(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTDNSR_DSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTDNSR_DSELCB(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTDNSR_DSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTDNSR_DSELCA(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTDNSR_DSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTDNSR_DSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTDNSR_DSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTDNSR_DSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTDNSR_DSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTDNSR_DSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTDNSR_DSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTDNSR_DSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTDNSR_DSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTDNSR_DSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTDNSR_DSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTDNSR_DSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTDNSR_DSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTDNSR_DSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTDNSR_DSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTDNSR_DSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTDNSR_DSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTDNSR_DSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTDNSR_DSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTDNSR_DSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTDNSR_DSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTDNSR_DSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTDNSR_DSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTDNSR_DSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTDNSR_DSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1
}

// GPT320.GTICASR: General PWM Timer Input Capture Source Select Register A
func (o *GPT320_Type) SetGTICASR_ASELCH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT320_Type) GetGTICASR_ASELCH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800000) >> 23
}
func (o *GPT320_Type) SetGTICASR_ASELCG(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT320_Type) GetGTICASR_ASELCG() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400000) >> 22
}
func (o *GPT320_Type) SetGTICASR_ASELCF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT320_Type) GetGTICASR_ASELCF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200000) >> 21
}
func (o *GPT320_Type) SetGTICASR_ASELCE(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT320_Type) GetGTICASR_ASELCE() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100000) >> 20
}
func (o *GPT320_Type) SetGTICASR_ASELCD(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTICASR_ASELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTICASR_ASELCC(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTICASR_ASELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTICASR_ASELCB(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTICASR_ASELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTICASR_ASELCA(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTICASR_ASELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTICASR_ASCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTICASR_ASCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTICASR_ASCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTICASR_ASCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTICASR_ASCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTICASR_ASCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTICASR_ASCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTICASR_ASCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTICASR_ASCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTICASR_ASCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTICASR_ASCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTICASR_ASCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTICASR_ASCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTICASR_ASCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTICASR_ASCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTICASR_ASCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTICASR_ASGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTICASR_ASGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTICASR_ASGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTICASR_ASGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTICASR_ASGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTICASR_ASGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTICASR_ASGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTICASR_ASGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICASR.Reg) & 0x1
}

// GPT320.GTICBSR: General PWM Timer Input Capture Source Select Register B
func (o *GPT320_Type) SetGTICBSR_BSELCH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT320_Type) GetGTICBSR_BSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800000) >> 23
}
func (o *GPT320_Type) SetGTICBSR_BSELCG(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT320_Type) GetGTICBSR_BSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400000) >> 22
}
func (o *GPT320_Type) SetGTICBSR_BSELCF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT320_Type) GetGTICBSR_BSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200000) >> 21
}
func (o *GPT320_Type) SetGTICBSR_BSELCE(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT320_Type) GetGTICBSR_BSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100000) >> 20
}
func (o *GPT320_Type) SetGTICBSR_BSELCD(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTICBSR_BSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTICBSR_BSELCC(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTICBSR_BSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTICBSR_BSELCB(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTICBSR_BSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTICBSR_BSELCA(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTICBSR_BSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTICBSR_BSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTICBSR_BSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTICBSR_BSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTICBSR_BSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTICBSR_BSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTICBSR_BSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTICBSR_BSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTICBSR_BSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTICBSR_BSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTICBSR_BSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTICBSR_BSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTICBSR_BSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTICBSR_BSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTICBSR_BSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTICBSR_BSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTICBSR_BSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTICBSR_BSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTICBSR_BSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTICBSR_BSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTICBSR_BSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTICBSR_BSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTICBSR_BSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTICBSR_BSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTICBSR_BSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1
}

// GPT320.GTCR: General PWM Timer Control Register
func (o *GPT320_Type) SetGTCR_TPCS(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x7000000)|value<<24)
}
func (o *GPT320_Type) GetGTCR_TPCS() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x7000000) >> 24
}
func (o *GPT320_Type) SetGTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0xf80000)|value<<19)
}
func (o *GPT320_Type) GetGTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0xf80000) >> 19
}
func (o *GPT320_Type) SetGTCR_MD(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x70000)|value<<16)
}
func (o *GPT320_Type) GetGTCR_MD() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x70000) >> 16
}
func (o *GPT320_Type) SetGTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0xfffe)|value<<1)
}
func (o *GPT320_Type) GetGTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0xfffe) >> 1
}
func (o *GPT320_Type) SetGTCR_CST(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTCR_CST() uint32 {
	return volatile.LoadUint32(&o.GTCR.Reg) & 0x1
}

// GPT320.GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
func (o *GPT320_Type) SetGTUDDTYC_OBDTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x8000000)|value<<27)
}
func (o *GPT320_Type) GetGTUDDTYC_OBDTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x8000000) >> 27
}
func (o *GPT320_Type) SetGTUDDTYC_OBDTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT320_Type) GetGTUDDTYC_OBDTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x4000000) >> 26
}
func (o *GPT320_Type) SetGTUDDTYC_OBDTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT320_Type) GetGTUDDTYC_OBDTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x3000000) >> 24
}
func (o *GPT320_Type) SetGTUDDTYC_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0xf00000)|value<<20)
}
func (o *GPT320_Type) GetGTUDDTYC_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0xf00000) >> 20
}
func (o *GPT320_Type) SetGTUDDTYC_OADTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTUDDTYC_OADTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTUDDTYC_OADTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTUDDTYC_OADTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTUDDTYC_OADTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x30000)|value<<16)
}
func (o *GPT320_Type) GetGTUDDTYC_OADTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x30000) >> 16
}
func (o *GPT320_Type) SetGTUDDTYC_UDF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTUDDTYC_UDF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTUDDTYC_UD(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTUDDTYC_UD() uint32 {
	return volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x1
}

// GPT320.GTIOR: General PWM Timer I/O Control Register
func (o *GPT320_Type) SetGTIOR_NFCSB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT320_Type) GetGTIOR_NFCSB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc0000000) >> 30
}
func (o *GPT320_Type) SetGTIOR_NFBEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT320_Type) GetGTIOR_NFBEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20000000) >> 29
}
func (o *GPT320_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x18000000)|value<<27)
}
func (o *GPT320_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x18000000) >> 27
}
func (o *GPT320_Type) SetGTIOR_OBDF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x6000000)|value<<25)
}
func (o *GPT320_Type) GetGTIOR_OBDF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x6000000) >> 25
}
func (o *GPT320_Type) SetGTIOR_OBE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT320_Type) GetGTIOR_OBE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1000000) >> 24
}
func (o *GPT320_Type) SetGTIOR_OBHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT320_Type) GetGTIOR_OBHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x800000) >> 23
}
func (o *GPT320_Type) SetGTIOR_OBDFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT320_Type) GetGTIOR_OBDFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x400000) >> 22
}
func (o *GPT320_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT320_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x200000) >> 21
}
func (o *GPT320_Type) SetGTIOR_GTIOB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f0000)|value<<16)
}
func (o *GPT320_Type) GetGTIOR_GTIOB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f0000) >> 16
}
func (o *GPT320_Type) SetGTIOR_NFCSA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc000)|value<<14)
}
func (o *GPT320_Type) GetGTIOR_NFCSA() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc000) >> 14
}
func (o *GPT320_Type) SetGTIOR_NFAEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTIOR_NFAEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1800)|value<<11)
}
func (o *GPT320_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1800) >> 11
}
func (o *GPT320_Type) SetGTIOR_OADF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x600)|value<<9)
}
func (o *GPT320_Type) GetGTIOR_OADF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x600) >> 9
}
func (o *GPT320_Type) SetGTIOR_OAE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTIOR_OAE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTIOR_OAHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x80)|value<<7)
}
func (o *GPT320_Type) GetGTIOR_OAHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x80) >> 7
}
func (o *GPT320_Type) SetGTIOR_OADFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTIOR_OADFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTIOR_GTIOA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f)|value)
}
func (o *GPT320_Type) GetGTIOR_GTIOA() uint32 {
	return volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f
}

// GPT320.GTINTAD: General PWM Timer Interrupt Output Setting Register
func (o *GPT320_Type) SetGTINTAD_GRPABL(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT320_Type) GetGTINTAD_GRPABL() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x40000000) >> 30
}
func (o *GPT320_Type) SetGTINTAD_GRPABH(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT320_Type) GetGTINTAD_GRPABH() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x20000000) >> 29
}
func (o *GPT320_Type) SetGTINTAD_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x1c000000)|value<<26)
}
func (o *GPT320_Type) GetGTINTAD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x1c000000) >> 26
}
func (o *GPT320_Type) SetGTINTAD_GRP(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT320_Type) GetGTINTAD_GRP() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x3000000) >> 24
}
func (o *GPT320_Type) SetGTINTAD_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0xffffff)|value)
}
func (o *GPT320_Type) GetGTINTAD_Reserved() uint32 {
	return volatile.LoadUint32(&o.GTINTAD.Reg) & 0xffffff
}

// GPT320.GTST: General PWM Timer Status Register
func (o *GPT320_Type) SetGTST_OABLF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT320_Type) GetGTST_OABLF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40000000) >> 30
}
func (o *GPT320_Type) SetGTST_OABHF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT320_Type) GetGTST_OABHF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20000000) >> 29
}
func (o *GPT320_Type) SetGTST_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1e000000)|value<<25)
}
func (o *GPT320_Type) GetGTST_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1e000000) >> 25
}
func (o *GPT320_Type) SetGTST_ODF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT320_Type) GetGTST_ODF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1000000) >> 24
}
func (o *GPT320_Type) SetGTST_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0xff0000)|value<<16)
}
func (o *GPT320_Type) GetGTST_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0xff0000) >> 16
}
func (o *GPT320_Type) SetGTST_TUCF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTST_TUCF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTST_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x7f00)|value<<8)
}
func (o *GPT320_Type) GetGTST_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x7f00) >> 8
}
func (o *GPT320_Type) SetGTST_TCFPU(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x80)|value<<7)
}
func (o *GPT320_Type) GetGTST_TCFPU() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x80) >> 7
}
func (o *GPT320_Type) SetGTST_TCPFO(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTST_TCPFO() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTST_TCFF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTST_TCFF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTST_TCFE(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x10)|value<<4)
}
func (o *GPT320_Type) GetGTST_TCFE() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x10) >> 4
}
func (o *GPT320_Type) SetGTST_TCFD(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTST_TCFD() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTST_TCFC(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTST_TCFC() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTST_TCFB(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTST_TCFB() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTST_TCFA(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTST_TCFA() uint32 {
	return volatile.LoadUint32(&o.GTST.Reg) & 0x1
}

// GPT320.GTBER: General PWM Timer Buffer Enable Register
func (o *GPT320_Type) SetGTBER_CCRSWT(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x400000)|value<<22)
}
func (o *GPT320_Type) GetGTBER_CCRSWT() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x400000) >> 22
}
func (o *GPT320_Type) SetGTBER_PR(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x300000)|value<<20)
}
func (o *GPT320_Type) GetGTBER_PR() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x300000) >> 20
}
func (o *GPT320_Type) SetGTBER_CCRB(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPT320_Type) GetGTBER_CCRB() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0xc0000) >> 18
}
func (o *GPT320_Type) SetGTBER_CCRA(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x30000)|value<<16)
}
func (o *GPT320_Type) GetGTBER_CCRA() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x30000) >> 16
}
func (o *GPT320_Type) SetGTBER_BD(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x3)|value)
}
func (o *GPT320_Type) GetGTBER_BD() uint32 {
	return volatile.LoadUint32(&o.GTBER.Reg) & 0x3
}

// GPT320.GTCNT: General PWM Timer Counter
func (o *GPT320_Type) SetGTCNT(value uint32) {
	volatile.StoreUint32(&o.GTCNT.Reg, value)
}
func (o *GPT320_Type) GetGTCNT() uint32 {
	return volatile.LoadUint32(&o.GTCNT.Reg)
}

// GPT320.GTCCRA: General PWM Timer Compare Capture Register A
func (o *GPT320_Type) SetGTCCRA(value uint32) {
	volatile.StoreUint32(&o.GTCCRA.Reg, value)
}
func (o *GPT320_Type) GetGTCCRA() uint32 {
	return volatile.LoadUint32(&o.GTCCRA.Reg)
}

// GPT320.GTCCRB: General PWM Timer Compare Capture Register B
func (o *GPT320_Type) SetGTCCRB(value uint32) {
	volatile.StoreUint32(&o.GTCCRB.Reg, value)
}
func (o *GPT320_Type) GetGTCCRB() uint32 {
	return volatile.LoadUint32(&o.GTCCRB.Reg)
}

// GPT320.GTCCRC: General PWM Timer Compare Capture Register C
func (o *GPT320_Type) SetGTCCRC(value uint32) {
	volatile.StoreUint32(&o.GTCCRC.Reg, value)
}
func (o *GPT320_Type) GetGTCCRC() uint32 {
	return volatile.LoadUint32(&o.GTCCRC.Reg)
}

// GPT320.GTCCRE: General PWM Timer Compare Capture Register E
func (o *GPT320_Type) SetGTCCRE(value uint32) {
	volatile.StoreUint32(&o.GTCCRE.Reg, value)
}
func (o *GPT320_Type) GetGTCCRE() uint32 {
	return volatile.LoadUint32(&o.GTCCRE.Reg)
}

// GPT320.GTCCRD: General PWM Timer Compare Capture Register D
func (o *GPT320_Type) SetGTCCRD(value uint32) {
	volatile.StoreUint32(&o.GTCCRD.Reg, value)
}
func (o *GPT320_Type) GetGTCCRD() uint32 {
	return volatile.LoadUint32(&o.GTCCRD.Reg)
}

// GPT320.GTCCRF: General PWM Timer Compare Capture Register F
func (o *GPT320_Type) SetGTCCRF(value uint32) {
	volatile.StoreUint32(&o.GTCCRF.Reg, value)
}
func (o *GPT320_Type) GetGTCCRF() uint32 {
	return volatile.LoadUint32(&o.GTCCRF.Reg)
}

// GPT320.GTPR: General PWM Timer Cycle Setting Register
func (o *GPT320_Type) SetGTPR(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, value)
}
func (o *GPT320_Type) GetGTPR() uint32 {
	return volatile.LoadUint32(&o.GTPR.Reg)
}

// GPT320.GTPBR: General PWM Timer Cycle Setting Buffer Register
func (o *GPT320_Type) SetGTPBR(value uint32) {
	volatile.StoreUint32(&o.GTPBR.Reg, value)
}
func (o *GPT320_Type) GetGTPBR() uint32 {
	return volatile.LoadUint32(&o.GTPBR.Reg)
}

// GPT320.GTDTCR: General PWM Timer Dead Time Control Register
func (o *GPT320_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0xfffffe00)|value<<9)
}
func (o *GPT320_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0xfffffe00) >> 9
}
func (o *GPT320_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0xc0)|value<<6)
}
func (o *GPT320_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0xc0) >> 6
}
func (o *GPT320_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x10)|value<<4)
}
func (o *GPT320_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0x10) >> 4
}
func (o *GPT320_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0xe)|value<<1)
}
func (o *GPT320_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0xe) >> 1
}
func (o *GPT320_Type) SetGTDTCR_TDE(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTDTCR_TDE() uint32 {
	return volatile.LoadUint32(&o.GTDTCR.Reg) & 0x1
}

// GPT320.GTDVU: General PWM Timer Dead Time Value Register U
func (o *GPT320_Type) SetGTDVU(value uint32) {
	volatile.StoreUint32(&o.GTDVU.Reg, value)
}
func (o *GPT320_Type) GetGTDVU() uint32 {
	return volatile.LoadUint32(&o.GTDVU.Reg)
}

// General PWM Timer 4 (16-bit)
type GPT164_Type struct {
	GTWP     volatile.Register32 // 0x0
	GTSTR    volatile.Register32 // 0x4
	GTSTP    volatile.Register32 // 0x8
	GTCLR    volatile.Register32 // 0xC
	GTSSR    volatile.Register32 // 0x10
	GTPSR    volatile.Register32 // 0x14
	GTCSR    volatile.Register32 // 0x18
	GTUPSR   volatile.Register32 // 0x1C
	GTDNSR   volatile.Register32 // 0x20
	GTICASR  volatile.Register32 // 0x24
	GTICBSR  volatile.Register32 // 0x28
	GTCR     volatile.Register32 // 0x2C
	GTUDDTYC volatile.Register32 // 0x30
	GTIOR    volatile.Register32 // 0x34
	GTINTAD  volatile.Register32 // 0x38
	GTST     volatile.Register32 // 0x3C
	GTBER    volatile.Register32 // 0x40
	_        [4]byte
	GTCNT    volatile.Register32 // 0x48
	GTCCRA   volatile.Register32 // 0x4C
	GTCCRB   volatile.Register32 // 0x50
	GTCCRC   volatile.Register32 // 0x54
	GTCCRE   volatile.Register32 // 0x58
	GTCCRD   volatile.Register32 // 0x5C
	GTCCRF   volatile.Register32 // 0x60
	GTPR     volatile.Register32 // 0x64
	GTPBR    volatile.Register32 // 0x68
	_        [28]byte
	GTDTCR   volatile.Register32 // 0x88
	GTDVU    volatile.Register32 // 0x8C
}

// GPT164.GTWP: General PWM Timer Write-Protection Register
func (o *GPT164_Type) SetGTWP_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPT164_Type) GetGTWP_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xffff0000) >> 16
}
func (o *GPT164_Type) SetGTWP_PRKEY(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xff00)|value<<8)
}
func (o *GPT164_Type) GetGTWP_PRKEY() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xff00) >> 8
}
func (o *GPT164_Type) SetGTWP_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xfe)|value<<1)
}
func (o *GPT164_Type) GetGTWP_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xfe) >> 1
}
func (o *GPT164_Type) SetGTWP_WP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTWP_WP() uint32 {
	return volatile.LoadUint32(&o.GTWP.Reg) & 0x1
}

// GPT164.GTSTR: General PWM Timer Software Start Register
func (o *GPT164_Type) SetGTSTR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *GPT164_Type) GetGTSTR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0xfffffc00) >> 10
}
func (o *GPT164_Type) SetGTSTR_CSTRT9(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTSTR_CSTRT9() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTSTR_CSTRT8(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTSTR_CSTRT8() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTSTR_CSTRT7(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTSTR_CSTRT7() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTSTR_CSTRT6(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTSTR_CSTRT6() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTSTR_CSTRT5(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTSTR_CSTRT5() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTSTR_CSTRT4(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTSTR_CSTRT4() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTSTR_CSTRT3(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTSTR_CSTRT3() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTSTR_CSTRT2(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTSTR_CSTRT2() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTSTR_CSTRT1(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTSTR_CSTRT1() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTSTR_CSTRT0(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTSTR_CSTRT0() uint32 {
	return volatile.LoadUint32(&o.GTSTR.Reg) & 0x1
}

// GPT164.GTSTP: General PWM Timer Software Stop Register
func (o *GPT164_Type) SetGTSTP_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0xfffffc00)|value<<10)
}
func (o *GPT164_Type) GetGTSTP_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0xfffffc00) >> 10
}
func (o *GPT164_Type) SetGTSTP_CSTOP9(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTSTP_CSTOP9() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTSTP_CSTOP8(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTSTP_CSTOP8() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTSTP_CSTOP7(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTSTP_CSTOP7() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTSTP_CSTOP6(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTSTP_CSTOP6() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTSTP_CSTOP5(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTSTP_CSTOP5() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTSTP_CSTOP4(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTSTP_CSTOP4() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTSTP_CSTOP3(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTSTP_CSTOP3() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTSTP_CSTOP2(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTSTP_CSTOP2() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTSTP_CSTOP1(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTSTP_CSTOP1() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTSTP_CSTOP0(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTSTP_CSTOP0() uint32 {
	return volatile.LoadUint32(&o.GTSTP.Reg) & 0x1
}

// GPT164.GTCLR: General PWM Timer Software Clear Register
func (o *GPT164_Type) SetGTCLR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *GPT164_Type) GetGTCLR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0xfffffc00) >> 10
}
func (o *GPT164_Type) SetGTCLR_CCLR9(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTCLR_CCLR9() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTCLR_CCLR8(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTCLR_CCLR8() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTCLR_CCLR7(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTCLR_CCLR7() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTCLR_CCLR6(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTCLR_CCLR6() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTCLR_CCLR5(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTCLR_CCLR5() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTCLR_CCLR4(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTCLR_CCLR4() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTCLR_CCLR3(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTCLR_CCLR3() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTCLR_CCLR2(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTCLR_CCLR2() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTCLR_CCLR1(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTCLR_CCLR1() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTCLR_CCLR0(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTCLR_CCLR0() uint32 {
	return volatile.LoadUint32(&o.GTCLR.Reg) & 0x1
}

// GPT164.GTSSR: General PWM Timer Start Source Select Register
func (o *GPT164_Type) SetGTSSR_CSTRT(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT164_Type) GetGTSSR_CSTRT() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000000) >> 31
}
func (o *GPT164_Type) SetGTSSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x7f000000)|value<<24)
}
func (o *GPT164_Type) GetGTSSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x7f000000) >> 24
}
func (o *GPT164_Type) SetGTSSR_SSELCH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTSSR_SSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800000) >> 23
}
func (o *GPT164_Type) SetGTSSR_SSELCG(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTSSR_SSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTSSR_SSELCF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTSSR_SSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTSSR_SSELCE(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTSSR_SSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTSSR_SSELCD(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTSSR_SSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTSSR_SSELCC(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTSSR_SSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTSSR_SSELCB(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTSSR_SSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTSSR_SSELCA(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTSSR_SSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTSSR_SSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTSSR_SSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTSSR_SSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTSSR_SSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTSSR_SSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTSSR_SSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTSSR_SSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTSSR_SSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTSSR_SSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTSSR_SSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTSSR_SSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTSSR_SSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTSSR_SSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTSSR_SSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTSSR_SSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTSSR_SSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTSSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0xf0)|value<<4)
}
func (o *GPT164_Type) GetGTSSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0xf0) >> 4
}
func (o *GPT164_Type) SetGTSSR_SSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTSSR_SSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTSSR_SSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTSSR_SSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTSSR.Reg) & 0x1
}

// GPT164.GTPSR: General PWM Timer Stop Source Select Register
func (o *GPT164_Type) SetGTPSR_CSTOP(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT164_Type) GetGTPSR_CSTOP() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000000) >> 31
}
func (o *GPT164_Type) SetGTPSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x7f000000)|value<<24)
}
func (o *GPT164_Type) GetGTPSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x7f000000) >> 24
}
func (o *GPT164_Type) SetGTPSR_PSELCH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTPSR_PSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800000) >> 23
}
func (o *GPT164_Type) SetGTPSR_PSELCG(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTPSR_PSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTPSR_PSELCF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTPSR_PSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTPSR_PSELCE(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTPSR_PSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTPSR_PSELCD(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTPSR_PSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTPSR_PSELCC(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTPSR_PSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTPSR_PSELCB(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTPSR_PSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTPSR_PSELCA(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTPSR_PSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTPSR_PSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTPSR_PSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTPSR_PSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTPSR_PSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTPSR_PSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTPSR_PSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTPSR_PSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTPSR_PSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTPSR_PSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTPSR_PSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTPSR_PSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTPSR_PSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTPSR_PSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTPSR_PSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTPSR_PSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTPSR_PSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTPSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0xf0)|value<<4)
}
func (o *GPT164_Type) GetGTPSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0xf0) >> 4
}
func (o *GPT164_Type) SetGTPSR_PSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTPSR_PSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTPSR_PSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTPSR_PSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTPSR.Reg) & 0x1
}

// GPT164.GTCSR: General PWM Timer Clear Source Select Register
func (o *GPT164_Type) SetGTCSR_CCLR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT164_Type) GetGTCSR_CCLR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000000) >> 31
}
func (o *GPT164_Type) SetGTCSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x7f000000)|value<<24)
}
func (o *GPT164_Type) GetGTCSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x7f000000) >> 24
}
func (o *GPT164_Type) SetGTCSR_CSELCH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTCSR_CSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800000) >> 23
}
func (o *GPT164_Type) SetGTCSR_CSELCG(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTCSR_CSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTCSR_CSELCF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTCSR_CSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTCSR_CSELCE(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTCSR_CSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTCSR_CSELCD(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTCSR_CSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTCSR_CSELCC(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTCSR_CSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTCSR_CSELCB(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTCSR_CSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTCSR_CSELCA(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTCSR_CSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTCSR_CSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTCSR_CSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTCSR_CSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTCSR_CSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTCSR_CSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTCSR_CSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTCSR_CSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTCSR_CSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTCSR_CSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTCSR_CSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTCSR_CSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTCSR_CSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTCSR_CSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTCSR_CSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTCSR_CSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTCSR_CSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTCSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0xf0)|value<<4)
}
func (o *GPT164_Type) GetGTCSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0xf0) >> 4
}
func (o *GPT164_Type) SetGTCSR_CSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTCSR_CSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTCSR_CSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTCSR_CSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTCSR.Reg) & 0x1
}

// GPT164.GTUPSR: General PWM Timer Up Count Source Select Register
func (o *GPT164_Type) SetGTUPSR_USELCH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTUPSR_USELCH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800000) >> 23
}
func (o *GPT164_Type) SetGTUPSR_USELCG(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTUPSR_USELCG() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTUPSR_USELCF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTUPSR_USELCF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTUPSR_USELCE(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTUPSR_USELCE() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTUPSR_USELCD(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTUPSR_USELCD() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTUPSR_USELCC(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTUPSR_USELCC() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTUPSR_USELCB(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTUPSR_USELCB() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTUPSR_USELCA(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTUPSR_USELCA() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTUPSR_USCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTUPSR_USCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTUPSR_USCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTUPSR_USCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTUPSR_USCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTUPSR_USCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTUPSR_USCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTUPSR_USCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTUPSR_USCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTUPSR_USCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTUPSR_USCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTUPSR_USCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTUPSR_USCARBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTUPSR_USCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTUPSR_USCARBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTUPSR_USCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTUPSR_USGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTUPSR_USGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTUPSR_USGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTUPSR_USGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1
}

// GPT164.GTDNSR: General PWM Timer Down Count Source Select Register
func (o *GPT164_Type) SetGTDNSR_DSELCH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTDNSR_DSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800000) >> 23
}
func (o *GPT164_Type) SetGTDNSR_DSELCG(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTDNSR_DSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTDNSR_DSELCF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTDNSR_DSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTDNSR_DSELCE(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTDNSR_DSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTDNSR_DSELCD(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTDNSR_DSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTDNSR_DSELCC(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTDNSR_DSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTDNSR_DSELCB(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTDNSR_DSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTDNSR_DSELCA(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTDNSR_DSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTDNSR_DSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTDNSR_DSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTDNSR_DSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTDNSR_DSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTDNSR_DSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTDNSR_DSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTDNSR_DSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTDNSR_DSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTDNSR_DSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTDNSR_DSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTDNSR_DSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTDNSR_DSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTDNSR_DSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTDNSR_DSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTDNSR_DSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTDNSR_DSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1
}

// GPT164.GTICASR: General PWM Timer Input Capture Source Select Register A
func (o *GPT164_Type) SetGTICASR_ASELCH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTICASR_ASELCH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800000) >> 23
}
func (o *GPT164_Type) SetGTICASR_ASELCG(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTICASR_ASELCG() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTICASR_ASELCF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTICASR_ASELCF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTICASR_ASELCE(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTICASR_ASELCE() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTICASR_ASELCD(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTICASR_ASELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTICASR_ASELCC(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTICASR_ASELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTICASR_ASELCB(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTICASR_ASELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTICASR_ASELCA(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTICASR_ASELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTICASR_ASCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTICASR_ASCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTICASR_ASCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTICASR_ASCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTICASR_ASCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTICASR_ASCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTICASR_ASCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTICASR_ASCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTICASR_ASCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTICASR_ASCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTICASR_ASCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTICASR_ASCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTICASR_ASCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTICASR_ASCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTICASR_ASCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTICASR_ASCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTICASR_ASGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTICASR_ASGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTICASR_ASGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTICASR_ASGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICASR.Reg) & 0x1
}

// GPT164.GTICBSR: General PWM Timer Input Capture Source Select Register B
func (o *GPT164_Type) SetGTICBSR_BSELCH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTICBSR_BSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800000) >> 23
}
func (o *GPT164_Type) SetGTICBSR_BSELCG(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTICBSR_BSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTICBSR_BSELCF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTICBSR_BSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTICBSR_BSELCE(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTICBSR_BSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTICBSR_BSELCD(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTICBSR_BSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTICBSR_BSELCC(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTICBSR_BSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTICBSR_BSELCB(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTICBSR_BSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTICBSR_BSELCA(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTICBSR_BSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTICBSR_BSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTICBSR_BSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTICBSR_BSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTICBSR_BSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTICBSR_BSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTICBSR_BSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTICBSR_BSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTICBSR_BSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTICBSR_BSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTICBSR_BSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTICBSR_BSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTICBSR_BSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTICBSR_BSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTICBSR_BSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTICBSR_BSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTICBSR_BSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1
}

// GPT164.GTCR: General PWM Timer Control Register
func (o *GPT164_Type) SetGTCR_TPCS(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x7000000)|value<<24)
}
func (o *GPT164_Type) GetGTCR_TPCS() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x7000000) >> 24
}
func (o *GPT164_Type) SetGTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0xf80000)|value<<19)
}
func (o *GPT164_Type) GetGTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0xf80000) >> 19
}
func (o *GPT164_Type) SetGTCR_MD(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x70000)|value<<16)
}
func (o *GPT164_Type) GetGTCR_MD() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x70000) >> 16
}
func (o *GPT164_Type) SetGTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0xfffe)|value<<1)
}
func (o *GPT164_Type) GetGTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0xfffe) >> 1
}
func (o *GPT164_Type) SetGTCR_CST(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTCR_CST() uint32 {
	return volatile.LoadUint32(&o.GTCR.Reg) & 0x1
}

// GPT164.GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
func (o *GPT164_Type) SetGTUDDTYC_OBDTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x8000000)|value<<27)
}
func (o *GPT164_Type) GetGTUDDTYC_OBDTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x8000000) >> 27
}
func (o *GPT164_Type) SetGTUDDTYC_OBDTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT164_Type) GetGTUDDTYC_OBDTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x4000000) >> 26
}
func (o *GPT164_Type) SetGTUDDTYC_OBDTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT164_Type) GetGTUDDTYC_OBDTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x3000000) >> 24
}
func (o *GPT164_Type) SetGTUDDTYC_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0xf00000)|value<<20)
}
func (o *GPT164_Type) GetGTUDDTYC_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0xf00000) >> 20
}
func (o *GPT164_Type) SetGTUDDTYC_OADTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTUDDTYC_OADTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTUDDTYC_OADTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTUDDTYC_OADTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTUDDTYC_OADTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x30000)|value<<16)
}
func (o *GPT164_Type) GetGTUDDTYC_OADTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x30000) >> 16
}
func (o *GPT164_Type) SetGTUDDTYC_UDF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTUDDTYC_UDF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTUDDTYC_UD(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTUDDTYC_UD() uint32 {
	return volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x1
}

// GPT164.GTIOR: General PWM Timer I/O Control Register
func (o *GPT164_Type) SetGTIOR_NFCSB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT164_Type) GetGTIOR_NFCSB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc0000000) >> 30
}
func (o *GPT164_Type) SetGTIOR_NFBEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT164_Type) GetGTIOR_NFBEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20000000) >> 29
}
func (o *GPT164_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x18000000)|value<<27)
}
func (o *GPT164_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x18000000) >> 27
}
func (o *GPT164_Type) SetGTIOR_OBDF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x6000000)|value<<25)
}
func (o *GPT164_Type) GetGTIOR_OBDF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x6000000) >> 25
}
func (o *GPT164_Type) SetGTIOR_OBE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT164_Type) GetGTIOR_OBE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1000000) >> 24
}
func (o *GPT164_Type) SetGTIOR_OBHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTIOR_OBHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x800000) >> 23
}
func (o *GPT164_Type) SetGTIOR_OBDFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTIOR_OBDFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTIOR_GTIOB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f0000)|value<<16)
}
func (o *GPT164_Type) GetGTIOR_GTIOB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f0000) >> 16
}
func (o *GPT164_Type) SetGTIOR_NFCSA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc000)|value<<14)
}
func (o *GPT164_Type) GetGTIOR_NFCSA() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc000) >> 14
}
func (o *GPT164_Type) SetGTIOR_NFAEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTIOR_NFAEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1800)|value<<11)
}
func (o *GPT164_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1800) >> 11
}
func (o *GPT164_Type) SetGTIOR_OADF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x600)|value<<9)
}
func (o *GPT164_Type) GetGTIOR_OADF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x600) >> 9
}
func (o *GPT164_Type) SetGTIOR_OAE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTIOR_OAE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTIOR_OAHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTIOR_OAHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTIOR_OADFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTIOR_OADFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTIOR_GTIOA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f)|value)
}
func (o *GPT164_Type) GetGTIOR_GTIOA() uint32 {
	return volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f
}

// GPT164.GTINTAD: General PWM Timer Interrupt Output Setting Register
func (o *GPT164_Type) SetGTINTAD_GRPABL(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT164_Type) GetGTINTAD_GRPABL() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x40000000) >> 30
}
func (o *GPT164_Type) SetGTINTAD_GRPABH(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT164_Type) GetGTINTAD_GRPABH() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x20000000) >> 29
}
func (o *GPT164_Type) SetGTINTAD_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x1c000000)|value<<26)
}
func (o *GPT164_Type) GetGTINTAD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x1c000000) >> 26
}
func (o *GPT164_Type) SetGTINTAD_GRP(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT164_Type) GetGTINTAD_GRP() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x3000000) >> 24
}
func (o *GPT164_Type) SetGTINTAD_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0xffffff)|value)
}
func (o *GPT164_Type) GetGTINTAD_Reserved() uint32 {
	return volatile.LoadUint32(&o.GTINTAD.Reg) & 0xffffff
}

// GPT164.GTST: General PWM Timer Status Register
func (o *GPT164_Type) SetGTST_OABLF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT164_Type) GetGTST_OABLF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40000000) >> 30
}
func (o *GPT164_Type) SetGTST_OABHF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT164_Type) GetGTST_OABHF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20000000) >> 29
}
func (o *GPT164_Type) SetGTST_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1e000000)|value<<25)
}
func (o *GPT164_Type) GetGTST_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1e000000) >> 25
}
func (o *GPT164_Type) SetGTST_ODF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT164_Type) GetGTST_ODF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1000000) >> 24
}
func (o *GPT164_Type) SetGTST_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0xff0000)|value<<16)
}
func (o *GPT164_Type) GetGTST_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0xff0000) >> 16
}
func (o *GPT164_Type) SetGTST_TUCF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTST_TUCF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTST_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x7f00)|value<<8)
}
func (o *GPT164_Type) GetGTST_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x7f00) >> 8
}
func (o *GPT164_Type) SetGTST_TCFPU(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTST_TCFPU() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTST_TCPFO(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTST_TCPFO() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTST_TCFF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTST_TCFF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTST_TCFE(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTST_TCFE() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTST_TCFD(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTST_TCFD() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTST_TCFC(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTST_TCFC() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTST_TCFB(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTST_TCFB() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTST_TCFA(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTST_TCFA() uint32 {
	return volatile.LoadUint32(&o.GTST.Reg) & 0x1
}

// GPT164.GTBER: General PWM Timer Buffer Enable Register
func (o *GPT164_Type) SetGTBER_CCRSWT(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTBER_CCRSWT() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTBER_PR(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x300000)|value<<20)
}
func (o *GPT164_Type) GetGTBER_PR() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x300000) >> 20
}
func (o *GPT164_Type) SetGTBER_CCRB(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPT164_Type) GetGTBER_CCRB() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0xc0000) >> 18
}
func (o *GPT164_Type) SetGTBER_CCRA(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x30000)|value<<16)
}
func (o *GPT164_Type) GetGTBER_CCRA() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x30000) >> 16
}
func (o *GPT164_Type) SetGTBER_BD(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x3)|value)
}
func (o *GPT164_Type) GetGTBER_BD() uint32 {
	return volatile.LoadUint32(&o.GTBER.Reg) & 0x3
}

// GPT164.GTCNT: General PWM Timer Counter
func (o *GPT164_Type) SetGTCNT(value uint32) {
	volatile.StoreUint32(&o.GTCNT.Reg, value)
}
func (o *GPT164_Type) GetGTCNT() uint32 {
	return volatile.LoadUint32(&o.GTCNT.Reg)
}

// GPT164.GTCCRA: General PWM Timer Compare Capture Register A
func (o *GPT164_Type) SetGTCCRA(value uint32) {
	volatile.StoreUint32(&o.GTCCRA.Reg, value)
}
func (o *GPT164_Type) GetGTCCRA() uint32 {
	return volatile.LoadUint32(&o.GTCCRA.Reg)
}

// GPT164.GTCCRB: General PWM Timer Compare Capture Register B
func (o *GPT164_Type) SetGTCCRB(value uint32) {
	volatile.StoreUint32(&o.GTCCRB.Reg, value)
}
func (o *GPT164_Type) GetGTCCRB() uint32 {
	return volatile.LoadUint32(&o.GTCCRB.Reg)
}

// GPT164.GTCCRC: General PWM Timer Compare Capture Register C
func (o *GPT164_Type) SetGTCCRC(value uint32) {
	volatile.StoreUint32(&o.GTCCRC.Reg, value)
}
func (o *GPT164_Type) GetGTCCRC() uint32 {
	return volatile.LoadUint32(&o.GTCCRC.Reg)
}

// GPT164.GTCCRE: General PWM Timer Compare Capture Register E
func (o *GPT164_Type) SetGTCCRE(value uint32) {
	volatile.StoreUint32(&o.GTCCRE.Reg, value)
}
func (o *GPT164_Type) GetGTCCRE() uint32 {
	return volatile.LoadUint32(&o.GTCCRE.Reg)
}

// GPT164.GTCCRD: General PWM Timer Compare Capture Register D
func (o *GPT164_Type) SetGTCCRD(value uint32) {
	volatile.StoreUint32(&o.GTCCRD.Reg, value)
}
func (o *GPT164_Type) GetGTCCRD() uint32 {
	return volatile.LoadUint32(&o.GTCCRD.Reg)
}

// GPT164.GTCCRF: General PWM Timer Compare Capture Register F
func (o *GPT164_Type) SetGTCCRF(value uint32) {
	volatile.StoreUint32(&o.GTCCRF.Reg, value)
}
func (o *GPT164_Type) GetGTCCRF() uint32 {
	return volatile.LoadUint32(&o.GTCCRF.Reg)
}

// GPT164.GTPR: General PWM Timer Cycle Setting Register
func (o *GPT164_Type) SetGTPR(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, value)
}
func (o *GPT164_Type) GetGTPR() uint32 {
	return volatile.LoadUint32(&o.GTPR.Reg)
}

// GPT164.GTPBR: General PWM Timer Cycle Setting Buffer Register
func (o *GPT164_Type) SetGTPBR(value uint32) {
	volatile.StoreUint32(&o.GTPBR.Reg, value)
}
func (o *GPT164_Type) GetGTPBR() uint32 {
	return volatile.LoadUint32(&o.GTPBR.Reg)
}

// GPT164.GTDTCR: General PWM Timer Dead Time Control Register
func (o *GPT164_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0xfffffe00)|value<<9)
}
func (o *GPT164_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0xfffffe00) >> 9
}
func (o *GPT164_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0xc0)|value<<6)
}
func (o *GPT164_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0xc0) >> 6
}
func (o *GPT164_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0xe)|value<<1)
}
func (o *GPT164_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0xe) >> 1
}
func (o *GPT164_Type) SetGTDTCR_TDE(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTDTCR_TDE() uint32 {
	return volatile.LoadUint32(&o.GTDTCR.Reg) & 0x1
}

// GPT164.GTDVU: General PWM Timer Dead Time Value Register U
func (o *GPT164_Type) SetGTDVU(value uint32) {
	volatile.StoreUint32(&o.GTDVU.Reg, value)
}
func (o *GPT164_Type) GetGTDVU() uint32 {
	return volatile.LoadUint32(&o.GTDVU.Reg)
}

// Output Phase Switching Controller
type GPT_OPS_Type struct {
	OPSCR volatile.Register32 // 0x0
}

// GPT_OPS.OPSCR: Output Phase Switching Control Register
func (o *GPT_OPS_Type) SetOPSCR_NFCS(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT_OPS_Type) GetOPSCR_NFCS() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0xc0000000) >> 30
}
func (o *GPT_OPS_Type) SetOPSCR_NFEN(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT_OPS_Type) GetOPSCR_NFEN() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x20000000) >> 29
}
func (o *GPT_OPS_Type) SetOPSCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x18000000)|value<<27)
}
func (o *GPT_OPS_Type) GetOPSCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x18000000) >> 27
}
func (o *GPT_OPS_Type) SetOPSCR_GODF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT_OPS_Type) GetOPSCR_GODF() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x4000000) >> 26
}
func (o *GPT_OPS_Type) SetOPSCR_GRP(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT_OPS_Type) GetOPSCR_GRP() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x3000000) >> 24
}
func (o *GPT_OPS_Type) SetOPSCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0xc00000)|value<<22)
}
func (o *GPT_OPS_Type) GetOPSCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0xc00000) >> 22
}
func (o *GPT_OPS_Type) SetOPSCR_ALIGN(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT_OPS_Type) GetOPSCR_ALIGN() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x200000) >> 21
}
func (o *GPT_OPS_Type) SetOPSCR_RV(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT_OPS_Type) GetOPSCR_RV() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x100000) >> 20
}
func (o *GPT_OPS_Type) SetOPSCR_INV(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT_OPS_Type) GetOPSCR_INV() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x80000) >> 19
}
func (o *GPT_OPS_Type) SetOPSCR_N(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT_OPS_Type) GetOPSCR_N() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x40000) >> 18
}
func (o *GPT_OPS_Type) SetOPSCR_P(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT_OPS_Type) GetOPSCR_P() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x20000) >> 17
}
func (o *GPT_OPS_Type) SetOPSCR_FB(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT_OPS_Type) GetOPSCR_FB() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x10000) >> 16
}
func (o *GPT_OPS_Type) SetOPSCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0xfe00)|value<<9)
}
func (o *GPT_OPS_Type) GetOPSCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0xfe00) >> 9
}
func (o *GPT_OPS_Type) SetOPSCR_EN(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x100)|value<<8)
}
func (o *GPT_OPS_Type) GetOPSCR_EN() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x100) >> 8
}
func (o *GPT_OPS_Type) SetOPSCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x80)|value<<7)
}
func (o *GPT_OPS_Type) GetOPSCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x80) >> 7
}
func (o *GPT_OPS_Type) SetOPSCR_W(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x40)|value<<6)
}
func (o *GPT_OPS_Type) GetOPSCR_W() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x40) >> 6
}
func (o *GPT_OPS_Type) SetOPSCR_V(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x20)|value<<5)
}
func (o *GPT_OPS_Type) GetOPSCR_V() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x20) >> 5
}
func (o *GPT_OPS_Type) SetOPSCR_U(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x10)|value<<4)
}
func (o *GPT_OPS_Type) GetOPSCR_U() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x10) >> 4
}
func (o *GPT_OPS_Type) SetOPSCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x8)|value<<3)
}
func (o *GPT_OPS_Type) GetOPSCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x8) >> 3
}
func (o *GPT_OPS_Type) SetOPSCR_WF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x4)|value<<2)
}
func (o *GPT_OPS_Type) GetOPSCR_WF() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x4) >> 2
}
func (o *GPT_OPS_Type) SetOPSCR_VF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x2)|value<<1)
}
func (o *GPT_OPS_Type) GetOPSCR_VF() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x2) >> 1
}
func (o *GPT_OPS_Type) SetOPSCR_UF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x1)|value)
}
func (o *GPT_OPS_Type) GetOPSCR_UF() uint32 {
	return volatile.LoadUint32(&o.OPSCR.Reg) & 0x1
}

// Asynchronous General purpose Timer 0
type AGT0_Type struct {
	AGT      volatile.Register16 // 0x0
	AGTCMA   volatile.Register16 // 0x2
	AGTCMB   volatile.Register16 // 0x4
	_        [2]byte
	AGTCR    volatile.Register8 // 0x8
	AGTMR1   volatile.Register8 // 0x9
	AGTMR2   volatile.Register8 // 0xA
	_        byte
	AGTIOC   volatile.Register8 // 0xC
	AGTISR   volatile.Register8 // 0xD
	AGTCMSR  volatile.Register8 // 0xE
	AGTIOSEL volatile.Register8 // 0xF
}

// AGT0.AGT: AGT Counter Register
func (o *AGT0_Type) SetAGT(value uint16) {
	volatile.StoreUint16(&o.AGT.Reg, value)
}
func (o *AGT0_Type) GetAGT() uint16 {
	return volatile.LoadUint16(&o.AGT.Reg)
}

// AGT0.AGTCMA: AGT Compare Match A Register
func (o *AGT0_Type) SetAGTCMA(value uint16) {
	volatile.StoreUint16(&o.AGTCMA.Reg, value)
}
func (o *AGT0_Type) GetAGTCMA() uint16 {
	return volatile.LoadUint16(&o.AGTCMA.Reg)
}

// AGT0.AGTCMB: AGT Compare Match B Register
func (o *AGT0_Type) SetAGTCMB(value uint16) {
	volatile.StoreUint16(&o.AGTCMB.Reg, value)
}
func (o *AGT0_Type) GetAGTCMB() uint16 {
	return volatile.LoadUint16(&o.AGTCMB.Reg)
}

// AGT0.AGTCR: AGT Control Register
func (o *AGT0_Type) SetAGTCR_TCMBF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTCR_TCMBF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x80) >> 7
}
func (o *AGT0_Type) SetAGTCR_TCMAF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x40)|value<<6)
}
func (o *AGT0_Type) GetAGTCR_TCMAF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x40) >> 6
}
func (o *AGT0_Type) SetAGTCR_TUNDF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x20)|value<<5)
}
func (o *AGT0_Type) GetAGTCR_TUNDF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x20) >> 5
}
func (o *AGT0_Type) SetAGTCR_TEDGF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTCR_TEDGF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x10) >> 4
}
func (o *AGT0_Type) SetAGTCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x8)|value<<3)
}
func (o *AGT0_Type) GetAGTCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x8) >> 3
}
func (o *AGT0_Type) SetAGTCR_TSTOP(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTCR_TSTOP() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTCR_TCSTF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x2)|value<<1)
}
func (o *AGT0_Type) GetAGTCR_TCSTF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x2) >> 1
}
func (o *AGT0_Type) SetAGTCR_TSTART(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTCR_TSTART() uint8 {
	return volatile.LoadUint8(&o.AGTCR.Reg) & 0x1
}

// AGT0.AGTMR1: AGT Mode Register 1
func (o *AGT0_Type) SetAGTMR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTMR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTMR1.Reg) & 0x80) >> 7
}
func (o *AGT0_Type) SetAGTMR1_TCK(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x70)|value<<4)
}
func (o *AGT0_Type) GetAGTMR1_TCK() uint8 {
	return (volatile.LoadUint8(&o.AGTMR1.Reg) & 0x70) >> 4
}
func (o *AGT0_Type) SetAGTMR1_TEDGPL(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x8)|value<<3)
}
func (o *AGT0_Type) GetAGTMR1_TEDGPL() uint8 {
	return (volatile.LoadUint8(&o.AGTMR1.Reg) & 0x8) >> 3
}
func (o *AGT0_Type) SetAGTMR1_TMOD(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x7)|value)
}
func (o *AGT0_Type) GetAGTMR1_TMOD() uint8 {
	return volatile.LoadUint8(&o.AGTMR1.Reg) & 0x7
}

// AGT0.AGTMR2: AGT Mode Register 2
func (o *AGT0_Type) SetAGTMR2_LPM(value uint8) {
	volatile.StoreUint8(&o.AGTMR2.Reg, volatile.LoadUint8(&o.AGTMR2.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTMR2_LPM() uint8 {
	return (volatile.LoadUint8(&o.AGTMR2.Reg) & 0x80) >> 7
}
func (o *AGT0_Type) SetAGTMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTMR2.Reg, volatile.LoadUint8(&o.AGTMR2.Reg)&^(0x78)|value<<3)
}
func (o *AGT0_Type) GetAGTMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTMR2.Reg) & 0x78) >> 3
}
func (o *AGT0_Type) SetAGTMR2_CKS(value uint8) {
	volatile.StoreUint8(&o.AGTMR2.Reg, volatile.LoadUint8(&o.AGTMR2.Reg)&^(0x7)|value)
}
func (o *AGT0_Type) GetAGTMR2_CKS() uint8 {
	return volatile.LoadUint8(&o.AGTMR2.Reg) & 0x7
}

// AGT0.AGTIOC: AGT I/O Control Register
func (o *AGT0_Type) SetAGTIOC_TIOGT(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0xc0)|value<<6)
}
func (o *AGT0_Type) GetAGTIOC_TIOGT() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0xc0) >> 6
}
func (o *AGT0_Type) SetAGTIOC_TIPF(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x30)|value<<4)
}
func (o *AGT0_Type) GetAGTIOC_TIPF() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x30) >> 4
}
func (o *AGT0_Type) SetAGTIOC_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x8)|value<<3)
}
func (o *AGT0_Type) GetAGTIOC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x8) >> 3
}
func (o *AGT0_Type) SetAGTIOC_TOE(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTIOC_TOE() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTIOC_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x2)|value<<1)
}
func (o *AGT0_Type) GetAGTIOC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x2) >> 1
}
func (o *AGT0_Type) SetAGTIOC_TEDGSEL(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTIOC_TEDGSEL() uint8 {
	return volatile.LoadUint8(&o.AGTIOC.Reg) & 0x1
}

// AGT0.AGTISR: AGT Event Pin Select Register
func (o *AGT0_Type) SetAGTISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTISR.Reg, volatile.LoadUint8(&o.AGTISR.Reg)&^(0xf8)|value<<3)
}
func (o *AGT0_Type) GetAGTISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTISR.Reg) & 0xf8) >> 3
}
func (o *AGT0_Type) SetAGTISR_EEPS(value uint8) {
	volatile.StoreUint8(&o.AGTISR.Reg, volatile.LoadUint8(&o.AGTISR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTISR_EEPS() uint8 {
	return (volatile.LoadUint8(&o.AGTISR.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTISR.Reg, volatile.LoadUint8(&o.AGTISR.Reg)&^(0x3)|value)
}
func (o *AGT0_Type) GetAGTISR_Reserved() uint8 {
	return volatile.LoadUint8(&o.AGTISR.Reg) & 0x3
}

// AGT0.AGTCMSR: AGT Compare Match Function Select Register
func (o *AGT0_Type) SetAGTCMSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTCMSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x80) >> 7
}
func (o *AGT0_Type) SetAGTCMSR_TOPOLB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x40)|value<<6)
}
func (o *AGT0_Type) GetAGTCMSR_TOPOLB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x40) >> 6
}
func (o *AGT0_Type) SetAGTCMSR_TOEB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x20)|value<<5)
}
func (o *AGT0_Type) GetAGTCMSR_TOEB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x20) >> 5
}
func (o *AGT0_Type) SetAGTCMSR_TCMEB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTCMSR_TCMEB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x10) >> 4
}
func (o *AGT0_Type) SetAGTCMSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x8)|value<<3)
}
func (o *AGT0_Type) GetAGTCMSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x8) >> 3
}
func (o *AGT0_Type) SetAGTCMSR_TOPOLA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTCMSR_TOPOLA() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTCMSR_TOEA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x2)|value<<1)
}
func (o *AGT0_Type) GetAGTCMSR_TOEA() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x2) >> 1
}
func (o *AGT0_Type) SetAGTCMSR_TCMEA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTCMSR_TCMEA() uint8 {
	return volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x1
}

// AGT0.AGTIOSEL: AGT Pin Select Register
func (o *AGT0_Type) SetAGTIOSEL_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTIOSEL.Reg, volatile.LoadUint8(&o.AGTIOSEL.Reg)&^(0xe0)|value<<5)
}
func (o *AGT0_Type) GetAGTIOSEL_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTIOSEL.Reg) & 0xe0) >> 5
}
func (o *AGT0_Type) SetAGTIOSEL_TIES(value uint8) {
	volatile.StoreUint8(&o.AGTIOSEL.Reg, volatile.LoadUint8(&o.AGTIOSEL.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTIOSEL_TIES() uint8 {
	return (volatile.LoadUint8(&o.AGTIOSEL.Reg) & 0x10) >> 4
}
func (o *AGT0_Type) SetAGTIOSEL_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTIOSEL.Reg, volatile.LoadUint8(&o.AGTIOSEL.Reg)&^(0xc)|value<<2)
}
func (o *AGT0_Type) GetAGTIOSEL_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTIOSEL.Reg) & 0xc) >> 2
}
func (o *AGT0_Type) SetAGTIOSEL_SEL(value uint8) {
	volatile.StoreUint8(&o.AGTIOSEL.Reg, volatile.LoadUint8(&o.AGTIOSEL.Reg)&^(0x3)|value)
}
func (o *AGT0_Type) GetAGTIOSEL_SEL() uint8 {
	return volatile.LoadUint8(&o.AGTIOSEL.Reg) & 0x3
}

// Realtime Clock
type RTC_Type struct {
	R64CNT  volatile.Register8 // 0x0
	_       byte
	RSECCNT volatile.Register8 // 0x2
	_       byte
	RMINCNT volatile.Register8 // 0x4
	_       byte
	RHRCNT  volatile.Register8 // 0x6
	_       byte
	RWKCNT  volatile.Register8 // 0x8
	_       byte
	RDAYCNT volatile.Register8 // 0xA
	_       byte
	RMONCNT volatile.Register8 // 0xC
	_       byte
	RYRCNT  volatile.Register16 // 0xE
	RSECAR  volatile.Register8  // 0x10
	_       byte
	RMINAR  volatile.Register8 // 0x12
	_       byte
	RHRAR   volatile.Register8 // 0x14
	_       byte
	RWKAR   volatile.Register8 // 0x16
	_       byte
	RDAYAR  volatile.Register8 // 0x18
	_       byte
	RMONAR  volatile.Register8 // 0x1A
	_       byte
	RYRAR   volatile.Register16 // 0x1C
	RYRAREN volatile.Register8  // 0x1E
	_       [3]byte
	RCR1    volatile.Register8 // 0x22
	_       byte
	RCR2    volatile.Register8 // 0x24
	_       [3]byte
	RCR4    volatile.Register8 // 0x28
	_       byte
	RFRH    volatile.Register16 // 0x2A
	RFRL    volatile.Register16 // 0x2C
	RADJ    volatile.Register8  // 0x2E
	_       [17]byte
	RTCCR0  volatile.Register8 // 0x40
	_       byte
	RTCCR1  volatile.Register8 // 0x42
	_       byte
	RTCCR2  volatile.Register8 // 0x44
	_       [13]byte
	RSECCP0 volatile.Register8 // 0x52
	_       byte
	RMINCP0 volatile.Register8 // 0x54
	_       byte
	RHRCP0  volatile.Register8 // 0x56
	_       [3]byte
	RDAYCP0 volatile.Register8 // 0x5A
	_       byte
	RMONCP0 volatile.Register8 // 0x5C
	_       [5]byte
	RSECCP1 volatile.Register8 // 0x62
	_       byte
	RMINCP1 volatile.Register8 // 0x64
	_       byte
	RHRCP1  volatile.Register8 // 0x66
	_       [3]byte
	RDAYCP1 volatile.Register8 // 0x6A
	_       byte
	RMONCP1 volatile.Register8 // 0x6C
	_       [5]byte
	RSECCP2 volatile.Register8 // 0x72
	_       byte
	RMINCP2 volatile.Register8 // 0x74
	_       byte
	RHRCP2  volatile.Register8 // 0x76
	_       [3]byte
	RDAYCP2 volatile.Register8 // 0x7A
	_       byte
	RMONCP2 volatile.Register8 // 0x7C
}

// RTC.R64CNT: 64-Hz Counter
func (o *RTC_Type) SetR64CNT_F1HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetR64CNT_F1HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetR64CNT_F2HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetR64CNT_F2HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetR64CNT_F4HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetR64CNT_F4HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetR64CNT_F8HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetR64CNT_F8HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetR64CNT_F16HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetR64CNT_F16HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetR64CNT_F32HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetR64CNT_F32HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetR64CNT_F64HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetR64CNT_F64HZ() uint8 {
	return volatile.LoadUint8(&o.R64CNT.Reg) & 0x1
}

// RTC.RSECCNT: Second Counter
func (o *RTC_Type) SetRSECCNT_SEC10(value uint8) {
	volatile.StoreUint8(&o.RSECCNT.Reg, volatile.LoadUint8(&o.RSECCNT.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRSECCNT_SEC10() uint8 {
	return (volatile.LoadUint8(&o.RSECCNT.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRSECCNT_SEC1(value uint8) {
	volatile.StoreUint8(&o.RSECCNT.Reg, volatile.LoadUint8(&o.RSECCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRSECCNT_SEC1() uint8 {
	return volatile.LoadUint8(&o.RSECCNT.Reg) & 0xf
}

// RTC.RMINCNT: Minute Counter
func (o *RTC_Type) SetRMINCNT_MIN10(value uint8) {
	volatile.StoreUint8(&o.RMINCNT.Reg, volatile.LoadUint8(&o.RMINCNT.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRMINCNT_MIN10() uint8 {
	return (volatile.LoadUint8(&o.RMINCNT.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRMINCNT_MIN1(value uint8) {
	volatile.StoreUint8(&o.RMINCNT.Reg, volatile.LoadUint8(&o.RMINCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMINCNT_MIN1() uint8 {
	return volatile.LoadUint8(&o.RMINCNT.Reg) & 0xf
}

// RTC.RHRCNT: Hour Counter
func (o *RTC_Type) SetRHRCNT_PM(value uint8) {
	volatile.StoreUint8(&o.RHRCNT.Reg, volatile.LoadUint8(&o.RHRCNT.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRHRCNT_PM() uint8 {
	return (volatile.LoadUint8(&o.RHRCNT.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRHRCNT_HR10(value uint8) {
	volatile.StoreUint8(&o.RHRCNT.Reg, volatile.LoadUint8(&o.RHRCNT.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRHRCNT_HR10() uint8 {
	return (volatile.LoadUint8(&o.RHRCNT.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRHRCNT_HR1(value uint8) {
	volatile.StoreUint8(&o.RHRCNT.Reg, volatile.LoadUint8(&o.RHRCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRHRCNT_HR1() uint8 {
	return volatile.LoadUint8(&o.RHRCNT.Reg) & 0xf
}

// RTC.RWKCNT: Day-of-Week Counter
func (o *RTC_Type) SetRWKCNT_DAYW(value uint8) {
	volatile.StoreUint8(&o.RWKCNT.Reg, volatile.LoadUint8(&o.RWKCNT.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetRWKCNT_DAYW() uint8 {
	return volatile.LoadUint8(&o.RWKCNT.Reg) & 0x7
}

// RTC.RDAYCNT: Day Counter
func (o *RTC_Type) SetRDAYCNT_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYCNT.Reg, volatile.LoadUint8(&o.RDAYCNT.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYCNT_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYCNT.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRDAYCNT_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYCNT.Reg, volatile.LoadUint8(&o.RDAYCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYCNT_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYCNT.Reg) & 0xf
}

// RTC.RMONCNT: Month Counter
func (o *RTC_Type) SetRMONCNT_Reserved(value uint8) {
	volatile.StoreUint8(&o.RMONCNT.Reg, volatile.LoadUint8(&o.RMONCNT.Reg)&^(0xe0)|value<<5)
}
func (o *RTC_Type) GetRMONCNT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RMONCNT.Reg) & 0xe0) >> 5
}
func (o *RTC_Type) SetRMONCNT_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCNT.Reg, volatile.LoadUint8(&o.RMONCNT.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCNT_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCNT.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRMONCNT_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCNT.Reg, volatile.LoadUint8(&o.RMONCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCNT_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCNT.Reg) & 0xf
}

// RTC.RYRCNT: Year Counter
func (o *RTC_Type) SetRYRCNT_Reserved(value uint16) {
	volatile.StoreUint16(&o.RYRCNT.Reg, volatile.LoadUint16(&o.RYRCNT.Reg)&^(0xff00)|value<<8)
}
func (o *RTC_Type) GetRYRCNT_Reserved() uint16 {
	return (volatile.LoadUint16(&o.RYRCNT.Reg) & 0xff00) >> 8
}
func (o *RTC_Type) SetRYRCNT_YR10(value uint16) {
	volatile.StoreUint16(&o.RYRCNT.Reg, volatile.LoadUint16(&o.RYRCNT.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetRYRCNT_YR10() uint16 {
	return (volatile.LoadUint16(&o.RYRCNT.Reg) & 0xf0) >> 4
}
func (o *RTC_Type) SetRYRCNT_YR1(value uint16) {
	volatile.StoreUint16(&o.RYRCNT.Reg, volatile.LoadUint16(&o.RYRCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRYRCNT_YR1() uint16 {
	return volatile.LoadUint16(&o.RYRCNT.Reg) & 0xf
}

// RTC.RSECAR: Second Alarm Register
func (o *RTC_Type) SetRSECAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RSECAR.Reg, volatile.LoadUint8(&o.RSECAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRSECAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RSECAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRSECAR_SEC10(value uint8) {
	volatile.StoreUint8(&o.RSECAR.Reg, volatile.LoadUint8(&o.RSECAR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRSECAR_SEC10() uint8 {
	return (volatile.LoadUint8(&o.RSECAR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRSECAR_SEC1(value uint8) {
	volatile.StoreUint8(&o.RSECAR.Reg, volatile.LoadUint8(&o.RSECAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRSECAR_SEC1() uint8 {
	return volatile.LoadUint8(&o.RSECAR.Reg) & 0xf
}

// RTC.RMINAR: Minute Alarm Register
func (o *RTC_Type) SetRMINAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RMINAR.Reg, volatile.LoadUint8(&o.RMINAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRMINAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RMINAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRMINAR_MIN10(value uint8) {
	volatile.StoreUint8(&o.RMINAR.Reg, volatile.LoadUint8(&o.RMINAR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRMINAR_MIN10() uint8 {
	return (volatile.LoadUint8(&o.RMINAR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRMINAR_MIN1(value uint8) {
	volatile.StoreUint8(&o.RMINAR.Reg, volatile.LoadUint8(&o.RMINAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMINAR_MIN1() uint8 {
	return volatile.LoadUint8(&o.RMINAR.Reg) & 0xf
}

// RTC.RHRAR: Hour Alarm Register
func (o *RTC_Type) SetRHRAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RHRAR.Reg, volatile.LoadUint8(&o.RHRAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRHRAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RHRAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRHRAR_PM(value uint8) {
	volatile.StoreUint8(&o.RHRAR.Reg, volatile.LoadUint8(&o.RHRAR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRHRAR_PM() uint8 {
	return (volatile.LoadUint8(&o.RHRAR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRHRAR_HR10(value uint8) {
	volatile.StoreUint8(&o.RHRAR.Reg, volatile.LoadUint8(&o.RHRAR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRHRAR_HR10() uint8 {
	return (volatile.LoadUint8(&o.RHRAR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRHRAR_HR1(value uint8) {
	volatile.StoreUint8(&o.RHRAR.Reg, volatile.LoadUint8(&o.RHRAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRHRAR_HR1() uint8 {
	return volatile.LoadUint8(&o.RHRAR.Reg) & 0xf
}

// RTC.RWKAR: Day-of-Week Alarm Register
func (o *RTC_Type) SetRWKAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RWKAR.Reg, volatile.LoadUint8(&o.RWKAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRWKAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RWKAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRWKAR_Reserved(value uint8) {
	volatile.StoreUint8(&o.RWKAR.Reg, volatile.LoadUint8(&o.RWKAR.Reg)&^(0x78)|value<<3)
}
func (o *RTC_Type) GetRWKAR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RWKAR.Reg) & 0x78) >> 3
}
func (o *RTC_Type) SetRWKAR_DAYW(value uint8) {
	volatile.StoreUint8(&o.RWKAR.Reg, volatile.LoadUint8(&o.RWKAR.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetRWKAR_DAYW() uint8 {
	return volatile.LoadUint8(&o.RWKAR.Reg) & 0x7
}

// RTC.RDAYAR: Date Alarm Register
func (o *RTC_Type) SetRDAYAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RDAYAR.Reg, volatile.LoadUint8(&o.RDAYAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRDAYAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RDAYAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRDAYAR_Reserved(value uint8) {
	volatile.StoreUint8(&o.RDAYAR.Reg, volatile.LoadUint8(&o.RDAYAR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRDAYAR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RDAYAR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRDAYAR_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYAR.Reg, volatile.LoadUint8(&o.RDAYAR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYAR_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYAR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRDAYAR_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYAR.Reg, volatile.LoadUint8(&o.RDAYAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYAR_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYAR.Reg) & 0xf
}

// RTC.RMONAR: Month Alarm Register
func (o *RTC_Type) SetRMONAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RMONAR.Reg, volatile.LoadUint8(&o.RMONAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRMONAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RMONAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRMONAR_Reserved(value uint8) {
	volatile.StoreUint8(&o.RMONAR.Reg, volatile.LoadUint8(&o.RMONAR.Reg)&^(0x60)|value<<5)
}
func (o *RTC_Type) GetRMONAR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RMONAR.Reg) & 0x60) >> 5
}
func (o *RTC_Type) SetRMONAR_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONAR.Reg, volatile.LoadUint8(&o.RMONAR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONAR_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONAR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRMONAR_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONAR.Reg, volatile.LoadUint8(&o.RMONAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONAR_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONAR.Reg) & 0xf
}

// RTC.RYRAR: Year Alarm Register
func (o *RTC_Type) SetRYRAR_Reserved(value uint16) {
	volatile.StoreUint16(&o.RYRAR.Reg, volatile.LoadUint16(&o.RYRAR.Reg)&^(0xff00)|value<<8)
}
func (o *RTC_Type) GetRYRAR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.RYRAR.Reg) & 0xff00) >> 8
}
func (o *RTC_Type) SetRYRAR_YR10(value uint16) {
	volatile.StoreUint16(&o.RYRAR.Reg, volatile.LoadUint16(&o.RYRAR.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetRYRAR_YR10() uint16 {
	return (volatile.LoadUint16(&o.RYRAR.Reg) & 0xf0) >> 4
}
func (o *RTC_Type) SetRYRAR_YR1(value uint16) {
	volatile.StoreUint16(&o.RYRAR.Reg, volatile.LoadUint16(&o.RYRAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRYRAR_YR1() uint16 {
	return volatile.LoadUint16(&o.RYRAR.Reg) & 0xf
}

// RTC.RYRAREN: Year Alarm Enable Register
func (o *RTC_Type) SetRYRAREN_ENB(value uint8) {
	volatile.StoreUint8(&o.RYRAREN.Reg, volatile.LoadUint8(&o.RYRAREN.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRYRAREN_ENB() uint8 {
	return (volatile.LoadUint8(&o.RYRAREN.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRYRAREN_Reserved(value uint8) {
	volatile.StoreUint8(&o.RYRAREN.Reg, volatile.LoadUint8(&o.RYRAREN.Reg)&^(0x7f)|value)
}
func (o *RTC_Type) GetRYRAREN_Reserved() uint8 {
	return volatile.LoadUint8(&o.RYRAREN.Reg) & 0x7f
}

// RTC.RCR1: RTC Control Register 1
func (o *RTC_Type) SetRCR1_PES(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetRCR1_PES() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0xf0) >> 4
}
func (o *RTC_Type) SetRCR1_RTCOS(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRCR1_RTCOS() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRCR1_PIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRCR1_PIE() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRCR1_CIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetRCR1_CIE() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetRCR1_AIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR1_AIE() uint8 {
	return volatile.LoadUint8(&o.RCR1.Reg) & 0x1
}

// RTC.RCR2: RTC Control Register 2
func (o *RTC_Type) SetRCR2_CNTMD(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRCR2_CNTMD() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRCR2_HR24(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRCR2_HR24() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRCR2_AADJP(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetRCR2_AADJP() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetRCR2_AADJE(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRCR2_AADJE() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRCR2_RTCOE(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRCR2_RTCOE() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRCR2_ADJ30(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRCR2_ADJ30() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRCR2_RESET(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetRCR2_RESET() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetRCR2_START(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR2_START() uint8 {
	return volatile.LoadUint8(&o.RCR2.Reg) & 0x1
}

// RTC.RCR4: RTC Control Register 4
func (o *RTC_Type) SetRCR4_Reserved(value uint8) {
	volatile.StoreUint8(&o.RCR4.Reg, volatile.LoadUint8(&o.RCR4.Reg)&^(0xfe)|value<<1)
}
func (o *RTC_Type) GetRCR4_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RCR4.Reg) & 0xfe) >> 1
}
func (o *RTC_Type) SetRCR4_RCKSEL(value uint8) {
	volatile.StoreUint8(&o.RCR4.Reg, volatile.LoadUint8(&o.RCR4.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR4_RCKSEL() uint8 {
	return volatile.LoadUint8(&o.RCR4.Reg) & 0x1
}

// RTC.RFRH: Frequency Register H
func (o *RTC_Type) SetRFRH_Reserved(value uint16) {
	volatile.StoreUint16(&o.RFRH.Reg, volatile.LoadUint16(&o.RFRH.Reg)&^(0xfffe)|value<<1)
}
func (o *RTC_Type) GetRFRH_Reserved() uint16 {
	return (volatile.LoadUint16(&o.RFRH.Reg) & 0xfffe) >> 1
}
func (o *RTC_Type) SetRFRH_RFC16(value uint16) {
	volatile.StoreUint16(&o.RFRH.Reg, volatile.LoadUint16(&o.RFRH.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRFRH_RFC16() uint16 {
	return volatile.LoadUint16(&o.RFRH.Reg) & 0x1
}

// RTC.RFRL: Frequency Register L
func (o *RTC_Type) SetRFRL(value uint16) {
	volatile.StoreUint16(&o.RFRL.Reg, value)
}
func (o *RTC_Type) GetRFRL() uint16 {
	return volatile.LoadUint16(&o.RFRL.Reg)
}

// RTC.RADJ: Time Error Adjustment Register
func (o *RTC_Type) SetRADJ_PMADJ(value uint8) {
	volatile.StoreUint8(&o.RADJ.Reg, volatile.LoadUint8(&o.RADJ.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_Type) GetRADJ_PMADJ() uint8 {
	return (volatile.LoadUint8(&o.RADJ.Reg) & 0xc0) >> 6
}
func (o *RTC_Type) SetRADJ_ADJ(value uint8) {
	volatile.StoreUint8(&o.RADJ.Reg, volatile.LoadUint8(&o.RADJ.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetRADJ_ADJ() uint8 {
	return volatile.LoadUint8(&o.RADJ.Reg) & 0x3f
}

// RTC.RTCCR0: Time Capture Control Register %s
func (o *RTC_Type) SetRTCCR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.RTCCR0.Reg, volatile.LoadUint8(&o.RTCCR0.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRTCCR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RTCCR0.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRTCCR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.RTCCR0.Reg, volatile.LoadUint8(&o.RTCCR0.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRTCCR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RTCCR0.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRTCCR0_TCNF(value uint8) {
	volatile.StoreUint8(&o.RTCCR0.Reg, volatile.LoadUint8(&o.RTCCR0.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRTCCR0_TCNF() uint8 {
	return (volatile.LoadUint8(&o.RTCCR0.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRTCCR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.RTCCR0.Reg, volatile.LoadUint8(&o.RTCCR0.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRTCCR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RTCCR0.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRTCCR0_TCST(value uint8) {
	volatile.StoreUint8(&o.RTCCR0.Reg, volatile.LoadUint8(&o.RTCCR0.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRTCCR0_TCST() uint8 {
	return (volatile.LoadUint8(&o.RTCCR0.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRTCCR0_TCCT(value uint8) {
	volatile.StoreUint8(&o.RTCCR0.Reg, volatile.LoadUint8(&o.RTCCR0.Reg)&^(0x3)|value)
}
func (o *RTC_Type) GetRTCCR0_TCCT() uint8 {
	return volatile.LoadUint8(&o.RTCCR0.Reg) & 0x3
}

// RTC.RTCCR1: Time Capture Control Register %s
func (o *RTC_Type) SetRTCCR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.RTCCR1.Reg, volatile.LoadUint8(&o.RTCCR1.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRTCCR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RTCCR1.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRTCCR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.RTCCR1.Reg, volatile.LoadUint8(&o.RTCCR1.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRTCCR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RTCCR1.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRTCCR1_TCNF(value uint8) {
	volatile.StoreUint8(&o.RTCCR1.Reg, volatile.LoadUint8(&o.RTCCR1.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRTCCR1_TCNF() uint8 {
	return (volatile.LoadUint8(&o.RTCCR1.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRTCCR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.RTCCR1.Reg, volatile.LoadUint8(&o.RTCCR1.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRTCCR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RTCCR1.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRTCCR1_TCST(value uint8) {
	volatile.StoreUint8(&o.RTCCR1.Reg, volatile.LoadUint8(&o.RTCCR1.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRTCCR1_TCST() uint8 {
	return (volatile.LoadUint8(&o.RTCCR1.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRTCCR1_TCCT(value uint8) {
	volatile.StoreUint8(&o.RTCCR1.Reg, volatile.LoadUint8(&o.RTCCR1.Reg)&^(0x3)|value)
}
func (o *RTC_Type) GetRTCCR1_TCCT() uint8 {
	return volatile.LoadUint8(&o.RTCCR1.Reg) & 0x3
}

// RTC.RTCCR2: Time Capture Control Register %s
func (o *RTC_Type) SetRTCCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.RTCCR2.Reg, volatile.LoadUint8(&o.RTCCR2.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRTCCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RTCCR2.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRTCCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.RTCCR2.Reg, volatile.LoadUint8(&o.RTCCR2.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRTCCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RTCCR2.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRTCCR2_TCNF(value uint8) {
	volatile.StoreUint8(&o.RTCCR2.Reg, volatile.LoadUint8(&o.RTCCR2.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRTCCR2_TCNF() uint8 {
	return (volatile.LoadUint8(&o.RTCCR2.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRTCCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.RTCCR2.Reg, volatile.LoadUint8(&o.RTCCR2.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRTCCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RTCCR2.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRTCCR2_TCST(value uint8) {
	volatile.StoreUint8(&o.RTCCR2.Reg, volatile.LoadUint8(&o.RTCCR2.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRTCCR2_TCST() uint8 {
	return (volatile.LoadUint8(&o.RTCCR2.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRTCCR2_TCCT(value uint8) {
	volatile.StoreUint8(&o.RTCCR2.Reg, volatile.LoadUint8(&o.RTCCR2.Reg)&^(0x3)|value)
}
func (o *RTC_Type) GetRTCCR2_TCCT() uint8 {
	return volatile.LoadUint8(&o.RTCCR2.Reg) & 0x3
}

// RTC.RSECCP0: Second Capture Register %s
func (o *RTC_Type) SetRSECCP0_Reserved(value uint8) {
	volatile.StoreUint8(&o.RSECCP0.Reg, volatile.LoadUint8(&o.RSECCP0.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRSECCP0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RSECCP0.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRSECCP0_SEC10(value uint8) {
	volatile.StoreUint8(&o.RSECCP0.Reg, volatile.LoadUint8(&o.RSECCP0.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRSECCP0_SEC10() uint8 {
	return (volatile.LoadUint8(&o.RSECCP0.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRSECCP0_SEC1(value uint8) {
	volatile.StoreUint8(&o.RSECCP0.Reg, volatile.LoadUint8(&o.RSECCP0.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRSECCP0_SEC1() uint8 {
	return volatile.LoadUint8(&o.RSECCP0.Reg) & 0xf
}

// RTC.RMINCP0: Minute Capture Register %s
func (o *RTC_Type) SetRMINCP0_Reserved(value uint8) {
	volatile.StoreUint8(&o.RMINCP0.Reg, volatile.LoadUint8(&o.RMINCP0.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRMINCP0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RMINCP0.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRMINCP0_MIN10(value uint8) {
	volatile.StoreUint8(&o.RMINCP0.Reg, volatile.LoadUint8(&o.RMINCP0.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRMINCP0_MIN10() uint8 {
	return (volatile.LoadUint8(&o.RMINCP0.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRMINCP0_MIN1(value uint8) {
	volatile.StoreUint8(&o.RMINCP0.Reg, volatile.LoadUint8(&o.RMINCP0.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMINCP0_MIN1() uint8 {
	return volatile.LoadUint8(&o.RMINCP0.Reg) & 0xf
}

// RTC.RHRCP0: Hour Capture Register %s
func (o *RTC_Type) SetRHRCP0_Reserved(value uint8) {
	volatile.StoreUint8(&o.RHRCP0.Reg, volatile.LoadUint8(&o.RHRCP0.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRHRCP0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RHRCP0.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRHRCP0_PM(value uint8) {
	volatile.StoreUint8(&o.RHRCP0.Reg, volatile.LoadUint8(&o.RHRCP0.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRHRCP0_PM() uint8 {
	return (volatile.LoadUint8(&o.RHRCP0.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRHRCP0_HR10(value uint8) {
	volatile.StoreUint8(&o.RHRCP0.Reg, volatile.LoadUint8(&o.RHRCP0.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRHRCP0_HR10() uint8 {
	return (volatile.LoadUint8(&o.RHRCP0.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRHRCP0_HR1(value uint8) {
	volatile.StoreUint8(&o.RHRCP0.Reg, volatile.LoadUint8(&o.RHRCP0.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRHRCP0_HR1() uint8 {
	return volatile.LoadUint8(&o.RHRCP0.Reg) & 0xf
}

// RTC.RDAYCP0: Date Capture Register %s
func (o *RTC_Type) SetRDAYCP0_Reserved(value uint8) {
	volatile.StoreUint8(&o.RDAYCP0.Reg, volatile.LoadUint8(&o.RDAYCP0.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_Type) GetRDAYCP0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RDAYCP0.Reg) & 0xc0) >> 6
}
func (o *RTC_Type) SetRDAYCP0_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYCP0.Reg, volatile.LoadUint8(&o.RDAYCP0.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYCP0_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYCP0.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRDAYCP0_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYCP0.Reg, volatile.LoadUint8(&o.RDAYCP0.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYCP0_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYCP0.Reg) & 0xf
}

// RTC.RMONCP0: Month Capture Register %s
func (o *RTC_Type) SetRMONCP0_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCP0.Reg, volatile.LoadUint8(&o.RMONCP0.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCP0_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCP0.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRMONCP0_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCP0.Reg, volatile.LoadUint8(&o.RMONCP0.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCP0_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCP0.Reg) & 0xf
}

// RTC.RSECCP1: Second Capture Register %s
func (o *RTC_Type) SetRSECCP1_Reserved(value uint8) {
	volatile.StoreUint8(&o.RSECCP1.Reg, volatile.LoadUint8(&o.RSECCP1.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRSECCP1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RSECCP1.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRSECCP1_SEC10(value uint8) {
	volatile.StoreUint8(&o.RSECCP1.Reg, volatile.LoadUint8(&o.RSECCP1.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRSECCP1_SEC10() uint8 {
	return (volatile.LoadUint8(&o.RSECCP1.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRSECCP1_SEC1(value uint8) {
	volatile.StoreUint8(&o.RSECCP1.Reg, volatile.LoadUint8(&o.RSECCP1.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRSECCP1_SEC1() uint8 {
	return volatile.LoadUint8(&o.RSECCP1.Reg) & 0xf
}

// RTC.RMINCP1: Minute Capture Register %s
func (o *RTC_Type) SetRMINCP1_Reserved(value uint8) {
	volatile.StoreUint8(&o.RMINCP1.Reg, volatile.LoadUint8(&o.RMINCP1.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRMINCP1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RMINCP1.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRMINCP1_MIN10(value uint8) {
	volatile.StoreUint8(&o.RMINCP1.Reg, volatile.LoadUint8(&o.RMINCP1.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRMINCP1_MIN10() uint8 {
	return (volatile.LoadUint8(&o.RMINCP1.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRMINCP1_MIN1(value uint8) {
	volatile.StoreUint8(&o.RMINCP1.Reg, volatile.LoadUint8(&o.RMINCP1.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMINCP1_MIN1() uint8 {
	return volatile.LoadUint8(&o.RMINCP1.Reg) & 0xf
}

// RTC.RHRCP1: Hour Capture Register %s
func (o *RTC_Type) SetRHRCP1_Reserved(value uint8) {
	volatile.StoreUint8(&o.RHRCP1.Reg, volatile.LoadUint8(&o.RHRCP1.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRHRCP1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RHRCP1.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRHRCP1_PM(value uint8) {
	volatile.StoreUint8(&o.RHRCP1.Reg, volatile.LoadUint8(&o.RHRCP1.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRHRCP1_PM() uint8 {
	return (volatile.LoadUint8(&o.RHRCP1.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRHRCP1_HR10(value uint8) {
	volatile.StoreUint8(&o.RHRCP1.Reg, volatile.LoadUint8(&o.RHRCP1.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRHRCP1_HR10() uint8 {
	return (volatile.LoadUint8(&o.RHRCP1.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRHRCP1_HR1(value uint8) {
	volatile.StoreUint8(&o.RHRCP1.Reg, volatile.LoadUint8(&o.RHRCP1.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRHRCP1_HR1() uint8 {
	return volatile.LoadUint8(&o.RHRCP1.Reg) & 0xf
}

// RTC.RDAYCP1: Date Capture Register %s
func (o *RTC_Type) SetRDAYCP1_Reserved(value uint8) {
	volatile.StoreUint8(&o.RDAYCP1.Reg, volatile.LoadUint8(&o.RDAYCP1.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_Type) GetRDAYCP1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RDAYCP1.Reg) & 0xc0) >> 6
}
func (o *RTC_Type) SetRDAYCP1_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYCP1.Reg, volatile.LoadUint8(&o.RDAYCP1.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYCP1_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYCP1.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRDAYCP1_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYCP1.Reg, volatile.LoadUint8(&o.RDAYCP1.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYCP1_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYCP1.Reg) & 0xf
}

// RTC.RMONCP1: Month Capture Register %s
func (o *RTC_Type) SetRMONCP1_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCP1.Reg, volatile.LoadUint8(&o.RMONCP1.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCP1_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCP1.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRMONCP1_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCP1.Reg, volatile.LoadUint8(&o.RMONCP1.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCP1_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCP1.Reg) & 0xf
}

// RTC.RSECCP2: Second Capture Register %s
func (o *RTC_Type) SetRSECCP2_Reserved(value uint8) {
	volatile.StoreUint8(&o.RSECCP2.Reg, volatile.LoadUint8(&o.RSECCP2.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRSECCP2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RSECCP2.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRSECCP2_SEC10(value uint8) {
	volatile.StoreUint8(&o.RSECCP2.Reg, volatile.LoadUint8(&o.RSECCP2.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRSECCP2_SEC10() uint8 {
	return (volatile.LoadUint8(&o.RSECCP2.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRSECCP2_SEC1(value uint8) {
	volatile.StoreUint8(&o.RSECCP2.Reg, volatile.LoadUint8(&o.RSECCP2.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRSECCP2_SEC1() uint8 {
	return volatile.LoadUint8(&o.RSECCP2.Reg) & 0xf
}

// RTC.RMINCP2: Minute Capture Register %s
func (o *RTC_Type) SetRMINCP2_Reserved(value uint8) {
	volatile.StoreUint8(&o.RMINCP2.Reg, volatile.LoadUint8(&o.RMINCP2.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRMINCP2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RMINCP2.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRMINCP2_MIN10(value uint8) {
	volatile.StoreUint8(&o.RMINCP2.Reg, volatile.LoadUint8(&o.RMINCP2.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRMINCP2_MIN10() uint8 {
	return (volatile.LoadUint8(&o.RMINCP2.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRMINCP2_MIN1(value uint8) {
	volatile.StoreUint8(&o.RMINCP2.Reg, volatile.LoadUint8(&o.RMINCP2.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMINCP2_MIN1() uint8 {
	return volatile.LoadUint8(&o.RMINCP2.Reg) & 0xf
}

// RTC.RHRCP2: Hour Capture Register %s
func (o *RTC_Type) SetRHRCP2_Reserved(value uint8) {
	volatile.StoreUint8(&o.RHRCP2.Reg, volatile.LoadUint8(&o.RHRCP2.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRHRCP2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RHRCP2.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRHRCP2_PM(value uint8) {
	volatile.StoreUint8(&o.RHRCP2.Reg, volatile.LoadUint8(&o.RHRCP2.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRHRCP2_PM() uint8 {
	return (volatile.LoadUint8(&o.RHRCP2.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRHRCP2_HR10(value uint8) {
	volatile.StoreUint8(&o.RHRCP2.Reg, volatile.LoadUint8(&o.RHRCP2.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRHRCP2_HR10() uint8 {
	return (volatile.LoadUint8(&o.RHRCP2.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRHRCP2_HR1(value uint8) {
	volatile.StoreUint8(&o.RHRCP2.Reg, volatile.LoadUint8(&o.RHRCP2.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRHRCP2_HR1() uint8 {
	return volatile.LoadUint8(&o.RHRCP2.Reg) & 0xf
}

// RTC.RDAYCP2: Date Capture Register %s
func (o *RTC_Type) SetRDAYCP2_Reserved(value uint8) {
	volatile.StoreUint8(&o.RDAYCP2.Reg, volatile.LoadUint8(&o.RDAYCP2.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_Type) GetRDAYCP2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RDAYCP2.Reg) & 0xc0) >> 6
}
func (o *RTC_Type) SetRDAYCP2_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYCP2.Reg, volatile.LoadUint8(&o.RDAYCP2.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYCP2_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYCP2.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRDAYCP2_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYCP2.Reg, volatile.LoadUint8(&o.RDAYCP2.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYCP2_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYCP2.Reg) & 0xf
}

// RTC.RMONCP2: Month Capture Register %s
func (o *RTC_Type) SetRMONCP2_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCP2.Reg, volatile.LoadUint8(&o.RMONCP2.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCP2_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCP2.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRMONCP2_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCP2.Reg, volatile.LoadUint8(&o.RMONCP2.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCP2_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCP2.Reg) & 0xf
}

// System Control
type SYSTEM_Type struct {
	_           [12]byte
	SBYCR       volatile.Register16 // 0xC
	_           [14]byte
	MSTPCRA     volatile.Register32 // 0x1C
	SCKDIVCR    volatile.Register32 // 0x20
	_           [2]byte
	SCKSCR      volatile.Register8 // 0x26
	_           [3]byte
	PLLCR       volatile.Register8 // 0x2A
	PLLCCR2     volatile.Register8 // 0x2B
	_           [4]byte
	BCKCR       volatile.Register8 // 0x30
	MEMWAIT     volatile.Register8 // 0x31
	MOSCCR      volatile.Register8 // 0x32
	_           [3]byte
	HOCOCR      volatile.Register8 // 0x36
	_           byte
	MOCOCR      volatile.Register8 // 0x38
	_           [3]byte
	OSCSF       volatile.Register8 // 0x3C
	_           byte
	CKOCR       volatile.Register8 // 0x3E
	TRCKCR      volatile.Register8 // 0x3F
	OSTDCR      volatile.Register8 // 0x40
	OSTDSR      volatile.Register8 // 0x41
	_           [14]byte
	SLCDSCKCR   volatile.Register8 // 0x50
	_           byte
	EBCKOCR     volatile.Register8 // 0x52
	_           [14]byte
	MOCOUTCR    volatile.Register8 // 0x61
	HOCOUTCR    volatile.Register8 // 0x62
	_           [47]byte
	SNZCR       volatile.Register8 // 0x92
	_           byte
	SNZEDCR     volatile.Register8 // 0x94
	_           [3]byte
	SNZREQCR    volatile.Register32 // 0x98
	_           [2]byte
	FLSTOP      volatile.Register8 // 0x9E
	PSMCR       volatile.Register8 // 0x9F
	OPCCR       volatile.Register8 // 0xA0
	_           byte
	MOSCWTCR    volatile.Register8 // 0xA2
	_           [2]byte
	HOCOWTCR    volatile.Register8 // 0xA5
	_           [4]byte
	SOPCCR      volatile.Register8 // 0xAA
	_           [21]byte
	RSTSR1      volatile.Register16 // 0xC0
	_           [4]byte
	BKRACR      volatile.Register8 // 0xC6
	_           [9]byte
	USBCKCR     volatile.Register8 // 0xD0
	_           [15]byte
	LVD1CR1     volatile.Register8 // 0xE0
	LVD1SR      volatile.Register8 // 0xE1
	LVD2CR1     volatile.Register8 // 0xE2
	LVD2SR      volatile.Register8 // 0xE3
	_           [794]byte
	PRCR        volatile.Register16 // 0x3FE
	_           [14]byte
	SYOCDCR     volatile.Register8 // 0x40E
	_           byte
	RSTSR0      volatile.Register8 // 0x410
	RSTSR2      volatile.Register8 // 0x411
	_           byte
	MOMCR       volatile.Register8 // 0x413
	_           [3]byte
	LVCMPCR     volatile.Register8 // 0x417
	LVDLVLR     volatile.Register8 // 0x418
	_           byte
	LVD1CR0     volatile.Register8 // 0x41A
	LVD2CR0     volatile.Register8 // 0x41B
	_           [3]byte
	VBTCR1      volatile.Register8 // 0x41F
	_           [96]byte
	SOSCCR      volatile.Register8 // 0x480
	SOMCR       volatile.Register8 // 0x481
	_           [14]byte
	LOCOCR      volatile.Register8 // 0x490
	_           byte
	LOCOUTCR    volatile.Register8 // 0x492
	_           [29]byte
	VBTCR2      volatile.Register8 // 0x4B0
	VBTSR       volatile.Register8 // 0x4B1
	VBTCMPCR    volatile.Register8 // 0x4B2
	_           byte
	VBTLVDICR   volatile.Register8 // 0x4B4
	_           byte
	VBTWCTLR    volatile.Register8 // 0x4B6
	_           byte
	VBTWCH0OTSR volatile.Register8 // 0x4B8
	VBTWCH1OTSR volatile.Register8 // 0x4B9
	VBTWCH2OTSR volatile.Register8 // 0x4BA
	VBTICTLR    volatile.Register8 // 0x4BB
	VBTOCTLR    volatile.Register8 // 0x4BC
	VBTWTER     volatile.Register8 // 0x4BD
	VBTWEGR     volatile.Register8 // 0x4BE
	VBTWFR      volatile.Register8 // 0x4BF
	_           [64]byte
	VBTBKR      [512]volatile.Register8 // 0x500
}

// SYSTEM.SBYCR: Standby Control Register
func (o *SYSTEM_Type) SetSBYCR_SSBY(value uint16) {
	volatile.StoreUint16(&o.SBYCR.Reg, volatile.LoadUint16(&o.SBYCR.Reg)&^(0x8000)|value<<15)
}
func (o *SYSTEM_Type) GetSBYCR_SSBY() uint16 {
	return (volatile.LoadUint16(&o.SBYCR.Reg) & 0x8000) >> 15
}
func (o *SYSTEM_Type) SetSBYCR_OPE(value uint16) {
	volatile.StoreUint16(&o.SBYCR.Reg, volatile.LoadUint16(&o.SBYCR.Reg)&^(0x4000)|value<<14)
}
func (o *SYSTEM_Type) GetSBYCR_OPE() uint16 {
	return (volatile.LoadUint16(&o.SBYCR.Reg) & 0x4000) >> 14
}
func (o *SYSTEM_Type) SetSBYCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.SBYCR.Reg, volatile.LoadUint16(&o.SBYCR.Reg)&^(0x3fff)|value)
}
func (o *SYSTEM_Type) GetSBYCR_Reserved() uint16 {
	return volatile.LoadUint16(&o.SBYCR.Reg) & 0x3fff
}

// SYSTEM.MSTPCRA: Module Stop Control Register A
func (o *SYSTEM_Type) SetMSTPCRA_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0xff800000)|value<<23)
}
func (o *SYSTEM_Type) GetMSTPCRA_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0xff800000) >> 23
}
func (o *SYSTEM_Type) SetMSTPCRA_MSTPA22(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x400000)|value<<22)
}
func (o *SYSTEM_Type) GetMSTPCRA_MSTPA22() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x400000) >> 22
}
func (o *SYSTEM_Type) SetMSTPCRA_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x3fff80)|value<<7)
}
func (o *SYSTEM_Type) GetMSTPCRA_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x3fff80) >> 7
}
func (o *SYSTEM_Type) SetMSTPCRA_MSTPA6(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetMSTPCRA_MSTPA6() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetMSTPCRA_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x3e)|value<<1)
}
func (o *SYSTEM_Type) GetMSTPCRA_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x3e) >> 1
}
func (o *SYSTEM_Type) SetMSTPCRA_MSTPA0(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetMSTPCRA_MSTPA0() uint32 {
	return volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x1
}

// SYSTEM.SCKDIVCR: System Clock Division Control Register
func (o *SYSTEM_Type) SetSCKDIVCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTEM_Type) GetSCKDIVCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x80000000) >> 31
}
func (o *SYSTEM_Type) SetSCKDIVCR_FCK(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x70000000)|value<<28)
}
func (o *SYSTEM_Type) GetSCKDIVCR_FCK() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x70000000) >> 28
}
func (o *SYSTEM_Type) SetSCKDIVCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSTEM_Type) GetSCKDIVCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x8000000) >> 27
}
func (o *SYSTEM_Type) SetSCKDIVCR_ICK(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x7000000)|value<<24)
}
func (o *SYSTEM_Type) GetSCKDIVCR_ICK() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x7000000) >> 24
}
func (o *SYSTEM_Type) SetSCKDIVCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0xf80000)|value<<19)
}
func (o *SYSTEM_Type) GetSCKDIVCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0xf80000) >> 19
}
func (o *SYSTEM_Type) SetSCKDIVCR_BCK(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x70000)|value<<16)
}
func (o *SYSTEM_Type) GetSCKDIVCR_BCK() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x70000) >> 16
}
func (o *SYSTEM_Type) SetSCKDIVCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x8000)|value<<15)
}
func (o *SYSTEM_Type) GetSCKDIVCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x8000) >> 15
}
func (o *SYSTEM_Type) SetSCKDIVCR_PCKA(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x7000)|value<<12)
}
func (o *SYSTEM_Type) GetSCKDIVCR_PCKA() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x7000) >> 12
}
func (o *SYSTEM_Type) SetSCKDIVCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x800)|value<<11)
}
func (o *SYSTEM_Type) GetSCKDIVCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x800) >> 11
}
func (o *SYSTEM_Type) SetSCKDIVCR_PCKB(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x700)|value<<8)
}
func (o *SYSTEM_Type) GetSCKDIVCR_PCKB() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x700) >> 8
}
func (o *SYSTEM_Type) SetSCKDIVCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSCKDIVCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSCKDIVCR_PCKC(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x70)|value<<4)
}
func (o *SYSTEM_Type) GetSCKDIVCR_PCKC() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x70) >> 4
}
func (o *SYSTEM_Type) SetSCKDIVCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetSCKDIVCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetSCKDIVCR_PCKD(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetSCKDIVCR_PCKD() uint32 {
	return volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x7
}

// SYSTEM.SCKSCR: System Clock Source Control Register
func (o *SYSTEM_Type) SetSCKSCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SCKSCR.Reg, volatile.LoadUint8(&o.SCKSCR.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetSCKSCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SCKSCR.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetSCKSCR_CKSEL(value uint8) {
	volatile.StoreUint8(&o.SCKSCR.Reg, volatile.LoadUint8(&o.SCKSCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetSCKSCR_CKSEL() uint8 {
	return volatile.LoadUint8(&o.SCKSCR.Reg) & 0x7
}

// SYSTEM.PLLCR: PLL Control Register
func (o *SYSTEM_Type) SetPLLCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.PLLCR.Reg, volatile.LoadUint8(&o.PLLCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetPLLCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.PLLCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetPLLCR_PLLSTP(value uint8) {
	volatile.StoreUint8(&o.PLLCR.Reg, volatile.LoadUint8(&o.PLLCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetPLLCR_PLLSTP() uint8 {
	return volatile.LoadUint8(&o.PLLCR.Reg) & 0x1
}

// SYSTEM.PLLCCR2: PLL Clock Control Register2
func (o *SYSTEM_Type) SetPLLCCR2_PLODIV(value uint8) {
	volatile.StoreUint8(&o.PLLCCR2.Reg, volatile.LoadUint8(&o.PLLCCR2.Reg)&^(0xc0)|value<<6)
}
func (o *SYSTEM_Type) GetPLLCCR2_PLODIV() uint8 {
	return (volatile.LoadUint8(&o.PLLCCR2.Reg) & 0xc0) >> 6
}
func (o *SYSTEM_Type) SetPLLCCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.PLLCCR2.Reg, volatile.LoadUint8(&o.PLLCCR2.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetPLLCCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.PLLCCR2.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetPLLCCR2_PLLMUL(value uint8) {
	volatile.StoreUint8(&o.PLLCCR2.Reg, volatile.LoadUint8(&o.PLLCCR2.Reg)&^(0x1f)|value)
}
func (o *SYSTEM_Type) GetPLLCCR2_PLLMUL() uint8 {
	return volatile.LoadUint8(&o.PLLCCR2.Reg) & 0x1f
}

// SYSTEM.BCKCR: External Bus Clock Control Register
func (o *SYSTEM_Type) SetBCKCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.BCKCR.Reg, volatile.LoadUint8(&o.BCKCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetBCKCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.BCKCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetBCKCR_BCLKDIV(value uint8) {
	volatile.StoreUint8(&o.BCKCR.Reg, volatile.LoadUint8(&o.BCKCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetBCKCR_BCLKDIV() uint8 {
	return volatile.LoadUint8(&o.BCKCR.Reg) & 0x1
}

// SYSTEM.MEMWAIT: Memory Wait Cycle Control Register
func (o *SYSTEM_Type) SetMEMWAIT_Reserved(value uint8) {
	volatile.StoreUint8(&o.MEMWAIT.Reg, volatile.LoadUint8(&o.MEMWAIT.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetMEMWAIT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MEMWAIT.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetMEMWAIT(value uint8) {
	volatile.StoreUint8(&o.MEMWAIT.Reg, volatile.LoadUint8(&o.MEMWAIT.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetMEMWAIT() uint8 {
	return volatile.LoadUint8(&o.MEMWAIT.Reg) & 0x1
}

// SYSTEM.MOSCCR: Main Clock Oscillator Control Register
func (o *SYSTEM_Type) SetMOSCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MOSCCR.Reg, volatile.LoadUint8(&o.MOSCCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetMOSCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MOSCCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetMOSCCR_MOSTP(value uint8) {
	volatile.StoreUint8(&o.MOSCCR.Reg, volatile.LoadUint8(&o.MOSCCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetMOSCCR_MOSTP() uint8 {
	return volatile.LoadUint8(&o.MOSCCR.Reg) & 0x1
}

// SYSTEM.HOCOCR: High-Speed On-Chip Oscillator Control Register
func (o *SYSTEM_Type) SetHOCOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.HOCOCR.Reg, volatile.LoadUint8(&o.HOCOCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetHOCOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.HOCOCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetHOCOCR_HCSTP(value uint8) {
	volatile.StoreUint8(&o.HOCOCR.Reg, volatile.LoadUint8(&o.HOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetHOCOCR_HCSTP() uint8 {
	return volatile.LoadUint8(&o.HOCOCR.Reg) & 0x1
}

// SYSTEM.MOCOCR: Middle-Speed On-Chip Oscillator Control Register
func (o *SYSTEM_Type) SetMOCOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MOCOCR.Reg, volatile.LoadUint8(&o.MOCOCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetMOCOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MOCOCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetMOCOCR_MCSTP(value uint8) {
	volatile.StoreUint8(&o.MOCOCR.Reg, volatile.LoadUint8(&o.MOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetMOCOCR_MCSTP() uint8 {
	return volatile.LoadUint8(&o.MOCOCR.Reg) & 0x1
}

// SYSTEM.OSCSF: Oscillation Stabilization Flag Register
func (o *SYSTEM_Type) SetOSCSF_Reserved(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0xc0)|value<<6)
}
func (o *SYSTEM_Type) GetOSCSF_Reserved() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0xc0) >> 6
}
func (o *SYSTEM_Type) SetOSCSF_PLLSF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetOSCSF_PLLSF() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetOSCSF_Reserved(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetOSCSF_Reserved() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetOSCSF_MOSCSF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetOSCSF_MOSCSF() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetOSCSF_Reserved(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x6)|value<<1)
}
func (o *SYSTEM_Type) GetOSCSF_Reserved() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0x6) >> 1
}
func (o *SYSTEM_Type) SetOSCSF_HOCOSF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetOSCSF_HOCOSF() uint8 {
	return volatile.LoadUint8(&o.OSCSF.Reg) & 0x1
}

// SYSTEM.CKOCR: Clock Out Control Register
func (o *SYSTEM_Type) SetCKOCR_CKOEN(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetCKOCR_CKOEN() uint8 {
	return (volatile.LoadUint8(&o.CKOCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetCKOCR_CKODIV(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x70)|value<<4)
}
func (o *SYSTEM_Type) GetCKOCR_CKODIV() uint8 {
	return (volatile.LoadUint8(&o.CKOCR.Reg) & 0x70) >> 4
}
func (o *SYSTEM_Type) SetCKOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetCKOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CKOCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetCKOCR_CKOSEL(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetCKOCR_CKOSEL() uint8 {
	return volatile.LoadUint8(&o.CKOCR.Reg) & 0x7
}

// SYSTEM.TRCKCR: Trace Clock Control Register
func (o *SYSTEM_Type) SetTRCKCR_TRCKEN(value uint8) {
	volatile.StoreUint8(&o.TRCKCR.Reg, volatile.LoadUint8(&o.TRCKCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetTRCKCR_TRCKEN() uint8 {
	return (volatile.LoadUint8(&o.TRCKCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetTRCKCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.TRCKCR.Reg, volatile.LoadUint8(&o.TRCKCR.Reg)&^(0x70)|value<<4)
}
func (o *SYSTEM_Type) GetTRCKCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.TRCKCR.Reg) & 0x70) >> 4
}
func (o *SYSTEM_Type) SetTRCKCR_TRCK(value uint8) {
	volatile.StoreUint8(&o.TRCKCR.Reg, volatile.LoadUint8(&o.TRCKCR.Reg)&^(0xf)|value)
}
func (o *SYSTEM_Type) GetTRCKCR_TRCK() uint8 {
	return volatile.LoadUint8(&o.TRCKCR.Reg) & 0xf
}

// SYSTEM.OSTDCR: Oscillation Stop Detection Control Register
func (o *SYSTEM_Type) SetOSTDCR_OSTDE(value uint8) {
	volatile.StoreUint8(&o.OSTDCR.Reg, volatile.LoadUint8(&o.OSTDCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetOSTDCR_OSTDE() uint8 {
	return (volatile.LoadUint8(&o.OSTDCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetOSTDCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.OSTDCR.Reg, volatile.LoadUint8(&o.OSTDCR.Reg)&^(0x7e)|value<<1)
}
func (o *SYSTEM_Type) GetOSTDCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.OSTDCR.Reg) & 0x7e) >> 1
}
func (o *SYSTEM_Type) SetOSTDCR_OSTDIE(value uint8) {
	volatile.StoreUint8(&o.OSTDCR.Reg, volatile.LoadUint8(&o.OSTDCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetOSTDCR_OSTDIE() uint8 {
	return volatile.LoadUint8(&o.OSTDCR.Reg) & 0x1
}

// SYSTEM.OSTDSR: Oscillation Stop Detection Status Register
func (o *SYSTEM_Type) SetOSTDSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.OSTDSR.Reg, volatile.LoadUint8(&o.OSTDSR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetOSTDSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.OSTDSR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetOSTDSR_OSTDF(value uint8) {
	volatile.StoreUint8(&o.OSTDSR.Reg, volatile.LoadUint8(&o.OSTDSR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetOSTDSR_OSTDF() uint8 {
	return volatile.LoadUint8(&o.OSTDSR.Reg) & 0x1
}

// SYSTEM.SLCDSCKCR: Segment LCD Source Clock Control Register
func (o *SYSTEM_Type) SetSLCDSCKCR_LCDSCKEN(value uint8) {
	volatile.StoreUint8(&o.SLCDSCKCR.Reg, volatile.LoadUint8(&o.SLCDSCKCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSLCDSCKCR_LCDSCKEN() uint8 {
	return (volatile.LoadUint8(&o.SLCDSCKCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSLCDSCKCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SLCDSCKCR.Reg, volatile.LoadUint8(&o.SLCDSCKCR.Reg)&^(0x78)|value<<3)
}
func (o *SYSTEM_Type) GetSLCDSCKCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SLCDSCKCR.Reg) & 0x78) >> 3
}
func (o *SYSTEM_Type) SetSLCDSCKCR_LCDSCKSEL(value uint8) {
	volatile.StoreUint8(&o.SLCDSCKCR.Reg, volatile.LoadUint8(&o.SLCDSCKCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetSLCDSCKCR_LCDSCKSEL() uint8 {
	return volatile.LoadUint8(&o.SLCDSCKCR.Reg) & 0x7
}

// SYSTEM.EBCKOCR: External Bus Clock Output Control Register
func (o *SYSTEM_Type) SetEBCKOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.EBCKOCR.Reg, volatile.LoadUint8(&o.EBCKOCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetEBCKOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.EBCKOCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetEBCKOCR_EBCKOEN(value uint8) {
	volatile.StoreUint8(&o.EBCKOCR.Reg, volatile.LoadUint8(&o.EBCKOCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetEBCKOCR_EBCKOEN() uint8 {
	return volatile.LoadUint8(&o.EBCKOCR.Reg) & 0x1
}

// SYSTEM.MOCOUTCR: MOCO User Trimming Control Register
func (o *SYSTEM_Type) SetMOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.MOCOUTCR.Reg, value)
}
func (o *SYSTEM_Type) GetMOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.MOCOUTCR.Reg)
}

// SYSTEM.HOCOUTCR: HOCO User Trimming Control Register
func (o *SYSTEM_Type) SetHOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.HOCOUTCR.Reg, value)
}
func (o *SYSTEM_Type) GetHOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.HOCOUTCR.Reg)
}

// SYSTEM.SNZCR: Snooze Control Register
func (o *SYSTEM_Type) SetSNZCR_SNZE(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSNZCR_SNZE() uint8 {
	return (volatile.LoadUint8(&o.SNZCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSNZCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x7c)|value<<2)
}
func (o *SYSTEM_Type) GetSNZCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SNZCR.Reg) & 0x7c) >> 2
}
func (o *SYSTEM_Type) SetSNZCR_SNZDTCEN(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetSNZCR_SNZDTCEN() uint8 {
	return (volatile.LoadUint8(&o.SNZCR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetSNZCR_RXDREQEN(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSNZCR_RXDREQEN() uint8 {
	return volatile.LoadUint8(&o.SNZCR.Reg) & 0x1
}

// SYSTEM.SNZEDCR: Snooze End Control Register
func (o *SYSTEM_Type) SetSNZEDCR_SCI0UMTED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSNZEDCR_SCI0UMTED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSNZEDCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x60)|value<<5)
}
func (o *SYSTEM_Type) GetSNZEDCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x60) >> 5
}
func (o *SYSTEM_Type) SetSNZEDCR_AD0UMTED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetSNZEDCR_AD0UMTED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetSNZEDCR_AD0MATED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetSNZEDCR_AD0MATED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetSNZEDCR_DTCNZRED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetSNZEDCR_DTCNZRED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetSNZEDCR_DTCZRED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetSNZEDCR_DTCZRED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetSNZEDCR_AGT1UNFED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSNZEDCR_AGT1UNFED() uint8 {
	return volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x1
}

// SYSTEM.SNZREQCR: Snooze Request Control Register
func (o *SYSTEM_Type) SetSNZREQCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTEM_Type) GetSNZREQCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x80000000) >> 31
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN30(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN30() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x40000000) >> 30
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN29(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN29() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x20000000) >> 29
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN28(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN28() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x10000000) >> 28
}
func (o *SYSTEM_Type) SetSNZREQCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0xc000000)|value<<26)
}
func (o *SYSTEM_Type) GetSNZREQCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0xc000000) >> 26
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN25(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN25() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x2000000) >> 25
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN24(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN24() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x1000000) >> 24
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN23(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x800000)|value<<23)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN23() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x800000) >> 23
}
func (o *SYSTEM_Type) SetSNZREQCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x7c0000)|value<<18)
}
func (o *SYSTEM_Type) GetSNZREQCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x7c0000) >> 18
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN17(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x20000)|value<<17)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN17() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x20000) >> 17
}
func (o *SYSTEM_Type) SetSNZREQCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x10000)|value<<16)
}
func (o *SYSTEM_Type) GetSNZREQCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x10000) >> 16
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN15(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x8000)|value<<15)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN15() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x8000) >> 15
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN14(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x4000)|value<<14)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN14() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x4000) >> 14
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN13(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x2000)|value<<13)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN13() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x2000) >> 13
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN12(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x1000)|value<<12)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN12() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x1000) >> 12
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN11(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x800)|value<<11)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN11() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x800) >> 11
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN10(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x400)|value<<10)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN10() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x400) >> 10
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN9(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x200)|value<<9)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN9() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x200) >> 9
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN8(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x100)|value<<8)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN8() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x100) >> 8
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN7(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN7() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN6(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN6() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN5(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN5() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN4(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN4() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN3(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN3() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN2(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN2() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN1(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN1() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN0(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN0() uint32 {
	return volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x1
}

// SYSTEM.FLSTOP: Flash Operation Control Register
func (o *SYSTEM_Type) SetFLSTOP_Reserved(value uint8) {
	volatile.StoreUint8(&o.FLSTOP.Reg, volatile.LoadUint8(&o.FLSTOP.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetFLSTOP_Reserved() uint8 {
	return (volatile.LoadUint8(&o.FLSTOP.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetFLSTOP_FLSTPF(value uint8) {
	volatile.StoreUint8(&o.FLSTOP.Reg, volatile.LoadUint8(&o.FLSTOP.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetFLSTOP_FLSTPF() uint8 {
	return (volatile.LoadUint8(&o.FLSTOP.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetFLSTOP_Reserved(value uint8) {
	volatile.StoreUint8(&o.FLSTOP.Reg, volatile.LoadUint8(&o.FLSTOP.Reg)&^(0xe)|value<<1)
}
func (o *SYSTEM_Type) GetFLSTOP_Reserved() uint8 {
	return (volatile.LoadUint8(&o.FLSTOP.Reg) & 0xe) >> 1
}
func (o *SYSTEM_Type) SetFLSTOP(value uint8) {
	volatile.StoreUint8(&o.FLSTOP.Reg, volatile.LoadUint8(&o.FLSTOP.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetFLSTOP() uint8 {
	return volatile.LoadUint8(&o.FLSTOP.Reg) & 0x1
}

// SYSTEM.PSMCR: Power Save Memory Control Register
func (o *SYSTEM_Type) SetPSMCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.PSMCR.Reg, volatile.LoadUint8(&o.PSMCR.Reg)&^(0xfc)|value<<2)
}
func (o *SYSTEM_Type) GetPSMCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.PSMCR.Reg) & 0xfc) >> 2
}
func (o *SYSTEM_Type) SetPSMCR_PSMC(value uint8) {
	volatile.StoreUint8(&o.PSMCR.Reg, volatile.LoadUint8(&o.PSMCR.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetPSMCR_PSMC() uint8 {
	return volatile.LoadUint8(&o.PSMCR.Reg) & 0x3
}

// SYSTEM.OPCCR: Operating Power Control Register
func (o *SYSTEM_Type) SetOPCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetOPCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.OPCCR.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetOPCCR_OPCMTSF(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetOPCCR_OPCMTSF() uint8 {
	return (volatile.LoadUint8(&o.OPCCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetOPCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0xc)|value<<2)
}
func (o *SYSTEM_Type) GetOPCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.OPCCR.Reg) & 0xc) >> 2
}
func (o *SYSTEM_Type) SetOPCCR_OPCM(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetOPCCR_OPCM() uint8 {
	return volatile.LoadUint8(&o.OPCCR.Reg) & 0x3
}

// SYSTEM.MOSCWTCR: Main Clock Oscillator Wait Control Register
func (o *SYSTEM_Type) SetMOSCWTCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MOSCWTCR.Reg, volatile.LoadUint8(&o.MOSCWTCR.Reg)&^(0xf0)|value<<4)
}
func (o *SYSTEM_Type) GetMOSCWTCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MOSCWTCR.Reg) & 0xf0) >> 4
}
func (o *SYSTEM_Type) SetMOSCWTCR_MSTS(value uint8) {
	volatile.StoreUint8(&o.MOSCWTCR.Reg, volatile.LoadUint8(&o.MOSCWTCR.Reg)&^(0xf)|value)
}
func (o *SYSTEM_Type) GetMOSCWTCR_MSTS() uint8 {
	return volatile.LoadUint8(&o.MOSCWTCR.Reg) & 0xf
}

// SYSTEM.HOCOWTCR: High-Speed On-Chip Oscillator Wait Control Register
func (o *SYSTEM_Type) SetHOCOWTCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.HOCOWTCR.Reg, volatile.LoadUint8(&o.HOCOWTCR.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetHOCOWTCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.HOCOWTCR.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetHOCOWTCR_HSTS(value uint8) {
	volatile.StoreUint8(&o.HOCOWTCR.Reg, volatile.LoadUint8(&o.HOCOWTCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetHOCOWTCR_HSTS() uint8 {
	return volatile.LoadUint8(&o.HOCOWTCR.Reg) & 0x7
}

// SYSTEM.SOPCCR: Sub Operating Power Control Register
func (o *SYSTEM_Type) SetSOPCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetSOPCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SOPCCR.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetSOPCCR_SOPCMTSF(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetSOPCCR_SOPCMTSF() uint8 {
	return (volatile.LoadUint8(&o.SOPCCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetSOPCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0xe)|value<<1)
}
func (o *SYSTEM_Type) GetSOPCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SOPCCR.Reg) & 0xe) >> 1
}
func (o *SYSTEM_Type) SetSOPCCR_SOPCM(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSOPCCR_SOPCM() uint8 {
	return volatile.LoadUint8(&o.SOPCCR.Reg) & 0x1
}

// SYSTEM.RSTSR1: Reset Status Register 1
func (o *SYSTEM_Type) SetRSTSR1_Reserved(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0xe000)|value<<13)
}
func (o *SYSTEM_Type) GetRSTSR1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0xe000) >> 13
}
func (o *SYSTEM_Type) SetRSTSR1_SPERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x1000)|value<<12)
}
func (o *SYSTEM_Type) GetRSTSR1_SPERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x1000) >> 12
}
func (o *SYSTEM_Type) SetRSTSR1_BUSMRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x800)|value<<11)
}
func (o *SYSTEM_Type) GetRSTSR1_BUSMRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x800) >> 11
}
func (o *SYSTEM_Type) SetRSTSR1_BUSSRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x400)|value<<10)
}
func (o *SYSTEM_Type) GetRSTSR1_BUSSRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x400) >> 10
}
func (o *SYSTEM_Type) SetRSTSR1_REERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x200)|value<<9)
}
func (o *SYSTEM_Type) GetRSTSR1_REERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x200) >> 9
}
func (o *SYSTEM_Type) SetRSTSR1_RPERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x100)|value<<8)
}
func (o *SYSTEM_Type) GetRSTSR1_RPERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x100) >> 8
}
func (o *SYSTEM_Type) SetRSTSR1_Reserved(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetRSTSR1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetRSTSR1_SWRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetRSTSR1_SWRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetRSTSR1_WDTRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetRSTSR1_WDTRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetRSTSR1_IWDTRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetRSTSR1_IWDTRF() uint16 {
	return volatile.LoadUint16(&o.RSTSR1.Reg) & 0x1
}

// SYSTEM.BKRACR: Backup Register Access Control Register
func (o *SYSTEM_Type) SetBKRACR_Reserved(value uint8) {
	volatile.StoreUint8(&o.BKRACR.Reg, volatile.LoadUint8(&o.BKRACR.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetBKRACR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.BKRACR.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetBKRACR_BKRACS(value uint8) {
	volatile.StoreUint8(&o.BKRACR.Reg, volatile.LoadUint8(&o.BKRACR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetBKRACR_BKRACS() uint8 {
	return volatile.LoadUint8(&o.BKRACR.Reg) & 0x7
}

// SYSTEM.USBCKCR: USB Clock Control register
func (o *SYSTEM_Type) SetUSBCKCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.USBCKCR.Reg, volatile.LoadUint8(&o.USBCKCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetUSBCKCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.USBCKCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetUSBCKCR_HSTS(value uint8) {
	volatile.StoreUint8(&o.USBCKCR.Reg, volatile.LoadUint8(&o.USBCKCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetUSBCKCR_HSTS() uint8 {
	return volatile.LoadUint8(&o.USBCKCR.Reg) & 0x1
}

// SYSTEM.LVD1CR1: Voltage Monitor %s Circuit Control Register 1
func (o *SYSTEM_Type) SetLVD1CR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD1CR1.Reg, volatile.LoadUint8(&o.LVD1CR1.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetLVD1CR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR1.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetLVD1CR1_IRQSEL(value uint8) {
	volatile.StoreUint8(&o.LVD1CR1.Reg, volatile.LoadUint8(&o.LVD1CR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetLVD1CR1_IRQSEL() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetLVD1CR1_IDTSEL(value uint8) {
	volatile.StoreUint8(&o.LVD1CR1.Reg, volatile.LoadUint8(&o.LVD1CR1.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetLVD1CR1_IDTSEL() uint8 {
	return volatile.LoadUint8(&o.LVD1CR1.Reg) & 0x3
}

// SYSTEM.LVD1SR: Voltage Monitor %s Circuit Status Register
func (o *SYSTEM_Type) SetLVD1SR_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD1SR.Reg, volatile.LoadUint8(&o.LVD1SR.Reg)&^(0xfc)|value<<2)
}
func (o *SYSTEM_Type) GetLVD1SR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD1SR.Reg) & 0xfc) >> 2
}
func (o *SYSTEM_Type) SetLVD1SR_MON(value uint8) {
	volatile.StoreUint8(&o.LVD1SR.Reg, volatile.LoadUint8(&o.LVD1SR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetLVD1SR_MON() uint8 {
	return (volatile.LoadUint8(&o.LVD1SR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetLVD1SR_DET(value uint8) {
	volatile.StoreUint8(&o.LVD1SR.Reg, volatile.LoadUint8(&o.LVD1SR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLVD1SR_DET() uint8 {
	return volatile.LoadUint8(&o.LVD1SR.Reg) & 0x1
}

// SYSTEM.LVD2CR1: Voltage Monitor %s Circuit Control Register 1
func (o *SYSTEM_Type) SetLVD2CR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD2CR1.Reg, volatile.LoadUint8(&o.LVD2CR1.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetLVD2CR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR1.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetLVD2CR1_IRQSEL(value uint8) {
	volatile.StoreUint8(&o.LVD2CR1.Reg, volatile.LoadUint8(&o.LVD2CR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetLVD2CR1_IRQSEL() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetLVD2CR1_IDTSEL(value uint8) {
	volatile.StoreUint8(&o.LVD2CR1.Reg, volatile.LoadUint8(&o.LVD2CR1.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetLVD2CR1_IDTSEL() uint8 {
	return volatile.LoadUint8(&o.LVD2CR1.Reg) & 0x3
}

// SYSTEM.LVD2SR: Voltage Monitor %s Circuit Status Register
func (o *SYSTEM_Type) SetLVD2SR_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD2SR.Reg, volatile.LoadUint8(&o.LVD2SR.Reg)&^(0xfc)|value<<2)
}
func (o *SYSTEM_Type) GetLVD2SR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD2SR.Reg) & 0xfc) >> 2
}
func (o *SYSTEM_Type) SetLVD2SR_MON(value uint8) {
	volatile.StoreUint8(&o.LVD2SR.Reg, volatile.LoadUint8(&o.LVD2SR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetLVD2SR_MON() uint8 {
	return (volatile.LoadUint8(&o.LVD2SR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetLVD2SR_DET(value uint8) {
	volatile.StoreUint8(&o.LVD2SR.Reg, volatile.LoadUint8(&o.LVD2SR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLVD2SR_DET() uint8 {
	return volatile.LoadUint8(&o.LVD2SR.Reg) & 0x1
}

// SYSTEM.PRCR: Protect Register
func (o *SYSTEM_Type) SetPRCR_PRKEY(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0xff00)|value<<8)
}
func (o *SYSTEM_Type) GetPRCR_PRKEY() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0xff00) >> 8
}
func (o *SYSTEM_Type) SetPRCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0xf0)|value<<4)
}
func (o *SYSTEM_Type) GetPRCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0xf0) >> 4
}
func (o *SYSTEM_Type) SetPRCR_PRC3(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetPRCR_PRC3() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetPRCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetPRCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetPRCR_PRC1(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetPRCR_PRC1() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetPRCR_PRC0(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetPRCR_PRC0() uint16 {
	return volatile.LoadUint16(&o.PRCR.Reg) & 0x1
}

// SYSTEM.SYOCDCR: System Control OCD Control Register
func (o *SYSTEM_Type) SetSYOCDCR_DBGEN(value uint8) {
	volatile.StoreUint8(&o.SYOCDCR.Reg, volatile.LoadUint8(&o.SYOCDCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSYOCDCR_DBGEN() uint8 {
	return (volatile.LoadUint8(&o.SYOCDCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSYOCDCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SYOCDCR.Reg, volatile.LoadUint8(&o.SYOCDCR.Reg)&^(0x7f)|value)
}
func (o *SYSTEM_Type) GetSYOCDCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.SYOCDCR.Reg) & 0x7f
}

// SYSTEM.RSTSR0: Reset Status Register 0
func (o *SYSTEM_Type) SetRSTSR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0xf0)|value<<4)
}
func (o *SYSTEM_Type) GetRSTSR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0xf0) >> 4
}
func (o *SYSTEM_Type) SetRSTSR0_LVD2RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetRSTSR0_LVD2RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetRSTSR0_LVD1RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetRSTSR0_LVD1RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetRSTSR0_LVD0RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetRSTSR0_LVD0RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetRSTSR0_PORF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetRSTSR0_PORF() uint8 {
	return volatile.LoadUint8(&o.RSTSR0.Reg) & 0x1
}

// SYSTEM.RSTSR2: Reset Status Register 2
func (o *SYSTEM_Type) SetRSTSR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.RSTSR2.Reg, volatile.LoadUint8(&o.RSTSR2.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetRSTSR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RSTSR2.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetRSTSR2_CWSF(value uint8) {
	volatile.StoreUint8(&o.RSTSR2.Reg, volatile.LoadUint8(&o.RSTSR2.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetRSTSR2_CWSF() uint8 {
	return volatile.LoadUint8(&o.RSTSR2.Reg) & 0x1
}

// SYSTEM.MOMCR: Main Clock Oscillator Mode Oscillation Control Register
func (o *SYSTEM_Type) SetMOMCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetMOMCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetMOMCR_MOSEL(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetMOMCR_MOSEL() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetMOMCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x30)|value<<4)
}
func (o *SYSTEM_Type) GetMOMCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x30) >> 4
}
func (o *SYSTEM_Type) SetMOMCR_MODRV1(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetMOMCR_MODRV1() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetMOMCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetMOMCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.MOMCR.Reg) & 0x7
}

// SYSTEM.LVCMPCR: Voltage Monitor Circuit Control Register
func (o *SYSTEM_Type) SetLVCMPCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetLVCMPCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVCMPCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetLVCMPCR_LVD2E(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetLVCMPCR_LVD2E() uint8 {
	return (volatile.LoadUint8(&o.LVCMPCR.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetLVCMPCR_LVD1E(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetLVCMPCR_LVD1E() uint8 {
	return (volatile.LoadUint8(&o.LVCMPCR.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetLVCMPCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetLVCMPCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVCMPCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetLVCMPCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0xc)|value<<2)
}
func (o *SYSTEM_Type) GetLVCMPCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVCMPCR.Reg) & 0xc) >> 2
}
func (o *SYSTEM_Type) SetLVCMPCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetLVCMPCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.LVCMPCR.Reg) & 0x3
}

// SYSTEM.LVDLVLR: Voltage Detection Level Select Register
func (o *SYSTEM_Type) SetLVDLVLR_LVD2LVL(value uint8) {
	volatile.StoreUint8(&o.LVDLVLR.Reg, volatile.LoadUint8(&o.LVDLVLR.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetLVDLVLR_LVD2LVL() uint8 {
	return (volatile.LoadUint8(&o.LVDLVLR.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetLVDLVLR_LVD1LVL(value uint8) {
	volatile.StoreUint8(&o.LVDLVLR.Reg, volatile.LoadUint8(&o.LVDLVLR.Reg)&^(0x1f)|value)
}
func (o *SYSTEM_Type) GetLVDLVLR_LVD1LVL() uint8 {
	return volatile.LoadUint8(&o.LVDLVLR.Reg) & 0x1f
}

// SYSTEM.LVD1CR0: Voltage Monitor %s Circuit Control Register 0
func (o *SYSTEM_Type) SetLVD1CR0_RN(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetLVD1CR0_RN() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetLVD1CR0_RI(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetLVD1CR0_RI() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetLVD1CR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x38)|value<<3)
}
func (o *SYSTEM_Type) GetLVD1CR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x38) >> 3
}
func (o *SYSTEM_Type) SetLVD1CR0_CMPE(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetLVD1CR0_CMPE() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetLVD1CR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetLVD1CR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetLVD1CR0_RIE(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLVD1CR0_RIE() uint8 {
	return volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x1
}

// SYSTEM.LVD2CR0: Voltage Monitor %s Circuit Control Register 0
func (o *SYSTEM_Type) SetLVD2CR0_RN(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetLVD2CR0_RN() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetLVD2CR0_RI(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetLVD2CR0_RI() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetLVD2CR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x38)|value<<3)
}
func (o *SYSTEM_Type) GetLVD2CR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x38) >> 3
}
func (o *SYSTEM_Type) SetLVD2CR0_CMPE(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetLVD2CR0_CMPE() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetLVD2CR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetLVD2CR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetLVD2CR0_RIE(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLVD2CR0_RIE() uint8 {
	return volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x1
}

// SYSTEM.VBTCR1: VBATT Control Register1
func (o *SYSTEM_Type) SetVBTCR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTCR1.Reg, volatile.LoadUint8(&o.VBTCR1.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetVBTCR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTCR1.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetVBTCR1_BPWSWSTP(value uint8) {
	volatile.StoreUint8(&o.VBTCR1.Reg, volatile.LoadUint8(&o.VBTCR1.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTCR1_BPWSWSTP() uint8 {
	return volatile.LoadUint8(&o.VBTCR1.Reg) & 0x1
}

// SYSTEM.SOSCCR: Sub-Clock Oscillator Control Register
func (o *SYSTEM_Type) SetSOSCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SOSCCR.Reg, volatile.LoadUint8(&o.SOSCCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetSOSCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SOSCCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetSOSCCR_SOSTP(value uint8) {
	volatile.StoreUint8(&o.SOSCCR.Reg, volatile.LoadUint8(&o.SOSCCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSOSCCR_SOSTP() uint8 {
	return volatile.LoadUint8(&o.SOSCCR.Reg) & 0x1
}

// SYSTEM.SOMCR: Sub Clock Oscillator Mode Control Register
func (o *SYSTEM_Type) SetSOMCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SOMCR.Reg, volatile.LoadUint8(&o.SOMCR.Reg)&^(0xfc)|value<<2)
}
func (o *SYSTEM_Type) GetSOMCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SOMCR.Reg) & 0xfc) >> 2
}
func (o *SYSTEM_Type) SetSOMCR_SODRV(value uint8) {
	volatile.StoreUint8(&o.SOMCR.Reg, volatile.LoadUint8(&o.SOMCR.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetSOMCR_SODRV() uint8 {
	return volatile.LoadUint8(&o.SOMCR.Reg) & 0x3
}

// SYSTEM.LOCOCR: Low-Speed On-Chip Oscillator Control Register
func (o *SYSTEM_Type) SetLOCOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.LOCOCR.Reg, volatile.LoadUint8(&o.LOCOCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetLOCOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LOCOCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetLOCOCR_LCSTP(value uint8) {
	volatile.StoreUint8(&o.LOCOCR.Reg, volatile.LoadUint8(&o.LOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLOCOCR_LCSTP() uint8 {
	return volatile.LoadUint8(&o.LOCOCR.Reg) & 0x1
}

// SYSTEM.LOCOUTCR: LOCO User Trimming Control Register
func (o *SYSTEM_Type) SetLOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.LOCOUTCR.Reg, value)
}
func (o *SYSTEM_Type) GetLOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.LOCOUTCR.Reg)
}

// SYSTEM.VBTCR2: VBATT Control Register2
func (o *SYSTEM_Type) SetVBTCR2_VBTLVDLVL(value uint8) {
	volatile.StoreUint8(&o.VBTCR2.Reg, volatile.LoadUint8(&o.VBTCR2.Reg)&^(0xc0)|value<<6)
}
func (o *SYSTEM_Type) GetVBTCR2_VBTLVDLVL() uint8 {
	return (volatile.LoadUint8(&o.VBTCR2.Reg) & 0xc0) >> 6
}
func (o *SYSTEM_Type) SetVBTCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTCR2.Reg, volatile.LoadUint8(&o.VBTCR2.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetVBTCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTCR2.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetVBTCR2_VBTLVDEN(value uint8) {
	volatile.StoreUint8(&o.VBTCR2.Reg, volatile.LoadUint8(&o.VBTCR2.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetVBTCR2_VBTLVDEN() uint8 {
	return (volatile.LoadUint8(&o.VBTCR2.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetVBTCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTCR2.Reg, volatile.LoadUint8(&o.VBTCR2.Reg)&^(0xf)|value)
}
func (o *SYSTEM_Type) GetVBTCR2_Reserved() uint8 {
	return volatile.LoadUint8(&o.VBTCR2.Reg) & 0xf
}

// SYSTEM.VBTSR: VBATT Status Register
func (o *SYSTEM_Type) SetVBTSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTSR.Reg, volatile.LoadUint8(&o.VBTSR.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetVBTSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTSR.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetVBTSR_VBTRVLD(value uint8) {
	volatile.StoreUint8(&o.VBTSR.Reg, volatile.LoadUint8(&o.VBTSR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetVBTSR_VBTRVLD() uint8 {
	return (volatile.LoadUint8(&o.VBTSR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetVBTSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTSR.Reg, volatile.LoadUint8(&o.VBTSR.Reg)&^(0xc)|value<<2)
}
func (o *SYSTEM_Type) GetVBTSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTSR.Reg) & 0xc) >> 2
}
func (o *SYSTEM_Type) SetVBTSR_VBTBLDF(value uint8) {
	volatile.StoreUint8(&o.VBTSR.Reg, volatile.LoadUint8(&o.VBTSR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetVBTSR_VBTBLDF() uint8 {
	return (volatile.LoadUint8(&o.VBTSR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetVBTSR_VBTRDF(value uint8) {
	volatile.StoreUint8(&o.VBTSR.Reg, volatile.LoadUint8(&o.VBTSR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTSR_VBTRDF() uint8 {
	return volatile.LoadUint8(&o.VBTSR.Reg) & 0x1
}

// SYSTEM.VBTCMPCR: VBATT Comparator Control Register
func (o *SYSTEM_Type) SetVBTCMPCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTCMPCR.Reg, volatile.LoadUint8(&o.VBTCMPCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetVBTCMPCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTCMPCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetVBTCMPCR_VBTCMPE(value uint8) {
	volatile.StoreUint8(&o.VBTCMPCR.Reg, volatile.LoadUint8(&o.VBTCMPCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTCMPCR_VBTCMPE() uint8 {
	return volatile.LoadUint8(&o.VBTCMPCR.Reg) & 0x1
}

// SYSTEM.VBTLVDICR: VBATT Pin Low Voltage Detect Interrupt Control Register
func (o *SYSTEM_Type) SetVBTLVDICR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTLVDICR.Reg, volatile.LoadUint8(&o.VBTLVDICR.Reg)&^(0xfc)|value<<2)
}
func (o *SYSTEM_Type) GetVBTLVDICR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTLVDICR.Reg) & 0xfc) >> 2
}
func (o *SYSTEM_Type) SetVBTLVDICR_VBTLVDISEL(value uint8) {
	volatile.StoreUint8(&o.VBTLVDICR.Reg, volatile.LoadUint8(&o.VBTLVDICR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetVBTLVDICR_VBTLVDISEL() uint8 {
	return (volatile.LoadUint8(&o.VBTLVDICR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetVBTLVDICR_VBTLVDIE(value uint8) {
	volatile.StoreUint8(&o.VBTLVDICR.Reg, volatile.LoadUint8(&o.VBTLVDICR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTLVDICR_VBTLVDIE() uint8 {
	return volatile.LoadUint8(&o.VBTLVDICR.Reg) & 0x1
}

// SYSTEM.VBTWCTLR: VBATT Wakeup function Control Register
func (o *SYSTEM_Type) SetVBTWCTLR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTWCTLR.Reg, volatile.LoadUint8(&o.VBTWCTLR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetVBTWCTLR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTWCTLR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetVBTWCTLR_VWEN(value uint8) {
	volatile.StoreUint8(&o.VBTWCTLR.Reg, volatile.LoadUint8(&o.VBTWCTLR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTWCTLR_VWEN() uint8 {
	return volatile.LoadUint8(&o.VBTWCTLR.Reg) & 0x1
}

// SYSTEM.VBTWCH0OTSR: VBATT Wakeup I/O 0 Output Trigger Select Register
func (o *SYSTEM_Type) SetVBTWCH0OTSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTWCH0OTSR.Reg, volatile.LoadUint8(&o.VBTWCH0OTSR.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetVBTWCH0OTSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH0OTSR.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetVBTWCH0OTSR_CH0VRTCATE(value uint8) {
	volatile.StoreUint8(&o.VBTWCH0OTSR.Reg, volatile.LoadUint8(&o.VBTWCH0OTSR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetVBTWCH0OTSR_CH0VRTCATE() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH0OTSR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetVBTWCH0OTSR_CH0VRTCTE(value uint8) {
	volatile.StoreUint8(&o.VBTWCH0OTSR.Reg, volatile.LoadUint8(&o.VBTWCH0OTSR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetVBTWCH0OTSR_CH0VRTCTE() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH0OTSR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetVBTWCH0OTSR_CH0VCH2TE(value uint8) {
	volatile.StoreUint8(&o.VBTWCH0OTSR.Reg, volatile.LoadUint8(&o.VBTWCH0OTSR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetVBTWCH0OTSR_CH0VCH2TE() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH0OTSR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetVBTWCH0OTSR_CH0VCH1TE(value uint8) {
	volatile.StoreUint8(&o.VBTWCH0OTSR.Reg, volatile.LoadUint8(&o.VBTWCH0OTSR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetVBTWCH0OTSR_CH0VCH1TE() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH0OTSR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetVBTWCH0OTSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTWCH0OTSR.Reg, volatile.LoadUint8(&o.VBTWCH0OTSR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTWCH0OTSR_Reserved() uint8 {
	return volatile.LoadUint8(&o.VBTWCH0OTSR.Reg) & 0x1
}

// SYSTEM.VBTWCH1OTSR: VBATT Wakeup I/O 1 Output Trigger Select Register
func (o *SYSTEM_Type) SetVBTWCH1OTSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTWCH1OTSR.Reg, volatile.LoadUint8(&o.VBTWCH1OTSR.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetVBTWCH1OTSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH1OTSR.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetVBTWCH1OTSR_CH1VRTCATE(value uint8) {
	volatile.StoreUint8(&o.VBTWCH1OTSR.Reg, volatile.LoadUint8(&o.VBTWCH1OTSR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetVBTWCH1OTSR_CH1VRTCATE() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH1OTSR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetVBTWCH1OTSR_CH1VRTCTE(value uint8) {
	volatile.StoreUint8(&o.VBTWCH1OTSR.Reg, volatile.LoadUint8(&o.VBTWCH1OTSR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetVBTWCH1OTSR_CH1VRTCTE() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH1OTSR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetVBTWCH1OTSR_CH1VCH2TE(value uint8) {
	volatile.StoreUint8(&o.VBTWCH1OTSR.Reg, volatile.LoadUint8(&o.VBTWCH1OTSR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetVBTWCH1OTSR_CH1VCH2TE() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH1OTSR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetVBTWCH1OTSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTWCH1OTSR.Reg, volatile.LoadUint8(&o.VBTWCH1OTSR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetVBTWCH1OTSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH1OTSR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetVBTWCH1OTSR_CH1VCH0TE(value uint8) {
	volatile.StoreUint8(&o.VBTWCH1OTSR.Reg, volatile.LoadUint8(&o.VBTWCH1OTSR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTWCH1OTSR_CH1VCH0TE() uint8 {
	return volatile.LoadUint8(&o.VBTWCH1OTSR.Reg) & 0x1
}

// SYSTEM.VBTWCH2OTSR: VBATT Wakeup I/O 2 Output Trigger Select Register
func (o *SYSTEM_Type) SetVBTWCH2OTSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTWCH2OTSR.Reg, volatile.LoadUint8(&o.VBTWCH2OTSR.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetVBTWCH2OTSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH2OTSR.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetVBTWCH2OTSR_CH2VRTCATE(value uint8) {
	volatile.StoreUint8(&o.VBTWCH2OTSR.Reg, volatile.LoadUint8(&o.VBTWCH2OTSR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetVBTWCH2OTSR_CH2VRTCATE() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH2OTSR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetVBTWCH2OTSR_CH2VRTCTE(value uint8) {
	volatile.StoreUint8(&o.VBTWCH2OTSR.Reg, volatile.LoadUint8(&o.VBTWCH2OTSR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetVBTWCH2OTSR_CH2VRTCTE() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH2OTSR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetVBTWCH2OTSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTWCH2OTSR.Reg, volatile.LoadUint8(&o.VBTWCH2OTSR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetVBTWCH2OTSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH2OTSR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetVBTWCH2OTSR_CH2VCH1TE(value uint8) {
	volatile.StoreUint8(&o.VBTWCH2OTSR.Reg, volatile.LoadUint8(&o.VBTWCH2OTSR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetVBTWCH2OTSR_CH2VCH1TE() uint8 {
	return (volatile.LoadUint8(&o.VBTWCH2OTSR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetVBTWCH2OTSR_CH2VCH0TE(value uint8) {
	volatile.StoreUint8(&o.VBTWCH2OTSR.Reg, volatile.LoadUint8(&o.VBTWCH2OTSR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTWCH2OTSR_CH2VCH0TE() uint8 {
	return volatile.LoadUint8(&o.VBTWCH2OTSR.Reg) & 0x1
}

// SYSTEM.VBTICTLR: VBATT Input Control Register
func (o *SYSTEM_Type) SetVBTICTLR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTICTLR.Reg, volatile.LoadUint8(&o.VBTICTLR.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetVBTICTLR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTICTLR.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetVBTICTLR_VCH2INEN(value uint8) {
	volatile.StoreUint8(&o.VBTICTLR.Reg, volatile.LoadUint8(&o.VBTICTLR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetVBTICTLR_VCH2INEN() uint8 {
	return (volatile.LoadUint8(&o.VBTICTLR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetVBTICTLR_VCH1INEN(value uint8) {
	volatile.StoreUint8(&o.VBTICTLR.Reg, volatile.LoadUint8(&o.VBTICTLR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetVBTICTLR_VCH1INEN() uint8 {
	return (volatile.LoadUint8(&o.VBTICTLR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetVBTICTLR_VCH0INEN(value uint8) {
	volatile.StoreUint8(&o.VBTICTLR.Reg, volatile.LoadUint8(&o.VBTICTLR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTICTLR_VCH0INEN() uint8 {
	return volatile.LoadUint8(&o.VBTICTLR.Reg) & 0x1
}

// SYSTEM.VBTOCTLR: VBATT Output Control Register
func (o *SYSTEM_Type) SetVBTOCTLR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTOCTLR.Reg, volatile.LoadUint8(&o.VBTOCTLR.Reg)&^(0xc0)|value<<6)
}
func (o *SYSTEM_Type) GetVBTOCTLR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTOCTLR.Reg) & 0xc0) >> 6
}
func (o *SYSTEM_Type) SetVBTOCTLR_VOUT2LSEL(value uint8) {
	volatile.StoreUint8(&o.VBTOCTLR.Reg, volatile.LoadUint8(&o.VBTOCTLR.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetVBTOCTLR_VOUT2LSEL() uint8 {
	return (volatile.LoadUint8(&o.VBTOCTLR.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetVBTOCTLR_VCOU1LSEL(value uint8) {
	volatile.StoreUint8(&o.VBTOCTLR.Reg, volatile.LoadUint8(&o.VBTOCTLR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetVBTOCTLR_VCOU1LSEL() uint8 {
	return (volatile.LoadUint8(&o.VBTOCTLR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetVBTOCTLR_VOUT0LSEL(value uint8) {
	volatile.StoreUint8(&o.VBTOCTLR.Reg, volatile.LoadUint8(&o.VBTOCTLR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetVBTOCTLR_VOUT0LSEL() uint8 {
	return (volatile.LoadUint8(&o.VBTOCTLR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetVBTOCTLR_VCH2OEN(value uint8) {
	volatile.StoreUint8(&o.VBTOCTLR.Reg, volatile.LoadUint8(&o.VBTOCTLR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetVBTOCTLR_VCH2OEN() uint8 {
	return (volatile.LoadUint8(&o.VBTOCTLR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetVBTOCTLR_VCH1OEN(value uint8) {
	volatile.StoreUint8(&o.VBTOCTLR.Reg, volatile.LoadUint8(&o.VBTOCTLR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetVBTOCTLR_VCH1OEN() uint8 {
	return (volatile.LoadUint8(&o.VBTOCTLR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetVBTOCTLR_VCH0OEN(value uint8) {
	volatile.StoreUint8(&o.VBTOCTLR.Reg, volatile.LoadUint8(&o.VBTOCTLR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTOCTLR_VCH0OEN() uint8 {
	return volatile.LoadUint8(&o.VBTOCTLR.Reg) & 0x1
}

// SYSTEM.VBTWTER: VBATT Wakeup Trigger source Enable Register
func (o *SYSTEM_Type) SetVBTWTER_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTWTER.Reg, volatile.LoadUint8(&o.VBTWTER.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetVBTWTER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTWTER.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetVBTWTER_VRTCAE(value uint8) {
	volatile.StoreUint8(&o.VBTWTER.Reg, volatile.LoadUint8(&o.VBTWTER.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetVBTWTER_VRTCAE() uint8 {
	return (volatile.LoadUint8(&o.VBTWTER.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetVBTWTER_VRTCIE(value uint8) {
	volatile.StoreUint8(&o.VBTWTER.Reg, volatile.LoadUint8(&o.VBTWTER.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetVBTWTER_VRTCIE() uint8 {
	return (volatile.LoadUint8(&o.VBTWTER.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetVBTWTER_VCH2E(value uint8) {
	volatile.StoreUint8(&o.VBTWTER.Reg, volatile.LoadUint8(&o.VBTWTER.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetVBTWTER_VCH2E() uint8 {
	return (volatile.LoadUint8(&o.VBTWTER.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetVBTWTER_VCH1E(value uint8) {
	volatile.StoreUint8(&o.VBTWTER.Reg, volatile.LoadUint8(&o.VBTWTER.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetVBTWTER_VCH1E() uint8 {
	return (volatile.LoadUint8(&o.VBTWTER.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetVBTWTER_VCH0E(value uint8) {
	volatile.StoreUint8(&o.VBTWTER.Reg, volatile.LoadUint8(&o.VBTWTER.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTWTER_VCH0E() uint8 {
	return volatile.LoadUint8(&o.VBTWTER.Reg) & 0x1
}

// SYSTEM.VBTWEGR: VBATT Wakeup Trigger source Edge Register
func (o *SYSTEM_Type) SetVBTWEGR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTWEGR.Reg, volatile.LoadUint8(&o.VBTWEGR.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetVBTWEGR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTWEGR.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetVBTWEGR_VCH2EG(value uint8) {
	volatile.StoreUint8(&o.VBTWEGR.Reg, volatile.LoadUint8(&o.VBTWEGR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetVBTWEGR_VCH2EG() uint8 {
	return (volatile.LoadUint8(&o.VBTWEGR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetVBTWEGR_VCH1EG(value uint8) {
	volatile.StoreUint8(&o.VBTWEGR.Reg, volatile.LoadUint8(&o.VBTWEGR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetVBTWEGR_VCH1EG() uint8 {
	return (volatile.LoadUint8(&o.VBTWEGR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetVBTWEGR_VCH0EG(value uint8) {
	volatile.StoreUint8(&o.VBTWEGR.Reg, volatile.LoadUint8(&o.VBTWEGR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTWEGR_VCH0EG() uint8 {
	return volatile.LoadUint8(&o.VBTWEGR.Reg) & 0x1
}

// SYSTEM.VBTWFR: VBATT Wakeup trigger source Flag Register
func (o *SYSTEM_Type) SetVBTWFR_Reserved(value uint8) {
	volatile.StoreUint8(&o.VBTWFR.Reg, volatile.LoadUint8(&o.VBTWFR.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetVBTWFR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VBTWFR.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetVBTWFR_VRTCAF(value uint8) {
	volatile.StoreUint8(&o.VBTWFR.Reg, volatile.LoadUint8(&o.VBTWFR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetVBTWFR_VRTCAF() uint8 {
	return (volatile.LoadUint8(&o.VBTWFR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetVBTWFR_VRTCIF(value uint8) {
	volatile.StoreUint8(&o.VBTWFR.Reg, volatile.LoadUint8(&o.VBTWFR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetVBTWFR_VRTCIF() uint8 {
	return (volatile.LoadUint8(&o.VBTWFR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetVBTWFR_VCH2F(value uint8) {
	volatile.StoreUint8(&o.VBTWFR.Reg, volatile.LoadUint8(&o.VBTWFR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetVBTWFR_VCH2F() uint8 {
	return (volatile.LoadUint8(&o.VBTWFR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetVBTWFR_VCH1F(value uint8) {
	volatile.StoreUint8(&o.VBTWFR.Reg, volatile.LoadUint8(&o.VBTWFR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetVBTWFR_VCH1F() uint8 {
	return (volatile.LoadUint8(&o.VBTWFR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetVBTWFR_VCH0F(value uint8) {
	volatile.StoreUint8(&o.VBTWFR.Reg, volatile.LoadUint8(&o.VBTWFR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTWFR_VCH0F() uint8 {
	return volatile.LoadUint8(&o.VBTWFR.Reg) & 0x1
}

// SYSTEM.VBTBKR: VBATT Backup Register [%s]
func (o *SYSTEM_Type) SetVBTBKR(idx int, value uint8) {
	volatile.StoreUint8(&o.VBTBKR[idx].Reg, value)
}
func (o *SYSTEM_Type) GetVBTBKR(idx int) uint8 {
	return volatile.LoadUint8(&o.VBTBKR[idx].Reg)
}

// Module Stop Control B,C,D
type MSTP_Type struct {
	MSTPCRB volatile.Register32 // 0x0
	MSTPCRC volatile.Register32 // 0x4
	MSTPCRD volatile.Register32 // 0x8
}

// MSTP.MSTPCRB: Module Stop Control Register B
func (o *MSTP_Type) SetMSTPCRB_MSTPB31(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x80000000)|value<<31)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB31() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x80000000) >> 31
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB30(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x40000000)|value<<30)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB30() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x40000000) >> 30
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB29(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x20000000)|value<<29)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB29() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x20000000) >> 29
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB28(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x10000000)|value<<28)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB28() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x10000000) >> 28
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB27(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x8000000)|value<<27)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB27() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x8000000) >> 27
}
func (o *MSTP_Type) SetMSTPCRB_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x7800000)|value<<23)
}
func (o *MSTP_Type) GetMSTPCRB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x7800000) >> 23
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB22(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x400000)|value<<22)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB22() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x400000) >> 22
}
func (o *MSTP_Type) SetMSTPCRB_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x300000)|value<<20)
}
func (o *MSTP_Type) GetMSTPCRB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x300000) >> 20
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB19(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x80000)|value<<19)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB19() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x80000) >> 19
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB18(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x40000)|value<<18)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB18() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x40000) >> 18
}
func (o *MSTP_Type) SetMSTPCRB_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x3f000)|value<<12)
}
func (o *MSTP_Type) GetMSTPCRB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x3f000) >> 12
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB11(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x800)|value<<11)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB11() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x800) >> 11
}
func (o *MSTP_Type) SetMSTPCRB_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x400)|value<<10)
}
func (o *MSTP_Type) GetMSTPCRB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x400) >> 10
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB9(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x200)|value<<9)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB9() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x200) >> 9
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB8(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x100)|value<<8)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB8() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x100) >> 8
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB7(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x80)|value<<7)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB7() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x80) >> 7
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB6(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x40)|value<<6)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB6() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x40) >> 6
}
func (o *MSTP_Type) SetMSTPCRB_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x38)|value<<3)
}
func (o *MSTP_Type) GetMSTPCRB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x38) >> 3
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB2(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB2() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x4) >> 2
}
func (o *MSTP_Type) SetMSTPCRB_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x3)|value)
}
func (o *MSTP_Type) GetMSTPCRB_Reserved() uint32 {
	return volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x3
}

// MSTP.MSTPCRC: Module Stop Control Register C
func (o *MSTP_Type) SetMSTPCRC_MSTPC31(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x80000000)|value<<31)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC31() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x80000000) >> 31
}
func (o *MSTP_Type) SetMSTPCRC_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x7fff8000)|value<<15)
}
func (o *MSTP_Type) GetMSTPCRC_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x7fff8000) >> 15
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC14(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x4000)|value<<14)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC14() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x4000) >> 14
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC13(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x2000)|value<<13)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC13() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x2000) >> 13
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC12(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x1000)|value<<12)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC12() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x1000) >> 12
}
func (o *MSTP_Type) SetMSTPCRC_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0xe00)|value<<9)
}
func (o *MSTP_Type) GetMSTPCRC_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0xe00) >> 9
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC8(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x100)|value<<8)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC8() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x100) >> 8
}
func (o *MSTP_Type) SetMSTPCRC_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0xe0)|value<<5)
}
func (o *MSTP_Type) GetMSTPCRC_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0xe0) >> 5
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC4(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x10)|value<<4)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC4() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x10) >> 4
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC3(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x8)|value<<3)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC3() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x8) >> 3
}
func (o *MSTP_Type) SetMSTPCRC_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetMSTPCRC_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x4) >> 2
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC1(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x2)|value<<1)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC1() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x2) >> 1
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC0(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x1)|value)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC0() uint32 {
	return volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x1
}

// MSTP.MSTPCRD: Module Stop Control Register D
func (o *MSTP_Type) SetMSTPCRD_MSTPD31(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x80000000)|value<<31)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD31() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x80000000) >> 31
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x40000000)|value<<30)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x40000000) >> 30
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD29(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x20000000)|value<<29)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD29() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x20000000) >> 29
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x1fe00000)|value<<21)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x1fe00000) >> 21
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD20(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x100000)|value<<20)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD20() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x100000) >> 20
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD19(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x80000)|value<<19)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD19() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x80000) >> 19
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x60000)|value<<17)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x60000) >> 17
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD16(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x10000)|value<<16)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD16() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x10000) >> 16
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x8000)|value<<15)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x8000) >> 15
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD14(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x4000)|value<<14)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD14() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x4000) >> 14
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x3f80)|value<<7)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x3f80) >> 7
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD6(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x40)|value<<6)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD6() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x40) >> 6
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD5(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x20)|value<<5)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD5() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x20) >> 5
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x10)|value<<4)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x10) >> 4
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD3(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x8)|value<<3)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD3() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x8) >> 3
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD2(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD2() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x4) >> 2
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x3)|value)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x3
}

// Flash Cache
type FCACHE_Type struct {
	_        [256]byte
	FCACHEE  volatile.Register16 // 0x100
	_        [2]byte
	FCACHEIV volatile.Register16 // 0x104
	_        [22]byte
	FLWT     volatile.Register8 // 0x11C
}

// FCACHE.FCACHEE: Flash Cache Enable Register
func (o *FCACHE_Type) SetFCACHEE_Reserved(value uint16) {
	volatile.StoreUint16(&o.FCACHEE.Reg, volatile.LoadUint16(&o.FCACHEE.Reg)&^(0xfffe)|value<<1)
}
func (o *FCACHE_Type) GetFCACHEE_Reserved() uint16 {
	return (volatile.LoadUint16(&o.FCACHEE.Reg) & 0xfffe) >> 1
}
func (o *FCACHE_Type) SetFCACHEE_FCACHEEN(value uint16) {
	volatile.StoreUint16(&o.FCACHEE.Reg, volatile.LoadUint16(&o.FCACHEE.Reg)&^(0x1)|value)
}
func (o *FCACHE_Type) GetFCACHEE_FCACHEEN() uint16 {
	return volatile.LoadUint16(&o.FCACHEE.Reg) & 0x1
}

// FCACHE.FCACHEIV: Flash Cache Invalidate Register
func (o *FCACHE_Type) SetFCACHEIV_Reserved(value uint16) {
	volatile.StoreUint16(&o.FCACHEIV.Reg, volatile.LoadUint16(&o.FCACHEIV.Reg)&^(0xfffe)|value<<1)
}
func (o *FCACHE_Type) GetFCACHEIV_Reserved() uint16 {
	return (volatile.LoadUint16(&o.FCACHEIV.Reg) & 0xfffe) >> 1
}
func (o *FCACHE_Type) SetFCACHEIV(value uint16) {
	volatile.StoreUint16(&o.FCACHEIV.Reg, volatile.LoadUint16(&o.FCACHEIV.Reg)&^(0x1)|value)
}
func (o *FCACHE_Type) GetFCACHEIV() uint16 {
	return volatile.LoadUint16(&o.FCACHEIV.Reg) & 0x1
}

// FCACHE.FLWT: Flash Wait Cycle Register
func (o *FCACHE_Type) SetFLWT_Reserved(value uint8) {
	volatile.StoreUint8(&o.FLWT.Reg, volatile.LoadUint8(&o.FLWT.Reg)&^(0xf8)|value<<3)
}
func (o *FCACHE_Type) GetFLWT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.FLWT.Reg) & 0xf8) >> 3
}
func (o *FCACHE_Type) SetFLWT(value uint8) {
	volatile.StoreUint8(&o.FLWT.Reg, volatile.LoadUint8(&o.FLWT.Reg)&^(0x7)|value)
}
func (o *FCACHE_Type) GetFLWT() uint8 {
	return volatile.LoadUint8(&o.FLWT.Reg) & 0x7
}

// Interrupt Controller
type ICU_Type struct {
	IRQCR0  volatile.Register8 // 0x0
	IRQCR1  volatile.Register8 // 0x1
	IRQCR2  volatile.Register8 // 0x2
	IRQCR3  volatile.Register8 // 0x3
	IRQCR4  volatile.Register8 // 0x4
	IRQCR5  volatile.Register8 // 0x5
	IRQCR6  volatile.Register8 // 0x6
	IRQCR7  volatile.Register8 // 0x7
	IRQCR8  volatile.Register8 // 0x8
	IRQCR9  volatile.Register8 // 0x9
	IRQCR10 volatile.Register8 // 0xA
	IRQCR11 volatile.Register8 // 0xB
	IRQCR12 volatile.Register8 // 0xC
	IRQCR13 volatile.Register8 // 0xD
	IRQCR14 volatile.Register8 // 0xE
	IRQCR15 volatile.Register8 // 0xF
	_       [240]byte
	NMICR   volatile.Register8 // 0x100
	_       [31]byte
	NMIER   volatile.Register16 // 0x120
	_       [14]byte
	NMICLR  volatile.Register16 // 0x130
	_       [14]byte
	NMISR   volatile.Register16 // 0x140
	_       [94]byte
	WUPEN   volatile.Register32 // 0x1A0
	_       [92]byte
	SELSR0  volatile.Register16 // 0x200
	_       [126]byte
	DELSR0  volatile.Register16 // 0x280
	_       [2]byte
	DELSR1  volatile.Register16 // 0x284
	_       [2]byte
	DELSR2  volatile.Register16 // 0x288
	_       [2]byte
	DELSR3  volatile.Register16 // 0x28C
	_       [114]byte
	IELSR0  volatile.Register32 // 0x300
	IELSR1  volatile.Register32 // 0x304
	IELSR2  volatile.Register32 // 0x308
	IELSR3  volatile.Register32 // 0x30C
	IELSR4  volatile.Register32 // 0x310
	IELSR5  volatile.Register32 // 0x314
	IELSR6  volatile.Register32 // 0x318
	IELSR7  volatile.Register32 // 0x31C
	IELSR8  volatile.Register32 // 0x320
	IELSR9  volatile.Register32 // 0x324
	IELSR10 volatile.Register32 // 0x328
	IELSR11 volatile.Register32 // 0x32C
	IELSR12 volatile.Register32 // 0x330
	IELSR13 volatile.Register32 // 0x334
	IELSR14 volatile.Register32 // 0x338
	IELSR15 volatile.Register32 // 0x33C
	IELSR16 volatile.Register32 // 0x340
	IELSR17 volatile.Register32 // 0x344
	IELSR18 volatile.Register32 // 0x348
	IELSR19 volatile.Register32 // 0x34C
	IELSR20 volatile.Register32 // 0x350
	IELSR21 volatile.Register32 // 0x354
	IELSR22 volatile.Register32 // 0x358
	IELSR23 volatile.Register32 // 0x35C
	IELSR24 volatile.Register32 // 0x360
	IELSR25 volatile.Register32 // 0x364
	IELSR26 volatile.Register32 // 0x368
	IELSR27 volatile.Register32 // 0x36C
	IELSR28 volatile.Register32 // 0x370
	IELSR29 volatile.Register32 // 0x374
	IELSR30 volatile.Register32 // 0x378
	IELSR31 volatile.Register32 // 0x37C
}

// ICU.IRQCR0: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR0_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR0_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR0_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR0_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR0_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR0_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR0.Reg) & 0x3
}

// ICU.IRQCR1: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR1_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR1_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR1_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR1_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR1_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR1_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR1.Reg) & 0x3
}

// ICU.IRQCR2: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR2_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR2_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR2_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR2_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR2_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR2_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR2.Reg) & 0x3
}

// ICU.IRQCR3: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR3_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR3_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR3_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR3_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR3_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR3_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR3_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR3_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR3_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR3_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR3.Reg) & 0x3
}

// ICU.IRQCR4: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR4_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR4_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR4_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR4_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR4_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR4_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR4_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR4_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR4_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR4_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR4.Reg) & 0x3
}

// ICU.IRQCR5: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR5_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR5_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR5_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR5_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR5_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR5_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR5_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR5_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR5_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR5_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR5.Reg) & 0x3
}

// ICU.IRQCR6: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR6_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR6_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR6_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR6_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR6_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR6_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR6_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR6_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR6_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR6_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR6.Reg) & 0x3
}

// ICU.IRQCR7: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR7_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR7_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR7_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR7_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR7_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR7_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR7_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR7_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR7_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR7_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR7.Reg) & 0x3
}

// ICU.IRQCR8: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR8_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR8.Reg, volatile.LoadUint8(&o.IRQCR8.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR8_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR8.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR8_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR8.Reg, volatile.LoadUint8(&o.IRQCR8.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR8_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR8.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR8_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR8.Reg, volatile.LoadUint8(&o.IRQCR8.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR8_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR8.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR8_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR8.Reg, volatile.LoadUint8(&o.IRQCR8.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR8_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR8.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR8_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR8.Reg, volatile.LoadUint8(&o.IRQCR8.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR8_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR8.Reg) & 0x3
}

// ICU.IRQCR9: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR9_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR9.Reg, volatile.LoadUint8(&o.IRQCR9.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR9_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR9.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR9_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR9.Reg, volatile.LoadUint8(&o.IRQCR9.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR9_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR9.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR9_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR9.Reg, volatile.LoadUint8(&o.IRQCR9.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR9_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR9.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR9_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR9.Reg, volatile.LoadUint8(&o.IRQCR9.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR9_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR9.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR9_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR9.Reg, volatile.LoadUint8(&o.IRQCR9.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR9_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR9.Reg) & 0x3
}

// ICU.IRQCR10: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR10_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR10.Reg, volatile.LoadUint8(&o.IRQCR10.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR10_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR10.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR10_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR10.Reg, volatile.LoadUint8(&o.IRQCR10.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR10_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR10.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR10_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR10.Reg, volatile.LoadUint8(&o.IRQCR10.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR10_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR10.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR10_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR10.Reg, volatile.LoadUint8(&o.IRQCR10.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR10_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR10.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR10_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR10.Reg, volatile.LoadUint8(&o.IRQCR10.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR10_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR10.Reg) & 0x3
}

// ICU.IRQCR11: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR11_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR11.Reg, volatile.LoadUint8(&o.IRQCR11.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR11_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR11.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR11_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR11.Reg, volatile.LoadUint8(&o.IRQCR11.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR11_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR11.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR11_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR11.Reg, volatile.LoadUint8(&o.IRQCR11.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR11_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR11.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR11_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR11.Reg, volatile.LoadUint8(&o.IRQCR11.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR11_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR11.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR11_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR11.Reg, volatile.LoadUint8(&o.IRQCR11.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR11_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR11.Reg) & 0x3
}

// ICU.IRQCR12: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR12_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR12.Reg, volatile.LoadUint8(&o.IRQCR12.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR12_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR12.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR12_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR12.Reg, volatile.LoadUint8(&o.IRQCR12.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR12_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR12.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR12_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR12.Reg, volatile.LoadUint8(&o.IRQCR12.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR12_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR12.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR12_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR12.Reg, volatile.LoadUint8(&o.IRQCR12.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR12_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR12.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR12_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR12.Reg, volatile.LoadUint8(&o.IRQCR12.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR12_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR12.Reg) & 0x3
}

// ICU.IRQCR13: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR13_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR13.Reg, volatile.LoadUint8(&o.IRQCR13.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR13_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR13.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR13_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR13.Reg, volatile.LoadUint8(&o.IRQCR13.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR13_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR13.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR13_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR13.Reg, volatile.LoadUint8(&o.IRQCR13.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR13_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR13.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR13_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR13.Reg, volatile.LoadUint8(&o.IRQCR13.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR13_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR13.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR13_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR13.Reg, volatile.LoadUint8(&o.IRQCR13.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR13_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR13.Reg) & 0x3
}

// ICU.IRQCR14: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR14_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR14.Reg, volatile.LoadUint8(&o.IRQCR14.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR14_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR14.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR14_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR14.Reg, volatile.LoadUint8(&o.IRQCR14.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR14_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR14.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR14_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR14.Reg, volatile.LoadUint8(&o.IRQCR14.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR14_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR14.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR14_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR14.Reg, volatile.LoadUint8(&o.IRQCR14.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR14_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR14.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR14_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR14.Reg, volatile.LoadUint8(&o.IRQCR14.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR14_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR14.Reg) & 0x3
}

// ICU.IRQCR15: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR15_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR15.Reg, volatile.LoadUint8(&o.IRQCR15.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR15_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR15.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR15_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR15.Reg, volatile.LoadUint8(&o.IRQCR15.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR15_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR15.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR15_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR15.Reg, volatile.LoadUint8(&o.IRQCR15.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR15_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR15.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR15_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR15.Reg, volatile.LoadUint8(&o.IRQCR15.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR15_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR15.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR15_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR15.Reg, volatile.LoadUint8(&o.IRQCR15.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR15_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR15.Reg) & 0x3
}

// ICU.NMICR: NMI Pin Interrupt Control Register
func (o *ICU_Type) SetNMICR_NFLTEN(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMICR_NFLTEN() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMICR_Reserved(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMICR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMICR_NFCLKSEL(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetNMICR_NFCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetNMICR_Reserved(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0xe)|value<<1)
}
func (o *ICU_Type) GetNMICR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0xe) >> 1
}
func (o *ICU_Type) SetNMICR_NMIMD(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMICR_NMIMD() uint8 {
	return volatile.LoadUint8(&o.NMICR.Reg) & 0x1
}

// ICU.NMIER: Non-Maskable Interrupt Enable Register
func (o *ICU_Type) SetNMIER_Reserved(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0xe000)|value<<13)
}
func (o *ICU_Type) GetNMIER_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0xe000) >> 13
}
func (o *ICU_Type) SetNMIER_SPEEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetNMIER_SPEEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x1000) >> 12
}
func (o *ICU_Type) SetNMIER_BUSMEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMIER_BUSMEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMIER_BUSSEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetNMIER_BUSSEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetNMIER_RECCEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetNMIER_RECCEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetNMIER_RPEEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMIER_RPEEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMIER_NMIEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMIER_NMIEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMIER_OSTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMIER_OSTEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMIER_Reserved(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x20)|value<<5)
}
func (o *ICU_Type) GetNMIER_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x20) >> 5
}
func (o *ICU_Type) SetNMIER_VBATTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x10)|value<<4)
}
func (o *ICU_Type) GetNMIER_VBATTEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x10) >> 4
}
func (o *ICU_Type) SetNMIER_LVD2EN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMIER_LVD2EN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMIER_LVD1EN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMIER_LVD1EN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMIER_WDTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMIER_WDTEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMIER_IWDTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMIER_IWDTEN() uint16 {
	return volatile.LoadUint16(&o.NMIER.Reg) & 0x1
}

// ICU.NMICLR: Non-Maskable Interrupt Status Clear Register
func (o *ICU_Type) SetNMICLR_Reserved(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0xe000)|value<<13)
}
func (o *ICU_Type) GetNMICLR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0xe000) >> 13
}
func (o *ICU_Type) SetNMICLR_SPECLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetNMICLR_SPECLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x1000) >> 12
}
func (o *ICU_Type) SetNMICLR_BUSMCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMICLR_BUSMCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMICLR_BUSSCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetNMICLR_BUSSCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetNMICLR_RECCCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetNMICLR_RECCCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetNMICLR_RPECLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMICLR_RPECLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMICLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMICLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMICLR_OSTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMICLR_OSTCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMICLR_Reserved(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x20)|value<<5)
}
func (o *ICU_Type) GetNMICLR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x20) >> 5
}
func (o *ICU_Type) SetNMICLR_VBATTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x10)|value<<4)
}
func (o *ICU_Type) GetNMICLR_VBATTCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x10) >> 4
}
func (o *ICU_Type) SetNMICLR_LVD2CLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMICLR_LVD2CLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMICLR_LVD1CLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMICLR_LVD1CLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMICLR_WDTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMICLR_WDTCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMICLR_IWDTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMICLR_IWDTCLR() uint16 {
	return volatile.LoadUint16(&o.NMICLR.Reg) & 0x1
}

// ICU.NMISR: Non-Maskable Interrupt Status Register
func (o *ICU_Type) SetNMISR_Reserved(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0xe000)|value<<13)
}
func (o *ICU_Type) GetNMISR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0xe000) >> 13
}
func (o *ICU_Type) SetNMISR_SPEST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetNMISR_SPEST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x1000) >> 12
}
func (o *ICU_Type) SetNMISR_BUSMST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMISR_BUSMST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMISR_BUSSST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetNMISR_BUSSST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetNMISR_RECCST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetNMISR_RECCST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetNMISR_RPEST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMISR_RPEST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMISR_NMIST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMISR_NMIST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMISR_OSTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMISR_OSTST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMISR_Reserved(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x20)|value<<5)
}
func (o *ICU_Type) GetNMISR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x20) >> 5
}
func (o *ICU_Type) SetNMISR_VBATTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x10)|value<<4)
}
func (o *ICU_Type) GetNMISR_VBATTST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x10) >> 4
}
func (o *ICU_Type) SetNMISR_LVD2ST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMISR_LVD2ST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMISR_LVD1ST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMISR_LVD1ST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMISR_WDTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMISR_WDTST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMISR_IWDTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMISR_IWDTST() uint16 {
	return volatile.LoadUint16(&o.NMISR.Reg) & 0x1
}

// ICU.WUPEN: Wake Up Interrupt Enable Register
func (o *ICU_Type) SetWUPEN_IIC0WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x80000000)|value<<31)
}
func (o *ICU_Type) GetWUPEN_IIC0WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x80000000) >> 31
}
func (o *ICU_Type) SetWUPEN_AGT1CBWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x40000000)|value<<30)
}
func (o *ICU_Type) GetWUPEN_AGT1CBWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x40000000) >> 30
}
func (o *ICU_Type) SetWUPEN_AGT1CAWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x20000000)|value<<29)
}
func (o *ICU_Type) GetWUPEN_AGT1CAWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x20000000) >> 29
}
func (o *ICU_Type) SetWUPEN_AGT1UDWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x10000000)|value<<28)
}
func (o *ICU_Type) GetWUPEN_AGT1UDWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x10000000) >> 28
}
func (o *ICU_Type) SetWUPEN_USBFSWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x8000000)|value<<27)
}
func (o *ICU_Type) GetWUPEN_USBFSWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x8000000) >> 27
}
func (o *ICU_Type) SetWUPEN_Reserved(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x4000000)|value<<26)
}
func (o *ICU_Type) GetWUPEN_Reserved() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x4000000) >> 26
}
func (o *ICU_Type) SetWUPEN_RTCPRDWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x2000000)|value<<25)
}
func (o *ICU_Type) GetWUPEN_RTCPRDWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x2000000) >> 25
}
func (o *ICU_Type) SetWUPEN_RTCALMWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetWUPEN_RTCALMWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetWUPEN_ACMPLP0WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x800000)|value<<23)
}
func (o *ICU_Type) GetWUPEN_ACMPLP0WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x800000) >> 23
}
func (o *ICU_Type) SetWUPEN_Reserved(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x600000)|value<<21)
}
func (o *ICU_Type) GetWUPEN_Reserved() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x600000) >> 21
}
func (o *ICU_Type) SetWUPEN_VBATTWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x100000)|value<<20)
}
func (o *ICU_Type) GetWUPEN_VBATTWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x100000) >> 20
}
func (o *ICU_Type) SetWUPEN_LVD2WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x80000)|value<<19)
}
func (o *ICU_Type) GetWUPEN_LVD2WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x80000) >> 19
}
func (o *ICU_Type) SetWUPEN_LVD1WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x40000)|value<<18)
}
func (o *ICU_Type) GetWUPEN_LVD1WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x40000) >> 18
}
func (o *ICU_Type) SetWUPEN_KEYWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x20000)|value<<17)
}
func (o *ICU_Type) GetWUPEN_KEYWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x20000) >> 17
}
func (o *ICU_Type) SetWUPEN_IWDTWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetWUPEN_IWDTWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN15(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x8000)|value<<15)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN15() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x8000) >> 15
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN14(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x4000)|value<<14)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN14() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x4000) >> 14
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN13(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x2000)|value<<13)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN13() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x2000) >> 13
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN12(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN12() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x1000) >> 12
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN11(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN11() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN10(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN10() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN9(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN9() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN8(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN8() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN7(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN7() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN6(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN6() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN5(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x20)|value<<5)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN5() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x20) >> 5
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN4(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x10)|value<<4)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN4() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x10) >> 4
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN3(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN3() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN2(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN2() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN1(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN1() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN0(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN0() uint32 {
	return volatile.LoadUint32(&o.WUPEN.Reg) & 0x1
}

// ICU.SELSR0: Snooze Event Link Setting Register
func (o *ICU_Type) SetSELSR0_Reserved(value uint16) {
	volatile.StoreUint16(&o.SELSR0.Reg, volatile.LoadUint16(&o.SELSR0.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetSELSR0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SELSR0.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetSELSR0_SELS(value uint16) {
	volatile.StoreUint16(&o.SELSR0.Reg, volatile.LoadUint16(&o.SELSR0.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetSELSR0_SELS() uint16 {
	return volatile.LoadUint16(&o.SELSR0.Reg) & 0xff
}

// ICU.DELSR0: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR0_Reserved(value uint16) {
	volatile.StoreUint16(&o.DELSR0.Reg, volatile.LoadUint16(&o.DELSR0.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetDELSR0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DELSR0.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetDELSR0_DELS(value uint16) {
	volatile.StoreUint16(&o.DELSR0.Reg, volatile.LoadUint16(&o.DELSR0.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetDELSR0_DELS() uint16 {
	return volatile.LoadUint16(&o.DELSR0.Reg) & 0xff
}

// ICU.DELSR1: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR1_Reserved(value uint16) {
	volatile.StoreUint16(&o.DELSR1.Reg, volatile.LoadUint16(&o.DELSR1.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetDELSR1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DELSR1.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetDELSR1_DELS(value uint16) {
	volatile.StoreUint16(&o.DELSR1.Reg, volatile.LoadUint16(&o.DELSR1.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetDELSR1_DELS() uint16 {
	return volatile.LoadUint16(&o.DELSR1.Reg) & 0xff
}

// ICU.DELSR2: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR2_Reserved(value uint16) {
	volatile.StoreUint16(&o.DELSR2.Reg, volatile.LoadUint16(&o.DELSR2.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetDELSR2_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DELSR2.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetDELSR2_DELS(value uint16) {
	volatile.StoreUint16(&o.DELSR2.Reg, volatile.LoadUint16(&o.DELSR2.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetDELSR2_DELS() uint16 {
	return volatile.LoadUint16(&o.DELSR2.Reg) & 0xff
}

// ICU.DELSR3: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR3_Reserved(value uint16) {
	volatile.StoreUint16(&o.DELSR3.Reg, volatile.LoadUint16(&o.DELSR3.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetDELSR3_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DELSR3.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetDELSR3_DELS(value uint16) {
	volatile.StoreUint16(&o.DELSR3.Reg, volatile.LoadUint16(&o.DELSR3.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetDELSR3_DELS() uint16 {
	return volatile.LoadUint16(&o.DELSR3.Reg) & 0xff
}

// ICU.IELSR0: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR0_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR0_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR0.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR0_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR0_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR0.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR0_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR0_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR0.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR0_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR0_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR0.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR0_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR0_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR0.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR0_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR0_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR0.Reg) & 0xff
}

// ICU.IELSR1: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR1.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR1_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR1_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR1.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR1.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR1_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR1_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR1.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR1.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR1_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR1_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR1.Reg) & 0xff
}

// ICU.IELSR2: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR2.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR2_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR2_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR2.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR2.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR2_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR2_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR2.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR2.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR2_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR2_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR2.Reg) & 0xff
}

// ICU.IELSR3: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR3_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR3_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR3.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR3_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR3_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR3.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR3_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR3_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR3.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR3_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR3_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR3.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR3_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR3_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR3.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR3_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR3_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR3.Reg) & 0xff
}

// ICU.IELSR4: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR4_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR4_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR4.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR4_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR4_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR4.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR4_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR4_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR4.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR4_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR4_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR4.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR4_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR4_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR4.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR4_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR4_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR4.Reg) & 0xff
}

// ICU.IELSR5: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR5_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR5_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR5.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR5_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR5_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR5.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR5_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR5_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR5.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR5_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR5_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR5.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR5_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR5_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR5.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR5_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR5_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR5.Reg) & 0xff
}

// ICU.IELSR6: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR6_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR6_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR6.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR6_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR6_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR6.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR6_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR6_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR6.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR6_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR6_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR6.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR6_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR6_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR6.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR6_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR6_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR6.Reg) & 0xff
}

// ICU.IELSR7: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR7_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR7_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR7.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR7_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR7_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR7.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR7_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR7_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR7.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR7_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR7_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR7.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR7_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR7_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR7.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR7_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR7_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR7.Reg) & 0xff
}

// ICU.IELSR8: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR8_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR8_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR8.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR8_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR8_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR8.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR8_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR8_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR8.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR8_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR8_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR8.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR8_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR8_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR8.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR8_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR8_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR8.Reg) & 0xff
}

// ICU.IELSR9: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR9_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR9_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR9.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR9_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR9_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR9.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR9_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR9_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR9.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR9_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR9_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR9.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR9_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR9_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR9.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR9_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR9_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR9.Reg) & 0xff
}

// ICU.IELSR10: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR10_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR10_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR10.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR10_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR10_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR10.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR10_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR10_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR10.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR10_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR10_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR10.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR10_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR10_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR10.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR10_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR10_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR10.Reg) & 0xff
}

// ICU.IELSR11: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR11_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR11_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR11.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR11_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR11_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR11.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR11_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR11_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR11.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR11_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR11_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR11.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR11_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR11_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR11.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR11_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR11_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR11.Reg) & 0xff
}

// ICU.IELSR12: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR12_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR12_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR12.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR12_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR12_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR12.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR12_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR12_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR12.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR12_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR12_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR12.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR12_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR12_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR12.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR12_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR12_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR12.Reg) & 0xff
}

// ICU.IELSR13: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR13_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR13_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR13.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR13_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR13_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR13.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR13_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR13_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR13.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR13_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR13_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR13.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR13_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR13_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR13.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR13_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR13_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR13.Reg) & 0xff
}

// ICU.IELSR14: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR14_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR14_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR14.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR14_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR14_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR14.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR14_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR14_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR14.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR14_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR14_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR14.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR14_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR14_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR14.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR14_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR14_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR14.Reg) & 0xff
}

// ICU.IELSR15: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR15_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR15_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR15.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR15_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR15_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR15.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR15_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR15_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR15.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR15_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR15_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR15.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR15_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR15_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR15.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR15_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR15_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR15.Reg) & 0xff
}

// ICU.IELSR16: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR16_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR16_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR16.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR16_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR16_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR16.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR16_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR16_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR16.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR16_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR16_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR16.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR16_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR16_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR16.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR16_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR16_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR16.Reg) & 0xff
}

// ICU.IELSR17: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR17_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR17_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR17.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR17_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR17_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR17.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR17_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR17_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR17.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR17_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR17_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR17.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR17_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR17_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR17.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR17_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR17_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR17.Reg) & 0xff
}

// ICU.IELSR18: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR18_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR18_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR18.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR18_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR18_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR18.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR18_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR18_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR18.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR18_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR18_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR18.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR18_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR18_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR18.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR18_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR18_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR18.Reg) & 0xff
}

// ICU.IELSR19: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR19_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR19_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR19.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR19_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR19_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR19.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR19_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR19_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR19.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR19_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR19_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR19.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR19_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR19_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR19.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR19_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR19_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR19.Reg) & 0xff
}

// ICU.IELSR20: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR20_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR20_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR20.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR20_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR20_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR20.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR20_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR20_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR20.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR20_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR20_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR20.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR20_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR20_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR20.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR20_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR20_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR20.Reg) & 0xff
}

// ICU.IELSR21: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR21_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR21_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR21.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR21_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR21_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR21.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR21_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR21_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR21.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR21_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR21_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR21.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR21_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR21_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR21.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR21_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR21_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR21.Reg) & 0xff
}

// ICU.IELSR22: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR22_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR22_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR22.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR22_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR22_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR22.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR22_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR22_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR22.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR22_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR22_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR22.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR22_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR22_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR22.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR22_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR22_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR22.Reg) & 0xff
}

// ICU.IELSR23: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR23_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR23_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR23.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR23_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR23_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR23.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR23_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR23_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR23.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR23_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR23_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR23.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR23_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR23_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR23.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR23_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR23_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR23.Reg) & 0xff
}

// ICU.IELSR24: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR24_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR24_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR24.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR24_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR24_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR24.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR24_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR24_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR24.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR24_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR24_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR24.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR24_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR24_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR24.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR24_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR24_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR24.Reg) & 0xff
}

// ICU.IELSR25: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR25_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR25_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR25.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR25_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR25_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR25.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR25_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR25_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR25.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR25_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR25_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR25.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR25_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR25_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR25.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR25_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR25_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR25.Reg) & 0xff
}

// ICU.IELSR26: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR26_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR26_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR26.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR26_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR26_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR26.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR26_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR26_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR26.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR26_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR26_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR26.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR26_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR26_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR26.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR26_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR26_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR26.Reg) & 0xff
}

// ICU.IELSR27: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR27_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR27_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR27.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR27_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR27_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR27.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR27_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR27_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR27.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR27_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR27_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR27.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR27_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR27_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR27.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR27_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR27_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR27.Reg) & 0xff
}

// ICU.IELSR28: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR28_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR28_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR28.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR28_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR28_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR28.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR28_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR28_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR28.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR28_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR28_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR28.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR28_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR28_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR28.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR28_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR28_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR28.Reg) & 0xff
}

// ICU.IELSR29: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR29_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR29_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR29.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR29_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR29_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR29.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR29_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR29_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR29.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR29_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR29_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR29.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR29_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR29_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR29.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR29_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR29_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR29.Reg) & 0xff
}

// ICU.IELSR30: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR30_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR30_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR30.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR30_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR30_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR30.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR30_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR30_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR30.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR30_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR30_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR30.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR30_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR30_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR30.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR30_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR30_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR30.Reg) & 0xff
}

// ICU.IELSR31: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR31_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR31_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR31.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR31_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR31_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR31.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR31_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR31_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR31.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR31_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR31_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR31.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR31_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR31_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR31.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR31_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR31_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR31.Reg) & 0xff
}

// Direct memory access controller 0
type DMAC0_Type struct {
	DMSAR volatile.Register32 // 0x0
	DMDAR volatile.Register32 // 0x4
	DMCRA volatile.Register32 // 0x8
	DMCRB volatile.Register16 // 0xC
	_     [2]byte
	DMTMD volatile.Register16 // 0x10
	_     byte
	DMINT volatile.Register8  // 0x13
	DMAMD volatile.Register16 // 0x14
	_     [2]byte
	DMOFR volatile.Register32 // 0x18
	DMCNT volatile.Register8  // 0x1C
	DMREQ volatile.Register8  // 0x1D
	DMSTS volatile.Register8  // 0x1E
}

// DMAC0.DMSAR: DMA Source Address Register
func (o *DMAC0_Type) SetDMSAR(value uint32) {
	volatile.StoreUint32(&o.DMSAR.Reg, value)
}
func (o *DMAC0_Type) GetDMSAR() uint32 {
	return volatile.LoadUint32(&o.DMSAR.Reg)
}

// DMAC0.DMDAR: DMA Destination Address Register
func (o *DMAC0_Type) SetDMDAR(value uint32) {
	volatile.StoreUint32(&o.DMDAR.Reg, value)
}
func (o *DMAC0_Type) GetDMDAR() uint32 {
	return volatile.LoadUint32(&o.DMDAR.Reg)
}

// DMAC0.DMCRA: DMA Transfer Count Register
func (o *DMAC0_Type) SetDMCRA_Reserved(value uint32) {
	volatile.StoreUint32(&o.DMCRA.Reg, volatile.LoadUint32(&o.DMCRA.Reg)&^(0xfc000000)|value<<26)
}
func (o *DMAC0_Type) GetDMCRA_Reserved() uint32 {
	return (volatile.LoadUint32(&o.DMCRA.Reg) & 0xfc000000) >> 26
}
func (o *DMAC0_Type) SetDMCRA_DMCRAH(value uint32) {
	volatile.StoreUint32(&o.DMCRA.Reg, volatile.LoadUint32(&o.DMCRA.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC0_Type) GetDMCRA_DMCRAH() uint32 {
	return (volatile.LoadUint32(&o.DMCRA.Reg) & 0x3ff0000) >> 16
}
func (o *DMAC0_Type) SetDMCRA_DMCRAL(value uint32) {
	volatile.StoreUint32(&o.DMCRA.Reg, volatile.LoadUint32(&o.DMCRA.Reg)&^(0xffff)|value)
}
func (o *DMAC0_Type) GetDMCRA_DMCRAL() uint32 {
	return volatile.LoadUint32(&o.DMCRA.Reg) & 0xffff
}

// DMAC0.DMCRB: DMA Block Transfer Count Register
func (o *DMAC0_Type) SetDMCRB(value uint16) {
	volatile.StoreUint16(&o.DMCRB.Reg, value)
}
func (o *DMAC0_Type) GetDMCRB() uint16 {
	return volatile.LoadUint16(&o.DMCRB.Reg)
}

// DMAC0.DMTMD: DMA Transfer Mode Register
func (o *DMAC0_Type) SetDMTMD_MD(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC0_Type) GetDMTMD_MD() uint16 {
	return (volatile.LoadUint16(&o.DMTMD.Reg) & 0xc000) >> 14
}
func (o *DMAC0_Type) SetDMTMD_DTS(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0x3000)|value<<12)
}
func (o *DMAC0_Type) GetDMTMD_DTS() uint16 {
	return (volatile.LoadUint16(&o.DMTMD.Reg) & 0x3000) >> 12
}
func (o *DMAC0_Type) SetDMTMD_Reserved(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC0_Type) GetDMTMD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DMTMD.Reg) & 0xc00) >> 10
}
func (o *DMAC0_Type) SetDMTMD_SZ(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0x300)|value<<8)
}
func (o *DMAC0_Type) GetDMTMD_SZ() uint16 {
	return (volatile.LoadUint16(&o.DMTMD.Reg) & 0x300) >> 8
}
func (o *DMAC0_Type) SetDMTMD_Reserved(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0xfc)|value<<2)
}
func (o *DMAC0_Type) GetDMTMD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DMTMD.Reg) & 0xfc) >> 2
}
func (o *DMAC0_Type) SetDMTMD_DCTG(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0x3)|value)
}
func (o *DMAC0_Type) GetDMTMD_DCTG() uint16 {
	return volatile.LoadUint16(&o.DMTMD.Reg) & 0x3
}

// DMAC0.DMINT: DMA Interrupt Setting Register
func (o *DMAC0_Type) SetDMINT_Reserved(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0xe0)|value<<5)
}
func (o *DMAC0_Type) GetDMINT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DMINT.Reg) & 0xe0) >> 5
}
func (o *DMAC0_Type) SetDMINT_DTIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x10)|value<<4)
}
func (o *DMAC0_Type) GetDMINT_DTIE() uint8 {
	return (volatile.LoadUint8(&o.DMINT.Reg) & 0x10) >> 4
}
func (o *DMAC0_Type) SetDMINT_ESIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x8)|value<<3)
}
func (o *DMAC0_Type) GetDMINT_ESIE() uint8 {
	return (volatile.LoadUint8(&o.DMINT.Reg) & 0x8) >> 3
}
func (o *DMAC0_Type) SetDMINT_RPTIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x4)|value<<2)
}
func (o *DMAC0_Type) GetDMINT_RPTIE() uint8 {
	return (volatile.LoadUint8(&o.DMINT.Reg) & 0x4) >> 2
}
func (o *DMAC0_Type) SetDMINT_SARIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x2)|value<<1)
}
func (o *DMAC0_Type) GetDMINT_SARIE() uint8 {
	return (volatile.LoadUint8(&o.DMINT.Reg) & 0x2) >> 1
}
func (o *DMAC0_Type) SetDMINT_DARIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x1)|value)
}
func (o *DMAC0_Type) GetDMINT_DARIE() uint8 {
	return volatile.LoadUint8(&o.DMINT.Reg) & 0x1
}

// DMAC0.DMAMD: DMA Address Mode Register
func (o *DMAC0_Type) SetDMAMD_SM(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC0_Type) GetDMAMD_SM() uint16 {
	return (volatile.LoadUint16(&o.DMAMD.Reg) & 0xc000) >> 14
}
func (o *DMAC0_Type) SetDMAMD_Reserved(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC0_Type) GetDMAMD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DMAMD.Reg) & 0x2000) >> 13
}
func (o *DMAC0_Type) SetDMAMD_SARA(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0x1f00)|value<<8)
}
func (o *DMAC0_Type) GetDMAMD_SARA() uint16 {
	return (volatile.LoadUint16(&o.DMAMD.Reg) & 0x1f00) >> 8
}
func (o *DMAC0_Type) SetDMAMD_DM(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0xc0)|value<<6)
}
func (o *DMAC0_Type) GetDMAMD_DM() uint16 {
	return (volatile.LoadUint16(&o.DMAMD.Reg) & 0xc0) >> 6
}
func (o *DMAC0_Type) SetDMAMD_Reserved(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0x20)|value<<5)
}
func (o *DMAC0_Type) GetDMAMD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DMAMD.Reg) & 0x20) >> 5
}
func (o *DMAC0_Type) SetDMAMD_DARA(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0x1f)|value)
}
func (o *DMAC0_Type) GetDMAMD_DARA() uint16 {
	return volatile.LoadUint16(&o.DMAMD.Reg) & 0x1f
}

// DMAC0.DMOFR: DMA Offset Register
func (o *DMAC0_Type) SetDMOFR(value uint32) {
	volatile.StoreUint32(&o.DMOFR.Reg, value)
}
func (o *DMAC0_Type) GetDMOFR() uint32 {
	return volatile.LoadUint32(&o.DMOFR.Reg)
}

// DMAC0.DMCNT: DMA Transfer Enable Register
func (o *DMAC0_Type) SetDMCNT_Reserved(value uint8) {
	volatile.StoreUint8(&o.DMCNT.Reg, volatile.LoadUint8(&o.DMCNT.Reg)&^(0xfe)|value<<1)
}
func (o *DMAC0_Type) GetDMCNT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DMCNT.Reg) & 0xfe) >> 1
}
func (o *DMAC0_Type) SetDMCNT_DTE(value uint8) {
	volatile.StoreUint8(&o.DMCNT.Reg, volatile.LoadUint8(&o.DMCNT.Reg)&^(0x1)|value)
}
func (o *DMAC0_Type) GetDMCNT_DTE() uint8 {
	return volatile.LoadUint8(&o.DMCNT.Reg) & 0x1
}

// DMAC0.DMREQ: DMA Software Start Register
func (o *DMAC0_Type) SetDMREQ_Reserved(value uint8) {
	volatile.StoreUint8(&o.DMREQ.Reg, volatile.LoadUint8(&o.DMREQ.Reg)&^(0xe0)|value<<5)
}
func (o *DMAC0_Type) GetDMREQ_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DMREQ.Reg) & 0xe0) >> 5
}
func (o *DMAC0_Type) SetDMREQ_CLRS(value uint8) {
	volatile.StoreUint8(&o.DMREQ.Reg, volatile.LoadUint8(&o.DMREQ.Reg)&^(0x10)|value<<4)
}
func (o *DMAC0_Type) GetDMREQ_CLRS() uint8 {
	return (volatile.LoadUint8(&o.DMREQ.Reg) & 0x10) >> 4
}
func (o *DMAC0_Type) SetDMREQ_Reserved(value uint8) {
	volatile.StoreUint8(&o.DMREQ.Reg, volatile.LoadUint8(&o.DMREQ.Reg)&^(0xe)|value<<1)
}
func (o *DMAC0_Type) GetDMREQ_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DMREQ.Reg) & 0xe) >> 1
}
func (o *DMAC0_Type) SetDMREQ_SWREQ(value uint8) {
	volatile.StoreUint8(&o.DMREQ.Reg, volatile.LoadUint8(&o.DMREQ.Reg)&^(0x1)|value)
}
func (o *DMAC0_Type) GetDMREQ_SWREQ() uint8 {
	return volatile.LoadUint8(&o.DMREQ.Reg) & 0x1
}

// DMAC0.DMSTS: DMA Status Register
func (o *DMAC0_Type) SetDMSTS_ACT(value uint8) {
	volatile.StoreUint8(&o.DMSTS.Reg, volatile.LoadUint8(&o.DMSTS.Reg)&^(0x80)|value<<7)
}
func (o *DMAC0_Type) GetDMSTS_ACT() uint8 {
	return (volatile.LoadUint8(&o.DMSTS.Reg) & 0x80) >> 7
}
func (o *DMAC0_Type) SetDMSTS_Reserved(value uint8) {
	volatile.StoreUint8(&o.DMSTS.Reg, volatile.LoadUint8(&o.DMSTS.Reg)&^(0x60)|value<<5)
}
func (o *DMAC0_Type) GetDMSTS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DMSTS.Reg) & 0x60) >> 5
}
func (o *DMAC0_Type) SetDMSTS_DTIF(value uint8) {
	volatile.StoreUint8(&o.DMSTS.Reg, volatile.LoadUint8(&o.DMSTS.Reg)&^(0x10)|value<<4)
}
func (o *DMAC0_Type) GetDMSTS_DTIF() uint8 {
	return (volatile.LoadUint8(&o.DMSTS.Reg) & 0x10) >> 4
}
func (o *DMAC0_Type) SetDMSTS_Reserved(value uint8) {
	volatile.StoreUint8(&o.DMSTS.Reg, volatile.LoadUint8(&o.DMSTS.Reg)&^(0xe)|value<<1)
}
func (o *DMAC0_Type) GetDMSTS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DMSTS.Reg) & 0xe) >> 1
}
func (o *DMAC0_Type) SetDMSTS_ESIF(value uint8) {
	volatile.StoreUint8(&o.DMSTS.Reg, volatile.LoadUint8(&o.DMSTS.Reg)&^(0x1)|value)
}
func (o *DMAC0_Type) GetDMSTS_ESIF() uint8 {
	return volatile.LoadUint8(&o.DMSTS.Reg) & 0x1
}

// DMAC Module Activation
type DMA_Type struct {
	DMAST volatile.Register8 // 0x0
}

// DMA.DMAST: DMAC Module Activation Register
func (o *DMA_Type) SetDMAST_Reserved(value uint8) {
	volatile.StoreUint8(&o.DMAST.Reg, volatile.LoadUint8(&o.DMAST.Reg)&^(0xfe)|value<<1)
}
func (o *DMA_Type) GetDMAST_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DMAST.Reg) & 0xfe) >> 1
}
func (o *DMA_Type) SetDMAST_DMST(value uint8) {
	volatile.StoreUint8(&o.DMAST.Reg, volatile.LoadUint8(&o.DMAST.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetDMAST_DMST() uint8 {
	return volatile.LoadUint8(&o.DMAST.Reg) & 0x1
}

// Debug Function
type DBG_Type struct {
	DBGSTR    volatile.Register32 // 0x0
	_         [12]byte
	DBGSTOPCR volatile.Register32 // 0x10
	_         [12]byte
	TRACECTR  volatile.Register32 // 0x20
}

// DBG.DBGSTR: Debug Status Register
func (o *DBG_Type) SetDBGSTR_Reserved(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0xc0000000)|value<<30)
}
func (o *DBG_Type) GetDBGSTR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.DBGSTR.Reg) & 0xc0000000) >> 30
}
func (o *DBG_Type) SetDBGSTR_CDBGPWRUPACK(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0x20000000)|value<<29)
}
func (o *DBG_Type) GetDBGSTR_CDBGPWRUPACK() uint32 {
	return (volatile.LoadUint32(&o.DBGSTR.Reg) & 0x20000000) >> 29
}
func (o *DBG_Type) SetDBGSTR_CDBGPWRUPREQ(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0x10000000)|value<<28)
}
func (o *DBG_Type) GetDBGSTR_CDBGPWRUPREQ() uint32 {
	return (volatile.LoadUint32(&o.DBGSTR.Reg) & 0x10000000) >> 28
}
func (o *DBG_Type) SetDBGSTR_Reserved(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0xfffffff)|value)
}
func (o *DBG_Type) GetDBGSTR_Reserved() uint32 {
	return volatile.LoadUint32(&o.DBGSTR.Reg) & 0xfffffff
}

// DBG.DBGSTOPCR: Debug Stop Control Register
func (o *DBG_Type) SetDBGSTOPCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0xfc000000)|value<<26)
}
func (o *DBG_Type) GetDBGSTOPCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0xfc000000) >> 26
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_RECCR(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x2000000)|value<<25)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_RECCR() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x2000000) >> 25
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_RPER(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_RPER() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x1000000) >> 24
}
func (o *DBG_Type) SetDBGSTOPCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0xf80000)|value<<19)
}
func (o *DBG_Type) GetDBGSTOPCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0xf80000) >> 19
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_LVD(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x70000)|value<<16)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_LVD() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x70000) >> 16
}
func (o *DBG_Type) SetDBGSTOPCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0xfffc)|value<<2)
}
func (o *DBG_Type) GetDBGSTOPCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0xfffc) >> 2
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_WDT(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x2)|value<<1)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_WDT() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x2) >> 1
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_IWDT(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x1)|value)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_IWDT() uint32 {
	return volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x1
}

// DBG.TRACECTR: Trace Control Register
func (o *DBG_Type) SetTRACECTR_ENETBFULL(value uint32) {
	volatile.StoreUint32(&o.TRACECTR.Reg, volatile.LoadUint32(&o.TRACECTR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBG_Type) GetTRACECTR_ENETBFULL() uint32 {
	return (volatile.LoadUint32(&o.TRACECTR.Reg) & 0x80000000) >> 31
}
func (o *DBG_Type) SetTRACECTR_Reserved(value uint32) {
	volatile.StoreUint32(&o.TRACECTR.Reg, volatile.LoadUint32(&o.TRACECTR.Reg)&^(0x7fffffff)|value)
}
func (o *DBG_Type) GetTRACECTR_Reserved() uint32 {
	return volatile.LoadUint32(&o.TRACECTR.Reg) & 0x7fffffff
}

// BUS Control
type BUS_Type struct {
	_           [2]byte
	CS0MOD      volatile.Register16 // 0x2
	CS0WCR1     volatile.Register32 // 0x4
	CS0WCR2     volatile.Register32 // 0x8
	_           [6]byte
	CS1MOD      volatile.Register16 // 0x12
	CS1WCR1     volatile.Register32 // 0x14
	CS1WCR2     volatile.Register32 // 0x18
	_           [6]byte
	CS2MOD      volatile.Register16 // 0x22
	CS2WCR1     volatile.Register32 // 0x24
	CS2WCR2     volatile.Register32 // 0x28
	_           [6]byte
	CS3MOD      volatile.Register16 // 0x32
	CS3WCR1     volatile.Register32 // 0x34
	CS3WCR2     volatile.Register32 // 0x38
	_           [1990]byte
	CS0CR       volatile.Register16 // 0x802
	_           [6]byte
	CS0REC      volatile.Register16 // 0x80A
	_           [6]byte
	CS1CR       volatile.Register16 // 0x812
	_           [6]byte
	CS1REC      volatile.Register16 // 0x81A
	_           [6]byte
	CS2CR       volatile.Register16 // 0x822
	_           [6]byte
	CS2REC      volatile.Register16 // 0x82A
	_           [6]byte
	CS3CR       volatile.Register16 // 0x832
	_           [6]byte
	CS3REC      volatile.Register16 // 0x83A
	_           [68]byte
	CSRECEN     volatile.Register16 // 0x880
	_           [1918]byte
	BUSMCNTM4I  volatile.Register16 // 0x1000
	_           [2]byte
	BUSMCNTM4D  volatile.Register16 // 0x1004
	_           [2]byte
	BUSMCNTSYS  volatile.Register16 // 0x1008
	_           [2]byte
	BUSMCNTDMA  volatile.Register16 // 0x100C
	_           [242]byte
	BUSSCNTFLI  volatile.Register16 // 0x1100
	_           [6]byte
	BUSSCNTMBIU volatile.Register16 // 0x1108
	_           [2]byte
	BUSSCNTRAM0 volatile.Register16 // 0x110C
	_           [6]byte
	BUSSCNTP0B  volatile.Register16 // 0x1114
	_           [2]byte
	BUSSCNTP2B  volatile.Register16 // 0x1118
	_           [2]byte
	BUSSCNTP3B  volatile.Register16 // 0x111C
	_           [2]byte
	BUSSCNTP4B  volatile.Register16 // 0x1120
	_           [6]byte
	BUSSCNTP6B  volatile.Register16 // 0x1128
	_           [6]byte
	BUSSCNTFBU  volatile.Register16 // 0x1130
	_           [2]byte
	BUSSCNTEXT  volatile.Register16 // 0x1134
	_           [2]byte
	BUSSCNTEXT2 volatile.Register16 // 0x1138
	_           [1734]byte
	BUS1ERRADD  volatile.Register32 // 0x1800
	BUS1ERRSTAT volatile.Register8  // 0x1804
	_           [11]byte
	BUS2ERRADD  volatile.Register32 // 0x1810
	BUS2ERRSTAT volatile.Register8  // 0x1814
	_           [11]byte
	BUS3ERRADD  volatile.Register32 // 0x1820
	BUS3ERRSTAT volatile.Register8  // 0x1824
	_           [11]byte
	BUS4ERRADD  volatile.Register32 // 0x1830
	BUS4ERRSTAT volatile.Register8  // 0x1834
}

// BUS.CS0MOD: CS%s Mode Register
func (o *BUS_Type) SetCS0MOD_PRDMOD(value uint16) {
	volatile.StoreUint16(&o.CS0MOD.Reg, volatile.LoadUint16(&o.CS0MOD.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCS0MOD_PRDMOD() uint16 {
	return (volatile.LoadUint16(&o.CS0MOD.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCS0MOD_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS0MOD.Reg, volatile.LoadUint16(&o.CS0MOD.Reg)&^(0x7c00)|value<<10)
}
func (o *BUS_Type) GetCS0MOD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS0MOD.Reg) & 0x7c00) >> 10
}
func (o *BUS_Type) SetCS0MOD_PWENB(value uint16) {
	volatile.StoreUint16(&o.CS0MOD.Reg, volatile.LoadUint16(&o.CS0MOD.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCS0MOD_PWENB() uint16 {
	return (volatile.LoadUint16(&o.CS0MOD.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCS0MOD_PRENB(value uint16) {
	volatile.StoreUint16(&o.CS0MOD.Reg, volatile.LoadUint16(&o.CS0MOD.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS0MOD_PRENB() uint16 {
	return (volatile.LoadUint16(&o.CS0MOD.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS0MOD_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS0MOD.Reg, volatile.LoadUint16(&o.CS0MOD.Reg)&^(0xf0)|value<<4)
}
func (o *BUS_Type) GetCS0MOD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS0MOD.Reg) & 0xf0) >> 4
}
func (o *BUS_Type) SetCS0MOD_EWENB(value uint16) {
	volatile.StoreUint16(&o.CS0MOD.Reg, volatile.LoadUint16(&o.CS0MOD.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS0MOD_EWENB() uint16 {
	return (volatile.LoadUint16(&o.CS0MOD.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS0MOD_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS0MOD.Reg, volatile.LoadUint16(&o.CS0MOD.Reg)&^(0x6)|value<<1)
}
func (o *BUS_Type) GetCS0MOD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS0MOD.Reg) & 0x6) >> 1
}
func (o *BUS_Type) SetCS0MOD_WRMOD(value uint16) {
	volatile.StoreUint16(&o.CS0MOD.Reg, volatile.LoadUint16(&o.CS0MOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS0MOD_WRMOD() uint16 {
	return volatile.LoadUint16(&o.CS0MOD.Reg) & 0x1
}

// BUS.CS0WCR1: CS%s Wait Control Register 1
func (o *BUS_Type) SetCS0WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS0WCR1.Reg, volatile.LoadUint32(&o.CS0WCR1.Reg)&^(0xe0000000)|value<<29)
}
func (o *BUS_Type) GetCS0WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR1.Reg) & 0xe0000000) >> 29
}
func (o *BUS_Type) SetCS0WCR1_CSRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS0WCR1.Reg, volatile.LoadUint32(&o.CS0WCR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *BUS_Type) GetCS0WCR1_CSRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR1.Reg) & 0x1f000000) >> 24
}
func (o *BUS_Type) SetCS0WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS0WCR1.Reg, volatile.LoadUint32(&o.CS0WCR1.Reg)&^(0xe00000)|value<<21)
}
func (o *BUS_Type) GetCS0WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR1.Reg) & 0xe00000) >> 21
}
func (o *BUS_Type) SetCS0WCR1_CSWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS0WCR1.Reg, volatile.LoadUint32(&o.CS0WCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *BUS_Type) GetCS0WCR1_CSWWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR1.Reg) & 0x1f0000) >> 16
}
func (o *BUS_Type) SetCS0WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS0WCR1.Reg, volatile.LoadUint32(&o.CS0WCR1.Reg)&^(0xf800)|value<<11)
}
func (o *BUS_Type) GetCS0WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR1.Reg) & 0xf800) >> 11
}
func (o *BUS_Type) SetCS0WCR1_CSPRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS0WCR1.Reg, volatile.LoadUint32(&o.CS0WCR1.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS0WCR1_CSPRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR1.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS0WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS0WCR1.Reg, volatile.LoadUint32(&o.CS0WCR1.Reg)&^(0xf8)|value<<3)
}
func (o *BUS_Type) GetCS0WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR1.Reg) & 0xf8) >> 3
}
func (o *BUS_Type) SetCS0WCR1_CSPWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS0WCR1.Reg, volatile.LoadUint32(&o.CS0WCR1.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS0WCR1_CSPWWAIT() uint32 {
	return volatile.LoadUint32(&o.CS0WCR1.Reg) & 0x7
}

// BUS.CS0WCR2: CS%s Wait Control Register 2
func (o *BUS_Type) SetCS0WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x80000000)|value<<31)
}
func (o *BUS_Type) GetCS0WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x80000000) >> 31
}
func (o *BUS_Type) SetCS0WCR2_CSON(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x70000000)|value<<28)
}
func (o *BUS_Type) GetCS0WCR2_CSON() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x70000000) >> 28
}
func (o *BUS_Type) SetCS0WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x8000000)|value<<27)
}
func (o *BUS_Type) GetCS0WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x8000000) >> 27
}
func (o *BUS_Type) SetCS0WCR2_WDON(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x7000000)|value<<24)
}
func (o *BUS_Type) GetCS0WCR2_WDON() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x7000000) >> 24
}
func (o *BUS_Type) SetCS0WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x800000)|value<<23)
}
func (o *BUS_Type) GetCS0WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x800000) >> 23
}
func (o *BUS_Type) SetCS0WCR2_WRON(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x700000)|value<<20)
}
func (o *BUS_Type) GetCS0WCR2_WRON() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x700000) >> 20
}
func (o *BUS_Type) SetCS0WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x80000)|value<<19)
}
func (o *BUS_Type) GetCS0WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x80000) >> 19
}
func (o *BUS_Type) SetCS0WCR2_RDON(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x70000)|value<<16)
}
func (o *BUS_Type) GetCS0WCR2_RDON() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x70000) >> 16
}
func (o *BUS_Type) SetCS0WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0xc000)|value<<14)
}
func (o *BUS_Type) GetCS0WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0xc000) >> 14
}
func (o *BUS_Type) SetCS0WCR2_AWAIT(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x3000)|value<<12)
}
func (o *BUS_Type) GetCS0WCR2_AWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x3000) >> 12
}
func (o *BUS_Type) SetCS0WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x800)|value<<11)
}
func (o *BUS_Type) GetCS0WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x800) >> 11
}
func (o *BUS_Type) SetCS0WCR2_WDOFF(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS0WCR2_WDOFF() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS0WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetCS0WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetCS0WCR2_CSWOFF(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x70)|value<<4)
}
func (o *BUS_Type) GetCS0WCR2_CSWOFF() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x70) >> 4
}
func (o *BUS_Type) SetCS0WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS0WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS0WCR2_CSROFF(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS0WCR2_CSROFF() uint32 {
	return volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x7
}

// BUS.CS1MOD: CS%s Mode Register
func (o *BUS_Type) SetCS1MOD_PRDMOD(value uint16) {
	volatile.StoreUint16(&o.CS1MOD.Reg, volatile.LoadUint16(&o.CS1MOD.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCS1MOD_PRDMOD() uint16 {
	return (volatile.LoadUint16(&o.CS1MOD.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCS1MOD_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS1MOD.Reg, volatile.LoadUint16(&o.CS1MOD.Reg)&^(0x7c00)|value<<10)
}
func (o *BUS_Type) GetCS1MOD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS1MOD.Reg) & 0x7c00) >> 10
}
func (o *BUS_Type) SetCS1MOD_PWENB(value uint16) {
	volatile.StoreUint16(&o.CS1MOD.Reg, volatile.LoadUint16(&o.CS1MOD.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCS1MOD_PWENB() uint16 {
	return (volatile.LoadUint16(&o.CS1MOD.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCS1MOD_PRENB(value uint16) {
	volatile.StoreUint16(&o.CS1MOD.Reg, volatile.LoadUint16(&o.CS1MOD.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS1MOD_PRENB() uint16 {
	return (volatile.LoadUint16(&o.CS1MOD.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS1MOD_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS1MOD.Reg, volatile.LoadUint16(&o.CS1MOD.Reg)&^(0xf0)|value<<4)
}
func (o *BUS_Type) GetCS1MOD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS1MOD.Reg) & 0xf0) >> 4
}
func (o *BUS_Type) SetCS1MOD_EWENB(value uint16) {
	volatile.StoreUint16(&o.CS1MOD.Reg, volatile.LoadUint16(&o.CS1MOD.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS1MOD_EWENB() uint16 {
	return (volatile.LoadUint16(&o.CS1MOD.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS1MOD_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS1MOD.Reg, volatile.LoadUint16(&o.CS1MOD.Reg)&^(0x6)|value<<1)
}
func (o *BUS_Type) GetCS1MOD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS1MOD.Reg) & 0x6) >> 1
}
func (o *BUS_Type) SetCS1MOD_WRMOD(value uint16) {
	volatile.StoreUint16(&o.CS1MOD.Reg, volatile.LoadUint16(&o.CS1MOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS1MOD_WRMOD() uint16 {
	return volatile.LoadUint16(&o.CS1MOD.Reg) & 0x1
}

// BUS.CS1WCR1: CS%s Wait Control Register 1
func (o *BUS_Type) SetCS1WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS1WCR1.Reg, volatile.LoadUint32(&o.CS1WCR1.Reg)&^(0xe0000000)|value<<29)
}
func (o *BUS_Type) GetCS1WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR1.Reg) & 0xe0000000) >> 29
}
func (o *BUS_Type) SetCS1WCR1_CSRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS1WCR1.Reg, volatile.LoadUint32(&o.CS1WCR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *BUS_Type) GetCS1WCR1_CSRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR1.Reg) & 0x1f000000) >> 24
}
func (o *BUS_Type) SetCS1WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS1WCR1.Reg, volatile.LoadUint32(&o.CS1WCR1.Reg)&^(0xe00000)|value<<21)
}
func (o *BUS_Type) GetCS1WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR1.Reg) & 0xe00000) >> 21
}
func (o *BUS_Type) SetCS1WCR1_CSWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS1WCR1.Reg, volatile.LoadUint32(&o.CS1WCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *BUS_Type) GetCS1WCR1_CSWWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR1.Reg) & 0x1f0000) >> 16
}
func (o *BUS_Type) SetCS1WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS1WCR1.Reg, volatile.LoadUint32(&o.CS1WCR1.Reg)&^(0xf800)|value<<11)
}
func (o *BUS_Type) GetCS1WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR1.Reg) & 0xf800) >> 11
}
func (o *BUS_Type) SetCS1WCR1_CSPRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS1WCR1.Reg, volatile.LoadUint32(&o.CS1WCR1.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS1WCR1_CSPRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR1.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS1WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS1WCR1.Reg, volatile.LoadUint32(&o.CS1WCR1.Reg)&^(0xf8)|value<<3)
}
func (o *BUS_Type) GetCS1WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR1.Reg) & 0xf8) >> 3
}
func (o *BUS_Type) SetCS1WCR1_CSPWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS1WCR1.Reg, volatile.LoadUint32(&o.CS1WCR1.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS1WCR1_CSPWWAIT() uint32 {
	return volatile.LoadUint32(&o.CS1WCR1.Reg) & 0x7
}

// BUS.CS1WCR2: CS%s Wait Control Register 2
func (o *BUS_Type) SetCS1WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x80000000)|value<<31)
}
func (o *BUS_Type) GetCS1WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x80000000) >> 31
}
func (o *BUS_Type) SetCS1WCR2_CSON(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x70000000)|value<<28)
}
func (o *BUS_Type) GetCS1WCR2_CSON() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x70000000) >> 28
}
func (o *BUS_Type) SetCS1WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x8000000)|value<<27)
}
func (o *BUS_Type) GetCS1WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x8000000) >> 27
}
func (o *BUS_Type) SetCS1WCR2_WDON(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x7000000)|value<<24)
}
func (o *BUS_Type) GetCS1WCR2_WDON() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x7000000) >> 24
}
func (o *BUS_Type) SetCS1WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x800000)|value<<23)
}
func (o *BUS_Type) GetCS1WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x800000) >> 23
}
func (o *BUS_Type) SetCS1WCR2_WRON(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x700000)|value<<20)
}
func (o *BUS_Type) GetCS1WCR2_WRON() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x700000) >> 20
}
func (o *BUS_Type) SetCS1WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x80000)|value<<19)
}
func (o *BUS_Type) GetCS1WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x80000) >> 19
}
func (o *BUS_Type) SetCS1WCR2_RDON(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x70000)|value<<16)
}
func (o *BUS_Type) GetCS1WCR2_RDON() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x70000) >> 16
}
func (o *BUS_Type) SetCS1WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0xc000)|value<<14)
}
func (o *BUS_Type) GetCS1WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0xc000) >> 14
}
func (o *BUS_Type) SetCS1WCR2_AWAIT(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x3000)|value<<12)
}
func (o *BUS_Type) GetCS1WCR2_AWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x3000) >> 12
}
func (o *BUS_Type) SetCS1WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x800)|value<<11)
}
func (o *BUS_Type) GetCS1WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x800) >> 11
}
func (o *BUS_Type) SetCS1WCR2_WDOFF(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS1WCR2_WDOFF() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS1WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetCS1WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetCS1WCR2_CSWOFF(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x70)|value<<4)
}
func (o *BUS_Type) GetCS1WCR2_CSWOFF() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x70) >> 4
}
func (o *BUS_Type) SetCS1WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS1WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS1WCR2_CSROFF(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS1WCR2_CSROFF() uint32 {
	return volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x7
}

// BUS.CS2MOD: CS%s Mode Register
func (o *BUS_Type) SetCS2MOD_PRDMOD(value uint16) {
	volatile.StoreUint16(&o.CS2MOD.Reg, volatile.LoadUint16(&o.CS2MOD.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCS2MOD_PRDMOD() uint16 {
	return (volatile.LoadUint16(&o.CS2MOD.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCS2MOD_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS2MOD.Reg, volatile.LoadUint16(&o.CS2MOD.Reg)&^(0x7c00)|value<<10)
}
func (o *BUS_Type) GetCS2MOD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS2MOD.Reg) & 0x7c00) >> 10
}
func (o *BUS_Type) SetCS2MOD_PWENB(value uint16) {
	volatile.StoreUint16(&o.CS2MOD.Reg, volatile.LoadUint16(&o.CS2MOD.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCS2MOD_PWENB() uint16 {
	return (volatile.LoadUint16(&o.CS2MOD.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCS2MOD_PRENB(value uint16) {
	volatile.StoreUint16(&o.CS2MOD.Reg, volatile.LoadUint16(&o.CS2MOD.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS2MOD_PRENB() uint16 {
	return (volatile.LoadUint16(&o.CS2MOD.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS2MOD_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS2MOD.Reg, volatile.LoadUint16(&o.CS2MOD.Reg)&^(0xf0)|value<<4)
}
func (o *BUS_Type) GetCS2MOD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS2MOD.Reg) & 0xf0) >> 4
}
func (o *BUS_Type) SetCS2MOD_EWENB(value uint16) {
	volatile.StoreUint16(&o.CS2MOD.Reg, volatile.LoadUint16(&o.CS2MOD.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS2MOD_EWENB() uint16 {
	return (volatile.LoadUint16(&o.CS2MOD.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS2MOD_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS2MOD.Reg, volatile.LoadUint16(&o.CS2MOD.Reg)&^(0x6)|value<<1)
}
func (o *BUS_Type) GetCS2MOD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS2MOD.Reg) & 0x6) >> 1
}
func (o *BUS_Type) SetCS2MOD_WRMOD(value uint16) {
	volatile.StoreUint16(&o.CS2MOD.Reg, volatile.LoadUint16(&o.CS2MOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS2MOD_WRMOD() uint16 {
	return volatile.LoadUint16(&o.CS2MOD.Reg) & 0x1
}

// BUS.CS2WCR1: CS%s Wait Control Register 1
func (o *BUS_Type) SetCS2WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS2WCR1.Reg, volatile.LoadUint32(&o.CS2WCR1.Reg)&^(0xe0000000)|value<<29)
}
func (o *BUS_Type) GetCS2WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR1.Reg) & 0xe0000000) >> 29
}
func (o *BUS_Type) SetCS2WCR1_CSRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS2WCR1.Reg, volatile.LoadUint32(&o.CS2WCR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *BUS_Type) GetCS2WCR1_CSRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR1.Reg) & 0x1f000000) >> 24
}
func (o *BUS_Type) SetCS2WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS2WCR1.Reg, volatile.LoadUint32(&o.CS2WCR1.Reg)&^(0xe00000)|value<<21)
}
func (o *BUS_Type) GetCS2WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR1.Reg) & 0xe00000) >> 21
}
func (o *BUS_Type) SetCS2WCR1_CSWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS2WCR1.Reg, volatile.LoadUint32(&o.CS2WCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *BUS_Type) GetCS2WCR1_CSWWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR1.Reg) & 0x1f0000) >> 16
}
func (o *BUS_Type) SetCS2WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS2WCR1.Reg, volatile.LoadUint32(&o.CS2WCR1.Reg)&^(0xf800)|value<<11)
}
func (o *BUS_Type) GetCS2WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR1.Reg) & 0xf800) >> 11
}
func (o *BUS_Type) SetCS2WCR1_CSPRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS2WCR1.Reg, volatile.LoadUint32(&o.CS2WCR1.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS2WCR1_CSPRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR1.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS2WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS2WCR1.Reg, volatile.LoadUint32(&o.CS2WCR1.Reg)&^(0xf8)|value<<3)
}
func (o *BUS_Type) GetCS2WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR1.Reg) & 0xf8) >> 3
}
func (o *BUS_Type) SetCS2WCR1_CSPWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS2WCR1.Reg, volatile.LoadUint32(&o.CS2WCR1.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS2WCR1_CSPWWAIT() uint32 {
	return volatile.LoadUint32(&o.CS2WCR1.Reg) & 0x7
}

// BUS.CS2WCR2: CS%s Wait Control Register 2
func (o *BUS_Type) SetCS2WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x80000000)|value<<31)
}
func (o *BUS_Type) GetCS2WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x80000000) >> 31
}
func (o *BUS_Type) SetCS2WCR2_CSON(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x70000000)|value<<28)
}
func (o *BUS_Type) GetCS2WCR2_CSON() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x70000000) >> 28
}
func (o *BUS_Type) SetCS2WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x8000000)|value<<27)
}
func (o *BUS_Type) GetCS2WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x8000000) >> 27
}
func (o *BUS_Type) SetCS2WCR2_WDON(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x7000000)|value<<24)
}
func (o *BUS_Type) GetCS2WCR2_WDON() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x7000000) >> 24
}
func (o *BUS_Type) SetCS2WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x800000)|value<<23)
}
func (o *BUS_Type) GetCS2WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x800000) >> 23
}
func (o *BUS_Type) SetCS2WCR2_WRON(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x700000)|value<<20)
}
func (o *BUS_Type) GetCS2WCR2_WRON() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x700000) >> 20
}
func (o *BUS_Type) SetCS2WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x80000)|value<<19)
}
func (o *BUS_Type) GetCS2WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x80000) >> 19
}
func (o *BUS_Type) SetCS2WCR2_RDON(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x70000)|value<<16)
}
func (o *BUS_Type) GetCS2WCR2_RDON() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x70000) >> 16
}
func (o *BUS_Type) SetCS2WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0xc000)|value<<14)
}
func (o *BUS_Type) GetCS2WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0xc000) >> 14
}
func (o *BUS_Type) SetCS2WCR2_AWAIT(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x3000)|value<<12)
}
func (o *BUS_Type) GetCS2WCR2_AWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x3000) >> 12
}
func (o *BUS_Type) SetCS2WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x800)|value<<11)
}
func (o *BUS_Type) GetCS2WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x800) >> 11
}
func (o *BUS_Type) SetCS2WCR2_WDOFF(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS2WCR2_WDOFF() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS2WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetCS2WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetCS2WCR2_CSWOFF(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x70)|value<<4)
}
func (o *BUS_Type) GetCS2WCR2_CSWOFF() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x70) >> 4
}
func (o *BUS_Type) SetCS2WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS2WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS2WCR2_CSROFF(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS2WCR2_CSROFF() uint32 {
	return volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x7
}

// BUS.CS3MOD: CS%s Mode Register
func (o *BUS_Type) SetCS3MOD_PRDMOD(value uint16) {
	volatile.StoreUint16(&o.CS3MOD.Reg, volatile.LoadUint16(&o.CS3MOD.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCS3MOD_PRDMOD() uint16 {
	return (volatile.LoadUint16(&o.CS3MOD.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCS3MOD_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS3MOD.Reg, volatile.LoadUint16(&o.CS3MOD.Reg)&^(0x7c00)|value<<10)
}
func (o *BUS_Type) GetCS3MOD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS3MOD.Reg) & 0x7c00) >> 10
}
func (o *BUS_Type) SetCS3MOD_PWENB(value uint16) {
	volatile.StoreUint16(&o.CS3MOD.Reg, volatile.LoadUint16(&o.CS3MOD.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCS3MOD_PWENB() uint16 {
	return (volatile.LoadUint16(&o.CS3MOD.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCS3MOD_PRENB(value uint16) {
	volatile.StoreUint16(&o.CS3MOD.Reg, volatile.LoadUint16(&o.CS3MOD.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS3MOD_PRENB() uint16 {
	return (volatile.LoadUint16(&o.CS3MOD.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS3MOD_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS3MOD.Reg, volatile.LoadUint16(&o.CS3MOD.Reg)&^(0xf0)|value<<4)
}
func (o *BUS_Type) GetCS3MOD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS3MOD.Reg) & 0xf0) >> 4
}
func (o *BUS_Type) SetCS3MOD_EWENB(value uint16) {
	volatile.StoreUint16(&o.CS3MOD.Reg, volatile.LoadUint16(&o.CS3MOD.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS3MOD_EWENB() uint16 {
	return (volatile.LoadUint16(&o.CS3MOD.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS3MOD_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS3MOD.Reg, volatile.LoadUint16(&o.CS3MOD.Reg)&^(0x6)|value<<1)
}
func (o *BUS_Type) GetCS3MOD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS3MOD.Reg) & 0x6) >> 1
}
func (o *BUS_Type) SetCS3MOD_WRMOD(value uint16) {
	volatile.StoreUint16(&o.CS3MOD.Reg, volatile.LoadUint16(&o.CS3MOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS3MOD_WRMOD() uint16 {
	return volatile.LoadUint16(&o.CS3MOD.Reg) & 0x1
}

// BUS.CS3WCR1: CS%s Wait Control Register 1
func (o *BUS_Type) SetCS3WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS3WCR1.Reg, volatile.LoadUint32(&o.CS3WCR1.Reg)&^(0xe0000000)|value<<29)
}
func (o *BUS_Type) GetCS3WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR1.Reg) & 0xe0000000) >> 29
}
func (o *BUS_Type) SetCS3WCR1_CSRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS3WCR1.Reg, volatile.LoadUint32(&o.CS3WCR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *BUS_Type) GetCS3WCR1_CSRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR1.Reg) & 0x1f000000) >> 24
}
func (o *BUS_Type) SetCS3WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS3WCR1.Reg, volatile.LoadUint32(&o.CS3WCR1.Reg)&^(0xe00000)|value<<21)
}
func (o *BUS_Type) GetCS3WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR1.Reg) & 0xe00000) >> 21
}
func (o *BUS_Type) SetCS3WCR1_CSWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS3WCR1.Reg, volatile.LoadUint32(&o.CS3WCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *BUS_Type) GetCS3WCR1_CSWWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR1.Reg) & 0x1f0000) >> 16
}
func (o *BUS_Type) SetCS3WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS3WCR1.Reg, volatile.LoadUint32(&o.CS3WCR1.Reg)&^(0xf800)|value<<11)
}
func (o *BUS_Type) GetCS3WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR1.Reg) & 0xf800) >> 11
}
func (o *BUS_Type) SetCS3WCR1_CSPRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS3WCR1.Reg, volatile.LoadUint32(&o.CS3WCR1.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS3WCR1_CSPRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR1.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS3WCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS3WCR1.Reg, volatile.LoadUint32(&o.CS3WCR1.Reg)&^(0xf8)|value<<3)
}
func (o *BUS_Type) GetCS3WCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR1.Reg) & 0xf8) >> 3
}
func (o *BUS_Type) SetCS3WCR1_CSPWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS3WCR1.Reg, volatile.LoadUint32(&o.CS3WCR1.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS3WCR1_CSPWWAIT() uint32 {
	return volatile.LoadUint32(&o.CS3WCR1.Reg) & 0x7
}

// BUS.CS3WCR2: CS%s Wait Control Register 2
func (o *BUS_Type) SetCS3WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x80000000)|value<<31)
}
func (o *BUS_Type) GetCS3WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x80000000) >> 31
}
func (o *BUS_Type) SetCS3WCR2_CSON(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x70000000)|value<<28)
}
func (o *BUS_Type) GetCS3WCR2_CSON() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x70000000) >> 28
}
func (o *BUS_Type) SetCS3WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x8000000)|value<<27)
}
func (o *BUS_Type) GetCS3WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x8000000) >> 27
}
func (o *BUS_Type) SetCS3WCR2_WDON(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x7000000)|value<<24)
}
func (o *BUS_Type) GetCS3WCR2_WDON() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x7000000) >> 24
}
func (o *BUS_Type) SetCS3WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x800000)|value<<23)
}
func (o *BUS_Type) GetCS3WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x800000) >> 23
}
func (o *BUS_Type) SetCS3WCR2_WRON(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x700000)|value<<20)
}
func (o *BUS_Type) GetCS3WCR2_WRON() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x700000) >> 20
}
func (o *BUS_Type) SetCS3WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x80000)|value<<19)
}
func (o *BUS_Type) GetCS3WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x80000) >> 19
}
func (o *BUS_Type) SetCS3WCR2_RDON(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x70000)|value<<16)
}
func (o *BUS_Type) GetCS3WCR2_RDON() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x70000) >> 16
}
func (o *BUS_Type) SetCS3WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0xc000)|value<<14)
}
func (o *BUS_Type) GetCS3WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0xc000) >> 14
}
func (o *BUS_Type) SetCS3WCR2_AWAIT(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x3000)|value<<12)
}
func (o *BUS_Type) GetCS3WCR2_AWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x3000) >> 12
}
func (o *BUS_Type) SetCS3WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x800)|value<<11)
}
func (o *BUS_Type) GetCS3WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x800) >> 11
}
func (o *BUS_Type) SetCS3WCR2_WDOFF(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS3WCR2_WDOFF() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS3WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetCS3WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetCS3WCR2_CSWOFF(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x70)|value<<4)
}
func (o *BUS_Type) GetCS3WCR2_CSWOFF() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x70) >> 4
}
func (o *BUS_Type) SetCS3WCR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS3WCR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS3WCR2_CSROFF(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS3WCR2_CSROFF() uint32 {
	return volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x7
}

// BUS.CS0CR: CS0 Control Register
func (o *BUS_Type) SetCS0CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS0CR.Reg, volatile.LoadUint16(&o.CS0CR.Reg)&^(0xe000)|value<<13)
}
func (o *BUS_Type) GetCS0CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS0CR.Reg) & 0xe000) >> 13
}
func (o *BUS_Type) SetCS0CR_MPXEN(value uint16) {
	volatile.StoreUint16(&o.CS0CR.Reg, volatile.LoadUint16(&o.CS0CR.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCS0CR_MPXEN() uint16 {
	return (volatile.LoadUint16(&o.CS0CR.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCS0CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS0CR.Reg, volatile.LoadUint16(&o.CS0CR.Reg)&^(0xe00)|value<<9)
}
func (o *BUS_Type) GetCS0CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS0CR.Reg) & 0xe00) >> 9
}
func (o *BUS_Type) SetCS0CR_EMODE(value uint16) {
	volatile.StoreUint16(&o.CS0CR.Reg, volatile.LoadUint16(&o.CS0CR.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS0CR_EMODE() uint16 {
	return (volatile.LoadUint16(&o.CS0CR.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS0CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS0CR.Reg, volatile.LoadUint16(&o.CS0CR.Reg)&^(0xc0)|value<<6)
}
func (o *BUS_Type) GetCS0CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS0CR.Reg) & 0xc0) >> 6
}
func (o *BUS_Type) SetCS0CR_BSIZE(value uint16) {
	volatile.StoreUint16(&o.CS0CR.Reg, volatile.LoadUint16(&o.CS0CR.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetCS0CR_BSIZE() uint16 {
	return (volatile.LoadUint16(&o.CS0CR.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetCS0CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS0CR.Reg, volatile.LoadUint16(&o.CS0CR.Reg)&^(0xe)|value<<1)
}
func (o *BUS_Type) GetCS0CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS0CR.Reg) & 0xe) >> 1
}
func (o *BUS_Type) SetCS0CR_EXENB(value uint16) {
	volatile.StoreUint16(&o.CS0CR.Reg, volatile.LoadUint16(&o.CS0CR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS0CR_EXENB() uint16 {
	return volatile.LoadUint16(&o.CS0CR.Reg) & 0x1
}

// BUS.CS0REC: CS%s Recovery Cycle Register
func (o *BUS_Type) SetCS0REC_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS0REC.Reg, volatile.LoadUint16(&o.CS0REC.Reg)&^(0xf000)|value<<12)
}
func (o *BUS_Type) GetCS0REC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS0REC.Reg) & 0xf000) >> 12
}
func (o *BUS_Type) SetCS0REC_WRCV(value uint16) {
	volatile.StoreUint16(&o.CS0REC.Reg, volatile.LoadUint16(&o.CS0REC.Reg)&^(0xf00)|value<<8)
}
func (o *BUS_Type) GetCS0REC_WRCV() uint16 {
	return (volatile.LoadUint16(&o.CS0REC.Reg) & 0xf00) >> 8
}
func (o *BUS_Type) SetCS0REC_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS0REC.Reg, volatile.LoadUint16(&o.CS0REC.Reg)&^(0xf0)|value<<4)
}
func (o *BUS_Type) GetCS0REC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS0REC.Reg) & 0xf0) >> 4
}
func (o *BUS_Type) SetCS0REC_RRCV(value uint16) {
	volatile.StoreUint16(&o.CS0REC.Reg, volatile.LoadUint16(&o.CS0REC.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetCS0REC_RRCV() uint16 {
	return volatile.LoadUint16(&o.CS0REC.Reg) & 0xf
}

// BUS.CS1CR: CS%s Control Register
func (o *BUS_Type) SetCS1CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS1CR.Reg, volatile.LoadUint16(&o.CS1CR.Reg)&^(0xe000)|value<<13)
}
func (o *BUS_Type) GetCS1CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS1CR.Reg) & 0xe000) >> 13
}
func (o *BUS_Type) SetCS1CR_MPXEN(value uint16) {
	volatile.StoreUint16(&o.CS1CR.Reg, volatile.LoadUint16(&o.CS1CR.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCS1CR_MPXEN() uint16 {
	return (volatile.LoadUint16(&o.CS1CR.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCS1CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS1CR.Reg, volatile.LoadUint16(&o.CS1CR.Reg)&^(0xe00)|value<<9)
}
func (o *BUS_Type) GetCS1CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS1CR.Reg) & 0xe00) >> 9
}
func (o *BUS_Type) SetCS1CR_EMODE(value uint16) {
	volatile.StoreUint16(&o.CS1CR.Reg, volatile.LoadUint16(&o.CS1CR.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS1CR_EMODE() uint16 {
	return (volatile.LoadUint16(&o.CS1CR.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS1CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS1CR.Reg, volatile.LoadUint16(&o.CS1CR.Reg)&^(0xc0)|value<<6)
}
func (o *BUS_Type) GetCS1CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS1CR.Reg) & 0xc0) >> 6
}
func (o *BUS_Type) SetCS1CR_BSIZE(value uint16) {
	volatile.StoreUint16(&o.CS1CR.Reg, volatile.LoadUint16(&o.CS1CR.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetCS1CR_BSIZE() uint16 {
	return (volatile.LoadUint16(&o.CS1CR.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetCS1CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS1CR.Reg, volatile.LoadUint16(&o.CS1CR.Reg)&^(0xe)|value<<1)
}
func (o *BUS_Type) GetCS1CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS1CR.Reg) & 0xe) >> 1
}
func (o *BUS_Type) SetCS1CR_EXENB(value uint16) {
	volatile.StoreUint16(&o.CS1CR.Reg, volatile.LoadUint16(&o.CS1CR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS1CR_EXENB() uint16 {
	return volatile.LoadUint16(&o.CS1CR.Reg) & 0x1
}

// BUS.CS1REC: CS%s Recovery Cycle Register
func (o *BUS_Type) SetCS1REC_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS1REC.Reg, volatile.LoadUint16(&o.CS1REC.Reg)&^(0xf000)|value<<12)
}
func (o *BUS_Type) GetCS1REC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS1REC.Reg) & 0xf000) >> 12
}
func (o *BUS_Type) SetCS1REC_WRCV(value uint16) {
	volatile.StoreUint16(&o.CS1REC.Reg, volatile.LoadUint16(&o.CS1REC.Reg)&^(0xf00)|value<<8)
}
func (o *BUS_Type) GetCS1REC_WRCV() uint16 {
	return (volatile.LoadUint16(&o.CS1REC.Reg) & 0xf00) >> 8
}
func (o *BUS_Type) SetCS1REC_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS1REC.Reg, volatile.LoadUint16(&o.CS1REC.Reg)&^(0xf0)|value<<4)
}
func (o *BUS_Type) GetCS1REC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS1REC.Reg) & 0xf0) >> 4
}
func (o *BUS_Type) SetCS1REC_RRCV(value uint16) {
	volatile.StoreUint16(&o.CS1REC.Reg, volatile.LoadUint16(&o.CS1REC.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetCS1REC_RRCV() uint16 {
	return volatile.LoadUint16(&o.CS1REC.Reg) & 0xf
}

// BUS.CS2CR: CS%s Control Register
func (o *BUS_Type) SetCS2CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS2CR.Reg, volatile.LoadUint16(&o.CS2CR.Reg)&^(0xe000)|value<<13)
}
func (o *BUS_Type) GetCS2CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS2CR.Reg) & 0xe000) >> 13
}
func (o *BUS_Type) SetCS2CR_MPXEN(value uint16) {
	volatile.StoreUint16(&o.CS2CR.Reg, volatile.LoadUint16(&o.CS2CR.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCS2CR_MPXEN() uint16 {
	return (volatile.LoadUint16(&o.CS2CR.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCS2CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS2CR.Reg, volatile.LoadUint16(&o.CS2CR.Reg)&^(0xe00)|value<<9)
}
func (o *BUS_Type) GetCS2CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS2CR.Reg) & 0xe00) >> 9
}
func (o *BUS_Type) SetCS2CR_EMODE(value uint16) {
	volatile.StoreUint16(&o.CS2CR.Reg, volatile.LoadUint16(&o.CS2CR.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS2CR_EMODE() uint16 {
	return (volatile.LoadUint16(&o.CS2CR.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS2CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS2CR.Reg, volatile.LoadUint16(&o.CS2CR.Reg)&^(0xc0)|value<<6)
}
func (o *BUS_Type) GetCS2CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS2CR.Reg) & 0xc0) >> 6
}
func (o *BUS_Type) SetCS2CR_BSIZE(value uint16) {
	volatile.StoreUint16(&o.CS2CR.Reg, volatile.LoadUint16(&o.CS2CR.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetCS2CR_BSIZE() uint16 {
	return (volatile.LoadUint16(&o.CS2CR.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetCS2CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS2CR.Reg, volatile.LoadUint16(&o.CS2CR.Reg)&^(0xe)|value<<1)
}
func (o *BUS_Type) GetCS2CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS2CR.Reg) & 0xe) >> 1
}
func (o *BUS_Type) SetCS2CR_EXENB(value uint16) {
	volatile.StoreUint16(&o.CS2CR.Reg, volatile.LoadUint16(&o.CS2CR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS2CR_EXENB() uint16 {
	return volatile.LoadUint16(&o.CS2CR.Reg) & 0x1
}

// BUS.CS2REC: CS%s Recovery Cycle Register
func (o *BUS_Type) SetCS2REC_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS2REC.Reg, volatile.LoadUint16(&o.CS2REC.Reg)&^(0xf000)|value<<12)
}
func (o *BUS_Type) GetCS2REC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS2REC.Reg) & 0xf000) >> 12
}
func (o *BUS_Type) SetCS2REC_WRCV(value uint16) {
	volatile.StoreUint16(&o.CS2REC.Reg, volatile.LoadUint16(&o.CS2REC.Reg)&^(0xf00)|value<<8)
}
func (o *BUS_Type) GetCS2REC_WRCV() uint16 {
	return (volatile.LoadUint16(&o.CS2REC.Reg) & 0xf00) >> 8
}
func (o *BUS_Type) SetCS2REC_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS2REC.Reg, volatile.LoadUint16(&o.CS2REC.Reg)&^(0xf0)|value<<4)
}
func (o *BUS_Type) GetCS2REC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS2REC.Reg) & 0xf0) >> 4
}
func (o *BUS_Type) SetCS2REC_RRCV(value uint16) {
	volatile.StoreUint16(&o.CS2REC.Reg, volatile.LoadUint16(&o.CS2REC.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetCS2REC_RRCV() uint16 {
	return volatile.LoadUint16(&o.CS2REC.Reg) & 0xf
}

// BUS.CS3CR: CS%s Control Register
func (o *BUS_Type) SetCS3CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS3CR.Reg, volatile.LoadUint16(&o.CS3CR.Reg)&^(0xe000)|value<<13)
}
func (o *BUS_Type) GetCS3CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS3CR.Reg) & 0xe000) >> 13
}
func (o *BUS_Type) SetCS3CR_MPXEN(value uint16) {
	volatile.StoreUint16(&o.CS3CR.Reg, volatile.LoadUint16(&o.CS3CR.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCS3CR_MPXEN() uint16 {
	return (volatile.LoadUint16(&o.CS3CR.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCS3CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS3CR.Reg, volatile.LoadUint16(&o.CS3CR.Reg)&^(0xe00)|value<<9)
}
func (o *BUS_Type) GetCS3CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS3CR.Reg) & 0xe00) >> 9
}
func (o *BUS_Type) SetCS3CR_EMODE(value uint16) {
	volatile.StoreUint16(&o.CS3CR.Reg, volatile.LoadUint16(&o.CS3CR.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS3CR_EMODE() uint16 {
	return (volatile.LoadUint16(&o.CS3CR.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS3CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS3CR.Reg, volatile.LoadUint16(&o.CS3CR.Reg)&^(0xc0)|value<<6)
}
func (o *BUS_Type) GetCS3CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS3CR.Reg) & 0xc0) >> 6
}
func (o *BUS_Type) SetCS3CR_BSIZE(value uint16) {
	volatile.StoreUint16(&o.CS3CR.Reg, volatile.LoadUint16(&o.CS3CR.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetCS3CR_BSIZE() uint16 {
	return (volatile.LoadUint16(&o.CS3CR.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetCS3CR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS3CR.Reg, volatile.LoadUint16(&o.CS3CR.Reg)&^(0xe)|value<<1)
}
func (o *BUS_Type) GetCS3CR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS3CR.Reg) & 0xe) >> 1
}
func (o *BUS_Type) SetCS3CR_EXENB(value uint16) {
	volatile.StoreUint16(&o.CS3CR.Reg, volatile.LoadUint16(&o.CS3CR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS3CR_EXENB() uint16 {
	return volatile.LoadUint16(&o.CS3CR.Reg) & 0x1
}

// BUS.CS3REC: CS%s Recovery Cycle Register
func (o *BUS_Type) SetCS3REC_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS3REC.Reg, volatile.LoadUint16(&o.CS3REC.Reg)&^(0xf000)|value<<12)
}
func (o *BUS_Type) GetCS3REC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS3REC.Reg) & 0xf000) >> 12
}
func (o *BUS_Type) SetCS3REC_WRCV(value uint16) {
	volatile.StoreUint16(&o.CS3REC.Reg, volatile.LoadUint16(&o.CS3REC.Reg)&^(0xf00)|value<<8)
}
func (o *BUS_Type) GetCS3REC_WRCV() uint16 {
	return (volatile.LoadUint16(&o.CS3REC.Reg) & 0xf00) >> 8
}
func (o *BUS_Type) SetCS3REC_Reserved(value uint16) {
	volatile.StoreUint16(&o.CS3REC.Reg, volatile.LoadUint16(&o.CS3REC.Reg)&^(0xf0)|value<<4)
}
func (o *BUS_Type) GetCS3REC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CS3REC.Reg) & 0xf0) >> 4
}
func (o *BUS_Type) SetCS3REC_RRCV(value uint16) {
	volatile.StoreUint16(&o.CS3REC.Reg, volatile.LoadUint16(&o.CS3REC.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetCS3REC_RRCV() uint16 {
	return volatile.LoadUint16(&o.CS3REC.Reg) & 0xf
}

// BUS.CSRECEN: CS Recovery Cycle Insertion Enable Register
func (o *BUS_Type) SetCSRECEN_RECVENM7(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCSRECEN_RECVENM7() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCSRECEN_RECVENM6(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x4000)|value<<14)
}
func (o *BUS_Type) GetCSRECEN_RECVENM6() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x4000) >> 14
}
func (o *BUS_Type) SetCSRECEN_RECVENM5(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x2000)|value<<13)
}
func (o *BUS_Type) GetCSRECEN_RECVENM5() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x2000) >> 13
}
func (o *BUS_Type) SetCSRECEN_RECVENM4(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCSRECEN_RECVENM4() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCSRECEN_RECVENM3(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x800)|value<<11)
}
func (o *BUS_Type) GetCSRECEN_RECVENM3() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x800) >> 11
}
func (o *BUS_Type) SetCSRECEN_RECVENM2(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x400)|value<<10)
}
func (o *BUS_Type) GetCSRECEN_RECVENM2() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x400) >> 10
}
func (o *BUS_Type) SetCSRECEN_RECVENM1(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCSRECEN_RECVENM1() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCSRECEN_RECVENM0(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCSRECEN_RECVENM0() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCSRECEN_RECVEN7(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetCSRECEN_RECVEN7() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetCSRECEN_RECVEN6(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x40)|value<<6)
}
func (o *BUS_Type) GetCSRECEN_RECVEN6() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x40) >> 6
}
func (o *BUS_Type) SetCSRECEN_RECVEN5(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x20)|value<<5)
}
func (o *BUS_Type) GetCSRECEN_RECVEN5() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x20) >> 5
}
func (o *BUS_Type) SetCSRECEN_RECVEN4(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x10)|value<<4)
}
func (o *BUS_Type) GetCSRECEN_RECVEN4() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x10) >> 4
}
func (o *BUS_Type) SetCSRECEN_RECVEN3(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCSRECEN_RECVEN3() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCSRECEN_RECVEN2(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x4)|value<<2)
}
func (o *BUS_Type) GetCSRECEN_RECVEN2() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x4) >> 2
}
func (o *BUS_Type) SetCSRECEN_RECVEN1(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x2)|value<<1)
}
func (o *BUS_Type) GetCSRECEN_RECVEN1() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x2) >> 1
}
func (o *BUS_Type) SetCSRECEN_RECVEN0(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCSRECEN_RECVEN0() uint16 {
	return volatile.LoadUint16(&o.CSRECEN.Reg) & 0x1
}

// BUS.BUSMCNTM4I: Master Bus Control Register %s
func (o *BUS_Type) SetBUSMCNTM4I_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTM4I.Reg, volatile.LoadUint16(&o.BUSMCNTM4I.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTM4I_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTM4I.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetBUSMCNTM4I_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTM4I.Reg, volatile.LoadUint16(&o.BUSMCNTM4I.Reg)&^(0x7fff)|value)
}
func (o *BUS_Type) GetBUSMCNTM4I_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSMCNTM4I.Reg) & 0x7fff
}

// BUS.BUSMCNTM4D: Master Bus Control Register %s
func (o *BUS_Type) SetBUSMCNTM4D_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTM4D.Reg, volatile.LoadUint16(&o.BUSMCNTM4D.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTM4D_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTM4D.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetBUSMCNTM4D_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTM4D.Reg, volatile.LoadUint16(&o.BUSMCNTM4D.Reg)&^(0x7fff)|value)
}
func (o *BUS_Type) GetBUSMCNTM4D_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSMCNTM4D.Reg) & 0x7fff
}

// BUS.BUSMCNTSYS: Master Bus Control Register %s
func (o *BUS_Type) SetBUSMCNTSYS_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTSYS.Reg, volatile.LoadUint16(&o.BUSMCNTSYS.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTSYS_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTSYS.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetBUSMCNTSYS_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTSYS.Reg, volatile.LoadUint16(&o.BUSMCNTSYS.Reg)&^(0x7fff)|value)
}
func (o *BUS_Type) GetBUSMCNTSYS_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSMCNTSYS.Reg) & 0x7fff
}

// BUS.BUSMCNTDMA: Master Bus Control Register %s
func (o *BUS_Type) SetBUSMCNTDMA_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTDMA.Reg, volatile.LoadUint16(&o.BUSMCNTDMA.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTDMA_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTDMA.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetBUSMCNTDMA_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTDMA.Reg, volatile.LoadUint16(&o.BUSMCNTDMA.Reg)&^(0x7fff)|value)
}
func (o *BUS_Type) GetBUSMCNTDMA_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSMCNTDMA.Reg) & 0x7fff
}

// BUS.BUSSCNTFLI: Slave Bus Control Register FLI
func (o *BUS_Type) SetBUSSCNTFLI_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFLI.Reg, volatile.LoadUint16(&o.BUSSCNTFLI.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTFLI_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTFLI.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTFLI_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFLI.Reg, volatile.LoadUint16(&o.BUSSCNTFLI.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTFLI_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTFLI.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTFLI_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFLI.Reg, volatile.LoadUint16(&o.BUSSCNTFLI.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTFLI_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTFLI.Reg) & 0xf
}

// BUS.BUSSCNTMBIU: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTMBIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTMBIU.Reg, volatile.LoadUint16(&o.BUSSCNTMBIU.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTMBIU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTMBIU.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTMBIU_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTMBIU.Reg, volatile.LoadUint16(&o.BUSSCNTMBIU.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTMBIU_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTMBIU.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTMBIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTMBIU.Reg, volatile.LoadUint16(&o.BUSSCNTMBIU.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTMBIU_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTMBIU.Reg) & 0xf
}

// BUS.BUSSCNTRAM0: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTRAM0_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTRAM0.Reg, volatile.LoadUint16(&o.BUSSCNTRAM0.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTRAM0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTRAM0.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTRAM0_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTRAM0.Reg, volatile.LoadUint16(&o.BUSSCNTRAM0.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTRAM0_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTRAM0.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTRAM0_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTRAM0.Reg, volatile.LoadUint16(&o.BUSSCNTRAM0.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTRAM0_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTRAM0.Reg) & 0xf
}

// BUS.BUSSCNTP0B: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTP0B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP0B.Reg, volatile.LoadUint16(&o.BUSSCNTP0B.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTP0B_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP0B.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTP0B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP0B.Reg, volatile.LoadUint16(&o.BUSSCNTP0B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP0B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP0B.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTP0B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP0B.Reg, volatile.LoadUint16(&o.BUSSCNTP0B.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTP0B_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTP0B.Reg) & 0xf
}

// BUS.BUSSCNTP2B: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTP2B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP2B.Reg, volatile.LoadUint16(&o.BUSSCNTP2B.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTP2B_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP2B.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTP2B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP2B.Reg, volatile.LoadUint16(&o.BUSSCNTP2B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP2B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP2B.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTP2B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP2B.Reg, volatile.LoadUint16(&o.BUSSCNTP2B.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTP2B_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTP2B.Reg) & 0xf
}

// BUS.BUSSCNTP3B: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTP3B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP3B.Reg, volatile.LoadUint16(&o.BUSSCNTP3B.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTP3B_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP3B.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTP3B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP3B.Reg, volatile.LoadUint16(&o.BUSSCNTP3B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP3B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP3B.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTP3B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP3B.Reg, volatile.LoadUint16(&o.BUSSCNTP3B.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTP3B_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTP3B.Reg) & 0xf
}

// BUS.BUSSCNTP4B: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTP4B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP4B.Reg, volatile.LoadUint16(&o.BUSSCNTP4B.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTP4B_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP4B.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTP4B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP4B.Reg, volatile.LoadUint16(&o.BUSSCNTP4B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP4B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP4B.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTP4B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP4B.Reg, volatile.LoadUint16(&o.BUSSCNTP4B.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTP4B_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTP4B.Reg) & 0xf
}

// BUS.BUSSCNTP6B: Slave Bus Control Register P6B
func (o *BUS_Type) SetBUSSCNTP6B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP6B.Reg, volatile.LoadUint16(&o.BUSSCNTP6B.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTP6B_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP6B.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTP6B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP6B.Reg, volatile.LoadUint16(&o.BUSSCNTP6B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP6B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP6B.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTP6B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP6B.Reg, volatile.LoadUint16(&o.BUSSCNTP6B.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTP6B_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTP6B.Reg) & 0xf
}

// BUS.BUSSCNTFBU: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTFBU_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFBU.Reg, volatile.LoadUint16(&o.BUSSCNTFBU.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTFBU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTFBU.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTFBU_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFBU.Reg, volatile.LoadUint16(&o.BUSSCNTFBU.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTFBU_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTFBU.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTFBU_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFBU.Reg, volatile.LoadUint16(&o.BUSSCNTFBU.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTFBU_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTFBU.Reg) & 0xf
}

// BUS.BUSSCNTEXT: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTEXT_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTEXT.Reg, volatile.LoadUint16(&o.BUSSCNTEXT.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTEXT_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTEXT.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTEXT_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTEXT.Reg, volatile.LoadUint16(&o.BUSSCNTEXT.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTEXT_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTEXT.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTEXT_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTEXT.Reg, volatile.LoadUint16(&o.BUSSCNTEXT.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTEXT_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTEXT.Reg) & 0xf
}

// BUS.BUSSCNTEXT2: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTEXT2_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTEXT2.Reg, volatile.LoadUint16(&o.BUSSCNTEXT2.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTEXT2_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTEXT2.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTEXT2_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTEXT2.Reg, volatile.LoadUint16(&o.BUSSCNTEXT2.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTEXT2_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTEXT2.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTEXT2_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTEXT2.Reg, volatile.LoadUint16(&o.BUSSCNTEXT2.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTEXT2_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTEXT2.Reg) & 0xf
}

// BUS.BUS1ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS1ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS1ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS1ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS1ERRADD.Reg)
}

// BUS.BUS1ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS1ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRSTAT.Reg, volatile.LoadUint8(&o.BUS1ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS1ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS1ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS1ERRSTAT_Reserved(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRSTAT.Reg, volatile.LoadUint8(&o.BUS1ERRSTAT.Reg)&^(0x7e)|value<<1)
}
func (o *BUS_Type) GetBUS1ERRSTAT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.BUS1ERRSTAT.Reg) & 0x7e) >> 1
}
func (o *BUS_Type) SetBUS1ERRSTAT_ACCSTST(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRSTAT.Reg, volatile.LoadUint8(&o.BUS1ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS1ERRSTAT_ACCSTST() uint8 {
	return volatile.LoadUint8(&o.BUS1ERRSTAT.Reg) & 0x1
}

// BUS.BUS2ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS2ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS2ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS2ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS2ERRADD.Reg)
}

// BUS.BUS2ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS2ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRSTAT.Reg, volatile.LoadUint8(&o.BUS2ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS2ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS2ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS2ERRSTAT_Reserved(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRSTAT.Reg, volatile.LoadUint8(&o.BUS2ERRSTAT.Reg)&^(0x7e)|value<<1)
}
func (o *BUS_Type) GetBUS2ERRSTAT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.BUS2ERRSTAT.Reg) & 0x7e) >> 1
}
func (o *BUS_Type) SetBUS2ERRSTAT_ACCSTST(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRSTAT.Reg, volatile.LoadUint8(&o.BUS2ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS2ERRSTAT_ACCSTST() uint8 {
	return volatile.LoadUint8(&o.BUS2ERRSTAT.Reg) & 0x1
}

// BUS.BUS3ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS3ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS3ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS3ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS3ERRADD.Reg)
}

// BUS.BUS3ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS3ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS3ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS3ERRSTAT_Reserved(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x7e)|value<<1)
}
func (o *BUS_Type) GetBUS3ERRSTAT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x7e) >> 1
}
func (o *BUS_Type) SetBUS3ERRSTAT_ACCSTST(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS3ERRSTAT_ACCSTST() uint8 {
	return volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x1
}

// BUS.BUS4ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS4ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS4ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS4ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS4ERRADD.Reg)
}

// BUS.BUS4ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS4ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS4ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS4ERRSTAT_Reserved(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x7e)|value<<1)
}
func (o *BUS_Type) GetBUS4ERRSTAT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x7e) >> 1
}
func (o *BUS_Type) SetBUS4ERRSTAT_ACCSTST(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS4ERRSTAT_ACCSTST() uint8 {
	return volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x1
}

// SRAM Control
type SRAM_Type struct {
	PARIOAD   volatile.Register8 // 0x0
	_         [3]byte
	SRAMPRCR  volatile.Register8 // 0x4
	_         [187]byte
	ECCMODE   volatile.Register8 // 0xC0
	ECC2STS   volatile.Register8 // 0xC1
	ECC1STSEN volatile.Register8 // 0xC2
	ECC1STS   volatile.Register8 // 0xC3
	ECCPRCR   volatile.Register8 // 0xC4
	_         [11]byte
	ECCPRCR2  volatile.Register8 // 0xD0
	_         [3]byte
	ECCETST   volatile.Register8 // 0xD4
	_         [3]byte
	ECCOAD    volatile.Register8 // 0xD8
}

// SRAM.PARIOAD: SRAM Parity Error Operation After Detection Register
func (o *SRAM_Type) SetPARIOAD_Reserved(value uint8) {
	volatile.StoreUint8(&o.PARIOAD.Reg, volatile.LoadUint8(&o.PARIOAD.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetPARIOAD_Reserved() uint8 {
	return (volatile.LoadUint8(&o.PARIOAD.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetPARIOAD_OAD(value uint8) {
	volatile.StoreUint8(&o.PARIOAD.Reg, volatile.LoadUint8(&o.PARIOAD.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetPARIOAD_OAD() uint8 {
	return volatile.LoadUint8(&o.PARIOAD.Reg) & 0x1
}

// SRAM.SRAMPRCR: SRAM Protection Register
func (o *SRAM_Type) SetSRAMPRCR_KW(value uint8) {
	volatile.StoreUint8(&o.SRAMPRCR.Reg, volatile.LoadUint8(&o.SRAMPRCR.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetSRAMPRCR_KW() uint8 {
	return (volatile.LoadUint8(&o.SRAMPRCR.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetSRAMPRCR(value uint8) {
	volatile.StoreUint8(&o.SRAMPRCR.Reg, volatile.LoadUint8(&o.SRAMPRCR.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetSRAMPRCR() uint8 {
	return volatile.LoadUint8(&o.SRAMPRCR.Reg) & 0x1
}

// SRAM.ECCMODE: ECC Operating Mode Control Register
func (o *SRAM_Type) SetECCMODE_Reserved(value uint8) {
	volatile.StoreUint8(&o.ECCMODE.Reg, volatile.LoadUint8(&o.ECCMODE.Reg)&^(0xfc)|value<<2)
}
func (o *SRAM_Type) GetECCMODE_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ECCMODE.Reg) & 0xfc) >> 2
}
func (o *SRAM_Type) SetECCMODE_ECCMOD(value uint8) {
	volatile.StoreUint8(&o.ECCMODE.Reg, volatile.LoadUint8(&o.ECCMODE.Reg)&^(0x3)|value)
}
func (o *SRAM_Type) GetECCMODE_ECCMOD() uint8 {
	return volatile.LoadUint8(&o.ECCMODE.Reg) & 0x3
}

// SRAM.ECC2STS: ECC 2-Bit Error Status Register
func (o *SRAM_Type) SetECC2STS_Reserved(value uint8) {
	volatile.StoreUint8(&o.ECC2STS.Reg, volatile.LoadUint8(&o.ECC2STS.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECC2STS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ECC2STS.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECC2STS_ECC2ERR(value uint8) {
	volatile.StoreUint8(&o.ECC2STS.Reg, volatile.LoadUint8(&o.ECC2STS.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECC2STS_ECC2ERR() uint8 {
	return volatile.LoadUint8(&o.ECC2STS.Reg) & 0x1
}

// SRAM.ECC1STSEN: ECC 1-Bit Error Information Update Enable Register
func (o *SRAM_Type) SetECC1STSEN_Reserved(value uint8) {
	volatile.StoreUint8(&o.ECC1STSEN.Reg, volatile.LoadUint8(&o.ECC1STSEN.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECC1STSEN_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ECC1STSEN.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECC1STSEN_E1STSEN(value uint8) {
	volatile.StoreUint8(&o.ECC1STSEN.Reg, volatile.LoadUint8(&o.ECC1STSEN.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECC1STSEN_E1STSEN() uint8 {
	return volatile.LoadUint8(&o.ECC1STSEN.Reg) & 0x1
}

// SRAM.ECC1STS: ECC 1-Bit Error Status Register
func (o *SRAM_Type) SetECC1STS_Reserved(value uint8) {
	volatile.StoreUint8(&o.ECC1STS.Reg, volatile.LoadUint8(&o.ECC1STS.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECC1STS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ECC1STS.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECC1STS_ECC1ERR(value uint8) {
	volatile.StoreUint8(&o.ECC1STS.Reg, volatile.LoadUint8(&o.ECC1STS.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECC1STS_ECC1ERR() uint8 {
	return volatile.LoadUint8(&o.ECC1STS.Reg) & 0x1
}

// SRAM.ECCPRCR: ECC Protection Register
func (o *SRAM_Type) SetECCPRCR_KW(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR.Reg, volatile.LoadUint8(&o.ECCPRCR.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECCPRCR_KW() uint8 {
	return (volatile.LoadUint8(&o.ECCPRCR.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECCPRCR(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR.Reg, volatile.LoadUint8(&o.ECCPRCR.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCPRCR() uint8 {
	return volatile.LoadUint8(&o.ECCPRCR.Reg) & 0x1
}

// SRAM.ECCPRCR2: ECC Protection Register 2
func (o *SRAM_Type) SetECCPRCR2_KW2(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR2.Reg, volatile.LoadUint8(&o.ECCPRCR2.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECCPRCR2_KW2() uint8 {
	return (volatile.LoadUint8(&o.ECCPRCR2.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECCPRCR2(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR2.Reg, volatile.LoadUint8(&o.ECCPRCR2.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCPRCR2() uint8 {
	return volatile.LoadUint8(&o.ECCPRCR2.Reg) & 0x1
}

// SRAM.ECCETST: ECC Test Control Register
func (o *SRAM_Type) SetECCETST_Reserved(value uint8) {
	volatile.StoreUint8(&o.ECCETST.Reg, volatile.LoadUint8(&o.ECCETST.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECCETST_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ECCETST.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECCETST_TSTBYP(value uint8) {
	volatile.StoreUint8(&o.ECCETST.Reg, volatile.LoadUint8(&o.ECCETST.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCETST_TSTBYP() uint8 {
	return volatile.LoadUint8(&o.ECCETST.Reg) & 0x1
}

// SRAM.ECCOAD: SRAM ECC Error Operation After Detection Register
func (o *SRAM_Type) SetECCOAD_Reserved(value uint8) {
	volatile.StoreUint8(&o.ECCOAD.Reg, volatile.LoadUint8(&o.ECCOAD.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECCOAD_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ECCOAD.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECCOAD_OAD(value uint8) {
	volatile.StoreUint8(&o.ECCOAD.Reg, volatile.LoadUint8(&o.ECCOAD.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCOAD_OAD() uint8 {
	return volatile.LoadUint8(&o.ECCOAD.Reg) & 0x1
}

// Bus Master MPU
type MMPU_Type struct {
	MMPUCTLA  volatile.Register16 // 0x0
	_         [256]byte
	MMPUPTA   volatile.Register16 // 0x102
	_         [252]byte
	MMPUACA0  volatile.Register16 // 0x200
	_         [2]byte
	MMPUSA0   volatile.Register32 // 0x204
	MMPUEA0   volatile.Register32 // 0x208
	_         [4]byte
	MMPUACA1  volatile.Register16 // 0x210
	_         [2]byte
	MMPUSA1   volatile.Register32 // 0x214
	MMPUEA1   volatile.Register32 // 0x218
	_         [4]byte
	MMPUACA2  volatile.Register16 // 0x220
	_         [2]byte
	MMPUSA2   volatile.Register32 // 0x224
	MMPUEA2   volatile.Register32 // 0x228
	_         [4]byte
	MMPUACA3  volatile.Register16 // 0x230
	_         [2]byte
	MMPUSA3   volatile.Register32 // 0x234
	MMPUEA3   volatile.Register32 // 0x238
	_         [4]byte
	MMPUACA4  volatile.Register16 // 0x240
	_         [2]byte
	MMPUSA4   volatile.Register32 // 0x244
	MMPUEA4   volatile.Register32 // 0x248
	_         [4]byte
	MMPUACA5  volatile.Register16 // 0x250
	_         [2]byte
	MMPUSA5   volatile.Register32 // 0x254
	MMPUEA5   volatile.Register32 // 0x258
	_         [4]byte
	MMPUACA6  volatile.Register16 // 0x260
	_         [2]byte
	MMPUSA6   volatile.Register32 // 0x264
	MMPUEA6   volatile.Register32 // 0x268
	_         [4]byte
	MMPUACA7  volatile.Register16 // 0x270
	_         [2]byte
	MMPUSA7   volatile.Register32 // 0x274
	MMPUEA7   volatile.Register32 // 0x278
	_         [4]byte
	MMPUACA8  volatile.Register16 // 0x280
	_         [2]byte
	MMPUSA8   volatile.Register32 // 0x284
	MMPUEA8   volatile.Register32 // 0x288
	_         [4]byte
	MMPUACA9  volatile.Register16 // 0x290
	_         [2]byte
	MMPUSA9   volatile.Register32 // 0x294
	MMPUEA9   volatile.Register32 // 0x298
	_         [4]byte
	MMPUACA10 volatile.Register16 // 0x2A0
	_         [2]byte
	MMPUSA10  volatile.Register32 // 0x2A4
	MMPUEA10  volatile.Register32 // 0x2A8
	_         [4]byte
	MMPUACA11 volatile.Register16 // 0x2B0
	_         [2]byte
	MMPUSA11  volatile.Register32 // 0x2B4
	MMPUEA11  volatile.Register32 // 0x2B8
	_         [4]byte
	MMPUACA12 volatile.Register16 // 0x2C0
	_         [2]byte
	MMPUSA12  volatile.Register32 // 0x2C4
	MMPUEA12  volatile.Register32 // 0x2C8
	_         [4]byte
	MMPUACA13 volatile.Register16 // 0x2D0
	_         [2]byte
	MMPUSA13  volatile.Register32 // 0x2D4
	MMPUEA13  volatile.Register32 // 0x2D8
	_         [4]byte
	MMPUACA14 volatile.Register16 // 0x2E0
	_         [2]byte
	MMPUSA14  volatile.Register32 // 0x2E4
	MMPUEA14  volatile.Register32 // 0x2E8
	_         [4]byte
	MMPUACA15 volatile.Register16 // 0x2F0
	_         [2]byte
	MMPUSA15  volatile.Register32 // 0x2F4
	MMPUEA15  volatile.Register32 // 0x2F8
}

// MMPU.MMPUCTLA: Bus Master MPU Control Register A
func (o *MMPU_Type) SetMMPUCTLA_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0xff00)|value<<8)
}
func (o *MMPU_Type) GetMMPUCTLA_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0xff00) >> 8
}
func (o *MMPU_Type) SetMMPUCTLA_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0xfc)|value<<2)
}
func (o *MMPU_Type) GetMMPUCTLA_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0xfc) >> 2
}
func (o *MMPU_Type) SetMMPUCTLA_OAD(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUCTLA_OAD() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUCTLA_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUCTLA_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0x1
}

// MMPU.MMPUPTA: Group A Protection of Register
func (o *MMPU_Type) SetMMPUPTA_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUPTA.Reg, volatile.LoadUint16(&o.MMPUPTA.Reg)&^(0xff00)|value<<8)
}
func (o *MMPU_Type) GetMMPUPTA_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUPTA.Reg) & 0xff00) >> 8
}
func (o *MMPU_Type) SetMMPUPTA_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUPTA.Reg, volatile.LoadUint16(&o.MMPUPTA.Reg)&^(0xfe)|value<<1)
}
func (o *MMPU_Type) GetMMPUPTA_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUPTA.Reg) & 0xfe) >> 1
}
func (o *MMPU_Type) SetMMPUPTA_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MMPUPTA.Reg, volatile.LoadUint16(&o.MMPUPTA.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUPTA_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MMPUPTA.Reg) & 0x1
}

// MMPU.MMPUACA0: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA0_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA0.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA0_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA0_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA0.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA0_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA0_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA0.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA0_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA0_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA0.Reg) & 0x1
}

// MMPU.MMPUSA0: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA0(value uint32) {
	volatile.StoreUint32(&o.MMPUSA0.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA0() uint32 {
	return volatile.LoadUint32(&o.MMPUSA0.Reg)
}

// MMPU.MMPUEA0: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA0(value uint32) {
	volatile.StoreUint32(&o.MMPUEA0.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA0() uint32 {
	return volatile.LoadUint32(&o.MMPUEA0.Reg)
}

// MMPU.MMPUACA1: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA1_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA1.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA1_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA1_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA1.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA1_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA1_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA1.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA1_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA1_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA1.Reg) & 0x1
}

// MMPU.MMPUSA1: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA1(value uint32) {
	volatile.StoreUint32(&o.MMPUSA1.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA1() uint32 {
	return volatile.LoadUint32(&o.MMPUSA1.Reg)
}

// MMPU.MMPUEA1: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA1(value uint32) {
	volatile.StoreUint32(&o.MMPUEA1.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA1() uint32 {
	return volatile.LoadUint32(&o.MMPUEA1.Reg)
}

// MMPU.MMPUACA2: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA2_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA2_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA2.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA2_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA2_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA2.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA2_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA2_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA2.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA2_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA2_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA2.Reg) & 0x1
}

// MMPU.MMPUSA2: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA2(value uint32) {
	volatile.StoreUint32(&o.MMPUSA2.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA2() uint32 {
	return volatile.LoadUint32(&o.MMPUSA2.Reg)
}

// MMPU.MMPUEA2: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA2(value uint32) {
	volatile.StoreUint32(&o.MMPUEA2.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA2() uint32 {
	return volatile.LoadUint32(&o.MMPUEA2.Reg)
}

// MMPU.MMPUACA3: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA3_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA3_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA3.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA3_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA3_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA3.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA3_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA3_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA3.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA3_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA3_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA3.Reg) & 0x1
}

// MMPU.MMPUSA3: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA3(value uint32) {
	volatile.StoreUint32(&o.MMPUSA3.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA3() uint32 {
	return volatile.LoadUint32(&o.MMPUSA3.Reg)
}

// MMPU.MMPUEA3: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA3(value uint32) {
	volatile.StoreUint32(&o.MMPUEA3.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA3() uint32 {
	return volatile.LoadUint32(&o.MMPUEA3.Reg)
}

// MMPU.MMPUACA4: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA4_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA4.Reg, volatile.LoadUint16(&o.MMPUACA4.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA4_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA4.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA4_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA4.Reg, volatile.LoadUint16(&o.MMPUACA4.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA4_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA4.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA4_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA4.Reg, volatile.LoadUint16(&o.MMPUACA4.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA4_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA4.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA4_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA4.Reg, volatile.LoadUint16(&o.MMPUACA4.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA4_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA4.Reg) & 0x1
}

// MMPU.MMPUSA4: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA4(value uint32) {
	volatile.StoreUint32(&o.MMPUSA4.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA4() uint32 {
	return volatile.LoadUint32(&o.MMPUSA4.Reg)
}

// MMPU.MMPUEA4: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA4(value uint32) {
	volatile.StoreUint32(&o.MMPUEA4.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA4() uint32 {
	return volatile.LoadUint32(&o.MMPUEA4.Reg)
}

// MMPU.MMPUACA5: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA5_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA5.Reg, volatile.LoadUint16(&o.MMPUACA5.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA5_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA5.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA5_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA5.Reg, volatile.LoadUint16(&o.MMPUACA5.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA5_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA5.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA5_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA5.Reg, volatile.LoadUint16(&o.MMPUACA5.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA5_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA5.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA5_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA5.Reg, volatile.LoadUint16(&o.MMPUACA5.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA5_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA5.Reg) & 0x1
}

// MMPU.MMPUSA5: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA5(value uint32) {
	volatile.StoreUint32(&o.MMPUSA5.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA5() uint32 {
	return volatile.LoadUint32(&o.MMPUSA5.Reg)
}

// MMPU.MMPUEA5: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA5(value uint32) {
	volatile.StoreUint32(&o.MMPUEA5.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA5() uint32 {
	return volatile.LoadUint32(&o.MMPUEA5.Reg)
}

// MMPU.MMPUACA6: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA6_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA6.Reg, volatile.LoadUint16(&o.MMPUACA6.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA6_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA6.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA6_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA6.Reg, volatile.LoadUint16(&o.MMPUACA6.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA6_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA6.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA6_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA6.Reg, volatile.LoadUint16(&o.MMPUACA6.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA6_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA6.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA6_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA6.Reg, volatile.LoadUint16(&o.MMPUACA6.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA6_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA6.Reg) & 0x1
}

// MMPU.MMPUSA6: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA6(value uint32) {
	volatile.StoreUint32(&o.MMPUSA6.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA6() uint32 {
	return volatile.LoadUint32(&o.MMPUSA6.Reg)
}

// MMPU.MMPUEA6: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA6(value uint32) {
	volatile.StoreUint32(&o.MMPUEA6.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA6() uint32 {
	return volatile.LoadUint32(&o.MMPUEA6.Reg)
}

// MMPU.MMPUACA7: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA7_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA7.Reg, volatile.LoadUint16(&o.MMPUACA7.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA7_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA7.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA7_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA7.Reg, volatile.LoadUint16(&o.MMPUACA7.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA7_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA7.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA7_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA7.Reg, volatile.LoadUint16(&o.MMPUACA7.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA7_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA7.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA7_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA7.Reg, volatile.LoadUint16(&o.MMPUACA7.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA7_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA7.Reg) & 0x1
}

// MMPU.MMPUSA7: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA7(value uint32) {
	volatile.StoreUint32(&o.MMPUSA7.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA7() uint32 {
	return volatile.LoadUint32(&o.MMPUSA7.Reg)
}

// MMPU.MMPUEA7: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA7(value uint32) {
	volatile.StoreUint32(&o.MMPUEA7.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA7() uint32 {
	return volatile.LoadUint32(&o.MMPUEA7.Reg)
}

// MMPU.MMPUACA8: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA8_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA8.Reg, volatile.LoadUint16(&o.MMPUACA8.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA8_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA8.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA8_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA8.Reg, volatile.LoadUint16(&o.MMPUACA8.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA8_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA8.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA8_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA8.Reg, volatile.LoadUint16(&o.MMPUACA8.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA8_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA8.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA8_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA8.Reg, volatile.LoadUint16(&o.MMPUACA8.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA8_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA8.Reg) & 0x1
}

// MMPU.MMPUSA8: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA8(value uint32) {
	volatile.StoreUint32(&o.MMPUSA8.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA8() uint32 {
	return volatile.LoadUint32(&o.MMPUSA8.Reg)
}

// MMPU.MMPUEA8: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA8(value uint32) {
	volatile.StoreUint32(&o.MMPUEA8.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA8() uint32 {
	return volatile.LoadUint32(&o.MMPUEA8.Reg)
}

// MMPU.MMPUACA9: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA9_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA9.Reg, volatile.LoadUint16(&o.MMPUACA9.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA9_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA9.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA9_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA9.Reg, volatile.LoadUint16(&o.MMPUACA9.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA9_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA9.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA9_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA9.Reg, volatile.LoadUint16(&o.MMPUACA9.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA9_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA9.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA9_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA9.Reg, volatile.LoadUint16(&o.MMPUACA9.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA9_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA9.Reg) & 0x1
}

// MMPU.MMPUSA9: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA9(value uint32) {
	volatile.StoreUint32(&o.MMPUSA9.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA9() uint32 {
	return volatile.LoadUint32(&o.MMPUSA9.Reg)
}

// MMPU.MMPUEA9: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA9(value uint32) {
	volatile.StoreUint32(&o.MMPUEA9.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA9() uint32 {
	return volatile.LoadUint32(&o.MMPUEA9.Reg)
}

// MMPU.MMPUACA10: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA10_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA10.Reg, volatile.LoadUint16(&o.MMPUACA10.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA10_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA10.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA10_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA10.Reg, volatile.LoadUint16(&o.MMPUACA10.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA10_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA10.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA10_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA10.Reg, volatile.LoadUint16(&o.MMPUACA10.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA10_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA10.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA10_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA10.Reg, volatile.LoadUint16(&o.MMPUACA10.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA10_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA10.Reg) & 0x1
}

// MMPU.MMPUSA10: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA10(value uint32) {
	volatile.StoreUint32(&o.MMPUSA10.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA10() uint32 {
	return volatile.LoadUint32(&o.MMPUSA10.Reg)
}

// MMPU.MMPUEA10: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA10(value uint32) {
	volatile.StoreUint32(&o.MMPUEA10.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA10() uint32 {
	return volatile.LoadUint32(&o.MMPUEA10.Reg)
}

// MMPU.MMPUACA11: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA11_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA11.Reg, volatile.LoadUint16(&o.MMPUACA11.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA11_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA11.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA11_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA11.Reg, volatile.LoadUint16(&o.MMPUACA11.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA11_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA11.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA11_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA11.Reg, volatile.LoadUint16(&o.MMPUACA11.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA11_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA11.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA11_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA11.Reg, volatile.LoadUint16(&o.MMPUACA11.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA11_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA11.Reg) & 0x1
}

// MMPU.MMPUSA11: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA11(value uint32) {
	volatile.StoreUint32(&o.MMPUSA11.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA11() uint32 {
	return volatile.LoadUint32(&o.MMPUSA11.Reg)
}

// MMPU.MMPUEA11: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA11(value uint32) {
	volatile.StoreUint32(&o.MMPUEA11.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA11() uint32 {
	return volatile.LoadUint32(&o.MMPUEA11.Reg)
}

// MMPU.MMPUACA12: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA12_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA12.Reg, volatile.LoadUint16(&o.MMPUACA12.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA12_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA12.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA12_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA12.Reg, volatile.LoadUint16(&o.MMPUACA12.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA12_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA12.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA12_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA12.Reg, volatile.LoadUint16(&o.MMPUACA12.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA12_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA12.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA12_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA12.Reg, volatile.LoadUint16(&o.MMPUACA12.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA12_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA12.Reg) & 0x1
}

// MMPU.MMPUSA12: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA12(value uint32) {
	volatile.StoreUint32(&o.MMPUSA12.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA12() uint32 {
	return volatile.LoadUint32(&o.MMPUSA12.Reg)
}

// MMPU.MMPUEA12: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA12(value uint32) {
	volatile.StoreUint32(&o.MMPUEA12.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA12() uint32 {
	return volatile.LoadUint32(&o.MMPUEA12.Reg)
}

// MMPU.MMPUACA13: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA13_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA13.Reg, volatile.LoadUint16(&o.MMPUACA13.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA13_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA13.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA13_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA13.Reg, volatile.LoadUint16(&o.MMPUACA13.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA13_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA13.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA13_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA13.Reg, volatile.LoadUint16(&o.MMPUACA13.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA13_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA13.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA13_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA13.Reg, volatile.LoadUint16(&o.MMPUACA13.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA13_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA13.Reg) & 0x1
}

// MMPU.MMPUSA13: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA13(value uint32) {
	volatile.StoreUint32(&o.MMPUSA13.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA13() uint32 {
	return volatile.LoadUint32(&o.MMPUSA13.Reg)
}

// MMPU.MMPUEA13: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA13(value uint32) {
	volatile.StoreUint32(&o.MMPUEA13.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA13() uint32 {
	return volatile.LoadUint32(&o.MMPUEA13.Reg)
}

// MMPU.MMPUACA14: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA14_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA14.Reg, volatile.LoadUint16(&o.MMPUACA14.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA14_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA14.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA14_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA14.Reg, volatile.LoadUint16(&o.MMPUACA14.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA14_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA14.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA14_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA14.Reg, volatile.LoadUint16(&o.MMPUACA14.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA14_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA14.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA14_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA14.Reg, volatile.LoadUint16(&o.MMPUACA14.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA14_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA14.Reg) & 0x1
}

// MMPU.MMPUSA14: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA14(value uint32) {
	volatile.StoreUint32(&o.MMPUSA14.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA14() uint32 {
	return volatile.LoadUint32(&o.MMPUSA14.Reg)
}

// MMPU.MMPUEA14: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA14(value uint32) {
	volatile.StoreUint32(&o.MMPUEA14.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA14() uint32 {
	return volatile.LoadUint32(&o.MMPUEA14.Reg)
}

// MMPU.MMPUACA15: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA15_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA15.Reg, volatile.LoadUint16(&o.MMPUACA15.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA15_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA15.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA15_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA15.Reg, volatile.LoadUint16(&o.MMPUACA15.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA15_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA15.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA15_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA15.Reg, volatile.LoadUint16(&o.MMPUACA15.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA15_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA15.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA15_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA15.Reg, volatile.LoadUint16(&o.MMPUACA15.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA15_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA15.Reg) & 0x1
}

// MMPU.MMPUSA15: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA15(value uint32) {
	volatile.StoreUint32(&o.MMPUSA15.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA15() uint32 {
	return volatile.LoadUint32(&o.MMPUSA15.Reg)
}

// MMPU.MMPUEA15: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA15(value uint32) {
	volatile.StoreUint32(&o.MMPUEA15.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA15() uint32 {
	return volatile.LoadUint32(&o.MMPUEA15.Reg)
}

// Bus Slave MPU
type SMPU_Type struct {
	SMPUCTL    volatile.Register16 // 0x0
	_          [14]byte
	SMPUMBIU   volatile.Register16 // 0x10
	_          [2]byte
	SMPUFBIU   volatile.Register16 // 0x14
	_          [2]byte
	SMPUSRAM0  volatile.Register16 // 0x18
	_          [6]byte
	SMPUP0BIU  volatile.Register16 // 0x20
	_          [2]byte
	SMPUP2BIU  volatile.Register16 // 0x24
	_          [2]byte
	SMPUP6BIU  volatile.Register16 // 0x28
	_          [6]byte
	SMPUEXBIU  volatile.Register16 // 0x30
	_          [2]byte
	SMPUEXBIU2 volatile.Register16 // 0x34
}

// SMPU.SMPUCTL: Slave MPU Control Register
func (o *SMPU_Type) SetSMPUCTL_KEY(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0xff00)|value<<8)
}
func (o *SMPU_Type) GetSMPUCTL_KEY() uint16 {
	return (volatile.LoadUint16(&o.SMPUCTL.Reg) & 0xff00) >> 8
}
func (o *SMPU_Type) SetSMPUCTL_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0xf8)|value<<3)
}
func (o *SMPU_Type) GetSMPUCTL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUCTL.Reg) & 0xf8) >> 3
}
func (o *SMPU_Type) SetSMPUCTL_PROTECT(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0x6)|value<<1)
}
func (o *SMPU_Type) GetSMPUCTL_PROTECT() uint16 {
	return (volatile.LoadUint16(&o.SMPUCTL.Reg) & 0x6) >> 1
}
func (o *SMPU_Type) SetSMPUCTL_OAD(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUCTL_OAD() uint16 {
	return volatile.LoadUint16(&o.SMPUCTL.Reg) & 0x1
}

// SMPU.SMPUMBIU: Access Control Register for MBIU
func (o *SMPU_Type) SetSMPUMBIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUMBIU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUMBIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUMBIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUMBIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUMBIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUMBIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x3)|value)
}
func (o *SMPU_Type) GetSMPUMBIU_Reserved() uint16 {
	return volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x3
}

// SMPU.SMPUFBIU: Access Control Register for FBIU
func (o *SMPU_Type) SetSMPUFBIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUFBIU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUFBIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUFBIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUFBIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUFBIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUFBIU_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUFBIU_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUFBIU_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUFBIU_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x1
}

// SMPU.SMPUSRAM0: Access Control Register for SRAM0
func (o *SMPU_Type) SetSMPUSRAM0_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUSRAM0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUSRAM0_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUSRAM0_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUSRAM0_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUSRAM0_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUSRAM0_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUSRAM0_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUSRAM0_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUSRAM0_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x1
}

// SMPU.SMPUP0BIU: Access Control Register for P%sBIU
func (o *SMPU_Type) SetSMPUP0BIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUP0BIU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUP0BIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUP0BIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUP0BIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUP0BIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUP0BIU_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUP0BIU_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUP0BIU_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUP0BIU_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x1
}

// SMPU.SMPUP2BIU: Access Control Register for P%sBIU
func (o *SMPU_Type) SetSMPUP2BIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUP2BIU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUP2BIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUP2BIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUP2BIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUP2BIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUP2BIU_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUP2BIU_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUP2BIU_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUP2BIU_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x1
}

// SMPU.SMPUP6BIU: Access Control Register for P%sBIU
func (o *SMPU_Type) SetSMPUP6BIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUP6BIU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUP6BIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUP6BIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUP6BIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUP6BIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUP6BIU_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUP6BIU_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUP6BIU_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUP6BIU_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x1
}

// SMPU.SMPUEXBIU: Access Control Register for EXBIU
func (o *SMPU_Type) SetSMPUEXBIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU.Reg, volatile.LoadUint16(&o.SMPUEXBIU.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUEXBIU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUEXBIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU.Reg, volatile.LoadUint16(&o.SMPUEXBIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUEXBIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUEXBIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU.Reg, volatile.LoadUint16(&o.SMPUEXBIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUEXBIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUEXBIU_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU.Reg, volatile.LoadUint16(&o.SMPUEXBIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUEXBIU_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUEXBIU_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU.Reg, volatile.LoadUint16(&o.SMPUEXBIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUEXBIU_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUEXBIU.Reg) & 0x1
}

// SMPU.SMPUEXBIU2: Access Control Register for EXBIU2
func (o *SMPU_Type) SetSMPUEXBIU2_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU2.Reg, volatile.LoadUint16(&o.SMPUEXBIU2.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUEXBIU2_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU2.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUEXBIU2_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU2.Reg, volatile.LoadUint16(&o.SMPUEXBIU2.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUEXBIU2_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU2.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUEXBIU2_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU2.Reg, volatile.LoadUint16(&o.SMPUEXBIU2.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUEXBIU2_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU2.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUEXBIU2_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU2.Reg, volatile.LoadUint16(&o.SMPUEXBIU2.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUEXBIU2_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU2.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUEXBIU2_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU2.Reg, volatile.LoadUint16(&o.SMPUEXBIU2.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUEXBIU2_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUEXBIU2.Reg) & 0x1
}

// CPU Stack Pointer Monitor
type SPMON_Type struct {
	MSPMPUOAD volatile.Register16 // 0x0
	_         [2]byte
	MSPMPUCTL volatile.Register16 // 0x4
	MSPMPUPT  volatile.Register16 // 0x6
	MSPMPUSA  volatile.Register32 // 0x8
	MSPMPUEA  volatile.Register32 // 0xC
	PSPMPUOAD volatile.Register16 // 0x10
	_         [2]byte
	PSPMPUCTL volatile.Register16 // 0x14
	PSPMPUPT  volatile.Register16 // 0x16
	PSPMPUSA  volatile.Register32 // 0x18
	PSPMPUEA  volatile.Register32 // 0x1C
}

// SPMON.MSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
func (o *SPMON_Type) SetMSPMPUOAD_KEY(value uint16) {
	volatile.StoreUint16(&o.MSPMPUOAD.Reg, volatile.LoadUint16(&o.MSPMPUOAD.Reg)&^(0xff00)|value<<8)
}
func (o *SPMON_Type) GetMSPMPUOAD_KEY() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUOAD.Reg) & 0xff00) >> 8
}
func (o *SPMON_Type) SetMSPMPUOAD_Reserved(value uint16) {
	volatile.StoreUint16(&o.MSPMPUOAD.Reg, volatile.LoadUint16(&o.MSPMPUOAD.Reg)&^(0xfe)|value<<1)
}
func (o *SPMON_Type) GetMSPMPUOAD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUOAD.Reg) & 0xfe) >> 1
}
func (o *SPMON_Type) SetMSPMPUOAD_OAD(value uint16) {
	volatile.StoreUint16(&o.MSPMPUOAD.Reg, volatile.LoadUint16(&o.MSPMPUOAD.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetMSPMPUOAD_OAD() uint16 {
	return volatile.LoadUint16(&o.MSPMPUOAD.Reg) & 0x1
}

// SPMON.MSPMPUCTL: Stack Pointer Monitor Access Control Register
func (o *SPMON_Type) SetMSPMPUCTL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MSPMPUCTL.Reg, volatile.LoadUint16(&o.MSPMPUCTL.Reg)&^(0xfe00)|value<<9)
}
func (o *SPMON_Type) GetMSPMPUCTL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUCTL.Reg) & 0xfe00) >> 9
}
func (o *SPMON_Type) SetMSPMPUCTL_ERROR(value uint16) {
	volatile.StoreUint16(&o.MSPMPUCTL.Reg, volatile.LoadUint16(&o.MSPMPUCTL.Reg)&^(0x100)|value<<8)
}
func (o *SPMON_Type) GetMSPMPUCTL_ERROR() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUCTL.Reg) & 0x100) >> 8
}
func (o *SPMON_Type) SetMSPMPUCTL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MSPMPUCTL.Reg, volatile.LoadUint16(&o.MSPMPUCTL.Reg)&^(0xfe)|value<<1)
}
func (o *SPMON_Type) GetMSPMPUCTL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUCTL.Reg) & 0xfe) >> 1
}
func (o *SPMON_Type) SetMSPMPUCTL_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MSPMPUCTL.Reg, volatile.LoadUint16(&o.MSPMPUCTL.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetMSPMPUCTL_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MSPMPUCTL.Reg) & 0x1
}

// SPMON.MSPMPUPT: Stack Pointer Monitor Protection Register
func (o *SPMON_Type) SetMSPMPUPT_KEY(value uint16) {
	volatile.StoreUint16(&o.MSPMPUPT.Reg, volatile.LoadUint16(&o.MSPMPUPT.Reg)&^(0xff00)|value<<8)
}
func (o *SPMON_Type) GetMSPMPUPT_KEY() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUPT.Reg) & 0xff00) >> 8
}
func (o *SPMON_Type) SetMSPMPUPT_Reserved(value uint16) {
	volatile.StoreUint16(&o.MSPMPUPT.Reg, volatile.LoadUint16(&o.MSPMPUPT.Reg)&^(0xfe)|value<<1)
}
func (o *SPMON_Type) GetMSPMPUPT_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUPT.Reg) & 0xfe) >> 1
}
func (o *SPMON_Type) SetMSPMPUPT_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MSPMPUPT.Reg, volatile.LoadUint16(&o.MSPMPUPT.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetMSPMPUPT_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MSPMPUPT.Reg) & 0x1
}

// SPMON.MSPMPUSA: Main Stack Pointer (MSP) Monitor Start Address Register
func (o *SPMON_Type) SetMSPMPUSA(value uint32) {
	volatile.StoreUint32(&o.MSPMPUSA.Reg, value)
}
func (o *SPMON_Type) GetMSPMPUSA() uint32 {
	return volatile.LoadUint32(&o.MSPMPUSA.Reg)
}

// SPMON.MSPMPUEA: Main Stack Pointer (MSP) Monitor End Address Register
func (o *SPMON_Type) SetMSPMPUEA(value uint32) {
	volatile.StoreUint32(&o.MSPMPUEA.Reg, value)
}
func (o *SPMON_Type) GetMSPMPUEA() uint32 {
	return volatile.LoadUint32(&o.MSPMPUEA.Reg)
}

// SPMON.PSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
func (o *SPMON_Type) SetPSPMPUOAD_KEY(value uint16) {
	volatile.StoreUint16(&o.PSPMPUOAD.Reg, volatile.LoadUint16(&o.PSPMPUOAD.Reg)&^(0xff00)|value<<8)
}
func (o *SPMON_Type) GetPSPMPUOAD_KEY() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUOAD.Reg) & 0xff00) >> 8
}
func (o *SPMON_Type) SetPSPMPUOAD_Reserved(value uint16) {
	volatile.StoreUint16(&o.PSPMPUOAD.Reg, volatile.LoadUint16(&o.PSPMPUOAD.Reg)&^(0xfe)|value<<1)
}
func (o *SPMON_Type) GetPSPMPUOAD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUOAD.Reg) & 0xfe) >> 1
}
func (o *SPMON_Type) SetPSPMPUOAD_OAD(value uint16) {
	volatile.StoreUint16(&o.PSPMPUOAD.Reg, volatile.LoadUint16(&o.PSPMPUOAD.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetPSPMPUOAD_OAD() uint16 {
	return volatile.LoadUint16(&o.PSPMPUOAD.Reg) & 0x1
}

// SPMON.PSPMPUCTL: Stack Pointer Monitor Access Control Register
func (o *SPMON_Type) SetPSPMPUCTL_Reserved(value uint16) {
	volatile.StoreUint16(&o.PSPMPUCTL.Reg, volatile.LoadUint16(&o.PSPMPUCTL.Reg)&^(0xfe00)|value<<9)
}
func (o *SPMON_Type) GetPSPMPUCTL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUCTL.Reg) & 0xfe00) >> 9
}
func (o *SPMON_Type) SetPSPMPUCTL_ERROR(value uint16) {
	volatile.StoreUint16(&o.PSPMPUCTL.Reg, volatile.LoadUint16(&o.PSPMPUCTL.Reg)&^(0x100)|value<<8)
}
func (o *SPMON_Type) GetPSPMPUCTL_ERROR() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUCTL.Reg) & 0x100) >> 8
}
func (o *SPMON_Type) SetPSPMPUCTL_Reserved(value uint16) {
	volatile.StoreUint16(&o.PSPMPUCTL.Reg, volatile.LoadUint16(&o.PSPMPUCTL.Reg)&^(0xfe)|value<<1)
}
func (o *SPMON_Type) GetPSPMPUCTL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUCTL.Reg) & 0xfe) >> 1
}
func (o *SPMON_Type) SetPSPMPUCTL_ENABLE(value uint16) {
	volatile.StoreUint16(&o.PSPMPUCTL.Reg, volatile.LoadUint16(&o.PSPMPUCTL.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetPSPMPUCTL_ENABLE() uint16 {
	return volatile.LoadUint16(&o.PSPMPUCTL.Reg) & 0x1
}

// SPMON.PSPMPUPT: Stack Pointer Monitor Protection Register
func (o *SPMON_Type) SetPSPMPUPT_KEY(value uint16) {
	volatile.StoreUint16(&o.PSPMPUPT.Reg, volatile.LoadUint16(&o.PSPMPUPT.Reg)&^(0xff00)|value<<8)
}
func (o *SPMON_Type) GetPSPMPUPT_KEY() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUPT.Reg) & 0xff00) >> 8
}
func (o *SPMON_Type) SetPSPMPUPT_Reserved(value uint16) {
	volatile.StoreUint16(&o.PSPMPUPT.Reg, volatile.LoadUint16(&o.PSPMPUPT.Reg)&^(0xfe)|value<<1)
}
func (o *SPMON_Type) GetPSPMPUPT_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUPT.Reg) & 0xfe) >> 1
}
func (o *SPMON_Type) SetPSPMPUPT_PROTECT(value uint16) {
	volatile.StoreUint16(&o.PSPMPUPT.Reg, volatile.LoadUint16(&o.PSPMPUPT.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetPSPMPUPT_PROTECT() uint16 {
	return volatile.LoadUint16(&o.PSPMPUPT.Reg) & 0x1
}

// SPMON.PSPMPUSA: Process Stack Pointer (PSP) Monitor Start Address Register
func (o *SPMON_Type) SetPSPMPUSA(value uint32) {
	volatile.StoreUint32(&o.PSPMPUSA.Reg, value)
}
func (o *SPMON_Type) GetPSPMPUSA() uint32 {
	return volatile.LoadUint32(&o.PSPMPUSA.Reg)
}

// SPMON.PSPMPUEA: Process Stack Pointer (PSP) Monitor End Address Register
func (o *SPMON_Type) SetPSPMPUEA(value uint32) {
	volatile.StoreUint32(&o.PSPMPUEA.Reg, value)
}
func (o *SPMON_Type) GetPSPMPUEA() uint32 {
	return volatile.LoadUint32(&o.PSPMPUEA.Reg)
}

// Memory Mirror Function
type MMF_Type struct {
	MMSFR volatile.Register32 // 0x0
	MMEN  volatile.Register32 // 0x4
}

// MMF.MMSFR: MemMirror Special Function Register
func (o *MMF_Type) SetMMSFR_KEY(value uint32) {
	volatile.StoreUint32(&o.MMSFR.Reg, volatile.LoadUint32(&o.MMSFR.Reg)&^(0xff000000)|value<<24)
}
func (o *MMF_Type) GetMMSFR_KEY() uint32 {
	return (volatile.LoadUint32(&o.MMSFR.Reg) & 0xff000000) >> 24
}
func (o *MMF_Type) SetMMSFR_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMSFR.Reg, volatile.LoadUint32(&o.MMSFR.Reg)&^(0x800000)|value<<23)
}
func (o *MMF_Type) GetMMSFR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MMSFR.Reg) & 0x800000) >> 23
}
func (o *MMF_Type) SetMMSFR_MEMMIRADDR(value uint32) {
	volatile.StoreUint32(&o.MMSFR.Reg, volatile.LoadUint32(&o.MMSFR.Reg)&^(0x7fff80)|value<<7)
}
func (o *MMF_Type) GetMMSFR_MEMMIRADDR() uint32 {
	return (volatile.LoadUint32(&o.MMSFR.Reg) & 0x7fff80) >> 7
}
func (o *MMF_Type) SetMMSFR_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMSFR.Reg, volatile.LoadUint32(&o.MMSFR.Reg)&^(0x7f)|value)
}
func (o *MMF_Type) GetMMSFR_Reserved() uint32 {
	return volatile.LoadUint32(&o.MMSFR.Reg) & 0x7f
}

// MMF.MMEN: MemMirror Enable Register
func (o *MMF_Type) SetMMEN_KEY(value uint32) {
	volatile.StoreUint32(&o.MMEN.Reg, volatile.LoadUint32(&o.MMEN.Reg)&^(0xff000000)|value<<24)
}
func (o *MMF_Type) GetMMEN_KEY() uint32 {
	return (volatile.LoadUint32(&o.MMEN.Reg) & 0xff000000) >> 24
}
func (o *MMF_Type) SetMMEN_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMEN.Reg, volatile.LoadUint32(&o.MMEN.Reg)&^(0xfffffe)|value<<1)
}
func (o *MMF_Type) GetMMEN_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MMEN.Reg) & 0xfffffe) >> 1
}
func (o *MMF_Type) SetMMEN_EN(value uint32) {
	volatile.StoreUint32(&o.MMEN.Reg, volatile.LoadUint32(&o.MMEN.Reg)&^(0x1)|value)
}
func (o *MMF_Type) GetMMEN_EN() uint32 {
	return volatile.LoadUint32(&o.MMEN.Reg) & 0x1
}

// Serial Peripheral Interface 0
type SPI0_Type struct {
	SPCR   volatile.Register8  // 0x0
	SSLP   volatile.Register8  // 0x1
	SPPCR  volatile.Register8  // 0x2
	SPSR   volatile.Register8  // 0x3
	SPDR   volatile.Register32 // 0x4
	SPSCR  volatile.Register8  // 0x8
	SPSSR  volatile.Register8  // 0x9
	SPBR   volatile.Register8  // 0xA
	SPDCR  volatile.Register8  // 0xB
	SPCKD  volatile.Register8  // 0xC
	SSLND  volatile.Register8  // 0xD
	SPND   volatile.Register8  // 0xE
	SPCR2  volatile.Register8  // 0xF
	SPCMD0 volatile.Register16 // 0x10
	SPCMD1 volatile.Register16 // 0x12
	SPCMD2 volatile.Register16 // 0x14
	SPCMD3 volatile.Register16 // 0x16
	SPCMD4 volatile.Register16 // 0x18
	SPCMD5 volatile.Register16 // 0x1A
	SPCMD6 volatile.Register16 // 0x1C
	SPCMD7 volatile.Register16 // 0x1E
}

// SPI0.SPCR: SPI Control Register
func (o *SPI0_Type) SetSPCR_SPRIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCR_SPRIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCR_SPE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPCR_SPE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPCR_SPTIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPCR_SPTIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPCR_SPEIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPCR_SPEIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPCR_MSTR(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPCR_MSTR() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPCR_MODFEN(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPCR_MODFEN() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPCR_TXMD(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCR_TXMD() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCR_SPMS(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCR_SPMS() uint8 {
	return volatile.LoadUint8(&o.SPCR.Reg) & 0x1
}

// SPI0.SSLP: SPI Slave Select Polarity Register
func (o *SPI0_Type) SetSSLP_Reserved(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0xf0)|value<<4)
}
func (o *SPI0_Type) GetSSLP_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0xf0) >> 4
}
func (o *SPI0_Type) SetSSLP_SSL3P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSSLP_SSL3P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSSLP_SSL2P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSSLP_SSL2P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSSLP_SSL1P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSSLP_SSL1P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSSLP_SSL0P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSSLP_SSL0P() uint8 {
	return volatile.LoadUint8(&o.SSLP.Reg) & 0x1
}

// SPI0.SPPCR: SPI Pin Control Register
func (o *SPI0_Type) SetSPPCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0xc0)|value<<6)
}
func (o *SPI0_Type) GetSPPCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0xc0) >> 6
}
func (o *SPI0_Type) SetSPPCR_MOIFE(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPPCR_MOIFE() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPPCR_MOIFV(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPPCR_MOIFV() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPPCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPPCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPPCR_SPLP2(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPPCR_SPLP2() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPPCR_SPLP(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPPCR_SPLP() uint8 {
	return volatile.LoadUint8(&o.SPPCR.Reg) & 0x1
}

// SPI0.SPSR: SPI Status Register
func (o *SPI0_Type) SetSPSR_SPRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPSR_SPRF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPSR_SPTEF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPSR_SPTEF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPSR_UDRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPSR_UDRF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPSR_PERF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPSR_PERF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPSR_MODF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPSR_MODF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPSR_IDLNF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPSR_IDLNF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPSR_OVRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPSR_OVRF() uint8 {
	return volatile.LoadUint8(&o.SPSR.Reg) & 0x1
}

// SPI0.SPDR: SPI Data Register
func (o *SPI0_Type) SetSPDR(value uint32) {
	volatile.StoreUint32(&o.SPDR.Reg, value)
}
func (o *SPI0_Type) GetSPDR() uint32 {
	return volatile.LoadUint32(&o.SPDR.Reg)
}

// SPI0.SPSCR: SPI Sequence Control Register
func (o *SPI0_Type) SetSPSCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPSCR.Reg, volatile.LoadUint8(&o.SPSCR.Reg)&^(0xf8)|value<<3)
}
func (o *SPI0_Type) GetSPSCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPSCR.Reg) & 0xf8) >> 3
}
func (o *SPI0_Type) SetSPSCR_SPSLN(value uint8) {
	volatile.StoreUint8(&o.SPSCR.Reg, volatile.LoadUint8(&o.SPSCR.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPSCR_SPSLN() uint8 {
	return volatile.LoadUint8(&o.SPSCR.Reg) & 0x7
}

// SPI0.SPSSR: SPI Sequence Status Register
func (o *SPI0_Type) SetSPSSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPSSR.Reg, volatile.LoadUint8(&o.SPSSR.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPSSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPSSR.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPSSR_SPECM(value uint8) {
	volatile.StoreUint8(&o.SPSSR.Reg, volatile.LoadUint8(&o.SPSSR.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPSSR_SPECM() uint8 {
	return (volatile.LoadUint8(&o.SPSSR.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPSSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPSSR.Reg, volatile.LoadUint8(&o.SPSSR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPSSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPSSR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPSSR_SPCP(value uint8) {
	volatile.StoreUint8(&o.SPSSR.Reg, volatile.LoadUint8(&o.SPSSR.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPSSR_SPCP() uint8 {
	return volatile.LoadUint8(&o.SPSSR.Reg) & 0x7
}

// SPI0.SPBR: SPI Bit Rate Register
func (o *SPI0_Type) SetSPBR(value uint8) {
	volatile.StoreUint8(&o.SPBR.Reg, value)
}
func (o *SPI0_Type) GetSPBR() uint8 {
	return volatile.LoadUint8(&o.SPBR.Reg)
}

// SPI0.SPDCR: SPI Data Control Register
func (o *SPI0_Type) SetSPDCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0xc0)|value<<6)
}
func (o *SPI0_Type) GetSPDCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0xc0) >> 6
}
func (o *SPI0_Type) SetSPDCR_SPLW(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPDCR_SPLW() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPDCR_SPRDTD(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPDCR_SPRDTD() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPDCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPDCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPDCR_SPFC(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x3)|value)
}
func (o *SPI0_Type) GetSPDCR_SPFC() uint8 {
	return volatile.LoadUint8(&o.SPDCR.Reg) & 0x3
}

// SPI0.SPCKD: SPI Clock Delay Register
func (o *SPI0_Type) SetSPCKD_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPCKD.Reg, volatile.LoadUint8(&o.SPCKD.Reg)&^(0xf8)|value<<3)
}
func (o *SPI0_Type) GetSPCKD_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPCKD.Reg) & 0xf8) >> 3
}
func (o *SPI0_Type) SetSPCKD_SCKDL(value uint8) {
	volatile.StoreUint8(&o.SPCKD.Reg, volatile.LoadUint8(&o.SPCKD.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPCKD_SCKDL() uint8 {
	return volatile.LoadUint8(&o.SPCKD.Reg) & 0x7
}

// SPI0.SSLND: SPI Slave Select Negation Delay Register
func (o *SPI0_Type) SetSSLND_Reserved(value uint8) {
	volatile.StoreUint8(&o.SSLND.Reg, volatile.LoadUint8(&o.SSLND.Reg)&^(0xf8)|value<<3)
}
func (o *SPI0_Type) GetSSLND_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SSLND.Reg) & 0xf8) >> 3
}
func (o *SPI0_Type) SetSSLND_SLNDL(value uint8) {
	volatile.StoreUint8(&o.SSLND.Reg, volatile.LoadUint8(&o.SSLND.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSSLND_SLNDL() uint8 {
	return volatile.LoadUint8(&o.SSLND.Reg) & 0x7
}

// SPI0.SPND: SPI Next-Access Delay Register
func (o *SPI0_Type) SetSPND_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPND.Reg, volatile.LoadUint8(&o.SPND.Reg)&^(0xf8)|value<<3)
}
func (o *SPI0_Type) GetSPND_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPND.Reg) & 0xf8) >> 3
}
func (o *SPI0_Type) SetSPND_SPNDL(value uint8) {
	volatile.StoreUint8(&o.SPND.Reg, volatile.LoadUint8(&o.SPND.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPND_SPNDL() uint8 {
	return volatile.LoadUint8(&o.SPND.Reg) & 0x7
}

// SPI0.SPCR2: SPI Control Register 2
func (o *SPI0_Type) SetSPCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0xe0)|value<<5)
}
func (o *SPI0_Type) GetSPCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0xe0) >> 5
}
func (o *SPI0_Type) SetSPCR2_SCKASE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPCR2_SCKASE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPCR2_PTE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPCR2_PTE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPCR2_SPIIE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPCR2_SPIIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPCR2_SPOE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCR2_SPOE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCR2_SPPE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCR2_SPPE() uint8 {
	return volatile.LoadUint8(&o.SPCR2.Reg) & 0x1
}

// SPI0.SPCMD0: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD0_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD0_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD0_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD0_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD0_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD0_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD0_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD0_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD0_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD0_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD0_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD0_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD0_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD0_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD0_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD0_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD0_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD0_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD0_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD0_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD0.Reg) & 0x1
}

// SPI0.SPCMD1: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD1_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD1_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD1_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD1_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD1_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD1_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD1_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD1_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD1_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD1_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD1_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD1_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD1_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD1_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD1_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD1_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD1_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD1_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD1_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD1_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD1.Reg) & 0x1
}

// SPI0.SPCMD2: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD2_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD2_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD2_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD2_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD2_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD2_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD2_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD2_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD2_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD2_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD2_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD2_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD2_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD2_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD2_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD2_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD2_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD2_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD2_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD2_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD2.Reg) & 0x1
}

// SPI0.SPCMD3: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD3_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD3_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD3_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD3_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD3_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD3_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD3_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD3_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD3_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD3_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD3_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD3_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD3_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD3_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD3_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD3_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD3_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD3_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD3_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD3_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD3.Reg) & 0x1
}

// SPI0.SPCMD4: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD4_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD4_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD4_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD4_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD4_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD4_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD4_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD4_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD4_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD4_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD4_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD4_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD4_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD4_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD4_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD4_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD4_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD4_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD4_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD4_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD4.Reg) & 0x1
}

// SPI0.SPCMD5: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD5_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD5_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD5_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD5_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD5_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD5_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD5_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD5_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD5_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD5_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD5_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD5_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD5_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD5_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD5_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD5_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD5_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD5_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD5_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD5_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD5.Reg) & 0x1
}

// SPI0.SPCMD6: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD6_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD6_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD6_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD6_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD6_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD6_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD6_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD6_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD6_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD6_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD6_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD6_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD6_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD6_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD6_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD6_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD6_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD6_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD6_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD6_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD6.Reg) & 0x1
}

// SPI0.SPCMD7: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD7_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD7_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD7_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD7_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD7_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD7_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD7_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD7_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD7_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD7_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD7_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD7_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD7_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD7_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD7_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD7_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD7_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD7_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD7_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD7_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD7.Reg) & 0x1
}

// Serial Peripheral Interface 1
type SPI1_Type struct {
	SPCR   volatile.Register8  // 0x0
	SSLP   volatile.Register8  // 0x1
	SPPCR  volatile.Register8  // 0x2
	SPSR   volatile.Register8  // 0x3
	SPDR   volatile.Register32 // 0x4
	_      [2]byte
	SPBR   volatile.Register8  // 0xA
	SPDCR  volatile.Register8  // 0xB
	SPCKD  volatile.Register8  // 0xC
	SSLND  volatile.Register8  // 0xD
	SPND   volatile.Register8  // 0xE
	SPCR2  volatile.Register8  // 0xF
	SPCMD0 volatile.Register16 // 0x10
}

// SPI1.SPCR: SPI Control Register
func (o *SPI1_Type) SetSPCR_SPRIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x80)|value<<7)
}
func (o *SPI1_Type) GetSPCR_SPRIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x80) >> 7
}
func (o *SPI1_Type) SetSPCR_SPE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x40)|value<<6)
}
func (o *SPI1_Type) GetSPCR_SPE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x40) >> 6
}
func (o *SPI1_Type) SetSPCR_SPTIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI1_Type) GetSPCR_SPTIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x20) >> 5
}
func (o *SPI1_Type) SetSPCR_SPEIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPCR_SPEIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPCR_MSTR(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPCR_MSTR() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPCR_MODFEN(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPCR_MODFEN() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPCR_TXMD(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPCR_TXMD() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPCR_SPMS(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPCR_SPMS() uint8 {
	return volatile.LoadUint8(&o.SPCR.Reg) & 0x1
}

// SPI1.SSLP: SPI Slave Select Polarity Register
func (o *SPI1_Type) SetSSLP_Reserved(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0xf0)|value<<4)
}
func (o *SPI1_Type) GetSSLP_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0xf0) >> 4
}
func (o *SPI1_Type) SetSSLP_SSL3P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSSLP_SSL3P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSSLP_SSL2P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSSLP_SSL2P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSSLP_SSL1P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSSLP_SSL1P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSSLP_SSL0P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSSLP_SSL0P() uint8 {
	return volatile.LoadUint8(&o.SSLP.Reg) & 0x1
}

// SPI1.SPPCR: SPI Pin Control Register
func (o *SPI1_Type) SetSPPCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0xc0)|value<<6)
}
func (o *SPI1_Type) GetSPPCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0xc0) >> 6
}
func (o *SPI1_Type) SetSPPCR_MOIFE(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI1_Type) GetSPPCR_MOIFE() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x20) >> 5
}
func (o *SPI1_Type) SetSPPCR_MOIFV(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPPCR_MOIFV() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPPCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0xc)|value<<2)
}
func (o *SPI1_Type) GetSPPCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0xc) >> 2
}
func (o *SPI1_Type) SetSPPCR_SPLP2(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPPCR_SPLP2() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPPCR_SPLP(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPPCR_SPLP() uint8 {
	return volatile.LoadUint8(&o.SPPCR.Reg) & 0x1
}

// SPI1.SPSR: SPI Status Register
func (o *SPI1_Type) SetSPSR_SPRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x80)|value<<7)
}
func (o *SPI1_Type) GetSPSR_SPRF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x80) >> 7
}
func (o *SPI1_Type) SetSPSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x40)|value<<6)
}
func (o *SPI1_Type) GetSPSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x40) >> 6
}
func (o *SPI1_Type) SetSPSR_SPTEF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x20)|value<<5)
}
func (o *SPI1_Type) GetSPSR_SPTEF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x20) >> 5
}
func (o *SPI1_Type) SetSPSR_UDRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPSR_UDRF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPSR_PERF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPSR_PERF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPSR_MODF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPSR_MODF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPSR_IDLNF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPSR_IDLNF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPSR_OVRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPSR_OVRF() uint8 {
	return volatile.LoadUint8(&o.SPSR.Reg) & 0x1
}

// SPI1.SPDR: SPI Data Register
func (o *SPI1_Type) SetSPDR(value uint32) {
	volatile.StoreUint32(&o.SPDR.Reg, value)
}
func (o *SPI1_Type) GetSPDR() uint32 {
	return volatile.LoadUint32(&o.SPDR.Reg)
}

// SPI1.SPBR: SPI Bit Rate Register
func (o *SPI1_Type) SetSPBR(value uint8) {
	volatile.StoreUint8(&o.SPBR.Reg, value)
}
func (o *SPI1_Type) GetSPBR() uint8 {
	return volatile.LoadUint8(&o.SPBR.Reg)
}

// SPI1.SPDCR: SPI Data Control Register
func (o *SPI1_Type) SetSPDCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0xc0)|value<<6)
}
func (o *SPI1_Type) GetSPDCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0xc0) >> 6
}
func (o *SPI1_Type) SetSPDCR_SPLW(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI1_Type) GetSPDCR_SPLW() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x20) >> 5
}
func (o *SPI1_Type) SetSPDCR_SPRDTD(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPDCR_SPRDTD() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPDCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0xf)|value)
}
func (o *SPI1_Type) GetSPDCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.SPDCR.Reg) & 0xf
}

// SPI1.SPCKD: SPI Clock Delay Register
func (o *SPI1_Type) SetSPCKD_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPCKD.Reg, volatile.LoadUint8(&o.SPCKD.Reg)&^(0xf8)|value<<3)
}
func (o *SPI1_Type) GetSPCKD_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPCKD.Reg) & 0xf8) >> 3
}
func (o *SPI1_Type) SetSPCKD_SCKDL(value uint8) {
	volatile.StoreUint8(&o.SPCKD.Reg, volatile.LoadUint8(&o.SPCKD.Reg)&^(0x7)|value)
}
func (o *SPI1_Type) GetSPCKD_SCKDL() uint8 {
	return volatile.LoadUint8(&o.SPCKD.Reg) & 0x7
}

// SPI1.SSLND: SPI Slave Select Negation Delay Register
func (o *SPI1_Type) SetSSLND_Reserved(value uint8) {
	volatile.StoreUint8(&o.SSLND.Reg, volatile.LoadUint8(&o.SSLND.Reg)&^(0xf8)|value<<3)
}
func (o *SPI1_Type) GetSSLND_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SSLND.Reg) & 0xf8) >> 3
}
func (o *SPI1_Type) SetSSLND_SLNDL(value uint8) {
	volatile.StoreUint8(&o.SSLND.Reg, volatile.LoadUint8(&o.SSLND.Reg)&^(0x7)|value)
}
func (o *SPI1_Type) GetSSLND_SLNDL() uint8 {
	return volatile.LoadUint8(&o.SSLND.Reg) & 0x7
}

// SPI1.SPND: SPI Next-Access Delay Register
func (o *SPI1_Type) SetSPND_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPND.Reg, volatile.LoadUint8(&o.SPND.Reg)&^(0xf8)|value<<3)
}
func (o *SPI1_Type) GetSPND_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPND.Reg) & 0xf8) >> 3
}
func (o *SPI1_Type) SetSPND_SPNDL(value uint8) {
	volatile.StoreUint8(&o.SPND.Reg, volatile.LoadUint8(&o.SPND.Reg)&^(0x7)|value)
}
func (o *SPI1_Type) GetSPND_SPNDL() uint8 {
	return volatile.LoadUint8(&o.SPND.Reg) & 0x7
}

// SPI1.SPCR2: SPI Control Register 2
func (o *SPI1_Type) SetSPCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0xe0)|value<<5)
}
func (o *SPI1_Type) GetSPCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0xe0) >> 5
}
func (o *SPI1_Type) SetSPCR2_SCKASE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPCR2_SCKASE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPCR2_PTE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPCR2_PTE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPCR2_SPIIE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPCR2_SPIIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPCR2_SPOE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPCR2_SPOE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPCR2_SPPE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPCR2_SPPE() uint8 {
	return volatile.LoadUint8(&o.SPCR2.Reg) & 0x1
}

// SPI1.SPCMD0: SPI Command Register 0
func (o *SPI1_Type) SetSPCMD0_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x8000)|value<<15)
}
func (o *SPI1_Type) GetSPCMD0_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x8000) >> 15
}
func (o *SPI1_Type) SetSPCMD0_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x4000)|value<<14)
}
func (o *SPI1_Type) GetSPCMD0_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x4000) >> 14
}
func (o *SPI1_Type) SetSPCMD0_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x2000)|value<<13)
}
func (o *SPI1_Type) GetSPCMD0_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x2000) >> 13
}
func (o *SPI1_Type) SetSPCMD0_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x1000)|value<<12)
}
func (o *SPI1_Type) GetSPCMD0_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x1000) >> 12
}
func (o *SPI1_Type) SetSPCMD0_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0xf00)|value<<8)
}
func (o *SPI1_Type) GetSPCMD0_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0xf00) >> 8
}
func (o *SPI1_Type) SetSPCMD0_Reserved(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x80)|value<<7)
}
func (o *SPI1_Type) GetSPCMD0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x80) >> 7
}
func (o *SPI1_Type) SetSPCMD0_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x70)|value<<4)
}
func (o *SPI1_Type) GetSPCMD0_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x70) >> 4
}
func (o *SPI1_Type) SetSPCMD0_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0xc)|value<<2)
}
func (o *SPI1_Type) GetSPCMD0_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0xc) >> 2
}
func (o *SPI1_Type) SetSPCMD0_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPCMD0_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPCMD0_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPCMD0_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD0.Reg) & 0x1
}

// Serial Communication Interface 0
type SCI0_Type struct {
	SMR   volatile.Register8  // 0x0
	BRR   volatile.Register8  // 0x1
	SCR   volatile.Register8  // 0x2
	TDR   volatile.Register8  // 0x3
	SSR   volatile.Register8  // 0x4
	RDR   volatile.Register8  // 0x5
	SCMR  volatile.Register8  // 0x6
	SEMR  volatile.Register8  // 0x7
	SNFR  volatile.Register8  // 0x8
	SIMR1 volatile.Register8  // 0x9
	SIMR2 volatile.Register8  // 0xA
	SIMR3 volatile.Register8  // 0xB
	SISR  volatile.Register8  // 0xC
	SPMR  volatile.Register8  // 0xD
	TDRHL volatile.Register16 // 0xE
	RDRHL volatile.Register16 // 0x10
	MDDR  volatile.Register8  // 0x12
	DCCR  volatile.Register8  // 0x13
	FCR   volatile.Register16 // 0x14
	FDR   volatile.Register16 // 0x16
	LSR   volatile.Register16 // 0x18
	CDR   volatile.Register16 // 0x1A
	SPTR  volatile.Register8  // 0x1C
}

// SCI0.SMR: Serial Mode Register (SCMR.SMIF = 0)
func (o *SCI0_Type) SetSMR_CM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSMR_CM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSMR_CHR(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSMR_CHR() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSMR_PE(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSMR_PE() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSMR_PM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSMR_PM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSMR_STOP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSMR_STOP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSMR_MP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSMR_MP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSMR_CKS(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x3)|value)
}
func (o *SCI0_Type) GetSMR_CKS() uint8 {
	return volatile.LoadUint8(&o.SMR.Reg) & 0x3
}

// SCI0.BRR: Bit Rate Register
func (o *SCI0_Type) SetBRR(value uint8) {
	volatile.StoreUint8(&o.BRR.Reg, value)
}
func (o *SCI0_Type) GetBRR() uint8 {
	return volatile.LoadUint8(&o.BRR.Reg)
}

// SCI0.SCR: Serial Control Register (SCMR.SMIF = 0)
func (o *SCI0_Type) SetSCR_TIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSCR_TIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSCR_RIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSCR_RIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSCR_TE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSCR_TE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSCR_RE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSCR_RE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSCR_MPIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSCR_MPIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSCR_TEIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSCR_TEIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSCR_CKE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x3)|value)
}
func (o *SCI0_Type) GetSCR_CKE() uint8 {
	return volatile.LoadUint8(&o.SCR.Reg) & 0x3
}

// SCI0.TDR: Transmit Data Register
func (o *SCI0_Type) SetTDR(value uint8) {
	volatile.StoreUint8(&o.TDR.Reg, value)
}
func (o *SCI0_Type) GetTDR() uint8 {
	return volatile.LoadUint8(&o.TDR.Reg)
}

// SCI0.SSR: Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
func (o *SCI0_Type) SetSSR_TDRE(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSSR_TDRE() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSSR_RDRF(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSSR_RDRF() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSSR_ORER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSSR_ORER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSSR_FER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSSR_FER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSSR_PER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSSR_PER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSSR_TEND(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSSR_TEND() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSSR_MPB(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSSR_MPB() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSSR_MPBT(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSSR_MPBT() uint8 {
	return volatile.LoadUint8(&o.SSR.Reg) & 0x1
}

// SCI0.RDR: Receive Data Register
func (o *SCI0_Type) SetRDR(value uint8) {
	volatile.StoreUint8(&o.RDR.Reg, value)
}
func (o *SCI0_Type) GetRDR() uint8 {
	return volatile.LoadUint8(&o.RDR.Reg)
}

// SCI0.SCMR: Smart Card Mode Register
func (o *SCI0_Type) SetSCMR_BCP2(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSCMR_BCP2() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSCMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x60)|value<<5)
}
func (o *SCI0_Type) GetSCMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x60) >> 5
}
func (o *SCI0_Type) SetSCMR_CHR1(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSCMR_CHR1() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSCMR_SDIR(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSCMR_SDIR() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSCMR_SINV(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSCMR_SINV() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSCMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSCMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSCMR_SMIF(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSCMR_SMIF() uint8 {
	return volatile.LoadUint8(&o.SCMR.Reg) & 0x1
}

// SCI0.SEMR: Serial Extended Mode Register
func (o *SCI0_Type) SetSEMR_RXDESEL(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSEMR_RXDESEL() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSEMR_BGDM(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSEMR_BGDM() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSEMR_NFEN(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSEMR_NFEN() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSEMR_ABCS(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSEMR_ABCS() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSEMR_ABCSE(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSEMR_ABCSE() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSEMR_BRME(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSEMR_BRME() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSEMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x3)|value)
}
func (o *SCI0_Type) GetSEMR_Reserved() uint8 {
	return volatile.LoadUint8(&o.SEMR.Reg) & 0x3
}

// SCI0.SNFR: Noise Filter Setting Register
func (o *SCI0_Type) SetSNFR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0xf8)|value<<3)
}
func (o *SCI0_Type) GetSNFR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SNFR.Reg) & 0xf8) >> 3
}
func (o *SCI0_Type) SetSNFR_NFCS(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0x7)|value)
}
func (o *SCI0_Type) GetSNFR_NFCS() uint8 {
	return volatile.LoadUint8(&o.SNFR.Reg) & 0x7
}

// SCI0.SIMR1: I2C Mode Register 1
func (o *SCI0_Type) SetSIMR1_IICDL(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0xf8)|value<<3)
}
func (o *SCI0_Type) GetSIMR1_IICDL() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0xf8) >> 3
}
func (o *SCI0_Type) SetSIMR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x6)|value<<1)
}
func (o *SCI0_Type) GetSIMR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0x6) >> 1
}
func (o *SCI0_Type) SetSIMR1_IICM(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR1_IICM() uint8 {
	return volatile.LoadUint8(&o.SIMR1.Reg) & 0x1
}

// SCI0.SIMR2: I2C Mode Register 2
func (o *SCI0_Type) SetSIMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0xc0)|value<<6)
}
func (o *SCI0_Type) GetSIMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0xc0) >> 6
}
func (o *SCI0_Type) SetSIMR2_IICACKT(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSIMR2_IICACKT() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSIMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1c)|value<<2)
}
func (o *SCI0_Type) GetSIMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x1c) >> 2
}
func (o *SCI0_Type) SetSIMR2_IICCSC(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSIMR2_IICCSC() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSIMR2_IICINTM(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR2_IICINTM() uint8 {
	return volatile.LoadUint8(&o.SIMR2.Reg) & 0x1
}

// SCI0.SIMR3: I2C Mode Register 3
func (o *SCI0_Type) SetSIMR3_IICSCLS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0xc0)|value<<6)
}
func (o *SCI0_Type) GetSIMR3_IICSCLS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0xc0) >> 6
}
func (o *SCI0_Type) SetSIMR3_IICSDAS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x30)|value<<4)
}
func (o *SCI0_Type) GetSIMR3_IICSDAS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x30) >> 4
}
func (o *SCI0_Type) SetSIMR3_IICSTIF(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSIMR3_IICSTIF() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSIMR3_IICSTPREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSIMR3_IICSTPREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSIMR3_IICRSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSIMR3_IICRSTAREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSIMR3_IICSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR3_IICSTAREQ() uint8 {
	return volatile.LoadUint8(&o.SIMR3.Reg) & 0x1
}

// SCI0.SISR: I2C Status Register
func (o *SCI0_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0xc0)|value<<6)
}
func (o *SCI0_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0xc0) >> 6
}
func (o *SCI0_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSISR_IICACKR(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSISR_IICACKR() uint8 {
	return volatile.LoadUint8(&o.SISR.Reg) & 0x1
}

// SCI0.SPMR: SPI Mode Register
func (o *SCI0_Type) SetSPMR_CKPH(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSPMR_CKPH() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSPMR_CKPOL(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSPMR_CKPOL() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSPMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSPMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSPMR_MFF(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSPMR_MFF() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSPMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSPMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSPMR_MSS(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSPMR_MSS() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSPMR_CTSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSPMR_CTSE() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSPMR_SSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSPMR_SSE() uint8 {
	return volatile.LoadUint8(&o.SPMR.Reg) & 0x1
}

// SCI0.TDRHL: Transmit 9-bit Data Register
func (o *SCI0_Type) SetTDRHL(value uint16) {
	volatile.StoreUint16(&o.TDRHL.Reg, value)
}
func (o *SCI0_Type) GetTDRHL() uint16 {
	return volatile.LoadUint16(&o.TDRHL.Reg)
}

// SCI0.RDRHL: Receive 9-bit Data Register
func (o *SCI0_Type) SetRDRHL(value uint16) {
	volatile.StoreUint16(&o.RDRHL.Reg, value)
}
func (o *SCI0_Type) GetRDRHL() uint16 {
	return volatile.LoadUint16(&o.RDRHL.Reg)
}

// SCI0.MDDR: Modulation Duty Register
func (o *SCI0_Type) SetMDDR(value uint8) {
	volatile.StoreUint8(&o.MDDR.Reg, value)
}
func (o *SCI0_Type) GetMDDR() uint8 {
	return volatile.LoadUint8(&o.MDDR.Reg)
}

// SCI0.DCCR: Data Compare Match Control Register
func (o *SCI0_Type) SetDCCR_DCME(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetDCCR_DCME() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetDCCR_IDSEL(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetDCCR_IDSEL() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetDCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetDCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetDCCR_DFER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetDCCR_DFER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetDCCR_DPER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetDCCR_DPER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetDCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x6)|value<<1)
}
func (o *SCI0_Type) GetDCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x6) >> 1
}
func (o *SCI0_Type) SetDCCR_DCMF(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetDCCR_DCMF() uint8 {
	return volatile.LoadUint8(&o.DCCR.Reg) & 0x1
}

// SCI0.FCR: FIFO Control Register
func (o *SCI0_Type) SetFCR_RSTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf000)|value<<12)
}
func (o *SCI0_Type) GetFCR_RSTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf000) >> 12
}
func (o *SCI0_Type) SetFCR_RTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf00)|value<<8)
}
func (o *SCI0_Type) GetFCR_RTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf00) >> 8
}
func (o *SCI0_Type) SetFCR_TTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf0)|value<<4)
}
func (o *SCI0_Type) GetFCR_TTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf0) >> 4
}
func (o *SCI0_Type) SetFCR_DRES(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetFCR_DRES() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetFCR_TFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetFCR_TFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetFCR_RFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetFCR_RFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetFCR_FM(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetFCR_FM() uint16 {
	return volatile.LoadUint16(&o.FCR.Reg) & 0x1
}

// SCI0.FDR: FIFO Data Count Register
func (o *SCI0_Type) SetFDR_Reserved(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0xe000)|value<<13)
}
func (o *SCI0_Type) GetFDR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.FDR.Reg) & 0xe000) >> 13
}
func (o *SCI0_Type) SetFDR_T(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI0_Type) GetFDR_T() uint16 {
	return (volatile.LoadUint16(&o.FDR.Reg) & 0x1f00) >> 8
}
func (o *SCI0_Type) SetFDR_Reserved(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0xe0)|value<<5)
}
func (o *SCI0_Type) GetFDR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.FDR.Reg) & 0xe0) >> 5
}
func (o *SCI0_Type) SetFDR_R(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f)|value)
}
func (o *SCI0_Type) GetFDR_R() uint16 {
	return volatile.LoadUint16(&o.FDR.Reg) & 0x1f
}

// SCI0.LSR: Line Status Register
func (o *SCI0_Type) SetLSR_Reserved(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0xe000)|value<<13)
}
func (o *SCI0_Type) GetLSR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0xe000) >> 13
}
func (o *SCI0_Type) SetLSR_PNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI0_Type) GetLSR_PNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x1f00) >> 8
}
func (o *SCI0_Type) SetLSR_Reserved(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetLSR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetLSR_FNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x7c)|value<<2)
}
func (o *SCI0_Type) GetLSR_FNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x7c) >> 2
}
func (o *SCI0_Type) SetLSR_Reserved(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetLSR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetLSR_ORER(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetLSR_ORER() uint16 {
	return volatile.LoadUint16(&o.LSR.Reg) & 0x1
}

// SCI0.CDR: Compare Match Data Register
func (o *SCI0_Type) SetCDR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0xfe00)|value<<9)
}
func (o *SCI0_Type) GetCDR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CDR.Reg) & 0xfe00) >> 9
}
func (o *SCI0_Type) SetCDR_CMPD(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0x1ff)|value)
}
func (o *SCI0_Type) GetCDR_CMPD() uint16 {
	return volatile.LoadUint16(&o.CDR.Reg) & 0x1ff
}

// SCI0.SPTR: Serial Port Register
func (o *SCI0_Type) SetSPTR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0xf8)|value<<3)
}
func (o *SCI0_Type) GetSPTR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0xf8) >> 3
}
func (o *SCI0_Type) SetSPTR_SPB2IO(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSPTR_SPB2IO() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSPTR_SPB2DT(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSPTR_SPB2DT() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSPTR_RXDMON(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSPTR_RXDMON() uint8 {
	return volatile.LoadUint8(&o.SPTR.Reg) & 0x1
}

// Serial Communication Interface 2
type SCI2_Type struct {
	SMR   volatile.Register8  // 0x0
	BRR   volatile.Register8  // 0x1
	SCR   volatile.Register8  // 0x2
	TDR   volatile.Register8  // 0x3
	SSR   volatile.Register8  // 0x4
	RDR   volatile.Register8  // 0x5
	SCMR  volatile.Register8  // 0x6
	SEMR  volatile.Register8  // 0x7
	SNFR  volatile.Register8  // 0x8
	SIMR1 volatile.Register8  // 0x9
	SIMR2 volatile.Register8  // 0xA
	SIMR3 volatile.Register8  // 0xB
	SISR  volatile.Register8  // 0xC
	SPMR  volatile.Register8  // 0xD
	TDRHL volatile.Register16 // 0xE
	RDRHL volatile.Register16 // 0x10
	MDDR  volatile.Register8  // 0x12
	DCCR  volatile.Register8  // 0x13
	_     [6]byte
	CDR   volatile.Register16 // 0x1A
	SPTR  volatile.Register8  // 0x1C
}

// SCI2.SMR: Serial Mode Register (SCMR.SMIF = 0)
func (o *SCI2_Type) SetSMR_CM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetSMR_CM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x80) >> 7
}
func (o *SCI2_Type) SetSMR_CHR(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetSMR_CHR() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetSMR_PE(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSMR_PE() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetSMR_PM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSMR_PM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSMR_STOP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSMR_STOP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSMR_MP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSMR_MP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSMR_CKS(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x3)|value)
}
func (o *SCI2_Type) GetSMR_CKS() uint8 {
	return volatile.LoadUint8(&o.SMR.Reg) & 0x3
}

// SCI2.BRR: Bit Rate Register
func (o *SCI2_Type) SetBRR(value uint8) {
	volatile.StoreUint8(&o.BRR.Reg, value)
}
func (o *SCI2_Type) GetBRR() uint8 {
	return volatile.LoadUint8(&o.BRR.Reg)
}

// SCI2.SCR: Serial Control Register (SCMR.SMIF = 0)
func (o *SCI2_Type) SetSCR_TIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetSCR_TIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x80) >> 7
}
func (o *SCI2_Type) SetSCR_RIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetSCR_RIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetSCR_TE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSCR_TE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetSCR_RE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSCR_RE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSCR_MPIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSCR_MPIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSCR_TEIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSCR_TEIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSCR_CKE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x3)|value)
}
func (o *SCI2_Type) GetSCR_CKE() uint8 {
	return volatile.LoadUint8(&o.SCR.Reg) & 0x3
}

// SCI2.TDR: Transmit Data Register
func (o *SCI2_Type) SetTDR(value uint8) {
	volatile.StoreUint8(&o.TDR.Reg, value)
}
func (o *SCI2_Type) GetTDR() uint8 {
	return volatile.LoadUint8(&o.TDR.Reg)
}

// SCI2.SSR: Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
func (o *SCI2_Type) SetSSR_TDRE(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetSSR_TDRE() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x80) >> 7
}
func (o *SCI2_Type) SetSSR_RDRF(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetSSR_RDRF() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetSSR_ORER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSSR_ORER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetSSR_FER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSSR_FER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSSR_PER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSSR_PER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSSR_TEND(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSSR_TEND() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSSR_MPB(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSSR_MPB() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSSR_MPBT(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSSR_MPBT() uint8 {
	return volatile.LoadUint8(&o.SSR.Reg) & 0x1
}

// SCI2.RDR: Receive Data Register
func (o *SCI2_Type) SetRDR(value uint8) {
	volatile.StoreUint8(&o.RDR.Reg, value)
}
func (o *SCI2_Type) GetRDR() uint8 {
	return volatile.LoadUint8(&o.RDR.Reg)
}

// SCI2.SCMR: Smart Card Mode Register
func (o *SCI2_Type) SetSCMR_BCP2(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetSCMR_BCP2() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x80) >> 7
}
func (o *SCI2_Type) SetSCMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x60)|value<<5)
}
func (o *SCI2_Type) GetSCMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x60) >> 5
}
func (o *SCI2_Type) SetSCMR_CHR1(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSCMR_CHR1() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSCMR_SDIR(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSCMR_SDIR() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSCMR_SINV(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSCMR_SINV() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSCMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSCMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSCMR_SMIF(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSCMR_SMIF() uint8 {
	return volatile.LoadUint8(&o.SCMR.Reg) & 0x1
}

// SCI2.SEMR: Serial Extended Mode Register
func (o *SCI2_Type) SetSEMR_RXDESEL(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetSEMR_RXDESEL() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x80) >> 7
}
func (o *SCI2_Type) SetSEMR_BGDM(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetSEMR_BGDM() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetSEMR_NFEN(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSEMR_NFEN() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetSEMR_ABCS(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSEMR_ABCS() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSEMR_ABCSE(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSEMR_ABCSE() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSEMR_BRME(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSEMR_BRME() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSEMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x3)|value)
}
func (o *SCI2_Type) GetSEMR_Reserved() uint8 {
	return volatile.LoadUint8(&o.SEMR.Reg) & 0x3
}

// SCI2.SNFR: Noise Filter Setting Register
func (o *SCI2_Type) SetSNFR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0xf8)|value<<3)
}
func (o *SCI2_Type) GetSNFR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SNFR.Reg) & 0xf8) >> 3
}
func (o *SCI2_Type) SetSNFR_NFCS(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0x7)|value)
}
func (o *SCI2_Type) GetSNFR_NFCS() uint8 {
	return volatile.LoadUint8(&o.SNFR.Reg) & 0x7
}

// SCI2.SIMR1: I2C Mode Register 1
func (o *SCI2_Type) SetSIMR1_IICDL(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0xf8)|value<<3)
}
func (o *SCI2_Type) GetSIMR1_IICDL() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0xf8) >> 3
}
func (o *SCI2_Type) SetSIMR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x6)|value<<1)
}
func (o *SCI2_Type) GetSIMR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0x6) >> 1
}
func (o *SCI2_Type) SetSIMR1_IICM(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSIMR1_IICM() uint8 {
	return volatile.LoadUint8(&o.SIMR1.Reg) & 0x1
}

// SCI2.SIMR2: I2C Mode Register 2
func (o *SCI2_Type) SetSIMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0xc0)|value<<6)
}
func (o *SCI2_Type) GetSIMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0xc0) >> 6
}
func (o *SCI2_Type) SetSIMR2_IICACKT(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSIMR2_IICACKT() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetSIMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1c)|value<<2)
}
func (o *SCI2_Type) GetSIMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x1c) >> 2
}
func (o *SCI2_Type) SetSIMR2_IICCSC(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSIMR2_IICCSC() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSIMR2_IICINTM(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSIMR2_IICINTM() uint8 {
	return volatile.LoadUint8(&o.SIMR2.Reg) & 0x1
}

// SCI2.SIMR3: I2C Mode Register 3
func (o *SCI2_Type) SetSIMR3_IICSCLS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0xc0)|value<<6)
}
func (o *SCI2_Type) GetSIMR3_IICSCLS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0xc0) >> 6
}
func (o *SCI2_Type) SetSIMR3_IICSDAS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x30)|value<<4)
}
func (o *SCI2_Type) GetSIMR3_IICSDAS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x30) >> 4
}
func (o *SCI2_Type) SetSIMR3_IICSTIF(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSIMR3_IICSTIF() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSIMR3_IICSTPREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSIMR3_IICSTPREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSIMR3_IICRSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSIMR3_IICRSTAREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSIMR3_IICSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSIMR3_IICSTAREQ() uint8 {
	return volatile.LoadUint8(&o.SIMR3.Reg) & 0x1
}

// SCI2.SISR: I2C Status Register
func (o *SCI2_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0xc0)|value<<6)
}
func (o *SCI2_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0xc0) >> 6
}
func (o *SCI2_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSISR_IICACKR(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSISR_IICACKR() uint8 {
	return volatile.LoadUint8(&o.SISR.Reg) & 0x1
}

// SCI2.SPMR: SPI Mode Register
func (o *SCI2_Type) SetSPMR_CKPH(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetSPMR_CKPH() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x80) >> 7
}
func (o *SCI2_Type) SetSPMR_CKPOL(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetSPMR_CKPOL() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetSPMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSPMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetSPMR_MFF(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSPMR_MFF() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSPMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSPMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSPMR_MSS(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSPMR_MSS() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSPMR_CTSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSPMR_CTSE() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSPMR_SSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSPMR_SSE() uint8 {
	return volatile.LoadUint8(&o.SPMR.Reg) & 0x1
}

// SCI2.TDRHL: Transmit 9-bit Data Register
func (o *SCI2_Type) SetTDRHL(value uint16) {
	volatile.StoreUint16(&o.TDRHL.Reg, value)
}
func (o *SCI2_Type) GetTDRHL() uint16 {
	return volatile.LoadUint16(&o.TDRHL.Reg)
}

// SCI2.RDRHL: Receive 9-bit Data Register
func (o *SCI2_Type) SetRDRHL(value uint16) {
	volatile.StoreUint16(&o.RDRHL.Reg, value)
}
func (o *SCI2_Type) GetRDRHL() uint16 {
	return volatile.LoadUint16(&o.RDRHL.Reg)
}

// SCI2.MDDR: Modulation Duty Register
func (o *SCI2_Type) SetMDDR(value uint8) {
	volatile.StoreUint8(&o.MDDR.Reg, value)
}
func (o *SCI2_Type) GetMDDR() uint8 {
	return volatile.LoadUint8(&o.MDDR.Reg)
}

// SCI2.DCCR: Data Compare Match Control Register
func (o *SCI2_Type) SetDCCR_DCME(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetDCCR_DCME() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x80) >> 7
}
func (o *SCI2_Type) SetDCCR_IDSEL(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetDCCR_IDSEL() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetDCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetDCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetDCCR_DFER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetDCCR_DFER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetDCCR_DPER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetDCCR_DPER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetDCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x6)|value<<1)
}
func (o *SCI2_Type) GetDCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x6) >> 1
}
func (o *SCI2_Type) SetDCCR_DCMF(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetDCCR_DCMF() uint8 {
	return volatile.LoadUint8(&o.DCCR.Reg) & 0x1
}

// SCI2.CDR: Compare Match Data Register
func (o *SCI2_Type) SetCDR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0xfe00)|value<<9)
}
func (o *SCI2_Type) GetCDR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CDR.Reg) & 0xfe00) >> 9
}
func (o *SCI2_Type) SetCDR_CMPD(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0x1ff)|value)
}
func (o *SCI2_Type) GetCDR_CMPD() uint16 {
	return volatile.LoadUint16(&o.CDR.Reg) & 0x1ff
}

// SCI2.SPTR: Serial Port Register
func (o *SCI2_Type) SetSPTR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0xf8)|value<<3)
}
func (o *SCI2_Type) GetSPTR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0xf8) >> 3
}
func (o *SCI2_Type) SetSPTR_SPB2IO(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSPTR_SPB2IO() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSPTR_SPB2DT(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSPTR_SPB2DT() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSPTR_RXDMON(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSPTR_RXDMON() uint8 {
	return volatile.LoadUint8(&o.SPTR.Reg) & 0x1
}

// Inter-Integrated Circuit 0
type IIC0_Type struct {
	ICCR1  volatile.Register8 // 0x0
	ICCR2  volatile.Register8 // 0x1
	ICMR1  volatile.Register8 // 0x2
	ICMR2  volatile.Register8 // 0x3
	ICMR3  volatile.Register8 // 0x4
	ICFER  volatile.Register8 // 0x5
	ICSER  volatile.Register8 // 0x6
	ICIER  volatile.Register8 // 0x7
	ICSR1  volatile.Register8 // 0x8
	ICSR2  volatile.Register8 // 0x9
	SARL0  volatile.Register8 // 0xA
	SARU0  volatile.Register8 // 0xB
	SARL1  volatile.Register8 // 0xC
	SARU1  volatile.Register8 // 0xD
	SARL2  volatile.Register8 // 0xE
	SARU2  volatile.Register8 // 0xF
	ICBRL  volatile.Register8 // 0x10
	ICBRH  volatile.Register8 // 0x11
	ICDRT  volatile.Register8 // 0x12
	ICDRR  volatile.Register8 // 0x13
	_      [2]byte
	ICWUR  volatile.Register8 // 0x16
	ICWUR2 volatile.Register8 // 0x17
}

// IIC0.ICCR1: I2C Bus Control Register 1
func (o *IIC0_Type) SetICCR1_ICE(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICCR1_ICE() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICCR1_IICRST(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICCR1_IICRST() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICCR1_CLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICCR1_CLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICCR1_SOWP(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICCR1_SOWP() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICCR1_SCLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICCR1_SCLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICCR1_SDAO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICCR1_SDAO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICCR1_SCLI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICCR1_SCLI() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICCR1_SDAI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICCR1_SDAI() uint8 {
	return volatile.LoadUint8(&o.ICCR1.Reg) & 0x1
}

// IIC0.ICCR2: I2C Bus Control Register 2
func (o *IIC0_Type) SetICCR2_BBSY(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICCR2_BBSY() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICCR2_MST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICCR2_MST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICCR2_TRS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICCR2_TRS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICCR2_SP(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICCR2_SP() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICCR2_RS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICCR2_RS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICCR2_ST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICCR2_ST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICCR2_Reserved() uint8 {
	return volatile.LoadUint8(&o.ICCR2.Reg) & 0x1
}

// IIC0.ICMR1: I2C Bus Mode Register 1
func (o *IIC0_Type) SetICMR1_MTWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR1_MTWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICMR1_CKS(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x70)|value<<4)
}
func (o *IIC0_Type) GetICMR1_CKS() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x70) >> 4
}
func (o *IIC0_Type) SetICMR1_BCWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICMR1_BCWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICMR1_BC(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x7)|value)
}
func (o *IIC0_Type) GetICMR1_BC() uint8 {
	return volatile.LoadUint8(&o.ICMR1.Reg) & 0x7
}

// IIC0.ICMR2: I2C Bus Mode Register 2
func (o *IIC0_Type) SetICMR2_DLCS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR2_DLCS() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICMR2_SDDL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x70)|value<<4)
}
func (o *IIC0_Type) GetICMR2_SDDL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x70) >> 4
}
func (o *IIC0_Type) SetICMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICMR2_TMOH(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICMR2_TMOH() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICMR2_TMOL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICMR2_TMOL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICMR2_TMOS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICMR2_TMOS() uint8 {
	return volatile.LoadUint8(&o.ICMR2.Reg) & 0x1
}

// IIC0.ICMR3: I2C Bus Mode Register 3
func (o *IIC0_Type) SetICMR3_SMBS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR3_SMBS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICMR3_WAIT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICMR3_WAIT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICMR3_RDRFS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICMR3_RDRFS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICMR3_ACKWP(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICMR3_ACKWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICMR3_ACKBT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICMR3_ACKBT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICMR3_ACKBR(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICMR3_ACKBR() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICMR3_NF(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x3)|value)
}
func (o *IIC0_Type) GetICMR3_NF() uint8 {
	return volatile.LoadUint8(&o.ICMR3.Reg) & 0x3
}

// IIC0.ICFER: I2C Bus Function Enable Register
func (o *IIC0_Type) SetICFER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICFER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICFER_SCLE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICFER_SCLE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICFER_NFE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICFER_NFE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICFER_NACKE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICFER_NACKE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICFER_SALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICFER_SALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICFER_NALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICFER_NALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICFER_MALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICFER_MALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICFER_TMOE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICFER_TMOE() uint8 {
	return volatile.LoadUint8(&o.ICFER.Reg) & 0x1
}

// IIC0.ICSER: I2C Bus Status Enable Register
func (o *IIC0_Type) SetICSER_HOAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSER_HOAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICSER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICSER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICSER_DIDE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSER_DIDE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICSER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICSER_GCAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSER_GCAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSER_SAR2E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSER_SAR2E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSER_SAR1E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSER_SAR1E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSER_SAR0E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSER_SAR0E() uint8 {
	return volatile.LoadUint8(&o.ICSER.Reg) & 0x1
}

// IIC0.ICIER: I2C Bus Interrupt Enable Register
func (o *IIC0_Type) SetICIER_TIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICIER_TIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICIER_TEIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICIER_TEIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICIER_RIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICIER_RIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICIER_NAKIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICIER_NAKIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICIER_SPIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICIER_SPIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICIER_STIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICIER_STIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICIER_ALIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICIER_ALIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICIER_TMOIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICIER_TMOIE() uint8 {
	return volatile.LoadUint8(&o.ICIER.Reg) & 0x1
}

// IIC0.ICSR1: I2C Bus Status Register 1
func (o *IIC0_Type) SetICSR1_HOA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSR1_HOA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICSR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICSR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICSR1_DID(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSR1_DID() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICSR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICSR1_GCA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSR1_GCA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSR1_AAS2(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSR1_AAS2() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSR1_AAS1(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSR1_AAS1() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSR1_AAS0(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSR1_AAS0() uint8 {
	return volatile.LoadUint8(&o.ICSR1.Reg) & 0x1
}

// IIC0.ICSR2: I2C Bus Status Register 2
func (o *IIC0_Type) SetICSR2_TDRE(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSR2_TDRE() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICSR2_TEND(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICSR2_TEND() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICSR2_RDRF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSR2_RDRF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSR2_NACKF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICSR2_NACKF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICSR2_STOP(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSR2_STOP() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSR2_START(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSR2_START() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSR2_AL(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSR2_AL() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSR2_TMOF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSR2_TMOF() uint8 {
	return volatile.LoadUint8(&o.ICSR2.Reg) & 0x1
}

// IIC0.SARL0: Slave Address Register L%s
func (o *IIC0_Type) SetSARL0(value uint8) {
	volatile.StoreUint8(&o.SARL0.Reg, value)
}
func (o *IIC0_Type) GetSARL0() uint8 {
	return volatile.LoadUint8(&o.SARL0.Reg)
}

// IIC0.SARU0: Slave Address Register U%s
func (o *IIC0_Type) SetSARU0_Reserved(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0xf8)|value<<3)
}
func (o *IIC0_Type) GetSARU0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0xf8) >> 3
}
func (o *IIC0_Type) SetSARU0_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetSARU0_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetSARU0_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetSARU0_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetSARU0_FS(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU0_FS() uint8 {
	return volatile.LoadUint8(&o.SARU0.Reg) & 0x1
}

// IIC0.SARL1: Slave Address Register L%s
func (o *IIC0_Type) SetSARL1(value uint8) {
	volatile.StoreUint8(&o.SARL1.Reg, value)
}
func (o *IIC0_Type) GetSARL1() uint8 {
	return volatile.LoadUint8(&o.SARL1.Reg)
}

// IIC0.SARU1: Slave Address Register U%s
func (o *IIC0_Type) SetSARU1_Reserved(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0xf8)|value<<3)
}
func (o *IIC0_Type) GetSARU1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0xf8) >> 3
}
func (o *IIC0_Type) SetSARU1_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetSARU1_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetSARU1_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetSARU1_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetSARU1_FS(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU1_FS() uint8 {
	return volatile.LoadUint8(&o.SARU1.Reg) & 0x1
}

// IIC0.SARL2: Slave Address Register L%s
func (o *IIC0_Type) SetSARL2(value uint8) {
	volatile.StoreUint8(&o.SARL2.Reg, value)
}
func (o *IIC0_Type) GetSARL2() uint8 {
	return volatile.LoadUint8(&o.SARL2.Reg)
}

// IIC0.SARU2: Slave Address Register U%s
func (o *IIC0_Type) SetSARU2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0xf8)|value<<3)
}
func (o *IIC0_Type) GetSARU2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0xf8) >> 3
}
func (o *IIC0_Type) SetSARU2_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetSARU2_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetSARU2_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetSARU2_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetSARU2_FS(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU2_FS() uint8 {
	return volatile.LoadUint8(&o.SARU2.Reg) & 0x1
}

// IIC0.ICBRL: I2C Bus Bit Rate Low-Level Register
func (o *IIC0_Type) SetICBRL_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICBRL.Reg, volatile.LoadUint8(&o.ICBRL.Reg)&^(0xe0)|value<<5)
}
func (o *IIC0_Type) GetICBRL_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICBRL.Reg) & 0xe0) >> 5
}
func (o *IIC0_Type) SetICBRL_BRL(value uint8) {
	volatile.StoreUint8(&o.ICBRL.Reg, volatile.LoadUint8(&o.ICBRL.Reg)&^(0x1f)|value)
}
func (o *IIC0_Type) GetICBRL_BRL() uint8 {
	return volatile.LoadUint8(&o.ICBRL.Reg) & 0x1f
}

// IIC0.ICBRH: I2C Bus Bit Rate High-Level Register
func (o *IIC0_Type) SetICBRH_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICBRH.Reg, volatile.LoadUint8(&o.ICBRH.Reg)&^(0xe0)|value<<5)
}
func (o *IIC0_Type) GetICBRH_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICBRH.Reg) & 0xe0) >> 5
}
func (o *IIC0_Type) SetICBRH_BRH(value uint8) {
	volatile.StoreUint8(&o.ICBRH.Reg, volatile.LoadUint8(&o.ICBRH.Reg)&^(0x1f)|value)
}
func (o *IIC0_Type) GetICBRH_BRH() uint8 {
	return volatile.LoadUint8(&o.ICBRH.Reg) & 0x1f
}

// IIC0.ICDRT: I2C Bus Transmit Data Register
func (o *IIC0_Type) SetICDRT(value uint8) {
	volatile.StoreUint8(&o.ICDRT.Reg, value)
}
func (o *IIC0_Type) GetICDRT() uint8 {
	return volatile.LoadUint8(&o.ICDRT.Reg)
}

// IIC0.ICDRR: I2C Bus Receive Data Register
func (o *IIC0_Type) SetICDRR(value uint8) {
	volatile.StoreUint8(&o.ICDRR.Reg, value)
}
func (o *IIC0_Type) GetICDRR() uint8 {
	return volatile.LoadUint8(&o.ICDRR.Reg)
}

// IIC0.ICWUR: I2C Bus Wake Up Unit Register
func (o *IIC0_Type) SetICWUR_WUE(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICWUR_WUE() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICWUR_WUIE(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICWUR_WUIE() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICWUR_WUF(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICWUR_WUF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICWUR_WUACK(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICWUR_WUACK() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICWUR_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0xe)|value<<1)
}
func (o *IIC0_Type) GetICWUR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0xe) >> 1
}
func (o *IIC0_Type) SetICWUR_WUAFA(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICWUR_WUAFA() uint8 {
	return volatile.LoadUint8(&o.ICWUR.Reg) & 0x1
}

// IIC0.ICWUR2: I2C Bus Wake up Unit Register 2
func (o *IIC0_Type) SetICWUR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0xf8)|value<<3)
}
func (o *IIC0_Type) GetICWUR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICWUR2.Reg) & 0xf8) >> 3
}
func (o *IIC0_Type) SetICWUR2_WUSYF(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICWUR2_WUSYF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICWUR2_WUASYF(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICWUR2_WUASYF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICWUR2_WUSEN(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICWUR2_WUSEN() uint8 {
	return volatile.LoadUint8(&o.ICWUR2.Reg) & 0x1
}

// Inter-Integrated Circuit 1
type IIC1_Type struct {
	ICCR1 volatile.Register8 // 0x0
	ICCR2 volatile.Register8 // 0x1
	ICMR1 volatile.Register8 // 0x2
	ICMR2 volatile.Register8 // 0x3
	ICMR3 volatile.Register8 // 0x4
	ICFER volatile.Register8 // 0x5
	ICSER volatile.Register8 // 0x6
	ICIER volatile.Register8 // 0x7
	ICSR1 volatile.Register8 // 0x8
	ICSR2 volatile.Register8 // 0x9
	SARL0 volatile.Register8 // 0xA
	SARU0 volatile.Register8 // 0xB
	SARL1 volatile.Register8 // 0xC
	SARU1 volatile.Register8 // 0xD
	SARL2 volatile.Register8 // 0xE
	SARU2 volatile.Register8 // 0xF
	ICBRL volatile.Register8 // 0x10
	ICBRH volatile.Register8 // 0x11
	ICDRT volatile.Register8 // 0x12
	ICDRR volatile.Register8 // 0x13
}

// IIC1.ICCR1: I2C Bus Control Register 1
func (o *IIC1_Type) SetICCR1_ICE(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICCR1_ICE() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICCR1_IICRST(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICCR1_IICRST() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICCR1_CLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICCR1_CLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICCR1_SOWP(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICCR1_SOWP() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICCR1_SCLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICCR1_SCLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICCR1_SDAO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICCR1_SDAO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICCR1_SCLI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICCR1_SCLI() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICCR1_SDAI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICCR1_SDAI() uint8 {
	return volatile.LoadUint8(&o.ICCR1.Reg) & 0x1
}

// IIC1.ICCR2: I2C Bus Control Register 2
func (o *IIC1_Type) SetICCR2_BBSY(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICCR2_BBSY() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICCR2_MST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICCR2_MST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICCR2_TRS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICCR2_TRS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICCR2_SP(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICCR2_SP() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICCR2_RS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICCR2_RS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICCR2_ST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICCR2_ST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICCR2_Reserved() uint8 {
	return volatile.LoadUint8(&o.ICCR2.Reg) & 0x1
}

// IIC1.ICMR1: I2C Bus Mode Register 1
func (o *IIC1_Type) SetICMR1_MTWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICMR1_MTWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICMR1_CKS(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x70)|value<<4)
}
func (o *IIC1_Type) GetICMR1_CKS() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x70) >> 4
}
func (o *IIC1_Type) SetICMR1_BCWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICMR1_BCWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICMR1_BC(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x7)|value)
}
func (o *IIC1_Type) GetICMR1_BC() uint8 {
	return volatile.LoadUint8(&o.ICMR1.Reg) & 0x7
}

// IIC1.ICMR2: I2C Bus Mode Register 2
func (o *IIC1_Type) SetICMR2_DLCS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICMR2_DLCS() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICMR2_SDDL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x70)|value<<4)
}
func (o *IIC1_Type) GetICMR2_SDDL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x70) >> 4
}
func (o *IIC1_Type) SetICMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICMR2_TMOH(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICMR2_TMOH() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICMR2_TMOL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICMR2_TMOL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICMR2_TMOS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICMR2_TMOS() uint8 {
	return volatile.LoadUint8(&o.ICMR2.Reg) & 0x1
}

// IIC1.ICMR3: I2C Bus Mode Register 3
func (o *IIC1_Type) SetICMR3_SMBS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICMR3_SMBS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICMR3_WAIT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICMR3_WAIT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICMR3_RDRFS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICMR3_RDRFS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICMR3_ACKWP(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICMR3_ACKWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICMR3_ACKBT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICMR3_ACKBT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICMR3_ACKBR(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICMR3_ACKBR() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICMR3_NF(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x3)|value)
}
func (o *IIC1_Type) GetICMR3_NF() uint8 {
	return volatile.LoadUint8(&o.ICMR3.Reg) & 0x3
}

// IIC1.ICFER: I2C Bus Function Enable Register
func (o *IIC1_Type) SetICFER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICFER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICFER_SCLE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICFER_SCLE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICFER_NFE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICFER_NFE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICFER_NACKE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICFER_NACKE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICFER_SALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICFER_SALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICFER_NALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICFER_NALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICFER_MALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICFER_MALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICFER_TMOE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICFER_TMOE() uint8 {
	return volatile.LoadUint8(&o.ICFER.Reg) & 0x1
}

// IIC1.ICSER: I2C Bus Status Enable Register
func (o *IIC1_Type) SetICSER_HOAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICSER_HOAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICSER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICSER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICSER_DIDE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICSER_DIDE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICSER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICSER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICSER_GCAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICSER_GCAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICSER_SAR2E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICSER_SAR2E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICSER_SAR1E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICSER_SAR1E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICSER_SAR0E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICSER_SAR0E() uint8 {
	return volatile.LoadUint8(&o.ICSER.Reg) & 0x1
}

// IIC1.ICIER: I2C Bus Interrupt Enable Register
func (o *IIC1_Type) SetICIER_TIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICIER_TIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICIER_TEIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICIER_TEIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICIER_RIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICIER_RIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICIER_NAKIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICIER_NAKIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICIER_SPIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICIER_SPIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICIER_STIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICIER_STIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICIER_ALIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICIER_ALIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICIER_TMOIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICIER_TMOIE() uint8 {
	return volatile.LoadUint8(&o.ICIER.Reg) & 0x1
}

// IIC1.ICSR1: I2C Bus Status Register 1
func (o *IIC1_Type) SetICSR1_HOA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICSR1_HOA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICSR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICSR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICSR1_DID(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICSR1_DID() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICSR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICSR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICSR1_GCA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICSR1_GCA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICSR1_AAS2(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICSR1_AAS2() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICSR1_AAS1(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICSR1_AAS1() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICSR1_AAS0(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICSR1_AAS0() uint8 {
	return volatile.LoadUint8(&o.ICSR1.Reg) & 0x1
}

// IIC1.ICSR2: I2C Bus Status Register 2
func (o *IIC1_Type) SetICSR2_TDRE(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICSR2_TDRE() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICSR2_TEND(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICSR2_TEND() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICSR2_RDRF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICSR2_RDRF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICSR2_NACKF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICSR2_NACKF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICSR2_STOP(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICSR2_STOP() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICSR2_START(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICSR2_START() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICSR2_AL(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICSR2_AL() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICSR2_TMOF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICSR2_TMOF() uint8 {
	return volatile.LoadUint8(&o.ICSR2.Reg) & 0x1
}

// IIC1.SARL0: Slave Address Register L%s
func (o *IIC1_Type) SetSARL0(value uint8) {
	volatile.StoreUint8(&o.SARL0.Reg, value)
}
func (o *IIC1_Type) GetSARL0() uint8 {
	return volatile.LoadUint8(&o.SARL0.Reg)
}

// IIC1.SARU0: Slave Address Register U%s
func (o *IIC1_Type) SetSARU0_Reserved(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0xf8)|value<<3)
}
func (o *IIC1_Type) GetSARU0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0xf8) >> 3
}
func (o *IIC1_Type) SetSARU0_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetSARU0_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetSARU0_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetSARU0_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetSARU0_FS(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetSARU0_FS() uint8 {
	return volatile.LoadUint8(&o.SARU0.Reg) & 0x1
}

// IIC1.SARL1: Slave Address Register L%s
func (o *IIC1_Type) SetSARL1(value uint8) {
	volatile.StoreUint8(&o.SARL1.Reg, value)
}
func (o *IIC1_Type) GetSARL1() uint8 {
	return volatile.LoadUint8(&o.SARL1.Reg)
}

// IIC1.SARU1: Slave Address Register U%s
func (o *IIC1_Type) SetSARU1_Reserved(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0xf8)|value<<3)
}
func (o *IIC1_Type) GetSARU1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0xf8) >> 3
}
func (o *IIC1_Type) SetSARU1_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetSARU1_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetSARU1_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetSARU1_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetSARU1_FS(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetSARU1_FS() uint8 {
	return volatile.LoadUint8(&o.SARU1.Reg) & 0x1
}

// IIC1.SARL2: Slave Address Register L%s
func (o *IIC1_Type) SetSARL2(value uint8) {
	volatile.StoreUint8(&o.SARL2.Reg, value)
}
func (o *IIC1_Type) GetSARL2() uint8 {
	return volatile.LoadUint8(&o.SARL2.Reg)
}

// IIC1.SARU2: Slave Address Register U%s
func (o *IIC1_Type) SetSARU2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0xf8)|value<<3)
}
func (o *IIC1_Type) GetSARU2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0xf8) >> 3
}
func (o *IIC1_Type) SetSARU2_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetSARU2_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetSARU2_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetSARU2_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetSARU2_FS(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetSARU2_FS() uint8 {
	return volatile.LoadUint8(&o.SARU2.Reg) & 0x1
}

// IIC1.ICBRL: I2C Bus Bit Rate Low-Level Register
func (o *IIC1_Type) SetICBRL_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICBRL.Reg, volatile.LoadUint8(&o.ICBRL.Reg)&^(0xe0)|value<<5)
}
func (o *IIC1_Type) GetICBRL_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICBRL.Reg) & 0xe0) >> 5
}
func (o *IIC1_Type) SetICBRL_BRL(value uint8) {
	volatile.StoreUint8(&o.ICBRL.Reg, volatile.LoadUint8(&o.ICBRL.Reg)&^(0x1f)|value)
}
func (o *IIC1_Type) GetICBRL_BRL() uint8 {
	return volatile.LoadUint8(&o.ICBRL.Reg) & 0x1f
}

// IIC1.ICBRH: I2C Bus Bit Rate High-Level Register
func (o *IIC1_Type) SetICBRH_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICBRH.Reg, volatile.LoadUint8(&o.ICBRH.Reg)&^(0xe0)|value<<5)
}
func (o *IIC1_Type) GetICBRH_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICBRH.Reg) & 0xe0) >> 5
}
func (o *IIC1_Type) SetICBRH_BRH(value uint8) {
	volatile.StoreUint8(&o.ICBRH.Reg, volatile.LoadUint8(&o.ICBRH.Reg)&^(0x1f)|value)
}
func (o *IIC1_Type) GetICBRH_BRH() uint8 {
	return volatile.LoadUint8(&o.ICBRH.Reg) & 0x1f
}

// IIC1.ICDRT: I2C Bus Transmit Data Register
func (o *IIC1_Type) SetICDRT(value uint8) {
	volatile.StoreUint8(&o.ICDRT.Reg, value)
}
func (o *IIC1_Type) GetICDRT() uint8 {
	return volatile.LoadUint8(&o.ICDRT.Reg)
}

// IIC1.ICDRR: I2C Bus Receive Data Register
func (o *IIC1_Type) SetICDRR(value uint8) {
	volatile.StoreUint8(&o.ICDRR.Reg, value)
}
func (o *IIC1_Type) GetICDRR() uint8 {
	return volatile.LoadUint8(&o.ICDRR.Reg)
}

// CAN0 Module
type CAN0_Type struct {
	_       [512]byte
	MB0_ID  volatile.Register32    // 0x200
	MB0_DL  volatile.Register16    // 0x204
	MB0_D0  volatile.Register8     // 0x206
	MB0_D1  volatile.Register8     // 0x207
	MB0_D2  volatile.Register8     // 0x208
	MB0_D3  volatile.Register8     // 0x209
	MB0_D4  volatile.Register8     // 0x20A
	MB0_D5  volatile.Register8     // 0x20B
	MB0_D6  volatile.Register8     // 0x20C
	MB0_D7  volatile.Register8     // 0x20D
	MB0_TS  volatile.Register16    // 0x20E
	MB1_ID  volatile.Register32    // 0x210
	MB1_DL  volatile.Register16    // 0x214
	MB1_D0  volatile.Register8     // 0x216
	MB1_D1  volatile.Register8     // 0x217
	MB1_D2  volatile.Register8     // 0x218
	MB1_D3  volatile.Register8     // 0x219
	MB1_D4  volatile.Register8     // 0x21A
	MB1_D5  volatile.Register8     // 0x21B
	MB1_D6  volatile.Register8     // 0x21C
	MB1_D7  volatile.Register8     // 0x21D
	MB1_TS  volatile.Register16    // 0x21E
	MB2_ID  volatile.Register32    // 0x220
	MB2_DL  volatile.Register16    // 0x224
	MB2_D0  volatile.Register8     // 0x226
	MB2_D1  volatile.Register8     // 0x227
	MB2_D2  volatile.Register8     // 0x228
	MB2_D3  volatile.Register8     // 0x229
	MB2_D4  volatile.Register8     // 0x22A
	MB2_D5  volatile.Register8     // 0x22B
	MB2_D6  volatile.Register8     // 0x22C
	MB2_D7  volatile.Register8     // 0x22D
	MB2_TS  volatile.Register16    // 0x22E
	MB3_ID  volatile.Register32    // 0x230
	MB3_DL  volatile.Register16    // 0x234
	MB3_D0  volatile.Register8     // 0x236
	MB3_D1  volatile.Register8     // 0x237
	MB3_D2  volatile.Register8     // 0x238
	MB3_D3  volatile.Register8     // 0x239
	MB3_D4  volatile.Register8     // 0x23A
	MB3_D5  volatile.Register8     // 0x23B
	MB3_D6  volatile.Register8     // 0x23C
	MB3_D7  volatile.Register8     // 0x23D
	MB3_TS  volatile.Register16    // 0x23E
	MB4_ID  volatile.Register32    // 0x240
	MB4_DL  volatile.Register16    // 0x244
	MB4_D0  volatile.Register8     // 0x246
	MB4_D1  volatile.Register8     // 0x247
	MB4_D2  volatile.Register8     // 0x248
	MB4_D3  volatile.Register8     // 0x249
	MB4_D4  volatile.Register8     // 0x24A
	MB4_D5  volatile.Register8     // 0x24B
	MB4_D6  volatile.Register8     // 0x24C
	MB4_D7  volatile.Register8     // 0x24D
	MB4_TS  volatile.Register16    // 0x24E
	MB5_ID  volatile.Register32    // 0x250
	MB5_DL  volatile.Register16    // 0x254
	MB5_D0  volatile.Register8     // 0x256
	MB5_D1  volatile.Register8     // 0x257
	MB5_D2  volatile.Register8     // 0x258
	MB5_D3  volatile.Register8     // 0x259
	MB5_D4  volatile.Register8     // 0x25A
	MB5_D5  volatile.Register8     // 0x25B
	MB5_D6  volatile.Register8     // 0x25C
	MB5_D7  volatile.Register8     // 0x25D
	MB5_TS  volatile.Register16    // 0x25E
	MB6_ID  volatile.Register32    // 0x260
	MB6_DL  volatile.Register16    // 0x264
	MB6_D0  volatile.Register8     // 0x266
	MB6_D1  volatile.Register8     // 0x267
	MB6_D2  volatile.Register8     // 0x268
	MB6_D3  volatile.Register8     // 0x269
	MB6_D4  volatile.Register8     // 0x26A
	MB6_D5  volatile.Register8     // 0x26B
	MB6_D6  volatile.Register8     // 0x26C
	MB6_D7  volatile.Register8     // 0x26D
	MB6_TS  volatile.Register16    // 0x26E
	MB7_ID  volatile.Register32    // 0x270
	MB7_DL  volatile.Register16    // 0x274
	MB7_D0  volatile.Register8     // 0x276
	MB7_D1  volatile.Register8     // 0x277
	MB7_D2  volatile.Register8     // 0x278
	MB7_D3  volatile.Register8     // 0x279
	MB7_D4  volatile.Register8     // 0x27A
	MB7_D5  volatile.Register8     // 0x27B
	MB7_D6  volatile.Register8     // 0x27C
	MB7_D7  volatile.Register8     // 0x27D
	MB7_TS  volatile.Register16    // 0x27E
	MB8_ID  volatile.Register32    // 0x280
	MB8_DL  volatile.Register16    // 0x284
	MB8_D0  volatile.Register8     // 0x286
	MB8_D1  volatile.Register8     // 0x287
	MB8_D2  volatile.Register8     // 0x288
	MB8_D3  volatile.Register8     // 0x289
	MB8_D4  volatile.Register8     // 0x28A
	MB8_D5  volatile.Register8     // 0x28B
	MB8_D6  volatile.Register8     // 0x28C
	MB8_D7  volatile.Register8     // 0x28D
	MB8_TS  volatile.Register16    // 0x28E
	MB9_ID  volatile.Register32    // 0x290
	MB9_DL  volatile.Register16    // 0x294
	MB9_D0  volatile.Register8     // 0x296
	MB9_D1  volatile.Register8     // 0x297
	MB9_D2  volatile.Register8     // 0x298
	MB9_D3  volatile.Register8     // 0x299
	MB9_D4  volatile.Register8     // 0x29A
	MB9_D5  volatile.Register8     // 0x29B
	MB9_D6  volatile.Register8     // 0x29C
	MB9_D7  volatile.Register8     // 0x29D
	MB9_TS  volatile.Register16    // 0x29E
	MB10_ID volatile.Register32    // 0x2A0
	MB10_DL volatile.Register16    // 0x2A4
	MB10_D0 volatile.Register8     // 0x2A6
	MB10_D1 volatile.Register8     // 0x2A7
	MB10_D2 volatile.Register8     // 0x2A8
	MB10_D3 volatile.Register8     // 0x2A9
	MB10_D4 volatile.Register8     // 0x2AA
	MB10_D5 volatile.Register8     // 0x2AB
	MB10_D6 volatile.Register8     // 0x2AC
	MB10_D7 volatile.Register8     // 0x2AD
	MB10_TS volatile.Register16    // 0x2AE
	MB11_ID volatile.Register32    // 0x2B0
	MB11_DL volatile.Register16    // 0x2B4
	MB11_D0 volatile.Register8     // 0x2B6
	MB11_D1 volatile.Register8     // 0x2B7
	MB11_D2 volatile.Register8     // 0x2B8
	MB11_D3 volatile.Register8     // 0x2B9
	MB11_D4 volatile.Register8     // 0x2BA
	MB11_D5 volatile.Register8     // 0x2BB
	MB11_D6 volatile.Register8     // 0x2BC
	MB11_D7 volatile.Register8     // 0x2BD
	MB11_TS volatile.Register16    // 0x2BE
	MB12_ID volatile.Register32    // 0x2C0
	MB12_DL volatile.Register16    // 0x2C4
	MB12_D0 volatile.Register8     // 0x2C6
	MB12_D1 volatile.Register8     // 0x2C7
	MB12_D2 volatile.Register8     // 0x2C8
	MB12_D3 volatile.Register8     // 0x2C9
	MB12_D4 volatile.Register8     // 0x2CA
	MB12_D5 volatile.Register8     // 0x2CB
	MB12_D6 volatile.Register8     // 0x2CC
	MB12_D7 volatile.Register8     // 0x2CD
	MB12_TS volatile.Register16    // 0x2CE
	MB13_ID volatile.Register32    // 0x2D0
	MB13_DL volatile.Register16    // 0x2D4
	MB13_D0 volatile.Register8     // 0x2D6
	MB13_D1 volatile.Register8     // 0x2D7
	MB13_D2 volatile.Register8     // 0x2D8
	MB13_D3 volatile.Register8     // 0x2D9
	MB13_D4 volatile.Register8     // 0x2DA
	MB13_D5 volatile.Register8     // 0x2DB
	MB13_D6 volatile.Register8     // 0x2DC
	MB13_D7 volatile.Register8     // 0x2DD
	MB13_TS volatile.Register16    // 0x2DE
	MB14_ID volatile.Register32    // 0x2E0
	MB14_DL volatile.Register16    // 0x2E4
	MB14_D0 volatile.Register8     // 0x2E6
	MB14_D1 volatile.Register8     // 0x2E7
	MB14_D2 volatile.Register8     // 0x2E8
	MB14_D3 volatile.Register8     // 0x2E9
	MB14_D4 volatile.Register8     // 0x2EA
	MB14_D5 volatile.Register8     // 0x2EB
	MB14_D6 volatile.Register8     // 0x2EC
	MB14_D7 volatile.Register8     // 0x2ED
	MB14_TS volatile.Register16    // 0x2EE
	MB15_ID volatile.Register32    // 0x2F0
	MB15_DL volatile.Register16    // 0x2F4
	MB15_D0 volatile.Register8     // 0x2F6
	MB15_D1 volatile.Register8     // 0x2F7
	MB15_D2 volatile.Register8     // 0x2F8
	MB15_D3 volatile.Register8     // 0x2F9
	MB15_D4 volatile.Register8     // 0x2FA
	MB15_D5 volatile.Register8     // 0x2FB
	MB15_D6 volatile.Register8     // 0x2FC
	MB15_D7 volatile.Register8     // 0x2FD
	MB15_TS volatile.Register16    // 0x2FE
	MB16_ID volatile.Register32    // 0x300
	MB16_DL volatile.Register16    // 0x304
	MB16_D0 volatile.Register8     // 0x306
	MB16_D1 volatile.Register8     // 0x307
	MB16_D2 volatile.Register8     // 0x308
	MB16_D3 volatile.Register8     // 0x309
	MB16_D4 volatile.Register8     // 0x30A
	MB16_D5 volatile.Register8     // 0x30B
	MB16_D6 volatile.Register8     // 0x30C
	MB16_D7 volatile.Register8     // 0x30D
	MB16_TS volatile.Register16    // 0x30E
	MB17_ID volatile.Register32    // 0x310
	MB17_DL volatile.Register16    // 0x314
	MB17_D0 volatile.Register8     // 0x316
	MB17_D1 volatile.Register8     // 0x317
	MB17_D2 volatile.Register8     // 0x318
	MB17_D3 volatile.Register8     // 0x319
	MB17_D4 volatile.Register8     // 0x31A
	MB17_D5 volatile.Register8     // 0x31B
	MB17_D6 volatile.Register8     // 0x31C
	MB17_D7 volatile.Register8     // 0x31D
	MB17_TS volatile.Register16    // 0x31E
	MB18_ID volatile.Register32    // 0x320
	MB18_DL volatile.Register16    // 0x324
	MB18_D0 volatile.Register8     // 0x326
	MB18_D1 volatile.Register8     // 0x327
	MB18_D2 volatile.Register8     // 0x328
	MB18_D3 volatile.Register8     // 0x329
	MB18_D4 volatile.Register8     // 0x32A
	MB18_D5 volatile.Register8     // 0x32B
	MB18_D6 volatile.Register8     // 0x32C
	MB18_D7 volatile.Register8     // 0x32D
	MB18_TS volatile.Register16    // 0x32E
	MB19_ID volatile.Register32    // 0x330
	MB19_DL volatile.Register16    // 0x334
	MB19_D0 volatile.Register8     // 0x336
	MB19_D1 volatile.Register8     // 0x337
	MB19_D2 volatile.Register8     // 0x338
	MB19_D3 volatile.Register8     // 0x339
	MB19_D4 volatile.Register8     // 0x33A
	MB19_D5 volatile.Register8     // 0x33B
	MB19_D6 volatile.Register8     // 0x33C
	MB19_D7 volatile.Register8     // 0x33D
	MB19_TS volatile.Register16    // 0x33E
	MB20_ID volatile.Register32    // 0x340
	MB20_DL volatile.Register16    // 0x344
	MB20_D0 volatile.Register8     // 0x346
	MB20_D1 volatile.Register8     // 0x347
	MB20_D2 volatile.Register8     // 0x348
	MB20_D3 volatile.Register8     // 0x349
	MB20_D4 volatile.Register8     // 0x34A
	MB20_D5 volatile.Register8     // 0x34B
	MB20_D6 volatile.Register8     // 0x34C
	MB20_D7 volatile.Register8     // 0x34D
	MB20_TS volatile.Register16    // 0x34E
	MB21_ID volatile.Register32    // 0x350
	MB21_DL volatile.Register16    // 0x354
	MB21_D0 volatile.Register8     // 0x356
	MB21_D1 volatile.Register8     // 0x357
	MB21_D2 volatile.Register8     // 0x358
	MB21_D3 volatile.Register8     // 0x359
	MB21_D4 volatile.Register8     // 0x35A
	MB21_D5 volatile.Register8     // 0x35B
	MB21_D6 volatile.Register8     // 0x35C
	MB21_D7 volatile.Register8     // 0x35D
	MB21_TS volatile.Register16    // 0x35E
	MB22_ID volatile.Register32    // 0x360
	MB22_DL volatile.Register16    // 0x364
	MB22_D0 volatile.Register8     // 0x366
	MB22_D1 volatile.Register8     // 0x367
	MB22_D2 volatile.Register8     // 0x368
	MB22_D3 volatile.Register8     // 0x369
	MB22_D4 volatile.Register8     // 0x36A
	MB22_D5 volatile.Register8     // 0x36B
	MB22_D6 volatile.Register8     // 0x36C
	MB22_D7 volatile.Register8     // 0x36D
	MB22_TS volatile.Register16    // 0x36E
	MB23_ID volatile.Register32    // 0x370
	MB23_DL volatile.Register16    // 0x374
	MB23_D0 volatile.Register8     // 0x376
	MB23_D1 volatile.Register8     // 0x377
	MB23_D2 volatile.Register8     // 0x378
	MB23_D3 volatile.Register8     // 0x379
	MB23_D4 volatile.Register8     // 0x37A
	MB23_D5 volatile.Register8     // 0x37B
	MB23_D6 volatile.Register8     // 0x37C
	MB23_D7 volatile.Register8     // 0x37D
	MB23_TS volatile.Register16    // 0x37E
	MB24_ID volatile.Register32    // 0x380
	MB24_DL volatile.Register16    // 0x384
	MB24_D0 volatile.Register8     // 0x386
	MB24_D1 volatile.Register8     // 0x387
	MB24_D2 volatile.Register8     // 0x388
	MB24_D3 volatile.Register8     // 0x389
	MB24_D4 volatile.Register8     // 0x38A
	MB24_D5 volatile.Register8     // 0x38B
	MB24_D6 volatile.Register8     // 0x38C
	MB24_D7 volatile.Register8     // 0x38D
	MB24_TS volatile.Register16    // 0x38E
	MB25_ID volatile.Register32    // 0x390
	MB25_DL volatile.Register16    // 0x394
	MB25_D0 volatile.Register8     // 0x396
	MB25_D1 volatile.Register8     // 0x397
	MB25_D2 volatile.Register8     // 0x398
	MB25_D3 volatile.Register8     // 0x399
	MB25_D4 volatile.Register8     // 0x39A
	MB25_D5 volatile.Register8     // 0x39B
	MB25_D6 volatile.Register8     // 0x39C
	MB25_D7 volatile.Register8     // 0x39D
	MB25_TS volatile.Register16    // 0x39E
	MB26_ID volatile.Register32    // 0x3A0
	MB26_DL volatile.Register16    // 0x3A4
	MB26_D0 volatile.Register8     // 0x3A6
	MB26_D1 volatile.Register8     // 0x3A7
	MB26_D2 volatile.Register8     // 0x3A8
	MB26_D3 volatile.Register8     // 0x3A9
	MB26_D4 volatile.Register8     // 0x3AA
	MB26_D5 volatile.Register8     // 0x3AB
	MB26_D6 volatile.Register8     // 0x3AC
	MB26_D7 volatile.Register8     // 0x3AD
	MB26_TS volatile.Register16    // 0x3AE
	MB27_ID volatile.Register32    // 0x3B0
	MB27_DL volatile.Register16    // 0x3B4
	MB27_D0 volatile.Register8     // 0x3B6
	MB27_D1 volatile.Register8     // 0x3B7
	MB27_D2 volatile.Register8     // 0x3B8
	MB27_D3 volatile.Register8     // 0x3B9
	MB27_D4 volatile.Register8     // 0x3BA
	MB27_D5 volatile.Register8     // 0x3BB
	MB27_D6 volatile.Register8     // 0x3BC
	MB27_D7 volatile.Register8     // 0x3BD
	MB27_TS volatile.Register16    // 0x3BE
	MB28_ID volatile.Register32    // 0x3C0
	MB28_DL volatile.Register16    // 0x3C4
	MB28_D0 volatile.Register8     // 0x3C6
	MB28_D1 volatile.Register8     // 0x3C7
	MB28_D2 volatile.Register8     // 0x3C8
	MB28_D3 volatile.Register8     // 0x3C9
	MB28_D4 volatile.Register8     // 0x3CA
	MB28_D5 volatile.Register8     // 0x3CB
	MB28_D6 volatile.Register8     // 0x3CC
	MB28_D7 volatile.Register8     // 0x3CD
	MB28_TS volatile.Register16    // 0x3CE
	MB29_ID volatile.Register32    // 0x3D0
	MB29_DL volatile.Register16    // 0x3D4
	MB29_D0 volatile.Register8     // 0x3D6
	MB29_D1 volatile.Register8     // 0x3D7
	MB29_D2 volatile.Register8     // 0x3D8
	MB29_D3 volatile.Register8     // 0x3D9
	MB29_D4 volatile.Register8     // 0x3DA
	MB29_D5 volatile.Register8     // 0x3DB
	MB29_D6 volatile.Register8     // 0x3DC
	MB29_D7 volatile.Register8     // 0x3DD
	MB29_TS volatile.Register16    // 0x3DE
	MB30_ID volatile.Register32    // 0x3E0
	MB30_DL volatile.Register16    // 0x3E4
	MB30_D0 volatile.Register8     // 0x3E6
	MB30_D1 volatile.Register8     // 0x3E7
	MB30_D2 volatile.Register8     // 0x3E8
	MB30_D3 volatile.Register8     // 0x3E9
	MB30_D4 volatile.Register8     // 0x3EA
	MB30_D5 volatile.Register8     // 0x3EB
	MB30_D6 volatile.Register8     // 0x3EC
	MB30_D7 volatile.Register8     // 0x3ED
	MB30_TS volatile.Register16    // 0x3EE
	MB31_ID volatile.Register32    // 0x3F0
	MB31_DL volatile.Register16    // 0x3F4
	MB31_D0 volatile.Register8     // 0x3F6
	MB31_D1 volatile.Register8     // 0x3F7
	MB31_D2 volatile.Register8     // 0x3F8
	MB31_D3 volatile.Register8     // 0x3F9
	MB31_D4 volatile.Register8     // 0x3FA
	MB31_D5 volatile.Register8     // 0x3FB
	MB31_D6 volatile.Register8     // 0x3FC
	MB31_D7 volatile.Register8     // 0x3FD
	MB31_TS volatile.Register16    // 0x3FE
	MKR     [8]volatile.Register32 // 0x400
	FIDCR0  volatile.Register32    // 0x420
	FIDCR1  volatile.Register32    // 0x424
	MKIVLR  volatile.Register32    // 0x428
	MIER    volatile.Register32    // 0x42C
	_       [1008]byte
	MCTL_TX [32]volatile.Register8 // 0x820
	CTLR    volatile.Register16    // 0x840
	STR     volatile.Register16    // 0x842
	BCR     volatile.Register32    // 0x844
	RFCR    volatile.Register8     // 0x848
	RFPCR   volatile.Register8     // 0x849
	TFCR    volatile.Register8     // 0x84A
	TFPCR   volatile.Register8     // 0x84B
	EIER    volatile.Register8     // 0x84C
	EIFR    volatile.Register8     // 0x84D
	RECR    volatile.Register8     // 0x84E
	TECR    volatile.Register8     // 0x84F
	ECSR    volatile.Register8     // 0x850
	CSSR    volatile.Register8     // 0x851
	MSSR    volatile.Register8     // 0x852
	MSMR    volatile.Register8     // 0x853
	TSR     volatile.Register16    // 0x854
	AFSR    volatile.Register16    // 0x856
	TCR     volatile.Register8     // 0x858
}

// CAN0.MB0_ID: Mailbox Register
func (o *CAN0_Type) SetMB0_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB0_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB0_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB0_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB0_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB0_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB0_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB0_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB0_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB0_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB0_ID.Reg) & 0x3ffff
}

// CAN0.MB0_DL: Mailbox Register
func (o *CAN0_Type) SetMB0_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB0_DL.Reg, volatile.LoadUint16(&o.MB0_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB0_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB0_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB0_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB0_DL.Reg, volatile.LoadUint16(&o.MB0_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB0_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB0_DL.Reg) & 0xf
}

// CAN0.MB0_D0: Mailbox Register
func (o *CAN0_Type) SetMB0_D0(value uint8) {
	volatile.StoreUint8(&o.MB0_D0.Reg, value)
}
func (o *CAN0_Type) GetMB0_D0() uint8 {
	return volatile.LoadUint8(&o.MB0_D0.Reg)
}

// CAN0.MB0_D1: Mailbox Register
func (o *CAN0_Type) SetMB0_D1(value uint8) {
	volatile.StoreUint8(&o.MB0_D1.Reg, value)
}
func (o *CAN0_Type) GetMB0_D1() uint8 {
	return volatile.LoadUint8(&o.MB0_D1.Reg)
}

// CAN0.MB0_D2: Mailbox Register
func (o *CAN0_Type) SetMB0_D2(value uint8) {
	volatile.StoreUint8(&o.MB0_D2.Reg, value)
}
func (o *CAN0_Type) GetMB0_D2() uint8 {
	return volatile.LoadUint8(&o.MB0_D2.Reg)
}

// CAN0.MB0_D3: Mailbox Register
func (o *CAN0_Type) SetMB0_D3(value uint8) {
	volatile.StoreUint8(&o.MB0_D3.Reg, value)
}
func (o *CAN0_Type) GetMB0_D3() uint8 {
	return volatile.LoadUint8(&o.MB0_D3.Reg)
}

// CAN0.MB0_D4: Mailbox Register
func (o *CAN0_Type) SetMB0_D4(value uint8) {
	volatile.StoreUint8(&o.MB0_D4.Reg, value)
}
func (o *CAN0_Type) GetMB0_D4() uint8 {
	return volatile.LoadUint8(&o.MB0_D4.Reg)
}

// CAN0.MB0_D5: Mailbox Register
func (o *CAN0_Type) SetMB0_D5(value uint8) {
	volatile.StoreUint8(&o.MB0_D5.Reg, value)
}
func (o *CAN0_Type) GetMB0_D5() uint8 {
	return volatile.LoadUint8(&o.MB0_D5.Reg)
}

// CAN0.MB0_D6: Mailbox Register
func (o *CAN0_Type) SetMB0_D6(value uint8) {
	volatile.StoreUint8(&o.MB0_D6.Reg, value)
}
func (o *CAN0_Type) GetMB0_D6() uint8 {
	return volatile.LoadUint8(&o.MB0_D6.Reg)
}

// CAN0.MB0_D7: Mailbox Register
func (o *CAN0_Type) SetMB0_D7(value uint8) {
	volatile.StoreUint8(&o.MB0_D7.Reg, value)
}
func (o *CAN0_Type) GetMB0_D7() uint8 {
	return volatile.LoadUint8(&o.MB0_D7.Reg)
}

// CAN0.MB0_TS: Mailbox Register
func (o *CAN0_Type) SetMB0_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB0_TS.Reg, volatile.LoadUint16(&o.MB0_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB0_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB0_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB0_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB0_TS.Reg, volatile.LoadUint16(&o.MB0_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB0_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB0_TS.Reg) & 0xff
}

// CAN0.MB1_ID: Mailbox Register
func (o *CAN0_Type) SetMB1_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB1_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB1_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB1_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB1_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB1_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB1_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB1_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB1_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB1_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB1_ID.Reg) & 0x3ffff
}

// CAN0.MB1_DL: Mailbox Register
func (o *CAN0_Type) SetMB1_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB1_DL.Reg, volatile.LoadUint16(&o.MB1_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB1_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB1_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB1_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB1_DL.Reg, volatile.LoadUint16(&o.MB1_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB1_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB1_DL.Reg) & 0xf
}

// CAN0.MB1_D0: Mailbox Register
func (o *CAN0_Type) SetMB1_D0(value uint8) {
	volatile.StoreUint8(&o.MB1_D0.Reg, value)
}
func (o *CAN0_Type) GetMB1_D0() uint8 {
	return volatile.LoadUint8(&o.MB1_D0.Reg)
}

// CAN0.MB1_D1: Mailbox Register
func (o *CAN0_Type) SetMB1_D1(value uint8) {
	volatile.StoreUint8(&o.MB1_D1.Reg, value)
}
func (o *CAN0_Type) GetMB1_D1() uint8 {
	return volatile.LoadUint8(&o.MB1_D1.Reg)
}

// CAN0.MB1_D2: Mailbox Register
func (o *CAN0_Type) SetMB1_D2(value uint8) {
	volatile.StoreUint8(&o.MB1_D2.Reg, value)
}
func (o *CAN0_Type) GetMB1_D2() uint8 {
	return volatile.LoadUint8(&o.MB1_D2.Reg)
}

// CAN0.MB1_D3: Mailbox Register
func (o *CAN0_Type) SetMB1_D3(value uint8) {
	volatile.StoreUint8(&o.MB1_D3.Reg, value)
}
func (o *CAN0_Type) GetMB1_D3() uint8 {
	return volatile.LoadUint8(&o.MB1_D3.Reg)
}

// CAN0.MB1_D4: Mailbox Register
func (o *CAN0_Type) SetMB1_D4(value uint8) {
	volatile.StoreUint8(&o.MB1_D4.Reg, value)
}
func (o *CAN0_Type) GetMB1_D4() uint8 {
	return volatile.LoadUint8(&o.MB1_D4.Reg)
}

// CAN0.MB1_D5: Mailbox Register
func (o *CAN0_Type) SetMB1_D5(value uint8) {
	volatile.StoreUint8(&o.MB1_D5.Reg, value)
}
func (o *CAN0_Type) GetMB1_D5() uint8 {
	return volatile.LoadUint8(&o.MB1_D5.Reg)
}

// CAN0.MB1_D6: Mailbox Register
func (o *CAN0_Type) SetMB1_D6(value uint8) {
	volatile.StoreUint8(&o.MB1_D6.Reg, value)
}
func (o *CAN0_Type) GetMB1_D6() uint8 {
	return volatile.LoadUint8(&o.MB1_D6.Reg)
}

// CAN0.MB1_D7: Mailbox Register
func (o *CAN0_Type) SetMB1_D7(value uint8) {
	volatile.StoreUint8(&o.MB1_D7.Reg, value)
}
func (o *CAN0_Type) GetMB1_D7() uint8 {
	return volatile.LoadUint8(&o.MB1_D7.Reg)
}

// CAN0.MB1_TS: Mailbox Register
func (o *CAN0_Type) SetMB1_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB1_TS.Reg, volatile.LoadUint16(&o.MB1_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB1_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB1_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB1_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB1_TS.Reg, volatile.LoadUint16(&o.MB1_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB1_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB1_TS.Reg) & 0xff
}

// CAN0.MB2_ID: Mailbox Register
func (o *CAN0_Type) SetMB2_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB2_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB2_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB2_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB2_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB2_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB2_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB2_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB2_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB2_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB2_ID.Reg) & 0x3ffff
}

// CAN0.MB2_DL: Mailbox Register
func (o *CAN0_Type) SetMB2_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB2_DL.Reg, volatile.LoadUint16(&o.MB2_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB2_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB2_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB2_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB2_DL.Reg, volatile.LoadUint16(&o.MB2_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB2_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB2_DL.Reg) & 0xf
}

// CAN0.MB2_D0: Mailbox Register
func (o *CAN0_Type) SetMB2_D0(value uint8) {
	volatile.StoreUint8(&o.MB2_D0.Reg, value)
}
func (o *CAN0_Type) GetMB2_D0() uint8 {
	return volatile.LoadUint8(&o.MB2_D0.Reg)
}

// CAN0.MB2_D1: Mailbox Register
func (o *CAN0_Type) SetMB2_D1(value uint8) {
	volatile.StoreUint8(&o.MB2_D1.Reg, value)
}
func (o *CAN0_Type) GetMB2_D1() uint8 {
	return volatile.LoadUint8(&o.MB2_D1.Reg)
}

// CAN0.MB2_D2: Mailbox Register
func (o *CAN0_Type) SetMB2_D2(value uint8) {
	volatile.StoreUint8(&o.MB2_D2.Reg, value)
}
func (o *CAN0_Type) GetMB2_D2() uint8 {
	return volatile.LoadUint8(&o.MB2_D2.Reg)
}

// CAN0.MB2_D3: Mailbox Register
func (o *CAN0_Type) SetMB2_D3(value uint8) {
	volatile.StoreUint8(&o.MB2_D3.Reg, value)
}
func (o *CAN0_Type) GetMB2_D3() uint8 {
	return volatile.LoadUint8(&o.MB2_D3.Reg)
}

// CAN0.MB2_D4: Mailbox Register
func (o *CAN0_Type) SetMB2_D4(value uint8) {
	volatile.StoreUint8(&o.MB2_D4.Reg, value)
}
func (o *CAN0_Type) GetMB2_D4() uint8 {
	return volatile.LoadUint8(&o.MB2_D4.Reg)
}

// CAN0.MB2_D5: Mailbox Register
func (o *CAN0_Type) SetMB2_D5(value uint8) {
	volatile.StoreUint8(&o.MB2_D5.Reg, value)
}
func (o *CAN0_Type) GetMB2_D5() uint8 {
	return volatile.LoadUint8(&o.MB2_D5.Reg)
}

// CAN0.MB2_D6: Mailbox Register
func (o *CAN0_Type) SetMB2_D6(value uint8) {
	volatile.StoreUint8(&o.MB2_D6.Reg, value)
}
func (o *CAN0_Type) GetMB2_D6() uint8 {
	return volatile.LoadUint8(&o.MB2_D6.Reg)
}

// CAN0.MB2_D7: Mailbox Register
func (o *CAN0_Type) SetMB2_D7(value uint8) {
	volatile.StoreUint8(&o.MB2_D7.Reg, value)
}
func (o *CAN0_Type) GetMB2_D7() uint8 {
	return volatile.LoadUint8(&o.MB2_D7.Reg)
}

// CAN0.MB2_TS: Mailbox Register
func (o *CAN0_Type) SetMB2_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB2_TS.Reg, volatile.LoadUint16(&o.MB2_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB2_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB2_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB2_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB2_TS.Reg, volatile.LoadUint16(&o.MB2_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB2_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB2_TS.Reg) & 0xff
}

// CAN0.MB3_ID: Mailbox Register
func (o *CAN0_Type) SetMB3_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB3_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB3_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB3_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB3_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB3_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB3_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB3_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB3_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB3_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB3_ID.Reg) & 0x3ffff
}

// CAN0.MB3_DL: Mailbox Register
func (o *CAN0_Type) SetMB3_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB3_DL.Reg, volatile.LoadUint16(&o.MB3_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB3_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB3_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB3_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB3_DL.Reg, volatile.LoadUint16(&o.MB3_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB3_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB3_DL.Reg) & 0xf
}

// CAN0.MB3_D0: Mailbox Register
func (o *CAN0_Type) SetMB3_D0(value uint8) {
	volatile.StoreUint8(&o.MB3_D0.Reg, value)
}
func (o *CAN0_Type) GetMB3_D0() uint8 {
	return volatile.LoadUint8(&o.MB3_D0.Reg)
}

// CAN0.MB3_D1: Mailbox Register
func (o *CAN0_Type) SetMB3_D1(value uint8) {
	volatile.StoreUint8(&o.MB3_D1.Reg, value)
}
func (o *CAN0_Type) GetMB3_D1() uint8 {
	return volatile.LoadUint8(&o.MB3_D1.Reg)
}

// CAN0.MB3_D2: Mailbox Register
func (o *CAN0_Type) SetMB3_D2(value uint8) {
	volatile.StoreUint8(&o.MB3_D2.Reg, value)
}
func (o *CAN0_Type) GetMB3_D2() uint8 {
	return volatile.LoadUint8(&o.MB3_D2.Reg)
}

// CAN0.MB3_D3: Mailbox Register
func (o *CAN0_Type) SetMB3_D3(value uint8) {
	volatile.StoreUint8(&o.MB3_D3.Reg, value)
}
func (o *CAN0_Type) GetMB3_D3() uint8 {
	return volatile.LoadUint8(&o.MB3_D3.Reg)
}

// CAN0.MB3_D4: Mailbox Register
func (o *CAN0_Type) SetMB3_D4(value uint8) {
	volatile.StoreUint8(&o.MB3_D4.Reg, value)
}
func (o *CAN0_Type) GetMB3_D4() uint8 {
	return volatile.LoadUint8(&o.MB3_D4.Reg)
}

// CAN0.MB3_D5: Mailbox Register
func (o *CAN0_Type) SetMB3_D5(value uint8) {
	volatile.StoreUint8(&o.MB3_D5.Reg, value)
}
func (o *CAN0_Type) GetMB3_D5() uint8 {
	return volatile.LoadUint8(&o.MB3_D5.Reg)
}

// CAN0.MB3_D6: Mailbox Register
func (o *CAN0_Type) SetMB3_D6(value uint8) {
	volatile.StoreUint8(&o.MB3_D6.Reg, value)
}
func (o *CAN0_Type) GetMB3_D6() uint8 {
	return volatile.LoadUint8(&o.MB3_D6.Reg)
}

// CAN0.MB3_D7: Mailbox Register
func (o *CAN0_Type) SetMB3_D7(value uint8) {
	volatile.StoreUint8(&o.MB3_D7.Reg, value)
}
func (o *CAN0_Type) GetMB3_D7() uint8 {
	return volatile.LoadUint8(&o.MB3_D7.Reg)
}

// CAN0.MB3_TS: Mailbox Register
func (o *CAN0_Type) SetMB3_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB3_TS.Reg, volatile.LoadUint16(&o.MB3_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB3_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB3_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB3_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB3_TS.Reg, volatile.LoadUint16(&o.MB3_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB3_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB3_TS.Reg) & 0xff
}

// CAN0.MB4_ID: Mailbox Register
func (o *CAN0_Type) SetMB4_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB4_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB4_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB4_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB4_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB4_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB4_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB4_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB4_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB4_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB4_ID.Reg) & 0x3ffff
}

// CAN0.MB4_DL: Mailbox Register
func (o *CAN0_Type) SetMB4_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB4_DL.Reg, volatile.LoadUint16(&o.MB4_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB4_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB4_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB4_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB4_DL.Reg, volatile.LoadUint16(&o.MB4_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB4_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB4_DL.Reg) & 0xf
}

// CAN0.MB4_D0: Mailbox Register
func (o *CAN0_Type) SetMB4_D0(value uint8) {
	volatile.StoreUint8(&o.MB4_D0.Reg, value)
}
func (o *CAN0_Type) GetMB4_D0() uint8 {
	return volatile.LoadUint8(&o.MB4_D0.Reg)
}

// CAN0.MB4_D1: Mailbox Register
func (o *CAN0_Type) SetMB4_D1(value uint8) {
	volatile.StoreUint8(&o.MB4_D1.Reg, value)
}
func (o *CAN0_Type) GetMB4_D1() uint8 {
	return volatile.LoadUint8(&o.MB4_D1.Reg)
}

// CAN0.MB4_D2: Mailbox Register
func (o *CAN0_Type) SetMB4_D2(value uint8) {
	volatile.StoreUint8(&o.MB4_D2.Reg, value)
}
func (o *CAN0_Type) GetMB4_D2() uint8 {
	return volatile.LoadUint8(&o.MB4_D2.Reg)
}

// CAN0.MB4_D3: Mailbox Register
func (o *CAN0_Type) SetMB4_D3(value uint8) {
	volatile.StoreUint8(&o.MB4_D3.Reg, value)
}
func (o *CAN0_Type) GetMB4_D3() uint8 {
	return volatile.LoadUint8(&o.MB4_D3.Reg)
}

// CAN0.MB4_D4: Mailbox Register
func (o *CAN0_Type) SetMB4_D4(value uint8) {
	volatile.StoreUint8(&o.MB4_D4.Reg, value)
}
func (o *CAN0_Type) GetMB4_D4() uint8 {
	return volatile.LoadUint8(&o.MB4_D4.Reg)
}

// CAN0.MB4_D5: Mailbox Register
func (o *CAN0_Type) SetMB4_D5(value uint8) {
	volatile.StoreUint8(&o.MB4_D5.Reg, value)
}
func (o *CAN0_Type) GetMB4_D5() uint8 {
	return volatile.LoadUint8(&o.MB4_D5.Reg)
}

// CAN0.MB4_D6: Mailbox Register
func (o *CAN0_Type) SetMB4_D6(value uint8) {
	volatile.StoreUint8(&o.MB4_D6.Reg, value)
}
func (o *CAN0_Type) GetMB4_D6() uint8 {
	return volatile.LoadUint8(&o.MB4_D6.Reg)
}

// CAN0.MB4_D7: Mailbox Register
func (o *CAN0_Type) SetMB4_D7(value uint8) {
	volatile.StoreUint8(&o.MB4_D7.Reg, value)
}
func (o *CAN0_Type) GetMB4_D7() uint8 {
	return volatile.LoadUint8(&o.MB4_D7.Reg)
}

// CAN0.MB4_TS: Mailbox Register
func (o *CAN0_Type) SetMB4_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB4_TS.Reg, volatile.LoadUint16(&o.MB4_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB4_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB4_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB4_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB4_TS.Reg, volatile.LoadUint16(&o.MB4_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB4_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB4_TS.Reg) & 0xff
}

// CAN0.MB5_ID: Mailbox Register
func (o *CAN0_Type) SetMB5_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB5_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB5_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB5_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB5_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB5_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB5_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB5_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB5_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB5_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB5_ID.Reg) & 0x3ffff
}

// CAN0.MB5_DL: Mailbox Register
func (o *CAN0_Type) SetMB5_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB5_DL.Reg, volatile.LoadUint16(&o.MB5_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB5_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB5_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB5_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB5_DL.Reg, volatile.LoadUint16(&o.MB5_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB5_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB5_DL.Reg) & 0xf
}

// CAN0.MB5_D0: Mailbox Register
func (o *CAN0_Type) SetMB5_D0(value uint8) {
	volatile.StoreUint8(&o.MB5_D0.Reg, value)
}
func (o *CAN0_Type) GetMB5_D0() uint8 {
	return volatile.LoadUint8(&o.MB5_D0.Reg)
}

// CAN0.MB5_D1: Mailbox Register
func (o *CAN0_Type) SetMB5_D1(value uint8) {
	volatile.StoreUint8(&o.MB5_D1.Reg, value)
}
func (o *CAN0_Type) GetMB5_D1() uint8 {
	return volatile.LoadUint8(&o.MB5_D1.Reg)
}

// CAN0.MB5_D2: Mailbox Register
func (o *CAN0_Type) SetMB5_D2(value uint8) {
	volatile.StoreUint8(&o.MB5_D2.Reg, value)
}
func (o *CAN0_Type) GetMB5_D2() uint8 {
	return volatile.LoadUint8(&o.MB5_D2.Reg)
}

// CAN0.MB5_D3: Mailbox Register
func (o *CAN0_Type) SetMB5_D3(value uint8) {
	volatile.StoreUint8(&o.MB5_D3.Reg, value)
}
func (o *CAN0_Type) GetMB5_D3() uint8 {
	return volatile.LoadUint8(&o.MB5_D3.Reg)
}

// CAN0.MB5_D4: Mailbox Register
func (o *CAN0_Type) SetMB5_D4(value uint8) {
	volatile.StoreUint8(&o.MB5_D4.Reg, value)
}
func (o *CAN0_Type) GetMB5_D4() uint8 {
	return volatile.LoadUint8(&o.MB5_D4.Reg)
}

// CAN0.MB5_D5: Mailbox Register
func (o *CAN0_Type) SetMB5_D5(value uint8) {
	volatile.StoreUint8(&o.MB5_D5.Reg, value)
}
func (o *CAN0_Type) GetMB5_D5() uint8 {
	return volatile.LoadUint8(&o.MB5_D5.Reg)
}

// CAN0.MB5_D6: Mailbox Register
func (o *CAN0_Type) SetMB5_D6(value uint8) {
	volatile.StoreUint8(&o.MB5_D6.Reg, value)
}
func (o *CAN0_Type) GetMB5_D6() uint8 {
	return volatile.LoadUint8(&o.MB5_D6.Reg)
}

// CAN0.MB5_D7: Mailbox Register
func (o *CAN0_Type) SetMB5_D7(value uint8) {
	volatile.StoreUint8(&o.MB5_D7.Reg, value)
}
func (o *CAN0_Type) GetMB5_D7() uint8 {
	return volatile.LoadUint8(&o.MB5_D7.Reg)
}

// CAN0.MB5_TS: Mailbox Register
func (o *CAN0_Type) SetMB5_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB5_TS.Reg, volatile.LoadUint16(&o.MB5_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB5_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB5_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB5_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB5_TS.Reg, volatile.LoadUint16(&o.MB5_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB5_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB5_TS.Reg) & 0xff
}

// CAN0.MB6_ID: Mailbox Register
func (o *CAN0_Type) SetMB6_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB6_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB6_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB6_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB6_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB6_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB6_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB6_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB6_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB6_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB6_ID.Reg) & 0x3ffff
}

// CAN0.MB6_DL: Mailbox Register
func (o *CAN0_Type) SetMB6_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB6_DL.Reg, volatile.LoadUint16(&o.MB6_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB6_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB6_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB6_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB6_DL.Reg, volatile.LoadUint16(&o.MB6_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB6_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB6_DL.Reg) & 0xf
}

// CAN0.MB6_D0: Mailbox Register
func (o *CAN0_Type) SetMB6_D0(value uint8) {
	volatile.StoreUint8(&o.MB6_D0.Reg, value)
}
func (o *CAN0_Type) GetMB6_D0() uint8 {
	return volatile.LoadUint8(&o.MB6_D0.Reg)
}

// CAN0.MB6_D1: Mailbox Register
func (o *CAN0_Type) SetMB6_D1(value uint8) {
	volatile.StoreUint8(&o.MB6_D1.Reg, value)
}
func (o *CAN0_Type) GetMB6_D1() uint8 {
	return volatile.LoadUint8(&o.MB6_D1.Reg)
}

// CAN0.MB6_D2: Mailbox Register
func (o *CAN0_Type) SetMB6_D2(value uint8) {
	volatile.StoreUint8(&o.MB6_D2.Reg, value)
}
func (o *CAN0_Type) GetMB6_D2() uint8 {
	return volatile.LoadUint8(&o.MB6_D2.Reg)
}

// CAN0.MB6_D3: Mailbox Register
func (o *CAN0_Type) SetMB6_D3(value uint8) {
	volatile.StoreUint8(&o.MB6_D3.Reg, value)
}
func (o *CAN0_Type) GetMB6_D3() uint8 {
	return volatile.LoadUint8(&o.MB6_D3.Reg)
}

// CAN0.MB6_D4: Mailbox Register
func (o *CAN0_Type) SetMB6_D4(value uint8) {
	volatile.StoreUint8(&o.MB6_D4.Reg, value)
}
func (o *CAN0_Type) GetMB6_D4() uint8 {
	return volatile.LoadUint8(&o.MB6_D4.Reg)
}

// CAN0.MB6_D5: Mailbox Register
func (o *CAN0_Type) SetMB6_D5(value uint8) {
	volatile.StoreUint8(&o.MB6_D5.Reg, value)
}
func (o *CAN0_Type) GetMB6_D5() uint8 {
	return volatile.LoadUint8(&o.MB6_D5.Reg)
}

// CAN0.MB6_D6: Mailbox Register
func (o *CAN0_Type) SetMB6_D6(value uint8) {
	volatile.StoreUint8(&o.MB6_D6.Reg, value)
}
func (o *CAN0_Type) GetMB6_D6() uint8 {
	return volatile.LoadUint8(&o.MB6_D6.Reg)
}

// CAN0.MB6_D7: Mailbox Register
func (o *CAN0_Type) SetMB6_D7(value uint8) {
	volatile.StoreUint8(&o.MB6_D7.Reg, value)
}
func (o *CAN0_Type) GetMB6_D7() uint8 {
	return volatile.LoadUint8(&o.MB6_D7.Reg)
}

// CAN0.MB6_TS: Mailbox Register
func (o *CAN0_Type) SetMB6_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB6_TS.Reg, volatile.LoadUint16(&o.MB6_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB6_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB6_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB6_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB6_TS.Reg, volatile.LoadUint16(&o.MB6_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB6_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB6_TS.Reg) & 0xff
}

// CAN0.MB7_ID: Mailbox Register
func (o *CAN0_Type) SetMB7_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB7_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB7_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB7_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB7_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB7_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB7_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB7_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB7_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB7_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB7_ID.Reg) & 0x3ffff
}

// CAN0.MB7_DL: Mailbox Register
func (o *CAN0_Type) SetMB7_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB7_DL.Reg, volatile.LoadUint16(&o.MB7_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB7_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB7_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB7_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB7_DL.Reg, volatile.LoadUint16(&o.MB7_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB7_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB7_DL.Reg) & 0xf
}

// CAN0.MB7_D0: Mailbox Register
func (o *CAN0_Type) SetMB7_D0(value uint8) {
	volatile.StoreUint8(&o.MB7_D0.Reg, value)
}
func (o *CAN0_Type) GetMB7_D0() uint8 {
	return volatile.LoadUint8(&o.MB7_D0.Reg)
}

// CAN0.MB7_D1: Mailbox Register
func (o *CAN0_Type) SetMB7_D1(value uint8) {
	volatile.StoreUint8(&o.MB7_D1.Reg, value)
}
func (o *CAN0_Type) GetMB7_D1() uint8 {
	return volatile.LoadUint8(&o.MB7_D1.Reg)
}

// CAN0.MB7_D2: Mailbox Register
func (o *CAN0_Type) SetMB7_D2(value uint8) {
	volatile.StoreUint8(&o.MB7_D2.Reg, value)
}
func (o *CAN0_Type) GetMB7_D2() uint8 {
	return volatile.LoadUint8(&o.MB7_D2.Reg)
}

// CAN0.MB7_D3: Mailbox Register
func (o *CAN0_Type) SetMB7_D3(value uint8) {
	volatile.StoreUint8(&o.MB7_D3.Reg, value)
}
func (o *CAN0_Type) GetMB7_D3() uint8 {
	return volatile.LoadUint8(&o.MB7_D3.Reg)
}

// CAN0.MB7_D4: Mailbox Register
func (o *CAN0_Type) SetMB7_D4(value uint8) {
	volatile.StoreUint8(&o.MB7_D4.Reg, value)
}
func (o *CAN0_Type) GetMB7_D4() uint8 {
	return volatile.LoadUint8(&o.MB7_D4.Reg)
}

// CAN0.MB7_D5: Mailbox Register
func (o *CAN0_Type) SetMB7_D5(value uint8) {
	volatile.StoreUint8(&o.MB7_D5.Reg, value)
}
func (o *CAN0_Type) GetMB7_D5() uint8 {
	return volatile.LoadUint8(&o.MB7_D5.Reg)
}

// CAN0.MB7_D6: Mailbox Register
func (o *CAN0_Type) SetMB7_D6(value uint8) {
	volatile.StoreUint8(&o.MB7_D6.Reg, value)
}
func (o *CAN0_Type) GetMB7_D6() uint8 {
	return volatile.LoadUint8(&o.MB7_D6.Reg)
}

// CAN0.MB7_D7: Mailbox Register
func (o *CAN0_Type) SetMB7_D7(value uint8) {
	volatile.StoreUint8(&o.MB7_D7.Reg, value)
}
func (o *CAN0_Type) GetMB7_D7() uint8 {
	return volatile.LoadUint8(&o.MB7_D7.Reg)
}

// CAN0.MB7_TS: Mailbox Register
func (o *CAN0_Type) SetMB7_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB7_TS.Reg, volatile.LoadUint16(&o.MB7_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB7_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB7_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB7_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB7_TS.Reg, volatile.LoadUint16(&o.MB7_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB7_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB7_TS.Reg) & 0xff
}

// CAN0.MB8_ID: Mailbox Register
func (o *CAN0_Type) SetMB8_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB8_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB8_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB8_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB8_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB8_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB8_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB8_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB8_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB8_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB8_ID.Reg) & 0x3ffff
}

// CAN0.MB8_DL: Mailbox Register
func (o *CAN0_Type) SetMB8_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB8_DL.Reg, volatile.LoadUint16(&o.MB8_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB8_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB8_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB8_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB8_DL.Reg, volatile.LoadUint16(&o.MB8_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB8_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB8_DL.Reg) & 0xf
}

// CAN0.MB8_D0: Mailbox Register
func (o *CAN0_Type) SetMB8_D0(value uint8) {
	volatile.StoreUint8(&o.MB8_D0.Reg, value)
}
func (o *CAN0_Type) GetMB8_D0() uint8 {
	return volatile.LoadUint8(&o.MB8_D0.Reg)
}

// CAN0.MB8_D1: Mailbox Register
func (o *CAN0_Type) SetMB8_D1(value uint8) {
	volatile.StoreUint8(&o.MB8_D1.Reg, value)
}
func (o *CAN0_Type) GetMB8_D1() uint8 {
	return volatile.LoadUint8(&o.MB8_D1.Reg)
}

// CAN0.MB8_D2: Mailbox Register
func (o *CAN0_Type) SetMB8_D2(value uint8) {
	volatile.StoreUint8(&o.MB8_D2.Reg, value)
}
func (o *CAN0_Type) GetMB8_D2() uint8 {
	return volatile.LoadUint8(&o.MB8_D2.Reg)
}

// CAN0.MB8_D3: Mailbox Register
func (o *CAN0_Type) SetMB8_D3(value uint8) {
	volatile.StoreUint8(&o.MB8_D3.Reg, value)
}
func (o *CAN0_Type) GetMB8_D3() uint8 {
	return volatile.LoadUint8(&o.MB8_D3.Reg)
}

// CAN0.MB8_D4: Mailbox Register
func (o *CAN0_Type) SetMB8_D4(value uint8) {
	volatile.StoreUint8(&o.MB8_D4.Reg, value)
}
func (o *CAN0_Type) GetMB8_D4() uint8 {
	return volatile.LoadUint8(&o.MB8_D4.Reg)
}

// CAN0.MB8_D5: Mailbox Register
func (o *CAN0_Type) SetMB8_D5(value uint8) {
	volatile.StoreUint8(&o.MB8_D5.Reg, value)
}
func (o *CAN0_Type) GetMB8_D5() uint8 {
	return volatile.LoadUint8(&o.MB8_D5.Reg)
}

// CAN0.MB8_D6: Mailbox Register
func (o *CAN0_Type) SetMB8_D6(value uint8) {
	volatile.StoreUint8(&o.MB8_D6.Reg, value)
}
func (o *CAN0_Type) GetMB8_D6() uint8 {
	return volatile.LoadUint8(&o.MB8_D6.Reg)
}

// CAN0.MB8_D7: Mailbox Register
func (o *CAN0_Type) SetMB8_D7(value uint8) {
	volatile.StoreUint8(&o.MB8_D7.Reg, value)
}
func (o *CAN0_Type) GetMB8_D7() uint8 {
	return volatile.LoadUint8(&o.MB8_D7.Reg)
}

// CAN0.MB8_TS: Mailbox Register
func (o *CAN0_Type) SetMB8_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB8_TS.Reg, volatile.LoadUint16(&o.MB8_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB8_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB8_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB8_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB8_TS.Reg, volatile.LoadUint16(&o.MB8_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB8_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB8_TS.Reg) & 0xff
}

// CAN0.MB9_ID: Mailbox Register
func (o *CAN0_Type) SetMB9_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB9_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB9_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB9_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB9_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB9_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB9_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB9_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB9_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB9_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB9_ID.Reg) & 0x3ffff
}

// CAN0.MB9_DL: Mailbox Register
func (o *CAN0_Type) SetMB9_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB9_DL.Reg, volatile.LoadUint16(&o.MB9_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB9_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB9_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB9_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB9_DL.Reg, volatile.LoadUint16(&o.MB9_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB9_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB9_DL.Reg) & 0xf
}

// CAN0.MB9_D0: Mailbox Register
func (o *CAN0_Type) SetMB9_D0(value uint8) {
	volatile.StoreUint8(&o.MB9_D0.Reg, value)
}
func (o *CAN0_Type) GetMB9_D0() uint8 {
	return volatile.LoadUint8(&o.MB9_D0.Reg)
}

// CAN0.MB9_D1: Mailbox Register
func (o *CAN0_Type) SetMB9_D1(value uint8) {
	volatile.StoreUint8(&o.MB9_D1.Reg, value)
}
func (o *CAN0_Type) GetMB9_D1() uint8 {
	return volatile.LoadUint8(&o.MB9_D1.Reg)
}

// CAN0.MB9_D2: Mailbox Register
func (o *CAN0_Type) SetMB9_D2(value uint8) {
	volatile.StoreUint8(&o.MB9_D2.Reg, value)
}
func (o *CAN0_Type) GetMB9_D2() uint8 {
	return volatile.LoadUint8(&o.MB9_D2.Reg)
}

// CAN0.MB9_D3: Mailbox Register
func (o *CAN0_Type) SetMB9_D3(value uint8) {
	volatile.StoreUint8(&o.MB9_D3.Reg, value)
}
func (o *CAN0_Type) GetMB9_D3() uint8 {
	return volatile.LoadUint8(&o.MB9_D3.Reg)
}

// CAN0.MB9_D4: Mailbox Register
func (o *CAN0_Type) SetMB9_D4(value uint8) {
	volatile.StoreUint8(&o.MB9_D4.Reg, value)
}
func (o *CAN0_Type) GetMB9_D4() uint8 {
	return volatile.LoadUint8(&o.MB9_D4.Reg)
}

// CAN0.MB9_D5: Mailbox Register
func (o *CAN0_Type) SetMB9_D5(value uint8) {
	volatile.StoreUint8(&o.MB9_D5.Reg, value)
}
func (o *CAN0_Type) GetMB9_D5() uint8 {
	return volatile.LoadUint8(&o.MB9_D5.Reg)
}

// CAN0.MB9_D6: Mailbox Register
func (o *CAN0_Type) SetMB9_D6(value uint8) {
	volatile.StoreUint8(&o.MB9_D6.Reg, value)
}
func (o *CAN0_Type) GetMB9_D6() uint8 {
	return volatile.LoadUint8(&o.MB9_D6.Reg)
}

// CAN0.MB9_D7: Mailbox Register
func (o *CAN0_Type) SetMB9_D7(value uint8) {
	volatile.StoreUint8(&o.MB9_D7.Reg, value)
}
func (o *CAN0_Type) GetMB9_D7() uint8 {
	return volatile.LoadUint8(&o.MB9_D7.Reg)
}

// CAN0.MB9_TS: Mailbox Register
func (o *CAN0_Type) SetMB9_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB9_TS.Reg, volatile.LoadUint16(&o.MB9_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB9_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB9_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB9_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB9_TS.Reg, volatile.LoadUint16(&o.MB9_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB9_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB9_TS.Reg) & 0xff
}

// CAN0.MB10_ID: Mailbox Register
func (o *CAN0_Type) SetMB10_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB10_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB10_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB10_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB10_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB10_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB10_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB10_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB10_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB10_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB10_ID.Reg) & 0x3ffff
}

// CAN0.MB10_DL: Mailbox Register
func (o *CAN0_Type) SetMB10_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB10_DL.Reg, volatile.LoadUint16(&o.MB10_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB10_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB10_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB10_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB10_DL.Reg, volatile.LoadUint16(&o.MB10_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB10_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB10_DL.Reg) & 0xf
}

// CAN0.MB10_D0: Mailbox Register
func (o *CAN0_Type) SetMB10_D0(value uint8) {
	volatile.StoreUint8(&o.MB10_D0.Reg, value)
}
func (o *CAN0_Type) GetMB10_D0() uint8 {
	return volatile.LoadUint8(&o.MB10_D0.Reg)
}

// CAN0.MB10_D1: Mailbox Register
func (o *CAN0_Type) SetMB10_D1(value uint8) {
	volatile.StoreUint8(&o.MB10_D1.Reg, value)
}
func (o *CAN0_Type) GetMB10_D1() uint8 {
	return volatile.LoadUint8(&o.MB10_D1.Reg)
}

// CAN0.MB10_D2: Mailbox Register
func (o *CAN0_Type) SetMB10_D2(value uint8) {
	volatile.StoreUint8(&o.MB10_D2.Reg, value)
}
func (o *CAN0_Type) GetMB10_D2() uint8 {
	return volatile.LoadUint8(&o.MB10_D2.Reg)
}

// CAN0.MB10_D3: Mailbox Register
func (o *CAN0_Type) SetMB10_D3(value uint8) {
	volatile.StoreUint8(&o.MB10_D3.Reg, value)
}
func (o *CAN0_Type) GetMB10_D3() uint8 {
	return volatile.LoadUint8(&o.MB10_D3.Reg)
}

// CAN0.MB10_D4: Mailbox Register
func (o *CAN0_Type) SetMB10_D4(value uint8) {
	volatile.StoreUint8(&o.MB10_D4.Reg, value)
}
func (o *CAN0_Type) GetMB10_D4() uint8 {
	return volatile.LoadUint8(&o.MB10_D4.Reg)
}

// CAN0.MB10_D5: Mailbox Register
func (o *CAN0_Type) SetMB10_D5(value uint8) {
	volatile.StoreUint8(&o.MB10_D5.Reg, value)
}
func (o *CAN0_Type) GetMB10_D5() uint8 {
	return volatile.LoadUint8(&o.MB10_D5.Reg)
}

// CAN0.MB10_D6: Mailbox Register
func (o *CAN0_Type) SetMB10_D6(value uint8) {
	volatile.StoreUint8(&o.MB10_D6.Reg, value)
}
func (o *CAN0_Type) GetMB10_D6() uint8 {
	return volatile.LoadUint8(&o.MB10_D6.Reg)
}

// CAN0.MB10_D7: Mailbox Register
func (o *CAN0_Type) SetMB10_D7(value uint8) {
	volatile.StoreUint8(&o.MB10_D7.Reg, value)
}
func (o *CAN0_Type) GetMB10_D7() uint8 {
	return volatile.LoadUint8(&o.MB10_D7.Reg)
}

// CAN0.MB10_TS: Mailbox Register
func (o *CAN0_Type) SetMB10_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB10_TS.Reg, volatile.LoadUint16(&o.MB10_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB10_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB10_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB10_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB10_TS.Reg, volatile.LoadUint16(&o.MB10_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB10_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB10_TS.Reg) & 0xff
}

// CAN0.MB11_ID: Mailbox Register
func (o *CAN0_Type) SetMB11_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB11_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB11_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB11_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB11_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB11_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB11_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB11_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB11_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB11_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB11_ID.Reg) & 0x3ffff
}

// CAN0.MB11_DL: Mailbox Register
func (o *CAN0_Type) SetMB11_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB11_DL.Reg, volatile.LoadUint16(&o.MB11_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB11_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB11_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB11_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB11_DL.Reg, volatile.LoadUint16(&o.MB11_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB11_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB11_DL.Reg) & 0xf
}

// CAN0.MB11_D0: Mailbox Register
func (o *CAN0_Type) SetMB11_D0(value uint8) {
	volatile.StoreUint8(&o.MB11_D0.Reg, value)
}
func (o *CAN0_Type) GetMB11_D0() uint8 {
	return volatile.LoadUint8(&o.MB11_D0.Reg)
}

// CAN0.MB11_D1: Mailbox Register
func (o *CAN0_Type) SetMB11_D1(value uint8) {
	volatile.StoreUint8(&o.MB11_D1.Reg, value)
}
func (o *CAN0_Type) GetMB11_D1() uint8 {
	return volatile.LoadUint8(&o.MB11_D1.Reg)
}

// CAN0.MB11_D2: Mailbox Register
func (o *CAN0_Type) SetMB11_D2(value uint8) {
	volatile.StoreUint8(&o.MB11_D2.Reg, value)
}
func (o *CAN0_Type) GetMB11_D2() uint8 {
	return volatile.LoadUint8(&o.MB11_D2.Reg)
}

// CAN0.MB11_D3: Mailbox Register
func (o *CAN0_Type) SetMB11_D3(value uint8) {
	volatile.StoreUint8(&o.MB11_D3.Reg, value)
}
func (o *CAN0_Type) GetMB11_D3() uint8 {
	return volatile.LoadUint8(&o.MB11_D3.Reg)
}

// CAN0.MB11_D4: Mailbox Register
func (o *CAN0_Type) SetMB11_D4(value uint8) {
	volatile.StoreUint8(&o.MB11_D4.Reg, value)
}
func (o *CAN0_Type) GetMB11_D4() uint8 {
	return volatile.LoadUint8(&o.MB11_D4.Reg)
}

// CAN0.MB11_D5: Mailbox Register
func (o *CAN0_Type) SetMB11_D5(value uint8) {
	volatile.StoreUint8(&o.MB11_D5.Reg, value)
}
func (o *CAN0_Type) GetMB11_D5() uint8 {
	return volatile.LoadUint8(&o.MB11_D5.Reg)
}

// CAN0.MB11_D6: Mailbox Register
func (o *CAN0_Type) SetMB11_D6(value uint8) {
	volatile.StoreUint8(&o.MB11_D6.Reg, value)
}
func (o *CAN0_Type) GetMB11_D6() uint8 {
	return volatile.LoadUint8(&o.MB11_D6.Reg)
}

// CAN0.MB11_D7: Mailbox Register
func (o *CAN0_Type) SetMB11_D7(value uint8) {
	volatile.StoreUint8(&o.MB11_D7.Reg, value)
}
func (o *CAN0_Type) GetMB11_D7() uint8 {
	return volatile.LoadUint8(&o.MB11_D7.Reg)
}

// CAN0.MB11_TS: Mailbox Register
func (o *CAN0_Type) SetMB11_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB11_TS.Reg, volatile.LoadUint16(&o.MB11_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB11_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB11_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB11_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB11_TS.Reg, volatile.LoadUint16(&o.MB11_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB11_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB11_TS.Reg) & 0xff
}

// CAN0.MB12_ID: Mailbox Register
func (o *CAN0_Type) SetMB12_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB12_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB12_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB12_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB12_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB12_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB12_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB12_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB12_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB12_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB12_ID.Reg) & 0x3ffff
}

// CAN0.MB12_DL: Mailbox Register
func (o *CAN0_Type) SetMB12_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB12_DL.Reg, volatile.LoadUint16(&o.MB12_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB12_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB12_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB12_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB12_DL.Reg, volatile.LoadUint16(&o.MB12_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB12_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB12_DL.Reg) & 0xf
}

// CAN0.MB12_D0: Mailbox Register
func (o *CAN0_Type) SetMB12_D0(value uint8) {
	volatile.StoreUint8(&o.MB12_D0.Reg, value)
}
func (o *CAN0_Type) GetMB12_D0() uint8 {
	return volatile.LoadUint8(&o.MB12_D0.Reg)
}

// CAN0.MB12_D1: Mailbox Register
func (o *CAN0_Type) SetMB12_D1(value uint8) {
	volatile.StoreUint8(&o.MB12_D1.Reg, value)
}
func (o *CAN0_Type) GetMB12_D1() uint8 {
	return volatile.LoadUint8(&o.MB12_D1.Reg)
}

// CAN0.MB12_D2: Mailbox Register
func (o *CAN0_Type) SetMB12_D2(value uint8) {
	volatile.StoreUint8(&o.MB12_D2.Reg, value)
}
func (o *CAN0_Type) GetMB12_D2() uint8 {
	return volatile.LoadUint8(&o.MB12_D2.Reg)
}

// CAN0.MB12_D3: Mailbox Register
func (o *CAN0_Type) SetMB12_D3(value uint8) {
	volatile.StoreUint8(&o.MB12_D3.Reg, value)
}
func (o *CAN0_Type) GetMB12_D3() uint8 {
	return volatile.LoadUint8(&o.MB12_D3.Reg)
}

// CAN0.MB12_D4: Mailbox Register
func (o *CAN0_Type) SetMB12_D4(value uint8) {
	volatile.StoreUint8(&o.MB12_D4.Reg, value)
}
func (o *CAN0_Type) GetMB12_D4() uint8 {
	return volatile.LoadUint8(&o.MB12_D4.Reg)
}

// CAN0.MB12_D5: Mailbox Register
func (o *CAN0_Type) SetMB12_D5(value uint8) {
	volatile.StoreUint8(&o.MB12_D5.Reg, value)
}
func (o *CAN0_Type) GetMB12_D5() uint8 {
	return volatile.LoadUint8(&o.MB12_D5.Reg)
}

// CAN0.MB12_D6: Mailbox Register
func (o *CAN0_Type) SetMB12_D6(value uint8) {
	volatile.StoreUint8(&o.MB12_D6.Reg, value)
}
func (o *CAN0_Type) GetMB12_D6() uint8 {
	return volatile.LoadUint8(&o.MB12_D6.Reg)
}

// CAN0.MB12_D7: Mailbox Register
func (o *CAN0_Type) SetMB12_D7(value uint8) {
	volatile.StoreUint8(&o.MB12_D7.Reg, value)
}
func (o *CAN0_Type) GetMB12_D7() uint8 {
	return volatile.LoadUint8(&o.MB12_D7.Reg)
}

// CAN0.MB12_TS: Mailbox Register
func (o *CAN0_Type) SetMB12_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB12_TS.Reg, volatile.LoadUint16(&o.MB12_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB12_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB12_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB12_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB12_TS.Reg, volatile.LoadUint16(&o.MB12_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB12_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB12_TS.Reg) & 0xff
}

// CAN0.MB13_ID: Mailbox Register
func (o *CAN0_Type) SetMB13_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB13_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB13_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB13_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB13_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB13_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB13_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB13_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB13_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB13_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB13_ID.Reg) & 0x3ffff
}

// CAN0.MB13_DL: Mailbox Register
func (o *CAN0_Type) SetMB13_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB13_DL.Reg, volatile.LoadUint16(&o.MB13_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB13_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB13_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB13_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB13_DL.Reg, volatile.LoadUint16(&o.MB13_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB13_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB13_DL.Reg) & 0xf
}

// CAN0.MB13_D0: Mailbox Register
func (o *CAN0_Type) SetMB13_D0(value uint8) {
	volatile.StoreUint8(&o.MB13_D0.Reg, value)
}
func (o *CAN0_Type) GetMB13_D0() uint8 {
	return volatile.LoadUint8(&o.MB13_D0.Reg)
}

// CAN0.MB13_D1: Mailbox Register
func (o *CAN0_Type) SetMB13_D1(value uint8) {
	volatile.StoreUint8(&o.MB13_D1.Reg, value)
}
func (o *CAN0_Type) GetMB13_D1() uint8 {
	return volatile.LoadUint8(&o.MB13_D1.Reg)
}

// CAN0.MB13_D2: Mailbox Register
func (o *CAN0_Type) SetMB13_D2(value uint8) {
	volatile.StoreUint8(&o.MB13_D2.Reg, value)
}
func (o *CAN0_Type) GetMB13_D2() uint8 {
	return volatile.LoadUint8(&o.MB13_D2.Reg)
}

// CAN0.MB13_D3: Mailbox Register
func (o *CAN0_Type) SetMB13_D3(value uint8) {
	volatile.StoreUint8(&o.MB13_D3.Reg, value)
}
func (o *CAN0_Type) GetMB13_D3() uint8 {
	return volatile.LoadUint8(&o.MB13_D3.Reg)
}

// CAN0.MB13_D4: Mailbox Register
func (o *CAN0_Type) SetMB13_D4(value uint8) {
	volatile.StoreUint8(&o.MB13_D4.Reg, value)
}
func (o *CAN0_Type) GetMB13_D4() uint8 {
	return volatile.LoadUint8(&o.MB13_D4.Reg)
}

// CAN0.MB13_D5: Mailbox Register
func (o *CAN0_Type) SetMB13_D5(value uint8) {
	volatile.StoreUint8(&o.MB13_D5.Reg, value)
}
func (o *CAN0_Type) GetMB13_D5() uint8 {
	return volatile.LoadUint8(&o.MB13_D5.Reg)
}

// CAN0.MB13_D6: Mailbox Register
func (o *CAN0_Type) SetMB13_D6(value uint8) {
	volatile.StoreUint8(&o.MB13_D6.Reg, value)
}
func (o *CAN0_Type) GetMB13_D6() uint8 {
	return volatile.LoadUint8(&o.MB13_D6.Reg)
}

// CAN0.MB13_D7: Mailbox Register
func (o *CAN0_Type) SetMB13_D7(value uint8) {
	volatile.StoreUint8(&o.MB13_D7.Reg, value)
}
func (o *CAN0_Type) GetMB13_D7() uint8 {
	return volatile.LoadUint8(&o.MB13_D7.Reg)
}

// CAN0.MB13_TS: Mailbox Register
func (o *CAN0_Type) SetMB13_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB13_TS.Reg, volatile.LoadUint16(&o.MB13_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB13_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB13_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB13_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB13_TS.Reg, volatile.LoadUint16(&o.MB13_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB13_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB13_TS.Reg) & 0xff
}

// CAN0.MB14_ID: Mailbox Register
func (o *CAN0_Type) SetMB14_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB14_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB14_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB14_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB14_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB14_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB14_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB14_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB14_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB14_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB14_ID.Reg) & 0x3ffff
}

// CAN0.MB14_DL: Mailbox Register
func (o *CAN0_Type) SetMB14_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB14_DL.Reg, volatile.LoadUint16(&o.MB14_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB14_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB14_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB14_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB14_DL.Reg, volatile.LoadUint16(&o.MB14_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB14_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB14_DL.Reg) & 0xf
}

// CAN0.MB14_D0: Mailbox Register
func (o *CAN0_Type) SetMB14_D0(value uint8) {
	volatile.StoreUint8(&o.MB14_D0.Reg, value)
}
func (o *CAN0_Type) GetMB14_D0() uint8 {
	return volatile.LoadUint8(&o.MB14_D0.Reg)
}

// CAN0.MB14_D1: Mailbox Register
func (o *CAN0_Type) SetMB14_D1(value uint8) {
	volatile.StoreUint8(&o.MB14_D1.Reg, value)
}
func (o *CAN0_Type) GetMB14_D1() uint8 {
	return volatile.LoadUint8(&o.MB14_D1.Reg)
}

// CAN0.MB14_D2: Mailbox Register
func (o *CAN0_Type) SetMB14_D2(value uint8) {
	volatile.StoreUint8(&o.MB14_D2.Reg, value)
}
func (o *CAN0_Type) GetMB14_D2() uint8 {
	return volatile.LoadUint8(&o.MB14_D2.Reg)
}

// CAN0.MB14_D3: Mailbox Register
func (o *CAN0_Type) SetMB14_D3(value uint8) {
	volatile.StoreUint8(&o.MB14_D3.Reg, value)
}
func (o *CAN0_Type) GetMB14_D3() uint8 {
	return volatile.LoadUint8(&o.MB14_D3.Reg)
}

// CAN0.MB14_D4: Mailbox Register
func (o *CAN0_Type) SetMB14_D4(value uint8) {
	volatile.StoreUint8(&o.MB14_D4.Reg, value)
}
func (o *CAN0_Type) GetMB14_D4() uint8 {
	return volatile.LoadUint8(&o.MB14_D4.Reg)
}

// CAN0.MB14_D5: Mailbox Register
func (o *CAN0_Type) SetMB14_D5(value uint8) {
	volatile.StoreUint8(&o.MB14_D5.Reg, value)
}
func (o *CAN0_Type) GetMB14_D5() uint8 {
	return volatile.LoadUint8(&o.MB14_D5.Reg)
}

// CAN0.MB14_D6: Mailbox Register
func (o *CAN0_Type) SetMB14_D6(value uint8) {
	volatile.StoreUint8(&o.MB14_D6.Reg, value)
}
func (o *CAN0_Type) GetMB14_D6() uint8 {
	return volatile.LoadUint8(&o.MB14_D6.Reg)
}

// CAN0.MB14_D7: Mailbox Register
func (o *CAN0_Type) SetMB14_D7(value uint8) {
	volatile.StoreUint8(&o.MB14_D7.Reg, value)
}
func (o *CAN0_Type) GetMB14_D7() uint8 {
	return volatile.LoadUint8(&o.MB14_D7.Reg)
}

// CAN0.MB14_TS: Mailbox Register
func (o *CAN0_Type) SetMB14_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB14_TS.Reg, volatile.LoadUint16(&o.MB14_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB14_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB14_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB14_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB14_TS.Reg, volatile.LoadUint16(&o.MB14_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB14_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB14_TS.Reg) & 0xff
}

// CAN0.MB15_ID: Mailbox Register
func (o *CAN0_Type) SetMB15_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB15_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB15_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB15_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB15_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB15_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB15_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB15_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB15_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB15_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB15_ID.Reg) & 0x3ffff
}

// CAN0.MB15_DL: Mailbox Register
func (o *CAN0_Type) SetMB15_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB15_DL.Reg, volatile.LoadUint16(&o.MB15_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB15_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB15_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB15_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB15_DL.Reg, volatile.LoadUint16(&o.MB15_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB15_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB15_DL.Reg) & 0xf
}

// CAN0.MB15_D0: Mailbox Register
func (o *CAN0_Type) SetMB15_D0(value uint8) {
	volatile.StoreUint8(&o.MB15_D0.Reg, value)
}
func (o *CAN0_Type) GetMB15_D0() uint8 {
	return volatile.LoadUint8(&o.MB15_D0.Reg)
}

// CAN0.MB15_D1: Mailbox Register
func (o *CAN0_Type) SetMB15_D1(value uint8) {
	volatile.StoreUint8(&o.MB15_D1.Reg, value)
}
func (o *CAN0_Type) GetMB15_D1() uint8 {
	return volatile.LoadUint8(&o.MB15_D1.Reg)
}

// CAN0.MB15_D2: Mailbox Register
func (o *CAN0_Type) SetMB15_D2(value uint8) {
	volatile.StoreUint8(&o.MB15_D2.Reg, value)
}
func (o *CAN0_Type) GetMB15_D2() uint8 {
	return volatile.LoadUint8(&o.MB15_D2.Reg)
}

// CAN0.MB15_D3: Mailbox Register
func (o *CAN0_Type) SetMB15_D3(value uint8) {
	volatile.StoreUint8(&o.MB15_D3.Reg, value)
}
func (o *CAN0_Type) GetMB15_D3() uint8 {
	return volatile.LoadUint8(&o.MB15_D3.Reg)
}

// CAN0.MB15_D4: Mailbox Register
func (o *CAN0_Type) SetMB15_D4(value uint8) {
	volatile.StoreUint8(&o.MB15_D4.Reg, value)
}
func (o *CAN0_Type) GetMB15_D4() uint8 {
	return volatile.LoadUint8(&o.MB15_D4.Reg)
}

// CAN0.MB15_D5: Mailbox Register
func (o *CAN0_Type) SetMB15_D5(value uint8) {
	volatile.StoreUint8(&o.MB15_D5.Reg, value)
}
func (o *CAN0_Type) GetMB15_D5() uint8 {
	return volatile.LoadUint8(&o.MB15_D5.Reg)
}

// CAN0.MB15_D6: Mailbox Register
func (o *CAN0_Type) SetMB15_D6(value uint8) {
	volatile.StoreUint8(&o.MB15_D6.Reg, value)
}
func (o *CAN0_Type) GetMB15_D6() uint8 {
	return volatile.LoadUint8(&o.MB15_D6.Reg)
}

// CAN0.MB15_D7: Mailbox Register
func (o *CAN0_Type) SetMB15_D7(value uint8) {
	volatile.StoreUint8(&o.MB15_D7.Reg, value)
}
func (o *CAN0_Type) GetMB15_D7() uint8 {
	return volatile.LoadUint8(&o.MB15_D7.Reg)
}

// CAN0.MB15_TS: Mailbox Register
func (o *CAN0_Type) SetMB15_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB15_TS.Reg, volatile.LoadUint16(&o.MB15_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB15_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB15_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB15_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB15_TS.Reg, volatile.LoadUint16(&o.MB15_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB15_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB15_TS.Reg) & 0xff
}

// CAN0.MB16_ID: Mailbox Register
func (o *CAN0_Type) SetMB16_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB16_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB16_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB16_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB16_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB16_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB16_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB16_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB16_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB16_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB16_ID.Reg) & 0x3ffff
}

// CAN0.MB16_DL: Mailbox Register
func (o *CAN0_Type) SetMB16_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB16_DL.Reg, volatile.LoadUint16(&o.MB16_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB16_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB16_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB16_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB16_DL.Reg, volatile.LoadUint16(&o.MB16_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB16_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB16_DL.Reg) & 0xf
}

// CAN0.MB16_D0: Mailbox Register
func (o *CAN0_Type) SetMB16_D0(value uint8) {
	volatile.StoreUint8(&o.MB16_D0.Reg, value)
}
func (o *CAN0_Type) GetMB16_D0() uint8 {
	return volatile.LoadUint8(&o.MB16_D0.Reg)
}

// CAN0.MB16_D1: Mailbox Register
func (o *CAN0_Type) SetMB16_D1(value uint8) {
	volatile.StoreUint8(&o.MB16_D1.Reg, value)
}
func (o *CAN0_Type) GetMB16_D1() uint8 {
	return volatile.LoadUint8(&o.MB16_D1.Reg)
}

// CAN0.MB16_D2: Mailbox Register
func (o *CAN0_Type) SetMB16_D2(value uint8) {
	volatile.StoreUint8(&o.MB16_D2.Reg, value)
}
func (o *CAN0_Type) GetMB16_D2() uint8 {
	return volatile.LoadUint8(&o.MB16_D2.Reg)
}

// CAN0.MB16_D3: Mailbox Register
func (o *CAN0_Type) SetMB16_D3(value uint8) {
	volatile.StoreUint8(&o.MB16_D3.Reg, value)
}
func (o *CAN0_Type) GetMB16_D3() uint8 {
	return volatile.LoadUint8(&o.MB16_D3.Reg)
}

// CAN0.MB16_D4: Mailbox Register
func (o *CAN0_Type) SetMB16_D4(value uint8) {
	volatile.StoreUint8(&o.MB16_D4.Reg, value)
}
func (o *CAN0_Type) GetMB16_D4() uint8 {
	return volatile.LoadUint8(&o.MB16_D4.Reg)
}

// CAN0.MB16_D5: Mailbox Register
func (o *CAN0_Type) SetMB16_D5(value uint8) {
	volatile.StoreUint8(&o.MB16_D5.Reg, value)
}
func (o *CAN0_Type) GetMB16_D5() uint8 {
	return volatile.LoadUint8(&o.MB16_D5.Reg)
}

// CAN0.MB16_D6: Mailbox Register
func (o *CAN0_Type) SetMB16_D6(value uint8) {
	volatile.StoreUint8(&o.MB16_D6.Reg, value)
}
func (o *CAN0_Type) GetMB16_D6() uint8 {
	return volatile.LoadUint8(&o.MB16_D6.Reg)
}

// CAN0.MB16_D7: Mailbox Register
func (o *CAN0_Type) SetMB16_D7(value uint8) {
	volatile.StoreUint8(&o.MB16_D7.Reg, value)
}
func (o *CAN0_Type) GetMB16_D7() uint8 {
	return volatile.LoadUint8(&o.MB16_D7.Reg)
}

// CAN0.MB16_TS: Mailbox Register
func (o *CAN0_Type) SetMB16_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB16_TS.Reg, volatile.LoadUint16(&o.MB16_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB16_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB16_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB16_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB16_TS.Reg, volatile.LoadUint16(&o.MB16_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB16_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB16_TS.Reg) & 0xff
}

// CAN0.MB17_ID: Mailbox Register
func (o *CAN0_Type) SetMB17_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB17_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB17_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB17_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB17_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB17_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB17_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB17_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB17_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB17_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB17_ID.Reg) & 0x3ffff
}

// CAN0.MB17_DL: Mailbox Register
func (o *CAN0_Type) SetMB17_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB17_DL.Reg, volatile.LoadUint16(&o.MB17_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB17_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB17_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB17_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB17_DL.Reg, volatile.LoadUint16(&o.MB17_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB17_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB17_DL.Reg) & 0xf
}

// CAN0.MB17_D0: Mailbox Register
func (o *CAN0_Type) SetMB17_D0(value uint8) {
	volatile.StoreUint8(&o.MB17_D0.Reg, value)
}
func (o *CAN0_Type) GetMB17_D0() uint8 {
	return volatile.LoadUint8(&o.MB17_D0.Reg)
}

// CAN0.MB17_D1: Mailbox Register
func (o *CAN0_Type) SetMB17_D1(value uint8) {
	volatile.StoreUint8(&o.MB17_D1.Reg, value)
}
func (o *CAN0_Type) GetMB17_D1() uint8 {
	return volatile.LoadUint8(&o.MB17_D1.Reg)
}

// CAN0.MB17_D2: Mailbox Register
func (o *CAN0_Type) SetMB17_D2(value uint8) {
	volatile.StoreUint8(&o.MB17_D2.Reg, value)
}
func (o *CAN0_Type) GetMB17_D2() uint8 {
	return volatile.LoadUint8(&o.MB17_D2.Reg)
}

// CAN0.MB17_D3: Mailbox Register
func (o *CAN0_Type) SetMB17_D3(value uint8) {
	volatile.StoreUint8(&o.MB17_D3.Reg, value)
}
func (o *CAN0_Type) GetMB17_D3() uint8 {
	return volatile.LoadUint8(&o.MB17_D3.Reg)
}

// CAN0.MB17_D4: Mailbox Register
func (o *CAN0_Type) SetMB17_D4(value uint8) {
	volatile.StoreUint8(&o.MB17_D4.Reg, value)
}
func (o *CAN0_Type) GetMB17_D4() uint8 {
	return volatile.LoadUint8(&o.MB17_D4.Reg)
}

// CAN0.MB17_D5: Mailbox Register
func (o *CAN0_Type) SetMB17_D5(value uint8) {
	volatile.StoreUint8(&o.MB17_D5.Reg, value)
}
func (o *CAN0_Type) GetMB17_D5() uint8 {
	return volatile.LoadUint8(&o.MB17_D5.Reg)
}

// CAN0.MB17_D6: Mailbox Register
func (o *CAN0_Type) SetMB17_D6(value uint8) {
	volatile.StoreUint8(&o.MB17_D6.Reg, value)
}
func (o *CAN0_Type) GetMB17_D6() uint8 {
	return volatile.LoadUint8(&o.MB17_D6.Reg)
}

// CAN0.MB17_D7: Mailbox Register
func (o *CAN0_Type) SetMB17_D7(value uint8) {
	volatile.StoreUint8(&o.MB17_D7.Reg, value)
}
func (o *CAN0_Type) GetMB17_D7() uint8 {
	return volatile.LoadUint8(&o.MB17_D7.Reg)
}

// CAN0.MB17_TS: Mailbox Register
func (o *CAN0_Type) SetMB17_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB17_TS.Reg, volatile.LoadUint16(&o.MB17_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB17_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB17_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB17_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB17_TS.Reg, volatile.LoadUint16(&o.MB17_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB17_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB17_TS.Reg) & 0xff
}

// CAN0.MB18_ID: Mailbox Register
func (o *CAN0_Type) SetMB18_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB18_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB18_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB18_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB18_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB18_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB18_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB18_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB18_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB18_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB18_ID.Reg) & 0x3ffff
}

// CAN0.MB18_DL: Mailbox Register
func (o *CAN0_Type) SetMB18_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB18_DL.Reg, volatile.LoadUint16(&o.MB18_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB18_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB18_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB18_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB18_DL.Reg, volatile.LoadUint16(&o.MB18_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB18_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB18_DL.Reg) & 0xf
}

// CAN0.MB18_D0: Mailbox Register
func (o *CAN0_Type) SetMB18_D0(value uint8) {
	volatile.StoreUint8(&o.MB18_D0.Reg, value)
}
func (o *CAN0_Type) GetMB18_D0() uint8 {
	return volatile.LoadUint8(&o.MB18_D0.Reg)
}

// CAN0.MB18_D1: Mailbox Register
func (o *CAN0_Type) SetMB18_D1(value uint8) {
	volatile.StoreUint8(&o.MB18_D1.Reg, value)
}
func (o *CAN0_Type) GetMB18_D1() uint8 {
	return volatile.LoadUint8(&o.MB18_D1.Reg)
}

// CAN0.MB18_D2: Mailbox Register
func (o *CAN0_Type) SetMB18_D2(value uint8) {
	volatile.StoreUint8(&o.MB18_D2.Reg, value)
}
func (o *CAN0_Type) GetMB18_D2() uint8 {
	return volatile.LoadUint8(&o.MB18_D2.Reg)
}

// CAN0.MB18_D3: Mailbox Register
func (o *CAN0_Type) SetMB18_D3(value uint8) {
	volatile.StoreUint8(&o.MB18_D3.Reg, value)
}
func (o *CAN0_Type) GetMB18_D3() uint8 {
	return volatile.LoadUint8(&o.MB18_D3.Reg)
}

// CAN0.MB18_D4: Mailbox Register
func (o *CAN0_Type) SetMB18_D4(value uint8) {
	volatile.StoreUint8(&o.MB18_D4.Reg, value)
}
func (o *CAN0_Type) GetMB18_D4() uint8 {
	return volatile.LoadUint8(&o.MB18_D4.Reg)
}

// CAN0.MB18_D5: Mailbox Register
func (o *CAN0_Type) SetMB18_D5(value uint8) {
	volatile.StoreUint8(&o.MB18_D5.Reg, value)
}
func (o *CAN0_Type) GetMB18_D5() uint8 {
	return volatile.LoadUint8(&o.MB18_D5.Reg)
}

// CAN0.MB18_D6: Mailbox Register
func (o *CAN0_Type) SetMB18_D6(value uint8) {
	volatile.StoreUint8(&o.MB18_D6.Reg, value)
}
func (o *CAN0_Type) GetMB18_D6() uint8 {
	return volatile.LoadUint8(&o.MB18_D6.Reg)
}

// CAN0.MB18_D7: Mailbox Register
func (o *CAN0_Type) SetMB18_D7(value uint8) {
	volatile.StoreUint8(&o.MB18_D7.Reg, value)
}
func (o *CAN0_Type) GetMB18_D7() uint8 {
	return volatile.LoadUint8(&o.MB18_D7.Reg)
}

// CAN0.MB18_TS: Mailbox Register
func (o *CAN0_Type) SetMB18_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB18_TS.Reg, volatile.LoadUint16(&o.MB18_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB18_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB18_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB18_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB18_TS.Reg, volatile.LoadUint16(&o.MB18_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB18_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB18_TS.Reg) & 0xff
}

// CAN0.MB19_ID: Mailbox Register
func (o *CAN0_Type) SetMB19_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB19_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB19_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB19_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB19_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB19_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB19_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB19_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB19_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB19_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB19_ID.Reg) & 0x3ffff
}

// CAN0.MB19_DL: Mailbox Register
func (o *CAN0_Type) SetMB19_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB19_DL.Reg, volatile.LoadUint16(&o.MB19_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB19_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB19_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB19_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB19_DL.Reg, volatile.LoadUint16(&o.MB19_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB19_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB19_DL.Reg) & 0xf
}

// CAN0.MB19_D0: Mailbox Register
func (o *CAN0_Type) SetMB19_D0(value uint8) {
	volatile.StoreUint8(&o.MB19_D0.Reg, value)
}
func (o *CAN0_Type) GetMB19_D0() uint8 {
	return volatile.LoadUint8(&o.MB19_D0.Reg)
}

// CAN0.MB19_D1: Mailbox Register
func (o *CAN0_Type) SetMB19_D1(value uint8) {
	volatile.StoreUint8(&o.MB19_D1.Reg, value)
}
func (o *CAN0_Type) GetMB19_D1() uint8 {
	return volatile.LoadUint8(&o.MB19_D1.Reg)
}

// CAN0.MB19_D2: Mailbox Register
func (o *CAN0_Type) SetMB19_D2(value uint8) {
	volatile.StoreUint8(&o.MB19_D2.Reg, value)
}
func (o *CAN0_Type) GetMB19_D2() uint8 {
	return volatile.LoadUint8(&o.MB19_D2.Reg)
}

// CAN0.MB19_D3: Mailbox Register
func (o *CAN0_Type) SetMB19_D3(value uint8) {
	volatile.StoreUint8(&o.MB19_D3.Reg, value)
}
func (o *CAN0_Type) GetMB19_D3() uint8 {
	return volatile.LoadUint8(&o.MB19_D3.Reg)
}

// CAN0.MB19_D4: Mailbox Register
func (o *CAN0_Type) SetMB19_D4(value uint8) {
	volatile.StoreUint8(&o.MB19_D4.Reg, value)
}
func (o *CAN0_Type) GetMB19_D4() uint8 {
	return volatile.LoadUint8(&o.MB19_D4.Reg)
}

// CAN0.MB19_D5: Mailbox Register
func (o *CAN0_Type) SetMB19_D5(value uint8) {
	volatile.StoreUint8(&o.MB19_D5.Reg, value)
}
func (o *CAN0_Type) GetMB19_D5() uint8 {
	return volatile.LoadUint8(&o.MB19_D5.Reg)
}

// CAN0.MB19_D6: Mailbox Register
func (o *CAN0_Type) SetMB19_D6(value uint8) {
	volatile.StoreUint8(&o.MB19_D6.Reg, value)
}
func (o *CAN0_Type) GetMB19_D6() uint8 {
	return volatile.LoadUint8(&o.MB19_D6.Reg)
}

// CAN0.MB19_D7: Mailbox Register
func (o *CAN0_Type) SetMB19_D7(value uint8) {
	volatile.StoreUint8(&o.MB19_D7.Reg, value)
}
func (o *CAN0_Type) GetMB19_D7() uint8 {
	return volatile.LoadUint8(&o.MB19_D7.Reg)
}

// CAN0.MB19_TS: Mailbox Register
func (o *CAN0_Type) SetMB19_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB19_TS.Reg, volatile.LoadUint16(&o.MB19_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB19_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB19_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB19_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB19_TS.Reg, volatile.LoadUint16(&o.MB19_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB19_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB19_TS.Reg) & 0xff
}

// CAN0.MB20_ID: Mailbox Register
func (o *CAN0_Type) SetMB20_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB20_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB20_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB20_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB20_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB20_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB20_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB20_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB20_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB20_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB20_ID.Reg) & 0x3ffff
}

// CAN0.MB20_DL: Mailbox Register
func (o *CAN0_Type) SetMB20_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB20_DL.Reg, volatile.LoadUint16(&o.MB20_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB20_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB20_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB20_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB20_DL.Reg, volatile.LoadUint16(&o.MB20_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB20_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB20_DL.Reg) & 0xf
}

// CAN0.MB20_D0: Mailbox Register
func (o *CAN0_Type) SetMB20_D0(value uint8) {
	volatile.StoreUint8(&o.MB20_D0.Reg, value)
}
func (o *CAN0_Type) GetMB20_D0() uint8 {
	return volatile.LoadUint8(&o.MB20_D0.Reg)
}

// CAN0.MB20_D1: Mailbox Register
func (o *CAN0_Type) SetMB20_D1(value uint8) {
	volatile.StoreUint8(&o.MB20_D1.Reg, value)
}
func (o *CAN0_Type) GetMB20_D1() uint8 {
	return volatile.LoadUint8(&o.MB20_D1.Reg)
}

// CAN0.MB20_D2: Mailbox Register
func (o *CAN0_Type) SetMB20_D2(value uint8) {
	volatile.StoreUint8(&o.MB20_D2.Reg, value)
}
func (o *CAN0_Type) GetMB20_D2() uint8 {
	return volatile.LoadUint8(&o.MB20_D2.Reg)
}

// CAN0.MB20_D3: Mailbox Register
func (o *CAN0_Type) SetMB20_D3(value uint8) {
	volatile.StoreUint8(&o.MB20_D3.Reg, value)
}
func (o *CAN0_Type) GetMB20_D3() uint8 {
	return volatile.LoadUint8(&o.MB20_D3.Reg)
}

// CAN0.MB20_D4: Mailbox Register
func (o *CAN0_Type) SetMB20_D4(value uint8) {
	volatile.StoreUint8(&o.MB20_D4.Reg, value)
}
func (o *CAN0_Type) GetMB20_D4() uint8 {
	return volatile.LoadUint8(&o.MB20_D4.Reg)
}

// CAN0.MB20_D5: Mailbox Register
func (o *CAN0_Type) SetMB20_D5(value uint8) {
	volatile.StoreUint8(&o.MB20_D5.Reg, value)
}
func (o *CAN0_Type) GetMB20_D5() uint8 {
	return volatile.LoadUint8(&o.MB20_D5.Reg)
}

// CAN0.MB20_D6: Mailbox Register
func (o *CAN0_Type) SetMB20_D6(value uint8) {
	volatile.StoreUint8(&o.MB20_D6.Reg, value)
}
func (o *CAN0_Type) GetMB20_D6() uint8 {
	return volatile.LoadUint8(&o.MB20_D6.Reg)
}

// CAN0.MB20_D7: Mailbox Register
func (o *CAN0_Type) SetMB20_D7(value uint8) {
	volatile.StoreUint8(&o.MB20_D7.Reg, value)
}
func (o *CAN0_Type) GetMB20_D7() uint8 {
	return volatile.LoadUint8(&o.MB20_D7.Reg)
}

// CAN0.MB20_TS: Mailbox Register
func (o *CAN0_Type) SetMB20_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB20_TS.Reg, volatile.LoadUint16(&o.MB20_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB20_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB20_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB20_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB20_TS.Reg, volatile.LoadUint16(&o.MB20_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB20_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB20_TS.Reg) & 0xff
}

// CAN0.MB21_ID: Mailbox Register
func (o *CAN0_Type) SetMB21_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB21_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB21_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB21_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB21_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB21_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB21_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB21_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB21_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB21_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB21_ID.Reg) & 0x3ffff
}

// CAN0.MB21_DL: Mailbox Register
func (o *CAN0_Type) SetMB21_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB21_DL.Reg, volatile.LoadUint16(&o.MB21_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB21_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB21_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB21_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB21_DL.Reg, volatile.LoadUint16(&o.MB21_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB21_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB21_DL.Reg) & 0xf
}

// CAN0.MB21_D0: Mailbox Register
func (o *CAN0_Type) SetMB21_D0(value uint8) {
	volatile.StoreUint8(&o.MB21_D0.Reg, value)
}
func (o *CAN0_Type) GetMB21_D0() uint8 {
	return volatile.LoadUint8(&o.MB21_D0.Reg)
}

// CAN0.MB21_D1: Mailbox Register
func (o *CAN0_Type) SetMB21_D1(value uint8) {
	volatile.StoreUint8(&o.MB21_D1.Reg, value)
}
func (o *CAN0_Type) GetMB21_D1() uint8 {
	return volatile.LoadUint8(&o.MB21_D1.Reg)
}

// CAN0.MB21_D2: Mailbox Register
func (o *CAN0_Type) SetMB21_D2(value uint8) {
	volatile.StoreUint8(&o.MB21_D2.Reg, value)
}
func (o *CAN0_Type) GetMB21_D2() uint8 {
	return volatile.LoadUint8(&o.MB21_D2.Reg)
}

// CAN0.MB21_D3: Mailbox Register
func (o *CAN0_Type) SetMB21_D3(value uint8) {
	volatile.StoreUint8(&o.MB21_D3.Reg, value)
}
func (o *CAN0_Type) GetMB21_D3() uint8 {
	return volatile.LoadUint8(&o.MB21_D3.Reg)
}

// CAN0.MB21_D4: Mailbox Register
func (o *CAN0_Type) SetMB21_D4(value uint8) {
	volatile.StoreUint8(&o.MB21_D4.Reg, value)
}
func (o *CAN0_Type) GetMB21_D4() uint8 {
	return volatile.LoadUint8(&o.MB21_D4.Reg)
}

// CAN0.MB21_D5: Mailbox Register
func (o *CAN0_Type) SetMB21_D5(value uint8) {
	volatile.StoreUint8(&o.MB21_D5.Reg, value)
}
func (o *CAN0_Type) GetMB21_D5() uint8 {
	return volatile.LoadUint8(&o.MB21_D5.Reg)
}

// CAN0.MB21_D6: Mailbox Register
func (o *CAN0_Type) SetMB21_D6(value uint8) {
	volatile.StoreUint8(&o.MB21_D6.Reg, value)
}
func (o *CAN0_Type) GetMB21_D6() uint8 {
	return volatile.LoadUint8(&o.MB21_D6.Reg)
}

// CAN0.MB21_D7: Mailbox Register
func (o *CAN0_Type) SetMB21_D7(value uint8) {
	volatile.StoreUint8(&o.MB21_D7.Reg, value)
}
func (o *CAN0_Type) GetMB21_D7() uint8 {
	return volatile.LoadUint8(&o.MB21_D7.Reg)
}

// CAN0.MB21_TS: Mailbox Register
func (o *CAN0_Type) SetMB21_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB21_TS.Reg, volatile.LoadUint16(&o.MB21_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB21_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB21_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB21_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB21_TS.Reg, volatile.LoadUint16(&o.MB21_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB21_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB21_TS.Reg) & 0xff
}

// CAN0.MB22_ID: Mailbox Register
func (o *CAN0_Type) SetMB22_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB22_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB22_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB22_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB22_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB22_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB22_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB22_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB22_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB22_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB22_ID.Reg) & 0x3ffff
}

// CAN0.MB22_DL: Mailbox Register
func (o *CAN0_Type) SetMB22_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB22_DL.Reg, volatile.LoadUint16(&o.MB22_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB22_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB22_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB22_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB22_DL.Reg, volatile.LoadUint16(&o.MB22_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB22_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB22_DL.Reg) & 0xf
}

// CAN0.MB22_D0: Mailbox Register
func (o *CAN0_Type) SetMB22_D0(value uint8) {
	volatile.StoreUint8(&o.MB22_D0.Reg, value)
}
func (o *CAN0_Type) GetMB22_D0() uint8 {
	return volatile.LoadUint8(&o.MB22_D0.Reg)
}

// CAN0.MB22_D1: Mailbox Register
func (o *CAN0_Type) SetMB22_D1(value uint8) {
	volatile.StoreUint8(&o.MB22_D1.Reg, value)
}
func (o *CAN0_Type) GetMB22_D1() uint8 {
	return volatile.LoadUint8(&o.MB22_D1.Reg)
}

// CAN0.MB22_D2: Mailbox Register
func (o *CAN0_Type) SetMB22_D2(value uint8) {
	volatile.StoreUint8(&o.MB22_D2.Reg, value)
}
func (o *CAN0_Type) GetMB22_D2() uint8 {
	return volatile.LoadUint8(&o.MB22_D2.Reg)
}

// CAN0.MB22_D3: Mailbox Register
func (o *CAN0_Type) SetMB22_D3(value uint8) {
	volatile.StoreUint8(&o.MB22_D3.Reg, value)
}
func (o *CAN0_Type) GetMB22_D3() uint8 {
	return volatile.LoadUint8(&o.MB22_D3.Reg)
}

// CAN0.MB22_D4: Mailbox Register
func (o *CAN0_Type) SetMB22_D4(value uint8) {
	volatile.StoreUint8(&o.MB22_D4.Reg, value)
}
func (o *CAN0_Type) GetMB22_D4() uint8 {
	return volatile.LoadUint8(&o.MB22_D4.Reg)
}

// CAN0.MB22_D5: Mailbox Register
func (o *CAN0_Type) SetMB22_D5(value uint8) {
	volatile.StoreUint8(&o.MB22_D5.Reg, value)
}
func (o *CAN0_Type) GetMB22_D5() uint8 {
	return volatile.LoadUint8(&o.MB22_D5.Reg)
}

// CAN0.MB22_D6: Mailbox Register
func (o *CAN0_Type) SetMB22_D6(value uint8) {
	volatile.StoreUint8(&o.MB22_D6.Reg, value)
}
func (o *CAN0_Type) GetMB22_D6() uint8 {
	return volatile.LoadUint8(&o.MB22_D6.Reg)
}

// CAN0.MB22_D7: Mailbox Register
func (o *CAN0_Type) SetMB22_D7(value uint8) {
	volatile.StoreUint8(&o.MB22_D7.Reg, value)
}
func (o *CAN0_Type) GetMB22_D7() uint8 {
	return volatile.LoadUint8(&o.MB22_D7.Reg)
}

// CAN0.MB22_TS: Mailbox Register
func (o *CAN0_Type) SetMB22_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB22_TS.Reg, volatile.LoadUint16(&o.MB22_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB22_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB22_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB22_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB22_TS.Reg, volatile.LoadUint16(&o.MB22_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB22_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB22_TS.Reg) & 0xff
}

// CAN0.MB23_ID: Mailbox Register
func (o *CAN0_Type) SetMB23_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB23_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB23_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB23_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB23_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB23_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB23_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB23_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB23_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB23_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB23_ID.Reg) & 0x3ffff
}

// CAN0.MB23_DL: Mailbox Register
func (o *CAN0_Type) SetMB23_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB23_DL.Reg, volatile.LoadUint16(&o.MB23_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB23_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB23_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB23_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB23_DL.Reg, volatile.LoadUint16(&o.MB23_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB23_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB23_DL.Reg) & 0xf
}

// CAN0.MB23_D0: Mailbox Register
func (o *CAN0_Type) SetMB23_D0(value uint8) {
	volatile.StoreUint8(&o.MB23_D0.Reg, value)
}
func (o *CAN0_Type) GetMB23_D0() uint8 {
	return volatile.LoadUint8(&o.MB23_D0.Reg)
}

// CAN0.MB23_D1: Mailbox Register
func (o *CAN0_Type) SetMB23_D1(value uint8) {
	volatile.StoreUint8(&o.MB23_D1.Reg, value)
}
func (o *CAN0_Type) GetMB23_D1() uint8 {
	return volatile.LoadUint8(&o.MB23_D1.Reg)
}

// CAN0.MB23_D2: Mailbox Register
func (o *CAN0_Type) SetMB23_D2(value uint8) {
	volatile.StoreUint8(&o.MB23_D2.Reg, value)
}
func (o *CAN0_Type) GetMB23_D2() uint8 {
	return volatile.LoadUint8(&o.MB23_D2.Reg)
}

// CAN0.MB23_D3: Mailbox Register
func (o *CAN0_Type) SetMB23_D3(value uint8) {
	volatile.StoreUint8(&o.MB23_D3.Reg, value)
}
func (o *CAN0_Type) GetMB23_D3() uint8 {
	return volatile.LoadUint8(&o.MB23_D3.Reg)
}

// CAN0.MB23_D4: Mailbox Register
func (o *CAN0_Type) SetMB23_D4(value uint8) {
	volatile.StoreUint8(&o.MB23_D4.Reg, value)
}
func (o *CAN0_Type) GetMB23_D4() uint8 {
	return volatile.LoadUint8(&o.MB23_D4.Reg)
}

// CAN0.MB23_D5: Mailbox Register
func (o *CAN0_Type) SetMB23_D5(value uint8) {
	volatile.StoreUint8(&o.MB23_D5.Reg, value)
}
func (o *CAN0_Type) GetMB23_D5() uint8 {
	return volatile.LoadUint8(&o.MB23_D5.Reg)
}

// CAN0.MB23_D6: Mailbox Register
func (o *CAN0_Type) SetMB23_D6(value uint8) {
	volatile.StoreUint8(&o.MB23_D6.Reg, value)
}
func (o *CAN0_Type) GetMB23_D6() uint8 {
	return volatile.LoadUint8(&o.MB23_D6.Reg)
}

// CAN0.MB23_D7: Mailbox Register
func (o *CAN0_Type) SetMB23_D7(value uint8) {
	volatile.StoreUint8(&o.MB23_D7.Reg, value)
}
func (o *CAN0_Type) GetMB23_D7() uint8 {
	return volatile.LoadUint8(&o.MB23_D7.Reg)
}

// CAN0.MB23_TS: Mailbox Register
func (o *CAN0_Type) SetMB23_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB23_TS.Reg, volatile.LoadUint16(&o.MB23_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB23_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB23_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB23_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB23_TS.Reg, volatile.LoadUint16(&o.MB23_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB23_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB23_TS.Reg) & 0xff
}

// CAN0.MB24_ID: Mailbox Register
func (o *CAN0_Type) SetMB24_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB24_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB24_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB24_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB24_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB24_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB24_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB24_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB24_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB24_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB24_ID.Reg) & 0x3ffff
}

// CAN0.MB24_DL: Mailbox Register
func (o *CAN0_Type) SetMB24_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB24_DL.Reg, volatile.LoadUint16(&o.MB24_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB24_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB24_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB24_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB24_DL.Reg, volatile.LoadUint16(&o.MB24_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB24_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB24_DL.Reg) & 0xf
}

// CAN0.MB24_D0: Mailbox Register
func (o *CAN0_Type) SetMB24_D0(value uint8) {
	volatile.StoreUint8(&o.MB24_D0.Reg, value)
}
func (o *CAN0_Type) GetMB24_D0() uint8 {
	return volatile.LoadUint8(&o.MB24_D0.Reg)
}

// CAN0.MB24_D1: Mailbox Register
func (o *CAN0_Type) SetMB24_D1(value uint8) {
	volatile.StoreUint8(&o.MB24_D1.Reg, value)
}
func (o *CAN0_Type) GetMB24_D1() uint8 {
	return volatile.LoadUint8(&o.MB24_D1.Reg)
}

// CAN0.MB24_D2: Mailbox Register
func (o *CAN0_Type) SetMB24_D2(value uint8) {
	volatile.StoreUint8(&o.MB24_D2.Reg, value)
}
func (o *CAN0_Type) GetMB24_D2() uint8 {
	return volatile.LoadUint8(&o.MB24_D2.Reg)
}

// CAN0.MB24_D3: Mailbox Register
func (o *CAN0_Type) SetMB24_D3(value uint8) {
	volatile.StoreUint8(&o.MB24_D3.Reg, value)
}
func (o *CAN0_Type) GetMB24_D3() uint8 {
	return volatile.LoadUint8(&o.MB24_D3.Reg)
}

// CAN0.MB24_D4: Mailbox Register
func (o *CAN0_Type) SetMB24_D4(value uint8) {
	volatile.StoreUint8(&o.MB24_D4.Reg, value)
}
func (o *CAN0_Type) GetMB24_D4() uint8 {
	return volatile.LoadUint8(&o.MB24_D4.Reg)
}

// CAN0.MB24_D5: Mailbox Register
func (o *CAN0_Type) SetMB24_D5(value uint8) {
	volatile.StoreUint8(&o.MB24_D5.Reg, value)
}
func (o *CAN0_Type) GetMB24_D5() uint8 {
	return volatile.LoadUint8(&o.MB24_D5.Reg)
}

// CAN0.MB24_D6: Mailbox Register
func (o *CAN0_Type) SetMB24_D6(value uint8) {
	volatile.StoreUint8(&o.MB24_D6.Reg, value)
}
func (o *CAN0_Type) GetMB24_D6() uint8 {
	return volatile.LoadUint8(&o.MB24_D6.Reg)
}

// CAN0.MB24_D7: Mailbox Register
func (o *CAN0_Type) SetMB24_D7(value uint8) {
	volatile.StoreUint8(&o.MB24_D7.Reg, value)
}
func (o *CAN0_Type) GetMB24_D7() uint8 {
	return volatile.LoadUint8(&o.MB24_D7.Reg)
}

// CAN0.MB24_TS: Mailbox Register
func (o *CAN0_Type) SetMB24_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB24_TS.Reg, volatile.LoadUint16(&o.MB24_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB24_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB24_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB24_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB24_TS.Reg, volatile.LoadUint16(&o.MB24_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB24_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB24_TS.Reg) & 0xff
}

// CAN0.MB25_ID: Mailbox Register
func (o *CAN0_Type) SetMB25_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB25_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB25_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB25_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB25_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB25_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB25_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB25_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB25_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB25_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB25_ID.Reg) & 0x3ffff
}

// CAN0.MB25_DL: Mailbox Register
func (o *CAN0_Type) SetMB25_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB25_DL.Reg, volatile.LoadUint16(&o.MB25_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB25_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB25_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB25_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB25_DL.Reg, volatile.LoadUint16(&o.MB25_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB25_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB25_DL.Reg) & 0xf
}

// CAN0.MB25_D0: Mailbox Register
func (o *CAN0_Type) SetMB25_D0(value uint8) {
	volatile.StoreUint8(&o.MB25_D0.Reg, value)
}
func (o *CAN0_Type) GetMB25_D0() uint8 {
	return volatile.LoadUint8(&o.MB25_D0.Reg)
}

// CAN0.MB25_D1: Mailbox Register
func (o *CAN0_Type) SetMB25_D1(value uint8) {
	volatile.StoreUint8(&o.MB25_D1.Reg, value)
}
func (o *CAN0_Type) GetMB25_D1() uint8 {
	return volatile.LoadUint8(&o.MB25_D1.Reg)
}

// CAN0.MB25_D2: Mailbox Register
func (o *CAN0_Type) SetMB25_D2(value uint8) {
	volatile.StoreUint8(&o.MB25_D2.Reg, value)
}
func (o *CAN0_Type) GetMB25_D2() uint8 {
	return volatile.LoadUint8(&o.MB25_D2.Reg)
}

// CAN0.MB25_D3: Mailbox Register
func (o *CAN0_Type) SetMB25_D3(value uint8) {
	volatile.StoreUint8(&o.MB25_D3.Reg, value)
}
func (o *CAN0_Type) GetMB25_D3() uint8 {
	return volatile.LoadUint8(&o.MB25_D3.Reg)
}

// CAN0.MB25_D4: Mailbox Register
func (o *CAN0_Type) SetMB25_D4(value uint8) {
	volatile.StoreUint8(&o.MB25_D4.Reg, value)
}
func (o *CAN0_Type) GetMB25_D4() uint8 {
	return volatile.LoadUint8(&o.MB25_D4.Reg)
}

// CAN0.MB25_D5: Mailbox Register
func (o *CAN0_Type) SetMB25_D5(value uint8) {
	volatile.StoreUint8(&o.MB25_D5.Reg, value)
}
func (o *CAN0_Type) GetMB25_D5() uint8 {
	return volatile.LoadUint8(&o.MB25_D5.Reg)
}

// CAN0.MB25_D6: Mailbox Register
func (o *CAN0_Type) SetMB25_D6(value uint8) {
	volatile.StoreUint8(&o.MB25_D6.Reg, value)
}
func (o *CAN0_Type) GetMB25_D6() uint8 {
	return volatile.LoadUint8(&o.MB25_D6.Reg)
}

// CAN0.MB25_D7: Mailbox Register
func (o *CAN0_Type) SetMB25_D7(value uint8) {
	volatile.StoreUint8(&o.MB25_D7.Reg, value)
}
func (o *CAN0_Type) GetMB25_D7() uint8 {
	return volatile.LoadUint8(&o.MB25_D7.Reg)
}

// CAN0.MB25_TS: Mailbox Register
func (o *CAN0_Type) SetMB25_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB25_TS.Reg, volatile.LoadUint16(&o.MB25_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB25_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB25_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB25_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB25_TS.Reg, volatile.LoadUint16(&o.MB25_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB25_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB25_TS.Reg) & 0xff
}

// CAN0.MB26_ID: Mailbox Register
func (o *CAN0_Type) SetMB26_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB26_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB26_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB26_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB26_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB26_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB26_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB26_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB26_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB26_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB26_ID.Reg) & 0x3ffff
}

// CAN0.MB26_DL: Mailbox Register
func (o *CAN0_Type) SetMB26_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB26_DL.Reg, volatile.LoadUint16(&o.MB26_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB26_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB26_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB26_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB26_DL.Reg, volatile.LoadUint16(&o.MB26_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB26_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB26_DL.Reg) & 0xf
}

// CAN0.MB26_D0: Mailbox Register
func (o *CAN0_Type) SetMB26_D0(value uint8) {
	volatile.StoreUint8(&o.MB26_D0.Reg, value)
}
func (o *CAN0_Type) GetMB26_D0() uint8 {
	return volatile.LoadUint8(&o.MB26_D0.Reg)
}

// CAN0.MB26_D1: Mailbox Register
func (o *CAN0_Type) SetMB26_D1(value uint8) {
	volatile.StoreUint8(&o.MB26_D1.Reg, value)
}
func (o *CAN0_Type) GetMB26_D1() uint8 {
	return volatile.LoadUint8(&o.MB26_D1.Reg)
}

// CAN0.MB26_D2: Mailbox Register
func (o *CAN0_Type) SetMB26_D2(value uint8) {
	volatile.StoreUint8(&o.MB26_D2.Reg, value)
}
func (o *CAN0_Type) GetMB26_D2() uint8 {
	return volatile.LoadUint8(&o.MB26_D2.Reg)
}

// CAN0.MB26_D3: Mailbox Register
func (o *CAN0_Type) SetMB26_D3(value uint8) {
	volatile.StoreUint8(&o.MB26_D3.Reg, value)
}
func (o *CAN0_Type) GetMB26_D3() uint8 {
	return volatile.LoadUint8(&o.MB26_D3.Reg)
}

// CAN0.MB26_D4: Mailbox Register
func (o *CAN0_Type) SetMB26_D4(value uint8) {
	volatile.StoreUint8(&o.MB26_D4.Reg, value)
}
func (o *CAN0_Type) GetMB26_D4() uint8 {
	return volatile.LoadUint8(&o.MB26_D4.Reg)
}

// CAN0.MB26_D5: Mailbox Register
func (o *CAN0_Type) SetMB26_D5(value uint8) {
	volatile.StoreUint8(&o.MB26_D5.Reg, value)
}
func (o *CAN0_Type) GetMB26_D5() uint8 {
	return volatile.LoadUint8(&o.MB26_D5.Reg)
}

// CAN0.MB26_D6: Mailbox Register
func (o *CAN0_Type) SetMB26_D6(value uint8) {
	volatile.StoreUint8(&o.MB26_D6.Reg, value)
}
func (o *CAN0_Type) GetMB26_D6() uint8 {
	return volatile.LoadUint8(&o.MB26_D6.Reg)
}

// CAN0.MB26_D7: Mailbox Register
func (o *CAN0_Type) SetMB26_D7(value uint8) {
	volatile.StoreUint8(&o.MB26_D7.Reg, value)
}
func (o *CAN0_Type) GetMB26_D7() uint8 {
	return volatile.LoadUint8(&o.MB26_D7.Reg)
}

// CAN0.MB26_TS: Mailbox Register
func (o *CAN0_Type) SetMB26_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB26_TS.Reg, volatile.LoadUint16(&o.MB26_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB26_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB26_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB26_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB26_TS.Reg, volatile.LoadUint16(&o.MB26_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB26_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB26_TS.Reg) & 0xff
}

// CAN0.MB27_ID: Mailbox Register
func (o *CAN0_Type) SetMB27_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB27_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB27_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB27_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB27_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB27_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB27_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB27_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB27_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB27_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB27_ID.Reg) & 0x3ffff
}

// CAN0.MB27_DL: Mailbox Register
func (o *CAN0_Type) SetMB27_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB27_DL.Reg, volatile.LoadUint16(&o.MB27_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB27_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB27_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB27_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB27_DL.Reg, volatile.LoadUint16(&o.MB27_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB27_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB27_DL.Reg) & 0xf
}

// CAN0.MB27_D0: Mailbox Register
func (o *CAN0_Type) SetMB27_D0(value uint8) {
	volatile.StoreUint8(&o.MB27_D0.Reg, value)
}
func (o *CAN0_Type) GetMB27_D0() uint8 {
	return volatile.LoadUint8(&o.MB27_D0.Reg)
}

// CAN0.MB27_D1: Mailbox Register
func (o *CAN0_Type) SetMB27_D1(value uint8) {
	volatile.StoreUint8(&o.MB27_D1.Reg, value)
}
func (o *CAN0_Type) GetMB27_D1() uint8 {
	return volatile.LoadUint8(&o.MB27_D1.Reg)
}

// CAN0.MB27_D2: Mailbox Register
func (o *CAN0_Type) SetMB27_D2(value uint8) {
	volatile.StoreUint8(&o.MB27_D2.Reg, value)
}
func (o *CAN0_Type) GetMB27_D2() uint8 {
	return volatile.LoadUint8(&o.MB27_D2.Reg)
}

// CAN0.MB27_D3: Mailbox Register
func (o *CAN0_Type) SetMB27_D3(value uint8) {
	volatile.StoreUint8(&o.MB27_D3.Reg, value)
}
func (o *CAN0_Type) GetMB27_D3() uint8 {
	return volatile.LoadUint8(&o.MB27_D3.Reg)
}

// CAN0.MB27_D4: Mailbox Register
func (o *CAN0_Type) SetMB27_D4(value uint8) {
	volatile.StoreUint8(&o.MB27_D4.Reg, value)
}
func (o *CAN0_Type) GetMB27_D4() uint8 {
	return volatile.LoadUint8(&o.MB27_D4.Reg)
}

// CAN0.MB27_D5: Mailbox Register
func (o *CAN0_Type) SetMB27_D5(value uint8) {
	volatile.StoreUint8(&o.MB27_D5.Reg, value)
}
func (o *CAN0_Type) GetMB27_D5() uint8 {
	return volatile.LoadUint8(&o.MB27_D5.Reg)
}

// CAN0.MB27_D6: Mailbox Register
func (o *CAN0_Type) SetMB27_D6(value uint8) {
	volatile.StoreUint8(&o.MB27_D6.Reg, value)
}
func (o *CAN0_Type) GetMB27_D6() uint8 {
	return volatile.LoadUint8(&o.MB27_D6.Reg)
}

// CAN0.MB27_D7: Mailbox Register
func (o *CAN0_Type) SetMB27_D7(value uint8) {
	volatile.StoreUint8(&o.MB27_D7.Reg, value)
}
func (o *CAN0_Type) GetMB27_D7() uint8 {
	return volatile.LoadUint8(&o.MB27_D7.Reg)
}

// CAN0.MB27_TS: Mailbox Register
func (o *CAN0_Type) SetMB27_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB27_TS.Reg, volatile.LoadUint16(&o.MB27_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB27_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB27_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB27_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB27_TS.Reg, volatile.LoadUint16(&o.MB27_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB27_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB27_TS.Reg) & 0xff
}

// CAN0.MB28_ID: Mailbox Register
func (o *CAN0_Type) SetMB28_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB28_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB28_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB28_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB28_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB28_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB28_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB28_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB28_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB28_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB28_ID.Reg) & 0x3ffff
}

// CAN0.MB28_DL: Mailbox Register
func (o *CAN0_Type) SetMB28_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB28_DL.Reg, volatile.LoadUint16(&o.MB28_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB28_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB28_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB28_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB28_DL.Reg, volatile.LoadUint16(&o.MB28_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB28_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB28_DL.Reg) & 0xf
}

// CAN0.MB28_D0: Mailbox Register
func (o *CAN0_Type) SetMB28_D0(value uint8) {
	volatile.StoreUint8(&o.MB28_D0.Reg, value)
}
func (o *CAN0_Type) GetMB28_D0() uint8 {
	return volatile.LoadUint8(&o.MB28_D0.Reg)
}

// CAN0.MB28_D1: Mailbox Register
func (o *CAN0_Type) SetMB28_D1(value uint8) {
	volatile.StoreUint8(&o.MB28_D1.Reg, value)
}
func (o *CAN0_Type) GetMB28_D1() uint8 {
	return volatile.LoadUint8(&o.MB28_D1.Reg)
}

// CAN0.MB28_D2: Mailbox Register
func (o *CAN0_Type) SetMB28_D2(value uint8) {
	volatile.StoreUint8(&o.MB28_D2.Reg, value)
}
func (o *CAN0_Type) GetMB28_D2() uint8 {
	return volatile.LoadUint8(&o.MB28_D2.Reg)
}

// CAN0.MB28_D3: Mailbox Register
func (o *CAN0_Type) SetMB28_D3(value uint8) {
	volatile.StoreUint8(&o.MB28_D3.Reg, value)
}
func (o *CAN0_Type) GetMB28_D3() uint8 {
	return volatile.LoadUint8(&o.MB28_D3.Reg)
}

// CAN0.MB28_D4: Mailbox Register
func (o *CAN0_Type) SetMB28_D4(value uint8) {
	volatile.StoreUint8(&o.MB28_D4.Reg, value)
}
func (o *CAN0_Type) GetMB28_D4() uint8 {
	return volatile.LoadUint8(&o.MB28_D4.Reg)
}

// CAN0.MB28_D5: Mailbox Register
func (o *CAN0_Type) SetMB28_D5(value uint8) {
	volatile.StoreUint8(&o.MB28_D5.Reg, value)
}
func (o *CAN0_Type) GetMB28_D5() uint8 {
	return volatile.LoadUint8(&o.MB28_D5.Reg)
}

// CAN0.MB28_D6: Mailbox Register
func (o *CAN0_Type) SetMB28_D6(value uint8) {
	volatile.StoreUint8(&o.MB28_D6.Reg, value)
}
func (o *CAN0_Type) GetMB28_D6() uint8 {
	return volatile.LoadUint8(&o.MB28_D6.Reg)
}

// CAN0.MB28_D7: Mailbox Register
func (o *CAN0_Type) SetMB28_D7(value uint8) {
	volatile.StoreUint8(&o.MB28_D7.Reg, value)
}
func (o *CAN0_Type) GetMB28_D7() uint8 {
	return volatile.LoadUint8(&o.MB28_D7.Reg)
}

// CAN0.MB28_TS: Mailbox Register
func (o *CAN0_Type) SetMB28_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB28_TS.Reg, volatile.LoadUint16(&o.MB28_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB28_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB28_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB28_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB28_TS.Reg, volatile.LoadUint16(&o.MB28_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB28_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB28_TS.Reg) & 0xff
}

// CAN0.MB29_ID: Mailbox Register
func (o *CAN0_Type) SetMB29_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB29_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB29_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB29_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB29_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB29_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB29_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB29_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB29_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB29_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB29_ID.Reg) & 0x3ffff
}

// CAN0.MB29_DL: Mailbox Register
func (o *CAN0_Type) SetMB29_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB29_DL.Reg, volatile.LoadUint16(&o.MB29_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB29_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB29_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB29_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB29_DL.Reg, volatile.LoadUint16(&o.MB29_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB29_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB29_DL.Reg) & 0xf
}

// CAN0.MB29_D0: Mailbox Register
func (o *CAN0_Type) SetMB29_D0(value uint8) {
	volatile.StoreUint8(&o.MB29_D0.Reg, value)
}
func (o *CAN0_Type) GetMB29_D0() uint8 {
	return volatile.LoadUint8(&o.MB29_D0.Reg)
}

// CAN0.MB29_D1: Mailbox Register
func (o *CAN0_Type) SetMB29_D1(value uint8) {
	volatile.StoreUint8(&o.MB29_D1.Reg, value)
}
func (o *CAN0_Type) GetMB29_D1() uint8 {
	return volatile.LoadUint8(&o.MB29_D1.Reg)
}

// CAN0.MB29_D2: Mailbox Register
func (o *CAN0_Type) SetMB29_D2(value uint8) {
	volatile.StoreUint8(&o.MB29_D2.Reg, value)
}
func (o *CAN0_Type) GetMB29_D2() uint8 {
	return volatile.LoadUint8(&o.MB29_D2.Reg)
}

// CAN0.MB29_D3: Mailbox Register
func (o *CAN0_Type) SetMB29_D3(value uint8) {
	volatile.StoreUint8(&o.MB29_D3.Reg, value)
}
func (o *CAN0_Type) GetMB29_D3() uint8 {
	return volatile.LoadUint8(&o.MB29_D3.Reg)
}

// CAN0.MB29_D4: Mailbox Register
func (o *CAN0_Type) SetMB29_D4(value uint8) {
	volatile.StoreUint8(&o.MB29_D4.Reg, value)
}
func (o *CAN0_Type) GetMB29_D4() uint8 {
	return volatile.LoadUint8(&o.MB29_D4.Reg)
}

// CAN0.MB29_D5: Mailbox Register
func (o *CAN0_Type) SetMB29_D5(value uint8) {
	volatile.StoreUint8(&o.MB29_D5.Reg, value)
}
func (o *CAN0_Type) GetMB29_D5() uint8 {
	return volatile.LoadUint8(&o.MB29_D5.Reg)
}

// CAN0.MB29_D6: Mailbox Register
func (o *CAN0_Type) SetMB29_D6(value uint8) {
	volatile.StoreUint8(&o.MB29_D6.Reg, value)
}
func (o *CAN0_Type) GetMB29_D6() uint8 {
	return volatile.LoadUint8(&o.MB29_D6.Reg)
}

// CAN0.MB29_D7: Mailbox Register
func (o *CAN0_Type) SetMB29_D7(value uint8) {
	volatile.StoreUint8(&o.MB29_D7.Reg, value)
}
func (o *CAN0_Type) GetMB29_D7() uint8 {
	return volatile.LoadUint8(&o.MB29_D7.Reg)
}

// CAN0.MB29_TS: Mailbox Register
func (o *CAN0_Type) SetMB29_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB29_TS.Reg, volatile.LoadUint16(&o.MB29_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB29_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB29_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB29_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB29_TS.Reg, volatile.LoadUint16(&o.MB29_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB29_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB29_TS.Reg) & 0xff
}

// CAN0.MB30_ID: Mailbox Register
func (o *CAN0_Type) SetMB30_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB30_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB30_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB30_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB30_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB30_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB30_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB30_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB30_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB30_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB30_ID.Reg) & 0x3ffff
}

// CAN0.MB30_DL: Mailbox Register
func (o *CAN0_Type) SetMB30_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB30_DL.Reg, volatile.LoadUint16(&o.MB30_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB30_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB30_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB30_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB30_DL.Reg, volatile.LoadUint16(&o.MB30_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB30_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB30_DL.Reg) & 0xf
}

// CAN0.MB30_D0: Mailbox Register
func (o *CAN0_Type) SetMB30_D0(value uint8) {
	volatile.StoreUint8(&o.MB30_D0.Reg, value)
}
func (o *CAN0_Type) GetMB30_D0() uint8 {
	return volatile.LoadUint8(&o.MB30_D0.Reg)
}

// CAN0.MB30_D1: Mailbox Register
func (o *CAN0_Type) SetMB30_D1(value uint8) {
	volatile.StoreUint8(&o.MB30_D1.Reg, value)
}
func (o *CAN0_Type) GetMB30_D1() uint8 {
	return volatile.LoadUint8(&o.MB30_D1.Reg)
}

// CAN0.MB30_D2: Mailbox Register
func (o *CAN0_Type) SetMB30_D2(value uint8) {
	volatile.StoreUint8(&o.MB30_D2.Reg, value)
}
func (o *CAN0_Type) GetMB30_D2() uint8 {
	return volatile.LoadUint8(&o.MB30_D2.Reg)
}

// CAN0.MB30_D3: Mailbox Register
func (o *CAN0_Type) SetMB30_D3(value uint8) {
	volatile.StoreUint8(&o.MB30_D3.Reg, value)
}
func (o *CAN0_Type) GetMB30_D3() uint8 {
	return volatile.LoadUint8(&o.MB30_D3.Reg)
}

// CAN0.MB30_D4: Mailbox Register
func (o *CAN0_Type) SetMB30_D4(value uint8) {
	volatile.StoreUint8(&o.MB30_D4.Reg, value)
}
func (o *CAN0_Type) GetMB30_D4() uint8 {
	return volatile.LoadUint8(&o.MB30_D4.Reg)
}

// CAN0.MB30_D5: Mailbox Register
func (o *CAN0_Type) SetMB30_D5(value uint8) {
	volatile.StoreUint8(&o.MB30_D5.Reg, value)
}
func (o *CAN0_Type) GetMB30_D5() uint8 {
	return volatile.LoadUint8(&o.MB30_D5.Reg)
}

// CAN0.MB30_D6: Mailbox Register
func (o *CAN0_Type) SetMB30_D6(value uint8) {
	volatile.StoreUint8(&o.MB30_D6.Reg, value)
}
func (o *CAN0_Type) GetMB30_D6() uint8 {
	return volatile.LoadUint8(&o.MB30_D6.Reg)
}

// CAN0.MB30_D7: Mailbox Register
func (o *CAN0_Type) SetMB30_D7(value uint8) {
	volatile.StoreUint8(&o.MB30_D7.Reg, value)
}
func (o *CAN0_Type) GetMB30_D7() uint8 {
	return volatile.LoadUint8(&o.MB30_D7.Reg)
}

// CAN0.MB30_TS: Mailbox Register
func (o *CAN0_Type) SetMB30_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB30_TS.Reg, volatile.LoadUint16(&o.MB30_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB30_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB30_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB30_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB30_TS.Reg, volatile.LoadUint16(&o.MB30_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB30_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB30_TS.Reg) & 0xff
}

// CAN0.MB31_ID: Mailbox Register
func (o *CAN0_Type) SetMB31_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB31_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB31_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB31_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB31_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB31_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB31_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB31_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB31_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB31_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB31_ID.Reg) & 0x3ffff
}

// CAN0.MB31_DL: Mailbox Register
func (o *CAN0_Type) SetMB31_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB31_DL.Reg, volatile.LoadUint16(&o.MB31_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB31_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB31_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB31_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB31_DL.Reg, volatile.LoadUint16(&o.MB31_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB31_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB31_DL.Reg) & 0xf
}

// CAN0.MB31_D0: Mailbox Register
func (o *CAN0_Type) SetMB31_D0(value uint8) {
	volatile.StoreUint8(&o.MB31_D0.Reg, value)
}
func (o *CAN0_Type) GetMB31_D0() uint8 {
	return volatile.LoadUint8(&o.MB31_D0.Reg)
}

// CAN0.MB31_D1: Mailbox Register
func (o *CAN0_Type) SetMB31_D1(value uint8) {
	volatile.StoreUint8(&o.MB31_D1.Reg, value)
}
func (o *CAN0_Type) GetMB31_D1() uint8 {
	return volatile.LoadUint8(&o.MB31_D1.Reg)
}

// CAN0.MB31_D2: Mailbox Register
func (o *CAN0_Type) SetMB31_D2(value uint8) {
	volatile.StoreUint8(&o.MB31_D2.Reg, value)
}
func (o *CAN0_Type) GetMB31_D2() uint8 {
	return volatile.LoadUint8(&o.MB31_D2.Reg)
}

// CAN0.MB31_D3: Mailbox Register
func (o *CAN0_Type) SetMB31_D3(value uint8) {
	volatile.StoreUint8(&o.MB31_D3.Reg, value)
}
func (o *CAN0_Type) GetMB31_D3() uint8 {
	return volatile.LoadUint8(&o.MB31_D3.Reg)
}

// CAN0.MB31_D4: Mailbox Register
func (o *CAN0_Type) SetMB31_D4(value uint8) {
	volatile.StoreUint8(&o.MB31_D4.Reg, value)
}
func (o *CAN0_Type) GetMB31_D4() uint8 {
	return volatile.LoadUint8(&o.MB31_D4.Reg)
}

// CAN0.MB31_D5: Mailbox Register
func (o *CAN0_Type) SetMB31_D5(value uint8) {
	volatile.StoreUint8(&o.MB31_D5.Reg, value)
}
func (o *CAN0_Type) GetMB31_D5() uint8 {
	return volatile.LoadUint8(&o.MB31_D5.Reg)
}

// CAN0.MB31_D6: Mailbox Register
func (o *CAN0_Type) SetMB31_D6(value uint8) {
	volatile.StoreUint8(&o.MB31_D6.Reg, value)
}
func (o *CAN0_Type) GetMB31_D6() uint8 {
	return volatile.LoadUint8(&o.MB31_D6.Reg)
}

// CAN0.MB31_D7: Mailbox Register
func (o *CAN0_Type) SetMB31_D7(value uint8) {
	volatile.StoreUint8(&o.MB31_D7.Reg, value)
}
func (o *CAN0_Type) GetMB31_D7() uint8 {
	return volatile.LoadUint8(&o.MB31_D7.Reg)
}

// CAN0.MB31_TS: Mailbox Register
func (o *CAN0_Type) SetMB31_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB31_TS.Reg, volatile.LoadUint16(&o.MB31_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB31_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB31_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB31_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB31_TS.Reg, volatile.LoadUint16(&o.MB31_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB31_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB31_TS.Reg) & 0xff
}

// CAN0.MKR: Mask Register
func (o *CAN0_Type) SetMKR_Reserved(idx int, value uint32) {
	volatile.StoreUint32(&o.MKR[idx].Reg, volatile.LoadUint32(&o.MKR[idx].Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetMKR_Reserved(idx int) uint32 {
	return (volatile.LoadUint32(&o.MKR[idx].Reg) & 0xe0000000) >> 29
}
func (o *CAN0_Type) SetMKR_SID(idx int, value uint32) {
	volatile.StoreUint32(&o.MKR[idx].Reg, volatile.LoadUint32(&o.MKR[idx].Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMKR_SID(idx int) uint32 {
	return (volatile.LoadUint32(&o.MKR[idx].Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMKR_EID(idx int, value uint32) {
	volatile.StoreUint32(&o.MKR[idx].Reg, volatile.LoadUint32(&o.MKR[idx].Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMKR_EID(idx int) uint32 {
	return volatile.LoadUint32(&o.MKR[idx].Reg) & 0x3ffff
}

// CAN0.FIDCR0: FIFO Received ID Compare Registers
func (o *CAN0_Type) SetFIDCR0_IDE(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetFIDCR0_IDE() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetFIDCR0_RTR(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetFIDCR0_RTR() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetFIDCR0_Reserved(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetFIDCR0_Reserved() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetFIDCR0_SID(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetFIDCR0_SID() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetFIDCR0_EID(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetFIDCR0_EID() uint32 {
	return volatile.LoadUint32(&o.FIDCR0.Reg) & 0x3ffff
}

// CAN0.FIDCR1: FIFO Received ID Compare Registers
func (o *CAN0_Type) SetFIDCR1_IDE(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetFIDCR1_IDE() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetFIDCR1_RTR(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetFIDCR1_RTR() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetFIDCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetFIDCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetFIDCR1_SID(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetFIDCR1_SID() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetFIDCR1_EID(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetFIDCR1_EID() uint32 {
	return volatile.LoadUint32(&o.FIDCR1.Reg) & 0x3ffff
}

// CAN0.MKIVLR: Mask Invalid Register
func (o *CAN0_Type) SetMKIVLR_MB31(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMKIVLR_MB31() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMKIVLR_MB30(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMKIVLR_MB30() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMKIVLR_MB29(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMKIVLR_MB29() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMKIVLR_MB28(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetMKIVLR_MB28() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetMKIVLR_MB27(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetMKIVLR_MB27() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetMKIVLR_MB26(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetMKIVLR_MB26() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetMKIVLR_MB25(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetMKIVLR_MB25() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetMKIVLR_MB24(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetMKIVLR_MB24() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetMKIVLR_MB23(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetMKIVLR_MB23() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetMKIVLR_MB22(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetMKIVLR_MB22() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetMKIVLR_MB21(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetMKIVLR_MB21() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetMKIVLR_MB20(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetMKIVLR_MB20() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetMKIVLR_MB19(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetMKIVLR_MB19() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetMKIVLR_MB18(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetMKIVLR_MB18() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetMKIVLR_MB17(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetMKIVLR_MB17() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetMKIVLR_MB16(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetMKIVLR_MB16() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetMKIVLR_MB15(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetMKIVLR_MB15() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetMKIVLR_MB14(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetMKIVLR_MB14() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetMKIVLR_MB13(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetMKIVLR_MB13() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetMKIVLR_MB12(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetMKIVLR_MB12() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetMKIVLR_MB11(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetMKIVLR_MB11() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetMKIVLR_MB10(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetMKIVLR_MB10() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetMKIVLR_MB9(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetMKIVLR_MB9() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetMKIVLR_MB8(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetMKIVLR_MB8() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetMKIVLR_MB7(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMKIVLR_MB7() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMKIVLR_MB6(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMKIVLR_MB6() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMKIVLR_MB5(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetMKIVLR_MB5() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetMKIVLR_MB4(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMKIVLR_MB4() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMKIVLR_MB3(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetMKIVLR_MB3() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetMKIVLR_MB2(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMKIVLR_MB2() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMKIVLR_MB1(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMKIVLR_MB1() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMKIVLR_MB0(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMKIVLR_MB0() uint32 {
	return volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1
}

// CAN0.MIER: Mailbox Interrupt Enable Register
func (o *CAN0_Type) SetMIER_MB31(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMIER_MB31() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMIER_MB30(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMIER_MB30() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMIER_MB29(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMIER_MB29() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMIER_MB28(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetMIER_MB28() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetMIER_MB27(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetMIER_MB27() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetMIER_MB26(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetMIER_MB26() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetMIER_MB25(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetMIER_MB25() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetMIER_MB24(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetMIER_MB24() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetMIER_MB23(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetMIER_MB23() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetMIER_MB22(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetMIER_MB22() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetMIER_MB21(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetMIER_MB21() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetMIER_MB20(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetMIER_MB20() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetMIER_MB19(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetMIER_MB19() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetMIER_MB18(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetMIER_MB18() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetMIER_MB17(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetMIER_MB17() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetMIER_MB16(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetMIER_MB16() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetMIER_MB15(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetMIER_MB15() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetMIER_MB14(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetMIER_MB14() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetMIER_MB13(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetMIER_MB13() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetMIER_MB12(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetMIER_MB12() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetMIER_MB11(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetMIER_MB11() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetMIER_MB10(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetMIER_MB10() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetMIER_MB9(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetMIER_MB9() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetMIER_MB8(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetMIER_MB8() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetMIER_MB7(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMIER_MB7() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMIER_MB6(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMIER_MB6() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMIER_MB5(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetMIER_MB5() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetMIER_MB4(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMIER_MB4() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMIER_MB3(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetMIER_MB3() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetMIER_MB2(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMIER_MB2() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMIER_MB1(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMIER_MB1() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMIER_MB0(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMIER_MB0() uint32 {
	return volatile.LoadUint32(&o.MIER.Reg) & 0x1
}

// CAN0.MCTL_TX: Message Control Register for Transmit
func (o *CAN0_Type) SetMCTL_TX_TRMREQ(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMCTL_TX_TRMREQ(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMCTL_TX_RECREQ(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMCTL_TX_RECREQ(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMCTL_TX_Reserved(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetMCTL_TX_Reserved(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetMCTL_TX_ONESHOT(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMCTL_TX_ONESHOT(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMCTL_TX_Reserved(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetMCTL_TX_Reserved(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetMCTL_TX_TRMABT(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMCTL_TX_TRMABT(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMCTL_TX_TRMACTIVE(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMCTL_TX_TRMACTIVE(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMCTL_TX_SENTDATA(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMCTL_TX_SENTDATA(idx int) uint8 {
	return volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x1
}

// CAN0.CTLR: Control Register
func (o *CAN0_Type) SetCTLR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0xc000)|value<<14)
}
func (o *CAN0_Type) GetCTLR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0xc000) >> 14
}
func (o *CAN0_Type) SetCTLR_RBOC(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetCTLR_RBOC() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetCTLR_BOM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x1800)|value<<11)
}
func (o *CAN0_Type) GetCTLR_BOM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x1800) >> 11
}
func (o *CAN0_Type) SetCTLR_SLPM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetCTLR_SLPM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetCTLR_CANM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x300)|value<<8)
}
func (o *CAN0_Type) GetCTLR_CANM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x300) >> 8
}
func (o *CAN0_Type) SetCTLR_TSPS(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0xc0)|value<<6)
}
func (o *CAN0_Type) GetCTLR_TSPS() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0xc0) >> 6
}
func (o *CAN0_Type) SetCTLR_TSRC(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetCTLR_TSRC() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetCTLR_TPM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetCTLR_TPM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetCTLR_MLM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetCTLR_MLM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetCTLR_IDFM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x6)|value<<1)
}
func (o *CAN0_Type) GetCTLR_IDFM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x6) >> 1
}
func (o *CAN0_Type) SetCTLR_MBM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetCTLR_MBM() uint16 {
	return volatile.LoadUint16(&o.CTLR.Reg) & 0x1
}

// CAN0.STR: Status Register
func (o *CAN0_Type) SetSTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetSTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetSTR_RECST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetSTR_RECST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetSTR_TRMST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetSTR_TRMST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetSTR_BOST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetSTR_BOST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetSTR_EPST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetSTR_EPST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetSTR_SLPST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetSTR_SLPST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetSTR_HLTST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetSTR_HLTST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetSTR_RSTST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetSTR_RSTST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetSTR_EST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetSTR_EST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetSTR_TABST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetSTR_TABST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetSTR_FMLST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetSTR_FMLST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetSTR_NMLST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetSTR_NMLST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetSTR_TFST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetSTR_TFST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetSTR_RFST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetSTR_RFST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetSTR_SDST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetSTR_SDST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetSTR_NDST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetSTR_NDST() uint16 {
	return volatile.LoadUint16(&o.STR.Reg) & 0x1
}

// CAN0.BCR: Bit Configuration Register
func (o *CAN0_Type) SetBCR_TSEG1(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAN0_Type) GetBCR_TSEG1() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0xf0000000) >> 28
}
func (o *CAN0_Type) SetBCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0xc000000)|value<<26)
}
func (o *CAN0_Type) GetBCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0xc000000) >> 26
}
func (o *CAN0_Type) SetBCR_BRP(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *CAN0_Type) GetBCR_BRP() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x3ff0000) >> 16
}
func (o *CAN0_Type) SetBCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0xc000)|value<<14)
}
func (o *CAN0_Type) GetBCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0xc000) >> 14
}
func (o *CAN0_Type) SetBCR_SJW(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x3000)|value<<12)
}
func (o *CAN0_Type) GetBCR_SJW() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x3000) >> 12
}
func (o *CAN0_Type) SetBCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetBCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetBCR_TSEG2(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x700)|value<<8)
}
func (o *CAN0_Type) GetBCR_TSEG2() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x700) >> 8
}
func (o *CAN0_Type) SetBCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0xfe)|value<<1)
}
func (o *CAN0_Type) GetBCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0xfe) >> 1
}
func (o *CAN0_Type) SetBCR_CCLKS(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetBCR_CCLKS() uint32 {
	return volatile.LoadUint32(&o.BCR.Reg) & 0x1
}

// CAN0.RFCR: Receive FIFO Control Register
func (o *CAN0_Type) SetRFCR_RFEST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRFCR_RFEST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRFCR_RFWST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRFCR_RFWST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRFCR_RFFST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRFCR_RFFST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRFCR_RFMLF(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRFCR_RFMLF() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRFCR_RFUST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0xe)|value<<1)
}
func (o *CAN0_Type) GetRFCR_RFUST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0xe) >> 1
}
func (o *CAN0_Type) SetRFCR_RFE(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRFCR_RFE() uint8 {
	return volatile.LoadUint8(&o.RFCR.Reg) & 0x1
}

// CAN0.RFPCR: Receive FIFO Pointer Control Register
func (o *CAN0_Type) SetRFPCR(value uint8) {
	volatile.StoreUint8(&o.RFPCR.Reg, value)
}
func (o *CAN0_Type) GetRFPCR() uint8 {
	return volatile.LoadUint8(&o.RFPCR.Reg)
}

// CAN0.TFCR: Transmit FIFO Control Register
func (o *CAN0_Type) SetTFCR_TFEST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetTFCR_TFEST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetTFCR_TFFST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetTFCR_TFFST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetTFCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x30)|value<<4)
}
func (o *CAN0_Type) GetTFCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0x30) >> 4
}
func (o *CAN0_Type) SetTFCR_TFUST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0xe)|value<<1)
}
func (o *CAN0_Type) GetTFCR_TFUST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0xe) >> 1
}
func (o *CAN0_Type) SetTFCR_TFE(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetTFCR_TFE() uint8 {
	return volatile.LoadUint8(&o.TFCR.Reg) & 0x1
}

// CAN0.TFPCR: Transmit FIFO Pointer Control Register
func (o *CAN0_Type) SetTFPCR(value uint8) {
	volatile.StoreUint8(&o.TFPCR.Reg, value)
}
func (o *CAN0_Type) GetTFPCR() uint8 {
	return volatile.LoadUint8(&o.TFPCR.Reg)
}

// CAN0.EIER: Error Interrupt Enable Register
func (o *CAN0_Type) SetEIER_BLIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetEIER_BLIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetEIER_OLIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetEIER_OLIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetEIER_ORIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetEIER_ORIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetEIER_BORIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetEIER_BORIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetEIER_BOEIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetEIER_BOEIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetEIER_EPIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetEIER_EPIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetEIER_EWIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetEIER_EWIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetEIER_BEIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetEIER_BEIE() uint8 {
	return volatile.LoadUint8(&o.EIER.Reg) & 0x1
}

// CAN0.EIFR: Error Interrupt Factor Judge Register
func (o *CAN0_Type) SetEIFR_BLIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetEIFR_BLIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetEIFR_OLIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetEIFR_OLIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetEIFR_ORIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetEIFR_ORIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetEIFR_BORIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetEIFR_BORIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetEIFR_BOEIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetEIFR_BOEIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetEIFR_EPIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetEIFR_EPIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetEIFR_EWIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetEIFR_EWIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetEIFR_BEIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetEIFR_BEIF() uint8 {
	return volatile.LoadUint8(&o.EIFR.Reg) & 0x1
}

// CAN0.RECR: Receive Error Count Register
func (o *CAN0_Type) SetRECR(value uint8) {
	volatile.StoreUint8(&o.RECR.Reg, value)
}
func (o *CAN0_Type) GetRECR() uint8 {
	return volatile.LoadUint8(&o.RECR.Reg)
}

// CAN0.TECR: Transmit Error Count Register
func (o *CAN0_Type) SetTECR(value uint8) {
	volatile.StoreUint8(&o.TECR.Reg, value)
}
func (o *CAN0_Type) GetTECR() uint8 {
	return volatile.LoadUint8(&o.TECR.Reg)
}

// CAN0.ECSR: Error Code Store Register
func (o *CAN0_Type) SetECSR_EDPM(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetECSR_EDPM() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetECSR_ADEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetECSR_ADEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetECSR_BE0F(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetECSR_BE0F() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetECSR_BE1F(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetECSR_BE1F() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetECSR_CEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetECSR_CEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetECSR_AEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetECSR_AEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetECSR_FEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetECSR_FEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetECSR_SEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetECSR_SEF() uint8 {
	return volatile.LoadUint8(&o.ECSR.Reg) & 0x1
}

// CAN0.CSSR: Channel Search Support Register
func (o *CAN0_Type) SetCSSR(value uint8) {
	volatile.StoreUint8(&o.CSSR.Reg, value)
}
func (o *CAN0_Type) GetCSSR() uint8 {
	return volatile.LoadUint8(&o.CSSR.Reg)
}

// CAN0.MSSR: Mailbox Search Status Register
func (o *CAN0_Type) SetMSSR_SEST(value uint8) {
	volatile.StoreUint8(&o.MSSR.Reg, volatile.LoadUint8(&o.MSSR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMSSR_SEST() uint8 {
	return (volatile.LoadUint8(&o.MSSR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMSSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MSSR.Reg, volatile.LoadUint8(&o.MSSR.Reg)&^(0x60)|value<<5)
}
func (o *CAN0_Type) GetMSSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MSSR.Reg) & 0x60) >> 5
}
func (o *CAN0_Type) SetMSSR_MBNST(value uint8) {
	volatile.StoreUint8(&o.MSSR.Reg, volatile.LoadUint8(&o.MSSR.Reg)&^(0x1f)|value)
}
func (o *CAN0_Type) GetMSSR_MBNST() uint8 {
	return volatile.LoadUint8(&o.MSSR.Reg) & 0x1f
}

// CAN0.MSMR: Mailbox Search Mode Register
func (o *CAN0_Type) SetMSMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MSMR.Reg, volatile.LoadUint8(&o.MSMR.Reg)&^(0xfc)|value<<2)
}
func (o *CAN0_Type) GetMSMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MSMR.Reg) & 0xfc) >> 2
}
func (o *CAN0_Type) SetMSMR_MBSM(value uint8) {
	volatile.StoreUint8(&o.MSMR.Reg, volatile.LoadUint8(&o.MSMR.Reg)&^(0x3)|value)
}
func (o *CAN0_Type) GetMSMR_MBSM() uint8 {
	return volatile.LoadUint8(&o.MSMR.Reg) & 0x3
}

// CAN0.TSR: Time Stamp Register
func (o *CAN0_Type) SetTSR(value uint16) {
	volatile.StoreUint16(&o.TSR.Reg, value)
}
func (o *CAN0_Type) GetTSR() uint16 {
	return volatile.LoadUint16(&o.TSR.Reg)
}

// CAN0.AFSR: Acceptance Filter Support Register
func (o *CAN0_Type) SetAFSR(value uint16) {
	volatile.StoreUint16(&o.AFSR.Reg, value)
}
func (o *CAN0_Type) GetAFSR() uint16 {
	return volatile.LoadUint16(&o.AFSR.Reg)
}

// CAN0.TCR: Test Control Register
func (o *CAN0_Type) SetTCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0xf8)|value<<3)
}
func (o *CAN0_Type) GetTCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.TCR.Reg) & 0xf8) >> 3
}
func (o *CAN0_Type) SetTCR_TSTM(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0x6)|value<<1)
}
func (o *CAN0_Type) GetTCR_TSTM() uint8 {
	return (volatile.LoadUint8(&o.TCR.Reg) & 0x6) >> 1
}
func (o *CAN0_Type) SetTCR_TSTE(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetTCR_TSTE() uint8 {
	return volatile.LoadUint8(&o.TCR.Reg) & 0x1
}

// Watchdog Timer
type WDT_Type struct {
	WDTRR    volatile.Register8 // 0x0
	_        byte
	WDTCR    volatile.Register16 // 0x2
	WDTSR    volatile.Register16 // 0x4
	WDTRCR   volatile.Register8  // 0x6
	_        byte
	WDTCSTPR volatile.Register8 // 0x8
}

// WDT.WDTRR: WDT Refresh Register
func (o *WDT_Type) SetWDTRR(value uint8) {
	volatile.StoreUint8(&o.WDTRR.Reg, value)
}
func (o *WDT_Type) GetWDTRR() uint8 {
	return volatile.LoadUint8(&o.WDTRR.Reg)
}

// WDT.WDTCR: WDT Control Register
func (o *WDT_Type) SetWDTCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0xc000)|value<<14)
}
func (o *WDT_Type) GetWDTCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0xc000) >> 14
}
func (o *WDT_Type) SetWDTCR_RPSS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x3000)|value<<12)
}
func (o *WDT_Type) GetWDTCR_RPSS() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0x3000) >> 12
}
func (o *WDT_Type) SetWDTCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0xc00)|value<<10)
}
func (o *WDT_Type) GetWDTCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0xc00) >> 10
}
func (o *WDT_Type) SetWDTCR_RPES(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x300)|value<<8)
}
func (o *WDT_Type) GetWDTCR_RPES() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0x300) >> 8
}
func (o *WDT_Type) SetWDTCR_CKS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0xf0)|value<<4)
}
func (o *WDT_Type) GetWDTCR_CKS() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0xf0) >> 4
}
func (o *WDT_Type) SetWDTCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0xc)|value<<2)
}
func (o *WDT_Type) GetWDTCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0xc) >> 2
}
func (o *WDT_Type) SetWDTCR_TOPS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x3)|value)
}
func (o *WDT_Type) GetWDTCR_TOPS() uint16 {
	return volatile.LoadUint16(&o.WDTCR.Reg) & 0x3
}

// WDT.WDTSR: WDT Status Register
func (o *WDT_Type) SetWDTSR_REFEF(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x8000)|value<<15)
}
func (o *WDT_Type) GetWDTSR_REFEF() uint16 {
	return (volatile.LoadUint16(&o.WDTSR.Reg) & 0x8000) >> 15
}
func (o *WDT_Type) SetWDTSR_UNDFF(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x4000)|value<<14)
}
func (o *WDT_Type) GetWDTSR_UNDFF() uint16 {
	return (volatile.LoadUint16(&o.WDTSR.Reg) & 0x4000) >> 14
}
func (o *WDT_Type) SetWDTSR_CNTVAL(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x3fff)|value)
}
func (o *WDT_Type) GetWDTSR_CNTVAL() uint16 {
	return volatile.LoadUint16(&o.WDTSR.Reg) & 0x3fff
}

// WDT.WDTRCR: WDT Reset Control Register
func (o *WDT_Type) SetWDTRCR_RSTIRQS(value uint8) {
	volatile.StoreUint8(&o.WDTRCR.Reg, volatile.LoadUint8(&o.WDTRCR.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetWDTRCR_RSTIRQS() uint8 {
	return (volatile.LoadUint8(&o.WDTRCR.Reg) & 0x80) >> 7
}

// WDT.WDTCSTPR: WDT Count Stop Control Register
func (o *WDT_Type) SetWDTCSTPR_SLCSTP(value uint8) {
	volatile.StoreUint8(&o.WDTCSTPR.Reg, volatile.LoadUint8(&o.WDTCSTPR.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetWDTCSTPR_SLCSTP() uint8 {
	return (volatile.LoadUint8(&o.WDTCSTPR.Reg) & 0x80) >> 7
}
func (o *WDT_Type) SetWDTCSTPR_Reserved(value uint8) {
	volatile.StoreUint8(&o.WDTCSTPR.Reg, volatile.LoadUint8(&o.WDTCSTPR.Reg)&^(0x7f)|value)
}
func (o *WDT_Type) GetWDTCSTPR_Reserved() uint8 {
	return volatile.LoadUint8(&o.WDTCSTPR.Reg) & 0x7f
}

// USB 2.0 FS Module
type USBFS_Type struct {
	SYSCFG     volatile.Register16 // 0x0
	_          [2]byte
	SYSSTS0    volatile.Register16 // 0x4
	_          [2]byte
	DVSTCTR0   volatile.Register16 // 0x8
	_          [10]byte
	CFIFO      volatile.Register16 // 0x14
	_          [2]byte
	D0FIFO     volatile.Register16 // 0x18
	_          [2]byte
	D1FIFO     volatile.Register16 // 0x1C
	_          [2]byte
	CFIFOSEL   volatile.Register16 // 0x20
	CFIFOCTR   volatile.Register16 // 0x22
	_          [4]byte
	D0FIFOSEL  volatile.Register16 // 0x28
	D0FIFOCTR  volatile.Register16 // 0x2A
	D1FIFOSEL  volatile.Register16 // 0x2C
	D1FIFOCTR  volatile.Register16 // 0x2E
	INTENB0    volatile.Register16 // 0x30
	INTENB1    volatile.Register16 // 0x32
	_          [2]byte
	BRDYENB    volatile.Register16 // 0x36
	NRDYENB    volatile.Register16 // 0x38
	BEMPENB    volatile.Register16 // 0x3A
	SOFCFG     volatile.Register16 // 0x3C
	_          [2]byte
	INTSTS0    volatile.Register16 // 0x40
	INTSTS1    volatile.Register16 // 0x42
	_          [2]byte
	BRDYSTS    volatile.Register16 // 0x46
	NRDYSTS    volatile.Register16 // 0x48
	BEMPSTS    volatile.Register16 // 0x4A
	FRMNUM     volatile.Register16 // 0x4C
	_          [6]byte
	USBREQ     volatile.Register16 // 0x54
	USBVAL     volatile.Register16 // 0x56
	USBINDX    volatile.Register16 // 0x58
	USBLENG    volatile.Register16 // 0x5A
	DCPCFG     volatile.Register16 // 0x5C
	DCPMAXP    volatile.Register16 // 0x5E
	DCPCTR     volatile.Register16 // 0x60
	_          [2]byte
	PIPESEL    volatile.Register16 // 0x64
	_          [2]byte
	PIPECFG    volatile.Register16 // 0x68
	_          [2]byte
	PIPEMAXP   volatile.Register16 // 0x6C
	PIPEPERI   volatile.Register16 // 0x6E
	PIPE1CTR   volatile.Register16 // 0x70
	PIPE2CTR   volatile.Register16 // 0x72
	PIPE3CTR   volatile.Register16 // 0x74
	PIPE4CTR   volatile.Register16 // 0x76
	PIPE5CTR   volatile.Register16 // 0x78
	PIPE6CTR   volatile.Register16 // 0x7A
	PIPE7CTR   volatile.Register16 // 0x7C
	PIPE8CTR   volatile.Register16 // 0x7E
	PIPE9CTR   volatile.Register16 // 0x80
	_          [14]byte
	PIPE1TRE   volatile.Register16 // 0x90
	PIPE1TRN   volatile.Register16 // 0x92
	PIPE2TRE   volatile.Register16 // 0x94
	PIPE2TRN   volatile.Register16 // 0x96
	PIPE3TRE   volatile.Register16 // 0x98
	PIPE3TRN   volatile.Register16 // 0x9A
	PIPE4TRE   volatile.Register16 // 0x9C
	PIPE4TRN   volatile.Register16 // 0x9E
	PIPE5TRE   volatile.Register16 // 0xA0
	PIPE5TRN   volatile.Register16 // 0xA2
	_          [12]byte
	USBBCCTRL0 volatile.Register16 // 0xB0
	_          [26]byte
	USBMC      volatile.Register16 // 0xCC
	_          [2]byte
	DEVADD0    volatile.Register16 // 0xD0
	DEVADD1    volatile.Register16 // 0xD2
	DEVADD2    volatile.Register16 // 0xD4
	DEVADD3    volatile.Register16 // 0xD6
	DEVADD4    volatile.Register16 // 0xD8
	DEVADD5    volatile.Register16 // 0xDA
}

// USBFS.SYSCFG: System Configuration Control Register
func (o *USBFS_Type) SetSYSCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0xf800)|value<<11)
}
func (o *USBFS_Type) GetSYSCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0xf800) >> 11
}
func (o *USBFS_Type) SetSYSCFG_SCKE(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetSYSCFG_SCKE() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetSYSCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetSYSCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetSYSCFG_CNEN(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetSYSCFG_CNEN() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetSYSCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetSYSCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetSYSCFG_DCFM(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetSYSCFG_DCFM() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetSYSCFG_DRPD(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetSYSCFG_DRPD() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetSYSCFG_DPRPU(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetSYSCFG_DPRPU() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetSYSCFG_DMRPU(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetSYSCFG_DMRPU() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetSYSCFG_USBE(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetSYSCFG_USBE() uint16 {
	return volatile.LoadUint16(&o.SYSCFG.Reg) & 0x1
}

// USBFS.SYSSTS0: System Configuration Status Register 0
func (o *USBFS_Type) SetSYSSTS0_OVCMON(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0xc000)|value<<14)
}
func (o *USBFS_Type) GetSYSSTS0_OVCMON() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0xc000) >> 14
}
func (o *USBFS_Type) SetSYSSTS0_Reserved(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x3f80)|value<<7)
}
func (o *USBFS_Type) GetSYSSTS0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x3f80) >> 7
}
func (o *USBFS_Type) SetSYSSTS0_HTACT(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetSYSSTS0_HTACT() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetSYSSTS0_Reserved(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x38)|value<<3)
}
func (o *USBFS_Type) GetSYSSTS0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x38) >> 3
}
func (o *USBFS_Type) SetSYSSTS0_IDMON(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetSYSSTS0_IDMON() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetSYSSTS0_LNST(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetSYSSTS0_LNST() uint16 {
	return volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x3
}

// USBFS.DVSTCTR0: Device State Control Register 0
func (o *USBFS_Type) SetDVSTCTR0_Reserved(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0xf000)|value<<12)
}
func (o *USBFS_Type) GetDVSTCTR0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0xf000) >> 12
}
func (o *USBFS_Type) SetDVSTCTR0_HNPBTOA(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetDVSTCTR0_HNPBTOA() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetDVSTCTR0_EXICEN(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetDVSTCTR0_EXICEN() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetDVSTCTR0_VBUSEN(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetDVSTCTR0_VBUSEN() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetDVSTCTR0_WKUP(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetDVSTCTR0_WKUP() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetDVSTCTR0_RWUPE(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetDVSTCTR0_RWUPE() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetDVSTCTR0_USBRST(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetDVSTCTR0_USBRST() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetDVSTCTR0_RESUME(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetDVSTCTR0_RESUME() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetDVSTCTR0_UACT(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetDVSTCTR0_UACT() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetDVSTCTR0_Reserved(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetDVSTCTR0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetDVSTCTR0_RHST(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x7)|value)
}
func (o *USBFS_Type) GetDVSTCTR0_RHST() uint16 {
	return volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x7
}

// USBFS.CFIFO: CFIFO Port Register
func (o *USBFS_Type) SetCFIFO(value uint16) {
	volatile.StoreUint16(&o.CFIFO.Reg, value)
}
func (o *USBFS_Type) GetCFIFO() uint16 {
	return volatile.LoadUint16(&o.CFIFO.Reg)
}

// USBFS.D0FIFO: D0FIFO Port Register
func (o *USBFS_Type) SetD0FIFO(value uint16) {
	volatile.StoreUint16(&o.D0FIFO.Reg, value)
}
func (o *USBFS_Type) GetD0FIFO() uint16 {
	return volatile.LoadUint16(&o.D0FIFO.Reg)
}

// USBFS.D1FIFO: D1FIFO Port Register
func (o *USBFS_Type) SetD1FIFO(value uint16) {
	volatile.StoreUint16(&o.D1FIFO.Reg, value)
}
func (o *USBFS_Type) GetD1FIFO() uint16 {
	return volatile.LoadUint16(&o.D1FIFO.Reg)
}

// USBFS.CFIFOSEL: CFIFO Port Select Register
func (o *USBFS_Type) SetCFIFOSEL_RCNT(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetCFIFOSEL_RCNT() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetCFIFOSEL_REW(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetCFIFOSEL_REW() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetCFIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x3800)|value<<11)
}
func (o *USBFS_Type) GetCFIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x3800) >> 11
}
func (o *USBFS_Type) SetCFIFOSEL_MBW(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetCFIFOSEL_MBW() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetCFIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetCFIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetCFIFOSEL_BIGEND(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetCFIFOSEL_BIGEND() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetCFIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetCFIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0xc0) >> 6
}
func (o *USBFS_Type) SetCFIFOSEL_ISEL(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetCFIFOSEL_ISEL() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetCFIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetCFIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetCFIFOSEL_CURPIPE(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetCFIFOSEL_CURPIPE() uint16 {
	return volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0xf
}

// USBFS.CFIFOCTR: CFIFO Port Control Register
func (o *USBFS_Type) SetCFIFOCTR_BVAL(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetCFIFOCTR_BVAL() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetCFIFOCTR_BCLR(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetCFIFOCTR_BCLR() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetCFIFOCTR_FRDY(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetCFIFOCTR_FRDY() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetCFIFOCTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x1e00)|value<<9)
}
func (o *USBFS_Type) GetCFIFOCTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x1e00) >> 9
}
func (o *USBFS_Type) SetCFIFOCTR_DTLN(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetCFIFOCTR_DTLN() uint16 {
	return volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x1ff
}

// USBFS.D0FIFOSEL: D0FIFO Port Select Register
func (o *USBFS_Type) SetD0FIFOSEL_RCNT(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetD0FIFOSEL_RCNT() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetD0FIFOSEL_REW(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetD0FIFOSEL_REW() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetD0FIFOSEL_DCLRM(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetD0FIFOSEL_DCLRM() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetD0FIFOSEL_DREQE(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetD0FIFOSEL_DREQE() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetD0FIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetD0FIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetD0FIFOSEL_MBW(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetD0FIFOSEL_MBW() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetD0FIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetD0FIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetD0FIFOSEL_BIGEND(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetD0FIFOSEL_BIGEND() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetD0FIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0xf0)|value<<4)
}
func (o *USBFS_Type) GetD0FIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0xf0) >> 4
}
func (o *USBFS_Type) SetD0FIFOSEL_CURPIPE(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetD0FIFOSEL_CURPIPE() uint16 {
	return volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0xf
}

// USBFS.D0FIFOCTR: D0FIFO Port Control Register
func (o *USBFS_Type) SetD0FIFOCTR_BVAL(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetD0FIFOCTR_BVAL() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetD0FIFOCTR_BCLR(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetD0FIFOCTR_BCLR() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetD0FIFOCTR_FRDY(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetD0FIFOCTR_FRDY() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetD0FIFOCTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x1e00)|value<<9)
}
func (o *USBFS_Type) GetD0FIFOCTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x1e00) >> 9
}
func (o *USBFS_Type) SetD0FIFOCTR_DTLN(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetD0FIFOCTR_DTLN() uint16 {
	return volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x1ff
}

// USBFS.D1FIFOSEL: D1FIFO Port Select Register
func (o *USBFS_Type) SetD1FIFOSEL_RCNT(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetD1FIFOSEL_RCNT() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetD1FIFOSEL_REW(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetD1FIFOSEL_REW() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetD1FIFOSEL_DCLRM(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetD1FIFOSEL_DCLRM() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetD1FIFOSEL_DREQE(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetD1FIFOSEL_DREQE() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetD1FIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetD1FIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetD1FIFOSEL_MBW(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetD1FIFOSEL_MBW() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetD1FIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetD1FIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetD1FIFOSEL_BIGEND(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetD1FIFOSEL_BIGEND() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetD1FIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0xf0)|value<<4)
}
func (o *USBFS_Type) GetD1FIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0xf0) >> 4
}
func (o *USBFS_Type) SetD1FIFOSEL_CURPIPE(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetD1FIFOSEL_CURPIPE() uint16 {
	return volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0xf
}

// USBFS.D1FIFOCTR: D1FIFO Port Control Register
func (o *USBFS_Type) SetD1FIFOCTR_BVAL(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetD1FIFOCTR_BVAL() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetD1FIFOCTR_BCLR(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetD1FIFOCTR_BCLR() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetD1FIFOCTR_FRDY(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetD1FIFOCTR_FRDY() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetD1FIFOCTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x1e00)|value<<9)
}
func (o *USBFS_Type) GetD1FIFOCTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x1e00) >> 9
}
func (o *USBFS_Type) SetD1FIFOCTR_DTLN(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetD1FIFOCTR_DTLN() uint16 {
	return volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x1ff
}

// USBFS.INTENB0: Interrupt Enable Register 0
func (o *USBFS_Type) SetINTENB0_VBSE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTENB0_VBSE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetINTENB0_RSME(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTENB0_RSME() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTENB0_SOFE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetINTENB0_SOFE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetINTENB0_DVSE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTENB0_DVSE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTENB0_CTRE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTENB0_CTRE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTENB0_BEMPE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetINTENB0_BEMPE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetINTENB0_NRDYE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetINTENB0_NRDYE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetINTENB0_BRDYE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetINTENB0_BRDYE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetINTENB0_Reserved(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0xff)|value)
}
func (o *USBFS_Type) GetINTENB0_Reserved() uint16 {
	return volatile.LoadUint16(&o.INTENB0.Reg) & 0xff
}

// USBFS.INTENB1: Interrupt Enable Register 1
func (o *USBFS_Type) SetINTENB1_OVRCRE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTENB1_OVRCRE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetINTENB1_BCHGE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTENB1_BCHGE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTENB1_Reserved(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetINTENB1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetINTENB1_DTCHE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTENB1_DTCHE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTENB1_ATTCHE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTENB1_ATTCHE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTENB1_Reserved(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x780)|value<<7)
}
func (o *USBFS_Type) GetINTENB1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x780) >> 7
}
func (o *USBFS_Type) SetINTENB1_EOFERRE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetINTENB1_EOFERRE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetINTENB1_SIGNE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetINTENB1_SIGNE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetINTENB1_SACKE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetINTENB1_SACKE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetINTENB1_Reserved(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0xe)|value<<1)
}
func (o *USBFS_Type) GetINTENB1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0xe) >> 1
}
func (o *USBFS_Type) SetINTENB1_PDDETINTE0(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetINTENB1_PDDETINTE0() uint16 {
	return volatile.LoadUint16(&o.INTENB1.Reg) & 0x1
}

// USBFS.BRDYENB: BRDY Interrupt Enable Register
func (o *USBFS_Type) SetBRDYENB_Reserved(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetBRDYENB_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetBRDYENB_PIPE9BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBRDYENB_PIPE9BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetBRDYENB_PIPE8BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBRDYENB_PIPE8BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBRDYENB_PIPE7BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBRDYENB_PIPE7BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBRDYENB_PIPE6BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBRDYENB_PIPE6BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBRDYENB_PIPE5BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBRDYENB_PIPE5BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBRDYENB_PIPE4BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBRDYENB_PIPE4BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBRDYENB_PIPE3BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBRDYENB_PIPE3BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBRDYENB_PIPE2BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBRDYENB_PIPE2BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBRDYENB_PIPE1BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBRDYENB_PIPE1BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBRDYENB_PIPE0BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBRDYENB_PIPE0BRDYE() uint16 {
	return volatile.LoadUint16(&o.BRDYENB.Reg) & 0x1
}

// USBFS.NRDYENB: NRDY Interrupt Enable Register
func (o *USBFS_Type) SetNRDYENB_Reserved(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetNRDYENB_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetNRDYENB_PIPE9NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetNRDYENB_PIPE9NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetNRDYENB_PIPE8NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetNRDYENB_PIPE8NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetNRDYENB_PIPE7NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetNRDYENB_PIPE7NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetNRDYENB_PIPE6NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetNRDYENB_PIPE6NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetNRDYENB_PIPE5NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetNRDYENB_PIPE5NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetNRDYENB_PIPE4NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetNRDYENB_PIPE4NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetNRDYENB_PIPE3NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetNRDYENB_PIPE3NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetNRDYENB_PIPE2NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetNRDYENB_PIPE2NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetNRDYENB_PIPE1NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetNRDYENB_PIPE1NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetNRDYENB_PIPE0NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetNRDYENB_PIPE0NRDYE() uint16 {
	return volatile.LoadUint16(&o.NRDYENB.Reg) & 0x1
}

// USBFS.BEMPENB: BEMP Interrupt Enable Register
func (o *USBFS_Type) SetBEMPENB_Reserved(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetBEMPENB_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetBEMPENB_PIPE9BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBEMPENB_PIPE9BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetBEMPENB_PIPE8BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBEMPENB_PIPE8BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBEMPENB_PIPE7BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBEMPENB_PIPE7BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBEMPENB_PIPE6BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBEMPENB_PIPE6BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBEMPENB_PIPE5BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBEMPENB_PIPE5BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBEMPENB_PIPE4BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBEMPENB_PIPE4BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBEMPENB_PIPE3BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBEMPENB_PIPE3BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBEMPENB_PIPE2BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBEMPENB_PIPE2BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBEMPENB_PIPE1BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBEMPENB_PIPE1BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBEMPENB_PIPE0BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBEMPENB_PIPE0BEMPE() uint16 {
	return volatile.LoadUint16(&o.BEMPENB.Reg) & 0x1
}

// USBFS.SOFCFG: SOF Output Configuration Register
func (o *USBFS_Type) SetSOFCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0xfe00)|value<<9)
}
func (o *USBFS_Type) GetSOFCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0xfe00) >> 9
}
func (o *USBFS_Type) SetSOFCFG_TRNENSEL(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetSOFCFG_TRNENSEL() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetSOFCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetSOFCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetSOFCFG_BRDYM(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetSOFCFG_BRDYM() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetSOFCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetSOFCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetSOFCFG_EDGESTS(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetSOFCFG_EDGESTS() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetSOFCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetSOFCFG_Reserved() uint16 {
	return volatile.LoadUint16(&o.SOFCFG.Reg) & 0xf
}

// USBFS.INTSTS0: Interrupt Status Register 0
func (o *USBFS_Type) SetINTSTS0_VBINT(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTSTS0_VBINT() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetINTSTS0_RESM(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTSTS0_RESM() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTSTS0_SOFR(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetINTSTS0_SOFR() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetINTSTS0_DVST(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTSTS0_DVST() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTSTS0_CTRT(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTSTS0_CTRT() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTSTS0_BEMP(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetINTSTS0_BEMP() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetINTSTS0_NRDY(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetINTSTS0_NRDY() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetINTSTS0_BRDY(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetINTSTS0_BRDY() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetINTSTS0_VBSTS(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetINTSTS0_VBSTS() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetINTSTS0_DVSQ(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x70)|value<<4)
}
func (o *USBFS_Type) GetINTSTS0_DVSQ() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x70) >> 4
}
func (o *USBFS_Type) SetINTSTS0_VALID(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetINTSTS0_VALID() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetINTSTS0_CTSQ(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x7)|value)
}
func (o *USBFS_Type) GetINTSTS0_CTSQ() uint16 {
	return volatile.LoadUint16(&o.INTSTS0.Reg) & 0x7
}

// USBFS.INTSTS1: Interrupt Status Register 1
func (o *USBFS_Type) SetINTSTS1_OVRCR(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTSTS1_OVRCR() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetINTSTS1_BCHG(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTSTS1_BCHG() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTSTS1_Reserved(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetINTSTS1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetINTSTS1_DTCH(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTSTS1_DTCH() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTSTS1_ATTCH(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTSTS1_ATTCH() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTSTS1_Reserved(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x780)|value<<7)
}
func (o *USBFS_Type) GetINTSTS1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x780) >> 7
}
func (o *USBFS_Type) SetINTSTS1_EOFERR(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetINTSTS1_EOFERR() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetINTSTS1_SIGN(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetINTSTS1_SIGN() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetINTSTS1_SACK(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetINTSTS1_SACK() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetINTSTS1_Reserved(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0xe)|value<<1)
}
func (o *USBFS_Type) GetINTSTS1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0xe) >> 1
}
func (o *USBFS_Type) SetINTSTS1_PDDETINT0(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetINTSTS1_PDDETINT0() uint16 {
	return volatile.LoadUint16(&o.INTSTS1.Reg) & 0x1
}

// USBFS.BRDYSTS: BRDY Interrupt Status Register
func (o *USBFS_Type) SetBRDYSTS_Reserved(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetBRDYSTS_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetBRDYSTS_PIPE9BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE9BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetBRDYSTS_PIPE8BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE8BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBRDYSTS_PIPE7BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE7BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBRDYSTS_PIPE6BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE6BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBRDYSTS_PIPE5BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE5BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBRDYSTS_PIPE4BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE4BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBRDYSTS_PIPE3BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE3BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBRDYSTS_PIPE2BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE2BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBRDYSTS_PIPE1BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE1BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBRDYSTS_PIPE0BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE0BRDY() uint16 {
	return volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x1
}

// USBFS.NRDYSTS: NRDY Interrupt Status Register
func (o *USBFS_Type) SetNRDYSTS_Reserved(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetNRDYSTS_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetNRDYSTS_PIPE9NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE9NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetNRDYSTS_PIPE8NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE8NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetNRDYSTS_PIPE7NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE7NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetNRDYSTS_PIPE6NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE6NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetNRDYSTS_PIPE5NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE5NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetNRDYSTS_PIPE4NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE4NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetNRDYSTS_PIPE3NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE3NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetNRDYSTS_PIPE2NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE2NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetNRDYSTS_PIPE1NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE1NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetNRDYSTS_PIPE0NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE0NRDY() uint16 {
	return volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x1
}

// USBFS.BEMPSTS: BEMP Interrupt Status Register
func (o *USBFS_Type) SetBEMPSTS_Reserved(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetBEMPSTS_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetBEMPSTS_PIPE9BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE9BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetBEMPSTS_PIPE8BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE8BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBEMPSTS_PIPE7BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE7BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBEMPSTS_PIPE6BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE6BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBEMPSTS_PIPE5BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE5BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBEMPSTS_PIPE4BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE4BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBEMPSTS_PIPE3BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE3BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBEMPSTS_PIPE2BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE2BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBEMPSTS_PIPE1BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE1BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBEMPSTS_PIPE0BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE0BEMP() uint16 {
	return volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x1
}

// USBFS.FRMNUM: Frame Number Register
func (o *USBFS_Type) SetFRMNUM_OVRN(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetFRMNUM_OVRN() uint16 {
	return (volatile.LoadUint16(&o.FRMNUM.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetFRMNUM_CRCE(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetFRMNUM_CRCE() uint16 {
	return (volatile.LoadUint16(&o.FRMNUM.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetFRMNUM_Reserved(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x3800)|value<<11)
}
func (o *USBFS_Type) GetFRMNUM_Reserved() uint16 {
	return (volatile.LoadUint16(&o.FRMNUM.Reg) & 0x3800) >> 11
}
func (o *USBFS_Type) SetFRMNUM_FRNM(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x7ff)|value)
}
func (o *USBFS_Type) GetFRMNUM_FRNM() uint16 {
	return volatile.LoadUint16(&o.FRMNUM.Reg) & 0x7ff
}

// USBFS.USBREQ: USB Request Type Register
func (o *USBFS_Type) SetUSBREQ_BREQUEST(value uint16) {
	volatile.StoreUint16(&o.USBREQ.Reg, volatile.LoadUint16(&o.USBREQ.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetUSBREQ_BREQUEST() uint16 {
	return (volatile.LoadUint16(&o.USBREQ.Reg) & 0xff00) >> 8
}
func (o *USBFS_Type) SetUSBREQ_BMREQUESTTYPE(value uint16) {
	volatile.StoreUint16(&o.USBREQ.Reg, volatile.LoadUint16(&o.USBREQ.Reg)&^(0xff)|value)
}
func (o *USBFS_Type) GetUSBREQ_BMREQUESTTYPE() uint16 {
	return volatile.LoadUint16(&o.USBREQ.Reg) & 0xff
}

// USBFS.USBVAL: USB Request Value Register
func (o *USBFS_Type) SetUSBVAL(value uint16) {
	volatile.StoreUint16(&o.USBVAL.Reg, value)
}
func (o *USBFS_Type) GetUSBVAL() uint16 {
	return volatile.LoadUint16(&o.USBVAL.Reg)
}

// USBFS.USBINDX: USB Request Index Register
func (o *USBFS_Type) SetUSBINDX(value uint16) {
	volatile.StoreUint16(&o.USBINDX.Reg, value)
}
func (o *USBFS_Type) GetUSBINDX() uint16 {
	return volatile.LoadUint16(&o.USBINDX.Reg)
}

// USBFS.USBLENG: USB Request Length Register
func (o *USBFS_Type) SetUSBLENG(value uint16) {
	volatile.StoreUint16(&o.USBLENG.Reg, value)
}
func (o *USBFS_Type) GetUSBLENG() uint16 {
	return volatile.LoadUint16(&o.USBLENG.Reg)
}

// USBFS.DCPCFG: DCP Configuration Register
func (o *USBFS_Type) SetDCPCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetDCPCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0xff00) >> 8
}
func (o *USBFS_Type) SetDCPCFG_SHTNAK(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetDCPCFG_SHTNAK() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetDCPCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0x60)|value<<5)
}
func (o *USBFS_Type) GetDCPCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0x60) >> 5
}
func (o *USBFS_Type) SetDCPCFG_DIR(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetDCPCFG_DIR() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetDCPCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetDCPCFG_Reserved() uint16 {
	return volatile.LoadUint16(&o.DCPCFG.Reg) & 0xf
}

// USBFS.DCPMAXP: DCP Maximum Packet Size Register
func (o *USBFS_Type) SetDCPMAXP_DEVSEL(value uint16) {
	volatile.StoreUint16(&o.DCPMAXP.Reg, volatile.LoadUint16(&o.DCPMAXP.Reg)&^(0xf000)|value<<12)
}
func (o *USBFS_Type) GetDCPMAXP_DEVSEL() uint16 {
	return (volatile.LoadUint16(&o.DCPMAXP.Reg) & 0xf000) >> 12
}
func (o *USBFS_Type) SetDCPMAXP_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPMAXP.Reg, volatile.LoadUint16(&o.DCPMAXP.Reg)&^(0xf80)|value<<7)
}
func (o *USBFS_Type) GetDCPMAXP_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DCPMAXP.Reg) & 0xf80) >> 7
}
func (o *USBFS_Type) SetDCPMAXP_MXPS(value uint16) {
	volatile.StoreUint16(&o.DCPMAXP.Reg, volatile.LoadUint16(&o.DCPMAXP.Reg)&^(0x7f)|value)
}
func (o *USBFS_Type) GetDCPMAXP_MXPS() uint16 {
	return volatile.LoadUint16(&o.DCPMAXP.Reg) & 0x7f
}

// USBFS.DCPCTR: DCP Control Register
func (o *USBFS_Type) SetDCPCTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetDCPCTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetDCPCTR_SUREQ(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetDCPCTR_SUREQ() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetDCPCTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x3000)|value<<12)
}
func (o *USBFS_Type) GetDCPCTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x3000) >> 12
}
func (o *USBFS_Type) SetDCPCTR_SUREQCLR(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetDCPCTR_SUREQCLR() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetDCPCTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x600)|value<<9)
}
func (o *USBFS_Type) GetDCPCTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x600) >> 9
}
func (o *USBFS_Type) SetDCPCTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetDCPCTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetDCPCTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetDCPCTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetDCPCTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetDCPCTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetDCPCTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetDCPCTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetDCPCTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x18)|value<<3)
}
func (o *USBFS_Type) GetDCPCTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x18) >> 3
}
func (o *USBFS_Type) SetDCPCTR_CCPL(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetDCPCTR_CCPL() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetDCPCTR_PID(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetDCPCTR_PID() uint16 {
	return volatile.LoadUint16(&o.DCPCTR.Reg) & 0x3
}

// USBFS.PIPESEL: Pipe Window Select Register
func (o *USBFS_Type) SetPIPESEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPESEL.Reg, volatile.LoadUint16(&o.PIPESEL.Reg)&^(0xfff0)|value<<4)
}
func (o *USBFS_Type) GetPIPESEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPESEL.Reg) & 0xfff0) >> 4
}
func (o *USBFS_Type) SetPIPESEL(value uint16) {
	volatile.StoreUint16(&o.PIPESEL.Reg, volatile.LoadUint16(&o.PIPESEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetPIPESEL() uint16 {
	return volatile.LoadUint16(&o.PIPESEL.Reg) & 0xf
}

// USBFS.PIPECFG: Pipe Configuration Register
func (o *USBFS_Type) SetPIPECFG_TYPE(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0xc000)|value<<14)
}
func (o *USBFS_Type) GetPIPECFG_TYPE() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0xc000) >> 14
}
func (o *USBFS_Type) SetPIPECFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x3800)|value<<11)
}
func (o *USBFS_Type) GetPIPECFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x3800) >> 11
}
func (o *USBFS_Type) SetPIPECFG_BFRE(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPECFG_BFRE() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPECFG_DBLB(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPECFG_DBLB() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPECFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPECFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPECFG_SHTNAK(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPECFG_SHTNAK() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPECFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPECFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPECFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPECFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPECFG_DIR(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetPIPECFG_DIR() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetPIPECFG_EPNUM(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetPIPECFG_EPNUM() uint16 {
	return volatile.LoadUint16(&o.PIPECFG.Reg) & 0xf
}

// USBFS.PIPEMAXP: Pipe Maximum Packet Size Register
func (o *USBFS_Type) SetPIPEMAXP_DEVSEL(value uint16) {
	volatile.StoreUint16(&o.PIPEMAXP.Reg, volatile.LoadUint16(&o.PIPEMAXP.Reg)&^(0xf000)|value<<12)
}
func (o *USBFS_Type) GetPIPEMAXP_DEVSEL() uint16 {
	return (volatile.LoadUint16(&o.PIPEMAXP.Reg) & 0xf000) >> 12
}
func (o *USBFS_Type) SetPIPEMAXP_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPEMAXP.Reg, volatile.LoadUint16(&o.PIPEMAXP.Reg)&^(0xe00)|value<<9)
}
func (o *USBFS_Type) GetPIPEMAXP_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPEMAXP.Reg) & 0xe00) >> 9
}
func (o *USBFS_Type) SetPIPEMAXP_MXPS(value uint16) {
	volatile.StoreUint16(&o.PIPEMAXP.Reg, volatile.LoadUint16(&o.PIPEMAXP.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetPIPEMAXP_MXPS() uint16 {
	return volatile.LoadUint16(&o.PIPEMAXP.Reg) & 0x1ff
}

// USBFS.PIPEPERI: Pipe Cycle Control Register
func (o *USBFS_Type) SetPIPEPERI_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPEPERI.Reg, volatile.LoadUint16(&o.PIPEPERI.Reg)&^(0xe000)|value<<13)
}
func (o *USBFS_Type) GetPIPEPERI_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPEPERI.Reg) & 0xe000) >> 13
}
func (o *USBFS_Type) SetPIPEPERI_IFIS(value uint16) {
	volatile.StoreUint16(&o.PIPEPERI.Reg, volatile.LoadUint16(&o.PIPEPERI.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetPIPEPERI_IFIS() uint16 {
	return (volatile.LoadUint16(&o.PIPEPERI.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetPIPEPERI_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPEPERI.Reg, volatile.LoadUint16(&o.PIPEPERI.Reg)&^(0xff8)|value<<3)
}
func (o *USBFS_Type) GetPIPEPERI_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPEPERI.Reg) & 0xff8) >> 3
}
func (o *USBFS_Type) SetPIPEPERI_IITV(value uint16) {
	volatile.StoreUint16(&o.PIPEPERI.Reg, volatile.LoadUint16(&o.PIPEPERI.Reg)&^(0x7)|value)
}
func (o *USBFS_Type) GetPIPEPERI_IITV() uint16 {
	return volatile.LoadUint16(&o.PIPEPERI.Reg) & 0x7
}

// USBFS.PIPE1CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE1CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE1CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE1CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE1CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE1CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x3800)|value<<11)
}
func (o *USBFS_Type) GetPIPE1CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x3800) >> 11
}
func (o *USBFS_Type) SetPIPE1CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE1CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE1CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE1CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE1CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE1CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE1CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE1CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE1CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE1CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE1CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE1CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE1CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x1c)|value<<2)
}
func (o *USBFS_Type) GetPIPE1CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x1c) >> 2
}
func (o *USBFS_Type) SetPIPE1CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE1CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x3
}

// USBFS.PIPE2CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE2CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE2CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE2CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE2CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE2CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x3800)|value<<11)
}
func (o *USBFS_Type) GetPIPE2CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x3800) >> 11
}
func (o *USBFS_Type) SetPIPE2CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE2CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE2CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE2CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE2CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE2CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE2CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE2CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE2CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE2CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE2CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE2CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE2CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x1c)|value<<2)
}
func (o *USBFS_Type) GetPIPE2CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x1c) >> 2
}
func (o *USBFS_Type) SetPIPE2CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE2CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x3
}

// USBFS.PIPE3CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE3CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE3CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE3CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE3CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE3CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x3800)|value<<11)
}
func (o *USBFS_Type) GetPIPE3CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x3800) >> 11
}
func (o *USBFS_Type) SetPIPE3CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE3CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE3CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE3CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE3CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE3CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE3CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE3CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE3CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE3CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE3CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE3CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE3CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x1c)|value<<2)
}
func (o *USBFS_Type) GetPIPE3CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x1c) >> 2
}
func (o *USBFS_Type) SetPIPE3CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE3CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x3
}

// USBFS.PIPE4CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE4CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE4CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE4CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE4CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE4CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x3800)|value<<11)
}
func (o *USBFS_Type) GetPIPE4CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x3800) >> 11
}
func (o *USBFS_Type) SetPIPE4CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE4CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE4CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE4CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE4CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE4CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE4CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE4CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE4CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE4CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE4CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE4CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE4CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x1c)|value<<2)
}
func (o *USBFS_Type) GetPIPE4CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x1c) >> 2
}
func (o *USBFS_Type) SetPIPE4CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE4CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x3
}

// USBFS.PIPE5CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE5CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE5CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE5CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE5CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE5CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x3800)|value<<11)
}
func (o *USBFS_Type) GetPIPE5CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x3800) >> 11
}
func (o *USBFS_Type) SetPIPE5CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE5CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE5CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE5CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE5CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE5CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE5CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE5CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE5CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE5CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE5CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE5CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE5CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x1c)|value<<2)
}
func (o *USBFS_Type) GetPIPE5CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x1c) >> 2
}
func (o *USBFS_Type) SetPIPE5CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE5CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x3
}

// USBFS.PIPE6CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE6CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE6CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE6CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x7c00)|value<<10)
}
func (o *USBFS_Type) GetPIPE6CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x7c00) >> 10
}
func (o *USBFS_Type) SetPIPE6CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE6CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE6CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE6CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE6CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE6CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE6CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE6CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE6CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE6CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE6CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x1c)|value<<2)
}
func (o *USBFS_Type) GetPIPE6CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x1c) >> 2
}
func (o *USBFS_Type) SetPIPE6CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE6CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x3
}

// USBFS.PIPE7CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE7CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE7CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE7CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x7c00)|value<<10)
}
func (o *USBFS_Type) GetPIPE7CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x7c00) >> 10
}
func (o *USBFS_Type) SetPIPE7CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE7CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE7CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE7CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE7CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE7CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE7CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE7CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE7CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE7CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE7CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x1c)|value<<2)
}
func (o *USBFS_Type) GetPIPE7CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x1c) >> 2
}
func (o *USBFS_Type) SetPIPE7CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE7CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x3
}

// USBFS.PIPE8CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE8CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE8CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE8CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x7c00)|value<<10)
}
func (o *USBFS_Type) GetPIPE8CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x7c00) >> 10
}
func (o *USBFS_Type) SetPIPE8CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE8CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE8CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE8CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE8CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE8CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE8CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE8CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE8CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE8CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE8CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x1c)|value<<2)
}
func (o *USBFS_Type) GetPIPE8CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x1c) >> 2
}
func (o *USBFS_Type) SetPIPE8CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE8CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x3
}

// USBFS.PIPE9CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE9CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE9CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE9CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x7c00)|value<<10)
}
func (o *USBFS_Type) GetPIPE9CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x7c00) >> 10
}
func (o *USBFS_Type) SetPIPE9CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE9CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE9CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE9CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE9CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE9CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE9CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE9CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE9CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE9CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE9CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x1c)|value<<2)
}
func (o *USBFS_Type) GetPIPE9CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x1c) >> 2
}
func (o *USBFS_Type) SetPIPE9CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE9CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x3
}

// USBFS.PIPE1TRE: Pipe %s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE1TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRE.Reg, volatile.LoadUint16(&o.PIPE1TRE.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetPIPE1TRE_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE1TRE.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetPIPE1TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRE.Reg, volatile.LoadUint16(&o.PIPE1TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE1TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE1TRE.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE1TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRE.Reg, volatile.LoadUint16(&o.PIPE1TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE1TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE1TRE.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE1TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRE.Reg, volatile.LoadUint16(&o.PIPE1TRE.Reg)&^(0xff)|value)
}
func (o *USBFS_Type) GetPIPE1TRE_Reserved() uint16 {
	return volatile.LoadUint16(&o.PIPE1TRE.Reg) & 0xff
}

// USBFS.PIPE1TRN: Pipe %s Transaction Counter Register
func (o *USBFS_Type) SetPIPE1TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE1TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE1TRN.Reg)
}

// USBFS.PIPE2TRE: Pipe %s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE2TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRE.Reg, volatile.LoadUint16(&o.PIPE2TRE.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetPIPE2TRE_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE2TRE.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetPIPE2TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRE.Reg, volatile.LoadUint16(&o.PIPE2TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE2TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE2TRE.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE2TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRE.Reg, volatile.LoadUint16(&o.PIPE2TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE2TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE2TRE.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE2TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRE.Reg, volatile.LoadUint16(&o.PIPE2TRE.Reg)&^(0xff)|value)
}
func (o *USBFS_Type) GetPIPE2TRE_Reserved() uint16 {
	return volatile.LoadUint16(&o.PIPE2TRE.Reg) & 0xff
}

// USBFS.PIPE2TRN: Pipe %s Transaction Counter Register
func (o *USBFS_Type) SetPIPE2TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE2TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE2TRN.Reg)
}

// USBFS.PIPE3TRE: Pipe %s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE3TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRE.Reg, volatile.LoadUint16(&o.PIPE3TRE.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetPIPE3TRE_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE3TRE.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetPIPE3TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRE.Reg, volatile.LoadUint16(&o.PIPE3TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE3TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE3TRE.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE3TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRE.Reg, volatile.LoadUint16(&o.PIPE3TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE3TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE3TRE.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE3TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRE.Reg, volatile.LoadUint16(&o.PIPE3TRE.Reg)&^(0xff)|value)
}
func (o *USBFS_Type) GetPIPE3TRE_Reserved() uint16 {
	return volatile.LoadUint16(&o.PIPE3TRE.Reg) & 0xff
}

// USBFS.PIPE3TRN: Pipe %s Transaction Counter Register
func (o *USBFS_Type) SetPIPE3TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE3TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE3TRN.Reg)
}

// USBFS.PIPE4TRE: Pipe %s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE4TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetPIPE4TRE_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetPIPE4TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE4TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE4TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE4TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE4TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0xff)|value)
}
func (o *USBFS_Type) GetPIPE4TRE_Reserved() uint16 {
	return volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0xff
}

// USBFS.PIPE4TRN: Pipe %s Transaction Counter Register
func (o *USBFS_Type) SetPIPE4TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE4TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE4TRN.Reg)
}

// USBFS.PIPE5TRE: Pipe %s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE5TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetPIPE5TRE_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetPIPE5TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE5TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE5TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE5TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE5TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0xff)|value)
}
func (o *USBFS_Type) GetPIPE5TRE_Reserved() uint16 {
	return volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0xff
}

// USBFS.PIPE5TRN: Pipe %s Transaction Counter Register
func (o *USBFS_Type) SetPIPE5TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE5TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE5TRN.Reg)
}

// USBFS.USBBCCTRL0: BC Control Register 0
func (o *USBFS_Type) SetUSBBCCTRL0_Reserved(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetUSBBCCTRL0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetUSBBCCTRL0_PDDETSTS0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetUSBBCCTRL0_PDDETSTS0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetUSBBCCTRL0_CHGDETSTS0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetUSBBCCTRL0_CHGDETSTS0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetUSBBCCTRL0_BATCHGE0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetUSBBCCTRL0_BATCHGE0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetUSBBCCTRL0_Reserved(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetUSBBCCTRL0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetUSBBCCTRL0_VDMSRCE0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetUSBBCCTRL0_VDMSRCE0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetUSBBCCTRL0_IDPSINKE0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetUSBBCCTRL0_IDPSINKE0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetUSBBCCTRL0_VDPSRCE0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetUSBBCCTRL0_VDPSRCE0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetUSBBCCTRL0_IDMSINKE0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetUSBBCCTRL0_IDMSINKE0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetUSBBCCTRL0_IDPSRCE0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetUSBBCCTRL0_IDPSRCE0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetUSBBCCTRL0_RPDME0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetUSBBCCTRL0_RPDME0() uint16 {
	return volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x1
}

// USBFS.USBMC: USB Module Control Register
func (o *USBFS_Type) SetUSBMC_Reserved(value uint16) {
	volatile.StoreUint16(&o.USBMC.Reg, volatile.LoadUint16(&o.USBMC.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetUSBMC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.USBMC.Reg) & 0xff00) >> 8
}
func (o *USBFS_Type) SetUSBMC_VDCEN(value uint16) {
	volatile.StoreUint16(&o.USBMC.Reg, volatile.LoadUint16(&o.USBMC.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetUSBMC_VDCEN() uint16 {
	return (volatile.LoadUint16(&o.USBMC.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetUSBMC_Reserved(value uint16) {
	volatile.StoreUint16(&o.USBMC.Reg, volatile.LoadUint16(&o.USBMC.Reg)&^(0x7c)|value<<2)
}
func (o *USBFS_Type) GetUSBMC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.USBMC.Reg) & 0x7c) >> 2
}
func (o *USBFS_Type) SetUSBMC_Reserved(value uint16) {
	volatile.StoreUint16(&o.USBMC.Reg, volatile.LoadUint16(&o.USBMC.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetUSBMC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.USBMC.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetUSBMC_VDDUSBE(value uint16) {
	volatile.StoreUint16(&o.USBMC.Reg, volatile.LoadUint16(&o.USBMC.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetUSBMC_VDDUSBE() uint16 {
	return volatile.LoadUint16(&o.USBMC.Reg) & 0x1
}

// USBFS.DEVADD0: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD0_Reserved(value uint16) {
	volatile.StoreUint16(&o.DEVADD0.Reg, volatile.LoadUint16(&o.DEVADD0.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetDEVADD0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DEVADD0.Reg) & 0xff00) >> 8
}
func (o *USBFS_Type) SetDEVADD0_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD0.Reg, volatile.LoadUint16(&o.DEVADD0.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD0_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD0.Reg) & 0xc0) >> 6
}
func (o *USBFS_Type) SetDEVADD0_Reserved(value uint16) {
	volatile.StoreUint16(&o.DEVADD0.Reg, volatile.LoadUint16(&o.DEVADD0.Reg)&^(0x3f)|value)
}
func (o *USBFS_Type) GetDEVADD0_Reserved() uint16 {
	return volatile.LoadUint16(&o.DEVADD0.Reg) & 0x3f
}

// USBFS.DEVADD1: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD1_Reserved(value uint16) {
	volatile.StoreUint16(&o.DEVADD1.Reg, volatile.LoadUint16(&o.DEVADD1.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetDEVADD1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DEVADD1.Reg) & 0xff00) >> 8
}
func (o *USBFS_Type) SetDEVADD1_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD1.Reg, volatile.LoadUint16(&o.DEVADD1.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD1_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD1.Reg) & 0xc0) >> 6
}
func (o *USBFS_Type) SetDEVADD1_Reserved(value uint16) {
	volatile.StoreUint16(&o.DEVADD1.Reg, volatile.LoadUint16(&o.DEVADD1.Reg)&^(0x3f)|value)
}
func (o *USBFS_Type) GetDEVADD1_Reserved() uint16 {
	return volatile.LoadUint16(&o.DEVADD1.Reg) & 0x3f
}

// USBFS.DEVADD2: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD2_Reserved(value uint16) {
	volatile.StoreUint16(&o.DEVADD2.Reg, volatile.LoadUint16(&o.DEVADD2.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetDEVADD2_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DEVADD2.Reg) & 0xff00) >> 8
}
func (o *USBFS_Type) SetDEVADD2_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD2.Reg, volatile.LoadUint16(&o.DEVADD2.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD2_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD2.Reg) & 0xc0) >> 6
}
func (o *USBFS_Type) SetDEVADD2_Reserved(value uint16) {
	volatile.StoreUint16(&o.DEVADD2.Reg, volatile.LoadUint16(&o.DEVADD2.Reg)&^(0x3f)|value)
}
func (o *USBFS_Type) GetDEVADD2_Reserved() uint16 {
	return volatile.LoadUint16(&o.DEVADD2.Reg) & 0x3f
}

// USBFS.DEVADD3: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD3_Reserved(value uint16) {
	volatile.StoreUint16(&o.DEVADD3.Reg, volatile.LoadUint16(&o.DEVADD3.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetDEVADD3_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DEVADD3.Reg) & 0xff00) >> 8
}
func (o *USBFS_Type) SetDEVADD3_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD3.Reg, volatile.LoadUint16(&o.DEVADD3.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD3_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD3.Reg) & 0xc0) >> 6
}
func (o *USBFS_Type) SetDEVADD3_Reserved(value uint16) {
	volatile.StoreUint16(&o.DEVADD3.Reg, volatile.LoadUint16(&o.DEVADD3.Reg)&^(0x3f)|value)
}
func (o *USBFS_Type) GetDEVADD3_Reserved() uint16 {
	return volatile.LoadUint16(&o.DEVADD3.Reg) & 0x3f
}

// USBFS.DEVADD4: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD4_Reserved(value uint16) {
	volatile.StoreUint16(&o.DEVADD4.Reg, volatile.LoadUint16(&o.DEVADD4.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetDEVADD4_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DEVADD4.Reg) & 0xff00) >> 8
}
func (o *USBFS_Type) SetDEVADD4_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD4.Reg, volatile.LoadUint16(&o.DEVADD4.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD4_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD4.Reg) & 0xc0) >> 6
}
func (o *USBFS_Type) SetDEVADD4_Reserved(value uint16) {
	volatile.StoreUint16(&o.DEVADD4.Reg, volatile.LoadUint16(&o.DEVADD4.Reg)&^(0x3f)|value)
}
func (o *USBFS_Type) GetDEVADD4_Reserved() uint16 {
	return volatile.LoadUint16(&o.DEVADD4.Reg) & 0x3f
}

// USBFS.DEVADD5: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD5_Reserved(value uint16) {
	volatile.StoreUint16(&o.DEVADD5.Reg, volatile.LoadUint16(&o.DEVADD5.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetDEVADD5_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DEVADD5.Reg) & 0xff00) >> 8
}
func (o *USBFS_Type) SetDEVADD5_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD5.Reg, volatile.LoadUint16(&o.DEVADD5.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD5_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD5.Reg) & 0xc0) >> 6
}
func (o *USBFS_Type) SetDEVADD5_Reserved(value uint16) {
	volatile.StoreUint16(&o.DEVADD5.Reg, volatile.LoadUint16(&o.DEVADD5.Reg)&^(0x3f)|value)
}
func (o *USBFS_Type) GetDEVADD5_Reserved() uint16 {
	return volatile.LoadUint16(&o.DEVADD5.Reg) & 0x3f
}

// Independent Watchdog Timer
type IWDT_Type struct {
	IWDTRR volatile.Register8 // 0x0
	_      [3]byte
	IWDTSR volatile.Register16 // 0x4
}

// IWDT.IWDTRR: IWDT Refresh Register
func (o *IWDT_Type) SetIWDTRR(value uint8) {
	volatile.StoreUint8(&o.IWDTRR.Reg, value)
}
func (o *IWDT_Type) GetIWDTRR() uint8 {
	return volatile.LoadUint8(&o.IWDTRR.Reg)
}

// IWDT.IWDTSR: IWDT Status Register
func (o *IWDT_Type) SetIWDTSR_REFEF(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x8000)|value<<15)
}
func (o *IWDT_Type) GetIWDTSR_REFEF() uint16 {
	return (volatile.LoadUint16(&o.IWDTSR.Reg) & 0x8000) >> 15
}
func (o *IWDT_Type) SetIWDTSR_UNDFF(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x4000)|value<<14)
}
func (o *IWDT_Type) GetIWDTSR_UNDFF() uint16 {
	return (volatile.LoadUint16(&o.IWDTSR.Reg) & 0x4000) >> 14
}
func (o *IWDT_Type) SetIWDTSR_CNTVAL(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x3fff)|value)
}
func (o *IWDT_Type) GetIWDTSR_CNTVAL() uint16 {
	return volatile.LoadUint16(&o.IWDTSR.Reg) & 0x3fff
}

// Port 0 Control Registers
type PORT0_Type struct {
	PCNTR1 volatile.Register32 // 0x0
	PCNTR2 volatile.Register32 // 0x4
	PCNTR3 volatile.Register32 // 0x8
}

// PORT0.PCNTR1: Port Control Register 1
func (o *PORT0_Type) SetPCNTR1_PODR(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT0_Type) GetPCNTR1_PODR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0xffff0000) >> 16
}
func (o *PORT0_Type) SetPCNTR1_PDR(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0xffff)|value)
}
func (o *PORT0_Type) GetPCNTR1_PDR() uint32 {
	return volatile.LoadUint32(&o.PCNTR1.Reg) & 0xffff
}

// PORT0.PCNTR2: Port Control Register 2
func (o *PORT0_Type) SetPCNTR2_EIDR(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT0_Type) GetPCNTR2_EIDR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0xffff0000) >> 16
}
func (o *PORT0_Type) SetPCNTR2_PIDR(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0xffff)|value)
}
func (o *PORT0_Type) GetPCNTR2_PIDR() uint32 {
	return volatile.LoadUint32(&o.PCNTR2.Reg) & 0xffff
}

// PORT0.PCNTR3: Port Control Register 3
func (o *PORT0_Type) SetPCNTR3_PORR(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT0_Type) GetPCNTR3_PORR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0xffff0000) >> 16
}
func (o *PORT0_Type) SetPCNTR3_POSR(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0xffff)|value)
}
func (o *PORT0_Type) GetPCNTR3_POSR() uint32 {
	return volatile.LoadUint32(&o.PCNTR3.Reg) & 0xffff
}

// Port 1 Control Registers
type PORT1_Type struct {
	PCNTR1 volatile.Register32 // 0x0
	PCNTR2 volatile.Register32 // 0x4
	PCNTR3 volatile.Register32 // 0x8
	PCNTR4 volatile.Register32 // 0xC
}

// PORT1.PCNTR1: Port Control Register 1
func (o *PORT1_Type) SetPCNTR1_PODR(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR1_PODR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0xffff0000) >> 16
}
func (o *PORT1_Type) SetPCNTR1_PDR(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0xffff)|value)
}
func (o *PORT1_Type) GetPCNTR1_PDR() uint32 {
	return volatile.LoadUint32(&o.PCNTR1.Reg) & 0xffff
}

// PORT1.PCNTR2: Port Control Register 2
func (o *PORT1_Type) SetPCNTR2_EIDR(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR2_EIDR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0xffff0000) >> 16
}
func (o *PORT1_Type) SetPCNTR2_PIDR(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0xffff)|value)
}
func (o *PORT1_Type) GetPCNTR2_PIDR() uint32 {
	return volatile.LoadUint32(&o.PCNTR2.Reg) & 0xffff
}

// PORT1.PCNTR3: Port Control Register 3
func (o *PORT1_Type) SetPCNTR3_PORR(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR3_PORR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0xffff0000) >> 16
}
func (o *PORT1_Type) SetPCNTR3_POSR(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0xffff)|value)
}
func (o *PORT1_Type) GetPCNTR3_POSR() uint32 {
	return volatile.LoadUint32(&o.PCNTR3.Reg) & 0xffff
}

// PORT1.PCNTR4: Port Control Register 4
func (o *PORT1_Type) SetPCNTR4_EORR(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR4_EORR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0xffff0000) >> 16
}
func (o *PORT1_Type) SetPCNTR4_EOSR(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0xffff)|value)
}
func (o *PORT1_Type) GetPCNTR4_EOSR() uint32 {
	return volatile.LoadUint32(&o.PCNTR4.Reg) & 0xffff
}

// Pmn Pin Function Control Register
type PFS_Type struct {
	P000PFS volatile.Register32 // 0x0
	P001PFS volatile.Register32 // 0x4
	P002PFS volatile.Register32 // 0x8
	P003PFS volatile.Register32 // 0xC
	P004PFS volatile.Register32 // 0x10
	P005PFS volatile.Register32 // 0x14
	P006PFS volatile.Register32 // 0x18
	P007PFS volatile.Register32 // 0x1C
	P008PFS volatile.Register32 // 0x20
	P009PFS volatile.Register32 // 0x24
	P010PFS volatile.Register32 // 0x28
	P011PFS volatile.Register32 // 0x2C
	P012PFS volatile.Register32 // 0x30
	P013PFS volatile.Register32 // 0x34
	P014PFS volatile.Register32 // 0x38
	P015PFS volatile.Register32 // 0x3C
	P100PFS volatile.Register32 // 0x40
	P101PFS volatile.Register32 // 0x44
	P102PFS volatile.Register32 // 0x48
	P103PFS volatile.Register32 // 0x4C
	P104PFS volatile.Register32 // 0x50
	P105PFS volatile.Register32 // 0x54
	P106PFS volatile.Register32 // 0x58
	P107PFS volatile.Register32 // 0x5C
	P108PFS volatile.Register32 // 0x60
	P109PFS volatile.Register32 // 0x64
	P110PFS volatile.Register32 // 0x68
	P111PFS volatile.Register32 // 0x6C
	P112PFS volatile.Register32 // 0x70
	P113PFS volatile.Register32 // 0x74
	P114PFS volatile.Register32 // 0x78
	P115PFS volatile.Register32 // 0x7C
	P200PFS volatile.Register32 // 0x80
	P201PFS volatile.Register32 // 0x84
	P202PFS volatile.Register32 // 0x88
	P203PFS volatile.Register32 // 0x8C
	P204PFS volatile.Register32 // 0x90
	P205PFS volatile.Register32 // 0x94
	P206PFS volatile.Register32 // 0x98
	_       [20]byte
	P212PFS volatile.Register32 // 0xB0
	P213PFS volatile.Register32 // 0xB4
	P214PFS volatile.Register32 // 0xB8
	P215PFS volatile.Register32 // 0xBC
	P300PFS volatile.Register32 // 0xC0
	P301PFS volatile.Register32 // 0xC4
	P302PFS volatile.Register32 // 0xC8
	P303PFS volatile.Register32 // 0xCC
	P304PFS volatile.Register32 // 0xD0
	P305PFS volatile.Register32 // 0xD4
	P306PFS volatile.Register32 // 0xD8
	P307PFS volatile.Register32 // 0xDC
	P308PFS volatile.Register32 // 0xE0
	P309PFS volatile.Register32 // 0xE4
	P310PFS volatile.Register32 // 0xE8
	P311PFS volatile.Register32 // 0xEC
	P312PFS volatile.Register32 // 0xF0
	P313PFS volatile.Register32 // 0xF4
	P314PFS volatile.Register32 // 0xF8
	P315PFS volatile.Register32 // 0xFC
	P400PFS volatile.Register32 // 0x100
	P401PFS volatile.Register32 // 0x104
	P402PFS volatile.Register32 // 0x108
	P403PFS volatile.Register32 // 0x10C
	P404PFS volatile.Register32 // 0x110
	P405PFS volatile.Register32 // 0x114
	P406PFS volatile.Register32 // 0x118
	P407PFS volatile.Register32 // 0x11C
	P408PFS volatile.Register32 // 0x120
	P409PFS volatile.Register32 // 0x124
	P410PFS volatile.Register32 // 0x128
	P411PFS volatile.Register32 // 0x12C
	P412PFS volatile.Register32 // 0x130
	P413PFS volatile.Register32 // 0x134
	P414PFS volatile.Register32 // 0x138
	P415PFS volatile.Register32 // 0x13C
	P500PFS volatile.Register32 // 0x140
	P501PFS volatile.Register32 // 0x144
	P502PFS volatile.Register32 // 0x148
	P503PFS volatile.Register32 // 0x14C
	P504PFS volatile.Register32 // 0x150
	P505PFS volatile.Register32 // 0x154
	P506PFS volatile.Register32 // 0x158
	P507PFS volatile.Register32 // 0x15C
	_       [12]byte
	P511PFS volatile.Register32 // 0x16C
	P512PFS volatile.Register32 // 0x170
	_       [12]byte
	P600PFS volatile.Register32 // 0x180
	P601PFS volatile.Register32 // 0x184
	P602PFS volatile.Register32 // 0x188
	P603PFS volatile.Register32 // 0x18C
	P604PFS volatile.Register32 // 0x190
	P605PFS volatile.Register32 // 0x194
	P606PFS volatile.Register32 // 0x198
	_       [4]byte
	P608PFS volatile.Register32 // 0x1A0
	P609PFS volatile.Register32 // 0x1A4
	P610PFS volatile.Register32 // 0x1A8
	P611PFS volatile.Register32 // 0x1AC
	P612PFS volatile.Register32 // 0x1B0
	P613PFS volatile.Register32 // 0x1B4
	P614PFS volatile.Register32 // 0x1B8
	_       [4]byte
	P700PFS volatile.Register32 // 0x1C0
	P701PFS volatile.Register32 // 0x1C4
	P702PFS volatile.Register32 // 0x1C8
	P703PFS volatile.Register32 // 0x1CC
	P704PFS volatile.Register32 // 0x1D0
	P705PFS volatile.Register32 // 0x1D4
	_       [8]byte
	P708PFS volatile.Register32 // 0x1E0
	P709PFS volatile.Register32 // 0x1E4
	P710PFS volatile.Register32 // 0x1E8
	P711PFS volatile.Register32 // 0x1EC
	P712PFS volatile.Register32 // 0x1F0
	P713PFS volatile.Register32 // 0x1F4
	_       [8]byte
	P800PFS volatile.Register32 // 0x200
	P801PFS volatile.Register32 // 0x204
	P802PFS volatile.Register32 // 0x208
	P803PFS volatile.Register32 // 0x20C
	P804PFS volatile.Register32 // 0x210
	P805PFS volatile.Register32 // 0x214
	P806PFS volatile.Register32 // 0x218
	P807PFS volatile.Register32 // 0x21C
	P808PFS volatile.Register32 // 0x220
	P809PFS volatile.Register32 // 0x224
	_       [24]byte
	P900PFS volatile.Register32 // 0x240
	P901PFS volatile.Register32 // 0x244
	P902PFS volatile.Register32 // 0x248
	_       [44]byte
	P914PFS volatile.Register32 // 0x278
	P915PFS volatile.Register32 // 0x27C
}

// PFS.P000PFS: P000 Pin Function Control Register
func (o *PFS_Type) SetP000PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0xe0000000)|value<<29)
}
func (o *PFS_Type) GetP000PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0xe0000000) >> 29
}
func (o *PFS_Type) SetP000PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP000PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x1f000000) >> 24
}
func (o *PFS_Type) SetP000PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0xfe0000)|value<<17)
}
func (o *PFS_Type) GetP000PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0xfe0000) >> 17
}
func (o *PFS_Type) SetP000PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP000PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP000PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP000PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP000PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP000PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP000PFS_EOF(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x2000)|value<<13)
}
func (o *PFS_Type) GetP000PFS_EOF() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x2000) >> 13
}
func (o *PFS_Type) SetP000PFS_EOR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x1000)|value<<12)
}
func (o *PFS_Type) GetP000PFS_EOR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x1000) >> 12
}
func (o *PFS_Type) SetP000PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x800)|value<<11)
}
func (o *PFS_Type) GetP000PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x800) >> 11
}
func (o *PFS_Type) SetP000PFS_DSCR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x400)|value<<10)
}
func (o *PFS_Type) GetP000PFS_DSCR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x400) >> 10
}
func (o *PFS_Type) SetP000PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x380)|value<<7)
}
func (o *PFS_Type) GetP000PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x380) >> 7
}
func (o *PFS_Type) SetP000PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP000PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP000PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x20)|value<<5)
}
func (o *PFS_Type) GetP000PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x20) >> 5
}
func (o *PFS_Type) SetP000PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP000PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP000PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x8)|value<<3)
}
func (o *PFS_Type) GetP000PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x8) >> 3
}
func (o *PFS_Type) SetP000PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP000PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP000PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP000PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP000PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP000PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P000PFS.Reg) & 0x1
}

// PFS.P108PFS: P108 Pin Function Control Register
func (o *PFS_Type) SetP108PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0xe0000000)|value<<29)
}
func (o *PFS_Type) GetP108PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0xe0000000) >> 29
}
func (o *PFS_Type) SetP108PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP108PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x1f000000) >> 24
}
func (o *PFS_Type) SetP108PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0xfe0000)|value<<17)
}
func (o *PFS_Type) GetP108PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0xfe0000) >> 17
}
func (o *PFS_Type) SetP108PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP108PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP108PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP108PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP108PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP108PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP108PFS_EOF(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x2000)|value<<13)
}
func (o *PFS_Type) GetP108PFS_EOF() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x2000) >> 13
}
func (o *PFS_Type) SetP108PFS_EOR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x1000)|value<<12)
}
func (o *PFS_Type) GetP108PFS_EOR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x1000) >> 12
}
func (o *PFS_Type) SetP108PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x800)|value<<11)
}
func (o *PFS_Type) GetP108PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x800) >> 11
}
func (o *PFS_Type) SetP108PFS_DSCR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x400)|value<<10)
}
func (o *PFS_Type) GetP108PFS_DSCR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x400) >> 10
}
func (o *PFS_Type) SetP108PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x380)|value<<7)
}
func (o *PFS_Type) GetP108PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x380) >> 7
}
func (o *PFS_Type) SetP108PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP108PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP108PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x20)|value<<5)
}
func (o *PFS_Type) GetP108PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x20) >> 5
}
func (o *PFS_Type) SetP108PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP108PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP108PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x8)|value<<3)
}
func (o *PFS_Type) GetP108PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x8) >> 3
}
func (o *PFS_Type) SetP108PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP108PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP108PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP108PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP108PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP108PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P108PFS.Reg) & 0x1
}

// PFS.P109PFS: P109 Pin Function Control Register
func (o *PFS_Type) SetP109PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0xe0000000)|value<<29)
}
func (o *PFS_Type) GetP109PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0xe0000000) >> 29
}
func (o *PFS_Type) SetP109PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP109PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x1f000000) >> 24
}
func (o *PFS_Type) SetP109PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0xfe0000)|value<<17)
}
func (o *PFS_Type) GetP109PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0xfe0000) >> 17
}
func (o *PFS_Type) SetP109PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP109PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP109PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP109PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP109PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP109PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP109PFS_EOF(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x2000)|value<<13)
}
func (o *PFS_Type) GetP109PFS_EOF() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x2000) >> 13
}
func (o *PFS_Type) SetP109PFS_EOR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x1000)|value<<12)
}
func (o *PFS_Type) GetP109PFS_EOR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x1000) >> 12
}
func (o *PFS_Type) SetP109PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x800)|value<<11)
}
func (o *PFS_Type) GetP109PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x800) >> 11
}
func (o *PFS_Type) SetP109PFS_DSCR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x400)|value<<10)
}
func (o *PFS_Type) GetP109PFS_DSCR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x400) >> 10
}
func (o *PFS_Type) SetP109PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x380)|value<<7)
}
func (o *PFS_Type) GetP109PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x380) >> 7
}
func (o *PFS_Type) SetP109PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP109PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP109PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x20)|value<<5)
}
func (o *PFS_Type) GetP109PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x20) >> 5
}
func (o *PFS_Type) SetP109PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP109PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP109PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x8)|value<<3)
}
func (o *PFS_Type) GetP109PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x8) >> 3
}
func (o *PFS_Type) SetP109PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP109PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP109PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP109PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP109PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP109PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P109PFS.Reg) & 0x1
}

// PFS.P201PFS: P201 Pin Function Control Register
func (o *PFS_Type) SetP201PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0xe0000000)|value<<29)
}
func (o *PFS_Type) GetP201PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0xe0000000) >> 29
}
func (o *PFS_Type) SetP201PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP201PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x1f000000) >> 24
}
func (o *PFS_Type) SetP201PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0xfe0000)|value<<17)
}
func (o *PFS_Type) GetP201PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0xfe0000) >> 17
}
func (o *PFS_Type) SetP201PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP201PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP201PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP201PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP201PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP201PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP201PFS_EOF(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x2000)|value<<13)
}
func (o *PFS_Type) GetP201PFS_EOF() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x2000) >> 13
}
func (o *PFS_Type) SetP201PFS_EOR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x1000)|value<<12)
}
func (o *PFS_Type) GetP201PFS_EOR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x1000) >> 12
}
func (o *PFS_Type) SetP201PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x800)|value<<11)
}
func (o *PFS_Type) GetP201PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x800) >> 11
}
func (o *PFS_Type) SetP201PFS_DSCR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x400)|value<<10)
}
func (o *PFS_Type) GetP201PFS_DSCR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x400) >> 10
}
func (o *PFS_Type) SetP201PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x380)|value<<7)
}
func (o *PFS_Type) GetP201PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x380) >> 7
}
func (o *PFS_Type) SetP201PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP201PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP201PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x20)|value<<5)
}
func (o *PFS_Type) GetP201PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x20) >> 5
}
func (o *PFS_Type) SetP201PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP201PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP201PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x8)|value<<3)
}
func (o *PFS_Type) GetP201PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x8) >> 3
}
func (o *PFS_Type) SetP201PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP201PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP201PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP201PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP201PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP201PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P201PFS.Reg) & 0x1
}

// PFS.P408PFS: P408 Pin Function Control Register
func (o *PFS_Type) SetP408PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0xe0000000)|value<<29)
}
func (o *PFS_Type) GetP408PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0xe0000000) >> 29
}
func (o *PFS_Type) SetP408PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP408PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x1f000000) >> 24
}
func (o *PFS_Type) SetP408PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0xfe0000)|value<<17)
}
func (o *PFS_Type) GetP408PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0xfe0000) >> 17
}
func (o *PFS_Type) SetP408PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP408PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP408PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP408PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP408PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP408PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP408PFS_EOF(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x2000)|value<<13)
}
func (o *PFS_Type) GetP408PFS_EOF() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x2000) >> 13
}
func (o *PFS_Type) SetP408PFS_EOR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x1000)|value<<12)
}
func (o *PFS_Type) GetP408PFS_EOR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x1000) >> 12
}
func (o *PFS_Type) SetP408PFS_DSCR1(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x800)|value<<11)
}
func (o *PFS_Type) GetP408PFS_DSCR1() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x800) >> 11
}
func (o *PFS_Type) SetP408PFS_DSCR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x400)|value<<10)
}
func (o *PFS_Type) GetP408PFS_DSCR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x400) >> 10
}
func (o *PFS_Type) SetP408PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x380)|value<<7)
}
func (o *PFS_Type) GetP408PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x380) >> 7
}
func (o *PFS_Type) SetP408PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP408PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP408PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x20)|value<<5)
}
func (o *PFS_Type) GetP408PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x20) >> 5
}
func (o *PFS_Type) SetP408PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP408PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP408PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x8)|value<<3)
}
func (o *PFS_Type) GetP408PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x8) >> 3
}
func (o *PFS_Type) SetP408PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP408PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP408PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP408PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP408PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP408PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P408PFS.Reg) & 0x1
}

// Miscellaneous Port Control Register
type PMISC_Type struct {
	_    [3]byte
	PWPR volatile.Register8 // 0x3
}

// PMISC.PWPR: Write-Protect Register
func (o *PMISC_Type) SetPWPR_B0WI(value uint8) {
	volatile.StoreUint8(&o.PWPR.Reg, volatile.LoadUint8(&o.PWPR.Reg)&^(0x80)|value<<7)
}
func (o *PMISC_Type) GetPWPR_B0WI() uint8 {
	return (volatile.LoadUint8(&o.PWPR.Reg) & 0x80) >> 7
}
func (o *PMISC_Type) SetPWPR_PFSWE(value uint8) {
	volatile.StoreUint8(&o.PWPR.Reg, volatile.LoadUint8(&o.PWPR.Reg)&^(0x40)|value<<6)
}
func (o *PMISC_Type) GetPWPR_PFSWE() uint8 {
	return (volatile.LoadUint8(&o.PWPR.Reg) & 0x40) >> 6
}
func (o *PMISC_Type) SetPWPR_Reserved(value uint8) {
	volatile.StoreUint8(&o.PWPR.Reg, volatile.LoadUint8(&o.PWPR.Reg)&^(0x3f)|value)
}
func (o *PMISC_Type) GetPWPR_Reserved() uint8 {
	return volatile.LoadUint8(&o.PWPR.Reg) & 0x3f
}

// Event Link Controller
type ELC_Type struct {
	ELCR    volatile.Register8 // 0x0
	_       byte
	ELSEGR0 volatile.Register8 // 0x2
	_       byte
	ELSEGR1 volatile.Register8 // 0x4
	_       [11]byte
	ELSR0   volatile.Register16 // 0x10
	_       [2]byte
	ELSR1   volatile.Register16 // 0x14
	_       [2]byte
	ELSR2   volatile.Register16 // 0x18
	_       [2]byte
	ELSR3   volatile.Register16 // 0x1C
	_       [2]byte
	ELSR4   volatile.Register16 // 0x20
	_       [2]byte
	ELSR5   volatile.Register16 // 0x24
	_       [2]byte
	ELSR6   volatile.Register16 // 0x28
	_       [2]byte
	ELSR7   volatile.Register16 // 0x2C
	_       [2]byte
	ELSR8   volatile.Register16 // 0x30
	_       [2]byte
	ELSR9   volatile.Register16 // 0x34
	_       [10]byte
	ELSR12  volatile.Register16 // 0x40
	_       [6]byte
	ELSR14  volatile.Register16 // 0x48
	_       [2]byte
	ELSR15  volatile.Register16 // 0x4C
	_       [2]byte
	ELSR16  volatile.Register16 // 0x50
	_       [2]byte
	ELSR17  volatile.Register16 // 0x54
	_       [2]byte
	ELSR18  volatile.Register16 // 0x58
}

// ELC.ELCR: Event Link Controller Register
func (o *ELC_Type) SetELCR_ELCON(value uint8) {
	volatile.StoreUint8(&o.ELCR.Reg, volatile.LoadUint8(&o.ELCR.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELCR_ELCON() uint8 {
	return (volatile.LoadUint8(&o.ELCR.Reg) & 0x80) >> 7
}
func (o *ELC_Type) SetELCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.ELCR.Reg, volatile.LoadUint8(&o.ELCR.Reg)&^(0x7f)|value)
}
func (o *ELC_Type) GetELCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.ELCR.Reg) & 0x7f
}

// ELC.ELSEGR0: Event Link Software Event Generation Register %s
func (o *ELC_Type) SetELSEGR0_WI(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELSEGR0_WI() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x80) >> 7
}
func (o *ELC_Type) SetELSEGR0_WE(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x40)|value<<6)
}
func (o *ELC_Type) GetELSEGR0_WE() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x40) >> 6
}
func (o *ELC_Type) SetELSEGR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x3e)|value<<1)
}
func (o *ELC_Type) GetELSEGR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x3e) >> 1
}
func (o *ELC_Type) SetELSEGR0_SEG(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x1)|value)
}
func (o *ELC_Type) GetELSEGR0_SEG() uint8 {
	return volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x1
}

// ELC.ELSEGR1: Event Link Software Event Generation Register %s
func (o *ELC_Type) SetELSEGR1_WI(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELSEGR1_WI() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x80) >> 7
}
func (o *ELC_Type) SetELSEGR1_WE(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x40)|value<<6)
}
func (o *ELC_Type) GetELSEGR1_WE() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x40) >> 6
}
func (o *ELC_Type) SetELSEGR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x3e)|value<<1)
}
func (o *ELC_Type) GetELSEGR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x3e) >> 1
}
func (o *ELC_Type) SetELSEGR1_SEG(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x1)|value)
}
func (o *ELC_Type) GetELSEGR1_SEG() uint8 {
	return volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x1
}

// ELC.ELSR0: Event Link Setting Register %s
func (o *ELC_Type) SetELSR0_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR0.Reg, volatile.LoadUint16(&o.ELSR0.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR0.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR0_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR0.Reg, volatile.LoadUint16(&o.ELSR0.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR0_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR0.Reg) & 0xff
}

// ELC.ELSR1: Event Link Setting Register %s
func (o *ELC_Type) SetELSR1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR1.Reg, volatile.LoadUint16(&o.ELSR1.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR1.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR1_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR1.Reg, volatile.LoadUint16(&o.ELSR1.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR1_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR1.Reg) & 0xff
}

// ELC.ELSR2: Event Link Setting Register %s
func (o *ELC_Type) SetELSR2_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR2.Reg, volatile.LoadUint16(&o.ELSR2.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR2_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR2.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR2_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR2.Reg, volatile.LoadUint16(&o.ELSR2.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR2_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR2.Reg) & 0xff
}

// ELC.ELSR3: Event Link Setting Register %s
func (o *ELC_Type) SetELSR3_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR3.Reg, volatile.LoadUint16(&o.ELSR3.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR3_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR3.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR3_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR3.Reg, volatile.LoadUint16(&o.ELSR3.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR3_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR3.Reg) & 0xff
}

// ELC.ELSR4: Event Link Setting Register %s
func (o *ELC_Type) SetELSR4_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR4.Reg, volatile.LoadUint16(&o.ELSR4.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR4_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR4.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR4_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR4.Reg, volatile.LoadUint16(&o.ELSR4.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR4_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR4.Reg) & 0xff
}

// ELC.ELSR5: Event Link Setting Register %s
func (o *ELC_Type) SetELSR5_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR5.Reg, volatile.LoadUint16(&o.ELSR5.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR5_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR5.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR5_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR5.Reg, volatile.LoadUint16(&o.ELSR5.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR5_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR5.Reg) & 0xff
}

// ELC.ELSR6: Event Link Setting Register %s
func (o *ELC_Type) SetELSR6_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR6.Reg, volatile.LoadUint16(&o.ELSR6.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR6_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR6.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR6_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR6.Reg, volatile.LoadUint16(&o.ELSR6.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR6_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR6.Reg) & 0xff
}

// ELC.ELSR7: Event Link Setting Register %s
func (o *ELC_Type) SetELSR7_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR7.Reg, volatile.LoadUint16(&o.ELSR7.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR7_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR7.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR7_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR7.Reg, volatile.LoadUint16(&o.ELSR7.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR7_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR7.Reg) & 0xff
}

// ELC.ELSR8: Event Link Setting Register %s
func (o *ELC_Type) SetELSR8_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR8.Reg, volatile.LoadUint16(&o.ELSR8.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR8_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR8.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR8_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR8.Reg, volatile.LoadUint16(&o.ELSR8.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR8_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR8.Reg) & 0xff
}

// ELC.ELSR9: Event Link Setting Register %s
func (o *ELC_Type) SetELSR9_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR9.Reg, volatile.LoadUint16(&o.ELSR9.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR9_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR9.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR9_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR9.Reg, volatile.LoadUint16(&o.ELSR9.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR9_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR9.Reg) & 0xff
}

// ELC.ELSR12: Event Link Setting Register 12
func (o *ELC_Type) SetELSR12_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR12.Reg, volatile.LoadUint16(&o.ELSR12.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR12_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR12.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR12_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR12.Reg, volatile.LoadUint16(&o.ELSR12.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR12_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR12.Reg) & 0xff
}

// ELC.ELSR14: Event Link Setting Register %s
func (o *ELC_Type) SetELSR14_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR14.Reg, volatile.LoadUint16(&o.ELSR14.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR14_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR14.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR14_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR14.Reg, volatile.LoadUint16(&o.ELSR14.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR14_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR14.Reg) & 0xff
}

// ELC.ELSR15: Event Link Setting Register %s
func (o *ELC_Type) SetELSR15_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR15.Reg, volatile.LoadUint16(&o.ELSR15.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR15_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR15.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR15_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR15.Reg, volatile.LoadUint16(&o.ELSR15.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR15_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR15.Reg) & 0xff
}

// ELC.ELSR16: Event Link Setting Register %s
func (o *ELC_Type) SetELSR16_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR16.Reg, volatile.LoadUint16(&o.ELSR16.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR16_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR16.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR16_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR16.Reg, volatile.LoadUint16(&o.ELSR16.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR16_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR16.Reg) & 0xff
}

// ELC.ELSR17: Event Link Setting Register %s
func (o *ELC_Type) SetELSR17_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR17.Reg, volatile.LoadUint16(&o.ELSR17.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR17_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR17.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR17_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR17.Reg, volatile.LoadUint16(&o.ELSR17.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR17_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR17.Reg) & 0xff
}

// ELC.ELSR18: Event Link Setting Register %s
func (o *ELC_Type) SetELSR18_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR18.Reg, volatile.LoadUint16(&o.ELSR18.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR18_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR18.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR18_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR18.Reg, volatile.LoadUint16(&o.ELSR18.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR18_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR18.Reg) & 0xff
}

// Data Operation Circuit
type DOC_Type struct {
	DOCR  volatile.Register8 // 0x0
	_     byte
	DODIR volatile.Register16 // 0x2
	DODSR volatile.Register16 // 0x4
}

// DOC.DOCR: DOC Control Register
func (o *DOC_Type) SetDOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x80)|value<<7)
}
func (o *DOC_Type) GetDOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x80) >> 7
}
func (o *DOC_Type) SetDOCR_DOPCFCL(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x40)|value<<6)
}
func (o *DOC_Type) GetDOCR_DOPCFCL() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x40) >> 6
}
func (o *DOC_Type) SetDOCR_DOPCF(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x20)|value<<5)
}
func (o *DOC_Type) GetDOCR_DOPCF() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x20) >> 5
}
func (o *DOC_Type) SetDOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x18)|value<<3)
}
func (o *DOC_Type) GetDOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x18) >> 3
}
func (o *DOC_Type) SetDOCR_DCSEL(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x4)|value<<2)
}
func (o *DOC_Type) GetDOCR_DCSEL() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x4) >> 2
}
func (o *DOC_Type) SetDOCR_OMS(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x3)|value)
}
func (o *DOC_Type) GetDOCR_OMS() uint8 {
	return volatile.LoadUint8(&o.DOCR.Reg) & 0x3
}

// DOC.DODIR: DOC Data Input Register
func (o *DOC_Type) SetDODIR(value uint16) {
	volatile.StoreUint16(&o.DODIR.Reg, value)
}
func (o *DOC_Type) GetDODIR() uint16 {
	return volatile.LoadUint16(&o.DODIR.Reg)
}

// DOC.DODSR: DOC Data Setting Register
func (o *DOC_Type) SetDODSR(value uint16) {
	volatile.StoreUint16(&o.DODSR.Reg, value)
}
func (o *DOC_Type) GetDODSR() uint16 {
	return volatile.LoadUint16(&o.DODSR.Reg)
}

// CRC Calculator
type CRC_Type struct {
	CRCCR0 volatile.Register8 // 0x0
	CRCCR1 volatile.Register8 // 0x1
	_      [2]byte
	CRCDIR volatile.Register32 // 0x4
	CRCDOR volatile.Register32 // 0x8
	CRCSAR volatile.Register16 // 0xC
}

// CRC.CRCCR0: CRC Control Register0
func (o *CRC_Type) SetCRCCR0_DORCIR(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCRCCR0_DORCIR() uint8 {
	return (volatile.LoadUint8(&o.CRCCR0.Reg) & 0x80) >> 7
}
func (o *CRC_Type) SetCRCCR0_LMS(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x40)|value<<6)
}
func (o *CRC_Type) GetCRCCR0_LMS() uint8 {
	return (volatile.LoadUint8(&o.CRCCR0.Reg) & 0x40) >> 6
}
func (o *CRC_Type) SetCRCCR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x38)|value<<3)
}
func (o *CRC_Type) GetCRCCR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CRCCR0.Reg) & 0x38) >> 3
}
func (o *CRC_Type) SetCRCCR0_GPS(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x7)|value)
}
func (o *CRC_Type) GetCRCCR0_GPS() uint8 {
	return volatile.LoadUint8(&o.CRCCR0.Reg) & 0x7
}

// CRC.CRCCR1: CRC Control Register1
func (o *CRC_Type) SetCRCCR1_CRCSEN(value uint8) {
	volatile.StoreUint8(&o.CRCCR1.Reg, volatile.LoadUint8(&o.CRCCR1.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCRCCR1_CRCSEN() uint8 {
	return (volatile.LoadUint8(&o.CRCCR1.Reg) & 0x80) >> 7
}
func (o *CRC_Type) SetCRCCR1_CRCSWR(value uint8) {
	volatile.StoreUint8(&o.CRCCR1.Reg, volatile.LoadUint8(&o.CRCCR1.Reg)&^(0x40)|value<<6)
}
func (o *CRC_Type) GetCRCCR1_CRCSWR() uint8 {
	return (volatile.LoadUint8(&o.CRCCR1.Reg) & 0x40) >> 6
}
func (o *CRC_Type) SetCRCCR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.CRCCR1.Reg, volatile.LoadUint8(&o.CRCCR1.Reg)&^(0x3f)|value)
}
func (o *CRC_Type) GetCRCCR1_Reserved() uint8 {
	return volatile.LoadUint8(&o.CRCCR1.Reg) & 0x3f
}

// CRC.CRCDIR: CRC Data Input Register
func (o *CRC_Type) SetCRCDIR(value uint32) {
	volatile.StoreUint32(&o.CRCDIR.Reg, value)
}
func (o *CRC_Type) GetCRCDIR() uint32 {
	return volatile.LoadUint32(&o.CRCDIR.Reg)
}

// CRC.CRCDOR: CRC Data Output Register
func (o *CRC_Type) SetCRCDOR(value uint32) {
	volatile.StoreUint32(&o.CRCDOR.Reg, value)
}
func (o *CRC_Type) GetCRCDOR() uint32 {
	return volatile.LoadUint32(&o.CRCDOR.Reg)
}

// CRC.CRCSAR: Snoop Address Register
func (o *CRC_Type) SetCRCSAR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CRCSAR.Reg, volatile.LoadUint16(&o.CRCSAR.Reg)&^(0xc000)|value<<14)
}
func (o *CRC_Type) GetCRCSAR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CRCSAR.Reg) & 0xc000) >> 14
}
func (o *CRC_Type) SetCRCSAR_CRCSA(value uint16) {
	volatile.StoreUint16(&o.CRCSAR.Reg, volatile.LoadUint16(&o.CRCSAR.Reg)&^(0x3fff)|value)
}
func (o *CRC_Type) GetCRCSAR_CRCSA() uint16 {
	return volatile.LoadUint16(&o.CRCSAR.Reg) & 0x3fff
}

// Clock Frequency Accuracy Measurement Circuit
type CAC_Type struct {
	CACR0   volatile.Register8 // 0x0
	CACR1   volatile.Register8 // 0x1
	CACR2   volatile.Register8 // 0x2
	CAICR   volatile.Register8 // 0x3
	CASTR   volatile.Register8 // 0x4
	_       byte
	CAULVR  volatile.Register16 // 0x6
	CALLVR  volatile.Register16 // 0x8
	CACNTBR volatile.Register16 // 0xA
}

// CAC.CACR0: CAC Control Register 0
func (o *CAC_Type) SetCACR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.CACR0.Reg, volatile.LoadUint8(&o.CACR0.Reg)&^(0xfe)|value<<1)
}
func (o *CAC_Type) GetCACR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CACR0.Reg) & 0xfe) >> 1
}
func (o *CAC_Type) SetCACR0_CFME(value uint8) {
	volatile.StoreUint8(&o.CACR0.Reg, volatile.LoadUint8(&o.CACR0.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR0_CFME() uint8 {
	return volatile.LoadUint8(&o.CACR0.Reg) & 0x1
}

// CAC.CACR1: CAC Control Register 1
func (o *CAC_Type) SetCACR1_EDGES(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0xc0)|value<<6)
}
func (o *CAC_Type) GetCACR1_EDGES() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0xc0) >> 6
}
func (o *CAC_Type) SetCACR1_TCSS(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0x30)|value<<4)
}
func (o *CAC_Type) GetCACR1_TCSS() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0x30) >> 4
}
func (o *CAC_Type) SetCACR1_FMCS(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0xe)|value<<1)
}
func (o *CAC_Type) GetCACR1_FMCS() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0xe) >> 1
}
func (o *CAC_Type) SetCACR1_CACREFE(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR1_CACREFE() uint8 {
	return volatile.LoadUint8(&o.CACR1.Reg) & 0x1
}

// CAC.CACR2: CAC Control Register 2
func (o *CAC_Type) SetCACR2_DFS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0xc0)|value<<6)
}
func (o *CAC_Type) GetCACR2_DFS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0xc0) >> 6
}
func (o *CAC_Type) SetCACR2_RCDS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0x30)|value<<4)
}
func (o *CAC_Type) GetCACR2_RCDS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0x30) >> 4
}
func (o *CAC_Type) SetCACR2_RSCS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0xe)|value<<1)
}
func (o *CAC_Type) GetCACR2_RSCS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0xe) >> 1
}
func (o *CAC_Type) SetCACR2_RPS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR2_RPS() uint8 {
	return volatile.LoadUint8(&o.CACR2.Reg) & 0x1
}

// CAC.CAICR: CAC Interrupt Control Register
func (o *CAC_Type) SetCAICR_Reserved(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x80)|value<<7)
}
func (o *CAC_Type) GetCAICR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x80) >> 7
}
func (o *CAC_Type) SetCAICR_OVFFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x40)|value<<6)
}
func (o *CAC_Type) GetCAICR_OVFFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x40) >> 6
}
func (o *CAC_Type) SetCAICR_MENDFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x20)|value<<5)
}
func (o *CAC_Type) GetCAICR_MENDFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x20) >> 5
}
func (o *CAC_Type) SetCAICR_FERRFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x10)|value<<4)
}
func (o *CAC_Type) GetCAICR_FERRFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x10) >> 4
}
func (o *CAC_Type) SetCAICR_Reserved(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x8)|value<<3)
}
func (o *CAC_Type) GetCAICR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x8) >> 3
}
func (o *CAC_Type) SetCAICR_OVFIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x4)|value<<2)
}
func (o *CAC_Type) GetCAICR_OVFIE() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x4) >> 2
}
func (o *CAC_Type) SetCAICR_MENDIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x2)|value<<1)
}
func (o *CAC_Type) GetCAICR_MENDIE() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x2) >> 1
}
func (o *CAC_Type) SetCAICR_FERRIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCAICR_FERRIE() uint8 {
	return volatile.LoadUint8(&o.CAICR.Reg) & 0x1
}

// CAC.CASTR: CAC Status Register
func (o *CAC_Type) SetCASTR_OVFF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x4)|value<<2)
}
func (o *CAC_Type) GetCASTR_OVFF() uint8 {
	return (volatile.LoadUint8(&o.CASTR.Reg) & 0x4) >> 2
}
func (o *CAC_Type) SetCASTR_MENDF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x2)|value<<1)
}
func (o *CAC_Type) GetCASTR_MENDF() uint8 {
	return (volatile.LoadUint8(&o.CASTR.Reg) & 0x2) >> 1
}
func (o *CAC_Type) SetCASTR_FERRF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCASTR_FERRF() uint8 {
	return volatile.LoadUint8(&o.CASTR.Reg) & 0x1
}

// CAC.CAULVR: CAC Upper-Limit Value Setting Register
func (o *CAC_Type) SetCAULVR(value uint16) {
	volatile.StoreUint16(&o.CAULVR.Reg, value)
}
func (o *CAC_Type) GetCAULVR() uint16 {
	return volatile.LoadUint16(&o.CAULVR.Reg)
}

// CAC.CALLVR: CAC Lower-Limit Value Setting Register
func (o *CAC_Type) SetCALLVR(value uint16) {
	volatile.StoreUint16(&o.CALLVR.Reg, value)
}
func (o *CAC_Type) GetCALLVR() uint16 {
	return volatile.LoadUint16(&o.CALLVR.Reg)
}

// CAC.CACNTBR: CAC Counter Buffer Register
func (o *CAC_Type) SetCACNTBR(value uint16) {
	volatile.StoreUint16(&o.CACNTBR.Reg, value)
}
func (o *CAC_Type) GetCACNTBR() uint16 {
	return volatile.LoadUint16(&o.CACNTBR.Reg)
}

// 8-bit D/A converter
type DAC8_Type struct {
	DACS0 volatile.Register8 // 0x0
	DACS1 volatile.Register8 // 0x1
	_     byte
	DAM   volatile.Register8 // 0x3
}

// DAC8.DACS0: D/A Conversion Value Setting Register %s
func (o *DAC8_Type) SetDACS0(value uint8) {
	volatile.StoreUint8(&o.DACS0.Reg, value)
}
func (o *DAC8_Type) GetDACS0() uint8 {
	return volatile.LoadUint8(&o.DACS0.Reg)
}

// DAC8.DACS1: D/A Conversion Value Setting Register %s
func (o *DAC8_Type) SetDACS1(value uint8) {
	volatile.StoreUint8(&o.DACS1.Reg, value)
}
func (o *DAC8_Type) GetDACS1() uint8 {
	return volatile.LoadUint8(&o.DACS1.Reg)
}

// DAC8.DAM: D/A Converter Mode Register
func (o *DAC8_Type) SetDAM_Reserved(value uint8) {
	volatile.StoreUint8(&o.DAM.Reg, volatile.LoadUint8(&o.DAM.Reg)&^(0xc0)|value<<6)
}
func (o *DAC8_Type) GetDAM_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DAM.Reg) & 0xc0) >> 6
}
func (o *DAC8_Type) SetDAM_DACE1(value uint8) {
	volatile.StoreUint8(&o.DAM.Reg, volatile.LoadUint8(&o.DAM.Reg)&^(0x20)|value<<5)
}
func (o *DAC8_Type) GetDAM_DACE1() uint8 {
	return (volatile.LoadUint8(&o.DAM.Reg) & 0x20) >> 5
}
func (o *DAC8_Type) SetDAM_DACE0(value uint8) {
	volatile.StoreUint8(&o.DAM.Reg, volatile.LoadUint8(&o.DAM.Reg)&^(0x10)|value<<4)
}
func (o *DAC8_Type) GetDAM_DACE0() uint8 {
	return (volatile.LoadUint8(&o.DAM.Reg) & 0x10) >> 4
}
func (o *DAC8_Type) SetDAM_Reserved(value uint8) {
	volatile.StoreUint8(&o.DAM.Reg, volatile.LoadUint8(&o.DAM.Reg)&^(0xf)|value)
}
func (o *DAC8_Type) GetDAM_Reserved() uint8 {
	return volatile.LoadUint8(&o.DAM.Reg) & 0xf
}

// 12-bit D/A converter
type DAC12_Type struct {
	DADR0    volatile.Register16 // 0x0
	_        [2]byte
	DACR     volatile.Register8 // 0x4
	DADPR    volatile.Register8 // 0x5
	DAADSCR  volatile.Register8 // 0x6
	DAVREFCR volatile.Register8 // 0x7
}

// DAC12.DADR0: D/A Data Register 0
func (o *DAC12_Type) SetDADR0(value uint16) {
	volatile.StoreUint16(&o.DADR0.Reg, value)
}
func (o *DAC12_Type) GetDADR0() uint16 {
	return volatile.LoadUint16(&o.DADR0.Reg)
}

// DAC12.DACR: D/A Control Register
func (o *DAC12_Type) SetDACR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDACR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DACR.Reg) & 0x80) >> 7
}
func (o *DAC12_Type) SetDACR_DAOE0(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x40)|value<<6)
}
func (o *DAC12_Type) GetDACR_DAOE0() uint8 {
	return (volatile.LoadUint8(&o.DACR.Reg) & 0x40) >> 6
}
func (o *DAC12_Type) SetDACR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x20)|value<<5)
}
func (o *DAC12_Type) GetDACR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DACR.Reg) & 0x20) >> 5
}
func (o *DAC12_Type) SetDACR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x1f)|value)
}
func (o *DAC12_Type) GetDACR_Reserved() uint8 {
	return volatile.LoadUint8(&o.DACR.Reg) & 0x1f
}

// DAC12.DADPR: DADR0 Format Select Register
func (o *DAC12_Type) SetDADPR_DPSEL(value uint8) {
	volatile.StoreUint8(&o.DADPR.Reg, volatile.LoadUint8(&o.DADPR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDADPR_DPSEL() uint8 {
	return (volatile.LoadUint8(&o.DADPR.Reg) & 0x80) >> 7
}
func (o *DAC12_Type) SetDADPR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DADPR.Reg, volatile.LoadUint8(&o.DADPR.Reg)&^(0x7f)|value)
}
func (o *DAC12_Type) GetDADPR_Reserved() uint8 {
	return volatile.LoadUint8(&o.DADPR.Reg) & 0x7f
}

// DAC12.DAADSCR: D/A-A/D Synchronous Start Control Register
func (o *DAC12_Type) SetDAADSCR_DAADST(value uint8) {
	volatile.StoreUint8(&o.DAADSCR.Reg, volatile.LoadUint8(&o.DAADSCR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDAADSCR_DAADST() uint8 {
	return (volatile.LoadUint8(&o.DAADSCR.Reg) & 0x80) >> 7
}

// DAC12.DAVREFCR: D/A VREF Control Register
func (o *DAC12_Type) SetDAVREFCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DAVREFCR.Reg, volatile.LoadUint8(&o.DAVREFCR.Reg)&^(0xf8)|value<<3)
}
func (o *DAC12_Type) GetDAVREFCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DAVREFCR.Reg) & 0xf8) >> 3
}
func (o *DAC12_Type) SetDAVREFCR_REF(value uint8) {
	volatile.StoreUint8(&o.DAVREFCR.Reg, volatile.LoadUint8(&o.DAVREFCR.Reg)&^(0x7)|value)
}
func (o *DAC12_Type) GetDAVREFCR_REF() uint8 {
	return volatile.LoadUint8(&o.DAVREFCR.Reg) & 0x7
}

// Capacitive Touch Sensing Unit
type CTSU_Type struct {
	CTSUCR0    volatile.Register8  // 0x0
	CTSUCR1    volatile.Register8  // 0x1
	CTSUSDPRS  volatile.Register8  // 0x2
	CTSUSST    volatile.Register8  // 0x3
	CTSUMCH0   volatile.Register8  // 0x4
	CTSUMCH1   volatile.Register8  // 0x5
	CTSUCHAC0  volatile.Register8  // 0x6
	CTSUCHAC1  volatile.Register8  // 0x7
	CTSUCHAC2  volatile.Register8  // 0x8
	CTSUCHAC3  volatile.Register8  // 0x9
	CTSUCHAC4  volatile.Register8  // 0xA
	CTSUCHTRC0 volatile.Register8  // 0xB
	CTSUCHTRC1 volatile.Register8  // 0xC
	CTSUCHTRC2 volatile.Register8  // 0xD
	CTSUCHTRC3 volatile.Register8  // 0xE
	CTSUCHTRC4 volatile.Register8  // 0xF
	CTSUDCLKC  volatile.Register8  // 0x10
	CTSUST     volatile.Register8  // 0x11
	CTSUSSC    volatile.Register16 // 0x12
	CTSUSO0    volatile.Register16 // 0x14
	CTSUSO1    volatile.Register16 // 0x16
	CTSUSC     volatile.Register16 // 0x18
	CTSURC     volatile.Register16 // 0x1A
	CTSUERRS   volatile.Register16 // 0x1C
}

// CTSU.CTSUCR0: CTSU Control Register 0
func (o *CTSU_Type) SetCTSUCR0_CTSUINIT(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x10)|value<<4)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUINIT() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x10) >> 4
}
func (o *CTSU_Type) SetCTSUCR0_CTSUIOC(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x8)|value<<3)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUIOC() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x8) >> 3
}
func (o *CTSU_Type) SetCTSUCR0_CTSUSNZ(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x4)|value<<2)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUSNZ() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x4) >> 2
}
func (o *CTSU_Type) SetCTSUCR0_CTSUCAP(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x2)|value<<1)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUCAP() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x2) >> 1
}
func (o *CTSU_Type) SetCTSUCR0_CTSUSTRT(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x1)|value)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUSTRT() uint8 {
	return volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x1
}

// CTSU.CTSUCR1: CTSU Control Register 1
func (o *CTSU_Type) SetCTSUCR1_CTSUMD(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0xc0)|value<<6)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUMD() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0xc0) >> 6
}
func (o *CTSU_Type) SetCTSUCR1_CTSUCLK(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x30)|value<<4)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUCLK() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x30) >> 4
}
func (o *CTSU_Type) SetCTSUCR1_CTSUATUNE1(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x8)|value<<3)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUATUNE1() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x8) >> 3
}
func (o *CTSU_Type) SetCTSUCR1_CTSUATUNE0(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x4)|value<<2)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUATUNE0() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x4) >> 2
}
func (o *CTSU_Type) SetCTSUCR1_CTSUCSW(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x2)|value<<1)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUCSW() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x2) >> 1
}
func (o *CTSU_Type) SetCTSUCR1_CTSUPON(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x1)|value)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUPON() uint8 {
	return volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x1
}

// CTSU.CTSUSDPRS: CTSU Synchronous Noise Reduction Setting Register
func (o *CTSU_Type) SetCTSUSDPRS_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUSDPRS.Reg, volatile.LoadUint8(&o.CTSUSDPRS.Reg)&^(0x80)|value<<7)
}
func (o *CTSU_Type) GetCTSUSDPRS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUSDPRS.Reg) & 0x80) >> 7
}
func (o *CTSU_Type) SetCTSUSDPRS_CTSUSOFF(value uint8) {
	volatile.StoreUint8(&o.CTSUSDPRS.Reg, volatile.LoadUint8(&o.CTSUSDPRS.Reg)&^(0x40)|value<<6)
}
func (o *CTSU_Type) GetCTSUSDPRS_CTSUSOFF() uint8 {
	return (volatile.LoadUint8(&o.CTSUSDPRS.Reg) & 0x40) >> 6
}
func (o *CTSU_Type) SetCTSUSDPRS_CTSUPRMODE(value uint8) {
	volatile.StoreUint8(&o.CTSUSDPRS.Reg, volatile.LoadUint8(&o.CTSUSDPRS.Reg)&^(0x30)|value<<4)
}
func (o *CTSU_Type) GetCTSUSDPRS_CTSUPRMODE() uint8 {
	return (volatile.LoadUint8(&o.CTSUSDPRS.Reg) & 0x30) >> 4
}
func (o *CTSU_Type) SetCTSUSDPRS_CTSUPRRATIO(value uint8) {
	volatile.StoreUint8(&o.CTSUSDPRS.Reg, volatile.LoadUint8(&o.CTSUSDPRS.Reg)&^(0xf)|value)
}
func (o *CTSU_Type) GetCTSUSDPRS_CTSUPRRATIO() uint8 {
	return volatile.LoadUint8(&o.CTSUSDPRS.Reg) & 0xf
}

// CTSU.CTSUSST: CTSU Sensor Stabilization Wait Control Register
func (o *CTSU_Type) SetCTSUSST(value uint8) {
	volatile.StoreUint8(&o.CTSUSST.Reg, value)
}
func (o *CTSU_Type) GetCTSUSST() uint8 {
	return volatile.LoadUint8(&o.CTSUSST.Reg)
}

// CTSU.CTSUMCH0: CTSU Measurement Channel Register 0
func (o *CTSU_Type) SetCTSUMCH0_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUMCH0.Reg, volatile.LoadUint8(&o.CTSUMCH0.Reg)&^(0xc0)|value<<6)
}
func (o *CTSU_Type) GetCTSUMCH0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUMCH0.Reg) & 0xc0) >> 6
}
func (o *CTSU_Type) SetCTSUMCH0(value uint8) {
	volatile.StoreUint8(&o.CTSUMCH0.Reg, volatile.LoadUint8(&o.CTSUMCH0.Reg)&^(0x3f)|value)
}
func (o *CTSU_Type) GetCTSUMCH0() uint8 {
	return volatile.LoadUint8(&o.CTSUMCH0.Reg) & 0x3f
}

// CTSU.CTSUMCH1: CTSU Measurement Channel Register 1
func (o *CTSU_Type) SetCTSUMCH1_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUMCH1.Reg, volatile.LoadUint8(&o.CTSUMCH1.Reg)&^(0xc0)|value<<6)
}
func (o *CTSU_Type) GetCTSUMCH1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUMCH1.Reg) & 0xc0) >> 6
}
func (o *CTSU_Type) SetCTSUMCH1(value uint8) {
	volatile.StoreUint8(&o.CTSUMCH1.Reg, volatile.LoadUint8(&o.CTSUMCH1.Reg)&^(0x3f)|value)
}
func (o *CTSU_Type) GetCTSUMCH1() uint8 {
	return volatile.LoadUint8(&o.CTSUMCH1.Reg) & 0x3f
}

// CTSU.CTSUCHAC0: CTSU Channel Enable Control Register 0
func (o *CTSU_Type) SetCTSUCHAC0(value uint8) {
	volatile.StoreUint8(&o.CTSUCHAC0.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHAC0() uint8 {
	return volatile.LoadUint8(&o.CTSUCHAC0.Reg)
}

// CTSU.CTSUCHAC1: CTSU Channel Enable Control Register 1
func (o *CTSU_Type) SetCTSUCHAC1(value uint8) {
	volatile.StoreUint8(&o.CTSUCHAC1.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHAC1() uint8 {
	return volatile.LoadUint8(&o.CTSUCHAC1.Reg)
}

// CTSU.CTSUCHAC2: CTSU Channel Enable Control Register 2
func (o *CTSU_Type) SetCTSUCHAC2(value uint8) {
	volatile.StoreUint8(&o.CTSUCHAC2.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHAC2() uint8 {
	return volatile.LoadUint8(&o.CTSUCHAC2.Reg)
}

// CTSU.CTSUCHAC3: CTSU Channel Enable Control Register 3
func (o *CTSU_Type) SetCTSUCHAC3(value uint8) {
	volatile.StoreUint8(&o.CTSUCHAC3.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHAC3() uint8 {
	return volatile.LoadUint8(&o.CTSUCHAC3.Reg)
}

// CTSU.CTSUCHAC4: CTSU Channel Enable Control Register 4
func (o *CTSU_Type) SetCTSUCHAC4_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUCHAC4.Reg, volatile.LoadUint8(&o.CTSUCHAC4.Reg)&^(0xf0)|value<<4)
}
func (o *CTSU_Type) GetCTSUCHAC4_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUCHAC4.Reg) & 0xf0) >> 4
}
func (o *CTSU_Type) SetCTSUCHAC4(value uint8) {
	volatile.StoreUint8(&o.CTSUCHAC4.Reg, volatile.LoadUint8(&o.CTSUCHAC4.Reg)&^(0xf)|value)
}
func (o *CTSU_Type) GetCTSUCHAC4() uint8 {
	return volatile.LoadUint8(&o.CTSUCHAC4.Reg) & 0xf
}

// CTSU.CTSUCHTRC0: CTSU Channel Transmit/Receive Control Register 0
func (o *CTSU_Type) SetCTSUCHTRC0(value uint8) {
	volatile.StoreUint8(&o.CTSUCHTRC0.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHTRC0() uint8 {
	return volatile.LoadUint8(&o.CTSUCHTRC0.Reg)
}

// CTSU.CTSUCHTRC1: CTSU Channel Transmit/Receive Control Register 1
func (o *CTSU_Type) SetCTSUCHTRC1(value uint8) {
	volatile.StoreUint8(&o.CTSUCHTRC1.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHTRC1() uint8 {
	return volatile.LoadUint8(&o.CTSUCHTRC1.Reg)
}

// CTSU.CTSUCHTRC2: CTSU Channel Transmit/Receive Control Register 3
func (o *CTSU_Type) SetCTSUCHTRC2(value uint8) {
	volatile.StoreUint8(&o.CTSUCHTRC2.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHTRC2() uint8 {
	return volatile.LoadUint8(&o.CTSUCHTRC2.Reg)
}

// CTSU.CTSUCHTRC3: CTSU Channel Transmit/Receive Control Register 3
func (o *CTSU_Type) SetCTSUCHTRC3(value uint8) {
	volatile.StoreUint8(&o.CTSUCHTRC3.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHTRC3() uint8 {
	return volatile.LoadUint8(&o.CTSUCHTRC3.Reg)
}

// CTSU.CTSUCHTRC4: CTSU Channel Transmit/Receive Control Register 4
func (o *CTSU_Type) SetCTSUCHTRC4_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUCHTRC4.Reg, volatile.LoadUint8(&o.CTSUCHTRC4.Reg)&^(0xf0)|value<<4)
}
func (o *CTSU_Type) GetCTSUCHTRC4_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUCHTRC4.Reg) & 0xf0) >> 4
}
func (o *CTSU_Type) SetCTSUCHTRC4_CTSUCHAC4(value uint8) {
	volatile.StoreUint8(&o.CTSUCHTRC4.Reg, volatile.LoadUint8(&o.CTSUCHTRC4.Reg)&^(0xf)|value)
}
func (o *CTSU_Type) GetCTSUCHTRC4_CTSUCHAC4() uint8 {
	return volatile.LoadUint8(&o.CTSUCHTRC4.Reg) & 0xf
}

// CTSU.CTSUDCLKC: CTSU High-Pass Noise Reduction Control Register
func (o *CTSU_Type) SetCTSUDCLKC_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUDCLKC.Reg, volatile.LoadUint8(&o.CTSUDCLKC.Reg)&^(0xc0)|value<<6)
}
func (o *CTSU_Type) GetCTSUDCLKC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUDCLKC.Reg) & 0xc0) >> 6
}
func (o *CTSU_Type) SetCTSUDCLKC_CTSUSSCNT(value uint8) {
	volatile.StoreUint8(&o.CTSUDCLKC.Reg, volatile.LoadUint8(&o.CTSUDCLKC.Reg)&^(0x30)|value<<4)
}
func (o *CTSU_Type) GetCTSUDCLKC_CTSUSSCNT() uint8 {
	return (volatile.LoadUint8(&o.CTSUDCLKC.Reg) & 0x30) >> 4
}
func (o *CTSU_Type) SetCTSUDCLKC_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUDCLKC.Reg, volatile.LoadUint8(&o.CTSUDCLKC.Reg)&^(0xc)|value<<2)
}
func (o *CTSU_Type) GetCTSUDCLKC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUDCLKC.Reg) & 0xc) >> 2
}
func (o *CTSU_Type) SetCTSUDCLKC_CTSUSSMOD(value uint8) {
	volatile.StoreUint8(&o.CTSUDCLKC.Reg, volatile.LoadUint8(&o.CTSUDCLKC.Reg)&^(0x3)|value)
}
func (o *CTSU_Type) GetCTSUDCLKC_CTSUSSMOD() uint8 {
	return volatile.LoadUint8(&o.CTSUDCLKC.Reg) & 0x3
}

// CTSU.CTSUST: CTSU Status Register
func (o *CTSU_Type) SetCTSUST_CTSUPS(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x80)|value<<7)
}
func (o *CTSU_Type) GetCTSUST_CTSUPS() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x80) >> 7
}
func (o *CTSU_Type) SetCTSUST_CTSUROVF(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x40)|value<<6)
}
func (o *CTSU_Type) GetCTSUST_CTSUROVF() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x40) >> 6
}
func (o *CTSU_Type) SetCTSUST_CTSUSOVF(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x20)|value<<5)
}
func (o *CTSU_Type) GetCTSUST_CTSUSOVF() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x20) >> 5
}
func (o *CTSU_Type) SetCTSUST_CTSUDTSR(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x10)|value<<4)
}
func (o *CTSU_Type) GetCTSUST_CTSUDTSR() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x10) >> 4
}
func (o *CTSU_Type) SetCTSUST_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x8)|value<<3)
}
func (o *CTSU_Type) GetCTSUST_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x8) >> 3
}
func (o *CTSU_Type) SetCTSUST_CTSUSTC(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x7)|value)
}
func (o *CTSU_Type) GetCTSUST_CTSUSTC() uint8 {
	return volatile.LoadUint8(&o.CTSUST.Reg) & 0x7
}

// CTSU.CTSUSSC: CTSU High-Pass Noise Reduction Spectrum Diffusion Control Register
func (o *CTSU_Type) SetCTSUSSC_Reserved(value uint16) {
	volatile.StoreUint16(&o.CTSUSSC.Reg, volatile.LoadUint16(&o.CTSUSSC.Reg)&^(0xf000)|value<<12)
}
func (o *CTSU_Type) GetCTSUSSC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CTSUSSC.Reg) & 0xf000) >> 12
}
func (o *CTSU_Type) SetCTSUSSC_CTSUSSDIV(value uint16) {
	volatile.StoreUint16(&o.CTSUSSC.Reg, volatile.LoadUint16(&o.CTSUSSC.Reg)&^(0xf00)|value<<8)
}
func (o *CTSU_Type) GetCTSUSSC_CTSUSSDIV() uint16 {
	return (volatile.LoadUint16(&o.CTSUSSC.Reg) & 0xf00) >> 8
}
func (o *CTSU_Type) SetCTSUSSC_Reserved(value uint16) {
	volatile.StoreUint16(&o.CTSUSSC.Reg, volatile.LoadUint16(&o.CTSUSSC.Reg)&^(0xff)|value)
}
func (o *CTSU_Type) GetCTSUSSC_Reserved() uint16 {
	return volatile.LoadUint16(&o.CTSUSSC.Reg) & 0xff
}

// CTSU.CTSUSO0: CTSU Sensor Offset Register 0
func (o *CTSU_Type) SetCTSUSO0_CTSUSNUM(value uint16) {
	volatile.StoreUint16(&o.CTSUSO0.Reg, volatile.LoadUint16(&o.CTSUSO0.Reg)&^(0xfc00)|value<<10)
}
func (o *CTSU_Type) GetCTSUSO0_CTSUSNUM() uint16 {
	return (volatile.LoadUint16(&o.CTSUSO0.Reg) & 0xfc00) >> 10
}
func (o *CTSU_Type) SetCTSUSO0_CTSUSO(value uint16) {
	volatile.StoreUint16(&o.CTSUSO0.Reg, volatile.LoadUint16(&o.CTSUSO0.Reg)&^(0x3ff)|value)
}
func (o *CTSU_Type) GetCTSUSO0_CTSUSO() uint16 {
	return volatile.LoadUint16(&o.CTSUSO0.Reg) & 0x3ff
}

// CTSU.CTSUSO1: CTSU Sensor Offset Register 1
func (o *CTSU_Type) SetCTSUSO1_Reserved(value uint16) {
	volatile.StoreUint16(&o.CTSUSO1.Reg, volatile.LoadUint16(&o.CTSUSO1.Reg)&^(0x8000)|value<<15)
}
func (o *CTSU_Type) GetCTSUSO1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CTSUSO1.Reg) & 0x8000) >> 15
}
func (o *CTSU_Type) SetCTSUSO1_CTSUICOG(value uint16) {
	volatile.StoreUint16(&o.CTSUSO1.Reg, volatile.LoadUint16(&o.CTSUSO1.Reg)&^(0x6000)|value<<13)
}
func (o *CTSU_Type) GetCTSUSO1_CTSUICOG() uint16 {
	return (volatile.LoadUint16(&o.CTSUSO1.Reg) & 0x6000) >> 13
}
func (o *CTSU_Type) SetCTSUSO1_CTSUSDPA(value uint16) {
	volatile.StoreUint16(&o.CTSUSO1.Reg, volatile.LoadUint16(&o.CTSUSO1.Reg)&^(0x1f00)|value<<8)
}
func (o *CTSU_Type) GetCTSUSO1_CTSUSDPA() uint16 {
	return (volatile.LoadUint16(&o.CTSUSO1.Reg) & 0x1f00) >> 8
}
func (o *CTSU_Type) SetCTSUSO1_CTSURICOA(value uint16) {
	volatile.StoreUint16(&o.CTSUSO1.Reg, volatile.LoadUint16(&o.CTSUSO1.Reg)&^(0xff)|value)
}
func (o *CTSU_Type) GetCTSUSO1_CTSURICOA() uint16 {
	return volatile.LoadUint16(&o.CTSUSO1.Reg) & 0xff
}

// CTSU.CTSUSC: CTSU Sensor Counter
func (o *CTSU_Type) SetCTSUSC(value uint16) {
	volatile.StoreUint16(&o.CTSUSC.Reg, value)
}
func (o *CTSU_Type) GetCTSUSC() uint16 {
	return volatile.LoadUint16(&o.CTSUSC.Reg)
}

// CTSU.CTSURC: CTSU Reference Counter
func (o *CTSU_Type) SetCTSURC(value uint16) {
	volatile.StoreUint16(&o.CTSURC.Reg, value)
}
func (o *CTSU_Type) GetCTSURC() uint16 {
	return volatile.LoadUint16(&o.CTSURC.Reg)
}

// CTSU.CTSUERRS: CTSU Error Status Register
func (o *CTSU_Type) SetCTSUERRS_CTSUICOMP(value uint16) {
	volatile.StoreUint16(&o.CTSUERRS.Reg, volatile.LoadUint16(&o.CTSUERRS.Reg)&^(0x8000)|value<<15)
}
func (o *CTSU_Type) GetCTSUERRS_CTSUICOMP() uint16 {
	return (volatile.LoadUint16(&o.CTSUERRS.Reg) & 0x8000) >> 15
}
func (o *CTSU_Type) SetCTSUERRS_Reserved(value uint16) {
	volatile.StoreUint16(&o.CTSUERRS.Reg, volatile.LoadUint16(&o.CTSUERRS.Reg)&^(0x7fff)|value)
}
func (o *CTSU_Type) GetCTSUERRS_Reserved() uint16 {
	return volatile.LoadUint16(&o.CTSUERRS.Reg) & 0x7fff
}

// 14bit A/D Converter
type ADC140_Type struct {
	ADCSR      volatile.Register16 // 0x0
	_          [2]byte
	ADANSA0    volatile.Register16 // 0x4
	ADANSA1    volatile.Register16 // 0x6
	ADADS0     volatile.Register16 // 0x8
	ADADS1     volatile.Register16 // 0xA
	ADADC      volatile.Register8  // 0xC
	_          byte
	ADCER      volatile.Register16 // 0xE
	ADSTRGR    volatile.Register16 // 0x10
	ADEXICR    volatile.Register16 // 0x12
	ADANSB0    volatile.Register16 // 0x14
	ADANSB1    volatile.Register16 // 0x16
	ADDBLDR    volatile.Register16 // 0x18
	ADTSDR     volatile.Register16 // 0x1A
	ADOCDR     volatile.Register16 // 0x1C
	ADRD       volatile.Register16 // 0x1E
	ADDR0      volatile.Register16 // 0x20
	ADDR1      volatile.Register16 // 0x22
	ADDR2      volatile.Register16 // 0x24
	ADDR3      volatile.Register16 // 0x26
	ADDR4      volatile.Register16 // 0x28
	ADDR5      volatile.Register16 // 0x2A
	ADDR6      volatile.Register16 // 0x2C
	ADDR7      volatile.Register16 // 0x2E
	ADDR8      volatile.Register16 // 0x30
	ADDR9      volatile.Register16 // 0x32
	ADDR10     volatile.Register16 // 0x34
	ADDR11     volatile.Register16 // 0x36
	ADDR12     volatile.Register16 // 0x38
	ADDR13     volatile.Register16 // 0x3A
	ADDR14     volatile.Register16 // 0x3C
	ADDR15     volatile.Register16 // 0x3E
	ADDR16     volatile.Register16 // 0x40
	ADDR17     volatile.Register16 // 0x42
	ADDR18     volatile.Register16 // 0x44
	ADDR19     volatile.Register16 // 0x46
	ADDR20     volatile.Register16 // 0x48
	ADDR21     volatile.Register16 // 0x4A
	ADDR22     volatile.Register16 // 0x4C
	ADDR23     volatile.Register16 // 0x4E
	ADDR24     volatile.Register16 // 0x50
	ADDR25     volatile.Register16 // 0x52
	ADDR26     volatile.Register16 // 0x54
	ADDR27     volatile.Register16 // 0x56
	_          [34]byte
	ADDISCR    volatile.Register8 // 0x7A
	_          [5]byte
	ADGSPCR    volatile.Register16 // 0x80
	_          [2]byte
	ADDBLDRA   volatile.Register16 // 0x84
	ADDBLDRB   volatile.Register16 // 0x86
	_          [2]byte
	ADHVREFCNT volatile.Register8 // 0x8A
	_          byte
	ADWINMON   volatile.Register8 // 0x8C
	_          [3]byte
	ADCMPCR    volatile.Register16 // 0x90
	ADCMPANSER volatile.Register8  // 0x92
	ADCMPLER   volatile.Register8  // 0x93
	ADCMPANSR0 volatile.Register16 // 0x94
	ADCMPANSR1 volatile.Register16 // 0x96
	ADCMPLR0   volatile.Register16 // 0x98
	ADCMPLR1   volatile.Register16 // 0x9A
	ADCMPDR0   volatile.Register16 // 0x9C
	ADCMPDR1   volatile.Register16 // 0x9E
	ADCMPSR0   volatile.Register16 // 0xA0
	ADCMPSR1   volatile.Register16 // 0xA2
	ADCMPSER   volatile.Register8  // 0xA4
	_          byte
	ADCMPBNSR  volatile.Register8 // 0xA6
	_          byte
	ADWINLLB   volatile.Register16 // 0xA8
	ADWINULB   volatile.Register16 // 0xAA
	ADCMPBSR   volatile.Register8  // 0xAC
	_          [48]byte
	ADSSTRL    volatile.Register8 // 0xDD
	ADSSTRT    volatile.Register8 // 0xDE
	ADSSTRO    volatile.Register8 // 0xDF
	ADSSTR0    volatile.Register8 // 0xE0
	ADSSTR1    volatile.Register8 // 0xE1
	ADSSTR2    volatile.Register8 // 0xE2
	ADSSTR3    volatile.Register8 // 0xE3
	ADSSTR4    volatile.Register8 // 0xE4
	ADSSTR5    volatile.Register8 // 0xE5
	ADSSTR6    volatile.Register8 // 0xE6
	ADSSTR7    volatile.Register8 // 0xE7
	ADSSTR8    volatile.Register8 // 0xE8
	ADSSTR9    volatile.Register8 // 0xE9
	ADSSTR10   volatile.Register8 // 0xEA
	ADSSTR11   volatile.Register8 // 0xEB
	ADSSTR12   volatile.Register8 // 0xEC
	ADSSTR13   volatile.Register8 // 0xED
	ADSSTR14   volatile.Register8 // 0xEE
	ADSSTR15   volatile.Register8 // 0xEF
}

// ADC140.ADCSR: A/D Control Register
func (o *ADC140_Type) SetADCSR_ADST(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC140_Type) GetADCSR_ADST() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x8000) >> 15
}
func (o *ADC140_Type) SetADCSR_ADCS(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x6000)|value<<13)
}
func (o *ADC140_Type) GetADCSR_ADCS() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x6000) >> 13
}
func (o *ADC140_Type) SetADCSR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x1800)|value<<11)
}
func (o *ADC140_Type) GetADCSR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x1800) >> 11
}
func (o *ADC140_Type) SetADCSR_ADHSC(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADCSR_ADHSC() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADCSR_TRGE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADCSR_TRGE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADCSR_EXTRG(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADCSR_EXTRG() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADCSR_DBLE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADCSR_DBLE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADCSR_GBADIE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADCSR_GBADIE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADCSR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADCSR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADCSR_DBLANS(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x1f)|value)
}
func (o *ADC140_Type) GetADCSR_DBLANS() uint16 {
	return volatile.LoadUint16(&o.ADCSR.Reg) & 0x1f
}

// ADC140.ADANSA0: A/D Channel Select Register A0
func (o *ADC140_Type) SetADANSA0_ANSA015(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC140_Type) GetADANSA0_ANSA015() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x8000) >> 15
}
func (o *ADC140_Type) SetADANSA0_ANSA014(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x4000)|value<<14)
}
func (o *ADC140_Type) GetADANSA0_ANSA014() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x4000) >> 14
}
func (o *ADC140_Type) SetADANSA0_ANSA013(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC140_Type) GetADANSA0_ANSA013() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x2000) >> 13
}
func (o *ADC140_Type) SetADANSA0_ANSA012(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC140_Type) GetADANSA0_ANSA012() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x1000) >> 12
}
func (o *ADC140_Type) SetADANSA0_ANSA011(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADANSA0_ANSA011() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADANSA0_ANSA010(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADANSA0_ANSA010() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADANSA0_ANSA09(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADANSA0_ANSA09() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADANSA0_ANSA08(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADANSA0_ANSA08() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADANSA0_ANSA07(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADANSA0_ANSA07() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADANSA0_ANSA06(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADANSA0_ANSA06() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADANSA0_ANSA05(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADANSA0_ANSA05() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADANSA0_ANSA04(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADANSA0_ANSA04() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADANSA0_ANSA03(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x8)|value<<3)
}
func (o *ADC140_Type) GetADANSA0_ANSA03() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x8) >> 3
}
func (o *ADC140_Type) SetADANSA0_ANSA02(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x4)|value<<2)
}
func (o *ADC140_Type) GetADANSA0_ANSA02() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x4) >> 2
}
func (o *ADC140_Type) SetADANSA0_ANSA01(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADANSA0_ANSA01() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADANSA0_ANSA00(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADANSA0_ANSA00() uint16 {
	return volatile.LoadUint16(&o.ADANSA0.Reg) & 0x1
}

// ADC140.ADANSA1: A/D Channel Select Register A1
func (o *ADC140_Type) SetADANSA1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0xf000)|value<<12)
}
func (o *ADC140_Type) GetADANSA1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0xf000) >> 12
}
func (o *ADC140_Type) SetADANSA1_ANSA27(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADANSA1_ANSA27() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADANSA1_ANSA26(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADANSA1_ANSA26() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADANSA1_ANSA25(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADANSA1_ANSA25() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADANSA1_ANSA24(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADANSA1_ANSA24() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADANSA1_ANSA23(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADANSA1_ANSA23() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADANSA1_ANSA22(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADANSA1_ANSA22() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADANSA1_ANSA21(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADANSA1_ANSA21() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADANSA1_ANSA20(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADANSA1_ANSA20() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADANSA1_ANSA19(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x8)|value<<3)
}
func (o *ADC140_Type) GetADANSA1_ANSA19() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x8) >> 3
}
func (o *ADC140_Type) SetADANSA1_ANSA18(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x4)|value<<2)
}
func (o *ADC140_Type) GetADANSA1_ANSA18() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x4) >> 2
}
func (o *ADC140_Type) SetADANSA1_ANSA17(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADANSA1_ANSA17() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADANSA1_ANSA16(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADANSA1_ANSA16() uint16 {
	return volatile.LoadUint16(&o.ADANSA1.Reg) & 0x1
}

// ADC140.ADADS0: A/D-Converted Value Addition/Average Channel Select Register 0
func (o *ADC140_Type) SetADADS0_ADS15(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC140_Type) GetADADS0_ADS15() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x8000) >> 15
}
func (o *ADC140_Type) SetADADS0_ADS14(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x4000)|value<<14)
}
func (o *ADC140_Type) GetADADS0_ADS14() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x4000) >> 14
}
func (o *ADC140_Type) SetADADS0_ADS13(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC140_Type) GetADADS0_ADS13() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x2000) >> 13
}
func (o *ADC140_Type) SetADADS0_ADS12(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC140_Type) GetADADS0_ADS12() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x1000) >> 12
}
func (o *ADC140_Type) SetADADS0_ADS11(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADADS0_ADS11() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADADS0_ADS10(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADADS0_ADS10() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADADS0_ADS09(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADADS0_ADS09() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADADS0_ADS08(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADADS0_ADS08() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADADS0_ADS07(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADADS0_ADS07() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADADS0_ADS06(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADADS0_ADS06() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADADS0_ADS05(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADADS0_ADS05() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADADS0_ADS04(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADADS0_ADS04() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADADS0_ADS03(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x8)|value<<3)
}
func (o *ADC140_Type) GetADADS0_ADS03() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x8) >> 3
}
func (o *ADC140_Type) SetADADS0_ADS02(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x4)|value<<2)
}
func (o *ADC140_Type) GetADADS0_ADS02() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x4) >> 2
}
func (o *ADC140_Type) SetADADS0_ADS01(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADADS0_ADS01() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADADS0_ADS00(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADADS0_ADS00() uint16 {
	return volatile.LoadUint16(&o.ADADS0.Reg) & 0x1
}

// ADC140.ADADS1: A/D-Converted Value Addition/Average Channel Select Register 1
func (o *ADC140_Type) SetADADS1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0xf000)|value<<12)
}
func (o *ADC140_Type) GetADADS1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0xf000) >> 12
}
func (o *ADC140_Type) SetADADS1_ADS27(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADADS1_ADS27() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADADS1_ADS26(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADADS1_ADS26() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADADS1_ADS25(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADADS1_ADS25() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADADS1_ADS24(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADADS1_ADS24() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADADS1_ADS23(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADADS1_ADS23() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADADS1_ADS22(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADADS1_ADS22() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADADS1_ADS21(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADADS1_ADS21() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADADS1_ADS20(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADADS1_ADS20() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADADS1_ADS19(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x8)|value<<3)
}
func (o *ADC140_Type) GetADADS1_ADS19() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x8) >> 3
}
func (o *ADC140_Type) SetADADS1_ADS18(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x4)|value<<2)
}
func (o *ADC140_Type) GetADADS1_ADS18() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x4) >> 2
}
func (o *ADC140_Type) SetADADS1_ADS17(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADADS1_ADS17() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADADS1_ADS16(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADADS1_ADS16() uint16 {
	return volatile.LoadUint16(&o.ADADS1.Reg) & 0x1
}

// ADC140.ADADC: A/D-Converted Value Addition/Average Count Select Register
func (o *ADC140_Type) SetADADC_AVEE(value uint8) {
	volatile.StoreUint8(&o.ADADC.Reg, volatile.LoadUint8(&o.ADADC.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADADC_AVEE() uint8 {
	return (volatile.LoadUint8(&o.ADADC.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADADC_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADADC.Reg, volatile.LoadUint8(&o.ADADC.Reg)&^(0x78)|value<<3)
}
func (o *ADC140_Type) GetADADC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADADC.Reg) & 0x78) >> 3
}
func (o *ADC140_Type) SetADADC_ADC(value uint8) {
	volatile.StoreUint8(&o.ADADC.Reg, volatile.LoadUint8(&o.ADADC.Reg)&^(0x7)|value)
}
func (o *ADC140_Type) GetADADC_ADC() uint8 {
	return volatile.LoadUint8(&o.ADADC.Reg) & 0x7
}

// ADC140.ADCER: A/D Control Extended Register
func (o *ADC140_Type) SetADCER_ADRFMT(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x8000)|value<<15)
}
func (o *ADC140_Type) GetADCER_ADRFMT() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x8000) >> 15
}
func (o *ADC140_Type) SetADCER_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x7000)|value<<12)
}
func (o *ADC140_Type) GetADCER_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x7000) >> 12
}
func (o *ADC140_Type) SetADCER_DIAGM(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADCER_DIAGM() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADCER_DIAGLD(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADCER_DIAGLD() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADCER_DIAGVAL(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x300)|value<<8)
}
func (o *ADC140_Type) GetADCER_DIAGVAL() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x300) >> 8
}
func (o *ADC140_Type) SetADCER_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0xc0)|value<<6)
}
func (o *ADC140_Type) GetADCER_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0xc0) >> 6
}
func (o *ADC140_Type) SetADCER_ACE(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADCER_ACE() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADCER_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADCER_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADCER_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x8)|value<<3)
}
func (o *ADC140_Type) GetADCER_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x8) >> 3
}
func (o *ADC140_Type) SetADCER_ADPRC(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x6)|value<<1)
}
func (o *ADC140_Type) GetADCER_ADPRC() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x6) >> 1
}
func (o *ADC140_Type) SetADCER_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADCER_Reserved() uint16 {
	return volatile.LoadUint16(&o.ADCER.Reg) & 0x1
}

// ADC140.ADSTRGR: A/D Conversion Start Trigger Select Register
func (o *ADC140_Type) SetADSTRGR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0xc000)|value<<14)
}
func (o *ADC140_Type) GetADSTRGR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADSTRGR.Reg) & 0xc000) >> 14
}
func (o *ADC140_Type) SetADSTRGR_TRSA(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0x3f00)|value<<8)
}
func (o *ADC140_Type) GetADSTRGR_TRSA() uint16 {
	return (volatile.LoadUint16(&o.ADSTRGR.Reg) & 0x3f00) >> 8
}
func (o *ADC140_Type) SetADSTRGR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0xc0)|value<<6)
}
func (o *ADC140_Type) GetADSTRGR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADSTRGR.Reg) & 0xc0) >> 6
}
func (o *ADC140_Type) SetADSTRGR_TRSB(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0x3f)|value)
}
func (o *ADC140_Type) GetADSTRGR_TRSB() uint16 {
	return volatile.LoadUint16(&o.ADSTRGR.Reg) & 0x3f
}

// ADC140.ADEXICR: A/D Conversion Extended Input Control Register
func (o *ADC140_Type) SetADEXICR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC140_Type) GetADEXICR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x8000) >> 15
}
func (o *ADC140_Type) SetADEXICR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x4000)|value<<14)
}
func (o *ADC140_Type) GetADEXICR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x4000) >> 14
}
func (o *ADC140_Type) SetADEXICR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x1000)|value<<12)
}
func (o *ADC140_Type) GetADEXICR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x1000) >> 12
}
func (o *ADC140_Type) SetADEXICR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADEXICR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADEXICR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADEXICR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADEXICR_OCSA(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADEXICR_OCSA() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADEXICR_TSSA(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADEXICR_TSSA() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADEXICR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0xfc)|value<<2)
}
func (o *ADC140_Type) GetADEXICR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0xfc) >> 2
}
func (o *ADC140_Type) SetADEXICR_OCSAD(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADEXICR_OCSAD() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADEXICR_TSSAD(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADEXICR_TSSAD() uint16 {
	return volatile.LoadUint16(&o.ADEXICR.Reg) & 0x1
}

// ADC140.ADANSB0: A/D Channel Select Register B0
func (o *ADC140_Type) SetADANSB0_ANSB15(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC140_Type) GetADANSB0_ANSB15() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x8000) >> 15
}
func (o *ADC140_Type) SetADANSB0_ANSB14(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x4000)|value<<14)
}
func (o *ADC140_Type) GetADANSB0_ANSB14() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x4000) >> 14
}
func (o *ADC140_Type) SetADANSB0_ANSB13(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC140_Type) GetADANSB0_ANSB13() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x2000) >> 13
}
func (o *ADC140_Type) SetADANSB0_ANSB12(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC140_Type) GetADANSB0_ANSB12() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x1000) >> 12
}
func (o *ADC140_Type) SetADANSB0_ANSB11(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADANSB0_ANSB11() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADANSB0_ANSB10(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADANSB0_ANSB10() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADANSB0_ANSB09(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADANSB0_ANSB09() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADANSB0_ANSB08(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADANSB0_ANSB08() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADANSB0_ANSB07(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADANSB0_ANSB07() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADANSB0_ANSB06(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADANSB0_ANSB06() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADANSB0_ANSB05(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADANSB0_ANSB05() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADANSB0_ANSB04(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADANSB0_ANSB04() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADANSB0_ANSB03(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x8)|value<<3)
}
func (o *ADC140_Type) GetADANSB0_ANSB03() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x8) >> 3
}
func (o *ADC140_Type) SetADANSB0_ANSB02(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x4)|value<<2)
}
func (o *ADC140_Type) GetADANSB0_ANSB02() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x4) >> 2
}
func (o *ADC140_Type) SetADANSB0_ANSB01(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADANSB0_ANSB01() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADANSB0_ANSB00(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADANSB0_ANSB00() uint16 {
	return volatile.LoadUint16(&o.ADANSB0.Reg) & 0x1
}

// ADC140.ADANSB1: A/D Channel Select Register B1
func (o *ADC140_Type) SetADANSB1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0xf000)|value<<12)
}
func (o *ADC140_Type) GetADANSB1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0xf000) >> 12
}
func (o *ADC140_Type) SetADANSB1_ANSB27(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADANSB1_ANSB27() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADANSB1_ANSB26(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADANSB1_ANSB26() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADANSB1_ANSB25(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADANSB1_ANSB25() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADANSB1_ANSB24(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADANSB1_ANSB24() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADANSB1_ANSB23(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADANSB1_ANSB23() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADANSB1_ANSB22(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADANSB1_ANSB22() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADANSB1_ANSB21(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADANSB1_ANSB21() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADANSB1_ANSB20(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADANSB1_ANSB20() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADANSB1_ANSB19(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x8)|value<<3)
}
func (o *ADC140_Type) GetADANSB1_ANSB19() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x8) >> 3
}
func (o *ADC140_Type) SetADANSB1_ANSB18(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x4)|value<<2)
}
func (o *ADC140_Type) GetADANSB1_ANSB18() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x4) >> 2
}
func (o *ADC140_Type) SetADANSB1_ANSB17(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADANSB1_ANSB17() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADANSB1_ANSB16(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADANSB1_ANSB16() uint16 {
	return volatile.LoadUint16(&o.ADANSB1.Reg) & 0x1
}

// ADC140.ADDBLDR: A/D Data Duplication Register
func (o *ADC140_Type) SetADDBLDR(value uint16) {
	volatile.StoreUint16(&o.ADDBLDR.Reg, value)
}
func (o *ADC140_Type) GetADDBLDR() uint16 {
	return volatile.LoadUint16(&o.ADDBLDR.Reg)
}

// ADC140.ADTSDR: A/D Temperature Sensor Data Register
func (o *ADC140_Type) SetADTSDR(value uint16) {
	volatile.StoreUint16(&o.ADTSDR.Reg, value)
}
func (o *ADC140_Type) GetADTSDR() uint16 {
	return volatile.LoadUint16(&o.ADTSDR.Reg)
}

// ADC140.ADOCDR: A/D Internal Reference Voltage Data Register
func (o *ADC140_Type) SetADOCDR(value uint16) {
	volatile.StoreUint16(&o.ADOCDR.Reg, value)
}
func (o *ADC140_Type) GetADOCDR() uint16 {
	return volatile.LoadUint16(&o.ADOCDR.Reg)
}

// ADC140.ADRD: A/D Self-Diagnosis Data Register
func (o *ADC140_Type) SetADRD_DIAGST(value uint16) {
	volatile.StoreUint16(&o.ADRD.Reg, volatile.LoadUint16(&o.ADRD.Reg)&^(0xc000)|value<<14)
}
func (o *ADC140_Type) GetADRD_DIAGST() uint16 {
	return (volatile.LoadUint16(&o.ADRD.Reg) & 0xc000) >> 14
}
func (o *ADC140_Type) SetADRD_AD(value uint16) {
	volatile.StoreUint16(&o.ADRD.Reg, volatile.LoadUint16(&o.ADRD.Reg)&^(0x3fff)|value)
}
func (o *ADC140_Type) GetADRD_AD() uint16 {
	return volatile.LoadUint16(&o.ADRD.Reg) & 0x3fff
}

// ADC140.ADDR0: A/D Data Register %s
func (o *ADC140_Type) SetADDR0(value uint16) {
	volatile.StoreUint16(&o.ADDR0.Reg, value)
}
func (o *ADC140_Type) GetADDR0() uint16 {
	return volatile.LoadUint16(&o.ADDR0.Reg)
}

// ADC140.ADDR1: A/D Data Register %s
func (o *ADC140_Type) SetADDR1(value uint16) {
	volatile.StoreUint16(&o.ADDR1.Reg, value)
}
func (o *ADC140_Type) GetADDR1() uint16 {
	return volatile.LoadUint16(&o.ADDR1.Reg)
}

// ADC140.ADDR2: A/D Data Register %s
func (o *ADC140_Type) SetADDR2(value uint16) {
	volatile.StoreUint16(&o.ADDR2.Reg, value)
}
func (o *ADC140_Type) GetADDR2() uint16 {
	return volatile.LoadUint16(&o.ADDR2.Reg)
}

// ADC140.ADDR3: A/D Data Register %s
func (o *ADC140_Type) SetADDR3(value uint16) {
	volatile.StoreUint16(&o.ADDR3.Reg, value)
}
func (o *ADC140_Type) GetADDR3() uint16 {
	return volatile.LoadUint16(&o.ADDR3.Reg)
}

// ADC140.ADDR4: A/D Data Register %s
func (o *ADC140_Type) SetADDR4(value uint16) {
	volatile.StoreUint16(&o.ADDR4.Reg, value)
}
func (o *ADC140_Type) GetADDR4() uint16 {
	return volatile.LoadUint16(&o.ADDR4.Reg)
}

// ADC140.ADDR5: A/D Data Register %s
func (o *ADC140_Type) SetADDR5(value uint16) {
	volatile.StoreUint16(&o.ADDR5.Reg, value)
}
func (o *ADC140_Type) GetADDR5() uint16 {
	return volatile.LoadUint16(&o.ADDR5.Reg)
}

// ADC140.ADDR6: A/D Data Register %s
func (o *ADC140_Type) SetADDR6(value uint16) {
	volatile.StoreUint16(&o.ADDR6.Reg, value)
}
func (o *ADC140_Type) GetADDR6() uint16 {
	return volatile.LoadUint16(&o.ADDR6.Reg)
}

// ADC140.ADDR7: A/D Data Register %s
func (o *ADC140_Type) SetADDR7(value uint16) {
	volatile.StoreUint16(&o.ADDR7.Reg, value)
}
func (o *ADC140_Type) GetADDR7() uint16 {
	return volatile.LoadUint16(&o.ADDR7.Reg)
}

// ADC140.ADDR8: A/D Data Register %s
func (o *ADC140_Type) SetADDR8(value uint16) {
	volatile.StoreUint16(&o.ADDR8.Reg, value)
}
func (o *ADC140_Type) GetADDR8() uint16 {
	return volatile.LoadUint16(&o.ADDR8.Reg)
}

// ADC140.ADDR9: A/D Data Register %s
func (o *ADC140_Type) SetADDR9(value uint16) {
	volatile.StoreUint16(&o.ADDR9.Reg, value)
}
func (o *ADC140_Type) GetADDR9() uint16 {
	return volatile.LoadUint16(&o.ADDR9.Reg)
}

// ADC140.ADDR10: A/D Data Register %s
func (o *ADC140_Type) SetADDR10(value uint16) {
	volatile.StoreUint16(&o.ADDR10.Reg, value)
}
func (o *ADC140_Type) GetADDR10() uint16 {
	return volatile.LoadUint16(&o.ADDR10.Reg)
}

// ADC140.ADDR11: A/D Data Register %s
func (o *ADC140_Type) SetADDR11(value uint16) {
	volatile.StoreUint16(&o.ADDR11.Reg, value)
}
func (o *ADC140_Type) GetADDR11() uint16 {
	return volatile.LoadUint16(&o.ADDR11.Reg)
}

// ADC140.ADDR12: A/D Data Register %s
func (o *ADC140_Type) SetADDR12(value uint16) {
	volatile.StoreUint16(&o.ADDR12.Reg, value)
}
func (o *ADC140_Type) GetADDR12() uint16 {
	return volatile.LoadUint16(&o.ADDR12.Reg)
}

// ADC140.ADDR13: A/D Data Register %s
func (o *ADC140_Type) SetADDR13(value uint16) {
	volatile.StoreUint16(&o.ADDR13.Reg, value)
}
func (o *ADC140_Type) GetADDR13() uint16 {
	return volatile.LoadUint16(&o.ADDR13.Reg)
}

// ADC140.ADDR14: A/D Data Register %s
func (o *ADC140_Type) SetADDR14(value uint16) {
	volatile.StoreUint16(&o.ADDR14.Reg, value)
}
func (o *ADC140_Type) GetADDR14() uint16 {
	return volatile.LoadUint16(&o.ADDR14.Reg)
}

// ADC140.ADDR15: A/D Data Register %s
func (o *ADC140_Type) SetADDR15(value uint16) {
	volatile.StoreUint16(&o.ADDR15.Reg, value)
}
func (o *ADC140_Type) GetADDR15() uint16 {
	return volatile.LoadUint16(&o.ADDR15.Reg)
}

// ADC140.ADDR16: A/D Data Register %s
func (o *ADC140_Type) SetADDR16(value uint16) {
	volatile.StoreUint16(&o.ADDR16.Reg, value)
}
func (o *ADC140_Type) GetADDR16() uint16 {
	return volatile.LoadUint16(&o.ADDR16.Reg)
}

// ADC140.ADDR17: A/D Data Register %s
func (o *ADC140_Type) SetADDR17(value uint16) {
	volatile.StoreUint16(&o.ADDR17.Reg, value)
}
func (o *ADC140_Type) GetADDR17() uint16 {
	return volatile.LoadUint16(&o.ADDR17.Reg)
}

// ADC140.ADDR18: A/D Data Register %s
func (o *ADC140_Type) SetADDR18(value uint16) {
	volatile.StoreUint16(&o.ADDR18.Reg, value)
}
func (o *ADC140_Type) GetADDR18() uint16 {
	return volatile.LoadUint16(&o.ADDR18.Reg)
}

// ADC140.ADDR19: A/D Data Register %s
func (o *ADC140_Type) SetADDR19(value uint16) {
	volatile.StoreUint16(&o.ADDR19.Reg, value)
}
func (o *ADC140_Type) GetADDR19() uint16 {
	return volatile.LoadUint16(&o.ADDR19.Reg)
}

// ADC140.ADDR20: A/D Data Register %s
func (o *ADC140_Type) SetADDR20(value uint16) {
	volatile.StoreUint16(&o.ADDR20.Reg, value)
}
func (o *ADC140_Type) GetADDR20() uint16 {
	return volatile.LoadUint16(&o.ADDR20.Reg)
}

// ADC140.ADDR21: A/D Data Register %s
func (o *ADC140_Type) SetADDR21(value uint16) {
	volatile.StoreUint16(&o.ADDR21.Reg, value)
}
func (o *ADC140_Type) GetADDR21() uint16 {
	return volatile.LoadUint16(&o.ADDR21.Reg)
}

// ADC140.ADDR22: A/D Data Register %s
func (o *ADC140_Type) SetADDR22(value uint16) {
	volatile.StoreUint16(&o.ADDR22.Reg, value)
}
func (o *ADC140_Type) GetADDR22() uint16 {
	return volatile.LoadUint16(&o.ADDR22.Reg)
}

// ADC140.ADDR23: A/D Data Register %s
func (o *ADC140_Type) SetADDR23(value uint16) {
	volatile.StoreUint16(&o.ADDR23.Reg, value)
}
func (o *ADC140_Type) GetADDR23() uint16 {
	return volatile.LoadUint16(&o.ADDR23.Reg)
}

// ADC140.ADDR24: A/D Data Register %s
func (o *ADC140_Type) SetADDR24(value uint16) {
	volatile.StoreUint16(&o.ADDR24.Reg, value)
}
func (o *ADC140_Type) GetADDR24() uint16 {
	return volatile.LoadUint16(&o.ADDR24.Reg)
}

// ADC140.ADDR25: A/D Data Register %s
func (o *ADC140_Type) SetADDR25(value uint16) {
	volatile.StoreUint16(&o.ADDR25.Reg, value)
}
func (o *ADC140_Type) GetADDR25() uint16 {
	return volatile.LoadUint16(&o.ADDR25.Reg)
}

// ADC140.ADDR26: A/D Data Register %s
func (o *ADC140_Type) SetADDR26(value uint16) {
	volatile.StoreUint16(&o.ADDR26.Reg, value)
}
func (o *ADC140_Type) GetADDR26() uint16 {
	return volatile.LoadUint16(&o.ADDR26.Reg)
}

// ADC140.ADDR27: A/D Data Register %s
func (o *ADC140_Type) SetADDR27(value uint16) {
	volatile.StoreUint16(&o.ADDR27.Reg, value)
}
func (o *ADC140_Type) GetADDR27() uint16 {
	return volatile.LoadUint16(&o.ADDR27.Reg)
}

// ADC140.ADDISCR: A/D Disconnection Detection Control Register
func (o *ADC140_Type) SetADDISCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0xe0)|value<<5)
}
func (o *ADC140_Type) GetADDISCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADDISCR.Reg) & 0xe0) >> 5
}
func (o *ADC140_Type) SetADDISCR_ADNDIS(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0x1f)|value)
}
func (o *ADC140_Type) GetADDISCR_ADNDIS() uint8 {
	return volatile.LoadUint8(&o.ADDISCR.Reg) & 0x1f
}

// ADC140.ADGSPCR: A/D Group Scan Priority Control Register
func (o *ADC140_Type) SetADGSPCR_GBRP(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC140_Type) GetADGSPCR_GBRP() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x8000) >> 15
}
func (o *ADC140_Type) SetADGSPCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x7e00)|value<<9)
}
func (o *ADC140_Type) GetADGSPCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x7e00) >> 9
}
func (o *ADC140_Type) SetADGSPCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADGSPCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADGSPCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0xfc)|value<<2)
}
func (o *ADC140_Type) GetADGSPCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0xfc) >> 2
}
func (o *ADC140_Type) SetADGSPCR_GBRSCN(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADGSPCR_GBRSCN() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADGSPCR_PGS(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADGSPCR_PGS() uint16 {
	return volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x1
}

// ADC140.ADDBLDRA: A/D Data Duplexing Register A
func (o *ADC140_Type) SetADDBLDRA(value uint16) {
	volatile.StoreUint16(&o.ADDBLDRA.Reg, value)
}
func (o *ADC140_Type) GetADDBLDRA() uint16 {
	return volatile.LoadUint16(&o.ADDBLDRA.Reg)
}

// ADC140.ADDBLDRB: A/D Data Duplexing Register B
func (o *ADC140_Type) SetADDBLDRB(value uint16) {
	volatile.StoreUint16(&o.ADDBLDRB.Reg, value)
}
func (o *ADC140_Type) GetADDBLDRB() uint16 {
	return volatile.LoadUint16(&o.ADDBLDRB.Reg)
}

// ADC140.ADHVREFCNT: A/D High-Potential/Low-Potential Reference Voltage Control Register
func (o *ADC140_Type) SetADHVREFCNT_ADSLP(value uint8) {
	volatile.StoreUint8(&o.ADHVREFCNT.Reg, volatile.LoadUint8(&o.ADHVREFCNT.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADHVREFCNT_ADSLP() uint8 {
	return (volatile.LoadUint8(&o.ADHVREFCNT.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADHVREFCNT_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADHVREFCNT.Reg, volatile.LoadUint8(&o.ADHVREFCNT.Reg)&^(0x60)|value<<5)
}
func (o *ADC140_Type) GetADHVREFCNT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADHVREFCNT.Reg) & 0x60) >> 5
}
func (o *ADC140_Type) SetADHVREFCNT_LVSEL(value uint8) {
	volatile.StoreUint8(&o.ADHVREFCNT.Reg, volatile.LoadUint8(&o.ADHVREFCNT.Reg)&^(0x1c)|value<<2)
}
func (o *ADC140_Type) GetADHVREFCNT_LVSEL() uint8 {
	return (volatile.LoadUint8(&o.ADHVREFCNT.Reg) & 0x1c) >> 2
}
func (o *ADC140_Type) SetADHVREFCNT_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADHVREFCNT.Reg, volatile.LoadUint8(&o.ADHVREFCNT.Reg)&^(0xc)|value<<2)
}
func (o *ADC140_Type) GetADHVREFCNT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADHVREFCNT.Reg) & 0xc) >> 2
}
func (o *ADC140_Type) SetADHVREFCNT_CMPAB(value uint8) {
	volatile.StoreUint8(&o.ADHVREFCNT.Reg, volatile.LoadUint8(&o.ADHVREFCNT.Reg)&^(0x3)|value)
}
func (o *ADC140_Type) GetADHVREFCNT_CMPAB() uint8 {
	return volatile.LoadUint8(&o.ADHVREFCNT.Reg) & 0x3
}

// ADC140.ADWINMON: A/D Compare Function Window A/B Status Monitor Register
func (o *ADC140_Type) SetADWINMON_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0xc0)|value<<6)
}
func (o *ADC140_Type) GetADWINMON_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0xc0) >> 6
}
func (o *ADC140_Type) SetADWINMON_MONCMPB(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADWINMON_MONCMPB() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADWINMON_MONCMPA(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADWINMON_MONCMPA() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADWINMON_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0xe)|value<<1)
}
func (o *ADC140_Type) GetADWINMON_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0xe) >> 1
}
func (o *ADC140_Type) SetADWINMON_MONCOMB(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADWINMON_MONCOMB() uint8 {
	return volatile.LoadUint8(&o.ADWINMON.Reg) & 0x1
}

// ADC140.ADCMPCR: A/D Compare Function Control Register
func (o *ADC140_Type) SetADCMPCR_CMPAIE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC140_Type) GetADCMPCR_CMPAIE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x8000) >> 15
}
func (o *ADC140_Type) SetADCMPCR_WCMPE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x4000)|value<<14)
}
func (o *ADC140_Type) GetADCMPCR_WCMPE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x4000) >> 14
}
func (o *ADC140_Type) SetADCMPCR_CMPBIE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x2000)|value<<13)
}
func (o *ADC140_Type) GetADCMPCR_CMPBIE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x2000) >> 13
}
func (o *ADC140_Type) SetADCMPCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x1000)|value<<12)
}
func (o *ADC140_Type) GetADCMPCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x1000) >> 12
}
func (o *ADC140_Type) SetADCMPCR_CMPAE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADCMPCR_CMPAE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADCMPCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADCMPCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADCMPCR_CMPBE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADCMPCR_CMPBE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADCMPCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x1fc)|value<<2)
}
func (o *ADC140_Type) GetADCMPCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x1fc) >> 2
}
func (o *ADC140_Type) SetADCMPCR_CMPAB(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x3)|value)
}
func (o *ADC140_Type) GetADCMPCR_CMPAB() uint16 {
	return volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x3
}

// ADC140.ADCMPANSER: A/D Compare Function Window A Extended Input Select Register
func (o *ADC140_Type) SetADCMPANSER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADCMPANSER.Reg, volatile.LoadUint8(&o.ADCMPANSER.Reg)&^(0xfc)|value<<2)
}
func (o *ADC140_Type) GetADCMPANSER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADCMPANSER.Reg) & 0xfc) >> 2
}
func (o *ADC140_Type) SetADCMPANSER_CMPOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPANSER.Reg, volatile.LoadUint8(&o.ADCMPANSER.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADCMPANSER_CMPOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPANSER.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADCMPANSER_CMPTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPANSER.Reg, volatile.LoadUint8(&o.ADCMPANSER.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADCMPANSER_CMPTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPANSER.Reg) & 0x1
}

// ADC140.ADCMPLER: A/D Compare Function Window A Extended Input Comparison Condition Setting Register
func (o *ADC140_Type) SetADCMPLER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADCMPLER.Reg, volatile.LoadUint8(&o.ADCMPLER.Reg)&^(0xfc)|value<<2)
}
func (o *ADC140_Type) GetADCMPLER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADCMPLER.Reg) & 0xfc) >> 2
}
func (o *ADC140_Type) SetADCMPLER_CMPLOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPLER.Reg, volatile.LoadUint8(&o.ADCMPLER.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADCMPLER_CMPLOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPLER.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADCMPLER_CMPLTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPLER.Reg, volatile.LoadUint8(&o.ADCMPLER.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADCMPLER_CMPLTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPLER.Reg) & 0x1
}

// ADC140.ADCMPANSR0: A/D Compare Function Window A Channel Select Register 0
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA15(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA15() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x8000) >> 15
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA14(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x4000)|value<<14)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA14() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x4000) >> 14
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA13(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA13() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x2000) >> 13
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA12(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA12() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x1000) >> 12
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA11(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA11() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA10(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA10() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA09(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA09() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA08(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA08() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA04(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA04() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x8) >> 3
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x4) >> 2
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADCMPANSR0_CMPCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADCMPANSR0_CMPCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x1
}

// ADC140.ADCMPANSR1: A/D Compare Function Window A Channel Select Register 1
func (o *ADC140_Type) SetADCMPANSR1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0xf000)|value<<12)
}
func (o *ADC140_Type) GetADCMPANSR1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0xf000) >> 12
}
func (o *ADC140_Type) SetADCMPANSR1_CMPCHA27(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADCMPANSR1_CMPCHA27() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADCMPANSR1_CMPCHA26(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADCMPANSR1_CMPCHA26() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADCMPANSR1_CMPCHA25(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADCMPANSR1_CMPCHA25() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADCMPANSR1_CMPCHA24(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADCMPANSR1_CMPCHA24() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADCMPANSR1_CMPCHA23(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADCMPANSR1_CMPCHA23() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADCMPANSR1_CMPCHA22(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADCMPANSR1_CMPCHA22() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADCMPANSR1_CMPCHA21(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADCMPANSR1_CMPCHA21() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADCMPANSR1_CMPCHA20(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADCMPANSR1_CMPCHA20() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADCMPANSR1_CMPCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC140_Type) GetADCMPANSR1_CMPCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x8) >> 3
}
func (o *ADC140_Type) SetADCMPANSR1_CMPCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC140_Type) GetADCMPANSR1_CMPCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x4) >> 2
}
func (o *ADC140_Type) SetADCMPANSR1_CMPCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADCMPANSR1_CMPCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADCMPANSR1_CMPCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADCMPANSR1_CMPCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x1
}

// ADC140.ADCMPLR0: A/D Compare Function Window A Comparison Condition Setting Register 0
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA15(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA15() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x8000) >> 15
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA14(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x4000)|value<<14)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA14() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x4000) >> 14
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA13(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA13() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x2000) >> 13
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA12(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA12() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x1000) >> 12
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA11(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA11() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA10(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA10() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA09(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA09() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA08(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA08() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA04(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA04() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x8) >> 3
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x4) >> 2
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADCMPLR0_CMPLCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADCMPLR0_CMPLCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x1
}

// ADC140.ADCMPLR1: A/D Compare Function Window A Comparison Condition Setting Register 1
func (o *ADC140_Type) SetADCMPLR1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0xf000)|value<<12)
}
func (o *ADC140_Type) GetADCMPLR1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0xf000) >> 12
}
func (o *ADC140_Type) SetADCMPLR1_CMPLCHA27(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADCMPLR1_CMPLCHA27() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADCMPLR1_CMPLCHA26(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADCMPLR1_CMPLCHA26() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADCMPLR1_CMPLCHA25(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADCMPLR1_CMPLCHA25() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADCMPLR1_CMPLCHA24(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADCMPLR1_CMPLCHA24() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADCMPLR1_CMPLCHA23(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADCMPLR1_CMPLCHA23() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADCMPLR1_CMPLCHA22(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADCMPLR1_CMPLCHA22() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADCMPLR1_CMPLCHA21(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADCMPLR1_CMPLCHA21() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADCMPLR1_CMPLCHA20(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADCMPLR1_CMPLCHA20() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADCMPLR1_CMPLCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC140_Type) GetADCMPLR1_CMPLCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x8) >> 3
}
func (o *ADC140_Type) SetADCMPLR1_CMPLCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC140_Type) GetADCMPLR1_CMPLCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x4) >> 2
}
func (o *ADC140_Type) SetADCMPLR1_CMPLCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADCMPLR1_CMPLCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADCMPLR1_CMPLCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADCMPLR1_CMPLCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x1
}

// ADC140.ADCMPDR0: A/D Compare Function Window A Lower-Side Level Setting Register
func (o *ADC140_Type) SetADCMPDR0(value uint16) {
	volatile.StoreUint16(&o.ADCMPDR0.Reg, value)
}
func (o *ADC140_Type) GetADCMPDR0() uint16 {
	return volatile.LoadUint16(&o.ADCMPDR0.Reg)
}

// ADC140.ADCMPDR1: A/D Compare Function Window A Upper-Side Level Setting Register
func (o *ADC140_Type) SetADCMPDR1(value uint16) {
	volatile.StoreUint16(&o.ADCMPDR1.Reg, value)
}
func (o *ADC140_Type) GetADCMPDR1() uint16 {
	return volatile.LoadUint16(&o.ADCMPDR1.Reg)
}

// ADC140.ADCMPSR0: A/D Compare Function Window A Channel Status Register 0
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA15(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA15() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x8000) >> 15
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA14(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x4000)|value<<14)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA14() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x4000) >> 14
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA13(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA13() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x2000) >> 13
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA12(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA12() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x1000) >> 12
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA11(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA11() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA10(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA10() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA09(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA09() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA08(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA08() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA04(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA04() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x8) >> 3
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x4) >> 2
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADCMPSR0_CMPSTCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADCMPSR0_CMPSTCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x1
}

// ADC140.ADCMPSR1: A/D Compare Function Window A Channel Status Register 1
func (o *ADC140_Type) SetADCMPSR1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0xf000)|value<<12)
}
func (o *ADC140_Type) GetADCMPSR1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0xf000) >> 12
}
func (o *ADC140_Type) SetADCMPSR1_CMPSTCHA27(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x800)|value<<11)
}
func (o *ADC140_Type) GetADCMPSR1_CMPSTCHA27() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x800) >> 11
}
func (o *ADC140_Type) SetADCMPSR1_CMPSTCHA26(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x400)|value<<10)
}
func (o *ADC140_Type) GetADCMPSR1_CMPSTCHA26() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x400) >> 10
}
func (o *ADC140_Type) SetADCMPSR1_CMPSTCHA25(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x200)|value<<9)
}
func (o *ADC140_Type) GetADCMPSR1_CMPSTCHA25() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x200) >> 9
}
func (o *ADC140_Type) SetADCMPSR1_CMPSTCHA24(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x100)|value<<8)
}
func (o *ADC140_Type) GetADCMPSR1_CMPSTCHA24() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x100) >> 8
}
func (o *ADC140_Type) SetADCMPSR1_CMPSTCHA23(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADCMPSR1_CMPSTCHA23() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADCMPSR1_CMPSTCHA22(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADCMPSR1_CMPSTCHA22() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADCMPSR1_CMPSTCHA21(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x20)|value<<5)
}
func (o *ADC140_Type) GetADCMPSR1_CMPSTCHA21() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x20) >> 5
}
func (o *ADC140_Type) SetADCMPSR1_CMPSTCHA20(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x10)|value<<4)
}
func (o *ADC140_Type) GetADCMPSR1_CMPSTCHA20() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x10) >> 4
}
func (o *ADC140_Type) SetADCMPSR1_CMPSTCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC140_Type) GetADCMPSR1_CMPSTCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x8) >> 3
}
func (o *ADC140_Type) SetADCMPSR1_CMPSTCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC140_Type) GetADCMPSR1_CMPSTCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x4) >> 2
}
func (o *ADC140_Type) SetADCMPSR1_CMPSTCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADCMPSR1_CMPSTCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADCMPSR1_CMPSTCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADCMPSR1_CMPSTCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x1
}

// ADC140.ADCMPSER: A/D Compare Function Window A Extended Input Channel Status Register
func (o *ADC140_Type) SetADCMPSER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADCMPSER.Reg, volatile.LoadUint8(&o.ADCMPSER.Reg)&^(0xfc)|value<<2)
}
func (o *ADC140_Type) GetADCMPSER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADCMPSER.Reg) & 0xfc) >> 2
}
func (o *ADC140_Type) SetADCMPSER_CMPSTOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPSER.Reg, volatile.LoadUint8(&o.ADCMPSER.Reg)&^(0x2)|value<<1)
}
func (o *ADC140_Type) GetADCMPSER_CMPSTOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPSER.Reg) & 0x2) >> 1
}
func (o *ADC140_Type) SetADCMPSER_CMPSTTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPSER.Reg, volatile.LoadUint8(&o.ADCMPSER.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADCMPSER_CMPSTTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPSER.Reg) & 0x1
}

// ADC140.ADCMPBNSR: A/D Compare Function Window B Channel Selection Register
func (o *ADC140_Type) SetADCMPBNSR_CMPLB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC140_Type) GetADCMPBNSR_CMPLB() uint8 {
	return (volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x80) >> 7
}
func (o *ADC140_Type) SetADCMPBNSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x40)|value<<6)
}
func (o *ADC140_Type) GetADCMPBNSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x40) >> 6
}
func (o *ADC140_Type) SetADCMPBNSR_CMPCHB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x3f)|value)
}
func (o *ADC140_Type) GetADCMPBNSR_CMPCHB() uint8 {
	return volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x3f
}

// ADC140.ADWINLLB: A/D Compare Function Window B Lower-Side Level Setting Register
func (o *ADC140_Type) SetADWINLLB(value uint16) {
	volatile.StoreUint16(&o.ADWINLLB.Reg, value)
}
func (o *ADC140_Type) GetADWINLLB() uint16 {
	return volatile.LoadUint16(&o.ADWINLLB.Reg)
}

// ADC140.ADWINULB: A/D Compare Function Window B Upper-Side Level Setting Register
func (o *ADC140_Type) SetADWINULB(value uint16) {
	volatile.StoreUint16(&o.ADWINULB.Reg, value)
}
func (o *ADC140_Type) GetADWINULB() uint16 {
	return volatile.LoadUint16(&o.ADWINULB.Reg)
}

// ADC140.ADCMPBSR: A/D Compare Function Window B Status Register
func (o *ADC140_Type) SetADCMPBSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADCMPBSR.Reg, volatile.LoadUint8(&o.ADCMPBSR.Reg)&^(0xfe)|value<<1)
}
func (o *ADC140_Type) GetADCMPBSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADCMPBSR.Reg) & 0xfe) >> 1
}
func (o *ADC140_Type) SetADCMPBSR_CMPSTB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBSR.Reg, volatile.LoadUint8(&o.ADCMPBSR.Reg)&^(0x1)|value)
}
func (o *ADC140_Type) GetADCMPBSR_CMPSTB() uint8 {
	return volatile.LoadUint8(&o.ADCMPBSR.Reg) & 0x1
}

// ADC140.ADSSTRL: A/D Sampling State Register L
func (o *ADC140_Type) SetADSSTRL(value uint8) {
	volatile.StoreUint8(&o.ADSSTRL.Reg, value)
}
func (o *ADC140_Type) GetADSSTRL() uint8 {
	return volatile.LoadUint8(&o.ADSSTRL.Reg)
}

// ADC140.ADSSTRT: A/D Sampling State Register T
func (o *ADC140_Type) SetADSSTRT(value uint8) {
	volatile.StoreUint8(&o.ADSSTRT.Reg, value)
}
func (o *ADC140_Type) GetADSSTRT() uint8 {
	return volatile.LoadUint8(&o.ADSSTRT.Reg)
}

// ADC140.ADSSTRO: A/D Sampling State Register O
func (o *ADC140_Type) SetADSSTRO(value uint8) {
	volatile.StoreUint8(&o.ADSSTRO.Reg, value)
}
func (o *ADC140_Type) GetADSSTRO() uint8 {
	return volatile.LoadUint8(&o.ADSSTRO.Reg)
}

// ADC140.ADSSTR0: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR0(value uint8) {
	volatile.StoreUint8(&o.ADSSTR0.Reg, value)
}
func (o *ADC140_Type) GetADSSTR0() uint8 {
	return volatile.LoadUint8(&o.ADSSTR0.Reg)
}

// ADC140.ADSSTR1: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR1(value uint8) {
	volatile.StoreUint8(&o.ADSSTR1.Reg, value)
}
func (o *ADC140_Type) GetADSSTR1() uint8 {
	return volatile.LoadUint8(&o.ADSSTR1.Reg)
}

// ADC140.ADSSTR2: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR2(value uint8) {
	volatile.StoreUint8(&o.ADSSTR2.Reg, value)
}
func (o *ADC140_Type) GetADSSTR2() uint8 {
	return volatile.LoadUint8(&o.ADSSTR2.Reg)
}

// ADC140.ADSSTR3: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR3(value uint8) {
	volatile.StoreUint8(&o.ADSSTR3.Reg, value)
}
func (o *ADC140_Type) GetADSSTR3() uint8 {
	return volatile.LoadUint8(&o.ADSSTR3.Reg)
}

// ADC140.ADSSTR4: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR4(value uint8) {
	volatile.StoreUint8(&o.ADSSTR4.Reg, value)
}
func (o *ADC140_Type) GetADSSTR4() uint8 {
	return volatile.LoadUint8(&o.ADSSTR4.Reg)
}

// ADC140.ADSSTR5: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR5(value uint8) {
	volatile.StoreUint8(&o.ADSSTR5.Reg, value)
}
func (o *ADC140_Type) GetADSSTR5() uint8 {
	return volatile.LoadUint8(&o.ADSSTR5.Reg)
}

// ADC140.ADSSTR6: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR6(value uint8) {
	volatile.StoreUint8(&o.ADSSTR6.Reg, value)
}
func (o *ADC140_Type) GetADSSTR6() uint8 {
	return volatile.LoadUint8(&o.ADSSTR6.Reg)
}

// ADC140.ADSSTR7: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR7(value uint8) {
	volatile.StoreUint8(&o.ADSSTR7.Reg, value)
}
func (o *ADC140_Type) GetADSSTR7() uint8 {
	return volatile.LoadUint8(&o.ADSSTR7.Reg)
}

// ADC140.ADSSTR8: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR8(value uint8) {
	volatile.StoreUint8(&o.ADSSTR8.Reg, value)
}
func (o *ADC140_Type) GetADSSTR8() uint8 {
	return volatile.LoadUint8(&o.ADSSTR8.Reg)
}

// ADC140.ADSSTR9: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR9(value uint8) {
	volatile.StoreUint8(&o.ADSSTR9.Reg, value)
}
func (o *ADC140_Type) GetADSSTR9() uint8 {
	return volatile.LoadUint8(&o.ADSSTR9.Reg)
}

// ADC140.ADSSTR10: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR10(value uint8) {
	volatile.StoreUint8(&o.ADSSTR10.Reg, value)
}
func (o *ADC140_Type) GetADSSTR10() uint8 {
	return volatile.LoadUint8(&o.ADSSTR10.Reg)
}

// ADC140.ADSSTR11: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR11(value uint8) {
	volatile.StoreUint8(&o.ADSSTR11.Reg, value)
}
func (o *ADC140_Type) GetADSSTR11() uint8 {
	return volatile.LoadUint8(&o.ADSSTR11.Reg)
}

// ADC140.ADSSTR12: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR12(value uint8) {
	volatile.StoreUint8(&o.ADSSTR12.Reg, value)
}
func (o *ADC140_Type) GetADSSTR12() uint8 {
	return volatile.LoadUint8(&o.ADSSTR12.Reg)
}

// ADC140.ADSSTR13: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR13(value uint8) {
	volatile.StoreUint8(&o.ADSSTR13.Reg, value)
}
func (o *ADC140_Type) GetADSSTR13() uint8 {
	return volatile.LoadUint8(&o.ADSSTR13.Reg)
}

// ADC140.ADSSTR14: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR14(value uint8) {
	volatile.StoreUint8(&o.ADSSTR14.Reg, value)
}
func (o *ADC140_Type) GetADSSTR14() uint8 {
	return volatile.LoadUint8(&o.ADSSTR14.Reg)
}

// ADC140.ADSSTR15: A/D Sampling State Register %s
func (o *ADC140_Type) SetADSSTR15(value uint8) {
	volatile.StoreUint8(&o.ADSSTR15.Reg, value)
}
func (o *ADC140_Type) GetADSSTR15() uint8 {
	return volatile.LoadUint8(&o.ADSSTR15.Reg)
}

// Low-Power Analog Comparator
type ACMPLP_Type struct {
	COMPMDR  volatile.Register8 // 0x0
	COMPFIR  volatile.Register8 // 0x1
	COMPOCR  volatile.Register8 // 0x2
	_        byte
	COMPSEL0 volatile.Register8 // 0x4
	COMPSEL1 volatile.Register8 // 0x5
}

// ACMPLP.COMPMDR: ACMPLP Mode Setting Register
func (o *ACMPLP_Type) SetCOMPMDR_C1MON(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x80)|value<<7)
}
func (o *ACMPLP_Type) GetCOMPMDR_C1MON() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x80) >> 7
}
func (o *ACMPLP_Type) SetCOMPMDR_C1VRF(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x40)|value<<6)
}
func (o *ACMPLP_Type) GetCOMPMDR_C1VRF() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x40) >> 6
}
func (o *ACMPLP_Type) SetCOMPMDR_C1WDE(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x20)|value<<5)
}
func (o *ACMPLP_Type) GetCOMPMDR_C1WDE() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x20) >> 5
}
func (o *ACMPLP_Type) SetCOMPMDR_C1ENB(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x10)|value<<4)
}
func (o *ACMPLP_Type) GetCOMPMDR_C1ENB() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x10) >> 4
}
func (o *ACMPLP_Type) SetCOMPMDR_C0MON(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x8)|value<<3)
}
func (o *ACMPLP_Type) GetCOMPMDR_C0MON() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x8) >> 3
}
func (o *ACMPLP_Type) SetCOMPMDR_C0VRF(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x4)|value<<2)
}
func (o *ACMPLP_Type) GetCOMPMDR_C0VRF() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x4) >> 2
}
func (o *ACMPLP_Type) SetCOMPMDR_C0WDE(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x2)|value<<1)
}
func (o *ACMPLP_Type) GetCOMPMDR_C0WDE() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x2) >> 1
}
func (o *ACMPLP_Type) SetCOMPMDR_C0ENB(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x1)|value)
}
func (o *ACMPLP_Type) GetCOMPMDR_C0ENB() uint8 {
	return volatile.LoadUint8(&o.COMPMDR.Reg) & 0x1
}

// ACMPLP.COMPFIR: ACMPLP Filter Control Register
func (o *ACMPLP_Type) SetCOMPFIR_C1EDG(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x80)|value<<7)
}
func (o *ACMPLP_Type) GetCOMPFIR_C1EDG() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x80) >> 7
}
func (o *ACMPLP_Type) SetCOMPFIR_C1EPO(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x40)|value<<6)
}
func (o *ACMPLP_Type) GetCOMPFIR_C1EPO() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x40) >> 6
}
func (o *ACMPLP_Type) SetCOMPFIR_C1FCK(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x30)|value<<4)
}
func (o *ACMPLP_Type) GetCOMPFIR_C1FCK() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x30) >> 4
}
func (o *ACMPLP_Type) SetCOMPFIR_C0EDG(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x8)|value<<3)
}
func (o *ACMPLP_Type) GetCOMPFIR_C0EDG() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x8) >> 3
}
func (o *ACMPLP_Type) SetCOMPFIR_C0EPO(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x4)|value<<2)
}
func (o *ACMPLP_Type) GetCOMPFIR_C0EPO() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x4) >> 2
}
func (o *ACMPLP_Type) SetCOMPFIR_C0FCK(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x3)|value)
}
func (o *ACMPLP_Type) GetCOMPFIR_C0FCK() uint8 {
	return volatile.LoadUint8(&o.COMPFIR.Reg) & 0x3
}

// ACMPLP.COMPOCR: ACMPLP Output Control Register
func (o *ACMPLP_Type) SetCOMPOCR_SPDMD(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x80)|value<<7)
}
func (o *ACMPLP_Type) GetCOMPOCR_SPDMD() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x80) >> 7
}
func (o *ACMPLP_Type) SetCOMPOCR_C1OP(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x40)|value<<6)
}
func (o *ACMPLP_Type) GetCOMPOCR_C1OP() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x40) >> 6
}
func (o *ACMPLP_Type) SetCOMPOCR_C1OE(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x20)|value<<5)
}
func (o *ACMPLP_Type) GetCOMPOCR_C1OE() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x20) >> 5
}
func (o *ACMPLP_Type) SetCOMPOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x18)|value<<3)
}
func (o *ACMPLP_Type) GetCOMPOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x18) >> 3
}
func (o *ACMPLP_Type) SetCOMPOCR_C0OP(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x4)|value<<2)
}
func (o *ACMPLP_Type) GetCOMPOCR_C0OP() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x4) >> 2
}
func (o *ACMPLP_Type) SetCOMPOCR_C0OE(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x2)|value<<1)
}
func (o *ACMPLP_Type) GetCOMPOCR_C0OE() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x2) >> 1
}
func (o *ACMPLP_Type) SetCOMPOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x1)|value)
}
func (o *ACMPLP_Type) GetCOMPOCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.COMPOCR.Reg) & 0x1
}

// ACMPLP.COMPSEL0: Comparator Input Select Register
func (o *ACMPLP_Type) SetCOMPSEL0_Reserved(value uint8) {
	volatile.StoreUint8(&o.COMPSEL0.Reg, volatile.LoadUint8(&o.COMPSEL0.Reg)&^(0x80)|value<<7)
}
func (o *ACMPLP_Type) GetCOMPSEL0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.COMPSEL0.Reg) & 0x80) >> 7
}
func (o *ACMPLP_Type) SetCOMPSEL0_CMPSEL64(value uint8) {
	volatile.StoreUint8(&o.COMPSEL0.Reg, volatile.LoadUint8(&o.COMPSEL0.Reg)&^(0x70)|value<<4)
}
func (o *ACMPLP_Type) GetCOMPSEL0_CMPSEL64() uint8 {
	return (volatile.LoadUint8(&o.COMPSEL0.Reg) & 0x70) >> 4
}
func (o *ACMPLP_Type) SetCOMPSEL0_Reserved(value uint8) {
	volatile.StoreUint8(&o.COMPSEL0.Reg, volatile.LoadUint8(&o.COMPSEL0.Reg)&^(0x8)|value<<3)
}
func (o *ACMPLP_Type) GetCOMPSEL0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.COMPSEL0.Reg) & 0x8) >> 3
}
func (o *ACMPLP_Type) SetCOMPSEL0_CMPSEL20(value uint8) {
	volatile.StoreUint8(&o.COMPSEL0.Reg, volatile.LoadUint8(&o.COMPSEL0.Reg)&^(0x7)|value)
}
func (o *ACMPLP_Type) GetCOMPSEL0_CMPSEL20() uint8 {
	return volatile.LoadUint8(&o.COMPSEL0.Reg) & 0x7
}

// ACMPLP.COMPSEL1: Comparator Reference Voltage Select Register
func (o *ACMPLP_Type) SetCOMPSEL1_C1VRF2(value uint8) {
	volatile.StoreUint8(&o.COMPSEL1.Reg, volatile.LoadUint8(&o.COMPSEL1.Reg)&^(0x80)|value<<7)
}
func (o *ACMPLP_Type) GetCOMPSEL1_C1VRF2() uint8 {
	return (volatile.LoadUint8(&o.COMPSEL1.Reg) & 0x80) >> 7
}
func (o *ACMPLP_Type) SetCOMPSEL1_CRVS64(value uint8) {
	volatile.StoreUint8(&o.COMPSEL1.Reg, volatile.LoadUint8(&o.COMPSEL1.Reg)&^(0x70)|value<<4)
}
func (o *ACMPLP_Type) GetCOMPSEL1_CRVS64() uint8 {
	return (volatile.LoadUint8(&o.COMPSEL1.Reg) & 0x70) >> 4
}
func (o *ACMPLP_Type) SetCOMPSEL1_Reserved(value uint8) {
	volatile.StoreUint8(&o.COMPSEL1.Reg, volatile.LoadUint8(&o.COMPSEL1.Reg)&^(0x8)|value<<3)
}
func (o *ACMPLP_Type) GetCOMPSEL1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.COMPSEL1.Reg) & 0x8) >> 3
}
func (o *ACMPLP_Type) SetCOMPSEL1_CRVS20(value uint8) {
	volatile.StoreUint8(&o.COMPSEL1.Reg, volatile.LoadUint8(&o.COMPSEL1.Reg)&^(0x7)|value)
}
func (o *ACMPLP_Type) GetCOMPSEL1_CRVS20() uint8 {
	return volatile.LoadUint8(&o.COMPSEL1.Reg) & 0x7
}

// Temperature Sensor
type TSN_Type struct {
	_      [552]byte
	TSCDRH volatile.Register8 // 0x228
	TSCDRL volatile.Register8 // 0x229
}

// TSN.TSCDRH: Temperature Sensor Calibration Data Register H
func (o *TSN_Type) SetTSCDRH(value uint8) {
	volatile.StoreUint8(&o.TSCDRH.Reg, value)
}
func (o *TSN_Type) GetTSCDRH() uint8 {
	return volatile.LoadUint8(&o.TSCDRH.Reg)
}

// TSN.TSCDRL: Temperature Sensor Calibration Data Register L
func (o *TSN_Type) SetTSCDRL(value uint8) {
	volatile.StoreUint8(&o.TSCDRL.Reg, value)
}
func (o *TSN_Type) GetTSCDRL() uint8 {
	return volatile.LoadUint8(&o.TSCDRL.Reg)
}

// Segment LCD Controller/Driver
type SLCDC_Type struct {
	LCDM0 volatile.Register8 // 0x0
	LCDM1 volatile.Register8 // 0x1
	LCDC0 volatile.Register8 // 0x2
	VLCD  volatile.Register8 // 0x3
	_     [252]byte
	SEG0  volatile.Register8 // 0x100
	SEG1  volatile.Register8 // 0x101
	SEG2  volatile.Register8 // 0x102
	SEG3  volatile.Register8 // 0x103
	SEG4  volatile.Register8 // 0x104
	SEG5  volatile.Register8 // 0x105
	SEG6  volatile.Register8 // 0x106
	SEG7  volatile.Register8 // 0x107
	SEG8  volatile.Register8 // 0x108
	SEG9  volatile.Register8 // 0x109
	SEG10 volatile.Register8 // 0x10A
	SEG11 volatile.Register8 // 0x10B
	SEG12 volatile.Register8 // 0x10C
	SEG13 volatile.Register8 // 0x10D
	SEG14 volatile.Register8 // 0x10E
	SEG15 volatile.Register8 // 0x10F
	SEG16 volatile.Register8 // 0x110
	SEG17 volatile.Register8 // 0x111
	SEG18 volatile.Register8 // 0x112
	SEG19 volatile.Register8 // 0x113
	SEG20 volatile.Register8 // 0x114
	SEG21 volatile.Register8 // 0x115
	SEG22 volatile.Register8 // 0x116
	SEG23 volatile.Register8 // 0x117
	SEG24 volatile.Register8 // 0x118
	SEG25 volatile.Register8 // 0x119
	SEG26 volatile.Register8 // 0x11A
	SEG27 volatile.Register8 // 0x11B
	SEG28 volatile.Register8 // 0x11C
	SEG29 volatile.Register8 // 0x11D
	SEG30 volatile.Register8 // 0x11E
	SEG31 volatile.Register8 // 0x11F
	SEG32 volatile.Register8 // 0x120
	SEG33 volatile.Register8 // 0x121
	SEG34 volatile.Register8 // 0x122
	SEG35 volatile.Register8 // 0x123
	SEG36 volatile.Register8 // 0x124
	SEG37 volatile.Register8 // 0x125
	SEG38 volatile.Register8 // 0x126
	SEG39 volatile.Register8 // 0x127
	SEG40 volatile.Register8 // 0x128
	SEG41 volatile.Register8 // 0x129
	SEG42 volatile.Register8 // 0x12A
	SEG43 volatile.Register8 // 0x12B
	SEG44 volatile.Register8 // 0x12C
	SEG45 volatile.Register8 // 0x12D
	SEG46 volatile.Register8 // 0x12E
	SEG47 volatile.Register8 // 0x12F
	SEG48 volatile.Register8 // 0x130
	SEG49 volatile.Register8 // 0x131
	SEG50 volatile.Register8 // 0x132
	SEG51 volatile.Register8 // 0x133
	SEG52 volatile.Register8 // 0x134
	SEG53 volatile.Register8 // 0x135
}

// SLCDC.LCDM0: LCD Mode Register 0
func (o *SLCDC_Type) SetLCDM0_MDSET(value uint8) {
	volatile.StoreUint8(&o.LCDM0.Reg, volatile.LoadUint8(&o.LCDM0.Reg)&^(0xc0)|value<<6)
}
func (o *SLCDC_Type) GetLCDM0_MDSET() uint8 {
	return (volatile.LoadUint8(&o.LCDM0.Reg) & 0xc0) >> 6
}
func (o *SLCDC_Type) SetLCDM0_LWAVE(value uint8) {
	volatile.StoreUint8(&o.LCDM0.Reg, volatile.LoadUint8(&o.LCDM0.Reg)&^(0x20)|value<<5)
}
func (o *SLCDC_Type) GetLCDM0_LWAVE() uint8 {
	return (volatile.LoadUint8(&o.LCDM0.Reg) & 0x20) >> 5
}
func (o *SLCDC_Type) SetLCDM0_LDTY(value uint8) {
	volatile.StoreUint8(&o.LCDM0.Reg, volatile.LoadUint8(&o.LCDM0.Reg)&^(0x1c)|value<<2)
}
func (o *SLCDC_Type) GetLCDM0_LDTY() uint8 {
	return (volatile.LoadUint8(&o.LCDM0.Reg) & 0x1c) >> 2
}
func (o *SLCDC_Type) SetLCDM0_LBAS(value uint8) {
	volatile.StoreUint8(&o.LCDM0.Reg, volatile.LoadUint8(&o.LCDM0.Reg)&^(0x3)|value)
}
func (o *SLCDC_Type) GetLCDM0_LBAS() uint8 {
	return volatile.LoadUint8(&o.LCDM0.Reg) & 0x3
}

// SLCDC.LCDM1: LCD Mode Register 1
func (o *SLCDC_Type) SetLCDM1_LCDON(value uint8) {
	volatile.StoreUint8(&o.LCDM1.Reg, volatile.LoadUint8(&o.LCDM1.Reg)&^(0x80)|value<<7)
}
func (o *SLCDC_Type) GetLCDM1_LCDON() uint8 {
	return (volatile.LoadUint8(&o.LCDM1.Reg) & 0x80) >> 7
}
func (o *SLCDC_Type) SetLCDM1_SCOC(value uint8) {
	volatile.StoreUint8(&o.LCDM1.Reg, volatile.LoadUint8(&o.LCDM1.Reg)&^(0x40)|value<<6)
}
func (o *SLCDC_Type) GetLCDM1_SCOC() uint8 {
	return (volatile.LoadUint8(&o.LCDM1.Reg) & 0x40) >> 6
}
func (o *SLCDC_Type) SetLCDM1_VLCON(value uint8) {
	volatile.StoreUint8(&o.LCDM1.Reg, volatile.LoadUint8(&o.LCDM1.Reg)&^(0x20)|value<<5)
}
func (o *SLCDC_Type) GetLCDM1_VLCON() uint8 {
	return (volatile.LoadUint8(&o.LCDM1.Reg) & 0x20) >> 5
}
func (o *SLCDC_Type) SetLCDM1_BLON(value uint8) {
	volatile.StoreUint8(&o.LCDM1.Reg, volatile.LoadUint8(&o.LCDM1.Reg)&^(0x10)|value<<4)
}
func (o *SLCDC_Type) GetLCDM1_BLON() uint8 {
	return (volatile.LoadUint8(&o.LCDM1.Reg) & 0x10) >> 4
}
func (o *SLCDC_Type) SetLCDM1_LCDSEL(value uint8) {
	volatile.StoreUint8(&o.LCDM1.Reg, volatile.LoadUint8(&o.LCDM1.Reg)&^(0x8)|value<<3)
}
func (o *SLCDC_Type) GetLCDM1_LCDSEL() uint8 {
	return (volatile.LoadUint8(&o.LCDM1.Reg) & 0x8) >> 3
}
func (o *SLCDC_Type) SetLCDM1_Reserved(value uint8) {
	volatile.StoreUint8(&o.LCDM1.Reg, volatile.LoadUint8(&o.LCDM1.Reg)&^(0x6)|value<<1)
}
func (o *SLCDC_Type) GetLCDM1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LCDM1.Reg) & 0x6) >> 1
}
func (o *SLCDC_Type) SetLCDM1_LCDVLM(value uint8) {
	volatile.StoreUint8(&o.LCDM1.Reg, volatile.LoadUint8(&o.LCDM1.Reg)&^(0x1)|value)
}
func (o *SLCDC_Type) GetLCDM1_LCDVLM() uint8 {
	return volatile.LoadUint8(&o.LCDM1.Reg) & 0x1
}

// SLCDC.LCDC0: LCD Clock Control Register 0
func (o *SLCDC_Type) SetLCDC0_LCDC(value uint8) {
	volatile.StoreUint8(&o.LCDC0.Reg, volatile.LoadUint8(&o.LCDC0.Reg)&^(0x3f)|value)
}
func (o *SLCDC_Type) GetLCDC0_LCDC() uint8 {
	return volatile.LoadUint8(&o.LCDC0.Reg) & 0x3f
}

// SLCDC.VLCD: LCD Boost Level Control Register
func (o *SLCDC_Type) SetVLCD(value uint8) {
	volatile.StoreUint8(&o.VLCD.Reg, volatile.LoadUint8(&o.VLCD.Reg)&^(0x1f)|value)
}
func (o *SLCDC_Type) GetVLCD() uint8 {
	return volatile.LoadUint8(&o.VLCD.Reg) & 0x1f
}

// SLCDC.SEG0: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG0(value uint8) {
	volatile.StoreUint8(&o.SEG0.Reg, value)
}
func (o *SLCDC_Type) GetSEG0() uint8 {
	return volatile.LoadUint8(&o.SEG0.Reg)
}

// SLCDC.SEG1: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG1(value uint8) {
	volatile.StoreUint8(&o.SEG1.Reg, value)
}
func (o *SLCDC_Type) GetSEG1() uint8 {
	return volatile.LoadUint8(&o.SEG1.Reg)
}

// SLCDC.SEG2: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG2(value uint8) {
	volatile.StoreUint8(&o.SEG2.Reg, value)
}
func (o *SLCDC_Type) GetSEG2() uint8 {
	return volatile.LoadUint8(&o.SEG2.Reg)
}

// SLCDC.SEG3: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG3(value uint8) {
	volatile.StoreUint8(&o.SEG3.Reg, value)
}
func (o *SLCDC_Type) GetSEG3() uint8 {
	return volatile.LoadUint8(&o.SEG3.Reg)
}

// SLCDC.SEG4: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG4(value uint8) {
	volatile.StoreUint8(&o.SEG4.Reg, value)
}
func (o *SLCDC_Type) GetSEG4() uint8 {
	return volatile.LoadUint8(&o.SEG4.Reg)
}

// SLCDC.SEG5: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG5(value uint8) {
	volatile.StoreUint8(&o.SEG5.Reg, value)
}
func (o *SLCDC_Type) GetSEG5() uint8 {
	return volatile.LoadUint8(&o.SEG5.Reg)
}

// SLCDC.SEG6: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG6(value uint8) {
	volatile.StoreUint8(&o.SEG6.Reg, value)
}
func (o *SLCDC_Type) GetSEG6() uint8 {
	return volatile.LoadUint8(&o.SEG6.Reg)
}

// SLCDC.SEG7: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG7(value uint8) {
	volatile.StoreUint8(&o.SEG7.Reg, value)
}
func (o *SLCDC_Type) GetSEG7() uint8 {
	return volatile.LoadUint8(&o.SEG7.Reg)
}

// SLCDC.SEG8: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG8(value uint8) {
	volatile.StoreUint8(&o.SEG8.Reg, value)
}
func (o *SLCDC_Type) GetSEG8() uint8 {
	return volatile.LoadUint8(&o.SEG8.Reg)
}

// SLCDC.SEG9: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG9(value uint8) {
	volatile.StoreUint8(&o.SEG9.Reg, value)
}
func (o *SLCDC_Type) GetSEG9() uint8 {
	return volatile.LoadUint8(&o.SEG9.Reg)
}

// SLCDC.SEG10: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG10(value uint8) {
	volatile.StoreUint8(&o.SEG10.Reg, value)
}
func (o *SLCDC_Type) GetSEG10() uint8 {
	return volatile.LoadUint8(&o.SEG10.Reg)
}

// SLCDC.SEG11: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG11(value uint8) {
	volatile.StoreUint8(&o.SEG11.Reg, value)
}
func (o *SLCDC_Type) GetSEG11() uint8 {
	return volatile.LoadUint8(&o.SEG11.Reg)
}

// SLCDC.SEG12: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG12(value uint8) {
	volatile.StoreUint8(&o.SEG12.Reg, value)
}
func (o *SLCDC_Type) GetSEG12() uint8 {
	return volatile.LoadUint8(&o.SEG12.Reg)
}

// SLCDC.SEG13: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG13(value uint8) {
	volatile.StoreUint8(&o.SEG13.Reg, value)
}
func (o *SLCDC_Type) GetSEG13() uint8 {
	return volatile.LoadUint8(&o.SEG13.Reg)
}

// SLCDC.SEG14: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG14(value uint8) {
	volatile.StoreUint8(&o.SEG14.Reg, value)
}
func (o *SLCDC_Type) GetSEG14() uint8 {
	return volatile.LoadUint8(&o.SEG14.Reg)
}

// SLCDC.SEG15: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG15(value uint8) {
	volatile.StoreUint8(&o.SEG15.Reg, value)
}
func (o *SLCDC_Type) GetSEG15() uint8 {
	return volatile.LoadUint8(&o.SEG15.Reg)
}

// SLCDC.SEG16: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG16(value uint8) {
	volatile.StoreUint8(&o.SEG16.Reg, value)
}
func (o *SLCDC_Type) GetSEG16() uint8 {
	return volatile.LoadUint8(&o.SEG16.Reg)
}

// SLCDC.SEG17: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG17(value uint8) {
	volatile.StoreUint8(&o.SEG17.Reg, value)
}
func (o *SLCDC_Type) GetSEG17() uint8 {
	return volatile.LoadUint8(&o.SEG17.Reg)
}

// SLCDC.SEG18: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG18(value uint8) {
	volatile.StoreUint8(&o.SEG18.Reg, value)
}
func (o *SLCDC_Type) GetSEG18() uint8 {
	return volatile.LoadUint8(&o.SEG18.Reg)
}

// SLCDC.SEG19: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG19(value uint8) {
	volatile.StoreUint8(&o.SEG19.Reg, value)
}
func (o *SLCDC_Type) GetSEG19() uint8 {
	return volatile.LoadUint8(&o.SEG19.Reg)
}

// SLCDC.SEG20: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG20(value uint8) {
	volatile.StoreUint8(&o.SEG20.Reg, value)
}
func (o *SLCDC_Type) GetSEG20() uint8 {
	return volatile.LoadUint8(&o.SEG20.Reg)
}

// SLCDC.SEG21: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG21(value uint8) {
	volatile.StoreUint8(&o.SEG21.Reg, value)
}
func (o *SLCDC_Type) GetSEG21() uint8 {
	return volatile.LoadUint8(&o.SEG21.Reg)
}

// SLCDC.SEG22: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG22(value uint8) {
	volatile.StoreUint8(&o.SEG22.Reg, value)
}
func (o *SLCDC_Type) GetSEG22() uint8 {
	return volatile.LoadUint8(&o.SEG22.Reg)
}

// SLCDC.SEG23: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG23(value uint8) {
	volatile.StoreUint8(&o.SEG23.Reg, value)
}
func (o *SLCDC_Type) GetSEG23() uint8 {
	return volatile.LoadUint8(&o.SEG23.Reg)
}

// SLCDC.SEG24: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG24(value uint8) {
	volatile.StoreUint8(&o.SEG24.Reg, value)
}
func (o *SLCDC_Type) GetSEG24() uint8 {
	return volatile.LoadUint8(&o.SEG24.Reg)
}

// SLCDC.SEG25: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG25(value uint8) {
	volatile.StoreUint8(&o.SEG25.Reg, value)
}
func (o *SLCDC_Type) GetSEG25() uint8 {
	return volatile.LoadUint8(&o.SEG25.Reg)
}

// SLCDC.SEG26: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG26(value uint8) {
	volatile.StoreUint8(&o.SEG26.Reg, value)
}
func (o *SLCDC_Type) GetSEG26() uint8 {
	return volatile.LoadUint8(&o.SEG26.Reg)
}

// SLCDC.SEG27: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG27(value uint8) {
	volatile.StoreUint8(&o.SEG27.Reg, value)
}
func (o *SLCDC_Type) GetSEG27() uint8 {
	return volatile.LoadUint8(&o.SEG27.Reg)
}

// SLCDC.SEG28: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG28(value uint8) {
	volatile.StoreUint8(&o.SEG28.Reg, value)
}
func (o *SLCDC_Type) GetSEG28() uint8 {
	return volatile.LoadUint8(&o.SEG28.Reg)
}

// SLCDC.SEG29: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG29(value uint8) {
	volatile.StoreUint8(&o.SEG29.Reg, value)
}
func (o *SLCDC_Type) GetSEG29() uint8 {
	return volatile.LoadUint8(&o.SEG29.Reg)
}

// SLCDC.SEG30: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG30(value uint8) {
	volatile.StoreUint8(&o.SEG30.Reg, value)
}
func (o *SLCDC_Type) GetSEG30() uint8 {
	return volatile.LoadUint8(&o.SEG30.Reg)
}

// SLCDC.SEG31: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG31(value uint8) {
	volatile.StoreUint8(&o.SEG31.Reg, value)
}
func (o *SLCDC_Type) GetSEG31() uint8 {
	return volatile.LoadUint8(&o.SEG31.Reg)
}

// SLCDC.SEG32: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG32(value uint8) {
	volatile.StoreUint8(&o.SEG32.Reg, value)
}
func (o *SLCDC_Type) GetSEG32() uint8 {
	return volatile.LoadUint8(&o.SEG32.Reg)
}

// SLCDC.SEG33: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG33(value uint8) {
	volatile.StoreUint8(&o.SEG33.Reg, value)
}
func (o *SLCDC_Type) GetSEG33() uint8 {
	return volatile.LoadUint8(&o.SEG33.Reg)
}

// SLCDC.SEG34: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG34(value uint8) {
	volatile.StoreUint8(&o.SEG34.Reg, value)
}
func (o *SLCDC_Type) GetSEG34() uint8 {
	return volatile.LoadUint8(&o.SEG34.Reg)
}

// SLCDC.SEG35: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG35(value uint8) {
	volatile.StoreUint8(&o.SEG35.Reg, value)
}
func (o *SLCDC_Type) GetSEG35() uint8 {
	return volatile.LoadUint8(&o.SEG35.Reg)
}

// SLCDC.SEG36: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG36(value uint8) {
	volatile.StoreUint8(&o.SEG36.Reg, value)
}
func (o *SLCDC_Type) GetSEG36() uint8 {
	return volatile.LoadUint8(&o.SEG36.Reg)
}

// SLCDC.SEG37: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG37(value uint8) {
	volatile.StoreUint8(&o.SEG37.Reg, value)
}
func (o *SLCDC_Type) GetSEG37() uint8 {
	return volatile.LoadUint8(&o.SEG37.Reg)
}

// SLCDC.SEG38: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG38(value uint8) {
	volatile.StoreUint8(&o.SEG38.Reg, value)
}
func (o *SLCDC_Type) GetSEG38() uint8 {
	return volatile.LoadUint8(&o.SEG38.Reg)
}

// SLCDC.SEG39: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG39(value uint8) {
	volatile.StoreUint8(&o.SEG39.Reg, value)
}
func (o *SLCDC_Type) GetSEG39() uint8 {
	return volatile.LoadUint8(&o.SEG39.Reg)
}

// SLCDC.SEG40: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG40(value uint8) {
	volatile.StoreUint8(&o.SEG40.Reg, value)
}
func (o *SLCDC_Type) GetSEG40() uint8 {
	return volatile.LoadUint8(&o.SEG40.Reg)
}

// SLCDC.SEG41: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG41(value uint8) {
	volatile.StoreUint8(&o.SEG41.Reg, value)
}
func (o *SLCDC_Type) GetSEG41() uint8 {
	return volatile.LoadUint8(&o.SEG41.Reg)
}

// SLCDC.SEG42: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG42(value uint8) {
	volatile.StoreUint8(&o.SEG42.Reg, value)
}
func (o *SLCDC_Type) GetSEG42() uint8 {
	return volatile.LoadUint8(&o.SEG42.Reg)
}

// SLCDC.SEG43: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG43(value uint8) {
	volatile.StoreUint8(&o.SEG43.Reg, value)
}
func (o *SLCDC_Type) GetSEG43() uint8 {
	return volatile.LoadUint8(&o.SEG43.Reg)
}

// SLCDC.SEG44: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG44(value uint8) {
	volatile.StoreUint8(&o.SEG44.Reg, value)
}
func (o *SLCDC_Type) GetSEG44() uint8 {
	return volatile.LoadUint8(&o.SEG44.Reg)
}

// SLCDC.SEG45: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG45(value uint8) {
	volatile.StoreUint8(&o.SEG45.Reg, value)
}
func (o *SLCDC_Type) GetSEG45() uint8 {
	return volatile.LoadUint8(&o.SEG45.Reg)
}

// SLCDC.SEG46: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG46(value uint8) {
	volatile.StoreUint8(&o.SEG46.Reg, value)
}
func (o *SLCDC_Type) GetSEG46() uint8 {
	return volatile.LoadUint8(&o.SEG46.Reg)
}

// SLCDC.SEG47: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG47(value uint8) {
	volatile.StoreUint8(&o.SEG47.Reg, value)
}
func (o *SLCDC_Type) GetSEG47() uint8 {
	return volatile.LoadUint8(&o.SEG47.Reg)
}

// SLCDC.SEG48: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG48(value uint8) {
	volatile.StoreUint8(&o.SEG48.Reg, value)
}
func (o *SLCDC_Type) GetSEG48() uint8 {
	return volatile.LoadUint8(&o.SEG48.Reg)
}

// SLCDC.SEG49: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG49(value uint8) {
	volatile.StoreUint8(&o.SEG49.Reg, value)
}
func (o *SLCDC_Type) GetSEG49() uint8 {
	return volatile.LoadUint8(&o.SEG49.Reg)
}

// SLCDC.SEG50: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG50(value uint8) {
	volatile.StoreUint8(&o.SEG50.Reg, value)
}
func (o *SLCDC_Type) GetSEG50() uint8 {
	return volatile.LoadUint8(&o.SEG50.Reg)
}

// SLCDC.SEG51: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG51(value uint8) {
	volatile.StoreUint8(&o.SEG51.Reg, value)
}
func (o *SLCDC_Type) GetSEG51() uint8 {
	return volatile.LoadUint8(&o.SEG51.Reg)
}

// SLCDC.SEG52: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG52(value uint8) {
	volatile.StoreUint8(&o.SEG52.Reg, value)
}
func (o *SLCDC_Type) GetSEG52() uint8 {
	return volatile.LoadUint8(&o.SEG52.Reg)
}

// SLCDC.SEG53: LCD Display Data Register %s
func (o *SLCDC_Type) SetSEG53(value uint8) {
	volatile.StoreUint8(&o.SEG53.Reg, value)
}
func (o *SLCDC_Type) GetSEG53() uint8 {
	return volatile.LoadUint8(&o.SEG53.Reg)
}

// OperationalAmplifier
type OPAMP_Type struct {
	_      [8]byte
	AMPMC  volatile.Register8 // 0x8
	AMPTRM volatile.Register8 // 0x9
	AMPTRS volatile.Register8 // 0xA
	AMPC   volatile.Register8 // 0xB
	AMPMON volatile.Register8 // 0xC
}

// OPAMP.AMPMC: Operational amplifier mode control register
func (o *OPAMP_Type) SetAMPMC_AMPSP(value uint8) {
	volatile.StoreUint8(&o.AMPMC.Reg, volatile.LoadUint8(&o.AMPMC.Reg)&^(0x80)|value<<7)
}
func (o *OPAMP_Type) GetAMPMC_AMPSP() uint8 {
	return (volatile.LoadUint8(&o.AMPMC.Reg) & 0x80) >> 7
}
func (o *OPAMP_Type) SetAMPMC_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMPMC.Reg, volatile.LoadUint8(&o.AMPMC.Reg)&^(0x70)|value<<4)
}
func (o *OPAMP_Type) GetAMPMC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMPMC.Reg) & 0x70) >> 4
}
func (o *OPAMP_Type) SetAMPMC_AMPPC3(value uint8) {
	volatile.StoreUint8(&o.AMPMC.Reg, volatile.LoadUint8(&o.AMPMC.Reg)&^(0x8)|value<<3)
}
func (o *OPAMP_Type) GetAMPMC_AMPPC3() uint8 {
	return (volatile.LoadUint8(&o.AMPMC.Reg) & 0x8) >> 3
}
func (o *OPAMP_Type) SetAMPMC_AMPPC2(value uint8) {
	volatile.StoreUint8(&o.AMPMC.Reg, volatile.LoadUint8(&o.AMPMC.Reg)&^(0x4)|value<<2)
}
func (o *OPAMP_Type) GetAMPMC_AMPPC2() uint8 {
	return (volatile.LoadUint8(&o.AMPMC.Reg) & 0x4) >> 2
}
func (o *OPAMP_Type) SetAMPMC_AMPPC1(value uint8) {
	volatile.StoreUint8(&o.AMPMC.Reg, volatile.LoadUint8(&o.AMPMC.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMPMC_AMPPC1() uint8 {
	return (volatile.LoadUint8(&o.AMPMC.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMPMC_AMPPC0(value uint8) {
	volatile.StoreUint8(&o.AMPMC.Reg, volatile.LoadUint8(&o.AMPMC.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMPMC_AMPPC0() uint8 {
	return volatile.LoadUint8(&o.AMPMC.Reg) & 0x1
}

// OPAMP.AMPTRM: Operational amplifier trigger mode control register
func (o *OPAMP_Type) SetAMPTRM_AMPTRM31(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x80)|value<<7)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM31() uint8 {
	return (volatile.LoadUint8(&o.AMPTRM.Reg) & 0x80) >> 7
}
func (o *OPAMP_Type) SetAMPTRM_AMPTRM30(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x40)|value<<6)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM30() uint8 {
	return (volatile.LoadUint8(&o.AMPTRM.Reg) & 0x40) >> 6
}
func (o *OPAMP_Type) SetAMPTRM_AMPTRM21(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x20)|value<<5)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM21() uint8 {
	return (volatile.LoadUint8(&o.AMPTRM.Reg) & 0x20) >> 5
}
func (o *OPAMP_Type) SetAMPTRM_AMPTRM20(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x10)|value<<4)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM20() uint8 {
	return (volatile.LoadUint8(&o.AMPTRM.Reg) & 0x10) >> 4
}
func (o *OPAMP_Type) SetAMPTRM_AMPTRM11(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x8)|value<<3)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM11() uint8 {
	return (volatile.LoadUint8(&o.AMPTRM.Reg) & 0x8) >> 3
}
func (o *OPAMP_Type) SetAMPTRM_AMPTRM10(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x4)|value<<2)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM10() uint8 {
	return (volatile.LoadUint8(&o.AMPTRM.Reg) & 0x4) >> 2
}
func (o *OPAMP_Type) SetAMPTRM_AMPTRM01(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM01() uint8 {
	return (volatile.LoadUint8(&o.AMPTRM.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMPTRM_AMPTRM00(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM00() uint8 {
	return volatile.LoadUint8(&o.AMPTRM.Reg) & 0x1
}

// OPAMP.AMPTRS: Operational Amplifier Activation Trigger Select Register
func (o *OPAMP_Type) SetAMPTRS(value uint8) {
	volatile.StoreUint8(&o.AMPTRS.Reg, volatile.LoadUint8(&o.AMPTRS.Reg)&^(0x3)|value)
}
func (o *OPAMP_Type) GetAMPTRS() uint8 {
	return volatile.LoadUint8(&o.AMPTRS.Reg) & 0x3
}

// OPAMP.AMPC: Operational amplifier control register
func (o *OPAMP_Type) SetAMPC_IREFE(value uint8) {
	volatile.StoreUint8(&o.AMPC.Reg, volatile.LoadUint8(&o.AMPC.Reg)&^(0x80)|value<<7)
}
func (o *OPAMP_Type) GetAMPC_IREFE() uint8 {
	return (volatile.LoadUint8(&o.AMPC.Reg) & 0x80) >> 7
}
func (o *OPAMP_Type) SetAMPC_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMPC.Reg, volatile.LoadUint8(&o.AMPC.Reg)&^(0x70)|value<<4)
}
func (o *OPAMP_Type) GetAMPC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMPC.Reg) & 0x70) >> 4
}
func (o *OPAMP_Type) SetAMPC_AMPE3(value uint8) {
	volatile.StoreUint8(&o.AMPC.Reg, volatile.LoadUint8(&o.AMPC.Reg)&^(0x8)|value<<3)
}
func (o *OPAMP_Type) GetAMPC_AMPE3() uint8 {
	return (volatile.LoadUint8(&o.AMPC.Reg) & 0x8) >> 3
}
func (o *OPAMP_Type) SetAMPC_AMPE2(value uint8) {
	volatile.StoreUint8(&o.AMPC.Reg, volatile.LoadUint8(&o.AMPC.Reg)&^(0x4)|value<<2)
}
func (o *OPAMP_Type) GetAMPC_AMPE2() uint8 {
	return (volatile.LoadUint8(&o.AMPC.Reg) & 0x4) >> 2
}
func (o *OPAMP_Type) SetAMPC_AMPE1(value uint8) {
	volatile.StoreUint8(&o.AMPC.Reg, volatile.LoadUint8(&o.AMPC.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMPC_AMPE1() uint8 {
	return (volatile.LoadUint8(&o.AMPC.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMPC_AMPE0(value uint8) {
	volatile.StoreUint8(&o.AMPC.Reg, volatile.LoadUint8(&o.AMPC.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMPC_AMPE0() uint8 {
	return volatile.LoadUint8(&o.AMPC.Reg) & 0x1
}

// OPAMP.AMPMON: Operational amplifier monitor register
func (o *OPAMP_Type) SetAMPMON_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMPMON.Reg, volatile.LoadUint8(&o.AMPMON.Reg)&^(0xf0)|value<<4)
}
func (o *OPAMP_Type) GetAMPMON_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMPMON.Reg) & 0xf0) >> 4
}
func (o *OPAMP_Type) SetAMPMON_AMPMON3(value uint8) {
	volatile.StoreUint8(&o.AMPMON.Reg, volatile.LoadUint8(&o.AMPMON.Reg)&^(0x8)|value<<3)
}
func (o *OPAMP_Type) GetAMPMON_AMPMON3() uint8 {
	return (volatile.LoadUint8(&o.AMPMON.Reg) & 0x8) >> 3
}
func (o *OPAMP_Type) SetAMPMON_AMPMON2(value uint8) {
	volatile.StoreUint8(&o.AMPMON.Reg, volatile.LoadUint8(&o.AMPMON.Reg)&^(0x4)|value<<2)
}
func (o *OPAMP_Type) GetAMPMON_AMPMON2() uint8 {
	return (volatile.LoadUint8(&o.AMPMON.Reg) & 0x4) >> 2
}
func (o *OPAMP_Type) SetAMPMON_AMPMON1(value uint8) {
	volatile.StoreUint8(&o.AMPMON.Reg, volatile.LoadUint8(&o.AMPMON.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMPMON_AMPMON1() uint8 {
	return (volatile.LoadUint8(&o.AMPMON.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMPMON_AMPMON0(value uint8) {
	volatile.StoreUint8(&o.AMPMON.Reg, volatile.LoadUint8(&o.AMPMON.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMPMON_AMPMON0() uint8 {
	return volatile.LoadUint8(&o.AMPMON.Reg) & 0x1
}

// Data Transfer Controller
type DTC_Type struct {
	DTCCR  volatile.Register8 // 0x0
	_      [3]byte
	DTCVBR volatile.Register32 // 0x4
	_      [4]byte
	DTCST  volatile.Register8 // 0xC
	_      byte
	DTCSTS volatile.Register16 // 0xE
}

// DTC.DTCCR: DTC Control Register
func (o *DTC_Type) SetDTCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DTCCR.Reg, volatile.LoadUint8(&o.DTCCR.Reg)&^(0xe0)|value<<5)
}
func (o *DTC_Type) GetDTCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DTCCR.Reg) & 0xe0) >> 5
}
func (o *DTC_Type) SetDTCCR_RRS(value uint8) {
	volatile.StoreUint8(&o.DTCCR.Reg, volatile.LoadUint8(&o.DTCCR.Reg)&^(0x10)|value<<4)
}
func (o *DTC_Type) GetDTCCR_RRS() uint8 {
	return (volatile.LoadUint8(&o.DTCCR.Reg) & 0x10) >> 4
}
func (o *DTC_Type) SetDTCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DTCCR.Reg, volatile.LoadUint8(&o.DTCCR.Reg)&^(0x8)|value<<3)
}
func (o *DTC_Type) GetDTCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DTCCR.Reg) & 0x8) >> 3
}
func (o *DTC_Type) SetDTCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DTCCR.Reg, volatile.LoadUint8(&o.DTCCR.Reg)&^(0x7)|value)
}
func (o *DTC_Type) GetDTCCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.DTCCR.Reg) & 0x7
}

// DTC.DTCVBR: DTC Vector Base Register
func (o *DTC_Type) SetDTCVBR(value uint32) {
	volatile.StoreUint32(&o.DTCVBR.Reg, value)
}
func (o *DTC_Type) GetDTCVBR() uint32 {
	return volatile.LoadUint32(&o.DTCVBR.Reg)
}

// DTC.DTCST: DTC Module Start Register
func (o *DTC_Type) SetDTCST_Reserved(value uint8) {
	volatile.StoreUint8(&o.DTCST.Reg, volatile.LoadUint8(&o.DTCST.Reg)&^(0xfe)|value<<1)
}
func (o *DTC_Type) GetDTCST_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DTCST.Reg) & 0xfe) >> 1
}
func (o *DTC_Type) SetDTCST(value uint8) {
	volatile.StoreUint8(&o.DTCST.Reg, volatile.LoadUint8(&o.DTCST.Reg)&^(0x1)|value)
}
func (o *DTC_Type) GetDTCST() uint8 {
	return volatile.LoadUint8(&o.DTCST.Reg) & 0x1
}

// DTC.DTCSTS: DTC Status Register
func (o *DTC_Type) SetDTCSTS_ACT(value uint16) {
	volatile.StoreUint16(&o.DTCSTS.Reg, volatile.LoadUint16(&o.DTCSTS.Reg)&^(0x8000)|value<<15)
}
func (o *DTC_Type) GetDTCSTS_ACT() uint16 {
	return (volatile.LoadUint16(&o.DTCSTS.Reg) & 0x8000) >> 15
}
func (o *DTC_Type) SetDTCSTS_Reserved(value uint16) {
	volatile.StoreUint16(&o.DTCSTS.Reg, volatile.LoadUint16(&o.DTCSTS.Reg)&^(0x7f00)|value<<8)
}
func (o *DTC_Type) GetDTCSTS_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DTCSTS.Reg) & 0x7f00) >> 8
}
func (o *DTC_Type) SetDTCSTS_VECN(value uint16) {
	volatile.StoreUint16(&o.DTCSTS.Reg, volatile.LoadUint16(&o.DTCSTS.Reg)&^(0xff)|value)
}
func (o *DTC_Type) GetDTCSTS_VECN() uint16 {
	return volatile.LoadUint16(&o.DTCSTS.Reg) & 0xff
}

// Key Interrupt Function
type KINT_Type struct {
	KRCTL volatile.Register8 // 0x0
	_     [3]byte
	KRF   volatile.Register8 // 0x4
	_     [3]byte
	KRM   volatile.Register8 // 0x8
}

// KINT.KRCTL: KEY Return Control Register
func (o *KINT_Type) SetKRCTL_KRMD(value uint8) {
	volatile.StoreUint8(&o.KRCTL.Reg, volatile.LoadUint8(&o.KRCTL.Reg)&^(0x80)|value<<7)
}
func (o *KINT_Type) GetKRCTL_KRMD() uint8 {
	return (volatile.LoadUint8(&o.KRCTL.Reg) & 0x80) >> 7
}
func (o *KINT_Type) SetKRCTL_Reserved(value uint8) {
	volatile.StoreUint8(&o.KRCTL.Reg, volatile.LoadUint8(&o.KRCTL.Reg)&^(0x7e)|value<<1)
}
func (o *KINT_Type) GetKRCTL_Reserved() uint8 {
	return (volatile.LoadUint8(&o.KRCTL.Reg) & 0x7e) >> 1
}
func (o *KINT_Type) SetKRCTL_KREG(value uint8) {
	volatile.StoreUint8(&o.KRCTL.Reg, volatile.LoadUint8(&o.KRCTL.Reg)&^(0x1)|value)
}
func (o *KINT_Type) GetKRCTL_KREG() uint8 {
	return volatile.LoadUint8(&o.KRCTL.Reg) & 0x1
}

// KINT.KRF: KEY Return Flag Register
func (o *KINT_Type) SetKRF_KRF7(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x80)|value<<7)
}
func (o *KINT_Type) GetKRF_KRF7() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x80) >> 7
}
func (o *KINT_Type) SetKRF_KRF6(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x40)|value<<6)
}
func (o *KINT_Type) GetKRF_KRF6() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x40) >> 6
}
func (o *KINT_Type) SetKRF_KRF5(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x20)|value<<5)
}
func (o *KINT_Type) GetKRF_KRF5() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x20) >> 5
}
func (o *KINT_Type) SetKRF_KRF4(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x10)|value<<4)
}
func (o *KINT_Type) GetKRF_KRF4() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x10) >> 4
}
func (o *KINT_Type) SetKRF_KRF3(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x8)|value<<3)
}
func (o *KINT_Type) GetKRF_KRF3() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x8) >> 3
}
func (o *KINT_Type) SetKRF_KRF2(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x4)|value<<2)
}
func (o *KINT_Type) GetKRF_KRF2() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x4) >> 2
}
func (o *KINT_Type) SetKRF_KRF1(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x2)|value<<1)
}
func (o *KINT_Type) GetKRF_KRF1() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x2) >> 1
}
func (o *KINT_Type) SetKRF_KRF0(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x1)|value)
}
func (o *KINT_Type) GetKRF_KRF0() uint8 {
	return volatile.LoadUint8(&o.KRF.Reg) & 0x1
}

// KINT.KRM: KEY Return Mode Register
func (o *KINT_Type) SetKRM_KRM7(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x80)|value<<7)
}
func (o *KINT_Type) GetKRM_KRM7() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x80) >> 7
}
func (o *KINT_Type) SetKRM_KRM6(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x40)|value<<6)
}
func (o *KINT_Type) GetKRM_KRM6() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x40) >> 6
}
func (o *KINT_Type) SetKRM_KRM5(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x20)|value<<5)
}
func (o *KINT_Type) GetKRM_KRM5() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x20) >> 5
}
func (o *KINT_Type) SetKRM_KRM4(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x10)|value<<4)
}
func (o *KINT_Type) GetKRM_KRM4() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x10) >> 4
}
func (o *KINT_Type) SetKRM_KRM3(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x8)|value<<3)
}
func (o *KINT_Type) GetKRM_KRM3() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x8) >> 3
}
func (o *KINT_Type) SetKRM_KRM2(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x4)|value<<2)
}
func (o *KINT_Type) GetKRM_KRM2() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x4) >> 2
}
func (o *KINT_Type) SetKRM_KRM1(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x2)|value<<1)
}
func (o *KINT_Type) GetKRM_KRM1() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x2) >> 1
}
func (o *KINT_Type) SetKRM_KRM0(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x1)|value)
}
func (o *KINT_Type) GetKRM_KRM0() uint8 {
	return volatile.LoadUint8(&o.KRM.Reg) & 0x1
}

// Constants for POEG: Port Output Enable Module for GPT
const (
	// POEGGA: POEG Group %s Setting Register
	// Position of NFCS field.
	POEG_POEGG_NFCS_Pos = 0x1e
	// Bit mask of NFCS field.
	POEG_POEGG_NFCS_Msk = 0xc0000000
	// Sampling GTETRG pin input level for three times in every PCLKB.
	POEG_POEGG_NFCS_00 = 0x0
	// Sampling GTETRG pin input level for three times in every PCLKB /8.
	POEG_POEGG_NFCS_01 = 0x1
	// Sampling GTETRG pin input level for three times in every PCLKB /32.
	POEG_POEGG_NFCS_10 = 0x2
	// Sampling GTETRG pin input level for three times in every PCLKB /128.
	POEG_POEGG_NFCS_11 = 0x3
	// Position of NFEN field.
	POEG_POEGG_NFEN_Pos = 0x1d
	// Bit mask of NFEN field.
	POEG_POEGG_NFEN_Msk = 0x20000000
	// Bit NFEN.
	POEG_POEGG_NFEN = 0x20000000
	// Filtering noise disabled
	POEG_POEGG_NFEN_0 = 0x0
	// Filtering noise enabled
	POEG_POEGG_NFEN_1 = 0x1
	// Position of INV field.
	POEG_POEGG_INV_Pos = 0x1c
	// Bit mask of INV field.
	POEG_POEGG_INV_Msk = 0x10000000
	// Bit INV.
	POEG_POEGG_INV = 0x10000000
	// GTETRG Input
	POEG_POEGG_INV_0 = 0x0
	// GTETRG Input Reversed.
	POEG_POEGG_INV_1 = 0x1
	// Position of Reserved field.
	POEG_POEGG_Reserved_Pos = 0x11
	// Bit mask of Reserved field.
	POEG_POEGG_Reserved_Msk = 0xffe0000
	// Position of ST field.
	POEG_POEGG_ST_Pos = 0x10
	// Bit mask of ST field.
	POEG_POEGG_ST_Msk = 0x10000
	// Bit ST.
	POEG_POEGG_ST = 0x10000
	// GTETRG input after filtering is 0.
	POEG_POEGG_ST_0 = 0x0
	// GTETRG input after filtering is 1.
	POEG_POEGG_ST_1 = 0x1
	// Position of OSTPE field.
	POEG_POEGG_OSTPE_Pos = 0x6
	// Bit mask of OSTPE field.
	POEG_POEGG_OSTPE_Msk = 0x40
	// Bit OSTPE.
	POEG_POEGG_OSTPE = 0x40
	// A output-disable request from the oscillation stop detection disabled.
	POEG_POEGG_OSTPE_0 = 0x0
	// A output-disable request from the oscillation stop detection enabled.
	POEG_POEGG_OSTPE_1 = 0x1
	// Position of IOCE field.
	POEG_POEGG_IOCE_Pos = 0x5
	// Bit mask of IOCE field.
	POEG_POEGG_IOCE_Msk = 0x20
	// Bit IOCE.
	POEG_POEGG_IOCE = 0x20
	// Output-disable request from the GPT disable request disabled
	POEG_POEGG_IOCE_0 = 0x0
	// Output-disable request from the GPT disable request enabled.
	POEG_POEGG_IOCE_1 = 0x1
	// Position of PIDE field.
	POEG_POEGG_PIDE_Pos = 0x4
	// Bit mask of PIDE field.
	POEG_POEGG_PIDE_Msk = 0x10
	// Bit PIDE.
	POEG_POEGG_PIDE = 0x10
	// Output-disable request from the GTETRG pins disabled
	POEG_POEGG_PIDE_0 = 0x0
	// Output-disable request from the GTETRG pins enabled.
	POEG_POEGG_PIDE_1 = 0x1
	// Position of SSF field.
	POEG_POEGG_SSF_Pos = 0x3
	// Bit mask of SSF field.
	POEG_POEGG_SSF_Msk = 0x8
	// Bit SSF.
	POEG_POEGG_SSF = 0x8
	// No output-disable request from software has occurred
	POEG_POEGG_SSF_0 = 0x0
	// Output-disable request from software occurred.
	POEG_POEGG_SSF_1 = 0x1
	// Position of OSTPF field.
	POEG_POEGG_OSTPF_Pos = 0x2
	// Bit mask of OSTPF field.
	POEG_POEGG_OSTPF_Msk = 0x4
	// Bit OSTPF.
	POEG_POEGG_OSTPF = 0x4
	// No output-disable request from oscillation stop detection has occurred
	POEG_POEGG_OSTPF_0 = 0x0
	// Output-disable request from oscillation stop detection occurred.
	POEG_POEGG_OSTPF_1 = 0x1
	// Position of IOCF field.
	POEG_POEGG_IOCF_Pos = 0x1
	// Bit mask of IOCF field.
	POEG_POEGG_IOCF_Msk = 0x2
	// Bit IOCF.
	POEG_POEGG_IOCF = 0x2
	// No output-disable request from the GPT disable request has occurred
	POEG_POEGG_IOCF_0 = 0x0
	// Output-disable request from the GPT disable request occurred.
	POEG_POEGG_IOCF_1 = 0x1
	// Position of PIDF field.
	POEG_POEGG_PIDF_Pos = 0x0
	// Bit mask of PIDF field.
	POEG_POEGG_PIDF_Msk = 0x1
	// Bit PIDF.
	POEG_POEGG_PIDF = 0x1
	// No output-disable request from the GTETRGn pin has occurred
	POEG_POEGG_PIDF_0 = 0x0
	// Output-disable request from the GTETRGn pin occurred.
	POEG_POEGG_PIDF_1 = 0x1
)

// Constants for GPT320: General PWM Timer 0 (32-bit)
const (
	// GTWP: General PWM Timer Write-Protection Register
	// Position of Reserved field.
	GPT320_GTWP_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT320_GTWP_Reserved_Msk = 0xffff0000
	// Position of PRKEY field.
	GPT320_GTWP_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	GPT320_GTWP_PRKEY_Msk = 0xff00
	// Written to these bits, the WP bits write is permitted.
	GPT320_GTWP_PRKEY_0xA5 = 0xa5
	// Position of Reserved field.
	GPT320_GTWP_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	GPT320_GTWP_Reserved_Msk = 0xfe
	// Position of WP field.
	GPT320_GTWP_WP_Pos = 0x0
	// Bit mask of WP field.
	GPT320_GTWP_WP_Msk = 0x1
	// Bit WP.
	GPT320_GTWP_WP = 0x1
	// Write to the register is enabled
	GPT320_GTWP_WP_0 = 0x0
	// Write to the register is disabled
	GPT320_GTWP_WP_1 = 0x1

	// GTSTR: General PWM Timer Software Start Register
	// Position of Reserved field.
	GPT320_GTSTR_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	GPT320_GTSTR_Reserved_Msk = 0xfffffc00
	// Position of CSTRT9 field.
	GPT320_GTSTR_CSTRT9_Pos = 0x9
	// Bit mask of CSTRT9 field.
	GPT320_GTSTR_CSTRT9_Msk = 0x200
	// Bit CSTRT9.
	GPT320_GTSTR_CSTRT9 = 0x200
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT9_0 = 0x0
	// GPT169.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT9_1 = 0x1
	// Position of CSTRT8 field.
	GPT320_GTSTR_CSTRT8_Pos = 0x8
	// Bit mask of CSTRT8 field.
	GPT320_GTSTR_CSTRT8_Msk = 0x100
	// Bit CSTRT8.
	GPT320_GTSTR_CSTRT8 = 0x100
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT8_0 = 0x0
	// GPT168.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT8_1 = 0x1
	// Position of CSTRT7 field.
	GPT320_GTSTR_CSTRT7_Pos = 0x7
	// Bit mask of CSTRT7 field.
	GPT320_GTSTR_CSTRT7_Msk = 0x80
	// Bit CSTRT7.
	GPT320_GTSTR_CSTRT7 = 0x80
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT7_0 = 0x0
	// GPT167.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT7_1 = 0x1
	// Position of CSTRT6 field.
	GPT320_GTSTR_CSTRT6_Pos = 0x6
	// Bit mask of CSTRT6 field.
	GPT320_GTSTR_CSTRT6_Msk = 0x40
	// Bit CSTRT6.
	GPT320_GTSTR_CSTRT6 = 0x40
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT6_0 = 0x0
	// GPT166.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT6_1 = 0x1
	// Position of CSTRT5 field.
	GPT320_GTSTR_CSTRT5_Pos = 0x5
	// Bit mask of CSTRT5 field.
	GPT320_GTSTR_CSTRT5_Msk = 0x20
	// Bit CSTRT5.
	GPT320_GTSTR_CSTRT5 = 0x20
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT5_0 = 0x0
	// GPT165.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT5_1 = 0x1
	// Position of CSTRT4 field.
	GPT320_GTSTR_CSTRT4_Pos = 0x4
	// Bit mask of CSTRT4 field.
	GPT320_GTSTR_CSTRT4_Msk = 0x10
	// Bit CSTRT4.
	GPT320_GTSTR_CSTRT4 = 0x10
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT4_0 = 0x0
	// GPT164.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT4_1 = 0x1
	// Position of CSTRT3 field.
	GPT320_GTSTR_CSTRT3_Pos = 0x3
	// Bit mask of CSTRT3 field.
	GPT320_GTSTR_CSTRT3_Msk = 0x8
	// Bit CSTRT3.
	GPT320_GTSTR_CSTRT3 = 0x8
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT3_0 = 0x0
	// GPT323.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT3_1 = 0x1
	// Position of CSTRT2 field.
	GPT320_GTSTR_CSTRT2_Pos = 0x2
	// Bit mask of CSTRT2 field.
	GPT320_GTSTR_CSTRT2_Msk = 0x4
	// Bit CSTRT2.
	GPT320_GTSTR_CSTRT2 = 0x4
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT2_0 = 0x0
	// GPT322.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT2_1 = 0x1
	// Position of CSTRT1 field.
	GPT320_GTSTR_CSTRT1_Pos = 0x1
	// Bit mask of CSTRT1 field.
	GPT320_GTSTR_CSTRT1_Msk = 0x2
	// Bit CSTRT1.
	GPT320_GTSTR_CSTRT1 = 0x2
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT1_0 = 0x0
	// GPT321.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT1_1 = 0x1
	// Position of CSTRT0 field.
	GPT320_GTSTR_CSTRT0_Pos = 0x0
	// Bit mask of CSTRT0 field.
	GPT320_GTSTR_CSTRT0_Msk = 0x1
	// Bit CSTRT0.
	GPT320_GTSTR_CSTRT0 = 0x1
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT0_0 = 0x0
	// GPT320.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT0_1 = 0x1

	// GTSTP: General PWM Timer Software Stop Register
	// Position of Reserved field.
	GPT320_GTSTP_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	GPT320_GTSTP_Reserved_Msk = 0xfffffc00
	// Position of CSTOP9 field.
	GPT320_GTSTP_CSTOP9_Pos = 0x9
	// Bit mask of CSTOP9 field.
	GPT320_GTSTP_CSTOP9_Msk = 0x200
	// Bit CSTOP9.
	GPT320_GTSTP_CSTOP9 = 0x200
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP9_0 = 0x0
	// GPT169.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP9_1 = 0x1
	// Position of CSTOP8 field.
	GPT320_GTSTP_CSTOP8_Pos = 0x8
	// Bit mask of CSTOP8 field.
	GPT320_GTSTP_CSTOP8_Msk = 0x100
	// Bit CSTOP8.
	GPT320_GTSTP_CSTOP8 = 0x100
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP8_0 = 0x0
	// GPT168.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP8_1 = 0x1
	// Position of CSTOP7 field.
	GPT320_GTSTP_CSTOP7_Pos = 0x7
	// Bit mask of CSTOP7 field.
	GPT320_GTSTP_CSTOP7_Msk = 0x80
	// Bit CSTOP7.
	GPT320_GTSTP_CSTOP7 = 0x80
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP7_0 = 0x0
	// GPT167.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP7_1 = 0x1
	// Position of CSTOP6 field.
	GPT320_GTSTP_CSTOP6_Pos = 0x6
	// Bit mask of CSTOP6 field.
	GPT320_GTSTP_CSTOP6_Msk = 0x40
	// Bit CSTOP6.
	GPT320_GTSTP_CSTOP6 = 0x40
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP6_0 = 0x0
	// GPT166.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP6_1 = 0x1
	// Position of CSTOP5 field.
	GPT320_GTSTP_CSTOP5_Pos = 0x5
	// Bit mask of CSTOP5 field.
	GPT320_GTSTP_CSTOP5_Msk = 0x20
	// Bit CSTOP5.
	GPT320_GTSTP_CSTOP5 = 0x20
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP5_0 = 0x0
	// GPT165.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP5_1 = 0x1
	// Position of CSTOP4 field.
	GPT320_GTSTP_CSTOP4_Pos = 0x4
	// Bit mask of CSTOP4 field.
	GPT320_GTSTP_CSTOP4_Msk = 0x10
	// Bit CSTOP4.
	GPT320_GTSTP_CSTOP4 = 0x10
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP4_0 = 0x0
	// GPT164.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP4_1 = 0x1
	// Position of CSTOP3 field.
	GPT320_GTSTP_CSTOP3_Pos = 0x3
	// Bit mask of CSTOP3 field.
	GPT320_GTSTP_CSTOP3_Msk = 0x8
	// Bit CSTOP3.
	GPT320_GTSTP_CSTOP3 = 0x8
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP3_0 = 0x0
	// GPT323.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP3_1 = 0x1
	// Position of CSTOP2 field.
	GPT320_GTSTP_CSTOP2_Pos = 0x2
	// Bit mask of CSTOP2 field.
	GPT320_GTSTP_CSTOP2_Msk = 0x4
	// Bit CSTOP2.
	GPT320_GTSTP_CSTOP2 = 0x4
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP2_0 = 0x0
	// GPT322.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP2_1 = 0x1
	// Position of CSTOP1 field.
	GPT320_GTSTP_CSTOP1_Pos = 0x1
	// Bit mask of CSTOP1 field.
	GPT320_GTSTP_CSTOP1_Msk = 0x2
	// Bit CSTOP1.
	GPT320_GTSTP_CSTOP1 = 0x2
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP1_0 = 0x0
	// GPT321.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP1_1 = 0x1
	// Position of CSTOP0 field.
	GPT320_GTSTP_CSTOP0_Pos = 0x0
	// Bit mask of CSTOP0 field.
	GPT320_GTSTP_CSTOP0_Msk = 0x1
	// Bit CSTOP0.
	GPT320_GTSTP_CSTOP0 = 0x1
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP0_0 = 0x0
	// GPT320.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP0_1 = 0x1

	// GTCLR: General PWM Timer Software Clear Register
	// Position of Reserved field.
	GPT320_GTCLR_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	GPT320_GTCLR_Reserved_Msk = 0xfffffc00
	// Position of CCLR9 field.
	GPT320_GTCLR_CCLR9_Pos = 0x9
	// Bit mask of CCLR9 field.
	GPT320_GTCLR_CCLR9_Msk = 0x200
	// Bit CCLR9.
	GPT320_GTCLR_CCLR9 = 0x200
	// No effect
	GPT320_GTCLR_CCLR9_0 = 0x0
	// GPT169.GTCNT counter clears
	GPT320_GTCLR_CCLR9_1 = 0x1
	// Position of CCLR8 field.
	GPT320_GTCLR_CCLR8_Pos = 0x8
	// Bit mask of CCLR8 field.
	GPT320_GTCLR_CCLR8_Msk = 0x100
	// Bit CCLR8.
	GPT320_GTCLR_CCLR8 = 0x100
	// No effect
	GPT320_GTCLR_CCLR8_0 = 0x0
	// GPT168.GTCNT counter clears
	GPT320_GTCLR_CCLR8_1 = 0x1
	// Position of CCLR7 field.
	GPT320_GTCLR_CCLR7_Pos = 0x7
	// Bit mask of CCLR7 field.
	GPT320_GTCLR_CCLR7_Msk = 0x80
	// Bit CCLR7.
	GPT320_GTCLR_CCLR7 = 0x80
	// No effect
	GPT320_GTCLR_CCLR7_0 = 0x0
	// GPT167.GTCNT counter clears
	GPT320_GTCLR_CCLR7_1 = 0x1
	// Position of CCLR6 field.
	GPT320_GTCLR_CCLR6_Pos = 0x6
	// Bit mask of CCLR6 field.
	GPT320_GTCLR_CCLR6_Msk = 0x40
	// Bit CCLR6.
	GPT320_GTCLR_CCLR6 = 0x40
	// No effect
	GPT320_GTCLR_CCLR6_0 = 0x0
	// GPT166.GTCNT counter clears
	GPT320_GTCLR_CCLR6_1 = 0x1
	// Position of CCLR5 field.
	GPT320_GTCLR_CCLR5_Pos = 0x5
	// Bit mask of CCLR5 field.
	GPT320_GTCLR_CCLR5_Msk = 0x20
	// Bit CCLR5.
	GPT320_GTCLR_CCLR5 = 0x20
	// No effect
	GPT320_GTCLR_CCLR5_0 = 0x0
	// GPT165.GTCNT counter clears
	GPT320_GTCLR_CCLR5_1 = 0x1
	// Position of CCLR4 field.
	GPT320_GTCLR_CCLR4_Pos = 0x4
	// Bit mask of CCLR4 field.
	GPT320_GTCLR_CCLR4_Msk = 0x10
	// Bit CCLR4.
	GPT320_GTCLR_CCLR4 = 0x10
	// No effect
	GPT320_GTCLR_CCLR4_0 = 0x0
	// GPT164.GTCNT counter clears
	GPT320_GTCLR_CCLR4_1 = 0x1
	// Position of CCLR3 field.
	GPT320_GTCLR_CCLR3_Pos = 0x3
	// Bit mask of CCLR3 field.
	GPT320_GTCLR_CCLR3_Msk = 0x8
	// Bit CCLR3.
	GPT320_GTCLR_CCLR3 = 0x8
	// No effect
	GPT320_GTCLR_CCLR3_0 = 0x0
	// GPT323.GTCNT counter clears
	GPT320_GTCLR_CCLR3_1 = 0x1
	// Position of CCLR2 field.
	GPT320_GTCLR_CCLR2_Pos = 0x2
	// Bit mask of CCLR2 field.
	GPT320_GTCLR_CCLR2_Msk = 0x4
	// Bit CCLR2.
	GPT320_GTCLR_CCLR2 = 0x4
	// No effect
	GPT320_GTCLR_CCLR2_0 = 0x0
	// GPT322.GTCNT counter clears
	GPT320_GTCLR_CCLR2_1 = 0x1
	// Position of CCLR1 field.
	GPT320_GTCLR_CCLR1_Pos = 0x1
	// Bit mask of CCLR1 field.
	GPT320_GTCLR_CCLR1_Msk = 0x2
	// Bit CCLR1.
	GPT320_GTCLR_CCLR1 = 0x2
	// No effect
	GPT320_GTCLR_CCLR1_0 = 0x0
	// GPT321.GTCNT counter clears
	GPT320_GTCLR_CCLR1_1 = 0x1
	// Position of CCLR0 field.
	GPT320_GTCLR_CCLR0_Pos = 0x0
	// Bit mask of CCLR0 field.
	GPT320_GTCLR_CCLR0_Msk = 0x1
	// Bit CCLR0.
	GPT320_GTCLR_CCLR0 = 0x1
	// No effect
	GPT320_GTCLR_CCLR0_0 = 0x0
	// GPT320.GTCNT counter clears
	GPT320_GTCLR_CCLR0_1 = 0x1

	// GTSSR: General PWM Timer Start Source Select Register
	// Position of CSTRT field.
	GPT320_GTSSR_CSTRT_Pos = 0x1f
	// Bit mask of CSTRT field.
	GPT320_GTSSR_CSTRT_Msk = 0x80000000
	// Bit CSTRT.
	GPT320_GTSSR_CSTRT = 0x80000000
	// Counter start is disable by the GTSTR register
	GPT320_GTSSR_CSTRT_0 = 0x0
	// Counter start is enable by the GTSTR register
	GPT320_GTSSR_CSTRT_1 = 0x1
	// Position of Reserved field.
	GPT320_GTSSR_Reserved_Pos = 0x18
	// Bit mask of Reserved field.
	GPT320_GTSSR_Reserved_Msk = 0x7f000000
	// Position of SSELCH field.
	GPT320_GTSSR_SSELCH_Pos = 0x17
	// Bit mask of SSELCH field.
	GPT320_GTSSR_SSELCH_Msk = 0x800000
	// Bit SSELCH.
	GPT320_GTSSR_SSELCH = 0x800000
	// Counter start is disable at the ELC_GPTH input
	GPT320_GTSSR_SSELCH_0 = 0x0
	// Counter start is enable at the ELC_GPTH input
	GPT320_GTSSR_SSELCH_1 = 0x1
	// Position of SSELCG field.
	GPT320_GTSSR_SSELCG_Pos = 0x16
	// Bit mask of SSELCG field.
	GPT320_GTSSR_SSELCG_Msk = 0x400000
	// Bit SSELCG.
	GPT320_GTSSR_SSELCG = 0x400000
	// Counter start is disable at the ELC_GPTG input
	GPT320_GTSSR_SSELCG_0 = 0x0
	// Counter start is enable at the ELC_GPTG input
	GPT320_GTSSR_SSELCG_1 = 0x1
	// Position of SSELCF field.
	GPT320_GTSSR_SSELCF_Pos = 0x15
	// Bit mask of SSELCF field.
	GPT320_GTSSR_SSELCF_Msk = 0x200000
	// Bit SSELCF.
	GPT320_GTSSR_SSELCF = 0x200000
	// Counter start is disable at the ELC_GPTF input
	GPT320_GTSSR_SSELCF_0 = 0x0
	// Counter start is enable at the ELC_GPTF input
	GPT320_GTSSR_SSELCF_1 = 0x1
	// Position of SSELCE field.
	GPT320_GTSSR_SSELCE_Pos = 0x14
	// Bit mask of SSELCE field.
	GPT320_GTSSR_SSELCE_Msk = 0x100000
	// Bit SSELCE.
	GPT320_GTSSR_SSELCE = 0x100000
	// Counter start is disable at the ELC_GPTE input
	GPT320_GTSSR_SSELCE_0 = 0x0
	// Counter start is enable at the ELC_GPTE input
	GPT320_GTSSR_SSELCE_1 = 0x1
	// Position of SSELCD field.
	GPT320_GTSSR_SSELCD_Pos = 0x13
	// Bit mask of SSELCD field.
	GPT320_GTSSR_SSELCD_Msk = 0x80000
	// Bit SSELCD.
	GPT320_GTSSR_SSELCD = 0x80000
	// Counter start is disable at the ELC_GPTD input
	GPT320_GTSSR_SSELCD_0 = 0x0
	// Counter start is enable at the ELC_GPTD input
	GPT320_GTSSR_SSELCD_1 = 0x1
	// Position of SSELCC field.
	GPT320_GTSSR_SSELCC_Pos = 0x12
	// Bit mask of SSELCC field.
	GPT320_GTSSR_SSELCC_Msk = 0x40000
	// Bit SSELCC.
	GPT320_GTSSR_SSELCC = 0x40000
	// Counter start is disable at the ELC_GPTC input
	GPT320_GTSSR_SSELCC_0 = 0x0
	// Counter start is enable at the ELC_GPTC input
	GPT320_GTSSR_SSELCC_1 = 0x1
	// Position of SSELCB field.
	GPT320_GTSSR_SSELCB_Pos = 0x11
	// Bit mask of SSELCB field.
	GPT320_GTSSR_SSELCB_Msk = 0x20000
	// Bit SSELCB.
	GPT320_GTSSR_SSELCB = 0x20000
	// Counter start is disable at the ELC_GPTB input
	GPT320_GTSSR_SSELCB_0 = 0x0
	// Counter start is enable at the ELC_GPTB input
	GPT320_GTSSR_SSELCB_1 = 0x1
	// Position of SSELCA field.
	GPT320_GTSSR_SSELCA_Pos = 0x10
	// Bit mask of SSELCA field.
	GPT320_GTSSR_SSELCA_Msk = 0x10000
	// Bit SSELCA.
	GPT320_GTSSR_SSELCA = 0x10000
	// Counter start is disable at the ELC_GPTA input
	GPT320_GTSSR_SSELCA_0 = 0x0
	// Counter start is enable at the ELC_GPTA input
	GPT320_GTSSR_SSELCA_1 = 0x1
	// Position of SSCBFAH field.
	GPT320_GTSSR_SSCBFAH_Pos = 0xf
	// Bit mask of SSCBFAH field.
	GPT320_GTSSR_SSCBFAH_Msk = 0x8000
	// Bit SSCBFAH.
	GPT320_GTSSR_SSCBFAH = 0x8000
	// Counter start is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTSSR_SSCBFAH_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTSSR_SSCBFAH_1 = 0x1
	// Position of SSCBFAL field.
	GPT320_GTSSR_SSCBFAL_Pos = 0xe
	// Bit mask of SSCBFAL field.
	GPT320_GTSSR_SSCBFAL_Msk = 0x4000
	// Bit SSCBFAL.
	GPT320_GTSSR_SSCBFAL = 0x4000
	// Counter start is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTSSR_SSCBFAL_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTSSR_SSCBFAL_1 = 0x1
	// Position of SSCBRAH field.
	GPT320_GTSSR_SSCBRAH_Pos = 0xd
	// Bit mask of SSCBRAH field.
	GPT320_GTSSR_SSCBRAH_Msk = 0x2000
	// Bit SSCBRAH.
	GPT320_GTSSR_SSCBRAH = 0x2000
	// Counter start is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTSSR_SSCBRAH_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTSSR_SSCBRAH_1 = 0x1
	// Position of SSCBRAL field.
	GPT320_GTSSR_SSCBRAL_Pos = 0xc
	// Bit mask of SSCBRAL field.
	GPT320_GTSSR_SSCBRAL_Msk = 0x1000
	// Bit SSCBRAL.
	GPT320_GTSSR_SSCBRAL = 0x1000
	// Counter start is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTSSR_SSCBRAL_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTSSR_SSCBRAL_1 = 0x1
	// Position of SSCAFBH field.
	GPT320_GTSSR_SSCAFBH_Pos = 0xb
	// Bit mask of SSCAFBH field.
	GPT320_GTSSR_SSCAFBH_Msk = 0x800
	// Bit SSCAFBH.
	GPT320_GTSSR_SSCAFBH = 0x800
	// Counter start is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTSSR_SSCAFBH_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTSSR_SSCAFBH_1 = 0x1
	// Position of SSCAFBL field.
	GPT320_GTSSR_SSCAFBL_Pos = 0xa
	// Bit mask of SSCAFBL field.
	GPT320_GTSSR_SSCAFBL_Msk = 0x400
	// Bit SSCAFBL.
	GPT320_GTSSR_SSCAFBL = 0x400
	// Counter start is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTSSR_SSCAFBL_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTSSR_SSCAFBL_1 = 0x1
	// Position of SSCARBH field.
	GPT320_GTSSR_SSCARBH_Pos = 0x9
	// Bit mask of SSCARBH field.
	GPT320_GTSSR_SSCARBH_Msk = 0x200
	// Bit SSCARBH.
	GPT320_GTSSR_SSCARBH = 0x200
	// Counter start is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTSSR_SSCARBH_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTSSR_SSCARBH_1 = 0x1
	// Position of SSCARBL field.
	GPT320_GTSSR_SSCARBL_Pos = 0x8
	// Bit mask of SSCARBL field.
	GPT320_GTSSR_SSCARBL_Msk = 0x100
	// Bit SSCARBL.
	GPT320_GTSSR_SSCARBL = 0x100
	// Counter start is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTSSR_SSCARBL_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTSSR_SSCARBL_1 = 0x1
	// Position of Reserved field.
	GPT320_GTSSR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT320_GTSSR_Reserved_Msk = 0xf0
	// Position of SSGTRGBF field.
	GPT320_GTSSR_SSGTRGBF_Pos = 0x3
	// Bit mask of SSGTRGBF field.
	GPT320_GTSSR_SSGTRGBF_Msk = 0x8
	// Bit SSGTRGBF.
	GPT320_GTSSR_SSGTRGBF = 0x8
	// Counter start is disable at the falling edge of GTETRGB input
	GPT320_GTSSR_SSGTRGBF_0 = 0x0
	// Counter start is enable at the falling edge of GTETRGB input
	GPT320_GTSSR_SSGTRGBF_1 = 0x1
	// Position of SSGTRGBR field.
	GPT320_GTSSR_SSGTRGBR_Pos = 0x2
	// Bit mask of SSGTRGBR field.
	GPT320_GTSSR_SSGTRGBR_Msk = 0x4
	// Bit SSGTRGBR.
	GPT320_GTSSR_SSGTRGBR = 0x4
	// Counter start is disable at the rising edge of GTETRGB input
	GPT320_GTSSR_SSGTRGBR_0 = 0x0
	// Counter start is enable at the rising edge of GTETRGB input
	GPT320_GTSSR_SSGTRGBR_1 = 0x1
	// Position of SSGTRGAF field.
	GPT320_GTSSR_SSGTRGAF_Pos = 0x1
	// Bit mask of SSGTRGAF field.
	GPT320_GTSSR_SSGTRGAF_Msk = 0x2
	// Bit SSGTRGAF.
	GPT320_GTSSR_SSGTRGAF = 0x2
	// Counter start is disable at the falling edge of GTETRGA input
	GPT320_GTSSR_SSGTRGAF_0 = 0x0
	// Counter start is enable at the falling edge of GTETRGA input
	GPT320_GTSSR_SSGTRGAF_1 = 0x1
	// Position of SSGTRGAR field.
	GPT320_GTSSR_SSGTRGAR_Pos = 0x0
	// Bit mask of SSGTRGAR field.
	GPT320_GTSSR_SSGTRGAR_Msk = 0x1
	// Bit SSGTRGAR.
	GPT320_GTSSR_SSGTRGAR = 0x1
	// Counter start is disable at the rising edge of GTETRGA input
	GPT320_GTSSR_SSGTRGAR_0 = 0x0
	// Counter start is enable at the rising edge of GTETRGA input
	GPT320_GTSSR_SSGTRGAR_1 = 0x1

	// GTPSR: General PWM Timer Stop Source Select Register
	// Position of CSTOP field.
	GPT320_GTPSR_CSTOP_Pos = 0x1f
	// Bit mask of CSTOP field.
	GPT320_GTPSR_CSTOP_Msk = 0x80000000
	// Bit CSTOP.
	GPT320_GTPSR_CSTOP = 0x80000000
	// Counter stop is disable by the GTSTP register
	GPT320_GTPSR_CSTOP_0 = 0x0
	// Counter stop is enable by the GTSTP register
	GPT320_GTPSR_CSTOP_1 = 0x1
	// Position of Reserved field.
	GPT320_GTPSR_Reserved_Pos = 0x18
	// Bit mask of Reserved field.
	GPT320_GTPSR_Reserved_Msk = 0x7f000000
	// Position of PSELCH field.
	GPT320_GTPSR_PSELCH_Pos = 0x17
	// Bit mask of PSELCH field.
	GPT320_GTPSR_PSELCH_Msk = 0x800000
	// Bit PSELCH.
	GPT320_GTPSR_PSELCH = 0x800000
	// Counter stop is disable at the ELC_GPTH input
	GPT320_GTPSR_PSELCH_0 = 0x0
	// Counter stop is enable at the ELC_GPTH input
	GPT320_GTPSR_PSELCH_1 = 0x1
	// Position of PSELCG field.
	GPT320_GTPSR_PSELCG_Pos = 0x16
	// Bit mask of PSELCG field.
	GPT320_GTPSR_PSELCG_Msk = 0x400000
	// Bit PSELCG.
	GPT320_GTPSR_PSELCG = 0x400000
	// Counter stop is disable at the ELC_GPTG input
	GPT320_GTPSR_PSELCG_0 = 0x0
	// Counter stop is enable at the ELC_GPTG input
	GPT320_GTPSR_PSELCG_1 = 0x1
	// Position of PSELCF field.
	GPT320_GTPSR_PSELCF_Pos = 0x15
	// Bit mask of PSELCF field.
	GPT320_GTPSR_PSELCF_Msk = 0x200000
	// Bit PSELCF.
	GPT320_GTPSR_PSELCF = 0x200000
	// Counter stop is disable at the ELC_GPTF input
	GPT320_GTPSR_PSELCF_0 = 0x0
	// Counter stop is enable at the ELC_GPTF input
	GPT320_GTPSR_PSELCF_1 = 0x1
	// Position of PSELCE field.
	GPT320_GTPSR_PSELCE_Pos = 0x14
	// Bit mask of PSELCE field.
	GPT320_GTPSR_PSELCE_Msk = 0x100000
	// Bit PSELCE.
	GPT320_GTPSR_PSELCE = 0x100000
	// Counter stop is disable at the ELC_GPTE input
	GPT320_GTPSR_PSELCE_0 = 0x0
	// Counter stop is enable at the ELC_GPTE input
	GPT320_GTPSR_PSELCE_1 = 0x1
	// Position of PSELCD field.
	GPT320_GTPSR_PSELCD_Pos = 0x13
	// Bit mask of PSELCD field.
	GPT320_GTPSR_PSELCD_Msk = 0x80000
	// Bit PSELCD.
	GPT320_GTPSR_PSELCD = 0x80000
	// Counter stop is disable at the ELC_GPTD input
	GPT320_GTPSR_PSELCD_0 = 0x0
	// Counter stop is enable at the ELC_GPTD input
	GPT320_GTPSR_PSELCD_1 = 0x1
	// Position of PSELCC field.
	GPT320_GTPSR_PSELCC_Pos = 0x12
	// Bit mask of PSELCC field.
	GPT320_GTPSR_PSELCC_Msk = 0x40000
	// Bit PSELCC.
	GPT320_GTPSR_PSELCC = 0x40000
	// Counter stop is disable at the ELC_GPTC input
	GPT320_GTPSR_PSELCC_0 = 0x0
	// Counter stop is enable at the ELC_GPTC input
	GPT320_GTPSR_PSELCC_1 = 0x1
	// Position of PSELCB field.
	GPT320_GTPSR_PSELCB_Pos = 0x11
	// Bit mask of PSELCB field.
	GPT320_GTPSR_PSELCB_Msk = 0x20000
	// Bit PSELCB.
	GPT320_GTPSR_PSELCB = 0x20000
	// Counter stop is disable at the ELC_GPTB input
	GPT320_GTPSR_PSELCB_0 = 0x0
	// Counter stop is enable at the ELC_GPTB input
	GPT320_GTPSR_PSELCB_1 = 0x1
	// Position of PSELCA field.
	GPT320_GTPSR_PSELCA_Pos = 0x10
	// Bit mask of PSELCA field.
	GPT320_GTPSR_PSELCA_Msk = 0x10000
	// Bit PSELCA.
	GPT320_GTPSR_PSELCA = 0x10000
	// Counter stop is disable at the ELC_GPTA input
	GPT320_GTPSR_PSELCA_0 = 0x0
	// Counter stop is enable at the ELC_GPTA input
	GPT320_GTPSR_PSELCA_1 = 0x1
	// Position of PSCBFAH field.
	GPT320_GTPSR_PSCBFAH_Pos = 0xf
	// Bit mask of PSCBFAH field.
	GPT320_GTPSR_PSCBFAH_Msk = 0x8000
	// Bit PSCBFAH.
	GPT320_GTPSR_PSCBFAH = 0x8000
	// Counter stop is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTPSR_PSCBFAH_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTPSR_PSCBFAH_1 = 0x1
	// Position of PSCBFAL field.
	GPT320_GTPSR_PSCBFAL_Pos = 0xe
	// Bit mask of PSCBFAL field.
	GPT320_GTPSR_PSCBFAL_Msk = 0x4000
	// Bit PSCBFAL.
	GPT320_GTPSR_PSCBFAL = 0x4000
	// Counter stop is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTPSR_PSCBFAL_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTPSR_PSCBFAL_1 = 0x1
	// Position of PSCBRAH field.
	GPT320_GTPSR_PSCBRAH_Pos = 0xd
	// Bit mask of PSCBRAH field.
	GPT320_GTPSR_PSCBRAH_Msk = 0x2000
	// Bit PSCBRAH.
	GPT320_GTPSR_PSCBRAH = 0x2000
	// Counter stop is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTPSR_PSCBRAH_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTPSR_PSCBRAH_1 = 0x1
	// Position of PSCBRAL field.
	GPT320_GTPSR_PSCBRAL_Pos = 0xc
	// Bit mask of PSCBRAL field.
	GPT320_GTPSR_PSCBRAL_Msk = 0x1000
	// Bit PSCBRAL.
	GPT320_GTPSR_PSCBRAL = 0x1000
	// Counter stop is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTPSR_PSCBRAL_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTPSR_PSCBRAL_1 = 0x1
	// Position of PSCAFBH field.
	GPT320_GTPSR_PSCAFBH_Pos = 0xb
	// Bit mask of PSCAFBH field.
	GPT320_GTPSR_PSCAFBH_Msk = 0x800
	// Bit PSCAFBH.
	GPT320_GTPSR_PSCAFBH = 0x800
	// Counter stop is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTPSR_PSCAFBH_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTPSR_PSCAFBH_1 = 0x1
	// Position of PSCAFBL field.
	GPT320_GTPSR_PSCAFBL_Pos = 0xa
	// Bit mask of PSCAFBL field.
	GPT320_GTPSR_PSCAFBL_Msk = 0x400
	// Bit PSCAFBL.
	GPT320_GTPSR_PSCAFBL = 0x400
	// Counter stop is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTPSR_PSCAFBL_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTPSR_PSCAFBL_1 = 0x1
	// Position of PSCARBH field.
	GPT320_GTPSR_PSCARBH_Pos = 0x9
	// Bit mask of PSCARBH field.
	GPT320_GTPSR_PSCARBH_Msk = 0x200
	// Bit PSCARBH.
	GPT320_GTPSR_PSCARBH = 0x200
	// Counter stop is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTPSR_PSCARBH_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTPSR_PSCARBH_1 = 0x1
	// Position of PSCARBL field.
	GPT320_GTPSR_PSCARBL_Pos = 0x8
	// Bit mask of PSCARBL field.
	GPT320_GTPSR_PSCARBL_Msk = 0x100
	// Bit PSCARBL.
	GPT320_GTPSR_PSCARBL = 0x100
	// Counter stop is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTPSR_PSCARBL_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTPSR_PSCARBL_1 = 0x1
	// Position of Reserved field.
	GPT320_GTPSR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT320_GTPSR_Reserved_Msk = 0xf0
	// Position of PSGTRGBF field.
	GPT320_GTPSR_PSGTRGBF_Pos = 0x3
	// Bit mask of PSGTRGBF field.
	GPT320_GTPSR_PSGTRGBF_Msk = 0x8
	// Bit PSGTRGBF.
	GPT320_GTPSR_PSGTRGBF = 0x8
	// Counter stop is disable at the falling edge of GTETRGB input
	GPT320_GTPSR_PSGTRGBF_0 = 0x0
	// Counter stop is enable at the falling edge of GTETRGB input
	GPT320_GTPSR_PSGTRGBF_1 = 0x1
	// Position of PSGTRGBR field.
	GPT320_GTPSR_PSGTRGBR_Pos = 0x2
	// Bit mask of PSGTRGBR field.
	GPT320_GTPSR_PSGTRGBR_Msk = 0x4
	// Bit PSGTRGBR.
	GPT320_GTPSR_PSGTRGBR = 0x4
	// Counter stop is disable at the rising edge of GTETRGB input
	GPT320_GTPSR_PSGTRGBR_0 = 0x0
	// Counter stop is enable at the rising edge of GTETRGB input
	GPT320_GTPSR_PSGTRGBR_1 = 0x1
	// Position of PSGTRGAF field.
	GPT320_GTPSR_PSGTRGAF_Pos = 0x1
	// Bit mask of PSGTRGAF field.
	GPT320_GTPSR_PSGTRGAF_Msk = 0x2
	// Bit PSGTRGAF.
	GPT320_GTPSR_PSGTRGAF = 0x2
	// Counter stop is disable at the falling edge of GTETRGA input
	GPT320_GTPSR_PSGTRGAF_0 = 0x0
	// Counter stop is enable at the falling edge of GTETRGA input
	GPT320_GTPSR_PSGTRGAF_1 = 0x1
	// Position of PSGTRGAR field.
	GPT320_GTPSR_PSGTRGAR_Pos = 0x0
	// Bit mask of PSGTRGAR field.
	GPT320_GTPSR_PSGTRGAR_Msk = 0x1
	// Bit PSGTRGAR.
	GPT320_GTPSR_PSGTRGAR = 0x1
	// Counter stop is disable at the rising edge of GTETRGA input
	GPT320_GTPSR_PSGTRGAR_0 = 0x0
	// Counter stop is enable at the rising edge of GTETRGA input
	GPT320_GTPSR_PSGTRGAR_1 = 0x1

	// GTCSR: General PWM Timer Clear Source Select Register
	// Position of CCLR field.
	GPT320_GTCSR_CCLR_Pos = 0x1f
	// Bit mask of CCLR field.
	GPT320_GTCSR_CCLR_Msk = 0x80000000
	// Bit CCLR.
	GPT320_GTCSR_CCLR = 0x80000000
	// Counter clear is disable by the GTCLR register
	GPT320_GTCSR_CCLR_0 = 0x0
	// Counter clear is enable by the GTCLR register
	GPT320_GTCSR_CCLR_1 = 0x1
	// Position of Reserved field.
	GPT320_GTCSR_Reserved_Pos = 0x18
	// Bit mask of Reserved field.
	GPT320_GTCSR_Reserved_Msk = 0x7f000000
	// Position of CSELCH field.
	GPT320_GTCSR_CSELCH_Pos = 0x17
	// Bit mask of CSELCH field.
	GPT320_GTCSR_CSELCH_Msk = 0x800000
	// Bit CSELCH.
	GPT320_GTCSR_CSELCH = 0x800000
	// Counter clear is disable at the ELC_GPTH input
	GPT320_GTCSR_CSELCH_0 = 0x0
	// Counter clear is enable at the ELC_GPTH input
	GPT320_GTCSR_CSELCH_1 = 0x1
	// Position of CSELCG field.
	GPT320_GTCSR_CSELCG_Pos = 0x16
	// Bit mask of CSELCG field.
	GPT320_GTCSR_CSELCG_Msk = 0x400000
	// Bit CSELCG.
	GPT320_GTCSR_CSELCG = 0x400000
	// Counter clear is disable at the ELC_GPTG input
	GPT320_GTCSR_CSELCG_0 = 0x0
	// Counter clear is enable at the ELC_GPTG input
	GPT320_GTCSR_CSELCG_1 = 0x1
	// Position of CSELCF field.
	GPT320_GTCSR_CSELCF_Pos = 0x15
	// Bit mask of CSELCF field.
	GPT320_GTCSR_CSELCF_Msk = 0x200000
	// Bit CSELCF.
	GPT320_GTCSR_CSELCF = 0x200000
	// Counter clear is disable at the ELC_GPTF input
	GPT320_GTCSR_CSELCF_0 = 0x0
	// Counter clear is enable at the ELC_GPTF input
	GPT320_GTCSR_CSELCF_1 = 0x1
	// Position of CSELCE field.
	GPT320_GTCSR_CSELCE_Pos = 0x14
	// Bit mask of CSELCE field.
	GPT320_GTCSR_CSELCE_Msk = 0x100000
	// Bit CSELCE.
	GPT320_GTCSR_CSELCE = 0x100000
	// Counter clear is disable at the ELC_GPTE input
	GPT320_GTCSR_CSELCE_0 = 0x0
	// Counter clear is enable at the ELC_GPTE input
	GPT320_GTCSR_CSELCE_1 = 0x1
	// Position of CSELCD field.
	GPT320_GTCSR_CSELCD_Pos = 0x13
	// Bit mask of CSELCD field.
	GPT320_GTCSR_CSELCD_Msk = 0x80000
	// Bit CSELCD.
	GPT320_GTCSR_CSELCD = 0x80000
	// Counter clear is disable at the ELC_GPTD input
	GPT320_GTCSR_CSELCD_0 = 0x0
	// Counter clear is enable at the ELC_GPTD input
	GPT320_GTCSR_CSELCD_1 = 0x1
	// Position of CSELCC field.
	GPT320_GTCSR_CSELCC_Pos = 0x12
	// Bit mask of CSELCC field.
	GPT320_GTCSR_CSELCC_Msk = 0x40000
	// Bit CSELCC.
	GPT320_GTCSR_CSELCC = 0x40000
	// Counter clear is disable at the ELC_GPTC input
	GPT320_GTCSR_CSELCC_0 = 0x0
	// Counter clear is enable at the ELC_GPTC input
	GPT320_GTCSR_CSELCC_1 = 0x1
	// Position of CSELCB field.
	GPT320_GTCSR_CSELCB_Pos = 0x11
	// Bit mask of CSELCB field.
	GPT320_GTCSR_CSELCB_Msk = 0x20000
	// Bit CSELCB.
	GPT320_GTCSR_CSELCB = 0x20000
	// Counter clear is disable at the ELC_GPTB input
	GPT320_GTCSR_CSELCB_0 = 0x0
	// Counter clear is enable at the ELC_GPTB input
	GPT320_GTCSR_CSELCB_1 = 0x1
	// Position of CSELCA field.
	GPT320_GTCSR_CSELCA_Pos = 0x10
	// Bit mask of CSELCA field.
	GPT320_GTCSR_CSELCA_Msk = 0x10000
	// Bit CSELCA.
	GPT320_GTCSR_CSELCA = 0x10000
	// Counter clear is disable at the ELC_GPTA input
	GPT320_GTCSR_CSELCA_0 = 0x0
	// Counter clear is enable at the ELC_GPTA input
	GPT320_GTCSR_CSELCA_1 = 0x1
	// Position of CSCBFAH field.
	GPT320_GTCSR_CSCBFAH_Pos = 0xf
	// Bit mask of CSCBFAH field.
	GPT320_GTCSR_CSCBFAH_Msk = 0x8000
	// Bit CSCBFAH.
	GPT320_GTCSR_CSCBFAH = 0x8000
	// Counter clear is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTCSR_CSCBFAH_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTCSR_CSCBFAH_1 = 0x1
	// Position of CSCBFAL field.
	GPT320_GTCSR_CSCBFAL_Pos = 0xe
	// Bit mask of CSCBFAL field.
	GPT320_GTCSR_CSCBFAL_Msk = 0x4000
	// Bit CSCBFAL.
	GPT320_GTCSR_CSCBFAL = 0x4000
	// Counter clear is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTCSR_CSCBFAL_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTCSR_CSCBFAL_1 = 0x1
	// Position of CSCBRAH field.
	GPT320_GTCSR_CSCBRAH_Pos = 0xd
	// Bit mask of CSCBRAH field.
	GPT320_GTCSR_CSCBRAH_Msk = 0x2000
	// Bit CSCBRAH.
	GPT320_GTCSR_CSCBRAH = 0x2000
	// Counter clear is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTCSR_CSCBRAH_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTCSR_CSCBRAH_1 = 0x1
	// Position of CSCBRAL field.
	GPT320_GTCSR_CSCBRAL_Pos = 0xc
	// Bit mask of CSCBRAL field.
	GPT320_GTCSR_CSCBRAL_Msk = 0x1000
	// Bit CSCBRAL.
	GPT320_GTCSR_CSCBRAL = 0x1000
	// Counter clear is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTCSR_CSCBRAL_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTCSR_CSCBRAL_1 = 0x1
	// Position of CSCAFBH field.
	GPT320_GTCSR_CSCAFBH_Pos = 0xb
	// Bit mask of CSCAFBH field.
	GPT320_GTCSR_CSCAFBH_Msk = 0x800
	// Bit CSCAFBH.
	GPT320_GTCSR_CSCAFBH = 0x800
	// Counter clear is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTCSR_CSCAFBH_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTCSR_CSCAFBH_1 = 0x1
	// Position of CSCAFBL field.
	GPT320_GTCSR_CSCAFBL_Pos = 0xa
	// Bit mask of CSCAFBL field.
	GPT320_GTCSR_CSCAFBL_Msk = 0x400
	// Bit CSCAFBL.
	GPT320_GTCSR_CSCAFBL = 0x400
	// Counter clear is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTCSR_CSCAFBL_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTCSR_CSCAFBL_1 = 0x1
	// Position of CSCARBH field.
	GPT320_GTCSR_CSCARBH_Pos = 0x9
	// Bit mask of CSCARBH field.
	GPT320_GTCSR_CSCARBH_Msk = 0x200
	// Bit CSCARBH.
	GPT320_GTCSR_CSCARBH = 0x200
	// Counter clear is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTCSR_CSCARBH_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTCSR_CSCARBH_1 = 0x1
	// Position of CSCARBL field.
	GPT320_GTCSR_CSCARBL_Pos = 0x8
	// Bit mask of CSCARBL field.
	GPT320_GTCSR_CSCARBL_Msk = 0x100
	// Bit CSCARBL.
	GPT320_GTCSR_CSCARBL = 0x100
	// Counter clear is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTCSR_CSCARBL_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTCSR_CSCARBL_1 = 0x1
	// Position of Reserved field.
	GPT320_GTCSR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT320_GTCSR_Reserved_Msk = 0xf0
	// Position of CSGTRGBF field.
	GPT320_GTCSR_CSGTRGBF_Pos = 0x3
	// Bit mask of CSGTRGBF field.
	GPT320_GTCSR_CSGTRGBF_Msk = 0x8
	// Bit CSGTRGBF.
	GPT320_GTCSR_CSGTRGBF = 0x8
	// Counter clear is disable at the falling edge of GTETRGB input
	GPT320_GTCSR_CSGTRGBF_0 = 0x0
	// Counter clear is enable at the falling edge of GTETRGB input
	GPT320_GTCSR_CSGTRGBF_1 = 0x1
	// Position of CSGTRGBR field.
	GPT320_GTCSR_CSGTRGBR_Pos = 0x2
	// Bit mask of CSGTRGBR field.
	GPT320_GTCSR_CSGTRGBR_Msk = 0x4
	// Bit CSGTRGBR.
	GPT320_GTCSR_CSGTRGBR = 0x4
	// Counter clear is disable at the rising edge of GTETRGB input
	GPT320_GTCSR_CSGTRGBR_0 = 0x0
	// Counter clear is enable at the rising edge of GTETRGB input
	GPT320_GTCSR_CSGTRGBR_1 = 0x1
	// Position of CSGTRGAF field.
	GPT320_GTCSR_CSGTRGAF_Pos = 0x1
	// Bit mask of CSGTRGAF field.
	GPT320_GTCSR_CSGTRGAF_Msk = 0x2
	// Bit CSGTRGAF.
	GPT320_GTCSR_CSGTRGAF = 0x2
	// Counter clear is disable at the falling edge of GTETRGA input
	GPT320_GTCSR_CSGTRGAF_0 = 0x0
	// Counter clear is enable at the falling edge of GTETRGA input
	GPT320_GTCSR_CSGTRGAF_1 = 0x1
	// Position of CSGTRGAR field.
	GPT320_GTCSR_CSGTRGAR_Pos = 0x0
	// Bit mask of CSGTRGAR field.
	GPT320_GTCSR_CSGTRGAR_Msk = 0x1
	// Bit CSGTRGAR.
	GPT320_GTCSR_CSGTRGAR = 0x1
	// Counter clear is disable at the rising edge of GTETRGA input
	GPT320_GTCSR_CSGTRGAR_0 = 0x0
	// Counter clear is enable at the rising edge of GTETRGA input
	GPT320_GTCSR_CSGTRGAR_1 = 0x1

	// GTUPSR: General PWM Timer Up Count Source Select Register
	// Position of USELCH field.
	GPT320_GTUPSR_USELCH_Pos = 0x17
	// Bit mask of USELCH field.
	GPT320_GTUPSR_USELCH_Msk = 0x800000
	// Bit USELCH.
	GPT320_GTUPSR_USELCH = 0x800000
	// Counter count up is disable at the ELC_GPTH input
	GPT320_GTUPSR_USELCH_0 = 0x0
	// Counter count up is enable at the ELC_GPTH input
	GPT320_GTUPSR_USELCH_1 = 0x1
	// Position of USELCG field.
	GPT320_GTUPSR_USELCG_Pos = 0x16
	// Bit mask of USELCG field.
	GPT320_GTUPSR_USELCG_Msk = 0x400000
	// Bit USELCG.
	GPT320_GTUPSR_USELCG = 0x400000
	// Counter count up is disable at the ELC_GPTG input
	GPT320_GTUPSR_USELCG_0 = 0x0
	// Counter count up is enable at the ELC_GPTG input
	GPT320_GTUPSR_USELCG_1 = 0x1
	// Position of USELCF field.
	GPT320_GTUPSR_USELCF_Pos = 0x15
	// Bit mask of USELCF field.
	GPT320_GTUPSR_USELCF_Msk = 0x200000
	// Bit USELCF.
	GPT320_GTUPSR_USELCF = 0x200000
	// Counter count up is disable at the ELC_GPTF input
	GPT320_GTUPSR_USELCF_0 = 0x0
	// Counter count up is enable at the ELC_GPTF input
	GPT320_GTUPSR_USELCF_1 = 0x1
	// Position of USELCE field.
	GPT320_GTUPSR_USELCE_Pos = 0x14
	// Bit mask of USELCE field.
	GPT320_GTUPSR_USELCE_Msk = 0x100000
	// Bit USELCE.
	GPT320_GTUPSR_USELCE = 0x100000
	// Counter count up is disable at the ELC_GPTE input
	GPT320_GTUPSR_USELCE_0 = 0x0
	// Counter count up is enable at the ELC_GPTE input
	GPT320_GTUPSR_USELCE_1 = 0x1
	// Position of USELCD field.
	GPT320_GTUPSR_USELCD_Pos = 0x13
	// Bit mask of USELCD field.
	GPT320_GTUPSR_USELCD_Msk = 0x80000
	// Bit USELCD.
	GPT320_GTUPSR_USELCD = 0x80000
	// Counter count up is disable at the ELC_GPTD input
	GPT320_GTUPSR_USELCD_0 = 0x0
	// Counter count up is enable at the ELC_GPTD input
	GPT320_GTUPSR_USELCD_1 = 0x1
	// Position of USELCC field.
	GPT320_GTUPSR_USELCC_Pos = 0x12
	// Bit mask of USELCC field.
	GPT320_GTUPSR_USELCC_Msk = 0x40000
	// Bit USELCC.
	GPT320_GTUPSR_USELCC = 0x40000
	// Counter count up is disable at the ELC_GPTC input
	GPT320_GTUPSR_USELCC_0 = 0x0
	// Counter count up is enable at the ELC_GPTC input
	GPT320_GTUPSR_USELCC_1 = 0x1
	// Position of USELCB field.
	GPT320_GTUPSR_USELCB_Pos = 0x11
	// Bit mask of USELCB field.
	GPT320_GTUPSR_USELCB_Msk = 0x20000
	// Bit USELCB.
	GPT320_GTUPSR_USELCB = 0x20000
	// Counter count up is disable at the ELC_GPTB input
	GPT320_GTUPSR_USELCB_0 = 0x0
	// Counter count up is enable at the ELC_GPTB input
	GPT320_GTUPSR_USELCB_1 = 0x1
	// Position of USELCA field.
	GPT320_GTUPSR_USELCA_Pos = 0x10
	// Bit mask of USELCA field.
	GPT320_GTUPSR_USELCA_Msk = 0x10000
	// Bit USELCA.
	GPT320_GTUPSR_USELCA = 0x10000
	// Counter count up is disable at the ELC_GPTA input
	GPT320_GTUPSR_USELCA_0 = 0x0
	// Counter count up is enable at the ELC_GPTA input
	GPT320_GTUPSR_USELCA_1 = 0x1
	// Position of USCBFAH field.
	GPT320_GTUPSR_USCBFAH_Pos = 0xf
	// Bit mask of USCBFAH field.
	GPT320_GTUPSR_USCBFAH_Msk = 0x8000
	// Bit USCBFAH.
	GPT320_GTUPSR_USCBFAH = 0x8000
	// Counter count up is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTUPSR_USCBFAH_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTUPSR_USCBFAH_1 = 0x1
	// Position of USCBFAL field.
	GPT320_GTUPSR_USCBFAL_Pos = 0xe
	// Bit mask of USCBFAL field.
	GPT320_GTUPSR_USCBFAL_Msk = 0x4000
	// Bit USCBFAL.
	GPT320_GTUPSR_USCBFAL = 0x4000
	// Counter count up is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTUPSR_USCBFAL_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTUPSR_USCBFAL_1 = 0x1
	// Position of USCBRAH field.
	GPT320_GTUPSR_USCBRAH_Pos = 0xd
	// Bit mask of USCBRAH field.
	GPT320_GTUPSR_USCBRAH_Msk = 0x2000
	// Bit USCBRAH.
	GPT320_GTUPSR_USCBRAH = 0x2000
	// Counter count up is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTUPSR_USCBRAH_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTUPSR_USCBRAH_1 = 0x1
	// Position of USCBRAL field.
	GPT320_GTUPSR_USCBRAL_Pos = 0xc
	// Bit mask of USCBRAL field.
	GPT320_GTUPSR_USCBRAL_Msk = 0x1000
	// Bit USCBRAL.
	GPT320_GTUPSR_USCBRAL = 0x1000
	// Counter count up is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTUPSR_USCBRAL_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTUPSR_USCBRAL_1 = 0x1
	// Position of USCAFBH field.
	GPT320_GTUPSR_USCAFBH_Pos = 0xb
	// Bit mask of USCAFBH field.
	GPT320_GTUPSR_USCAFBH_Msk = 0x800
	// Bit USCAFBH.
	GPT320_GTUPSR_USCAFBH = 0x800
	// Counter count up is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTUPSR_USCAFBH_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTUPSR_USCAFBH_1 = 0x1
	// Position of USCAFBL field.
	GPT320_GTUPSR_USCAFBL_Pos = 0xa
	// Bit mask of USCAFBL field.
	GPT320_GTUPSR_USCAFBL_Msk = 0x400
	// Bit USCAFBL.
	GPT320_GTUPSR_USCAFBL = 0x400
	// Counter count up is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTUPSR_USCAFBL_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTUPSR_USCAFBL_1 = 0x1
	// Position of USCARBH field.
	GPT320_GTUPSR_USCARBH_Pos = 0x9
	// Bit mask of USCARBH field.
	GPT320_GTUPSR_USCARBH_Msk = 0x200
	// Bit USCARBH.
	GPT320_GTUPSR_USCARBH = 0x200
	// Counter count up is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTUPSR_USCARBH_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTUPSR_USCARBH_1 = 0x1
	// Position of USCARBL field.
	GPT320_GTUPSR_USCARBL_Pos = 0x8
	// Bit mask of USCARBL field.
	GPT320_GTUPSR_USCARBL_Msk = 0x100
	// Bit USCARBL.
	GPT320_GTUPSR_USCARBL = 0x100
	// Counter count up is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTUPSR_USCARBL_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTUPSR_USCARBL_1 = 0x1
	// Position of USGTRGBF field.
	GPT320_GTUPSR_USGTRGBF_Pos = 0x3
	// Bit mask of USGTRGBF field.
	GPT320_GTUPSR_USGTRGBF_Msk = 0x8
	// Bit USGTRGBF.
	GPT320_GTUPSR_USGTRGBF = 0x8
	// Counter count up is disable at the falling edge of GTETRGB input
	GPT320_GTUPSR_USGTRGBF_0 = 0x0
	// Counter count up is enable at the falling edge of GTETRGB input
	GPT320_GTUPSR_USGTRGBF_1 = 0x1
	// Position of USGTRGBR field.
	GPT320_GTUPSR_USGTRGBR_Pos = 0x2
	// Bit mask of USGTRGBR field.
	GPT320_GTUPSR_USGTRGBR_Msk = 0x4
	// Bit USGTRGBR.
	GPT320_GTUPSR_USGTRGBR = 0x4
	// Counter count up is disable at the rising edge of GTETRGB input
	GPT320_GTUPSR_USGTRGBR_0 = 0x0
	// Counter count up is enable at the rising edge of GTETRGB input
	GPT320_GTUPSR_USGTRGBR_1 = 0x1
	// Position of USGTRGAF field.
	GPT320_GTUPSR_USGTRGAF_Pos = 0x1
	// Bit mask of USGTRGAF field.
	GPT320_GTUPSR_USGTRGAF_Msk = 0x2
	// Bit USGTRGAF.
	GPT320_GTUPSR_USGTRGAF = 0x2
	// Counter count up is disable at the falling edge of GTETRGA input
	GPT320_GTUPSR_USGTRGAF_0 = 0x0
	// Counter count up is enable at the falling edge of GTETRGA input
	GPT320_GTUPSR_USGTRGAF_1 = 0x1
	// Position of USGTRGAR field.
	GPT320_GTUPSR_USGTRGAR_Pos = 0x0
	// Bit mask of USGTRGAR field.
	GPT320_GTUPSR_USGTRGAR_Msk = 0x1
	// Bit USGTRGAR.
	GPT320_GTUPSR_USGTRGAR = 0x1
	// Counter count up is disable at the rising edge of GTETRGA input
	GPT320_GTUPSR_USGTRGAR_0 = 0x0
	// Counter count up is enable at the rising edge of GTETRGA input
	GPT320_GTUPSR_USGTRGAR_1 = 0x1

	// GTDNSR: General PWM Timer Down Count Source Select Register
	// Position of DSELCH field.
	GPT320_GTDNSR_DSELCH_Pos = 0x17
	// Bit mask of DSELCH field.
	GPT320_GTDNSR_DSELCH_Msk = 0x800000
	// Bit DSELCH.
	GPT320_GTDNSR_DSELCH = 0x800000
	// Counter count down is disable at the ELC_GPTH input
	GPT320_GTDNSR_DSELCH_0 = 0x0
	// Counter count down is enable at the ELC_GPTH input
	GPT320_GTDNSR_DSELCH_1 = 0x1
	// Position of DSELCG field.
	GPT320_GTDNSR_DSELCG_Pos = 0x16
	// Bit mask of DSELCG field.
	GPT320_GTDNSR_DSELCG_Msk = 0x400000
	// Bit DSELCG.
	GPT320_GTDNSR_DSELCG = 0x400000
	// Counter count down is disable at the ELC_GPTG input
	GPT320_GTDNSR_DSELCG_0 = 0x0
	// Counter count down is enable at the ELC_GPTG input
	GPT320_GTDNSR_DSELCG_1 = 0x1
	// Position of DSELCF field.
	GPT320_GTDNSR_DSELCF_Pos = 0x15
	// Bit mask of DSELCF field.
	GPT320_GTDNSR_DSELCF_Msk = 0x200000
	// Bit DSELCF.
	GPT320_GTDNSR_DSELCF = 0x200000
	// Counter count down is disable at the ELC_GPTF input
	GPT320_GTDNSR_DSELCF_0 = 0x0
	// Counter count down is enable at the ELC_GPTF input
	GPT320_GTDNSR_DSELCF_1 = 0x1
	// Position of DSELCE field.
	GPT320_GTDNSR_DSELCE_Pos = 0x14
	// Bit mask of DSELCE field.
	GPT320_GTDNSR_DSELCE_Msk = 0x100000
	// Bit DSELCE.
	GPT320_GTDNSR_DSELCE = 0x100000
	// Counter count down is disable at the ELC_GPTE input
	GPT320_GTDNSR_DSELCE_0 = 0x0
	// Counter count down is enable at the ELC_GPTE input
	GPT320_GTDNSR_DSELCE_1 = 0x1
	// Position of DSELCD field.
	GPT320_GTDNSR_DSELCD_Pos = 0x13
	// Bit mask of DSELCD field.
	GPT320_GTDNSR_DSELCD_Msk = 0x80000
	// Bit DSELCD.
	GPT320_GTDNSR_DSELCD = 0x80000
	// Counter count down is disable at the ELC_GPTD input
	GPT320_GTDNSR_DSELCD_0 = 0x0
	// Counter count down is enable at the ELC_GPTD input
	GPT320_GTDNSR_DSELCD_1 = 0x1
	// Position of DSELCC field.
	GPT320_GTDNSR_DSELCC_Pos = 0x12
	// Bit mask of DSELCC field.
	GPT320_GTDNSR_DSELCC_Msk = 0x40000
	// Bit DSELCC.
	GPT320_GTDNSR_DSELCC = 0x40000
	// Counter count down is disable at the ELC_GPTC input
	GPT320_GTDNSR_DSELCC_0 = 0x0
	// Counter count down is enable at the ELC_GPTC input
	GPT320_GTDNSR_DSELCC_1 = 0x1
	// Position of DSELCB field.
	GPT320_GTDNSR_DSELCB_Pos = 0x11
	// Bit mask of DSELCB field.
	GPT320_GTDNSR_DSELCB_Msk = 0x20000
	// Bit DSELCB.
	GPT320_GTDNSR_DSELCB = 0x20000
	// Counter count down is disable at the ELC_GPTB input
	GPT320_GTDNSR_DSELCB_0 = 0x0
	// Counter count down is enable at the ELC_GPTB input
	GPT320_GTDNSR_DSELCB_1 = 0x1
	// Position of DSELCA field.
	GPT320_GTDNSR_DSELCA_Pos = 0x10
	// Bit mask of DSELCA field.
	GPT320_GTDNSR_DSELCA_Msk = 0x10000
	// Bit DSELCA.
	GPT320_GTDNSR_DSELCA = 0x10000
	// Counter count down is disable at the ELC_GPTA input
	GPT320_GTDNSR_DSELCA_0 = 0x0
	// Counter count down is enable at the ELC_GPTA input
	GPT320_GTDNSR_DSELCA_1 = 0x1
	// Position of DSCBFAH field.
	GPT320_GTDNSR_DSCBFAH_Pos = 0xf
	// Bit mask of DSCBFAH field.
	GPT320_GTDNSR_DSCBFAH_Msk = 0x8000
	// Bit DSCBFAH.
	GPT320_GTDNSR_DSCBFAH = 0x8000
	// Counter count down is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTDNSR_DSCBFAH_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTDNSR_DSCBFAH_1 = 0x1
	// Position of DSCBFAL field.
	GPT320_GTDNSR_DSCBFAL_Pos = 0xe
	// Bit mask of DSCBFAL field.
	GPT320_GTDNSR_DSCBFAL_Msk = 0x4000
	// Bit DSCBFAL.
	GPT320_GTDNSR_DSCBFAL = 0x4000
	// Counter count down is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTDNSR_DSCBFAL_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTDNSR_DSCBFAL_1 = 0x1
	// Position of DSCBRAH field.
	GPT320_GTDNSR_DSCBRAH_Pos = 0xd
	// Bit mask of DSCBRAH field.
	GPT320_GTDNSR_DSCBRAH_Msk = 0x2000
	// Bit DSCBRAH.
	GPT320_GTDNSR_DSCBRAH = 0x2000
	// Counter count down is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTDNSR_DSCBRAH_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTDNSR_DSCBRAH_1 = 0x1
	// Position of DSCBRAL field.
	GPT320_GTDNSR_DSCBRAL_Pos = 0xc
	// Bit mask of DSCBRAL field.
	GPT320_GTDNSR_DSCBRAL_Msk = 0x1000
	// Bit DSCBRAL.
	GPT320_GTDNSR_DSCBRAL = 0x1000
	// Counter count down is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTDNSR_DSCBRAL_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTDNSR_DSCBRAL_1 = 0x1
	// Position of DSCAFBH field.
	GPT320_GTDNSR_DSCAFBH_Pos = 0xb
	// Bit mask of DSCAFBH field.
	GPT320_GTDNSR_DSCAFBH_Msk = 0x800
	// Bit DSCAFBH.
	GPT320_GTDNSR_DSCAFBH = 0x800
	// Counter count down is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTDNSR_DSCAFBH_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTDNSR_DSCAFBH_1 = 0x1
	// Position of DSCAFBL field.
	GPT320_GTDNSR_DSCAFBL_Pos = 0xa
	// Bit mask of DSCAFBL field.
	GPT320_GTDNSR_DSCAFBL_Msk = 0x400
	// Bit DSCAFBL.
	GPT320_GTDNSR_DSCAFBL = 0x400
	// Counter count down is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTDNSR_DSCAFBL_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTDNSR_DSCAFBL_1 = 0x1
	// Position of DSCARBH field.
	GPT320_GTDNSR_DSCARBH_Pos = 0x9
	// Bit mask of DSCARBH field.
	GPT320_GTDNSR_DSCARBH_Msk = 0x200
	// Bit DSCARBH.
	GPT320_GTDNSR_DSCARBH = 0x200
	// Counter count down is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTDNSR_DSCARBH_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTDNSR_DSCARBH_1 = 0x1
	// Position of DSCARBL field.
	GPT320_GTDNSR_DSCARBL_Pos = 0x8
	// Bit mask of DSCARBL field.
	GPT320_GTDNSR_DSCARBL_Msk = 0x100
	// Bit DSCARBL.
	GPT320_GTDNSR_DSCARBL = 0x100
	// Counter count down is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTDNSR_DSCARBL_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTDNSR_DSCARBL_1 = 0x1
	// Position of DSGTRGBF field.
	GPT320_GTDNSR_DSGTRGBF_Pos = 0x3
	// Bit mask of DSGTRGBF field.
	GPT320_GTDNSR_DSGTRGBF_Msk = 0x8
	// Bit DSGTRGBF.
	GPT320_GTDNSR_DSGTRGBF = 0x8
	// Counter count down is disable at the falling edge of GTETRGB input
	GPT320_GTDNSR_DSGTRGBF_0 = 0x0
	// Counter count down is enable at the falling edge of GTETRGB input
	GPT320_GTDNSR_DSGTRGBF_1 = 0x1
	// Position of DSGTRGBR field.
	GPT320_GTDNSR_DSGTRGBR_Pos = 0x2
	// Bit mask of DSGTRGBR field.
	GPT320_GTDNSR_DSGTRGBR_Msk = 0x4
	// Bit DSGTRGBR.
	GPT320_GTDNSR_DSGTRGBR = 0x4
	// Counter count down is disable at the rising edge of GTETRGB input
	GPT320_GTDNSR_DSGTRGBR_0 = 0x0
	// Counter count down is enable at the rising edge of GTETRGB input
	GPT320_GTDNSR_DSGTRGBR_1 = 0x1
	// Position of DSGTRGAF field.
	GPT320_GTDNSR_DSGTRGAF_Pos = 0x1
	// Bit mask of DSGTRGAF field.
	GPT320_GTDNSR_DSGTRGAF_Msk = 0x2
	// Bit DSGTRGAF.
	GPT320_GTDNSR_DSGTRGAF = 0x2
	// Counter count down is disable at the falling edge of GTETRGA input
	GPT320_GTDNSR_DSGTRGAF_0 = 0x0
	// Counter count down is enable at the falling edge of GTETRGA input
	GPT320_GTDNSR_DSGTRGAF_1 = 0x1
	// Position of DSGTRGAR field.
	GPT320_GTDNSR_DSGTRGAR_Pos = 0x0
	// Bit mask of DSGTRGAR field.
	GPT320_GTDNSR_DSGTRGAR_Msk = 0x1
	// Bit DSGTRGAR.
	GPT320_GTDNSR_DSGTRGAR = 0x1
	// Counter count down is disable at the rising edge of GTETRGA input
	GPT320_GTDNSR_DSGTRGAR_0 = 0x0
	// Counter count down is enable at the rising edge of GTETRGA input
	GPT320_GTDNSR_DSGTRGAR_1 = 0x1

	// GTICASR: General PWM Timer Input Capture Source Select Register A
	// Position of ASELCH field.
	GPT320_GTICASR_ASELCH_Pos = 0x17
	// Bit mask of ASELCH field.
	GPT320_GTICASR_ASELCH_Msk = 0x800000
	// Bit ASELCH.
	GPT320_GTICASR_ASELCH = 0x800000
	// GTCCRA input capture is disable at the ELC_GPTH input
	GPT320_GTICASR_ASELCH_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTH input
	GPT320_GTICASR_ASELCH_1 = 0x1
	// Position of ASELCG field.
	GPT320_GTICASR_ASELCG_Pos = 0x16
	// Bit mask of ASELCG field.
	GPT320_GTICASR_ASELCG_Msk = 0x400000
	// Bit ASELCG.
	GPT320_GTICASR_ASELCG = 0x400000
	// GTCCRA input capture is disable at the ELC_GPTG input
	GPT320_GTICASR_ASELCG_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTG input
	GPT320_GTICASR_ASELCG_1 = 0x1
	// Position of ASELCF field.
	GPT320_GTICASR_ASELCF_Pos = 0x15
	// Bit mask of ASELCF field.
	GPT320_GTICASR_ASELCF_Msk = 0x200000
	// Bit ASELCF.
	GPT320_GTICASR_ASELCF = 0x200000
	// GTCCRA input capture is disable at the ELC_GPTF input
	GPT320_GTICASR_ASELCF_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTF input
	GPT320_GTICASR_ASELCF_1 = 0x1
	// Position of ASELCE field.
	GPT320_GTICASR_ASELCE_Pos = 0x14
	// Bit mask of ASELCE field.
	GPT320_GTICASR_ASELCE_Msk = 0x100000
	// Bit ASELCE.
	GPT320_GTICASR_ASELCE = 0x100000
	// GTCCRA input capture is disable at the ELC_GPTE input
	GPT320_GTICASR_ASELCE_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTE input
	GPT320_GTICASR_ASELCE_1 = 0x1
	// Position of ASELCD field.
	GPT320_GTICASR_ASELCD_Pos = 0x13
	// Bit mask of ASELCD field.
	GPT320_GTICASR_ASELCD_Msk = 0x80000
	// Bit ASELCD.
	GPT320_GTICASR_ASELCD = 0x80000
	// GTCCRA input capture is disable at the ELC_GPTD input
	GPT320_GTICASR_ASELCD_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTD input
	GPT320_GTICASR_ASELCD_1 = 0x1
	// Position of ASELCC field.
	GPT320_GTICASR_ASELCC_Pos = 0x12
	// Bit mask of ASELCC field.
	GPT320_GTICASR_ASELCC_Msk = 0x40000
	// Bit ASELCC.
	GPT320_GTICASR_ASELCC = 0x40000
	// GTCCRA input capture is disable at the ELC_GPTC input
	GPT320_GTICASR_ASELCC_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTC input
	GPT320_GTICASR_ASELCC_1 = 0x1
	// Position of ASELCB field.
	GPT320_GTICASR_ASELCB_Pos = 0x11
	// Bit mask of ASELCB field.
	GPT320_GTICASR_ASELCB_Msk = 0x20000
	// Bit ASELCB.
	GPT320_GTICASR_ASELCB = 0x20000
	// GTCCRA input capture is disable at the ELC_GPTB input
	GPT320_GTICASR_ASELCB_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTB input
	GPT320_GTICASR_ASELCB_1 = 0x1
	// Position of ASELCA field.
	GPT320_GTICASR_ASELCA_Pos = 0x10
	// Bit mask of ASELCA field.
	GPT320_GTICASR_ASELCA_Msk = 0x10000
	// Bit ASELCA.
	GPT320_GTICASR_ASELCA = 0x10000
	// GTCCRA input capture is disable at the ELC_GPTA input
	GPT320_GTICASR_ASELCA_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTA input
	GPT320_GTICASR_ASELCA_1 = 0x1
	// Position of ASCBFAH field.
	GPT320_GTICASR_ASCBFAH_Pos = 0xf
	// Bit mask of ASCBFAH field.
	GPT320_GTICASR_ASCBFAH_Msk = 0x8000
	// Bit ASCBFAH.
	GPT320_GTICASR_ASCBFAH = 0x8000
	// GTCCRA input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICASR_ASCBFAH_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICASR_ASCBFAH_1 = 0x1
	// Position of ASCBFAL field.
	GPT320_GTICASR_ASCBFAL_Pos = 0xe
	// Bit mask of ASCBFAL field.
	GPT320_GTICASR_ASCBFAL_Msk = 0x4000
	// Bit ASCBFAL.
	GPT320_GTICASR_ASCBFAL = 0x4000
	// GTCCRA input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICASR_ASCBFAL_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICASR_ASCBFAL_1 = 0x1
	// Position of ASCBRAH field.
	GPT320_GTICASR_ASCBRAH_Pos = 0xd
	// Bit mask of ASCBRAH field.
	GPT320_GTICASR_ASCBRAH_Msk = 0x2000
	// Bit ASCBRAH.
	GPT320_GTICASR_ASCBRAH = 0x2000
	// GTCCRA input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICASR_ASCBRAH_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICASR_ASCBRAH_1 = 0x1
	// Position of ASCBRAL field.
	GPT320_GTICASR_ASCBRAL_Pos = 0xc
	// Bit mask of ASCBRAL field.
	GPT320_GTICASR_ASCBRAL_Msk = 0x1000
	// Bit ASCBRAL.
	GPT320_GTICASR_ASCBRAL = 0x1000
	// GTCCRA input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICASR_ASCBRAL_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICASR_ASCBRAL_1 = 0x1
	// Position of ASCAFBH field.
	GPT320_GTICASR_ASCAFBH_Pos = 0xb
	// Bit mask of ASCAFBH field.
	GPT320_GTICASR_ASCAFBH_Msk = 0x800
	// Bit ASCAFBH.
	GPT320_GTICASR_ASCAFBH = 0x800
	// GTCCRA input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICASR_ASCAFBH_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICASR_ASCAFBH_1 = 0x1
	// Position of ASCAFBL field.
	GPT320_GTICASR_ASCAFBL_Pos = 0xa
	// Bit mask of ASCAFBL field.
	GPT320_GTICASR_ASCAFBL_Msk = 0x400
	// Bit ASCAFBL.
	GPT320_GTICASR_ASCAFBL = 0x400
	// GTCCRA input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICASR_ASCAFBL_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICASR_ASCAFBL_1 = 0x1
	// Position of ASCARBH field.
	GPT320_GTICASR_ASCARBH_Pos = 0x9
	// Bit mask of ASCARBH field.
	GPT320_GTICASR_ASCARBH_Msk = 0x200
	// Bit ASCARBH.
	GPT320_GTICASR_ASCARBH = 0x200
	// GTCCRA input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICASR_ASCARBH_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICASR_ASCARBH_1 = 0x1
	// Position of ASCARBL field.
	GPT320_GTICASR_ASCARBL_Pos = 0x8
	// Bit mask of ASCARBL field.
	GPT320_GTICASR_ASCARBL_Msk = 0x100
	// Bit ASCARBL.
	GPT320_GTICASR_ASCARBL = 0x100
	// GTCCRA input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICASR_ASCARBL_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICASR_ASCARBL_1 = 0x1
	// Position of ASGTRGBF field.
	GPT320_GTICASR_ASGTRGBF_Pos = 0x3
	// Bit mask of ASGTRGBF field.
	GPT320_GTICASR_ASGTRGBF_Msk = 0x8
	// Bit ASGTRGBF.
	GPT320_GTICASR_ASGTRGBF = 0x8
	// GTCCRA input capture is disable at the falling edge of GTETRGB input
	GPT320_GTICASR_ASGTRGBF_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTETRGB input
	GPT320_GTICASR_ASGTRGBF_1 = 0x1
	// Position of ASGTRGBR field.
	GPT320_GTICASR_ASGTRGBR_Pos = 0x2
	// Bit mask of ASGTRGBR field.
	GPT320_GTICASR_ASGTRGBR_Msk = 0x4
	// Bit ASGTRGBR.
	GPT320_GTICASR_ASGTRGBR = 0x4
	// GTCCRA input capture is disable at the rising edge of GTETRGB input
	GPT320_GTICASR_ASGTRGBR_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTETRGB input
	GPT320_GTICASR_ASGTRGBR_1 = 0x1
	// Position of ASGTRGAF field.
	GPT320_GTICASR_ASGTRGAF_Pos = 0x1
	// Bit mask of ASGTRGAF field.
	GPT320_GTICASR_ASGTRGAF_Msk = 0x2
	// Bit ASGTRGAF.
	GPT320_GTICASR_ASGTRGAF = 0x2
	// GTCCRA input capture is disable at the falling edge of GTETRGA input
	GPT320_GTICASR_ASGTRGAF_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTETRGA input
	GPT320_GTICASR_ASGTRGAF_1 = 0x1
	// Position of ASGTRGAR field.
	GPT320_GTICASR_ASGTRGAR_Pos = 0x0
	// Bit mask of ASGTRGAR field.
	GPT320_GTICASR_ASGTRGAR_Msk = 0x1
	// Bit ASGTRGAR.
	GPT320_GTICASR_ASGTRGAR = 0x1
	// GTCCRA input capture is disable at the rising edge of GTETRGA input
	GPT320_GTICASR_ASGTRGAR_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTETRGA input
	GPT320_GTICASR_ASGTRGAR_1 = 0x1

	// GTICBSR: General PWM Timer Input Capture Source Select Register B
	// Position of BSELCH field.
	GPT320_GTICBSR_BSELCH_Pos = 0x17
	// Bit mask of BSELCH field.
	GPT320_GTICBSR_BSELCH_Msk = 0x800000
	// Bit BSELCH.
	GPT320_GTICBSR_BSELCH = 0x800000
	// GTCCRB input capture is disable at the ELC_GPTH input
	GPT320_GTICBSR_BSELCH_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTH input
	GPT320_GTICBSR_BSELCH_1 = 0x1
	// Position of BSELCG field.
	GPT320_GTICBSR_BSELCG_Pos = 0x16
	// Bit mask of BSELCG field.
	GPT320_GTICBSR_BSELCG_Msk = 0x400000
	// Bit BSELCG.
	GPT320_GTICBSR_BSELCG = 0x400000
	// GTCCRB input capture is disable at the ELC_GPTG input
	GPT320_GTICBSR_BSELCG_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTG input
	GPT320_GTICBSR_BSELCG_1 = 0x1
	// Position of BSELCF field.
	GPT320_GTICBSR_BSELCF_Pos = 0x15
	// Bit mask of BSELCF field.
	GPT320_GTICBSR_BSELCF_Msk = 0x200000
	// Bit BSELCF.
	GPT320_GTICBSR_BSELCF = 0x200000
	// GTCCRB input capture is disable at the ELC_GPTF input
	GPT320_GTICBSR_BSELCF_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTF input
	GPT320_GTICBSR_BSELCF_1 = 0x1
	// Position of BSELCE field.
	GPT320_GTICBSR_BSELCE_Pos = 0x14
	// Bit mask of BSELCE field.
	GPT320_GTICBSR_BSELCE_Msk = 0x100000
	// Bit BSELCE.
	GPT320_GTICBSR_BSELCE = 0x100000
	// GTCCRB input capture is disable at the ELC_GPTE input
	GPT320_GTICBSR_BSELCE_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTE input
	GPT320_GTICBSR_BSELCE_1 = 0x1
	// Position of BSELCD field.
	GPT320_GTICBSR_BSELCD_Pos = 0x13
	// Bit mask of BSELCD field.
	GPT320_GTICBSR_BSELCD_Msk = 0x80000
	// Bit BSELCD.
	GPT320_GTICBSR_BSELCD = 0x80000
	// GTCCRB input capture is disable at the ELC_GPTD input
	GPT320_GTICBSR_BSELCD_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTD input
	GPT320_GTICBSR_BSELCD_1 = 0x1
	// Position of BSELCC field.
	GPT320_GTICBSR_BSELCC_Pos = 0x12
	// Bit mask of BSELCC field.
	GPT320_GTICBSR_BSELCC_Msk = 0x40000
	// Bit BSELCC.
	GPT320_GTICBSR_BSELCC = 0x40000
	// GTCCRB input capture is disable at the ELC_GPTC input
	GPT320_GTICBSR_BSELCC_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTC input
	GPT320_GTICBSR_BSELCC_1 = 0x1
	// Position of BSELCB field.
	GPT320_GTICBSR_BSELCB_Pos = 0x11
	// Bit mask of BSELCB field.
	GPT320_GTICBSR_BSELCB_Msk = 0x20000
	// Bit BSELCB.
	GPT320_GTICBSR_BSELCB = 0x20000
	// GTCCRB input capture is disable at the ELC_GPTB input
	GPT320_GTICBSR_BSELCB_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTB input
	GPT320_GTICBSR_BSELCB_1 = 0x1
	// Position of BSELCA field.
	GPT320_GTICBSR_BSELCA_Pos = 0x10
	// Bit mask of BSELCA field.
	GPT320_GTICBSR_BSELCA_Msk = 0x10000
	// Bit BSELCA.
	GPT320_GTICBSR_BSELCA = 0x10000
	// GTCCRB input capture is disable at the ELC_GPTA input
	GPT320_GTICBSR_BSELCA_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTA input
	GPT320_GTICBSR_BSELCA_1 = 0x1
	// Position of BSCBFAH field.
	GPT320_GTICBSR_BSCBFAH_Pos = 0xf
	// Bit mask of BSCBFAH field.
	GPT320_GTICBSR_BSCBFAH_Msk = 0x8000
	// Bit BSCBFAH.
	GPT320_GTICBSR_BSCBFAH = 0x8000
	// GTCCRB input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICBSR_BSCBFAH_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICBSR_BSCBFAH_1 = 0x1
	// Position of BSCBFAL field.
	GPT320_GTICBSR_BSCBFAL_Pos = 0xe
	// Bit mask of BSCBFAL field.
	GPT320_GTICBSR_BSCBFAL_Msk = 0x4000
	// Bit BSCBFAL.
	GPT320_GTICBSR_BSCBFAL = 0x4000
	// GTCCRB input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICBSR_BSCBFAL_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICBSR_BSCBFAL_1 = 0x1
	// Position of BSCBRAH field.
	GPT320_GTICBSR_BSCBRAH_Pos = 0xd
	// Bit mask of BSCBRAH field.
	GPT320_GTICBSR_BSCBRAH_Msk = 0x2000
	// Bit BSCBRAH.
	GPT320_GTICBSR_BSCBRAH = 0x2000
	// GTCCRB input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICBSR_BSCBRAH_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICBSR_BSCBRAH_1 = 0x1
	// Position of BSCBRAL field.
	GPT320_GTICBSR_BSCBRAL_Pos = 0xc
	// Bit mask of BSCBRAL field.
	GPT320_GTICBSR_BSCBRAL_Msk = 0x1000
	// Bit BSCBRAL.
	GPT320_GTICBSR_BSCBRAL = 0x1000
	// GTCCRB input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICBSR_BSCBRAL_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICBSR_BSCBRAL_1 = 0x1
	// Position of BSCAFBH field.
	GPT320_GTICBSR_BSCAFBH_Pos = 0xb
	// Bit mask of BSCAFBH field.
	GPT320_GTICBSR_BSCAFBH_Msk = 0x800
	// Bit BSCAFBH.
	GPT320_GTICBSR_BSCAFBH = 0x800
	// GTCCRB input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICBSR_BSCAFBH_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICBSR_BSCAFBH_1 = 0x1
	// Position of BSCAFBL field.
	GPT320_GTICBSR_BSCAFBL_Pos = 0xa
	// Bit mask of BSCAFBL field.
	GPT320_GTICBSR_BSCAFBL_Msk = 0x400
	// Bit BSCAFBL.
	GPT320_GTICBSR_BSCAFBL = 0x400
	// GTCCRB input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICBSR_BSCAFBL_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICBSR_BSCAFBL_1 = 0x1
	// Position of BSCARBH field.
	GPT320_GTICBSR_BSCARBH_Pos = 0x9
	// Bit mask of BSCARBH field.
	GPT320_GTICBSR_BSCARBH_Msk = 0x200
	// Bit BSCARBH.
	GPT320_GTICBSR_BSCARBH = 0x200
	// GTCCRB input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICBSR_BSCARBH_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICBSR_BSCARBH_1 = 0x1
	// Position of BSCARBL field.
	GPT320_GTICBSR_BSCARBL_Pos = 0x8
	// Bit mask of BSCARBL field.
	GPT320_GTICBSR_BSCARBL_Msk = 0x100
	// Bit BSCARBL.
	GPT320_GTICBSR_BSCARBL = 0x100
	// GTCCRB input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICBSR_BSCARBL_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICBSR_BSCARBL_1 = 0x1
	// Position of BSGTRGBF field.
	GPT320_GTICBSR_BSGTRGBF_Pos = 0x3
	// Bit mask of BSGTRGBF field.
	GPT320_GTICBSR_BSGTRGBF_Msk = 0x8
	// Bit BSGTRGBF.
	GPT320_GTICBSR_BSGTRGBF = 0x8
	// GTCCRB input capture is disable at the falling edge of GTETRGB input
	GPT320_GTICBSR_BSGTRGBF_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTETRGB input
	GPT320_GTICBSR_BSGTRGBF_1 = 0x1
	// Position of BSGTRGBR field.
	GPT320_GTICBSR_BSGTRGBR_Pos = 0x2
	// Bit mask of BSGTRGBR field.
	GPT320_GTICBSR_BSGTRGBR_Msk = 0x4
	// Bit BSGTRGBR.
	GPT320_GTICBSR_BSGTRGBR = 0x4
	// GTCCRB input capture is disable at the rising edge of GTETRGB input
	GPT320_GTICBSR_BSGTRGBR_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTETRGB input
	GPT320_GTICBSR_BSGTRGBR_1 = 0x1
	// Position of BSGTRGAF field.
	GPT320_GTICBSR_BSGTRGAF_Pos = 0x1
	// Bit mask of BSGTRGAF field.
	GPT320_GTICBSR_BSGTRGAF_Msk = 0x2
	// Bit BSGTRGAF.
	GPT320_GTICBSR_BSGTRGAF = 0x2
	// GTCCRB input capture is disable at the falling edge of GTETRGA input
	GPT320_GTICBSR_BSGTRGAF_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTETRGA input
	GPT320_GTICBSR_BSGTRGAF_1 = 0x1
	// Position of BSGTRGAR field.
	GPT320_GTICBSR_BSGTRGAR_Pos = 0x0
	// Bit mask of BSGTRGAR field.
	GPT320_GTICBSR_BSGTRGAR_Msk = 0x1
	// Bit BSGTRGAR.
	GPT320_GTICBSR_BSGTRGAR = 0x1
	// GTCCRB input capture is disable at the rising edge of GTETRGA input
	GPT320_GTICBSR_BSGTRGAR_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTETRGA input
	GPT320_GTICBSR_BSGTRGAR_1 = 0x1

	// GTCR: General PWM Timer Control Register
	// Position of TPCS field.
	GPT320_GTCR_TPCS_Pos = 0x18
	// Bit mask of TPCS field.
	GPT320_GTCR_TPCS_Msk = 0x7000000
	// PCLK/1
	GPT320_GTCR_TPCS_000 = 0x0
	// PCLK/4
	GPT320_GTCR_TPCS_001 = 0x1
	// PCLK/16
	GPT320_GTCR_TPCS_010 = 0x2
	// PCLK/64
	GPT320_GTCR_TPCS_011 = 0x3
	// PCLK/256
	GPT320_GTCR_TPCS_100 = 0x4
	// PCLK/1024
	GPT320_GTCR_TPCS_101 = 0x5
	// Position of Reserved field.
	GPT320_GTCR_Reserved_Pos = 0x13
	// Bit mask of Reserved field.
	GPT320_GTCR_Reserved_Msk = 0xf80000
	// Position of MD field.
	GPT320_GTCR_MD_Pos = 0x10
	// Bit mask of MD field.
	GPT320_GTCR_MD_Msk = 0x70000
	// Saw-wave PWM mode (single buffer or double buffer possible)
	GPT320_GTCR_MD_000 = 0x0
	// Saw-wave one-shot pulse mode (fixed buffer operation)
	GPT320_GTCR_MD_001 = 0x1
	// Setting prohibited
	GPT320_GTCR_MD_010 = 0x2
	// Setting prohibited
	GPT320_GTCR_MD_011 = 0x3
	// Triangle-wave PWM mode 1 (16-bit transfer at crest) (single buffer or double buffer possible)
	GPT320_GTCR_MD_100 = 0x4
	// Triangle-wave PWM mode 2 (16-bit transfer at crest and trough) (single buffer or double buffer possible)
	GPT320_GTCR_MD_101 = 0x5
	// Triangle-wave PWM mode 3 (32-bit transfer at trough) fixed buffer operation)
	GPT320_GTCR_MD_110 = 0x6
	// Setting prohibited
	GPT320_GTCR_MD_111 = 0x7
	// Position of Reserved field.
	GPT320_GTCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	GPT320_GTCR_Reserved_Msk = 0xfffe
	// Position of CST field.
	GPT320_GTCR_CST_Pos = 0x0
	// Bit mask of CST field.
	GPT320_GTCR_CST_Msk = 0x1
	// Bit CST.
	GPT320_GTCR_CST = 0x1
	// Count operation is stopped
	GPT320_GTCR_CST_0 = 0x0
	// Count operation is performed
	GPT320_GTCR_CST_1 = 0x1

	// GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
	// Position of OBDTYR field.
	GPT320_GTUDDTYC_OBDTYR_Pos = 0x1b
	// Bit mask of OBDTYR field.
	GPT320_GTUDDTYC_OBDTYR_Msk = 0x8000000
	// Bit OBDTYR.
	GPT320_GTUDDTYC_OBDTYR = 0x8000000
	// Apply output value set in 0 percent/100 percent duty to GTIOB[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT320_GTUDDTYC_OBDTYR_0 = 0x0
	// Apply masked compare match output value to GTIOB[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT320_GTUDDTYC_OBDTYR_1 = 0x1
	// Position of OBDTYF field.
	GPT320_GTUDDTYC_OBDTYF_Pos = 0x1a
	// Bit mask of OBDTYF field.
	GPT320_GTUDDTYC_OBDTYF_Msk = 0x4000000
	// Bit OBDTYF.
	GPT320_GTUDDTYC_OBDTYF = 0x4000000
	// Not forcibly set
	GPT320_GTUDDTYC_OBDTYF_0 = 0x0
	// Forcibly set
	GPT320_GTUDDTYC_OBDTYF_1 = 0x1
	// Position of OBDTY field.
	GPT320_GTUDDTYC_OBDTY_Pos = 0x18
	// Bit mask of OBDTY field.
	GPT320_GTUDDTYC_OBDTY_Msk = 0x3000000
	// GTIOCB pin duty is depend on compare match
	GPT320_GTUDDTYC_OBDTY_00 = 0x0
	// GTIOCB pin duty is depend on compare match
	GPT320_GTUDDTYC_OBDTY_01 = 0x1
	// GTIOCB pin duty 0 percent
	GPT320_GTUDDTYC_OBDTY_10 = 0x2
	// GTIOCB pin duty 100 percent
	GPT320_GTUDDTYC_OBDTY_11 = 0x3
	// Position of Reserved field.
	GPT320_GTUDDTYC_Reserved_Pos = 0x14
	// Bit mask of Reserved field.
	GPT320_GTUDDTYC_Reserved_Msk = 0xf00000
	// Position of OADTYR field.
	GPT320_GTUDDTYC_OADTYR_Pos = 0x13
	// Bit mask of OADTYR field.
	GPT320_GTUDDTYC_OADTYR_Msk = 0x80000
	// Bit OADTYR.
	GPT320_GTUDDTYC_OADTYR = 0x80000
	// Apply output value set in 0 percent/100 percent duty to GTIOA[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT320_GTUDDTYC_OADTYR_0 = 0x0
	// Apply masked compare match output value to GTIOA[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT320_GTUDDTYC_OADTYR_1 = 0x1
	// Position of OADTYF field.
	GPT320_GTUDDTYC_OADTYF_Pos = 0x12
	// Bit mask of OADTYF field.
	GPT320_GTUDDTYC_OADTYF_Msk = 0x40000
	// Bit OADTYF.
	GPT320_GTUDDTYC_OADTYF = 0x40000
	// Not forcibly set
	GPT320_GTUDDTYC_OADTYF_0 = 0x0
	// Forcibly set
	GPT320_GTUDDTYC_OADTYF_1 = 0x1
	// Position of OADTY field.
	GPT320_GTUDDTYC_OADTY_Pos = 0x10
	// Bit mask of OADTY field.
	GPT320_GTUDDTYC_OADTY_Msk = 0x30000
	// GTIOCA pin duty is depend on compare match
	GPT320_GTUDDTYC_OADTY_00 = 0x0
	// GTIOCA pin duty is depend on compare match
	GPT320_GTUDDTYC_OADTY_01 = 0x1
	// GTIOCA pin duty 0 percent
	GPT320_GTUDDTYC_OADTY_10 = 0x2
	// GTIOCA pin duty 100 percent
	GPT320_GTUDDTYC_OADTY_11 = 0x3
	// Position of UDF field.
	GPT320_GTUDDTYC_UDF_Pos = 0x1
	// Bit mask of UDF field.
	GPT320_GTUDDTYC_UDF_Msk = 0x2
	// Bit UDF.
	GPT320_GTUDDTYC_UDF = 0x2
	// Not forcibly set
	GPT320_GTUDDTYC_UDF_0 = 0x0
	// Forcibly set
	GPT320_GTUDDTYC_UDF_1 = 0x1
	// Position of UD field.
	GPT320_GTUDDTYC_UD_Pos = 0x0
	// Bit mask of UD field.
	GPT320_GTUDDTYC_UD_Msk = 0x1
	// Bit UD.
	GPT320_GTUDDTYC_UD = 0x1
	// GTCNT counts down.
	GPT320_GTUDDTYC_UD_0 = 0x0
	// GTCNT counts up.
	GPT320_GTUDDTYC_UD_1 = 0x1

	// GTIOR: General PWM Timer I/O Control Register
	// Position of NFCSB field.
	GPT320_GTIOR_NFCSB_Pos = 0x1e
	// Bit mask of NFCSB field.
	GPT320_GTIOR_NFCSB_Msk = 0xc0000000
	// PCLK/1
	GPT320_GTIOR_NFCSB_00 = 0x0
	// PCLK/4
	GPT320_GTIOR_NFCSB_01 = 0x1
	// PCLK/16
	GPT320_GTIOR_NFCSB_10 = 0x2
	// PCLK/64
	GPT320_GTIOR_NFCSB_11 = 0x3
	// Position of NFBEN field.
	GPT320_GTIOR_NFBEN_Pos = 0x1d
	// Bit mask of NFBEN field.
	GPT320_GTIOR_NFBEN_Msk = 0x20000000
	// Bit NFBEN.
	GPT320_GTIOR_NFBEN = 0x20000000
	// The noise filter for the GTIOCB pin is disabled.
	GPT320_GTIOR_NFBEN_0 = 0x0
	// The noise filter for the GTIOCB pin is enabled.
	GPT320_GTIOR_NFBEN_1 = 0x1
	// Position of Reserved field.
	GPT320_GTIOR_Reserved_Pos = 0x1b
	// Bit mask of Reserved field.
	GPT320_GTIOR_Reserved_Msk = 0x18000000
	// Position of OBDF field.
	GPT320_GTIOR_OBDF_Pos = 0x19
	// Bit mask of OBDF field.
	GPT320_GTIOR_OBDF_Msk = 0x6000000
	// Output disable is prohibited.
	GPT320_GTIOR_OBDF_00 = 0x0
	// GTIOCB pin is set to Hi-Z when output disable is performed.
	GPT320_GTIOR_OBDF_01 = 0x1
	// GTIOCB pin is set to 0 when output disable is performed.
	GPT320_GTIOR_OBDF_10 = 0x2
	// GTIOCB pin is set to 1 when output disable is performed.
	GPT320_GTIOR_OBDF_11 = 0x3
	// Position of OBE field.
	GPT320_GTIOR_OBE_Pos = 0x18
	// Bit mask of OBE field.
	GPT320_GTIOR_OBE_Msk = 0x1000000
	// Bit OBE.
	GPT320_GTIOR_OBE = 0x1000000
	// Output is disabled
	GPT320_GTIOR_OBE_0 = 0x0
	// Output is enabled
	GPT320_GTIOR_OBE_1 = 0x1
	// Position of OBHLD field.
	GPT320_GTIOR_OBHLD_Pos = 0x17
	// Bit mask of OBHLD field.
	GPT320_GTIOR_OBHLD_Msk = 0x800000
	// Bit OBHLD.
	GPT320_GTIOR_OBHLD = 0x800000
	// The GTIOCB pin output level at start/stop of counting depends on the register setting.
	GPT320_GTIOR_OBHLD_0 = 0x0
	// The GTIOCB pin output level is retained at start/stop of counting.
	GPT320_GTIOR_OBHLD_1 = 0x1
	// Position of OBDFLT field.
	GPT320_GTIOR_OBDFLT_Pos = 0x16
	// Bit mask of OBDFLT field.
	GPT320_GTIOR_OBDFLT_Msk = 0x400000
	// Bit OBDFLT.
	GPT320_GTIOR_OBDFLT = 0x400000
	// The GTIOCB pin outputs low when counting is stopped.
	GPT320_GTIOR_OBDFLT_0 = 0x0
	// The GTIOCB pin outputs high when counting is stopped.
	GPT320_GTIOR_OBDFLT_1 = 0x1
	// Position of Reserved field.
	GPT320_GTIOR_Reserved_Pos = 0x15
	// Bit mask of Reserved field.
	GPT320_GTIOR_Reserved_Msk = 0x200000
	// Bit Reserved.
	GPT320_GTIOR_Reserved = 0x200000
	// Position of GTIOB field.
	GPT320_GTIOR_GTIOB_Pos = 0x10
	// Bit mask of GTIOB field.
	GPT320_GTIOR_GTIOB_Msk = 0x1f0000
	// Initial output is Low. Output retained at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00000 = 0x0
	// Initial output is Low. Output retained at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00001 = 0x1
	// Initial output is Low. Output retained at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00010 = 0x2
	// Initial output is Low. Output retained at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00011 = 0x3
	// Initial output is Low. Low output at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00100 = 0x4
	// Initial output is Low. Low output at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00101 = 0x5
	// Initial output is Low. Low output at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00110 = 0x6
	// Initial output is Low. Low output at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00111 = 0x7
	// Initial output is Low. High output at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01000 = 0x8
	// Initial output is Low. High output at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01001 = 0x9
	// Initial output is Low. High output at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01010 = 0xa
	// Initial output is Low. High output at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01011 = 0xb
	// Initial output is Low. Output toggled at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01100 = 0xc
	// Initial output is Low. Output toggled at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01101 = 0xd
	// Initial output is Low. Output toggled at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01110 = 0xe
	// Initial output is Low. Output toggled at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01111 = 0xf
	// Initial output is High. Output retained at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10000 = 0x10
	// Initial output is High. Output retained at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10001 = 0x11
	// Initial output is High. Output retained at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10010 = 0x12
	// Initial output is High. Output retained at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10011 = 0x13
	// Initial output is High. Low output at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10100 = 0x14
	// Initial output is High. Low output at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10101 = 0x15
	// Initial output is High. Low output at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10110 = 0x16
	// Initial output is High. Low output at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10111 = 0x17
	// Initial output is High. High output at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11000 = 0x18
	// Initial output is High. High output at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11001 = 0x19
	// Initial output is High. High output at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11010 = 0x1a
	// Initial output is High. High output at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11011 = 0x1b
	// Initial output is High. Output toggled at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11100 = 0x1c
	// Initial output is High. Output toggled at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11101 = 0x1d
	// Initial output is High. Output toggled at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11110 = 0x1e
	// Initial output is High. Output toggled at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11111 = 0x1f
	// Position of NFCSA field.
	GPT320_GTIOR_NFCSA_Pos = 0xe
	// Bit mask of NFCSA field.
	GPT320_GTIOR_NFCSA_Msk = 0xc000
	// PCLK/1
	GPT320_GTIOR_NFCSA_00 = 0x0
	// PCLK/4
	GPT320_GTIOR_NFCSA_01 = 0x1
	// PCLK/16
	GPT320_GTIOR_NFCSA_10 = 0x2
	// PCLK/64
	GPT320_GTIOR_NFCSA_11 = 0x3
	// Position of NFAEN field.
	GPT320_GTIOR_NFAEN_Pos = 0xd
	// Bit mask of NFAEN field.
	GPT320_GTIOR_NFAEN_Msk = 0x2000
	// Bit NFAEN.
	GPT320_GTIOR_NFAEN = 0x2000
	// The noise filter for the GTIOCA pin is disabled.
	GPT320_GTIOR_NFAEN_0 = 0x0
	// The noise filter for the GTIOCA pin is enabled.
	GPT320_GTIOR_NFAEN_1 = 0x1
	// Position of Reserved field.
	GPT320_GTIOR_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	GPT320_GTIOR_Reserved_Msk = 0x1800
	// Position of OADF field.
	GPT320_GTIOR_OADF_Pos = 0x9
	// Bit mask of OADF field.
	GPT320_GTIOR_OADF_Msk = 0x600
	// Output disable is prohibited.
	GPT320_GTIOR_OADF_00 = 0x0
	// GTIOCA pin is set to Hi-Z when output disable is performed.
	GPT320_GTIOR_OADF_01 = 0x1
	// GTIOCA pin is set to 0 when output disable is performed.
	GPT320_GTIOR_OADF_10 = 0x2
	// GTIOCA pin is set to 1 when output disable is performed.
	GPT320_GTIOR_OADF_11 = 0x3
	// Position of OAE field.
	GPT320_GTIOR_OAE_Pos = 0x8
	// Bit mask of OAE field.
	GPT320_GTIOR_OAE_Msk = 0x100
	// Bit OAE.
	GPT320_GTIOR_OAE = 0x100
	// Output is disabled
	GPT320_GTIOR_OAE_0 = 0x0
	// Output is enabled
	GPT320_GTIOR_OAE_1 = 0x1
	// Position of OAHLD field.
	GPT320_GTIOR_OAHLD_Pos = 0x7
	// Bit mask of OAHLD field.
	GPT320_GTIOR_OAHLD_Msk = 0x80
	// Bit OAHLD.
	GPT320_GTIOR_OAHLD = 0x80
	// The GTIOCA pin output level at start/stop of counting depends on the register setting.
	GPT320_GTIOR_OAHLD_0 = 0x0
	// The GTIOCA pin output level is retained at start/stop of counting.
	GPT320_GTIOR_OAHLD_1 = 0x1
	// Position of OADFLT field.
	GPT320_GTIOR_OADFLT_Pos = 0x6
	// Bit mask of OADFLT field.
	GPT320_GTIOR_OADFLT_Msk = 0x40
	// Bit OADFLT.
	GPT320_GTIOR_OADFLT = 0x40
	// The GTIOCA pin outputs low when counting is stopped.
	GPT320_GTIOR_OADFLT_0 = 0x0
	// The GTIOCA pin outputs high when counting is stopped.
	GPT320_GTIOR_OADFLT_1 = 0x1
	// Position of Reserved field.
	GPT320_GTIOR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	GPT320_GTIOR_Reserved_Msk = 0x20
	// Bit Reserved.
	GPT320_GTIOR_Reserved = 0x20
	// Position of GTIOA field.
	GPT320_GTIOR_GTIOA_Pos = 0x0
	// Bit mask of GTIOA field.
	GPT320_GTIOR_GTIOA_Msk = 0x1f
	// Initial output is Low. Output retained at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00000 = 0x0
	// Initial output is Low. Output retained at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00001 = 0x1
	// Initial output is Low. Output retained at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00010 = 0x2
	// Initial output is Low. Output retained at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00011 = 0x3
	// Initial output is Low. Low output at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00100 = 0x4
	// Initial output is Low. Low output at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00101 = 0x5
	// Initial output is Low. Low output at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00110 = 0x6
	// Initial output is Low. Low output at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00111 = 0x7
	// Initial output is Low. High output at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01000 = 0x8
	// Initial output is Low. High output at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01001 = 0x9
	// Initial output is Low. High output at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01010 = 0xa
	// Initial output is Low. High output at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01011 = 0xb
	// Initial output is Low. Output toggled at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01100 = 0xc
	// Initial output is Low. Output toggled at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01101 = 0xd
	// Initial output is Low. Output toggled at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01110 = 0xe
	// Initial output is Low. Output toggled at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01111 = 0xf
	// Initial output is High. Output retained at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10000 = 0x10
	// Initial output is High. Output retained at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10001 = 0x11
	// Initial output is High. Output retained at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10010 = 0x12
	// Initial output is High. Output retained at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10011 = 0x13
	// Initial output is High. Low output at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10100 = 0x14
	// Initial output is High. Low output at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10101 = 0x15
	// Initial output is High. Low output at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10110 = 0x16
	// Initial output is High. Low output at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10111 = 0x17
	// Initial output is High. High output at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11000 = 0x18
	// Initial output is High. High output at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11001 = 0x19
	// Initial output is High. High output at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11010 = 0x1a
	// Initial output is High. High output at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11011 = 0x1b
	// Initial output is High. Output toggled at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11100 = 0x1c
	// Initial output is High. Output toggled at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11101 = 0x1d
	// Initial output is High. Output toggled at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11110 = 0x1e
	// Initial output is High. Output toggled at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11111 = 0x1f

	// GTINTAD: General PWM Timer Interrupt Output Setting Register
	// Position of GRPABL field.
	GPT320_GTINTAD_GRPABL_Pos = 0x1e
	// Bit mask of GRPABL field.
	GPT320_GTINTAD_GRPABL_Msk = 0x40000000
	// Bit GRPABL.
	GPT320_GTINTAD_GRPABL = 0x40000000
	// Same time output level low disable request is disabled.
	GPT320_GTINTAD_GRPABL_0 = 0x0
	// Same time output level low disable request is enabled.
	GPT320_GTINTAD_GRPABL_1 = 0x1
	// Position of GRPABH field.
	GPT320_GTINTAD_GRPABH_Pos = 0x1d
	// Bit mask of GRPABH field.
	GPT320_GTINTAD_GRPABH_Msk = 0x20000000
	// Bit GRPABH.
	GPT320_GTINTAD_GRPABH = 0x20000000
	// Same time output level high disable request is disabled.
	GPT320_GTINTAD_GRPABH_0 = 0x0
	// Same time output level high disable request is enabled.
	GPT320_GTINTAD_GRPABH_1 = 0x1
	// Position of Reserved field.
	GPT320_GTINTAD_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	GPT320_GTINTAD_Reserved_Msk = 0x1c000000
	// Position of GRP field.
	GPT320_GTINTAD_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT320_GTINTAD_GRP_Msk = 0x3000000
	// Group A output disable request
	GPT320_GTINTAD_GRP_00 = 0x0
	// Group B output disable request
	GPT320_GTINTAD_GRP_01 = 0x1
	// Position of Reserved field.
	GPT320_GTINTAD_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	GPT320_GTINTAD_Reserved_Msk = 0xffffff

	// GTST: General PWM Timer Status Register
	// Position of OABLF field.
	GPT320_GTST_OABLF_Pos = 0x1e
	// Bit mask of OABLF field.
	GPT320_GTST_OABLF_Msk = 0x40000000
	// Bit OABLF.
	GPT320_GTST_OABLF = 0x40000000
	// GTIOCA pin and GTIOCB pin don't output 0 at the same time.
	GPT320_GTST_OABLF_0 = 0x0
	// GTIOCA pin and GTIOCB pin output 0 at the same time.
	GPT320_GTST_OABLF_1 = 0x1
	// Position of OABHF field.
	GPT320_GTST_OABHF_Pos = 0x1d
	// Bit mask of OABHF field.
	GPT320_GTST_OABHF_Msk = 0x20000000
	// Bit OABHF.
	GPT320_GTST_OABHF = 0x20000000
	// GTIOCA pin and GTIOCB pin don't output 1 at the same time.
	GPT320_GTST_OABHF_0 = 0x0
	// GTIOCA pin and GTIOCB pin output 1 at the same time.
	GPT320_GTST_OABHF_1 = 0x1
	// Position of Reserved field.
	GPT320_GTST_Reserved_Pos = 0x19
	// Bit mask of Reserved field.
	GPT320_GTST_Reserved_Msk = 0x1e000000
	// Position of ODF field.
	GPT320_GTST_ODF_Pos = 0x18
	// Bit mask of ODF field.
	GPT320_GTST_ODF_Msk = 0x1000000
	// Bit ODF.
	GPT320_GTST_ODF = 0x1000000
	// No output disable request is generated.
	GPT320_GTST_ODF_0 = 0x0
	// An output disable request is generated.
	GPT320_GTST_ODF_1 = 0x1
	// Position of Reserved field.
	GPT320_GTST_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT320_GTST_Reserved_Msk = 0xff0000
	// Position of TUCF field.
	GPT320_GTST_TUCF_Pos = 0xf
	// Bit mask of TUCF field.
	GPT320_GTST_TUCF_Msk = 0x8000
	// Bit TUCF.
	GPT320_GTST_TUCF = 0x8000
	// The GTCNT counter counts downward.
	GPT320_GTST_TUCF_0 = 0x0
	// The GTCNT counter counts upward.
	GPT320_GTST_TUCF_1 = 0x1
	// Position of Reserved field.
	GPT320_GTST_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	GPT320_GTST_Reserved_Msk = 0x7f00
	// Position of TCFPU field.
	GPT320_GTST_TCFPU_Pos = 0x7
	// Bit mask of TCFPU field.
	GPT320_GTST_TCFPU_Msk = 0x80
	// Bit TCFPU.
	GPT320_GTST_TCFPU = 0x80
	// No underflow (trough) has occurred.
	GPT320_GTST_TCFPU_0 = 0x0
	// An underflow (trough) has occurred.
	GPT320_GTST_TCFPU_1 = 0x1
	// Position of TCPFO field.
	GPT320_GTST_TCPFO_Pos = 0x6
	// Bit mask of TCPFO field.
	GPT320_GTST_TCPFO_Msk = 0x40
	// Bit TCPFO.
	GPT320_GTST_TCPFO = 0x40
	// No overflow (crest) has occurred.
	GPT320_GTST_TCPFO_0 = 0x0
	// An overflow (crest) has occurred.
	GPT320_GTST_TCPFO_1 = 0x1
	// Position of TCFF field.
	GPT320_GTST_TCFF_Pos = 0x5
	// Bit mask of TCFF field.
	GPT320_GTST_TCFF_Msk = 0x20
	// Bit TCFF.
	GPT320_GTST_TCFF = 0x20
	// No compare match of GTCCRF is generated.
	GPT320_GTST_TCFF_0 = 0x0
	// A compare match of GTCCRF is generated.
	GPT320_GTST_TCFF_1 = 0x1
	// Position of TCFE field.
	GPT320_GTST_TCFE_Pos = 0x4
	// Bit mask of TCFE field.
	GPT320_GTST_TCFE_Msk = 0x10
	// Bit TCFE.
	GPT320_GTST_TCFE = 0x10
	// No compare match of GTCCRE is generated.
	GPT320_GTST_TCFE_0 = 0x0
	// A compare match of GTCCRE is generated.
	GPT320_GTST_TCFE_1 = 0x1
	// Position of TCFD field.
	GPT320_GTST_TCFD_Pos = 0x3
	// Bit mask of TCFD field.
	GPT320_GTST_TCFD_Msk = 0x8
	// Bit TCFD.
	GPT320_GTST_TCFD = 0x8
	// No compare match of GTCCRD is generated.
	GPT320_GTST_TCFD_0 = 0x0
	// A compare match of GTCCRD is generated.
	GPT320_GTST_TCFD_1 = 0x1
	// Position of TCFC field.
	GPT320_GTST_TCFC_Pos = 0x2
	// Bit mask of TCFC field.
	GPT320_GTST_TCFC_Msk = 0x4
	// Bit TCFC.
	GPT320_GTST_TCFC = 0x4
	// No compare match of GTCCRC is generated.
	GPT320_GTST_TCFC_0 = 0x0
	// A compare match of GTCCRC is generated.
	GPT320_GTST_TCFC_1 = 0x1
	// Position of TCFB field.
	GPT320_GTST_TCFB_Pos = 0x1
	// Bit mask of TCFB field.
	GPT320_GTST_TCFB_Msk = 0x2
	// Bit TCFB.
	GPT320_GTST_TCFB = 0x2
	// No input capture/compare match of GTCCRB is generated.
	GPT320_GTST_TCFB_0 = 0x0
	// An input capture/compare match of GTCCRB is generated.
	GPT320_GTST_TCFB_1 = 0x1
	// Position of TCFA field.
	GPT320_GTST_TCFA_Pos = 0x0
	// Bit mask of TCFA field.
	GPT320_GTST_TCFA_Msk = 0x1
	// Bit TCFA.
	GPT320_GTST_TCFA = 0x1
	// No input capture/compare match of GTCCRA is generated.
	GPT320_GTST_TCFA_0 = 0x0
	// An input capture/compare match of GTCCRA is generated.
	GPT320_GTST_TCFA_1 = 0x1

	// GTBER: General PWM Timer Buffer Enable Register
	// Position of CCRSWT field.
	GPT320_GTBER_CCRSWT_Pos = 0x16
	// Bit mask of CCRSWT field.
	GPT320_GTBER_CCRSWT_Msk = 0x400000
	// Bit CCRSWT.
	GPT320_GTBER_CCRSWT = 0x400000
	// no effect
	GPT320_GTBER_CCRSWT_0 = 0x0
	// Forcibly performs buffer transfer of GTCCRA and GTCCRB. This bit automatically returns to 0 after the writing of 1.
	GPT320_GTBER_CCRSWT_1 = 0x1
	// Position of PR field.
	GPT320_GTBER_PR_Pos = 0x14
	// Bit mask of PR field.
	GPT320_GTBER_PR_Msk = 0x300000
	// Buffer operation is not performed
	GPT320_GTBER_PR_00 = 0x0
	// Single buffer operation (GTPBR --> GTPR)
	GPT320_GTBER_PR_01 = 0x1
	// Position of CCRB field.
	GPT320_GTBER_CCRB_Pos = 0x12
	// Bit mask of CCRB field.
	GPT320_GTBER_CCRB_Msk = 0xc0000
	// Buffer operation is not performed
	GPT320_GTBER_CCRB_00 = 0x0
	// Single buffer operation (GTCCRB <--> GTCCRE)
	GPT320_GTBER_CCRB_01 = 0x1
	// Double buffer operation (GTCCRB <--> GTCCRE <--> GTCCRF)
	GPT320_GTBER_CCRB_10 = 0x2
	// Double buffer operation (GTCCRB <--> GTCCRE <--> GTCCRF)
	GPT320_GTBER_CCRB_11 = 0x3
	// Position of CCRA field.
	GPT320_GTBER_CCRA_Pos = 0x10
	// Bit mask of CCRA field.
	GPT320_GTBER_CCRA_Msk = 0x30000
	// Buffer operation is not performed
	GPT320_GTBER_CCRA_00 = 0x0
	// Single buffer operation (GTCCRA <--> GTCCRC)
	GPT320_GTBER_CCRA_01 = 0x1
	// Double buffer operation (GTCCRA <--> GTCCRC <--> GTCCRD)
	GPT320_GTBER_CCRA_10 = 0x2
	// Double buffer operation (GTCCRA <--> GTCCRC <--> GTCCRD)
	GPT320_GTBER_CCRA_11 = 0x3
	// Position of BD field.
	GPT320_GTBER_BD_Pos = 0x0
	// Bit mask of BD field.
	GPT320_GTBER_BD_Msk = 0x3
	// Buffer operation is enabled
	GPT320_GTBER_BD_0 = 0x0
	// Buffer operation is disabled
	GPT320_GTBER_BD_1 = 0x1

	// GTCNT: General PWM Timer Counter
	// Position of GTCNT field.
	GPT320_GTCNT_GTCNT_Pos = 0x0
	// Bit mask of GTCNT field.
	GPT320_GTCNT_GTCNT_Msk = 0xffffffff

	// GTCCRA: General PWM Timer Compare Capture Register A
	// Position of GTCCRA field.
	GPT320_GTCCRA_GTCCRA_Pos = 0x0
	// Bit mask of GTCCRA field.
	GPT320_GTCCRA_GTCCRA_Msk = 0xffffffff

	// GTCCRB: General PWM Timer Compare Capture Register B
	// Position of GTCCRB field.
	GPT320_GTCCRB_GTCCRB_Pos = 0x0
	// Bit mask of GTCCRB field.
	GPT320_GTCCRB_GTCCRB_Msk = 0xffffffff

	// GTCCRC: General PWM Timer Compare Capture Register C
	// Position of GTCCRC field.
	GPT320_GTCCRC_GTCCRC_Pos = 0x0
	// Bit mask of GTCCRC field.
	GPT320_GTCCRC_GTCCRC_Msk = 0xffffffff

	// GTCCRE: General PWM Timer Compare Capture Register E
	// Position of GTCCRE field.
	GPT320_GTCCRE_GTCCRE_Pos = 0x0
	// Bit mask of GTCCRE field.
	GPT320_GTCCRE_GTCCRE_Msk = 0xffffffff

	// GTCCRD: General PWM Timer Compare Capture Register D
	// Position of GTCCRD field.
	GPT320_GTCCRD_GTCCRD_Pos = 0x0
	// Bit mask of GTCCRD field.
	GPT320_GTCCRD_GTCCRD_Msk = 0xffffffff

	// GTCCRF: General PWM Timer Compare Capture Register F
	// Position of GTCCRF field.
	GPT320_GTCCRF_GTCCRF_Pos = 0x0
	// Bit mask of GTCCRF field.
	GPT320_GTCCRF_GTCCRF_Msk = 0xffffffff

	// GTPR: General PWM Timer Cycle Setting Register
	// Position of GTPR field.
	GPT320_GTPR_GTPR_Pos = 0x0
	// Bit mask of GTPR field.
	GPT320_GTPR_GTPR_Msk = 0xffffffff

	// GTPBR: General PWM Timer Cycle Setting Buffer Register
	// Position of GTPBR field.
	GPT320_GTPBR_GTPBR_Pos = 0x0
	// Bit mask of GTPBR field.
	GPT320_GTPBR_GTPBR_Msk = 0xffffffff

	// GTDTCR: General PWM Timer Dead Time Control Register
	// Position of Reserved field.
	GPT320_GTDTCR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	GPT320_GTDTCR_Reserved_Msk = 0xfffffe00
	// Position of Reserved field.
	GPT320_GTDTCR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	GPT320_GTDTCR_Reserved_Msk = 0x100
	// Bit Reserved.
	GPT320_GTDTCR_Reserved = 0x100
	// Position of Reserved field.
	GPT320_GTDTCR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	GPT320_GTDTCR_Reserved_Msk = 0xc0
	// Position of Reserved field.
	GPT320_GTDTCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	GPT320_GTDTCR_Reserved_Msk = 0x20
	// Bit Reserved.
	GPT320_GTDTCR_Reserved = 0x20
	// Position of Reserved field.
	GPT320_GTDTCR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT320_GTDTCR_Reserved_Msk = 0x10
	// Bit Reserved.
	GPT320_GTDTCR_Reserved = 0x10
	// Position of Reserved field.
	GPT320_GTDTCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	GPT320_GTDTCR_Reserved_Msk = 0xe
	// Position of TDE field.
	GPT320_GTDTCR_TDE_Pos = 0x0
	// Bit mask of TDE field.
	GPT320_GTDTCR_TDE_Msk = 0x1
	// Bit TDE.
	GPT320_GTDTCR_TDE = 0x1
	// GTCCRB is set without using GTDVU and GTDVD.
	GPT320_GTDTCR_TDE_0 = 0x0
	// GTDVU and GTDVD are used to set the compare match value for negative-phase waveform with dead time automatically in GTCCRB.
	GPT320_GTDTCR_TDE_1 = 0x1

	// GTDVU: General PWM Timer Dead Time Value Register U
	// Position of GTDVU field.
	GPT320_GTDVU_GTDVU_Pos = 0x0
	// Bit mask of GTDVU field.
	GPT320_GTDVU_GTDVU_Msk = 0xffffffff
)

// Constants for GPT164: General PWM Timer 4 (16-bit)
const (
	// GTWP: General PWM Timer Write-Protection Register
	// Position of Reserved field.
	GPT164_GTWP_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT164_GTWP_Reserved_Msk = 0xffff0000
	// Position of PRKEY field.
	GPT164_GTWP_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	GPT164_GTWP_PRKEY_Msk = 0xff00
	// Written to these bits, the WP bits write is permitted.
	GPT164_GTWP_PRKEY_0xA5 = 0xa5
	// Position of Reserved field.
	GPT164_GTWP_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	GPT164_GTWP_Reserved_Msk = 0xfe
	// Position of WP field.
	GPT164_GTWP_WP_Pos = 0x0
	// Bit mask of WP field.
	GPT164_GTWP_WP_Msk = 0x1
	// Bit WP.
	GPT164_GTWP_WP = 0x1
	// Write to the register is enabled
	GPT164_GTWP_WP_0 = 0x0
	// Write to the register is disabled
	GPT164_GTWP_WP_1 = 0x1

	// GTSTR: General PWM Timer Software Start Register
	// Position of Reserved field.
	GPT164_GTSTR_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	GPT164_GTSTR_Reserved_Msk = 0xfffffc00
	// Position of CSTRT9 field.
	GPT164_GTSTR_CSTRT9_Pos = 0x9
	// Bit mask of CSTRT9 field.
	GPT164_GTSTR_CSTRT9_Msk = 0x200
	// Bit CSTRT9.
	GPT164_GTSTR_CSTRT9 = 0x200
	// No effect (write) / counter stop (read)
	GPT164_GTSTR_CSTRT9_0 = 0x0
	// GPT169.GTCNT counter starts (write) / Counter running (read)
	GPT164_GTSTR_CSTRT9_1 = 0x1
	// Position of CSTRT8 field.
	GPT164_GTSTR_CSTRT8_Pos = 0x8
	// Bit mask of CSTRT8 field.
	GPT164_GTSTR_CSTRT8_Msk = 0x100
	// Bit CSTRT8.
	GPT164_GTSTR_CSTRT8 = 0x100
	// No effect (write) / counter stop (read)
	GPT164_GTSTR_CSTRT8_0 = 0x0
	// GPT168.GTCNT counter starts (write) / Counter running (read)
	GPT164_GTSTR_CSTRT8_1 = 0x1
	// Position of CSTRT7 field.
	GPT164_GTSTR_CSTRT7_Pos = 0x7
	// Bit mask of CSTRT7 field.
	GPT164_GTSTR_CSTRT7_Msk = 0x80
	// Bit CSTRT7.
	GPT164_GTSTR_CSTRT7 = 0x80
	// No effect (write) / counter stop (read)
	GPT164_GTSTR_CSTRT7_0 = 0x0
	// GPT167.GTCNT counter starts (write) / Counter running (read)
	GPT164_GTSTR_CSTRT7_1 = 0x1
	// Position of CSTRT6 field.
	GPT164_GTSTR_CSTRT6_Pos = 0x6
	// Bit mask of CSTRT6 field.
	GPT164_GTSTR_CSTRT6_Msk = 0x40
	// Bit CSTRT6.
	GPT164_GTSTR_CSTRT6 = 0x40
	// No effect (write) / counter stop (read)
	GPT164_GTSTR_CSTRT6_0 = 0x0
	// GPT166.GTCNT counter starts (write) / Counter running (read)
	GPT164_GTSTR_CSTRT6_1 = 0x1
	// Position of CSTRT5 field.
	GPT164_GTSTR_CSTRT5_Pos = 0x5
	// Bit mask of CSTRT5 field.
	GPT164_GTSTR_CSTRT5_Msk = 0x20
	// Bit CSTRT5.
	GPT164_GTSTR_CSTRT5 = 0x20
	// No effect (write) / counter stop (read)
	GPT164_GTSTR_CSTRT5_0 = 0x0
	// GPT165.GTCNT counter starts (write) / Counter running (read)
	GPT164_GTSTR_CSTRT5_1 = 0x1
	// Position of CSTRT4 field.
	GPT164_GTSTR_CSTRT4_Pos = 0x4
	// Bit mask of CSTRT4 field.
	GPT164_GTSTR_CSTRT4_Msk = 0x10
	// Bit CSTRT4.
	GPT164_GTSTR_CSTRT4 = 0x10
	// No effect (write) / counter stop (read)
	GPT164_GTSTR_CSTRT4_0 = 0x0
	// GPT164.GTCNT counter starts (write) / Counter running (read)
	GPT164_GTSTR_CSTRT4_1 = 0x1
	// Position of CSTRT3 field.
	GPT164_GTSTR_CSTRT3_Pos = 0x3
	// Bit mask of CSTRT3 field.
	GPT164_GTSTR_CSTRT3_Msk = 0x8
	// Bit CSTRT3.
	GPT164_GTSTR_CSTRT3 = 0x8
	// No effect (write) / counter stop (read)
	GPT164_GTSTR_CSTRT3_0 = 0x0
	// GPT323.GTCNT counter starts (write) / Counter running (read)
	GPT164_GTSTR_CSTRT3_1 = 0x1
	// Position of CSTRT2 field.
	GPT164_GTSTR_CSTRT2_Pos = 0x2
	// Bit mask of CSTRT2 field.
	GPT164_GTSTR_CSTRT2_Msk = 0x4
	// Bit CSTRT2.
	GPT164_GTSTR_CSTRT2 = 0x4
	// No effect (write) / counter stop (read)
	GPT164_GTSTR_CSTRT2_0 = 0x0
	// GPT322.GTCNT counter starts (write) / Counter running (read)
	GPT164_GTSTR_CSTRT2_1 = 0x1
	// Position of CSTRT1 field.
	GPT164_GTSTR_CSTRT1_Pos = 0x1
	// Bit mask of CSTRT1 field.
	GPT164_GTSTR_CSTRT1_Msk = 0x2
	// Bit CSTRT1.
	GPT164_GTSTR_CSTRT1 = 0x2
	// No effect (write) / counter stop (read)
	GPT164_GTSTR_CSTRT1_0 = 0x0
	// GPT321.GTCNT counter starts (write) / Counter running (read)
	GPT164_GTSTR_CSTRT1_1 = 0x1
	// Position of CSTRT0 field.
	GPT164_GTSTR_CSTRT0_Pos = 0x0
	// Bit mask of CSTRT0 field.
	GPT164_GTSTR_CSTRT0_Msk = 0x1
	// Bit CSTRT0.
	GPT164_GTSTR_CSTRT0 = 0x1
	// No effect (write) / counter stop (read)
	GPT164_GTSTR_CSTRT0_0 = 0x0
	// GPT320.GTCNT counter starts (write) / Counter running (read)
	GPT164_GTSTR_CSTRT0_1 = 0x1

	// GTSTP: General PWM Timer Software Stop Register
	// Position of Reserved field.
	GPT164_GTSTP_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	GPT164_GTSTP_Reserved_Msk = 0xfffffc00
	// Position of CSTOP9 field.
	GPT164_GTSTP_CSTOP9_Pos = 0x9
	// Bit mask of CSTOP9 field.
	GPT164_GTSTP_CSTOP9_Msk = 0x200
	// Bit CSTOP9.
	GPT164_GTSTP_CSTOP9 = 0x200
	// No effect (write) / counter running (read)
	GPT164_GTSTP_CSTOP9_0 = 0x0
	// GPT169.GTCNT counter stops (write) / Counter stop (read)
	GPT164_GTSTP_CSTOP9_1 = 0x1
	// Position of CSTOP8 field.
	GPT164_GTSTP_CSTOP8_Pos = 0x8
	// Bit mask of CSTOP8 field.
	GPT164_GTSTP_CSTOP8_Msk = 0x100
	// Bit CSTOP8.
	GPT164_GTSTP_CSTOP8 = 0x100
	// No effect (write) / counter running (read)
	GPT164_GTSTP_CSTOP8_0 = 0x0
	// GPT168.GTCNT counter stops (write) / Counter stop (read)
	GPT164_GTSTP_CSTOP8_1 = 0x1
	// Position of CSTOP7 field.
	GPT164_GTSTP_CSTOP7_Pos = 0x7
	// Bit mask of CSTOP7 field.
	GPT164_GTSTP_CSTOP7_Msk = 0x80
	// Bit CSTOP7.
	GPT164_GTSTP_CSTOP7 = 0x80
	// No effect (write) / counter running (read)
	GPT164_GTSTP_CSTOP7_0 = 0x0
	// GPT167.GTCNT counter stops (write) / Counter stop (read)
	GPT164_GTSTP_CSTOP7_1 = 0x1
	// Position of CSTOP6 field.
	GPT164_GTSTP_CSTOP6_Pos = 0x6
	// Bit mask of CSTOP6 field.
	GPT164_GTSTP_CSTOP6_Msk = 0x40
	// Bit CSTOP6.
	GPT164_GTSTP_CSTOP6 = 0x40
	// No effect (write) / counter running (read)
	GPT164_GTSTP_CSTOP6_0 = 0x0
	// GPT166.GTCNT counter stops (write) / Counter stop (read)
	GPT164_GTSTP_CSTOP6_1 = 0x1
	// Position of CSTOP5 field.
	GPT164_GTSTP_CSTOP5_Pos = 0x5
	// Bit mask of CSTOP5 field.
	GPT164_GTSTP_CSTOP5_Msk = 0x20
	// Bit CSTOP5.
	GPT164_GTSTP_CSTOP5 = 0x20
	// No effect (write) / counter running (read)
	GPT164_GTSTP_CSTOP5_0 = 0x0
	// GPT165.GTCNT counter stops (write) / Counter stop (read)
	GPT164_GTSTP_CSTOP5_1 = 0x1
	// Position of CSTOP4 field.
	GPT164_GTSTP_CSTOP4_Pos = 0x4
	// Bit mask of CSTOP4 field.
	GPT164_GTSTP_CSTOP4_Msk = 0x10
	// Bit CSTOP4.
	GPT164_GTSTP_CSTOP4 = 0x10
	// No effect (write) / counter running (read)
	GPT164_GTSTP_CSTOP4_0 = 0x0
	// GPT164.GTCNT counter stops (write) / Counter stop (read)
	GPT164_GTSTP_CSTOP4_1 = 0x1
	// Position of CSTOP3 field.
	GPT164_GTSTP_CSTOP3_Pos = 0x3
	// Bit mask of CSTOP3 field.
	GPT164_GTSTP_CSTOP3_Msk = 0x8
	// Bit CSTOP3.
	GPT164_GTSTP_CSTOP3 = 0x8
	// No effect (write) / counter running (read)
	GPT164_GTSTP_CSTOP3_0 = 0x0
	// GPT323.GTCNT counter stops (write) / Counter stop (read)
	GPT164_GTSTP_CSTOP3_1 = 0x1
	// Position of CSTOP2 field.
	GPT164_GTSTP_CSTOP2_Pos = 0x2
	// Bit mask of CSTOP2 field.
	GPT164_GTSTP_CSTOP2_Msk = 0x4
	// Bit CSTOP2.
	GPT164_GTSTP_CSTOP2 = 0x4
	// No effect (write) / counter running (read)
	GPT164_GTSTP_CSTOP2_0 = 0x0
	// GPT322.GTCNT counter stops (write) / Counter stop (read)
	GPT164_GTSTP_CSTOP2_1 = 0x1
	// Position of CSTOP1 field.
	GPT164_GTSTP_CSTOP1_Pos = 0x1
	// Bit mask of CSTOP1 field.
	GPT164_GTSTP_CSTOP1_Msk = 0x2
	// Bit CSTOP1.
	GPT164_GTSTP_CSTOP1 = 0x2
	// No effect (write) / counter running (read)
	GPT164_GTSTP_CSTOP1_0 = 0x0
	// GPT321.GTCNT counter stops (write) / Counter stop (read)
	GPT164_GTSTP_CSTOP1_1 = 0x1
	// Position of CSTOP0 field.
	GPT164_GTSTP_CSTOP0_Pos = 0x0
	// Bit mask of CSTOP0 field.
	GPT164_GTSTP_CSTOP0_Msk = 0x1
	// Bit CSTOP0.
	GPT164_GTSTP_CSTOP0 = 0x1
	// No effect (write) / counter running (read)
	GPT164_GTSTP_CSTOP0_0 = 0x0
	// GPT320.GTCNT counter stops (write) / Counter stop (read)
	GPT164_GTSTP_CSTOP0_1 = 0x1

	// GTCLR: General PWM Timer Software Clear Register
	// Position of Reserved field.
	GPT164_GTCLR_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	GPT164_GTCLR_Reserved_Msk = 0xfffffc00
	// Position of CCLR9 field.
	GPT164_GTCLR_CCLR9_Pos = 0x9
	// Bit mask of CCLR9 field.
	GPT164_GTCLR_CCLR9_Msk = 0x200
	// Bit CCLR9.
	GPT164_GTCLR_CCLR9 = 0x200
	// No effect
	GPT164_GTCLR_CCLR9_0 = 0x0
	// GPT169.GTCNT counter clears
	GPT164_GTCLR_CCLR9_1 = 0x1
	// Position of CCLR8 field.
	GPT164_GTCLR_CCLR8_Pos = 0x8
	// Bit mask of CCLR8 field.
	GPT164_GTCLR_CCLR8_Msk = 0x100
	// Bit CCLR8.
	GPT164_GTCLR_CCLR8 = 0x100
	// No effect
	GPT164_GTCLR_CCLR8_0 = 0x0
	// GPT168.GTCNT counter clears
	GPT164_GTCLR_CCLR8_1 = 0x1
	// Position of CCLR7 field.
	GPT164_GTCLR_CCLR7_Pos = 0x7
	// Bit mask of CCLR7 field.
	GPT164_GTCLR_CCLR7_Msk = 0x80
	// Bit CCLR7.
	GPT164_GTCLR_CCLR7 = 0x80
	// No effect
	GPT164_GTCLR_CCLR7_0 = 0x0
	// GPT167.GTCNT counter clears
	GPT164_GTCLR_CCLR7_1 = 0x1
	// Position of CCLR6 field.
	GPT164_GTCLR_CCLR6_Pos = 0x6
	// Bit mask of CCLR6 field.
	GPT164_GTCLR_CCLR6_Msk = 0x40
	// Bit CCLR6.
	GPT164_GTCLR_CCLR6 = 0x40
	// No effect
	GPT164_GTCLR_CCLR6_0 = 0x0
	// GPT166.GTCNT counter clears
	GPT164_GTCLR_CCLR6_1 = 0x1
	// Position of CCLR5 field.
	GPT164_GTCLR_CCLR5_Pos = 0x5
	// Bit mask of CCLR5 field.
	GPT164_GTCLR_CCLR5_Msk = 0x20
	// Bit CCLR5.
	GPT164_GTCLR_CCLR5 = 0x20
	// No effect
	GPT164_GTCLR_CCLR5_0 = 0x0
	// GPT165.GTCNT counter clears
	GPT164_GTCLR_CCLR5_1 = 0x1
	// Position of CCLR4 field.
	GPT164_GTCLR_CCLR4_Pos = 0x4
	// Bit mask of CCLR4 field.
	GPT164_GTCLR_CCLR4_Msk = 0x10
	// Bit CCLR4.
	GPT164_GTCLR_CCLR4 = 0x10
	// No effect
	GPT164_GTCLR_CCLR4_0 = 0x0
	// GPT164.GTCNT counter clears
	GPT164_GTCLR_CCLR4_1 = 0x1
	// Position of CCLR3 field.
	GPT164_GTCLR_CCLR3_Pos = 0x3
	// Bit mask of CCLR3 field.
	GPT164_GTCLR_CCLR3_Msk = 0x8
	// Bit CCLR3.
	GPT164_GTCLR_CCLR3 = 0x8
	// No effect
	GPT164_GTCLR_CCLR3_0 = 0x0
	// GPT323.GTCNT counter clears
	GPT164_GTCLR_CCLR3_1 = 0x1
	// Position of CCLR2 field.
	GPT164_GTCLR_CCLR2_Pos = 0x2
	// Bit mask of CCLR2 field.
	GPT164_GTCLR_CCLR2_Msk = 0x4
	// Bit CCLR2.
	GPT164_GTCLR_CCLR2 = 0x4
	// No effect
	GPT164_GTCLR_CCLR2_0 = 0x0
	// GPT322.GTCNT counter clears
	GPT164_GTCLR_CCLR2_1 = 0x1
	// Position of CCLR1 field.
	GPT164_GTCLR_CCLR1_Pos = 0x1
	// Bit mask of CCLR1 field.
	GPT164_GTCLR_CCLR1_Msk = 0x2
	// Bit CCLR1.
	GPT164_GTCLR_CCLR1 = 0x2
	// No effect
	GPT164_GTCLR_CCLR1_0 = 0x0
	// GPT321.GTCNT counter clears
	GPT164_GTCLR_CCLR1_1 = 0x1
	// Position of CCLR0 field.
	GPT164_GTCLR_CCLR0_Pos = 0x0
	// Bit mask of CCLR0 field.
	GPT164_GTCLR_CCLR0_Msk = 0x1
	// Bit CCLR0.
	GPT164_GTCLR_CCLR0 = 0x1
	// No effect
	GPT164_GTCLR_CCLR0_0 = 0x0
	// GPT320.GTCNT counter clears
	GPT164_GTCLR_CCLR0_1 = 0x1

	// GTSSR: General PWM Timer Start Source Select Register
	// Position of CSTRT field.
	GPT164_GTSSR_CSTRT_Pos = 0x1f
	// Bit mask of CSTRT field.
	GPT164_GTSSR_CSTRT_Msk = 0x80000000
	// Bit CSTRT.
	GPT164_GTSSR_CSTRT = 0x80000000
	// Counter start is disable by the GTSTR register
	GPT164_GTSSR_CSTRT_0 = 0x0
	// Counter start is enable by the GTSTR register
	GPT164_GTSSR_CSTRT_1 = 0x1
	// Position of Reserved field.
	GPT164_GTSSR_Reserved_Pos = 0x18
	// Bit mask of Reserved field.
	GPT164_GTSSR_Reserved_Msk = 0x7f000000
	// Position of SSELCH field.
	GPT164_GTSSR_SSELCH_Pos = 0x17
	// Bit mask of SSELCH field.
	GPT164_GTSSR_SSELCH_Msk = 0x800000
	// Bit SSELCH.
	GPT164_GTSSR_SSELCH = 0x800000
	// Counter start is disable at the ELC_GPTH input
	GPT164_GTSSR_SSELCH_0 = 0x0
	// Counter start is enable at the ELC_GPTH input
	GPT164_GTSSR_SSELCH_1 = 0x1
	// Position of SSELCG field.
	GPT164_GTSSR_SSELCG_Pos = 0x16
	// Bit mask of SSELCG field.
	GPT164_GTSSR_SSELCG_Msk = 0x400000
	// Bit SSELCG.
	GPT164_GTSSR_SSELCG = 0x400000
	// Counter start is disable at the ELC_GPTG input
	GPT164_GTSSR_SSELCG_0 = 0x0
	// Counter start is enable at the ELC_GPTG input
	GPT164_GTSSR_SSELCG_1 = 0x1
	// Position of SSELCF field.
	GPT164_GTSSR_SSELCF_Pos = 0x15
	// Bit mask of SSELCF field.
	GPT164_GTSSR_SSELCF_Msk = 0x200000
	// Bit SSELCF.
	GPT164_GTSSR_SSELCF = 0x200000
	// Counter start is disable at the ELC_GPTF input
	GPT164_GTSSR_SSELCF_0 = 0x0
	// Counter start is enable at the ELC_GPTF input
	GPT164_GTSSR_SSELCF_1 = 0x1
	// Position of SSELCE field.
	GPT164_GTSSR_SSELCE_Pos = 0x14
	// Bit mask of SSELCE field.
	GPT164_GTSSR_SSELCE_Msk = 0x100000
	// Bit SSELCE.
	GPT164_GTSSR_SSELCE = 0x100000
	// Counter start is disable at the ELC_GPTE input
	GPT164_GTSSR_SSELCE_0 = 0x0
	// Counter start is enable at the ELC_GPTE input
	GPT164_GTSSR_SSELCE_1 = 0x1
	// Position of SSELCD field.
	GPT164_GTSSR_SSELCD_Pos = 0x13
	// Bit mask of SSELCD field.
	GPT164_GTSSR_SSELCD_Msk = 0x80000
	// Bit SSELCD.
	GPT164_GTSSR_SSELCD = 0x80000
	// Counter start is disable at the ELC_GPTD input
	GPT164_GTSSR_SSELCD_0 = 0x0
	// Counter start is enable at the ELC_GPTD input
	GPT164_GTSSR_SSELCD_1 = 0x1
	// Position of SSELCC field.
	GPT164_GTSSR_SSELCC_Pos = 0x12
	// Bit mask of SSELCC field.
	GPT164_GTSSR_SSELCC_Msk = 0x40000
	// Bit SSELCC.
	GPT164_GTSSR_SSELCC = 0x40000
	// Counter start is disable at the ELC_GPTC input
	GPT164_GTSSR_SSELCC_0 = 0x0
	// Counter start is enable at the ELC_GPTC input
	GPT164_GTSSR_SSELCC_1 = 0x1
	// Position of SSELCB field.
	GPT164_GTSSR_SSELCB_Pos = 0x11
	// Bit mask of SSELCB field.
	GPT164_GTSSR_SSELCB_Msk = 0x20000
	// Bit SSELCB.
	GPT164_GTSSR_SSELCB = 0x20000
	// Counter start is disable at the ELC_GPTB input
	GPT164_GTSSR_SSELCB_0 = 0x0
	// Counter start is enable at the ELC_GPTB input
	GPT164_GTSSR_SSELCB_1 = 0x1
	// Position of SSELCA field.
	GPT164_GTSSR_SSELCA_Pos = 0x10
	// Bit mask of SSELCA field.
	GPT164_GTSSR_SSELCA_Msk = 0x10000
	// Bit SSELCA.
	GPT164_GTSSR_SSELCA = 0x10000
	// Counter start is disable at the ELC_GPTA input
	GPT164_GTSSR_SSELCA_0 = 0x0
	// Counter start is enable at the ELC_GPTA input
	GPT164_GTSSR_SSELCA_1 = 0x1
	// Position of SSCBFAH field.
	GPT164_GTSSR_SSCBFAH_Pos = 0xf
	// Bit mask of SSCBFAH field.
	GPT164_GTSSR_SSCBFAH_Msk = 0x8000
	// Bit SSCBFAH.
	GPT164_GTSSR_SSCBFAH = 0x8000
	// Counter start is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTSSR_SSCBFAH_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTSSR_SSCBFAH_1 = 0x1
	// Position of SSCBFAL field.
	GPT164_GTSSR_SSCBFAL_Pos = 0xe
	// Bit mask of SSCBFAL field.
	GPT164_GTSSR_SSCBFAL_Msk = 0x4000
	// Bit SSCBFAL.
	GPT164_GTSSR_SSCBFAL = 0x4000
	// Counter start is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTSSR_SSCBFAL_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTSSR_SSCBFAL_1 = 0x1
	// Position of SSCBRAH field.
	GPT164_GTSSR_SSCBRAH_Pos = 0xd
	// Bit mask of SSCBRAH field.
	GPT164_GTSSR_SSCBRAH_Msk = 0x2000
	// Bit SSCBRAH.
	GPT164_GTSSR_SSCBRAH = 0x2000
	// Counter start is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTSSR_SSCBRAH_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTSSR_SSCBRAH_1 = 0x1
	// Position of SSCBRAL field.
	GPT164_GTSSR_SSCBRAL_Pos = 0xc
	// Bit mask of SSCBRAL field.
	GPT164_GTSSR_SSCBRAL_Msk = 0x1000
	// Bit SSCBRAL.
	GPT164_GTSSR_SSCBRAL = 0x1000
	// Counter start is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTSSR_SSCBRAL_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTSSR_SSCBRAL_1 = 0x1
	// Position of SSCAFBH field.
	GPT164_GTSSR_SSCAFBH_Pos = 0xb
	// Bit mask of SSCAFBH field.
	GPT164_GTSSR_SSCAFBH_Msk = 0x800
	// Bit SSCAFBH.
	GPT164_GTSSR_SSCAFBH = 0x800
	// Counter start is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTSSR_SSCAFBH_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTSSR_SSCAFBH_1 = 0x1
	// Position of SSCAFBL field.
	GPT164_GTSSR_SSCAFBL_Pos = 0xa
	// Bit mask of SSCAFBL field.
	GPT164_GTSSR_SSCAFBL_Msk = 0x400
	// Bit SSCAFBL.
	GPT164_GTSSR_SSCAFBL = 0x400
	// Counter start is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTSSR_SSCAFBL_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTSSR_SSCAFBL_1 = 0x1
	// Position of SSCARBH field.
	GPT164_GTSSR_SSCARBH_Pos = 0x9
	// Bit mask of SSCARBH field.
	GPT164_GTSSR_SSCARBH_Msk = 0x200
	// Bit SSCARBH.
	GPT164_GTSSR_SSCARBH = 0x200
	// Counter start is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTSSR_SSCARBH_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTSSR_SSCARBH_1 = 0x1
	// Position of SSCARBL field.
	GPT164_GTSSR_SSCARBL_Pos = 0x8
	// Bit mask of SSCARBL field.
	GPT164_GTSSR_SSCARBL_Msk = 0x100
	// Bit SSCARBL.
	GPT164_GTSSR_SSCARBL = 0x100
	// Counter start is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTSSR_SSCARBL_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTSSR_SSCARBL_1 = 0x1
	// Position of Reserved field.
	GPT164_GTSSR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT164_GTSSR_Reserved_Msk = 0xf0
	// Position of SSGTRGBF field.
	GPT164_GTSSR_SSGTRGBF_Pos = 0x3
	// Bit mask of SSGTRGBF field.
	GPT164_GTSSR_SSGTRGBF_Msk = 0x8
	// Bit SSGTRGBF.
	GPT164_GTSSR_SSGTRGBF = 0x8
	// Counter start is disable at the falling edge of GTETRGB input
	GPT164_GTSSR_SSGTRGBF_0 = 0x0
	// Counter start is enable at the falling edge of GTETRGB input
	GPT164_GTSSR_SSGTRGBF_1 = 0x1
	// Position of SSGTRGBR field.
	GPT164_GTSSR_SSGTRGBR_Pos = 0x2
	// Bit mask of SSGTRGBR field.
	GPT164_GTSSR_SSGTRGBR_Msk = 0x4
	// Bit SSGTRGBR.
	GPT164_GTSSR_SSGTRGBR = 0x4
	// Counter start is disable at the rising edge of GTETRGB input
	GPT164_GTSSR_SSGTRGBR_0 = 0x0
	// Counter start is enable at the rising edge of GTETRGB input
	GPT164_GTSSR_SSGTRGBR_1 = 0x1
	// Position of SSGTRGAF field.
	GPT164_GTSSR_SSGTRGAF_Pos = 0x1
	// Bit mask of SSGTRGAF field.
	GPT164_GTSSR_SSGTRGAF_Msk = 0x2
	// Bit SSGTRGAF.
	GPT164_GTSSR_SSGTRGAF = 0x2
	// Counter start is disable at the falling edge of GTETRGA input
	GPT164_GTSSR_SSGTRGAF_0 = 0x0
	// Counter start is enable at the falling edge of GTETRGA input
	GPT164_GTSSR_SSGTRGAF_1 = 0x1
	// Position of SSGTRGAR field.
	GPT164_GTSSR_SSGTRGAR_Pos = 0x0
	// Bit mask of SSGTRGAR field.
	GPT164_GTSSR_SSGTRGAR_Msk = 0x1
	// Bit SSGTRGAR.
	GPT164_GTSSR_SSGTRGAR = 0x1
	// Counter start is disable at the rising edge of GTETRGA input
	GPT164_GTSSR_SSGTRGAR_0 = 0x0
	// Counter start is enable at the rising edge of GTETRGA input
	GPT164_GTSSR_SSGTRGAR_1 = 0x1

	// GTPSR: General PWM Timer Stop Source Select Register
	// Position of CSTOP field.
	GPT164_GTPSR_CSTOP_Pos = 0x1f
	// Bit mask of CSTOP field.
	GPT164_GTPSR_CSTOP_Msk = 0x80000000
	// Bit CSTOP.
	GPT164_GTPSR_CSTOP = 0x80000000
	// Counter stop is disable by the GTSTP register
	GPT164_GTPSR_CSTOP_0 = 0x0
	// Counter stop is enable by the GTSTP register
	GPT164_GTPSR_CSTOP_1 = 0x1
	// Position of Reserved field.
	GPT164_GTPSR_Reserved_Pos = 0x18
	// Bit mask of Reserved field.
	GPT164_GTPSR_Reserved_Msk = 0x7f000000
	// Position of PSELCH field.
	GPT164_GTPSR_PSELCH_Pos = 0x17
	// Bit mask of PSELCH field.
	GPT164_GTPSR_PSELCH_Msk = 0x800000
	// Bit PSELCH.
	GPT164_GTPSR_PSELCH = 0x800000
	// Counter stop is disable at the ELC_GPTH input
	GPT164_GTPSR_PSELCH_0 = 0x0
	// Counter stop is enable at the ELC_GPTH input
	GPT164_GTPSR_PSELCH_1 = 0x1
	// Position of PSELCG field.
	GPT164_GTPSR_PSELCG_Pos = 0x16
	// Bit mask of PSELCG field.
	GPT164_GTPSR_PSELCG_Msk = 0x400000
	// Bit PSELCG.
	GPT164_GTPSR_PSELCG = 0x400000
	// Counter stop is disable at the ELC_GPTG input
	GPT164_GTPSR_PSELCG_0 = 0x0
	// Counter stop is enable at the ELC_GPTG input
	GPT164_GTPSR_PSELCG_1 = 0x1
	// Position of PSELCF field.
	GPT164_GTPSR_PSELCF_Pos = 0x15
	// Bit mask of PSELCF field.
	GPT164_GTPSR_PSELCF_Msk = 0x200000
	// Bit PSELCF.
	GPT164_GTPSR_PSELCF = 0x200000
	// Counter stop is disable at the ELC_GPTF input
	GPT164_GTPSR_PSELCF_0 = 0x0
	// Counter stop is enable at the ELC_GPTF input
	GPT164_GTPSR_PSELCF_1 = 0x1
	// Position of PSELCE field.
	GPT164_GTPSR_PSELCE_Pos = 0x14
	// Bit mask of PSELCE field.
	GPT164_GTPSR_PSELCE_Msk = 0x100000
	// Bit PSELCE.
	GPT164_GTPSR_PSELCE = 0x100000
	// Counter stop is disable at the ELC_GPTE input
	GPT164_GTPSR_PSELCE_0 = 0x0
	// Counter stop is enable at the ELC_GPTE input
	GPT164_GTPSR_PSELCE_1 = 0x1
	// Position of PSELCD field.
	GPT164_GTPSR_PSELCD_Pos = 0x13
	// Bit mask of PSELCD field.
	GPT164_GTPSR_PSELCD_Msk = 0x80000
	// Bit PSELCD.
	GPT164_GTPSR_PSELCD = 0x80000
	// Counter stop is disable at the ELC_GPTD input
	GPT164_GTPSR_PSELCD_0 = 0x0
	// Counter stop is enable at the ELC_GPTD input
	GPT164_GTPSR_PSELCD_1 = 0x1
	// Position of PSELCC field.
	GPT164_GTPSR_PSELCC_Pos = 0x12
	// Bit mask of PSELCC field.
	GPT164_GTPSR_PSELCC_Msk = 0x40000
	// Bit PSELCC.
	GPT164_GTPSR_PSELCC = 0x40000
	// Counter stop is disable at the ELC_GPTC input
	GPT164_GTPSR_PSELCC_0 = 0x0
	// Counter stop is enable at the ELC_GPTC input
	GPT164_GTPSR_PSELCC_1 = 0x1
	// Position of PSELCB field.
	GPT164_GTPSR_PSELCB_Pos = 0x11
	// Bit mask of PSELCB field.
	GPT164_GTPSR_PSELCB_Msk = 0x20000
	// Bit PSELCB.
	GPT164_GTPSR_PSELCB = 0x20000
	// Counter stop is disable at the ELC_GPTB input
	GPT164_GTPSR_PSELCB_0 = 0x0
	// Counter stop is enable at the ELC_GPTB input
	GPT164_GTPSR_PSELCB_1 = 0x1
	// Position of PSELCA field.
	GPT164_GTPSR_PSELCA_Pos = 0x10
	// Bit mask of PSELCA field.
	GPT164_GTPSR_PSELCA_Msk = 0x10000
	// Bit PSELCA.
	GPT164_GTPSR_PSELCA = 0x10000
	// Counter stop is disable at the ELC_GPTA input
	GPT164_GTPSR_PSELCA_0 = 0x0
	// Counter stop is enable at the ELC_GPTA input
	GPT164_GTPSR_PSELCA_1 = 0x1
	// Position of PSCBFAH field.
	GPT164_GTPSR_PSCBFAH_Pos = 0xf
	// Bit mask of PSCBFAH field.
	GPT164_GTPSR_PSCBFAH_Msk = 0x8000
	// Bit PSCBFAH.
	GPT164_GTPSR_PSCBFAH = 0x8000
	// Counter stop is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTPSR_PSCBFAH_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTPSR_PSCBFAH_1 = 0x1
	// Position of PSCBFAL field.
	GPT164_GTPSR_PSCBFAL_Pos = 0xe
	// Bit mask of PSCBFAL field.
	GPT164_GTPSR_PSCBFAL_Msk = 0x4000
	// Bit PSCBFAL.
	GPT164_GTPSR_PSCBFAL = 0x4000
	// Counter stop is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTPSR_PSCBFAL_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTPSR_PSCBFAL_1 = 0x1
	// Position of PSCBRAH field.
	GPT164_GTPSR_PSCBRAH_Pos = 0xd
	// Bit mask of PSCBRAH field.
	GPT164_GTPSR_PSCBRAH_Msk = 0x2000
	// Bit PSCBRAH.
	GPT164_GTPSR_PSCBRAH = 0x2000
	// Counter stop is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTPSR_PSCBRAH_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTPSR_PSCBRAH_1 = 0x1
	// Position of PSCBRAL field.
	GPT164_GTPSR_PSCBRAL_Pos = 0xc
	// Bit mask of PSCBRAL field.
	GPT164_GTPSR_PSCBRAL_Msk = 0x1000
	// Bit PSCBRAL.
	GPT164_GTPSR_PSCBRAL = 0x1000
	// Counter stop is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTPSR_PSCBRAL_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTPSR_PSCBRAL_1 = 0x1
	// Position of PSCAFBH field.
	GPT164_GTPSR_PSCAFBH_Pos = 0xb
	// Bit mask of PSCAFBH field.
	GPT164_GTPSR_PSCAFBH_Msk = 0x800
	// Bit PSCAFBH.
	GPT164_GTPSR_PSCAFBH = 0x800
	// Counter stop is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTPSR_PSCAFBH_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTPSR_PSCAFBH_1 = 0x1
	// Position of PSCAFBL field.
	GPT164_GTPSR_PSCAFBL_Pos = 0xa
	// Bit mask of PSCAFBL field.
	GPT164_GTPSR_PSCAFBL_Msk = 0x400
	// Bit PSCAFBL.
	GPT164_GTPSR_PSCAFBL = 0x400
	// Counter stop is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTPSR_PSCAFBL_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTPSR_PSCAFBL_1 = 0x1
	// Position of PSCARBH field.
	GPT164_GTPSR_PSCARBH_Pos = 0x9
	// Bit mask of PSCARBH field.
	GPT164_GTPSR_PSCARBH_Msk = 0x200
	// Bit PSCARBH.
	GPT164_GTPSR_PSCARBH = 0x200
	// Counter stop is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTPSR_PSCARBH_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTPSR_PSCARBH_1 = 0x1
	// Position of PSCARBL field.
	GPT164_GTPSR_PSCARBL_Pos = 0x8
	// Bit mask of PSCARBL field.
	GPT164_GTPSR_PSCARBL_Msk = 0x100
	// Bit PSCARBL.
	GPT164_GTPSR_PSCARBL = 0x100
	// Counter stop is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTPSR_PSCARBL_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTPSR_PSCARBL_1 = 0x1
	// Position of Reserved field.
	GPT164_GTPSR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT164_GTPSR_Reserved_Msk = 0xf0
	// Position of PSGTRGBF field.
	GPT164_GTPSR_PSGTRGBF_Pos = 0x3
	// Bit mask of PSGTRGBF field.
	GPT164_GTPSR_PSGTRGBF_Msk = 0x8
	// Bit PSGTRGBF.
	GPT164_GTPSR_PSGTRGBF = 0x8
	// Counter stop is disable at the falling edge of GTETRGB input
	GPT164_GTPSR_PSGTRGBF_0 = 0x0
	// Counter stop is enable at the falling edge of GTETRGB input
	GPT164_GTPSR_PSGTRGBF_1 = 0x1
	// Position of PSGTRGBR field.
	GPT164_GTPSR_PSGTRGBR_Pos = 0x2
	// Bit mask of PSGTRGBR field.
	GPT164_GTPSR_PSGTRGBR_Msk = 0x4
	// Bit PSGTRGBR.
	GPT164_GTPSR_PSGTRGBR = 0x4
	// Counter stop is disable at the rising edge of GTETRGB input
	GPT164_GTPSR_PSGTRGBR_0 = 0x0
	// Counter stop is enable at the rising edge of GTETRGB input
	GPT164_GTPSR_PSGTRGBR_1 = 0x1
	// Position of PSGTRGAF field.
	GPT164_GTPSR_PSGTRGAF_Pos = 0x1
	// Bit mask of PSGTRGAF field.
	GPT164_GTPSR_PSGTRGAF_Msk = 0x2
	// Bit PSGTRGAF.
	GPT164_GTPSR_PSGTRGAF = 0x2
	// Counter stop is disable at the falling edge of GTETRGA input
	GPT164_GTPSR_PSGTRGAF_0 = 0x0
	// Counter stop is enable at the falling edge of GTETRGA input
	GPT164_GTPSR_PSGTRGAF_1 = 0x1
	// Position of PSGTRGAR field.
	GPT164_GTPSR_PSGTRGAR_Pos = 0x0
	// Bit mask of PSGTRGAR field.
	GPT164_GTPSR_PSGTRGAR_Msk = 0x1
	// Bit PSGTRGAR.
	GPT164_GTPSR_PSGTRGAR = 0x1
	// Counter stop is disable at the rising edge of GTETRGA input
	GPT164_GTPSR_PSGTRGAR_0 = 0x0
	// Counter stop is enable at the rising edge of GTETRGA input
	GPT164_GTPSR_PSGTRGAR_1 = 0x1

	// GTCSR: General PWM Timer Clear Source Select Register
	// Position of CCLR field.
	GPT164_GTCSR_CCLR_Pos = 0x1f
	// Bit mask of CCLR field.
	GPT164_GTCSR_CCLR_Msk = 0x80000000
	// Bit CCLR.
	GPT164_GTCSR_CCLR = 0x80000000
	// Counter clear is disable by the GTCLR register
	GPT164_GTCSR_CCLR_0 = 0x0
	// Counter clear is enable by the GTCLR register
	GPT164_GTCSR_CCLR_1 = 0x1
	// Position of Reserved field.
	GPT164_GTCSR_Reserved_Pos = 0x18
	// Bit mask of Reserved field.
	GPT164_GTCSR_Reserved_Msk = 0x7f000000
	// Position of CSELCH field.
	GPT164_GTCSR_CSELCH_Pos = 0x17
	// Bit mask of CSELCH field.
	GPT164_GTCSR_CSELCH_Msk = 0x800000
	// Bit CSELCH.
	GPT164_GTCSR_CSELCH = 0x800000
	// Counter clear is disable at the ELC_GPTH input
	GPT164_GTCSR_CSELCH_0 = 0x0
	// Counter clear is enable at the ELC_GPTH input
	GPT164_GTCSR_CSELCH_1 = 0x1
	// Position of CSELCG field.
	GPT164_GTCSR_CSELCG_Pos = 0x16
	// Bit mask of CSELCG field.
	GPT164_GTCSR_CSELCG_Msk = 0x400000
	// Bit CSELCG.
	GPT164_GTCSR_CSELCG = 0x400000
	// Counter clear is disable at the ELC_GPTG input
	GPT164_GTCSR_CSELCG_0 = 0x0
	// Counter clear is enable at the ELC_GPTG input
	GPT164_GTCSR_CSELCG_1 = 0x1
	// Position of CSELCF field.
	GPT164_GTCSR_CSELCF_Pos = 0x15
	// Bit mask of CSELCF field.
	GPT164_GTCSR_CSELCF_Msk = 0x200000
	// Bit CSELCF.
	GPT164_GTCSR_CSELCF = 0x200000
	// Counter clear is disable at the ELC_GPTF input
	GPT164_GTCSR_CSELCF_0 = 0x0
	// Counter clear is enable at the ELC_GPTF input
	GPT164_GTCSR_CSELCF_1 = 0x1
	// Position of CSELCE field.
	GPT164_GTCSR_CSELCE_Pos = 0x14
	// Bit mask of CSELCE field.
	GPT164_GTCSR_CSELCE_Msk = 0x100000
	// Bit CSELCE.
	GPT164_GTCSR_CSELCE = 0x100000
	// Counter clear is disable at the ELC_GPTE input
	GPT164_GTCSR_CSELCE_0 = 0x0
	// Counter clear is enable at the ELC_GPTE input
	GPT164_GTCSR_CSELCE_1 = 0x1
	// Position of CSELCD field.
	GPT164_GTCSR_CSELCD_Pos = 0x13
	// Bit mask of CSELCD field.
	GPT164_GTCSR_CSELCD_Msk = 0x80000
	// Bit CSELCD.
	GPT164_GTCSR_CSELCD = 0x80000
	// Counter clear is disable at the ELC_GPTD input
	GPT164_GTCSR_CSELCD_0 = 0x0
	// Counter clear is enable at the ELC_GPTD input
	GPT164_GTCSR_CSELCD_1 = 0x1
	// Position of CSELCC field.
	GPT164_GTCSR_CSELCC_Pos = 0x12
	// Bit mask of CSELCC field.
	GPT164_GTCSR_CSELCC_Msk = 0x40000
	// Bit CSELCC.
	GPT164_GTCSR_CSELCC = 0x40000
	// Counter clear is disable at the ELC_GPTC input
	GPT164_GTCSR_CSELCC_0 = 0x0
	// Counter clear is enable at the ELC_GPTC input
	GPT164_GTCSR_CSELCC_1 = 0x1
	// Position of CSELCB field.
	GPT164_GTCSR_CSELCB_Pos = 0x11
	// Bit mask of CSELCB field.
	GPT164_GTCSR_CSELCB_Msk = 0x20000
	// Bit CSELCB.
	GPT164_GTCSR_CSELCB = 0x20000
	// Counter clear is disable at the ELC_GPTB input
	GPT164_GTCSR_CSELCB_0 = 0x0
	// Counter clear is enable at the ELC_GPTB input
	GPT164_GTCSR_CSELCB_1 = 0x1
	// Position of CSELCA field.
	GPT164_GTCSR_CSELCA_Pos = 0x10
	// Bit mask of CSELCA field.
	GPT164_GTCSR_CSELCA_Msk = 0x10000
	// Bit CSELCA.
	GPT164_GTCSR_CSELCA = 0x10000
	// Counter clear is disable at the ELC_GPTA input
	GPT164_GTCSR_CSELCA_0 = 0x0
	// Counter clear is enable at the ELC_GPTA input
	GPT164_GTCSR_CSELCA_1 = 0x1
	// Position of CSCBFAH field.
	GPT164_GTCSR_CSCBFAH_Pos = 0xf
	// Bit mask of CSCBFAH field.
	GPT164_GTCSR_CSCBFAH_Msk = 0x8000
	// Bit CSCBFAH.
	GPT164_GTCSR_CSCBFAH = 0x8000
	// Counter clear is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTCSR_CSCBFAH_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTCSR_CSCBFAH_1 = 0x1
	// Position of CSCBFAL field.
	GPT164_GTCSR_CSCBFAL_Pos = 0xe
	// Bit mask of CSCBFAL field.
	GPT164_GTCSR_CSCBFAL_Msk = 0x4000
	// Bit CSCBFAL.
	GPT164_GTCSR_CSCBFAL = 0x4000
	// Counter clear is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTCSR_CSCBFAL_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTCSR_CSCBFAL_1 = 0x1
	// Position of CSCBRAH field.
	GPT164_GTCSR_CSCBRAH_Pos = 0xd
	// Bit mask of CSCBRAH field.
	GPT164_GTCSR_CSCBRAH_Msk = 0x2000
	// Bit CSCBRAH.
	GPT164_GTCSR_CSCBRAH = 0x2000
	// Counter clear is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTCSR_CSCBRAH_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTCSR_CSCBRAH_1 = 0x1
	// Position of CSCBRAL field.
	GPT164_GTCSR_CSCBRAL_Pos = 0xc
	// Bit mask of CSCBRAL field.
	GPT164_GTCSR_CSCBRAL_Msk = 0x1000
	// Bit CSCBRAL.
	GPT164_GTCSR_CSCBRAL = 0x1000
	// Counter clear is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTCSR_CSCBRAL_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTCSR_CSCBRAL_1 = 0x1
	// Position of CSCAFBH field.
	GPT164_GTCSR_CSCAFBH_Pos = 0xb
	// Bit mask of CSCAFBH field.
	GPT164_GTCSR_CSCAFBH_Msk = 0x800
	// Bit CSCAFBH.
	GPT164_GTCSR_CSCAFBH = 0x800
	// Counter clear is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTCSR_CSCAFBH_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTCSR_CSCAFBH_1 = 0x1
	// Position of CSCAFBL field.
	GPT164_GTCSR_CSCAFBL_Pos = 0xa
	// Bit mask of CSCAFBL field.
	GPT164_GTCSR_CSCAFBL_Msk = 0x400
	// Bit CSCAFBL.
	GPT164_GTCSR_CSCAFBL = 0x400
	// Counter clear is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTCSR_CSCAFBL_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTCSR_CSCAFBL_1 = 0x1
	// Position of CSCARBH field.
	GPT164_GTCSR_CSCARBH_Pos = 0x9
	// Bit mask of CSCARBH field.
	GPT164_GTCSR_CSCARBH_Msk = 0x200
	// Bit CSCARBH.
	GPT164_GTCSR_CSCARBH = 0x200
	// Counter clear is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTCSR_CSCARBH_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTCSR_CSCARBH_1 = 0x1
	// Position of CSCARBL field.
	GPT164_GTCSR_CSCARBL_Pos = 0x8
	// Bit mask of CSCARBL field.
	GPT164_GTCSR_CSCARBL_Msk = 0x100
	// Bit CSCARBL.
	GPT164_GTCSR_CSCARBL = 0x100
	// Counter clear is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTCSR_CSCARBL_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTCSR_CSCARBL_1 = 0x1
	// Position of Reserved field.
	GPT164_GTCSR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT164_GTCSR_Reserved_Msk = 0xf0
	// Position of CSGTRGBF field.
	GPT164_GTCSR_CSGTRGBF_Pos = 0x3
	// Bit mask of CSGTRGBF field.
	GPT164_GTCSR_CSGTRGBF_Msk = 0x8
	// Bit CSGTRGBF.
	GPT164_GTCSR_CSGTRGBF = 0x8
	// Counter clear is disable at the falling edge of GTETRGB input
	GPT164_GTCSR_CSGTRGBF_0 = 0x0
	// Counter clear is enable at the falling edge of GTETRGB input
	GPT164_GTCSR_CSGTRGBF_1 = 0x1
	// Position of CSGTRGBR field.
	GPT164_GTCSR_CSGTRGBR_Pos = 0x2
	// Bit mask of CSGTRGBR field.
	GPT164_GTCSR_CSGTRGBR_Msk = 0x4
	// Bit CSGTRGBR.
	GPT164_GTCSR_CSGTRGBR = 0x4
	// Counter clear is disable at the rising edge of GTETRGB input
	GPT164_GTCSR_CSGTRGBR_0 = 0x0
	// Counter clear is enable at the rising edge of GTETRGB input
	GPT164_GTCSR_CSGTRGBR_1 = 0x1
	// Position of CSGTRGAF field.
	GPT164_GTCSR_CSGTRGAF_Pos = 0x1
	// Bit mask of CSGTRGAF field.
	GPT164_GTCSR_CSGTRGAF_Msk = 0x2
	// Bit CSGTRGAF.
	GPT164_GTCSR_CSGTRGAF = 0x2
	// Counter clear is disable at the falling edge of GTETRGA input
	GPT164_GTCSR_CSGTRGAF_0 = 0x0
	// Counter clear is enable at the falling edge of GTETRGA input
	GPT164_GTCSR_CSGTRGAF_1 = 0x1
	// Position of CSGTRGAR field.
	GPT164_GTCSR_CSGTRGAR_Pos = 0x0
	// Bit mask of CSGTRGAR field.
	GPT164_GTCSR_CSGTRGAR_Msk = 0x1
	// Bit CSGTRGAR.
	GPT164_GTCSR_CSGTRGAR = 0x1
	// Counter clear is disable at the rising edge of GTETRGA input
	GPT164_GTCSR_CSGTRGAR_0 = 0x0
	// Counter clear is enable at the rising edge of GTETRGA input
	GPT164_GTCSR_CSGTRGAR_1 = 0x1

	// GTUPSR: General PWM Timer Up Count Source Select Register
	// Position of USELCH field.
	GPT164_GTUPSR_USELCH_Pos = 0x17
	// Bit mask of USELCH field.
	GPT164_GTUPSR_USELCH_Msk = 0x800000
	// Bit USELCH.
	GPT164_GTUPSR_USELCH = 0x800000
	// Counter count up is disable at the ELC_GPTH input
	GPT164_GTUPSR_USELCH_0 = 0x0
	// Counter count up is enable at the ELC_GPTH input
	GPT164_GTUPSR_USELCH_1 = 0x1
	// Position of USELCG field.
	GPT164_GTUPSR_USELCG_Pos = 0x16
	// Bit mask of USELCG field.
	GPT164_GTUPSR_USELCG_Msk = 0x400000
	// Bit USELCG.
	GPT164_GTUPSR_USELCG = 0x400000
	// Counter count up is disable at the ELC_GPTG input
	GPT164_GTUPSR_USELCG_0 = 0x0
	// Counter count up is enable at the ELC_GPTG input
	GPT164_GTUPSR_USELCG_1 = 0x1
	// Position of USELCF field.
	GPT164_GTUPSR_USELCF_Pos = 0x15
	// Bit mask of USELCF field.
	GPT164_GTUPSR_USELCF_Msk = 0x200000
	// Bit USELCF.
	GPT164_GTUPSR_USELCF = 0x200000
	// Counter count up is disable at the ELC_GPTF input
	GPT164_GTUPSR_USELCF_0 = 0x0
	// Counter count up is enable at the ELC_GPTF input
	GPT164_GTUPSR_USELCF_1 = 0x1
	// Position of USELCE field.
	GPT164_GTUPSR_USELCE_Pos = 0x14
	// Bit mask of USELCE field.
	GPT164_GTUPSR_USELCE_Msk = 0x100000
	// Bit USELCE.
	GPT164_GTUPSR_USELCE = 0x100000
	// Counter count up is disable at the ELC_GPTE input
	GPT164_GTUPSR_USELCE_0 = 0x0
	// Counter count up is enable at the ELC_GPTE input
	GPT164_GTUPSR_USELCE_1 = 0x1
	// Position of USELCD field.
	GPT164_GTUPSR_USELCD_Pos = 0x13
	// Bit mask of USELCD field.
	GPT164_GTUPSR_USELCD_Msk = 0x80000
	// Bit USELCD.
	GPT164_GTUPSR_USELCD = 0x80000
	// Counter count up is disable at the ELC_GPTD input
	GPT164_GTUPSR_USELCD_0 = 0x0
	// Counter count up is enable at the ELC_GPTD input
	GPT164_GTUPSR_USELCD_1 = 0x1
	// Position of USELCC field.
	GPT164_GTUPSR_USELCC_Pos = 0x12
	// Bit mask of USELCC field.
	GPT164_GTUPSR_USELCC_Msk = 0x40000
	// Bit USELCC.
	GPT164_GTUPSR_USELCC = 0x40000
	// Counter count up is disable at the ELC_GPTC input
	GPT164_GTUPSR_USELCC_0 = 0x0
	// Counter count up is enable at the ELC_GPTC input
	GPT164_GTUPSR_USELCC_1 = 0x1
	// Position of USELCB field.
	GPT164_GTUPSR_USELCB_Pos = 0x11
	// Bit mask of USELCB field.
	GPT164_GTUPSR_USELCB_Msk = 0x20000
	// Bit USELCB.
	GPT164_GTUPSR_USELCB = 0x20000
	// Counter count up is disable at the ELC_GPTB input
	GPT164_GTUPSR_USELCB_0 = 0x0
	// Counter count up is enable at the ELC_GPTB input
	GPT164_GTUPSR_USELCB_1 = 0x1
	// Position of USELCA field.
	GPT164_GTUPSR_USELCA_Pos = 0x10
	// Bit mask of USELCA field.
	GPT164_GTUPSR_USELCA_Msk = 0x10000
	// Bit USELCA.
	GPT164_GTUPSR_USELCA = 0x10000
	// Counter count up is disable at the ELC_GPTA input
	GPT164_GTUPSR_USELCA_0 = 0x0
	// Counter count up is enable at the ELC_GPTA input
	GPT164_GTUPSR_USELCA_1 = 0x1
	// Position of USCBFAH field.
	GPT164_GTUPSR_USCBFAH_Pos = 0xf
	// Bit mask of USCBFAH field.
	GPT164_GTUPSR_USCBFAH_Msk = 0x8000
	// Bit USCBFAH.
	GPT164_GTUPSR_USCBFAH = 0x8000
	// Counter count up is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTUPSR_USCBFAH_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTUPSR_USCBFAH_1 = 0x1
	// Position of USCBFAL field.
	GPT164_GTUPSR_USCBFAL_Pos = 0xe
	// Bit mask of USCBFAL field.
	GPT164_GTUPSR_USCBFAL_Msk = 0x4000
	// Bit USCBFAL.
	GPT164_GTUPSR_USCBFAL = 0x4000
	// Counter count up is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTUPSR_USCBFAL_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTUPSR_USCBFAL_1 = 0x1
	// Position of USCBRAH field.
	GPT164_GTUPSR_USCBRAH_Pos = 0xd
	// Bit mask of USCBRAH field.
	GPT164_GTUPSR_USCBRAH_Msk = 0x2000
	// Bit USCBRAH.
	GPT164_GTUPSR_USCBRAH = 0x2000
	// Counter count up is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTUPSR_USCBRAH_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTUPSR_USCBRAH_1 = 0x1
	// Position of USCBRAL field.
	GPT164_GTUPSR_USCBRAL_Pos = 0xc
	// Bit mask of USCBRAL field.
	GPT164_GTUPSR_USCBRAL_Msk = 0x1000
	// Bit USCBRAL.
	GPT164_GTUPSR_USCBRAL = 0x1000
	// Counter count up is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTUPSR_USCBRAL_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTUPSR_USCBRAL_1 = 0x1
	// Position of USCAFBH field.
	GPT164_GTUPSR_USCAFBH_Pos = 0xb
	// Bit mask of USCAFBH field.
	GPT164_GTUPSR_USCAFBH_Msk = 0x800
	// Bit USCAFBH.
	GPT164_GTUPSR_USCAFBH = 0x800
	// Counter count up is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTUPSR_USCAFBH_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTUPSR_USCAFBH_1 = 0x1
	// Position of USCAFBL field.
	GPT164_GTUPSR_USCAFBL_Pos = 0xa
	// Bit mask of USCAFBL field.
	GPT164_GTUPSR_USCAFBL_Msk = 0x400
	// Bit USCAFBL.
	GPT164_GTUPSR_USCAFBL = 0x400
	// Counter count up is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTUPSR_USCAFBL_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTUPSR_USCAFBL_1 = 0x1
	// Position of USCARBH field.
	GPT164_GTUPSR_USCARBH_Pos = 0x9
	// Bit mask of USCARBH field.
	GPT164_GTUPSR_USCARBH_Msk = 0x200
	// Bit USCARBH.
	GPT164_GTUPSR_USCARBH = 0x200
	// Counter count up is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTUPSR_USCARBH_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTUPSR_USCARBH_1 = 0x1
	// Position of USCARBL field.
	GPT164_GTUPSR_USCARBL_Pos = 0x8
	// Bit mask of USCARBL field.
	GPT164_GTUPSR_USCARBL_Msk = 0x100
	// Bit USCARBL.
	GPT164_GTUPSR_USCARBL = 0x100
	// Counter count up is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTUPSR_USCARBL_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTUPSR_USCARBL_1 = 0x1
	// Position of USGTRGBF field.
	GPT164_GTUPSR_USGTRGBF_Pos = 0x3
	// Bit mask of USGTRGBF field.
	GPT164_GTUPSR_USGTRGBF_Msk = 0x8
	// Bit USGTRGBF.
	GPT164_GTUPSR_USGTRGBF = 0x8
	// Counter count up is disable at the falling edge of GTETRGB input
	GPT164_GTUPSR_USGTRGBF_0 = 0x0
	// Counter count up is enable at the falling edge of GTETRGB input
	GPT164_GTUPSR_USGTRGBF_1 = 0x1
	// Position of USGTRGBR field.
	GPT164_GTUPSR_USGTRGBR_Pos = 0x2
	// Bit mask of USGTRGBR field.
	GPT164_GTUPSR_USGTRGBR_Msk = 0x4
	// Bit USGTRGBR.
	GPT164_GTUPSR_USGTRGBR = 0x4
	// Counter count up is disable at the rising edge of GTETRGB input
	GPT164_GTUPSR_USGTRGBR_0 = 0x0
	// Counter count up is enable at the rising edge of GTETRGB input
	GPT164_GTUPSR_USGTRGBR_1 = 0x1
	// Position of USGTRGAF field.
	GPT164_GTUPSR_USGTRGAF_Pos = 0x1
	// Bit mask of USGTRGAF field.
	GPT164_GTUPSR_USGTRGAF_Msk = 0x2
	// Bit USGTRGAF.
	GPT164_GTUPSR_USGTRGAF = 0x2
	// Counter count up is disable at the falling edge of GTETRGA input
	GPT164_GTUPSR_USGTRGAF_0 = 0x0
	// Counter count up is enable at the falling edge of GTETRGA input
	GPT164_GTUPSR_USGTRGAF_1 = 0x1
	// Position of USGTRGAR field.
	GPT164_GTUPSR_USGTRGAR_Pos = 0x0
	// Bit mask of USGTRGAR field.
	GPT164_GTUPSR_USGTRGAR_Msk = 0x1
	// Bit USGTRGAR.
	GPT164_GTUPSR_USGTRGAR = 0x1
	// Counter count up is disable at the rising edge of GTETRGA input
	GPT164_GTUPSR_USGTRGAR_0 = 0x0
	// Counter count up is enable at the rising edge of GTETRGA input
	GPT164_GTUPSR_USGTRGAR_1 = 0x1

	// GTDNSR: General PWM Timer Down Count Source Select Register
	// Position of DSELCH field.
	GPT164_GTDNSR_DSELCH_Pos = 0x17
	// Bit mask of DSELCH field.
	GPT164_GTDNSR_DSELCH_Msk = 0x800000
	// Bit DSELCH.
	GPT164_GTDNSR_DSELCH = 0x800000
	// Counter count down is disable at the ELC_GPTH input
	GPT164_GTDNSR_DSELCH_0 = 0x0
	// Counter count down is enable at the ELC_GPTH input
	GPT164_GTDNSR_DSELCH_1 = 0x1
	// Position of DSELCG field.
	GPT164_GTDNSR_DSELCG_Pos = 0x16
	// Bit mask of DSELCG field.
	GPT164_GTDNSR_DSELCG_Msk = 0x400000
	// Bit DSELCG.
	GPT164_GTDNSR_DSELCG = 0x400000
	// Counter count down is disable at the ELC_GPTG input
	GPT164_GTDNSR_DSELCG_0 = 0x0
	// Counter count down is enable at the ELC_GPTG input
	GPT164_GTDNSR_DSELCG_1 = 0x1
	// Position of DSELCF field.
	GPT164_GTDNSR_DSELCF_Pos = 0x15
	// Bit mask of DSELCF field.
	GPT164_GTDNSR_DSELCF_Msk = 0x200000
	// Bit DSELCF.
	GPT164_GTDNSR_DSELCF = 0x200000
	// Counter count down is disable at the ELC_GPTF input
	GPT164_GTDNSR_DSELCF_0 = 0x0
	// Counter count down is enable at the ELC_GPTF input
	GPT164_GTDNSR_DSELCF_1 = 0x1
	// Position of DSELCE field.
	GPT164_GTDNSR_DSELCE_Pos = 0x14
	// Bit mask of DSELCE field.
	GPT164_GTDNSR_DSELCE_Msk = 0x100000
	// Bit DSELCE.
	GPT164_GTDNSR_DSELCE = 0x100000
	// Counter count down is disable at the ELC_GPTE input
	GPT164_GTDNSR_DSELCE_0 = 0x0
	// Counter count down is enable at the ELC_GPTE input
	GPT164_GTDNSR_DSELCE_1 = 0x1
	// Position of DSELCD field.
	GPT164_GTDNSR_DSELCD_Pos = 0x13
	// Bit mask of DSELCD field.
	GPT164_GTDNSR_DSELCD_Msk = 0x80000
	// Bit DSELCD.
	GPT164_GTDNSR_DSELCD = 0x80000
	// Counter count down is disable at the ELC_GPTD input
	GPT164_GTDNSR_DSELCD_0 = 0x0
	// Counter count down is enable at the ELC_GPTD input
	GPT164_GTDNSR_DSELCD_1 = 0x1
	// Position of DSELCC field.
	GPT164_GTDNSR_DSELCC_Pos = 0x12
	// Bit mask of DSELCC field.
	GPT164_GTDNSR_DSELCC_Msk = 0x40000
	// Bit DSELCC.
	GPT164_GTDNSR_DSELCC = 0x40000
	// Counter count down is disable at the ELC_GPTC input
	GPT164_GTDNSR_DSELCC_0 = 0x0
	// Counter count down is enable at the ELC_GPTC input
	GPT164_GTDNSR_DSELCC_1 = 0x1
	// Position of DSELCB field.
	GPT164_GTDNSR_DSELCB_Pos = 0x11
	// Bit mask of DSELCB field.
	GPT164_GTDNSR_DSELCB_Msk = 0x20000
	// Bit DSELCB.
	GPT164_GTDNSR_DSELCB = 0x20000
	// Counter count down is disable at the ELC_GPTB input
	GPT164_GTDNSR_DSELCB_0 = 0x0
	// Counter count down is enable at the ELC_GPTB input
	GPT164_GTDNSR_DSELCB_1 = 0x1
	// Position of DSELCA field.
	GPT164_GTDNSR_DSELCA_Pos = 0x10
	// Bit mask of DSELCA field.
	GPT164_GTDNSR_DSELCA_Msk = 0x10000
	// Bit DSELCA.
	GPT164_GTDNSR_DSELCA = 0x10000
	// Counter count down is disable at the ELC_GPTA input
	GPT164_GTDNSR_DSELCA_0 = 0x0
	// Counter count down is enable at the ELC_GPTA input
	GPT164_GTDNSR_DSELCA_1 = 0x1
	// Position of DSCBFAH field.
	GPT164_GTDNSR_DSCBFAH_Pos = 0xf
	// Bit mask of DSCBFAH field.
	GPT164_GTDNSR_DSCBFAH_Msk = 0x8000
	// Bit DSCBFAH.
	GPT164_GTDNSR_DSCBFAH = 0x8000
	// Counter count down is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTDNSR_DSCBFAH_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTDNSR_DSCBFAH_1 = 0x1
	// Position of DSCBFAL field.
	GPT164_GTDNSR_DSCBFAL_Pos = 0xe
	// Bit mask of DSCBFAL field.
	GPT164_GTDNSR_DSCBFAL_Msk = 0x4000
	// Bit DSCBFAL.
	GPT164_GTDNSR_DSCBFAL = 0x4000
	// Counter count down is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTDNSR_DSCBFAL_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTDNSR_DSCBFAL_1 = 0x1
	// Position of DSCBRAH field.
	GPT164_GTDNSR_DSCBRAH_Pos = 0xd
	// Bit mask of DSCBRAH field.
	GPT164_GTDNSR_DSCBRAH_Msk = 0x2000
	// Bit DSCBRAH.
	GPT164_GTDNSR_DSCBRAH = 0x2000
	// Counter count down is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTDNSR_DSCBRAH_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTDNSR_DSCBRAH_1 = 0x1
	// Position of DSCBRAL field.
	GPT164_GTDNSR_DSCBRAL_Pos = 0xc
	// Bit mask of DSCBRAL field.
	GPT164_GTDNSR_DSCBRAL_Msk = 0x1000
	// Bit DSCBRAL.
	GPT164_GTDNSR_DSCBRAL = 0x1000
	// Counter count down is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTDNSR_DSCBRAL_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTDNSR_DSCBRAL_1 = 0x1
	// Position of DSCAFBH field.
	GPT164_GTDNSR_DSCAFBH_Pos = 0xb
	// Bit mask of DSCAFBH field.
	GPT164_GTDNSR_DSCAFBH_Msk = 0x800
	// Bit DSCAFBH.
	GPT164_GTDNSR_DSCAFBH = 0x800
	// Counter count down is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTDNSR_DSCAFBH_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTDNSR_DSCAFBH_1 = 0x1
	// Position of DSCAFBL field.
	GPT164_GTDNSR_DSCAFBL_Pos = 0xa
	// Bit mask of DSCAFBL field.
	GPT164_GTDNSR_DSCAFBL_Msk = 0x400
	// Bit DSCAFBL.
	GPT164_GTDNSR_DSCAFBL = 0x400
	// Counter count down is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTDNSR_DSCAFBL_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTDNSR_DSCAFBL_1 = 0x1
	// Position of DSCARBH field.
	GPT164_GTDNSR_DSCARBH_Pos = 0x9
	// Bit mask of DSCARBH field.
	GPT164_GTDNSR_DSCARBH_Msk = 0x200
	// Bit DSCARBH.
	GPT164_GTDNSR_DSCARBH = 0x200
	// Counter count down is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTDNSR_DSCARBH_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTDNSR_DSCARBH_1 = 0x1
	// Position of DSCARBL field.
	GPT164_GTDNSR_DSCARBL_Pos = 0x8
	// Bit mask of DSCARBL field.
	GPT164_GTDNSR_DSCARBL_Msk = 0x100
	// Bit DSCARBL.
	GPT164_GTDNSR_DSCARBL = 0x100
	// Counter count down is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTDNSR_DSCARBL_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTDNSR_DSCARBL_1 = 0x1
	// Position of DSGTRGBF field.
	GPT164_GTDNSR_DSGTRGBF_Pos = 0x3
	// Bit mask of DSGTRGBF field.
	GPT164_GTDNSR_DSGTRGBF_Msk = 0x8
	// Bit DSGTRGBF.
	GPT164_GTDNSR_DSGTRGBF = 0x8
	// Counter count down is disable at the falling edge of GTETRGB input
	GPT164_GTDNSR_DSGTRGBF_0 = 0x0
	// Counter count down is enable at the falling edge of GTETRGB input
	GPT164_GTDNSR_DSGTRGBF_1 = 0x1
	// Position of DSGTRGBR field.
	GPT164_GTDNSR_DSGTRGBR_Pos = 0x2
	// Bit mask of DSGTRGBR field.
	GPT164_GTDNSR_DSGTRGBR_Msk = 0x4
	// Bit DSGTRGBR.
	GPT164_GTDNSR_DSGTRGBR = 0x4
	// Counter count down is disable at the rising edge of GTETRGB input
	GPT164_GTDNSR_DSGTRGBR_0 = 0x0
	// Counter count down is enable at the rising edge of GTETRGB input
	GPT164_GTDNSR_DSGTRGBR_1 = 0x1
	// Position of DSGTRGAF field.
	GPT164_GTDNSR_DSGTRGAF_Pos = 0x1
	// Bit mask of DSGTRGAF field.
	GPT164_GTDNSR_DSGTRGAF_Msk = 0x2
	// Bit DSGTRGAF.
	GPT164_GTDNSR_DSGTRGAF = 0x2
	// Counter count down is disable at the falling edge of GTETRGA input
	GPT164_GTDNSR_DSGTRGAF_0 = 0x0
	// Counter count down is enable at the falling edge of GTETRGA input
	GPT164_GTDNSR_DSGTRGAF_1 = 0x1
	// Position of DSGTRGAR field.
	GPT164_GTDNSR_DSGTRGAR_Pos = 0x0
	// Bit mask of DSGTRGAR field.
	GPT164_GTDNSR_DSGTRGAR_Msk = 0x1
	// Bit DSGTRGAR.
	GPT164_GTDNSR_DSGTRGAR = 0x1
	// Counter count down is disable at the rising edge of GTETRGA input
	GPT164_GTDNSR_DSGTRGAR_0 = 0x0
	// Counter count down is enable at the rising edge of GTETRGA input
	GPT164_GTDNSR_DSGTRGAR_1 = 0x1

	// GTICASR: General PWM Timer Input Capture Source Select Register A
	// Position of ASELCH field.
	GPT164_GTICASR_ASELCH_Pos = 0x17
	// Bit mask of ASELCH field.
	GPT164_GTICASR_ASELCH_Msk = 0x800000
	// Bit ASELCH.
	GPT164_GTICASR_ASELCH = 0x800000
	// GTCCRA input capture is disable at the ELC_GPTH input
	GPT164_GTICASR_ASELCH_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTH input
	GPT164_GTICASR_ASELCH_1 = 0x1
	// Position of ASELCG field.
	GPT164_GTICASR_ASELCG_Pos = 0x16
	// Bit mask of ASELCG field.
	GPT164_GTICASR_ASELCG_Msk = 0x400000
	// Bit ASELCG.
	GPT164_GTICASR_ASELCG = 0x400000
	// GTCCRA input capture is disable at the ELC_GPTG input
	GPT164_GTICASR_ASELCG_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTG input
	GPT164_GTICASR_ASELCG_1 = 0x1
	// Position of ASELCF field.
	GPT164_GTICASR_ASELCF_Pos = 0x15
	// Bit mask of ASELCF field.
	GPT164_GTICASR_ASELCF_Msk = 0x200000
	// Bit ASELCF.
	GPT164_GTICASR_ASELCF = 0x200000
	// GTCCRA input capture is disable at the ELC_GPTF input
	GPT164_GTICASR_ASELCF_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTF input
	GPT164_GTICASR_ASELCF_1 = 0x1
	// Position of ASELCE field.
	GPT164_GTICASR_ASELCE_Pos = 0x14
	// Bit mask of ASELCE field.
	GPT164_GTICASR_ASELCE_Msk = 0x100000
	// Bit ASELCE.
	GPT164_GTICASR_ASELCE = 0x100000
	// GTCCRA input capture is disable at the ELC_GPTE input
	GPT164_GTICASR_ASELCE_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTE input
	GPT164_GTICASR_ASELCE_1 = 0x1
	// Position of ASELCD field.
	GPT164_GTICASR_ASELCD_Pos = 0x13
	// Bit mask of ASELCD field.
	GPT164_GTICASR_ASELCD_Msk = 0x80000
	// Bit ASELCD.
	GPT164_GTICASR_ASELCD = 0x80000
	// GTCCRA input capture is disable at the ELC_GPTD input
	GPT164_GTICASR_ASELCD_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTD input
	GPT164_GTICASR_ASELCD_1 = 0x1
	// Position of ASELCC field.
	GPT164_GTICASR_ASELCC_Pos = 0x12
	// Bit mask of ASELCC field.
	GPT164_GTICASR_ASELCC_Msk = 0x40000
	// Bit ASELCC.
	GPT164_GTICASR_ASELCC = 0x40000
	// GTCCRA input capture is disable at the ELC_GPTC input
	GPT164_GTICASR_ASELCC_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTC input
	GPT164_GTICASR_ASELCC_1 = 0x1
	// Position of ASELCB field.
	GPT164_GTICASR_ASELCB_Pos = 0x11
	// Bit mask of ASELCB field.
	GPT164_GTICASR_ASELCB_Msk = 0x20000
	// Bit ASELCB.
	GPT164_GTICASR_ASELCB = 0x20000
	// GTCCRA input capture is disable at the ELC_GPTB input
	GPT164_GTICASR_ASELCB_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTB input
	GPT164_GTICASR_ASELCB_1 = 0x1
	// Position of ASELCA field.
	GPT164_GTICASR_ASELCA_Pos = 0x10
	// Bit mask of ASELCA field.
	GPT164_GTICASR_ASELCA_Msk = 0x10000
	// Bit ASELCA.
	GPT164_GTICASR_ASELCA = 0x10000
	// GTCCRA input capture is disable at the ELC_GPTA input
	GPT164_GTICASR_ASELCA_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTA input
	GPT164_GTICASR_ASELCA_1 = 0x1
	// Position of ASCBFAH field.
	GPT164_GTICASR_ASCBFAH_Pos = 0xf
	// Bit mask of ASCBFAH field.
	GPT164_GTICASR_ASCBFAH_Msk = 0x8000
	// Bit ASCBFAH.
	GPT164_GTICASR_ASCBFAH = 0x8000
	// GTCCRA input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTICASR_ASCBFAH_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTICASR_ASCBFAH_1 = 0x1
	// Position of ASCBFAL field.
	GPT164_GTICASR_ASCBFAL_Pos = 0xe
	// Bit mask of ASCBFAL field.
	GPT164_GTICASR_ASCBFAL_Msk = 0x4000
	// Bit ASCBFAL.
	GPT164_GTICASR_ASCBFAL = 0x4000
	// GTCCRA input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTICASR_ASCBFAL_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTICASR_ASCBFAL_1 = 0x1
	// Position of ASCBRAH field.
	GPT164_GTICASR_ASCBRAH_Pos = 0xd
	// Bit mask of ASCBRAH field.
	GPT164_GTICASR_ASCBRAH_Msk = 0x2000
	// Bit ASCBRAH.
	GPT164_GTICASR_ASCBRAH = 0x2000
	// GTCCRA input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTICASR_ASCBRAH_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTICASR_ASCBRAH_1 = 0x1
	// Position of ASCBRAL field.
	GPT164_GTICASR_ASCBRAL_Pos = 0xc
	// Bit mask of ASCBRAL field.
	GPT164_GTICASR_ASCBRAL_Msk = 0x1000
	// Bit ASCBRAL.
	GPT164_GTICASR_ASCBRAL = 0x1000
	// GTCCRA input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTICASR_ASCBRAL_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTICASR_ASCBRAL_1 = 0x1
	// Position of ASCAFBH field.
	GPT164_GTICASR_ASCAFBH_Pos = 0xb
	// Bit mask of ASCAFBH field.
	GPT164_GTICASR_ASCAFBH_Msk = 0x800
	// Bit ASCAFBH.
	GPT164_GTICASR_ASCAFBH = 0x800
	// GTCCRA input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTICASR_ASCAFBH_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTICASR_ASCAFBH_1 = 0x1
	// Position of ASCAFBL field.
	GPT164_GTICASR_ASCAFBL_Pos = 0xa
	// Bit mask of ASCAFBL field.
	GPT164_GTICASR_ASCAFBL_Msk = 0x400
	// Bit ASCAFBL.
	GPT164_GTICASR_ASCAFBL = 0x400
	// GTCCRA input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTICASR_ASCAFBL_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTICASR_ASCAFBL_1 = 0x1
	// Position of ASCARBH field.
	GPT164_GTICASR_ASCARBH_Pos = 0x9
	// Bit mask of ASCARBH field.
	GPT164_GTICASR_ASCARBH_Msk = 0x200
	// Bit ASCARBH.
	GPT164_GTICASR_ASCARBH = 0x200
	// GTCCRA input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTICASR_ASCARBH_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTICASR_ASCARBH_1 = 0x1
	// Position of ASCARBL field.
	GPT164_GTICASR_ASCARBL_Pos = 0x8
	// Bit mask of ASCARBL field.
	GPT164_GTICASR_ASCARBL_Msk = 0x100
	// Bit ASCARBL.
	GPT164_GTICASR_ASCARBL = 0x100
	// GTCCRA input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTICASR_ASCARBL_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTICASR_ASCARBL_1 = 0x1
	// Position of ASGTRGBF field.
	GPT164_GTICASR_ASGTRGBF_Pos = 0x3
	// Bit mask of ASGTRGBF field.
	GPT164_GTICASR_ASGTRGBF_Msk = 0x8
	// Bit ASGTRGBF.
	GPT164_GTICASR_ASGTRGBF = 0x8
	// GTCCRA input capture is disable at the falling edge of GTETRGB input
	GPT164_GTICASR_ASGTRGBF_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTETRGB input
	GPT164_GTICASR_ASGTRGBF_1 = 0x1
	// Position of ASGTRGBR field.
	GPT164_GTICASR_ASGTRGBR_Pos = 0x2
	// Bit mask of ASGTRGBR field.
	GPT164_GTICASR_ASGTRGBR_Msk = 0x4
	// Bit ASGTRGBR.
	GPT164_GTICASR_ASGTRGBR = 0x4
	// GTCCRA input capture is disable at the rising edge of GTETRGB input
	GPT164_GTICASR_ASGTRGBR_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTETRGB input
	GPT164_GTICASR_ASGTRGBR_1 = 0x1
	// Position of ASGTRGAF field.
	GPT164_GTICASR_ASGTRGAF_Pos = 0x1
	// Bit mask of ASGTRGAF field.
	GPT164_GTICASR_ASGTRGAF_Msk = 0x2
	// Bit ASGTRGAF.
	GPT164_GTICASR_ASGTRGAF = 0x2
	// GTCCRA input capture is disable at the falling edge of GTETRGA input
	GPT164_GTICASR_ASGTRGAF_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTETRGA input
	GPT164_GTICASR_ASGTRGAF_1 = 0x1
	// Position of ASGTRGAR field.
	GPT164_GTICASR_ASGTRGAR_Pos = 0x0
	// Bit mask of ASGTRGAR field.
	GPT164_GTICASR_ASGTRGAR_Msk = 0x1
	// Bit ASGTRGAR.
	GPT164_GTICASR_ASGTRGAR = 0x1
	// GTCCRA input capture is disable at the rising edge of GTETRGA input
	GPT164_GTICASR_ASGTRGAR_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTETRGA input
	GPT164_GTICASR_ASGTRGAR_1 = 0x1

	// GTICBSR: General PWM Timer Input Capture Source Select Register B
	// Position of BSELCH field.
	GPT164_GTICBSR_BSELCH_Pos = 0x17
	// Bit mask of BSELCH field.
	GPT164_GTICBSR_BSELCH_Msk = 0x800000
	// Bit BSELCH.
	GPT164_GTICBSR_BSELCH = 0x800000
	// GTCCRB input capture is disable at the ELC_GPTH input
	GPT164_GTICBSR_BSELCH_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTH input
	GPT164_GTICBSR_BSELCH_1 = 0x1
	// Position of BSELCG field.
	GPT164_GTICBSR_BSELCG_Pos = 0x16
	// Bit mask of BSELCG field.
	GPT164_GTICBSR_BSELCG_Msk = 0x400000
	// Bit BSELCG.
	GPT164_GTICBSR_BSELCG = 0x400000
	// GTCCRB input capture is disable at the ELC_GPTG input
	GPT164_GTICBSR_BSELCG_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTG input
	GPT164_GTICBSR_BSELCG_1 = 0x1
	// Position of BSELCF field.
	GPT164_GTICBSR_BSELCF_Pos = 0x15
	// Bit mask of BSELCF field.
	GPT164_GTICBSR_BSELCF_Msk = 0x200000
	// Bit BSELCF.
	GPT164_GTICBSR_BSELCF = 0x200000
	// GTCCRB input capture is disable at the ELC_GPTF input
	GPT164_GTICBSR_BSELCF_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTF input
	GPT164_GTICBSR_BSELCF_1 = 0x1
	// Position of BSELCE field.
	GPT164_GTICBSR_BSELCE_Pos = 0x14
	// Bit mask of BSELCE field.
	GPT164_GTICBSR_BSELCE_Msk = 0x100000
	// Bit BSELCE.
	GPT164_GTICBSR_BSELCE = 0x100000
	// GTCCRB input capture is disable at the ELC_GPTE input
	GPT164_GTICBSR_BSELCE_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTE input
	GPT164_GTICBSR_BSELCE_1 = 0x1
	// Position of BSELCD field.
	GPT164_GTICBSR_BSELCD_Pos = 0x13
	// Bit mask of BSELCD field.
	GPT164_GTICBSR_BSELCD_Msk = 0x80000
	// Bit BSELCD.
	GPT164_GTICBSR_BSELCD = 0x80000
	// GTCCRB input capture is disable at the ELC_GPTD input
	GPT164_GTICBSR_BSELCD_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTD input
	GPT164_GTICBSR_BSELCD_1 = 0x1
	// Position of BSELCC field.
	GPT164_GTICBSR_BSELCC_Pos = 0x12
	// Bit mask of BSELCC field.
	GPT164_GTICBSR_BSELCC_Msk = 0x40000
	// Bit BSELCC.
	GPT164_GTICBSR_BSELCC = 0x40000
	// GTCCRB input capture is disable at the ELC_GPTC input
	GPT164_GTICBSR_BSELCC_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTC input
	GPT164_GTICBSR_BSELCC_1 = 0x1
	// Position of BSELCB field.
	GPT164_GTICBSR_BSELCB_Pos = 0x11
	// Bit mask of BSELCB field.
	GPT164_GTICBSR_BSELCB_Msk = 0x20000
	// Bit BSELCB.
	GPT164_GTICBSR_BSELCB = 0x20000
	// GTCCRB input capture is disable at the ELC_GPTB input
	GPT164_GTICBSR_BSELCB_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTB input
	GPT164_GTICBSR_BSELCB_1 = 0x1
	// Position of BSELCA field.
	GPT164_GTICBSR_BSELCA_Pos = 0x10
	// Bit mask of BSELCA field.
	GPT164_GTICBSR_BSELCA_Msk = 0x10000
	// Bit BSELCA.
	GPT164_GTICBSR_BSELCA = 0x10000
	// GTCCRB input capture is disable at the ELC_GPTA input
	GPT164_GTICBSR_BSELCA_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTA input
	GPT164_GTICBSR_BSELCA_1 = 0x1
	// Position of BSCBFAH field.
	GPT164_GTICBSR_BSCBFAH_Pos = 0xf
	// Bit mask of BSCBFAH field.
	GPT164_GTICBSR_BSCBFAH_Msk = 0x8000
	// Bit BSCBFAH.
	GPT164_GTICBSR_BSCBFAH = 0x8000
	// GTCCRB input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTICBSR_BSCBFAH_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTICBSR_BSCBFAH_1 = 0x1
	// Position of BSCBFAL field.
	GPT164_GTICBSR_BSCBFAL_Pos = 0xe
	// Bit mask of BSCBFAL field.
	GPT164_GTICBSR_BSCBFAL_Msk = 0x4000
	// Bit BSCBFAL.
	GPT164_GTICBSR_BSCBFAL = 0x4000
	// GTCCRB input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTICBSR_BSCBFAL_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTICBSR_BSCBFAL_1 = 0x1
	// Position of BSCBRAH field.
	GPT164_GTICBSR_BSCBRAH_Pos = 0xd
	// Bit mask of BSCBRAH field.
	GPT164_GTICBSR_BSCBRAH_Msk = 0x2000
	// Bit BSCBRAH.
	GPT164_GTICBSR_BSCBRAH = 0x2000
	// GTCCRB input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTICBSR_BSCBRAH_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT164_GTICBSR_BSCBRAH_1 = 0x1
	// Position of BSCBRAL field.
	GPT164_GTICBSR_BSCBRAL_Pos = 0xc
	// Bit mask of BSCBRAL field.
	GPT164_GTICBSR_BSCBRAL_Msk = 0x1000
	// Bit BSCBRAL.
	GPT164_GTICBSR_BSCBRAL = 0x1000
	// GTCCRB input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTICBSR_BSCBRAL_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT164_GTICBSR_BSCBRAL_1 = 0x1
	// Position of BSCAFBH field.
	GPT164_GTICBSR_BSCAFBH_Pos = 0xb
	// Bit mask of BSCAFBH field.
	GPT164_GTICBSR_BSCAFBH_Msk = 0x800
	// Bit BSCAFBH.
	GPT164_GTICBSR_BSCAFBH = 0x800
	// GTCCRB input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTICBSR_BSCAFBH_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTICBSR_BSCAFBH_1 = 0x1
	// Position of BSCAFBL field.
	GPT164_GTICBSR_BSCAFBL_Pos = 0xa
	// Bit mask of BSCAFBL field.
	GPT164_GTICBSR_BSCAFBL_Msk = 0x400
	// Bit BSCAFBL.
	GPT164_GTICBSR_BSCAFBL = 0x400
	// GTCCRB input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTICBSR_BSCAFBL_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTICBSR_BSCAFBL_1 = 0x1
	// Position of BSCARBH field.
	GPT164_GTICBSR_BSCARBH_Pos = 0x9
	// Bit mask of BSCARBH field.
	GPT164_GTICBSR_BSCARBH_Msk = 0x200
	// Bit BSCARBH.
	GPT164_GTICBSR_BSCARBH = 0x200
	// GTCCRB input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTICBSR_BSCARBH_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT164_GTICBSR_BSCARBH_1 = 0x1
	// Position of BSCARBL field.
	GPT164_GTICBSR_BSCARBL_Pos = 0x8
	// Bit mask of BSCARBL field.
	GPT164_GTICBSR_BSCARBL_Msk = 0x100
	// Bit BSCARBL.
	GPT164_GTICBSR_BSCARBL = 0x100
	// GTCCRB input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTICBSR_BSCARBL_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT164_GTICBSR_BSCARBL_1 = 0x1
	// Position of BSGTRGBF field.
	GPT164_GTICBSR_BSGTRGBF_Pos = 0x3
	// Bit mask of BSGTRGBF field.
	GPT164_GTICBSR_BSGTRGBF_Msk = 0x8
	// Bit BSGTRGBF.
	GPT164_GTICBSR_BSGTRGBF = 0x8
	// GTCCRB input capture is disable at the falling edge of GTETRGB input
	GPT164_GTICBSR_BSGTRGBF_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTETRGB input
	GPT164_GTICBSR_BSGTRGBF_1 = 0x1
	// Position of BSGTRGBR field.
	GPT164_GTICBSR_BSGTRGBR_Pos = 0x2
	// Bit mask of BSGTRGBR field.
	GPT164_GTICBSR_BSGTRGBR_Msk = 0x4
	// Bit BSGTRGBR.
	GPT164_GTICBSR_BSGTRGBR = 0x4
	// GTCCRB input capture is disable at the rising edge of GTETRGB input
	GPT164_GTICBSR_BSGTRGBR_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTETRGB input
	GPT164_GTICBSR_BSGTRGBR_1 = 0x1
	// Position of BSGTRGAF field.
	GPT164_GTICBSR_BSGTRGAF_Pos = 0x1
	// Bit mask of BSGTRGAF field.
	GPT164_GTICBSR_BSGTRGAF_Msk = 0x2
	// Bit BSGTRGAF.
	GPT164_GTICBSR_BSGTRGAF = 0x2
	// GTCCRB input capture is disable at the falling edge of GTETRGA input
	GPT164_GTICBSR_BSGTRGAF_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTETRGA input
	GPT164_GTICBSR_BSGTRGAF_1 = 0x1
	// Position of BSGTRGAR field.
	GPT164_GTICBSR_BSGTRGAR_Pos = 0x0
	// Bit mask of BSGTRGAR field.
	GPT164_GTICBSR_BSGTRGAR_Msk = 0x1
	// Bit BSGTRGAR.
	GPT164_GTICBSR_BSGTRGAR = 0x1
	// GTCCRB input capture is disable at the rising edge of GTETRGA input
	GPT164_GTICBSR_BSGTRGAR_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTETRGA input
	GPT164_GTICBSR_BSGTRGAR_1 = 0x1

	// GTCR: General PWM Timer Control Register
	// Position of TPCS field.
	GPT164_GTCR_TPCS_Pos = 0x18
	// Bit mask of TPCS field.
	GPT164_GTCR_TPCS_Msk = 0x7000000
	// PCLK/1
	GPT164_GTCR_TPCS_000 = 0x0
	// PCLK/4
	GPT164_GTCR_TPCS_001 = 0x1
	// PCLK/16
	GPT164_GTCR_TPCS_010 = 0x2
	// PCLK/64
	GPT164_GTCR_TPCS_011 = 0x3
	// PCLK/256
	GPT164_GTCR_TPCS_100 = 0x4
	// PCLK/1024
	GPT164_GTCR_TPCS_101 = 0x5
	// Position of Reserved field.
	GPT164_GTCR_Reserved_Pos = 0x13
	// Bit mask of Reserved field.
	GPT164_GTCR_Reserved_Msk = 0xf80000
	// Position of MD field.
	GPT164_GTCR_MD_Pos = 0x10
	// Bit mask of MD field.
	GPT164_GTCR_MD_Msk = 0x70000
	// Saw-wave PWM mode (single buffer or double buffer possible)
	GPT164_GTCR_MD_000 = 0x0
	// Saw-wave one-shot pulse mode (fixed buffer operation)
	GPT164_GTCR_MD_001 = 0x1
	// Setting prohibited
	GPT164_GTCR_MD_010 = 0x2
	// Setting prohibited
	GPT164_GTCR_MD_011 = 0x3
	// Triangle-wave PWM mode 1 (16-bit transfer at crest) (single buffer or double buffer possible)
	GPT164_GTCR_MD_100 = 0x4
	// Triangle-wave PWM mode 2 (16-bit transfer at crest and trough) (single buffer or double buffer possible)
	GPT164_GTCR_MD_101 = 0x5
	// Triangle-wave PWM mode 3 (32-bit transfer at trough) fixed buffer operation)
	GPT164_GTCR_MD_110 = 0x6
	// Setting prohibited
	GPT164_GTCR_MD_111 = 0x7
	// Position of Reserved field.
	GPT164_GTCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	GPT164_GTCR_Reserved_Msk = 0xfffe
	// Position of CST field.
	GPT164_GTCR_CST_Pos = 0x0
	// Bit mask of CST field.
	GPT164_GTCR_CST_Msk = 0x1
	// Bit CST.
	GPT164_GTCR_CST = 0x1
	// Count operation is stopped
	GPT164_GTCR_CST_0 = 0x0
	// Count operation is performed
	GPT164_GTCR_CST_1 = 0x1

	// GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
	// Position of OBDTYR field.
	GPT164_GTUDDTYC_OBDTYR_Pos = 0x1b
	// Bit mask of OBDTYR field.
	GPT164_GTUDDTYC_OBDTYR_Msk = 0x8000000
	// Bit OBDTYR.
	GPT164_GTUDDTYC_OBDTYR = 0x8000000
	// Apply output value set in 0 percent/100 percent duty to GTIOB[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT164_GTUDDTYC_OBDTYR_0 = 0x0
	// Apply masked compare match output value to GTIOB[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT164_GTUDDTYC_OBDTYR_1 = 0x1
	// Position of OBDTYF field.
	GPT164_GTUDDTYC_OBDTYF_Pos = 0x1a
	// Bit mask of OBDTYF field.
	GPT164_GTUDDTYC_OBDTYF_Msk = 0x4000000
	// Bit OBDTYF.
	GPT164_GTUDDTYC_OBDTYF = 0x4000000
	// Not forcibly set
	GPT164_GTUDDTYC_OBDTYF_0 = 0x0
	// Forcibly set
	GPT164_GTUDDTYC_OBDTYF_1 = 0x1
	// Position of OBDTY field.
	GPT164_GTUDDTYC_OBDTY_Pos = 0x18
	// Bit mask of OBDTY field.
	GPT164_GTUDDTYC_OBDTY_Msk = 0x3000000
	// GTIOCB pin duty is depend on compare match
	GPT164_GTUDDTYC_OBDTY_00 = 0x0
	// GTIOCB pin duty is depend on compare match
	GPT164_GTUDDTYC_OBDTY_01 = 0x1
	// GTIOCB pin duty 0 percent
	GPT164_GTUDDTYC_OBDTY_10 = 0x2
	// GTIOCB pin duty 100 percent
	GPT164_GTUDDTYC_OBDTY_11 = 0x3
	// Position of Reserved field.
	GPT164_GTUDDTYC_Reserved_Pos = 0x14
	// Bit mask of Reserved field.
	GPT164_GTUDDTYC_Reserved_Msk = 0xf00000
	// Position of OADTYR field.
	GPT164_GTUDDTYC_OADTYR_Pos = 0x13
	// Bit mask of OADTYR field.
	GPT164_GTUDDTYC_OADTYR_Msk = 0x80000
	// Bit OADTYR.
	GPT164_GTUDDTYC_OADTYR = 0x80000
	// Apply output value set in 0 percent/100 percent duty to GTIOA[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT164_GTUDDTYC_OADTYR_0 = 0x0
	// Apply masked compare match output value to GTIOA[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT164_GTUDDTYC_OADTYR_1 = 0x1
	// Position of OADTYF field.
	GPT164_GTUDDTYC_OADTYF_Pos = 0x12
	// Bit mask of OADTYF field.
	GPT164_GTUDDTYC_OADTYF_Msk = 0x40000
	// Bit OADTYF.
	GPT164_GTUDDTYC_OADTYF = 0x40000
	// Not forcibly set
	GPT164_GTUDDTYC_OADTYF_0 = 0x0
	// Forcibly set
	GPT164_GTUDDTYC_OADTYF_1 = 0x1
	// Position of OADTY field.
	GPT164_GTUDDTYC_OADTY_Pos = 0x10
	// Bit mask of OADTY field.
	GPT164_GTUDDTYC_OADTY_Msk = 0x30000
	// GTIOCA pin duty is depend on compare match
	GPT164_GTUDDTYC_OADTY_00 = 0x0
	// GTIOCA pin duty is depend on compare match
	GPT164_GTUDDTYC_OADTY_01 = 0x1
	// GTIOCA pin duty 0 percent
	GPT164_GTUDDTYC_OADTY_10 = 0x2
	// GTIOCA pin duty 100 percent
	GPT164_GTUDDTYC_OADTY_11 = 0x3
	// Position of UDF field.
	GPT164_GTUDDTYC_UDF_Pos = 0x1
	// Bit mask of UDF field.
	GPT164_GTUDDTYC_UDF_Msk = 0x2
	// Bit UDF.
	GPT164_GTUDDTYC_UDF = 0x2
	// Not forcibly set
	GPT164_GTUDDTYC_UDF_0 = 0x0
	// Forcibly set
	GPT164_GTUDDTYC_UDF_1 = 0x1
	// Position of UD field.
	GPT164_GTUDDTYC_UD_Pos = 0x0
	// Bit mask of UD field.
	GPT164_GTUDDTYC_UD_Msk = 0x1
	// Bit UD.
	GPT164_GTUDDTYC_UD = 0x1
	// GTCNT counts down.
	GPT164_GTUDDTYC_UD_0 = 0x0
	// GTCNT counts up.
	GPT164_GTUDDTYC_UD_1 = 0x1

	// GTIOR: General PWM Timer I/O Control Register
	// Position of NFCSB field.
	GPT164_GTIOR_NFCSB_Pos = 0x1e
	// Bit mask of NFCSB field.
	GPT164_GTIOR_NFCSB_Msk = 0xc0000000
	// PCLK/1
	GPT164_GTIOR_NFCSB_00 = 0x0
	// PCLK/4
	GPT164_GTIOR_NFCSB_01 = 0x1
	// PCLK/16
	GPT164_GTIOR_NFCSB_10 = 0x2
	// PCLK/64
	GPT164_GTIOR_NFCSB_11 = 0x3
	// Position of NFBEN field.
	GPT164_GTIOR_NFBEN_Pos = 0x1d
	// Bit mask of NFBEN field.
	GPT164_GTIOR_NFBEN_Msk = 0x20000000
	// Bit NFBEN.
	GPT164_GTIOR_NFBEN = 0x20000000
	// The noise filter for the GTIOCB pin is disabled.
	GPT164_GTIOR_NFBEN_0 = 0x0
	// The noise filter for the GTIOCB pin is enabled.
	GPT164_GTIOR_NFBEN_1 = 0x1
	// Position of Reserved field.
	GPT164_GTIOR_Reserved_Pos = 0x1b
	// Bit mask of Reserved field.
	GPT164_GTIOR_Reserved_Msk = 0x18000000
	// Position of OBDF field.
	GPT164_GTIOR_OBDF_Pos = 0x19
	// Bit mask of OBDF field.
	GPT164_GTIOR_OBDF_Msk = 0x6000000
	// Output disable is prohibited.
	GPT164_GTIOR_OBDF_00 = 0x0
	// GTIOCB pin is set to Hi-Z when output disable is performed.
	GPT164_GTIOR_OBDF_01 = 0x1
	// GTIOCB pin is set to 0 when output disable is performed.
	GPT164_GTIOR_OBDF_10 = 0x2
	// GTIOCB pin is set to 1 when output disable is performed.
	GPT164_GTIOR_OBDF_11 = 0x3
	// Position of OBE field.
	GPT164_GTIOR_OBE_Pos = 0x18
	// Bit mask of OBE field.
	GPT164_GTIOR_OBE_Msk = 0x1000000
	// Bit OBE.
	GPT164_GTIOR_OBE = 0x1000000
	// Output is disabled
	GPT164_GTIOR_OBE_0 = 0x0
	// Output is enabled
	GPT164_GTIOR_OBE_1 = 0x1
	// Position of OBHLD field.
	GPT164_GTIOR_OBHLD_Pos = 0x17
	// Bit mask of OBHLD field.
	GPT164_GTIOR_OBHLD_Msk = 0x800000
	// Bit OBHLD.
	GPT164_GTIOR_OBHLD = 0x800000
	// The GTIOCB pin output level at start/stop of counting depends on the register setting.
	GPT164_GTIOR_OBHLD_0 = 0x0
	// The GTIOCB pin output level is retained at start/stop of counting.
	GPT164_GTIOR_OBHLD_1 = 0x1
	// Position of OBDFLT field.
	GPT164_GTIOR_OBDFLT_Pos = 0x16
	// Bit mask of OBDFLT field.
	GPT164_GTIOR_OBDFLT_Msk = 0x400000
	// Bit OBDFLT.
	GPT164_GTIOR_OBDFLT = 0x400000
	// The GTIOCB pin outputs low when counting is stopped.
	GPT164_GTIOR_OBDFLT_0 = 0x0
	// The GTIOCB pin outputs high when counting is stopped.
	GPT164_GTIOR_OBDFLT_1 = 0x1
	// Position of Reserved field.
	GPT164_GTIOR_Reserved_Pos = 0x15
	// Bit mask of Reserved field.
	GPT164_GTIOR_Reserved_Msk = 0x200000
	// Bit Reserved.
	GPT164_GTIOR_Reserved = 0x200000
	// Position of GTIOB field.
	GPT164_GTIOR_GTIOB_Pos = 0x10
	// Bit mask of GTIOB field.
	GPT164_GTIOR_GTIOB_Msk = 0x1f0000
	// Initial output is Low. Output retained at cycle end. Output retained at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_00000 = 0x0
	// Initial output is Low. Output retained at cycle end. Low output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_00001 = 0x1
	// Initial output is Low. Output retained at cycle end. High output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_00010 = 0x2
	// Initial output is Low. Output retained at cycle end. Output toggled at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_00011 = 0x3
	// Initial output is Low. Low output at cycle end. Output retained at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_00100 = 0x4
	// Initial output is Low. Low output at cycle end. Low output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_00101 = 0x5
	// Initial output is Low. Low output at cycle end. High output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_00110 = 0x6
	// Initial output is Low. Low output at cycle end. Output toggled at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_00111 = 0x7
	// Initial output is Low. High output at cycle end. Output retained at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_01000 = 0x8
	// Initial output is Low. High output at cycle end. Low output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_01001 = 0x9
	// Initial output is Low. High output at cycle end. High output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_01010 = 0xa
	// Initial output is Low. High output at cycle end. Output toggled at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_01011 = 0xb
	// Initial output is Low. Output toggled at cycle end. Output retained at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_01100 = 0xc
	// Initial output is Low. Output toggled at cycle end. Low output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_01101 = 0xd
	// Initial output is Low. Output toggled at cycle end. High output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_01110 = 0xe
	// Initial output is Low. Output toggled at cycle end. Output toggled at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_01111 = 0xf
	// Initial output is High. Output retained at cycle end. Output retained at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_10000 = 0x10
	// Initial output is High. Output retained at cycle end. Low output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_10001 = 0x11
	// Initial output is High. Output retained at cycle end. High output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_10010 = 0x12
	// Initial output is High. Output retained at cycle end. Output toggled at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_10011 = 0x13
	// Initial output is High. Low output at cycle end. Output retained at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_10100 = 0x14
	// Initial output is High. Low output at cycle end. Low output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_10101 = 0x15
	// Initial output is High. Low output at cycle end. High output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_10110 = 0x16
	// Initial output is High. Low output at cycle end. Output toggled at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_10111 = 0x17
	// Initial output is High. High output at cycle end. Output retained at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_11000 = 0x18
	// Initial output is High. High output at cycle end. Low output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_11001 = 0x19
	// Initial output is High. High output at cycle end. High output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_11010 = 0x1a
	// Initial output is High. High output at cycle end. Output toggled at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_11011 = 0x1b
	// Initial output is High. Output toggled at cycle end. Output retained at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_11100 = 0x1c
	// Initial output is High. Output toggled at cycle end. Low output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_11101 = 0x1d
	// Initial output is High. Output toggled at cycle end. High output at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_11110 = 0x1e
	// Initial output is High. Output toggled at cycle end. Output toggled at GTCCRB compare match.
	GPT164_GTIOR_GTIOB_11111 = 0x1f
	// Position of NFCSA field.
	GPT164_GTIOR_NFCSA_Pos = 0xe
	// Bit mask of NFCSA field.
	GPT164_GTIOR_NFCSA_Msk = 0xc000
	// PCLK/1
	GPT164_GTIOR_NFCSA_00 = 0x0
	// PCLK/4
	GPT164_GTIOR_NFCSA_01 = 0x1
	// PCLK/16
	GPT164_GTIOR_NFCSA_10 = 0x2
	// PCLK/64
	GPT164_GTIOR_NFCSA_11 = 0x3
	// Position of NFAEN field.
	GPT164_GTIOR_NFAEN_Pos = 0xd
	// Bit mask of NFAEN field.
	GPT164_GTIOR_NFAEN_Msk = 0x2000
	// Bit NFAEN.
	GPT164_GTIOR_NFAEN = 0x2000
	// The noise filter for the GTIOCA pin is disabled.
	GPT164_GTIOR_NFAEN_0 = 0x0
	// The noise filter for the GTIOCA pin is enabled.
	GPT164_GTIOR_NFAEN_1 = 0x1
	// Position of Reserved field.
	GPT164_GTIOR_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	GPT164_GTIOR_Reserved_Msk = 0x1800
	// Position of OADF field.
	GPT164_GTIOR_OADF_Pos = 0x9
	// Bit mask of OADF field.
	GPT164_GTIOR_OADF_Msk = 0x600
	// Output disable is prohibited.
	GPT164_GTIOR_OADF_00 = 0x0
	// GTIOCA pin is set to Hi-Z when output disable is performed.
	GPT164_GTIOR_OADF_01 = 0x1
	// GTIOCA pin is set to 0 when output disable is performed.
	GPT164_GTIOR_OADF_10 = 0x2
	// GTIOCA pin is set to 1 when output disable is performed.
	GPT164_GTIOR_OADF_11 = 0x3
	// Position of OAE field.
	GPT164_GTIOR_OAE_Pos = 0x8
	// Bit mask of OAE field.
	GPT164_GTIOR_OAE_Msk = 0x100
	// Bit OAE.
	GPT164_GTIOR_OAE = 0x100
	// Output is disabled
	GPT164_GTIOR_OAE_0 = 0x0
	// Output is enabled
	GPT164_GTIOR_OAE_1 = 0x1
	// Position of OAHLD field.
	GPT164_GTIOR_OAHLD_Pos = 0x7
	// Bit mask of OAHLD field.
	GPT164_GTIOR_OAHLD_Msk = 0x80
	// Bit OAHLD.
	GPT164_GTIOR_OAHLD = 0x80
	// The GTIOCA pin output level at start/stop of counting depends on the register setting.
	GPT164_GTIOR_OAHLD_0 = 0x0
	// The GTIOCA pin output level is retained at start/stop of counting.
	GPT164_GTIOR_OAHLD_1 = 0x1
	// Position of OADFLT field.
	GPT164_GTIOR_OADFLT_Pos = 0x6
	// Bit mask of OADFLT field.
	GPT164_GTIOR_OADFLT_Msk = 0x40
	// Bit OADFLT.
	GPT164_GTIOR_OADFLT = 0x40
	// The GTIOCA pin outputs low when counting is stopped.
	GPT164_GTIOR_OADFLT_0 = 0x0
	// The GTIOCA pin outputs high when counting is stopped.
	GPT164_GTIOR_OADFLT_1 = 0x1
	// Position of Reserved field.
	GPT164_GTIOR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	GPT164_GTIOR_Reserved_Msk = 0x20
	// Bit Reserved.
	GPT164_GTIOR_Reserved = 0x20
	// Position of GTIOA field.
	GPT164_GTIOR_GTIOA_Pos = 0x0
	// Bit mask of GTIOA field.
	GPT164_GTIOR_GTIOA_Msk = 0x1f
	// Initial output is Low. Output retained at cycle end. Output retained at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_00000 = 0x0
	// Initial output is Low. Output retained at cycle end. Low output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_00001 = 0x1
	// Initial output is Low. Output retained at cycle end. High output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_00010 = 0x2
	// Initial output is Low. Output retained at cycle end. Output toggled at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_00011 = 0x3
	// Initial output is Low. Low output at cycle end. Output retained at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_00100 = 0x4
	// Initial output is Low. Low output at cycle end. Low output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_00101 = 0x5
	// Initial output is Low. Low output at cycle end. High output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_00110 = 0x6
	// Initial output is Low. Low output at cycle end. Output toggled at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_00111 = 0x7
	// Initial output is Low. High output at cycle end. Output retained at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_01000 = 0x8
	// Initial output is Low. High output at cycle end. Low output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_01001 = 0x9
	// Initial output is Low. High output at cycle end. High output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_01010 = 0xa
	// Initial output is Low. High output at cycle end. Output toggled at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_01011 = 0xb
	// Initial output is Low. Output toggled at cycle end. Output retained at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_01100 = 0xc
	// Initial output is Low. Output toggled at cycle end. Low output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_01101 = 0xd
	// Initial output is Low. Output toggled at cycle end. High output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_01110 = 0xe
	// Initial output is Low. Output toggled at cycle end. Output toggled at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_01111 = 0xf
	// Initial output is High. Output retained at cycle end. Output retained at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_10000 = 0x10
	// Initial output is High. Output retained at cycle end. Low output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_10001 = 0x11
	// Initial output is High. Output retained at cycle end. High output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_10010 = 0x12
	// Initial output is High. Output retained at cycle end. Output toggled at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_10011 = 0x13
	// Initial output is High. Low output at cycle end. Output retained at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_10100 = 0x14
	// Initial output is High. Low output at cycle end. Low output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_10101 = 0x15
	// Initial output is High. Low output at cycle end. High output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_10110 = 0x16
	// Initial output is High. Low output at cycle end. Output toggled at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_10111 = 0x17
	// Initial output is High. High output at cycle end. Output retained at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_11000 = 0x18
	// Initial output is High. High output at cycle end. Low output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_11001 = 0x19
	// Initial output is High. High output at cycle end. High output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_11010 = 0x1a
	// Initial output is High. High output at cycle end. Output toggled at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_11011 = 0x1b
	// Initial output is High. Output toggled at cycle end. Output retained at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_11100 = 0x1c
	// Initial output is High. Output toggled at cycle end. Low output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_11101 = 0x1d
	// Initial output is High. Output toggled at cycle end. High output at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_11110 = 0x1e
	// Initial output is High. Output toggled at cycle end. Output toggled at GTCCRA compare match.
	GPT164_GTIOR_GTIOA_11111 = 0x1f

	// GTINTAD: General PWM Timer Interrupt Output Setting Register
	// Position of GRPABL field.
	GPT164_GTINTAD_GRPABL_Pos = 0x1e
	// Bit mask of GRPABL field.
	GPT164_GTINTAD_GRPABL_Msk = 0x40000000
	// Bit GRPABL.
	GPT164_GTINTAD_GRPABL = 0x40000000
	// Same time output level low disable request is disabled.
	GPT164_GTINTAD_GRPABL_0 = 0x0
	// Same time output level low disable request is enabled.
	GPT164_GTINTAD_GRPABL_1 = 0x1
	// Position of GRPABH field.
	GPT164_GTINTAD_GRPABH_Pos = 0x1d
	// Bit mask of GRPABH field.
	GPT164_GTINTAD_GRPABH_Msk = 0x20000000
	// Bit GRPABH.
	GPT164_GTINTAD_GRPABH = 0x20000000
	// Same time output level high disable request is disabled.
	GPT164_GTINTAD_GRPABH_0 = 0x0
	// Same time output level high disable request is enabled.
	GPT164_GTINTAD_GRPABH_1 = 0x1
	// Position of Reserved field.
	GPT164_GTINTAD_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	GPT164_GTINTAD_Reserved_Msk = 0x1c000000
	// Position of GRP field.
	GPT164_GTINTAD_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT164_GTINTAD_GRP_Msk = 0x3000000
	// Group A output disable request
	GPT164_GTINTAD_GRP_00 = 0x0
	// Group B output disable request
	GPT164_GTINTAD_GRP_01 = 0x1
	// Position of Reserved field.
	GPT164_GTINTAD_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	GPT164_GTINTAD_Reserved_Msk = 0xffffff

	// GTST: General PWM Timer Status Register
	// Position of OABLF field.
	GPT164_GTST_OABLF_Pos = 0x1e
	// Bit mask of OABLF field.
	GPT164_GTST_OABLF_Msk = 0x40000000
	// Bit OABLF.
	GPT164_GTST_OABLF = 0x40000000
	// GTIOCA pin and GTIOCB pin don't output 0 at the same time.
	GPT164_GTST_OABLF_0 = 0x0
	// GTIOCA pin and GTIOCB pin output 0 at the same time.
	GPT164_GTST_OABLF_1 = 0x1
	// Position of OABHF field.
	GPT164_GTST_OABHF_Pos = 0x1d
	// Bit mask of OABHF field.
	GPT164_GTST_OABHF_Msk = 0x20000000
	// Bit OABHF.
	GPT164_GTST_OABHF = 0x20000000
	// GTIOCA pin and GTIOCB pin don't output 1 at the same time.
	GPT164_GTST_OABHF_0 = 0x0
	// GTIOCA pin and GTIOCB pin output 1 at the same time.
	GPT164_GTST_OABHF_1 = 0x1
	// Position of Reserved field.
	GPT164_GTST_Reserved_Pos = 0x19
	// Bit mask of Reserved field.
	GPT164_GTST_Reserved_Msk = 0x1e000000
	// Position of ODF field.
	GPT164_GTST_ODF_Pos = 0x18
	// Bit mask of ODF field.
	GPT164_GTST_ODF_Msk = 0x1000000
	// Bit ODF.
	GPT164_GTST_ODF = 0x1000000
	// No output disable request is generated.
	GPT164_GTST_ODF_0 = 0x0
	// An output disable request is generated.
	GPT164_GTST_ODF_1 = 0x1
	// Position of Reserved field.
	GPT164_GTST_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT164_GTST_Reserved_Msk = 0xff0000
	// Position of TUCF field.
	GPT164_GTST_TUCF_Pos = 0xf
	// Bit mask of TUCF field.
	GPT164_GTST_TUCF_Msk = 0x8000
	// Bit TUCF.
	GPT164_GTST_TUCF = 0x8000
	// The GTCNT counter counts downward.
	GPT164_GTST_TUCF_0 = 0x0
	// The GTCNT counter counts upward.
	GPT164_GTST_TUCF_1 = 0x1
	// Position of Reserved field.
	GPT164_GTST_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	GPT164_GTST_Reserved_Msk = 0x7f00
	// Position of TCFPU field.
	GPT164_GTST_TCFPU_Pos = 0x7
	// Bit mask of TCFPU field.
	GPT164_GTST_TCFPU_Msk = 0x80
	// Bit TCFPU.
	GPT164_GTST_TCFPU = 0x80
	// No underflow (trough) has occurred.
	GPT164_GTST_TCFPU_0 = 0x0
	// An underflow (trough) has occurred.
	GPT164_GTST_TCFPU_1 = 0x1
	// Position of TCPFO field.
	GPT164_GTST_TCPFO_Pos = 0x6
	// Bit mask of TCPFO field.
	GPT164_GTST_TCPFO_Msk = 0x40
	// Bit TCPFO.
	GPT164_GTST_TCPFO = 0x40
	// No overflow (crest) has occurred.
	GPT164_GTST_TCPFO_0 = 0x0
	// An overflow (crest) has occurred.
	GPT164_GTST_TCPFO_1 = 0x1
	// Position of TCFF field.
	GPT164_GTST_TCFF_Pos = 0x5
	// Bit mask of TCFF field.
	GPT164_GTST_TCFF_Msk = 0x20
	// Bit TCFF.
	GPT164_GTST_TCFF = 0x20
	// No compare match of GTCCRF is generated.
	GPT164_GTST_TCFF_0 = 0x0
	// A compare match of GTCCRF is generated.
	GPT164_GTST_TCFF_1 = 0x1
	// Position of TCFE field.
	GPT164_GTST_TCFE_Pos = 0x4
	// Bit mask of TCFE field.
	GPT164_GTST_TCFE_Msk = 0x10
	// Bit TCFE.
	GPT164_GTST_TCFE = 0x10
	// No compare match of GTCCRE is generated.
	GPT164_GTST_TCFE_0 = 0x0
	// A compare match of GTCCRE is generated.
	GPT164_GTST_TCFE_1 = 0x1
	// Position of TCFD field.
	GPT164_GTST_TCFD_Pos = 0x3
	// Bit mask of TCFD field.
	GPT164_GTST_TCFD_Msk = 0x8
	// Bit TCFD.
	GPT164_GTST_TCFD = 0x8
	// No compare match of GTCCRD is generated.
	GPT164_GTST_TCFD_0 = 0x0
	// A compare match of GTCCRD is generated.
	GPT164_GTST_TCFD_1 = 0x1
	// Position of TCFC field.
	GPT164_GTST_TCFC_Pos = 0x2
	// Bit mask of TCFC field.
	GPT164_GTST_TCFC_Msk = 0x4
	// Bit TCFC.
	GPT164_GTST_TCFC = 0x4
	// No compare match of GTCCRC is generated.
	GPT164_GTST_TCFC_0 = 0x0
	// A compare match of GTCCRC is generated.
	GPT164_GTST_TCFC_1 = 0x1
	// Position of TCFB field.
	GPT164_GTST_TCFB_Pos = 0x1
	// Bit mask of TCFB field.
	GPT164_GTST_TCFB_Msk = 0x2
	// Bit TCFB.
	GPT164_GTST_TCFB = 0x2
	// No input capture/compare match of GTCCRB is generated.
	GPT164_GTST_TCFB_0 = 0x0
	// An input capture/compare match of GTCCRB is generated.
	GPT164_GTST_TCFB_1 = 0x1
	// Position of TCFA field.
	GPT164_GTST_TCFA_Pos = 0x0
	// Bit mask of TCFA field.
	GPT164_GTST_TCFA_Msk = 0x1
	// Bit TCFA.
	GPT164_GTST_TCFA = 0x1
	// No input capture/compare match of GTCCRA is generated.
	GPT164_GTST_TCFA_0 = 0x0
	// An input capture/compare match of GTCCRA is generated.
	GPT164_GTST_TCFA_1 = 0x1

	// GTBER: General PWM Timer Buffer Enable Register
	// Position of CCRSWT field.
	GPT164_GTBER_CCRSWT_Pos = 0x16
	// Bit mask of CCRSWT field.
	GPT164_GTBER_CCRSWT_Msk = 0x400000
	// Bit CCRSWT.
	GPT164_GTBER_CCRSWT = 0x400000
	// no effect
	GPT164_GTBER_CCRSWT_0 = 0x0
	// Forcibly performs buffer transfer of GTCCRA and GTCCRB. This bit automatically returns to 0 after the writing of 1.
	GPT164_GTBER_CCRSWT_1 = 0x1
	// Position of PR field.
	GPT164_GTBER_PR_Pos = 0x14
	// Bit mask of PR field.
	GPT164_GTBER_PR_Msk = 0x300000
	// Buffer operation is not performed
	GPT164_GTBER_PR_00 = 0x0
	// Single buffer operation (GTPBR --> GTPR)
	GPT164_GTBER_PR_01 = 0x1
	// Position of CCRB field.
	GPT164_GTBER_CCRB_Pos = 0x12
	// Bit mask of CCRB field.
	GPT164_GTBER_CCRB_Msk = 0xc0000
	// Buffer operation is not performed
	GPT164_GTBER_CCRB_00 = 0x0
	// Single buffer operation (GTCCRB <--> GTCCRE)
	GPT164_GTBER_CCRB_01 = 0x1
	// Double buffer operation (GTCCRB <--> GTCCRE <--> GTCCRF)
	GPT164_GTBER_CCRB_10 = 0x2
	// Double buffer operation (GTCCRB <--> GTCCRE <--> GTCCRF)
	GPT164_GTBER_CCRB_11 = 0x3
	// Position of CCRA field.
	GPT164_GTBER_CCRA_Pos = 0x10
	// Bit mask of CCRA field.
	GPT164_GTBER_CCRA_Msk = 0x30000
	// Buffer operation is not performed
	GPT164_GTBER_CCRA_00 = 0x0
	// Single buffer operation (GTCCRA <--> GTCCRC)
	GPT164_GTBER_CCRA_01 = 0x1
	// Double buffer operation (GTCCRA <--> GTCCRC <--> GTCCRD)
	GPT164_GTBER_CCRA_10 = 0x2
	// Double buffer operation (GTCCRA <--> GTCCRC <--> GTCCRD)
	GPT164_GTBER_CCRA_11 = 0x3
	// Position of BD field.
	GPT164_GTBER_BD_Pos = 0x0
	// Bit mask of BD field.
	GPT164_GTBER_BD_Msk = 0x3
	// Buffer operation is enabled
	GPT164_GTBER_BD_0 = 0x0
	// Buffer operation is disabled
	GPT164_GTBER_BD_1 = 0x1

	// GTCNT: General PWM Timer Counter
	// Position of GTCNT field.
	GPT164_GTCNT_GTCNT_Pos = 0x0
	// Bit mask of GTCNT field.
	GPT164_GTCNT_GTCNT_Msk = 0xffffffff

	// GTCCRA: General PWM Timer Compare Capture Register A
	// Position of GTCCRA field.
	GPT164_GTCCRA_GTCCRA_Pos = 0x0
	// Bit mask of GTCCRA field.
	GPT164_GTCCRA_GTCCRA_Msk = 0xffffffff

	// GTCCRB: General PWM Timer Compare Capture Register B
	// Position of GTCCRB field.
	GPT164_GTCCRB_GTCCRB_Pos = 0x0
	// Bit mask of GTCCRB field.
	GPT164_GTCCRB_GTCCRB_Msk = 0xffffffff

	// GTCCRC: General PWM Timer Compare Capture Register C
	// Position of GTCCRC field.
	GPT164_GTCCRC_GTCCRC_Pos = 0x0
	// Bit mask of GTCCRC field.
	GPT164_GTCCRC_GTCCRC_Msk = 0xffffffff

	// GTCCRE: General PWM Timer Compare Capture Register E
	// Position of GTCCRE field.
	GPT164_GTCCRE_GTCCRE_Pos = 0x0
	// Bit mask of GTCCRE field.
	GPT164_GTCCRE_GTCCRE_Msk = 0xffffffff

	// GTCCRD: General PWM Timer Compare Capture Register D
	// Position of GTCCRD field.
	GPT164_GTCCRD_GTCCRD_Pos = 0x0
	// Bit mask of GTCCRD field.
	GPT164_GTCCRD_GTCCRD_Msk = 0xffffffff

	// GTCCRF: General PWM Timer Compare Capture Register F
	// Position of GTCCRF field.
	GPT164_GTCCRF_GTCCRF_Pos = 0x0
	// Bit mask of GTCCRF field.
	GPT164_GTCCRF_GTCCRF_Msk = 0xffffffff

	// GTPR: General PWM Timer Cycle Setting Register
	// Position of GTPR field.
	GPT164_GTPR_GTPR_Pos = 0x0
	// Bit mask of GTPR field.
	GPT164_GTPR_GTPR_Msk = 0xffffffff

	// GTPBR: General PWM Timer Cycle Setting Buffer Register
	// Position of GTPBR field.
	GPT164_GTPBR_GTPBR_Pos = 0x0
	// Bit mask of GTPBR field.
	GPT164_GTPBR_GTPBR_Msk = 0xffffffff

	// GTDTCR: General PWM Timer Dead Time Control Register
	// Position of Reserved field.
	GPT164_GTDTCR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	GPT164_GTDTCR_Reserved_Msk = 0xfffffe00
	// Position of Reserved field.
	GPT164_GTDTCR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	GPT164_GTDTCR_Reserved_Msk = 0x100
	// Bit Reserved.
	GPT164_GTDTCR_Reserved = 0x100
	// Position of Reserved field.
	GPT164_GTDTCR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	GPT164_GTDTCR_Reserved_Msk = 0xc0
	// Position of Reserved field.
	GPT164_GTDTCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	GPT164_GTDTCR_Reserved_Msk = 0x20
	// Bit Reserved.
	GPT164_GTDTCR_Reserved = 0x20
	// Position of Reserved field.
	GPT164_GTDTCR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT164_GTDTCR_Reserved_Msk = 0x10
	// Bit Reserved.
	GPT164_GTDTCR_Reserved = 0x10
	// Position of Reserved field.
	GPT164_GTDTCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	GPT164_GTDTCR_Reserved_Msk = 0xe
	// Position of TDE field.
	GPT164_GTDTCR_TDE_Pos = 0x0
	// Bit mask of TDE field.
	GPT164_GTDTCR_TDE_Msk = 0x1
	// Bit TDE.
	GPT164_GTDTCR_TDE = 0x1
	// GTCCRB is set without using GTDVU and GTDVD.
	GPT164_GTDTCR_TDE_0 = 0x0
	// GTDVU and GTDVD are used to set the compare match value for negative-phase waveform with dead time automatically in GTCCRB.
	GPT164_GTDTCR_TDE_1 = 0x1

	// GTDVU: General PWM Timer Dead Time Value Register U
	// Position of GTDVU field.
	GPT164_GTDVU_GTDVU_Pos = 0x0
	// Bit mask of GTDVU field.
	GPT164_GTDVU_GTDVU_Msk = 0xffffffff
)

// Constants for GPT_OPS: Output Phase Switching Controller
const (
	// OPSCR: Output Phase Switching Control Register
	// Position of NFCS field.
	GPT_OPS_OPSCR_NFCS_Pos = 0x1e
	// Bit mask of NFCS field.
	GPT_OPS_OPSCR_NFCS_Msk = 0xc0000000
	// PCLK/1
	GPT_OPS_OPSCR_NFCS_00 = 0x0
	// PCLK/4
	GPT_OPS_OPSCR_NFCS_01 = 0x1
	// PCLK/16
	GPT_OPS_OPSCR_NFCS_10 = 0x2
	// PCLK/64
	GPT_OPS_OPSCR_NFCS_11 = 0x3
	// Position of NFEN field.
	GPT_OPS_OPSCR_NFEN_Pos = 0x1d
	// Bit mask of NFEN field.
	GPT_OPS_OPSCR_NFEN_Msk = 0x20000000
	// Bit NFEN.
	GPT_OPS_OPSCR_NFEN = 0x20000000
	// Do not use a noise filter to the external input.
	GPT_OPS_OPSCR_NFEN_0 = 0x0
	// Use a noise filter to the external input.
	GPT_OPS_OPSCR_NFEN_1 = 0x1
	// Position of Reserved field.
	GPT_OPS_OPSCR_Reserved_Pos = 0x1b
	// Bit mask of Reserved field.
	GPT_OPS_OPSCR_Reserved_Msk = 0x18000000
	// Position of GODF field.
	GPT_OPS_OPSCR_GODF_Pos = 0x1a
	// Bit mask of GODF field.
	GPT_OPS_OPSCR_GODF_Msk = 0x4000000
	// Bit GODF.
	GPT_OPS_OPSCR_GODF = 0x4000000
	// This bit function is ignored.
	GPT_OPS_OPSCR_GODF_0 = 0x0
	// Group disable will clear OPSCR.EN Bit.
	GPT_OPS_OPSCR_GODF_1 = 0x1
	// Position of GRP field.
	GPT_OPS_OPSCR_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT_OPS_OPSCR_GRP_Msk = 0x3000000
	// Select Group A output disable source
	GPT_OPS_OPSCR_GRP_00 = 0x0
	// Select Group B output disable source
	GPT_OPS_OPSCR_GRP_01 = 0x1
	// Position of Reserved field.
	GPT_OPS_OPSCR_Reserved_Pos = 0x16
	// Bit mask of Reserved field.
	GPT_OPS_OPSCR_Reserved_Msk = 0xc00000
	// Position of ALIGN field.
	GPT_OPS_OPSCR_ALIGN_Pos = 0x15
	// Bit mask of ALIGN field.
	GPT_OPS_OPSCR_ALIGN_Msk = 0x200000
	// Bit ALIGN.
	GPT_OPS_OPSCR_ALIGN = 0x200000
	// Input phase is aligned to PCLK.
	GPT_OPS_OPSCR_ALIGN_0 = 0x0
	// Input phase is aligned PWM.
	GPT_OPS_OPSCR_ALIGN_1 = 0x1
	// Position of RV field.
	GPT_OPS_OPSCR_RV_Pos = 0x14
	// Bit mask of RV field.
	GPT_OPS_OPSCR_RV_Msk = 0x100000
	// Bit RV.
	GPT_OPS_OPSCR_RV = 0x100000
	// U/V/W-Phase output
	GPT_OPS_OPSCR_RV_0 = 0x0
	// Output to reverse the V / W-phase
	GPT_OPS_OPSCR_RV_1 = 0x1
	// Position of INV field.
	GPT_OPS_OPSCR_INV_Pos = 0x13
	// Bit mask of INV field.
	GPT_OPS_OPSCR_INV_Msk = 0x80000
	// Bit INV.
	GPT_OPS_OPSCR_INV = 0x80000
	// Positive Logic (Active High)output
	GPT_OPS_OPSCR_INV_0 = 0x0
	// Negative Logic (Active Low)output
	GPT_OPS_OPSCR_INV_1 = 0x1
	// Position of N field.
	GPT_OPS_OPSCR_N_Pos = 0x12
	// Bit mask of N field.
	GPT_OPS_OPSCR_N_Msk = 0x40000
	// Bit N.
	GPT_OPS_OPSCR_N = 0x40000
	// Level signal output
	GPT_OPS_OPSCR_N_0 = 0x0
	// PWM signal output (PWM of GPT0)
	GPT_OPS_OPSCR_N_1 = 0x1
	// Position of P field.
	GPT_OPS_OPSCR_P_Pos = 0x11
	// Bit mask of P field.
	GPT_OPS_OPSCR_P_Msk = 0x20000
	// Bit P.
	GPT_OPS_OPSCR_P = 0x20000
	// Level signal output
	GPT_OPS_OPSCR_P_0 = 0x0
	// PWM signal output (PWM of GPT0)
	GPT_OPS_OPSCR_P_1 = 0x1
	// Position of FB field.
	GPT_OPS_OPSCR_FB_Pos = 0x10
	// Bit mask of FB field.
	GPT_OPS_OPSCR_FB_Msk = 0x10000
	// Bit FB.
	GPT_OPS_OPSCR_FB = 0x10000
	// Select the external input.
	GPT_OPS_OPSCR_FB_0 = 0x0
	// Select the soft setting(OPSCR.UF, VF, WF).
	GPT_OPS_OPSCR_FB_1 = 0x1
	// Position of Reserved field.
	GPT_OPS_OPSCR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	GPT_OPS_OPSCR_Reserved_Msk = 0xfe00
	// Position of EN field.
	GPT_OPS_OPSCR_EN_Pos = 0x8
	// Bit mask of EN field.
	GPT_OPS_OPSCR_EN_Msk = 0x100
	// Bit EN.
	GPT_OPS_OPSCR_EN = 0x100
	// Not Output(Hi-Z external terminals).
	GPT_OPS_OPSCR_EN_0 = 0x0
	// Output
	GPT_OPS_OPSCR_EN_1 = 0x1
	// Position of Reserved field.
	GPT_OPS_OPSCR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	GPT_OPS_OPSCR_Reserved_Msk = 0x80
	// Bit Reserved.
	GPT_OPS_OPSCR_Reserved = 0x80
	// Position of W field.
	GPT_OPS_OPSCR_W_Pos = 0x6
	// Bit mask of W field.
	GPT_OPS_OPSCR_W_Msk = 0x40
	// Bit W.
	GPT_OPS_OPSCR_W = 0x40
	// Position of V field.
	GPT_OPS_OPSCR_V_Pos = 0x5
	// Bit mask of V field.
	GPT_OPS_OPSCR_V_Msk = 0x20
	// Bit V.
	GPT_OPS_OPSCR_V = 0x20
	// Position of U field.
	GPT_OPS_OPSCR_U_Pos = 0x4
	// Bit mask of U field.
	GPT_OPS_OPSCR_U_Msk = 0x10
	// Bit U.
	GPT_OPS_OPSCR_U = 0x10
	// Position of Reserved field.
	GPT_OPS_OPSCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	GPT_OPS_OPSCR_Reserved_Msk = 0x8
	// Bit Reserved.
	GPT_OPS_OPSCR_Reserved = 0x8
	// Position of WF field.
	GPT_OPS_OPSCR_WF_Pos = 0x2
	// Bit mask of WF field.
	GPT_OPS_OPSCR_WF_Msk = 0x4
	// Bit WF.
	GPT_OPS_OPSCR_WF = 0x4
	// Position of VF field.
	GPT_OPS_OPSCR_VF_Pos = 0x1
	// Bit mask of VF field.
	GPT_OPS_OPSCR_VF_Msk = 0x2
	// Bit VF.
	GPT_OPS_OPSCR_VF = 0x2
	// Position of UF field.
	GPT_OPS_OPSCR_UF_Pos = 0x0
	// Bit mask of UF field.
	GPT_OPS_OPSCR_UF_Msk = 0x1
	// Bit UF.
	GPT_OPS_OPSCR_UF = 0x1
)

// Constants for AGT0: Asynchronous General purpose Timer 0
const (
	// AGT: AGT Counter Register
	// Position of AGT field.
	AGT0_AGT_AGT_Pos = 0x0
	// Bit mask of AGT field.
	AGT0_AGT_AGT_Msk = 0xffff

	// AGTCMA: AGT Compare Match A Register
	// Position of AGTCMA field.
	AGT0_AGTCMA_AGTCMA_Pos = 0x0
	// Bit mask of AGTCMA field.
	AGT0_AGTCMA_AGTCMA_Msk = 0xffff

	// AGTCMB: AGT Compare Match B Register
	// Position of AGTCMB field.
	AGT0_AGTCMB_AGTCMB_Pos = 0x0
	// Bit mask of AGTCMB field.
	AGT0_AGTCMB_AGTCMB_Msk = 0xffff

	// AGTCR: AGT Control Register
	// Position of TCMBF field.
	AGT0_AGTCR_TCMBF_Pos = 0x7
	// Bit mask of TCMBF field.
	AGT0_AGTCR_TCMBF_Msk = 0x80
	// Bit TCMBF.
	AGT0_AGTCR_TCMBF = 0x80
	// No match
	AGT0_AGTCR_TCMBF_0 = 0x0
	// Match.
	AGT0_AGTCR_TCMBF_1 = 0x1
	// Position of TCMAF field.
	AGT0_AGTCR_TCMAF_Pos = 0x6
	// Bit mask of TCMAF field.
	AGT0_AGTCR_TCMAF_Msk = 0x40
	// Bit TCMAF.
	AGT0_AGTCR_TCMAF = 0x40
	// No match
	AGT0_AGTCR_TCMAF_0 = 0x0
	// Match.
	AGT0_AGTCR_TCMAF_1 = 0x1
	// Position of TUNDF field.
	AGT0_AGTCR_TUNDF_Pos = 0x5
	// Bit mask of TUNDF field.
	AGT0_AGTCR_TUNDF_Msk = 0x20
	// Bit TUNDF.
	AGT0_AGTCR_TUNDF = 0x20
	// No match
	AGT0_AGTCR_TUNDF_0 = 0x0
	// Match.
	AGT0_AGTCR_TUNDF_1 = 0x1
	// Position of TEDGF field.
	AGT0_AGTCR_TEDGF_Pos = 0x4
	// Bit mask of TEDGF field.
	AGT0_AGTCR_TEDGF_Msk = 0x10
	// Bit TEDGF.
	AGT0_AGTCR_TEDGF = 0x10
	// No active edge received
	AGT0_AGTCR_TEDGF_0 = 0x0
	// Active edge received.
	AGT0_AGTCR_TEDGF_1 = 0x1
	// Position of Reserved field.
	AGT0_AGTCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	AGT0_AGTCR_Reserved_Msk = 0x8
	// Bit Reserved.
	AGT0_AGTCR_Reserved = 0x8
	// Position of TSTOP field.
	AGT0_AGTCR_TSTOP_Pos = 0x2
	// Bit mask of TSTOP field.
	AGT0_AGTCR_TSTOP_Msk = 0x4
	// Bit TSTOP.
	AGT0_AGTCR_TSTOP = 0x4
	// Writing is invalid
	AGT0_AGTCR_TSTOP_0 = 0x0
	// The count is forcibly stopped.
	AGT0_AGTCR_TSTOP_1 = 0x1
	// Position of TCSTF field.
	AGT0_AGTCR_TCSTF_Pos = 0x1
	// Bit mask of TCSTF field.
	AGT0_AGTCR_TCSTF_Msk = 0x2
	// Bit TCSTF.
	AGT0_AGTCR_TCSTF = 0x2
	// Count stops
	AGT0_AGTCR_TCSTF_0 = 0x0
	// Count in progress.
	AGT0_AGTCR_TCSTF_1 = 0x1
	// Position of TSTART field.
	AGT0_AGTCR_TSTART_Pos = 0x0
	// Bit mask of TSTART field.
	AGT0_AGTCR_TSTART_Msk = 0x1
	// Bit TSTART.
	AGT0_AGTCR_TSTART = 0x1
	// Count stops
	AGT0_AGTCR_TSTART_0 = 0x0
	// Count starts.
	AGT0_AGTCR_TSTART_1 = 0x1

	// AGTMR1: AGT Mode Register 1
	// Position of Reserved field.
	AGT0_AGTMR1_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	AGT0_AGTMR1_Reserved_Msk = 0x80
	// Bit Reserved.
	AGT0_AGTMR1_Reserved = 0x80
	// Position of TCK field.
	AGT0_AGTMR1_TCK_Pos = 0x4
	// Bit mask of TCK field.
	AGT0_AGTMR1_TCK_Msk = 0x70
	// PCLKB
	AGT0_AGTMR1_TCK_000 = 0x0
	// PCLKB/8
	AGT0_AGTMR1_TCK_001 = 0x1
	// PCLKB/2
	AGT0_AGTMR1_TCK_011 = 0x3
	// Divided clock AGTLCLK specified by CKS[2:0] bits in the AGTMR2 register
	AGT0_AGTMR1_TCK_100 = 0x4
	// Underflow event signal from AGT0*6
	AGT0_AGTMR1_TCK_101 = 0x5
	// Divided clock AGTSCLK specified by CKS[2:0] bits in the AGTMR2 register.
	AGT0_AGTMR1_TCK_110 = 0x6
	// Position of TEDGPL field.
	AGT0_AGTMR1_TEDGPL_Pos = 0x3
	// Bit mask of TEDGPL field.
	AGT0_AGTMR1_TEDGPL_Msk = 0x8
	// Bit TEDGPL.
	AGT0_AGTMR1_TEDGPL = 0x8
	// Single-edge
	AGT0_AGTMR1_TEDGPL_0 = 0x0
	// Both-edge.
	AGT0_AGTMR1_TEDGPL_1 = 0x1
	// Position of TMOD field.
	AGT0_AGTMR1_TMOD_Pos = 0x0
	// Bit mask of TMOD field.
	AGT0_AGTMR1_TMOD_Msk = 0x7
	// Timer mode
	AGT0_AGTMR1_TMOD_000 = 0x0
	// Pulse output mode
	AGT0_AGTMR1_TMOD_001 = 0x1
	// Event counter mode
	AGT0_AGTMR1_TMOD_010 = 0x2
	// Pulse width measurement mode
	AGT0_AGTMR1_TMOD_011 = 0x3
	// Pulse period measurement mode.
	AGT0_AGTMR1_TMOD_100 = 0x4

	// AGTMR2: AGT Mode Register 2
	// Position of LPM field.
	AGT0_AGTMR2_LPM_Pos = 0x7
	// Bit mask of LPM field.
	AGT0_AGTMR2_LPM_Msk = 0x80
	// Bit LPM.
	AGT0_AGTMR2_LPM = 0x80
	// Normal mode
	AGT0_AGTMR2_LPM_0 = 0x0
	// Low Power mode
	AGT0_AGTMR2_LPM_1 = 0x1
	// Position of Reserved field.
	AGT0_AGTMR2_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	AGT0_AGTMR2_Reserved_Msk = 0x78
	// Position of CKS field.
	AGT0_AGTMR2_CKS_Pos = 0x0
	// Bit mask of CKS field.
	AGT0_AGTMR2_CKS_Msk = 0x7
	// 1/1
	AGT0_AGTMR2_CKS_000 = 0x0
	// 1/2
	AGT0_AGTMR2_CKS_001 = 0x1
	// 1/4
	AGT0_AGTMR2_CKS_010 = 0x2
	// 1/8
	AGT0_AGTMR2_CKS_011 = 0x3
	// 1/16
	AGT0_AGTMR2_CKS_100 = 0x4
	// 1/32
	AGT0_AGTMR2_CKS_101 = 0x5
	// 1/64
	AGT0_AGTMR2_CKS_110 = 0x6
	// 1/128.
	AGT0_AGTMR2_CKS_111 = 0x7

	// AGTIOC: AGT I/O Control Register
	// Position of TIOGT field.
	AGT0_AGTIOC_TIOGT_Pos = 0x6
	// Bit mask of TIOGT field.
	AGT0_AGTIOC_TIOGT_Msk = 0xc0
	// Event is always counted
	AGT0_AGTIOC_TIOGT_00 = 0x0
	// Event is counted during polarity period specified for AGTEEn.
	AGT0_AGTIOC_TIOGT_01 = 0x1
	// Position of TIPF field.
	AGT0_AGTIOC_TIPF_Pos = 0x4
	// Bit mask of TIPF field.
	AGT0_AGTIOC_TIPF_Msk = 0x30
	// No filter
	AGT0_AGTIOC_TIPF_00 = 0x0
	// Filter sampled at PCLKB
	AGT0_AGTIOC_TIPF_01 = 0x1
	// Filter sampled at PCLKB/8
	AGT0_AGTIOC_TIPF_10 = 0x2
	// Filter sampled at PCLKB/32
	AGT0_AGTIOC_TIPF_11 = 0x3
	// Position of Reserved field.
	AGT0_AGTIOC_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	AGT0_AGTIOC_Reserved_Msk = 0x8
	// Bit Reserved.
	AGT0_AGTIOC_Reserved = 0x8
	// Position of TOE field.
	AGT0_AGTIOC_TOE_Pos = 0x2
	// Bit mask of TOE field.
	AGT0_AGTIOC_TOE_Msk = 0x4
	// Bit TOE.
	AGT0_AGTIOC_TOE = 0x4
	// AGTOn output disabled
	AGT0_AGTIOC_TOE_0 = 0x0
	// AGTOn output enabled.
	AGT0_AGTIOC_TOE_1 = 0x1
	// Position of Reserved field.
	AGT0_AGTIOC_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	AGT0_AGTIOC_Reserved_Msk = 0x2
	// Bit Reserved.
	AGT0_AGTIOC_Reserved = 0x2
	// Position of TEDGSEL field.
	AGT0_AGTIOC_TEDGSEL_Pos = 0x0
	// Bit mask of TEDGSEL field.
	AGT0_AGTIOC_TEDGSEL_Msk = 0x1
	// Bit TEDGSEL.
	AGT0_AGTIOC_TEDGSEL = 0x1

	// AGTISR: AGT Event Pin Select Register
	// Position of Reserved field.
	AGT0_AGTISR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	AGT0_AGTISR_Reserved_Msk = 0xf8
	// Position of EEPS field.
	AGT0_AGTISR_EEPS_Pos = 0x2
	// Bit mask of EEPS field.
	AGT0_AGTISR_EEPS_Msk = 0x4
	// Bit EEPS.
	AGT0_AGTISR_EEPS = 0x4
	// An event is counted during the low-level period
	AGT0_AGTISR_EEPS_0 = 0x0
	// An event is counted during the high-level period
	AGT0_AGTISR_EEPS_1 = 0x1
	// Position of Reserved field.
	AGT0_AGTISR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	AGT0_AGTISR_Reserved_Msk = 0x3

	// AGTCMSR: AGT Compare Match Function Select Register
	// Position of Reserved field.
	AGT0_AGTCMSR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	AGT0_AGTCMSR_Reserved_Msk = 0x80
	// Bit Reserved.
	AGT0_AGTCMSR_Reserved = 0x80
	// Position of TOPOLB field.
	AGT0_AGTCMSR_TOPOLB_Pos = 0x6
	// Bit mask of TOPOLB field.
	AGT0_AGTCMSR_TOPOLB_Msk = 0x40
	// Bit TOPOLB.
	AGT0_AGTCMSR_TOPOLB = 0x40
	// AGTOB Output is started at low
	AGT0_AGTCMSR_TOPOLB_0 = 0x0
	// AGTOB Output is started at high
	AGT0_AGTCMSR_TOPOLB_1 = 0x1
	// Position of TOEB field.
	AGT0_AGTCMSR_TOEB_Pos = 0x5
	// Bit mask of TOEB field.
	AGT0_AGTCMSR_TOEB_Msk = 0x20
	// Bit TOEB.
	AGT0_AGTCMSR_TOEB = 0x20
	// AGTOB output disabled (port)
	AGT0_AGTCMSR_TOEB_0 = 0x0
	// AGTOB output enabled
	AGT0_AGTCMSR_TOEB_1 = 0x1
	// Position of TCMEB field.
	AGT0_AGTCMSR_TCMEB_Pos = 0x4
	// Bit mask of TCMEB field.
	AGT0_AGTCMSR_TCMEB_Msk = 0x10
	// Bit TCMEB.
	AGT0_AGTCMSR_TCMEB = 0x10
	// Disable compare match B register
	AGT0_AGTCMSR_TCMEB_0 = 0x0
	// Enable compare match B register
	AGT0_AGTCMSR_TCMEB_1 = 0x1
	// Position of Reserved field.
	AGT0_AGTCMSR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	AGT0_AGTCMSR_Reserved_Msk = 0x8
	// Bit Reserved.
	AGT0_AGTCMSR_Reserved = 0x8
	// Position of TOPOLA field.
	AGT0_AGTCMSR_TOPOLA_Pos = 0x2
	// Bit mask of TOPOLA field.
	AGT0_AGTCMSR_TOPOLA_Msk = 0x4
	// Bit TOPOLA.
	AGT0_AGTCMSR_TOPOLA = 0x4
	// AGTOA Output is started at low
	AGT0_AGTCMSR_TOPOLA_0 = 0x0
	// AGTOA Output is started at high
	AGT0_AGTCMSR_TOPOLA_1 = 0x1
	// Position of TOEA field.
	AGT0_AGTCMSR_TOEA_Pos = 0x1
	// Bit mask of TOEA field.
	AGT0_AGTCMSR_TOEA_Msk = 0x2
	// Bit TOEA.
	AGT0_AGTCMSR_TOEA = 0x2
	// AGTOA output disabled (port)
	AGT0_AGTCMSR_TOEA_0 = 0x0
	// AGTOA output enabled
	AGT0_AGTCMSR_TOEA_1 = 0x1
	// Position of TCMEA field.
	AGT0_AGTCMSR_TCMEA_Pos = 0x0
	// Bit mask of TCMEA field.
	AGT0_AGTCMSR_TCMEA_Msk = 0x1
	// Bit TCMEA.
	AGT0_AGTCMSR_TCMEA = 0x1
	// Disable compare match A register
	AGT0_AGTCMSR_TCMEA_0 = 0x0
	// Enable compare match A register
	AGT0_AGTCMSR_TCMEA_1 = 0x1

	// AGTIOSEL: AGT Pin Select Register
	// Position of Reserved field.
	AGT0_AGTIOSEL_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	AGT0_AGTIOSEL_Reserved_Msk = 0xe0
	// Position of TIES field.
	AGT0_AGTIOSEL_TIES_Pos = 0x4
	// Bit mask of TIES field.
	AGT0_AGTIOSEL_TIES_Msk = 0x10
	// Bit TIES.
	AGT0_AGTIOSEL_TIES = 0x10
	// External event input is disabled during Software Standby mode
	AGT0_AGTIOSEL_TIES_0 = 0x0
	// External event input is enabled during Software Standby mode.
	AGT0_AGTIOSEL_TIES_1 = 0x1
	// Position of Reserved field.
	AGT0_AGTIOSEL_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	AGT0_AGTIOSEL_Reserved_Msk = 0xc
	// Position of SEL field.
	AGT0_AGTIOSEL_SEL_Pos = 0x0
	// Bit mask of SEL field.
	AGT0_AGTIOSEL_SEL_Msk = 0x3
	// Select the AGTIOn except for below pins
	AGT0_AGTIOSEL_SEL_00 = 0x0
	// Setting prohibited
	AGT0_AGTIOSEL_SEL_01 = 0x1
	// Select the P402/AGTIOn. P402/AGTIOn is input only. It is not possible to output
	AGT0_AGTIOSEL_SEL_10 = 0x2
	// Select the P403/AGTIOn. P403/AGTIOn is input only. It is not possible to output
	AGT0_AGTIOSEL_SEL_11 = 0x3
)

// Constants for RTC: Realtime Clock
const (
	// R64CNT: 64-Hz Counter
	// Position of F1HZ field.
	RTC_R64CNT_F1HZ_Pos = 0x6
	// Bit mask of F1HZ field.
	RTC_R64CNT_F1HZ_Msk = 0x40
	// Bit F1HZ.
	RTC_R64CNT_F1HZ = 0x40
	// Position of F2HZ field.
	RTC_R64CNT_F2HZ_Pos = 0x5
	// Bit mask of F2HZ field.
	RTC_R64CNT_F2HZ_Msk = 0x20
	// Bit F2HZ.
	RTC_R64CNT_F2HZ = 0x20
	// Position of F4HZ field.
	RTC_R64CNT_F4HZ_Pos = 0x4
	// Bit mask of F4HZ field.
	RTC_R64CNT_F4HZ_Msk = 0x10
	// Bit F4HZ.
	RTC_R64CNT_F4HZ = 0x10
	// Position of F8HZ field.
	RTC_R64CNT_F8HZ_Pos = 0x3
	// Bit mask of F8HZ field.
	RTC_R64CNT_F8HZ_Msk = 0x8
	// Bit F8HZ.
	RTC_R64CNT_F8HZ = 0x8
	// Position of F16HZ field.
	RTC_R64CNT_F16HZ_Pos = 0x2
	// Bit mask of F16HZ field.
	RTC_R64CNT_F16HZ_Msk = 0x4
	// Bit F16HZ.
	RTC_R64CNT_F16HZ = 0x4
	// Position of F32HZ field.
	RTC_R64CNT_F32HZ_Pos = 0x1
	// Bit mask of F32HZ field.
	RTC_R64CNT_F32HZ_Msk = 0x2
	// Bit F32HZ.
	RTC_R64CNT_F32HZ = 0x2
	// Position of F64HZ field.
	RTC_R64CNT_F64HZ_Pos = 0x0
	// Bit mask of F64HZ field.
	RTC_R64CNT_F64HZ_Msk = 0x1
	// Bit F64HZ.
	RTC_R64CNT_F64HZ = 0x1

	// RSECCNT: Second Counter
	// Position of SEC10 field.
	RTC_RSECCNT_SEC10_Pos = 0x4
	// Bit mask of SEC10 field.
	RTC_RSECCNT_SEC10_Msk = 0x70
	// Position of SEC1 field.
	RTC_RSECCNT_SEC1_Pos = 0x0
	// Bit mask of SEC1 field.
	RTC_RSECCNT_SEC1_Msk = 0xf

	// BCNT0: Binary Counter 0
	// Position of BCNT0 field.
	RTC_BCNT0_BCNT0_Pos = 0x0
	// Bit mask of BCNT0 field.
	RTC_BCNT0_BCNT0_Msk = 0xff

	// RMINCNT: Minute Counter
	// Position of MIN10 field.
	RTC_RMINCNT_MIN10_Pos = 0x4
	// Bit mask of MIN10 field.
	RTC_RMINCNT_MIN10_Msk = 0x70
	// Position of MIN1 field.
	RTC_RMINCNT_MIN1_Pos = 0x0
	// Bit mask of MIN1 field.
	RTC_RMINCNT_MIN1_Msk = 0xf

	// BCNT1: Binary Counter 1
	// Position of BCNT1 field.
	RTC_BCNT1_BCNT1_Pos = 0x0
	// Bit mask of BCNT1 field.
	RTC_BCNT1_BCNT1_Msk = 0xff

	// RHRCNT: Hour Counter
	// Position of PM field.
	RTC_RHRCNT_PM_Pos = 0x6
	// Bit mask of PM field.
	RTC_RHRCNT_PM_Msk = 0x40
	// Bit PM.
	RTC_RHRCNT_PM = 0x40
	// a.m.
	RTC_RHRCNT_PM_0 = 0x0
	// p.m.
	RTC_RHRCNT_PM_1 = 0x1
	// Position of HR10 field.
	RTC_RHRCNT_HR10_Pos = 0x4
	// Bit mask of HR10 field.
	RTC_RHRCNT_HR10_Msk = 0x30
	// Position of HR1 field.
	RTC_RHRCNT_HR1_Pos = 0x0
	// Bit mask of HR1 field.
	RTC_RHRCNT_HR1_Msk = 0xf

	// BCNT2: Binary Counter 2
	// Position of BCNT2 field.
	RTC_BCNT2_BCNT2_Pos = 0x0
	// Bit mask of BCNT2 field.
	RTC_BCNT2_BCNT2_Msk = 0xff

	// RWKCNT: Day-of-Week Counter
	// Position of DAYW field.
	RTC_RWKCNT_DAYW_Pos = 0x0
	// Bit mask of DAYW field.
	RTC_RWKCNT_DAYW_Msk = 0x7
	// Sunday
	RTC_RWKCNT_DAYW_000 = 0x0
	// Monday
	RTC_RWKCNT_DAYW_001 = 0x1
	// Tuesday
	RTC_RWKCNT_DAYW_010 = 0x2
	// Wednesday
	RTC_RWKCNT_DAYW_011 = 0x3
	// Thursday
	RTC_RWKCNT_DAYW_100 = 0x4
	// Friday
	RTC_RWKCNT_DAYW_101 = 0x5
	// Saturday
	RTC_RWKCNT_DAYW_110 = 0x6
	// Setting Prohibited
	RTC_RWKCNT_DAYW_111 = 0x7

	// BCNT3: Binary Counter 3
	// Position of BCNT3 field.
	RTC_BCNT3_BCNT3_Pos = 0x0
	// Bit mask of BCNT3 field.
	RTC_BCNT3_BCNT3_Msk = 0xff

	// RDAYCNT: Day Counter
	// Position of DATE10 field.
	RTC_RDAYCNT_DATE10_Pos = 0x4
	// Bit mask of DATE10 field.
	RTC_RDAYCNT_DATE10_Msk = 0x30
	// Position of DATE1 field.
	RTC_RDAYCNT_DATE1_Pos = 0x0
	// Bit mask of DATE1 field.
	RTC_RDAYCNT_DATE1_Msk = 0xf

	// RMONCNT: Month Counter
	// Position of Reserved field.
	RTC_RMONCNT_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	RTC_RMONCNT_Reserved_Msk = 0xe0
	// Position of MON10 field.
	RTC_RMONCNT_MON10_Pos = 0x4
	// Bit mask of MON10 field.
	RTC_RMONCNT_MON10_Msk = 0x10
	// Bit MON10.
	RTC_RMONCNT_MON10 = 0x10
	// Position of MON1 field.
	RTC_RMONCNT_MON1_Pos = 0x0
	// Bit mask of MON1 field.
	RTC_RMONCNT_MON1_Msk = 0xf

	// RYRCNT: Year Counter
	// Position of Reserved field.
	RTC_RYRCNT_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	RTC_RYRCNT_Reserved_Msk = 0xff00
	// Position of YR10 field.
	RTC_RYRCNT_YR10_Pos = 0x4
	// Bit mask of YR10 field.
	RTC_RYRCNT_YR10_Msk = 0xf0
	// Position of YR1 field.
	RTC_RYRCNT_YR1_Pos = 0x0
	// Bit mask of YR1 field.
	RTC_RYRCNT_YR1_Msk = 0xf

	// RSECAR: Second Alarm Register
	// Position of ENB field.
	RTC_RSECAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RSECAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RSECAR_ENB = 0x80
	// The register value is not compared with the RSECCNT counter value.
	RTC_RSECAR_ENB_0 = 0x0
	// The register value is compared with the RSECCNT counter value.
	RTC_RSECAR_ENB_1 = 0x1
	// Position of SEC10 field.
	RTC_RSECAR_SEC10_Pos = 0x4
	// Bit mask of SEC10 field.
	RTC_RSECAR_SEC10_Msk = 0x70
	// Position of SEC1 field.
	RTC_RSECAR_SEC1_Pos = 0x0
	// Bit mask of SEC1 field.
	RTC_RSECAR_SEC1_Msk = 0xf

	// BCNT0AR: Binary Counter 0 Alarm Register
	// Position of BCNT0AR field.
	RTC_BCNT0AR_BCNT0AR_Pos = 0x0
	// Bit mask of BCNT0AR field.
	RTC_BCNT0AR_BCNT0AR_Msk = 0xff

	// RMINAR: Minute Alarm Register
	// Position of ENB field.
	RTC_RMINAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RMINAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RMINAR_ENB = 0x80
	// The register value is not compared with the RMINCNT counter value.
	RTC_RMINAR_ENB_0 = 0x0
	// The register value is compared with the RMINCNT counter value.
	RTC_RMINAR_ENB_1 = 0x1
	// Position of MIN10 field.
	RTC_RMINAR_MIN10_Pos = 0x4
	// Bit mask of MIN10 field.
	RTC_RMINAR_MIN10_Msk = 0x70
	// Position of MIN1 field.
	RTC_RMINAR_MIN1_Pos = 0x0
	// Bit mask of MIN1 field.
	RTC_RMINAR_MIN1_Msk = 0xf

	// BCNT1AR: Binary Counter 1 Alarm Register
	// Position of BCNT1AR field.
	RTC_BCNT1AR_BCNT1AR_Pos = 0x0
	// Bit mask of BCNT1AR field.
	RTC_BCNT1AR_BCNT1AR_Msk = 0xff

	// RHRAR: Hour Alarm Register
	// Position of ENB field.
	RTC_RHRAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RHRAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RHRAR_ENB = 0x80
	// The register value is not compared with the RHRCNT counter value.
	RTC_RHRAR_ENB_0 = 0x0
	// The register value is compared with the RHRCNT counter value.
	RTC_RHRAR_ENB_1 = 0x1
	// Position of PM field.
	RTC_RHRAR_PM_Pos = 0x6
	// Bit mask of PM field.
	RTC_RHRAR_PM_Msk = 0x40
	// Bit PM.
	RTC_RHRAR_PM = 0x40
	// a.m.
	RTC_RHRAR_PM_0 = 0x0
	// p.m.
	RTC_RHRAR_PM_1 = 0x1
	// Position of HR10 field.
	RTC_RHRAR_HR10_Pos = 0x4
	// Bit mask of HR10 field.
	RTC_RHRAR_HR10_Msk = 0x30
	// Position of HR1 field.
	RTC_RHRAR_HR1_Pos = 0x0
	// Bit mask of HR1 field.
	RTC_RHRAR_HR1_Msk = 0xf

	// BCNT2AR: Binary Counter 2 Alarm Register
	// Position of BCNT2AR field.
	RTC_BCNT2AR_BCNT2AR_Pos = 0x0
	// Bit mask of BCNT2AR field.
	RTC_BCNT2AR_BCNT2AR_Msk = 0xff

	// RWKAR: Day-of-Week Alarm Register
	// Position of ENB field.
	RTC_RWKAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RWKAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RWKAR_ENB = 0x80
	// The register value is not compared with the RWKCNT counter value.
	RTC_RWKAR_ENB_0 = 0x0
	// The register value is compared with the RWKCNT counter value.
	RTC_RWKAR_ENB_1 = 0x1
	// Position of Reserved field.
	RTC_RWKAR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	RTC_RWKAR_Reserved_Msk = 0x78
	// Position of DAYW field.
	RTC_RWKAR_DAYW_Pos = 0x0
	// Bit mask of DAYW field.
	RTC_RWKAR_DAYW_Msk = 0x7
	// Sunday
	RTC_RWKAR_DAYW_000 = 0x0
	// Monday
	RTC_RWKAR_DAYW_001 = 0x1
	// Tuesday
	RTC_RWKAR_DAYW_010 = 0x2
	// Wednesday
	RTC_RWKAR_DAYW_011 = 0x3
	// Thursday
	RTC_RWKAR_DAYW_100 = 0x4
	// Friday
	RTC_RWKAR_DAYW_101 = 0x5
	// Saturday
	RTC_RWKAR_DAYW_110 = 0x6
	// Setting Prohibited
	RTC_RWKAR_DAYW_111 = 0x7

	// BCNT3AR: Binary Counter 3 Alarm Register
	// Position of BCNT3AR field.
	RTC_BCNT3AR_BCNT3AR_Pos = 0x0
	// Bit mask of BCNT3AR field.
	RTC_BCNT3AR_BCNT3AR_Msk = 0xff

	// RDAYAR: Date Alarm Register
	// Position of ENB field.
	RTC_RDAYAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RDAYAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RDAYAR_ENB = 0x80
	// The register value is not compared with the RDAYCNT counter value.
	RTC_RDAYAR_ENB_0 = 0x0
	// The register value is compared with the RDAYCNT counter value.
	RTC_RDAYAR_ENB_1 = 0x1
	// Position of Reserved field.
	RTC_RDAYAR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	RTC_RDAYAR_Reserved_Msk = 0x40
	// Bit Reserved.
	RTC_RDAYAR_Reserved = 0x40
	// Position of DATE10 field.
	RTC_RDAYAR_DATE10_Pos = 0x4
	// Bit mask of DATE10 field.
	RTC_RDAYAR_DATE10_Msk = 0x30
	// Position of DATE1 field.
	RTC_RDAYAR_DATE1_Pos = 0x0
	// Bit mask of DATE1 field.
	RTC_RDAYAR_DATE1_Msk = 0xf

	// BCNT0AER: Binary Counter 0 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT0AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT0AER_ENB_Msk = 0xff

	// RMONAR: Month Alarm Register
	// Position of ENB field.
	RTC_RMONAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RMONAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RMONAR_ENB = 0x80
	// The register value is not compared with the RMONCNT counter value.
	RTC_RMONAR_ENB_0 = 0x0
	// The register value is compared with the RMONCNT counter value.
	RTC_RMONAR_ENB_1 = 0x1
	// Position of Reserved field.
	RTC_RMONAR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	RTC_RMONAR_Reserved_Msk = 0x60
	// Position of MON10 field.
	RTC_RMONAR_MON10_Pos = 0x4
	// Bit mask of MON10 field.
	RTC_RMONAR_MON10_Msk = 0x10
	// Bit MON10.
	RTC_RMONAR_MON10 = 0x10
	// Position of MON1 field.
	RTC_RMONAR_MON1_Pos = 0x0
	// Bit mask of MON1 field.
	RTC_RMONAR_MON1_Msk = 0xf

	// BCNT1AER: Binary Counter 1 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT1AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT1AER_ENB_Msk = 0xff

	// RYRAR: Year Alarm Register
	// Position of Reserved field.
	RTC_RYRAR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	RTC_RYRAR_Reserved_Msk = 0xff00
	// Position of YR10 field.
	RTC_RYRAR_YR10_Pos = 0x4
	// Bit mask of YR10 field.
	RTC_RYRAR_YR10_Msk = 0xf0
	// Position of YR1 field.
	RTC_RYRAR_YR1_Pos = 0x0
	// Bit mask of YR1 field.
	RTC_RYRAR_YR1_Msk = 0xf

	// BCNT2AER: Binary Counter 2 Alarm Enable Register
	// Position of Reserved field.
	RTC_BCNT2AER_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	RTC_BCNT2AER_Reserved_Msk = 0xff00
	// Position of ENB field.
	RTC_BCNT2AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT2AER_ENB_Msk = 0xff

	// RYRAREN: Year Alarm Enable Register
	// Position of ENB field.
	RTC_RYRAREN_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RYRAREN_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RYRAREN_ENB = 0x80
	// The register value is not compared with the RYRCNT counter value.
	RTC_RYRAREN_ENB_0 = 0x0
	// The register value is compared with the RYRCNT counter value.
	RTC_RYRAREN_ENB_1 = 0x1
	// Position of Reserved field.
	RTC_RYRAREN_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	RTC_RYRAREN_Reserved_Msk = 0x7f

	// BCNT3AER: Binary Counter 3 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT3AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT3AER_ENB_Msk = 0xff

	// RCR1: RTC Control Register 1
	// Position of PES field.
	RTC_RCR1_PES_Pos = 0x4
	// Bit mask of PES field.
	RTC_RCR1_PES_Msk = 0xf0
	// A periodic interrupt is generated every 1/256 second((RCR4.RCKSEL = 0)./A periodic interrupt is generated every 1/128 second((RCR4.RCKSEL = 1).
	RTC_RCR1_PES_0110 = 0x6
	// A periodic interrupt is generated every 1/128 second.
	RTC_RCR1_PES_0111 = 0x7
	// A periodic interrupt is generated every 1/64 second.
	RTC_RCR1_PES_1000 = 0x8
	// A periodic interrupt is generated every 1/32 second.
	RTC_RCR1_PES_1001 = 0x9
	// A periodic interrupt is generated every 1/16 second.
	RTC_RCR1_PES_1010 = 0xa
	// A periodic interrupt is generated every 1/8 second.
	RTC_RCR1_PES_1011 = 0xb
	// A periodic interrupt is generated every 1/4 second.
	RTC_RCR1_PES_1100 = 0xc
	// A periodic interrupt is generated every 1/2 second.
	RTC_RCR1_PES_1101 = 0xd
	// A periodic interrupt is generated every 1 second.
	RTC_RCR1_PES_1110 = 0xe
	// A periodic interrupt is generated every 2 seconds.
	RTC_RCR1_PES_1111 = 0xf
	// Position of RTCOS field.
	RTC_RCR1_RTCOS_Pos = 0x3
	// Bit mask of RTCOS field.
	RTC_RCR1_RTCOS_Msk = 0x8
	// Bit RTCOS.
	RTC_RCR1_RTCOS = 0x8
	// RTCOUT outputs 1 Hz.
	RTC_RCR1_RTCOS_0 = 0x0
	// RTCOUT outputs 64 Hz.
	RTC_RCR1_RTCOS_1 = 0x1
	// Position of PIE field.
	RTC_RCR1_PIE_Pos = 0x2
	// Bit mask of PIE field.
	RTC_RCR1_PIE_Msk = 0x4
	// Bit PIE.
	RTC_RCR1_PIE = 0x4
	// A periodic interrupt request is disabled.
	RTC_RCR1_PIE_0 = 0x0
	// A periodic interrupt request is enabled.
	RTC_RCR1_PIE_1 = 0x1
	// Position of CIE field.
	RTC_RCR1_CIE_Pos = 0x1
	// Bit mask of CIE field.
	RTC_RCR1_CIE_Msk = 0x2
	// Bit CIE.
	RTC_RCR1_CIE = 0x2
	// A carry interrupt request is disabled.
	RTC_RCR1_CIE_0 = 0x0
	// A carry interrupt request is enabled.
	RTC_RCR1_CIE_1 = 0x1
	// Position of AIE field.
	RTC_RCR1_AIE_Pos = 0x0
	// Bit mask of AIE field.
	RTC_RCR1_AIE_Msk = 0x1
	// Bit AIE.
	RTC_RCR1_AIE = 0x1
	// An alarm interrupt request is disabled.
	RTC_RCR1_AIE_0 = 0x0
	// An alarm interrupt request is enabled.
	RTC_RCR1_AIE_1 = 0x1

	// RCR2: RTC Control Register 2
	// Position of CNTMD field.
	RTC_RCR2_CNTMD_Pos = 0x7
	// Bit mask of CNTMD field.
	RTC_RCR2_CNTMD_Msk = 0x80
	// Bit CNTMD.
	RTC_RCR2_CNTMD = 0x80
	// The calendar count mode.
	RTC_RCR2_CNTMD_0 = 0x0
	// The binary count mode.
	RTC_RCR2_CNTMD_1 = 0x1
	// Position of HR24 field.
	RTC_RCR2_HR24_Pos = 0x6
	// Bit mask of HR24 field.
	RTC_RCR2_HR24_Msk = 0x40
	// Bit HR24.
	RTC_RCR2_HR24 = 0x40
	// The RTC operates in 12-hour mode.
	RTC_RCR2_HR24_0 = 0x0
	// The RTC operates in 24-hour mode.
	RTC_RCR2_HR24_1 = 0x1
	// Position of AADJP field.
	RTC_RCR2_AADJP_Pos = 0x5
	// Bit mask of AADJP field.
	RTC_RCR2_AADJP_Msk = 0x20
	// Bit AADJP.
	RTC_RCR2_AADJP = 0x20
	// The RADJ.ADJ[5:0] setting value is adjusted from the count value of the prescaler every minute.
	RTC_RCR2_AADJP_0 = 0x0
	// The RADJ.ADJ[5:0] setting value is adjusted from the count value of the prescaler every 10 seconds.
	RTC_RCR2_AADJP_1 = 0x1
	// Position of AADJE field.
	RTC_RCR2_AADJE_Pos = 0x4
	// Bit mask of AADJE field.
	RTC_RCR2_AADJE_Msk = 0x10
	// Bit AADJE.
	RTC_RCR2_AADJE = 0x10
	// Automatic adjustment is disabled.
	RTC_RCR2_AADJE_0 = 0x0
	// Automatic adjustment is enabled.
	RTC_RCR2_AADJE_1 = 0x1
	// Position of RTCOE field.
	RTC_RCR2_RTCOE_Pos = 0x3
	// Bit mask of RTCOE field.
	RTC_RCR2_RTCOE_Msk = 0x8
	// Bit RTCOE.
	RTC_RCR2_RTCOE = 0x8
	// RTCOUT output disabled.
	RTC_RCR2_RTCOE_0 = 0x0
	// RTCOUT output enabled.
	RTC_RCR2_RTCOE_1 = 0x1
	// Position of ADJ30 field.
	RTC_RCR2_ADJ30_Pos = 0x2
	// Bit mask of ADJ30 field.
	RTC_RCR2_ADJ30_Msk = 0x4
	// Bit ADJ30.
	RTC_RCR2_ADJ30 = 0x4
	// Writing is invalid.(write) / In normal time operation, or 30-second adjustment has completed.(read)
	RTC_RCR2_ADJ30_0 = 0x0
	// 30-second adjustment is executed.(write) / During 30-second adjustment.(read)
	RTC_RCR2_ADJ30_1 = 0x1
	// Position of RESET field.
	RTC_RCR2_RESET_Pos = 0x1
	// Bit mask of RESET field.
	RTC_RCR2_RESET_Msk = 0x2
	// Bit RESET.
	RTC_RCR2_RESET = 0x2
	// Writing is invalid.(write) / In normal time operation, or an RTC software reset has completed.(read)
	RTC_RCR2_RESET_0 = 0x0
	// The prescaler and the target registers for RTC software reset *1 are initialized.(write) / During an RTC software reset.(read)
	RTC_RCR2_RESET_1 = 0x1
	// Position of START field.
	RTC_RCR2_START_Pos = 0x0
	// Bit mask of START field.
	RTC_RCR2_START_Msk = 0x1
	// Bit START.
	RTC_RCR2_START = 0x1
	// Prescaler and time counter are stopped.
	RTC_RCR2_START_0 = 0x0
	// Prescaler and time counter operate normally.
	RTC_RCR2_START_1 = 0x1

	// RCR4: RTC Control Register 4
	// Position of Reserved field.
	RTC_RCR4_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	RTC_RCR4_Reserved_Msk = 0xfe
	// Position of RCKSEL field.
	RTC_RCR4_RCKSEL_Pos = 0x0
	// Bit mask of RCKSEL field.
	RTC_RCR4_RCKSEL_Msk = 0x1
	// Bit RCKSEL.
	RTC_RCR4_RCKSEL = 0x1
	// Sub-clock oscillator is selected.
	RTC_RCR4_RCKSEL_0 = 0x0
	// LOCO clock oscillator is selected.
	RTC_RCR4_RCKSEL_1 = 0x1

	// RFRH: Frequency Register H
	// Position of Reserved field.
	RTC_RFRH_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	RTC_RFRH_Reserved_Msk = 0xfffe
	// Position of RFC16 field.
	RTC_RFRH_RFC16_Pos = 0x0
	// Bit mask of RFC16 field.
	RTC_RFRH_RFC16_Msk = 0x1
	// Bit RFC16.
	RTC_RFRH_RFC16 = 0x1

	// RFRL: Frequency Register L
	// Position of RFC field.
	RTC_RFRL_RFC_Pos = 0x0
	// Bit mask of RFC field.
	RTC_RFRL_RFC_Msk = 0xffff

	// RADJ: Time Error Adjustment Register
	// Position of PMADJ field.
	RTC_RADJ_PMADJ_Pos = 0x6
	// Bit mask of PMADJ field.
	RTC_RADJ_PMADJ_Msk = 0xc0
	// Adjustment is not performed.
	RTC_RADJ_PMADJ_00 = 0x0
	// Adjustment is performed by the addition to the prescaler.
	RTC_RADJ_PMADJ_01 = 0x1
	// Adjustment is performed by the subtraction from the prescaler.
	RTC_RADJ_PMADJ_10 = 0x2
	// Setting prohibited
	RTC_RADJ_PMADJ_11 = 0x3
	// Position of ADJ field.
	RTC_RADJ_ADJ_Pos = 0x0
	// Bit mask of ADJ field.
	RTC_RADJ_ADJ_Msk = 0x3f

	// RTCCR0: Time Capture Control Register %s
	// Position of Reserved field.
	RTC_RTCCR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	RTC_RTCCR_Reserved_Msk = 0x80
	// Bit Reserved.
	RTC_RTCCR_Reserved = 0x80
	// Position of Reserved field.
	RTC_RTCCR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	RTC_RTCCR_Reserved_Msk = 0x40
	// Bit Reserved.
	RTC_RTCCR_Reserved = 0x40
	// Position of TCNF field.
	RTC_RTCCR_TCNF_Pos = 0x4
	// Bit mask of TCNF field.
	RTC_RTCCR_TCNF_Msk = 0x30
	// The noise filter is off.
	RTC_RTCCR_TCNF_00 = 0x0
	// Setting prohibited
	RTC_RTCCR_TCNF_01 = 0x1
	// The noise filter is on (count source).
	RTC_RTCCR_TCNF_10 = 0x2
	// The noise filter is on (count source by divided by 32).
	RTC_RTCCR_TCNF_11 = 0x3
	// Position of Reserved field.
	RTC_RTCCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	RTC_RTCCR_Reserved_Msk = 0x8
	// Bit Reserved.
	RTC_RTCCR_Reserved = 0x8
	// Position of TCST field.
	RTC_RTCCR_TCST_Pos = 0x2
	// Bit mask of TCST field.
	RTC_RTCCR_TCST_Msk = 0x4
	// Bit TCST.
	RTC_RTCCR_TCST = 0x4
	// No event is detected.
	RTC_RTCCR_TCST_0 = 0x0
	// An event is detected.
	RTC_RTCCR_TCST_1 = 0x1
	// Position of TCCT field.
	RTC_RTCCR_TCCT_Pos = 0x0
	// Bit mask of TCCT field.
	RTC_RTCCR_TCCT_Msk = 0x3
	// No event is detected.
	RTC_RTCCR_TCCT_00 = 0x0
	// Rising edge is detected.
	RTC_RTCCR_TCCT_01 = 0x1
	// Falling edge is detected.
	RTC_RTCCR_TCCT_10 = 0x2
	// Both edges are detected.
	RTC_RTCCR_TCCT_11 = 0x3

	// RSECCP0: Second Capture Register %s
	// Position of Reserved field.
	RTC_RSECCP_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	RTC_RSECCP_Reserved_Msk = 0x80
	// Bit Reserved.
	RTC_RSECCP_Reserved = 0x80
	// Position of SEC10 field.
	RTC_RSECCP_SEC10_Pos = 0x4
	// Bit mask of SEC10 field.
	RTC_RSECCP_SEC10_Msk = 0x70
	// Position of SEC1 field.
	RTC_RSECCP_SEC1_Pos = 0x0
	// Bit mask of SEC1 field.
	RTC_RSECCP_SEC1_Msk = 0xf

	// BCNT0CP0: BCNT0 Capture Register %s
	// Position of BCNT0CP field.
	RTC_BCNT0CP_BCNT0CP_Pos = 0x0
	// Bit mask of BCNT0CP field.
	RTC_BCNT0CP_BCNT0CP_Msk = 0xff

	// RMINCP0: Minute Capture Register %s
	// Position of Reserved field.
	RTC_RMINCP_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	RTC_RMINCP_Reserved_Msk = 0x80
	// Bit Reserved.
	RTC_RMINCP_Reserved = 0x80
	// Position of MIN10 field.
	RTC_RMINCP_MIN10_Pos = 0x4
	// Bit mask of MIN10 field.
	RTC_RMINCP_MIN10_Msk = 0x70
	// Position of MIN1 field.
	RTC_RMINCP_MIN1_Pos = 0x0
	// Bit mask of MIN1 field.
	RTC_RMINCP_MIN1_Msk = 0xf

	// BCNT1CP0: BCNT1 Capture Register %s
	// Position of BCNT1CP field.
	RTC_BCNT1CP_BCNT1CP_Pos = 0x0
	// Bit mask of BCNT1CP field.
	RTC_BCNT1CP_BCNT1CP_Msk = 0xff

	// RHRCP0: Hour Capture Register %s
	// Position of Reserved field.
	RTC_RHRCP_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	RTC_RHRCP_Reserved_Msk = 0x80
	// Bit Reserved.
	RTC_RHRCP_Reserved = 0x80
	// Position of PM field.
	RTC_RHRCP_PM_Pos = 0x6
	// Bit mask of PM field.
	RTC_RHRCP_PM_Msk = 0x40
	// Bit PM.
	RTC_RHRCP_PM = 0x40
	// a.m.
	RTC_RHRCP_PM_0 = 0x0
	// p.m.
	RTC_RHRCP_PM_1 = 0x1
	// Position of HR10 field.
	RTC_RHRCP_HR10_Pos = 0x4
	// Bit mask of HR10 field.
	RTC_RHRCP_HR10_Msk = 0x30
	// Position of HR1 field.
	RTC_RHRCP_HR1_Pos = 0x0
	// Bit mask of HR1 field.
	RTC_RHRCP_HR1_Msk = 0xf

	// BCNT2CP0: BCNT2 Capture Register %s
	// Position of BCNT2CP field.
	RTC_BCNT2CP_BCNT2CP_Pos = 0x0
	// Bit mask of BCNT2CP field.
	RTC_BCNT2CP_BCNT2CP_Msk = 0xff

	// RDAYCP0: Date Capture Register %s
	// Position of Reserved field.
	RTC_RDAYCP_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	RTC_RDAYCP_Reserved_Msk = 0xc0
	// Position of DATE10 field.
	RTC_RDAYCP_DATE10_Pos = 0x4
	// Bit mask of DATE10 field.
	RTC_RDAYCP_DATE10_Msk = 0x30
	// Position of DATE1 field.
	RTC_RDAYCP_DATE1_Pos = 0x0
	// Bit mask of DATE1 field.
	RTC_RDAYCP_DATE1_Msk = 0xf

	// BCNT3CP0: BCNT3 Capture Register %s
	// Position of BCNT3CP field.
	RTC_BCNT3CP_BCNT3CP_Pos = 0x0
	// Bit mask of BCNT3CP field.
	RTC_BCNT3CP_BCNT3CP_Msk = 0xff

	// RMONCP0: Month Capture Register %s
	// Position of MON10 field.
	RTC_RMONCP_MON10_Pos = 0x4
	// Bit mask of MON10 field.
	RTC_RMONCP_MON10_Msk = 0x10
	// Bit MON10.
	RTC_RMONCP_MON10 = 0x10
	// Position of MON1 field.
	RTC_RMONCP_MON1_Pos = 0x0
	// Bit mask of MON1 field.
	RTC_RMONCP_MON1_Msk = 0xf
)

// Constants for SYSTEM: System Control
const (
	// SBYCR: Standby Control Register
	// Position of SSBY field.
	SYSTEM_SBYCR_SSBY_Pos = 0xf
	// Bit mask of SSBY field.
	SYSTEM_SBYCR_SSBY_Msk = 0x8000
	// Bit SSBY.
	SYSTEM_SBYCR_SSBY = 0x8000
	// Sleep mode
	SYSTEM_SBYCR_SSBY_0 = 0x0
	// Software Standby mode
	SYSTEM_SBYCR_SSBY_1 = 0x1
	// Position of OPE field.
	SYSTEM_SBYCR_OPE_Pos = 0xe
	// Bit mask of OPE field.
	SYSTEM_SBYCR_OPE_Msk = 0x4000
	// Bit OPE.
	SYSTEM_SBYCR_OPE = 0x4000
	// In software standby mode Address output pins, Data output pins, and other bus control signal output pins are set to the high-impedance state. In snooze mode, the status of the address bus and bus control signals are same as before entering software standby mode.
	SYSTEM_SBYCR_OPE_0 = 0x0
	// In software standby mode Address output pins, Data output pins, and other bus control signal output pins retain the output state.
	SYSTEM_SBYCR_OPE_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SBYCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SYSTEM_SBYCR_Reserved_Msk = 0x3fff

	// MSTPCRA: Module Stop Control Register A
	// Position of Reserved field.
	SYSTEM_MSTPCRA_Reserved_Pos = 0x17
	// Bit mask of Reserved field.
	SYSTEM_MSTPCRA_Reserved_Msk = 0xff800000
	// Position of MSTPA22 field.
	SYSTEM_MSTPCRA_MSTPA22_Pos = 0x16
	// Bit mask of MSTPA22 field.
	SYSTEM_MSTPCRA_MSTPA22_Msk = 0x400000
	// Bit MSTPA22.
	SYSTEM_MSTPCRA_MSTPA22 = 0x400000
	// Cancel the module-stop state
	SYSTEM_MSTPCRA_MSTPA22_0 = 0x0
	// Enter the module-stop state
	SYSTEM_MSTPCRA_MSTPA22_1 = 0x1
	// Position of Reserved field.
	SYSTEM_MSTPCRA_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	SYSTEM_MSTPCRA_Reserved_Msk = 0x3fff80
	// Position of MSTPA6 field.
	SYSTEM_MSTPCRA_MSTPA6_Pos = 0x6
	// Bit mask of MSTPA6 field.
	SYSTEM_MSTPCRA_MSTPA6_Msk = 0x40
	// Bit MSTPA6.
	SYSTEM_MSTPCRA_MSTPA6 = 0x40
	// Cancel the module-stop state
	SYSTEM_MSTPCRA_MSTPA6_0 = 0x0
	// Enter the module-stop state
	SYSTEM_MSTPCRA_MSTPA6_1 = 0x1
	// Position of Reserved field.
	SYSTEM_MSTPCRA_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_MSTPCRA_Reserved_Msk = 0x3e
	// Position of MSTPA0 field.
	SYSTEM_MSTPCRA_MSTPA0_Pos = 0x0
	// Bit mask of MSTPA0 field.
	SYSTEM_MSTPCRA_MSTPA0_Msk = 0x1
	// Bit MSTPA0.
	SYSTEM_MSTPCRA_MSTPA0 = 0x1
	// Cancel the module-stop state
	SYSTEM_MSTPCRA_MSTPA0_0 = 0x0
	// Enter the module-stop state
	SYSTEM_MSTPCRA_MSTPA0_1 = 0x1

	// SCKDIVCR: System Clock Division Control Register
	// Position of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Pos = 0x1f
	// Bit mask of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Msk = 0x80000000
	// Bit Reserved.
	SYSTEM_SCKDIVCR_Reserved = 0x80000000
	// Position of FCK field.
	SYSTEM_SCKDIVCR_FCK_Pos = 0x1c
	// Bit mask of FCK field.
	SYSTEM_SCKDIVCR_FCK_Msk = 0x70000000
	// /1
	SYSTEM_SCKDIVCR_FCK_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_FCK_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_FCK_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_FCK_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_FCK_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_FCK_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_FCK_110 = 0x6
	// Position of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Pos = 0x1b
	// Bit mask of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Msk = 0x8000000
	// Bit Reserved.
	SYSTEM_SCKDIVCR_Reserved = 0x8000000
	// Position of ICK field.
	SYSTEM_SCKDIVCR_ICK_Pos = 0x18
	// Bit mask of ICK field.
	SYSTEM_SCKDIVCR_ICK_Msk = 0x7000000
	// /1
	SYSTEM_SCKDIVCR_ICK_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_ICK_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_ICK_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_ICK_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_ICK_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_ICK_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_ICK_110 = 0x6
	// Position of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Pos = 0x13
	// Bit mask of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Msk = 0xf80000
	// Position of BCK field.
	SYSTEM_SCKDIVCR_BCK_Pos = 0x10
	// Bit mask of BCK field.
	SYSTEM_SCKDIVCR_BCK_Msk = 0x70000
	// /1
	SYSTEM_SCKDIVCR_BCK_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_BCK_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_BCK_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_BCK_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_BCK_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_BCK_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_BCK_110 = 0x6
	// Position of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Pos = 0xf
	// Bit mask of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Msk = 0x8000
	// Bit Reserved.
	SYSTEM_SCKDIVCR_Reserved = 0x8000
	// Position of PCKA field.
	SYSTEM_SCKDIVCR_PCKA_Pos = 0xc
	// Bit mask of PCKA field.
	SYSTEM_SCKDIVCR_PCKA_Msk = 0x7000
	// /1
	SYSTEM_SCKDIVCR_PCKA_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_PCKA_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_PCKA_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_PCKA_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_PCKA_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_PCKA_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_PCKA_110 = 0x6
	// Position of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Msk = 0x800
	// Bit Reserved.
	SYSTEM_SCKDIVCR_Reserved = 0x800
	// Position of PCKB field.
	SYSTEM_SCKDIVCR_PCKB_Pos = 0x8
	// Bit mask of PCKB field.
	SYSTEM_SCKDIVCR_PCKB_Msk = 0x700
	// /1
	SYSTEM_SCKDIVCR_PCKB_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_PCKB_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_PCKB_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_PCKB_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_PCKB_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_PCKB_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_PCKB_110 = 0x6
	// Position of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Msk = 0x80
	// Bit Reserved.
	SYSTEM_SCKDIVCR_Reserved = 0x80
	// Position of PCKC field.
	SYSTEM_SCKDIVCR_PCKC_Pos = 0x4
	// Bit mask of PCKC field.
	SYSTEM_SCKDIVCR_PCKC_Msk = 0x70
	// /1
	SYSTEM_SCKDIVCR_PCKC_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_PCKC_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_PCKC_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_PCKC_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_PCKC_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_PCKC_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_PCKC_110 = 0x6
	// Position of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Msk = 0x8
	// Bit Reserved.
	SYSTEM_SCKDIVCR_Reserved = 0x8
	// Position of PCKD field.
	SYSTEM_SCKDIVCR_PCKD_Pos = 0x0
	// Bit mask of PCKD field.
	SYSTEM_SCKDIVCR_PCKD_Msk = 0x7
	// /1
	SYSTEM_SCKDIVCR_PCKD_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_PCKD_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_PCKD_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_PCKD_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_PCKD_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_PCKD_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_PCKD_110 = 0x6

	// SCKSCR: System Clock Source Control Register
	// Position of Reserved field.
	SYSTEM_SCKSCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_SCKSCR_Reserved_Msk = 0xf8
	// Position of CKSEL field.
	SYSTEM_SCKSCR_CKSEL_Pos = 0x0
	// Bit mask of CKSEL field.
	SYSTEM_SCKSCR_CKSEL_Msk = 0x7
	// HOCO
	SYSTEM_SCKSCR_CKSEL_000 = 0x0
	// MOCO
	SYSTEM_SCKSCR_CKSEL_001 = 0x1
	// LOCO
	SYSTEM_SCKSCR_CKSEL_010 = 0x2
	// Main clock oscillator
	SYSTEM_SCKSCR_CKSEL_011 = 0x3
	// Sub-clock oscillator
	SYSTEM_SCKSCR_CKSEL_100 = 0x4
	// PLL
	SYSTEM_SCKSCR_CKSEL_101 = 0x5

	// PLLCR: PLL Control Register
	// Position of Reserved field.
	SYSTEM_PLLCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_PLLCR_Reserved_Msk = 0xfe
	// Position of PLLSTP field.
	SYSTEM_PLLCR_PLLSTP_Pos = 0x0
	// Bit mask of PLLSTP field.
	SYSTEM_PLLCR_PLLSTP_Msk = 0x1
	// Bit PLLSTP.
	SYSTEM_PLLCR_PLLSTP = 0x1
	// PLL is operating.
	SYSTEM_PLLCR_PLLSTP_0 = 0x0
	// PLL is stopped.
	SYSTEM_PLLCR_PLLSTP_1 = 0x1

	// PLLCCR2: PLL Clock Control Register2
	// Position of PLODIV field.
	SYSTEM_PLLCCR2_PLODIV_Pos = 0x6
	// Bit mask of PLODIV field.
	SYSTEM_PLLCCR2_PLODIV_Msk = 0xc0
	// /1.
	SYSTEM_PLLCCR2_PLODIV_00 = 0x0
	// /2.
	SYSTEM_PLLCCR2_PLODIV_01 = 0x1
	// /4.
	SYSTEM_PLLCCR2_PLODIV_10 = 0x2
	// Setting prohibited.
	SYSTEM_PLLCCR2_PLODIV_11 = 0x3
	// Position of Reserved field.
	SYSTEM_PLLCCR2_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_PLLCCR2_Reserved_Msk = 0x20
	// Bit Reserved.
	SYSTEM_PLLCCR2_Reserved = 0x20
	// Position of PLLMUL field.
	SYSTEM_PLLCCR2_PLLMUL_Pos = 0x0
	// Bit mask of PLLMUL field.
	SYSTEM_PLLCCR2_PLLMUL_Msk = 0x1f
	// Settings prohibited.
	SYSTEM_PLLCCR2_PLLMUL_1111 = 0xf

	// BCKCR: External Bus Clock Control Register
	// Position of Reserved field.
	SYSTEM_BCKCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_BCKCR_Reserved_Msk = 0xfe
	// Position of BCLKDIV field.
	SYSTEM_BCKCR_BCLKDIV_Pos = 0x0
	// Bit mask of BCLKDIV field.
	SYSTEM_BCKCR_BCLKDIV_Msk = 0x1
	// Bit BCLKDIV.
	SYSTEM_BCKCR_BCLKDIV = 0x1
	// BCLK
	SYSTEM_BCKCR_BCLKDIV_0 = 0x0
	// BCLK/2
	SYSTEM_BCKCR_BCLKDIV_1 = 0x1

	// MEMWAIT: Memory Wait Cycle Control Register
	// Position of Reserved field.
	SYSTEM_MEMWAIT_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_MEMWAIT_Reserved_Msk = 0xfe
	// Position of MEMWAIT field.
	SYSTEM_MEMWAIT_MEMWAIT_Pos = 0x0
	// Bit mask of MEMWAIT field.
	SYSTEM_MEMWAIT_MEMWAIT_Msk = 0x1
	// Bit MEMWAIT.
	SYSTEM_MEMWAIT_MEMWAIT = 0x1
	// no wait
	SYSTEM_MEMWAIT_MEMWAIT_0 = 0x0
	// wait
	SYSTEM_MEMWAIT_MEMWAIT_1 = 0x1

	// MOSCCR: Main Clock Oscillator Control Register
	// Position of Reserved field.
	SYSTEM_MOSCCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_MOSCCR_Reserved_Msk = 0xfe
	// Position of MOSTP field.
	SYSTEM_MOSCCR_MOSTP_Pos = 0x0
	// Bit mask of MOSTP field.
	SYSTEM_MOSCCR_MOSTP_Msk = 0x1
	// Bit MOSTP.
	SYSTEM_MOSCCR_MOSTP = 0x1
	// Main clock oscillator is operating.
	SYSTEM_MOSCCR_MOSTP_0 = 0x0
	// Main clock oscillator is stopped.
	SYSTEM_MOSCCR_MOSTP_1 = 0x1

	// HOCOCR: High-Speed On-Chip Oscillator Control Register
	// Position of Reserved field.
	SYSTEM_HOCOCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_HOCOCR_Reserved_Msk = 0xfe
	// Position of HCSTP field.
	SYSTEM_HOCOCR_HCSTP_Pos = 0x0
	// Bit mask of HCSTP field.
	SYSTEM_HOCOCR_HCSTP_Msk = 0x1
	// Bit HCSTP.
	SYSTEM_HOCOCR_HCSTP = 0x1
	// HOCO is operating.
	SYSTEM_HOCOCR_HCSTP_0 = 0x0
	// HOCO is stopped.
	SYSTEM_HOCOCR_HCSTP_1 = 0x1

	// MOCOCR: Middle-Speed On-Chip Oscillator Control Register
	// Position of Reserved field.
	SYSTEM_MOCOCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_MOCOCR_Reserved_Msk = 0xfe
	// Position of MCSTP field.
	SYSTEM_MOCOCR_MCSTP_Pos = 0x0
	// Bit mask of MCSTP field.
	SYSTEM_MOCOCR_MCSTP_Msk = 0x1
	// Bit MCSTP.
	SYSTEM_MOCOCR_MCSTP = 0x1
	// MOCO is operating.
	SYSTEM_MOCOCR_MCSTP_0 = 0x0
	// MOCO is stopped.
	SYSTEM_MOCOCR_MCSTP_1 = 0x1

	// OSCSF: Oscillation Stabilization Flag Register
	// Position of Reserved field.
	SYSTEM_OSCSF_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SYSTEM_OSCSF_Reserved_Msk = 0xc0
	// Position of PLLSF field.
	SYSTEM_OSCSF_PLLSF_Pos = 0x5
	// Bit mask of PLLSF field.
	SYSTEM_OSCSF_PLLSF_Msk = 0x20
	// Bit PLLSF.
	SYSTEM_OSCSF_PLLSF = 0x20
	// The PLL clock is stopped or oscillation of the PLL clock has not yet become stable.
	SYSTEM_OSCSF_PLLSF_0 = 0x0
	// Oscillation of the PLL clock is stable so the clock is available for use as the system clock.
	SYSTEM_OSCSF_PLLSF_1 = 0x1
	// Position of Reserved field.
	SYSTEM_OSCSF_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SYSTEM_OSCSF_Reserved_Msk = 0x10
	// Bit Reserved.
	SYSTEM_OSCSF_Reserved = 0x10
	// Position of MOSCSF field.
	SYSTEM_OSCSF_MOSCSF_Pos = 0x3
	// Bit mask of MOSCSF field.
	SYSTEM_OSCSF_MOSCSF_Msk = 0x8
	// Bit MOSCSF.
	SYSTEM_OSCSF_MOSCSF = 0x8
	// MOSTP = 1 (stopping the main clock oscillator) or oscillation of the main clock has not yet become stable.
	SYSTEM_OSCSF_MOSCSF_0 = 0x0
	// Oscillation of the main clock is stable so the clock is available for use as the system clock.
	SYSTEM_OSCSF_MOSCSF_1 = 0x1
	// Position of Reserved field.
	SYSTEM_OSCSF_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_OSCSF_Reserved_Msk = 0x6
	// Position of HOCOSF field.
	SYSTEM_OSCSF_HOCOSF_Pos = 0x0
	// Bit mask of HOCOSF field.
	SYSTEM_OSCSF_HOCOSF_Msk = 0x1
	// Bit HOCOSF.
	SYSTEM_OSCSF_HOCOSF = 0x1
	// The HOCO clock is stopped or oscillation of the HOCO clock has not yet become stable.
	SYSTEM_OSCSF_HOCOSF_0 = 0x0
	// Oscillation of the HOCO clock is stable so the clock is available for use as the system clock.
	SYSTEM_OSCSF_HOCOSF_1 = 0x1

	// CKOCR: Clock Out Control Register
	// Position of CKOEN field.
	SYSTEM_CKOCR_CKOEN_Pos = 0x7
	// Bit mask of CKOEN field.
	SYSTEM_CKOCR_CKOEN_Msk = 0x80
	// Bit CKOEN.
	SYSTEM_CKOCR_CKOEN = 0x80
	// Clock Out disable
	SYSTEM_CKOCR_CKOEN_0 = 0x0
	// Clock Out enable
	SYSTEM_CKOCR_CKOEN_1 = 0x1
	// Position of CKODIV field.
	SYSTEM_CKOCR_CKODIV_Pos = 0x4
	// Bit mask of CKODIV field.
	SYSTEM_CKOCR_CKODIV_Msk = 0x70
	// /1
	SYSTEM_CKOCR_CKODIV_000 = 0x0
	// /2
	SYSTEM_CKOCR_CKODIV_001 = 0x1
	// /4
	SYSTEM_CKOCR_CKODIV_010 = 0x2
	// /8
	SYSTEM_CKOCR_CKODIV_011 = 0x3
	// /16
	SYSTEM_CKOCR_CKODIV_100 = 0x4
	// /32
	SYSTEM_CKOCR_CKODIV_101 = 0x5
	// /64
	SYSTEM_CKOCR_CKODIV_110 = 0x6
	// /128
	SYSTEM_CKOCR_CKODIV_111 = 0x7
	// Position of Reserved field.
	SYSTEM_CKOCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_CKOCR_Reserved_Msk = 0x8
	// Bit Reserved.
	SYSTEM_CKOCR_Reserved = 0x8
	// Position of CKOSEL field.
	SYSTEM_CKOCR_CKOSEL_Pos = 0x0
	// Bit mask of CKOSEL field.
	SYSTEM_CKOCR_CKOSEL_Msk = 0x7
	// HOCO
	SYSTEM_CKOCR_CKOSEL_000 = 0x0
	// MOCO
	SYSTEM_CKOCR_CKOSEL_001 = 0x1
	// LOCO
	SYSTEM_CKOCR_CKOSEL_010 = 0x2
	// MOSC
	SYSTEM_CKOCR_CKOSEL_011 = 0x3
	// SOSC
	SYSTEM_CKOCR_CKOSEL_100 = 0x4

	// TRCKCR: Trace Clock Control Register
	// Position of TRCKEN field.
	SYSTEM_TRCKCR_TRCKEN_Pos = 0x7
	// Bit mask of TRCKEN field.
	SYSTEM_TRCKCR_TRCKEN_Msk = 0x80
	// Bit TRCKEN.
	SYSTEM_TRCKCR_TRCKEN = 0x80
	// Operation disabled
	SYSTEM_TRCKCR_TRCKEN_0 = 0x0
	// Operation enabled.
	SYSTEM_TRCKCR_TRCKEN_1 = 0x1
	// Position of Reserved field.
	SYSTEM_TRCKCR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SYSTEM_TRCKCR_Reserved_Msk = 0x70
	// Position of TRCK field.
	SYSTEM_TRCKCR_TRCK_Pos = 0x0
	// Bit mask of TRCK field.
	SYSTEM_TRCKCR_TRCK_Msk = 0xf
	// /1
	SYSTEM_TRCKCR_TRCK_0000 = 0x0
	// /2(value after reset)
	SYSTEM_TRCKCR_TRCK_0001 = 0x1
	// /4
	SYSTEM_TRCKCR_TRCK_0010 = 0x2

	// OSTDCR: Oscillation Stop Detection Control Register
	// Position of OSTDE field.
	SYSTEM_OSTDCR_OSTDE_Pos = 0x7
	// Bit mask of OSTDE field.
	SYSTEM_OSTDCR_OSTDE_Msk = 0x80
	// Bit OSTDE.
	SYSTEM_OSTDCR_OSTDE = 0x80
	// Oscillation stop detection function is disabled.
	SYSTEM_OSTDCR_OSTDE_0 = 0x0
	// Oscillation stop detection function is enabled.
	SYSTEM_OSTDCR_OSTDE_1 = 0x1
	// Position of Reserved field.
	SYSTEM_OSTDCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_OSTDCR_Reserved_Msk = 0x7e
	// Position of OSTDIE field.
	SYSTEM_OSTDCR_OSTDIE_Pos = 0x0
	// Bit mask of OSTDIE field.
	SYSTEM_OSTDCR_OSTDIE_Msk = 0x1
	// Bit OSTDIE.
	SYSTEM_OSTDCR_OSTDIE = 0x1
	// The oscillation stop detection interrupt is disabled. Oscillation stop detection is not notified to the POEG.
	SYSTEM_OSTDCR_OSTDIE_0 = 0x0
	// The oscillation stop detection interrupt is enabled. Oscillation stop detection is notified to the POEG.
	SYSTEM_OSTDCR_OSTDIE_1 = 0x1

	// OSTDSR: Oscillation Stop Detection Status Register
	// Position of Reserved field.
	SYSTEM_OSTDSR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_OSTDSR_Reserved_Msk = 0xfe
	// Position of OSTDF field.
	SYSTEM_OSTDSR_OSTDF_Pos = 0x0
	// Bit mask of OSTDF field.
	SYSTEM_OSTDSR_OSTDF_Msk = 0x1
	// Bit OSTDF.
	SYSTEM_OSTDSR_OSTDF = 0x1
	// The main clock oscillation stop has not been detected.
	SYSTEM_OSTDSR_OSTDF_0 = 0x0
	// The main clock oscillation stop has been detected.
	SYSTEM_OSTDSR_OSTDF_1 = 0x1

	// SLCDSCKCR: Segment LCD Source Clock Control Register
	// Position of LCDSCKEN field.
	SYSTEM_SLCDSCKCR_LCDSCKEN_Pos = 0x7
	// Bit mask of LCDSCKEN field.
	SYSTEM_SLCDSCKCR_LCDSCKEN_Msk = 0x80
	// Bit LCDSCKEN.
	SYSTEM_SLCDSCKCR_LCDSCKEN = 0x80
	// LCD source clock out disabled
	SYSTEM_SLCDSCKCR_LCDSCKEN_0 = 0x0
	// LCD source clock out enabled.
	SYSTEM_SLCDSCKCR_LCDSCKEN_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SLCDSCKCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_SLCDSCKCR_Reserved_Msk = 0x78
	// Position of LCDSCKSEL field.
	SYSTEM_SLCDSCKCR_LCDSCKSEL_Pos = 0x0
	// Bit mask of LCDSCKSEL field.
	SYSTEM_SLCDSCKCR_LCDSCKSEL_Msk = 0x7
	// LOCO
	SYSTEM_SLCDSCKCR_LCDSCKSEL_000 = 0x0
	// SOSC
	SYSTEM_SLCDSCKCR_LCDSCKSEL_001 = 0x1
	// MOSC
	SYSTEM_SLCDSCKCR_LCDSCKSEL_010 = 0x2
	// HOCO
	SYSTEM_SLCDSCKCR_LCDSCKSEL_100 = 0x4

	// EBCKOCR: External Bus Clock Output Control Register
	// Position of Reserved field.
	SYSTEM_EBCKOCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_EBCKOCR_Reserved_Msk = 0xfe
	// Position of EBCKOEN field.
	SYSTEM_EBCKOCR_EBCKOEN_Pos = 0x0
	// Bit mask of EBCKOEN field.
	SYSTEM_EBCKOCR_EBCKOEN_Msk = 0x1
	// Bit EBCKOEN.
	SYSTEM_EBCKOCR_EBCKOEN = 0x1
	// BCLK pin output is disabled. (Fixed high)
	SYSTEM_EBCKOCR_EBCKOEN_0 = 0x0
	// BCLK pin output is enabled
	SYSTEM_EBCKOCR_EBCKOEN_1 = 0x1

	// MOCOUTCR: MOCO User Trimming Control Register
	// Position of MOCOUTRM field.
	SYSTEM_MOCOUTCR_MOCOUTRM_Pos = 0x0
	// Bit mask of MOCOUTRM field.
	SYSTEM_MOCOUTCR_MOCOUTRM_Msk = 0xff

	// HOCOUTCR: HOCO User Trimming Control Register
	// Position of HOCOUTRM field.
	SYSTEM_HOCOUTCR_HOCOUTRM_Pos = 0x0
	// Bit mask of HOCOUTRM field.
	SYSTEM_HOCOUTCR_HOCOUTRM_Msk = 0xff

	// SNZCR: Snooze Control Register
	// Position of SNZE field.
	SYSTEM_SNZCR_SNZE_Pos = 0x7
	// Bit mask of SNZE field.
	SYSTEM_SNZCR_SNZE_Msk = 0x80
	// Bit SNZE.
	SYSTEM_SNZCR_SNZE = 0x80
	// Disable Snooze Mode
	SYSTEM_SNZCR_SNZE_0 = 0x0
	// Enable Snooze Mode
	SYSTEM_SNZCR_SNZE_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SNZCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_SNZCR_Reserved_Msk = 0x7c
	// Position of SNZDTCEN field.
	SYSTEM_SNZCR_SNZDTCEN_Pos = 0x1
	// Bit mask of SNZDTCEN field.
	SYSTEM_SNZCR_SNZDTCEN_Msk = 0x2
	// Bit SNZDTCEN.
	SYSTEM_SNZCR_SNZDTCEN = 0x2
	// Disable DTC operation
	SYSTEM_SNZCR_SNZDTCEN_0 = 0x0
	// Enable DTC operation
	SYSTEM_SNZCR_SNZDTCEN_1 = 0x1
	// Position of RXDREQEN field.
	SYSTEM_SNZCR_RXDREQEN_Pos = 0x0
	// Bit mask of RXDREQEN field.
	SYSTEM_SNZCR_RXDREQEN_Msk = 0x1
	// Bit RXDREQEN.
	SYSTEM_SNZCR_RXDREQEN = 0x1
	// Ignore RXD0 falling edge in Software Standby mode.
	SYSTEM_SNZCR_RXDREQEN_0 = 0x0
	// Accept RXD0 falling edge in Standby mode as a request to transit to Snooze mode.
	SYSTEM_SNZCR_RXDREQEN_1 = 0x1

	// SNZEDCR: Snooze End Control Register
	// Position of SCI0UMTED field.
	SYSTEM_SNZEDCR_SCI0UMTED_Pos = 0x7
	// Bit mask of SCI0UMTED field.
	SYSTEM_SNZEDCR_SCI0UMTED_Msk = 0x80
	// Bit SCI0UMTED.
	SYSTEM_SNZEDCR_SCI0UMTED = 0x80
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_SCI0UMTED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_SCI0UMTED_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SNZEDCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_SNZEDCR_Reserved_Msk = 0x60
	// Position of AD0UMTED field.
	SYSTEM_SNZEDCR_AD0UMTED_Pos = 0x4
	// Bit mask of AD0UMTED field.
	SYSTEM_SNZEDCR_AD0UMTED_Msk = 0x10
	// Bit AD0UMTED.
	SYSTEM_SNZEDCR_AD0UMTED = 0x10
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_AD0UMTED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_AD0UMTED_1 = 0x1
	// Position of AD0MATED field.
	SYSTEM_SNZEDCR_AD0MATED_Pos = 0x3
	// Bit mask of AD0MATED field.
	SYSTEM_SNZEDCR_AD0MATED_Msk = 0x8
	// Bit AD0MATED.
	SYSTEM_SNZEDCR_AD0MATED = 0x8
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_AD0MATED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_AD0MATED_1 = 0x1
	// Position of DTCNZRED field.
	SYSTEM_SNZEDCR_DTCNZRED_Pos = 0x2
	// Bit mask of DTCNZRED field.
	SYSTEM_SNZEDCR_DTCNZRED_Msk = 0x4
	// Bit DTCNZRED.
	SYSTEM_SNZEDCR_DTCNZRED = 0x4
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_DTCNZRED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_DTCNZRED_1 = 0x1
	// Position of DTCZRED field.
	SYSTEM_SNZEDCR_DTCZRED_Pos = 0x1
	// Bit mask of DTCZRED field.
	SYSTEM_SNZEDCR_DTCZRED_Msk = 0x2
	// Bit DTCZRED.
	SYSTEM_SNZEDCR_DTCZRED = 0x2
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_DTCZRED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_DTCZRED_1 = 0x1
	// Position of AGT1UNFED field.
	SYSTEM_SNZEDCR_AGT1UNFED_Pos = 0x0
	// Bit mask of AGT1UNFED field.
	SYSTEM_SNZEDCR_AGT1UNFED_Msk = 0x1
	// Bit AGT1UNFED.
	SYSTEM_SNZEDCR_AGT1UNFED = 0x1
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_AGT1UNFED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_AGT1UNFED_1 = 0x1

	// SNZREQCR: Snooze Request Control Register
	// Position of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Pos = 0x1f
	// Bit mask of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Msk = 0x80000000
	// Bit Reserved.
	SYSTEM_SNZREQCR_Reserved = 0x80000000
	// Position of SNZREQEN30 field.
	SYSTEM_SNZREQCR_SNZREQEN30_Pos = 0x1e
	// Bit mask of SNZREQEN30 field.
	SYSTEM_SNZREQCR_SNZREQEN30_Msk = 0x40000000
	// Bit SNZREQEN30.
	SYSTEM_SNZREQCR_SNZREQEN30 = 0x40000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN30_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN30_1 = 0x1
	// Position of SNZREQEN29 field.
	SYSTEM_SNZREQCR_SNZREQEN29_Pos = 0x1d
	// Bit mask of SNZREQEN29 field.
	SYSTEM_SNZREQCR_SNZREQEN29_Msk = 0x20000000
	// Bit SNZREQEN29.
	SYSTEM_SNZREQCR_SNZREQEN29 = 0x20000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN29_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN29_1 = 0x1
	// Position of SNZREQEN28 field.
	SYSTEM_SNZREQCR_SNZREQEN28_Pos = 0x1c
	// Bit mask of SNZREQEN28 field.
	SYSTEM_SNZREQCR_SNZREQEN28_Msk = 0x10000000
	// Bit SNZREQEN28.
	SYSTEM_SNZREQCR_SNZREQEN28 = 0x10000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN28_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN28_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Msk = 0xc000000
	// Position of SNZREQEN25 field.
	SYSTEM_SNZREQCR_SNZREQEN25_Pos = 0x19
	// Bit mask of SNZREQEN25 field.
	SYSTEM_SNZREQCR_SNZREQEN25_Msk = 0x2000000
	// Bit SNZREQEN25.
	SYSTEM_SNZREQCR_SNZREQEN25 = 0x2000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN25_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN25_1 = 0x1
	// Position of SNZREQEN24 field.
	SYSTEM_SNZREQCR_SNZREQEN24_Pos = 0x18
	// Bit mask of SNZREQEN24 field.
	SYSTEM_SNZREQCR_SNZREQEN24_Msk = 0x1000000
	// Bit SNZREQEN24.
	SYSTEM_SNZREQCR_SNZREQEN24 = 0x1000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN24_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN24_1 = 0x1
	// Position of SNZREQEN23 field.
	SYSTEM_SNZREQCR_SNZREQEN23_Pos = 0x17
	// Bit mask of SNZREQEN23 field.
	SYSTEM_SNZREQCR_SNZREQEN23_Msk = 0x800000
	// Bit SNZREQEN23.
	SYSTEM_SNZREQCR_SNZREQEN23 = 0x800000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN23_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN23_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Pos = 0x12
	// Bit mask of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Msk = 0x7c0000
	// Position of SNZREQEN17 field.
	SYSTEM_SNZREQCR_SNZREQEN17_Pos = 0x11
	// Bit mask of SNZREQEN17 field.
	SYSTEM_SNZREQCR_SNZREQEN17_Msk = 0x20000
	// Bit SNZREQEN17.
	SYSTEM_SNZREQCR_SNZREQEN17 = 0x20000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN17_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN17_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Msk = 0x10000
	// Bit Reserved.
	SYSTEM_SNZREQCR_Reserved = 0x10000
	// Position of SNZREQEN15 field.
	SYSTEM_SNZREQCR_SNZREQEN15_Pos = 0xf
	// Bit mask of SNZREQEN15 field.
	SYSTEM_SNZREQCR_SNZREQEN15_Msk = 0x8000
	// Bit SNZREQEN15.
	SYSTEM_SNZREQCR_SNZREQEN15 = 0x8000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN15_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN15_1 = 0x1
	// Position of SNZREQEN14 field.
	SYSTEM_SNZREQCR_SNZREQEN14_Pos = 0xe
	// Bit mask of SNZREQEN14 field.
	SYSTEM_SNZREQCR_SNZREQEN14_Msk = 0x4000
	// Bit SNZREQEN14.
	SYSTEM_SNZREQCR_SNZREQEN14 = 0x4000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN14_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN14_1 = 0x1
	// Position of SNZREQEN13 field.
	SYSTEM_SNZREQCR_SNZREQEN13_Pos = 0xd
	// Bit mask of SNZREQEN13 field.
	SYSTEM_SNZREQCR_SNZREQEN13_Msk = 0x2000
	// Bit SNZREQEN13.
	SYSTEM_SNZREQCR_SNZREQEN13 = 0x2000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN13_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN13_1 = 0x1
	// Position of SNZREQEN12 field.
	SYSTEM_SNZREQCR_SNZREQEN12_Pos = 0xc
	// Bit mask of SNZREQEN12 field.
	SYSTEM_SNZREQCR_SNZREQEN12_Msk = 0x1000
	// Bit SNZREQEN12.
	SYSTEM_SNZREQCR_SNZREQEN12 = 0x1000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN12_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN12_1 = 0x1
	// Position of SNZREQEN11 field.
	SYSTEM_SNZREQCR_SNZREQEN11_Pos = 0xb
	// Bit mask of SNZREQEN11 field.
	SYSTEM_SNZREQCR_SNZREQEN11_Msk = 0x800
	// Bit SNZREQEN11.
	SYSTEM_SNZREQCR_SNZREQEN11 = 0x800
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN11_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN11_1 = 0x1
	// Position of SNZREQEN10 field.
	SYSTEM_SNZREQCR_SNZREQEN10_Pos = 0xa
	// Bit mask of SNZREQEN10 field.
	SYSTEM_SNZREQCR_SNZREQEN10_Msk = 0x400
	// Bit SNZREQEN10.
	SYSTEM_SNZREQCR_SNZREQEN10 = 0x400
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN10_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN10_1 = 0x1
	// Position of SNZREQEN9 field.
	SYSTEM_SNZREQCR_SNZREQEN9_Pos = 0x9
	// Bit mask of SNZREQEN9 field.
	SYSTEM_SNZREQCR_SNZREQEN9_Msk = 0x200
	// Bit SNZREQEN9.
	SYSTEM_SNZREQCR_SNZREQEN9 = 0x200
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN9_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN9_1 = 0x1
	// Position of SNZREQEN8 field.
	SYSTEM_SNZREQCR_SNZREQEN8_Pos = 0x8
	// Bit mask of SNZREQEN8 field.
	SYSTEM_SNZREQCR_SNZREQEN8_Msk = 0x100
	// Bit SNZREQEN8.
	SYSTEM_SNZREQCR_SNZREQEN8 = 0x100
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN8_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN8_1 = 0x1
	// Position of SNZREQEN7 field.
	SYSTEM_SNZREQCR_SNZREQEN7_Pos = 0x7
	// Bit mask of SNZREQEN7 field.
	SYSTEM_SNZREQCR_SNZREQEN7_Msk = 0x80
	// Bit SNZREQEN7.
	SYSTEM_SNZREQCR_SNZREQEN7 = 0x80
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN7_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN7_1 = 0x1
	// Position of SNZREQEN6 field.
	SYSTEM_SNZREQCR_SNZREQEN6_Pos = 0x6
	// Bit mask of SNZREQEN6 field.
	SYSTEM_SNZREQCR_SNZREQEN6_Msk = 0x40
	// Bit SNZREQEN6.
	SYSTEM_SNZREQCR_SNZREQEN6 = 0x40
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN6_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN6_1 = 0x1
	// Position of SNZREQEN5 field.
	SYSTEM_SNZREQCR_SNZREQEN5_Pos = 0x5
	// Bit mask of SNZREQEN5 field.
	SYSTEM_SNZREQCR_SNZREQEN5_Msk = 0x20
	// Bit SNZREQEN5.
	SYSTEM_SNZREQCR_SNZREQEN5 = 0x20
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN5_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN5_1 = 0x1
	// Position of SNZREQEN4 field.
	SYSTEM_SNZREQCR_SNZREQEN4_Pos = 0x4
	// Bit mask of SNZREQEN4 field.
	SYSTEM_SNZREQCR_SNZREQEN4_Msk = 0x10
	// Bit SNZREQEN4.
	SYSTEM_SNZREQCR_SNZREQEN4 = 0x10
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN4_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN4_1 = 0x1
	// Position of SNZREQEN3 field.
	SYSTEM_SNZREQCR_SNZREQEN3_Pos = 0x3
	// Bit mask of SNZREQEN3 field.
	SYSTEM_SNZREQCR_SNZREQEN3_Msk = 0x8
	// Bit SNZREQEN3.
	SYSTEM_SNZREQCR_SNZREQEN3 = 0x8
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN3_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN3_1 = 0x1
	// Position of SNZREQEN2 field.
	SYSTEM_SNZREQCR_SNZREQEN2_Pos = 0x2
	// Bit mask of SNZREQEN2 field.
	SYSTEM_SNZREQCR_SNZREQEN2_Msk = 0x4
	// Bit SNZREQEN2.
	SYSTEM_SNZREQCR_SNZREQEN2 = 0x4
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN2_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN2_1 = 0x1
	// Position of SNZREQEN1 field.
	SYSTEM_SNZREQCR_SNZREQEN1_Pos = 0x1
	// Bit mask of SNZREQEN1 field.
	SYSTEM_SNZREQCR_SNZREQEN1_Msk = 0x2
	// Bit SNZREQEN1.
	SYSTEM_SNZREQCR_SNZREQEN1 = 0x2
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN1_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN1_1 = 0x1
	// Position of SNZREQEN0 field.
	SYSTEM_SNZREQCR_SNZREQEN0_Pos = 0x0
	// Bit mask of SNZREQEN0 field.
	SYSTEM_SNZREQCR_SNZREQEN0_Msk = 0x1
	// Bit SNZREQEN0.
	SYSTEM_SNZREQCR_SNZREQEN0 = 0x1
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN0_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN0_1 = 0x1

	// FLSTOP: Flash Operation Control Register
	// Position of Reserved field.
	SYSTEM_FLSTOP_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_FLSTOP_Reserved_Msk = 0xe0
	// Position of FLSTPF field.
	SYSTEM_FLSTOP_FLSTPF_Pos = 0x4
	// Bit mask of FLSTPF field.
	SYSTEM_FLSTOP_FLSTPF_Msk = 0x10
	// Bit FLSTPF.
	SYSTEM_FLSTOP_FLSTPF = 0x10
	// Transition completed
	SYSTEM_FLSTOP_FLSTPF_0 = 0x0
	// During transition (from the flash-stop-status to flash-operating-status or vice versa)
	SYSTEM_FLSTOP_FLSTPF_1 = 0x1
	// Position of Reserved field.
	SYSTEM_FLSTOP_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_FLSTOP_Reserved_Msk = 0xe
	// Position of FLSTOP field.
	SYSTEM_FLSTOP_FLSTOP_Pos = 0x0
	// Bit mask of FLSTOP field.
	SYSTEM_FLSTOP_FLSTOP_Msk = 0x1
	// Bit FLSTOP.
	SYSTEM_FLSTOP_FLSTOP = 0x1
	// Code flash and data flash memory operates
	SYSTEM_FLSTOP_FLSTOP_0 = 0x0
	// Code flash and data flash memory stops.
	SYSTEM_FLSTOP_FLSTOP_1 = 0x1

	// PSMCR: Power Save Memory Control Register
	// Position of Reserved field.
	SYSTEM_PSMCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_PSMCR_Reserved_Msk = 0xfc
	// Position of PSMC field.
	SYSTEM_PSMCR_PSMC_Pos = 0x0
	// Bit mask of PSMC field.
	SYSTEM_PSMCR_PSMC_Msk = 0x3
	// All RAM is on Software Standby mode.
	SYSTEM_PSMCR_PSMC_00 = 0x0
	// 48KB RAM is on in Software Standby mode.
	SYSTEM_PSMCR_PSMC_01 = 0x1

	// OPCCR: Operating Power Control Register
	// Position of Reserved field.
	SYSTEM_OPCCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_OPCCR_Reserved_Msk = 0xe0
	// Position of OPCMTSF field.
	SYSTEM_OPCCR_OPCMTSF_Pos = 0x4
	// Bit mask of OPCMTSF field.
	SYSTEM_OPCCR_OPCMTSF_Msk = 0x10
	// Bit OPCMTSF.
	SYSTEM_OPCCR_OPCMTSF = 0x10
	// Transition completed
	SYSTEM_OPCCR_OPCMTSF_0 = 0x0
	// During transition
	SYSTEM_OPCCR_OPCMTSF_1 = 0x1
	// Position of Reserved field.
	SYSTEM_OPCCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_OPCCR_Reserved_Msk = 0xc
	// Position of OPCM field.
	SYSTEM_OPCCR_OPCM_Pos = 0x0
	// Bit mask of OPCM field.
	SYSTEM_OPCCR_OPCM_Msk = 0x3
	// High-speed mode
	SYSTEM_OPCCR_OPCM_00 = 0x0
	// Middle-speed mode
	SYSTEM_OPCCR_OPCM_01 = 0x1
	// Low-voltage mode
	SYSTEM_OPCCR_OPCM_10 = 0x2
	// Low-speed mode
	SYSTEM_OPCCR_OPCM_11 = 0x3

	// MOSCWTCR: Main Clock Oscillator Wait Control Register
	// Position of Reserved field.
	SYSTEM_MOSCWTCR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SYSTEM_MOSCWTCR_Reserved_Msk = 0xf0
	// Position of MSTS field.
	SYSTEM_MOSCWTCR_MSTS_Pos = 0x0
	// Bit mask of MSTS field.
	SYSTEM_MOSCWTCR_MSTS_Msk = 0xf
	// Wait time = 2 cycles (0.25 us)
	SYSTEM_MOSCWTCR_MSTS_0000 = 0x0
	// Wait time = 1024 cycles (128 us)
	SYSTEM_MOSCWTCR_MSTS_0001 = 0x1
	// Wait time = 2048 cycles (256 us)
	SYSTEM_MOSCWTCR_MSTS_0010 = 0x2
	// Wait time = 4096 cycles (512 us)
	SYSTEM_MOSCWTCR_MSTS_0011 = 0x3
	// Wait time = 8192 cycles (1024 us)
	SYSTEM_MOSCWTCR_MSTS_0100 = 0x4
	// Wait time = 16384 cycles (2048 us) (value after reset)
	SYSTEM_MOSCWTCR_MSTS_0101 = 0x5
	// Wait time = 32768 cycles (4096 us)
	SYSTEM_MOSCWTCR_MSTS_0110 = 0x6
	// Wait time = 65536 cycles (8192 us)
	SYSTEM_MOSCWTCR_MSTS_0111 = 0x7
	// Wait time = 131072 cycles (16384 us)
	SYSTEM_MOSCWTCR_MSTS_1000 = 0x8
	// Wait time = 262144 cycles (32768 us).
	SYSTEM_MOSCWTCR_MSTS_1001 = 0x9

	// HOCOWTCR: High-Speed On-Chip Oscillator Wait Control Register
	// Position of Reserved field.
	SYSTEM_HOCOWTCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_HOCOWTCR_Reserved_Msk = 0xf8
	// Position of HSTS field.
	SYSTEM_HOCOWTCR_HSTS_Pos = 0x0
	// Bit mask of HSTS field.
	SYSTEM_HOCOWTCR_HSTS_Msk = 0x7
	// If HOCO frequency is other than 64MHz, should set the value to 101b.
	SYSTEM_HOCOWTCR_HSTS_101 = 0x5
	// If HOCO frequency = 64MHz, should set the value to 110b.
	SYSTEM_HOCOWTCR_HSTS_110 = 0x6

	// SOPCCR: Sub Operating Power Control Register
	// Position of Reserved field.
	SYSTEM_SOPCCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_SOPCCR_Reserved_Msk = 0xe0
	// Position of SOPCMTSF field.
	SYSTEM_SOPCCR_SOPCMTSF_Pos = 0x4
	// Bit mask of SOPCMTSF field.
	SYSTEM_SOPCCR_SOPCMTSF_Msk = 0x10
	// Bit SOPCMTSF.
	SYSTEM_SOPCCR_SOPCMTSF = 0x10
	// Transition completed
	SYSTEM_SOPCCR_SOPCMTSF_0 = 0x0
	// During transition
	SYSTEM_SOPCCR_SOPCMTSF_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SOPCCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_SOPCCR_Reserved_Msk = 0xe
	// Position of SOPCM field.
	SYSTEM_SOPCCR_SOPCM_Pos = 0x0
	// Bit mask of SOPCM field.
	SYSTEM_SOPCCR_SOPCM_Msk = 0x1
	// Bit SOPCM.
	SYSTEM_SOPCCR_SOPCM = 0x1
	// Other than Subosc-speed mode
	SYSTEM_SOPCCR_SOPCM_0 = 0x0
	// Subosc-speed mode
	SYSTEM_SOPCCR_SOPCM_1 = 0x1

	// RSTSR1: Reset Status Register 1
	// Position of Reserved field.
	SYSTEM_RSTSR1_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	SYSTEM_RSTSR1_Reserved_Msk = 0xe000
	// Position of SPERF field.
	SYSTEM_RSTSR1_SPERF_Pos = 0xc
	// Bit mask of SPERF field.
	SYSTEM_RSTSR1_SPERF_Msk = 0x1000
	// Bit SPERF.
	SYSTEM_RSTSR1_SPERF = 0x1000
	// SP error reset not detected.
	SYSTEM_RSTSR1_SPERF_0 = 0x0
	// SP error reset detected.
	SYSTEM_RSTSR1_SPERF_1 = 0x1
	// Position of BUSMRF field.
	SYSTEM_RSTSR1_BUSMRF_Pos = 0xb
	// Bit mask of BUSMRF field.
	SYSTEM_RSTSR1_BUSMRF_Msk = 0x800
	// Bit BUSMRF.
	SYSTEM_RSTSR1_BUSMRF = 0x800
	// Bus Master MPU reset not detected.
	SYSTEM_RSTSR1_BUSMRF_0 = 0x0
	// Bus Master MPU reset detected.
	SYSTEM_RSTSR1_BUSMRF_1 = 0x1
	// Position of BUSSRF field.
	SYSTEM_RSTSR1_BUSSRF_Pos = 0xa
	// Bit mask of BUSSRF field.
	SYSTEM_RSTSR1_BUSSRF_Msk = 0x400
	// Bit BUSSRF.
	SYSTEM_RSTSR1_BUSSRF = 0x400
	// Bus Slave MPU reset not detected.
	SYSTEM_RSTSR1_BUSSRF_0 = 0x0
	// Bus Slave MPU reset detected.
	SYSTEM_RSTSR1_BUSSRF_1 = 0x1
	// Position of REERF field.
	SYSTEM_RSTSR1_REERF_Pos = 0x9
	// Bit mask of REERF field.
	SYSTEM_RSTSR1_REERF_Msk = 0x200
	// Bit REERF.
	SYSTEM_RSTSR1_REERF = 0x200
	// RAM ECC error reset not detected.
	SYSTEM_RSTSR1_REERF_0 = 0x0
	// RAM ECC error reset detected.
	SYSTEM_RSTSR1_REERF_1 = 0x1
	// Position of RPERF field.
	SYSTEM_RSTSR1_RPERF_Pos = 0x8
	// Bit mask of RPERF field.
	SYSTEM_RSTSR1_RPERF_Msk = 0x100
	// Bit RPERF.
	SYSTEM_RSTSR1_RPERF = 0x100
	// RAM parity error reset not detected.
	SYSTEM_RSTSR1_RPERF_0 = 0x0
	// RAM parity error reset detected.
	SYSTEM_RSTSR1_RPERF_1 = 0x1
	// Position of Reserved field.
	SYSTEM_RSTSR1_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_RSTSR1_Reserved_Msk = 0xf8
	// Position of SWRF field.
	SYSTEM_RSTSR1_SWRF_Pos = 0x2
	// Bit mask of SWRF field.
	SYSTEM_RSTSR1_SWRF_Msk = 0x4
	// Bit SWRF.
	SYSTEM_RSTSR1_SWRF = 0x4
	// Software reset not detected.
	SYSTEM_RSTSR1_SWRF_0 = 0x0
	// Software reset detected.
	SYSTEM_RSTSR1_SWRF_1 = 0x1
	// Position of WDTRF field.
	SYSTEM_RSTSR1_WDTRF_Pos = 0x1
	// Bit mask of WDTRF field.
	SYSTEM_RSTSR1_WDTRF_Msk = 0x2
	// Bit WDTRF.
	SYSTEM_RSTSR1_WDTRF = 0x2
	// Watchdog timer reset not detected.
	SYSTEM_RSTSR1_WDTRF_0 = 0x0
	// Watchdog timer reset detected.
	SYSTEM_RSTSR1_WDTRF_1 = 0x1
	// Position of IWDTRF field.
	SYSTEM_RSTSR1_IWDTRF_Pos = 0x0
	// Bit mask of IWDTRF field.
	SYSTEM_RSTSR1_IWDTRF_Msk = 0x1
	// Bit IWDTRF.
	SYSTEM_RSTSR1_IWDTRF = 0x1
	// Independent watchdog timer reset not detected.
	SYSTEM_RSTSR1_IWDTRF_0 = 0x0
	// Independent watchdog timer reset detected.
	SYSTEM_RSTSR1_IWDTRF_1 = 0x1

	// BKRACR: Backup Register Access Control Register
	// Position of Reserved field.
	SYSTEM_BKRACR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_BKRACR_Reserved_Msk = 0xf8
	// Position of BKRACS field.
	SYSTEM_BKRACR_BKRACS_Pos = 0x0
	// Bit mask of BKRACS field.
	SYSTEM_BKRACR_BKRACS_Msk = 0x7
	// Access control disable. When System clock source is SOSC or LOCO.
	SYSTEM_BKRACR_BKRACS_000 = 0x0
	// Access control enable. System clock source is other than SOSC or LOCO.
	SYSTEM_BKRACR_BKRACS_110 = 0x6

	// USBCKCR: USB Clock Control register
	// Position of Reserved field.
	SYSTEM_USBCKCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_USBCKCR_Reserved_Msk = 0xfe
	// Position of HSTS field.
	SYSTEM_USBCKCR_HSTS_Pos = 0x0
	// Bit mask of HSTS field.
	SYSTEM_USBCKCR_HSTS_Msk = 0x1
	// Bit HSTS.
	SYSTEM_USBCKCR_HSTS = 0x1
	// PLL(Value after reset)
	SYSTEM_USBCKCR_HSTS_0 = 0x0
	// HOCO
	SYSTEM_USBCKCR_HSTS_1 = 0x1

	// LVD1CR1: Voltage Monitor %s Circuit Control Register 1
	// Position of Reserved field.
	SYSTEM_LVDCR1_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_LVDCR1_Reserved_Msk = 0xf8
	// Position of IRQSEL field.
	SYSTEM_LVDCR1_IRQSEL_Pos = 0x2
	// Bit mask of IRQSEL field.
	SYSTEM_LVDCR1_IRQSEL_Msk = 0x4
	// Bit IRQSEL.
	SYSTEM_LVDCR1_IRQSEL = 0x4
	// Non-maskable interrupt
	SYSTEM_LVDCR1_IRQSEL_0 = 0x0
	// Maskable interrupt
	SYSTEM_LVDCR1_IRQSEL_1 = 0x1
	// Position of IDTSEL field.
	SYSTEM_LVDCR1_IDTSEL_Pos = 0x0
	// Bit mask of IDTSEL field.
	SYSTEM_LVDCR1_IDTSEL_Msk = 0x3
	// When VCC>=Vdet (rise) is detected
	SYSTEM_LVDCR1_IDTSEL_00 = 0x0
	// When VCC<Vdet (drop) is detected
	SYSTEM_LVDCR1_IDTSEL_01 = 0x1
	// When drop and rise are detected
	SYSTEM_LVDCR1_IDTSEL_10 = 0x2
	// Settings prohibited
	SYSTEM_LVDCR1_IDTSEL_11 = 0x3

	// LVD1SR: Voltage Monitor %s Circuit Status Register
	// Position of Reserved field.
	SYSTEM_LVDSR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_LVDSR_Reserved_Msk = 0xfc
	// Position of MON field.
	SYSTEM_LVDSR_MON_Pos = 0x1
	// Bit mask of MON field.
	SYSTEM_LVDSR_MON_Msk = 0x2
	// Bit MON.
	SYSTEM_LVDSR_MON = 0x2
	// VCC < Vdet
	SYSTEM_LVDSR_MON_0 = 0x0
	// VCC >= Vdet or MON bit is disabled
	SYSTEM_LVDSR_MON_1 = 0x1
	// Position of DET field.
	SYSTEM_LVDSR_DET_Pos = 0x0
	// Bit mask of DET field.
	SYSTEM_LVDSR_DET_Msk = 0x1
	// Bit DET.
	SYSTEM_LVDSR_DET = 0x1
	// Not detected
	SYSTEM_LVDSR_DET_0 = 0x0
	// Vdet1 passage detection
	SYSTEM_LVDSR_DET_1 = 0x1

	// PRCR: Protect Register
	// Position of PRKEY field.
	SYSTEM_PRCR_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	SYSTEM_PRCR_PRKEY_Msk = 0xff00
	// Enables writing to the PRCR register.
	SYSTEM_PRCR_PRKEY_0x5A = 0x5a
	// Position of Reserved field.
	SYSTEM_PRCR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SYSTEM_PRCR_Reserved_Msk = 0xf0
	// Position of PRC3 field.
	SYSTEM_PRCR_PRC3_Pos = 0x3
	// Bit mask of PRC3 field.
	SYSTEM_PRCR_PRC3_Msk = 0x8
	// Bit PRC3.
	SYSTEM_PRCR_PRC3 = 0x8
	// Writes protected.
	SYSTEM_PRCR_PRC3_0 = 0x0
	// Writes not protected.
	SYSTEM_PRCR_PRC3_1 = 0x1
	// Position of Reserved field.
	SYSTEM_PRCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_PRCR_Reserved_Msk = 0x4
	// Bit Reserved.
	SYSTEM_PRCR_Reserved = 0x4
	// Position of PRC1 field.
	SYSTEM_PRCR_PRC1_Pos = 0x1
	// Bit mask of PRC1 field.
	SYSTEM_PRCR_PRC1_Msk = 0x2
	// Bit PRC1.
	SYSTEM_PRCR_PRC1 = 0x2
	// Writes protected.
	SYSTEM_PRCR_PRC1_0 = 0x0
	// Writes not protected.
	SYSTEM_PRCR_PRC1_1 = 0x1
	// Position of PRC0 field.
	SYSTEM_PRCR_PRC0_Pos = 0x0
	// Bit mask of PRC0 field.
	SYSTEM_PRCR_PRC0_Msk = 0x1
	// Bit PRC0.
	SYSTEM_PRCR_PRC0 = 0x1
	// Writes protected.
	SYSTEM_PRCR_PRC0_0 = 0x0
	// Writes not protected.
	SYSTEM_PRCR_PRC0_1 = 0x1

	// SYOCDCR: System Control OCD Control Register
	// Position of DBGEN field.
	SYSTEM_SYOCDCR_DBGEN_Pos = 0x7
	// Bit mask of DBGEN field.
	SYSTEM_SYOCDCR_DBGEN_Msk = 0x80
	// Bit DBGEN.
	SYSTEM_SYOCDCR_DBGEN = 0x80
	// On-chip debugger is disabled
	SYSTEM_SYOCDCR_DBGEN_0 = 0x0
	// On-chip debugger is enabled
	SYSTEM_SYOCDCR_DBGEN_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SYOCDCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SYSTEM_SYOCDCR_Reserved_Msk = 0x7f

	// RSTSR0: Reset Status Register 0
	// Position of Reserved field.
	SYSTEM_RSTSR0_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SYSTEM_RSTSR0_Reserved_Msk = 0xf0
	// Position of LVD2RF field.
	SYSTEM_RSTSR0_LVD2RF_Pos = 0x3
	// Bit mask of LVD2RF field.
	SYSTEM_RSTSR0_LVD2RF_Msk = 0x8
	// Bit LVD2RF.
	SYSTEM_RSTSR0_LVD2RF = 0x8
	// Voltage Monitor 2 reset not detected.
	SYSTEM_RSTSR0_LVD2RF_0 = 0x0
	// Voltage Monitor 2 reset detected.
	SYSTEM_RSTSR0_LVD2RF_1 = 0x1
	// Position of LVD1RF field.
	SYSTEM_RSTSR0_LVD1RF_Pos = 0x2
	// Bit mask of LVD1RF field.
	SYSTEM_RSTSR0_LVD1RF_Msk = 0x4
	// Bit LVD1RF.
	SYSTEM_RSTSR0_LVD1RF = 0x4
	// Voltage Monitor 1 reset not detected.
	SYSTEM_RSTSR0_LVD1RF_0 = 0x0
	// Voltage Monitor 1 reset detected.
	SYSTEM_RSTSR0_LVD1RF_1 = 0x1
	// Position of LVD0RF field.
	SYSTEM_RSTSR0_LVD0RF_Pos = 0x1
	// Bit mask of LVD0RF field.
	SYSTEM_RSTSR0_LVD0RF_Msk = 0x2
	// Bit LVD0RF.
	SYSTEM_RSTSR0_LVD0RF = 0x2
	// Voltage Monitor 0 reset not detected.
	SYSTEM_RSTSR0_LVD0RF_0 = 0x0
	// Voltage Monitor 0 reset detected.
	SYSTEM_RSTSR0_LVD0RF_1 = 0x1
	// Position of PORF field.
	SYSTEM_RSTSR0_PORF_Pos = 0x0
	// Bit mask of PORF field.
	SYSTEM_RSTSR0_PORF_Msk = 0x1
	// Bit PORF.
	SYSTEM_RSTSR0_PORF = 0x1
	// Power-on reset not detected.
	SYSTEM_RSTSR0_PORF_0 = 0x0
	// Power-on reset detected.
	SYSTEM_RSTSR0_PORF_1 = 0x1

	// RSTSR2: Reset Status Register 2
	// Position of Reserved field.
	SYSTEM_RSTSR2_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_RSTSR2_Reserved_Msk = 0xfe
	// Position of CWSF field.
	SYSTEM_RSTSR2_CWSF_Pos = 0x0
	// Bit mask of CWSF field.
	SYSTEM_RSTSR2_CWSF_Msk = 0x1
	// Bit CWSF.
	SYSTEM_RSTSR2_CWSF = 0x1
	// Cold start
	SYSTEM_RSTSR2_CWSF_0 = 0x0
	// Warm start
	SYSTEM_RSTSR2_CWSF_1 = 0x1

	// MOMCR: Main Clock Oscillator Mode Oscillation Control Register
	// Position of Reserved field.
	SYSTEM_MOMCR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	SYSTEM_MOMCR_Reserved_Msk = 0x80
	// Bit Reserved.
	SYSTEM_MOMCR_Reserved = 0x80
	// Position of MOSEL field.
	SYSTEM_MOMCR_MOSEL_Pos = 0x6
	// Bit mask of MOSEL field.
	SYSTEM_MOMCR_MOSEL_Msk = 0x40
	// Bit MOSEL.
	SYSTEM_MOMCR_MOSEL = 0x40
	// Resonator
	SYSTEM_MOMCR_MOSEL_0 = 0x0
	// External clock input
	SYSTEM_MOMCR_MOSEL_1 = 0x1
	// Position of Reserved field.
	SYSTEM_MOMCR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SYSTEM_MOMCR_Reserved_Msk = 0x30
	// Position of MODRV1 field.
	SYSTEM_MOMCR_MODRV1_Pos = 0x3
	// Bit mask of MODRV1 field.
	SYSTEM_MOMCR_MODRV1_Msk = 0x8
	// Bit MODRV1.
	SYSTEM_MOMCR_MODRV1 = 0x8
	// 10 MHz to 20 MHz
	SYSTEM_MOMCR_MODRV1_0 = 0x0
	// 1 MHz to 10 MHz.
	SYSTEM_MOMCR_MODRV1_1 = 0x1
	// Position of Reserved field.
	SYSTEM_MOMCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SYSTEM_MOMCR_Reserved_Msk = 0x7

	// LVCMPCR: Voltage Monitor Circuit Control Register
	// Position of Reserved field.
	SYSTEM_LVCMPCR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	SYSTEM_LVCMPCR_Reserved_Msk = 0x80
	// Bit Reserved.
	SYSTEM_LVCMPCR_Reserved = 0x80
	// Position of LVD2E field.
	SYSTEM_LVCMPCR_LVD2E_Pos = 0x6
	// Bit mask of LVD2E field.
	SYSTEM_LVCMPCR_LVD2E_Msk = 0x40
	// Bit LVD2E.
	SYSTEM_LVCMPCR_LVD2E = 0x40
	// Voltage detection 2 circuit disabled
	SYSTEM_LVCMPCR_LVD2E_0 = 0x0
	// Voltage detection 2 circuit enabled
	SYSTEM_LVCMPCR_LVD2E_1 = 0x1
	// Position of LVD1E field.
	SYSTEM_LVCMPCR_LVD1E_Pos = 0x5
	// Bit mask of LVD1E field.
	SYSTEM_LVCMPCR_LVD1E_Msk = 0x20
	// Bit LVD1E.
	SYSTEM_LVCMPCR_LVD1E = 0x20
	// Voltage detection 1 circuit disabled
	SYSTEM_LVCMPCR_LVD1E_0 = 0x0
	// Voltage detection 1 circuit enabled
	SYSTEM_LVCMPCR_LVD1E_1 = 0x1
	// Position of Reserved field.
	SYSTEM_LVCMPCR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SYSTEM_LVCMPCR_Reserved_Msk = 0x10
	// Bit Reserved.
	SYSTEM_LVCMPCR_Reserved = 0x10
	// Position of Reserved field.
	SYSTEM_LVCMPCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_LVCMPCR_Reserved_Msk = 0xc
	// Position of Reserved field.
	SYSTEM_LVCMPCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SYSTEM_LVCMPCR_Reserved_Msk = 0x3

	// LVDLVLR: Voltage Detection Level Select Register
	// Position of LVD2LVL field.
	SYSTEM_LVDLVLR_LVD2LVL_Pos = 0x5
	// Bit mask of LVD2LVL field.
	SYSTEM_LVDLVLR_LVD2LVL_Msk = 0xe0
	// 4.29V (Vdet2_0)
	SYSTEM_LVDLVLR_LVD2LVL_000 = 0x0
	// 4.14V (Vdet2_1)
	SYSTEM_LVDLVLR_LVD2LVL_001 = 0x1
	// 4.02V (Vdet2_2)
	SYSTEM_LVDLVLR_LVD2LVL_010 = 0x2
	// 3.84V (Vdet2_3)
	SYSTEM_LVDLVLR_LVD2LVL_011 = 0x3
	// Position of LVD1LVL field.
	SYSTEM_LVDLVLR_LVD1LVL_Pos = 0x0
	// Bit mask of LVD1LVL field.
	SYSTEM_LVDLVLR_LVD1LVL_Msk = 0x1f
	// 4.29V (Vdet1_0)
	SYSTEM_LVDLVLR_LVD1LVL_00000 = 0x0
	// 4.14V (Vdet1_1)
	SYSTEM_LVDLVLR_LVD1LVL_00001 = 0x1
	// 4.02V (Vdet1_2)
	SYSTEM_LVDLVLR_LVD1LVL_00010 = 0x2
	// 3.84V (Vdet1_3)
	SYSTEM_LVDLVLR_LVD1LVL_00011 = 0x3
	// 3.10V (Vdet1_4)
	SYSTEM_LVDLVLR_LVD1LVL_00100 = 0x4
	// 3.00V (Vdet1_5)
	SYSTEM_LVDLVLR_LVD1LVL_00101 = 0x5
	// 2.90V (Vdet1_6)
	SYSTEM_LVDLVLR_LVD1LVL_00110 = 0x6
	// 2.79V (Vdet1_7)
	SYSTEM_LVDLVLR_LVD1LVL_00111 = 0x7
	// 2.68V (Vdet1_8)
	SYSTEM_LVDLVLR_LVD1LVL_01000 = 0x8
	// 2.58V (Vdet1_9)
	SYSTEM_LVDLVLR_LVD1LVL_01001 = 0x9
	// 2.48V (Vdet1_A)
	SYSTEM_LVDLVLR_LVD1LVL_01010 = 0xa
	// 2.20V (Vdet1_B)
	SYSTEM_LVDLVLR_LVD1LVL_01011 = 0xb
	// 1.96V (Vdet1_C)
	SYSTEM_LVDLVLR_LVD1LVL_01100 = 0xc
	// 1.86V (Vdet1_D)
	SYSTEM_LVDLVLR_LVD1LVL_01101 = 0xd
	// 1.75V (Vdet1_E)
	SYSTEM_LVDLVLR_LVD1LVL_01110 = 0xe
	// 1.65V (Vdet1_F)
	SYSTEM_LVDLVLR_LVD1LVL_01111 = 0xf

	// LVD1CR0: Voltage Monitor %s Circuit Control Register 0
	// Position of RN field.
	SYSTEM_LVDCR0_RN_Pos = 0x7
	// Bit mask of RN field.
	SYSTEM_LVDCR0_RN_Msk = 0x80
	// Bit RN.
	SYSTEM_LVDCR0_RN = 0x80
	// Negation follows a stabilization time (tLVD) after VCC > Vdet1 is detected.
	SYSTEM_LVDCR0_RN_0 = 0x0
	// Negation follows a stabilization time (tLVD) after assertion of the LVD reset.
	SYSTEM_LVDCR0_RN_1 = 0x1
	// Position of RI field.
	SYSTEM_LVDCR0_RI_Pos = 0x6
	// Bit mask of RI field.
	SYSTEM_LVDCR0_RI_Msk = 0x40
	// Bit RI.
	SYSTEM_LVDCR0_RI = 0x40
	// Voltage Monitor interrupt during Vdet1 passage
	SYSTEM_LVDCR0_RI_0 = 0x0
	// Voltage Monitor reset enabled when the voltage falls to and below Vdet1
	SYSTEM_LVDCR0_RI_1 = 0x1
	// Position of Reserved field.
	SYSTEM_LVDCR0_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_LVDCR0_Reserved_Msk = 0x38
	// Position of CMPE field.
	SYSTEM_LVDCR0_CMPE_Pos = 0x2
	// Bit mask of CMPE field.
	SYSTEM_LVDCR0_CMPE_Msk = 0x4
	// Bit CMPE.
	SYSTEM_LVDCR0_CMPE = 0x4
	// Voltage Monitor circuit comparison result output disabled.
	SYSTEM_LVDCR0_CMPE_0 = 0x0
	// Voltage Monitor circuit comparison result output enabled.
	SYSTEM_LVDCR0_CMPE_1 = 0x1
	// Position of Reserved field.
	SYSTEM_LVDCR0_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_LVDCR0_Reserved_Msk = 0x2
	// Bit Reserved.
	SYSTEM_LVDCR0_Reserved = 0x2
	// Position of RIE field.
	SYSTEM_LVDCR0_RIE_Pos = 0x0
	// Bit mask of RIE field.
	SYSTEM_LVDCR0_RIE_Msk = 0x1
	// Bit RIE.
	SYSTEM_LVDCR0_RIE = 0x1
	// Disabled
	SYSTEM_LVDCR0_RIE_0 = 0x0
	// Enabled
	SYSTEM_LVDCR0_RIE_1 = 0x1

	// VBTCR1: VBATT Control Register1
	// Position of Reserved field.
	SYSTEM_VBTCR1_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_VBTCR1_Reserved_Msk = 0xfe
	// Position of BPWSWSTP field.
	SYSTEM_VBTCR1_BPWSWSTP_Pos = 0x0
	// Bit mask of BPWSWSTP field.
	SYSTEM_VBTCR1_BPWSWSTP_Msk = 0x1
	// Bit BPWSWSTP.
	SYSTEM_VBTCR1_BPWSWSTP = 0x1
	// Battery Power supply Switch Enable
	SYSTEM_VBTCR1_BPWSWSTP_0 = 0x0
	// Battery Power supply Switch stop
	SYSTEM_VBTCR1_BPWSWSTP_1 = 0x1

	// SOSCCR: Sub-Clock Oscillator Control Register
	// Position of Reserved field.
	SYSTEM_SOSCCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_SOSCCR_Reserved_Msk = 0xfe
	// Position of SOSTP field.
	SYSTEM_SOSCCR_SOSTP_Pos = 0x0
	// Bit mask of SOSTP field.
	SYSTEM_SOSCCR_SOSTP_Msk = 0x1
	// Bit SOSTP.
	SYSTEM_SOSCCR_SOSTP = 0x1
	// Sub-clock oscillator is operating.
	SYSTEM_SOSCCR_SOSTP_0 = 0x0
	// Sub-clock oscillator is stopped.
	SYSTEM_SOSCCR_SOSTP_1 = 0x1

	// SOMCR: Sub Clock Oscillator Mode Control Register
	// Position of Reserved field.
	SYSTEM_SOMCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_SOMCR_Reserved_Msk = 0xfc
	// Position of SODRV field.
	SYSTEM_SOMCR_SODRV_Pos = 0x0
	// Bit mask of SODRV field.
	SYSTEM_SOMCR_SODRV_Msk = 0x3
	// Normal mode
	SYSTEM_SOMCR_SODRV_00 = 0x0
	// Low power mode 1
	SYSTEM_SOMCR_SODRV_01 = 0x1
	// Low power mode 2
	SYSTEM_SOMCR_SODRV_10 = 0x2
	// Low power mode 3.
	SYSTEM_SOMCR_SODRV_11 = 0x3

	// LOCOCR: Low-Speed On-Chip Oscillator Control Register
	// Position of Reserved field.
	SYSTEM_LOCOCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_LOCOCR_Reserved_Msk = 0xfe
	// Position of LCSTP field.
	SYSTEM_LOCOCR_LCSTP_Pos = 0x0
	// Bit mask of LCSTP field.
	SYSTEM_LOCOCR_LCSTP_Msk = 0x1
	// Bit LCSTP.
	SYSTEM_LOCOCR_LCSTP = 0x1
	// LOCO is operating.
	SYSTEM_LOCOCR_LCSTP_0 = 0x0
	// LOCO is stopped.
	SYSTEM_LOCOCR_LCSTP_1 = 0x1

	// LOCOUTCR: LOCO User Trimming Control Register
	// Position of LOCOUTRM field.
	SYSTEM_LOCOUTCR_LOCOUTRM_Pos = 0x0
	// Bit mask of LOCOUTRM field.
	SYSTEM_LOCOUTCR_LOCOUTRM_Msk = 0xff

	// VBTCR2: VBATT Control Register2
	// Position of VBTLVDLVL field.
	SYSTEM_VBTCR2_VBTLVDLVL_Pos = 0x6
	// Bit mask of VBTLVDLVL field.
	SYSTEM_VBTCR2_VBTLVDLVL_Msk = 0xc0
	// 2.7V
	SYSTEM_VBTCR2_VBTLVDLVL_00 = 0x0
	// Setting prohibited
	SYSTEM_VBTCR2_VBTLVDLVL_01 = 0x1
	// 2.3V
	SYSTEM_VBTCR2_VBTLVDLVL_10 = 0x2
	// 2.1V
	SYSTEM_VBTCR2_VBTLVDLVL_11 = 0x3
	// Position of Reserved field.
	SYSTEM_VBTCR2_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_VBTCR2_Reserved_Msk = 0x20
	// Bit Reserved.
	SYSTEM_VBTCR2_Reserved = 0x20
	// Position of VBTLVDEN field.
	SYSTEM_VBTCR2_VBTLVDEN_Pos = 0x4
	// Bit mask of VBTLVDEN field.
	SYSTEM_VBTCR2_VBTLVDEN_Msk = 0x10
	// Bit VBTLVDEN.
	SYSTEM_VBTCR2_VBTLVDEN = 0x10
	// VBATT pin low voltage detect disable
	SYSTEM_VBTCR2_VBTLVDEN_0 = 0x0
	// VBATT pin low voltage detect enable
	SYSTEM_VBTCR2_VBTLVDEN_1 = 0x1
	// Position of Reserved field.
	SYSTEM_VBTCR2_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SYSTEM_VBTCR2_Reserved_Msk = 0xf

	// VBTSR: VBATT Status Register
	// Position of Reserved field.
	SYSTEM_VBTSR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_VBTSR_Reserved_Msk = 0xe0
	// Position of VBTRVLD field.
	SYSTEM_VBTSR_VBTRVLD_Pos = 0x4
	// Bit mask of VBTRVLD field.
	SYSTEM_VBTSR_VBTRVLD_Msk = 0x10
	// Bit VBTRVLD.
	SYSTEM_VBTSR_VBTRVLD = 0x10
	// VBATT_R area not valid
	SYSTEM_VBTSR_VBTRVLD_0 = 0x0
	// VBATT_R area valid
	SYSTEM_VBTSR_VBTRVLD_1 = 0x1
	// Position of Reserved field.
	SYSTEM_VBTSR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_VBTSR_Reserved_Msk = 0xc
	// Position of VBTBLDF field.
	SYSTEM_VBTSR_VBTBLDF_Pos = 0x1
	// Bit mask of VBTBLDF field.
	SYSTEM_VBTSR_VBTBLDF_Msk = 0x2
	// Bit VBTBLDF.
	SYSTEM_VBTSR_VBTBLDF = 0x2
	// VBATT pin low voltage not detected
	SYSTEM_VBTSR_VBTBLDF_0 = 0x0
	// VBATT pin low voltage detected.
	SYSTEM_VBTSR_VBTBLDF_1 = 0x1
	// Position of VBTRDF field.
	SYSTEM_VBTSR_VBTRDF_Pos = 0x0
	// Bit mask of VBTRDF field.
	SYSTEM_VBTSR_VBTRDF_Msk = 0x1
	// Bit VBTRDF.
	SYSTEM_VBTSR_VBTRDF = 0x1
	// VBATT_R voltage power-on reset not detected
	SYSTEM_VBTSR_VBTRDF_0 = 0x0
	// VBATT_R selected voltage power-on reset detected.
	SYSTEM_VBTSR_VBTRDF_1 = 0x1

	// VBTCMPCR: VBATT Comparator Control Register
	// Position of Reserved field.
	SYSTEM_VBTCMPCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_VBTCMPCR_Reserved_Msk = 0xfe
	// Position of VBTCMPE field.
	SYSTEM_VBTCMPCR_VBTCMPE_Pos = 0x0
	// Bit mask of VBTCMPE field.
	SYSTEM_VBTCMPCR_VBTCMPE_Msk = 0x1
	// Bit VBTCMPE.
	SYSTEM_VBTCMPCR_VBTCMPE = 0x1
	// VBATT pin low voltage detect circuit output disabled
	SYSTEM_VBTCMPCR_VBTCMPE_0 = 0x0
	// VBATT pin low voltage detect circuit output enabled
	SYSTEM_VBTCMPCR_VBTCMPE_1 = 0x1

	// VBTLVDICR: VBATT Pin Low Voltage Detect Interrupt Control Register
	// Position of Reserved field.
	SYSTEM_VBTLVDICR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_VBTLVDICR_Reserved_Msk = 0xfc
	// Position of VBTLVDISEL field.
	SYSTEM_VBTLVDICR_VBTLVDISEL_Pos = 0x1
	// Bit mask of VBTLVDISEL field.
	SYSTEM_VBTLVDICR_VBTLVDISEL_Msk = 0x2
	// Bit VBTLVDISEL.
	SYSTEM_VBTLVDICR_VBTLVDISEL = 0x2
	// Non Maskable Interrupt
	SYSTEM_VBTLVDICR_VBTLVDISEL_0 = 0x0
	// Maskable Interrupt
	SYSTEM_VBTLVDICR_VBTLVDISEL_1 = 0x1
	// Position of VBTLVDIE field.
	SYSTEM_VBTLVDICR_VBTLVDIE_Pos = 0x0
	// Bit mask of VBTLVDIE field.
	SYSTEM_VBTLVDICR_VBTLVDIE_Msk = 0x1
	// Bit VBTLVDIE.
	SYSTEM_VBTLVDICR_VBTLVDIE = 0x1
	// VBATT Pin Low Voltage Detect Interrupt Disable
	SYSTEM_VBTLVDICR_VBTLVDIE_0 = 0x0
	// VBATT Pin Low Voltage Detect Interrupt Enable
	SYSTEM_VBTLVDICR_VBTLVDIE_1 = 0x1

	// VBTWCTLR: VBATT Wakeup function Control Register
	// Position of Reserved field.
	SYSTEM_VBTWCTLR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_VBTWCTLR_Reserved_Msk = 0xfe
	// Position of VWEN field.
	SYSTEM_VBTWCTLR_VWEN_Pos = 0x0
	// Bit mask of VWEN field.
	SYSTEM_VBTWCTLR_VWEN_Msk = 0x1
	// Bit VWEN.
	SYSTEM_VBTWCTLR_VWEN = 0x1
	// Disable Wakeup function
	SYSTEM_VBTWCTLR_VWEN_0 = 0x0
	// Enable Wakeup function
	SYSTEM_VBTWCTLR_VWEN_1 = 0x1

	// VBTWCH0OTSR: VBATT Wakeup I/O 0 Output Trigger Select Register
	// Position of Reserved field.
	SYSTEM_VBTWCH0OTSR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_VBTWCH0OTSR_Reserved_Msk = 0xe0
	// Position of CH0VRTCATE field.
	SYSTEM_VBTWCH0OTSR_CH0VRTCATE_Pos = 0x4
	// Bit mask of CH0VRTCATE field.
	SYSTEM_VBTWCH0OTSR_CH0VRTCATE_Msk = 0x10
	// Bit CH0VRTCATE.
	SYSTEM_VBTWCH0OTSR_CH0VRTCATE = 0x10
	// VBATT wakeup I/O 0 output trigger by the RTC alarm signal is disabled
	SYSTEM_VBTWCH0OTSR_CH0VRTCATE_0 = 0x0
	// VBATT wakeup I/O 0 output trigger by the RTC alarm signal is enabled.
	SYSTEM_VBTWCH0OTSR_CH0VRTCATE_1 = 0x1
	// Position of CH0VRTCTE field.
	SYSTEM_VBTWCH0OTSR_CH0VRTCTE_Pos = 0x3
	// Bit mask of CH0VRTCTE field.
	SYSTEM_VBTWCH0OTSR_CH0VRTCTE_Msk = 0x8
	// Bit CH0VRTCTE.
	SYSTEM_VBTWCH0OTSR_CH0VRTCTE = 0x8
	// VBATT wakeup I/O 0 output trigger by the RTC periodic signal is disabled
	SYSTEM_VBTWCH0OTSR_CH0VRTCTE_0 = 0x0
	// VBATT wakeup I/O 0 output trigger by the RTC periodic signal is enabled.
	SYSTEM_VBTWCH0OTSR_CH0VRTCTE_1 = 0x1
	// Position of CH0VCH2TE field.
	SYSTEM_VBTWCH0OTSR_CH0VCH2TE_Pos = 0x2
	// Bit mask of CH0VCH2TE field.
	SYSTEM_VBTWCH0OTSR_CH0VCH2TE_Msk = 0x4
	// Bit CH0VCH2TE.
	SYSTEM_VBTWCH0OTSR_CH0VCH2TE = 0x4
	// VBATT wakeup I/O 0 output trigger by the VBATWIO2 pin is disabled
	SYSTEM_VBTWCH0OTSR_CH0VCH2TE_0 = 0x0
	// VBATT wakeup I/O 0 output trigger by the VBATWIO2 pin is enabled.
	SYSTEM_VBTWCH0OTSR_CH0VCH2TE_1 = 0x1
	// Position of CH0VCH1TE field.
	SYSTEM_VBTWCH0OTSR_CH0VCH1TE_Pos = 0x1
	// Bit mask of CH0VCH1TE field.
	SYSTEM_VBTWCH0OTSR_CH0VCH1TE_Msk = 0x2
	// Bit CH0VCH1TE.
	SYSTEM_VBTWCH0OTSR_CH0VCH1TE = 0x2
	// VBATT wakeup I/O 0 output trigger by the VBATWIO1 pin is disabled
	SYSTEM_VBTWCH0OTSR_CH0VCH1TE_0 = 0x0
	// VBATT wakeup I/O 0 output trigger by the VBATWIO1 pin is enabled.
	SYSTEM_VBTWCH0OTSR_CH0VCH1TE_1 = 0x1
	// Position of Reserved field.
	SYSTEM_VBTWCH0OTSR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SYSTEM_VBTWCH0OTSR_Reserved_Msk = 0x1
	// Bit Reserved.
	SYSTEM_VBTWCH0OTSR_Reserved = 0x1

	// VBTWCH1OTSR: VBATT Wakeup I/O 1 Output Trigger Select Register
	// Position of Reserved field.
	SYSTEM_VBTWCH1OTSR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_VBTWCH1OTSR_Reserved_Msk = 0xe0
	// Position of CH1VRTCATE field.
	SYSTEM_VBTWCH1OTSR_CH1VRTCATE_Pos = 0x4
	// Bit mask of CH1VRTCATE field.
	SYSTEM_VBTWCH1OTSR_CH1VRTCATE_Msk = 0x10
	// Bit CH1VRTCATE.
	SYSTEM_VBTWCH1OTSR_CH1VRTCATE = 0x10
	// VBATT wakeup I/O 1 output trigger by the RTC alarm signal is disabled
	SYSTEM_VBTWCH1OTSR_CH1VRTCATE_0 = 0x0
	// VBATT wakeup I/O 1 output trigger by the RTC alarm signal is enabled.
	SYSTEM_VBTWCH1OTSR_CH1VRTCATE_1 = 0x1
	// Position of CH1VRTCTE field.
	SYSTEM_VBTWCH1OTSR_CH1VRTCTE_Pos = 0x3
	// Bit mask of CH1VRTCTE field.
	SYSTEM_VBTWCH1OTSR_CH1VRTCTE_Msk = 0x8
	// Bit CH1VRTCTE.
	SYSTEM_VBTWCH1OTSR_CH1VRTCTE = 0x8
	// VBATT wakeup I/O 1 output trigger by the RTC periodic signal is disabled
	SYSTEM_VBTWCH1OTSR_CH1VRTCTE_0 = 0x0
	// VBATT wakeup I/O 1 output trigger by the RTC periodic signal is enabled
	SYSTEM_VBTWCH1OTSR_CH1VRTCTE_1 = 0x1
	// Position of CH1VCH2TE field.
	SYSTEM_VBTWCH1OTSR_CH1VCH2TE_Pos = 0x2
	// Bit mask of CH1VCH2TE field.
	SYSTEM_VBTWCH1OTSR_CH1VCH2TE_Msk = 0x4
	// Bit CH1VCH2TE.
	SYSTEM_VBTWCH1OTSR_CH1VCH2TE = 0x4
	// VBATT wakeup I/O 1 output trigger by the VBATWIO2 pin is disabled
	SYSTEM_VBTWCH1OTSR_CH1VCH2TE_0 = 0x0
	// VBATT wakeup I/O 1 output trigger by the VBATWIO2 pin is enabled.
	SYSTEM_VBTWCH1OTSR_CH1VCH2TE_1 = 0x1
	// Position of Reserved field.
	SYSTEM_VBTWCH1OTSR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_VBTWCH1OTSR_Reserved_Msk = 0x2
	// Bit Reserved.
	SYSTEM_VBTWCH1OTSR_Reserved = 0x2
	// Position of CH1VCH0TE field.
	SYSTEM_VBTWCH1OTSR_CH1VCH0TE_Pos = 0x0
	// Bit mask of CH1VCH0TE field.
	SYSTEM_VBTWCH1OTSR_CH1VCH0TE_Msk = 0x1
	// Bit CH1VCH0TE.
	SYSTEM_VBTWCH1OTSR_CH1VCH0TE = 0x1
	// VBATT wakeup I/O 1 output trigger by the VBATWIO0 pin is disabled
	SYSTEM_VBTWCH1OTSR_CH1VCH0TE_0 = 0x0
	// VBATT wakeup I/O 1 output trigger by the VBATWIO0 pin is enabled.
	SYSTEM_VBTWCH1OTSR_CH1VCH0TE_1 = 0x1

	// VBTWCH2OTSR: VBATT Wakeup I/O 2 Output Trigger Select Register
	// Position of Reserved field.
	SYSTEM_VBTWCH2OTSR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_VBTWCH2OTSR_Reserved_Msk = 0xe0
	// Position of CH2VRTCATE field.
	SYSTEM_VBTWCH2OTSR_CH2VRTCATE_Pos = 0x4
	// Bit mask of CH2VRTCATE field.
	SYSTEM_VBTWCH2OTSR_CH2VRTCATE_Msk = 0x10
	// Bit CH2VRTCATE.
	SYSTEM_VBTWCH2OTSR_CH2VRTCATE = 0x10
	// VBATT wakeup I/O 2 output trigger by the RTC alarm signal is disabled
	SYSTEM_VBTWCH2OTSR_CH2VRTCATE_0 = 0x0
	// VBATT wakeup I/O 2 output trigger by the RTC alarm signal is enabled.
	SYSTEM_VBTWCH2OTSR_CH2VRTCATE_1 = 0x1
	// Position of CH2VRTCTE field.
	SYSTEM_VBTWCH2OTSR_CH2VRTCTE_Pos = 0x3
	// Bit mask of CH2VRTCTE field.
	SYSTEM_VBTWCH2OTSR_CH2VRTCTE_Msk = 0x8
	// Bit CH2VRTCTE.
	SYSTEM_VBTWCH2OTSR_CH2VRTCTE = 0x8
	// VBATT wakeup I/O 2 output trigger by the RTC periodic signal is disabled
	SYSTEM_VBTWCH2OTSR_CH2VRTCTE_0 = 0x0
	// VBATT wakeup I/O 2 output trigger by the RTC periodic signal is enabled.
	SYSTEM_VBTWCH2OTSR_CH2VRTCTE_1 = 0x1
	// Position of Reserved field.
	SYSTEM_VBTWCH2OTSR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_VBTWCH2OTSR_Reserved_Msk = 0x4
	// Bit Reserved.
	SYSTEM_VBTWCH2OTSR_Reserved = 0x4
	// Position of CH2VCH1TE field.
	SYSTEM_VBTWCH2OTSR_CH2VCH1TE_Pos = 0x1
	// Bit mask of CH2VCH1TE field.
	SYSTEM_VBTWCH2OTSR_CH2VCH1TE_Msk = 0x2
	// Bit CH2VCH1TE.
	SYSTEM_VBTWCH2OTSR_CH2VCH1TE = 0x2
	// VBATT wakeup I/O 2 output trigger by the VBATWIO1 pin is disabled
	SYSTEM_VBTWCH2OTSR_CH2VCH1TE_0 = 0x0
	// VBATT wakeup I/O 2 output trigger by the VBATWIO1 pin is enabled.
	SYSTEM_VBTWCH2OTSR_CH2VCH1TE_1 = 0x1
	// Position of CH2VCH0TE field.
	SYSTEM_VBTWCH2OTSR_CH2VCH0TE_Pos = 0x0
	// Bit mask of CH2VCH0TE field.
	SYSTEM_VBTWCH2OTSR_CH2VCH0TE_Msk = 0x1
	// Bit CH2VCH0TE.
	SYSTEM_VBTWCH2OTSR_CH2VCH0TE = 0x1
	// VBATT wakeup I/O 2 output trigger by the VBATWIO0 pin is disabled
	SYSTEM_VBTWCH2OTSR_CH2VCH0TE_0 = 0x0
	// VBATT wakeup I/O 2 output trigger by the VBATWIO0 pin is enabled.
	SYSTEM_VBTWCH2OTSR_CH2VCH0TE_1 = 0x1

	// VBTICTLR: VBATT Input Control Register
	// Position of Reserved field.
	SYSTEM_VBTICTLR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_VBTICTLR_Reserved_Msk = 0xf8
	// Position of VCH2INEN field.
	SYSTEM_VBTICTLR_VCH2INEN_Pos = 0x2
	// Bit mask of VCH2INEN field.
	SYSTEM_VBTICTLR_VCH2INEN_Msk = 0x4
	// Bit VCH2INEN.
	SYSTEM_VBTICTLR_VCH2INEN = 0x4
	// VBATWIO2 and RTCIC2 inputs disabled
	SYSTEM_VBTICTLR_VCH2INEN_0 = 0x0
	// VBATWIO2 and RTCIC2 inputs enabled.
	SYSTEM_VBTICTLR_VCH2INEN_1 = 0x1
	// Position of VCH1INEN field.
	SYSTEM_VBTICTLR_VCH1INEN_Pos = 0x1
	// Bit mask of VCH1INEN field.
	SYSTEM_VBTICTLR_VCH1INEN_Msk = 0x2
	// Bit VCH1INEN.
	SYSTEM_VBTICTLR_VCH1INEN = 0x2
	// VBATWIO1, RTCIC1 inputs disabled
	SYSTEM_VBTICTLR_VCH1INEN_0 = 0x0
	// VBATWIO1, RTCIC1 inputs enabled.
	SYSTEM_VBTICTLR_VCH1INEN_1 = 0x1
	// Position of VCH0INEN field.
	SYSTEM_VBTICTLR_VCH0INEN_Pos = 0x0
	// Bit mask of VCH0INEN field.
	SYSTEM_VBTICTLR_VCH0INEN_Msk = 0x1
	// Bit VCH0INEN.
	SYSTEM_VBTICTLR_VCH0INEN = 0x1
	// VBATWIO0, RTCIC0 inputs disabled
	SYSTEM_VBTICTLR_VCH0INEN_0 = 0x0
	// VBATWIO0, RTCIC0 inputs enabled.
	SYSTEM_VBTICTLR_VCH0INEN_1 = 0x1

	// VBTOCTLR: VBATT Output Control Register
	// Position of Reserved field.
	SYSTEM_VBTOCTLR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SYSTEM_VBTOCTLR_Reserved_Msk = 0xc0
	// Position of VOUT2LSEL field.
	SYSTEM_VBTOCTLR_VOUT2LSEL_Pos = 0x5
	// Bit mask of VOUT2LSEL field.
	SYSTEM_VBTOCTLR_VOUT2LSEL_Msk = 0x20
	// Bit VOUT2LSEL.
	SYSTEM_VBTOCTLR_VOUT2LSEL = 0x20
	// Output L before VBATT wake up trigger
	SYSTEM_VBTOCTLR_VOUT2LSEL_0 = 0x0
	// Output H before VBATT wake up trigger
	SYSTEM_VBTOCTLR_VOUT2LSEL_1 = 0x1
	// Position of VCOU1LSEL field.
	SYSTEM_VBTOCTLR_VCOU1LSEL_Pos = 0x4
	// Bit mask of VCOU1LSEL field.
	SYSTEM_VBTOCTLR_VCOU1LSEL_Msk = 0x10
	// Bit VCOU1LSEL.
	SYSTEM_VBTOCTLR_VCOU1LSEL = 0x10
	// Output L before VBATT wake up trigger
	SYSTEM_VBTOCTLR_VCOU1LSEL_0 = 0x0
	// Output H before VBATT wake up trigger
	SYSTEM_VBTOCTLR_VCOU1LSEL_1 = 0x1
	// Position of VOUT0LSEL field.
	SYSTEM_VBTOCTLR_VOUT0LSEL_Pos = 0x3
	// Bit mask of VOUT0LSEL field.
	SYSTEM_VBTOCTLR_VOUT0LSEL_Msk = 0x8
	// Bit VOUT0LSEL.
	SYSTEM_VBTOCTLR_VOUT0LSEL = 0x8
	// Output L before VBATT wakeup trigger
	SYSTEM_VBTOCTLR_VOUT0LSEL_0 = 0x0
	// Output H before VBATT wakeup trigger
	SYSTEM_VBTOCTLR_VOUT0LSEL_1 = 0x1
	// Position of VCH2OEN field.
	SYSTEM_VBTOCTLR_VCH2OEN_Pos = 0x2
	// Bit mask of VCH2OEN field.
	SYSTEM_VBTOCTLR_VCH2OEN_Msk = 0x4
	// Bit VCH2OEN.
	SYSTEM_VBTOCTLR_VCH2OEN = 0x4
	// VBATWIO2 output disabled
	SYSTEM_VBTOCTLR_VCH2OEN_0 = 0x0
	// VBATWIO2 output enabled
	SYSTEM_VBTOCTLR_VCH2OEN_1 = 0x1
	// Position of VCH1OEN field.
	SYSTEM_VBTOCTLR_VCH1OEN_Pos = 0x1
	// Bit mask of VCH1OEN field.
	SYSTEM_VBTOCTLR_VCH1OEN_Msk = 0x2
	// Bit VCH1OEN.
	SYSTEM_VBTOCTLR_VCH1OEN = 0x2
	// VBATWIO1 output disabled
	SYSTEM_VBTOCTLR_VCH1OEN_0 = 0x0
	// VBATWIO1 output enabled
	SYSTEM_VBTOCTLR_VCH1OEN_1 = 0x1
	// Position of VCH0OEN field.
	SYSTEM_VBTOCTLR_VCH0OEN_Pos = 0x0
	// Bit mask of VCH0OEN field.
	SYSTEM_VBTOCTLR_VCH0OEN_Msk = 0x1
	// Bit VCH0OEN.
	SYSTEM_VBTOCTLR_VCH0OEN = 0x1
	// VBATWIO0 output disabled
	SYSTEM_VBTOCTLR_VCH0OEN_0 = 0x0
	// VBATWIO0 output enabled
	SYSTEM_VBTOCTLR_VCH0OEN_1 = 0x1

	// VBTWTER: VBATT Wakeup Trigger source Enable Register
	// Position of Reserved field.
	SYSTEM_VBTWTER_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_VBTWTER_Reserved_Msk = 0xe0
	// Position of VRTCAE field.
	SYSTEM_VBTWTER_VRTCAE_Pos = 0x4
	// Bit mask of VRTCAE field.
	SYSTEM_VBTWTER_VRTCAE_Msk = 0x10
	// Bit VRTCAE.
	SYSTEM_VBTWTER_VRTCAE = 0x10
	// VBATT wakeup triggered by RTC alarm signal is disabled
	SYSTEM_VBTWTER_VRTCAE_0 = 0x0
	// VBATT wakeup triggered by RTC alarm signal is enabled.
	SYSTEM_VBTWTER_VRTCAE_1 = 0x1
	// Position of VRTCIE field.
	SYSTEM_VBTWTER_VRTCIE_Pos = 0x3
	// Bit mask of VRTCIE field.
	SYSTEM_VBTWTER_VRTCIE_Msk = 0x8
	// Bit VRTCIE.
	SYSTEM_VBTWTER_VRTCIE = 0x8
	// VBATT wakeup triggered by RTC periodic signal is disabled
	SYSTEM_VBTWTER_VRTCIE_0 = 0x0
	// VBATT wakeup triggered by RTC periodic signal is enabled.
	SYSTEM_VBTWTER_VRTCIE_1 = 0x1
	// Position of VCH2E field.
	SYSTEM_VBTWTER_VCH2E_Pos = 0x2
	// Bit mask of VCH2E field.
	SYSTEM_VBTWTER_VCH2E_Msk = 0x4
	// Bit VCH2E.
	SYSTEM_VBTWTER_VCH2E = 0x4
	// VBATT wakeup triggered by the VBATWIO2 pin is disabled
	SYSTEM_VBTWTER_VCH2E_0 = 0x0
	// VBATT wakeup triggered by the VBATWIO2 pin is enabled.
	SYSTEM_VBTWTER_VCH2E_1 = 0x1
	// Position of VCH1E field.
	SYSTEM_VBTWTER_VCH1E_Pos = 0x1
	// Bit mask of VCH1E field.
	SYSTEM_VBTWTER_VCH1E_Msk = 0x2
	// Bit VCH1E.
	SYSTEM_VBTWTER_VCH1E = 0x2
	// VBATT wakeup triggered by the VBATWIO1 pin is disabled
	SYSTEM_VBTWTER_VCH1E_0 = 0x0
	// VBATT wakeup triggered by the VBATWIO1 pin is enabled.
	SYSTEM_VBTWTER_VCH1E_1 = 0x1
	// Position of VCH0E field.
	SYSTEM_VBTWTER_VCH0E_Pos = 0x0
	// Bit mask of VCH0E field.
	SYSTEM_VBTWTER_VCH0E_Msk = 0x1
	// Bit VCH0E.
	SYSTEM_VBTWTER_VCH0E = 0x1
	// VBATT wakeup triggered by the VBATWIO0 pin is disabled
	SYSTEM_VBTWTER_VCH0E_0 = 0x0
	// VBATT wakeup triggered by the VBATWIO0 pin is enabled.
	SYSTEM_VBTWTER_VCH0E_1 = 0x1

	// VBTWEGR: VBATT Wakeup Trigger source Edge Register
	// Position of Reserved field.
	SYSTEM_VBTWEGR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_VBTWEGR_Reserved_Msk = 0xf8
	// Position of VCH2EG field.
	SYSTEM_VBTWEGR_VCH2EG_Pos = 0x2
	// Bit mask of VCH2EG field.
	SYSTEM_VBTWEGR_VCH2EG_Msk = 0x4
	// Bit VCH2EG.
	SYSTEM_VBTWEGR_VCH2EG = 0x4
	// Wakeup trigger is generated at a falling edge
	SYSTEM_VBTWEGR_VCH2EG_0 = 0x0
	// Wakeup trigger is generated at a rising edge.
	SYSTEM_VBTWEGR_VCH2EG_1 = 0x1
	// Position of VCH1EG field.
	SYSTEM_VBTWEGR_VCH1EG_Pos = 0x1
	// Bit mask of VCH1EG field.
	SYSTEM_VBTWEGR_VCH1EG_Msk = 0x2
	// Bit VCH1EG.
	SYSTEM_VBTWEGR_VCH1EG = 0x2
	// Wakeup trigger is generated at a falling edge
	SYSTEM_VBTWEGR_VCH1EG_0 = 0x0
	// Wakeup trigger is generated at a rising edge.
	SYSTEM_VBTWEGR_VCH1EG_1 = 0x1
	// Position of VCH0EG field.
	SYSTEM_VBTWEGR_VCH0EG_Pos = 0x0
	// Bit mask of VCH0EG field.
	SYSTEM_VBTWEGR_VCH0EG_Msk = 0x1
	// Bit VCH0EG.
	SYSTEM_VBTWEGR_VCH0EG = 0x1
	// Wakeup trigger is generated at a falling edge
	SYSTEM_VBTWEGR_VCH0EG_0 = 0x0
	// Wakeup trigger is generated at a rising edge.
	SYSTEM_VBTWEGR_VCH0EG_1 = 0x1

	// VBTWFR: VBATT Wakeup trigger source Flag Register
	// Position of Reserved field.
	SYSTEM_VBTWFR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_VBTWFR_Reserved_Msk = 0xe0
	// Position of VRTCAF field.
	SYSTEM_VBTWFR_VRTCAF_Pos = 0x4
	// Bit mask of VRTCAF field.
	SYSTEM_VBTWFR_VRTCAF_Msk = 0x10
	// Bit VRTCAF.
	SYSTEM_VBTWFR_VRTCAF = 0x10
	// No wakeup trigger by the RTC alarm is generated
	SYSTEM_VBTWFR_VRTCAF_0 = 0x0
	// A wakeup trigger by the RTC alarm is generated
	SYSTEM_VBTWFR_VRTCAF_1 = 0x1
	// Position of VRTCIF field.
	SYSTEM_VBTWFR_VRTCIF_Pos = 0x3
	// Bit mask of VRTCIF field.
	SYSTEM_VBTWFR_VRTCIF_Msk = 0x8
	// Bit VRTCIF.
	SYSTEM_VBTWFR_VRTCIF = 0x8
	// No wakeup trigger by the RTC interval is generated
	SYSTEM_VBTWFR_VRTCIF_0 = 0x0
	// A wakeup trigger by the RTC interval is generated
	SYSTEM_VBTWFR_VRTCIF_1 = 0x1
	// Position of VCH2F field.
	SYSTEM_VBTWFR_VCH2F_Pos = 0x2
	// Bit mask of VCH2F field.
	SYSTEM_VBTWFR_VCH2F_Msk = 0x4
	// Bit VCH2F.
	SYSTEM_VBTWFR_VCH2F = 0x4
	// No wakeup trigger by the VBATWIO2 pin is generated
	SYSTEM_VBTWFR_VCH2F_0 = 0x0
	// A wakeup trigger by the VBATWIO2 pin is generated
	SYSTEM_VBTWFR_VCH2F_1 = 0x1
	// Position of VCH1F field.
	SYSTEM_VBTWFR_VCH1F_Pos = 0x1
	// Bit mask of VCH1F field.
	SYSTEM_VBTWFR_VCH1F_Msk = 0x2
	// Bit VCH1F.
	SYSTEM_VBTWFR_VCH1F = 0x2
	// No wakeup trigger by the VBATWIO1 pin is generated
	SYSTEM_VBTWFR_VCH1F_0 = 0x0
	// A wakeup trigger by the VBATWIO1 pin is generated
	SYSTEM_VBTWFR_VCH1F_1 = 0x1
	// Position of VCH0F field.
	SYSTEM_VBTWFR_VCH0F_Pos = 0x0
	// Bit mask of VCH0F field.
	SYSTEM_VBTWFR_VCH0F_Msk = 0x1
	// Bit VCH0F.
	SYSTEM_VBTWFR_VCH0F = 0x1
	// No wakeup trigger by the VBATWIO0 pin is generated
	SYSTEM_VBTWFR_VCH0F_0 = 0x0
	// A wakeup trigger by the VBATWIO0 pin is generated
	SYSTEM_VBTWFR_VCH0F_1 = 0x1

	// VBTBKR: VBATT Backup Register [%s]
	// Position of VBTBKR field.
	SYSTEM_VBTBKR_VBTBKR_Pos = 0x0
	// Bit mask of VBTBKR field.
	SYSTEM_VBTBKR_VBTBKR_Msk = 0xff
)

// Constants for MSTP: Module Stop Control B,C,D
const (
	// MSTPCRB: Module Stop Control Register B
	// Position of MSTPB31 field.
	MSTP_MSTPCRB_MSTPB31_Pos = 0x1f
	// Bit mask of MSTPB31 field.
	MSTP_MSTPCRB_MSTPB31_Msk = 0x80000000
	// Bit MSTPB31.
	MSTP_MSTPCRB_MSTPB31 = 0x80000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB31_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB31_1 = 0x1
	// Position of MSTPB30 field.
	MSTP_MSTPCRB_MSTPB30_Pos = 0x1e
	// Bit mask of MSTPB30 field.
	MSTP_MSTPCRB_MSTPB30_Msk = 0x40000000
	// Bit MSTPB30.
	MSTP_MSTPCRB_MSTPB30 = 0x40000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB30_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB30_1 = 0x1
	// Position of MSTPB29 field.
	MSTP_MSTPCRB_MSTPB29_Pos = 0x1d
	// Bit mask of MSTPB29 field.
	MSTP_MSTPCRB_MSTPB29_Msk = 0x20000000
	// Bit MSTPB29.
	MSTP_MSTPCRB_MSTPB29 = 0x20000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB29_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB29_1 = 0x1
	// Position of MSTPB28 field.
	MSTP_MSTPCRB_MSTPB28_Pos = 0x1c
	// Bit mask of MSTPB28 field.
	MSTP_MSTPCRB_MSTPB28_Msk = 0x10000000
	// Bit MSTPB28.
	MSTP_MSTPCRB_MSTPB28 = 0x10000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB28_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB28_1 = 0x1
	// Position of MSTPB27 field.
	MSTP_MSTPCRB_MSTPB27_Pos = 0x1b
	// Bit mask of MSTPB27 field.
	MSTP_MSTPCRB_MSTPB27_Msk = 0x8000000
	// Bit MSTPB27.
	MSTP_MSTPCRB_MSTPB27 = 0x8000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB27_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB27_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRB_Reserved_Pos = 0x17
	// Bit mask of Reserved field.
	MSTP_MSTPCRB_Reserved_Msk = 0x7800000
	// Position of MSTPB22 field.
	MSTP_MSTPCRB_MSTPB22_Pos = 0x16
	// Bit mask of MSTPB22 field.
	MSTP_MSTPCRB_MSTPB22_Msk = 0x400000
	// Bit MSTPB22.
	MSTP_MSTPCRB_MSTPB22 = 0x400000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB22_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB22_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRB_Reserved_Pos = 0x14
	// Bit mask of Reserved field.
	MSTP_MSTPCRB_Reserved_Msk = 0x300000
	// Position of MSTPB19 field.
	MSTP_MSTPCRB_MSTPB19_Pos = 0x13
	// Bit mask of MSTPB19 field.
	MSTP_MSTPCRB_MSTPB19_Msk = 0x80000
	// Bit MSTPB19.
	MSTP_MSTPCRB_MSTPB19 = 0x80000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB19_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB19_1 = 0x1
	// Position of MSTPB18 field.
	MSTP_MSTPCRB_MSTPB18_Pos = 0x12
	// Bit mask of MSTPB18 field.
	MSTP_MSTPCRB_MSTPB18_Msk = 0x40000
	// Bit MSTPB18.
	MSTP_MSTPCRB_MSTPB18 = 0x40000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB18_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB18_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRB_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	MSTP_MSTPCRB_Reserved_Msk = 0x3f000
	// Position of MSTPB11 field.
	MSTP_MSTPCRB_MSTPB11_Pos = 0xb
	// Bit mask of MSTPB11 field.
	MSTP_MSTPCRB_MSTPB11_Msk = 0x800
	// Bit MSTPB11.
	MSTP_MSTPCRB_MSTPB11 = 0x800
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB11_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB11_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRB_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	MSTP_MSTPCRB_Reserved_Msk = 0x400
	// Bit Reserved.
	MSTP_MSTPCRB_Reserved = 0x400
	// Position of MSTPB9 field.
	MSTP_MSTPCRB_MSTPB9_Pos = 0x9
	// Bit mask of MSTPB9 field.
	MSTP_MSTPCRB_MSTPB9_Msk = 0x200
	// Bit MSTPB9.
	MSTP_MSTPCRB_MSTPB9 = 0x200
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB9_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB9_1 = 0x1
	// Position of MSTPB8 field.
	MSTP_MSTPCRB_MSTPB8_Pos = 0x8
	// Bit mask of MSTPB8 field.
	MSTP_MSTPCRB_MSTPB8_Msk = 0x100
	// Bit MSTPB8.
	MSTP_MSTPCRB_MSTPB8 = 0x100
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB8_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB8_1 = 0x1
	// Position of MSTPB7 field.
	MSTP_MSTPCRB_MSTPB7_Pos = 0x7
	// Bit mask of MSTPB7 field.
	MSTP_MSTPCRB_MSTPB7_Msk = 0x80
	// Bit MSTPB7.
	MSTP_MSTPCRB_MSTPB7 = 0x80
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB7_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB7_1 = 0x1
	// Position of MSTPB6 field.
	MSTP_MSTPCRB_MSTPB6_Pos = 0x6
	// Bit mask of MSTPB6 field.
	MSTP_MSTPCRB_MSTPB6_Msk = 0x40
	// Bit MSTPB6.
	MSTP_MSTPCRB_MSTPB6 = 0x40
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB6_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB6_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRB_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	MSTP_MSTPCRB_Reserved_Msk = 0x38
	// Position of MSTPB2 field.
	MSTP_MSTPCRB_MSTPB2_Pos = 0x2
	// Bit mask of MSTPB2 field.
	MSTP_MSTPCRB_MSTPB2_Msk = 0x4
	// Bit MSTPB2.
	MSTP_MSTPCRB_MSTPB2 = 0x4
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB2_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB2_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRB_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	MSTP_MSTPCRB_Reserved_Msk = 0x3

	// MSTPCRC: Module Stop Control Register C
	// Position of MSTPC31 field.
	MSTP_MSTPCRC_MSTPC31_Pos = 0x1f
	// Bit mask of MSTPC31 field.
	MSTP_MSTPCRC_MSTPC31_Msk = 0x80000000
	// Bit MSTPC31.
	MSTP_MSTPCRC_MSTPC31 = 0x80000000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC31_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC31_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRC_Reserved_Pos = 0xf
	// Bit mask of Reserved field.
	MSTP_MSTPCRC_Reserved_Msk = 0x7fff8000
	// Position of MSTPC14 field.
	MSTP_MSTPCRC_MSTPC14_Pos = 0xe
	// Bit mask of MSTPC14 field.
	MSTP_MSTPCRC_MSTPC14_Msk = 0x4000
	// Bit MSTPC14.
	MSTP_MSTPCRC_MSTPC14 = 0x4000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC14_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC14_1 = 0x1
	// Position of MSTPC13 field.
	MSTP_MSTPCRC_MSTPC13_Pos = 0xd
	// Bit mask of MSTPC13 field.
	MSTP_MSTPCRC_MSTPC13_Msk = 0x2000
	// Bit MSTPC13.
	MSTP_MSTPCRC_MSTPC13 = 0x2000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC13_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC13_1 = 0x1
	// Position of MSTPC12 field.
	MSTP_MSTPCRC_MSTPC12_Pos = 0xc
	// Bit mask of MSTPC12 field.
	MSTP_MSTPCRC_MSTPC12_Msk = 0x1000
	// Bit MSTPC12.
	MSTP_MSTPCRC_MSTPC12 = 0x1000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC12_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC12_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRC_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	MSTP_MSTPCRC_Reserved_Msk = 0xe00
	// Position of MSTPC8 field.
	MSTP_MSTPCRC_MSTPC8_Pos = 0x8
	// Bit mask of MSTPC8 field.
	MSTP_MSTPCRC_MSTPC8_Msk = 0x100
	// Bit MSTPC8.
	MSTP_MSTPCRC_MSTPC8 = 0x100
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC8_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC8_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRC_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	MSTP_MSTPCRC_Reserved_Msk = 0xe0
	// Position of MSTPC4 field.
	MSTP_MSTPCRC_MSTPC4_Pos = 0x4
	// Bit mask of MSTPC4 field.
	MSTP_MSTPCRC_MSTPC4_Msk = 0x10
	// Bit MSTPC4.
	MSTP_MSTPCRC_MSTPC4 = 0x10
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC4_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC4_1 = 0x1
	// Position of MSTPC3 field.
	MSTP_MSTPCRC_MSTPC3_Pos = 0x3
	// Bit mask of MSTPC3 field.
	MSTP_MSTPCRC_MSTPC3_Msk = 0x8
	// Bit MSTPC3.
	MSTP_MSTPCRC_MSTPC3 = 0x8
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC3_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC3_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRC_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	MSTP_MSTPCRC_Reserved_Msk = 0x4
	// Bit Reserved.
	MSTP_MSTPCRC_Reserved = 0x4
	// Position of MSTPC1 field.
	MSTP_MSTPCRC_MSTPC1_Pos = 0x1
	// Bit mask of MSTPC1 field.
	MSTP_MSTPCRC_MSTPC1_Msk = 0x2
	// Bit MSTPC1.
	MSTP_MSTPCRC_MSTPC1 = 0x2
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC1_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC1_1 = 0x1
	// Position of MSTPC0 field.
	MSTP_MSTPCRC_MSTPC0_Pos = 0x0
	// Bit mask of MSTPC0 field.
	MSTP_MSTPCRC_MSTPC0_Msk = 0x1
	// Bit MSTPC0.
	MSTP_MSTPCRC_MSTPC0 = 0x1
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC0_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC0_1 = 0x1

	// MSTPCRD: Module Stop Control Register D
	// Position of MSTPD31 field.
	MSTP_MSTPCRD_MSTPD31_Pos = 0x1f
	// Bit mask of MSTPD31 field.
	MSTP_MSTPCRD_MSTPD31_Msk = 0x80000000
	// Bit MSTPD31.
	MSTP_MSTPCRD_MSTPD31 = 0x80000000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD31_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD31_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0x1e
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0x40000000
	// Bit Reserved.
	MSTP_MSTPCRD_Reserved = 0x40000000
	// Position of MSTPD29 field.
	MSTP_MSTPCRD_MSTPD29_Pos = 0x1d
	// Bit mask of MSTPD29 field.
	MSTP_MSTPCRD_MSTPD29_Msk = 0x20000000
	// Bit MSTPD29.
	MSTP_MSTPCRD_MSTPD29 = 0x20000000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD29_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD29_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0x15
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0x1fe00000
	// Position of MSTPD20 field.
	MSTP_MSTPCRD_MSTPD20_Pos = 0x14
	// Bit mask of MSTPD20 field.
	MSTP_MSTPCRD_MSTPD20_Msk = 0x100000
	// Bit MSTPD20.
	MSTP_MSTPCRD_MSTPD20 = 0x100000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD20_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD20_1 = 0x1
	// Position of MSTPD19 field.
	MSTP_MSTPCRD_MSTPD19_Pos = 0x13
	// Bit mask of MSTPD19 field.
	MSTP_MSTPCRD_MSTPD19_Msk = 0x80000
	// Bit MSTPD19.
	MSTP_MSTPCRD_MSTPD19 = 0x80000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD19_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD19_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0x11
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0x60000
	// Position of MSTPD16 field.
	MSTP_MSTPCRD_MSTPD16_Pos = 0x10
	// Bit mask of MSTPD16 field.
	MSTP_MSTPCRD_MSTPD16_Msk = 0x10000
	// Bit MSTPD16.
	MSTP_MSTPCRD_MSTPD16 = 0x10000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD16_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD16_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0xf
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0x8000
	// Bit Reserved.
	MSTP_MSTPCRD_Reserved = 0x8000
	// Position of MSTPD14 field.
	MSTP_MSTPCRD_MSTPD14_Pos = 0xe
	// Bit mask of MSTPD14 field.
	MSTP_MSTPCRD_MSTPD14_Msk = 0x4000
	// Bit MSTPD14.
	MSTP_MSTPCRD_MSTPD14 = 0x4000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD14_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD14_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0x3f80
	// Position of MSTPD6 field.
	MSTP_MSTPCRD_MSTPD6_Pos = 0x6
	// Bit mask of MSTPD6 field.
	MSTP_MSTPCRD_MSTPD6_Msk = 0x40
	// Bit MSTPD6.
	MSTP_MSTPCRD_MSTPD6 = 0x40
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD6_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD6_1 = 0x1
	// Position of MSTPD5 field.
	MSTP_MSTPCRD_MSTPD5_Pos = 0x5
	// Bit mask of MSTPD5 field.
	MSTP_MSTPCRD_MSTPD5_Msk = 0x20
	// Bit MSTPD5.
	MSTP_MSTPCRD_MSTPD5 = 0x20
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD5_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD5_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0x10
	// Bit Reserved.
	MSTP_MSTPCRD_Reserved = 0x10
	// Position of MSTPD3 field.
	MSTP_MSTPCRD_MSTPD3_Pos = 0x3
	// Bit mask of MSTPD3 field.
	MSTP_MSTPCRD_MSTPD3_Msk = 0x8
	// Bit MSTPD3.
	MSTP_MSTPCRD_MSTPD3 = 0x8
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD3_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD3_1 = 0x1
	// Position of MSTPD2 field.
	MSTP_MSTPCRD_MSTPD2_Pos = 0x2
	// Bit mask of MSTPD2 field.
	MSTP_MSTPCRD_MSTPD2_Msk = 0x4
	// Bit MSTPD2.
	MSTP_MSTPCRD_MSTPD2 = 0x4
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD2_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD2_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0x3
)

// Constants for FCACHE: Flash Cache
const (
	// FCACHEE: Flash Cache Enable Register
	// Position of Reserved field.
	FCACHE_FCACHEE_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	FCACHE_FCACHEE_Reserved_Msk = 0xfffe
	// Position of FCACHEEN field.
	FCACHE_FCACHEE_FCACHEEN_Pos = 0x0
	// Bit mask of FCACHEEN field.
	FCACHE_FCACHEE_FCACHEEN_Msk = 0x1
	// Bit FCACHEEN.
	FCACHE_FCACHEE_FCACHEEN = 0x1
	// FCACHE is disabled
	FCACHE_FCACHEE_FCACHEEN_0 = 0x0
	// FCACHE is enabled
	FCACHE_FCACHEE_FCACHEEN_1 = 0x1

	// FCACHEIV: Flash Cache Invalidate Register
	// Position of Reserved field.
	FCACHE_FCACHEIV_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	FCACHE_FCACHEIV_Reserved_Msk = 0xfffe
	// Position of FCACHEIV field.
	FCACHE_FCACHEIV_FCACHEIV_Pos = 0x0
	// Bit mask of FCACHEIV field.
	FCACHE_FCACHEIV_FCACHEIV_Msk = 0x1
	// Bit FCACHEIV.
	FCACHE_FCACHEIV_FCACHEIV = 0x1
	// (Read)not in progress / (Write) no effect.
	FCACHE_FCACHEIV_FCACHEIV_0 = 0x0
	// (Read)in progress /(Write) Starting Cache Invalidation
	FCACHE_FCACHEIV_FCACHEIV_1 = 0x1

	// FLWT: Flash Wait Cycle Register
	// Position of Reserved field.
	FCACHE_FLWT_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	FCACHE_FLWT_Reserved_Msk = 0xf8
	// Position of FLWT field.
	FCACHE_FLWT_FLWT_Pos = 0x0
	// Bit mask of FLWT field.
	FCACHE_FLWT_FLWT_Msk = 0x7
	// zero wait
	FCACHE_FLWT_FLWT_000 = 0x0
)

// Constants for ICU: Interrupt Controller
const (
	// IRQCR0: IRQ Control Register %s
	// Position of FLTEN field.
	ICU_IRQCR_FLTEN_Pos = 0x7
	// Bit mask of FLTEN field.
	ICU_IRQCR_FLTEN_Msk = 0x80
	// Bit FLTEN.
	ICU_IRQCR_FLTEN = 0x80
	// Digital filter disabled.
	ICU_IRQCR_FLTEN_0 = 0x0
	// Digital filter enabled.
	ICU_IRQCR_FLTEN_1 = 0x1
	// Position of Reserved field.
	ICU_IRQCR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ICU_IRQCR_Reserved_Msk = 0x40
	// Bit Reserved.
	ICU_IRQCR_Reserved = 0x40
	// Position of FCLKSEL field.
	ICU_IRQCR_FCLKSEL_Pos = 0x4
	// Bit mask of FCLKSEL field.
	ICU_IRQCR_FCLKSEL_Msk = 0x30
	// PCLKB
	ICU_IRQCR_FCLKSEL_00 = 0x0
	// PCLKB/8
	ICU_IRQCR_FCLKSEL_01 = 0x1
	// PCLKB/32
	ICU_IRQCR_FCLKSEL_10 = 0x2
	// PCLKB/64
	ICU_IRQCR_FCLKSEL_11 = 0x3
	// Position of Reserved field.
	ICU_IRQCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ICU_IRQCR_Reserved_Msk = 0xc
	// Position of IRQMD field.
	ICU_IRQCR_IRQMD_Pos = 0x0
	// Bit mask of IRQMD field.
	ICU_IRQCR_IRQMD_Msk = 0x3
	// Falling edge
	ICU_IRQCR_IRQMD_00 = 0x0
	// Rising edge
	ICU_IRQCR_IRQMD_01 = 0x1
	// Rising and falling edges
	ICU_IRQCR_IRQMD_10 = 0x2
	// Low level
	ICU_IRQCR_IRQMD_11 = 0x3

	// NMICR: NMI Pin Interrupt Control Register
	// Position of NFLTEN field.
	ICU_NMICR_NFLTEN_Pos = 0x7
	// Bit mask of NFLTEN field.
	ICU_NMICR_NFLTEN_Msk = 0x80
	// Bit NFLTEN.
	ICU_NMICR_NFLTEN = 0x80
	// Digital filter is disabled.
	ICU_NMICR_NFLTEN_0 = 0x0
	// Digital filter is enabled.
	ICU_NMICR_NFLTEN_1 = 0x1
	// Position of Reserved field.
	ICU_NMICR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ICU_NMICR_Reserved_Msk = 0x40
	// Bit Reserved.
	ICU_NMICR_Reserved = 0x40
	// Position of NFCLKSEL field.
	ICU_NMICR_NFCLKSEL_Pos = 0x4
	// Bit mask of NFCLKSEL field.
	ICU_NMICR_NFCLKSEL_Msk = 0x30
	// PCLKB
	ICU_NMICR_NFCLKSEL_00 = 0x0
	// PCLKB/8
	ICU_NMICR_NFCLKSEL_01 = 0x1
	// PCLKB/32
	ICU_NMICR_NFCLKSEL_10 = 0x2
	// PCLKB/64
	ICU_NMICR_NFCLKSEL_11 = 0x3
	// Position of Reserved field.
	ICU_NMICR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	ICU_NMICR_Reserved_Msk = 0xe
	// Position of NMIMD field.
	ICU_NMICR_NMIMD_Pos = 0x0
	// Bit mask of NMIMD field.
	ICU_NMICR_NMIMD_Msk = 0x1
	// Bit NMIMD.
	ICU_NMICR_NMIMD = 0x1
	// Falling edge
	ICU_NMICR_NMIMD_0 = 0x0
	// Rising edge
	ICU_NMICR_NMIMD_1 = 0x1

	// NMIER: Non-Maskable Interrupt Enable Register
	// Position of Reserved field.
	ICU_NMIER_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	ICU_NMIER_Reserved_Msk = 0xe000
	// Position of SPEEN field.
	ICU_NMIER_SPEEN_Pos = 0xc
	// Bit mask of SPEEN field.
	ICU_NMIER_SPEEN_Msk = 0x1000
	// Bit SPEEN.
	ICU_NMIER_SPEEN = 0x1000
	// Disabled
	ICU_NMIER_SPEEN_0 = 0x0
	// Enabled.
	ICU_NMIER_SPEEN_1 = 0x1
	// Position of BUSMEN field.
	ICU_NMIER_BUSMEN_Pos = 0xb
	// Bit mask of BUSMEN field.
	ICU_NMIER_BUSMEN_Msk = 0x800
	// Bit BUSMEN.
	ICU_NMIER_BUSMEN = 0x800
	// Disabled
	ICU_NMIER_BUSMEN_0 = 0x0
	// Enabled.
	ICU_NMIER_BUSMEN_1 = 0x1
	// Position of BUSSEN field.
	ICU_NMIER_BUSSEN_Pos = 0xa
	// Bit mask of BUSSEN field.
	ICU_NMIER_BUSSEN_Msk = 0x400
	// Bit BUSSEN.
	ICU_NMIER_BUSSEN = 0x400
	// Disabled
	ICU_NMIER_BUSSEN_0 = 0x0
	// Enabled.
	ICU_NMIER_BUSSEN_1 = 0x1
	// Position of RECCEN field.
	ICU_NMIER_RECCEN_Pos = 0x9
	// Bit mask of RECCEN field.
	ICU_NMIER_RECCEN_Msk = 0x200
	// Bit RECCEN.
	ICU_NMIER_RECCEN = 0x200
	// Disabled
	ICU_NMIER_RECCEN_0 = 0x0
	// Enabled.
	ICU_NMIER_RECCEN_1 = 0x1
	// Position of RPEEN field.
	ICU_NMIER_RPEEN_Pos = 0x8
	// Bit mask of RPEEN field.
	ICU_NMIER_RPEEN_Msk = 0x100
	// Bit RPEEN.
	ICU_NMIER_RPEEN = 0x100
	// Disabled
	ICU_NMIER_RPEEN_0 = 0x0
	// Enabled.
	ICU_NMIER_RPEEN_1 = 0x1
	// Position of NMIEN field.
	ICU_NMIER_NMIEN_Pos = 0x7
	// Bit mask of NMIEN field.
	ICU_NMIER_NMIEN_Msk = 0x80
	// Bit NMIEN.
	ICU_NMIER_NMIEN = 0x80
	// Disabled
	ICU_NMIER_NMIEN_0 = 0x0
	// Enabled.
	ICU_NMIER_NMIEN_1 = 0x1
	// Position of OSTEN field.
	ICU_NMIER_OSTEN_Pos = 0x6
	// Bit mask of OSTEN field.
	ICU_NMIER_OSTEN_Msk = 0x40
	// Bit OSTEN.
	ICU_NMIER_OSTEN = 0x40
	// Disabled
	ICU_NMIER_OSTEN_0 = 0x0
	// Enabled.
	ICU_NMIER_OSTEN_1 = 0x1
	// Position of Reserved field.
	ICU_NMIER_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	ICU_NMIER_Reserved_Msk = 0x20
	// Bit Reserved.
	ICU_NMIER_Reserved = 0x20
	// Position of VBATTEN field.
	ICU_NMIER_VBATTEN_Pos = 0x4
	// Bit mask of VBATTEN field.
	ICU_NMIER_VBATTEN_Msk = 0x10
	// Bit VBATTEN.
	ICU_NMIER_VBATTEN = 0x10
	// Disabled
	ICU_NMIER_VBATTEN_0 = 0x0
	// Enabled.
	ICU_NMIER_VBATTEN_1 = 0x1
	// Position of LVD2EN field.
	ICU_NMIER_LVD2EN_Pos = 0x3
	// Bit mask of LVD2EN field.
	ICU_NMIER_LVD2EN_Msk = 0x8
	// Bit LVD2EN.
	ICU_NMIER_LVD2EN = 0x8
	// Disabled
	ICU_NMIER_LVD2EN_0 = 0x0
	// Enabled.
	ICU_NMIER_LVD2EN_1 = 0x1
	// Position of LVD1EN field.
	ICU_NMIER_LVD1EN_Pos = 0x2
	// Bit mask of LVD1EN field.
	ICU_NMIER_LVD1EN_Msk = 0x4
	// Bit LVD1EN.
	ICU_NMIER_LVD1EN = 0x4
	// Disabled
	ICU_NMIER_LVD1EN_0 = 0x0
	// Enabled.
	ICU_NMIER_LVD1EN_1 = 0x1
	// Position of WDTEN field.
	ICU_NMIER_WDTEN_Pos = 0x1
	// Bit mask of WDTEN field.
	ICU_NMIER_WDTEN_Msk = 0x2
	// Bit WDTEN.
	ICU_NMIER_WDTEN = 0x2
	// Disabled
	ICU_NMIER_WDTEN_0 = 0x0
	// Enabled.
	ICU_NMIER_WDTEN_1 = 0x1
	// Position of IWDTEN field.
	ICU_NMIER_IWDTEN_Pos = 0x0
	// Bit mask of IWDTEN field.
	ICU_NMIER_IWDTEN_Msk = 0x1
	// Bit IWDTEN.
	ICU_NMIER_IWDTEN = 0x1
	// Disabled
	ICU_NMIER_IWDTEN_0 = 0x0
	// Enabled.
	ICU_NMIER_IWDTEN_1 = 0x1

	// NMICLR: Non-Maskable Interrupt Status Clear Register
	// Position of Reserved field.
	ICU_NMICLR_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	ICU_NMICLR_Reserved_Msk = 0xe000
	// Position of SPECLR field.
	ICU_NMICLR_SPECLR_Pos = 0xc
	// Bit mask of SPECLR field.
	ICU_NMICLR_SPECLR_Msk = 0x1000
	// Bit SPECLR.
	ICU_NMICLR_SPECLR = 0x1000
	// No effect.
	ICU_NMICLR_SPECLR_0 = 0x0
	// Clear the NMISR.SPEST flag.
	ICU_NMICLR_SPECLR_1 = 0x1
	// Position of BUSMCLR field.
	ICU_NMICLR_BUSMCLR_Pos = 0xb
	// Bit mask of BUSMCLR field.
	ICU_NMICLR_BUSMCLR_Msk = 0x800
	// Bit BUSMCLR.
	ICU_NMICLR_BUSMCLR = 0x800
	// No effect.
	ICU_NMICLR_BUSMCLR_0 = 0x0
	// Clear the NMISR.BUSMST flag.
	ICU_NMICLR_BUSMCLR_1 = 0x1
	// Position of BUSSCLR field.
	ICU_NMICLR_BUSSCLR_Pos = 0xa
	// Bit mask of BUSSCLR field.
	ICU_NMICLR_BUSSCLR_Msk = 0x400
	// Bit BUSSCLR.
	ICU_NMICLR_BUSSCLR = 0x400
	// No effect.
	ICU_NMICLR_BUSSCLR_0 = 0x0
	// Clear the NMISR.BUSSST flag.
	ICU_NMICLR_BUSSCLR_1 = 0x1
	// Position of RECCCLR field.
	ICU_NMICLR_RECCCLR_Pos = 0x9
	// Bit mask of RECCCLR field.
	ICU_NMICLR_RECCCLR_Msk = 0x200
	// Bit RECCCLR.
	ICU_NMICLR_RECCCLR = 0x200
	// No effect.
	ICU_NMICLR_RECCCLR_0 = 0x0
	// Clear the NMISR.RECCST flag.
	ICU_NMICLR_RECCCLR_1 = 0x1
	// Position of RPECLR field.
	ICU_NMICLR_RPECLR_Pos = 0x8
	// Bit mask of RPECLR field.
	ICU_NMICLR_RPECLR_Msk = 0x100
	// Bit RPECLR.
	ICU_NMICLR_RPECLR = 0x100
	// No effect.
	ICU_NMICLR_RPECLR_0 = 0x0
	// Clear the NMISR.RPEST flag.
	ICU_NMICLR_RPECLR_1 = 0x1
	// Position of NMICLR field.
	ICU_NMICLR_NMICLR_Pos = 0x7
	// Bit mask of NMICLR field.
	ICU_NMICLR_NMICLR_Msk = 0x80
	// Bit NMICLR.
	ICU_NMICLR_NMICLR = 0x80
	// No effect.
	ICU_NMICLR_NMICLR_0 = 0x0
	// Clear the NMISR.NMIST flag.
	ICU_NMICLR_NMICLR_1 = 0x1
	// Position of OSTCLR field.
	ICU_NMICLR_OSTCLR_Pos = 0x6
	// Bit mask of OSTCLR field.
	ICU_NMICLR_OSTCLR_Msk = 0x40
	// Bit OSTCLR.
	ICU_NMICLR_OSTCLR = 0x40
	// No effect.
	ICU_NMICLR_OSTCLR_0 = 0x0
	// Clear the NMISR.OSTST flag.
	ICU_NMICLR_OSTCLR_1 = 0x1
	// Position of Reserved field.
	ICU_NMICLR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	ICU_NMICLR_Reserved_Msk = 0x20
	// Bit Reserved.
	ICU_NMICLR_Reserved = 0x20
	// Position of VBATTCLR field.
	ICU_NMICLR_VBATTCLR_Pos = 0x4
	// Bit mask of VBATTCLR field.
	ICU_NMICLR_VBATTCLR_Msk = 0x10
	// Bit VBATTCLR.
	ICU_NMICLR_VBATTCLR = 0x10
	// No effect.
	ICU_NMICLR_VBATTCLR_0 = 0x0
	// Clear the NMISR.VBATTST flag.
	ICU_NMICLR_VBATTCLR_1 = 0x1
	// Position of LVD2CLR field.
	ICU_NMICLR_LVD2CLR_Pos = 0x3
	// Bit mask of LVD2CLR field.
	ICU_NMICLR_LVD2CLR_Msk = 0x8
	// Bit LVD2CLR.
	ICU_NMICLR_LVD2CLR = 0x8
	// No effect.
	ICU_NMICLR_LVD2CLR_0 = 0x0
	// Clear the NMISR.LVD2ST flag.
	ICU_NMICLR_LVD2CLR_1 = 0x1
	// Position of LVD1CLR field.
	ICU_NMICLR_LVD1CLR_Pos = 0x2
	// Bit mask of LVD1CLR field.
	ICU_NMICLR_LVD1CLR_Msk = 0x4
	// Bit LVD1CLR.
	ICU_NMICLR_LVD1CLR = 0x4
	// No effect.
	ICU_NMICLR_LVD1CLR_0 = 0x0
	// Clear the NMISR.LVD1ST flag.
	ICU_NMICLR_LVD1CLR_1 = 0x1
	// Position of WDTCLR field.
	ICU_NMICLR_WDTCLR_Pos = 0x1
	// Bit mask of WDTCLR field.
	ICU_NMICLR_WDTCLR_Msk = 0x2
	// Bit WDTCLR.
	ICU_NMICLR_WDTCLR = 0x2
	// No effect.
	ICU_NMICLR_WDTCLR_0 = 0x0
	// Clear the NMISR.WDTST flag.
	ICU_NMICLR_WDTCLR_1 = 0x1
	// Position of IWDTCLR field.
	ICU_NMICLR_IWDTCLR_Pos = 0x0
	// Bit mask of IWDTCLR field.
	ICU_NMICLR_IWDTCLR_Msk = 0x1
	// Bit IWDTCLR.
	ICU_NMICLR_IWDTCLR = 0x1
	// No effect.
	ICU_NMICLR_IWDTCLR_0 = 0x0
	// Clear the NMISR.IWDTST flag.
	ICU_NMICLR_IWDTCLR_1 = 0x1

	// NMISR: Non-Maskable Interrupt Status Register
	// Position of Reserved field.
	ICU_NMISR_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	ICU_NMISR_Reserved_Msk = 0xe000
	// Position of SPEST field.
	ICU_NMISR_SPEST_Pos = 0xc
	// Bit mask of SPEST field.
	ICU_NMISR_SPEST_Msk = 0x1000
	// Bit SPEST.
	ICU_NMISR_SPEST = 0x1000
	// Interrupt not requested
	ICU_NMISR_SPEST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_SPEST_1 = 0x1
	// Position of BUSMST field.
	ICU_NMISR_BUSMST_Pos = 0xb
	// Bit mask of BUSMST field.
	ICU_NMISR_BUSMST_Msk = 0x800
	// Bit BUSMST.
	ICU_NMISR_BUSMST = 0x800
	// Interrupt not requested
	ICU_NMISR_BUSMST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_BUSMST_1 = 0x1
	// Position of BUSSST field.
	ICU_NMISR_BUSSST_Pos = 0xa
	// Bit mask of BUSSST field.
	ICU_NMISR_BUSSST_Msk = 0x400
	// Bit BUSSST.
	ICU_NMISR_BUSSST = 0x400
	// Interrupt not requested
	ICU_NMISR_BUSSST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_BUSSST_1 = 0x1
	// Position of RECCST field.
	ICU_NMISR_RECCST_Pos = 0x9
	// Bit mask of RECCST field.
	ICU_NMISR_RECCST_Msk = 0x200
	// Bit RECCST.
	ICU_NMISR_RECCST = 0x200
	// Interrupt not requested
	ICU_NMISR_RECCST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_RECCST_1 = 0x1
	// Position of RPEST field.
	ICU_NMISR_RPEST_Pos = 0x8
	// Bit mask of RPEST field.
	ICU_NMISR_RPEST_Msk = 0x100
	// Bit RPEST.
	ICU_NMISR_RPEST = 0x100
	// Interrupt not requested
	ICU_NMISR_RPEST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_RPEST_1 = 0x1
	// Position of NMIST field.
	ICU_NMISR_NMIST_Pos = 0x7
	// Bit mask of NMIST field.
	ICU_NMISR_NMIST_Msk = 0x80
	// Bit NMIST.
	ICU_NMISR_NMIST = 0x80
	// Interrupt not requested
	ICU_NMISR_NMIST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_NMIST_1 = 0x1
	// Position of OSTST field.
	ICU_NMISR_OSTST_Pos = 0x6
	// Bit mask of OSTST field.
	ICU_NMISR_OSTST_Msk = 0x40
	// Bit OSTST.
	ICU_NMISR_OSTST = 0x40
	// Interrupt not requested for main oscillation stop
	ICU_NMISR_OSTST_0 = 0x0
	// Interrupt requested for main oscillation stop.
	ICU_NMISR_OSTST_1 = 0x1
	// Position of Reserved field.
	ICU_NMISR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	ICU_NMISR_Reserved_Msk = 0x20
	// Bit Reserved.
	ICU_NMISR_Reserved = 0x20
	// Position of VBATTST field.
	ICU_NMISR_VBATTST_Pos = 0x4
	// Bit mask of VBATTST field.
	ICU_NMISR_VBATTST_Msk = 0x10
	// Bit VBATTST.
	ICU_NMISR_VBATTST = 0x10
	// Interrupt not requested
	ICU_NMISR_VBATTST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_VBATTST_1 = 0x1
	// Position of LVD2ST field.
	ICU_NMISR_LVD2ST_Pos = 0x3
	// Bit mask of LVD2ST field.
	ICU_NMISR_LVD2ST_Msk = 0x8
	// Bit LVD2ST.
	ICU_NMISR_LVD2ST = 0x8
	// Interrupt not requested
	ICU_NMISR_LVD2ST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_LVD2ST_1 = 0x1
	// Position of LVD1ST field.
	ICU_NMISR_LVD1ST_Pos = 0x2
	// Bit mask of LVD1ST field.
	ICU_NMISR_LVD1ST_Msk = 0x4
	// Bit LVD1ST.
	ICU_NMISR_LVD1ST = 0x4
	// Interrupt not requested
	ICU_NMISR_LVD1ST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_LVD1ST_1 = 0x1
	// Position of WDTST field.
	ICU_NMISR_WDTST_Pos = 0x1
	// Bit mask of WDTST field.
	ICU_NMISR_WDTST_Msk = 0x2
	// Bit WDTST.
	ICU_NMISR_WDTST = 0x2
	// Interrupt not requested
	ICU_NMISR_WDTST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_WDTST_1 = 0x1
	// Position of IWDTST field.
	ICU_NMISR_IWDTST_Pos = 0x0
	// Bit mask of IWDTST field.
	ICU_NMISR_IWDTST_Msk = 0x1
	// Bit IWDTST.
	ICU_NMISR_IWDTST = 0x1
	// Interrupt not requested
	ICU_NMISR_IWDTST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_IWDTST_1 = 0x1

	// WUPEN: Wake Up Interrupt Enable Register
	// Position of IIC0WUPEN field.
	ICU_WUPEN_IIC0WUPEN_Pos = 0x1f
	// Bit mask of IIC0WUPEN field.
	ICU_WUPEN_IIC0WUPEN_Msk = 0x80000000
	// Bit IIC0WUPEN.
	ICU_WUPEN_IIC0WUPEN = 0x80000000
	// S/W standby returns by IIC0 address match interrupt is disabled
	ICU_WUPEN_IIC0WUPEN_0 = 0x0
	// S/W standby returns by IIC0 address match interrupt is enabled
	ICU_WUPEN_IIC0WUPEN_1 = 0x1
	// Position of AGT1CBWUPEN field.
	ICU_WUPEN_AGT1CBWUPEN_Pos = 0x1e
	// Bit mask of AGT1CBWUPEN field.
	ICU_WUPEN_AGT1CBWUPEN_Msk = 0x40000000
	// Bit AGT1CBWUPEN.
	ICU_WUPEN_AGT1CBWUPEN = 0x40000000
	// S/W standby returns by AGT1 compare match B interrupt is disabled
	ICU_WUPEN_AGT1CBWUPEN_0 = 0x0
	// S/W standby returns by AGT1 compare match B interrupt is enabled
	ICU_WUPEN_AGT1CBWUPEN_1 = 0x1
	// Position of AGT1CAWUPEN field.
	ICU_WUPEN_AGT1CAWUPEN_Pos = 0x1d
	// Bit mask of AGT1CAWUPEN field.
	ICU_WUPEN_AGT1CAWUPEN_Msk = 0x20000000
	// Bit AGT1CAWUPEN.
	ICU_WUPEN_AGT1CAWUPEN = 0x20000000
	// S/W standby returns by AGT1 compare match A interrupt is disabled
	ICU_WUPEN_AGT1CAWUPEN_0 = 0x0
	// S/W standby returns by AGT1 compare match A interrupt is enabled
	ICU_WUPEN_AGT1CAWUPEN_1 = 0x1
	// Position of AGT1UDWUPEN field.
	ICU_WUPEN_AGT1UDWUPEN_Pos = 0x1c
	// Bit mask of AGT1UDWUPEN field.
	ICU_WUPEN_AGT1UDWUPEN_Msk = 0x10000000
	// Bit AGT1UDWUPEN.
	ICU_WUPEN_AGT1UDWUPEN = 0x10000000
	// S/W standby returns by AGT1 underflow interrupt is disabled
	ICU_WUPEN_AGT1UDWUPEN_0 = 0x0
	// S/W standby returns by AGT1 underflow interrupt is enabled
	ICU_WUPEN_AGT1UDWUPEN_1 = 0x1
	// Position of USBFSWUPEN field.
	ICU_WUPEN_USBFSWUPEN_Pos = 0x1b
	// Bit mask of USBFSWUPEN field.
	ICU_WUPEN_USBFSWUPEN_Msk = 0x8000000
	// Bit USBFSWUPEN.
	ICU_WUPEN_USBFSWUPEN = 0x8000000
	// S/W standby returns by USBFS interrupt is disabled
	ICU_WUPEN_USBFSWUPEN_0 = 0x0
	// S/W standby returns by USBFS interrupt is enabled
	ICU_WUPEN_USBFSWUPEN_1 = 0x1
	// Position of Reserved field.
	ICU_WUPEN_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	ICU_WUPEN_Reserved_Msk = 0x4000000
	// Bit Reserved.
	ICU_WUPEN_Reserved = 0x4000000
	// Position of RTCPRDWUPEN field.
	ICU_WUPEN_RTCPRDWUPEN_Pos = 0x19
	// Bit mask of RTCPRDWUPEN field.
	ICU_WUPEN_RTCPRDWUPEN_Msk = 0x2000000
	// Bit RTCPRDWUPEN.
	ICU_WUPEN_RTCPRDWUPEN = 0x2000000
	// S/W standby returns by RTC period interrupt is disabled
	ICU_WUPEN_RTCPRDWUPEN_0 = 0x0
	// S/W standby returns by RTC period interrupt is enabled
	ICU_WUPEN_RTCPRDWUPEN_1 = 0x1
	// Position of RTCALMWUPEN field.
	ICU_WUPEN_RTCALMWUPEN_Pos = 0x18
	// Bit mask of RTCALMWUPEN field.
	ICU_WUPEN_RTCALMWUPEN_Msk = 0x1000000
	// Bit RTCALMWUPEN.
	ICU_WUPEN_RTCALMWUPEN = 0x1000000
	// S/W standby returns by RTC alarm interrupt is disabled
	ICU_WUPEN_RTCALMWUPEN_0 = 0x0
	// S/W standby returns by RTC alarm interrupt is enabled
	ICU_WUPEN_RTCALMWUPEN_1 = 0x1
	// Position of ACMPLP0WUPEN field.
	ICU_WUPEN_ACMPLP0WUPEN_Pos = 0x17
	// Bit mask of ACMPLP0WUPEN field.
	ICU_WUPEN_ACMPLP0WUPEN_Msk = 0x800000
	// Bit ACMPLP0WUPEN.
	ICU_WUPEN_ACMPLP0WUPEN = 0x800000
	// S/W standby returns by ACMPLP0 interrupt is disabled
	ICU_WUPEN_ACMPLP0WUPEN_0 = 0x0
	// S/W standby returns by ACMPLP0 interrupt is enabled
	ICU_WUPEN_ACMPLP0WUPEN_1 = 0x1
	// Position of Reserved field.
	ICU_WUPEN_Reserved_Pos = 0x15
	// Bit mask of Reserved field.
	ICU_WUPEN_Reserved_Msk = 0x600000
	// Position of VBATTWUPEN field.
	ICU_WUPEN_VBATTWUPEN_Pos = 0x14
	// Bit mask of VBATTWUPEN field.
	ICU_WUPEN_VBATTWUPEN_Msk = 0x100000
	// Bit VBATTWUPEN.
	ICU_WUPEN_VBATTWUPEN = 0x100000
	// S/W standby returns by VBATT monitor interrupt is disabled
	ICU_WUPEN_VBATTWUPEN_0 = 0x0
	// S/W standby returns by VBATT monitor interrupt is enabled
	ICU_WUPEN_VBATTWUPEN_1 = 0x1
	// Position of LVD2WUPEN field.
	ICU_WUPEN_LVD2WUPEN_Pos = 0x13
	// Bit mask of LVD2WUPEN field.
	ICU_WUPEN_LVD2WUPEN_Msk = 0x80000
	// Bit LVD2WUPEN.
	ICU_WUPEN_LVD2WUPEN = 0x80000
	// S/W standby returns by LVD2 interrupt is disabled
	ICU_WUPEN_LVD2WUPEN_0 = 0x0
	// S/W standby returns by LVD2 interrupt is enabled
	ICU_WUPEN_LVD2WUPEN_1 = 0x1
	// Position of LVD1WUPEN field.
	ICU_WUPEN_LVD1WUPEN_Pos = 0x12
	// Bit mask of LVD1WUPEN field.
	ICU_WUPEN_LVD1WUPEN_Msk = 0x40000
	// Bit LVD1WUPEN.
	ICU_WUPEN_LVD1WUPEN = 0x40000
	// S/W standby returns by LVD1 interrupt is disabled
	ICU_WUPEN_LVD1WUPEN_0 = 0x0
	// S/W standby returns by LVD1 interrupt is enabled
	ICU_WUPEN_LVD1WUPEN_1 = 0x1
	// Position of KEYWUPEN field.
	ICU_WUPEN_KEYWUPEN_Pos = 0x11
	// Bit mask of KEYWUPEN field.
	ICU_WUPEN_KEYWUPEN_Msk = 0x20000
	// Bit KEYWUPEN.
	ICU_WUPEN_KEYWUPEN = 0x20000
	// S/W standby returns by KEY interrupt is disabled
	ICU_WUPEN_KEYWUPEN_0 = 0x0
	// S/W standby returns by KEY interrupt is enabled
	ICU_WUPEN_KEYWUPEN_1 = 0x1
	// Position of IWDTWUPEN field.
	ICU_WUPEN_IWDTWUPEN_Pos = 0x10
	// Bit mask of IWDTWUPEN field.
	ICU_WUPEN_IWDTWUPEN_Msk = 0x10000
	// Bit IWDTWUPEN.
	ICU_WUPEN_IWDTWUPEN = 0x10000
	// S/W standby returns by IWDT interrupt is disabled
	ICU_WUPEN_IWDTWUPEN_0 = 0x0
	// S/W standby returns by IWDT interrupt is enabled
	ICU_WUPEN_IWDTWUPEN_1 = 0x1
	// Position of IRQWUPEN15 field.
	ICU_WUPEN_IRQWUPEN15_Pos = 0xf
	// Bit mask of IRQWUPEN15 field.
	ICU_WUPEN_IRQWUPEN15_Msk = 0x8000
	// Bit IRQWUPEN15.
	ICU_WUPEN_IRQWUPEN15 = 0x8000
	// S/W standby returns by IRQ15 interrupt is disabled
	ICU_WUPEN_IRQWUPEN15_0 = 0x0
	// S/W standby returns by IRQ15 interrupt is enabled
	ICU_WUPEN_IRQWUPEN15_1 = 0x1
	// Position of IRQWUPEN14 field.
	ICU_WUPEN_IRQWUPEN14_Pos = 0xe
	// Bit mask of IRQWUPEN14 field.
	ICU_WUPEN_IRQWUPEN14_Msk = 0x4000
	// Bit IRQWUPEN14.
	ICU_WUPEN_IRQWUPEN14 = 0x4000
	// S/W standby returns by IRQ14 interrupt is disabled
	ICU_WUPEN_IRQWUPEN14_0 = 0x0
	// S/W standby returns by IRQ14 interrupt is enabled
	ICU_WUPEN_IRQWUPEN14_1 = 0x1
	// Position of IRQWUPEN13 field.
	ICU_WUPEN_IRQWUPEN13_Pos = 0xd
	// Bit mask of IRQWUPEN13 field.
	ICU_WUPEN_IRQWUPEN13_Msk = 0x2000
	// Bit IRQWUPEN13.
	ICU_WUPEN_IRQWUPEN13 = 0x2000
	// S/W standby returns by IRQ13 interrupt is disabled
	ICU_WUPEN_IRQWUPEN13_0 = 0x0
	// S/W standby returns by IRQ13 interrupt is enabled
	ICU_WUPEN_IRQWUPEN13_1 = 0x1
	// Position of IRQWUPEN12 field.
	ICU_WUPEN_IRQWUPEN12_Pos = 0xc
	// Bit mask of IRQWUPEN12 field.
	ICU_WUPEN_IRQWUPEN12_Msk = 0x1000
	// Bit IRQWUPEN12.
	ICU_WUPEN_IRQWUPEN12 = 0x1000
	// S/W standby returns by IRQ12 interrupt is disabled
	ICU_WUPEN_IRQWUPEN12_0 = 0x0
	// S/W standby returns by IRQ12 interrupt is enabled
	ICU_WUPEN_IRQWUPEN12_1 = 0x1
	// Position of IRQWUPEN11 field.
	ICU_WUPEN_IRQWUPEN11_Pos = 0xb
	// Bit mask of IRQWUPEN11 field.
	ICU_WUPEN_IRQWUPEN11_Msk = 0x800
	// Bit IRQWUPEN11.
	ICU_WUPEN_IRQWUPEN11 = 0x800
	// S/W standby returns by IRQ11 interrupt is disabled
	ICU_WUPEN_IRQWUPEN11_0 = 0x0
	// S/W standby returns by IRQ11 interrupt is enabled
	ICU_WUPEN_IRQWUPEN11_1 = 0x1
	// Position of IRQWUPEN10 field.
	ICU_WUPEN_IRQWUPEN10_Pos = 0xa
	// Bit mask of IRQWUPEN10 field.
	ICU_WUPEN_IRQWUPEN10_Msk = 0x400
	// Bit IRQWUPEN10.
	ICU_WUPEN_IRQWUPEN10 = 0x400
	// S/W standby returns by IRQ10 interrupt is disabled
	ICU_WUPEN_IRQWUPEN10_0 = 0x0
	// S/W standby returns by IRQ10 interrupt is enabled
	ICU_WUPEN_IRQWUPEN10_1 = 0x1
	// Position of IRQWUPEN9 field.
	ICU_WUPEN_IRQWUPEN9_Pos = 0x9
	// Bit mask of IRQWUPEN9 field.
	ICU_WUPEN_IRQWUPEN9_Msk = 0x200
	// Bit IRQWUPEN9.
	ICU_WUPEN_IRQWUPEN9 = 0x200
	// S/W standby returns by IRQ9 interrupt is disabled
	ICU_WUPEN_IRQWUPEN9_0 = 0x0
	// S/W standby returns by IRQ9 interrupt is enabled
	ICU_WUPEN_IRQWUPEN9_1 = 0x1
	// Position of IRQWUPEN8 field.
	ICU_WUPEN_IRQWUPEN8_Pos = 0x8
	// Bit mask of IRQWUPEN8 field.
	ICU_WUPEN_IRQWUPEN8_Msk = 0x100
	// Bit IRQWUPEN8.
	ICU_WUPEN_IRQWUPEN8 = 0x100
	// S/W standby returns by IRQ8 interrupt is disabled
	ICU_WUPEN_IRQWUPEN8_0 = 0x0
	// S/W standby returns by IRQ8 interrupt is enabled
	ICU_WUPEN_IRQWUPEN8_1 = 0x1
	// Position of IRQWUPEN7 field.
	ICU_WUPEN_IRQWUPEN7_Pos = 0x7
	// Bit mask of IRQWUPEN7 field.
	ICU_WUPEN_IRQWUPEN7_Msk = 0x80
	// Bit IRQWUPEN7.
	ICU_WUPEN_IRQWUPEN7 = 0x80
	// S/W standby returns by IRQ7 interrupt is disabled
	ICU_WUPEN_IRQWUPEN7_0 = 0x0
	// S/W standby returns by IRQ7 interrupt is enabled
	ICU_WUPEN_IRQWUPEN7_1 = 0x1
	// Position of IRQWUPEN6 field.
	ICU_WUPEN_IRQWUPEN6_Pos = 0x6
	// Bit mask of IRQWUPEN6 field.
	ICU_WUPEN_IRQWUPEN6_Msk = 0x40
	// Bit IRQWUPEN6.
	ICU_WUPEN_IRQWUPEN6 = 0x40
	// S/W standby returns by IRQ6 interrupt is disabled
	ICU_WUPEN_IRQWUPEN6_0 = 0x0
	// S/W standby returns by IRQ6 interrupt is enabled
	ICU_WUPEN_IRQWUPEN6_1 = 0x1
	// Position of IRQWUPEN5 field.
	ICU_WUPEN_IRQWUPEN5_Pos = 0x5
	// Bit mask of IRQWUPEN5 field.
	ICU_WUPEN_IRQWUPEN5_Msk = 0x20
	// Bit IRQWUPEN5.
	ICU_WUPEN_IRQWUPEN5 = 0x20
	// S/W standby returns by IRQ5 interrupt is disabled
	ICU_WUPEN_IRQWUPEN5_0 = 0x0
	// S/W standby returns by IRQ5 interrupt is enabled
	ICU_WUPEN_IRQWUPEN5_1 = 0x1
	// Position of IRQWUPEN4 field.
	ICU_WUPEN_IRQWUPEN4_Pos = 0x4
	// Bit mask of IRQWUPEN4 field.
	ICU_WUPEN_IRQWUPEN4_Msk = 0x10
	// Bit IRQWUPEN4.
	ICU_WUPEN_IRQWUPEN4 = 0x10
	// S/W standby returns by IRQ4 interrupt is disabled
	ICU_WUPEN_IRQWUPEN4_0 = 0x0
	// S/W standby returns by IRQ4 interrupt is enabled
	ICU_WUPEN_IRQWUPEN4_1 = 0x1
	// Position of IRQWUPEN3 field.
	ICU_WUPEN_IRQWUPEN3_Pos = 0x3
	// Bit mask of IRQWUPEN3 field.
	ICU_WUPEN_IRQWUPEN3_Msk = 0x8
	// Bit IRQWUPEN3.
	ICU_WUPEN_IRQWUPEN3 = 0x8
	// S/W standby returns by IRQ3 interrupt is disabled
	ICU_WUPEN_IRQWUPEN3_0 = 0x0
	// S/W standby returns by IRQ3 interrupt is enabled
	ICU_WUPEN_IRQWUPEN3_1 = 0x1
	// Position of IRQWUPEN2 field.
	ICU_WUPEN_IRQWUPEN2_Pos = 0x2
	// Bit mask of IRQWUPEN2 field.
	ICU_WUPEN_IRQWUPEN2_Msk = 0x4
	// Bit IRQWUPEN2.
	ICU_WUPEN_IRQWUPEN2 = 0x4
	// S/W standby returns by IRQ2 interrupt is disabled
	ICU_WUPEN_IRQWUPEN2_0 = 0x0
	// S/W standby returns by IRQ2 interrupt is enabled
	ICU_WUPEN_IRQWUPEN2_1 = 0x1
	// Position of IRQWUPEN1 field.
	ICU_WUPEN_IRQWUPEN1_Pos = 0x1
	// Bit mask of IRQWUPEN1 field.
	ICU_WUPEN_IRQWUPEN1_Msk = 0x2
	// Bit IRQWUPEN1.
	ICU_WUPEN_IRQWUPEN1 = 0x2
	// S/W standby returns by IRQ1 interrupt is disabled
	ICU_WUPEN_IRQWUPEN1_0 = 0x0
	// S/W standby returns by IRQ1 interrupt is enabled
	ICU_WUPEN_IRQWUPEN1_1 = 0x1
	// Position of IRQWUPEN0 field.
	ICU_WUPEN_IRQWUPEN0_Pos = 0x0
	// Bit mask of IRQWUPEN0 field.
	ICU_WUPEN_IRQWUPEN0_Msk = 0x1
	// Bit IRQWUPEN0.
	ICU_WUPEN_IRQWUPEN0 = 0x1
	// S/W standby returns by IRQ0 interrupt is disabled
	ICU_WUPEN_IRQWUPEN0_0 = 0x0
	// S/W standby returns by IRQ0 interrupt is enabled
	ICU_WUPEN_IRQWUPEN0_1 = 0x1

	// SELSR0: Snooze Event Link Setting Register
	// Position of Reserved field.
	ICU_SELSR0_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ICU_SELSR0_Reserved_Msk = 0xff00
	// Position of SELS field.
	ICU_SELSR0_SELS_Pos = 0x0
	// Bit mask of SELS field.
	ICU_SELSR0_SELS_Msk = 0xff
	// Nothing is selected
	ICU_SELSR0_SELS_0x000 = 0x0
	// DTC_COMPLETE
	ICU_SELSR0_SELS_0x015 = 0x15
	// ADC140_WCMPM
	ICU_SELSR0_SELS_0x02D = 0x2d
	// ADC140_WCMPUM
	ICU_SELSR0_SELS_0x02E = 0x2e
	// CTSU_CTSUFN
	ICU_SELSR0_SELS_0x048 = 0x48
	// DOC_DOPCI
	ICU_SELSR0_SELS_0x04A = 0x4a
	// SCI0_AM
	ICU_SELSR0_SELS_0x0B0 = 0xb0
	// SCI0_RXI_OR_ERI
	ICU_SELSR0_SELS_0x0B1 = 0xb1

	// DELSR0: DMAC Event Link Setting Register %s
	// Position of Reserved field.
	ICU_DELSR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ICU_DELSR_Reserved_Msk = 0xff00
	// Position of DELS field.
	ICU_DELSR_DELS_Pos = 0x0
	// Bit mask of DELS field.
	ICU_DELSR_DELS_Msk = 0xff
	// Nothing is selected.
	ICU_DELSR_DELS_0x000 = 0x0

	// IELSR0: ICU Event Link Setting Register %s
	// Position of Reserved field.
	ICU_IELSR_Reserved_Pos = 0x19
	// Bit mask of Reserved field.
	ICU_IELSR_Reserved_Msk = 0xfe000000
	// Position of DTCE field.
	ICU_IELSR_DTCE_Pos = 0x18
	// Bit mask of DTCE field.
	ICU_IELSR_DTCE_Msk = 0x1000000
	// Bit DTCE.
	ICU_IELSR_DTCE = 0x1000000
	// DTC activation is disabled
	ICU_IELSR_DTCE_0 = 0x0
	// DTC activation is enabled
	ICU_IELSR_DTCE_1 = 0x1
	// Position of Reserved field.
	ICU_IELSR_Reserved_Pos = 0x11
	// Bit mask of Reserved field.
	ICU_IELSR_Reserved_Msk = 0xfe0000
	// Position of IR field.
	ICU_IELSR_IR_Pos = 0x10
	// Bit mask of IR field.
	ICU_IELSR_IR_Msk = 0x10000
	// Bit IR.
	ICU_IELSR_IR = 0x10000
	// No interrupt request is generated
	ICU_IELSR_IR_0 = 0x0
	// An interrupt request is generated ( 1 write to the IR bit is prohibited. )
	ICU_IELSR_IR_1 = 0x1
	// Position of Reserved field.
	ICU_IELSR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ICU_IELSR_Reserved_Msk = 0xff00
	// Position of IELS field.
	ICU_IELSR_IELS_Pos = 0x0
	// Bit mask of IELS field.
	ICU_IELSR_IELS_Msk = 0xff
	// Nothing is selected
	ICU_IELSR_IELS_0x000 = 0x0
)

// Constants for DMAC0: Direct memory access controller 0
const (
	// DMSAR: DMA Source Address Register
	// Position of DMSAR field.
	DMAC0_DMSAR_DMSAR_Pos = 0x0
	// Bit mask of DMSAR field.
	DMAC0_DMSAR_DMSAR_Msk = 0xffffffff

	// DMDAR: DMA Destination Address Register
	// Position of DMDAR field.
	DMAC0_DMDAR_DMDAR_Pos = 0x0
	// Bit mask of DMDAR field.
	DMAC0_DMDAR_DMDAR_Msk = 0xffffffff

	// DMCRA: DMA Transfer Count Register
	// Position of Reserved field.
	DMAC0_DMCRA_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	DMAC0_DMCRA_Reserved_Msk = 0xfc000000
	// Position of DMCRAH field.
	DMAC0_DMCRA_DMCRAH_Pos = 0x10
	// Bit mask of DMCRAH field.
	DMAC0_DMCRA_DMCRAH_Msk = 0x3ff0000
	// Position of DMCRAL field.
	DMAC0_DMCRA_DMCRAL_Pos = 0x0
	// Bit mask of DMCRAL field.
	DMAC0_DMCRA_DMCRAL_Msk = 0xffff

	// DMCRB: DMA Block Transfer Count Register
	// Position of DMCRB field.
	DMAC0_DMCRB_DMCRB_Pos = 0x0
	// Bit mask of DMCRB field.
	DMAC0_DMCRB_DMCRB_Msk = 0xffff
	// 65,536 blocks
	DMAC0_DMCRB_DMCRB_0000 = 0x0

	// DMTMD: DMA Transfer Mode Register
	// Position of MD field.
	DMAC0_DMTMD_MD_Pos = 0xe
	// Bit mask of MD field.
	DMAC0_DMTMD_MD_Msk = 0xc000
	// Normal transfer
	DMAC0_DMTMD_MD_00 = 0x0
	// Repeat transfer
	DMAC0_DMTMD_MD_01 = 0x1
	// Block transfer
	DMAC0_DMTMD_MD_10 = 0x2
	// Setting prohibited
	DMAC0_DMTMD_MD_11 = 0x3
	// Position of DTS field.
	DMAC0_DMTMD_DTS_Pos = 0xc
	// Bit mask of DTS field.
	DMAC0_DMTMD_DTS_Msk = 0x3000
	// The destination is specified as the repeat area or block area.
	DMAC0_DMTMD_DTS_00 = 0x0
	// The source is specified as the repeat area or block area.
	DMAC0_DMTMD_DTS_01 = 0x1
	// The repeat area or block area is not specified.
	DMAC0_DMTMD_DTS_10 = 0x2
	// Setting prohibited
	DMAC0_DMTMD_DTS_11 = 0x3
	// Position of Reserved field.
	DMAC0_DMTMD_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	DMAC0_DMTMD_Reserved_Msk = 0xc00
	// Position of SZ field.
	DMAC0_DMTMD_SZ_Pos = 0x8
	// Bit mask of SZ field.
	DMAC0_DMTMD_SZ_Msk = 0x300
	// 8 bits
	DMAC0_DMTMD_SZ_00 = 0x0
	// 16 bits
	DMAC0_DMTMD_SZ_01 = 0x1
	// 32 bits
	DMAC0_DMTMD_SZ_10 = 0x2
	// Setting prohibited
	DMAC0_DMTMD_SZ_11 = 0x3
	// Position of Reserved field.
	DMAC0_DMTMD_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	DMAC0_DMTMD_Reserved_Msk = 0xfc
	// Position of DCTG field.
	DMAC0_DMTMD_DCTG_Pos = 0x0
	// Bit mask of DCTG field.
	DMAC0_DMTMD_DCTG_Msk = 0x3
	// Software
	DMAC0_DMTMD_DCTG_00 = 0x0
	// Interrupts*1 from peripheral modules or external interrupt input pins
	DMAC0_DMTMD_DCTG_01 = 0x1
	// Setting prohibited
	DMAC0_DMTMD_DCTG_10 = 0x2
	// Setting prohibited
	DMAC0_DMTMD_DCTG_11 = 0x3

	// DMINT: DMA Interrupt Setting Register
	// Position of Reserved field.
	DMAC0_DMINT_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	DMAC0_DMINT_Reserved_Msk = 0xe0
	// Position of DTIE field.
	DMAC0_DMINT_DTIE_Pos = 0x4
	// Bit mask of DTIE field.
	DMAC0_DMINT_DTIE_Msk = 0x10
	// Bit DTIE.
	DMAC0_DMINT_DTIE = 0x10
	// Disabled
	DMAC0_DMINT_DTIE_0 = 0x0
	// Enabled
	DMAC0_DMINT_DTIE_1 = 0x1
	// Position of ESIE field.
	DMAC0_DMINT_ESIE_Pos = 0x3
	// Bit mask of ESIE field.
	DMAC0_DMINT_ESIE_Msk = 0x8
	// Bit ESIE.
	DMAC0_DMINT_ESIE = 0x8
	// Disabled
	DMAC0_DMINT_ESIE_0 = 0x0
	// Enabled
	DMAC0_DMINT_ESIE_1 = 0x1
	// Position of RPTIE field.
	DMAC0_DMINT_RPTIE_Pos = 0x2
	// Bit mask of RPTIE field.
	DMAC0_DMINT_RPTIE_Msk = 0x4
	// Bit RPTIE.
	DMAC0_DMINT_RPTIE = 0x4
	// Disabled
	DMAC0_DMINT_RPTIE_0 = 0x0
	// Enabled
	DMAC0_DMINT_RPTIE_1 = 0x1
	// Position of SARIE field.
	DMAC0_DMINT_SARIE_Pos = 0x1
	// Bit mask of SARIE field.
	DMAC0_DMINT_SARIE_Msk = 0x2
	// Bit SARIE.
	DMAC0_DMINT_SARIE = 0x2
	// Disabled
	DMAC0_DMINT_SARIE_0 = 0x0
	// Enabled
	DMAC0_DMINT_SARIE_1 = 0x1
	// Position of DARIE field.
	DMAC0_DMINT_DARIE_Pos = 0x0
	// Bit mask of DARIE field.
	DMAC0_DMINT_DARIE_Msk = 0x1
	// Bit DARIE.
	DMAC0_DMINT_DARIE = 0x1
	// Disabled
	DMAC0_DMINT_DARIE_0 = 0x0
	// Enabled
	DMAC0_DMINT_DARIE_1 = 0x1

	// DMAMD: DMA Address Mode Register
	// Position of SM field.
	DMAC0_DMAMD_SM_Pos = 0xe
	// Bit mask of SM field.
	DMAC0_DMAMD_SM_Msk = 0xc000
	// Fixed address
	DMAC0_DMAMD_SM_00 = 0x0
	// Offset addition
	DMAC0_DMAMD_SM_01 = 0x1
	// Incremented address
	DMAC0_DMAMD_SM_10 = 0x2
	// Decremented address.
	DMAC0_DMAMD_SM_11 = 0x3
	// Position of Reserved field.
	DMAC0_DMAMD_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	DMAC0_DMAMD_Reserved_Msk = 0x2000
	// Bit Reserved.
	DMAC0_DMAMD_Reserved = 0x2000
	// Position of SARA field.
	DMAC0_DMAMD_SARA_Pos = 0x8
	// Bit mask of SARA field.
	DMAC0_DMAMD_SARA_Msk = 0x1f00
	// Position of DM field.
	DMAC0_DMAMD_DM_Pos = 0x6
	// Bit mask of DM field.
	DMAC0_DMAMD_DM_Msk = 0xc0
	// Fixed address
	DMAC0_DMAMD_DM_00 = 0x0
	// Offset addition
	DMAC0_DMAMD_DM_01 = 0x1
	// Incremented address
	DMAC0_DMAMD_DM_10 = 0x2
	// Decremented address.
	DMAC0_DMAMD_DM_11 = 0x3
	// Position of Reserved field.
	DMAC0_DMAMD_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	DMAC0_DMAMD_Reserved_Msk = 0x20
	// Bit Reserved.
	DMAC0_DMAMD_Reserved = 0x20
	// Position of DARA field.
	DMAC0_DMAMD_DARA_Pos = 0x0
	// Bit mask of DARA field.
	DMAC0_DMAMD_DARA_Msk = 0x1f

	// DMOFR: DMA Offset Register
	// Position of DMOFR field.
	DMAC0_DMOFR_DMOFR_Pos = 0x0
	// Bit mask of DMOFR field.
	DMAC0_DMOFR_DMOFR_Msk = 0xffffffff

	// DMCNT: DMA Transfer Enable Register
	// Position of Reserved field.
	DMAC0_DMCNT_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	DMAC0_DMCNT_Reserved_Msk = 0xfe
	// Position of DTE field.
	DMAC0_DMCNT_DTE_Pos = 0x0
	// Bit mask of DTE field.
	DMAC0_DMCNT_DTE_Msk = 0x1
	// Bit DTE.
	DMAC0_DMCNT_DTE = 0x1
	// Disabled
	DMAC0_DMCNT_DTE_0 = 0x0
	// Enabled.
	DMAC0_DMCNT_DTE_1 = 0x1

	// DMREQ: DMA Software Start Register
	// Position of Reserved field.
	DMAC0_DMREQ_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	DMAC0_DMREQ_Reserved_Msk = 0xe0
	// Position of CLRS field.
	DMAC0_DMREQ_CLRS_Pos = 0x4
	// Bit mask of CLRS field.
	DMAC0_DMREQ_CLRS_Msk = 0x10
	// Bit CLRS.
	DMAC0_DMREQ_CLRS = 0x10
	// SWREQ bit is cleared after DMA transfer is started by software.
	DMAC0_DMREQ_CLRS_0 = 0x0
	// SWREQ bit is not cleared after DMA transfer is started by software.
	DMAC0_DMREQ_CLRS_1 = 0x1
	// Position of Reserved field.
	DMAC0_DMREQ_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	DMAC0_DMREQ_Reserved_Msk = 0xe
	// Position of SWREQ field.
	DMAC0_DMREQ_SWREQ_Pos = 0x0
	// Bit mask of SWREQ field.
	DMAC0_DMREQ_SWREQ_Msk = 0x1
	// Bit SWREQ.
	DMAC0_DMREQ_SWREQ = 0x1
	// DMA transfer is not requested.
	DMAC0_DMREQ_SWREQ_0 = 0x0
	// DMA transfer is requested.
	DMAC0_DMREQ_SWREQ_1 = 0x1

	// DMSTS: DMA Status Register
	// Position of ACT field.
	DMAC0_DMSTS_ACT_Pos = 0x7
	// Bit mask of ACT field.
	DMAC0_DMSTS_ACT_Msk = 0x80
	// Bit ACT.
	DMAC0_DMSTS_ACT = 0x80
	// DMAC operation suspended
	DMAC0_DMSTS_ACT_0 = 0x0
	// DMAC operating.
	DMAC0_DMSTS_ACT_1 = 0x1
	// Position of Reserved field.
	DMAC0_DMSTS_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	DMAC0_DMSTS_Reserved_Msk = 0x60
	// Position of DTIF field.
	DMAC0_DMSTS_DTIF_Pos = 0x4
	// Bit mask of DTIF field.
	DMAC0_DMSTS_DTIF_Msk = 0x10
	// Bit DTIF.
	DMAC0_DMSTS_DTIF = 0x10
	// No interrupt
	DMAC0_DMSTS_DTIF_0 = 0x0
	// Interrupt occurred.
	DMAC0_DMSTS_DTIF_1 = 0x1
	// Position of Reserved field.
	DMAC0_DMSTS_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	DMAC0_DMSTS_Reserved_Msk = 0xe
	// Position of ESIF field.
	DMAC0_DMSTS_ESIF_Pos = 0x0
	// Bit mask of ESIF field.
	DMAC0_DMSTS_ESIF_Msk = 0x1
	// Bit ESIF.
	DMAC0_DMSTS_ESIF = 0x1
	// No interrupt
	DMAC0_DMSTS_ESIF_0 = 0x0
	// Interrupt occurred.
	DMAC0_DMSTS_ESIF_1 = 0x1
)

// Constants for DMA: DMAC Module Activation
const (
	// DMAST: DMAC Module Activation Register
	// Position of Reserved field.
	DMA_DMAST_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	DMA_DMAST_Reserved_Msk = 0xfe
	// Position of DMST field.
	DMA_DMAST_DMST_Pos = 0x0
	// Bit mask of DMST field.
	DMA_DMAST_DMST_Msk = 0x1
	// Bit DMST.
	DMA_DMAST_DMST = 0x1
	// Disabled.
	DMA_DMAST_DMST_0 = 0x0
	// Enabled.
	DMA_DMAST_DMST_1 = 0x1
)

// Constants for DBG: Debug Function
const (
	// DBGSTR: Debug Status Register
	// Position of Reserved field.
	DBG_DBGSTR_Reserved_Pos = 0x1e
	// Bit mask of Reserved field.
	DBG_DBGSTR_Reserved_Msk = 0xc0000000
	// Position of CDBGPWRUPACK field.
	DBG_DBGSTR_CDBGPWRUPACK_Pos = 0x1d
	// Bit mask of CDBGPWRUPACK field.
	DBG_DBGSTR_CDBGPWRUPACK_Msk = 0x20000000
	// Bit CDBGPWRUPACK.
	DBG_DBGSTR_CDBGPWRUPACK = 0x20000000
	// Debug power-up request is not acknowledged
	DBG_DBGSTR_CDBGPWRUPACK_0 = 0x0
	// Debug power-up request is acknowledged
	DBG_DBGSTR_CDBGPWRUPACK_1 = 0x1
	// Position of CDBGPWRUPREQ field.
	DBG_DBGSTR_CDBGPWRUPREQ_Pos = 0x1c
	// Bit mask of CDBGPWRUPREQ field.
	DBG_DBGSTR_CDBGPWRUPREQ_Msk = 0x10000000
	// Bit CDBGPWRUPREQ.
	DBG_DBGSTR_CDBGPWRUPREQ = 0x10000000
	// OCD is not requesting debug power-up
	DBG_DBGSTR_CDBGPWRUPREQ_0 = 0x0
	// OCD is requesting debug power-up
	DBG_DBGSTR_CDBGPWRUPREQ_1 = 0x1
	// Position of Reserved field.
	DBG_DBGSTR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	DBG_DBGSTR_Reserved_Msk = 0xfffffff

	// DBGSTOPCR: Debug Stop Control Register
	// Position of Reserved field.
	DBG_DBGSTOPCR_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	DBG_DBGSTOPCR_Reserved_Msk = 0xfc000000
	// Position of DBGSTOP_RECCR field.
	DBG_DBGSTOPCR_DBGSTOP_RECCR_Pos = 0x19
	// Bit mask of DBGSTOP_RECCR field.
	DBG_DBGSTOPCR_DBGSTOP_RECCR_Msk = 0x2000000
	// Bit DBGSTOP_RECCR.
	DBG_DBGSTOPCR_DBGSTOP_RECCR = 0x2000000
	// Enable RAM ECC error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RECCR_0 = 0x0
	// Mask RAM ECC error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RECCR_1 = 0x1
	// Position of DBGSTOP_RPER field.
	DBG_DBGSTOPCR_DBGSTOP_RPER_Pos = 0x18
	// Bit mask of DBGSTOP_RPER field.
	DBG_DBGSTOPCR_DBGSTOP_RPER_Msk = 0x1000000
	// Bit DBGSTOP_RPER.
	DBG_DBGSTOPCR_DBGSTOP_RPER = 0x1000000
	// Enable RAM parity error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RPER_0 = 0x0
	// Mask RAM parity error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RPER_1 = 0x1
	// Position of Reserved field.
	DBG_DBGSTOPCR_Reserved_Pos = 0x13
	// Bit mask of Reserved field.
	DBG_DBGSTOPCR_Reserved_Msk = 0xf80000
	// Position of DBGSTOP_LVD field.
	DBG_DBGSTOPCR_DBGSTOP_LVD_Pos = 0x10
	// Bit mask of DBGSTOP_LVD field.
	DBG_DBGSTOPCR_DBGSTOP_LVD_Msk = 0x70000
	// Position of Reserved field.
	DBG_DBGSTOPCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	DBG_DBGSTOPCR_Reserved_Msk = 0xfffc
	// Position of DBGSTOP_WDT field.
	DBG_DBGSTOPCR_DBGSTOP_WDT_Pos = 0x1
	// Bit mask of DBGSTOP_WDT field.
	DBG_DBGSTOPCR_DBGSTOP_WDT_Msk = 0x2
	// Bit DBGSTOP_WDT.
	DBG_DBGSTOPCR_DBGSTOP_WDT = 0x2
	// Mask WDT reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_WDT_0 = 0x0
	// Enable WDT reset
	DBG_DBGSTOPCR_DBGSTOP_WDT_1 = 0x1
	// Position of DBGSTOP_IWDT field.
	DBG_DBGSTOPCR_DBGSTOP_IWDT_Pos = 0x0
	// Bit mask of DBGSTOP_IWDT field.
	DBG_DBGSTOPCR_DBGSTOP_IWDT_Msk = 0x1
	// Bit DBGSTOP_IWDT.
	DBG_DBGSTOPCR_DBGSTOP_IWDT = 0x1
	// Mask IWDT reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_IWDT_0 = 0x0
	// Enable IWDT reset
	DBG_DBGSTOPCR_DBGSTOP_IWDT_1 = 0x1

	// TRACECTR: Trace Control Register
	// Position of ENETBFULL field.
	DBG_TRACECTR_ENETBFULL_Pos = 0x1f
	// Bit mask of ENETBFULL field.
	DBG_TRACECTR_ENETBFULL_Msk = 0x80000000
	// Bit ENETBFULL.
	DBG_TRACECTR_ENETBFULL = 0x80000000
	// ETB full does not cause CPU halt
	DBG_TRACECTR_ENETBFULL_0 = 0x0
	// ETB full cause CPU halt
	DBG_TRACECTR_ENETBFULL_1 = 0x1
	// Position of Reserved field.
	DBG_TRACECTR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	DBG_TRACECTR_Reserved_Msk = 0x7fffffff
)

// Constants for BUS: BUS Control
const (
	// CS0MOD: CS%s Mode Register
	// Position of PRDMOD field.
	BUS_CSMOD_PRDMOD_Pos = 0xf
	// Bit mask of PRDMOD field.
	BUS_CSMOD_PRDMOD_Msk = 0x8000
	// Bit PRDMOD.
	BUS_CSMOD_PRDMOD = 0x8000
	// Normal access compatible mode
	BUS_CSMOD_PRDMOD_0 = 0x0
	// External data read continuous assertion mode
	BUS_CSMOD_PRDMOD_1 = 0x1
	// Position of Reserved field.
	BUS_CSMOD_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	BUS_CSMOD_Reserved_Msk = 0x7c00
	// Position of PWENB field.
	BUS_CSMOD_PWENB_Pos = 0x9
	// Bit mask of PWENB field.
	BUS_CSMOD_PWENB_Msk = 0x200
	// Bit PWENB.
	BUS_CSMOD_PWENB = 0x200
	// Disabled
	BUS_CSMOD_PWENB_0 = 0x0
	// Enabled
	BUS_CSMOD_PWENB_1 = 0x1
	// Position of PRENB field.
	BUS_CSMOD_PRENB_Pos = 0x8
	// Bit mask of PRENB field.
	BUS_CSMOD_PRENB_Msk = 0x100
	// Bit PRENB.
	BUS_CSMOD_PRENB = 0x100
	// Disabled
	BUS_CSMOD_PRENB_0 = 0x0
	// Enabled
	BUS_CSMOD_PRENB_1 = 0x1
	// Position of Reserved field.
	BUS_CSMOD_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	BUS_CSMOD_Reserved_Msk = 0xf0
	// Position of EWENB field.
	BUS_CSMOD_EWENB_Pos = 0x3
	// Bit mask of EWENB field.
	BUS_CSMOD_EWENB_Msk = 0x8
	// Bit EWENB.
	BUS_CSMOD_EWENB = 0x8
	// Disabled
	BUS_CSMOD_EWENB_0 = 0x0
	// Enabled
	BUS_CSMOD_EWENB_1 = 0x1
	// Position of Reserved field.
	BUS_CSMOD_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	BUS_CSMOD_Reserved_Msk = 0x6
	// Position of WRMOD field.
	BUS_CSMOD_WRMOD_Pos = 0x0
	// Bit mask of WRMOD field.
	BUS_CSMOD_WRMOD_Msk = 0x1
	// Bit WRMOD.
	BUS_CSMOD_WRMOD = 0x1
	// Byte strobe mode
	BUS_CSMOD_WRMOD_0 = 0x0
	// Single write strobe mode
	BUS_CSMOD_WRMOD_1 = 0x1

	// CS0WCR1: CS%s Wait Control Register 1
	// Position of Reserved field.
	BUS_CSWCR1_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	BUS_CSWCR1_Reserved_Msk = 0xe0000000
	// Position of CSRWAIT field.
	BUS_CSWCR1_CSRWAIT_Pos = 0x18
	// Bit mask of CSRWAIT field.
	BUS_CSWCR1_CSRWAIT_Msk = 0x1f000000
	// No wait is inserted.
	BUS_CSWCR1_CSRWAIT_0x00 = 0x0
	// Position of Reserved field.
	BUS_CSWCR1_Reserved_Pos = 0x15
	// Bit mask of Reserved field.
	BUS_CSWCR1_Reserved_Msk = 0xe00000
	// Position of CSWWAIT field.
	BUS_CSWCR1_CSWWAIT_Pos = 0x10
	// Bit mask of CSWWAIT field.
	BUS_CSWCR1_CSWWAIT_Msk = 0x1f0000
	// No wait is inserted.
	BUS_CSWCR1_CSWWAIT_0x00 = 0x0
	// Position of Reserved field.
	BUS_CSWCR1_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	BUS_CSWCR1_Reserved_Msk = 0xf800
	// Position of CSPRWAIT field.
	BUS_CSWCR1_CSPRWAIT_Pos = 0x8
	// Bit mask of CSPRWAIT field.
	BUS_CSWCR1_CSPRWAIT_Msk = 0x700
	// No wait is inserted.
	BUS_CSWCR1_CSPRWAIT_0x0 = 0x0
	// Position of Reserved field.
	BUS_CSWCR1_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	BUS_CSWCR1_Reserved_Msk = 0xf8
	// Position of CSPWWAIT field.
	BUS_CSWCR1_CSPWWAIT_Pos = 0x0
	// Bit mask of CSPWWAIT field.
	BUS_CSWCR1_CSPWWAIT_Msk = 0x7
	// No wait is inserted.
	BUS_CSWCR1_CSPWWAIT_0x0 = 0x0

	// CS0WCR2: CS%s Wait Control Register 2
	// Position of Reserved field.
	BUS_CSWCR2_Reserved_Pos = 0x1f
	// Bit mask of Reserved field.
	BUS_CSWCR2_Reserved_Msk = 0x80000000
	// Bit Reserved.
	BUS_CSWCR2_Reserved = 0x80000000
	// Position of CSON field.
	BUS_CSWCR2_CSON_Pos = 0x1c
	// Bit mask of CSON field.
	BUS_CSWCR2_CSON_Msk = 0x70000000
	// No wait is inserted.
	BUS_CSWCR2_CSON_0x0 = 0x0
	// Position of Reserved field.
	BUS_CSWCR2_Reserved_Pos = 0x1b
	// Bit mask of Reserved field.
	BUS_CSWCR2_Reserved_Msk = 0x8000000
	// Bit Reserved.
	BUS_CSWCR2_Reserved = 0x8000000
	// Position of WDON field.
	BUS_CSWCR2_WDON_Pos = 0x18
	// Bit mask of WDON field.
	BUS_CSWCR2_WDON_Msk = 0x7000000
	// No wait is inserted.
	BUS_CSWCR2_WDON_0x0 = 0x0
	// Position of Reserved field.
	BUS_CSWCR2_Reserved_Pos = 0x17
	// Bit mask of Reserved field.
	BUS_CSWCR2_Reserved_Msk = 0x800000
	// Bit Reserved.
	BUS_CSWCR2_Reserved = 0x800000
	// Position of WRON field.
	BUS_CSWCR2_WRON_Pos = 0x14
	// Bit mask of WRON field.
	BUS_CSWCR2_WRON_Msk = 0x700000
	// No wait is inserted.
	BUS_CSWCR2_WRON_0x0 = 0x0
	// Position of Reserved field.
	BUS_CSWCR2_Reserved_Pos = 0x13
	// Bit mask of Reserved field.
	BUS_CSWCR2_Reserved_Msk = 0x80000
	// Bit Reserved.
	BUS_CSWCR2_Reserved = 0x80000
	// Position of RDON field.
	BUS_CSWCR2_RDON_Pos = 0x10
	// Bit mask of RDON field.
	BUS_CSWCR2_RDON_Msk = 0x70000
	// No wait is inserted.
	BUS_CSWCR2_RDON_0x0 = 0x0
	// Position of Reserved field.
	BUS_CSWCR2_Reserved_Pos = 0xe
	// Bit mask of Reserved field.
	BUS_CSWCR2_Reserved_Msk = 0xc000
	// Position of AWAIT field.
	BUS_CSWCR2_AWAIT_Pos = 0xc
	// Bit mask of AWAIT field.
	BUS_CSWCR2_AWAIT_Msk = 0x3000
	// No wait is inserted.
	BUS_CSWCR2_AWAIT_0x0 = 0x0
	// Position of Reserved field.
	BUS_CSWCR2_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	BUS_CSWCR2_Reserved_Msk = 0x800
	// Bit Reserved.
	BUS_CSWCR2_Reserved = 0x800
	// Position of WDOFF field.
	BUS_CSWCR2_WDOFF_Pos = 0x8
	// Bit mask of WDOFF field.
	BUS_CSWCR2_WDOFF_Msk = 0x700
	// No wait is inserted.
	BUS_CSWCR2_WDOFF_0x0 = 0x0
	// Position of Reserved field.
	BUS_CSWCR2_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	BUS_CSWCR2_Reserved_Msk = 0x80
	// Bit Reserved.
	BUS_CSWCR2_Reserved = 0x80
	// Position of CSWOFF field.
	BUS_CSWCR2_CSWOFF_Pos = 0x4
	// Bit mask of CSWOFF field.
	BUS_CSWCR2_CSWOFF_Msk = 0x70
	// No wait is inserted.
	BUS_CSWCR2_CSWOFF_0x0 = 0x0
	// Position of Reserved field.
	BUS_CSWCR2_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	BUS_CSWCR2_Reserved_Msk = 0x8
	// Bit Reserved.
	BUS_CSWCR2_Reserved = 0x8
	// Position of CSROFF field.
	BUS_CSWCR2_CSROFF_Pos = 0x0
	// Bit mask of CSROFF field.
	BUS_CSWCR2_CSROFF_Msk = 0x7
	// No wait is inserted.
	BUS_CSWCR2_CSROFF_0x0 = 0x0

	// CS0CR: CS0 Control Register
	// Position of Reserved field.
	BUS_CS0CR_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	BUS_CS0CR_Reserved_Msk = 0xe000
	// Position of MPXEN field.
	BUS_CS0CR_MPXEN_Pos = 0xc
	// Bit mask of MPXEN field.
	BUS_CS0CR_MPXEN_Msk = 0x1000
	// Bit MPXEN.
	BUS_CS0CR_MPXEN = 0x1000
	// Separate bus interface is selected for area 0.
	BUS_CS0CR_MPXEN_0 = 0x0
	// Address/data multiplexed I/O interface is selected for area 0.
	BUS_CS0CR_MPXEN_1 = 0x1
	// Position of Reserved field.
	BUS_CS0CR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	BUS_CS0CR_Reserved_Msk = 0xe00
	// Position of EMODE field.
	BUS_CS0CR_EMODE_Pos = 0x8
	// Bit mask of EMODE field.
	BUS_CS0CR_EMODE_Msk = 0x100
	// Bit EMODE.
	BUS_CS0CR_EMODE = 0x100
	// Little Endian
	BUS_CS0CR_EMODE_0 = 0x0
	// Big Endian
	BUS_CS0CR_EMODE_1 = 0x1
	// Position of Reserved field.
	BUS_CS0CR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	BUS_CS0CR_Reserved_Msk = 0xc0
	// Position of BSIZE field.
	BUS_CS0CR_BSIZE_Pos = 0x4
	// Bit mask of BSIZE field.
	BUS_CS0CR_BSIZE_Msk = 0x30
	// 16-bit bus space
	BUS_CS0CR_BSIZE_00 = 0x0
	// Setting prohibited
	BUS_CS0CR_BSIZE_01 = 0x1
	// 8-bit bus space
	BUS_CS0CR_BSIZE_10 = 0x2
	// Setting prohibited
	BUS_CS0CR_BSIZE_11 = 0x3
	// Position of Reserved field.
	BUS_CS0CR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	BUS_CS0CR_Reserved_Msk = 0xe
	// Position of EXENB field.
	BUS_CS0CR_EXENB_Pos = 0x0
	// Bit mask of EXENB field.
	BUS_CS0CR_EXENB_Msk = 0x1
	// Bit EXENB.
	BUS_CS0CR_EXENB = 0x1
	// Disabled
	BUS_CS0CR_EXENB_0 = 0x0
	// Enabled
	BUS_CS0CR_EXENB_1 = 0x1

	// CS0REC: CS%s Recovery Cycle Register
	// Position of Reserved field.
	BUS_CSREC_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	BUS_CSREC_Reserved_Msk = 0xf000
	// Position of WRCV field.
	BUS_CSREC_WRCV_Pos = 0x8
	// Bit mask of WRCV field.
	BUS_CSREC_WRCV_Msk = 0xf00
	// No recovery cycle is inserted.
	BUS_CSREC_WRCV_0x0 = 0x0
	// Position of Reserved field.
	BUS_CSREC_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	BUS_CSREC_Reserved_Msk = 0xf0
	// Position of RRCV field.
	BUS_CSREC_RRCV_Pos = 0x0
	// Bit mask of RRCV field.
	BUS_CSREC_RRCV_Msk = 0xf
	// No recovery cycle is inserted.
	BUS_CSREC_RRCV_0x0 = 0x0

	// CS1CR: CS%s Control Register
	// Position of Reserved field.
	BUS_CSCR_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	BUS_CSCR_Reserved_Msk = 0xe000
	// Position of MPXEN field.
	BUS_CSCR_MPXEN_Pos = 0xc
	// Bit mask of MPXEN field.
	BUS_CSCR_MPXEN_Msk = 0x1000
	// Bit MPXEN.
	BUS_CSCR_MPXEN = 0x1000
	// Separate bus interface is selected for area 0.
	BUS_CSCR_MPXEN_0 = 0x0
	// Address/data multiplexed I/O interface is selected for area 0.
	BUS_CSCR_MPXEN_1 = 0x1
	// Position of Reserved field.
	BUS_CSCR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	BUS_CSCR_Reserved_Msk = 0xe00
	// Position of EMODE field.
	BUS_CSCR_EMODE_Pos = 0x8
	// Bit mask of EMODE field.
	BUS_CSCR_EMODE_Msk = 0x100
	// Bit EMODE.
	BUS_CSCR_EMODE = 0x100
	// Little Endian
	BUS_CSCR_EMODE_0 = 0x0
	// Big Endian
	BUS_CSCR_EMODE_1 = 0x1
	// Position of Reserved field.
	BUS_CSCR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	BUS_CSCR_Reserved_Msk = 0xc0
	// Position of BSIZE field.
	BUS_CSCR_BSIZE_Pos = 0x4
	// Bit mask of BSIZE field.
	BUS_CSCR_BSIZE_Msk = 0x30
	// 16-bit bus space
	BUS_CSCR_BSIZE_00 = 0x0
	// Setting prohibited
	BUS_CSCR_BSIZE_01 = 0x1
	// 8-bit bus space
	BUS_CSCR_BSIZE_10 = 0x2
	// Setting prohibited
	BUS_CSCR_BSIZE_11 = 0x3
	// Position of Reserved field.
	BUS_CSCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	BUS_CSCR_Reserved_Msk = 0xe
	// Position of EXENB field.
	BUS_CSCR_EXENB_Pos = 0x0
	// Bit mask of EXENB field.
	BUS_CSCR_EXENB_Msk = 0x1
	// Bit EXENB.
	BUS_CSCR_EXENB = 0x1
	// Disabled
	BUS_CSCR_EXENB_0 = 0x0
	// Enabled
	BUS_CSCR_EXENB_1 = 0x1

	// CSRECEN: CS Recovery Cycle Insertion Enable Register
	// Position of RECVENM7 field.
	BUS_CSRECEN_RECVENM7_Pos = 0xf
	// Bit mask of RECVENM7 field.
	BUS_CSRECEN_RECVENM7_Msk = 0x8000
	// Bit RECVENM7.
	BUS_CSRECEN_RECVENM7 = 0x8000
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RECVENM7_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RECVENM7_1 = 0x1
	// Position of RECVENM6 field.
	BUS_CSRECEN_RECVENM6_Pos = 0xe
	// Bit mask of RECVENM6 field.
	BUS_CSRECEN_RECVENM6_Msk = 0x4000
	// Bit RECVENM6.
	BUS_CSRECEN_RECVENM6 = 0x4000
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RECVENM6_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RECVENM6_1 = 0x1
	// Position of RECVENM5 field.
	BUS_CSRECEN_RECVENM5_Pos = 0xd
	// Bit mask of RECVENM5 field.
	BUS_CSRECEN_RECVENM5_Msk = 0x2000
	// Bit RECVENM5.
	BUS_CSRECEN_RECVENM5 = 0x2000
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RECVENM5_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RECVENM5_1 = 0x1
	// Position of RECVENM4 field.
	BUS_CSRECEN_RECVENM4_Pos = 0xc
	// Bit mask of RECVENM4 field.
	BUS_CSRECEN_RECVENM4_Msk = 0x1000
	// Bit RECVENM4.
	BUS_CSRECEN_RECVENM4 = 0x1000
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RECVENM4_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RECVENM4_1 = 0x1
	// Position of RECVENM3 field.
	BUS_CSRECEN_RECVENM3_Pos = 0xb
	// Bit mask of RECVENM3 field.
	BUS_CSRECEN_RECVENM3_Msk = 0x800
	// Bit RECVENM3.
	BUS_CSRECEN_RECVENM3 = 0x800
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RECVENM3_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RECVENM3_1 = 0x1
	// Position of RECVENM2 field.
	BUS_CSRECEN_RECVENM2_Pos = 0xa
	// Bit mask of RECVENM2 field.
	BUS_CSRECEN_RECVENM2_Msk = 0x400
	// Bit RECVENM2.
	BUS_CSRECEN_RECVENM2 = 0x400
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RECVENM2_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RECVENM2_1 = 0x1
	// Position of RECVENM1 field.
	BUS_CSRECEN_RECVENM1_Pos = 0x9
	// Bit mask of RECVENM1 field.
	BUS_CSRECEN_RECVENM1_Msk = 0x200
	// Bit RECVENM1.
	BUS_CSRECEN_RECVENM1 = 0x200
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RECVENM1_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RECVENM1_1 = 0x1
	// Position of RECVENM0 field.
	BUS_CSRECEN_RECVENM0_Pos = 0x8
	// Bit mask of RECVENM0 field.
	BUS_CSRECEN_RECVENM0_Msk = 0x100
	// Bit RECVENM0.
	BUS_CSRECEN_RECVENM0 = 0x100
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RECVENM0_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RECVENM0_1 = 0x1
	// Position of RECVEN7 field.
	BUS_CSRECEN_RECVEN7_Pos = 0x7
	// Bit mask of RECVEN7 field.
	BUS_CSRECEN_RECVEN7_Msk = 0x80
	// Bit RECVEN7.
	BUS_CSRECEN_RECVEN7 = 0x80
	// Disabled.
	BUS_CSRECEN_RECVEN7_0 = 0x0
	// Enabled.
	BUS_CSRECEN_RECVEN7_1 = 0x1
	// Position of RECVEN6 field.
	BUS_CSRECEN_RECVEN6_Pos = 0x6
	// Bit mask of RECVEN6 field.
	BUS_CSRECEN_RECVEN6_Msk = 0x40
	// Bit RECVEN6.
	BUS_CSRECEN_RECVEN6 = 0x40
	// Disabled.
	BUS_CSRECEN_RECVEN6_0 = 0x0
	// Enabled.
	BUS_CSRECEN_RECVEN6_1 = 0x1
	// Position of RECVEN5 field.
	BUS_CSRECEN_RECVEN5_Pos = 0x5
	// Bit mask of RECVEN5 field.
	BUS_CSRECEN_RECVEN5_Msk = 0x20
	// Bit RECVEN5.
	BUS_CSRECEN_RECVEN5 = 0x20
	// Disabled.
	BUS_CSRECEN_RECVEN5_0 = 0x0
	// Enabled.
	BUS_CSRECEN_RECVEN5_1 = 0x1
	// Position of RECVEN4 field.
	BUS_CSRECEN_RECVEN4_Pos = 0x4
	// Bit mask of RECVEN4 field.
	BUS_CSRECEN_RECVEN4_Msk = 0x10
	// Bit RECVEN4.
	BUS_CSRECEN_RECVEN4 = 0x10
	// Disabled.
	BUS_CSRECEN_RECVEN4_0 = 0x0
	// Enabled.
	BUS_CSRECEN_RECVEN4_1 = 0x1
	// Position of RECVEN3 field.
	BUS_CSRECEN_RECVEN3_Pos = 0x3
	// Bit mask of RECVEN3 field.
	BUS_CSRECEN_RECVEN3_Msk = 0x8
	// Bit RECVEN3.
	BUS_CSRECEN_RECVEN3 = 0x8
	// Disabled.
	BUS_CSRECEN_RECVEN3_0 = 0x0
	// Enabled.
	BUS_CSRECEN_RECVEN3_1 = 0x1
	// Position of RECVEN2 field.
	BUS_CSRECEN_RECVEN2_Pos = 0x2
	// Bit mask of RECVEN2 field.
	BUS_CSRECEN_RECVEN2_Msk = 0x4
	// Bit RECVEN2.
	BUS_CSRECEN_RECVEN2 = 0x4
	// Disabled.
	BUS_CSRECEN_RECVEN2_0 = 0x0
	// Enabled.
	BUS_CSRECEN_RECVEN2_1 = 0x1
	// Position of RECVEN1 field.
	BUS_CSRECEN_RECVEN1_Pos = 0x1
	// Bit mask of RECVEN1 field.
	BUS_CSRECEN_RECVEN1_Msk = 0x2
	// Bit RECVEN1.
	BUS_CSRECEN_RECVEN1 = 0x2
	// Disabled.
	BUS_CSRECEN_RECVEN1_0 = 0x0
	// Enabled.
	BUS_CSRECEN_RECVEN1_1 = 0x1
	// Position of RECVEN0 field.
	BUS_CSRECEN_RECVEN0_Pos = 0x0
	// Bit mask of RECVEN0 field.
	BUS_CSRECEN_RECVEN0_Msk = 0x1
	// Bit RECVEN0.
	BUS_CSRECEN_RECVEN0 = 0x1
	// Disabled.
	BUS_CSRECEN_RECVEN0_0 = 0x0
	// Enabled.
	BUS_CSRECEN_RECVEN0_1 = 0x1

	// BUSMCNTM4I: Master Bus Control Register %s
	// Position of IERES field.
	BUS_BUSMCNT_IERES_Pos = 0xf
	// Bit mask of IERES field.
	BUS_BUSMCNT_IERES_Msk = 0x8000
	// Bit IERES.
	BUS_BUSMCNT_IERES = 0x8000
	// A bus error is reported
	BUS_BUSMCNT_IERES_0 = 0x0
	// A bus error is not reported.
	BUS_BUSMCNT_IERES_1 = 0x1
	// Position of Reserved field.
	BUS_BUSMCNT_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSMCNT_Reserved_Msk = 0x7fff

	// BUSSCNTFLI: Slave Bus Control Register FLI
	// Position of Reserved field.
	BUS_BUSSCNTFLI_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	BUS_BUSSCNTFLI_Reserved_Msk = 0xffc0
	// Position of ARBMET field.
	BUS_BUSSCNTFLI_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNTFLI_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNTFLI_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNTFLI_ARBMET_01 = 0x1
	// Position of Reserved field.
	BUS_BUSSCNTFLI_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSSCNTFLI_Reserved_Msk = 0xf

	// BUSSCNTMBIU: Slave Bus Control Register %s
	// Position of Reserved field.
	BUS_BUSSCNT_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	BUS_BUSSCNT_Reserved_Msk = 0xffc0
	// Position of ARBMET field.
	BUS_BUSSCNT_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNT_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNT_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNT_ARBMET_01 = 0x1
	// Position of Reserved field.
	BUS_BUSSCNT_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSSCNT_Reserved_Msk = 0xf

	// BUSSCNTP0B: Slave Bus Control Register %s
	// Position of Reserved field.
	BUS_BUSSCNT_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	BUS_BUSSCNT_Reserved_Msk = 0xffc0
	// Position of ARBMET field.
	BUS_BUSSCNT_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNT_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNT_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNT_ARBMET_01 = 0x1
	// Position of Reserved field.
	BUS_BUSSCNT_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSSCNT_Reserved_Msk = 0xf

	// BUSSCNTP6B: Slave Bus Control Register P6B
	// Position of Reserved field.
	BUS_BUSSCNTP6B_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	BUS_BUSSCNTP6B_Reserved_Msk = 0xffc0
	// Position of ARBMET field.
	BUS_BUSSCNTP6B_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNTP6B_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNTP6B_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNTP6B_ARBMET_01 = 0x1
	// Position of Reserved field.
	BUS_BUSSCNTP6B_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSSCNTP6B_Reserved_Msk = 0xf

	// BUSSCNTFBU: Slave Bus Control Register %s
	// Position of Reserved field.
	BUS_BUSSCNT_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	BUS_BUSSCNT_Reserved_Msk = 0xffc0
	// Position of ARBMET field.
	BUS_BUSSCNT_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNT_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNT_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNT_ARBMET_01 = 0x1
	// Position of Reserved field.
	BUS_BUSSCNT_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSSCNT_Reserved_Msk = 0xf

	// BUS1ERRADD: Bus Error Address Register %s
	// Position of BERAD field.
	BUS_BUSERRADD_BERAD_Pos = 0x0
	// Bit mask of BERAD field.
	BUS_BUSERRADD_BERAD_Msk = 0xffffffff

	// BUS1ERRSTAT: Bus Error Status Register %s
	// Position of ERRSTAT field.
	BUS_BUSERRSTAT_ERRSTAT_Pos = 0x7
	// Bit mask of ERRSTAT field.
	BUS_BUSERRSTAT_ERRSTAT_Msk = 0x80
	// Bit ERRSTAT.
	BUS_BUSERRSTAT_ERRSTAT = 0x80
	// No bus error occurred
	BUS_BUSERRSTAT_ERRSTAT_0 = 0x0
	// Bus error occurred.
	BUS_BUSERRSTAT_ERRSTAT_1 = 0x1
	// Position of Reserved field.
	BUS_BUSERRSTAT_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	BUS_BUSERRSTAT_Reserved_Msk = 0x7e
	// Position of ACCSTST field.
	BUS_BUSERRSTAT_ACCSTST_Pos = 0x0
	// Bit mask of ACCSTST field.
	BUS_BUSERRSTAT_ACCSTST_Msk = 0x1
	// Bit ACCSTST.
	BUS_BUSERRSTAT_ACCSTST = 0x1
	// Read access
	BUS_BUSERRSTAT_ACCSTST_0 = 0x0
	// Write Access
	BUS_BUSERRSTAT_ACCSTST_1 = 0x1
)

// Constants for SRAM: SRAM Control
const (
	// PARIOAD: SRAM Parity Error Operation After Detection Register
	// Position of Reserved field.
	SRAM_PARIOAD_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SRAM_PARIOAD_Reserved_Msk = 0xfe
	// Position of OAD field.
	SRAM_PARIOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SRAM_PARIOAD_OAD_Msk = 0x1
	// Bit OAD.
	SRAM_PARIOAD_OAD = 0x1
	// Reset
	SRAM_PARIOAD_OAD_1 = 0x1
	// Non maskable interrupt.
	SRAM_PARIOAD_OAD_0 = 0x0

	// SRAMPRCR: SRAM Protection Register
	// Position of KW field.
	SRAM_SRAMPRCR_KW_Pos = 0x1
	// Bit mask of KW field.
	SRAM_SRAMPRCR_KW_Msk = 0xfe
	// Writing to the RAMPRCR bit is valid, when the KEY bits are written 1111000b.
	SRAM_SRAMPRCR_KW_1111000 = 0x78
	// Position of SRAMPRCR field.
	SRAM_SRAMPRCR_SRAMPRCR_Pos = 0x0
	// Bit mask of SRAMPRCR field.
	SRAM_SRAMPRCR_SRAMPRCR_Msk = 0x1
	// Bit SRAMPRCR.
	SRAM_SRAMPRCR_SRAMPRCR = 0x1
	// Disable writes to protected registers
	SRAM_SRAMPRCR_SRAMPRCR_0 = 0x0
	// Enable writes to protected registers.
	SRAM_SRAMPRCR_SRAMPRCR_1 = 0x1

	// ECCMODE: ECC Operating Mode Control Register
	// Position of Reserved field.
	SRAM_ECCMODE_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SRAM_ECCMODE_Reserved_Msk = 0xfc
	// Position of ECCMOD field.
	SRAM_ECCMODE_ECCMOD_Pos = 0x0
	// Bit mask of ECCMOD field.
	SRAM_ECCMODE_ECCMOD_Msk = 0x3
	// Disable ECC function
	SRAM_ECCMODE_ECCMOD_00 = 0x0
	// Setting prohibited
	SRAM_ECCMODE_ECCMOD_01 = 0x1
	// Enable ECC function without error checking
	SRAM_ECCMODE_ECCMOD_10 = 0x2
	// Enable ECC function with error checking
	SRAM_ECCMODE_ECCMOD_11 = 0x3

	// ECC2STS: ECC 2-Bit Error Status Register
	// Position of Reserved field.
	SRAM_ECC2STS_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SRAM_ECC2STS_Reserved_Msk = 0xfe
	// Position of ECC2ERR field.
	SRAM_ECC2STS_ECC2ERR_Pos = 0x0
	// Bit mask of ECC2ERR field.
	SRAM_ECC2STS_ECC2ERR_Msk = 0x1
	// Bit ECC2ERR.
	SRAM_ECC2STS_ECC2ERR = 0x1
	// No 2-bit ECC error occurred
	SRAM_ECC2STS_ECC2ERR_0 = 0x0
	// 2-bit ECC error occurred.
	SRAM_ECC2STS_ECC2ERR_1 = 0x1

	// ECC1STSEN: ECC 1-Bit Error Information Update Enable Register
	// Position of Reserved field.
	SRAM_ECC1STSEN_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SRAM_ECC1STSEN_Reserved_Msk = 0xfe
	// Position of E1STSEN field.
	SRAM_ECC1STSEN_E1STSEN_Pos = 0x0
	// Bit mask of E1STSEN field.
	SRAM_ECC1STSEN_E1STSEN_Msk = 0x1
	// Bit E1STSEN.
	SRAM_ECC1STSEN_E1STSEN = 0x1
	// Disables updating of the 1-bit ECC error information.
	SRAM_ECC1STSEN_E1STSEN_0 = 0x0
	// Enables updating of the 1-bit ECC error information.
	SRAM_ECC1STSEN_E1STSEN_1 = 0x1

	// ECC1STS: ECC 1-Bit Error Status Register
	// Position of Reserved field.
	SRAM_ECC1STS_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SRAM_ECC1STS_Reserved_Msk = 0xfe
	// Position of ECC1ERR field.
	SRAM_ECC1STS_ECC1ERR_Pos = 0x0
	// Bit mask of ECC1ERR field.
	SRAM_ECC1STS_ECC1ERR_Msk = 0x1
	// Bit ECC1ERR.
	SRAM_ECC1STS_ECC1ERR = 0x1
	// No 1-bit ECC error occurred
	SRAM_ECC1STS_ECC1ERR_0 = 0x0
	// 1-bit ECC error occurred
	SRAM_ECC1STS_ECC1ERR_1 = 0x1

	// ECCPRCR: ECC Protection Register
	// Position of KW field.
	SRAM_ECCPRCR_KW_Pos = 0x1
	// Bit mask of KW field.
	SRAM_ECCPRCR_KW_Msk = 0xfe
	// Writing to the ECCRAMPRCR bit is valid, when the KEY bits are written 1111000b.
	SRAM_ECCPRCR_KW_1111000 = 0x78
	// Position of ECCPRCR field.
	SRAM_ECCPRCR_ECCPRCR_Pos = 0x0
	// Bit mask of ECCPRCR field.
	SRAM_ECCPRCR_ECCPRCR_Msk = 0x1
	// Bit ECCPRCR.
	SRAM_ECCPRCR_ECCPRCR = 0x1
	// Disable writes to the protected registers
	SRAM_ECCPRCR_ECCPRCR_0 = 0x0
	// Enable writes to the protected registers
	SRAM_ECCPRCR_ECCPRCR_1 = 0x1

	// ECCPRCR2: ECC Protection Register 2
	// Position of KW2 field.
	SRAM_ECCPRCR2_KW2_Pos = 0x1
	// Bit mask of KW2 field.
	SRAM_ECCPRCR2_KW2_Msk = 0xfe
	// These bits enable or disable writes to the ECCPRCR2 bit..
	SRAM_ECCPRCR2_KW2_1111000 = 0x78
	// Position of ECCPRCR2 field.
	SRAM_ECCPRCR2_ECCPRCR2_Pos = 0x0
	// Bit mask of ECCPRCR2 field.
	SRAM_ECCPRCR2_ECCPRCR2_Msk = 0x1
	// Bit ECCPRCR2.
	SRAM_ECCPRCR2_ECCPRCR2 = 0x1
	// Disable writes to the protected registers
	SRAM_ECCPRCR2_ECCPRCR2_0 = 0x0
	// Enable writes to the protected registers.
	SRAM_ECCPRCR2_ECCPRCR2_1 = 0x1

	// ECCETST: ECC Test Control Register
	// Position of Reserved field.
	SRAM_ECCETST_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SRAM_ECCETST_Reserved_Msk = 0xfe
	// Position of TSTBYP field.
	SRAM_ECCETST_TSTBYP_Pos = 0x0
	// Bit mask of TSTBYP field.
	SRAM_ECCETST_TSTBYP_Msk = 0x1
	// Bit TSTBYP.
	SRAM_ECCETST_TSTBYP = 0x1
	// ECC bypass disabled.
	SRAM_ECCETST_TSTBYP_0 = 0x0
	// ECC bypass enabled.
	SRAM_ECCETST_TSTBYP_1 = 0x1

	// ECCOAD: SRAM ECC Error Operation After Detection Register
	// Position of Reserved field.
	SRAM_ECCOAD_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SRAM_ECCOAD_Reserved_Msk = 0xfe
	// Position of OAD field.
	SRAM_ECCOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SRAM_ECCOAD_OAD_Msk = 0x1
	// Bit OAD.
	SRAM_ECCOAD_OAD = 0x1
	// Non-maskable interrupt
	SRAM_ECCOAD_OAD_0 = 0x0
	// Reset
	SRAM_ECCOAD_OAD_1 = 0x1
)

// Constants for MMPU: Bus Master MPU
const (
	// MMPUCTLA: Bus Master MPU Control Register A
	// Position of KEY field.
	MMPU_MMPUCTLA_KEY_Pos = 0x8
	// Bit mask of KEY field.
	MMPU_MMPUCTLA_KEY_Msk = 0xff00
	// Position of Reserved field.
	MMPU_MMPUCTLA_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	MMPU_MMPUCTLA_Reserved_Msk = 0xfc
	// Position of OAD field.
	MMPU_MMPUCTLA_OAD_Pos = 0x1
	// Bit mask of OAD field.
	MMPU_MMPUCTLA_OAD_Msk = 0x2
	// Bit OAD.
	MMPU_MMPUCTLA_OAD = 0x2
	// Non-maskable interrupt.
	MMPU_MMPUCTLA_OAD_0 = 0x0
	// Internal reset.
	MMPU_MMPUCTLA_OAD_1 = 0x1
	// Position of ENABLE field.
	MMPU_MMPUCTLA_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MMPU_MMPUCTLA_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MMPU_MMPUCTLA_ENABLE = 0x1
	// Master Group A disabled
	MMPU_MMPUCTLA_ENABLE_0 = 0x0
	// Master Group A enabled.
	MMPU_MMPUCTLA_ENABLE_1 = 0x1

	// MMPUPTA: Group A Protection of Register
	// Position of KEY field.
	MMPU_MMPUPTA_KEY_Pos = 0x8
	// Bit mask of KEY field.
	MMPU_MMPUPTA_KEY_Msk = 0xff00
	// Writing to the PROTECT bit is valid, when the KEY bits are written 0xA5.
	MMPU_MMPUPTA_KEY_0xA5 = 0xa5
	// Position of Reserved field.
	MMPU_MMPUPTA_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	MMPU_MMPUPTA_Reserved_Msk = 0xfe
	// Position of PROTECT field.
	MMPU_MMPUPTA_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	MMPU_MMPUPTA_PROTECT_Msk = 0x1
	// Bit PROTECT.
	MMPU_MMPUPTA_PROTECT = 0x1
	// All Bus Master MPU Group A register writing is possible.
	MMPU_MMPUPTA_PROTECT_0 = 0x0
	// All Bus Master MPU Group A register writing is protected. Read is possible.
	MMPU_MMPUPTA_PROTECT_1 = 0x1

	// MMPUACA0: Group A Region %s Access Control Register
	// Position of Reserved field.
	MMPU_MMPUACA_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	MMPU_MMPUACA_Reserved_Msk = 0xfff8
	// Position of WP field.
	MMPU_MMPUACA_WP_Pos = 0x2
	// Bit mask of WP field.
	MMPU_MMPUACA_WP_Msk = 0x4
	// Bit WP.
	MMPU_MMPUACA_WP = 0x4
	// Write permission
	MMPU_MMPUACA_WP_0 = 0x0
	// Write protection
	MMPU_MMPUACA_WP_1 = 0x1
	// Position of RP field.
	MMPU_MMPUACA_RP_Pos = 0x1
	// Bit mask of RP field.
	MMPU_MMPUACA_RP_Msk = 0x2
	// Bit RP.
	MMPU_MMPUACA_RP = 0x2
	// Read permission
	MMPU_MMPUACA_RP_0 = 0x0
	// Read protection
	MMPU_MMPUACA_RP_1 = 0x1
	// Position of ENABLE field.
	MMPU_MMPUACA_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MMPU_MMPUACA_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MMPU_MMPUACA_ENABLE = 0x1
	// Group m Region n unit is disabled
	MMPU_MMPUACA_ENABLE_0 = 0x0
	// Group m Region n unit is enabled
	MMPU_MMPUACA_ENABLE_1 = 0x1

	// MMPUSA0: Group A Region %s Start Address Register
	// Position of MMPUSA field.
	MMPU_MMPUSA_MMPUSA_Pos = 0x0
	// Bit mask of MMPUSA field.
	MMPU_MMPUSA_MMPUSA_Msk = 0xffffffff

	// MMPUEA0: Group A Region %s End Address Register
	// Position of MMPUEA field.
	MMPU_MMPUEA_MMPUEA_Pos = 0x0
	// Bit mask of MMPUEA field.
	MMPU_MMPUEA_MMPUEA_Msk = 0xffffffff
)

// Constants for SMPU: Bus Slave MPU
const (
	// SMPUCTL: Slave MPU Control Register
	// Position of KEY field.
	SMPU_SMPUCTL_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SMPU_SMPUCTL_KEY_Msk = 0xff00
	// Writing to the PROTECT and OAD bit is valid, when the KEY bits are written 0xA5.
	SMPU_SMPUCTL_KEY_0xA5 = 0xa5
	// Position of Reserved field.
	SMPU_SMPUCTL_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SMPU_SMPUCTL_Reserved_Msk = 0xf8
	// Position of PROTECT field.
	SMPU_SMPUCTL_PROTECT_Pos = 0x1
	// Bit mask of PROTECT field.
	SMPU_SMPUCTL_PROTECT_Msk = 0x6
	// All Bus Slave register writing is possible.
	SMPU_SMPUCTL_PROTECT_0 = 0x0
	// All Bus Slave register writing is protected. Read is possible.
	SMPU_SMPUCTL_PROTECT_1 = 0x1
	// Position of OAD field.
	SMPU_SMPUCTL_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SMPU_SMPUCTL_OAD_Msk = 0x1
	// Bit OAD.
	SMPU_SMPUCTL_OAD = 0x1
	// Non-maskable interrupt.
	SMPU_SMPUCTL_OAD_0 = 0x0
	// Internal reset.
	SMPU_SMPUCTL_OAD_1 = 0x1

	// SMPUMBIU: Access Control Register for MBIU
	// Position of Reserved field.
	SMPU_SMPUMBIU_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SMPU_SMPUMBIU_Reserved_Msk = 0xfff0
	// Position of WPGRPA field.
	SMPU_SMPUMBIU_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	SMPU_SMPUMBIU_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	SMPU_SMPUMBIU_WPGRPA = 0x8
	// Master group A write of memory protection disabled.
	SMPU_SMPUMBIU_WPGRPA_0 = 0x0
	// Master group A write of memory protection enabled.
	SMPU_SMPUMBIU_WPGRPA_1 = 0x1
	// Position of RPGRPA field.
	SMPU_SMPUMBIU_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	SMPU_SMPUMBIU_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	SMPU_SMPUMBIU_RPGRPA = 0x4
	// Master group A read of memory protection disabled.
	SMPU_SMPUMBIU_RPGRPA_0 = 0x0
	// Master group A read of memory protection enabled.
	SMPU_SMPUMBIU_RPGRPA_1 = 0x1
	// Position of Reserved field.
	SMPU_SMPUMBIU_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SMPU_SMPUMBIU_Reserved_Msk = 0x3

	// SMPUFBIU: Access Control Register for FBIU
	// Position of Reserved field.
	SMPU_SMPUFBIU_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SMPU_SMPUFBIU_Reserved_Msk = 0xfff0
	// Position of WPGRPA field.
	SMPU_SMPUFBIU_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	SMPU_SMPUFBIU_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	SMPU_SMPUFBIU_WPGRPA = 0x8
	// Master group A write of memory protection disabled.
	SMPU_SMPUFBIU_WPGRPA_0 = 0x0
	// Master group A write of memory protection enabled.
	SMPU_SMPUFBIU_WPGRPA_1 = 0x1
	// Position of RPGRPA field.
	SMPU_SMPUFBIU_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	SMPU_SMPUFBIU_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	SMPU_SMPUFBIU_RPGRPA = 0x4
	// Master group A read of memory protection disabled.
	SMPU_SMPUFBIU_RPGRPA_0 = 0x0
	// Master group A read of memory protection enabled.
	SMPU_SMPUFBIU_RPGRPA_1 = 0x1
	// Position of WPCPU field.
	SMPU_SMPUFBIU_WPCPU_Pos = 0x1
	// Bit mask of WPCPU field.
	SMPU_SMPUFBIU_WPCPU_Msk = 0x2
	// Bit WPCPU.
	SMPU_SMPUFBIU_WPCPU = 0x2
	// CPU write of memory protection disabled.
	SMPU_SMPUFBIU_WPCPU_0 = 0x0
	// CPU write of memory protection enabled.
	SMPU_SMPUFBIU_WPCPU_1 = 0x1
	// Position of RPCPU field.
	SMPU_SMPUFBIU_RPCPU_Pos = 0x0
	// Bit mask of RPCPU field.
	SMPU_SMPUFBIU_RPCPU_Msk = 0x1
	// Bit RPCPU.
	SMPU_SMPUFBIU_RPCPU = 0x1
	// CPU read of memory protection disabled.
	SMPU_SMPUFBIU_RPCPU_0 = 0x0
	// CPU read of memory protection enabled.
	SMPU_SMPUFBIU_RPCPU_1 = 0x1

	// SMPUSRAM0: Access Control Register for SRAM0
	// Position of Reserved field.
	SMPU_SMPUSRAM0_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SMPU_SMPUSRAM0_Reserved_Msk = 0xfff0
	// Position of WPGRPA field.
	SMPU_SMPUSRAM0_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	SMPU_SMPUSRAM0_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	SMPU_SMPUSRAM0_WPGRPA = 0x8
	// Master group A write of memory protection disabled.
	SMPU_SMPUSRAM0_WPGRPA_0 = 0x0
	// Master group A write of memory protection enabled.
	SMPU_SMPUSRAM0_WPGRPA_1 = 0x1
	// Position of RPGRPA field.
	SMPU_SMPUSRAM0_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	SMPU_SMPUSRAM0_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	SMPU_SMPUSRAM0_RPGRPA = 0x4
	// Master group A read of memory protection disabled.
	SMPU_SMPUSRAM0_RPGRPA_0 = 0x0
	// Master group A read of memory protection enabled.
	SMPU_SMPUSRAM0_RPGRPA_1 = 0x1
	// Position of WPCPU field.
	SMPU_SMPUSRAM0_WPCPU_Pos = 0x1
	// Bit mask of WPCPU field.
	SMPU_SMPUSRAM0_WPCPU_Msk = 0x2
	// Bit WPCPU.
	SMPU_SMPUSRAM0_WPCPU = 0x2
	// CPU write of memory protection disabled.
	SMPU_SMPUSRAM0_WPCPU_0 = 0x0
	// CPU write of memory protection enabled.
	SMPU_SMPUSRAM0_WPCPU_1 = 0x1
	// Position of RPCPU field.
	SMPU_SMPUSRAM0_RPCPU_Pos = 0x0
	// Bit mask of RPCPU field.
	SMPU_SMPUSRAM0_RPCPU_Msk = 0x1
	// Bit RPCPU.
	SMPU_SMPUSRAM0_RPCPU = 0x1
	// CPU read of memory protection disabled.
	SMPU_SMPUSRAM0_RPCPU_0 = 0x0
	// CPU read of memory protection enabled.
	SMPU_SMPUSRAM0_RPCPU_1 = 0x1

	// SMPUP0BIU: Access Control Register for P%sBIU
	// Position of Reserved field.
	SMPU_SMPUPBIU_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SMPU_SMPUPBIU_Reserved_Msk = 0xfff0
	// Position of WPGRPA field.
	SMPU_SMPUPBIU_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	SMPU_SMPUPBIU_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	SMPU_SMPUPBIU_WPGRPA = 0x8
	// Master group A write of memory protection disabled.
	SMPU_SMPUPBIU_WPGRPA_0 = 0x0
	// Master group A write of memory protection enabled.
	SMPU_SMPUPBIU_WPGRPA_1 = 0x1
	// Position of RPGRPA field.
	SMPU_SMPUPBIU_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	SMPU_SMPUPBIU_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	SMPU_SMPUPBIU_RPGRPA = 0x4
	// Master group A read of memory protection disabled.
	SMPU_SMPUPBIU_RPGRPA_0 = 0x0
	// Master group A read of memory protection enabled.
	SMPU_SMPUPBIU_RPGRPA_1 = 0x1
	// Position of WPCPU field.
	SMPU_SMPUPBIU_WPCPU_Pos = 0x1
	// Bit mask of WPCPU field.
	SMPU_SMPUPBIU_WPCPU_Msk = 0x2
	// Bit WPCPU.
	SMPU_SMPUPBIU_WPCPU = 0x2
	// CPU write of memory protection disabled.
	SMPU_SMPUPBIU_WPCPU_0 = 0x0
	// CPU write of memory protection enabled.
	SMPU_SMPUPBIU_WPCPU_1 = 0x1
	// Position of RPCPU field.
	SMPU_SMPUPBIU_RPCPU_Pos = 0x0
	// Bit mask of RPCPU field.
	SMPU_SMPUPBIU_RPCPU_Msk = 0x1
	// Bit RPCPU.
	SMPU_SMPUPBIU_RPCPU = 0x1
	// CPU read of memory protection disabled.
	SMPU_SMPUPBIU_RPCPU_0 = 0x0
	// CPU read of memory protection enabled.
	SMPU_SMPUPBIU_RPCPU_1 = 0x1

	// SMPUEXBIU: Access Control Register for EXBIU
	// Position of Reserved field.
	SMPU_SMPUEXBIU_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SMPU_SMPUEXBIU_Reserved_Msk = 0xfff0
	// Position of WPGRPA field.
	SMPU_SMPUEXBIU_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	SMPU_SMPUEXBIU_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	SMPU_SMPUEXBIU_WPGRPA = 0x8
	// Master group A write of memory protection disabled.
	SMPU_SMPUEXBIU_WPGRPA_0 = 0x0
	// Master group A write of memory protection enabled.
	SMPU_SMPUEXBIU_WPGRPA_1 = 0x1
	// Position of RPGRPA field.
	SMPU_SMPUEXBIU_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	SMPU_SMPUEXBIU_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	SMPU_SMPUEXBIU_RPGRPA = 0x4
	// Master group A read of memory protection disabled.
	SMPU_SMPUEXBIU_RPGRPA_0 = 0x0
	// Master group A read of memory protection enabled.
	SMPU_SMPUEXBIU_RPGRPA_1 = 0x1
	// Position of WPCPU field.
	SMPU_SMPUEXBIU_WPCPU_Pos = 0x1
	// Bit mask of WPCPU field.
	SMPU_SMPUEXBIU_WPCPU_Msk = 0x2
	// Bit WPCPU.
	SMPU_SMPUEXBIU_WPCPU = 0x2
	// CPU write of memory protection disabled.
	SMPU_SMPUEXBIU_WPCPU_0 = 0x0
	// CPU write of memory protection enabled.
	SMPU_SMPUEXBIU_WPCPU_1 = 0x1
	// Position of RPCPU field.
	SMPU_SMPUEXBIU_RPCPU_Pos = 0x0
	// Bit mask of RPCPU field.
	SMPU_SMPUEXBIU_RPCPU_Msk = 0x1
	// Bit RPCPU.
	SMPU_SMPUEXBIU_RPCPU = 0x1
	// CPU read of memory protection disabled.
	SMPU_SMPUEXBIU_RPCPU_0 = 0x0
	// CPU read of memory protection enabled.
	SMPU_SMPUEXBIU_RPCPU_1 = 0x1

	// SMPUEXBIU2: Access Control Register for EXBIU2
	// Position of Reserved field.
	SMPU_SMPUEXBIU2_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SMPU_SMPUEXBIU2_Reserved_Msk = 0xfff0
	// Position of WPGRPA field.
	SMPU_SMPUEXBIU2_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	SMPU_SMPUEXBIU2_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	SMPU_SMPUEXBIU2_WPGRPA = 0x8
	// Master group A write of memory protection disabled.
	SMPU_SMPUEXBIU2_WPGRPA_0 = 0x0
	// Master group A write of memory protection enabled.
	SMPU_SMPUEXBIU2_WPGRPA_1 = 0x1
	// Position of RPGRPA field.
	SMPU_SMPUEXBIU2_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	SMPU_SMPUEXBIU2_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	SMPU_SMPUEXBIU2_RPGRPA = 0x4
	// Master group A read of memory protection disabled.
	SMPU_SMPUEXBIU2_RPGRPA_0 = 0x0
	// Master group A read of memory protection enabled.
	SMPU_SMPUEXBIU2_RPGRPA_1 = 0x1
	// Position of WPCPU field.
	SMPU_SMPUEXBIU2_WPCPU_Pos = 0x1
	// Bit mask of WPCPU field.
	SMPU_SMPUEXBIU2_WPCPU_Msk = 0x2
	// Bit WPCPU.
	SMPU_SMPUEXBIU2_WPCPU = 0x2
	// CPU write of memory protection disabled.
	SMPU_SMPUEXBIU2_WPCPU_0 = 0x0
	// CPU write of memory protection enabled.
	SMPU_SMPUEXBIU2_WPCPU_1 = 0x1
	// Position of RPCPU field.
	SMPU_SMPUEXBIU2_RPCPU_Pos = 0x0
	// Bit mask of RPCPU field.
	SMPU_SMPUEXBIU2_RPCPU_Msk = 0x1
	// Bit RPCPU.
	SMPU_SMPUEXBIU2_RPCPU = 0x1
	// CPU read of memory protection disabled.
	SMPU_SMPUEXBIU2_RPCPU_0 = 0x0
	// CPU read of memory protection enabled.
	SMPU_SMPUEXBIU2_RPCPU_1 = 0x1
)

// Constants for SPMON: CPU Stack Pointer Monitor
const (
	// MSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
	// Position of KEY field.
	SPMON_MSPMPUOAD_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SPMON_MSPMPUOAD_KEY_Msk = 0xff00
	// Writing to the OAD bit is valid, when the KEY bits are written 0xA5.
	SPMON_MSPMPUOAD_KEY_0xA5 = 0xa5
	// Position of Reserved field.
	SPMON_MSPMPUOAD_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SPMON_MSPMPUOAD_Reserved_Msk = 0xfe
	// Position of OAD field.
	SPMON_MSPMPUOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SPMON_MSPMPUOAD_OAD_Msk = 0x1
	// Bit OAD.
	SPMON_MSPMPUOAD_OAD = 0x1
	// Non-maskable interrupt
	SPMON_MSPMPUOAD_OAD_0 = 0x0
	// Reset.
	SPMON_MSPMPUOAD_OAD_1 = 0x1

	// MSPMPUCTL: Stack Pointer Monitor Access Control Register
	// Position of Reserved field.
	SPMON_MSPMPUCTL_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	SPMON_MSPMPUCTL_Reserved_Msk = 0xfe00
	// Position of ERROR field.
	SPMON_MSPMPUCTL_ERROR_Pos = 0x8
	// Bit mask of ERROR field.
	SPMON_MSPMPUCTL_ERROR_Msk = 0x100
	// Bit ERROR.
	SPMON_MSPMPUCTL_ERROR = 0x100
	// Stack pointer has not overflowed or underflowed
	SPMON_MSPMPUCTL_ERROR_0 = 0x0
	// Stack pointer has overflowed or underflowed
	SPMON_MSPMPUCTL_ERROR_1 = 0x1
	// Position of Reserved field.
	SPMON_MSPMPUCTL_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SPMON_MSPMPUCTL_Reserved_Msk = 0xfe
	// Position of ENABLE field.
	SPMON_MSPMPUCTL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPMON_MSPMPUCTL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SPMON_MSPMPUCTL_ENABLE = 0x1
	// Stack pointer monitor is disabled
	SPMON_MSPMPUCTL_ENABLE_0 = 0x0
	// Stack pointer monitor is enabled.
	SPMON_MSPMPUCTL_ENABLE_1 = 0x1

	// MSPMPUPT: Stack Pointer Monitor Protection Register
	// Position of KEY field.
	SPMON_MSPMPUPT_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SPMON_MSPMPUPT_KEY_Msk = 0xff00
	// Writing to the PROTECT bit is valid, when the KEY bits are written 0xA5.
	SPMON_MSPMPUPT_KEY_0xA5 = 0xa5
	// Position of Reserved field.
	SPMON_MSPMPUPT_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SPMON_MSPMPUPT_Reserved_Msk = 0xfe
	// Position of PROTECT field.
	SPMON_MSPMPUPT_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	SPMON_MSPMPUPT_PROTECT_Msk = 0x1
	// Bit PROTECT.
	SPMON_MSPMPUPT_PROTECT = 0x1
	// Stack Pointer Monitor register writing is possible.
	SPMON_MSPMPUPT_PROTECT_0 = 0x0
	// Stack Pointer Monitor register writing is protected.
	SPMON_MSPMPUPT_PROTECT_1 = 0x1

	// MSPMPUSA: Main Stack Pointer (MSP) Monitor Start Address Register
	// Position of MSPMPUSA field.
	SPMON_MSPMPUSA_MSPMPUSA_Pos = 0x0
	// Bit mask of MSPMPUSA field.
	SPMON_MSPMPUSA_MSPMPUSA_Msk = 0xffffffff

	// MSPMPUEA: Main Stack Pointer (MSP) Monitor End Address Register
	// Position of MSPMPUEA field.
	SPMON_MSPMPUEA_MSPMPUEA_Pos = 0x0
	// Bit mask of MSPMPUEA field.
	SPMON_MSPMPUEA_MSPMPUEA_Msk = 0xffffffff

	// PSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
	// Position of KEY field.
	SPMON_PSPMPUOAD_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SPMON_PSPMPUOAD_KEY_Msk = 0xff00
	// Writing to the OAD bit is valid, when the KEY bits are written 0xA5.
	SPMON_PSPMPUOAD_KEY_0xA5 = 0xa5
	// Position of Reserved field.
	SPMON_PSPMPUOAD_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SPMON_PSPMPUOAD_Reserved_Msk = 0xfe
	// Position of OAD field.
	SPMON_PSPMPUOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SPMON_PSPMPUOAD_OAD_Msk = 0x1
	// Bit OAD.
	SPMON_PSPMPUOAD_OAD = 0x1
	// Non-maskable interrupt
	SPMON_PSPMPUOAD_OAD_0 = 0x0
	// Reset.
	SPMON_PSPMPUOAD_OAD_1 = 0x1

	// PSPMPUCTL: Stack Pointer Monitor Access Control Register
	// Position of Reserved field.
	SPMON_PSPMPUCTL_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	SPMON_PSPMPUCTL_Reserved_Msk = 0xfe00
	// Position of ERROR field.
	SPMON_PSPMPUCTL_ERROR_Pos = 0x8
	// Bit mask of ERROR field.
	SPMON_PSPMPUCTL_ERROR_Msk = 0x100
	// Bit ERROR.
	SPMON_PSPMPUCTL_ERROR = 0x100
	// Stack pointer has not overflowed or underflowed
	SPMON_PSPMPUCTL_ERROR_0 = 0x0
	// Stack pointer has overflowed or underflowed
	SPMON_PSPMPUCTL_ERROR_1 = 0x1
	// Position of Reserved field.
	SPMON_PSPMPUCTL_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SPMON_PSPMPUCTL_Reserved_Msk = 0xfe
	// Position of ENABLE field.
	SPMON_PSPMPUCTL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPMON_PSPMPUCTL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SPMON_PSPMPUCTL_ENABLE = 0x1
	// Stack pointer monitor is disabled
	SPMON_PSPMPUCTL_ENABLE_0 = 0x0
	// Stack pointer monitor is enabled
	SPMON_PSPMPUCTL_ENABLE_1 = 0x1

	// PSPMPUPT: Stack Pointer Monitor Protection Register
	// Position of KEY field.
	SPMON_PSPMPUPT_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SPMON_PSPMPUPT_KEY_Msk = 0xff00
	// Writing to the PROTECT bit is valid, when the KEY bits are written 0xA5.
	SPMON_PSPMPUPT_KEY_0xA5 = 0xa5
	// Position of Reserved field.
	SPMON_PSPMPUPT_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SPMON_PSPMPUPT_Reserved_Msk = 0xfe
	// Position of PROTECT field.
	SPMON_PSPMPUPT_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	SPMON_PSPMPUPT_PROTECT_Msk = 0x1
	// Bit PROTECT.
	SPMON_PSPMPUPT_PROTECT = 0x1
	// Stack Pointer Monitor register writing is possible.
	SPMON_PSPMPUPT_PROTECT_0 = 0x0
	// Stack Pointer Monitor register writing is protected.
	SPMON_PSPMPUPT_PROTECT_1 = 0x1

	// PSPMPUSA: Process Stack Pointer (PSP) Monitor Start Address Register
	// Position of PSPMPUSA field.
	SPMON_PSPMPUSA_PSPMPUSA_Pos = 0x0
	// Bit mask of PSPMPUSA field.
	SPMON_PSPMPUSA_PSPMPUSA_Msk = 0xffffffff

	// PSPMPUEA: Process Stack Pointer (PSP) Monitor End Address Register
	// Position of PSPMPUEA field.
	SPMON_PSPMPUEA_PSPMPUEA_Pos = 0x0
	// Bit mask of PSPMPUEA field.
	SPMON_PSPMPUEA_PSPMPUEA_Msk = 0xffffffff
)

// Constants for MMF: Memory Mirror Function
const (
	// MMSFR: MemMirror Special Function Register
	// Position of KEY field.
	MMF_MMSFR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	MMF_MMSFR_KEY_Msk = 0xff000000
	// Writing to the MEMMIRADDR bits are valid, when the KEY bits are written 0xDB.
	MMF_MMSFR_KEY_0xDB = 0xdb
	// Position of Reserved field.
	MMF_MMSFR_Reserved_Pos = 0x17
	// Bit mask of Reserved field.
	MMF_MMSFR_Reserved_Msk = 0x800000
	// Bit Reserved.
	MMF_MMSFR_Reserved = 0x800000
	// Position of MEMMIRADDR field.
	MMF_MMSFR_MEMMIRADDR_Pos = 0x7
	// Bit mask of MEMMIRADDR field.
	MMF_MMSFR_MEMMIRADDR_Msk = 0x7fff80
	// Position of Reserved field.
	MMF_MMSFR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	MMF_MMSFR_Reserved_Msk = 0x7f

	// MMEN: MemMirror Enable Register
	// Position of KEY field.
	MMF_MMEN_KEY_Pos = 0x18
	// Bit mask of KEY field.
	MMF_MMEN_KEY_Msk = 0xff000000
	// Writing to the EN bit is valid, when the KEY bits are written 0xDB.
	MMF_MMEN_KEY_0xDB = 0xdb
	// Position of Reserved field.
	MMF_MMEN_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	MMF_MMEN_Reserved_Msk = 0xfffffe
	// Position of EN field.
	MMF_MMEN_EN_Pos = 0x0
	// Bit mask of EN field.
	MMF_MMEN_EN_Msk = 0x1
	// Bit EN.
	MMF_MMEN_EN = 0x1
	// Memory Mirror Function is enabled.
	MMF_MMEN_EN_1 = 0x1
	// Memory Mirror Function is disabled.
	MMF_MMEN_EN_0 = 0x0
)

// Constants for SPI0: Serial Peripheral Interface 0
const (
	// SPCR: SPI Control Register
	// Position of SPRIE field.
	SPI0_SPCR_SPRIE_Pos = 0x7
	// Bit mask of SPRIE field.
	SPI0_SPCR_SPRIE_Msk = 0x80
	// Bit SPRIE.
	SPI0_SPCR_SPRIE = 0x80
	// Disables the generation of SPI receive buffer full interrupt requests
	SPI0_SPCR_SPRIE_0 = 0x0
	// Enables the generation of SPI receive buffer full interrupt requests
	SPI0_SPCR_SPRIE_1 = 0x1
	// Position of SPE field.
	SPI0_SPCR_SPE_Pos = 0x6
	// Bit mask of SPE field.
	SPI0_SPCR_SPE_Msk = 0x40
	// Bit SPE.
	SPI0_SPCR_SPE = 0x40
	// Disables the SPI function
	SPI0_SPCR_SPE_0 = 0x0
	// Enables the SPI function
	SPI0_SPCR_SPE_1 = 0x1
	// Position of SPTIE field.
	SPI0_SPCR_SPTIE_Pos = 0x5
	// Bit mask of SPTIE field.
	SPI0_SPCR_SPTIE_Msk = 0x20
	// Bit SPTIE.
	SPI0_SPCR_SPTIE = 0x20
	// Disables the generation of transmit buffer empty interrupt requests
	SPI0_SPCR_SPTIE_0 = 0x0
	// Enables the generation of transmit buffer empty interrupt requests
	SPI0_SPCR_SPTIE_1 = 0x1
	// Position of SPEIE field.
	SPI0_SPCR_SPEIE_Pos = 0x4
	// Bit mask of SPEIE field.
	SPI0_SPCR_SPEIE_Msk = 0x10
	// Bit SPEIE.
	SPI0_SPCR_SPEIE = 0x10
	// Disables the generation of SPI error interrupt requests
	SPI0_SPCR_SPEIE_0 = 0x0
	// Enables the generation of SPI error interrupt requests
	SPI0_SPCR_SPEIE_1 = 0x1
	// Position of MSTR field.
	SPI0_SPCR_MSTR_Pos = 0x3
	// Bit mask of MSTR field.
	SPI0_SPCR_MSTR_Msk = 0x8
	// Bit MSTR.
	SPI0_SPCR_MSTR = 0x8
	// Slave mode
	SPI0_SPCR_MSTR_0 = 0x0
	// Master mode
	SPI0_SPCR_MSTR_1 = 0x1
	// Position of MODFEN field.
	SPI0_SPCR_MODFEN_Pos = 0x2
	// Bit mask of MODFEN field.
	SPI0_SPCR_MODFEN_Msk = 0x4
	// Bit MODFEN.
	SPI0_SPCR_MODFEN = 0x4
	// Disables the detection of mode fault error
	SPI0_SPCR_MODFEN_0 = 0x0
	// Enables the detection of mode fault error
	SPI0_SPCR_MODFEN_1 = 0x1
	// Position of TXMD field.
	SPI0_SPCR_TXMD_Pos = 0x1
	// Bit mask of TXMD field.
	SPI0_SPCR_TXMD_Msk = 0x2
	// Bit TXMD.
	SPI0_SPCR_TXMD = 0x2
	// Full-duplex synchronous serial communications
	SPI0_SPCR_TXMD_0 = 0x0
	// Serial communications consisting of only transmit operations
	SPI0_SPCR_TXMD_1 = 0x1
	// Position of SPMS field.
	SPI0_SPCR_SPMS_Pos = 0x0
	// Bit mask of SPMS field.
	SPI0_SPCR_SPMS_Msk = 0x1
	// Bit SPMS.
	SPI0_SPCR_SPMS = 0x1
	// SPI operation (4-wire method)
	SPI0_SPCR_SPMS_0 = 0x0
	// Clock synchronous operation (3-wire method)
	SPI0_SPCR_SPMS_1 = 0x1

	// SSLP: SPI Slave Select Polarity Register
	// Position of Reserved field.
	SPI0_SSLP_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SPI0_SSLP_Reserved_Msk = 0xf0
	// Position of SSL3P field.
	SPI0_SSLP_SSL3P_Pos = 0x3
	// Bit mask of SSL3P field.
	SPI0_SSLP_SSL3P_Msk = 0x8
	// Bit SSL3P.
	SPI0_SSLP_SSL3P = 0x8
	// SSL3 signal is active low
	SPI0_SSLP_SSL3P_0 = 0x0
	// SSL3 signal is active high
	SPI0_SSLP_SSL3P_1 = 0x1
	// Position of SSL2P field.
	SPI0_SSLP_SSL2P_Pos = 0x2
	// Bit mask of SSL2P field.
	SPI0_SSLP_SSL2P_Msk = 0x4
	// Bit SSL2P.
	SPI0_SSLP_SSL2P = 0x4
	// SSL2 signal is active low
	SPI0_SSLP_SSL2P_0 = 0x0
	// SSL2 signal is active high
	SPI0_SSLP_SSL2P_1 = 0x1
	// Position of SSL1P field.
	SPI0_SSLP_SSL1P_Pos = 0x1
	// Bit mask of SSL1P field.
	SPI0_SSLP_SSL1P_Msk = 0x2
	// Bit SSL1P.
	SPI0_SSLP_SSL1P = 0x2
	// SSL1 signal is active low
	SPI0_SSLP_SSL1P_0 = 0x0
	// SSL1 signal is active high
	SPI0_SSLP_SSL1P_1 = 0x1
	// Position of SSL0P field.
	SPI0_SSLP_SSL0P_Pos = 0x0
	// Bit mask of SSL0P field.
	SPI0_SSLP_SSL0P_Msk = 0x1
	// Bit SSL0P.
	SPI0_SSLP_SSL0P = 0x1
	// SSL0 signal is active low
	SPI0_SSLP_SSL0P_0 = 0x0
	// SSL0 signal is active high
	SPI0_SSLP_SSL0P_1 = 0x1

	// SPPCR: SPI Pin Control Register
	// Position of Reserved field.
	SPI0_SPPCR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SPI0_SPPCR_Reserved_Msk = 0xc0
	// Position of MOIFE field.
	SPI0_SPPCR_MOIFE_Pos = 0x5
	// Bit mask of MOIFE field.
	SPI0_SPPCR_MOIFE_Msk = 0x20
	// Bit MOIFE.
	SPI0_SPPCR_MOIFE = 0x20
	// MOSI output value equals final data from previous transfer
	SPI0_SPPCR_MOIFE_0 = 0x0
	// MOSI output value equals the value set in the MOIFV bit
	SPI0_SPPCR_MOIFE_1 = 0x1
	// Position of MOIFV field.
	SPI0_SPPCR_MOIFV_Pos = 0x4
	// Bit mask of MOIFV field.
	SPI0_SPPCR_MOIFV_Msk = 0x10
	// Bit MOIFV.
	SPI0_SPPCR_MOIFV = 0x10
	// The level output on the MOSIn pin during MOSI idling corresponds to low.
	SPI0_SPPCR_MOIFV_0 = 0x0
	// The level output on the MOSIn pin during MOSI idling corresponds to high.
	SPI0_SPPCR_MOIFV_1 = 0x1
	// Position of Reserved field.
	SPI0_SPPCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SPI0_SPPCR_Reserved_Msk = 0xc
	// Position of SPLP2 field.
	SPI0_SPPCR_SPLP2_Pos = 0x1
	// Bit mask of SPLP2 field.
	SPI0_SPPCR_SPLP2_Msk = 0x2
	// Bit SPLP2.
	SPI0_SPPCR_SPLP2 = 0x2
	// Normal mode
	SPI0_SPPCR_SPLP2_0 = 0x0
	// Loopback mode (data is not inverted for transmission)
	SPI0_SPPCR_SPLP2_1 = 0x1
	// Position of SPLP field.
	SPI0_SPPCR_SPLP_Pos = 0x0
	// Bit mask of SPLP field.
	SPI0_SPPCR_SPLP_Msk = 0x1
	// Bit SPLP.
	SPI0_SPPCR_SPLP = 0x1
	// Normal mode
	SPI0_SPPCR_SPLP_0 = 0x0
	// Loopback mode (data is inverted for transmission)
	SPI0_SPPCR_SPLP_1 = 0x1

	// SPSR: SPI Status Register
	// Position of SPRF field.
	SPI0_SPSR_SPRF_Pos = 0x7
	// Bit mask of SPRF field.
	SPI0_SPSR_SPRF_Msk = 0x80
	// Bit SPRF.
	SPI0_SPSR_SPRF = 0x80
	// No valid data in SPDR
	SPI0_SPSR_SPRF_0 = 0x0
	// Valid data found in SPDR
	SPI0_SPSR_SPRF_1 = 0x1
	// Position of Reserved field.
	SPI0_SPSR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SPI0_SPSR_Reserved_Msk = 0x40
	// Bit Reserved.
	SPI0_SPSR_Reserved = 0x40
	// Position of SPTEF field.
	SPI0_SPSR_SPTEF_Pos = 0x5
	// Bit mask of SPTEF field.
	SPI0_SPSR_SPTEF_Msk = 0x20
	// Bit SPTEF.
	SPI0_SPSR_SPTEF = 0x20
	// Data found in the transmit buffer
	SPI0_SPSR_SPTEF_0 = 0x0
	// No data in the transmit buffer
	SPI0_SPSR_SPTEF_1 = 0x1
	// Position of UDRF field.
	SPI0_SPSR_UDRF_Pos = 0x4
	// Bit mask of UDRF field.
	SPI0_SPSR_UDRF_Msk = 0x10
	// Bit UDRF.
	SPI0_SPSR_UDRF = 0x10
	// A mode fault error occurs (MODF=1)
	SPI0_SPSR_UDRF_0 = 0x0
	// An underrun error occurs (MODF=1)
	SPI0_SPSR_UDRF_1 = 0x1
	// Position of PERF field.
	SPI0_SPSR_PERF_Pos = 0x3
	// Bit mask of PERF field.
	SPI0_SPSR_PERF_Msk = 0x8
	// Bit PERF.
	SPI0_SPSR_PERF = 0x8
	// No parity error occurs
	SPI0_SPSR_PERF_0 = 0x0
	// A parity error occurs
	SPI0_SPSR_PERF_1 = 0x1
	// Position of MODF field.
	SPI0_SPSR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI0_SPSR_MODF_Msk = 0x4
	// Bit MODF.
	SPI0_SPSR_MODF = 0x4
	// Neither mode fault error nor underrun error occurs
	SPI0_SPSR_MODF_0 = 0x0
	// A mode fault error or an underrun error occurs.
	SPI0_SPSR_MODF_1 = 0x1
	// Position of IDLNF field.
	SPI0_SPSR_IDLNF_Pos = 0x1
	// Bit mask of IDLNF field.
	SPI0_SPSR_IDLNF_Msk = 0x2
	// Bit IDLNF.
	SPI0_SPSR_IDLNF = 0x2
	// SPI is in the idle state
	SPI0_SPSR_IDLNF_0 = 0x0
	// SPI is in the transfer state
	SPI0_SPSR_IDLNF_1 = 0x1
	// Position of OVRF field.
	SPI0_SPSR_OVRF_Pos = 0x0
	// Bit mask of OVRF field.
	SPI0_SPSR_OVRF_Msk = 0x1
	// Bit OVRF.
	SPI0_SPSR_OVRF = 0x1
	// No overrun error occurs
	SPI0_SPSR_OVRF_0 = 0x0
	// An overrun error occurs
	SPI0_SPSR_OVRF_1 = 0x1

	// SPDR: SPI Data Register
	// Position of SPDR field.
	SPI0_SPDR_SPDR_Pos = 0x0
	// Bit mask of SPDR field.
	SPI0_SPDR_SPDR_Msk = 0xffffffff

	// SPDR_HA: SPI Data Register ( halfword access )
	// Position of SPDR_HA field.
	SPI0_SPDR_HA_SPDR_HA_Pos = 0x0
	// Bit mask of SPDR_HA field.
	SPI0_SPDR_HA_SPDR_HA_Msk = 0xffff

	// SPSCR: SPI Sequence Control Register
	// Position of Reserved field.
	SPI0_SPSCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SPI0_SPSCR_Reserved_Msk = 0xf8
	// Position of SPSLN field.
	SPI0_SPSCR_SPSLN_Pos = 0x0
	// Bit mask of SPSLN field.
	SPI0_SPSCR_SPSLN_Msk = 0x7
	// Length 1 SPDMDx x = 0->0->...
	SPI0_SPSCR_SPSLN_000 = 0x0
	// Length 2 SPDMDx x = 0->1->0->...
	SPI0_SPSCR_SPSLN_001 = 0x1
	// Length 3 SPDMDx x = 0->1->2->0->...
	SPI0_SPSCR_SPSLN_010 = 0x2
	// Length 4 SPDMDx x = 0->1->2->3->0->...
	SPI0_SPSCR_SPSLN_011 = 0x3
	// Length 5 SPDMDx x = 0->1->2->3->4->0->...
	SPI0_SPSCR_SPSLN_100 = 0x4
	// Length 6 SPDMDx x = 0->1->2->3->4->5->0->...
	SPI0_SPSCR_SPSLN_101 = 0x5
	// Length 7 SPDMDx x = 0->1->2->3->4->5->6->0->...
	SPI0_SPSCR_SPSLN_110 = 0x6
	// Length 8 SPDMDx x = 0->1->2->3->4->5->6->7->0->...
	SPI0_SPSCR_SPSLN_111 = 0x7

	// SPSSR: SPI Sequence Status Register
	// Position of Reserved field.
	SPI0_SPSSR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	SPI0_SPSSR_Reserved_Msk = 0x80
	// Bit Reserved.
	SPI0_SPSSR_Reserved = 0x80
	// Position of SPECM field.
	SPI0_SPSSR_SPECM_Pos = 0x4
	// Bit mask of SPECM field.
	SPI0_SPSSR_SPECM_Msk = 0x70
	// SPCMD0
	SPI0_SPSSR_SPECM_000 = 0x0
	// SPCMD1
	SPI0_SPSSR_SPECM_001 = 0x1
	// SPCMD2
	SPI0_SPSSR_SPECM_010 = 0x2
	// SPCMD3
	SPI0_SPSSR_SPECM_011 = 0x3
	// SPCMD4
	SPI0_SPSSR_SPECM_100 = 0x4
	// SPCMD5
	SPI0_SPSSR_SPECM_101 = 0x5
	// SPCMD6
	SPI0_SPSSR_SPECM_110 = 0x6
	// SPCMD7
	SPI0_SPSSR_SPECM_111 = 0x7
	// Position of Reserved field.
	SPI0_SPSSR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SPI0_SPSSR_Reserved_Msk = 0x8
	// Bit Reserved.
	SPI0_SPSSR_Reserved = 0x8
	// Position of SPCP field.
	SPI0_SPSSR_SPCP_Pos = 0x0
	// Bit mask of SPCP field.
	SPI0_SPSSR_SPCP_Msk = 0x7
	// SPCMD0
	SPI0_SPSSR_SPCP_000 = 0x0
	// SPCMD1
	SPI0_SPSSR_SPCP_001 = 0x1
	// SPCMD2
	SPI0_SPSSR_SPCP_010 = 0x2
	// SPCMD3
	SPI0_SPSSR_SPCP_011 = 0x3
	// SPCMD4
	SPI0_SPSSR_SPCP_100 = 0x4
	// SPCMD5
	SPI0_SPSSR_SPCP_101 = 0x5
	// SPCMD6
	SPI0_SPSSR_SPCP_110 = 0x6
	// SPCMD7
	SPI0_SPSSR_SPCP_111 = 0x7

	// SPBR: SPI Bit Rate Register
	// Position of SPR field.
	SPI0_SPBR_SPR_Pos = 0x0
	// Bit mask of SPR field.
	SPI0_SPBR_SPR_Msk = 0xff

	// SPDCR: SPI Data Control Register
	// Position of Reserved field.
	SPI0_SPDCR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SPI0_SPDCR_Reserved_Msk = 0xc0
	// Position of SPLW field.
	SPI0_SPDCR_SPLW_Pos = 0x5
	// Bit mask of SPLW field.
	SPI0_SPDCR_SPLW_Msk = 0x20
	// Bit SPLW.
	SPI0_SPDCR_SPLW = 0x20
	// SPDR_HA is valid to access in halfwords
	SPI0_SPDCR_SPLW_0 = 0x0
	// SPDR is valid (to access in words).
	SPI0_SPDCR_SPLW_1 = 0x1
	// Position of SPRDTD field.
	SPI0_SPDCR_SPRDTD_Pos = 0x4
	// Bit mask of SPRDTD field.
	SPI0_SPDCR_SPRDTD_Msk = 0x10
	// Bit SPRDTD.
	SPI0_SPDCR_SPRDTD = 0x10
	// SPDR values are read from the receive buffer
	SPI0_SPDCR_SPRDTD_0 = 0x0
	// SPDR values are read from the transmit buffer (but only if the transmit buffer is empty)
	SPI0_SPDCR_SPRDTD_1 = 0x1
	// Position of Reserved field.
	SPI0_SPDCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SPI0_SPDCR_Reserved_Msk = 0xc
	// Position of SPFC field.
	SPI0_SPDCR_SPFC_Pos = 0x0
	// Bit mask of SPFC field.
	SPI0_SPDCR_SPFC_Msk = 0x3
	// 1 frame
	SPI0_SPDCR_SPFC_00 = 0x0
	// 2 frames
	SPI0_SPDCR_SPFC_01 = 0x1
	// 3 frames
	SPI0_SPDCR_SPFC_10 = 0x2
	// 4 frames.
	SPI0_SPDCR_SPFC_11 = 0x3

	// SPCKD: SPI Clock Delay Register
	// Position of Reserved field.
	SPI0_SPCKD_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SPI0_SPCKD_Reserved_Msk = 0xf8
	// Position of SCKDL field.
	SPI0_SPCKD_SCKDL_Pos = 0x0
	// Bit mask of SCKDL field.
	SPI0_SPCKD_SCKDL_Msk = 0x7
	// 1 RSPCK
	SPI0_SPCKD_SCKDL_000 = 0x0
	// 2 RSPCK
	SPI0_SPCKD_SCKDL_001 = 0x1
	// 3 RSPCK
	SPI0_SPCKD_SCKDL_010 = 0x2
	// 4 RSPCK
	SPI0_SPCKD_SCKDL_011 = 0x3
	// 5 RSPCK
	SPI0_SPCKD_SCKDL_100 = 0x4
	// 6 RSPCK
	SPI0_SPCKD_SCKDL_101 = 0x5
	// 7 RSPCK
	SPI0_SPCKD_SCKDL_110 = 0x6
	// 8 RSPCK
	SPI0_SPCKD_SCKDL_111 = 0x7

	// SSLND: SPI Slave Select Negation Delay Register
	// Position of Reserved field.
	SPI0_SSLND_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SPI0_SSLND_Reserved_Msk = 0xf8
	// Position of SLNDL field.
	SPI0_SSLND_SLNDL_Pos = 0x0
	// Bit mask of SLNDL field.
	SPI0_SSLND_SLNDL_Msk = 0x7
	// 1 RSPCK
	SPI0_SSLND_SLNDL_000 = 0x0
	// 2 RSPCK
	SPI0_SSLND_SLNDL_001 = 0x1
	// 3 RSPCK
	SPI0_SSLND_SLNDL_010 = 0x2
	// 4 RSPCK
	SPI0_SSLND_SLNDL_011 = 0x3
	// 5 RSPCK
	SPI0_SSLND_SLNDL_100 = 0x4
	// 6 RSPCK
	SPI0_SSLND_SLNDL_101 = 0x5
	// 7 RSPCK
	SPI0_SSLND_SLNDL_110 = 0x6
	// 8 RSPCK
	SPI0_SSLND_SLNDL_111 = 0x7

	// SPND: SPI Next-Access Delay Register
	// Position of Reserved field.
	SPI0_SPND_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SPI0_SPND_Reserved_Msk = 0xf8
	// Position of SPNDL field.
	SPI0_SPND_SPNDL_Pos = 0x0
	// Bit mask of SPNDL field.
	SPI0_SPND_SPNDL_Msk = 0x7
	// 1 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_000 = 0x0
	// 2 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_001 = 0x1
	// 3 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_010 = 0x2
	// 4 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_011 = 0x3
	// 5 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_100 = 0x4
	// 6 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_101 = 0x5
	// 7 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_110 = 0x6
	// 8 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_111 = 0x7

	// SPCR2: SPI Control Register 2
	// Position of Reserved field.
	SPI0_SPCR2_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SPI0_SPCR2_Reserved_Msk = 0xe0
	// Position of SCKASE field.
	SPI0_SPCR2_SCKASE_Pos = 0x4
	// Bit mask of SCKASE field.
	SPI0_SPCR2_SCKASE_Msk = 0x10
	// Bit SCKASE.
	SPI0_SPCR2_SCKASE = 0x10
	// Disables the RSPCK auto-stop function
	SPI0_SPCR2_SCKASE_0 = 0x0
	// Enables the RSPCK auto-stop function
	SPI0_SPCR2_SCKASE_1 = 0x1
	// Position of PTE field.
	SPI0_SPCR2_PTE_Pos = 0x3
	// Bit mask of PTE field.
	SPI0_SPCR2_PTE_Msk = 0x8
	// Bit PTE.
	SPI0_SPCR2_PTE = 0x8
	// Disables the self-diagnosis function of the parity circuit
	SPI0_SPCR2_PTE_0 = 0x0
	// Enables the self-diagnosis function of the parity circuit
	SPI0_SPCR2_PTE_1 = 0x1
	// Position of SPIIE field.
	SPI0_SPCR2_SPIIE_Pos = 0x2
	// Bit mask of SPIIE field.
	SPI0_SPCR2_SPIIE_Msk = 0x4
	// Bit SPIIE.
	SPI0_SPCR2_SPIIE = 0x4
	// Disables the generation of idle interrupt requests
	SPI0_SPCR2_SPIIE_0 = 0x0
	// Enables the generation of idle interrupt requests
	SPI0_SPCR2_SPIIE_1 = 0x1
	// Position of SPOE field.
	SPI0_SPCR2_SPOE_Pos = 0x1
	// Bit mask of SPOE field.
	SPI0_SPCR2_SPOE_Msk = 0x2
	// Bit SPOE.
	SPI0_SPCR2_SPOE = 0x2
	// Selects even parity for use in transmission and reception
	SPI0_SPCR2_SPOE_0 = 0x0
	// Selects odd parity for use in transmission and reception
	SPI0_SPCR2_SPOE_1 = 0x1
	// Position of SPPE field.
	SPI0_SPCR2_SPPE_Pos = 0x0
	// Bit mask of SPPE field.
	SPI0_SPCR2_SPPE_Msk = 0x1
	// Bit SPPE.
	SPI0_SPCR2_SPPE = 0x1
	// Does not add the parity bit to transmit data and does not check the parity bit of receive data
	SPI0_SPCR2_SPPE_0 = 0x0
	// Adds the parity bit to transmit data and checks the parity bit of receive data (when SPCR.TXMD = 0) / Adds the parity bit to transmit data but does not check the parity bit of receive data (when SPCR.TXMD = 1)
	SPI0_SPCR2_SPPE_1 = 0x1

	// SPCMD0: SPI Command Register %s
	// Position of SCKDEN field.
	SPI0_SPCMD_SCKDEN_Pos = 0xf
	// Bit mask of SCKDEN field.
	SPI0_SPCMD_SCKDEN_Msk = 0x8000
	// Bit SCKDEN.
	SPI0_SPCMD_SCKDEN = 0x8000
	// An RSPCK delay of 1 RSPCK
	SPI0_SPCMD_SCKDEN_0 = 0x0
	// An RSPCK delay is equal to the setting of the RSPI clock delay register (SPCKD)
	SPI0_SPCMD_SCKDEN_1 = 0x1
	// Position of SLNDEN field.
	SPI0_SPCMD_SLNDEN_Pos = 0xe
	// Bit mask of SLNDEN field.
	SPI0_SPCMD_SLNDEN_Msk = 0x4000
	// Bit SLNDEN.
	SPI0_SPCMD_SLNDEN = 0x4000
	// An SSL negation delay of 1 RSPCK
	SPI0_SPCMD_SLNDEN_0 = 0x0
	// An SSL negation delay is equal to the setting of the RSPI slave select negation delay register (SSLND)
	SPI0_SPCMD_SLNDEN_1 = 0x1
	// Position of SPNDEN field.
	SPI0_SPCMD_SPNDEN_Pos = 0xd
	// Bit mask of SPNDEN field.
	SPI0_SPCMD_SPNDEN_Msk = 0x2000
	// Bit SPNDEN.
	SPI0_SPCMD_SPNDEN = 0x2000
	// A next-access delay of 1 RSPCK + 2 PCLK
	SPI0_SPCMD_SPNDEN_0 = 0x0
	// A next-access delay is equal to the setting of the RSPI next-access delay register (SPND)
	SPI0_SPCMD_SPNDEN_1 = 0x1
	// Position of LSBF field.
	SPI0_SPCMD_LSBF_Pos = 0xc
	// Bit mask of LSBF field.
	SPI0_SPCMD_LSBF_Msk = 0x1000
	// Bit LSBF.
	SPI0_SPCMD_LSBF = 0x1000
	// MSB first
	SPI0_SPCMD_LSBF_0 = 0x0
	// LSB first
	SPI0_SPCMD_LSBF_1 = 0x1
	// Position of SPB field.
	SPI0_SPCMD_SPB_Pos = 0x8
	// Bit mask of SPB field.
	SPI0_SPCMD_SPB_Msk = 0xf00
	// 20 bits
	SPI0_SPCMD_SPB_0000 = 0x0
	// 24 bits
	SPI0_SPCMD_SPB_0001 = 0x1
	// 32 bits
	SPI0_SPCMD_SPB_0010 = 0x2
	// 32 bits
	SPI0_SPCMD_SPB_0011 = 0x3
	// 9 bits
	SPI0_SPCMD_SPB_1000 = 0x8
	// 10 bits
	SPI0_SPCMD_SPB_1001 = 0x9
	// 11 bits
	SPI0_SPCMD_SPB_1010 = 0xa
	// 12 bits
	SPI0_SPCMD_SPB_1011 = 0xb
	// 13 bits
	SPI0_SPCMD_SPB_1100 = 0xc
	// 14 bits
	SPI0_SPCMD_SPB_1101 = 0xd
	// 15 bits
	SPI0_SPCMD_SPB_1110 = 0xe
	// 16 bits
	SPI0_SPCMD_SPB_1111 = 0xf
	// Position of SSLKP field.
	SPI0_SPCMD_SSLKP_Pos = 0x7
	// Bit mask of SSLKP field.
	SPI0_SPCMD_SSLKP_Msk = 0x80
	// Bit SSLKP.
	SPI0_SPCMD_SSLKP = 0x80
	// Negates all SSL signals upon completion of transfer
	SPI0_SPCMD_SSLKP_0 = 0x0
	// Keeps the SSL signal level from the end of transfer until the beginning of the next access
	SPI0_SPCMD_SSLKP_1 = 0x1
	// Position of SSLA field.
	SPI0_SPCMD_SSLA_Pos = 0x4
	// Bit mask of SSLA field.
	SPI0_SPCMD_SSLA_Msk = 0x70
	// SSL0
	SPI0_SPCMD_SSLA_000 = 0x0
	// SSL1
	SPI0_SPCMD_SSLA_001 = 0x1
	// SSL2
	SPI0_SPCMD_SSLA_010 = 0x2
	// SSL3
	SPI0_SPCMD_SSLA_011 = 0x3
	// Position of BRDV field.
	SPI0_SPCMD_BRDV_Pos = 0x2
	// Bit mask of BRDV field.
	SPI0_SPCMD_BRDV_Msk = 0xc
	// These bits select the base bit rate
	SPI0_SPCMD_BRDV_00 = 0x0
	// These bits select the base bit rate divided by 2
	SPI0_SPCMD_BRDV_01 = 0x1
	// These bits select the base bit rate divided by 4
	SPI0_SPCMD_BRDV_10 = 0x2
	// These bits select the base bit rate divided by 8
	SPI0_SPCMD_BRDV_11 = 0x3
	// Position of CPOL field.
	SPI0_SPCMD_CPOL_Pos = 0x1
	// Bit mask of CPOL field.
	SPI0_SPCMD_CPOL_Msk = 0x2
	// Bit CPOL.
	SPI0_SPCMD_CPOL = 0x2
	// RSPCK is low when idle
	SPI0_SPCMD_CPOL_0 = 0x0
	// RSPCK is high when idle
	SPI0_SPCMD_CPOL_1 = 0x1
	// Position of CPHA field.
	SPI0_SPCMD_CPHA_Pos = 0x0
	// Bit mask of CPHA field.
	SPI0_SPCMD_CPHA_Msk = 0x1
	// Bit CPHA.
	SPI0_SPCMD_CPHA = 0x1
	// Data sampling on odd edge, data variation on even edge
	SPI0_SPCMD_CPHA_0 = 0x0
	// Data variation on odd edge, data sampling on even edge
	SPI0_SPCMD_CPHA_1 = 0x1
)

// Constants for SPI1: Serial Peripheral Interface 1
const (
	// SPCR: SPI Control Register
	// Position of SPRIE field.
	SPI1_SPCR_SPRIE_Pos = 0x7
	// Bit mask of SPRIE field.
	SPI1_SPCR_SPRIE_Msk = 0x80
	// Bit SPRIE.
	SPI1_SPCR_SPRIE = 0x80
	// Disables the generation of SPI receive buffer full interrupt requests
	SPI1_SPCR_SPRIE_0 = 0x0
	// Enables the generation of SPI receive buffer full interrupt requests
	SPI1_SPCR_SPRIE_1 = 0x1
	// Position of SPE field.
	SPI1_SPCR_SPE_Pos = 0x6
	// Bit mask of SPE field.
	SPI1_SPCR_SPE_Msk = 0x40
	// Bit SPE.
	SPI1_SPCR_SPE = 0x40
	// Disables the SPI function
	SPI1_SPCR_SPE_0 = 0x0
	// Enables the SPI function
	SPI1_SPCR_SPE_1 = 0x1
	// Position of SPTIE field.
	SPI1_SPCR_SPTIE_Pos = 0x5
	// Bit mask of SPTIE field.
	SPI1_SPCR_SPTIE_Msk = 0x20
	// Bit SPTIE.
	SPI1_SPCR_SPTIE = 0x20
	// Disables the generation of transmit buffer empty interrupt requests
	SPI1_SPCR_SPTIE_0 = 0x0
	// Enables the generation of transmit buffer empty interrupt requests
	SPI1_SPCR_SPTIE_1 = 0x1
	// Position of SPEIE field.
	SPI1_SPCR_SPEIE_Pos = 0x4
	// Bit mask of SPEIE field.
	SPI1_SPCR_SPEIE_Msk = 0x10
	// Bit SPEIE.
	SPI1_SPCR_SPEIE = 0x10
	// Disables the generation of SPI error interrupt requests
	SPI1_SPCR_SPEIE_0 = 0x0
	// Enables the generation of SPI error interrupt requests
	SPI1_SPCR_SPEIE_1 = 0x1
	// Position of MSTR field.
	SPI1_SPCR_MSTR_Pos = 0x3
	// Bit mask of MSTR field.
	SPI1_SPCR_MSTR_Msk = 0x8
	// Bit MSTR.
	SPI1_SPCR_MSTR = 0x8
	// Slave mode
	SPI1_SPCR_MSTR_0 = 0x0
	// Master mode
	SPI1_SPCR_MSTR_1 = 0x1
	// Position of MODFEN field.
	SPI1_SPCR_MODFEN_Pos = 0x2
	// Bit mask of MODFEN field.
	SPI1_SPCR_MODFEN_Msk = 0x4
	// Bit MODFEN.
	SPI1_SPCR_MODFEN = 0x4
	// Disables the detection of mode fault error
	SPI1_SPCR_MODFEN_0 = 0x0
	// Enables the detection of mode fault error
	SPI1_SPCR_MODFEN_1 = 0x1
	// Position of TXMD field.
	SPI1_SPCR_TXMD_Pos = 0x1
	// Bit mask of TXMD field.
	SPI1_SPCR_TXMD_Msk = 0x2
	// Bit TXMD.
	SPI1_SPCR_TXMD = 0x2
	// Full-duplex synchronous serial communications
	SPI1_SPCR_TXMD_0 = 0x0
	// Serial communications consisting of only transmit operations
	SPI1_SPCR_TXMD_1 = 0x1
	// Position of SPMS field.
	SPI1_SPCR_SPMS_Pos = 0x0
	// Bit mask of SPMS field.
	SPI1_SPCR_SPMS_Msk = 0x1
	// Bit SPMS.
	SPI1_SPCR_SPMS = 0x1
	// SPI operation (4-wire method)
	SPI1_SPCR_SPMS_0 = 0x0
	// Clock synchronous operation (3-wire method)
	SPI1_SPCR_SPMS_1 = 0x1

	// SSLP: SPI Slave Select Polarity Register
	// Position of Reserved field.
	SPI1_SSLP_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SPI1_SSLP_Reserved_Msk = 0xf0
	// Position of SSL3P field.
	SPI1_SSLP_SSL3P_Pos = 0x3
	// Bit mask of SSL3P field.
	SPI1_SSLP_SSL3P_Msk = 0x8
	// Bit SSL3P.
	SPI1_SSLP_SSL3P = 0x8
	// SSL3 signal is active low
	SPI1_SSLP_SSL3P_0 = 0x0
	// SSL3 signal is active high
	SPI1_SSLP_SSL3P_1 = 0x1
	// Position of SSL2P field.
	SPI1_SSLP_SSL2P_Pos = 0x2
	// Bit mask of SSL2P field.
	SPI1_SSLP_SSL2P_Msk = 0x4
	// Bit SSL2P.
	SPI1_SSLP_SSL2P = 0x4
	// SSL2 signal is active low
	SPI1_SSLP_SSL2P_0 = 0x0
	// SSL2 signal is active high
	SPI1_SSLP_SSL2P_1 = 0x1
	// Position of SSL1P field.
	SPI1_SSLP_SSL1P_Pos = 0x1
	// Bit mask of SSL1P field.
	SPI1_SSLP_SSL1P_Msk = 0x2
	// Bit SSL1P.
	SPI1_SSLP_SSL1P = 0x2
	// SSL1 signal is active low
	SPI1_SSLP_SSL1P_0 = 0x0
	// SSL1 signal is active high
	SPI1_SSLP_SSL1P_1 = 0x1
	// Position of SSL0P field.
	SPI1_SSLP_SSL0P_Pos = 0x0
	// Bit mask of SSL0P field.
	SPI1_SSLP_SSL0P_Msk = 0x1
	// Bit SSL0P.
	SPI1_SSLP_SSL0P = 0x1
	// SSL0 signal is active low
	SPI1_SSLP_SSL0P_0 = 0x0
	// SSL0 signal is active high
	SPI1_SSLP_SSL0P_1 = 0x1

	// SPPCR: SPI Pin Control Register
	// Position of Reserved field.
	SPI1_SPPCR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SPI1_SPPCR_Reserved_Msk = 0xc0
	// Position of MOIFE field.
	SPI1_SPPCR_MOIFE_Pos = 0x5
	// Bit mask of MOIFE field.
	SPI1_SPPCR_MOIFE_Msk = 0x20
	// Bit MOIFE.
	SPI1_SPPCR_MOIFE = 0x20
	// MOSI output value equals final data from previous transfer
	SPI1_SPPCR_MOIFE_0 = 0x0
	// MOSI output value equals the value set in the MOIFV bit
	SPI1_SPPCR_MOIFE_1 = 0x1
	// Position of MOIFV field.
	SPI1_SPPCR_MOIFV_Pos = 0x4
	// Bit mask of MOIFV field.
	SPI1_SPPCR_MOIFV_Msk = 0x10
	// Bit MOIFV.
	SPI1_SPPCR_MOIFV = 0x10
	// The level output on the MOSIn pin during MOSI idling corresponds to low.
	SPI1_SPPCR_MOIFV_0 = 0x0
	// The level output on the MOSIn pin during MOSI idling corresponds to high.
	SPI1_SPPCR_MOIFV_1 = 0x1
	// Position of Reserved field.
	SPI1_SPPCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SPI1_SPPCR_Reserved_Msk = 0xc
	// Position of SPLP2 field.
	SPI1_SPPCR_SPLP2_Pos = 0x1
	// Bit mask of SPLP2 field.
	SPI1_SPPCR_SPLP2_Msk = 0x2
	// Bit SPLP2.
	SPI1_SPPCR_SPLP2 = 0x2
	// Normal mode
	SPI1_SPPCR_SPLP2_0 = 0x0
	// Loopback mode (data is not inverted for transmission)
	SPI1_SPPCR_SPLP2_1 = 0x1
	// Position of SPLP field.
	SPI1_SPPCR_SPLP_Pos = 0x0
	// Bit mask of SPLP field.
	SPI1_SPPCR_SPLP_Msk = 0x1
	// Bit SPLP.
	SPI1_SPPCR_SPLP = 0x1
	// Normal mode
	SPI1_SPPCR_SPLP_0 = 0x0
	// Loopback mode (data is inverted for transmission)
	SPI1_SPPCR_SPLP_1 = 0x1

	// SPSR: SPI Status Register
	// Position of SPRF field.
	SPI1_SPSR_SPRF_Pos = 0x7
	// Bit mask of SPRF field.
	SPI1_SPSR_SPRF_Msk = 0x80
	// Bit SPRF.
	SPI1_SPSR_SPRF = 0x80
	// No valid data in SPDR
	SPI1_SPSR_SPRF_0 = 0x0
	// Valid data found in SPDR
	SPI1_SPSR_SPRF_1 = 0x1
	// Position of Reserved field.
	SPI1_SPSR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SPI1_SPSR_Reserved_Msk = 0x40
	// Bit Reserved.
	SPI1_SPSR_Reserved = 0x40
	// Position of SPTEF field.
	SPI1_SPSR_SPTEF_Pos = 0x5
	// Bit mask of SPTEF field.
	SPI1_SPSR_SPTEF_Msk = 0x20
	// Bit SPTEF.
	SPI1_SPSR_SPTEF = 0x20
	// Data found in the transmit buffer
	SPI1_SPSR_SPTEF_0 = 0x0
	// No data in the transmit buffer
	SPI1_SPSR_SPTEF_1 = 0x1
	// Position of UDRF field.
	SPI1_SPSR_UDRF_Pos = 0x4
	// Bit mask of UDRF field.
	SPI1_SPSR_UDRF_Msk = 0x10
	// Bit UDRF.
	SPI1_SPSR_UDRF = 0x10
	// A mode fault error occurs (MODF=1)
	SPI1_SPSR_UDRF_0 = 0x0
	// An underrun error occurs (MODF=1)
	SPI1_SPSR_UDRF_1 = 0x1
	// Position of PERF field.
	SPI1_SPSR_PERF_Pos = 0x3
	// Bit mask of PERF field.
	SPI1_SPSR_PERF_Msk = 0x8
	// Bit PERF.
	SPI1_SPSR_PERF = 0x8
	// No parity error occurs
	SPI1_SPSR_PERF_0 = 0x0
	// A parity error occurs
	SPI1_SPSR_PERF_1 = 0x1
	// Position of MODF field.
	SPI1_SPSR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI1_SPSR_MODF_Msk = 0x4
	// Bit MODF.
	SPI1_SPSR_MODF = 0x4
	// Neither mode fault error nor underrun error occurs
	SPI1_SPSR_MODF_0 = 0x0
	// A mode fault error or an underrun error occurs.
	SPI1_SPSR_MODF_1 = 0x1
	// Position of IDLNF field.
	SPI1_SPSR_IDLNF_Pos = 0x1
	// Bit mask of IDLNF field.
	SPI1_SPSR_IDLNF_Msk = 0x2
	// Bit IDLNF.
	SPI1_SPSR_IDLNF = 0x2
	// SPI is in the idle state
	SPI1_SPSR_IDLNF_0 = 0x0
	// SPI is in the transfer state
	SPI1_SPSR_IDLNF_1 = 0x1
	// Position of OVRF field.
	SPI1_SPSR_OVRF_Pos = 0x0
	// Bit mask of OVRF field.
	SPI1_SPSR_OVRF_Msk = 0x1
	// Bit OVRF.
	SPI1_SPSR_OVRF = 0x1
	// No overrun error occurs
	SPI1_SPSR_OVRF_0 = 0x0
	// An overrun error occurs
	SPI1_SPSR_OVRF_1 = 0x1

	// SPDR: SPI Data Register
	// Position of SPDR field.
	SPI1_SPDR_SPDR_Pos = 0x0
	// Bit mask of SPDR field.
	SPI1_SPDR_SPDR_Msk = 0xffffffff

	// SPDR_HA: SPI Data Register ( halfword access )
	// Position of SPDR_HA field.
	SPI1_SPDR_HA_SPDR_HA_Pos = 0x0
	// Bit mask of SPDR_HA field.
	SPI1_SPDR_HA_SPDR_HA_Msk = 0xffff

	// SPBR: SPI Bit Rate Register
	// Position of SPR field.
	SPI1_SPBR_SPR_Pos = 0x0
	// Bit mask of SPR field.
	SPI1_SPBR_SPR_Msk = 0xff

	// SPDCR: SPI Data Control Register
	// Position of Reserved field.
	SPI1_SPDCR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SPI1_SPDCR_Reserved_Msk = 0xc0
	// Position of SPLW field.
	SPI1_SPDCR_SPLW_Pos = 0x5
	// Bit mask of SPLW field.
	SPI1_SPDCR_SPLW_Msk = 0x20
	// Bit SPLW.
	SPI1_SPDCR_SPLW = 0x20
	// SPDR_HA is valid to access in halfwords
	SPI1_SPDCR_SPLW_0 = 0x0
	// SPDR is valid (to access in words).
	SPI1_SPDCR_SPLW_1 = 0x1
	// Position of SPRDTD field.
	SPI1_SPDCR_SPRDTD_Pos = 0x4
	// Bit mask of SPRDTD field.
	SPI1_SPDCR_SPRDTD_Msk = 0x10
	// Bit SPRDTD.
	SPI1_SPDCR_SPRDTD = 0x10
	// SPDR values are read from the receive buffer
	SPI1_SPDCR_SPRDTD_0 = 0x0
	// SPDR values are read from the transmit buffer (but only if the transmit buffer is empty)
	SPI1_SPDCR_SPRDTD_1 = 0x1
	// Position of Reserved field.
	SPI1_SPDCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SPI1_SPDCR_Reserved_Msk = 0xf

	// SPCKD: SPI Clock Delay Register
	// Position of Reserved field.
	SPI1_SPCKD_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SPI1_SPCKD_Reserved_Msk = 0xf8
	// Position of SCKDL field.
	SPI1_SPCKD_SCKDL_Pos = 0x0
	// Bit mask of SCKDL field.
	SPI1_SPCKD_SCKDL_Msk = 0x7
	// 1 RSPCK
	SPI1_SPCKD_SCKDL_000 = 0x0
	// 2 RSPCK
	SPI1_SPCKD_SCKDL_001 = 0x1
	// 3 RSPCK
	SPI1_SPCKD_SCKDL_010 = 0x2
	// 4 RSPCK
	SPI1_SPCKD_SCKDL_011 = 0x3
	// 5 RSPCK
	SPI1_SPCKD_SCKDL_100 = 0x4
	// 6 RSPCK
	SPI1_SPCKD_SCKDL_101 = 0x5
	// 7 RSPCK
	SPI1_SPCKD_SCKDL_110 = 0x6
	// 8 RSPCK
	SPI1_SPCKD_SCKDL_111 = 0x7

	// SSLND: SPI Slave Select Negation Delay Register
	// Position of Reserved field.
	SPI1_SSLND_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SPI1_SSLND_Reserved_Msk = 0xf8
	// Position of SLNDL field.
	SPI1_SSLND_SLNDL_Pos = 0x0
	// Bit mask of SLNDL field.
	SPI1_SSLND_SLNDL_Msk = 0x7
	// 1 RSPCK
	SPI1_SSLND_SLNDL_000 = 0x0
	// 2 RSPCK
	SPI1_SSLND_SLNDL_001 = 0x1
	// 3 RSPCK
	SPI1_SSLND_SLNDL_010 = 0x2
	// 4 RSPCK
	SPI1_SSLND_SLNDL_011 = 0x3
	// 5 RSPCK
	SPI1_SSLND_SLNDL_100 = 0x4
	// 6 RSPCK
	SPI1_SSLND_SLNDL_101 = 0x5
	// 7 RSPCK
	SPI1_SSLND_SLNDL_110 = 0x6
	// 8 RSPCK
	SPI1_SSLND_SLNDL_111 = 0x7

	// SPND: SPI Next-Access Delay Register
	// Position of Reserved field.
	SPI1_SPND_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SPI1_SPND_Reserved_Msk = 0xf8
	// Position of SPNDL field.
	SPI1_SPND_SPNDL_Pos = 0x0
	// Bit mask of SPNDL field.
	SPI1_SPND_SPNDL_Msk = 0x7
	// 1 RSPCK + 2 PCLK
	SPI1_SPND_SPNDL_000 = 0x0
	// 2 RSPCK + 2 PCLK
	SPI1_SPND_SPNDL_001 = 0x1
	// 3 RSPCK + 2 PCLK
	SPI1_SPND_SPNDL_010 = 0x2
	// 4 RSPCK + 2 PCLK
	SPI1_SPND_SPNDL_011 = 0x3
	// 5 RSPCK + 2 PCLK
	SPI1_SPND_SPNDL_100 = 0x4
	// 6 RSPCK + 2 PCLK
	SPI1_SPND_SPNDL_101 = 0x5
	// 7 RSPCK + 2 PCLK
	SPI1_SPND_SPNDL_110 = 0x6
	// 8 RSPCK + 2 PCLK
	SPI1_SPND_SPNDL_111 = 0x7

	// SPCR2: SPI Control Register 2
	// Position of Reserved field.
	SPI1_SPCR2_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SPI1_SPCR2_Reserved_Msk = 0xe0
	// Position of SCKASE field.
	SPI1_SPCR2_SCKASE_Pos = 0x4
	// Bit mask of SCKASE field.
	SPI1_SPCR2_SCKASE_Msk = 0x10
	// Bit SCKASE.
	SPI1_SPCR2_SCKASE = 0x10
	// Disables the RSPCK auto-stop function
	SPI1_SPCR2_SCKASE_0 = 0x0
	// Enables the RSPCK auto-stop function
	SPI1_SPCR2_SCKASE_1 = 0x1
	// Position of PTE field.
	SPI1_SPCR2_PTE_Pos = 0x3
	// Bit mask of PTE field.
	SPI1_SPCR2_PTE_Msk = 0x8
	// Bit PTE.
	SPI1_SPCR2_PTE = 0x8
	// Disables the self-diagnosis function of the parity circuit
	SPI1_SPCR2_PTE_0 = 0x0
	// Enables the self-diagnosis function of the parity circuit
	SPI1_SPCR2_PTE_1 = 0x1
	// Position of SPIIE field.
	SPI1_SPCR2_SPIIE_Pos = 0x2
	// Bit mask of SPIIE field.
	SPI1_SPCR2_SPIIE_Msk = 0x4
	// Bit SPIIE.
	SPI1_SPCR2_SPIIE = 0x4
	// Disables the generation of idle interrupt requests
	SPI1_SPCR2_SPIIE_0 = 0x0
	// Enables the generation of idle interrupt requests
	SPI1_SPCR2_SPIIE_1 = 0x1
	// Position of SPOE field.
	SPI1_SPCR2_SPOE_Pos = 0x1
	// Bit mask of SPOE field.
	SPI1_SPCR2_SPOE_Msk = 0x2
	// Bit SPOE.
	SPI1_SPCR2_SPOE = 0x2
	// Selects even parity for use in transmission and reception
	SPI1_SPCR2_SPOE_0 = 0x0
	// Selects odd parity for use in transmission and reception
	SPI1_SPCR2_SPOE_1 = 0x1
	// Position of SPPE field.
	SPI1_SPCR2_SPPE_Pos = 0x0
	// Bit mask of SPPE field.
	SPI1_SPCR2_SPPE_Msk = 0x1
	// Bit SPPE.
	SPI1_SPCR2_SPPE = 0x1
	// Does not add the parity bit to transmit data and does not check the parity bit of receive data
	SPI1_SPCR2_SPPE_0 = 0x0
	// Adds the parity bit to transmit data and checks the parity bit of receive data (when SPCR.TXMD = 0) / Adds the parity bit to transmit data but does not check the parity bit of receive data (when SPCR.TXMD = 1)
	SPI1_SPCR2_SPPE_1 = 0x1

	// SPCMD0: SPI Command Register 0
	// Position of SCKDEN field.
	SPI1_SPCMD0_SCKDEN_Pos = 0xf
	// Bit mask of SCKDEN field.
	SPI1_SPCMD0_SCKDEN_Msk = 0x8000
	// Bit SCKDEN.
	SPI1_SPCMD0_SCKDEN = 0x8000
	// An RSPCK delay of 1 RSPCK
	SPI1_SPCMD0_SCKDEN_0 = 0x0
	// An RSPCK delay is equal to the setting of the RSPI clock delay register (SPCKD)
	SPI1_SPCMD0_SCKDEN_1 = 0x1
	// Position of SLNDEN field.
	SPI1_SPCMD0_SLNDEN_Pos = 0xe
	// Bit mask of SLNDEN field.
	SPI1_SPCMD0_SLNDEN_Msk = 0x4000
	// Bit SLNDEN.
	SPI1_SPCMD0_SLNDEN = 0x4000
	// An SSL negation delay of 1 RSPCK
	SPI1_SPCMD0_SLNDEN_0 = 0x0
	// An SSL negation delay is equal to the setting of the RSPI slave select negation delay register (SSLND)
	SPI1_SPCMD0_SLNDEN_1 = 0x1
	// Position of SPNDEN field.
	SPI1_SPCMD0_SPNDEN_Pos = 0xd
	// Bit mask of SPNDEN field.
	SPI1_SPCMD0_SPNDEN_Msk = 0x2000
	// Bit SPNDEN.
	SPI1_SPCMD0_SPNDEN = 0x2000
	// A next-access delay of 1 RSPCK + 2 PCLK
	SPI1_SPCMD0_SPNDEN_0 = 0x0
	// A next-access delay is equal to the setting of the RSPI next-access delay register (SPND)
	SPI1_SPCMD0_SPNDEN_1 = 0x1
	// Position of LSBF field.
	SPI1_SPCMD0_LSBF_Pos = 0xc
	// Bit mask of LSBF field.
	SPI1_SPCMD0_LSBF_Msk = 0x1000
	// Bit LSBF.
	SPI1_SPCMD0_LSBF = 0x1000
	// MSB first
	SPI1_SPCMD0_LSBF_0 = 0x0
	// LSB first
	SPI1_SPCMD0_LSBF_1 = 0x1
	// Position of SPB field.
	SPI1_SPCMD0_SPB_Pos = 0x8
	// Bit mask of SPB field.
	SPI1_SPCMD0_SPB_Msk = 0xf00
	// 20 bits
	SPI1_SPCMD0_SPB_0000 = 0x0
	// 24 bits
	SPI1_SPCMD0_SPB_0001 = 0x1
	// 32 bits
	SPI1_SPCMD0_SPB_0010 = 0x2
	// 32 bits
	SPI1_SPCMD0_SPB_0011 = 0x3
	// 9 bits
	SPI1_SPCMD0_SPB_1000 = 0x8
	// 10 bits
	SPI1_SPCMD0_SPB_1001 = 0x9
	// 11 bits
	SPI1_SPCMD0_SPB_1010 = 0xa
	// 12 bits
	SPI1_SPCMD0_SPB_1011 = 0xb
	// 13 bits
	SPI1_SPCMD0_SPB_1100 = 0xc
	// 14 bits
	SPI1_SPCMD0_SPB_1101 = 0xd
	// 15 bits
	SPI1_SPCMD0_SPB_1110 = 0xe
	// 16 bits
	SPI1_SPCMD0_SPB_1111 = 0xf
	// Position of Reserved field.
	SPI1_SPCMD0_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	SPI1_SPCMD0_Reserved_Msk = 0x80
	// Bit Reserved.
	SPI1_SPCMD0_Reserved = 0x80
	// Position of SSLA field.
	SPI1_SPCMD0_SSLA_Pos = 0x4
	// Bit mask of SSLA field.
	SPI1_SPCMD0_SSLA_Msk = 0x70
	// SSL0
	SPI1_SPCMD0_SSLA_000 = 0x0
	// SSL1
	SPI1_SPCMD0_SSLA_001 = 0x1
	// SSL2
	SPI1_SPCMD0_SSLA_010 = 0x2
	// SSL3
	SPI1_SPCMD0_SSLA_011 = 0x3
	// Position of BRDV field.
	SPI1_SPCMD0_BRDV_Pos = 0x2
	// Bit mask of BRDV field.
	SPI1_SPCMD0_BRDV_Msk = 0xc
	// These bits select the base bit rate
	SPI1_SPCMD0_BRDV_00 = 0x0
	// These bits select the base bit rate divided by 2
	SPI1_SPCMD0_BRDV_01 = 0x1
	// These bits select the base bit rate divided by 4
	SPI1_SPCMD0_BRDV_10 = 0x2
	// These bits select the base bit rate divided by 8
	SPI1_SPCMD0_BRDV_11 = 0x3
	// Position of CPOL field.
	SPI1_SPCMD0_CPOL_Pos = 0x1
	// Bit mask of CPOL field.
	SPI1_SPCMD0_CPOL_Msk = 0x2
	// Bit CPOL.
	SPI1_SPCMD0_CPOL = 0x2
	// RSPCK is low when idle
	SPI1_SPCMD0_CPOL_0 = 0x0
	// RSPCK is high when idle
	SPI1_SPCMD0_CPOL_1 = 0x1
	// Position of CPHA field.
	SPI1_SPCMD0_CPHA_Pos = 0x0
	// Bit mask of CPHA field.
	SPI1_SPCMD0_CPHA_Msk = 0x1
	// Bit CPHA.
	SPI1_SPCMD0_CPHA = 0x1
	// Data sampling on odd edge, data variation on even edge
	SPI1_SPCMD0_CPHA_0 = 0x0
	// Data variation on odd edge, data sampling on even edge
	SPI1_SPCMD0_CPHA_1 = 0x1
)

// Constants for SCI0: Serial Communication Interface 0
const (
	// SMR: Serial Mode Register (SCMR.SMIF = 0)
	// Position of CM field.
	SCI0_SMR_CM_Pos = 0x7
	// Bit mask of CM field.
	SCI0_SMR_CM_Msk = 0x80
	// Bit CM.
	SCI0_SMR_CM = 0x80
	// Asynchronous mode or simple I2C mode
	SCI0_SMR_CM_0 = 0x0
	// Clock synchronous mode
	SCI0_SMR_CM_1 = 0x1
	// Position of CHR field.
	SCI0_SMR_CHR_Pos = 0x6
	// Bit mask of CHR field.
	SCI0_SMR_CHR_Msk = 0x40
	// Bit CHR.
	SCI0_SMR_CHR = 0x40
	// Transmit/receive in 9-bit data length(SCMR.CHR1=0) / in 8bit data length(SCMR.CHR1=1)
	SCI0_SMR_CHR_0 = 0x0
	// Transmit/receive in 9-bit data length(SCMR.CHR1=0) / in 7bit data length(SCMR.CHR1=1)
	SCI0_SMR_CHR_1 = 0x1
	// Position of PE field.
	SCI0_SMR_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI0_SMR_PE_Msk = 0x20
	// Bit PE.
	SCI0_SMR_PE = 0x20
	// Parity bit addition is not performed (transmitting) / Parity bit checking is not performed ( receiving )
	SCI0_SMR_PE_0 = 0x0
	// The parity bit is added (transmitting) / The parity bit is checked (receiving)
	SCI0_SMR_PE_1 = 0x1
	// Position of PM field.
	SCI0_SMR_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI0_SMR_PM_Msk = 0x10
	// Bit PM.
	SCI0_SMR_PM = 0x10
	// Selects even parity
	SCI0_SMR_PM_0 = 0x0
	// Selects odd parity
	SCI0_SMR_PM_1 = 0x1
	// Position of STOP field.
	SCI0_SMR_STOP_Pos = 0x3
	// Bit mask of STOP field.
	SCI0_SMR_STOP_Msk = 0x8
	// Bit STOP.
	SCI0_SMR_STOP = 0x8
	// 1 stop bit
	SCI0_SMR_STOP_0 = 0x0
	// 2 stop bits
	SCI0_SMR_STOP_1 = 0x1
	// Position of MP field.
	SCI0_SMR_MP_Pos = 0x2
	// Bit mask of MP field.
	SCI0_SMR_MP_Msk = 0x4
	// Bit MP.
	SCI0_SMR_MP = 0x4
	// Multi-processor communications function is disabled
	SCI0_SMR_MP_0 = 0x0
	// Multi-processor communications function is enabled
	SCI0_SMR_MP_1 = 0x1
	// Position of CKS field.
	SCI0_SMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI0_SMR_CKS_Msk = 0x3
	// PCLK clock
	SCI0_SMR_CKS_00 = 0x0
	// PCLK/4 clock
	SCI0_SMR_CKS_01 = 0x1
	// PCLK/16 clock
	SCI0_SMR_CKS_10 = 0x2
	// PCLK/64 clock
	SCI0_SMR_CKS_11 = 0x3

	// SMR_SMCI: Serial mode register (SCMR.SMIF = 1)
	// Position of GM field.
	SCI0_SMR_SMCI_GM_Pos = 0x7
	// Bit mask of GM field.
	SCI0_SMR_SMCI_GM_Msk = 0x80
	// Bit GM.
	SCI0_SMR_SMCI_GM = 0x80
	// Normal mode operation
	SCI0_SMR_SMCI_GM_0 = 0x0
	// GSM mode operation
	SCI0_SMR_SMCI_GM_1 = 0x1
	// Position of BLK field.
	SCI0_SMR_SMCI_BLK_Pos = 0x6
	// Bit mask of BLK field.
	SCI0_SMR_SMCI_BLK_Msk = 0x40
	// Bit BLK.
	SCI0_SMR_SMCI_BLK = 0x40
	// Normal mode operation
	SCI0_SMR_SMCI_BLK_0 = 0x0
	// Block transfer mode operation
	SCI0_SMR_SMCI_BLK_1 = 0x1
	// Position of PE field.
	SCI0_SMR_SMCI_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI0_SMR_SMCI_PE_Msk = 0x20
	// Bit PE.
	SCI0_SMR_SMCI_PE = 0x20
	// Setting Prohibited
	SCI0_SMR_SMCI_PE_0 = 0x0
	// Set this bit to 1 in smart card interface mode.
	SCI0_SMR_SMCI_PE_1 = 0x1
	// Position of PM field.
	SCI0_SMR_SMCI_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI0_SMR_SMCI_PM_Msk = 0x10
	// Bit PM.
	SCI0_SMR_SMCI_PM = 0x10
	// Selects even parity
	SCI0_SMR_SMCI_PM_0 = 0x0
	// Selects odd parity
	SCI0_SMR_SMCI_PM_1 = 0x1
	// Position of BCP field.
	SCI0_SMR_SMCI_BCP_Pos = 0x2
	// Bit mask of BCP field.
	SCI0_SMR_SMCI_BCP_Msk = 0xc
	// 93 clock cycles(S=93) (SCMR.BCP2=0) / 32 clock cycles(S=32) (SCMR.BCP2=1)
	SCI0_SMR_SMCI_BCP_00 = 0x0
	// 128 clock cycles(S=128) (SCMR.BCP2=0) / 64 clock cycles(S=64) (SCMR.BCP2=1)
	SCI0_SMR_SMCI_BCP_01 = 0x1
	// 186 clock cycles(S=186) (SCMR.BCP2=0) / 372 clock cycles(S=372) (SCMR.BCP2=1)
	SCI0_SMR_SMCI_BCP_10 = 0x2
	// 512 clock cycles(S=512) (SCMR.BCP2=0) / 256 clock cycles(S=256) (SCMR.BCP2=1)
	SCI0_SMR_SMCI_BCP_11 = 0x3
	// Position of CKS field.
	SCI0_SMR_SMCI_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI0_SMR_SMCI_CKS_Msk = 0x3
	// PCLK clock
	SCI0_SMR_SMCI_CKS_00 = 0x0
	// PCLK/4 clock
	SCI0_SMR_SMCI_CKS_01 = 0x1
	// PCLK/16 clock
	SCI0_SMR_SMCI_CKS_10 = 0x2
	// PCLK/64 clock
	SCI0_SMR_SMCI_CKS_11 = 0x3

	// BRR: Bit Rate Register
	// Position of BRR field.
	SCI0_BRR_BRR_Pos = 0x0
	// Bit mask of BRR field.
	SCI0_BRR_BRR_Msk = 0xff

	// SCR: Serial Control Register (SCMR.SMIF = 0)
	// Position of TIE field.
	SCI0_SCR_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI0_SCR_TIE_Msk = 0x80
	// Bit TIE.
	SCI0_SCR_TIE = 0x80
	// SCI_TXI interrupt request is disabled
	SCI0_SCR_TIE_0 = 0x0
	// SCI_TXI interrupt request is enabled
	SCI0_SCR_TIE_1 = 0x1
	// Position of RIE field.
	SCI0_SCR_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI0_SCR_RIE_Msk = 0x40
	// Bit RIE.
	SCI0_SCR_RIE = 0x40
	// SCI_RXI and SCI_ERI interrupt requests are disabled
	SCI0_SCR_RIE_0 = 0x0
	// SCI_RXI and SCI_ERI interrupt requests are enabled
	SCI0_SCR_RIE_1 = 0x1
	// Position of TE field.
	SCI0_SCR_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI0_SCR_TE_Msk = 0x20
	// Bit TE.
	SCI0_SCR_TE = 0x20
	// Serial transmission is disabled
	SCI0_SCR_TE_0 = 0x0
	// Serial transmission is enabled
	SCI0_SCR_TE_1 = 0x1
	// Position of RE field.
	SCI0_SCR_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI0_SCR_RE_Msk = 0x10
	// Bit RE.
	SCI0_SCR_RE = 0x10
	// Serial reception is disabled
	SCI0_SCR_RE_0 = 0x0
	// Serial reception is enabled
	SCI0_SCR_RE_1 = 0x1
	// Position of MPIE field.
	SCI0_SCR_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI0_SCR_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI0_SCR_MPIE = 0x8
	// Normal reception
	SCI0_SCR_MPIE_0 = 0x0
	// When the data with the multi-processor bit set to 0 is received, the data is not read, and setting the status flags RDRF,ORER and FER in SSR to 1 is disabled. When the data with the multiprocessor bit set to 1 is received, the MPIE bit is automatically cleared to 0, and normal reception is resumed.
	SCI0_SCR_MPIE_1 = 0x1
	// Position of TEIE field.
	SCI0_SCR_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI0_SCR_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI0_SCR_TEIE = 0x4
	// SCI_TEI interrupt request is disabled
	SCI0_SCR_TEIE_0 = 0x0
	// SCI_TEI interrupt request is enabled
	SCI0_SCR_TEIE_1 = 0x1
	// Position of CKE field.
	SCI0_SCR_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI0_SCR_CKE_Msk = 0x3
	// The SCKn pin is available for use as an I/O port in accord with the I/O port settings.(Asynchronous mode) / The SCKn pin functions as the clock output pin(Clock synchronous mode)
	SCI0_SCR_CKE_00 = 0x0
	// The clock with the same frequency as the bit rate is output from the SCKn pin.(Asynchronous mode) / The SCKn pin functions as the clock output pin(Clock synchronous mode)
	SCI0_SCR_CKE_01 = 0x1

	// SCR_SMCI: Serial Control Register (SCMR.SMIF =1)
	// Position of TIE field.
	SCI0_SCR_SMCI_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI0_SCR_SMCI_TIE_Msk = 0x80
	// Bit TIE.
	SCI0_SCR_SMCI_TIE = 0x80
	// A SCI_TXI interrupt request is disabled
	SCI0_SCR_SMCI_TIE_0 = 0x0
	// A SCI_TXI interrupt request is enabled
	SCI0_SCR_SMCI_TIE_1 = 0x1
	// Position of RIE field.
	SCI0_SCR_SMCI_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI0_SCR_SMCI_RIE_Msk = 0x40
	// Bit RIE.
	SCI0_SCR_SMCI_RIE = 0x40
	// SCI_RXI and SCI_ERI interrupt requests are disabled
	SCI0_SCR_SMCI_RIE_0 = 0x0
	// SCI_RXI and SCI_ERI interrupt requests are enabled
	SCI0_SCR_SMCI_RIE_1 = 0x1
	// Position of TE field.
	SCI0_SCR_SMCI_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI0_SCR_SMCI_TE_Msk = 0x20
	// Bit TE.
	SCI0_SCR_SMCI_TE = 0x20
	// Serial transmission is disabled
	SCI0_SCR_SMCI_TE_0 = 0x0
	// Serial transmission is enabled
	SCI0_SCR_SMCI_TE_1 = 0x1
	// Position of RE field.
	SCI0_SCR_SMCI_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI0_SCR_SMCI_RE_Msk = 0x10
	// Bit RE.
	SCI0_SCR_SMCI_RE = 0x10
	// Serial reception is disabled
	SCI0_SCR_SMCI_RE_0 = 0x0
	// Serial reception is enabled
	SCI0_SCR_SMCI_RE_1 = 0x1
	// Position of MPIE field.
	SCI0_SCR_SMCI_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI0_SCR_SMCI_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI0_SCR_SMCI_MPIE = 0x8
	// Position of TEIE field.
	SCI0_SCR_SMCI_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI0_SCR_SMCI_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI0_SCR_SMCI_TEIE = 0x4
	// Position of CKE field.
	SCI0_SCR_SMCI_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI0_SCR_SMCI_CKE_Msk = 0x3
	// Output disabled(SMR_SMCI.GM=0) / Output fixed low(SMR_SMCI.GM=1)
	SCI0_SCR_SMCI_CKE_00 = 0x0
	// Clock Output
	SCI0_SCR_SMCI_CKE_01 = 0x1
	// Setting prohibited(SMR_SMCI.GM=0) / Output fixed High(SMR_SMCI.GM=1)
	SCI0_SCR_SMCI_CKE_10 = 0x2
	// Setting prohibited(SMR_SMCI.GM=0) / Clock Output(SMR_SMCI.GM=1)
	SCI0_SCR_SMCI_CKE_11 = 0x3

	// TDR: Transmit Data Register
	// Position of TDR field.
	SCI0_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	SCI0_TDR_TDR_Msk = 0xff

	// SSR: Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
	// Position of TDRE field.
	SCI0_SSR_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI0_SSR_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI0_SSR_TDRE = 0x80
	// Transmit data is in TDR register
	SCI0_SSR_TDRE_0 = 0x0
	// No transmit data is in TDR register
	SCI0_SSR_TDRE_1 = 0x1
	// Position of RDRF field.
	SCI0_SSR_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI0_SSR_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI0_SSR_RDRF = 0x40
	// No received data is in RDR register
	SCI0_SSR_RDRF_0 = 0x0
	// Received data is in RDR register
	SCI0_SSR_RDRF_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_SSR_ORER_1 = 0x1
	// Position of FER field.
	SCI0_SSR_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_SSR_FER_Msk = 0x10
	// Bit FER.
	SCI0_SSR_FER = 0x10
	// No framing error occurred
	SCI0_SSR_FER_0 = 0x0
	// A framing error has occurred
	SCI0_SSR_FER_1 = 0x1
	// Position of PER field.
	SCI0_SSR_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_PER = 0x8
	// No parity error occurred
	SCI0_SSR_PER_0 = 0x0
	// A parity error has occurred
	SCI0_SSR_PER_1 = 0x1
	// Position of TEND field.
	SCI0_SSR_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_TEND = 0x4
	// A character is being transmitted.
	SCI0_SSR_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI0_SSR_TEND_1 = 0x1
	// Position of MPB field.
	SCI0_SSR_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_SSR_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_SSR_MPB = 0x2
	// Data transmission cycles
	SCI0_SSR_MPB_0 = 0x0
	// ID transmission cycles
	SCI0_SSR_MPB_1 = 0x1
	// Position of MPBT field.
	SCI0_SSR_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI0_SSR_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI0_SSR_MPBT = 0x1
	// Data transmission cycles
	SCI0_SSR_MPBT_0 = 0x0
	// ID transmission cycles
	SCI0_SSR_MPBT_1 = 0x1

	// SSR_FIFO: Serial Status Register(SCMR.SMIF = 0 and FCR.FM=1)
	// Position of TDFE field.
	SCI0_SSR_FIFO_TDFE_Pos = 0x7
	// Bit mask of TDFE field.
	SCI0_SSR_FIFO_TDFE_Msk = 0x80
	// Bit TDFE.
	SCI0_SSR_FIFO_TDFE = 0x80
	// The quantity of transmit data written in FTDR exceeds the specified transmit triggering number.
	SCI0_SSR_FIFO_TDFE_0 = 0x0
	// The quantity of transmit data written in FTDR is equal to or less than the specified transmit triggering number
	SCI0_SSR_FIFO_TDFE_1 = 0x1
	// Position of RDF field.
	SCI0_SSR_FIFO_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI0_SSR_FIFO_RDF_Msk = 0x40
	// Bit RDF.
	SCI0_SSR_FIFO_RDF = 0x40
	// The quantity of receive data written in FRDR falls below the specified receive triggering number.
	SCI0_SSR_FIFO_RDF_0 = 0x0
	// The quantity of receive data written in FRDR is equal to or greater than the specified receive triggering number.
	SCI0_SSR_FIFO_RDF_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_FIFO_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_FIFO_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_FIFO_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_FIFO_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_SSR_FIFO_ORER_1 = 0x1
	// Position of FER field.
	SCI0_SSR_FIFO_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_SSR_FIFO_FER_Msk = 0x10
	// Bit FER.
	SCI0_SSR_FIFO_FER = 0x10
	// No framing error occurred.
	SCI0_SSR_FIFO_FER_0 = 0x0
	// A framing error has occurred.
	SCI0_SSR_FIFO_FER_1 = 0x1
	// Position of PER field.
	SCI0_SSR_FIFO_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_FIFO_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_FIFO_PER = 0x8
	// No parity error occurred.
	SCI0_SSR_FIFO_PER_0 = 0x0
	// A parity error has occurred.
	SCI0_SSR_FIFO_PER_1 = 0x1
	// Position of TEND field.
	SCI0_SSR_FIFO_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_FIFO_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_FIFO_TEND = 0x4
	// A character is being transmitted or standing by for transmission.
	SCI0_SSR_FIFO_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI0_SSR_FIFO_TEND_1 = 0x1
	// Position of Reserved field.
	SCI0_SSR_FIFO_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI0_SSR_FIFO_Reserved_Msk = 0x2
	// Bit Reserved.
	SCI0_SSR_FIFO_Reserved = 0x2
	// Position of DR field.
	SCI0_SSR_FIFO_DR_Pos = 0x0
	// Bit mask of DR field.
	SCI0_SSR_FIFO_DR_Msk = 0x1
	// Bit DR.
	SCI0_SSR_FIFO_DR = 0x1
	// Receiving is in progress, or no received data has remained in FRDR after normally completed receiving.(receive FIFO is empty)
	SCI0_SSR_FIFO_DR_0 = 0x0
	// Next receive data has not been received for a period after normal completed receiving, , when data is stored in FIFO to equal or less than receive triggering number.
	SCI0_SSR_FIFO_DR_1 = 0x1

	// SSR_SMCI: Serial Status Register(SCMR.SMIF = 1)
	// Position of TDRE field.
	SCI0_SSR_SMCI_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI0_SSR_SMCI_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI0_SSR_SMCI_TDRE = 0x80
	// Transmit data is in TDR register
	SCI0_SSR_SMCI_TDRE_0 = 0x0
	// No transmit data is in TDR register
	SCI0_SSR_SMCI_TDRE_1 = 0x1
	// Position of RDRF field.
	SCI0_SSR_SMCI_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI0_SSR_SMCI_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI0_SSR_SMCI_RDRF = 0x40
	// No received data is in RDR register
	SCI0_SSR_SMCI_RDRF_0 = 0x0
	// Received data is in RDR register
	SCI0_SSR_SMCI_RDRF_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_SMCI_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_SMCI_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_SMCI_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_SMCI_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_SSR_SMCI_ORER_1 = 0x1
	// Position of ERS field.
	SCI0_SSR_SMCI_ERS_Pos = 0x4
	// Bit mask of ERS field.
	SCI0_SSR_SMCI_ERS_Msk = 0x10
	// Bit ERS.
	SCI0_SSR_SMCI_ERS = 0x10
	// Low error signal not responded
	SCI0_SSR_SMCI_ERS_0 = 0x0
	// Low error signal responded
	SCI0_SSR_SMCI_ERS_1 = 0x1
	// Position of PER field.
	SCI0_SSR_SMCI_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_SMCI_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_SMCI_PER = 0x8
	// No parity error occurred
	SCI0_SSR_SMCI_PER_0 = 0x0
	// A parity error has occurred
	SCI0_SSR_SMCI_PER_1 = 0x1
	// Position of TEND field.
	SCI0_SSR_SMCI_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_SMCI_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_SMCI_TEND = 0x4
	// A character is being transmitted.
	SCI0_SSR_SMCI_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI0_SSR_SMCI_TEND_1 = 0x1
	// Position of MPB field.
	SCI0_SSR_SMCI_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_SSR_SMCI_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_SSR_SMCI_MPB = 0x2
	// Position of MPBT field.
	SCI0_SSR_SMCI_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI0_SSR_SMCI_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI0_SSR_SMCI_MPBT = 0x1

	// RDR: Receive Data Register
	// Position of RDR field.
	SCI0_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	SCI0_RDR_RDR_Msk = 0xff

	// SCMR: Smart Card Mode Register
	// Position of BCP2 field.
	SCI0_SCMR_BCP2_Pos = 0x7
	// Bit mask of BCP2 field.
	SCI0_SCMR_BCP2_Msk = 0x80
	// Bit BCP2.
	SCI0_SCMR_BCP2 = 0x80
	// S=93(SMR.BCP[1:0]=00), 128(SMR.BCP[1:0]=01), 186(SMR.BCP[1:0]=10), 512(SMR.BCP[1:0]=11)
	SCI0_SCMR_BCP2_0 = 0x0
	// S=32(SMR.BCP[1:0]=00), 64(SMR.BCP[1:0]=01), 372(SMR.BCP[1:0]=10), 256(SMR.BCP[1:0]=11)
	SCI0_SCMR_BCP2_1 = 0x1
	// Position of Reserved field.
	SCI0_SCMR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI0_SCMR_Reserved_Msk = 0x60
	// Position of CHR1 field.
	SCI0_SCMR_CHR1_Pos = 0x4
	// Bit mask of CHR1 field.
	SCI0_SCMR_CHR1_Msk = 0x10
	// Bit CHR1.
	SCI0_SCMR_CHR1 = 0x10
	// Transmit/receive in 9-bit data length
	SCI0_SCMR_CHR1_0 = 0x0
	// Transmit/receive in 8-bit data length(SMR.CHR=0) / in 7bit data length(SMR.CHR=1)
	SCI0_SCMR_CHR1_1 = 0x1
	// Position of SDIR field.
	SCI0_SCMR_SDIR_Pos = 0x3
	// Bit mask of SDIR field.
	SCI0_SCMR_SDIR_Msk = 0x8
	// Bit SDIR.
	SCI0_SCMR_SDIR = 0x8
	// Transfer with LSB first
	SCI0_SCMR_SDIR_0 = 0x0
	// Transfer with MSB first
	SCI0_SCMR_SDIR_1 = 0x1
	// Position of SINV field.
	SCI0_SCMR_SINV_Pos = 0x2
	// Bit mask of SINV field.
	SCI0_SCMR_SINV_Msk = 0x4
	// Bit SINV.
	SCI0_SCMR_SINV = 0x4
	// TDR contents are transmitted as they are. Receive data is stored as it is in RDR.
	SCI0_SCMR_SINV_0 = 0x0
	// TDR contents are inverted before being transmitted. Receive data is stored in inverted form in RDR.
	SCI0_SCMR_SINV_1 = 0x1
	// Position of Reserved field.
	SCI0_SCMR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI0_SCMR_Reserved_Msk = 0x2
	// Bit Reserved.
	SCI0_SCMR_Reserved = 0x2
	// Position of SMIF field.
	SCI0_SCMR_SMIF_Pos = 0x0
	// Bit mask of SMIF field.
	SCI0_SCMR_SMIF_Msk = 0x1
	// Bit SMIF.
	SCI0_SCMR_SMIF = 0x1
	// Non-smart card interface mode(Asynchronous mode, clock synchronous mode, simple SPI mode, or simple I2C mode)
	SCI0_SCMR_SMIF_0 = 0x0
	// Smart card interface mode
	SCI0_SCMR_SMIF_1 = 0x1

	// SEMR: Serial Extended Mode Register
	// Position of RXDESEL field.
	SCI0_SEMR_RXDESEL_Pos = 0x7
	// Bit mask of RXDESEL field.
	SCI0_SEMR_RXDESEL_Msk = 0x80
	// Bit RXDESEL.
	SCI0_SEMR_RXDESEL = 0x80
	// The low level on the RXDn pin is detected as the start bit.
	SCI0_SEMR_RXDESEL_0 = 0x0
	// A falling edge on the RXDn pin is detected as the start bit.
	SCI0_SEMR_RXDESEL_1 = 0x1
	// Position of BGDM field.
	SCI0_SEMR_BGDM_Pos = 0x6
	// Bit mask of BGDM field.
	SCI0_SEMR_BGDM_Msk = 0x40
	// Bit BGDM.
	SCI0_SEMR_BGDM = 0x40
	// Baud rate generator outputs the clock with normal frequency.
	SCI0_SEMR_BGDM_0 = 0x0
	// Baud rate generator outputs the clock with doubled frequency.
	SCI0_SEMR_BGDM_1 = 0x1
	// Position of NFEN field.
	SCI0_SEMR_NFEN_Pos = 0x5
	// Bit mask of NFEN field.
	SCI0_SEMR_NFEN_Msk = 0x20
	// Bit NFEN.
	SCI0_SEMR_NFEN = 0x20
	// Noise cancellation function for the RXDn/SSCLn and SSDAn input signal is disabled.
	SCI0_SEMR_NFEN_0 = 0x0
	// Noise cancellation function for the RXDn/SSCLn and SSDAn input signal is enabled.
	SCI0_SEMR_NFEN_1 = 0x1
	// Position of ABCS field.
	SCI0_SEMR_ABCS_Pos = 0x4
	// Bit mask of ABCS field.
	SCI0_SEMR_ABCS_Msk = 0x10
	// Bit ABCS.
	SCI0_SEMR_ABCS = 0x10
	// Selects 16 base clock cycles for 1-bit period.
	SCI0_SEMR_ABCS_0 = 0x0
	// Selects 8 base clock cycles for 1-bit period.
	SCI0_SEMR_ABCS_1 = 0x1
	// Position of ABCSE field.
	SCI0_SEMR_ABCSE_Pos = 0x3
	// Bit mask of ABCSE field.
	SCI0_SEMR_ABCSE_Msk = 0x8
	// Bit ABCSE.
	SCI0_SEMR_ABCSE = 0x8
	// Clock cycles for 1-bit period is decided with combination between BGDM and ABCS in SEMR.
	SCI0_SEMR_ABCSE_0 = 0x0
	// Baud rate is 6 base clock cycles for 1-bit period and the clock of a double frequency is output from the baud rate generator.
	SCI0_SEMR_ABCSE_1 = 0x1
	// Position of BRME field.
	SCI0_SEMR_BRME_Pos = 0x2
	// Bit mask of BRME field.
	SCI0_SEMR_BRME_Msk = 0x4
	// Bit BRME.
	SCI0_SEMR_BRME = 0x4
	// Bit rate modulation function is disabled.
	SCI0_SEMR_BRME_0 = 0x0
	// Bit rate modulation function is enabled.
	SCI0_SEMR_BRME_1 = 0x1
	// Position of Reserved field.
	SCI0_SEMR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SCI0_SEMR_Reserved_Msk = 0x3

	// SNFR: Noise Filter Setting Register
	// Position of Reserved field.
	SCI0_SNFR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI0_SNFR_Reserved_Msk = 0xf8
	// Position of NFCS field.
	SCI0_SNFR_NFCS_Pos = 0x0
	// Bit mask of NFCS field.
	SCI0_SNFR_NFCS_Msk = 0x7
	// The clock signal divided by 1 is used with the noise filter.(In asynchronous mode)
	SCI0_SNFR_NFCS_000 = 0x0
	// The clock signal divided by 1 is used with the noise filter.(In simple I2C mode)
	SCI0_SNFR_NFCS_001 = 0x1
	// The clock signal divided by 2 is used with the noise filter.(In simple I2C mode)
	SCI0_SNFR_NFCS_010 = 0x2
	// The clock signal divided by 4 is used with the noise filter.(In simple I2C mode)
	SCI0_SNFR_NFCS_011 = 0x3
	// The clock signal divided by 8 is used with the noise filter.(In simple I2C mode)
	SCI0_SNFR_NFCS_100 = 0x4

	// SIMR1: I2C Mode Register 1
	// Position of IICDL field.
	SCI0_SIMR1_IICDL_Pos = 0x3
	// Bit mask of IICDL field.
	SCI0_SIMR1_IICDL_Msk = 0xf8
	// No output delay
	SCI0_SIMR1_IICDL_00000 = 0x0
	// Position of Reserved field.
	SCI0_SIMR1_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI0_SIMR1_Reserved_Msk = 0x6
	// Position of IICM field.
	SCI0_SIMR1_IICM_Pos = 0x0
	// Bit mask of IICM field.
	SCI0_SIMR1_IICM_Msk = 0x1
	// Bit IICM.
	SCI0_SIMR1_IICM = 0x1
	// Asynchronous mode, Multi-processor mode, Clock synchronous mode(SCMR.SMIF=0) /Smart card interface mode(SCMR.SMIF=1)
	SCI0_SIMR1_IICM_0 = 0x0
	// Simple I2C mode(SCMR.SMIF=0) / Setting prohibited.(SCMR.SMIF=1)
	SCI0_SIMR1_IICM_1 = 0x1

	// SIMR2: I2C Mode Register 2
	// Position of Reserved field.
	SCI0_SIMR2_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SCI0_SIMR2_Reserved_Msk = 0xc0
	// Position of IICACKT field.
	SCI0_SIMR2_IICACKT_Pos = 0x5
	// Bit mask of IICACKT field.
	SCI0_SIMR2_IICACKT_Msk = 0x20
	// Bit IICACKT.
	SCI0_SIMR2_IICACKT = 0x20
	// ACK transmission
	SCI0_SIMR2_IICACKT_0 = 0x0
	// NACK transmission and reception of ACK/NACK
	SCI0_SIMR2_IICACKT_1 = 0x1
	// Position of Reserved field.
	SCI0_SIMR2_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SCI0_SIMR2_Reserved_Msk = 0x1c
	// Position of IICCSC field.
	SCI0_SIMR2_IICCSC_Pos = 0x1
	// Bit mask of IICCSC field.
	SCI0_SIMR2_IICCSC_Msk = 0x2
	// Bit IICCSC.
	SCI0_SIMR2_IICCSC = 0x2
	// No synchronization with the clock signal
	SCI0_SIMR2_IICCSC_0 = 0x0
	// Synchronization with the clock signal
	SCI0_SIMR2_IICCSC_1 = 0x1
	// Position of IICINTM field.
	SCI0_SIMR2_IICINTM_Pos = 0x0
	// Bit mask of IICINTM field.
	SCI0_SIMR2_IICINTM_Msk = 0x1
	// Bit IICINTM.
	SCI0_SIMR2_IICINTM = 0x1
	// Use ACK/NACK interrupts.
	SCI0_SIMR2_IICINTM_0 = 0x0
	// Use reception and transmission interrupts
	SCI0_SIMR2_IICINTM_1 = 0x1

	// SIMR3: I2C Mode Register 3
	// Position of IICSCLS field.
	SCI0_SIMR3_IICSCLS_Pos = 0x6
	// Bit mask of IICSCLS field.
	SCI0_SIMR3_IICSCLS_Msk = 0xc0
	// Serial clock output
	SCI0_SIMR3_IICSCLS_00 = 0x0
	// Generate a start, restart, or stop condition.
	SCI0_SIMR3_IICSCLS_01 = 0x1
	// Output the low level on the SSCLn pin.
	SCI0_SIMR3_IICSCLS_10 = 0x2
	// Place the SSCLn pin in the high-impedance state.
	SCI0_SIMR3_IICSCLS_11 = 0x3
	// Position of IICSDAS field.
	SCI0_SIMR3_IICSDAS_Pos = 0x4
	// Bit mask of IICSDAS field.
	SCI0_SIMR3_IICSDAS_Msk = 0x30
	// Serial data output
	SCI0_SIMR3_IICSDAS_00 = 0x0
	// Generate a start, restart, or stop condition.
	SCI0_SIMR3_IICSDAS_01 = 0x1
	// Output the low level on the SSDAn pin.
	SCI0_SIMR3_IICSDAS_10 = 0x2
	// Place the SSDAn pin in the high-impedance state.
	SCI0_SIMR3_IICSDAS_11 = 0x3
	// Position of IICSTIF field.
	SCI0_SIMR3_IICSTIF_Pos = 0x3
	// Bit mask of IICSTIF field.
	SCI0_SIMR3_IICSTIF_Msk = 0x8
	// Bit IICSTIF.
	SCI0_SIMR3_IICSTIF = 0x8
	// There are no requests for generating conditions or a condition is being generated.
	SCI0_SIMR3_IICSTIF_0 = 0x0
	// A start, restart, or stop condition is completely generated.
	SCI0_SIMR3_IICSTIF_1 = 0x1
	// Position of IICSTPREQ field.
	SCI0_SIMR3_IICSTPREQ_Pos = 0x2
	// Bit mask of IICSTPREQ field.
	SCI0_SIMR3_IICSTPREQ_Msk = 0x4
	// Bit IICSTPREQ.
	SCI0_SIMR3_IICSTPREQ = 0x4
	// A stop condition is not generated.
	SCI0_SIMR3_IICSTPREQ_0 = 0x0
	// A stop condition is generated.
	SCI0_SIMR3_IICSTPREQ_1 = 0x1
	// Position of IICRSTAREQ field.
	SCI0_SIMR3_IICRSTAREQ_Pos = 0x1
	// Bit mask of IICRSTAREQ field.
	SCI0_SIMR3_IICRSTAREQ_Msk = 0x2
	// Bit IICRSTAREQ.
	SCI0_SIMR3_IICRSTAREQ = 0x2
	// A restart condition is not generated.
	SCI0_SIMR3_IICRSTAREQ_0 = 0x0
	// A restart condition is generated.
	SCI0_SIMR3_IICRSTAREQ_1 = 0x1
	// Position of IICSTAREQ field.
	SCI0_SIMR3_IICSTAREQ_Pos = 0x0
	// Bit mask of IICSTAREQ field.
	SCI0_SIMR3_IICSTAREQ_Msk = 0x1
	// Bit IICSTAREQ.
	SCI0_SIMR3_IICSTAREQ = 0x1
	// A start condition is not generated.
	SCI0_SIMR3_IICSTAREQ_0 = 0x0
	// A start condition is generated.
	SCI0_SIMR3_IICSTAREQ_1 = 0x1

	// SISR: I2C Status Register
	// Position of Reserved field.
	SCI0_SISR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SCI0_SISR_Reserved_Msk = 0xc0
	// Position of Reserved field.
	SCI0_SISR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI0_SISR_Reserved_Msk = 0x20
	// Bit Reserved.
	SCI0_SISR_Reserved = 0x20
	// Position of Reserved field.
	SCI0_SISR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SCI0_SISR_Reserved_Msk = 0x10
	// Bit Reserved.
	SCI0_SISR_Reserved = 0x10
	// Position of Reserved field.
	SCI0_SISR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI0_SISR_Reserved_Msk = 0x8
	// Bit Reserved.
	SCI0_SISR_Reserved = 0x8
	// Position of Reserved field.
	SCI0_SISR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SCI0_SISR_Reserved_Msk = 0x4
	// Bit Reserved.
	SCI0_SISR_Reserved = 0x4
	// Position of Reserved field.
	SCI0_SISR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI0_SISR_Reserved_Msk = 0x2
	// Bit Reserved.
	SCI0_SISR_Reserved = 0x2
	// Position of IICACKR field.
	SCI0_SISR_IICACKR_Pos = 0x0
	// Bit mask of IICACKR field.
	SCI0_SISR_IICACKR_Msk = 0x1
	// Bit IICACKR.
	SCI0_SISR_IICACKR = 0x1
	// ACK received
	SCI0_SISR_IICACKR_0 = 0x0
	// NACK received
	SCI0_SISR_IICACKR_1 = 0x1

	// SPMR: SPI Mode Register
	// Position of CKPH field.
	SCI0_SPMR_CKPH_Pos = 0x7
	// Bit mask of CKPH field.
	SCI0_SPMR_CKPH_Msk = 0x80
	// Bit CKPH.
	SCI0_SPMR_CKPH = 0x80
	// Clock is not delayed.
	SCI0_SPMR_CKPH_0 = 0x0
	// Clock is delayed.
	SCI0_SPMR_CKPH_1 = 0x1
	// Position of CKPOL field.
	SCI0_SPMR_CKPOL_Pos = 0x6
	// Bit mask of CKPOL field.
	SCI0_SPMR_CKPOL_Msk = 0x40
	// Bit CKPOL.
	SCI0_SPMR_CKPOL = 0x40
	// Clock polarity is not inverted.
	SCI0_SPMR_CKPOL_0 = 0x0
	// Clock polarity is inverted
	SCI0_SPMR_CKPOL_1 = 0x1
	// Position of Reserved field.
	SCI0_SPMR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI0_SPMR_Reserved_Msk = 0x20
	// Bit Reserved.
	SCI0_SPMR_Reserved = 0x20
	// Position of MFF field.
	SCI0_SPMR_MFF_Pos = 0x4
	// Bit mask of MFF field.
	SCI0_SPMR_MFF_Msk = 0x10
	// Bit MFF.
	SCI0_SPMR_MFF = 0x10
	// No mode fault error
	SCI0_SPMR_MFF_0 = 0x0
	// Mode fault error
	SCI0_SPMR_MFF_1 = 0x1
	// Position of Reserved field.
	SCI0_SPMR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI0_SPMR_Reserved_Msk = 0x8
	// Bit Reserved.
	SCI0_SPMR_Reserved = 0x8
	// Position of MSS field.
	SCI0_SPMR_MSS_Pos = 0x2
	// Bit mask of MSS field.
	SCI0_SPMR_MSS_Msk = 0x4
	// Bit MSS.
	SCI0_SPMR_MSS = 0x4
	// Transmission is through the TXDn pin and reception is through the RXDn pin (master mode).
	SCI0_SPMR_MSS_0 = 0x0
	// Reception is through the TXDn pin and transmission is through the RXDn pin (slave mode).
	SCI0_SPMR_MSS_1 = 0x1
	// Position of CTSE field.
	SCI0_SPMR_CTSE_Pos = 0x1
	// Bit mask of CTSE field.
	SCI0_SPMR_CTSE_Msk = 0x2
	// Bit CTSE.
	SCI0_SPMR_CTSE = 0x2
	// CTS function is disabled (RTS output function is enabled).
	SCI0_SPMR_CTSE_0 = 0x0
	// CTS function is enabled.
	SCI0_SPMR_CTSE_1 = 0x1
	// Position of SSE field.
	SCI0_SPMR_SSE_Pos = 0x0
	// Bit mask of SSE field.
	SCI0_SPMR_SSE_Msk = 0x1
	// Bit SSE.
	SCI0_SPMR_SSE = 0x1
	// SSn pin function is disabled.
	SCI0_SPMR_SSE_0 = 0x0
	// SSn pin function is enabled.
	SCI0_SPMR_SSE_1 = 0x1

	// TDRHL: Transmit 9-bit Data Register
	// Position of TDRHL field.
	SCI0_TDRHL_TDRHL_Pos = 0x0
	// Bit mask of TDRHL field.
	SCI0_TDRHL_TDRHL_Msk = 0xffff

	// FTDRHL: Transmit FIFO Data Register HL
	// Position of Reserved field.
	SCI0_FTDRHL_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	SCI0_FTDRHL_Reserved_Msk = 0xfc00
	// Position of MPBT field.
	SCI0_FTDRHL_MPBT_Pos = 0x9
	// Bit mask of MPBT field.
	SCI0_FTDRHL_MPBT_Msk = 0x200
	// Bit MPBT.
	SCI0_FTDRHL_MPBT = 0x200
	// Data transmission cycles
	SCI0_FTDRHL_MPBT_0 = 0x0
	// ID transmission cycles
	SCI0_FTDRHL_MPBT_1 = 0x1
	// Position of TDAT field.
	SCI0_FTDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI0_FTDRHL_TDAT_Msk = 0x1ff

	// FTDRH: Transmit FIFO Data Register H
	// Position of Reserved field.
	SCI0_FTDRH_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SCI0_FTDRH_Reserved_Msk = 0xfc
	// Position of MPBT field.
	SCI0_FTDRH_MPBT_Pos = 0x1
	// Bit mask of MPBT field.
	SCI0_FTDRH_MPBT_Msk = 0x2
	// Bit MPBT.
	SCI0_FTDRH_MPBT = 0x2
	// Data transmission cycles
	SCI0_FTDRH_MPBT_0 = 0x0
	// ID transmission cycles
	SCI0_FTDRH_MPBT_1 = 0x1
	// Position of TDATH field.
	SCI0_FTDRH_TDATH_Pos = 0x0
	// Bit mask of TDATH field.
	SCI0_FTDRH_TDATH_Msk = 0x1
	// Bit TDATH.
	SCI0_FTDRH_TDATH = 0x1

	// FTDRL: Transmit FIFO Data Register L
	// Position of TDATL field.
	SCI0_FTDRL_TDATL_Pos = 0x0
	// Bit mask of TDATL field.
	SCI0_FTDRL_TDATL_Msk = 0xff

	// RDRHL: Receive 9-bit Data Register
	// Position of RDRHL field.
	SCI0_RDRHL_RDRHL_Pos = 0x0
	// Bit mask of RDRHL field.
	SCI0_RDRHL_RDRHL_Msk = 0xffff

	// FRDRHL: Receive FIFO Data Register HL
	// Position of Reserved field.
	SCI0_FRDRHL_Reserved_Pos = 0xf
	// Bit mask of Reserved field.
	SCI0_FRDRHL_Reserved_Msk = 0x8000
	// Bit Reserved.
	SCI0_FRDRHL_Reserved = 0x8000
	// Position of RDF field.
	SCI0_FRDRHL_RDF_Pos = 0xe
	// Bit mask of RDF field.
	SCI0_FRDRHL_RDF_Msk = 0x4000
	// Bit RDF.
	SCI0_FRDRHL_RDF = 0x4000
	// The quantity of receive data written in FRDRH and FRDRL falls below the specified receive triggering number.
	SCI0_FRDRHL_RDF_0 = 0x0
	// The quantity of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number.
	SCI0_FRDRHL_RDF_1 = 0x1
	// Position of ORER field.
	SCI0_FRDRHL_ORER_Pos = 0xd
	// Bit mask of ORER field.
	SCI0_FRDRHL_ORER_Msk = 0x2000
	// Bit ORER.
	SCI0_FRDRHL_ORER = 0x2000
	// No overrun error occurred.
	SCI0_FRDRHL_ORER_0 = 0x0
	// An overrun error has occurred.
	SCI0_FRDRHL_ORER_1 = 0x1
	// Position of FER field.
	SCI0_FRDRHL_FER_Pos = 0xc
	// Bit mask of FER field.
	SCI0_FRDRHL_FER_Msk = 0x1000
	// Bit FER.
	SCI0_FRDRHL_FER = 0x1000
	// No framing error occurred at the first data of FRDRH and FRDRL.
	SCI0_FRDRHL_FER_0 = 0x0
	// A framing error has occurred at the first data of FRDRH and FRDRL.
	SCI0_FRDRHL_FER_1 = 0x1
	// Position of PER field.
	SCI0_FRDRHL_PER_Pos = 0xb
	// Bit mask of PER field.
	SCI0_FRDRHL_PER_Msk = 0x800
	// Bit PER.
	SCI0_FRDRHL_PER = 0x800
	// No parity error occurred at the first data of FRDRH and FRDRL.
	SCI0_FRDRHL_PER_0 = 0x0
	// A parity error has occurred at the first data of FRDRH and FRDRL.
	SCI0_FRDRHL_PER_1 = 0x1
	// Position of DR field.
	SCI0_FRDRHL_DR_Pos = 0xa
	// Bit mask of DR field.
	SCI0_FRDRHL_DR_Msk = 0x400
	// Bit DR.
	SCI0_FRDRHL_DR = 0x400
	// Receiving is in progress, or no received data has remained in FRDRH and FRDRL after normally completed receiving.
	SCI0_FRDRHL_DR_0 = 0x0
	// Next receive data has not been received for a period after normal completed receiving.
	SCI0_FRDRHL_DR_1 = 0x1
	// Position of MPB field.
	SCI0_FRDRHL_MPB_Pos = 0x9
	// Bit mask of MPB field.
	SCI0_FRDRHL_MPB_Msk = 0x200
	// Bit MPB.
	SCI0_FRDRHL_MPB = 0x200
	// Data transmission cycles
	SCI0_FRDRHL_MPB_0 = 0x0
	// ID transmission cycles
	SCI0_FRDRHL_MPB_1 = 0x1
	// Position of RDAT field.
	SCI0_FRDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI0_FRDRHL_RDAT_Msk = 0x1ff

	// FRDRH: Receive FIFO Data Register H
	// Position of Reserved field.
	SCI0_FRDRH_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	SCI0_FRDRH_Reserved_Msk = 0x80
	// Bit Reserved.
	SCI0_FRDRH_Reserved = 0x80
	// Position of RDF field.
	SCI0_FRDRH_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI0_FRDRH_RDF_Msk = 0x40
	// Bit RDF.
	SCI0_FRDRH_RDF = 0x40
	// The quantity of receive data written in FRDRH and FRDRL falls below the specified receive triggering number.
	SCI0_FRDRH_RDF_0 = 0x0
	// The quantity of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number.
	SCI0_FRDRH_RDF_1 = 0x1
	// Position of ORER field.
	SCI0_FRDRH_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_FRDRH_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_FRDRH_ORER = 0x20
	// No overrun error occurred
	SCI0_FRDRH_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_FRDRH_ORER_1 = 0x1
	// Position of FER field.
	SCI0_FRDRH_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_FRDRH_FER_Msk = 0x10
	// Bit FER.
	SCI0_FRDRH_FER = 0x10
	// No framing error occurred at the first data of FRDRH and FRDRL
	SCI0_FRDRH_FER_0 = 0x0
	// A framing error has occurred at the first data of FRDRH and FRDRL
	SCI0_FRDRH_FER_1 = 0x1
	// Position of PER field.
	SCI0_FRDRH_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_FRDRH_PER_Msk = 0x8
	// Bit PER.
	SCI0_FRDRH_PER = 0x8
	// No parity error occurred at the first data of FRDRH and FRDRL
	SCI0_FRDRH_PER_0 = 0x0
	// A parity error has occurred at the first data of FRDRH and FRDRL
	SCI0_FRDRH_PER_1 = 0x1
	// Position of DR field.
	SCI0_FRDRH_DR_Pos = 0x2
	// Bit mask of DR field.
	SCI0_FRDRH_DR_Msk = 0x4
	// Bit DR.
	SCI0_FRDRH_DR = 0x4
	// Receiving is in progress, or no received data has remained in FRDRH and FRDRL after normally completed receiving.
	SCI0_FRDRH_DR_0 = 0x0
	// Next receive data has not been received for a period after normal completed receiving.
	SCI0_FRDRH_DR_1 = 0x1
	// Position of MPB field.
	SCI0_FRDRH_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_FRDRH_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_FRDRH_MPB = 0x2
	// Data transmission cycles
	SCI0_FRDRH_MPB_0 = 0x0
	// ID transmission cycles
	SCI0_FRDRH_MPB_1 = 0x1
	// Position of RDATH field.
	SCI0_FRDRH_RDATH_Pos = 0x0
	// Bit mask of RDATH field.
	SCI0_FRDRH_RDATH_Msk = 0x1
	// Bit RDATH.
	SCI0_FRDRH_RDATH = 0x1

	// FRDRL: Receive FIFO Data Register L
	// Position of RDATL field.
	SCI0_FRDRL_RDATL_Pos = 0x0
	// Bit mask of RDATL field.
	SCI0_FRDRL_RDATL_Msk = 0xff

	// MDDR: Modulation Duty Register
	// Position of MDDR field.
	SCI0_MDDR_MDDR_Pos = 0x0
	// Bit mask of MDDR field.
	SCI0_MDDR_MDDR_Msk = 0xff

	// DCCR: Data Compare Match Control Register
	// Position of DCME field.
	SCI0_DCCR_DCME_Pos = 0x7
	// Bit mask of DCME field.
	SCI0_DCCR_DCME_Msk = 0x80
	// Bit DCME.
	SCI0_DCCR_DCME = 0x80
	// Address match function is disabled.
	SCI0_DCCR_DCME_0 = 0x0
	// Address match function is enabled
	SCI0_DCCR_DCME_1 = 0x1
	// Position of IDSEL field.
	SCI0_DCCR_IDSEL_Pos = 0x6
	// Bit mask of IDSEL field.
	SCI0_DCCR_IDSEL_Msk = 0x40
	// Bit IDSEL.
	SCI0_DCCR_IDSEL = 0x40
	// Always compare data regardless of the value of the MPB bit.
	SCI0_DCCR_IDSEL_0 = 0x0
	// Compare data when the MPB bit is 1 (ID frame) only.
	SCI0_DCCR_IDSEL_1 = 0x1
	// Position of Reserved field.
	SCI0_DCCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI0_DCCR_Reserved_Msk = 0x20
	// Bit Reserved.
	SCI0_DCCR_Reserved = 0x20
	// Position of DFER field.
	SCI0_DCCR_DFER_Pos = 0x4
	// Bit mask of DFER field.
	SCI0_DCCR_DFER_Msk = 0x10
	// Bit DFER.
	SCI0_DCCR_DFER = 0x10
	// No framing error occurred
	SCI0_DCCR_DFER_0 = 0x0
	// A framing error has occurred
	SCI0_DCCR_DFER_1 = 0x1
	// Position of DPER field.
	SCI0_DCCR_DPER_Pos = 0x3
	// Bit mask of DPER field.
	SCI0_DCCR_DPER_Msk = 0x8
	// Bit DPER.
	SCI0_DCCR_DPER = 0x8
	// No parity error occurred
	SCI0_DCCR_DPER_0 = 0x0
	// A parity error has occurred
	SCI0_DCCR_DPER_1 = 0x1
	// Position of Reserved field.
	SCI0_DCCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI0_DCCR_Reserved_Msk = 0x6
	// Position of DCMF field.
	SCI0_DCCR_DCMF_Pos = 0x0
	// Bit mask of DCMF field.
	SCI0_DCCR_DCMF_Msk = 0x1
	// Bit DCMF.
	SCI0_DCCR_DCMF = 0x1
	// No matched
	SCI0_DCCR_DCMF_0 = 0x0
	// Matched
	SCI0_DCCR_DCMF_1 = 0x1

	// FCR: FIFO Control Register
	// Position of RSTRG field.
	SCI0_FCR_RSTRG_Pos = 0xc
	// Bit mask of RSTRG field.
	SCI0_FCR_RSTRG_Msk = 0xf000
	// Trigger number 0
	SCI0_FCR_RSTRG_0000 = 0x0
	// Position of RTRG field.
	SCI0_FCR_RTRG_Pos = 0x8
	// Bit mask of RTRG field.
	SCI0_FCR_RTRG_Msk = 0xf00
	// Trigger number 0
	SCI0_FCR_RTRG_0000 = 0x0
	// Position of TTRG field.
	SCI0_FCR_TTRG_Pos = 0x4
	// Bit mask of TTRG field.
	SCI0_FCR_TTRG_Msk = 0xf0
	// Trigger number 0
	SCI0_FCR_TTRG_0000 = 0x0
	// Position of DRES field.
	SCI0_FCR_DRES_Pos = 0x3
	// Bit mask of DRES field.
	SCI0_FCR_DRES_Msk = 0x8
	// Bit DRES.
	SCI0_FCR_DRES = 0x8
	// reception data full interrupt (RXI)
	SCI0_FCR_DRES_0 = 0x0
	// receive error interrupt (ERI)
	SCI0_FCR_DRES_1 = 0x1
	// Position of TFRST field.
	SCI0_FCR_TFRST_Pos = 0x2
	// Bit mask of TFRST field.
	SCI0_FCR_TFRST_Msk = 0x4
	// Bit TFRST.
	SCI0_FCR_TFRST = 0x4
	// The number of data stored in FTDRH and FTDRL register are NOT made 0
	SCI0_FCR_TFRST_0 = 0x0
	// The number of data stored in FTDRH and FTDRL register are made 0
	SCI0_FCR_TFRST_1 = 0x1
	// Position of RFRST field.
	SCI0_FCR_RFRST_Pos = 0x1
	// Bit mask of RFRST field.
	SCI0_FCR_RFRST_Msk = 0x2
	// Bit RFRST.
	SCI0_FCR_RFRST = 0x2
	// The number of data stored in FRDRH and FRDRL register are NOT made 0
	SCI0_FCR_RFRST_0 = 0x0
	// The number of data stored in FRDRH and FRDRL register are made 0
	SCI0_FCR_RFRST_1 = 0x1
	// Position of FM field.
	SCI0_FCR_FM_Pos = 0x0
	// Bit mask of FM field.
	SCI0_FCR_FM_Msk = 0x1
	// Bit FM.
	SCI0_FCR_FM = 0x1
	// Non-FIFO mode(Selects o TDR/RDR for communication)
	SCI0_FCR_FM_0 = 0x0
	// FIFO mode (Selects to FTDRH and FTDRL/FRDRH and FRDRL for communication)
	SCI0_FCR_FM_1 = 0x1

	// FDR: FIFO Data Count Register
	// Position of Reserved field.
	SCI0_FDR_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	SCI0_FDR_Reserved_Msk = 0xe000
	// Position of T field.
	SCI0_FDR_T_Pos = 0x8
	// Bit mask of T field.
	SCI0_FDR_T_Msk = 0x1f00
	// Position of Reserved field.
	SCI0_FDR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI0_FDR_Reserved_Msk = 0xe0
	// Position of R field.
	SCI0_FDR_R_Pos = 0x0
	// Bit mask of R field.
	SCI0_FDR_R_Msk = 0x1f

	// LSR: Line Status Register
	// Position of Reserved field.
	SCI0_LSR_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	SCI0_LSR_Reserved_Msk = 0xe000
	// Position of PNUM field.
	SCI0_LSR_PNUM_Pos = 0x8
	// Bit mask of PNUM field.
	SCI0_LSR_PNUM_Msk = 0x1f00
	// Position of Reserved field.
	SCI0_LSR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	SCI0_LSR_Reserved_Msk = 0x80
	// Bit Reserved.
	SCI0_LSR_Reserved = 0x80
	// Position of FNUM field.
	SCI0_LSR_FNUM_Pos = 0x2
	// Bit mask of FNUM field.
	SCI0_LSR_FNUM_Msk = 0x7c
	// Position of Reserved field.
	SCI0_LSR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI0_LSR_Reserved_Msk = 0x2
	// Bit Reserved.
	SCI0_LSR_Reserved = 0x2
	// Position of ORER field.
	SCI0_LSR_ORER_Pos = 0x0
	// Bit mask of ORER field.
	SCI0_LSR_ORER_Msk = 0x1
	// Bit ORER.
	SCI0_LSR_ORER = 0x1
	// No overrun error occurred
	SCI0_LSR_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_LSR_ORER_1 = 0x1

	// CDR: Compare Match Data Register
	// Position of Reserved field.
	SCI0_CDR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	SCI0_CDR_Reserved_Msk = 0xfe00
	// Position of CMPD field.
	SCI0_CDR_CMPD_Pos = 0x0
	// Bit mask of CMPD field.
	SCI0_CDR_CMPD_Msk = 0x1ff

	// SPTR: Serial Port Register
	// Position of Reserved field.
	SCI0_SPTR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI0_SPTR_Reserved_Msk = 0xf8
	// Position of SPB2IO field.
	SCI0_SPTR_SPB2IO_Pos = 0x2
	// Bit mask of SPB2IO field.
	SCI0_SPTR_SPB2IO_Msk = 0x4
	// Bit SPB2IO.
	SCI0_SPTR_SPB2IO = 0x4
	// The value of SPB2DT bit is not output in TXD pin.
	SCI0_SPTR_SPB2IO_0 = 0x0
	// The value of SPB2DT bit is output in TXD pin.
	SCI0_SPTR_SPB2IO_1 = 0x1
	// Position of SPB2DT field.
	SCI0_SPTR_SPB2DT_Pos = 0x1
	// Bit mask of SPB2DT field.
	SCI0_SPTR_SPB2DT_Msk = 0x2
	// Bit SPB2DT.
	SCI0_SPTR_SPB2DT = 0x2
	// Low level is output on TXD pin
	SCI0_SPTR_SPB2DT_0 = 0x0
	// High level is output on TXD pin
	SCI0_SPTR_SPB2DT_1 = 0x1
	// Position of RXDMON field.
	SCI0_SPTR_RXDMON_Pos = 0x0
	// Bit mask of RXDMON field.
	SCI0_SPTR_RXDMON_Msk = 0x1
	// Bit RXDMON.
	SCI0_SPTR_RXDMON = 0x1
	// RXD pin is low.
	SCI0_SPTR_RXDMON_0 = 0x0
	// RXD pin is high.
	SCI0_SPTR_RXDMON_1 = 0x1
)

// Constants for SCI2: Serial Communication Interface 2
const (
	// SMR: Serial Mode Register (SCMR.SMIF = 0)
	// Position of CM field.
	SCI2_SMR_CM_Pos = 0x7
	// Bit mask of CM field.
	SCI2_SMR_CM_Msk = 0x80
	// Bit CM.
	SCI2_SMR_CM = 0x80
	// Asynchronous mode or simple I2C mode
	SCI2_SMR_CM_0 = 0x0
	// Clock synchronous mode
	SCI2_SMR_CM_1 = 0x1
	// Position of CHR field.
	SCI2_SMR_CHR_Pos = 0x6
	// Bit mask of CHR field.
	SCI2_SMR_CHR_Msk = 0x40
	// Bit CHR.
	SCI2_SMR_CHR = 0x40
	// Transmit/receive in 9-bit data length(SCMR.CHR1=0) / in 8bit data length(SCMR.CHR1=1)
	SCI2_SMR_CHR_0 = 0x0
	// Transmit/receive in 9-bit data length(SCMR.CHR1=0) / in 7bit data length(SCMR.CHR1=1)
	SCI2_SMR_CHR_1 = 0x1
	// Position of PE field.
	SCI2_SMR_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI2_SMR_PE_Msk = 0x20
	// Bit PE.
	SCI2_SMR_PE = 0x20
	// Parity bit addition is not performed (transmitting) / Parity bit checking is not performed ( receiving )
	SCI2_SMR_PE_0 = 0x0
	// The parity bit is added (transmitting) / The parity bit is checked (receiving)
	SCI2_SMR_PE_1 = 0x1
	// Position of PM field.
	SCI2_SMR_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI2_SMR_PM_Msk = 0x10
	// Bit PM.
	SCI2_SMR_PM = 0x10
	// Selects even parity
	SCI2_SMR_PM_0 = 0x0
	// Selects odd parity
	SCI2_SMR_PM_1 = 0x1
	// Position of STOP field.
	SCI2_SMR_STOP_Pos = 0x3
	// Bit mask of STOP field.
	SCI2_SMR_STOP_Msk = 0x8
	// Bit STOP.
	SCI2_SMR_STOP = 0x8
	// 1 stop bit
	SCI2_SMR_STOP_0 = 0x0
	// 2 stop bits
	SCI2_SMR_STOP_1 = 0x1
	// Position of MP field.
	SCI2_SMR_MP_Pos = 0x2
	// Bit mask of MP field.
	SCI2_SMR_MP_Msk = 0x4
	// Bit MP.
	SCI2_SMR_MP = 0x4
	// Multi-processor communications function is disabled
	SCI2_SMR_MP_0 = 0x0
	// Multi-processor communications function is enabled
	SCI2_SMR_MP_1 = 0x1
	// Position of CKS field.
	SCI2_SMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI2_SMR_CKS_Msk = 0x3
	// PCLK clock
	SCI2_SMR_CKS_00 = 0x0
	// PCLK/4 clock
	SCI2_SMR_CKS_01 = 0x1
	// PCLK/16 clock
	SCI2_SMR_CKS_10 = 0x2
	// PCLK/64 clock
	SCI2_SMR_CKS_11 = 0x3

	// SMR_SMCI: Serial mode register (SCMR.SMIF = 1)
	// Position of GM field.
	SCI2_SMR_SMCI_GM_Pos = 0x7
	// Bit mask of GM field.
	SCI2_SMR_SMCI_GM_Msk = 0x80
	// Bit GM.
	SCI2_SMR_SMCI_GM = 0x80
	// Normal mode operation
	SCI2_SMR_SMCI_GM_0 = 0x0
	// GSM mode operation
	SCI2_SMR_SMCI_GM_1 = 0x1
	// Position of BLK field.
	SCI2_SMR_SMCI_BLK_Pos = 0x6
	// Bit mask of BLK field.
	SCI2_SMR_SMCI_BLK_Msk = 0x40
	// Bit BLK.
	SCI2_SMR_SMCI_BLK = 0x40
	// Normal mode operation
	SCI2_SMR_SMCI_BLK_0 = 0x0
	// Block transfer mode operation
	SCI2_SMR_SMCI_BLK_1 = 0x1
	// Position of PE field.
	SCI2_SMR_SMCI_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI2_SMR_SMCI_PE_Msk = 0x20
	// Bit PE.
	SCI2_SMR_SMCI_PE = 0x20
	// Setting Prohibited
	SCI2_SMR_SMCI_PE_0 = 0x0
	// Set this bit to 1 in smart card interface mode.
	SCI2_SMR_SMCI_PE_1 = 0x1
	// Position of PM field.
	SCI2_SMR_SMCI_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI2_SMR_SMCI_PM_Msk = 0x10
	// Bit PM.
	SCI2_SMR_SMCI_PM = 0x10
	// Selects even parity
	SCI2_SMR_SMCI_PM_0 = 0x0
	// Selects odd parity
	SCI2_SMR_SMCI_PM_1 = 0x1
	// Position of BCP field.
	SCI2_SMR_SMCI_BCP_Pos = 0x2
	// Bit mask of BCP field.
	SCI2_SMR_SMCI_BCP_Msk = 0xc
	// 93 clock cycles(S=93) (SCMR.BCP2=0) / 32 clock cycles(S=32) (SCMR.BCP2=1)
	SCI2_SMR_SMCI_BCP_00 = 0x0
	// 128 clock cycles(S=128) (SCMR.BCP2=0) / 64 clock cycles(S=64) (SCMR.BCP2=1)
	SCI2_SMR_SMCI_BCP_01 = 0x1
	// 186 clock cycles(S=186) (SCMR.BCP2=0) / 372 clock cycles(S=372) (SCMR.BCP2=1)
	SCI2_SMR_SMCI_BCP_10 = 0x2
	// 512 clock cycles(S=512) (SCMR.BCP2=0) / 256 clock cycles(S=256) (SCMR.BCP2=1)
	SCI2_SMR_SMCI_BCP_11 = 0x3
	// Position of CKS field.
	SCI2_SMR_SMCI_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI2_SMR_SMCI_CKS_Msk = 0x3
	// PCLK clock
	SCI2_SMR_SMCI_CKS_00 = 0x0
	// PCLK/4 clock
	SCI2_SMR_SMCI_CKS_01 = 0x1
	// PCLK/16 clock
	SCI2_SMR_SMCI_CKS_10 = 0x2
	// PCLK/64 clock
	SCI2_SMR_SMCI_CKS_11 = 0x3

	// BRR: Bit Rate Register
	// Position of BRR field.
	SCI2_BRR_BRR_Pos = 0x0
	// Bit mask of BRR field.
	SCI2_BRR_BRR_Msk = 0xff

	// SCR: Serial Control Register (SCMR.SMIF = 0)
	// Position of TIE field.
	SCI2_SCR_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI2_SCR_TIE_Msk = 0x80
	// Bit TIE.
	SCI2_SCR_TIE = 0x80
	// SCI_TXI interrupt request is disabled
	SCI2_SCR_TIE_0 = 0x0
	// SCI_TXI interrupt request is enabled
	SCI2_SCR_TIE_1 = 0x1
	// Position of RIE field.
	SCI2_SCR_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI2_SCR_RIE_Msk = 0x40
	// Bit RIE.
	SCI2_SCR_RIE = 0x40
	// SCI_RXI and SCI_ERI interrupt requests are disabled
	SCI2_SCR_RIE_0 = 0x0
	// SCI_RXI and SCI_ERI interrupt requests are enabled
	SCI2_SCR_RIE_1 = 0x1
	// Position of TE field.
	SCI2_SCR_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI2_SCR_TE_Msk = 0x20
	// Bit TE.
	SCI2_SCR_TE = 0x20
	// Serial transmission is disabled
	SCI2_SCR_TE_0 = 0x0
	// Serial transmission is enabled
	SCI2_SCR_TE_1 = 0x1
	// Position of RE field.
	SCI2_SCR_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI2_SCR_RE_Msk = 0x10
	// Bit RE.
	SCI2_SCR_RE = 0x10
	// Serial reception is disabled
	SCI2_SCR_RE_0 = 0x0
	// Serial reception is enabled
	SCI2_SCR_RE_1 = 0x1
	// Position of MPIE field.
	SCI2_SCR_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI2_SCR_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI2_SCR_MPIE = 0x8
	// Normal reception
	SCI2_SCR_MPIE_0 = 0x0
	// When the data with the multi-processor bit set to 0 is received, the data is not read, and setting the status flags RDRF,ORER and FER in SSR to 1 is disabled. When the data with the multiprocessor bit set to 1 is received, the MPIE bit is automatically cleared to 0, and normal reception is resumed.
	SCI2_SCR_MPIE_1 = 0x1
	// Position of TEIE field.
	SCI2_SCR_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI2_SCR_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI2_SCR_TEIE = 0x4
	// SCI_TEI interrupt request is disabled
	SCI2_SCR_TEIE_0 = 0x0
	// SCI_TEI interrupt request is enabled
	SCI2_SCR_TEIE_1 = 0x1
	// Position of CKE field.
	SCI2_SCR_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI2_SCR_CKE_Msk = 0x3
	// The SCKn pin is available for use as an I/O port in accord with the I/O port settings.(Asynchronous mode) / The SCKn pin functions as the clock output pin(Clock synchronous mode)
	SCI2_SCR_CKE_00 = 0x0
	// The clock with the same frequency as the bit rate is output from the SCKn pin.(Asynchronous mode) / The SCKn pin functions as the clock output pin(Clock synchronous mode)
	SCI2_SCR_CKE_01 = 0x1

	// SCR_SMCI: Serial Control Register (SCMR.SMIF =1)
	// Position of TIE field.
	SCI2_SCR_SMCI_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI2_SCR_SMCI_TIE_Msk = 0x80
	// Bit TIE.
	SCI2_SCR_SMCI_TIE = 0x80
	// A SCI_TXI interrupt request is disabled
	SCI2_SCR_SMCI_TIE_0 = 0x0
	// A SCI_TXI interrupt request is enabled
	SCI2_SCR_SMCI_TIE_1 = 0x1
	// Position of RIE field.
	SCI2_SCR_SMCI_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI2_SCR_SMCI_RIE_Msk = 0x40
	// Bit RIE.
	SCI2_SCR_SMCI_RIE = 0x40
	// SCI_RXI and SCI_ERI interrupt requests are disabled
	SCI2_SCR_SMCI_RIE_0 = 0x0
	// SCI_RXI and SCI_ERI interrupt requests are enabled
	SCI2_SCR_SMCI_RIE_1 = 0x1
	// Position of TE field.
	SCI2_SCR_SMCI_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI2_SCR_SMCI_TE_Msk = 0x20
	// Bit TE.
	SCI2_SCR_SMCI_TE = 0x20
	// Serial transmission is disabled
	SCI2_SCR_SMCI_TE_0 = 0x0
	// Serial transmission is enabled
	SCI2_SCR_SMCI_TE_1 = 0x1
	// Position of RE field.
	SCI2_SCR_SMCI_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI2_SCR_SMCI_RE_Msk = 0x10
	// Bit RE.
	SCI2_SCR_SMCI_RE = 0x10
	// Serial reception is disabled
	SCI2_SCR_SMCI_RE_0 = 0x0
	// Serial reception is enabled
	SCI2_SCR_SMCI_RE_1 = 0x1
	// Position of MPIE field.
	SCI2_SCR_SMCI_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI2_SCR_SMCI_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI2_SCR_SMCI_MPIE = 0x8
	// Position of TEIE field.
	SCI2_SCR_SMCI_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI2_SCR_SMCI_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI2_SCR_SMCI_TEIE = 0x4
	// Position of CKE field.
	SCI2_SCR_SMCI_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI2_SCR_SMCI_CKE_Msk = 0x3
	// Output disabled(SMR_SMCI.GM=0) / Output fixed low(SMR_SMCI.GM=1)
	SCI2_SCR_SMCI_CKE_00 = 0x0
	// Clock Output
	SCI2_SCR_SMCI_CKE_01 = 0x1
	// Setting prohibited(SMR_SMCI.GM=0) / Output fixed High(SMR_SMCI.GM=1)
	SCI2_SCR_SMCI_CKE_10 = 0x2
	// Setting prohibited(SMR_SMCI.GM=0) / Clock Output(SMR_SMCI.GM=1)
	SCI2_SCR_SMCI_CKE_11 = 0x3

	// TDR: Transmit Data Register
	// Position of TDR field.
	SCI2_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	SCI2_TDR_TDR_Msk = 0xff

	// SSR: Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
	// Position of TDRE field.
	SCI2_SSR_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI2_SSR_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI2_SSR_TDRE = 0x80
	// Transmit data is in TDR register
	SCI2_SSR_TDRE_0 = 0x0
	// No transmit data is in TDR register
	SCI2_SSR_TDRE_1 = 0x1
	// Position of RDRF field.
	SCI2_SSR_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI2_SSR_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI2_SSR_RDRF = 0x40
	// No received data is in RDR register
	SCI2_SSR_RDRF_0 = 0x0
	// Received data is in RDR register
	SCI2_SSR_RDRF_1 = 0x1
	// Position of ORER field.
	SCI2_SSR_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI2_SSR_ORER_Msk = 0x20
	// Bit ORER.
	SCI2_SSR_ORER = 0x20
	// No overrun error occurred
	SCI2_SSR_ORER_0 = 0x0
	// An overrun error has occurred
	SCI2_SSR_ORER_1 = 0x1
	// Position of FER field.
	SCI2_SSR_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI2_SSR_FER_Msk = 0x10
	// Bit FER.
	SCI2_SSR_FER = 0x10
	// No framing error occurred
	SCI2_SSR_FER_0 = 0x0
	// A framing error has occurred
	SCI2_SSR_FER_1 = 0x1
	// Position of PER field.
	SCI2_SSR_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI2_SSR_PER_Msk = 0x8
	// Bit PER.
	SCI2_SSR_PER = 0x8
	// No parity error occurred
	SCI2_SSR_PER_0 = 0x0
	// A parity error has occurred
	SCI2_SSR_PER_1 = 0x1
	// Position of TEND field.
	SCI2_SSR_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI2_SSR_TEND_Msk = 0x4
	// Bit TEND.
	SCI2_SSR_TEND = 0x4
	// A character is being transmitted.
	SCI2_SSR_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI2_SSR_TEND_1 = 0x1
	// Position of MPB field.
	SCI2_SSR_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI2_SSR_MPB_Msk = 0x2
	// Bit MPB.
	SCI2_SSR_MPB = 0x2
	// Data transmission cycles
	SCI2_SSR_MPB_0 = 0x0
	// ID transmission cycles
	SCI2_SSR_MPB_1 = 0x1
	// Position of MPBT field.
	SCI2_SSR_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI2_SSR_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI2_SSR_MPBT = 0x1
	// Data transmission cycles
	SCI2_SSR_MPBT_0 = 0x0
	// ID transmission cycles
	SCI2_SSR_MPBT_1 = 0x1

	// SSR_SMCI: Serial Status Register(SCMR.SMIF = 1)
	// Position of TDRE field.
	SCI2_SSR_SMCI_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI2_SSR_SMCI_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI2_SSR_SMCI_TDRE = 0x80
	// Transmit data is in TDR register
	SCI2_SSR_SMCI_TDRE_0 = 0x0
	// No transmit data is in TDR register
	SCI2_SSR_SMCI_TDRE_1 = 0x1
	// Position of RDRF field.
	SCI2_SSR_SMCI_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI2_SSR_SMCI_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI2_SSR_SMCI_RDRF = 0x40
	// No received data is in RDR register
	SCI2_SSR_SMCI_RDRF_0 = 0x0
	// Received data is in RDR register
	SCI2_SSR_SMCI_RDRF_1 = 0x1
	// Position of ORER field.
	SCI2_SSR_SMCI_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI2_SSR_SMCI_ORER_Msk = 0x20
	// Bit ORER.
	SCI2_SSR_SMCI_ORER = 0x20
	// No overrun error occurred
	SCI2_SSR_SMCI_ORER_0 = 0x0
	// An overrun error has occurred
	SCI2_SSR_SMCI_ORER_1 = 0x1
	// Position of ERS field.
	SCI2_SSR_SMCI_ERS_Pos = 0x4
	// Bit mask of ERS field.
	SCI2_SSR_SMCI_ERS_Msk = 0x10
	// Bit ERS.
	SCI2_SSR_SMCI_ERS = 0x10
	// Low error signal not responded
	SCI2_SSR_SMCI_ERS_0 = 0x0
	// Low error signal responded
	SCI2_SSR_SMCI_ERS_1 = 0x1
	// Position of PER field.
	SCI2_SSR_SMCI_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI2_SSR_SMCI_PER_Msk = 0x8
	// Bit PER.
	SCI2_SSR_SMCI_PER = 0x8
	// No parity error occurred
	SCI2_SSR_SMCI_PER_0 = 0x0
	// A parity error has occurred
	SCI2_SSR_SMCI_PER_1 = 0x1
	// Position of TEND field.
	SCI2_SSR_SMCI_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI2_SSR_SMCI_TEND_Msk = 0x4
	// Bit TEND.
	SCI2_SSR_SMCI_TEND = 0x4
	// A character is being transmitted.
	SCI2_SSR_SMCI_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI2_SSR_SMCI_TEND_1 = 0x1
	// Position of MPB field.
	SCI2_SSR_SMCI_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI2_SSR_SMCI_MPB_Msk = 0x2
	// Bit MPB.
	SCI2_SSR_SMCI_MPB = 0x2
	// Position of MPBT field.
	SCI2_SSR_SMCI_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI2_SSR_SMCI_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI2_SSR_SMCI_MPBT = 0x1

	// RDR: Receive Data Register
	// Position of RDR field.
	SCI2_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	SCI2_RDR_RDR_Msk = 0xff

	// SCMR: Smart Card Mode Register
	// Position of BCP2 field.
	SCI2_SCMR_BCP2_Pos = 0x7
	// Bit mask of BCP2 field.
	SCI2_SCMR_BCP2_Msk = 0x80
	// Bit BCP2.
	SCI2_SCMR_BCP2 = 0x80
	// S=93(SMR.BCP[1:0]=00), 128(SMR.BCP[1:0]=01), 186(SMR.BCP[1:0]=10), 512(SMR.BCP[1:0]=11)
	SCI2_SCMR_BCP2_0 = 0x0
	// S=32(SMR.BCP[1:0]=00), 64(SMR.BCP[1:0]=01), 372(SMR.BCP[1:0]=10), 256(SMR.BCP[1:0]=11)
	SCI2_SCMR_BCP2_1 = 0x1
	// Position of Reserved field.
	SCI2_SCMR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI2_SCMR_Reserved_Msk = 0x60
	// Position of CHR1 field.
	SCI2_SCMR_CHR1_Pos = 0x4
	// Bit mask of CHR1 field.
	SCI2_SCMR_CHR1_Msk = 0x10
	// Bit CHR1.
	SCI2_SCMR_CHR1 = 0x10
	// Transmit/receive in 9-bit data length
	SCI2_SCMR_CHR1_0 = 0x0
	// Transmit/receive in 8-bit data length(SMR.CHR=0) / in 7bit data length(SMR.CHR=1)
	SCI2_SCMR_CHR1_1 = 0x1
	// Position of SDIR field.
	SCI2_SCMR_SDIR_Pos = 0x3
	// Bit mask of SDIR field.
	SCI2_SCMR_SDIR_Msk = 0x8
	// Bit SDIR.
	SCI2_SCMR_SDIR = 0x8
	// Transfer with LSB first
	SCI2_SCMR_SDIR_0 = 0x0
	// Transfer with MSB first
	SCI2_SCMR_SDIR_1 = 0x1
	// Position of SINV field.
	SCI2_SCMR_SINV_Pos = 0x2
	// Bit mask of SINV field.
	SCI2_SCMR_SINV_Msk = 0x4
	// Bit SINV.
	SCI2_SCMR_SINV = 0x4
	// TDR contents are transmitted as they are. Receive data is stored as it is in RDR.
	SCI2_SCMR_SINV_0 = 0x0
	// TDR contents are inverted before being transmitted. Receive data is stored in inverted form in RDR.
	SCI2_SCMR_SINV_1 = 0x1
	// Position of Reserved field.
	SCI2_SCMR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI2_SCMR_Reserved_Msk = 0x2
	// Bit Reserved.
	SCI2_SCMR_Reserved = 0x2
	// Position of SMIF field.
	SCI2_SCMR_SMIF_Pos = 0x0
	// Bit mask of SMIF field.
	SCI2_SCMR_SMIF_Msk = 0x1
	// Bit SMIF.
	SCI2_SCMR_SMIF = 0x1
	// Non-smart card interface mode(Asynchronous mode, clock synchronous mode, simple SPI mode, or simple I2C mode)
	SCI2_SCMR_SMIF_0 = 0x0
	// Smart card interface mode
	SCI2_SCMR_SMIF_1 = 0x1

	// SEMR: Serial Extended Mode Register
	// Position of RXDESEL field.
	SCI2_SEMR_RXDESEL_Pos = 0x7
	// Bit mask of RXDESEL field.
	SCI2_SEMR_RXDESEL_Msk = 0x80
	// Bit RXDESEL.
	SCI2_SEMR_RXDESEL = 0x80
	// The low level on the RXDn pin is detected as the start bit.
	SCI2_SEMR_RXDESEL_0 = 0x0
	// A falling edge on the RXDn pin is detected as the start bit.
	SCI2_SEMR_RXDESEL_1 = 0x1
	// Position of BGDM field.
	SCI2_SEMR_BGDM_Pos = 0x6
	// Bit mask of BGDM field.
	SCI2_SEMR_BGDM_Msk = 0x40
	// Bit BGDM.
	SCI2_SEMR_BGDM = 0x40
	// Baud rate generator outputs the clock with normal frequency.
	SCI2_SEMR_BGDM_0 = 0x0
	// Baud rate generator outputs the clock with doubled frequency.
	SCI2_SEMR_BGDM_1 = 0x1
	// Position of NFEN field.
	SCI2_SEMR_NFEN_Pos = 0x5
	// Bit mask of NFEN field.
	SCI2_SEMR_NFEN_Msk = 0x20
	// Bit NFEN.
	SCI2_SEMR_NFEN = 0x20
	// Noise cancellation function for the RXDn/SSCLn and SSDAn input signal is disabled.
	SCI2_SEMR_NFEN_0 = 0x0
	// Noise cancellation function for the RXDn/SSCLn and SSDAn input signal is enabled.
	SCI2_SEMR_NFEN_1 = 0x1
	// Position of ABCS field.
	SCI2_SEMR_ABCS_Pos = 0x4
	// Bit mask of ABCS field.
	SCI2_SEMR_ABCS_Msk = 0x10
	// Bit ABCS.
	SCI2_SEMR_ABCS = 0x10
	// Selects 16 base clock cycles for 1-bit period.
	SCI2_SEMR_ABCS_0 = 0x0
	// Selects 8 base clock cycles for 1-bit period.
	SCI2_SEMR_ABCS_1 = 0x1
	// Position of ABCSE field.
	SCI2_SEMR_ABCSE_Pos = 0x3
	// Bit mask of ABCSE field.
	SCI2_SEMR_ABCSE_Msk = 0x8
	// Bit ABCSE.
	SCI2_SEMR_ABCSE = 0x8
	// Clock cycles for 1-bit period is decided with combination between BGDM and ABCS in SEMR.
	SCI2_SEMR_ABCSE_0 = 0x0
	// Baud rate is 6 base clock cycles for 1-bit period and the clock of a double frequency is output from the baud rate generator.
	SCI2_SEMR_ABCSE_1 = 0x1
	// Position of BRME field.
	SCI2_SEMR_BRME_Pos = 0x2
	// Bit mask of BRME field.
	SCI2_SEMR_BRME_Msk = 0x4
	// Bit BRME.
	SCI2_SEMR_BRME = 0x4
	// Bit rate modulation function is disabled.
	SCI2_SEMR_BRME_0 = 0x0
	// Bit rate modulation function is enabled.
	SCI2_SEMR_BRME_1 = 0x1
	// Position of Reserved field.
	SCI2_SEMR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SCI2_SEMR_Reserved_Msk = 0x3

	// SNFR: Noise Filter Setting Register
	// Position of Reserved field.
	SCI2_SNFR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI2_SNFR_Reserved_Msk = 0xf8
	// Position of NFCS field.
	SCI2_SNFR_NFCS_Pos = 0x0
	// Bit mask of NFCS field.
	SCI2_SNFR_NFCS_Msk = 0x7
	// The clock signal divided by 1 is used with the noise filter.(In asynchronous mode)
	SCI2_SNFR_NFCS_000 = 0x0
	// The clock signal divided by 1 is used with the noise filter.(In simple I2C mode)
	SCI2_SNFR_NFCS_001 = 0x1
	// The clock signal divided by 2 is used with the noise filter.(In simple I2C mode)
	SCI2_SNFR_NFCS_010 = 0x2
	// The clock signal divided by 4 is used with the noise filter.(In simple I2C mode)
	SCI2_SNFR_NFCS_011 = 0x3
	// The clock signal divided by 8 is used with the noise filter.(In simple I2C mode)
	SCI2_SNFR_NFCS_100 = 0x4

	// SIMR1: I2C Mode Register 1
	// Position of IICDL field.
	SCI2_SIMR1_IICDL_Pos = 0x3
	// Bit mask of IICDL field.
	SCI2_SIMR1_IICDL_Msk = 0xf8
	// No output delay
	SCI2_SIMR1_IICDL_00000 = 0x0
	// Position of Reserved field.
	SCI2_SIMR1_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI2_SIMR1_Reserved_Msk = 0x6
	// Position of IICM field.
	SCI2_SIMR1_IICM_Pos = 0x0
	// Bit mask of IICM field.
	SCI2_SIMR1_IICM_Msk = 0x1
	// Bit IICM.
	SCI2_SIMR1_IICM = 0x1
	// Asynchronous mode, Multi-processor mode, Clock synchronous mode(SCMR.SMIF=0) /Smart card interface mode(SCMR.SMIF=1)
	SCI2_SIMR1_IICM_0 = 0x0
	// Simple I2C mode(SCMR.SMIF=0) / Setting prohibited.(SCMR.SMIF=1)
	SCI2_SIMR1_IICM_1 = 0x1

	// SIMR2: I2C Mode Register 2
	// Position of Reserved field.
	SCI2_SIMR2_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SCI2_SIMR2_Reserved_Msk = 0xc0
	// Position of IICACKT field.
	SCI2_SIMR2_IICACKT_Pos = 0x5
	// Bit mask of IICACKT field.
	SCI2_SIMR2_IICACKT_Msk = 0x20
	// Bit IICACKT.
	SCI2_SIMR2_IICACKT = 0x20
	// ACK transmission
	SCI2_SIMR2_IICACKT_0 = 0x0
	// NACK transmission and reception of ACK/NACK
	SCI2_SIMR2_IICACKT_1 = 0x1
	// Position of Reserved field.
	SCI2_SIMR2_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SCI2_SIMR2_Reserved_Msk = 0x1c
	// Position of IICCSC field.
	SCI2_SIMR2_IICCSC_Pos = 0x1
	// Bit mask of IICCSC field.
	SCI2_SIMR2_IICCSC_Msk = 0x2
	// Bit IICCSC.
	SCI2_SIMR2_IICCSC = 0x2
	// No synchronization with the clock signal
	SCI2_SIMR2_IICCSC_0 = 0x0
	// Synchronization with the clock signal
	SCI2_SIMR2_IICCSC_1 = 0x1
	// Position of IICINTM field.
	SCI2_SIMR2_IICINTM_Pos = 0x0
	// Bit mask of IICINTM field.
	SCI2_SIMR2_IICINTM_Msk = 0x1
	// Bit IICINTM.
	SCI2_SIMR2_IICINTM = 0x1
	// Use ACK/NACK interrupts.
	SCI2_SIMR2_IICINTM_0 = 0x0
	// Use reception and transmission interrupts
	SCI2_SIMR2_IICINTM_1 = 0x1

	// SIMR3: I2C Mode Register 3
	// Position of IICSCLS field.
	SCI2_SIMR3_IICSCLS_Pos = 0x6
	// Bit mask of IICSCLS field.
	SCI2_SIMR3_IICSCLS_Msk = 0xc0
	// Serial clock output
	SCI2_SIMR3_IICSCLS_00 = 0x0
	// Generate a start, restart, or stop condition.
	SCI2_SIMR3_IICSCLS_01 = 0x1
	// Output the low level on the SSCLn pin.
	SCI2_SIMR3_IICSCLS_10 = 0x2
	// Place the SSCLn pin in the high-impedance state.
	SCI2_SIMR3_IICSCLS_11 = 0x3
	// Position of IICSDAS field.
	SCI2_SIMR3_IICSDAS_Pos = 0x4
	// Bit mask of IICSDAS field.
	SCI2_SIMR3_IICSDAS_Msk = 0x30
	// Serial data output
	SCI2_SIMR3_IICSDAS_00 = 0x0
	// Generate a start, restart, or stop condition.
	SCI2_SIMR3_IICSDAS_01 = 0x1
	// Output the low level on the SSDAn pin.
	SCI2_SIMR3_IICSDAS_10 = 0x2
	// Place the SSDAn pin in the high-impedance state.
	SCI2_SIMR3_IICSDAS_11 = 0x3
	// Position of IICSTIF field.
	SCI2_SIMR3_IICSTIF_Pos = 0x3
	// Bit mask of IICSTIF field.
	SCI2_SIMR3_IICSTIF_Msk = 0x8
	// Bit IICSTIF.
	SCI2_SIMR3_IICSTIF = 0x8
	// There are no requests for generating conditions or a condition is being generated.
	SCI2_SIMR3_IICSTIF_0 = 0x0
	// A start, restart, or stop condition is completely generated.
	SCI2_SIMR3_IICSTIF_1 = 0x1
	// Position of IICSTPREQ field.
	SCI2_SIMR3_IICSTPREQ_Pos = 0x2
	// Bit mask of IICSTPREQ field.
	SCI2_SIMR3_IICSTPREQ_Msk = 0x4
	// Bit IICSTPREQ.
	SCI2_SIMR3_IICSTPREQ = 0x4
	// A stop condition is not generated.
	SCI2_SIMR3_IICSTPREQ_0 = 0x0
	// A stop condition is generated.
	SCI2_SIMR3_IICSTPREQ_1 = 0x1
	// Position of IICRSTAREQ field.
	SCI2_SIMR3_IICRSTAREQ_Pos = 0x1
	// Bit mask of IICRSTAREQ field.
	SCI2_SIMR3_IICRSTAREQ_Msk = 0x2
	// Bit IICRSTAREQ.
	SCI2_SIMR3_IICRSTAREQ = 0x2
	// A restart condition is not generated.
	SCI2_SIMR3_IICRSTAREQ_0 = 0x0
	// A restart condition is generated.
	SCI2_SIMR3_IICRSTAREQ_1 = 0x1
	// Position of IICSTAREQ field.
	SCI2_SIMR3_IICSTAREQ_Pos = 0x0
	// Bit mask of IICSTAREQ field.
	SCI2_SIMR3_IICSTAREQ_Msk = 0x1
	// Bit IICSTAREQ.
	SCI2_SIMR3_IICSTAREQ = 0x1
	// A start condition is not generated.
	SCI2_SIMR3_IICSTAREQ_0 = 0x0
	// A start condition is generated.
	SCI2_SIMR3_IICSTAREQ_1 = 0x1

	// SISR: I2C Status Register
	// Position of Reserved field.
	SCI2_SISR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SCI2_SISR_Reserved_Msk = 0xc0
	// Position of Reserved field.
	SCI2_SISR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI2_SISR_Reserved_Msk = 0x20
	// Bit Reserved.
	SCI2_SISR_Reserved = 0x20
	// Position of Reserved field.
	SCI2_SISR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SCI2_SISR_Reserved_Msk = 0x10
	// Bit Reserved.
	SCI2_SISR_Reserved = 0x10
	// Position of Reserved field.
	SCI2_SISR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI2_SISR_Reserved_Msk = 0x8
	// Bit Reserved.
	SCI2_SISR_Reserved = 0x8
	// Position of Reserved field.
	SCI2_SISR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SCI2_SISR_Reserved_Msk = 0x4
	// Bit Reserved.
	SCI2_SISR_Reserved = 0x4
	// Position of Reserved field.
	SCI2_SISR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI2_SISR_Reserved_Msk = 0x2
	// Bit Reserved.
	SCI2_SISR_Reserved = 0x2
	// Position of IICACKR field.
	SCI2_SISR_IICACKR_Pos = 0x0
	// Bit mask of IICACKR field.
	SCI2_SISR_IICACKR_Msk = 0x1
	// Bit IICACKR.
	SCI2_SISR_IICACKR = 0x1
	// ACK received
	SCI2_SISR_IICACKR_0 = 0x0
	// NACK received
	SCI2_SISR_IICACKR_1 = 0x1

	// SPMR: SPI Mode Register
	// Position of CKPH field.
	SCI2_SPMR_CKPH_Pos = 0x7
	// Bit mask of CKPH field.
	SCI2_SPMR_CKPH_Msk = 0x80
	// Bit CKPH.
	SCI2_SPMR_CKPH = 0x80
	// Clock is not delayed.
	SCI2_SPMR_CKPH_0 = 0x0
	// Clock is delayed.
	SCI2_SPMR_CKPH_1 = 0x1
	// Position of CKPOL field.
	SCI2_SPMR_CKPOL_Pos = 0x6
	// Bit mask of CKPOL field.
	SCI2_SPMR_CKPOL_Msk = 0x40
	// Bit CKPOL.
	SCI2_SPMR_CKPOL = 0x40
	// Clock polarity is not inverted.
	SCI2_SPMR_CKPOL_0 = 0x0
	// Clock polarity is inverted
	SCI2_SPMR_CKPOL_1 = 0x1
	// Position of Reserved field.
	SCI2_SPMR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI2_SPMR_Reserved_Msk = 0x20
	// Bit Reserved.
	SCI2_SPMR_Reserved = 0x20
	// Position of MFF field.
	SCI2_SPMR_MFF_Pos = 0x4
	// Bit mask of MFF field.
	SCI2_SPMR_MFF_Msk = 0x10
	// Bit MFF.
	SCI2_SPMR_MFF = 0x10
	// No mode fault error
	SCI2_SPMR_MFF_0 = 0x0
	// Mode fault error
	SCI2_SPMR_MFF_1 = 0x1
	// Position of Reserved field.
	SCI2_SPMR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI2_SPMR_Reserved_Msk = 0x8
	// Bit Reserved.
	SCI2_SPMR_Reserved = 0x8
	// Position of MSS field.
	SCI2_SPMR_MSS_Pos = 0x2
	// Bit mask of MSS field.
	SCI2_SPMR_MSS_Msk = 0x4
	// Bit MSS.
	SCI2_SPMR_MSS = 0x4
	// Transmission is through the TXDn pin and reception is through the RXDn pin (master mode).
	SCI2_SPMR_MSS_0 = 0x0
	// Reception is through the TXDn pin and transmission is through the RXDn pin (slave mode).
	SCI2_SPMR_MSS_1 = 0x1
	// Position of CTSE field.
	SCI2_SPMR_CTSE_Pos = 0x1
	// Bit mask of CTSE field.
	SCI2_SPMR_CTSE_Msk = 0x2
	// Bit CTSE.
	SCI2_SPMR_CTSE = 0x2
	// CTS function is disabled (RTS output function is enabled).
	SCI2_SPMR_CTSE_0 = 0x0
	// CTS function is enabled.
	SCI2_SPMR_CTSE_1 = 0x1
	// Position of SSE field.
	SCI2_SPMR_SSE_Pos = 0x0
	// Bit mask of SSE field.
	SCI2_SPMR_SSE_Msk = 0x1
	// Bit SSE.
	SCI2_SPMR_SSE = 0x1
	// SSn pin function is disabled.
	SCI2_SPMR_SSE_0 = 0x0
	// SSn pin function is enabled.
	SCI2_SPMR_SSE_1 = 0x1

	// TDRHL: Transmit 9-bit Data Register
	// Position of TDRHL field.
	SCI2_TDRHL_TDRHL_Pos = 0x0
	// Bit mask of TDRHL field.
	SCI2_TDRHL_TDRHL_Msk = 0xffff

	// RDRHL: Receive 9-bit Data Register
	// Position of RDRHL field.
	SCI2_RDRHL_RDRHL_Pos = 0x0
	// Bit mask of RDRHL field.
	SCI2_RDRHL_RDRHL_Msk = 0xffff

	// MDDR: Modulation Duty Register
	// Position of MDDR field.
	SCI2_MDDR_MDDR_Pos = 0x0
	// Bit mask of MDDR field.
	SCI2_MDDR_MDDR_Msk = 0xff

	// DCCR: Data Compare Match Control Register
	// Position of DCME field.
	SCI2_DCCR_DCME_Pos = 0x7
	// Bit mask of DCME field.
	SCI2_DCCR_DCME_Msk = 0x80
	// Bit DCME.
	SCI2_DCCR_DCME = 0x80
	// Address match function is disabled.
	SCI2_DCCR_DCME_0 = 0x0
	// Address match function is enabled
	SCI2_DCCR_DCME_1 = 0x1
	// Position of IDSEL field.
	SCI2_DCCR_IDSEL_Pos = 0x6
	// Bit mask of IDSEL field.
	SCI2_DCCR_IDSEL_Msk = 0x40
	// Bit IDSEL.
	SCI2_DCCR_IDSEL = 0x40
	// Always compare data regardless of the value of the MPB bit.
	SCI2_DCCR_IDSEL_0 = 0x0
	// Compare data when the MPB bit is 1 (ID frame) only.
	SCI2_DCCR_IDSEL_1 = 0x1
	// Position of Reserved field.
	SCI2_DCCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI2_DCCR_Reserved_Msk = 0x20
	// Bit Reserved.
	SCI2_DCCR_Reserved = 0x20
	// Position of DFER field.
	SCI2_DCCR_DFER_Pos = 0x4
	// Bit mask of DFER field.
	SCI2_DCCR_DFER_Msk = 0x10
	// Bit DFER.
	SCI2_DCCR_DFER = 0x10
	// No framing error occurred
	SCI2_DCCR_DFER_0 = 0x0
	// A framing error has occurred
	SCI2_DCCR_DFER_1 = 0x1
	// Position of DPER field.
	SCI2_DCCR_DPER_Pos = 0x3
	// Bit mask of DPER field.
	SCI2_DCCR_DPER_Msk = 0x8
	// Bit DPER.
	SCI2_DCCR_DPER = 0x8
	// No parity error occurred
	SCI2_DCCR_DPER_0 = 0x0
	// A parity error has occurred
	SCI2_DCCR_DPER_1 = 0x1
	// Position of Reserved field.
	SCI2_DCCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI2_DCCR_Reserved_Msk = 0x6
	// Position of DCMF field.
	SCI2_DCCR_DCMF_Pos = 0x0
	// Bit mask of DCMF field.
	SCI2_DCCR_DCMF_Msk = 0x1
	// Bit DCMF.
	SCI2_DCCR_DCMF = 0x1
	// No matched
	SCI2_DCCR_DCMF_0 = 0x0
	// Matched
	SCI2_DCCR_DCMF_1 = 0x1

	// CDR: Compare Match Data Register
	// Position of Reserved field.
	SCI2_CDR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	SCI2_CDR_Reserved_Msk = 0xfe00
	// Position of CMPD field.
	SCI2_CDR_CMPD_Pos = 0x0
	// Bit mask of CMPD field.
	SCI2_CDR_CMPD_Msk = 0x1ff

	// SPTR: Serial Port Register
	// Position of Reserved field.
	SCI2_SPTR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI2_SPTR_Reserved_Msk = 0xf8
	// Position of SPB2IO field.
	SCI2_SPTR_SPB2IO_Pos = 0x2
	// Bit mask of SPB2IO field.
	SCI2_SPTR_SPB2IO_Msk = 0x4
	// Bit SPB2IO.
	SCI2_SPTR_SPB2IO = 0x4
	// The value of SPB2DT bit is not output in TXD pin.
	SCI2_SPTR_SPB2IO_0 = 0x0
	// The value of SPB2DT bit is output in TXD pin.
	SCI2_SPTR_SPB2IO_1 = 0x1
	// Position of SPB2DT field.
	SCI2_SPTR_SPB2DT_Pos = 0x1
	// Bit mask of SPB2DT field.
	SCI2_SPTR_SPB2DT_Msk = 0x2
	// Bit SPB2DT.
	SCI2_SPTR_SPB2DT = 0x2
	// Low level is output on TXD pin
	SCI2_SPTR_SPB2DT_0 = 0x0
	// High level is output on TXD pin
	SCI2_SPTR_SPB2DT_1 = 0x1
	// Position of RXDMON field.
	SCI2_SPTR_RXDMON_Pos = 0x0
	// Bit mask of RXDMON field.
	SCI2_SPTR_RXDMON_Msk = 0x1
	// Bit RXDMON.
	SCI2_SPTR_RXDMON = 0x1
	// RXD pin is low.
	SCI2_SPTR_RXDMON_0 = 0x0
	// RXD pin is high.
	SCI2_SPTR_RXDMON_1 = 0x1
)

// Constants for IIC0: Inter-Integrated Circuit 0
const (
	// ICCR1: I2C Bus Control Register 1
	// Position of ICE field.
	IIC0_ICCR1_ICE_Pos = 0x7
	// Bit mask of ICE field.
	IIC0_ICCR1_ICE_Msk = 0x80
	// Bit ICE.
	IIC0_ICCR1_ICE = 0x80
	// Disable (SCLn and SDAn pins in inactive state)
	IIC0_ICCR1_ICE_0 = 0x0
	// Enable (SCLn and SDAn pins in active state)
	IIC0_ICCR1_ICE_1 = 0x1
	// Position of IICRST field.
	IIC0_ICCR1_IICRST_Pos = 0x6
	// Bit mask of IICRST field.
	IIC0_ICCR1_IICRST_Msk = 0x40
	// Bit IICRST.
	IIC0_ICCR1_IICRST = 0x40
	// Releases the RIIC reset or internal reset.
	IIC0_ICCR1_IICRST_0 = 0x0
	// Initiates the RIIC reset or internal reset.
	IIC0_ICCR1_IICRST_1 = 0x1
	// Position of CLO field.
	IIC0_ICCR1_CLO_Pos = 0x5
	// Bit mask of CLO field.
	IIC0_ICCR1_CLO_Msk = 0x20
	// Bit CLO.
	IIC0_ICCR1_CLO = 0x20
	// Does not output an extra SCL clock cycle.
	IIC0_ICCR1_CLO_0 = 0x0
	// Outputs an extra SCL clock cycle.
	IIC0_ICCR1_CLO_1 = 0x1
	// Position of SOWP field.
	IIC0_ICCR1_SOWP_Pos = 0x4
	// Bit mask of SOWP field.
	IIC0_ICCR1_SOWP_Msk = 0x10
	// Bit SOWP.
	IIC0_ICCR1_SOWP = 0x10
	// Bits SCLO and SDAO can be written
	IIC0_ICCR1_SOWP_0 = 0x0
	// Bits SCLO and SDAO are protected.
	IIC0_ICCR1_SOWP_1 = 0x1
	// Position of SCLO field.
	IIC0_ICCR1_SCLO_Pos = 0x3
	// Bit mask of SCLO field.
	IIC0_ICCR1_SCLO_Msk = 0x8
	// Bit SCLO.
	IIC0_ICCR1_SCLO = 0x8
	// (Read)The RIIC has driven the SCLn pin low. / (Write)The RIIC drives the SCLn pin low.
	IIC0_ICCR1_SCLO_0 = 0x0
	// (Read)The RIIC has released the SCLn pin. / (Write)The RIIC releases the SCLn pin.
	IIC0_ICCR1_SCLO_1 = 0x1
	// Position of SDAO field.
	IIC0_ICCR1_SDAO_Pos = 0x2
	// Bit mask of SDAO field.
	IIC0_ICCR1_SDAO_Msk = 0x4
	// Bit SDAO.
	IIC0_ICCR1_SDAO = 0x4
	// (Read)The RIIC has driven the SDAn pin low. / (Write)The RIIC drives the SDAn pin low.
	IIC0_ICCR1_SDAO_0 = 0x0
	// (Read)The RIIC has released the SDAn pin./ (Write)The RIIC releases the SDAn pin.
	IIC0_ICCR1_SDAO_1 = 0x1
	// Position of SCLI field.
	IIC0_ICCR1_SCLI_Pos = 0x1
	// Bit mask of SCLI field.
	IIC0_ICCR1_SCLI_Msk = 0x2
	// Bit SCLI.
	IIC0_ICCR1_SCLI = 0x2
	// SCLn line is low.
	IIC0_ICCR1_SCLI_0 = 0x0
	// SCLn line is high.
	IIC0_ICCR1_SCLI_1 = 0x1
	// Position of SDAI field.
	IIC0_ICCR1_SDAI_Pos = 0x0
	// Bit mask of SDAI field.
	IIC0_ICCR1_SDAI_Msk = 0x1
	// Bit SDAI.
	IIC0_ICCR1_SDAI = 0x1
	// SDAn line is low.
	IIC0_ICCR1_SDAI_0 = 0x0
	// SDAn line is high.
	IIC0_ICCR1_SDAI_1 = 0x1

	// ICCR2: I2C Bus Control Register 2
	// Position of BBSY field.
	IIC0_ICCR2_BBSY_Pos = 0x7
	// Bit mask of BBSY field.
	IIC0_ICCR2_BBSY_Msk = 0x80
	// Bit BBSY.
	IIC0_ICCR2_BBSY = 0x80
	// The I2C bus is released (bus free state).
	IIC0_ICCR2_BBSY_0 = 0x0
	// The I2C bus is occupied (bus busy state).
	IIC0_ICCR2_BBSY_1 = 0x1
	// Position of MST field.
	IIC0_ICCR2_MST_Pos = 0x6
	// Bit mask of MST field.
	IIC0_ICCR2_MST_Msk = 0x40
	// Bit MST.
	IIC0_ICCR2_MST = 0x40
	// Slave mode
	IIC0_ICCR2_MST_0 = 0x0
	// Master mode
	IIC0_ICCR2_MST_1 = 0x1
	// Position of TRS field.
	IIC0_ICCR2_TRS_Pos = 0x5
	// Bit mask of TRS field.
	IIC0_ICCR2_TRS_Msk = 0x20
	// Bit TRS.
	IIC0_ICCR2_TRS = 0x20
	// Receive mode
	IIC0_ICCR2_TRS_0 = 0x0
	// Transmit mode
	IIC0_ICCR2_TRS_1 = 0x1
	// Position of Reserved field.
	IIC0_ICCR2_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	IIC0_ICCR2_Reserved_Msk = 0x10
	// Bit Reserved.
	IIC0_ICCR2_Reserved = 0x10
	// Position of SP field.
	IIC0_ICCR2_SP_Pos = 0x3
	// Bit mask of SP field.
	IIC0_ICCR2_SP_Msk = 0x8
	// Bit SP.
	IIC0_ICCR2_SP = 0x8
	// Does not request to issue a stop condition.
	IIC0_ICCR2_SP_0 = 0x0
	// Requests to issue a stop condition.
	IIC0_ICCR2_SP_1 = 0x1
	// Position of RS field.
	IIC0_ICCR2_RS_Pos = 0x2
	// Bit mask of RS field.
	IIC0_ICCR2_RS_Msk = 0x4
	// Bit RS.
	IIC0_ICCR2_RS = 0x4
	// Does not request to issue a restart condition.
	IIC0_ICCR2_RS_0 = 0x0
	// Requests to issue a restart condition.
	IIC0_ICCR2_RS_1 = 0x1
	// Position of ST field.
	IIC0_ICCR2_ST_Pos = 0x1
	// Bit mask of ST field.
	IIC0_ICCR2_ST_Msk = 0x2
	// Bit ST.
	IIC0_ICCR2_ST = 0x2
	// Does not request to issue a start condition.
	IIC0_ICCR2_ST_0 = 0x0
	// Requests to issue a start condition.
	IIC0_ICCR2_ST_1 = 0x1
	// Position of Reserved field.
	IIC0_ICCR2_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	IIC0_ICCR2_Reserved_Msk = 0x1
	// Bit Reserved.
	IIC0_ICCR2_Reserved = 0x1

	// ICMR1: I2C Bus Mode Register 1
	// Position of MTWP field.
	IIC0_ICMR1_MTWP_Pos = 0x7
	// Bit mask of MTWP field.
	IIC0_ICMR1_MTWP_Msk = 0x80
	// Bit MTWP.
	IIC0_ICMR1_MTWP = 0x80
	// Disables writing to the MST and TRS bits in ICCR2.
	IIC0_ICMR1_MTWP_0 = 0x0
	// Enables writing to the MST and TRS bits in ICCR2.
	IIC0_ICMR1_MTWP_1 = 0x1
	// Position of CKS field.
	IIC0_ICMR1_CKS_Pos = 0x4
	// Bit mask of CKS field.
	IIC0_ICMR1_CKS_Msk = 0x70
	// PCLKB/1 clock
	IIC0_ICMR1_CKS_000 = 0x0
	// PCLKB/2 clock
	IIC0_ICMR1_CKS_001 = 0x1
	// PCLKB/4 clock
	IIC0_ICMR1_CKS_010 = 0x2
	// PCLKB/8 clock
	IIC0_ICMR1_CKS_011 = 0x3
	// PCLKB/16 clock
	IIC0_ICMR1_CKS_100 = 0x4
	// PCLKB/32 clock
	IIC0_ICMR1_CKS_101 = 0x5
	// PCLKB/64 clock
	IIC0_ICMR1_CKS_110 = 0x6
	// PCLKB/128 clock
	IIC0_ICMR1_CKS_111 = 0x7
	// Position of BCWP field.
	IIC0_ICMR1_BCWP_Pos = 0x3
	// Bit mask of BCWP field.
	IIC0_ICMR1_BCWP_Msk = 0x8
	// Bit BCWP.
	IIC0_ICMR1_BCWP = 0x8
	// Enables a value to be written in the BC[2:0] bits.
	IIC0_ICMR1_BCWP_0 = 0x0
	// Disables a value to be written in the BC[2:0] bits.
	IIC0_ICMR1_BCWP_1 = 0x1
	// Position of BC field.
	IIC0_ICMR1_BC_Pos = 0x0
	// Bit mask of BC field.
	IIC0_ICMR1_BC_Msk = 0x7
	// 9 bits
	IIC0_ICMR1_BC_000 = 0x0
	// 2 bits
	IIC0_ICMR1_BC_001 = 0x1
	// 3 bits
	IIC0_ICMR1_BC_010 = 0x2
	// 4 bits
	IIC0_ICMR1_BC_011 = 0x3
	// 5 bits
	IIC0_ICMR1_BC_100 = 0x4
	// 6 bits
	IIC0_ICMR1_BC_101 = 0x5
	// 7 bits
	IIC0_ICMR1_BC_110 = 0x6
	// 8 bits
	IIC0_ICMR1_BC_111 = 0x7

	// ICMR2: I2C Bus Mode Register 2
	// Position of DLCS field.
	IIC0_ICMR2_DLCS_Pos = 0x7
	// Bit mask of DLCS field.
	IIC0_ICMR2_DLCS_Msk = 0x80
	// Bit DLCS.
	IIC0_ICMR2_DLCS = 0x80
	// The internal reference clock (fIIC) is selected as the clock source of the SDA output delay counter.
	IIC0_ICMR2_DLCS_0 = 0x0
	// The internal reference clock divided by 2 (fIIC/2) is selected as the clock source of the SDA output delay counter.
	IIC0_ICMR2_DLCS_1 = 0x1
	// Position of SDDL field.
	IIC0_ICMR2_SDDL_Pos = 0x4
	// Bit mask of SDDL field.
	IIC0_ICMR2_SDDL_Msk = 0x70
	// No output delay
	IIC0_ICMR2_SDDL_000 = 0x0
	// 1 fIIC cycle (ICMR2.DLCS=0) / 1 or 2 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_001 = 0x1
	// 2 fIIC cycles (ICMR2.DLCS=0) / 3 or 4 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_010 = 0x2
	// 3 fIIC cycles (ICMR2.DLCS=0) / 5 or 6 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_011 = 0x3
	// 4 fIIC cycles (ICMR2.DLCS=0) / 7 or 8 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_100 = 0x4
	// 5 fIIC cycles (ICMR2.DLCS=0) / 9 or 10 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_101 = 0x5
	// 6 fIIC cycles (ICMR2.DLCS=0) / 11 or 12 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_110 = 0x6
	// 7 fIIC cycles (ICMR2.DLCS=0) / 13 or 14 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_111 = 0x7
	// Position of Reserved field.
	IIC0_ICMR2_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	IIC0_ICMR2_Reserved_Msk = 0x8
	// Bit Reserved.
	IIC0_ICMR2_Reserved = 0x8
	// Position of TMOH field.
	IIC0_ICMR2_TMOH_Pos = 0x2
	// Bit mask of TMOH field.
	IIC0_ICMR2_TMOH_Msk = 0x4
	// Bit TMOH.
	IIC0_ICMR2_TMOH = 0x4
	// Count is disabled while the SCLn line is at a high level.
	IIC0_ICMR2_TMOH_0 = 0x0
	// Count is enabled while the SCLn line is at a high level.
	IIC0_ICMR2_TMOH_1 = 0x1
	// Position of TMOL field.
	IIC0_ICMR2_TMOL_Pos = 0x1
	// Bit mask of TMOL field.
	IIC0_ICMR2_TMOL_Msk = 0x2
	// Bit TMOL.
	IIC0_ICMR2_TMOL = 0x2
	// Count is disabled while the SCLn line is at a low level.
	IIC0_ICMR2_TMOL_0 = 0x0
	// Count is enabled while the SCLn line is at a low level.
	IIC0_ICMR2_TMOL_1 = 0x1
	// Position of TMOS field.
	IIC0_ICMR2_TMOS_Pos = 0x0
	// Bit mask of TMOS field.
	IIC0_ICMR2_TMOS_Msk = 0x1
	// Bit TMOS.
	IIC0_ICMR2_TMOS = 0x1
	// Long mode is selected.
	IIC0_ICMR2_TMOS_0 = 0x0
	// Short mode is selected.
	IIC0_ICMR2_TMOS_1 = 0x1

	// ICMR3: I2C Bus Mode Register 3
	// Position of SMBS field.
	IIC0_ICMR3_SMBS_Pos = 0x7
	// Bit mask of SMBS field.
	IIC0_ICMR3_SMBS_Msk = 0x80
	// Bit SMBS.
	IIC0_ICMR3_SMBS = 0x80
	// The I2C bus is selected.
	IIC0_ICMR3_SMBS_0 = 0x0
	// The SMBus is selected.
	IIC0_ICMR3_SMBS_1 = 0x1
	// Position of WAIT field.
	IIC0_ICMR3_WAIT_Pos = 0x6
	// Bit mask of WAIT field.
	IIC0_ICMR3_WAIT_Msk = 0x40
	// Bit WAIT.
	IIC0_ICMR3_WAIT = 0x40
	// No WAIT (The period between ninth clock cycle and first clock cycle is not held low.)
	IIC0_ICMR3_WAIT_0 = 0x0
	// WAIT (The period between ninth clock cycle and first clock cycle is held low.)
	IIC0_ICMR3_WAIT_1 = 0x1
	// Position of RDRFS field.
	IIC0_ICMR3_RDRFS_Pos = 0x5
	// Bit mask of RDRFS field.
	IIC0_ICMR3_RDRFS_Msk = 0x20
	// Bit RDRFS.
	IIC0_ICMR3_RDRFS = 0x20
	// The RDRF flag is set at the rising edge of the ninth SCL clock cycle. (The SCLn line is not held low at the falling edge of the eighth clock cycle.)
	IIC0_ICMR3_RDRFS_0 = 0x0
	// The RDRF flag is set at the rising edge of the eighth SCL clock cycle. (The SCLn line is held low at the falling edge of the eighth clock cycle.)
	IIC0_ICMR3_RDRFS_1 = 0x1
	// Position of ACKWP field.
	IIC0_ICMR3_ACKWP_Pos = 0x4
	// Bit mask of ACKWP field.
	IIC0_ICMR3_ACKWP_Msk = 0x10
	// Bit ACKWP.
	IIC0_ICMR3_ACKWP = 0x10
	// Modification of the ACKBT bit is disabled.
	IIC0_ICMR3_ACKWP_0 = 0x0
	// Modification of the ACKBT bit is enabled.
	IIC0_ICMR3_ACKWP_1 = 0x1
	// Position of ACKBT field.
	IIC0_ICMR3_ACKBT_Pos = 0x3
	// Bit mask of ACKBT field.
	IIC0_ICMR3_ACKBT_Msk = 0x8
	// Bit ACKBT.
	IIC0_ICMR3_ACKBT = 0x8
	// A 0 is sent as the acknowledge bit (ACK transmission).
	IIC0_ICMR3_ACKBT_0 = 0x0
	// A 1 is sent as the acknowledge bit (NACK transmission).
	IIC0_ICMR3_ACKBT_1 = 0x1
	// Position of ACKBR field.
	IIC0_ICMR3_ACKBR_Pos = 0x2
	// Bit mask of ACKBR field.
	IIC0_ICMR3_ACKBR_Msk = 0x4
	// Bit ACKBR.
	IIC0_ICMR3_ACKBR = 0x4
	// A 0 is received as the acknowledge bit (ACK reception).
	IIC0_ICMR3_ACKBR_0 = 0x0
	// A 1 is received as the acknowledge bit (NACK reception).
	IIC0_ICMR3_ACKBR_1 = 0x1
	// Position of NF field.
	IIC0_ICMR3_NF_Pos = 0x0
	// Bit mask of NF field.
	IIC0_ICMR3_NF_Msk = 0x3
	// Noise of up to one fIIC cycle is filtered out (single-stage filter).
	IIC0_ICMR3_NF_00 = 0x0
	// Noise of up to two fIIC cycles is filtered out (2-stage filter).
	IIC0_ICMR3_NF_01 = 0x1
	// Noise of up to three fIIC cycles is filtered out (3-stage filter).
	IIC0_ICMR3_NF_10 = 0x2
	// Noise of up to four fIIC cycles is filtered out (4-stage filter)
	IIC0_ICMR3_NF_11 = 0x3

	// ICFER: I2C Bus Function Enable Register
	// Position of Reserved field.
	IIC0_ICFER_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	IIC0_ICFER_Reserved_Msk = 0x80
	// Bit Reserved.
	IIC0_ICFER_Reserved = 0x80
	// Position of SCLE field.
	IIC0_ICFER_SCLE_Pos = 0x6
	// Bit mask of SCLE field.
	IIC0_ICFER_SCLE_Msk = 0x40
	// Bit SCLE.
	IIC0_ICFER_SCLE = 0x40
	// No SCL synchronous circuit is used.
	IIC0_ICFER_SCLE_0 = 0x0
	// An SCL synchronous circuit is used.
	IIC0_ICFER_SCLE_1 = 0x1
	// Position of NFE field.
	IIC0_ICFER_NFE_Pos = 0x5
	// Bit mask of NFE field.
	IIC0_ICFER_NFE_Msk = 0x20
	// Bit NFE.
	IIC0_ICFER_NFE = 0x20
	// No digital noise filter circuit is used.
	IIC0_ICFER_NFE_0 = 0x0
	// A digital noise filter circuit is used.
	IIC0_ICFER_NFE_1 = 0x1
	// Position of NACKE field.
	IIC0_ICFER_NACKE_Pos = 0x4
	// Bit mask of NACKE field.
	IIC0_ICFER_NACKE_Msk = 0x10
	// Bit NACKE.
	IIC0_ICFER_NACKE = 0x10
	// Transfer operation is not suspended during NACK reception (transfer suspension disabled).
	IIC0_ICFER_NACKE_0 = 0x0
	// Transfer operation is suspended during NACK reception (transfer suspension enabled).
	IIC0_ICFER_NACKE_1 = 0x1
	// Position of SALE field.
	IIC0_ICFER_SALE_Pos = 0x3
	// Bit mask of SALE field.
	IIC0_ICFER_SALE_Msk = 0x8
	// Bit SALE.
	IIC0_ICFER_SALE = 0x8
	// Slave arbitration-lost detection is disabled.
	IIC0_ICFER_SALE_0 = 0x0
	// Slave arbitration-lost detection is enabled.
	IIC0_ICFER_SALE_1 = 0x1
	// Position of NALE field.
	IIC0_ICFER_NALE_Pos = 0x2
	// Bit mask of NALE field.
	IIC0_ICFER_NALE_Msk = 0x4
	// Bit NALE.
	IIC0_ICFER_NALE = 0x4
	// NACK transmission arbitration-lost detection is disabled.
	IIC0_ICFER_NALE_0 = 0x0
	// NACK transmission arbitration-lost detection is enabled.
	IIC0_ICFER_NALE_1 = 0x1
	// Position of MALE field.
	IIC0_ICFER_MALE_Pos = 0x1
	// Bit mask of MALE field.
	IIC0_ICFER_MALE_Msk = 0x2
	// Bit MALE.
	IIC0_ICFER_MALE = 0x2
	// Master arbitration-lost detection is disabled.
	IIC0_ICFER_MALE_0 = 0x0
	// Master arbitration-lost detection is enabled.
	IIC0_ICFER_MALE_1 = 0x1
	// Position of TMOE field.
	IIC0_ICFER_TMOE_Pos = 0x0
	// Bit mask of TMOE field.
	IIC0_ICFER_TMOE_Msk = 0x1
	// Bit TMOE.
	IIC0_ICFER_TMOE = 0x1
	// The timeout function is disabled.
	IIC0_ICFER_TMOE_0 = 0x0
	// The timeout function is enabled.
	IIC0_ICFER_TMOE_1 = 0x1

	// ICSER: I2C Bus Status Enable Register
	// Position of HOAE field.
	IIC0_ICSER_HOAE_Pos = 0x7
	// Bit mask of HOAE field.
	IIC0_ICSER_HOAE_Msk = 0x80
	// Bit HOAE.
	IIC0_ICSER_HOAE = 0x80
	// Host address detection is disabled.
	IIC0_ICSER_HOAE_0 = 0x0
	// Host address detection is enabled.
	IIC0_ICSER_HOAE_1 = 0x1
	// Position of Reserved field.
	IIC0_ICSER_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	IIC0_ICSER_Reserved_Msk = 0x40
	// Bit Reserved.
	IIC0_ICSER_Reserved = 0x40
	// Position of DIDE field.
	IIC0_ICSER_DIDE_Pos = 0x5
	// Bit mask of DIDE field.
	IIC0_ICSER_DIDE_Msk = 0x20
	// Bit DIDE.
	IIC0_ICSER_DIDE = 0x20
	// Device-ID address detection is disabled.
	IIC0_ICSER_DIDE_0 = 0x0
	// Device-ID address detection is enabled.
	IIC0_ICSER_DIDE_1 = 0x1
	// Position of Reserved field.
	IIC0_ICSER_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	IIC0_ICSER_Reserved_Msk = 0x10
	// Bit Reserved.
	IIC0_ICSER_Reserved = 0x10
	// Position of GCAE field.
	IIC0_ICSER_GCAE_Pos = 0x3
	// Bit mask of GCAE field.
	IIC0_ICSER_GCAE_Msk = 0x8
	// Bit GCAE.
	IIC0_ICSER_GCAE = 0x8
	// General call address detection is disabled.
	IIC0_ICSER_GCAE_0 = 0x0
	// General call address detection is enabled.
	IIC0_ICSER_GCAE_1 = 0x1
	// Position of SAR2E field.
	IIC0_ICSER_SAR2E_Pos = 0x2
	// Bit mask of SAR2E field.
	IIC0_ICSER_SAR2E_Msk = 0x4
	// Bit SAR2E.
	IIC0_ICSER_SAR2E = 0x4
	// Slave address in SARL2 and SARU2 is disabled.
	IIC0_ICSER_SAR2E_0 = 0x0
	// Slave address in SARL2 and SARU2 is enabled
	IIC0_ICSER_SAR2E_1 = 0x1
	// Position of SAR1E field.
	IIC0_ICSER_SAR1E_Pos = 0x1
	// Bit mask of SAR1E field.
	IIC0_ICSER_SAR1E_Msk = 0x2
	// Bit SAR1E.
	IIC0_ICSER_SAR1E = 0x2
	// Slave address in SARL1 and SARU1 is disabled.
	IIC0_ICSER_SAR1E_0 = 0x0
	// Slave address in SARL1 and SARU1 is enabled.
	IIC0_ICSER_SAR1E_1 = 0x1
	// Position of SAR0E field.
	IIC0_ICSER_SAR0E_Pos = 0x0
	// Bit mask of SAR0E field.
	IIC0_ICSER_SAR0E_Msk = 0x1
	// Bit SAR0E.
	IIC0_ICSER_SAR0E = 0x1
	// Slave address in SARL0 and SARU0 is disabled.
	IIC0_ICSER_SAR0E_0 = 0x0
	// Slave address in SARL0 and SARU0 is enabled.
	IIC0_ICSER_SAR0E_1 = 0x1

	// ICIER: I2C Bus Interrupt Enable Register
	// Position of TIE field.
	IIC0_ICIER_TIE_Pos = 0x7
	// Bit mask of TIE field.
	IIC0_ICIER_TIE_Msk = 0x80
	// Bit TIE.
	IIC0_ICIER_TIE = 0x80
	// Transmit data empty interrupt request (IIC_TXI) is disabled.
	IIC0_ICIER_TIE_0 = 0x0
	// Transmit data empty interrupt request (IIC_TXI) is enabled.
	IIC0_ICIER_TIE_1 = 0x1
	// Position of TEIE field.
	IIC0_ICIER_TEIE_Pos = 0x6
	// Bit mask of TEIE field.
	IIC0_ICIER_TEIE_Msk = 0x40
	// Bit TEIE.
	IIC0_ICIER_TEIE = 0x40
	// Transmit end interrupt request (IIC_TEI) is disabled.
	IIC0_ICIER_TEIE_0 = 0x0
	// Transmit end interrupt request (IIC_TEI) is enabled.
	IIC0_ICIER_TEIE_1 = 0x1
	// Position of RIE field.
	IIC0_ICIER_RIE_Pos = 0x5
	// Bit mask of RIE field.
	IIC0_ICIER_RIE_Msk = 0x20
	// Bit RIE.
	IIC0_ICIER_RIE = 0x20
	// Receive data full interrupt request (IIC_RXI) is disabled.
	IIC0_ICIER_RIE_0 = 0x0
	// Receive data full interrupt request (IIC_RXI) is enabled.
	IIC0_ICIER_RIE_1 = 0x1
	// Position of NAKIE field.
	IIC0_ICIER_NAKIE_Pos = 0x4
	// Bit mask of NAKIE field.
	IIC0_ICIER_NAKIE_Msk = 0x10
	// Bit NAKIE.
	IIC0_ICIER_NAKIE = 0x10
	// NACK reception interrupt request (NAKI) is disabled.
	IIC0_ICIER_NAKIE_0 = 0x0
	// NACK reception interrupt request (NAKI) is enabled.
	IIC0_ICIER_NAKIE_1 = 0x1
	// Position of SPIE field.
	IIC0_ICIER_SPIE_Pos = 0x3
	// Bit mask of SPIE field.
	IIC0_ICIER_SPIE_Msk = 0x8
	// Bit SPIE.
	IIC0_ICIER_SPIE = 0x8
	// Stop condition detection interrupt request (SPI) is disabled.
	IIC0_ICIER_SPIE_0 = 0x0
	// Stop condition detection interrupt request (SPI) is enabled.
	IIC0_ICIER_SPIE_1 = 0x1
	// Position of STIE field.
	IIC0_ICIER_STIE_Pos = 0x2
	// Bit mask of STIE field.
	IIC0_ICIER_STIE_Msk = 0x4
	// Bit STIE.
	IIC0_ICIER_STIE = 0x4
	// Start condition detection interrupt request (STI) is disabled.
	IIC0_ICIER_STIE_0 = 0x0
	// Start condition detection interrupt request (STI) is enabled.
	IIC0_ICIER_STIE_1 = 0x1
	// Position of ALIE field.
	IIC0_ICIER_ALIE_Pos = 0x1
	// Bit mask of ALIE field.
	IIC0_ICIER_ALIE_Msk = 0x2
	// Bit ALIE.
	IIC0_ICIER_ALIE = 0x2
	// Arbitration-lost interrupt request (ALI) is disabled.
	IIC0_ICIER_ALIE_0 = 0x0
	// Arbitration-lost interrupt request (ALI) is enabled.
	IIC0_ICIER_ALIE_1 = 0x1
	// Position of TMOIE field.
	IIC0_ICIER_TMOIE_Pos = 0x0
	// Bit mask of TMOIE field.
	IIC0_ICIER_TMOIE_Msk = 0x1
	// Bit TMOIE.
	IIC0_ICIER_TMOIE = 0x1
	// Timeout interrupt request (TMOI) is disabled.
	IIC0_ICIER_TMOIE_0 = 0x0
	// Timeout interrupt request (TMOI) is enabled.
	IIC0_ICIER_TMOIE_1 = 0x1

	// ICSR1: I2C Bus Status Register 1
	// Position of HOA field.
	IIC0_ICSR1_HOA_Pos = 0x7
	// Bit mask of HOA field.
	IIC0_ICSR1_HOA_Msk = 0x80
	// Bit HOA.
	IIC0_ICSR1_HOA = 0x80
	// Host address is not detected.
	IIC0_ICSR1_HOA_0 = 0x0
	// Host address is detected.
	IIC0_ICSR1_HOA_1 = 0x1
	// Position of Reserved field.
	IIC0_ICSR1_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	IIC0_ICSR1_Reserved_Msk = 0x40
	// Bit Reserved.
	IIC0_ICSR1_Reserved = 0x40
	// Position of DID field.
	IIC0_ICSR1_DID_Pos = 0x5
	// Bit mask of DID field.
	IIC0_ICSR1_DID_Msk = 0x20
	// Bit DID.
	IIC0_ICSR1_DID = 0x20
	// Device-ID command is not detected.
	IIC0_ICSR1_DID_0 = 0x0
	// Device-ID command is detected.
	IIC0_ICSR1_DID_1 = 0x1
	// Position of Reserved field.
	IIC0_ICSR1_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	IIC0_ICSR1_Reserved_Msk = 0x10
	// Bit Reserved.
	IIC0_ICSR1_Reserved = 0x10
	// Position of GCA field.
	IIC0_ICSR1_GCA_Pos = 0x3
	// Bit mask of GCA field.
	IIC0_ICSR1_GCA_Msk = 0x8
	// Bit GCA.
	IIC0_ICSR1_GCA = 0x8
	// General call address is not detected.
	IIC0_ICSR1_GCA_0 = 0x0
	// General call address is detected.
	IIC0_ICSR1_GCA_1 = 0x1
	// Position of AAS2 field.
	IIC0_ICSR1_AAS2_Pos = 0x2
	// Bit mask of AAS2 field.
	IIC0_ICSR1_AAS2_Msk = 0x4
	// Bit AAS2.
	IIC0_ICSR1_AAS2 = 0x4
	// Slave address 2 is not detected.
	IIC0_ICSR1_AAS2_0 = 0x0
	// Slave address 2 is detected
	IIC0_ICSR1_AAS2_1 = 0x1
	// Position of AAS1 field.
	IIC0_ICSR1_AAS1_Pos = 0x1
	// Bit mask of AAS1 field.
	IIC0_ICSR1_AAS1_Msk = 0x2
	// Bit AAS1.
	IIC0_ICSR1_AAS1 = 0x2
	// Slave address 1 is not detected.
	IIC0_ICSR1_AAS1_0 = 0x0
	// Slave address 1 is detected.
	IIC0_ICSR1_AAS1_1 = 0x1
	// Position of AAS0 field.
	IIC0_ICSR1_AAS0_Pos = 0x0
	// Bit mask of AAS0 field.
	IIC0_ICSR1_AAS0_Msk = 0x1
	// Bit AAS0.
	IIC0_ICSR1_AAS0 = 0x1
	// Slave address 0 is not detected.
	IIC0_ICSR1_AAS0_0 = 0x0
	// Slave address 0 is detected.
	IIC0_ICSR1_AAS0_1 = 0x1

	// ICSR2: I2C Bus Status Register 2
	// Position of TDRE field.
	IIC0_ICSR2_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	IIC0_ICSR2_TDRE_Msk = 0x80
	// Bit TDRE.
	IIC0_ICSR2_TDRE = 0x80
	// ICDRT contains transmit data.
	IIC0_ICSR2_TDRE_0 = 0x0
	// ICDRT contains no transmit data.
	IIC0_ICSR2_TDRE_1 = 0x1
	// Position of TEND field.
	IIC0_ICSR2_TEND_Pos = 0x6
	// Bit mask of TEND field.
	IIC0_ICSR2_TEND_Msk = 0x40
	// Bit TEND.
	IIC0_ICSR2_TEND = 0x40
	// Data is being transmitted.
	IIC0_ICSR2_TEND_0 = 0x0
	// Data has been transmitted.
	IIC0_ICSR2_TEND_1 = 0x1
	// Position of RDRF field.
	IIC0_ICSR2_RDRF_Pos = 0x5
	// Bit mask of RDRF field.
	IIC0_ICSR2_RDRF_Msk = 0x20
	// Bit RDRF.
	IIC0_ICSR2_RDRF = 0x20
	// ICDRR contains no receive data.
	IIC0_ICSR2_RDRF_0 = 0x0
	// ICDRR contains receive data.
	IIC0_ICSR2_RDRF_1 = 0x1
	// Position of NACKF field.
	IIC0_ICSR2_NACKF_Pos = 0x4
	// Bit mask of NACKF field.
	IIC0_ICSR2_NACKF_Msk = 0x10
	// Bit NACKF.
	IIC0_ICSR2_NACKF = 0x10
	// NACK is not detected.
	IIC0_ICSR2_NACKF_0 = 0x0
	// NACK is detected.
	IIC0_ICSR2_NACKF_1 = 0x1
	// Position of STOP field.
	IIC0_ICSR2_STOP_Pos = 0x3
	// Bit mask of STOP field.
	IIC0_ICSR2_STOP_Msk = 0x8
	// Bit STOP.
	IIC0_ICSR2_STOP = 0x8
	// Stop condition is not detected.
	IIC0_ICSR2_STOP_0 = 0x0
	// Stop condition is detected.
	IIC0_ICSR2_STOP_1 = 0x1
	// Position of START field.
	IIC0_ICSR2_START_Pos = 0x2
	// Bit mask of START field.
	IIC0_ICSR2_START_Msk = 0x4
	// Bit START.
	IIC0_ICSR2_START = 0x4
	// Start condition is not detected.
	IIC0_ICSR2_START_0 = 0x0
	// Start condition is detected.
	IIC0_ICSR2_START_1 = 0x1
	// Position of AL field.
	IIC0_ICSR2_AL_Pos = 0x1
	// Bit mask of AL field.
	IIC0_ICSR2_AL_Msk = 0x2
	// Bit AL.
	IIC0_ICSR2_AL = 0x2
	// Arbitration is not lost.
	IIC0_ICSR2_AL_0 = 0x0
	// Arbitration is lost.
	IIC0_ICSR2_AL_1 = 0x1
	// Position of TMOF field.
	IIC0_ICSR2_TMOF_Pos = 0x0
	// Bit mask of TMOF field.
	IIC0_ICSR2_TMOF_Msk = 0x1
	// Bit TMOF.
	IIC0_ICSR2_TMOF = 0x1
	// Timeout is not detected.
	IIC0_ICSR2_TMOF_0 = 0x0
	// Timeout is detected.
	IIC0_ICSR2_TMOF_1 = 0x1

	// SARL0: Slave Address Register L%s
	// Position of SVA field.
	IIC0_SARL_SVA_Pos = 0x0
	// Bit mask of SVA field.
	IIC0_SARL_SVA_Msk = 0xff

	// SARU0: Slave Address Register U%s
	// Position of Reserved field.
	IIC0_SARU_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	IIC0_SARU_Reserved_Msk = 0xf8
	// Position of SVA9 field.
	IIC0_SARU_SVA9_Pos = 0x2
	// Bit mask of SVA9 field.
	IIC0_SARU_SVA9_Msk = 0x4
	// Bit SVA9.
	IIC0_SARU_SVA9 = 0x4
	// Position of SVA8 field.
	IIC0_SARU_SVA8_Pos = 0x1
	// Bit mask of SVA8 field.
	IIC0_SARU_SVA8_Msk = 0x2
	// Bit SVA8.
	IIC0_SARU_SVA8 = 0x2
	// Position of FS field.
	IIC0_SARU_FS_Pos = 0x0
	// Bit mask of FS field.
	IIC0_SARU_FS_Msk = 0x1
	// Bit FS.
	IIC0_SARU_FS = 0x1
	// The 7-bit address format is selected.
	IIC0_SARU_FS_0 = 0x0
	// The 10-bit address format is selected.
	IIC0_SARU_FS_1 = 0x1

	// ICBRL: I2C Bus Bit Rate Low-Level Register
	// Position of Reserved field.
	IIC0_ICBRL_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	IIC0_ICBRL_Reserved_Msk = 0xe0
	// Position of BRL field.
	IIC0_ICBRL_BRL_Pos = 0x0
	// Bit mask of BRL field.
	IIC0_ICBRL_BRL_Msk = 0x1f

	// ICBRH: I2C Bus Bit Rate High-Level Register
	// Position of Reserved field.
	IIC0_ICBRH_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	IIC0_ICBRH_Reserved_Msk = 0xe0
	// Position of BRH field.
	IIC0_ICBRH_BRH_Pos = 0x0
	// Bit mask of BRH field.
	IIC0_ICBRH_BRH_Msk = 0x1f

	// ICDRT: I2C Bus Transmit Data Register
	// Position of ICDRT field.
	IIC0_ICDRT_ICDRT_Pos = 0x0
	// Bit mask of ICDRT field.
	IIC0_ICDRT_ICDRT_Msk = 0xff

	// ICDRR: I2C Bus Receive Data Register
	// Position of ICDRR field.
	IIC0_ICDRR_ICDRR_Pos = 0x0
	// Bit mask of ICDRR field.
	IIC0_ICDRR_ICDRR_Msk = 0xff

	// ICWUR: I2C Bus Wake Up Unit Register
	// Position of WUE field.
	IIC0_ICWUR_WUE_Pos = 0x7
	// Bit mask of WUE field.
	IIC0_ICWUR_WUE_Msk = 0x80
	// Bit WUE.
	IIC0_ICWUR_WUE = 0x80
	// Wakeup function disabled
	IIC0_ICWUR_WUE_0 = 0x0
	// Wakeup function enabled.
	IIC0_ICWUR_WUE_1 = 0x1
	// Position of WUIE field.
	IIC0_ICWUR_WUIE_Pos = 0x6
	// Bit mask of WUIE field.
	IIC0_ICWUR_WUIE_Msk = 0x40
	// Bit WUIE.
	IIC0_ICWUR_WUIE = 0x40
	// Wakeup Interrupt Request (IIC0_WUI) disabled
	IIC0_ICWUR_WUIE_0 = 0x0
	// Wakeup Interrupt Request (IIC0_WUI) enabled.
	IIC0_ICWUR_WUIE_1 = 0x1
	// Position of WUF field.
	IIC0_ICWUR_WUF_Pos = 0x5
	// Bit mask of WUF field.
	IIC0_ICWUR_WUF_Msk = 0x20
	// Bit WUF.
	IIC0_ICWUR_WUF = 0x20
	// Slave address does not match during wakeup function
	IIC0_ICWUR_WUF_0 = 0x0
	// Slave address matches during wakeup function.
	IIC0_ICWUR_WUF_1 = 0x1
	// Position of WUACK field.
	IIC0_ICWUR_WUACK_Pos = 0x4
	// Bit mask of WUACK field.
	IIC0_ICWUR_WUACK_Msk = 0x10
	// Bit WUACK.
	IIC0_ICWUR_WUACK = 0x10
	// State of synchronous operation
	IIC0_ICWUR_WUACK_0 = 0x0
	// State of asynchronous operation
	IIC0_ICWUR_WUACK_1 = 0x1
	// Position of Reserved field.
	IIC0_ICWUR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	IIC0_ICWUR_Reserved_Msk = 0xe
	// Position of WUAFA field.
	IIC0_ICWUR_WUAFA_Pos = 0x0
	// Bit mask of WUAFA field.
	IIC0_ICWUR_WUAFA_Msk = 0x1
	// Bit WUAFA.
	IIC0_ICWUR_WUAFA = 0x1
	// Do not add the wakeup analog filter
	IIC0_ICWUR_WUAFA_0 = 0x0
	// Add the wakeup analog filter.
	IIC0_ICWUR_WUAFA_1 = 0x1

	// ICWUR2: I2C Bus Wake up Unit Register 2
	// Position of Reserved field.
	IIC0_ICWUR2_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	IIC0_ICWUR2_Reserved_Msk = 0xf8
	// Position of WUSYF field.
	IIC0_ICWUR2_WUSYF_Pos = 0x2
	// Bit mask of WUSYF field.
	IIC0_ICWUR2_WUSYF_Msk = 0x4
	// Bit WUSYF.
	IIC0_ICWUR2_WUSYF = 0x4
	// IIC asynchronous circuit enable condition
	IIC0_ICWUR2_WUSYF_0 = 0x0
	// IIC synchronous circuit enable condition.
	IIC0_ICWUR2_WUSYF_1 = 0x1
	// Position of WUASYF field.
	IIC0_ICWUR2_WUASYF_Pos = 0x1
	// Bit mask of WUASYF field.
	IIC0_ICWUR2_WUASYF_Msk = 0x2
	// Bit WUASYF.
	IIC0_ICWUR2_WUASYF = 0x2
	// IIC synchronous circuit enable condition
	IIC0_ICWUR2_WUASYF_0 = 0x0
	// IIC asynchronous circuit enable condition.
	IIC0_ICWUR2_WUASYF_1 = 0x1
	// Position of WUSEN field.
	IIC0_ICWUR2_WUSEN_Pos = 0x0
	// Bit mask of WUSEN field.
	IIC0_ICWUR2_WUSEN_Msk = 0x1
	// Bit WUSEN.
	IIC0_ICWUR2_WUSEN = 0x1
	// IIC asynchronous circuit enable
	IIC0_ICWUR2_WUSEN_0 = 0x0
	// IIC synchronous circuit enable
	IIC0_ICWUR2_WUSEN_1 = 0x1
)

// Constants for IIC1: Inter-Integrated Circuit 1
const (
	// ICCR1: I2C Bus Control Register 1
	// Position of ICE field.
	IIC1_ICCR1_ICE_Pos = 0x7
	// Bit mask of ICE field.
	IIC1_ICCR1_ICE_Msk = 0x80
	// Bit ICE.
	IIC1_ICCR1_ICE = 0x80
	// Disable (SCLn and SDAn pins in inactive state)
	IIC1_ICCR1_ICE_0 = 0x0
	// Enable (SCLn and SDAn pins in active state)
	IIC1_ICCR1_ICE_1 = 0x1
	// Position of IICRST field.
	IIC1_ICCR1_IICRST_Pos = 0x6
	// Bit mask of IICRST field.
	IIC1_ICCR1_IICRST_Msk = 0x40
	// Bit IICRST.
	IIC1_ICCR1_IICRST = 0x40
	// Releases the RIIC reset or internal reset.
	IIC1_ICCR1_IICRST_0 = 0x0
	// Initiates the RIIC reset or internal reset.
	IIC1_ICCR1_IICRST_1 = 0x1
	// Position of CLO field.
	IIC1_ICCR1_CLO_Pos = 0x5
	// Bit mask of CLO field.
	IIC1_ICCR1_CLO_Msk = 0x20
	// Bit CLO.
	IIC1_ICCR1_CLO = 0x20
	// Does not output an extra SCL clock cycle.
	IIC1_ICCR1_CLO_0 = 0x0
	// Outputs an extra SCL clock cycle.
	IIC1_ICCR1_CLO_1 = 0x1
	// Position of SOWP field.
	IIC1_ICCR1_SOWP_Pos = 0x4
	// Bit mask of SOWP field.
	IIC1_ICCR1_SOWP_Msk = 0x10
	// Bit SOWP.
	IIC1_ICCR1_SOWP = 0x10
	// Bits SCLO and SDAO can be written
	IIC1_ICCR1_SOWP_0 = 0x0
	// Bits SCLO and SDAO are protected.
	IIC1_ICCR1_SOWP_1 = 0x1
	// Position of SCLO field.
	IIC1_ICCR1_SCLO_Pos = 0x3
	// Bit mask of SCLO field.
	IIC1_ICCR1_SCLO_Msk = 0x8
	// Bit SCLO.
	IIC1_ICCR1_SCLO = 0x8
	// (Read)The RIIC has driven the SCLn pin low. / (Write)The RIIC drives the SCLn pin low.
	IIC1_ICCR1_SCLO_0 = 0x0
	// (Read)The RIIC has released the SCLn pin. / (Write)The RIIC releases the SCLn pin.
	IIC1_ICCR1_SCLO_1 = 0x1
	// Position of SDAO field.
	IIC1_ICCR1_SDAO_Pos = 0x2
	// Bit mask of SDAO field.
	IIC1_ICCR1_SDAO_Msk = 0x4
	// Bit SDAO.
	IIC1_ICCR1_SDAO = 0x4
	// (Read)The RIIC has driven the SDAn pin low. / (Write)The RIIC drives the SDAn pin low.
	IIC1_ICCR1_SDAO_0 = 0x0
	// (Read)The RIIC has released the SDAn pin./ (Write)The RIIC releases the SDAn pin.
	IIC1_ICCR1_SDAO_1 = 0x1
	// Position of SCLI field.
	IIC1_ICCR1_SCLI_Pos = 0x1
	// Bit mask of SCLI field.
	IIC1_ICCR1_SCLI_Msk = 0x2
	// Bit SCLI.
	IIC1_ICCR1_SCLI = 0x2
	// SCLn line is low.
	IIC1_ICCR1_SCLI_0 = 0x0
	// SCLn line is high.
	IIC1_ICCR1_SCLI_1 = 0x1
	// Position of SDAI field.
	IIC1_ICCR1_SDAI_Pos = 0x0
	// Bit mask of SDAI field.
	IIC1_ICCR1_SDAI_Msk = 0x1
	// Bit SDAI.
	IIC1_ICCR1_SDAI = 0x1
	// SDAn line is low.
	IIC1_ICCR1_SDAI_0 = 0x0
	// SDAn line is high.
	IIC1_ICCR1_SDAI_1 = 0x1

	// ICCR2: I2C Bus Control Register 2
	// Position of BBSY field.
	IIC1_ICCR2_BBSY_Pos = 0x7
	// Bit mask of BBSY field.
	IIC1_ICCR2_BBSY_Msk = 0x80
	// Bit BBSY.
	IIC1_ICCR2_BBSY = 0x80
	// The I2C bus is released (bus free state).
	IIC1_ICCR2_BBSY_0 = 0x0
	// The I2C bus is occupied (bus busy state).
	IIC1_ICCR2_BBSY_1 = 0x1
	// Position of MST field.
	IIC1_ICCR2_MST_Pos = 0x6
	// Bit mask of MST field.
	IIC1_ICCR2_MST_Msk = 0x40
	// Bit MST.
	IIC1_ICCR2_MST = 0x40
	// Slave mode
	IIC1_ICCR2_MST_0 = 0x0
	// Master mode
	IIC1_ICCR2_MST_1 = 0x1
	// Position of TRS field.
	IIC1_ICCR2_TRS_Pos = 0x5
	// Bit mask of TRS field.
	IIC1_ICCR2_TRS_Msk = 0x20
	// Bit TRS.
	IIC1_ICCR2_TRS = 0x20
	// Receive mode
	IIC1_ICCR2_TRS_0 = 0x0
	// Transmit mode
	IIC1_ICCR2_TRS_1 = 0x1
	// Position of Reserved field.
	IIC1_ICCR2_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	IIC1_ICCR2_Reserved_Msk = 0x10
	// Bit Reserved.
	IIC1_ICCR2_Reserved = 0x10
	// Position of SP field.
	IIC1_ICCR2_SP_Pos = 0x3
	// Bit mask of SP field.
	IIC1_ICCR2_SP_Msk = 0x8
	// Bit SP.
	IIC1_ICCR2_SP = 0x8
	// Does not request to issue a stop condition.
	IIC1_ICCR2_SP_0 = 0x0
	// Requests to issue a stop condition.
	IIC1_ICCR2_SP_1 = 0x1
	// Position of RS field.
	IIC1_ICCR2_RS_Pos = 0x2
	// Bit mask of RS field.
	IIC1_ICCR2_RS_Msk = 0x4
	// Bit RS.
	IIC1_ICCR2_RS = 0x4
	// Does not request to issue a restart condition.
	IIC1_ICCR2_RS_0 = 0x0
	// Requests to issue a restart condition.
	IIC1_ICCR2_RS_1 = 0x1
	// Position of ST field.
	IIC1_ICCR2_ST_Pos = 0x1
	// Bit mask of ST field.
	IIC1_ICCR2_ST_Msk = 0x2
	// Bit ST.
	IIC1_ICCR2_ST = 0x2
	// Does not request to issue a start condition.
	IIC1_ICCR2_ST_0 = 0x0
	// Requests to issue a start condition.
	IIC1_ICCR2_ST_1 = 0x1
	// Position of Reserved field.
	IIC1_ICCR2_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	IIC1_ICCR2_Reserved_Msk = 0x1
	// Bit Reserved.
	IIC1_ICCR2_Reserved = 0x1

	// ICMR1: I2C Bus Mode Register 1
	// Position of MTWP field.
	IIC1_ICMR1_MTWP_Pos = 0x7
	// Bit mask of MTWP field.
	IIC1_ICMR1_MTWP_Msk = 0x80
	// Bit MTWP.
	IIC1_ICMR1_MTWP = 0x80
	// Disables writing to the MST and TRS bits in ICCR2.
	IIC1_ICMR1_MTWP_0 = 0x0
	// Enables writing to the MST and TRS bits in ICCR2.
	IIC1_ICMR1_MTWP_1 = 0x1
	// Position of CKS field.
	IIC1_ICMR1_CKS_Pos = 0x4
	// Bit mask of CKS field.
	IIC1_ICMR1_CKS_Msk = 0x70
	// PCLKB/1 clock
	IIC1_ICMR1_CKS_000 = 0x0
	// PCLKB/2 clock
	IIC1_ICMR1_CKS_001 = 0x1
	// PCLKB/4 clock
	IIC1_ICMR1_CKS_010 = 0x2
	// PCLKB/8 clock
	IIC1_ICMR1_CKS_011 = 0x3
	// PCLKB/16 clock
	IIC1_ICMR1_CKS_100 = 0x4
	// PCLKB/32 clock
	IIC1_ICMR1_CKS_101 = 0x5
	// PCLKB/64 clock
	IIC1_ICMR1_CKS_110 = 0x6
	// PCLKB/128 clock
	IIC1_ICMR1_CKS_111 = 0x7
	// Position of BCWP field.
	IIC1_ICMR1_BCWP_Pos = 0x3
	// Bit mask of BCWP field.
	IIC1_ICMR1_BCWP_Msk = 0x8
	// Bit BCWP.
	IIC1_ICMR1_BCWP = 0x8
	// Enables a value to be written in the BC[2:0] bits.
	IIC1_ICMR1_BCWP_0 = 0x0
	// Disables a value to be written in the BC[2:0] bits.
	IIC1_ICMR1_BCWP_1 = 0x1
	// Position of BC field.
	IIC1_ICMR1_BC_Pos = 0x0
	// Bit mask of BC field.
	IIC1_ICMR1_BC_Msk = 0x7
	// 9 bits
	IIC1_ICMR1_BC_000 = 0x0
	// 2 bits
	IIC1_ICMR1_BC_001 = 0x1
	// 3 bits
	IIC1_ICMR1_BC_010 = 0x2
	// 4 bits
	IIC1_ICMR1_BC_011 = 0x3
	// 5 bits
	IIC1_ICMR1_BC_100 = 0x4
	// 6 bits
	IIC1_ICMR1_BC_101 = 0x5
	// 7 bits
	IIC1_ICMR1_BC_110 = 0x6
	// 8 bits
	IIC1_ICMR1_BC_111 = 0x7

	// ICMR2: I2C Bus Mode Register 2
	// Position of DLCS field.
	IIC1_ICMR2_DLCS_Pos = 0x7
	// Bit mask of DLCS field.
	IIC1_ICMR2_DLCS_Msk = 0x80
	// Bit DLCS.
	IIC1_ICMR2_DLCS = 0x80
	// The internal reference clock (fIIC) is selected as the clock source of the SDA output delay counter.
	IIC1_ICMR2_DLCS_0 = 0x0
	// The internal reference clock divided by 2 (fIIC/2) is selected as the clock source of the SDA output delay counter.
	IIC1_ICMR2_DLCS_1 = 0x1
	// Position of SDDL field.
	IIC1_ICMR2_SDDL_Pos = 0x4
	// Bit mask of SDDL field.
	IIC1_ICMR2_SDDL_Msk = 0x70
	// No output delay
	IIC1_ICMR2_SDDL_000 = 0x0
	// 1 fIIC cycle (ICMR2.DLCS=0) / 1 or 2 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_001 = 0x1
	// 2 fIIC cycles (ICMR2.DLCS=0) / 3 or 4 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_010 = 0x2
	// 3 fIIC cycles (ICMR2.DLCS=0) / 5 or 6 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_011 = 0x3
	// 4 fIIC cycles (ICMR2.DLCS=0) / 7 or 8 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_100 = 0x4
	// 5 fIIC cycles (ICMR2.DLCS=0) / 9 or 10 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_101 = 0x5
	// 6 fIIC cycles (ICMR2.DLCS=0) / 11 or 12 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_110 = 0x6
	// 7 fIIC cycles (ICMR2.DLCS=0) / 13 or 14 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_111 = 0x7
	// Position of Reserved field.
	IIC1_ICMR2_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	IIC1_ICMR2_Reserved_Msk = 0x8
	// Bit Reserved.
	IIC1_ICMR2_Reserved = 0x8
	// Position of TMOH field.
	IIC1_ICMR2_TMOH_Pos = 0x2
	// Bit mask of TMOH field.
	IIC1_ICMR2_TMOH_Msk = 0x4
	// Bit TMOH.
	IIC1_ICMR2_TMOH = 0x4
	// Count is disabled while the SCLn line is at a high level.
	IIC1_ICMR2_TMOH_0 = 0x0
	// Count is enabled while the SCLn line is at a high level.
	IIC1_ICMR2_TMOH_1 = 0x1
	// Position of TMOL field.
	IIC1_ICMR2_TMOL_Pos = 0x1
	// Bit mask of TMOL field.
	IIC1_ICMR2_TMOL_Msk = 0x2
	// Bit TMOL.
	IIC1_ICMR2_TMOL = 0x2
	// Count is disabled while the SCLn line is at a low level.
	IIC1_ICMR2_TMOL_0 = 0x0
	// Count is enabled while the SCLn line is at a low level.
	IIC1_ICMR2_TMOL_1 = 0x1
	// Position of TMOS field.
	IIC1_ICMR2_TMOS_Pos = 0x0
	// Bit mask of TMOS field.
	IIC1_ICMR2_TMOS_Msk = 0x1
	// Bit TMOS.
	IIC1_ICMR2_TMOS = 0x1
	// Long mode is selected.
	IIC1_ICMR2_TMOS_0 = 0x0
	// Short mode is selected.
	IIC1_ICMR2_TMOS_1 = 0x1

	// ICMR3: I2C Bus Mode Register 3
	// Position of SMBS field.
	IIC1_ICMR3_SMBS_Pos = 0x7
	// Bit mask of SMBS field.
	IIC1_ICMR3_SMBS_Msk = 0x80
	// Bit SMBS.
	IIC1_ICMR3_SMBS = 0x80
	// The I2C bus is selected.
	IIC1_ICMR3_SMBS_0 = 0x0
	// The SMBus is selected.
	IIC1_ICMR3_SMBS_1 = 0x1
	// Position of WAIT field.
	IIC1_ICMR3_WAIT_Pos = 0x6
	// Bit mask of WAIT field.
	IIC1_ICMR3_WAIT_Msk = 0x40
	// Bit WAIT.
	IIC1_ICMR3_WAIT = 0x40
	// No WAIT (The period between ninth clock cycle and first clock cycle is not held low.)
	IIC1_ICMR3_WAIT_0 = 0x0
	// WAIT (The period between ninth clock cycle and first clock cycle is held low.)
	IIC1_ICMR3_WAIT_1 = 0x1
	// Position of RDRFS field.
	IIC1_ICMR3_RDRFS_Pos = 0x5
	// Bit mask of RDRFS field.
	IIC1_ICMR3_RDRFS_Msk = 0x20
	// Bit RDRFS.
	IIC1_ICMR3_RDRFS = 0x20
	// The RDRF flag is set at the rising edge of the ninth SCL clock cycle. (The SCLn line is not held low at the falling edge of the eighth clock cycle.)
	IIC1_ICMR3_RDRFS_0 = 0x0
	// The RDRF flag is set at the rising edge of the eighth SCL clock cycle. (The SCLn line is held low at the falling edge of the eighth clock cycle.)
	IIC1_ICMR3_RDRFS_1 = 0x1
	// Position of ACKWP field.
	IIC1_ICMR3_ACKWP_Pos = 0x4
	// Bit mask of ACKWP field.
	IIC1_ICMR3_ACKWP_Msk = 0x10
	// Bit ACKWP.
	IIC1_ICMR3_ACKWP = 0x10
	// Modification of the ACKBT bit is disabled.
	IIC1_ICMR3_ACKWP_0 = 0x0
	// Modification of the ACKBT bit is enabled.
	IIC1_ICMR3_ACKWP_1 = 0x1
	// Position of ACKBT field.
	IIC1_ICMR3_ACKBT_Pos = 0x3
	// Bit mask of ACKBT field.
	IIC1_ICMR3_ACKBT_Msk = 0x8
	// Bit ACKBT.
	IIC1_ICMR3_ACKBT = 0x8
	// A 0 is sent as the acknowledge bit (ACK transmission).
	IIC1_ICMR3_ACKBT_0 = 0x0
	// A 1 is sent as the acknowledge bit (NACK transmission).
	IIC1_ICMR3_ACKBT_1 = 0x1
	// Position of ACKBR field.
	IIC1_ICMR3_ACKBR_Pos = 0x2
	// Bit mask of ACKBR field.
	IIC1_ICMR3_ACKBR_Msk = 0x4
	// Bit ACKBR.
	IIC1_ICMR3_ACKBR = 0x4
	// A 0 is received as the acknowledge bit (ACK reception).
	IIC1_ICMR3_ACKBR_0 = 0x0
	// A 1 is received as the acknowledge bit (NACK reception).
	IIC1_ICMR3_ACKBR_1 = 0x1
	// Position of NF field.
	IIC1_ICMR3_NF_Pos = 0x0
	// Bit mask of NF field.
	IIC1_ICMR3_NF_Msk = 0x3
	// Noise of up to one fIIC cycle is filtered out (single-stage filter).
	IIC1_ICMR3_NF_00 = 0x0
	// Noise of up to two fIIC cycles is filtered out (2-stage filter).
	IIC1_ICMR3_NF_01 = 0x1
	// Noise of up to three fIIC cycles is filtered out (3-stage filter).
	IIC1_ICMR3_NF_10 = 0x2
	// Noise of up to four fIIC cycles is filtered out (4-stage filter)
	IIC1_ICMR3_NF_11 = 0x3

	// ICFER: I2C Bus Function Enable Register
	// Position of Reserved field.
	IIC1_ICFER_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	IIC1_ICFER_Reserved_Msk = 0x80
	// Bit Reserved.
	IIC1_ICFER_Reserved = 0x80
	// Position of SCLE field.
	IIC1_ICFER_SCLE_Pos = 0x6
	// Bit mask of SCLE field.
	IIC1_ICFER_SCLE_Msk = 0x40
	// Bit SCLE.
	IIC1_ICFER_SCLE = 0x40
	// No SCL synchronous circuit is used.
	IIC1_ICFER_SCLE_0 = 0x0
	// An SCL synchronous circuit is used.
	IIC1_ICFER_SCLE_1 = 0x1
	// Position of NFE field.
	IIC1_ICFER_NFE_Pos = 0x5
	// Bit mask of NFE field.
	IIC1_ICFER_NFE_Msk = 0x20
	// Bit NFE.
	IIC1_ICFER_NFE = 0x20
	// No digital noise filter circuit is used.
	IIC1_ICFER_NFE_0 = 0x0
	// A digital noise filter circuit is used.
	IIC1_ICFER_NFE_1 = 0x1
	// Position of NACKE field.
	IIC1_ICFER_NACKE_Pos = 0x4
	// Bit mask of NACKE field.
	IIC1_ICFER_NACKE_Msk = 0x10
	// Bit NACKE.
	IIC1_ICFER_NACKE = 0x10
	// Transfer operation is not suspended during NACK reception (transfer suspension disabled).
	IIC1_ICFER_NACKE_0 = 0x0
	// Transfer operation is suspended during NACK reception (transfer suspension enabled).
	IIC1_ICFER_NACKE_1 = 0x1
	// Position of SALE field.
	IIC1_ICFER_SALE_Pos = 0x3
	// Bit mask of SALE field.
	IIC1_ICFER_SALE_Msk = 0x8
	// Bit SALE.
	IIC1_ICFER_SALE = 0x8
	// Slave arbitration-lost detection is disabled.
	IIC1_ICFER_SALE_0 = 0x0
	// Slave arbitration-lost detection is enabled.
	IIC1_ICFER_SALE_1 = 0x1
	// Position of NALE field.
	IIC1_ICFER_NALE_Pos = 0x2
	// Bit mask of NALE field.
	IIC1_ICFER_NALE_Msk = 0x4
	// Bit NALE.
	IIC1_ICFER_NALE = 0x4
	// NACK transmission arbitration-lost detection is disabled.
	IIC1_ICFER_NALE_0 = 0x0
	// NACK transmission arbitration-lost detection is enabled.
	IIC1_ICFER_NALE_1 = 0x1
	// Position of MALE field.
	IIC1_ICFER_MALE_Pos = 0x1
	// Bit mask of MALE field.
	IIC1_ICFER_MALE_Msk = 0x2
	// Bit MALE.
	IIC1_ICFER_MALE = 0x2
	// Master arbitration-lost detection is disabled.
	IIC1_ICFER_MALE_0 = 0x0
	// Master arbitration-lost detection is enabled.
	IIC1_ICFER_MALE_1 = 0x1
	// Position of TMOE field.
	IIC1_ICFER_TMOE_Pos = 0x0
	// Bit mask of TMOE field.
	IIC1_ICFER_TMOE_Msk = 0x1
	// Bit TMOE.
	IIC1_ICFER_TMOE = 0x1
	// The timeout function is disabled.
	IIC1_ICFER_TMOE_0 = 0x0
	// The timeout function is enabled.
	IIC1_ICFER_TMOE_1 = 0x1

	// ICSER: I2C Bus Status Enable Register
	// Position of HOAE field.
	IIC1_ICSER_HOAE_Pos = 0x7
	// Bit mask of HOAE field.
	IIC1_ICSER_HOAE_Msk = 0x80
	// Bit HOAE.
	IIC1_ICSER_HOAE = 0x80
	// Host address detection is disabled.
	IIC1_ICSER_HOAE_0 = 0x0
	// Host address detection is enabled.
	IIC1_ICSER_HOAE_1 = 0x1
	// Position of Reserved field.
	IIC1_ICSER_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	IIC1_ICSER_Reserved_Msk = 0x40
	// Bit Reserved.
	IIC1_ICSER_Reserved = 0x40
	// Position of DIDE field.
	IIC1_ICSER_DIDE_Pos = 0x5
	// Bit mask of DIDE field.
	IIC1_ICSER_DIDE_Msk = 0x20
	// Bit DIDE.
	IIC1_ICSER_DIDE = 0x20
	// Device-ID address detection is disabled.
	IIC1_ICSER_DIDE_0 = 0x0
	// Device-ID address detection is enabled.
	IIC1_ICSER_DIDE_1 = 0x1
	// Position of Reserved field.
	IIC1_ICSER_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	IIC1_ICSER_Reserved_Msk = 0x10
	// Bit Reserved.
	IIC1_ICSER_Reserved = 0x10
	// Position of GCAE field.
	IIC1_ICSER_GCAE_Pos = 0x3
	// Bit mask of GCAE field.
	IIC1_ICSER_GCAE_Msk = 0x8
	// Bit GCAE.
	IIC1_ICSER_GCAE = 0x8
	// General call address detection is disabled.
	IIC1_ICSER_GCAE_0 = 0x0
	// General call address detection is enabled.
	IIC1_ICSER_GCAE_1 = 0x1
	// Position of SAR2E field.
	IIC1_ICSER_SAR2E_Pos = 0x2
	// Bit mask of SAR2E field.
	IIC1_ICSER_SAR2E_Msk = 0x4
	// Bit SAR2E.
	IIC1_ICSER_SAR2E = 0x4
	// Slave address in SARL2 and SARU2 is disabled.
	IIC1_ICSER_SAR2E_0 = 0x0
	// Slave address in SARL2 and SARU2 is enabled
	IIC1_ICSER_SAR2E_1 = 0x1
	// Position of SAR1E field.
	IIC1_ICSER_SAR1E_Pos = 0x1
	// Bit mask of SAR1E field.
	IIC1_ICSER_SAR1E_Msk = 0x2
	// Bit SAR1E.
	IIC1_ICSER_SAR1E = 0x2
	// Slave address in SARL1 and SARU1 is disabled.
	IIC1_ICSER_SAR1E_0 = 0x0
	// Slave address in SARL1 and SARU1 is enabled.
	IIC1_ICSER_SAR1E_1 = 0x1
	// Position of SAR0E field.
	IIC1_ICSER_SAR0E_Pos = 0x0
	// Bit mask of SAR0E field.
	IIC1_ICSER_SAR0E_Msk = 0x1
	// Bit SAR0E.
	IIC1_ICSER_SAR0E = 0x1
	// Slave address in SARL0 and SARU0 is disabled.
	IIC1_ICSER_SAR0E_0 = 0x0
	// Slave address in SARL0 and SARU0 is enabled.
	IIC1_ICSER_SAR0E_1 = 0x1

	// ICIER: I2C Bus Interrupt Enable Register
	// Position of TIE field.
	IIC1_ICIER_TIE_Pos = 0x7
	// Bit mask of TIE field.
	IIC1_ICIER_TIE_Msk = 0x80
	// Bit TIE.
	IIC1_ICIER_TIE = 0x80
	// Transmit data empty interrupt request (IIC_TXI) is disabled.
	IIC1_ICIER_TIE_0 = 0x0
	// Transmit data empty interrupt request (IIC_TXI) is enabled.
	IIC1_ICIER_TIE_1 = 0x1
	// Position of TEIE field.
	IIC1_ICIER_TEIE_Pos = 0x6
	// Bit mask of TEIE field.
	IIC1_ICIER_TEIE_Msk = 0x40
	// Bit TEIE.
	IIC1_ICIER_TEIE = 0x40
	// Transmit end interrupt request (IIC_TEI) is disabled.
	IIC1_ICIER_TEIE_0 = 0x0
	// Transmit end interrupt request (IIC_TEI) is enabled.
	IIC1_ICIER_TEIE_1 = 0x1
	// Position of RIE field.
	IIC1_ICIER_RIE_Pos = 0x5
	// Bit mask of RIE field.
	IIC1_ICIER_RIE_Msk = 0x20
	// Bit RIE.
	IIC1_ICIER_RIE = 0x20
	// Receive data full interrupt request (IIC_RXI) is disabled.
	IIC1_ICIER_RIE_0 = 0x0
	// Receive data full interrupt request (IIC_RXI) is enabled.
	IIC1_ICIER_RIE_1 = 0x1
	// Position of NAKIE field.
	IIC1_ICIER_NAKIE_Pos = 0x4
	// Bit mask of NAKIE field.
	IIC1_ICIER_NAKIE_Msk = 0x10
	// Bit NAKIE.
	IIC1_ICIER_NAKIE = 0x10
	// NACK reception interrupt request (NAKI) is disabled.
	IIC1_ICIER_NAKIE_0 = 0x0
	// NACK reception interrupt request (NAKI) is enabled.
	IIC1_ICIER_NAKIE_1 = 0x1
	// Position of SPIE field.
	IIC1_ICIER_SPIE_Pos = 0x3
	// Bit mask of SPIE field.
	IIC1_ICIER_SPIE_Msk = 0x8
	// Bit SPIE.
	IIC1_ICIER_SPIE = 0x8
	// Stop condition detection interrupt request (SPI) is disabled.
	IIC1_ICIER_SPIE_0 = 0x0
	// Stop condition detection interrupt request (SPI) is enabled.
	IIC1_ICIER_SPIE_1 = 0x1
	// Position of STIE field.
	IIC1_ICIER_STIE_Pos = 0x2
	// Bit mask of STIE field.
	IIC1_ICIER_STIE_Msk = 0x4
	// Bit STIE.
	IIC1_ICIER_STIE = 0x4
	// Start condition detection interrupt request (STI) is disabled.
	IIC1_ICIER_STIE_0 = 0x0
	// Start condition detection interrupt request (STI) is enabled.
	IIC1_ICIER_STIE_1 = 0x1
	// Position of ALIE field.
	IIC1_ICIER_ALIE_Pos = 0x1
	// Bit mask of ALIE field.
	IIC1_ICIER_ALIE_Msk = 0x2
	// Bit ALIE.
	IIC1_ICIER_ALIE = 0x2
	// Arbitration-lost interrupt request (ALI) is disabled.
	IIC1_ICIER_ALIE_0 = 0x0
	// Arbitration-lost interrupt request (ALI) is enabled.
	IIC1_ICIER_ALIE_1 = 0x1
	// Position of TMOIE field.
	IIC1_ICIER_TMOIE_Pos = 0x0
	// Bit mask of TMOIE field.
	IIC1_ICIER_TMOIE_Msk = 0x1
	// Bit TMOIE.
	IIC1_ICIER_TMOIE = 0x1
	// Timeout interrupt request (TMOI) is disabled.
	IIC1_ICIER_TMOIE_0 = 0x0
	// Timeout interrupt request (TMOI) is enabled.
	IIC1_ICIER_TMOIE_1 = 0x1

	// ICSR1: I2C Bus Status Register 1
	// Position of HOA field.
	IIC1_ICSR1_HOA_Pos = 0x7
	// Bit mask of HOA field.
	IIC1_ICSR1_HOA_Msk = 0x80
	// Bit HOA.
	IIC1_ICSR1_HOA = 0x80
	// Host address is not detected.
	IIC1_ICSR1_HOA_0 = 0x0
	// Host address is detected.
	IIC1_ICSR1_HOA_1 = 0x1
	// Position of Reserved field.
	IIC1_ICSR1_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	IIC1_ICSR1_Reserved_Msk = 0x40
	// Bit Reserved.
	IIC1_ICSR1_Reserved = 0x40
	// Position of DID field.
	IIC1_ICSR1_DID_Pos = 0x5
	// Bit mask of DID field.
	IIC1_ICSR1_DID_Msk = 0x20
	// Bit DID.
	IIC1_ICSR1_DID = 0x20
	// Device-ID command is not detected.
	IIC1_ICSR1_DID_0 = 0x0
	// Device-ID command is detected.
	IIC1_ICSR1_DID_1 = 0x1
	// Position of Reserved field.
	IIC1_ICSR1_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	IIC1_ICSR1_Reserved_Msk = 0x10
	// Bit Reserved.
	IIC1_ICSR1_Reserved = 0x10
	// Position of GCA field.
	IIC1_ICSR1_GCA_Pos = 0x3
	// Bit mask of GCA field.
	IIC1_ICSR1_GCA_Msk = 0x8
	// Bit GCA.
	IIC1_ICSR1_GCA = 0x8
	// General call address is not detected.
	IIC1_ICSR1_GCA_0 = 0x0
	// General call address is detected.
	IIC1_ICSR1_GCA_1 = 0x1
	// Position of AAS2 field.
	IIC1_ICSR1_AAS2_Pos = 0x2
	// Bit mask of AAS2 field.
	IIC1_ICSR1_AAS2_Msk = 0x4
	// Bit AAS2.
	IIC1_ICSR1_AAS2 = 0x4
	// Slave address 2 is not detected.
	IIC1_ICSR1_AAS2_0 = 0x0
	// Slave address 2 is detected
	IIC1_ICSR1_AAS2_1 = 0x1
	// Position of AAS1 field.
	IIC1_ICSR1_AAS1_Pos = 0x1
	// Bit mask of AAS1 field.
	IIC1_ICSR1_AAS1_Msk = 0x2
	// Bit AAS1.
	IIC1_ICSR1_AAS1 = 0x2
	// Slave address 1 is not detected.
	IIC1_ICSR1_AAS1_0 = 0x0
	// Slave address 1 is detected.
	IIC1_ICSR1_AAS1_1 = 0x1
	// Position of AAS0 field.
	IIC1_ICSR1_AAS0_Pos = 0x0
	// Bit mask of AAS0 field.
	IIC1_ICSR1_AAS0_Msk = 0x1
	// Bit AAS0.
	IIC1_ICSR1_AAS0 = 0x1
	// Slave address 0 is not detected.
	IIC1_ICSR1_AAS0_0 = 0x0
	// Slave address 0 is detected.
	IIC1_ICSR1_AAS0_1 = 0x1

	// ICSR2: I2C Bus Status Register 2
	// Position of TDRE field.
	IIC1_ICSR2_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	IIC1_ICSR2_TDRE_Msk = 0x80
	// Bit TDRE.
	IIC1_ICSR2_TDRE = 0x80
	// ICDRT contains transmit data.
	IIC1_ICSR2_TDRE_0 = 0x0
	// ICDRT contains no transmit data.
	IIC1_ICSR2_TDRE_1 = 0x1
	// Position of TEND field.
	IIC1_ICSR2_TEND_Pos = 0x6
	// Bit mask of TEND field.
	IIC1_ICSR2_TEND_Msk = 0x40
	// Bit TEND.
	IIC1_ICSR2_TEND = 0x40
	// Data is being transmitted.
	IIC1_ICSR2_TEND_0 = 0x0
	// Data has been transmitted.
	IIC1_ICSR2_TEND_1 = 0x1
	// Position of RDRF field.
	IIC1_ICSR2_RDRF_Pos = 0x5
	// Bit mask of RDRF field.
	IIC1_ICSR2_RDRF_Msk = 0x20
	// Bit RDRF.
	IIC1_ICSR2_RDRF = 0x20
	// ICDRR contains no receive data.
	IIC1_ICSR2_RDRF_0 = 0x0
	// ICDRR contains receive data.
	IIC1_ICSR2_RDRF_1 = 0x1
	// Position of NACKF field.
	IIC1_ICSR2_NACKF_Pos = 0x4
	// Bit mask of NACKF field.
	IIC1_ICSR2_NACKF_Msk = 0x10
	// Bit NACKF.
	IIC1_ICSR2_NACKF = 0x10
	// NACK is not detected.
	IIC1_ICSR2_NACKF_0 = 0x0
	// NACK is detected.
	IIC1_ICSR2_NACKF_1 = 0x1
	// Position of STOP field.
	IIC1_ICSR2_STOP_Pos = 0x3
	// Bit mask of STOP field.
	IIC1_ICSR2_STOP_Msk = 0x8
	// Bit STOP.
	IIC1_ICSR2_STOP = 0x8
	// Stop condition is not detected.
	IIC1_ICSR2_STOP_0 = 0x0
	// Stop condition is detected.
	IIC1_ICSR2_STOP_1 = 0x1
	// Position of START field.
	IIC1_ICSR2_START_Pos = 0x2
	// Bit mask of START field.
	IIC1_ICSR2_START_Msk = 0x4
	// Bit START.
	IIC1_ICSR2_START = 0x4
	// Start condition is not detected.
	IIC1_ICSR2_START_0 = 0x0
	// Start condition is detected.
	IIC1_ICSR2_START_1 = 0x1
	// Position of AL field.
	IIC1_ICSR2_AL_Pos = 0x1
	// Bit mask of AL field.
	IIC1_ICSR2_AL_Msk = 0x2
	// Bit AL.
	IIC1_ICSR2_AL = 0x2
	// Arbitration is not lost.
	IIC1_ICSR2_AL_0 = 0x0
	// Arbitration is lost.
	IIC1_ICSR2_AL_1 = 0x1
	// Position of TMOF field.
	IIC1_ICSR2_TMOF_Pos = 0x0
	// Bit mask of TMOF field.
	IIC1_ICSR2_TMOF_Msk = 0x1
	// Bit TMOF.
	IIC1_ICSR2_TMOF = 0x1
	// Timeout is not detected.
	IIC1_ICSR2_TMOF_0 = 0x0
	// Timeout is detected.
	IIC1_ICSR2_TMOF_1 = 0x1

	// SARL0: Slave Address Register L%s
	// Position of SVA field.
	IIC1_SARL_SVA_Pos = 0x0
	// Bit mask of SVA field.
	IIC1_SARL_SVA_Msk = 0xff

	// SARU0: Slave Address Register U%s
	// Position of Reserved field.
	IIC1_SARU_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	IIC1_SARU_Reserved_Msk = 0xf8
	// Position of SVA9 field.
	IIC1_SARU_SVA9_Pos = 0x2
	// Bit mask of SVA9 field.
	IIC1_SARU_SVA9_Msk = 0x4
	// Bit SVA9.
	IIC1_SARU_SVA9 = 0x4
	// Position of SVA8 field.
	IIC1_SARU_SVA8_Pos = 0x1
	// Bit mask of SVA8 field.
	IIC1_SARU_SVA8_Msk = 0x2
	// Bit SVA8.
	IIC1_SARU_SVA8 = 0x2
	// Position of FS field.
	IIC1_SARU_FS_Pos = 0x0
	// Bit mask of FS field.
	IIC1_SARU_FS_Msk = 0x1
	// Bit FS.
	IIC1_SARU_FS = 0x1
	// The 7-bit address format is selected.
	IIC1_SARU_FS_0 = 0x0
	// The 10-bit address format is selected.
	IIC1_SARU_FS_1 = 0x1

	// ICBRL: I2C Bus Bit Rate Low-Level Register
	// Position of Reserved field.
	IIC1_ICBRL_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	IIC1_ICBRL_Reserved_Msk = 0xe0
	// Position of BRL field.
	IIC1_ICBRL_BRL_Pos = 0x0
	// Bit mask of BRL field.
	IIC1_ICBRL_BRL_Msk = 0x1f

	// ICBRH: I2C Bus Bit Rate High-Level Register
	// Position of Reserved field.
	IIC1_ICBRH_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	IIC1_ICBRH_Reserved_Msk = 0xe0
	// Position of BRH field.
	IIC1_ICBRH_BRH_Pos = 0x0
	// Bit mask of BRH field.
	IIC1_ICBRH_BRH_Msk = 0x1f

	// ICDRT: I2C Bus Transmit Data Register
	// Position of ICDRT field.
	IIC1_ICDRT_ICDRT_Pos = 0x0
	// Bit mask of ICDRT field.
	IIC1_ICDRT_ICDRT_Msk = 0xff

	// ICDRR: I2C Bus Receive Data Register
	// Position of ICDRR field.
	IIC1_ICDRR_ICDRR_Pos = 0x0
	// Bit mask of ICDRR field.
	IIC1_ICDRR_ICDRR_Msk = 0xff
)

// Constants for CAN0: CAN0 Module
const (
	// MB0_ID: Mailbox Register
	// Position of IDE field.
	CAN0_MB_ID_IDE_Pos = 0x1f
	// Bit mask of IDE field.
	CAN0_MB_ID_IDE_Msk = 0x80000000
	// Bit IDE.
	CAN0_MB_ID_IDE = 0x80000000
	// Standard ID
	CAN0_MB_ID_IDE_0 = 0x0
	// Extended ID
	CAN0_MB_ID_IDE_1 = 0x1
	// Position of RTR field.
	CAN0_MB_ID_RTR_Pos = 0x1e
	// Bit mask of RTR field.
	CAN0_MB_ID_RTR_Msk = 0x40000000
	// Bit RTR.
	CAN0_MB_ID_RTR = 0x40000000
	// Data frame
	CAN0_MB_ID_RTR_0 = 0x0
	// Remote frame
	CAN0_MB_ID_RTR_1 = 0x1
	// Position of Reserved field.
	CAN0_MB_ID_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	CAN0_MB_ID_Reserved_Msk = 0x20000000
	// Bit Reserved.
	CAN0_MB_ID_Reserved = 0x20000000
	// Position of SID field.
	CAN0_MB_ID_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_MB_ID_SID_Msk = 0x1ffc0000
	// Position of EID field.
	CAN0_MB_ID_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_MB_ID_EID_Msk = 0x3ffff

	// MB0_DL: Mailbox Register
	// Position of Reserved field.
	CAN0_MB_DL_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	CAN0_MB_DL_Reserved_Msk = 0xfff0
	// Position of DLC field.
	CAN0_MB_DL_DLC_Pos = 0x0
	// Bit mask of DLC field.
	CAN0_MB_DL_DLC_Msk = 0xf
	// Data length = 0 byte
	CAN0_MB_DL_DLC_0000 = 0x0
	// Data length = 1 byte
	CAN0_MB_DL_DLC_0001 = 0x1
	// Data length = 2 bytes
	CAN0_MB_DL_DLC_0010 = 0x2
	// Data length = 3 bytes
	CAN0_MB_DL_DLC_0011 = 0x3
	// Data length = 4 bytes
	CAN0_MB_DL_DLC_0100 = 0x4
	// Data length = 5 bytes
	CAN0_MB_DL_DLC_0101 = 0x5
	// Data length = 6 bytes
	CAN0_MB_DL_DLC_0110 = 0x6
	// Data length = 7 bytes
	CAN0_MB_DL_DLC_0111 = 0x7

	// MB0_D0: Mailbox Register
	// Position of DATA0 field.
	CAN0_MB_D0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	CAN0_MB_D0_DATA0_Msk = 0xff

	// MB0_D1: Mailbox Register
	// Position of DATA1 field.
	CAN0_MB_D1_DATA1_Pos = 0x0
	// Bit mask of DATA1 field.
	CAN0_MB_D1_DATA1_Msk = 0xff

	// MB0_D2: Mailbox Register
	// Position of DATA2 field.
	CAN0_MB_D2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	CAN0_MB_D2_DATA2_Msk = 0xff

	// MB0_D3: Mailbox Register
	// Position of DATA3 field.
	CAN0_MB_D3_DATA3_Pos = 0x0
	// Bit mask of DATA3 field.
	CAN0_MB_D3_DATA3_Msk = 0xff

	// MB0_D4: Mailbox Register
	// Position of DATA4 field.
	CAN0_MB_D4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	CAN0_MB_D4_DATA4_Msk = 0xff

	// MB0_D5: Mailbox Register
	// Position of DATA5 field.
	CAN0_MB_D5_DATA5_Pos = 0x0
	// Bit mask of DATA5 field.
	CAN0_MB_D5_DATA5_Msk = 0xff

	// MB0_D6: Mailbox Register
	// Position of DATA6 field.
	CAN0_MB_D6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	CAN0_MB_D6_DATA6_Msk = 0xff

	// MB0_D7: Mailbox Register
	// Position of DATA7 field.
	CAN0_MB_D7_DATA7_Pos = 0x0
	// Bit mask of DATA7 field.
	CAN0_MB_D7_DATA7_Msk = 0xff

	// MB0_TS: Mailbox Register
	// Position of TSH field.
	CAN0_MB_TS_TSH_Pos = 0x8
	// Bit mask of TSH field.
	CAN0_MB_TS_TSH_Msk = 0xff00
	// Position of TSL field.
	CAN0_MB_TS_TSL_Pos = 0x0
	// Bit mask of TSL field.
	CAN0_MB_TS_TSL_Msk = 0xff

	// MKR: Mask Register
	// Position of Reserved field.
	CAN0_MKR_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	CAN0_MKR_Reserved_Msk = 0xe0000000
	// Position of SID field.
	CAN0_MKR_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_MKR_SID_Msk = 0x1ffc0000
	// Position of EID field.
	CAN0_MKR_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_MKR_EID_Msk = 0x3ffff

	// FIDCR0: FIFO Received ID Compare Registers
	// Position of IDE field.
	CAN0_FIDCR_IDE_Pos = 0x1f
	// Bit mask of IDE field.
	CAN0_FIDCR_IDE_Msk = 0x80000000
	// Bit IDE.
	CAN0_FIDCR_IDE = 0x80000000
	// Standard ID
	CAN0_FIDCR_IDE_0 = 0x0
	// Extended ID
	CAN0_FIDCR_IDE_1 = 0x1
	// Position of RTR field.
	CAN0_FIDCR_RTR_Pos = 0x1e
	// Bit mask of RTR field.
	CAN0_FIDCR_RTR_Msk = 0x40000000
	// Bit RTR.
	CAN0_FIDCR_RTR = 0x40000000
	// Data frame
	CAN0_FIDCR_RTR_0 = 0x0
	// Remote frame
	CAN0_FIDCR_RTR_1 = 0x1
	// Position of Reserved field.
	CAN0_FIDCR_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	CAN0_FIDCR_Reserved_Msk = 0x20000000
	// Bit Reserved.
	CAN0_FIDCR_Reserved = 0x20000000
	// Position of SID field.
	CAN0_FIDCR_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_FIDCR_SID_Msk = 0x1ffc0000
	// Position of EID field.
	CAN0_FIDCR_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_FIDCR_EID_Msk = 0x3ffff

	// MKIVLR: Mask Invalid Register
	// Position of MB31 field.
	CAN0_MKIVLR_MB31_Pos = 0x1f
	// Bit mask of MB31 field.
	CAN0_MKIVLR_MB31_Msk = 0x80000000
	// Bit MB31.
	CAN0_MKIVLR_MB31 = 0x80000000
	// Mask valid
	CAN0_MKIVLR_MB31_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB31_1 = 0x1
	// Position of MB30 field.
	CAN0_MKIVLR_MB30_Pos = 0x1e
	// Bit mask of MB30 field.
	CAN0_MKIVLR_MB30_Msk = 0x40000000
	// Bit MB30.
	CAN0_MKIVLR_MB30 = 0x40000000
	// Mask valid
	CAN0_MKIVLR_MB30_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB30_1 = 0x1
	// Position of MB29 field.
	CAN0_MKIVLR_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MKIVLR_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MKIVLR_MB29 = 0x20000000
	// Mask valid
	CAN0_MKIVLR_MB29_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB29_1 = 0x1
	// Position of MB28 field.
	CAN0_MKIVLR_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MKIVLR_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MKIVLR_MB28 = 0x10000000
	// Mask valid
	CAN0_MKIVLR_MB28_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB28_1 = 0x1
	// Position of MB27 field.
	CAN0_MKIVLR_MB27_Pos = 0x1b
	// Bit mask of MB27 field.
	CAN0_MKIVLR_MB27_Msk = 0x8000000
	// Bit MB27.
	CAN0_MKIVLR_MB27 = 0x8000000
	// Mask valid
	CAN0_MKIVLR_MB27_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB27_1 = 0x1
	// Position of MB26 field.
	CAN0_MKIVLR_MB26_Pos = 0x1a
	// Bit mask of MB26 field.
	CAN0_MKIVLR_MB26_Msk = 0x4000000
	// Bit MB26.
	CAN0_MKIVLR_MB26 = 0x4000000
	// Mask valid
	CAN0_MKIVLR_MB26_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB26_1 = 0x1
	// Position of MB25 field.
	CAN0_MKIVLR_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MKIVLR_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MKIVLR_MB25 = 0x2000000
	// Mask valid
	CAN0_MKIVLR_MB25_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB25_1 = 0x1
	// Position of MB24 field.
	CAN0_MKIVLR_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MKIVLR_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MKIVLR_MB24 = 0x1000000
	// Mask valid
	CAN0_MKIVLR_MB24_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB24_1 = 0x1
	// Position of MB23 field.
	CAN0_MKIVLR_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MKIVLR_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MKIVLR_MB23 = 0x800000
	// Mask valid
	CAN0_MKIVLR_MB23_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB23_1 = 0x1
	// Position of MB22 field.
	CAN0_MKIVLR_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MKIVLR_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MKIVLR_MB22 = 0x400000
	// Mask valid
	CAN0_MKIVLR_MB22_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB22_1 = 0x1
	// Position of MB21 field.
	CAN0_MKIVLR_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MKIVLR_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MKIVLR_MB21 = 0x200000
	// Mask valid
	CAN0_MKIVLR_MB21_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB21_1 = 0x1
	// Position of MB20 field.
	CAN0_MKIVLR_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MKIVLR_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MKIVLR_MB20 = 0x100000
	// Mask valid
	CAN0_MKIVLR_MB20_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB20_1 = 0x1
	// Position of MB19 field.
	CAN0_MKIVLR_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MKIVLR_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MKIVLR_MB19 = 0x80000
	// Mask valid
	CAN0_MKIVLR_MB19_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB19_1 = 0x1
	// Position of MB18 field.
	CAN0_MKIVLR_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MKIVLR_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MKIVLR_MB18 = 0x40000
	// Mask valid
	CAN0_MKIVLR_MB18_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB18_1 = 0x1
	// Position of MB17 field.
	CAN0_MKIVLR_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MKIVLR_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MKIVLR_MB17 = 0x20000
	// Mask valid
	CAN0_MKIVLR_MB17_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB17_1 = 0x1
	// Position of MB16 field.
	CAN0_MKIVLR_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MKIVLR_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MKIVLR_MB16 = 0x10000
	// Mask valid
	CAN0_MKIVLR_MB16_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB16_1 = 0x1
	// Position of MB15 field.
	CAN0_MKIVLR_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MKIVLR_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MKIVLR_MB15 = 0x8000
	// Mask valid
	CAN0_MKIVLR_MB15_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB15_1 = 0x1
	// Position of MB14 field.
	CAN0_MKIVLR_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MKIVLR_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MKIVLR_MB14 = 0x4000
	// Mask valid
	CAN0_MKIVLR_MB14_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB14_1 = 0x1
	// Position of MB13 field.
	CAN0_MKIVLR_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MKIVLR_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MKIVLR_MB13 = 0x2000
	// Mask valid
	CAN0_MKIVLR_MB13_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB13_1 = 0x1
	// Position of MB12 field.
	CAN0_MKIVLR_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MKIVLR_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MKIVLR_MB12 = 0x1000
	// Mask valid
	CAN0_MKIVLR_MB12_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB12_1 = 0x1
	// Position of MB11 field.
	CAN0_MKIVLR_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MKIVLR_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MKIVLR_MB11 = 0x800
	// Mask valid
	CAN0_MKIVLR_MB11_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB11_1 = 0x1
	// Position of MB10 field.
	CAN0_MKIVLR_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MKIVLR_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MKIVLR_MB10 = 0x400
	// Mask valid
	CAN0_MKIVLR_MB10_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB10_1 = 0x1
	// Position of MB9 field.
	CAN0_MKIVLR_MB9_Pos = 0x9
	// Bit mask of MB9 field.
	CAN0_MKIVLR_MB9_Msk = 0x200
	// Bit MB9.
	CAN0_MKIVLR_MB9 = 0x200
	// Mask valid
	CAN0_MKIVLR_MB9_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB9_1 = 0x1
	// Position of MB8 field.
	CAN0_MKIVLR_MB8_Pos = 0x8
	// Bit mask of MB8 field.
	CAN0_MKIVLR_MB8_Msk = 0x100
	// Bit MB8.
	CAN0_MKIVLR_MB8 = 0x100
	// Mask valid
	CAN0_MKIVLR_MB8_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB8_1 = 0x1
	// Position of MB7 field.
	CAN0_MKIVLR_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN0_MKIVLR_MB7_Msk = 0x80
	// Bit MB7.
	CAN0_MKIVLR_MB7 = 0x80
	// Mask valid
	CAN0_MKIVLR_MB7_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB7_1 = 0x1
	// Position of MB6 field.
	CAN0_MKIVLR_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN0_MKIVLR_MB6_Msk = 0x40
	// Bit MB6.
	CAN0_MKIVLR_MB6 = 0x40
	// Mask valid
	CAN0_MKIVLR_MB6_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB6_1 = 0x1
	// Position of MB5 field.
	CAN0_MKIVLR_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN0_MKIVLR_MB5_Msk = 0x20
	// Bit MB5.
	CAN0_MKIVLR_MB5 = 0x20
	// Mask valid
	CAN0_MKIVLR_MB5_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB5_1 = 0x1
	// Position of MB4 field.
	CAN0_MKIVLR_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN0_MKIVLR_MB4_Msk = 0x10
	// Bit MB4.
	CAN0_MKIVLR_MB4 = 0x10
	// Mask valid
	CAN0_MKIVLR_MB4_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB4_1 = 0x1
	// Position of MB3 field.
	CAN0_MKIVLR_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN0_MKIVLR_MB3_Msk = 0x8
	// Bit MB3.
	CAN0_MKIVLR_MB3 = 0x8
	// Mask valid
	CAN0_MKIVLR_MB3_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB3_1 = 0x1
	// Position of MB2 field.
	CAN0_MKIVLR_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN0_MKIVLR_MB2_Msk = 0x4
	// Bit MB2.
	CAN0_MKIVLR_MB2 = 0x4
	// Mask valid
	CAN0_MKIVLR_MB2_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB2_1 = 0x1
	// Position of MB1 field.
	CAN0_MKIVLR_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN0_MKIVLR_MB1_Msk = 0x2
	// Bit MB1.
	CAN0_MKIVLR_MB1 = 0x2
	// Mask valid
	CAN0_MKIVLR_MB1_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB1_1 = 0x1
	// Position of MB0 field.
	CAN0_MKIVLR_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN0_MKIVLR_MB0_Msk = 0x1
	// Bit MB0.
	CAN0_MKIVLR_MB0 = 0x1
	// Mask valid
	CAN0_MKIVLR_MB0_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB0_1 = 0x1

	// MIER: Mailbox Interrupt Enable Register
	// Position of MB31 field.
	CAN0_MIER_MB31_Pos = 0x1f
	// Bit mask of MB31 field.
	CAN0_MIER_MB31_Msk = 0x80000000
	// Bit MB31.
	CAN0_MIER_MB31 = 0x80000000
	// Interrupt disabled
	CAN0_MIER_MB31_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB31_1 = 0x1
	// Position of MB30 field.
	CAN0_MIER_MB30_Pos = 0x1e
	// Bit mask of MB30 field.
	CAN0_MIER_MB30_Msk = 0x40000000
	// Bit MB30.
	CAN0_MIER_MB30 = 0x40000000
	// Interrupt disabled
	CAN0_MIER_MB30_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB30_1 = 0x1
	// Position of MB29 field.
	CAN0_MIER_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MIER_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MIER_MB29 = 0x20000000
	// Interrupt disabled
	CAN0_MIER_MB29_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB29_1 = 0x1
	// Position of MB28 field.
	CAN0_MIER_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MIER_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MIER_MB28 = 0x10000000
	// Interrupt disabled
	CAN0_MIER_MB28_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB28_1 = 0x1
	// Position of MB27 field.
	CAN0_MIER_MB27_Pos = 0x1b
	// Bit mask of MB27 field.
	CAN0_MIER_MB27_Msk = 0x8000000
	// Bit MB27.
	CAN0_MIER_MB27 = 0x8000000
	// Interrupt disabled
	CAN0_MIER_MB27_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB27_1 = 0x1
	// Position of MB26 field.
	CAN0_MIER_MB26_Pos = 0x1a
	// Bit mask of MB26 field.
	CAN0_MIER_MB26_Msk = 0x4000000
	// Bit MB26.
	CAN0_MIER_MB26 = 0x4000000
	// Interrupt disabled
	CAN0_MIER_MB26_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB26_1 = 0x1
	// Position of MB25 field.
	CAN0_MIER_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MIER_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MIER_MB25 = 0x2000000
	// Interrupt disabled
	CAN0_MIER_MB25_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB25_1 = 0x1
	// Position of MB24 field.
	CAN0_MIER_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MIER_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MIER_MB24 = 0x1000000
	// Interrupt disabled
	CAN0_MIER_MB24_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB24_1 = 0x1
	// Position of MB23 field.
	CAN0_MIER_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MIER_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MIER_MB23 = 0x800000
	// Interrupt disabled
	CAN0_MIER_MB23_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB23_1 = 0x1
	// Position of MB22 field.
	CAN0_MIER_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MIER_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MIER_MB22 = 0x400000
	// Interrupt disabled
	CAN0_MIER_MB22_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB22_1 = 0x1
	// Position of MB21 field.
	CAN0_MIER_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MIER_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MIER_MB21 = 0x200000
	// Interrupt disabled
	CAN0_MIER_MB21_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB21_1 = 0x1
	// Position of MB20 field.
	CAN0_MIER_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MIER_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MIER_MB20 = 0x100000
	// Interrupt disabled
	CAN0_MIER_MB20_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB20_1 = 0x1
	// Position of MB19 field.
	CAN0_MIER_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MIER_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MIER_MB19 = 0x80000
	// Interrupt disabled
	CAN0_MIER_MB19_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB19_1 = 0x1
	// Position of MB18 field.
	CAN0_MIER_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MIER_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MIER_MB18 = 0x40000
	// Interrupt disabled
	CAN0_MIER_MB18_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB18_1 = 0x1
	// Position of MB17 field.
	CAN0_MIER_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MIER_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MIER_MB17 = 0x20000
	// Interrupt disabled
	CAN0_MIER_MB17_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB17_1 = 0x1
	// Position of MB16 field.
	CAN0_MIER_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MIER_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MIER_MB16 = 0x10000
	// Interrupt disabled
	CAN0_MIER_MB16_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB16_1 = 0x1
	// Position of MB15 field.
	CAN0_MIER_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MIER_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MIER_MB15 = 0x8000
	// Interrupt disabled
	CAN0_MIER_MB15_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB15_1 = 0x1
	// Position of MB14 field.
	CAN0_MIER_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MIER_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MIER_MB14 = 0x4000
	// Interrupt disabled
	CAN0_MIER_MB14_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB14_1 = 0x1
	// Position of MB13 field.
	CAN0_MIER_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MIER_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MIER_MB13 = 0x2000
	// Interrupt disabled
	CAN0_MIER_MB13_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB13_1 = 0x1
	// Position of MB12 field.
	CAN0_MIER_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MIER_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MIER_MB12 = 0x1000
	// Interrupt disabled
	CAN0_MIER_MB12_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB12_1 = 0x1
	// Position of MB11 field.
	CAN0_MIER_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MIER_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MIER_MB11 = 0x800
	// Interrupt disabled
	CAN0_MIER_MB11_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB11_1 = 0x1
	// Position of MB10 field.
	CAN0_MIER_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MIER_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MIER_MB10 = 0x400
	// Interrupt disabled
	CAN0_MIER_MB10_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB10_1 = 0x1
	// Position of MB9 field.
	CAN0_MIER_MB9_Pos = 0x9
	// Bit mask of MB9 field.
	CAN0_MIER_MB9_Msk = 0x200
	// Bit MB9.
	CAN0_MIER_MB9 = 0x200
	// Interrupt disabled
	CAN0_MIER_MB9_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB9_1 = 0x1
	// Position of MB8 field.
	CAN0_MIER_MB8_Pos = 0x8
	// Bit mask of MB8 field.
	CAN0_MIER_MB8_Msk = 0x100
	// Bit MB8.
	CAN0_MIER_MB8 = 0x100
	// Interrupt disabled
	CAN0_MIER_MB8_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB8_1 = 0x1
	// Position of MB7 field.
	CAN0_MIER_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN0_MIER_MB7_Msk = 0x80
	// Bit MB7.
	CAN0_MIER_MB7 = 0x80
	// Interrupt disabled
	CAN0_MIER_MB7_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB7_1 = 0x1
	// Position of MB6 field.
	CAN0_MIER_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN0_MIER_MB6_Msk = 0x40
	// Bit MB6.
	CAN0_MIER_MB6 = 0x40
	// Interrupt disabled
	CAN0_MIER_MB6_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB6_1 = 0x1
	// Position of MB5 field.
	CAN0_MIER_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN0_MIER_MB5_Msk = 0x20
	// Bit MB5.
	CAN0_MIER_MB5 = 0x20
	// Interrupt disabled
	CAN0_MIER_MB5_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB5_1 = 0x1
	// Position of MB4 field.
	CAN0_MIER_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN0_MIER_MB4_Msk = 0x10
	// Bit MB4.
	CAN0_MIER_MB4 = 0x10
	// Interrupt disabled
	CAN0_MIER_MB4_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB4_1 = 0x1
	// Position of MB3 field.
	CAN0_MIER_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN0_MIER_MB3_Msk = 0x8
	// Bit MB3.
	CAN0_MIER_MB3 = 0x8
	// Interrupt disabled
	CAN0_MIER_MB3_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB3_1 = 0x1
	// Position of MB2 field.
	CAN0_MIER_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN0_MIER_MB2_Msk = 0x4
	// Bit MB2.
	CAN0_MIER_MB2 = 0x4
	// Interrupt disabled
	CAN0_MIER_MB2_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB2_1 = 0x1
	// Position of MB1 field.
	CAN0_MIER_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN0_MIER_MB1_Msk = 0x2
	// Bit MB1.
	CAN0_MIER_MB1 = 0x2
	// Interrupt disabled
	CAN0_MIER_MB1_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB1_1 = 0x1
	// Position of MB0 field.
	CAN0_MIER_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN0_MIER_MB0_Msk = 0x1
	// Bit MB0.
	CAN0_MIER_MB0 = 0x1
	// Interrupt disabled
	CAN0_MIER_MB0_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB0_1 = 0x1

	// MIER_FIFO: Mailbox Interrupt Enable Register for FIFO Mailbox Mode
	// Position of MB29 field.
	CAN0_MIER_FIFO_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MIER_FIFO_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MIER_FIFO_MB29 = 0x20000000
	// Every time reception is completed
	CAN0_MIER_FIFO_MB29_0 = 0x0
	// When the receive FIFO becomes buffer warning by completion of reception
	CAN0_MIER_FIFO_MB29_1 = 0x1
	// Position of MB28 field.
	CAN0_MIER_FIFO_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MIER_FIFO_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MIER_FIFO_MB28 = 0x10000000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB28_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB28_1 = 0x1
	// Position of Reserved field.
	CAN0_MIER_FIFO_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	CAN0_MIER_FIFO_Reserved_Msk = 0xc000000
	// Position of MB25 field.
	CAN0_MIER_FIFO_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MIER_FIFO_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MIER_FIFO_MB25 = 0x2000000
	// Every time transmission is completed
	CAN0_MIER_FIFO_MB25_0 = 0x0
	// When the transmit FIFO becomes empty due to completion of transmission
	CAN0_MIER_FIFO_MB25_1 = 0x1
	// Position of MB24 field.
	CAN0_MIER_FIFO_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MIER_FIFO_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MIER_FIFO_MB24 = 0x1000000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB24_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB24_1 = 0x1
	// Position of MB23 field.
	CAN0_MIER_FIFO_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MIER_FIFO_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MIER_FIFO_MB23 = 0x800000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB23_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB23_1 = 0x1
	// Position of MB22 field.
	CAN0_MIER_FIFO_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MIER_FIFO_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MIER_FIFO_MB22 = 0x400000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB22_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB22_1 = 0x1
	// Position of MB21 field.
	CAN0_MIER_FIFO_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MIER_FIFO_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MIER_FIFO_MB21 = 0x200000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB21_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB21_1 = 0x1
	// Position of MB20 field.
	CAN0_MIER_FIFO_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MIER_FIFO_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MIER_FIFO_MB20 = 0x100000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB20_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB20_1 = 0x1
	// Position of MB19 field.
	CAN0_MIER_FIFO_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MIER_FIFO_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MIER_FIFO_MB19 = 0x80000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB19_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB19_1 = 0x1
	// Position of MB18 field.
	CAN0_MIER_FIFO_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MIER_FIFO_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MIER_FIFO_MB18 = 0x40000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB18_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB18_1 = 0x1
	// Position of MB17 field.
	CAN0_MIER_FIFO_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MIER_FIFO_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MIER_FIFO_MB17 = 0x20000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB17_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB17_1 = 0x1
	// Position of MB16 field.
	CAN0_MIER_FIFO_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MIER_FIFO_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MIER_FIFO_MB16 = 0x10000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB16_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB16_1 = 0x1
	// Position of MB15 field.
	CAN0_MIER_FIFO_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MIER_FIFO_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MIER_FIFO_MB15 = 0x8000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB15_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB15_1 = 0x1
	// Position of MB14 field.
	CAN0_MIER_FIFO_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MIER_FIFO_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MIER_FIFO_MB14 = 0x4000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB14_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB14_1 = 0x1
	// Position of MB13 field.
	CAN0_MIER_FIFO_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MIER_FIFO_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MIER_FIFO_MB13 = 0x2000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB13_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB13_1 = 0x1
	// Position of MB12 field.
	CAN0_MIER_FIFO_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MIER_FIFO_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MIER_FIFO_MB12 = 0x1000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB12_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB12_1 = 0x1
	// Position of MB11 field.
	CAN0_MIER_FIFO_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MIER_FIFO_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MIER_FIFO_MB11 = 0x800
	// Interrupt disabled
	CAN0_MIER_FIFO_MB11_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB11_1 = 0x1
	// Position of MB10 field.
	CAN0_MIER_FIFO_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MIER_FIFO_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MIER_FIFO_MB10 = 0x400
	// Interrupt disabled
	CAN0_MIER_FIFO_MB10_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB10_1 = 0x1
	// Position of MB9 field.
	CAN0_MIER_FIFO_MB9_Pos = 0x9
	// Bit mask of MB9 field.
	CAN0_MIER_FIFO_MB9_Msk = 0x200
	// Bit MB9.
	CAN0_MIER_FIFO_MB9 = 0x200
	// Interrupt disabled
	CAN0_MIER_FIFO_MB9_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB9_1 = 0x1
	// Position of MB8 field.
	CAN0_MIER_FIFO_MB8_Pos = 0x8
	// Bit mask of MB8 field.
	CAN0_MIER_FIFO_MB8_Msk = 0x100
	// Bit MB8.
	CAN0_MIER_FIFO_MB8 = 0x100
	// Interrupt disabled
	CAN0_MIER_FIFO_MB8_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB8_1 = 0x1
	// Position of MB7 field.
	CAN0_MIER_FIFO_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN0_MIER_FIFO_MB7_Msk = 0x80
	// Bit MB7.
	CAN0_MIER_FIFO_MB7 = 0x80
	// Interrupt disabled
	CAN0_MIER_FIFO_MB7_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB7_1 = 0x1
	// Position of MB6 field.
	CAN0_MIER_FIFO_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN0_MIER_FIFO_MB6_Msk = 0x40
	// Bit MB6.
	CAN0_MIER_FIFO_MB6 = 0x40
	// Interrupt disabled
	CAN0_MIER_FIFO_MB6_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB6_1 = 0x1
	// Position of MB5 field.
	CAN0_MIER_FIFO_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN0_MIER_FIFO_MB5_Msk = 0x20
	// Bit MB5.
	CAN0_MIER_FIFO_MB5 = 0x20
	// Interrupt disabled
	CAN0_MIER_FIFO_MB5_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB5_1 = 0x1
	// Position of MB4 field.
	CAN0_MIER_FIFO_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN0_MIER_FIFO_MB4_Msk = 0x10
	// Bit MB4.
	CAN0_MIER_FIFO_MB4 = 0x10
	// Interrupt disabled
	CAN0_MIER_FIFO_MB4_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB4_1 = 0x1
	// Position of MB3 field.
	CAN0_MIER_FIFO_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN0_MIER_FIFO_MB3_Msk = 0x8
	// Bit MB3.
	CAN0_MIER_FIFO_MB3 = 0x8
	// Interrupt disabled
	CAN0_MIER_FIFO_MB3_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB3_1 = 0x1
	// Position of MB2 field.
	CAN0_MIER_FIFO_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN0_MIER_FIFO_MB2_Msk = 0x4
	// Bit MB2.
	CAN0_MIER_FIFO_MB2 = 0x4
	// Interrupt disabled
	CAN0_MIER_FIFO_MB2_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB2_1 = 0x1
	// Position of MB1 field.
	CAN0_MIER_FIFO_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN0_MIER_FIFO_MB1_Msk = 0x2
	// Bit MB1.
	CAN0_MIER_FIFO_MB1 = 0x2
	// Interrupt disabled
	CAN0_MIER_FIFO_MB1_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB1_1 = 0x1
	// Position of MB0 field.
	CAN0_MIER_FIFO_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN0_MIER_FIFO_MB0_Msk = 0x1
	// Bit MB0.
	CAN0_MIER_FIFO_MB0 = 0x1
	// Interrupt disabled
	CAN0_MIER_FIFO_MB0_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB0_1 = 0x1

	// MCTL_TX: Message Control Register for Transmit
	// Position of TRMREQ field.
	CAN0_MCTL_TX_TRMREQ_Pos = 0x7
	// Bit mask of TRMREQ field.
	CAN0_MCTL_TX_TRMREQ_Msk = 0x80
	// Bit TRMREQ.
	CAN0_MCTL_TX_TRMREQ = 0x80
	// Not configured for transmission
	CAN0_MCTL_TX_TRMREQ_0 = 0x0
	// Configured for transmission
	CAN0_MCTL_TX_TRMREQ_1 = 0x1
	// Position of RECREQ field.
	CAN0_MCTL_TX_RECREQ_Pos = 0x6
	// Bit mask of RECREQ field.
	CAN0_MCTL_TX_RECREQ_Msk = 0x40
	// Bit RECREQ.
	CAN0_MCTL_TX_RECREQ = 0x40
	// Not configured for reception
	CAN0_MCTL_TX_RECREQ_0 = 0x0
	// Configured for reception
	CAN0_MCTL_TX_RECREQ_1 = 0x1
	// Position of Reserved field.
	CAN0_MCTL_TX_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	CAN0_MCTL_TX_Reserved_Msk = 0x20
	// Bit Reserved.
	CAN0_MCTL_TX_Reserved = 0x20
	// Position of ONESHOT field.
	CAN0_MCTL_TX_ONESHOT_Pos = 0x4
	// Bit mask of ONESHOT field.
	CAN0_MCTL_TX_ONESHOT_Msk = 0x10
	// Bit ONESHOT.
	CAN0_MCTL_TX_ONESHOT = 0x10
	// One-shot reception or one-shot transmission disabled
	CAN0_MCTL_TX_ONESHOT_0 = 0x0
	// One-shot reception or one-shot transmission enabled
	CAN0_MCTL_TX_ONESHOT_1 = 0x1
	// Position of Reserved field.
	CAN0_MCTL_TX_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	CAN0_MCTL_TX_Reserved_Msk = 0x8
	// Bit Reserved.
	CAN0_MCTL_TX_Reserved = 0x8
	// Position of TRMABT field.
	CAN0_MCTL_TX_TRMABT_Pos = 0x2
	// Bit mask of TRMABT field.
	CAN0_MCTL_TX_TRMABT_Msk = 0x4
	// Bit TRMABT.
	CAN0_MCTL_TX_TRMABT = 0x4
	// Transmission has started, transmission abort failed because transmission is completed, or transmission abort is not requested
	CAN0_MCTL_TX_TRMABT_0 = 0x0
	// Transmission abort is completed
	CAN0_MCTL_TX_TRMABT_1 = 0x1
	// Position of TRMACTIVE field.
	CAN0_MCTL_TX_TRMACTIVE_Pos = 0x1
	// Bit mask of TRMACTIVE field.
	CAN0_MCTL_TX_TRMACTIVE_Msk = 0x2
	// Bit TRMACTIVE.
	CAN0_MCTL_TX_TRMACTIVE = 0x2
	// Transmission is pending or transmission is not requested
	CAN0_MCTL_TX_TRMACTIVE_0 = 0x0
	// From acceptance of transmission request to completion of transmission, or error/arbitration-lost
	CAN0_MCTL_TX_TRMACTIVE_1 = 0x1
	// Position of SENTDATA field.
	CAN0_MCTL_TX_SENTDATA_Pos = 0x0
	// Bit mask of SENTDATA field.
	CAN0_MCTL_TX_SENTDATA_Msk = 0x1
	// Bit SENTDATA.
	CAN0_MCTL_TX_SENTDATA = 0x1
	// Transmission is not completed
	CAN0_MCTL_TX_SENTDATA_0 = 0x0
	// Transmission is completed
	CAN0_MCTL_TX_SENTDATA_1 = 0x1

	// MCTL_RX: Message Control Register for Receive
	// Position of TRMREQ field.
	CAN0_MCTL_RX_TRMREQ_Pos = 0x7
	// Bit mask of TRMREQ field.
	CAN0_MCTL_RX_TRMREQ_Msk = 0x80
	// Bit TRMREQ.
	CAN0_MCTL_RX_TRMREQ = 0x80
	// Not configured for transmission
	CAN0_MCTL_RX_TRMREQ_0 = 0x0
	// Configured for transmission
	CAN0_MCTL_RX_TRMREQ_1 = 0x1
	// Position of RECREQ field.
	CAN0_MCTL_RX_RECREQ_Pos = 0x6
	// Bit mask of RECREQ field.
	CAN0_MCTL_RX_RECREQ_Msk = 0x40
	// Bit RECREQ.
	CAN0_MCTL_RX_RECREQ = 0x40
	// Not configured for reception
	CAN0_MCTL_RX_RECREQ_0 = 0x0
	// Configured for reception
	CAN0_MCTL_RX_RECREQ_1 = 0x1
	// Position of Reserved field.
	CAN0_MCTL_RX_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	CAN0_MCTL_RX_Reserved_Msk = 0x20
	// Bit Reserved.
	CAN0_MCTL_RX_Reserved = 0x20
	// Position of ONESHOT field.
	CAN0_MCTL_RX_ONESHOT_Pos = 0x4
	// Bit mask of ONESHOT field.
	CAN0_MCTL_RX_ONESHOT_Msk = 0x10
	// Bit ONESHOT.
	CAN0_MCTL_RX_ONESHOT = 0x10
	// One-shot reception or one-shot transmission disabled
	CAN0_MCTL_RX_ONESHOT_0 = 0x0
	// One-shot reception or one-shot transmission enabled
	CAN0_MCTL_RX_ONESHOT_1 = 0x1
	// Position of Reserved field.
	CAN0_MCTL_RX_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	CAN0_MCTL_RX_Reserved_Msk = 0x8
	// Bit Reserved.
	CAN0_MCTL_RX_Reserved = 0x8
	// Position of MSGLOST field.
	CAN0_MCTL_RX_MSGLOST_Pos = 0x2
	// Bit mask of MSGLOST field.
	CAN0_MCTL_RX_MSGLOST_Msk = 0x4
	// Bit MSGLOST.
	CAN0_MCTL_RX_MSGLOST = 0x4
	// Message is not overwritten or overrun
	CAN0_MCTL_RX_MSGLOST_0 = 0x0
	// Message is overwritten or overrun
	CAN0_MCTL_RX_MSGLOST_1 = 0x1
	// Position of INVALDATA field.
	CAN0_MCTL_RX_INVALDATA_Pos = 0x1
	// Bit mask of INVALDATA field.
	CAN0_MCTL_RX_INVALDATA_Msk = 0x2
	// Bit INVALDATA.
	CAN0_MCTL_RX_INVALDATA = 0x2
	// Message valid
	CAN0_MCTL_RX_INVALDATA_0 = 0x0
	// Message being updated
	CAN0_MCTL_RX_INVALDATA_1 = 0x1
	// Position of NEWDATA field.
	CAN0_MCTL_RX_NEWDATA_Pos = 0x0
	// Bit mask of NEWDATA field.
	CAN0_MCTL_RX_NEWDATA_Msk = 0x1
	// Bit NEWDATA.
	CAN0_MCTL_RX_NEWDATA = 0x1
	// No data has been received or 0 is written to the NEWDATA bit
	CAN0_MCTL_RX_NEWDATA_0 = 0x0
	// A new message is being stored or has been stored to the mailbox
	CAN0_MCTL_RX_NEWDATA_1 = 0x1

	// CTLR: Control Register
	// Position of Reserved field.
	CAN0_CTLR_Reserved_Pos = 0xe
	// Bit mask of Reserved field.
	CAN0_CTLR_Reserved_Msk = 0xc000
	// Position of RBOC field.
	CAN0_CTLR_RBOC_Pos = 0xd
	// Bit mask of RBOC field.
	CAN0_CTLR_RBOC_Msk = 0x2000
	// Bit RBOC.
	CAN0_CTLR_RBOC = 0x2000
	// Nothing occurred
	CAN0_CTLR_RBOC_0 = 0x0
	// Forcible return from bus-off
	CAN0_CTLR_RBOC_1 = 0x1
	// Position of BOM field.
	CAN0_CTLR_BOM_Pos = 0xb
	// Bit mask of BOM field.
	CAN0_CTLR_BOM_Msk = 0x1800
	// Normal mode (ISO11898-1 compliant)
	CAN0_CTLR_BOM_00 = 0x0
	// Entry to CAN halt mode automatically at bus-off entry
	CAN0_CTLR_BOM_01 = 0x1
	// Entry to CAN halt mode automatically at bus-off end
	CAN0_CTLR_BOM_10 = 0x2
	// Entry to CAN halt mode (during bus-off recovery period)
	CAN0_CTLR_BOM_11 = 0x3
	// Position of SLPM field.
	CAN0_CTLR_SLPM_Pos = 0xa
	// Bit mask of SLPM field.
	CAN0_CTLR_SLPM_Msk = 0x400
	// Bit SLPM.
	CAN0_CTLR_SLPM = 0x400
	// Other than CAN sleep mode
	CAN0_CTLR_SLPM_0 = 0x0
	// CAN sleep mode
	CAN0_CTLR_SLPM_1 = 0x1
	// Position of CANM field.
	CAN0_CTLR_CANM_Pos = 0x8
	// Bit mask of CANM field.
	CAN0_CTLR_CANM_Msk = 0x300
	// CAN operation mode
	CAN0_CTLR_CANM_00 = 0x0
	// CAN reset mode
	CAN0_CTLR_CANM_01 = 0x1
	// CAN halt mode
	CAN0_CTLR_CANM_10 = 0x2
	// CAN reset mode (forcible transition)
	CAN0_CTLR_CANM_11 = 0x3
	// Position of TSPS field.
	CAN0_CTLR_TSPS_Pos = 0x6
	// Bit mask of TSPS field.
	CAN0_CTLR_TSPS_Msk = 0xc0
	// Every bit time
	CAN0_CTLR_TSPS_00 = 0x0
	// Every 2-bit time
	CAN0_CTLR_TSPS_01 = 0x1
	// Every 4-bit time
	CAN0_CTLR_TSPS_10 = 0x2
	// Every 8-bit time
	CAN0_CTLR_TSPS_11 = 0x3
	// Position of TSRC field.
	CAN0_CTLR_TSRC_Pos = 0x5
	// Bit mask of TSRC field.
	CAN0_CTLR_TSRC_Msk = 0x20
	// Bit TSRC.
	CAN0_CTLR_TSRC = 0x20
	// Nothing occurred
	CAN0_CTLR_TSRC_0 = 0x0
	// Reset
	CAN0_CTLR_TSRC_1 = 0x1
	// Position of TPM field.
	CAN0_CTLR_TPM_Pos = 0x4
	// Bit mask of TPM field.
	CAN0_CTLR_TPM_Msk = 0x10
	// Bit TPM.
	CAN0_CTLR_TPM = 0x10
	// ID priority transmit mode
	CAN0_CTLR_TPM_0 = 0x0
	// Mailbox number priority transmit mode
	CAN0_CTLR_TPM_1 = 0x1
	// Position of MLM field.
	CAN0_CTLR_MLM_Pos = 0x3
	// Bit mask of MLM field.
	CAN0_CTLR_MLM_Msk = 0x8
	// Bit MLM.
	CAN0_CTLR_MLM = 0x8
	// Overwrite mode
	CAN0_CTLR_MLM_0 = 0x0
	// Overrun mode
	CAN0_CTLR_MLM_1 = 0x1
	// Position of IDFM field.
	CAN0_CTLR_IDFM_Pos = 0x1
	// Bit mask of IDFM field.
	CAN0_CTLR_IDFM_Msk = 0x6
	// Standard ID mode.All mailboxes (including FIFO mailboxes) handle only standard Ids.
	CAN0_CTLR_IDFM_00 = 0x0
	// Extended ID mode.All mailboxes (including FIFO mailboxes) handle only extended IDs.
	CAN0_CTLR_IDFM_01 = 0x1
	// Mixed ID mode.All mailboxes (including FIFO mailboxes) handle both standard IDs and extended IDs. Standard IDs or extended IDs are specified by using the IDE bit in the corresponding mailbox in normal mailbox mode. In FIFO mailbox mode, the IDE bit in the corresponding mailbox is used for mailboxes [0] to [23], the IDE bits in FIDCR0 and FIDCR1 are used for the receive FIFO, and the IDE bit in mailbox [24] is used for the transmit FIFO.
	CAN0_CTLR_IDFM_10 = 0x2
	// Do not use this combination
	CAN0_CTLR_IDFM_11 = 0x3
	// Position of MBM field.
	CAN0_CTLR_MBM_Pos = 0x0
	// Bit mask of MBM field.
	CAN0_CTLR_MBM_Msk = 0x1
	// Bit MBM.
	CAN0_CTLR_MBM = 0x1
	// Normal mailbox mode
	CAN0_CTLR_MBM_0 = 0x0
	// FIFO mailbox mode
	CAN0_CTLR_MBM_1 = 0x1

	// STR: Status Register
	// Position of Reserved field.
	CAN0_STR_Reserved_Pos = 0xf
	// Bit mask of Reserved field.
	CAN0_STR_Reserved_Msk = 0x8000
	// Bit Reserved.
	CAN0_STR_Reserved = 0x8000
	// Position of RECST field.
	CAN0_STR_RECST_Pos = 0xe
	// Bit mask of RECST field.
	CAN0_STR_RECST_Msk = 0x4000
	// Bit RECST.
	CAN0_STR_RECST = 0x4000
	// Bus idle or transmission in progress
	CAN0_STR_RECST_0 = 0x0
	// Reception in progress
	CAN0_STR_RECST_1 = 0x1
	// Position of TRMST field.
	CAN0_STR_TRMST_Pos = 0xd
	// Bit mask of TRMST field.
	CAN0_STR_TRMST_Msk = 0x2000
	// Bit TRMST.
	CAN0_STR_TRMST = 0x2000
	// Bus idle or reception in progress
	CAN0_STR_TRMST_0 = 0x0
	// Transmission in progress or in bus-off state
	CAN0_STR_TRMST_1 = 0x1
	// Position of BOST field.
	CAN0_STR_BOST_Pos = 0xc
	// Bit mask of BOST field.
	CAN0_STR_BOST_Msk = 0x1000
	// Bit BOST.
	CAN0_STR_BOST = 0x1000
	// Not in bus-off state
	CAN0_STR_BOST_0 = 0x0
	// In bus-off state
	CAN0_STR_BOST_1 = 0x1
	// Position of EPST field.
	CAN0_STR_EPST_Pos = 0xb
	// Bit mask of EPST field.
	CAN0_STR_EPST_Msk = 0x800
	// Bit EPST.
	CAN0_STR_EPST = 0x800
	// Not in error-passive state
	CAN0_STR_EPST_0 = 0x0
	// In error-passive state
	CAN0_STR_EPST_1 = 0x1
	// Position of SLPST field.
	CAN0_STR_SLPST_Pos = 0xa
	// Bit mask of SLPST field.
	CAN0_STR_SLPST_Msk = 0x400
	// Bit SLPST.
	CAN0_STR_SLPST = 0x400
	// Not in CAN sleep mode
	CAN0_STR_SLPST_0 = 0x0
	// In CAN sleep mode
	CAN0_STR_SLPST_1 = 0x1
	// Position of HLTST field.
	CAN0_STR_HLTST_Pos = 0x9
	// Bit mask of HLTST field.
	CAN0_STR_HLTST_Msk = 0x200
	// Bit HLTST.
	CAN0_STR_HLTST = 0x200
	// Not in CAN halt mode
	CAN0_STR_HLTST_0 = 0x0
	// In CAN halt mode
	CAN0_STR_HLTST_1 = 0x1
	// Position of RSTST field.
	CAN0_STR_RSTST_Pos = 0x8
	// Bit mask of RSTST field.
	CAN0_STR_RSTST_Msk = 0x100
	// Bit RSTST.
	CAN0_STR_RSTST = 0x100
	// Not in CAN reset mode
	CAN0_STR_RSTST_0 = 0x0
	// In CAN reset mode
	CAN0_STR_RSTST_1 = 0x1
	// Position of EST field.
	CAN0_STR_EST_Pos = 0x7
	// Bit mask of EST field.
	CAN0_STR_EST_Msk = 0x80
	// Bit EST.
	CAN0_STR_EST = 0x80
	// No error occurred
	CAN0_STR_EST_0 = 0x0
	// Error occurred
	CAN0_STR_EST_1 = 0x1
	// Position of TABST field.
	CAN0_STR_TABST_Pos = 0x6
	// Bit mask of TABST field.
	CAN0_STR_TABST_Msk = 0x40
	// Bit TABST.
	CAN0_STR_TABST = 0x40
	// No mailbox with TRMABT bit = 1
	CAN0_STR_TABST_0 = 0x0
	// Mailbox(es) with TRMABT bit = 1
	CAN0_STR_TABST_1 = 0x1
	// Position of FMLST field.
	CAN0_STR_FMLST_Pos = 0x5
	// Bit mask of FMLST field.
	CAN0_STR_FMLST_Msk = 0x20
	// Bit FMLST.
	CAN0_STR_FMLST = 0x20
	// RFMLF bit = 0
	CAN0_STR_FMLST_0 = 0x0
	// RFMLF bit = 1
	CAN0_STR_FMLST_1 = 0x1
	// Position of NMLST field.
	CAN0_STR_NMLST_Pos = 0x4
	// Bit mask of NMLST field.
	CAN0_STR_NMLST_Msk = 0x10
	// Bit NMLST.
	CAN0_STR_NMLST = 0x10
	// No mailbox with MSGLOST bit = 1
	CAN0_STR_NMLST_0 = 0x0
	// Mailbox(es) with MSGLOST bit = 1
	CAN0_STR_NMLST_1 = 0x1
	// Position of TFST field.
	CAN0_STR_TFST_Pos = 0x3
	// Bit mask of TFST field.
	CAN0_STR_TFST_Msk = 0x8
	// Bit TFST.
	CAN0_STR_TFST = 0x8
	// Transmit FIFO is full
	CAN0_STR_TFST_0 = 0x0
	// Transmit FIFO is not full
	CAN0_STR_TFST_1 = 0x1
	// Position of RFST field.
	CAN0_STR_RFST_Pos = 0x2
	// Bit mask of RFST field.
	CAN0_STR_RFST_Msk = 0x4
	// Bit RFST.
	CAN0_STR_RFST = 0x4
	// No message in receive FIFO (empty)
	CAN0_STR_RFST_0 = 0x0
	// Message in receive FIFO
	CAN0_STR_RFST_1 = 0x1
	// Position of SDST field.
	CAN0_STR_SDST_Pos = 0x1
	// Bit mask of SDST field.
	CAN0_STR_SDST_Msk = 0x2
	// Bit SDST.
	CAN0_STR_SDST = 0x2
	// No mailbox with SENTDATA bit = 1
	CAN0_STR_SDST_0 = 0x0
	// Mailbox(es) with SENTDATA bit = 1
	CAN0_STR_SDST_1 = 0x1
	// Position of NDST field.
	CAN0_STR_NDST_Pos = 0x0
	// Bit mask of NDST field.
	CAN0_STR_NDST_Msk = 0x1
	// Bit NDST.
	CAN0_STR_NDST = 0x1
	// No mailbox with NEWDATA bit = 1
	CAN0_STR_NDST_0 = 0x0
	// Mailbox(es) with NEWDATA bit = 1
	CAN0_STR_NDST_1 = 0x1

	// BCR: Bit Configuration Register
	// Position of TSEG1 field.
	CAN0_BCR_TSEG1_Pos = 0x1c
	// Bit mask of TSEG1 field.
	CAN0_BCR_TSEG1_Msk = 0xf0000000
	// 4 Tq
	CAN0_BCR_TSEG1_0011 = 0x3
	// 5 Tq
	CAN0_BCR_TSEG1_0100 = 0x4
	// 6 Tq
	CAN0_BCR_TSEG1_0101 = 0x5
	// 7 Tq
	CAN0_BCR_TSEG1_0110 = 0x6
	// 8 Tq
	CAN0_BCR_TSEG1_0111 = 0x7
	// 9 Tq
	CAN0_BCR_TSEG1_1000 = 0x8
	// 10 Tq
	CAN0_BCR_TSEG1_1001 = 0x9
	// 11 Tq
	CAN0_BCR_TSEG1_1010 = 0xa
	// 12 Tq
	CAN0_BCR_TSEG1_1011 = 0xb
	// 13 Tq
	CAN0_BCR_TSEG1_1100 = 0xc
	// 14 Tq
	CAN0_BCR_TSEG1_1101 = 0xd
	// 15 Tq
	CAN0_BCR_TSEG1_1110 = 0xe
	// 16 Tq
	CAN0_BCR_TSEG1_1111 = 0xf
	// Position of Reserved field.
	CAN0_BCR_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	CAN0_BCR_Reserved_Msk = 0xc000000
	// Position of BRP field.
	CAN0_BCR_BRP_Pos = 0x10
	// Bit mask of BRP field.
	CAN0_BCR_BRP_Msk = 0x3ff0000
	// Position of Reserved field.
	CAN0_BCR_Reserved_Pos = 0xe
	// Bit mask of Reserved field.
	CAN0_BCR_Reserved_Msk = 0xc000
	// Position of SJW field.
	CAN0_BCR_SJW_Pos = 0xc
	// Bit mask of SJW field.
	CAN0_BCR_SJW_Msk = 0x3000
	// 1 Tq
	CAN0_BCR_SJW_00 = 0x0
	// 2 Tq
	CAN0_BCR_SJW_01 = 0x1
	// 3 Tq
	CAN0_BCR_SJW_10 = 0x2
	// 4 Tq
	CAN0_BCR_SJW_11 = 0x3
	// Position of Reserved field.
	CAN0_BCR_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	CAN0_BCR_Reserved_Msk = 0x800
	// Bit Reserved.
	CAN0_BCR_Reserved = 0x800
	// Position of TSEG2 field.
	CAN0_BCR_TSEG2_Pos = 0x8
	// Bit mask of TSEG2 field.
	CAN0_BCR_TSEG2_Msk = 0x700
	// Setting prohibited
	CAN0_BCR_TSEG2_000 = 0x0
	// 2 Tq
	CAN0_BCR_TSEG2_001 = 0x1
	// 3 Tq
	CAN0_BCR_TSEG2_010 = 0x2
	// 4 Tq
	CAN0_BCR_TSEG2_011 = 0x3
	// 5 Tq
	CAN0_BCR_TSEG2_100 = 0x4
	// 6 Tq
	CAN0_BCR_TSEG2_101 = 0x5
	// 7 Tq
	CAN0_BCR_TSEG2_110 = 0x6
	// 8 Tq
	CAN0_BCR_TSEG2_111 = 0x7
	// Position of Reserved field.
	CAN0_BCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	CAN0_BCR_Reserved_Msk = 0xfe
	// Position of CCLKS field.
	CAN0_BCR_CCLKS_Pos = 0x0
	// Bit mask of CCLKS field.
	CAN0_BCR_CCLKS_Msk = 0x1
	// Bit CCLKS.
	CAN0_BCR_CCLKS = 0x1
	// PCLK (generated by the PLL clock)
	CAN0_BCR_CCLKS_0 = 0x0
	// CANMCLK (generated by the main clock)
	CAN0_BCR_CCLKS_1 = 0x1

	// RFCR: Receive FIFO Control Register
	// Position of RFEST field.
	CAN0_RFCR_RFEST_Pos = 0x7
	// Bit mask of RFEST field.
	CAN0_RFCR_RFEST_Msk = 0x80
	// Bit RFEST.
	CAN0_RFCR_RFEST = 0x80
	// Unread message in receive FIFO
	CAN0_RFCR_RFEST_0 = 0x0
	// No unread message in receive FIFO
	CAN0_RFCR_RFEST_1 = 0x1
	// Position of RFWST field.
	CAN0_RFCR_RFWST_Pos = 0x6
	// Bit mask of RFWST field.
	CAN0_RFCR_RFWST_Msk = 0x40
	// Bit RFWST.
	CAN0_RFCR_RFWST = 0x40
	// Receive FIFO is not buffer warning
	CAN0_RFCR_RFWST_0 = 0x0
	// Receive FIFO is buffer warning (3 unread messages)
	CAN0_RFCR_RFWST_1 = 0x1
	// Position of RFFST field.
	CAN0_RFCR_RFFST_Pos = 0x5
	// Bit mask of RFFST field.
	CAN0_RFCR_RFFST_Msk = 0x20
	// Bit RFFST.
	CAN0_RFCR_RFFST = 0x20
	// Receive FIFO is not full
	CAN0_RFCR_RFFST_0 = 0x0
	// Receive FIFO is full (4 unread messages)
	CAN0_RFCR_RFFST_1 = 0x1
	// Position of RFMLF field.
	CAN0_RFCR_RFMLF_Pos = 0x4
	// Bit mask of RFMLF field.
	CAN0_RFCR_RFMLF_Msk = 0x10
	// Bit RFMLF.
	CAN0_RFCR_RFMLF = 0x10
	// No receive FIFO message lost has occurred
	CAN0_RFCR_RFMLF_0 = 0x0
	// Receive FIFO message lost has occurred
	CAN0_RFCR_RFMLF_1 = 0x1
	// Position of RFUST field.
	CAN0_RFCR_RFUST_Pos = 0x1
	// Bit mask of RFUST field.
	CAN0_RFCR_RFUST_Msk = 0xe
	// No unread message
	CAN0_RFCR_RFUST_000 = 0x0
	// 1 unread message
	CAN0_RFCR_RFUST_001 = 0x1
	// 2 unread messages
	CAN0_RFCR_RFUST_010 = 0x2
	// 3 unread messages
	CAN0_RFCR_RFUST_011 = 0x3
	// 4 unread messages
	CAN0_RFCR_RFUST_100 = 0x4
	// Position of RFE field.
	CAN0_RFCR_RFE_Pos = 0x0
	// Bit mask of RFE field.
	CAN0_RFCR_RFE_Msk = 0x1
	// Bit RFE.
	CAN0_RFCR_RFE = 0x1
	// Receive FIFO disabled
	CAN0_RFCR_RFE_0 = 0x0
	// Receive FIFO enabled
	CAN0_RFCR_RFE_1 = 0x1

	// RFPCR: Receive FIFO Pointer Control Register
	// Position of RFPCR field.
	CAN0_RFPCR_RFPCR_Pos = 0x0
	// Bit mask of RFPCR field.
	CAN0_RFPCR_RFPCR_Msk = 0xff

	// TFCR: Transmit FIFO Control Register
	// Position of TFEST field.
	CAN0_TFCR_TFEST_Pos = 0x7
	// Bit mask of TFEST field.
	CAN0_TFCR_TFEST_Msk = 0x80
	// Bit TFEST.
	CAN0_TFCR_TFEST = 0x80
	// Unsent message in transmit FIFO
	CAN0_TFCR_TFEST_0 = 0x0
	// No unsent message in transmit FIFO
	CAN0_TFCR_TFEST_1 = 0x1
	// Position of TFFST field.
	CAN0_TFCR_TFFST_Pos = 0x6
	// Bit mask of TFFST field.
	CAN0_TFCR_TFFST_Msk = 0x40
	// Bit TFFST.
	CAN0_TFCR_TFFST = 0x40
	// Transmit FIFO is not full
	CAN0_TFCR_TFFST_0 = 0x0
	// Transmit FIFO is full (4 unsent messages)
	CAN0_TFCR_TFFST_1 = 0x1
	// Position of Reserved field.
	CAN0_TFCR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	CAN0_TFCR_Reserved_Msk = 0x30
	// Position of TFUST field.
	CAN0_TFCR_TFUST_Pos = 0x1
	// Bit mask of TFUST field.
	CAN0_TFCR_TFUST_Msk = 0xe
	// No unsent message
	CAN0_TFCR_TFUST_000 = 0x0
	// 1 unsent message
	CAN0_TFCR_TFUST_001 = 0x1
	// 2 unsent messages
	CAN0_TFCR_TFUST_010 = 0x2
	// 3 unsent messages
	CAN0_TFCR_TFUST_011 = 0x3
	// 4 unsent messages
	CAN0_TFCR_TFUST_100 = 0x4
	// Position of TFE field.
	CAN0_TFCR_TFE_Pos = 0x0
	// Bit mask of TFE field.
	CAN0_TFCR_TFE_Msk = 0x1
	// Bit TFE.
	CAN0_TFCR_TFE = 0x1
	// Transmit FIFO disabled
	CAN0_TFCR_TFE_0 = 0x0
	// Transmit FIFO enabled
	CAN0_TFCR_TFE_1 = 0x1

	// TFPCR: Transmit FIFO Pointer Control Register
	// Position of TFPCR field.
	CAN0_TFPCR_TFPCR_Pos = 0x0
	// Bit mask of TFPCR field.
	CAN0_TFPCR_TFPCR_Msk = 0xff

	// EIER: Error Interrupt Enable Register
	// Position of BLIE field.
	CAN0_EIER_BLIE_Pos = 0x7
	// Bit mask of BLIE field.
	CAN0_EIER_BLIE_Msk = 0x80
	// Bit BLIE.
	CAN0_EIER_BLIE = 0x80
	// Bus lock interrupt disabled
	CAN0_EIER_BLIE_0 = 0x0
	// Bus lock interrupt enabled
	CAN0_EIER_BLIE_1 = 0x1
	// Position of OLIE field.
	CAN0_EIER_OLIE_Pos = 0x6
	// Bit mask of OLIE field.
	CAN0_EIER_OLIE_Msk = 0x40
	// Bit OLIE.
	CAN0_EIER_OLIE = 0x40
	// Overload frame transmit interrupt disabled
	CAN0_EIER_OLIE_0 = 0x0
	// Overload frame transmit interrupt enabled
	CAN0_EIER_OLIE_1 = 0x1
	// Position of ORIE field.
	CAN0_EIER_ORIE_Pos = 0x5
	// Bit mask of ORIE field.
	CAN0_EIER_ORIE_Msk = 0x20
	// Bit ORIE.
	CAN0_EIER_ORIE = 0x20
	// Receive overrun interrupt disabled
	CAN0_EIER_ORIE_0 = 0x0
	// Receive overrun interrupt enabled
	CAN0_EIER_ORIE_1 = 0x1
	// Position of BORIE field.
	CAN0_EIER_BORIE_Pos = 0x4
	// Bit mask of BORIE field.
	CAN0_EIER_BORIE_Msk = 0x10
	// Bit BORIE.
	CAN0_EIER_BORIE = 0x10
	// Bus-off recovery interrupt disabled
	CAN0_EIER_BORIE_0 = 0x0
	// Bus-off recovery interrupt enabled
	CAN0_EIER_BORIE_1 = 0x1
	// Position of BOEIE field.
	CAN0_EIER_BOEIE_Pos = 0x3
	// Bit mask of BOEIE field.
	CAN0_EIER_BOEIE_Msk = 0x8
	// Bit BOEIE.
	CAN0_EIER_BOEIE = 0x8
	// Bus-off entry interrupt disabled
	CAN0_EIER_BOEIE_0 = 0x0
	// Bus-off entry interrupt enabled
	CAN0_EIER_BOEIE_1 = 0x1
	// Position of EPIE field.
	CAN0_EIER_EPIE_Pos = 0x2
	// Bit mask of EPIE field.
	CAN0_EIER_EPIE_Msk = 0x4
	// Bit EPIE.
	CAN0_EIER_EPIE = 0x4
	// Error-passive interrupt disabled
	CAN0_EIER_EPIE_0 = 0x0
	// Error-passive interrupt enabled
	CAN0_EIER_EPIE_1 = 0x1
	// Position of EWIE field.
	CAN0_EIER_EWIE_Pos = 0x1
	// Bit mask of EWIE field.
	CAN0_EIER_EWIE_Msk = 0x2
	// Bit EWIE.
	CAN0_EIER_EWIE = 0x2
	// Error-warning interrupt disabled
	CAN0_EIER_EWIE_0 = 0x0
	// Error-warning interrupt enabled
	CAN0_EIER_EWIE_1 = 0x1
	// Position of BEIE field.
	CAN0_EIER_BEIE_Pos = 0x0
	// Bit mask of BEIE field.
	CAN0_EIER_BEIE_Msk = 0x1
	// Bit BEIE.
	CAN0_EIER_BEIE = 0x1
	// Bus error interrupt disabled
	CAN0_EIER_BEIE_0 = 0x0
	// Bus error interrupt enabled
	CAN0_EIER_BEIE_1 = 0x1

	// EIFR: Error Interrupt Factor Judge Register
	// Position of BLIF field.
	CAN0_EIFR_BLIF_Pos = 0x7
	// Bit mask of BLIF field.
	CAN0_EIFR_BLIF_Msk = 0x80
	// Bit BLIF.
	CAN0_EIFR_BLIF = 0x80
	// No bus lock detected
	CAN0_EIFR_BLIF_0 = 0x0
	// Bus lock detected
	CAN0_EIFR_BLIF_1 = 0x1
	// Position of OLIF field.
	CAN0_EIFR_OLIF_Pos = 0x6
	// Bit mask of OLIF field.
	CAN0_EIFR_OLIF_Msk = 0x40
	// Bit OLIF.
	CAN0_EIFR_OLIF = 0x40
	// No overload frame transmission detected
	CAN0_EIFR_OLIF_0 = 0x0
	// Overload frame transmission detected
	CAN0_EIFR_OLIF_1 = 0x1
	// Position of ORIF field.
	CAN0_EIFR_ORIF_Pos = 0x5
	// Bit mask of ORIF field.
	CAN0_EIFR_ORIF_Msk = 0x20
	// Bit ORIF.
	CAN0_EIFR_ORIF = 0x20
	// No receive overrun detected
	CAN0_EIFR_ORIF_0 = 0x0
	// Receive overrun detected
	CAN0_EIFR_ORIF_1 = 0x1
	// Position of BORIF field.
	CAN0_EIFR_BORIF_Pos = 0x4
	// Bit mask of BORIF field.
	CAN0_EIFR_BORIF_Msk = 0x10
	// Bit BORIF.
	CAN0_EIFR_BORIF = 0x10
	// No bus-off recovery detected
	CAN0_EIFR_BORIF_0 = 0x0
	// Bus-off recovery detected
	CAN0_EIFR_BORIF_1 = 0x1
	// Position of BOEIF field.
	CAN0_EIFR_BOEIF_Pos = 0x3
	// Bit mask of BOEIF field.
	CAN0_EIFR_BOEIF_Msk = 0x8
	// Bit BOEIF.
	CAN0_EIFR_BOEIF = 0x8
	// No bus-off entry detected
	CAN0_EIFR_BOEIF_0 = 0x0
	// Bus-off entry detected
	CAN0_EIFR_BOEIF_1 = 0x1
	// Position of EPIF field.
	CAN0_EIFR_EPIF_Pos = 0x2
	// Bit mask of EPIF field.
	CAN0_EIFR_EPIF_Msk = 0x4
	// Bit EPIF.
	CAN0_EIFR_EPIF = 0x4
	// No error-passive detected
	CAN0_EIFR_EPIF_0 = 0x0
	// Error-passive detected
	CAN0_EIFR_EPIF_1 = 0x1
	// Position of EWIF field.
	CAN0_EIFR_EWIF_Pos = 0x1
	// Bit mask of EWIF field.
	CAN0_EIFR_EWIF_Msk = 0x2
	// Bit EWIF.
	CAN0_EIFR_EWIF = 0x2
	// No error-warning detected
	CAN0_EIFR_EWIF_0 = 0x0
	// Error-warning detected
	CAN0_EIFR_EWIF_1 = 0x1
	// Position of BEIF field.
	CAN0_EIFR_BEIF_Pos = 0x0
	// Bit mask of BEIF field.
	CAN0_EIFR_BEIF_Msk = 0x1
	// Bit BEIF.
	CAN0_EIFR_BEIF = 0x1
	// No bus error detected
	CAN0_EIFR_BEIF_0 = 0x0
	// Bus error detected
	CAN0_EIFR_BEIF_1 = 0x1

	// RECR: Receive Error Count Register
	// Position of RECR field.
	CAN0_RECR_RECR_Pos = 0x0
	// Bit mask of RECR field.
	CAN0_RECR_RECR_Msk = 0xff

	// TECR: Transmit Error Count Register
	// Position of TECR field.
	CAN0_TECR_TECR_Pos = 0x0
	// Bit mask of TECR field.
	CAN0_TECR_TECR_Msk = 0xff

	// ECSR: Error Code Store Register
	// Position of EDPM field.
	CAN0_ECSR_EDPM_Pos = 0x7
	// Bit mask of EDPM field.
	CAN0_ECSR_EDPM_Msk = 0x80
	// Bit EDPM.
	CAN0_ECSR_EDPM = 0x80
	// Output of first detected error code
	CAN0_ECSR_EDPM_0 = 0x0
	// Output of accumulated error code
	CAN0_ECSR_EDPM_1 = 0x1
	// Position of ADEF field.
	CAN0_ECSR_ADEF_Pos = 0x6
	// Bit mask of ADEF field.
	CAN0_ECSR_ADEF_Msk = 0x40
	// Bit ADEF.
	CAN0_ECSR_ADEF = 0x40
	// No ACK delimiter error detected
	CAN0_ECSR_ADEF_0 = 0x0
	// ACK delimiter error detected
	CAN0_ECSR_ADEF_1 = 0x1
	// Position of BE0F field.
	CAN0_ECSR_BE0F_Pos = 0x5
	// Bit mask of BE0F field.
	CAN0_ECSR_BE0F_Msk = 0x20
	// Bit BE0F.
	CAN0_ECSR_BE0F = 0x20
	// No bit error (dominant) detected
	CAN0_ECSR_BE0F_0 = 0x0
	// Bit error (dominant) detected
	CAN0_ECSR_BE0F_1 = 0x1
	// Position of BE1F field.
	CAN0_ECSR_BE1F_Pos = 0x4
	// Bit mask of BE1F field.
	CAN0_ECSR_BE1F_Msk = 0x10
	// Bit BE1F.
	CAN0_ECSR_BE1F = 0x10
	// No bit error (recessive) detected
	CAN0_ECSR_BE1F_0 = 0x0
	// Bit error (recessive) detected
	CAN0_ECSR_BE1F_1 = 0x1
	// Position of CEF field.
	CAN0_ECSR_CEF_Pos = 0x3
	// Bit mask of CEF field.
	CAN0_ECSR_CEF_Msk = 0x8
	// Bit CEF.
	CAN0_ECSR_CEF = 0x8
	// No CRC error detected
	CAN0_ECSR_CEF_0 = 0x0
	// CRC error detected
	CAN0_ECSR_CEF_1 = 0x1
	// Position of AEF field.
	CAN0_ECSR_AEF_Pos = 0x2
	// Bit mask of AEF field.
	CAN0_ECSR_AEF_Msk = 0x4
	// Bit AEF.
	CAN0_ECSR_AEF = 0x4
	// No ACK error detected
	CAN0_ECSR_AEF_0 = 0x0
	// ACK error detected
	CAN0_ECSR_AEF_1 = 0x1
	// Position of FEF field.
	CAN0_ECSR_FEF_Pos = 0x1
	// Bit mask of FEF field.
	CAN0_ECSR_FEF_Msk = 0x2
	// Bit FEF.
	CAN0_ECSR_FEF = 0x2
	// No form error detected
	CAN0_ECSR_FEF_0 = 0x0
	// Form error detected
	CAN0_ECSR_FEF_1 = 0x1
	// Position of SEF field.
	CAN0_ECSR_SEF_Pos = 0x0
	// Bit mask of SEF field.
	CAN0_ECSR_SEF_Msk = 0x1
	// Bit SEF.
	CAN0_ECSR_SEF = 0x1
	// No stuff error detected
	CAN0_ECSR_SEF_0 = 0x0
	// Stuff error detected
	CAN0_ECSR_SEF_1 = 0x1

	// CSSR: Channel Search Support Register
	// Position of CSSR field.
	CAN0_CSSR_CSSR_Pos = 0x0
	// Bit mask of CSSR field.
	CAN0_CSSR_CSSR_Msk = 0xff

	// MSSR: Mailbox Search Status Register
	// Position of SEST field.
	CAN0_MSSR_SEST_Pos = 0x7
	// Bit mask of SEST field.
	CAN0_MSSR_SEST_Msk = 0x80
	// Bit SEST.
	CAN0_MSSR_SEST = 0x80
	// Search result found
	CAN0_MSSR_SEST_0 = 0x0
	// No search result
	CAN0_MSSR_SEST_1 = 0x1
	// Position of Reserved field.
	CAN0_MSSR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	CAN0_MSSR_Reserved_Msk = 0x60
	// Position of MBNST field.
	CAN0_MSSR_MBNST_Pos = 0x0
	// Bit mask of MBNST field.
	CAN0_MSSR_MBNST_Msk = 0x1f

	// MSMR: Mailbox Search Mode Register
	// Position of Reserved field.
	CAN0_MSMR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	CAN0_MSMR_Reserved_Msk = 0xfc
	// Position of MBSM field.
	CAN0_MSMR_MBSM_Pos = 0x0
	// Bit mask of MBSM field.
	CAN0_MSMR_MBSM_Msk = 0x3
	// Receive mailbox search mode
	CAN0_MSMR_MBSM_00 = 0x0
	// Transmit mailbox search mode
	CAN0_MSMR_MBSM_01 = 0x1
	// Message lost search mode
	CAN0_MSMR_MBSM_10 = 0x2
	// Channel search mode
	CAN0_MSMR_MBSM_11 = 0x3

	// TSR: Time Stamp Register
	// Position of TSR field.
	CAN0_TSR_TSR_Pos = 0x0
	// Bit mask of TSR field.
	CAN0_TSR_TSR_Msk = 0xffff

	// AFSR: Acceptance Filter Support Register
	// Position of AFSR field.
	CAN0_AFSR_AFSR_Pos = 0x0
	// Bit mask of AFSR field.
	CAN0_AFSR_AFSR_Msk = 0xffff

	// TCR: Test Control Register
	// Position of Reserved field.
	CAN0_TCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	CAN0_TCR_Reserved_Msk = 0xf8
	// Position of TSTM field.
	CAN0_TCR_TSTM_Pos = 0x1
	// Bit mask of TSTM field.
	CAN0_TCR_TSTM_Msk = 0x6
	// Other than CAN test mode
	CAN0_TCR_TSTM_00 = 0x0
	// Listen-only mode
	CAN0_TCR_TSTM_01 = 0x1
	// Self-test mode 0 (external loopback)
	CAN0_TCR_TSTM_10 = 0x2
	// Self-test mode 1 (internal loopback)
	CAN0_TCR_TSTM_11 = 0x3
	// Position of TSTE field.
	CAN0_TCR_TSTE_Pos = 0x0
	// Bit mask of TSTE field.
	CAN0_TCR_TSTE_Msk = 0x1
	// Bit TSTE.
	CAN0_TCR_TSTE = 0x1
	// CAN test mode disabled
	CAN0_TCR_TSTE_0 = 0x0
	// CAN test mode enabled
	CAN0_TCR_TSTE_1 = 0x1
)

// Constants for WDT: Watchdog Timer
const (
	// WDTRR: WDT Refresh Register
	// Position of WDTRR field.
	WDT_WDTRR_WDTRR_Pos = 0x0
	// Bit mask of WDTRR field.
	WDT_WDTRR_WDTRR_Msk = 0xff

	// WDTCR: WDT Control Register
	// Position of Reserved field.
	WDT_WDTCR_Reserved_Pos = 0xe
	// Bit mask of Reserved field.
	WDT_WDTCR_Reserved_Msk = 0xc000
	// Position of RPSS field.
	WDT_WDTCR_RPSS_Pos = 0xc
	// Bit mask of RPSS field.
	WDT_WDTCR_RPSS_Msk = 0x3000
	// 25 percent
	WDT_WDTCR_RPSS_00 = 0x0
	// 50 percent
	WDT_WDTCR_RPSS_01 = 0x1
	// 75 percent
	WDT_WDTCR_RPSS_10 = 0x2
	// 100 percent (window start position is not specified)
	WDT_WDTCR_RPSS_11 = 0x3
	// Position of Reserved field.
	WDT_WDTCR_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	WDT_WDTCR_Reserved_Msk = 0xc00
	// Position of RPES field.
	WDT_WDTCR_RPES_Pos = 0x8
	// Bit mask of RPES field.
	WDT_WDTCR_RPES_Msk = 0x300
	// 75 percent
	WDT_WDTCR_RPES_00 = 0x0
	// 50 percent
	WDT_WDTCR_RPES_01 = 0x1
	// 25 percent
	WDT_WDTCR_RPES_10 = 0x2
	// 0 percent (window end position is not specified)
	WDT_WDTCR_RPES_11 = 0x3
	// Position of CKS field.
	WDT_WDTCR_CKS_Pos = 0x4
	// Bit mask of CKS field.
	WDT_WDTCR_CKS_Msk = 0xf0
	// PCLK/4
	WDT_WDTCR_CKS_0001 = 0x1
	// PCLK/64
	WDT_WDTCR_CKS_0100 = 0x4
	// PCLK/128
	WDT_WDTCR_CKS_1111 = 0xf
	// PCLK/512
	WDT_WDTCR_CKS_0110 = 0x6
	// PCLK/2048
	WDT_WDTCR_CKS_0111 = 0x7
	// PCLK/8192
	WDT_WDTCR_CKS_1000 = 0x8
	// Position of Reserved field.
	WDT_WDTCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	WDT_WDTCR_Reserved_Msk = 0xc
	// Position of TOPS field.
	WDT_WDTCR_TOPS_Pos = 0x0
	// Bit mask of TOPS field.
	WDT_WDTCR_TOPS_Msk = 0x3
	// 1,024 cycles (03FFh)
	WDT_WDTCR_TOPS_00 = 0x0
	// 4,096 cycles (0FFFh)
	WDT_WDTCR_TOPS_01 = 0x1
	// 8,192 cycles (1FFFh)
	WDT_WDTCR_TOPS_10 = 0x2
	// 16,384 cycles (3FFFh)
	WDT_WDTCR_TOPS_11 = 0x3

	// WDTSR: WDT Status Register
	// Position of REFEF field.
	WDT_WDTSR_REFEF_Pos = 0xf
	// Bit mask of REFEF field.
	WDT_WDTSR_REFEF_Msk = 0x8000
	// Bit REFEF.
	WDT_WDTSR_REFEF = 0x8000
	// No refresh error occurred
	WDT_WDTSR_REFEF_0 = 0x0
	// Refresh error occurred
	WDT_WDTSR_REFEF_1 = 0x1
	// Position of UNDFF field.
	WDT_WDTSR_UNDFF_Pos = 0xe
	// Bit mask of UNDFF field.
	WDT_WDTSR_UNDFF_Msk = 0x4000
	// Bit UNDFF.
	WDT_WDTSR_UNDFF = 0x4000
	// No underflow occurred
	WDT_WDTSR_UNDFF_0 = 0x0
	// Underflow occurred
	WDT_WDTSR_UNDFF_1 = 0x1
	// Position of CNTVAL field.
	WDT_WDTSR_CNTVAL_Pos = 0x0
	// Bit mask of CNTVAL field.
	WDT_WDTSR_CNTVAL_Msk = 0x3fff

	// WDTRCR: WDT Reset Control Register
	// Position of RSTIRQS field.
	WDT_WDTRCR_RSTIRQS_Pos = 0x7
	// Bit mask of RSTIRQS field.
	WDT_WDTRCR_RSTIRQS_Msk = 0x80
	// Bit RSTIRQS.
	WDT_WDTRCR_RSTIRQS = 0x80
	// Non-maskable interrupt request or interrupt request output is enabled
	WDT_WDTRCR_RSTIRQS_0 = 0x0
	// Reset output is enabled.
	WDT_WDTRCR_RSTIRQS_1 = 0x1

	// WDTCSTPR: WDT Count Stop Control Register
	// Position of SLCSTP field.
	WDT_WDTCSTPR_SLCSTP_Pos = 0x7
	// Bit mask of SLCSTP field.
	WDT_WDTCSTPR_SLCSTP_Msk = 0x80
	// Bit SLCSTP.
	WDT_WDTCSTPR_SLCSTP = 0x80
	// Count stop is disabled.
	WDT_WDTCSTPR_SLCSTP_0 = 0x0
	// Count is stopped at a transition to sleep mode.
	WDT_WDTCSTPR_SLCSTP_1 = 0x1
	// Position of Reserved field.
	WDT_WDTCSTPR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	WDT_WDTCSTPR_Reserved_Msk = 0x7f
)

// Constants for USBFS: USB 2.0 FS Module
const (
	// SYSCFG: System Configuration Control Register
	// Position of Reserved field.
	USBFS_SYSCFG_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	USBFS_SYSCFG_Reserved_Msk = 0xf800
	// Position of SCKE field.
	USBFS_SYSCFG_SCKE_Pos = 0xa
	// Bit mask of SCKE field.
	USBFS_SYSCFG_SCKE_Msk = 0x400
	// Bit SCKE.
	USBFS_SYSCFG_SCKE = 0x400
	// Clock supply to the USBFS stopped
	USBFS_SYSCFG_SCKE_0 = 0x0
	// Clock supply to the USBFS enabled.
	USBFS_SYSCFG_SCKE_1 = 0x1
	// Position of Reserved field.
	USBFS_SYSCFG_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_SYSCFG_Reserved_Msk = 0x200
	// Bit Reserved.
	USBFS_SYSCFG_Reserved = 0x200
	// Position of CNEN field.
	USBFS_SYSCFG_CNEN_Pos = 0x8
	// Bit mask of CNEN field.
	USBFS_SYSCFG_CNEN_Msk = 0x100
	// Bit CNEN.
	USBFS_SYSCFG_CNEN = 0x100
	// Single end receiver disabled
	USBFS_SYSCFG_CNEN_0 = 0x0
	// Single end receiver enabled
	USBFS_SYSCFG_CNEN_1 = 0x1
	// Position of Reserved field.
	USBFS_SYSCFG_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	USBFS_SYSCFG_Reserved_Msk = 0x80
	// Bit Reserved.
	USBFS_SYSCFG_Reserved = 0x80
	// Position of DCFM field.
	USBFS_SYSCFG_DCFM_Pos = 0x6
	// Bit mask of DCFM field.
	USBFS_SYSCFG_DCFM_Msk = 0x40
	// Bit DCFM.
	USBFS_SYSCFG_DCFM = 0x40
	// Device controller selected
	USBFS_SYSCFG_DCFM_0 = 0x0
	// Host controller selected.
	USBFS_SYSCFG_DCFM_1 = 0x1
	// Position of DRPD field.
	USBFS_SYSCFG_DRPD_Pos = 0x5
	// Bit mask of DRPD field.
	USBFS_SYSCFG_DRPD_Msk = 0x20
	// Bit DRPD.
	USBFS_SYSCFG_DRPD = 0x20
	// Line pull-down disabled
	USBFS_SYSCFG_DRPD_0 = 0x0
	// Line pull-down enabled.
	USBFS_SYSCFG_DRPD_1 = 0x1
	// Position of DPRPU field.
	USBFS_SYSCFG_DPRPU_Pos = 0x4
	// Bit mask of DPRPU field.
	USBFS_SYSCFG_DPRPU_Msk = 0x10
	// Bit DPRPU.
	USBFS_SYSCFG_DPRPU = 0x10
	// Line pull-down disabled
	USBFS_SYSCFG_DPRPU_0 = 0x0
	// Line pull-down enabled.
	USBFS_SYSCFG_DPRPU_1 = 0x1
	// Position of DMRPU field.
	USBFS_SYSCFG_DMRPU_Pos = 0x3
	// Bit mask of DMRPU field.
	USBFS_SYSCFG_DMRPU_Msk = 0x8
	// Bit DMRPU.
	USBFS_SYSCFG_DMRPU = 0x8
	// Line pull-up disabled
	USBFS_SYSCFG_DMRPU_0 = 0x0
	// Line pull-up enabled.
	USBFS_SYSCFG_DMRPU_1 = 0x1
	// Position of USBE field.
	USBFS_SYSCFG_USBE_Pos = 0x0
	// Bit mask of USBE field.
	USBFS_SYSCFG_USBE_Msk = 0x1
	// Bit USBE.
	USBFS_SYSCFG_USBE = 0x1
	// Disabled
	USBFS_SYSCFG_USBE_0 = 0x0
	// Enabled.
	USBFS_SYSCFG_USBE_1 = 0x1

	// SYSSTS0: System Configuration Status Register 0
	// Position of OVCMON field.
	USBFS_SYSSTS0_OVCMON_Pos = 0xe
	// Bit mask of OVCMON field.
	USBFS_SYSSTS0_OVCMON_Msk = 0xc000
	// Position of Reserved field.
	USBFS_SYSSTS0_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	USBFS_SYSSTS0_Reserved_Msk = 0x3f80
	// Position of HTACT field.
	USBFS_SYSSTS0_HTACT_Pos = 0x6
	// Bit mask of HTACT field.
	USBFS_SYSSTS0_HTACT_Msk = 0x40
	// Bit HTACT.
	USBFS_SYSSTS0_HTACT = 0x40
	// Host sequencer completely stopped
	USBFS_SYSSTS0_HTACT_0 = 0x0
	// Host sequencer not completely stopped.
	USBFS_SYSSTS0_HTACT_1 = 0x1
	// Position of Reserved field.
	USBFS_SYSSTS0_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	USBFS_SYSSTS0_Reserved_Msk = 0x38
	// Position of IDMON field.
	USBFS_SYSSTS0_IDMON_Pos = 0x2
	// Bit mask of IDMON field.
	USBFS_SYSSTS0_IDMON_Msk = 0x4
	// Bit IDMON.
	USBFS_SYSSTS0_IDMON = 0x4
	// USB0_ID pin is low
	USBFS_SYSSTS0_IDMON_0 = 0x0
	// USB0_ID pin is high
	USBFS_SYSSTS0_IDMON_1 = 0x1
	// Position of LNST field.
	USBFS_SYSSTS0_LNST_Pos = 0x0
	// Bit mask of LNST field.
	USBFS_SYSSTS0_LNST_Msk = 0x3
	// SE0
	USBFS_SYSSTS0_LNST_00 = 0x0
	// K-State (FS) / J-State(LS)
	USBFS_SYSSTS0_LNST_01 = 0x1
	// J-State(FS) / K-State(LS)
	USBFS_SYSSTS0_LNST_10 = 0x2
	// SE1
	USBFS_SYSSTS0_LNST_11 = 0x3

	// DVSTCTR0: Device State Control Register 0
	// Position of Reserved field.
	USBFS_DVSTCTR0_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	USBFS_DVSTCTR0_Reserved_Msk = 0xf000
	// Position of HNPBTOA field.
	USBFS_DVSTCTR0_HNPBTOA_Pos = 0xb
	// Bit mask of HNPBTOA field.
	USBFS_DVSTCTR0_HNPBTOA_Msk = 0x800
	// Bit HNPBTOA.
	USBFS_DVSTCTR0_HNPBTOA = 0x800
	// Normal Operation
	USBFS_DVSTCTR0_HNPBTOA_0 = 0x0
	// Switching from device B to device A is enabled
	USBFS_DVSTCTR0_HNPBTOA_1 = 0x1
	// Position of EXICEN field.
	USBFS_DVSTCTR0_EXICEN_Pos = 0xa
	// Bit mask of EXICEN field.
	USBFS_DVSTCTR0_EXICEN_Msk = 0x400
	// Bit EXICEN.
	USBFS_DVSTCTR0_EXICEN = 0x400
	// External USB_EXICEN pin outputs low
	USBFS_DVSTCTR0_EXICEN_0 = 0x0
	// External USB_EXICEN pin outputs high
	USBFS_DVSTCTR0_EXICEN_1 = 0x1
	// Position of VBUSEN field.
	USBFS_DVSTCTR0_VBUSEN_Pos = 0x9
	// Bit mask of VBUSEN field.
	USBFS_DVSTCTR0_VBUSEN_Msk = 0x200
	// Bit VBUSEN.
	USBFS_DVSTCTR0_VBUSEN = 0x200
	// External USB_VBUSEN pin outputs low
	USBFS_DVSTCTR0_VBUSEN_0 = 0x0
	// External USB_VBUSEN pin outputs high
	USBFS_DVSTCTR0_VBUSEN_1 = 0x1
	// Position of WKUP field.
	USBFS_DVSTCTR0_WKUP_Pos = 0x8
	// Bit mask of WKUP field.
	USBFS_DVSTCTR0_WKUP_Msk = 0x100
	// Bit WKUP.
	USBFS_DVSTCTR0_WKUP = 0x100
	// Remote wakeup signal is not output.
	USBFS_DVSTCTR0_WKUP_0 = 0x0
	// Remote wakeup signal is output.
	USBFS_DVSTCTR0_WKUP_1 = 0x1
	// Position of RWUPE field.
	USBFS_DVSTCTR0_RWUPE_Pos = 0x7
	// Bit mask of RWUPE field.
	USBFS_DVSTCTR0_RWUPE_Msk = 0x80
	// Bit RWUPE.
	USBFS_DVSTCTR0_RWUPE = 0x80
	// Downstream port wakeup is disabled.
	USBFS_DVSTCTR0_RWUPE_0 = 0x0
	// Downstream port wakeup is enabled.
	USBFS_DVSTCTR0_RWUPE_1 = 0x1
	// Position of USBRST field.
	USBFS_DVSTCTR0_USBRST_Pos = 0x6
	// Bit mask of USBRST field.
	USBFS_DVSTCTR0_USBRST_Msk = 0x40
	// Bit USBRST.
	USBFS_DVSTCTR0_USBRST = 0x40
	// USB bus reset signal is not output.
	USBFS_DVSTCTR0_USBRST_0 = 0x0
	// USB bus reset signal is output.
	USBFS_DVSTCTR0_USBRST_1 = 0x1
	// Position of RESUME field.
	USBFS_DVSTCTR0_RESUME_Pos = 0x5
	// Bit mask of RESUME field.
	USBFS_DVSTCTR0_RESUME_Msk = 0x20
	// Bit RESUME.
	USBFS_DVSTCTR0_RESUME = 0x20
	// Resume signal is not output.
	USBFS_DVSTCTR0_RESUME_0 = 0x0
	// Resume signal is output.
	USBFS_DVSTCTR0_RESUME_1 = 0x1
	// Position of UACT field.
	USBFS_DVSTCTR0_UACT_Pos = 0x4
	// Bit mask of UACT field.
	USBFS_DVSTCTR0_UACT_Msk = 0x10
	// Bit UACT.
	USBFS_DVSTCTR0_UACT = 0x10
	// Downstream port is disabled (SOF transmission is disabled).
	USBFS_DVSTCTR0_UACT_0 = 0x0
	// Downstream port is enabled (SOF transmission is enabled).
	USBFS_DVSTCTR0_UACT_1 = 0x1
	// Position of Reserved field.
	USBFS_DVSTCTR0_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	USBFS_DVSTCTR0_Reserved_Msk = 0x8
	// Bit Reserved.
	USBFS_DVSTCTR0_Reserved = 0x8
	// Position of RHST field.
	USBFS_DVSTCTR0_RHST_Pos = 0x0
	// Bit mask of RHST field.
	USBFS_DVSTCTR0_RHST_Msk = 0x7
	// Communication speed not determined
	USBFS_DVSTCTR0_RHST_000 = 0x0
	// Low-speed connection(When the host controller is selected) /USB bus reset in progress( When the function controller is selected)
	USBFS_DVSTCTR0_RHST_001 = 0x1
	// Full-speed connection(When the host controller is selected) /USB bus reset in progress or full-speed connection(When the function controller is selected)
	USBFS_DVSTCTR0_RHST_010 = 0x2
	// Setting prohibited
	USBFS_DVSTCTR0_RHST_011 = 0x3

	// CFIFO: CFIFO Port Register
	// Position of FIFOPORT field.
	USBFS_CFIFO_FIFOPORT_Pos = 0x0
	// Bit mask of FIFOPORT field.
	USBFS_CFIFO_FIFOPORT_Msk = 0xffff

	// D0FIFO: D0FIFO Port Register
	// Position of FIFOPORT field.
	USBFS_D0FIFO_FIFOPORT_Pos = 0x0
	// Bit mask of FIFOPORT field.
	USBFS_D0FIFO_FIFOPORT_Msk = 0xffff

	// D1FIFO: D1FIFO Port Register
	// Position of FIFOPORT field.
	USBFS_D1FIFO_FIFOPORT_Pos = 0x0
	// Bit mask of FIFOPORT field.
	USBFS_D1FIFO_FIFOPORT_Msk = 0xffff

	// CFIFOSEL: CFIFO Port Select Register
	// Position of RCNT field.
	USBFS_CFIFOSEL_RCNT_Pos = 0xf
	// Bit mask of RCNT field.
	USBFS_CFIFOSEL_RCNT_Msk = 0x8000
	// Bit RCNT.
	USBFS_CFIFOSEL_RCNT = 0x8000
	// The DTLN[8:0] bits (CFIFOCRT.DTLN[8:0], D0FIFOCRT.DTLN[8:0], D1FIFOCRT.DTLN[8:0]) are cleared when all of the receive data has been read from the CFIFO.(In double buffer mode, the DTLN[8:0] bit value is cleared when all the data has been read from only a single plane.)
	USBFS_CFIFOSEL_RCNT_0 = 0x0
	// The DTLN[8:0] bits are decremented each time the receive data is read from the CFIFO.
	USBFS_CFIFOSEL_RCNT_1 = 0x1
	// Position of REW field.
	USBFS_CFIFOSEL_REW_Pos = 0xe
	// Bit mask of REW field.
	USBFS_CFIFOSEL_REW_Msk = 0x4000
	// Bit REW.
	USBFS_CFIFOSEL_REW = 0x4000
	// The buffer pointer is not rewound.
	USBFS_CFIFOSEL_REW_0 = 0x0
	// The buffer pointer is rewound.
	USBFS_CFIFOSEL_REW_1 = 0x1
	// Position of Reserved field.
	USBFS_CFIFOSEL_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	USBFS_CFIFOSEL_Reserved_Msk = 0x3800
	// Position of MBW field.
	USBFS_CFIFOSEL_MBW_Pos = 0xa
	// Bit mask of MBW field.
	USBFS_CFIFOSEL_MBW_Msk = 0x400
	// Bit MBW.
	USBFS_CFIFOSEL_MBW = 0x400
	// 8-bit width
	USBFS_CFIFOSEL_MBW_0 = 0x0
	// 16-bit width
	USBFS_CFIFOSEL_MBW_1 = 0x1
	// Position of Reserved field.
	USBFS_CFIFOSEL_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_CFIFOSEL_Reserved_Msk = 0x200
	// Bit Reserved.
	USBFS_CFIFOSEL_Reserved = 0x200
	// Position of BIGEND field.
	USBFS_CFIFOSEL_BIGEND_Pos = 0x8
	// Bit mask of BIGEND field.
	USBFS_CFIFOSEL_BIGEND_Msk = 0x100
	// Bit BIGEND.
	USBFS_CFIFOSEL_BIGEND = 0x100
	// Little endian
	USBFS_CFIFOSEL_BIGEND_0 = 0x0
	// Big endian
	USBFS_CFIFOSEL_BIGEND_1 = 0x1
	// Position of Reserved field.
	USBFS_CFIFOSEL_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	USBFS_CFIFOSEL_Reserved_Msk = 0xc0
	// Position of ISEL field.
	USBFS_CFIFOSEL_ISEL_Pos = 0x5
	// Bit mask of ISEL field.
	USBFS_CFIFOSEL_ISEL_Msk = 0x20
	// Bit ISEL.
	USBFS_CFIFOSEL_ISEL = 0x20
	// Reading from the buffer memory is selected
	USBFS_CFIFOSEL_ISEL_0 = 0x0
	// Writing to the buffer memory is selected
	USBFS_CFIFOSEL_ISEL_1 = 0x1
	// Position of Reserved field.
	USBFS_CFIFOSEL_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	USBFS_CFIFOSEL_Reserved_Msk = 0x10
	// Bit Reserved.
	USBFS_CFIFOSEL_Reserved = 0x10
	// Position of CURPIPE field.
	USBFS_CFIFOSEL_CURPIPE_Pos = 0x0
	// Bit mask of CURPIPE field.
	USBFS_CFIFOSEL_CURPIPE_Msk = 0xf
	// DCP (Default control pipe)
	USBFS_CFIFOSEL_CURPIPE_0000 = 0x0
	// Pipe 1
	USBFS_CFIFOSEL_CURPIPE_0001 = 0x1
	// Pipe 2
	USBFS_CFIFOSEL_CURPIPE_0010 = 0x2
	// Pipe 3
	USBFS_CFIFOSEL_CURPIPE_0011 = 0x3
	// Pipe 4
	USBFS_CFIFOSEL_CURPIPE_0100 = 0x4
	// Pipe 5
	USBFS_CFIFOSEL_CURPIPE_0101 = 0x5
	// Pipe 6
	USBFS_CFIFOSEL_CURPIPE_0110 = 0x6
	// Pipe 7
	USBFS_CFIFOSEL_CURPIPE_0111 = 0x7
	// Pipe 8
	USBFS_CFIFOSEL_CURPIPE_1000 = 0x8
	// Pipe 9
	USBFS_CFIFOSEL_CURPIPE_1001 = 0x9

	// CFIFOCTR: CFIFO Port Control Register
	// Position of BVAL field.
	USBFS_CFIFOCTR_BVAL_Pos = 0xf
	// Bit mask of BVAL field.
	USBFS_CFIFOCTR_BVAL_Msk = 0x8000
	// Bit BVAL.
	USBFS_CFIFOCTR_BVAL = 0x8000
	// Invalid
	USBFS_CFIFOCTR_BVAL_0 = 0x0
	// Writing ended
	USBFS_CFIFOCTR_BVAL_1 = 0x1
	// Position of BCLR field.
	USBFS_CFIFOCTR_BCLR_Pos = 0xe
	// Bit mask of BCLR field.
	USBFS_CFIFOCTR_BCLR_Msk = 0x4000
	// Bit BCLR.
	USBFS_CFIFOCTR_BCLR = 0x4000
	// Does not operate
	USBFS_CFIFOCTR_BCLR_0 = 0x0
	// FIFO buffer cleared on the CPU side.
	USBFS_CFIFOCTR_BCLR_1 = 0x1
	// Position of FRDY field.
	USBFS_CFIFOCTR_FRDY_Pos = 0xd
	// Bit mask of FRDY field.
	USBFS_CFIFOCTR_FRDY_Msk = 0x2000
	// Bit FRDY.
	USBFS_CFIFOCTR_FRDY = 0x2000
	// FIFO port access is disabled.
	USBFS_CFIFOCTR_FRDY_0 = 0x0
	// FIFO port access is enabled.
	USBFS_CFIFOCTR_FRDY_1 = 0x1
	// Position of Reserved field.
	USBFS_CFIFOCTR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_CFIFOCTR_Reserved_Msk = 0x1e00
	// Position of DTLN field.
	USBFS_CFIFOCTR_DTLN_Pos = 0x0
	// Bit mask of DTLN field.
	USBFS_CFIFOCTR_DTLN_Msk = 0x1ff

	// D0FIFOSEL: D0FIFO Port Select Register
	// Position of RCNT field.
	USBFS_D0FIFOSEL_RCNT_Pos = 0xf
	// Bit mask of RCNT field.
	USBFS_D0FIFOSEL_RCNT_Msk = 0x8000
	// Bit RCNT.
	USBFS_D0FIFOSEL_RCNT = 0x8000
	// The DTLN[8:0] bits (CFIFOCRT.DTLN[8:0], D0FIFOCRT.DTLN[8:0], D1FIFOCRT.DTLN[8:0]) are cleared when all of the receive data has been read from the DnFIFO.(In double buffer mode, the DTLN bit Value is cleared when all the data has been read from only a single plane.)
	USBFS_D0FIFOSEL_RCNT_0 = 0x0
	// The DTLN[8:0] bits are decremented each time the receive data is read from the DnFIFO. (n = 0, 1)
	USBFS_D0FIFOSEL_RCNT_1 = 0x1
	// Position of REW field.
	USBFS_D0FIFOSEL_REW_Pos = 0xe
	// Bit mask of REW field.
	USBFS_D0FIFOSEL_REW_Msk = 0x4000
	// Bit REW.
	USBFS_D0FIFOSEL_REW = 0x4000
	// The buffer pointer is not rewound.
	USBFS_D0FIFOSEL_REW_0 = 0x0
	// The buffer pointer is rewound.
	USBFS_D0FIFOSEL_REW_1 = 0x1
	// Position of DCLRM field.
	USBFS_D0FIFOSEL_DCLRM_Pos = 0xd
	// Bit mask of DCLRM field.
	USBFS_D0FIFOSEL_DCLRM_Msk = 0x2000
	// Bit DCLRM.
	USBFS_D0FIFOSEL_DCLRM = 0x2000
	// Auto buffer clear mode is disabled.
	USBFS_D0FIFOSEL_DCLRM_0 = 0x0
	// Auto buffer clear mode is enabled.
	USBFS_D0FIFOSEL_DCLRM_1 = 0x1
	// Position of DREQE field.
	USBFS_D0FIFOSEL_DREQE_Pos = 0xc
	// Bit mask of DREQE field.
	USBFS_D0FIFOSEL_DREQE_Msk = 0x1000
	// Bit DREQE.
	USBFS_D0FIFOSEL_DREQE = 0x1000
	// DMA/DTC transfer request is disabled.
	USBFS_D0FIFOSEL_DREQE_0 = 0x0
	// DMA/DTC transfer request is enabled.
	USBFS_D0FIFOSEL_DREQE_1 = 0x1
	// Position of Reserved field.
	USBFS_D0FIFOSEL_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	USBFS_D0FIFOSEL_Reserved_Msk = 0x800
	// Bit Reserved.
	USBFS_D0FIFOSEL_Reserved = 0x800
	// Position of MBW field.
	USBFS_D0FIFOSEL_MBW_Pos = 0xa
	// Bit mask of MBW field.
	USBFS_D0FIFOSEL_MBW_Msk = 0x400
	// Bit MBW.
	USBFS_D0FIFOSEL_MBW = 0x400
	// 8-bit width
	USBFS_D0FIFOSEL_MBW_0 = 0x0
	// 16-bit width
	USBFS_D0FIFOSEL_MBW_1 = 0x1
	// Position of Reserved field.
	USBFS_D0FIFOSEL_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_D0FIFOSEL_Reserved_Msk = 0x200
	// Bit Reserved.
	USBFS_D0FIFOSEL_Reserved = 0x200
	// Position of BIGEND field.
	USBFS_D0FIFOSEL_BIGEND_Pos = 0x8
	// Bit mask of BIGEND field.
	USBFS_D0FIFOSEL_BIGEND_Msk = 0x100
	// Bit BIGEND.
	USBFS_D0FIFOSEL_BIGEND = 0x100
	// Little endian
	USBFS_D0FIFOSEL_BIGEND_0 = 0x0
	// Big endian
	USBFS_D0FIFOSEL_BIGEND_1 = 0x1
	// Position of Reserved field.
	USBFS_D0FIFOSEL_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	USBFS_D0FIFOSEL_Reserved_Msk = 0xf0
	// Position of CURPIPE field.
	USBFS_D0FIFOSEL_CURPIPE_Pos = 0x0
	// Bit mask of CURPIPE field.
	USBFS_D0FIFOSEL_CURPIPE_Msk = 0xf
	// DCP (Default control pipe)
	USBFS_D0FIFOSEL_CURPIPE_0000 = 0x0
	// Pipe 1
	USBFS_D0FIFOSEL_CURPIPE_0001 = 0x1
	// Pipe 2
	USBFS_D0FIFOSEL_CURPIPE_0010 = 0x2
	// Pipe 3
	USBFS_D0FIFOSEL_CURPIPE_0011 = 0x3
	// Pipe 4
	USBFS_D0FIFOSEL_CURPIPE_0100 = 0x4
	// Pipe 5
	USBFS_D0FIFOSEL_CURPIPE_0101 = 0x5
	// Pipe 6
	USBFS_D0FIFOSEL_CURPIPE_0110 = 0x6
	// Pipe 7
	USBFS_D0FIFOSEL_CURPIPE_0111 = 0x7
	// Pipe 8
	USBFS_D0FIFOSEL_CURPIPE_1000 = 0x8
	// Pipe 9
	USBFS_D0FIFOSEL_CURPIPE_1001 = 0x9

	// D0FIFOCTR: D0FIFO Port Control Register
	// Position of BVAL field.
	USBFS_D0FIFOCTR_BVAL_Pos = 0xf
	// Bit mask of BVAL field.
	USBFS_D0FIFOCTR_BVAL_Msk = 0x8000
	// Bit BVAL.
	USBFS_D0FIFOCTR_BVAL = 0x8000
	// Invalid
	USBFS_D0FIFOCTR_BVAL_0 = 0x0
	// Writing ended
	USBFS_D0FIFOCTR_BVAL_1 = 0x1
	// Position of BCLR field.
	USBFS_D0FIFOCTR_BCLR_Pos = 0xe
	// Bit mask of BCLR field.
	USBFS_D0FIFOCTR_BCLR_Msk = 0x4000
	// Bit BCLR.
	USBFS_D0FIFOCTR_BCLR = 0x4000
	// Does not operate
	USBFS_D0FIFOCTR_BCLR_0 = 0x0
	// FIFO buffer cleared on the CPU side.
	USBFS_D0FIFOCTR_BCLR_1 = 0x1
	// Position of FRDY field.
	USBFS_D0FIFOCTR_FRDY_Pos = 0xd
	// Bit mask of FRDY field.
	USBFS_D0FIFOCTR_FRDY_Msk = 0x2000
	// Bit FRDY.
	USBFS_D0FIFOCTR_FRDY = 0x2000
	// FIFO port access is disabled.
	USBFS_D0FIFOCTR_FRDY_0 = 0x0
	// FIFO port access is enabled.
	USBFS_D0FIFOCTR_FRDY_1 = 0x1
	// Position of Reserved field.
	USBFS_D0FIFOCTR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_D0FIFOCTR_Reserved_Msk = 0x1e00
	// Position of DTLN field.
	USBFS_D0FIFOCTR_DTLN_Pos = 0x0
	// Bit mask of DTLN field.
	USBFS_D0FIFOCTR_DTLN_Msk = 0x1ff

	// D1FIFOSEL: D1FIFO Port Select Register
	// Position of RCNT field.
	USBFS_D1FIFOSEL_RCNT_Pos = 0xf
	// Bit mask of RCNT field.
	USBFS_D1FIFOSEL_RCNT_Msk = 0x8000
	// Bit RCNT.
	USBFS_D1FIFOSEL_RCNT = 0x8000
	// The DTLN[8:0] bits (CFIFOCRT.DTLN[8:0], D0FIFOCRT.DTLN[8:0], D1FIFOCRT.DTLN[8:0]) are cleared when all of the receive data has been read from the DnFIFO.(In double buffer mode, the DTLN bit Value is cleared when all the data has been read from only a single plane.)
	USBFS_D1FIFOSEL_RCNT_0 = 0x0
	// The DTLN[8:0] bits are decremented each time the receive data is read from the DnFIFO. (n = 0, 1)
	USBFS_D1FIFOSEL_RCNT_1 = 0x1
	// Position of REW field.
	USBFS_D1FIFOSEL_REW_Pos = 0xe
	// Bit mask of REW field.
	USBFS_D1FIFOSEL_REW_Msk = 0x4000
	// Bit REW.
	USBFS_D1FIFOSEL_REW = 0x4000
	// The buffer pointer is not rewound.
	USBFS_D1FIFOSEL_REW_0 = 0x0
	// The buffer pointer is rewound.
	USBFS_D1FIFOSEL_REW_1 = 0x1
	// Position of DCLRM field.
	USBFS_D1FIFOSEL_DCLRM_Pos = 0xd
	// Bit mask of DCLRM field.
	USBFS_D1FIFOSEL_DCLRM_Msk = 0x2000
	// Bit DCLRM.
	USBFS_D1FIFOSEL_DCLRM = 0x2000
	// Auto buffer clear mode is disabled.
	USBFS_D1FIFOSEL_DCLRM_0 = 0x0
	// Auto buffer clear mode is enabled.
	USBFS_D1FIFOSEL_DCLRM_1 = 0x1
	// Position of DREQE field.
	USBFS_D1FIFOSEL_DREQE_Pos = 0xc
	// Bit mask of DREQE field.
	USBFS_D1FIFOSEL_DREQE_Msk = 0x1000
	// Bit DREQE.
	USBFS_D1FIFOSEL_DREQE = 0x1000
	// DMA/DTC transfer request is disabled.
	USBFS_D1FIFOSEL_DREQE_0 = 0x0
	// DMA/DTC transfer request is enabled.
	USBFS_D1FIFOSEL_DREQE_1 = 0x1
	// Position of Reserved field.
	USBFS_D1FIFOSEL_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	USBFS_D1FIFOSEL_Reserved_Msk = 0x800
	// Bit Reserved.
	USBFS_D1FIFOSEL_Reserved = 0x800
	// Position of MBW field.
	USBFS_D1FIFOSEL_MBW_Pos = 0xa
	// Bit mask of MBW field.
	USBFS_D1FIFOSEL_MBW_Msk = 0x400
	// Bit MBW.
	USBFS_D1FIFOSEL_MBW = 0x400
	// 8-bit width
	USBFS_D1FIFOSEL_MBW_0 = 0x0
	// 16-bit width
	USBFS_D1FIFOSEL_MBW_1 = 0x1
	// Position of Reserved field.
	USBFS_D1FIFOSEL_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_D1FIFOSEL_Reserved_Msk = 0x200
	// Bit Reserved.
	USBFS_D1FIFOSEL_Reserved = 0x200
	// Position of BIGEND field.
	USBFS_D1FIFOSEL_BIGEND_Pos = 0x8
	// Bit mask of BIGEND field.
	USBFS_D1FIFOSEL_BIGEND_Msk = 0x100
	// Bit BIGEND.
	USBFS_D1FIFOSEL_BIGEND = 0x100
	// Little endian
	USBFS_D1FIFOSEL_BIGEND_0 = 0x0
	// Big endian
	USBFS_D1FIFOSEL_BIGEND_1 = 0x1
	// Position of Reserved field.
	USBFS_D1FIFOSEL_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	USBFS_D1FIFOSEL_Reserved_Msk = 0xf0
	// Position of CURPIPE field.
	USBFS_D1FIFOSEL_CURPIPE_Pos = 0x0
	// Bit mask of CURPIPE field.
	USBFS_D1FIFOSEL_CURPIPE_Msk = 0xf
	// DCP (Default control pipe)
	USBFS_D1FIFOSEL_CURPIPE_0000 = 0x0
	// Pipe 1
	USBFS_D1FIFOSEL_CURPIPE_0001 = 0x1
	// Pipe 2
	USBFS_D1FIFOSEL_CURPIPE_0010 = 0x2
	// Pipe 3
	USBFS_D1FIFOSEL_CURPIPE_0011 = 0x3
	// Pipe 4
	USBFS_D1FIFOSEL_CURPIPE_0100 = 0x4
	// Pipe 5
	USBFS_D1FIFOSEL_CURPIPE_0101 = 0x5
	// Pipe 6
	USBFS_D1FIFOSEL_CURPIPE_0110 = 0x6
	// Pipe 7
	USBFS_D1FIFOSEL_CURPIPE_0111 = 0x7
	// Pipe 8
	USBFS_D1FIFOSEL_CURPIPE_1000 = 0x8
	// Pipe 9
	USBFS_D1FIFOSEL_CURPIPE_1001 = 0x9

	// D1FIFOCTR: D1FIFO Port Control Register
	// Position of BVAL field.
	USBFS_D1FIFOCTR_BVAL_Pos = 0xf
	// Bit mask of BVAL field.
	USBFS_D1FIFOCTR_BVAL_Msk = 0x8000
	// Bit BVAL.
	USBFS_D1FIFOCTR_BVAL = 0x8000
	// Invalid
	USBFS_D1FIFOCTR_BVAL_0 = 0x0
	// Writing ended
	USBFS_D1FIFOCTR_BVAL_1 = 0x1
	// Position of BCLR field.
	USBFS_D1FIFOCTR_BCLR_Pos = 0xe
	// Bit mask of BCLR field.
	USBFS_D1FIFOCTR_BCLR_Msk = 0x4000
	// Bit BCLR.
	USBFS_D1FIFOCTR_BCLR = 0x4000
	// Does not operate
	USBFS_D1FIFOCTR_BCLR_0 = 0x0
	// FIFO buffer cleared on the CPU side.
	USBFS_D1FIFOCTR_BCLR_1 = 0x1
	// Position of FRDY field.
	USBFS_D1FIFOCTR_FRDY_Pos = 0xd
	// Bit mask of FRDY field.
	USBFS_D1FIFOCTR_FRDY_Msk = 0x2000
	// Bit FRDY.
	USBFS_D1FIFOCTR_FRDY = 0x2000
	// FIFO port access is disabled.
	USBFS_D1FIFOCTR_FRDY_0 = 0x0
	// FIFO port access is enabled.
	USBFS_D1FIFOCTR_FRDY_1 = 0x1
	// Position of Reserved field.
	USBFS_D1FIFOCTR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_D1FIFOCTR_Reserved_Msk = 0x1e00
	// Position of DTLN field.
	USBFS_D1FIFOCTR_DTLN_Pos = 0x0
	// Bit mask of DTLN field.
	USBFS_D1FIFOCTR_DTLN_Msk = 0x1ff

	// INTENB0: Interrupt Enable Register 0
	// Position of VBSE field.
	USBFS_INTENB0_VBSE_Pos = 0xf
	// Bit mask of VBSE field.
	USBFS_INTENB0_VBSE_Msk = 0x8000
	// Bit VBSE.
	USBFS_INTENB0_VBSE = 0x8000
	// Interrupt output disabled
	USBFS_INTENB0_VBSE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_VBSE_1 = 0x1
	// Position of RSME field.
	USBFS_INTENB0_RSME_Pos = 0xe
	// Bit mask of RSME field.
	USBFS_INTENB0_RSME_Msk = 0x4000
	// Bit RSME.
	USBFS_INTENB0_RSME = 0x4000
	// Interrupt output disabled
	USBFS_INTENB0_RSME_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_RSME_1 = 0x1
	// Position of SOFE field.
	USBFS_INTENB0_SOFE_Pos = 0xd
	// Bit mask of SOFE field.
	USBFS_INTENB0_SOFE_Msk = 0x2000
	// Bit SOFE.
	USBFS_INTENB0_SOFE = 0x2000
	// Interrupt output disabled
	USBFS_INTENB0_SOFE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_SOFE_1 = 0x1
	// Position of DVSE field.
	USBFS_INTENB0_DVSE_Pos = 0xc
	// Bit mask of DVSE field.
	USBFS_INTENB0_DVSE_Msk = 0x1000
	// Bit DVSE.
	USBFS_INTENB0_DVSE = 0x1000
	// Interrupt output disabled
	USBFS_INTENB0_DVSE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_DVSE_1 = 0x1
	// Position of CTRE field.
	USBFS_INTENB0_CTRE_Pos = 0xb
	// Bit mask of CTRE field.
	USBFS_INTENB0_CTRE_Msk = 0x800
	// Bit CTRE.
	USBFS_INTENB0_CTRE = 0x800
	// Interrupt output disabled
	USBFS_INTENB0_CTRE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_CTRE_1 = 0x1
	// Position of BEMPE field.
	USBFS_INTENB0_BEMPE_Pos = 0xa
	// Bit mask of BEMPE field.
	USBFS_INTENB0_BEMPE_Msk = 0x400
	// Bit BEMPE.
	USBFS_INTENB0_BEMPE = 0x400
	// Interrupt output disabled
	USBFS_INTENB0_BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_BEMPE_1 = 0x1
	// Position of NRDYE field.
	USBFS_INTENB0_NRDYE_Pos = 0x9
	// Bit mask of NRDYE field.
	USBFS_INTENB0_NRDYE_Msk = 0x200
	// Bit NRDYE.
	USBFS_INTENB0_NRDYE = 0x200
	// Interrupt output disabled
	USBFS_INTENB0_NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_NRDYE_1 = 0x1
	// Position of BRDYE field.
	USBFS_INTENB0_BRDYE_Pos = 0x8
	// Bit mask of BRDYE field.
	USBFS_INTENB0_BRDYE_Msk = 0x100
	// Bit BRDYE.
	USBFS_INTENB0_BRDYE = 0x100
	// Interrupt output disabled
	USBFS_INTENB0_BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_BRDYE_1 = 0x1
	// Position of Reserved field.
	USBFS_INTENB0_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	USBFS_INTENB0_Reserved_Msk = 0xff

	// INTENB1: Interrupt Enable Register 1
	// Position of OVRCRE field.
	USBFS_INTENB1_OVRCRE_Pos = 0xf
	// Bit mask of OVRCRE field.
	USBFS_INTENB1_OVRCRE_Msk = 0x8000
	// Bit OVRCRE.
	USBFS_INTENB1_OVRCRE = 0x8000
	// Interrupt output disabled
	USBFS_INTENB1_OVRCRE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_OVRCRE_1 = 0x1
	// Position of BCHGE field.
	USBFS_INTENB1_BCHGE_Pos = 0xe
	// Bit mask of BCHGE field.
	USBFS_INTENB1_BCHGE_Msk = 0x4000
	// Bit BCHGE.
	USBFS_INTENB1_BCHGE = 0x4000
	// Interrupt output disabled
	USBFS_INTENB1_BCHGE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_BCHGE_1 = 0x1
	// Position of Reserved field.
	USBFS_INTENB1_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	USBFS_INTENB1_Reserved_Msk = 0x2000
	// Bit Reserved.
	USBFS_INTENB1_Reserved = 0x2000
	// Position of DTCHE field.
	USBFS_INTENB1_DTCHE_Pos = 0xc
	// Bit mask of DTCHE field.
	USBFS_INTENB1_DTCHE_Msk = 0x1000
	// Bit DTCHE.
	USBFS_INTENB1_DTCHE = 0x1000
	// Interrupt output disabled
	USBFS_INTENB1_DTCHE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_DTCHE_1 = 0x1
	// Position of ATTCHE field.
	USBFS_INTENB1_ATTCHE_Pos = 0xb
	// Bit mask of ATTCHE field.
	USBFS_INTENB1_ATTCHE_Msk = 0x800
	// Bit ATTCHE.
	USBFS_INTENB1_ATTCHE = 0x800
	// Interrupt output disabled
	USBFS_INTENB1_ATTCHE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_ATTCHE_1 = 0x1
	// Position of Reserved field.
	USBFS_INTENB1_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	USBFS_INTENB1_Reserved_Msk = 0x780
	// Position of EOFERRE field.
	USBFS_INTENB1_EOFERRE_Pos = 0x6
	// Bit mask of EOFERRE field.
	USBFS_INTENB1_EOFERRE_Msk = 0x40
	// Bit EOFERRE.
	USBFS_INTENB1_EOFERRE = 0x40
	// Interrupt output disabled
	USBFS_INTENB1_EOFERRE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_EOFERRE_1 = 0x1
	// Position of SIGNE field.
	USBFS_INTENB1_SIGNE_Pos = 0x5
	// Bit mask of SIGNE field.
	USBFS_INTENB1_SIGNE_Msk = 0x20
	// Bit SIGNE.
	USBFS_INTENB1_SIGNE = 0x20
	// Interrupt output disabled
	USBFS_INTENB1_SIGNE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_SIGNE_1 = 0x1
	// Position of SACKE field.
	USBFS_INTENB1_SACKE_Pos = 0x4
	// Bit mask of SACKE field.
	USBFS_INTENB1_SACKE_Msk = 0x10
	// Bit SACKE.
	USBFS_INTENB1_SACKE = 0x10
	// Interrupt output disabled
	USBFS_INTENB1_SACKE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_SACKE_1 = 0x1
	// Position of Reserved field.
	USBFS_INTENB1_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	USBFS_INTENB1_Reserved_Msk = 0xe
	// Position of PDDETINTE0 field.
	USBFS_INTENB1_PDDETINTE0_Pos = 0x0
	// Bit mask of PDDETINTE0 field.
	USBFS_INTENB1_PDDETINTE0_Msk = 0x1
	// Bit PDDETINTE0.
	USBFS_INTENB1_PDDETINTE0 = 0x1
	// Interrupt output disabled
	USBFS_INTENB1_PDDETINTE0_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_PDDETINTE0_1 = 0x1

	// BRDYENB: BRDY Interrupt Enable Register
	// Position of Reserved field.
	USBFS_BRDYENB_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_BRDYENB_Reserved_Msk = 0xfc00
	// Position of PIPE9BRDYE field.
	USBFS_BRDYENB_PIPE9BRDYE_Pos = 0x9
	// Bit mask of PIPE9BRDYE field.
	USBFS_BRDYENB_PIPE9BRDYE_Msk = 0x200
	// Bit PIPE9BRDYE.
	USBFS_BRDYENB_PIPE9BRDYE = 0x200
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE9BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE9BRDYE_1 = 0x1
	// Position of PIPE8BRDYE field.
	USBFS_BRDYENB_PIPE8BRDYE_Pos = 0x8
	// Bit mask of PIPE8BRDYE field.
	USBFS_BRDYENB_PIPE8BRDYE_Msk = 0x100
	// Bit PIPE8BRDYE.
	USBFS_BRDYENB_PIPE8BRDYE = 0x100
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE8BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE8BRDYE_1 = 0x1
	// Position of PIPE7BRDYE field.
	USBFS_BRDYENB_PIPE7BRDYE_Pos = 0x7
	// Bit mask of PIPE7BRDYE field.
	USBFS_BRDYENB_PIPE7BRDYE_Msk = 0x80
	// Bit PIPE7BRDYE.
	USBFS_BRDYENB_PIPE7BRDYE = 0x80
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE7BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE7BRDYE_1 = 0x1
	// Position of PIPE6BRDYE field.
	USBFS_BRDYENB_PIPE6BRDYE_Pos = 0x6
	// Bit mask of PIPE6BRDYE field.
	USBFS_BRDYENB_PIPE6BRDYE_Msk = 0x40
	// Bit PIPE6BRDYE.
	USBFS_BRDYENB_PIPE6BRDYE = 0x40
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE6BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE6BRDYE_1 = 0x1
	// Position of PIPE5BRDYE field.
	USBFS_BRDYENB_PIPE5BRDYE_Pos = 0x5
	// Bit mask of PIPE5BRDYE field.
	USBFS_BRDYENB_PIPE5BRDYE_Msk = 0x20
	// Bit PIPE5BRDYE.
	USBFS_BRDYENB_PIPE5BRDYE = 0x20
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE5BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE5BRDYE_1 = 0x1
	// Position of PIPE4BRDYE field.
	USBFS_BRDYENB_PIPE4BRDYE_Pos = 0x4
	// Bit mask of PIPE4BRDYE field.
	USBFS_BRDYENB_PIPE4BRDYE_Msk = 0x10
	// Bit PIPE4BRDYE.
	USBFS_BRDYENB_PIPE4BRDYE = 0x10
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE4BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE4BRDYE_1 = 0x1
	// Position of PIPE3BRDYE field.
	USBFS_BRDYENB_PIPE3BRDYE_Pos = 0x3
	// Bit mask of PIPE3BRDYE field.
	USBFS_BRDYENB_PIPE3BRDYE_Msk = 0x8
	// Bit PIPE3BRDYE.
	USBFS_BRDYENB_PIPE3BRDYE = 0x8
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE3BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE3BRDYE_1 = 0x1
	// Position of PIPE2BRDYE field.
	USBFS_BRDYENB_PIPE2BRDYE_Pos = 0x2
	// Bit mask of PIPE2BRDYE field.
	USBFS_BRDYENB_PIPE2BRDYE_Msk = 0x4
	// Bit PIPE2BRDYE.
	USBFS_BRDYENB_PIPE2BRDYE = 0x4
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE2BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE2BRDYE_1 = 0x1
	// Position of PIPE1BRDYE field.
	USBFS_BRDYENB_PIPE1BRDYE_Pos = 0x1
	// Bit mask of PIPE1BRDYE field.
	USBFS_BRDYENB_PIPE1BRDYE_Msk = 0x2
	// Bit PIPE1BRDYE.
	USBFS_BRDYENB_PIPE1BRDYE = 0x2
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE1BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE1BRDYE_1 = 0x1
	// Position of PIPE0BRDYE field.
	USBFS_BRDYENB_PIPE0BRDYE_Pos = 0x0
	// Bit mask of PIPE0BRDYE field.
	USBFS_BRDYENB_PIPE0BRDYE_Msk = 0x1
	// Bit PIPE0BRDYE.
	USBFS_BRDYENB_PIPE0BRDYE = 0x1
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE0BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE0BRDYE_1 = 0x1

	// NRDYENB: NRDY Interrupt Enable Register
	// Position of Reserved field.
	USBFS_NRDYENB_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_NRDYENB_Reserved_Msk = 0xfc00
	// Position of PIPE9NRDYE field.
	USBFS_NRDYENB_PIPE9NRDYE_Pos = 0x9
	// Bit mask of PIPE9NRDYE field.
	USBFS_NRDYENB_PIPE9NRDYE_Msk = 0x200
	// Bit PIPE9NRDYE.
	USBFS_NRDYENB_PIPE9NRDYE = 0x200
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE9NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE9NRDYE_1 = 0x1
	// Position of PIPE8NRDYE field.
	USBFS_NRDYENB_PIPE8NRDYE_Pos = 0x8
	// Bit mask of PIPE8NRDYE field.
	USBFS_NRDYENB_PIPE8NRDYE_Msk = 0x100
	// Bit PIPE8NRDYE.
	USBFS_NRDYENB_PIPE8NRDYE = 0x100
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE8NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE8NRDYE_1 = 0x1
	// Position of PIPE7NRDYE field.
	USBFS_NRDYENB_PIPE7NRDYE_Pos = 0x7
	// Bit mask of PIPE7NRDYE field.
	USBFS_NRDYENB_PIPE7NRDYE_Msk = 0x80
	// Bit PIPE7NRDYE.
	USBFS_NRDYENB_PIPE7NRDYE = 0x80
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE7NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE7NRDYE_1 = 0x1
	// Position of PIPE6NRDYE field.
	USBFS_NRDYENB_PIPE6NRDYE_Pos = 0x6
	// Bit mask of PIPE6NRDYE field.
	USBFS_NRDYENB_PIPE6NRDYE_Msk = 0x40
	// Bit PIPE6NRDYE.
	USBFS_NRDYENB_PIPE6NRDYE = 0x40
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE6NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE6NRDYE_1 = 0x1
	// Position of PIPE5NRDYE field.
	USBFS_NRDYENB_PIPE5NRDYE_Pos = 0x5
	// Bit mask of PIPE5NRDYE field.
	USBFS_NRDYENB_PIPE5NRDYE_Msk = 0x20
	// Bit PIPE5NRDYE.
	USBFS_NRDYENB_PIPE5NRDYE = 0x20
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE5NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE5NRDYE_1 = 0x1
	// Position of PIPE4NRDYE field.
	USBFS_NRDYENB_PIPE4NRDYE_Pos = 0x4
	// Bit mask of PIPE4NRDYE field.
	USBFS_NRDYENB_PIPE4NRDYE_Msk = 0x10
	// Bit PIPE4NRDYE.
	USBFS_NRDYENB_PIPE4NRDYE = 0x10
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE4NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE4NRDYE_1 = 0x1
	// Position of PIPE3NRDYE field.
	USBFS_NRDYENB_PIPE3NRDYE_Pos = 0x3
	// Bit mask of PIPE3NRDYE field.
	USBFS_NRDYENB_PIPE3NRDYE_Msk = 0x8
	// Bit PIPE3NRDYE.
	USBFS_NRDYENB_PIPE3NRDYE = 0x8
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE3NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE3NRDYE_1 = 0x1
	// Position of PIPE2NRDYE field.
	USBFS_NRDYENB_PIPE2NRDYE_Pos = 0x2
	// Bit mask of PIPE2NRDYE field.
	USBFS_NRDYENB_PIPE2NRDYE_Msk = 0x4
	// Bit PIPE2NRDYE.
	USBFS_NRDYENB_PIPE2NRDYE = 0x4
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE2NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE2NRDYE_1 = 0x1
	// Position of PIPE1NRDYE field.
	USBFS_NRDYENB_PIPE1NRDYE_Pos = 0x1
	// Bit mask of PIPE1NRDYE field.
	USBFS_NRDYENB_PIPE1NRDYE_Msk = 0x2
	// Bit PIPE1NRDYE.
	USBFS_NRDYENB_PIPE1NRDYE = 0x2
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE1NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE1NRDYE_1 = 0x1
	// Position of PIPE0NRDYE field.
	USBFS_NRDYENB_PIPE0NRDYE_Pos = 0x0
	// Bit mask of PIPE0NRDYE field.
	USBFS_NRDYENB_PIPE0NRDYE_Msk = 0x1
	// Bit PIPE0NRDYE.
	USBFS_NRDYENB_PIPE0NRDYE = 0x1
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE0NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE0NRDYE_1 = 0x1

	// BEMPENB: BEMP Interrupt Enable Register
	// Position of Reserved field.
	USBFS_BEMPENB_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_BEMPENB_Reserved_Msk = 0xfc00
	// Position of PIPE9BEMPE field.
	USBFS_BEMPENB_PIPE9BEMPE_Pos = 0x9
	// Bit mask of PIPE9BEMPE field.
	USBFS_BEMPENB_PIPE9BEMPE_Msk = 0x200
	// Bit PIPE9BEMPE.
	USBFS_BEMPENB_PIPE9BEMPE = 0x200
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE9BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE9BEMPE_1 = 0x1
	// Position of PIPE8BEMPE field.
	USBFS_BEMPENB_PIPE8BEMPE_Pos = 0x8
	// Bit mask of PIPE8BEMPE field.
	USBFS_BEMPENB_PIPE8BEMPE_Msk = 0x100
	// Bit PIPE8BEMPE.
	USBFS_BEMPENB_PIPE8BEMPE = 0x100
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE8BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE8BEMPE_1 = 0x1
	// Position of PIPE7BEMPE field.
	USBFS_BEMPENB_PIPE7BEMPE_Pos = 0x7
	// Bit mask of PIPE7BEMPE field.
	USBFS_BEMPENB_PIPE7BEMPE_Msk = 0x80
	// Bit PIPE7BEMPE.
	USBFS_BEMPENB_PIPE7BEMPE = 0x80
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE7BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE7BEMPE_1 = 0x1
	// Position of PIPE6BEMPE field.
	USBFS_BEMPENB_PIPE6BEMPE_Pos = 0x6
	// Bit mask of PIPE6BEMPE field.
	USBFS_BEMPENB_PIPE6BEMPE_Msk = 0x40
	// Bit PIPE6BEMPE.
	USBFS_BEMPENB_PIPE6BEMPE = 0x40
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE6BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE6BEMPE_1 = 0x1
	// Position of PIPE5BEMPE field.
	USBFS_BEMPENB_PIPE5BEMPE_Pos = 0x5
	// Bit mask of PIPE5BEMPE field.
	USBFS_BEMPENB_PIPE5BEMPE_Msk = 0x20
	// Bit PIPE5BEMPE.
	USBFS_BEMPENB_PIPE5BEMPE = 0x20
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE5BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE5BEMPE_1 = 0x1
	// Position of PIPE4BEMPE field.
	USBFS_BEMPENB_PIPE4BEMPE_Pos = 0x4
	// Bit mask of PIPE4BEMPE field.
	USBFS_BEMPENB_PIPE4BEMPE_Msk = 0x10
	// Bit PIPE4BEMPE.
	USBFS_BEMPENB_PIPE4BEMPE = 0x10
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE4BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE4BEMPE_1 = 0x1
	// Position of PIPE3BEMPE field.
	USBFS_BEMPENB_PIPE3BEMPE_Pos = 0x3
	// Bit mask of PIPE3BEMPE field.
	USBFS_BEMPENB_PIPE3BEMPE_Msk = 0x8
	// Bit PIPE3BEMPE.
	USBFS_BEMPENB_PIPE3BEMPE = 0x8
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE3BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE3BEMPE_1 = 0x1
	// Position of PIPE2BEMPE field.
	USBFS_BEMPENB_PIPE2BEMPE_Pos = 0x2
	// Bit mask of PIPE2BEMPE field.
	USBFS_BEMPENB_PIPE2BEMPE_Msk = 0x4
	// Bit PIPE2BEMPE.
	USBFS_BEMPENB_PIPE2BEMPE = 0x4
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE2BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE2BEMPE_1 = 0x1
	// Position of PIPE1BEMPE field.
	USBFS_BEMPENB_PIPE1BEMPE_Pos = 0x1
	// Bit mask of PIPE1BEMPE field.
	USBFS_BEMPENB_PIPE1BEMPE_Msk = 0x2
	// Bit PIPE1BEMPE.
	USBFS_BEMPENB_PIPE1BEMPE = 0x2
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE1BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE1BEMPE_1 = 0x1
	// Position of PIPE0BEMPE field.
	USBFS_BEMPENB_PIPE0BEMPE_Pos = 0x0
	// Bit mask of PIPE0BEMPE field.
	USBFS_BEMPENB_PIPE0BEMPE_Msk = 0x1
	// Bit PIPE0BEMPE.
	USBFS_BEMPENB_PIPE0BEMPE = 0x1
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE0BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE0BEMPE_1 = 0x1

	// SOFCFG: SOF Output Configuration Register
	// Position of Reserved field.
	USBFS_SOFCFG_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_SOFCFG_Reserved_Msk = 0xfe00
	// Position of TRNENSEL field.
	USBFS_SOFCFG_TRNENSEL_Pos = 0x8
	// Bit mask of TRNENSEL field.
	USBFS_SOFCFG_TRNENSEL_Msk = 0x100
	// Bit TRNENSEL.
	USBFS_SOFCFG_TRNENSEL = 0x100
	// Not low-speed communication
	USBFS_SOFCFG_TRNENSEL_0 = 0x0
	// Low-speed communication.
	USBFS_SOFCFG_TRNENSEL_1 = 0x1
	// Position of Reserved field.
	USBFS_SOFCFG_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	USBFS_SOFCFG_Reserved_Msk = 0x80
	// Bit Reserved.
	USBFS_SOFCFG_Reserved = 0x80
	// Position of BRDYM field.
	USBFS_SOFCFG_BRDYM_Pos = 0x6
	// Bit mask of BRDYM field.
	USBFS_SOFCFG_BRDYM_Msk = 0x40
	// Bit BRDYM.
	USBFS_SOFCFG_BRDYM = 0x40
	// BRDY flag cleared by software
	USBFS_SOFCFG_BRDYM_0 = 0x0
	// BRDY flag cleared by the USBFS through a data read from the FIFO buffer or data write to the FIFO buffer.
	USBFS_SOFCFG_BRDYM_1 = 0x1
	// Position of Reserved field.
	USBFS_SOFCFG_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	USBFS_SOFCFG_Reserved_Msk = 0x20
	// Bit Reserved.
	USBFS_SOFCFG_Reserved = 0x20
	// Position of EDGESTS field.
	USBFS_SOFCFG_EDGESTS_Pos = 0x4
	// Bit mask of EDGESTS field.
	USBFS_SOFCFG_EDGESTS_Msk = 0x10
	// Bit EDGESTS.
	USBFS_SOFCFG_EDGESTS = 0x10
	// before stopping the clock supply to the USB module
	USBFS_SOFCFG_EDGESTS_0 = 0x0
	// the edge interrupt output signal is in the middle of the edge processing
	USBFS_SOFCFG_EDGESTS_1 = 0x1
	// Position of Reserved field.
	USBFS_SOFCFG_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	USBFS_SOFCFG_Reserved_Msk = 0xf

	// INTSTS0: Interrupt Status Register 0
	// Position of VBINT field.
	USBFS_INTSTS0_VBINT_Pos = 0xf
	// Bit mask of VBINT field.
	USBFS_INTSTS0_VBINT_Msk = 0x8000
	// Bit VBINT.
	USBFS_INTSTS0_VBINT = 0x8000
	// VBUS interrupts are not generated.
	USBFS_INTSTS0_VBINT_0 = 0x0
	// VBUS interrupts are generated.
	USBFS_INTSTS0_VBINT_1 = 0x1
	// Position of RESM field.
	USBFS_INTSTS0_RESM_Pos = 0xe
	// Bit mask of RESM field.
	USBFS_INTSTS0_RESM_Msk = 0x4000
	// Bit RESM.
	USBFS_INTSTS0_RESM = 0x4000
	// Resume interrupts are not generated.
	USBFS_INTSTS0_RESM_0 = 0x0
	// Resume interrupts are generated.
	USBFS_INTSTS0_RESM_1 = 0x1
	// Position of SOFR field.
	USBFS_INTSTS0_SOFR_Pos = 0xd
	// Bit mask of SOFR field.
	USBFS_INTSTS0_SOFR_Msk = 0x2000
	// Bit SOFR.
	USBFS_INTSTS0_SOFR = 0x2000
	// SOF interrupts are not generated.
	USBFS_INTSTS0_SOFR_0 = 0x0
	// SOF interrupts are generated.
	USBFS_INTSTS0_SOFR_1 = 0x1
	// Position of DVST field.
	USBFS_INTSTS0_DVST_Pos = 0xc
	// Bit mask of DVST field.
	USBFS_INTSTS0_DVST_Msk = 0x1000
	// Bit DVST.
	USBFS_INTSTS0_DVST = 0x1000
	// Device state transition interrupts are not generated.
	USBFS_INTSTS0_DVST_0 = 0x0
	// Device state transition interrupts are generated.
	USBFS_INTSTS0_DVST_1 = 0x1
	// Position of CTRT field.
	USBFS_INTSTS0_CTRT_Pos = 0xb
	// Bit mask of CTRT field.
	USBFS_INTSTS0_CTRT_Msk = 0x800
	// Bit CTRT.
	USBFS_INTSTS0_CTRT = 0x800
	// Control transfer stage transition interrupts are not generated.
	USBFS_INTSTS0_CTRT_0 = 0x0
	// Control transfer stage transition interrupts are generated.
	USBFS_INTSTS0_CTRT_1 = 0x1
	// Position of BEMP field.
	USBFS_INTSTS0_BEMP_Pos = 0xa
	// Bit mask of BEMP field.
	USBFS_INTSTS0_BEMP_Msk = 0x400
	// Bit BEMP.
	USBFS_INTSTS0_BEMP = 0x400
	// BEMP interrupts are not generated.
	USBFS_INTSTS0_BEMP_0 = 0x0
	// BEMP interrupts are generated.
	USBFS_INTSTS0_BEMP_1 = 0x1
	// Position of NRDY field.
	USBFS_INTSTS0_NRDY_Pos = 0x9
	// Bit mask of NRDY field.
	USBFS_INTSTS0_NRDY_Msk = 0x200
	// Bit NRDY.
	USBFS_INTSTS0_NRDY = 0x200
	// NRDY interrupts are not generated.
	USBFS_INTSTS0_NRDY_0 = 0x0
	// NRDY interrupts are generated.
	USBFS_INTSTS0_NRDY_1 = 0x1
	// Position of BRDY field.
	USBFS_INTSTS0_BRDY_Pos = 0x8
	// Bit mask of BRDY field.
	USBFS_INTSTS0_BRDY_Msk = 0x100
	// Bit BRDY.
	USBFS_INTSTS0_BRDY = 0x100
	// BRDY interrupts are not generated.
	USBFS_INTSTS0_BRDY_0 = 0x0
	// BRDY interrupts are generated.
	USBFS_INTSTS0_BRDY_1 = 0x1
	// Position of VBSTS field.
	USBFS_INTSTS0_VBSTS_Pos = 0x7
	// Bit mask of VBSTS field.
	USBFS_INTSTS0_VBSTS_Msk = 0x80
	// Bit VBSTS.
	USBFS_INTSTS0_VBSTS = 0x80
	// USB_VBUS pin is low.
	USBFS_INTSTS0_VBSTS_0 = 0x0
	// USB_VBUS pin is high.
	USBFS_INTSTS0_VBSTS_1 = 0x1
	// Position of DVSQ field.
	USBFS_INTSTS0_DVSQ_Pos = 0x4
	// Bit mask of DVSQ field.
	USBFS_INTSTS0_DVSQ_Msk = 0x70
	// Powered state
	USBFS_INTSTS0_DVSQ_000 = 0x0
	// Default state
	USBFS_INTSTS0_DVSQ_001 = 0x1
	// Address state
	USBFS_INTSTS0_DVSQ_010 = 0x2
	// Configured state
	USBFS_INTSTS0_DVSQ_011 = 0x3
	// Position of VALID field.
	USBFS_INTSTS0_VALID_Pos = 0x3
	// Bit mask of VALID field.
	USBFS_INTSTS0_VALID_Msk = 0x8
	// Bit VALID.
	USBFS_INTSTS0_VALID = 0x8
	// Setup packet is not received
	USBFS_INTSTS0_VALID_0 = 0x0
	// Setup packet is received
	USBFS_INTSTS0_VALID_1 = 0x1
	// Position of CTSQ field.
	USBFS_INTSTS0_CTSQ_Pos = 0x0
	// Bit mask of CTSQ field.
	USBFS_INTSTS0_CTSQ_Msk = 0x7
	// Idle or setup stage
	USBFS_INTSTS0_CTSQ_000 = 0x0
	// Control read data stage
	USBFS_INTSTS0_CTSQ_001 = 0x1
	// Control read status stage
	USBFS_INTSTS0_CTSQ_010 = 0x2
	// Control write data stage
	USBFS_INTSTS0_CTSQ_011 = 0x3
	// Control write status stage
	USBFS_INTSTS0_CTSQ_100 = 0x4
	// Control write (no data) status stage
	USBFS_INTSTS0_CTSQ_101 = 0x5
	// Control transfer sequence error
	USBFS_INTSTS0_CTSQ_110 = 0x6

	// INTSTS1: Interrupt Status Register 1
	// Position of OVRCR field.
	USBFS_INTSTS1_OVRCR_Pos = 0xf
	// Bit mask of OVRCR field.
	USBFS_INTSTS1_OVRCR_Msk = 0x8000
	// Bit OVRCR.
	USBFS_INTSTS1_OVRCR = 0x8000
	// OVRCR interrupts are not generated.
	USBFS_INTSTS1_OVRCR_0 = 0x0
	// OVRCR interrupts are generated.
	USBFS_INTSTS1_OVRCR_1 = 0x1
	// Position of BCHG field.
	USBFS_INTSTS1_BCHG_Pos = 0xe
	// Bit mask of BCHG field.
	USBFS_INTSTS1_BCHG_Msk = 0x4000
	// Bit BCHG.
	USBFS_INTSTS1_BCHG = 0x4000
	// BCHG interrupts are not generated.
	USBFS_INTSTS1_BCHG_0 = 0x0
	// BCHG interrupts are generated.
	USBFS_INTSTS1_BCHG_1 = 0x1
	// Position of Reserved field.
	USBFS_INTSTS1_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	USBFS_INTSTS1_Reserved_Msk = 0x2000
	// Bit Reserved.
	USBFS_INTSTS1_Reserved = 0x2000
	// Position of DTCH field.
	USBFS_INTSTS1_DTCH_Pos = 0xc
	// Bit mask of DTCH field.
	USBFS_INTSTS1_DTCH_Msk = 0x1000
	// Bit DTCH.
	USBFS_INTSTS1_DTCH = 0x1000
	// DTCH interrupts are not generated.
	USBFS_INTSTS1_DTCH_0 = 0x0
	// DTCH interrupts are generated.
	USBFS_INTSTS1_DTCH_1 = 0x1
	// Position of ATTCH field.
	USBFS_INTSTS1_ATTCH_Pos = 0xb
	// Bit mask of ATTCH field.
	USBFS_INTSTS1_ATTCH_Msk = 0x800
	// Bit ATTCH.
	USBFS_INTSTS1_ATTCH = 0x800
	// ATTCH interrupts are not generated.
	USBFS_INTSTS1_ATTCH_0 = 0x0
	// ATTCH interrupts are generated.
	USBFS_INTSTS1_ATTCH_1 = 0x1
	// Position of Reserved field.
	USBFS_INTSTS1_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	USBFS_INTSTS1_Reserved_Msk = 0x780
	// Position of EOFERR field.
	USBFS_INTSTS1_EOFERR_Pos = 0x6
	// Bit mask of EOFERR field.
	USBFS_INTSTS1_EOFERR_Msk = 0x40
	// Bit EOFERR.
	USBFS_INTSTS1_EOFERR = 0x40
	// EOFERR interrupts are not generated.
	USBFS_INTSTS1_EOFERR_0 = 0x0
	// EOFERR interrupts are generated.
	USBFS_INTSTS1_EOFERR_1 = 0x1
	// Position of SIGN field.
	USBFS_INTSTS1_SIGN_Pos = 0x5
	// Bit mask of SIGN field.
	USBFS_INTSTS1_SIGN_Msk = 0x20
	// Bit SIGN.
	USBFS_INTSTS1_SIGN = 0x20
	// SIGN interrupts are not generated.
	USBFS_INTSTS1_SIGN_0 = 0x0
	// SIGN interrupts are generated.
	USBFS_INTSTS1_SIGN_1 = 0x1
	// Position of SACK field.
	USBFS_INTSTS1_SACK_Pos = 0x4
	// Bit mask of SACK field.
	USBFS_INTSTS1_SACK_Msk = 0x10
	// Bit SACK.
	USBFS_INTSTS1_SACK = 0x10
	// SACK interrupts are not generated.
	USBFS_INTSTS1_SACK_0 = 0x0
	// SACK interrupts are generated.
	USBFS_INTSTS1_SACK_1 = 0x1
	// Position of Reserved field.
	USBFS_INTSTS1_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	USBFS_INTSTS1_Reserved_Msk = 0xe
	// Position of PDDETINT0 field.
	USBFS_INTSTS1_PDDETINT0_Pos = 0x0
	// Bit mask of PDDETINT0 field.
	USBFS_INTSTS1_PDDETINT0_Msk = 0x1
	// Bit PDDETINT0.
	USBFS_INTSTS1_PDDETINT0 = 0x1
	// PDDET0 detection interrupts are not generated.
	USBFS_INTSTS1_PDDETINT0_0 = 0x0
	// PDDET0 detection interrupts are generated.
	USBFS_INTSTS1_PDDETINT0_1 = 0x1

	// BRDYSTS: BRDY Interrupt Status Register
	// Position of Reserved field.
	USBFS_BRDYSTS_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_BRDYSTS_Reserved_Msk = 0xfc00
	// Position of PIPE9BRDY field.
	USBFS_BRDYSTS_PIPE9BRDY_Pos = 0x9
	// Bit mask of PIPE9BRDY field.
	USBFS_BRDYSTS_PIPE9BRDY_Msk = 0x200
	// Bit PIPE9BRDY.
	USBFS_BRDYSTS_PIPE9BRDY = 0x200
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE9BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE9BRDY_1 = 0x1
	// Position of PIPE8BRDY field.
	USBFS_BRDYSTS_PIPE8BRDY_Pos = 0x8
	// Bit mask of PIPE8BRDY field.
	USBFS_BRDYSTS_PIPE8BRDY_Msk = 0x100
	// Bit PIPE8BRDY.
	USBFS_BRDYSTS_PIPE8BRDY = 0x100
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE8BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE8BRDY_1 = 0x1
	// Position of PIPE7BRDY field.
	USBFS_BRDYSTS_PIPE7BRDY_Pos = 0x7
	// Bit mask of PIPE7BRDY field.
	USBFS_BRDYSTS_PIPE7BRDY_Msk = 0x80
	// Bit PIPE7BRDY.
	USBFS_BRDYSTS_PIPE7BRDY = 0x80
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE7BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE7BRDY_1 = 0x1
	// Position of PIPE6BRDY field.
	USBFS_BRDYSTS_PIPE6BRDY_Pos = 0x6
	// Bit mask of PIPE6BRDY field.
	USBFS_BRDYSTS_PIPE6BRDY_Msk = 0x40
	// Bit PIPE6BRDY.
	USBFS_BRDYSTS_PIPE6BRDY = 0x40
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE6BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE6BRDY_1 = 0x1
	// Position of PIPE5BRDY field.
	USBFS_BRDYSTS_PIPE5BRDY_Pos = 0x5
	// Bit mask of PIPE5BRDY field.
	USBFS_BRDYSTS_PIPE5BRDY_Msk = 0x20
	// Bit PIPE5BRDY.
	USBFS_BRDYSTS_PIPE5BRDY = 0x20
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE5BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE5BRDY_1 = 0x1
	// Position of PIPE4BRDY field.
	USBFS_BRDYSTS_PIPE4BRDY_Pos = 0x4
	// Bit mask of PIPE4BRDY field.
	USBFS_BRDYSTS_PIPE4BRDY_Msk = 0x10
	// Bit PIPE4BRDY.
	USBFS_BRDYSTS_PIPE4BRDY = 0x10
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE4BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE4BRDY_1 = 0x1
	// Position of PIPE3BRDY field.
	USBFS_BRDYSTS_PIPE3BRDY_Pos = 0x3
	// Bit mask of PIPE3BRDY field.
	USBFS_BRDYSTS_PIPE3BRDY_Msk = 0x8
	// Bit PIPE3BRDY.
	USBFS_BRDYSTS_PIPE3BRDY = 0x8
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE3BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE3BRDY_1 = 0x1
	// Position of PIPE2BRDY field.
	USBFS_BRDYSTS_PIPE2BRDY_Pos = 0x2
	// Bit mask of PIPE2BRDY field.
	USBFS_BRDYSTS_PIPE2BRDY_Msk = 0x4
	// Bit PIPE2BRDY.
	USBFS_BRDYSTS_PIPE2BRDY = 0x4
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE2BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE2BRDY_1 = 0x1
	// Position of PIPE1BRDY field.
	USBFS_BRDYSTS_PIPE1BRDY_Pos = 0x1
	// Bit mask of PIPE1BRDY field.
	USBFS_BRDYSTS_PIPE1BRDY_Msk = 0x2
	// Bit PIPE1BRDY.
	USBFS_BRDYSTS_PIPE1BRDY = 0x2
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE1BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE1BRDY_1 = 0x1
	// Position of PIPE0BRDY field.
	USBFS_BRDYSTS_PIPE0BRDY_Pos = 0x0
	// Bit mask of PIPE0BRDY field.
	USBFS_BRDYSTS_PIPE0BRDY_Msk = 0x1
	// Bit PIPE0BRDY.
	USBFS_BRDYSTS_PIPE0BRDY = 0x1
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE0BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE0BRDY_1 = 0x1

	// NRDYSTS: NRDY Interrupt Status Register
	// Position of Reserved field.
	USBFS_NRDYSTS_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_NRDYSTS_Reserved_Msk = 0xfc00
	// Position of PIPE9NRDY field.
	USBFS_NRDYSTS_PIPE9NRDY_Pos = 0x9
	// Bit mask of PIPE9NRDY field.
	USBFS_NRDYSTS_PIPE9NRDY_Msk = 0x200
	// Bit PIPE9NRDY.
	USBFS_NRDYSTS_PIPE9NRDY = 0x200
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE9NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE9NRDY_1 = 0x1
	// Position of PIPE8NRDY field.
	USBFS_NRDYSTS_PIPE8NRDY_Pos = 0x8
	// Bit mask of PIPE8NRDY field.
	USBFS_NRDYSTS_PIPE8NRDY_Msk = 0x100
	// Bit PIPE8NRDY.
	USBFS_NRDYSTS_PIPE8NRDY = 0x100
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE8NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE8NRDY_1 = 0x1
	// Position of PIPE7NRDY field.
	USBFS_NRDYSTS_PIPE7NRDY_Pos = 0x7
	// Bit mask of PIPE7NRDY field.
	USBFS_NRDYSTS_PIPE7NRDY_Msk = 0x80
	// Bit PIPE7NRDY.
	USBFS_NRDYSTS_PIPE7NRDY = 0x80
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE7NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE7NRDY_1 = 0x1
	// Position of PIPE6NRDY field.
	USBFS_NRDYSTS_PIPE6NRDY_Pos = 0x6
	// Bit mask of PIPE6NRDY field.
	USBFS_NRDYSTS_PIPE6NRDY_Msk = 0x40
	// Bit PIPE6NRDY.
	USBFS_NRDYSTS_PIPE6NRDY = 0x40
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE6NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE6NRDY_1 = 0x1
	// Position of PIPE5NRDY field.
	USBFS_NRDYSTS_PIPE5NRDY_Pos = 0x5
	// Bit mask of PIPE5NRDY field.
	USBFS_NRDYSTS_PIPE5NRDY_Msk = 0x20
	// Bit PIPE5NRDY.
	USBFS_NRDYSTS_PIPE5NRDY = 0x20
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE5NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE5NRDY_1 = 0x1
	// Position of PIPE4NRDY field.
	USBFS_NRDYSTS_PIPE4NRDY_Pos = 0x4
	// Bit mask of PIPE4NRDY field.
	USBFS_NRDYSTS_PIPE4NRDY_Msk = 0x10
	// Bit PIPE4NRDY.
	USBFS_NRDYSTS_PIPE4NRDY = 0x10
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE4NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE4NRDY_1 = 0x1
	// Position of PIPE3NRDY field.
	USBFS_NRDYSTS_PIPE3NRDY_Pos = 0x3
	// Bit mask of PIPE3NRDY field.
	USBFS_NRDYSTS_PIPE3NRDY_Msk = 0x8
	// Bit PIPE3NRDY.
	USBFS_NRDYSTS_PIPE3NRDY = 0x8
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE3NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE3NRDY_1 = 0x1
	// Position of PIPE2NRDY field.
	USBFS_NRDYSTS_PIPE2NRDY_Pos = 0x2
	// Bit mask of PIPE2NRDY field.
	USBFS_NRDYSTS_PIPE2NRDY_Msk = 0x4
	// Bit PIPE2NRDY.
	USBFS_NRDYSTS_PIPE2NRDY = 0x4
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE2NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE2NRDY_1 = 0x1
	// Position of PIPE1NRDY field.
	USBFS_NRDYSTS_PIPE1NRDY_Pos = 0x1
	// Bit mask of PIPE1NRDY field.
	USBFS_NRDYSTS_PIPE1NRDY_Msk = 0x2
	// Bit PIPE1NRDY.
	USBFS_NRDYSTS_PIPE1NRDY = 0x2
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE1NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE1NRDY_1 = 0x1
	// Position of PIPE0NRDY field.
	USBFS_NRDYSTS_PIPE0NRDY_Pos = 0x0
	// Bit mask of PIPE0NRDY field.
	USBFS_NRDYSTS_PIPE0NRDY_Msk = 0x1
	// Bit PIPE0NRDY.
	USBFS_NRDYSTS_PIPE0NRDY = 0x1
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE0NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE0NRDY_1 = 0x1

	// BEMPSTS: BEMP Interrupt Status Register
	// Position of Reserved field.
	USBFS_BEMPSTS_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_BEMPSTS_Reserved_Msk = 0xfc00
	// Position of PIPE9BEMP field.
	USBFS_BEMPSTS_PIPE9BEMP_Pos = 0x9
	// Bit mask of PIPE9BEMP field.
	USBFS_BEMPSTS_PIPE9BEMP_Msk = 0x200
	// Bit PIPE9BEMP.
	USBFS_BEMPSTS_PIPE9BEMP = 0x200
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE9BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE9BEMP_1 = 0x1
	// Position of PIPE8BEMP field.
	USBFS_BEMPSTS_PIPE8BEMP_Pos = 0x8
	// Bit mask of PIPE8BEMP field.
	USBFS_BEMPSTS_PIPE8BEMP_Msk = 0x100
	// Bit PIPE8BEMP.
	USBFS_BEMPSTS_PIPE8BEMP = 0x100
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE8BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE8BEMP_1 = 0x1
	// Position of PIPE7BEMP field.
	USBFS_BEMPSTS_PIPE7BEMP_Pos = 0x7
	// Bit mask of PIPE7BEMP field.
	USBFS_BEMPSTS_PIPE7BEMP_Msk = 0x80
	// Bit PIPE7BEMP.
	USBFS_BEMPSTS_PIPE7BEMP = 0x80
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE7BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE7BEMP_1 = 0x1
	// Position of PIPE6BEMP field.
	USBFS_BEMPSTS_PIPE6BEMP_Pos = 0x6
	// Bit mask of PIPE6BEMP field.
	USBFS_BEMPSTS_PIPE6BEMP_Msk = 0x40
	// Bit PIPE6BEMP.
	USBFS_BEMPSTS_PIPE6BEMP = 0x40
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE6BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE6BEMP_1 = 0x1
	// Position of PIPE5BEMP field.
	USBFS_BEMPSTS_PIPE5BEMP_Pos = 0x5
	// Bit mask of PIPE5BEMP field.
	USBFS_BEMPSTS_PIPE5BEMP_Msk = 0x20
	// Bit PIPE5BEMP.
	USBFS_BEMPSTS_PIPE5BEMP = 0x20
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE5BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE5BEMP_1 = 0x1
	// Position of PIPE4BEMP field.
	USBFS_BEMPSTS_PIPE4BEMP_Pos = 0x4
	// Bit mask of PIPE4BEMP field.
	USBFS_BEMPSTS_PIPE4BEMP_Msk = 0x10
	// Bit PIPE4BEMP.
	USBFS_BEMPSTS_PIPE4BEMP = 0x10
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE4BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE4BEMP_1 = 0x1
	// Position of PIPE3BEMP field.
	USBFS_BEMPSTS_PIPE3BEMP_Pos = 0x3
	// Bit mask of PIPE3BEMP field.
	USBFS_BEMPSTS_PIPE3BEMP_Msk = 0x8
	// Bit PIPE3BEMP.
	USBFS_BEMPSTS_PIPE3BEMP = 0x8
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE3BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE3BEMP_1 = 0x1
	// Position of PIPE2BEMP field.
	USBFS_BEMPSTS_PIPE2BEMP_Pos = 0x2
	// Bit mask of PIPE2BEMP field.
	USBFS_BEMPSTS_PIPE2BEMP_Msk = 0x4
	// Bit PIPE2BEMP.
	USBFS_BEMPSTS_PIPE2BEMP = 0x4
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE2BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE2BEMP_1 = 0x1
	// Position of PIPE1BEMP field.
	USBFS_BEMPSTS_PIPE1BEMP_Pos = 0x1
	// Bit mask of PIPE1BEMP field.
	USBFS_BEMPSTS_PIPE1BEMP_Msk = 0x2
	// Bit PIPE1BEMP.
	USBFS_BEMPSTS_PIPE1BEMP = 0x2
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE1BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE1BEMP_1 = 0x1
	// Position of PIPE0BEMP field.
	USBFS_BEMPSTS_PIPE0BEMP_Pos = 0x0
	// Bit mask of PIPE0BEMP field.
	USBFS_BEMPSTS_PIPE0BEMP_Msk = 0x1
	// Bit PIPE0BEMP.
	USBFS_BEMPSTS_PIPE0BEMP = 0x1
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE0BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE0BEMP_1 = 0x1

	// FRMNUM: Frame Number Register
	// Position of OVRN field.
	USBFS_FRMNUM_OVRN_Pos = 0xf
	// Bit mask of OVRN field.
	USBFS_FRMNUM_OVRN_Msk = 0x8000
	// Bit OVRN.
	USBFS_FRMNUM_OVRN = 0x8000
	// No error
	USBFS_FRMNUM_OVRN_0 = 0x0
	// An error occurred
	USBFS_FRMNUM_OVRN_1 = 0x1
	// Position of CRCE field.
	USBFS_FRMNUM_CRCE_Pos = 0xe
	// Bit mask of CRCE field.
	USBFS_FRMNUM_CRCE_Msk = 0x4000
	// Bit CRCE.
	USBFS_FRMNUM_CRCE = 0x4000
	// No error
	USBFS_FRMNUM_CRCE_0 = 0x0
	// An error occurred
	USBFS_FRMNUM_CRCE_1 = 0x1
	// Position of Reserved field.
	USBFS_FRMNUM_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	USBFS_FRMNUM_Reserved_Msk = 0x3800
	// Position of FRNM field.
	USBFS_FRMNUM_FRNM_Pos = 0x0
	// Bit mask of FRNM field.
	USBFS_FRMNUM_FRNM_Msk = 0x7ff

	// USBREQ: USB Request Type Register
	// Position of BREQUEST field.
	USBFS_USBREQ_BREQUEST_Pos = 0x8
	// Bit mask of BREQUEST field.
	USBFS_USBREQ_BREQUEST_Msk = 0xff00
	// Position of BMREQUESTTYPE field.
	USBFS_USBREQ_BMREQUESTTYPE_Pos = 0x0
	// Bit mask of BMREQUESTTYPE field.
	USBFS_USBREQ_BMREQUESTTYPE_Msk = 0xff

	// USBVAL: USB Request Value Register
	// Position of WVALUE field.
	USBFS_USBVAL_WVALUE_Pos = 0x0
	// Bit mask of WVALUE field.
	USBFS_USBVAL_WVALUE_Msk = 0xffff

	// USBINDX: USB Request Index Register
	// Position of WINDEX field.
	USBFS_USBINDX_WINDEX_Pos = 0x0
	// Bit mask of WINDEX field.
	USBFS_USBINDX_WINDEX_Msk = 0xffff

	// USBLENG: USB Request Length Register
	// Position of WLENGTH field.
	USBFS_USBLENG_WLENGTH_Pos = 0x0
	// Bit mask of WLENGTH field.
	USBFS_USBLENG_WLENGTH_Msk = 0xffff

	// DCPCFG: DCP Configuration Register
	// Position of Reserved field.
	USBFS_DCPCFG_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	USBFS_DCPCFG_Reserved_Msk = 0xff00
	// Position of SHTNAK field.
	USBFS_DCPCFG_SHTNAK_Pos = 0x7
	// Bit mask of SHTNAK field.
	USBFS_DCPCFG_SHTNAK_Msk = 0x80
	// Bit SHTNAK.
	USBFS_DCPCFG_SHTNAK = 0x80
	// Pipe continued at the end of transfer
	USBFS_DCPCFG_SHTNAK_0 = 0x0
	// Pipe disabled at the end of transfer
	USBFS_DCPCFG_SHTNAK_1 = 0x1
	// Position of Reserved field.
	USBFS_DCPCFG_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	USBFS_DCPCFG_Reserved_Msk = 0x60
	// Position of DIR field.
	USBFS_DCPCFG_DIR_Pos = 0x4
	// Bit mask of DIR field.
	USBFS_DCPCFG_DIR_Msk = 0x10
	// Bit DIR.
	USBFS_DCPCFG_DIR = 0x10
	// Data receiving direction
	USBFS_DCPCFG_DIR_0 = 0x0
	// Data transmitting direction
	USBFS_DCPCFG_DIR_1 = 0x1
	// Position of Reserved field.
	USBFS_DCPCFG_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	USBFS_DCPCFG_Reserved_Msk = 0xf

	// DCPMAXP: DCP Maximum Packet Size Register
	// Position of DEVSEL field.
	USBFS_DCPMAXP_DEVSEL_Pos = 0xc
	// Bit mask of DEVSEL field.
	USBFS_DCPMAXP_DEVSEL_Msk = 0xf000
	// Address 0000
	USBFS_DCPMAXP_DEVSEL_0000 = 0x0
	// Address 0001
	USBFS_DCPMAXP_DEVSEL_0001 = 0x1
	// Address 0010
	USBFS_DCPMAXP_DEVSEL_0010 = 0x2
	// Address 0011
	USBFS_DCPMAXP_DEVSEL_0011 = 0x3
	// Address 0100
	USBFS_DCPMAXP_DEVSEL_0100 = 0x4
	// Address 0101
	USBFS_DCPMAXP_DEVSEL_0101 = 0x5
	// Position of Reserved field.
	USBFS_DCPMAXP_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	USBFS_DCPMAXP_Reserved_Msk = 0xf80
	// Position of MXPS field.
	USBFS_DCPMAXP_MXPS_Pos = 0x0
	// Bit mask of MXPS field.
	USBFS_DCPMAXP_MXPS_Msk = 0x7f
	// 8 bytes
	USBFS_DCPMAXP_MXPS_0x08 = 0x8
	// 16 bytes
	USBFS_DCPMAXP_MXPS_0x10 = 0x10
	// 24 bytes
	USBFS_DCPMAXP_MXPS_0x18 = 0x18
	// 32 bytes
	USBFS_DCPMAXP_MXPS_0x20 = 0x20
	// 40 bytes
	USBFS_DCPMAXP_MXPS_0x28 = 0x28
	// 48 bytes
	USBFS_DCPMAXP_MXPS_0x30 = 0x30
	// 56 bytes
	USBFS_DCPMAXP_MXPS_0x38 = 0x38
	// 64 bytes
	USBFS_DCPMAXP_MXPS_0x40 = 0x40
	// 72 bytes
	USBFS_DCPMAXP_MXPS_0x48 = 0x48
	// 80 bytes
	USBFS_DCPMAXP_MXPS_0x50 = 0x50
	// 88 bytes
	USBFS_DCPMAXP_MXPS_0x58 = 0x58
	// 96 bytes
	USBFS_DCPMAXP_MXPS_0x60 = 0x60
	// 104 bytes
	USBFS_DCPMAXP_MXPS_0x68 = 0x68
	// 112 bytes
	USBFS_DCPMAXP_MXPS_0x70 = 0x70
	// 120 bytes
	USBFS_DCPMAXP_MXPS_0x78 = 0x78

	// DCPCTR: DCP Control Register
	// Position of BSTS field.
	USBFS_DCPCTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBFS_DCPCTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBFS_DCPCTR_BSTS = 0x8000
	// Buffer access is disabled.
	USBFS_DCPCTR_BSTS_0 = 0x0
	// Buffer access is enabled.
	USBFS_DCPCTR_BSTS_1 = 0x1
	// Position of SUREQ field.
	USBFS_DCPCTR_SUREQ_Pos = 0xe
	// Bit mask of SUREQ field.
	USBFS_DCPCTR_SUREQ_Msk = 0x4000
	// Bit SUREQ.
	USBFS_DCPCTR_SUREQ = 0x4000
	// Invalid
	USBFS_DCPCTR_SUREQ_0 = 0x0
	// Transmits the setup packet.
	USBFS_DCPCTR_SUREQ_1 = 0x1
	// Position of Reserved field.
	USBFS_DCPCTR_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	USBFS_DCPCTR_Reserved_Msk = 0x3000
	// Position of SUREQCLR field.
	USBFS_DCPCTR_SUREQCLR_Pos = 0xb
	// Bit mask of SUREQCLR field.
	USBFS_DCPCTR_SUREQCLR_Msk = 0x800
	// Bit SUREQCLR.
	USBFS_DCPCTR_SUREQCLR = 0x800
	// Invalid
	USBFS_DCPCTR_SUREQCLR_0 = 0x0
	// Clears the SUREQ bit to 0.
	USBFS_DCPCTR_SUREQCLR_1 = 0x1
	// Position of Reserved field.
	USBFS_DCPCTR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_DCPCTR_Reserved_Msk = 0x600
	// Position of SQCLR field.
	USBFS_DCPCTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBFS_DCPCTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBFS_DCPCTR_SQCLR = 0x100
	// Invalid
	USBFS_DCPCTR_SQCLR_0 = 0x0
	// Specifies DATA0.
	USBFS_DCPCTR_SQCLR_1 = 0x1
	// Position of SQSET field.
	USBFS_DCPCTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBFS_DCPCTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBFS_DCPCTR_SQSET = 0x80
	// Invalid
	USBFS_DCPCTR_SQSET_0 = 0x0
	// Specifies DATA1.
	USBFS_DCPCTR_SQSET_1 = 0x1
	// Position of SQMON field.
	USBFS_DCPCTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBFS_DCPCTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBFS_DCPCTR_SQMON = 0x40
	// DATA0
	USBFS_DCPCTR_SQMON_0 = 0x0
	// DATA1
	USBFS_DCPCTR_SQMON_1 = 0x1
	// Position of PBUSY field.
	USBFS_DCPCTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBFS_DCPCTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBFS_DCPCTR_PBUSY = 0x20
	// DCP is not used for the transaction.
	USBFS_DCPCTR_PBUSY_0 = 0x0
	// DCP is used for the transaction.
	USBFS_DCPCTR_PBUSY_1 = 0x1
	// Position of Reserved field.
	USBFS_DCPCTR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	USBFS_DCPCTR_Reserved_Msk = 0x18
	// Position of CCPL field.
	USBFS_DCPCTR_CCPL_Pos = 0x2
	// Bit mask of CCPL field.
	USBFS_DCPCTR_CCPL_Msk = 0x4
	// Bit CCPL.
	USBFS_DCPCTR_CCPL = 0x4
	// Invalid
	USBFS_DCPCTR_CCPL_0 = 0x0
	// Completion of control transfer is enabled.
	USBFS_DCPCTR_CCPL_1 = 0x1
	// Position of PID field.
	USBFS_DCPCTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBFS_DCPCTR_PID_Msk = 0x3
	// NAK response
	USBFS_DCPCTR_PID_00 = 0x0
	// BUF response (depending on the buffer state)
	USBFS_DCPCTR_PID_01 = 0x1
	// STALL response
	USBFS_DCPCTR_PID_10 = 0x2
	// STALL response
	USBFS_DCPCTR_PID_11 = 0x3

	// PIPESEL: Pipe Window Select Register
	// Position of Reserved field.
	USBFS_PIPESEL_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	USBFS_PIPESEL_Reserved_Msk = 0xfff0
	// Position of PIPESEL field.
	USBFS_PIPESEL_PIPESEL_Pos = 0x0
	// Bit mask of PIPESEL field.
	USBFS_PIPESEL_PIPESEL_Msk = 0xf
	// No pipe selected
	USBFS_PIPESEL_PIPESEL_0000 = 0x0
	// PIPE1
	USBFS_PIPESEL_PIPESEL_0001 = 0x1
	// PIPE2
	USBFS_PIPESEL_PIPESEL_0010 = 0x2
	// PIPE3
	USBFS_PIPESEL_PIPESEL_0011 = 0x3
	// PIPE4
	USBFS_PIPESEL_PIPESEL_0100 = 0x4
	// PIPE5
	USBFS_PIPESEL_PIPESEL_0101 = 0x5
	// PIPE6
	USBFS_PIPESEL_PIPESEL_0110 = 0x6
	// PIPE7
	USBFS_PIPESEL_PIPESEL_0111 = 0x7
	// PIPE8
	USBFS_PIPESEL_PIPESEL_1000 = 0x8
	// PIPE9
	USBFS_PIPESEL_PIPESEL_1001 = 0x9

	// PIPECFG: Pipe Configuration Register
	// Position of TYPE field.
	USBFS_PIPECFG_TYPE_Pos = 0xe
	// Bit mask of TYPE field.
	USBFS_PIPECFG_TYPE_Msk = 0xc000
	// Pipe not used
	USBFS_PIPECFG_TYPE_00 = 0x0
	// Bulk transfer(PIPE1 and PIPE5) /Setting prohibited(PIPE6 to PIPE9)
	USBFS_PIPECFG_TYPE_01 = 0x1
	// Setting prohibited(PIPE1 and PIPE5) /Interrupt transfer(PIPE6 to PIPE9)
	USBFS_PIPECFG_TYPE_10 = 0x2
	// Isochronous transfer(PIPE1 and PIPE2) /Setting prohibited(PIPE3 to PIPE9)
	USBFS_PIPECFG_TYPE_11 = 0x3
	// Position of Reserved field.
	USBFS_PIPECFG_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	USBFS_PIPECFG_Reserved_Msk = 0x3800
	// Position of BFRE field.
	USBFS_PIPECFG_BFRE_Pos = 0xa
	// Bit mask of BFRE field.
	USBFS_PIPECFG_BFRE_Msk = 0x400
	// Bit BFRE.
	USBFS_PIPECFG_BFRE = 0x400
	// BRDY interrupt upon transmitting or receiving data
	USBFS_PIPECFG_BFRE_0 = 0x0
	// BRDY interrupt upon completion of reading data
	USBFS_PIPECFG_BFRE_1 = 0x1
	// Position of DBLB field.
	USBFS_PIPECFG_DBLB_Pos = 0x9
	// Bit mask of DBLB field.
	USBFS_PIPECFG_DBLB_Msk = 0x200
	// Bit DBLB.
	USBFS_PIPECFG_DBLB = 0x200
	// Single buffer
	USBFS_PIPECFG_DBLB_0 = 0x0
	// Double buffer
	USBFS_PIPECFG_DBLB_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPECFG_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	USBFS_PIPECFG_Reserved_Msk = 0x100
	// Bit Reserved.
	USBFS_PIPECFG_Reserved = 0x100
	// Position of SHTNAK field.
	USBFS_PIPECFG_SHTNAK_Pos = 0x7
	// Bit mask of SHTNAK field.
	USBFS_PIPECFG_SHTNAK_Msk = 0x80
	// Bit SHTNAK.
	USBFS_PIPECFG_SHTNAK = 0x80
	// Continue pipe operation after transfer ends
	USBFS_PIPECFG_SHTNAK_0 = 0x0
	// Disable pipe operation after transfer ends.
	USBFS_PIPECFG_SHTNAK_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPECFG_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	USBFS_PIPECFG_Reserved_Msk = 0x40
	// Bit Reserved.
	USBFS_PIPECFG_Reserved = 0x40
	// Position of Reserved field.
	USBFS_PIPECFG_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	USBFS_PIPECFG_Reserved_Msk = 0x20
	// Bit Reserved.
	USBFS_PIPECFG_Reserved = 0x20
	// Position of DIR field.
	USBFS_PIPECFG_DIR_Pos = 0x4
	// Bit mask of DIR field.
	USBFS_PIPECFG_DIR_Msk = 0x10
	// Bit DIR.
	USBFS_PIPECFG_DIR = 0x10
	// Receiving direction
	USBFS_PIPECFG_DIR_0 = 0x0
	// Transmitting direction
	USBFS_PIPECFG_DIR_1 = 0x1
	// Position of EPNUM field.
	USBFS_PIPECFG_EPNUM_Pos = 0x0
	// Bit mask of EPNUM field.
	USBFS_PIPECFG_EPNUM_Msk = 0xf

	// PIPEMAXP: Pipe Maximum Packet Size Register
	// Position of DEVSEL field.
	USBFS_PIPEMAXP_DEVSEL_Pos = 0xc
	// Bit mask of DEVSEL field.
	USBFS_PIPEMAXP_DEVSEL_Msk = 0xf000
	// Address 0000
	USBFS_PIPEMAXP_DEVSEL_0000 = 0x0
	// Address 0001
	USBFS_PIPEMAXP_DEVSEL_0001 = 0x1
	// Address 0010
	USBFS_PIPEMAXP_DEVSEL_0010 = 0x2
	// Address 0011
	USBFS_PIPEMAXP_DEVSEL_0011 = 0x3
	// Address 0100
	USBFS_PIPEMAXP_DEVSEL_0100 = 0x4
	// Address 0101
	USBFS_PIPEMAXP_DEVSEL_0101 = 0x5
	// Position of Reserved field.
	USBFS_PIPEMAXP_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_PIPEMAXP_Reserved_Msk = 0xe00
	// Position of MXPS field.
	USBFS_PIPEMAXP_MXPS_Pos = 0x0
	// Bit mask of MXPS field.
	USBFS_PIPEMAXP_MXPS_Msk = 0x1ff

	// PIPEPERI: Pipe Cycle Control Register
	// Position of Reserved field.
	USBFS_PIPEPERI_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	USBFS_PIPEPERI_Reserved_Msk = 0xe000
	// Position of IFIS field.
	USBFS_PIPEPERI_IFIS_Pos = 0xc
	// Bit mask of IFIS field.
	USBFS_PIPEPERI_IFIS_Msk = 0x1000
	// Bit IFIS.
	USBFS_PIPEPERI_IFIS = 0x1000
	// The buffer is not flushed.
	USBFS_PIPEPERI_IFIS_0 = 0x0
	// The buffer is flushed.
	USBFS_PIPEPERI_IFIS_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPEPERI_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	USBFS_PIPEPERI_Reserved_Msk = 0xff8
	// Position of IITV field.
	USBFS_PIPEPERI_IITV_Pos = 0x0
	// Bit mask of IITV field.
	USBFS_PIPEPERI_IITV_Msk = 0x7

	// PIPE1CTR: Pipe %s Control Register
	// Position of BSTS field.
	USBFS_PIPECTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBFS_PIPECTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBFS_PIPECTR_BSTS = 0x8000
	// Buffer access by the CPU is disabled.
	USBFS_PIPECTR_BSTS_0 = 0x0
	// Buffer access by the CPU is enabled.
	USBFS_PIPECTR_BSTS_1 = 0x1
	// Position of INBUFM field.
	USBFS_PIPECTR_INBUFM_Pos = 0xe
	// Bit mask of INBUFM field.
	USBFS_PIPECTR_INBUFM_Msk = 0x4000
	// Bit INBUFM.
	USBFS_PIPECTR_INBUFM = 0x4000
	// No data to be transmitted is in the FIFO buffer
	USBFS_PIPECTR_INBUFM_0 = 0x0
	// Data to be transmitted is in the FIFO buffer
	USBFS_PIPECTR_INBUFM_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPECTR_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	USBFS_PIPECTR_Reserved_Msk = 0x3800
	// Position of ATREPM field.
	USBFS_PIPECTR_ATREPM_Pos = 0xa
	// Bit mask of ATREPM field.
	USBFS_PIPECTR_ATREPM_Msk = 0x400
	// Bit ATREPM.
	USBFS_PIPECTR_ATREPM = 0x400
	// Auto response disabled.
	USBFS_PIPECTR_ATREPM_0 = 0x0
	// Auto response enabled.
	USBFS_PIPECTR_ATREPM_1 = 0x1
	// Position of ACLRM field.
	USBFS_PIPECTR_ACLRM_Pos = 0x9
	// Bit mask of ACLRM field.
	USBFS_PIPECTR_ACLRM_Msk = 0x200
	// Bit ACLRM.
	USBFS_PIPECTR_ACLRM = 0x200
	// Disabled
	USBFS_PIPECTR_ACLRM_0 = 0x0
	// Enabled (all buffers are initialized)
	USBFS_PIPECTR_ACLRM_1 = 0x1
	// Position of SQCLR field.
	USBFS_PIPECTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBFS_PIPECTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBFS_PIPECTR_SQCLR = 0x100
	// Write disabled
	USBFS_PIPECTR_SQCLR_0 = 0x0
	// Specifies DATA0.
	USBFS_PIPECTR_SQCLR_1 = 0x1
	// Position of SQSET field.
	USBFS_PIPECTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBFS_PIPECTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBFS_PIPECTR_SQSET = 0x80
	// Write disabled
	USBFS_PIPECTR_SQSET_0 = 0x0
	// Specifies DATA1.
	USBFS_PIPECTR_SQSET_1 = 0x1
	// Position of SQMON field.
	USBFS_PIPECTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBFS_PIPECTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBFS_PIPECTR_SQMON = 0x40
	// DATA0
	USBFS_PIPECTR_SQMON_0 = 0x0
	// DATA1
	USBFS_PIPECTR_SQMON_1 = 0x1
	// Position of PBUSY field.
	USBFS_PIPECTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBFS_PIPECTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBFS_PIPECTR_PBUSY = 0x20
	// Pipe n not in use for the transaction
	USBFS_PIPECTR_PBUSY_0 = 0x0
	// Pipe n in use for the transaction.
	USBFS_PIPECTR_PBUSY_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPECTR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	USBFS_PIPECTR_Reserved_Msk = 0x1c
	// Position of PID field.
	USBFS_PIPECTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBFS_PIPECTR_PID_Msk = 0x3
	// NAK response
	USBFS_PIPECTR_PID_00 = 0x0
	// BUF response (depending on the buffer state)
	USBFS_PIPECTR_PID_01 = 0x1
	// STALL response
	USBFS_PIPECTR_PID_10 = 0x2
	// STALL response
	USBFS_PIPECTR_PID_11 = 0x3

	// PIPE6CTR: Pipe %s Control Register
	// Position of BSTS field.
	USBFS_PIPECTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBFS_PIPECTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBFS_PIPECTR_BSTS = 0x8000
	// Buffer access is disabled.
	USBFS_PIPECTR_BSTS_0 = 0x0
	// Buffer access is enabled.
	USBFS_PIPECTR_BSTS_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPECTR_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_PIPECTR_Reserved_Msk = 0x7c00
	// Position of ACLRM field.
	USBFS_PIPECTR_ACLRM_Pos = 0x9
	// Bit mask of ACLRM field.
	USBFS_PIPECTR_ACLRM_Msk = 0x200
	// Bit ACLRM.
	USBFS_PIPECTR_ACLRM = 0x200
	// Auto buffer clear mode is disabled.
	USBFS_PIPECTR_ACLRM_0 = 0x0
	// Auto buffer clear mode is enabled (all buffers are initialized)
	USBFS_PIPECTR_ACLRM_1 = 0x1
	// Position of SQCLR field.
	USBFS_PIPECTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBFS_PIPECTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBFS_PIPECTR_SQCLR = 0x100
	// Invalid
	USBFS_PIPECTR_SQCLR_0 = 0x0
	// Specifies DATA0.
	USBFS_PIPECTR_SQCLR_1 = 0x1
	// Position of SQSET field.
	USBFS_PIPECTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBFS_PIPECTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBFS_PIPECTR_SQSET = 0x80
	// Invalid
	USBFS_PIPECTR_SQSET_0 = 0x0
	// Specifies DATA1.
	USBFS_PIPECTR_SQSET_1 = 0x1
	// Position of SQMON field.
	USBFS_PIPECTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBFS_PIPECTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBFS_PIPECTR_SQMON = 0x40
	// DATA0
	USBFS_PIPECTR_SQMON_0 = 0x0
	// DATA1
	USBFS_PIPECTR_SQMON_1 = 0x1
	// Position of PBUSY field.
	USBFS_PIPECTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBFS_PIPECTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBFS_PIPECTR_PBUSY = 0x20
	// Pipe n not in use for the transaction
	USBFS_PIPECTR_PBUSY_0 = 0x0
	// Pipe n in use for the transaction.
	USBFS_PIPECTR_PBUSY_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPECTR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	USBFS_PIPECTR_Reserved_Msk = 0x1c
	// Position of PID field.
	USBFS_PIPECTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBFS_PIPECTR_PID_Msk = 0x3
	// NAK response
	USBFS_PIPECTR_PID_00 = 0x0
	// BUF response (depending on the buffer state)
	USBFS_PIPECTR_PID_01 = 0x1
	// STALL response
	USBFS_PIPECTR_PID_10 = 0x2
	// STALL response
	USBFS_PIPECTR_PID_11 = 0x3

	// PIPE1TRE: Pipe %s Transaction Counter Enable Register
	// Position of Reserved field.
	USBFS_PIPETRE_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_PIPETRE_Reserved_Msk = 0xfc00
	// Position of TRENB field.
	USBFS_PIPETRE_TRENB_Pos = 0x9
	// Bit mask of TRENB field.
	USBFS_PIPETRE_TRENB_Msk = 0x200
	// Bit TRENB.
	USBFS_PIPETRE_TRENB = 0x200
	// Transaction counter is disabled.
	USBFS_PIPETRE_TRENB_0 = 0x0
	// Transaction counter is enabled.
	USBFS_PIPETRE_TRENB_1 = 0x1
	// Position of TRCLR field.
	USBFS_PIPETRE_TRCLR_Pos = 0x8
	// Bit mask of TRCLR field.
	USBFS_PIPETRE_TRCLR_Msk = 0x100
	// Bit TRCLR.
	USBFS_PIPETRE_TRCLR = 0x100
	// Invalid
	USBFS_PIPETRE_TRCLR_0 = 0x0
	// The current counter value is cleared.
	USBFS_PIPETRE_TRCLR_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPETRE_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	USBFS_PIPETRE_Reserved_Msk = 0xff

	// PIPE1TRN: Pipe %s Transaction Counter Register
	// Position of TRNCNT field.
	USBFS_PIPETRN_TRNCNT_Pos = 0x0
	// Bit mask of TRNCNT field.
	USBFS_PIPETRN_TRNCNT_Msk = 0xffff

	// USBBCCTRL0: BC Control Register 0
	// Position of Reserved field.
	USBFS_USBBCCTRL0_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_USBBCCTRL0_Reserved_Msk = 0xfc00
	// Position of PDDETSTS0 field.
	USBFS_USBBCCTRL0_PDDETSTS0_Pos = 0x9
	// Bit mask of PDDETSTS0 field.
	USBFS_USBBCCTRL0_PDDETSTS0_Msk = 0x200
	// Bit PDDETSTS0.
	USBFS_USBBCCTRL0_PDDETSTS0 = 0x200
	// Not detected
	USBFS_USBBCCTRL0_PDDETSTS0_0 = 0x0
	// Detected
	USBFS_USBBCCTRL0_PDDETSTS0_1 = 0x1
	// Position of CHGDETSTS0 field.
	USBFS_USBBCCTRL0_CHGDETSTS0_Pos = 0x8
	// Bit mask of CHGDETSTS0 field.
	USBFS_USBBCCTRL0_CHGDETSTS0_Msk = 0x100
	// Bit CHGDETSTS0.
	USBFS_USBBCCTRL0_CHGDETSTS0 = 0x100
	// Not detected
	USBFS_USBBCCTRL0_CHGDETSTS0_0 = 0x0
	// Detected
	USBFS_USBBCCTRL0_CHGDETSTS0_1 = 0x1
	// Position of BATCHGE0 field.
	USBFS_USBBCCTRL0_BATCHGE0_Pos = 0x7
	// Bit mask of BATCHGE0 field.
	USBFS_USBBCCTRL0_BATCHGE0_Msk = 0x80
	// Bit BATCHGE0.
	USBFS_USBBCCTRL0_BATCHGE0 = 0x80
	// Disabled
	USBFS_USBBCCTRL0_BATCHGE0_0 = 0x0
	// Enabled
	USBFS_USBBCCTRL0_BATCHGE0_1 = 0x1
	// Position of Reserved field.
	USBFS_USBBCCTRL0_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	USBFS_USBBCCTRL0_Reserved_Msk = 0x40
	// Bit Reserved.
	USBFS_USBBCCTRL0_Reserved = 0x40
	// Position of VDMSRCE0 field.
	USBFS_USBBCCTRL0_VDMSRCE0_Pos = 0x5
	// Bit mask of VDMSRCE0 field.
	USBFS_USBBCCTRL0_VDMSRCE0_Msk = 0x20
	// Bit VDMSRCE0.
	USBFS_USBBCCTRL0_VDMSRCE0 = 0x20
	// Stop
	USBFS_USBBCCTRL0_VDMSRCE0_0 = 0x0
	// 0.6V output
	USBFS_USBBCCTRL0_VDMSRCE0_1 = 0x1
	// Position of IDPSINKE0 field.
	USBFS_USBBCCTRL0_IDPSINKE0_Pos = 0x4
	// Bit mask of IDPSINKE0 field.
	USBFS_USBBCCTRL0_IDPSINKE0_Msk = 0x10
	// Bit IDPSINKE0.
	USBFS_USBBCCTRL0_IDPSINKE0 = 0x10
	// Detection off
	USBFS_USBBCCTRL0_IDPSINKE0_0 = 0x0
	// Detection on ( Comparator and sink current on )
	USBFS_USBBCCTRL0_IDPSINKE0_1 = 0x1
	// Position of VDPSRCE0 field.
	USBFS_USBBCCTRL0_VDPSRCE0_Pos = 0x3
	// Bit mask of VDPSRCE0 field.
	USBFS_USBBCCTRL0_VDPSRCE0_Msk = 0x8
	// Bit VDPSRCE0.
	USBFS_USBBCCTRL0_VDPSRCE0 = 0x8
	// Stop
	USBFS_USBBCCTRL0_VDPSRCE0_0 = 0x0
	// 0.6V output
	USBFS_USBBCCTRL0_VDPSRCE0_1 = 0x1
	// Position of IDMSINKE0 field.
	USBFS_USBBCCTRL0_IDMSINKE0_Pos = 0x2
	// Bit mask of IDMSINKE0 field.
	USBFS_USBBCCTRL0_IDMSINKE0_Msk = 0x4
	// Bit IDMSINKE0.
	USBFS_USBBCCTRL0_IDMSINKE0 = 0x4
	// Detection off
	USBFS_USBBCCTRL0_IDMSINKE0_0 = 0x0
	// Detection on ( Comparator and sink current on )
	USBFS_USBBCCTRL0_IDMSINKE0_1 = 0x1
	// Position of IDPSRCE0 field.
	USBFS_USBBCCTRL0_IDPSRCE0_Pos = 0x1
	// Bit mask of IDPSRCE0 field.
	USBFS_USBBCCTRL0_IDPSRCE0_Msk = 0x2
	// Bit IDPSRCE0.
	USBFS_USBBCCTRL0_IDPSRCE0 = 0x2
	// Stop
	USBFS_USBBCCTRL0_IDPSRCE0_0 = 0x0
	// 10uA output
	USBFS_USBBCCTRL0_IDPSRCE0_1 = 0x1
	// Position of RPDME0 field.
	USBFS_USBBCCTRL0_RPDME0_Pos = 0x0
	// Bit mask of RPDME0 field.
	USBFS_USBBCCTRL0_RPDME0_Msk = 0x1
	// Bit RPDME0.
	USBFS_USBBCCTRL0_RPDME0 = 0x1
	// Pull-down off
	USBFS_USBBCCTRL0_RPDME0_0 = 0x0
	// Pull-down on
	USBFS_USBBCCTRL0_RPDME0_1 = 0x1

	// USBMC: USB Module Control Register
	// Position of Reserved field.
	USBFS_USBMC_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	USBFS_USBMC_Reserved_Msk = 0xff00
	// Position of VDCEN field.
	USBFS_USBMC_VDCEN_Pos = 0x7
	// Bit mask of VDCEN field.
	USBFS_USBMC_VDCEN_Msk = 0x80
	// Bit VDCEN.
	USBFS_USBMC_VDCEN = 0x80
	// USB regulator off
	USBFS_USBMC_VDCEN_0 = 0x0
	// USB regulator on
	USBFS_USBMC_VDCEN_1 = 0x1
	// Position of Reserved field.
	USBFS_USBMC_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	USBFS_USBMC_Reserved_Msk = 0x7c
	// Position of Reserved field.
	USBFS_USBMC_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	USBFS_USBMC_Reserved_Msk = 0x2
	// Bit Reserved.
	USBFS_USBMC_Reserved = 0x2
	// Position of VDDUSBE field.
	USBFS_USBMC_VDDUSBE_Pos = 0x0
	// Bit mask of VDDUSBE field.
	USBFS_USBMC_VDDUSBE_Msk = 0x1
	// Bit VDDUSBE.
	USBFS_USBMC_VDDUSBE = 0x1
	// USB reference power supply circuit off
	USBFS_USBMC_VDDUSBE_0 = 0x0
	// USB reference power supply circuit on
	USBFS_USBMC_VDDUSBE_1 = 0x1

	// DEVADD0: Device Address %s Configuration Register
	// Position of Reserved field.
	USBFS_DEVADD_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	USBFS_DEVADD_Reserved_Msk = 0xff00
	// Position of USBSPD field.
	USBFS_DEVADD_USBSPD_Pos = 0x6
	// Bit mask of USBSPD field.
	USBFS_DEVADD_USBSPD_Msk = 0xc0
	// DEVADDn is not used
	USBFS_DEVADD_USBSPD_00 = 0x0
	// Low speed
	USBFS_DEVADD_USBSPD_01 = 0x1
	// Full speed
	USBFS_DEVADD_USBSPD_10 = 0x2
	// Setting prohibited
	USBFS_DEVADD_USBSPD_11 = 0x3
	// Position of Reserved field.
	USBFS_DEVADD_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	USBFS_DEVADD_Reserved_Msk = 0x3f
)

// Constants for IWDT: Independent Watchdog Timer
const (
	// IWDTRR: IWDT Refresh Register
	// Position of IWDTRR field.
	IWDT_IWDTRR_IWDTRR_Pos = 0x0
	// Bit mask of IWDTRR field.
	IWDT_IWDTRR_IWDTRR_Msk = 0xff

	// IWDTSR: IWDT Status Register
	// Position of REFEF field.
	IWDT_IWDTSR_REFEF_Pos = 0xf
	// Bit mask of REFEF field.
	IWDT_IWDTSR_REFEF_Msk = 0x8000
	// Bit REFEF.
	IWDT_IWDTSR_REFEF = 0x8000
	// Refresh error not occurred
	IWDT_IWDTSR_REFEF_0 = 0x0
	// Refresh error occurred
	IWDT_IWDTSR_REFEF_1 = 0x1
	// Position of UNDFF field.
	IWDT_IWDTSR_UNDFF_Pos = 0xe
	// Bit mask of UNDFF field.
	IWDT_IWDTSR_UNDFF_Msk = 0x4000
	// Bit UNDFF.
	IWDT_IWDTSR_UNDFF = 0x4000
	// Underflow not occurred
	IWDT_IWDTSR_UNDFF_0 = 0x0
	// Underflow occurred
	IWDT_IWDTSR_UNDFF_1 = 0x1
	// Position of CNTVAL field.
	IWDT_IWDTSR_CNTVAL_Pos = 0x0
	// Bit mask of CNTVAL field.
	IWDT_IWDTSR_CNTVAL_Msk = 0x3fff
)

// Constants for PORT0: Port 0 Control Registers
const (
	// PCNTR1: Port Control Register 1
	// Position of PODR field.
	PORT0_PCNTR1_PODR_Pos = 0x10
	// Bit mask of PODR field.
	PORT0_PCNTR1_PODR_Msk = 0xffff0000
	// Low output
	PORT0_PCNTR1_PODR_0 = 0x0
	// High output.
	PORT0_PCNTR1_PODR_1 = 0x1
	// Position of PDR field.
	PORT0_PCNTR1_PDR_Pos = 0x0
	// Bit mask of PDR field.
	PORT0_PCNTR1_PDR_Msk = 0xffff
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR_0 = 0x0
	// Output (functions as an output pin).
	PORT0_PCNTR1_PDR_1 = 0x1

	// PODR: Output data register
	// Position of PODR field.
	PORT0_PODR_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PORT0_PODR_PODR_Msk = 0xffff
	// Low output
	PORT0_PODR_PODR_0 = 0x0
	// High output.
	PORT0_PODR_PODR_1 = 0x1

	// PDR: Data direction register
	// Position of PDR field.
	PORT0_PDR_PDR_Pos = 0x0
	// Bit mask of PDR field.
	PORT0_PDR_PDR_Msk = 0xffff
	// Input (functions as an input pin)
	PORT0_PDR_PDR_0 = 0x0
	// Output (functions as an output pin).
	PORT0_PDR_PDR_1 = 0x1

	// PCNTR2: Port Control Register 2
	// Position of EIDR field.
	PORT0_PCNTR2_EIDR_Pos = 0x10
	// Bit mask of EIDR field.
	PORT0_PCNTR2_EIDR_Msk = 0xffff0000
	// Low input
	PORT0_PCNTR2_EIDR_0 = 0x0
	// High input.
	PORT0_PCNTR2_EIDR_1 = 0x1
	// Position of PIDR field.
	PORT0_PCNTR2_PIDR_Pos = 0x0
	// Bit mask of PIDR field.
	PORT0_PCNTR2_PIDR_Msk = 0xffff
	// Low input
	PORT0_PCNTR2_PIDR_0 = 0x0
	// High input.
	PORT0_PCNTR2_PIDR_1 = 0x1

	// PIDR: Input data register
	// Position of PIDR field.
	PORT0_PIDR_PIDR_Pos = 0x0
	// Bit mask of PIDR field.
	PORT0_PIDR_PIDR_Msk = 0xffff
	// Low input
	PORT0_PIDR_PIDR_0 = 0x0
	// High input.
	PORT0_PIDR_PIDR_1 = 0x1

	// PCNTR3: Port Control Register 3
	// Position of PORR field.
	PORT0_PCNTR3_PORR_Pos = 0x10
	// Bit mask of PORR field.
	PORT0_PCNTR3_PORR_Msk = 0xffff0000
	// No affect to output
	PORT0_PCNTR3_PORR_0 = 0x0
	// Low output.
	PORT0_PCNTR3_PORR_1 = 0x1
	// Position of POSR field.
	PORT0_PCNTR3_POSR_Pos = 0x0
	// Bit mask of POSR field.
	PORT0_PCNTR3_POSR_Msk = 0xffff
	// No affect to output
	PORT0_PCNTR3_POSR_0 = 0x0
	// High output.
	PORT0_PCNTR3_POSR_1 = 0x1

	// PORR: Output reset register
	// Position of PORR field.
	PORT0_PORR_PORR_Pos = 0x0
	// Bit mask of PORR field.
	PORT0_PORR_PORR_Msk = 0xffff
	// No affect to output
	PORT0_PORR_PORR_0 = 0x0
	// Low output.
	PORT0_PORR_PORR_1 = 0x1

	// POSR: Output set register
	// Position of POSR field.
	PORT0_POSR_POSR_Pos = 0x0
	// Bit mask of POSR field.
	PORT0_POSR_POSR_Msk = 0xffff
	// No affect to output
	PORT0_POSR_POSR_0 = 0x0
	// High output.
	PORT0_POSR_POSR_1 = 0x1
)

// Constants for PORT1: Port 1 Control Registers
const (
	// PCNTR1: Port Control Register 1
	// Position of PODR field.
	PORT1_PCNTR1_PODR_Pos = 0x10
	// Bit mask of PODR field.
	PORT1_PCNTR1_PODR_Msk = 0xffff0000
	// Low output
	PORT1_PCNTR1_PODR_0 = 0x0
	// High output.
	PORT1_PCNTR1_PODR_1 = 0x1
	// Position of PDR field.
	PORT1_PCNTR1_PDR_Pos = 0x0
	// Bit mask of PDR field.
	PORT1_PCNTR1_PDR_Msk = 0xffff
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR_0 = 0x0
	// Output (functions as an output pin).
	PORT1_PCNTR1_PDR_1 = 0x1

	// PODR: Output data register
	// Position of PODR field.
	PORT1_PODR_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PORT1_PODR_PODR_Msk = 0xffff
	// Low output
	PORT1_PODR_PODR_0 = 0x0
	// High output.
	PORT1_PODR_PODR_1 = 0x1

	// PDR: Data direction register
	// Position of PDR field.
	PORT1_PDR_PDR_Pos = 0x0
	// Bit mask of PDR field.
	PORT1_PDR_PDR_Msk = 0xffff
	// Input (functions as an input pin)
	PORT1_PDR_PDR_0 = 0x0
	// Output (functions as an output pin).
	PORT1_PDR_PDR_1 = 0x1

	// PCNTR2: Port Control Register 2
	// Position of EIDR field.
	PORT1_PCNTR2_EIDR_Pos = 0x10
	// Bit mask of EIDR field.
	PORT1_PCNTR2_EIDR_Msk = 0xffff0000
	// Low input
	PORT1_PCNTR2_EIDR_0 = 0x0
	// High input.
	PORT1_PCNTR2_EIDR_1 = 0x1
	// Position of PIDR field.
	PORT1_PCNTR2_PIDR_Pos = 0x0
	// Bit mask of PIDR field.
	PORT1_PCNTR2_PIDR_Msk = 0xffff
	// Low input
	PORT1_PCNTR2_PIDR_0 = 0x0
	// High input.
	PORT1_PCNTR2_PIDR_1 = 0x1

	// EIDR: Event input data register
	// Position of EIDR field.
	PORT1_EIDR_EIDR_Pos = 0x0
	// Bit mask of EIDR field.
	PORT1_EIDR_EIDR_Msk = 0xffff
	// Low input
	PORT1_EIDR_EIDR_0 = 0x0
	// High input.
	PORT1_EIDR_EIDR_1 = 0x1

	// PIDR: Input data register
	// Position of PIDR field.
	PORT1_PIDR_PIDR_Pos = 0x0
	// Bit mask of PIDR field.
	PORT1_PIDR_PIDR_Msk = 0xffff
	// Low input
	PORT1_PIDR_PIDR_0 = 0x0
	// High input.
	PORT1_PIDR_PIDR_1 = 0x1

	// PCNTR3: Port Control Register 3
	// Position of PORR field.
	PORT1_PCNTR3_PORR_Pos = 0x10
	// Bit mask of PORR field.
	PORT1_PCNTR3_PORR_Msk = 0xffff0000
	// No affect to output
	PORT1_PCNTR3_PORR_0 = 0x0
	// Low output.
	PORT1_PCNTR3_PORR_1 = 0x1
	// Position of POSR field.
	PORT1_PCNTR3_POSR_Pos = 0x0
	// Bit mask of POSR field.
	PORT1_PCNTR3_POSR_Msk = 0xffff
	// No affect to output
	PORT1_PCNTR3_POSR_0 = 0x0
	// High output.
	PORT1_PCNTR3_POSR_1 = 0x1

	// PORR: Output set register
	// Position of PORR field.
	PORT1_PORR_PORR_Pos = 0x0
	// Bit mask of PORR field.
	PORT1_PORR_PORR_Msk = 0xffff
	// No affect to output
	PORT1_PORR_PORR_0 = 0x0
	// Low output.
	PORT1_PORR_PORR_1 = 0x1

	// POSR: Output reset register
	// Position of POSR field.
	PORT1_POSR_POSR_Pos = 0x0
	// Bit mask of POSR field.
	PORT1_POSR_POSR_Msk = 0xffff
	// No affect to output
	PORT1_POSR_POSR_0 = 0x0
	// High output.
	PORT1_POSR_POSR_1 = 0x1

	// PCNTR4: Port Control Register 4
	// Position of EORR field.
	PORT1_PCNTR4_EORR_Pos = 0x10
	// Bit mask of EORR field.
	PORT1_PCNTR4_EORR_Msk = 0xffff0000
	// No affect to output
	PORT1_PCNTR4_EORR_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR_1 = 0x1
	// Position of EOSR field.
	PORT1_PCNTR4_EOSR_Pos = 0x0
	// Bit mask of EOSR field.
	PORT1_PCNTR4_EOSR_Msk = 0xffff
	// No affect to output
	PORT1_PCNTR4_EOSR_0 = 0x0
	// High output.
	PORT1_PCNTR4_EOSR_1 = 0x1

	// EORR: Event output set register
	// Position of EORR field.
	PORT1_EORR_EORR_Pos = 0x0
	// Bit mask of EORR field.
	PORT1_EORR_EORR_Msk = 0xffff
	// No affect to output
	PORT1_EORR_EORR_0 = 0x0
	// Low output
	PORT1_EORR_EORR_1 = 0x1

	// EOSR: Event output reset register
	// Position of EOSR field.
	PORT1_EOSR_EOSR_Pos = 0x0
	// Bit mask of EOSR field.
	PORT1_EOSR_EOSR_Msk = 0xffff
	// No affect to output
	PORT1_EOSR_EOSR_0 = 0x0
	// High output.
	PORT1_EOSR_EOSR_1 = 0x1
)

// Constants for PFS: Pmn Pin Function Control Register
const (
	// P000PFS: P000 Pin Function Control Register
	// Position of Reserved field.
	PFS_P000PFS_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	PFS_P000PFS_Reserved_Msk = 0xe0000000
	// Position of PSEL field.
	PFS_P000PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P000PFS_PSEL_Msk = 0x1f000000
	// Position of Reserved field.
	PFS_P000PFS_Reserved_Pos = 0x11
	// Bit mask of Reserved field.
	PFS_P000PFS_Reserved_Msk = 0xfe0000
	// Position of PMR field.
	PFS_P000PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P000PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P000PFS_PMR = 0x10000
	// Uses the pin as a general I/O pin.
	PFS_P000PFS_PMR_0 = 0x0
	// Uses the pin as an I/O port for peripheral functions.
	PFS_P000PFS_PMR_1 = 0x1
	// Position of ASEL field.
	PFS_P000PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P000PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P000PFS_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P000PFS_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P000PFS_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P000PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P000PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P000PFS_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P000PFS_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P000PFS_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P000PFS_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P000PFS_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P000PFS_EOF = 0x2000
	// No effected
	PFS_P000PFS_EOF_0 = 0x0
	// Detect failing edge
	PFS_P000PFS_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P000PFS_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P000PFS_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P000PFS_EOR = 0x1000
	// No effected
	PFS_P000PFS_EOR_0 = 0x0
	// Detect rising edge
	PFS_P000PFS_EOR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	PFS_P000PFS_Reserved_Msk = 0x800
	// Bit Reserved.
	PFS_P000PFS_Reserved = 0x800
	// Position of DSCR field.
	PFS_P000PFS_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P000PFS_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P000PFS_DSCR = 0x400
	// Low drive
	PFS_P000PFS_DSCR_0 = 0x0
	// Middle drive.
	PFS_P000PFS_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P000PFS_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P000PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P000PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P000PFS_NCODR = 0x40
	// CMOS output
	PFS_P000PFS_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P000PFS_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P000PFS_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P000PFS_Reserved = 0x20
	// Position of PCR field.
	PFS_P000PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P000PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P000PFS_PCR = 0x10
	// Disables an input pull-up.
	PFS_P000PFS_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P000PFS_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P000PFS_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P000PFS_Reserved = 0x8
	// Position of PDR field.
	PFS_P000PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P000PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P000PFS_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P000PFS_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P000PFS_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P000PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P000PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P000PFS_PIDR = 0x2
	// Low input
	PFS_P000PFS_PIDR_0 = 0x0
	// High input
	PFS_P000PFS_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P000PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P000PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P000PFS_PODR = 0x1
	// Low output
	PFS_P000PFS_PODR_0 = 0x0
	// High output
	PFS_P000PFS_PODR_1 = 0x1

	// P000PFS_HA: P000 Pin Function Control Register
	// Position of ASEL field.
	PFS_P000PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P000PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P000PFS_HA_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P000PFS_HA_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P000PFS_HA_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P000PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P000PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P000PFS_HA_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P000PFS_HA_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P000PFS_HA_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P000PFS_HA_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P000PFS_HA_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P000PFS_HA_EOF = 0x2000
	// No effected
	PFS_P000PFS_HA_EOF_0 = 0x0
	// Detect failing edge
	PFS_P000PFS_HA_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P000PFS_HA_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P000PFS_HA_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P000PFS_HA_EOR = 0x1000
	// No effected
	PFS_P000PFS_HA_EOR_0 = 0x0
	// Detect rising edge
	PFS_P000PFS_HA_EOR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_HA_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	PFS_P000PFS_HA_Reserved_Msk = 0x800
	// Bit Reserved.
	PFS_P000PFS_HA_Reserved = 0x800
	// Position of DSCR field.
	PFS_P000PFS_HA_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P000PFS_HA_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P000PFS_HA_DSCR = 0x400
	// Low drive
	PFS_P000PFS_HA_DSCR_0 = 0x0
	// Middle drive.
	PFS_P000PFS_HA_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_HA_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P000PFS_HA_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P000PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P000PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P000PFS_HA_NCODR = 0x40
	// CMOS output
	PFS_P000PFS_HA_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P000PFS_HA_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_HA_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P000PFS_HA_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P000PFS_HA_Reserved = 0x20
	// Position of PCR field.
	PFS_P000PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P000PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P000PFS_HA_PCR = 0x10
	// Disables an input pull-up.
	PFS_P000PFS_HA_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P000PFS_HA_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_HA_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P000PFS_HA_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P000PFS_HA_Reserved = 0x8
	// Position of PDR field.
	PFS_P000PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P000PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P000PFS_HA_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P000PFS_HA_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P000PFS_HA_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P000PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P000PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P000PFS_HA_PIDR = 0x2
	// Low input
	PFS_P000PFS_HA_PIDR_0 = 0x0
	// High input
	PFS_P000PFS_HA_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P000PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P000PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P000PFS_HA_PODR = 0x1
	// Low output
	PFS_P000PFS_HA_PODR_0 = 0x0
	// High output
	PFS_P000PFS_HA_PODR_1 = 0x1

	// P000PFS_BY: P000 Pin Function Control Register
	// Position of Reserved field.
	PFS_P000PFS_BY_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P000PFS_BY_Reserved_Msk = 0x80
	// Bit Reserved.
	PFS_P000PFS_BY_Reserved = 0x80
	// Position of NCODR field.
	PFS_P000PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P000PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P000PFS_BY_NCODR = 0x40
	// CMOS output
	PFS_P000PFS_BY_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P000PFS_BY_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_BY_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P000PFS_BY_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P000PFS_BY_Reserved = 0x20
	// Position of PCR field.
	PFS_P000PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P000PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P000PFS_BY_PCR = 0x10
	// Disables an input pull-up.
	PFS_P000PFS_BY_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P000PFS_BY_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_BY_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P000PFS_BY_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P000PFS_BY_Reserved = 0x8
	// Position of PDR field.
	PFS_P000PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P000PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P000PFS_BY_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P000PFS_BY_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P000PFS_BY_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P000PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P000PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P000PFS_BY_PIDR = 0x2
	// Low input
	PFS_P000PFS_BY_PIDR_0 = 0x0
	// High input
	PFS_P000PFS_BY_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P000PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P000PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P000PFS_BY_PODR = 0x1
	// Low output
	PFS_P000PFS_BY_PODR_0 = 0x0
	// High output
	PFS_P000PFS_BY_PODR_1 = 0x1

	// P108PFS: P108 Pin Function Control Register
	// Position of Reserved field.
	PFS_P108PFS_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	PFS_P108PFS_Reserved_Msk = 0xe0000000
	// Position of PSEL field.
	PFS_P108PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P108PFS_PSEL_Msk = 0x1f000000
	// Position of Reserved field.
	PFS_P108PFS_Reserved_Pos = 0x11
	// Bit mask of Reserved field.
	PFS_P108PFS_Reserved_Msk = 0xfe0000
	// Position of PMR field.
	PFS_P108PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P108PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P108PFS_PMR = 0x10000
	// Uses the pin as a general I/O pin.
	PFS_P108PFS_PMR_0 = 0x0
	// Uses the pin as an I/O port for peripheral functions.
	PFS_P108PFS_PMR_1 = 0x1
	// Position of ASEL field.
	PFS_P108PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P108PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P108PFS_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P108PFS_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P108PFS_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P108PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P108PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P108PFS_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P108PFS_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P108PFS_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P108PFS_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P108PFS_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P108PFS_EOF = 0x2000
	// No effected
	PFS_P108PFS_EOF_0 = 0x0
	// Detect failing edge
	PFS_P108PFS_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P108PFS_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P108PFS_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P108PFS_EOR = 0x1000
	// No effected
	PFS_P108PFS_EOR_0 = 0x0
	// Detect rising edge
	PFS_P108PFS_EOR_1 = 0x1
	// Position of Reserved field.
	PFS_P108PFS_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	PFS_P108PFS_Reserved_Msk = 0x800
	// Bit Reserved.
	PFS_P108PFS_Reserved = 0x800
	// Position of DSCR field.
	PFS_P108PFS_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P108PFS_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P108PFS_DSCR = 0x400
	// Low drive
	PFS_P108PFS_DSCR_0 = 0x0
	// Middle drive.
	PFS_P108PFS_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P108PFS_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P108PFS_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P108PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P108PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P108PFS_NCODR = 0x40
	// CMOS output
	PFS_P108PFS_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P108PFS_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P108PFS_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P108PFS_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P108PFS_Reserved = 0x20
	// Position of PCR field.
	PFS_P108PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P108PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P108PFS_PCR = 0x10
	// Disables an input pull-up.
	PFS_P108PFS_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P108PFS_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P108PFS_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P108PFS_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P108PFS_Reserved = 0x8
	// Position of PDR field.
	PFS_P108PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P108PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P108PFS_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P108PFS_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P108PFS_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P108PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P108PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P108PFS_PIDR = 0x2
	// Low input
	PFS_P108PFS_PIDR_0 = 0x0
	// High input
	PFS_P108PFS_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P108PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P108PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P108PFS_PODR = 0x1
	// Low output
	PFS_P108PFS_PODR_0 = 0x0
	// High output
	PFS_P108PFS_PODR_1 = 0x1

	// P108PFS_HA: P108 Pin Function Control Register
	// Position of ASEL field.
	PFS_P108PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P108PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P108PFS_HA_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P108PFS_HA_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P108PFS_HA_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P108PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P108PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P108PFS_HA_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P108PFS_HA_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P108PFS_HA_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P108PFS_HA_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P108PFS_HA_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P108PFS_HA_EOF = 0x2000
	// No effected
	PFS_P108PFS_HA_EOF_0 = 0x0
	// Detect failing edge
	PFS_P108PFS_HA_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P108PFS_HA_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P108PFS_HA_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P108PFS_HA_EOR = 0x1000
	// No effected
	PFS_P108PFS_HA_EOR_0 = 0x0
	// Detect rising edge
	PFS_P108PFS_HA_EOR_1 = 0x1
	// Position of Reserved field.
	PFS_P108PFS_HA_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	PFS_P108PFS_HA_Reserved_Msk = 0x800
	// Bit Reserved.
	PFS_P108PFS_HA_Reserved = 0x800
	// Position of DSCR field.
	PFS_P108PFS_HA_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P108PFS_HA_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P108PFS_HA_DSCR = 0x400
	// Low drive
	PFS_P108PFS_HA_DSCR_0 = 0x0
	// Middle drive.
	PFS_P108PFS_HA_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P108PFS_HA_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P108PFS_HA_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P108PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P108PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P108PFS_HA_NCODR = 0x40
	// CMOS output
	PFS_P108PFS_HA_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P108PFS_HA_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P108PFS_HA_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P108PFS_HA_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P108PFS_HA_Reserved = 0x20
	// Position of PCR field.
	PFS_P108PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P108PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P108PFS_HA_PCR = 0x10
	// Disables an input pull-up.
	PFS_P108PFS_HA_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P108PFS_HA_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P108PFS_HA_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P108PFS_HA_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P108PFS_HA_Reserved = 0x8
	// Position of PDR field.
	PFS_P108PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P108PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P108PFS_HA_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P108PFS_HA_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P108PFS_HA_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P108PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P108PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P108PFS_HA_PIDR = 0x2
	// Low input
	PFS_P108PFS_HA_PIDR_0 = 0x0
	// High input
	PFS_P108PFS_HA_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P108PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P108PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P108PFS_HA_PODR = 0x1
	// Low output
	PFS_P108PFS_HA_PODR_0 = 0x0
	// High output
	PFS_P108PFS_HA_PODR_1 = 0x1

	// P108PFS_BY: P108 Pin Function Control Register
	// Position of Reserved field.
	PFS_P108PFS_BY_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P108PFS_BY_Reserved_Msk = 0x80
	// Bit Reserved.
	PFS_P108PFS_BY_Reserved = 0x80
	// Position of NCODR field.
	PFS_P108PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P108PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P108PFS_BY_NCODR = 0x40
	// CMOS output
	PFS_P108PFS_BY_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P108PFS_BY_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P108PFS_BY_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P108PFS_BY_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P108PFS_BY_Reserved = 0x20
	// Position of PCR field.
	PFS_P108PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P108PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P108PFS_BY_PCR = 0x10
	// Disables an input pull-up.
	PFS_P108PFS_BY_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P108PFS_BY_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P108PFS_BY_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P108PFS_BY_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P108PFS_BY_Reserved = 0x8
	// Position of PDR field.
	PFS_P108PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P108PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P108PFS_BY_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P108PFS_BY_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P108PFS_BY_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P108PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P108PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P108PFS_BY_PIDR = 0x2
	// Low input
	PFS_P108PFS_BY_PIDR_0 = 0x0
	// High input
	PFS_P108PFS_BY_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P108PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P108PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P108PFS_BY_PODR = 0x1
	// Low output
	PFS_P108PFS_BY_PODR_0 = 0x0
	// High output
	PFS_P108PFS_BY_PODR_1 = 0x1

	// P109PFS: P109 Pin Function Control Register
	// Position of Reserved field.
	PFS_P109PFS_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	PFS_P109PFS_Reserved_Msk = 0xe0000000
	// Position of PSEL field.
	PFS_P109PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P109PFS_PSEL_Msk = 0x1f000000
	// Position of Reserved field.
	PFS_P109PFS_Reserved_Pos = 0x11
	// Bit mask of Reserved field.
	PFS_P109PFS_Reserved_Msk = 0xfe0000
	// Position of PMR field.
	PFS_P109PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P109PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P109PFS_PMR = 0x10000
	// Uses the pin as a general I/O pin.
	PFS_P109PFS_PMR_0 = 0x0
	// Uses the pin as an I/O port for peripheral functions.
	PFS_P109PFS_PMR_1 = 0x1
	// Position of ASEL field.
	PFS_P109PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P109PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P109PFS_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P109PFS_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P109PFS_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P109PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P109PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P109PFS_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P109PFS_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P109PFS_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P109PFS_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P109PFS_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P109PFS_EOF = 0x2000
	// No effected
	PFS_P109PFS_EOF_0 = 0x0
	// Detect failing edge
	PFS_P109PFS_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P109PFS_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P109PFS_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P109PFS_EOR = 0x1000
	// No effected
	PFS_P109PFS_EOR_0 = 0x0
	// Detect rising edge
	PFS_P109PFS_EOR_1 = 0x1
	// Position of Reserved field.
	PFS_P109PFS_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	PFS_P109PFS_Reserved_Msk = 0x800
	// Bit Reserved.
	PFS_P109PFS_Reserved = 0x800
	// Position of DSCR field.
	PFS_P109PFS_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P109PFS_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P109PFS_DSCR = 0x400
	// Low drive
	PFS_P109PFS_DSCR_0 = 0x0
	// Middle drive.
	PFS_P109PFS_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P109PFS_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P109PFS_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P109PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P109PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P109PFS_NCODR = 0x40
	// CMOS output
	PFS_P109PFS_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P109PFS_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P109PFS_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P109PFS_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P109PFS_Reserved = 0x20
	// Position of PCR field.
	PFS_P109PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P109PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P109PFS_PCR = 0x10
	// Disables an input pull-up.
	PFS_P109PFS_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P109PFS_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P109PFS_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P109PFS_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P109PFS_Reserved = 0x8
	// Position of PDR field.
	PFS_P109PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P109PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P109PFS_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P109PFS_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P109PFS_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P109PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P109PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P109PFS_PIDR = 0x2
	// Low input
	PFS_P109PFS_PIDR_0 = 0x0
	// High input
	PFS_P109PFS_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P109PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P109PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P109PFS_PODR = 0x1
	// Low output
	PFS_P109PFS_PODR_0 = 0x0
	// High output
	PFS_P109PFS_PODR_1 = 0x1

	// P109PFS_HA: P109 Pin Function Control Register
	// Position of ASEL field.
	PFS_P109PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P109PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P109PFS_HA_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P109PFS_HA_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P109PFS_HA_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P109PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P109PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P109PFS_HA_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P109PFS_HA_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P109PFS_HA_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P109PFS_HA_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P109PFS_HA_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P109PFS_HA_EOF = 0x2000
	// No effected
	PFS_P109PFS_HA_EOF_0 = 0x0
	// Detect failing edge
	PFS_P109PFS_HA_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P109PFS_HA_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P109PFS_HA_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P109PFS_HA_EOR = 0x1000
	// No effected
	PFS_P109PFS_HA_EOR_0 = 0x0
	// Detect rising edge
	PFS_P109PFS_HA_EOR_1 = 0x1
	// Position of Reserved field.
	PFS_P109PFS_HA_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	PFS_P109PFS_HA_Reserved_Msk = 0x800
	// Bit Reserved.
	PFS_P109PFS_HA_Reserved = 0x800
	// Position of DSCR field.
	PFS_P109PFS_HA_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P109PFS_HA_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P109PFS_HA_DSCR = 0x400
	// Low drive
	PFS_P109PFS_HA_DSCR_0 = 0x0
	// Middle drive.
	PFS_P109PFS_HA_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P109PFS_HA_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P109PFS_HA_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P109PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P109PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P109PFS_HA_NCODR = 0x40
	// CMOS output
	PFS_P109PFS_HA_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P109PFS_HA_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P109PFS_HA_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P109PFS_HA_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P109PFS_HA_Reserved = 0x20
	// Position of PCR field.
	PFS_P109PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P109PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P109PFS_HA_PCR = 0x10
	// Disables an input pull-up.
	PFS_P109PFS_HA_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P109PFS_HA_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P109PFS_HA_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P109PFS_HA_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P109PFS_HA_Reserved = 0x8
	// Position of PDR field.
	PFS_P109PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P109PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P109PFS_HA_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P109PFS_HA_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P109PFS_HA_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P109PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P109PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P109PFS_HA_PIDR = 0x2
	// Low input
	PFS_P109PFS_HA_PIDR_0 = 0x0
	// High input
	PFS_P109PFS_HA_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P109PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P109PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P109PFS_HA_PODR = 0x1
	// Low output
	PFS_P109PFS_HA_PODR_0 = 0x0
	// High output
	PFS_P109PFS_HA_PODR_1 = 0x1

	// P109PFS_BY: P109 Pin Function Control Register
	// Position of Reserved field.
	PFS_P109PFS_BY_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P109PFS_BY_Reserved_Msk = 0x80
	// Bit Reserved.
	PFS_P109PFS_BY_Reserved = 0x80
	// Position of NCODR field.
	PFS_P109PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P109PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P109PFS_BY_NCODR = 0x40
	// CMOS output
	PFS_P109PFS_BY_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P109PFS_BY_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P109PFS_BY_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P109PFS_BY_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P109PFS_BY_Reserved = 0x20
	// Position of PCR field.
	PFS_P109PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P109PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P109PFS_BY_PCR = 0x10
	// Disables an input pull-up.
	PFS_P109PFS_BY_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P109PFS_BY_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P109PFS_BY_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P109PFS_BY_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P109PFS_BY_Reserved = 0x8
	// Position of PDR field.
	PFS_P109PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P109PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P109PFS_BY_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P109PFS_BY_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P109PFS_BY_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P109PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P109PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P109PFS_BY_PIDR = 0x2
	// Low input
	PFS_P109PFS_BY_PIDR_0 = 0x0
	// High input
	PFS_P109PFS_BY_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P109PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P109PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P109PFS_BY_PODR = 0x1
	// Low output
	PFS_P109PFS_BY_PODR_0 = 0x0
	// High output
	PFS_P109PFS_BY_PODR_1 = 0x1

	// P201PFS: P201 Pin Function Control Register
	// Position of Reserved field.
	PFS_P201PFS_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	PFS_P201PFS_Reserved_Msk = 0xe0000000
	// Position of PSEL field.
	PFS_P201PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P201PFS_PSEL_Msk = 0x1f000000
	// Position of Reserved field.
	PFS_P201PFS_Reserved_Pos = 0x11
	// Bit mask of Reserved field.
	PFS_P201PFS_Reserved_Msk = 0xfe0000
	// Position of PMR field.
	PFS_P201PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P201PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P201PFS_PMR = 0x10000
	// Uses the pin as a general I/O pin.
	PFS_P201PFS_PMR_0 = 0x0
	// Uses the pin as an I/O port for peripheral functions.
	PFS_P201PFS_PMR_1 = 0x1
	// Position of ASEL field.
	PFS_P201PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P201PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P201PFS_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P201PFS_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P201PFS_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P201PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P201PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P201PFS_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P201PFS_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P201PFS_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P201PFS_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P201PFS_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P201PFS_EOF = 0x2000
	// Do not care
	PFS_P201PFS_EOF_0 = 0x0
	// Detect falling edge
	PFS_P201PFS_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P201PFS_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P201PFS_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P201PFS_EOR = 0x1000
	// Do not care
	PFS_P201PFS_EOR_0 = 0x0
	// Detect rising edge
	PFS_P201PFS_EOR_1 = 0x1
	// Position of Reserved field.
	PFS_P201PFS_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	PFS_P201PFS_Reserved_Msk = 0x800
	// Bit Reserved.
	PFS_P201PFS_Reserved = 0x800
	// Position of DSCR field.
	PFS_P201PFS_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P201PFS_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P201PFS_DSCR = 0x400
	// Low drive
	PFS_P201PFS_DSCR_0 = 0x0
	// High drive
	PFS_P201PFS_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P201PFS_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P201PFS_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P201PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P201PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P201PFS_NCODR = 0x40
	// CMOS output
	PFS_P201PFS_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P201PFS_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P201PFS_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P201PFS_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P201PFS_Reserved = 0x20
	// Position of PCR field.
	PFS_P201PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P201PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P201PFS_PCR = 0x10
	// Disables an input pull-up.
	PFS_P201PFS_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P201PFS_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P201PFS_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P201PFS_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P201PFS_Reserved = 0x8
	// Position of PDR field.
	PFS_P201PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P201PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P201PFS_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P201PFS_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P201PFS_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P201PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P201PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P201PFS_PIDR = 0x2
	// Low input
	PFS_P201PFS_PIDR_0 = 0x0
	// High input
	PFS_P201PFS_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P201PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P201PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P201PFS_PODR = 0x1
	// Low output
	PFS_P201PFS_PODR_0 = 0x0
	// High output
	PFS_P201PFS_PODR_1 = 0x1

	// P201PFS_HA: P201 Pin Function Control Register
	// Position of ASEL field.
	PFS_P201PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P201PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P201PFS_HA_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P201PFS_HA_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P201PFS_HA_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P201PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P201PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P201PFS_HA_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P201PFS_HA_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P201PFS_HA_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P201PFS_HA_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P201PFS_HA_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P201PFS_HA_EOF = 0x2000
	// Do not care
	PFS_P201PFS_HA_EOF_0 = 0x0
	// Detect falling edge
	PFS_P201PFS_HA_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P201PFS_HA_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P201PFS_HA_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P201PFS_HA_EOR = 0x1000
	// Do not care
	PFS_P201PFS_HA_EOR_0 = 0x0
	// Detect rising edge
	PFS_P201PFS_HA_EOR_1 = 0x1
	// Position of Reserved field.
	PFS_P201PFS_HA_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	PFS_P201PFS_HA_Reserved_Msk = 0x800
	// Bit Reserved.
	PFS_P201PFS_HA_Reserved = 0x800
	// Position of DSCR field.
	PFS_P201PFS_HA_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P201PFS_HA_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P201PFS_HA_DSCR = 0x400
	// Low drive
	PFS_P201PFS_HA_DSCR_0 = 0x0
	// High drive
	PFS_P201PFS_HA_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P201PFS_HA_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P201PFS_HA_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P201PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P201PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P201PFS_HA_NCODR = 0x40
	// CMOS output
	PFS_P201PFS_HA_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P201PFS_HA_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P201PFS_HA_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P201PFS_HA_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P201PFS_HA_Reserved = 0x20
	// Position of PCR field.
	PFS_P201PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P201PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P201PFS_HA_PCR = 0x10
	// Disables an input pull-up.
	PFS_P201PFS_HA_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P201PFS_HA_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P201PFS_HA_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P201PFS_HA_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P201PFS_HA_Reserved = 0x8
	// Position of PDR field.
	PFS_P201PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P201PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P201PFS_HA_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P201PFS_HA_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P201PFS_HA_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P201PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P201PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P201PFS_HA_PIDR = 0x2
	// Low input
	PFS_P201PFS_HA_PIDR_0 = 0x0
	// High input
	PFS_P201PFS_HA_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P201PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P201PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P201PFS_HA_PODR = 0x1
	// Low output
	PFS_P201PFS_HA_PODR_0 = 0x0
	// High output
	PFS_P201PFS_HA_PODR_1 = 0x1

	// P201PFS_BY: P201 Pin Function Control Register
	// Position of Reserved field.
	PFS_P201PFS_BY_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P201PFS_BY_Reserved_Msk = 0x80
	// Bit Reserved.
	PFS_P201PFS_BY_Reserved = 0x80
	// Position of NCODR field.
	PFS_P201PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P201PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P201PFS_BY_NCODR = 0x40
	// CMOS output
	PFS_P201PFS_BY_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P201PFS_BY_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P201PFS_BY_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P201PFS_BY_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P201PFS_BY_Reserved = 0x20
	// Position of PCR field.
	PFS_P201PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P201PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P201PFS_BY_PCR = 0x10
	// Disables an input pull-up.
	PFS_P201PFS_BY_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P201PFS_BY_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P201PFS_BY_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P201PFS_BY_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P201PFS_BY_Reserved = 0x8
	// Position of PDR field.
	PFS_P201PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P201PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P201PFS_BY_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P201PFS_BY_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P201PFS_BY_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P201PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P201PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P201PFS_BY_PIDR = 0x2
	// Low input
	PFS_P201PFS_BY_PIDR_0 = 0x0
	// High input
	PFS_P201PFS_BY_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P201PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P201PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P201PFS_BY_PODR = 0x1
	// Low output
	PFS_P201PFS_BY_PODR_0 = 0x0
	// High output
	PFS_P201PFS_BY_PODR_1 = 0x1

	// P408PFS: P408 Pin Function Control Register
	// Position of Reserved field.
	PFS_P408PFS_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	PFS_P408PFS_Reserved_Msk = 0xe0000000
	// Position of PSEL field.
	PFS_P408PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P408PFS_PSEL_Msk = 0x1f000000
	// Position of Reserved field.
	PFS_P408PFS_Reserved_Pos = 0x11
	// Bit mask of Reserved field.
	PFS_P408PFS_Reserved_Msk = 0xfe0000
	// Position of PMR field.
	PFS_P408PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P408PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P408PFS_PMR = 0x10000
	// Uses the pin as a general I/O pin.
	PFS_P408PFS_PMR_0 = 0x0
	// Uses the pin as an I/O port for peripheral functions.
	PFS_P408PFS_PMR_1 = 0x1
	// Position of ASEL field.
	PFS_P408PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P408PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P408PFS_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P408PFS_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P408PFS_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P408PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P408PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P408PFS_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P408PFS_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P408PFS_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P408PFS_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P408PFS_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P408PFS_EOF = 0x2000
	// Do not care
	PFS_P408PFS_EOF_0 = 0x0
	// Detect falling edge
	PFS_P408PFS_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P408PFS_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P408PFS_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P408PFS_EOR = 0x1000
	// Do not care
	PFS_P408PFS_EOR_0 = 0x0
	// Detect rising edge
	PFS_P408PFS_EOR_1 = 0x1
	// Position of DSCR1 field.
	PFS_P408PFS_DSCR1_Pos = 0xb
	// Bit mask of DSCR1 field.
	PFS_P408PFS_DSCR1_Msk = 0x800
	// Bit DSCR1.
	PFS_P408PFS_DSCR1 = 0x800
	// Low drive(DSCR = 0)/Middle drive(DSCR = 1)
	PFS_P408PFS_DSCR1_0 = 0x0
	// Middle drive for IIC Fast-mode(DSCR = 0)/Setting prohibited(DSCR = 1)
	PFS_P408PFS_DSCR1_1 = 0x1
	// Position of DSCR field.
	PFS_P408PFS_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P408PFS_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P408PFS_DSCR = 0x400
	// Low drive(DSCR1 = 0)/Middle drive for llC Fast-mode(DSCR1 = 1)
	PFS_P408PFS_DSCR_0 = 0x0
	// Middle drive(DSCR1 = 0)/Setting prohibited(DSCR1 = 1)
	PFS_P408PFS_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P408PFS_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P408PFS_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P408PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P408PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P408PFS_NCODR = 0x40
	// CMOS output
	PFS_P408PFS_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P408PFS_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P408PFS_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P408PFS_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P408PFS_Reserved = 0x20
	// Position of PCR field.
	PFS_P408PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P408PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P408PFS_PCR = 0x10
	// Disables an input pull-up.
	PFS_P408PFS_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P408PFS_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P408PFS_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P408PFS_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P408PFS_Reserved = 0x8
	// Position of PDR field.
	PFS_P408PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P408PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P408PFS_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P408PFS_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P408PFS_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P408PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P408PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P408PFS_PIDR = 0x2
	// Low input
	PFS_P408PFS_PIDR_0 = 0x0
	// High input
	PFS_P408PFS_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P408PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P408PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P408PFS_PODR = 0x1
	// Low output
	PFS_P408PFS_PODR_0 = 0x0
	// High output
	PFS_P408PFS_PODR_1 = 0x1

	// P408PFS_HA: P408 Pin Function Control Register
	// Position of ASEL field.
	PFS_P408PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P408PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P408PFS_HA_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P408PFS_HA_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P408PFS_HA_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P408PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P408PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P408PFS_HA_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P408PFS_HA_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P408PFS_HA_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P408PFS_HA_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P408PFS_HA_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P408PFS_HA_EOF = 0x2000
	// Do not care
	PFS_P408PFS_HA_EOF_0 = 0x0
	// Detect falling edge
	PFS_P408PFS_HA_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P408PFS_HA_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P408PFS_HA_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P408PFS_HA_EOR = 0x1000
	// Do not care
	PFS_P408PFS_HA_EOR_0 = 0x0
	// Detect rising edge
	PFS_P408PFS_HA_EOR_1 = 0x1
	// Position of DSCR1 field.
	PFS_P408PFS_HA_DSCR1_Pos = 0xb
	// Bit mask of DSCR1 field.
	PFS_P408PFS_HA_DSCR1_Msk = 0x800
	// Bit DSCR1.
	PFS_P408PFS_HA_DSCR1 = 0x800
	// Low drive(DSCR = 0)/Middle drive(DSCR = 1)
	PFS_P408PFS_HA_DSCR1_0 = 0x0
	// Middle drive for IIC Fast-mode(DSCR = 0)/Setting prohibited(DSCR = 1)
	PFS_P408PFS_HA_DSCR1_1 = 0x1
	// Position of DSCR field.
	PFS_P408PFS_HA_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P408PFS_HA_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P408PFS_HA_DSCR = 0x400
	// Low drive(DSCR1 = 0)/Middle drive for llC Fast-mode(DSCR1 = 1)
	PFS_P408PFS_HA_DSCR_0 = 0x0
	// Middle drive(DSCR1 = 0)/Setting prohibited(DSCR1 = 1)
	PFS_P408PFS_HA_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P408PFS_HA_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P408PFS_HA_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P408PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P408PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P408PFS_HA_NCODR = 0x40
	// CMOS output
	PFS_P408PFS_HA_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P408PFS_HA_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P408PFS_HA_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P408PFS_HA_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P408PFS_HA_Reserved = 0x20
	// Position of PCR field.
	PFS_P408PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P408PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P408PFS_HA_PCR = 0x10
	// Disables an input pull-up.
	PFS_P408PFS_HA_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P408PFS_HA_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P408PFS_HA_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P408PFS_HA_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P408PFS_HA_Reserved = 0x8
	// Position of PDR field.
	PFS_P408PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P408PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P408PFS_HA_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P408PFS_HA_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P408PFS_HA_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P408PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P408PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P408PFS_HA_PIDR = 0x2
	// Low input
	PFS_P408PFS_HA_PIDR_0 = 0x0
	// High input
	PFS_P408PFS_HA_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P408PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P408PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P408PFS_HA_PODR = 0x1
	// Low output
	PFS_P408PFS_HA_PODR_0 = 0x0
	// High output
	PFS_P408PFS_HA_PODR_1 = 0x1

	// P408PFS_BY: P408 Pin Function Control Register
	// Position of Reserved field.
	PFS_P408PFS_BY_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P408PFS_BY_Reserved_Msk = 0x80
	// Bit Reserved.
	PFS_P408PFS_BY_Reserved = 0x80
	// Position of NCODR field.
	PFS_P408PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P408PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P408PFS_BY_NCODR = 0x40
	// CMOS output
	PFS_P408PFS_BY_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P408PFS_BY_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P408PFS_BY_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P408PFS_BY_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P408PFS_BY_Reserved = 0x20
	// Position of PCR field.
	PFS_P408PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P408PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P408PFS_BY_PCR = 0x10
	// Disables an input pull-up.
	PFS_P408PFS_BY_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P408PFS_BY_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P408PFS_BY_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P408PFS_BY_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P408PFS_BY_Reserved = 0x8
	// Position of PDR field.
	PFS_P408PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P408PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P408PFS_BY_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P408PFS_BY_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P408PFS_BY_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P408PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P408PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P408PFS_BY_PIDR = 0x2
	// Low input
	PFS_P408PFS_BY_PIDR_0 = 0x0
	// High input
	PFS_P408PFS_BY_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P408PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P408PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P408PFS_BY_PODR = 0x1
	// Low output
	PFS_P408PFS_BY_PODR_0 = 0x0
	// High output
	PFS_P408PFS_BY_PODR_1 = 0x1
)

// Constants for PMISC: Miscellaneous Port Control Register
const (
	// PWPR: Write-Protect Register
	// Position of B0WI field.
	PMISC_PWPR_B0WI_Pos = 0x7
	// Bit mask of B0WI field.
	PMISC_PWPR_B0WI_Msk = 0x80
	// Bit B0WI.
	PMISC_PWPR_B0WI = 0x80
	// Writing to the PFSWE bit is enabled
	PMISC_PWPR_B0WI_0 = 0x0
	// Writing to the PFSWE bit is disabled
	PMISC_PWPR_B0WI_1 = 0x1
	// Position of PFSWE field.
	PMISC_PWPR_PFSWE_Pos = 0x6
	// Bit mask of PFSWE field.
	PMISC_PWPR_PFSWE_Msk = 0x40
	// Bit PFSWE.
	PMISC_PWPR_PFSWE = 0x40
	// Writing to the PFS register is disabled
	PMISC_PWPR_PFSWE_0 = 0x0
	// Writing to the PFS register is enabled
	PMISC_PWPR_PFSWE_1 = 0x1
	// Position of Reserved field.
	PMISC_PWPR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	PMISC_PWPR_Reserved_Msk = 0x3f
)

// Constants for ELC: Event Link Controller
const (
	// ELCR: Event Link Controller Register
	// Position of ELCON field.
	ELC_ELCR_ELCON_Pos = 0x7
	// Bit mask of ELCON field.
	ELC_ELCR_ELCON_Msk = 0x80
	// Bit ELCON.
	ELC_ELCR_ELCON = 0x80
	// ELC function is disabled.
	ELC_ELCR_ELCON_0 = 0x0
	// ELC function is enabled.
	ELC_ELCR_ELCON_1 = 0x1
	// Position of Reserved field.
	ELC_ELCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	ELC_ELCR_Reserved_Msk = 0x7f

	// ELSEGR0: Event Link Software Event Generation Register %s
	// Position of WI field.
	ELC_ELSEGR_WI_Pos = 0x7
	// Bit mask of WI field.
	ELC_ELSEGR_WI_Msk = 0x80
	// Bit WI.
	ELC_ELSEGR_WI = 0x80
	// Write to ELSEGR register is enabled.
	ELC_ELSEGR_WI_0 = 0x0
	// Write to ELSEGR register is disabled.
	ELC_ELSEGR_WI_1 = 0x1
	// Position of WE field.
	ELC_ELSEGR_WE_Pos = 0x6
	// Bit mask of WE field.
	ELC_ELSEGR_WE_Msk = 0x40
	// Bit WE.
	ELC_ELSEGR_WE = 0x40
	// Write to SEG bit is disabled.
	ELC_ELSEGR_WE_0 = 0x0
	// Write to SEG bit is enabled.
	ELC_ELSEGR_WE_1 = 0x1
	// Position of Reserved field.
	ELC_ELSEGR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	ELC_ELSEGR_Reserved_Msk = 0x3e
	// Position of SEG field.
	ELC_ELSEGR_SEG_Pos = 0x0
	// Bit mask of SEG field.
	ELC_ELSEGR_SEG_Msk = 0x1
	// Bit SEG.
	ELC_ELSEGR_SEG = 0x1
	// Normal operation
	ELC_ELSEGR_SEG_0 = 0x0
	// Software event is generated.
	ELC_ELSEGR_SEG_1 = 0x1

	// ELSR0: Event Link Setting Register %s
	// Position of Reserved field.
	ELC_ELSR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ELC_ELSR_Reserved_Msk = 0xff00
	// Position of ELS field.
	ELC_ELSR_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR_ELS_Msk = 0xff
	// Event output to the corresponding peripheral module is disabled.
	ELC_ELSR_ELS_0x00 = 0x0

	// ELSR12: Event Link Setting Register 12
	// Position of Reserved field.
	ELC_ELSR12_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ELC_ELSR12_Reserved_Msk = 0xff00
	// Position of ELS field.
	ELC_ELSR12_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR12_ELS_Msk = 0xff
	// Event output to the corresponding peripheral module is disabled.
	ELC_ELSR12_ELS_0x00 = 0x0

	// ELSR14: Event Link Setting Register %s
	// Position of Reserved field.
	ELC_ELSR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ELC_ELSR_Reserved_Msk = 0xff00
	// Position of ELS field.
	ELC_ELSR_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR_ELS_Msk = 0xff
	// Event output to the corresponding peripheral module is disabled.
	ELC_ELSR_ELS_0x00 = 0x0
)

// Constants for DOC: Data Operation Circuit
const (
	// DOCR: DOC Control Register
	// Position of Reserved field.
	DOC_DOCR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	DOC_DOCR_Reserved_Msk = 0x80
	// Bit Reserved.
	DOC_DOCR_Reserved = 0x80
	// Position of DOPCFCL field.
	DOC_DOCR_DOPCFCL_Pos = 0x6
	// Bit mask of DOPCFCL field.
	DOC_DOCR_DOPCFCL_Msk = 0x40
	// Bit DOPCFCL.
	DOC_DOCR_DOPCFCL = 0x40
	// Maintains the DOPCF flag state.
	DOC_DOCR_DOPCFCL_0 = 0x0
	// Clears the DOPCF flag.
	DOC_DOCR_DOPCFCL_1 = 0x1
	// Position of DOPCF field.
	DOC_DOCR_DOPCF_Pos = 0x5
	// Bit mask of DOPCF field.
	DOC_DOCR_DOPCF_Msk = 0x20
	// Bit DOPCF.
	DOC_DOCR_DOPCF = 0x20
	// Position of Reserved field.
	DOC_DOCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	DOC_DOCR_Reserved_Msk = 0x18
	// Position of DCSEL field.
	DOC_DOCR_DCSEL_Pos = 0x2
	// Bit mask of DCSEL field.
	DOC_DOCR_DCSEL_Msk = 0x4
	// Bit DCSEL.
	DOC_DOCR_DCSEL = 0x4
	// DOPCF is set when data mismatch is detected.
	DOC_DOCR_DCSEL_0 = 0x0
	// DOPCF is set when data match is detected.
	DOC_DOCR_DCSEL_1 = 0x1
	// Position of OMS field.
	DOC_DOCR_OMS_Pos = 0x0
	// Bit mask of OMS field.
	DOC_DOCR_OMS_Msk = 0x3
	// Data comparison mode
	DOC_DOCR_OMS_00 = 0x0
	// Data addition mode
	DOC_DOCR_OMS_01 = 0x1
	// Data subtraction mode
	DOC_DOCR_OMS_10 = 0x2
	// Setting prohibited
	DOC_DOCR_OMS_11 = 0x3

	// DODIR: DOC Data Input Register
	// Position of DODIR field.
	DOC_DODIR_DODIR_Pos = 0x0
	// Bit mask of DODIR field.
	DOC_DODIR_DODIR_Msk = 0xffff

	// DODSR: DOC Data Setting Register
	// Position of DODSR field.
	DOC_DODSR_DODSR_Pos = 0x0
	// Bit mask of DODSR field.
	DOC_DODSR_DODSR_Msk = 0xffff
)

// Constants for CRC: CRC Calculator
const (
	// CRCCR0: CRC Control Register0
	// Position of DORCIR field.
	CRC_CRCCR0_DORCIR_Pos = 0x7
	// Bit mask of DORCIR field.
	CRC_CRCCR0_DORCIR_Msk = 0x80
	// Bit DORCIR.
	CRC_CRCCR0_DORCIR = 0x80
	// No effect.
	CRC_CRCCR0_DORCIR_0 = 0x0
	// Clears the CRCDOR register.
	CRC_CRCCR0_DORCIR_1 = 0x1
	// Position of LMS field.
	CRC_CRCCR0_LMS_Pos = 0x6
	// Bit mask of LMS field.
	CRC_CRCCR0_LMS_Msk = 0x40
	// Bit LMS.
	CRC_CRCCR0_LMS = 0x40
	// Generates CRC for LSB first communication.
	CRC_CRCCR0_LMS_0 = 0x0
	// Generates CRC for MSB first communication.
	CRC_CRCCR0_LMS_1 = 0x1
	// Position of Reserved field.
	CRC_CRCCR0_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	CRC_CRCCR0_Reserved_Msk = 0x38
	// Position of GPS field.
	CRC_CRCCR0_GPS_Pos = 0x0
	// Bit mask of GPS field.
	CRC_CRCCR0_GPS_Msk = 0x7
	// No calculation is executed.
	CRC_CRCCR0_GPS_000 = 0x0
	// 8-bit CRC-8 (X8 + X2 + X + 1)
	CRC_CRCCR0_GPS_001 = 0x1
	// 16-bit CRC-16 (X16 + X15 + X2 + 1)
	CRC_CRCCR0_GPS_010 = 0x2
	// 16-bit CRC-CCITT (X16 + X12 + X5 + 1)
	CRC_CRCCR0_GPS_011 = 0x3
	// 32-bit CRC-32 (X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X+1)
	CRC_CRCCR0_GPS_100 = 0x4
	// 32-bit CRC-32C (X32+X28+X27+X26+ X25+X23+X22+X20+X19+X18+X14+X13+X11+X10+X9+X8+X6+1)
	CRC_CRCCR0_GPS_101 = 0x5

	// CRCCR1: CRC Control Register1
	// Position of CRCSEN field.
	CRC_CRCCR1_CRCSEN_Pos = 0x7
	// Bit mask of CRCSEN field.
	CRC_CRCCR1_CRCSEN_Msk = 0x80
	// Bit CRCSEN.
	CRC_CRCCR1_CRCSEN = 0x80
	// Disabled
	CRC_CRCCR1_CRCSEN_0 = 0x0
	// Enabled
	CRC_CRCCR1_CRCSEN_1 = 0x1
	// Position of CRCSWR field.
	CRC_CRCCR1_CRCSWR_Pos = 0x6
	// Bit mask of CRCSWR field.
	CRC_CRCCR1_CRCSWR_Msk = 0x40
	// Bit CRCSWR.
	CRC_CRCCR1_CRCSWR = 0x40
	// Snoop-on-read
	CRC_CRCCR1_CRCSWR_0 = 0x0
	// Snoop-on-write
	CRC_CRCCR1_CRCSWR_1 = 0x1
	// Position of Reserved field.
	CRC_CRCCR1_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	CRC_CRCCR1_Reserved_Msk = 0x3f

	// CRCDIR: CRC Data Input Register
	// Position of CRCDIR field.
	CRC_CRCDIR_CRCDIR_Pos = 0x0
	// Bit mask of CRCDIR field.
	CRC_CRCDIR_CRCDIR_Msk = 0xffffffff

	// CRCDIR_BY: CRC Data Input Register (byte access)
	// Position of CRCDIR_BY field.
	CRC_CRCDIR_BY_CRCDIR_BY_Pos = 0x0
	// Bit mask of CRCDIR_BY field.
	CRC_CRCDIR_BY_CRCDIR_BY_Msk = 0xff

	// CRCDOR: CRC Data Output Register
	// Position of CRCDOR field.
	CRC_CRCDOR_CRCDOR_Pos = 0x0
	// Bit mask of CRCDOR field.
	CRC_CRCDOR_CRCDOR_Msk = 0xffffffff

	// CRCDOR_HA: CRC Data Output Register (halfword access)
	// Position of CRCDOR_HA field.
	CRC_CRCDOR_HA_CRCDOR_HA_Pos = 0x0
	// Bit mask of CRCDOR_HA field.
	CRC_CRCDOR_HA_CRCDOR_HA_Msk = 0xffff

	// CRCDOR_BY: CRC Data Output Register(byte access)
	// Position of CRCDOR_BY field.
	CRC_CRCDOR_BY_CRCDOR_BY_Pos = 0x0
	// Bit mask of CRCDOR_BY field.
	CRC_CRCDOR_BY_CRCDOR_BY_Msk = 0xff

	// CRCSAR: Snoop Address Register
	// Position of Reserved field.
	CRC_CRCSAR_Reserved_Pos = 0xe
	// Bit mask of Reserved field.
	CRC_CRCSAR_Reserved_Msk = 0xc000
	// Position of CRCSA field.
	CRC_CRCSAR_CRCSA_Pos = 0x0
	// Bit mask of CRCSA field.
	CRC_CRCSAR_CRCSA_Msk = 0x3fff
	// SCI0.TDR
	CRC_CRCSAR_CRCSA_0x0003 = 0x3
	// SCI0.RDR
	CRC_CRCSAR_CRCSA_0x0005 = 0x5
	// SCI1.TDR
	CRC_CRCSAR_CRCSA_0x0023 = 0x23
	// SCI1.RDR
	CRC_CRCSAR_CRCSA_0x0025 = 0x25
	// SCI2.TDR
	CRC_CRCSAR_CRCSA_0x0043 = 0x43
	// SCI2.RDR
	CRC_CRCSAR_CRCSA_0x0045 = 0x45
	// SCI3.TDR
	CRC_CRCSAR_CRCSA_0x0063 = 0x63
	// SCI3.RDR
	CRC_CRCSAR_CRCSA_0x0065 = 0x65
	// SCI4.TDR
	CRC_CRCSAR_CRCSA_0x0083 = 0x83
	// SCI4.RDR
	CRC_CRCSAR_CRCSA_0x0085 = 0x85
	// SCI9.TDR
	CRC_CRCSAR_CRCSA_0x0123 = 0x123
	// SCI9.RDR
	CRC_CRCSAR_CRCSA_0x0125 = 0x125
)

// Constants for CAC: Clock Frequency Accuracy Measurement Circuit
const (
	// CACR0: CAC Control Register 0
	// Position of Reserved field.
	CAC_CACR0_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	CAC_CACR0_Reserved_Msk = 0xfe
	// Position of CFME field.
	CAC_CACR0_CFME_Pos = 0x0
	// Bit mask of CFME field.
	CAC_CACR0_CFME_Msk = 0x1
	// Bit CFME.
	CAC_CACR0_CFME = 0x1
	// Disable
	CAC_CACR0_CFME_0 = 0x0
	// Enable
	CAC_CACR0_CFME_1 = 0x1

	// CACR1: CAC Control Register 1
	// Position of EDGES field.
	CAC_CACR1_EDGES_Pos = 0x6
	// Bit mask of EDGES field.
	CAC_CACR1_EDGES_Msk = 0xc0
	// Rising edge
	CAC_CACR1_EDGES_00 = 0x0
	// Falling edge
	CAC_CACR1_EDGES_01 = 0x1
	// Both rising and falling edges
	CAC_CACR1_EDGES_10 = 0x2
	// Setting prohibited
	CAC_CACR1_EDGES_11 = 0x3
	// Position of TCSS field.
	CAC_CACR1_TCSS_Pos = 0x4
	// Bit mask of TCSS field.
	CAC_CACR1_TCSS_Msk = 0x30
	// No division
	CAC_CACR1_TCSS_00 = 0x0
	// x 1/4 clock
	CAC_CACR1_TCSS_01 = 0x1
	// x 1/8 clock
	CAC_CACR1_TCSS_10 = 0x2
	// x 1/32 clock
	CAC_CACR1_TCSS_11 = 0x3
	// Position of FMCS field.
	CAC_CACR1_FMCS_Pos = 0x1
	// Bit mask of FMCS field.
	CAC_CACR1_FMCS_Msk = 0xe
	// Main clock
	CAC_CACR1_FMCS_000 = 0x0
	// Sub-clock
	CAC_CACR1_FMCS_001 = 0x1
	// HOCO clock
	CAC_CACR1_FMCS_010 = 0x2
	// MOCO clock
	CAC_CACR1_FMCS_011 = 0x3
	// LOCO clock
	CAC_CACR1_FMCS_100 = 0x4
	// Peripheral module clock(PCLKB)
	CAC_CACR1_FMCS_101 = 0x5
	// IWDTCLK clock
	CAC_CACR1_FMCS_110 = 0x6
	// Setting prohibited
	CAC_CACR1_FMCS_111 = 0x7
	// Position of CACREFE field.
	CAC_CACR1_CACREFE_Pos = 0x0
	// Bit mask of CACREFE field.
	CAC_CACR1_CACREFE_Msk = 0x1
	// Bit CACREFE.
	CAC_CACR1_CACREFE = 0x1
	// Disable
	CAC_CACR1_CACREFE_0 = 0x0
	// Enable
	CAC_CACR1_CACREFE_1 = 0x1

	// CACR2: CAC Control Register 2
	// Position of DFS field.
	CAC_CACR2_DFS_Pos = 0x6
	// Bit mask of DFS field.
	CAC_CACR2_DFS_Msk = 0xc0
	// Digital filtering is disabled.
	CAC_CACR2_DFS_00 = 0x0
	// The sampling clock for the digital filter is the frequency measuring clock.
	CAC_CACR2_DFS_01 = 0x1
	// The sampling clock for the digital filter is the frequency measuring clock divided by 4.
	CAC_CACR2_DFS_10 = 0x2
	// The sampling clock for the digital filter is the frequency measuring clock divided by 16.
	CAC_CACR2_DFS_11 = 0x3
	// Position of RCDS field.
	CAC_CACR2_RCDS_Pos = 0x4
	// Bit mask of RCDS field.
	CAC_CACR2_RCDS_Msk = 0x30
	// 1/32 clock
	CAC_CACR2_RCDS_00 = 0x0
	// 1/128 clock
	CAC_CACR2_RCDS_01 = 0x1
	// 1/1024 clock
	CAC_CACR2_RCDS_10 = 0x2
	// 1/8192 clock
	CAC_CACR2_RCDS_11 = 0x3
	// Position of RSCS field.
	CAC_CACR2_RSCS_Pos = 0x1
	// Bit mask of RSCS field.
	CAC_CACR2_RSCS_Msk = 0xe
	// Main clock
	CAC_CACR2_RSCS_000 = 0x0
	// Sub-clock
	CAC_CACR2_RSCS_001 = 0x1
	// HOCO clock
	CAC_CACR2_RSCS_010 = 0x2
	// MOCO clock
	CAC_CACR2_RSCS_011 = 0x3
	// LOCO clock
	CAC_CACR2_RSCS_100 = 0x4
	// Peripheral module clock(PCLKB)
	CAC_CACR2_RSCS_101 = 0x5
	// IWDTCLK clock
	CAC_CACR2_RSCS_110 = 0x6
	// Setting prohibited
	CAC_CACR2_RSCS_111 = 0x7
	// Position of RPS field.
	CAC_CACR2_RPS_Pos = 0x0
	// Bit mask of RPS field.
	CAC_CACR2_RPS_Msk = 0x1
	// Bit RPS.
	CAC_CACR2_RPS = 0x1
	// CACREF pin input
	CAC_CACR2_RPS_0 = 0x0
	// Internal clock (internally generated signal)
	CAC_CACR2_RPS_1 = 0x1

	// CAICR: CAC Interrupt Control Register
	// Position of Reserved field.
	CAC_CAICR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	CAC_CAICR_Reserved_Msk = 0x80
	// Bit Reserved.
	CAC_CAICR_Reserved = 0x80
	// Position of OVFFCL field.
	CAC_CAICR_OVFFCL_Pos = 0x6
	// Bit mask of OVFFCL field.
	CAC_CAICR_OVFFCL_Msk = 0x40
	// Bit OVFFCL.
	CAC_CAICR_OVFFCL = 0x40
	// No effect on operations
	CAC_CAICR_OVFFCL_0 = 0x0
	// Clears the OVFF flag
	CAC_CAICR_OVFFCL_1 = 0x1
	// Position of MENDFCL field.
	CAC_CAICR_MENDFCL_Pos = 0x5
	// Bit mask of MENDFCL field.
	CAC_CAICR_MENDFCL_Msk = 0x20
	// Bit MENDFCL.
	CAC_CAICR_MENDFCL = 0x20
	// No effect on operations
	CAC_CAICR_MENDFCL_0 = 0x0
	// Clears the MENDF flag
	CAC_CAICR_MENDFCL_1 = 0x1
	// Position of FERRFCL field.
	CAC_CAICR_FERRFCL_Pos = 0x4
	// Bit mask of FERRFCL field.
	CAC_CAICR_FERRFCL_Msk = 0x10
	// Bit FERRFCL.
	CAC_CAICR_FERRFCL = 0x10
	// No effect on operations
	CAC_CAICR_FERRFCL_0 = 0x0
	// Clears the FERRF flag
	CAC_CAICR_FERRFCL_1 = 0x1
	// Position of Reserved field.
	CAC_CAICR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	CAC_CAICR_Reserved_Msk = 0x8
	// Bit Reserved.
	CAC_CAICR_Reserved = 0x8
	// Position of OVFIE field.
	CAC_CAICR_OVFIE_Pos = 0x2
	// Bit mask of OVFIE field.
	CAC_CAICR_OVFIE_Msk = 0x4
	// Bit OVFIE.
	CAC_CAICR_OVFIE = 0x4
	// Disable
	CAC_CAICR_OVFIE_0 = 0x0
	// Enable
	CAC_CAICR_OVFIE_1 = 0x1
	// Position of MENDIE field.
	CAC_CAICR_MENDIE_Pos = 0x1
	// Bit mask of MENDIE field.
	CAC_CAICR_MENDIE_Msk = 0x2
	// Bit MENDIE.
	CAC_CAICR_MENDIE = 0x2
	// Disable
	CAC_CAICR_MENDIE_0 = 0x0
	// Enable
	CAC_CAICR_MENDIE_1 = 0x1
	// Position of FERRIE field.
	CAC_CAICR_FERRIE_Pos = 0x0
	// Bit mask of FERRIE field.
	CAC_CAICR_FERRIE_Msk = 0x1
	// Bit FERRIE.
	CAC_CAICR_FERRIE = 0x1
	// Disable
	CAC_CAICR_FERRIE_0 = 0x0
	// Enable
	CAC_CAICR_FERRIE_1 = 0x1

	// CASTR: CAC Status Register
	// Position of OVFF field.
	CAC_CASTR_OVFF_Pos = 0x2
	// Bit mask of OVFF field.
	CAC_CASTR_OVFF_Msk = 0x4
	// Bit OVFF.
	CAC_CASTR_OVFF = 0x4
	// The counter has not overflowed.
	CAC_CASTR_OVFF_0 = 0x0
	// The counter has overflowed.
	CAC_CASTR_OVFF_1 = 0x1
	// Position of MENDF field.
	CAC_CASTR_MENDF_Pos = 0x1
	// Bit mask of MENDF field.
	CAC_CASTR_MENDF_Msk = 0x2
	// Bit MENDF.
	CAC_CASTR_MENDF = 0x2
	// Measurement is in progress.
	CAC_CASTR_MENDF_0 = 0x0
	// Measurement has ended.
	CAC_CASTR_MENDF_1 = 0x1
	// Position of FERRF field.
	CAC_CASTR_FERRF_Pos = 0x0
	// Bit mask of FERRF field.
	CAC_CASTR_FERRF_Msk = 0x1
	// Bit FERRF.
	CAC_CASTR_FERRF = 0x1
	// The clock frequency is within the range corresponding to the settings.
	CAC_CASTR_FERRF_0 = 0x0
	// The clock frequency has deviated beyond the range corresponding to the settings (frequency error).
	CAC_CASTR_FERRF_1 = 0x1

	// CAULVR: CAC Upper-Limit Value Setting Register
	// Position of CAULVR field.
	CAC_CAULVR_CAULVR_Pos = 0x0
	// Bit mask of CAULVR field.
	CAC_CAULVR_CAULVR_Msk = 0xffff

	// CALLVR: CAC Lower-Limit Value Setting Register
	// Position of CALLVR field.
	CAC_CALLVR_CALLVR_Pos = 0x0
	// Bit mask of CALLVR field.
	CAC_CALLVR_CALLVR_Msk = 0xffff

	// CACNTBR: CAC Counter Buffer Register
	// Position of CACNTBR field.
	CAC_CACNTBR_CACNTBR_Pos = 0x0
	// Bit mask of CACNTBR field.
	CAC_CACNTBR_CACNTBR_Msk = 0xffff
)

// Constants for DAC8: 8-bit D/A converter
const (
	// DACS0: D/A Conversion Value Setting Register %s
	// Position of DACS field.
	DAC8_DACS_DACS_Pos = 0x0
	// Bit mask of DACS field.
	DAC8_DACS_DACS_Msk = 0xff

	// DAM: D/A Converter Mode Register
	// Position of Reserved field.
	DAC8_DAM_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	DAC8_DAM_Reserved_Msk = 0xc0
	// Position of DACE1 field.
	DAC8_DAM_DACE1_Pos = 0x5
	// Bit mask of DACE1 field.
	DAC8_DAM_DACE1_Msk = 0x20
	// Bit DACE1.
	DAC8_DAM_DACE1 = 0x20
	// D/A conversion disabled for channel 1
	DAC8_DAM_DACE1_0 = 0x0
	// D/A conversion enabled for channel 1
	DAC8_DAM_DACE1_1 = 0x1
	// Position of DACE0 field.
	DAC8_DAM_DACE0_Pos = 0x4
	// Bit mask of DACE0 field.
	DAC8_DAM_DACE0_Msk = 0x10
	// Bit DACE0.
	DAC8_DAM_DACE0 = 0x10
	// D/A conversion disabled for channel 0
	DAC8_DAM_DACE0_0 = 0x0
	// D/A conversion enabled for channel 0.
	DAC8_DAM_DACE0_1 = 0x1
	// Position of Reserved field.
	DAC8_DAM_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	DAC8_DAM_Reserved_Msk = 0xf
)

// Constants for DAC12: 12-bit D/A converter
const (
	// DADR0: D/A Data Register 0
	// Position of DADR field.
	DAC12_DADR0_DADR_Pos = 0x0
	// Bit mask of DADR field.
	DAC12_DADR0_DADR_Msk = 0xffff

	// DACR: D/A Control Register
	// Position of Reserved field.
	DAC12_DACR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	DAC12_DACR_Reserved_Msk = 0x80
	// Bit Reserved.
	DAC12_DACR_Reserved = 0x80
	// Position of DAOE0 field.
	DAC12_DACR_DAOE0_Pos = 0x6
	// Bit mask of DAOE0 field.
	DAC12_DACR_DAOE0_Msk = 0x40
	// Bit DAOE0.
	DAC12_DACR_DAOE0 = 0x40
	// Analog output of channel 0 (DA0) is disabled.
	DAC12_DACR_DAOE0_0 = 0x0
	// D/A conversion of channel 0 is enabled. Analog output of channel 0 (DA0) is enabled.
	DAC12_DACR_DAOE0_1 = 0x1
	// Position of Reserved field.
	DAC12_DACR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	DAC12_DACR_Reserved_Msk = 0x20
	// Bit Reserved.
	DAC12_DACR_Reserved = 0x20
	// Position of Reserved field.
	DAC12_DACR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	DAC12_DACR_Reserved_Msk = 0x1f

	// DADPR: DADR0 Format Select Register
	// Position of DPSEL field.
	DAC12_DADPR_DPSEL_Pos = 0x7
	// Bit mask of DPSEL field.
	DAC12_DADPR_DPSEL_Msk = 0x80
	// Bit DPSEL.
	DAC12_DADPR_DPSEL = 0x80
	// Right justified format.
	DAC12_DADPR_DPSEL_0 = 0x0
	// Left justified format.
	DAC12_DADPR_DPSEL_1 = 0x1
	// Position of Reserved field.
	DAC12_DADPR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	DAC12_DADPR_Reserved_Msk = 0x7f

	// DAADSCR: D/A-A/D Synchronous Start Control Register
	// Position of DAADST field.
	DAC12_DAADSCR_DAADST_Pos = 0x7
	// Bit mask of DAADST field.
	DAC12_DAADSCR_DAADST_Msk = 0x80
	// Bit DAADST.
	DAC12_DAADSCR_DAADST = 0x80
	// D/A converter operation does not synchronize with A/D converter operation (unit 1) (countermeasure against interference between D/A and A/D conversions is disabled).
	DAC12_DAADSCR_DAADST_0 = 0x0
	// D/A converter operation synchronizes with A/D converter operation (unit 1) (countermeasure against interference between D/A and A/D conversions is enabled).
	DAC12_DAADSCR_DAADST_1 = 0x1

	// DAVREFCR: D/A VREF Control Register
	// Position of Reserved field.
	DAC12_DAVREFCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	DAC12_DAVREFCR_Reserved_Msk = 0xf8
	// Position of REF field.
	DAC12_DAVREFCR_REF_Pos = 0x0
	// Bit mask of REF field.
	DAC12_DAVREFCR_REF_Msk = 0x7
	// Not selected
	DAC12_DAVREFCR_REF_000 = 0x0
	// AVCC0/AVSS0
	DAC12_DAVREFCR_REF_001 = 0x1
	// Internal reference voltage/AVSS0
	DAC12_DAVREFCR_REF_011 = 0x3
	// VREFH/VREFL
	DAC12_DAVREFCR_REF_110 = 0x6
)

// Constants for CTSU: Capacitive Touch Sensing Unit
const (
	// CTSUCR0: CTSU Control Register 0
	// Position of CTSUINIT field.
	CTSU_CTSUCR0_CTSUINIT_Pos = 0x4
	// Bit mask of CTSUINIT field.
	CTSU_CTSUCR0_CTSUINIT_Msk = 0x10
	// Bit CTSUINIT.
	CTSU_CTSUCR0_CTSUINIT = 0x10
	// Writing a 0 has no effect, this bit is read as 0.
	CTSU_CTSUCR0_CTSUINIT_0 = 0x0
	// initializes the CTSU control block and registers.
	CTSU_CTSUCR0_CTSUINIT_1 = 0x1
	// Position of CTSUIOC field.
	CTSU_CTSUCR0_CTSUIOC_Pos = 0x3
	// Bit mask of CTSUIOC field.
	CTSU_CTSUCR0_CTSUIOC_Msk = 0x8
	// Bit CTSUIOC.
	CTSU_CTSUCR0_CTSUIOC = 0x8
	// Low-level output from transmit channel non-measurement pin.
	CTSU_CTSUCR0_CTSUIOC_0 = 0x0
	// High-level output from transmit channel non-measurement pin.
	CTSU_CTSUCR0_CTSUIOC_1 = 0x1
	// Position of CTSUSNZ field.
	CTSU_CTSUCR0_CTSUSNZ_Pos = 0x2
	// Bit mask of CTSUSNZ field.
	CTSU_CTSUCR0_CTSUSNZ_Msk = 0x4
	// Bit CTSUSNZ.
	CTSU_CTSUCR0_CTSUSNZ = 0x4
	// Power-saving function during wait state is disabled.
	CTSU_CTSUCR0_CTSUSNZ_0 = 0x0
	// Power-saving function during wait state is enabled.
	CTSU_CTSUCR0_CTSUSNZ_1 = 0x1
	// Position of CTSUCAP field.
	CTSU_CTSUCR0_CTSUCAP_Pos = 0x1
	// Bit mask of CTSUCAP field.
	CTSU_CTSUCR0_CTSUCAP_Msk = 0x2
	// Bit CTSUCAP.
	CTSU_CTSUCR0_CTSUCAP = 0x2
	// Software trigger.
	CTSU_CTSUCR0_CTSUCAP_0 = 0x0
	// External trigger.
	CTSU_CTSUCR0_CTSUCAP_1 = 0x1
	// Position of CTSUSTRT field.
	CTSU_CTSUCR0_CTSUSTRT_Pos = 0x0
	// Bit mask of CTSUSTRT field.
	CTSU_CTSUCR0_CTSUSTRT_Msk = 0x1
	// Bit CTSUSTRT.
	CTSU_CTSUCR0_CTSUSTRT = 0x1
	// Measurement operation stops.
	CTSU_CTSUCR0_CTSUSTRT_0 = 0x0
	// Measurement operation starts.
	CTSU_CTSUCR0_CTSUSTRT_1 = 0x1

	// CTSUCR1: CTSU Control Register 1
	// Position of CTSUMD field.
	CTSU_CTSUCR1_CTSUMD_Pos = 0x6
	// Bit mask of CTSUMD field.
	CTSU_CTSUCR1_CTSUMD_Msk = 0xc0
	// Self-capacitance single scan mode
	CTSU_CTSUCR1_CTSUMD_00 = 0x0
	// Self-capacitance multi-scan mode
	CTSU_CTSUCR1_CTSUMD_01 = 0x1
	// Mutual capacitance simple scan mode
	CTSU_CTSUCR1_CTSUMD_10 = 0x2
	// Mutual capacitance full scan mode
	CTSU_CTSUCR1_CTSUMD_11 = 0x3
	// Position of CTSUCLK field.
	CTSU_CTSUCR1_CTSUCLK_Pos = 0x4
	// Bit mask of CTSUCLK field.
	CTSU_CTSUCR1_CTSUCLK_Msk = 0x30
	// PCLK
	CTSU_CTSUCR1_CTSUCLK_00 = 0x0
	// PCLK/2 (PCLK divided by 2)
	CTSU_CTSUCR1_CTSUCLK_01 = 0x1
	// PCLK/2 (PCLK divided by 4)
	CTSU_CTSUCR1_CTSUCLK_10 = 0x2
	// Setting prohibited
	CTSU_CTSUCR1_CTSUCLK_11 = 0x3
	// Position of CTSUATUNE1 field.
	CTSU_CTSUCR1_CTSUATUNE1_Pos = 0x3
	// Bit mask of CTSUATUNE1 field.
	CTSU_CTSUCR1_CTSUATUNE1_Msk = 0x8
	// Bit CTSUATUNE1.
	CTSU_CTSUCR1_CTSUATUNE1 = 0x8
	// Normal output
	CTSU_CTSUCR1_CTSUATUNE1_0 = 0x0
	// High-current output
	CTSU_CTSUCR1_CTSUATUNE1_1 = 0x1
	// Position of CTSUATUNE0 field.
	CTSU_CTSUCR1_CTSUATUNE0_Pos = 0x2
	// Bit mask of CTSUATUNE0 field.
	CTSU_CTSUCR1_CTSUATUNE0_Msk = 0x4
	// Bit CTSUATUNE0.
	CTSU_CTSUCR1_CTSUATUNE0 = 0x4
	// Normal operating mode
	CTSU_CTSUCR1_CTSUATUNE0_0 = 0x0
	// Low-voltage operating mode
	CTSU_CTSUCR1_CTSUATUNE0_1 = 0x1
	// Position of CTSUCSW field.
	CTSU_CTSUCR1_CTSUCSW_Pos = 0x1
	// Bit mask of CTSUCSW field.
	CTSU_CTSUCR1_CTSUCSW_Msk = 0x2
	// Bit CTSUCSW.
	CTSU_CTSUCR1_CTSUCSW = 0x2
	// Turned off capacitance switch
	CTSU_CTSUCR1_CTSUCSW_0 = 0x0
	// Turned on capacitance switch
	CTSU_CTSUCR1_CTSUCSW_1 = 0x1
	// Position of CTSUPON field.
	CTSU_CTSUCR1_CTSUPON_Pos = 0x0
	// Bit mask of CTSUPON field.
	CTSU_CTSUCR1_CTSUPON_Msk = 0x1
	// Bit CTSUPON.
	CTSU_CTSUCR1_CTSUPON = 0x1
	// Powered off the CTSU
	CTSU_CTSUCR1_CTSUPON_0 = 0x0
	// Powered on the CTSU
	CTSU_CTSUCR1_CTSUPON_1 = 0x1

	// CTSUSDPRS: CTSU Synchronous Noise Reduction Setting Register
	// Position of Reserved field.
	CTSU_CTSUSDPRS_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	CTSU_CTSUSDPRS_Reserved_Msk = 0x80
	// Bit Reserved.
	CTSU_CTSUSDPRS_Reserved = 0x80
	// Position of CTSUSOFF field.
	CTSU_CTSUSDPRS_CTSUSOFF_Pos = 0x6
	// Bit mask of CTSUSOFF field.
	CTSU_CTSUSDPRS_CTSUSOFF_Msk = 0x40
	// Bit CTSUSOFF.
	CTSU_CTSUSDPRS_CTSUSOFF = 0x40
	// High-pass noise reduction function turned on
	CTSU_CTSUSDPRS_CTSUSOFF_0 = 0x0
	// High-pass noise reduction function turned off
	CTSU_CTSUSDPRS_CTSUSOFF_1 = 0x1
	// Position of CTSUPRMODE field.
	CTSU_CTSUSDPRS_CTSUPRMODE_Pos = 0x4
	// Bit mask of CTSUPRMODE field.
	CTSU_CTSUSDPRS_CTSUPRMODE_Msk = 0x30
	// 510 pulses
	CTSU_CTSUSDPRS_CTSUPRMODE_00 = 0x0
	// 126 pulses
	CTSU_CTSUSDPRS_CTSUPRMODE_01 = 0x1
	// 62 pulses (recommended setting value)
	CTSU_CTSUSDPRS_CTSUPRMODE_10 = 0x2
	// Setting prohibited
	CTSU_CTSUSDPRS_CTSUPRMODE_11 = 0x3
	// Position of CTSUPRRATIO field.
	CTSU_CTSUSDPRS_CTSUPRRATIO_Pos = 0x0
	// Bit mask of CTSUPRRATIO field.
	CTSU_CTSUSDPRS_CTSUPRRATIO_Msk = 0xf

	// CTSUSST: CTSU Sensor Stabilization Wait Control Register
	// Position of CTSUSST field.
	CTSU_CTSUSST_CTSUSST_Pos = 0x0
	// Bit mask of CTSUSST field.
	CTSU_CTSUSST_CTSUSST_Msk = 0xff

	// CTSUMCH0: CTSU Measurement Channel Register 0
	// Position of Reserved field.
	CTSU_CTSUMCH0_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	CTSU_CTSUMCH0_Reserved_Msk = 0xc0
	// Position of CTSUMCH0 field.
	CTSU_CTSUMCH0_CTSUMCH0_Pos = 0x0
	// Bit mask of CTSUMCH0 field.
	CTSU_CTSUMCH0_CTSUMCH0_Msk = 0x3f

	// CTSUMCH1: CTSU Measurement Channel Register 1
	// Position of Reserved field.
	CTSU_CTSUMCH1_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	CTSU_CTSUMCH1_Reserved_Msk = 0xc0
	// Position of CTSUMCH1 field.
	CTSU_CTSUMCH1_CTSUMCH1_Pos = 0x0
	// Bit mask of CTSUMCH1 field.
	CTSU_CTSUMCH1_CTSUMCH1_Msk = 0x3f

	// CTSUCHAC0: CTSU Channel Enable Control Register 0
	// Position of CTSUCHAC0 field.
	CTSU_CTSUCHAC0_CTSUCHAC0_Pos = 0x0
	// Bit mask of CTSUCHAC0 field.
	CTSU_CTSUCHAC0_CTSUCHAC0_Msk = 0xff

	// CTSUCHAC1: CTSU Channel Enable Control Register 1
	// Position of CTSUCHAC1 field.
	CTSU_CTSUCHAC1_CTSUCHAC1_Pos = 0x0
	// Bit mask of CTSUCHAC1 field.
	CTSU_CTSUCHAC1_CTSUCHAC1_Msk = 0xff

	// CTSUCHAC2: CTSU Channel Enable Control Register 2
	// Position of CTSUCHAC2 field.
	CTSU_CTSUCHAC2_CTSUCHAC2_Pos = 0x0
	// Bit mask of CTSUCHAC2 field.
	CTSU_CTSUCHAC2_CTSUCHAC2_Msk = 0xff

	// CTSUCHAC3: CTSU Channel Enable Control Register 3
	// Position of CTSUCHAC3 field.
	CTSU_CTSUCHAC3_CTSUCHAC3_Pos = 0x0
	// Bit mask of CTSUCHAC3 field.
	CTSU_CTSUCHAC3_CTSUCHAC3_Msk = 0xff

	// CTSUCHAC4: CTSU Channel Enable Control Register 4
	// Position of Reserved field.
	CTSU_CTSUCHAC4_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	CTSU_CTSUCHAC4_Reserved_Msk = 0xf0
	// Position of CTSUCHAC4 field.
	CTSU_CTSUCHAC4_CTSUCHAC4_Pos = 0x0
	// Bit mask of CTSUCHAC4 field.
	CTSU_CTSUCHAC4_CTSUCHAC4_Msk = 0xf

	// CTSUCHTRC0: CTSU Channel Transmit/Receive Control Register 0
	// Position of CTSUCHTRC0 field.
	CTSU_CTSUCHTRC0_CTSUCHTRC0_Pos = 0x0
	// Bit mask of CTSUCHTRC0 field.
	CTSU_CTSUCHTRC0_CTSUCHTRC0_Msk = 0xff
	// Reception
	CTSU_CTSUCHTRC0_CTSUCHTRC0_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRC0_CTSUCHTRC0_1 = 0x1

	// CTSUCHTRC1: CTSU Channel Transmit/Receive Control Register 1
	// Position of CTSUCHTRC1 field.
	CTSU_CTSUCHTRC1_CTSUCHTRC1_Pos = 0x0
	// Bit mask of CTSUCHTRC1 field.
	CTSU_CTSUCHTRC1_CTSUCHTRC1_Msk = 0xff
	// Reception
	CTSU_CTSUCHTRC1_CTSUCHTRC1_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRC1_CTSUCHTRC1_1 = 0x1

	// CTSUCHTRC2: CTSU Channel Transmit/Receive Control Register 3
	// Position of CTSUCHTRC2 field.
	CTSU_CTSUCHTRC2_CTSUCHTRC2_Pos = 0x0
	// Bit mask of CTSUCHTRC2 field.
	CTSU_CTSUCHTRC2_CTSUCHTRC2_Msk = 0xff
	// Reception
	CTSU_CTSUCHTRC2_CTSUCHTRC2_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRC2_CTSUCHTRC2_1 = 0x1

	// CTSUCHTRC3: CTSU Channel Transmit/Receive Control Register 3
	// Position of CTSUCHTRC3 field.
	CTSU_CTSUCHTRC3_CTSUCHTRC3_Pos = 0x0
	// Bit mask of CTSUCHTRC3 field.
	CTSU_CTSUCHTRC3_CTSUCHTRC3_Msk = 0xff
	// Reception
	CTSU_CTSUCHTRC3_CTSUCHTRC3_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRC3_CTSUCHTRC3_1 = 0x1

	// CTSUCHTRC4: CTSU Channel Transmit/Receive Control Register 4
	// Position of Reserved field.
	CTSU_CTSUCHTRC4_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	CTSU_CTSUCHTRC4_Reserved_Msk = 0xf0
	// Position of CTSUCHAC4 field.
	CTSU_CTSUCHTRC4_CTSUCHAC4_Pos = 0x0
	// Bit mask of CTSUCHAC4 field.
	CTSU_CTSUCHTRC4_CTSUCHAC4_Msk = 0xf
	// Reception
	CTSU_CTSUCHTRC4_CTSUCHAC4_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRC4_CTSUCHAC4_1 = 0x1

	// CTSUDCLKC: CTSU High-Pass Noise Reduction Control Register
	// Position of Reserved field.
	CTSU_CTSUDCLKC_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	CTSU_CTSUDCLKC_Reserved_Msk = 0xc0
	// Position of CTSUSSCNT field.
	CTSU_CTSUDCLKC_CTSUSSCNT_Pos = 0x4
	// Bit mask of CTSUSSCNT field.
	CTSU_CTSUDCLKC_CTSUSSCNT_Msk = 0x30
	// Position of Reserved field.
	CTSU_CTSUDCLKC_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	CTSU_CTSUDCLKC_Reserved_Msk = 0xc
	// Position of CTSUSSMOD field.
	CTSU_CTSUDCLKC_CTSUSSMOD_Pos = 0x0
	// Bit mask of CTSUSSMOD field.
	CTSU_CTSUDCLKC_CTSUSSMOD_Msk = 0x3

	// CTSUST: CTSU Status Register
	// Position of CTSUPS field.
	CTSU_CTSUST_CTSUPS_Pos = 0x7
	// Bit mask of CTSUPS field.
	CTSU_CTSUST_CTSUPS_Msk = 0x80
	// Bit CTSUPS.
	CTSU_CTSUST_CTSUPS = 0x80
	// First measurement
	CTSU_CTSUST_CTSUPS_0 = 0x0
	// Second measurement
	CTSU_CTSUST_CTSUPS_1 = 0x1
	// Position of CTSUROVF field.
	CTSU_CTSUST_CTSUROVF_Pos = 0x6
	// Bit mask of CTSUROVF field.
	CTSU_CTSUST_CTSUROVF_Msk = 0x40
	// Bit CTSUROVF.
	CTSU_CTSUST_CTSUROVF = 0x40
	// No overflow
	CTSU_CTSUST_CTSUROVF_0 = 0x0
	// An overflow
	CTSU_CTSUST_CTSUROVF_1 = 0x1
	// Position of CTSUSOVF field.
	CTSU_CTSUST_CTSUSOVF_Pos = 0x5
	// Bit mask of CTSUSOVF field.
	CTSU_CTSUST_CTSUSOVF_Msk = 0x20
	// Bit CTSUSOVF.
	CTSU_CTSUST_CTSUSOVF = 0x20
	// No overflow
	CTSU_CTSUST_CTSUSOVF_0 = 0x0
	// An overflow
	CTSU_CTSUST_CTSUSOVF_1 = 0x1
	// Position of CTSUDTSR field.
	CTSU_CTSUST_CTSUDTSR_Pos = 0x4
	// Bit mask of CTSUDTSR field.
	CTSU_CTSUST_CTSUDTSR_Msk = 0x10
	// Bit CTSUDTSR.
	CTSU_CTSUST_CTSUDTSR = 0x10
	// Measurement result has been read
	CTSU_CTSUST_CTSUDTSR_0 = 0x0
	// Measurement result has not been read
	CTSU_CTSUST_CTSUDTSR_1 = 0x1
	// Position of Reserved field.
	CTSU_CTSUST_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	CTSU_CTSUST_Reserved_Msk = 0x8
	// Bit Reserved.
	CTSU_CTSUST_Reserved = 0x8
	// Position of CTSUSTC field.
	CTSU_CTSUST_CTSUSTC_Pos = 0x0
	// Bit mask of CTSUSTC field.
	CTSU_CTSUST_CTSUSTC_Msk = 0x7
	// Status 0
	CTSU_CTSUST_CTSUSTC_000 = 0x0
	// Status 1
	CTSU_CTSUST_CTSUSTC_001 = 0x1
	// Status 2
	CTSU_CTSUST_CTSUSTC_010 = 0x2
	// Status 3
	CTSU_CTSUST_CTSUSTC_011 = 0x3
	// Status 4
	CTSU_CTSUST_CTSUSTC_100 = 0x4
	// Status 5
	CTSU_CTSUST_CTSUSTC_101 = 0x5

	// CTSUSSC: CTSU High-Pass Noise Reduction Spectrum Diffusion Control Register
	// Position of Reserved field.
	CTSU_CTSUSSC_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	CTSU_CTSUSSC_Reserved_Msk = 0xf000
	// Position of CTSUSSDIV field.
	CTSU_CTSUSSC_CTSUSSDIV_Pos = 0x8
	// Bit mask of CTSUSSDIV field.
	CTSU_CTSUSSC_CTSUSSDIV_Msk = 0xf00
	// 4.00 <= fb
	CTSU_CTSUSSC_CTSUSSDIV_0000 = 0x0
	// 2.00 <= fb < 4.00
	CTSU_CTSUSSC_CTSUSSDIV_0001 = 0x1
	// 1.33 <= fb < 2.00
	CTSU_CTSUSSC_CTSUSSDIV_0010 = 0x2
	// 1.00 <= fb < 1.33
	CTSU_CTSUSSC_CTSUSSDIV_0011 = 0x3
	// 0.80 <= fb < 1.00
	CTSU_CTSUSSC_CTSUSSDIV_0100 = 0x4
	// 0.67 <= fb < 0.80
	CTSU_CTSUSSC_CTSUSSDIV_0101 = 0x5
	// 0.57 <= fb < 0.67
	CTSU_CTSUSSC_CTSUSSDIV_0110 = 0x6
	// 0.50 <= fb < 0.57
	CTSU_CTSUSSC_CTSUSSDIV_0111 = 0x7
	// 0.44 <= fb < 0.50
	CTSU_CTSUSSC_CTSUSSDIV_1000 = 0x8
	// 0.40 <= fb < 0.44
	CTSU_CTSUSSC_CTSUSSDIV_1001 = 0x9
	// 0.36 <= fb < 0.40
	CTSU_CTSUSSC_CTSUSSDIV_1010 = 0xa
	// 0.33 <= fb < 0.36
	CTSU_CTSUSSC_CTSUSSDIV_1011 = 0xb
	// 0.31 <= fb < 0.33
	CTSU_CTSUSSC_CTSUSSDIV_1100 = 0xc
	// 0.29 <= fb < 0.31
	CTSU_CTSUSSC_CTSUSSDIV_1101 = 0xd
	// 0.27 <= fb < 0.29
	CTSU_CTSUSSC_CTSUSSDIV_1110 = 0xe
	// fb < 0.27
	CTSU_CTSUSSC_CTSUSSDIV_1111 = 0xf
	// Position of Reserved field.
	CTSU_CTSUSSC_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	CTSU_CTSUSSC_Reserved_Msk = 0xff

	// CTSUSO0: CTSU Sensor Offset Register 0
	// Position of CTSUSNUM field.
	CTSU_CTSUSO0_CTSUSNUM_Pos = 0xa
	// Bit mask of CTSUSNUM field.
	CTSU_CTSUSO0_CTSUSNUM_Msk = 0xfc00
	// Position of CTSUSO field.
	CTSU_CTSUSO0_CTSUSO_Pos = 0x0
	// Bit mask of CTSUSO field.
	CTSU_CTSUSO0_CTSUSO_Msk = 0x3ff

	// CTSUSO1: CTSU Sensor Offset Register 1
	// Position of Reserved field.
	CTSU_CTSUSO1_Reserved_Pos = 0xf
	// Bit mask of Reserved field.
	CTSU_CTSUSO1_Reserved_Msk = 0x8000
	// Bit Reserved.
	CTSU_CTSUSO1_Reserved = 0x8000
	// Position of CTSUICOG field.
	CTSU_CTSUSO1_CTSUICOG_Pos = 0xd
	// Bit mask of CTSUICOG field.
	CTSU_CTSUSO1_CTSUICOG_Msk = 0x6000
	// 100 percent gain
	CTSU_CTSUSO1_CTSUICOG_00 = 0x0
	// 66 percent gain
	CTSU_CTSUSO1_CTSUICOG_01 = 0x1
	// 50 percent gain
	CTSU_CTSUSO1_CTSUICOG_10 = 0x2
	// 40 percent gain
	CTSU_CTSUSO1_CTSUICOG_11 = 0x3
	// Position of CTSUSDPA field.
	CTSU_CTSUSO1_CTSUSDPA_Pos = 0x8
	// Bit mask of CTSUSDPA field.
	CTSU_CTSUSO1_CTSUSDPA_Msk = 0x1f00
	// Position of CTSURICOA field.
	CTSU_CTSUSO1_CTSURICOA_Pos = 0x0
	// Bit mask of CTSURICOA field.
	CTSU_CTSUSO1_CTSURICOA_Msk = 0xff

	// CTSUSC: CTSU Sensor Counter
	// Position of CTSUSC field.
	CTSU_CTSUSC_CTSUSC_Pos = 0x0
	// Bit mask of CTSUSC field.
	CTSU_CTSUSC_CTSUSC_Msk = 0xffff

	// CTSURC: CTSU Reference Counter
	// Position of CTSURC field.
	CTSU_CTSURC_CTSURC_Pos = 0x0
	// Bit mask of CTSURC field.
	CTSU_CTSURC_CTSURC_Msk = 0xffff

	// CTSUERRS: CTSU Error Status Register
	// Position of CTSUICOMP field.
	CTSU_CTSUERRS_CTSUICOMP_Pos = 0xf
	// Bit mask of CTSUICOMP field.
	CTSU_CTSUERRS_CTSUICOMP_Msk = 0x8000
	// Bit CTSUICOMP.
	CTSU_CTSUERRS_CTSUICOMP = 0x8000
	// Normal TSCAP voltage
	CTSU_CTSUERRS_CTSUICOMP_0 = 0x0
	// Abnormal TSCAP voltage
	CTSU_CTSUERRS_CTSUICOMP_1 = 0x1
	// Position of Reserved field.
	CTSU_CTSUERRS_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	CTSU_CTSUERRS_Reserved_Msk = 0x7fff
)

// Constants for ADC140: 14bit A/D Converter
const (
	// ADCSR: A/D Control Register
	// Position of ADST field.
	ADC140_ADCSR_ADST_Pos = 0xf
	// Bit mask of ADST field.
	ADC140_ADCSR_ADST_Msk = 0x8000
	// Bit ADST.
	ADC140_ADCSR_ADST = 0x8000
	// Stops A/D conversion process.
	ADC140_ADCSR_ADST_0 = 0x0
	// Starts A/D conversion process.
	ADC140_ADCSR_ADST_1 = 0x1
	// Position of ADCS field.
	ADC140_ADCSR_ADCS_Pos = 0xd
	// Bit mask of ADCS field.
	ADC140_ADCSR_ADCS_Msk = 0x6000
	// Single scan mode
	ADC140_ADCSR_ADCS_00 = 0x0
	// Group scan mode
	ADC140_ADCSR_ADCS_01 = 0x1
	// Continuous scan mode
	ADC140_ADCSR_ADCS_10 = 0x2
	// Setting prohibited
	ADC140_ADCSR_ADCS_11 = 0x3
	// Position of Reserved field.
	ADC140_ADCSR_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	ADC140_ADCSR_Reserved_Msk = 0x1800
	// Position of ADHSC field.
	ADC140_ADCSR_ADHSC_Pos = 0xa
	// Bit mask of ADHSC field.
	ADC140_ADCSR_ADHSC_Msk = 0x400
	// Bit ADHSC.
	ADC140_ADCSR_ADHSC = 0x400
	// High speed A/D conversion mode
	ADC140_ADCSR_ADHSC_0 = 0x0
	// Low current A/D conversion mode
	ADC140_ADCSR_ADHSC_1 = 0x1
	// Position of TRGE field.
	ADC140_ADCSR_TRGE_Pos = 0x9
	// Bit mask of TRGE field.
	ADC140_ADCSR_TRGE_Msk = 0x200
	// Bit TRGE.
	ADC140_ADCSR_TRGE = 0x200
	// Disables A/D conversion to be started by the synchronous or asynchronous trigger.
	ADC140_ADCSR_TRGE_0 = 0x0
	// Enables A/D conversion to be started by the synchronous or asynchronous trigger.
	ADC140_ADCSR_TRGE_1 = 0x1
	// Position of EXTRG field.
	ADC140_ADCSR_EXTRG_Pos = 0x8
	// Bit mask of EXTRG field.
	ADC140_ADCSR_EXTRG_Msk = 0x100
	// Bit EXTRG.
	ADC140_ADCSR_EXTRG = 0x100
	// A/D conversion is started by the synchronous trigger (ELC).
	ADC140_ADCSR_EXTRG_0 = 0x0
	// A/D conversion is started by the asynchronous trigger (ADTRG0#).
	ADC140_ADCSR_EXTRG_1 = 0x1
	// Position of DBLE field.
	ADC140_ADCSR_DBLE_Pos = 0x7
	// Bit mask of DBLE field.
	ADC140_ADCSR_DBLE_Msk = 0x80
	// Bit DBLE.
	ADC140_ADCSR_DBLE = 0x80
	// Double trigger mode non-selection
	ADC140_ADCSR_DBLE_0 = 0x0
	// Double trigger mode selection
	ADC140_ADCSR_DBLE_1 = 0x1
	// Position of GBADIE field.
	ADC140_ADCSR_GBADIE_Pos = 0x6
	// Bit mask of GBADIE field.
	ADC140_ADCSR_GBADIE_Msk = 0x40
	// Bit GBADIE.
	ADC140_ADCSR_GBADIE = 0x40
	// Disables S12GBADI0 interrupt generation upon group B scan completion.
	ADC140_ADCSR_GBADIE_0 = 0x0
	// Enables S12GBADI0 interrupt generation upon group B scan completion.
	ADC140_ADCSR_GBADIE_1 = 0x1
	// Position of Reserved field.
	ADC140_ADCSR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	ADC140_ADCSR_Reserved_Msk = 0x20
	// Bit Reserved.
	ADC140_ADCSR_Reserved = 0x20
	// Position of DBLANS field.
	ADC140_ADCSR_DBLANS_Pos = 0x0
	// Bit mask of DBLANS field.
	ADC140_ADCSR_DBLANS_Msk = 0x1f

	// ADANSA0: A/D Channel Select Register A0
	// Position of ANSA015 field.
	ADC140_ADANSA0_ANSA015_Pos = 0xf
	// Bit mask of ANSA015 field.
	ADC140_ADANSA0_ANSA015_Msk = 0x8000
	// Bit ANSA015.
	ADC140_ADANSA0_ANSA015 = 0x8000
	// AN015 is not subjected to conversion.
	ADC140_ADANSA0_ANSA015_0 = 0x0
	// AN015 is subjected to conversion.
	ADC140_ADANSA0_ANSA015_1 = 0x1
	// Position of ANSA014 field.
	ADC140_ADANSA0_ANSA014_Pos = 0xe
	// Bit mask of ANSA014 field.
	ADC140_ADANSA0_ANSA014_Msk = 0x4000
	// Bit ANSA014.
	ADC140_ADANSA0_ANSA014 = 0x4000
	// AN014 is not subjected to conversion.
	ADC140_ADANSA0_ANSA014_0 = 0x0
	// AN014 is subjected to conversion.
	ADC140_ADANSA0_ANSA014_1 = 0x1
	// Position of ANSA013 field.
	ADC140_ADANSA0_ANSA013_Pos = 0xd
	// Bit mask of ANSA013 field.
	ADC140_ADANSA0_ANSA013_Msk = 0x2000
	// Bit ANSA013.
	ADC140_ADANSA0_ANSA013 = 0x2000
	// AN013 is not subjected to conversion.
	ADC140_ADANSA0_ANSA013_0 = 0x0
	// AN013 is subjected to conversion.
	ADC140_ADANSA0_ANSA013_1 = 0x1
	// Position of ANSA012 field.
	ADC140_ADANSA0_ANSA012_Pos = 0xc
	// Bit mask of ANSA012 field.
	ADC140_ADANSA0_ANSA012_Msk = 0x1000
	// Bit ANSA012.
	ADC140_ADANSA0_ANSA012 = 0x1000
	// AN012 is not subjected to conversion.
	ADC140_ADANSA0_ANSA012_0 = 0x0
	// AN012 is subjected to conversion.
	ADC140_ADANSA0_ANSA012_1 = 0x1
	// Position of ANSA011 field.
	ADC140_ADANSA0_ANSA011_Pos = 0xb
	// Bit mask of ANSA011 field.
	ADC140_ADANSA0_ANSA011_Msk = 0x800
	// Bit ANSA011.
	ADC140_ADANSA0_ANSA011 = 0x800
	// AN011 is not subjected to conversion.
	ADC140_ADANSA0_ANSA011_0 = 0x0
	// AN011 is subjected to conversion.
	ADC140_ADANSA0_ANSA011_1 = 0x1
	// Position of ANSA010 field.
	ADC140_ADANSA0_ANSA010_Pos = 0xa
	// Bit mask of ANSA010 field.
	ADC140_ADANSA0_ANSA010_Msk = 0x400
	// Bit ANSA010.
	ADC140_ADANSA0_ANSA010 = 0x400
	// AN010 is not subjected to conversion.
	ADC140_ADANSA0_ANSA010_0 = 0x0
	// AN010 is subjected to conversion.
	ADC140_ADANSA0_ANSA010_1 = 0x1
	// Position of ANSA09 field.
	ADC140_ADANSA0_ANSA09_Pos = 0x9
	// Bit mask of ANSA09 field.
	ADC140_ADANSA0_ANSA09_Msk = 0x200
	// Bit ANSA09.
	ADC140_ADANSA0_ANSA09 = 0x200
	// AN009 is not subjected to conversion.
	ADC140_ADANSA0_ANSA09_0 = 0x0
	// AN009 is subjected to conversion.
	ADC140_ADANSA0_ANSA09_1 = 0x1
	// Position of ANSA08 field.
	ADC140_ADANSA0_ANSA08_Pos = 0x8
	// Bit mask of ANSA08 field.
	ADC140_ADANSA0_ANSA08_Msk = 0x100
	// Bit ANSA08.
	ADC140_ADANSA0_ANSA08 = 0x100
	// AN008 is not subjected to conversion.
	ADC140_ADANSA0_ANSA08_0 = 0x0
	// AN008 is subjected to conversion.
	ADC140_ADANSA0_ANSA08_1 = 0x1
	// Position of ANSA07 field.
	ADC140_ADANSA0_ANSA07_Pos = 0x7
	// Bit mask of ANSA07 field.
	ADC140_ADANSA0_ANSA07_Msk = 0x80
	// Bit ANSA07.
	ADC140_ADANSA0_ANSA07 = 0x80
	// AN007 is not subjected to conversion.
	ADC140_ADANSA0_ANSA07_0 = 0x0
	// AN007 is subjected to conversion.
	ADC140_ADANSA0_ANSA07_1 = 0x1
	// Position of ANSA06 field.
	ADC140_ADANSA0_ANSA06_Pos = 0x6
	// Bit mask of ANSA06 field.
	ADC140_ADANSA0_ANSA06_Msk = 0x40
	// Bit ANSA06.
	ADC140_ADANSA0_ANSA06 = 0x40
	// AN006 is not subjected to conversion.
	ADC140_ADANSA0_ANSA06_0 = 0x0
	// AN006 is subjected to conversion.
	ADC140_ADANSA0_ANSA06_1 = 0x1
	// Position of ANSA05 field.
	ADC140_ADANSA0_ANSA05_Pos = 0x5
	// Bit mask of ANSA05 field.
	ADC140_ADANSA0_ANSA05_Msk = 0x20
	// Bit ANSA05.
	ADC140_ADANSA0_ANSA05 = 0x20
	// AN005 is not subjected to conversion.
	ADC140_ADANSA0_ANSA05_0 = 0x0
	// AN005 is subjected to conversion.
	ADC140_ADANSA0_ANSA05_1 = 0x1
	// Position of ANSA04 field.
	ADC140_ADANSA0_ANSA04_Pos = 0x4
	// Bit mask of ANSA04 field.
	ADC140_ADANSA0_ANSA04_Msk = 0x10
	// Bit ANSA04.
	ADC140_ADANSA0_ANSA04 = 0x10
	// AN004 is not subjected to conversion.
	ADC140_ADANSA0_ANSA04_0 = 0x0
	// AN004 is subjected to conversion.
	ADC140_ADANSA0_ANSA04_1 = 0x1
	// Position of ANSA03 field.
	ADC140_ADANSA0_ANSA03_Pos = 0x3
	// Bit mask of ANSA03 field.
	ADC140_ADANSA0_ANSA03_Msk = 0x8
	// Bit ANSA03.
	ADC140_ADANSA0_ANSA03 = 0x8
	// AN003 is not subjected to conversion.
	ADC140_ADANSA0_ANSA03_0 = 0x0
	// AN003 is subjected to conversion.
	ADC140_ADANSA0_ANSA03_1 = 0x1
	// Position of ANSA02 field.
	ADC140_ADANSA0_ANSA02_Pos = 0x2
	// Bit mask of ANSA02 field.
	ADC140_ADANSA0_ANSA02_Msk = 0x4
	// Bit ANSA02.
	ADC140_ADANSA0_ANSA02 = 0x4
	// AN002 is not subjected to conversion.
	ADC140_ADANSA0_ANSA02_0 = 0x0
	// AN002 is subjected to conversion.
	ADC140_ADANSA0_ANSA02_1 = 0x1
	// Position of ANSA01 field.
	ADC140_ADANSA0_ANSA01_Pos = 0x1
	// Bit mask of ANSA01 field.
	ADC140_ADANSA0_ANSA01_Msk = 0x2
	// Bit ANSA01.
	ADC140_ADANSA0_ANSA01 = 0x2
	// AN001 is not subjected to conversion.
	ADC140_ADANSA0_ANSA01_0 = 0x0
	// AN001 is subjected to conversion.
	ADC140_ADANSA0_ANSA01_1 = 0x1
	// Position of ANSA00 field.
	ADC140_ADANSA0_ANSA00_Pos = 0x0
	// Bit mask of ANSA00 field.
	ADC140_ADANSA0_ANSA00_Msk = 0x1
	// Bit ANSA00.
	ADC140_ADANSA0_ANSA00 = 0x1
	// AN000 is not subjected to conversion.
	ADC140_ADANSA0_ANSA00_0 = 0x0
	// AN000 is subjected to conversion.
	ADC140_ADANSA0_ANSA00_1 = 0x1

	// ADANSA1: A/D Channel Select Register A1
	// Position of Reserved field.
	ADC140_ADANSA1_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	ADC140_ADANSA1_Reserved_Msk = 0xf000
	// Position of ANSA27 field.
	ADC140_ADANSA1_ANSA27_Pos = 0xb
	// Bit mask of ANSA27 field.
	ADC140_ADANSA1_ANSA27_Msk = 0x800
	// Bit ANSA27.
	ADC140_ADANSA1_ANSA27 = 0x800
	// AN027 is not subjected to conversion.
	ADC140_ADANSA1_ANSA27_0 = 0x0
	// AN027 is subjected to conversion.
	ADC140_ADANSA1_ANSA27_1 = 0x1
	// Position of ANSA26 field.
	ADC140_ADANSA1_ANSA26_Pos = 0xa
	// Bit mask of ANSA26 field.
	ADC140_ADANSA1_ANSA26_Msk = 0x400
	// Bit ANSA26.
	ADC140_ADANSA1_ANSA26 = 0x400
	// AN026 is not subjected to conversion.
	ADC140_ADANSA1_ANSA26_0 = 0x0
	// AN026 is subjected to conversion.
	ADC140_ADANSA1_ANSA26_1 = 0x1
	// Position of ANSA25 field.
	ADC140_ADANSA1_ANSA25_Pos = 0x9
	// Bit mask of ANSA25 field.
	ADC140_ADANSA1_ANSA25_Msk = 0x200
	// Bit ANSA25.
	ADC140_ADANSA1_ANSA25 = 0x200
	// AN025 is not subjected to conversion.
	ADC140_ADANSA1_ANSA25_0 = 0x0
	// AN025 is subjected to conversion.
	ADC140_ADANSA1_ANSA25_1 = 0x1
	// Position of ANSA24 field.
	ADC140_ADANSA1_ANSA24_Pos = 0x8
	// Bit mask of ANSA24 field.
	ADC140_ADANSA1_ANSA24_Msk = 0x100
	// Bit ANSA24.
	ADC140_ADANSA1_ANSA24 = 0x100
	// AN024 is not subjected to conversion.
	ADC140_ADANSA1_ANSA24_0 = 0x0
	// AN024 is subjected to conversion.
	ADC140_ADANSA1_ANSA24_1 = 0x1
	// Position of ANSA23 field.
	ADC140_ADANSA1_ANSA23_Pos = 0x7
	// Bit mask of ANSA23 field.
	ADC140_ADANSA1_ANSA23_Msk = 0x80
	// Bit ANSA23.
	ADC140_ADANSA1_ANSA23 = 0x80
	// AN023 is not subjected to conversion.
	ADC140_ADANSA1_ANSA23_0 = 0x0
	// AN023 is subjected to conversion.
	ADC140_ADANSA1_ANSA23_1 = 0x1
	// Position of ANSA22 field.
	ADC140_ADANSA1_ANSA22_Pos = 0x6
	// Bit mask of ANSA22 field.
	ADC140_ADANSA1_ANSA22_Msk = 0x40
	// Bit ANSA22.
	ADC140_ADANSA1_ANSA22 = 0x40
	// AN022 is not subjected to conversion.
	ADC140_ADANSA1_ANSA22_0 = 0x0
	// AN022 is subjected to conversion.
	ADC140_ADANSA1_ANSA22_1 = 0x1
	// Position of ANSA21 field.
	ADC140_ADANSA1_ANSA21_Pos = 0x5
	// Bit mask of ANSA21 field.
	ADC140_ADANSA1_ANSA21_Msk = 0x20
	// Bit ANSA21.
	ADC140_ADANSA1_ANSA21 = 0x20
	// AN021 is not subjected to conversion.
	ADC140_ADANSA1_ANSA21_0 = 0x0
	// AN021 is subjected to conversion.
	ADC140_ADANSA1_ANSA21_1 = 0x1
	// Position of ANSA20 field.
	ADC140_ADANSA1_ANSA20_Pos = 0x4
	// Bit mask of ANSA20 field.
	ADC140_ADANSA1_ANSA20_Msk = 0x10
	// Bit ANSA20.
	ADC140_ADANSA1_ANSA20 = 0x10
	// AN020 is not subjected to conversion.
	ADC140_ADANSA1_ANSA20_0 = 0x0
	// AN020 is subjected to conversion.
	ADC140_ADANSA1_ANSA20_1 = 0x1
	// Position of ANSA19 field.
	ADC140_ADANSA1_ANSA19_Pos = 0x3
	// Bit mask of ANSA19 field.
	ADC140_ADANSA1_ANSA19_Msk = 0x8
	// Bit ANSA19.
	ADC140_ADANSA1_ANSA19 = 0x8
	// AN019 is not subjected to conversion.
	ADC140_ADANSA1_ANSA19_0 = 0x0
	// AN019 is subjected to conversion.
	ADC140_ADANSA1_ANSA19_1 = 0x1
	// Position of ANSA18 field.
	ADC140_ADANSA1_ANSA18_Pos = 0x2
	// Bit mask of ANSA18 field.
	ADC140_ADANSA1_ANSA18_Msk = 0x4
	// Bit ANSA18.
	ADC140_ADANSA1_ANSA18 = 0x4
	// AN018 is not subjected to conversion.
	ADC140_ADANSA1_ANSA18_0 = 0x0
	// AN018 is subjected to conversion.
	ADC140_ADANSA1_ANSA18_1 = 0x1
	// Position of ANSA17 field.
	ADC140_ADANSA1_ANSA17_Pos = 0x1
	// Bit mask of ANSA17 field.
	ADC140_ADANSA1_ANSA17_Msk = 0x2
	// Bit ANSA17.
	ADC140_ADANSA1_ANSA17 = 0x2
	// AN017 is not subjected to conversion.
	ADC140_ADANSA1_ANSA17_0 = 0x0
	// AN017 is subjected to conversion.
	ADC140_ADANSA1_ANSA17_1 = 0x1
	// Position of ANSA16 field.
	ADC140_ADANSA1_ANSA16_Pos = 0x0
	// Bit mask of ANSA16 field.
	ADC140_ADANSA1_ANSA16_Msk = 0x1
	// Bit ANSA16.
	ADC140_ADANSA1_ANSA16 = 0x1
	// AN016 is not subjected to conversion.
	ADC140_ADANSA1_ANSA16_0 = 0x0
	// AN016 is subjected to conversion.
	ADC140_ADANSA1_ANSA16_1 = 0x1

	// ADADS0: A/D-Converted Value Addition/Average Channel Select Register 0
	// Position of ADS15 field.
	ADC140_ADADS0_ADS15_Pos = 0xf
	// Bit mask of ADS15 field.
	ADC140_ADADS0_ADS15_Msk = 0x8000
	// Bit ADS15.
	ADC140_ADADS0_ADS15 = 0x8000
	// AN015 is not selected.
	ADC140_ADADS0_ADS15_0 = 0x0
	// AN015 is selected.
	ADC140_ADADS0_ADS15_1 = 0x1
	// Position of ADS14 field.
	ADC140_ADADS0_ADS14_Pos = 0xe
	// Bit mask of ADS14 field.
	ADC140_ADADS0_ADS14_Msk = 0x4000
	// Bit ADS14.
	ADC140_ADADS0_ADS14 = 0x4000
	// AN014 is not selected.
	ADC140_ADADS0_ADS14_0 = 0x0
	// AN014 is selected.
	ADC140_ADADS0_ADS14_1 = 0x1
	// Position of ADS13 field.
	ADC140_ADADS0_ADS13_Pos = 0xd
	// Bit mask of ADS13 field.
	ADC140_ADADS0_ADS13_Msk = 0x2000
	// Bit ADS13.
	ADC140_ADADS0_ADS13 = 0x2000
	// AN013 is not selected.
	ADC140_ADADS0_ADS13_0 = 0x0
	// AN013 is selected.
	ADC140_ADADS0_ADS13_1 = 0x1
	// Position of ADS12 field.
	ADC140_ADADS0_ADS12_Pos = 0xc
	// Bit mask of ADS12 field.
	ADC140_ADADS0_ADS12_Msk = 0x1000
	// Bit ADS12.
	ADC140_ADADS0_ADS12 = 0x1000
	// AN012 is not selected.
	ADC140_ADADS0_ADS12_0 = 0x0
	// AN012 is selected.
	ADC140_ADADS0_ADS12_1 = 0x1
	// Position of ADS11 field.
	ADC140_ADADS0_ADS11_Pos = 0xb
	// Bit mask of ADS11 field.
	ADC140_ADADS0_ADS11_Msk = 0x800
	// Bit ADS11.
	ADC140_ADADS0_ADS11 = 0x800
	// AN011 is not selected.
	ADC140_ADADS0_ADS11_0 = 0x0
	// AN011 is selected.
	ADC140_ADADS0_ADS11_1 = 0x1
	// Position of ADS10 field.
	ADC140_ADADS0_ADS10_Pos = 0xa
	// Bit mask of ADS10 field.
	ADC140_ADADS0_ADS10_Msk = 0x400
	// Bit ADS10.
	ADC140_ADADS0_ADS10 = 0x400
	// AN010 is not selected.
	ADC140_ADADS0_ADS10_0 = 0x0
	// AN010 is selected.
	ADC140_ADADS0_ADS10_1 = 0x1
	// Position of ADS09 field.
	ADC140_ADADS0_ADS09_Pos = 0x9
	// Bit mask of ADS09 field.
	ADC140_ADADS0_ADS09_Msk = 0x200
	// Bit ADS09.
	ADC140_ADADS0_ADS09 = 0x200
	// AN009 is not selected.
	ADC140_ADADS0_ADS09_0 = 0x0
	// AN009 is selected.
	ADC140_ADADS0_ADS09_1 = 0x1
	// Position of ADS08 field.
	ADC140_ADADS0_ADS08_Pos = 0x8
	// Bit mask of ADS08 field.
	ADC140_ADADS0_ADS08_Msk = 0x100
	// Bit ADS08.
	ADC140_ADADS0_ADS08 = 0x100
	// AN008 is not selected.
	ADC140_ADADS0_ADS08_0 = 0x0
	// AN008 is selected.
	ADC140_ADADS0_ADS08_1 = 0x1
	// Position of ADS07 field.
	ADC140_ADADS0_ADS07_Pos = 0x7
	// Bit mask of ADS07 field.
	ADC140_ADADS0_ADS07_Msk = 0x80
	// Bit ADS07.
	ADC140_ADADS0_ADS07 = 0x80
	// AN007 is not selected.
	ADC140_ADADS0_ADS07_0 = 0x0
	// AN007 is selected.
	ADC140_ADADS0_ADS07_1 = 0x1
	// Position of ADS06 field.
	ADC140_ADADS0_ADS06_Pos = 0x6
	// Bit mask of ADS06 field.
	ADC140_ADADS0_ADS06_Msk = 0x40
	// Bit ADS06.
	ADC140_ADADS0_ADS06 = 0x40
	// AN006 is not selected.
	ADC140_ADADS0_ADS06_0 = 0x0
	// AN006 is selected.
	ADC140_ADADS0_ADS06_1 = 0x1
	// Position of ADS05 field.
	ADC140_ADADS0_ADS05_Pos = 0x5
	// Bit mask of ADS05 field.
	ADC140_ADADS0_ADS05_Msk = 0x20
	// Bit ADS05.
	ADC140_ADADS0_ADS05 = 0x20
	// AN005 is not selected.
	ADC140_ADADS0_ADS05_0 = 0x0
	// AN005 is selected.
	ADC140_ADADS0_ADS05_1 = 0x1
	// Position of ADS04 field.
	ADC140_ADADS0_ADS04_Pos = 0x4
	// Bit mask of ADS04 field.
	ADC140_ADADS0_ADS04_Msk = 0x10
	// Bit ADS04.
	ADC140_ADADS0_ADS04 = 0x10
	// AN004 is not selected.
	ADC140_ADADS0_ADS04_0 = 0x0
	// AN004 is selected.
	ADC140_ADADS0_ADS04_1 = 0x1
	// Position of ADS03 field.
	ADC140_ADADS0_ADS03_Pos = 0x3
	// Bit mask of ADS03 field.
	ADC140_ADADS0_ADS03_Msk = 0x8
	// Bit ADS03.
	ADC140_ADADS0_ADS03 = 0x8
	// AN003 is not selected.
	ADC140_ADADS0_ADS03_0 = 0x0
	// AN003 is selected.
	ADC140_ADADS0_ADS03_1 = 0x1
	// Position of ADS02 field.
	ADC140_ADADS0_ADS02_Pos = 0x2
	// Bit mask of ADS02 field.
	ADC140_ADADS0_ADS02_Msk = 0x4
	// Bit ADS02.
	ADC140_ADADS0_ADS02 = 0x4
	// AN002 is not selected.
	ADC140_ADADS0_ADS02_0 = 0x0
	// AN002 is selected.
	ADC140_ADADS0_ADS02_1 = 0x1
	// Position of ADS01 field.
	ADC140_ADADS0_ADS01_Pos = 0x1
	// Bit mask of ADS01 field.
	ADC140_ADADS0_ADS01_Msk = 0x2
	// Bit ADS01.
	ADC140_ADADS0_ADS01 = 0x2
	// AN001 is not selected.
	ADC140_ADADS0_ADS01_0 = 0x0
	// AN001 is selected.
	ADC140_ADADS0_ADS01_1 = 0x1
	// Position of ADS00 field.
	ADC140_ADADS0_ADS00_Pos = 0x0
	// Bit mask of ADS00 field.
	ADC140_ADADS0_ADS00_Msk = 0x1
	// Bit ADS00.
	ADC140_ADADS0_ADS00 = 0x1
	// AN000 is not selected.
	ADC140_ADADS0_ADS00_0 = 0x0
	// AN000 is selected.
	ADC140_ADADS0_ADS00_1 = 0x1

	// ADADS1: A/D-Converted Value Addition/Average Channel Select Register 1
	// Position of Reserved field.
	ADC140_ADADS1_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	ADC140_ADADS1_Reserved_Msk = 0xf000
	// Position of ADS27 field.
	ADC140_ADADS1_ADS27_Pos = 0xb
	// Bit mask of ADS27 field.
	ADC140_ADADS1_ADS27_Msk = 0x800
	// Bit ADS27.
	ADC140_ADADS1_ADS27 = 0x800
	// AN027 is not selected.
	ADC140_ADADS1_ADS27_0 = 0x0
	// AN027 is selected.
	ADC140_ADADS1_ADS27_1 = 0x1
	// Position of ADS26 field.
	ADC140_ADADS1_ADS26_Pos = 0xa
	// Bit mask of ADS26 field.
	ADC140_ADADS1_ADS26_Msk = 0x400
	// Bit ADS26.
	ADC140_ADADS1_ADS26 = 0x400
	// AN026 is not selected.
	ADC140_ADADS1_ADS26_0 = 0x0
	// AN026 is selected.
	ADC140_ADADS1_ADS26_1 = 0x1
	// Position of ADS25 field.
	ADC140_ADADS1_ADS25_Pos = 0x9
	// Bit mask of ADS25 field.
	ADC140_ADADS1_ADS25_Msk = 0x200
	// Bit ADS25.
	ADC140_ADADS1_ADS25 = 0x200
	// AN025 is not selected.
	ADC140_ADADS1_ADS25_0 = 0x0
	// AN025 is selected.
	ADC140_ADADS1_ADS25_1 = 0x1
	// Position of ADS24 field.
	ADC140_ADADS1_ADS24_Pos = 0x8
	// Bit mask of ADS24 field.
	ADC140_ADADS1_ADS24_Msk = 0x100
	// Bit ADS24.
	ADC140_ADADS1_ADS24 = 0x100
	// AN024 is not selected.
	ADC140_ADADS1_ADS24_0 = 0x0
	// AN024 is selected.
	ADC140_ADADS1_ADS24_1 = 0x1
	// Position of ADS23 field.
	ADC140_ADADS1_ADS23_Pos = 0x7
	// Bit mask of ADS23 field.
	ADC140_ADADS1_ADS23_Msk = 0x80
	// Bit ADS23.
	ADC140_ADADS1_ADS23 = 0x80
	// AN023 is not selected.
	ADC140_ADADS1_ADS23_0 = 0x0
	// AN023 is selected.
	ADC140_ADADS1_ADS23_1 = 0x1
	// Position of ADS22 field.
	ADC140_ADADS1_ADS22_Pos = 0x6
	// Bit mask of ADS22 field.
	ADC140_ADADS1_ADS22_Msk = 0x40
	// Bit ADS22.
	ADC140_ADADS1_ADS22 = 0x40
	// AN022 is not selected.
	ADC140_ADADS1_ADS22_0 = 0x0
	// AN022 is selected.
	ADC140_ADADS1_ADS22_1 = 0x1
	// Position of ADS21 field.
	ADC140_ADADS1_ADS21_Pos = 0x5
	// Bit mask of ADS21 field.
	ADC140_ADADS1_ADS21_Msk = 0x20
	// Bit ADS21.
	ADC140_ADADS1_ADS21 = 0x20
	// AN021 is not selected.
	ADC140_ADADS1_ADS21_0 = 0x0
	// AN021 is selected.
	ADC140_ADADS1_ADS21_1 = 0x1
	// Position of ADS20 field.
	ADC140_ADADS1_ADS20_Pos = 0x4
	// Bit mask of ADS20 field.
	ADC140_ADADS1_ADS20_Msk = 0x10
	// Bit ADS20.
	ADC140_ADADS1_ADS20 = 0x10
	// AN020 is not selected.
	ADC140_ADADS1_ADS20_0 = 0x0
	// AN020 is selected.
	ADC140_ADADS1_ADS20_1 = 0x1
	// Position of ADS19 field.
	ADC140_ADADS1_ADS19_Pos = 0x3
	// Bit mask of ADS19 field.
	ADC140_ADADS1_ADS19_Msk = 0x8
	// Bit ADS19.
	ADC140_ADADS1_ADS19 = 0x8
	// AN019 is not selected.
	ADC140_ADADS1_ADS19_0 = 0x0
	// AN019 is selected.
	ADC140_ADADS1_ADS19_1 = 0x1
	// Position of ADS18 field.
	ADC140_ADADS1_ADS18_Pos = 0x2
	// Bit mask of ADS18 field.
	ADC140_ADADS1_ADS18_Msk = 0x4
	// Bit ADS18.
	ADC140_ADADS1_ADS18 = 0x4
	// AN018 is not selected.
	ADC140_ADADS1_ADS18_0 = 0x0
	// AN018 is selected.
	ADC140_ADADS1_ADS18_1 = 0x1
	// Position of ADS17 field.
	ADC140_ADADS1_ADS17_Pos = 0x1
	// Bit mask of ADS17 field.
	ADC140_ADADS1_ADS17_Msk = 0x2
	// Bit ADS17.
	ADC140_ADADS1_ADS17 = 0x2
	// AN017 is not selected.
	ADC140_ADADS1_ADS17_0 = 0x0
	// AN017 is selected.
	ADC140_ADADS1_ADS17_1 = 0x1
	// Position of ADS16 field.
	ADC140_ADADS1_ADS16_Pos = 0x0
	// Bit mask of ADS16 field.
	ADC140_ADADS1_ADS16_Msk = 0x1
	// Bit ADS16.
	ADC140_ADADS1_ADS16 = 0x1
	// AN016 is not selected.
	ADC140_ADADS1_ADS16_0 = 0x0
	// AN016 is selected.
	ADC140_ADADS1_ADS16_1 = 0x1

	// ADADC: A/D-Converted Value Addition/Average Count Select Register
	// Position of AVEE field.
	ADC140_ADADC_AVEE_Pos = 0x7
	// Bit mask of AVEE field.
	ADC140_ADADC_AVEE_Msk = 0x80
	// Bit AVEE.
	ADC140_ADADC_AVEE = 0x80
	// Disabled
	ADC140_ADADC_AVEE_0 = 0x0
	// Enabled
	ADC140_ADADC_AVEE_1 = 0x1
	// Position of Reserved field.
	ADC140_ADADC_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	ADC140_ADADC_Reserved_Msk = 0x78
	// Position of ADC field.
	ADC140_ADADC_ADC_Pos = 0x0
	// Bit mask of ADC field.
	ADC140_ADADC_ADC_Msk = 0x7
	// 1-time conversion (no addition; same as normal conversion)
	ADC140_ADADC_ADC_000 = 0x0
	// 2-time conversion (addition once)
	ADC140_ADADC_ADC_001 = 0x1
	// 3-time conversion (addition twice)
	ADC140_ADADC_ADC_010 = 0x2
	// 4-time conversion (addition three times)
	ADC140_ADADC_ADC_011 = 0x3
	// 16-time conversion (addition 15 times), can be set when selecting 12-bit accuracy.
	ADC140_ADADC_ADC_101 = 0x5

	// ADCER: A/D Control Extended Register
	// Position of ADRFMT field.
	ADC140_ADCER_ADRFMT_Pos = 0xf
	// Bit mask of ADRFMT field.
	ADC140_ADCER_ADRFMT_Msk = 0x8000
	// Bit ADRFMT.
	ADC140_ADCER_ADRFMT = 0x8000
	// Flush-right is selected for the A/D data register format.
	ADC140_ADCER_ADRFMT_0 = 0x0
	// Flush-left is selected for the A/D data register format.
	ADC140_ADCER_ADRFMT_1 = 0x1
	// Position of Reserved field.
	ADC140_ADCER_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	ADC140_ADCER_Reserved_Msk = 0x7000
	// Position of DIAGM field.
	ADC140_ADCER_DIAGM_Pos = 0xb
	// Bit mask of DIAGM field.
	ADC140_ADCER_DIAGM_Msk = 0x800
	// Bit DIAGM.
	ADC140_ADCER_DIAGM = 0x800
	// Disables self-diagnosis of A/D converter.
	ADC140_ADCER_DIAGM_0 = 0x0
	// Enables self-diagnosis of A/D converter.
	ADC140_ADCER_DIAGM_1 = 0x1
	// Position of DIAGLD field.
	ADC140_ADCER_DIAGLD_Pos = 0xa
	// Bit mask of DIAGLD field.
	ADC140_ADCER_DIAGLD_Msk = 0x400
	// Bit DIAGLD.
	ADC140_ADCER_DIAGLD = 0x400
	// Rotation mode for self-diagnosis voltage
	ADC140_ADCER_DIAGLD_0 = 0x0
	// Fixed mode for self-diagnosis voltage
	ADC140_ADCER_DIAGLD_1 = 0x1
	// Position of DIAGVAL field.
	ADC140_ADCER_DIAGVAL_Pos = 0x8
	// Bit mask of DIAGVAL field.
	ADC140_ADCER_DIAGVAL_Msk = 0x300
	// When the self-diagnosis fixation mode is selected, it set prohibits it.
	ADC140_ADCER_DIAGVAL_00 = 0x0
	// The self-diagnosis by using the voltage of 0V.
	ADC140_ADCER_DIAGVAL_01 = 0x1
	// The self-diagnosis by using the voltage of reference supply x 1/2.
	ADC140_ADCER_DIAGVAL_10 = 0x2
	// The self-diagnosis by using the voltage of the reference supply.
	ADC140_ADCER_DIAGVAL_11 = 0x3
	// Position of Reserved field.
	ADC140_ADCER_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ADC140_ADCER_Reserved_Msk = 0xc0
	// Position of ACE field.
	ADC140_ADCER_ACE_Pos = 0x5
	// Bit mask of ACE field.
	ADC140_ADCER_ACE_Msk = 0x20
	// Bit ACE.
	ADC140_ADCER_ACE = 0x20
	// Disables automatic clearing.
	ADC140_ADCER_ACE_0 = 0x0
	// Enables automatic clearing.
	ADC140_ADCER_ACE_1 = 0x1
	// Position of Reserved field.
	ADC140_ADCER_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	ADC140_ADCER_Reserved_Msk = 0x10
	// Bit Reserved.
	ADC140_ADCER_Reserved = 0x10
	// Position of Reserved field.
	ADC140_ADCER_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	ADC140_ADCER_Reserved_Msk = 0x8
	// Bit Reserved.
	ADC140_ADCER_Reserved = 0x8
	// Position of ADPRC field.
	ADC140_ADCER_ADPRC_Pos = 0x1
	// Bit mask of ADPRC field.
	ADC140_ADCER_ADPRC_Msk = 0x6
	// A/D conversion is performed with 12-bit accuracy.
	ADC140_ADCER_ADPRC_00 = 0x0
	// A/D conversion is performed with 14-bit accuracy.
	ADC140_ADCER_ADPRC_11 = 0x3
	// Position of Reserved field.
	ADC140_ADCER_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	ADC140_ADCER_Reserved_Msk = 0x1
	// Bit Reserved.
	ADC140_ADCER_Reserved = 0x1

	// ADSTRGR: A/D Conversion Start Trigger Select Register
	// Position of Reserved field.
	ADC140_ADSTRGR_Reserved_Pos = 0xe
	// Bit mask of Reserved field.
	ADC140_ADSTRGR_Reserved_Msk = 0xc000
	// Position of TRSA field.
	ADC140_ADSTRGR_TRSA_Pos = 0x8
	// Bit mask of TRSA field.
	ADC140_ADSTRGR_TRSA_Msk = 0x3f00
	// Position of Reserved field.
	ADC140_ADSTRGR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ADC140_ADSTRGR_Reserved_Msk = 0xc0
	// Position of TRSB field.
	ADC140_ADSTRGR_TRSB_Pos = 0x0
	// Bit mask of TRSB field.
	ADC140_ADSTRGR_TRSB_Msk = 0x3f

	// ADEXICR: A/D Conversion Extended Input Control Register
	// Position of Reserved field.
	ADC140_ADEXICR_Reserved_Pos = 0xf
	// Bit mask of Reserved field.
	ADC140_ADEXICR_Reserved_Msk = 0x8000
	// Bit Reserved.
	ADC140_ADEXICR_Reserved = 0x8000
	// Position of Reserved field.
	ADC140_ADEXICR_Reserved_Pos = 0xe
	// Bit mask of Reserved field.
	ADC140_ADEXICR_Reserved_Msk = 0x4000
	// Bit Reserved.
	ADC140_ADEXICR_Reserved = 0x4000
	// Position of Reserved field.
	ADC140_ADEXICR_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	ADC140_ADEXICR_Reserved_Msk = 0x1000
	// Bit Reserved.
	ADC140_ADEXICR_Reserved = 0x1000
	// Position of Reserved field.
	ADC140_ADEXICR_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	ADC140_ADEXICR_Reserved_Msk = 0x800
	// Bit Reserved.
	ADC140_ADEXICR_Reserved = 0x800
	// Position of Reserved field.
	ADC140_ADEXICR_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	ADC140_ADEXICR_Reserved_Msk = 0x400
	// Bit Reserved.
	ADC140_ADEXICR_Reserved = 0x400
	// Position of OCSA field.
	ADC140_ADEXICR_OCSA_Pos = 0x9
	// Bit mask of OCSA field.
	ADC140_ADEXICR_OCSA_Msk = 0x200
	// Bit OCSA.
	ADC140_ADEXICR_OCSA = 0x200
	// The internal reference voltage is not selected.
	ADC140_ADEXICR_OCSA_0 = 0x0
	// The internal reference voltage is selected for group A in single scan mode, continuous scan mode, or group scan mode.
	ADC140_ADEXICR_OCSA_1 = 0x1
	// Position of TSSA field.
	ADC140_ADEXICR_TSSA_Pos = 0x8
	// Bit mask of TSSA field.
	ADC140_ADEXICR_TSSA_Msk = 0x100
	// Bit TSSA.
	ADC140_ADEXICR_TSSA = 0x100
	// The temperature sensor output is not selected.
	ADC140_ADEXICR_TSSA_0 = 0x0
	// The temperature sensor output is selected.
	ADC140_ADEXICR_TSSA_1 = 0x1
	// Position of Reserved field.
	ADC140_ADEXICR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC140_ADEXICR_Reserved_Msk = 0xfc
	// Position of OCSAD field.
	ADC140_ADEXICR_OCSAD_Pos = 0x1
	// Bit mask of OCSAD field.
	ADC140_ADEXICR_OCSAD_Msk = 0x2
	// Bit OCSAD.
	ADC140_ADEXICR_OCSAD = 0x2
	// Internal reference voltage A/D-converted value addition/average mode is not selected.
	ADC140_ADEXICR_OCSAD_0 = 0x0
	// Internal reference voltage A/D-converted value addition/average mode is selected.
	ADC140_ADEXICR_OCSAD_1 = 0x1
	// Position of TSSAD field.
	ADC140_ADEXICR_TSSAD_Pos = 0x0
	// Bit mask of TSSAD field.
	ADC140_ADEXICR_TSSAD_Msk = 0x1
	// Bit TSSAD.
	ADC140_ADEXICR_TSSAD = 0x1
	// Temperature sensor output A/D-converted value addition/average mode is not selected.
	ADC140_ADEXICR_TSSAD_0 = 0x0
	// Temperature sensor output A/D-converted value addition/average mode is selected.
	ADC140_ADEXICR_TSSAD_1 = 0x1

	// ADANSB0: A/D Channel Select Register B0
	// Position of ANSB15 field.
	ADC140_ADANSB0_ANSB15_Pos = 0xf
	// Bit mask of ANSB15 field.
	ADC140_ADANSB0_ANSB15_Msk = 0x8000
	// Bit ANSB15.
	ADC140_ADANSB0_ANSB15 = 0x8000
	// AN015 is not subjected to conversion.
	ADC140_ADANSB0_ANSB15_0 = 0x0
	// AN015 is subjected to conversion.
	ADC140_ADANSB0_ANSB15_1 = 0x1
	// Position of ANSB14 field.
	ADC140_ADANSB0_ANSB14_Pos = 0xe
	// Bit mask of ANSB14 field.
	ADC140_ADANSB0_ANSB14_Msk = 0x4000
	// Bit ANSB14.
	ADC140_ADANSB0_ANSB14 = 0x4000
	// AN014 is not subjected to conversion.
	ADC140_ADANSB0_ANSB14_0 = 0x0
	// AN014 is subjected to conversion.
	ADC140_ADANSB0_ANSB14_1 = 0x1
	// Position of ANSB13 field.
	ADC140_ADANSB0_ANSB13_Pos = 0xd
	// Bit mask of ANSB13 field.
	ADC140_ADANSB0_ANSB13_Msk = 0x2000
	// Bit ANSB13.
	ADC140_ADANSB0_ANSB13 = 0x2000
	// AN013 is not subjected to conversion.
	ADC140_ADANSB0_ANSB13_0 = 0x0
	// AN013 is subjected to conversion.
	ADC140_ADANSB0_ANSB13_1 = 0x1
	// Position of ANSB12 field.
	ADC140_ADANSB0_ANSB12_Pos = 0xc
	// Bit mask of ANSB12 field.
	ADC140_ADANSB0_ANSB12_Msk = 0x1000
	// Bit ANSB12.
	ADC140_ADANSB0_ANSB12 = 0x1000
	// AN012 is not subjected to conversion.
	ADC140_ADANSB0_ANSB12_0 = 0x0
	// AN012 is subjected to conversion.
	ADC140_ADANSB0_ANSB12_1 = 0x1
	// Position of ANSB11 field.
	ADC140_ADANSB0_ANSB11_Pos = 0xb
	// Bit mask of ANSB11 field.
	ADC140_ADANSB0_ANSB11_Msk = 0x800
	// Bit ANSB11.
	ADC140_ADANSB0_ANSB11 = 0x800
	// AN011 is not subjected to conversion.
	ADC140_ADANSB0_ANSB11_0 = 0x0
	// AN011 is subjected to conversion.
	ADC140_ADANSB0_ANSB11_1 = 0x1
	// Position of ANSB10 field.
	ADC140_ADANSB0_ANSB10_Pos = 0xa
	// Bit mask of ANSB10 field.
	ADC140_ADANSB0_ANSB10_Msk = 0x400
	// Bit ANSB10.
	ADC140_ADANSB0_ANSB10 = 0x400
	// AN010 is not subjected to conversion.
	ADC140_ADANSB0_ANSB10_0 = 0x0
	// AN010 is subjected to conversion.
	ADC140_ADANSB0_ANSB10_1 = 0x1
	// Position of ANSB09 field.
	ADC140_ADANSB0_ANSB09_Pos = 0x9
	// Bit mask of ANSB09 field.
	ADC140_ADANSB0_ANSB09_Msk = 0x200
	// Bit ANSB09.
	ADC140_ADANSB0_ANSB09 = 0x200
	// AN009 is not subjected to conversion.
	ADC140_ADANSB0_ANSB09_0 = 0x0
	// AN009 is subjected to conversion.
	ADC140_ADANSB0_ANSB09_1 = 0x1
	// Position of ANSB08 field.
	ADC140_ADANSB0_ANSB08_Pos = 0x8
	// Bit mask of ANSB08 field.
	ADC140_ADANSB0_ANSB08_Msk = 0x100
	// Bit ANSB08.
	ADC140_ADANSB0_ANSB08 = 0x100
	// AN008 is not subjected to conversion.
	ADC140_ADANSB0_ANSB08_0 = 0x0
	// AN008 is subjected to conversion.
	ADC140_ADANSB0_ANSB08_1 = 0x1
	// Position of ANSB07 field.
	ADC140_ADANSB0_ANSB07_Pos = 0x7
	// Bit mask of ANSB07 field.
	ADC140_ADANSB0_ANSB07_Msk = 0x80
	// Bit ANSB07.
	ADC140_ADANSB0_ANSB07 = 0x80
	// AN007 is not subjected to conversion.
	ADC140_ADANSB0_ANSB07_0 = 0x0
	// AN007 is subjected to conversion.
	ADC140_ADANSB0_ANSB07_1 = 0x1
	// Position of ANSB06 field.
	ADC140_ADANSB0_ANSB06_Pos = 0x6
	// Bit mask of ANSB06 field.
	ADC140_ADANSB0_ANSB06_Msk = 0x40
	// Bit ANSB06.
	ADC140_ADANSB0_ANSB06 = 0x40
	// AN006 is not subjected to conversion.
	ADC140_ADANSB0_ANSB06_0 = 0x0
	// AN006 is subjected to conversion.
	ADC140_ADANSB0_ANSB06_1 = 0x1
	// Position of ANSB05 field.
	ADC140_ADANSB0_ANSB05_Pos = 0x5
	// Bit mask of ANSB05 field.
	ADC140_ADANSB0_ANSB05_Msk = 0x20
	// Bit ANSB05.
	ADC140_ADANSB0_ANSB05 = 0x20
	// AN005 is not subjected to conversion.
	ADC140_ADANSB0_ANSB05_0 = 0x0
	// AN005 is subjected to conversion.
	ADC140_ADANSB0_ANSB05_1 = 0x1
	// Position of ANSB04 field.
	ADC140_ADANSB0_ANSB04_Pos = 0x4
	// Bit mask of ANSB04 field.
	ADC140_ADANSB0_ANSB04_Msk = 0x10
	// Bit ANSB04.
	ADC140_ADANSB0_ANSB04 = 0x10
	// AN004 is not subjected to conversion.
	ADC140_ADANSB0_ANSB04_0 = 0x0
	// AN004 is subjected to conversion.
	ADC140_ADANSB0_ANSB04_1 = 0x1
	// Position of ANSB03 field.
	ADC140_ADANSB0_ANSB03_Pos = 0x3
	// Bit mask of ANSB03 field.
	ADC140_ADANSB0_ANSB03_Msk = 0x8
	// Bit ANSB03.
	ADC140_ADANSB0_ANSB03 = 0x8
	// AN003 is not subjected to conversion.
	ADC140_ADANSB0_ANSB03_0 = 0x0
	// AN003 is subjected to conversion.
	ADC140_ADANSB0_ANSB03_1 = 0x1
	// Position of ANSB02 field.
	ADC140_ADANSB0_ANSB02_Pos = 0x2
	// Bit mask of ANSB02 field.
	ADC140_ADANSB0_ANSB02_Msk = 0x4
	// Bit ANSB02.
	ADC140_ADANSB0_ANSB02 = 0x4
	// AN002 is not subjected to conversion.
	ADC140_ADANSB0_ANSB02_0 = 0x0
	// AN002 is subjected to conversion.
	ADC140_ADANSB0_ANSB02_1 = 0x1
	// Position of ANSB01 field.
	ADC140_ADANSB0_ANSB01_Pos = 0x1
	// Bit mask of ANSB01 field.
	ADC140_ADANSB0_ANSB01_Msk = 0x2
	// Bit ANSB01.
	ADC140_ADANSB0_ANSB01 = 0x2
	// AN001 is not subjected to conversion.
	ADC140_ADANSB0_ANSB01_0 = 0x0
	// AN001 is subjected to conversion.
	ADC140_ADANSB0_ANSB01_1 = 0x1
	// Position of ANSB00 field.
	ADC140_ADANSB0_ANSB00_Pos = 0x0
	// Bit mask of ANSB00 field.
	ADC140_ADANSB0_ANSB00_Msk = 0x1
	// Bit ANSB00.
	ADC140_ADANSB0_ANSB00 = 0x1
	// AN000 is not subjected to conversion.
	ADC140_ADANSB0_ANSB00_0 = 0x0
	// AN000 is subjected to conversion.
	ADC140_ADANSB0_ANSB00_1 = 0x1

	// ADANSB1: A/D Channel Select Register B1
	// Position of Reserved field.
	ADC140_ADANSB1_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	ADC140_ADANSB1_Reserved_Msk = 0xf000
	// Position of ANSB27 field.
	ADC140_ADANSB1_ANSB27_Pos = 0xb
	// Bit mask of ANSB27 field.
	ADC140_ADANSB1_ANSB27_Msk = 0x800
	// Bit ANSB27.
	ADC140_ADANSB1_ANSB27 = 0x800
	// AN027 is not subjected to conversion.
	ADC140_ADANSB1_ANSB27_0 = 0x0
	// AN027 is subjected to conversion.
	ADC140_ADANSB1_ANSB27_1 = 0x1
	// Position of ANSB26 field.
	ADC140_ADANSB1_ANSB26_Pos = 0xa
	// Bit mask of ANSB26 field.
	ADC140_ADANSB1_ANSB26_Msk = 0x400
	// Bit ANSB26.
	ADC140_ADANSB1_ANSB26 = 0x400
	// AN026 is not subjected to conversion.
	ADC140_ADANSB1_ANSB26_0 = 0x0
	// AN026 is subjected to conversion.
	ADC140_ADANSB1_ANSB26_1 = 0x1
	// Position of ANSB25 field.
	ADC140_ADANSB1_ANSB25_Pos = 0x9
	// Bit mask of ANSB25 field.
	ADC140_ADANSB1_ANSB25_Msk = 0x200
	// Bit ANSB25.
	ADC140_ADANSB1_ANSB25 = 0x200
	// AN025 is not subjected to conversion.
	ADC140_ADANSB1_ANSB25_0 = 0x0
	// AN025 is subjected to conversion.
	ADC140_ADANSB1_ANSB25_1 = 0x1
	// Position of ANSB24 field.
	ADC140_ADANSB1_ANSB24_Pos = 0x8
	// Bit mask of ANSB24 field.
	ADC140_ADANSB1_ANSB24_Msk = 0x100
	// Bit ANSB24.
	ADC140_ADANSB1_ANSB24 = 0x100
	// AN024 is not subjected to conversion.
	ADC140_ADANSB1_ANSB24_0 = 0x0
	// AN024 is subjected to conversion.
	ADC140_ADANSB1_ANSB24_1 = 0x1
	// Position of ANSB23 field.
	ADC140_ADANSB1_ANSB23_Pos = 0x7
	// Bit mask of ANSB23 field.
	ADC140_ADANSB1_ANSB23_Msk = 0x80
	// Bit ANSB23.
	ADC140_ADANSB1_ANSB23 = 0x80
	// AN023 is not subjected to conversion.
	ADC140_ADANSB1_ANSB23_0 = 0x0
	// AN023 is subjected to conversion.
	ADC140_ADANSB1_ANSB23_1 = 0x1
	// Position of ANSB22 field.
	ADC140_ADANSB1_ANSB22_Pos = 0x6
	// Bit mask of ANSB22 field.
	ADC140_ADANSB1_ANSB22_Msk = 0x40
	// Bit ANSB22.
	ADC140_ADANSB1_ANSB22 = 0x40
	// AN022 is not subjected to conversion.
	ADC140_ADANSB1_ANSB22_0 = 0x0
	// AN022 is subjected to conversion.
	ADC140_ADANSB1_ANSB22_1 = 0x1
	// Position of ANSB21 field.
	ADC140_ADANSB1_ANSB21_Pos = 0x5
	// Bit mask of ANSB21 field.
	ADC140_ADANSB1_ANSB21_Msk = 0x20
	// Bit ANSB21.
	ADC140_ADANSB1_ANSB21 = 0x20
	// AN021 is not subjected to conversion.
	ADC140_ADANSB1_ANSB21_0 = 0x0
	// AN021 is subjected to conversion.
	ADC140_ADANSB1_ANSB21_1 = 0x1
	// Position of ANSB20 field.
	ADC140_ADANSB1_ANSB20_Pos = 0x4
	// Bit mask of ANSB20 field.
	ADC140_ADANSB1_ANSB20_Msk = 0x10
	// Bit ANSB20.
	ADC140_ADANSB1_ANSB20 = 0x10
	// AN020 is not subjected to conversion.
	ADC140_ADANSB1_ANSB20_0 = 0x0
	// AN020 is subjected to conversion.
	ADC140_ADANSB1_ANSB20_1 = 0x1
	// Position of ANSB19 field.
	ADC140_ADANSB1_ANSB19_Pos = 0x3
	// Bit mask of ANSB19 field.
	ADC140_ADANSB1_ANSB19_Msk = 0x8
	// Bit ANSB19.
	ADC140_ADANSB1_ANSB19 = 0x8
	// AN019 is not subjected to conversion.
	ADC140_ADANSB1_ANSB19_0 = 0x0
	// AN019 is subjected to conversion.
	ADC140_ADANSB1_ANSB19_1 = 0x1
	// Position of ANSB18 field.
	ADC140_ADANSB1_ANSB18_Pos = 0x2
	// Bit mask of ANSB18 field.
	ADC140_ADANSB1_ANSB18_Msk = 0x4
	// Bit ANSB18.
	ADC140_ADANSB1_ANSB18 = 0x4
	// AN018 is not subjected to conversion.
	ADC140_ADANSB1_ANSB18_0 = 0x0
	// AN018 is subjected to conversion.
	ADC140_ADANSB1_ANSB18_1 = 0x1
	// Position of ANSB17 field.
	ADC140_ADANSB1_ANSB17_Pos = 0x1
	// Bit mask of ANSB17 field.
	ADC140_ADANSB1_ANSB17_Msk = 0x2
	// Bit ANSB17.
	ADC140_ADANSB1_ANSB17 = 0x2
	// AN017 is not subjected to conversion.
	ADC140_ADANSB1_ANSB17_0 = 0x0
	// AN017 is subjected to conversion.
	ADC140_ADANSB1_ANSB17_1 = 0x1
	// Position of ANSB16 field.
	ADC140_ADANSB1_ANSB16_Pos = 0x0
	// Bit mask of ANSB16 field.
	ADC140_ADANSB1_ANSB16_Msk = 0x1
	// Bit ANSB16.
	ADC140_ADANSB1_ANSB16 = 0x1
	// AN016 is not subjected to conversion.
	ADC140_ADANSB1_ANSB16_0 = 0x0
	// AN016 is subjected to conversion.
	ADC140_ADANSB1_ANSB16_1 = 0x1

	// ADDBLDR: A/D Data Duplication Register
	// Position of ADDBLDR field.
	ADC140_ADDBLDR_ADDBLDR_Pos = 0x0
	// Bit mask of ADDBLDR field.
	ADC140_ADDBLDR_ADDBLDR_Msk = 0xffff

	// ADTSDR: A/D Temperature Sensor Data Register
	// Position of ADTSDR field.
	ADC140_ADTSDR_ADTSDR_Pos = 0x0
	// Bit mask of ADTSDR field.
	ADC140_ADTSDR_ADTSDR_Msk = 0xffff

	// ADOCDR: A/D Internal Reference Voltage Data Register
	// Position of ADOCDR field.
	ADC140_ADOCDR_ADOCDR_Pos = 0x0
	// Bit mask of ADOCDR field.
	ADC140_ADOCDR_ADOCDR_Msk = 0xffff

	// ADRD: A/D Self-Diagnosis Data Register
	// Position of DIAGST field.
	ADC140_ADRD_DIAGST_Pos = 0xe
	// Bit mask of DIAGST field.
	ADC140_ADRD_DIAGST_Msk = 0xc000
	// Self-diagnosis has never been executed since power-on.
	ADC140_ADRD_DIAGST_00 = 0x0
	// Self-diagnosis using the voltage of 0 V has been executed.
	ADC140_ADRD_DIAGST_01 = 0x1
	// Self-diagnosis using the voltage of reference power supply(VREFH) x 1/2 has been executed.
	ADC140_ADRD_DIAGST_10 = 0x2
	// Self-diagnosis using the voltage of reference power supply(VREFH) has been executed.
	ADC140_ADRD_DIAGST_11 = 0x3
	// Position of AD field.
	ADC140_ADRD_AD_Pos = 0x0
	// Bit mask of AD field.
	ADC140_ADRD_AD_Msk = 0x3fff

	// ADDR0: A/D Data Register %s
	// Position of ADDR field.
	ADC140_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ADC140_ADDR_ADDR_Msk = 0xffff

	// ADDISCR: A/D Disconnection Detection Control Register
	// Position of Reserved field.
	ADC140_ADDISCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	ADC140_ADDISCR_Reserved_Msk = 0xe0
	// Position of ADNDIS field.
	ADC140_ADDISCR_ADNDIS_Pos = 0x0
	// Bit mask of ADNDIS field.
	ADC140_ADDISCR_ADNDIS_Msk = 0x1f
	// Disconnection detection is disabled
	ADC140_ADDISCR_ADNDIS_0000 = 0x0
	// Setting prohibited
	ADC140_ADDISCR_ADNDIS_0001 = 0x1

	// ADGSPCR: A/D Group Scan Priority Control Register
	// Position of GBRP field.
	ADC140_ADGSPCR_GBRP_Pos = 0xf
	// Bit mask of GBRP field.
	ADC140_ADGSPCR_GBRP_Msk = 0x8000
	// Bit GBRP.
	ADC140_ADGSPCR_GBRP = 0x8000
	// Single scan for group B is not continuously activated.
	ADC140_ADGSPCR_GBRP_0 = 0x0
	// Single scan for group B is continuously activated.
	ADC140_ADGSPCR_GBRP_1 = 0x1
	// Position of Reserved field.
	ADC140_ADGSPCR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	ADC140_ADGSPCR_Reserved_Msk = 0x7e00
	// Position of Reserved field.
	ADC140_ADGSPCR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ADC140_ADGSPCR_Reserved_Msk = 0x100
	// Bit Reserved.
	ADC140_ADGSPCR_Reserved = 0x100
	// Position of Reserved field.
	ADC140_ADGSPCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC140_ADGSPCR_Reserved_Msk = 0xfc
	// Position of GBRSCN field.
	ADC140_ADGSPCR_GBRSCN_Pos = 0x1
	// Bit mask of GBRSCN field.
	ADC140_ADGSPCR_GBRSCN_Msk = 0x2
	// Bit GBRSCN.
	ADC140_ADGSPCR_GBRSCN = 0x2
	// Scanning for group B is not restarted after having been discontinued due to group A priority control.
	ADC140_ADGSPCR_GBRSCN_0 = 0x0
	// Scanning for group B is restarted after having been discontinued due to group A priority control.
	ADC140_ADGSPCR_GBRSCN_1 = 0x1
	// Position of PGS field.
	ADC140_ADGSPCR_PGS_Pos = 0x0
	// Bit mask of PGS field.
	ADC140_ADGSPCR_PGS_Msk = 0x1
	// Bit PGS.
	ADC140_ADGSPCR_PGS = 0x1
	// Operation is without group A priority control
	ADC140_ADGSPCR_PGS_0 = 0x0
	// Operation is with group A priority control
	ADC140_ADGSPCR_PGS_1 = 0x1

	// ADDBLDRA: A/D Data Duplexing Register A
	// Position of ADDBLDRA field.
	ADC140_ADDBLDRA_ADDBLDRA_Pos = 0x0
	// Bit mask of ADDBLDRA field.
	ADC140_ADDBLDRA_ADDBLDRA_Msk = 0xffff

	// ADDBLDRB: A/D Data Duplexing Register B
	// Position of ADDBLDRB field.
	ADC140_ADDBLDRB_ADDBLDRB_Pos = 0x0
	// Bit mask of ADDBLDRB field.
	ADC140_ADDBLDRB_ADDBLDRB_Msk = 0xffff

	// ADHVREFCNT: A/D High-Potential/Low-Potential Reference Voltage Control Register
	// Position of ADSLP field.
	ADC140_ADHVREFCNT_ADSLP_Pos = 0x7
	// Bit mask of ADSLP field.
	ADC140_ADHVREFCNT_ADSLP_Msk = 0x80
	// Bit ADSLP.
	ADC140_ADHVREFCNT_ADSLP = 0x80
	// Normal operation
	ADC140_ADHVREFCNT_ADSLP_0 = 0x0
	// Standby state.
	ADC140_ADHVREFCNT_ADSLP_1 = 0x1
	// Position of Reserved field.
	ADC140_ADHVREFCNT_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	ADC140_ADHVREFCNT_Reserved_Msk = 0x60
	// Position of LVSEL field.
	ADC140_ADHVREFCNT_LVSEL_Pos = 0x2
	// Bit mask of LVSEL field.
	ADC140_ADHVREFCNT_LVSEL_Msk = 0x1c
	// AVSS0 is selected as the low-potential reference voltage
	ADC140_ADHVREFCNT_LVSEL_0 = 0x0
	// VREFL0 is selected as the low-potential reference voltage.
	ADC140_ADHVREFCNT_LVSEL_1 = 0x1
	// Position of Reserved field.
	ADC140_ADHVREFCNT_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC140_ADHVREFCNT_Reserved_Msk = 0xc
	// Position of CMPAB field.
	ADC140_ADHVREFCNT_CMPAB_Pos = 0x0
	// Bit mask of CMPAB field.
	ADC140_ADHVREFCNT_CMPAB_Msk = 0x3
	// AVCC0 is selected as the high-potential reference voltage
	ADC140_ADHVREFCNT_CMPAB_00 = 0x0
	// VREFH0 is selected as the high-potential reference voltage
	ADC140_ADHVREFCNT_CMPAB_01 = 0x1
	// Internal reference voltage is selected as the high-potential reference voltage
	ADC140_ADHVREFCNT_CMPAB_10 = 0x2
	// Internal node discharge. No reference voltage pin is selected.
	ADC140_ADHVREFCNT_CMPAB_11 = 0x3

	// ADWINMON: A/D Compare Function Window A/B Status Monitor Register
	// Position of Reserved field.
	ADC140_ADWINMON_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ADC140_ADWINMON_Reserved_Msk = 0xc0
	// Position of MONCMPB field.
	ADC140_ADWINMON_MONCMPB_Pos = 0x5
	// Bit mask of MONCMPB field.
	ADC140_ADWINMON_MONCMPB_Msk = 0x20
	// Bit MONCMPB.
	ADC140_ADWINMON_MONCMPB = 0x20
	// Window B comparison conditions are not met.
	ADC140_ADWINMON_MONCMPB_0 = 0x0
	// Window B comparison conditions are met.
	ADC140_ADWINMON_MONCMPB_1 = 0x1
	// Position of MONCMPA field.
	ADC140_ADWINMON_MONCMPA_Pos = 0x4
	// Bit mask of MONCMPA field.
	ADC140_ADWINMON_MONCMPA_Msk = 0x10
	// Bit MONCMPA.
	ADC140_ADWINMON_MONCMPA = 0x10
	// Window A comparison conditions are not met.
	ADC140_ADWINMON_MONCMPA_0 = 0x0
	// Window A comparison conditions are met.
	ADC140_ADWINMON_MONCMPA_1 = 0x1
	// Position of Reserved field.
	ADC140_ADWINMON_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	ADC140_ADWINMON_Reserved_Msk = 0xe
	// Position of MONCOMB field.
	ADC140_ADWINMON_MONCOMB_Pos = 0x0
	// Bit mask of MONCOMB field.
	ADC140_ADWINMON_MONCOMB_Msk = 0x1
	// Bit MONCOMB.
	ADC140_ADWINMON_MONCOMB = 0x1
	// Window A / window B composite conditions are not met.
	ADC140_ADWINMON_MONCOMB_0 = 0x0
	// Window A / window B composite conditions are met.
	ADC140_ADWINMON_MONCOMB_1 = 0x1

	// ADCMPCR: A/D Compare Function Control Register
	// Position of CMPAIE field.
	ADC140_ADCMPCR_CMPAIE_Pos = 0xf
	// Bit mask of CMPAIE field.
	ADC140_ADCMPCR_CMPAIE_Msk = 0x8000
	// Bit CMPAIE.
	ADC140_ADCMPCR_CMPAIE = 0x8000
	// ADC140_CMPAI interrupt is disabled when comparison conditions (window A) are met.
	ADC140_ADCMPCR_CMPAIE_0 = 0x0
	// ADC140_CMPAI interrupt is enabled when comparison conditions (window A) are met.
	ADC140_ADCMPCR_CMPAIE_1 = 0x1
	// Position of WCMPE field.
	ADC140_ADCMPCR_WCMPE_Pos = 0xe
	// Bit mask of WCMPE field.
	ADC140_ADCMPCR_WCMPE_Msk = 0x4000
	// Bit WCMPE.
	ADC140_ADCMPCR_WCMPE = 0x4000
	// Window function is disabled. Window A and window B operate as a comparator to comparator the single value on the lower side with the A/D conversion result.
	ADC140_ADCMPCR_WCMPE_0 = 0x0
	// Window function is enabled. Window A and window B operate as a comparator to comparator the two values on the upper and lower sides with the A/D conversion result.
	ADC140_ADCMPCR_WCMPE_1 = 0x1
	// Position of CMPBIE field.
	ADC140_ADCMPCR_CMPBIE_Pos = 0xd
	// Bit mask of CMPBIE field.
	ADC140_ADCMPCR_CMPBIE_Msk = 0x2000
	// Bit CMPBIE.
	ADC140_ADCMPCR_CMPBIE = 0x2000
	// ADC140_CMPAI interrupt is disabled when comparison conditions (window B) are met.
	ADC140_ADCMPCR_CMPBIE_0 = 0x0
	// ADC140_CMPAI interrupt is enabled when comparison conditions (window B) are met.
	ADC140_ADCMPCR_CMPBIE_1 = 0x1
	// Position of Reserved field.
	ADC140_ADCMPCR_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	ADC140_ADCMPCR_Reserved_Msk = 0x1000
	// Bit Reserved.
	ADC140_ADCMPCR_Reserved = 0x1000
	// Position of CMPAE field.
	ADC140_ADCMPCR_CMPAE_Pos = 0xb
	// Bit mask of CMPAE field.
	ADC140_ADCMPCR_CMPAE_Msk = 0x800
	// Bit CMPAE.
	ADC140_ADCMPCR_CMPAE = 0x800
	// Compare window A operation is disabled. ADC140_WCMPM and ADC140_WCMPUM outputs are disabled.
	ADC140_ADCMPCR_CMPAE_0 = 0x0
	// Compare window A operation is enabled.
	ADC140_ADCMPCR_CMPAE_1 = 0x1
	// Position of Reserved field.
	ADC140_ADCMPCR_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	ADC140_ADCMPCR_Reserved_Msk = 0x400
	// Bit Reserved.
	ADC140_ADCMPCR_Reserved = 0x400
	// Position of CMPBE field.
	ADC140_ADCMPCR_CMPBE_Pos = 0x9
	// Bit mask of CMPBE field.
	ADC140_ADCMPCR_CMPBE_Msk = 0x200
	// Bit CMPBE.
	ADC140_ADCMPCR_CMPBE = 0x200
	// Compare window B operation is disabled. ADC140_WCMPM and ADC140_WCMPUM outputs are disabled.
	ADC140_ADCMPCR_CMPBE_0 = 0x0
	// Compare window B operation is enabled.
	ADC140_ADCMPCR_CMPBE_1 = 0x1
	// Position of Reserved field.
	ADC140_ADCMPCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC140_ADCMPCR_Reserved_Msk = 0x1fc
	// Position of CMPAB field.
	ADC140_ADCMPCR_CMPAB_Pos = 0x0
	// Bit mask of CMPAB field.
	ADC140_ADCMPCR_CMPAB_Msk = 0x3
	// ADC140_WCMPM is output when window A comparison conditions are met OR window B comparison conditions are met. ADC140_WCMPUM is output in other cases.
	ADC140_ADCMPCR_CMPAB_00 = 0x0
	// S14ADWMELC0 is output when window A comparison conditions are met EXOR window B comparison conditions are met. ADC140_WCMPUM is output in other cases.
	ADC140_ADCMPCR_CMPAB_01 = 0x1
	// ADC140_WCMPM is output when window A comparison conditions are met and window B comparison conditions are met. ADC140_WCMPUM is output in other cases.
	ADC140_ADCMPCR_CMPAB_10 = 0x2
	// Setting prohibited.
	ADC140_ADCMPCR_CMPAB_11 = 0x3

	// ADCMPANSER: A/D Compare Function Window A Extended Input Select Register
	// Position of Reserved field.
	ADC140_ADCMPANSER_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC140_ADCMPANSER_Reserved_Msk = 0xfc
	// Position of CMPOCA field.
	ADC140_ADCMPANSER_CMPOCA_Pos = 0x1
	// Bit mask of CMPOCA field.
	ADC140_ADCMPANSER_CMPOCA_Msk = 0x2
	// Bit CMPOCA.
	ADC140_ADCMPANSER_CMPOCA = 0x2
	// Excludes the internal reference voltage from the compare window A target range.
	ADC140_ADCMPANSER_CMPOCA_0 = 0x0
	// Includes the internal reference voltage in the compare window A target range.
	ADC140_ADCMPANSER_CMPOCA_1 = 0x1
	// Position of CMPTSA field.
	ADC140_ADCMPANSER_CMPTSA_Pos = 0x0
	// Bit mask of CMPTSA field.
	ADC140_ADCMPANSER_CMPTSA_Msk = 0x1
	// Bit CMPTSA.
	ADC140_ADCMPANSER_CMPTSA = 0x1
	// Excludes the temperature sensor output from the compare window A target range.
	ADC140_ADCMPANSER_CMPTSA_0 = 0x0
	// Includes the temperature sensor output in the compare window A target range.
	ADC140_ADCMPANSER_CMPTSA_1 = 0x1

	// ADCMPLER: A/D Compare Function Window A Extended Input Comparison Condition Setting Register
	// Position of Reserved field.
	ADC140_ADCMPLER_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC140_ADCMPLER_Reserved_Msk = 0xfc
	// Position of CMPLOCA field.
	ADC140_ADCMPLER_CMPLOCA_Pos = 0x1
	// Bit mask of CMPLOCA field.
	ADC140_ADCMPLER_CMPLOCA_Msk = 0x2
	// Bit CMPLOCA.
	ADC140_ADCMPLER_CMPLOCA = 0x2
	// ADCMPDR0 value > A/D converted value(ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or A/D converted value > ADCMPDR1 value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLER_CMPLOCA_0 = 0x0
	// ADCMPDR0 value < A/D converted value(ADCMPCR.WCMPE=0) / ADCMPDR0 value < A/D converted value < ADCMPDR1 value(ADCMPCR.WCMPE=1)
	ADC140_ADCMPLER_CMPLOCA_1 = 0x1
	// Position of CMPLTSA field.
	ADC140_ADCMPLER_CMPLTSA_Pos = 0x0
	// Bit mask of CMPLTSA field.
	ADC140_ADCMPLER_CMPLTSA_Msk = 0x1
	// Bit CMPLTSA.
	ADC140_ADCMPLER_CMPLTSA = 0x1
	// ADCMPDR0 register value > A/D-converted value(ADCMPCR.WCMPE=0) / AD-converted value < ADCMPDR0 register value or A/D-converted value > ADCMPDR1 register value(ADCMPCR.WCMPE=1).
	ADC140_ADCMPLER_CMPLTSA_0 = 0x0
	// ADCMPDR0 register value < A/D-converted value(ADCMPCR.WCMPE=0) / ADCMPDR0 register value < A/D-converted value < ADCMPDR1 register value(ADCMPCR.WCMPE=1).
	ADC140_ADCMPLER_CMPLTSA_1 = 0x1

	// ADCMPANSR0: A/D Compare Function Window A Channel Select Register 0
	// Position of CMPCHA15 field.
	ADC140_ADCMPANSR0_CMPCHA15_Pos = 0xf
	// Bit mask of CMPCHA15 field.
	ADC140_ADCMPANSR0_CMPCHA15_Msk = 0x8000
	// Bit CMPCHA15.
	ADC140_ADCMPANSR0_CMPCHA15 = 0x8000
	// Excludes AN015 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA15_0 = 0x0
	// Includes AN015 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA15_1 = 0x1
	// Position of CMPCHA14 field.
	ADC140_ADCMPANSR0_CMPCHA14_Pos = 0xe
	// Bit mask of CMPCHA14 field.
	ADC140_ADCMPANSR0_CMPCHA14_Msk = 0x4000
	// Bit CMPCHA14.
	ADC140_ADCMPANSR0_CMPCHA14 = 0x4000
	// Excludes AN014 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA14_0 = 0x0
	// Includes AN014 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA14_1 = 0x1
	// Position of CMPCHA13 field.
	ADC140_ADCMPANSR0_CMPCHA13_Pos = 0xd
	// Bit mask of CMPCHA13 field.
	ADC140_ADCMPANSR0_CMPCHA13_Msk = 0x2000
	// Bit CMPCHA13.
	ADC140_ADCMPANSR0_CMPCHA13 = 0x2000
	// Excludes AN013 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA13_0 = 0x0
	// Includes AN013 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA13_1 = 0x1
	// Position of CMPCHA12 field.
	ADC140_ADCMPANSR0_CMPCHA12_Pos = 0xc
	// Bit mask of CMPCHA12 field.
	ADC140_ADCMPANSR0_CMPCHA12_Msk = 0x1000
	// Bit CMPCHA12.
	ADC140_ADCMPANSR0_CMPCHA12 = 0x1000
	// Excludes AN012 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA12_0 = 0x0
	// Includes AN012 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA12_1 = 0x1
	// Position of CMPCHA11 field.
	ADC140_ADCMPANSR0_CMPCHA11_Pos = 0xb
	// Bit mask of CMPCHA11 field.
	ADC140_ADCMPANSR0_CMPCHA11_Msk = 0x800
	// Bit CMPCHA11.
	ADC140_ADCMPANSR0_CMPCHA11 = 0x800
	// Excludes AN011 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA11_0 = 0x0
	// Includes AN011 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA11_1 = 0x1
	// Position of CMPCHA10 field.
	ADC140_ADCMPANSR0_CMPCHA10_Pos = 0xa
	// Bit mask of CMPCHA10 field.
	ADC140_ADCMPANSR0_CMPCHA10_Msk = 0x400
	// Bit CMPCHA10.
	ADC140_ADCMPANSR0_CMPCHA10 = 0x400
	// Excludes AN010 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA10_0 = 0x0
	// Includes AN010 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA10_1 = 0x1
	// Position of CMPCHA09 field.
	ADC140_ADCMPANSR0_CMPCHA09_Pos = 0x9
	// Bit mask of CMPCHA09 field.
	ADC140_ADCMPANSR0_CMPCHA09_Msk = 0x200
	// Bit CMPCHA09.
	ADC140_ADCMPANSR0_CMPCHA09 = 0x200
	// Excludes AN009 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA09_0 = 0x0
	// Includes AN009 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA09_1 = 0x1
	// Position of CMPCHA08 field.
	ADC140_ADCMPANSR0_CMPCHA08_Pos = 0x8
	// Bit mask of CMPCHA08 field.
	ADC140_ADCMPANSR0_CMPCHA08_Msk = 0x100
	// Bit CMPCHA08.
	ADC140_ADCMPANSR0_CMPCHA08 = 0x100
	// Excludes AN008 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA08_0 = 0x0
	// Includes AN008 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA08_1 = 0x1
	// Position of CMPCHA07 field.
	ADC140_ADCMPANSR0_CMPCHA07_Pos = 0x7
	// Bit mask of CMPCHA07 field.
	ADC140_ADCMPANSR0_CMPCHA07_Msk = 0x80
	// Bit CMPCHA07.
	ADC140_ADCMPANSR0_CMPCHA07 = 0x80
	// Excludes AN007 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA07_0 = 0x0
	// Includes AN007 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA07_1 = 0x1
	// Position of CMPCHA06 field.
	ADC140_ADCMPANSR0_CMPCHA06_Pos = 0x6
	// Bit mask of CMPCHA06 field.
	ADC140_ADCMPANSR0_CMPCHA06_Msk = 0x40
	// Bit CMPCHA06.
	ADC140_ADCMPANSR0_CMPCHA06 = 0x40
	// Excludes AN006 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA06_0 = 0x0
	// Includes AN006 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA06_1 = 0x1
	// Position of CMPCHA05 field.
	ADC140_ADCMPANSR0_CMPCHA05_Pos = 0x5
	// Bit mask of CMPCHA05 field.
	ADC140_ADCMPANSR0_CMPCHA05_Msk = 0x20
	// Bit CMPCHA05.
	ADC140_ADCMPANSR0_CMPCHA05 = 0x20
	// Excludes AN005 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA05_0 = 0x0
	// Includes AN005 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA05_1 = 0x1
	// Position of CMPCHA04 field.
	ADC140_ADCMPANSR0_CMPCHA04_Pos = 0x4
	// Bit mask of CMPCHA04 field.
	ADC140_ADCMPANSR0_CMPCHA04_Msk = 0x10
	// Bit CMPCHA04.
	ADC140_ADCMPANSR0_CMPCHA04 = 0x10
	// Excludes AN004 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA04_0 = 0x0
	// Includes AN004 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA04_1 = 0x1
	// Position of CMPCHA03 field.
	ADC140_ADCMPANSR0_CMPCHA03_Pos = 0x3
	// Bit mask of CMPCHA03 field.
	ADC140_ADCMPANSR0_CMPCHA03_Msk = 0x8
	// Bit CMPCHA03.
	ADC140_ADCMPANSR0_CMPCHA03 = 0x8
	// Excludes AN003 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA03_0 = 0x0
	// Includes AN003 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA03_1 = 0x1
	// Position of CMPCHA02 field.
	ADC140_ADCMPANSR0_CMPCHA02_Pos = 0x2
	// Bit mask of CMPCHA02 field.
	ADC140_ADCMPANSR0_CMPCHA02_Msk = 0x4
	// Bit CMPCHA02.
	ADC140_ADCMPANSR0_CMPCHA02 = 0x4
	// Excludes AN002 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA02_0 = 0x0
	// Includes AN002 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA02_1 = 0x1
	// Position of CMPCHA01 field.
	ADC140_ADCMPANSR0_CMPCHA01_Pos = 0x1
	// Bit mask of CMPCHA01 field.
	ADC140_ADCMPANSR0_CMPCHA01_Msk = 0x2
	// Bit CMPCHA01.
	ADC140_ADCMPANSR0_CMPCHA01 = 0x2
	// Excludes AN001 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA01_0 = 0x0
	// Includes AN001 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA01_1 = 0x1
	// Position of CMPCHA00 field.
	ADC140_ADCMPANSR0_CMPCHA00_Pos = 0x0
	// Bit mask of CMPCHA00 field.
	ADC140_ADCMPANSR0_CMPCHA00_Msk = 0x1
	// Bit CMPCHA00.
	ADC140_ADCMPANSR0_CMPCHA00 = 0x1
	// Excludes AN000 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA00_0 = 0x0
	// Includes AN000 from the compare window A target range.
	ADC140_ADCMPANSR0_CMPCHA00_1 = 0x1

	// ADCMPANSR1: A/D Compare Function Window A Channel Select Register 1
	// Position of Reserved field.
	ADC140_ADCMPANSR1_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	ADC140_ADCMPANSR1_Reserved_Msk = 0xf000
	// Position of CMPCHA27 field.
	ADC140_ADCMPANSR1_CMPCHA27_Pos = 0xb
	// Bit mask of CMPCHA27 field.
	ADC140_ADCMPANSR1_CMPCHA27_Msk = 0x800
	// Bit CMPCHA27.
	ADC140_ADCMPANSR1_CMPCHA27 = 0x800
	// Excludes AN027 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA27_0 = 0x0
	// Includes AN027 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA27_1 = 0x1
	// Position of CMPCHA26 field.
	ADC140_ADCMPANSR1_CMPCHA26_Pos = 0xa
	// Bit mask of CMPCHA26 field.
	ADC140_ADCMPANSR1_CMPCHA26_Msk = 0x400
	// Bit CMPCHA26.
	ADC140_ADCMPANSR1_CMPCHA26 = 0x400
	// Excludes AN026 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA26_0 = 0x0
	// Includes AN026 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA26_1 = 0x1
	// Position of CMPCHA25 field.
	ADC140_ADCMPANSR1_CMPCHA25_Pos = 0x9
	// Bit mask of CMPCHA25 field.
	ADC140_ADCMPANSR1_CMPCHA25_Msk = 0x200
	// Bit CMPCHA25.
	ADC140_ADCMPANSR1_CMPCHA25 = 0x200
	// Excludes AN025 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA25_0 = 0x0
	// Includes AN025 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA25_1 = 0x1
	// Position of CMPCHA24 field.
	ADC140_ADCMPANSR1_CMPCHA24_Pos = 0x8
	// Bit mask of CMPCHA24 field.
	ADC140_ADCMPANSR1_CMPCHA24_Msk = 0x100
	// Bit CMPCHA24.
	ADC140_ADCMPANSR1_CMPCHA24 = 0x100
	// Excludes AN024 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA24_0 = 0x0
	// Includes AN024 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA24_1 = 0x1
	// Position of CMPCHA23 field.
	ADC140_ADCMPANSR1_CMPCHA23_Pos = 0x7
	// Bit mask of CMPCHA23 field.
	ADC140_ADCMPANSR1_CMPCHA23_Msk = 0x80
	// Bit CMPCHA23.
	ADC140_ADCMPANSR1_CMPCHA23 = 0x80
	// Excludes AN023 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA23_0 = 0x0
	// Includes AN023 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA23_1 = 0x1
	// Position of CMPCHA22 field.
	ADC140_ADCMPANSR1_CMPCHA22_Pos = 0x6
	// Bit mask of CMPCHA22 field.
	ADC140_ADCMPANSR1_CMPCHA22_Msk = 0x40
	// Bit CMPCHA22.
	ADC140_ADCMPANSR1_CMPCHA22 = 0x40
	// Excludes AN022 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA22_0 = 0x0
	// Includes AN022 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA22_1 = 0x1
	// Position of CMPCHA21 field.
	ADC140_ADCMPANSR1_CMPCHA21_Pos = 0x5
	// Bit mask of CMPCHA21 field.
	ADC140_ADCMPANSR1_CMPCHA21_Msk = 0x20
	// Bit CMPCHA21.
	ADC140_ADCMPANSR1_CMPCHA21 = 0x20
	// Excludes AN021 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA21_0 = 0x0
	// Includes AN021 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA21_1 = 0x1
	// Position of CMPCHA20 field.
	ADC140_ADCMPANSR1_CMPCHA20_Pos = 0x4
	// Bit mask of CMPCHA20 field.
	ADC140_ADCMPANSR1_CMPCHA20_Msk = 0x10
	// Bit CMPCHA20.
	ADC140_ADCMPANSR1_CMPCHA20 = 0x10
	// Excludes AN020 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA20_0 = 0x0
	// Includes AN020 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA20_1 = 0x1
	// Position of CMPCHA19 field.
	ADC140_ADCMPANSR1_CMPCHA19_Pos = 0x3
	// Bit mask of CMPCHA19 field.
	ADC140_ADCMPANSR1_CMPCHA19_Msk = 0x8
	// Bit CMPCHA19.
	ADC140_ADCMPANSR1_CMPCHA19 = 0x8
	// Excludes AN019 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA19_0 = 0x0
	// Includes AN019 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA19_1 = 0x1
	// Position of CMPCHA18 field.
	ADC140_ADCMPANSR1_CMPCHA18_Pos = 0x2
	// Bit mask of CMPCHA18 field.
	ADC140_ADCMPANSR1_CMPCHA18_Msk = 0x4
	// Bit CMPCHA18.
	ADC140_ADCMPANSR1_CMPCHA18 = 0x4
	// Excludes AN018 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA18_0 = 0x0
	// Includes AN018 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA18_1 = 0x1
	// Position of CMPCHA17 field.
	ADC140_ADCMPANSR1_CMPCHA17_Pos = 0x1
	// Bit mask of CMPCHA17 field.
	ADC140_ADCMPANSR1_CMPCHA17_Msk = 0x2
	// Bit CMPCHA17.
	ADC140_ADCMPANSR1_CMPCHA17 = 0x2
	// Excludes AN017 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA17_0 = 0x0
	// Includes AN017 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA17_1 = 0x1
	// Position of CMPCHA16 field.
	ADC140_ADCMPANSR1_CMPCHA16_Pos = 0x0
	// Bit mask of CMPCHA16 field.
	ADC140_ADCMPANSR1_CMPCHA16_Msk = 0x1
	// Bit CMPCHA16.
	ADC140_ADCMPANSR1_CMPCHA16 = 0x1
	// Excludes AN016 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA16_0 = 0x0
	// Includes AN016 from the compare window A target range.
	ADC140_ADCMPANSR1_CMPCHA16_1 = 0x1

	// ADCMPLR0: A/D Compare Function Window A Comparison Condition Setting Register 0
	// Position of CMPLCHA15 field.
	ADC140_ADCMPLR0_CMPLCHA15_Pos = 0xf
	// Bit mask of CMPLCHA15 field.
	ADC140_ADCMPLR0_CMPLCHA15_Msk = 0x8000
	// Bit CMPLCHA15.
	ADC140_ADCMPLR0_CMPLCHA15 = 0x8000
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA15_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA15_1 = 0x1
	// Position of CMPLCHA14 field.
	ADC140_ADCMPLR0_CMPLCHA14_Pos = 0xe
	// Bit mask of CMPLCHA14 field.
	ADC140_ADCMPLR0_CMPLCHA14_Msk = 0x4000
	// Bit CMPLCHA14.
	ADC140_ADCMPLR0_CMPLCHA14 = 0x4000
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA14_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA14_1 = 0x1
	// Position of CMPLCHA13 field.
	ADC140_ADCMPLR0_CMPLCHA13_Pos = 0xd
	// Bit mask of CMPLCHA13 field.
	ADC140_ADCMPLR0_CMPLCHA13_Msk = 0x2000
	// Bit CMPLCHA13.
	ADC140_ADCMPLR0_CMPLCHA13 = 0x2000
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA13_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA13_1 = 0x1
	// Position of CMPLCHA12 field.
	ADC140_ADCMPLR0_CMPLCHA12_Pos = 0xc
	// Bit mask of CMPLCHA12 field.
	ADC140_ADCMPLR0_CMPLCHA12_Msk = 0x1000
	// Bit CMPLCHA12.
	ADC140_ADCMPLR0_CMPLCHA12 = 0x1000
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA12_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA12_1 = 0x1
	// Position of CMPLCHA11 field.
	ADC140_ADCMPLR0_CMPLCHA11_Pos = 0xb
	// Bit mask of CMPLCHA11 field.
	ADC140_ADCMPLR0_CMPLCHA11_Msk = 0x800
	// Bit CMPLCHA11.
	ADC140_ADCMPLR0_CMPLCHA11 = 0x800
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA11_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA11_1 = 0x1
	// Position of CMPLCHA10 field.
	ADC140_ADCMPLR0_CMPLCHA10_Pos = 0xa
	// Bit mask of CMPLCHA10 field.
	ADC140_ADCMPLR0_CMPLCHA10_Msk = 0x400
	// Bit CMPLCHA10.
	ADC140_ADCMPLR0_CMPLCHA10 = 0x400
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA10_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA10_1 = 0x1
	// Position of CMPLCHA09 field.
	ADC140_ADCMPLR0_CMPLCHA09_Pos = 0x9
	// Bit mask of CMPLCHA09 field.
	ADC140_ADCMPLR0_CMPLCHA09_Msk = 0x200
	// Bit CMPLCHA09.
	ADC140_ADCMPLR0_CMPLCHA09 = 0x200
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA09_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA09_1 = 0x1
	// Position of CMPLCHA08 field.
	ADC140_ADCMPLR0_CMPLCHA08_Pos = 0x8
	// Bit mask of CMPLCHA08 field.
	ADC140_ADCMPLR0_CMPLCHA08_Msk = 0x100
	// Bit CMPLCHA08.
	ADC140_ADCMPLR0_CMPLCHA08 = 0x100
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA08_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA08_1 = 0x1
	// Position of CMPLCHA07 field.
	ADC140_ADCMPLR0_CMPLCHA07_Pos = 0x7
	// Bit mask of CMPLCHA07 field.
	ADC140_ADCMPLR0_CMPLCHA07_Msk = 0x80
	// Bit CMPLCHA07.
	ADC140_ADCMPLR0_CMPLCHA07 = 0x80
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA07_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA07_1 = 0x1
	// Position of CMPLCHA06 field.
	ADC140_ADCMPLR0_CMPLCHA06_Pos = 0x6
	// Bit mask of CMPLCHA06 field.
	ADC140_ADCMPLR0_CMPLCHA06_Msk = 0x40
	// Bit CMPLCHA06.
	ADC140_ADCMPLR0_CMPLCHA06 = 0x40
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA06_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA06_1 = 0x1
	// Position of CMPLCHA05 field.
	ADC140_ADCMPLR0_CMPLCHA05_Pos = 0x5
	// Bit mask of CMPLCHA05 field.
	ADC140_ADCMPLR0_CMPLCHA05_Msk = 0x20
	// Bit CMPLCHA05.
	ADC140_ADCMPLR0_CMPLCHA05 = 0x20
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA05_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA05_1 = 0x1
	// Position of CMPLCHA04 field.
	ADC140_ADCMPLR0_CMPLCHA04_Pos = 0x4
	// Bit mask of CMPLCHA04 field.
	ADC140_ADCMPLR0_CMPLCHA04_Msk = 0x10
	// Bit CMPLCHA04.
	ADC140_ADCMPLR0_CMPLCHA04 = 0x10
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA04_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA04_1 = 0x1
	// Position of CMPLCHA03 field.
	ADC140_ADCMPLR0_CMPLCHA03_Pos = 0x3
	// Bit mask of CMPLCHA03 field.
	ADC140_ADCMPLR0_CMPLCHA03_Msk = 0x8
	// Bit CMPLCHA03.
	ADC140_ADCMPLR0_CMPLCHA03 = 0x8
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA03_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA03_1 = 0x1
	// Position of CMPLCHA02 field.
	ADC140_ADCMPLR0_CMPLCHA02_Pos = 0x2
	// Bit mask of CMPLCHA02 field.
	ADC140_ADCMPLR0_CMPLCHA02_Msk = 0x4
	// Bit CMPLCHA02.
	ADC140_ADCMPLR0_CMPLCHA02 = 0x4
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA02_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA02_1 = 0x1
	// Position of CMPLCHA01 field.
	ADC140_ADCMPLR0_CMPLCHA01_Pos = 0x1
	// Bit mask of CMPLCHA01 field.
	ADC140_ADCMPLR0_CMPLCHA01_Msk = 0x2
	// Bit CMPLCHA01.
	ADC140_ADCMPLR0_CMPLCHA01 = 0x2
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA01_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA01_1 = 0x1
	// Position of CMPLCHA00 field.
	ADC140_ADCMPLR0_CMPLCHA00_Pos = 0x0
	// Bit mask of CMPLCHA00 field.
	ADC140_ADCMPLR0_CMPLCHA00_Msk = 0x1
	// Bit CMPLCHA00.
	ADC140_ADCMPLR0_CMPLCHA00 = 0x1
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR0_CMPLCHA00_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR0_CMPLCHA00_1 = 0x1

	// ADCMPLR1: A/D Compare Function Window A Comparison Condition Setting Register 1
	// Position of Reserved field.
	ADC140_ADCMPLR1_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	ADC140_ADCMPLR1_Reserved_Msk = 0xf000
	// Position of CMPLCHA27 field.
	ADC140_ADCMPLR1_CMPLCHA27_Pos = 0xb
	// Bit mask of CMPLCHA27 field.
	ADC140_ADCMPLR1_CMPLCHA27_Msk = 0x800
	// Bit CMPLCHA27.
	ADC140_ADCMPLR1_CMPLCHA27 = 0x800
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR1_CMPLCHA27_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR1_CMPLCHA27_1 = 0x1
	// Position of CMPLCHA26 field.
	ADC140_ADCMPLR1_CMPLCHA26_Pos = 0xa
	// Bit mask of CMPLCHA26 field.
	ADC140_ADCMPLR1_CMPLCHA26_Msk = 0x400
	// Bit CMPLCHA26.
	ADC140_ADCMPLR1_CMPLCHA26 = 0x400
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR1_CMPLCHA26_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR1_CMPLCHA26_1 = 0x1
	// Position of CMPLCHA25 field.
	ADC140_ADCMPLR1_CMPLCHA25_Pos = 0x9
	// Bit mask of CMPLCHA25 field.
	ADC140_ADCMPLR1_CMPLCHA25_Msk = 0x200
	// Bit CMPLCHA25.
	ADC140_ADCMPLR1_CMPLCHA25 = 0x200
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR1_CMPLCHA25_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR1_CMPLCHA25_1 = 0x1
	// Position of CMPLCHA24 field.
	ADC140_ADCMPLR1_CMPLCHA24_Pos = 0x8
	// Bit mask of CMPLCHA24 field.
	ADC140_ADCMPLR1_CMPLCHA24_Msk = 0x100
	// Bit CMPLCHA24.
	ADC140_ADCMPLR1_CMPLCHA24 = 0x100
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR1_CMPLCHA24_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR1_CMPLCHA24_1 = 0x1
	// Position of CMPLCHA23 field.
	ADC140_ADCMPLR1_CMPLCHA23_Pos = 0x7
	// Bit mask of CMPLCHA23 field.
	ADC140_ADCMPLR1_CMPLCHA23_Msk = 0x80
	// Bit CMPLCHA23.
	ADC140_ADCMPLR1_CMPLCHA23 = 0x80
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR1_CMPLCHA23_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR1_CMPLCHA23_1 = 0x1
	// Position of CMPLCHA22 field.
	ADC140_ADCMPLR1_CMPLCHA22_Pos = 0x6
	// Bit mask of CMPLCHA22 field.
	ADC140_ADCMPLR1_CMPLCHA22_Msk = 0x40
	// Bit CMPLCHA22.
	ADC140_ADCMPLR1_CMPLCHA22 = 0x40
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR1_CMPLCHA22_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR1_CMPLCHA22_1 = 0x1
	// Position of CMPLCHA21 field.
	ADC140_ADCMPLR1_CMPLCHA21_Pos = 0x5
	// Bit mask of CMPLCHA21 field.
	ADC140_ADCMPLR1_CMPLCHA21_Msk = 0x20
	// Bit CMPLCHA21.
	ADC140_ADCMPLR1_CMPLCHA21 = 0x20
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR1_CMPLCHA21_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR1_CMPLCHA21_1 = 0x1
	// Position of CMPLCHA20 field.
	ADC140_ADCMPLR1_CMPLCHA20_Pos = 0x4
	// Bit mask of CMPLCHA20 field.
	ADC140_ADCMPLR1_CMPLCHA20_Msk = 0x10
	// Bit CMPLCHA20.
	ADC140_ADCMPLR1_CMPLCHA20 = 0x10
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR1_CMPLCHA20_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR1_CMPLCHA20_1 = 0x1
	// Position of CMPLCHA19 field.
	ADC140_ADCMPLR1_CMPLCHA19_Pos = 0x3
	// Bit mask of CMPLCHA19 field.
	ADC140_ADCMPLR1_CMPLCHA19_Msk = 0x8
	// Bit CMPLCHA19.
	ADC140_ADCMPLR1_CMPLCHA19 = 0x8
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR1_CMPLCHA19_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR1_CMPLCHA19_1 = 0x1
	// Position of CMPLCHA18 field.
	ADC140_ADCMPLR1_CMPLCHA18_Pos = 0x2
	// Bit mask of CMPLCHA18 field.
	ADC140_ADCMPLR1_CMPLCHA18_Msk = 0x4
	// Bit CMPLCHA18.
	ADC140_ADCMPLR1_CMPLCHA18 = 0x4
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR1_CMPLCHA18_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR1_CMPLCHA18_1 = 0x1
	// Position of CMPLCHA17 field.
	ADC140_ADCMPLR1_CMPLCHA17_Pos = 0x1
	// Bit mask of CMPLCHA17 field.
	ADC140_ADCMPLR1_CMPLCHA17_Msk = 0x2
	// Bit CMPLCHA17.
	ADC140_ADCMPLR1_CMPLCHA17 = 0x2
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR1_CMPLCHA17_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR1_CMPLCHA17_1 = 0x1
	// Position of CMPLCHA16 field.
	ADC140_ADCMPLR1_CMPLCHA16_Pos = 0x0
	// Bit mask of CMPLCHA16 field.
	ADC140_ADCMPLR1_CMPLCHA16_Msk = 0x1
	// Bit CMPLCHA16.
	ADC140_ADCMPLR1_CMPLCHA16 = 0x1
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPLR1_CMPLCHA16_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC140_ADCMPLR1_CMPLCHA16_1 = 0x1

	// ADCMPDR0: A/D Compare Function Window A Lower-Side Level Setting Register
	// Position of ADCMPDR0 field.
	ADC140_ADCMPDR0_ADCMPDR0_Pos = 0x0
	// Bit mask of ADCMPDR0 field.
	ADC140_ADCMPDR0_ADCMPDR0_Msk = 0xffff

	// ADCMPDR1: A/D Compare Function Window A Upper-Side Level Setting Register
	// Position of ADCMPDR1 field.
	ADC140_ADCMPDR1_ADCMPDR1_Pos = 0x0
	// Bit mask of ADCMPDR1 field.
	ADC140_ADCMPDR1_ADCMPDR1_Msk = 0xffff

	// ADCMPSR0: A/D Compare Function Window A Channel Status Register 0
	// Position of CMPSTCHA15 field.
	ADC140_ADCMPSR0_CMPSTCHA15_Pos = 0xf
	// Bit mask of CMPSTCHA15 field.
	ADC140_ADCMPSR0_CMPSTCHA15_Msk = 0x8000
	// Bit CMPSTCHA15.
	ADC140_ADCMPSR0_CMPSTCHA15 = 0x8000
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA15_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA15_1 = 0x1
	// Position of CMPSTCHA14 field.
	ADC140_ADCMPSR0_CMPSTCHA14_Pos = 0xe
	// Bit mask of CMPSTCHA14 field.
	ADC140_ADCMPSR0_CMPSTCHA14_Msk = 0x4000
	// Bit CMPSTCHA14.
	ADC140_ADCMPSR0_CMPSTCHA14 = 0x4000
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA14_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA14_1 = 0x1
	// Position of CMPSTCHA13 field.
	ADC140_ADCMPSR0_CMPSTCHA13_Pos = 0xd
	// Bit mask of CMPSTCHA13 field.
	ADC140_ADCMPSR0_CMPSTCHA13_Msk = 0x2000
	// Bit CMPSTCHA13.
	ADC140_ADCMPSR0_CMPSTCHA13 = 0x2000
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA13_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA13_1 = 0x1
	// Position of CMPSTCHA12 field.
	ADC140_ADCMPSR0_CMPSTCHA12_Pos = 0xc
	// Bit mask of CMPSTCHA12 field.
	ADC140_ADCMPSR0_CMPSTCHA12_Msk = 0x1000
	// Bit CMPSTCHA12.
	ADC140_ADCMPSR0_CMPSTCHA12 = 0x1000
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA12_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA12_1 = 0x1
	// Position of CMPSTCHA11 field.
	ADC140_ADCMPSR0_CMPSTCHA11_Pos = 0xb
	// Bit mask of CMPSTCHA11 field.
	ADC140_ADCMPSR0_CMPSTCHA11_Msk = 0x800
	// Bit CMPSTCHA11.
	ADC140_ADCMPSR0_CMPSTCHA11 = 0x800
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA11_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA11_1 = 0x1
	// Position of CMPSTCHA10 field.
	ADC140_ADCMPSR0_CMPSTCHA10_Pos = 0xa
	// Bit mask of CMPSTCHA10 field.
	ADC140_ADCMPSR0_CMPSTCHA10_Msk = 0x400
	// Bit CMPSTCHA10.
	ADC140_ADCMPSR0_CMPSTCHA10 = 0x400
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA10_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA10_1 = 0x1
	// Position of CMPSTCHA09 field.
	ADC140_ADCMPSR0_CMPSTCHA09_Pos = 0x9
	// Bit mask of CMPSTCHA09 field.
	ADC140_ADCMPSR0_CMPSTCHA09_Msk = 0x200
	// Bit CMPSTCHA09.
	ADC140_ADCMPSR0_CMPSTCHA09 = 0x200
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA09_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA09_1 = 0x1
	// Position of CMPSTCHA08 field.
	ADC140_ADCMPSR0_CMPSTCHA08_Pos = 0x8
	// Bit mask of CMPSTCHA08 field.
	ADC140_ADCMPSR0_CMPSTCHA08_Msk = 0x100
	// Bit CMPSTCHA08.
	ADC140_ADCMPSR0_CMPSTCHA08 = 0x100
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA08_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA08_1 = 0x1
	// Position of CMPSTCHA07 field.
	ADC140_ADCMPSR0_CMPSTCHA07_Pos = 0x7
	// Bit mask of CMPSTCHA07 field.
	ADC140_ADCMPSR0_CMPSTCHA07_Msk = 0x80
	// Bit CMPSTCHA07.
	ADC140_ADCMPSR0_CMPSTCHA07 = 0x80
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA07_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA07_1 = 0x1
	// Position of CMPSTCHA06 field.
	ADC140_ADCMPSR0_CMPSTCHA06_Pos = 0x6
	// Bit mask of CMPSTCHA06 field.
	ADC140_ADCMPSR0_CMPSTCHA06_Msk = 0x40
	// Bit CMPSTCHA06.
	ADC140_ADCMPSR0_CMPSTCHA06 = 0x40
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA06_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA06_1 = 0x1
	// Position of CMPSTCHA05 field.
	ADC140_ADCMPSR0_CMPSTCHA05_Pos = 0x5
	// Bit mask of CMPSTCHA05 field.
	ADC140_ADCMPSR0_CMPSTCHA05_Msk = 0x20
	// Bit CMPSTCHA05.
	ADC140_ADCMPSR0_CMPSTCHA05 = 0x20
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA05_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA05_1 = 0x1
	// Position of CMPSTCHA04 field.
	ADC140_ADCMPSR0_CMPSTCHA04_Pos = 0x4
	// Bit mask of CMPSTCHA04 field.
	ADC140_ADCMPSR0_CMPSTCHA04_Msk = 0x10
	// Bit CMPSTCHA04.
	ADC140_ADCMPSR0_CMPSTCHA04 = 0x10
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA04_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA04_1 = 0x1
	// Position of CMPSTCHA03 field.
	ADC140_ADCMPSR0_CMPSTCHA03_Pos = 0x3
	// Bit mask of CMPSTCHA03 field.
	ADC140_ADCMPSR0_CMPSTCHA03_Msk = 0x8
	// Bit CMPSTCHA03.
	ADC140_ADCMPSR0_CMPSTCHA03 = 0x8
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA03_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA03_1 = 0x1
	// Position of CMPSTCHA02 field.
	ADC140_ADCMPSR0_CMPSTCHA02_Pos = 0x2
	// Bit mask of CMPSTCHA02 field.
	ADC140_ADCMPSR0_CMPSTCHA02_Msk = 0x4
	// Bit CMPSTCHA02.
	ADC140_ADCMPSR0_CMPSTCHA02 = 0x4
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA02_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA02_1 = 0x1
	// Position of CMPSTCHA01 field.
	ADC140_ADCMPSR0_CMPSTCHA01_Pos = 0x1
	// Bit mask of CMPSTCHA01 field.
	ADC140_ADCMPSR0_CMPSTCHA01_Msk = 0x2
	// Bit CMPSTCHA01.
	ADC140_ADCMPSR0_CMPSTCHA01 = 0x2
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA01_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA01_1 = 0x1
	// Position of CMPSTCHA00 field.
	ADC140_ADCMPSR0_CMPSTCHA00_Pos = 0x0
	// Bit mask of CMPSTCHA00 field.
	ADC140_ADCMPSR0_CMPSTCHA00_Msk = 0x1
	// Bit CMPSTCHA00.
	ADC140_ADCMPSR0_CMPSTCHA00 = 0x1
	// Comparison conditions are not met.
	ADC140_ADCMPSR0_CMPSTCHA00_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR0_CMPSTCHA00_1 = 0x1

	// ADCMPSR1: A/D Compare Function Window A Channel Status Register 1
	// Position of Reserved field.
	ADC140_ADCMPSR1_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	ADC140_ADCMPSR1_Reserved_Msk = 0xf000
	// Position of CMPSTCHA27 field.
	ADC140_ADCMPSR1_CMPSTCHA27_Pos = 0xb
	// Bit mask of CMPSTCHA27 field.
	ADC140_ADCMPSR1_CMPSTCHA27_Msk = 0x800
	// Bit CMPSTCHA27.
	ADC140_ADCMPSR1_CMPSTCHA27 = 0x800
	// Comparison conditions are not met.
	ADC140_ADCMPSR1_CMPSTCHA27_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR1_CMPSTCHA27_1 = 0x1
	// Position of CMPSTCHA26 field.
	ADC140_ADCMPSR1_CMPSTCHA26_Pos = 0xa
	// Bit mask of CMPSTCHA26 field.
	ADC140_ADCMPSR1_CMPSTCHA26_Msk = 0x400
	// Bit CMPSTCHA26.
	ADC140_ADCMPSR1_CMPSTCHA26 = 0x400
	// Comparison conditions are not met.
	ADC140_ADCMPSR1_CMPSTCHA26_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR1_CMPSTCHA26_1 = 0x1
	// Position of CMPSTCHA25 field.
	ADC140_ADCMPSR1_CMPSTCHA25_Pos = 0x9
	// Bit mask of CMPSTCHA25 field.
	ADC140_ADCMPSR1_CMPSTCHA25_Msk = 0x200
	// Bit CMPSTCHA25.
	ADC140_ADCMPSR1_CMPSTCHA25 = 0x200
	// Comparison conditions are not met.
	ADC140_ADCMPSR1_CMPSTCHA25_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR1_CMPSTCHA25_1 = 0x1
	// Position of CMPSTCHA24 field.
	ADC140_ADCMPSR1_CMPSTCHA24_Pos = 0x8
	// Bit mask of CMPSTCHA24 field.
	ADC140_ADCMPSR1_CMPSTCHA24_Msk = 0x100
	// Bit CMPSTCHA24.
	ADC140_ADCMPSR1_CMPSTCHA24 = 0x100
	// Comparison conditions are not met.
	ADC140_ADCMPSR1_CMPSTCHA24_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR1_CMPSTCHA24_1 = 0x1
	// Position of CMPSTCHA23 field.
	ADC140_ADCMPSR1_CMPSTCHA23_Pos = 0x7
	// Bit mask of CMPSTCHA23 field.
	ADC140_ADCMPSR1_CMPSTCHA23_Msk = 0x80
	// Bit CMPSTCHA23.
	ADC140_ADCMPSR1_CMPSTCHA23 = 0x80
	// Comparison conditions are not met.
	ADC140_ADCMPSR1_CMPSTCHA23_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR1_CMPSTCHA23_1 = 0x1
	// Position of CMPSTCHA22 field.
	ADC140_ADCMPSR1_CMPSTCHA22_Pos = 0x6
	// Bit mask of CMPSTCHA22 field.
	ADC140_ADCMPSR1_CMPSTCHA22_Msk = 0x40
	// Bit CMPSTCHA22.
	ADC140_ADCMPSR1_CMPSTCHA22 = 0x40
	// Comparison conditions are not met.
	ADC140_ADCMPSR1_CMPSTCHA22_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR1_CMPSTCHA22_1 = 0x1
	// Position of CMPSTCHA21 field.
	ADC140_ADCMPSR1_CMPSTCHA21_Pos = 0x5
	// Bit mask of CMPSTCHA21 field.
	ADC140_ADCMPSR1_CMPSTCHA21_Msk = 0x20
	// Bit CMPSTCHA21.
	ADC140_ADCMPSR1_CMPSTCHA21 = 0x20
	// Comparison conditions are not met.
	ADC140_ADCMPSR1_CMPSTCHA21_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR1_CMPSTCHA21_1 = 0x1
	// Position of CMPSTCHA20 field.
	ADC140_ADCMPSR1_CMPSTCHA20_Pos = 0x4
	// Bit mask of CMPSTCHA20 field.
	ADC140_ADCMPSR1_CMPSTCHA20_Msk = 0x10
	// Bit CMPSTCHA20.
	ADC140_ADCMPSR1_CMPSTCHA20 = 0x10
	// Comparison conditions are not met.
	ADC140_ADCMPSR1_CMPSTCHA20_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR1_CMPSTCHA20_1 = 0x1
	// Position of CMPSTCHA19 field.
	ADC140_ADCMPSR1_CMPSTCHA19_Pos = 0x3
	// Bit mask of CMPSTCHA19 field.
	ADC140_ADCMPSR1_CMPSTCHA19_Msk = 0x8
	// Bit CMPSTCHA19.
	ADC140_ADCMPSR1_CMPSTCHA19 = 0x8
	// Comparison conditions are not met.
	ADC140_ADCMPSR1_CMPSTCHA19_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR1_CMPSTCHA19_1 = 0x1
	// Position of CMPSTCHA18 field.
	ADC140_ADCMPSR1_CMPSTCHA18_Pos = 0x2
	// Bit mask of CMPSTCHA18 field.
	ADC140_ADCMPSR1_CMPSTCHA18_Msk = 0x4
	// Bit CMPSTCHA18.
	ADC140_ADCMPSR1_CMPSTCHA18 = 0x4
	// Comparison conditions are not met.
	ADC140_ADCMPSR1_CMPSTCHA18_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR1_CMPSTCHA18_1 = 0x1
	// Position of CMPSTCHA17 field.
	ADC140_ADCMPSR1_CMPSTCHA17_Pos = 0x1
	// Bit mask of CMPSTCHA17 field.
	ADC140_ADCMPSR1_CMPSTCHA17_Msk = 0x2
	// Bit CMPSTCHA17.
	ADC140_ADCMPSR1_CMPSTCHA17 = 0x2
	// Comparison conditions are not met.
	ADC140_ADCMPSR1_CMPSTCHA17_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR1_CMPSTCHA17_1 = 0x1
	// Position of CMPSTCHA16 field.
	ADC140_ADCMPSR1_CMPSTCHA16_Pos = 0x0
	// Bit mask of CMPSTCHA16 field.
	ADC140_ADCMPSR1_CMPSTCHA16_Msk = 0x1
	// Bit CMPSTCHA16.
	ADC140_ADCMPSR1_CMPSTCHA16 = 0x1
	// Comparison conditions are not met.
	ADC140_ADCMPSR1_CMPSTCHA16_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSR1_CMPSTCHA16_1 = 0x1

	// ADCMPSER: A/D Compare Function Window A Extended Input Channel Status Register
	// Position of Reserved field.
	ADC140_ADCMPSER_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC140_ADCMPSER_Reserved_Msk = 0xfc
	// Position of CMPSTOCA field.
	ADC140_ADCMPSER_CMPSTOCA_Pos = 0x1
	// Bit mask of CMPSTOCA field.
	ADC140_ADCMPSER_CMPSTOCA_Msk = 0x2
	// Bit CMPSTOCA.
	ADC140_ADCMPSER_CMPSTOCA = 0x2
	// Comparison conditions are not met.
	ADC140_ADCMPSER_CMPSTOCA_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSER_CMPSTOCA_1 = 0x1
	// Position of CMPSTTSA field.
	ADC140_ADCMPSER_CMPSTTSA_Pos = 0x0
	// Bit mask of CMPSTTSA field.
	ADC140_ADCMPSER_CMPSTTSA_Msk = 0x1
	// Bit CMPSTTSA.
	ADC140_ADCMPSER_CMPSTTSA = 0x1
	// Comparison conditions are not met.
	ADC140_ADCMPSER_CMPSTTSA_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPSER_CMPSTTSA_1 = 0x1

	// ADCMPBNSR: A/D Compare Function Window B Channel Selection Register
	// Position of CMPLB field.
	ADC140_ADCMPBNSR_CMPLB_Pos = 0x7
	// Bit mask of CMPLB field.
	ADC140_ADCMPBNSR_CMPLB_Msk = 0x80
	// Bit CMPLB.
	ADC140_ADCMPBNSR_CMPLB = 0x80
	// CMPLLB value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < CMPLLB value or CMPULB value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPBNSR_CMPLB_0 = 0x0
	// CMPLLB value < A/D converted value(ADCMPCR.WCMPE=0) / CMPLLB value < A/D converted value < CMPULB value (ADCMPCR.WCMPE=1)
	ADC140_ADCMPBNSR_CMPLB_1 = 0x1
	// Position of Reserved field.
	ADC140_ADCMPBNSR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ADC140_ADCMPBNSR_Reserved_Msk = 0x40
	// Bit Reserved.
	ADC140_ADCMPBNSR_Reserved = 0x40
	// Position of CMPCHB field.
	ADC140_ADCMPBNSR_CMPCHB_Pos = 0x0
	// Bit mask of CMPCHB field.
	ADC140_ADCMPBNSR_CMPCHB_Msk = 0x3f
	// AN000
	ADC140_ADCMPBNSR_CMPCHB_0x00 = 0x0
	// AN001
	ADC140_ADCMPBNSR_CMPCHB_0x01 = 0x1
	// AN002
	ADC140_ADCMPBNSR_CMPCHB_0x02 = 0x2
	// AN003
	ADC140_ADCMPBNSR_CMPCHB_0x03 = 0x3
	// AN004
	ADC140_ADCMPBNSR_CMPCHB_0x04 = 0x4
	// AN005
	ADC140_ADCMPBNSR_CMPCHB_0x05 = 0x5
	// AN006
	ADC140_ADCMPBNSR_CMPCHB_0x06 = 0x6
	// AN007
	ADC140_ADCMPBNSR_CMPCHB_0x07 = 0x7
	// AN008
	ADC140_ADCMPBNSR_CMPCHB_0x08 = 0x8
	// AN009
	ADC140_ADCMPBNSR_CMPCHB_0x09 = 0x9
	// AN010
	ADC140_ADCMPBNSR_CMPCHB_0x0A = 0xa
	// AN011
	ADC140_ADCMPBNSR_CMPCHB_0x0B = 0xb
	// AN012
	ADC140_ADCMPBNSR_CMPCHB_0x0C = 0xc
	// AN013
	ADC140_ADCMPBNSR_CMPCHB_0x0D = 0xd
	// AN014
	ADC140_ADCMPBNSR_CMPCHB_0x0E = 0xe
	// AN015
	ADC140_ADCMPBNSR_CMPCHB_0x0F = 0xf
	// AN016
	ADC140_ADCMPBNSR_CMPCHB_0x10 = 0x10
	// AN017
	ADC140_ADCMPBNSR_CMPCHB_0x11 = 0x11
	// AN018
	ADC140_ADCMPBNSR_CMPCHB_0x12 = 0x12
	// AN019
	ADC140_ADCMPBNSR_CMPCHB_0x13 = 0x13
	// AN020
	ADC140_ADCMPBNSR_CMPCHB_0x14 = 0x14
	// AN021
	ADC140_ADCMPBNSR_CMPCHB_0x15 = 0x15
	// AN022
	ADC140_ADCMPBNSR_CMPCHB_0x16 = 0x16
	// AN023
	ADC140_ADCMPBNSR_CMPCHB_0x17 = 0x17
	// AN024
	ADC140_ADCMPBNSR_CMPCHB_0x18 = 0x18
	// AN025
	ADC140_ADCMPBNSR_CMPCHB_0x19 = 0x19
	// AN026
	ADC140_ADCMPBNSR_CMPCHB_0x1A = 0x1a
	// AN027
	ADC140_ADCMPBNSR_CMPCHB_0x1B = 0x1b
	// Temperature sensor
	ADC140_ADCMPBNSR_CMPCHB_0x20 = 0x20
	// Internal reference voltage
	ADC140_ADCMPBNSR_CMPCHB_0x21 = 0x21
	// No channel is selected
	ADC140_ADCMPBNSR_CMPCHB_0x3F = 0x3f

	// ADWINLLB: A/D Compare Function Window B Lower-Side Level Setting Register
	// Position of ADWINLLB field.
	ADC140_ADWINLLB_ADWINLLB_Pos = 0x0
	// Bit mask of ADWINLLB field.
	ADC140_ADWINLLB_ADWINLLB_Msk = 0xffff

	// ADWINULB: A/D Compare Function Window B Upper-Side Level Setting Register
	// Position of ADWINULB field.
	ADC140_ADWINULB_ADWINULB_Pos = 0x0
	// Bit mask of ADWINULB field.
	ADC140_ADWINULB_ADWINULB_Msk = 0xffff

	// ADCMPBSR: A/D Compare Function Window B Status Register
	// Position of Reserved field.
	ADC140_ADCMPBSR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	ADC140_ADCMPBSR_Reserved_Msk = 0xfe
	// Position of CMPSTB field.
	ADC140_ADCMPBSR_CMPSTB_Pos = 0x0
	// Bit mask of CMPSTB field.
	ADC140_ADCMPBSR_CMPSTB_Msk = 0x1
	// Bit CMPSTB.
	ADC140_ADCMPBSR_CMPSTB = 0x1
	// Comparison conditions are not met.
	ADC140_ADCMPBSR_CMPSTB_0 = 0x0
	// Comparison conditions are met.
	ADC140_ADCMPBSR_CMPSTB_1 = 0x1

	// ADSSTRL: A/D Sampling State Register L
	// Position of SST field.
	ADC140_ADSSTRL_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC140_ADSSTRL_SST_Msk = 0xff

	// ADSSTRT: A/D Sampling State Register T
	// Position of SST field.
	ADC140_ADSSTRT_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC140_ADSSTRT_SST_Msk = 0xff

	// ADSSTRO: A/D Sampling State Register O
	// Position of SST field.
	ADC140_ADSSTRO_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC140_ADSSTRO_SST_Msk = 0xff

	// ADSSTR0: A/D Sampling State Register %s
	// Position of SST field.
	ADC140_ADSSTR_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC140_ADSSTR_SST_Msk = 0xff
)

// Constants for ACMPLP: Low-Power Analog Comparator
const (
	// COMPMDR: ACMPLP Mode Setting Register
	// Position of C1MON field.
	ACMPLP_COMPMDR_C1MON_Pos = 0x7
	// Bit mask of C1MON field.
	ACMPLP_COMPMDR_C1MON_Msk = 0x80
	// Bit C1MON.
	ACMPLP_COMPMDR_C1MON = 0x80
	// CMPIN1 < CMPREF1, CMPIN1 < internal reference voltage, or ACMPLP1 operation disabled.(When the window function is disabled)/CMPIN1 < VRFL, CMPIN1 > VRFH, or ACMPLP1 operation disabled.(When the window function is enabled)
	ACMPLP_COMPMDR_C1MON_0 = 0x0
	// CMPIN1 > CMPREF1, or CMPIN1 > internal reference voltage.(When the window function is disabled)/VRFL < CMPIN1 < VRFH.(When the window function is enabled)
	ACMPLP_COMPMDR_C1MON_1 = 0x1
	// Position of C1VRF field.
	ACMPLP_COMPMDR_C1VRF_Pos = 0x6
	// Bit mask of C1VRF field.
	ACMPLP_COMPMDR_C1VRF_Msk = 0x40
	// Bit C1VRF.
	ACMPLP_COMPMDR_C1VRF = 0x40
	// IVREF0 or IVREF1
	ACMPLP_COMPMDR_C1VRF_0 = 0x0
	// internal reference voltage (Vref)
	ACMPLP_COMPMDR_C1VRF_1 = 0x1
	// Position of C1WDE field.
	ACMPLP_COMPMDR_C1WDE_Pos = 0x5
	// Bit mask of C1WDE field.
	ACMPLP_COMPMDR_C1WDE_Msk = 0x20
	// Bit C1WDE.
	ACMPLP_COMPMDR_C1WDE = 0x20
	// Disabled
	ACMPLP_COMPMDR_C1WDE_0 = 0x0
	// Enabled
	ACMPLP_COMPMDR_C1WDE_1 = 0x1
	// Position of C1ENB field.
	ACMPLP_COMPMDR_C1ENB_Pos = 0x4
	// Bit mask of C1ENB field.
	ACMPLP_COMPMDR_C1ENB_Msk = 0x10
	// Bit C1ENB.
	ACMPLP_COMPMDR_C1ENB = 0x10
	// Disabled
	ACMPLP_COMPMDR_C1ENB_0 = 0x0
	// Enabled
	ACMPLP_COMPMDR_C1ENB_1 = 0x1
	// Position of C0MON field.
	ACMPLP_COMPMDR_C0MON_Pos = 0x3
	// Bit mask of C0MON field.
	ACMPLP_COMPMDR_C0MON_Msk = 0x8
	// Bit C0MON.
	ACMPLP_COMPMDR_C0MON = 0x8
	// CMPIN0 < CMPREF0, CMPIN0 < internal reference voltage, or ACMPLP0 operation disabled.(When the window function is disabled)/CMPIN0 < VRFL, CMPIN0 > VRFH, or ACMPLP0 operation disabled.(When the window function is enabled)
	ACMPLP_COMPMDR_C0MON_0 = 0x0
	// CMPIN0 > CMPREF0, or CMPIN0 > internal reference voltage.(When the window function is disabled)/VRFL < CMPIN0 < VRFH.(When the window function is enabled)
	ACMPLP_COMPMDR_C0MON_1 = 0x1
	// Position of C0VRF field.
	ACMPLP_COMPMDR_C0VRF_Pos = 0x2
	// Bit mask of C0VRF field.
	ACMPLP_COMPMDR_C0VRF_Msk = 0x4
	// Bit C0VRF.
	ACMPLP_COMPMDR_C0VRF = 0x4
	// IVREF0
	ACMPLP_COMPMDR_C0VRF_0 = 0x0
	// internal reference voltage (Vref)
	ACMPLP_COMPMDR_C0VRF_1 = 0x1
	// Position of C0WDE field.
	ACMPLP_COMPMDR_C0WDE_Pos = 0x1
	// Bit mask of C0WDE field.
	ACMPLP_COMPMDR_C0WDE_Msk = 0x2
	// Bit C0WDE.
	ACMPLP_COMPMDR_C0WDE = 0x2
	// Disabled
	ACMPLP_COMPMDR_C0WDE_0 = 0x0
	// Enabled
	ACMPLP_COMPMDR_C0WDE_1 = 0x1
	// Position of C0ENB field.
	ACMPLP_COMPMDR_C0ENB_Pos = 0x0
	// Bit mask of C0ENB field.
	ACMPLP_COMPMDR_C0ENB_Msk = 0x1
	// Bit C0ENB.
	ACMPLP_COMPMDR_C0ENB = 0x1
	// Disabled
	ACMPLP_COMPMDR_C0ENB_0 = 0x0
	// Enabled
	ACMPLP_COMPMDR_C0ENB_1 = 0x1

	// COMPFIR: ACMPLP Filter Control Register
	// Position of C1EDG field.
	ACMPLP_COMPFIR_C1EDG_Pos = 0x7
	// Bit mask of C1EDG field.
	ACMPLP_COMPFIR_C1EDG_Msk = 0x80
	// Bit C1EDG.
	ACMPLP_COMPFIR_C1EDG = 0x80
	// Interrupt and ELC event request by one-edge detection
	ACMPLP_COMPFIR_C1EDG_0 = 0x0
	// Interrupt and ELC event request by both-edge detection
	ACMPLP_COMPFIR_C1EDG_1 = 0x1
	// Position of C1EPO field.
	ACMPLP_COMPFIR_C1EPO_Pos = 0x6
	// Bit mask of C1EPO field.
	ACMPLP_COMPFIR_C1EPO_Msk = 0x40
	// Bit C1EPO.
	ACMPLP_COMPFIR_C1EPO = 0x40
	// Interrupt and ELC event request at rising edge
	ACMPLP_COMPFIR_C1EPO_0 = 0x0
	// Interrupt and ELC event request at falling edge
	ACMPLP_COMPFIR_C1EPO_1 = 0x1
	// Position of C1FCK field.
	ACMPLP_COMPFIR_C1FCK_Pos = 0x4
	// Bit mask of C1FCK field.
	ACMPLP_COMPFIR_C1FCK_Msk = 0x30
	// No Sampling (bypass)
	ACMPLP_COMPFIR_C1FCK_00 = 0x0
	// Sampling at PCLK
	ACMPLP_COMPFIR_C1FCK_01 = 0x1
	// Sampling at PCLK/8
	ACMPLP_COMPFIR_C1FCK_10 = 0x2
	// Sampling at PCLK/32
	ACMPLP_COMPFIR_C1FCK_11 = 0x3
	// Position of C0EDG field.
	ACMPLP_COMPFIR_C0EDG_Pos = 0x3
	// Bit mask of C0EDG field.
	ACMPLP_COMPFIR_C0EDG_Msk = 0x8
	// Bit C0EDG.
	ACMPLP_COMPFIR_C0EDG = 0x8
	// Interrupt and ELC event request by one-edge detection
	ACMPLP_COMPFIR_C0EDG_0 = 0x0
	// Interrupt and ELC event request by both-edge detection
	ACMPLP_COMPFIR_C0EDG_1 = 0x1
	// Position of C0EPO field.
	ACMPLP_COMPFIR_C0EPO_Pos = 0x2
	// Bit mask of C0EPO field.
	ACMPLP_COMPFIR_C0EPO_Msk = 0x4
	// Bit C0EPO.
	ACMPLP_COMPFIR_C0EPO = 0x4
	// Interrupt and ELC event request at rising edge
	ACMPLP_COMPFIR_C0EPO_0 = 0x0
	// Interrupt and ELC event request at falling edge
	ACMPLP_COMPFIR_C0EPO_1 = 0x1
	// Position of C0FCK field.
	ACMPLP_COMPFIR_C0FCK_Pos = 0x0
	// Bit mask of C0FCK field.
	ACMPLP_COMPFIR_C0FCK_Msk = 0x3
	// No Sampling (bypass)
	ACMPLP_COMPFIR_C0FCK_00 = 0x0
	// Sampling at PCLK
	ACMPLP_COMPFIR_C0FCK_01 = 0x1
	// Sampling at PCLK/8
	ACMPLP_COMPFIR_C0FCK_10 = 0x2
	// Sampling at PCLK/32
	ACMPLP_COMPFIR_C0FCK_11 = 0x3

	// COMPOCR: ACMPLP Output Control Register
	// Position of SPDMD field.
	ACMPLP_COMPOCR_SPDMD_Pos = 0x7
	// Bit mask of SPDMD field.
	ACMPLP_COMPOCR_SPDMD_Msk = 0x80
	// Bit SPDMD.
	ACMPLP_COMPOCR_SPDMD = 0x80
	// Comparator low-speed mode
	ACMPLP_COMPOCR_SPDMD_0 = 0x0
	// Comparator high-speed mode
	ACMPLP_COMPOCR_SPDMD_1 = 0x1
	// Position of C1OP field.
	ACMPLP_COMPOCR_C1OP_Pos = 0x6
	// Bit mask of C1OP field.
	ACMPLP_COMPOCR_C1OP_Msk = 0x40
	// Bit C1OP.
	ACMPLP_COMPOCR_C1OP = 0x40
	// Non inverted
	ACMPLP_COMPOCR_C1OP_0 = 0x0
	// Inverted
	ACMPLP_COMPOCR_C1OP_1 = 0x1
	// Position of C1OE field.
	ACMPLP_COMPOCR_C1OE_Pos = 0x5
	// Bit mask of C1OE field.
	ACMPLP_COMPOCR_C1OE_Msk = 0x20
	// Bit C1OE.
	ACMPLP_COMPOCR_C1OE = 0x20
	// Disabled
	ACMPLP_COMPOCR_C1OE_0 = 0x0
	// Enabled
	ACMPLP_COMPOCR_C1OE_1 = 0x1
	// Position of Reserved field.
	ACMPLP_COMPOCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	ACMPLP_COMPOCR_Reserved_Msk = 0x18
	// Position of C0OP field.
	ACMPLP_COMPOCR_C0OP_Pos = 0x2
	// Bit mask of C0OP field.
	ACMPLP_COMPOCR_C0OP_Msk = 0x4
	// Bit C0OP.
	ACMPLP_COMPOCR_C0OP = 0x4
	// Non inverted
	ACMPLP_COMPOCR_C0OP_0 = 0x0
	// Inverted
	ACMPLP_COMPOCR_C0OP_1 = 0x1
	// Position of C0OE field.
	ACMPLP_COMPOCR_C0OE_Pos = 0x1
	// Bit mask of C0OE field.
	ACMPLP_COMPOCR_C0OE_Msk = 0x2
	// Bit C0OE.
	ACMPLP_COMPOCR_C0OE = 0x2
	// Disabled
	ACMPLP_COMPOCR_C0OE_0 = 0x0
	// Enabled
	ACMPLP_COMPOCR_C0OE_1 = 0x1
	// Position of Reserved field.
	ACMPLP_COMPOCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	ACMPLP_COMPOCR_Reserved_Msk = 0x1
	// Bit Reserved.
	ACMPLP_COMPOCR_Reserved = 0x1

	// COMPSEL0: Comparator Input Select Register
	// Position of Reserved field.
	ACMPLP_COMPSEL0_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	ACMPLP_COMPSEL0_Reserved_Msk = 0x80
	// Bit Reserved.
	ACMPLP_COMPSEL0_Reserved = 0x80
	// Position of CMPSEL64 field.
	ACMPLP_COMPSEL0_CMPSEL64_Pos = 0x4
	// Bit mask of CMPSEL64 field.
	ACMPLP_COMPSEL0_CMPSEL64_Msk = 0x70
	// No input
	ACMPLP_COMPSEL0_CMPSEL64_000 = 0x0
	// CMPIN1 (P102)
	ACMPLP_COMPSEL0_CMPSEL64_001 = 0x1
	// CMPIN1 (P501)
	ACMPLP_COMPSEL0_CMPSEL64_100 = 0x4
	// Position of Reserved field.
	ACMPLP_COMPSEL0_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	ACMPLP_COMPSEL0_Reserved_Msk = 0x8
	// Bit Reserved.
	ACMPLP_COMPSEL0_Reserved = 0x8
	// Position of CMPSEL20 field.
	ACMPLP_COMPSEL0_CMPSEL20_Pos = 0x0
	// Bit mask of CMPSEL20 field.
	ACMPLP_COMPSEL0_CMPSEL20_Msk = 0x7
	// No input
	ACMPLP_COMPSEL0_CMPSEL20_000 = 0x0
	// CMPIN0 (P100)
	ACMPLP_COMPSEL0_CMPSEL20_001 = 0x1
	// CMPIN0 (P503)
	ACMPLP_COMPSEL0_CMPSEL20_100 = 0x4

	// COMPSEL1: Comparator Reference Voltage Select Register
	// Position of C1VRF2 field.
	ACMPLP_COMPSEL1_C1VRF2_Pos = 0x7
	// Bit mask of C1VRF2 field.
	ACMPLP_COMPSEL1_C1VRF2_Msk = 0x80
	// Bit C1VRF2.
	ACMPLP_COMPSEL1_C1VRF2 = 0x80
	// IVREF0 selected
	ACMPLP_COMPSEL1_C1VRF2_0 = 0x0
	// IVREF1 selected.
	ACMPLP_COMPSEL1_C1VRF2_1 = 0x1
	// Position of CRVS64 field.
	ACMPLP_COMPSEL1_CRVS64_Pos = 0x4
	// Bit mask of CRVS64 field.
	ACMPLP_COMPSEL1_CRVS64_Msk = 0x70
	// No input
	ACMPLP_COMPSEL1_CRVS64_000 = 0x0
	// CMPREF1 (P103)
	ACMPLP_COMPSEL1_CRVS64_001 = 0x1
	// DAC8 (ch1) output
	ACMPLP_COMPSEL1_CRVS64_010 = 0x2
	// CMPREF1 (P500)
	ACMPLP_COMPSEL1_CRVS64_100 = 0x4
	// Position of Reserved field.
	ACMPLP_COMPSEL1_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	ACMPLP_COMPSEL1_Reserved_Msk = 0x8
	// Bit Reserved.
	ACMPLP_COMPSEL1_Reserved = 0x8
	// Position of CRVS20 field.
	ACMPLP_COMPSEL1_CRVS20_Pos = 0x0
	// Bit mask of CRVS20 field.
	ACMPLP_COMPSEL1_CRVS20_Msk = 0x7
	// No input
	ACMPLP_COMPSEL1_CRVS20_000 = 0x0
	// CMPREF0 (P101)
	ACMPLP_COMPSEL1_CRVS20_001 = 0x1
	// DAC8 (ch0) output
	ACMPLP_COMPSEL1_CRVS20_010 = 0x2
	// CMPREF0 (P502)
	ACMPLP_COMPSEL1_CRVS20_100 = 0x4
)

// Constants for TSN: Temperature Sensor
const (
	// TSCDRH: Temperature Sensor Calibration Data Register H
	// Position of TSCDRH field.
	TSN_TSCDRH_TSCDRH_Pos = 0x0
	// Bit mask of TSCDRH field.
	TSN_TSCDRH_TSCDRH_Msk = 0xff

	// TSCDRL: Temperature Sensor Calibration Data Register L
	// Position of TSCDRL field.
	TSN_TSCDRL_TSCDRL_Pos = 0x0
	// Bit mask of TSCDRL field.
	TSN_TSCDRL_TSCDRL_Msk = 0xff
)

// Constants for SLCDC: Segment LCD Controller/Driver
const (
	// LCDM0: LCD Mode Register 0
	// Position of MDSET field.
	SLCDC_LCDM0_MDSET_Pos = 0x6
	// Bit mask of MDSET field.
	SLCDC_LCDM0_MDSET_Msk = 0xc0
	// External resistance division method
	SLCDC_LCDM0_MDSET_00 = 0x0
	// Internal voltage boosting method
	SLCDC_LCDM0_MDSET_01 = 0x1
	// Capacitor split method
	SLCDC_LCDM0_MDSET_10 = 0x2
	// Setting prohibited
	SLCDC_LCDM0_MDSET_11 = 0x3
	// Position of LWAVE field.
	SLCDC_LCDM0_LWAVE_Pos = 0x5
	// Bit mask of LWAVE field.
	SLCDC_LCDM0_LWAVE_Msk = 0x20
	// Bit LWAVE.
	SLCDC_LCDM0_LWAVE = 0x20
	// Waveform A
	SLCDC_LCDM0_LWAVE_0 = 0x0
	// Waveform B
	SLCDC_LCDM0_LWAVE_1 = 0x1
	// Position of LDTY field.
	SLCDC_LCDM0_LDTY_Pos = 0x2
	// Bit mask of LDTY field.
	SLCDC_LCDM0_LDTY_Msk = 0x1c
	// Static
	SLCDC_LCDM0_LDTY_000 = 0x0
	// 2-time slice
	SLCDC_LCDM0_LDTY_001 = 0x1
	// 3-time slice
	SLCDC_LCDM0_LDTY_010 = 0x2
	// 4-time slice
	SLCDC_LCDM0_LDTY_011 = 0x3
	// 8-time slice
	SLCDC_LCDM0_LDTY_101 = 0x5
	// Position of LBAS field.
	SLCDC_LCDM0_LBAS_Pos = 0x0
	// Bit mask of LBAS field.
	SLCDC_LCDM0_LBAS_Msk = 0x3
	// 1/2 bias method
	SLCDC_LCDM0_LBAS_00 = 0x0
	// 1/3 bias method
	SLCDC_LCDM0_LBAS_01 = 0x1
	// 1/4 bias method
	SLCDC_LCDM0_LBAS_10 = 0x2
	// Setting prohibited
	SLCDC_LCDM0_LBAS_11 = 0x3

	// LCDM1: LCD Mode Register 1
	// Position of LCDON field.
	SLCDC_LCDM1_LCDON_Pos = 0x7
	// Bit mask of LCDON field.
	SLCDC_LCDM1_LCDON_Msk = 0x80
	// Bit LCDON.
	SLCDC_LCDM1_LCDON = 0x80
	// Output ground level to segment/common pin(SCOC=0)/Display off (all segment outputs are deselected)(SCOC=1)
	SLCDC_LCDM1_LCDON_0 = 0x0
	// Output ground level to segment/common pin(SCOC=0)/Display on(SCOC=1)
	SLCDC_LCDM1_LCDON_1 = 0x1
	// Position of SCOC field.
	SLCDC_LCDM1_SCOC_Pos = 0x6
	// Bit mask of SCOC field.
	SLCDC_LCDM1_SCOC_Msk = 0x40
	// Bit SCOC.
	SLCDC_LCDM1_SCOC = 0x40
	// Output ground level to segment/common pin(LCDON=0)/Output ground level to segment/common pin(LCDON=1)
	SLCDC_LCDM1_SCOC_0 = 0x0
	// Display off (all segment outputs are deselected)(LCDON=0)/Display on(LCDON=1)
	SLCDC_LCDM1_SCOC_1 = 0x1
	// Position of VLCON field.
	SLCDC_LCDM1_VLCON_Pos = 0x5
	// Bit mask of VLCON field.
	SLCDC_LCDM1_VLCON_Msk = 0x20
	// Bit VLCON.
	SLCDC_LCDM1_VLCON = 0x20
	// Stops voltage boost circuit or capacitor split circuit operation
	SLCDC_LCDM1_VLCON_0 = 0x0
	// Enables voltage boost circuit or capacitor split circuit operation
	SLCDC_LCDM1_VLCON_1 = 0x1
	// Position of BLON field.
	SLCDC_LCDM1_BLON_Pos = 0x4
	// Bit mask of BLON field.
	SLCDC_LCDM1_BLON_Msk = 0x10
	// Bit BLON.
	SLCDC_LCDM1_BLON = 0x10
	// Displaying an A-pattern area data (lower four bits of LCD display data register)(LCDSEL=0)/Displaying a B-pattern area data (higher four bits of LCD display data register)(LCDSEL=1)
	SLCDC_LCDM1_BLON_0 = 0x0
	// Alternately displaying A-pattern and B-pattern area data (blinking display corresponding to the constant-period interrupt (INTRTC) timing of the real-time clock (RTC))
	SLCDC_LCDM1_BLON_1 = 0x1
	// Position of LCDSEL field.
	SLCDC_LCDM1_LCDSEL_Pos = 0x3
	// Bit mask of LCDSEL field.
	SLCDC_LCDM1_LCDSEL_Msk = 0x8
	// Bit LCDSEL.
	SLCDC_LCDM1_LCDSEL = 0x8
	// Displaying an A-pattern area data (lower four bits of LCD display data register)(BLON=0)/Alternately displaying A-pattern and B-pattern area data (blinking display corresponding to the constant-period interrupt (INTRTC) timing of the real-time clock (RTC))(BLON=1)
	SLCDC_LCDM1_LCDSEL_0 = 0x0
	// Displaying a B-pattern area data (higher four bits of LCD display data register)(BLON=0)/Alternately displaying A-pattern and B-pattern area data (blinking display corresponding to the constant-period interrupt (INTRTC) timing of the real-time clock (RTC))(BLON=1)
	SLCDC_LCDM1_LCDSEL_1 = 0x1
	// Position of Reserved field.
	SLCDC_LCDM1_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SLCDC_LCDM1_Reserved_Msk = 0x6
	// Position of LCDVLM field.
	SLCDC_LCDM1_LCDVLM_Pos = 0x0
	// Bit mask of LCDVLM field.
	SLCDC_LCDM1_LCDVLM_Msk = 0x1
	// Bit LCDVLM.
	SLCDC_LCDM1_LCDVLM = 0x1
	// Set when VDD >= 2.7 V
	SLCDC_LCDM1_LCDVLM_0 = 0x0
	// Set when VDD <= 4.2 V
	SLCDC_LCDM1_LCDVLM_1 = 0x1

	// LCDC0: LCD Clock Control Register 0
	// Position of LCDC field.
	SLCDC_LCDC0_LCDC_Pos = 0x0
	// Bit mask of LCDC field.
	SLCDC_LCDC0_LCDC_Msk = 0x3f
	// (Sub clock)/22 or (LOCO clock)/22
	SLCDC_LCDC0_LCDC_000001 = 0x1
	// (Sub clock)/23 or (LOCO clock)/23
	SLCDC_LCDC0_LCDC_000010 = 0x2
	// (Sub clock)/24 or (LOCO clock)/24
	SLCDC_LCDC0_LCDC_000011 = 0x3
	// (Sub clock)/25 or (LOCO clock)/25
	SLCDC_LCDC0_LCDC_000100 = 0x4
	// (Sub clock)/26 or (LOCO clock)/26
	SLCDC_LCDC0_LCDC_000101 = 0x5
	// (Sub clock)/27 or (LOCO clock)/27
	SLCDC_LCDC0_LCDC_000110 = 0x6
	// (Sub clock)/28 or (LOCO clock)/28
	SLCDC_LCDC0_LCDC_000111 = 0x7
	// (Sub clock)/29 or (LOCO clock)/29
	SLCDC_LCDC0_LCDC_001000 = 0x8
	// (Sub clock)/210 or (LOCO clock)/210
	SLCDC_LCDC0_LCDC_001001 = 0x9
	// (Main clock)/28 or (HOCO clock)/28
	SLCDC_LCDC0_LCDC_010001 = 0x11
	// (Main clock)/29 or (HOCO clock)/29
	SLCDC_LCDC0_LCDC_010010 = 0x12
	// (Main clock)/210 or (HOCO clock)/210
	SLCDC_LCDC0_LCDC_010011 = 0x13
	// (Main clock)/211 or (HOCO clock)/211
	SLCDC_LCDC0_LCDC_010100 = 0x14
	// (Main clock)/212 or (HOCO clock)/212
	SLCDC_LCDC0_LCDC_010101 = 0x15
	// (Main clock)/213 or (HOCO clock)/213
	SLCDC_LCDC0_LCDC_010110 = 0x16
	// (Main clock)/214 or (HOCO clock)/214
	SLCDC_LCDC0_LCDC_010111 = 0x17
	// (Main clock)/215 or (HOCO clock)/215
	SLCDC_LCDC0_LCDC_011000 = 0x18
	// (Main clock)/216 or (HOCO clock)/216
	SLCDC_LCDC0_LCDC_011001 = 0x19
	// (Main clock)/217 or (HOCO clock)/217
	SLCDC_LCDC0_LCDC_011010 = 0x1a
	// (Main clock)/218 or (HOCO clock)/218
	SLCDC_LCDC0_LCDC_011011 = 0x1b
	// (Main clock)/219 or (HOCO clock)/219
	SLCDC_LCDC0_LCDC_101011 = 0x2b

	// VLCD: LCD Boost Level Control Register
	// Position of VLCD field.
	SLCDC_VLCD_VLCD_Pos = 0x0
	// Bit mask of VLCD field.
	SLCDC_VLCD_VLCD_Msk = 0x1f
	// Reference voltageselection(contrast adjustment): 1.00 V (default) VL4 voltage: 3.00 V(1/3 bias method)/4.00 V(1/4 bias method)
	SLCDC_VLCD_VLCD_00100 = 0x4
	// Reference voltageselection(contrast adjustment): 1.05 V VL4 voltage: 3.15 V(1/3 bias method)/4.20 V(1/4 bias method)
	SLCDC_VLCD_VLCD_00101 = 0x5
	// Reference voltageselection(contrast adjustment): 1.10 V VL4 voltage: 3.30 V(1/3 bias method)/4.40 V(1/4 bias method)
	SLCDC_VLCD_VLCD_00110 = 0x6
	// Reference voltageselection(contrast adjustment): 1.15 V VL4 voltage: 3.45 V(1/3 bias method)/4.60 V(1/4 bias method)
	SLCDC_VLCD_VLCD_00111 = 0x7
	// Reference voltageselection(contrast adjustment): 1.20 V VL4 voltage: 3.60 V(1/3 bias method)/4.80 V(1/4 bias method)
	SLCDC_VLCD_VLCD_01000 = 0x8
	// Reference voltageselection(contrast adjustment): 1.25 V VL4 voltage: 3.75 V(1/3 bias method)/5.00 V(1/4 bias method)
	SLCDC_VLCD_VLCD_01001 = 0x9
	// Reference voltageselection(contrast adjustment): 1.30 V VL4 voltage: 3.90 V(1/3 bias method)/5.20 V(1/4 bias method)
	SLCDC_VLCD_VLCD_01010 = 0xa
	// Reference voltageselection(contrast adjustment): 1.35 V VL4 voltage: 4.05 V(1/3 bias method)/Setting prohibited(1/4 bias method)
	SLCDC_VLCD_VLCD_01011 = 0xb
	// Reference voltageselection(contrast adjustment): 1.40 V VL4 voltage: 4.20 V(1/3 bias method)/Setting prohibited(1/4 bias method)
	SLCDC_VLCD_VLCD_01100 = 0xc
	// Reference voltageselection(contrast adjustment): 1.45 V VL4 voltage: 4.35 V(1/3 bias method)/Setting prohibited(1/4 bias method)
	SLCDC_VLCD_VLCD_01101 = 0xd
	// Reference voltageselection(contrast adjustment): 1.50 V VL4 voltage: 4.50 V(1/3 bias method)/Setting prohibited(1/4 bias method)
	SLCDC_VLCD_VLCD_01110 = 0xe
	// Reference voltageselection(contrast adjustment): 1.55 V VL4 voltage: 4.65 V(1/3 bias method)/Setting prohibited(1/4 bias method)
	SLCDC_VLCD_VLCD_01111 = 0xf
	// Reference voltageselection(contrast adjustment): 1.60 V VL4 voltage: 4.80 V(1/3 bias method)/Setting prohibited(1/4 bias method)
	SLCDC_VLCD_VLCD_10000 = 0x10
	// Reference voltageselection(contrast adjustment): 1.65 V VL4 voltage: 4.95 V(1/3 bias method)/Setting prohibited(1/4 bias method)
	SLCDC_VLCD_VLCD_10001 = 0x11
	// Reference voltageselection(contrast adjustment): 1.70 V VL4 voltage: 5.10 V(1/3 bias method)/Setting prohibited(1/4 bias method)
	SLCDC_VLCD_VLCD_10010 = 0x12
	// Reference voltageselection(contrast adjustment): 1.75 V VL4 voltage: 5.25 V(1/3 bias method)/Setting prohibited(1/4 bias method)
	SLCDC_VLCD_VLCD_10011 = 0x13

	// SEG0: LCD Display Data Register %s
	// Position of SEG field.
	SLCDC_SEG_SEG_Pos = 0x0
	// Bit mask of SEG field.
	SLCDC_SEG_SEG_Msk = 0xff
)

// Constants for OPAMP: OperationalAmplifier
const (
	// AMPMC: Operational amplifier mode control register
	// Position of AMPSP field.
	OPAMP_AMPMC_AMPSP_Pos = 0x7
	// Bit mask of AMPSP field.
	OPAMP_AMPMC_AMPSP_Msk = 0x80
	// Bit AMPSP.
	OPAMP_AMPMC_AMPSP = 0x80
	// Low-power mode (low-speed).
	OPAMP_AMPMC_AMPSP_0 = 0x0
	// High-speed mode.
	OPAMP_AMPMC_AMPSP_1 = 0x1
	// Position of Reserved field.
	OPAMP_AMPMC_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	OPAMP_AMPMC_Reserved_Msk = 0x70
	// Position of AMPPC3 field.
	OPAMP_AMPMC_AMPPC3_Pos = 0x3
	// Bit mask of AMPPC3 field.
	OPAMP_AMPMC_AMPPC3_Msk = 0x8
	// Bit AMPPC3.
	OPAMP_AMPMC_AMPPC3 = 0x8
	// Precharging is stopped.
	OPAMP_AMPMC_AMPPC3_0 = 0x0
	// Precharging is enabled.
	OPAMP_AMPMC_AMPPC3_1 = 0x1
	// Position of AMPPC2 field.
	OPAMP_AMPMC_AMPPC2_Pos = 0x2
	// Bit mask of AMPPC2 field.
	OPAMP_AMPMC_AMPPC2_Msk = 0x4
	// Bit AMPPC2.
	OPAMP_AMPMC_AMPPC2 = 0x4
	// Precharging is stopped.
	OPAMP_AMPMC_AMPPC2_0 = 0x0
	// Precharging is enabled.
	OPAMP_AMPMC_AMPPC2_1 = 0x1
	// Position of AMPPC1 field.
	OPAMP_AMPMC_AMPPC1_Pos = 0x1
	// Bit mask of AMPPC1 field.
	OPAMP_AMPMC_AMPPC1_Msk = 0x2
	// Bit AMPPC1.
	OPAMP_AMPMC_AMPPC1 = 0x2
	// Precharging is stopped.
	OPAMP_AMPMC_AMPPC1_0 = 0x0
	// Precharging is enabled.
	OPAMP_AMPMC_AMPPC1_1 = 0x1
	// Position of AMPPC0 field.
	OPAMP_AMPMC_AMPPC0_Pos = 0x0
	// Bit mask of AMPPC0 field.
	OPAMP_AMPMC_AMPPC0_Msk = 0x1
	// Bit AMPPC0.
	OPAMP_AMPMC_AMPPC0 = 0x1
	// Precharging is stopped.
	OPAMP_AMPMC_AMPPC0_0 = 0x0
	// Precharging is enabled.
	OPAMP_AMPMC_AMPPC0_1 = 0x1

	// AMPTRM: Operational amplifier trigger mode control register
	// Position of AMPTRM31 field.
	OPAMP_AMPTRM_AMPTRM31_Pos = 0x7
	// Bit mask of AMPTRM31 field.
	OPAMP_AMPTRM_AMPTRM31_Msk = 0x80
	// Bit AMPTRM31.
	OPAMP_AMPTRM_AMPTRM31 = 0x80
	// Software trigger mode(AMPTRM30=0)/An activation trigger mode(AMPTRM30=1).
	OPAMP_AMPTRM_AMPTRM31_0 = 0x0
	// Setting prohibited(AMPTRM30=0)/An activation and A/D trigger mode(AMPTRM30=1).
	OPAMP_AMPTRM_AMPTRM31_1 = 0x1
	// Position of AMPTRM30 field.
	OPAMP_AMPTRM_AMPTRM30_Pos = 0x6
	// Bit mask of AMPTRM30 field.
	OPAMP_AMPTRM_AMPTRM30_Msk = 0x40
	// Bit AMPTRM30.
	OPAMP_AMPTRM_AMPTRM30 = 0x40
	// Software trigger mode(AMPTRM31=0)/Setting prohibited(AMPTRM31=1).
	OPAMP_AMPTRM_AMPTRM30_0 = 0x0
	// An activation trigger mode(AMPTRM31=0)/An activation and A/D trigger mode(AMPTRM31=1).
	OPAMP_AMPTRM_AMPTRM30_1 = 0x1
	// Position of AMPTRM21 field.
	OPAMP_AMPTRM_AMPTRM21_Pos = 0x5
	// Bit mask of AMPTRM21 field.
	OPAMP_AMPTRM_AMPTRM21_Msk = 0x20
	// Bit AMPTRM21.
	OPAMP_AMPTRM_AMPTRM21 = 0x20
	// Software trigger mode(AMPTRM20=0)/An activation trigger mode(AMPTRM20=1).
	OPAMP_AMPTRM_AMPTRM21_0 = 0x0
	// Setting prohibited(AMPTRM20=0)/An activation and A/D trigger mode(AMPTRM20=1).
	OPAMP_AMPTRM_AMPTRM21_1 = 0x1
	// Position of AMPTRM20 field.
	OPAMP_AMPTRM_AMPTRM20_Pos = 0x4
	// Bit mask of AMPTRM20 field.
	OPAMP_AMPTRM_AMPTRM20_Msk = 0x10
	// Bit AMPTRM20.
	OPAMP_AMPTRM_AMPTRM20 = 0x10
	// Software trigger mode(AMPTRM21=0)/Setting prohibited(AMPTRM21=1).
	OPAMP_AMPTRM_AMPTRM20_0 = 0x0
	// An activation trigger mode(AMPTRM21=0)/An activation and A/D trigger mode(AMPTRM21=1).
	OPAMP_AMPTRM_AMPTRM20_1 = 0x1
	// Position of AMPTRM11 field.
	OPAMP_AMPTRM_AMPTRM11_Pos = 0x3
	// Bit mask of AMPTRM11 field.
	OPAMP_AMPTRM_AMPTRM11_Msk = 0x8
	// Bit AMPTRM11.
	OPAMP_AMPTRM_AMPTRM11 = 0x8
	// Software trigger mode(AMPTRM10=0)/An activation trigger mode(AMPTRM10=1).
	OPAMP_AMPTRM_AMPTRM11_0 = 0x0
	// Setting prohibited(AMPTRM10=0)/An activation and A/D trigger mode(AMPTRM10=1).
	OPAMP_AMPTRM_AMPTRM11_1 = 0x1
	// Position of AMPTRM10 field.
	OPAMP_AMPTRM_AMPTRM10_Pos = 0x2
	// Bit mask of AMPTRM10 field.
	OPAMP_AMPTRM_AMPTRM10_Msk = 0x4
	// Bit AMPTRM10.
	OPAMP_AMPTRM_AMPTRM10 = 0x4
	// Software trigger mode(AMPTRM11=0)/Setting prohibited(AMPTRM11=1).
	OPAMP_AMPTRM_AMPTRM10_0 = 0x0
	// An activation trigger mode(AMPTRM11=0)/An activation and A/D trigger mode(AMPTRM11=1).
	OPAMP_AMPTRM_AMPTRM10_1 = 0x1
	// Position of AMPTRM01 field.
	OPAMP_AMPTRM_AMPTRM01_Pos = 0x1
	// Bit mask of AMPTRM01 field.
	OPAMP_AMPTRM_AMPTRM01_Msk = 0x2
	// Bit AMPTRM01.
	OPAMP_AMPTRM_AMPTRM01 = 0x2
	// Software trigger mode(AMPTRM00=0)/An activation trigger mode(AMPTRM00=1).
	OPAMP_AMPTRM_AMPTRM01_0 = 0x0
	// Setting prohibited(AMPTRM00=0)/An activation and A/D trigger mode(AMPTRM00=1).
	OPAMP_AMPTRM_AMPTRM01_1 = 0x1
	// Position of AMPTRM00 field.
	OPAMP_AMPTRM_AMPTRM00_Pos = 0x0
	// Bit mask of AMPTRM00 field.
	OPAMP_AMPTRM_AMPTRM00_Msk = 0x1
	// Bit AMPTRM00.
	OPAMP_AMPTRM_AMPTRM00 = 0x1
	// Software trigger mode(AMPTRM01=0)/Setting prohibited(AMPTRM01=1).
	OPAMP_AMPTRM_AMPTRM00_0 = 0x0
	// An activation trigger mode(AMPTRM01=0)/An activation and A/D trigger mode(AMPTRM01=1).
	OPAMP_AMPTRM_AMPTRM00_1 = 0x1

	// AMPTRS: Operational Amplifier Activation Trigger Select Register
	// Position of AMPTRS field.
	OPAMP_AMPTRS_AMPTRS_Pos = 0x0
	// Bit mask of AMPTRS field.
	OPAMP_AMPTRS_AMPTRS_Msk = 0x3
	// Operational amplifier 0: Operational amplifier An activation trigger 0.Operational amplifier 1: Operational amplifier An activation trigger 1.Operational amplifier 2: Operational amplifier An activation trigger 2.Operational amplifier 3: Operational amplifier An activation trigger 3
	OPAMP_AMPTRS_AMPTRS_00 = 0x0
	// Operational amplifier 0: Operational amplifier An activation trigger 0.Operational amplifier 1: Operational amplifier An activation trigger 0.Operational amplifier 2: Operational amplifier An activation trigger 1.Operational amplifier 3: Operational amplifier An activation trigger 1
	OPAMP_AMPTRS_AMPTRS_01 = 0x1
	// Setting prohibited
	OPAMP_AMPTRS_AMPTRS_10 = 0x2
	// Operational amplifier 0: Operational amplifier An activation trigger 0.Operational amplifier 1: Operational amplifier An activation trigger 0.Operational amplifier 2: Operational amplifier An activation trigger 0.Operational amplifier 3: Operational amplifier An activation trigger 0
	OPAMP_AMPTRS_AMPTRS_11 = 0x3

	// AMPC: Operational amplifier control register
	// Position of IREFE field.
	OPAMP_AMPC_IREFE_Pos = 0x7
	// Bit mask of IREFE field.
	OPAMP_AMPC_IREFE_Msk = 0x80
	// Bit IREFE.
	OPAMP_AMPC_IREFE = 0x80
	// Operational amplifier reference current circuit is stopped.
	OPAMP_AMPC_IREFE_0 = 0x0
	// Operation of operational amplifier reference current circuit is enabled.
	OPAMP_AMPC_IREFE_1 = 0x1
	// Position of Reserved field.
	OPAMP_AMPC_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	OPAMP_AMPC_Reserved_Msk = 0x70
	// Position of AMPE3 field.
	OPAMP_AMPC_AMPE3_Pos = 0x3
	// Bit mask of AMPE3 field.
	OPAMP_AMPC_AMPE3_Msk = 0x8
	// Bit AMPE3.
	OPAMP_AMPC_AMPE3 = 0x8
	// Operation amplifier is stopped.
	OPAMP_AMPC_AMPE3_0 = 0x0
	// Software trigger mode: Operation of operational amplifier is enabled Operation of the operational amplifier reference current circuit is also enabled regardless of the IREFE bit se An activation trigger mode or An activation and A/D trigger mode: Wait for An activation is enabled.
	OPAMP_AMPC_AMPE3_1 = 0x1
	// Position of AMPE2 field.
	OPAMP_AMPC_AMPE2_Pos = 0x2
	// Bit mask of AMPE2 field.
	OPAMP_AMPC_AMPE2_Msk = 0x4
	// Bit AMPE2.
	OPAMP_AMPC_AMPE2 = 0x4
	// Operation amplifier is stopped.
	OPAMP_AMPC_AMPE2_0 = 0x0
	// Software trigger mode: Operation of operational amplifier is enabled Operation of the operational amplifier reference current circuit is also enabled regardless of the IREFE bit se An activation trigger mode or An activation and A/D trigger mode: Wait for An activation is enabled.
	OPAMP_AMPC_AMPE2_1 = 0x1
	// Position of AMPE1 field.
	OPAMP_AMPC_AMPE1_Pos = 0x1
	// Bit mask of AMPE1 field.
	OPAMP_AMPC_AMPE1_Msk = 0x2
	// Bit AMPE1.
	OPAMP_AMPC_AMPE1 = 0x2
	// Operation amplifier is stopped.
	OPAMP_AMPC_AMPE1_0 = 0x0
	// Software trigger mode: Operation of operational amplifier is enabled Operation of the operational amplifier reference current circuit is also enabled regardless of the IREFE bit se An activation trigger mode or An activation and A/D trigger mode: Wait for An activation is enabled.
	OPAMP_AMPC_AMPE1_1 = 0x1
	// Position of AMPE0 field.
	OPAMP_AMPC_AMPE0_Pos = 0x0
	// Bit mask of AMPE0 field.
	OPAMP_AMPC_AMPE0_Msk = 0x1
	// Bit AMPE0.
	OPAMP_AMPC_AMPE0 = 0x1
	// Operation amplifier is stopped.
	OPAMP_AMPC_AMPE0_0 = 0x0
	// Software trigger mode: Operation of operational amplifier is enabled Operation of the operational amplifier reference current circuit is also enabled regardless of the IREFE bit se An activation trigger mode or An activation and A/D trigger mode: Wait for AGT is enabled.
	OPAMP_AMPC_AMPE0_1 = 0x1

	// AMPMON: Operational amplifier monitor register
	// Position of Reserved field.
	OPAMP_AMPMON_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	OPAMP_AMPMON_Reserved_Msk = 0xf0
	// Position of AMPMON3 field.
	OPAMP_AMPMON_AMPMON3_Pos = 0x3
	// Bit mask of AMPMON3 field.
	OPAMP_AMPMON_AMPMON3_Msk = 0x8
	// Bit AMPMON3.
	OPAMP_AMPMON_AMPMON3 = 0x8
	// Operational amplifier 3 is stopped.
	OPAMP_AMPMON_AMPMON3_0 = 0x0
	// Operational amplifier 3 is operating.
	OPAMP_AMPMON_AMPMON3_1 = 0x1
	// Position of AMPMON2 field.
	OPAMP_AMPMON_AMPMON2_Pos = 0x2
	// Bit mask of AMPMON2 field.
	OPAMP_AMPMON_AMPMON2_Msk = 0x4
	// Bit AMPMON2.
	OPAMP_AMPMON_AMPMON2 = 0x4
	// Operational amplifier 2 is stopped.
	OPAMP_AMPMON_AMPMON2_0 = 0x0
	// Operational amplifier 2 is operating.
	OPAMP_AMPMON_AMPMON2_1 = 0x1
	// Position of AMPMON1 field.
	OPAMP_AMPMON_AMPMON1_Pos = 0x1
	// Bit mask of AMPMON1 field.
	OPAMP_AMPMON_AMPMON1_Msk = 0x2
	// Bit AMPMON1.
	OPAMP_AMPMON_AMPMON1 = 0x2
	// Operational amplifier 1 is stopped.
	OPAMP_AMPMON_AMPMON1_0 = 0x0
	// Operational amplifier 1 is operating.
	OPAMP_AMPMON_AMPMON1_1 = 0x1
	// Position of AMPMON0 field.
	OPAMP_AMPMON_AMPMON0_Pos = 0x0
	// Bit mask of AMPMON0 field.
	OPAMP_AMPMON_AMPMON0_Msk = 0x1
	// Bit AMPMON0.
	OPAMP_AMPMON_AMPMON0 = 0x1
	// Operational amplifier 0 is stopped.
	OPAMP_AMPMON_AMPMON0_0 = 0x0
	// Operational amplifier 0 is operating.
	OPAMP_AMPMON_AMPMON0_1 = 0x1
)

// Constants for DTC: Data Transfer Controller
const (
	// DTCCR: DTC Control Register
	// Position of Reserved field.
	DTC_DTCCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	DTC_DTCCR_Reserved_Msk = 0xe0
	// Position of RRS field.
	DTC_DTCCR_RRS_Pos = 0x4
	// Bit mask of RRS field.
	DTC_DTCCR_RRS_Msk = 0x10
	// Bit RRS.
	DTC_DTCCR_RRS = 0x10
	// Do not skip transfer information read
	DTC_DTCCR_RRS_0 = 0x0
	// Skip transfer information read when vector numbers match
	DTC_DTCCR_RRS_1 = 0x1
	// Position of Reserved field.
	DTC_DTCCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	DTC_DTCCR_Reserved_Msk = 0x8
	// Bit Reserved.
	DTC_DTCCR_Reserved = 0x8
	// Position of Reserved field.
	DTC_DTCCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	DTC_DTCCR_Reserved_Msk = 0x7

	// DTCVBR: DTC Vector Base Register
	// Position of DTCVBR field.
	DTC_DTCVBR_DTCVBR_Pos = 0x0
	// Bit mask of DTCVBR field.
	DTC_DTCVBR_DTCVBR_Msk = 0xffffffff

	// DTCST: DTC Module Start Register
	// Position of Reserved field.
	DTC_DTCST_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	DTC_DTCST_Reserved_Msk = 0xfe
	// Position of DTCST field.
	DTC_DTCST_DTCST_Pos = 0x0
	// Bit mask of DTCST field.
	DTC_DTCST_DTCST_Msk = 0x1
	// Bit DTCST.
	DTC_DTCST_DTCST = 0x1
	// DTC module stop
	DTC_DTCST_DTCST_0 = 0x0
	// DTC module start
	DTC_DTCST_DTCST_1 = 0x1

	// DTCSTS: DTC Status Register
	// Position of ACT field.
	DTC_DTCSTS_ACT_Pos = 0xf
	// Bit mask of ACT field.
	DTC_DTCSTS_ACT_Msk = 0x8000
	// Bit ACT.
	DTC_DTCSTS_ACT = 0x8000
	// DTC transfer operation is not in progress.
	DTC_DTCSTS_ACT_0 = 0x0
	// DTC transfer operation is in progress.
	DTC_DTCSTS_ACT_1 = 0x1
	// Position of Reserved field.
	DTC_DTCSTS_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	DTC_DTCSTS_Reserved_Msk = 0x7f00
	// Position of VECN field.
	DTC_DTCSTS_VECN_Pos = 0x0
	// Bit mask of VECN field.
	DTC_DTCSTS_VECN_Msk = 0xff
)

// Constants for KINT: Key Interrupt Function
const (
	// KRCTL: KEY Return Control Register
	// Position of KRMD field.
	KINT_KRCTL_KRMD_Pos = 0x7
	// Bit mask of KRMD field.
	KINT_KRCTL_KRMD_Msk = 0x80
	// Bit KRMD.
	KINT_KRCTL_KRMD = 0x80
	// Do not use key interrupt flags
	KINT_KRCTL_KRMD_0 = 0x0
	// Use key interrupt flags.
	KINT_KRCTL_KRMD_1 = 0x1
	// Position of Reserved field.
	KINT_KRCTL_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	KINT_KRCTL_Reserved_Msk = 0x7e
	// Position of KREG field.
	KINT_KRCTL_KREG_Pos = 0x0
	// Bit mask of KREG field.
	KINT_KRCTL_KREG_Msk = 0x1
	// Bit KREG.
	KINT_KRCTL_KREG = 0x1
	// Falling edge
	KINT_KRCTL_KREG_0 = 0x0
	// Rising edge
	KINT_KRCTL_KREG_1 = 0x1

	// KRF: KEY Return Flag Register
	// Position of KRF7 field.
	KINT_KRF_KRF7_Pos = 0x7
	// Bit mask of KRF7 field.
	KINT_KRF_KRF7_Msk = 0x80
	// Bit KRF7.
	KINT_KRF_KRF7 = 0x80
	// No interrupt detected
	KINT_KRF_KRF7_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF7_1 = 0x1
	// Position of KRF6 field.
	KINT_KRF_KRF6_Pos = 0x6
	// Bit mask of KRF6 field.
	KINT_KRF_KRF6_Msk = 0x40
	// Bit KRF6.
	KINT_KRF_KRF6 = 0x40
	// No interrupt detected
	KINT_KRF_KRF6_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF6_1 = 0x1
	// Position of KRF5 field.
	KINT_KRF_KRF5_Pos = 0x5
	// Bit mask of KRF5 field.
	KINT_KRF_KRF5_Msk = 0x20
	// Bit KRF5.
	KINT_KRF_KRF5 = 0x20
	// No interrupt detected
	KINT_KRF_KRF5_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF5_1 = 0x1
	// Position of KRF4 field.
	KINT_KRF_KRF4_Pos = 0x4
	// Bit mask of KRF4 field.
	KINT_KRF_KRF4_Msk = 0x10
	// Bit KRF4.
	KINT_KRF_KRF4 = 0x10
	// No interrupt detected
	KINT_KRF_KRF4_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF4_1 = 0x1
	// Position of KRF3 field.
	KINT_KRF_KRF3_Pos = 0x3
	// Bit mask of KRF3 field.
	KINT_KRF_KRF3_Msk = 0x8
	// Bit KRF3.
	KINT_KRF_KRF3 = 0x8
	// No interrupt detected
	KINT_KRF_KRF3_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF3_1 = 0x1
	// Position of KRF2 field.
	KINT_KRF_KRF2_Pos = 0x2
	// Bit mask of KRF2 field.
	KINT_KRF_KRF2_Msk = 0x4
	// Bit KRF2.
	KINT_KRF_KRF2 = 0x4
	// No interrupt detected
	KINT_KRF_KRF2_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF2_1 = 0x1
	// Position of KRF1 field.
	KINT_KRF_KRF1_Pos = 0x1
	// Bit mask of KRF1 field.
	KINT_KRF_KRF1_Msk = 0x2
	// Bit KRF1.
	KINT_KRF_KRF1 = 0x2
	// No interrupt detected
	KINT_KRF_KRF1_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF1_1 = 0x1
	// Position of KRF0 field.
	KINT_KRF_KRF0_Pos = 0x0
	// Bit mask of KRF0 field.
	KINT_KRF_KRF0_Msk = 0x1
	// Bit KRF0.
	KINT_KRF_KRF0 = 0x1
	// No interrupt detected
	KINT_KRF_KRF0_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF0_1 = 0x1

	// KRM: KEY Return Mode Register
	// Position of KRM7 field.
	KINT_KRM_KRM7_Pos = 0x7
	// Bit mask of KRM7 field.
	KINT_KRM_KRM7_Msk = 0x80
	// Bit KRM7.
	KINT_KRM_KRM7 = 0x80
	// Does not detect key interrupt signal
	KINT_KRM_KRM7_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM7_1 = 0x1
	// Position of KRM6 field.
	KINT_KRM_KRM6_Pos = 0x6
	// Bit mask of KRM6 field.
	KINT_KRM_KRM6_Msk = 0x40
	// Bit KRM6.
	KINT_KRM_KRM6 = 0x40
	// Does not detect key interrupt signal
	KINT_KRM_KRM6_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM6_1 = 0x1
	// Position of KRM5 field.
	KINT_KRM_KRM5_Pos = 0x5
	// Bit mask of KRM5 field.
	KINT_KRM_KRM5_Msk = 0x20
	// Bit KRM5.
	KINT_KRM_KRM5 = 0x20
	// Does not detect key interrupt signal
	KINT_KRM_KRM5_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM5_1 = 0x1
	// Position of KRM4 field.
	KINT_KRM_KRM4_Pos = 0x4
	// Bit mask of KRM4 field.
	KINT_KRM_KRM4_Msk = 0x10
	// Bit KRM4.
	KINT_KRM_KRM4 = 0x10
	// Does not detect key interrupt signal
	KINT_KRM_KRM4_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM4_1 = 0x1
	// Position of KRM3 field.
	KINT_KRM_KRM3_Pos = 0x3
	// Bit mask of KRM3 field.
	KINT_KRM_KRM3_Msk = 0x8
	// Bit KRM3.
	KINT_KRM_KRM3 = 0x8
	// Does not detect key interrupt signal
	KINT_KRM_KRM3_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM3_1 = 0x1
	// Position of KRM2 field.
	KINT_KRM_KRM2_Pos = 0x2
	// Bit mask of KRM2 field.
	KINT_KRM_KRM2_Msk = 0x4
	// Bit KRM2.
	KINT_KRM_KRM2 = 0x4
	// Does not detect key interrupt signal
	KINT_KRM_KRM2_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM2_1 = 0x1
	// Position of KRM1 field.
	KINT_KRM_KRM1_Pos = 0x1
	// Bit mask of KRM1 field.
	KINT_KRM_KRM1_Msk = 0x2
	// Bit KRM1.
	KINT_KRM_KRM1 = 0x2
	// Does not detect key interrupt signal
	KINT_KRM_KRM1_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM1_1 = 0x1
	// Position of KRM0 field.
	KINT_KRM_KRM0_Pos = 0x0
	// Bit mask of KRM0 field.
	KINT_KRM_KRM0_Msk = 0x1
	// Bit KRM0.
	KINT_KRM_KRM0 = 0x1
	// Does not detect key interrupt signal
	KINT_KRM_KRM0_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM0_1 = 0x1
)
