// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from R7FA6E10F.svd, see https://github.com/cmsis-svd/cmsis-svd-data/tree/master/data/Renesas

//go:build renesas && r7fa6e10f

/*
// Arm Cortex-M33 based Microcontroller RA6E1 group
*/
//     This software is supplied by Renesas Electronics Corporation and is only intended for
//     use with Renesas products. No other uses are authorized. This software is owned by
//     Renesas Electronics Corporation and is protected under all applicable laws, including
//     copyright laws.
//
//     THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
//     THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO
//     WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
//     ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM EXTENT PERMITTED NOT
//     PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED
//     COMPANIES SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
//     DAMAGES FOR ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
//     BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
//
//     Renesas reserves the right, without notice, to make changes to this software and to
//     discontinue the availability of this software. By using this software, you agree to
//     the additional terms and conditions found by accessing the following link:
//     http://www.renesas.com/disclaimer
//     \n
package renesas

import (
	"github.com/goplus/emb/runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "R7FA6E10F"
	CPU          = "CM33"
	FPUPresent   = true
	NVICPrioBits = 4
)

// Interrupt numbers.
const (
	// Interrupt Controller
	IRQ_IEL0 = 0

	// Interrupt Controller
	IRQ_IEL1 = 1

	// Interrupt Controller
	IRQ_IEL2 = 2

	// Interrupt Controller
	IRQ_IEL3 = 3

	// Interrupt Controller
	IRQ_IEL4 = 4

	// Interrupt Controller
	IRQ_IEL5 = 5

	// Interrupt Controller
	IRQ_IEL6 = 6

	// Interrupt Controller
	IRQ_IEL7 = 7

	// Interrupt Controller
	IRQ_IEL8 = 8

	// Interrupt Controller
	IRQ_IEL9 = 9

	// Interrupt Controller
	IRQ_IEL10 = 10

	// Interrupt Controller
	IRQ_IEL11 = 11

	// Interrupt Controller
	IRQ_IEL12 = 12

	// Interrupt Controller
	IRQ_IEL13 = 13

	// Interrupt Controller
	IRQ_IEL14 = 14

	// Interrupt Controller
	IRQ_IEL15 = 15

	// Interrupt Controller
	IRQ_IEL16 = 16

	// Interrupt Controller
	IRQ_IEL17 = 17

	// Interrupt Controller
	IRQ_IEL18 = 18

	// Interrupt Controller
	IRQ_IEL19 = 19

	// Interrupt Controller
	IRQ_IEL20 = 20

	// Interrupt Controller
	IRQ_IEL21 = 21

	// Interrupt Controller
	IRQ_IEL22 = 22

	// Interrupt Controller
	IRQ_IEL23 = 23

	// Interrupt Controller
	IRQ_IEL24 = 24

	// Interrupt Controller
	IRQ_IEL25 = 25

	// Interrupt Controller
	IRQ_IEL26 = 26

	// Interrupt Controller
	IRQ_IEL27 = 27

	// Interrupt Controller
	IRQ_IEL28 = 28

	// Interrupt Controller
	IRQ_IEL29 = 29

	// Interrupt Controller
	IRQ_IEL30 = 30

	// Interrupt Controller
	IRQ_IEL31 = 31

	// Interrupt Controller
	IRQ_IEL32 = 32

	// Interrupt Controller
	IRQ_IEL33 = 33

	// Interrupt Controller
	IRQ_IEL34 = 34

	// Interrupt Controller
	IRQ_IEL35 = 35

	// Interrupt Controller
	IRQ_IEL36 = 36

	// Interrupt Controller
	IRQ_IEL37 = 37

	// Interrupt Controller
	IRQ_IEL38 = 38

	// Interrupt Controller
	IRQ_IEL39 = 39

	// Interrupt Controller
	IRQ_IEL40 = 40

	// Interrupt Controller
	IRQ_IEL41 = 41

	// Interrupt Controller
	IRQ_IEL42 = 42

	// Interrupt Controller
	IRQ_IEL43 = 43

	// Interrupt Controller
	IRQ_IEL44 = 44

	// Interrupt Controller
	IRQ_IEL45 = 45

	// Interrupt Controller
	IRQ_IEL46 = 46

	// Interrupt Controller
	IRQ_IEL47 = 47

	// Interrupt Controller
	IRQ_IEL48 = 48

	// Interrupt Controller
	IRQ_IEL49 = 49

	// Interrupt Controller
	IRQ_IEL50 = 50

	// Interrupt Controller
	IRQ_IEL51 = 51

	// Interrupt Controller
	IRQ_IEL52 = 52

	// Interrupt Controller
	IRQ_IEL53 = 53

	// Interrupt Controller
	IRQ_IEL54 = 54

	// Interrupt Controller
	IRQ_IEL55 = 55

	// Interrupt Controller
	IRQ_IEL56 = 56

	// Interrupt Controller
	IRQ_IEL57 = 57

	// Interrupt Controller
	IRQ_IEL58 = 58

	// Interrupt Controller
	IRQ_IEL59 = 59

	// Interrupt Controller
	IRQ_IEL60 = 60

	// Interrupt Controller
	IRQ_IEL61 = 61

	// Interrupt Controller
	IRQ_IEL62 = 62

	// Interrupt Controller
	IRQ_IEL63 = 63

	// Interrupt Controller
	IRQ_IEL64 = 64

	// Interrupt Controller
	IRQ_IEL65 = 65

	// Interrupt Controller
	IRQ_IEL66 = 66

	// Interrupt Controller
	IRQ_IEL67 = 67

	// Interrupt Controller
	IRQ_IEL68 = 68

	// Interrupt Controller
	IRQ_IEL69 = 69

	// Interrupt Controller
	IRQ_IEL70 = 70

	// Interrupt Controller
	IRQ_IEL71 = 71

	// Interrupt Controller
	IRQ_IEL72 = 72

	// Interrupt Controller
	IRQ_IEL73 = 73

	// Interrupt Controller
	IRQ_IEL74 = 74

	// Interrupt Controller
	IRQ_IEL75 = 75

	// Interrupt Controller
	IRQ_IEL76 = 76

	// Interrupt Controller
	IRQ_IEL77 = 77

	// Interrupt Controller
	IRQ_IEL78 = 78

	// Interrupt Controller
	IRQ_IEL79 = 79

	// Interrupt Controller
	IRQ_IEL80 = 80

	// Interrupt Controller
	IRQ_IEL81 = 81

	// Interrupt Controller
	IRQ_IEL82 = 82

	// Interrupt Controller
	IRQ_IEL83 = 83

	// Interrupt Controller
	IRQ_IEL84 = 84

	// Interrupt Controller
	IRQ_IEL85 = 85

	// Interrupt Controller
	IRQ_IEL86 = 86

	// Interrupt Controller
	IRQ_IEL87 = 87

	// Interrupt Controller
	IRQ_IEL88 = 88

	// Interrupt Controller
	IRQ_IEL89 = 89

	// Interrupt Controller
	IRQ_IEL90 = 90

	// Interrupt Controller
	IRQ_IEL91 = 91

	// Interrupt Controller
	IRQ_IEL92 = 92

	// Interrupt Controller
	IRQ_IEL93 = 93

	// Interrupt Controller
	IRQ_IEL94 = 94

	// Interrupt Controller
	IRQ_IEL95 = 95

	// Highest interrupt number on this device.
	IRQ_max = 95
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
// NOTE(zzy): runtime/interrupt.callHandlers is not yet implemented in LLGO
// Original linkname: //go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int) {
	// TODO: implement interrupt handler dispatch mechanism
}

//export IEL0_IRQHandler
func interruptIEL0() {
	callHandlers(IRQ_IEL0)
}

//export IEL1_IRQHandler
func interruptIEL1() {
	callHandlers(IRQ_IEL1)
}

//export IEL2_IRQHandler
func interruptIEL2() {
	callHandlers(IRQ_IEL2)
}

//export IEL3_IRQHandler
func interruptIEL3() {
	callHandlers(IRQ_IEL3)
}

//export IEL4_IRQHandler
func interruptIEL4() {
	callHandlers(IRQ_IEL4)
}

//export IEL5_IRQHandler
func interruptIEL5() {
	callHandlers(IRQ_IEL5)
}

//export IEL6_IRQHandler
func interruptIEL6() {
	callHandlers(IRQ_IEL6)
}

//export IEL7_IRQHandler
func interruptIEL7() {
	callHandlers(IRQ_IEL7)
}

//export IEL8_IRQHandler
func interruptIEL8() {
	callHandlers(IRQ_IEL8)
}

//export IEL9_IRQHandler
func interruptIEL9() {
	callHandlers(IRQ_IEL9)
}

//export IEL10_IRQHandler
func interruptIEL10() {
	callHandlers(IRQ_IEL10)
}

//export IEL11_IRQHandler
func interruptIEL11() {
	callHandlers(IRQ_IEL11)
}

//export IEL12_IRQHandler
func interruptIEL12() {
	callHandlers(IRQ_IEL12)
}

//export IEL13_IRQHandler
func interruptIEL13() {
	callHandlers(IRQ_IEL13)
}

//export IEL14_IRQHandler
func interruptIEL14() {
	callHandlers(IRQ_IEL14)
}

//export IEL15_IRQHandler
func interruptIEL15() {
	callHandlers(IRQ_IEL15)
}

//export IEL16_IRQHandler
func interruptIEL16() {
	callHandlers(IRQ_IEL16)
}

//export IEL17_IRQHandler
func interruptIEL17() {
	callHandlers(IRQ_IEL17)
}

//export IEL18_IRQHandler
func interruptIEL18() {
	callHandlers(IRQ_IEL18)
}

//export IEL19_IRQHandler
func interruptIEL19() {
	callHandlers(IRQ_IEL19)
}

//export IEL20_IRQHandler
func interruptIEL20() {
	callHandlers(IRQ_IEL20)
}

//export IEL21_IRQHandler
func interruptIEL21() {
	callHandlers(IRQ_IEL21)
}

//export IEL22_IRQHandler
func interruptIEL22() {
	callHandlers(IRQ_IEL22)
}

//export IEL23_IRQHandler
func interruptIEL23() {
	callHandlers(IRQ_IEL23)
}

//export IEL24_IRQHandler
func interruptIEL24() {
	callHandlers(IRQ_IEL24)
}

//export IEL25_IRQHandler
func interruptIEL25() {
	callHandlers(IRQ_IEL25)
}

//export IEL26_IRQHandler
func interruptIEL26() {
	callHandlers(IRQ_IEL26)
}

//export IEL27_IRQHandler
func interruptIEL27() {
	callHandlers(IRQ_IEL27)
}

//export IEL28_IRQHandler
func interruptIEL28() {
	callHandlers(IRQ_IEL28)
}

//export IEL29_IRQHandler
func interruptIEL29() {
	callHandlers(IRQ_IEL29)
}

//export IEL30_IRQHandler
func interruptIEL30() {
	callHandlers(IRQ_IEL30)
}

//export IEL31_IRQHandler
func interruptIEL31() {
	callHandlers(IRQ_IEL31)
}

//export IEL32_IRQHandler
func interruptIEL32() {
	callHandlers(IRQ_IEL32)
}

//export IEL33_IRQHandler
func interruptIEL33() {
	callHandlers(IRQ_IEL33)
}

//export IEL34_IRQHandler
func interruptIEL34() {
	callHandlers(IRQ_IEL34)
}

//export IEL35_IRQHandler
func interruptIEL35() {
	callHandlers(IRQ_IEL35)
}

//export IEL36_IRQHandler
func interruptIEL36() {
	callHandlers(IRQ_IEL36)
}

//export IEL37_IRQHandler
func interruptIEL37() {
	callHandlers(IRQ_IEL37)
}

//export IEL38_IRQHandler
func interruptIEL38() {
	callHandlers(IRQ_IEL38)
}

//export IEL39_IRQHandler
func interruptIEL39() {
	callHandlers(IRQ_IEL39)
}

//export IEL40_IRQHandler
func interruptIEL40() {
	callHandlers(IRQ_IEL40)
}

//export IEL41_IRQHandler
func interruptIEL41() {
	callHandlers(IRQ_IEL41)
}

//export IEL42_IRQHandler
func interruptIEL42() {
	callHandlers(IRQ_IEL42)
}

//export IEL43_IRQHandler
func interruptIEL43() {
	callHandlers(IRQ_IEL43)
}

//export IEL44_IRQHandler
func interruptIEL44() {
	callHandlers(IRQ_IEL44)
}

//export IEL45_IRQHandler
func interruptIEL45() {
	callHandlers(IRQ_IEL45)
}

//export IEL46_IRQHandler
func interruptIEL46() {
	callHandlers(IRQ_IEL46)
}

//export IEL47_IRQHandler
func interruptIEL47() {
	callHandlers(IRQ_IEL47)
}

//export IEL48_IRQHandler
func interruptIEL48() {
	callHandlers(IRQ_IEL48)
}

//export IEL49_IRQHandler
func interruptIEL49() {
	callHandlers(IRQ_IEL49)
}

//export IEL50_IRQHandler
func interruptIEL50() {
	callHandlers(IRQ_IEL50)
}

//export IEL51_IRQHandler
func interruptIEL51() {
	callHandlers(IRQ_IEL51)
}

//export IEL52_IRQHandler
func interruptIEL52() {
	callHandlers(IRQ_IEL52)
}

//export IEL53_IRQHandler
func interruptIEL53() {
	callHandlers(IRQ_IEL53)
}

//export IEL54_IRQHandler
func interruptIEL54() {
	callHandlers(IRQ_IEL54)
}

//export IEL55_IRQHandler
func interruptIEL55() {
	callHandlers(IRQ_IEL55)
}

//export IEL56_IRQHandler
func interruptIEL56() {
	callHandlers(IRQ_IEL56)
}

//export IEL57_IRQHandler
func interruptIEL57() {
	callHandlers(IRQ_IEL57)
}

//export IEL58_IRQHandler
func interruptIEL58() {
	callHandlers(IRQ_IEL58)
}

//export IEL59_IRQHandler
func interruptIEL59() {
	callHandlers(IRQ_IEL59)
}

//export IEL60_IRQHandler
func interruptIEL60() {
	callHandlers(IRQ_IEL60)
}

//export IEL61_IRQHandler
func interruptIEL61() {
	callHandlers(IRQ_IEL61)
}

//export IEL62_IRQHandler
func interruptIEL62() {
	callHandlers(IRQ_IEL62)
}

//export IEL63_IRQHandler
func interruptIEL63() {
	callHandlers(IRQ_IEL63)
}

//export IEL64_IRQHandler
func interruptIEL64() {
	callHandlers(IRQ_IEL64)
}

//export IEL65_IRQHandler
func interruptIEL65() {
	callHandlers(IRQ_IEL65)
}

//export IEL66_IRQHandler
func interruptIEL66() {
	callHandlers(IRQ_IEL66)
}

//export IEL67_IRQHandler
func interruptIEL67() {
	callHandlers(IRQ_IEL67)
}

//export IEL68_IRQHandler
func interruptIEL68() {
	callHandlers(IRQ_IEL68)
}

//export IEL69_IRQHandler
func interruptIEL69() {
	callHandlers(IRQ_IEL69)
}

//export IEL70_IRQHandler
func interruptIEL70() {
	callHandlers(IRQ_IEL70)
}

//export IEL71_IRQHandler
func interruptIEL71() {
	callHandlers(IRQ_IEL71)
}

//export IEL72_IRQHandler
func interruptIEL72() {
	callHandlers(IRQ_IEL72)
}

//export IEL73_IRQHandler
func interruptIEL73() {
	callHandlers(IRQ_IEL73)
}

//export IEL74_IRQHandler
func interruptIEL74() {
	callHandlers(IRQ_IEL74)
}

//export IEL75_IRQHandler
func interruptIEL75() {
	callHandlers(IRQ_IEL75)
}

//export IEL76_IRQHandler
func interruptIEL76() {
	callHandlers(IRQ_IEL76)
}

//export IEL77_IRQHandler
func interruptIEL77() {
	callHandlers(IRQ_IEL77)
}

//export IEL78_IRQHandler
func interruptIEL78() {
	callHandlers(IRQ_IEL78)
}

//export IEL79_IRQHandler
func interruptIEL79() {
	callHandlers(IRQ_IEL79)
}

//export IEL80_IRQHandler
func interruptIEL80() {
	callHandlers(IRQ_IEL80)
}

//export IEL81_IRQHandler
func interruptIEL81() {
	callHandlers(IRQ_IEL81)
}

//export IEL82_IRQHandler
func interruptIEL82() {
	callHandlers(IRQ_IEL82)
}

//export IEL83_IRQHandler
func interruptIEL83() {
	callHandlers(IRQ_IEL83)
}

//export IEL84_IRQHandler
func interruptIEL84() {
	callHandlers(IRQ_IEL84)
}

//export IEL85_IRQHandler
func interruptIEL85() {
	callHandlers(IRQ_IEL85)
}

//export IEL86_IRQHandler
func interruptIEL86() {
	callHandlers(IRQ_IEL86)
}

//export IEL87_IRQHandler
func interruptIEL87() {
	callHandlers(IRQ_IEL87)
}

//export IEL88_IRQHandler
func interruptIEL88() {
	callHandlers(IRQ_IEL88)
}

//export IEL89_IRQHandler
func interruptIEL89() {
	callHandlers(IRQ_IEL89)
}

//export IEL90_IRQHandler
func interruptIEL90() {
	callHandlers(IRQ_IEL90)
}

//export IEL91_IRQHandler
func interruptIEL91() {
	callHandlers(IRQ_IEL91)
}

//export IEL92_IRQHandler
func interruptIEL92() {
	callHandlers(IRQ_IEL92)
}

//export IEL93_IRQHandler
func interruptIEL93() {
	callHandlers(IRQ_IEL93)
}

//export IEL94_IRQHandler
func interruptIEL94() {
	callHandlers(IRQ_IEL94)
}

//export IEL95_IRQHandler
func interruptIEL95() {
	callHandlers(IRQ_IEL95)
}

// Peripherals.
var (
	// Renesas Memory Protection Unit
	RMPU = (*RMPU_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// TrustZone Filter
	TZF = (*TZF_Type)(unsafe.Pointer(uintptr(0x40000e00)))

	// SRAM Control
	SRAM = (*SRAM_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// Bus Control
	BUS = (*BUS_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Direct memory access controller 0
	DMAC0 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005000)))

	// Direct memory access controller 1
	DMAC1 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005040)))

	// Direct memory access controller 2
	DMAC2 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005080)))

	// Direct memory access controller 3
	DMAC3 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x400050c0)))

	// Direct memory access controller 4
	DMAC4 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005100)))

	// Direct memory access controller 5
	DMAC5 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005140)))

	// Direct memory access controller 6
	DMAC6 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005180)))

	// Direct memory access controller 7
	DMAC7 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x400051c0)))

	// DMAC Module Activation
	DMA = (*DMA_Type)(unsafe.Pointer(uintptr(0x40005200)))

	// Data Transfer Controller
	DTC = (*DTC_Type)(unsafe.Pointer(uintptr(0x40005400)))

	// Interrupt Controller
	ICU = (*ICU_Type)(unsafe.Pointer(uintptr(0x40006000)))

	// CACHE
	CACHE = (*CACHE_Type)(unsafe.Pointer(uintptr(0x40007000)))

	// CPU System Security Control Unit
	CPSCU = (*CPSCU_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// Debug Function
	DBG = (*DBG_Type)(unsafe.Pointer(uintptr(0x4001b000)))

	// SYSTEM/FLASH
	FCACHE = (*FCACHE_Type)(unsafe.Pointer(uintptr(0x4001c100)))

	// System Control
	SYSC = (*SYSC_Type)(unsafe.Pointer(uintptr(0x4001e000)))

	// Pmn Pin FunctionPort 0 Control RegistersPmn Pin Function Control Register
	PORT0 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40080000)))

	// Pmn Pin FunctionPort 1 Control RegistersPmn Pin Function Control Register
	PORT1 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40080020)))

	// Pmn Pin FunctionPort 2 Control RegistersPmn Pin Function Control Register
	PORT2 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40080040)))

	// Pmn Pin FunctionPort 3 Control RegistersPmn Pin Function Control Register
	PORT3 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40080060)))

	// Pmn Pin FunctionPort 4 Control RegistersPmn Pin Function Control Register
	PORT4 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40080080)))

	// Pmn Pin FunctionPort 5 Control RegistersPmn Pin Function Control Register
	PORT5 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x400800a0)))

	// Pmn Pin FunctionPort 6 Control RegistersPmn Pin Function Control Register
	PORT6 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x400800c0)))

	// Pmn Pin FunctionPort 7 Control RegistersPmn Pin Function Control Register
	PORT7 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x400800e0)))

	// Pmn Pin FunctionPort 8 Control RegistersPmn Pin Function Control Register
	PORT8 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40080100)))

	// Control Register
	PFS = (*PFS_Type)(unsafe.Pointer(uintptr(0x40080800)))

	// Event Link Controller
	ELC = (*ELC_Type)(unsafe.Pointer(uintptr(0x40082000)))

	// Realtime Clock
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x40083000)))

	// Independent Watchdog Timer
	IWDT = (*IWDT_Type)(unsafe.Pointer(uintptr(0x40083200)))

	// Watchdog Timer
	WDT = (*WDT_Type)(unsafe.Pointer(uintptr(0x40083400)))

	// Clock Frequency Accuracy Measurement Circuit
	CAC = (*CAC_Type)(unsafe.Pointer(uintptr(0x40083600)))

	// Module Stop Control
	MSTP = (*MSTP_Type)(unsafe.Pointer(uintptr(0x40084000)))

	// Port Output Enable Module for GPT
	POEG = (*POEG_Type)(unsafe.Pointer(uintptr(0x4008a000)))

	// USB 2.0 Full-Speed Module
	USBFS = (*USBFS_Type)(unsafe.Pointer(uintptr(0x40090000)))

	// SD Host Interface 0
	SDHI0 = (*SDHI0_Type)(unsafe.Pointer(uintptr(0x40092000)))

	// Serial Sound Interface Enhanced (SSIE)
	SSIE0 = (*SSIE0_Type)(unsafe.Pointer(uintptr(0x4009d000)))

	// Inter-Integrated Circuit 0
	IIC0 = (*IIC0_Type)(unsafe.Pointer(uintptr(0x4009f000)))

	// Inter-Integrated Circuit 0 Wake-up Unit
	IIC0WU = (*IIC0WU_Type)(unsafe.Pointer(uintptr(0x4009f014)))

	// Inter-Integrated Circuit 1
	IIC1 = (*IIC0_Type)(unsafe.Pointer(uintptr(0x4009f100)))

	// Controller Area Network
	CAN0 = (*CAN0_Type)(unsafe.Pointer(uintptr(0x400a8000)))

	// Peripheral Security Control Unit
	PSCU = (*PSCU_Type)(unsafe.Pointer(uintptr(0x400e0000)))

	// Low Power Asynchronous General Purpose Timer 0
	AGT0 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x400e8000)))

	// Low Power Asynchronous General Purpose Timer 1
	AGT1 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x400e8100)))

	// Low Power Asynchronous General Purpose Timer 2
	AGT2 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x400e8200)))

	// Low Power Asynchronous General Purpose Timer 3
	AGT3 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x400e8300)))

	// Low Power Asynchronous General Purpose Timer 4
	AGT4 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x400e8400)))

	// Low Power Asynchronous General Purpose Timer 5
	AGT5 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x400e8500)))

	// Cyclic Redundancy Check Calculator
	CRC = (*CRC_Type)(unsafe.Pointer(uintptr(0x40108000)))

	// Data Operation Circuit
	DOC = (*DOC_Type)(unsafe.Pointer(uintptr(0x40109000)))

	// DMA Controller for the Ethernet Controller Channel 0
	EDMAC0 = (*EDMAC0_Type)(unsafe.Pointer(uintptr(0x40114000)))

	// Ethernet Controller Channel 0
	ETHERC0 = (*ETHERC0_Type)(unsafe.Pointer(uintptr(0x40114100)))

	// Serial Communication Interface
	SCI0 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x40118000)))

	// Serial Communication Interface 1
	SCI1 = (*SCI1_Type)(unsafe.Pointer(uintptr(0x40118100)))

	// Serial Communication Interface 2
	SCI2 = (*SCI2_Type)(unsafe.Pointer(uintptr(0x40118200)))

	// Serial Communication Interface
	SCI3 = (*SCI3_Type)(unsafe.Pointer(uintptr(0x40118300)))

	// Serial Communication Interface
	SCI4 = (*SCI3_Type)(unsafe.Pointer(uintptr(0x40118400)))

	// Serial Communication Interface
	SCI9 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x40118900)))

	// Serial Peripheral Interface 0
	SPI0 = (*SPI0_Type)(unsafe.Pointer(uintptr(0x4011a000)))

	// Serial Peripheral Interface 1
	SPI1 = (*SPI0_Type)(unsafe.Pointer(uintptr(0x4011a100)))

	// General PWM 32-bit Timer 1
	GPT321 = (*GPT321_Type)(unsafe.Pointer(uintptr(0x40169100)))

	// General PWM 32-bit Timer 2
	GPT322 = (*GPT321_Type)(unsafe.Pointer(uintptr(0x40169200)))

	// General PWM 16-bit Timer 4
	GPT164 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40169400)))

	// General PWM 16-bit Timer 5
	GPT165 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40169500)))

	// General PWM 16-bit Timer 6
	GPT166 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40169600)))

	// General PWM 16-bit Timer 7
	GPT167 = (*GPT164_Type)(unsafe.Pointer(uintptr(0x40169700)))

	// 12-bit A/D Converter
	ADC120 = (*ADC120_Type)(unsafe.Pointer(uintptr(0x40170000)))

	// 12-bit D/A converter
	DAC12 = (*DAC12_Type)(unsafe.Pointer(uintptr(0x40171000)))

	// Data Flash
	FLAD = (*FLAD_Type)(unsafe.Pointer(uintptr(0x407fc000)))

	// Flash/CPU Interface
	FACI = (*FACI_Type)(unsafe.Pointer(uintptr(0x407fe000)))

	// Quad Serial Peripheral Interface
	QSPI = (*QSPI_Type)(unsafe.Pointer(uintptr(0x64000000)))
)

// Renesas Memory Protection Unit
type RMPU_Type struct {
	MMPUOAD         volatile.Register16 // 0x0
	_               [2]byte
	MMPUOADPT       volatile.Register16 // 0x4
	_               [250]byte
	MMPUENDMAC      volatile.Register16 // 0x100
	_               [2]byte
	MMPUENPTDMAC    volatile.Register16 // 0x104
	_               [2]byte
	MMPURPTDMAC     volatile.Register16 // 0x108
	_               [2]byte
	MMPURPTDMAC_SEC volatile.Register16 // 0x10C
	_               [242]byte
	MMPUACDMAC0     volatile.Register16 // 0x200
	_               [2]byte
	MMPUSDMAC0      volatile.Register32 // 0x204
	MMPUEDMAC0      volatile.Register32 // 0x208
	_               [4]byte
	MMPUACDMAC1     volatile.Register16 // 0x210
	_               [2]byte
	MMPUSDMAC1      volatile.Register32 // 0x214
	MMPUEDMAC1      volatile.Register32 // 0x218
	_               [4]byte
	MMPUACDMAC2     volatile.Register16 // 0x220
	_               [2]byte
	MMPUSDMAC2      volatile.Register32 // 0x224
	MMPUEDMAC2      volatile.Register32 // 0x228
	_               [4]byte
	MMPUACDMAC3     volatile.Register16 // 0x230
	_               [2]byte
	MMPUSDMAC3      volatile.Register32 // 0x234
	MMPUEDMAC3      volatile.Register32 // 0x238
	_               [4]byte
	MMPUACDMAC4     volatile.Register16 // 0x240
	_               [2]byte
	MMPUSDMAC4      volatile.Register32 // 0x244
	MMPUEDMAC4      volatile.Register32 // 0x248
	_               [4]byte
	MMPUACDMAC5     volatile.Register16 // 0x250
	_               [2]byte
	MMPUSDMAC5      volatile.Register32 // 0x254
	MMPUEDMAC5      volatile.Register32 // 0x258
	_               [4]byte
	MMPUACDMAC6     volatile.Register16 // 0x260
	_               [2]byte
	MMPUSDMAC6      volatile.Register32 // 0x264
	MMPUEDMAC6      volatile.Register32 // 0x268
	_               [4]byte
	MMPUACDMAC7     volatile.Register16 // 0x270
	_               [2]byte
	MMPUSDMAC7      volatile.Register32 // 0x274
	MMPUEDMAC7      volatile.Register32 // 0x278
	_               [644]byte
	MMPUENEDMAC     volatile.Register16 // 0x500
	_               [2]byte
	MMPUENPTEDMAC   volatile.Register16 // 0x504
	_               [2]byte
	MMPURPTEDMAC    volatile.Register16 // 0x508
	_               [246]byte
	MMPUACEDMAC0    volatile.Register16 // 0x600
	_               [2]byte
	MMPUSEDMAC0     volatile.Register32 // 0x604
	MMPUEEDMAC0     volatile.Register32 // 0x608
	_               [4]byte
	MMPUACEDMAC1    volatile.Register16 // 0x610
	_               [2]byte
	MMPUSEDMAC1     volatile.Register32 // 0x614
	MMPUEEDMAC1     volatile.Register32 // 0x618
	_               [4]byte
	MMPUACEDMAC2    volatile.Register16 // 0x620
	_               [2]byte
	MMPUSEDMAC2     volatile.Register32 // 0x624
	MMPUEEDMAC2     volatile.Register32 // 0x628
	_               [4]byte
	MMPUACEDMAC3    volatile.Register16 // 0x630
	_               [2]byte
	MMPUSEDMAC3     volatile.Register32 // 0x634
	MMPUEEDMAC3     volatile.Register32 // 0x638
}

// RMPU.MMPUOAD: MMPU Operation After Detection Register
func (o *RMPU_Type) SetMMPUOAD_OAD(value uint16) {
	volatile.StoreUint16(&o.MMPUOAD.Reg, volatile.LoadUint16(&o.MMPUOAD.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUOAD_OAD() uint16 {
	return volatile.LoadUint16(&o.MMPUOAD.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUOAD_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUOAD.Reg, volatile.LoadUint16(&o.MMPUOAD.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetMMPUOAD_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUOAD.Reg) & 0xff00) >> 8
}

// RMPU.MMPUOADPT: MMPU Operation After Detection Protect Register
func (o *RMPU_Type) SetMMPUOADPT_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MMPUOADPT.Reg, volatile.LoadUint16(&o.MMPUOADPT.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUOADPT_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MMPUOADPT.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUOADPT_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUOADPT.Reg, volatile.LoadUint16(&o.MMPUOADPT.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetMMPUOADPT_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUOADPT.Reg) & 0xff00) >> 8
}

// RMPU.MMPUENDMAC: MMPU Enable Register for DMAC
func (o *RMPU_Type) SetMMPUENDMAC_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUENDMAC.Reg, volatile.LoadUint16(&o.MMPUENDMAC.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUENDMAC_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUENDMAC.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUENDMAC_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUENDMAC.Reg, volatile.LoadUint16(&o.MMPUENDMAC.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetMMPUENDMAC_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUENDMAC.Reg) & 0xff00) >> 8
}

// RMPU.MMPUENPTDMAC: MMPU Enable Protect Register for DMAC
func (o *RMPU_Type) SetMMPUENPTDMAC_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MMPUENPTDMAC.Reg, volatile.LoadUint16(&o.MMPUENPTDMAC.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUENPTDMAC_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MMPUENPTDMAC.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUENPTDMAC_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUENPTDMAC.Reg, volatile.LoadUint16(&o.MMPUENPTDMAC.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetMMPUENPTDMAC_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUENPTDMAC.Reg) & 0xff00) >> 8
}

// RMPU.MMPURPTDMAC: MMPU Regions Protect Register for DMAC
func (o *RMPU_Type) SetMMPURPTDMAC_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MMPURPTDMAC.Reg, volatile.LoadUint16(&o.MMPURPTDMAC.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPURPTDMAC_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MMPURPTDMAC.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPURPTDMAC_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPURPTDMAC.Reg, volatile.LoadUint16(&o.MMPURPTDMAC.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetMMPURPTDMAC_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPURPTDMAC.Reg) & 0xff00) >> 8
}

// RMPU.MMPURPTDMAC_SEC: MMPU Regions Protect register for DMAC Secure
func (o *RMPU_Type) SetMMPURPTDMAC_SEC_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MMPURPTDMAC_SEC.Reg, volatile.LoadUint16(&o.MMPURPTDMAC_SEC.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPURPTDMAC_SEC_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MMPURPTDMAC_SEC.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPURPTDMAC_SEC_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPURPTDMAC_SEC.Reg, volatile.LoadUint16(&o.MMPURPTDMAC_SEC.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetMMPURPTDMAC_SEC_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPURPTDMAC_SEC.Reg) & 0xff00) >> 8
}

// RMPU.MMPUACDMAC0: MMPU Access Control Register for DMAC
func (o *RMPU_Type) SetMMPUACDMAC0_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC0.Reg, volatile.LoadUint16(&o.MMPUACDMAC0.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACDMAC0_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACDMAC0.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACDMAC0_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC0.Reg, volatile.LoadUint16(&o.MMPUACDMAC0.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACDMAC0_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC0.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACDMAC0_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC0.Reg, volatile.LoadUint16(&o.MMPUACDMAC0.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACDMAC0_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC0.Reg) & 0x4) >> 2
}

// RMPU.MMPUSDMAC0: MMPU Start Address Register for DMAC
func (o *RMPU_Type) SetMMPUSDMAC0_MMPUS(value uint32) {
	volatile.StoreUint32(&o.MMPUSDMAC0.Reg, volatile.LoadUint32(&o.MMPUSDMAC0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUSDMAC0_MMPUS() uint32 {
	return (volatile.LoadUint32(&o.MMPUSDMAC0.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUEDMAC0: MMPU End Address Register for DMAC
func (o *RMPU_Type) SetMMPUEDMAC0_MMPUE(value uint32) {
	volatile.StoreUint32(&o.MMPUEDMAC0.Reg, volatile.LoadUint32(&o.MMPUEDMAC0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUEDMAC0_MMPUE() uint32 {
	return (volatile.LoadUint32(&o.MMPUEDMAC0.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUACDMAC1: MMPU Access Control Register for DMAC
func (o *RMPU_Type) SetMMPUACDMAC1_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC1.Reg, volatile.LoadUint16(&o.MMPUACDMAC1.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACDMAC1_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACDMAC1.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACDMAC1_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC1.Reg, volatile.LoadUint16(&o.MMPUACDMAC1.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACDMAC1_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC1.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACDMAC1_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC1.Reg, volatile.LoadUint16(&o.MMPUACDMAC1.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACDMAC1_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC1.Reg) & 0x4) >> 2
}

// RMPU.MMPUSDMAC1: MMPU Start Address Register for DMAC
func (o *RMPU_Type) SetMMPUSDMAC1_MMPUS(value uint32) {
	volatile.StoreUint32(&o.MMPUSDMAC1.Reg, volatile.LoadUint32(&o.MMPUSDMAC1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUSDMAC1_MMPUS() uint32 {
	return (volatile.LoadUint32(&o.MMPUSDMAC1.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUEDMAC1: MMPU End Address Register for DMAC
func (o *RMPU_Type) SetMMPUEDMAC1_MMPUE(value uint32) {
	volatile.StoreUint32(&o.MMPUEDMAC1.Reg, volatile.LoadUint32(&o.MMPUEDMAC1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUEDMAC1_MMPUE() uint32 {
	return (volatile.LoadUint32(&o.MMPUEDMAC1.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUACDMAC2: MMPU Access Control Register for DMAC
func (o *RMPU_Type) SetMMPUACDMAC2_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC2.Reg, volatile.LoadUint16(&o.MMPUACDMAC2.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACDMAC2_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACDMAC2.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACDMAC2_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC2.Reg, volatile.LoadUint16(&o.MMPUACDMAC2.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACDMAC2_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC2.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACDMAC2_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC2.Reg, volatile.LoadUint16(&o.MMPUACDMAC2.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACDMAC2_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC2.Reg) & 0x4) >> 2
}

// RMPU.MMPUSDMAC2: MMPU Start Address Register for DMAC
func (o *RMPU_Type) SetMMPUSDMAC2_MMPUS(value uint32) {
	volatile.StoreUint32(&o.MMPUSDMAC2.Reg, volatile.LoadUint32(&o.MMPUSDMAC2.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUSDMAC2_MMPUS() uint32 {
	return (volatile.LoadUint32(&o.MMPUSDMAC2.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUEDMAC2: MMPU End Address Register for DMAC
func (o *RMPU_Type) SetMMPUEDMAC2_MMPUE(value uint32) {
	volatile.StoreUint32(&o.MMPUEDMAC2.Reg, volatile.LoadUint32(&o.MMPUEDMAC2.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUEDMAC2_MMPUE() uint32 {
	return (volatile.LoadUint32(&o.MMPUEDMAC2.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUACDMAC3: MMPU Access Control Register for DMAC
func (o *RMPU_Type) SetMMPUACDMAC3_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC3.Reg, volatile.LoadUint16(&o.MMPUACDMAC3.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACDMAC3_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACDMAC3.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACDMAC3_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC3.Reg, volatile.LoadUint16(&o.MMPUACDMAC3.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACDMAC3_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC3.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACDMAC3_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC3.Reg, volatile.LoadUint16(&o.MMPUACDMAC3.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACDMAC3_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC3.Reg) & 0x4) >> 2
}

// RMPU.MMPUSDMAC3: MMPU Start Address Register for DMAC
func (o *RMPU_Type) SetMMPUSDMAC3_MMPUS(value uint32) {
	volatile.StoreUint32(&o.MMPUSDMAC3.Reg, volatile.LoadUint32(&o.MMPUSDMAC3.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUSDMAC3_MMPUS() uint32 {
	return (volatile.LoadUint32(&o.MMPUSDMAC3.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUEDMAC3: MMPU End Address Register for DMAC
func (o *RMPU_Type) SetMMPUEDMAC3_MMPUE(value uint32) {
	volatile.StoreUint32(&o.MMPUEDMAC3.Reg, volatile.LoadUint32(&o.MMPUEDMAC3.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUEDMAC3_MMPUE() uint32 {
	return (volatile.LoadUint32(&o.MMPUEDMAC3.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUACDMAC4: MMPU Access Control Register for DMAC
func (o *RMPU_Type) SetMMPUACDMAC4_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC4.Reg, volatile.LoadUint16(&o.MMPUACDMAC4.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACDMAC4_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACDMAC4.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACDMAC4_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC4.Reg, volatile.LoadUint16(&o.MMPUACDMAC4.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACDMAC4_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC4.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACDMAC4_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC4.Reg, volatile.LoadUint16(&o.MMPUACDMAC4.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACDMAC4_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC4.Reg) & 0x4) >> 2
}

// RMPU.MMPUSDMAC4: MMPU Start Address Register for DMAC
func (o *RMPU_Type) SetMMPUSDMAC4_MMPUS(value uint32) {
	volatile.StoreUint32(&o.MMPUSDMAC4.Reg, volatile.LoadUint32(&o.MMPUSDMAC4.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUSDMAC4_MMPUS() uint32 {
	return (volatile.LoadUint32(&o.MMPUSDMAC4.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUEDMAC4: MMPU End Address Register for DMAC
func (o *RMPU_Type) SetMMPUEDMAC4_MMPUE(value uint32) {
	volatile.StoreUint32(&o.MMPUEDMAC4.Reg, volatile.LoadUint32(&o.MMPUEDMAC4.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUEDMAC4_MMPUE() uint32 {
	return (volatile.LoadUint32(&o.MMPUEDMAC4.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUACDMAC5: MMPU Access Control Register for DMAC
func (o *RMPU_Type) SetMMPUACDMAC5_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC5.Reg, volatile.LoadUint16(&o.MMPUACDMAC5.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACDMAC5_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACDMAC5.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACDMAC5_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC5.Reg, volatile.LoadUint16(&o.MMPUACDMAC5.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACDMAC5_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC5.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACDMAC5_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC5.Reg, volatile.LoadUint16(&o.MMPUACDMAC5.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACDMAC5_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC5.Reg) & 0x4) >> 2
}

// RMPU.MMPUSDMAC5: MMPU Start Address Register for DMAC
func (o *RMPU_Type) SetMMPUSDMAC5_MMPUS(value uint32) {
	volatile.StoreUint32(&o.MMPUSDMAC5.Reg, volatile.LoadUint32(&o.MMPUSDMAC5.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUSDMAC5_MMPUS() uint32 {
	return (volatile.LoadUint32(&o.MMPUSDMAC5.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUEDMAC5: MMPU End Address Register for DMAC
func (o *RMPU_Type) SetMMPUEDMAC5_MMPUE(value uint32) {
	volatile.StoreUint32(&o.MMPUEDMAC5.Reg, volatile.LoadUint32(&o.MMPUEDMAC5.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUEDMAC5_MMPUE() uint32 {
	return (volatile.LoadUint32(&o.MMPUEDMAC5.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUACDMAC6: MMPU Access Control Register for DMAC
func (o *RMPU_Type) SetMMPUACDMAC6_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC6.Reg, volatile.LoadUint16(&o.MMPUACDMAC6.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACDMAC6_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACDMAC6.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACDMAC6_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC6.Reg, volatile.LoadUint16(&o.MMPUACDMAC6.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACDMAC6_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC6.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACDMAC6_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC6.Reg, volatile.LoadUint16(&o.MMPUACDMAC6.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACDMAC6_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC6.Reg) & 0x4) >> 2
}

// RMPU.MMPUSDMAC6: MMPU Start Address Register for DMAC
func (o *RMPU_Type) SetMMPUSDMAC6_MMPUS(value uint32) {
	volatile.StoreUint32(&o.MMPUSDMAC6.Reg, volatile.LoadUint32(&o.MMPUSDMAC6.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUSDMAC6_MMPUS() uint32 {
	return (volatile.LoadUint32(&o.MMPUSDMAC6.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUEDMAC6: MMPU End Address Register for DMAC
func (o *RMPU_Type) SetMMPUEDMAC6_MMPUE(value uint32) {
	volatile.StoreUint32(&o.MMPUEDMAC6.Reg, volatile.LoadUint32(&o.MMPUEDMAC6.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUEDMAC6_MMPUE() uint32 {
	return (volatile.LoadUint32(&o.MMPUEDMAC6.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUACDMAC7: MMPU Access Control Register for DMAC
func (o *RMPU_Type) SetMMPUACDMAC7_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC7.Reg, volatile.LoadUint16(&o.MMPUACDMAC7.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACDMAC7_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACDMAC7.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACDMAC7_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC7.Reg, volatile.LoadUint16(&o.MMPUACDMAC7.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACDMAC7_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC7.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACDMAC7_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACDMAC7.Reg, volatile.LoadUint16(&o.MMPUACDMAC7.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACDMAC7_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACDMAC7.Reg) & 0x4) >> 2
}

// RMPU.MMPUSDMAC7: MMPU Start Address Register for DMAC
func (o *RMPU_Type) SetMMPUSDMAC7_MMPUS(value uint32) {
	volatile.StoreUint32(&o.MMPUSDMAC7.Reg, volatile.LoadUint32(&o.MMPUSDMAC7.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUSDMAC7_MMPUS() uint32 {
	return (volatile.LoadUint32(&o.MMPUSDMAC7.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUEDMAC7: MMPU End Address Register for DMAC
func (o *RMPU_Type) SetMMPUEDMAC7_MMPUE(value uint32) {
	volatile.StoreUint32(&o.MMPUEDMAC7.Reg, volatile.LoadUint32(&o.MMPUEDMAC7.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUEDMAC7_MMPUE() uint32 {
	return (volatile.LoadUint32(&o.MMPUEDMAC7.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUENEDMAC: MMPU Enable Register for EDMAC
func (o *RMPU_Type) SetMMPUENEDMAC_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUENEDMAC.Reg, volatile.LoadUint16(&o.MMPUENEDMAC.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUENEDMAC_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUENEDMAC.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUENEDMAC_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUENEDMAC.Reg, volatile.LoadUint16(&o.MMPUENEDMAC.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetMMPUENEDMAC_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUENEDMAC.Reg) & 0xff00) >> 8
}

// RMPU.MMPUENPTEDMAC: MMPU Enable Protect Register for EDMAC
func (o *RMPU_Type) SetMMPUENPTEDMAC_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MMPUENPTEDMAC.Reg, volatile.LoadUint16(&o.MMPUENPTEDMAC.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUENPTEDMAC_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MMPUENPTEDMAC.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUENPTEDMAC_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUENPTEDMAC.Reg, volatile.LoadUint16(&o.MMPUENPTEDMAC.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetMMPUENPTEDMAC_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUENPTEDMAC.Reg) & 0xff00) >> 8
}

// RMPU.MMPURPTEDMAC: MMPU Regions Protect Register for EDMAC
func (o *RMPU_Type) SetMMPURPTEDMAC_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MMPURPTEDMAC.Reg, volatile.LoadUint16(&o.MMPURPTEDMAC.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPURPTEDMAC_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MMPURPTEDMAC.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPURPTEDMAC_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPURPTEDMAC.Reg, volatile.LoadUint16(&o.MMPURPTEDMAC.Reg)&^(0xff00)|value<<8)
}
func (o *RMPU_Type) GetMMPURPTEDMAC_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPURPTEDMAC.Reg) & 0xff00) >> 8
}

// RMPU.MMPUACEDMAC0: MMPU Access Control Register for EDMAC
func (o *RMPU_Type) SetMMPUACEDMAC0_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACEDMAC0.Reg, volatile.LoadUint16(&o.MMPUACEDMAC0.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACEDMAC0_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACEDMAC0.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACEDMAC0_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACEDMAC0.Reg, volatile.LoadUint16(&o.MMPUACEDMAC0.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACEDMAC0_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACEDMAC0.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACEDMAC0_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACEDMAC0.Reg, volatile.LoadUint16(&o.MMPUACEDMAC0.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACEDMAC0_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACEDMAC0.Reg) & 0x4) >> 2
}

// RMPU.MMPUSEDMAC0: MMPU Start Address Register for EDMAC
func (o *RMPU_Type) SetMMPUSEDMAC0_MMPUS(value uint32) {
	volatile.StoreUint32(&o.MMPUSEDMAC0.Reg, volatile.LoadUint32(&o.MMPUSEDMAC0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUSEDMAC0_MMPUS() uint32 {
	return (volatile.LoadUint32(&o.MMPUSEDMAC0.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUEEDMAC0: MMPU End Address Register for EDMAC
func (o *RMPU_Type) SetMMPUEEDMAC0_MMPUE(value uint32) {
	volatile.StoreUint32(&o.MMPUEEDMAC0.Reg, volatile.LoadUint32(&o.MMPUEEDMAC0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUEEDMAC0_MMPUE() uint32 {
	return (volatile.LoadUint32(&o.MMPUEEDMAC0.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUACEDMAC1: MMPU Access Control Register for EDMAC
func (o *RMPU_Type) SetMMPUACEDMAC1_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACEDMAC1.Reg, volatile.LoadUint16(&o.MMPUACEDMAC1.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACEDMAC1_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACEDMAC1.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACEDMAC1_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACEDMAC1.Reg, volatile.LoadUint16(&o.MMPUACEDMAC1.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACEDMAC1_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACEDMAC1.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACEDMAC1_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACEDMAC1.Reg, volatile.LoadUint16(&o.MMPUACEDMAC1.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACEDMAC1_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACEDMAC1.Reg) & 0x4) >> 2
}

// RMPU.MMPUSEDMAC1: MMPU Start Address Register for EDMAC
func (o *RMPU_Type) SetMMPUSEDMAC1_MMPUS(value uint32) {
	volatile.StoreUint32(&o.MMPUSEDMAC1.Reg, volatile.LoadUint32(&o.MMPUSEDMAC1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUSEDMAC1_MMPUS() uint32 {
	return (volatile.LoadUint32(&o.MMPUSEDMAC1.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUEEDMAC1: MMPU End Address Register for EDMAC
func (o *RMPU_Type) SetMMPUEEDMAC1_MMPUE(value uint32) {
	volatile.StoreUint32(&o.MMPUEEDMAC1.Reg, volatile.LoadUint32(&o.MMPUEEDMAC1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUEEDMAC1_MMPUE() uint32 {
	return (volatile.LoadUint32(&o.MMPUEEDMAC1.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUACEDMAC2: MMPU Access Control Register for EDMAC
func (o *RMPU_Type) SetMMPUACEDMAC2_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACEDMAC2.Reg, volatile.LoadUint16(&o.MMPUACEDMAC2.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACEDMAC2_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACEDMAC2.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACEDMAC2_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACEDMAC2.Reg, volatile.LoadUint16(&o.MMPUACEDMAC2.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACEDMAC2_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACEDMAC2.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACEDMAC2_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACEDMAC2.Reg, volatile.LoadUint16(&o.MMPUACEDMAC2.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACEDMAC2_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACEDMAC2.Reg) & 0x4) >> 2
}

// RMPU.MMPUSEDMAC2: MMPU Start Address Register for EDMAC
func (o *RMPU_Type) SetMMPUSEDMAC2_MMPUS(value uint32) {
	volatile.StoreUint32(&o.MMPUSEDMAC2.Reg, volatile.LoadUint32(&o.MMPUSEDMAC2.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUSEDMAC2_MMPUS() uint32 {
	return (volatile.LoadUint32(&o.MMPUSEDMAC2.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUEEDMAC2: MMPU End Address Register for EDMAC
func (o *RMPU_Type) SetMMPUEEDMAC2_MMPUE(value uint32) {
	volatile.StoreUint32(&o.MMPUEEDMAC2.Reg, volatile.LoadUint32(&o.MMPUEEDMAC2.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUEEDMAC2_MMPUE() uint32 {
	return (volatile.LoadUint32(&o.MMPUEEDMAC2.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUACEDMAC3: MMPU Access Control Register for EDMAC
func (o *RMPU_Type) SetMMPUACEDMAC3_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACEDMAC3.Reg, volatile.LoadUint16(&o.MMPUACEDMAC3.Reg)&^(0x1)|value)
}
func (o *RMPU_Type) GetMMPUACEDMAC3_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACEDMAC3.Reg) & 0x1
}
func (o *RMPU_Type) SetMMPUACEDMAC3_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACEDMAC3.Reg, volatile.LoadUint16(&o.MMPUACEDMAC3.Reg)&^(0x2)|value<<1)
}
func (o *RMPU_Type) GetMMPUACEDMAC3_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACEDMAC3.Reg) & 0x2) >> 1
}
func (o *RMPU_Type) SetMMPUACEDMAC3_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACEDMAC3.Reg, volatile.LoadUint16(&o.MMPUACEDMAC3.Reg)&^(0x4)|value<<2)
}
func (o *RMPU_Type) GetMMPUACEDMAC3_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACEDMAC3.Reg) & 0x4) >> 2
}

// RMPU.MMPUSEDMAC3: MMPU Start Address Register for EDMAC
func (o *RMPU_Type) SetMMPUSEDMAC3_MMPUS(value uint32) {
	volatile.StoreUint32(&o.MMPUSEDMAC3.Reg, volatile.LoadUint32(&o.MMPUSEDMAC3.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUSEDMAC3_MMPUS() uint32 {
	return (volatile.LoadUint32(&o.MMPUSEDMAC3.Reg) & 0xffffffe0) >> 5
}

// RMPU.MMPUEEDMAC3: MMPU End Address Register for EDMAC
func (o *RMPU_Type) SetMMPUEEDMAC3_MMPUE(value uint32) {
	volatile.StoreUint32(&o.MMPUEEDMAC3.Reg, volatile.LoadUint32(&o.MMPUEEDMAC3.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RMPU_Type) GetMMPUEEDMAC3_MMPUE() uint32 {
	return (volatile.LoadUint32(&o.MMPUEEDMAC3.Reg) & 0xffffffe0) >> 5
}

// TrustZone Filter
type TZF_Type struct {
	TZFOAD volatile.Register16 // 0x0
	_      [2]byte
	TZFPT  volatile.Register16 // 0x4
}

// TZF.TZFOAD: TrustZone Filter Operation After Detection Register
func (o *TZF_Type) SetTZFOAD_OAD(value uint16) {
	volatile.StoreUint16(&o.TZFOAD.Reg, volatile.LoadUint16(&o.TZFOAD.Reg)&^(0x1)|value)
}
func (o *TZF_Type) GetTZFOAD_OAD() uint16 {
	return volatile.LoadUint16(&o.TZFOAD.Reg) & 0x1
}
func (o *TZF_Type) SetTZFOAD_KEY(value uint16) {
	volatile.StoreUint16(&o.TZFOAD.Reg, volatile.LoadUint16(&o.TZFOAD.Reg)&^(0xff00)|value<<8)
}
func (o *TZF_Type) GetTZFOAD_KEY() uint16 {
	return (volatile.LoadUint16(&o.TZFOAD.Reg) & 0xff00) >> 8
}

// TZF.TZFPT: TrustZone Filter Protect Register
func (o *TZF_Type) SetTZFPT_PROTECT(value uint16) {
	volatile.StoreUint16(&o.TZFPT.Reg, volatile.LoadUint16(&o.TZFPT.Reg)&^(0x1)|value)
}
func (o *TZF_Type) GetTZFPT_PROTECT() uint16 {
	return volatile.LoadUint16(&o.TZFPT.Reg) & 0x1
}
func (o *TZF_Type) SetTZFPT_KEY(value uint16) {
	volatile.StoreUint16(&o.TZFPT.Reg, volatile.LoadUint16(&o.TZFPT.Reg)&^(0xff00)|value<<8)
}
func (o *TZF_Type) GetTZFPT_KEY() uint16 {
	return (volatile.LoadUint16(&o.TZFPT.Reg) & 0xff00) >> 8
}

// SRAM Control
type SRAM_Type struct {
	PARIOAD   volatile.Register8 // 0x0
	_         [3]byte
	SRAMPRCR  volatile.Register8 // 0x4
	_         [3]byte
	SRAMWTSC  volatile.Register8 // 0x8
	_         [3]byte
	SRAMPRCR2 volatile.Register8 // 0xC
}

// SRAM.PARIOAD: SRAM Parity Error Operation After Detection Register
func (o *SRAM_Type) SetPARIOAD_OAD(value uint8) {
	volatile.StoreUint8(&o.PARIOAD.Reg, volatile.LoadUint8(&o.PARIOAD.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetPARIOAD_OAD() uint8 {
	return volatile.LoadUint8(&o.PARIOAD.Reg) & 0x1
}

// SRAM.SRAMPRCR: SRAM Protection Register
func (o *SRAM_Type) SetSRAMPRCR(value uint8) {
	volatile.StoreUint8(&o.SRAMPRCR.Reg, volatile.LoadUint8(&o.SRAMPRCR.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetSRAMPRCR() uint8 {
	return volatile.LoadUint8(&o.SRAMPRCR.Reg) & 0x1
}
func (o *SRAM_Type) SetSRAMPRCR_KW(value uint8) {
	volatile.StoreUint8(&o.SRAMPRCR.Reg, volatile.LoadUint8(&o.SRAMPRCR.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetSRAMPRCR_KW() uint8 {
	return (volatile.LoadUint8(&o.SRAMPRCR.Reg) & 0xfe) >> 1
}

// SRAM.SRAMWTSC: SRAM Wait State Control Register
func (o *SRAM_Type) SetSRAMWTSC_SRAM0WTEN(value uint8) {
	volatile.StoreUint8(&o.SRAMWTSC.Reg, volatile.LoadUint8(&o.SRAMWTSC.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetSRAMWTSC_SRAM0WTEN() uint8 {
	return volatile.LoadUint8(&o.SRAMWTSC.Reg) & 0x1
}

// SRAM.SRAMPRCR2: SRAM Protection Register 2
func (o *SRAM_Type) SetSRAMPRCR2(value uint8) {
	volatile.StoreUint8(&o.SRAMPRCR2.Reg, volatile.LoadUint8(&o.SRAMPRCR2.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetSRAMPRCR2() uint8 {
	return volatile.LoadUint8(&o.SRAMPRCR2.Reg) & 0x1
}
func (o *SRAM_Type) SetSRAMPRCR2_KW(value uint8) {
	volatile.StoreUint8(&o.SRAMPRCR2.Reg, volatile.LoadUint8(&o.SRAMPRCR2.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetSRAMPRCR2_KW() uint8 {
	return (volatile.LoadUint8(&o.SRAMPRCR2.Reg) & 0xfe) >> 1
}

// Bus Control
type BUS_Type struct {
	_              [4352]byte
	BUSSCNTFHBIU   volatile.Register16 // 0x1100
	_              [2]byte
	BUSSCNTFLBIU   volatile.Register16 // 0x1104
	_              [10]byte
	BUSSCNTS0BIU   volatile.Register16 // 0x1110
	_              [14]byte
	BUSSCNTPSBIU   volatile.Register16 // 0x1120
	_              [14]byte
	BUSSCNTPLBIU   volatile.Register16 // 0x1130
	_              [2]byte
	BUSSCNTPHBIU   volatile.Register16 // 0x1134
	_              [10]byte
	BUSSCNTEQBIU   volatile.Register16 // 0x1140
	_              [1726]byte
	BUS1ERRADD     volatile.Register32 // 0x1800
	BUS1ERRRW      volatile.Register8  // 0x1804
	_              [11]byte
	BUS2ERRADD     volatile.Register32 // 0x1810
	BUS2ERRRW      volatile.Register8  // 0x1814
	_              [11]byte
	BUS3ERRADD     volatile.Register32 // 0x1820
	BUS3ERRRW      volatile.Register8  // 0x1824
	_              [11]byte
	BUS4ERRADD     volatile.Register32 // 0x1830
	BUS4ERRRW      volatile.Register8  // 0x1834
	_              [203]byte
	BTZF1ERRADD    volatile.Register32 // 0x1900
	BTZF1ERRRW     volatile.Register8  // 0x1904
	_              [11]byte
	BTZF2ERRADD    volatile.Register32 // 0x1910
	BTZF2ERRRW     volatile.Register8  // 0x1914
	_              [11]byte
	BTZF3ERRADD    volatile.Register32 // 0x1920
	BTZF3ERRRW     volatile.Register8  // 0x1924
	_              [11]byte
	BTZF4ERRADD    volatile.Register32 // 0x1930
	BTZF4ERRRW     volatile.Register8  // 0x1934
	_              [203]byte
	BUS1ERRSTAT    volatile.Register8 // 0x1A00
	_              [7]byte
	BUS1ERRCLR     volatile.Register8 // 0x1A08
	_              [7]byte
	BUS2ERRSTAT    volatile.Register8 // 0x1A10
	_              [7]byte
	BUS2ERRCLR     volatile.Register8 // 0x1A18
	_              [7]byte
	BUS3ERRSTAT    volatile.Register8 // 0x1A20
	_              [3]byte
	DMACDTCERRSTAT volatile.Register8 // 0x1A24
	_              [3]byte
	BUS3ERRCLR     volatile.Register8 // 0x1A28
	_              [3]byte
	DMACDTCERRCLR  volatile.Register8 // 0x1A2C
	_              [3]byte
	BUS4ERRSTAT    volatile.Register8 // 0x1A30
	_              [7]byte
	BUS4ERRCLR     volatile.Register8 // 0x1A38
}

// BUS.BUSSCNTFHBIU: Slave Bus Control Register
func (o *BUS_Type) SetBUSSCNTFHBIU_ARBS(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFHBIU.Reg, volatile.LoadUint16(&o.BUSSCNTFHBIU.Reg)&^(0x3)|value)
}
func (o *BUS_Type) GetBUSSCNTFHBIU_ARBS() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTFHBIU.Reg) & 0x3
}

// BUS.BUSSCNTFLBIU: Slave Bus Control Register
func (o *BUS_Type) SetBUSSCNTFLBIU_ARBS(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFLBIU.Reg, volatile.LoadUint16(&o.BUSSCNTFLBIU.Reg)&^(0x3)|value)
}
func (o *BUS_Type) GetBUSSCNTFLBIU_ARBS() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTFLBIU.Reg) & 0x3
}

// BUS.BUSSCNTS0BIU: Slave Bus Control Register
func (o *BUS_Type) SetBUSSCNTS0BIU_ARBS(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTS0BIU.Reg, volatile.LoadUint16(&o.BUSSCNTS0BIU.Reg)&^(0x3)|value)
}
func (o *BUS_Type) GetBUSSCNTS0BIU_ARBS() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTS0BIU.Reg) & 0x3
}

// BUS.BUSSCNTPSBIU: Slave Bus Control Register
func (o *BUS_Type) SetBUSSCNTPSBIU_ARBS(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTPSBIU.Reg, volatile.LoadUint16(&o.BUSSCNTPSBIU.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUSSCNTPSBIU_ARBS() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTPSBIU.Reg) & 0x1
}

// BUS.BUSSCNTPLBIU: Slave Bus Control Register
func (o *BUS_Type) SetBUSSCNTPLBIU_ARBS(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTPLBIU.Reg, volatile.LoadUint16(&o.BUSSCNTPLBIU.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUSSCNTPLBIU_ARBS() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTPLBIU.Reg) & 0x1
}

// BUS.BUSSCNTPHBIU: Slave Bus Control Register
func (o *BUS_Type) SetBUSSCNTPHBIU_ARBS(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTPHBIU.Reg, volatile.LoadUint16(&o.BUSSCNTPHBIU.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUSSCNTPHBIU_ARBS() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTPHBIU.Reg) & 0x1
}

// BUS.BUSSCNTEQBIU: Slave Bus Control Register
func (o *BUS_Type) SetBUSSCNTEQBIU_ARBS(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTEQBIU.Reg, volatile.LoadUint16(&o.BUSSCNTEQBIU.Reg)&^(0x3)|value)
}
func (o *BUS_Type) GetBUSSCNTEQBIU_ARBS() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTEQBIU.Reg) & 0x3
}

// BUS.BUS1ERRADD: BUS Error Address Register
func (o *BUS_Type) SetBUS1ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS1ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS1ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS1ERRADD.Reg)
}

// BUS.BUS1ERRRW: BUS Error Read Write Register
func (o *BUS_Type) SetBUS1ERRRW_RWSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRRW.Reg, volatile.LoadUint8(&o.BUS1ERRRW.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS1ERRRW_RWSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS1ERRRW.Reg) & 0x1
}

// BUS.BUS2ERRADD: BUS Error Address Register
func (o *BUS_Type) SetBUS2ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS2ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS2ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS2ERRADD.Reg)
}

// BUS.BUS2ERRRW: BUS Error Read Write Register
func (o *BUS_Type) SetBUS2ERRRW_RWSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRRW.Reg, volatile.LoadUint8(&o.BUS2ERRRW.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS2ERRRW_RWSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS2ERRRW.Reg) & 0x1
}

// BUS.BUS3ERRADD: BUS Error Address Register
func (o *BUS_Type) SetBUS3ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS3ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS3ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS3ERRADD.Reg)
}

// BUS.BUS3ERRRW: BUS Error Read Write Register
func (o *BUS_Type) SetBUS3ERRRW_RWSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRRW.Reg, volatile.LoadUint8(&o.BUS3ERRRW.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS3ERRRW_RWSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS3ERRRW.Reg) & 0x1
}

// BUS.BUS4ERRADD: BUS Error Address Register
func (o *BUS_Type) SetBUS4ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS4ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS4ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS4ERRADD.Reg)
}

// BUS.BUS4ERRRW: BUS Error Read Write Register
func (o *BUS_Type) SetBUS4ERRRW_RWSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRRW.Reg, volatile.LoadUint8(&o.BUS4ERRRW.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS4ERRRW_RWSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS4ERRRW.Reg) & 0x1
}

// BUS.BTZF1ERRADD: BUS TZF Error Address Register
func (o *BUS_Type) SetBTZF1ERRADD(value uint32) {
	volatile.StoreUint32(&o.BTZF1ERRADD.Reg, value)
}
func (o *BUS_Type) GetBTZF1ERRADD() uint32 {
	return volatile.LoadUint32(&o.BTZF1ERRADD.Reg)
}

// BUS.BTZF1ERRRW: BUS TZF Error Read Write Register
func (o *BUS_Type) SetBTZF1ERRRW_TRWSTAT(value uint8) {
	volatile.StoreUint8(&o.BTZF1ERRRW.Reg, volatile.LoadUint8(&o.BTZF1ERRRW.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBTZF1ERRRW_TRWSTAT() uint8 {
	return volatile.LoadUint8(&o.BTZF1ERRRW.Reg) & 0x1
}

// BUS.BTZF2ERRADD: BUS TZF Error Address Register
func (o *BUS_Type) SetBTZF2ERRADD(value uint32) {
	volatile.StoreUint32(&o.BTZF2ERRADD.Reg, value)
}
func (o *BUS_Type) GetBTZF2ERRADD() uint32 {
	return volatile.LoadUint32(&o.BTZF2ERRADD.Reg)
}

// BUS.BTZF2ERRRW: BUS TZF Error Read Write Register
func (o *BUS_Type) SetBTZF2ERRRW_TRWSTAT(value uint8) {
	volatile.StoreUint8(&o.BTZF2ERRRW.Reg, volatile.LoadUint8(&o.BTZF2ERRRW.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBTZF2ERRRW_TRWSTAT() uint8 {
	return volatile.LoadUint8(&o.BTZF2ERRRW.Reg) & 0x1
}

// BUS.BTZF3ERRADD: BUS TZF Error Address Register
func (o *BUS_Type) SetBTZF3ERRADD(value uint32) {
	volatile.StoreUint32(&o.BTZF3ERRADD.Reg, value)
}
func (o *BUS_Type) GetBTZF3ERRADD() uint32 {
	return volatile.LoadUint32(&o.BTZF3ERRADD.Reg)
}

// BUS.BTZF3ERRRW: BUS TZF Error Read Write Register
func (o *BUS_Type) SetBTZF3ERRRW_TRWSTAT(value uint8) {
	volatile.StoreUint8(&o.BTZF3ERRRW.Reg, volatile.LoadUint8(&o.BTZF3ERRRW.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBTZF3ERRRW_TRWSTAT() uint8 {
	return volatile.LoadUint8(&o.BTZF3ERRRW.Reg) & 0x1
}

// BUS.BTZF4ERRADD: BUS TZF Error Address Register
func (o *BUS_Type) SetBTZF4ERRADD(value uint32) {
	volatile.StoreUint32(&o.BTZF4ERRADD.Reg, value)
}
func (o *BUS_Type) GetBTZF4ERRADD() uint32 {
	return volatile.LoadUint32(&o.BTZF4ERRADD.Reg)
}

// BUS.BTZF4ERRRW: BUS TZF Error Read Write Register
func (o *BUS_Type) SetBTZF4ERRRW_TRWSTAT(value uint8) {
	volatile.StoreUint8(&o.BTZF4ERRRW.Reg, volatile.LoadUint8(&o.BTZF4ERRRW.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBTZF4ERRRW_TRWSTAT() uint8 {
	return volatile.LoadUint8(&o.BTZF4ERRRW.Reg) & 0x1
}

// BUS.BUS1ERRSTAT: BUS Error Status Register %s
func (o *BUS_Type) SetBUS1ERRSTAT_SLERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRSTAT.Reg, volatile.LoadUint8(&o.BUS1ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS1ERRSTAT_SLERRSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS1ERRSTAT.Reg) & 0x1
}
func (o *BUS_Type) SetBUS1ERRSTAT_STERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRSTAT.Reg, volatile.LoadUint8(&o.BUS1ERRSTAT.Reg)&^(0x2)|value<<1)
}
func (o *BUS_Type) GetBUS1ERRSTAT_STERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS1ERRSTAT.Reg) & 0x2) >> 1
}
func (o *BUS_Type) SetBUS1ERRSTAT_MMERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRSTAT.Reg, volatile.LoadUint8(&o.BUS1ERRSTAT.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetBUS1ERRSTAT_MMERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS1ERRSTAT.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetBUS1ERRSTAT_ILERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRSTAT.Reg, volatile.LoadUint8(&o.BUS1ERRSTAT.Reg)&^(0x10)|value<<4)
}
func (o *BUS_Type) GetBUS1ERRSTAT_ILERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS1ERRSTAT.Reg) & 0x10) >> 4
}

// BUS.BUS1ERRCLR: BUS Error Clear Register %s
func (o *BUS_Type) SetBUS1ERRCLR_SLERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRCLR.Reg, volatile.LoadUint8(&o.BUS1ERRCLR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS1ERRCLR_SLERRCLR() uint8 {
	return volatile.LoadUint8(&o.BUS1ERRCLR.Reg) & 0x1
}
func (o *BUS_Type) SetBUS1ERRCLR_STERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRCLR.Reg, volatile.LoadUint8(&o.BUS1ERRCLR.Reg)&^(0x2)|value<<1)
}
func (o *BUS_Type) GetBUS1ERRCLR_STERRCLR() uint8 {
	return (volatile.LoadUint8(&o.BUS1ERRCLR.Reg) & 0x2) >> 1
}
func (o *BUS_Type) SetBUS1ERRCLR_MMERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRCLR.Reg, volatile.LoadUint8(&o.BUS1ERRCLR.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetBUS1ERRCLR_MMERRCLR() uint8 {
	return (volatile.LoadUint8(&o.BUS1ERRCLR.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetBUS1ERRCLR_ILERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRCLR.Reg, volatile.LoadUint8(&o.BUS1ERRCLR.Reg)&^(0x10)|value<<4)
}
func (o *BUS_Type) GetBUS1ERRCLR_ILERRCLR() uint8 {
	return (volatile.LoadUint8(&o.BUS1ERRCLR.Reg) & 0x10) >> 4
}

// BUS.BUS2ERRSTAT: BUS Error Status Register %s
func (o *BUS_Type) SetBUS2ERRSTAT_SLERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRSTAT.Reg, volatile.LoadUint8(&o.BUS2ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS2ERRSTAT_SLERRSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS2ERRSTAT.Reg) & 0x1
}
func (o *BUS_Type) SetBUS2ERRSTAT_STERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRSTAT.Reg, volatile.LoadUint8(&o.BUS2ERRSTAT.Reg)&^(0x2)|value<<1)
}
func (o *BUS_Type) GetBUS2ERRSTAT_STERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS2ERRSTAT.Reg) & 0x2) >> 1
}
func (o *BUS_Type) SetBUS2ERRSTAT_MMERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRSTAT.Reg, volatile.LoadUint8(&o.BUS2ERRSTAT.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetBUS2ERRSTAT_MMERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS2ERRSTAT.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetBUS2ERRSTAT_ILERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRSTAT.Reg, volatile.LoadUint8(&o.BUS2ERRSTAT.Reg)&^(0x10)|value<<4)
}
func (o *BUS_Type) GetBUS2ERRSTAT_ILERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS2ERRSTAT.Reg) & 0x10) >> 4
}

// BUS.BUS2ERRCLR: BUS Error Clear Register %s
func (o *BUS_Type) SetBUS2ERRCLR_SLERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRCLR.Reg, volatile.LoadUint8(&o.BUS2ERRCLR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS2ERRCLR_SLERRCLR() uint8 {
	return volatile.LoadUint8(&o.BUS2ERRCLR.Reg) & 0x1
}
func (o *BUS_Type) SetBUS2ERRCLR_STERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRCLR.Reg, volatile.LoadUint8(&o.BUS2ERRCLR.Reg)&^(0x2)|value<<1)
}
func (o *BUS_Type) GetBUS2ERRCLR_STERRCLR() uint8 {
	return (volatile.LoadUint8(&o.BUS2ERRCLR.Reg) & 0x2) >> 1
}
func (o *BUS_Type) SetBUS2ERRCLR_MMERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRCLR.Reg, volatile.LoadUint8(&o.BUS2ERRCLR.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetBUS2ERRCLR_MMERRCLR() uint8 {
	return (volatile.LoadUint8(&o.BUS2ERRCLR.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetBUS2ERRCLR_ILERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRCLR.Reg, volatile.LoadUint8(&o.BUS2ERRCLR.Reg)&^(0x10)|value<<4)
}
func (o *BUS_Type) GetBUS2ERRCLR_ILERRCLR() uint8 {
	return (volatile.LoadUint8(&o.BUS2ERRCLR.Reg) & 0x10) >> 4
}

// BUS.BUS3ERRSTAT: BUS Error Status Register %s
func (o *BUS_Type) SetBUS3ERRSTAT_SLERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS3ERRSTAT_SLERRSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x1
}
func (o *BUS_Type) SetBUS3ERRSTAT_STERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x2)|value<<1)
}
func (o *BUS_Type) GetBUS3ERRSTAT_STERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x2) >> 1
}
func (o *BUS_Type) SetBUS3ERRSTAT_MMERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetBUS3ERRSTAT_MMERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetBUS3ERRSTAT_ILERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x10)|value<<4)
}
func (o *BUS_Type) GetBUS3ERRSTAT_ILERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x10) >> 4
}

// BUS.DMACDTCERRSTAT: DMAC/DTC Error Status Register
func (o *BUS_Type) SetDMACDTCERRSTAT_MTERRSTAT(value uint8) {
	volatile.StoreUint8(&o.DMACDTCERRSTAT.Reg, volatile.LoadUint8(&o.DMACDTCERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetDMACDTCERRSTAT_MTERRSTAT() uint8 {
	return volatile.LoadUint8(&o.DMACDTCERRSTAT.Reg) & 0x1
}

// BUS.BUS3ERRCLR: BUS Error Clear Register %s
func (o *BUS_Type) SetBUS3ERRCLR_SLERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRCLR.Reg, volatile.LoadUint8(&o.BUS3ERRCLR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS3ERRCLR_SLERRCLR() uint8 {
	return volatile.LoadUint8(&o.BUS3ERRCLR.Reg) & 0x1
}
func (o *BUS_Type) SetBUS3ERRCLR_STERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRCLR.Reg, volatile.LoadUint8(&o.BUS3ERRCLR.Reg)&^(0x2)|value<<1)
}
func (o *BUS_Type) GetBUS3ERRCLR_STERRCLR() uint8 {
	return (volatile.LoadUint8(&o.BUS3ERRCLR.Reg) & 0x2) >> 1
}
func (o *BUS_Type) SetBUS3ERRCLR_MMERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRCLR.Reg, volatile.LoadUint8(&o.BUS3ERRCLR.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetBUS3ERRCLR_MMERRCLR() uint8 {
	return (volatile.LoadUint8(&o.BUS3ERRCLR.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetBUS3ERRCLR_ILERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRCLR.Reg, volatile.LoadUint8(&o.BUS3ERRCLR.Reg)&^(0x10)|value<<4)
}
func (o *BUS_Type) GetBUS3ERRCLR_ILERRCLR() uint8 {
	return (volatile.LoadUint8(&o.BUS3ERRCLR.Reg) & 0x10) >> 4
}

// BUS.DMACDTCERRCLR: DMAC/DTC Error Clear Register
func (o *BUS_Type) SetDMACDTCERRCLR_MTERRCLR(value uint8) {
	volatile.StoreUint8(&o.DMACDTCERRCLR.Reg, volatile.LoadUint8(&o.DMACDTCERRCLR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetDMACDTCERRCLR_MTERRCLR() uint8 {
	return volatile.LoadUint8(&o.DMACDTCERRCLR.Reg) & 0x1
}

// BUS.BUS4ERRSTAT: BUS Error Status Register %s
func (o *BUS_Type) SetBUS4ERRSTAT_SLERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS4ERRSTAT_SLERRSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x1
}
func (o *BUS_Type) SetBUS4ERRSTAT_STERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x2)|value<<1)
}
func (o *BUS_Type) GetBUS4ERRSTAT_STERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x2) >> 1
}
func (o *BUS_Type) SetBUS4ERRSTAT_MMERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetBUS4ERRSTAT_MMERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetBUS4ERRSTAT_ILERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x10)|value<<4)
}
func (o *BUS_Type) GetBUS4ERRSTAT_ILERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x10) >> 4
}

// BUS.BUS4ERRCLR: BUS Error Clear Register %s
func (o *BUS_Type) SetBUS4ERRCLR_SLERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRCLR.Reg, volatile.LoadUint8(&o.BUS4ERRCLR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS4ERRCLR_SLERRCLR() uint8 {
	return volatile.LoadUint8(&o.BUS4ERRCLR.Reg) & 0x1
}
func (o *BUS_Type) SetBUS4ERRCLR_STERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRCLR.Reg, volatile.LoadUint8(&o.BUS4ERRCLR.Reg)&^(0x2)|value<<1)
}
func (o *BUS_Type) GetBUS4ERRCLR_STERRCLR() uint8 {
	return (volatile.LoadUint8(&o.BUS4ERRCLR.Reg) & 0x2) >> 1
}
func (o *BUS_Type) SetBUS4ERRCLR_MMERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRCLR.Reg, volatile.LoadUint8(&o.BUS4ERRCLR.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetBUS4ERRCLR_MMERRCLR() uint8 {
	return (volatile.LoadUint8(&o.BUS4ERRCLR.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetBUS4ERRCLR_ILERRCLR(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRCLR.Reg, volatile.LoadUint8(&o.BUS4ERRCLR.Reg)&^(0x10)|value<<4)
}
func (o *BUS_Type) GetBUS4ERRCLR_ILERRCLR() uint8 {
	return (volatile.LoadUint8(&o.BUS4ERRCLR.Reg) & 0x10) >> 4
}

// Direct memory access controller 0
type DMAC0_Type struct {
	DMSAR volatile.Register32 // 0x0
	DMDAR volatile.Register32 // 0x4
	DMCRA volatile.Register32 // 0x8
	DMCRB volatile.Register32 // 0xC
	DMTMD volatile.Register16 // 0x10
	_     byte
	DMINT volatile.Register8  // 0x13
	DMAMD volatile.Register16 // 0x14
	_     [2]byte
	DMOFR volatile.Register32 // 0x18
	DMCNT volatile.Register8  // 0x1C
	DMREQ volatile.Register8  // 0x1D
	DMSTS volatile.Register8  // 0x1E
	_     byte
	DMSRR volatile.Register32 // 0x20
	DMDRR volatile.Register32 // 0x24
	DMSBS volatile.Register32 // 0x28
	DMDBS volatile.Register32 // 0x2C
}

// DMAC0.DMCRA: DMA Transfer Count Register
func (o *DMAC0_Type) SetDMCRA_DMCRAL(value uint32) {
	volatile.StoreUint32(&o.DMCRA.Reg, volatile.LoadUint32(&o.DMCRA.Reg)&^(0xffff)|value)
}
func (o *DMAC0_Type) GetDMCRA_DMCRAL() uint32 {
	return volatile.LoadUint32(&o.DMCRA.Reg) & 0xffff
}
func (o *DMAC0_Type) SetDMCRA_DMCRAH(value uint32) {
	volatile.StoreUint32(&o.DMCRA.Reg, volatile.LoadUint32(&o.DMCRA.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC0_Type) GetDMCRA_DMCRAH() uint32 {
	return (volatile.LoadUint32(&o.DMCRA.Reg) & 0x3ff0000) >> 16
}

// DMAC0.DMCRB: DMA Block Transfer Count Register
func (o *DMAC0_Type) SetDMCRB_DMCRBL(value uint32) {
	volatile.StoreUint32(&o.DMCRB.Reg, volatile.LoadUint32(&o.DMCRB.Reg)&^(0xffff)|value)
}
func (o *DMAC0_Type) GetDMCRB_DMCRBL() uint32 {
	return volatile.LoadUint32(&o.DMCRB.Reg) & 0xffff
}
func (o *DMAC0_Type) SetDMCRB_DMCRBH(value uint32) {
	volatile.StoreUint32(&o.DMCRB.Reg, volatile.LoadUint32(&o.DMCRB.Reg)&^(0xffff0000)|value<<16)
}
func (o *DMAC0_Type) GetDMCRB_DMCRBH() uint32 {
	return (volatile.LoadUint32(&o.DMCRB.Reg) & 0xffff0000) >> 16
}

// DMAC0.DMTMD: DMA Transfer Mode Register
func (o *DMAC0_Type) SetDMTMD_DCTG(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0x3)|value)
}
func (o *DMAC0_Type) GetDMTMD_DCTG() uint16 {
	return volatile.LoadUint16(&o.DMTMD.Reg) & 0x3
}
func (o *DMAC0_Type) SetDMTMD_SZ(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0x300)|value<<8)
}
func (o *DMAC0_Type) GetDMTMD_SZ() uint16 {
	return (volatile.LoadUint16(&o.DMTMD.Reg) & 0x300) >> 8
}
func (o *DMAC0_Type) SetDMTMD_TKP(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0x400)|value<<10)
}
func (o *DMAC0_Type) GetDMTMD_TKP() uint16 {
	return (volatile.LoadUint16(&o.DMTMD.Reg) & 0x400) >> 10
}
func (o *DMAC0_Type) SetDMTMD_DTS(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0x3000)|value<<12)
}
func (o *DMAC0_Type) GetDMTMD_DTS() uint16 {
	return (volatile.LoadUint16(&o.DMTMD.Reg) & 0x3000) >> 12
}
func (o *DMAC0_Type) SetDMTMD_MD(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC0_Type) GetDMTMD_MD() uint16 {
	return (volatile.LoadUint16(&o.DMTMD.Reg) & 0xc000) >> 14
}

// DMAC0.DMINT: DMA Interrupt Setting Register
func (o *DMAC0_Type) SetDMINT_DARIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x1)|value)
}
func (o *DMAC0_Type) GetDMINT_DARIE() uint8 {
	return volatile.LoadUint8(&o.DMINT.Reg) & 0x1
}
func (o *DMAC0_Type) SetDMINT_SARIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x2)|value<<1)
}
func (o *DMAC0_Type) GetDMINT_SARIE() uint8 {
	return (volatile.LoadUint8(&o.DMINT.Reg) & 0x2) >> 1
}
func (o *DMAC0_Type) SetDMINT_RPTIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x4)|value<<2)
}
func (o *DMAC0_Type) GetDMINT_RPTIE() uint8 {
	return (volatile.LoadUint8(&o.DMINT.Reg) & 0x4) >> 2
}
func (o *DMAC0_Type) SetDMINT_ESIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x8)|value<<3)
}
func (o *DMAC0_Type) GetDMINT_ESIE() uint8 {
	return (volatile.LoadUint8(&o.DMINT.Reg) & 0x8) >> 3
}
func (o *DMAC0_Type) SetDMINT_DTIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x10)|value<<4)
}
func (o *DMAC0_Type) GetDMINT_DTIE() uint8 {
	return (volatile.LoadUint8(&o.DMINT.Reg) & 0x10) >> 4
}

// DMAC0.DMAMD: DMA Address Mode Register
func (o *DMAC0_Type) SetDMAMD_DARA(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0x1f)|value)
}
func (o *DMAC0_Type) GetDMAMD_DARA() uint16 {
	return volatile.LoadUint16(&o.DMAMD.Reg) & 0x1f
}
func (o *DMAC0_Type) SetDMAMD_DADR(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0x20)|value<<5)
}
func (o *DMAC0_Type) GetDMAMD_DADR() uint16 {
	return (volatile.LoadUint16(&o.DMAMD.Reg) & 0x20) >> 5
}
func (o *DMAC0_Type) SetDMAMD_DM(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0xc0)|value<<6)
}
func (o *DMAC0_Type) GetDMAMD_DM() uint16 {
	return (volatile.LoadUint16(&o.DMAMD.Reg) & 0xc0) >> 6
}
func (o *DMAC0_Type) SetDMAMD_SARA(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0x1f00)|value<<8)
}
func (o *DMAC0_Type) GetDMAMD_SARA() uint16 {
	return (volatile.LoadUint16(&o.DMAMD.Reg) & 0x1f00) >> 8
}
func (o *DMAC0_Type) SetDMAMD_SADR(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC0_Type) GetDMAMD_SADR() uint16 {
	return (volatile.LoadUint16(&o.DMAMD.Reg) & 0x2000) >> 13
}
func (o *DMAC0_Type) SetDMAMD_SM(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC0_Type) GetDMAMD_SM() uint16 {
	return (volatile.LoadUint16(&o.DMAMD.Reg) & 0xc000) >> 14
}

// DMAC0.DMCNT: DMA Transfer Enable Register
func (o *DMAC0_Type) SetDMCNT_DTE(value uint8) {
	volatile.StoreUint8(&o.DMCNT.Reg, volatile.LoadUint8(&o.DMCNT.Reg)&^(0x1)|value)
}
func (o *DMAC0_Type) GetDMCNT_DTE() uint8 {
	return volatile.LoadUint8(&o.DMCNT.Reg) & 0x1
}

// DMAC0.DMREQ: DMA Software Start Register
func (o *DMAC0_Type) SetDMREQ_SWREQ(value uint8) {
	volatile.StoreUint8(&o.DMREQ.Reg, volatile.LoadUint8(&o.DMREQ.Reg)&^(0x1)|value)
}
func (o *DMAC0_Type) GetDMREQ_SWREQ() uint8 {
	return volatile.LoadUint8(&o.DMREQ.Reg) & 0x1
}
func (o *DMAC0_Type) SetDMREQ_CLRS(value uint8) {
	volatile.StoreUint8(&o.DMREQ.Reg, volatile.LoadUint8(&o.DMREQ.Reg)&^(0x10)|value<<4)
}
func (o *DMAC0_Type) GetDMREQ_CLRS() uint8 {
	return (volatile.LoadUint8(&o.DMREQ.Reg) & 0x10) >> 4
}

// DMAC0.DMSTS: DMA Status Register
func (o *DMAC0_Type) SetDMSTS_ESIF(value uint8) {
	volatile.StoreUint8(&o.DMSTS.Reg, volatile.LoadUint8(&o.DMSTS.Reg)&^(0x1)|value)
}
func (o *DMAC0_Type) GetDMSTS_ESIF() uint8 {
	return volatile.LoadUint8(&o.DMSTS.Reg) & 0x1
}
func (o *DMAC0_Type) SetDMSTS_DTIF(value uint8) {
	volatile.StoreUint8(&o.DMSTS.Reg, volatile.LoadUint8(&o.DMSTS.Reg)&^(0x10)|value<<4)
}
func (o *DMAC0_Type) GetDMSTS_DTIF() uint8 {
	return (volatile.LoadUint8(&o.DMSTS.Reg) & 0x10) >> 4
}
func (o *DMAC0_Type) SetDMSTS_ACT(value uint8) {
	volatile.StoreUint8(&o.DMSTS.Reg, volatile.LoadUint8(&o.DMSTS.Reg)&^(0x80)|value<<7)
}
func (o *DMAC0_Type) GetDMSTS_ACT() uint8 {
	return (volatile.LoadUint8(&o.DMSTS.Reg) & 0x80) >> 7
}

// DMAC0.DMSBS: DMA Source Buffer Size Register
func (o *DMAC0_Type) SetDMSBS_DMSBSL(value uint32) {
	volatile.StoreUint32(&o.DMSBS.Reg, volatile.LoadUint32(&o.DMSBS.Reg)&^(0xffff)|value)
}
func (o *DMAC0_Type) GetDMSBS_DMSBSL() uint32 {
	return volatile.LoadUint32(&o.DMSBS.Reg) & 0xffff
}
func (o *DMAC0_Type) SetDMSBS_DMSBSH(value uint32) {
	volatile.StoreUint32(&o.DMSBS.Reg, volatile.LoadUint32(&o.DMSBS.Reg)&^(0xffff0000)|value<<16)
}
func (o *DMAC0_Type) GetDMSBS_DMSBSH() uint32 {
	return (volatile.LoadUint32(&o.DMSBS.Reg) & 0xffff0000) >> 16
}

// DMAC0.DMDBS: DMA Destination Buffer Size Register
func (o *DMAC0_Type) SetDMDBS_DMDBSL(value uint32) {
	volatile.StoreUint32(&o.DMDBS.Reg, volatile.LoadUint32(&o.DMDBS.Reg)&^(0xffff)|value)
}
func (o *DMAC0_Type) GetDMDBS_DMDBSL() uint32 {
	return volatile.LoadUint32(&o.DMDBS.Reg) & 0xffff
}
func (o *DMAC0_Type) SetDMDBS_DMDBSH(value uint32) {
	volatile.StoreUint32(&o.DMDBS.Reg, volatile.LoadUint32(&o.DMDBS.Reg)&^(0xffff0000)|value<<16)
}
func (o *DMAC0_Type) GetDMDBS_DMDBSH() uint32 {
	return (volatile.LoadUint32(&o.DMDBS.Reg) & 0xffff0000) >> 16
}

// DMAC Module Activation
type DMA_Type struct {
	DMAST  volatile.Register8 // 0x0
	_      [63]byte
	DMECHR volatile.Register32 // 0x40
}

// DMA.DMAST: DMA Module Activation Register
func (o *DMA_Type) SetDMAST_DMST(value uint8) {
	volatile.StoreUint8(&o.DMAST.Reg, volatile.LoadUint8(&o.DMAST.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetDMAST_DMST() uint8 {
	return volatile.LoadUint8(&o.DMAST.Reg) & 0x1
}

// DMA.DMECHR: DMAC Error Channel Register
func (o *DMA_Type) SetDMECHR_DMECH(value uint32) {
	volatile.StoreUint32(&o.DMECHR.Reg, volatile.LoadUint32(&o.DMECHR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetDMECHR_DMECH() uint32 {
	return volatile.LoadUint32(&o.DMECHR.Reg) & 0x7
}
func (o *DMA_Type) SetDMECHR_DMECHSAM(value uint32) {
	volatile.StoreUint32(&o.DMECHR.Reg, volatile.LoadUint32(&o.DMECHR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetDMECHR_DMECHSAM() uint32 {
	return (volatile.LoadUint32(&o.DMECHR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetDMECHR_DMESTA(value uint32) {
	volatile.StoreUint32(&o.DMECHR.Reg, volatile.LoadUint32(&o.DMECHR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetDMECHR_DMESTA() uint32 {
	return (volatile.LoadUint32(&o.DMECHR.Reg) & 0x10000) >> 16
}

// Data Transfer Controller
type DTC_Type struct {
	DTCCR      volatile.Register8 // 0x0
	_          [3]byte
	DTCVBR     volatile.Register32 // 0x4
	_          [4]byte
	DTCST      volatile.Register8 // 0xC
	_          byte
	DTCSTS     volatile.Register16 // 0xE
	DTCCR_SEC  volatile.Register8  // 0x10
	_          [3]byte
	DTCVBR_SEC volatile.Register32 // 0x14
	_          [8]byte
	DTEVR      volatile.Register32 // 0x20
}

// DTC.DTCCR: DTC Control Register
func (o *DTC_Type) SetDTCCR_RRS(value uint8) {
	volatile.StoreUint8(&o.DTCCR.Reg, volatile.LoadUint8(&o.DTCCR.Reg)&^(0x10)|value<<4)
}
func (o *DTC_Type) GetDTCCR_RRS() uint8 {
	return (volatile.LoadUint8(&o.DTCCR.Reg) & 0x10) >> 4
}

// DTC.DTCST: DTC Module Start Register
func (o *DTC_Type) SetDTCST(value uint8) {
	volatile.StoreUint8(&o.DTCST.Reg, volatile.LoadUint8(&o.DTCST.Reg)&^(0x1)|value)
}
func (o *DTC_Type) GetDTCST() uint8 {
	return volatile.LoadUint8(&o.DTCST.Reg) & 0x1
}

// DTC.DTCSTS: DTC Status Register
func (o *DTC_Type) SetDTCSTS_VECN(value uint16) {
	volatile.StoreUint16(&o.DTCSTS.Reg, volatile.LoadUint16(&o.DTCSTS.Reg)&^(0xff)|value)
}
func (o *DTC_Type) GetDTCSTS_VECN() uint16 {
	return volatile.LoadUint16(&o.DTCSTS.Reg) & 0xff
}
func (o *DTC_Type) SetDTCSTS_ACT(value uint16) {
	volatile.StoreUint16(&o.DTCSTS.Reg, volatile.LoadUint16(&o.DTCSTS.Reg)&^(0x8000)|value<<15)
}
func (o *DTC_Type) GetDTCSTS_ACT() uint16 {
	return (volatile.LoadUint16(&o.DTCSTS.Reg) & 0x8000) >> 15
}

// DTC.DTCCR_SEC: DTC Control Register for secure Region
func (o *DTC_Type) SetDTCCR_SEC_RRS(value uint8) {
	volatile.StoreUint8(&o.DTCCR_SEC.Reg, volatile.LoadUint8(&o.DTCCR_SEC.Reg)&^(0x10)|value<<4)
}
func (o *DTC_Type) GetDTCCR_SEC_RRS() uint8 {
	return (volatile.LoadUint8(&o.DTCCR_SEC.Reg) & 0x10) >> 4
}

// DTC.DTEVR: DTC Error Vector Register
func (o *DTC_Type) SetDTEVR_DTEV(value uint32) {
	volatile.StoreUint32(&o.DTEVR.Reg, volatile.LoadUint32(&o.DTEVR.Reg)&^(0xff)|value)
}
func (o *DTC_Type) GetDTEVR_DTEV() uint32 {
	return volatile.LoadUint32(&o.DTEVR.Reg) & 0xff
}
func (o *DTC_Type) SetDTEVR_DTEVSAM(value uint32) {
	volatile.StoreUint32(&o.DTEVR.Reg, volatile.LoadUint32(&o.DTEVR.Reg)&^(0x100)|value<<8)
}
func (o *DTC_Type) GetDTEVR_DTEVSAM() uint32 {
	return (volatile.LoadUint32(&o.DTEVR.Reg) & 0x100) >> 8
}
func (o *DTC_Type) SetDTEVR_DTESTA(value uint32) {
	volatile.StoreUint32(&o.DTEVR.Reg, volatile.LoadUint32(&o.DTEVR.Reg)&^(0x10000)|value<<16)
}
func (o *DTC_Type) GetDTEVR_DTESTA() uint32 {
	return (volatile.LoadUint32(&o.DTEVR.Reg) & 0x10000) >> 16
}

// Interrupt Controller
type ICU_Type struct {
	IRQCR0  volatile.Register8 // 0x0
	IRQCR1  volatile.Register8 // 0x1
	IRQCR2  volatile.Register8 // 0x2
	IRQCR3  volatile.Register8 // 0x3
	IRQCR4  volatile.Register8 // 0x4
	IRQCR5  volatile.Register8 // 0x5
	IRQCR6  volatile.Register8 // 0x6
	IRQCR7  volatile.Register8 // 0x7
	IRQCR8  volatile.Register8 // 0x8
	IRQCR9  volatile.Register8 // 0x9
	IRQCR10 volatile.Register8 // 0xA
	IRQCR11 volatile.Register8 // 0xB
	IRQCR12 volatile.Register8 // 0xC
	IRQCR13 volatile.Register8 // 0xD
	IRQCR14 volatile.Register8 // 0xE
	IRQCR15 volatile.Register8 // 0xF
	_       [240]byte
	NMICR   volatile.Register8 // 0x100
	_       [31]byte
	NMIER   volatile.Register16 // 0x120
	_       [14]byte
	NMICLR  volatile.Register16 // 0x130
	_       [14]byte
	NMISR   volatile.Register16 // 0x140
	_       [94]byte
	WUPEN0  volatile.Register32 // 0x1A0
	WUPEN1  volatile.Register32 // 0x1A4
	_       [88]byte
	SELSR0  volatile.Register16 // 0x200
	_       [126]byte
	DELSR0  volatile.Register32 // 0x280
	DELSR1  volatile.Register32 // 0x284
	DELSR2  volatile.Register32 // 0x288
	DELSR3  volatile.Register32 // 0x28C
	DELSR4  volatile.Register32 // 0x290
	DELSR5  volatile.Register32 // 0x294
	DELSR6  volatile.Register32 // 0x298
	DELSR7  volatile.Register32 // 0x29C
	_       [96]byte
	IELSR0  volatile.Register32 // 0x300
	IELSR1  volatile.Register32 // 0x304
	IELSR2  volatile.Register32 // 0x308
	IELSR3  volatile.Register32 // 0x30C
	IELSR4  volatile.Register32 // 0x310
	IELSR5  volatile.Register32 // 0x314
	IELSR6  volatile.Register32 // 0x318
	IELSR7  volatile.Register32 // 0x31C
	IELSR8  volatile.Register32 // 0x320
	IELSR9  volatile.Register32 // 0x324
	IELSR10 volatile.Register32 // 0x328
	IELSR11 volatile.Register32 // 0x32C
	IELSR12 volatile.Register32 // 0x330
	IELSR13 volatile.Register32 // 0x334
	IELSR14 volatile.Register32 // 0x338
	IELSR15 volatile.Register32 // 0x33C
	IELSR16 volatile.Register32 // 0x340
	IELSR17 volatile.Register32 // 0x344
	IELSR18 volatile.Register32 // 0x348
	IELSR19 volatile.Register32 // 0x34C
	IELSR20 volatile.Register32 // 0x350
	IELSR21 volatile.Register32 // 0x354
	IELSR22 volatile.Register32 // 0x358
	IELSR23 volatile.Register32 // 0x35C
	IELSR24 volatile.Register32 // 0x360
	IELSR25 volatile.Register32 // 0x364
	IELSR26 volatile.Register32 // 0x368
	IELSR27 volatile.Register32 // 0x36C
	IELSR28 volatile.Register32 // 0x370
	IELSR29 volatile.Register32 // 0x374
	IELSR30 volatile.Register32 // 0x378
	IELSR31 volatile.Register32 // 0x37C
	IELSR32 volatile.Register32 // 0x380
	IELSR33 volatile.Register32 // 0x384
	IELSR34 volatile.Register32 // 0x388
	IELSR35 volatile.Register32 // 0x38C
	IELSR36 volatile.Register32 // 0x390
	IELSR37 volatile.Register32 // 0x394
	IELSR38 volatile.Register32 // 0x398
	IELSR39 volatile.Register32 // 0x39C
	IELSR40 volatile.Register32 // 0x3A0
	IELSR41 volatile.Register32 // 0x3A4
	IELSR42 volatile.Register32 // 0x3A8
	IELSR43 volatile.Register32 // 0x3AC
	IELSR44 volatile.Register32 // 0x3B0
	IELSR45 volatile.Register32 // 0x3B4
	IELSR46 volatile.Register32 // 0x3B8
	IELSR47 volatile.Register32 // 0x3BC
	IELSR48 volatile.Register32 // 0x3C0
	IELSR49 volatile.Register32 // 0x3C4
	IELSR50 volatile.Register32 // 0x3C8
	IELSR51 volatile.Register32 // 0x3CC
	IELSR52 volatile.Register32 // 0x3D0
	IELSR53 volatile.Register32 // 0x3D4
	IELSR54 volatile.Register32 // 0x3D8
	IELSR55 volatile.Register32 // 0x3DC
	IELSR56 volatile.Register32 // 0x3E0
	IELSR57 volatile.Register32 // 0x3E4
	IELSR58 volatile.Register32 // 0x3E8
	IELSR59 volatile.Register32 // 0x3EC
	IELSR60 volatile.Register32 // 0x3F0
	IELSR61 volatile.Register32 // 0x3F4
	IELSR62 volatile.Register32 // 0x3F8
	IELSR63 volatile.Register32 // 0x3FC
	IELSR64 volatile.Register32 // 0x400
	IELSR65 volatile.Register32 // 0x404
	IELSR66 volatile.Register32 // 0x408
	IELSR67 volatile.Register32 // 0x40C
	IELSR68 volatile.Register32 // 0x410
	IELSR69 volatile.Register32 // 0x414
	IELSR70 volatile.Register32 // 0x418
	IELSR71 volatile.Register32 // 0x41C
	IELSR72 volatile.Register32 // 0x420
	IELSR73 volatile.Register32 // 0x424
	IELSR74 volatile.Register32 // 0x428
	IELSR75 volatile.Register32 // 0x42C
	IELSR76 volatile.Register32 // 0x430
	IELSR77 volatile.Register32 // 0x434
	IELSR78 volatile.Register32 // 0x438
	IELSR79 volatile.Register32 // 0x43C
	IELSR80 volatile.Register32 // 0x440
	IELSR81 volatile.Register32 // 0x444
	IELSR82 volatile.Register32 // 0x448
	IELSR83 volatile.Register32 // 0x44C
	IELSR84 volatile.Register32 // 0x450
	IELSR85 volatile.Register32 // 0x454
	IELSR86 volatile.Register32 // 0x458
	IELSR87 volatile.Register32 // 0x45C
	IELSR88 volatile.Register32 // 0x460
	IELSR89 volatile.Register32 // 0x464
	IELSR90 volatile.Register32 // 0x468
	IELSR91 volatile.Register32 // 0x46C
	IELSR92 volatile.Register32 // 0x470
	IELSR93 volatile.Register32 // 0x474
	IELSR94 volatile.Register32 // 0x478
	IELSR95 volatile.Register32 // 0x47C
}

// ICU.IRQCR0: IRQ Control Register
func (o *ICU_Type) SetIRQCR0_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR0_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR0.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR0_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR0_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR0_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR0_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0x80) >> 7
}

// ICU.IRQCR1: IRQ Control Register
func (o *ICU_Type) SetIRQCR1_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR1_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR1.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR1_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR1_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR1_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR1_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0x80) >> 7
}

// ICU.IRQCR2: IRQ Control Register
func (o *ICU_Type) SetIRQCR2_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR2_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR2.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR2_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR2_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR2_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR2_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0x80) >> 7
}

// ICU.IRQCR3: IRQ Control Register
func (o *ICU_Type) SetIRQCR3_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR3_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR3.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR3_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR3_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR3_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR3_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0x80) >> 7
}

// ICU.IRQCR4: IRQ Control Register
func (o *ICU_Type) SetIRQCR4_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR4_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR4.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR4_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR4_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR4_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR4_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0x80) >> 7
}

// ICU.IRQCR5: IRQ Control Register
func (o *ICU_Type) SetIRQCR5_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR5_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR5.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR5_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR5_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR5_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR5_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0x80) >> 7
}

// ICU.IRQCR6: IRQ Control Register
func (o *ICU_Type) SetIRQCR6_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR6_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR6.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR6_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR6_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR6_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR6_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0x80) >> 7
}

// ICU.IRQCR7: IRQ Control Register
func (o *ICU_Type) SetIRQCR7_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR7_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR7.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR7_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR7_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR7_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR7_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0x80) >> 7
}

// ICU.IRQCR8: IRQ Control Register
func (o *ICU_Type) SetIRQCR8_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR8.Reg, volatile.LoadUint8(&o.IRQCR8.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR8_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR8.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR8_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR8.Reg, volatile.LoadUint8(&o.IRQCR8.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR8_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR8.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR8_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR8.Reg, volatile.LoadUint8(&o.IRQCR8.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR8_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR8.Reg) & 0x80) >> 7
}

// ICU.IRQCR9: IRQ Control Register
func (o *ICU_Type) SetIRQCR9_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR9.Reg, volatile.LoadUint8(&o.IRQCR9.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR9_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR9.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR9_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR9.Reg, volatile.LoadUint8(&o.IRQCR9.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR9_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR9.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR9_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR9.Reg, volatile.LoadUint8(&o.IRQCR9.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR9_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR9.Reg) & 0x80) >> 7
}

// ICU.IRQCR10: IRQ Control Register
func (o *ICU_Type) SetIRQCR10_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR10.Reg, volatile.LoadUint8(&o.IRQCR10.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR10_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR10.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR10_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR10.Reg, volatile.LoadUint8(&o.IRQCR10.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR10_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR10.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR10_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR10.Reg, volatile.LoadUint8(&o.IRQCR10.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR10_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR10.Reg) & 0x80) >> 7
}

// ICU.IRQCR11: IRQ Control Register
func (o *ICU_Type) SetIRQCR11_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR11.Reg, volatile.LoadUint8(&o.IRQCR11.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR11_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR11.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR11_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR11.Reg, volatile.LoadUint8(&o.IRQCR11.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR11_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR11.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR11_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR11.Reg, volatile.LoadUint8(&o.IRQCR11.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR11_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR11.Reg) & 0x80) >> 7
}

// ICU.IRQCR12: IRQ Control Register
func (o *ICU_Type) SetIRQCR12_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR12.Reg, volatile.LoadUint8(&o.IRQCR12.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR12_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR12.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR12_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR12.Reg, volatile.LoadUint8(&o.IRQCR12.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR12_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR12.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR12_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR12.Reg, volatile.LoadUint8(&o.IRQCR12.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR12_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR12.Reg) & 0x80) >> 7
}

// ICU.IRQCR13: IRQ Control Register
func (o *ICU_Type) SetIRQCR13_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR13.Reg, volatile.LoadUint8(&o.IRQCR13.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR13_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR13.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR13_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR13.Reg, volatile.LoadUint8(&o.IRQCR13.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR13_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR13.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR13_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR13.Reg, volatile.LoadUint8(&o.IRQCR13.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR13_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR13.Reg) & 0x80) >> 7
}

// ICU.IRQCR14: IRQ Control Register
func (o *ICU_Type) SetIRQCR14_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR14.Reg, volatile.LoadUint8(&o.IRQCR14.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR14_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR14.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR14_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR14.Reg, volatile.LoadUint8(&o.IRQCR14.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR14_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR14.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR14_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR14.Reg, volatile.LoadUint8(&o.IRQCR14.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR14_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR14.Reg) & 0x80) >> 7
}

// ICU.IRQCR15: IRQ Control Register
func (o *ICU_Type) SetIRQCR15_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR15.Reg, volatile.LoadUint8(&o.IRQCR15.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR15_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR15.Reg) & 0x3
}
func (o *ICU_Type) SetIRQCR15_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR15.Reg, volatile.LoadUint8(&o.IRQCR15.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR15_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR15.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR15_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR15.Reg, volatile.LoadUint8(&o.IRQCR15.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR15_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR15.Reg) & 0x80) >> 7
}

// ICU.NMICR: NMI Pin Interrupt Control Register
func (o *ICU_Type) SetNMICR_NMIMD(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMICR_NMIMD() uint8 {
	return volatile.LoadUint8(&o.NMICR.Reg) & 0x1
}
func (o *ICU_Type) SetNMICR_NFCLKSEL(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetNMICR_NFCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetNMICR_NFLTEN(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMICR_NFLTEN() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0x80) >> 7
}

// ICU.NMIER: Non-Maskable Interrupt Enable Register
func (o *ICU_Type) SetNMIER_IWDTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMIER_IWDTEN() uint16 {
	return volatile.LoadUint16(&o.NMIER.Reg) & 0x1
}
func (o *ICU_Type) SetNMIER_WDTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMIER_WDTEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMIER_LVD1EN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMIER_LVD1EN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMIER_LVD2EN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMIER_LVD2EN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMIER_OSTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMIER_OSTEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMIER_NMIEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMIER_NMIEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMIER_RPEEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMIER_RPEEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMIER_BUSMEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMIER_BUSMEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMIER_TZFEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x2000)|value<<13)
}
func (o *ICU_Type) GetNMIER_TZFEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x2000) >> 13
}
func (o *ICU_Type) SetNMIER_CPEEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x8000)|value<<15)
}
func (o *ICU_Type) GetNMIER_CPEEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x8000) >> 15
}

// ICU.NMICLR: Non-Maskable Interrupt Status Clear Register
func (o *ICU_Type) SetNMICLR_IWDTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMICLR_IWDTCLR() uint16 {
	return volatile.LoadUint16(&o.NMICLR.Reg) & 0x1
}
func (o *ICU_Type) SetNMICLR_WDTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMICLR_WDTCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMICLR_LVD1CLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMICLR_LVD1CLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMICLR_LVD2CLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMICLR_LVD2CLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMICLR_OSTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMICLR_OSTCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMICLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMICLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMICLR_RPECLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMICLR_RPECLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMICLR_BUSMCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMICLR_BUSMCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMICLR_TZFCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x2000)|value<<13)
}
func (o *ICU_Type) GetNMICLR_TZFCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x2000) >> 13
}
func (o *ICU_Type) SetNMICLR_CPECLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x8000)|value<<15)
}
func (o *ICU_Type) GetNMICLR_CPECLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x8000) >> 15
}

// ICU.NMISR: Non-Maskable Interrupt Status Register
func (o *ICU_Type) SetNMISR_IWDTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMISR_IWDTST() uint16 {
	return volatile.LoadUint16(&o.NMISR.Reg) & 0x1
}
func (o *ICU_Type) SetNMISR_WDTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMISR_WDTST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMISR_LVD1ST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMISR_LVD1ST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMISR_LVD2ST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMISR_LVD2ST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMISR_OSTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMISR_OSTST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMISR_NMIST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMISR_NMIST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMISR_RPEST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMISR_RPEST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMISR_BUSMST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMISR_BUSMST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMISR_TZFST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x2000)|value<<13)
}
func (o *ICU_Type) GetNMISR_TZFST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x2000) >> 13
}
func (o *ICU_Type) SetNMISR_CPEST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x8000)|value<<15)
}
func (o *ICU_Type) GetNMISR_CPEST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x8000) >> 15
}

// ICU.WUPEN0: Wake Up Interrupt Enable Register 0
func (o *ICU_Type) SetWUPEN0_IRQWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN0.Reg, volatile.LoadUint32(&o.WUPEN0.Reg)&^(0xffff)|value)
}
func (o *ICU_Type) GetWUPEN0_IRQWUPEN() uint32 {
	return volatile.LoadUint32(&o.WUPEN0.Reg) & 0xffff
}
func (o *ICU_Type) SetWUPEN0_IWDTWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN0.Reg, volatile.LoadUint32(&o.WUPEN0.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetWUPEN0_IWDTWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN0.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetWUPEN0_LVD1WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN0.Reg, volatile.LoadUint32(&o.WUPEN0.Reg)&^(0x40000)|value<<18)
}
func (o *ICU_Type) GetWUPEN0_LVD1WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN0.Reg) & 0x40000) >> 18
}
func (o *ICU_Type) SetWUPEN0_LVD2WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN0.Reg, volatile.LoadUint32(&o.WUPEN0.Reg)&^(0x80000)|value<<19)
}
func (o *ICU_Type) GetWUPEN0_LVD2WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN0.Reg) & 0x80000) >> 19
}
func (o *ICU_Type) SetWUPEN0_RTCALMWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN0.Reg, volatile.LoadUint32(&o.WUPEN0.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetWUPEN0_RTCALMWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN0.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetWUPEN0_RTCPRDWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN0.Reg, volatile.LoadUint32(&o.WUPEN0.Reg)&^(0x2000000)|value<<25)
}
func (o *ICU_Type) GetWUPEN0_RTCPRDWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN0.Reg) & 0x2000000) >> 25
}
func (o *ICU_Type) SetWUPEN0_USBFS0WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN0.Reg, volatile.LoadUint32(&o.WUPEN0.Reg)&^(0x8000000)|value<<27)
}
func (o *ICU_Type) GetWUPEN0_USBFS0WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN0.Reg) & 0x8000000) >> 27
}
func (o *ICU_Type) SetWUPEN0_AGT1UDWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN0.Reg, volatile.LoadUint32(&o.WUPEN0.Reg)&^(0x10000000)|value<<28)
}
func (o *ICU_Type) GetWUPEN0_AGT1UDWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN0.Reg) & 0x10000000) >> 28
}
func (o *ICU_Type) SetWUPEN0_AGT1CAWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN0.Reg, volatile.LoadUint32(&o.WUPEN0.Reg)&^(0x20000000)|value<<29)
}
func (o *ICU_Type) GetWUPEN0_AGT1CAWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN0.Reg) & 0x20000000) >> 29
}
func (o *ICU_Type) SetWUPEN0_AGT1CBWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN0.Reg, volatile.LoadUint32(&o.WUPEN0.Reg)&^(0x40000000)|value<<30)
}
func (o *ICU_Type) GetWUPEN0_AGT1CBWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN0.Reg) & 0x40000000) >> 30
}
func (o *ICU_Type) SetWUPEN0_IIC0WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN0.Reg, volatile.LoadUint32(&o.WUPEN0.Reg)&^(0x80000000)|value<<31)
}
func (o *ICU_Type) GetWUPEN0_IIC0WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN0.Reg) & 0x80000000) >> 31
}

// ICU.WUPEN1: Wake Up interrupt enable register 1
func (o *ICU_Type) SetWUPEN1_AGT3UDWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN1.Reg, volatile.LoadUint32(&o.WUPEN1.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetWUPEN1_AGT3UDWUPEN() uint32 {
	return volatile.LoadUint32(&o.WUPEN1.Reg) & 0x1
}
func (o *ICU_Type) SetWUPEN1_AGT3CAWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN1.Reg, volatile.LoadUint32(&o.WUPEN1.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetWUPEN1_AGT3CAWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN1.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetWUPEN1_AGT3CBWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN1.Reg, volatile.LoadUint32(&o.WUPEN1.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetWUPEN1_AGT3CBWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN1.Reg) & 0x4) >> 2
}

// ICU.DELSR0: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR0_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR0.Reg, volatile.LoadUint32(&o.DELSR0.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR0_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR0.Reg) & 0x1ff
}
func (o *ICU_Type) SetDELSR0_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR0.Reg, volatile.LoadUint32(&o.DELSR0.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR0_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR0.Reg) & 0x10000) >> 16
}

// ICU.DELSR1: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR1_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR1.Reg, volatile.LoadUint32(&o.DELSR1.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR1_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR1.Reg) & 0x1ff
}
func (o *ICU_Type) SetDELSR1_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR1.Reg, volatile.LoadUint32(&o.DELSR1.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR1_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR1.Reg) & 0x10000) >> 16
}

// ICU.DELSR2: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR2_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR2.Reg, volatile.LoadUint32(&o.DELSR2.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR2_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR2.Reg) & 0x1ff
}
func (o *ICU_Type) SetDELSR2_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR2.Reg, volatile.LoadUint32(&o.DELSR2.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR2_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR2.Reg) & 0x10000) >> 16
}

// ICU.DELSR3: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR3_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR3.Reg, volatile.LoadUint32(&o.DELSR3.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR3_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR3.Reg) & 0x1ff
}
func (o *ICU_Type) SetDELSR3_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR3.Reg, volatile.LoadUint32(&o.DELSR3.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR3_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR3.Reg) & 0x10000) >> 16
}

// ICU.DELSR4: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR4_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR4.Reg, volatile.LoadUint32(&o.DELSR4.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR4_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR4.Reg) & 0x1ff
}
func (o *ICU_Type) SetDELSR4_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR4.Reg, volatile.LoadUint32(&o.DELSR4.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR4_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR4.Reg) & 0x10000) >> 16
}

// ICU.DELSR5: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR5_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR5.Reg, volatile.LoadUint32(&o.DELSR5.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR5_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR5.Reg) & 0x1ff
}
func (o *ICU_Type) SetDELSR5_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR5.Reg, volatile.LoadUint32(&o.DELSR5.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR5_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR5.Reg) & 0x10000) >> 16
}

// ICU.DELSR6: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR6_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR6.Reg, volatile.LoadUint32(&o.DELSR6.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR6_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR6.Reg) & 0x1ff
}
func (o *ICU_Type) SetDELSR6_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR6.Reg, volatile.LoadUint32(&o.DELSR6.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR6_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR6.Reg) & 0x10000) >> 16
}

// ICU.DELSR7: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR7_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR7.Reg, volatile.LoadUint32(&o.DELSR7.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR7_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR7.Reg) & 0x1ff
}
func (o *ICU_Type) SetDELSR7_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR7.Reg, volatile.LoadUint32(&o.DELSR7.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR7_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR7.Reg) & 0x10000) >> 16
}

// CACHE
type CACHE_Type struct {
	CCACTL volatile.Register32 // 0x0
	CCAFCT volatile.Register32 // 0x4
	CCALCF volatile.Register32 // 0x8
	_      [52]byte
	SCACTL volatile.Register32 // 0x40
	SCAFCT volatile.Register32 // 0x44
	SCALCF volatile.Register32 // 0x48
	_      [436]byte
	CAPOAD volatile.Register32 // 0x200
	CAPRCR volatile.Register32 // 0x204
}

// CACHE.CCACTL: C-Cache Control Register
func (o *CACHE_Type) SetCCACTL_ENC(value uint32) {
	volatile.StoreUint32(&o.CCACTL.Reg, volatile.LoadUint32(&o.CCACTL.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetCCACTL_ENC() uint32 {
	return volatile.LoadUint32(&o.CCACTL.Reg) & 0x1
}

// CACHE.CCAFCT: C-Cache Flush Control Register
func (o *CACHE_Type) SetCCAFCT_FC(value uint32) {
	volatile.StoreUint32(&o.CCAFCT.Reg, volatile.LoadUint32(&o.CCAFCT.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetCCAFCT_FC() uint32 {
	return volatile.LoadUint32(&o.CCAFCT.Reg) & 0x1
}

// CACHE.CCALCF: C-Cache Line Configuration Register
func (o *CACHE_Type) SetCCALCF_CC(value uint32) {
	volatile.StoreUint32(&o.CCALCF.Reg, volatile.LoadUint32(&o.CCALCF.Reg)&^(0x3)|value)
}
func (o *CACHE_Type) GetCCALCF_CC() uint32 {
	return volatile.LoadUint32(&o.CCALCF.Reg) & 0x3
}

// CACHE.SCACTL: S-Cache Control Register
func (o *CACHE_Type) SetSCACTL_ENS(value uint32) {
	volatile.StoreUint32(&o.SCACTL.Reg, volatile.LoadUint32(&o.SCACTL.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetSCACTL_ENS() uint32 {
	return volatile.LoadUint32(&o.SCACTL.Reg) & 0x1
}

// CACHE.SCAFCT: S-Cache Flush Control Register
func (o *CACHE_Type) SetSCAFCT_FS(value uint32) {
	volatile.StoreUint32(&o.SCAFCT.Reg, volatile.LoadUint32(&o.SCAFCT.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetSCAFCT_FS() uint32 {
	return volatile.LoadUint32(&o.SCAFCT.Reg) & 0x1
}

// CACHE.SCALCF: S-Cache Line Configuration Register
func (o *CACHE_Type) SetSCALCF_CS(value uint32) {
	volatile.StoreUint32(&o.SCALCF.Reg, volatile.LoadUint32(&o.SCALCF.Reg)&^(0x3)|value)
}
func (o *CACHE_Type) GetSCALCF_CS() uint32 {
	return volatile.LoadUint32(&o.SCALCF.Reg) & 0x3
}

// CACHE.CAPOAD: Cache Parity Error Operation After Detection Register
func (o *CACHE_Type) SetCAPOAD_OAD(value uint32) {
	volatile.StoreUint32(&o.CAPOAD.Reg, volatile.LoadUint32(&o.CAPOAD.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetCAPOAD_OAD() uint32 {
	return volatile.LoadUint32(&o.CAPOAD.Reg) & 0x1
}

// CACHE.CAPRCR: Cache Protection Register
func (o *CACHE_Type) SetCAPRCR_PRCR(value uint32) {
	volatile.StoreUint32(&o.CAPRCR.Reg, volatile.LoadUint32(&o.CAPRCR.Reg)&^(0x1)|value)
}
func (o *CACHE_Type) GetCAPRCR_PRCR() uint32 {
	return volatile.LoadUint32(&o.CAPRCR.Reg) & 0x1
}
func (o *CACHE_Type) SetCAPRCR_KW(value uint32) {
	volatile.StoreUint32(&o.CAPRCR.Reg, volatile.LoadUint32(&o.CAPRCR.Reg)&^(0xfe)|value<<1)
}
func (o *CACHE_Type) GetCAPRCR_KW() uint32 {
	return (volatile.LoadUint32(&o.CAPRCR.Reg) & 0xfe) >> 1
}

// CPU System Security Control Unit
type CPSCU_Type struct {
	CSAR      volatile.Register32 // 0x0
	_         [12]byte
	SRAMSAR   volatile.Register32 // 0x10
	STBRAMSAR volatile.Register32 // 0x14
	_         [24]byte
	DTCSAR    volatile.Register32 // 0x30
	DMACSAR   volatile.Register32 // 0x34
	_         [8]byte
	ICUSARA   volatile.Register32 // 0x40
	ICUSARB   volatile.Register32 // 0x44
	ICUSARC   volatile.Register32 // 0x48
	ICUSARD   volatile.Register32 // 0x4C
	_         [4]byte
	ICUSARF   volatile.Register32 // 0x54
	_         [24]byte
	ICUSARG   volatile.Register32 // 0x70
	ICUSARH   volatile.Register32 // 0x74
	ICUSARI   volatile.Register32 // 0x78
	_         [132]byte
	BUSSARA   volatile.Register32 // 0x100
	BUSSARB   volatile.Register32 // 0x104
	_         [40]byte
	MMPUSARA  volatile.Register32 // 0x130
	MMPUSARB  volatile.Register32 // 0x134
	_         [72]byte
	TZFSAR    volatile.Register32 // 0x180
	_         [44]byte
	CPUDSAR   volatile.Register32 // 0x1B0
}

// CPSCU.CSAR: Cache Security Attribution Register
func (o *CPSCU_Type) SetCSAR_CACHESA(value uint32) {
	volatile.StoreUint32(&o.CSAR.Reg, volatile.LoadUint32(&o.CSAR.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetCSAR_CACHESA() uint32 {
	return volatile.LoadUint32(&o.CSAR.Reg) & 0x1
}
func (o *CPSCU_Type) SetCSAR_CACHELSA(value uint32) {
	volatile.StoreUint32(&o.CSAR.Reg, volatile.LoadUint32(&o.CSAR.Reg)&^(0x2)|value<<1)
}
func (o *CPSCU_Type) GetCSAR_CACHELSA() uint32 {
	return (volatile.LoadUint32(&o.CSAR.Reg) & 0x2) >> 1
}
func (o *CPSCU_Type) SetCSAR_CACHEESA(value uint32) {
	volatile.StoreUint32(&o.CSAR.Reg, volatile.LoadUint32(&o.CSAR.Reg)&^(0x4)|value<<2)
}
func (o *CPSCU_Type) GetCSAR_CACHEESA() uint32 {
	return (volatile.LoadUint32(&o.CSAR.Reg) & 0x4) >> 2
}

// CPSCU.SRAMSAR: SRAM Security Attribution Register
func (o *CPSCU_Type) SetSRAMSAR_SRAMSA0(value uint32) {
	volatile.StoreUint32(&o.SRAMSAR.Reg, volatile.LoadUint32(&o.SRAMSAR.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetSRAMSAR_SRAMSA0() uint32 {
	return volatile.LoadUint32(&o.SRAMSAR.Reg) & 0x1
}
func (o *CPSCU_Type) SetSRAMSAR_SRAMSA1(value uint32) {
	volatile.StoreUint32(&o.SRAMSAR.Reg, volatile.LoadUint32(&o.SRAMSAR.Reg)&^(0x2)|value<<1)
}
func (o *CPSCU_Type) GetSRAMSAR_SRAMSA1() uint32 {
	return (volatile.LoadUint32(&o.SRAMSAR.Reg) & 0x2) >> 1
}

// CPSCU.STBRAMSAR: Standby RAM memory Security Attribution Register
func (o *CPSCU_Type) SetSTBRAMSAR_NSBSTBR(value uint32) {
	volatile.StoreUint32(&o.STBRAMSAR.Reg, volatile.LoadUint32(&o.STBRAMSAR.Reg)&^(0xf)|value)
}
func (o *CPSCU_Type) GetSTBRAMSAR_NSBSTBR() uint32 {
	return volatile.LoadUint32(&o.STBRAMSAR.Reg) & 0xf
}

// CPSCU.DTCSAR: DTC Controller Security Attribution Register
func (o *CPSCU_Type) SetDTCSAR_DTCSTSA(value uint32) {
	volatile.StoreUint32(&o.DTCSAR.Reg, volatile.LoadUint32(&o.DTCSAR.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetDTCSAR_DTCSTSA() uint32 {
	return volatile.LoadUint32(&o.DTCSAR.Reg) & 0x1
}

// CPSCU.DMACSAR: DMAC Controller Security Attribution Register
func (o *CPSCU_Type) SetDMACSAR_DMASTSA(value uint32) {
	volatile.StoreUint32(&o.DMACSAR.Reg, volatile.LoadUint32(&o.DMACSAR.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetDMACSAR_DMASTSA() uint32 {
	return volatile.LoadUint32(&o.DMACSAR.Reg) & 0x1
}

// CPSCU.ICUSARA: Interrupt Controller Unit Security Attribution Register A
func (o *CPSCU_Type) SetICUSARA_SAIRQCR00(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR00() uint32 {
	return volatile.LoadUint32(&o.ICUSARA.Reg) & 0x1
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR01(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x2)|value<<1)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR01() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x2) >> 1
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR02(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x4)|value<<2)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR02() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x4) >> 2
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR03(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x8)|value<<3)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR03() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x8) >> 3
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR04(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x10)|value<<4)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR04() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x10) >> 4
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR05(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x20)|value<<5)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR05() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x20) >> 5
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR06(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x40)|value<<6)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR06() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x40) >> 6
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR07(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x80)|value<<7)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR07() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x80) >> 7
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR08(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x100)|value<<8)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR08() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x100) >> 8
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR09(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x200)|value<<9)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR09() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x200) >> 9
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR10(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x400)|value<<10)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR10() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x400) >> 10
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR11(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x800)|value<<11)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR11() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x800) >> 11
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR12(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x1000)|value<<12)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR12() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x1000) >> 12
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR13(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x2000)|value<<13)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR13() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x2000) >> 13
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR14(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x4000)|value<<14)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR14() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x4000) >> 14
}
func (o *CPSCU_Type) SetICUSARA_SAIRQCR15(value uint32) {
	volatile.StoreUint32(&o.ICUSARA.Reg, volatile.LoadUint32(&o.ICUSARA.Reg)&^(0x8000)|value<<15)
}
func (o *CPSCU_Type) GetICUSARA_SAIRQCR15() uint32 {
	return (volatile.LoadUint32(&o.ICUSARA.Reg) & 0x8000) >> 15
}

// CPSCU.ICUSARB: Interrupt Controller Unit Security Attribution Register B
func (o *CPSCU_Type) SetICUSARB_SANMI(value uint32) {
	volatile.StoreUint32(&o.ICUSARB.Reg, volatile.LoadUint32(&o.ICUSARB.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetICUSARB_SANMI() uint32 {
	return volatile.LoadUint32(&o.ICUSARB.Reg) & 0x1
}

// CPSCU.ICUSARC: Interrupt Controller Unit Security Attribution Register C
func (o *CPSCU_Type) SetICUSARC_SADMAC0(value uint32) {
	volatile.StoreUint32(&o.ICUSARC.Reg, volatile.LoadUint32(&o.ICUSARC.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetICUSARC_SADMAC0() uint32 {
	return volatile.LoadUint32(&o.ICUSARC.Reg) & 0x1
}
func (o *CPSCU_Type) SetICUSARC_SADMAC1(value uint32) {
	volatile.StoreUint32(&o.ICUSARC.Reg, volatile.LoadUint32(&o.ICUSARC.Reg)&^(0x2)|value<<1)
}
func (o *CPSCU_Type) GetICUSARC_SADMAC1() uint32 {
	return (volatile.LoadUint32(&o.ICUSARC.Reg) & 0x2) >> 1
}
func (o *CPSCU_Type) SetICUSARC_SADMAC2(value uint32) {
	volatile.StoreUint32(&o.ICUSARC.Reg, volatile.LoadUint32(&o.ICUSARC.Reg)&^(0x4)|value<<2)
}
func (o *CPSCU_Type) GetICUSARC_SADMAC2() uint32 {
	return (volatile.LoadUint32(&o.ICUSARC.Reg) & 0x4) >> 2
}
func (o *CPSCU_Type) SetICUSARC_SADMAC3(value uint32) {
	volatile.StoreUint32(&o.ICUSARC.Reg, volatile.LoadUint32(&o.ICUSARC.Reg)&^(0x8)|value<<3)
}
func (o *CPSCU_Type) GetICUSARC_SADMAC3() uint32 {
	return (volatile.LoadUint32(&o.ICUSARC.Reg) & 0x8) >> 3
}
func (o *CPSCU_Type) SetICUSARC_SADMAC4(value uint32) {
	volatile.StoreUint32(&o.ICUSARC.Reg, volatile.LoadUint32(&o.ICUSARC.Reg)&^(0x10)|value<<4)
}
func (o *CPSCU_Type) GetICUSARC_SADMAC4() uint32 {
	return (volatile.LoadUint32(&o.ICUSARC.Reg) & 0x10) >> 4
}
func (o *CPSCU_Type) SetICUSARC_SADMAC5(value uint32) {
	volatile.StoreUint32(&o.ICUSARC.Reg, volatile.LoadUint32(&o.ICUSARC.Reg)&^(0x20)|value<<5)
}
func (o *CPSCU_Type) GetICUSARC_SADMAC5() uint32 {
	return (volatile.LoadUint32(&o.ICUSARC.Reg) & 0x20) >> 5
}
func (o *CPSCU_Type) SetICUSARC_SADMAC6(value uint32) {
	volatile.StoreUint32(&o.ICUSARC.Reg, volatile.LoadUint32(&o.ICUSARC.Reg)&^(0x40)|value<<6)
}
func (o *CPSCU_Type) GetICUSARC_SADMAC6() uint32 {
	return (volatile.LoadUint32(&o.ICUSARC.Reg) & 0x40) >> 6
}
func (o *CPSCU_Type) SetICUSARC_SADMAC7(value uint32) {
	volatile.StoreUint32(&o.ICUSARC.Reg, volatile.LoadUint32(&o.ICUSARC.Reg)&^(0x80)|value<<7)
}
func (o *CPSCU_Type) GetICUSARC_SADMAC7() uint32 {
	return (volatile.LoadUint32(&o.ICUSARC.Reg) & 0x80) >> 7
}

// CPSCU.ICUSARD: Interrupt Controller Unit Security Attribution Register D
func (o *CPSCU_Type) SetICUSARD_SASELSR0(value uint32) {
	volatile.StoreUint32(&o.ICUSARD.Reg, volatile.LoadUint32(&o.ICUSARD.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetICUSARD_SASELSR0() uint32 {
	return volatile.LoadUint32(&o.ICUSARD.Reg) & 0x1
}

// CPSCU.ICUSARF: Interrupt Controller Unit Security Attribution Register F
func (o *CPSCU_Type) SetICUSARF_SAAGT3UDWUP(value uint32) {
	volatile.StoreUint32(&o.ICUSARF.Reg, volatile.LoadUint32(&o.ICUSARF.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetICUSARF_SAAGT3UDWUP() uint32 {
	return volatile.LoadUint32(&o.ICUSARF.Reg) & 0x1
}
func (o *CPSCU_Type) SetICUSARF_SAAGT3CAWUP(value uint32) {
	volatile.StoreUint32(&o.ICUSARF.Reg, volatile.LoadUint32(&o.ICUSARF.Reg)&^(0x2)|value<<1)
}
func (o *CPSCU_Type) GetICUSARF_SAAGT3CAWUP() uint32 {
	return (volatile.LoadUint32(&o.ICUSARF.Reg) & 0x2) >> 1
}
func (o *CPSCU_Type) SetICUSARF_SAAGT3CBWUP(value uint32) {
	volatile.StoreUint32(&o.ICUSARF.Reg, volatile.LoadUint32(&o.ICUSARF.Reg)&^(0x4)|value<<2)
}
func (o *CPSCU_Type) GetICUSARF_SAAGT3CBWUP() uint32 {
	return (volatile.LoadUint32(&o.ICUSARF.Reg) & 0x4) >> 2
}

// CPSCU.ICUSARG: Interrupt Controller Unit Security Attribution Register G
func (o *CPSCU_Type) SetICUSARG_SAIELSR00(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR00() uint32 {
	return volatile.LoadUint32(&o.ICUSARG.Reg) & 0x1
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR01(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x2)|value<<1)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR01() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x2) >> 1
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR02(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x4)|value<<2)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR02() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x4) >> 2
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR03(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x8)|value<<3)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR03() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x8) >> 3
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR04(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x10)|value<<4)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR04() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x10) >> 4
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR05(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x20)|value<<5)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR05() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x20) >> 5
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR06(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x40)|value<<6)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR06() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x40) >> 6
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR07(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x80)|value<<7)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR07() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x80) >> 7
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR08(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x100)|value<<8)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR08() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x100) >> 8
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR09(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x200)|value<<9)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR09() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x200) >> 9
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR10(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x400)|value<<10)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR10() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x400) >> 10
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR11(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x800)|value<<11)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR11() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x800) >> 11
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR12(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x1000)|value<<12)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR12() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x1000) >> 12
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR13(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x2000)|value<<13)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR13() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x2000) >> 13
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR14(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x4000)|value<<14)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR14() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x4000) >> 14
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR15(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x8000)|value<<15)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR15() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x8000) >> 15
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR16(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x10000)|value<<16)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR16() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x10000) >> 16
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR17(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x20000)|value<<17)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR17() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x20000) >> 17
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR18(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x40000)|value<<18)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR18() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x40000) >> 18
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR19(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x80000)|value<<19)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR19() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x80000) >> 19
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR20(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x100000)|value<<20)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR20() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x100000) >> 20
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR21(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x200000)|value<<21)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR21() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x200000) >> 21
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR22(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x400000)|value<<22)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR22() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x400000) >> 22
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR23(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x800000)|value<<23)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR23() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x800000) >> 23
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR24(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x1000000)|value<<24)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR24() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x1000000) >> 24
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR25(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x2000000)|value<<25)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR25() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x2000000) >> 25
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR26(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x4000000)|value<<26)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR26() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x4000000) >> 26
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR27(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x8000000)|value<<27)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR27() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x8000000) >> 27
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR28(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x10000000)|value<<28)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR28() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x10000000) >> 28
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR29(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x20000000)|value<<29)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR29() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x20000000) >> 29
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR30(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x40000000)|value<<30)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR30() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x40000000) >> 30
}
func (o *CPSCU_Type) SetICUSARG_SAIELSR31(value uint32) {
	volatile.StoreUint32(&o.ICUSARG.Reg, volatile.LoadUint32(&o.ICUSARG.Reg)&^(0x80000000)|value<<31)
}
func (o *CPSCU_Type) GetICUSARG_SAIELSR31() uint32 {
	return (volatile.LoadUint32(&o.ICUSARG.Reg) & 0x80000000) >> 31
}

// CPSCU.ICUSARH: Interrupt Controller Unit Security Attribution Register H
func (o *CPSCU_Type) SetICUSARH_SAIELSR32(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR32() uint32 {
	return volatile.LoadUint32(&o.ICUSARH.Reg) & 0x1
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR33(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x2)|value<<1)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR33() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x2) >> 1
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR34(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x4)|value<<2)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR34() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x4) >> 2
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR35(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x8)|value<<3)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR35() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x8) >> 3
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR36(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x10)|value<<4)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR36() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x10) >> 4
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR37(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x20)|value<<5)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR37() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x20) >> 5
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR38(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x40)|value<<6)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR38() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x40) >> 6
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR39(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x80)|value<<7)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR39() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x80) >> 7
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR40(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x100)|value<<8)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR40() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x100) >> 8
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR41(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x200)|value<<9)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR41() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x200) >> 9
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR42(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x400)|value<<10)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR42() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x400) >> 10
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR43(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x800)|value<<11)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR43() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x800) >> 11
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR44(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x1000)|value<<12)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR44() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x1000) >> 12
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR45(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x2000)|value<<13)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR45() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x2000) >> 13
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR46(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x4000)|value<<14)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR46() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x4000) >> 14
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR47(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x8000)|value<<15)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR47() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x8000) >> 15
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR48(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x10000)|value<<16)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR48() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x10000) >> 16
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR49(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x20000)|value<<17)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR49() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x20000) >> 17
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR50(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x40000)|value<<18)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR50() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x40000) >> 18
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR51(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x80000)|value<<19)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR51() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x80000) >> 19
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR52(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x100000)|value<<20)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR52() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x100000) >> 20
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR53(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x200000)|value<<21)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR53() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x200000) >> 21
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR54(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x400000)|value<<22)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR54() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x400000) >> 22
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR55(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x800000)|value<<23)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR55() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x800000) >> 23
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR56(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x1000000)|value<<24)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR56() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x1000000) >> 24
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR57(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x2000000)|value<<25)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR57() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x2000000) >> 25
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR58(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x4000000)|value<<26)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR58() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x4000000) >> 26
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR59(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x8000000)|value<<27)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR59() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x8000000) >> 27
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR60(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x10000000)|value<<28)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR60() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x10000000) >> 28
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR61(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x20000000)|value<<29)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR61() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x20000000) >> 29
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR62(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x40000000)|value<<30)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR62() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x40000000) >> 30
}
func (o *CPSCU_Type) SetICUSARH_SAIELSR63(value uint32) {
	volatile.StoreUint32(&o.ICUSARH.Reg, volatile.LoadUint32(&o.ICUSARH.Reg)&^(0x80000000)|value<<31)
}
func (o *CPSCU_Type) GetICUSARH_SAIELSR63() uint32 {
	return (volatile.LoadUint32(&o.ICUSARH.Reg) & 0x80000000) >> 31
}

// CPSCU.ICUSARI: Interrupt Controller Unit Security Attribution Register I
func (o *CPSCU_Type) SetICUSARI_SAIELSR64(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR64() uint32 {
	return volatile.LoadUint32(&o.ICUSARI.Reg) & 0x1
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR65(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x2)|value<<1)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR65() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x2) >> 1
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR66(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x4)|value<<2)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR66() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x4) >> 2
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR67(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x8)|value<<3)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR67() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x8) >> 3
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR68(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x10)|value<<4)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR68() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x10) >> 4
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR69(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x20)|value<<5)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR69() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x20) >> 5
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR70(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x40)|value<<6)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR70() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x40) >> 6
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR71(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x80)|value<<7)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR71() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x80) >> 7
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR72(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x100)|value<<8)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR72() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x100) >> 8
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR73(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x200)|value<<9)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR73() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x200) >> 9
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR74(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x400)|value<<10)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR74() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x400) >> 10
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR75(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x800)|value<<11)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR75() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x800) >> 11
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR76(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x1000)|value<<12)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR76() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x1000) >> 12
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR77(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x2000)|value<<13)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR77() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x2000) >> 13
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR78(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x4000)|value<<14)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR78() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x4000) >> 14
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR79(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x8000)|value<<15)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR79() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x8000) >> 15
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR80(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x10000)|value<<16)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR80() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x10000) >> 16
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR81(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x20000)|value<<17)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR81() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x20000) >> 17
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR82(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x40000)|value<<18)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR82() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x40000) >> 18
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR83(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x80000)|value<<19)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR83() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x80000) >> 19
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR84(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x100000)|value<<20)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR84() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x100000) >> 20
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR85(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x200000)|value<<21)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR85() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x200000) >> 21
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR86(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x400000)|value<<22)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR86() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x400000) >> 22
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR87(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x800000)|value<<23)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR87() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x800000) >> 23
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR88(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x1000000)|value<<24)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR88() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x1000000) >> 24
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR89(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x2000000)|value<<25)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR89() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x2000000) >> 25
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR90(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x4000000)|value<<26)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR90() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x4000000) >> 26
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR91(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x8000000)|value<<27)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR91() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x8000000) >> 27
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR92(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x10000000)|value<<28)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR92() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x10000000) >> 28
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR93(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x20000000)|value<<29)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR93() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x20000000) >> 29
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR94(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x40000000)|value<<30)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR94() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x40000000) >> 30
}
func (o *CPSCU_Type) SetICUSARI_SAIELSR95(value uint32) {
	volatile.StoreUint32(&o.ICUSARI.Reg, volatile.LoadUint32(&o.ICUSARI.Reg)&^(0x80000000)|value<<31)
}
func (o *CPSCU_Type) GetICUSARI_SAIELSR95() uint32 {
	return (volatile.LoadUint32(&o.ICUSARI.Reg) & 0x80000000) >> 31
}

// CPSCU.BUSSARA: BUS Security Attribution Register A
func (o *CPSCU_Type) SetBUSSARA_BUSSA0(value uint32) {
	volatile.StoreUint32(&o.BUSSARA.Reg, volatile.LoadUint32(&o.BUSSARA.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetBUSSARA_BUSSA0() uint32 {
	return volatile.LoadUint32(&o.BUSSARA.Reg) & 0x1
}

// CPSCU.BUSSARB: BUS Security Attribution Register B
func (o *CPSCU_Type) SetBUSSARB_BUSSB0(value uint32) {
	volatile.StoreUint32(&o.BUSSARB.Reg, volatile.LoadUint32(&o.BUSSARB.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetBUSSARB_BUSSB0() uint32 {
	return volatile.LoadUint32(&o.BUSSARB.Reg) & 0x1
}

// CPSCU.MMPUSARA: Master Memory Protection Unit Security Attribution Register A
func (o *CPSCU_Type) SetMMPUSARA_MMPUASAn(value uint32) {
	volatile.StoreUint32(&o.MMPUSARA.Reg, volatile.LoadUint32(&o.MMPUSARA.Reg)&^(0xff)|value)
}
func (o *CPSCU_Type) GetMMPUSARA_MMPUASAn() uint32 {
	return volatile.LoadUint32(&o.MMPUSARA.Reg) & 0xff
}

// CPSCU.MMPUSARB: Master Memory Protection Unit Security Attribution Register B
func (o *CPSCU_Type) SetMMPUSARB_MMPUBSA0(value uint32) {
	volatile.StoreUint32(&o.MMPUSARB.Reg, volatile.LoadUint32(&o.MMPUSARB.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetMMPUSARB_MMPUBSA0() uint32 {
	return volatile.LoadUint32(&o.MMPUSARB.Reg) & 0x1
}

// CPSCU.TZFSAR: TrustZone Filter Security Attribution Register
func (o *CPSCU_Type) SetTZFSAR_TZFSA0(value uint32) {
	volatile.StoreUint32(&o.TZFSAR.Reg, volatile.LoadUint32(&o.TZFSAR.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetTZFSAR_TZFSA0() uint32 {
	return volatile.LoadUint32(&o.TZFSAR.Reg) & 0x1
}

// CPSCU.CPUDSAR: CPU Debug Security Attribution Register
func (o *CPSCU_Type) SetCPUDSAR_CPUDSA0(value uint32) {
	volatile.StoreUint32(&o.CPUDSAR.Reg, volatile.LoadUint32(&o.CPUDSAR.Reg)&^(0x1)|value)
}
func (o *CPSCU_Type) GetCPUDSAR_CPUDSA0() uint32 {
	return volatile.LoadUint32(&o.CPUDSAR.Reg) & 0x1
}

// Debug Function
type DBG_Type struct {
	DBGSTR    volatile.Register32 // 0x0
	_         [12]byte
	DBGSTOPCR volatile.Register32 // 0x10
}

// DBG.DBGSTR: Debug Status Register
func (o *DBG_Type) SetDBGSTR_CDBGPWRUPREQ(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0x10000000)|value<<28)
}
func (o *DBG_Type) GetDBGSTR_CDBGPWRUPREQ() uint32 {
	return (volatile.LoadUint32(&o.DBGSTR.Reg) & 0x10000000) >> 28
}
func (o *DBG_Type) SetDBGSTR_CDBGPWRUPACK(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0x20000000)|value<<29)
}
func (o *DBG_Type) GetDBGSTR_CDBGPWRUPACK() uint32 {
	return (volatile.LoadUint32(&o.DBGSTR.Reg) & 0x20000000) >> 29
}

// DBG.DBGSTOPCR: Debug Stop Control Register
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_IWDT(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x1)|value)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_IWDT() uint32 {
	return volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x1
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_WDT(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x2)|value<<1)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_WDT() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x2) >> 1
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_LVD0(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x10000)|value<<16)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_LVD0() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x10000) >> 16
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_LVD1(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x20000)|value<<17)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_LVD1() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x20000) >> 17
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_LVD2(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x40000)|value<<18)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_LVD2() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x40000) >> 18
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_RPER(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_RPER() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x1000000) >> 24
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_CPER(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_CPER() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x80000000) >> 31
}

// SYSTEM/FLASH
type FCACHE_Type struct {
	FCACHEE  volatile.Register16 // 0x0
	_        [2]byte
	FCACHEIV volatile.Register16 // 0x4
	_        [22]byte
	FLWT     volatile.Register8 // 0x1C
	_        [35]byte
	FSAR     volatile.Register16 // 0x40
}

// FCACHE.FCACHEE: Flash Cache Enable Register
func (o *FCACHE_Type) SetFCACHEE_FCACHEEN(value uint16) {
	volatile.StoreUint16(&o.FCACHEE.Reg, volatile.LoadUint16(&o.FCACHEE.Reg)&^(0x1)|value)
}
func (o *FCACHE_Type) GetFCACHEE_FCACHEEN() uint16 {
	return volatile.LoadUint16(&o.FCACHEE.Reg) & 0x1
}

// FCACHE.FCACHEIV: Flash Cache Invalidate Register
func (o *FCACHE_Type) SetFCACHEIV(value uint16) {
	volatile.StoreUint16(&o.FCACHEIV.Reg, volatile.LoadUint16(&o.FCACHEIV.Reg)&^(0x1)|value)
}
func (o *FCACHE_Type) GetFCACHEIV() uint16 {
	return volatile.LoadUint16(&o.FCACHEIV.Reg) & 0x1
}

// FCACHE.FLWT: Flash Wait Cycle Register
func (o *FCACHE_Type) SetFLWT(value uint8) {
	volatile.StoreUint8(&o.FLWT.Reg, volatile.LoadUint8(&o.FLWT.Reg)&^(0x7)|value)
}
func (o *FCACHE_Type) GetFLWT() uint8 {
	return volatile.LoadUint8(&o.FLWT.Reg) & 0x7
}

// FCACHE.FSAR: Flash Security Attribution Register
func (o *FCACHE_Type) SetFSAR_FLWTSA(value uint16) {
	volatile.StoreUint16(&o.FSAR.Reg, volatile.LoadUint16(&o.FSAR.Reg)&^(0x1)|value)
}
func (o *FCACHE_Type) GetFSAR_FLWTSA() uint16 {
	return volatile.LoadUint16(&o.FSAR.Reg) & 0x1
}
func (o *FCACHE_Type) SetFSAR_FCKMHZSA(value uint16) {
	volatile.StoreUint16(&o.FSAR.Reg, volatile.LoadUint16(&o.FSAR.Reg)&^(0x100)|value<<8)
}
func (o *FCACHE_Type) GetFSAR_FCKMHZSA() uint16 {
	return (volatile.LoadUint16(&o.FSAR.Reg) & 0x100) >> 8
}

// System Control
type SYSC_Type struct {
	_           [12]byte
	SBYCR       volatile.Register16 // 0xC
	_           [18]byte
	SCKDIVCR    volatile.Register32 // 0x20
	_           [2]byte
	SCKSCR      volatile.Register8 // 0x26
	_           byte
	PLLCCR      volatile.Register16 // 0x28
	PLLCR       volatile.Register8  // 0x2A
	_           [7]byte
	MOSCCR      volatile.Register8 // 0x32
	_           [3]byte
	HOCOCR      volatile.Register8 // 0x36
	_           byte
	MOCOCR      volatile.Register8  // 0x38
	FLLCR1      volatile.Register8  // 0x39
	FLLCR2      volatile.Register16 // 0x3A
	OSCSF       volatile.Register8  // 0x3C
	_           byte
	CKOCR       volatile.Register8 // 0x3E
	TRCKCR      volatile.Register8 // 0x3F
	OSTDCR      volatile.Register8 // 0x40
	OSTDSR      volatile.Register8 // 0x41
	_           [6]byte
	PLL2CCR     volatile.Register16 // 0x48
	PLL2CR      volatile.Register8  // 0x4A
	_           [22]byte
	MOCOUTCR    volatile.Register8 // 0x61
	HOCOUTCR    volatile.Register8 // 0x62
	_           [9]byte
	USBCKDIVCR  volatile.Register8 // 0x6C
	_           [7]byte
	USBCKCR     volatile.Register8 // 0x74
	_           [19]byte
	SNZREQCR1   volatile.Register32 // 0x88
	_           [6]byte
	SNZCR       volatile.Register8 // 0x92
	_           byte
	SNZEDCR0    volatile.Register8 // 0x94
	SNZEDCR1    volatile.Register8 // 0x95
	_           [2]byte
	SNZREQCR0   volatile.Register32 // 0x98
	_           [4]byte
	OPCCR       volatile.Register8 // 0xA0
	_           byte
	MOSCWTCR    volatile.Register8 // 0xA2
	_           [7]byte
	SOPCCR      volatile.Register8 // 0xAA
	_           [21]byte
	RSTSR1      volatile.Register16 // 0xC0
	_           [30]byte
	LVD1CR1     volatile.Register8 // 0xE0
	LVD1SR      volatile.Register8 // 0xE1
	LVD2CR1     volatile.Register8 // 0xE2
	LVD2SR      volatile.Register8 // 0xE3
	_           [732]byte
	CGFSAR      volatile.Register32 // 0x3C0
	RSTSAR      volatile.Register32 // 0x3C4
	LPMSAR      volatile.Register32 // 0x3C8
	LVDSAR      volatile.Register32 // 0x3CC
	BBFSAR      volatile.Register32 // 0x3D0
	_           [12]byte
	DPFSAR      volatile.Register32 // 0x3E0
	_           [26]byte
	PRCR        volatile.Register16 // 0x3FE
	DPSBYCR     volatile.Register8  // 0x400
	DPSWCR      volatile.Register8  // 0x401
	DPSIER0     volatile.Register8  // 0x402
	DPSIER1     volatile.Register8  // 0x403
	DPSIER2     volatile.Register8  // 0x404
	DPSIER3     volatile.Register8  // 0x405
	DPSIFR0     volatile.Register8  // 0x406
	DPSIFR1     volatile.Register8  // 0x407
	DPSIFR2     volatile.Register8  // 0x408
	DPSIFR3     volatile.Register8  // 0x409
	DPSIEGR0    volatile.Register8  // 0x40A
	DPSIEGR1    volatile.Register8  // 0x40B
	DPSIEGR2    volatile.Register8  // 0x40C
	_           byte
	SYOCDCR     volatile.Register8 // 0x40E
	_           byte
	RSTSR0      volatile.Register8 // 0x410
	RSTSR2      volatile.Register8 // 0x411
	_           byte
	MOMCR       volatile.Register8 // 0x413
	_           [2]byte
	FWEPROR     volatile.Register8 // 0x416
	LVD1CMPCR   volatile.Register8 // 0x417
	LVD2CMPCR   volatile.Register8 // 0x418
	_           byte
	LVD1CR0     volatile.Register8 // 0x41A
	LVD2CR0     volatile.Register8 // 0x41B
	_           byte
	VBATTMNSELR volatile.Register8 // 0x41D
	VBATTMONR   volatile.Register8 // 0x41E
	_           [97]byte
	SOSCCR      volatile.Register8 // 0x480
	SOMCR       volatile.Register8 // 0x481
	_           [14]byte
	LOCOCR      volatile.Register8 // 0x490
	_           byte
	LOCOUTCR    volatile.Register8 // 0x492
	_           [40]byte
	VBTICTLR    volatile.Register8 // 0x4BB
	_           [4]byte
	VBTBER      volatile.Register8 // 0x4C0
	_           [63]byte
	VBTBKR      [128]volatile.Register8 // 0x500
}

// SYSC.SBYCR: Standby Control Register
func (o *SYSC_Type) SetSBYCR_SSBY(value uint16) {
	volatile.StoreUint16(&o.SBYCR.Reg, volatile.LoadUint16(&o.SBYCR.Reg)&^(0x8000)|value<<15)
}
func (o *SYSC_Type) GetSBYCR_SSBY() uint16 {
	return (volatile.LoadUint16(&o.SBYCR.Reg) & 0x8000) >> 15
}

// SYSC.SCKDIVCR: System Clock Division Control Register
func (o *SYSC_Type) SetSCKDIVCR_PCKD(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x7)|value)
}
func (o *SYSC_Type) GetSCKDIVCR_PCKD() uint32 {
	return volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x7
}
func (o *SYSC_Type) SetSCKDIVCR_PCKC(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x70)|value<<4)
}
func (o *SYSC_Type) GetSCKDIVCR_PCKC() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x70) >> 4
}
func (o *SYSC_Type) SetSCKDIVCR_PCKB(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x700)|value<<8)
}
func (o *SYSC_Type) GetSCKDIVCR_PCKB() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x700) >> 8
}
func (o *SYSC_Type) SetSCKDIVCR_PCKA(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x7000)|value<<12)
}
func (o *SYSC_Type) GetSCKDIVCR_PCKA() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x7000) >> 12
}
func (o *SYSC_Type) SetSCKDIVCR_RSV(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x70000)|value<<16)
}
func (o *SYSC_Type) GetSCKDIVCR_RSV() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x70000) >> 16
}
func (o *SYSC_Type) SetSCKDIVCR_ICK(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x7000000)|value<<24)
}
func (o *SYSC_Type) GetSCKDIVCR_ICK() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x7000000) >> 24
}
func (o *SYSC_Type) SetSCKDIVCR_FCK(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x70000000)|value<<28)
}
func (o *SYSC_Type) GetSCKDIVCR_FCK() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x70000000) >> 28
}

// SYSC.SCKSCR: System Clock Source Control Register
func (o *SYSC_Type) SetSCKSCR_CKSEL(value uint8) {
	volatile.StoreUint8(&o.SCKSCR.Reg, volatile.LoadUint8(&o.SCKSCR.Reg)&^(0x7)|value)
}
func (o *SYSC_Type) GetSCKSCR_CKSEL() uint8 {
	return volatile.LoadUint8(&o.SCKSCR.Reg) & 0x7
}

// SYSC.PLLCCR: PLL Clock Control Register
func (o *SYSC_Type) SetPLLCCR_PLIDIV(value uint16) {
	volatile.StoreUint16(&o.PLLCCR.Reg, volatile.LoadUint16(&o.PLLCCR.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetPLLCCR_PLIDIV() uint16 {
	return volatile.LoadUint16(&o.PLLCCR.Reg) & 0x3
}
func (o *SYSC_Type) SetPLLCCR_PLSRCSEL(value uint16) {
	volatile.StoreUint16(&o.PLLCCR.Reg, volatile.LoadUint16(&o.PLLCCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetPLLCCR_PLSRCSEL() uint16 {
	return (volatile.LoadUint16(&o.PLLCCR.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetPLLCCR_PLLMUL(value uint16) {
	volatile.StoreUint16(&o.PLLCCR.Reg, volatile.LoadUint16(&o.PLLCCR.Reg)&^(0x3f00)|value<<8)
}
func (o *SYSC_Type) GetPLLCCR_PLLMUL() uint16 {
	return (volatile.LoadUint16(&o.PLLCCR.Reg) & 0x3f00) >> 8
}

// SYSC.PLLCR: PLL Control Register
func (o *SYSC_Type) SetPLLCR_PLLSTP(value uint8) {
	volatile.StoreUint8(&o.PLLCR.Reg, volatile.LoadUint8(&o.PLLCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetPLLCR_PLLSTP() uint8 {
	return volatile.LoadUint8(&o.PLLCR.Reg) & 0x1
}

// SYSC.MOSCCR: Main Clock Oscillator Control Register
func (o *SYSC_Type) SetMOSCCR_MOSTP(value uint8) {
	volatile.StoreUint8(&o.MOSCCR.Reg, volatile.LoadUint8(&o.MOSCCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetMOSCCR_MOSTP() uint8 {
	return volatile.LoadUint8(&o.MOSCCR.Reg) & 0x1
}

// SYSC.HOCOCR: High-Speed On-Chip Oscillator Control Register
func (o *SYSC_Type) SetHOCOCR_HCSTP(value uint8) {
	volatile.StoreUint8(&o.HOCOCR.Reg, volatile.LoadUint8(&o.HOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetHOCOCR_HCSTP() uint8 {
	return volatile.LoadUint8(&o.HOCOCR.Reg) & 0x1
}

// SYSC.MOCOCR: Middle-Speed On-Chip Oscillator Control Register
func (o *SYSC_Type) SetMOCOCR_MCSTP(value uint8) {
	volatile.StoreUint8(&o.MOCOCR.Reg, volatile.LoadUint8(&o.MOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetMOCOCR_MCSTP() uint8 {
	return volatile.LoadUint8(&o.MOCOCR.Reg) & 0x1
}

// SYSC.FLLCR1: FLL Control Register1
func (o *SYSC_Type) SetFLLCR1_FLLEN(value uint8) {
	volatile.StoreUint8(&o.FLLCR1.Reg, volatile.LoadUint8(&o.FLLCR1.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetFLLCR1_FLLEN() uint8 {
	return volatile.LoadUint8(&o.FLLCR1.Reg) & 0x1
}

// SYSC.FLLCR2: FLL Control Register2
func (o *SYSC_Type) SetFLLCR2_FLLCNTL(value uint16) {
	volatile.StoreUint16(&o.FLLCR2.Reg, volatile.LoadUint16(&o.FLLCR2.Reg)&^(0x7ff)|value)
}
func (o *SYSC_Type) GetFLLCR2_FLLCNTL() uint16 {
	return volatile.LoadUint16(&o.FLLCR2.Reg) & 0x7ff
}

// SYSC.OSCSF: Oscillation Stabilization Flag Register
func (o *SYSC_Type) SetOSCSF_HOCOSF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetOSCSF_HOCOSF() uint8 {
	return volatile.LoadUint8(&o.OSCSF.Reg) & 0x1
}
func (o *SYSC_Type) SetOSCSF_MOSCSF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetOSCSF_MOSCSF() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetOSCSF_PLLSF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x20)|value<<5)
}
func (o *SYSC_Type) GetOSCSF_PLLSF() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0x20) >> 5
}
func (o *SYSC_Type) SetOSCSF_PLL2SF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetOSCSF_PLL2SF() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0x40) >> 6
}

// SYSC.CKOCR: Clock Out Control Register
func (o *SYSC_Type) SetCKOCR_CKOSEL(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x7)|value)
}
func (o *SYSC_Type) GetCKOCR_CKOSEL() uint8 {
	return volatile.LoadUint8(&o.CKOCR.Reg) & 0x7
}
func (o *SYSC_Type) SetCKOCR_CKODIV(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x70)|value<<4)
}
func (o *SYSC_Type) GetCKOCR_CKODIV() uint8 {
	return (volatile.LoadUint8(&o.CKOCR.Reg) & 0x70) >> 4
}
func (o *SYSC_Type) SetCKOCR_CKOEN(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetCKOCR_CKOEN() uint8 {
	return (volatile.LoadUint8(&o.CKOCR.Reg) & 0x80) >> 7
}

// SYSC.TRCKCR: Trace Clock Control Register
func (o *SYSC_Type) SetTRCKCR_TRCK(value uint8) {
	volatile.StoreUint8(&o.TRCKCR.Reg, volatile.LoadUint8(&o.TRCKCR.Reg)&^(0xf)|value)
}
func (o *SYSC_Type) GetTRCKCR_TRCK() uint8 {
	return volatile.LoadUint8(&o.TRCKCR.Reg) & 0xf
}
func (o *SYSC_Type) SetTRCKCR_TRCKEN(value uint8) {
	volatile.StoreUint8(&o.TRCKCR.Reg, volatile.LoadUint8(&o.TRCKCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetTRCKCR_TRCKEN() uint8 {
	return (volatile.LoadUint8(&o.TRCKCR.Reg) & 0x80) >> 7
}

// SYSC.OSTDCR: Oscillation Stop Detection Control Register
func (o *SYSC_Type) SetOSTDCR_OSTDIE(value uint8) {
	volatile.StoreUint8(&o.OSTDCR.Reg, volatile.LoadUint8(&o.OSTDCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetOSTDCR_OSTDIE() uint8 {
	return volatile.LoadUint8(&o.OSTDCR.Reg) & 0x1
}
func (o *SYSC_Type) SetOSTDCR_OSTDE(value uint8) {
	volatile.StoreUint8(&o.OSTDCR.Reg, volatile.LoadUint8(&o.OSTDCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetOSTDCR_OSTDE() uint8 {
	return (volatile.LoadUint8(&o.OSTDCR.Reg) & 0x80) >> 7
}

// SYSC.OSTDSR: Oscillation Stop Detection Status Register
func (o *SYSC_Type) SetOSTDSR_OSTDF(value uint8) {
	volatile.StoreUint8(&o.OSTDSR.Reg, volatile.LoadUint8(&o.OSTDSR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetOSTDSR_OSTDF() uint8 {
	return volatile.LoadUint8(&o.OSTDSR.Reg) & 0x1
}

// SYSC.PLL2CCR: PLL2 Clock Control Register
func (o *SYSC_Type) SetPLL2CCR_PL2IDIV(value uint16) {
	volatile.StoreUint16(&o.PLL2CCR.Reg, volatile.LoadUint16(&o.PLL2CCR.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetPLL2CCR_PL2IDIV() uint16 {
	return volatile.LoadUint16(&o.PLL2CCR.Reg) & 0x3
}
func (o *SYSC_Type) SetPLL2CCR_PL2SRCSEL(value uint16) {
	volatile.StoreUint16(&o.PLL2CCR.Reg, volatile.LoadUint16(&o.PLL2CCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetPLL2CCR_PL2SRCSEL() uint16 {
	return (volatile.LoadUint16(&o.PLL2CCR.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetPLL2CCR_PLL2MUL(value uint16) {
	volatile.StoreUint16(&o.PLL2CCR.Reg, volatile.LoadUint16(&o.PLL2CCR.Reg)&^(0x3f00)|value<<8)
}
func (o *SYSC_Type) GetPLL2CCR_PLL2MUL() uint16 {
	return (volatile.LoadUint16(&o.PLL2CCR.Reg) & 0x3f00) >> 8
}

// SYSC.PLL2CR: PLL2 Control Register
func (o *SYSC_Type) SetPLL2CR_PLL2STP(value uint8) {
	volatile.StoreUint8(&o.PLL2CR.Reg, volatile.LoadUint8(&o.PLL2CR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetPLL2CR_PLL2STP() uint8 {
	return volatile.LoadUint8(&o.PLL2CR.Reg) & 0x1
}

// SYSC.MOCOUTCR: MOCO User Trimming Control Register
func (o *SYSC_Type) SetMOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.MOCOUTCR.Reg, value)
}
func (o *SYSC_Type) GetMOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.MOCOUTCR.Reg)
}

// SYSC.HOCOUTCR: HOCO User Trimming Control Register
func (o *SYSC_Type) SetHOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.HOCOUTCR.Reg, value)
}
func (o *SYSC_Type) GetHOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.HOCOUTCR.Reg)
}

// SYSC.USBCKDIVCR: USB Clock Division Control Register
func (o *SYSC_Type) SetUSBCKDIVCR_USBCKDIV(value uint8) {
	volatile.StoreUint8(&o.USBCKDIVCR.Reg, volatile.LoadUint8(&o.USBCKDIVCR.Reg)&^(0x7)|value)
}
func (o *SYSC_Type) GetUSBCKDIVCR_USBCKDIV() uint8 {
	return volatile.LoadUint8(&o.USBCKDIVCR.Reg) & 0x7
}

// SYSC.USBCKCR: USB Clock Control Register
func (o *SYSC_Type) SetUSBCKCR_USBCKSEL(value uint8) {
	volatile.StoreUint8(&o.USBCKCR.Reg, volatile.LoadUint8(&o.USBCKCR.Reg)&^(0x7)|value)
}
func (o *SYSC_Type) GetUSBCKCR_USBCKSEL() uint8 {
	return volatile.LoadUint8(&o.USBCKCR.Reg) & 0x7
}
func (o *SYSC_Type) SetUSBCKCR_USBCKSREQ(value uint8) {
	volatile.StoreUint8(&o.USBCKCR.Reg, volatile.LoadUint8(&o.USBCKCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetUSBCKCR_USBCKSREQ() uint8 {
	return (volatile.LoadUint8(&o.USBCKCR.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetUSBCKCR_USBCKSRDY(value uint8) {
	volatile.StoreUint8(&o.USBCKCR.Reg, volatile.LoadUint8(&o.USBCKCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetUSBCKCR_USBCKSRDY() uint8 {
	return (volatile.LoadUint8(&o.USBCKCR.Reg) & 0x80) >> 7
}

// SYSC.SNZREQCR1: Snooze Request Control Register 1
func (o *SYSC_Type) SetSNZREQCR1_SNZREQEN0(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR1.Reg, volatile.LoadUint32(&o.SNZREQCR1.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSNZREQCR1_SNZREQEN0() uint32 {
	return volatile.LoadUint32(&o.SNZREQCR1.Reg) & 0x1
}
func (o *SYSC_Type) SetSNZREQCR1_SNZREQEN1(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR1.Reg, volatile.LoadUint32(&o.SNZREQCR1.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetSNZREQCR1_SNZREQEN1() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR1.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetSNZREQCR1_SNZREQEN2(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR1.Reg, volatile.LoadUint32(&o.SNZREQCR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetSNZREQCR1_SNZREQEN2() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR1.Reg) & 0x4) >> 2
}

// SYSC.SNZCR: Snooze Control Register
func (o *SYSC_Type) SetSNZCR_RXDREQEN(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSNZCR_RXDREQEN() uint8 {
	return volatile.LoadUint8(&o.SNZCR.Reg) & 0x1
}
func (o *SYSC_Type) SetSNZCR_SNZDTCEN(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetSNZCR_SNZDTCEN() uint8 {
	return (volatile.LoadUint8(&o.SNZCR.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetSNZCR_SNZE(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetSNZCR_SNZE() uint8 {
	return (volatile.LoadUint8(&o.SNZCR.Reg) & 0x80) >> 7
}

// SYSC.SNZEDCR0: Snooze End Control Register 0
func (o *SYSC_Type) SetSNZEDCR0_AGTUNFED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR0.Reg, volatile.LoadUint8(&o.SNZEDCR0.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSNZEDCR0_AGTUNFED() uint8 {
	return volatile.LoadUint8(&o.SNZEDCR0.Reg) & 0x1
}
func (o *SYSC_Type) SetSNZEDCR0_DTCZRED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR0.Reg, volatile.LoadUint8(&o.SNZEDCR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetSNZEDCR0_DTCZRED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR0.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetSNZEDCR0_DTCNZRED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR0.Reg, volatile.LoadUint8(&o.SNZEDCR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetSNZEDCR0_DTCNZRED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR0.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetSNZEDCR0_AD0MATED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR0.Reg, volatile.LoadUint8(&o.SNZEDCR0.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetSNZEDCR0_AD0MATED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR0.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetSNZEDCR0_AD0UMTED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR0.Reg, volatile.LoadUint8(&o.SNZEDCR0.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetSNZEDCR0_AD0UMTED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR0.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetSNZEDCR0_SCI0UMTED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR0.Reg, volatile.LoadUint8(&o.SNZEDCR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetSNZEDCR0_SCI0UMTED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR0.Reg) & 0x80) >> 7
}

// SYSC.SNZEDCR1: Snooze End Control Register 1
func (o *SYSC_Type) SetSNZEDCR1_AGT3UNFED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR1.Reg, volatile.LoadUint8(&o.SNZEDCR1.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSNZEDCR1_AGT3UNFED() uint8 {
	return volatile.LoadUint8(&o.SNZEDCR1.Reg) & 0x1
}

// SYSC.SNZREQCR0: Snooze Request Control Register 0
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN0(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN0() uint32 {
	return volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x1
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN1(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN1() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN2(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN2() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN3(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN3() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN4(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN4() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN5(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x20)|value<<5)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN5() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x20) >> 5
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN6(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN6() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN7(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN7() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x80) >> 7
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN8(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x100)|value<<8)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN8() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x100) >> 8
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN9(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x200)|value<<9)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN9() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x200) >> 9
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN10(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x400)|value<<10)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN10() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x400) >> 10
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN11(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x800)|value<<11)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN11() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x800) >> 11
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN12(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN12() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x1000) >> 12
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN13(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x2000)|value<<13)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN13() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x2000) >> 13
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN14(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x4000)|value<<14)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN14() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x4000) >> 14
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN15(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x8000)|value<<15)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN15() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x8000) >> 15
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN24(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN24() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x1000000) >> 24
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN25(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN25() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x2000000) >> 25
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN28(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN28() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x10000000) >> 28
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN29(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN29() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x20000000) >> 29
}
func (o *SYSC_Type) SetSNZREQCR0_SNZREQEN30(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR0.Reg, volatile.LoadUint32(&o.SNZREQCR0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSC_Type) GetSNZREQCR0_SNZREQEN30() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR0.Reg) & 0x40000000) >> 30
}

// SYSC.OPCCR: Operating Power Control Register
func (o *SYSC_Type) SetOPCCR_OPCM(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetOPCCR_OPCM() uint8 {
	return volatile.LoadUint8(&o.OPCCR.Reg) & 0x3
}
func (o *SYSC_Type) SetOPCCR_OPCMTSF(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetOPCCR_OPCMTSF() uint8 {
	return (volatile.LoadUint8(&o.OPCCR.Reg) & 0x10) >> 4
}

// SYSC.MOSCWTCR: Main Clock Oscillator Wait Control Register
func (o *SYSC_Type) SetMOSCWTCR_MSTS(value uint8) {
	volatile.StoreUint8(&o.MOSCWTCR.Reg, volatile.LoadUint8(&o.MOSCWTCR.Reg)&^(0xf)|value)
}
func (o *SYSC_Type) GetMOSCWTCR_MSTS() uint8 {
	return volatile.LoadUint8(&o.MOSCWTCR.Reg) & 0xf
}

// SYSC.SOPCCR: Sub Operating Power Control Register
func (o *SYSC_Type) SetSOPCCR_SOPCM(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSOPCCR_SOPCM() uint8 {
	return volatile.LoadUint8(&o.SOPCCR.Reg) & 0x1
}
func (o *SYSC_Type) SetSOPCCR_SOPCMTSF(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetSOPCCR_SOPCMTSF() uint8 {
	return (volatile.LoadUint8(&o.SOPCCR.Reg) & 0x10) >> 4
}

// SYSC.RSTSR1: Reset Status Register 1
func (o *SYSC_Type) SetRSTSR1_IWDTRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetRSTSR1_IWDTRF() uint16 {
	return volatile.LoadUint16(&o.RSTSR1.Reg) & 0x1
}
func (o *SYSC_Type) SetRSTSR1_WDTRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetRSTSR1_WDTRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetRSTSR1_SWRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetRSTSR1_SWRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetRSTSR1_RPERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x100)|value<<8)
}
func (o *SYSC_Type) GetRSTSR1_RPERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x100) >> 8
}
func (o *SYSC_Type) SetRSTSR1_BUSMRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x800)|value<<11)
}
func (o *SYSC_Type) GetRSTSR1_BUSMRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x800) >> 11
}
func (o *SYSC_Type) SetRSTSR1_TZERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x2000)|value<<13)
}
func (o *SYSC_Type) GetRSTSR1_TZERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x2000) >> 13
}
func (o *SYSC_Type) SetRSTSR1_CPERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x8000)|value<<15)
}
func (o *SYSC_Type) GetRSTSR1_CPERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x8000) >> 15
}

// SYSC.LVD1CR1: Voltage Monitor 1 Circuit Control Register
func (o *SYSC_Type) SetLVD1CR1_IDTSEL(value uint8) {
	volatile.StoreUint8(&o.LVD1CR1.Reg, volatile.LoadUint8(&o.LVD1CR1.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetLVD1CR1_IDTSEL() uint8 {
	return volatile.LoadUint8(&o.LVD1CR1.Reg) & 0x3
}
func (o *SYSC_Type) SetLVD1CR1_IRQSEL(value uint8) {
	volatile.StoreUint8(&o.LVD1CR1.Reg, volatile.LoadUint8(&o.LVD1CR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetLVD1CR1_IRQSEL() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR1.Reg) & 0x4) >> 2
}

// SYSC.LVD1SR: Voltage Monitor 1 Circuit Status Register
func (o *SYSC_Type) SetLVD1SR_DET(value uint8) {
	volatile.StoreUint8(&o.LVD1SR.Reg, volatile.LoadUint8(&o.LVD1SR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetLVD1SR_DET() uint8 {
	return volatile.LoadUint8(&o.LVD1SR.Reg) & 0x1
}
func (o *SYSC_Type) SetLVD1SR_MON(value uint8) {
	volatile.StoreUint8(&o.LVD1SR.Reg, volatile.LoadUint8(&o.LVD1SR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetLVD1SR_MON() uint8 {
	return (volatile.LoadUint8(&o.LVD1SR.Reg) & 0x2) >> 1
}

// SYSC.LVD2CR1: Voltage Monitor 2 Circuit Control Register 1
func (o *SYSC_Type) SetLVD2CR1_IDTSEL(value uint8) {
	volatile.StoreUint8(&o.LVD2CR1.Reg, volatile.LoadUint8(&o.LVD2CR1.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetLVD2CR1_IDTSEL() uint8 {
	return volatile.LoadUint8(&o.LVD2CR1.Reg) & 0x3
}
func (o *SYSC_Type) SetLVD2CR1_IRQSEL(value uint8) {
	volatile.StoreUint8(&o.LVD2CR1.Reg, volatile.LoadUint8(&o.LVD2CR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetLVD2CR1_IRQSEL() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR1.Reg) & 0x4) >> 2
}

// SYSC.LVD2SR: Voltage Monitor 2 Circuit Status Register
func (o *SYSC_Type) SetLVD2SR_DET(value uint8) {
	volatile.StoreUint8(&o.LVD2SR.Reg, volatile.LoadUint8(&o.LVD2SR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetLVD2SR_DET() uint8 {
	return volatile.LoadUint8(&o.LVD2SR.Reg) & 0x1
}
func (o *SYSC_Type) SetLVD2SR_MON(value uint8) {
	volatile.StoreUint8(&o.LVD2SR.Reg, volatile.LoadUint8(&o.LVD2SR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetLVD2SR_MON() uint8 {
	return (volatile.LoadUint8(&o.LVD2SR.Reg) & 0x2) >> 1
}

// SYSC.CGFSAR: Clock Generation Function Security Attribute Register
func (o *SYSC_Type) SetCGFSAR_NONSEC00(value uint32) {
	volatile.StoreUint32(&o.CGFSAR.Reg, volatile.LoadUint32(&o.CGFSAR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetCGFSAR_NONSEC00() uint32 {
	return volatile.LoadUint32(&o.CGFSAR.Reg) & 0x1
}
func (o *SYSC_Type) SetCGFSAR_NONSEC02(value uint32) {
	volatile.StoreUint32(&o.CGFSAR.Reg, volatile.LoadUint32(&o.CGFSAR.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetCGFSAR_NONSEC02() uint32 {
	return (volatile.LoadUint32(&o.CGFSAR.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetCGFSAR_NONSEC03(value uint32) {
	volatile.StoreUint32(&o.CGFSAR.Reg, volatile.LoadUint32(&o.CGFSAR.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetCGFSAR_NONSEC03() uint32 {
	return (volatile.LoadUint32(&o.CGFSAR.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetCGFSAR_NONSEC04(value uint32) {
	volatile.StoreUint32(&o.CGFSAR.Reg, volatile.LoadUint32(&o.CGFSAR.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetCGFSAR_NONSEC04() uint32 {
	return (volatile.LoadUint32(&o.CGFSAR.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetCGFSAR_NONSEC05(value uint32) {
	volatile.StoreUint32(&o.CGFSAR.Reg, volatile.LoadUint32(&o.CGFSAR.Reg)&^(0x20)|value<<5)
}
func (o *SYSC_Type) GetCGFSAR_NONSEC05() uint32 {
	return (volatile.LoadUint32(&o.CGFSAR.Reg) & 0x20) >> 5
}
func (o *SYSC_Type) SetCGFSAR_NONSEC06(value uint32) {
	volatile.StoreUint32(&o.CGFSAR.Reg, volatile.LoadUint32(&o.CGFSAR.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetCGFSAR_NONSEC06() uint32 {
	return (volatile.LoadUint32(&o.CGFSAR.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetCGFSAR_NONSEC07(value uint32) {
	volatile.StoreUint32(&o.CGFSAR.Reg, volatile.LoadUint32(&o.CGFSAR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetCGFSAR_NONSEC07() uint32 {
	return (volatile.LoadUint32(&o.CGFSAR.Reg) & 0x80) >> 7
}
func (o *SYSC_Type) SetCGFSAR_NONSEC08(value uint32) {
	volatile.StoreUint32(&o.CGFSAR.Reg, volatile.LoadUint32(&o.CGFSAR.Reg)&^(0x100)|value<<8)
}
func (o *SYSC_Type) GetCGFSAR_NONSEC08() uint32 {
	return (volatile.LoadUint32(&o.CGFSAR.Reg) & 0x100) >> 8
}
func (o *SYSC_Type) SetCGFSAR_NONSEC09(value uint32) {
	volatile.StoreUint32(&o.CGFSAR.Reg, volatile.LoadUint32(&o.CGFSAR.Reg)&^(0x200)|value<<9)
}
func (o *SYSC_Type) GetCGFSAR_NONSEC09() uint32 {
	return (volatile.LoadUint32(&o.CGFSAR.Reg) & 0x200) >> 9
}
func (o *SYSC_Type) SetCGFSAR_NONSEC11(value uint32) {
	volatile.StoreUint32(&o.CGFSAR.Reg, volatile.LoadUint32(&o.CGFSAR.Reg)&^(0x800)|value<<11)
}
func (o *SYSC_Type) GetCGFSAR_NONSEC11() uint32 {
	return (volatile.LoadUint32(&o.CGFSAR.Reg) & 0x800) >> 11
}
func (o *SYSC_Type) SetCGFSAR_NONSEC16(value uint32) {
	volatile.StoreUint32(&o.CGFSAR.Reg, volatile.LoadUint32(&o.CGFSAR.Reg)&^(0x10000)|value<<16)
}
func (o *SYSC_Type) GetCGFSAR_NONSEC16() uint32 {
	return (volatile.LoadUint32(&o.CGFSAR.Reg) & 0x10000) >> 16
}

// SYSC.RSTSAR: Reset Security Attribution Register
func (o *SYSC_Type) SetRSTSAR_NONSEC0(value uint32) {
	volatile.StoreUint32(&o.RSTSAR.Reg, volatile.LoadUint32(&o.RSTSAR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetRSTSAR_NONSEC0() uint32 {
	return volatile.LoadUint32(&o.RSTSAR.Reg) & 0x1
}
func (o *SYSC_Type) SetRSTSAR_NONSEC1(value uint32) {
	volatile.StoreUint32(&o.RSTSAR.Reg, volatile.LoadUint32(&o.RSTSAR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetRSTSAR_NONSEC1() uint32 {
	return (volatile.LoadUint32(&o.RSTSAR.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetRSTSAR_NONSEC2(value uint32) {
	volatile.StoreUint32(&o.RSTSAR.Reg, volatile.LoadUint32(&o.RSTSAR.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetRSTSAR_NONSEC2() uint32 {
	return (volatile.LoadUint32(&o.RSTSAR.Reg) & 0x4) >> 2
}

// SYSC.LPMSAR: Low Power Mode Security Attribution Register
func (o *SYSC_Type) SetLPMSAR_NONSEC0(value uint32) {
	volatile.StoreUint32(&o.LPMSAR.Reg, volatile.LoadUint32(&o.LPMSAR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetLPMSAR_NONSEC0() uint32 {
	return volatile.LoadUint32(&o.LPMSAR.Reg) & 0x1
}
func (o *SYSC_Type) SetLPMSAR_NONSEC2(value uint32) {
	volatile.StoreUint32(&o.LPMSAR.Reg, volatile.LoadUint32(&o.LPMSAR.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetLPMSAR_NONSEC2() uint32 {
	return (volatile.LoadUint32(&o.LPMSAR.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetLPMSAR_NONSEC4(value uint32) {
	volatile.StoreUint32(&o.LPMSAR.Reg, volatile.LoadUint32(&o.LPMSAR.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetLPMSAR_NONSEC4() uint32 {
	return (volatile.LoadUint32(&o.LPMSAR.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetLPMSAR_NONSEC8(value uint32) {
	volatile.StoreUint32(&o.LPMSAR.Reg, volatile.LoadUint32(&o.LPMSAR.Reg)&^(0x100)|value<<8)
}
func (o *SYSC_Type) GetLPMSAR_NONSEC8() uint32 {
	return (volatile.LoadUint32(&o.LPMSAR.Reg) & 0x100) >> 8
}
func (o *SYSC_Type) SetLPMSAR_NONSEC9(value uint32) {
	volatile.StoreUint32(&o.LPMSAR.Reg, volatile.LoadUint32(&o.LPMSAR.Reg)&^(0x200)|value<<9)
}
func (o *SYSC_Type) GetLPMSAR_NONSEC9() uint32 {
	return (volatile.LoadUint32(&o.LPMSAR.Reg) & 0x200) >> 9
}

// SYSC.LVDSAR: Low Voltage Detection Security Attribution Register
func (o *SYSC_Type) SetLVDSAR_NONSEC0(value uint32) {
	volatile.StoreUint32(&o.LVDSAR.Reg, volatile.LoadUint32(&o.LVDSAR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetLVDSAR_NONSEC0() uint32 {
	return volatile.LoadUint32(&o.LVDSAR.Reg) & 0x1
}
func (o *SYSC_Type) SetLVDSAR_NONSEC1(value uint32) {
	volatile.StoreUint32(&o.LVDSAR.Reg, volatile.LoadUint32(&o.LVDSAR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetLVDSAR_NONSEC1() uint32 {
	return (volatile.LoadUint32(&o.LVDSAR.Reg) & 0x2) >> 1
}

// SYSC.BBFSAR: Battery Backup Function Security Attribute Register
func (o *SYSC_Type) SetBBFSAR_NONSEC0(value uint32) {
	volatile.StoreUint32(&o.BBFSAR.Reg, volatile.LoadUint32(&o.BBFSAR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetBBFSAR_NONSEC0() uint32 {
	return volatile.LoadUint32(&o.BBFSAR.Reg) & 0x1
}
func (o *SYSC_Type) SetBBFSAR_NONSEC1(value uint32) {
	volatile.StoreUint32(&o.BBFSAR.Reg, volatile.LoadUint32(&o.BBFSAR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetBBFSAR_NONSEC1() uint32 {
	return (volatile.LoadUint32(&o.BBFSAR.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetBBFSAR_NONSEC2(value uint32) {
	volatile.StoreUint32(&o.BBFSAR.Reg, volatile.LoadUint32(&o.BBFSAR.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetBBFSAR_NONSEC2() uint32 {
	return (volatile.LoadUint32(&o.BBFSAR.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetBBFSAR_NONSEC16(value uint32) {
	volatile.StoreUint32(&o.BBFSAR.Reg, volatile.LoadUint32(&o.BBFSAR.Reg)&^(0x10000)|value<<16)
}
func (o *SYSC_Type) GetBBFSAR_NONSEC16() uint32 {
	return (volatile.LoadUint32(&o.BBFSAR.Reg) & 0x10000) >> 16
}
func (o *SYSC_Type) SetBBFSAR_NONSEC17(value uint32) {
	volatile.StoreUint32(&o.BBFSAR.Reg, volatile.LoadUint32(&o.BBFSAR.Reg)&^(0x20000)|value<<17)
}
func (o *SYSC_Type) GetBBFSAR_NONSEC17() uint32 {
	return (volatile.LoadUint32(&o.BBFSAR.Reg) & 0x20000) >> 17
}
func (o *SYSC_Type) SetBBFSAR_NONSEC18(value uint32) {
	volatile.StoreUint32(&o.BBFSAR.Reg, volatile.LoadUint32(&o.BBFSAR.Reg)&^(0x40000)|value<<18)
}
func (o *SYSC_Type) GetBBFSAR_NONSEC18() uint32 {
	return (volatile.LoadUint32(&o.BBFSAR.Reg) & 0x40000) >> 18
}
func (o *SYSC_Type) SetBBFSAR_NONSEC19(value uint32) {
	volatile.StoreUint32(&o.BBFSAR.Reg, volatile.LoadUint32(&o.BBFSAR.Reg)&^(0x80000)|value<<19)
}
func (o *SYSC_Type) GetBBFSAR_NONSEC19() uint32 {
	return (volatile.LoadUint32(&o.BBFSAR.Reg) & 0x80000) >> 19
}
func (o *SYSC_Type) SetBBFSAR_NONSEC20(value uint32) {
	volatile.StoreUint32(&o.BBFSAR.Reg, volatile.LoadUint32(&o.BBFSAR.Reg)&^(0x100000)|value<<20)
}
func (o *SYSC_Type) GetBBFSAR_NONSEC20() uint32 {
	return (volatile.LoadUint32(&o.BBFSAR.Reg) & 0x100000) >> 20
}
func (o *SYSC_Type) SetBBFSAR_NONSEC21(value uint32) {
	volatile.StoreUint32(&o.BBFSAR.Reg, volatile.LoadUint32(&o.BBFSAR.Reg)&^(0x200000)|value<<21)
}
func (o *SYSC_Type) GetBBFSAR_NONSEC21() uint32 {
	return (volatile.LoadUint32(&o.BBFSAR.Reg) & 0x200000) >> 21
}
func (o *SYSC_Type) SetBBFSAR_NONSEC22(value uint32) {
	volatile.StoreUint32(&o.BBFSAR.Reg, volatile.LoadUint32(&o.BBFSAR.Reg)&^(0x400000)|value<<22)
}
func (o *SYSC_Type) GetBBFSAR_NONSEC22() uint32 {
	return (volatile.LoadUint32(&o.BBFSAR.Reg) & 0x400000) >> 22
}
func (o *SYSC_Type) SetBBFSAR_NONSEC23(value uint32) {
	volatile.StoreUint32(&o.BBFSAR.Reg, volatile.LoadUint32(&o.BBFSAR.Reg)&^(0x800000)|value<<23)
}
func (o *SYSC_Type) GetBBFSAR_NONSEC23() uint32 {
	return (volatile.LoadUint32(&o.BBFSAR.Reg) & 0x800000) >> 23
}

// SYSC.DPFSAR: Deep Standby Interrupt Factor Security Attribution Register
func (o *SYSC_Type) SetDPFSAR_DPFSA00(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA00() uint32 {
	return volatile.LoadUint32(&o.DPFSAR.Reg) & 0x1
}
func (o *SYSC_Type) SetDPFSAR_DPFSA01(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA01() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetDPFSAR_DPFSA04(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA04() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetDPFSAR_DPFSA05(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x20)|value<<5)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA05() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x20) >> 5
}
func (o *SYSC_Type) SetDPFSAR_DPFSA06(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA06() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetDPFSAR_DPFSA07(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA07() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x80) >> 7
}
func (o *SYSC_Type) SetDPFSAR_DPFSA08(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x100)|value<<8)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA08() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x100) >> 8
}
func (o *SYSC_Type) SetDPFSAR_DPFSA09(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x200)|value<<9)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA09() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x200) >> 9
}
func (o *SYSC_Type) SetDPFSAR_DPFSA10(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x400)|value<<10)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA10() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x400) >> 10
}
func (o *SYSC_Type) SetDPFSAR_DPFSA11(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x800)|value<<11)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA11() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x800) >> 11
}
func (o *SYSC_Type) SetDPFSAR_DPFSA12(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x1000)|value<<12)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA12() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x1000) >> 12
}
func (o *SYSC_Type) SetDPFSAR_DPFSA14(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x4000)|value<<14)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA14() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x4000) >> 14
}
func (o *SYSC_Type) SetDPFSAR_DPFSA15(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x8000)|value<<15)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA15() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x8000) >> 15
}
func (o *SYSC_Type) SetDPFSAR_DPFSA16(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x10000)|value<<16)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA16() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x10000) >> 16
}
func (o *SYSC_Type) SetDPFSAR_DPFSA17(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x20000)|value<<17)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA17() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x20000) >> 17
}
func (o *SYSC_Type) SetDPFSAR_DPFSA18(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x40000)|value<<18)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA18() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x40000) >> 18
}
func (o *SYSC_Type) SetDPFSAR_DPFSA19(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x80000)|value<<19)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA19() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x80000) >> 19
}
func (o *SYSC_Type) SetDPFSAR_DPFSA20(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x100000)|value<<20)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA20() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x100000) >> 20
}
func (o *SYSC_Type) SetDPFSAR_DPFSA24(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA24() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x1000000) >> 24
}
func (o *SYSC_Type) SetDPFSAR_DPFSA26(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA26() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x4000000) >> 26
}
func (o *SYSC_Type) SetDPFSAR_DPFSA27(value uint32) {
	volatile.StoreUint32(&o.DPFSAR.Reg, volatile.LoadUint32(&o.DPFSAR.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSC_Type) GetDPFSAR_DPFSA27() uint32 {
	return (volatile.LoadUint32(&o.DPFSAR.Reg) & 0x8000000) >> 27
}

// SYSC.PRCR: Protect Register
func (o *SYSC_Type) SetPRCR_PRC0(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetPRCR_PRC0() uint16 {
	return volatile.LoadUint16(&o.PRCR.Reg) & 0x1
}
func (o *SYSC_Type) SetPRCR_PRC1(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetPRCR_PRC1() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetPRCR_PRC3(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetPRCR_PRC3() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetPRCR_PRC4(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetPRCR_PRC4() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetPRCR_PRKEY(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0xff00)|value<<8)
}
func (o *SYSC_Type) GetPRCR_PRKEY() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0xff00) >> 8
}

// SYSC.DPSBYCR: Deep Standby Control Register
func (o *SYSC_Type) SetDPSBYCR_DEEPCUT(value uint8) {
	volatile.StoreUint8(&o.DPSBYCR.Reg, volatile.LoadUint8(&o.DPSBYCR.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetDPSBYCR_DEEPCUT() uint8 {
	return volatile.LoadUint8(&o.DPSBYCR.Reg) & 0x3
}
func (o *SYSC_Type) SetDPSBYCR_IOKEEP(value uint8) {
	volatile.StoreUint8(&o.DPSBYCR.Reg, volatile.LoadUint8(&o.DPSBYCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetDPSBYCR_IOKEEP() uint8 {
	return (volatile.LoadUint8(&o.DPSBYCR.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetDPSBYCR_DPSBY(value uint8) {
	volatile.StoreUint8(&o.DPSBYCR.Reg, volatile.LoadUint8(&o.DPSBYCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetDPSBYCR_DPSBY() uint8 {
	return (volatile.LoadUint8(&o.DPSBYCR.Reg) & 0x80) >> 7
}

// SYSC.DPSWCR: Deep Standby Wait Control Register
func (o *SYSC_Type) SetDPSWCR_WTSTS(value uint8) {
	volatile.StoreUint8(&o.DPSWCR.Reg, volatile.LoadUint8(&o.DPSWCR.Reg)&^(0x3f)|value)
}
func (o *SYSC_Type) GetDPSWCR_WTSTS() uint8 {
	return volatile.LoadUint8(&o.DPSWCR.Reg) & 0x3f
}

// SYSC.DPSIER0: Deep Standby Interrupt Enable Register 0
func (o *SYSC_Type) SetDPSIER0_DIRQ0E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetDPSIER0_DIRQ0E() uint8 {
	return volatile.LoadUint8(&o.DPSIER0.Reg) & 0x1
}
func (o *SYSC_Type) SetDPSIER0_DIRQ1E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetDPSIER0_DIRQ1E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER0.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetDPSIER0_DIRQ4E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetDPSIER0_DIRQ4E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER0.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetDPSIER0_DIRQ5E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x20)|value<<5)
}
func (o *SYSC_Type) GetDPSIER0_DIRQ5E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER0.Reg) & 0x20) >> 5
}
func (o *SYSC_Type) SetDPSIER0_DIRQ6E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetDPSIER0_DIRQ6E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER0.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetDPSIER0_DIRQ7E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetDPSIER0_DIRQ7E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER0.Reg) & 0x80) >> 7
}

// SYSC.DPSIER1: Deep Standby Interrupt Enable Register 1
func (o *SYSC_Type) SetDPSIER1_DIRQ8E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetDPSIER1_DIRQ8E() uint8 {
	return volatile.LoadUint8(&o.DPSIER1.Reg) & 0x1
}
func (o *SYSC_Type) SetDPSIER1_DIRQ9E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetDPSIER1_DIRQ9E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER1.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetDPSIER1_DIRQ10E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetDPSIER1_DIRQ10E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER1.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetDPSIER1_DIRQ11E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetDPSIER1_DIRQ11E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER1.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetDPSIER1_DIRQ12E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetDPSIER1_DIRQ12E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER1.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetDPSIER1_DIRQ14E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetDPSIER1_DIRQ14E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER1.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetDPSIER1_DIRQ15E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetDPSIER1_DIRQ15E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER1.Reg) & 0x80) >> 7
}

// SYSC.DPSIER2: Deep Standby Interrupt Enable Register 2
func (o *SYSC_Type) SetDPSIER2_DLVD1IE(value uint8) {
	volatile.StoreUint8(&o.DPSIER2.Reg, volatile.LoadUint8(&o.DPSIER2.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetDPSIER2_DLVD1IE() uint8 {
	return volatile.LoadUint8(&o.DPSIER2.Reg) & 0x1
}
func (o *SYSC_Type) SetDPSIER2_DLVD2IE(value uint8) {
	volatile.StoreUint8(&o.DPSIER2.Reg, volatile.LoadUint8(&o.DPSIER2.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetDPSIER2_DLVD2IE() uint8 {
	return (volatile.LoadUint8(&o.DPSIER2.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetDPSIER2_DRTCIIE(value uint8) {
	volatile.StoreUint8(&o.DPSIER2.Reg, volatile.LoadUint8(&o.DPSIER2.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetDPSIER2_DRTCIIE() uint8 {
	return (volatile.LoadUint8(&o.DPSIER2.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetDPSIER2_DRTCAIE(value uint8) {
	volatile.StoreUint8(&o.DPSIER2.Reg, volatile.LoadUint8(&o.DPSIER2.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetDPSIER2_DRTCAIE() uint8 {
	return (volatile.LoadUint8(&o.DPSIER2.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetDPSIER2_DNMIE(value uint8) {
	volatile.StoreUint8(&o.DPSIER2.Reg, volatile.LoadUint8(&o.DPSIER2.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetDPSIER2_DNMIE() uint8 {
	return (volatile.LoadUint8(&o.DPSIER2.Reg) & 0x10) >> 4
}

// SYSC.DPSIER3: Deep Standby Interrupt Enable Register 3
func (o *SYSC_Type) SetDPSIER3_DUSBFS0IE(value uint8) {
	volatile.StoreUint8(&o.DPSIER3.Reg, volatile.LoadUint8(&o.DPSIER3.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetDPSIER3_DUSBFS0IE() uint8 {
	return volatile.LoadUint8(&o.DPSIER3.Reg) & 0x1
}
func (o *SYSC_Type) SetDPSIER3_DAGT1IE(value uint8) {
	volatile.StoreUint8(&o.DPSIER3.Reg, volatile.LoadUint8(&o.DPSIER3.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetDPSIER3_DAGT1IE() uint8 {
	return (volatile.LoadUint8(&o.DPSIER3.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetDPSIER3_DAGT3IE(value uint8) {
	volatile.StoreUint8(&o.DPSIER3.Reg, volatile.LoadUint8(&o.DPSIER3.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetDPSIER3_DAGT3IE() uint8 {
	return (volatile.LoadUint8(&o.DPSIER3.Reg) & 0x8) >> 3
}

// SYSC.DPSIFR0: Deep Standby Interrupt Flag Register 0
func (o *SYSC_Type) SetDPSIFR0_DIRQ0F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetDPSIFR0_DIRQ0F() uint8 {
	return volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x1
}
func (o *SYSC_Type) SetDPSIFR0_DIRQ1F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetDPSIFR0_DIRQ1F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetDPSIFR0_DIRQ4F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetDPSIFR0_DIRQ4F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetDPSIFR0_DIRQ5F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x20)|value<<5)
}
func (o *SYSC_Type) GetDPSIFR0_DIRQ5F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x20) >> 5
}
func (o *SYSC_Type) SetDPSIFR0_DIRQ6F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetDPSIFR0_DIRQ6F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetDPSIFR0_DIRQ7F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetDPSIFR0_DIRQ7F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x80) >> 7
}

// SYSC.DPSIFR1: Deep Standby Interrupt Flag Register 1
func (o *SYSC_Type) SetDPSIFR1_DIRQ8F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetDPSIFR1_DIRQ8F() uint8 {
	return volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x1
}
func (o *SYSC_Type) SetDPSIFR1_DIRQ9F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetDPSIFR1_DIRQ9F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetDPSIFR1_DIRQ10F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetDPSIFR1_DIRQ10F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetDPSIFR1_DIRQ11F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetDPSIFR1_DIRQ11F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetDPSIFR1_DIRQ12F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetDPSIFR1_DIRQ12F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetDPSIFR1_DIRQ14F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetDPSIFR1_DIRQ14F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetDPSIFR1_DIRQ15F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetDPSIFR1_DIRQ15F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x80) >> 7
}

// SYSC.DPSIFR2: Deep Standby Interrupt Flag Register 2
func (o *SYSC_Type) SetDPSIFR2_DLVD1IF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR2.Reg, volatile.LoadUint8(&o.DPSIFR2.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetDPSIFR2_DLVD1IF() uint8 {
	return volatile.LoadUint8(&o.DPSIFR2.Reg) & 0x1
}
func (o *SYSC_Type) SetDPSIFR2_DLVD2IF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR2.Reg, volatile.LoadUint8(&o.DPSIFR2.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetDPSIFR2_DLVD2IF() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR2.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetDPSIFR2_DRTCIIF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR2.Reg, volatile.LoadUint8(&o.DPSIFR2.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetDPSIFR2_DRTCIIF() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR2.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetDPSIFR2_DRTCAIF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR2.Reg, volatile.LoadUint8(&o.DPSIFR2.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetDPSIFR2_DRTCAIF() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR2.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetDPSIFR2_DNMIF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR2.Reg, volatile.LoadUint8(&o.DPSIFR2.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetDPSIFR2_DNMIF() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR2.Reg) & 0x10) >> 4
}

// SYSC.DPSIFR3: Deep Standby Interrupt Flag Register 3
func (o *SYSC_Type) SetDPSIFR3_DUSBFS0IF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR3.Reg, volatile.LoadUint8(&o.DPSIFR3.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetDPSIFR3_DUSBFS0IF() uint8 {
	return volatile.LoadUint8(&o.DPSIFR3.Reg) & 0x1
}
func (o *SYSC_Type) SetDPSIFR3_DAGT1IF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR3.Reg, volatile.LoadUint8(&o.DPSIFR3.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetDPSIFR3_DAGT1IF() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR3.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetDPSIFR3_DAGT3IF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR3.Reg, volatile.LoadUint8(&o.DPSIFR3.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetDPSIFR3_DAGT3IF() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR3.Reg) & 0x8) >> 3
}

// SYSC.DPSIEGR0: Deep Standby Interrupt Edge Register 0
func (o *SYSC_Type) SetDPSIEGR0_DIRQ0EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetDPSIEGR0_DIRQ0EG() uint8 {
	return volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x1
}
func (o *SYSC_Type) SetDPSIEGR0_DIRQ1EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetDPSIEGR0_DIRQ1EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetDPSIEGR0_DIRQ4EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetDPSIEGR0_DIRQ4EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetDPSIEGR0_DIRQ5EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x20)|value<<5)
}
func (o *SYSC_Type) GetDPSIEGR0_DIRQ5EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x20) >> 5
}
func (o *SYSC_Type) SetDPSIEGR0_DIRQ6EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetDPSIEGR0_DIRQ6EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetDPSIEGR0_DIRQ7EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetDPSIEGR0_DIRQ7EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x80) >> 7
}

// SYSC.DPSIEGR1: Deep Standby Interrupt Edge Register 1
func (o *SYSC_Type) SetDPSIEGR1_DIRQ8EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetDPSIEGR1_DIRQ8EG() uint8 {
	return volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x1
}
func (o *SYSC_Type) SetDPSIEGR1_DIRQ9EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetDPSIEGR1_DIRQ9EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetDPSIEGR1_DIRQ10EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetDPSIEGR1_DIRQ10EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetDPSIEGR1_DIRQ11EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetDPSIEGR1_DIRQ11EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetDPSIEGR1_DIRQ12EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetDPSIEGR1_DIRQ12EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetDPSIEGR1_DIRQ14EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetDPSIEGR1_DIRQ14EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetDPSIEGR1_DIRQ15EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetDPSIEGR1_DIRQ15EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x80) >> 7
}

// SYSC.DPSIEGR2: Deep Standby Interrupt Edge Register 2
func (o *SYSC_Type) SetDPSIEGR2_DLVD1EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR2.Reg, volatile.LoadUint8(&o.DPSIEGR2.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetDPSIEGR2_DLVD1EG() uint8 {
	return volatile.LoadUint8(&o.DPSIEGR2.Reg) & 0x1
}
func (o *SYSC_Type) SetDPSIEGR2_DLVD2EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR2.Reg, volatile.LoadUint8(&o.DPSIEGR2.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetDPSIEGR2_DLVD2EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR2.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetDPSIEGR2_DNMIEG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR2.Reg, volatile.LoadUint8(&o.DPSIEGR2.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetDPSIEGR2_DNMIEG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR2.Reg) & 0x10) >> 4
}

// SYSC.SYOCDCR: System Control OCD Control Register
func (o *SYSC_Type) SetSYOCDCR_DOCDF(value uint8) {
	volatile.StoreUint8(&o.SYOCDCR.Reg, volatile.LoadUint8(&o.SYOCDCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSYOCDCR_DOCDF() uint8 {
	return volatile.LoadUint8(&o.SYOCDCR.Reg) & 0x1
}
func (o *SYSC_Type) SetSYOCDCR_DBGEN(value uint8) {
	volatile.StoreUint8(&o.SYOCDCR.Reg, volatile.LoadUint8(&o.SYOCDCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetSYOCDCR_DBGEN() uint8 {
	return (volatile.LoadUint8(&o.SYOCDCR.Reg) & 0x80) >> 7
}

// SYSC.RSTSR0: Reset Status Register 0
func (o *SYSC_Type) SetRSTSR0_PORF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetRSTSR0_PORF() uint8 {
	return volatile.LoadUint8(&o.RSTSR0.Reg) & 0x1
}
func (o *SYSC_Type) SetRSTSR0_LVD0RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetRSTSR0_LVD0RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetRSTSR0_LVD1RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetRSTSR0_LVD1RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetRSTSR0_LVD2RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetRSTSR0_LVD2RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetRSTSR0_DPSRSTF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetRSTSR0_DPSRSTF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x80) >> 7
}

// SYSC.RSTSR2: Reset Status Register 2
func (o *SYSC_Type) SetRSTSR2_CWSF(value uint8) {
	volatile.StoreUint8(&o.RSTSR2.Reg, volatile.LoadUint8(&o.RSTSR2.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetRSTSR2_CWSF() uint8 {
	return volatile.LoadUint8(&o.RSTSR2.Reg) & 0x1
}

// SYSC.MOMCR: Main Clock Oscillator Mode Oscillation Control Register
func (o *SYSC_Type) SetMOMCR_MODRV(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x30)|value<<4)
}
func (o *SYSC_Type) GetMOMCR_MODRV() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x30) >> 4
}
func (o *SYSC_Type) SetMOMCR_MOSEL(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetMOMCR_MOSEL() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x40) >> 6
}

// SYSC.FWEPROR: Flash P/E Protect Register
func (o *SYSC_Type) SetFWEPROR_FLWE(value uint8) {
	volatile.StoreUint8(&o.FWEPROR.Reg, volatile.LoadUint8(&o.FWEPROR.Reg)&^(0x3)|value)
}
func (o *SYSC_Type) GetFWEPROR_FLWE() uint8 {
	return volatile.LoadUint8(&o.FWEPROR.Reg) & 0x3
}

// SYSC.LVD1CMPCR: Voltage Monitoring 1 Comparator Control Register
func (o *SYSC_Type) SetLVD1CMPCR_LVD1LVL(value uint8) {
	volatile.StoreUint8(&o.LVD1CMPCR.Reg, volatile.LoadUint8(&o.LVD1CMPCR.Reg)&^(0x1f)|value)
}
func (o *SYSC_Type) GetLVD1CMPCR_LVD1LVL() uint8 {
	return volatile.LoadUint8(&o.LVD1CMPCR.Reg) & 0x1f
}
func (o *SYSC_Type) SetLVD1CMPCR_LVD1E(value uint8) {
	volatile.StoreUint8(&o.LVD1CMPCR.Reg, volatile.LoadUint8(&o.LVD1CMPCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetLVD1CMPCR_LVD1E() uint8 {
	return (volatile.LoadUint8(&o.LVD1CMPCR.Reg) & 0x80) >> 7
}

// SYSC.LVD2CMPCR: Voltage Monitoring 2 Comparator Control Register
func (o *SYSC_Type) SetLVD2CMPCR_LVD2LVL(value uint8) {
	volatile.StoreUint8(&o.LVD2CMPCR.Reg, volatile.LoadUint8(&o.LVD2CMPCR.Reg)&^(0x7)|value)
}
func (o *SYSC_Type) GetLVD2CMPCR_LVD2LVL() uint8 {
	return volatile.LoadUint8(&o.LVD2CMPCR.Reg) & 0x7
}
func (o *SYSC_Type) SetLVD2CMPCR_LVD2E(value uint8) {
	volatile.StoreUint8(&o.LVD2CMPCR.Reg, volatile.LoadUint8(&o.LVD2CMPCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetLVD2CMPCR_LVD2E() uint8 {
	return (volatile.LoadUint8(&o.LVD2CMPCR.Reg) & 0x80) >> 7
}

// SYSC.LVD1CR0: Voltage Monitor 1 Circuit Control Register 0
func (o *SYSC_Type) SetLVD1CR0_RIE(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetLVD1CR0_RIE() uint8 {
	return volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x1
}
func (o *SYSC_Type) SetLVD1CR0_DFDIS(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetLVD1CR0_DFDIS() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetLVD1CR0_CMPE(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetLVD1CR0_CMPE() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetLVD1CR0_FSAMP(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x30)|value<<4)
}
func (o *SYSC_Type) GetLVD1CR0_FSAMP() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x30) >> 4
}
func (o *SYSC_Type) SetLVD1CR0_RI(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetLVD1CR0_RI() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetLVD1CR0_RN(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetLVD1CR0_RN() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x80) >> 7
}

// SYSC.LVD2CR0: Voltage Monitor 2 Circuit Control Register 0
func (o *SYSC_Type) SetLVD2CR0_RIE(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetLVD2CR0_RIE() uint8 {
	return volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x1
}
func (o *SYSC_Type) SetLVD2CR0_DFDIS(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetLVD2CR0_DFDIS() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetLVD2CR0_CMPE(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetLVD2CR0_CMPE() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetLVD2CR0_FSAMP(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x30)|value<<4)
}
func (o *SYSC_Type) GetLVD2CR0_FSAMP() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x30) >> 4
}
func (o *SYSC_Type) SetLVD2CR0_RI(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSC_Type) GetLVD2CR0_RI() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x40) >> 6
}
func (o *SYSC_Type) SetLVD2CR0_RN(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSC_Type) GetLVD2CR0_RN() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x80) >> 7
}

// SYSC.VBATTMNSELR: Battery Backup Voltage Monitor Function Select Register
func (o *SYSC_Type) SetVBATTMNSELR_VBATTMNSEL(value uint8) {
	volatile.StoreUint8(&o.VBATTMNSELR.Reg, volatile.LoadUint8(&o.VBATTMNSELR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetVBATTMNSELR_VBATTMNSEL() uint8 {
	return volatile.LoadUint8(&o.VBATTMNSELR.Reg) & 0x1
}

// SYSC.VBATTMONR: Battery Backup Voltage Monitor Register
func (o *SYSC_Type) SetVBATTMONR_VBATTMON(value uint8) {
	volatile.StoreUint8(&o.VBATTMONR.Reg, volatile.LoadUint8(&o.VBATTMONR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetVBATTMONR_VBATTMON() uint8 {
	return volatile.LoadUint8(&o.VBATTMONR.Reg) & 0x1
}

// SYSC.SOSCCR: Sub-Clock Oscillator Control Register
func (o *SYSC_Type) SetSOSCCR_SOSTP(value uint8) {
	volatile.StoreUint8(&o.SOSCCR.Reg, volatile.LoadUint8(&o.SOSCCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSOSCCR_SOSTP() uint8 {
	return volatile.LoadUint8(&o.SOSCCR.Reg) & 0x1
}

// SYSC.SOMCR: Sub-Clock Oscillator Mode Control Register
func (o *SYSC_Type) SetSOMCR_SODRV(value uint8) {
	volatile.StoreUint8(&o.SOMCR.Reg, volatile.LoadUint8(&o.SOMCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetSOMCR_SODRV() uint8 {
	return (volatile.LoadUint8(&o.SOMCR.Reg) & 0x2) >> 1
}

// SYSC.LOCOCR: Low-Speed On-Chip Oscillator Control Register
func (o *SYSC_Type) SetLOCOCR_LCSTP(value uint8) {
	volatile.StoreUint8(&o.LOCOCR.Reg, volatile.LoadUint8(&o.LOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetLOCOCR_LCSTP() uint8 {
	return volatile.LoadUint8(&o.LOCOCR.Reg) & 0x1
}

// SYSC.LOCOUTCR: LOCO User Trimming Control Register
func (o *SYSC_Type) SetLOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.LOCOUTCR.Reg, value)
}
func (o *SYSC_Type) GetLOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.LOCOUTCR.Reg)
}

// SYSC.VBTICTLR: VBATT Input Control Register
func (o *SYSC_Type) SetVBTICTLR_VCH0INEN(value uint8) {
	volatile.StoreUint8(&o.VBTICTLR.Reg, volatile.LoadUint8(&o.VBTICTLR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetVBTICTLR_VCH0INEN() uint8 {
	return volatile.LoadUint8(&o.VBTICTLR.Reg) & 0x1
}
func (o *SYSC_Type) SetVBTICTLR_VCH1INEN(value uint8) {
	volatile.StoreUint8(&o.VBTICTLR.Reg, volatile.LoadUint8(&o.VBTICTLR.Reg)&^(0x2)|value<<1)
}
func (o *SYSC_Type) GetVBTICTLR_VCH1INEN() uint8 {
	return (volatile.LoadUint8(&o.VBTICTLR.Reg) & 0x2) >> 1
}
func (o *SYSC_Type) SetVBTICTLR_VCH2INEN(value uint8) {
	volatile.StoreUint8(&o.VBTICTLR.Reg, volatile.LoadUint8(&o.VBTICTLR.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetVBTICTLR_VCH2INEN() uint8 {
	return (volatile.LoadUint8(&o.VBTICTLR.Reg) & 0x4) >> 2
}

// SYSC.VBTBER: VBATT Backup Enable Register
func (o *SYSC_Type) SetVBTBER_VBAE(value uint8) {
	volatile.StoreUint8(&o.VBTBER.Reg, volatile.LoadUint8(&o.VBTBER.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetVBTBER_VBAE() uint8 {
	return (volatile.LoadUint8(&o.VBTBER.Reg) & 0x8) >> 3
}

// SYSC.VBTBKR: VBATT Backup Register
func (o *SYSC_Type) SetVBTBKR(idx int, value uint8) {
	volatile.StoreUint8(&o.VBTBKR[idx].Reg, value)
}
func (o *SYSC_Type) GetVBTBKR(idx int) uint8 {
	return volatile.LoadUint8(&o.VBTBKR[idx].Reg)
}

// Pmn Pin FunctionPort 0 Control RegistersPmn Pin Function Control Register
type PORT0_Type struct {
	PCNTR1 volatile.Register32 // 0x0
	PCNTR2 volatile.Register32 // 0x4
	PCNTR3 volatile.Register32 // 0x8
}

// PORT0.PCNTR1: Port Control Register 1
func (o *PORT0_Type) SetPCNTR1_PDR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x1)|value)
}
func (o *PORT0_Type) GetPCNTR1_PDR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR1.Reg) & 0x1
}
func (o *PORT0_Type) SetPCNTR1_PDR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x2)|value<<1)
}
func (o *PORT0_Type) GetPCNTR1_PDR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x2) >> 1
}
func (o *PORT0_Type) SetPCNTR1_PDR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x4)|value<<2)
}
func (o *PORT0_Type) GetPCNTR1_PDR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x4) >> 2
}
func (o *PORT0_Type) SetPCNTR1_PDR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x8)|value<<3)
}
func (o *PORT0_Type) GetPCNTR1_PDR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x8) >> 3
}
func (o *PORT0_Type) SetPCNTR1_PDR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x10)|value<<4)
}
func (o *PORT0_Type) GetPCNTR1_PDR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x10) >> 4
}
func (o *PORT0_Type) SetPCNTR1_PDR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x20)|value<<5)
}
func (o *PORT0_Type) GetPCNTR1_PDR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x20) >> 5
}
func (o *PORT0_Type) SetPCNTR1_PDR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x40)|value<<6)
}
func (o *PORT0_Type) GetPCNTR1_PDR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x40) >> 6
}
func (o *PORT0_Type) SetPCNTR1_PDR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x80)|value<<7)
}
func (o *PORT0_Type) GetPCNTR1_PDR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x80) >> 7
}
func (o *PORT0_Type) SetPCNTR1_PDR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x100)|value<<8)
}
func (o *PORT0_Type) GetPCNTR1_PDR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x100) >> 8
}
func (o *PORT0_Type) SetPCNTR1_PDR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x200)|value<<9)
}
func (o *PORT0_Type) GetPCNTR1_PDR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x200) >> 9
}
func (o *PORT0_Type) SetPCNTR1_PDR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x400)|value<<10)
}
func (o *PORT0_Type) GetPCNTR1_PDR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x400) >> 10
}
func (o *PORT0_Type) SetPCNTR1_PDR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x800)|value<<11)
}
func (o *PORT0_Type) GetPCNTR1_PDR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x800) >> 11
}
func (o *PORT0_Type) SetPCNTR1_PDR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x1000)|value<<12)
}
func (o *PORT0_Type) GetPCNTR1_PDR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x1000) >> 12
}
func (o *PORT0_Type) SetPCNTR1_PDR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x2000)|value<<13)
}
func (o *PORT0_Type) GetPCNTR1_PDR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x2000) >> 13
}
func (o *PORT0_Type) SetPCNTR1_PDR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x4000)|value<<14)
}
func (o *PORT0_Type) GetPCNTR1_PDR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x4000) >> 14
}
func (o *PORT0_Type) SetPCNTR1_PDR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x8000)|value<<15)
}
func (o *PORT0_Type) GetPCNTR1_PDR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x8000) >> 15
}
func (o *PORT0_Type) SetPCNTR1_PODR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x10000)|value<<16)
}
func (o *PORT0_Type) GetPCNTR1_PODR00() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x10000) >> 16
}
func (o *PORT0_Type) SetPCNTR1_PODR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x20000)|value<<17)
}
func (o *PORT0_Type) GetPCNTR1_PODR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x20000) >> 17
}
func (o *PORT0_Type) SetPCNTR1_PODR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x40000)|value<<18)
}
func (o *PORT0_Type) GetPCNTR1_PODR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x40000) >> 18
}
func (o *PORT0_Type) SetPCNTR1_PODR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x80000)|value<<19)
}
func (o *PORT0_Type) GetPCNTR1_PODR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x80000) >> 19
}
func (o *PORT0_Type) SetPCNTR1_PODR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x100000)|value<<20)
}
func (o *PORT0_Type) GetPCNTR1_PODR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x100000) >> 20
}
func (o *PORT0_Type) SetPCNTR1_PODR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x200000)|value<<21)
}
func (o *PORT0_Type) GetPCNTR1_PODR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x200000) >> 21
}
func (o *PORT0_Type) SetPCNTR1_PODR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x400000)|value<<22)
}
func (o *PORT0_Type) GetPCNTR1_PODR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x400000) >> 22
}
func (o *PORT0_Type) SetPCNTR1_PODR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x800000)|value<<23)
}
func (o *PORT0_Type) GetPCNTR1_PODR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x800000) >> 23
}
func (o *PORT0_Type) SetPCNTR1_PODR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT0_Type) GetPCNTR1_PODR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x1000000) >> 24
}
func (o *PORT0_Type) SetPCNTR1_PODR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT0_Type) GetPCNTR1_PODR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x2000000) >> 25
}
func (o *PORT0_Type) SetPCNTR1_PODR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT0_Type) GetPCNTR1_PODR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x4000000) >> 26
}
func (o *PORT0_Type) SetPCNTR1_PODR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT0_Type) GetPCNTR1_PODR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x8000000) >> 27
}
func (o *PORT0_Type) SetPCNTR1_PODR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT0_Type) GetPCNTR1_PODR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x10000000) >> 28
}
func (o *PORT0_Type) SetPCNTR1_PODR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT0_Type) GetPCNTR1_PODR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x20000000) >> 29
}
func (o *PORT0_Type) SetPCNTR1_PODR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT0_Type) GetPCNTR1_PODR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x40000000) >> 30
}
func (o *PORT0_Type) SetPCNTR1_PODR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT0_Type) GetPCNTR1_PODR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x80000000) >> 31
}

// PORT0.PCNTR2: Port Control Register 2
func (o *PORT0_Type) SetPCNTR2_PIDR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x1)|value)
}
func (o *PORT0_Type) GetPCNTR2_PIDR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR2.Reg) & 0x1
}
func (o *PORT0_Type) SetPCNTR2_PIDR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x2)|value<<1)
}
func (o *PORT0_Type) GetPCNTR2_PIDR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x2) >> 1
}
func (o *PORT0_Type) SetPCNTR2_PIDR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x4)|value<<2)
}
func (o *PORT0_Type) GetPCNTR2_PIDR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x4) >> 2
}
func (o *PORT0_Type) SetPCNTR2_PIDR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x8)|value<<3)
}
func (o *PORT0_Type) GetPCNTR2_PIDR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x8) >> 3
}
func (o *PORT0_Type) SetPCNTR2_PIDR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x10)|value<<4)
}
func (o *PORT0_Type) GetPCNTR2_PIDR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x10) >> 4
}
func (o *PORT0_Type) SetPCNTR2_PIDR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x20)|value<<5)
}
func (o *PORT0_Type) GetPCNTR2_PIDR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x20) >> 5
}
func (o *PORT0_Type) SetPCNTR2_PIDR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x40)|value<<6)
}
func (o *PORT0_Type) GetPCNTR2_PIDR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x40) >> 6
}
func (o *PORT0_Type) SetPCNTR2_PIDR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x80)|value<<7)
}
func (o *PORT0_Type) GetPCNTR2_PIDR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x80) >> 7
}
func (o *PORT0_Type) SetPCNTR2_PIDR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x100)|value<<8)
}
func (o *PORT0_Type) GetPCNTR2_PIDR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x100) >> 8
}
func (o *PORT0_Type) SetPCNTR2_PIDR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x200)|value<<9)
}
func (o *PORT0_Type) GetPCNTR2_PIDR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x200) >> 9
}
func (o *PORT0_Type) SetPCNTR2_PIDR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x400)|value<<10)
}
func (o *PORT0_Type) GetPCNTR2_PIDR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x400) >> 10
}
func (o *PORT0_Type) SetPCNTR2_PIDR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x800)|value<<11)
}
func (o *PORT0_Type) GetPCNTR2_PIDR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x800) >> 11
}
func (o *PORT0_Type) SetPCNTR2_PIDR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x1000)|value<<12)
}
func (o *PORT0_Type) GetPCNTR2_PIDR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x1000) >> 12
}
func (o *PORT0_Type) SetPCNTR2_PIDR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x2000)|value<<13)
}
func (o *PORT0_Type) GetPCNTR2_PIDR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x2000) >> 13
}
func (o *PORT0_Type) SetPCNTR2_PIDR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x4000)|value<<14)
}
func (o *PORT0_Type) GetPCNTR2_PIDR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x4000) >> 14
}
func (o *PORT0_Type) SetPCNTR2_PIDR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x8000)|value<<15)
}
func (o *PORT0_Type) GetPCNTR2_PIDR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x8000) >> 15
}

// PORT0.PCNTR3: Port Control Register 3
func (o *PORT0_Type) SetPCNTR3_POSR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x1)|value)
}
func (o *PORT0_Type) GetPCNTR3_POSR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR3.Reg) & 0x1
}
func (o *PORT0_Type) SetPCNTR3_POSR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x2)|value<<1)
}
func (o *PORT0_Type) GetPCNTR3_POSR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x2) >> 1
}
func (o *PORT0_Type) SetPCNTR3_POSR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x4)|value<<2)
}
func (o *PORT0_Type) GetPCNTR3_POSR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x4) >> 2
}
func (o *PORT0_Type) SetPCNTR3_POSR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x8)|value<<3)
}
func (o *PORT0_Type) GetPCNTR3_POSR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x8) >> 3
}
func (o *PORT0_Type) SetPCNTR3_POSR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x10)|value<<4)
}
func (o *PORT0_Type) GetPCNTR3_POSR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x10) >> 4
}
func (o *PORT0_Type) SetPCNTR3_POSR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x20)|value<<5)
}
func (o *PORT0_Type) GetPCNTR3_POSR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x20) >> 5
}
func (o *PORT0_Type) SetPCNTR3_POSR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x40)|value<<6)
}
func (o *PORT0_Type) GetPCNTR3_POSR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x40) >> 6
}
func (o *PORT0_Type) SetPCNTR3_POSR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x80)|value<<7)
}
func (o *PORT0_Type) GetPCNTR3_POSR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x80) >> 7
}
func (o *PORT0_Type) SetPCNTR3_POSR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x100)|value<<8)
}
func (o *PORT0_Type) GetPCNTR3_POSR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x100) >> 8
}
func (o *PORT0_Type) SetPCNTR3_POSR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x200)|value<<9)
}
func (o *PORT0_Type) GetPCNTR3_POSR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x200) >> 9
}
func (o *PORT0_Type) SetPCNTR3_POSR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x400)|value<<10)
}
func (o *PORT0_Type) GetPCNTR3_POSR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x400) >> 10
}
func (o *PORT0_Type) SetPCNTR3_POSR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x800)|value<<11)
}
func (o *PORT0_Type) GetPCNTR3_POSR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x800) >> 11
}
func (o *PORT0_Type) SetPCNTR3_POSR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x1000)|value<<12)
}
func (o *PORT0_Type) GetPCNTR3_POSR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x1000) >> 12
}
func (o *PORT0_Type) SetPCNTR3_POSR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x2000)|value<<13)
}
func (o *PORT0_Type) GetPCNTR3_POSR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x2000) >> 13
}
func (o *PORT0_Type) SetPCNTR3_POSR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x4000)|value<<14)
}
func (o *PORT0_Type) GetPCNTR3_POSR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x4000) >> 14
}
func (o *PORT0_Type) SetPCNTR3_POSR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x8000)|value<<15)
}
func (o *PORT0_Type) GetPCNTR3_POSR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x8000) >> 15
}
func (o *PORT0_Type) SetPCNTR3_PORR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x10000)|value<<16)
}
func (o *PORT0_Type) GetPCNTR3_PORR00() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x10000) >> 16
}
func (o *PORT0_Type) SetPCNTR3_PORR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x20000)|value<<17)
}
func (o *PORT0_Type) GetPCNTR3_PORR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x20000) >> 17
}
func (o *PORT0_Type) SetPCNTR3_PORR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x40000)|value<<18)
}
func (o *PORT0_Type) GetPCNTR3_PORR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x40000) >> 18
}
func (o *PORT0_Type) SetPCNTR3_PORR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x80000)|value<<19)
}
func (o *PORT0_Type) GetPCNTR3_PORR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x80000) >> 19
}
func (o *PORT0_Type) SetPCNTR3_PORR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x100000)|value<<20)
}
func (o *PORT0_Type) GetPCNTR3_PORR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x100000) >> 20
}
func (o *PORT0_Type) SetPCNTR3_PORR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x200000)|value<<21)
}
func (o *PORT0_Type) GetPCNTR3_PORR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x200000) >> 21
}
func (o *PORT0_Type) SetPCNTR3_PORR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x400000)|value<<22)
}
func (o *PORT0_Type) GetPCNTR3_PORR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x400000) >> 22
}
func (o *PORT0_Type) SetPCNTR3_PORR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x800000)|value<<23)
}
func (o *PORT0_Type) GetPCNTR3_PORR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x800000) >> 23
}
func (o *PORT0_Type) SetPCNTR3_PORR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT0_Type) GetPCNTR3_PORR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x1000000) >> 24
}
func (o *PORT0_Type) SetPCNTR3_PORR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT0_Type) GetPCNTR3_PORR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x2000000) >> 25
}
func (o *PORT0_Type) SetPCNTR3_PORR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT0_Type) GetPCNTR3_PORR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x4000000) >> 26
}
func (o *PORT0_Type) SetPCNTR3_PORR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT0_Type) GetPCNTR3_PORR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x8000000) >> 27
}
func (o *PORT0_Type) SetPCNTR3_PORR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT0_Type) GetPCNTR3_PORR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x10000000) >> 28
}
func (o *PORT0_Type) SetPCNTR3_PORR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT0_Type) GetPCNTR3_PORR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x20000000) >> 29
}
func (o *PORT0_Type) SetPCNTR3_PORR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT0_Type) GetPCNTR3_PORR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x40000000) >> 30
}
func (o *PORT0_Type) SetPCNTR3_PORR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT0_Type) GetPCNTR3_PORR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x80000000) >> 31
}

// Pmn Pin FunctionPort 1 Control RegistersPmn Pin Function Control Register
type PORT1_Type struct {
	PCNTR1 volatile.Register32 // 0x0
	PCNTR2 volatile.Register32 // 0x4
	PCNTR3 volatile.Register32 // 0x8
	PCNTR4 volatile.Register32 // 0xC
}

// PORT1.PCNTR1: Port Control Register 1
func (o *PORT1_Type) SetPCNTR1_PDR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x1)|value)
}
func (o *PORT1_Type) GetPCNTR1_PDR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR1.Reg) & 0x1
}
func (o *PORT1_Type) SetPCNTR1_PDR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x2)|value<<1)
}
func (o *PORT1_Type) GetPCNTR1_PDR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x2) >> 1
}
func (o *PORT1_Type) SetPCNTR1_PDR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x4)|value<<2)
}
func (o *PORT1_Type) GetPCNTR1_PDR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x4) >> 2
}
func (o *PORT1_Type) SetPCNTR1_PDR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x8)|value<<3)
}
func (o *PORT1_Type) GetPCNTR1_PDR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x8) >> 3
}
func (o *PORT1_Type) SetPCNTR1_PDR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x10)|value<<4)
}
func (o *PORT1_Type) GetPCNTR1_PDR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x10) >> 4
}
func (o *PORT1_Type) SetPCNTR1_PDR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x20)|value<<5)
}
func (o *PORT1_Type) GetPCNTR1_PDR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x20) >> 5
}
func (o *PORT1_Type) SetPCNTR1_PDR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x40)|value<<6)
}
func (o *PORT1_Type) GetPCNTR1_PDR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x40) >> 6
}
func (o *PORT1_Type) SetPCNTR1_PDR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x80)|value<<7)
}
func (o *PORT1_Type) GetPCNTR1_PDR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x80) >> 7
}
func (o *PORT1_Type) SetPCNTR1_PDR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x100)|value<<8)
}
func (o *PORT1_Type) GetPCNTR1_PDR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x100) >> 8
}
func (o *PORT1_Type) SetPCNTR1_PDR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x200)|value<<9)
}
func (o *PORT1_Type) GetPCNTR1_PDR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x200) >> 9
}
func (o *PORT1_Type) SetPCNTR1_PDR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x400)|value<<10)
}
func (o *PORT1_Type) GetPCNTR1_PDR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x400) >> 10
}
func (o *PORT1_Type) SetPCNTR1_PDR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x800)|value<<11)
}
func (o *PORT1_Type) GetPCNTR1_PDR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x800) >> 11
}
func (o *PORT1_Type) SetPCNTR1_PDR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x1000)|value<<12)
}
func (o *PORT1_Type) GetPCNTR1_PDR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x1000) >> 12
}
func (o *PORT1_Type) SetPCNTR1_PDR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x2000)|value<<13)
}
func (o *PORT1_Type) GetPCNTR1_PDR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x2000) >> 13
}
func (o *PORT1_Type) SetPCNTR1_PDR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x4000)|value<<14)
}
func (o *PORT1_Type) GetPCNTR1_PDR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x4000) >> 14
}
func (o *PORT1_Type) SetPCNTR1_PDR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x8000)|value<<15)
}
func (o *PORT1_Type) GetPCNTR1_PDR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x8000) >> 15
}
func (o *PORT1_Type) SetPCNTR1_PODR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x10000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR1_PODR00() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x10000) >> 16
}
func (o *PORT1_Type) SetPCNTR1_PODR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x20000)|value<<17)
}
func (o *PORT1_Type) GetPCNTR1_PODR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x20000) >> 17
}
func (o *PORT1_Type) SetPCNTR1_PODR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x40000)|value<<18)
}
func (o *PORT1_Type) GetPCNTR1_PODR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x40000) >> 18
}
func (o *PORT1_Type) SetPCNTR1_PODR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x80000)|value<<19)
}
func (o *PORT1_Type) GetPCNTR1_PODR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x80000) >> 19
}
func (o *PORT1_Type) SetPCNTR1_PODR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x100000)|value<<20)
}
func (o *PORT1_Type) GetPCNTR1_PODR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x100000) >> 20
}
func (o *PORT1_Type) SetPCNTR1_PODR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x200000)|value<<21)
}
func (o *PORT1_Type) GetPCNTR1_PODR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x200000) >> 21
}
func (o *PORT1_Type) SetPCNTR1_PODR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x400000)|value<<22)
}
func (o *PORT1_Type) GetPCNTR1_PODR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x400000) >> 22
}
func (o *PORT1_Type) SetPCNTR1_PODR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x800000)|value<<23)
}
func (o *PORT1_Type) GetPCNTR1_PODR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x800000) >> 23
}
func (o *PORT1_Type) SetPCNTR1_PODR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT1_Type) GetPCNTR1_PODR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x1000000) >> 24
}
func (o *PORT1_Type) SetPCNTR1_PODR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT1_Type) GetPCNTR1_PODR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x2000000) >> 25
}
func (o *PORT1_Type) SetPCNTR1_PODR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT1_Type) GetPCNTR1_PODR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x4000000) >> 26
}
func (o *PORT1_Type) SetPCNTR1_PODR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT1_Type) GetPCNTR1_PODR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x8000000) >> 27
}
func (o *PORT1_Type) SetPCNTR1_PODR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT1_Type) GetPCNTR1_PODR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x10000000) >> 28
}
func (o *PORT1_Type) SetPCNTR1_PODR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT1_Type) GetPCNTR1_PODR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x20000000) >> 29
}
func (o *PORT1_Type) SetPCNTR1_PODR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT1_Type) GetPCNTR1_PODR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x40000000) >> 30
}
func (o *PORT1_Type) SetPCNTR1_PODR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT1_Type) GetPCNTR1_PODR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0x80000000) >> 31
}

// PORT1.PCNTR2: Port Control Register 2
func (o *PORT1_Type) SetPCNTR2_PIDR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x1)|value)
}
func (o *PORT1_Type) GetPCNTR2_PIDR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR2.Reg) & 0x1
}
func (o *PORT1_Type) SetPCNTR2_PIDR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x2)|value<<1)
}
func (o *PORT1_Type) GetPCNTR2_PIDR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x2) >> 1
}
func (o *PORT1_Type) SetPCNTR2_PIDR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x4)|value<<2)
}
func (o *PORT1_Type) GetPCNTR2_PIDR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x4) >> 2
}
func (o *PORT1_Type) SetPCNTR2_PIDR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x8)|value<<3)
}
func (o *PORT1_Type) GetPCNTR2_PIDR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x8) >> 3
}
func (o *PORT1_Type) SetPCNTR2_PIDR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x10)|value<<4)
}
func (o *PORT1_Type) GetPCNTR2_PIDR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x10) >> 4
}
func (o *PORT1_Type) SetPCNTR2_PIDR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x20)|value<<5)
}
func (o *PORT1_Type) GetPCNTR2_PIDR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x20) >> 5
}
func (o *PORT1_Type) SetPCNTR2_PIDR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x40)|value<<6)
}
func (o *PORT1_Type) GetPCNTR2_PIDR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x40) >> 6
}
func (o *PORT1_Type) SetPCNTR2_PIDR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x80)|value<<7)
}
func (o *PORT1_Type) GetPCNTR2_PIDR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x80) >> 7
}
func (o *PORT1_Type) SetPCNTR2_PIDR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x100)|value<<8)
}
func (o *PORT1_Type) GetPCNTR2_PIDR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x100) >> 8
}
func (o *PORT1_Type) SetPCNTR2_PIDR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x200)|value<<9)
}
func (o *PORT1_Type) GetPCNTR2_PIDR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x200) >> 9
}
func (o *PORT1_Type) SetPCNTR2_PIDR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x400)|value<<10)
}
func (o *PORT1_Type) GetPCNTR2_PIDR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x400) >> 10
}
func (o *PORT1_Type) SetPCNTR2_PIDR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x800)|value<<11)
}
func (o *PORT1_Type) GetPCNTR2_PIDR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x800) >> 11
}
func (o *PORT1_Type) SetPCNTR2_PIDR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x1000)|value<<12)
}
func (o *PORT1_Type) GetPCNTR2_PIDR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x1000) >> 12
}
func (o *PORT1_Type) SetPCNTR2_PIDR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x2000)|value<<13)
}
func (o *PORT1_Type) GetPCNTR2_PIDR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x2000) >> 13
}
func (o *PORT1_Type) SetPCNTR2_PIDR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x4000)|value<<14)
}
func (o *PORT1_Type) GetPCNTR2_PIDR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x4000) >> 14
}
func (o *PORT1_Type) SetPCNTR2_PIDR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x8000)|value<<15)
}
func (o *PORT1_Type) GetPCNTR2_PIDR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x8000) >> 15
}
func (o *PORT1_Type) SetPCNTR2_EIDR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x10000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR2_EIDR00() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x10000) >> 16
}
func (o *PORT1_Type) SetPCNTR2_EIDR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x20000)|value<<17)
}
func (o *PORT1_Type) GetPCNTR2_EIDR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x20000) >> 17
}
func (o *PORT1_Type) SetPCNTR2_EIDR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x40000)|value<<18)
}
func (o *PORT1_Type) GetPCNTR2_EIDR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x40000) >> 18
}
func (o *PORT1_Type) SetPCNTR2_EIDR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x80000)|value<<19)
}
func (o *PORT1_Type) GetPCNTR2_EIDR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x80000) >> 19
}
func (o *PORT1_Type) SetPCNTR2_EIDR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x100000)|value<<20)
}
func (o *PORT1_Type) GetPCNTR2_EIDR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x100000) >> 20
}
func (o *PORT1_Type) SetPCNTR2_EIDR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x200000)|value<<21)
}
func (o *PORT1_Type) GetPCNTR2_EIDR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x200000) >> 21
}
func (o *PORT1_Type) SetPCNTR2_EIDR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x400000)|value<<22)
}
func (o *PORT1_Type) GetPCNTR2_EIDR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x400000) >> 22
}
func (o *PORT1_Type) SetPCNTR2_EIDR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x800000)|value<<23)
}
func (o *PORT1_Type) GetPCNTR2_EIDR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x800000) >> 23
}
func (o *PORT1_Type) SetPCNTR2_EIDR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT1_Type) GetPCNTR2_EIDR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x1000000) >> 24
}
func (o *PORT1_Type) SetPCNTR2_EIDR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT1_Type) GetPCNTR2_EIDR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x2000000) >> 25
}
func (o *PORT1_Type) SetPCNTR2_EIDR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT1_Type) GetPCNTR2_EIDR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x4000000) >> 26
}
func (o *PORT1_Type) SetPCNTR2_EIDR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT1_Type) GetPCNTR2_EIDR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x8000000) >> 27
}
func (o *PORT1_Type) SetPCNTR2_EIDR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT1_Type) GetPCNTR2_EIDR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x10000000) >> 28
}
func (o *PORT1_Type) SetPCNTR2_EIDR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT1_Type) GetPCNTR2_EIDR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x20000000) >> 29
}
func (o *PORT1_Type) SetPCNTR2_EIDR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT1_Type) GetPCNTR2_EIDR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x40000000) >> 30
}
func (o *PORT1_Type) SetPCNTR2_EIDR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT1_Type) GetPCNTR2_EIDR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0x80000000) >> 31
}

// PORT1.PCNTR3: Port Control Register 3
func (o *PORT1_Type) SetPCNTR3_POSR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x1)|value)
}
func (o *PORT1_Type) GetPCNTR3_POSR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR3.Reg) & 0x1
}
func (o *PORT1_Type) SetPCNTR3_POSR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x2)|value<<1)
}
func (o *PORT1_Type) GetPCNTR3_POSR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x2) >> 1
}
func (o *PORT1_Type) SetPCNTR3_POSR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x4)|value<<2)
}
func (o *PORT1_Type) GetPCNTR3_POSR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x4) >> 2
}
func (o *PORT1_Type) SetPCNTR3_POSR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x8)|value<<3)
}
func (o *PORT1_Type) GetPCNTR3_POSR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x8) >> 3
}
func (o *PORT1_Type) SetPCNTR3_POSR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x10)|value<<4)
}
func (o *PORT1_Type) GetPCNTR3_POSR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x10) >> 4
}
func (o *PORT1_Type) SetPCNTR3_POSR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x20)|value<<5)
}
func (o *PORT1_Type) GetPCNTR3_POSR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x20) >> 5
}
func (o *PORT1_Type) SetPCNTR3_POSR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x40)|value<<6)
}
func (o *PORT1_Type) GetPCNTR3_POSR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x40) >> 6
}
func (o *PORT1_Type) SetPCNTR3_POSR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x80)|value<<7)
}
func (o *PORT1_Type) GetPCNTR3_POSR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x80) >> 7
}
func (o *PORT1_Type) SetPCNTR3_POSR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x100)|value<<8)
}
func (o *PORT1_Type) GetPCNTR3_POSR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x100) >> 8
}
func (o *PORT1_Type) SetPCNTR3_POSR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x200)|value<<9)
}
func (o *PORT1_Type) GetPCNTR3_POSR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x200) >> 9
}
func (o *PORT1_Type) SetPCNTR3_POSR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x400)|value<<10)
}
func (o *PORT1_Type) GetPCNTR3_POSR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x400) >> 10
}
func (o *PORT1_Type) SetPCNTR3_POSR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x800)|value<<11)
}
func (o *PORT1_Type) GetPCNTR3_POSR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x800) >> 11
}
func (o *PORT1_Type) SetPCNTR3_POSR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x1000)|value<<12)
}
func (o *PORT1_Type) GetPCNTR3_POSR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x1000) >> 12
}
func (o *PORT1_Type) SetPCNTR3_POSR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x2000)|value<<13)
}
func (o *PORT1_Type) GetPCNTR3_POSR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x2000) >> 13
}
func (o *PORT1_Type) SetPCNTR3_POSR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x4000)|value<<14)
}
func (o *PORT1_Type) GetPCNTR3_POSR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x4000) >> 14
}
func (o *PORT1_Type) SetPCNTR3_POSR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x8000)|value<<15)
}
func (o *PORT1_Type) GetPCNTR3_POSR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x8000) >> 15
}
func (o *PORT1_Type) SetPCNTR3_PORR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x10000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR3_PORR00() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x10000) >> 16
}
func (o *PORT1_Type) SetPCNTR3_PORR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x20000)|value<<17)
}
func (o *PORT1_Type) GetPCNTR3_PORR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x20000) >> 17
}
func (o *PORT1_Type) SetPCNTR3_PORR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x40000)|value<<18)
}
func (o *PORT1_Type) GetPCNTR3_PORR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x40000) >> 18
}
func (o *PORT1_Type) SetPCNTR3_PORR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x80000)|value<<19)
}
func (o *PORT1_Type) GetPCNTR3_PORR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x80000) >> 19
}
func (o *PORT1_Type) SetPCNTR3_PORR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x100000)|value<<20)
}
func (o *PORT1_Type) GetPCNTR3_PORR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x100000) >> 20
}
func (o *PORT1_Type) SetPCNTR3_PORR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x200000)|value<<21)
}
func (o *PORT1_Type) GetPCNTR3_PORR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x200000) >> 21
}
func (o *PORT1_Type) SetPCNTR3_PORR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x400000)|value<<22)
}
func (o *PORT1_Type) GetPCNTR3_PORR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x400000) >> 22
}
func (o *PORT1_Type) SetPCNTR3_PORR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x800000)|value<<23)
}
func (o *PORT1_Type) GetPCNTR3_PORR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x800000) >> 23
}
func (o *PORT1_Type) SetPCNTR3_PORR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT1_Type) GetPCNTR3_PORR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x1000000) >> 24
}
func (o *PORT1_Type) SetPCNTR3_PORR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT1_Type) GetPCNTR3_PORR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x2000000) >> 25
}
func (o *PORT1_Type) SetPCNTR3_PORR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT1_Type) GetPCNTR3_PORR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x4000000) >> 26
}
func (o *PORT1_Type) SetPCNTR3_PORR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT1_Type) GetPCNTR3_PORR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x8000000) >> 27
}
func (o *PORT1_Type) SetPCNTR3_PORR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT1_Type) GetPCNTR3_PORR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x10000000) >> 28
}
func (o *PORT1_Type) SetPCNTR3_PORR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT1_Type) GetPCNTR3_PORR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x20000000) >> 29
}
func (o *PORT1_Type) SetPCNTR3_PORR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT1_Type) GetPCNTR3_PORR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x40000000) >> 30
}
func (o *PORT1_Type) SetPCNTR3_PORR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT1_Type) GetPCNTR3_PORR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0x80000000) >> 31
}

// PORT1.PCNTR4: Port Control Register 4
func (o *PORT1_Type) SetPCNTR4_EOSR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x1)|value)
}
func (o *PORT1_Type) GetPCNTR4_EOSR00() uint32 {
	return volatile.LoadUint32(&o.PCNTR4.Reg) & 0x1
}
func (o *PORT1_Type) SetPCNTR4_EOSR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x2)|value<<1)
}
func (o *PORT1_Type) GetPCNTR4_EOSR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x2) >> 1
}
func (o *PORT1_Type) SetPCNTR4_EOSR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x4)|value<<2)
}
func (o *PORT1_Type) GetPCNTR4_EOSR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x4) >> 2
}
func (o *PORT1_Type) SetPCNTR4_EOSR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x8)|value<<3)
}
func (o *PORT1_Type) GetPCNTR4_EOSR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x8) >> 3
}
func (o *PORT1_Type) SetPCNTR4_EOSR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x10)|value<<4)
}
func (o *PORT1_Type) GetPCNTR4_EOSR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x10) >> 4
}
func (o *PORT1_Type) SetPCNTR4_EOSR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x20)|value<<5)
}
func (o *PORT1_Type) GetPCNTR4_EOSR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x20) >> 5
}
func (o *PORT1_Type) SetPCNTR4_EOSR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x40)|value<<6)
}
func (o *PORT1_Type) GetPCNTR4_EOSR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x40) >> 6
}
func (o *PORT1_Type) SetPCNTR4_EOSR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x80)|value<<7)
}
func (o *PORT1_Type) GetPCNTR4_EOSR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x80) >> 7
}
func (o *PORT1_Type) SetPCNTR4_EOSR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x100)|value<<8)
}
func (o *PORT1_Type) GetPCNTR4_EOSR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x100) >> 8
}
func (o *PORT1_Type) SetPCNTR4_EOSR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x200)|value<<9)
}
func (o *PORT1_Type) GetPCNTR4_EOSR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x200) >> 9
}
func (o *PORT1_Type) SetPCNTR4_EOSR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x400)|value<<10)
}
func (o *PORT1_Type) GetPCNTR4_EOSR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x400) >> 10
}
func (o *PORT1_Type) SetPCNTR4_EOSR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x800)|value<<11)
}
func (o *PORT1_Type) GetPCNTR4_EOSR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x800) >> 11
}
func (o *PORT1_Type) SetPCNTR4_EOSR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x1000)|value<<12)
}
func (o *PORT1_Type) GetPCNTR4_EOSR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x1000) >> 12
}
func (o *PORT1_Type) SetPCNTR4_EOSR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x2000)|value<<13)
}
func (o *PORT1_Type) GetPCNTR4_EOSR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x2000) >> 13
}
func (o *PORT1_Type) SetPCNTR4_EOSR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x4000)|value<<14)
}
func (o *PORT1_Type) GetPCNTR4_EOSR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x4000) >> 14
}
func (o *PORT1_Type) SetPCNTR4_EOSR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x8000)|value<<15)
}
func (o *PORT1_Type) GetPCNTR4_EOSR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x8000) >> 15
}
func (o *PORT1_Type) SetPCNTR4_EORR00(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x10000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR4_EORR00() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x10000) >> 16
}
func (o *PORT1_Type) SetPCNTR4_EORR01(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x20000)|value<<17)
}
func (o *PORT1_Type) GetPCNTR4_EORR01() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x20000) >> 17
}
func (o *PORT1_Type) SetPCNTR4_EORR02(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x40000)|value<<18)
}
func (o *PORT1_Type) GetPCNTR4_EORR02() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x40000) >> 18
}
func (o *PORT1_Type) SetPCNTR4_EORR03(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x80000)|value<<19)
}
func (o *PORT1_Type) GetPCNTR4_EORR03() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x80000) >> 19
}
func (o *PORT1_Type) SetPCNTR4_EORR04(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x100000)|value<<20)
}
func (o *PORT1_Type) GetPCNTR4_EORR04() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x100000) >> 20
}
func (o *PORT1_Type) SetPCNTR4_EORR05(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x200000)|value<<21)
}
func (o *PORT1_Type) GetPCNTR4_EORR05() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x200000) >> 21
}
func (o *PORT1_Type) SetPCNTR4_EORR06(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x400000)|value<<22)
}
func (o *PORT1_Type) GetPCNTR4_EORR06() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x400000) >> 22
}
func (o *PORT1_Type) SetPCNTR4_EORR07(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x800000)|value<<23)
}
func (o *PORT1_Type) GetPCNTR4_EORR07() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x800000) >> 23
}
func (o *PORT1_Type) SetPCNTR4_EORR08(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT1_Type) GetPCNTR4_EORR08() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x1000000) >> 24
}
func (o *PORT1_Type) SetPCNTR4_EORR09(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT1_Type) GetPCNTR4_EORR09() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x2000000) >> 25
}
func (o *PORT1_Type) SetPCNTR4_EORR10(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT1_Type) GetPCNTR4_EORR10() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x4000000) >> 26
}
func (o *PORT1_Type) SetPCNTR4_EORR11(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT1_Type) GetPCNTR4_EORR11() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x8000000) >> 27
}
func (o *PORT1_Type) SetPCNTR4_EORR12(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT1_Type) GetPCNTR4_EORR12() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x10000000) >> 28
}
func (o *PORT1_Type) SetPCNTR4_EORR13(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT1_Type) GetPCNTR4_EORR13() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x20000000) >> 29
}
func (o *PORT1_Type) SetPCNTR4_EORR14(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT1_Type) GetPCNTR4_EORR14() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x40000000) >> 30
}
func (o *PORT1_Type) SetPCNTR4_EORR15(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT1_Type) GetPCNTR4_EORR15() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0x80000000) >> 31
}

// Control Register
type PFS_Type struct {
	P000PFS volatile.Register32 // 0x0
	P001PFS volatile.Register32 // 0x4
	P002PFS volatile.Register32 // 0x8
	P003PFS volatile.Register32 // 0xC
	P004PFS volatile.Register32 // 0x10
	P005PFS volatile.Register32 // 0x14
	P006PFS volatile.Register32 // 0x18
	P007PFS volatile.Register32 // 0x1C
	P008PFS volatile.Register32 // 0x20
	_       [20]byte
	P014PFS volatile.Register32 // 0x38
	P015PFS volatile.Register32 // 0x3C
	P100PFS volatile.Register32 // 0x40
	P101PFS volatile.Register32 // 0x44
	P102PFS volatile.Register32 // 0x48
	P103PFS volatile.Register32 // 0x4C
	P104PFS volatile.Register32 // 0x50
	P105PFS volatile.Register32 // 0x54
	P106PFS volatile.Register32 // 0x58
	P107PFS volatile.Register32 // 0x5C
	P108PFS volatile.Register32 // 0x60
	P109PFS volatile.Register32 // 0x64
	P110PFS volatile.Register32 // 0x68
	P111PFS volatile.Register32 // 0x6C
	P112PFS volatile.Register32 // 0x70
	P113PFS volatile.Register32 // 0x74
	P114PFS volatile.Register32 // 0x78
	P115PFS volatile.Register32 // 0x7C
	P200PFS volatile.Register32 // 0x80
	P201PFS volatile.Register32 // 0x84
	_       [12]byte
	P205PFS volatile.Register32 // 0x94
	P206PFS volatile.Register32 // 0x98
	P207PFS volatile.Register32 // 0x9C
	P208PFS volatile.Register32 // 0xA0
	P209PFS volatile.Register32 // 0xA4
	P210PFS volatile.Register32 // 0xA8
	P211PFS volatile.Register32 // 0xAC
	P212PFS volatile.Register32 // 0xB0
	P213PFS volatile.Register32 // 0xB4
	P214PFS volatile.Register32 // 0xB8
	_       [4]byte
	P300PFS volatile.Register32 // 0xC0
	P301PFS volatile.Register32 // 0xC4
	P302PFS volatile.Register32 // 0xC8
	P303PFS volatile.Register32 // 0xCC
	P304PFS volatile.Register32 // 0xD0
	P305PFS volatile.Register32 // 0xD4
	P306PFS volatile.Register32 // 0xD8
	P307PFS volatile.Register32 // 0xDC
	_       [32]byte
	P400PFS volatile.Register32 // 0x100
	P401PFS volatile.Register32 // 0x104
	P402PFS volatile.Register32 // 0x108
	P403PFS volatile.Register32 // 0x10C
	P404PFS volatile.Register32 // 0x110
	P405PFS volatile.Register32 // 0x114
	P406PFS volatile.Register32 // 0x118
	P407PFS volatile.Register32 // 0x11C
	P408PFS volatile.Register32 // 0x120
	P409PFS volatile.Register32 // 0x124
	P410PFS volatile.Register32 // 0x128
	P411PFS volatile.Register32 // 0x12C
	P412PFS volatile.Register32 // 0x130
	P413PFS volatile.Register32 // 0x134
	P414PFS volatile.Register32 // 0x138
	P415PFS volatile.Register32 // 0x13C
	P500PFS volatile.Register32 // 0x140
	P501PFS volatile.Register32 // 0x144
	P502PFS volatile.Register32 // 0x148
	P503PFS volatile.Register32 // 0x14C
	P504PFS volatile.Register32 // 0x150
	P505PFS volatile.Register32 // 0x154
	_       [40]byte
	P600PFS volatile.Register32 // 0x180
	P601PFS volatile.Register32 // 0x184
	P602PFS volatile.Register32 // 0x188
	_       [20]byte
	P608PFS volatile.Register32 // 0x1A0
	P609PFS volatile.Register32 // 0x1A4
	P610PFS volatile.Register32 // 0x1A8
	_       [52]byte
	P708PFS volatile.Register32 // 0x1E0
	_       [796]byte
	PFENET  volatile.Register8 // 0x500
	_       [2]byte
	PWPR    volatile.Register8 // 0x503
	_       byte
	PWPRS   volatile.Register8 // 0x505
	_       [10]byte
	P0SAR   volatile.Register16 // 0x510
	P1SAR   volatile.Register16 // 0x512
	P2SAR   volatile.Register16 // 0x514
	P3SAR   volatile.Register16 // 0x516
	P4SAR   volatile.Register16 // 0x518
	P5SAR   volatile.Register16 // 0x51A
	P6SAR   volatile.Register16 // 0x51C
	P7SAR   volatile.Register16 // 0x51E
}

// PFS.P000PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP000PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP000PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P000PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP000PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP000PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP000PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP000PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP000PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP000PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP000PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP000PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP000PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP000PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP000PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP000PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP000PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP000PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP000PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP000PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P001PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP001PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP001PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P001PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP001PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP001PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP001PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP001PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP001PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP001PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP001PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP001PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP001PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP001PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP001PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP001PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP001PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP001PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP001PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P001PFS.Reg, volatile.LoadUint32(&o.P001PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP001PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P001PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P002PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP002PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP002PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P002PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP002PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP002PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP002PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP002PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP002PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP002PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP002PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP002PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP002PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP002PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP002PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP002PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP002PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP002PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP002PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P002PFS.Reg, volatile.LoadUint32(&o.P002PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP002PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P002PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P003PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP003PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP003PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P003PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP003PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP003PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP003PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP003PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP003PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP003PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP003PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP003PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP003PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP003PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP003PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP003PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP003PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP003PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP003PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P003PFS.Reg, volatile.LoadUint32(&o.P003PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP003PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P003PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P004PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP004PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP004PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P004PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP004PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP004PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP004PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP004PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP004PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP004PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP004PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP004PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP004PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP004PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP004PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP004PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP004PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP004PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP004PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P004PFS.Reg, volatile.LoadUint32(&o.P004PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP004PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P004PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P005PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP005PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP005PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P005PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP005PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP005PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP005PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP005PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP005PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP005PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP005PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP005PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP005PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP005PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP005PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP005PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP005PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP005PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP005PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P005PFS.Reg, volatile.LoadUint32(&o.P005PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP005PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P005PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P006PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP006PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP006PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P006PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP006PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP006PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP006PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP006PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP006PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP006PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP006PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP006PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP006PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP006PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP006PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP006PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP006PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP006PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP006PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P006PFS.Reg, volatile.LoadUint32(&o.P006PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP006PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P006PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P007PFS: Port 00%s Pin Function Select Register
func (o *PFS_Type) SetP007PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP007PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P007PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP007PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP007PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP007PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP007PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP007PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP007PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP007PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP007PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP007PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP007PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP007PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP007PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP007PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP007PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP007PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P007PFS.Reg, volatile.LoadUint32(&o.P007PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP007PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P007PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P008PFS: Port 008 Pin Function Select Register
func (o *PFS_Type) SetP008PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP008PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P008PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP008PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP008PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP008PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP008PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP008PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP008PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP008PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP008PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP008PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP008PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP008PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP008PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP008PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP008PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP008PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P008PFS.Reg, volatile.LoadUint32(&o.P008PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP008PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P008PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P014PFS: Port 0%s Pin Function Select Register
func (o *PFS_Type) SetP014PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP014PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P014PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP014PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP014PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP014PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP014PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP014PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP014PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP014PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP014PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP014PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP014PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP014PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP014PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP014PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP014PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP014PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P014PFS.Reg, volatile.LoadUint32(&o.P014PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP014PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P014PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P015PFS: Port 0%s Pin Function Select Register
func (o *PFS_Type) SetP015PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP015PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P015PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP015PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP015PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP015PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP015PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP015PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP015PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP015PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP015PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP015PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP015PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP015PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP015PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP015PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP015PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP015PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P015PFS.Reg, volatile.LoadUint32(&o.P015PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP015PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P015PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P100PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP100PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP100PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P100PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP100PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP100PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP100PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP100PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP100PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP100PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP100PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP100PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP100PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP100PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP100PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP100PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP100PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP100PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP100PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP100PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP100PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP100PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P101PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP101PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP101PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P101PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP101PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP101PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP101PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP101PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP101PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP101PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP101PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP101PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP101PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP101PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP101PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP101PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP101PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP101PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP101PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP101PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP101PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P101PFS.Reg, volatile.LoadUint32(&o.P101PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP101PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P101PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P102PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP102PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP102PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P102PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP102PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP102PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP102PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP102PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP102PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP102PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP102PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP102PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP102PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP102PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP102PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP102PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP102PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP102PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP102PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP102PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP102PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P102PFS.Reg, volatile.LoadUint32(&o.P102PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP102PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P102PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P103PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP103PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP103PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P103PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP103PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP103PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP103PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP103PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP103PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP103PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP103PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP103PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP103PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP103PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP103PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP103PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP103PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP103PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP103PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP103PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP103PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P103PFS.Reg, volatile.LoadUint32(&o.P103PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP103PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P103PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P104PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP104PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP104PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P104PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP104PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP104PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP104PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP104PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP104PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP104PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP104PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP104PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP104PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP104PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP104PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP104PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP104PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP104PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP104PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP104PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP104PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P104PFS.Reg, volatile.LoadUint32(&o.P104PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP104PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P104PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P105PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP105PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP105PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P105PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP105PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP105PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP105PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP105PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP105PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP105PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP105PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP105PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP105PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP105PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP105PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP105PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP105PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP105PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP105PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP105PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP105PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P105PFS.Reg, volatile.LoadUint32(&o.P105PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP105PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P105PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P106PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP106PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP106PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P106PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP106PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP106PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP106PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP106PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP106PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP106PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP106PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP106PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP106PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP106PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP106PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP106PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP106PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP106PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP106PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP106PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP106PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P106PFS.Reg, volatile.LoadUint32(&o.P106PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP106PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P106PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P107PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP107PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP107PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P107PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP107PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP107PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP107PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP107PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP107PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP107PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP107PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP107PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP107PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP107PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP107PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP107PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP107PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP107PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP107PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP107PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP107PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P107PFS.Reg, volatile.LoadUint32(&o.P107PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP107PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P107PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P108PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP108PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP108PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P108PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP108PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP108PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP108PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP108PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP108PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP108PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP108PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP108PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP108PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP108PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP108PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP108PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP108PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP108PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP108PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP108PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP108PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP108PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P109PFS: Port 10%s Pin Function Select Register
func (o *PFS_Type) SetP109PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP109PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P109PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP109PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP109PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP109PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP109PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP109PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP109PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP109PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP109PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP109PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP109PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP109PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP109PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP109PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP109PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP109PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP109PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP109PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P109PFS.Reg, volatile.LoadUint32(&o.P109PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP109PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P109PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P110PFS: Port 1%s Pin Function Select Register
func (o *PFS_Type) SetP110PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP110PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P110PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP110PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP110PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP110PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP110PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP110PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP110PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP110PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP110PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP110PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP110PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP110PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP110PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP110PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP110PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP110PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP110PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP110PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP110PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P111PFS: Port 1%s Pin Function Select Register
func (o *PFS_Type) SetP111PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP111PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P111PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP111PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP111PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP111PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP111PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP111PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP111PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP111PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP111PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP111PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP111PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP111PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP111PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP111PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP111PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP111PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP111PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP111PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P111PFS.Reg, volatile.LoadUint32(&o.P111PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP111PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P111PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P112PFS: Port 1%s Pin Function Select Register
func (o *PFS_Type) SetP112PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP112PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P112PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP112PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP112PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP112PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP112PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP112PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP112PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP112PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP112PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP112PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP112PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP112PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP112PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP112PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP112PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP112PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP112PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP112PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P112PFS.Reg, volatile.LoadUint32(&o.P112PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP112PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P112PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P113PFS: Port 1%s Pin Function Select Register
func (o *PFS_Type) SetP113PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP113PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P113PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP113PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP113PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP113PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP113PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP113PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP113PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP113PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP113PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP113PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP113PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP113PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP113PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP113PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP113PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP113PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP113PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP113PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P113PFS.Reg, volatile.LoadUint32(&o.P113PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP113PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P113PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P114PFS: Port 1%s Pin Function Select Register
func (o *PFS_Type) SetP114PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP114PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P114PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP114PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP114PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP114PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP114PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP114PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP114PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP114PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP114PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP114PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP114PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP114PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP114PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP114PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP114PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP114PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP114PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP114PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P114PFS.Reg, volatile.LoadUint32(&o.P114PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP114PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P114PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P115PFS: Port 1%s Pin Function Select Register
func (o *PFS_Type) SetP115PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP115PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P115PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP115PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP115PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP115PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP115PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP115PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP115PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP115PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP115PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP115PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP115PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP115PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP115PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP115PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP115PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP115PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP115PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP115PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P115PFS.Reg, volatile.LoadUint32(&o.P115PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP115PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P115PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P200PFS: Port 200 Pin Function Select Register
func (o *PFS_Type) SetP200PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP200PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P200PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP200PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP200PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP200PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP200PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP200PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP200PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP200PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP200PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP200PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP200PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP200PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP200PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP200PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP200PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP200PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP200PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP200PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P200PFS.Reg, volatile.LoadUint32(&o.P200PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP200PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P200PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P201PFS: Port 201 Pin Function Select Register
func (o *PFS_Type) SetP201PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP201PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P201PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP201PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP201PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP201PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP201PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP201PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP201PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP201PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP201PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP201PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP201PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP201PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP201PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP201PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP201PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP201PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP201PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP201PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP201PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P205PFS: Port 20%s Pin Function Select Register
func (o *PFS_Type) SetP205PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP205PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P205PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP205PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP205PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP205PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP205PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP205PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP205PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP205PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP205PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP205PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP205PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP205PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP205PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP205PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP205PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP205PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP205PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP205PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P205PFS.Reg, volatile.LoadUint32(&o.P205PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP205PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P205PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P206PFS: Port 20%s Pin Function Select Register
func (o *PFS_Type) SetP206PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP206PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P206PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP206PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP206PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP206PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP206PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP206PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP206PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP206PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP206PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP206PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP206PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP206PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP206PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP206PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP206PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP206PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP206PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP206PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P206PFS.Reg, volatile.LoadUint32(&o.P206PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP206PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P206PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P207PFS: Port 20%s Pin Function Select Register
func (o *PFS_Type) SetP207PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP207PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P207PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP207PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP207PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP207PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP207PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP207PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP207PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP207PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP207PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP207PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP207PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP207PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP207PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP207PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP207PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP207PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP207PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP207PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P207PFS.Reg, volatile.LoadUint32(&o.P207PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP207PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P207PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P208PFS: Port 20%s Pin Function Select Register
func (o *PFS_Type) SetP208PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP208PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P208PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP208PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP208PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP208PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP208PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP208PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP208PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP208PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP208PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP208PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP208PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP208PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP208PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP208PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP208PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP208PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP208PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP208PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P208PFS.Reg, volatile.LoadUint32(&o.P208PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP208PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P208PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P209PFS: Port 20%s Pin Function Select Register
func (o *PFS_Type) SetP209PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P209PFS.Reg, volatile.LoadUint32(&o.P209PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP209PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P209PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP209PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P209PFS.Reg, volatile.LoadUint32(&o.P209PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP209PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P209PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP209PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P209PFS.Reg, volatile.LoadUint32(&o.P209PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP209PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P209PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP209PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P209PFS.Reg, volatile.LoadUint32(&o.P209PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP209PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P209PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP209PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P209PFS.Reg, volatile.LoadUint32(&o.P209PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP209PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P209PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP209PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P209PFS.Reg, volatile.LoadUint32(&o.P209PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP209PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P209PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP209PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P209PFS.Reg, volatile.LoadUint32(&o.P209PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP209PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P209PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP209PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P209PFS.Reg, volatile.LoadUint32(&o.P209PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP209PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P209PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP209PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P209PFS.Reg, volatile.LoadUint32(&o.P209PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP209PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P209PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP209PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P209PFS.Reg, volatile.LoadUint32(&o.P209PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP209PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P209PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P210PFS: Port 2%s Pin Function Select Register
func (o *PFS_Type) SetP210PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P210PFS.Reg, volatile.LoadUint32(&o.P210PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP210PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P210PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP210PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P210PFS.Reg, volatile.LoadUint32(&o.P210PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP210PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P210PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP210PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P210PFS.Reg, volatile.LoadUint32(&o.P210PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP210PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P210PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP210PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P210PFS.Reg, volatile.LoadUint32(&o.P210PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP210PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P210PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP210PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P210PFS.Reg, volatile.LoadUint32(&o.P210PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP210PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P210PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP210PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P210PFS.Reg, volatile.LoadUint32(&o.P210PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP210PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P210PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP210PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P210PFS.Reg, volatile.LoadUint32(&o.P210PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP210PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P210PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP210PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P210PFS.Reg, volatile.LoadUint32(&o.P210PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP210PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P210PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP210PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P210PFS.Reg, volatile.LoadUint32(&o.P210PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP210PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P210PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP210PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P210PFS.Reg, volatile.LoadUint32(&o.P210PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP210PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P210PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P211PFS: Port 2%s Pin Function Select Register
func (o *PFS_Type) SetP211PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P211PFS.Reg, volatile.LoadUint32(&o.P211PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP211PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P211PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP211PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P211PFS.Reg, volatile.LoadUint32(&o.P211PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP211PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P211PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP211PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P211PFS.Reg, volatile.LoadUint32(&o.P211PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP211PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P211PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP211PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P211PFS.Reg, volatile.LoadUint32(&o.P211PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP211PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P211PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP211PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P211PFS.Reg, volatile.LoadUint32(&o.P211PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP211PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P211PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP211PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P211PFS.Reg, volatile.LoadUint32(&o.P211PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP211PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P211PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP211PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P211PFS.Reg, volatile.LoadUint32(&o.P211PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP211PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P211PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP211PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P211PFS.Reg, volatile.LoadUint32(&o.P211PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP211PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P211PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP211PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P211PFS.Reg, volatile.LoadUint32(&o.P211PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP211PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P211PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP211PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P211PFS.Reg, volatile.LoadUint32(&o.P211PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP211PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P211PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P212PFS: Port 2%s Pin Function Select Register
func (o *PFS_Type) SetP212PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP212PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P212PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP212PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP212PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP212PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP212PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP212PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP212PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP212PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP212PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP212PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP212PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP212PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP212PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP212PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP212PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP212PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP212PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP212PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P212PFS.Reg, volatile.LoadUint32(&o.P212PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP212PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P212PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P213PFS: Port 2%s Pin Function Select Register
func (o *PFS_Type) SetP213PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP213PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P213PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP213PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP213PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP213PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP213PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP213PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP213PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP213PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP213PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP213PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP213PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP213PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP213PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP213PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP213PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP213PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP213PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP213PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P213PFS.Reg, volatile.LoadUint32(&o.P213PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP213PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P213PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P214PFS: Port 2%s Pin Function Select Register
func (o *PFS_Type) SetP214PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP214PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P214PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP214PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP214PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP214PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP214PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP214PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP214PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP214PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP214PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP214PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP214PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP214PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP214PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP214PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP214PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP214PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP214PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP214PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P214PFS.Reg, volatile.LoadUint32(&o.P214PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP214PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P214PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P300PFS: Port 300 Pin Function Select Register
func (o *PFS_Type) SetP300PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP300PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P300PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP300PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP300PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP300PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP300PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP300PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP300PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP300PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP300PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP300PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP300PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP300PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP300PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP300PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP300PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP300PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP300PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP300PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P300PFS.Reg, volatile.LoadUint32(&o.P300PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP300PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P300PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P301PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP301PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP301PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P301PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP301PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP301PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP301PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP301PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP301PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP301PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP301PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP301PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP301PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP301PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP301PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP301PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP301PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP301PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP301PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP301PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP301PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P301PFS.Reg, volatile.LoadUint32(&o.P301PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP301PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P301PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P302PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP302PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP302PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P302PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP302PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP302PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP302PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP302PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP302PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP302PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP302PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP302PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP302PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP302PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP302PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP302PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP302PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP302PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP302PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP302PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP302PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P302PFS.Reg, volatile.LoadUint32(&o.P302PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP302PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P302PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P303PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP303PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP303PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P303PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP303PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP303PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP303PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP303PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP303PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP303PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP303PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP303PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP303PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP303PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP303PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP303PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP303PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP303PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP303PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP303PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP303PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P303PFS.Reg, volatile.LoadUint32(&o.P303PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP303PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P303PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P304PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP304PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP304PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P304PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP304PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP304PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP304PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP304PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP304PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP304PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP304PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP304PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP304PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP304PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP304PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP304PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP304PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP304PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP304PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP304PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP304PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P304PFS.Reg, volatile.LoadUint32(&o.P304PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP304PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P304PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P305PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP305PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP305PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P305PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP305PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP305PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP305PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP305PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP305PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP305PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP305PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP305PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP305PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP305PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP305PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP305PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP305PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP305PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP305PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP305PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP305PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P305PFS.Reg, volatile.LoadUint32(&o.P305PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP305PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P305PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P306PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP306PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP306PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P306PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP306PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP306PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP306PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP306PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP306PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP306PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP306PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP306PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP306PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP306PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP306PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP306PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP306PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP306PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP306PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP306PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP306PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P306PFS.Reg, volatile.LoadUint32(&o.P306PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP306PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P306PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P307PFS: Port 30%s Pin Function Select Register
func (o *PFS_Type) SetP307PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP307PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P307PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP307PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP307PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP307PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP307PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP307PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP307PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP307PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP307PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP307PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP307PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP307PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP307PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP307PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP307PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP307PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP307PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP307PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P307PFS.Reg, volatile.LoadUint32(&o.P307PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP307PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P307PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P400PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP400PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP400PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P400PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP400PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP400PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP400PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP400PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP400PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP400PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP400PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP400PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP400PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP400PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP400PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP400PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP400PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP400PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP400PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP400PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP400PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P400PFS.Reg, volatile.LoadUint32(&o.P400PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP400PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P400PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P401PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP401PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP401PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P401PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP401PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP401PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP401PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP401PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP401PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP401PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP401PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP401PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP401PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP401PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP401PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP401PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP401PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP401PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP401PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP401PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP401PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P401PFS.Reg, volatile.LoadUint32(&o.P401PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP401PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P401PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P402PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP402PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP402PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P402PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP402PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP402PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP402PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP402PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP402PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP402PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP402PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP402PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP402PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP402PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP402PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP402PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP402PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP402PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP402PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP402PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP402PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P402PFS.Reg, volatile.LoadUint32(&o.P402PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP402PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P402PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P403PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP403PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP403PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P403PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP403PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP403PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP403PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP403PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP403PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP403PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP403PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP403PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP403PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP403PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP403PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP403PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP403PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP403PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP403PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP403PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP403PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P403PFS.Reg, volatile.LoadUint32(&o.P403PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP403PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P403PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P404PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP404PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP404PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P404PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP404PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP404PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP404PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP404PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP404PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP404PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP404PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP404PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP404PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP404PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP404PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP404PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP404PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP404PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP404PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP404PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP404PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P404PFS.Reg, volatile.LoadUint32(&o.P404PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP404PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P404PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P405PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP405PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP405PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P405PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP405PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP405PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP405PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP405PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP405PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP405PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP405PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP405PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP405PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP405PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP405PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP405PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP405PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP405PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP405PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP405PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP405PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P405PFS.Reg, volatile.LoadUint32(&o.P405PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP405PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P405PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P406PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP406PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP406PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P406PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP406PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP406PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP406PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP406PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP406PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP406PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP406PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP406PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP406PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP406PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP406PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP406PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP406PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP406PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP406PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP406PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP406PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P406PFS.Reg, volatile.LoadUint32(&o.P406PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP406PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P406PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P407PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP407PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP407PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P407PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP407PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP407PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP407PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP407PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP407PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP407PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP407PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP407PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP407PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP407PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP407PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP407PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP407PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP407PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP407PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP407PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP407PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP407PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P408PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP408PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP408PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P408PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP408PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP408PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP408PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP408PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP408PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP408PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP408PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP408PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP408PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP408PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP408PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP408PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP408PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP408PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP408PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP408PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP408PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P408PFS.Reg, volatile.LoadUint32(&o.P408PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP408PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P408PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P409PFS: Port 40%s Pin Function Select Register
func (o *PFS_Type) SetP409PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP409PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P409PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP409PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP409PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP409PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP409PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP409PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP409PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP409PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP409PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP409PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP409PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP409PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP409PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP409PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP409PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP409PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP409PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP409PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P409PFS.Reg, volatile.LoadUint32(&o.P409PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP409PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P409PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P410PFS: Port 4%s Pin Function Select Register
func (o *PFS_Type) SetP410PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP410PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P410PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP410PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP410PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP410PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP410PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP410PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP410PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP410PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP410PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP410PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP410PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP410PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP410PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP410PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP410PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP410PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP410PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP410PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P410PFS.Reg, volatile.LoadUint32(&o.P410PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP410PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P410PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P411PFS: Port 4%s Pin Function Select Register
func (o *PFS_Type) SetP411PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP411PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P411PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP411PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP411PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP411PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP411PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP411PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP411PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP411PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP411PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP411PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP411PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP411PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP411PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP411PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP411PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP411PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP411PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP411PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P411PFS.Reg, volatile.LoadUint32(&o.P411PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP411PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P411PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P412PFS: Port 4%s Pin Function Select Register
func (o *PFS_Type) SetP412PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP412PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P412PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP412PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP412PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP412PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP412PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP412PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP412PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP412PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP412PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP412PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP412PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP412PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP412PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP412PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP412PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP412PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP412PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP412PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P412PFS.Reg, volatile.LoadUint32(&o.P412PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP412PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P412PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P413PFS: Port 4%s Pin Function Select Register
func (o *PFS_Type) SetP413PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP413PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P413PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP413PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP413PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP413PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP413PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP413PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP413PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP413PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP413PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP413PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP413PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP413PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP413PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP413PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP413PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP413PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP413PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP413PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P413PFS.Reg, volatile.LoadUint32(&o.P413PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP413PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P413PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P414PFS: Port 4%s Pin Function Select Register
func (o *PFS_Type) SetP414PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP414PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P414PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP414PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP414PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP414PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP414PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP414PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP414PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP414PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP414PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP414PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP414PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP414PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP414PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP414PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP414PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP414PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP414PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP414PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P414PFS.Reg, volatile.LoadUint32(&o.P414PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP414PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P414PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P415PFS: Port 4%s Pin Function Select Register
func (o *PFS_Type) SetP415PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP415PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P415PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP415PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP415PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP415PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP415PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP415PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP415PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP415PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP415PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP415PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP415PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP415PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP415PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP415PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP415PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP415PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP415PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP415PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P415PFS.Reg, volatile.LoadUint32(&o.P415PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP415PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P415PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P500PFS: Port 50%s Pin Function Select Register
func (o *PFS_Type) SetP500PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP500PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P500PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP500PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP500PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP500PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP500PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP500PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP500PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP500PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP500PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP500PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP500PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP500PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP500PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP500PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP500PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP500PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P500PFS.Reg, volatile.LoadUint32(&o.P500PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP500PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P500PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P501PFS: Port 50%s Pin Function Select Register
func (o *PFS_Type) SetP501PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP501PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P501PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP501PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP501PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP501PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP501PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP501PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP501PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP501PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP501PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP501PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP501PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP501PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP501PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP501PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP501PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP501PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P501PFS.Reg, volatile.LoadUint32(&o.P501PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP501PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P501PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P502PFS: Port 50%s Pin Function Select Register
func (o *PFS_Type) SetP502PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP502PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P502PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP502PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP502PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP502PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP502PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP502PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP502PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP502PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP502PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP502PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP502PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP502PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP502PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP502PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP502PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP502PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P502PFS.Reg, volatile.LoadUint32(&o.P502PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP502PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P502PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P503PFS: Port 50%s Pin Function Select Register
func (o *PFS_Type) SetP503PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP503PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P503PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP503PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP503PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP503PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP503PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP503PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP503PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP503PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP503PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP503PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP503PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP503PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP503PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP503PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP503PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP503PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P503PFS.Reg, volatile.LoadUint32(&o.P503PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP503PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P503PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P504PFS: Port 50%s Pin Function Select Register
func (o *PFS_Type) SetP504PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP504PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P504PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP504PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP504PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP504PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP504PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP504PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP504PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP504PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP504PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP504PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP504PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP504PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP504PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP504PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP504PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP504PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P504PFS.Reg, volatile.LoadUint32(&o.P504PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP504PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P504PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P505PFS: Port 50%s Pin Function Select Register
func (o *PFS_Type) SetP505PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP505PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P505PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP505PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP505PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP505PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP505PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP505PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP505PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP505PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP505PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP505PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP505PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP505PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP505PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP505PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP505PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP505PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P505PFS.Reg, volatile.LoadUint32(&o.P505PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP505PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P505PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P600PFS: Port 60%s Pin Function Select Register
func (o *PFS_Type) SetP600PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP600PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P600PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP600PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP600PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP600PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP600PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP600PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP600PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP600PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP600PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP600PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP600PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP600PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP600PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP600PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP600PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP600PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P600PFS.Reg, volatile.LoadUint32(&o.P600PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP600PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P600PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P601PFS: Port 60%s Pin Function Select Register
func (o *PFS_Type) SetP601PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP601PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P601PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP601PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP601PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP601PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP601PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP601PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP601PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP601PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP601PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP601PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP601PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP601PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP601PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP601PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP601PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP601PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P601PFS.Reg, volatile.LoadUint32(&o.P601PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP601PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P601PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P602PFS: Port 60%s Pin Function Select Register
func (o *PFS_Type) SetP602PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP602PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P602PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP602PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP602PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP602PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP602PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP602PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP602PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP602PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP602PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP602PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP602PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP602PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP602PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP602PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP602PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP602PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P602PFS.Reg, volatile.LoadUint32(&o.P602PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP602PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P602PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P608PFS: Port 60%s Pin Function Select Register
func (o *PFS_Type) SetP608PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP608PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P608PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP608PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP608PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP608PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP608PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP608PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP608PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP608PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP608PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP608PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP608PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP608PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP608PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP608PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP608PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP608PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P608PFS.Reg, volatile.LoadUint32(&o.P608PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP608PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P608PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P609PFS: Port 60%s Pin Function Select Register
func (o *PFS_Type) SetP609PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP609PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P609PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP609PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP609PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP609PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP609PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP609PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP609PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP609PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP609PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP609PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP609PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP609PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP609PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP609PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP609PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP609PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P609PFS.Reg, volatile.LoadUint32(&o.P609PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP609PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P609PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P610PFS: Port 610 Pin Function Select Register
func (o *PFS_Type) SetP610PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP610PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P610PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP610PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP610PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP610PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP610PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP610PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP610PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP610PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP610PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP610PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP610PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP610PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP610PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP610PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP610PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP610PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P610PFS.Reg, volatile.LoadUint32(&o.P610PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP610PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P610PFS.Reg) & 0x1f000000) >> 24
}

// PFS.P708PFS: Port 708 Pin Function Select Register
func (o *PFS_Type) SetP708PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP708PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P708PFS.Reg) & 0x1
}
func (o *PFS_Type) SetP708PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP708PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP708PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP708PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP708PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP708PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP708PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP708PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP708PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP708PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP708PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP708PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP708PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP708PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP708PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P708PFS.Reg, volatile.LoadUint32(&o.P708PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP708PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P708PFS.Reg) & 0x1f000000) >> 24
}

// PFS.PFENET: Ethernet Control Register
func (o *PFS_Type) SetPFENET_PHYMODE0(value uint8) {
	volatile.StoreUint8(&o.PFENET.Reg, volatile.LoadUint8(&o.PFENET.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetPFENET_PHYMODE0() uint8 {
	return (volatile.LoadUint8(&o.PFENET.Reg) & 0x10) >> 4
}

// PFS.PWPR: Write-Protect Register
func (o *PFS_Type) SetPWPR_PFSWE(value uint8) {
	volatile.StoreUint8(&o.PWPR.Reg, volatile.LoadUint8(&o.PWPR.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetPWPR_PFSWE() uint8 {
	return (volatile.LoadUint8(&o.PWPR.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetPWPR_B0WI(value uint8) {
	volatile.StoreUint8(&o.PWPR.Reg, volatile.LoadUint8(&o.PWPR.Reg)&^(0x80)|value<<7)
}
func (o *PFS_Type) GetPWPR_B0WI() uint8 {
	return (volatile.LoadUint8(&o.PWPR.Reg) & 0x80) >> 7
}

// PFS.PWPRS: Write-Protect Register for Secure
func (o *PFS_Type) SetPWPRS_PFSWE(value uint8) {
	volatile.StoreUint8(&o.PWPRS.Reg, volatile.LoadUint8(&o.PWPRS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetPWPRS_PFSWE() uint8 {
	return (volatile.LoadUint8(&o.PWPRS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetPWPRS_B0WI(value uint8) {
	volatile.StoreUint8(&o.PWPRS.Reg, volatile.LoadUint8(&o.PWPRS.Reg)&^(0x80)|value<<7)
}
func (o *PFS_Type) GetPWPRS_B0WI() uint8 {
	return (volatile.LoadUint8(&o.PWPRS.Reg) & 0x80) >> 7
}

// PFS.P0SAR: Port Security Attribution register
func (o *PFS_Type) SetP0SAR(value uint16) {
	volatile.StoreUint16(&o.P0SAR.Reg, value)
}
func (o *PFS_Type) GetP0SAR() uint16 {
	return volatile.LoadUint16(&o.P0SAR.Reg)
}

// PFS.P1SAR: Port Security Attribution register
func (o *PFS_Type) SetP1SAR(value uint16) {
	volatile.StoreUint16(&o.P1SAR.Reg, value)
}
func (o *PFS_Type) GetP1SAR() uint16 {
	return volatile.LoadUint16(&o.P1SAR.Reg)
}

// PFS.P2SAR: Port Security Attribution register
func (o *PFS_Type) SetP2SAR(value uint16) {
	volatile.StoreUint16(&o.P2SAR.Reg, value)
}
func (o *PFS_Type) GetP2SAR() uint16 {
	return volatile.LoadUint16(&o.P2SAR.Reg)
}

// PFS.P3SAR: Port Security Attribution register
func (o *PFS_Type) SetP3SAR(value uint16) {
	volatile.StoreUint16(&o.P3SAR.Reg, value)
}
func (o *PFS_Type) GetP3SAR() uint16 {
	return volatile.LoadUint16(&o.P3SAR.Reg)
}

// PFS.P4SAR: Port Security Attribution register
func (o *PFS_Type) SetP4SAR(value uint16) {
	volatile.StoreUint16(&o.P4SAR.Reg, value)
}
func (o *PFS_Type) GetP4SAR() uint16 {
	return volatile.LoadUint16(&o.P4SAR.Reg)
}

// PFS.P5SAR: Port Security Attribution register
func (o *PFS_Type) SetP5SAR(value uint16) {
	volatile.StoreUint16(&o.P5SAR.Reg, value)
}
func (o *PFS_Type) GetP5SAR() uint16 {
	return volatile.LoadUint16(&o.P5SAR.Reg)
}

// PFS.P6SAR: Port Security Attribution register
func (o *PFS_Type) SetP6SAR(value uint16) {
	volatile.StoreUint16(&o.P6SAR.Reg, value)
}
func (o *PFS_Type) GetP6SAR() uint16 {
	return volatile.LoadUint16(&o.P6SAR.Reg)
}

// PFS.P7SAR: Port Security Attribution register
func (o *PFS_Type) SetP7SAR(value uint16) {
	volatile.StoreUint16(&o.P7SAR.Reg, value)
}
func (o *PFS_Type) GetP7SAR() uint16 {
	return volatile.LoadUint16(&o.P7SAR.Reg)
}

// Event Link Controller
type ELC_Type struct {
	ELCR    volatile.Register8 // 0x0
	_       byte
	ELSEGR0 volatile.Register8 // 0x2
	_       byte
	ELSEGR1 volatile.Register8 // 0x4
	_       [11]byte
	ELSR0   volatile.Register16 // 0x10
	_       [2]byte
	ELSR1   volatile.Register16 // 0x14
	_       [2]byte
	ELSR2   volatile.Register16 // 0x18
	_       [2]byte
	ELSR3   volatile.Register16 // 0x1C
	_       [2]byte
	ELSR4   volatile.Register16 // 0x20
	_       [2]byte
	ELSR5   volatile.Register16 // 0x24
	_       [2]byte
	ELSR6   volatile.Register16 // 0x28
	_       [2]byte
	ELSR7   volatile.Register16 // 0x2C
	_       [2]byte
	ELSR8   volatile.Register16 // 0x30
	_       [2]byte
	ELSR9   volatile.Register16 // 0x34
	_       [10]byte
	ELSR12  volatile.Register16 // 0x40
	_       [6]byte
	ELSR14  volatile.Register16 // 0x48
	_       [2]byte
	ELSR15  volatile.Register16 // 0x4C
	_       [2]byte
	ELSR16  volatile.Register16 // 0x50
	_       [2]byte
	ELSR17  volatile.Register16 // 0x54
	_       [30]byte
	ELCSARA volatile.Register16 // 0x74
	_       [2]byte
	ELCSARB volatile.Register16 // 0x78
	_       [2]byte
	ELCSARC volatile.Register16 // 0x7C
}

// ELC.ELCR: Event Link Controller Register
func (o *ELC_Type) SetELCR_ELCON(value uint8) {
	volatile.StoreUint8(&o.ELCR.Reg, volatile.LoadUint8(&o.ELCR.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELCR_ELCON() uint8 {
	return (volatile.LoadUint8(&o.ELCR.Reg) & 0x80) >> 7
}

// ELC.ELSEGR0: Event Link Software Event Generation Register %s
func (o *ELC_Type) SetELSEGR0_SEG(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x1)|value)
}
func (o *ELC_Type) GetELSEGR0_SEG() uint8 {
	return volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x1
}
func (o *ELC_Type) SetELSEGR0_WE(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x40)|value<<6)
}
func (o *ELC_Type) GetELSEGR0_WE() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x40) >> 6
}
func (o *ELC_Type) SetELSEGR0_WI(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELSEGR0_WI() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x80) >> 7
}

// ELC.ELSEGR1: Event Link Software Event Generation Register %s
func (o *ELC_Type) SetELSEGR1_SEG(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x1)|value)
}
func (o *ELC_Type) GetELSEGR1_SEG() uint8 {
	return volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x1
}
func (o *ELC_Type) SetELSEGR1_WE(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x40)|value<<6)
}
func (o *ELC_Type) GetELSEGR1_WE() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x40) >> 6
}
func (o *ELC_Type) SetELSEGR1_WI(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELSEGR1_WI() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x80) >> 7
}

// ELC.ELSR0: Event Link Setting Register %s
func (o *ELC_Type) SetELSR0_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR0.Reg, volatile.LoadUint16(&o.ELSR0.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR0_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR0.Reg) & 0x1ff
}

// ELC.ELSR1: Event Link Setting Register %s
func (o *ELC_Type) SetELSR1_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR1.Reg, volatile.LoadUint16(&o.ELSR1.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR1_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR1.Reg) & 0x1ff
}

// ELC.ELSR2: Event Link Setting Register %s
func (o *ELC_Type) SetELSR2_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR2.Reg, volatile.LoadUint16(&o.ELSR2.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR2_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR2.Reg) & 0x1ff
}

// ELC.ELSR3: Event Link Setting Register %s
func (o *ELC_Type) SetELSR3_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR3.Reg, volatile.LoadUint16(&o.ELSR3.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR3_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR3.Reg) & 0x1ff
}

// ELC.ELSR4: Event Link Setting Register %s
func (o *ELC_Type) SetELSR4_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR4.Reg, volatile.LoadUint16(&o.ELSR4.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR4_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR4.Reg) & 0x1ff
}

// ELC.ELSR5: Event Link Setting Register %s
func (o *ELC_Type) SetELSR5_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR5.Reg, volatile.LoadUint16(&o.ELSR5.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR5_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR5.Reg) & 0x1ff
}

// ELC.ELSR6: Event Link Setting Register %s
func (o *ELC_Type) SetELSR6_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR6.Reg, volatile.LoadUint16(&o.ELSR6.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR6_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR6.Reg) & 0x1ff
}

// ELC.ELSR7: Event Link Setting Register %s
func (o *ELC_Type) SetELSR7_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR7.Reg, volatile.LoadUint16(&o.ELSR7.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR7_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR7.Reg) & 0x1ff
}

// ELC.ELSR8: Event Link Setting Register %s
func (o *ELC_Type) SetELSR8_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR8.Reg, volatile.LoadUint16(&o.ELSR8.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR8_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR8.Reg) & 0x1ff
}

// ELC.ELSR9: Event Link Setting Register %s
func (o *ELC_Type) SetELSR9_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR9.Reg, volatile.LoadUint16(&o.ELSR9.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR9_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR9.Reg) & 0x1ff
}

// ELC.ELSR12: Event Link Setting Register 12
func (o *ELC_Type) SetELSR12_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR12.Reg, volatile.LoadUint16(&o.ELSR12.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR12_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR12.Reg) & 0x1ff
}

// ELC.ELSR14: Event Link Setting Register %s
func (o *ELC_Type) SetELSR14_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR14.Reg, volatile.LoadUint16(&o.ELSR14.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR14_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR14.Reg) & 0x1ff
}

// ELC.ELSR15: Event Link Setting Register %s
func (o *ELC_Type) SetELSR15_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR15.Reg, volatile.LoadUint16(&o.ELSR15.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR15_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR15.Reg) & 0x1ff
}

// ELC.ELSR16: Event Link Setting Register %s
func (o *ELC_Type) SetELSR16_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR16.Reg, volatile.LoadUint16(&o.ELSR16.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR16_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR16.Reg) & 0x1ff
}

// ELC.ELSR17: Event Link Setting Register %s
func (o *ELC_Type) SetELSR17_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR17.Reg, volatile.LoadUint16(&o.ELSR17.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR17_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR17.Reg) & 0x1ff
}

// ELC.ELCSARA: Event Link Controller Security Attribution Register A
func (o *ELC_Type) SetELCSARA_ELCR(value uint16) {
	volatile.StoreUint16(&o.ELCSARA.Reg, volatile.LoadUint16(&o.ELCSARA.Reg)&^(0x1)|value)
}
func (o *ELC_Type) GetELCSARA_ELCR() uint16 {
	return volatile.LoadUint16(&o.ELCSARA.Reg) & 0x1
}
func (o *ELC_Type) SetELCSARA_ELSEGR0(value uint16) {
	volatile.StoreUint16(&o.ELCSARA.Reg, volatile.LoadUint16(&o.ELCSARA.Reg)&^(0x2)|value<<1)
}
func (o *ELC_Type) GetELCSARA_ELSEGR0() uint16 {
	return (volatile.LoadUint16(&o.ELCSARA.Reg) & 0x2) >> 1
}
func (o *ELC_Type) SetELCSARA_ELSEGR1(value uint16) {
	volatile.StoreUint16(&o.ELCSARA.Reg, volatile.LoadUint16(&o.ELCSARA.Reg)&^(0x4)|value<<2)
}
func (o *ELC_Type) GetELCSARA_ELSEGR1() uint16 {
	return (volatile.LoadUint16(&o.ELCSARA.Reg) & 0x4) >> 2
}

// ELC.ELCSARB: Event Link Controller Security Attribution Register B
func (o *ELC_Type) SetELCSARB(value uint16) {
	volatile.StoreUint16(&o.ELCSARB.Reg, value)
}
func (o *ELC_Type) GetELCSARB() uint16 {
	return volatile.LoadUint16(&o.ELCSARB.Reg)
}

// ELC.ELCSARC: Event Link Controller Security Attribution Register C
func (o *ELC_Type) SetELCSARC_ELSR(value uint16) {
	volatile.StoreUint16(&o.ELCSARC.Reg, volatile.LoadUint16(&o.ELCSARC.Reg)&^(0x3)|value)
}
func (o *ELC_Type) GetELCSARC_ELSR() uint16 {
	return volatile.LoadUint16(&o.ELCSARC.Reg) & 0x3
}

// Realtime Clock
type RTC_Type struct {
	R64CNT   volatile.Register8 // 0x0
	_        byte
	BCNT0    volatile.Register8 // 0x2
	_        byte
	BCNT1    volatile.Register8 // 0x4
	_        byte
	BCNT2    volatile.Register8 // 0x6
	_        byte
	BCNT3    volatile.Register8 // 0x8
	_        byte
	RDAYCNT  volatile.Register8 // 0xA
	_        byte
	RMONCNT  volatile.Register8 // 0xC
	_        byte
	RYRCNT   volatile.Register16 // 0xE
	BCNT0AR  volatile.Register8  // 0x10
	_        byte
	BCNT1AR  volatile.Register8 // 0x12
	_        byte
	BCNT2AR  volatile.Register8 // 0x14
	_        byte
	BCNT3AR  volatile.Register8 // 0x16
	_        byte
	BCNT0AER volatile.Register8 // 0x18
	_        byte
	BCNT1AER volatile.Register8 // 0x1A
	_        byte
	BCNT2AER volatile.Register16 // 0x1C
	BCNT3AER volatile.Register8  // 0x1E
	_        [3]byte
	RCR1     volatile.Register8 // 0x22
	_        byte
	RCR2     volatile.Register8 // 0x24
	_        [3]byte
	RCR4     volatile.Register8 // 0x28
	_        byte
	RFRH     volatile.Register16 // 0x2A
	RFRL     volatile.Register16 // 0x2C
	RADJ     volatile.Register8  // 0x2E
	_        [17]byte
	RTCCR0   volatile.Register8 // 0x40
	_        byte
	RTCCR1   volatile.Register8 // 0x42
	_        byte
	RTCCR2   volatile.Register8 // 0x44
	_        [13]byte
	BCNT0CP0 volatile.Register8 // 0x52
	_        byte
	BCNT1CP0 volatile.Register8 // 0x54
	_        byte
	BCNT2CP0 volatile.Register8 // 0x56
	_        [3]byte
	BCNT3CP0 volatile.Register8 // 0x5A
	_        byte
	RMONCP0  volatile.Register8 // 0x5C
	_        [5]byte
	BCNT0CP1 volatile.Register8 // 0x62
	_        byte
	BCNT1CP1 volatile.Register8 // 0x64
	_        byte
	BCNT2CP1 volatile.Register8 // 0x66
	_        [3]byte
	BCNT3CP1 volatile.Register8 // 0x6A
	_        byte
	RMONCP1  volatile.Register8 // 0x6C
	_        [5]byte
	BCNT0CP2 volatile.Register8 // 0x72
	_        byte
	BCNT1CP2 volatile.Register8 // 0x74
	_        byte
	BCNT2CP2 volatile.Register8 // 0x76
	_        [3]byte
	BCNT3CP2 volatile.Register8 // 0x7A
	_        byte
	RMONCP2  volatile.Register8 // 0x7C
}

// RTC.R64CNT: 64-Hz Counter
func (o *RTC_Type) SetR64CNT_F64HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetR64CNT_F64HZ() uint8 {
	return volatile.LoadUint8(&o.R64CNT.Reg) & 0x1
}
func (o *RTC_Type) SetR64CNT_F32HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetR64CNT_F32HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetR64CNT_F16HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetR64CNT_F16HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetR64CNT_F8HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetR64CNT_F8HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetR64CNT_F4HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetR64CNT_F4HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetR64CNT_F2HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetR64CNT_F2HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetR64CNT_F1HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetR64CNT_F1HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x40) >> 6
}

// RTC.BCNT0: Binary Counter %s
func (o *RTC_Type) SetBCNT0(value uint8) {
	volatile.StoreUint8(&o.BCNT0.Reg, value)
}
func (o *RTC_Type) GetBCNT0() uint8 {
	return volatile.LoadUint8(&o.BCNT0.Reg)
}

// RTC.BCNT1: Binary Counter %s
func (o *RTC_Type) SetBCNT1(value uint8) {
	volatile.StoreUint8(&o.BCNT1.Reg, value)
}
func (o *RTC_Type) GetBCNT1() uint8 {
	return volatile.LoadUint8(&o.BCNT1.Reg)
}

// RTC.BCNT2: Binary Counter %s
func (o *RTC_Type) SetBCNT2(value uint8) {
	volatile.StoreUint8(&o.BCNT2.Reg, value)
}
func (o *RTC_Type) GetBCNT2() uint8 {
	return volatile.LoadUint8(&o.BCNT2.Reg)
}

// RTC.BCNT3: Binary Counter %s
func (o *RTC_Type) SetBCNT3(value uint8) {
	volatile.StoreUint8(&o.BCNT3.Reg, value)
}
func (o *RTC_Type) GetBCNT3() uint8 {
	return volatile.LoadUint8(&o.BCNT3.Reg)
}

// RTC.RDAYCNT: Day Counter
func (o *RTC_Type) SetRDAYCNT_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYCNT.Reg, volatile.LoadUint8(&o.RDAYCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYCNT_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYCNT.Reg) & 0xf
}
func (o *RTC_Type) SetRDAYCNT_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYCNT.Reg, volatile.LoadUint8(&o.RDAYCNT.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYCNT_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYCNT.Reg) & 0x30) >> 4
}

// RTC.RMONCNT: Month Counter
func (o *RTC_Type) SetRMONCNT_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCNT.Reg, volatile.LoadUint8(&o.RMONCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCNT_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCNT.Reg) & 0xf
}
func (o *RTC_Type) SetRMONCNT_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCNT.Reg, volatile.LoadUint8(&o.RMONCNT.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCNT_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCNT.Reg) & 0x10) >> 4
}

// RTC.RYRCNT: Year Counter
func (o *RTC_Type) SetRYRCNT_YR1(value uint16) {
	volatile.StoreUint16(&o.RYRCNT.Reg, volatile.LoadUint16(&o.RYRCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRYRCNT_YR1() uint16 {
	return volatile.LoadUint16(&o.RYRCNT.Reg) & 0xf
}
func (o *RTC_Type) SetRYRCNT_YR10(value uint16) {
	volatile.StoreUint16(&o.RYRCNT.Reg, volatile.LoadUint16(&o.RYRCNT.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetRYRCNT_YR10() uint16 {
	return (volatile.LoadUint16(&o.RYRCNT.Reg) & 0xf0) >> 4
}

// RTC.BCNT0AR: Binary Counter %s Alarm Register
func (o *RTC_Type) SetBCNT0AR(value uint8) {
	volatile.StoreUint8(&o.BCNT0AR.Reg, value)
}
func (o *RTC_Type) GetBCNT0AR() uint8 {
	return volatile.LoadUint8(&o.BCNT0AR.Reg)
}

// RTC.BCNT1AR: Binary Counter %s Alarm Register
func (o *RTC_Type) SetBCNT1AR(value uint8) {
	volatile.StoreUint8(&o.BCNT1AR.Reg, value)
}
func (o *RTC_Type) GetBCNT1AR() uint8 {
	return volatile.LoadUint8(&o.BCNT1AR.Reg)
}

// RTC.BCNT2AR: Binary Counter %s Alarm Register
func (o *RTC_Type) SetBCNT2AR(value uint8) {
	volatile.StoreUint8(&o.BCNT2AR.Reg, value)
}
func (o *RTC_Type) GetBCNT2AR() uint8 {
	return volatile.LoadUint8(&o.BCNT2AR.Reg)
}

// RTC.BCNT3AR: Binary Counter %s Alarm Register
func (o *RTC_Type) SetBCNT3AR(value uint8) {
	volatile.StoreUint8(&o.BCNT3AR.Reg, value)
}
func (o *RTC_Type) GetBCNT3AR() uint8 {
	return volatile.LoadUint8(&o.BCNT3AR.Reg)
}

// RTC.BCNT0AER: Binary Counter %s Alarm Enable Register
func (o *RTC_Type) SetBCNT0AER(value uint8) {
	volatile.StoreUint8(&o.BCNT0AER.Reg, value)
}
func (o *RTC_Type) GetBCNT0AER() uint8 {
	return volatile.LoadUint8(&o.BCNT0AER.Reg)
}

// RTC.BCNT1AER: Binary Counter %s Alarm Enable Register
func (o *RTC_Type) SetBCNT1AER(value uint8) {
	volatile.StoreUint8(&o.BCNT1AER.Reg, value)
}
func (o *RTC_Type) GetBCNT1AER() uint8 {
	return volatile.LoadUint8(&o.BCNT1AER.Reg)
}

// RTC.BCNT2AER: Binary Counter 2 Alarm Enable Register
func (o *RTC_Type) SetBCNT2AER_ENB(value uint16) {
	volatile.StoreUint16(&o.BCNT2AER.Reg, volatile.LoadUint16(&o.BCNT2AER.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetBCNT2AER_ENB() uint16 {
	return volatile.LoadUint16(&o.BCNT2AER.Reg) & 0xff
}

// RTC.BCNT3AER: Binary Counter 3 Alarm Enable Register
func (o *RTC_Type) SetBCNT3AER(value uint8) {
	volatile.StoreUint8(&o.BCNT3AER.Reg, value)
}
func (o *RTC_Type) GetBCNT3AER() uint8 {
	return volatile.LoadUint8(&o.BCNT3AER.Reg)
}

// RTC.RCR1: RTC Control Register 1
func (o *RTC_Type) SetRCR1_AIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR1_AIE() uint8 {
	return volatile.LoadUint8(&o.RCR1.Reg) & 0x1
}
func (o *RTC_Type) SetRCR1_CIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetRCR1_CIE() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetRCR1_PIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRCR1_PIE() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRCR1_RTCOS(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRCR1_RTCOS() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRCR1_PES(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetRCR1_PES() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0xf0) >> 4
}

// RTC.RCR2: RTC Control Register 2 (in Calendar Count Mode)
func (o *RTC_Type) SetRCR2_START(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR2_START() uint8 {
	return volatile.LoadUint8(&o.RCR2.Reg) & 0x1
}
func (o *RTC_Type) SetRCR2_RESET(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetRCR2_RESET() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetRCR2_ADJ30(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRCR2_ADJ30() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRCR2_RTCOE(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRCR2_RTCOE() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRCR2_AADJE(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRCR2_AADJE() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRCR2_AADJP(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetRCR2_AADJP() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetRCR2_HR24(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRCR2_HR24() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRCR2_CNTMD(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRCR2_CNTMD() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x80) >> 7
}

// RTC.RCR4: RTC Control Register 4
func (o *RTC_Type) SetRCR4_RCKSEL(value uint8) {
	volatile.StoreUint8(&o.RCR4.Reg, volatile.LoadUint8(&o.RCR4.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR4_RCKSEL() uint8 {
	return volatile.LoadUint8(&o.RCR4.Reg) & 0x1
}

// RTC.RFRH: Frequency Register H
func (o *RTC_Type) SetRFRH_RFC16(value uint16) {
	volatile.StoreUint16(&o.RFRH.Reg, volatile.LoadUint16(&o.RFRH.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRFRH_RFC16() uint16 {
	return volatile.LoadUint16(&o.RFRH.Reg) & 0x1
}

// RTC.RFRL: Frequency Register L
func (o *RTC_Type) SetRFRL(value uint16) {
	volatile.StoreUint16(&o.RFRL.Reg, value)
}
func (o *RTC_Type) GetRFRL() uint16 {
	return volatile.LoadUint16(&o.RFRL.Reg)
}

// RTC.RADJ: Time Error Adjustment Register
func (o *RTC_Type) SetRADJ_ADJ(value uint8) {
	volatile.StoreUint8(&o.RADJ.Reg, volatile.LoadUint8(&o.RADJ.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetRADJ_ADJ() uint8 {
	return volatile.LoadUint8(&o.RADJ.Reg) & 0x3f
}
func (o *RTC_Type) SetRADJ_PMADJ(value uint8) {
	volatile.StoreUint8(&o.RADJ.Reg, volatile.LoadUint8(&o.RADJ.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_Type) GetRADJ_PMADJ() uint8 {
	return (volatile.LoadUint8(&o.RADJ.Reg) & 0xc0) >> 6
}

// RTC.RTCCR0: Time Capture Control Register %s
func (o *RTC_Type) SetRTCCR0_TCCT(value uint8) {
	volatile.StoreUint8(&o.RTCCR0.Reg, volatile.LoadUint8(&o.RTCCR0.Reg)&^(0x3)|value)
}
func (o *RTC_Type) GetRTCCR0_TCCT() uint8 {
	return volatile.LoadUint8(&o.RTCCR0.Reg) & 0x3
}
func (o *RTC_Type) SetRTCCR0_TCST(value uint8) {
	volatile.StoreUint8(&o.RTCCR0.Reg, volatile.LoadUint8(&o.RTCCR0.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRTCCR0_TCST() uint8 {
	return (volatile.LoadUint8(&o.RTCCR0.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRTCCR0_TCNF(value uint8) {
	volatile.StoreUint8(&o.RTCCR0.Reg, volatile.LoadUint8(&o.RTCCR0.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRTCCR0_TCNF() uint8 {
	return (volatile.LoadUint8(&o.RTCCR0.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRTCCR0_TCEN(value uint8) {
	volatile.StoreUint8(&o.RTCCR0.Reg, volatile.LoadUint8(&o.RTCCR0.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRTCCR0_TCEN() uint8 {
	return (volatile.LoadUint8(&o.RTCCR0.Reg) & 0x80) >> 7
}

// RTC.RTCCR1: Time Capture Control Register %s
func (o *RTC_Type) SetRTCCR1_TCCT(value uint8) {
	volatile.StoreUint8(&o.RTCCR1.Reg, volatile.LoadUint8(&o.RTCCR1.Reg)&^(0x3)|value)
}
func (o *RTC_Type) GetRTCCR1_TCCT() uint8 {
	return volatile.LoadUint8(&o.RTCCR1.Reg) & 0x3
}
func (o *RTC_Type) SetRTCCR1_TCST(value uint8) {
	volatile.StoreUint8(&o.RTCCR1.Reg, volatile.LoadUint8(&o.RTCCR1.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRTCCR1_TCST() uint8 {
	return (volatile.LoadUint8(&o.RTCCR1.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRTCCR1_TCNF(value uint8) {
	volatile.StoreUint8(&o.RTCCR1.Reg, volatile.LoadUint8(&o.RTCCR1.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRTCCR1_TCNF() uint8 {
	return (volatile.LoadUint8(&o.RTCCR1.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRTCCR1_TCEN(value uint8) {
	volatile.StoreUint8(&o.RTCCR1.Reg, volatile.LoadUint8(&o.RTCCR1.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRTCCR1_TCEN() uint8 {
	return (volatile.LoadUint8(&o.RTCCR1.Reg) & 0x80) >> 7
}

// RTC.RTCCR2: Time Capture Control Register %s
func (o *RTC_Type) SetRTCCR2_TCCT(value uint8) {
	volatile.StoreUint8(&o.RTCCR2.Reg, volatile.LoadUint8(&o.RTCCR2.Reg)&^(0x3)|value)
}
func (o *RTC_Type) GetRTCCR2_TCCT() uint8 {
	return volatile.LoadUint8(&o.RTCCR2.Reg) & 0x3
}
func (o *RTC_Type) SetRTCCR2_TCST(value uint8) {
	volatile.StoreUint8(&o.RTCCR2.Reg, volatile.LoadUint8(&o.RTCCR2.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRTCCR2_TCST() uint8 {
	return (volatile.LoadUint8(&o.RTCCR2.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRTCCR2_TCNF(value uint8) {
	volatile.StoreUint8(&o.RTCCR2.Reg, volatile.LoadUint8(&o.RTCCR2.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRTCCR2_TCNF() uint8 {
	return (volatile.LoadUint8(&o.RTCCR2.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRTCCR2_TCEN(value uint8) {
	volatile.StoreUint8(&o.RTCCR2.Reg, volatile.LoadUint8(&o.RTCCR2.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRTCCR2_TCEN() uint8 {
	return (volatile.LoadUint8(&o.RTCCR2.Reg) & 0x80) >> 7
}

// RTC.RMONCP0: Month Capture Register %s
func (o *RTC_Type) SetRMONCP0_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCP0.Reg, volatile.LoadUint8(&o.RMONCP0.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCP0_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCP0.Reg) & 0xf
}
func (o *RTC_Type) SetRMONCP0_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCP0.Reg, volatile.LoadUint8(&o.RMONCP0.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCP0_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCP0.Reg) & 0x10) >> 4
}

// RTC.RMONCP1: Month Capture Register %s
func (o *RTC_Type) SetRMONCP1_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCP1.Reg, volatile.LoadUint8(&o.RMONCP1.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCP1_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCP1.Reg) & 0xf
}
func (o *RTC_Type) SetRMONCP1_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCP1.Reg, volatile.LoadUint8(&o.RMONCP1.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCP1_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCP1.Reg) & 0x10) >> 4
}

// RTC.RMONCP2: Month Capture Register %s
func (o *RTC_Type) SetRMONCP2_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCP2.Reg, volatile.LoadUint8(&o.RMONCP2.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCP2_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCP2.Reg) & 0xf
}
func (o *RTC_Type) SetRMONCP2_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCP2.Reg, volatile.LoadUint8(&o.RMONCP2.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCP2_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCP2.Reg) & 0x10) >> 4
}

// Independent Watchdog Timer
type IWDT_Type struct {
	IWDTRR volatile.Register8 // 0x0
	_      [3]byte
	IWDTSR volatile.Register16 // 0x4
}

// IWDT.IWDTSR: IWDT Status Register
func (o *IWDT_Type) SetIWDTSR_CNTVAL(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x3fff)|value)
}
func (o *IWDT_Type) GetIWDTSR_CNTVAL() uint16 {
	return volatile.LoadUint16(&o.IWDTSR.Reg) & 0x3fff
}
func (o *IWDT_Type) SetIWDTSR_UNDFF(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x4000)|value<<14)
}
func (o *IWDT_Type) GetIWDTSR_UNDFF() uint16 {
	return (volatile.LoadUint16(&o.IWDTSR.Reg) & 0x4000) >> 14
}
func (o *IWDT_Type) SetIWDTSR_REFEF(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x8000)|value<<15)
}
func (o *IWDT_Type) GetIWDTSR_REFEF() uint16 {
	return (volatile.LoadUint16(&o.IWDTSR.Reg) & 0x8000) >> 15
}

// Watchdog Timer
type WDT_Type struct {
	WDTRR    volatile.Register8 // 0x0
	_        byte
	WDTCR    volatile.Register16 // 0x2
	WDTSR    volatile.Register16 // 0x4
	WDTRCR   volatile.Register8  // 0x6
	_        byte
	WDTCSTPR volatile.Register8 // 0x8
}

// WDT.WDTCR: WDT Control Register
func (o *WDT_Type) SetWDTCR_TOPS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x3)|value)
}
func (o *WDT_Type) GetWDTCR_TOPS() uint16 {
	return volatile.LoadUint16(&o.WDTCR.Reg) & 0x3
}
func (o *WDT_Type) SetWDTCR_CKS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0xf0)|value<<4)
}
func (o *WDT_Type) GetWDTCR_CKS() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0xf0) >> 4
}
func (o *WDT_Type) SetWDTCR_RPES(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x300)|value<<8)
}
func (o *WDT_Type) GetWDTCR_RPES() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0x300) >> 8
}
func (o *WDT_Type) SetWDTCR_RPSS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x3000)|value<<12)
}
func (o *WDT_Type) GetWDTCR_RPSS() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0x3000) >> 12
}

// WDT.WDTSR: WDT Status Register
func (o *WDT_Type) SetWDTSR_CNTVAL(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x3fff)|value)
}
func (o *WDT_Type) GetWDTSR_CNTVAL() uint16 {
	return volatile.LoadUint16(&o.WDTSR.Reg) & 0x3fff
}
func (o *WDT_Type) SetWDTSR_UNDFF(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x4000)|value<<14)
}
func (o *WDT_Type) GetWDTSR_UNDFF() uint16 {
	return (volatile.LoadUint16(&o.WDTSR.Reg) & 0x4000) >> 14
}
func (o *WDT_Type) SetWDTSR_REFEF(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x8000)|value<<15)
}
func (o *WDT_Type) GetWDTSR_REFEF() uint16 {
	return (volatile.LoadUint16(&o.WDTSR.Reg) & 0x8000) >> 15
}

// WDT.WDTRCR: WDT Reset Control Register
func (o *WDT_Type) SetWDTRCR_RSTIRQS(value uint8) {
	volatile.StoreUint8(&o.WDTRCR.Reg, volatile.LoadUint8(&o.WDTRCR.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetWDTRCR_RSTIRQS() uint8 {
	return (volatile.LoadUint8(&o.WDTRCR.Reg) & 0x80) >> 7
}

// WDT.WDTCSTPR: WDT Count Stop Control Register
func (o *WDT_Type) SetWDTCSTPR_SLCSTP(value uint8) {
	volatile.StoreUint8(&o.WDTCSTPR.Reg, volatile.LoadUint8(&o.WDTCSTPR.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetWDTCSTPR_SLCSTP() uint8 {
	return (volatile.LoadUint8(&o.WDTCSTPR.Reg) & 0x80) >> 7
}

// Clock Frequency Accuracy Measurement Circuit
type CAC_Type struct {
	CACR0   volatile.Register8 // 0x0
	CACR1   volatile.Register8 // 0x1
	CACR2   volatile.Register8 // 0x2
	CAICR   volatile.Register8 // 0x3
	CASTR   volatile.Register8 // 0x4
	_       byte
	CAULVR  volatile.Register16 // 0x6
	CALLVR  volatile.Register16 // 0x8
	CACNTBR volatile.Register16 // 0xA
}

// CAC.CACR0: CAC Control Register 0
func (o *CAC_Type) SetCACR0_CFME(value uint8) {
	volatile.StoreUint8(&o.CACR0.Reg, volatile.LoadUint8(&o.CACR0.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR0_CFME() uint8 {
	return volatile.LoadUint8(&o.CACR0.Reg) & 0x1
}

// CAC.CACR1: CAC Control Register 1
func (o *CAC_Type) SetCACR1_CACREFE(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR1_CACREFE() uint8 {
	return volatile.LoadUint8(&o.CACR1.Reg) & 0x1
}
func (o *CAC_Type) SetCACR1_FMCS(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0xe)|value<<1)
}
func (o *CAC_Type) GetCACR1_FMCS() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0xe) >> 1
}
func (o *CAC_Type) SetCACR1_TCSS(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0x30)|value<<4)
}
func (o *CAC_Type) GetCACR1_TCSS() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0x30) >> 4
}
func (o *CAC_Type) SetCACR1_EDGES(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0xc0)|value<<6)
}
func (o *CAC_Type) GetCACR1_EDGES() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0xc0) >> 6
}

// CAC.CACR2: CAC Control Register 2
func (o *CAC_Type) SetCACR2_RPS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR2_RPS() uint8 {
	return volatile.LoadUint8(&o.CACR2.Reg) & 0x1
}
func (o *CAC_Type) SetCACR2_RSCS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0xe)|value<<1)
}
func (o *CAC_Type) GetCACR2_RSCS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0xe) >> 1
}
func (o *CAC_Type) SetCACR2_RCDS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0x30)|value<<4)
}
func (o *CAC_Type) GetCACR2_RCDS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0x30) >> 4
}
func (o *CAC_Type) SetCACR2_DFS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0xc0)|value<<6)
}
func (o *CAC_Type) GetCACR2_DFS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0xc0) >> 6
}

// CAC.CAICR: CAC Interrupt Control Register
func (o *CAC_Type) SetCAICR_FERRIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCAICR_FERRIE() uint8 {
	return volatile.LoadUint8(&o.CAICR.Reg) & 0x1
}
func (o *CAC_Type) SetCAICR_MENDIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x2)|value<<1)
}
func (o *CAC_Type) GetCAICR_MENDIE() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x2) >> 1
}
func (o *CAC_Type) SetCAICR_OVFIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x4)|value<<2)
}
func (o *CAC_Type) GetCAICR_OVFIE() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x4) >> 2
}
func (o *CAC_Type) SetCAICR_FERRFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x10)|value<<4)
}
func (o *CAC_Type) GetCAICR_FERRFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x10) >> 4
}
func (o *CAC_Type) SetCAICR_MENDFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x20)|value<<5)
}
func (o *CAC_Type) GetCAICR_MENDFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x20) >> 5
}
func (o *CAC_Type) SetCAICR_OVFFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x40)|value<<6)
}
func (o *CAC_Type) GetCAICR_OVFFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x40) >> 6
}

// CAC.CASTR: CAC Status Register
func (o *CAC_Type) SetCASTR_FERRF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCASTR_FERRF() uint8 {
	return volatile.LoadUint8(&o.CASTR.Reg) & 0x1
}
func (o *CAC_Type) SetCASTR_MENDF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x2)|value<<1)
}
func (o *CAC_Type) GetCASTR_MENDF() uint8 {
	return (volatile.LoadUint8(&o.CASTR.Reg) & 0x2) >> 1
}
func (o *CAC_Type) SetCASTR_OVFF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x4)|value<<2)
}
func (o *CAC_Type) GetCASTR_OVFF() uint8 {
	return (volatile.LoadUint8(&o.CASTR.Reg) & 0x4) >> 2
}

// Module Stop Control
type MSTP_Type struct {
	MSTPCRA volatile.Register32 // 0x0
	MSTPCRB volatile.Register32 // 0x4
	MSTPCRC volatile.Register32 // 0x8
	MSTPCRD volatile.Register32 // 0xC
	MSTPCRE volatile.Register32 // 0x10
}

// MSTP.MSTPCRA: Module Stop Control Register A
func (o *MSTP_Type) SetMSTPCRA_MSTPA0(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x1)|value)
}
func (o *MSTP_Type) GetMSTPCRA_MSTPA0() uint32 {
	return volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x1
}
func (o *MSTP_Type) SetMSTPCRA_MSTPA7(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x80)|value<<7)
}
func (o *MSTP_Type) GetMSTPCRA_MSTPA7() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x80) >> 7
}
func (o *MSTP_Type) SetMSTPCRA_MSTPA22(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x400000)|value<<22)
}
func (o *MSTP_Type) GetMSTPCRA_MSTPA22() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x400000) >> 22
}

// MSTP.MSTPCRB: Module Stop Control Register B
func (o *MSTP_Type) SetMSTPCRB_MSTPB2(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB2() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x4) >> 2
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB6(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x40)|value<<6)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB6() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x40) >> 6
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB8(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x100)|value<<8)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB8() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x100) >> 8
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB9(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x200)|value<<9)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB9() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x200) >> 9
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB11(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x800)|value<<11)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB11() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x800) >> 11
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB15(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x8000)|value<<15)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB15() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x8000) >> 15
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB18(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x40000)|value<<18)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB18() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x40000) >> 18
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB19(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x80000)|value<<19)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB19() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x80000) >> 19
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB22(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x400000)|value<<22)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB22() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x400000) >> 22
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB27(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x8000000)|value<<27)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB27() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x8000000) >> 27
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB28(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x10000000)|value<<28)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB28() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x10000000) >> 28
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB29(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x20000000)|value<<29)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB29() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x20000000) >> 29
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB30(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x40000000)|value<<30)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB30() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x40000000) >> 30
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB31(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x80000000)|value<<31)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB31() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x80000000) >> 31
}

// MSTP.MSTPCRC: Module Stop Control Register C
func (o *MSTP_Type) SetMSTPCRC_MSTPC0(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x1)|value)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC0() uint32 {
	return volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x1
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC1(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x2)|value<<1)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC1() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x2) >> 1
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC8(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x100)|value<<8)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC8() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x100) >> 8
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC12(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x1000)|value<<12)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC12() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x1000) >> 12
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC13(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x2000)|value<<13)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC13() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x2000) >> 13
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC14(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x4000)|value<<14)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC14() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x4000) >> 14
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC31(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x80000000)|value<<31)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC31() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x80000000) >> 31
}

// MSTP.MSTPCRD: Module Stop Control Register D
func (o *MSTP_Type) SetMSTPCRD_MSTPD0(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x1)|value)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD0() uint32 {
	return volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x1
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD1(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x2)|value<<1)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD1() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x2) >> 1
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD2(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD2() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x4) >> 2
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD3(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x8)|value<<3)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD3() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x8) >> 3
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD11(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x800)|value<<11)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD11() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x800) >> 11
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD12(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x1000)|value<<12)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD12() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x1000) >> 12
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD13(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x2000)|value<<13)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD13() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x2000) >> 13
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD14(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x4000)|value<<14)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD14() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x4000) >> 14
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD16(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x10000)|value<<16)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD16() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x10000) >> 16
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD20(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x100000)|value<<20)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD20() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x100000) >> 20
}

// MSTP.MSTPCRE: Module Stop Control Register E
func (o *MSTP_Type) SetMSTPCRE_MSTPE14(value uint32) {
	volatile.StoreUint32(&o.MSTPCRE.Reg, volatile.LoadUint32(&o.MSTPCRE.Reg)&^(0x4000)|value<<14)
}
func (o *MSTP_Type) GetMSTPCRE_MSTPE14() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRE.Reg) & 0x4000) >> 14
}
func (o *MSTP_Type) SetMSTPCRE_MSTPE15(value uint32) {
	volatile.StoreUint32(&o.MSTPCRE.Reg, volatile.LoadUint32(&o.MSTPCRE.Reg)&^(0x8000)|value<<15)
}
func (o *MSTP_Type) GetMSTPCRE_MSTPE15() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRE.Reg) & 0x8000) >> 15
}
func (o *MSTP_Type) SetMSTPCRE_MSTPE24(value uint32) {
	volatile.StoreUint32(&o.MSTPCRE.Reg, volatile.LoadUint32(&o.MSTPCRE.Reg)&^(0x1000000)|value<<24)
}
func (o *MSTP_Type) GetMSTPCRE_MSTPE24() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRE.Reg) & 0x1000000) >> 24
}
func (o *MSTP_Type) SetMSTPCRE_MSTPE25(value uint32) {
	volatile.StoreUint32(&o.MSTPCRE.Reg, volatile.LoadUint32(&o.MSTPCRE.Reg)&^(0x2000000)|value<<25)
}
func (o *MSTP_Type) GetMSTPCRE_MSTPE25() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRE.Reg) & 0x2000000) >> 25
}
func (o *MSTP_Type) SetMSTPCRE_MSTPE26(value uint32) {
	volatile.StoreUint32(&o.MSTPCRE.Reg, volatile.LoadUint32(&o.MSTPCRE.Reg)&^(0x4000000)|value<<26)
}
func (o *MSTP_Type) GetMSTPCRE_MSTPE26() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRE.Reg) & 0x4000000) >> 26
}
func (o *MSTP_Type) SetMSTPCRE_MSTPE27(value uint32) {
	volatile.StoreUint32(&o.MSTPCRE.Reg, volatile.LoadUint32(&o.MSTPCRE.Reg)&^(0x8000000)|value<<27)
}
func (o *MSTP_Type) GetMSTPCRE_MSTPE27() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRE.Reg) & 0x8000000) >> 27
}
func (o *MSTP_Type) SetMSTPCRE_MSTPE29(value uint32) {
	volatile.StoreUint32(&o.MSTPCRE.Reg, volatile.LoadUint32(&o.MSTPCRE.Reg)&^(0x20000000)|value<<29)
}
func (o *MSTP_Type) GetMSTPCRE_MSTPE29() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRE.Reg) & 0x20000000) >> 29
}
func (o *MSTP_Type) SetMSTPCRE_MSTPE30(value uint32) {
	volatile.StoreUint32(&o.MSTPCRE.Reg, volatile.LoadUint32(&o.MSTPCRE.Reg)&^(0x40000000)|value<<30)
}
func (o *MSTP_Type) GetMSTPCRE_MSTPE30() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRE.Reg) & 0x40000000) >> 30
}

// Port Output Enable Module for GPT
type POEG_Type struct {
	POEGGA volatile.Register32 // 0x0
	_      [252]byte
	POEGGB volatile.Register32 // 0x100
	_      [252]byte
	POEGGC volatile.Register32 // 0x200
	_      [252]byte
	POEGGD volatile.Register32 // 0x300
}

// POEG.POEGGA: POEG Group A Setting Register
func (o *POEG_Type) SetPOEGGA_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGA_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGA.Reg) & 0x1
}
func (o *POEG_Type) SetPOEGGA_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGA_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGA_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGA_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGA_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGA_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGA_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGA_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGA_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGA_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGA_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGA_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGA_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGA_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGA_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGA_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGA_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGA_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGA_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGA_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0xc0000000) >> 30
}

// POEG.POEGGB: POEG Group B Setting Register
func (o *POEG_Type) SetPOEGGB_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGB_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGB.Reg) & 0x1
}
func (o *POEG_Type) SetPOEGGB_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGB_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGB_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGB_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGB_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGB_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGB_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGB_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGB_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGB_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGB_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGB_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGB_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGB_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGB_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGB_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGB_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGB_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGB_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGB_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0xc0000000) >> 30
}

// POEG.POEGGC: POEG Group C Setting Register
func (o *POEG_Type) SetPOEGGC_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGC_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGC.Reg) & 0x1
}
func (o *POEG_Type) SetPOEGGC_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGC_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGC_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGC_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGC_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGC_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGC_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGC_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGC_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGC_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGC_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGC_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGC_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGC_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGC_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGC_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGC_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGC_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGC_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGC_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0xc0000000) >> 30
}

// POEG.POEGGD: POEG Group D Setting Register
func (o *POEG_Type) SetPOEGGD_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGD_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGD.Reg) & 0x1
}
func (o *POEG_Type) SetPOEGGD_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGD_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGD_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGD_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGD_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGD_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGD_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGD_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGD_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGD_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGD_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGD_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGD_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGD_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGD_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGD_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGD_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGD_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGD_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGD_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0xc0000000) >> 30
}

// USB 2.0 Full-Speed Module
type USBFS_Type struct {
	SYSCFG    volatile.Register16 // 0x0
	_         [2]byte
	SYSSTS0   volatile.Register16 // 0x4
	_         [2]byte
	DVSTCTR0  volatile.Register16 // 0x8
	_         [10]byte
	CFIFO     volatile.Register16 // 0x14
	_         [2]byte
	D0FIFO    volatile.Register16 // 0x18
	_         [2]byte
	D1FIFO    volatile.Register16 // 0x1C
	_         [2]byte
	CFIFOSEL  volatile.Register16 // 0x20
	CFIFOCTR  volatile.Register16 // 0x22
	_         [4]byte
	D0FIFOSEL volatile.Register16 // 0x28
	D0FIFOCTR volatile.Register16 // 0x2A
	D1FIFOSEL volatile.Register16 // 0x2C
	D1FIFOCTR volatile.Register16 // 0x2E
	INTENB0   volatile.Register16 // 0x30
	INTENB1   volatile.Register16 // 0x32
	_         [2]byte
	BRDYENB   volatile.Register16 // 0x36
	NRDYENB   volatile.Register16 // 0x38
	BEMPENB   volatile.Register16 // 0x3A
	SOFCFG    volatile.Register16 // 0x3C
	_         [2]byte
	INTSTS0   volatile.Register16 // 0x40
	INTSTS1   volatile.Register16 // 0x42
	_         [2]byte
	BRDYSTS   volatile.Register16 // 0x46
	NRDYSTS   volatile.Register16 // 0x48
	BEMPSTS   volatile.Register16 // 0x4A
	FRMNUM    volatile.Register16 // 0x4C
	DVCHGR    volatile.Register16 // 0x4E
	USBADDR   volatile.Register16 // 0x50
	_         [2]byte
	USBREQ    volatile.Register16 // 0x54
	USBVAL    volatile.Register16 // 0x56
	USBINDX   volatile.Register16 // 0x58
	USBLENG   volatile.Register16 // 0x5A
	DCPCFG    volatile.Register16 // 0x5C
	DCPMAXP   volatile.Register16 // 0x5E
	DCPCTR    volatile.Register16 // 0x60
	_         [2]byte
	PIPESEL   volatile.Register16 // 0x64
	_         [2]byte
	PIPECFG   volatile.Register16 // 0x68
	_         [2]byte
	PIPEMAXP  volatile.Register16 // 0x6C
	PIPEPERI  volatile.Register16 // 0x6E
	PIPE1CTR  volatile.Register16 // 0x70
	PIPE2CTR  volatile.Register16 // 0x72
	PIPE3CTR  volatile.Register16 // 0x74
	PIPE4CTR  volatile.Register16 // 0x76
	PIPE5CTR  volatile.Register16 // 0x78
	PIPE6CTR  volatile.Register16 // 0x7A
	PIPE7CTR  volatile.Register16 // 0x7C
	PIPE8CTR  volatile.Register16 // 0x7E
	PIPE9CTR  volatile.Register16 // 0x80
	_         [14]byte
	PIPE1TRE  volatile.Register16 // 0x90
	PIPE1TRN  volatile.Register16 // 0x92
	PIPE2TRE  volatile.Register16 // 0x94
	PIPE2TRN  volatile.Register16 // 0x96
	PIPE3TRE  volatile.Register16 // 0x98
	PIPE3TRN  volatile.Register16 // 0x9A
	PIPE4TRE  volatile.Register16 // 0x9C
	PIPE4TRN  volatile.Register16 // 0x9E
	PIPE5TRE  volatile.Register16 // 0xA0
	PIPE5TRN  volatile.Register16 // 0xA2
	_         [12]byte
	BCCTRL1   volatile.Register32 // 0xB0
	BCCTRL2   volatile.Register32 // 0xB4
	_         [24]byte
	DEVADD0   volatile.Register16 // 0xD0
	DEVADD1   volatile.Register16 // 0xD2
	DEVADD2   volatile.Register16 // 0xD4
	DEVADD3   volatile.Register16 // 0xD6
	DEVADD4   volatile.Register16 // 0xD8
	DEVADD5   volatile.Register16 // 0xDA
	_         [24]byte
	PHYSECTRL volatile.Register32 // 0xF4
	_         [776]byte
	DPUSR0R   volatile.Register32 // 0x400
	DPUSR1R   volatile.Register32 // 0x404
}

// USBFS.SYSCFG: System Configuration Control Register
func (o *USBFS_Type) SetSYSCFG_USBE(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetSYSCFG_USBE() uint16 {
	return volatile.LoadUint16(&o.SYSCFG.Reg) & 0x1
}
func (o *USBFS_Type) SetSYSCFG_DPRPU(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetSYSCFG_DPRPU() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetSYSCFG_DRPD(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetSYSCFG_DRPD() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetSYSCFG_DCFM(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetSYSCFG_DCFM() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetSYSCFG_SCKE(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetSYSCFG_SCKE() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x400) >> 10
}

// USBFS.SYSSTS0: System Configuration Status Register 0
func (o *USBFS_Type) SetSYSSTS0_LNST(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetSYSSTS0_LNST() uint16 {
	return volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x3
}
func (o *USBFS_Type) SetSYSSTS0_IDMON(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetSYSSTS0_IDMON() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetSYSSTS0_SOFEA(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetSYSSTS0_SOFEA() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetSYSSTS0_HTACT(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetSYSSTS0_HTACT() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetSYSSTS0_OVCMON(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0xc000)|value<<14)
}
func (o *USBFS_Type) GetSYSSTS0_OVCMON() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0xc000) >> 14
}

// USBFS.DVSTCTR0: Device State Control Register 0
func (o *USBFS_Type) SetDVSTCTR0_RHST(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x7)|value)
}
func (o *USBFS_Type) GetDVSTCTR0_RHST() uint16 {
	return volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x7
}
func (o *USBFS_Type) SetDVSTCTR0_UACT(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetDVSTCTR0_UACT() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetDVSTCTR0_RESUME(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetDVSTCTR0_RESUME() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetDVSTCTR0_USBRST(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetDVSTCTR0_USBRST() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetDVSTCTR0_RWUPE(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetDVSTCTR0_RWUPE() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetDVSTCTR0_WKUP(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetDVSTCTR0_WKUP() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetDVSTCTR0_VBUSEN(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetDVSTCTR0_VBUSEN() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetDVSTCTR0_EXICEN(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetDVSTCTR0_EXICEN() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetDVSTCTR0_HNPBTOA(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetDVSTCTR0_HNPBTOA() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x800) >> 11
}

// USBFS.CFIFO: CFIFO Port Register
func (o *USBFS_Type) SetCFIFO(value uint16) {
	volatile.StoreUint16(&o.CFIFO.Reg, value)
}
func (o *USBFS_Type) GetCFIFO() uint16 {
	return volatile.LoadUint16(&o.CFIFO.Reg)
}

// USBFS.D0FIFO: D%sFIFO Port Register
func (o *USBFS_Type) SetD0FIFO(value uint16) {
	volatile.StoreUint16(&o.D0FIFO.Reg, value)
}
func (o *USBFS_Type) GetD0FIFO() uint16 {
	return volatile.LoadUint16(&o.D0FIFO.Reg)
}

// USBFS.D1FIFO: D%sFIFO Port Register
func (o *USBFS_Type) SetD1FIFO(value uint16) {
	volatile.StoreUint16(&o.D1FIFO.Reg, value)
}
func (o *USBFS_Type) GetD1FIFO() uint16 {
	return volatile.LoadUint16(&o.D1FIFO.Reg)
}

// USBFS.CFIFOSEL: CFIFO Port Select Register
func (o *USBFS_Type) SetCFIFOSEL_CURPIPE(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetCFIFOSEL_CURPIPE() uint16 {
	return volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0xf
}
func (o *USBFS_Type) SetCFIFOSEL_ISEL(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetCFIFOSEL_ISEL() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetCFIFOSEL_BIGEND(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetCFIFOSEL_BIGEND() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetCFIFOSEL_MBW(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetCFIFOSEL_MBW() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetCFIFOSEL_REW(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetCFIFOSEL_REW() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetCFIFOSEL_RCNT(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetCFIFOSEL_RCNT() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x8000) >> 15
}

// USBFS.CFIFOCTR: CFIFO Port Control Register
func (o *USBFS_Type) SetCFIFOCTR_DTLN(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetCFIFOCTR_DTLN() uint16 {
	return volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x1ff
}
func (o *USBFS_Type) SetCFIFOCTR_FRDY(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetCFIFOCTR_FRDY() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetCFIFOCTR_BCLR(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetCFIFOCTR_BCLR() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetCFIFOCTR_BVAL(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetCFIFOCTR_BVAL() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x8000) >> 15
}

// USBFS.D0FIFOSEL: D%sFIFO Port Select Register
func (o *USBFS_Type) SetD0FIFOSEL_CURPIPE(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetD0FIFOSEL_CURPIPE() uint16 {
	return volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0xf
}
func (o *USBFS_Type) SetD0FIFOSEL_BIGEND(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetD0FIFOSEL_BIGEND() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetD0FIFOSEL_MBW(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetD0FIFOSEL_MBW() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetD0FIFOSEL_DREQE(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetD0FIFOSEL_DREQE() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetD0FIFOSEL_DCLRM(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetD0FIFOSEL_DCLRM() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetD0FIFOSEL_REW(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetD0FIFOSEL_REW() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetD0FIFOSEL_RCNT(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetD0FIFOSEL_RCNT() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x8000) >> 15
}

// USBFS.D0FIFOCTR: D%sFIFO Port Control Register
func (o *USBFS_Type) SetD0FIFOCTR_DTLN(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetD0FIFOCTR_DTLN() uint16 {
	return volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x1ff
}
func (o *USBFS_Type) SetD0FIFOCTR_FRDY(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetD0FIFOCTR_FRDY() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetD0FIFOCTR_BCLR(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetD0FIFOCTR_BCLR() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetD0FIFOCTR_BVAL(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetD0FIFOCTR_BVAL() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x8000) >> 15
}

// USBFS.D1FIFOSEL: D%sFIFO Port Select Register
func (o *USBFS_Type) SetD1FIFOSEL_CURPIPE(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetD1FIFOSEL_CURPIPE() uint16 {
	return volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0xf
}
func (o *USBFS_Type) SetD1FIFOSEL_BIGEND(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetD1FIFOSEL_BIGEND() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetD1FIFOSEL_MBW(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetD1FIFOSEL_MBW() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetD1FIFOSEL_DREQE(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetD1FIFOSEL_DREQE() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetD1FIFOSEL_DCLRM(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetD1FIFOSEL_DCLRM() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetD1FIFOSEL_REW(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetD1FIFOSEL_REW() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetD1FIFOSEL_RCNT(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetD1FIFOSEL_RCNT() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x8000) >> 15
}

// USBFS.D1FIFOCTR: D%sFIFO Port Control Register
func (o *USBFS_Type) SetD1FIFOCTR_DTLN(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetD1FIFOCTR_DTLN() uint16 {
	return volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x1ff
}
func (o *USBFS_Type) SetD1FIFOCTR_FRDY(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetD1FIFOCTR_FRDY() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetD1FIFOCTR_BCLR(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetD1FIFOCTR_BCLR() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetD1FIFOCTR_BVAL(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetD1FIFOCTR_BVAL() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x8000) >> 15
}

// USBFS.INTENB0: Interrupt Enable Register 0
func (o *USBFS_Type) SetINTENB0_BRDYE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetINTENB0_BRDYE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetINTENB0_NRDYE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetINTENB0_NRDYE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetINTENB0_BEMPE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetINTENB0_BEMPE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetINTENB0_CTRE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTENB0_CTRE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTENB0_DVSE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTENB0_DVSE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTENB0_SOFE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetINTENB0_SOFE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetINTENB0_RSME(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTENB0_RSME() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTENB0_VBSE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTENB0_VBSE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x8000) >> 15
}

// USBFS.INTENB1: Interrupt Enable Register 1
func (o *USBFS_Type) SetINTENB1_PDDETINTE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetINTENB1_PDDETINTE() uint16 {
	return volatile.LoadUint16(&o.INTENB1.Reg) & 0x1
}
func (o *USBFS_Type) SetINTENB1_SACKE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetINTENB1_SACKE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetINTENB1_SIGNE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetINTENB1_SIGNE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetINTENB1_EOFERRE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetINTENB1_EOFERRE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetINTENB1_ATTCHE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTENB1_ATTCHE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTENB1_DTCHE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTENB1_DTCHE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTENB1_BCHGE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTENB1_BCHGE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTENB1_OVRCRE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTENB1_OVRCRE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x8000) >> 15
}

// USBFS.BRDYENB: BRDY Interrupt Enable Register
func (o *USBFS_Type) SetBRDYENB_PIPE0BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBRDYENB_PIPE0BRDYE() uint16 {
	return volatile.LoadUint16(&o.BRDYENB.Reg) & 0x1
}
func (o *USBFS_Type) SetBRDYENB_PIPE1BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBRDYENB_PIPE1BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBRDYENB_PIPE2BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBRDYENB_PIPE2BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBRDYENB_PIPE3BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBRDYENB_PIPE3BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBRDYENB_PIPE4BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBRDYENB_PIPE4BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBRDYENB_PIPE5BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBRDYENB_PIPE5BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBRDYENB_PIPE6BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBRDYENB_PIPE6BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBRDYENB_PIPE7BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBRDYENB_PIPE7BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBRDYENB_PIPE8BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBRDYENB_PIPE8BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBRDYENB_PIPE9BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBRDYENB_PIPE9BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x200) >> 9
}

// USBFS.NRDYENB: NRDY Interrupt Enable Register
func (o *USBFS_Type) SetNRDYENB_PIPE0NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetNRDYENB_PIPE0NRDYE() uint16 {
	return volatile.LoadUint16(&o.NRDYENB.Reg) & 0x1
}
func (o *USBFS_Type) SetNRDYENB_PIPE1NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetNRDYENB_PIPE1NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetNRDYENB_PIPE2NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetNRDYENB_PIPE2NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetNRDYENB_PIPE3NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetNRDYENB_PIPE3NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetNRDYENB_PIPE4NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetNRDYENB_PIPE4NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetNRDYENB_PIPE5NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetNRDYENB_PIPE5NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetNRDYENB_PIPE6NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetNRDYENB_PIPE6NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetNRDYENB_PIPE7NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetNRDYENB_PIPE7NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetNRDYENB_PIPE8NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetNRDYENB_PIPE8NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetNRDYENB_PIPE9NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetNRDYENB_PIPE9NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x200) >> 9
}

// USBFS.BEMPENB: BEMP Interrupt Enable Register
func (o *USBFS_Type) SetBEMPENB_PIPE0BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBEMPENB_PIPE0BEMPE() uint16 {
	return volatile.LoadUint16(&o.BEMPENB.Reg) & 0x1
}
func (o *USBFS_Type) SetBEMPENB_PIPE1BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBEMPENB_PIPE1BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBEMPENB_PIPE2BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBEMPENB_PIPE2BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBEMPENB_PIPE3BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBEMPENB_PIPE3BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBEMPENB_PIPE4BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBEMPENB_PIPE4BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBEMPENB_PIPE5BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBEMPENB_PIPE5BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBEMPENB_PIPE6BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBEMPENB_PIPE6BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBEMPENB_PIPE7BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBEMPENB_PIPE7BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBEMPENB_PIPE8BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBEMPENB_PIPE8BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBEMPENB_PIPE9BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBEMPENB_PIPE9BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x200) >> 9
}

// USBFS.SOFCFG: SOF Output Configuration Register
func (o *USBFS_Type) SetSOFCFG_EDGESTS(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetSOFCFG_EDGESTS() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetSOFCFG_BRDYM(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetSOFCFG_BRDYM() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetSOFCFG_TRNENSEL(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetSOFCFG_TRNENSEL() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x100) >> 8
}

// USBFS.INTSTS0: Interrupt Status Register 0
func (o *USBFS_Type) SetINTSTS0_CTSQ(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x7)|value)
}
func (o *USBFS_Type) GetINTSTS0_CTSQ() uint16 {
	return volatile.LoadUint16(&o.INTSTS0.Reg) & 0x7
}
func (o *USBFS_Type) SetINTSTS0_VALID(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetINTSTS0_VALID() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetINTSTS0_DVSQ(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x70)|value<<4)
}
func (o *USBFS_Type) GetINTSTS0_DVSQ() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x70) >> 4
}
func (o *USBFS_Type) SetINTSTS0_VBSTS(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetINTSTS0_VBSTS() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetINTSTS0_BRDY(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetINTSTS0_BRDY() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetINTSTS0_NRDY(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetINTSTS0_NRDY() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetINTSTS0_BEMP(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetINTSTS0_BEMP() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetINTSTS0_CTRT(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTSTS0_CTRT() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTSTS0_DVST(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTSTS0_DVST() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTSTS0_SOFR(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetINTSTS0_SOFR() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetINTSTS0_RESM(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTSTS0_RESM() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTSTS0_VBINT(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTSTS0_VBINT() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x8000) >> 15
}

// USBFS.INTSTS1: Interrupt Status Register 1
func (o *USBFS_Type) SetINTSTS1_PDDETINT(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetINTSTS1_PDDETINT() uint16 {
	return volatile.LoadUint16(&o.INTSTS1.Reg) & 0x1
}
func (o *USBFS_Type) SetINTSTS1_SACK(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetINTSTS1_SACK() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetINTSTS1_SIGN(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetINTSTS1_SIGN() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetINTSTS1_EOFERR(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetINTSTS1_EOFERR() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetINTSTS1_ATTCH(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTSTS1_ATTCH() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTSTS1_DTCH(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTSTS1_DTCH() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTSTS1_BCHG(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTSTS1_BCHG() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTSTS1_OVRCR(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTSTS1_OVRCR() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x8000) >> 15
}

// USBFS.BRDYSTS: BRDY Interrupt Status Register
func (o *USBFS_Type) SetBRDYSTS_PIPE0BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE0BRDY() uint16 {
	return volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x1
}
func (o *USBFS_Type) SetBRDYSTS_PIPE1BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE1BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBRDYSTS_PIPE2BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE2BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBRDYSTS_PIPE3BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE3BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBRDYSTS_PIPE4BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE4BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBRDYSTS_PIPE5BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE5BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBRDYSTS_PIPE6BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE6BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBRDYSTS_PIPE7BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE7BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBRDYSTS_PIPE8BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE8BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBRDYSTS_PIPE9BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE9BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x200) >> 9
}

// USBFS.NRDYSTS: NRDY Interrupt Status Register
func (o *USBFS_Type) SetNRDYSTS_PIPE0NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE0NRDY() uint16 {
	return volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x1
}
func (o *USBFS_Type) SetNRDYSTS_PIPE1NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE1NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetNRDYSTS_PIPE2NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE2NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetNRDYSTS_PIPE3NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE3NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetNRDYSTS_PIPE4NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE4NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetNRDYSTS_PIPE5NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE5NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetNRDYSTS_PIPE6NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE6NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetNRDYSTS_PIPE7NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE7NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetNRDYSTS_PIPE8NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE8NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetNRDYSTS_PIPE9NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE9NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x200) >> 9
}

// USBFS.BEMPSTS: BEMP Interrupt Status Register
func (o *USBFS_Type) SetBEMPSTS_PIPE0BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE0BEMP() uint16 {
	return volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x1
}
func (o *USBFS_Type) SetBEMPSTS_PIPE1BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE1BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBEMPSTS_PIPE2BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE2BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBEMPSTS_PIPE3BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE3BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBEMPSTS_PIPE4BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE4BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBEMPSTS_PIPE5BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE5BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBEMPSTS_PIPE6BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE6BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBEMPSTS_PIPE7BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE7BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBEMPSTS_PIPE8BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE8BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBEMPSTS_PIPE9BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE9BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x200) >> 9
}

// USBFS.FRMNUM: Frame Number Register
func (o *USBFS_Type) SetFRMNUM_FRNM(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x7ff)|value)
}
func (o *USBFS_Type) GetFRMNUM_FRNM() uint16 {
	return volatile.LoadUint16(&o.FRMNUM.Reg) & 0x7ff
}
func (o *USBFS_Type) SetFRMNUM_CRCE(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetFRMNUM_CRCE() uint16 {
	return (volatile.LoadUint16(&o.FRMNUM.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetFRMNUM_OVRN(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetFRMNUM_OVRN() uint16 {
	return (volatile.LoadUint16(&o.FRMNUM.Reg) & 0x8000) >> 15
}

// USBFS.DVCHGR: Device State Change Register
func (o *USBFS_Type) SetDVCHGR_DVCHG(value uint16) {
	volatile.StoreUint16(&o.DVCHGR.Reg, volatile.LoadUint16(&o.DVCHGR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetDVCHGR_DVCHG() uint16 {
	return (volatile.LoadUint16(&o.DVCHGR.Reg) & 0x8000) >> 15
}

// USBFS.USBADDR: USB Address Register
func (o *USBFS_Type) SetUSBADDR(value uint16) {
	volatile.StoreUint16(&o.USBADDR.Reg, volatile.LoadUint16(&o.USBADDR.Reg)&^(0x7f)|value)
}
func (o *USBFS_Type) GetUSBADDR() uint16 {
	return volatile.LoadUint16(&o.USBADDR.Reg) & 0x7f
}
func (o *USBFS_Type) SetUSBADDR_STSRECOV(value uint16) {
	volatile.StoreUint16(&o.USBADDR.Reg, volatile.LoadUint16(&o.USBADDR.Reg)&^(0xf00)|value<<8)
}
func (o *USBFS_Type) GetUSBADDR_STSRECOV() uint16 {
	return (volatile.LoadUint16(&o.USBADDR.Reg) & 0xf00) >> 8
}

// USBFS.USBREQ: USB Request Type Register
func (o *USBFS_Type) SetUSBREQ_BMREQUESTTYPE(value uint16) {
	volatile.StoreUint16(&o.USBREQ.Reg, volatile.LoadUint16(&o.USBREQ.Reg)&^(0xff)|value)
}
func (o *USBFS_Type) GetUSBREQ_BMREQUESTTYPE() uint16 {
	return volatile.LoadUint16(&o.USBREQ.Reg) & 0xff
}
func (o *USBFS_Type) SetUSBREQ_BREQUEST(value uint16) {
	volatile.StoreUint16(&o.USBREQ.Reg, volatile.LoadUint16(&o.USBREQ.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetUSBREQ_BREQUEST() uint16 {
	return (volatile.LoadUint16(&o.USBREQ.Reg) & 0xff00) >> 8
}

// USBFS.USBVAL: USB Request Value Register
func (o *USBFS_Type) SetUSBVAL(value uint16) {
	volatile.StoreUint16(&o.USBVAL.Reg, value)
}
func (o *USBFS_Type) GetUSBVAL() uint16 {
	return volatile.LoadUint16(&o.USBVAL.Reg)
}

// USBFS.USBINDX: USB Request Index Register
func (o *USBFS_Type) SetUSBINDX(value uint16) {
	volatile.StoreUint16(&o.USBINDX.Reg, value)
}
func (o *USBFS_Type) GetUSBINDX() uint16 {
	return volatile.LoadUint16(&o.USBINDX.Reg)
}

// USBFS.USBLENG: USB Request Length Register
func (o *USBFS_Type) SetUSBLENG(value uint16) {
	volatile.StoreUint16(&o.USBLENG.Reg, value)
}
func (o *USBFS_Type) GetUSBLENG() uint16 {
	return volatile.LoadUint16(&o.USBLENG.Reg)
}

// USBFS.DCPCFG: DCP Configuration Register
func (o *USBFS_Type) SetDCPCFG_DIR(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetDCPCFG_DIR() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetDCPCFG_SHTNAK(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetDCPCFG_SHTNAK() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0x80) >> 7
}

// USBFS.DCPMAXP: DCP Maximum Packet Size Register
func (o *USBFS_Type) SetDCPMAXP_MXPS(value uint16) {
	volatile.StoreUint16(&o.DCPMAXP.Reg, volatile.LoadUint16(&o.DCPMAXP.Reg)&^(0x7f)|value)
}
func (o *USBFS_Type) GetDCPMAXP_MXPS() uint16 {
	return volatile.LoadUint16(&o.DCPMAXP.Reg) & 0x7f
}
func (o *USBFS_Type) SetDCPMAXP_DEVSEL(value uint16) {
	volatile.StoreUint16(&o.DCPMAXP.Reg, volatile.LoadUint16(&o.DCPMAXP.Reg)&^(0xf000)|value<<12)
}
func (o *USBFS_Type) GetDCPMAXP_DEVSEL() uint16 {
	return (volatile.LoadUint16(&o.DCPMAXP.Reg) & 0xf000) >> 12
}

// USBFS.DCPCTR: DCP Control Register
func (o *USBFS_Type) SetDCPCTR_PID(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetDCPCTR_PID() uint16 {
	return volatile.LoadUint16(&o.DCPCTR.Reg) & 0x3
}
func (o *USBFS_Type) SetDCPCTR_CCPL(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetDCPCTR_CCPL() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetDCPCTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetDCPCTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetDCPCTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetDCPCTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetDCPCTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetDCPCTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetDCPCTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetDCPCTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetDCPCTR_SUREQCLR(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetDCPCTR_SUREQCLR() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetDCPCTR_SUREQ(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetDCPCTR_SUREQ() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetDCPCTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetDCPCTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x8000) >> 15
}

// USBFS.PIPESEL: Pipe Window Select Register
func (o *USBFS_Type) SetPIPESEL(value uint16) {
	volatile.StoreUint16(&o.PIPESEL.Reg, volatile.LoadUint16(&o.PIPESEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetPIPESEL() uint16 {
	return volatile.LoadUint16(&o.PIPESEL.Reg) & 0xf
}

// USBFS.PIPECFG: Pipe Configuration Register
func (o *USBFS_Type) SetPIPECFG_EPNUM(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetPIPECFG_EPNUM() uint16 {
	return volatile.LoadUint16(&o.PIPECFG.Reg) & 0xf
}
func (o *USBFS_Type) SetPIPECFG_DIR(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetPIPECFG_DIR() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetPIPECFG_SHTNAK(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPECFG_SHTNAK() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPECFG_DBLB(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPECFG_DBLB() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPECFG_BFRE(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPECFG_BFRE() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPECFG_TYPE(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0xc000)|value<<14)
}
func (o *USBFS_Type) GetPIPECFG_TYPE() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0xc000) >> 14
}

// USBFS.PIPEMAXP: Pipe Maximum Packet Size Register
func (o *USBFS_Type) SetPIPEMAXP_MXPS(value uint16) {
	volatile.StoreUint16(&o.PIPEMAXP.Reg, volatile.LoadUint16(&o.PIPEMAXP.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetPIPEMAXP_MXPS() uint16 {
	return volatile.LoadUint16(&o.PIPEMAXP.Reg) & 0x1ff
}
func (o *USBFS_Type) SetPIPEMAXP_DEVSEL(value uint16) {
	volatile.StoreUint16(&o.PIPEMAXP.Reg, volatile.LoadUint16(&o.PIPEMAXP.Reg)&^(0xf000)|value<<12)
}
func (o *USBFS_Type) GetPIPEMAXP_DEVSEL() uint16 {
	return (volatile.LoadUint16(&o.PIPEMAXP.Reg) & 0xf000) >> 12
}

// USBFS.PIPEPERI: Pipe Cycle Control Register
func (o *USBFS_Type) SetPIPEPERI_IITV(value uint16) {
	volatile.StoreUint16(&o.PIPEPERI.Reg, volatile.LoadUint16(&o.PIPEPERI.Reg)&^(0x7)|value)
}
func (o *USBFS_Type) GetPIPEPERI_IITV() uint16 {
	return volatile.LoadUint16(&o.PIPEPERI.Reg) & 0x7
}
func (o *USBFS_Type) SetPIPEPERI_IFIS(value uint16) {
	volatile.StoreUint16(&o.PIPEPERI.Reg, volatile.LoadUint16(&o.PIPEPERI.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetPIPEPERI_IFIS() uint16 {
	return (volatile.LoadUint16(&o.PIPEPERI.Reg) & 0x1000) >> 12
}

// USBFS.PIPE1CTR: PIPE%s Control Registers
func (o *USBFS_Type) SetPIPE1CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE1CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x3
}
func (o *USBFS_Type) SetPIPE1CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE1CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE1CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE1CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE1CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE1CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE1CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE1CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE1CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE1CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE1CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE1CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE1CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE1CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE1CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE1CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x8000) >> 15
}

// USBFS.PIPE2CTR: PIPE%s Control Registers
func (o *USBFS_Type) SetPIPE2CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE2CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x3
}
func (o *USBFS_Type) SetPIPE2CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE2CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE2CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE2CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE2CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE2CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE2CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE2CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE2CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE2CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE2CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE2CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE2CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE2CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE2CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE2CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x8000) >> 15
}

// USBFS.PIPE3CTR: PIPE%s Control Registers
func (o *USBFS_Type) SetPIPE3CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE3CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x3
}
func (o *USBFS_Type) SetPIPE3CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE3CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE3CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE3CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE3CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE3CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE3CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE3CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE3CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE3CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE3CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE3CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE3CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE3CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE3CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE3CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x8000) >> 15
}

// USBFS.PIPE4CTR: PIPE%s Control Registers
func (o *USBFS_Type) SetPIPE4CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE4CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x3
}
func (o *USBFS_Type) SetPIPE4CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE4CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE4CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE4CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE4CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE4CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE4CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE4CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE4CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE4CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE4CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE4CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE4CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE4CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE4CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE4CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x8000) >> 15
}

// USBFS.PIPE5CTR: PIPE%s Control Registers
func (o *USBFS_Type) SetPIPE5CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE5CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x3
}
func (o *USBFS_Type) SetPIPE5CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE5CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE5CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE5CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE5CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE5CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE5CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE5CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE5CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE5CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE5CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE5CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE5CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE5CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE5CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE5CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x8000) >> 15
}

// USBFS.PIPE6CTR: PIPE%s Control Registers
func (o *USBFS_Type) SetPIPE6CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE6CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x3
}
func (o *USBFS_Type) SetPIPE6CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE6CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE6CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE6CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE6CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE6CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE6CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE6CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE6CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE6CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE6CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE6CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x8000) >> 15
}

// USBFS.PIPE7CTR: PIPE%s Control Registers
func (o *USBFS_Type) SetPIPE7CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE7CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x3
}
func (o *USBFS_Type) SetPIPE7CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE7CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE7CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE7CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE7CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE7CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE7CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE7CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE7CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE7CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE7CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE7CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x8000) >> 15
}

// USBFS.PIPE8CTR: PIPE%s Control Registers
func (o *USBFS_Type) SetPIPE8CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE8CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x3
}
func (o *USBFS_Type) SetPIPE8CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE8CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE8CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE8CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE8CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE8CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE8CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE8CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE8CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE8CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE8CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE8CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x8000) >> 15
}

// USBFS.PIPE9CTR: PIPE%s Control Registers
func (o *USBFS_Type) SetPIPE9CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE9CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x3
}
func (o *USBFS_Type) SetPIPE9CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE9CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE9CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE9CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE9CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE9CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE9CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE9CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE9CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE9CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE9CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE9CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x8000) >> 15
}

// USBFS.PIPE1TRE: PIPE%s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE1TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRE.Reg, volatile.LoadUint16(&o.PIPE1TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE1TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE1TRE.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE1TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRE.Reg, volatile.LoadUint16(&o.PIPE1TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE1TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE1TRE.Reg) & 0x200) >> 9
}

// USBFS.PIPE1TRN: PIPE%s Transaction Counter Register
func (o *USBFS_Type) SetPIPE1TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE1TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE1TRN.Reg)
}

// USBFS.PIPE2TRE: PIPE%s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE2TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRE.Reg, volatile.LoadUint16(&o.PIPE2TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE2TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE2TRE.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE2TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRE.Reg, volatile.LoadUint16(&o.PIPE2TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE2TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE2TRE.Reg) & 0x200) >> 9
}

// USBFS.PIPE2TRN: PIPE%s Transaction Counter Register
func (o *USBFS_Type) SetPIPE2TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE2TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE2TRN.Reg)
}

// USBFS.PIPE3TRE: PIPE%s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE3TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRE.Reg, volatile.LoadUint16(&o.PIPE3TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE3TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE3TRE.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE3TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRE.Reg, volatile.LoadUint16(&o.PIPE3TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE3TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE3TRE.Reg) & 0x200) >> 9
}

// USBFS.PIPE3TRN: PIPE%s Transaction Counter Register
func (o *USBFS_Type) SetPIPE3TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE3TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE3TRN.Reg)
}

// USBFS.PIPE4TRE: PIPE%s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE4TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE4TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE4TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE4TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0x200) >> 9
}

// USBFS.PIPE4TRN: PIPE%s Transaction Counter Register
func (o *USBFS_Type) SetPIPE4TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE4TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE4TRN.Reg)
}

// USBFS.PIPE5TRE: PIPE%s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE5TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE5TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE5TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE5TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0x200) >> 9
}

// USBFS.PIPE5TRN: PIPE%s Transaction Counter Register
func (o *USBFS_Type) SetPIPE5TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE5TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE5TRN.Reg)
}

// USBFS.BCCTRL1: Battery Charging Control Register 1
func (o *USBFS_Type) SetBCCTRL1_RPDME(value uint32) {
	volatile.StoreUint32(&o.BCCTRL1.Reg, volatile.LoadUint32(&o.BCCTRL1.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBCCTRL1_RPDME() uint32 {
	return volatile.LoadUint32(&o.BCCTRL1.Reg) & 0x1
}
func (o *USBFS_Type) SetBCCTRL1_IDPSRCE(value uint32) {
	volatile.StoreUint32(&o.BCCTRL1.Reg, volatile.LoadUint32(&o.BCCTRL1.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBCCTRL1_IDPSRCE() uint32 {
	return (volatile.LoadUint32(&o.BCCTRL1.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBCCTRL1_VDMSRCE(value uint32) {
	volatile.StoreUint32(&o.BCCTRL1.Reg, volatile.LoadUint32(&o.BCCTRL1.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBCCTRL1_VDMSRCE() uint32 {
	return (volatile.LoadUint32(&o.BCCTRL1.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBCCTRL1_VDPSRCE(value uint32) {
	volatile.StoreUint32(&o.BCCTRL1.Reg, volatile.LoadUint32(&o.BCCTRL1.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBCCTRL1_VDPSRCE() uint32 {
	return (volatile.LoadUint32(&o.BCCTRL1.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBCCTRL1_PDDETE(value uint32) {
	volatile.StoreUint32(&o.BCCTRL1.Reg, volatile.LoadUint32(&o.BCCTRL1.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBCCTRL1_PDDETE() uint32 {
	return (volatile.LoadUint32(&o.BCCTRL1.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBCCTRL1_CHGDETE(value uint32) {
	volatile.StoreUint32(&o.BCCTRL1.Reg, volatile.LoadUint32(&o.BCCTRL1.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBCCTRL1_CHGDETE() uint32 {
	return (volatile.LoadUint32(&o.BCCTRL1.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBCCTRL1_PDDETSTS(value uint32) {
	volatile.StoreUint32(&o.BCCTRL1.Reg, volatile.LoadUint32(&o.BCCTRL1.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBCCTRL1_PDDETSTS() uint32 {
	return (volatile.LoadUint32(&o.BCCTRL1.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBCCTRL1_CHGDETSTS(value uint32) {
	volatile.StoreUint32(&o.BCCTRL1.Reg, volatile.LoadUint32(&o.BCCTRL1.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBCCTRL1_CHGDETSTS() uint32 {
	return (volatile.LoadUint32(&o.BCCTRL1.Reg) & 0x200) >> 9
}

// USBFS.BCCTRL2: Battery Charging Control Register 2
func (o *USBFS_Type) SetBCCTRL2_DCPMODE(value uint32) {
	volatile.StoreUint32(&o.BCCTRL2.Reg, volatile.LoadUint32(&o.BCCTRL2.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBCCTRL2_DCPMODE() uint32 {
	return (volatile.LoadUint32(&o.BCCTRL2.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBCCTRL2_BATCHGE(value uint32) {
	volatile.StoreUint32(&o.BCCTRL2.Reg, volatile.LoadUint32(&o.BCCTRL2.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBCCTRL2_BATCHGE() uint32 {
	return (volatile.LoadUint32(&o.BCCTRL2.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBCCTRL2_PHYDET(value uint32) {
	volatile.StoreUint32(&o.BCCTRL2.Reg, volatile.LoadUint32(&o.BCCTRL2.Reg)&^(0x3000)|value<<12)
}
func (o *USBFS_Type) GetBCCTRL2_PHYDET() uint32 {
	return (volatile.LoadUint32(&o.BCCTRL2.Reg) & 0x3000) >> 12
}

// USBFS.DEVADD0: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD0_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD0.Reg, volatile.LoadUint16(&o.DEVADD0.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD0_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD0.Reg) & 0xc0) >> 6
}

// USBFS.DEVADD1: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD1_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD1.Reg, volatile.LoadUint16(&o.DEVADD1.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD1_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD1.Reg) & 0xc0) >> 6
}

// USBFS.DEVADD2: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD2_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD2.Reg, volatile.LoadUint16(&o.DEVADD2.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD2_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD2.Reg) & 0xc0) >> 6
}

// USBFS.DEVADD3: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD3_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD3.Reg, volatile.LoadUint16(&o.DEVADD3.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD3_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD3.Reg) & 0xc0) >> 6
}

// USBFS.DEVADD4: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD4_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD4.Reg, volatile.LoadUint16(&o.DEVADD4.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD4_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD4.Reg) & 0xc0) >> 6
}

// USBFS.DEVADD5: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD5_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD5.Reg, volatile.LoadUint16(&o.DEVADD5.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD5_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD5.Reg) & 0xc0) >> 6
}

// USBFS.PHYSECTRL: PHY Single-ended Receiver Control Register
func (o *USBFS_Type) SetPHYSECTRL_CNEN(value uint32) {
	volatile.StoreUint32(&o.PHYSECTRL.Reg, volatile.LoadUint32(&o.PHYSECTRL.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetPHYSECTRL_CNEN() uint32 {
	return (volatile.LoadUint32(&o.PHYSECTRL.Reg) & 0x10) >> 4
}

// USBFS.DPUSR0R: Deep Software Standby USB Transceiver Control/Pin Monitor Register
func (o *USBFS_Type) SetDPUSR0R_SRPC0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetDPUSR0R_SRPC0() uint32 {
	return volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x1
}
func (o *USBFS_Type) SetDPUSR0R_RPUE0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetDPUSR0R_RPUE0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetDPUSR0R_DRPD0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetDPUSR0R_DRPD0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetDPUSR0R_FIXPHY0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetDPUSR0R_FIXPHY0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetDPUSR0R_DP0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x10000)|value<<16)
}
func (o *USBFS_Type) GetDPUSR0R_DP0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x10000) >> 16
}
func (o *USBFS_Type) SetDPUSR0R_DM0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x20000)|value<<17)
}
func (o *USBFS_Type) GetDPUSR0R_DM0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x20000) >> 17
}
func (o *USBFS_Type) SetDPUSR0R_DOVCA0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x100000)|value<<20)
}
func (o *USBFS_Type) GetDPUSR0R_DOVCA0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x100000) >> 20
}
func (o *USBFS_Type) SetDPUSR0R_DOVCB0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x200000)|value<<21)
}
func (o *USBFS_Type) GetDPUSR0R_DOVCB0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x200000) >> 21
}
func (o *USBFS_Type) SetDPUSR0R_DVBSTS0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x800000)|value<<23)
}
func (o *USBFS_Type) GetDPUSR0R_DVBSTS0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x800000) >> 23
}

// USBFS.DPUSR1R: Deep Software Standby USB Suspend/Resume Interrupt Register
func (o *USBFS_Type) SetDPUSR1R_DPINTE0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetDPUSR1R_DPINTE0() uint32 {
	return volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x1
}
func (o *USBFS_Type) SetDPUSR1R_DMINTE0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetDPUSR1R_DMINTE0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetDPUSR1R_DOVRCRAE0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetDPUSR1R_DOVRCRAE0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetDPUSR1R_DOVRCRBE0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetDPUSR1R_DOVRCRBE0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetDPUSR1R_DVBSE0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetDPUSR1R_DVBSE0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetDPUSR1R_DPINT0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x10000)|value<<16)
}
func (o *USBFS_Type) GetDPUSR1R_DPINT0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x10000) >> 16
}
func (o *USBFS_Type) SetDPUSR1R_DMINT0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x20000)|value<<17)
}
func (o *USBFS_Type) GetDPUSR1R_DMINT0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x20000) >> 17
}
func (o *USBFS_Type) SetDPUSR1R_DOVRCRA0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x100000)|value<<20)
}
func (o *USBFS_Type) GetDPUSR1R_DOVRCRA0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x100000) >> 20
}
func (o *USBFS_Type) SetDPUSR1R_DOVRCRB0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x200000)|value<<21)
}
func (o *USBFS_Type) GetDPUSR1R_DOVRCRB0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x200000) >> 21
}
func (o *USBFS_Type) SetDPUSR1R_DVBINT0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x800000)|value<<23)
}
func (o *USBFS_Type) GetDPUSR1R_DVBINT0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x800000) >> 23
}

// SD Host Interface 0
type SDHI0_Type struct {
	SD_CMD          volatile.Register32 // 0x0
	_               [4]byte
	SD_ARG          volatile.Register32 // 0x8
	SD_ARG1         volatile.Register32 // 0xC
	SD_STOP         volatile.Register32 // 0x10
	SD_SECCNT       volatile.Register32 // 0x14
	SD_RSP10        volatile.Register32 // 0x18
	SD_RSP1         volatile.Register32 // 0x1C
	SD_RSP32        volatile.Register32 // 0x20
	SD_RSP3         volatile.Register32 // 0x24
	SD_RSP54        volatile.Register32 // 0x28
	SD_RSP5         volatile.Register32 // 0x2C
	SD_RSP76        volatile.Register32 // 0x30
	SD_RSP7         volatile.Register32 // 0x34
	SD_INFO1        volatile.Register32 // 0x38
	SD_INFO2        volatile.Register32 // 0x3C
	SD_INFO1_MASK   volatile.Register32 // 0x40
	SD_INFO2_MASK   volatile.Register32 // 0x44
	SD_CLK_CTRL     volatile.Register32 // 0x48
	SD_SIZE         volatile.Register32 // 0x4C
	SD_OPTION       volatile.Register32 // 0x50
	_               [4]byte
	SD_ERR_STS1     volatile.Register32 // 0x58
	SD_ERR_STS2     volatile.Register32 // 0x5C
	SD_BUF0         volatile.Register32 // 0x60
	_               [4]byte
	SDIO_MODE       volatile.Register32 // 0x68
	SDIO_INFO1      volatile.Register32 // 0x6C
	SDIO_INFO1_MASK volatile.Register32 // 0x70
	_               [316]byte
	SD_DMAEN        volatile.Register32 // 0x1B0
	_               [12]byte
	SOFT_RST        volatile.Register32 // 0x1C0
	_               [8]byte
	SDIF_MODE       volatile.Register32 // 0x1CC
	_               [16]byte
	EXT_SWAP        volatile.Register32 // 0x1E0
}

// SDHI0.SD_CMD: Command Type Register
func (o *SDHI0_Type) SetSD_CMD_CMDIDX(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0x3f)|value)
}
func (o *SDHI0_Type) GetSD_CMD_CMDIDX() uint32 {
	return volatile.LoadUint32(&o.SD_CMD.Reg) & 0x3f
}
func (o *SDHI0_Type) SetSD_CMD_ACMD(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0xc0)|value<<6)
}
func (o *SDHI0_Type) GetSD_CMD_ACMD() uint32 {
	return (volatile.LoadUint32(&o.SD_CMD.Reg) & 0xc0) >> 6
}
func (o *SDHI0_Type) SetSD_CMD_RSPTP(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0x700)|value<<8)
}
func (o *SDHI0_Type) GetSD_CMD_RSPTP() uint32 {
	return (volatile.LoadUint32(&o.SD_CMD.Reg) & 0x700) >> 8
}
func (o *SDHI0_Type) SetSD_CMD_CMDTP(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0x800)|value<<11)
}
func (o *SDHI0_Type) GetSD_CMD_CMDTP() uint32 {
	return (volatile.LoadUint32(&o.SD_CMD.Reg) & 0x800) >> 11
}
func (o *SDHI0_Type) SetSD_CMD_CMDRW(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0x1000)|value<<12)
}
func (o *SDHI0_Type) GetSD_CMD_CMDRW() uint32 {
	return (volatile.LoadUint32(&o.SD_CMD.Reg) & 0x1000) >> 12
}
func (o *SDHI0_Type) SetSD_CMD_TRSTP(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0x2000)|value<<13)
}
func (o *SDHI0_Type) GetSD_CMD_TRSTP() uint32 {
	return (volatile.LoadUint32(&o.SD_CMD.Reg) & 0x2000) >> 13
}
func (o *SDHI0_Type) SetSD_CMD_CMD12AT(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0xc000)|value<<14)
}
func (o *SDHI0_Type) GetSD_CMD_CMD12AT() uint32 {
	return (volatile.LoadUint32(&o.SD_CMD.Reg) & 0xc000) >> 14
}

// SDHI0.SD_STOP: Data Stop Register
func (o *SDHI0_Type) SetSD_STOP_STP(value uint32) {
	volatile.StoreUint32(&o.SD_STOP.Reg, volatile.LoadUint32(&o.SD_STOP.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_STOP_STP() uint32 {
	return volatile.LoadUint32(&o.SD_STOP.Reg) & 0x1
}
func (o *SDHI0_Type) SetSD_STOP_SEC(value uint32) {
	volatile.StoreUint32(&o.SD_STOP.Reg, volatile.LoadUint32(&o.SD_STOP.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_STOP_SEC() uint32 {
	return (volatile.LoadUint32(&o.SD_STOP.Reg) & 0x100) >> 8
}

// SDHI0.SD_RSP76: SD Card Response Register 76
func (o *SDHI0_Type) SetSD_RSP76(value uint32) {
	volatile.StoreUint32(&o.SD_RSP76.Reg, volatile.LoadUint32(&o.SD_RSP76.Reg)&^(0xffffff)|value)
}
func (o *SDHI0_Type) GetSD_RSP76() uint32 {
	return volatile.LoadUint32(&o.SD_RSP76.Reg) & 0xffffff
}

// SDHI0.SD_RSP7: SD Card Response Register 7
func (o *SDHI0_Type) SetSD_RSP7(value uint32) {
	volatile.StoreUint32(&o.SD_RSP7.Reg, volatile.LoadUint32(&o.SD_RSP7.Reg)&^(0xff)|value)
}
func (o *SDHI0_Type) GetSD_RSP7() uint32 {
	return volatile.LoadUint32(&o.SD_RSP7.Reg) & 0xff
}

// SDHI0.SD_INFO1: SD Card Interrupt Flag Register 1
func (o *SDHI0_Type) SetSD_INFO1_RSPEND(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_INFO1_RSPEND() uint32 {
	return volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x1
}
func (o *SDHI0_Type) SetSD_INFO1_ACEND(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSD_INFO1_ACEND() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSD_INFO1_SDCDRM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x8)|value<<3)
}
func (o *SDHI0_Type) GetSD_INFO1_SDCDRM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x8) >> 3
}
func (o *SDHI0_Type) SetSD_INFO1_SDCDIN(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x10)|value<<4)
}
func (o *SDHI0_Type) GetSD_INFO1_SDCDIN() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x10) >> 4
}
func (o *SDHI0_Type) SetSD_INFO1_SDCDMON(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x20)|value<<5)
}
func (o *SDHI0_Type) GetSD_INFO1_SDCDMON() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x20) >> 5
}
func (o *SDHI0_Type) SetSD_INFO1_SDWPMON(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x80)|value<<7)
}
func (o *SDHI0_Type) GetSD_INFO1_SDWPMON() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x80) >> 7
}
func (o *SDHI0_Type) SetSD_INFO1_SDD3RM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_INFO1_SDD3RM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_INFO1_SDD3IN(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSD_INFO1_SDD3IN() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x200) >> 9
}
func (o *SDHI0_Type) SetSD_INFO1_SDD3MON(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x400)|value<<10)
}
func (o *SDHI0_Type) GetSD_INFO1_SDD3MON() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x400) >> 10
}

// SDHI0.SD_INFO2: SD Card Interrupt Flag Register 2
func (o *SDHI0_Type) SetSD_INFO2_CMDE(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_INFO2_CMDE() uint32 {
	return volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x1
}
func (o *SDHI0_Type) SetSD_INFO2_CRCE(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x2)|value<<1)
}
func (o *SDHI0_Type) GetSD_INFO2_CRCE() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x2) >> 1
}
func (o *SDHI0_Type) SetSD_INFO2_ENDE(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSD_INFO2_ENDE() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSD_INFO2_DTO(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x8)|value<<3)
}
func (o *SDHI0_Type) GetSD_INFO2_DTO() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x8) >> 3
}
func (o *SDHI0_Type) SetSD_INFO2_ILW(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x10)|value<<4)
}
func (o *SDHI0_Type) GetSD_INFO2_ILW() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x10) >> 4
}
func (o *SDHI0_Type) SetSD_INFO2_ILR(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x20)|value<<5)
}
func (o *SDHI0_Type) GetSD_INFO2_ILR() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x20) >> 5
}
func (o *SDHI0_Type) SetSD_INFO2_RSPTO(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x40)|value<<6)
}
func (o *SDHI0_Type) GetSD_INFO2_RSPTO() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x40) >> 6
}
func (o *SDHI0_Type) SetSD_INFO2_SDD0MON(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x80)|value<<7)
}
func (o *SDHI0_Type) GetSD_INFO2_SDD0MON() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x80) >> 7
}
func (o *SDHI0_Type) SetSD_INFO2_BRE(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_INFO2_BRE() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_INFO2_BWE(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSD_INFO2_BWE() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x200) >> 9
}
func (o *SDHI0_Type) SetSD_INFO2_SD_CLK_CTRLEN(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x2000)|value<<13)
}
func (o *SDHI0_Type) GetSD_INFO2_SD_CLK_CTRLEN() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x2000) >> 13
}
func (o *SDHI0_Type) SetSD_INFO2_CBSY(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x4000)|value<<14)
}
func (o *SDHI0_Type) GetSD_INFO2_CBSY() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x4000) >> 14
}
func (o *SDHI0_Type) SetSD_INFO2_ILA(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x8000)|value<<15)
}
func (o *SDHI0_Type) GetSD_INFO2_ILA() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x8000) >> 15
}

// SDHI0.SD_INFO1_MASK: SD INFO1 Interrupt Mask Register
func (o *SDHI0_Type) SetSD_INFO1_MASK_RSPENDM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1_MASK.Reg, volatile.LoadUint32(&o.SD_INFO1_MASK.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_INFO1_MASK_RSPENDM() uint32 {
	return volatile.LoadUint32(&o.SD_INFO1_MASK.Reg) & 0x1
}
func (o *SDHI0_Type) SetSD_INFO1_MASK_ACENDM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1_MASK.Reg, volatile.LoadUint32(&o.SD_INFO1_MASK.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSD_INFO1_MASK_ACENDM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1_MASK.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSD_INFO1_MASK_SDCDRMM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1_MASK.Reg, volatile.LoadUint32(&o.SD_INFO1_MASK.Reg)&^(0x8)|value<<3)
}
func (o *SDHI0_Type) GetSD_INFO1_MASK_SDCDRMM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1_MASK.Reg) & 0x8) >> 3
}
func (o *SDHI0_Type) SetSD_INFO1_MASK_SDCDINM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1_MASK.Reg, volatile.LoadUint32(&o.SD_INFO1_MASK.Reg)&^(0x10)|value<<4)
}
func (o *SDHI0_Type) GetSD_INFO1_MASK_SDCDINM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1_MASK.Reg) & 0x10) >> 4
}
func (o *SDHI0_Type) SetSD_INFO1_MASK_SDD3RMM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1_MASK.Reg, volatile.LoadUint32(&o.SD_INFO1_MASK.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_INFO1_MASK_SDD3RMM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1_MASK.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_INFO1_MASK_SDD3INM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1_MASK.Reg, volatile.LoadUint32(&o.SD_INFO1_MASK.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSD_INFO1_MASK_SDD3INM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1_MASK.Reg) & 0x200) >> 9
}

// SDHI0.SD_INFO2_MASK: SD INFO2 Interrupt Mask Register
func (o *SDHI0_Type) SetSD_INFO2_MASK_CMDEM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_CMDEM() uint32 {
	return volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x1
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_CRCEM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x2)|value<<1)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_CRCEM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x2) >> 1
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_ENDEM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_ENDEM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_DTOM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x8)|value<<3)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_DTOM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x8) >> 3
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_ILWM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x10)|value<<4)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_ILWM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x10) >> 4
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_ILRM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x20)|value<<5)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_ILRM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x20) >> 5
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_RSPTOM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x40)|value<<6)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_RSPTOM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x40) >> 6
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_BREM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_BREM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_BWEM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_BWEM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x200) >> 9
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_ILAM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x8000)|value<<15)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_ILAM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x8000) >> 15
}

// SDHI0.SD_CLK_CTRL: SD Clock Control Register
func (o *SDHI0_Type) SetSD_CLK_CTRL_CLKSEL(value uint32) {
	volatile.StoreUint32(&o.SD_CLK_CTRL.Reg, volatile.LoadUint32(&o.SD_CLK_CTRL.Reg)&^(0xff)|value)
}
func (o *SDHI0_Type) GetSD_CLK_CTRL_CLKSEL() uint32 {
	return volatile.LoadUint32(&o.SD_CLK_CTRL.Reg) & 0xff
}
func (o *SDHI0_Type) SetSD_CLK_CTRL_CLKEN(value uint32) {
	volatile.StoreUint32(&o.SD_CLK_CTRL.Reg, volatile.LoadUint32(&o.SD_CLK_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_CLK_CTRL_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.SD_CLK_CTRL.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_CLK_CTRL_CLKCTRLEN(value uint32) {
	volatile.StoreUint32(&o.SD_CLK_CTRL.Reg, volatile.LoadUint32(&o.SD_CLK_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSD_CLK_CTRL_CLKCTRLEN() uint32 {
	return (volatile.LoadUint32(&o.SD_CLK_CTRL.Reg) & 0x200) >> 9
}

// SDHI0.SD_SIZE: Transfer Data Length Register
func (o *SDHI0_Type) SetSD_SIZE_LEN(value uint32) {
	volatile.StoreUint32(&o.SD_SIZE.Reg, volatile.LoadUint32(&o.SD_SIZE.Reg)&^(0x3ff)|value)
}
func (o *SDHI0_Type) GetSD_SIZE_LEN() uint32 {
	return volatile.LoadUint32(&o.SD_SIZE.Reg) & 0x3ff
}

// SDHI0.SD_OPTION: SD Card Access Control Option Register
func (o *SDHI0_Type) SetSD_OPTION_CTOP(value uint32) {
	volatile.StoreUint32(&o.SD_OPTION.Reg, volatile.LoadUint32(&o.SD_OPTION.Reg)&^(0xf)|value)
}
func (o *SDHI0_Type) GetSD_OPTION_CTOP() uint32 {
	return volatile.LoadUint32(&o.SD_OPTION.Reg) & 0xf
}
func (o *SDHI0_Type) SetSD_OPTION_TOP(value uint32) {
	volatile.StoreUint32(&o.SD_OPTION.Reg, volatile.LoadUint32(&o.SD_OPTION.Reg)&^(0xf0)|value<<4)
}
func (o *SDHI0_Type) GetSD_OPTION_TOP() uint32 {
	return (volatile.LoadUint32(&o.SD_OPTION.Reg) & 0xf0) >> 4
}
func (o *SDHI0_Type) SetSD_OPTION_TOUTMASK(value uint32) {
	volatile.StoreUint32(&o.SD_OPTION.Reg, volatile.LoadUint32(&o.SD_OPTION.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_OPTION_TOUTMASK() uint32 {
	return (volatile.LoadUint32(&o.SD_OPTION.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_OPTION_WIDTH8(value uint32) {
	volatile.StoreUint32(&o.SD_OPTION.Reg, volatile.LoadUint32(&o.SD_OPTION.Reg)&^(0x2000)|value<<13)
}
func (o *SDHI0_Type) GetSD_OPTION_WIDTH8() uint32 {
	return (volatile.LoadUint32(&o.SD_OPTION.Reg) & 0x2000) >> 13
}
func (o *SDHI0_Type) SetSD_OPTION_WIDTH(value uint32) {
	volatile.StoreUint32(&o.SD_OPTION.Reg, volatile.LoadUint32(&o.SD_OPTION.Reg)&^(0x8000)|value<<15)
}
func (o *SDHI0_Type) GetSD_OPTION_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.SD_OPTION.Reg) & 0x8000) >> 15
}

// SDHI0.SD_ERR_STS1: SD Error Status Register 1
func (o *SDHI0_Type) SetSD_ERR_STS1_CMDE0(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_CMDE0() uint32 {
	return volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x1
}
func (o *SDHI0_Type) SetSD_ERR_STS1_CMDE1(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x2)|value<<1)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_CMDE1() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x2) >> 1
}
func (o *SDHI0_Type) SetSD_ERR_STS1_RSPLENE0(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_RSPLENE0() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSD_ERR_STS1_RSPLENE1(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x8)|value<<3)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_RSPLENE1() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x8) >> 3
}
func (o *SDHI0_Type) SetSD_ERR_STS1_RDLENE(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x10)|value<<4)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_RDLENE() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x10) >> 4
}
func (o *SDHI0_Type) SetSD_ERR_STS1_CRCLENE(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x20)|value<<5)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_CRCLENE() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x20) >> 5
}
func (o *SDHI0_Type) SetSD_ERR_STS1_RSPCRCE0(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_RSPCRCE0() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_ERR_STS1_RSPCRCE1(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_RSPCRCE1() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x200) >> 9
}
func (o *SDHI0_Type) SetSD_ERR_STS1_RDCRCE(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x400)|value<<10)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_RDCRCE() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x400) >> 10
}
func (o *SDHI0_Type) SetSD_ERR_STS1_CRCTKE(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x800)|value<<11)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_CRCTKE() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x800) >> 11
}
func (o *SDHI0_Type) SetSD_ERR_STS1_CRCTK(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x7000)|value<<12)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_CRCTK() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x7000) >> 12
}

// SDHI0.SD_ERR_STS2: SD Error Status Register 2
func (o *SDHI0_Type) SetSD_ERR_STS2_RSPTO0(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_RSPTO0() uint32 {
	return volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x1
}
func (o *SDHI0_Type) SetSD_ERR_STS2_RSPTO1(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x2)|value<<1)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_RSPTO1() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x2) >> 1
}
func (o *SDHI0_Type) SetSD_ERR_STS2_BSYTO0(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_BSYTO0() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSD_ERR_STS2_BSYTO1(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x8)|value<<3)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_BSYTO1() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x8) >> 3
}
func (o *SDHI0_Type) SetSD_ERR_STS2_RDTO(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x10)|value<<4)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_RDTO() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x10) >> 4
}
func (o *SDHI0_Type) SetSD_ERR_STS2_CRCTO(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x20)|value<<5)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_CRCTO() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x20) >> 5
}
func (o *SDHI0_Type) SetSD_ERR_STS2_CRCBSYTO(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x40)|value<<6)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_CRCBSYTO() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x40) >> 6
}

// SDHI0.SDIO_MODE: SDIO Mode Control Register
func (o *SDHI0_Type) SetSDIO_MODE_INTEN(value uint32) {
	volatile.StoreUint32(&o.SDIO_MODE.Reg, volatile.LoadUint32(&o.SDIO_MODE.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSDIO_MODE_INTEN() uint32 {
	return volatile.LoadUint32(&o.SDIO_MODE.Reg) & 0x1
}
func (o *SDHI0_Type) SetSDIO_MODE_RWREQ(value uint32) {
	volatile.StoreUint32(&o.SDIO_MODE.Reg, volatile.LoadUint32(&o.SDIO_MODE.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSDIO_MODE_RWREQ() uint32 {
	return (volatile.LoadUint32(&o.SDIO_MODE.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSDIO_MODE_IOABT(value uint32) {
	volatile.StoreUint32(&o.SDIO_MODE.Reg, volatile.LoadUint32(&o.SDIO_MODE.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSDIO_MODE_IOABT() uint32 {
	return (volatile.LoadUint32(&o.SDIO_MODE.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSDIO_MODE_C52PUB(value uint32) {
	volatile.StoreUint32(&o.SDIO_MODE.Reg, volatile.LoadUint32(&o.SDIO_MODE.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSDIO_MODE_C52PUB() uint32 {
	return (volatile.LoadUint32(&o.SDIO_MODE.Reg) & 0x200) >> 9
}

// SDHI0.SDIO_INFO1: SDIO Interrupt Flag Register
func (o *SDHI0_Type) SetSDIO_INFO1_IOIRQ(value uint32) {
	volatile.StoreUint32(&o.SDIO_INFO1.Reg, volatile.LoadUint32(&o.SDIO_INFO1.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSDIO_INFO1_IOIRQ() uint32 {
	return volatile.LoadUint32(&o.SDIO_INFO1.Reg) & 0x1
}
func (o *SDHI0_Type) SetSDIO_INFO1_EXPUB52(value uint32) {
	volatile.StoreUint32(&o.SDIO_INFO1.Reg, volatile.LoadUint32(&o.SDIO_INFO1.Reg)&^(0x4000)|value<<14)
}
func (o *SDHI0_Type) GetSDIO_INFO1_EXPUB52() uint32 {
	return (volatile.LoadUint32(&o.SDIO_INFO1.Reg) & 0x4000) >> 14
}
func (o *SDHI0_Type) SetSDIO_INFO1_EXWT(value uint32) {
	volatile.StoreUint32(&o.SDIO_INFO1.Reg, volatile.LoadUint32(&o.SDIO_INFO1.Reg)&^(0x8000)|value<<15)
}
func (o *SDHI0_Type) GetSDIO_INFO1_EXWT() uint32 {
	return (volatile.LoadUint32(&o.SDIO_INFO1.Reg) & 0x8000) >> 15
}

// SDHI0.SDIO_INFO1_MASK: SDIO INFO1 Interrupt Mask Register
func (o *SDHI0_Type) SetSDIO_INFO1_MASK_IOIRQM(value uint32) {
	volatile.StoreUint32(&o.SDIO_INFO1_MASK.Reg, volatile.LoadUint32(&o.SDIO_INFO1_MASK.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSDIO_INFO1_MASK_IOIRQM() uint32 {
	return volatile.LoadUint32(&o.SDIO_INFO1_MASK.Reg) & 0x1
}
func (o *SDHI0_Type) SetSDIO_INFO1_MASK_EXPUB52M(value uint32) {
	volatile.StoreUint32(&o.SDIO_INFO1_MASK.Reg, volatile.LoadUint32(&o.SDIO_INFO1_MASK.Reg)&^(0x4000)|value<<14)
}
func (o *SDHI0_Type) GetSDIO_INFO1_MASK_EXPUB52M() uint32 {
	return (volatile.LoadUint32(&o.SDIO_INFO1_MASK.Reg) & 0x4000) >> 14
}
func (o *SDHI0_Type) SetSDIO_INFO1_MASK_EXWTM(value uint32) {
	volatile.StoreUint32(&o.SDIO_INFO1_MASK.Reg, volatile.LoadUint32(&o.SDIO_INFO1_MASK.Reg)&^(0x8000)|value<<15)
}
func (o *SDHI0_Type) GetSDIO_INFO1_MASK_EXWTM() uint32 {
	return (volatile.LoadUint32(&o.SDIO_INFO1_MASK.Reg) & 0x8000) >> 15
}

// SDHI0.SD_DMAEN: DMA Mode Enable Register
func (o *SDHI0_Type) SetSD_DMAEN_DMAEN(value uint32) {
	volatile.StoreUint32(&o.SD_DMAEN.Reg, volatile.LoadUint32(&o.SD_DMAEN.Reg)&^(0x2)|value<<1)
}
func (o *SDHI0_Type) GetSD_DMAEN_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.SD_DMAEN.Reg) & 0x2) >> 1
}

// SDHI0.SOFT_RST: Software Reset Register
func (o *SDHI0_Type) SetSOFT_RST_SDRST(value uint32) {
	volatile.StoreUint32(&o.SOFT_RST.Reg, volatile.LoadUint32(&o.SOFT_RST.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSOFT_RST_SDRST() uint32 {
	return volatile.LoadUint32(&o.SOFT_RST.Reg) & 0x1
}

// SDHI0.SDIF_MODE: SD Interface Mode Setting Register
func (o *SDHI0_Type) SetSDIF_MODE_NOCHKCR(value uint32) {
	volatile.StoreUint32(&o.SDIF_MODE.Reg, volatile.LoadUint32(&o.SDIF_MODE.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSDIF_MODE_NOCHKCR() uint32 {
	return (volatile.LoadUint32(&o.SDIF_MODE.Reg) & 0x100) >> 8
}

// SDHI0.EXT_SWAP: Swap Control Register
func (o *SDHI0_Type) SetEXT_SWAP_BWSWP(value uint32) {
	volatile.StoreUint32(&o.EXT_SWAP.Reg, volatile.LoadUint32(&o.EXT_SWAP.Reg)&^(0x40)|value<<6)
}
func (o *SDHI0_Type) GetEXT_SWAP_BWSWP() uint32 {
	return (volatile.LoadUint32(&o.EXT_SWAP.Reg) & 0x40) >> 6
}
func (o *SDHI0_Type) SetEXT_SWAP_BRSWP(value uint32) {
	volatile.StoreUint32(&o.EXT_SWAP.Reg, volatile.LoadUint32(&o.EXT_SWAP.Reg)&^(0x80)|value<<7)
}
func (o *SDHI0_Type) GetEXT_SWAP_BRSWP() uint32 {
	return (volatile.LoadUint32(&o.EXT_SWAP.Reg) & 0x80) >> 7
}

// Serial Sound Interface Enhanced (SSIE)
type SSIE0_Type struct {
	SSICR   volatile.Register32 // 0x0
	SSISR   volatile.Register32 // 0x4
	_       [8]byte
	SSIFCR  volatile.Register32 // 0x10
	SSIFSR  volatile.Register32 // 0x14
	SSIFTDR volatile.Register32 // 0x18
	SSIFRDR volatile.Register32 // 0x1C
	SSIOFR  volatile.Register32 // 0x20
	SSISCR  volatile.Register32 // 0x24
}

// SSIE0.SSICR: Control Register
func (o *SSIE0_Type) SetSSICR_REN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x1)|value)
}
func (o *SSIE0_Type) GetSSICR_REN() uint32 {
	return volatile.LoadUint32(&o.SSICR.Reg) & 0x1
}
func (o *SSIE0_Type) SetSSICR_TEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x2)|value<<1)
}
func (o *SSIE0_Type) GetSSICR_TEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x2) >> 1
}
func (o *SSIE0_Type) SetSSICR_MUEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x8)|value<<3)
}
func (o *SSIE0_Type) GetSSICR_MUEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x8) >> 3
}
func (o *SSIE0_Type) SetSSICR_CKDV(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0xf0)|value<<4)
}
func (o *SSIE0_Type) GetSSICR_CKDV() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0xf0) >> 4
}
func (o *SSIE0_Type) SetSSICR_DEL(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x100)|value<<8)
}
func (o *SSIE0_Type) GetSSICR_DEL() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x100) >> 8
}
func (o *SSIE0_Type) SetSSICR_PDTA(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x200)|value<<9)
}
func (o *SSIE0_Type) GetSSICR_PDTA() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x200) >> 9
}
func (o *SSIE0_Type) SetSSICR_SDTA(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x400)|value<<10)
}
func (o *SSIE0_Type) GetSSICR_SDTA() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x400) >> 10
}
func (o *SSIE0_Type) SetSSICR_SPDP(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x800)|value<<11)
}
func (o *SSIE0_Type) GetSSICR_SPDP() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x800) >> 11
}
func (o *SSIE0_Type) SetSSICR_LRCKP(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x1000)|value<<12)
}
func (o *SSIE0_Type) GetSSICR_LRCKP() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x1000) >> 12
}
func (o *SSIE0_Type) SetSSICR_BCKP(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x2000)|value<<13)
}
func (o *SSIE0_Type) GetSSICR_BCKP() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x2000) >> 13
}
func (o *SSIE0_Type) SetSSICR_MST(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x4000)|value<<14)
}
func (o *SSIE0_Type) GetSSICR_MST() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x4000) >> 14
}
func (o *SSIE0_Type) SetSSICR_SWL(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x70000)|value<<16)
}
func (o *SSIE0_Type) GetSSICR_SWL() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x70000) >> 16
}
func (o *SSIE0_Type) SetSSICR_DWL(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x380000)|value<<19)
}
func (o *SSIE0_Type) GetSSICR_DWL() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x380000) >> 19
}
func (o *SSIE0_Type) SetSSICR_FRM(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0xc00000)|value<<22)
}
func (o *SSIE0_Type) GetSSICR_FRM() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0xc00000) >> 22
}
func (o *SSIE0_Type) SetSSICR_IIEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x2000000)|value<<25)
}
func (o *SSIE0_Type) GetSSICR_IIEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x2000000) >> 25
}
func (o *SSIE0_Type) SetSSICR_ROIEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x4000000)|value<<26)
}
func (o *SSIE0_Type) GetSSICR_ROIEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x4000000) >> 26
}
func (o *SSIE0_Type) SetSSICR_RUIEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x8000000)|value<<27)
}
func (o *SSIE0_Type) GetSSICR_RUIEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x8000000) >> 27
}
func (o *SSIE0_Type) SetSSICR_TOIEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x10000000)|value<<28)
}
func (o *SSIE0_Type) GetSSICR_TOIEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x10000000) >> 28
}
func (o *SSIE0_Type) SetSSICR_TUIEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x20000000)|value<<29)
}
func (o *SSIE0_Type) GetSSICR_TUIEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x20000000) >> 29
}

// SSIE0.SSISR: Status Register
func (o *SSIE0_Type) SetSSISR_IIRQ(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x2000000)|value<<25)
}
func (o *SSIE0_Type) GetSSISR_IIRQ() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0x2000000) >> 25
}
func (o *SSIE0_Type) SetSSISR_ROIRQ(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x4000000)|value<<26)
}
func (o *SSIE0_Type) GetSSISR_ROIRQ() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0x4000000) >> 26
}
func (o *SSIE0_Type) SetSSISR_RUIRQ(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x8000000)|value<<27)
}
func (o *SSIE0_Type) GetSSISR_RUIRQ() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0x8000000) >> 27
}
func (o *SSIE0_Type) SetSSISR_TOIRQ(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x10000000)|value<<28)
}
func (o *SSIE0_Type) GetSSISR_TOIRQ() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0x10000000) >> 28
}
func (o *SSIE0_Type) SetSSISR_TUIRQ(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x20000000)|value<<29)
}
func (o *SSIE0_Type) GetSSISR_TUIRQ() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0x20000000) >> 29
}

// SSIE0.SSIFCR: FIFO Control Register
func (o *SSIE0_Type) SetSSIFCR_RFRST(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x1)|value)
}
func (o *SSIE0_Type) GetSSIFCR_RFRST() uint32 {
	return volatile.LoadUint32(&o.SSIFCR.Reg) & 0x1
}
func (o *SSIE0_Type) SetSSIFCR_TFRST(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x2)|value<<1)
}
func (o *SSIE0_Type) GetSSIFCR_TFRST() uint32 {
	return (volatile.LoadUint32(&o.SSIFCR.Reg) & 0x2) >> 1
}
func (o *SSIE0_Type) SetSSIFCR_RIE(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x4)|value<<2)
}
func (o *SSIE0_Type) GetSSIFCR_RIE() uint32 {
	return (volatile.LoadUint32(&o.SSIFCR.Reg) & 0x4) >> 2
}
func (o *SSIE0_Type) SetSSIFCR_TIE(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x8)|value<<3)
}
func (o *SSIE0_Type) GetSSIFCR_TIE() uint32 {
	return (volatile.LoadUint32(&o.SSIFCR.Reg) & 0x8) >> 3
}
func (o *SSIE0_Type) SetSSIFCR_BSW(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x800)|value<<11)
}
func (o *SSIE0_Type) GetSSIFCR_BSW() uint32 {
	return (volatile.LoadUint32(&o.SSIFCR.Reg) & 0x800) >> 11
}
func (o *SSIE0_Type) SetSSIFCR_SSIRST(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x10000)|value<<16)
}
func (o *SSIE0_Type) GetSSIFCR_SSIRST() uint32 {
	return (volatile.LoadUint32(&o.SSIFCR.Reg) & 0x10000) >> 16
}
func (o *SSIE0_Type) SetSSIFCR_AUCKE(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x80000000)|value<<31)
}
func (o *SSIE0_Type) GetSSIFCR_AUCKE() uint32 {
	return (volatile.LoadUint32(&o.SSIFCR.Reg) & 0x80000000) >> 31
}

// SSIE0.SSIFSR: FIFO Status Register
func (o *SSIE0_Type) SetSSIFSR_RDF(value uint32) {
	volatile.StoreUint32(&o.SSIFSR.Reg, volatile.LoadUint32(&o.SSIFSR.Reg)&^(0x1)|value)
}
func (o *SSIE0_Type) GetSSIFSR_RDF() uint32 {
	return volatile.LoadUint32(&o.SSIFSR.Reg) & 0x1
}
func (o *SSIE0_Type) SetSSIFSR_RDC(value uint32) {
	volatile.StoreUint32(&o.SSIFSR.Reg, volatile.LoadUint32(&o.SSIFSR.Reg)&^(0x3f00)|value<<8)
}
func (o *SSIE0_Type) GetSSIFSR_RDC() uint32 {
	return (volatile.LoadUint32(&o.SSIFSR.Reg) & 0x3f00) >> 8
}
func (o *SSIE0_Type) SetSSIFSR_TDE(value uint32) {
	volatile.StoreUint32(&o.SSIFSR.Reg, volatile.LoadUint32(&o.SSIFSR.Reg)&^(0x10000)|value<<16)
}
func (o *SSIE0_Type) GetSSIFSR_TDE() uint32 {
	return (volatile.LoadUint32(&o.SSIFSR.Reg) & 0x10000) >> 16
}
func (o *SSIE0_Type) SetSSIFSR_TDC(value uint32) {
	volatile.StoreUint32(&o.SSIFSR.Reg, volatile.LoadUint32(&o.SSIFSR.Reg)&^(0x3f000000)|value<<24)
}
func (o *SSIE0_Type) GetSSIFSR_TDC() uint32 {
	return (volatile.LoadUint32(&o.SSIFSR.Reg) & 0x3f000000) >> 24
}

// SSIE0.SSIFTDR: Transmit FIFO Data Register
func (o *SSIE0_Type) SetSSIFTDR(value uint32) {
	volatile.StoreUint32(&o.SSIFTDR.Reg, value)
}
func (o *SSIE0_Type) GetSSIFTDR() uint32 {
	return volatile.LoadUint32(&o.SSIFTDR.Reg)
}

// SSIE0.SSIFRDR: Receive FIFO Data Register
func (o *SSIE0_Type) SetSSIFRDR(value uint32) {
	volatile.StoreUint32(&o.SSIFRDR.Reg, value)
}
func (o *SSIE0_Type) GetSSIFRDR() uint32 {
	return volatile.LoadUint32(&o.SSIFRDR.Reg)
}

// SSIE0.SSIOFR: Audio Format Register
func (o *SSIE0_Type) SetSSIOFR_OMOD(value uint32) {
	volatile.StoreUint32(&o.SSIOFR.Reg, volatile.LoadUint32(&o.SSIOFR.Reg)&^(0x3)|value)
}
func (o *SSIE0_Type) GetSSIOFR_OMOD() uint32 {
	return volatile.LoadUint32(&o.SSIOFR.Reg) & 0x3
}
func (o *SSIE0_Type) SetSSIOFR_LRCONT(value uint32) {
	volatile.StoreUint32(&o.SSIOFR.Reg, volatile.LoadUint32(&o.SSIOFR.Reg)&^(0x100)|value<<8)
}
func (o *SSIE0_Type) GetSSIOFR_LRCONT() uint32 {
	return (volatile.LoadUint32(&o.SSIOFR.Reg) & 0x100) >> 8
}
func (o *SSIE0_Type) SetSSIOFR_BCKASTP(value uint32) {
	volatile.StoreUint32(&o.SSIOFR.Reg, volatile.LoadUint32(&o.SSIOFR.Reg)&^(0x200)|value<<9)
}
func (o *SSIE0_Type) GetSSIOFR_BCKASTP() uint32 {
	return (volatile.LoadUint32(&o.SSIOFR.Reg) & 0x200) >> 9
}

// SSIE0.SSISCR: Status Control Register
func (o *SSIE0_Type) SetSSISCR_RDFS(value uint32) {
	volatile.StoreUint32(&o.SSISCR.Reg, volatile.LoadUint32(&o.SSISCR.Reg)&^(0x1f)|value)
}
func (o *SSIE0_Type) GetSSISCR_RDFS() uint32 {
	return volatile.LoadUint32(&o.SSISCR.Reg) & 0x1f
}
func (o *SSIE0_Type) SetSSISCR_TDES(value uint32) {
	volatile.StoreUint32(&o.SSISCR.Reg, volatile.LoadUint32(&o.SSISCR.Reg)&^(0x1f00)|value<<8)
}
func (o *SSIE0_Type) GetSSISCR_TDES() uint32 {
	return (volatile.LoadUint32(&o.SSISCR.Reg) & 0x1f00) >> 8
}

// Inter-Integrated Circuit 0
type IIC0_Type struct {
	ICCR1 volatile.Register8 // 0x0
	ICCR2 volatile.Register8 // 0x1
	ICMR1 volatile.Register8 // 0x2
	ICMR2 volatile.Register8 // 0x3
	ICMR3 volatile.Register8 // 0x4
	ICFER volatile.Register8 // 0x5
	ICSER volatile.Register8 // 0x6
	ICIER volatile.Register8 // 0x7
	ICSR1 volatile.Register8 // 0x8
	ICSR2 volatile.Register8 // 0x9
	SARL0 volatile.Register8 // 0xA
	SARU0 volatile.Register8 // 0xB
	SARL1 volatile.Register8 // 0xC
	SARU1 volatile.Register8 // 0xD
	SARL2 volatile.Register8 // 0xE
	SARU2 volatile.Register8 // 0xF
	ICBRL volatile.Register8 // 0x10
	ICBRH volatile.Register8 // 0x11
	ICDRT volatile.Register8 // 0x12
	ICDRR volatile.Register8 // 0x13
}

// IIC0.ICCR1: I2C Bus Control Register 1
func (o *IIC0_Type) SetICCR1_SDAI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICCR1_SDAI() uint8 {
	return volatile.LoadUint8(&o.ICCR1.Reg) & 0x1
}
func (o *IIC0_Type) SetICCR1_SCLI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICCR1_SCLI() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICCR1_SDAO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICCR1_SDAO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICCR1_SCLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICCR1_SCLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICCR1_SOWP(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICCR1_SOWP() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICCR1_CLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICCR1_CLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICCR1_IICRST(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICCR1_IICRST() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICCR1_ICE(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICCR1_ICE() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x80) >> 7
}

// IIC0.ICCR2: I2C Bus Control Register 2
func (o *IIC0_Type) SetICCR2_ST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICCR2_ST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICCR2_RS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICCR2_RS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICCR2_SP(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICCR2_SP() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICCR2_TRS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICCR2_TRS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICCR2_MST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICCR2_MST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICCR2_BBSY(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICCR2_BBSY() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x80) >> 7
}

// IIC0.ICMR1: I2C Bus Mode Register 1
func (o *IIC0_Type) SetICMR1_BC(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x7)|value)
}
func (o *IIC0_Type) GetICMR1_BC() uint8 {
	return volatile.LoadUint8(&o.ICMR1.Reg) & 0x7
}
func (o *IIC0_Type) SetICMR1_BCWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICMR1_BCWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICMR1_CKS(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x70)|value<<4)
}
func (o *IIC0_Type) GetICMR1_CKS() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x70) >> 4
}
func (o *IIC0_Type) SetICMR1_MTWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR1_MTWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x80) >> 7
}

// IIC0.ICMR2: I2C Bus Mode Register 2
func (o *IIC0_Type) SetICMR2_TMOS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICMR2_TMOS() uint8 {
	return volatile.LoadUint8(&o.ICMR2.Reg) & 0x1
}
func (o *IIC0_Type) SetICMR2_TMOL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICMR2_TMOL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICMR2_TMOH(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICMR2_TMOH() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICMR2_SDDL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x70)|value<<4)
}
func (o *IIC0_Type) GetICMR2_SDDL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x70) >> 4
}
func (o *IIC0_Type) SetICMR2_DLCS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR2_DLCS() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x80) >> 7
}

// IIC0.ICMR3: I2C Bus Mode Register 3
func (o *IIC0_Type) SetICMR3_NF(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x3)|value)
}
func (o *IIC0_Type) GetICMR3_NF() uint8 {
	return volatile.LoadUint8(&o.ICMR3.Reg) & 0x3
}
func (o *IIC0_Type) SetICMR3_ACKBR(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICMR3_ACKBR() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICMR3_ACKBT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICMR3_ACKBT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICMR3_ACKWP(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICMR3_ACKWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICMR3_RDRFS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICMR3_RDRFS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICMR3_WAIT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICMR3_WAIT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICMR3_SMBS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR3_SMBS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x80) >> 7
}

// IIC0.ICFER: I2C Bus Function Enable Register
func (o *IIC0_Type) SetICFER_TMOE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICFER_TMOE() uint8 {
	return volatile.LoadUint8(&o.ICFER.Reg) & 0x1
}
func (o *IIC0_Type) SetICFER_MALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICFER_MALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICFER_NALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICFER_NALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICFER_SALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICFER_SALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICFER_NACKE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICFER_NACKE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICFER_NFE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICFER_NFE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICFER_SCLE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICFER_SCLE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICFER_FMPE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICFER_FMPE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x80) >> 7
}

// IIC0.ICSER: I2C Bus Status Enable Register
func (o *IIC0_Type) SetICSER_SAR0E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSER_SAR0E() uint8 {
	return volatile.LoadUint8(&o.ICSER.Reg) & 0x1
}
func (o *IIC0_Type) SetICSER_SAR1E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSER_SAR1E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSER_SAR2E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSER_SAR2E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSER_GCAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSER_GCAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSER_DIDE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSER_DIDE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSER_HOAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSER_HOAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x80) >> 7
}

// IIC0.ICIER: I2C Bus Interrupt Enable Register
func (o *IIC0_Type) SetICIER_TMOIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICIER_TMOIE() uint8 {
	return volatile.LoadUint8(&o.ICIER.Reg) & 0x1
}
func (o *IIC0_Type) SetICIER_ALIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICIER_ALIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICIER_STIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICIER_STIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICIER_SPIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICIER_SPIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICIER_NAKIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICIER_NAKIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICIER_RIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICIER_RIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICIER_TEIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICIER_TEIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICIER_TIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICIER_TIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x80) >> 7
}

// IIC0.ICSR1: I2C Bus Status Register 1
func (o *IIC0_Type) SetICSR1_AAS0(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSR1_AAS0() uint8 {
	return volatile.LoadUint8(&o.ICSR1.Reg) & 0x1
}
func (o *IIC0_Type) SetICSR1_AAS1(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSR1_AAS1() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSR1_AAS2(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSR1_AAS2() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSR1_GCA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSR1_GCA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSR1_DID(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSR1_DID() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSR1_HOA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSR1_HOA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x80) >> 7
}

// IIC0.ICSR2: I2C Bus Status Register 2
func (o *IIC0_Type) SetICSR2_TMOF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSR2_TMOF() uint8 {
	return volatile.LoadUint8(&o.ICSR2.Reg) & 0x1
}
func (o *IIC0_Type) SetICSR2_AL(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSR2_AL() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSR2_START(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSR2_START() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSR2_STOP(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSR2_STOP() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSR2_NACKF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICSR2_NACKF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICSR2_RDRF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSR2_RDRF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSR2_TEND(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICSR2_TEND() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICSR2_TDRE(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSR2_TDRE() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x80) >> 7
}

// IIC0.SARL0: Slave Address Register Ly
func (o *IIC0_Type) SetSARL0_SVA0(value uint8) {
	volatile.StoreUint8(&o.SARL0.Reg, volatile.LoadUint8(&o.SARL0.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARL0_SVA0() uint8 {
	return volatile.LoadUint8(&o.SARL0.Reg) & 0x1
}
func (o *IIC0_Type) SetSARL0_SVA(value uint8) {
	volatile.StoreUint8(&o.SARL0.Reg, volatile.LoadUint8(&o.SARL0.Reg)&^(0xfe)|value<<1)
}
func (o *IIC0_Type) GetSARL0_SVA() uint8 {
	return (volatile.LoadUint8(&o.SARL0.Reg) & 0xfe) >> 1
}

// IIC0.SARU0: Slave Address Register Uy
func (o *IIC0_Type) SetSARU0_FS(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU0_FS() uint8 {
	return volatile.LoadUint8(&o.SARU0.Reg) & 0x1
}
func (o *IIC0_Type) SetSARU0_SVA(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x6)|value<<1)
}
func (o *IIC0_Type) GetSARU0_SVA() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x6) >> 1
}

// IIC0.SARL1: Slave Address Register Ly
func (o *IIC0_Type) SetSARL1_SVA0(value uint8) {
	volatile.StoreUint8(&o.SARL1.Reg, volatile.LoadUint8(&o.SARL1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARL1_SVA0() uint8 {
	return volatile.LoadUint8(&o.SARL1.Reg) & 0x1
}
func (o *IIC0_Type) SetSARL1_SVA(value uint8) {
	volatile.StoreUint8(&o.SARL1.Reg, volatile.LoadUint8(&o.SARL1.Reg)&^(0xfe)|value<<1)
}
func (o *IIC0_Type) GetSARL1_SVA() uint8 {
	return (volatile.LoadUint8(&o.SARL1.Reg) & 0xfe) >> 1
}

// IIC0.SARU1: Slave Address Register Uy
func (o *IIC0_Type) SetSARU1_FS(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU1_FS() uint8 {
	return volatile.LoadUint8(&o.SARU1.Reg) & 0x1
}
func (o *IIC0_Type) SetSARU1_SVA(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x6)|value<<1)
}
func (o *IIC0_Type) GetSARU1_SVA() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x6) >> 1
}

// IIC0.SARL2: Slave Address Register Ly
func (o *IIC0_Type) SetSARL2_SVA0(value uint8) {
	volatile.StoreUint8(&o.SARL2.Reg, volatile.LoadUint8(&o.SARL2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARL2_SVA0() uint8 {
	return volatile.LoadUint8(&o.SARL2.Reg) & 0x1
}
func (o *IIC0_Type) SetSARL2_SVA(value uint8) {
	volatile.StoreUint8(&o.SARL2.Reg, volatile.LoadUint8(&o.SARL2.Reg)&^(0xfe)|value<<1)
}
func (o *IIC0_Type) GetSARL2_SVA() uint8 {
	return (volatile.LoadUint8(&o.SARL2.Reg) & 0xfe) >> 1
}

// IIC0.SARU2: Slave Address Register Uy
func (o *IIC0_Type) SetSARU2_FS(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU2_FS() uint8 {
	return volatile.LoadUint8(&o.SARU2.Reg) & 0x1
}
func (o *IIC0_Type) SetSARU2_SVA(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x6)|value<<1)
}
func (o *IIC0_Type) GetSARU2_SVA() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x6) >> 1
}

// IIC0.ICBRL: I2C Bus Bit Rate Low-Level Register
func (o *IIC0_Type) SetICBRL_BRL(value uint8) {
	volatile.StoreUint8(&o.ICBRL.Reg, volatile.LoadUint8(&o.ICBRL.Reg)&^(0x1f)|value)
}
func (o *IIC0_Type) GetICBRL_BRL() uint8 {
	return volatile.LoadUint8(&o.ICBRL.Reg) & 0x1f
}

// IIC0.ICBRH: I2C Bus Bit Rate High-Level Register
func (o *IIC0_Type) SetICBRH_BRH(value uint8) {
	volatile.StoreUint8(&o.ICBRH.Reg, volatile.LoadUint8(&o.ICBRH.Reg)&^(0x1f)|value)
}
func (o *IIC0_Type) GetICBRH_BRH() uint8 {
	return volatile.LoadUint8(&o.ICBRH.Reg) & 0x1f
}

// Inter-Integrated Circuit 0 Wake-up Unit
type IIC0WU_Type struct {
	_      [2]byte
	ICWUR  volatile.Register8 // 0x2
	ICWUR2 volatile.Register8 // 0x3
}

// IIC0WU.ICWUR: I2C Bus Wakeup Unit Register
func (o *IIC0WU_Type) SetICWUR_WUAFA(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x1)|value)
}
func (o *IIC0WU_Type) GetICWUR_WUAFA() uint8 {
	return volatile.LoadUint8(&o.ICWUR.Reg) & 0x1
}
func (o *IIC0WU_Type) SetICWUR_WUACK(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x10)|value<<4)
}
func (o *IIC0WU_Type) GetICWUR_WUACK() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x10) >> 4
}
func (o *IIC0WU_Type) SetICWUR_WUF(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x20)|value<<5)
}
func (o *IIC0WU_Type) GetICWUR_WUF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x20) >> 5
}
func (o *IIC0WU_Type) SetICWUR_WUIE(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x40)|value<<6)
}
func (o *IIC0WU_Type) GetICWUR_WUIE() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x40) >> 6
}
func (o *IIC0WU_Type) SetICWUR_WUE(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x80)|value<<7)
}
func (o *IIC0WU_Type) GetICWUR_WUE() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x80) >> 7
}

// IIC0WU.ICWUR2: I2C Bus Wakeup Unit Register 2
func (o *IIC0WU_Type) SetICWUR2_WUSEN(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x1)|value)
}
func (o *IIC0WU_Type) GetICWUR2_WUSEN() uint8 {
	return volatile.LoadUint8(&o.ICWUR2.Reg) & 0x1
}
func (o *IIC0WU_Type) SetICWUR2_WUASYF(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0WU_Type) GetICWUR2_WUASYF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR2.Reg) & 0x2) >> 1
}
func (o *IIC0WU_Type) SetICWUR2_WUSYF(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0WU_Type) GetICWUR2_WUSYF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR2.Reg) & 0x4) >> 2
}

// Controller Area Network
type CAN0_Type struct {
	_       [512]byte
	MB0_ID  volatile.Register32    // 0x200
	MB0_DL  volatile.Register16    // 0x204
	MB0_D0  volatile.Register8     // 0x206
	MB0_D1  volatile.Register8     // 0x207
	MB0_D2  volatile.Register8     // 0x208
	MB0_D3  volatile.Register8     // 0x209
	MB0_D4  volatile.Register8     // 0x20A
	MB0_D5  volatile.Register8     // 0x20B
	MB0_D6  volatile.Register8     // 0x20C
	MB0_D7  volatile.Register8     // 0x20D
	MB0_TS  volatile.Register16    // 0x20E
	MB1_ID  volatile.Register32    // 0x210
	MB1_DL  volatile.Register16    // 0x214
	MB1_D0  volatile.Register8     // 0x216
	MB1_D1  volatile.Register8     // 0x217
	MB1_D2  volatile.Register8     // 0x218
	MB1_D3  volatile.Register8     // 0x219
	MB1_D4  volatile.Register8     // 0x21A
	MB1_D5  volatile.Register8     // 0x21B
	MB1_D6  volatile.Register8     // 0x21C
	MB1_D7  volatile.Register8     // 0x21D
	MB1_TS  volatile.Register16    // 0x21E
	MB2_ID  volatile.Register32    // 0x220
	MB2_DL  volatile.Register16    // 0x224
	MB2_D0  volatile.Register8     // 0x226
	MB2_D1  volatile.Register8     // 0x227
	MB2_D2  volatile.Register8     // 0x228
	MB2_D3  volatile.Register8     // 0x229
	MB2_D4  volatile.Register8     // 0x22A
	MB2_D5  volatile.Register8     // 0x22B
	MB2_D6  volatile.Register8     // 0x22C
	MB2_D7  volatile.Register8     // 0x22D
	MB2_TS  volatile.Register16    // 0x22E
	MB3_ID  volatile.Register32    // 0x230
	MB3_DL  volatile.Register16    // 0x234
	MB3_D0  volatile.Register8     // 0x236
	MB3_D1  volatile.Register8     // 0x237
	MB3_D2  volatile.Register8     // 0x238
	MB3_D3  volatile.Register8     // 0x239
	MB3_D4  volatile.Register8     // 0x23A
	MB3_D5  volatile.Register8     // 0x23B
	MB3_D6  volatile.Register8     // 0x23C
	MB3_D7  volatile.Register8     // 0x23D
	MB3_TS  volatile.Register16    // 0x23E
	MB4_ID  volatile.Register32    // 0x240
	MB4_DL  volatile.Register16    // 0x244
	MB4_D0  volatile.Register8     // 0x246
	MB4_D1  volatile.Register8     // 0x247
	MB4_D2  volatile.Register8     // 0x248
	MB4_D3  volatile.Register8     // 0x249
	MB4_D4  volatile.Register8     // 0x24A
	MB4_D5  volatile.Register8     // 0x24B
	MB4_D6  volatile.Register8     // 0x24C
	MB4_D7  volatile.Register8     // 0x24D
	MB4_TS  volatile.Register16    // 0x24E
	MB5_ID  volatile.Register32    // 0x250
	MB5_DL  volatile.Register16    // 0x254
	MB5_D0  volatile.Register8     // 0x256
	MB5_D1  volatile.Register8     // 0x257
	MB5_D2  volatile.Register8     // 0x258
	MB5_D3  volatile.Register8     // 0x259
	MB5_D4  volatile.Register8     // 0x25A
	MB5_D5  volatile.Register8     // 0x25B
	MB5_D6  volatile.Register8     // 0x25C
	MB5_D7  volatile.Register8     // 0x25D
	MB5_TS  volatile.Register16    // 0x25E
	MB6_ID  volatile.Register32    // 0x260
	MB6_DL  volatile.Register16    // 0x264
	MB6_D0  volatile.Register8     // 0x266
	MB6_D1  volatile.Register8     // 0x267
	MB6_D2  volatile.Register8     // 0x268
	MB6_D3  volatile.Register8     // 0x269
	MB6_D4  volatile.Register8     // 0x26A
	MB6_D5  volatile.Register8     // 0x26B
	MB6_D6  volatile.Register8     // 0x26C
	MB6_D7  volatile.Register8     // 0x26D
	MB6_TS  volatile.Register16    // 0x26E
	MB7_ID  volatile.Register32    // 0x270
	MB7_DL  volatile.Register16    // 0x274
	MB7_D0  volatile.Register8     // 0x276
	MB7_D1  volatile.Register8     // 0x277
	MB7_D2  volatile.Register8     // 0x278
	MB7_D3  volatile.Register8     // 0x279
	MB7_D4  volatile.Register8     // 0x27A
	MB7_D5  volatile.Register8     // 0x27B
	MB7_D6  volatile.Register8     // 0x27C
	MB7_D7  volatile.Register8     // 0x27D
	MB7_TS  volatile.Register16    // 0x27E
	MB8_ID  volatile.Register32    // 0x280
	MB8_DL  volatile.Register16    // 0x284
	MB8_D0  volatile.Register8     // 0x286
	MB8_D1  volatile.Register8     // 0x287
	MB8_D2  volatile.Register8     // 0x288
	MB8_D3  volatile.Register8     // 0x289
	MB8_D4  volatile.Register8     // 0x28A
	MB8_D5  volatile.Register8     // 0x28B
	MB8_D6  volatile.Register8     // 0x28C
	MB8_D7  volatile.Register8     // 0x28D
	MB8_TS  volatile.Register16    // 0x28E
	MB9_ID  volatile.Register32    // 0x290
	MB9_DL  volatile.Register16    // 0x294
	MB9_D0  volatile.Register8     // 0x296
	MB9_D1  volatile.Register8     // 0x297
	MB9_D2  volatile.Register8     // 0x298
	MB9_D3  volatile.Register8     // 0x299
	MB9_D4  volatile.Register8     // 0x29A
	MB9_D5  volatile.Register8     // 0x29B
	MB9_D6  volatile.Register8     // 0x29C
	MB9_D7  volatile.Register8     // 0x29D
	MB9_TS  volatile.Register16    // 0x29E
	MB10_ID volatile.Register32    // 0x2A0
	MB10_DL volatile.Register16    // 0x2A4
	MB10_D0 volatile.Register8     // 0x2A6
	MB10_D1 volatile.Register8     // 0x2A7
	MB10_D2 volatile.Register8     // 0x2A8
	MB10_D3 volatile.Register8     // 0x2A9
	MB10_D4 volatile.Register8     // 0x2AA
	MB10_D5 volatile.Register8     // 0x2AB
	MB10_D6 volatile.Register8     // 0x2AC
	MB10_D7 volatile.Register8     // 0x2AD
	MB10_TS volatile.Register16    // 0x2AE
	MB11_ID volatile.Register32    // 0x2B0
	MB11_DL volatile.Register16    // 0x2B4
	MB11_D0 volatile.Register8     // 0x2B6
	MB11_D1 volatile.Register8     // 0x2B7
	MB11_D2 volatile.Register8     // 0x2B8
	MB11_D3 volatile.Register8     // 0x2B9
	MB11_D4 volatile.Register8     // 0x2BA
	MB11_D5 volatile.Register8     // 0x2BB
	MB11_D6 volatile.Register8     // 0x2BC
	MB11_D7 volatile.Register8     // 0x2BD
	MB11_TS volatile.Register16    // 0x2BE
	MB12_ID volatile.Register32    // 0x2C0
	MB12_DL volatile.Register16    // 0x2C4
	MB12_D0 volatile.Register8     // 0x2C6
	MB12_D1 volatile.Register8     // 0x2C7
	MB12_D2 volatile.Register8     // 0x2C8
	MB12_D3 volatile.Register8     // 0x2C9
	MB12_D4 volatile.Register8     // 0x2CA
	MB12_D5 volatile.Register8     // 0x2CB
	MB12_D6 volatile.Register8     // 0x2CC
	MB12_D7 volatile.Register8     // 0x2CD
	MB12_TS volatile.Register16    // 0x2CE
	MB13_ID volatile.Register32    // 0x2D0
	MB13_DL volatile.Register16    // 0x2D4
	MB13_D0 volatile.Register8     // 0x2D6
	MB13_D1 volatile.Register8     // 0x2D7
	MB13_D2 volatile.Register8     // 0x2D8
	MB13_D3 volatile.Register8     // 0x2D9
	MB13_D4 volatile.Register8     // 0x2DA
	MB13_D5 volatile.Register8     // 0x2DB
	MB13_D6 volatile.Register8     // 0x2DC
	MB13_D7 volatile.Register8     // 0x2DD
	MB13_TS volatile.Register16    // 0x2DE
	MB14_ID volatile.Register32    // 0x2E0
	MB14_DL volatile.Register16    // 0x2E4
	MB14_D0 volatile.Register8     // 0x2E6
	MB14_D1 volatile.Register8     // 0x2E7
	MB14_D2 volatile.Register8     // 0x2E8
	MB14_D3 volatile.Register8     // 0x2E9
	MB14_D4 volatile.Register8     // 0x2EA
	MB14_D5 volatile.Register8     // 0x2EB
	MB14_D6 volatile.Register8     // 0x2EC
	MB14_D7 volatile.Register8     // 0x2ED
	MB14_TS volatile.Register16    // 0x2EE
	MB15_ID volatile.Register32    // 0x2F0
	MB15_DL volatile.Register16    // 0x2F4
	MB15_D0 volatile.Register8     // 0x2F6
	MB15_D1 volatile.Register8     // 0x2F7
	MB15_D2 volatile.Register8     // 0x2F8
	MB15_D3 volatile.Register8     // 0x2F9
	MB15_D4 volatile.Register8     // 0x2FA
	MB15_D5 volatile.Register8     // 0x2FB
	MB15_D6 volatile.Register8     // 0x2FC
	MB15_D7 volatile.Register8     // 0x2FD
	MB15_TS volatile.Register16    // 0x2FE
	MB16_ID volatile.Register32    // 0x300
	MB16_DL volatile.Register16    // 0x304
	MB16_D0 volatile.Register8     // 0x306
	MB16_D1 volatile.Register8     // 0x307
	MB16_D2 volatile.Register8     // 0x308
	MB16_D3 volatile.Register8     // 0x309
	MB16_D4 volatile.Register8     // 0x30A
	MB16_D5 volatile.Register8     // 0x30B
	MB16_D6 volatile.Register8     // 0x30C
	MB16_D7 volatile.Register8     // 0x30D
	MB16_TS volatile.Register16    // 0x30E
	MB17_ID volatile.Register32    // 0x310
	MB17_DL volatile.Register16    // 0x314
	MB17_D0 volatile.Register8     // 0x316
	MB17_D1 volatile.Register8     // 0x317
	MB17_D2 volatile.Register8     // 0x318
	MB17_D3 volatile.Register8     // 0x319
	MB17_D4 volatile.Register8     // 0x31A
	MB17_D5 volatile.Register8     // 0x31B
	MB17_D6 volatile.Register8     // 0x31C
	MB17_D7 volatile.Register8     // 0x31D
	MB17_TS volatile.Register16    // 0x31E
	MB18_ID volatile.Register32    // 0x320
	MB18_DL volatile.Register16    // 0x324
	MB18_D0 volatile.Register8     // 0x326
	MB18_D1 volatile.Register8     // 0x327
	MB18_D2 volatile.Register8     // 0x328
	MB18_D3 volatile.Register8     // 0x329
	MB18_D4 volatile.Register8     // 0x32A
	MB18_D5 volatile.Register8     // 0x32B
	MB18_D6 volatile.Register8     // 0x32C
	MB18_D7 volatile.Register8     // 0x32D
	MB18_TS volatile.Register16    // 0x32E
	MB19_ID volatile.Register32    // 0x330
	MB19_DL volatile.Register16    // 0x334
	MB19_D0 volatile.Register8     // 0x336
	MB19_D1 volatile.Register8     // 0x337
	MB19_D2 volatile.Register8     // 0x338
	MB19_D3 volatile.Register8     // 0x339
	MB19_D4 volatile.Register8     // 0x33A
	MB19_D5 volatile.Register8     // 0x33B
	MB19_D6 volatile.Register8     // 0x33C
	MB19_D7 volatile.Register8     // 0x33D
	MB19_TS volatile.Register16    // 0x33E
	MB20_ID volatile.Register32    // 0x340
	MB20_DL volatile.Register16    // 0x344
	MB20_D0 volatile.Register8     // 0x346
	MB20_D1 volatile.Register8     // 0x347
	MB20_D2 volatile.Register8     // 0x348
	MB20_D3 volatile.Register8     // 0x349
	MB20_D4 volatile.Register8     // 0x34A
	MB20_D5 volatile.Register8     // 0x34B
	MB20_D6 volatile.Register8     // 0x34C
	MB20_D7 volatile.Register8     // 0x34D
	MB20_TS volatile.Register16    // 0x34E
	MB21_ID volatile.Register32    // 0x350
	MB21_DL volatile.Register16    // 0x354
	MB21_D0 volatile.Register8     // 0x356
	MB21_D1 volatile.Register8     // 0x357
	MB21_D2 volatile.Register8     // 0x358
	MB21_D3 volatile.Register8     // 0x359
	MB21_D4 volatile.Register8     // 0x35A
	MB21_D5 volatile.Register8     // 0x35B
	MB21_D6 volatile.Register8     // 0x35C
	MB21_D7 volatile.Register8     // 0x35D
	MB21_TS volatile.Register16    // 0x35E
	MB22_ID volatile.Register32    // 0x360
	MB22_DL volatile.Register16    // 0x364
	MB22_D0 volatile.Register8     // 0x366
	MB22_D1 volatile.Register8     // 0x367
	MB22_D2 volatile.Register8     // 0x368
	MB22_D3 volatile.Register8     // 0x369
	MB22_D4 volatile.Register8     // 0x36A
	MB22_D5 volatile.Register8     // 0x36B
	MB22_D6 volatile.Register8     // 0x36C
	MB22_D7 volatile.Register8     // 0x36D
	MB22_TS volatile.Register16    // 0x36E
	MB23_ID volatile.Register32    // 0x370
	MB23_DL volatile.Register16    // 0x374
	MB23_D0 volatile.Register8     // 0x376
	MB23_D1 volatile.Register8     // 0x377
	MB23_D2 volatile.Register8     // 0x378
	MB23_D3 volatile.Register8     // 0x379
	MB23_D4 volatile.Register8     // 0x37A
	MB23_D5 volatile.Register8     // 0x37B
	MB23_D6 volatile.Register8     // 0x37C
	MB23_D7 volatile.Register8     // 0x37D
	MB23_TS volatile.Register16    // 0x37E
	MB24_ID volatile.Register32    // 0x380
	MB24_DL volatile.Register16    // 0x384
	MB24_D0 volatile.Register8     // 0x386
	MB24_D1 volatile.Register8     // 0x387
	MB24_D2 volatile.Register8     // 0x388
	MB24_D3 volatile.Register8     // 0x389
	MB24_D4 volatile.Register8     // 0x38A
	MB24_D5 volatile.Register8     // 0x38B
	MB24_D6 volatile.Register8     // 0x38C
	MB24_D7 volatile.Register8     // 0x38D
	MB24_TS volatile.Register16    // 0x38E
	MB25_ID volatile.Register32    // 0x390
	MB25_DL volatile.Register16    // 0x394
	MB25_D0 volatile.Register8     // 0x396
	MB25_D1 volatile.Register8     // 0x397
	MB25_D2 volatile.Register8     // 0x398
	MB25_D3 volatile.Register8     // 0x399
	MB25_D4 volatile.Register8     // 0x39A
	MB25_D5 volatile.Register8     // 0x39B
	MB25_D6 volatile.Register8     // 0x39C
	MB25_D7 volatile.Register8     // 0x39D
	MB25_TS volatile.Register16    // 0x39E
	MB26_ID volatile.Register32    // 0x3A0
	MB26_DL volatile.Register16    // 0x3A4
	MB26_D0 volatile.Register8     // 0x3A6
	MB26_D1 volatile.Register8     // 0x3A7
	MB26_D2 volatile.Register8     // 0x3A8
	MB26_D3 volatile.Register8     // 0x3A9
	MB26_D4 volatile.Register8     // 0x3AA
	MB26_D5 volatile.Register8     // 0x3AB
	MB26_D6 volatile.Register8     // 0x3AC
	MB26_D7 volatile.Register8     // 0x3AD
	MB26_TS volatile.Register16    // 0x3AE
	MB27_ID volatile.Register32    // 0x3B0
	MB27_DL volatile.Register16    // 0x3B4
	MB27_D0 volatile.Register8     // 0x3B6
	MB27_D1 volatile.Register8     // 0x3B7
	MB27_D2 volatile.Register8     // 0x3B8
	MB27_D3 volatile.Register8     // 0x3B9
	MB27_D4 volatile.Register8     // 0x3BA
	MB27_D5 volatile.Register8     // 0x3BB
	MB27_D6 volatile.Register8     // 0x3BC
	MB27_D7 volatile.Register8     // 0x3BD
	MB27_TS volatile.Register16    // 0x3BE
	MB28_ID volatile.Register32    // 0x3C0
	MB28_DL volatile.Register16    // 0x3C4
	MB28_D0 volatile.Register8     // 0x3C6
	MB28_D1 volatile.Register8     // 0x3C7
	MB28_D2 volatile.Register8     // 0x3C8
	MB28_D3 volatile.Register8     // 0x3C9
	MB28_D4 volatile.Register8     // 0x3CA
	MB28_D5 volatile.Register8     // 0x3CB
	MB28_D6 volatile.Register8     // 0x3CC
	MB28_D7 volatile.Register8     // 0x3CD
	MB28_TS volatile.Register16    // 0x3CE
	MB29_ID volatile.Register32    // 0x3D0
	MB29_DL volatile.Register16    // 0x3D4
	MB29_D0 volatile.Register8     // 0x3D6
	MB29_D1 volatile.Register8     // 0x3D7
	MB29_D2 volatile.Register8     // 0x3D8
	MB29_D3 volatile.Register8     // 0x3D9
	MB29_D4 volatile.Register8     // 0x3DA
	MB29_D5 volatile.Register8     // 0x3DB
	MB29_D6 volatile.Register8     // 0x3DC
	MB29_D7 volatile.Register8     // 0x3DD
	MB29_TS volatile.Register16    // 0x3DE
	MB30_ID volatile.Register32    // 0x3E0
	MB30_DL volatile.Register16    // 0x3E4
	MB30_D0 volatile.Register8     // 0x3E6
	MB30_D1 volatile.Register8     // 0x3E7
	MB30_D2 volatile.Register8     // 0x3E8
	MB30_D3 volatile.Register8     // 0x3E9
	MB30_D4 volatile.Register8     // 0x3EA
	MB30_D5 volatile.Register8     // 0x3EB
	MB30_D6 volatile.Register8     // 0x3EC
	MB30_D7 volatile.Register8     // 0x3ED
	MB30_TS volatile.Register16    // 0x3EE
	MB31_ID volatile.Register32    // 0x3F0
	MB31_DL volatile.Register16    // 0x3F4
	MB31_D0 volatile.Register8     // 0x3F6
	MB31_D1 volatile.Register8     // 0x3F7
	MB31_D2 volatile.Register8     // 0x3F8
	MB31_D3 volatile.Register8     // 0x3F9
	MB31_D4 volatile.Register8     // 0x3FA
	MB31_D5 volatile.Register8     // 0x3FB
	MB31_D6 volatile.Register8     // 0x3FC
	MB31_D7 volatile.Register8     // 0x3FD
	MB31_TS volatile.Register16    // 0x3FE
	MKR     [8]volatile.Register32 // 0x400
	FIDCR0  volatile.Register32    // 0x420
	FIDCR1  volatile.Register32    // 0x424
	MKIVLR  volatile.Register32    // 0x428
	MIER    volatile.Register32    // 0x42C
	_       [1008]byte
	MCTL_RX [32]volatile.Register8 // 0x820
	CTLR    volatile.Register16    // 0x840
	STR     volatile.Register16    // 0x842
	BCR     volatile.Register32    // 0x844
	RFCR    volatile.Register8     // 0x848
	RFPCR   volatile.Register8     // 0x849
	TFCR    volatile.Register8     // 0x84A
	TFPCR   volatile.Register8     // 0x84B
	EIER    volatile.Register8     // 0x84C
	EIFR    volatile.Register8     // 0x84D
	RECR    volatile.Register8     // 0x84E
	TECR    volatile.Register8     // 0x84F
	ECSR    volatile.Register8     // 0x850
	CSSR    volatile.Register8     // 0x851
	MSSR    volatile.Register8     // 0x852
	MSMR    volatile.Register8     // 0x853
	TSR     volatile.Register16    // 0x854
	AFSR    volatile.Register16    // 0x856
	TCR     volatile.Register8     // 0x858
}

// CAN0.MB0_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB0_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB0_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB0_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB0_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB0_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB0_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB0_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB0_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB0_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB0_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB0_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB0_DL.Reg, volatile.LoadUint16(&o.MB0_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB0_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB0_DL.Reg) & 0xf
}

// CAN0.MB0_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D0(value uint8) {
	volatile.StoreUint8(&o.MB0_D0.Reg, value)
}
func (o *CAN0_Type) GetMB0_D0() uint8 {
	return volatile.LoadUint8(&o.MB0_D0.Reg)
}

// CAN0.MB0_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D1(value uint8) {
	volatile.StoreUint8(&o.MB0_D1.Reg, value)
}
func (o *CAN0_Type) GetMB0_D1() uint8 {
	return volatile.LoadUint8(&o.MB0_D1.Reg)
}

// CAN0.MB0_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D2(value uint8) {
	volatile.StoreUint8(&o.MB0_D2.Reg, value)
}
func (o *CAN0_Type) GetMB0_D2() uint8 {
	return volatile.LoadUint8(&o.MB0_D2.Reg)
}

// CAN0.MB0_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D3(value uint8) {
	volatile.StoreUint8(&o.MB0_D3.Reg, value)
}
func (o *CAN0_Type) GetMB0_D3() uint8 {
	return volatile.LoadUint8(&o.MB0_D3.Reg)
}

// CAN0.MB0_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D4(value uint8) {
	volatile.StoreUint8(&o.MB0_D4.Reg, value)
}
func (o *CAN0_Type) GetMB0_D4() uint8 {
	return volatile.LoadUint8(&o.MB0_D4.Reg)
}

// CAN0.MB0_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D5(value uint8) {
	volatile.StoreUint8(&o.MB0_D5.Reg, value)
}
func (o *CAN0_Type) GetMB0_D5() uint8 {
	return volatile.LoadUint8(&o.MB0_D5.Reg)
}

// CAN0.MB0_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D6(value uint8) {
	volatile.StoreUint8(&o.MB0_D6.Reg, value)
}
func (o *CAN0_Type) GetMB0_D6() uint8 {
	return volatile.LoadUint8(&o.MB0_D6.Reg)
}

// CAN0.MB0_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB0_D7(value uint8) {
	volatile.StoreUint8(&o.MB0_D7.Reg, value)
}
func (o *CAN0_Type) GetMB0_D7() uint8 {
	return volatile.LoadUint8(&o.MB0_D7.Reg)
}

// CAN0.MB0_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB0_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB0_TS.Reg, volatile.LoadUint16(&o.MB0_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB0_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB0_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB0_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB0_TS.Reg, volatile.LoadUint16(&o.MB0_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB0_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB0_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB1_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB1_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB1_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB1_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB1_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB1_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB1_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB1_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB1_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB1_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB1_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB1_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB1_DL.Reg, volatile.LoadUint16(&o.MB1_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB1_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB1_DL.Reg) & 0xf
}

// CAN0.MB1_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D0(value uint8) {
	volatile.StoreUint8(&o.MB1_D0.Reg, value)
}
func (o *CAN0_Type) GetMB1_D0() uint8 {
	return volatile.LoadUint8(&o.MB1_D0.Reg)
}

// CAN0.MB1_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D1(value uint8) {
	volatile.StoreUint8(&o.MB1_D1.Reg, value)
}
func (o *CAN0_Type) GetMB1_D1() uint8 {
	return volatile.LoadUint8(&o.MB1_D1.Reg)
}

// CAN0.MB1_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D2(value uint8) {
	volatile.StoreUint8(&o.MB1_D2.Reg, value)
}
func (o *CAN0_Type) GetMB1_D2() uint8 {
	return volatile.LoadUint8(&o.MB1_D2.Reg)
}

// CAN0.MB1_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D3(value uint8) {
	volatile.StoreUint8(&o.MB1_D3.Reg, value)
}
func (o *CAN0_Type) GetMB1_D3() uint8 {
	return volatile.LoadUint8(&o.MB1_D3.Reg)
}

// CAN0.MB1_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D4(value uint8) {
	volatile.StoreUint8(&o.MB1_D4.Reg, value)
}
func (o *CAN0_Type) GetMB1_D4() uint8 {
	return volatile.LoadUint8(&o.MB1_D4.Reg)
}

// CAN0.MB1_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D5(value uint8) {
	volatile.StoreUint8(&o.MB1_D5.Reg, value)
}
func (o *CAN0_Type) GetMB1_D5() uint8 {
	return volatile.LoadUint8(&o.MB1_D5.Reg)
}

// CAN0.MB1_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D6(value uint8) {
	volatile.StoreUint8(&o.MB1_D6.Reg, value)
}
func (o *CAN0_Type) GetMB1_D6() uint8 {
	return volatile.LoadUint8(&o.MB1_D6.Reg)
}

// CAN0.MB1_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB1_D7(value uint8) {
	volatile.StoreUint8(&o.MB1_D7.Reg, value)
}
func (o *CAN0_Type) GetMB1_D7() uint8 {
	return volatile.LoadUint8(&o.MB1_D7.Reg)
}

// CAN0.MB1_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB1_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB1_TS.Reg, volatile.LoadUint16(&o.MB1_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB1_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB1_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB1_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB1_TS.Reg, volatile.LoadUint16(&o.MB1_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB1_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB1_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB2_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB2_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB2_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB2_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB2_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB2_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB2_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB2_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB2_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB2_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB2_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB2_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB2_DL.Reg, volatile.LoadUint16(&o.MB2_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB2_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB2_DL.Reg) & 0xf
}

// CAN0.MB2_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D0(value uint8) {
	volatile.StoreUint8(&o.MB2_D0.Reg, value)
}
func (o *CAN0_Type) GetMB2_D0() uint8 {
	return volatile.LoadUint8(&o.MB2_D0.Reg)
}

// CAN0.MB2_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D1(value uint8) {
	volatile.StoreUint8(&o.MB2_D1.Reg, value)
}
func (o *CAN0_Type) GetMB2_D1() uint8 {
	return volatile.LoadUint8(&o.MB2_D1.Reg)
}

// CAN0.MB2_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D2(value uint8) {
	volatile.StoreUint8(&o.MB2_D2.Reg, value)
}
func (o *CAN0_Type) GetMB2_D2() uint8 {
	return volatile.LoadUint8(&o.MB2_D2.Reg)
}

// CAN0.MB2_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D3(value uint8) {
	volatile.StoreUint8(&o.MB2_D3.Reg, value)
}
func (o *CAN0_Type) GetMB2_D3() uint8 {
	return volatile.LoadUint8(&o.MB2_D3.Reg)
}

// CAN0.MB2_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D4(value uint8) {
	volatile.StoreUint8(&o.MB2_D4.Reg, value)
}
func (o *CAN0_Type) GetMB2_D4() uint8 {
	return volatile.LoadUint8(&o.MB2_D4.Reg)
}

// CAN0.MB2_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D5(value uint8) {
	volatile.StoreUint8(&o.MB2_D5.Reg, value)
}
func (o *CAN0_Type) GetMB2_D5() uint8 {
	return volatile.LoadUint8(&o.MB2_D5.Reg)
}

// CAN0.MB2_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D6(value uint8) {
	volatile.StoreUint8(&o.MB2_D6.Reg, value)
}
func (o *CAN0_Type) GetMB2_D6() uint8 {
	return volatile.LoadUint8(&o.MB2_D6.Reg)
}

// CAN0.MB2_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB2_D7(value uint8) {
	volatile.StoreUint8(&o.MB2_D7.Reg, value)
}
func (o *CAN0_Type) GetMB2_D7() uint8 {
	return volatile.LoadUint8(&o.MB2_D7.Reg)
}

// CAN0.MB2_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB2_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB2_TS.Reg, volatile.LoadUint16(&o.MB2_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB2_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB2_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB2_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB2_TS.Reg, volatile.LoadUint16(&o.MB2_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB2_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB2_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB3_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB3_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB3_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB3_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB3_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB3_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB3_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB3_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB3_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB3_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB3_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB3_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB3_DL.Reg, volatile.LoadUint16(&o.MB3_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB3_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB3_DL.Reg) & 0xf
}

// CAN0.MB3_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D0(value uint8) {
	volatile.StoreUint8(&o.MB3_D0.Reg, value)
}
func (o *CAN0_Type) GetMB3_D0() uint8 {
	return volatile.LoadUint8(&o.MB3_D0.Reg)
}

// CAN0.MB3_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D1(value uint8) {
	volatile.StoreUint8(&o.MB3_D1.Reg, value)
}
func (o *CAN0_Type) GetMB3_D1() uint8 {
	return volatile.LoadUint8(&o.MB3_D1.Reg)
}

// CAN0.MB3_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D2(value uint8) {
	volatile.StoreUint8(&o.MB3_D2.Reg, value)
}
func (o *CAN0_Type) GetMB3_D2() uint8 {
	return volatile.LoadUint8(&o.MB3_D2.Reg)
}

// CAN0.MB3_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D3(value uint8) {
	volatile.StoreUint8(&o.MB3_D3.Reg, value)
}
func (o *CAN0_Type) GetMB3_D3() uint8 {
	return volatile.LoadUint8(&o.MB3_D3.Reg)
}

// CAN0.MB3_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D4(value uint8) {
	volatile.StoreUint8(&o.MB3_D4.Reg, value)
}
func (o *CAN0_Type) GetMB3_D4() uint8 {
	return volatile.LoadUint8(&o.MB3_D4.Reg)
}

// CAN0.MB3_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D5(value uint8) {
	volatile.StoreUint8(&o.MB3_D5.Reg, value)
}
func (o *CAN0_Type) GetMB3_D5() uint8 {
	return volatile.LoadUint8(&o.MB3_D5.Reg)
}

// CAN0.MB3_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D6(value uint8) {
	volatile.StoreUint8(&o.MB3_D6.Reg, value)
}
func (o *CAN0_Type) GetMB3_D6() uint8 {
	return volatile.LoadUint8(&o.MB3_D6.Reg)
}

// CAN0.MB3_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB3_D7(value uint8) {
	volatile.StoreUint8(&o.MB3_D7.Reg, value)
}
func (o *CAN0_Type) GetMB3_D7() uint8 {
	return volatile.LoadUint8(&o.MB3_D7.Reg)
}

// CAN0.MB3_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB3_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB3_TS.Reg, volatile.LoadUint16(&o.MB3_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB3_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB3_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB3_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB3_TS.Reg, volatile.LoadUint16(&o.MB3_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB3_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB3_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB4_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB4_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB4_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB4_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB4_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB4_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB4_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB4_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB4_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB4_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB4_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB4_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB4_DL.Reg, volatile.LoadUint16(&o.MB4_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB4_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB4_DL.Reg) & 0xf
}

// CAN0.MB4_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D0(value uint8) {
	volatile.StoreUint8(&o.MB4_D0.Reg, value)
}
func (o *CAN0_Type) GetMB4_D0() uint8 {
	return volatile.LoadUint8(&o.MB4_D0.Reg)
}

// CAN0.MB4_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D1(value uint8) {
	volatile.StoreUint8(&o.MB4_D1.Reg, value)
}
func (o *CAN0_Type) GetMB4_D1() uint8 {
	return volatile.LoadUint8(&o.MB4_D1.Reg)
}

// CAN0.MB4_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D2(value uint8) {
	volatile.StoreUint8(&o.MB4_D2.Reg, value)
}
func (o *CAN0_Type) GetMB4_D2() uint8 {
	return volatile.LoadUint8(&o.MB4_D2.Reg)
}

// CAN0.MB4_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D3(value uint8) {
	volatile.StoreUint8(&o.MB4_D3.Reg, value)
}
func (o *CAN0_Type) GetMB4_D3() uint8 {
	return volatile.LoadUint8(&o.MB4_D3.Reg)
}

// CAN0.MB4_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D4(value uint8) {
	volatile.StoreUint8(&o.MB4_D4.Reg, value)
}
func (o *CAN0_Type) GetMB4_D4() uint8 {
	return volatile.LoadUint8(&o.MB4_D4.Reg)
}

// CAN0.MB4_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D5(value uint8) {
	volatile.StoreUint8(&o.MB4_D5.Reg, value)
}
func (o *CAN0_Type) GetMB4_D5() uint8 {
	return volatile.LoadUint8(&o.MB4_D5.Reg)
}

// CAN0.MB4_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D6(value uint8) {
	volatile.StoreUint8(&o.MB4_D6.Reg, value)
}
func (o *CAN0_Type) GetMB4_D6() uint8 {
	return volatile.LoadUint8(&o.MB4_D6.Reg)
}

// CAN0.MB4_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB4_D7(value uint8) {
	volatile.StoreUint8(&o.MB4_D7.Reg, value)
}
func (o *CAN0_Type) GetMB4_D7() uint8 {
	return volatile.LoadUint8(&o.MB4_D7.Reg)
}

// CAN0.MB4_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB4_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB4_TS.Reg, volatile.LoadUint16(&o.MB4_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB4_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB4_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB4_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB4_TS.Reg, volatile.LoadUint16(&o.MB4_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB4_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB4_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB5_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB5_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB5_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB5_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB5_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB5_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB5_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB5_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB5_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB5_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB5_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB5_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB5_DL.Reg, volatile.LoadUint16(&o.MB5_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB5_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB5_DL.Reg) & 0xf
}

// CAN0.MB5_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D0(value uint8) {
	volatile.StoreUint8(&o.MB5_D0.Reg, value)
}
func (o *CAN0_Type) GetMB5_D0() uint8 {
	return volatile.LoadUint8(&o.MB5_D0.Reg)
}

// CAN0.MB5_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D1(value uint8) {
	volatile.StoreUint8(&o.MB5_D1.Reg, value)
}
func (o *CAN0_Type) GetMB5_D1() uint8 {
	return volatile.LoadUint8(&o.MB5_D1.Reg)
}

// CAN0.MB5_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D2(value uint8) {
	volatile.StoreUint8(&o.MB5_D2.Reg, value)
}
func (o *CAN0_Type) GetMB5_D2() uint8 {
	return volatile.LoadUint8(&o.MB5_D2.Reg)
}

// CAN0.MB5_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D3(value uint8) {
	volatile.StoreUint8(&o.MB5_D3.Reg, value)
}
func (o *CAN0_Type) GetMB5_D3() uint8 {
	return volatile.LoadUint8(&o.MB5_D3.Reg)
}

// CAN0.MB5_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D4(value uint8) {
	volatile.StoreUint8(&o.MB5_D4.Reg, value)
}
func (o *CAN0_Type) GetMB5_D4() uint8 {
	return volatile.LoadUint8(&o.MB5_D4.Reg)
}

// CAN0.MB5_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D5(value uint8) {
	volatile.StoreUint8(&o.MB5_D5.Reg, value)
}
func (o *CAN0_Type) GetMB5_D5() uint8 {
	return volatile.LoadUint8(&o.MB5_D5.Reg)
}

// CAN0.MB5_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D6(value uint8) {
	volatile.StoreUint8(&o.MB5_D6.Reg, value)
}
func (o *CAN0_Type) GetMB5_D6() uint8 {
	return volatile.LoadUint8(&o.MB5_D6.Reg)
}

// CAN0.MB5_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB5_D7(value uint8) {
	volatile.StoreUint8(&o.MB5_D7.Reg, value)
}
func (o *CAN0_Type) GetMB5_D7() uint8 {
	return volatile.LoadUint8(&o.MB5_D7.Reg)
}

// CAN0.MB5_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB5_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB5_TS.Reg, volatile.LoadUint16(&o.MB5_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB5_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB5_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB5_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB5_TS.Reg, volatile.LoadUint16(&o.MB5_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB5_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB5_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB6_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB6_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB6_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB6_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB6_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB6_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB6_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB6_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB6_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB6_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB6_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB6_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB6_DL.Reg, volatile.LoadUint16(&o.MB6_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB6_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB6_DL.Reg) & 0xf
}

// CAN0.MB6_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D0(value uint8) {
	volatile.StoreUint8(&o.MB6_D0.Reg, value)
}
func (o *CAN0_Type) GetMB6_D0() uint8 {
	return volatile.LoadUint8(&o.MB6_D0.Reg)
}

// CAN0.MB6_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D1(value uint8) {
	volatile.StoreUint8(&o.MB6_D1.Reg, value)
}
func (o *CAN0_Type) GetMB6_D1() uint8 {
	return volatile.LoadUint8(&o.MB6_D1.Reg)
}

// CAN0.MB6_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D2(value uint8) {
	volatile.StoreUint8(&o.MB6_D2.Reg, value)
}
func (o *CAN0_Type) GetMB6_D2() uint8 {
	return volatile.LoadUint8(&o.MB6_D2.Reg)
}

// CAN0.MB6_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D3(value uint8) {
	volatile.StoreUint8(&o.MB6_D3.Reg, value)
}
func (o *CAN0_Type) GetMB6_D3() uint8 {
	return volatile.LoadUint8(&o.MB6_D3.Reg)
}

// CAN0.MB6_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D4(value uint8) {
	volatile.StoreUint8(&o.MB6_D4.Reg, value)
}
func (o *CAN0_Type) GetMB6_D4() uint8 {
	return volatile.LoadUint8(&o.MB6_D4.Reg)
}

// CAN0.MB6_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D5(value uint8) {
	volatile.StoreUint8(&o.MB6_D5.Reg, value)
}
func (o *CAN0_Type) GetMB6_D5() uint8 {
	return volatile.LoadUint8(&o.MB6_D5.Reg)
}

// CAN0.MB6_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D6(value uint8) {
	volatile.StoreUint8(&o.MB6_D6.Reg, value)
}
func (o *CAN0_Type) GetMB6_D6() uint8 {
	return volatile.LoadUint8(&o.MB6_D6.Reg)
}

// CAN0.MB6_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB6_D7(value uint8) {
	volatile.StoreUint8(&o.MB6_D7.Reg, value)
}
func (o *CAN0_Type) GetMB6_D7() uint8 {
	return volatile.LoadUint8(&o.MB6_D7.Reg)
}

// CAN0.MB6_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB6_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB6_TS.Reg, volatile.LoadUint16(&o.MB6_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB6_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB6_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB6_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB6_TS.Reg, volatile.LoadUint16(&o.MB6_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB6_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB6_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB7_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB7_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB7_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB7_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB7_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB7_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB7_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB7_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB7_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB7_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB7_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB7_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB7_DL.Reg, volatile.LoadUint16(&o.MB7_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB7_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB7_DL.Reg) & 0xf
}

// CAN0.MB7_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D0(value uint8) {
	volatile.StoreUint8(&o.MB7_D0.Reg, value)
}
func (o *CAN0_Type) GetMB7_D0() uint8 {
	return volatile.LoadUint8(&o.MB7_D0.Reg)
}

// CAN0.MB7_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D1(value uint8) {
	volatile.StoreUint8(&o.MB7_D1.Reg, value)
}
func (o *CAN0_Type) GetMB7_D1() uint8 {
	return volatile.LoadUint8(&o.MB7_D1.Reg)
}

// CAN0.MB7_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D2(value uint8) {
	volatile.StoreUint8(&o.MB7_D2.Reg, value)
}
func (o *CAN0_Type) GetMB7_D2() uint8 {
	return volatile.LoadUint8(&o.MB7_D2.Reg)
}

// CAN0.MB7_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D3(value uint8) {
	volatile.StoreUint8(&o.MB7_D3.Reg, value)
}
func (o *CAN0_Type) GetMB7_D3() uint8 {
	return volatile.LoadUint8(&o.MB7_D3.Reg)
}

// CAN0.MB7_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D4(value uint8) {
	volatile.StoreUint8(&o.MB7_D4.Reg, value)
}
func (o *CAN0_Type) GetMB7_D4() uint8 {
	return volatile.LoadUint8(&o.MB7_D4.Reg)
}

// CAN0.MB7_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D5(value uint8) {
	volatile.StoreUint8(&o.MB7_D5.Reg, value)
}
func (o *CAN0_Type) GetMB7_D5() uint8 {
	return volatile.LoadUint8(&o.MB7_D5.Reg)
}

// CAN0.MB7_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D6(value uint8) {
	volatile.StoreUint8(&o.MB7_D6.Reg, value)
}
func (o *CAN0_Type) GetMB7_D6() uint8 {
	return volatile.LoadUint8(&o.MB7_D6.Reg)
}

// CAN0.MB7_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB7_D7(value uint8) {
	volatile.StoreUint8(&o.MB7_D7.Reg, value)
}
func (o *CAN0_Type) GetMB7_D7() uint8 {
	return volatile.LoadUint8(&o.MB7_D7.Reg)
}

// CAN0.MB7_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB7_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB7_TS.Reg, volatile.LoadUint16(&o.MB7_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB7_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB7_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB7_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB7_TS.Reg, volatile.LoadUint16(&o.MB7_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB7_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB7_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB8_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB8_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB8_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB8_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB8_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB8_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB8_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB8_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB8_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB8_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB8_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB8_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB8_DL.Reg, volatile.LoadUint16(&o.MB8_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB8_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB8_DL.Reg) & 0xf
}

// CAN0.MB8_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D0(value uint8) {
	volatile.StoreUint8(&o.MB8_D0.Reg, value)
}
func (o *CAN0_Type) GetMB8_D0() uint8 {
	return volatile.LoadUint8(&o.MB8_D0.Reg)
}

// CAN0.MB8_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D1(value uint8) {
	volatile.StoreUint8(&o.MB8_D1.Reg, value)
}
func (o *CAN0_Type) GetMB8_D1() uint8 {
	return volatile.LoadUint8(&o.MB8_D1.Reg)
}

// CAN0.MB8_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D2(value uint8) {
	volatile.StoreUint8(&o.MB8_D2.Reg, value)
}
func (o *CAN0_Type) GetMB8_D2() uint8 {
	return volatile.LoadUint8(&o.MB8_D2.Reg)
}

// CAN0.MB8_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D3(value uint8) {
	volatile.StoreUint8(&o.MB8_D3.Reg, value)
}
func (o *CAN0_Type) GetMB8_D3() uint8 {
	return volatile.LoadUint8(&o.MB8_D3.Reg)
}

// CAN0.MB8_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D4(value uint8) {
	volatile.StoreUint8(&o.MB8_D4.Reg, value)
}
func (o *CAN0_Type) GetMB8_D4() uint8 {
	return volatile.LoadUint8(&o.MB8_D4.Reg)
}

// CAN0.MB8_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D5(value uint8) {
	volatile.StoreUint8(&o.MB8_D5.Reg, value)
}
func (o *CAN0_Type) GetMB8_D5() uint8 {
	return volatile.LoadUint8(&o.MB8_D5.Reg)
}

// CAN0.MB8_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D6(value uint8) {
	volatile.StoreUint8(&o.MB8_D6.Reg, value)
}
func (o *CAN0_Type) GetMB8_D6() uint8 {
	return volatile.LoadUint8(&o.MB8_D6.Reg)
}

// CAN0.MB8_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB8_D7(value uint8) {
	volatile.StoreUint8(&o.MB8_D7.Reg, value)
}
func (o *CAN0_Type) GetMB8_D7() uint8 {
	return volatile.LoadUint8(&o.MB8_D7.Reg)
}

// CAN0.MB8_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB8_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB8_TS.Reg, volatile.LoadUint16(&o.MB8_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB8_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB8_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB8_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB8_TS.Reg, volatile.LoadUint16(&o.MB8_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB8_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB8_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB9_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB9_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB9_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB9_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB9_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB9_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB9_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB9_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB9_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB9_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB9_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB9_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB9_DL.Reg, volatile.LoadUint16(&o.MB9_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB9_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB9_DL.Reg) & 0xf
}

// CAN0.MB9_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D0(value uint8) {
	volatile.StoreUint8(&o.MB9_D0.Reg, value)
}
func (o *CAN0_Type) GetMB9_D0() uint8 {
	return volatile.LoadUint8(&o.MB9_D0.Reg)
}

// CAN0.MB9_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D1(value uint8) {
	volatile.StoreUint8(&o.MB9_D1.Reg, value)
}
func (o *CAN0_Type) GetMB9_D1() uint8 {
	return volatile.LoadUint8(&o.MB9_D1.Reg)
}

// CAN0.MB9_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D2(value uint8) {
	volatile.StoreUint8(&o.MB9_D2.Reg, value)
}
func (o *CAN0_Type) GetMB9_D2() uint8 {
	return volatile.LoadUint8(&o.MB9_D2.Reg)
}

// CAN0.MB9_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D3(value uint8) {
	volatile.StoreUint8(&o.MB9_D3.Reg, value)
}
func (o *CAN0_Type) GetMB9_D3() uint8 {
	return volatile.LoadUint8(&o.MB9_D3.Reg)
}

// CAN0.MB9_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D4(value uint8) {
	volatile.StoreUint8(&o.MB9_D4.Reg, value)
}
func (o *CAN0_Type) GetMB9_D4() uint8 {
	return volatile.LoadUint8(&o.MB9_D4.Reg)
}

// CAN0.MB9_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D5(value uint8) {
	volatile.StoreUint8(&o.MB9_D5.Reg, value)
}
func (o *CAN0_Type) GetMB9_D5() uint8 {
	return volatile.LoadUint8(&o.MB9_D5.Reg)
}

// CAN0.MB9_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D6(value uint8) {
	volatile.StoreUint8(&o.MB9_D6.Reg, value)
}
func (o *CAN0_Type) GetMB9_D6() uint8 {
	return volatile.LoadUint8(&o.MB9_D6.Reg)
}

// CAN0.MB9_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB9_D7(value uint8) {
	volatile.StoreUint8(&o.MB9_D7.Reg, value)
}
func (o *CAN0_Type) GetMB9_D7() uint8 {
	return volatile.LoadUint8(&o.MB9_D7.Reg)
}

// CAN0.MB9_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB9_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB9_TS.Reg, volatile.LoadUint16(&o.MB9_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB9_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB9_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB9_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB9_TS.Reg, volatile.LoadUint16(&o.MB9_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB9_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB9_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB10_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB10_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB10_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB10_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB10_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB10_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB10_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB10_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB10_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB10_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB10_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB10_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB10_DL.Reg, volatile.LoadUint16(&o.MB10_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB10_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB10_DL.Reg) & 0xf
}

// CAN0.MB10_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D0(value uint8) {
	volatile.StoreUint8(&o.MB10_D0.Reg, value)
}
func (o *CAN0_Type) GetMB10_D0() uint8 {
	return volatile.LoadUint8(&o.MB10_D0.Reg)
}

// CAN0.MB10_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D1(value uint8) {
	volatile.StoreUint8(&o.MB10_D1.Reg, value)
}
func (o *CAN0_Type) GetMB10_D1() uint8 {
	return volatile.LoadUint8(&o.MB10_D1.Reg)
}

// CAN0.MB10_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D2(value uint8) {
	volatile.StoreUint8(&o.MB10_D2.Reg, value)
}
func (o *CAN0_Type) GetMB10_D2() uint8 {
	return volatile.LoadUint8(&o.MB10_D2.Reg)
}

// CAN0.MB10_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D3(value uint8) {
	volatile.StoreUint8(&o.MB10_D3.Reg, value)
}
func (o *CAN0_Type) GetMB10_D3() uint8 {
	return volatile.LoadUint8(&o.MB10_D3.Reg)
}

// CAN0.MB10_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D4(value uint8) {
	volatile.StoreUint8(&o.MB10_D4.Reg, value)
}
func (o *CAN0_Type) GetMB10_D4() uint8 {
	return volatile.LoadUint8(&o.MB10_D4.Reg)
}

// CAN0.MB10_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D5(value uint8) {
	volatile.StoreUint8(&o.MB10_D5.Reg, value)
}
func (o *CAN0_Type) GetMB10_D5() uint8 {
	return volatile.LoadUint8(&o.MB10_D5.Reg)
}

// CAN0.MB10_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D6(value uint8) {
	volatile.StoreUint8(&o.MB10_D6.Reg, value)
}
func (o *CAN0_Type) GetMB10_D6() uint8 {
	return volatile.LoadUint8(&o.MB10_D6.Reg)
}

// CAN0.MB10_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB10_D7(value uint8) {
	volatile.StoreUint8(&o.MB10_D7.Reg, value)
}
func (o *CAN0_Type) GetMB10_D7() uint8 {
	return volatile.LoadUint8(&o.MB10_D7.Reg)
}

// CAN0.MB10_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB10_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB10_TS.Reg, volatile.LoadUint16(&o.MB10_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB10_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB10_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB10_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB10_TS.Reg, volatile.LoadUint16(&o.MB10_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB10_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB10_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB11_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB11_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB11_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB11_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB11_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB11_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB11_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB11_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB11_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB11_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB11_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB11_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB11_DL.Reg, volatile.LoadUint16(&o.MB11_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB11_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB11_DL.Reg) & 0xf
}

// CAN0.MB11_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D0(value uint8) {
	volatile.StoreUint8(&o.MB11_D0.Reg, value)
}
func (o *CAN0_Type) GetMB11_D0() uint8 {
	return volatile.LoadUint8(&o.MB11_D0.Reg)
}

// CAN0.MB11_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D1(value uint8) {
	volatile.StoreUint8(&o.MB11_D1.Reg, value)
}
func (o *CAN0_Type) GetMB11_D1() uint8 {
	return volatile.LoadUint8(&o.MB11_D1.Reg)
}

// CAN0.MB11_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D2(value uint8) {
	volatile.StoreUint8(&o.MB11_D2.Reg, value)
}
func (o *CAN0_Type) GetMB11_D2() uint8 {
	return volatile.LoadUint8(&o.MB11_D2.Reg)
}

// CAN0.MB11_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D3(value uint8) {
	volatile.StoreUint8(&o.MB11_D3.Reg, value)
}
func (o *CAN0_Type) GetMB11_D3() uint8 {
	return volatile.LoadUint8(&o.MB11_D3.Reg)
}

// CAN0.MB11_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D4(value uint8) {
	volatile.StoreUint8(&o.MB11_D4.Reg, value)
}
func (o *CAN0_Type) GetMB11_D4() uint8 {
	return volatile.LoadUint8(&o.MB11_D4.Reg)
}

// CAN0.MB11_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D5(value uint8) {
	volatile.StoreUint8(&o.MB11_D5.Reg, value)
}
func (o *CAN0_Type) GetMB11_D5() uint8 {
	return volatile.LoadUint8(&o.MB11_D5.Reg)
}

// CAN0.MB11_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D6(value uint8) {
	volatile.StoreUint8(&o.MB11_D6.Reg, value)
}
func (o *CAN0_Type) GetMB11_D6() uint8 {
	return volatile.LoadUint8(&o.MB11_D6.Reg)
}

// CAN0.MB11_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB11_D7(value uint8) {
	volatile.StoreUint8(&o.MB11_D7.Reg, value)
}
func (o *CAN0_Type) GetMB11_D7() uint8 {
	return volatile.LoadUint8(&o.MB11_D7.Reg)
}

// CAN0.MB11_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB11_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB11_TS.Reg, volatile.LoadUint16(&o.MB11_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB11_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB11_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB11_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB11_TS.Reg, volatile.LoadUint16(&o.MB11_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB11_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB11_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB12_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB12_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB12_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB12_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB12_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB12_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB12_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB12_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB12_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB12_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB12_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB12_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB12_DL.Reg, volatile.LoadUint16(&o.MB12_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB12_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB12_DL.Reg) & 0xf
}

// CAN0.MB12_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D0(value uint8) {
	volatile.StoreUint8(&o.MB12_D0.Reg, value)
}
func (o *CAN0_Type) GetMB12_D0() uint8 {
	return volatile.LoadUint8(&o.MB12_D0.Reg)
}

// CAN0.MB12_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D1(value uint8) {
	volatile.StoreUint8(&o.MB12_D1.Reg, value)
}
func (o *CAN0_Type) GetMB12_D1() uint8 {
	return volatile.LoadUint8(&o.MB12_D1.Reg)
}

// CAN0.MB12_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D2(value uint8) {
	volatile.StoreUint8(&o.MB12_D2.Reg, value)
}
func (o *CAN0_Type) GetMB12_D2() uint8 {
	return volatile.LoadUint8(&o.MB12_D2.Reg)
}

// CAN0.MB12_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D3(value uint8) {
	volatile.StoreUint8(&o.MB12_D3.Reg, value)
}
func (o *CAN0_Type) GetMB12_D3() uint8 {
	return volatile.LoadUint8(&o.MB12_D3.Reg)
}

// CAN0.MB12_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D4(value uint8) {
	volatile.StoreUint8(&o.MB12_D4.Reg, value)
}
func (o *CAN0_Type) GetMB12_D4() uint8 {
	return volatile.LoadUint8(&o.MB12_D4.Reg)
}

// CAN0.MB12_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D5(value uint8) {
	volatile.StoreUint8(&o.MB12_D5.Reg, value)
}
func (o *CAN0_Type) GetMB12_D5() uint8 {
	return volatile.LoadUint8(&o.MB12_D5.Reg)
}

// CAN0.MB12_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D6(value uint8) {
	volatile.StoreUint8(&o.MB12_D6.Reg, value)
}
func (o *CAN0_Type) GetMB12_D6() uint8 {
	return volatile.LoadUint8(&o.MB12_D6.Reg)
}

// CAN0.MB12_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB12_D7(value uint8) {
	volatile.StoreUint8(&o.MB12_D7.Reg, value)
}
func (o *CAN0_Type) GetMB12_D7() uint8 {
	return volatile.LoadUint8(&o.MB12_D7.Reg)
}

// CAN0.MB12_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB12_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB12_TS.Reg, volatile.LoadUint16(&o.MB12_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB12_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB12_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB12_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB12_TS.Reg, volatile.LoadUint16(&o.MB12_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB12_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB12_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB13_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB13_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB13_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB13_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB13_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB13_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB13_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB13_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB13_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB13_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB13_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB13_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB13_DL.Reg, volatile.LoadUint16(&o.MB13_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB13_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB13_DL.Reg) & 0xf
}

// CAN0.MB13_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D0(value uint8) {
	volatile.StoreUint8(&o.MB13_D0.Reg, value)
}
func (o *CAN0_Type) GetMB13_D0() uint8 {
	return volatile.LoadUint8(&o.MB13_D0.Reg)
}

// CAN0.MB13_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D1(value uint8) {
	volatile.StoreUint8(&o.MB13_D1.Reg, value)
}
func (o *CAN0_Type) GetMB13_D1() uint8 {
	return volatile.LoadUint8(&o.MB13_D1.Reg)
}

// CAN0.MB13_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D2(value uint8) {
	volatile.StoreUint8(&o.MB13_D2.Reg, value)
}
func (o *CAN0_Type) GetMB13_D2() uint8 {
	return volatile.LoadUint8(&o.MB13_D2.Reg)
}

// CAN0.MB13_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D3(value uint8) {
	volatile.StoreUint8(&o.MB13_D3.Reg, value)
}
func (o *CAN0_Type) GetMB13_D3() uint8 {
	return volatile.LoadUint8(&o.MB13_D3.Reg)
}

// CAN0.MB13_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D4(value uint8) {
	volatile.StoreUint8(&o.MB13_D4.Reg, value)
}
func (o *CAN0_Type) GetMB13_D4() uint8 {
	return volatile.LoadUint8(&o.MB13_D4.Reg)
}

// CAN0.MB13_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D5(value uint8) {
	volatile.StoreUint8(&o.MB13_D5.Reg, value)
}
func (o *CAN0_Type) GetMB13_D5() uint8 {
	return volatile.LoadUint8(&o.MB13_D5.Reg)
}

// CAN0.MB13_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D6(value uint8) {
	volatile.StoreUint8(&o.MB13_D6.Reg, value)
}
func (o *CAN0_Type) GetMB13_D6() uint8 {
	return volatile.LoadUint8(&o.MB13_D6.Reg)
}

// CAN0.MB13_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB13_D7(value uint8) {
	volatile.StoreUint8(&o.MB13_D7.Reg, value)
}
func (o *CAN0_Type) GetMB13_D7() uint8 {
	return volatile.LoadUint8(&o.MB13_D7.Reg)
}

// CAN0.MB13_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB13_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB13_TS.Reg, volatile.LoadUint16(&o.MB13_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB13_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB13_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB13_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB13_TS.Reg, volatile.LoadUint16(&o.MB13_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB13_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB13_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB14_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB14_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB14_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB14_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB14_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB14_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB14_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB14_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB14_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB14_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB14_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB14_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB14_DL.Reg, volatile.LoadUint16(&o.MB14_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB14_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB14_DL.Reg) & 0xf
}

// CAN0.MB14_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D0(value uint8) {
	volatile.StoreUint8(&o.MB14_D0.Reg, value)
}
func (o *CAN0_Type) GetMB14_D0() uint8 {
	return volatile.LoadUint8(&o.MB14_D0.Reg)
}

// CAN0.MB14_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D1(value uint8) {
	volatile.StoreUint8(&o.MB14_D1.Reg, value)
}
func (o *CAN0_Type) GetMB14_D1() uint8 {
	return volatile.LoadUint8(&o.MB14_D1.Reg)
}

// CAN0.MB14_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D2(value uint8) {
	volatile.StoreUint8(&o.MB14_D2.Reg, value)
}
func (o *CAN0_Type) GetMB14_D2() uint8 {
	return volatile.LoadUint8(&o.MB14_D2.Reg)
}

// CAN0.MB14_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D3(value uint8) {
	volatile.StoreUint8(&o.MB14_D3.Reg, value)
}
func (o *CAN0_Type) GetMB14_D3() uint8 {
	return volatile.LoadUint8(&o.MB14_D3.Reg)
}

// CAN0.MB14_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D4(value uint8) {
	volatile.StoreUint8(&o.MB14_D4.Reg, value)
}
func (o *CAN0_Type) GetMB14_D4() uint8 {
	return volatile.LoadUint8(&o.MB14_D4.Reg)
}

// CAN0.MB14_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D5(value uint8) {
	volatile.StoreUint8(&o.MB14_D5.Reg, value)
}
func (o *CAN0_Type) GetMB14_D5() uint8 {
	return volatile.LoadUint8(&o.MB14_D5.Reg)
}

// CAN0.MB14_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D6(value uint8) {
	volatile.StoreUint8(&o.MB14_D6.Reg, value)
}
func (o *CAN0_Type) GetMB14_D6() uint8 {
	return volatile.LoadUint8(&o.MB14_D6.Reg)
}

// CAN0.MB14_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB14_D7(value uint8) {
	volatile.StoreUint8(&o.MB14_D7.Reg, value)
}
func (o *CAN0_Type) GetMB14_D7() uint8 {
	return volatile.LoadUint8(&o.MB14_D7.Reg)
}

// CAN0.MB14_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB14_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB14_TS.Reg, volatile.LoadUint16(&o.MB14_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB14_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB14_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB14_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB14_TS.Reg, volatile.LoadUint16(&o.MB14_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB14_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB14_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB15_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB15_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB15_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB15_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB15_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB15_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB15_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB15_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB15_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB15_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB15_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB15_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB15_DL.Reg, volatile.LoadUint16(&o.MB15_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB15_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB15_DL.Reg) & 0xf
}

// CAN0.MB15_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D0(value uint8) {
	volatile.StoreUint8(&o.MB15_D0.Reg, value)
}
func (o *CAN0_Type) GetMB15_D0() uint8 {
	return volatile.LoadUint8(&o.MB15_D0.Reg)
}

// CAN0.MB15_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D1(value uint8) {
	volatile.StoreUint8(&o.MB15_D1.Reg, value)
}
func (o *CAN0_Type) GetMB15_D1() uint8 {
	return volatile.LoadUint8(&o.MB15_D1.Reg)
}

// CAN0.MB15_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D2(value uint8) {
	volatile.StoreUint8(&o.MB15_D2.Reg, value)
}
func (o *CAN0_Type) GetMB15_D2() uint8 {
	return volatile.LoadUint8(&o.MB15_D2.Reg)
}

// CAN0.MB15_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D3(value uint8) {
	volatile.StoreUint8(&o.MB15_D3.Reg, value)
}
func (o *CAN0_Type) GetMB15_D3() uint8 {
	return volatile.LoadUint8(&o.MB15_D3.Reg)
}

// CAN0.MB15_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D4(value uint8) {
	volatile.StoreUint8(&o.MB15_D4.Reg, value)
}
func (o *CAN0_Type) GetMB15_D4() uint8 {
	return volatile.LoadUint8(&o.MB15_D4.Reg)
}

// CAN0.MB15_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D5(value uint8) {
	volatile.StoreUint8(&o.MB15_D5.Reg, value)
}
func (o *CAN0_Type) GetMB15_D5() uint8 {
	return volatile.LoadUint8(&o.MB15_D5.Reg)
}

// CAN0.MB15_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D6(value uint8) {
	volatile.StoreUint8(&o.MB15_D6.Reg, value)
}
func (o *CAN0_Type) GetMB15_D6() uint8 {
	return volatile.LoadUint8(&o.MB15_D6.Reg)
}

// CAN0.MB15_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB15_D7(value uint8) {
	volatile.StoreUint8(&o.MB15_D7.Reg, value)
}
func (o *CAN0_Type) GetMB15_D7() uint8 {
	return volatile.LoadUint8(&o.MB15_D7.Reg)
}

// CAN0.MB15_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB15_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB15_TS.Reg, volatile.LoadUint16(&o.MB15_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB15_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB15_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB15_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB15_TS.Reg, volatile.LoadUint16(&o.MB15_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB15_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB15_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB16_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB16_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB16_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB16_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB16_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB16_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB16_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB16_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB16_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB16_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB16_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB16_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB16_DL.Reg, volatile.LoadUint16(&o.MB16_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB16_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB16_DL.Reg) & 0xf
}

// CAN0.MB16_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D0(value uint8) {
	volatile.StoreUint8(&o.MB16_D0.Reg, value)
}
func (o *CAN0_Type) GetMB16_D0() uint8 {
	return volatile.LoadUint8(&o.MB16_D0.Reg)
}

// CAN0.MB16_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D1(value uint8) {
	volatile.StoreUint8(&o.MB16_D1.Reg, value)
}
func (o *CAN0_Type) GetMB16_D1() uint8 {
	return volatile.LoadUint8(&o.MB16_D1.Reg)
}

// CAN0.MB16_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D2(value uint8) {
	volatile.StoreUint8(&o.MB16_D2.Reg, value)
}
func (o *CAN0_Type) GetMB16_D2() uint8 {
	return volatile.LoadUint8(&o.MB16_D2.Reg)
}

// CAN0.MB16_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D3(value uint8) {
	volatile.StoreUint8(&o.MB16_D3.Reg, value)
}
func (o *CAN0_Type) GetMB16_D3() uint8 {
	return volatile.LoadUint8(&o.MB16_D3.Reg)
}

// CAN0.MB16_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D4(value uint8) {
	volatile.StoreUint8(&o.MB16_D4.Reg, value)
}
func (o *CAN0_Type) GetMB16_D4() uint8 {
	return volatile.LoadUint8(&o.MB16_D4.Reg)
}

// CAN0.MB16_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D5(value uint8) {
	volatile.StoreUint8(&o.MB16_D5.Reg, value)
}
func (o *CAN0_Type) GetMB16_D5() uint8 {
	return volatile.LoadUint8(&o.MB16_D5.Reg)
}

// CAN0.MB16_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D6(value uint8) {
	volatile.StoreUint8(&o.MB16_D6.Reg, value)
}
func (o *CAN0_Type) GetMB16_D6() uint8 {
	return volatile.LoadUint8(&o.MB16_D6.Reg)
}

// CAN0.MB16_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB16_D7(value uint8) {
	volatile.StoreUint8(&o.MB16_D7.Reg, value)
}
func (o *CAN0_Type) GetMB16_D7() uint8 {
	return volatile.LoadUint8(&o.MB16_D7.Reg)
}

// CAN0.MB16_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB16_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB16_TS.Reg, volatile.LoadUint16(&o.MB16_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB16_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB16_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB16_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB16_TS.Reg, volatile.LoadUint16(&o.MB16_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB16_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB16_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB17_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB17_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB17_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB17_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB17_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB17_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB17_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB17_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB17_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB17_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB17_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB17_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB17_DL.Reg, volatile.LoadUint16(&o.MB17_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB17_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB17_DL.Reg) & 0xf
}

// CAN0.MB17_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D0(value uint8) {
	volatile.StoreUint8(&o.MB17_D0.Reg, value)
}
func (o *CAN0_Type) GetMB17_D0() uint8 {
	return volatile.LoadUint8(&o.MB17_D0.Reg)
}

// CAN0.MB17_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D1(value uint8) {
	volatile.StoreUint8(&o.MB17_D1.Reg, value)
}
func (o *CAN0_Type) GetMB17_D1() uint8 {
	return volatile.LoadUint8(&o.MB17_D1.Reg)
}

// CAN0.MB17_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D2(value uint8) {
	volatile.StoreUint8(&o.MB17_D2.Reg, value)
}
func (o *CAN0_Type) GetMB17_D2() uint8 {
	return volatile.LoadUint8(&o.MB17_D2.Reg)
}

// CAN0.MB17_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D3(value uint8) {
	volatile.StoreUint8(&o.MB17_D3.Reg, value)
}
func (o *CAN0_Type) GetMB17_D3() uint8 {
	return volatile.LoadUint8(&o.MB17_D3.Reg)
}

// CAN0.MB17_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D4(value uint8) {
	volatile.StoreUint8(&o.MB17_D4.Reg, value)
}
func (o *CAN0_Type) GetMB17_D4() uint8 {
	return volatile.LoadUint8(&o.MB17_D4.Reg)
}

// CAN0.MB17_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D5(value uint8) {
	volatile.StoreUint8(&o.MB17_D5.Reg, value)
}
func (o *CAN0_Type) GetMB17_D5() uint8 {
	return volatile.LoadUint8(&o.MB17_D5.Reg)
}

// CAN0.MB17_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D6(value uint8) {
	volatile.StoreUint8(&o.MB17_D6.Reg, value)
}
func (o *CAN0_Type) GetMB17_D6() uint8 {
	return volatile.LoadUint8(&o.MB17_D6.Reg)
}

// CAN0.MB17_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB17_D7(value uint8) {
	volatile.StoreUint8(&o.MB17_D7.Reg, value)
}
func (o *CAN0_Type) GetMB17_D7() uint8 {
	return volatile.LoadUint8(&o.MB17_D7.Reg)
}

// CAN0.MB17_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB17_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB17_TS.Reg, volatile.LoadUint16(&o.MB17_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB17_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB17_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB17_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB17_TS.Reg, volatile.LoadUint16(&o.MB17_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB17_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB17_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB18_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB18_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB18_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB18_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB18_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB18_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB18_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB18_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB18_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB18_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB18_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB18_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB18_DL.Reg, volatile.LoadUint16(&o.MB18_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB18_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB18_DL.Reg) & 0xf
}

// CAN0.MB18_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D0(value uint8) {
	volatile.StoreUint8(&o.MB18_D0.Reg, value)
}
func (o *CAN0_Type) GetMB18_D0() uint8 {
	return volatile.LoadUint8(&o.MB18_D0.Reg)
}

// CAN0.MB18_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D1(value uint8) {
	volatile.StoreUint8(&o.MB18_D1.Reg, value)
}
func (o *CAN0_Type) GetMB18_D1() uint8 {
	return volatile.LoadUint8(&o.MB18_D1.Reg)
}

// CAN0.MB18_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D2(value uint8) {
	volatile.StoreUint8(&o.MB18_D2.Reg, value)
}
func (o *CAN0_Type) GetMB18_D2() uint8 {
	return volatile.LoadUint8(&o.MB18_D2.Reg)
}

// CAN0.MB18_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D3(value uint8) {
	volatile.StoreUint8(&o.MB18_D3.Reg, value)
}
func (o *CAN0_Type) GetMB18_D3() uint8 {
	return volatile.LoadUint8(&o.MB18_D3.Reg)
}

// CAN0.MB18_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D4(value uint8) {
	volatile.StoreUint8(&o.MB18_D4.Reg, value)
}
func (o *CAN0_Type) GetMB18_D4() uint8 {
	return volatile.LoadUint8(&o.MB18_D4.Reg)
}

// CAN0.MB18_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D5(value uint8) {
	volatile.StoreUint8(&o.MB18_D5.Reg, value)
}
func (o *CAN0_Type) GetMB18_D5() uint8 {
	return volatile.LoadUint8(&o.MB18_D5.Reg)
}

// CAN0.MB18_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D6(value uint8) {
	volatile.StoreUint8(&o.MB18_D6.Reg, value)
}
func (o *CAN0_Type) GetMB18_D6() uint8 {
	return volatile.LoadUint8(&o.MB18_D6.Reg)
}

// CAN0.MB18_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB18_D7(value uint8) {
	volatile.StoreUint8(&o.MB18_D7.Reg, value)
}
func (o *CAN0_Type) GetMB18_D7() uint8 {
	return volatile.LoadUint8(&o.MB18_D7.Reg)
}

// CAN0.MB18_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB18_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB18_TS.Reg, volatile.LoadUint16(&o.MB18_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB18_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB18_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB18_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB18_TS.Reg, volatile.LoadUint16(&o.MB18_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB18_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB18_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB19_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB19_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB19_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB19_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB19_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB19_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB19_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB19_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB19_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB19_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB19_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB19_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB19_DL.Reg, volatile.LoadUint16(&o.MB19_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB19_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB19_DL.Reg) & 0xf
}

// CAN0.MB19_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D0(value uint8) {
	volatile.StoreUint8(&o.MB19_D0.Reg, value)
}
func (o *CAN0_Type) GetMB19_D0() uint8 {
	return volatile.LoadUint8(&o.MB19_D0.Reg)
}

// CAN0.MB19_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D1(value uint8) {
	volatile.StoreUint8(&o.MB19_D1.Reg, value)
}
func (o *CAN0_Type) GetMB19_D1() uint8 {
	return volatile.LoadUint8(&o.MB19_D1.Reg)
}

// CAN0.MB19_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D2(value uint8) {
	volatile.StoreUint8(&o.MB19_D2.Reg, value)
}
func (o *CAN0_Type) GetMB19_D2() uint8 {
	return volatile.LoadUint8(&o.MB19_D2.Reg)
}

// CAN0.MB19_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D3(value uint8) {
	volatile.StoreUint8(&o.MB19_D3.Reg, value)
}
func (o *CAN0_Type) GetMB19_D3() uint8 {
	return volatile.LoadUint8(&o.MB19_D3.Reg)
}

// CAN0.MB19_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D4(value uint8) {
	volatile.StoreUint8(&o.MB19_D4.Reg, value)
}
func (o *CAN0_Type) GetMB19_D4() uint8 {
	return volatile.LoadUint8(&o.MB19_D4.Reg)
}

// CAN0.MB19_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D5(value uint8) {
	volatile.StoreUint8(&o.MB19_D5.Reg, value)
}
func (o *CAN0_Type) GetMB19_D5() uint8 {
	return volatile.LoadUint8(&o.MB19_D5.Reg)
}

// CAN0.MB19_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D6(value uint8) {
	volatile.StoreUint8(&o.MB19_D6.Reg, value)
}
func (o *CAN0_Type) GetMB19_D6() uint8 {
	return volatile.LoadUint8(&o.MB19_D6.Reg)
}

// CAN0.MB19_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB19_D7(value uint8) {
	volatile.StoreUint8(&o.MB19_D7.Reg, value)
}
func (o *CAN0_Type) GetMB19_D7() uint8 {
	return volatile.LoadUint8(&o.MB19_D7.Reg)
}

// CAN0.MB19_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB19_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB19_TS.Reg, volatile.LoadUint16(&o.MB19_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB19_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB19_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB19_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB19_TS.Reg, volatile.LoadUint16(&o.MB19_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB19_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB19_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB20_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB20_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB20_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB20_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB20_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB20_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB20_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB20_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB20_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB20_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB20_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB20_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB20_DL.Reg, volatile.LoadUint16(&o.MB20_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB20_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB20_DL.Reg) & 0xf
}

// CAN0.MB20_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D0(value uint8) {
	volatile.StoreUint8(&o.MB20_D0.Reg, value)
}
func (o *CAN0_Type) GetMB20_D0() uint8 {
	return volatile.LoadUint8(&o.MB20_D0.Reg)
}

// CAN0.MB20_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D1(value uint8) {
	volatile.StoreUint8(&o.MB20_D1.Reg, value)
}
func (o *CAN0_Type) GetMB20_D1() uint8 {
	return volatile.LoadUint8(&o.MB20_D1.Reg)
}

// CAN0.MB20_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D2(value uint8) {
	volatile.StoreUint8(&o.MB20_D2.Reg, value)
}
func (o *CAN0_Type) GetMB20_D2() uint8 {
	return volatile.LoadUint8(&o.MB20_D2.Reg)
}

// CAN0.MB20_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D3(value uint8) {
	volatile.StoreUint8(&o.MB20_D3.Reg, value)
}
func (o *CAN0_Type) GetMB20_D3() uint8 {
	return volatile.LoadUint8(&o.MB20_D3.Reg)
}

// CAN0.MB20_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D4(value uint8) {
	volatile.StoreUint8(&o.MB20_D4.Reg, value)
}
func (o *CAN0_Type) GetMB20_D4() uint8 {
	return volatile.LoadUint8(&o.MB20_D4.Reg)
}

// CAN0.MB20_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D5(value uint8) {
	volatile.StoreUint8(&o.MB20_D5.Reg, value)
}
func (o *CAN0_Type) GetMB20_D5() uint8 {
	return volatile.LoadUint8(&o.MB20_D5.Reg)
}

// CAN0.MB20_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D6(value uint8) {
	volatile.StoreUint8(&o.MB20_D6.Reg, value)
}
func (o *CAN0_Type) GetMB20_D6() uint8 {
	return volatile.LoadUint8(&o.MB20_D6.Reg)
}

// CAN0.MB20_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB20_D7(value uint8) {
	volatile.StoreUint8(&o.MB20_D7.Reg, value)
}
func (o *CAN0_Type) GetMB20_D7() uint8 {
	return volatile.LoadUint8(&o.MB20_D7.Reg)
}

// CAN0.MB20_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB20_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB20_TS.Reg, volatile.LoadUint16(&o.MB20_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB20_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB20_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB20_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB20_TS.Reg, volatile.LoadUint16(&o.MB20_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB20_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB20_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB21_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB21_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB21_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB21_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB21_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB21_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB21_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB21_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB21_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB21_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB21_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB21_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB21_DL.Reg, volatile.LoadUint16(&o.MB21_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB21_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB21_DL.Reg) & 0xf
}

// CAN0.MB21_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D0(value uint8) {
	volatile.StoreUint8(&o.MB21_D0.Reg, value)
}
func (o *CAN0_Type) GetMB21_D0() uint8 {
	return volatile.LoadUint8(&o.MB21_D0.Reg)
}

// CAN0.MB21_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D1(value uint8) {
	volatile.StoreUint8(&o.MB21_D1.Reg, value)
}
func (o *CAN0_Type) GetMB21_D1() uint8 {
	return volatile.LoadUint8(&o.MB21_D1.Reg)
}

// CAN0.MB21_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D2(value uint8) {
	volatile.StoreUint8(&o.MB21_D2.Reg, value)
}
func (o *CAN0_Type) GetMB21_D2() uint8 {
	return volatile.LoadUint8(&o.MB21_D2.Reg)
}

// CAN0.MB21_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D3(value uint8) {
	volatile.StoreUint8(&o.MB21_D3.Reg, value)
}
func (o *CAN0_Type) GetMB21_D3() uint8 {
	return volatile.LoadUint8(&o.MB21_D3.Reg)
}

// CAN0.MB21_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D4(value uint8) {
	volatile.StoreUint8(&o.MB21_D4.Reg, value)
}
func (o *CAN0_Type) GetMB21_D4() uint8 {
	return volatile.LoadUint8(&o.MB21_D4.Reg)
}

// CAN0.MB21_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D5(value uint8) {
	volatile.StoreUint8(&o.MB21_D5.Reg, value)
}
func (o *CAN0_Type) GetMB21_D5() uint8 {
	return volatile.LoadUint8(&o.MB21_D5.Reg)
}

// CAN0.MB21_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D6(value uint8) {
	volatile.StoreUint8(&o.MB21_D6.Reg, value)
}
func (o *CAN0_Type) GetMB21_D6() uint8 {
	return volatile.LoadUint8(&o.MB21_D6.Reg)
}

// CAN0.MB21_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB21_D7(value uint8) {
	volatile.StoreUint8(&o.MB21_D7.Reg, value)
}
func (o *CAN0_Type) GetMB21_D7() uint8 {
	return volatile.LoadUint8(&o.MB21_D7.Reg)
}

// CAN0.MB21_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB21_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB21_TS.Reg, volatile.LoadUint16(&o.MB21_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB21_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB21_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB21_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB21_TS.Reg, volatile.LoadUint16(&o.MB21_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB21_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB21_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB22_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB22_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB22_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB22_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB22_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB22_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB22_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB22_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB22_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB22_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB22_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB22_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB22_DL.Reg, volatile.LoadUint16(&o.MB22_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB22_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB22_DL.Reg) & 0xf
}

// CAN0.MB22_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D0(value uint8) {
	volatile.StoreUint8(&o.MB22_D0.Reg, value)
}
func (o *CAN0_Type) GetMB22_D0() uint8 {
	return volatile.LoadUint8(&o.MB22_D0.Reg)
}

// CAN0.MB22_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D1(value uint8) {
	volatile.StoreUint8(&o.MB22_D1.Reg, value)
}
func (o *CAN0_Type) GetMB22_D1() uint8 {
	return volatile.LoadUint8(&o.MB22_D1.Reg)
}

// CAN0.MB22_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D2(value uint8) {
	volatile.StoreUint8(&o.MB22_D2.Reg, value)
}
func (o *CAN0_Type) GetMB22_D2() uint8 {
	return volatile.LoadUint8(&o.MB22_D2.Reg)
}

// CAN0.MB22_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D3(value uint8) {
	volatile.StoreUint8(&o.MB22_D3.Reg, value)
}
func (o *CAN0_Type) GetMB22_D3() uint8 {
	return volatile.LoadUint8(&o.MB22_D3.Reg)
}

// CAN0.MB22_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D4(value uint8) {
	volatile.StoreUint8(&o.MB22_D4.Reg, value)
}
func (o *CAN0_Type) GetMB22_D4() uint8 {
	return volatile.LoadUint8(&o.MB22_D4.Reg)
}

// CAN0.MB22_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D5(value uint8) {
	volatile.StoreUint8(&o.MB22_D5.Reg, value)
}
func (o *CAN0_Type) GetMB22_D5() uint8 {
	return volatile.LoadUint8(&o.MB22_D5.Reg)
}

// CAN0.MB22_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D6(value uint8) {
	volatile.StoreUint8(&o.MB22_D6.Reg, value)
}
func (o *CAN0_Type) GetMB22_D6() uint8 {
	return volatile.LoadUint8(&o.MB22_D6.Reg)
}

// CAN0.MB22_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB22_D7(value uint8) {
	volatile.StoreUint8(&o.MB22_D7.Reg, value)
}
func (o *CAN0_Type) GetMB22_D7() uint8 {
	return volatile.LoadUint8(&o.MB22_D7.Reg)
}

// CAN0.MB22_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB22_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB22_TS.Reg, volatile.LoadUint16(&o.MB22_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB22_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB22_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB22_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB22_TS.Reg, volatile.LoadUint16(&o.MB22_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB22_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB22_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB23_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB23_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB23_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB23_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB23_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB23_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB23_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB23_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB23_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB23_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB23_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB23_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB23_DL.Reg, volatile.LoadUint16(&o.MB23_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB23_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB23_DL.Reg) & 0xf
}

// CAN0.MB23_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D0(value uint8) {
	volatile.StoreUint8(&o.MB23_D0.Reg, value)
}
func (o *CAN0_Type) GetMB23_D0() uint8 {
	return volatile.LoadUint8(&o.MB23_D0.Reg)
}

// CAN0.MB23_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D1(value uint8) {
	volatile.StoreUint8(&o.MB23_D1.Reg, value)
}
func (o *CAN0_Type) GetMB23_D1() uint8 {
	return volatile.LoadUint8(&o.MB23_D1.Reg)
}

// CAN0.MB23_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D2(value uint8) {
	volatile.StoreUint8(&o.MB23_D2.Reg, value)
}
func (o *CAN0_Type) GetMB23_D2() uint8 {
	return volatile.LoadUint8(&o.MB23_D2.Reg)
}

// CAN0.MB23_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D3(value uint8) {
	volatile.StoreUint8(&o.MB23_D3.Reg, value)
}
func (o *CAN0_Type) GetMB23_D3() uint8 {
	return volatile.LoadUint8(&o.MB23_D3.Reg)
}

// CAN0.MB23_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D4(value uint8) {
	volatile.StoreUint8(&o.MB23_D4.Reg, value)
}
func (o *CAN0_Type) GetMB23_D4() uint8 {
	return volatile.LoadUint8(&o.MB23_D4.Reg)
}

// CAN0.MB23_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D5(value uint8) {
	volatile.StoreUint8(&o.MB23_D5.Reg, value)
}
func (o *CAN0_Type) GetMB23_D5() uint8 {
	return volatile.LoadUint8(&o.MB23_D5.Reg)
}

// CAN0.MB23_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D6(value uint8) {
	volatile.StoreUint8(&o.MB23_D6.Reg, value)
}
func (o *CAN0_Type) GetMB23_D6() uint8 {
	return volatile.LoadUint8(&o.MB23_D6.Reg)
}

// CAN0.MB23_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB23_D7(value uint8) {
	volatile.StoreUint8(&o.MB23_D7.Reg, value)
}
func (o *CAN0_Type) GetMB23_D7() uint8 {
	return volatile.LoadUint8(&o.MB23_D7.Reg)
}

// CAN0.MB23_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB23_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB23_TS.Reg, volatile.LoadUint16(&o.MB23_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB23_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB23_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB23_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB23_TS.Reg, volatile.LoadUint16(&o.MB23_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB23_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB23_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB24_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB24_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB24_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB24_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB24_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB24_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB24_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB24_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB24_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB24_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB24_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB24_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB24_DL.Reg, volatile.LoadUint16(&o.MB24_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB24_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB24_DL.Reg) & 0xf
}

// CAN0.MB24_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D0(value uint8) {
	volatile.StoreUint8(&o.MB24_D0.Reg, value)
}
func (o *CAN0_Type) GetMB24_D0() uint8 {
	return volatile.LoadUint8(&o.MB24_D0.Reg)
}

// CAN0.MB24_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D1(value uint8) {
	volatile.StoreUint8(&o.MB24_D1.Reg, value)
}
func (o *CAN0_Type) GetMB24_D1() uint8 {
	return volatile.LoadUint8(&o.MB24_D1.Reg)
}

// CAN0.MB24_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D2(value uint8) {
	volatile.StoreUint8(&o.MB24_D2.Reg, value)
}
func (o *CAN0_Type) GetMB24_D2() uint8 {
	return volatile.LoadUint8(&o.MB24_D2.Reg)
}

// CAN0.MB24_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D3(value uint8) {
	volatile.StoreUint8(&o.MB24_D3.Reg, value)
}
func (o *CAN0_Type) GetMB24_D3() uint8 {
	return volatile.LoadUint8(&o.MB24_D3.Reg)
}

// CAN0.MB24_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D4(value uint8) {
	volatile.StoreUint8(&o.MB24_D4.Reg, value)
}
func (o *CAN0_Type) GetMB24_D4() uint8 {
	return volatile.LoadUint8(&o.MB24_D4.Reg)
}

// CAN0.MB24_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D5(value uint8) {
	volatile.StoreUint8(&o.MB24_D5.Reg, value)
}
func (o *CAN0_Type) GetMB24_D5() uint8 {
	return volatile.LoadUint8(&o.MB24_D5.Reg)
}

// CAN0.MB24_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D6(value uint8) {
	volatile.StoreUint8(&o.MB24_D6.Reg, value)
}
func (o *CAN0_Type) GetMB24_D6() uint8 {
	return volatile.LoadUint8(&o.MB24_D6.Reg)
}

// CAN0.MB24_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB24_D7(value uint8) {
	volatile.StoreUint8(&o.MB24_D7.Reg, value)
}
func (o *CAN0_Type) GetMB24_D7() uint8 {
	return volatile.LoadUint8(&o.MB24_D7.Reg)
}

// CAN0.MB24_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB24_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB24_TS.Reg, volatile.LoadUint16(&o.MB24_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB24_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB24_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB24_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB24_TS.Reg, volatile.LoadUint16(&o.MB24_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB24_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB24_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB25_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB25_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB25_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB25_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB25_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB25_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB25_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB25_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB25_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB25_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB25_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB25_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB25_DL.Reg, volatile.LoadUint16(&o.MB25_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB25_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB25_DL.Reg) & 0xf
}

// CAN0.MB25_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D0(value uint8) {
	volatile.StoreUint8(&o.MB25_D0.Reg, value)
}
func (o *CAN0_Type) GetMB25_D0() uint8 {
	return volatile.LoadUint8(&o.MB25_D0.Reg)
}

// CAN0.MB25_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D1(value uint8) {
	volatile.StoreUint8(&o.MB25_D1.Reg, value)
}
func (o *CAN0_Type) GetMB25_D1() uint8 {
	return volatile.LoadUint8(&o.MB25_D1.Reg)
}

// CAN0.MB25_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D2(value uint8) {
	volatile.StoreUint8(&o.MB25_D2.Reg, value)
}
func (o *CAN0_Type) GetMB25_D2() uint8 {
	return volatile.LoadUint8(&o.MB25_D2.Reg)
}

// CAN0.MB25_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D3(value uint8) {
	volatile.StoreUint8(&o.MB25_D3.Reg, value)
}
func (o *CAN0_Type) GetMB25_D3() uint8 {
	return volatile.LoadUint8(&o.MB25_D3.Reg)
}

// CAN0.MB25_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D4(value uint8) {
	volatile.StoreUint8(&o.MB25_D4.Reg, value)
}
func (o *CAN0_Type) GetMB25_D4() uint8 {
	return volatile.LoadUint8(&o.MB25_D4.Reg)
}

// CAN0.MB25_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D5(value uint8) {
	volatile.StoreUint8(&o.MB25_D5.Reg, value)
}
func (o *CAN0_Type) GetMB25_D5() uint8 {
	return volatile.LoadUint8(&o.MB25_D5.Reg)
}

// CAN0.MB25_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D6(value uint8) {
	volatile.StoreUint8(&o.MB25_D6.Reg, value)
}
func (o *CAN0_Type) GetMB25_D6() uint8 {
	return volatile.LoadUint8(&o.MB25_D6.Reg)
}

// CAN0.MB25_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB25_D7(value uint8) {
	volatile.StoreUint8(&o.MB25_D7.Reg, value)
}
func (o *CAN0_Type) GetMB25_D7() uint8 {
	return volatile.LoadUint8(&o.MB25_D7.Reg)
}

// CAN0.MB25_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB25_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB25_TS.Reg, volatile.LoadUint16(&o.MB25_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB25_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB25_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB25_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB25_TS.Reg, volatile.LoadUint16(&o.MB25_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB25_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB25_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB26_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB26_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB26_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB26_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB26_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB26_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB26_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB26_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB26_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB26_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB26_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB26_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB26_DL.Reg, volatile.LoadUint16(&o.MB26_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB26_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB26_DL.Reg) & 0xf
}

// CAN0.MB26_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D0(value uint8) {
	volatile.StoreUint8(&o.MB26_D0.Reg, value)
}
func (o *CAN0_Type) GetMB26_D0() uint8 {
	return volatile.LoadUint8(&o.MB26_D0.Reg)
}

// CAN0.MB26_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D1(value uint8) {
	volatile.StoreUint8(&o.MB26_D1.Reg, value)
}
func (o *CAN0_Type) GetMB26_D1() uint8 {
	return volatile.LoadUint8(&o.MB26_D1.Reg)
}

// CAN0.MB26_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D2(value uint8) {
	volatile.StoreUint8(&o.MB26_D2.Reg, value)
}
func (o *CAN0_Type) GetMB26_D2() uint8 {
	return volatile.LoadUint8(&o.MB26_D2.Reg)
}

// CAN0.MB26_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D3(value uint8) {
	volatile.StoreUint8(&o.MB26_D3.Reg, value)
}
func (o *CAN0_Type) GetMB26_D3() uint8 {
	return volatile.LoadUint8(&o.MB26_D3.Reg)
}

// CAN0.MB26_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D4(value uint8) {
	volatile.StoreUint8(&o.MB26_D4.Reg, value)
}
func (o *CAN0_Type) GetMB26_D4() uint8 {
	return volatile.LoadUint8(&o.MB26_D4.Reg)
}

// CAN0.MB26_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D5(value uint8) {
	volatile.StoreUint8(&o.MB26_D5.Reg, value)
}
func (o *CAN0_Type) GetMB26_D5() uint8 {
	return volatile.LoadUint8(&o.MB26_D5.Reg)
}

// CAN0.MB26_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D6(value uint8) {
	volatile.StoreUint8(&o.MB26_D6.Reg, value)
}
func (o *CAN0_Type) GetMB26_D6() uint8 {
	return volatile.LoadUint8(&o.MB26_D6.Reg)
}

// CAN0.MB26_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB26_D7(value uint8) {
	volatile.StoreUint8(&o.MB26_D7.Reg, value)
}
func (o *CAN0_Type) GetMB26_D7() uint8 {
	return volatile.LoadUint8(&o.MB26_D7.Reg)
}

// CAN0.MB26_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB26_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB26_TS.Reg, volatile.LoadUint16(&o.MB26_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB26_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB26_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB26_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB26_TS.Reg, volatile.LoadUint16(&o.MB26_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB26_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB26_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB27_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB27_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB27_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB27_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB27_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB27_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB27_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB27_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB27_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB27_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB27_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB27_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB27_DL.Reg, volatile.LoadUint16(&o.MB27_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB27_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB27_DL.Reg) & 0xf
}

// CAN0.MB27_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D0(value uint8) {
	volatile.StoreUint8(&o.MB27_D0.Reg, value)
}
func (o *CAN0_Type) GetMB27_D0() uint8 {
	return volatile.LoadUint8(&o.MB27_D0.Reg)
}

// CAN0.MB27_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D1(value uint8) {
	volatile.StoreUint8(&o.MB27_D1.Reg, value)
}
func (o *CAN0_Type) GetMB27_D1() uint8 {
	return volatile.LoadUint8(&o.MB27_D1.Reg)
}

// CAN0.MB27_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D2(value uint8) {
	volatile.StoreUint8(&o.MB27_D2.Reg, value)
}
func (o *CAN0_Type) GetMB27_D2() uint8 {
	return volatile.LoadUint8(&o.MB27_D2.Reg)
}

// CAN0.MB27_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D3(value uint8) {
	volatile.StoreUint8(&o.MB27_D3.Reg, value)
}
func (o *CAN0_Type) GetMB27_D3() uint8 {
	return volatile.LoadUint8(&o.MB27_D3.Reg)
}

// CAN0.MB27_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D4(value uint8) {
	volatile.StoreUint8(&o.MB27_D4.Reg, value)
}
func (o *CAN0_Type) GetMB27_D4() uint8 {
	return volatile.LoadUint8(&o.MB27_D4.Reg)
}

// CAN0.MB27_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D5(value uint8) {
	volatile.StoreUint8(&o.MB27_D5.Reg, value)
}
func (o *CAN0_Type) GetMB27_D5() uint8 {
	return volatile.LoadUint8(&o.MB27_D5.Reg)
}

// CAN0.MB27_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D6(value uint8) {
	volatile.StoreUint8(&o.MB27_D6.Reg, value)
}
func (o *CAN0_Type) GetMB27_D6() uint8 {
	return volatile.LoadUint8(&o.MB27_D6.Reg)
}

// CAN0.MB27_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB27_D7(value uint8) {
	volatile.StoreUint8(&o.MB27_D7.Reg, value)
}
func (o *CAN0_Type) GetMB27_D7() uint8 {
	return volatile.LoadUint8(&o.MB27_D7.Reg)
}

// CAN0.MB27_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB27_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB27_TS.Reg, volatile.LoadUint16(&o.MB27_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB27_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB27_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB27_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB27_TS.Reg, volatile.LoadUint16(&o.MB27_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB27_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB27_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB28_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB28_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB28_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB28_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB28_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB28_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB28_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB28_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB28_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB28_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB28_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB28_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB28_DL.Reg, volatile.LoadUint16(&o.MB28_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB28_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB28_DL.Reg) & 0xf
}

// CAN0.MB28_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D0(value uint8) {
	volatile.StoreUint8(&o.MB28_D0.Reg, value)
}
func (o *CAN0_Type) GetMB28_D0() uint8 {
	return volatile.LoadUint8(&o.MB28_D0.Reg)
}

// CAN0.MB28_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D1(value uint8) {
	volatile.StoreUint8(&o.MB28_D1.Reg, value)
}
func (o *CAN0_Type) GetMB28_D1() uint8 {
	return volatile.LoadUint8(&o.MB28_D1.Reg)
}

// CAN0.MB28_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D2(value uint8) {
	volatile.StoreUint8(&o.MB28_D2.Reg, value)
}
func (o *CAN0_Type) GetMB28_D2() uint8 {
	return volatile.LoadUint8(&o.MB28_D2.Reg)
}

// CAN0.MB28_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D3(value uint8) {
	volatile.StoreUint8(&o.MB28_D3.Reg, value)
}
func (o *CAN0_Type) GetMB28_D3() uint8 {
	return volatile.LoadUint8(&o.MB28_D3.Reg)
}

// CAN0.MB28_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D4(value uint8) {
	volatile.StoreUint8(&o.MB28_D4.Reg, value)
}
func (o *CAN0_Type) GetMB28_D4() uint8 {
	return volatile.LoadUint8(&o.MB28_D4.Reg)
}

// CAN0.MB28_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D5(value uint8) {
	volatile.StoreUint8(&o.MB28_D5.Reg, value)
}
func (o *CAN0_Type) GetMB28_D5() uint8 {
	return volatile.LoadUint8(&o.MB28_D5.Reg)
}

// CAN0.MB28_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D6(value uint8) {
	volatile.StoreUint8(&o.MB28_D6.Reg, value)
}
func (o *CAN0_Type) GetMB28_D6() uint8 {
	return volatile.LoadUint8(&o.MB28_D6.Reg)
}

// CAN0.MB28_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB28_D7(value uint8) {
	volatile.StoreUint8(&o.MB28_D7.Reg, value)
}
func (o *CAN0_Type) GetMB28_D7() uint8 {
	return volatile.LoadUint8(&o.MB28_D7.Reg)
}

// CAN0.MB28_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB28_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB28_TS.Reg, volatile.LoadUint16(&o.MB28_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB28_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB28_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB28_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB28_TS.Reg, volatile.LoadUint16(&o.MB28_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB28_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB28_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB29_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB29_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB29_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB29_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB29_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB29_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB29_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB29_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB29_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB29_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB29_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB29_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB29_DL.Reg, volatile.LoadUint16(&o.MB29_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB29_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB29_DL.Reg) & 0xf
}

// CAN0.MB29_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D0(value uint8) {
	volatile.StoreUint8(&o.MB29_D0.Reg, value)
}
func (o *CAN0_Type) GetMB29_D0() uint8 {
	return volatile.LoadUint8(&o.MB29_D0.Reg)
}

// CAN0.MB29_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D1(value uint8) {
	volatile.StoreUint8(&o.MB29_D1.Reg, value)
}
func (o *CAN0_Type) GetMB29_D1() uint8 {
	return volatile.LoadUint8(&o.MB29_D1.Reg)
}

// CAN0.MB29_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D2(value uint8) {
	volatile.StoreUint8(&o.MB29_D2.Reg, value)
}
func (o *CAN0_Type) GetMB29_D2() uint8 {
	return volatile.LoadUint8(&o.MB29_D2.Reg)
}

// CAN0.MB29_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D3(value uint8) {
	volatile.StoreUint8(&o.MB29_D3.Reg, value)
}
func (o *CAN0_Type) GetMB29_D3() uint8 {
	return volatile.LoadUint8(&o.MB29_D3.Reg)
}

// CAN0.MB29_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D4(value uint8) {
	volatile.StoreUint8(&o.MB29_D4.Reg, value)
}
func (o *CAN0_Type) GetMB29_D4() uint8 {
	return volatile.LoadUint8(&o.MB29_D4.Reg)
}

// CAN0.MB29_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D5(value uint8) {
	volatile.StoreUint8(&o.MB29_D5.Reg, value)
}
func (o *CAN0_Type) GetMB29_D5() uint8 {
	return volatile.LoadUint8(&o.MB29_D5.Reg)
}

// CAN0.MB29_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D6(value uint8) {
	volatile.StoreUint8(&o.MB29_D6.Reg, value)
}
func (o *CAN0_Type) GetMB29_D6() uint8 {
	return volatile.LoadUint8(&o.MB29_D6.Reg)
}

// CAN0.MB29_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB29_D7(value uint8) {
	volatile.StoreUint8(&o.MB29_D7.Reg, value)
}
func (o *CAN0_Type) GetMB29_D7() uint8 {
	return volatile.LoadUint8(&o.MB29_D7.Reg)
}

// CAN0.MB29_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB29_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB29_TS.Reg, volatile.LoadUint16(&o.MB29_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB29_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB29_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB29_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB29_TS.Reg, volatile.LoadUint16(&o.MB29_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB29_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB29_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB30_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB30_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB30_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB30_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB30_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB30_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB30_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB30_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB30_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB30_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB30_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB30_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB30_DL.Reg, volatile.LoadUint16(&o.MB30_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB30_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB30_DL.Reg) & 0xf
}

// CAN0.MB30_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D0(value uint8) {
	volatile.StoreUint8(&o.MB30_D0.Reg, value)
}
func (o *CAN0_Type) GetMB30_D0() uint8 {
	return volatile.LoadUint8(&o.MB30_D0.Reg)
}

// CAN0.MB30_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D1(value uint8) {
	volatile.StoreUint8(&o.MB30_D1.Reg, value)
}
func (o *CAN0_Type) GetMB30_D1() uint8 {
	return volatile.LoadUint8(&o.MB30_D1.Reg)
}

// CAN0.MB30_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D2(value uint8) {
	volatile.StoreUint8(&o.MB30_D2.Reg, value)
}
func (o *CAN0_Type) GetMB30_D2() uint8 {
	return volatile.LoadUint8(&o.MB30_D2.Reg)
}

// CAN0.MB30_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D3(value uint8) {
	volatile.StoreUint8(&o.MB30_D3.Reg, value)
}
func (o *CAN0_Type) GetMB30_D3() uint8 {
	return volatile.LoadUint8(&o.MB30_D3.Reg)
}

// CAN0.MB30_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D4(value uint8) {
	volatile.StoreUint8(&o.MB30_D4.Reg, value)
}
func (o *CAN0_Type) GetMB30_D4() uint8 {
	return volatile.LoadUint8(&o.MB30_D4.Reg)
}

// CAN0.MB30_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D5(value uint8) {
	volatile.StoreUint8(&o.MB30_D5.Reg, value)
}
func (o *CAN0_Type) GetMB30_D5() uint8 {
	return volatile.LoadUint8(&o.MB30_D5.Reg)
}

// CAN0.MB30_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D6(value uint8) {
	volatile.StoreUint8(&o.MB30_D6.Reg, value)
}
func (o *CAN0_Type) GetMB30_D6() uint8 {
	return volatile.LoadUint8(&o.MB30_D6.Reg)
}

// CAN0.MB30_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB30_D7(value uint8) {
	volatile.StoreUint8(&o.MB30_D7.Reg, value)
}
func (o *CAN0_Type) GetMB30_D7() uint8 {
	return volatile.LoadUint8(&o.MB30_D7.Reg)
}

// CAN0.MB30_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB30_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB30_TS.Reg, volatile.LoadUint16(&o.MB30_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB30_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB30_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB30_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB30_TS.Reg, volatile.LoadUint16(&o.MB30_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB30_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB30_TS.Reg) & 0xff00) >> 8
}

// CAN0.MB31_ID: Mailbox ID Register %s
func (o *CAN0_Type) SetMB31_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB31_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB31_ID.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMB31_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB31_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB31_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB31_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB31_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB31_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x80000000) >> 31
}

// CAN0.MB31_DL: Mailbox Data Length Register %s
func (o *CAN0_Type) SetMB31_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB31_DL.Reg, volatile.LoadUint16(&o.MB31_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB31_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB31_DL.Reg) & 0xf
}

// CAN0.MB31_D0: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D0(value uint8) {
	volatile.StoreUint8(&o.MB31_D0.Reg, value)
}
func (o *CAN0_Type) GetMB31_D0() uint8 {
	return volatile.LoadUint8(&o.MB31_D0.Reg)
}

// CAN0.MB31_D1: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D1(value uint8) {
	volatile.StoreUint8(&o.MB31_D1.Reg, value)
}
func (o *CAN0_Type) GetMB31_D1() uint8 {
	return volatile.LoadUint8(&o.MB31_D1.Reg)
}

// CAN0.MB31_D2: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D2(value uint8) {
	volatile.StoreUint8(&o.MB31_D2.Reg, value)
}
func (o *CAN0_Type) GetMB31_D2() uint8 {
	return volatile.LoadUint8(&o.MB31_D2.Reg)
}

// CAN0.MB31_D3: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D3(value uint8) {
	volatile.StoreUint8(&o.MB31_D3.Reg, value)
}
func (o *CAN0_Type) GetMB31_D3() uint8 {
	return volatile.LoadUint8(&o.MB31_D3.Reg)
}

// CAN0.MB31_D4: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D4(value uint8) {
	volatile.StoreUint8(&o.MB31_D4.Reg, value)
}
func (o *CAN0_Type) GetMB31_D4() uint8 {
	return volatile.LoadUint8(&o.MB31_D4.Reg)
}

// CAN0.MB31_D5: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D5(value uint8) {
	volatile.StoreUint8(&o.MB31_D5.Reg, value)
}
func (o *CAN0_Type) GetMB31_D5() uint8 {
	return volatile.LoadUint8(&o.MB31_D5.Reg)
}

// CAN0.MB31_D6: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D6(value uint8) {
	volatile.StoreUint8(&o.MB31_D6.Reg, value)
}
func (o *CAN0_Type) GetMB31_D6() uint8 {
	return volatile.LoadUint8(&o.MB31_D6.Reg)
}

// CAN0.MB31_D7: Mailbox Data Register %s
func (o *CAN0_Type) SetMB31_D7(value uint8) {
	volatile.StoreUint8(&o.MB31_D7.Reg, value)
}
func (o *CAN0_Type) GetMB31_D7() uint8 {
	return volatile.LoadUint8(&o.MB31_D7.Reg)
}

// CAN0.MB31_TS: Mailbox Time Stamp Register %s
func (o *CAN0_Type) SetMB31_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB31_TS.Reg, volatile.LoadUint16(&o.MB31_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB31_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB31_TS.Reg) & 0xff
}
func (o *CAN0_Type) SetMB31_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB31_TS.Reg, volatile.LoadUint16(&o.MB31_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB31_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB31_TS.Reg) & 0xff00) >> 8
}

// CAN0.MKR: Mask Register %s
func (o *CAN0_Type) SetMKR_EID(idx int, value uint32) {
	volatile.StoreUint32(&o.MKR[idx].Reg, volatile.LoadUint32(&o.MKR[idx].Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMKR_EID(idx int) uint32 {
	return volatile.LoadUint32(&o.MKR[idx].Reg) & 0x3ffff
}
func (o *CAN0_Type) SetMKR_SID(idx int, value uint32) {
	volatile.StoreUint32(&o.MKR[idx].Reg, volatile.LoadUint32(&o.MKR[idx].Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMKR_SID(idx int) uint32 {
	return (volatile.LoadUint32(&o.MKR[idx].Reg) & 0x1ffc0000) >> 18
}

// CAN0.FIDCR0: FIFO Received ID Compare Register %s
func (o *CAN0_Type) SetFIDCR0_EID(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetFIDCR0_EID() uint32 {
	return volatile.LoadUint32(&o.FIDCR0.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetFIDCR0_SID(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetFIDCR0_SID() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetFIDCR0_RTR(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetFIDCR0_RTR() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetFIDCR0_IDE(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetFIDCR0_IDE() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x80000000) >> 31
}

// CAN0.FIDCR1: FIFO Received ID Compare Register %s
func (o *CAN0_Type) SetFIDCR1_EID(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetFIDCR1_EID() uint32 {
	return volatile.LoadUint32(&o.FIDCR1.Reg) & 0x3ffff
}
func (o *CAN0_Type) SetFIDCR1_SID(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetFIDCR1_SID() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetFIDCR1_RTR(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetFIDCR1_RTR() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetFIDCR1_IDE(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetFIDCR1_IDE() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x80000000) >> 31
}

// CAN0.MKIVLR: Mask Invalid Register
func (o *CAN0_Type) SetMKIVLR_MB00(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMKIVLR_MB00() uint32 {
	return volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1
}
func (o *CAN0_Type) SetMKIVLR_MB01(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMKIVLR_MB01() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMKIVLR_MB02(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMKIVLR_MB02() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMKIVLR_MB03(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetMKIVLR_MB03() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetMKIVLR_MB04(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMKIVLR_MB04() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMKIVLR_MB05(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetMKIVLR_MB05() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetMKIVLR_MB06(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMKIVLR_MB06() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMKIVLR_MB07(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMKIVLR_MB07() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMKIVLR_MB08(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetMKIVLR_MB08() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetMKIVLR_MB09(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetMKIVLR_MB09() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetMKIVLR_MB10(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetMKIVLR_MB10() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetMKIVLR_MB11(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetMKIVLR_MB11() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetMKIVLR_MB12(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetMKIVLR_MB12() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetMKIVLR_MB13(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetMKIVLR_MB13() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetMKIVLR_MB14(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetMKIVLR_MB14() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetMKIVLR_MB15(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetMKIVLR_MB15() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetMKIVLR_MB16(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetMKIVLR_MB16() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetMKIVLR_MB17(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetMKIVLR_MB17() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetMKIVLR_MB18(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetMKIVLR_MB18() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetMKIVLR_MB19(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetMKIVLR_MB19() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetMKIVLR_MB20(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetMKIVLR_MB20() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetMKIVLR_MB21(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetMKIVLR_MB21() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetMKIVLR_MB22(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetMKIVLR_MB22() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetMKIVLR_MB23(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetMKIVLR_MB23() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetMKIVLR_MB24(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetMKIVLR_MB24() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetMKIVLR_MB25(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetMKIVLR_MB25() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetMKIVLR_MB26(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetMKIVLR_MB26() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetMKIVLR_MB27(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetMKIVLR_MB27() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetMKIVLR_MB28(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetMKIVLR_MB28() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetMKIVLR_MB29(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMKIVLR_MB29() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMKIVLR_MB30(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMKIVLR_MB30() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMKIVLR_MB31(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMKIVLR_MB31() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80000000) >> 31
}

// CAN0.MIER: Mailbox Interrupt Enable Register
func (o *CAN0_Type) SetMIER_MB00(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMIER_MB00() uint32 {
	return volatile.LoadUint32(&o.MIER.Reg) & 0x1
}
func (o *CAN0_Type) SetMIER_MB01(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMIER_MB01() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMIER_MB02(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMIER_MB02() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMIER_MB03(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetMIER_MB03() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetMIER_MB04(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMIER_MB04() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMIER_MB05(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetMIER_MB05() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetMIER_MB06(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMIER_MB06() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMIER_MB07(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMIER_MB07() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMIER_MB08(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetMIER_MB08() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetMIER_MB09(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetMIER_MB09() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetMIER_MB10(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetMIER_MB10() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetMIER_MB11(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetMIER_MB11() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetMIER_MB12(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetMIER_MB12() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetMIER_MB13(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetMIER_MB13() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetMIER_MB14(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetMIER_MB14() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetMIER_MB15(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetMIER_MB15() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetMIER_MB16(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetMIER_MB16() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetMIER_MB17(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetMIER_MB17() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetMIER_MB18(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetMIER_MB18() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetMIER_MB19(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetMIER_MB19() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetMIER_MB20(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetMIER_MB20() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetMIER_MB21(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetMIER_MB21() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetMIER_MB22(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetMIER_MB22() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetMIER_MB23(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetMIER_MB23() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetMIER_MB24(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetMIER_MB24() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetMIER_MB25(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetMIER_MB25() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetMIER_MB26(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetMIER_MB26() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetMIER_MB27(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetMIER_MB27() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetMIER_MB28(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetMIER_MB28() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetMIER_MB29(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMIER_MB29() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMIER_MB30(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMIER_MB30() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMIER_MB31(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMIER_MB31() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80000000) >> 31
}

// CAN0.MCTL_RX: Message Control Register for Receive
func (o *CAN0_Type) SetMCTL_RX_NEWDATA(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_RX[idx].Reg, volatile.LoadUint8(&o.MCTL_RX[idx].Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMCTL_RX_NEWDATA(idx int) uint8 {
	return volatile.LoadUint8(&o.MCTL_RX[idx].Reg) & 0x1
}
func (o *CAN0_Type) SetMCTL_RX_INVALDATA(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_RX[idx].Reg, volatile.LoadUint8(&o.MCTL_RX[idx].Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMCTL_RX_INVALDATA(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_RX[idx].Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMCTL_RX_MSGLOST(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_RX[idx].Reg, volatile.LoadUint8(&o.MCTL_RX[idx].Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMCTL_RX_MSGLOST(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_RX[idx].Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMCTL_RX_ONESHOT(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_RX[idx].Reg, volatile.LoadUint8(&o.MCTL_RX[idx].Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMCTL_RX_ONESHOT(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_RX[idx].Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMCTL_RX_RECREQ(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_RX[idx].Reg, volatile.LoadUint8(&o.MCTL_RX[idx].Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMCTL_RX_RECREQ(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_RX[idx].Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMCTL_RX_TRMREQ(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_RX[idx].Reg, volatile.LoadUint8(&o.MCTL_RX[idx].Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMCTL_RX_TRMREQ(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_RX[idx].Reg) & 0x80) >> 7
}

// CAN0.CTLR: Control Register
func (o *CAN0_Type) SetCTLR_MBM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetCTLR_MBM() uint16 {
	return volatile.LoadUint16(&o.CTLR.Reg) & 0x1
}
func (o *CAN0_Type) SetCTLR_IDFM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x6)|value<<1)
}
func (o *CAN0_Type) GetCTLR_IDFM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x6) >> 1
}
func (o *CAN0_Type) SetCTLR_MLM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetCTLR_MLM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetCTLR_TPM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetCTLR_TPM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetCTLR_TSRC(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetCTLR_TSRC() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetCTLR_TSPS(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0xc0)|value<<6)
}
func (o *CAN0_Type) GetCTLR_TSPS() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0xc0) >> 6
}
func (o *CAN0_Type) SetCTLR_CANM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x300)|value<<8)
}
func (o *CAN0_Type) GetCTLR_CANM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x300) >> 8
}
func (o *CAN0_Type) SetCTLR_SLPM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetCTLR_SLPM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetCTLR_BOM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x1800)|value<<11)
}
func (o *CAN0_Type) GetCTLR_BOM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x1800) >> 11
}
func (o *CAN0_Type) SetCTLR_RBOC(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetCTLR_RBOC() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x2000) >> 13
}

// CAN0.STR: Status Register
func (o *CAN0_Type) SetSTR_NDST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetSTR_NDST() uint16 {
	return volatile.LoadUint16(&o.STR.Reg) & 0x1
}
func (o *CAN0_Type) SetSTR_SDST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetSTR_SDST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetSTR_RFST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetSTR_RFST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetSTR_TFST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetSTR_TFST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetSTR_NMLST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetSTR_NMLST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetSTR_FMLST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetSTR_FMLST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetSTR_TABST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetSTR_TABST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetSTR_EST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetSTR_EST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetSTR_RSTST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetSTR_RSTST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetSTR_HLTST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetSTR_HLTST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetSTR_SLPST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetSTR_SLPST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetSTR_EPST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetSTR_EPST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetSTR_BOST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetSTR_BOST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetSTR_TRMST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetSTR_TRMST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetSTR_RECST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetSTR_RECST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x4000) >> 14
}

// CAN0.BCR: Bit Configuration Register
func (o *CAN0_Type) SetBCR_CCLKS(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetBCR_CCLKS() uint32 {
	return volatile.LoadUint32(&o.BCR.Reg) & 0x1
}
func (o *CAN0_Type) SetBCR_TSEG2(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x700)|value<<8)
}
func (o *CAN0_Type) GetBCR_TSEG2() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x700) >> 8
}
func (o *CAN0_Type) SetBCR_SJW(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x3000)|value<<12)
}
func (o *CAN0_Type) GetBCR_SJW() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x3000) >> 12
}
func (o *CAN0_Type) SetBCR_BRP(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *CAN0_Type) GetBCR_BRP() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x3ff0000) >> 16
}
func (o *CAN0_Type) SetBCR_TSEG1(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAN0_Type) GetBCR_TSEG1() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0xf0000000) >> 28
}

// CAN0.RFCR: Receive FIFO Control Register
func (o *CAN0_Type) SetRFCR_RFE(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRFCR_RFE() uint8 {
	return volatile.LoadUint8(&o.RFCR.Reg) & 0x1
}
func (o *CAN0_Type) SetRFCR_RFUST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0xe)|value<<1)
}
func (o *CAN0_Type) GetRFCR_RFUST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0xe) >> 1
}
func (o *CAN0_Type) SetRFCR_RFMLF(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRFCR_RFMLF() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRFCR_RFFST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRFCR_RFFST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRFCR_RFWST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRFCR_RFWST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRFCR_RFEST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRFCR_RFEST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x80) >> 7
}

// CAN0.TFCR: Transmit FIFO Control Register
func (o *CAN0_Type) SetTFCR_TFE(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetTFCR_TFE() uint8 {
	return volatile.LoadUint8(&o.TFCR.Reg) & 0x1
}
func (o *CAN0_Type) SetTFCR_TFUST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0xe)|value<<1)
}
func (o *CAN0_Type) GetTFCR_TFUST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0xe) >> 1
}
func (o *CAN0_Type) SetTFCR_TFFST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetTFCR_TFFST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetTFCR_TFEST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetTFCR_TFEST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0x80) >> 7
}

// CAN0.EIER: Error Interrupt Enable Register
func (o *CAN0_Type) SetEIER_BEIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetEIER_BEIE() uint8 {
	return volatile.LoadUint8(&o.EIER.Reg) & 0x1
}
func (o *CAN0_Type) SetEIER_EWIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetEIER_EWIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetEIER_EPIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetEIER_EPIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetEIER_BOEIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetEIER_BOEIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetEIER_BORIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetEIER_BORIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetEIER_ORIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetEIER_ORIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetEIER_OLIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetEIER_OLIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetEIER_BLIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetEIER_BLIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x80) >> 7
}

// CAN0.EIFR: Error Interrupt Factor Judge Register
func (o *CAN0_Type) SetEIFR_BEIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetEIFR_BEIF() uint8 {
	return volatile.LoadUint8(&o.EIFR.Reg) & 0x1
}
func (o *CAN0_Type) SetEIFR_EWIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetEIFR_EWIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetEIFR_EPIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetEIFR_EPIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetEIFR_BOEIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetEIFR_BOEIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetEIFR_BORIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetEIFR_BORIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetEIFR_ORIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetEIFR_ORIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetEIFR_OLIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetEIFR_OLIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetEIFR_BLIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetEIFR_BLIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x80) >> 7
}

// CAN0.ECSR: Error Code Store Register
func (o *CAN0_Type) SetECSR_SEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetECSR_SEF() uint8 {
	return volatile.LoadUint8(&o.ECSR.Reg) & 0x1
}
func (o *CAN0_Type) SetECSR_FEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetECSR_FEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetECSR_AEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetECSR_AEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetECSR_CEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetECSR_CEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetECSR_BE1F(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetECSR_BE1F() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetECSR_BE0F(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetECSR_BE0F() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetECSR_ADEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetECSR_ADEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetECSR_EDPM(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetECSR_EDPM() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x80) >> 7
}

// CAN0.MSSR: Mailbox Search Status Register
func (o *CAN0_Type) SetMSSR_MBNST(value uint8) {
	volatile.StoreUint8(&o.MSSR.Reg, volatile.LoadUint8(&o.MSSR.Reg)&^(0x1f)|value)
}
func (o *CAN0_Type) GetMSSR_MBNST() uint8 {
	return volatile.LoadUint8(&o.MSSR.Reg) & 0x1f
}
func (o *CAN0_Type) SetMSSR_SEST(value uint8) {
	volatile.StoreUint8(&o.MSSR.Reg, volatile.LoadUint8(&o.MSSR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMSSR_SEST() uint8 {
	return (volatile.LoadUint8(&o.MSSR.Reg) & 0x80) >> 7
}

// CAN0.MSMR: Mailbox Search Mode Register
func (o *CAN0_Type) SetMSMR_MBSM(value uint8) {
	volatile.StoreUint8(&o.MSMR.Reg, volatile.LoadUint8(&o.MSMR.Reg)&^(0x3)|value)
}
func (o *CAN0_Type) GetMSMR_MBSM() uint8 {
	return volatile.LoadUint8(&o.MSMR.Reg) & 0x3
}

// CAN0.TCR: Test Control Register
func (o *CAN0_Type) SetTCR_TSTE(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetTCR_TSTE() uint8 {
	return volatile.LoadUint8(&o.TCR.Reg) & 0x1
}
func (o *CAN0_Type) SetTCR_TSTM(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0x6)|value<<1)
}
func (o *CAN0_Type) GetTCR_TSTM() uint8 {
	return (volatile.LoadUint8(&o.TCR.Reg) & 0x6) >> 1
}

// Peripheral Security Control Unit
type PSCU_Type struct {
	_        [4]byte
	PSARB    volatile.Register32 // 0x4
	PSARC    volatile.Register32 // 0x8
	PSARD    volatile.Register32 // 0xC
	PSARE    volatile.Register32 // 0x10
	MSSAR    volatile.Register32 // 0x14
	CFSAMONA volatile.Register32 // 0x18
	CFSAMONB volatile.Register32 // 0x1C
	DFSAMON  volatile.Register32 // 0x20
	SSAMONA  volatile.Register32 // 0x24
	SSAMONB  volatile.Register32 // 0x28
	DLMMON   volatile.Register32 // 0x2C
}

// PSCU.PSARB: Peripheral Security Attribution Register B
func (o *PSCU_Type) SetPSARB_PSARB2(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x4)|value<<2)
}
func (o *PSCU_Type) GetPSARB_PSARB2() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x4) >> 2
}
func (o *PSCU_Type) SetPSARB_PSARB6(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x40)|value<<6)
}
func (o *PSCU_Type) GetPSARB_PSARB6() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x40) >> 6
}
func (o *PSCU_Type) SetPSARB_PSARB8(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x100)|value<<8)
}
func (o *PSCU_Type) GetPSARB_PSARB8() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x100) >> 8
}
func (o *PSCU_Type) SetPSARB_PSARB9(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x200)|value<<9)
}
func (o *PSCU_Type) GetPSARB_PSARB9() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x200) >> 9
}
func (o *PSCU_Type) SetPSARB_PSARB11(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x800)|value<<11)
}
func (o *PSCU_Type) GetPSARB_PSARB11() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x800) >> 11
}
func (o *PSCU_Type) SetPSARB_PSARB15(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x8000)|value<<15)
}
func (o *PSCU_Type) GetPSARB_PSARB15() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x8000) >> 15
}
func (o *PSCU_Type) SetPSARB_PSARB18(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x40000)|value<<18)
}
func (o *PSCU_Type) GetPSARB_PSARB18() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x40000) >> 18
}
func (o *PSCU_Type) SetPSARB_PSARB19(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x80000)|value<<19)
}
func (o *PSCU_Type) GetPSARB_PSARB19() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x80000) >> 19
}
func (o *PSCU_Type) SetPSARB_PSARB22(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x400000)|value<<22)
}
func (o *PSCU_Type) GetPSARB_PSARB22() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x400000) >> 22
}
func (o *PSCU_Type) SetPSARB_PSARB27(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x8000000)|value<<27)
}
func (o *PSCU_Type) GetPSARB_PSARB27() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x8000000) >> 27
}
func (o *PSCU_Type) SetPSARB_PSARB28(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x10000000)|value<<28)
}
func (o *PSCU_Type) GetPSARB_PSARB28() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x10000000) >> 28
}
func (o *PSCU_Type) SetPSARB_PSARB29(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x20000000)|value<<29)
}
func (o *PSCU_Type) GetPSARB_PSARB29() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x20000000) >> 29
}
func (o *PSCU_Type) SetPSARB_PSARB30(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x40000000)|value<<30)
}
func (o *PSCU_Type) GetPSARB_PSARB30() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x40000000) >> 30
}
func (o *PSCU_Type) SetPSARB_PSARB31(value uint32) {
	volatile.StoreUint32(&o.PSARB.Reg, volatile.LoadUint32(&o.PSARB.Reg)&^(0x80000000)|value<<31)
}
func (o *PSCU_Type) GetPSARB_PSARB31() uint32 {
	return (volatile.LoadUint32(&o.PSARB.Reg) & 0x80000000) >> 31
}

// PSCU.PSARC: Peripheral Security Attribution Register C
func (o *PSCU_Type) SetPSARC_PSARC0(value uint32) {
	volatile.StoreUint32(&o.PSARC.Reg, volatile.LoadUint32(&o.PSARC.Reg)&^(0x1)|value)
}
func (o *PSCU_Type) GetPSARC_PSARC0() uint32 {
	return volatile.LoadUint32(&o.PSARC.Reg) & 0x1
}
func (o *PSCU_Type) SetPSARC_PSARC1(value uint32) {
	volatile.StoreUint32(&o.PSARC.Reg, volatile.LoadUint32(&o.PSARC.Reg)&^(0x2)|value<<1)
}
func (o *PSCU_Type) GetPSARC_PSARC1() uint32 {
	return (volatile.LoadUint32(&o.PSARC.Reg) & 0x2) >> 1
}
func (o *PSCU_Type) SetPSARC_PSARC8(value uint32) {
	volatile.StoreUint32(&o.PSARC.Reg, volatile.LoadUint32(&o.PSARC.Reg)&^(0x100)|value<<8)
}
func (o *PSCU_Type) GetPSARC_PSARC8() uint32 {
	return (volatile.LoadUint32(&o.PSARC.Reg) & 0x100) >> 8
}
func (o *PSCU_Type) SetPSARC_PSARC12(value uint32) {
	volatile.StoreUint32(&o.PSARC.Reg, volatile.LoadUint32(&o.PSARC.Reg)&^(0x1000)|value<<12)
}
func (o *PSCU_Type) GetPSARC_PSARC12() uint32 {
	return (volatile.LoadUint32(&o.PSARC.Reg) & 0x1000) >> 12
}
func (o *PSCU_Type) SetPSARC_PSARC13(value uint32) {
	volatile.StoreUint32(&o.PSARC.Reg, volatile.LoadUint32(&o.PSARC.Reg)&^(0x2000)|value<<13)
}
func (o *PSCU_Type) GetPSARC_PSARC13() uint32 {
	return (volatile.LoadUint32(&o.PSARC.Reg) & 0x2000) >> 13
}
func (o *PSCU_Type) SetPSARC_PSARC31(value uint32) {
	volatile.StoreUint32(&o.PSARC.Reg, volatile.LoadUint32(&o.PSARC.Reg)&^(0x80000000)|value<<31)
}
func (o *PSCU_Type) GetPSARC_PSARC31() uint32 {
	return (volatile.LoadUint32(&o.PSARC.Reg) & 0x80000000) >> 31
}

// PSCU.PSARD: Peripheral Security Attribution Register D
func (o *PSCU_Type) SetPSARD_PSARD0(value uint32) {
	volatile.StoreUint32(&o.PSARD.Reg, volatile.LoadUint32(&o.PSARD.Reg)&^(0x1)|value)
}
func (o *PSCU_Type) GetPSARD_PSARD0() uint32 {
	return volatile.LoadUint32(&o.PSARD.Reg) & 0x1
}
func (o *PSCU_Type) SetPSARD_PSARD1(value uint32) {
	volatile.StoreUint32(&o.PSARD.Reg, volatile.LoadUint32(&o.PSARD.Reg)&^(0x2)|value<<1)
}
func (o *PSCU_Type) GetPSARD_PSARD1() uint32 {
	return (volatile.LoadUint32(&o.PSARD.Reg) & 0x2) >> 1
}
func (o *PSCU_Type) SetPSARD_PSARD2(value uint32) {
	volatile.StoreUint32(&o.PSARD.Reg, volatile.LoadUint32(&o.PSARD.Reg)&^(0x4)|value<<2)
}
func (o *PSCU_Type) GetPSARD_PSARD2() uint32 {
	return (volatile.LoadUint32(&o.PSARD.Reg) & 0x4) >> 2
}
func (o *PSCU_Type) SetPSARD_PSARD3(value uint32) {
	volatile.StoreUint32(&o.PSARD.Reg, volatile.LoadUint32(&o.PSARD.Reg)&^(0x8)|value<<3)
}
func (o *PSCU_Type) GetPSARD_PSARD3() uint32 {
	return (volatile.LoadUint32(&o.PSARD.Reg) & 0x8) >> 3
}
func (o *PSCU_Type) SetPSARD_PSARD11(value uint32) {
	volatile.StoreUint32(&o.PSARD.Reg, volatile.LoadUint32(&o.PSARD.Reg)&^(0x800)|value<<11)
}
func (o *PSCU_Type) GetPSARD_PSARD11() uint32 {
	return (volatile.LoadUint32(&o.PSARD.Reg) & 0x800) >> 11
}
func (o *PSCU_Type) SetPSARD_PSARD12(value uint32) {
	volatile.StoreUint32(&o.PSARD.Reg, volatile.LoadUint32(&o.PSARD.Reg)&^(0x1000)|value<<12)
}
func (o *PSCU_Type) GetPSARD_PSARD12() uint32 {
	return (volatile.LoadUint32(&o.PSARD.Reg) & 0x1000) >> 12
}
func (o *PSCU_Type) SetPSARD_PSARD13(value uint32) {
	volatile.StoreUint32(&o.PSARD.Reg, volatile.LoadUint32(&o.PSARD.Reg)&^(0x2000)|value<<13)
}
func (o *PSCU_Type) GetPSARD_PSARD13() uint32 {
	return (volatile.LoadUint32(&o.PSARD.Reg) & 0x2000) >> 13
}
func (o *PSCU_Type) SetPSARD_PSARD14(value uint32) {
	volatile.StoreUint32(&o.PSARD.Reg, volatile.LoadUint32(&o.PSARD.Reg)&^(0x4000)|value<<14)
}
func (o *PSCU_Type) GetPSARD_PSARD14() uint32 {
	return (volatile.LoadUint32(&o.PSARD.Reg) & 0x4000) >> 14
}
func (o *PSCU_Type) SetPSARD_PSARD16(value uint32) {
	volatile.StoreUint32(&o.PSARD.Reg, volatile.LoadUint32(&o.PSARD.Reg)&^(0x10000)|value<<16)
}
func (o *PSCU_Type) GetPSARD_PSARD16() uint32 {
	return (volatile.LoadUint32(&o.PSARD.Reg) & 0x10000) >> 16
}
func (o *PSCU_Type) SetPSARD_PSARD20(value uint32) {
	volatile.StoreUint32(&o.PSARD.Reg, volatile.LoadUint32(&o.PSARD.Reg)&^(0x100000)|value<<20)
}
func (o *PSCU_Type) GetPSARD_PSARD20() uint32 {
	return (volatile.LoadUint32(&o.PSARD.Reg) & 0x100000) >> 20
}

// PSCU.PSARE: Peripheral Security Attribution Register E
func (o *PSCU_Type) SetPSARE_PSARE0(value uint32) {
	volatile.StoreUint32(&o.PSARE.Reg, volatile.LoadUint32(&o.PSARE.Reg)&^(0x1)|value)
}
func (o *PSCU_Type) GetPSARE_PSARE0() uint32 {
	return volatile.LoadUint32(&o.PSARE.Reg) & 0x1
}
func (o *PSCU_Type) SetPSARE_PSARE1(value uint32) {
	volatile.StoreUint32(&o.PSARE.Reg, volatile.LoadUint32(&o.PSARE.Reg)&^(0x2)|value<<1)
}
func (o *PSCU_Type) GetPSARE_PSARE1() uint32 {
	return (volatile.LoadUint32(&o.PSARE.Reg) & 0x2) >> 1
}
func (o *PSCU_Type) SetPSARE_PSARE2(value uint32) {
	volatile.StoreUint32(&o.PSARE.Reg, volatile.LoadUint32(&o.PSARE.Reg)&^(0x4)|value<<2)
}
func (o *PSCU_Type) GetPSARE_PSARE2() uint32 {
	return (volatile.LoadUint32(&o.PSARE.Reg) & 0x4) >> 2
}
func (o *PSCU_Type) SetPSARE_PSARE14(value uint32) {
	volatile.StoreUint32(&o.PSARE.Reg, volatile.LoadUint32(&o.PSARE.Reg)&^(0x4000)|value<<14)
}
func (o *PSCU_Type) GetPSARE_PSARE14() uint32 {
	return (volatile.LoadUint32(&o.PSARE.Reg) & 0x4000) >> 14
}
func (o *PSCU_Type) SetPSARE_PSARE15(value uint32) {
	volatile.StoreUint32(&o.PSARE.Reg, volatile.LoadUint32(&o.PSARE.Reg)&^(0x8000)|value<<15)
}
func (o *PSCU_Type) GetPSARE_PSARE15() uint32 {
	return (volatile.LoadUint32(&o.PSARE.Reg) & 0x8000) >> 15
}
func (o *PSCU_Type) SetPSARE_PSARE24(value uint32) {
	volatile.StoreUint32(&o.PSARE.Reg, volatile.LoadUint32(&o.PSARE.Reg)&^(0x1000000)|value<<24)
}
func (o *PSCU_Type) GetPSARE_PSARE24() uint32 {
	return (volatile.LoadUint32(&o.PSARE.Reg) & 0x1000000) >> 24
}
func (o *PSCU_Type) SetPSARE_PSARE25(value uint32) {
	volatile.StoreUint32(&o.PSARE.Reg, volatile.LoadUint32(&o.PSARE.Reg)&^(0x2000000)|value<<25)
}
func (o *PSCU_Type) GetPSARE_PSARE25() uint32 {
	return (volatile.LoadUint32(&o.PSARE.Reg) & 0x2000000) >> 25
}
func (o *PSCU_Type) SetPSARE_PSARE26(value uint32) {
	volatile.StoreUint32(&o.PSARE.Reg, volatile.LoadUint32(&o.PSARE.Reg)&^(0x4000000)|value<<26)
}
func (o *PSCU_Type) GetPSARE_PSARE26() uint32 {
	return (volatile.LoadUint32(&o.PSARE.Reg) & 0x4000000) >> 26
}
func (o *PSCU_Type) SetPSARE_PSARE27(value uint32) {
	volatile.StoreUint32(&o.PSARE.Reg, volatile.LoadUint32(&o.PSARE.Reg)&^(0x8000000)|value<<27)
}
func (o *PSCU_Type) GetPSARE_PSARE27() uint32 {
	return (volatile.LoadUint32(&o.PSARE.Reg) & 0x8000000) >> 27
}
func (o *PSCU_Type) SetPSARE_PSARE29(value uint32) {
	volatile.StoreUint32(&o.PSARE.Reg, volatile.LoadUint32(&o.PSARE.Reg)&^(0x20000000)|value<<29)
}
func (o *PSCU_Type) GetPSARE_PSARE29() uint32 {
	return (volatile.LoadUint32(&o.PSARE.Reg) & 0x20000000) >> 29
}
func (o *PSCU_Type) SetPSARE_PSARE30(value uint32) {
	volatile.StoreUint32(&o.PSARE.Reg, volatile.LoadUint32(&o.PSARE.Reg)&^(0x40000000)|value<<30)
}
func (o *PSCU_Type) GetPSARE_PSARE30() uint32 {
	return (volatile.LoadUint32(&o.PSARE.Reg) & 0x40000000) >> 30
}

// PSCU.MSSAR: Module Stop Security Attribution Register
func (o *PSCU_Type) SetMSSAR_MSSAR0(value uint32) {
	volatile.StoreUint32(&o.MSSAR.Reg, volatile.LoadUint32(&o.MSSAR.Reg)&^(0x1)|value)
}
func (o *PSCU_Type) GetMSSAR_MSSAR0() uint32 {
	return volatile.LoadUint32(&o.MSSAR.Reg) & 0x1
}
func (o *PSCU_Type) SetMSSAR_MSSAR1(value uint32) {
	volatile.StoreUint32(&o.MSSAR.Reg, volatile.LoadUint32(&o.MSSAR.Reg)&^(0x2)|value<<1)
}
func (o *PSCU_Type) GetMSSAR_MSSAR1() uint32 {
	return (volatile.LoadUint32(&o.MSSAR.Reg) & 0x2) >> 1
}
func (o *PSCU_Type) SetMSSAR_MSSAR2(value uint32) {
	volatile.StoreUint32(&o.MSSAR.Reg, volatile.LoadUint32(&o.MSSAR.Reg)&^(0x4)|value<<2)
}
func (o *PSCU_Type) GetMSSAR_MSSAR2() uint32 {
	return (volatile.LoadUint32(&o.MSSAR.Reg) & 0x4) >> 2
}
func (o *PSCU_Type) SetMSSAR_MSSAR3(value uint32) {
	volatile.StoreUint32(&o.MSSAR.Reg, volatile.LoadUint32(&o.MSSAR.Reg)&^(0x8)|value<<3)
}
func (o *PSCU_Type) GetMSSAR_MSSAR3() uint32 {
	return (volatile.LoadUint32(&o.MSSAR.Reg) & 0x8) >> 3
}

// PSCU.CFSAMONA: Code Flash Security Attribution Monitor Register A
func (o *PSCU_Type) SetCFSAMONA_CFS2(value uint32) {
	volatile.StoreUint32(&o.CFSAMONA.Reg, volatile.LoadUint32(&o.CFSAMONA.Reg)&^(0xff8000)|value<<15)
}
func (o *PSCU_Type) GetCFSAMONA_CFS2() uint32 {
	return (volatile.LoadUint32(&o.CFSAMONA.Reg) & 0xff8000) >> 15
}

// PSCU.CFSAMONB: Code Flash Security Attribution Monitor Register B
func (o *PSCU_Type) SetCFSAMONB_CFS1(value uint32) {
	volatile.StoreUint32(&o.CFSAMONB.Reg, volatile.LoadUint32(&o.CFSAMONB.Reg)&^(0xfffc00)|value<<10)
}
func (o *PSCU_Type) GetCFSAMONB_CFS1() uint32 {
	return (volatile.LoadUint32(&o.CFSAMONB.Reg) & 0xfffc00) >> 10
}

// PSCU.DFSAMON: Data Flash Security Attribution Monitor Register
func (o *PSCU_Type) SetDFSAMON_DFS(value uint32) {
	volatile.StoreUint32(&o.DFSAMON.Reg, volatile.LoadUint32(&o.DFSAMON.Reg)&^(0xfc00)|value<<10)
}
func (o *PSCU_Type) GetDFSAMON_DFS() uint32 {
	return (volatile.LoadUint32(&o.DFSAMON.Reg) & 0xfc00) >> 10
}

// PSCU.SSAMONA: SRAM Security Attribution Monitor Register A
func (o *PSCU_Type) SetSSAMONA_SS2(value uint32) {
	volatile.StoreUint32(&o.SSAMONA.Reg, volatile.LoadUint32(&o.SSAMONA.Reg)&^(0x1fe000)|value<<13)
}
func (o *PSCU_Type) GetSSAMONA_SS2() uint32 {
	return (volatile.LoadUint32(&o.SSAMONA.Reg) & 0x1fe000) >> 13
}

// PSCU.SSAMONB: SRAM Security Attribution Monitor Register B
func (o *PSCU_Type) SetSSAMONB_SS1(value uint32) {
	volatile.StoreUint32(&o.SSAMONB.Reg, volatile.LoadUint32(&o.SSAMONB.Reg)&^(0x1ffc00)|value<<10)
}
func (o *PSCU_Type) GetSSAMONB_SS1() uint32 {
	return (volatile.LoadUint32(&o.SSAMONB.Reg) & 0x1ffc00) >> 10
}

// PSCU.DLMMON: Device Lifecycle Management State Monitor Register
func (o *PSCU_Type) SetDLMMON(value uint32) {
	volatile.StoreUint32(&o.DLMMON.Reg, volatile.LoadUint32(&o.DLMMON.Reg)&^(0xf)|value)
}
func (o *PSCU_Type) GetDLMMON() uint32 {
	return volatile.LoadUint32(&o.DLMMON.Reg) & 0xf
}

// Low Power Asynchronous General Purpose Timer 0
type AGT0_Type struct {
	AGT      volatile.Register16 // 0x0
	AGTCMA   volatile.Register16 // 0x2
	AGTCMB   volatile.Register16 // 0x4
	_        [2]byte
	AGTCR    volatile.Register8 // 0x8
	AGTMR1   volatile.Register8 // 0x9
	AGTMR2   volatile.Register8 // 0xA
	_        byte
	AGTIOC   volatile.Register8 // 0xC
	AGTISR   volatile.Register8 // 0xD
	AGTCMSR  volatile.Register8 // 0xE
	AGTIOSEL volatile.Register8 // 0xF
}

// AGT0.AGTCR: AGT Control Register
func (o *AGT0_Type) SetAGTCR_TSTART(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTCR_TSTART() uint8 {
	return volatile.LoadUint8(&o.AGTCR.Reg) & 0x1
}
func (o *AGT0_Type) SetAGTCR_TCSTF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x2)|value<<1)
}
func (o *AGT0_Type) GetAGTCR_TCSTF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x2) >> 1
}
func (o *AGT0_Type) SetAGTCR_TSTOP(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTCR_TSTOP() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTCR_TEDGF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTCR_TEDGF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x10) >> 4
}
func (o *AGT0_Type) SetAGTCR_TUNDF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x20)|value<<5)
}
func (o *AGT0_Type) GetAGTCR_TUNDF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x20) >> 5
}
func (o *AGT0_Type) SetAGTCR_TCMAF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x40)|value<<6)
}
func (o *AGT0_Type) GetAGTCR_TCMAF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x40) >> 6
}
func (o *AGT0_Type) SetAGTCR_TCMBF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTCR_TCMBF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x80) >> 7
}

// AGT0.AGTMR1: AGT Mode Register 1
func (o *AGT0_Type) SetAGTMR1_TMOD(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x7)|value)
}
func (o *AGT0_Type) GetAGTMR1_TMOD() uint8 {
	return volatile.LoadUint8(&o.AGTMR1.Reg) & 0x7
}
func (o *AGT0_Type) SetAGTMR1_TEDGPL(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x8)|value<<3)
}
func (o *AGT0_Type) GetAGTMR1_TEDGPL() uint8 {
	return (volatile.LoadUint8(&o.AGTMR1.Reg) & 0x8) >> 3
}
func (o *AGT0_Type) SetAGTMR1_TCK(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x70)|value<<4)
}
func (o *AGT0_Type) GetAGTMR1_TCK() uint8 {
	return (volatile.LoadUint8(&o.AGTMR1.Reg) & 0x70) >> 4
}

// AGT0.AGTMR2: AGT Mode Register 2
func (o *AGT0_Type) SetAGTMR2_CKS(value uint8) {
	volatile.StoreUint8(&o.AGTMR2.Reg, volatile.LoadUint8(&o.AGTMR2.Reg)&^(0x7)|value)
}
func (o *AGT0_Type) GetAGTMR2_CKS() uint8 {
	return volatile.LoadUint8(&o.AGTMR2.Reg) & 0x7
}
func (o *AGT0_Type) SetAGTMR2_LPM(value uint8) {
	volatile.StoreUint8(&o.AGTMR2.Reg, volatile.LoadUint8(&o.AGTMR2.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTMR2_LPM() uint8 {
	return (volatile.LoadUint8(&o.AGTMR2.Reg) & 0x80) >> 7
}

// AGT0.AGTIOC: AGT I/O Control Register
func (o *AGT0_Type) SetAGTIOC_TEDGSEL(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTIOC_TEDGSEL() uint8 {
	return volatile.LoadUint8(&o.AGTIOC.Reg) & 0x1
}
func (o *AGT0_Type) SetAGTIOC_TOE(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTIOC_TOE() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTIOC_TIPF(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x30)|value<<4)
}
func (o *AGT0_Type) GetAGTIOC_TIPF() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x30) >> 4
}
func (o *AGT0_Type) SetAGTIOC_TIOGT(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0xc0)|value<<6)
}
func (o *AGT0_Type) GetAGTIOC_TIOGT() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0xc0) >> 6
}

// AGT0.AGTISR: AGT Event Pin Select Register
func (o *AGT0_Type) SetAGTISR_EEPS(value uint8) {
	volatile.StoreUint8(&o.AGTISR.Reg, volatile.LoadUint8(&o.AGTISR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTISR_EEPS() uint8 {
	return (volatile.LoadUint8(&o.AGTISR.Reg) & 0x4) >> 2
}

// AGT0.AGTCMSR: AGT Compare Match Function Select Register
func (o *AGT0_Type) SetAGTCMSR_TCMEA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTCMSR_TCMEA() uint8 {
	return volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x1
}
func (o *AGT0_Type) SetAGTCMSR_TOEA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x2)|value<<1)
}
func (o *AGT0_Type) GetAGTCMSR_TOEA() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x2) >> 1
}
func (o *AGT0_Type) SetAGTCMSR_TOPOLA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTCMSR_TOPOLA() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTCMSR_TCMEB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTCMSR_TCMEB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x10) >> 4
}
func (o *AGT0_Type) SetAGTCMSR_TOEB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x20)|value<<5)
}
func (o *AGT0_Type) GetAGTCMSR_TOEB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x20) >> 5
}
func (o *AGT0_Type) SetAGTCMSR_TOPOLB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x40)|value<<6)
}
func (o *AGT0_Type) GetAGTCMSR_TOPOLB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x40) >> 6
}

// AGT0.AGTIOSEL: AGT Pin Select Register
func (o *AGT0_Type) SetAGTIOSEL_SEL(value uint8) {
	volatile.StoreUint8(&o.AGTIOSEL.Reg, volatile.LoadUint8(&o.AGTIOSEL.Reg)&^(0x3)|value)
}
func (o *AGT0_Type) GetAGTIOSEL_SEL() uint8 {
	return volatile.LoadUint8(&o.AGTIOSEL.Reg) & 0x3
}
func (o *AGT0_Type) SetAGTIOSEL_TIES(value uint8) {
	volatile.StoreUint8(&o.AGTIOSEL.Reg, volatile.LoadUint8(&o.AGTIOSEL.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTIOSEL_TIES() uint8 {
	return (volatile.LoadUint8(&o.AGTIOSEL.Reg) & 0x10) >> 4
}

// Cyclic Redundancy Check Calculator
type CRC_Type struct {
	CRCCR0 volatile.Register8 // 0x0
	_      [3]byte
	CRCDIR volatile.Register32 // 0x4
	CRCDOR volatile.Register32 // 0x8
}

// CRC.CRCCR0: CRC Control Register 0
func (o *CRC_Type) SetCRCCR0_GPS(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x7)|value)
}
func (o *CRC_Type) GetCRCCR0_GPS() uint8 {
	return volatile.LoadUint8(&o.CRCCR0.Reg) & 0x7
}
func (o *CRC_Type) SetCRCCR0_LMS(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x40)|value<<6)
}
func (o *CRC_Type) GetCRCCR0_LMS() uint8 {
	return (volatile.LoadUint8(&o.CRCCR0.Reg) & 0x40) >> 6
}
func (o *CRC_Type) SetCRCCR0_DORCLR(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCRCCR0_DORCLR() uint8 {
	return (volatile.LoadUint8(&o.CRCCR0.Reg) & 0x80) >> 7
}

// Data Operation Circuit
type DOC_Type struct {
	DOCR  volatile.Register8 // 0x0
	_     byte
	DODIR volatile.Register16 // 0x2
	DODSR volatile.Register16 // 0x4
}

// DOC.DOCR: DOC Control Register
func (o *DOC_Type) SetDOCR_OMS(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x3)|value)
}
func (o *DOC_Type) GetDOCR_OMS() uint8 {
	return volatile.LoadUint8(&o.DOCR.Reg) & 0x3
}
func (o *DOC_Type) SetDOCR_DCSEL(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x4)|value<<2)
}
func (o *DOC_Type) GetDOCR_DCSEL() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x4) >> 2
}
func (o *DOC_Type) SetDOCR_DOPCF(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x20)|value<<5)
}
func (o *DOC_Type) GetDOCR_DOPCF() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x20) >> 5
}
func (o *DOC_Type) SetDOCR_DOPCFCL(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x40)|value<<6)
}
func (o *DOC_Type) GetDOCR_DOPCFCL() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x40) >> 6
}

// DMA Controller for the Ethernet Controller Channel 0
type EDMAC0_Type struct {
	EDMR   volatile.Register32 // 0x0
	_      [4]byte
	EDTRR  volatile.Register32 // 0x8
	_      [4]byte
	EDRRR  volatile.Register32 // 0x10
	_      [4]byte
	TDLAR  volatile.Register32 // 0x18
	_      [4]byte
	RDLAR  volatile.Register32 // 0x20
	_      [4]byte
	EESR   volatile.Register32 // 0x28
	_      [4]byte
	EESIPR volatile.Register32 // 0x30
	_      [4]byte
	TRSCER volatile.Register32 // 0x38
	_      [4]byte
	RMFCR  volatile.Register32 // 0x40
	_      [4]byte
	TFTR   volatile.Register32 // 0x48
	_      [4]byte
	FDR    volatile.Register32 // 0x50
	_      [4]byte
	RMCR   volatile.Register32 // 0x58
	_      [8]byte
	TFUCR  volatile.Register32 // 0x64
	RFOCR  volatile.Register32 // 0x68
	IOSR   volatile.Register32 // 0x6C
	FCFTR  volatile.Register32 // 0x70
	_      [4]byte
	RPADIR volatile.Register32 // 0x78
	TRIMD  volatile.Register32 // 0x7C
	_      [72]byte
	RBWAR  volatile.Register32 // 0xC8
	RDFAR  volatile.Register32 // 0xCC
	_      [4]byte
	TBRAR  volatile.Register32 // 0xD4
	TDFAR  volatile.Register32 // 0xD8
}

// EDMAC0.EDMR: EDMAC Mode Register
func (o *EDMAC0_Type) SetEDMR_SWR(value uint32) {
	volatile.StoreUint32(&o.EDMR.Reg, volatile.LoadUint32(&o.EDMR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetEDMR_SWR() uint32 {
	return volatile.LoadUint32(&o.EDMR.Reg) & 0x1
}
func (o *EDMAC0_Type) SetEDMR_DL(value uint32) {
	volatile.StoreUint32(&o.EDMR.Reg, volatile.LoadUint32(&o.EDMR.Reg)&^(0x30)|value<<4)
}
func (o *EDMAC0_Type) GetEDMR_DL() uint32 {
	return (volatile.LoadUint32(&o.EDMR.Reg) & 0x30) >> 4
}
func (o *EDMAC0_Type) SetEDMR_DE(value uint32) {
	volatile.StoreUint32(&o.EDMR.Reg, volatile.LoadUint32(&o.EDMR.Reg)&^(0x40)|value<<6)
}
func (o *EDMAC0_Type) GetEDMR_DE() uint32 {
	return (volatile.LoadUint32(&o.EDMR.Reg) & 0x40) >> 6
}

// EDMAC0.EDTRR: EDMAC Transmit Request Register
func (o *EDMAC0_Type) SetEDTRR_TR(value uint32) {
	volatile.StoreUint32(&o.EDTRR.Reg, volatile.LoadUint32(&o.EDTRR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetEDTRR_TR() uint32 {
	return volatile.LoadUint32(&o.EDTRR.Reg) & 0x1
}

// EDMAC0.EDRRR: EDMAC Receive Request Register
func (o *EDMAC0_Type) SetEDRRR_RR(value uint32) {
	volatile.StoreUint32(&o.EDRRR.Reg, volatile.LoadUint32(&o.EDRRR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetEDRRR_RR() uint32 {
	return volatile.LoadUint32(&o.EDRRR.Reg) & 0x1
}

// EDMAC0.EESR: ETHERC/EDMAC Status Register
func (o *EDMAC0_Type) SetEESR_CERF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetEESR_CERF() uint32 {
	return volatile.LoadUint32(&o.EESR.Reg) & 0x1
}
func (o *EDMAC0_Type) SetEESR_PRE(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x2)|value<<1)
}
func (o *EDMAC0_Type) GetEESR_PRE() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x2) >> 1
}
func (o *EDMAC0_Type) SetEESR_RTSF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x4)|value<<2)
}
func (o *EDMAC0_Type) GetEESR_RTSF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x4) >> 2
}
func (o *EDMAC0_Type) SetEESR_RTLF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x8)|value<<3)
}
func (o *EDMAC0_Type) GetEESR_RTLF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x8) >> 3
}
func (o *EDMAC0_Type) SetEESR_RRF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x10)|value<<4)
}
func (o *EDMAC0_Type) GetEESR_RRF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x10) >> 4
}
func (o *EDMAC0_Type) SetEESR_RMAF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x80)|value<<7)
}
func (o *EDMAC0_Type) GetEESR_RMAF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x80) >> 7
}
func (o *EDMAC0_Type) SetEESR_TRO(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x100)|value<<8)
}
func (o *EDMAC0_Type) GetEESR_TRO() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x100) >> 8
}
func (o *EDMAC0_Type) SetEESR_CD(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x200)|value<<9)
}
func (o *EDMAC0_Type) GetEESR_CD() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x200) >> 9
}
func (o *EDMAC0_Type) SetEESR_DLC(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x400)|value<<10)
}
func (o *EDMAC0_Type) GetEESR_DLC() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x400) >> 10
}
func (o *EDMAC0_Type) SetEESR_CND(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x800)|value<<11)
}
func (o *EDMAC0_Type) GetEESR_CND() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x800) >> 11
}
func (o *EDMAC0_Type) SetEESR_RFOF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x10000)|value<<16)
}
func (o *EDMAC0_Type) GetEESR_RFOF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x10000) >> 16
}
func (o *EDMAC0_Type) SetEESR_RDE(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x20000)|value<<17)
}
func (o *EDMAC0_Type) GetEESR_RDE() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x20000) >> 17
}
func (o *EDMAC0_Type) SetEESR_FR(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x40000)|value<<18)
}
func (o *EDMAC0_Type) GetEESR_FR() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x40000) >> 18
}
func (o *EDMAC0_Type) SetEESR_TFUF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x80000)|value<<19)
}
func (o *EDMAC0_Type) GetEESR_TFUF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x80000) >> 19
}
func (o *EDMAC0_Type) SetEESR_TDE(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x100000)|value<<20)
}
func (o *EDMAC0_Type) GetEESR_TDE() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x100000) >> 20
}
func (o *EDMAC0_Type) SetEESR_TC(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x200000)|value<<21)
}
func (o *EDMAC0_Type) GetEESR_TC() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x200000) >> 21
}
func (o *EDMAC0_Type) SetEESR_ECI(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x400000)|value<<22)
}
func (o *EDMAC0_Type) GetEESR_ECI() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x400000) >> 22
}
func (o *EDMAC0_Type) SetEESR_ADE(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x800000)|value<<23)
}
func (o *EDMAC0_Type) GetEESR_ADE() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x800000) >> 23
}
func (o *EDMAC0_Type) SetEESR_RFCOF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x1000000)|value<<24)
}
func (o *EDMAC0_Type) GetEESR_RFCOF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x1000000) >> 24
}
func (o *EDMAC0_Type) SetEESR_RABT(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x2000000)|value<<25)
}
func (o *EDMAC0_Type) GetEESR_RABT() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x2000000) >> 25
}
func (o *EDMAC0_Type) SetEESR_TABT(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x4000000)|value<<26)
}
func (o *EDMAC0_Type) GetEESR_TABT() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x4000000) >> 26
}
func (o *EDMAC0_Type) SetEESR_TWB(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x40000000)|value<<30)
}
func (o *EDMAC0_Type) GetEESR_TWB() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x40000000) >> 30
}

// EDMAC0.EESIPR: ETHERC/EDMAC Status Interrupt Enable Register
func (o *EDMAC0_Type) SetEESIPR_CERFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetEESIPR_CERFIP() uint32 {
	return volatile.LoadUint32(&o.EESIPR.Reg) & 0x1
}
func (o *EDMAC0_Type) SetEESIPR_PREIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x2)|value<<1)
}
func (o *EDMAC0_Type) GetEESIPR_PREIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x2) >> 1
}
func (o *EDMAC0_Type) SetEESIPR_RTSFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x4)|value<<2)
}
func (o *EDMAC0_Type) GetEESIPR_RTSFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x4) >> 2
}
func (o *EDMAC0_Type) SetEESIPR_RTLFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x8)|value<<3)
}
func (o *EDMAC0_Type) GetEESIPR_RTLFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x8) >> 3
}
func (o *EDMAC0_Type) SetEESIPR_RRFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x10)|value<<4)
}
func (o *EDMAC0_Type) GetEESIPR_RRFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x10) >> 4
}
func (o *EDMAC0_Type) SetEESIPR_RMAFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x80)|value<<7)
}
func (o *EDMAC0_Type) GetEESIPR_RMAFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x80) >> 7
}
func (o *EDMAC0_Type) SetEESIPR_TROIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x100)|value<<8)
}
func (o *EDMAC0_Type) GetEESIPR_TROIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x100) >> 8
}
func (o *EDMAC0_Type) SetEESIPR_CDIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x200)|value<<9)
}
func (o *EDMAC0_Type) GetEESIPR_CDIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x200) >> 9
}
func (o *EDMAC0_Type) SetEESIPR_DLCIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x400)|value<<10)
}
func (o *EDMAC0_Type) GetEESIPR_DLCIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x400) >> 10
}
func (o *EDMAC0_Type) SetEESIPR_CNDIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x800)|value<<11)
}
func (o *EDMAC0_Type) GetEESIPR_CNDIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x800) >> 11
}
func (o *EDMAC0_Type) SetEESIPR_RFOFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x10000)|value<<16)
}
func (o *EDMAC0_Type) GetEESIPR_RFOFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x10000) >> 16
}
func (o *EDMAC0_Type) SetEESIPR_RDEIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x20000)|value<<17)
}
func (o *EDMAC0_Type) GetEESIPR_RDEIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x20000) >> 17
}
func (o *EDMAC0_Type) SetEESIPR_FRIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x40000)|value<<18)
}
func (o *EDMAC0_Type) GetEESIPR_FRIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x40000) >> 18
}
func (o *EDMAC0_Type) SetEESIPR_TFUFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x80000)|value<<19)
}
func (o *EDMAC0_Type) GetEESIPR_TFUFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x80000) >> 19
}
func (o *EDMAC0_Type) SetEESIPR_TDEIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x100000)|value<<20)
}
func (o *EDMAC0_Type) GetEESIPR_TDEIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x100000) >> 20
}
func (o *EDMAC0_Type) SetEESIPR_TCIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x200000)|value<<21)
}
func (o *EDMAC0_Type) GetEESIPR_TCIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x200000) >> 21
}
func (o *EDMAC0_Type) SetEESIPR_ECIIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x400000)|value<<22)
}
func (o *EDMAC0_Type) GetEESIPR_ECIIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x400000) >> 22
}
func (o *EDMAC0_Type) SetEESIPR_ADEIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x800000)|value<<23)
}
func (o *EDMAC0_Type) GetEESIPR_ADEIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x800000) >> 23
}
func (o *EDMAC0_Type) SetEESIPR_RFCOFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x1000000)|value<<24)
}
func (o *EDMAC0_Type) GetEESIPR_RFCOFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x1000000) >> 24
}
func (o *EDMAC0_Type) SetEESIPR_RABTIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x2000000)|value<<25)
}
func (o *EDMAC0_Type) GetEESIPR_RABTIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x2000000) >> 25
}
func (o *EDMAC0_Type) SetEESIPR_TABTIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x4000000)|value<<26)
}
func (o *EDMAC0_Type) GetEESIPR_TABTIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x4000000) >> 26
}
func (o *EDMAC0_Type) SetEESIPR_TWBIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x40000000)|value<<30)
}
func (o *EDMAC0_Type) GetEESIPR_TWBIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x40000000) >> 30
}

// EDMAC0.TRSCER: ETHERC/EDMAC Transmit/Receive Status Copy Enable Register
func (o *EDMAC0_Type) SetTRSCER_RRFCE(value uint32) {
	volatile.StoreUint32(&o.TRSCER.Reg, volatile.LoadUint32(&o.TRSCER.Reg)&^(0x10)|value<<4)
}
func (o *EDMAC0_Type) GetTRSCER_RRFCE() uint32 {
	return (volatile.LoadUint32(&o.TRSCER.Reg) & 0x10) >> 4
}
func (o *EDMAC0_Type) SetTRSCER_RMAFCE(value uint32) {
	volatile.StoreUint32(&o.TRSCER.Reg, volatile.LoadUint32(&o.TRSCER.Reg)&^(0x80)|value<<7)
}
func (o *EDMAC0_Type) GetTRSCER_RMAFCE() uint32 {
	return (volatile.LoadUint32(&o.TRSCER.Reg) & 0x80) >> 7
}

// EDMAC0.RMFCR: Missed-Frame Counter Register
func (o *EDMAC0_Type) SetRMFCR_MFC(value uint32) {
	volatile.StoreUint32(&o.RMFCR.Reg, volatile.LoadUint32(&o.RMFCR.Reg)&^(0xffff)|value)
}
func (o *EDMAC0_Type) GetRMFCR_MFC() uint32 {
	return volatile.LoadUint32(&o.RMFCR.Reg) & 0xffff
}

// EDMAC0.TFTR: Transmit FIFO Threshold Register
func (o *EDMAC0_Type) SetTFTR_TFT(value uint32) {
	volatile.StoreUint32(&o.TFTR.Reg, volatile.LoadUint32(&o.TFTR.Reg)&^(0x7ff)|value)
}
func (o *EDMAC0_Type) GetTFTR_TFT() uint32 {
	return volatile.LoadUint32(&o.TFTR.Reg) & 0x7ff
}

// EDMAC0.FDR: FIFO Depth Register
func (o *EDMAC0_Type) SetFDR_RFD(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0x1f)|value)
}
func (o *EDMAC0_Type) GetFDR_RFD() uint32 {
	return volatile.LoadUint32(&o.FDR.Reg) & 0x1f
}
func (o *EDMAC0_Type) SetFDR_TFD(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0x1f00)|value<<8)
}
func (o *EDMAC0_Type) GetFDR_TFD() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0x1f00) >> 8
}

// EDMAC0.RMCR: Receive Method Control Register
func (o *EDMAC0_Type) SetRMCR_RNR(value uint32) {
	volatile.StoreUint32(&o.RMCR.Reg, volatile.LoadUint32(&o.RMCR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetRMCR_RNR() uint32 {
	return volatile.LoadUint32(&o.RMCR.Reg) & 0x1
}

// EDMAC0.TFUCR: Transmit FIFO Underflow Counter
func (o *EDMAC0_Type) SetTFUCR_UNDER(value uint32) {
	volatile.StoreUint32(&o.TFUCR.Reg, volatile.LoadUint32(&o.TFUCR.Reg)&^(0xffff)|value)
}
func (o *EDMAC0_Type) GetTFUCR_UNDER() uint32 {
	return volatile.LoadUint32(&o.TFUCR.Reg) & 0xffff
}

// EDMAC0.RFOCR: Receive FIFO Overflow Counter
func (o *EDMAC0_Type) SetRFOCR_OVER(value uint32) {
	volatile.StoreUint32(&o.RFOCR.Reg, volatile.LoadUint32(&o.RFOCR.Reg)&^(0xffff)|value)
}
func (o *EDMAC0_Type) GetRFOCR_OVER() uint32 {
	return volatile.LoadUint32(&o.RFOCR.Reg) & 0xffff
}

// EDMAC0.IOSR: Independent Output Signal Setting Register
func (o *EDMAC0_Type) SetIOSR_ELB(value uint32) {
	volatile.StoreUint32(&o.IOSR.Reg, volatile.LoadUint32(&o.IOSR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetIOSR_ELB() uint32 {
	return volatile.LoadUint32(&o.IOSR.Reg) & 0x1
}

// EDMAC0.FCFTR: Flow Control Start FIFO Threshold Setting Register
func (o *EDMAC0_Type) SetFCFTR_RFDO(value uint32) {
	volatile.StoreUint32(&o.FCFTR.Reg, volatile.LoadUint32(&o.FCFTR.Reg)&^(0x7)|value)
}
func (o *EDMAC0_Type) GetFCFTR_RFDO() uint32 {
	return volatile.LoadUint32(&o.FCFTR.Reg) & 0x7
}
func (o *EDMAC0_Type) SetFCFTR_RFFO(value uint32) {
	volatile.StoreUint32(&o.FCFTR.Reg, volatile.LoadUint32(&o.FCFTR.Reg)&^(0x70000)|value<<16)
}
func (o *EDMAC0_Type) GetFCFTR_RFFO() uint32 {
	return (volatile.LoadUint32(&o.FCFTR.Reg) & 0x70000) >> 16
}

// EDMAC0.RPADIR: Receive Data Padding Insert Register
func (o *EDMAC0_Type) SetRPADIR_PADR(value uint32) {
	volatile.StoreUint32(&o.RPADIR.Reg, volatile.LoadUint32(&o.RPADIR.Reg)&^(0x3f)|value)
}
func (o *EDMAC0_Type) GetRPADIR_PADR() uint32 {
	return volatile.LoadUint32(&o.RPADIR.Reg) & 0x3f
}
func (o *EDMAC0_Type) SetRPADIR_PADS(value uint32) {
	volatile.StoreUint32(&o.RPADIR.Reg, volatile.LoadUint32(&o.RPADIR.Reg)&^(0x30000)|value<<16)
}
func (o *EDMAC0_Type) GetRPADIR_PADS() uint32 {
	return (volatile.LoadUint32(&o.RPADIR.Reg) & 0x30000) >> 16
}

// EDMAC0.TRIMD: Transmit Interrupt Setting Register
func (o *EDMAC0_Type) SetTRIMD_TIS(value uint32) {
	volatile.StoreUint32(&o.TRIMD.Reg, volatile.LoadUint32(&o.TRIMD.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetTRIMD_TIS() uint32 {
	return volatile.LoadUint32(&o.TRIMD.Reg) & 0x1
}
func (o *EDMAC0_Type) SetTRIMD_TIM(value uint32) {
	volatile.StoreUint32(&o.TRIMD.Reg, volatile.LoadUint32(&o.TRIMD.Reg)&^(0x10)|value<<4)
}
func (o *EDMAC0_Type) GetTRIMD_TIM() uint32 {
	return (volatile.LoadUint32(&o.TRIMD.Reg) & 0x10) >> 4
}

// Ethernet Controller Channel 0
type ETHERC0_Type struct {
	ECMR     volatile.Register32 // 0x0
	_        [4]byte
	RFLR     volatile.Register32 // 0x8
	_        [4]byte
	ECSR     volatile.Register32 // 0x10
	_        [4]byte
	ECSIPR   volatile.Register32 // 0x18
	_        [4]byte
	PIR      volatile.Register32 // 0x20
	_        [4]byte
	PSR      volatile.Register32 // 0x28
	_        [20]byte
	RDMLR    volatile.Register32 // 0x40
	_        [12]byte
	IPGR     volatile.Register32 // 0x50
	APR      volatile.Register32 // 0x54
	MPR      volatile.Register32 // 0x58
	_        [4]byte
	RFCF     volatile.Register32 // 0x60
	TPAUSER  volatile.Register32 // 0x64
	TPAUSECR volatile.Register32 // 0x68
	BCFRR    volatile.Register32 // 0x6C
	_        [80]byte
	MAHR     volatile.Register32 // 0xC0
	_        [4]byte
	MALR     volatile.Register32 // 0xC8
	_        [4]byte
	TROCR    volatile.Register32 // 0xD0
	CDCR     volatile.Register32 // 0xD4
	LCCR     volatile.Register32 // 0xD8
	CNDCR    volatile.Register32 // 0xDC
	_        [4]byte
	CEFCR    volatile.Register32 // 0xE4
	_        [4]byte
	TSFRCR   volatile.Register32 // 0xEC
	TLFRCR   volatile.Register32 // 0xF0
	RFCR     volatile.Register32 // 0xF4
	MAFCR    volatile.Register32 // 0xF8
}

// ETHERC0.ECMR: ETHERC Mode Register
func (o *ETHERC0_Type) SetECMR_PRM(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x1)|value)
}
func (o *ETHERC0_Type) GetECMR_PRM() uint32 {
	return volatile.LoadUint32(&o.ECMR.Reg) & 0x1
}
func (o *ETHERC0_Type) SetECMR_DM(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x2)|value<<1)
}
func (o *ETHERC0_Type) GetECMR_DM() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x2) >> 1
}
func (o *ETHERC0_Type) SetECMR_RTM(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x4)|value<<2)
}
func (o *ETHERC0_Type) GetECMR_RTM() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x4) >> 2
}
func (o *ETHERC0_Type) SetECMR_ILB(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x8)|value<<3)
}
func (o *ETHERC0_Type) GetECMR_ILB() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x8) >> 3
}
func (o *ETHERC0_Type) SetECMR_TE(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x20)|value<<5)
}
func (o *ETHERC0_Type) GetECMR_TE() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x20) >> 5
}
func (o *ETHERC0_Type) SetECMR_RE(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x40)|value<<6)
}
func (o *ETHERC0_Type) GetECMR_RE() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x40) >> 6
}
func (o *ETHERC0_Type) SetECMR_MPDE(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x200)|value<<9)
}
func (o *ETHERC0_Type) GetECMR_MPDE() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x200) >> 9
}
func (o *ETHERC0_Type) SetECMR_PRCEF(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x1000)|value<<12)
}
func (o *ETHERC0_Type) GetECMR_PRCEF() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x1000) >> 12
}
func (o *ETHERC0_Type) SetECMR_TXF(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x10000)|value<<16)
}
func (o *ETHERC0_Type) GetECMR_TXF() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x10000) >> 16
}
func (o *ETHERC0_Type) SetECMR_RXF(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x20000)|value<<17)
}
func (o *ETHERC0_Type) GetECMR_RXF() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x20000) >> 17
}
func (o *ETHERC0_Type) SetECMR_PFR(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x40000)|value<<18)
}
func (o *ETHERC0_Type) GetECMR_PFR() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x40000) >> 18
}
func (o *ETHERC0_Type) SetECMR_ZPF(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x80000)|value<<19)
}
func (o *ETHERC0_Type) GetECMR_ZPF() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x80000) >> 19
}
func (o *ETHERC0_Type) SetECMR_TPC(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x100000)|value<<20)
}
func (o *ETHERC0_Type) GetECMR_TPC() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x100000) >> 20
}

// ETHERC0.RFLR: Receive Frame Maximum Length Register
func (o *ETHERC0_Type) SetRFLR_RFL(value uint32) {
	volatile.StoreUint32(&o.RFLR.Reg, volatile.LoadUint32(&o.RFLR.Reg)&^(0xfff)|value)
}
func (o *ETHERC0_Type) GetRFLR_RFL() uint32 {
	return volatile.LoadUint32(&o.RFLR.Reg) & 0xfff
}

// ETHERC0.ECSR: ETHERC Status Register
func (o *ETHERC0_Type) SetECSR_ICD(value uint32) {
	volatile.StoreUint32(&o.ECSR.Reg, volatile.LoadUint32(&o.ECSR.Reg)&^(0x1)|value)
}
func (o *ETHERC0_Type) GetECSR_ICD() uint32 {
	return volatile.LoadUint32(&o.ECSR.Reg) & 0x1
}
func (o *ETHERC0_Type) SetECSR_MPD(value uint32) {
	volatile.StoreUint32(&o.ECSR.Reg, volatile.LoadUint32(&o.ECSR.Reg)&^(0x2)|value<<1)
}
func (o *ETHERC0_Type) GetECSR_MPD() uint32 {
	return (volatile.LoadUint32(&o.ECSR.Reg) & 0x2) >> 1
}
func (o *ETHERC0_Type) SetECSR_LCHNG(value uint32) {
	volatile.StoreUint32(&o.ECSR.Reg, volatile.LoadUint32(&o.ECSR.Reg)&^(0x4)|value<<2)
}
func (o *ETHERC0_Type) GetECSR_LCHNG() uint32 {
	return (volatile.LoadUint32(&o.ECSR.Reg) & 0x4) >> 2
}
func (o *ETHERC0_Type) SetECSR_PSRTO(value uint32) {
	volatile.StoreUint32(&o.ECSR.Reg, volatile.LoadUint32(&o.ECSR.Reg)&^(0x10)|value<<4)
}
func (o *ETHERC0_Type) GetECSR_PSRTO() uint32 {
	return (volatile.LoadUint32(&o.ECSR.Reg) & 0x10) >> 4
}
func (o *ETHERC0_Type) SetECSR_BFR(value uint32) {
	volatile.StoreUint32(&o.ECSR.Reg, volatile.LoadUint32(&o.ECSR.Reg)&^(0x20)|value<<5)
}
func (o *ETHERC0_Type) GetECSR_BFR() uint32 {
	return (volatile.LoadUint32(&o.ECSR.Reg) & 0x20) >> 5
}

// ETHERC0.ECSIPR: ETHERC Interrupt Enable Register
func (o *ETHERC0_Type) SetECSIPR_ICDIP(value uint32) {
	volatile.StoreUint32(&o.ECSIPR.Reg, volatile.LoadUint32(&o.ECSIPR.Reg)&^(0x1)|value)
}
func (o *ETHERC0_Type) GetECSIPR_ICDIP() uint32 {
	return volatile.LoadUint32(&o.ECSIPR.Reg) & 0x1
}
func (o *ETHERC0_Type) SetECSIPR_MPDIP(value uint32) {
	volatile.StoreUint32(&o.ECSIPR.Reg, volatile.LoadUint32(&o.ECSIPR.Reg)&^(0x2)|value<<1)
}
func (o *ETHERC0_Type) GetECSIPR_MPDIP() uint32 {
	return (volatile.LoadUint32(&o.ECSIPR.Reg) & 0x2) >> 1
}
func (o *ETHERC0_Type) SetECSIPR_LCHNGIP(value uint32) {
	volatile.StoreUint32(&o.ECSIPR.Reg, volatile.LoadUint32(&o.ECSIPR.Reg)&^(0x4)|value<<2)
}
func (o *ETHERC0_Type) GetECSIPR_LCHNGIP() uint32 {
	return (volatile.LoadUint32(&o.ECSIPR.Reg) & 0x4) >> 2
}
func (o *ETHERC0_Type) SetECSIPR_PSRTOIP(value uint32) {
	volatile.StoreUint32(&o.ECSIPR.Reg, volatile.LoadUint32(&o.ECSIPR.Reg)&^(0x10)|value<<4)
}
func (o *ETHERC0_Type) GetECSIPR_PSRTOIP() uint32 {
	return (volatile.LoadUint32(&o.ECSIPR.Reg) & 0x10) >> 4
}
func (o *ETHERC0_Type) SetECSIPR_BFSIPR(value uint32) {
	volatile.StoreUint32(&o.ECSIPR.Reg, volatile.LoadUint32(&o.ECSIPR.Reg)&^(0x20)|value<<5)
}
func (o *ETHERC0_Type) GetECSIPR_BFSIPR() uint32 {
	return (volatile.LoadUint32(&o.ECSIPR.Reg) & 0x20) >> 5
}

// ETHERC0.PIR: PHY Interface Register
func (o *ETHERC0_Type) SetPIR_MDC(value uint32) {
	volatile.StoreUint32(&o.PIR.Reg, volatile.LoadUint32(&o.PIR.Reg)&^(0x1)|value)
}
func (o *ETHERC0_Type) GetPIR_MDC() uint32 {
	return volatile.LoadUint32(&o.PIR.Reg) & 0x1
}
func (o *ETHERC0_Type) SetPIR_MMD(value uint32) {
	volatile.StoreUint32(&o.PIR.Reg, volatile.LoadUint32(&o.PIR.Reg)&^(0x2)|value<<1)
}
func (o *ETHERC0_Type) GetPIR_MMD() uint32 {
	return (volatile.LoadUint32(&o.PIR.Reg) & 0x2) >> 1
}
func (o *ETHERC0_Type) SetPIR_MDO(value uint32) {
	volatile.StoreUint32(&o.PIR.Reg, volatile.LoadUint32(&o.PIR.Reg)&^(0x4)|value<<2)
}
func (o *ETHERC0_Type) GetPIR_MDO() uint32 {
	return (volatile.LoadUint32(&o.PIR.Reg) & 0x4) >> 2
}
func (o *ETHERC0_Type) SetPIR_MDI(value uint32) {
	volatile.StoreUint32(&o.PIR.Reg, volatile.LoadUint32(&o.PIR.Reg)&^(0x8)|value<<3)
}
func (o *ETHERC0_Type) GetPIR_MDI() uint32 {
	return (volatile.LoadUint32(&o.PIR.Reg) & 0x8) >> 3
}

// ETHERC0.PSR: PHY Status Register
func (o *ETHERC0_Type) SetPSR_LMON(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1)|value)
}
func (o *ETHERC0_Type) GetPSR_LMON() uint32 {
	return volatile.LoadUint32(&o.PSR.Reg) & 0x1
}

// ETHERC0.RDMLR: Random Number Generation Counter Upper Limit Setting Register
func (o *ETHERC0_Type) SetRDMLR_RMD(value uint32) {
	volatile.StoreUint32(&o.RDMLR.Reg, volatile.LoadUint32(&o.RDMLR.Reg)&^(0xfffff)|value)
}
func (o *ETHERC0_Type) GetRDMLR_RMD() uint32 {
	return volatile.LoadUint32(&o.RDMLR.Reg) & 0xfffff
}

// ETHERC0.IPGR: Interpacket Gap Register
func (o *ETHERC0_Type) SetIPGR_IPG(value uint32) {
	volatile.StoreUint32(&o.IPGR.Reg, volatile.LoadUint32(&o.IPGR.Reg)&^(0x1f)|value)
}
func (o *ETHERC0_Type) GetIPGR_IPG() uint32 {
	return volatile.LoadUint32(&o.IPGR.Reg) & 0x1f
}

// ETHERC0.APR: Automatic PAUSE Frame Register
func (o *ETHERC0_Type) SetAPR_AP(value uint32) {
	volatile.StoreUint32(&o.APR.Reg, volatile.LoadUint32(&o.APR.Reg)&^(0xffff)|value)
}
func (o *ETHERC0_Type) GetAPR_AP() uint32 {
	return volatile.LoadUint32(&o.APR.Reg) & 0xffff
}

// ETHERC0.MPR: Manual PAUSE Frame Register
func (o *ETHERC0_Type) SetMPR_MP(value uint32) {
	volatile.StoreUint32(&o.MPR.Reg, volatile.LoadUint32(&o.MPR.Reg)&^(0xffff)|value)
}
func (o *ETHERC0_Type) GetMPR_MP() uint32 {
	return volatile.LoadUint32(&o.MPR.Reg) & 0xffff
}

// ETHERC0.RFCF: Received PAUSE Frame Counter
func (o *ETHERC0_Type) SetRFCF_RPAUSE(value uint32) {
	volatile.StoreUint32(&o.RFCF.Reg, volatile.LoadUint32(&o.RFCF.Reg)&^(0xff)|value)
}
func (o *ETHERC0_Type) GetRFCF_RPAUSE() uint32 {
	return volatile.LoadUint32(&o.RFCF.Reg) & 0xff
}

// ETHERC0.TPAUSER: PAUSE Frame Retransmit Count Setting Register
func (o *ETHERC0_Type) SetTPAUSER_TPAUSE(value uint32) {
	volatile.StoreUint32(&o.TPAUSER.Reg, volatile.LoadUint32(&o.TPAUSER.Reg)&^(0xffff)|value)
}
func (o *ETHERC0_Type) GetTPAUSER_TPAUSE() uint32 {
	return volatile.LoadUint32(&o.TPAUSER.Reg) & 0xffff
}

// ETHERC0.TPAUSECR: PAUSE Frame Retransmit Counter
func (o *ETHERC0_Type) SetTPAUSECR_TXP(value uint32) {
	volatile.StoreUint32(&o.TPAUSECR.Reg, volatile.LoadUint32(&o.TPAUSECR.Reg)&^(0xff)|value)
}
func (o *ETHERC0_Type) GetTPAUSECR_TXP() uint32 {
	return volatile.LoadUint32(&o.TPAUSECR.Reg) & 0xff
}

// ETHERC0.BCFRR: Broadcast Frame Receive Count Setting Register
func (o *ETHERC0_Type) SetBCFRR_BCF(value uint32) {
	volatile.StoreUint32(&o.BCFRR.Reg, volatile.LoadUint32(&o.BCFRR.Reg)&^(0xffff)|value)
}
func (o *ETHERC0_Type) GetBCFRR_BCF() uint32 {
	return volatile.LoadUint32(&o.BCFRR.Reg) & 0xffff
}

// ETHERC0.MAHR: MAC Address Upper Bit Register
func (o *ETHERC0_Type) SetMAHR(value uint32) {
	volatile.StoreUint32(&o.MAHR.Reg, value)
}
func (o *ETHERC0_Type) GetMAHR() uint32 {
	return volatile.LoadUint32(&o.MAHR.Reg)
}

// ETHERC0.MALR: MAC Address Lower Bit Register
func (o *ETHERC0_Type) SetMALR(value uint32) {
	volatile.StoreUint32(&o.MALR.Reg, volatile.LoadUint32(&o.MALR.Reg)&^(0xffff)|value)
}
func (o *ETHERC0_Type) GetMALR() uint32 {
	return volatile.LoadUint32(&o.MALR.Reg) & 0xffff
}

// ETHERC0.TROCR: Transmit Retry Over Counter Register
func (o *ETHERC0_Type) SetTROCR(value uint32) {
	volatile.StoreUint32(&o.TROCR.Reg, value)
}
func (o *ETHERC0_Type) GetTROCR() uint32 {
	return volatile.LoadUint32(&o.TROCR.Reg)
}

// ETHERC0.CDCR: Late Collision Detect Counter Register
func (o *ETHERC0_Type) SetCDCR(value uint32) {
	volatile.StoreUint32(&o.CDCR.Reg, value)
}
func (o *ETHERC0_Type) GetCDCR() uint32 {
	return volatile.LoadUint32(&o.CDCR.Reg)
}

// ETHERC0.LCCR: Lost Carrier Counter Register
func (o *ETHERC0_Type) SetLCCR(value uint32) {
	volatile.StoreUint32(&o.LCCR.Reg, value)
}
func (o *ETHERC0_Type) GetLCCR() uint32 {
	return volatile.LoadUint32(&o.LCCR.Reg)
}

// ETHERC0.CNDCR: Carrier Not Detect Counter Register
func (o *ETHERC0_Type) SetCNDCR(value uint32) {
	volatile.StoreUint32(&o.CNDCR.Reg, value)
}
func (o *ETHERC0_Type) GetCNDCR() uint32 {
	return volatile.LoadUint32(&o.CNDCR.Reg)
}

// ETHERC0.CEFCR: CRC Error Frame Receive Counter Register
func (o *ETHERC0_Type) SetCEFCR(value uint32) {
	volatile.StoreUint32(&o.CEFCR.Reg, value)
}
func (o *ETHERC0_Type) GetCEFCR() uint32 {
	return volatile.LoadUint32(&o.CEFCR.Reg)
}

// ETHERC0.TSFRCR: Too-Short Frame Receive Counter Register
func (o *ETHERC0_Type) SetTSFRCR(value uint32) {
	volatile.StoreUint32(&o.TSFRCR.Reg, value)
}
func (o *ETHERC0_Type) GetTSFRCR() uint32 {
	return volatile.LoadUint32(&o.TSFRCR.Reg)
}

// ETHERC0.TLFRCR: Too-Long Frame Receive Counter Register
func (o *ETHERC0_Type) SetTLFRCR(value uint32) {
	volatile.StoreUint32(&o.TLFRCR.Reg, value)
}
func (o *ETHERC0_Type) GetTLFRCR() uint32 {
	return volatile.LoadUint32(&o.TLFRCR.Reg)
}

// ETHERC0.RFCR: Received Alignment Error Frame Counter Register
func (o *ETHERC0_Type) SetRFCR(value uint32) {
	volatile.StoreUint32(&o.RFCR.Reg, value)
}
func (o *ETHERC0_Type) GetRFCR() uint32 {
	return volatile.LoadUint32(&o.RFCR.Reg)
}

// ETHERC0.MAFCR: Multicast Address Frame Receive Counter Register
func (o *ETHERC0_Type) SetMAFCR(value uint32) {
	volatile.StoreUint32(&o.MAFCR.Reg, value)
}
func (o *ETHERC0_Type) GetMAFCR() uint32 {
	return volatile.LoadUint32(&o.MAFCR.Reg)
}

// Serial Communication Interface
type SCI0_Type struct {
	SMR    volatile.Register8  // 0x0
	BRR    volatile.Register8  // 0x1
	SCR    volatile.Register8  // 0x2
	TDR    volatile.Register8  // 0x3
	SSR    volatile.Register8  // 0x4
	RDR    volatile.Register8  // 0x5
	SCMR   volatile.Register8  // 0x6
	SEMR   volatile.Register8  // 0x7
	SNFR   volatile.Register8  // 0x8
	SIMR1  volatile.Register8  // 0x9
	SIMR2  volatile.Register8  // 0xA
	SIMR3  volatile.Register8  // 0xB
	SISR   volatile.Register8  // 0xC
	SPMR   volatile.Register8  // 0xD
	FTDRHL volatile.Register16 // 0xE
	FRDRHL volatile.Register16 // 0x10
	MDDR   volatile.Register8  // 0x12
	DCCR   volatile.Register8  // 0x13
	FCR    volatile.Register16 // 0x14
	FDR    volatile.Register16 // 0x16
	LSR    volatile.Register16 // 0x18
	CDR    volatile.Register16 // 0x1A
	SPTR   volatile.Register8  // 0x1C
	ACTR   volatile.Register8  // 0x1D
}

// SCI0.SMR: Serial Mode Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
func (o *SCI0_Type) SetSMR_CKS(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x3)|value)
}
func (o *SCI0_Type) GetSMR_CKS() uint8 {
	return volatile.LoadUint8(&o.SMR.Reg) & 0x3
}
func (o *SCI0_Type) SetSMR_MP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSMR_MP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSMR_STOP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSMR_STOP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSMR_PM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSMR_PM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSMR_PE(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSMR_PE() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSMR_CHR(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSMR_CHR() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSMR_CM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSMR_CM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x80) >> 7
}

// SCI0.SCR: Serial Control Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
func (o *SCI0_Type) SetSCR_CKE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x3)|value)
}
func (o *SCI0_Type) GetSCR_CKE() uint8 {
	return volatile.LoadUint8(&o.SCR.Reg) & 0x3
}
func (o *SCI0_Type) SetSCR_TEIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSCR_TEIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSCR_MPIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSCR_MPIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSCR_RE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSCR_RE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSCR_TE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSCR_TE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSCR_RIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSCR_RIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSCR_TIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSCR_TIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x80) >> 7
}

// SCI0.SSR: Serial Status Register for Non-Smart Card Interface and Non-FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0, and MMR.MANEN = 0)
func (o *SCI0_Type) SetSSR_MPBT(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSSR_MPBT() uint8 {
	return volatile.LoadUint8(&o.SSR.Reg) & 0x1
}
func (o *SCI0_Type) SetSSR_MPB(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSSR_MPB() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSSR_TEND(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSSR_TEND() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSSR_PER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSSR_PER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSSR_FER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSSR_FER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSSR_ORER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSSR_ORER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSSR_RDRF(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSSR_RDRF() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSSR_TDRE(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSSR_TDRE() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x80) >> 7
}

// SCI0.SCMR: Smart Card Mode Register
func (o *SCI0_Type) SetSCMR_SMIF(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSCMR_SMIF() uint8 {
	return volatile.LoadUint8(&o.SCMR.Reg) & 0x1
}
func (o *SCI0_Type) SetSCMR_SINV(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSCMR_SINV() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSCMR_SDIR(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSCMR_SDIR() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSCMR_CHR1(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSCMR_CHR1() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSCMR_BCP2(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSCMR_BCP2() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x80) >> 7
}

// SCI0.SEMR: Serial Extended Mode Register
func (o *SCI0_Type) SetSEMR_ACS0(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSEMR_ACS0() uint8 {
	return volatile.LoadUint8(&o.SEMR.Reg) & 0x1
}
func (o *SCI0_Type) SetSEMR_PADIS(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSEMR_PADIS() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSEMR_BRME(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSEMR_BRME() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSEMR_ABCSE(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSEMR_ABCSE() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSEMR_ABCS(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSEMR_ABCS() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSEMR_NFEN(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSEMR_NFEN() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSEMR_BGDM(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSEMR_BGDM() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSEMR_RXDESEL(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSEMR_RXDESEL() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x80) >> 7
}

// SCI0.SNFR: Noise Filter Setting Register
func (o *SCI0_Type) SetSNFR_NFCS(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0x7)|value)
}
func (o *SCI0_Type) GetSNFR_NFCS() uint8 {
	return volatile.LoadUint8(&o.SNFR.Reg) & 0x7
}

// SCI0.SIMR1: IIC Mode Register 1
func (o *SCI0_Type) SetSIMR1_IICM(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR1_IICM() uint8 {
	return volatile.LoadUint8(&o.SIMR1.Reg) & 0x1
}
func (o *SCI0_Type) SetSIMR1_IICDL(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0xf8)|value<<3)
}
func (o *SCI0_Type) GetSIMR1_IICDL() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0xf8) >> 3
}

// SCI0.SIMR2: IIC Mode Register 2
func (o *SCI0_Type) SetSIMR2_IICINTM(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR2_IICINTM() uint8 {
	return volatile.LoadUint8(&o.SIMR2.Reg) & 0x1
}
func (o *SCI0_Type) SetSIMR2_IICCSC(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSIMR2_IICCSC() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSIMR2_IICACKT(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSIMR2_IICACKT() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x20) >> 5
}

// SCI0.SIMR3: IIC Mode Register 3
func (o *SCI0_Type) SetSIMR3_IICSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR3_IICSTAREQ() uint8 {
	return volatile.LoadUint8(&o.SIMR3.Reg) & 0x1
}
func (o *SCI0_Type) SetSIMR3_IICRSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSIMR3_IICRSTAREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSIMR3_IICSTPREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSIMR3_IICSTPREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSIMR3_IICSTIF(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSIMR3_IICSTIF() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSIMR3_IICSDAS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x30)|value<<4)
}
func (o *SCI0_Type) GetSIMR3_IICSDAS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x30) >> 4
}
func (o *SCI0_Type) SetSIMR3_IICSCLS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0xc0)|value<<6)
}
func (o *SCI0_Type) GetSIMR3_IICSCLS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0xc0) >> 6
}

// SCI0.SISR: IIC Status Register
func (o *SCI0_Type) SetSISR_IICACKR(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSISR_IICACKR() uint8 {
	return volatile.LoadUint8(&o.SISR.Reg) & 0x1
}

// SCI0.SPMR: SPI Mode Register
func (o *SCI0_Type) SetSPMR_SSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSPMR_SSE() uint8 {
	return volatile.LoadUint8(&o.SPMR.Reg) & 0x1
}
func (o *SCI0_Type) SetSPMR_CTSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSPMR_CTSE() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSPMR_MSS(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSPMR_MSS() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSPMR_CTSPEN(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSPMR_CTSPEN() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSPMR_MFF(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSPMR_MFF() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSPMR_CKPOL(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSPMR_CKPOL() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSPMR_CKPH(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSPMR_CKPH() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x80) >> 7
}

// SCI0.FTDRHL: Transmit FIFO Data Register
func (o *SCI0_Type) SetFTDRHL_TDAT(value uint16) {
	volatile.StoreUint16(&o.FTDRHL.Reg, volatile.LoadUint16(&o.FTDRHL.Reg)&^(0x1ff)|value)
}
func (o *SCI0_Type) GetFTDRHL_TDAT() uint16 {
	return volatile.LoadUint16(&o.FTDRHL.Reg) & 0x1ff
}
func (o *SCI0_Type) SetFTDRHL_MPBT(value uint16) {
	volatile.StoreUint16(&o.FTDRHL.Reg, volatile.LoadUint16(&o.FTDRHL.Reg)&^(0x200)|value<<9)
}
func (o *SCI0_Type) GetFTDRHL_MPBT() uint16 {
	return (volatile.LoadUint16(&o.FTDRHL.Reg) & 0x200) >> 9
}

// SCI0.FRDRHL: Receive FIFO Data Register
func (o *SCI0_Type) SetFRDRHL_RDAT(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x1ff)|value)
}
func (o *SCI0_Type) GetFRDRHL_RDAT() uint16 {
	return volatile.LoadUint16(&o.FRDRHL.Reg) & 0x1ff
}
func (o *SCI0_Type) SetFRDRHL_MPB(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x200)|value<<9)
}
func (o *SCI0_Type) GetFRDRHL_MPB() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x200) >> 9
}
func (o *SCI0_Type) SetFRDRHL_DR(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x400)|value<<10)
}
func (o *SCI0_Type) GetFRDRHL_DR() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x400) >> 10
}
func (o *SCI0_Type) SetFRDRHL_PER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x800)|value<<11)
}
func (o *SCI0_Type) GetFRDRHL_PER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x800) >> 11
}
func (o *SCI0_Type) SetFRDRHL_FER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x1000)|value<<12)
}
func (o *SCI0_Type) GetFRDRHL_FER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x1000) >> 12
}
func (o *SCI0_Type) SetFRDRHL_ORER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x2000)|value<<13)
}
func (o *SCI0_Type) GetFRDRHL_ORER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x2000) >> 13
}
func (o *SCI0_Type) SetFRDRHL_RDF(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x4000)|value<<14)
}
func (o *SCI0_Type) GetFRDRHL_RDF() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x4000) >> 14
}

// SCI0.DCCR: Data Compare Match Control Register
func (o *SCI0_Type) SetDCCR_DCMF(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetDCCR_DCMF() uint8 {
	return volatile.LoadUint8(&o.DCCR.Reg) & 0x1
}
func (o *SCI0_Type) SetDCCR_DPER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetDCCR_DPER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetDCCR_DFER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetDCCR_DFER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetDCCR_IDSEL(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetDCCR_IDSEL() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetDCCR_DCME(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetDCCR_DCME() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x80) >> 7
}

// SCI0.FCR: FIFO Control Register
func (o *SCI0_Type) SetFCR_FM(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetFCR_FM() uint16 {
	return volatile.LoadUint16(&o.FCR.Reg) & 0x1
}
func (o *SCI0_Type) SetFCR_RFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetFCR_RFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetFCR_TFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetFCR_TFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetFCR_DRES(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetFCR_DRES() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetFCR_TTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf0)|value<<4)
}
func (o *SCI0_Type) GetFCR_TTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf0) >> 4
}
func (o *SCI0_Type) SetFCR_RTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf00)|value<<8)
}
func (o *SCI0_Type) GetFCR_RTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf00) >> 8
}
func (o *SCI0_Type) SetFCR_RSTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf000)|value<<12)
}
func (o *SCI0_Type) GetFCR_RSTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf000) >> 12
}

// SCI0.FDR: FIFO Data Count Register
func (o *SCI0_Type) SetFDR_R(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f)|value)
}
func (o *SCI0_Type) GetFDR_R() uint16 {
	return volatile.LoadUint16(&o.FDR.Reg) & 0x1f
}
func (o *SCI0_Type) SetFDR_T(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI0_Type) GetFDR_T() uint16 {
	return (volatile.LoadUint16(&o.FDR.Reg) & 0x1f00) >> 8
}

// SCI0.LSR: Line Status Register
func (o *SCI0_Type) SetLSR_ORER(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetLSR_ORER() uint16 {
	return volatile.LoadUint16(&o.LSR.Reg) & 0x1
}
func (o *SCI0_Type) SetLSR_FNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x7c)|value<<2)
}
func (o *SCI0_Type) GetLSR_FNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x7c) >> 2
}
func (o *SCI0_Type) SetLSR_PNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI0_Type) GetLSR_PNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x1f00) >> 8
}

// SCI0.CDR: Compare Match Data Register
func (o *SCI0_Type) SetCDR_CMPD(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0x1ff)|value)
}
func (o *SCI0_Type) GetCDR_CMPD() uint16 {
	return volatile.LoadUint16(&o.CDR.Reg) & 0x1ff
}

// SCI0.SPTR: Serial Port Register
func (o *SCI0_Type) SetSPTR_RXDMON(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSPTR_RXDMON() uint8 {
	return volatile.LoadUint8(&o.SPTR.Reg) & 0x1
}
func (o *SCI0_Type) SetSPTR_SPB2DT(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSPTR_SPB2DT() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSPTR_SPB2IO(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSPTR_SPB2IO() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSPTR_RINV(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSPTR_RINV() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSPTR_TINV(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSPTR_TINV() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSPTR_ASEN(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSPTR_ASEN() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSPTR_ATEN(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSPTR_ATEN() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x80) >> 7
}

// SCI0.ACTR: Adjustment Communication Timing Register
func (o *SCI0_Type) SetACTR_AST(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x7)|value)
}
func (o *SCI0_Type) GetACTR_AST() uint8 {
	return volatile.LoadUint8(&o.ACTR.Reg) & 0x7
}
func (o *SCI0_Type) SetACTR_AJD(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetACTR_AJD() uint8 {
	return (volatile.LoadUint8(&o.ACTR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetACTR_ATT(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x70)|value<<4)
}
func (o *SCI0_Type) GetACTR_ATT() uint8 {
	return (volatile.LoadUint8(&o.ACTR.Reg) & 0x70) >> 4
}
func (o *SCI0_Type) SetACTR_AET(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetACTR_AET() uint8 {
	return (volatile.LoadUint8(&o.ACTR.Reg) & 0x80) >> 7
}

// Serial Communication Interface 1
type SCI1_Type struct {
	SMR    volatile.Register8 // 0x0
	BRR    volatile.Register8 // 0x1
	SCR    volatile.Register8 // 0x2
	TDR    volatile.Register8 // 0x3
	SSR    volatile.Register8 // 0x4
	RDR    volatile.Register8 // 0x5
	SCMR   volatile.Register8 // 0x6
	_      byte
	SNFR   volatile.Register8  // 0x8
	SIMR1  volatile.Register8  // 0x9
	SIMR2  volatile.Register8  // 0xA
	SIMR3  volatile.Register8  // 0xB
	SISR   volatile.Register8  // 0xC
	SPMR   volatile.Register8  // 0xD
	FTDRHL volatile.Register16 // 0xE
	FRDRHL volatile.Register16 // 0x10
	MDDR   volatile.Register8  // 0x12
	DCCR   volatile.Register8  // 0x13
	FCR    volatile.Register16 // 0x14
	FDR    volatile.Register16 // 0x16
	LSR    volatile.Register16 // 0x18
	CDR    volatile.Register16 // 0x1A
	SPTR   volatile.Register8  // 0x1C
	ACTR   volatile.Register8  // 0x1D
	_      [2]byte
	MMR    volatile.Register8 // 0x20
	_      byte
	TMPR   volatile.Register8 // 0x22
	RMPR   volatile.Register8 // 0x23
	MESR   volatile.Register8 // 0x24
	MECR   volatile.Register8 // 0x25
}

// SCI1.SMR: Serial Mode Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
func (o *SCI1_Type) SetSMR_CKS(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x3)|value)
}
func (o *SCI1_Type) GetSMR_CKS() uint8 {
	return volatile.LoadUint8(&o.SMR.Reg) & 0x3
}
func (o *SCI1_Type) SetSMR_MP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSMR_MP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSMR_STOP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSMR_STOP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSMR_PM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSMR_PM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSMR_PE(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSMR_PE() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSMR_CHR(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSMR_CHR() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSMR_CM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSMR_CM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x80) >> 7
}

// SCI1.SCR: Serial Control Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
func (o *SCI1_Type) SetSCR_CKE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x3)|value)
}
func (o *SCI1_Type) GetSCR_CKE() uint8 {
	return volatile.LoadUint8(&o.SCR.Reg) & 0x3
}
func (o *SCI1_Type) SetSCR_TEIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSCR_TEIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSCR_MPIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSCR_MPIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSCR_RE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSCR_RE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSCR_TE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSCR_TE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSCR_RIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSCR_RIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSCR_TIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSCR_TIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x80) >> 7
}

// SCI1.SSR: Serial Status Register for Non-Smart Card Interface and Non-FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0, and MMR.MANEN = 0)
func (o *SCI1_Type) SetSSR_MPBT(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSSR_MPBT() uint8 {
	return volatile.LoadUint8(&o.SSR.Reg) & 0x1
}
func (o *SCI1_Type) SetSSR_MPB(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSSR_MPB() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSSR_TEND(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSSR_TEND() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSSR_PER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSSR_PER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSSR_FER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSSR_FER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSSR_ORER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSSR_ORER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSSR_RDRF(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSSR_RDRF() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSSR_TDRE(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSSR_TDRE() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x80) >> 7
}

// SCI1.SCMR: Smart Card Mode Register
func (o *SCI1_Type) SetSCMR_SMIF(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSCMR_SMIF() uint8 {
	return volatile.LoadUint8(&o.SCMR.Reg) & 0x1
}
func (o *SCI1_Type) SetSCMR_SINV(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSCMR_SINV() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSCMR_SDIR(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSCMR_SDIR() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSCMR_CHR1(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSCMR_CHR1() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSCMR_BCP2(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSCMR_BCP2() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x80) >> 7
}

// SCI1.SNFR: Noise Filter Setting Register
func (o *SCI1_Type) SetSNFR_NFCS(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0x7)|value)
}
func (o *SCI1_Type) GetSNFR_NFCS() uint8 {
	return volatile.LoadUint8(&o.SNFR.Reg) & 0x7
}

// SCI1.SIMR1: IIC Mode Register 1
func (o *SCI1_Type) SetSIMR1_IICM(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSIMR1_IICM() uint8 {
	return volatile.LoadUint8(&o.SIMR1.Reg) & 0x1
}
func (o *SCI1_Type) SetSIMR1_IICDL(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0xf8)|value<<3)
}
func (o *SCI1_Type) GetSIMR1_IICDL() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0xf8) >> 3
}

// SCI1.SIMR2: IIC Mode Register 2
func (o *SCI1_Type) SetSIMR2_IICINTM(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSIMR2_IICINTM() uint8 {
	return volatile.LoadUint8(&o.SIMR2.Reg) & 0x1
}
func (o *SCI1_Type) SetSIMR2_IICCSC(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSIMR2_IICCSC() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSIMR2_IICACKT(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSIMR2_IICACKT() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x20) >> 5
}

// SCI1.SIMR3: IIC Mode Register 3
func (o *SCI1_Type) SetSIMR3_IICSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSIMR3_IICSTAREQ() uint8 {
	return volatile.LoadUint8(&o.SIMR3.Reg) & 0x1
}
func (o *SCI1_Type) SetSIMR3_IICRSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSIMR3_IICRSTAREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSIMR3_IICSTPREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSIMR3_IICSTPREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSIMR3_IICSTIF(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSIMR3_IICSTIF() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSIMR3_IICSDAS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x30)|value<<4)
}
func (o *SCI1_Type) GetSIMR3_IICSDAS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x30) >> 4
}
func (o *SCI1_Type) SetSIMR3_IICSCLS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0xc0)|value<<6)
}
func (o *SCI1_Type) GetSIMR3_IICSCLS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0xc0) >> 6
}

// SCI1.SISR: IIC Status Register
func (o *SCI1_Type) SetSISR_IICACKR(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSISR_IICACKR() uint8 {
	return volatile.LoadUint8(&o.SISR.Reg) & 0x1
}

// SCI1.SPMR: SPI Mode Register
func (o *SCI1_Type) SetSPMR_SSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSPMR_SSE() uint8 {
	return volatile.LoadUint8(&o.SPMR.Reg) & 0x1
}
func (o *SCI1_Type) SetSPMR_CTSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSPMR_CTSE() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSPMR_MSS(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSPMR_MSS() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSPMR_CTSPEN(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSPMR_CTSPEN() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSPMR_MFF(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSPMR_MFF() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSPMR_CKPOL(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSPMR_CKPOL() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSPMR_CKPH(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSPMR_CKPH() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x80) >> 7
}

// SCI1.FTDRHL: Transmit FIFO Data Register
func (o *SCI1_Type) SetFTDRHL_TDAT(value uint16) {
	volatile.StoreUint16(&o.FTDRHL.Reg, volatile.LoadUint16(&o.FTDRHL.Reg)&^(0x1ff)|value)
}
func (o *SCI1_Type) GetFTDRHL_TDAT() uint16 {
	return volatile.LoadUint16(&o.FTDRHL.Reg) & 0x1ff
}
func (o *SCI1_Type) SetFTDRHL_MPBT(value uint16) {
	volatile.StoreUint16(&o.FTDRHL.Reg, volatile.LoadUint16(&o.FTDRHL.Reg)&^(0x200)|value<<9)
}
func (o *SCI1_Type) GetFTDRHL_MPBT() uint16 {
	return (volatile.LoadUint16(&o.FTDRHL.Reg) & 0x200) >> 9
}

// SCI1.FRDRHL: Receive FIFO Data Register
func (o *SCI1_Type) SetFRDRHL_RDAT(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x1ff)|value)
}
func (o *SCI1_Type) GetFRDRHL_RDAT() uint16 {
	return volatile.LoadUint16(&o.FRDRHL.Reg) & 0x1ff
}
func (o *SCI1_Type) SetFRDRHL_MPB(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x200)|value<<9)
}
func (o *SCI1_Type) GetFRDRHL_MPB() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x200) >> 9
}
func (o *SCI1_Type) SetFRDRHL_DR(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x400)|value<<10)
}
func (o *SCI1_Type) GetFRDRHL_DR() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x400) >> 10
}
func (o *SCI1_Type) SetFRDRHL_PER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x800)|value<<11)
}
func (o *SCI1_Type) GetFRDRHL_PER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x800) >> 11
}
func (o *SCI1_Type) SetFRDRHL_FER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x1000)|value<<12)
}
func (o *SCI1_Type) GetFRDRHL_FER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x1000) >> 12
}
func (o *SCI1_Type) SetFRDRHL_ORER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x2000)|value<<13)
}
func (o *SCI1_Type) GetFRDRHL_ORER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x2000) >> 13
}
func (o *SCI1_Type) SetFRDRHL_RDF(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x4000)|value<<14)
}
func (o *SCI1_Type) GetFRDRHL_RDF() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x4000) >> 14
}

// SCI1.DCCR: Data Compare Match Control Register
func (o *SCI1_Type) SetDCCR_DCMF(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetDCCR_DCMF() uint8 {
	return volatile.LoadUint8(&o.DCCR.Reg) & 0x1
}
func (o *SCI1_Type) SetDCCR_DPER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetDCCR_DPER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetDCCR_DFER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetDCCR_DFER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetDCCR_IDSEL(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetDCCR_IDSEL() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetDCCR_DCME(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetDCCR_DCME() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x80) >> 7
}

// SCI1.FCR: FIFO Control Register
func (o *SCI1_Type) SetFCR_FM(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetFCR_FM() uint16 {
	return volatile.LoadUint16(&o.FCR.Reg) & 0x1
}
func (o *SCI1_Type) SetFCR_RFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetFCR_RFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetFCR_TFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetFCR_TFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetFCR_DRES(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetFCR_DRES() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetFCR_TTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf0)|value<<4)
}
func (o *SCI1_Type) GetFCR_TTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf0) >> 4
}
func (o *SCI1_Type) SetFCR_RTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf00)|value<<8)
}
func (o *SCI1_Type) GetFCR_RTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf00) >> 8
}
func (o *SCI1_Type) SetFCR_RSTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf000)|value<<12)
}
func (o *SCI1_Type) GetFCR_RSTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf000) >> 12
}

// SCI1.FDR: FIFO Data Count Register
func (o *SCI1_Type) SetFDR_R(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f)|value)
}
func (o *SCI1_Type) GetFDR_R() uint16 {
	return volatile.LoadUint16(&o.FDR.Reg) & 0x1f
}
func (o *SCI1_Type) SetFDR_T(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI1_Type) GetFDR_T() uint16 {
	return (volatile.LoadUint16(&o.FDR.Reg) & 0x1f00) >> 8
}

// SCI1.LSR: Line Status Register
func (o *SCI1_Type) SetLSR_ORER(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetLSR_ORER() uint16 {
	return volatile.LoadUint16(&o.LSR.Reg) & 0x1
}
func (o *SCI1_Type) SetLSR_FNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x7c)|value<<2)
}
func (o *SCI1_Type) GetLSR_FNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x7c) >> 2
}
func (o *SCI1_Type) SetLSR_PNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI1_Type) GetLSR_PNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x1f00) >> 8
}

// SCI1.CDR: Compare Match Data Register
func (o *SCI1_Type) SetCDR_CMPD(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0x1ff)|value)
}
func (o *SCI1_Type) GetCDR_CMPD() uint16 {
	return volatile.LoadUint16(&o.CDR.Reg) & 0x1ff
}

// SCI1.SPTR: Serial Port Register
func (o *SCI1_Type) SetSPTR_RXDMON(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSPTR_RXDMON() uint8 {
	return volatile.LoadUint8(&o.SPTR.Reg) & 0x1
}
func (o *SCI1_Type) SetSPTR_SPB2DT(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSPTR_SPB2DT() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSPTR_SPB2IO(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSPTR_SPB2IO() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSPTR_RINV(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSPTR_RINV() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSPTR_TINV(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSPTR_TINV() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSPTR_ASEN(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSPTR_ASEN() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSPTR_ATEN(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSPTR_ATEN() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x80) >> 7
}

// SCI1.ACTR: Adjustment Communication Timing Register
func (o *SCI1_Type) SetACTR_AST(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x7)|value)
}
func (o *SCI1_Type) GetACTR_AST() uint8 {
	return volatile.LoadUint8(&o.ACTR.Reg) & 0x7
}
func (o *SCI1_Type) SetACTR_AJD(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetACTR_AJD() uint8 {
	return (volatile.LoadUint8(&o.ACTR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetACTR_ATT(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x70)|value<<4)
}
func (o *SCI1_Type) GetACTR_ATT() uint8 {
	return (volatile.LoadUint8(&o.ACTR.Reg) & 0x70) >> 4
}
func (o *SCI1_Type) SetACTR_AET(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetACTR_AET() uint8 {
	return (volatile.LoadUint8(&o.ACTR.Reg) & 0x80) >> 7
}

// SCI1.MMR: Manchester Mode Register
func (o *SCI1_Type) SetMMR_RMPOL(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetMMR_RMPOL() uint8 {
	return volatile.LoadUint8(&o.MMR.Reg) & 0x1
}
func (o *SCI1_Type) SetMMR_TMPOL(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetMMR_TMPOL() uint8 {
	return (volatile.LoadUint8(&o.MMR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetMMR_ERTEN(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetMMR_ERTEN() uint8 {
	return (volatile.LoadUint8(&o.MMR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetMMR_SYNVAL(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetMMR_SYNVAL() uint8 {
	return (volatile.LoadUint8(&o.MMR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetMMR_SYNSEL(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetMMR_SYNSEL() uint8 {
	return (volatile.LoadUint8(&o.MMR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetMMR_SBSEL(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetMMR_SBSEL() uint8 {
	return (volatile.LoadUint8(&o.MMR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetMMR_MANEN(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetMMR_MANEN() uint8 {
	return (volatile.LoadUint8(&o.MMR.Reg) & 0x80) >> 7
}

// SCI1.TMPR: Transmit Manchester Preface Setting Register
func (o *SCI1_Type) SetTMPR_TPLEN(value uint8) {
	volatile.StoreUint8(&o.TMPR.Reg, volatile.LoadUint8(&o.TMPR.Reg)&^(0xf)|value)
}
func (o *SCI1_Type) GetTMPR_TPLEN() uint8 {
	return volatile.LoadUint8(&o.TMPR.Reg) & 0xf
}
func (o *SCI1_Type) SetTMPR_TPPAT(value uint8) {
	volatile.StoreUint8(&o.TMPR.Reg, volatile.LoadUint8(&o.TMPR.Reg)&^(0x30)|value<<4)
}
func (o *SCI1_Type) GetTMPR_TPPAT() uint8 {
	return (volatile.LoadUint8(&o.TMPR.Reg) & 0x30) >> 4
}

// SCI1.RMPR: Receive Manchester Preface Setting Register
func (o *SCI1_Type) SetRMPR_RPLEN(value uint8) {
	volatile.StoreUint8(&o.RMPR.Reg, volatile.LoadUint8(&o.RMPR.Reg)&^(0xf)|value)
}
func (o *SCI1_Type) GetRMPR_RPLEN() uint8 {
	return volatile.LoadUint8(&o.RMPR.Reg) & 0xf
}
func (o *SCI1_Type) SetRMPR_RPPAT(value uint8) {
	volatile.StoreUint8(&o.RMPR.Reg, volatile.LoadUint8(&o.RMPR.Reg)&^(0x30)|value<<4)
}
func (o *SCI1_Type) GetRMPR_RPPAT() uint8 {
	return (volatile.LoadUint8(&o.RMPR.Reg) & 0x30) >> 4
}

// SCI1.MESR: Manchester Extended Error Status Register
func (o *SCI1_Type) SetMESR_PFER(value uint8) {
	volatile.StoreUint8(&o.MESR.Reg, volatile.LoadUint8(&o.MESR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetMESR_PFER() uint8 {
	return volatile.LoadUint8(&o.MESR.Reg) & 0x1
}
func (o *SCI1_Type) SetMESR_SYER(value uint8) {
	volatile.StoreUint8(&o.MESR.Reg, volatile.LoadUint8(&o.MESR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetMESR_SYER() uint8 {
	return (volatile.LoadUint8(&o.MESR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetMESR_SBER(value uint8) {
	volatile.StoreUint8(&o.MESR.Reg, volatile.LoadUint8(&o.MESR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetMESR_SBER() uint8 {
	return (volatile.LoadUint8(&o.MESR.Reg) & 0x4) >> 2
}

// SCI1.MECR: Manchester Extended Error Control Register
func (o *SCI1_Type) SetMECR_PFEREN(value uint8) {
	volatile.StoreUint8(&o.MECR.Reg, volatile.LoadUint8(&o.MECR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetMECR_PFEREN() uint8 {
	return volatile.LoadUint8(&o.MECR.Reg) & 0x1
}
func (o *SCI1_Type) SetMECR_SYEREN(value uint8) {
	volatile.StoreUint8(&o.MECR.Reg, volatile.LoadUint8(&o.MECR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetMECR_SYEREN() uint8 {
	return (volatile.LoadUint8(&o.MECR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetMECR_SBEREN(value uint8) {
	volatile.StoreUint8(&o.MECR.Reg, volatile.LoadUint8(&o.MECR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetMECR_SBEREN() uint8 {
	return (volatile.LoadUint8(&o.MECR.Reg) & 0x4) >> 2
}

// Serial Communication Interface 2
type SCI2_Type struct {
	SMR    volatile.Register8  // 0x0
	BRR    volatile.Register8  // 0x1
	SCR    volatile.Register8  // 0x2
	TDR    volatile.Register8  // 0x3
	SSR    volatile.Register8  // 0x4
	RDR    volatile.Register8  // 0x5
	SCMR   volatile.Register8  // 0x6
	SEMR   volatile.Register8  // 0x7
	SNFR   volatile.Register8  // 0x8
	SIMR1  volatile.Register8  // 0x9
	SIMR2  volatile.Register8  // 0xA
	SIMR3  volatile.Register8  // 0xB
	SISR   volatile.Register8  // 0xC
	SPMR   volatile.Register8  // 0xD
	FTDRHL volatile.Register16 // 0xE
	FRDRHL volatile.Register16 // 0x10
	MDDR   volatile.Register8  // 0x12
	DCCR   volatile.Register8  // 0x13
	FCR    volatile.Register16 // 0x14
	FDR    volatile.Register16 // 0x16
	LSR    volatile.Register16 // 0x18
	CDR    volatile.Register16 // 0x1A
	SPTR   volatile.Register8  // 0x1C
	ACTR   volatile.Register8  // 0x1D
	_      [2]byte
	ESMER  volatile.Register8 // 0x20
	CR0    volatile.Register8 // 0x21
	CR1    volatile.Register8 // 0x22
	CR2    volatile.Register8 // 0x23
	CR3    volatile.Register8 // 0x24
	MECR   volatile.Register8 // 0x25
	ICR    volatile.Register8 // 0x26
	STR    volatile.Register8 // 0x27
	STCR   volatile.Register8 // 0x28
	CF0DR  volatile.Register8 // 0x29
	CF0CR  volatile.Register8 // 0x2A
	CF0RR  volatile.Register8 // 0x2B
	PCF1DR volatile.Register8 // 0x2C
	SCF1DR volatile.Register8 // 0x2D
	CF1CR  volatile.Register8 // 0x2E
	CF1RR  volatile.Register8 // 0x2F
	TCR    volatile.Register8 // 0x30
	TMR    volatile.Register8 // 0x31
	TPRE   volatile.Register8 // 0x32
	TCNT   volatile.Register8 // 0x33
}

// SCI2.SMR: Serial Mode Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
func (o *SCI2_Type) SetSMR_CKS(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x3)|value)
}
func (o *SCI2_Type) GetSMR_CKS() uint8 {
	return volatile.LoadUint8(&o.SMR.Reg) & 0x3
}
func (o *SCI2_Type) SetSMR_MP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSMR_MP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSMR_STOP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSMR_STOP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSMR_PM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSMR_PM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSMR_PE(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSMR_PE() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetSMR_CHR(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetSMR_CHR() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetSMR_CM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetSMR_CM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x80) >> 7
}

// SCI2.SCR: Serial Control Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
func (o *SCI2_Type) SetSCR_CKE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x3)|value)
}
func (o *SCI2_Type) GetSCR_CKE() uint8 {
	return volatile.LoadUint8(&o.SCR.Reg) & 0x3
}
func (o *SCI2_Type) SetSCR_TEIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSCR_TEIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSCR_MPIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSCR_MPIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSCR_RE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSCR_RE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSCR_TE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSCR_TE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetSCR_RIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetSCR_RIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetSCR_TIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetSCR_TIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x80) >> 7
}

// SCI2.SSR: Serial Status Register for Non-Smart Card Interface and Non-FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0, and MMR.MANEN = 0)
func (o *SCI2_Type) SetSSR_MPBT(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSSR_MPBT() uint8 {
	return volatile.LoadUint8(&o.SSR.Reg) & 0x1
}
func (o *SCI2_Type) SetSSR_MPB(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSSR_MPB() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSSR_TEND(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSSR_TEND() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSSR_PER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSSR_PER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSSR_FER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSSR_FER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSSR_ORER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSSR_ORER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetSSR_RDRF(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetSSR_RDRF() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetSSR_TDRE(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetSSR_TDRE() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x80) >> 7
}

// SCI2.SCMR: Smart Card Mode Register
func (o *SCI2_Type) SetSCMR_SMIF(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSCMR_SMIF() uint8 {
	return volatile.LoadUint8(&o.SCMR.Reg) & 0x1
}
func (o *SCI2_Type) SetSCMR_SINV(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSCMR_SINV() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSCMR_SDIR(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSCMR_SDIR() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSCMR_CHR1(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSCMR_CHR1() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSCMR_BCP2(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetSCMR_BCP2() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x80) >> 7
}

// SCI2.SEMR: Serial Extended Mode Register
func (o *SCI2_Type) SetSEMR_ACS0(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSEMR_ACS0() uint8 {
	return volatile.LoadUint8(&o.SEMR.Reg) & 0x1
}
func (o *SCI2_Type) SetSEMR_PADIS(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSEMR_PADIS() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSEMR_BRME(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSEMR_BRME() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSEMR_ABCSE(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSEMR_ABCSE() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSEMR_ABCS(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSEMR_ABCS() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSEMR_NFEN(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSEMR_NFEN() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetSEMR_BGDM(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetSEMR_BGDM() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetSEMR_RXDESEL(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetSEMR_RXDESEL() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x80) >> 7
}

// SCI2.SNFR: Noise Filter Setting Register
func (o *SCI2_Type) SetSNFR_NFCS(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0x7)|value)
}
func (o *SCI2_Type) GetSNFR_NFCS() uint8 {
	return volatile.LoadUint8(&o.SNFR.Reg) & 0x7
}

// SCI2.SIMR1: IIC Mode Register 1
func (o *SCI2_Type) SetSIMR1_IICM(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSIMR1_IICM() uint8 {
	return volatile.LoadUint8(&o.SIMR1.Reg) & 0x1
}
func (o *SCI2_Type) SetSIMR1_IICDL(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0xf8)|value<<3)
}
func (o *SCI2_Type) GetSIMR1_IICDL() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0xf8) >> 3
}

// SCI2.SIMR2: IIC Mode Register 2
func (o *SCI2_Type) SetSIMR2_IICINTM(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSIMR2_IICINTM() uint8 {
	return volatile.LoadUint8(&o.SIMR2.Reg) & 0x1
}
func (o *SCI2_Type) SetSIMR2_IICCSC(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSIMR2_IICCSC() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSIMR2_IICACKT(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSIMR2_IICACKT() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x20) >> 5
}

// SCI2.SIMR3: IIC Mode Register 3
func (o *SCI2_Type) SetSIMR3_IICSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSIMR3_IICSTAREQ() uint8 {
	return volatile.LoadUint8(&o.SIMR3.Reg) & 0x1
}
func (o *SCI2_Type) SetSIMR3_IICRSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSIMR3_IICRSTAREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSIMR3_IICSTPREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSIMR3_IICSTPREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSIMR3_IICSTIF(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSIMR3_IICSTIF() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSIMR3_IICSDAS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x30)|value<<4)
}
func (o *SCI2_Type) GetSIMR3_IICSDAS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x30) >> 4
}
func (o *SCI2_Type) SetSIMR3_IICSCLS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0xc0)|value<<6)
}
func (o *SCI2_Type) GetSIMR3_IICSCLS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0xc0) >> 6
}

// SCI2.SISR: IIC Status Register
func (o *SCI2_Type) SetSISR_IICACKR(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSISR_IICACKR() uint8 {
	return volatile.LoadUint8(&o.SISR.Reg) & 0x1
}

// SCI2.SPMR: SPI Mode Register
func (o *SCI2_Type) SetSPMR_SSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSPMR_SSE() uint8 {
	return volatile.LoadUint8(&o.SPMR.Reg) & 0x1
}
func (o *SCI2_Type) SetSPMR_CTSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSPMR_CTSE() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSPMR_MSS(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSPMR_MSS() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSPMR_CTSPEN(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSPMR_CTSPEN() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSPMR_MFF(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSPMR_MFF() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSPMR_CKPOL(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetSPMR_CKPOL() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetSPMR_CKPH(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetSPMR_CKPH() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x80) >> 7
}

// SCI2.FTDRHL: Transmit FIFO Data Register
func (o *SCI2_Type) SetFTDRHL_TDAT(value uint16) {
	volatile.StoreUint16(&o.FTDRHL.Reg, volatile.LoadUint16(&o.FTDRHL.Reg)&^(0x1ff)|value)
}
func (o *SCI2_Type) GetFTDRHL_TDAT() uint16 {
	return volatile.LoadUint16(&o.FTDRHL.Reg) & 0x1ff
}
func (o *SCI2_Type) SetFTDRHL_MPBT(value uint16) {
	volatile.StoreUint16(&o.FTDRHL.Reg, volatile.LoadUint16(&o.FTDRHL.Reg)&^(0x200)|value<<9)
}
func (o *SCI2_Type) GetFTDRHL_MPBT() uint16 {
	return (volatile.LoadUint16(&o.FTDRHL.Reg) & 0x200) >> 9
}

// SCI2.FRDRHL: Receive FIFO Data Register
func (o *SCI2_Type) SetFRDRHL_RDAT(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x1ff)|value)
}
func (o *SCI2_Type) GetFRDRHL_RDAT() uint16 {
	return volatile.LoadUint16(&o.FRDRHL.Reg) & 0x1ff
}
func (o *SCI2_Type) SetFRDRHL_MPB(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x200)|value<<9)
}
func (o *SCI2_Type) GetFRDRHL_MPB() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x200) >> 9
}
func (o *SCI2_Type) SetFRDRHL_DR(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x400)|value<<10)
}
func (o *SCI2_Type) GetFRDRHL_DR() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x400) >> 10
}
func (o *SCI2_Type) SetFRDRHL_PER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x800)|value<<11)
}
func (o *SCI2_Type) GetFRDRHL_PER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x800) >> 11
}
func (o *SCI2_Type) SetFRDRHL_FER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x1000)|value<<12)
}
func (o *SCI2_Type) GetFRDRHL_FER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x1000) >> 12
}
func (o *SCI2_Type) SetFRDRHL_ORER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x2000)|value<<13)
}
func (o *SCI2_Type) GetFRDRHL_ORER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x2000) >> 13
}
func (o *SCI2_Type) SetFRDRHL_RDF(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x4000)|value<<14)
}
func (o *SCI2_Type) GetFRDRHL_RDF() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x4000) >> 14
}

// SCI2.DCCR: Data Compare Match Control Register
func (o *SCI2_Type) SetDCCR_DCMF(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetDCCR_DCMF() uint8 {
	return volatile.LoadUint8(&o.DCCR.Reg) & 0x1
}
func (o *SCI2_Type) SetDCCR_DPER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetDCCR_DPER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetDCCR_DFER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetDCCR_DFER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetDCCR_IDSEL(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetDCCR_IDSEL() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetDCCR_DCME(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetDCCR_DCME() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x80) >> 7
}

// SCI2.FCR: FIFO Control Register
func (o *SCI2_Type) SetFCR_FM(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetFCR_FM() uint16 {
	return volatile.LoadUint16(&o.FCR.Reg) & 0x1
}
func (o *SCI2_Type) SetFCR_RFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetFCR_RFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetFCR_TFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetFCR_TFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetFCR_DRES(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetFCR_DRES() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetFCR_TTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf0)|value<<4)
}
func (o *SCI2_Type) GetFCR_TTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf0) >> 4
}
func (o *SCI2_Type) SetFCR_RTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf00)|value<<8)
}
func (o *SCI2_Type) GetFCR_RTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf00) >> 8
}
func (o *SCI2_Type) SetFCR_RSTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf000)|value<<12)
}
func (o *SCI2_Type) GetFCR_RSTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf000) >> 12
}

// SCI2.FDR: FIFO Data Count Register
func (o *SCI2_Type) SetFDR_R(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f)|value)
}
func (o *SCI2_Type) GetFDR_R() uint16 {
	return volatile.LoadUint16(&o.FDR.Reg) & 0x1f
}
func (o *SCI2_Type) SetFDR_T(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI2_Type) GetFDR_T() uint16 {
	return (volatile.LoadUint16(&o.FDR.Reg) & 0x1f00) >> 8
}

// SCI2.LSR: Line Status Register
func (o *SCI2_Type) SetLSR_ORER(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetLSR_ORER() uint16 {
	return volatile.LoadUint16(&o.LSR.Reg) & 0x1
}
func (o *SCI2_Type) SetLSR_FNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x7c)|value<<2)
}
func (o *SCI2_Type) GetLSR_FNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x7c) >> 2
}
func (o *SCI2_Type) SetLSR_PNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI2_Type) GetLSR_PNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x1f00) >> 8
}

// SCI2.CDR: Compare Match Data Register
func (o *SCI2_Type) SetCDR_CMPD(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0x1ff)|value)
}
func (o *SCI2_Type) GetCDR_CMPD() uint16 {
	return volatile.LoadUint16(&o.CDR.Reg) & 0x1ff
}

// SCI2.SPTR: Serial Port Register
func (o *SCI2_Type) SetSPTR_RXDMON(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSPTR_RXDMON() uint8 {
	return volatile.LoadUint8(&o.SPTR.Reg) & 0x1
}
func (o *SCI2_Type) SetSPTR_SPB2DT(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSPTR_SPB2DT() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSPTR_SPB2IO(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSPTR_SPB2IO() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSPTR_RINV(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSPTR_RINV() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSPTR_TINV(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSPTR_TINV() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetSPTR_ASEN(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetSPTR_ASEN() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetSPTR_ATEN(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetSPTR_ATEN() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x80) >> 7
}

// SCI2.ACTR: Adjustment Communication Timing Register
func (o *SCI2_Type) SetACTR_AST(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x7)|value)
}
func (o *SCI2_Type) GetACTR_AST() uint8 {
	return volatile.LoadUint8(&o.ACTR.Reg) & 0x7
}
func (o *SCI2_Type) SetACTR_AJD(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetACTR_AJD() uint8 {
	return (volatile.LoadUint8(&o.ACTR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetACTR_ATT(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x70)|value<<4)
}
func (o *SCI2_Type) GetACTR_ATT() uint8 {
	return (volatile.LoadUint8(&o.ACTR.Reg) & 0x70) >> 4
}
func (o *SCI2_Type) SetACTR_AET(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetACTR_AET() uint8 {
	return (volatile.LoadUint8(&o.ACTR.Reg) & 0x80) >> 7
}

// SCI2.ESMER: Extended Serial Module Enable Register
func (o *SCI2_Type) SetESMER_ESME(value uint8) {
	volatile.StoreUint8(&o.ESMER.Reg, volatile.LoadUint8(&o.ESMER.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetESMER_ESME() uint8 {
	return volatile.LoadUint8(&o.ESMER.Reg) & 0x1
}

// SCI2.CR0: Control Register 0
func (o *SCI2_Type) SetCR0_SFSF(value uint8) {
	volatile.StoreUint8(&o.CR0.Reg, volatile.LoadUint8(&o.CR0.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetCR0_SFSF() uint8 {
	return (volatile.LoadUint8(&o.CR0.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetCR0_RXDSF(value uint8) {
	volatile.StoreUint8(&o.CR0.Reg, volatile.LoadUint8(&o.CR0.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetCR0_RXDSF() uint8 {
	return (volatile.LoadUint8(&o.CR0.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetCR0_BRME(value uint8) {
	volatile.StoreUint8(&o.CR0.Reg, volatile.LoadUint8(&o.CR0.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetCR0_BRME() uint8 {
	return (volatile.LoadUint8(&o.CR0.Reg) & 0x8) >> 3
}

// SCI2.CR1: Control Register 1
func (o *SCI2_Type) SetCR1_BFE(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetCR1_BFE() uint8 {
	return volatile.LoadUint8(&o.CR1.Reg) & 0x1
}
func (o *SCI2_Type) SetCR1_CF0RE(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetCR1_CF0RE() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetCR1_CF1DS(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0xc)|value<<2)
}
func (o *SCI2_Type) GetCR1_CF1DS() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0xc) >> 2
}
func (o *SCI2_Type) SetCR1_PIBE(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetCR1_PIBE() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetCR1_PIBS(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0xe0)|value<<5)
}
func (o *SCI2_Type) GetCR1_PIBS() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0xe0) >> 5
}

// SCI2.CR2: Control Register 2
func (o *SCI2_Type) SetCR2_DFCS(value uint8) {
	volatile.StoreUint8(&o.CR2.Reg, volatile.LoadUint8(&o.CR2.Reg)&^(0x7)|value)
}
func (o *SCI2_Type) GetCR2_DFCS() uint8 {
	return volatile.LoadUint8(&o.CR2.Reg) & 0x7
}
func (o *SCI2_Type) SetCR2_BCCS(value uint8) {
	volatile.StoreUint8(&o.CR2.Reg, volatile.LoadUint8(&o.CR2.Reg)&^(0x30)|value<<4)
}
func (o *SCI2_Type) GetCR2_BCCS() uint8 {
	return (volatile.LoadUint8(&o.CR2.Reg) & 0x30) >> 4
}
func (o *SCI2_Type) SetCR2_RTS(value uint8) {
	volatile.StoreUint8(&o.CR2.Reg, volatile.LoadUint8(&o.CR2.Reg)&^(0xc0)|value<<6)
}
func (o *SCI2_Type) GetCR2_RTS() uint8 {
	return (volatile.LoadUint8(&o.CR2.Reg) & 0xc0) >> 6
}

// SCI2.CR3: Control Register 3
func (o *SCI2_Type) SetCR3_SDST(value uint8) {
	volatile.StoreUint8(&o.CR3.Reg, volatile.LoadUint8(&o.CR3.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetCR3_SDST() uint8 {
	return volatile.LoadUint8(&o.CR3.Reg) & 0x1
}

// SCI2.MECR: Manchester Extended Error Control Register
func (o *SCI2_Type) SetMECR_PFEREN(value uint8) {
	volatile.StoreUint8(&o.MECR.Reg, volatile.LoadUint8(&o.MECR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetMECR_PFEREN() uint8 {
	return volatile.LoadUint8(&o.MECR.Reg) & 0x1
}
func (o *SCI2_Type) SetMECR_SYEREN(value uint8) {
	volatile.StoreUint8(&o.MECR.Reg, volatile.LoadUint8(&o.MECR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetMECR_SYEREN() uint8 {
	return (volatile.LoadUint8(&o.MECR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetMECR_SBEREN(value uint8) {
	volatile.StoreUint8(&o.MECR.Reg, volatile.LoadUint8(&o.MECR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetMECR_SBEREN() uint8 {
	return (volatile.LoadUint8(&o.MECR.Reg) & 0x4) >> 2
}

// SCI2.ICR: Interrupt Control Register
func (o *SCI2_Type) SetICR_BFDIE(value uint8) {
	volatile.StoreUint8(&o.ICR.Reg, volatile.LoadUint8(&o.ICR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetICR_BFDIE() uint8 {
	return volatile.LoadUint8(&o.ICR.Reg) & 0x1
}
func (o *SCI2_Type) SetICR_CF0MIE(value uint8) {
	volatile.StoreUint8(&o.ICR.Reg, volatile.LoadUint8(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetICR_CF0MIE() uint8 {
	return (volatile.LoadUint8(&o.ICR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetICR_CF1MIE(value uint8) {
	volatile.StoreUint8(&o.ICR.Reg, volatile.LoadUint8(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetICR_CF1MIE() uint8 {
	return (volatile.LoadUint8(&o.ICR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetICR_PIBDIE(value uint8) {
	volatile.StoreUint8(&o.ICR.Reg, volatile.LoadUint8(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetICR_PIBDIE() uint8 {
	return (volatile.LoadUint8(&o.ICR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetICR_BCDIE(value uint8) {
	volatile.StoreUint8(&o.ICR.Reg, volatile.LoadUint8(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetICR_BCDIE() uint8 {
	return (volatile.LoadUint8(&o.ICR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetICR_AEDIE(value uint8) {
	volatile.StoreUint8(&o.ICR.Reg, volatile.LoadUint8(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetICR_AEDIE() uint8 {
	return (volatile.LoadUint8(&o.ICR.Reg) & 0x20) >> 5
}

// SCI2.STR: Status Register
func (o *SCI2_Type) SetSTR_BFDF(value uint8) {
	volatile.StoreUint8(&o.STR.Reg, volatile.LoadUint8(&o.STR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSTR_BFDF() uint8 {
	return volatile.LoadUint8(&o.STR.Reg) & 0x1
}
func (o *SCI2_Type) SetSTR_CF0MF(value uint8) {
	volatile.StoreUint8(&o.STR.Reg, volatile.LoadUint8(&o.STR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSTR_CF0MF() uint8 {
	return (volatile.LoadUint8(&o.STR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSTR_CF1MF(value uint8) {
	volatile.StoreUint8(&o.STR.Reg, volatile.LoadUint8(&o.STR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSTR_CF1MF() uint8 {
	return (volatile.LoadUint8(&o.STR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSTR_PIBDF(value uint8) {
	volatile.StoreUint8(&o.STR.Reg, volatile.LoadUint8(&o.STR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSTR_PIBDF() uint8 {
	return (volatile.LoadUint8(&o.STR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSTR_BCDF(value uint8) {
	volatile.StoreUint8(&o.STR.Reg, volatile.LoadUint8(&o.STR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSTR_BCDF() uint8 {
	return (volatile.LoadUint8(&o.STR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSTR_AEDF(value uint8) {
	volatile.StoreUint8(&o.STR.Reg, volatile.LoadUint8(&o.STR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSTR_AEDF() uint8 {
	return (volatile.LoadUint8(&o.STR.Reg) & 0x20) >> 5
}

// SCI2.STCR: Status Clear Register
func (o *SCI2_Type) SetSTCR_BFDCL(value uint8) {
	volatile.StoreUint8(&o.STCR.Reg, volatile.LoadUint8(&o.STCR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetSTCR_BFDCL() uint8 {
	return volatile.LoadUint8(&o.STCR.Reg) & 0x1
}
func (o *SCI2_Type) SetSTCR_CF0MCL(value uint8) {
	volatile.StoreUint8(&o.STCR.Reg, volatile.LoadUint8(&o.STCR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetSTCR_CF0MCL() uint8 {
	return (volatile.LoadUint8(&o.STCR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetSTCR_CF1MCL(value uint8) {
	volatile.StoreUint8(&o.STCR.Reg, volatile.LoadUint8(&o.STCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetSTCR_CF1MCL() uint8 {
	return (volatile.LoadUint8(&o.STCR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetSTCR_PIBDCL(value uint8) {
	volatile.StoreUint8(&o.STCR.Reg, volatile.LoadUint8(&o.STCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetSTCR_PIBDCL() uint8 {
	return (volatile.LoadUint8(&o.STCR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetSTCR_BCDCL(value uint8) {
	volatile.StoreUint8(&o.STCR.Reg, volatile.LoadUint8(&o.STCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetSTCR_BCDCL() uint8 {
	return (volatile.LoadUint8(&o.STCR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetSTCR_AEDCL(value uint8) {
	volatile.StoreUint8(&o.STCR.Reg, volatile.LoadUint8(&o.STCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetSTCR_AEDCL() uint8 {
	return (volatile.LoadUint8(&o.STCR.Reg) & 0x20) >> 5
}

// SCI2.CF0CR: Control Field 0 Compare Enable Register
func (o *SCI2_Type) SetCF0CR_CF0CE0(value uint8) {
	volatile.StoreUint8(&o.CF0CR.Reg, volatile.LoadUint8(&o.CF0CR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetCF0CR_CF0CE0() uint8 {
	return volatile.LoadUint8(&o.CF0CR.Reg) & 0x1
}
func (o *SCI2_Type) SetCF0CR_CF0CE1(value uint8) {
	volatile.StoreUint8(&o.CF0CR.Reg, volatile.LoadUint8(&o.CF0CR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetCF0CR_CF0CE1() uint8 {
	return (volatile.LoadUint8(&o.CF0CR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetCF0CR_CF0CE2(value uint8) {
	volatile.StoreUint8(&o.CF0CR.Reg, volatile.LoadUint8(&o.CF0CR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetCF0CR_CF0CE2() uint8 {
	return (volatile.LoadUint8(&o.CF0CR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetCF0CR_CF0CE3(value uint8) {
	volatile.StoreUint8(&o.CF0CR.Reg, volatile.LoadUint8(&o.CF0CR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetCF0CR_CF0CE3() uint8 {
	return (volatile.LoadUint8(&o.CF0CR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetCF0CR_CF0CE4(value uint8) {
	volatile.StoreUint8(&o.CF0CR.Reg, volatile.LoadUint8(&o.CF0CR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetCF0CR_CF0CE4() uint8 {
	return (volatile.LoadUint8(&o.CF0CR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetCF0CR_CF0CE5(value uint8) {
	volatile.StoreUint8(&o.CF0CR.Reg, volatile.LoadUint8(&o.CF0CR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetCF0CR_CF0CE5() uint8 {
	return (volatile.LoadUint8(&o.CF0CR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetCF0CR_CF0CE6(value uint8) {
	volatile.StoreUint8(&o.CF0CR.Reg, volatile.LoadUint8(&o.CF0CR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetCF0CR_CF0CE6() uint8 {
	return (volatile.LoadUint8(&o.CF0CR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetCF0CR_CF0CE7(value uint8) {
	volatile.StoreUint8(&o.CF0CR.Reg, volatile.LoadUint8(&o.CF0CR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetCF0CR_CF0CE7() uint8 {
	return (volatile.LoadUint8(&o.CF0CR.Reg) & 0x80) >> 7
}

// SCI2.CF1CR: Control Field 1 Compare Enable Register
func (o *SCI2_Type) SetCF1CR_CF1CE0(value uint8) {
	volatile.StoreUint8(&o.CF1CR.Reg, volatile.LoadUint8(&o.CF1CR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetCF1CR_CF1CE0() uint8 {
	return volatile.LoadUint8(&o.CF1CR.Reg) & 0x1
}
func (o *SCI2_Type) SetCF1CR_CF1CE1(value uint8) {
	volatile.StoreUint8(&o.CF1CR.Reg, volatile.LoadUint8(&o.CF1CR.Reg)&^(0x2)|value<<1)
}
func (o *SCI2_Type) GetCF1CR_CF1CE1() uint8 {
	return (volatile.LoadUint8(&o.CF1CR.Reg) & 0x2) >> 1
}
func (o *SCI2_Type) SetCF1CR_CF1CE2(value uint8) {
	volatile.StoreUint8(&o.CF1CR.Reg, volatile.LoadUint8(&o.CF1CR.Reg)&^(0x4)|value<<2)
}
func (o *SCI2_Type) GetCF1CR_CF1CE2() uint8 {
	return (volatile.LoadUint8(&o.CF1CR.Reg) & 0x4) >> 2
}
func (o *SCI2_Type) SetCF1CR_CF1CE3(value uint8) {
	volatile.StoreUint8(&o.CF1CR.Reg, volatile.LoadUint8(&o.CF1CR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetCF1CR_CF1CE3() uint8 {
	return (volatile.LoadUint8(&o.CF1CR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetCF1CR_CF1CE4(value uint8) {
	volatile.StoreUint8(&o.CF1CR.Reg, volatile.LoadUint8(&o.CF1CR.Reg)&^(0x10)|value<<4)
}
func (o *SCI2_Type) GetCF1CR_CF1CE4() uint8 {
	return (volatile.LoadUint8(&o.CF1CR.Reg) & 0x10) >> 4
}
func (o *SCI2_Type) SetCF1CR_CF1CE5(value uint8) {
	volatile.StoreUint8(&o.CF1CR.Reg, volatile.LoadUint8(&o.CF1CR.Reg)&^(0x20)|value<<5)
}
func (o *SCI2_Type) GetCF1CR_CF1CE5() uint8 {
	return (volatile.LoadUint8(&o.CF1CR.Reg) & 0x20) >> 5
}
func (o *SCI2_Type) SetCF1CR_CF1CE6(value uint8) {
	volatile.StoreUint8(&o.CF1CR.Reg, volatile.LoadUint8(&o.CF1CR.Reg)&^(0x40)|value<<6)
}
func (o *SCI2_Type) GetCF1CR_CF1CE6() uint8 {
	return (volatile.LoadUint8(&o.CF1CR.Reg) & 0x40) >> 6
}
func (o *SCI2_Type) SetCF1CR_CF1CE7(value uint8) {
	volatile.StoreUint8(&o.CF1CR.Reg, volatile.LoadUint8(&o.CF1CR.Reg)&^(0x80)|value<<7)
}
func (o *SCI2_Type) GetCF1CR_CF1CE7() uint8 {
	return (volatile.LoadUint8(&o.CF1CR.Reg) & 0x80) >> 7
}

// SCI2.TCR: Timer Control Register
func (o *SCI2_Type) SetTCR_TCST(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0x1)|value)
}
func (o *SCI2_Type) GetTCR_TCST() uint8 {
	return volatile.LoadUint8(&o.TCR.Reg) & 0x1
}

// SCI2.TMR: Timer Mode Register
func (o *SCI2_Type) SetTMR_TOMS(value uint8) {
	volatile.StoreUint8(&o.TMR.Reg, volatile.LoadUint8(&o.TMR.Reg)&^(0x3)|value)
}
func (o *SCI2_Type) GetTMR_TOMS() uint8 {
	return volatile.LoadUint8(&o.TMR.Reg) & 0x3
}
func (o *SCI2_Type) SetTMR_TWRC(value uint8) {
	volatile.StoreUint8(&o.TMR.Reg, volatile.LoadUint8(&o.TMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI2_Type) GetTMR_TWRC() uint8 {
	return (volatile.LoadUint8(&o.TMR.Reg) & 0x8) >> 3
}
func (o *SCI2_Type) SetTMR_TCSS(value uint8) {
	volatile.StoreUint8(&o.TMR.Reg, volatile.LoadUint8(&o.TMR.Reg)&^(0x70)|value<<4)
}
func (o *SCI2_Type) GetTMR_TCSS() uint8 {
	return (volatile.LoadUint8(&o.TMR.Reg) & 0x70) >> 4
}

// Serial Communication Interface
type SCI3_Type struct {
	SMR    volatile.Register8  // 0x0
	BRR    volatile.Register8  // 0x1
	SCR    volatile.Register8  // 0x2
	TDR    volatile.Register8  // 0x3
	SSR    volatile.Register8  // 0x4
	RDR    volatile.Register8  // 0x5
	SCMR   volatile.Register8  // 0x6
	SEMR   volatile.Register8  // 0x7
	SNFR   volatile.Register8  // 0x8
	SIMR1  volatile.Register8  // 0x9
	SIMR2  volatile.Register8  // 0xA
	SIMR3  volatile.Register8  // 0xB
	SISR   volatile.Register8  // 0xC
	SPMR   volatile.Register8  // 0xD
	FTDRHL volatile.Register16 // 0xE
	FRDRHL volatile.Register16 // 0x10
	MDDR   volatile.Register8  // 0x12
	DCCR   volatile.Register8  // 0x13
	FCR    volatile.Register16 // 0x14
	FDR    volatile.Register16 // 0x16
	LSR    volatile.Register16 // 0x18
	CDR    volatile.Register16 // 0x1A
	SPTR   volatile.Register8  // 0x1C
	ACTR   volatile.Register8  // 0x1D
	_      [2]byte
	MMR    volatile.Register8 // 0x20
	_      byte
	TMPR   volatile.Register8 // 0x22
	RMPR   volatile.Register8 // 0x23
	MESR   volatile.Register8 // 0x24
	MECR   volatile.Register8 // 0x25
}

// SCI3.SMR: Serial Mode Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
func (o *SCI3_Type) SetSMR_CKS(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x3)|value)
}
func (o *SCI3_Type) GetSMR_CKS() uint8 {
	return volatile.LoadUint8(&o.SMR.Reg) & 0x3
}
func (o *SCI3_Type) SetSMR_MP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI3_Type) GetSMR_MP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x4) >> 2
}
func (o *SCI3_Type) SetSMR_STOP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI3_Type) GetSMR_STOP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x8) >> 3
}
func (o *SCI3_Type) SetSMR_PM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI3_Type) GetSMR_PM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x10) >> 4
}
func (o *SCI3_Type) SetSMR_PE(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI3_Type) GetSMR_PE() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x20) >> 5
}
func (o *SCI3_Type) SetSMR_CHR(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI3_Type) GetSMR_CHR() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x40) >> 6
}
func (o *SCI3_Type) SetSMR_CM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI3_Type) GetSMR_CM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x80) >> 7
}

// SCI3.SCR: Serial Control Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
func (o *SCI3_Type) SetSCR_CKE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x3)|value)
}
func (o *SCI3_Type) GetSCR_CKE() uint8 {
	return volatile.LoadUint8(&o.SCR.Reg) & 0x3
}
func (o *SCI3_Type) SetSCR_TEIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI3_Type) GetSCR_TEIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCI3_Type) SetSCR_MPIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI3_Type) GetSCR_MPIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x8) >> 3
}
func (o *SCI3_Type) SetSCR_RE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI3_Type) GetSCR_RE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x10) >> 4
}
func (o *SCI3_Type) SetSCR_TE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI3_Type) GetSCR_TE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x20) >> 5
}
func (o *SCI3_Type) SetSCR_RIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI3_Type) GetSCR_RIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x40) >> 6
}
func (o *SCI3_Type) SetSCR_TIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI3_Type) GetSCR_TIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x80) >> 7
}

// SCI3.SSR: Serial Status Register for Non-Smart Card Interface and Non-FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0, and MMR.MANEN = 0)
func (o *SCI3_Type) SetSSR_MPBT(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetSSR_MPBT() uint8 {
	return volatile.LoadUint8(&o.SSR.Reg) & 0x1
}
func (o *SCI3_Type) SetSSR_MPB(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x2)|value<<1)
}
func (o *SCI3_Type) GetSSR_MPB() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x2) >> 1
}
func (o *SCI3_Type) SetSSR_TEND(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x4)|value<<2)
}
func (o *SCI3_Type) GetSSR_TEND() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x4) >> 2
}
func (o *SCI3_Type) SetSSR_PER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x8)|value<<3)
}
func (o *SCI3_Type) GetSSR_PER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x8) >> 3
}
func (o *SCI3_Type) SetSSR_FER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x10)|value<<4)
}
func (o *SCI3_Type) GetSSR_FER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x10) >> 4
}
func (o *SCI3_Type) SetSSR_ORER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x20)|value<<5)
}
func (o *SCI3_Type) GetSSR_ORER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x20) >> 5
}
func (o *SCI3_Type) SetSSR_RDRF(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x40)|value<<6)
}
func (o *SCI3_Type) GetSSR_RDRF() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x40) >> 6
}
func (o *SCI3_Type) SetSSR_TDRE(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x80)|value<<7)
}
func (o *SCI3_Type) GetSSR_TDRE() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x80) >> 7
}

// SCI3.SCMR: Smart Card Mode Register
func (o *SCI3_Type) SetSCMR_SMIF(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetSCMR_SMIF() uint8 {
	return volatile.LoadUint8(&o.SCMR.Reg) & 0x1
}
func (o *SCI3_Type) SetSCMR_SINV(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI3_Type) GetSCMR_SINV() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x4) >> 2
}
func (o *SCI3_Type) SetSCMR_SDIR(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI3_Type) GetSCMR_SDIR() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x8) >> 3
}
func (o *SCI3_Type) SetSCMR_CHR1(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI3_Type) GetSCMR_CHR1() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x10) >> 4
}
func (o *SCI3_Type) SetSCMR_BCP2(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI3_Type) GetSCMR_BCP2() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x80) >> 7
}

// SCI3.SEMR: Serial Extended Mode Register
func (o *SCI3_Type) SetSEMR_ACS0(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetSEMR_ACS0() uint8 {
	return volatile.LoadUint8(&o.SEMR.Reg) & 0x1
}
func (o *SCI3_Type) SetSEMR_PADIS(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI3_Type) GetSEMR_PADIS() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x2) >> 1
}
func (o *SCI3_Type) SetSEMR_BRME(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI3_Type) GetSEMR_BRME() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x4) >> 2
}
func (o *SCI3_Type) SetSEMR_ABCSE(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI3_Type) GetSEMR_ABCSE() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x8) >> 3
}
func (o *SCI3_Type) SetSEMR_ABCS(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI3_Type) GetSEMR_ABCS() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x10) >> 4
}
func (o *SCI3_Type) SetSEMR_NFEN(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI3_Type) GetSEMR_NFEN() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x20) >> 5
}
func (o *SCI3_Type) SetSEMR_BGDM(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI3_Type) GetSEMR_BGDM() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x40) >> 6
}
func (o *SCI3_Type) SetSEMR_RXDESEL(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI3_Type) GetSEMR_RXDESEL() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x80) >> 7
}

// SCI3.SNFR: Noise Filter Setting Register
func (o *SCI3_Type) SetSNFR_NFCS(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0x7)|value)
}
func (o *SCI3_Type) GetSNFR_NFCS() uint8 {
	return volatile.LoadUint8(&o.SNFR.Reg) & 0x7
}

// SCI3.SIMR1: IIC Mode Register 1
func (o *SCI3_Type) SetSIMR1_IICM(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetSIMR1_IICM() uint8 {
	return volatile.LoadUint8(&o.SIMR1.Reg) & 0x1
}
func (o *SCI3_Type) SetSIMR1_IICDL(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0xf8)|value<<3)
}
func (o *SCI3_Type) GetSIMR1_IICDL() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0xf8) >> 3
}

// SCI3.SIMR2: IIC Mode Register 2
func (o *SCI3_Type) SetSIMR2_IICINTM(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetSIMR2_IICINTM() uint8 {
	return volatile.LoadUint8(&o.SIMR2.Reg) & 0x1
}
func (o *SCI3_Type) SetSIMR2_IICCSC(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x2)|value<<1)
}
func (o *SCI3_Type) GetSIMR2_IICCSC() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x2) >> 1
}
func (o *SCI3_Type) SetSIMR2_IICACKT(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x20)|value<<5)
}
func (o *SCI3_Type) GetSIMR2_IICACKT() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x20) >> 5
}

// SCI3.SIMR3: IIC Mode Register 3
func (o *SCI3_Type) SetSIMR3_IICSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetSIMR3_IICSTAREQ() uint8 {
	return volatile.LoadUint8(&o.SIMR3.Reg) & 0x1
}
func (o *SCI3_Type) SetSIMR3_IICRSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x2)|value<<1)
}
func (o *SCI3_Type) GetSIMR3_IICRSTAREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x2) >> 1
}
func (o *SCI3_Type) SetSIMR3_IICSTPREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x4)|value<<2)
}
func (o *SCI3_Type) GetSIMR3_IICSTPREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x4) >> 2
}
func (o *SCI3_Type) SetSIMR3_IICSTIF(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x8)|value<<3)
}
func (o *SCI3_Type) GetSIMR3_IICSTIF() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x8) >> 3
}
func (o *SCI3_Type) SetSIMR3_IICSDAS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x30)|value<<4)
}
func (o *SCI3_Type) GetSIMR3_IICSDAS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x30) >> 4
}
func (o *SCI3_Type) SetSIMR3_IICSCLS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0xc0)|value<<6)
}
func (o *SCI3_Type) GetSIMR3_IICSCLS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0xc0) >> 6
}

// SCI3.SISR: IIC Status Register
func (o *SCI3_Type) SetSISR_IICACKR(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetSISR_IICACKR() uint8 {
	return volatile.LoadUint8(&o.SISR.Reg) & 0x1
}

// SCI3.SPMR: SPI Mode Register
func (o *SCI3_Type) SetSPMR_SSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetSPMR_SSE() uint8 {
	return volatile.LoadUint8(&o.SPMR.Reg) & 0x1
}
func (o *SCI3_Type) SetSPMR_CTSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI3_Type) GetSPMR_CTSE() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x2) >> 1
}
func (o *SCI3_Type) SetSPMR_MSS(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI3_Type) GetSPMR_MSS() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x4) >> 2
}
func (o *SCI3_Type) SetSPMR_CTSPEN(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI3_Type) GetSPMR_CTSPEN() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x8) >> 3
}
func (o *SCI3_Type) SetSPMR_MFF(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI3_Type) GetSPMR_MFF() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x10) >> 4
}
func (o *SCI3_Type) SetSPMR_CKPOL(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI3_Type) GetSPMR_CKPOL() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x40) >> 6
}
func (o *SCI3_Type) SetSPMR_CKPH(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI3_Type) GetSPMR_CKPH() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x80) >> 7
}

// SCI3.FTDRHL: Transmit FIFO Data Register
func (o *SCI3_Type) SetFTDRHL_TDAT(value uint16) {
	volatile.StoreUint16(&o.FTDRHL.Reg, volatile.LoadUint16(&o.FTDRHL.Reg)&^(0x1ff)|value)
}
func (o *SCI3_Type) GetFTDRHL_TDAT() uint16 {
	return volatile.LoadUint16(&o.FTDRHL.Reg) & 0x1ff
}
func (o *SCI3_Type) SetFTDRHL_MPBT(value uint16) {
	volatile.StoreUint16(&o.FTDRHL.Reg, volatile.LoadUint16(&o.FTDRHL.Reg)&^(0x200)|value<<9)
}
func (o *SCI3_Type) GetFTDRHL_MPBT() uint16 {
	return (volatile.LoadUint16(&o.FTDRHL.Reg) & 0x200) >> 9
}

// SCI3.FRDRHL: Receive FIFO Data Register
func (o *SCI3_Type) SetFRDRHL_RDAT(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x1ff)|value)
}
func (o *SCI3_Type) GetFRDRHL_RDAT() uint16 {
	return volatile.LoadUint16(&o.FRDRHL.Reg) & 0x1ff
}
func (o *SCI3_Type) SetFRDRHL_MPB(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x200)|value<<9)
}
func (o *SCI3_Type) GetFRDRHL_MPB() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x200) >> 9
}
func (o *SCI3_Type) SetFRDRHL_DR(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x400)|value<<10)
}
func (o *SCI3_Type) GetFRDRHL_DR() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x400) >> 10
}
func (o *SCI3_Type) SetFRDRHL_PER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x800)|value<<11)
}
func (o *SCI3_Type) GetFRDRHL_PER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x800) >> 11
}
func (o *SCI3_Type) SetFRDRHL_FER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x1000)|value<<12)
}
func (o *SCI3_Type) GetFRDRHL_FER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x1000) >> 12
}
func (o *SCI3_Type) SetFRDRHL_ORER(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x2000)|value<<13)
}
func (o *SCI3_Type) GetFRDRHL_ORER() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x2000) >> 13
}
func (o *SCI3_Type) SetFRDRHL_RDF(value uint16) {
	volatile.StoreUint16(&o.FRDRHL.Reg, volatile.LoadUint16(&o.FRDRHL.Reg)&^(0x4000)|value<<14)
}
func (o *SCI3_Type) GetFRDRHL_RDF() uint16 {
	return (volatile.LoadUint16(&o.FRDRHL.Reg) & 0x4000) >> 14
}

// SCI3.DCCR: Data Compare Match Control Register
func (o *SCI3_Type) SetDCCR_DCMF(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetDCCR_DCMF() uint8 {
	return volatile.LoadUint8(&o.DCCR.Reg) & 0x1
}
func (o *SCI3_Type) SetDCCR_DPER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI3_Type) GetDCCR_DPER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x8) >> 3
}
func (o *SCI3_Type) SetDCCR_DFER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI3_Type) GetDCCR_DFER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x10) >> 4
}
func (o *SCI3_Type) SetDCCR_IDSEL(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI3_Type) GetDCCR_IDSEL() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x40) >> 6
}
func (o *SCI3_Type) SetDCCR_DCME(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI3_Type) GetDCCR_DCME() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x80) >> 7
}

// SCI3.FCR: FIFO Control Register
func (o *SCI3_Type) SetFCR_FM(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetFCR_FM() uint16 {
	return volatile.LoadUint16(&o.FCR.Reg) & 0x1
}
func (o *SCI3_Type) SetFCR_RFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x2)|value<<1)
}
func (o *SCI3_Type) GetFCR_RFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x2) >> 1
}
func (o *SCI3_Type) SetFCR_TFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI3_Type) GetFCR_TFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x4) >> 2
}
func (o *SCI3_Type) SetFCR_DRES(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI3_Type) GetFCR_DRES() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x8) >> 3
}
func (o *SCI3_Type) SetFCR_TTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf0)|value<<4)
}
func (o *SCI3_Type) GetFCR_TTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf0) >> 4
}
func (o *SCI3_Type) SetFCR_RTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf00)|value<<8)
}
func (o *SCI3_Type) GetFCR_RTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf00) >> 8
}
func (o *SCI3_Type) SetFCR_RSTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf000)|value<<12)
}
func (o *SCI3_Type) GetFCR_RSTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf000) >> 12
}

// SCI3.FDR: FIFO Data Count Register
func (o *SCI3_Type) SetFDR_R(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f)|value)
}
func (o *SCI3_Type) GetFDR_R() uint16 {
	return volatile.LoadUint16(&o.FDR.Reg) & 0x1f
}
func (o *SCI3_Type) SetFDR_T(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI3_Type) GetFDR_T() uint16 {
	return (volatile.LoadUint16(&o.FDR.Reg) & 0x1f00) >> 8
}

// SCI3.LSR: Line Status Register
func (o *SCI3_Type) SetLSR_ORER(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetLSR_ORER() uint16 {
	return volatile.LoadUint16(&o.LSR.Reg) & 0x1
}
func (o *SCI3_Type) SetLSR_FNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x7c)|value<<2)
}
func (o *SCI3_Type) GetLSR_FNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x7c) >> 2
}
func (o *SCI3_Type) SetLSR_PNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI3_Type) GetLSR_PNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x1f00) >> 8
}

// SCI3.CDR: Compare Match Data Register
func (o *SCI3_Type) SetCDR_CMPD(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0x1ff)|value)
}
func (o *SCI3_Type) GetCDR_CMPD() uint16 {
	return volatile.LoadUint16(&o.CDR.Reg) & 0x1ff
}

// SCI3.SPTR: Serial Port Register
func (o *SCI3_Type) SetSPTR_RXDMON(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetSPTR_RXDMON() uint8 {
	return volatile.LoadUint8(&o.SPTR.Reg) & 0x1
}
func (o *SCI3_Type) SetSPTR_SPB2DT(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x2)|value<<1)
}
func (o *SCI3_Type) GetSPTR_SPB2DT() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x2) >> 1
}
func (o *SCI3_Type) SetSPTR_SPB2IO(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x4)|value<<2)
}
func (o *SCI3_Type) GetSPTR_SPB2IO() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x4) >> 2
}
func (o *SCI3_Type) SetSPTR_RINV(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x10)|value<<4)
}
func (o *SCI3_Type) GetSPTR_RINV() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x10) >> 4
}
func (o *SCI3_Type) SetSPTR_TINV(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x20)|value<<5)
}
func (o *SCI3_Type) GetSPTR_TINV() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x20) >> 5
}
func (o *SCI3_Type) SetSPTR_ASEN(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x40)|value<<6)
}
func (o *SCI3_Type) GetSPTR_ASEN() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x40) >> 6
}
func (o *SCI3_Type) SetSPTR_ATEN(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x80)|value<<7)
}
func (o *SCI3_Type) GetSPTR_ATEN() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x80) >> 7
}

// SCI3.ACTR: Adjustment Communication Timing Register
func (o *SCI3_Type) SetACTR_AST(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x7)|value)
}
func (o *SCI3_Type) GetACTR_AST() uint8 {
	return volatile.LoadUint8(&o.ACTR.Reg) & 0x7
}
func (o *SCI3_Type) SetACTR_AJD(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x8)|value<<3)
}
func (o *SCI3_Type) GetACTR_AJD() uint8 {
	return (volatile.LoadUint8(&o.ACTR.Reg) & 0x8) >> 3
}
func (o *SCI3_Type) SetACTR_ATT(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x70)|value<<4)
}
func (o *SCI3_Type) GetACTR_ATT() uint8 {
	return (volatile.LoadUint8(&o.ACTR.Reg) & 0x70) >> 4
}
func (o *SCI3_Type) SetACTR_AET(value uint8) {
	volatile.StoreUint8(&o.ACTR.Reg, volatile.LoadUint8(&o.ACTR.Reg)&^(0x80)|value<<7)
}
func (o *SCI3_Type) GetACTR_AET() uint8 {
	return (volatile.LoadUint8(&o.ACTR.Reg) & 0x80) >> 7
}

// SCI3.MMR: Manchester Mode Register
func (o *SCI3_Type) SetMMR_RMPOL(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetMMR_RMPOL() uint8 {
	return volatile.LoadUint8(&o.MMR.Reg) & 0x1
}
func (o *SCI3_Type) SetMMR_TMPOL(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI3_Type) GetMMR_TMPOL() uint8 {
	return (volatile.LoadUint8(&o.MMR.Reg) & 0x2) >> 1
}
func (o *SCI3_Type) SetMMR_ERTEN(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI3_Type) GetMMR_ERTEN() uint8 {
	return (volatile.LoadUint8(&o.MMR.Reg) & 0x4) >> 2
}
func (o *SCI3_Type) SetMMR_SYNVAL(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI3_Type) GetMMR_SYNVAL() uint8 {
	return (volatile.LoadUint8(&o.MMR.Reg) & 0x10) >> 4
}
func (o *SCI3_Type) SetMMR_SYNSEL(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI3_Type) GetMMR_SYNSEL() uint8 {
	return (volatile.LoadUint8(&o.MMR.Reg) & 0x20) >> 5
}
func (o *SCI3_Type) SetMMR_SBSEL(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI3_Type) GetMMR_SBSEL() uint8 {
	return (volatile.LoadUint8(&o.MMR.Reg) & 0x40) >> 6
}
func (o *SCI3_Type) SetMMR_MANEN(value uint8) {
	volatile.StoreUint8(&o.MMR.Reg, volatile.LoadUint8(&o.MMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI3_Type) GetMMR_MANEN() uint8 {
	return (volatile.LoadUint8(&o.MMR.Reg) & 0x80) >> 7
}

// SCI3.TMPR: Transmit Manchester Preface Setting Register
func (o *SCI3_Type) SetTMPR_TPLEN(value uint8) {
	volatile.StoreUint8(&o.TMPR.Reg, volatile.LoadUint8(&o.TMPR.Reg)&^(0xf)|value)
}
func (o *SCI3_Type) GetTMPR_TPLEN() uint8 {
	return volatile.LoadUint8(&o.TMPR.Reg) & 0xf
}
func (o *SCI3_Type) SetTMPR_TPPAT(value uint8) {
	volatile.StoreUint8(&o.TMPR.Reg, volatile.LoadUint8(&o.TMPR.Reg)&^(0x30)|value<<4)
}
func (o *SCI3_Type) GetTMPR_TPPAT() uint8 {
	return (volatile.LoadUint8(&o.TMPR.Reg) & 0x30) >> 4
}

// SCI3.RMPR: Receive Manchester Preface Setting Register
func (o *SCI3_Type) SetRMPR_RPLEN(value uint8) {
	volatile.StoreUint8(&o.RMPR.Reg, volatile.LoadUint8(&o.RMPR.Reg)&^(0xf)|value)
}
func (o *SCI3_Type) GetRMPR_RPLEN() uint8 {
	return volatile.LoadUint8(&o.RMPR.Reg) & 0xf
}
func (o *SCI3_Type) SetRMPR_RPPAT(value uint8) {
	volatile.StoreUint8(&o.RMPR.Reg, volatile.LoadUint8(&o.RMPR.Reg)&^(0x30)|value<<4)
}
func (o *SCI3_Type) GetRMPR_RPPAT() uint8 {
	return (volatile.LoadUint8(&o.RMPR.Reg) & 0x30) >> 4
}

// SCI3.MESR: Manchester Extended Error Status Register
func (o *SCI3_Type) SetMESR_PFER(value uint8) {
	volatile.StoreUint8(&o.MESR.Reg, volatile.LoadUint8(&o.MESR.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetMESR_PFER() uint8 {
	return volatile.LoadUint8(&o.MESR.Reg) & 0x1
}
func (o *SCI3_Type) SetMESR_SYER(value uint8) {
	volatile.StoreUint8(&o.MESR.Reg, volatile.LoadUint8(&o.MESR.Reg)&^(0x2)|value<<1)
}
func (o *SCI3_Type) GetMESR_SYER() uint8 {
	return (volatile.LoadUint8(&o.MESR.Reg) & 0x2) >> 1
}
func (o *SCI3_Type) SetMESR_SBER(value uint8) {
	volatile.StoreUint8(&o.MESR.Reg, volatile.LoadUint8(&o.MESR.Reg)&^(0x4)|value<<2)
}
func (o *SCI3_Type) GetMESR_SBER() uint8 {
	return (volatile.LoadUint8(&o.MESR.Reg) & 0x4) >> 2
}

// SCI3.MECR: Manchester Extended Error Control Register
func (o *SCI3_Type) SetMECR_PFEREN(value uint8) {
	volatile.StoreUint8(&o.MECR.Reg, volatile.LoadUint8(&o.MECR.Reg)&^(0x1)|value)
}
func (o *SCI3_Type) GetMECR_PFEREN() uint8 {
	return volatile.LoadUint8(&o.MECR.Reg) & 0x1
}
func (o *SCI3_Type) SetMECR_SYEREN(value uint8) {
	volatile.StoreUint8(&o.MECR.Reg, volatile.LoadUint8(&o.MECR.Reg)&^(0x2)|value<<1)
}
func (o *SCI3_Type) GetMECR_SYEREN() uint8 {
	return (volatile.LoadUint8(&o.MECR.Reg) & 0x2) >> 1
}
func (o *SCI3_Type) SetMECR_SBEREN(value uint8) {
	volatile.StoreUint8(&o.MECR.Reg, volatile.LoadUint8(&o.MECR.Reg)&^(0x4)|value<<2)
}
func (o *SCI3_Type) GetMECR_SBEREN() uint8 {
	return (volatile.LoadUint8(&o.MECR.Reg) & 0x4) >> 2
}

// Serial Peripheral Interface 0
type SPI0_Type struct {
	SPCR   volatile.Register8  // 0x0
	SSLP   volatile.Register8  // 0x1
	SPPCR  volatile.Register8  // 0x2
	SPSR   volatile.Register8  // 0x3
	SPDR   volatile.Register32 // 0x4
	SPSCR  volatile.Register8  // 0x8
	SPSSR  volatile.Register8  // 0x9
	SPBR   volatile.Register8  // 0xA
	SPDCR  volatile.Register8  // 0xB
	SPCKD  volatile.Register8  // 0xC
	SSLND  volatile.Register8  // 0xD
	SPND   volatile.Register8  // 0xE
	SPCR2  volatile.Register8  // 0xF
	SPCMD0 volatile.Register16 // 0x10
	SPCMD1 volatile.Register16 // 0x12
	SPCMD2 volatile.Register16 // 0x14
	SPCMD3 volatile.Register16 // 0x16
	SPCMD4 volatile.Register16 // 0x18
	SPCMD5 volatile.Register16 // 0x1A
	SPCMD6 volatile.Register16 // 0x1C
	SPCMD7 volatile.Register16 // 0x1E
	SPDCR2 volatile.Register8  // 0x20
	SPCR3  volatile.Register8  // 0x21
}

// SPI0.SPCR: SPI Control Register
func (o *SPI0_Type) SetSPCR_SPMS(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCR_SPMS() uint8 {
	return volatile.LoadUint8(&o.SPCR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCR_TXMD(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCR_TXMD() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCR_MODFEN(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPCR_MODFEN() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPCR_MSTR(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPCR_MSTR() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPCR_SPEIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPCR_SPEIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPCR_SPTIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPCR_SPTIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPCR_SPE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPCR_SPE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPCR_SPRIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCR_SPRIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x80) >> 7
}

// SPI0.SSLP: SPI Slave Select Polarity Register
func (o *SPI0_Type) SetSSLP_SSL0P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSSLP_SSL0P() uint8 {
	return volatile.LoadUint8(&o.SSLP.Reg) & 0x1
}
func (o *SPI0_Type) SetSSLP_SSL1P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSSLP_SSL1P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSSLP_SSL2P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSSLP_SSL2P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSSLP_SSL3P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSSLP_SSL3P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x8) >> 3
}

// SPI0.SPPCR: SPI Pin Control Register
func (o *SPI0_Type) SetSPPCR_SPLP(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPPCR_SPLP() uint8 {
	return volatile.LoadUint8(&o.SPPCR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPPCR_SPLP2(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPPCR_SPLP2() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPPCR_MOIFV(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPPCR_MOIFV() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPPCR_MOIFE(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPPCR_MOIFE() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x20) >> 5
}

// SPI0.SPSR: SPI Status Register
func (o *SPI0_Type) SetSPSR_OVRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPSR_OVRF() uint8 {
	return volatile.LoadUint8(&o.SPSR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPSR_IDLNF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPSR_IDLNF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPSR_MODF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPSR_MODF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPSR_PERF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPSR_PERF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPSR_UDRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPSR_UDRF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPSR_SPTEF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPSR_SPTEF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPSR_CENDF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPSR_CENDF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPSR_SPRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPSR_SPRF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x80) >> 7
}

// SPI0.SPSCR: SPI Sequence Control Register
func (o *SPI0_Type) SetSPSCR_SPSLN(value uint8) {
	volatile.StoreUint8(&o.SPSCR.Reg, volatile.LoadUint8(&o.SPSCR.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPSCR_SPSLN() uint8 {
	return volatile.LoadUint8(&o.SPSCR.Reg) & 0x7
}

// SPI0.SPSSR: SPI Sequence Status Register
func (o *SPI0_Type) SetSPSSR_SPCP(value uint8) {
	volatile.StoreUint8(&o.SPSSR.Reg, volatile.LoadUint8(&o.SPSSR.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPSSR_SPCP() uint8 {
	return volatile.LoadUint8(&o.SPSSR.Reg) & 0x7
}
func (o *SPI0_Type) SetSPSSR_SPECM(value uint8) {
	volatile.StoreUint8(&o.SPSSR.Reg, volatile.LoadUint8(&o.SPSSR.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPSSR_SPECM() uint8 {
	return (volatile.LoadUint8(&o.SPSSR.Reg) & 0x70) >> 4
}

// SPI0.SPDCR: SPI Data Control Register
func (o *SPI0_Type) SetSPDCR_SPFC(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x3)|value)
}
func (o *SPI0_Type) GetSPDCR_SPFC() uint8 {
	return volatile.LoadUint8(&o.SPDCR.Reg) & 0x3
}
func (o *SPI0_Type) SetSPDCR_SPRDTD(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPDCR_SPRDTD() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPDCR_SPLW(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPDCR_SPLW() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPDCR_SPBYT(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPDCR_SPBYT() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x40) >> 6
}

// SPI0.SPCKD: SPI Clock Delay Register
func (o *SPI0_Type) SetSPCKD_SCKDL(value uint8) {
	volatile.StoreUint8(&o.SPCKD.Reg, volatile.LoadUint8(&o.SPCKD.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPCKD_SCKDL() uint8 {
	return volatile.LoadUint8(&o.SPCKD.Reg) & 0x7
}

// SPI0.SSLND: SPI Slave Select Negation Delay Register
func (o *SPI0_Type) SetSSLND_SLNDL(value uint8) {
	volatile.StoreUint8(&o.SSLND.Reg, volatile.LoadUint8(&o.SSLND.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSSLND_SLNDL() uint8 {
	return volatile.LoadUint8(&o.SSLND.Reg) & 0x7
}

// SPI0.SPND: SPI Next-Access Delay Register
func (o *SPI0_Type) SetSPND_SPNDL(value uint8) {
	volatile.StoreUint8(&o.SPND.Reg, volatile.LoadUint8(&o.SPND.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPND_SPNDL() uint8 {
	return volatile.LoadUint8(&o.SPND.Reg) & 0x7
}

// SPI0.SPCR2: SPI Control Register 2
func (o *SPI0_Type) SetSPCR2_SPPE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCR2_SPPE() uint8 {
	return volatile.LoadUint8(&o.SPCR2.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCR2_SPOE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCR2_SPOE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCR2_SPIIE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPCR2_SPIIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPCR2_PTE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPCR2_PTE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPCR2_SCKASE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPCR2_SCKASE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x10) >> 4
}

// SPI0.SPCMD0: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD0_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD0_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD0.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCMD0_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD0_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD0_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD0_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD0_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD0_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD0_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD0_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD0_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD0_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD0_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD0_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD0_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD0_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD0_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD0_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD0_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD0_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x8000) >> 15
}

// SPI0.SPCMD1: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD1_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD1_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD1.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCMD1_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD1_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD1_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD1_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD1_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD1_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD1_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD1_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD1_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD1_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD1_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD1_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD1_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD1_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD1_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD1_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD1_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD1_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x8000) >> 15
}

// SPI0.SPCMD2: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD2_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD2_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD2.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCMD2_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD2_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD2_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD2_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD2_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD2_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD2_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD2_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD2_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD2_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD2_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD2_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD2_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD2_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD2_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD2_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD2_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD2_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x8000) >> 15
}

// SPI0.SPCMD3: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD3_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD3_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD3.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCMD3_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD3_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD3_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD3_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD3_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD3_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD3_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD3_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD3_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD3_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD3_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD3_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD3_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD3_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD3_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD3_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD3_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD3_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x8000) >> 15
}

// SPI0.SPCMD4: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD4_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD4_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD4.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCMD4_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD4_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD4_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD4_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD4_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD4_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD4_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD4_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD4_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD4_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD4_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD4_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD4_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD4_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD4_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD4_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD4_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD4_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x8000) >> 15
}

// SPI0.SPCMD5: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD5_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD5_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD5.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCMD5_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD5_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD5_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD5_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD5_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD5_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD5_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD5_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD5_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD5_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD5_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD5_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD5_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD5_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD5_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD5_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD5_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD5_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x8000) >> 15
}

// SPI0.SPCMD6: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD6_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD6_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD6.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCMD6_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD6_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD6_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD6_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD6_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD6_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD6_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD6_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD6_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD6_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD6_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD6_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD6_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD6_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD6_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD6_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD6_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD6_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x8000) >> 15
}

// SPI0.SPCMD7: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD7_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD7_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD7.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCMD7_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD7_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD7_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD7_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD7_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD7_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD7_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD7_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD7_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD7_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD7_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD7_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD7_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD7_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD7_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD7_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD7_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD7_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x8000) >> 15
}

// SPI0.SPDCR2: SPI Data Control Register 2
func (o *SPI0_Type) SetSPDCR2_BYSW(value uint8) {
	volatile.StoreUint8(&o.SPDCR2.Reg, volatile.LoadUint8(&o.SPDCR2.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPDCR2_BYSW() uint8 {
	return volatile.LoadUint8(&o.SPDCR2.Reg) & 0x1
}
func (o *SPI0_Type) SetSPDCR2_SINV(value uint8) {
	volatile.StoreUint8(&o.SPDCR2.Reg, volatile.LoadUint8(&o.SPDCR2.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPDCR2_SINV() uint8 {
	return (volatile.LoadUint8(&o.SPDCR2.Reg) & 0x2) >> 1
}

// SPI0.SPCR3: SPI Control Register 3
func (o *SPI0_Type) SetSPCR3_ETXMD(value uint8) {
	volatile.StoreUint8(&o.SPCR3.Reg, volatile.LoadUint8(&o.SPCR3.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCR3_ETXMD() uint8 {
	return volatile.LoadUint8(&o.SPCR3.Reg) & 0x1
}
func (o *SPI0_Type) SetSPCR3_BFDS(value uint8) {
	volatile.StoreUint8(&o.SPCR3.Reg, volatile.LoadUint8(&o.SPCR3.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCR3_BFDS() uint8 {
	return (volatile.LoadUint8(&o.SPCR3.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCR3_CENDIE(value uint8) {
	volatile.StoreUint8(&o.SPCR3.Reg, volatile.LoadUint8(&o.SPCR3.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPCR3_CENDIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR3.Reg) & 0x10) >> 4
}

// General PWM 32-bit Timer 1
type GPT321_Type struct {
	GTWP     volatile.Register32 // 0x0
	GTSTR    volatile.Register32 // 0x4
	GTSTP    volatile.Register32 // 0x8
	GTCLR    volatile.Register32 // 0xC
	GTSSR    volatile.Register32 // 0x10
	GTPSR    volatile.Register32 // 0x14
	GTCSR    volatile.Register32 // 0x18
	GTUPSR   volatile.Register32 // 0x1C
	GTDNSR   volatile.Register32 // 0x20
	GTICASR  volatile.Register32 // 0x24
	GTICBSR  volatile.Register32 // 0x28
	GTCR     volatile.Register32 // 0x2C
	GTUDDTYC volatile.Register32 // 0x30
	GTIOR    volatile.Register32 // 0x34
	GTINTAD  volatile.Register32 // 0x38
	GTST     volatile.Register32 // 0x3C
	GTBER    volatile.Register32 // 0x40
	_        [4]byte
	GTCNT    volatile.Register32 // 0x48
	GTCCRA   volatile.Register32 // 0x4C
	GTCCRB   volatile.Register32 // 0x50
	GTCCRC   volatile.Register32 // 0x54
	GTCCRE   volatile.Register32 // 0x58
	GTCCRD   volatile.Register32 // 0x5C
	GTCCRF   volatile.Register32 // 0x60
	GTPR     volatile.Register32 // 0x64
	GTPBR    volatile.Register32 // 0x68
	_        [28]byte
	GTDTCR   volatile.Register32 // 0x88
	GTDVU    volatile.Register32 // 0x8C
	_        [40]byte
	GTICLF   volatile.Register32 // 0xB8
	GTPC     volatile.Register32 // 0xBC
	_        [16]byte
	GTSECSR  volatile.Register32 // 0xD0
	GTSECR   volatile.Register32 // 0xD4
}

// GPT321.GTWP: General PWM Timer Write-Protection Register
func (o *GPT321_Type) SetGTWP_WP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTWP_WP() uint32 {
	return volatile.LoadUint32(&o.GTWP.Reg) & 0x1
}
func (o *GPT321_Type) SetGTWP_STRWP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTWP_STRWP() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTWP_STPWP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x4)|value<<2)
}
func (o *GPT321_Type) GetGTWP_STPWP() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0x4) >> 2
}
func (o *GPT321_Type) SetGTWP_CLRWP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x8)|value<<3)
}
func (o *GPT321_Type) GetGTWP_CLRWP() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0x8) >> 3
}
func (o *GPT321_Type) SetGTWP_CMNWP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x10)|value<<4)
}
func (o *GPT321_Type) GetGTWP_CMNWP() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0x10) >> 4
}
func (o *GPT321_Type) SetGTWP_PRKEY(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xff00)|value<<8)
}
func (o *GPT321_Type) GetGTWP_PRKEY() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xff00) >> 8
}

// GPT321.GTSTR: General PWM Timer Software Start Register
func (o *GPT321_Type) SetGTSTR_CSTRT0(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTSTR_CSTRT0() uint32 {
	return volatile.LoadUint32(&o.GTSTR.Reg) & 0x1
}
func (o *GPT321_Type) SetGTSTR_CSTRT1(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTSTR_CSTRT1() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTSTR_CSTRT2(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x4)|value<<2)
}
func (o *GPT321_Type) GetGTSTR_CSTRT2() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x4) >> 2
}
func (o *GPT321_Type) SetGTSTR_CSTRT3(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x8)|value<<3)
}
func (o *GPT321_Type) GetGTSTR_CSTRT3() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x8) >> 3
}
func (o *GPT321_Type) SetGTSTR_CSTRT4(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x10)|value<<4)
}
func (o *GPT321_Type) GetGTSTR_CSTRT4() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x10) >> 4
}
func (o *GPT321_Type) SetGTSTR_CSTRT5(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x20)|value<<5)
}
func (o *GPT321_Type) GetGTSTR_CSTRT5() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x20) >> 5
}
func (o *GPT321_Type) SetGTSTR_CSTRT6(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x40)|value<<6)
}
func (o *GPT321_Type) GetGTSTR_CSTRT6() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x40) >> 6
}
func (o *GPT321_Type) SetGTSTR_CSTRT7(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x80)|value<<7)
}
func (o *GPT321_Type) GetGTSTR_CSTRT7() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x80) >> 7
}
func (o *GPT321_Type) SetGTSTR_CSTRT8(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTSTR_CSTRT8() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTSTR_CSTRT9(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x200)|value<<9)
}
func (o *GPT321_Type) GetGTSTR_CSTRT9() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x200) >> 9
}

// GPT321.GTSTP: General PWM Timer Software Stop Register
func (o *GPT321_Type) SetGTSTP_CSTOP0(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTSTP_CSTOP0() uint32 {
	return volatile.LoadUint32(&o.GTSTP.Reg) & 0x1
}
func (o *GPT321_Type) SetGTSTP_CSTOP1(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTSTP_CSTOP1() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTSTP_CSTOP2(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x4)|value<<2)
}
func (o *GPT321_Type) GetGTSTP_CSTOP2() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x4) >> 2
}
func (o *GPT321_Type) SetGTSTP_CSTOP3(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x8)|value<<3)
}
func (o *GPT321_Type) GetGTSTP_CSTOP3() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x8) >> 3
}
func (o *GPT321_Type) SetGTSTP_CSTOP4(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x10)|value<<4)
}
func (o *GPT321_Type) GetGTSTP_CSTOP4() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x10) >> 4
}
func (o *GPT321_Type) SetGTSTP_CSTOP5(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x20)|value<<5)
}
func (o *GPT321_Type) GetGTSTP_CSTOP5() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x20) >> 5
}
func (o *GPT321_Type) SetGTSTP_CSTOP6(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x40)|value<<6)
}
func (o *GPT321_Type) GetGTSTP_CSTOP6() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x40) >> 6
}
func (o *GPT321_Type) SetGTSTP_CSTOP7(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x80)|value<<7)
}
func (o *GPT321_Type) GetGTSTP_CSTOP7() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x80) >> 7
}
func (o *GPT321_Type) SetGTSTP_CSTOP8(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTSTP_CSTOP8() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTSTP_CSTOP9(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x200)|value<<9)
}
func (o *GPT321_Type) GetGTSTP_CSTOP9() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x200) >> 9
}

// GPT321.GTCLR: General PWM Timer Software Clear Register
func (o *GPT321_Type) SetGTCLR_CCLR0(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTCLR_CCLR0() uint32 {
	return volatile.LoadUint32(&o.GTCLR.Reg) & 0x1
}
func (o *GPT321_Type) SetGTCLR_CCLR1(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTCLR_CCLR1() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTCLR_CCLR2(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPT321_Type) GetGTCLR_CCLR2() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x4) >> 2
}
func (o *GPT321_Type) SetGTCLR_CCLR3(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPT321_Type) GetGTCLR_CCLR3() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x8) >> 3
}
func (o *GPT321_Type) SetGTCLR_CCLR4(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPT321_Type) GetGTCLR_CCLR4() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x10) >> 4
}
func (o *GPT321_Type) SetGTCLR_CCLR5(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPT321_Type) GetGTCLR_CCLR5() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x20) >> 5
}
func (o *GPT321_Type) SetGTCLR_CCLR6(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPT321_Type) GetGTCLR_CCLR6() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x40) >> 6
}
func (o *GPT321_Type) SetGTCLR_CCLR7(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPT321_Type) GetGTCLR_CCLR7() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x80) >> 7
}
func (o *GPT321_Type) SetGTCLR_CCLR8(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTCLR_CCLR8() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTCLR_CCLR9(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPT321_Type) GetGTCLR_CCLR9() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x200) >> 9
}

// GPT321.GTSSR: General PWM Timer Start Source Select Register
func (o *GPT321_Type) SetGTSSR_SSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTSSR_SSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTSSR.Reg) & 0x1
}
func (o *GPT321_Type) SetGTSSR_SSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTSSR_SSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTSSR_SSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT321_Type) GetGTSSR_SSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4) >> 2
}
func (o *GPT321_Type) SetGTSSR_SSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT321_Type) GetGTSSR_SSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8) >> 3
}
func (o *GPT321_Type) SetGTSSR_SSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT321_Type) GetGTSSR_SSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10) >> 4
}
func (o *GPT321_Type) SetGTSSR_SSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT321_Type) GetGTSSR_SSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20) >> 5
}
func (o *GPT321_Type) SetGTSSR_SSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT321_Type) GetGTSSR_SSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40) >> 6
}
func (o *GPT321_Type) SetGTSSR_SSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT321_Type) GetGTSSR_SSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80) >> 7
}
func (o *GPT321_Type) SetGTSSR_SSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTSSR_SSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTSSR_SSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT321_Type) GetGTSSR_SSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200) >> 9
}
func (o *GPT321_Type) SetGTSSR_SSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT321_Type) GetGTSSR_SSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400) >> 10
}
func (o *GPT321_Type) SetGTSSR_SSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT321_Type) GetGTSSR_SSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800) >> 11
}
func (o *GPT321_Type) SetGTSSR_SSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT321_Type) GetGTSSR_SSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x1000) >> 12
}
func (o *GPT321_Type) SetGTSSR_SSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT321_Type) GetGTSSR_SSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2000) >> 13
}
func (o *GPT321_Type) SetGTSSR_SSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT321_Type) GetGTSSR_SSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4000) >> 14
}
func (o *GPT321_Type) SetGTSSR_SSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT321_Type) GetGTSSR_SSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8000) >> 15
}
func (o *GPT321_Type) SetGTSSR_SSELCA(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT321_Type) GetGTSSR_SSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10000) >> 16
}
func (o *GPT321_Type) SetGTSSR_SSELCB(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT321_Type) GetGTSSR_SSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20000) >> 17
}
func (o *GPT321_Type) SetGTSSR_SSELCC(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT321_Type) GetGTSSR_SSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40000) >> 18
}
func (o *GPT321_Type) SetGTSSR_SSELCD(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT321_Type) GetGTSSR_SSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000) >> 19
}
func (o *GPT321_Type) SetGTSSR_SSELCE(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT321_Type) GetGTSSR_SSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100000) >> 20
}
func (o *GPT321_Type) SetGTSSR_SSELCF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT321_Type) GetGTSSR_SSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200000) >> 21
}
func (o *GPT321_Type) SetGTSSR_SSELCG(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT321_Type) GetGTSSR_SSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400000) >> 22
}
func (o *GPT321_Type) SetGTSSR_SSELCH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT321_Type) GetGTSSR_SSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800000) >> 23
}
func (o *GPT321_Type) SetGTSSR_CSTRT(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT321_Type) GetGTSSR_CSTRT() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000000) >> 31
}

// GPT321.GTPSR: General PWM Timer Stop Source Select Register
func (o *GPT321_Type) SetGTPSR_PSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTPSR_PSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTPSR.Reg) & 0x1
}
func (o *GPT321_Type) SetGTPSR_PSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTPSR_PSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTPSR_PSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT321_Type) GetGTPSR_PSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4) >> 2
}
func (o *GPT321_Type) SetGTPSR_PSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT321_Type) GetGTPSR_PSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8) >> 3
}
func (o *GPT321_Type) SetGTPSR_PSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT321_Type) GetGTPSR_PSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10) >> 4
}
func (o *GPT321_Type) SetGTPSR_PSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT321_Type) GetGTPSR_PSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20) >> 5
}
func (o *GPT321_Type) SetGTPSR_PSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT321_Type) GetGTPSR_PSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40) >> 6
}
func (o *GPT321_Type) SetGTPSR_PSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT321_Type) GetGTPSR_PSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80) >> 7
}
func (o *GPT321_Type) SetGTPSR_PSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTPSR_PSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTPSR_PSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT321_Type) GetGTPSR_PSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200) >> 9
}
func (o *GPT321_Type) SetGTPSR_PSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT321_Type) GetGTPSR_PSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400) >> 10
}
func (o *GPT321_Type) SetGTPSR_PSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT321_Type) GetGTPSR_PSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800) >> 11
}
func (o *GPT321_Type) SetGTPSR_PSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT321_Type) GetGTPSR_PSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x1000) >> 12
}
func (o *GPT321_Type) SetGTPSR_PSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT321_Type) GetGTPSR_PSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2000) >> 13
}
func (o *GPT321_Type) SetGTPSR_PSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT321_Type) GetGTPSR_PSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4000) >> 14
}
func (o *GPT321_Type) SetGTPSR_PSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT321_Type) GetGTPSR_PSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8000) >> 15
}
func (o *GPT321_Type) SetGTPSR_PSELCA(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT321_Type) GetGTPSR_PSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10000) >> 16
}
func (o *GPT321_Type) SetGTPSR_PSELCB(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT321_Type) GetGTPSR_PSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20000) >> 17
}
func (o *GPT321_Type) SetGTPSR_PSELCC(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT321_Type) GetGTPSR_PSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40000) >> 18
}
func (o *GPT321_Type) SetGTPSR_PSELCD(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT321_Type) GetGTPSR_PSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000) >> 19
}
func (o *GPT321_Type) SetGTPSR_PSELCE(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT321_Type) GetGTPSR_PSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100000) >> 20
}
func (o *GPT321_Type) SetGTPSR_PSELCF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT321_Type) GetGTPSR_PSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200000) >> 21
}
func (o *GPT321_Type) SetGTPSR_PSELCG(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT321_Type) GetGTPSR_PSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400000) >> 22
}
func (o *GPT321_Type) SetGTPSR_PSELCH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT321_Type) GetGTPSR_PSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800000) >> 23
}
func (o *GPT321_Type) SetGTPSR_CSTOP(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT321_Type) GetGTPSR_CSTOP() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000000) >> 31
}

// GPT321.GTCSR: General PWM Timer Clear Source Select Register
func (o *GPT321_Type) SetGTCSR_CSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTCSR_CSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTCSR.Reg) & 0x1
}
func (o *GPT321_Type) SetGTCSR_CSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTCSR_CSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTCSR_CSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT321_Type) GetGTCSR_CSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4) >> 2
}
func (o *GPT321_Type) SetGTCSR_CSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT321_Type) GetGTCSR_CSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8) >> 3
}
func (o *GPT321_Type) SetGTCSR_CSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT321_Type) GetGTCSR_CSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10) >> 4
}
func (o *GPT321_Type) SetGTCSR_CSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT321_Type) GetGTCSR_CSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20) >> 5
}
func (o *GPT321_Type) SetGTCSR_CSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT321_Type) GetGTCSR_CSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40) >> 6
}
func (o *GPT321_Type) SetGTCSR_CSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT321_Type) GetGTCSR_CSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80) >> 7
}
func (o *GPT321_Type) SetGTCSR_CSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTCSR_CSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTCSR_CSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT321_Type) GetGTCSR_CSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200) >> 9
}
func (o *GPT321_Type) SetGTCSR_CSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT321_Type) GetGTCSR_CSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400) >> 10
}
func (o *GPT321_Type) SetGTCSR_CSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT321_Type) GetGTCSR_CSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800) >> 11
}
func (o *GPT321_Type) SetGTCSR_CSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT321_Type) GetGTCSR_CSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x1000) >> 12
}
func (o *GPT321_Type) SetGTCSR_CSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT321_Type) GetGTCSR_CSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2000) >> 13
}
func (o *GPT321_Type) SetGTCSR_CSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT321_Type) GetGTCSR_CSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4000) >> 14
}
func (o *GPT321_Type) SetGTCSR_CSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT321_Type) GetGTCSR_CSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8000) >> 15
}
func (o *GPT321_Type) SetGTCSR_CSELCA(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT321_Type) GetGTCSR_CSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10000) >> 16
}
func (o *GPT321_Type) SetGTCSR_CSELCB(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT321_Type) GetGTCSR_CSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20000) >> 17
}
func (o *GPT321_Type) SetGTCSR_CSELCC(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT321_Type) GetGTCSR_CSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40000) >> 18
}
func (o *GPT321_Type) SetGTCSR_CSELCD(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT321_Type) GetGTCSR_CSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000) >> 19
}
func (o *GPT321_Type) SetGTCSR_CSELCE(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT321_Type) GetGTCSR_CSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100000) >> 20
}
func (o *GPT321_Type) SetGTCSR_CSELCF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT321_Type) GetGTCSR_CSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200000) >> 21
}
func (o *GPT321_Type) SetGTCSR_CSELCG(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT321_Type) GetGTCSR_CSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400000) >> 22
}
func (o *GPT321_Type) SetGTCSR_CSELCH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT321_Type) GetGTCSR_CSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800000) >> 23
}
func (o *GPT321_Type) SetGTCSR_CCLR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT321_Type) GetGTCSR_CCLR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000000) >> 31
}

// GPT321.GTUPSR: General PWM Timer Up Count Source Select Register
func (o *GPT321_Type) SetGTUPSR_USGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTUPSR_USGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1
}
func (o *GPT321_Type) SetGTUPSR_USGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTUPSR_USGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTUPSR_USGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT321_Type) GetGTUPSR_USGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4) >> 2
}
func (o *GPT321_Type) SetGTUPSR_USGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT321_Type) GetGTUPSR_USGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8) >> 3
}
func (o *GPT321_Type) SetGTUPSR_USGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT321_Type) GetGTUPSR_USGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10) >> 4
}
func (o *GPT321_Type) SetGTUPSR_USGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT321_Type) GetGTUPSR_USGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20) >> 5
}
func (o *GPT321_Type) SetGTUPSR_USGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT321_Type) GetGTUPSR_USGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40) >> 6
}
func (o *GPT321_Type) SetGTUPSR_USGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT321_Type) GetGTUPSR_USGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80) >> 7
}
func (o *GPT321_Type) SetGTUPSR_USCARBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTUPSR_USCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTUPSR_USCARBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT321_Type) GetGTUPSR_USCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200) >> 9
}
func (o *GPT321_Type) SetGTUPSR_USCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT321_Type) GetGTUPSR_USCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400) >> 10
}
func (o *GPT321_Type) SetGTUPSR_USCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT321_Type) GetGTUPSR_USCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800) >> 11
}
func (o *GPT321_Type) SetGTUPSR_USCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT321_Type) GetGTUPSR_USCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1000) >> 12
}
func (o *GPT321_Type) SetGTUPSR_USCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT321_Type) GetGTUPSR_USCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2000) >> 13
}
func (o *GPT321_Type) SetGTUPSR_USCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT321_Type) GetGTUPSR_USCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4000) >> 14
}
func (o *GPT321_Type) SetGTUPSR_USCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT321_Type) GetGTUPSR_USCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8000) >> 15
}
func (o *GPT321_Type) SetGTUPSR_USELCA(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT321_Type) GetGTUPSR_USELCA() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10000) >> 16
}
func (o *GPT321_Type) SetGTUPSR_USELCB(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT321_Type) GetGTUPSR_USELCB() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20000) >> 17
}
func (o *GPT321_Type) SetGTUPSR_USELCC(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT321_Type) GetGTUPSR_USELCC() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40000) >> 18
}
func (o *GPT321_Type) SetGTUPSR_USELCD(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT321_Type) GetGTUPSR_USELCD() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80000) >> 19
}
func (o *GPT321_Type) SetGTUPSR_USELCE(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT321_Type) GetGTUPSR_USELCE() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100000) >> 20
}
func (o *GPT321_Type) SetGTUPSR_USELCF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT321_Type) GetGTUPSR_USELCF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200000) >> 21
}
func (o *GPT321_Type) SetGTUPSR_USELCG(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT321_Type) GetGTUPSR_USELCG() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400000) >> 22
}
func (o *GPT321_Type) SetGTUPSR_USELCH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT321_Type) GetGTUPSR_USELCH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800000) >> 23
}

// GPT321.GTDNSR: General PWM Timer Down Count Source Select Register
func (o *GPT321_Type) SetGTDNSR_DSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTDNSR_DSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1
}
func (o *GPT321_Type) SetGTDNSR_DSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTDNSR_DSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTDNSR_DSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT321_Type) GetGTDNSR_DSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4) >> 2
}
func (o *GPT321_Type) SetGTDNSR_DSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT321_Type) GetGTDNSR_DSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8) >> 3
}
func (o *GPT321_Type) SetGTDNSR_DSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT321_Type) GetGTDNSR_DSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10) >> 4
}
func (o *GPT321_Type) SetGTDNSR_DSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT321_Type) GetGTDNSR_DSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20) >> 5
}
func (o *GPT321_Type) SetGTDNSR_DSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT321_Type) GetGTDNSR_DSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40) >> 6
}
func (o *GPT321_Type) SetGTDNSR_DSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT321_Type) GetGTDNSR_DSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80) >> 7
}
func (o *GPT321_Type) SetGTDNSR_DSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTDNSR_DSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTDNSR_DSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT321_Type) GetGTDNSR_DSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200) >> 9
}
func (o *GPT321_Type) SetGTDNSR_DSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT321_Type) GetGTDNSR_DSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400) >> 10
}
func (o *GPT321_Type) SetGTDNSR_DSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT321_Type) GetGTDNSR_DSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800) >> 11
}
func (o *GPT321_Type) SetGTDNSR_DSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT321_Type) GetGTDNSR_DSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1000) >> 12
}
func (o *GPT321_Type) SetGTDNSR_DSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT321_Type) GetGTDNSR_DSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2000) >> 13
}
func (o *GPT321_Type) SetGTDNSR_DSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT321_Type) GetGTDNSR_DSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4000) >> 14
}
func (o *GPT321_Type) SetGTDNSR_DSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT321_Type) GetGTDNSR_DSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8000) >> 15
}
func (o *GPT321_Type) SetGTDNSR_DSELCA(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT321_Type) GetGTDNSR_DSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10000) >> 16
}
func (o *GPT321_Type) SetGTDNSR_DSELCB(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT321_Type) GetGTDNSR_DSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20000) >> 17
}
func (o *GPT321_Type) SetGTDNSR_DSELCC(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT321_Type) GetGTDNSR_DSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40000) >> 18
}
func (o *GPT321_Type) SetGTDNSR_DSELCD(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT321_Type) GetGTDNSR_DSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80000) >> 19
}
func (o *GPT321_Type) SetGTDNSR_DSELCE(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT321_Type) GetGTDNSR_DSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100000) >> 20
}
func (o *GPT321_Type) SetGTDNSR_DSELCF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT321_Type) GetGTDNSR_DSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200000) >> 21
}
func (o *GPT321_Type) SetGTDNSR_DSELCG(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT321_Type) GetGTDNSR_DSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400000) >> 22
}
func (o *GPT321_Type) SetGTDNSR_DSELCH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT321_Type) GetGTDNSR_DSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800000) >> 23
}

// GPT321.GTICASR: General PWM Timer Input Capture Source Select Register A
func (o *GPT321_Type) SetGTICASR_ASGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTICASR_ASGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICASR.Reg) & 0x1
}
func (o *GPT321_Type) SetGTICASR_ASGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTICASR_ASGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTICASR_ASGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4)|value<<2)
}
func (o *GPT321_Type) GetGTICASR_ASGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4) >> 2
}
func (o *GPT321_Type) SetGTICASR_ASGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8)|value<<3)
}
func (o *GPT321_Type) GetGTICASR_ASGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8) >> 3
}
func (o *GPT321_Type) SetGTICASR_ASGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10)|value<<4)
}
func (o *GPT321_Type) GetGTICASR_ASGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10) >> 4
}
func (o *GPT321_Type) SetGTICASR_ASGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20)|value<<5)
}
func (o *GPT321_Type) GetGTICASR_ASGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20) >> 5
}
func (o *GPT321_Type) SetGTICASR_ASGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40)|value<<6)
}
func (o *GPT321_Type) GetGTICASR_ASGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40) >> 6
}
func (o *GPT321_Type) SetGTICASR_ASGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80)|value<<7)
}
func (o *GPT321_Type) GetGTICASR_ASGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80) >> 7
}
func (o *GPT321_Type) SetGTICASR_ASCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTICASR_ASCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTICASR_ASCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200)|value<<9)
}
func (o *GPT321_Type) GetGTICASR_ASCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200) >> 9
}
func (o *GPT321_Type) SetGTICASR_ASCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400)|value<<10)
}
func (o *GPT321_Type) GetGTICASR_ASCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400) >> 10
}
func (o *GPT321_Type) SetGTICASR_ASCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800)|value<<11)
}
func (o *GPT321_Type) GetGTICASR_ASCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800) >> 11
}
func (o *GPT321_Type) SetGTICASR_ASCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT321_Type) GetGTICASR_ASCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x1000) >> 12
}
func (o *GPT321_Type) SetGTICASR_ASCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT321_Type) GetGTICASR_ASCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2000) >> 13
}
func (o *GPT321_Type) SetGTICASR_ASCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT321_Type) GetGTICASR_ASCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4000) >> 14
}
func (o *GPT321_Type) SetGTICASR_ASCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT321_Type) GetGTICASR_ASCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8000) >> 15
}
func (o *GPT321_Type) SetGTICASR_ASELCA(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT321_Type) GetGTICASR_ASELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10000) >> 16
}
func (o *GPT321_Type) SetGTICASR_ASELCB(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT321_Type) GetGTICASR_ASELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20000) >> 17
}
func (o *GPT321_Type) SetGTICASR_ASELCC(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT321_Type) GetGTICASR_ASELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40000) >> 18
}
func (o *GPT321_Type) SetGTICASR_ASELCD(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT321_Type) GetGTICASR_ASELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80000) >> 19
}
func (o *GPT321_Type) SetGTICASR_ASELCE(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT321_Type) GetGTICASR_ASELCE() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100000) >> 20
}
func (o *GPT321_Type) SetGTICASR_ASELCF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT321_Type) GetGTICASR_ASELCF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200000) >> 21
}
func (o *GPT321_Type) SetGTICASR_ASELCG(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT321_Type) GetGTICASR_ASELCG() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400000) >> 22
}
func (o *GPT321_Type) SetGTICASR_ASELCH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT321_Type) GetGTICASR_ASELCH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800000) >> 23
}

// GPT321.GTICBSR: General PWM Timer Input Capture Source Select Register B
func (o *GPT321_Type) SetGTICBSR_BSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTICBSR_BSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1
}
func (o *GPT321_Type) SetGTICBSR_BSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTICBSR_BSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTICBSR_BSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT321_Type) GetGTICBSR_BSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4) >> 2
}
func (o *GPT321_Type) SetGTICBSR_BSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT321_Type) GetGTICBSR_BSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8) >> 3
}
func (o *GPT321_Type) SetGTICBSR_BSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT321_Type) GetGTICBSR_BSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10) >> 4
}
func (o *GPT321_Type) SetGTICBSR_BSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT321_Type) GetGTICBSR_BSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20) >> 5
}
func (o *GPT321_Type) SetGTICBSR_BSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT321_Type) GetGTICBSR_BSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40) >> 6
}
func (o *GPT321_Type) SetGTICBSR_BSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT321_Type) GetGTICBSR_BSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80) >> 7
}
func (o *GPT321_Type) SetGTICBSR_BSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTICBSR_BSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTICBSR_BSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT321_Type) GetGTICBSR_BSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200) >> 9
}
func (o *GPT321_Type) SetGTICBSR_BSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT321_Type) GetGTICBSR_BSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400) >> 10
}
func (o *GPT321_Type) SetGTICBSR_BSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT321_Type) GetGTICBSR_BSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800) >> 11
}
func (o *GPT321_Type) SetGTICBSR_BSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT321_Type) GetGTICBSR_BSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1000) >> 12
}
func (o *GPT321_Type) SetGTICBSR_BSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT321_Type) GetGTICBSR_BSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2000) >> 13
}
func (o *GPT321_Type) SetGTICBSR_BSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT321_Type) GetGTICBSR_BSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4000) >> 14
}
func (o *GPT321_Type) SetGTICBSR_BSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT321_Type) GetGTICBSR_BSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8000) >> 15
}
func (o *GPT321_Type) SetGTICBSR_BSELCA(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT321_Type) GetGTICBSR_BSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10000) >> 16
}
func (o *GPT321_Type) SetGTICBSR_BSELCB(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT321_Type) GetGTICBSR_BSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20000) >> 17
}
func (o *GPT321_Type) SetGTICBSR_BSELCC(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT321_Type) GetGTICBSR_BSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40000) >> 18
}
func (o *GPT321_Type) SetGTICBSR_BSELCD(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT321_Type) GetGTICBSR_BSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80000) >> 19
}
func (o *GPT321_Type) SetGTICBSR_BSELCE(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT321_Type) GetGTICBSR_BSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100000) >> 20
}
func (o *GPT321_Type) SetGTICBSR_BSELCF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT321_Type) GetGTICBSR_BSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200000) >> 21
}
func (o *GPT321_Type) SetGTICBSR_BSELCG(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT321_Type) GetGTICBSR_BSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400000) >> 22
}
func (o *GPT321_Type) SetGTICBSR_BSELCH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT321_Type) GetGTICBSR_BSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800000) >> 23
}

// GPT321.GTCR: General PWM Timer Control Register
func (o *GPT321_Type) SetGTCR_CST(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTCR_CST() uint32 {
	return volatile.LoadUint32(&o.GTCR.Reg) & 0x1
}
func (o *GPT321_Type) SetGTCR_MD(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x70000)|value<<16)
}
func (o *GPT321_Type) GetGTCR_MD() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x70000) >> 16
}
func (o *GPT321_Type) SetGTCR_TPCS(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x7800000)|value<<23)
}
func (o *GPT321_Type) GetGTCR_TPCS() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x7800000) >> 23
}

// GPT321.GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
func (o *GPT321_Type) SetGTUDDTYC_UD(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTUDDTYC_UD() uint32 {
	return volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x1
}
func (o *GPT321_Type) SetGTUDDTYC_UDF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTUDDTYC_UDF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTUDDTYC_OADTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x30000)|value<<16)
}
func (o *GPT321_Type) GetGTUDDTYC_OADTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x30000) >> 16
}
func (o *GPT321_Type) SetGTUDDTYC_OADTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x40000)|value<<18)
}
func (o *GPT321_Type) GetGTUDDTYC_OADTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x40000) >> 18
}
func (o *GPT321_Type) SetGTUDDTYC_OADTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x80000)|value<<19)
}
func (o *GPT321_Type) GetGTUDDTYC_OADTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x80000) >> 19
}
func (o *GPT321_Type) SetGTUDDTYC_OBDTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT321_Type) GetGTUDDTYC_OBDTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x3000000) >> 24
}
func (o *GPT321_Type) SetGTUDDTYC_OBDTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT321_Type) GetGTUDDTYC_OBDTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x4000000) >> 26
}
func (o *GPT321_Type) SetGTUDDTYC_OBDTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x8000000)|value<<27)
}
func (o *GPT321_Type) GetGTUDDTYC_OBDTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x8000000) >> 27
}

// GPT321.GTIOR: General PWM Timer I/O Control Register
func (o *GPT321_Type) SetGTIOR_GTIOA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f)|value)
}
func (o *GPT321_Type) GetGTIOR_GTIOA() uint32 {
	return volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f
}
func (o *GPT321_Type) SetGTIOR_OADFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x40)|value<<6)
}
func (o *GPT321_Type) GetGTIOR_OADFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x40) >> 6
}
func (o *GPT321_Type) SetGTIOR_OAHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x80)|value<<7)
}
func (o *GPT321_Type) GetGTIOR_OAHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x80) >> 7
}
func (o *GPT321_Type) SetGTIOR_OAE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTIOR_OAE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTIOR_OADF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x600)|value<<9)
}
func (o *GPT321_Type) GetGTIOR_OADF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x600) >> 9
}
func (o *GPT321_Type) SetGTIOR_NFAEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT321_Type) GetGTIOR_NFAEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x2000) >> 13
}
func (o *GPT321_Type) SetGTIOR_NFCSA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc000)|value<<14)
}
func (o *GPT321_Type) GetGTIOR_NFCSA() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc000) >> 14
}
func (o *GPT321_Type) SetGTIOR_GTIOB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f0000)|value<<16)
}
func (o *GPT321_Type) GetGTIOR_GTIOB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f0000) >> 16
}
func (o *GPT321_Type) SetGTIOR_OBDFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT321_Type) GetGTIOR_OBDFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x400000) >> 22
}
func (o *GPT321_Type) SetGTIOR_OBHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT321_Type) GetGTIOR_OBHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x800000) >> 23
}
func (o *GPT321_Type) SetGTIOR_OBE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT321_Type) GetGTIOR_OBE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1000000) >> 24
}
func (o *GPT321_Type) SetGTIOR_OBDF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x6000000)|value<<25)
}
func (o *GPT321_Type) GetGTIOR_OBDF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x6000000) >> 25
}
func (o *GPT321_Type) SetGTIOR_NFBEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT321_Type) GetGTIOR_NFBEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20000000) >> 29
}
func (o *GPT321_Type) SetGTIOR_NFCSB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT321_Type) GetGTIOR_NFCSB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc0000000) >> 30
}

// GPT321.GTINTAD: General PWM Timer Interrupt Output Setting Register
func (o *GPT321_Type) SetGTINTAD_GRP(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT321_Type) GetGTINTAD_GRP() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x3000000) >> 24
}
func (o *GPT321_Type) SetGTINTAD_GRPABH(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT321_Type) GetGTINTAD_GRPABH() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x20000000) >> 29
}
func (o *GPT321_Type) SetGTINTAD_GRPABL(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT321_Type) GetGTINTAD_GRPABL() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x40000000) >> 30
}

// GPT321.GTST: General PWM Timer Status Register
func (o *GPT321_Type) SetGTST_TCFA(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTST_TCFA() uint32 {
	return volatile.LoadUint32(&o.GTST.Reg) & 0x1
}
func (o *GPT321_Type) SetGTST_TCFB(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTST_TCFB() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTST_TCFC(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x4)|value<<2)
}
func (o *GPT321_Type) GetGTST_TCFC() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x4) >> 2
}
func (o *GPT321_Type) SetGTST_TCFD(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8)|value<<3)
}
func (o *GPT321_Type) GetGTST_TCFD() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8) >> 3
}
func (o *GPT321_Type) SetGTST_TCFE(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x10)|value<<4)
}
func (o *GPT321_Type) GetGTST_TCFE() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x10) >> 4
}
func (o *GPT321_Type) SetGTST_TCFF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20)|value<<5)
}
func (o *GPT321_Type) GetGTST_TCFF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20) >> 5
}
func (o *GPT321_Type) SetGTST_TCFPO(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40)|value<<6)
}
func (o *GPT321_Type) GetGTST_TCFPO() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40) >> 6
}
func (o *GPT321_Type) SetGTST_TCFPU(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x80)|value<<7)
}
func (o *GPT321_Type) GetGTST_TCFPU() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x80) >> 7
}
func (o *GPT321_Type) SetGTST_TUCF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8000)|value<<15)
}
func (o *GPT321_Type) GetGTST_TUCF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8000) >> 15
}
func (o *GPT321_Type) SetGTST_ODF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT321_Type) GetGTST_ODF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1000000) >> 24
}
func (o *GPT321_Type) SetGTST_OABHF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT321_Type) GetGTST_OABHF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20000000) >> 29
}
func (o *GPT321_Type) SetGTST_OABLF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT321_Type) GetGTST_OABLF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40000000) >> 30
}
func (o *GPT321_Type) SetGTST_PCF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT321_Type) GetGTST_PCF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x80000000) >> 31
}

// GPT321.GTBER: General PWM Timer Buffer Enable Register
func (o *GPT321_Type) SetGTBER_BD0(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTBER_BD0() uint32 {
	return volatile.LoadUint32(&o.GTBER.Reg) & 0x1
}
func (o *GPT321_Type) SetGTBER_BD1(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTBER_BD1() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTBER_CCRA(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x30000)|value<<16)
}
func (o *GPT321_Type) GetGTBER_CCRA() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x30000) >> 16
}
func (o *GPT321_Type) SetGTBER_CCRB(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPT321_Type) GetGTBER_CCRB() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0xc0000) >> 18
}
func (o *GPT321_Type) SetGTBER_PR(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x300000)|value<<20)
}
func (o *GPT321_Type) GetGTBER_PR() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x300000) >> 20
}
func (o *GPT321_Type) SetGTBER_CCRSWT(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x400000)|value<<22)
}
func (o *GPT321_Type) GetGTBER_CCRSWT() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x400000) >> 22
}

// GPT321.GTDTCR: General PWM Timer Dead Time Control Register
func (o *GPT321_Type) SetGTDTCR_TDE(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTDTCR_TDE() uint32 {
	return volatile.LoadUint32(&o.GTDTCR.Reg) & 0x1
}

// GPT321.GTICLF: General PWM Timer Inter Channel Logical Operation Function Setting Register
func (o *GPT321_Type) SetGTICLF_ICLFA(value uint32) {
	volatile.StoreUint32(&o.GTICLF.Reg, volatile.LoadUint32(&o.GTICLF.Reg)&^(0x7)|value)
}
func (o *GPT321_Type) GetGTICLF_ICLFA() uint32 {
	return volatile.LoadUint32(&o.GTICLF.Reg) & 0x7
}
func (o *GPT321_Type) SetGTICLF_ICLFSELC(value uint32) {
	volatile.StoreUint32(&o.GTICLF.Reg, volatile.LoadUint32(&o.GTICLF.Reg)&^(0x3f0)|value<<4)
}
func (o *GPT321_Type) GetGTICLF_ICLFSELC() uint32 {
	return (volatile.LoadUint32(&o.GTICLF.Reg) & 0x3f0) >> 4
}
func (o *GPT321_Type) SetGTICLF_ICLFB(value uint32) {
	volatile.StoreUint32(&o.GTICLF.Reg, volatile.LoadUint32(&o.GTICLF.Reg)&^(0x70000)|value<<16)
}
func (o *GPT321_Type) GetGTICLF_ICLFB() uint32 {
	return (volatile.LoadUint32(&o.GTICLF.Reg) & 0x70000) >> 16
}
func (o *GPT321_Type) SetGTICLF_ICLFSELD(value uint32) {
	volatile.StoreUint32(&o.GTICLF.Reg, volatile.LoadUint32(&o.GTICLF.Reg)&^(0x3f00000)|value<<20)
}
func (o *GPT321_Type) GetGTICLF_ICLFSELD() uint32 {
	return (volatile.LoadUint32(&o.GTICLF.Reg) & 0x3f00000) >> 20
}

// GPT321.GTPC: General PWM Timer Period Count Register
func (o *GPT321_Type) SetGTPC_PCEN(value uint32) {
	volatile.StoreUint32(&o.GTPC.Reg, volatile.LoadUint32(&o.GTPC.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTPC_PCEN() uint32 {
	return volatile.LoadUint32(&o.GTPC.Reg) & 0x1
}
func (o *GPT321_Type) SetGTPC_ASTP(value uint32) {
	volatile.StoreUint32(&o.GTPC.Reg, volatile.LoadUint32(&o.GTPC.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTPC_ASTP() uint32 {
	return (volatile.LoadUint32(&o.GTPC.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTPC_PCNT(value uint32) {
	volatile.StoreUint32(&o.GTPC.Reg, volatile.LoadUint32(&o.GTPC.Reg)&^(0xfff0000)|value<<16)
}
func (o *GPT321_Type) GetGTPC_PCNT() uint32 {
	return (volatile.LoadUint32(&o.GTPC.Reg) & 0xfff0000) >> 16
}

// GPT321.GTSECSR: General PWM Timer Operation Enable Bit Simultaneous Control Channel Select Register
func (o *GPT321_Type) SetGTSECSR_SECSEL0(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTSECSR_SECSEL0() uint32 {
	return volatile.LoadUint32(&o.GTSECSR.Reg) & 0x1
}
func (o *GPT321_Type) SetGTSECSR_SECSEL1(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTSECSR_SECSEL1() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTSECSR_SECSEL2(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT321_Type) GetGTSECSR_SECSEL2() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x4) >> 2
}
func (o *GPT321_Type) SetGTSECSR_SECSEL3(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT321_Type) GetGTSECSR_SECSEL3() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x8) >> 3
}
func (o *GPT321_Type) SetGTSECSR_SECSEL4(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT321_Type) GetGTSECSR_SECSEL4() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x10) >> 4
}
func (o *GPT321_Type) SetGTSECSR_SECSEL5(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT321_Type) GetGTSECSR_SECSEL5() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x20) >> 5
}
func (o *GPT321_Type) SetGTSECSR_SECSEL6(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT321_Type) GetGTSECSR_SECSEL6() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x40) >> 6
}
func (o *GPT321_Type) SetGTSECSR_SECSEL7(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT321_Type) GetGTSECSR_SECSEL7() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x80) >> 7
}
func (o *GPT321_Type) SetGTSECSR_SECSEL8(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTSECSR_SECSEL8() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTSECSR_SECSEL9(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT321_Type) GetGTSECSR_SECSEL9() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x200) >> 9
}

// GPT321.GTSECR: General PWM Timer Operation Enable Bit Simultaneous Control Register
func (o *GPT321_Type) SetGTSECR_SBDCE(value uint32) {
	volatile.StoreUint32(&o.GTSECR.Reg, volatile.LoadUint32(&o.GTSECR.Reg)&^(0x1)|value)
}
func (o *GPT321_Type) GetGTSECR_SBDCE() uint32 {
	return volatile.LoadUint32(&o.GTSECR.Reg) & 0x1
}
func (o *GPT321_Type) SetGTSECR_SBDPE(value uint32) {
	volatile.StoreUint32(&o.GTSECR.Reg, volatile.LoadUint32(&o.GTSECR.Reg)&^(0x2)|value<<1)
}
func (o *GPT321_Type) GetGTSECR_SBDPE() uint32 {
	return (volatile.LoadUint32(&o.GTSECR.Reg) & 0x2) >> 1
}
func (o *GPT321_Type) SetGTSECR_SBDCD(value uint32) {
	volatile.StoreUint32(&o.GTSECR.Reg, volatile.LoadUint32(&o.GTSECR.Reg)&^(0x100)|value<<8)
}
func (o *GPT321_Type) GetGTSECR_SBDCD() uint32 {
	return (volatile.LoadUint32(&o.GTSECR.Reg) & 0x100) >> 8
}
func (o *GPT321_Type) SetGTSECR_SBDPD(value uint32) {
	volatile.StoreUint32(&o.GTSECR.Reg, volatile.LoadUint32(&o.GTSECR.Reg)&^(0x200)|value<<9)
}
func (o *GPT321_Type) GetGTSECR_SBDPD() uint32 {
	return (volatile.LoadUint32(&o.GTSECR.Reg) & 0x200) >> 9
}
func (o *GPT321_Type) SetGTSECR_SPCE(value uint32) {
	volatile.StoreUint32(&o.GTSECR.Reg, volatile.LoadUint32(&o.GTSECR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT321_Type) GetGTSECR_SPCE() uint32 {
	return (volatile.LoadUint32(&o.GTSECR.Reg) & 0x10000) >> 16
}
func (o *GPT321_Type) SetGTSECR_SPCD(value uint32) {
	volatile.StoreUint32(&o.GTSECR.Reg, volatile.LoadUint32(&o.GTSECR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT321_Type) GetGTSECR_SPCD() uint32 {
	return (volatile.LoadUint32(&o.GTSECR.Reg) & 0x1000000) >> 24
}

// General PWM 16-bit Timer 4
type GPT164_Type struct {
	GTWP     volatile.Register32 // 0x0
	GTSTR    volatile.Register32 // 0x4
	GTSTP    volatile.Register32 // 0x8
	GTCLR    volatile.Register32 // 0xC
	GTSSR    volatile.Register32 // 0x10
	GTPSR    volatile.Register32 // 0x14
	GTCSR    volatile.Register32 // 0x18
	GTUPSR   volatile.Register32 // 0x1C
	GTDNSR   volatile.Register32 // 0x20
	GTICASR  volatile.Register32 // 0x24
	GTICBSR  volatile.Register32 // 0x28
	GTCR     volatile.Register32 // 0x2C
	GTUDDTYC volatile.Register32 // 0x30
	GTIOR    volatile.Register32 // 0x34
	GTINTAD  volatile.Register32 // 0x38
	GTST     volatile.Register32 // 0x3C
	GTBER    volatile.Register32 // 0x40
	_        [4]byte
	GTCNT    volatile.Register32 // 0x48
	GTCCRA   volatile.Register32 // 0x4C
	GTCCRB   volatile.Register32 // 0x50
	GTCCRC   volatile.Register32 // 0x54
	GTCCRE   volatile.Register32 // 0x58
	GTCCRD   volatile.Register32 // 0x5C
	GTCCRF   volatile.Register32 // 0x60
	GTPR     volatile.Register32 // 0x64
	GTPBR    volatile.Register32 // 0x68
	_        [28]byte
	GTDTCR   volatile.Register32 // 0x88
	GTDVU    volatile.Register32 // 0x8C
	_        [40]byte
	GTICLF   volatile.Register32 // 0xB8
	GTPC     volatile.Register32 // 0xBC
	_        [16]byte
	GTSECSR  volatile.Register32 // 0xD0
	GTSECR   volatile.Register32 // 0xD4
}

// GPT164.GTWP: General PWM Timer Write-Protection Register
func (o *GPT164_Type) SetGTWP_WP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTWP_WP() uint32 {
	return volatile.LoadUint32(&o.GTWP.Reg) & 0x1
}
func (o *GPT164_Type) SetGTWP_STRWP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTWP_STRWP() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTWP_STPWP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTWP_STPWP() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTWP_CLRWP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTWP_CLRWP() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTWP_CMNWP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTWP_CMNWP() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTWP_PRKEY(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xff00)|value<<8)
}
func (o *GPT164_Type) GetGTWP_PRKEY() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xff00) >> 8
}

// GPT164.GTSTR: General PWM Timer Software Start Register
func (o *GPT164_Type) SetGTSTR_CSTRT0(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTSTR_CSTRT0() uint32 {
	return volatile.LoadUint32(&o.GTSTR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTSTR_CSTRT1(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTSTR_CSTRT1() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTSTR_CSTRT2(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTSTR_CSTRT2() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTSTR_CSTRT3(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTSTR_CSTRT3() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTSTR_CSTRT4(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTSTR_CSTRT4() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTSTR_CSTRT5(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTSTR_CSTRT5() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTSTR_CSTRT6(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTSTR_CSTRT6() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTSTR_CSTRT7(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTSTR_CSTRT7() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTSTR_CSTRT8(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTSTR_CSTRT8() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTSTR_CSTRT9(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTSTR_CSTRT9() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x200) >> 9
}

// GPT164.GTSTP: General PWM Timer Software Stop Register
func (o *GPT164_Type) SetGTSTP_CSTOP0(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTSTP_CSTOP0() uint32 {
	return volatile.LoadUint32(&o.GTSTP.Reg) & 0x1
}
func (o *GPT164_Type) SetGTSTP_CSTOP1(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTSTP_CSTOP1() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTSTP_CSTOP2(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTSTP_CSTOP2() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTSTP_CSTOP3(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTSTP_CSTOP3() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTSTP_CSTOP4(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTSTP_CSTOP4() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTSTP_CSTOP5(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTSTP_CSTOP5() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTSTP_CSTOP6(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTSTP_CSTOP6() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTSTP_CSTOP7(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTSTP_CSTOP7() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTSTP_CSTOP8(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTSTP_CSTOP8() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTSTP_CSTOP9(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTSTP_CSTOP9() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x200) >> 9
}

// GPT164.GTCLR: General PWM Timer Software Clear Register
func (o *GPT164_Type) SetGTCLR_CCLR0(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTCLR_CCLR0() uint32 {
	return volatile.LoadUint32(&o.GTCLR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTCLR_CCLR1(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTCLR_CCLR1() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTCLR_CCLR2(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTCLR_CCLR2() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTCLR_CCLR3(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTCLR_CCLR3() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTCLR_CCLR4(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTCLR_CCLR4() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTCLR_CCLR5(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTCLR_CCLR5() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTCLR_CCLR6(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTCLR_CCLR6() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTCLR_CCLR7(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTCLR_CCLR7() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTCLR_CCLR8(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTCLR_CCLR8() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTCLR_CCLR9(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTCLR_CCLR9() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x200) >> 9
}

// GPT164.GTSSR: General PWM Timer Start Source Select Register
func (o *GPT164_Type) SetGTSSR_SSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTSSR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTSSR_SSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTSSR_SSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTSSR_SSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTSSR_SSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTSSR_SSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTSSR_SSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTSSR_SSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTSSR_SSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTSSR_SSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTSSR_SSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTSSR_SSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTSSR_SSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTSSR_SSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTSSR_SSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTSSR_SSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTSSR_SSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTSSR_SSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTSSR_SSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTSSR_SSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTSSR_SSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTSSR_SSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTSSR_SSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTSSR_SSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTSSR_SSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTSSR_SSELCA(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTSSR_SSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTSSR_SSELCB(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTSSR_SSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTSSR_SSELCC(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTSSR_SSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTSSR_SSELCD(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTSSR_SSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTSSR_SSELCE(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTSSR_SSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTSSR_SSELCF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTSSR_SSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTSSR_SSELCG(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTSSR_SSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTSSR_SSELCH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTSSR_SSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800000) >> 23
}
func (o *GPT164_Type) SetGTSSR_CSTRT(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT164_Type) GetGTSSR_CSTRT() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000000) >> 31
}

// GPT164.GTPSR: General PWM Timer Stop Source Select Register
func (o *GPT164_Type) SetGTPSR_PSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTPSR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTPSR_PSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTPSR_PSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTPSR_PSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTPSR_PSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTPSR_PSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTPSR_PSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTPSR_PSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTPSR_PSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTPSR_PSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTPSR_PSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTPSR_PSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTPSR_PSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTPSR_PSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTPSR_PSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTPSR_PSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTPSR_PSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTPSR_PSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTPSR_PSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTPSR_PSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTPSR_PSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTPSR_PSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTPSR_PSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTPSR_PSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTPSR_PSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTPSR_PSELCA(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTPSR_PSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTPSR_PSELCB(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTPSR_PSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTPSR_PSELCC(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTPSR_PSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTPSR_PSELCD(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTPSR_PSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTPSR_PSELCE(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTPSR_PSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTPSR_PSELCF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTPSR_PSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTPSR_PSELCG(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTPSR_PSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTPSR_PSELCH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTPSR_PSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800000) >> 23
}
func (o *GPT164_Type) SetGTPSR_CSTOP(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT164_Type) GetGTPSR_CSTOP() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000000) >> 31
}

// GPT164.GTCSR: General PWM Timer Clear Source Select Register
func (o *GPT164_Type) SetGTCSR_CSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTCSR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTCSR_CSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTCSR_CSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTCSR_CSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTCSR_CSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTCSR_CSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTCSR_CSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTCSR_CSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTCSR_CSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTCSR_CSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTCSR_CSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTCSR_CSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTCSR_CSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTCSR_CSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTCSR_CSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTCSR_CSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTCSR_CSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTCSR_CSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTCSR_CSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTCSR_CSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTCSR_CSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTCSR_CSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTCSR_CSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTCSR_CSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTCSR_CSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTCSR_CSELCA(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTCSR_CSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTCSR_CSELCB(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTCSR_CSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTCSR_CSELCC(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTCSR_CSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTCSR_CSELCD(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTCSR_CSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTCSR_CSELCE(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTCSR_CSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTCSR_CSELCF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTCSR_CSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTCSR_CSELCG(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTCSR_CSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTCSR_CSELCH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTCSR_CSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800000) >> 23
}
func (o *GPT164_Type) SetGTCSR_CCLR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT164_Type) GetGTCSR_CCLR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000000) >> 31
}

// GPT164.GTUPSR: General PWM Timer Up Count Source Select Register
func (o *GPT164_Type) SetGTUPSR_USGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTUPSR_USGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTUPSR_USGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTUPSR_USGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTUPSR_USGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTUPSR_USGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTUPSR_USGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTUPSR_USGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTUPSR_USGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTUPSR_USCARBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTUPSR_USCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTUPSR_USCARBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTUPSR_USCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTUPSR_USCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTUPSR_USCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTUPSR_USCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTUPSR_USCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTUPSR_USCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTUPSR_USCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTUPSR_USCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTUPSR_USCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTUPSR_USCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTUPSR_USCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTUPSR_USCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTUPSR_USCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTUPSR_USELCA(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTUPSR_USELCA() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTUPSR_USELCB(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTUPSR_USELCB() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTUPSR_USELCC(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTUPSR_USELCC() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTUPSR_USELCD(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTUPSR_USELCD() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTUPSR_USELCE(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTUPSR_USELCE() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTUPSR_USELCF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTUPSR_USELCF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTUPSR_USELCG(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTUPSR_USELCG() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTUPSR_USELCH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTUPSR_USELCH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800000) >> 23
}

// GPT164.GTDNSR: General PWM Timer Down Count Source Select Register
func (o *GPT164_Type) SetGTDNSR_DSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTDNSR_DSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTDNSR_DSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTDNSR_DSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTDNSR_DSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTDNSR_DSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTDNSR_DSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTDNSR_DSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTDNSR_DSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTDNSR_DSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTDNSR_DSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTDNSR_DSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTDNSR_DSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTDNSR_DSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTDNSR_DSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTDNSR_DSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTDNSR_DSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTDNSR_DSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTDNSR_DSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTDNSR_DSELCA(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTDNSR_DSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTDNSR_DSELCB(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTDNSR_DSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTDNSR_DSELCC(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTDNSR_DSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTDNSR_DSELCD(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTDNSR_DSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTDNSR_DSELCE(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTDNSR_DSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTDNSR_DSELCF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTDNSR_DSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTDNSR_DSELCG(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTDNSR_DSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTDNSR_DSELCH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTDNSR_DSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800000) >> 23
}

// GPT164.GTICASR: General PWM Timer Input Capture Source Select Register A
func (o *GPT164_Type) SetGTICASR_ASGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICASR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTICASR_ASGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTICASR_ASGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTICASR_ASGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTICASR_ASGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTICASR_ASGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTICASR_ASGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTICASR_ASGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTICASR_ASGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTICASR_ASCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTICASR_ASCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTICASR_ASCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTICASR_ASCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTICASR_ASCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTICASR_ASCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTICASR_ASCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTICASR_ASCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTICASR_ASCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTICASR_ASCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTICASR_ASCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTICASR_ASCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTICASR_ASCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTICASR_ASCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTICASR_ASCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTICASR_ASCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTICASR_ASELCA(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTICASR_ASELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTICASR_ASELCB(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTICASR_ASELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTICASR_ASELCC(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTICASR_ASELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTICASR_ASELCD(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTICASR_ASELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTICASR_ASELCE(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTICASR_ASELCE() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTICASR_ASELCF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTICASR_ASELCF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTICASR_ASELCG(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTICASR_ASELCG() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTICASR_ASELCH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTICASR_ASELCH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800000) >> 23
}

// GPT164.GTICBSR: General PWM Timer Input Capture Source Select Register B
func (o *GPT164_Type) SetGTICBSR_BSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTICBSR_BSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTICBSR_BSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTICBSR_BSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTICBSR_BSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTICBSR_BSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTICBSR_BSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTICBSR_BSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT164_Type) GetGTICBSR_BSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400) >> 10
}
func (o *GPT164_Type) SetGTICBSR_BSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT164_Type) GetGTICBSR_BSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800) >> 11
}
func (o *GPT164_Type) SetGTICBSR_BSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT164_Type) GetGTICBSR_BSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1000) >> 12
}
func (o *GPT164_Type) SetGTICBSR_BSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTICBSR_BSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTICBSR_BSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT164_Type) GetGTICBSR_BSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4000) >> 14
}
func (o *GPT164_Type) SetGTICBSR_BSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTICBSR_BSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTICBSR_BSELCA(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTICBSR_BSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTICBSR_BSELCB(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT164_Type) GetGTICBSR_BSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20000) >> 17
}
func (o *GPT164_Type) SetGTICBSR_BSELCC(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTICBSR_BSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTICBSR_BSELCD(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTICBSR_BSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTICBSR_BSELCE(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT164_Type) GetGTICBSR_BSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100000) >> 20
}
func (o *GPT164_Type) SetGTICBSR_BSELCF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT164_Type) GetGTICBSR_BSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200000) >> 21
}
func (o *GPT164_Type) SetGTICBSR_BSELCG(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTICBSR_BSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTICBSR_BSELCH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTICBSR_BSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800000) >> 23
}

// GPT164.GTCR: General PWM Timer Control Register
func (o *GPT164_Type) SetGTCR_CST(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTCR_CST() uint32 {
	return volatile.LoadUint32(&o.GTCR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTCR_MD(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x70000)|value<<16)
}
func (o *GPT164_Type) GetGTCR_MD() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x70000) >> 16
}
func (o *GPT164_Type) SetGTCR_TPCS(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x7800000)|value<<23)
}
func (o *GPT164_Type) GetGTCR_TPCS() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x7800000) >> 23
}

// GPT164.GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
func (o *GPT164_Type) SetGTUDDTYC_UD(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTUDDTYC_UD() uint32 {
	return volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x1
}
func (o *GPT164_Type) SetGTUDDTYC_UDF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTUDDTYC_UDF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTUDDTYC_OADTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x30000)|value<<16)
}
func (o *GPT164_Type) GetGTUDDTYC_OADTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x30000) >> 16
}
func (o *GPT164_Type) SetGTUDDTYC_OADTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x40000)|value<<18)
}
func (o *GPT164_Type) GetGTUDDTYC_OADTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x40000) >> 18
}
func (o *GPT164_Type) SetGTUDDTYC_OADTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x80000)|value<<19)
}
func (o *GPT164_Type) GetGTUDDTYC_OADTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x80000) >> 19
}
func (o *GPT164_Type) SetGTUDDTYC_OBDTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT164_Type) GetGTUDDTYC_OBDTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x3000000) >> 24
}
func (o *GPT164_Type) SetGTUDDTYC_OBDTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT164_Type) GetGTUDDTYC_OBDTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x4000000) >> 26
}
func (o *GPT164_Type) SetGTUDDTYC_OBDTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x8000000)|value<<27)
}
func (o *GPT164_Type) GetGTUDDTYC_OBDTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x8000000) >> 27
}

// GPT164.GTIOR: General PWM Timer I/O Control Register
func (o *GPT164_Type) SetGTIOR_GTIOA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f)|value)
}
func (o *GPT164_Type) GetGTIOR_GTIOA() uint32 {
	return volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f
}
func (o *GPT164_Type) SetGTIOR_OADFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTIOR_OADFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTIOR_OAHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTIOR_OAHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTIOR_OAE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTIOR_OAE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTIOR_OADF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x600)|value<<9)
}
func (o *GPT164_Type) GetGTIOR_OADF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x600) >> 9
}
func (o *GPT164_Type) SetGTIOR_NFAEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT164_Type) GetGTIOR_NFAEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x2000) >> 13
}
func (o *GPT164_Type) SetGTIOR_NFCSA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc000)|value<<14)
}
func (o *GPT164_Type) GetGTIOR_NFCSA() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc000) >> 14
}
func (o *GPT164_Type) SetGTIOR_GTIOB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f0000)|value<<16)
}
func (o *GPT164_Type) GetGTIOR_GTIOB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f0000) >> 16
}
func (o *GPT164_Type) SetGTIOR_OBDFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTIOR_OBDFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x400000) >> 22
}
func (o *GPT164_Type) SetGTIOR_OBHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT164_Type) GetGTIOR_OBHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x800000) >> 23
}
func (o *GPT164_Type) SetGTIOR_OBE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT164_Type) GetGTIOR_OBE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1000000) >> 24
}
func (o *GPT164_Type) SetGTIOR_OBDF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x6000000)|value<<25)
}
func (o *GPT164_Type) GetGTIOR_OBDF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x6000000) >> 25
}
func (o *GPT164_Type) SetGTIOR_NFBEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT164_Type) GetGTIOR_NFBEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20000000) >> 29
}
func (o *GPT164_Type) SetGTIOR_NFCSB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT164_Type) GetGTIOR_NFCSB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc0000000) >> 30
}

// GPT164.GTINTAD: General PWM Timer Interrupt Output Setting Register
func (o *GPT164_Type) SetGTINTAD_GRP(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT164_Type) GetGTINTAD_GRP() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x3000000) >> 24
}
func (o *GPT164_Type) SetGTINTAD_GRPABH(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT164_Type) GetGTINTAD_GRPABH() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x20000000) >> 29
}
func (o *GPT164_Type) SetGTINTAD_GRPABL(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT164_Type) GetGTINTAD_GRPABL() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x40000000) >> 30
}

// GPT164.GTST: General PWM Timer Status Register
func (o *GPT164_Type) SetGTST_TCFA(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTST_TCFA() uint32 {
	return volatile.LoadUint32(&o.GTST.Reg) & 0x1
}
func (o *GPT164_Type) SetGTST_TCFB(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTST_TCFB() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTST_TCFC(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTST_TCFC() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTST_TCFD(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTST_TCFD() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTST_TCFE(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTST_TCFE() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTST_TCFF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTST_TCFF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTST_TCFPO(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTST_TCFPO() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTST_TCFPU(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTST_TCFPU() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTST_TUCF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8000)|value<<15)
}
func (o *GPT164_Type) GetGTST_TUCF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8000) >> 15
}
func (o *GPT164_Type) SetGTST_ODF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT164_Type) GetGTST_ODF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1000000) >> 24
}
func (o *GPT164_Type) SetGTST_OABHF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT164_Type) GetGTST_OABHF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20000000) >> 29
}
func (o *GPT164_Type) SetGTST_OABLF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT164_Type) GetGTST_OABLF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40000000) >> 30
}
func (o *GPT164_Type) SetGTST_PCF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT164_Type) GetGTST_PCF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x80000000) >> 31
}

// GPT164.GTBER: General PWM Timer Buffer Enable Register
func (o *GPT164_Type) SetGTBER_BD0(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTBER_BD0() uint32 {
	return volatile.LoadUint32(&o.GTBER.Reg) & 0x1
}
func (o *GPT164_Type) SetGTBER_BD1(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTBER_BD1() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTBER_CCRA(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x30000)|value<<16)
}
func (o *GPT164_Type) GetGTBER_CCRA() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x30000) >> 16
}
func (o *GPT164_Type) SetGTBER_CCRB(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPT164_Type) GetGTBER_CCRB() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0xc0000) >> 18
}
func (o *GPT164_Type) SetGTBER_PR(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x300000)|value<<20)
}
func (o *GPT164_Type) GetGTBER_PR() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x300000) >> 20
}
func (o *GPT164_Type) SetGTBER_CCRSWT(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x400000)|value<<22)
}
func (o *GPT164_Type) GetGTBER_CCRSWT() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x400000) >> 22
}

// GPT164.GTDTCR: General PWM Timer Dead Time Control Register
func (o *GPT164_Type) SetGTDTCR_TDE(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTDTCR_TDE() uint32 {
	return volatile.LoadUint32(&o.GTDTCR.Reg) & 0x1
}

// GPT164.GTICLF: General PWM Timer Inter Channel Logical Operation Function Setting Register
func (o *GPT164_Type) SetGTICLF_ICLFA(value uint32) {
	volatile.StoreUint32(&o.GTICLF.Reg, volatile.LoadUint32(&o.GTICLF.Reg)&^(0x7)|value)
}
func (o *GPT164_Type) GetGTICLF_ICLFA() uint32 {
	return volatile.LoadUint32(&o.GTICLF.Reg) & 0x7
}
func (o *GPT164_Type) SetGTICLF_ICLFSELC(value uint32) {
	volatile.StoreUint32(&o.GTICLF.Reg, volatile.LoadUint32(&o.GTICLF.Reg)&^(0x3f0)|value<<4)
}
func (o *GPT164_Type) GetGTICLF_ICLFSELC() uint32 {
	return (volatile.LoadUint32(&o.GTICLF.Reg) & 0x3f0) >> 4
}
func (o *GPT164_Type) SetGTICLF_ICLFB(value uint32) {
	volatile.StoreUint32(&o.GTICLF.Reg, volatile.LoadUint32(&o.GTICLF.Reg)&^(0x70000)|value<<16)
}
func (o *GPT164_Type) GetGTICLF_ICLFB() uint32 {
	return (volatile.LoadUint32(&o.GTICLF.Reg) & 0x70000) >> 16
}
func (o *GPT164_Type) SetGTICLF_ICLFSELD(value uint32) {
	volatile.StoreUint32(&o.GTICLF.Reg, volatile.LoadUint32(&o.GTICLF.Reg)&^(0x3f00000)|value<<20)
}
func (o *GPT164_Type) GetGTICLF_ICLFSELD() uint32 {
	return (volatile.LoadUint32(&o.GTICLF.Reg) & 0x3f00000) >> 20
}

// GPT164.GTPC: General PWM Timer Period Count Register
func (o *GPT164_Type) SetGTPC_PCEN(value uint32) {
	volatile.StoreUint32(&o.GTPC.Reg, volatile.LoadUint32(&o.GTPC.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTPC_PCEN() uint32 {
	return volatile.LoadUint32(&o.GTPC.Reg) & 0x1
}
func (o *GPT164_Type) SetGTPC_ASTP(value uint32) {
	volatile.StoreUint32(&o.GTPC.Reg, volatile.LoadUint32(&o.GTPC.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTPC_ASTP() uint32 {
	return (volatile.LoadUint32(&o.GTPC.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTPC_PCNT(value uint32) {
	volatile.StoreUint32(&o.GTPC.Reg, volatile.LoadUint32(&o.GTPC.Reg)&^(0xfff0000)|value<<16)
}
func (o *GPT164_Type) GetGTPC_PCNT() uint32 {
	return (volatile.LoadUint32(&o.GTPC.Reg) & 0xfff0000) >> 16
}

// GPT164.GTSECSR: General PWM Timer Operation Enable Bit Simultaneous Control Channel Select Register
func (o *GPT164_Type) SetGTSECSR_SECSEL0(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTSECSR_SECSEL0() uint32 {
	return volatile.LoadUint32(&o.GTSECSR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTSECSR_SECSEL1(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTSECSR_SECSEL1() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTSECSR_SECSEL2(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT164_Type) GetGTSECSR_SECSEL2() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x4) >> 2
}
func (o *GPT164_Type) SetGTSECSR_SECSEL3(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT164_Type) GetGTSECSR_SECSEL3() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x8) >> 3
}
func (o *GPT164_Type) SetGTSECSR_SECSEL4(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT164_Type) GetGTSECSR_SECSEL4() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x10) >> 4
}
func (o *GPT164_Type) SetGTSECSR_SECSEL5(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT164_Type) GetGTSECSR_SECSEL5() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x20) >> 5
}
func (o *GPT164_Type) SetGTSECSR_SECSEL6(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT164_Type) GetGTSECSR_SECSEL6() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x40) >> 6
}
func (o *GPT164_Type) SetGTSECSR_SECSEL7(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT164_Type) GetGTSECSR_SECSEL7() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x80) >> 7
}
func (o *GPT164_Type) SetGTSECSR_SECSEL8(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTSECSR_SECSEL8() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTSECSR_SECSEL9(value uint32) {
	volatile.StoreUint32(&o.GTSECSR.Reg, volatile.LoadUint32(&o.GTSECSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTSECSR_SECSEL9() uint32 {
	return (volatile.LoadUint32(&o.GTSECSR.Reg) & 0x200) >> 9
}

// GPT164.GTSECR: General PWM Timer Operation Enable Bit Simultaneous Control Register
func (o *GPT164_Type) SetGTSECR_SBDCE(value uint32) {
	volatile.StoreUint32(&o.GTSECR.Reg, volatile.LoadUint32(&o.GTSECR.Reg)&^(0x1)|value)
}
func (o *GPT164_Type) GetGTSECR_SBDCE() uint32 {
	return volatile.LoadUint32(&o.GTSECR.Reg) & 0x1
}
func (o *GPT164_Type) SetGTSECR_SBDPE(value uint32) {
	volatile.StoreUint32(&o.GTSECR.Reg, volatile.LoadUint32(&o.GTSECR.Reg)&^(0x2)|value<<1)
}
func (o *GPT164_Type) GetGTSECR_SBDPE() uint32 {
	return (volatile.LoadUint32(&o.GTSECR.Reg) & 0x2) >> 1
}
func (o *GPT164_Type) SetGTSECR_SBDCD(value uint32) {
	volatile.StoreUint32(&o.GTSECR.Reg, volatile.LoadUint32(&o.GTSECR.Reg)&^(0x100)|value<<8)
}
func (o *GPT164_Type) GetGTSECR_SBDCD() uint32 {
	return (volatile.LoadUint32(&o.GTSECR.Reg) & 0x100) >> 8
}
func (o *GPT164_Type) SetGTSECR_SBDPD(value uint32) {
	volatile.StoreUint32(&o.GTSECR.Reg, volatile.LoadUint32(&o.GTSECR.Reg)&^(0x200)|value<<9)
}
func (o *GPT164_Type) GetGTSECR_SBDPD() uint32 {
	return (volatile.LoadUint32(&o.GTSECR.Reg) & 0x200) >> 9
}
func (o *GPT164_Type) SetGTSECR_SPCE(value uint32) {
	volatile.StoreUint32(&o.GTSECR.Reg, volatile.LoadUint32(&o.GTSECR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT164_Type) GetGTSECR_SPCE() uint32 {
	return (volatile.LoadUint32(&o.GTSECR.Reg) & 0x10000) >> 16
}
func (o *GPT164_Type) SetGTSECR_SPCD(value uint32) {
	volatile.StoreUint32(&o.GTSECR.Reg, volatile.LoadUint32(&o.GTSECR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT164_Type) GetGTSECR_SPCD() uint32 {
	return (volatile.LoadUint32(&o.GTSECR.Reg) & 0x1000000) >> 24
}

// 12-bit A/D Converter
type ADC120_Type struct {
	ADCSR      volatile.Register16 // 0x0
	_          [2]byte
	ADANSA0    volatile.Register16 // 0x4
	_          [2]byte
	ADADS0     volatile.Register16 // 0x8
	_          [2]byte
	ADADC      volatile.Register8 // 0xC
	_          byte
	ADCER      volatile.Register16 // 0xE
	ADSTRGR    volatile.Register16 // 0x10
	ADEXICR    volatile.Register16 // 0x12
	ADANSB0    volatile.Register16 // 0x14
	_          [2]byte
	ADDBLDR    volatile.Register16 // 0x18
	_          [2]byte
	ADOCDR     volatile.Register16 // 0x1C
	ADRD       volatile.Register16 // 0x1E
	ADDR0      volatile.Register16 // 0x20
	ADDR1      volatile.Register16 // 0x22
	ADDR2      volatile.Register16 // 0x24
	ADDR3      volatile.Register16 // 0x26
	ADDR4      volatile.Register16 // 0x28
	ADDR5      volatile.Register16 // 0x2A
	ADDR6      volatile.Register16 // 0x2C
	ADDR7      volatile.Register16 // 0x2E
	ADDR8      volatile.Register16 // 0x30
	_          [6]byte
	ADDR12     volatile.Register16 // 0x38
	ADDR13     volatile.Register16 // 0x3A
	_          [62]byte
	ADDISCR    volatile.Register8 // 0x7A
	_          [5]byte
	ADGSPCR    volatile.Register16 // 0x80
	_          [2]byte
	ADDBLDRA   volatile.Register16 // 0x84
	ADDBLDRB   volatile.Register16 // 0x86
	_          [4]byte
	ADWINMON   volatile.Register8 // 0x8C
	_          [3]byte
	ADCMPCR    volatile.Register16 // 0x90
	ADCMPANSER volatile.Register8  // 0x92
	ADCMPLER   volatile.Register8  // 0x93
	ADCMPANSR0 volatile.Register16 // 0x94
	_          [2]byte
	ADCMPLR0   volatile.Register16 // 0x98
	_          [2]byte
	ADCMPDR0   volatile.Register16 // 0x9C
	ADCMPDR1   volatile.Register16 // 0x9E
	ADCMPSR0   volatile.Register16 // 0xA0
	_          [2]byte
	ADCMPSER   volatile.Register8 // 0xA4
	_          byte
	ADCMPBNSR  volatile.Register8 // 0xA6
	_          byte
	ADWINLLB   volatile.Register16 // 0xA8
	ADWINULB   volatile.Register16 // 0xAA
	ADCMPBSR   volatile.Register8  // 0xAC
	_          [3]byte
	ADBUF0     volatile.Register16 // 0xB0
	ADBUF1     volatile.Register16 // 0xB2
	ADBUF2     volatile.Register16 // 0xB4
	ADBUF3     volatile.Register16 // 0xB6
	ADBUF4     volatile.Register16 // 0xB8
	ADBUF5     volatile.Register16 // 0xBA
	ADBUF6     volatile.Register16 // 0xBC
	ADBUF7     volatile.Register16 // 0xBE
	ADBUF8     volatile.Register16 // 0xC0
	ADBUF9     volatile.Register16 // 0xC2
	ADBUF10    volatile.Register16 // 0xC4
	ADBUF11    volatile.Register16 // 0xC6
	ADBUF12    volatile.Register16 // 0xC8
	ADBUF13    volatile.Register16 // 0xCA
	ADBUF14    volatile.Register16 // 0xCC
	ADBUF15    volatile.Register16 // 0xCE
	ADBUFEN    volatile.Register8  // 0xD0
	_          byte
	ADBUFPTR   volatile.Register8 // 0xD2
	_          [12]byte
	ADSSTRO    volatile.Register8 // 0xDF
	ADSSTR0    volatile.Register8 // 0xE0
	ADSSTR1    volatile.Register8 // 0xE1
	ADSSTR2    volatile.Register8 // 0xE2
	ADSSTR3    volatile.Register8 // 0xE3
	ADSSTR4    volatile.Register8 // 0xE4
	ADSSTR5    volatile.Register8 // 0xE5
	ADSSTR6    volatile.Register8 // 0xE6
	ADSSTR7    volatile.Register8 // 0xE7
	ADSSTR8    volatile.Register8 // 0xE8
	_          [3]byte
	ADSSTR12   volatile.Register8 // 0xEC
	ADSSTR13   volatile.Register8 // 0xED
}

// ADC120.ADCSR: A/D Control Register
func (o *ADC120_Type) SetADCSR_DBLANS(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x1f)|value)
}
func (o *ADC120_Type) GetADCSR_DBLANS() uint16 {
	return volatile.LoadUint16(&o.ADCSR.Reg) & 0x1f
}
func (o *ADC120_Type) SetADCSR_GBADIE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCSR_GBADIE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCSR_DBLE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCSR_DBLE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCSR_EXTRG(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADCSR_EXTRG() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADCSR_TRGE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADCSR_TRGE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADCSR_ADCS(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x6000)|value<<13)
}
func (o *ADC120_Type) GetADCSR_ADCS() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x6000) >> 13
}
func (o *ADC120_Type) SetADCSR_ADST(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCSR_ADST() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x8000) >> 15
}

// ADC120.ADANSA0: A/D Channel Select Register A0
func (o *ADC120_Type) SetADANSA0_ANSA0(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADANSA0_ANSA0() uint16 {
	return volatile.LoadUint16(&o.ADANSA0.Reg) & 0x1
}
func (o *ADC120_Type) SetADANSA0_ANSA1(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADANSA0_ANSA1() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADANSA0_ANSA2(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADANSA0_ANSA2() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADANSA0_ANSA3(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADANSA0_ANSA3() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADANSA0_ANSA4(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADANSA0_ANSA4() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADANSA0_ANSA5(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADANSA0_ANSA5() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADANSA0_ANSA6(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADANSA0_ANSA6() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADANSA0_ANSA7(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADANSA0_ANSA7() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADANSA0_ANSA8(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADANSA0_ANSA8() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADANSA0_ANSA12(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADANSA0_ANSA12() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADANSA0_ANSA13(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADANSA0_ANSA13() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x2000) >> 13
}

// ADC120.ADADS0: A/D-Converted Value Addition/Average Channel Select Register 0
func (o *ADC120_Type) SetADADS0_ADS0(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADADS0_ADS0() uint16 {
	return volatile.LoadUint16(&o.ADADS0.Reg) & 0x1
}
func (o *ADC120_Type) SetADADS0_ADS1(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADADS0_ADS1() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADADS0_ADS2(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADADS0_ADS2() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADADS0_ADS3(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADADS0_ADS3() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADADS0_ADS4(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADADS0_ADS4() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADADS0_ADS5(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADADS0_ADS5() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADADS0_ADS6(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADADS0_ADS6() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADADS0_ADS7(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADADS0_ADS7() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADADS0_ADS8(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADADS0_ADS8() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADADS0_ADS12(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADADS0_ADS12() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADADS0_ADS13(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADADS0_ADS13() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x2000) >> 13
}

// ADC120.ADADC: A/D-Converted Value Addition/Average Count Select Register
func (o *ADC120_Type) SetADADC_ADC(value uint8) {
	volatile.StoreUint8(&o.ADADC.Reg, volatile.LoadUint8(&o.ADADC.Reg)&^(0x7)|value)
}
func (o *ADC120_Type) GetADADC_ADC() uint8 {
	return volatile.LoadUint8(&o.ADADC.Reg) & 0x7
}
func (o *ADC120_Type) SetADADC_AVEE(value uint8) {
	volatile.StoreUint8(&o.ADADC.Reg, volatile.LoadUint8(&o.ADADC.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADADC_AVEE() uint8 {
	return (volatile.LoadUint8(&o.ADADC.Reg) & 0x80) >> 7
}

// ADC120.ADCER: A/D Control Extended Register
func (o *ADC120_Type) SetADCER_ADPRC(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x6)|value<<1)
}
func (o *ADC120_Type) GetADCER_ADPRC() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x6) >> 1
}
func (o *ADC120_Type) SetADCER_ACE(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCER_ACE() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCER_DIAGVAL(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x300)|value<<8)
}
func (o *ADC120_Type) GetADCER_DIAGVAL() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x300) >> 8
}
func (o *ADC120_Type) SetADCER_DIAGLD(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADCER_DIAGLD() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADCER_DIAGM(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADCER_DIAGM() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADCER_ADRFMT(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCER_ADRFMT() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x8000) >> 15
}

// ADC120.ADSTRGR: A/D Conversion Start Trigger Select Register
func (o *ADC120_Type) SetADSTRGR_TRSB(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0x3f)|value)
}
func (o *ADC120_Type) GetADSTRGR_TRSB() uint16 {
	return volatile.LoadUint16(&o.ADSTRGR.Reg) & 0x3f
}
func (o *ADC120_Type) SetADSTRGR_TRSA(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0x3f00)|value<<8)
}
func (o *ADC120_Type) GetADSTRGR_TRSA() uint16 {
	return (volatile.LoadUint16(&o.ADSTRGR.Reg) & 0x3f00) >> 8
}

// ADC120.ADEXICR: A/D Conversion Extended Input Control Registers
func (o *ADC120_Type) SetADEXICR_OCSAD(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADEXICR_OCSAD() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADEXICR_OCSA(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADEXICR_OCSA() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADEXICR_OCSB(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADEXICR_OCSB() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x800) >> 11
}

// ADC120.ADANSB0: A/D Channel Select Register B0
func (o *ADC120_Type) SetADANSB0_ANSB0(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADANSB0_ANSB0() uint16 {
	return volatile.LoadUint16(&o.ADANSB0.Reg) & 0x1
}
func (o *ADC120_Type) SetADANSB0_ANSB1(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADANSB0_ANSB1() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADANSB0_ANSB2(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADANSB0_ANSB2() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADANSB0_ANSB3(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADANSB0_ANSB3() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADANSB0_ANSB4(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADANSB0_ANSB4() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADANSB0_ANSB5(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADANSB0_ANSB5() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADANSB0_ANSB6(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADANSB0_ANSB6() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADANSB0_ANSB7(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADANSB0_ANSB7() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADANSB0_ANSB8(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADANSB0_ANSB8() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADANSB0_ANSB12(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADANSB0_ANSB12() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADANSB0_ANSB13(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADANSB0_ANSB13() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x2000) >> 13
}

// ADC120.ADDBLDR: A/D Data Duplexing Register
func (o *ADC120_Type) SetADDBLDR(value uint16) {
	volatile.StoreUint16(&o.ADDBLDR.Reg, value)
}
func (o *ADC120_Type) GetADDBLDR() uint16 {
	return volatile.LoadUint16(&o.ADDBLDR.Reg)
}

// ADC120.ADOCDR: A/D Internal Reference Voltage Data Register
func (o *ADC120_Type) SetADOCDR(value uint16) {
	volatile.StoreUint16(&o.ADOCDR.Reg, value)
}
func (o *ADC120_Type) GetADOCDR() uint16 {
	return volatile.LoadUint16(&o.ADOCDR.Reg)
}

// ADC120.ADRD: A/D Self-Diagnosis Data Register
func (o *ADC120_Type) SetADRD_AD(value uint16) {
	volatile.StoreUint16(&o.ADRD.Reg, volatile.LoadUint16(&o.ADRD.Reg)&^(0xfff)|value)
}
func (o *ADC120_Type) GetADRD_AD() uint16 {
	return volatile.LoadUint16(&o.ADRD.Reg) & 0xfff
}
func (o *ADC120_Type) SetADRD_DIAGST(value uint16) {
	volatile.StoreUint16(&o.ADRD.Reg, volatile.LoadUint16(&o.ADRD.Reg)&^(0xc000)|value<<14)
}
func (o *ADC120_Type) GetADRD_DIAGST() uint16 {
	return (volatile.LoadUint16(&o.ADRD.Reg) & 0xc000) >> 14
}

// ADC120.ADDR0: A/D Data Registers %s
func (o *ADC120_Type) SetADDR0(value uint16) {
	volatile.StoreUint16(&o.ADDR0.Reg, value)
}
func (o *ADC120_Type) GetADDR0() uint16 {
	return volatile.LoadUint16(&o.ADDR0.Reg)
}

// ADC120.ADDR1: A/D Data Registers %s
func (o *ADC120_Type) SetADDR1(value uint16) {
	volatile.StoreUint16(&o.ADDR1.Reg, value)
}
func (o *ADC120_Type) GetADDR1() uint16 {
	return volatile.LoadUint16(&o.ADDR1.Reg)
}

// ADC120.ADDR2: A/D Data Registers %s
func (o *ADC120_Type) SetADDR2(value uint16) {
	volatile.StoreUint16(&o.ADDR2.Reg, value)
}
func (o *ADC120_Type) GetADDR2() uint16 {
	return volatile.LoadUint16(&o.ADDR2.Reg)
}

// ADC120.ADDR3: A/D Data Registers %s
func (o *ADC120_Type) SetADDR3(value uint16) {
	volatile.StoreUint16(&o.ADDR3.Reg, value)
}
func (o *ADC120_Type) GetADDR3() uint16 {
	return volatile.LoadUint16(&o.ADDR3.Reg)
}

// ADC120.ADDR4: A/D Data Registers %s
func (o *ADC120_Type) SetADDR4(value uint16) {
	volatile.StoreUint16(&o.ADDR4.Reg, value)
}
func (o *ADC120_Type) GetADDR4() uint16 {
	return volatile.LoadUint16(&o.ADDR4.Reg)
}

// ADC120.ADDR5: A/D Data Registers %s
func (o *ADC120_Type) SetADDR5(value uint16) {
	volatile.StoreUint16(&o.ADDR5.Reg, value)
}
func (o *ADC120_Type) GetADDR5() uint16 {
	return volatile.LoadUint16(&o.ADDR5.Reg)
}

// ADC120.ADDR6: A/D Data Registers %s
func (o *ADC120_Type) SetADDR6(value uint16) {
	volatile.StoreUint16(&o.ADDR6.Reg, value)
}
func (o *ADC120_Type) GetADDR6() uint16 {
	return volatile.LoadUint16(&o.ADDR6.Reg)
}

// ADC120.ADDR7: A/D Data Registers %s
func (o *ADC120_Type) SetADDR7(value uint16) {
	volatile.StoreUint16(&o.ADDR7.Reg, value)
}
func (o *ADC120_Type) GetADDR7() uint16 {
	return volatile.LoadUint16(&o.ADDR7.Reg)
}

// ADC120.ADDR8: A/D Data Registers %s
func (o *ADC120_Type) SetADDR8(value uint16) {
	volatile.StoreUint16(&o.ADDR8.Reg, value)
}
func (o *ADC120_Type) GetADDR8() uint16 {
	return volatile.LoadUint16(&o.ADDR8.Reg)
}

// ADC120.ADDR12: A/D Data Registers %s
func (o *ADC120_Type) SetADDR12(value uint16) {
	volatile.StoreUint16(&o.ADDR12.Reg, value)
}
func (o *ADC120_Type) GetADDR12() uint16 {
	return volatile.LoadUint16(&o.ADDR12.Reg)
}

// ADC120.ADDR13: A/D Data Registers %s
func (o *ADC120_Type) SetADDR13(value uint16) {
	volatile.StoreUint16(&o.ADDR13.Reg, value)
}
func (o *ADC120_Type) GetADDR13() uint16 {
	return volatile.LoadUint16(&o.ADDR13.Reg)
}

// ADC120.ADDISCR: A/D Disconnection Detection Control Register
func (o *ADC120_Type) SetADDISCR_ADNDIS(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0xf)|value)
}
func (o *ADC120_Type) GetADDISCR_ADNDIS() uint8 {
	return volatile.LoadUint8(&o.ADDISCR.Reg) & 0xf
}
func (o *ADC120_Type) SetADDISCR_PCHG(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADDISCR_PCHG() uint8 {
	return (volatile.LoadUint8(&o.ADDISCR.Reg) & 0x10) >> 4
}

// ADC120.ADGSPCR: A/D Group Scan Priority Control Register
func (o *ADC120_Type) SetADGSPCR_PGS(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADGSPCR_PGS() uint16 {
	return volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x1
}
func (o *ADC120_Type) SetADGSPCR_GBRSCN(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADGSPCR_GBRSCN() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADGSPCR_LGRRS(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADGSPCR_LGRRS() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADGSPCR_GBRP(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADGSPCR_GBRP() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x8000) >> 15
}

// ADC120.ADDBLDRA: A/D Data Duplexing Register A
func (o *ADC120_Type) SetADDBLDRA(value uint16) {
	volatile.StoreUint16(&o.ADDBLDRA.Reg, value)
}
func (o *ADC120_Type) GetADDBLDRA() uint16 {
	return volatile.LoadUint16(&o.ADDBLDRA.Reg)
}

// ADC120.ADDBLDRB: A/D Data Duplexing Register B
func (o *ADC120_Type) SetADDBLDRB(value uint16) {
	volatile.StoreUint16(&o.ADDBLDRB.Reg, value)
}
func (o *ADC120_Type) GetADDBLDRB() uint16 {
	return volatile.LoadUint16(&o.ADDBLDRB.Reg)
}

// ADC120.ADWINMON: A/D Compare Function Window A/B Status Monitor Register
func (o *ADC120_Type) SetADWINMON_MONCOMB(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADWINMON_MONCOMB() uint8 {
	return volatile.LoadUint8(&o.ADWINMON.Reg) & 0x1
}
func (o *ADC120_Type) SetADWINMON_MONCMPA(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADWINMON_MONCMPA() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADWINMON_MONCMPB(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADWINMON_MONCMPB() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0x20) >> 5
}

// ADC120.ADCMPCR: A/D Compare Function Control Register
func (o *ADC120_Type) SetADCMPCR_CMPAB(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x3)|value)
}
func (o *ADC120_Type) GetADCMPCR_CMPAB() uint16 {
	return volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x3
}
func (o *ADC120_Type) SetADCMPCR_CMPBE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADCMPCR_CMPBE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADCMPCR_CMPAE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADCMPCR_CMPAE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADCMPCR_CMPBIE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADCMPCR_CMPBIE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADCMPCR_WCMPE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADCMPCR_WCMPE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADCMPCR_CMPAIE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCMPCR_CMPAIE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x8000) >> 15
}

// ADC120.ADCMPANSER: A/D Compare Function Window A Extended Input Select Register
func (o *ADC120_Type) SetADCMPANSER_CMPOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPANSER.Reg, volatile.LoadUint8(&o.ADCMPANSER.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPANSER_CMPOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPANSER.Reg) & 0x2) >> 1
}

// ADC120.ADCMPLER: A/D Compare Function Window A Extended Input Comparison Condition Setting Register
func (o *ADC120_Type) SetADCMPLER_CMPLOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPLER.Reg, volatile.LoadUint8(&o.ADCMPLER.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPLER_CMPLOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPLER.Reg) & 0x2) >> 1
}

// ADC120.ADCMPANSR0: A/D Compare Function Window A Channel Select Register 0
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA0(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA0() uint16 {
	return volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x1
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA1(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA1() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA2(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA2() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA3(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA3() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA4(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA4() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA5(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA5() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA6(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA6() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA7(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA7() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA8(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA8() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA12(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA12() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA13(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA13() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x2000) >> 13
}

// ADC120.ADCMPLR0: A/D Compare Function Window A Comparison Condition Setting Register 0
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA0(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA0() uint16 {
	return volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x1
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA1(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA1() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA2(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA2() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA3(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA3() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA4(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA4() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA5(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA5() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA6(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA6() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA7(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA7() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA8(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA8() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA12(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA12() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA13(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA13() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x2000) >> 13
}

// ADC120.ADCMPSR0: A/D Compare Function Window A Channel Status Register 0
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA0(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA0() uint16 {
	return volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x1
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA1(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA1() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA2(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA2() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA3(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA3() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA4(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA4() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA5(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA5() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA6(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA6() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA7(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA7() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA8(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA8() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA12(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA12() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x1000) >> 12
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA13(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA13() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x2000) >> 13
}

// ADC120.ADCMPSER: A/D Compare Function Window A Extended Input Channel Status Register
func (o *ADC120_Type) SetADCMPSER_CMPSTOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPSER.Reg, volatile.LoadUint8(&o.ADCMPSER.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPSER_CMPSTOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPSER.Reg) & 0x2) >> 1
}

// ADC120.ADCMPBNSR: A/D Compare Function Window B Channel Select Register
func (o *ADC120_Type) SetADCMPBNSR_CMPCHB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x3f)|value)
}
func (o *ADC120_Type) GetADCMPBNSR_CMPCHB() uint8 {
	return volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x3f
}
func (o *ADC120_Type) SetADCMPBNSR_CMPLB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPBNSR_CMPLB() uint8 {
	return (volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x80) >> 7
}

// ADC120.ADCMPBSR: A/D Compare Function Window B Status Register
func (o *ADC120_Type) SetADCMPBSR_CMPSTB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBSR.Reg, volatile.LoadUint8(&o.ADCMPBSR.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPBSR_CMPSTB() uint8 {
	return volatile.LoadUint8(&o.ADCMPBSR.Reg) & 0x1
}

// ADC120.ADBUFEN: A/D Data Buffer Enable Register
func (o *ADC120_Type) SetADBUFEN_BUFEN(value uint8) {
	volatile.StoreUint8(&o.ADBUFEN.Reg, volatile.LoadUint8(&o.ADBUFEN.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADBUFEN_BUFEN() uint8 {
	return volatile.LoadUint8(&o.ADBUFEN.Reg) & 0x1
}

// ADC120.ADBUFPTR: A/D Data Buffer Pointer Register
func (o *ADC120_Type) SetADBUFPTR_BUFPTR(value uint8) {
	volatile.StoreUint8(&o.ADBUFPTR.Reg, volatile.LoadUint8(&o.ADBUFPTR.Reg)&^(0xf)|value)
}
func (o *ADC120_Type) GetADBUFPTR_BUFPTR() uint8 {
	return volatile.LoadUint8(&o.ADBUFPTR.Reg) & 0xf
}
func (o *ADC120_Type) SetADBUFPTR_PTROVF(value uint8) {
	volatile.StoreUint8(&o.ADBUFPTR.Reg, volatile.LoadUint8(&o.ADBUFPTR.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADBUFPTR_PTROVF() uint8 {
	return (volatile.LoadUint8(&o.ADBUFPTR.Reg) & 0x10) >> 4
}

// ADC120.ADSSTRO: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTRO(value uint8) {
	volatile.StoreUint8(&o.ADSSTRO.Reg, value)
}
func (o *ADC120_Type) GetADSSTRO() uint8 {
	return volatile.LoadUint8(&o.ADSSTRO.Reg)
}

// ADC120.ADSSTR0: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR0(value uint8) {
	volatile.StoreUint8(&o.ADSSTR0.Reg, value)
}
func (o *ADC120_Type) GetADSSTR0() uint8 {
	return volatile.LoadUint8(&o.ADSSTR0.Reg)
}

// ADC120.ADSSTR1: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR1(value uint8) {
	volatile.StoreUint8(&o.ADSSTR1.Reg, value)
}
func (o *ADC120_Type) GetADSSTR1() uint8 {
	return volatile.LoadUint8(&o.ADSSTR1.Reg)
}

// ADC120.ADSSTR2: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR2(value uint8) {
	volatile.StoreUint8(&o.ADSSTR2.Reg, value)
}
func (o *ADC120_Type) GetADSSTR2() uint8 {
	return volatile.LoadUint8(&o.ADSSTR2.Reg)
}

// ADC120.ADSSTR3: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR3(value uint8) {
	volatile.StoreUint8(&o.ADSSTR3.Reg, value)
}
func (o *ADC120_Type) GetADSSTR3() uint8 {
	return volatile.LoadUint8(&o.ADSSTR3.Reg)
}

// ADC120.ADSSTR4: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR4(value uint8) {
	volatile.StoreUint8(&o.ADSSTR4.Reg, value)
}
func (o *ADC120_Type) GetADSSTR4() uint8 {
	return volatile.LoadUint8(&o.ADSSTR4.Reg)
}

// ADC120.ADSSTR5: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR5(value uint8) {
	volatile.StoreUint8(&o.ADSSTR5.Reg, value)
}
func (o *ADC120_Type) GetADSSTR5() uint8 {
	return volatile.LoadUint8(&o.ADSSTR5.Reg)
}

// ADC120.ADSSTR6: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR6(value uint8) {
	volatile.StoreUint8(&o.ADSSTR6.Reg, value)
}
func (o *ADC120_Type) GetADSSTR6() uint8 {
	return volatile.LoadUint8(&o.ADSSTR6.Reg)
}

// ADC120.ADSSTR7: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR7(value uint8) {
	volatile.StoreUint8(&o.ADSSTR7.Reg, value)
}
func (o *ADC120_Type) GetADSSTR7() uint8 {
	return volatile.LoadUint8(&o.ADSSTR7.Reg)
}

// ADC120.ADSSTR8: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR8(value uint8) {
	volatile.StoreUint8(&o.ADSSTR8.Reg, value)
}
func (o *ADC120_Type) GetADSSTR8() uint8 {
	return volatile.LoadUint8(&o.ADSSTR8.Reg)
}

// ADC120.ADSSTR12: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR12(value uint8) {
	volatile.StoreUint8(&o.ADSSTR12.Reg, value)
}
func (o *ADC120_Type) GetADSSTR12() uint8 {
	return volatile.LoadUint8(&o.ADSSTR12.Reg)
}

// ADC120.ADSSTR13: A/D Sampling State Register
func (o *ADC120_Type) SetADSSTR13(value uint8) {
	volatile.StoreUint8(&o.ADSSTR13.Reg, value)
}
func (o *ADC120_Type) GetADSSTR13() uint8 {
	return volatile.LoadUint8(&o.ADSSTR13.Reg)
}

// 12-bit D/A converter
type DAC12_Type struct {
	DADRn   volatile.Register16 // 0x0
	_       [2]byte
	DACR    volatile.Register8 // 0x4
	DADPR   volatile.Register8 // 0x5
	DAADSCR volatile.Register8 // 0x6
	_       byte
	DAAMPCR volatile.Register8 // 0x8
	_       [19]byte
	DAASWCR volatile.Register8 // 0x1C
	_       [4259]byte
	DAADUSR volatile.Register8 // 0x10C0
}

// DAC12.DACR: D/A Control Register
func (o *DAC12_Type) SetDACR_DAE(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x20)|value<<5)
}
func (o *DAC12_Type) GetDACR_DAE() uint8 {
	return (volatile.LoadUint8(&o.DACR.Reg) & 0x20) >> 5
}
func (o *DAC12_Type) SetDACR_DAOE0(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x40)|value<<6)
}
func (o *DAC12_Type) GetDACR_DAOE0() uint8 {
	return (volatile.LoadUint8(&o.DACR.Reg) & 0x40) >> 6
}

// DAC12.DADPR: DADR Format Select Register
func (o *DAC12_Type) SetDADPR_DPSEL(value uint8) {
	volatile.StoreUint8(&o.DADPR.Reg, volatile.LoadUint8(&o.DADPR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDADPR_DPSEL() uint8 {
	return (volatile.LoadUint8(&o.DADPR.Reg) & 0x80) >> 7
}

// DAC12.DAADSCR: D/A A/D Synchronous Start Control Register
func (o *DAC12_Type) SetDAADSCR_DAADST(value uint8) {
	volatile.StoreUint8(&o.DAADSCR.Reg, volatile.LoadUint8(&o.DAADSCR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDAADSCR_DAADST() uint8 {
	return (volatile.LoadUint8(&o.DAADSCR.Reg) & 0x80) >> 7
}

// DAC12.DAAMPCR: D/A Output Amplifier Control Register
func (o *DAC12_Type) SetDAAMPCR_DAAMP0(value uint8) {
	volatile.StoreUint8(&o.DAAMPCR.Reg, volatile.LoadUint8(&o.DAAMPCR.Reg)&^(0x40)|value<<6)
}
func (o *DAC12_Type) GetDAAMPCR_DAAMP0() uint8 {
	return (volatile.LoadUint8(&o.DAAMPCR.Reg) & 0x40) >> 6
}

// DAC12.DAASWCR: D/A Amplifier Stabilization Wait Control Register
func (o *DAC12_Type) SetDAASWCR_DAASW0(value uint8) {
	volatile.StoreUint8(&o.DAASWCR.Reg, volatile.LoadUint8(&o.DAASWCR.Reg)&^(0x40)|value<<6)
}
func (o *DAC12_Type) GetDAASWCR_DAASW0() uint8 {
	return (volatile.LoadUint8(&o.DAASWCR.Reg) & 0x40) >> 6
}

// DAC12.DAADUSR: D/A A/D Synchronous Unit Select Register
func (o *DAC12_Type) SetDAADUSR_AMADSEL0(value uint8) {
	volatile.StoreUint8(&o.DAADUSR.Reg, volatile.LoadUint8(&o.DAADUSR.Reg)&^(0x1)|value)
}
func (o *DAC12_Type) GetDAADUSR_AMADSEL0() uint8 {
	return volatile.LoadUint8(&o.DAADUSR.Reg) & 0x1
}

// Data Flash
type FLAD_Type struct {
	_      [64]byte
	FCKMHZ volatile.Register8 // 0x40
}

// FLAD.FCKMHZ: Data Flash Access Frequency Register
func (o *FLAD_Type) SetFCKMHZ(value uint8) {
	volatile.StoreUint8(&o.FCKMHZ.Reg, value)
}
func (o *FLAD_Type) GetFCKMHZ() uint8 {
	return volatile.LoadUint8(&o.FCKMHZ.Reg)
}

// Flash/CPU Interface
type FACI_Type struct {
	_        [16]byte
	FASTAT   volatile.Register8 // 0x10
	_        [3]byte
	FAEINT   volatile.Register8 // 0x14
	_        [3]byte
	FRDYIE   volatile.Register8 // 0x18
	_        [23]byte
	FSADDR   volatile.Register32 // 0x30
	FEADDR   volatile.Register32 // 0x34
	_        [12]byte
	FMEPROT  volatile.Register16 // 0x44
	_        [50]byte
	FBPROT0  volatile.Register16 // 0x78
	_        [2]byte
	FBPROT1  volatile.Register16 // 0x7C
	_        [2]byte
	FSTATR   volatile.Register32 // 0x80
	FENTRYR  volatile.Register16 // 0x84
	_        [6]byte
	FSUINITR volatile.Register16 // 0x8C
	_        [18]byte
	FCMDR    volatile.Register16 // 0xA0
	_        [46]byte
	FBCCNT   volatile.Register8 // 0xD0
	_        [3]byte
	FBCSTAT  volatile.Register8 // 0xD4
	_        [3]byte
	FPSADDR  volatile.Register32 // 0xD8
	FSUASMON volatile.Register32 // 0xDC
	FCPSR    volatile.Register16 // 0xE0
	_        [2]byte
	FPCKAR   volatile.Register16 // 0xE4
	_        [2]byte
	FSUACR   volatile.Register16 // 0xE8
}

// FACI.FASTAT: Flash Access Status Register
func (o *FACI_Type) SetFASTAT_DFAE(value uint8) {
	volatile.StoreUint8(&o.FASTAT.Reg, volatile.LoadUint8(&o.FASTAT.Reg)&^(0x8)|value<<3)
}
func (o *FACI_Type) GetFASTAT_DFAE() uint8 {
	return (volatile.LoadUint8(&o.FASTAT.Reg) & 0x8) >> 3
}
func (o *FACI_Type) SetFASTAT_CMDLK(value uint8) {
	volatile.StoreUint8(&o.FASTAT.Reg, volatile.LoadUint8(&o.FASTAT.Reg)&^(0x10)|value<<4)
}
func (o *FACI_Type) GetFASTAT_CMDLK() uint8 {
	return (volatile.LoadUint8(&o.FASTAT.Reg) & 0x10) >> 4
}
func (o *FACI_Type) SetFASTAT_CFAE(value uint8) {
	volatile.StoreUint8(&o.FASTAT.Reg, volatile.LoadUint8(&o.FASTAT.Reg)&^(0x80)|value<<7)
}
func (o *FACI_Type) GetFASTAT_CFAE() uint8 {
	return (volatile.LoadUint8(&o.FASTAT.Reg) & 0x80) >> 7
}

// FACI.FAEINT: Flash Access Error Interrupt Enable Register
func (o *FACI_Type) SetFAEINT_DFAEIE(value uint8) {
	volatile.StoreUint8(&o.FAEINT.Reg, volatile.LoadUint8(&o.FAEINT.Reg)&^(0x8)|value<<3)
}
func (o *FACI_Type) GetFAEINT_DFAEIE() uint8 {
	return (volatile.LoadUint8(&o.FAEINT.Reg) & 0x8) >> 3
}
func (o *FACI_Type) SetFAEINT_CMDLKIE(value uint8) {
	volatile.StoreUint8(&o.FAEINT.Reg, volatile.LoadUint8(&o.FAEINT.Reg)&^(0x10)|value<<4)
}
func (o *FACI_Type) GetFAEINT_CMDLKIE() uint8 {
	return (volatile.LoadUint8(&o.FAEINT.Reg) & 0x10) >> 4
}
func (o *FACI_Type) SetFAEINT_CFAEIE(value uint8) {
	volatile.StoreUint8(&o.FAEINT.Reg, volatile.LoadUint8(&o.FAEINT.Reg)&^(0x80)|value<<7)
}
func (o *FACI_Type) GetFAEINT_CFAEIE() uint8 {
	return (volatile.LoadUint8(&o.FAEINT.Reg) & 0x80) >> 7
}

// FACI.FRDYIE: Flash Ready Interrupt Enable Register
func (o *FACI_Type) SetFRDYIE(value uint8) {
	volatile.StoreUint8(&o.FRDYIE.Reg, volatile.LoadUint8(&o.FRDYIE.Reg)&^(0x1)|value)
}
func (o *FACI_Type) GetFRDYIE() uint8 {
	return volatile.LoadUint8(&o.FRDYIE.Reg) & 0x1
}

// FACI.FEADDR: FACI Command End Address Register
func (o *FACI_Type) SetFEADDR(value uint32) {
	volatile.StoreUint32(&o.FEADDR.Reg, value)
}
func (o *FACI_Type) GetFEADDR() uint32 {
	return volatile.LoadUint32(&o.FEADDR.Reg)
}

// FACI.FMEPROT: Flash P/E Mode Entry Protection Register
func (o *FACI_Type) SetFMEPROT_CEPROT(value uint16) {
	volatile.StoreUint16(&o.FMEPROT.Reg, volatile.LoadUint16(&o.FMEPROT.Reg)&^(0x1)|value)
}
func (o *FACI_Type) GetFMEPROT_CEPROT() uint16 {
	return volatile.LoadUint16(&o.FMEPROT.Reg) & 0x1
}
func (o *FACI_Type) SetFMEPROT_KEY(value uint16) {
	volatile.StoreUint16(&o.FMEPROT.Reg, volatile.LoadUint16(&o.FMEPROT.Reg)&^(0xff00)|value<<8)
}
func (o *FACI_Type) GetFMEPROT_KEY() uint16 {
	return (volatile.LoadUint16(&o.FMEPROT.Reg) & 0xff00) >> 8
}

// FACI.FBPROT0: Flash Block Protection Register
func (o *FACI_Type) SetFBPROT0_BPCN0(value uint16) {
	volatile.StoreUint16(&o.FBPROT0.Reg, volatile.LoadUint16(&o.FBPROT0.Reg)&^(0x1)|value)
}
func (o *FACI_Type) GetFBPROT0_BPCN0() uint16 {
	return volatile.LoadUint16(&o.FBPROT0.Reg) & 0x1
}
func (o *FACI_Type) SetFBPROT0_KEY(value uint16) {
	volatile.StoreUint16(&o.FBPROT0.Reg, volatile.LoadUint16(&o.FBPROT0.Reg)&^(0xff00)|value<<8)
}
func (o *FACI_Type) GetFBPROT0_KEY() uint16 {
	return (volatile.LoadUint16(&o.FBPROT0.Reg) & 0xff00) >> 8
}

// FACI.FBPROT1: Flash Block Protection for Secure Register
func (o *FACI_Type) SetFBPROT1_BPCN1(value uint16) {
	volatile.StoreUint16(&o.FBPROT1.Reg, volatile.LoadUint16(&o.FBPROT1.Reg)&^(0x1)|value)
}
func (o *FACI_Type) GetFBPROT1_BPCN1() uint16 {
	return volatile.LoadUint16(&o.FBPROT1.Reg) & 0x1
}
func (o *FACI_Type) SetFBPROT1_KEY(value uint16) {
	volatile.StoreUint16(&o.FBPROT1.Reg, volatile.LoadUint16(&o.FBPROT1.Reg)&^(0xff00)|value<<8)
}
func (o *FACI_Type) GetFBPROT1_KEY() uint16 {
	return (volatile.LoadUint16(&o.FBPROT1.Reg) & 0xff00) >> 8
}

// FACI.FSTATR: Flash Status Register
func (o *FACI_Type) SetFSTATR_FLWEERR(value uint32) {
	volatile.StoreUint32(&o.FSTATR.Reg, volatile.LoadUint32(&o.FSTATR.Reg)&^(0x40)|value<<6)
}
func (o *FACI_Type) GetFSTATR_FLWEERR() uint32 {
	return (volatile.LoadUint32(&o.FSTATR.Reg) & 0x40) >> 6
}
func (o *FACI_Type) SetFSTATR_PRGSPD(value uint32) {
	volatile.StoreUint32(&o.FSTATR.Reg, volatile.LoadUint32(&o.FSTATR.Reg)&^(0x100)|value<<8)
}
func (o *FACI_Type) GetFSTATR_PRGSPD() uint32 {
	return (volatile.LoadUint32(&o.FSTATR.Reg) & 0x100) >> 8
}
func (o *FACI_Type) SetFSTATR_ERSSPD(value uint32) {
	volatile.StoreUint32(&o.FSTATR.Reg, volatile.LoadUint32(&o.FSTATR.Reg)&^(0x200)|value<<9)
}
func (o *FACI_Type) GetFSTATR_ERSSPD() uint32 {
	return (volatile.LoadUint32(&o.FSTATR.Reg) & 0x200) >> 9
}
func (o *FACI_Type) SetFSTATR_DBFULL(value uint32) {
	volatile.StoreUint32(&o.FSTATR.Reg, volatile.LoadUint32(&o.FSTATR.Reg)&^(0x400)|value<<10)
}
func (o *FACI_Type) GetFSTATR_DBFULL() uint32 {
	return (volatile.LoadUint32(&o.FSTATR.Reg) & 0x400) >> 10
}
func (o *FACI_Type) SetFSTATR_SUSRDY(value uint32) {
	volatile.StoreUint32(&o.FSTATR.Reg, volatile.LoadUint32(&o.FSTATR.Reg)&^(0x800)|value<<11)
}
func (o *FACI_Type) GetFSTATR_SUSRDY() uint32 {
	return (volatile.LoadUint32(&o.FSTATR.Reg) & 0x800) >> 11
}
func (o *FACI_Type) SetFSTATR_PRGERR(value uint32) {
	volatile.StoreUint32(&o.FSTATR.Reg, volatile.LoadUint32(&o.FSTATR.Reg)&^(0x1000)|value<<12)
}
func (o *FACI_Type) GetFSTATR_PRGERR() uint32 {
	return (volatile.LoadUint32(&o.FSTATR.Reg) & 0x1000) >> 12
}
func (o *FACI_Type) SetFSTATR_ERSERR(value uint32) {
	volatile.StoreUint32(&o.FSTATR.Reg, volatile.LoadUint32(&o.FSTATR.Reg)&^(0x2000)|value<<13)
}
func (o *FACI_Type) GetFSTATR_ERSERR() uint32 {
	return (volatile.LoadUint32(&o.FSTATR.Reg) & 0x2000) >> 13
}
func (o *FACI_Type) SetFSTATR_ILGLERR(value uint32) {
	volatile.StoreUint32(&o.FSTATR.Reg, volatile.LoadUint32(&o.FSTATR.Reg)&^(0x4000)|value<<14)
}
func (o *FACI_Type) GetFSTATR_ILGLERR() uint32 {
	return (volatile.LoadUint32(&o.FSTATR.Reg) & 0x4000) >> 14
}
func (o *FACI_Type) SetFSTATR_FRDY(value uint32) {
	volatile.StoreUint32(&o.FSTATR.Reg, volatile.LoadUint32(&o.FSTATR.Reg)&^(0x8000)|value<<15)
}
func (o *FACI_Type) GetFSTATR_FRDY() uint32 {
	return (volatile.LoadUint32(&o.FSTATR.Reg) & 0x8000) >> 15
}
func (o *FACI_Type) SetFSTATR_OTERR(value uint32) {
	volatile.StoreUint32(&o.FSTATR.Reg, volatile.LoadUint32(&o.FSTATR.Reg)&^(0x100000)|value<<20)
}
func (o *FACI_Type) GetFSTATR_OTERR() uint32 {
	return (volatile.LoadUint32(&o.FSTATR.Reg) & 0x100000) >> 20
}
func (o *FACI_Type) SetFSTATR_SECERR(value uint32) {
	volatile.StoreUint32(&o.FSTATR.Reg, volatile.LoadUint32(&o.FSTATR.Reg)&^(0x200000)|value<<21)
}
func (o *FACI_Type) GetFSTATR_SECERR() uint32 {
	return (volatile.LoadUint32(&o.FSTATR.Reg) & 0x200000) >> 21
}
func (o *FACI_Type) SetFSTATR_FESETERR(value uint32) {
	volatile.StoreUint32(&o.FSTATR.Reg, volatile.LoadUint32(&o.FSTATR.Reg)&^(0x400000)|value<<22)
}
func (o *FACI_Type) GetFSTATR_FESETERR() uint32 {
	return (volatile.LoadUint32(&o.FSTATR.Reg) & 0x400000) >> 22
}
func (o *FACI_Type) SetFSTATR_ILGCOMERR(value uint32) {
	volatile.StoreUint32(&o.FSTATR.Reg, volatile.LoadUint32(&o.FSTATR.Reg)&^(0x800000)|value<<23)
}
func (o *FACI_Type) GetFSTATR_ILGCOMERR() uint32 {
	return (volatile.LoadUint32(&o.FSTATR.Reg) & 0x800000) >> 23
}

// FACI.FENTRYR: Flash P/E Mode Entry Register
func (o *FACI_Type) SetFENTRYR_FENTRYC(value uint16) {
	volatile.StoreUint16(&o.FENTRYR.Reg, volatile.LoadUint16(&o.FENTRYR.Reg)&^(0x1)|value)
}
func (o *FACI_Type) GetFENTRYR_FENTRYC() uint16 {
	return volatile.LoadUint16(&o.FENTRYR.Reg) & 0x1
}
func (o *FACI_Type) SetFENTRYR_FENTRYD(value uint16) {
	volatile.StoreUint16(&o.FENTRYR.Reg, volatile.LoadUint16(&o.FENTRYR.Reg)&^(0x80)|value<<7)
}
func (o *FACI_Type) GetFENTRYR_FENTRYD() uint16 {
	return (volatile.LoadUint16(&o.FENTRYR.Reg) & 0x80) >> 7
}
func (o *FACI_Type) SetFENTRYR_KEY(value uint16) {
	volatile.StoreUint16(&o.FENTRYR.Reg, volatile.LoadUint16(&o.FENTRYR.Reg)&^(0xff00)|value<<8)
}
func (o *FACI_Type) GetFENTRYR_KEY() uint16 {
	return (volatile.LoadUint16(&o.FENTRYR.Reg) & 0xff00) >> 8
}

// FACI.FSUINITR: Flash Sequencer Setup Initialization Register
func (o *FACI_Type) SetFSUINITR_SUINIT(value uint16) {
	volatile.StoreUint16(&o.FSUINITR.Reg, volatile.LoadUint16(&o.FSUINITR.Reg)&^(0x1)|value)
}
func (o *FACI_Type) GetFSUINITR_SUINIT() uint16 {
	return volatile.LoadUint16(&o.FSUINITR.Reg) & 0x1
}
func (o *FACI_Type) SetFSUINITR_KEY(value uint16) {
	volatile.StoreUint16(&o.FSUINITR.Reg, volatile.LoadUint16(&o.FSUINITR.Reg)&^(0xff00)|value<<8)
}
func (o *FACI_Type) GetFSUINITR_KEY() uint16 {
	return (volatile.LoadUint16(&o.FSUINITR.Reg) & 0xff00) >> 8
}

// FACI.FCMDR: FACI Command Register
func (o *FACI_Type) SetFCMDR_PCMDR(value uint16) {
	volatile.StoreUint16(&o.FCMDR.Reg, volatile.LoadUint16(&o.FCMDR.Reg)&^(0xff)|value)
}
func (o *FACI_Type) GetFCMDR_PCMDR() uint16 {
	return volatile.LoadUint16(&o.FCMDR.Reg) & 0xff
}
func (o *FACI_Type) SetFCMDR_CMDR(value uint16) {
	volatile.StoreUint16(&o.FCMDR.Reg, volatile.LoadUint16(&o.FCMDR.Reg)&^(0xff00)|value<<8)
}
func (o *FACI_Type) GetFCMDR_CMDR() uint16 {
	return (volatile.LoadUint16(&o.FCMDR.Reg) & 0xff00) >> 8
}

// FACI.FBCCNT: Blank Check Control Register
func (o *FACI_Type) SetFBCCNT_BCDIR(value uint8) {
	volatile.StoreUint8(&o.FBCCNT.Reg, volatile.LoadUint8(&o.FBCCNT.Reg)&^(0x1)|value)
}
func (o *FACI_Type) GetFBCCNT_BCDIR() uint8 {
	return volatile.LoadUint8(&o.FBCCNT.Reg) & 0x1
}

// FACI.FBCSTAT: Blank Check Status Register
func (o *FACI_Type) SetFBCSTAT_BCST(value uint8) {
	volatile.StoreUint8(&o.FBCSTAT.Reg, volatile.LoadUint8(&o.FBCSTAT.Reg)&^(0x1)|value)
}
func (o *FACI_Type) GetFBCSTAT_BCST() uint8 {
	return volatile.LoadUint8(&o.FBCSTAT.Reg) & 0x1
}

// FACI.FPSADDR: Data Flash Programming Start Address Register
func (o *FACI_Type) SetFPSADDR_PSADR(value uint32) {
	volatile.StoreUint32(&o.FPSADDR.Reg, volatile.LoadUint32(&o.FPSADDR.Reg)&^(0x1ffff)|value)
}
func (o *FACI_Type) GetFPSADDR_PSADR() uint32 {
	return volatile.LoadUint32(&o.FPSADDR.Reg) & 0x1ffff
}

// FACI.FSUASMON: Flash Startup Area Select Monitor Register
func (o *FACI_Type) SetFSUASMON_FSPR(value uint32) {
	volatile.StoreUint32(&o.FSUASMON.Reg, volatile.LoadUint32(&o.FSUASMON.Reg)&^(0x8000)|value<<15)
}
func (o *FACI_Type) GetFSUASMON_FSPR() uint32 {
	return (volatile.LoadUint32(&o.FSUASMON.Reg) & 0x8000) >> 15
}
func (o *FACI_Type) SetFSUASMON_BTFLG(value uint32) {
	volatile.StoreUint32(&o.FSUASMON.Reg, volatile.LoadUint32(&o.FSUASMON.Reg)&^(0x80000000)|value<<31)
}
func (o *FACI_Type) GetFSUASMON_BTFLG() uint32 {
	return (volatile.LoadUint32(&o.FSUASMON.Reg) & 0x80000000) >> 31
}

// FACI.FCPSR: Flash Sequencer Processing Switching Register
func (o *FACI_Type) SetFCPSR_ESUSPMD(value uint16) {
	volatile.StoreUint16(&o.FCPSR.Reg, volatile.LoadUint16(&o.FCPSR.Reg)&^(0x1)|value)
}
func (o *FACI_Type) GetFCPSR_ESUSPMD() uint16 {
	return volatile.LoadUint16(&o.FCPSR.Reg) & 0x1
}

// FACI.FPCKAR: Flash Sequencer Processing Clock Notification Register
func (o *FACI_Type) SetFPCKAR_PCKA(value uint16) {
	volatile.StoreUint16(&o.FPCKAR.Reg, volatile.LoadUint16(&o.FPCKAR.Reg)&^(0xff)|value)
}
func (o *FACI_Type) GetFPCKAR_PCKA() uint16 {
	return volatile.LoadUint16(&o.FPCKAR.Reg) & 0xff
}
func (o *FACI_Type) SetFPCKAR_KEY(value uint16) {
	volatile.StoreUint16(&o.FPCKAR.Reg, volatile.LoadUint16(&o.FPCKAR.Reg)&^(0xff00)|value<<8)
}
func (o *FACI_Type) GetFPCKAR_KEY() uint16 {
	return (volatile.LoadUint16(&o.FPCKAR.Reg) & 0xff00) >> 8
}

// FACI.FSUACR: Flash Startup Area Control Register
func (o *FACI_Type) SetFSUACR_SAS(value uint16) {
	volatile.StoreUint16(&o.FSUACR.Reg, volatile.LoadUint16(&o.FSUACR.Reg)&^(0x3)|value)
}
func (o *FACI_Type) GetFSUACR_SAS() uint16 {
	return volatile.LoadUint16(&o.FSUACR.Reg) & 0x3
}
func (o *FACI_Type) SetFSUACR_KEY(value uint16) {
	volatile.StoreUint16(&o.FSUACR.Reg, volatile.LoadUint16(&o.FSUACR.Reg)&^(0xff00)|value<<8)
}
func (o *FACI_Type) GetFSUACR_KEY() uint16 {
	return (volatile.LoadUint16(&o.FSUACR.Reg) & 0xff00) >> 8
}

// Quad Serial Peripheral Interface
type QSPI_Type struct {
	SFMSMD  volatile.Register32 // 0x0
	SFMSSC  volatile.Register32 // 0x4
	SFMSKC  volatile.Register32 // 0x8
	SFMSST  volatile.Register32 // 0xC
	SFMCOM  volatile.Register32 // 0x10
	SFMCMD  volatile.Register32 // 0x14
	SFMCST  volatile.Register32 // 0x18
	_       [4]byte
	SFMSIC  volatile.Register32 // 0x20
	SFMSAC  volatile.Register32 // 0x24
	SFMSDC  volatile.Register32 // 0x28
	_       [4]byte
	SFMSPC  volatile.Register32 // 0x30
	SFMPMD  volatile.Register32 // 0x34
	_       [1996]byte
	SFMCNT1 volatile.Register32 // 0x804
}

// QSPI.SFMSMD: Transfer Mode Control Register
func (o *QSPI_Type) SetSFMSMD_SFMRM(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x7)|value)
}
func (o *QSPI_Type) GetSFMSMD_SFMRM() uint32 {
	return volatile.LoadUint32(&o.SFMSMD.Reg) & 0x7
}
func (o *QSPI_Type) SetSFMSMD_SFMSE(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x30)|value<<4)
}
func (o *QSPI_Type) GetSFMSMD_SFMSE() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x30) >> 4
}
func (o *QSPI_Type) SetSFMSMD_SFMPFE(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x40)|value<<6)
}
func (o *QSPI_Type) GetSFMSMD_SFMPFE() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x40) >> 6
}
func (o *QSPI_Type) SetSFMSMD_SFMPAE(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x80)|value<<7)
}
func (o *QSPI_Type) GetSFMSMD_SFMPAE() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x80) >> 7
}
func (o *QSPI_Type) SetSFMSMD_SFMMD3(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x100)|value<<8)
}
func (o *QSPI_Type) GetSFMSMD_SFMMD3() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x100) >> 8
}
func (o *QSPI_Type) SetSFMSMD_SFMOEX(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x200)|value<<9)
}
func (o *QSPI_Type) GetSFMSMD_SFMOEX() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x200) >> 9
}
func (o *QSPI_Type) SetSFMSMD_SFMOHW(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x400)|value<<10)
}
func (o *QSPI_Type) GetSFMSMD_SFMOHW() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x400) >> 10
}
func (o *QSPI_Type) SetSFMSMD_SFMOSW(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x800)|value<<11)
}
func (o *QSPI_Type) GetSFMSMD_SFMOSW() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x800) >> 11
}
func (o *QSPI_Type) SetSFMSMD_SFMCCE(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x8000)|value<<15)
}
func (o *QSPI_Type) GetSFMSMD_SFMCCE() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x8000) >> 15
}

// QSPI.SFMSSC: Chip Selection Control Register
func (o *QSPI_Type) SetSFMSSC_SFMSW(value uint32) {
	volatile.StoreUint32(&o.SFMSSC.Reg, volatile.LoadUint32(&o.SFMSSC.Reg)&^(0xf)|value)
}
func (o *QSPI_Type) GetSFMSSC_SFMSW() uint32 {
	return volatile.LoadUint32(&o.SFMSSC.Reg) & 0xf
}
func (o *QSPI_Type) SetSFMSSC_SFMSHD(value uint32) {
	volatile.StoreUint32(&o.SFMSSC.Reg, volatile.LoadUint32(&o.SFMSSC.Reg)&^(0x10)|value<<4)
}
func (o *QSPI_Type) GetSFMSSC_SFMSHD() uint32 {
	return (volatile.LoadUint32(&o.SFMSSC.Reg) & 0x10) >> 4
}
func (o *QSPI_Type) SetSFMSSC_SFMSLD(value uint32) {
	volatile.StoreUint32(&o.SFMSSC.Reg, volatile.LoadUint32(&o.SFMSSC.Reg)&^(0x20)|value<<5)
}
func (o *QSPI_Type) GetSFMSSC_SFMSLD() uint32 {
	return (volatile.LoadUint32(&o.SFMSSC.Reg) & 0x20) >> 5
}

// QSPI.SFMSKC: Clock Control Register
func (o *QSPI_Type) SetSFMSKC_SFMDV(value uint32) {
	volatile.StoreUint32(&o.SFMSKC.Reg, volatile.LoadUint32(&o.SFMSKC.Reg)&^(0x1f)|value)
}
func (o *QSPI_Type) GetSFMSKC_SFMDV() uint32 {
	return volatile.LoadUint32(&o.SFMSKC.Reg) & 0x1f
}
func (o *QSPI_Type) SetSFMSKC_SFMDTY(value uint32) {
	volatile.StoreUint32(&o.SFMSKC.Reg, volatile.LoadUint32(&o.SFMSKC.Reg)&^(0x20)|value<<5)
}
func (o *QSPI_Type) GetSFMSKC_SFMDTY() uint32 {
	return (volatile.LoadUint32(&o.SFMSKC.Reg) & 0x20) >> 5
}

// QSPI.SFMSST: Status Register
func (o *QSPI_Type) SetSFMSST_PFCNT(value uint32) {
	volatile.StoreUint32(&o.SFMSST.Reg, volatile.LoadUint32(&o.SFMSST.Reg)&^(0x1f)|value)
}
func (o *QSPI_Type) GetSFMSST_PFCNT() uint32 {
	return volatile.LoadUint32(&o.SFMSST.Reg) & 0x1f
}
func (o *QSPI_Type) SetSFMSST_PFFUL(value uint32) {
	volatile.StoreUint32(&o.SFMSST.Reg, volatile.LoadUint32(&o.SFMSST.Reg)&^(0x40)|value<<6)
}
func (o *QSPI_Type) GetSFMSST_PFFUL() uint32 {
	return (volatile.LoadUint32(&o.SFMSST.Reg) & 0x40) >> 6
}
func (o *QSPI_Type) SetSFMSST_PFOFF(value uint32) {
	volatile.StoreUint32(&o.SFMSST.Reg, volatile.LoadUint32(&o.SFMSST.Reg)&^(0x80)|value<<7)
}
func (o *QSPI_Type) GetSFMSST_PFOFF() uint32 {
	return (volatile.LoadUint32(&o.SFMSST.Reg) & 0x80) >> 7
}

// QSPI.SFMCOM: Communication Port Register
func (o *QSPI_Type) SetSFMCOM_SFMD(value uint32) {
	volatile.StoreUint32(&o.SFMCOM.Reg, volatile.LoadUint32(&o.SFMCOM.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetSFMCOM_SFMD() uint32 {
	return volatile.LoadUint32(&o.SFMCOM.Reg) & 0xff
}

// QSPI.SFMCMD: Communication Mode Control Register
func (o *QSPI_Type) SetSFMCMD_DCOM(value uint32) {
	volatile.StoreUint32(&o.SFMCMD.Reg, volatile.LoadUint32(&o.SFMCMD.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetSFMCMD_DCOM() uint32 {
	return volatile.LoadUint32(&o.SFMCMD.Reg) & 0x1
}

// QSPI.SFMCST: Communication Status Register
func (o *QSPI_Type) SetSFMCST_COMBSY(value uint32) {
	volatile.StoreUint32(&o.SFMCST.Reg, volatile.LoadUint32(&o.SFMCST.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetSFMCST_COMBSY() uint32 {
	return volatile.LoadUint32(&o.SFMCST.Reg) & 0x1
}
func (o *QSPI_Type) SetSFMCST_EROMR(value uint32) {
	volatile.StoreUint32(&o.SFMCST.Reg, volatile.LoadUint32(&o.SFMCST.Reg)&^(0x80)|value<<7)
}
func (o *QSPI_Type) GetSFMCST_EROMR() uint32 {
	return (volatile.LoadUint32(&o.SFMCST.Reg) & 0x80) >> 7
}

// QSPI.SFMSIC: Instruction Code Register
func (o *QSPI_Type) SetSFMSIC_SFMCIC(value uint32) {
	volatile.StoreUint32(&o.SFMSIC.Reg, volatile.LoadUint32(&o.SFMSIC.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetSFMSIC_SFMCIC() uint32 {
	return volatile.LoadUint32(&o.SFMSIC.Reg) & 0xff
}

// QSPI.SFMSAC: Address Mode Control Register
func (o *QSPI_Type) SetSFMSAC_SFMAS(value uint32) {
	volatile.StoreUint32(&o.SFMSAC.Reg, volatile.LoadUint32(&o.SFMSAC.Reg)&^(0x3)|value)
}
func (o *QSPI_Type) GetSFMSAC_SFMAS() uint32 {
	return volatile.LoadUint32(&o.SFMSAC.Reg) & 0x3
}
func (o *QSPI_Type) SetSFMSAC_SFM4BC(value uint32) {
	volatile.StoreUint32(&o.SFMSAC.Reg, volatile.LoadUint32(&o.SFMSAC.Reg)&^(0x10)|value<<4)
}
func (o *QSPI_Type) GetSFMSAC_SFM4BC() uint32 {
	return (volatile.LoadUint32(&o.SFMSAC.Reg) & 0x10) >> 4
}

// QSPI.SFMSDC: Dummy Cycle Control Register
func (o *QSPI_Type) SetSFMSDC_SFMDN(value uint32) {
	volatile.StoreUint32(&o.SFMSDC.Reg, volatile.LoadUint32(&o.SFMSDC.Reg)&^(0xf)|value)
}
func (o *QSPI_Type) GetSFMSDC_SFMDN() uint32 {
	return volatile.LoadUint32(&o.SFMSDC.Reg) & 0xf
}
func (o *QSPI_Type) SetSFMSDC_SFMXST(value uint32) {
	volatile.StoreUint32(&o.SFMSDC.Reg, volatile.LoadUint32(&o.SFMSDC.Reg)&^(0x40)|value<<6)
}
func (o *QSPI_Type) GetSFMSDC_SFMXST() uint32 {
	return (volatile.LoadUint32(&o.SFMSDC.Reg) & 0x40) >> 6
}
func (o *QSPI_Type) SetSFMSDC_SFMXEN(value uint32) {
	volatile.StoreUint32(&o.SFMSDC.Reg, volatile.LoadUint32(&o.SFMSDC.Reg)&^(0x80)|value<<7)
}
func (o *QSPI_Type) GetSFMSDC_SFMXEN() uint32 {
	return (volatile.LoadUint32(&o.SFMSDC.Reg) & 0x80) >> 7
}
func (o *QSPI_Type) SetSFMSDC_SFMXD(value uint32) {
	volatile.StoreUint32(&o.SFMSDC.Reg, volatile.LoadUint32(&o.SFMSDC.Reg)&^(0xff00)|value<<8)
}
func (o *QSPI_Type) GetSFMSDC_SFMXD() uint32 {
	return (volatile.LoadUint32(&o.SFMSDC.Reg) & 0xff00) >> 8
}

// QSPI.SFMSPC: SPI Protocol Control Register
func (o *QSPI_Type) SetSFMSPC_SFMSPI(value uint32) {
	volatile.StoreUint32(&o.SFMSPC.Reg, volatile.LoadUint32(&o.SFMSPC.Reg)&^(0x3)|value)
}
func (o *QSPI_Type) GetSFMSPC_SFMSPI() uint32 {
	return volatile.LoadUint32(&o.SFMSPC.Reg) & 0x3
}
func (o *QSPI_Type) SetSFMSPC_SFMSDE(value uint32) {
	volatile.StoreUint32(&o.SFMSPC.Reg, volatile.LoadUint32(&o.SFMSPC.Reg)&^(0x10)|value<<4)
}
func (o *QSPI_Type) GetSFMSPC_SFMSDE() uint32 {
	return (volatile.LoadUint32(&o.SFMSPC.Reg) & 0x10) >> 4
}

// QSPI.SFMPMD: Port Control Register
func (o *QSPI_Type) SetSFMPMD_SFMWPL(value uint32) {
	volatile.StoreUint32(&o.SFMPMD.Reg, volatile.LoadUint32(&o.SFMPMD.Reg)&^(0x4)|value<<2)
}
func (o *QSPI_Type) GetSFMPMD_SFMWPL() uint32 {
	return (volatile.LoadUint32(&o.SFMPMD.Reg) & 0x4) >> 2
}

// QSPI.SFMCNT1: External QSPI Address Register
func (o *QSPI_Type) SetSFMCNT1_QSPI_EXT(value uint32) {
	volatile.StoreUint32(&o.SFMCNT1.Reg, volatile.LoadUint32(&o.SFMCNT1.Reg)&^(0xfc000000)|value<<26)
}
func (o *QSPI_Type) GetSFMCNT1_QSPI_EXT() uint32 {
	return (volatile.LoadUint32(&o.SFMCNT1.Reg) & 0xfc000000) >> 26
}

// Constants for RMPU: Renesas Memory Protection Unit
const (
	// MMPUOAD: MMPU Operation After Detection Register
	// Position of OAD field.
	RMPU_MMPUOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	RMPU_MMPUOAD_OAD_Msk = 0x1
	// Bit OAD.
	RMPU_MMPUOAD_OAD = 0x1
	// Non-maskable interrupt
	RMPU_MMPUOAD_OAD_0 = 0x0
	// Reset
	RMPU_MMPUOAD_OAD_1 = 0x1
	// Position of KEY field.
	RMPU_MMPUOAD_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_MMPUOAD_KEY_Msk = 0xff00

	// MMPUOADPT: MMPU Operation After Detection Protect Register
	// Position of PROTECT field.
	RMPU_MMPUOADPT_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	RMPU_MMPUOADPT_PROTECT_Msk = 0x1
	// Bit PROTECT.
	RMPU_MMPUOADPT_PROTECT = 0x1
	// MMPUOAD register writes are possible.
	RMPU_MMPUOADPT_PROTECT_0 = 0x0
	// MMPUOAD register writes are protected. Read is possible.
	RMPU_MMPUOADPT_PROTECT_1 = 0x1
	// Position of KEY field.
	RMPU_MMPUOADPT_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_MMPUOADPT_KEY_Msk = 0xff00

	// MMPUENDMAC: MMPU Enable Register for DMAC
	// Position of ENABLE field.
	RMPU_MMPUENDMAC_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	RMPU_MMPUENDMAC_ENABLE_Msk = 0x1
	// Bit ENABLE.
	RMPU_MMPUENDMAC_ENABLE = 0x1
	// Bus Master MPU of DMAC is disabled.
	RMPU_MMPUENDMAC_ENABLE_0 = 0x0
	// Bus Master MPU of DMAC is enabled.
	RMPU_MMPUENDMAC_ENABLE_1 = 0x1
	// Position of KEY field.
	RMPU_MMPUENDMAC_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_MMPUENDMAC_KEY_Msk = 0xff00

	// MMPUENPTDMAC: MMPU Enable Protect Register for DMAC
	// Position of PROTECT field.
	RMPU_MMPUENPTDMAC_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	RMPU_MMPUENPTDMAC_PROTECT_Msk = 0x1
	// Bit PROTECT.
	RMPU_MMPUENPTDMAC_PROTECT = 0x1
	// MMPUENDMAC register writes are possible.
	RMPU_MMPUENPTDMAC_PROTECT_0 = 0x0
	// MMPUENDMAC register writes are protected. Read is possible.
	RMPU_MMPUENPTDMAC_PROTECT_1 = 0x1
	// Position of KEY field.
	RMPU_MMPUENPTDMAC_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_MMPUENPTDMAC_KEY_Msk = 0xff00

	// MMPURPTDMAC: MMPU Regions Protect Register for DMAC
	// Position of PROTECT field.
	RMPU_MMPURPTDMAC_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	RMPU_MMPURPTDMAC_PROTECT_Msk = 0x1
	// Bit PROTECT.
	RMPU_MMPURPTDMAC_PROTECT = 0x1
	// Bus Master MPU register for DMAC writing is possible.
	RMPU_MMPURPTDMAC_PROTECT_0 = 0x0
	// Bus Master MPU register for DMAC writing is protected. Read is possible.
	RMPU_MMPURPTDMAC_PROTECT_1 = 0x1
	// Position of KEY field.
	RMPU_MMPURPTDMAC_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_MMPURPTDMAC_KEY_Msk = 0xff00

	// MMPURPTDMAC_SEC: MMPU Regions Protect register for DMAC Secure
	// Position of PROTECT field.
	RMPU_MMPURPTDMAC_SEC_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	RMPU_MMPURPTDMAC_SEC_PROTECT_Msk = 0x1
	// Bit PROTECT.
	RMPU_MMPURPTDMAC_SEC_PROTECT = 0x1
	// Bus master MPU register for DMAC secure writes are possible.
	RMPU_MMPURPTDMAC_SEC_PROTECT_0 = 0x0
	// Bus master MPU register for DMAC secure writes are protected. Read is possible.
	RMPU_MMPURPTDMAC_SEC_PROTECT_1 = 0x1
	// Position of KEY field.
	RMPU_MMPURPTDMAC_SEC_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_MMPURPTDMAC_SEC_KEY_Msk = 0xff00

	// MMPUACDMAC0: MMPU Access Control Register for DMAC
	// Position of ENABLE field.
	RMPU_MMPUACDMAC_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	RMPU_MMPUACDMAC_ENABLE_Msk = 0x1
	// Bit ENABLE.
	RMPU_MMPUACDMAC_ENABLE = 0x1
	// DMAC Region n unit is disabled
	RMPU_MMPUACDMAC_ENABLE_0 = 0x0
	// DMAC Region n unit is enabled
	RMPU_MMPUACDMAC_ENABLE_1 = 0x1
	// Position of RP field.
	RMPU_MMPUACDMAC_RP_Pos = 0x1
	// Bit mask of RP field.
	RMPU_MMPUACDMAC_RP_Msk = 0x2
	// Bit RP.
	RMPU_MMPUACDMAC_RP = 0x2
	// Read permission
	RMPU_MMPUACDMAC_RP_0 = 0x0
	// Read protection
	RMPU_MMPUACDMAC_RP_1 = 0x1
	// Position of WP field.
	RMPU_MMPUACDMAC_WP_Pos = 0x2
	// Bit mask of WP field.
	RMPU_MMPUACDMAC_WP_Msk = 0x4
	// Bit WP.
	RMPU_MMPUACDMAC_WP = 0x4
	// Write permission
	RMPU_MMPUACDMAC_WP_0 = 0x0
	// Write protection
	RMPU_MMPUACDMAC_WP_1 = 0x1

	// MMPUSDMAC0: MMPU Start Address Register for DMAC
	// Position of MMPUS field.
	RMPU_MMPUSDMAC_MMPUS_Pos = 0x5
	// Bit mask of MMPUS field.
	RMPU_MMPUSDMAC_MMPUS_Msk = 0xffffffe0

	// MMPUEDMAC0: MMPU End Address Register for DMAC
	// Position of MMPUE field.
	RMPU_MMPUEDMAC_MMPUE_Pos = 0x5
	// Bit mask of MMPUE field.
	RMPU_MMPUEDMAC_MMPUE_Msk = 0xffffffe0

	// MMPUENEDMAC: MMPU Enable Register for EDMAC
	// Position of ENABLE field.
	RMPU_MMPUENEDMAC_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	RMPU_MMPUENEDMAC_ENABLE_Msk = 0x1
	// Bit ENABLE.
	RMPU_MMPUENEDMAC_ENABLE = 0x1
	// Bus Master MPU of EDMAC is disabled.
	RMPU_MMPUENEDMAC_ENABLE_0 = 0x0
	// Bus Master MPU of EDMAC is enabled.
	RMPU_MMPUENEDMAC_ENABLE_1 = 0x1
	// Position of KEY field.
	RMPU_MMPUENEDMAC_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_MMPUENEDMAC_KEY_Msk = 0xff00

	// MMPUENPTEDMAC: MMPU Enable Protect Register for EDMAC
	// Position of PROTECT field.
	RMPU_MMPUENPTEDMAC_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	RMPU_MMPUENPTEDMAC_PROTECT_Msk = 0x1
	// Bit PROTECT.
	RMPU_MMPUENPTEDMAC_PROTECT = 0x1
	// MMPUENEDMAC register writes are possible.
	RMPU_MMPUENPTEDMAC_PROTECT_0 = 0x0
	// MMPUENEDMAC register writes are protected. Read is possible.
	RMPU_MMPUENPTEDMAC_PROTECT_1 = 0x1
	// Position of KEY field.
	RMPU_MMPUENPTEDMAC_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_MMPUENPTEDMAC_KEY_Msk = 0xff00

	// MMPURPTEDMAC: MMPU Regions Protect Register for EDMAC
	// Position of PROTECT field.
	RMPU_MMPURPTEDMAC_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	RMPU_MMPURPTEDMAC_PROTECT_Msk = 0x1
	// Bit PROTECT.
	RMPU_MMPURPTEDMAC_PROTECT = 0x1
	// Bus Master MPU register for EDMAC writing is possible.
	RMPU_MMPURPTEDMAC_PROTECT_0 = 0x0
	// Bus Master MPU register for EDMAC writing is protected. Read is possible.
	RMPU_MMPURPTEDMAC_PROTECT_1 = 0x1
	// Position of KEY field.
	RMPU_MMPURPTEDMAC_KEY_Pos = 0x8
	// Bit mask of KEY field.
	RMPU_MMPURPTEDMAC_KEY_Msk = 0xff00

	// MMPUACEDMAC0: MMPU Access Control Register for EDMAC
	// Position of ENABLE field.
	RMPU_MMPUACEDMAC_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	RMPU_MMPUACEDMAC_ENABLE_Msk = 0x1
	// Bit ENABLE.
	RMPU_MMPUACEDMAC_ENABLE = 0x1
	// EDMAC Region n unit is disabled
	RMPU_MMPUACEDMAC_ENABLE_0 = 0x0
	// EDMAC Region n unit is enabled
	RMPU_MMPUACEDMAC_ENABLE_1 = 0x1
	// Position of RP field.
	RMPU_MMPUACEDMAC_RP_Pos = 0x1
	// Bit mask of RP field.
	RMPU_MMPUACEDMAC_RP_Msk = 0x2
	// Bit RP.
	RMPU_MMPUACEDMAC_RP = 0x2
	// Read permission
	RMPU_MMPUACEDMAC_RP_0 = 0x0
	// Read protection
	RMPU_MMPUACEDMAC_RP_1 = 0x1
	// Position of WP field.
	RMPU_MMPUACEDMAC_WP_Pos = 0x2
	// Bit mask of WP field.
	RMPU_MMPUACEDMAC_WP_Msk = 0x4
	// Bit WP.
	RMPU_MMPUACEDMAC_WP = 0x4
	// Write permission
	RMPU_MMPUACEDMAC_WP_0 = 0x0
	// Write protection
	RMPU_MMPUACEDMAC_WP_1 = 0x1

	// MMPUSEDMAC0: MMPU Start Address Register for EDMAC
	// Position of MMPUS field.
	RMPU_MMPUSEDMAC_MMPUS_Pos = 0x5
	// Bit mask of MMPUS field.
	RMPU_MMPUSEDMAC_MMPUS_Msk = 0xffffffe0

	// MMPUEEDMAC0: MMPU End Address Register for EDMAC
	// Position of MMPUE field.
	RMPU_MMPUEEDMAC_MMPUE_Pos = 0x5
	// Bit mask of MMPUE field.
	RMPU_MMPUEEDMAC_MMPUE_Msk = 0xffffffe0
)

// Constants for TZF: TrustZone Filter
const (
	// TZFOAD: TrustZone Filter Operation After Detection Register
	// Position of OAD field.
	TZF_TZFOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	TZF_TZFOAD_OAD_Msk = 0x1
	// Bit OAD.
	TZF_TZFOAD_OAD = 0x1
	// Non-maskable interrupt
	TZF_TZFOAD_OAD_0 = 0x0
	// Reset
	TZF_TZFOAD_OAD_1 = 0x1
	// Position of KEY field.
	TZF_TZFOAD_KEY_Pos = 0x8
	// Bit mask of KEY field.
	TZF_TZFOAD_KEY_Msk = 0xff00

	// TZFPT: TrustZone Filter Protect Register
	// Position of PROTECT field.
	TZF_TZFPT_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	TZF_TZFPT_PROTECT_Msk = 0x1
	// Bit PROTECT.
	TZF_TZFPT_PROTECT = 0x1
	// All Bus TrustZone Filter register writing is protected. Read is possible.
	TZF_TZFPT_PROTECT_0 = 0x0
	// All Bus TrustZone Filter register writing is possible.
	TZF_TZFPT_PROTECT_1 = 0x1
	// Position of KEY field.
	TZF_TZFPT_KEY_Pos = 0x8
	// Bit mask of KEY field.
	TZF_TZFPT_KEY_Msk = 0xff00
)

// Constants for SRAM: SRAM Control
const (
	// PARIOAD: SRAM Parity Error Operation After Detection Register
	// Position of OAD field.
	SRAM_PARIOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SRAM_PARIOAD_OAD_Msk = 0x1
	// Bit OAD.
	SRAM_PARIOAD_OAD = 0x1
	// Non-maskable interrupt
	SRAM_PARIOAD_OAD_0 = 0x0
	// Reset
	SRAM_PARIOAD_OAD_1 = 0x1

	// SRAMPRCR: SRAM Protection Register
	// Position of SRAMPRCR field.
	SRAM_SRAMPRCR_SRAMPRCR_Pos = 0x0
	// Bit mask of SRAMPRCR field.
	SRAM_SRAMPRCR_SRAMPRCR_Msk = 0x1
	// Bit SRAMPRCR.
	SRAM_SRAMPRCR_SRAMPRCR = 0x1
	// Disable writes to protected registers
	SRAM_SRAMPRCR_SRAMPRCR_0 = 0x0
	// Enable writes to protected registers
	SRAM_SRAMPRCR_SRAMPRCR_1 = 0x1
	// Position of KW field.
	SRAM_SRAMPRCR_KW_Pos = 0x1
	// Bit mask of KW field.
	SRAM_SRAMPRCR_KW_Msk = 0xfe

	// SRAMWTSC: SRAM Wait State Control Register
	// Position of SRAM0WTEN field.
	SRAM_SRAMWTSC_SRAM0WTEN_Pos = 0x0
	// Bit mask of SRAM0WTEN field.
	SRAM_SRAMWTSC_SRAM0WTEN_Msk = 0x1
	// Bit SRAM0WTEN.
	SRAM_SRAMWTSC_SRAM0WTEN = 0x1
	// No wait
	SRAM_SRAMWTSC_SRAM0WTEN_0 = 0x0
	// Add wait state in read access cycle to SRAM0
	SRAM_SRAMWTSC_SRAM0WTEN_1 = 0x1

	// SRAMPRCR2: SRAM Protection Register 2
	// Position of SRAMPRCR2 field.
	SRAM_SRAMPRCR2_SRAMPRCR2_Pos = 0x0
	// Bit mask of SRAMPRCR2 field.
	SRAM_SRAMPRCR2_SRAMPRCR2_Msk = 0x1
	// Bit SRAMPRCR2.
	SRAM_SRAMPRCR2_SRAMPRCR2 = 0x1
	// Disable writes to the protectedregisters
	SRAM_SRAMPRCR2_SRAMPRCR2_0 = 0x0
	// Enable writes to the protected registers
	SRAM_SRAMPRCR2_SRAMPRCR2_1 = 0x1
	// Position of KW field.
	SRAM_SRAMPRCR2_KW_Pos = 0x1
	// Bit mask of KW field.
	SRAM_SRAMPRCR2_KW_Msk = 0xfe
)

// Constants for BUS: Bus Control
const (
	// BUSSCNTFHBIU: Slave Bus Control Register
	// Position of ARBS field.
	BUS_BUSSCNTFHBIU_ARBS_Pos = 0x0
	// Bit mask of ARBS field.
	BUS_BUSSCNTFHBIU_ARBS_Msk = 0x3
	// EDMAC > DMAC/DTC > CPU
	BUS_BUSSCNTFHBIU_ARBS_00 = 0x0
	// Setting prohibited
	BUS_BUSSCNTFHBIU_ARBS_01 = 0x1
	// (EDMAC ↔ DMAC/DTC) > CPU
	BUS_BUSSCNTFHBIU_ARBS_10 = 0x2
	// (EDMAC ↔ DMAC/DTC) ↔ CPU
	BUS_BUSSCNTFHBIU_ARBS_11 = 0x3

	// BUSSCNTFLBIU: Slave Bus Control Register
	// Position of ARBS field.
	BUS_BUSSCNTFLBIU_ARBS_Pos = 0x0
	// Bit mask of ARBS field.
	BUS_BUSSCNTFLBIU_ARBS_Msk = 0x3
	// EDMAC > DMAC/DTC > CPU
	BUS_BUSSCNTFLBIU_ARBS_00 = 0x0
	// Setting prohibited
	BUS_BUSSCNTFLBIU_ARBS_01 = 0x1
	// (EDMAC ↔ DMAC/DTC) > CPU
	BUS_BUSSCNTFLBIU_ARBS_10 = 0x2
	// (EDMAC ↔ DMAC/DTC) ↔ CPU
	BUS_BUSSCNTFLBIU_ARBS_11 = 0x3

	// BUSSCNTS0BIU: Slave Bus Control Register
	// Position of ARBS field.
	BUS_BUSSCNTS0BIU_ARBS_Pos = 0x0
	// Bit mask of ARBS field.
	BUS_BUSSCNTS0BIU_ARBS_Msk = 0x3
	// EDMAC > DMAC/DTC > CPU
	BUS_BUSSCNTS0BIU_ARBS_00 = 0x0
	// Setting prohibited
	BUS_BUSSCNTS0BIU_ARBS_01 = 0x1
	// (EDMAC ↔ DMAC/DTC) > CPU
	BUS_BUSSCNTS0BIU_ARBS_10 = 0x2
	// (EDMAC ↔ DMAC/DTC) ↔ CPU
	BUS_BUSSCNTS0BIU_ARBS_11 = 0x3

	// BUSSCNTPSBIU: Slave Bus Control Register
	// Position of ARBS field.
	BUS_BUSSCNTPSBIU_ARBS_Pos = 0x0
	// Bit mask of ARBS field.
	BUS_BUSSCNTPSBIU_ARBS_Msk = 0x1
	// Bit ARBS.
	BUS_BUSSCNTPSBIU_ARBS = 0x1
	// DMAC/DTC > CPU
	BUS_BUSSCNTPSBIU_ARBS_0 = 0x0
	// DMAC/DTC ↔ CPU
	BUS_BUSSCNTPSBIU_ARBS_1 = 0x1

	// BUSSCNTPLBIU: Slave Bus Control Register
	// Position of ARBS field.
	BUS_BUSSCNTPLBIU_ARBS_Pos = 0x0
	// Bit mask of ARBS field.
	BUS_BUSSCNTPLBIU_ARBS_Msk = 0x1
	// Bit ARBS.
	BUS_BUSSCNTPLBIU_ARBS = 0x1
	// DMAC/DTC > CPU
	BUS_BUSSCNTPLBIU_ARBS_0 = 0x0
	// DMAC/DTC ↔ CPU
	BUS_BUSSCNTPLBIU_ARBS_1 = 0x1

	// BUSSCNTPHBIU: Slave Bus Control Register
	// Position of ARBS field.
	BUS_BUSSCNTPHBIU_ARBS_Pos = 0x0
	// Bit mask of ARBS field.
	BUS_BUSSCNTPHBIU_ARBS_Msk = 0x1
	// Bit ARBS.
	BUS_BUSSCNTPHBIU_ARBS = 0x1
	// DMAC/DTC > CPU
	BUS_BUSSCNTPHBIU_ARBS_0 = 0x0
	// DMAC/DTC ↔ CPU
	BUS_BUSSCNTPHBIU_ARBS_1 = 0x1

	// BUSSCNTEQBIU: Slave Bus Control Register
	// Position of ARBS field.
	BUS_BUSSCNTEQBIU_ARBS_Pos = 0x0
	// Bit mask of ARBS field.
	BUS_BUSSCNTEQBIU_ARBS_Msk = 0x3
	// EDMAC > DMAC/DTC > CPU
	BUS_BUSSCNTEQBIU_ARBS_00 = 0x0
	// Setting prohibited
	BUS_BUSSCNTEQBIU_ARBS_01 = 0x1
	// (EDMAC ↔ DMAC/DTC) > CPU
	BUS_BUSSCNTEQBIU_ARBS_10 = 0x2
	// (EDMAC ↔ DMAC/DTC) ↔ CPU
	BUS_BUSSCNTEQBIU_ARBS_11 = 0x3

	// BUS1ERRADD: BUS Error Address Register
	// Position of BERAD field.
	BUS_BUSERRADD_BERAD_Pos = 0x0
	// Bit mask of BERAD field.
	BUS_BUSERRADD_BERAD_Msk = 0xffffffff

	// BUS1ERRRW: BUS Error Read Write Register
	// Position of RWSTAT field.
	BUS_BUSERRRW_RWSTAT_Pos = 0x0
	// Bit mask of RWSTAT field.
	BUS_BUSERRRW_RWSTAT_Msk = 0x1
	// Bit RWSTAT.
	BUS_BUSERRRW_RWSTAT = 0x1
	// Read access
	BUS_BUSERRRW_RWSTAT_0 = 0x0
	// Write access
	BUS_BUSERRRW_RWSTAT_1 = 0x1

	// BTZF1ERRADD: BUS TZF Error Address Register
	// Position of BTZFERAD field.
	BUS_BTZFERRADD_BTZFERAD_Pos = 0x0
	// Bit mask of BTZFERAD field.
	BUS_BTZFERRADD_BTZFERAD_Msk = 0xffffffff

	// BTZF1ERRRW: BUS TZF Error Read Write Register
	// Position of TRWSTAT field.
	BUS_BTZFERRRW_TRWSTAT_Pos = 0x0
	// Bit mask of TRWSTAT field.
	BUS_BTZFERRRW_TRWSTAT_Msk = 0x1
	// Bit TRWSTAT.
	BUS_BTZFERRRW_TRWSTAT = 0x1
	// Read access
	BUS_BTZFERRRW_TRWSTAT_0 = 0x0
	// Write access
	BUS_BTZFERRRW_TRWSTAT_1 = 0x1

	// BUS1ERRSTAT: BUS Error Status Register %s
	// Position of SLERRSTAT field.
	BUS_BUSERRSTAT_SLERRSTAT_Pos = 0x0
	// Bit mask of SLERRSTAT field.
	BUS_BUSERRSTAT_SLERRSTAT_Msk = 0x1
	// Bit SLERRSTAT.
	BUS_BUSERRSTAT_SLERRSTAT = 0x1
	// No error occurred
	BUS_BUSERRSTAT_SLERRSTAT_0 = 0x0
	// Error occurred
	BUS_BUSERRSTAT_SLERRSTAT_1 = 0x1
	// Position of STERRSTAT field.
	BUS_BUSERRSTAT_STERRSTAT_Pos = 0x1
	// Bit mask of STERRSTAT field.
	BUS_BUSERRSTAT_STERRSTAT_Msk = 0x2
	// Bit STERRSTAT.
	BUS_BUSERRSTAT_STERRSTAT = 0x2
	// No error occurred
	BUS_BUSERRSTAT_STERRSTAT_0 = 0x0
	// Error occurred
	BUS_BUSERRSTAT_STERRSTAT_1 = 0x1
	// Position of MMERRSTAT field.
	BUS_BUSERRSTAT_MMERRSTAT_Pos = 0x3
	// Bit mask of MMERRSTAT field.
	BUS_BUSERRSTAT_MMERRSTAT_Msk = 0x8
	// Bit MMERRSTAT.
	BUS_BUSERRSTAT_MMERRSTAT = 0x8
	// No error occurred
	BUS_BUSERRSTAT_MMERRSTAT_0 = 0x0
	// Error occurred
	BUS_BUSERRSTAT_MMERRSTAT_1 = 0x1
	// Position of ILERRSTAT field.
	BUS_BUSERRSTAT_ILERRSTAT_Pos = 0x4
	// Bit mask of ILERRSTAT field.
	BUS_BUSERRSTAT_ILERRSTAT_Msk = 0x10
	// Bit ILERRSTAT.
	BUS_BUSERRSTAT_ILERRSTAT = 0x10
	// No error occurred
	BUS_BUSERRSTAT_ILERRSTAT_0 = 0x0
	// Error occurred
	BUS_BUSERRSTAT_ILERRSTAT_1 = 0x1

	// BUS1ERRCLR: BUS Error Clear Register %s
	// Position of SLERRCLR field.
	BUS_BUSERRCLR_SLERRCLR_Pos = 0x0
	// Bit mask of SLERRCLR field.
	BUS_BUSERRCLR_SLERRCLR_Msk = 0x1
	// Bit SLERRCLR.
	BUS_BUSERRCLR_SLERRCLR = 0x1
	// Position of STERRCLR field.
	BUS_BUSERRCLR_STERRCLR_Pos = 0x1
	// Bit mask of STERRCLR field.
	BUS_BUSERRCLR_STERRCLR_Msk = 0x2
	// Bit STERRCLR.
	BUS_BUSERRCLR_STERRCLR = 0x2
	// Position of MMERRCLR field.
	BUS_BUSERRCLR_MMERRCLR_Pos = 0x3
	// Bit mask of MMERRCLR field.
	BUS_BUSERRCLR_MMERRCLR_Msk = 0x8
	// Bit MMERRCLR.
	BUS_BUSERRCLR_MMERRCLR = 0x8
	// Position of ILERRCLR field.
	BUS_BUSERRCLR_ILERRCLR_Pos = 0x4
	// Bit mask of ILERRCLR field.
	BUS_BUSERRCLR_ILERRCLR_Msk = 0x10
	// Bit ILERRCLR.
	BUS_BUSERRCLR_ILERRCLR = 0x10

	// DMACDTCERRSTAT: DMAC/DTC Error Status Register
	// Position of MTERRSTAT field.
	BUS_DMACDTCERRSTAT_MTERRSTAT_Pos = 0x0
	// Bit mask of MTERRSTAT field.
	BUS_DMACDTCERRSTAT_MTERRSTAT_Msk = 0x1
	// Bit MTERRSTAT.
	BUS_DMACDTCERRSTAT_MTERRSTAT = 0x1
	// No error occurred
	BUS_DMACDTCERRSTAT_MTERRSTAT_0 = 0x0
	// Error occurred
	BUS_DMACDTCERRSTAT_MTERRSTAT_1 = 0x1

	// DMACDTCERRCLR: DMAC/DTC Error Clear Register
	// Position of MTERRCLR field.
	BUS_DMACDTCERRCLR_MTERRCLR_Pos = 0x0
	// Bit mask of MTERRCLR field.
	BUS_DMACDTCERRCLR_MTERRCLR_Msk = 0x1
	// Bit MTERRCLR.
	BUS_DMACDTCERRCLR_MTERRCLR = 0x1
)

// Constants for DMAC0: Direct memory access controller 0
const (
	// DMCRA: DMA Transfer Count Register
	// Position of DMCRAL field.
	DMAC0_DMCRA_DMCRAL_Pos = 0x0
	// Bit mask of DMCRAL field.
	DMAC0_DMCRA_DMCRAL_Msk = 0xffff
	// Position of DMCRAH field.
	DMAC0_DMCRA_DMCRAH_Pos = 0x10
	// Bit mask of DMCRAH field.
	DMAC0_DMCRA_DMCRAH_Msk = 0x3ff0000

	// DMCRB: DMA Block Transfer Count Register
	// Position of DMCRBL field.
	DMAC0_DMCRB_DMCRBL_Pos = 0x0
	// Bit mask of DMCRBL field.
	DMAC0_DMCRB_DMCRBL_Msk = 0xffff
	// Position of DMCRBH field.
	DMAC0_DMCRB_DMCRBH_Pos = 0x10
	// Bit mask of DMCRBH field.
	DMAC0_DMCRB_DMCRBH_Msk = 0xffff0000

	// DMTMD: DMA Transfer Mode Register
	// Position of DCTG field.
	DMAC0_DMTMD_DCTG_Pos = 0x0
	// Bit mask of DCTG field.
	DMAC0_DMTMD_DCTG_Msk = 0x3
	// Software request
	DMAC0_DMTMD_DCTG_00 = 0x0
	// Hardware request
	DMAC0_DMTMD_DCTG_01 = 0x1
	// Setting prohibited
	DMAC0_DMTMD_DCTG_10 = 0x2
	// Setting prohibited
	DMAC0_DMTMD_DCTG_11 = 0x3
	// Position of SZ field.
	DMAC0_DMTMD_SZ_Pos = 0x8
	// Bit mask of SZ field.
	DMAC0_DMTMD_SZ_Msk = 0x300
	// 8 bits
	DMAC0_DMTMD_SZ_00 = 0x0
	// 16 bits
	DMAC0_DMTMD_SZ_01 = 0x1
	// 32 bits
	DMAC0_DMTMD_SZ_10 = 0x2
	// Setting prohibited
	DMAC0_DMTMD_SZ_11 = 0x3
	// Position of TKP field.
	DMAC0_DMTMD_TKP_Pos = 0xa
	// Bit mask of TKP field.
	DMAC0_DMTMD_TKP_Msk = 0x400
	// Bit TKP.
	DMAC0_DMTMD_TKP = 0x400
	// Transfer is stopped by completion of specified total number of transfer operations.
	DMAC0_DMTMD_TKP_0 = 0x0
	// Transfer is not stopped by completion of specified total number of transfer operations. (free-running)
	DMAC0_DMTMD_TKP_1 = 0x1
	// Position of DTS field.
	DMAC0_DMTMD_DTS_Pos = 0xc
	// Bit mask of DTS field.
	DMAC0_DMTMD_DTS_Msk = 0x3000
	// The destination is specified as the repeat area or block area
	DMAC0_DMTMD_DTS_00 = 0x0
	// The source is specified as the repeat area or block area
	DMAC0_DMTMD_DTS_01 = 0x1
	// The repeat area or block area is not specified
	DMAC0_DMTMD_DTS_10 = 0x2
	// Setting prohibited
	DMAC0_DMTMD_DTS_11 = 0x3
	// Position of MD field.
	DMAC0_DMTMD_MD_Pos = 0xe
	// Bit mask of MD field.
	DMAC0_DMTMD_MD_Msk = 0xc000
	// Normal transfer
	DMAC0_DMTMD_MD_00 = 0x0
	// Repeat transfer
	DMAC0_DMTMD_MD_01 = 0x1
	// Block transfer
	DMAC0_DMTMD_MD_10 = 0x2
	// Repeat-block transfer
	DMAC0_DMTMD_MD_11 = 0x3

	// DMINT: DMA Interrupt Setting Register
	// Position of DARIE field.
	DMAC0_DMINT_DARIE_Pos = 0x0
	// Bit mask of DARIE field.
	DMAC0_DMINT_DARIE_Msk = 0x1
	// Bit DARIE.
	DMAC0_DMINT_DARIE = 0x1
	// Disables an interrupt request for an extended repeat area overflow on the destination address
	DMAC0_DMINT_DARIE_0 = 0x0
	// Enables an interrupt request for an extended repeat area overflow on the destination address
	DMAC0_DMINT_DARIE_1 = 0x1
	// Position of SARIE field.
	DMAC0_DMINT_SARIE_Pos = 0x1
	// Bit mask of SARIE field.
	DMAC0_DMINT_SARIE_Msk = 0x2
	// Bit SARIE.
	DMAC0_DMINT_SARIE = 0x2
	// Disables an interrupt request for an extended repeat area overflow on the source address
	DMAC0_DMINT_SARIE_0 = 0x0
	// Enables an interrupt request for an extended repeat area overflow on the source address
	DMAC0_DMINT_SARIE_1 = 0x1
	// Position of RPTIE field.
	DMAC0_DMINT_RPTIE_Pos = 0x2
	// Bit mask of RPTIE field.
	DMAC0_DMINT_RPTIE_Msk = 0x4
	// Bit RPTIE.
	DMAC0_DMINT_RPTIE = 0x4
	// Disables the repeat size end interrupt request
	DMAC0_DMINT_RPTIE_0 = 0x0
	// Enables the repeat size end interrupt request
	DMAC0_DMINT_RPTIE_1 = 0x1
	// Position of ESIE field.
	DMAC0_DMINT_ESIE_Pos = 0x3
	// Bit mask of ESIE field.
	DMAC0_DMINT_ESIE_Msk = 0x8
	// Bit ESIE.
	DMAC0_DMINT_ESIE = 0x8
	// Disables the transfer escape end interrupt request
	DMAC0_DMINT_ESIE_0 = 0x0
	// Enables the transfer escape end interrupt request
	DMAC0_DMINT_ESIE_1 = 0x1
	// Position of DTIE field.
	DMAC0_DMINT_DTIE_Pos = 0x4
	// Bit mask of DTIE field.
	DMAC0_DMINT_DTIE_Msk = 0x10
	// Bit DTIE.
	DMAC0_DMINT_DTIE = 0x10
	// Disables the transfer end interrupt request
	DMAC0_DMINT_DTIE_0 = 0x0
	// Enables the transfer end interrupt request
	DMAC0_DMINT_DTIE_1 = 0x1

	// DMAMD: DMA Address Mode Register
	// Position of DARA field.
	DMAC0_DMAMD_DARA_Pos = 0x0
	// Bit mask of DARA field.
	DMAC0_DMAMD_DARA_Msk = 0x1f
	// Position of DADR field.
	DMAC0_DMAMD_DADR_Pos = 0x5
	// Bit mask of DADR field.
	DMAC0_DMAMD_DADR_Msk = 0x20
	// Bit DADR.
	DMAC0_DMAMD_DADR = 0x20
	// Only reloading
	DMAC0_DMAMD_DADR_0 = 0x0
	// Add index after reloading
	DMAC0_DMAMD_DADR_1 = 0x1
	// Position of DM field.
	DMAC0_DMAMD_DM_Pos = 0x6
	// Bit mask of DM field.
	DMAC0_DMAMD_DM_Msk = 0xc0
	// Destination address is fixed
	DMAC0_DMAMD_DM_00 = 0x0
	// Offset addition
	DMAC0_DMAMD_DM_01 = 0x1
	// Destination address is incremented
	DMAC0_DMAMD_DM_10 = 0x2
	// Destination address is decremented
	DMAC0_DMAMD_DM_11 = 0x3
	// Position of SARA field.
	DMAC0_DMAMD_SARA_Pos = 0x8
	// Bit mask of SARA field.
	DMAC0_DMAMD_SARA_Msk = 0x1f00
	// Position of SADR field.
	DMAC0_DMAMD_SADR_Pos = 0xd
	// Bit mask of SADR field.
	DMAC0_DMAMD_SADR_Msk = 0x2000
	// Bit SADR.
	DMAC0_DMAMD_SADR = 0x2000
	// Only reloading
	DMAC0_DMAMD_SADR_0 = 0x0
	// Add index after reloading
	DMAC0_DMAMD_SADR_1 = 0x1
	// Position of SM field.
	DMAC0_DMAMD_SM_Pos = 0xe
	// Bit mask of SM field.
	DMAC0_DMAMD_SM_Msk = 0xc000
	// Source address is fixed
	DMAC0_DMAMD_SM_00 = 0x0
	// Offset addition
	DMAC0_DMAMD_SM_01 = 0x1
	// Source address is incremented
	DMAC0_DMAMD_SM_10 = 0x2
	// Source address is decremented
	DMAC0_DMAMD_SM_11 = 0x3

	// DMCNT: DMA Transfer Enable Register
	// Position of DTE field.
	DMAC0_DMCNT_DTE_Pos = 0x0
	// Bit mask of DTE field.
	DMAC0_DMCNT_DTE_Msk = 0x1
	// Bit DTE.
	DMAC0_DMCNT_DTE = 0x1
	// Disables DMA transfer
	DMAC0_DMCNT_DTE_0 = 0x0
	// Enables DMA transfer
	DMAC0_DMCNT_DTE_1 = 0x1

	// DMREQ: DMA Software Start Register
	// Position of SWREQ field.
	DMAC0_DMREQ_SWREQ_Pos = 0x0
	// Bit mask of SWREQ field.
	DMAC0_DMREQ_SWREQ_Msk = 0x1
	// Bit SWREQ.
	DMAC0_DMREQ_SWREQ = 0x1
	// DMA transfer is not requested
	DMAC0_DMREQ_SWREQ_0 = 0x0
	// DMA transfer is requested
	DMAC0_DMREQ_SWREQ_1 = 0x1
	// Position of CLRS field.
	DMAC0_DMREQ_CLRS_Pos = 0x4
	// Bit mask of CLRS field.
	DMAC0_DMREQ_CLRS_Msk = 0x10
	// Bit CLRS.
	DMAC0_DMREQ_CLRS = 0x10
	// SWREQ bit is cleared after DMA transfer is started by software
	DMAC0_DMREQ_CLRS_0 = 0x0
	// SWREQ bit is not cleared after DMA transfer is started by software
	DMAC0_DMREQ_CLRS_1 = 0x1

	// DMSTS: DMA Status Register
	// Position of ESIF field.
	DMAC0_DMSTS_ESIF_Pos = 0x0
	// Bit mask of ESIF field.
	DMAC0_DMSTS_ESIF_Msk = 0x1
	// Bit ESIF.
	DMAC0_DMSTS_ESIF = 0x1
	// A transfer escape end interrupt has not been generated
	DMAC0_DMSTS_ESIF_0 = 0x0
	// A transfer escape end interrupt has been generated
	DMAC0_DMSTS_ESIF_1 = 0x1
	// Position of DTIF field.
	DMAC0_DMSTS_DTIF_Pos = 0x4
	// Bit mask of DTIF field.
	DMAC0_DMSTS_DTIF_Msk = 0x10
	// Bit DTIF.
	DMAC0_DMSTS_DTIF = 0x10
	// A transfer end interrupt has not been generated
	DMAC0_DMSTS_DTIF_0 = 0x0
	// A transfer end interrupt has been generated
	DMAC0_DMSTS_DTIF_1 = 0x1
	// Position of ACT field.
	DMAC0_DMSTS_ACT_Pos = 0x7
	// Bit mask of ACT field.
	DMAC0_DMSTS_ACT_Msk = 0x80
	// Bit ACT.
	DMAC0_DMSTS_ACT = 0x80
	// DMAC is in the idle state
	DMAC0_DMSTS_ACT_0 = 0x0
	// DMAC is operating
	DMAC0_DMSTS_ACT_1 = 0x1

	// DMSBS: DMA Source Buffer Size Register
	// Position of DMSBSL field.
	DMAC0_DMSBS_DMSBSL_Pos = 0x0
	// Bit mask of DMSBSL field.
	DMAC0_DMSBS_DMSBSL_Msk = 0xffff
	// Position of DMSBSH field.
	DMAC0_DMSBS_DMSBSH_Pos = 0x10
	// Bit mask of DMSBSH field.
	DMAC0_DMSBS_DMSBSH_Msk = 0xffff0000

	// DMDBS: DMA Destination Buffer Size Register
	// Position of DMDBSL field.
	DMAC0_DMDBS_DMDBSL_Pos = 0x0
	// Bit mask of DMDBSL field.
	DMAC0_DMDBS_DMDBSL_Msk = 0xffff
	// Position of DMDBSH field.
	DMAC0_DMDBS_DMDBSH_Pos = 0x10
	// Bit mask of DMDBSH field.
	DMAC0_DMDBS_DMDBSH_Msk = 0xffff0000
)

// Constants for DMA: DMAC Module Activation
const (
	// DMAST: DMA Module Activation Register
	// Position of DMST field.
	DMA_DMAST_DMST_Pos = 0x0
	// Bit mask of DMST field.
	DMA_DMAST_DMST_Msk = 0x1
	// Bit DMST.
	DMA_DMAST_DMST = 0x1
	// DMAC activation is disabled
	DMA_DMAST_DMST_0 = 0x0
	// DMAC activation is enabled
	DMA_DMAST_DMST_1 = 0x1

	// DMECHR: DMAC Error Channel Register
	// Position of DMECH field.
	DMA_DMECHR_DMECH_Pos = 0x0
	// Bit mask of DMECH field.
	DMA_DMECHR_DMECH_Msk = 0x7
	// Position of DMECHSAM field.
	DMA_DMECHR_DMECHSAM_Pos = 0x8
	// Bit mask of DMECHSAM field.
	DMA_DMECHR_DMECHSAM_Msk = 0x100
	// Bit DMECHSAM.
	DMA_DMECHR_DMECHSAM = 0x100
	// secure channel
	DMA_DMECHR_DMECHSAM_0 = 0x0
	// non-secure channel
	DMA_DMECHR_DMECHSAM_1 = 0x1
	// Position of DMESTA field.
	DMA_DMECHR_DMESTA_Pos = 0x10
	// Bit mask of DMESTA field.
	DMA_DMECHR_DMESTA_Msk = 0x10000
	// Bit DMESTA.
	DMA_DMECHR_DMESTA = 0x10000
	// No DMA transfer error occurred
	DMA_DMECHR_DMESTA_0 = 0x0
	// DMA transfer error occurred
	DMA_DMECHR_DMESTA_1 = 0x1
)

// Constants for DTC: Data Transfer Controller
const (
	// DTCCR: DTC Control Register
	// Position of RRS field.
	DTC_DTCCR_RRS_Pos = 0x4
	// Bit mask of RRS field.
	DTC_DTCCR_RRS_Msk = 0x10
	// Bit RRS.
	DTC_DTCCR_RRS = 0x10
	// Transfer information read is not skipped
	DTC_DTCCR_RRS_0 = 0x0
	// Transfer information read is skipped when vector numbers match
	DTC_DTCCR_RRS_1 = 0x1

	// DTCST: DTC Module Start Register
	// Position of DTCST field.
	DTC_DTCST_DTCST_Pos = 0x0
	// Bit mask of DTCST field.
	DTC_DTCST_DTCST_Msk = 0x1
	// Bit DTCST.
	DTC_DTCST_DTCST = 0x1
	// DTC module stopped
	DTC_DTCST_DTCST_0 = 0x0
	// DTC module started
	DTC_DTCST_DTCST_1 = 0x1

	// DTCSTS: DTC Status Register
	// Position of VECN field.
	DTC_DTCSTS_VECN_Pos = 0x0
	// Bit mask of VECN field.
	DTC_DTCSTS_VECN_Msk = 0xff
	// Position of ACT field.
	DTC_DTCSTS_ACT_Pos = 0xf
	// Bit mask of ACT field.
	DTC_DTCSTS_ACT_Msk = 0x8000
	// Bit ACT.
	DTC_DTCSTS_ACT = 0x8000
	// DTC transfer operation is not in progress
	DTC_DTCSTS_ACT_0 = 0x0
	// DTC transfer operation is in progress
	DTC_DTCSTS_ACT_1 = 0x1

	// DTCCR_SEC: DTC Control Register for secure Region
	// Position of RRS field.
	DTC_DTCCR_SEC_RRS_Pos = 0x4
	// Bit mask of RRS field.
	DTC_DTCCR_SEC_RRS_Msk = 0x10
	// Bit RRS.
	DTC_DTCCR_SEC_RRS = 0x10
	// Transfer information read is not skipped.
	DTC_DTCCR_SEC_RRS_0 = 0x0
	// Transfer information read is skipped when vector numbers match.
	DTC_DTCCR_SEC_RRS_1 = 0x1

	// DTEVR: DTC Error Vector Register
	// Position of DTEV field.
	DTC_DTEVR_DTEV_Pos = 0x0
	// Bit mask of DTEV field.
	DTC_DTEVR_DTEV_Msk = 0xff
	// Position of DTEVSAM field.
	DTC_DTEVR_DTEVSAM_Pos = 0x8
	// Bit mask of DTEVSAM field.
	DTC_DTEVR_DTEVSAM_Msk = 0x100
	// Bit DTEVSAM.
	DTC_DTEVR_DTEVSAM = 0x100
	// Secure vector number
	DTC_DTEVR_DTEVSAM_0 = 0x0
	// Non-Secure vector number
	DTC_DTEVR_DTEVSAM_1 = 0x1
	// Position of DTESTA field.
	DTC_DTEVR_DTESTA_Pos = 0x10
	// Bit mask of DTESTA field.
	DTC_DTEVR_DTESTA_Msk = 0x10000
	// Bit DTESTA.
	DTC_DTEVR_DTESTA = 0x10000
	// No DTC transfer error occurred
	DTC_DTEVR_DTESTA_0 = 0x0
	// DTC transfer error occurred
	DTC_DTEVR_DTESTA_1 = 0x1
)

// Constants for ICU: Interrupt Controller
const (
	// IRQCR0: IRQ Control Register
	// Position of IRQMD field.
	ICU_IRQCR_IRQMD_Pos = 0x0
	// Bit mask of IRQMD field.
	ICU_IRQCR_IRQMD_Msk = 0x3
	// Falling edge
	ICU_IRQCR_IRQMD_00 = 0x0
	// Rising edge
	ICU_IRQCR_IRQMD_01 = 0x1
	// Rising and falling edges
	ICU_IRQCR_IRQMD_10 = 0x2
	// Low level
	ICU_IRQCR_IRQMD_11 = 0x3
	// Position of FCLKSEL field.
	ICU_IRQCR_FCLKSEL_Pos = 0x4
	// Bit mask of FCLKSEL field.
	ICU_IRQCR_FCLKSEL_Msk = 0x30
	// PCLKB
	ICU_IRQCR_FCLKSEL_00 = 0x0
	// PCLKB/8
	ICU_IRQCR_FCLKSEL_01 = 0x1
	// PCLKB/32
	ICU_IRQCR_FCLKSEL_10 = 0x2
	// PCLKB/64
	ICU_IRQCR_FCLKSEL_11 = 0x3
	// Position of FLTEN field.
	ICU_IRQCR_FLTEN_Pos = 0x7
	// Bit mask of FLTEN field.
	ICU_IRQCR_FLTEN_Msk = 0x80
	// Bit FLTEN.
	ICU_IRQCR_FLTEN = 0x80
	// Digital filter is disabled
	ICU_IRQCR_FLTEN_0 = 0x0
	// Digital filter is enabled.
	ICU_IRQCR_FLTEN_1 = 0x1

	// NMICR: NMI Pin Interrupt Control Register
	// Position of NMIMD field.
	ICU_NMICR_NMIMD_Pos = 0x0
	// Bit mask of NMIMD field.
	ICU_NMICR_NMIMD_Msk = 0x1
	// Bit NMIMD.
	ICU_NMICR_NMIMD = 0x1
	// Falling edge
	ICU_NMICR_NMIMD_0 = 0x0
	// Rising edge
	ICU_NMICR_NMIMD_1 = 0x1
	// Position of NFCLKSEL field.
	ICU_NMICR_NFCLKSEL_Pos = 0x4
	// Bit mask of NFCLKSEL field.
	ICU_NMICR_NFCLKSEL_Msk = 0x30
	// PCLKB
	ICU_NMICR_NFCLKSEL_00 = 0x0
	// PCLKB/8
	ICU_NMICR_NFCLKSEL_01 = 0x1
	// PCLKB/32
	ICU_NMICR_NFCLKSEL_10 = 0x2
	// PCLKB/64
	ICU_NMICR_NFCLKSEL_11 = 0x3
	// Position of NFLTEN field.
	ICU_NMICR_NFLTEN_Pos = 0x7
	// Bit mask of NFLTEN field.
	ICU_NMICR_NFLTEN_Msk = 0x80
	// Bit NFLTEN.
	ICU_NMICR_NFLTEN = 0x80
	// Disabled.
	ICU_NMICR_NFLTEN_0 = 0x0
	// Enabled.
	ICU_NMICR_NFLTEN_1 = 0x1

	// NMIER: Non-Maskable Interrupt Enable Register
	// Position of IWDTEN field.
	ICU_NMIER_IWDTEN_Pos = 0x0
	// Bit mask of IWDTEN field.
	ICU_NMIER_IWDTEN_Msk = 0x1
	// Bit IWDTEN.
	ICU_NMIER_IWDTEN = 0x1
	// Disabled
	ICU_NMIER_IWDTEN_0 = 0x0
	// Enabled.
	ICU_NMIER_IWDTEN_1 = 0x1
	// Position of WDTEN field.
	ICU_NMIER_WDTEN_Pos = 0x1
	// Bit mask of WDTEN field.
	ICU_NMIER_WDTEN_Msk = 0x2
	// Bit WDTEN.
	ICU_NMIER_WDTEN = 0x2
	// Disabled
	ICU_NMIER_WDTEN_0 = 0x0
	// Enabled
	ICU_NMIER_WDTEN_1 = 0x1
	// Position of LVD1EN field.
	ICU_NMIER_LVD1EN_Pos = 0x2
	// Bit mask of LVD1EN field.
	ICU_NMIER_LVD1EN_Msk = 0x4
	// Bit LVD1EN.
	ICU_NMIER_LVD1EN = 0x4
	// Disabled
	ICU_NMIER_LVD1EN_0 = 0x0
	// Enabled
	ICU_NMIER_LVD1EN_1 = 0x1
	// Position of LVD2EN field.
	ICU_NMIER_LVD2EN_Pos = 0x3
	// Bit mask of LVD2EN field.
	ICU_NMIER_LVD2EN_Msk = 0x8
	// Bit LVD2EN.
	ICU_NMIER_LVD2EN = 0x8
	// Disabled
	ICU_NMIER_LVD2EN_0 = 0x0
	// Enabled
	ICU_NMIER_LVD2EN_1 = 0x1
	// Position of OSTEN field.
	ICU_NMIER_OSTEN_Pos = 0x6
	// Bit mask of OSTEN field.
	ICU_NMIER_OSTEN_Msk = 0x40
	// Bit OSTEN.
	ICU_NMIER_OSTEN = 0x40
	// Disabled
	ICU_NMIER_OSTEN_0 = 0x0
	// Enabled
	ICU_NMIER_OSTEN_1 = 0x1
	// Position of NMIEN field.
	ICU_NMIER_NMIEN_Pos = 0x7
	// Bit mask of NMIEN field.
	ICU_NMIER_NMIEN_Msk = 0x80
	// Bit NMIEN.
	ICU_NMIER_NMIEN = 0x80
	// Disabled
	ICU_NMIER_NMIEN_0 = 0x0
	// Enabled
	ICU_NMIER_NMIEN_1 = 0x1
	// Position of RPEEN field.
	ICU_NMIER_RPEEN_Pos = 0x8
	// Bit mask of RPEEN field.
	ICU_NMIER_RPEEN_Msk = 0x100
	// Bit RPEEN.
	ICU_NMIER_RPEEN = 0x100
	// Disabled
	ICU_NMIER_RPEEN_0 = 0x0
	// Enabled
	ICU_NMIER_RPEEN_1 = 0x1
	// Position of BUSMEN field.
	ICU_NMIER_BUSMEN_Pos = 0xb
	// Bit mask of BUSMEN field.
	ICU_NMIER_BUSMEN_Msk = 0x800
	// Bit BUSMEN.
	ICU_NMIER_BUSMEN = 0x800
	// Disabled
	ICU_NMIER_BUSMEN_0 = 0x0
	// Enabled
	ICU_NMIER_BUSMEN_1 = 0x1
	// Position of TZFEN field.
	ICU_NMIER_TZFEN_Pos = 0xd
	// Bit mask of TZFEN field.
	ICU_NMIER_TZFEN_Msk = 0x2000
	// Bit TZFEN.
	ICU_NMIER_TZFEN = 0x2000
	// Disabled
	ICU_NMIER_TZFEN_0 = 0x0
	// Enabled
	ICU_NMIER_TZFEN_1 = 0x1
	// Position of CPEEN field.
	ICU_NMIER_CPEEN_Pos = 0xf
	// Bit mask of CPEEN field.
	ICU_NMIER_CPEEN_Msk = 0x8000
	// Bit CPEEN.
	ICU_NMIER_CPEEN = 0x8000
	// Disabled
	ICU_NMIER_CPEEN_0 = 0x0
	// Enabled
	ICU_NMIER_CPEEN_1 = 0x1

	// NMICLR: Non-Maskable Interrupt Status Clear Register
	// Position of IWDTCLR field.
	ICU_NMICLR_IWDTCLR_Pos = 0x0
	// Bit mask of IWDTCLR field.
	ICU_NMICLR_IWDTCLR_Msk = 0x1
	// Bit IWDTCLR.
	ICU_NMICLR_IWDTCLR = 0x1
	// No effect
	ICU_NMICLR_IWDTCLR_0 = 0x0
	// Clear the NMISR.IWDTST flag
	ICU_NMICLR_IWDTCLR_1 = 0x1
	// Position of WDTCLR field.
	ICU_NMICLR_WDTCLR_Pos = 0x1
	// Bit mask of WDTCLR field.
	ICU_NMICLR_WDTCLR_Msk = 0x2
	// Bit WDTCLR.
	ICU_NMICLR_WDTCLR = 0x2
	// No effect
	ICU_NMICLR_WDTCLR_0 = 0x0
	// Clear the NMISR.WDTST flag
	ICU_NMICLR_WDTCLR_1 = 0x1
	// Position of LVD1CLR field.
	ICU_NMICLR_LVD1CLR_Pos = 0x2
	// Bit mask of LVD1CLR field.
	ICU_NMICLR_LVD1CLR_Msk = 0x4
	// Bit LVD1CLR.
	ICU_NMICLR_LVD1CLR = 0x4
	// No effect
	ICU_NMICLR_LVD1CLR_0 = 0x0
	// Clear the NMISR.LVD1ST flag
	ICU_NMICLR_LVD1CLR_1 = 0x1
	// Position of LVD2CLR field.
	ICU_NMICLR_LVD2CLR_Pos = 0x3
	// Bit mask of LVD2CLR field.
	ICU_NMICLR_LVD2CLR_Msk = 0x8
	// Bit LVD2CLR.
	ICU_NMICLR_LVD2CLR = 0x8
	// No effect
	ICU_NMICLR_LVD2CLR_0 = 0x0
	// Clear the NMISR.LVD2ST flag.
	ICU_NMICLR_LVD2CLR_1 = 0x1
	// Position of OSTCLR field.
	ICU_NMICLR_OSTCLR_Pos = 0x6
	// Bit mask of OSTCLR field.
	ICU_NMICLR_OSTCLR_Msk = 0x40
	// Bit OSTCLR.
	ICU_NMICLR_OSTCLR = 0x40
	// No effect
	ICU_NMICLR_OSTCLR_0 = 0x0
	// Clear the NMISR.OSTST flag
	ICU_NMICLR_OSTCLR_1 = 0x1
	// Position of NMICLR field.
	ICU_NMICLR_NMICLR_Pos = 0x7
	// Bit mask of NMICLR field.
	ICU_NMICLR_NMICLR_Msk = 0x80
	// Bit NMICLR.
	ICU_NMICLR_NMICLR = 0x80
	// No effect
	ICU_NMICLR_NMICLR_0 = 0x0
	// Clear the NMISR.NMIST flag
	ICU_NMICLR_NMICLR_1 = 0x1
	// Position of RPECLR field.
	ICU_NMICLR_RPECLR_Pos = 0x8
	// Bit mask of RPECLR field.
	ICU_NMICLR_RPECLR_Msk = 0x100
	// Bit RPECLR.
	ICU_NMICLR_RPECLR = 0x100
	// No effect
	ICU_NMICLR_RPECLR_0 = 0x0
	// Clear the NMISR.RPEST flag
	ICU_NMICLR_RPECLR_1 = 0x1
	// Position of BUSMCLR field.
	ICU_NMICLR_BUSMCLR_Pos = 0xb
	// Bit mask of BUSMCLR field.
	ICU_NMICLR_BUSMCLR_Msk = 0x800
	// Bit BUSMCLR.
	ICU_NMICLR_BUSMCLR = 0x800
	// No effect
	ICU_NMICLR_BUSMCLR_0 = 0x0
	// Clear the NMISR.BUSMST flag
	ICU_NMICLR_BUSMCLR_1 = 0x1
	// Position of TZFCLR field.
	ICU_NMICLR_TZFCLR_Pos = 0xd
	// Bit mask of TZFCLR field.
	ICU_NMICLR_TZFCLR_Msk = 0x2000
	// Bit TZFCLR.
	ICU_NMICLR_TZFCLR = 0x2000
	// No effect
	ICU_NMICLR_TZFCLR_0 = 0x0
	// Clear the NMISR.TZFCLR flag
	ICU_NMICLR_TZFCLR_1 = 0x1
	// Position of CPECLR field.
	ICU_NMICLR_CPECLR_Pos = 0xf
	// Bit mask of CPECLR field.
	ICU_NMICLR_CPECLR_Msk = 0x8000
	// Bit CPECLR.
	ICU_NMICLR_CPECLR = 0x8000
	// No effect
	ICU_NMICLR_CPECLR_0 = 0x0
	// Clear the NMISR.CPECLR flag
	ICU_NMICLR_CPECLR_1 = 0x1

	// NMISR: Non-Maskable Interrupt Status Register
	// Position of IWDTST field.
	ICU_NMISR_IWDTST_Pos = 0x0
	// Bit mask of IWDTST field.
	ICU_NMISR_IWDTST_Msk = 0x1
	// Bit IWDTST.
	ICU_NMISR_IWDTST = 0x1
	// Interrupt not requested
	ICU_NMISR_IWDTST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_IWDTST_1 = 0x1
	// Position of WDTST field.
	ICU_NMISR_WDTST_Pos = 0x1
	// Bit mask of WDTST field.
	ICU_NMISR_WDTST_Msk = 0x2
	// Bit WDTST.
	ICU_NMISR_WDTST = 0x2
	// Interrupt not requested
	ICU_NMISR_WDTST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_WDTST_1 = 0x1
	// Position of LVD1ST field.
	ICU_NMISR_LVD1ST_Pos = 0x2
	// Bit mask of LVD1ST field.
	ICU_NMISR_LVD1ST_Msk = 0x4
	// Bit LVD1ST.
	ICU_NMISR_LVD1ST = 0x4
	// Interrupt not requested
	ICU_NMISR_LVD1ST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_LVD1ST_1 = 0x1
	// Position of LVD2ST field.
	ICU_NMISR_LVD2ST_Pos = 0x3
	// Bit mask of LVD2ST field.
	ICU_NMISR_LVD2ST_Msk = 0x8
	// Bit LVD2ST.
	ICU_NMISR_LVD2ST = 0x8
	// Interrupt not requested
	ICU_NMISR_LVD2ST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_LVD2ST_1 = 0x1
	// Position of OSTST field.
	ICU_NMISR_OSTST_Pos = 0x6
	// Bit mask of OSTST field.
	ICU_NMISR_OSTST_Msk = 0x40
	// Bit OSTST.
	ICU_NMISR_OSTST = 0x40
	// Interrupt not requested for main oscillation stop
	ICU_NMISR_OSTST_0 = 0x0
	// Interrupt requested for main oscillation stop
	ICU_NMISR_OSTST_1 = 0x1
	// Position of NMIST field.
	ICU_NMISR_NMIST_Pos = 0x7
	// Bit mask of NMIST field.
	ICU_NMISR_NMIST_Msk = 0x80
	// Bit NMIST.
	ICU_NMISR_NMIST = 0x80
	// Interrupt not requested
	ICU_NMISR_NMIST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_NMIST_1 = 0x1
	// Position of RPEST field.
	ICU_NMISR_RPEST_Pos = 0x8
	// Bit mask of RPEST field.
	ICU_NMISR_RPEST_Msk = 0x100
	// Bit RPEST.
	ICU_NMISR_RPEST = 0x100
	// Interrupt not requested
	ICU_NMISR_RPEST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_RPEST_1 = 0x1
	// Position of BUSMST field.
	ICU_NMISR_BUSMST_Pos = 0xb
	// Bit mask of BUSMST field.
	ICU_NMISR_BUSMST_Msk = 0x800
	// Bit BUSMST.
	ICU_NMISR_BUSMST = 0x800
	// Interrupt not requested
	ICU_NMISR_BUSMST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_BUSMST_1 = 0x1
	// Position of TZFST field.
	ICU_NMISR_TZFST_Pos = 0xd
	// Bit mask of TZFST field.
	ICU_NMISR_TZFST_Msk = 0x2000
	// Bit TZFST.
	ICU_NMISR_TZFST = 0x2000
	// Interrupt not requested
	ICU_NMISR_TZFST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_TZFST_1 = 0x1
	// Position of CPEST field.
	ICU_NMISR_CPEST_Pos = 0xf
	// Bit mask of CPEST field.
	ICU_NMISR_CPEST_Msk = 0x8000
	// Bit CPEST.
	ICU_NMISR_CPEST = 0x8000
	// Interrupt not requested
	ICU_NMISR_CPEST_0 = 0x0
	// Interrupt requested
	ICU_NMISR_CPEST_1 = 0x1

	// WUPEN0: Wake Up Interrupt Enable Register 0
	// Position of IRQWUPEN field.
	ICU_WUPEN0_IRQWUPEN_Pos = 0x0
	// Bit mask of IRQWUPEN field.
	ICU_WUPEN0_IRQWUPEN_Msk = 0xffff
	// Software Standby/Snooze Mode returns by IRQn interrupt is disabled
	ICU_WUPEN0_IRQWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by IRQn interrupt is enabled
	ICU_WUPEN0_IRQWUPEN_1 = 0x1
	// Position of IWDTWUPEN field.
	ICU_WUPEN0_IWDTWUPEN_Pos = 0x10
	// Bit mask of IWDTWUPEN field.
	ICU_WUPEN0_IWDTWUPEN_Msk = 0x10000
	// Bit IWDTWUPEN.
	ICU_WUPEN0_IWDTWUPEN = 0x10000
	// Software Standby/Snooze Mode returns by IWDT interrupt is disabled
	ICU_WUPEN0_IWDTWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by IWDT interrupt is enabled
	ICU_WUPEN0_IWDTWUPEN_1 = 0x1
	// Position of LVD1WUPEN field.
	ICU_WUPEN0_LVD1WUPEN_Pos = 0x12
	// Bit mask of LVD1WUPEN field.
	ICU_WUPEN0_LVD1WUPEN_Msk = 0x40000
	// Bit LVD1WUPEN.
	ICU_WUPEN0_LVD1WUPEN = 0x40000
	// Software Standby/Snooze Mode returns by LVD1 interrupt is disabled
	ICU_WUPEN0_LVD1WUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by LVD1 interrupt is enabled
	ICU_WUPEN0_LVD1WUPEN_1 = 0x1
	// Position of LVD2WUPEN field.
	ICU_WUPEN0_LVD2WUPEN_Pos = 0x13
	// Bit mask of LVD2WUPEN field.
	ICU_WUPEN0_LVD2WUPEN_Msk = 0x80000
	// Bit LVD2WUPEN.
	ICU_WUPEN0_LVD2WUPEN = 0x80000
	// Software Standby/Snooze Mode returns by LVD2 interrupt is disabled
	ICU_WUPEN0_LVD2WUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by LVD2 interrupt is enabled
	ICU_WUPEN0_LVD2WUPEN_1 = 0x1
	// Position of RTCALMWUPEN field.
	ICU_WUPEN0_RTCALMWUPEN_Pos = 0x18
	// Bit mask of RTCALMWUPEN field.
	ICU_WUPEN0_RTCALMWUPEN_Msk = 0x1000000
	// Bit RTCALMWUPEN.
	ICU_WUPEN0_RTCALMWUPEN = 0x1000000
	// Software Standby/Snooze Mode returns by RTC alarm interrupt is disabled
	ICU_WUPEN0_RTCALMWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by RTC alarm interrupt is enabled
	ICU_WUPEN0_RTCALMWUPEN_1 = 0x1
	// Position of RTCPRDWUPEN field.
	ICU_WUPEN0_RTCPRDWUPEN_Pos = 0x19
	// Bit mask of RTCPRDWUPEN field.
	ICU_WUPEN0_RTCPRDWUPEN_Msk = 0x2000000
	// Bit RTCPRDWUPEN.
	ICU_WUPEN0_RTCPRDWUPEN = 0x2000000
	// Software Standby/Snooze Mode returns by RTC period interrupt is disabled
	ICU_WUPEN0_RTCPRDWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by RTC period interrupt is enabled
	ICU_WUPEN0_RTCPRDWUPEN_1 = 0x1
	// Position of USBFS0WUPEN field.
	ICU_WUPEN0_USBFS0WUPEN_Pos = 0x1b
	// Bit mask of USBFS0WUPEN field.
	ICU_WUPEN0_USBFS0WUPEN_Msk = 0x8000000
	// Bit USBFS0WUPEN.
	ICU_WUPEN0_USBFS0WUPEN = 0x8000000
	// Software Standby/Snooze Mode returns by USBFS0 interrupt is disabled
	ICU_WUPEN0_USBFS0WUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by USBFS0 interrupt is enabled
	ICU_WUPEN0_USBFS0WUPEN_1 = 0x1
	// Position of AGT1UDWUPEN field.
	ICU_WUPEN0_AGT1UDWUPEN_Pos = 0x1c
	// Bit mask of AGT1UDWUPEN field.
	ICU_WUPEN0_AGT1UDWUPEN_Msk = 0x10000000
	// Bit AGT1UDWUPEN.
	ICU_WUPEN0_AGT1UDWUPEN = 0x10000000
	// Software Standby/Snooze Mode returns by AGT1 underflow interrupt is disabled
	ICU_WUPEN0_AGT1UDWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by AGT1 underflow interrupt is enabled
	ICU_WUPEN0_AGT1UDWUPEN_1 = 0x1
	// Position of AGT1CAWUPEN field.
	ICU_WUPEN0_AGT1CAWUPEN_Pos = 0x1d
	// Bit mask of AGT1CAWUPEN field.
	ICU_WUPEN0_AGT1CAWUPEN_Msk = 0x20000000
	// Bit AGT1CAWUPEN.
	ICU_WUPEN0_AGT1CAWUPEN = 0x20000000
	// Software Standby/Snooze Mode returns by AGT1 compare match A interrupt is disabled
	ICU_WUPEN0_AGT1CAWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by AGT1 compare match A interrupt is enabled
	ICU_WUPEN0_AGT1CAWUPEN_1 = 0x1
	// Position of AGT1CBWUPEN field.
	ICU_WUPEN0_AGT1CBWUPEN_Pos = 0x1e
	// Bit mask of AGT1CBWUPEN field.
	ICU_WUPEN0_AGT1CBWUPEN_Msk = 0x40000000
	// Bit AGT1CBWUPEN.
	ICU_WUPEN0_AGT1CBWUPEN = 0x40000000
	// Software Standby/Snooze Mode returns by AGT1 compare match B interrupt is disabled
	ICU_WUPEN0_AGT1CBWUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by AGT1 compare match B interrupt is enabled
	ICU_WUPEN0_AGT1CBWUPEN_1 = 0x1
	// Position of IIC0WUPEN field.
	ICU_WUPEN0_IIC0WUPEN_Pos = 0x1f
	// Bit mask of IIC0WUPEN field.
	ICU_WUPEN0_IIC0WUPEN_Msk = 0x80000000
	// Bit IIC0WUPEN.
	ICU_WUPEN0_IIC0WUPEN = 0x80000000
	// Software Standby/Snooze Mode returns by IIC0 address match interrupt is disabled
	ICU_WUPEN0_IIC0WUPEN_0 = 0x0
	// Software Standby/Snooze Mode returns by IIC0 address match interrupt is enabled
	ICU_WUPEN0_IIC0WUPEN_1 = 0x1

	// WUPEN1: Wake Up interrupt enable register 1
	// Position of AGT3UDWUPEN field.
	ICU_WUPEN1_AGT3UDWUPEN_Pos = 0x0
	// Bit mask of AGT3UDWUPEN field.
	ICU_WUPEN1_AGT3UDWUPEN_Msk = 0x1
	// Bit AGT3UDWUPEN.
	ICU_WUPEN1_AGT3UDWUPEN = 0x1
	// Software standby returns by AGT3 underflow interrupt is disabled
	ICU_WUPEN1_AGT3UDWUPEN_0 = 0x0
	// Software standby returns by AGT3 underflow interrupt is enabled
	ICU_WUPEN1_AGT3UDWUPEN_1 = 0x1
	// Position of AGT3CAWUPEN field.
	ICU_WUPEN1_AGT3CAWUPEN_Pos = 0x1
	// Bit mask of AGT3CAWUPEN field.
	ICU_WUPEN1_AGT3CAWUPEN_Msk = 0x2
	// Bit AGT3CAWUPEN.
	ICU_WUPEN1_AGT3CAWUPEN = 0x2
	// Software standby returns by AGT3 compare match A interrupt is disabled
	ICU_WUPEN1_AGT3CAWUPEN_0 = 0x0
	// Software standby returns by AGT3 compare match A interrupt is enabled
	ICU_WUPEN1_AGT3CAWUPEN_1 = 0x1
	// Position of AGT3CBWUPEN field.
	ICU_WUPEN1_AGT3CBWUPEN_Pos = 0x2
	// Bit mask of AGT3CBWUPEN field.
	ICU_WUPEN1_AGT3CBWUPEN_Msk = 0x4
	// Bit AGT3CBWUPEN.
	ICU_WUPEN1_AGT3CBWUPEN = 0x4
	// Software standby returns by AGT3 compare match B interrupt is disabled
	ICU_WUPEN1_AGT3CBWUPEN_0 = 0x0
	// Software standby returns by AGT3 compare match B interrupt is enabled
	ICU_WUPEN1_AGT3CBWUPEN_1 = 0x1

	// DELSR0: DMAC Event Link Setting Register %s
	// Position of DELS field.
	ICU_DELSR_DELS_Pos = 0x0
	// Bit mask of DELS field.
	ICU_DELSR_DELS_Msk = 0x1ff
	// Disable interrupts to the associated DMAC module.
	ICU_DELSR_DELS_0x00 = 0x0
	// Position of IR field.
	ICU_DELSR_IR_Pos = 0x10
	// Bit mask of IR field.
	ICU_DELSR_IR_Msk = 0x10000
	// Bit IR.
	ICU_DELSR_IR = 0x10000
	// No DMAC activation request occurred.
	ICU_DELSR_IR_0 = 0x0
	// DMAC activation request occurred.
	ICU_DELSR_IR_1 = 0x1
)

// Constants for CACHE: CACHE
const (
	// CCACTL: C-Cache Control Register
	// Position of ENC field.
	CACHE_CCACTL_ENC_Pos = 0x0
	// Bit mask of ENC field.
	CACHE_CCACTL_ENC_Msk = 0x1
	// Bit ENC.
	CACHE_CCACTL_ENC = 0x1
	// Disable C-cache
	CACHE_CCACTL_ENC_0 = 0x0
	// Enable C-cache
	CACHE_CCACTL_ENC_1 = 0x1

	// CCAFCT: C-Cache Flush Control Register
	// Position of FC field.
	CACHE_CCAFCT_FC_Pos = 0x0
	// Bit mask of FC field.
	CACHE_CCAFCT_FC_Msk = 0x1
	// Bit FC.
	CACHE_CCAFCT_FC = 0x1
	// No action
	CACHE_CCAFCT_FC_0 = 0x0
	// C-cache line flush (all lines invalidated)
	CACHE_CCAFCT_FC_1 = 0x1

	// CCALCF: C-Cache Line Configuration Register
	// Position of CC field.
	CACHE_CCALCF_CC_Pos = 0x0
	// Bit mask of CC field.
	CACHE_CCALCF_CC_Msk = 0x3
	// Prohibited
	CACHE_CCALCF_CC_00 = 0x0
	// Cache line size 32 bytes
	CACHE_CCALCF_CC_01 = 0x1
	// Cache line size 64 bytes
	CACHE_CCALCF_CC_10 = 0x2
	// Prohibited
	CACHE_CCALCF_CC_11 = 0x3

	// SCACTL: S-Cache Control Register
	// Position of ENS field.
	CACHE_SCACTL_ENS_Pos = 0x0
	// Bit mask of ENS field.
	CACHE_SCACTL_ENS_Msk = 0x1
	// Bit ENS.
	CACHE_SCACTL_ENS = 0x1
	// Disable S-cache
	CACHE_SCACTL_ENS_0 = 0x0
	// Enable S-cache
	CACHE_SCACTL_ENS_1 = 0x1

	// SCAFCT: S-Cache Flush Control Register
	// Position of FS field.
	CACHE_SCAFCT_FS_Pos = 0x0
	// Bit mask of FS field.
	CACHE_SCAFCT_FS_Msk = 0x1
	// Bit FS.
	CACHE_SCAFCT_FS = 0x1
	// No action
	CACHE_SCAFCT_FS_0 = 0x0
	// S-cache line flush (all lines invalidated)
	CACHE_SCAFCT_FS_1 = 0x1

	// SCALCF: S-Cache Line Configuration Register
	// Position of CS field.
	CACHE_SCALCF_CS_Pos = 0x0
	// Bit mask of CS field.
	CACHE_SCALCF_CS_Msk = 0x3
	// Prohibited
	CACHE_SCALCF_CS_00 = 0x0
	// Cache line size 32 bytes
	CACHE_SCALCF_CS_01 = 0x1
	// Cache line size 64 bytes
	CACHE_SCALCF_CS_10 = 0x2
	// Prohibited
	CACHE_SCALCF_CS_11 = 0x3

	// CAPOAD: Cache Parity Error Operation After Detection Register
	// Position of OAD field.
	CACHE_CAPOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	CACHE_CAPOAD_OAD_Msk = 0x1
	// Bit OAD.
	CACHE_CAPOAD_OAD = 0x1
	// Non-maskable interrupt
	CACHE_CAPOAD_OAD_0 = 0x0
	// Reset
	CACHE_CAPOAD_OAD_1 = 0x1

	// CAPRCR: Cache Protection Register
	// Position of PRCR field.
	CACHE_CAPRCR_PRCR_Pos = 0x0
	// Bit mask of PRCR field.
	CACHE_CAPRCR_PRCR_Msk = 0x1
	// Bit PRCR.
	CACHE_CAPRCR_PRCR = 0x1
	// Disable writes to protected registers
	CACHE_CAPRCR_PRCR_0 = 0x0
	// Enable writes to protected registers
	CACHE_CAPRCR_PRCR_1 = 0x1
	// Position of KW field.
	CACHE_CAPRCR_KW_Pos = 0x1
	// Bit mask of KW field.
	CACHE_CAPRCR_KW_Msk = 0xfe
)

// Constants for CPSCU: CPU System Security Control Unit
const (
	// CSAR: Cache Security Attribution Register
	// Position of CACHESA field.
	CPSCU_CSAR_CACHESA_Pos = 0x0
	// Bit mask of CACHESA field.
	CPSCU_CSAR_CACHESA_Msk = 0x1
	// Bit CACHESA.
	CPSCU_CSAR_CACHESA = 0x1
	// Secure
	CPSCU_CSAR_CACHESA_0 = 0x0
	// Non-secure
	CPSCU_CSAR_CACHESA_1 = 0x1
	// Position of CACHELSA field.
	CPSCU_CSAR_CACHELSA_Pos = 0x1
	// Bit mask of CACHELSA field.
	CPSCU_CSAR_CACHELSA_Msk = 0x2
	// Bit CACHELSA.
	CPSCU_CSAR_CACHELSA = 0x2
	// Secure
	CPSCU_CSAR_CACHELSA_0 = 0x0
	// Non-secure
	CPSCU_CSAR_CACHELSA_1 = 0x1
	// Position of CACHEESA field.
	CPSCU_CSAR_CACHEESA_Pos = 0x2
	// Bit mask of CACHEESA field.
	CPSCU_CSAR_CACHEESA_Msk = 0x4
	// Bit CACHEESA.
	CPSCU_CSAR_CACHEESA = 0x4
	// Secure
	CPSCU_CSAR_CACHEESA_0 = 0x0
	// Non-secure
	CPSCU_CSAR_CACHEESA_1 = 0x1

	// SRAMSAR: SRAM Security Attribution Register
	// Position of SRAMSA0 field.
	CPSCU_SRAMSAR_SRAMSA0_Pos = 0x0
	// Bit mask of SRAMSA0 field.
	CPSCU_SRAMSAR_SRAMSA0_Msk = 0x1
	// Bit SRAMSA0.
	CPSCU_SRAMSAR_SRAMSA0 = 0x1
	// Secure
	CPSCU_SRAMSAR_SRAMSA0_0 = 0x0
	// Non-Secure
	CPSCU_SRAMSAR_SRAMSA0_1 = 0x1
	// Position of SRAMSA1 field.
	CPSCU_SRAMSAR_SRAMSA1_Pos = 0x1
	// Bit mask of SRAMSA1 field.
	CPSCU_SRAMSAR_SRAMSA1_Msk = 0x2
	// Bit SRAMSA1.
	CPSCU_SRAMSAR_SRAMSA1 = 0x2
	// Secure
	CPSCU_SRAMSAR_SRAMSA1_0 = 0x0
	// Non-Secure
	CPSCU_SRAMSAR_SRAMSA1_1 = 0x1

	// STBRAMSAR: Standby RAM memory Security Attribution Register
	// Position of NSBSTBR field.
	CPSCU_STBRAMSAR_NSBSTBR_Pos = 0x0
	// Bit mask of NSBSTBR field.
	CPSCU_STBRAMSAR_NSBSTBR_Msk = 0xf
	// Region7-0 are all Secure.
	CPSCU_STBRAMSAR_NSBSTBR_0x0 = 0x0
	// Region7 is Non-secure. Region6-0 are Secure
	CPSCU_STBRAMSAR_NSBSTBR_0x1 = 0x1
	// Region7-6 are Non-secure. Region5-0 are Secure.
	CPSCU_STBRAMSAR_NSBSTBR_0x2 = 0x2
	// Region7-5 are Non-secure. Region4-0 are Secure.
	CPSCU_STBRAMSAR_NSBSTBR_0x3 = 0x3
	// Region7-4 are Non-secure. Region 3-0 are Secure.
	CPSCU_STBRAMSAR_NSBSTBR_0x4 = 0x4
	// Region7-3 are Non-secure. Region 2-0 are Secure.
	CPSCU_STBRAMSAR_NSBSTBR_0x5 = 0x5
	// Region7-2 are Non-secure. Region 1-0 are Secure.
	CPSCU_STBRAMSAR_NSBSTBR_0x6 = 0x6
	// Region7-1 are Non-Secure. Region0 is Secure.
	CPSCU_STBRAMSAR_NSBSTBR_0x7 = 0x7

	// DTCSAR: DTC Controller Security Attribution Register
	// Position of DTCSTSA field.
	CPSCU_DTCSAR_DTCSTSA_Pos = 0x0
	// Bit mask of DTCSTSA field.
	CPSCU_DTCSAR_DTCSTSA_Msk = 0x1
	// Bit DTCSTSA.
	CPSCU_DTCSAR_DTCSTSA = 0x1
	// Secure.
	CPSCU_DTCSAR_DTCSTSA_0 = 0x0
	// Non-Secure.
	CPSCU_DTCSAR_DTCSTSA_1 = 0x1

	// DMACSAR: DMAC Controller Security Attribution Register
	// Position of DMASTSA field.
	CPSCU_DMACSAR_DMASTSA_Pos = 0x0
	// Bit mask of DMASTSA field.
	CPSCU_DMACSAR_DMASTSA_Msk = 0x1
	// Bit DMASTSA.
	CPSCU_DMACSAR_DMASTSA = 0x1
	// Secure
	CPSCU_DMACSAR_DMASTSA_0 = 0x0
	// Non-secure
	CPSCU_DMACSAR_DMASTSA_1 = 0x1

	// ICUSARA: Interrupt Controller Unit Security Attribution Register A
	// Position of SAIRQCR00 field.
	CPSCU_ICUSARA_SAIRQCR00_Pos = 0x0
	// Bit mask of SAIRQCR00 field.
	CPSCU_ICUSARA_SAIRQCR00_Msk = 0x1
	// Bit SAIRQCR00.
	CPSCU_ICUSARA_SAIRQCR00 = 0x1
	// Secure
	CPSCU_ICUSARA_SAIRQCR00_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR00_1 = 0x1
	// Position of SAIRQCR01 field.
	CPSCU_ICUSARA_SAIRQCR01_Pos = 0x1
	// Bit mask of SAIRQCR01 field.
	CPSCU_ICUSARA_SAIRQCR01_Msk = 0x2
	// Bit SAIRQCR01.
	CPSCU_ICUSARA_SAIRQCR01 = 0x2
	// Secure
	CPSCU_ICUSARA_SAIRQCR01_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR01_1 = 0x1
	// Position of SAIRQCR02 field.
	CPSCU_ICUSARA_SAIRQCR02_Pos = 0x2
	// Bit mask of SAIRQCR02 field.
	CPSCU_ICUSARA_SAIRQCR02_Msk = 0x4
	// Bit SAIRQCR02.
	CPSCU_ICUSARA_SAIRQCR02 = 0x4
	// Secure
	CPSCU_ICUSARA_SAIRQCR02_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR02_1 = 0x1
	// Position of SAIRQCR03 field.
	CPSCU_ICUSARA_SAIRQCR03_Pos = 0x3
	// Bit mask of SAIRQCR03 field.
	CPSCU_ICUSARA_SAIRQCR03_Msk = 0x8
	// Bit SAIRQCR03.
	CPSCU_ICUSARA_SAIRQCR03 = 0x8
	// Secure
	CPSCU_ICUSARA_SAIRQCR03_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR03_1 = 0x1
	// Position of SAIRQCR04 field.
	CPSCU_ICUSARA_SAIRQCR04_Pos = 0x4
	// Bit mask of SAIRQCR04 field.
	CPSCU_ICUSARA_SAIRQCR04_Msk = 0x10
	// Bit SAIRQCR04.
	CPSCU_ICUSARA_SAIRQCR04 = 0x10
	// Secure
	CPSCU_ICUSARA_SAIRQCR04_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR04_1 = 0x1
	// Position of SAIRQCR05 field.
	CPSCU_ICUSARA_SAIRQCR05_Pos = 0x5
	// Bit mask of SAIRQCR05 field.
	CPSCU_ICUSARA_SAIRQCR05_Msk = 0x20
	// Bit SAIRQCR05.
	CPSCU_ICUSARA_SAIRQCR05 = 0x20
	// Secure
	CPSCU_ICUSARA_SAIRQCR05_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR05_1 = 0x1
	// Position of SAIRQCR06 field.
	CPSCU_ICUSARA_SAIRQCR06_Pos = 0x6
	// Bit mask of SAIRQCR06 field.
	CPSCU_ICUSARA_SAIRQCR06_Msk = 0x40
	// Bit SAIRQCR06.
	CPSCU_ICUSARA_SAIRQCR06 = 0x40
	// Secure
	CPSCU_ICUSARA_SAIRQCR06_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR06_1 = 0x1
	// Position of SAIRQCR07 field.
	CPSCU_ICUSARA_SAIRQCR07_Pos = 0x7
	// Bit mask of SAIRQCR07 field.
	CPSCU_ICUSARA_SAIRQCR07_Msk = 0x80
	// Bit SAIRQCR07.
	CPSCU_ICUSARA_SAIRQCR07 = 0x80
	// Secure
	CPSCU_ICUSARA_SAIRQCR07_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR07_1 = 0x1
	// Position of SAIRQCR08 field.
	CPSCU_ICUSARA_SAIRQCR08_Pos = 0x8
	// Bit mask of SAIRQCR08 field.
	CPSCU_ICUSARA_SAIRQCR08_Msk = 0x100
	// Bit SAIRQCR08.
	CPSCU_ICUSARA_SAIRQCR08 = 0x100
	// Secure
	CPSCU_ICUSARA_SAIRQCR08_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR08_1 = 0x1
	// Position of SAIRQCR09 field.
	CPSCU_ICUSARA_SAIRQCR09_Pos = 0x9
	// Bit mask of SAIRQCR09 field.
	CPSCU_ICUSARA_SAIRQCR09_Msk = 0x200
	// Bit SAIRQCR09.
	CPSCU_ICUSARA_SAIRQCR09 = 0x200
	// Secure
	CPSCU_ICUSARA_SAIRQCR09_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR09_1 = 0x1
	// Position of SAIRQCR10 field.
	CPSCU_ICUSARA_SAIRQCR10_Pos = 0xa
	// Bit mask of SAIRQCR10 field.
	CPSCU_ICUSARA_SAIRQCR10_Msk = 0x400
	// Bit SAIRQCR10.
	CPSCU_ICUSARA_SAIRQCR10 = 0x400
	// Secure
	CPSCU_ICUSARA_SAIRQCR10_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR10_1 = 0x1
	// Position of SAIRQCR11 field.
	CPSCU_ICUSARA_SAIRQCR11_Pos = 0xb
	// Bit mask of SAIRQCR11 field.
	CPSCU_ICUSARA_SAIRQCR11_Msk = 0x800
	// Bit SAIRQCR11.
	CPSCU_ICUSARA_SAIRQCR11 = 0x800
	// Secure
	CPSCU_ICUSARA_SAIRQCR11_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR11_1 = 0x1
	// Position of SAIRQCR12 field.
	CPSCU_ICUSARA_SAIRQCR12_Pos = 0xc
	// Bit mask of SAIRQCR12 field.
	CPSCU_ICUSARA_SAIRQCR12_Msk = 0x1000
	// Bit SAIRQCR12.
	CPSCU_ICUSARA_SAIRQCR12 = 0x1000
	// Secure
	CPSCU_ICUSARA_SAIRQCR12_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR12_1 = 0x1
	// Position of SAIRQCR13 field.
	CPSCU_ICUSARA_SAIRQCR13_Pos = 0xd
	// Bit mask of SAIRQCR13 field.
	CPSCU_ICUSARA_SAIRQCR13_Msk = 0x2000
	// Bit SAIRQCR13.
	CPSCU_ICUSARA_SAIRQCR13 = 0x2000
	// Secure
	CPSCU_ICUSARA_SAIRQCR13_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR13_1 = 0x1
	// Position of SAIRQCR14 field.
	CPSCU_ICUSARA_SAIRQCR14_Pos = 0xe
	// Bit mask of SAIRQCR14 field.
	CPSCU_ICUSARA_SAIRQCR14_Msk = 0x4000
	// Bit SAIRQCR14.
	CPSCU_ICUSARA_SAIRQCR14 = 0x4000
	// Secure
	CPSCU_ICUSARA_SAIRQCR14_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR14_1 = 0x1
	// Position of SAIRQCR15 field.
	CPSCU_ICUSARA_SAIRQCR15_Pos = 0xf
	// Bit mask of SAIRQCR15 field.
	CPSCU_ICUSARA_SAIRQCR15_Msk = 0x8000
	// Bit SAIRQCR15.
	CPSCU_ICUSARA_SAIRQCR15 = 0x8000
	// Secure
	CPSCU_ICUSARA_SAIRQCR15_0 = 0x0
	// Non-secure
	CPSCU_ICUSARA_SAIRQCR15_1 = 0x1

	// ICUSARB: Interrupt Controller Unit Security Attribution Register B
	// Position of SANMI field.
	CPSCU_ICUSARB_SANMI_Pos = 0x0
	// Bit mask of SANMI field.
	CPSCU_ICUSARB_SANMI_Msk = 0x1
	// Bit SANMI.
	CPSCU_ICUSARB_SANMI = 0x1
	// Secure
	CPSCU_ICUSARB_SANMI_0 = 0x0
	// Non-secure
	CPSCU_ICUSARB_SANMI_1 = 0x1

	// ICUSARC: Interrupt Controller Unit Security Attribution Register C
	// Position of SADMAC0 field.
	CPSCU_ICUSARC_SADMAC0_Pos = 0x0
	// Bit mask of SADMAC0 field.
	CPSCU_ICUSARC_SADMAC0_Msk = 0x1
	// Bit SADMAC0.
	CPSCU_ICUSARC_SADMAC0 = 0x1
	// Secure
	CPSCU_ICUSARC_SADMAC0_0 = 0x0
	// Non-secure
	CPSCU_ICUSARC_SADMAC0_1 = 0x1
	// Position of SADMAC1 field.
	CPSCU_ICUSARC_SADMAC1_Pos = 0x1
	// Bit mask of SADMAC1 field.
	CPSCU_ICUSARC_SADMAC1_Msk = 0x2
	// Bit SADMAC1.
	CPSCU_ICUSARC_SADMAC1 = 0x2
	// Secure
	CPSCU_ICUSARC_SADMAC1_0 = 0x0
	// Non-secure
	CPSCU_ICUSARC_SADMAC1_1 = 0x1
	// Position of SADMAC2 field.
	CPSCU_ICUSARC_SADMAC2_Pos = 0x2
	// Bit mask of SADMAC2 field.
	CPSCU_ICUSARC_SADMAC2_Msk = 0x4
	// Bit SADMAC2.
	CPSCU_ICUSARC_SADMAC2 = 0x4
	// Secure
	CPSCU_ICUSARC_SADMAC2_0 = 0x0
	// Non-secure
	CPSCU_ICUSARC_SADMAC2_1 = 0x1
	// Position of SADMAC3 field.
	CPSCU_ICUSARC_SADMAC3_Pos = 0x3
	// Bit mask of SADMAC3 field.
	CPSCU_ICUSARC_SADMAC3_Msk = 0x8
	// Bit SADMAC3.
	CPSCU_ICUSARC_SADMAC3 = 0x8
	// Secure
	CPSCU_ICUSARC_SADMAC3_0 = 0x0
	// Non-secure
	CPSCU_ICUSARC_SADMAC3_1 = 0x1
	// Position of SADMAC4 field.
	CPSCU_ICUSARC_SADMAC4_Pos = 0x4
	// Bit mask of SADMAC4 field.
	CPSCU_ICUSARC_SADMAC4_Msk = 0x10
	// Bit SADMAC4.
	CPSCU_ICUSARC_SADMAC4 = 0x10
	// Secure
	CPSCU_ICUSARC_SADMAC4_0 = 0x0
	// Non-secure
	CPSCU_ICUSARC_SADMAC4_1 = 0x1
	// Position of SADMAC5 field.
	CPSCU_ICUSARC_SADMAC5_Pos = 0x5
	// Bit mask of SADMAC5 field.
	CPSCU_ICUSARC_SADMAC5_Msk = 0x20
	// Bit SADMAC5.
	CPSCU_ICUSARC_SADMAC5 = 0x20
	// Secure
	CPSCU_ICUSARC_SADMAC5_0 = 0x0
	// Non-secure
	CPSCU_ICUSARC_SADMAC5_1 = 0x1
	// Position of SADMAC6 field.
	CPSCU_ICUSARC_SADMAC6_Pos = 0x6
	// Bit mask of SADMAC6 field.
	CPSCU_ICUSARC_SADMAC6_Msk = 0x40
	// Bit SADMAC6.
	CPSCU_ICUSARC_SADMAC6 = 0x40
	// Secure
	CPSCU_ICUSARC_SADMAC6_0 = 0x0
	// Non-secure
	CPSCU_ICUSARC_SADMAC6_1 = 0x1
	// Position of SADMAC7 field.
	CPSCU_ICUSARC_SADMAC7_Pos = 0x7
	// Bit mask of SADMAC7 field.
	CPSCU_ICUSARC_SADMAC7_Msk = 0x80
	// Bit SADMAC7.
	CPSCU_ICUSARC_SADMAC7 = 0x80
	// Secure
	CPSCU_ICUSARC_SADMAC7_0 = 0x0
	// Non-secure
	CPSCU_ICUSARC_SADMAC7_1 = 0x1

	// ICUSARD: Interrupt Controller Unit Security Attribution Register D
	// Position of SASELSR0 field.
	CPSCU_ICUSARD_SASELSR0_Pos = 0x0
	// Bit mask of SASELSR0 field.
	CPSCU_ICUSARD_SASELSR0_Msk = 0x1
	// Bit SASELSR0.
	CPSCU_ICUSARD_SASELSR0 = 0x1
	// Secure
	CPSCU_ICUSARD_SASELSR0_0 = 0x0
	// Non-secure
	CPSCU_ICUSARD_SASELSR0_1 = 0x1

	// ICUSARF: Interrupt Controller Unit Security Attribution Register F
	// Position of SAAGT3UDWUP field.
	CPSCU_ICUSARF_SAAGT3UDWUP_Pos = 0x0
	// Bit mask of SAAGT3UDWUP field.
	CPSCU_ICUSARF_SAAGT3UDWUP_Msk = 0x1
	// Bit SAAGT3UDWUP.
	CPSCU_ICUSARF_SAAGT3UDWUP = 0x1
	// Secure
	CPSCU_ICUSARF_SAAGT3UDWUP_0 = 0x0
	// Non-secure
	CPSCU_ICUSARF_SAAGT3UDWUP_1 = 0x1
	// Position of SAAGT3CAWUP field.
	CPSCU_ICUSARF_SAAGT3CAWUP_Pos = 0x1
	// Bit mask of SAAGT3CAWUP field.
	CPSCU_ICUSARF_SAAGT3CAWUP_Msk = 0x2
	// Bit SAAGT3CAWUP.
	CPSCU_ICUSARF_SAAGT3CAWUP = 0x2
	// Secure
	CPSCU_ICUSARF_SAAGT3CAWUP_0 = 0x0
	// Non-secure
	CPSCU_ICUSARF_SAAGT3CAWUP_1 = 0x1
	// Position of SAAGT3CBWUP field.
	CPSCU_ICUSARF_SAAGT3CBWUP_Pos = 0x2
	// Bit mask of SAAGT3CBWUP field.
	CPSCU_ICUSARF_SAAGT3CBWUP_Msk = 0x4
	// Bit SAAGT3CBWUP.
	CPSCU_ICUSARF_SAAGT3CBWUP = 0x4
	// Secure
	CPSCU_ICUSARF_SAAGT3CBWUP_0 = 0x0
	// Non-secure
	CPSCU_ICUSARF_SAAGT3CBWUP_1 = 0x1

	// ICUSARG: Interrupt Controller Unit Security Attribution Register G
	// Position of SAIELSR00 field.
	CPSCU_ICUSARG_SAIELSR00_Pos = 0x0
	// Bit mask of SAIELSR00 field.
	CPSCU_ICUSARG_SAIELSR00_Msk = 0x1
	// Bit SAIELSR00.
	CPSCU_ICUSARG_SAIELSR00 = 0x1
	// Secure
	CPSCU_ICUSARG_SAIELSR00_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR00_1 = 0x1
	// Position of SAIELSR01 field.
	CPSCU_ICUSARG_SAIELSR01_Pos = 0x1
	// Bit mask of SAIELSR01 field.
	CPSCU_ICUSARG_SAIELSR01_Msk = 0x2
	// Bit SAIELSR01.
	CPSCU_ICUSARG_SAIELSR01 = 0x2
	// Secure
	CPSCU_ICUSARG_SAIELSR01_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR01_1 = 0x1
	// Position of SAIELSR02 field.
	CPSCU_ICUSARG_SAIELSR02_Pos = 0x2
	// Bit mask of SAIELSR02 field.
	CPSCU_ICUSARG_SAIELSR02_Msk = 0x4
	// Bit SAIELSR02.
	CPSCU_ICUSARG_SAIELSR02 = 0x4
	// Secure
	CPSCU_ICUSARG_SAIELSR02_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR02_1 = 0x1
	// Position of SAIELSR03 field.
	CPSCU_ICUSARG_SAIELSR03_Pos = 0x3
	// Bit mask of SAIELSR03 field.
	CPSCU_ICUSARG_SAIELSR03_Msk = 0x8
	// Bit SAIELSR03.
	CPSCU_ICUSARG_SAIELSR03 = 0x8
	// Secure
	CPSCU_ICUSARG_SAIELSR03_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR03_1 = 0x1
	// Position of SAIELSR04 field.
	CPSCU_ICUSARG_SAIELSR04_Pos = 0x4
	// Bit mask of SAIELSR04 field.
	CPSCU_ICUSARG_SAIELSR04_Msk = 0x10
	// Bit SAIELSR04.
	CPSCU_ICUSARG_SAIELSR04 = 0x10
	// Secure
	CPSCU_ICUSARG_SAIELSR04_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR04_1 = 0x1
	// Position of SAIELSR05 field.
	CPSCU_ICUSARG_SAIELSR05_Pos = 0x5
	// Bit mask of SAIELSR05 field.
	CPSCU_ICUSARG_SAIELSR05_Msk = 0x20
	// Bit SAIELSR05.
	CPSCU_ICUSARG_SAIELSR05 = 0x20
	// Secure
	CPSCU_ICUSARG_SAIELSR05_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR05_1 = 0x1
	// Position of SAIELSR06 field.
	CPSCU_ICUSARG_SAIELSR06_Pos = 0x6
	// Bit mask of SAIELSR06 field.
	CPSCU_ICUSARG_SAIELSR06_Msk = 0x40
	// Bit SAIELSR06.
	CPSCU_ICUSARG_SAIELSR06 = 0x40
	// Secure
	CPSCU_ICUSARG_SAIELSR06_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR06_1 = 0x1
	// Position of SAIELSR07 field.
	CPSCU_ICUSARG_SAIELSR07_Pos = 0x7
	// Bit mask of SAIELSR07 field.
	CPSCU_ICUSARG_SAIELSR07_Msk = 0x80
	// Bit SAIELSR07.
	CPSCU_ICUSARG_SAIELSR07 = 0x80
	// Secure
	CPSCU_ICUSARG_SAIELSR07_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR07_1 = 0x1
	// Position of SAIELSR08 field.
	CPSCU_ICUSARG_SAIELSR08_Pos = 0x8
	// Bit mask of SAIELSR08 field.
	CPSCU_ICUSARG_SAIELSR08_Msk = 0x100
	// Bit SAIELSR08.
	CPSCU_ICUSARG_SAIELSR08 = 0x100
	// Secure
	CPSCU_ICUSARG_SAIELSR08_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR08_1 = 0x1
	// Position of SAIELSR09 field.
	CPSCU_ICUSARG_SAIELSR09_Pos = 0x9
	// Bit mask of SAIELSR09 field.
	CPSCU_ICUSARG_SAIELSR09_Msk = 0x200
	// Bit SAIELSR09.
	CPSCU_ICUSARG_SAIELSR09 = 0x200
	// Secure
	CPSCU_ICUSARG_SAIELSR09_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR09_1 = 0x1
	// Position of SAIELSR10 field.
	CPSCU_ICUSARG_SAIELSR10_Pos = 0xa
	// Bit mask of SAIELSR10 field.
	CPSCU_ICUSARG_SAIELSR10_Msk = 0x400
	// Bit SAIELSR10.
	CPSCU_ICUSARG_SAIELSR10 = 0x400
	// Secure
	CPSCU_ICUSARG_SAIELSR10_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR10_1 = 0x1
	// Position of SAIELSR11 field.
	CPSCU_ICUSARG_SAIELSR11_Pos = 0xb
	// Bit mask of SAIELSR11 field.
	CPSCU_ICUSARG_SAIELSR11_Msk = 0x800
	// Bit SAIELSR11.
	CPSCU_ICUSARG_SAIELSR11 = 0x800
	// Secure
	CPSCU_ICUSARG_SAIELSR11_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR11_1 = 0x1
	// Position of SAIELSR12 field.
	CPSCU_ICUSARG_SAIELSR12_Pos = 0xc
	// Bit mask of SAIELSR12 field.
	CPSCU_ICUSARG_SAIELSR12_Msk = 0x1000
	// Bit SAIELSR12.
	CPSCU_ICUSARG_SAIELSR12 = 0x1000
	// Secure
	CPSCU_ICUSARG_SAIELSR12_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR12_1 = 0x1
	// Position of SAIELSR13 field.
	CPSCU_ICUSARG_SAIELSR13_Pos = 0xd
	// Bit mask of SAIELSR13 field.
	CPSCU_ICUSARG_SAIELSR13_Msk = 0x2000
	// Bit SAIELSR13.
	CPSCU_ICUSARG_SAIELSR13 = 0x2000
	// Secure
	CPSCU_ICUSARG_SAIELSR13_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR13_1 = 0x1
	// Position of SAIELSR14 field.
	CPSCU_ICUSARG_SAIELSR14_Pos = 0xe
	// Bit mask of SAIELSR14 field.
	CPSCU_ICUSARG_SAIELSR14_Msk = 0x4000
	// Bit SAIELSR14.
	CPSCU_ICUSARG_SAIELSR14 = 0x4000
	// Secure
	CPSCU_ICUSARG_SAIELSR14_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR14_1 = 0x1
	// Position of SAIELSR15 field.
	CPSCU_ICUSARG_SAIELSR15_Pos = 0xf
	// Bit mask of SAIELSR15 field.
	CPSCU_ICUSARG_SAIELSR15_Msk = 0x8000
	// Bit SAIELSR15.
	CPSCU_ICUSARG_SAIELSR15 = 0x8000
	// Secure
	CPSCU_ICUSARG_SAIELSR15_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR15_1 = 0x1
	// Position of SAIELSR16 field.
	CPSCU_ICUSARG_SAIELSR16_Pos = 0x10
	// Bit mask of SAIELSR16 field.
	CPSCU_ICUSARG_SAIELSR16_Msk = 0x10000
	// Bit SAIELSR16.
	CPSCU_ICUSARG_SAIELSR16 = 0x10000
	// Secure
	CPSCU_ICUSARG_SAIELSR16_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR16_1 = 0x1
	// Position of SAIELSR17 field.
	CPSCU_ICUSARG_SAIELSR17_Pos = 0x11
	// Bit mask of SAIELSR17 field.
	CPSCU_ICUSARG_SAIELSR17_Msk = 0x20000
	// Bit SAIELSR17.
	CPSCU_ICUSARG_SAIELSR17 = 0x20000
	// Secure
	CPSCU_ICUSARG_SAIELSR17_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR17_1 = 0x1
	// Position of SAIELSR18 field.
	CPSCU_ICUSARG_SAIELSR18_Pos = 0x12
	// Bit mask of SAIELSR18 field.
	CPSCU_ICUSARG_SAIELSR18_Msk = 0x40000
	// Bit SAIELSR18.
	CPSCU_ICUSARG_SAIELSR18 = 0x40000
	// Secure
	CPSCU_ICUSARG_SAIELSR18_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR18_1 = 0x1
	// Position of SAIELSR19 field.
	CPSCU_ICUSARG_SAIELSR19_Pos = 0x13
	// Bit mask of SAIELSR19 field.
	CPSCU_ICUSARG_SAIELSR19_Msk = 0x80000
	// Bit SAIELSR19.
	CPSCU_ICUSARG_SAIELSR19 = 0x80000
	// Secure
	CPSCU_ICUSARG_SAIELSR19_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR19_1 = 0x1
	// Position of SAIELSR20 field.
	CPSCU_ICUSARG_SAIELSR20_Pos = 0x14
	// Bit mask of SAIELSR20 field.
	CPSCU_ICUSARG_SAIELSR20_Msk = 0x100000
	// Bit SAIELSR20.
	CPSCU_ICUSARG_SAIELSR20 = 0x100000
	// Secure
	CPSCU_ICUSARG_SAIELSR20_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR20_1 = 0x1
	// Position of SAIELSR21 field.
	CPSCU_ICUSARG_SAIELSR21_Pos = 0x15
	// Bit mask of SAIELSR21 field.
	CPSCU_ICUSARG_SAIELSR21_Msk = 0x200000
	// Bit SAIELSR21.
	CPSCU_ICUSARG_SAIELSR21 = 0x200000
	// Secure
	CPSCU_ICUSARG_SAIELSR21_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR21_1 = 0x1
	// Position of SAIELSR22 field.
	CPSCU_ICUSARG_SAIELSR22_Pos = 0x16
	// Bit mask of SAIELSR22 field.
	CPSCU_ICUSARG_SAIELSR22_Msk = 0x400000
	// Bit SAIELSR22.
	CPSCU_ICUSARG_SAIELSR22 = 0x400000
	// Secure
	CPSCU_ICUSARG_SAIELSR22_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR22_1 = 0x1
	// Position of SAIELSR23 field.
	CPSCU_ICUSARG_SAIELSR23_Pos = 0x17
	// Bit mask of SAIELSR23 field.
	CPSCU_ICUSARG_SAIELSR23_Msk = 0x800000
	// Bit SAIELSR23.
	CPSCU_ICUSARG_SAIELSR23 = 0x800000
	// Secure
	CPSCU_ICUSARG_SAIELSR23_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR23_1 = 0x1
	// Position of SAIELSR24 field.
	CPSCU_ICUSARG_SAIELSR24_Pos = 0x18
	// Bit mask of SAIELSR24 field.
	CPSCU_ICUSARG_SAIELSR24_Msk = 0x1000000
	// Bit SAIELSR24.
	CPSCU_ICUSARG_SAIELSR24 = 0x1000000
	// Secure
	CPSCU_ICUSARG_SAIELSR24_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR24_1 = 0x1
	// Position of SAIELSR25 field.
	CPSCU_ICUSARG_SAIELSR25_Pos = 0x19
	// Bit mask of SAIELSR25 field.
	CPSCU_ICUSARG_SAIELSR25_Msk = 0x2000000
	// Bit SAIELSR25.
	CPSCU_ICUSARG_SAIELSR25 = 0x2000000
	// Secure
	CPSCU_ICUSARG_SAIELSR25_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR25_1 = 0x1
	// Position of SAIELSR26 field.
	CPSCU_ICUSARG_SAIELSR26_Pos = 0x1a
	// Bit mask of SAIELSR26 field.
	CPSCU_ICUSARG_SAIELSR26_Msk = 0x4000000
	// Bit SAIELSR26.
	CPSCU_ICUSARG_SAIELSR26 = 0x4000000
	// Secure
	CPSCU_ICUSARG_SAIELSR26_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR26_1 = 0x1
	// Position of SAIELSR27 field.
	CPSCU_ICUSARG_SAIELSR27_Pos = 0x1b
	// Bit mask of SAIELSR27 field.
	CPSCU_ICUSARG_SAIELSR27_Msk = 0x8000000
	// Bit SAIELSR27.
	CPSCU_ICUSARG_SAIELSR27 = 0x8000000
	// Secure
	CPSCU_ICUSARG_SAIELSR27_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR27_1 = 0x1
	// Position of SAIELSR28 field.
	CPSCU_ICUSARG_SAIELSR28_Pos = 0x1c
	// Bit mask of SAIELSR28 field.
	CPSCU_ICUSARG_SAIELSR28_Msk = 0x10000000
	// Bit SAIELSR28.
	CPSCU_ICUSARG_SAIELSR28 = 0x10000000
	// Secure
	CPSCU_ICUSARG_SAIELSR28_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR28_1 = 0x1
	// Position of SAIELSR29 field.
	CPSCU_ICUSARG_SAIELSR29_Pos = 0x1d
	// Bit mask of SAIELSR29 field.
	CPSCU_ICUSARG_SAIELSR29_Msk = 0x20000000
	// Bit SAIELSR29.
	CPSCU_ICUSARG_SAIELSR29 = 0x20000000
	// Secure
	CPSCU_ICUSARG_SAIELSR29_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR29_1 = 0x1
	// Position of SAIELSR30 field.
	CPSCU_ICUSARG_SAIELSR30_Pos = 0x1e
	// Bit mask of SAIELSR30 field.
	CPSCU_ICUSARG_SAIELSR30_Msk = 0x40000000
	// Bit SAIELSR30.
	CPSCU_ICUSARG_SAIELSR30 = 0x40000000
	// Secure
	CPSCU_ICUSARG_SAIELSR30_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR30_1 = 0x1
	// Position of SAIELSR31 field.
	CPSCU_ICUSARG_SAIELSR31_Pos = 0x1f
	// Bit mask of SAIELSR31 field.
	CPSCU_ICUSARG_SAIELSR31_Msk = 0x80000000
	// Bit SAIELSR31.
	CPSCU_ICUSARG_SAIELSR31 = 0x80000000
	// Secure
	CPSCU_ICUSARG_SAIELSR31_0 = 0x0
	// Non-secure
	CPSCU_ICUSARG_SAIELSR31_1 = 0x1

	// ICUSARH: Interrupt Controller Unit Security Attribution Register H
	// Position of SAIELSR32 field.
	CPSCU_ICUSARH_SAIELSR32_Pos = 0x0
	// Bit mask of SAIELSR32 field.
	CPSCU_ICUSARH_SAIELSR32_Msk = 0x1
	// Bit SAIELSR32.
	CPSCU_ICUSARH_SAIELSR32 = 0x1
	// Secure
	CPSCU_ICUSARH_SAIELSR32_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR32_1 = 0x1
	// Position of SAIELSR33 field.
	CPSCU_ICUSARH_SAIELSR33_Pos = 0x1
	// Bit mask of SAIELSR33 field.
	CPSCU_ICUSARH_SAIELSR33_Msk = 0x2
	// Bit SAIELSR33.
	CPSCU_ICUSARH_SAIELSR33 = 0x2
	// Secure
	CPSCU_ICUSARH_SAIELSR33_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR33_1 = 0x1
	// Position of SAIELSR34 field.
	CPSCU_ICUSARH_SAIELSR34_Pos = 0x2
	// Bit mask of SAIELSR34 field.
	CPSCU_ICUSARH_SAIELSR34_Msk = 0x4
	// Bit SAIELSR34.
	CPSCU_ICUSARH_SAIELSR34 = 0x4
	// Secure
	CPSCU_ICUSARH_SAIELSR34_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR34_1 = 0x1
	// Position of SAIELSR35 field.
	CPSCU_ICUSARH_SAIELSR35_Pos = 0x3
	// Bit mask of SAIELSR35 field.
	CPSCU_ICUSARH_SAIELSR35_Msk = 0x8
	// Bit SAIELSR35.
	CPSCU_ICUSARH_SAIELSR35 = 0x8
	// Secure
	CPSCU_ICUSARH_SAIELSR35_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR35_1 = 0x1
	// Position of SAIELSR36 field.
	CPSCU_ICUSARH_SAIELSR36_Pos = 0x4
	// Bit mask of SAIELSR36 field.
	CPSCU_ICUSARH_SAIELSR36_Msk = 0x10
	// Bit SAIELSR36.
	CPSCU_ICUSARH_SAIELSR36 = 0x10
	// Secure
	CPSCU_ICUSARH_SAIELSR36_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR36_1 = 0x1
	// Position of SAIELSR37 field.
	CPSCU_ICUSARH_SAIELSR37_Pos = 0x5
	// Bit mask of SAIELSR37 field.
	CPSCU_ICUSARH_SAIELSR37_Msk = 0x20
	// Bit SAIELSR37.
	CPSCU_ICUSARH_SAIELSR37 = 0x20
	// Secure
	CPSCU_ICUSARH_SAIELSR37_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR37_1 = 0x1
	// Position of SAIELSR38 field.
	CPSCU_ICUSARH_SAIELSR38_Pos = 0x6
	// Bit mask of SAIELSR38 field.
	CPSCU_ICUSARH_SAIELSR38_Msk = 0x40
	// Bit SAIELSR38.
	CPSCU_ICUSARH_SAIELSR38 = 0x40
	// Secure
	CPSCU_ICUSARH_SAIELSR38_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR38_1 = 0x1
	// Position of SAIELSR39 field.
	CPSCU_ICUSARH_SAIELSR39_Pos = 0x7
	// Bit mask of SAIELSR39 field.
	CPSCU_ICUSARH_SAIELSR39_Msk = 0x80
	// Bit SAIELSR39.
	CPSCU_ICUSARH_SAIELSR39 = 0x80
	// Secure
	CPSCU_ICUSARH_SAIELSR39_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR39_1 = 0x1
	// Position of SAIELSR40 field.
	CPSCU_ICUSARH_SAIELSR40_Pos = 0x8
	// Bit mask of SAIELSR40 field.
	CPSCU_ICUSARH_SAIELSR40_Msk = 0x100
	// Bit SAIELSR40.
	CPSCU_ICUSARH_SAIELSR40 = 0x100
	// Secure
	CPSCU_ICUSARH_SAIELSR40_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR40_1 = 0x1
	// Position of SAIELSR41 field.
	CPSCU_ICUSARH_SAIELSR41_Pos = 0x9
	// Bit mask of SAIELSR41 field.
	CPSCU_ICUSARH_SAIELSR41_Msk = 0x200
	// Bit SAIELSR41.
	CPSCU_ICUSARH_SAIELSR41 = 0x200
	// Secure
	CPSCU_ICUSARH_SAIELSR41_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR41_1 = 0x1
	// Position of SAIELSR42 field.
	CPSCU_ICUSARH_SAIELSR42_Pos = 0xa
	// Bit mask of SAIELSR42 field.
	CPSCU_ICUSARH_SAIELSR42_Msk = 0x400
	// Bit SAIELSR42.
	CPSCU_ICUSARH_SAIELSR42 = 0x400
	// Secure
	CPSCU_ICUSARH_SAIELSR42_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR42_1 = 0x1
	// Position of SAIELSR43 field.
	CPSCU_ICUSARH_SAIELSR43_Pos = 0xb
	// Bit mask of SAIELSR43 field.
	CPSCU_ICUSARH_SAIELSR43_Msk = 0x800
	// Bit SAIELSR43.
	CPSCU_ICUSARH_SAIELSR43 = 0x800
	// Secure
	CPSCU_ICUSARH_SAIELSR43_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR43_1 = 0x1
	// Position of SAIELSR44 field.
	CPSCU_ICUSARH_SAIELSR44_Pos = 0xc
	// Bit mask of SAIELSR44 field.
	CPSCU_ICUSARH_SAIELSR44_Msk = 0x1000
	// Bit SAIELSR44.
	CPSCU_ICUSARH_SAIELSR44 = 0x1000
	// Secure
	CPSCU_ICUSARH_SAIELSR44_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR44_1 = 0x1
	// Position of SAIELSR45 field.
	CPSCU_ICUSARH_SAIELSR45_Pos = 0xd
	// Bit mask of SAIELSR45 field.
	CPSCU_ICUSARH_SAIELSR45_Msk = 0x2000
	// Bit SAIELSR45.
	CPSCU_ICUSARH_SAIELSR45 = 0x2000
	// Secure
	CPSCU_ICUSARH_SAIELSR45_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR45_1 = 0x1
	// Position of SAIELSR46 field.
	CPSCU_ICUSARH_SAIELSR46_Pos = 0xe
	// Bit mask of SAIELSR46 field.
	CPSCU_ICUSARH_SAIELSR46_Msk = 0x4000
	// Bit SAIELSR46.
	CPSCU_ICUSARH_SAIELSR46 = 0x4000
	// Secure
	CPSCU_ICUSARH_SAIELSR46_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR46_1 = 0x1
	// Position of SAIELSR47 field.
	CPSCU_ICUSARH_SAIELSR47_Pos = 0xf
	// Bit mask of SAIELSR47 field.
	CPSCU_ICUSARH_SAIELSR47_Msk = 0x8000
	// Bit SAIELSR47.
	CPSCU_ICUSARH_SAIELSR47 = 0x8000
	// Secure
	CPSCU_ICUSARH_SAIELSR47_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR47_1 = 0x1
	// Position of SAIELSR48 field.
	CPSCU_ICUSARH_SAIELSR48_Pos = 0x10
	// Bit mask of SAIELSR48 field.
	CPSCU_ICUSARH_SAIELSR48_Msk = 0x10000
	// Bit SAIELSR48.
	CPSCU_ICUSARH_SAIELSR48 = 0x10000
	// Secure
	CPSCU_ICUSARH_SAIELSR48_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR48_1 = 0x1
	// Position of SAIELSR49 field.
	CPSCU_ICUSARH_SAIELSR49_Pos = 0x11
	// Bit mask of SAIELSR49 field.
	CPSCU_ICUSARH_SAIELSR49_Msk = 0x20000
	// Bit SAIELSR49.
	CPSCU_ICUSARH_SAIELSR49 = 0x20000
	// Secure
	CPSCU_ICUSARH_SAIELSR49_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR49_1 = 0x1
	// Position of SAIELSR50 field.
	CPSCU_ICUSARH_SAIELSR50_Pos = 0x12
	// Bit mask of SAIELSR50 field.
	CPSCU_ICUSARH_SAIELSR50_Msk = 0x40000
	// Bit SAIELSR50.
	CPSCU_ICUSARH_SAIELSR50 = 0x40000
	// Secure
	CPSCU_ICUSARH_SAIELSR50_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR50_1 = 0x1
	// Position of SAIELSR51 field.
	CPSCU_ICUSARH_SAIELSR51_Pos = 0x13
	// Bit mask of SAIELSR51 field.
	CPSCU_ICUSARH_SAIELSR51_Msk = 0x80000
	// Bit SAIELSR51.
	CPSCU_ICUSARH_SAIELSR51 = 0x80000
	// Secure
	CPSCU_ICUSARH_SAIELSR51_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR51_1 = 0x1
	// Position of SAIELSR52 field.
	CPSCU_ICUSARH_SAIELSR52_Pos = 0x14
	// Bit mask of SAIELSR52 field.
	CPSCU_ICUSARH_SAIELSR52_Msk = 0x100000
	// Bit SAIELSR52.
	CPSCU_ICUSARH_SAIELSR52 = 0x100000
	// Secure
	CPSCU_ICUSARH_SAIELSR52_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR52_1 = 0x1
	// Position of SAIELSR53 field.
	CPSCU_ICUSARH_SAIELSR53_Pos = 0x15
	// Bit mask of SAIELSR53 field.
	CPSCU_ICUSARH_SAIELSR53_Msk = 0x200000
	// Bit SAIELSR53.
	CPSCU_ICUSARH_SAIELSR53 = 0x200000
	// Secure
	CPSCU_ICUSARH_SAIELSR53_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR53_1 = 0x1
	// Position of SAIELSR54 field.
	CPSCU_ICUSARH_SAIELSR54_Pos = 0x16
	// Bit mask of SAIELSR54 field.
	CPSCU_ICUSARH_SAIELSR54_Msk = 0x400000
	// Bit SAIELSR54.
	CPSCU_ICUSARH_SAIELSR54 = 0x400000
	// Secure
	CPSCU_ICUSARH_SAIELSR54_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR54_1 = 0x1
	// Position of SAIELSR55 field.
	CPSCU_ICUSARH_SAIELSR55_Pos = 0x17
	// Bit mask of SAIELSR55 field.
	CPSCU_ICUSARH_SAIELSR55_Msk = 0x800000
	// Bit SAIELSR55.
	CPSCU_ICUSARH_SAIELSR55 = 0x800000
	// Secure
	CPSCU_ICUSARH_SAIELSR55_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR55_1 = 0x1
	// Position of SAIELSR56 field.
	CPSCU_ICUSARH_SAIELSR56_Pos = 0x18
	// Bit mask of SAIELSR56 field.
	CPSCU_ICUSARH_SAIELSR56_Msk = 0x1000000
	// Bit SAIELSR56.
	CPSCU_ICUSARH_SAIELSR56 = 0x1000000
	// Secure
	CPSCU_ICUSARH_SAIELSR56_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR56_1 = 0x1
	// Position of SAIELSR57 field.
	CPSCU_ICUSARH_SAIELSR57_Pos = 0x19
	// Bit mask of SAIELSR57 field.
	CPSCU_ICUSARH_SAIELSR57_Msk = 0x2000000
	// Bit SAIELSR57.
	CPSCU_ICUSARH_SAIELSR57 = 0x2000000
	// Secure
	CPSCU_ICUSARH_SAIELSR57_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR57_1 = 0x1
	// Position of SAIELSR58 field.
	CPSCU_ICUSARH_SAIELSR58_Pos = 0x1a
	// Bit mask of SAIELSR58 field.
	CPSCU_ICUSARH_SAIELSR58_Msk = 0x4000000
	// Bit SAIELSR58.
	CPSCU_ICUSARH_SAIELSR58 = 0x4000000
	// Secure
	CPSCU_ICUSARH_SAIELSR58_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR58_1 = 0x1
	// Position of SAIELSR59 field.
	CPSCU_ICUSARH_SAIELSR59_Pos = 0x1b
	// Bit mask of SAIELSR59 field.
	CPSCU_ICUSARH_SAIELSR59_Msk = 0x8000000
	// Bit SAIELSR59.
	CPSCU_ICUSARH_SAIELSR59 = 0x8000000
	// Secure
	CPSCU_ICUSARH_SAIELSR59_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR59_1 = 0x1
	// Position of SAIELSR60 field.
	CPSCU_ICUSARH_SAIELSR60_Pos = 0x1c
	// Bit mask of SAIELSR60 field.
	CPSCU_ICUSARH_SAIELSR60_Msk = 0x10000000
	// Bit SAIELSR60.
	CPSCU_ICUSARH_SAIELSR60 = 0x10000000
	// Secure
	CPSCU_ICUSARH_SAIELSR60_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR60_1 = 0x1
	// Position of SAIELSR61 field.
	CPSCU_ICUSARH_SAIELSR61_Pos = 0x1d
	// Bit mask of SAIELSR61 field.
	CPSCU_ICUSARH_SAIELSR61_Msk = 0x20000000
	// Bit SAIELSR61.
	CPSCU_ICUSARH_SAIELSR61 = 0x20000000
	// Secure
	CPSCU_ICUSARH_SAIELSR61_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR61_1 = 0x1
	// Position of SAIELSR62 field.
	CPSCU_ICUSARH_SAIELSR62_Pos = 0x1e
	// Bit mask of SAIELSR62 field.
	CPSCU_ICUSARH_SAIELSR62_Msk = 0x40000000
	// Bit SAIELSR62.
	CPSCU_ICUSARH_SAIELSR62 = 0x40000000
	// Secure
	CPSCU_ICUSARH_SAIELSR62_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR62_1 = 0x1
	// Position of SAIELSR63 field.
	CPSCU_ICUSARH_SAIELSR63_Pos = 0x1f
	// Bit mask of SAIELSR63 field.
	CPSCU_ICUSARH_SAIELSR63_Msk = 0x80000000
	// Bit SAIELSR63.
	CPSCU_ICUSARH_SAIELSR63 = 0x80000000
	// Secure
	CPSCU_ICUSARH_SAIELSR63_0 = 0x0
	// Non-secure
	CPSCU_ICUSARH_SAIELSR63_1 = 0x1

	// ICUSARI: Interrupt Controller Unit Security Attribution Register I
	// Position of SAIELSR64 field.
	CPSCU_ICUSARI_SAIELSR64_Pos = 0x0
	// Bit mask of SAIELSR64 field.
	CPSCU_ICUSARI_SAIELSR64_Msk = 0x1
	// Bit SAIELSR64.
	CPSCU_ICUSARI_SAIELSR64 = 0x1
	// Secure
	CPSCU_ICUSARI_SAIELSR64_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR64_1 = 0x1
	// Position of SAIELSR65 field.
	CPSCU_ICUSARI_SAIELSR65_Pos = 0x1
	// Bit mask of SAIELSR65 field.
	CPSCU_ICUSARI_SAIELSR65_Msk = 0x2
	// Bit SAIELSR65.
	CPSCU_ICUSARI_SAIELSR65 = 0x2
	// Secure
	CPSCU_ICUSARI_SAIELSR65_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR65_1 = 0x1
	// Position of SAIELSR66 field.
	CPSCU_ICUSARI_SAIELSR66_Pos = 0x2
	// Bit mask of SAIELSR66 field.
	CPSCU_ICUSARI_SAIELSR66_Msk = 0x4
	// Bit SAIELSR66.
	CPSCU_ICUSARI_SAIELSR66 = 0x4
	// Secure
	CPSCU_ICUSARI_SAIELSR66_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR66_1 = 0x1
	// Position of SAIELSR67 field.
	CPSCU_ICUSARI_SAIELSR67_Pos = 0x3
	// Bit mask of SAIELSR67 field.
	CPSCU_ICUSARI_SAIELSR67_Msk = 0x8
	// Bit SAIELSR67.
	CPSCU_ICUSARI_SAIELSR67 = 0x8
	// Secure
	CPSCU_ICUSARI_SAIELSR67_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR67_1 = 0x1
	// Position of SAIELSR68 field.
	CPSCU_ICUSARI_SAIELSR68_Pos = 0x4
	// Bit mask of SAIELSR68 field.
	CPSCU_ICUSARI_SAIELSR68_Msk = 0x10
	// Bit SAIELSR68.
	CPSCU_ICUSARI_SAIELSR68 = 0x10
	// Secure
	CPSCU_ICUSARI_SAIELSR68_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR68_1 = 0x1
	// Position of SAIELSR69 field.
	CPSCU_ICUSARI_SAIELSR69_Pos = 0x5
	// Bit mask of SAIELSR69 field.
	CPSCU_ICUSARI_SAIELSR69_Msk = 0x20
	// Bit SAIELSR69.
	CPSCU_ICUSARI_SAIELSR69 = 0x20
	// Secure
	CPSCU_ICUSARI_SAIELSR69_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR69_1 = 0x1
	// Position of SAIELSR70 field.
	CPSCU_ICUSARI_SAIELSR70_Pos = 0x6
	// Bit mask of SAIELSR70 field.
	CPSCU_ICUSARI_SAIELSR70_Msk = 0x40
	// Bit SAIELSR70.
	CPSCU_ICUSARI_SAIELSR70 = 0x40
	// Secure
	CPSCU_ICUSARI_SAIELSR70_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR70_1 = 0x1
	// Position of SAIELSR71 field.
	CPSCU_ICUSARI_SAIELSR71_Pos = 0x7
	// Bit mask of SAIELSR71 field.
	CPSCU_ICUSARI_SAIELSR71_Msk = 0x80
	// Bit SAIELSR71.
	CPSCU_ICUSARI_SAIELSR71 = 0x80
	// Secure
	CPSCU_ICUSARI_SAIELSR71_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR71_1 = 0x1
	// Position of SAIELSR72 field.
	CPSCU_ICUSARI_SAIELSR72_Pos = 0x8
	// Bit mask of SAIELSR72 field.
	CPSCU_ICUSARI_SAIELSR72_Msk = 0x100
	// Bit SAIELSR72.
	CPSCU_ICUSARI_SAIELSR72 = 0x100
	// Secure
	CPSCU_ICUSARI_SAIELSR72_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR72_1 = 0x1
	// Position of SAIELSR73 field.
	CPSCU_ICUSARI_SAIELSR73_Pos = 0x9
	// Bit mask of SAIELSR73 field.
	CPSCU_ICUSARI_SAIELSR73_Msk = 0x200
	// Bit SAIELSR73.
	CPSCU_ICUSARI_SAIELSR73 = 0x200
	// Secure
	CPSCU_ICUSARI_SAIELSR73_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR73_1 = 0x1
	// Position of SAIELSR74 field.
	CPSCU_ICUSARI_SAIELSR74_Pos = 0xa
	// Bit mask of SAIELSR74 field.
	CPSCU_ICUSARI_SAIELSR74_Msk = 0x400
	// Bit SAIELSR74.
	CPSCU_ICUSARI_SAIELSR74 = 0x400
	// Secure
	CPSCU_ICUSARI_SAIELSR74_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR74_1 = 0x1
	// Position of SAIELSR75 field.
	CPSCU_ICUSARI_SAIELSR75_Pos = 0xb
	// Bit mask of SAIELSR75 field.
	CPSCU_ICUSARI_SAIELSR75_Msk = 0x800
	// Bit SAIELSR75.
	CPSCU_ICUSARI_SAIELSR75 = 0x800
	// Secure
	CPSCU_ICUSARI_SAIELSR75_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR75_1 = 0x1
	// Position of SAIELSR76 field.
	CPSCU_ICUSARI_SAIELSR76_Pos = 0xc
	// Bit mask of SAIELSR76 field.
	CPSCU_ICUSARI_SAIELSR76_Msk = 0x1000
	// Bit SAIELSR76.
	CPSCU_ICUSARI_SAIELSR76 = 0x1000
	// Secure
	CPSCU_ICUSARI_SAIELSR76_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR76_1 = 0x1
	// Position of SAIELSR77 field.
	CPSCU_ICUSARI_SAIELSR77_Pos = 0xd
	// Bit mask of SAIELSR77 field.
	CPSCU_ICUSARI_SAIELSR77_Msk = 0x2000
	// Bit SAIELSR77.
	CPSCU_ICUSARI_SAIELSR77 = 0x2000
	// Secure
	CPSCU_ICUSARI_SAIELSR77_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR77_1 = 0x1
	// Position of SAIELSR78 field.
	CPSCU_ICUSARI_SAIELSR78_Pos = 0xe
	// Bit mask of SAIELSR78 field.
	CPSCU_ICUSARI_SAIELSR78_Msk = 0x4000
	// Bit SAIELSR78.
	CPSCU_ICUSARI_SAIELSR78 = 0x4000
	// Secure
	CPSCU_ICUSARI_SAIELSR78_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR78_1 = 0x1
	// Position of SAIELSR79 field.
	CPSCU_ICUSARI_SAIELSR79_Pos = 0xf
	// Bit mask of SAIELSR79 field.
	CPSCU_ICUSARI_SAIELSR79_Msk = 0x8000
	// Bit SAIELSR79.
	CPSCU_ICUSARI_SAIELSR79 = 0x8000
	// Secure
	CPSCU_ICUSARI_SAIELSR79_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR79_1 = 0x1
	// Position of SAIELSR80 field.
	CPSCU_ICUSARI_SAIELSR80_Pos = 0x10
	// Bit mask of SAIELSR80 field.
	CPSCU_ICUSARI_SAIELSR80_Msk = 0x10000
	// Bit SAIELSR80.
	CPSCU_ICUSARI_SAIELSR80 = 0x10000
	// Secure
	CPSCU_ICUSARI_SAIELSR80_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR80_1 = 0x1
	// Position of SAIELSR81 field.
	CPSCU_ICUSARI_SAIELSR81_Pos = 0x11
	// Bit mask of SAIELSR81 field.
	CPSCU_ICUSARI_SAIELSR81_Msk = 0x20000
	// Bit SAIELSR81.
	CPSCU_ICUSARI_SAIELSR81 = 0x20000
	// Secure
	CPSCU_ICUSARI_SAIELSR81_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR81_1 = 0x1
	// Position of SAIELSR82 field.
	CPSCU_ICUSARI_SAIELSR82_Pos = 0x12
	// Bit mask of SAIELSR82 field.
	CPSCU_ICUSARI_SAIELSR82_Msk = 0x40000
	// Bit SAIELSR82.
	CPSCU_ICUSARI_SAIELSR82 = 0x40000
	// Secure
	CPSCU_ICUSARI_SAIELSR82_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR82_1 = 0x1
	// Position of SAIELSR83 field.
	CPSCU_ICUSARI_SAIELSR83_Pos = 0x13
	// Bit mask of SAIELSR83 field.
	CPSCU_ICUSARI_SAIELSR83_Msk = 0x80000
	// Bit SAIELSR83.
	CPSCU_ICUSARI_SAIELSR83 = 0x80000
	// Secure
	CPSCU_ICUSARI_SAIELSR83_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR83_1 = 0x1
	// Position of SAIELSR84 field.
	CPSCU_ICUSARI_SAIELSR84_Pos = 0x14
	// Bit mask of SAIELSR84 field.
	CPSCU_ICUSARI_SAIELSR84_Msk = 0x100000
	// Bit SAIELSR84.
	CPSCU_ICUSARI_SAIELSR84 = 0x100000
	// Secure
	CPSCU_ICUSARI_SAIELSR84_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR84_1 = 0x1
	// Position of SAIELSR85 field.
	CPSCU_ICUSARI_SAIELSR85_Pos = 0x15
	// Bit mask of SAIELSR85 field.
	CPSCU_ICUSARI_SAIELSR85_Msk = 0x200000
	// Bit SAIELSR85.
	CPSCU_ICUSARI_SAIELSR85 = 0x200000
	// Secure
	CPSCU_ICUSARI_SAIELSR85_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR85_1 = 0x1
	// Position of SAIELSR86 field.
	CPSCU_ICUSARI_SAIELSR86_Pos = 0x16
	// Bit mask of SAIELSR86 field.
	CPSCU_ICUSARI_SAIELSR86_Msk = 0x400000
	// Bit SAIELSR86.
	CPSCU_ICUSARI_SAIELSR86 = 0x400000
	// Secure
	CPSCU_ICUSARI_SAIELSR86_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR86_1 = 0x1
	// Position of SAIELSR87 field.
	CPSCU_ICUSARI_SAIELSR87_Pos = 0x17
	// Bit mask of SAIELSR87 field.
	CPSCU_ICUSARI_SAIELSR87_Msk = 0x800000
	// Bit SAIELSR87.
	CPSCU_ICUSARI_SAIELSR87 = 0x800000
	// Secure
	CPSCU_ICUSARI_SAIELSR87_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR87_1 = 0x1
	// Position of SAIELSR88 field.
	CPSCU_ICUSARI_SAIELSR88_Pos = 0x18
	// Bit mask of SAIELSR88 field.
	CPSCU_ICUSARI_SAIELSR88_Msk = 0x1000000
	// Bit SAIELSR88.
	CPSCU_ICUSARI_SAIELSR88 = 0x1000000
	// Secure
	CPSCU_ICUSARI_SAIELSR88_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR88_1 = 0x1
	// Position of SAIELSR89 field.
	CPSCU_ICUSARI_SAIELSR89_Pos = 0x19
	// Bit mask of SAIELSR89 field.
	CPSCU_ICUSARI_SAIELSR89_Msk = 0x2000000
	// Bit SAIELSR89.
	CPSCU_ICUSARI_SAIELSR89 = 0x2000000
	// Secure
	CPSCU_ICUSARI_SAIELSR89_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR89_1 = 0x1
	// Position of SAIELSR90 field.
	CPSCU_ICUSARI_SAIELSR90_Pos = 0x1a
	// Bit mask of SAIELSR90 field.
	CPSCU_ICUSARI_SAIELSR90_Msk = 0x4000000
	// Bit SAIELSR90.
	CPSCU_ICUSARI_SAIELSR90 = 0x4000000
	// Secure
	CPSCU_ICUSARI_SAIELSR90_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR90_1 = 0x1
	// Position of SAIELSR91 field.
	CPSCU_ICUSARI_SAIELSR91_Pos = 0x1b
	// Bit mask of SAIELSR91 field.
	CPSCU_ICUSARI_SAIELSR91_Msk = 0x8000000
	// Bit SAIELSR91.
	CPSCU_ICUSARI_SAIELSR91 = 0x8000000
	// Secure
	CPSCU_ICUSARI_SAIELSR91_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR91_1 = 0x1
	// Position of SAIELSR92 field.
	CPSCU_ICUSARI_SAIELSR92_Pos = 0x1c
	// Bit mask of SAIELSR92 field.
	CPSCU_ICUSARI_SAIELSR92_Msk = 0x10000000
	// Bit SAIELSR92.
	CPSCU_ICUSARI_SAIELSR92 = 0x10000000
	// Secure
	CPSCU_ICUSARI_SAIELSR92_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR92_1 = 0x1
	// Position of SAIELSR93 field.
	CPSCU_ICUSARI_SAIELSR93_Pos = 0x1d
	// Bit mask of SAIELSR93 field.
	CPSCU_ICUSARI_SAIELSR93_Msk = 0x20000000
	// Bit SAIELSR93.
	CPSCU_ICUSARI_SAIELSR93 = 0x20000000
	// Secure
	CPSCU_ICUSARI_SAIELSR93_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR93_1 = 0x1
	// Position of SAIELSR94 field.
	CPSCU_ICUSARI_SAIELSR94_Pos = 0x1e
	// Bit mask of SAIELSR94 field.
	CPSCU_ICUSARI_SAIELSR94_Msk = 0x40000000
	// Bit SAIELSR94.
	CPSCU_ICUSARI_SAIELSR94 = 0x40000000
	// Secure
	CPSCU_ICUSARI_SAIELSR94_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR94_1 = 0x1
	// Position of SAIELSR95 field.
	CPSCU_ICUSARI_SAIELSR95_Pos = 0x1f
	// Bit mask of SAIELSR95 field.
	CPSCU_ICUSARI_SAIELSR95_Msk = 0x80000000
	// Bit SAIELSR95.
	CPSCU_ICUSARI_SAIELSR95 = 0x80000000
	// Secure
	CPSCU_ICUSARI_SAIELSR95_0 = 0x0
	// Non-secure
	CPSCU_ICUSARI_SAIELSR95_1 = 0x1

	// BUSSARA: BUS Security Attribution Register A
	// Position of BUSSA0 field.
	CPSCU_BUSSARA_BUSSA0_Pos = 0x0
	// Bit mask of BUSSA0 field.
	CPSCU_BUSSARA_BUSSA0_Msk = 0x1
	// Bit BUSSA0.
	CPSCU_BUSSARA_BUSSA0 = 0x1
	// Secure
	CPSCU_BUSSARA_BUSSA0_0 = 0x0
	// Non-Secure
	CPSCU_BUSSARA_BUSSA0_1 = 0x1

	// BUSSARB: BUS Security Attribution Register B
	// Position of BUSSB0 field.
	CPSCU_BUSSARB_BUSSB0_Pos = 0x0
	// Bit mask of BUSSB0 field.
	CPSCU_BUSSARB_BUSSB0_Msk = 0x1
	// Bit BUSSB0.
	CPSCU_BUSSARB_BUSSB0 = 0x1
	// Secure
	CPSCU_BUSSARB_BUSSB0_0 = 0x0
	// Non-Secure
	CPSCU_BUSSARB_BUSSB0_1 = 0x1

	// MMPUSARA: Master Memory Protection Unit Security Attribution Register A
	// Position of MMPUASAn field.
	CPSCU_MMPUSARA_MMPUASAn_Pos = 0x0
	// Bit mask of MMPUASAn field.
	CPSCU_MMPUSARA_MMPUASAn_Msk = 0xff
	// Secure
	CPSCU_MMPUSARA_MMPUASAn_0 = 0x0
	// Non-Secure
	CPSCU_MMPUSARA_MMPUASAn_1 = 0x1

	// MMPUSARB: Master Memory Protection Unit Security Attribution Register B
	// Position of MMPUBSA0 field.
	CPSCU_MMPUSARB_MMPUBSA0_Pos = 0x0
	// Bit mask of MMPUBSA0 field.
	CPSCU_MMPUSARB_MMPUBSA0_Msk = 0x1
	// Bit MMPUBSA0.
	CPSCU_MMPUSARB_MMPUBSA0 = 0x1
	// Secure
	CPSCU_MMPUSARB_MMPUBSA0_0 = 0x0
	// Non-Secure
	CPSCU_MMPUSARB_MMPUBSA0_1 = 0x1

	// TZFSAR: TrustZone Filter Security Attribution Register
	// Position of TZFSA0 field.
	CPSCU_TZFSAR_TZFSA0_Pos = 0x0
	// Bit mask of TZFSA0 field.
	CPSCU_TZFSAR_TZFSA0_Msk = 0x1
	// Bit TZFSA0.
	CPSCU_TZFSAR_TZFSA0 = 0x1
	// Secure
	CPSCU_TZFSAR_TZFSA0_0 = 0x0
	// Non-secure
	CPSCU_TZFSAR_TZFSA0_1 = 0x1

	// CPUDSAR: CPU Debug Security Attribution Register
	// Position of CPUDSA0 field.
	CPSCU_CPUDSAR_CPUDSA0_Pos = 0x0
	// Bit mask of CPUDSA0 field.
	CPSCU_CPUDSAR_CPUDSA0_Msk = 0x1
	// Bit CPUDSA0.
	CPSCU_CPUDSAR_CPUDSA0 = 0x1
	// Secure
	CPSCU_CPUDSAR_CPUDSA0_0 = 0x0
	// Non-secure
	CPSCU_CPUDSAR_CPUDSA0_1 = 0x1
)

// Constants for DBG: Debug Function
const (
	// DBGSTR: Debug Status Register
	// Position of CDBGPWRUPREQ field.
	DBG_DBGSTR_CDBGPWRUPREQ_Pos = 0x1c
	// Bit mask of CDBGPWRUPREQ field.
	DBG_DBGSTR_CDBGPWRUPREQ_Msk = 0x10000000
	// Bit CDBGPWRUPREQ.
	DBG_DBGSTR_CDBGPWRUPREQ = 0x10000000
	// OCD is not requesting debug power up
	DBG_DBGSTR_CDBGPWRUPREQ_0 = 0x0
	// OCD is requesting debug power up
	DBG_DBGSTR_CDBGPWRUPREQ_1 = 0x1
	// Position of CDBGPWRUPACK field.
	DBG_DBGSTR_CDBGPWRUPACK_Pos = 0x1d
	// Bit mask of CDBGPWRUPACK field.
	DBG_DBGSTR_CDBGPWRUPACK_Msk = 0x20000000
	// Bit CDBGPWRUPACK.
	DBG_DBGSTR_CDBGPWRUPACK = 0x20000000
	// Debug power-up request is not acknowledged
	DBG_DBGSTR_CDBGPWRUPACK_0 = 0x0
	// Debug power-up request is acknowledged
	DBG_DBGSTR_CDBGPWRUPACK_1 = 0x1

	// DBGSTOPCR: Debug Stop Control Register
	// Position of DBGSTOP_IWDT field.
	DBG_DBGSTOPCR_DBGSTOP_IWDT_Pos = 0x0
	// Bit mask of DBGSTOP_IWDT field.
	DBG_DBGSTOPCR_DBGSTOP_IWDT_Msk = 0x1
	// Bit DBGSTOP_IWDT.
	DBG_DBGSTOPCR_DBGSTOP_IWDT = 0x1
	// Enable IWDT reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_IWDT_0 = 0x0
	// Mask IWDT reset/interrupt and stop IWDT counter
	DBG_DBGSTOPCR_DBGSTOP_IWDT_1 = 0x1
	// Position of DBGSTOP_WDT field.
	DBG_DBGSTOPCR_DBGSTOP_WDT_Pos = 0x1
	// Bit mask of DBGSTOP_WDT field.
	DBG_DBGSTOPCR_DBGSTOP_WDT_Msk = 0x2
	// Bit DBGSTOP_WDT.
	DBG_DBGSTOPCR_DBGSTOP_WDT = 0x2
	// Enable WDT reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_WDT_0 = 0x0
	// Mask WDT reset/interrupt and stop WDT counter
	DBG_DBGSTOPCR_DBGSTOP_WDT_1 = 0x1
	// Position of DBGSTOP_LVD0 field.
	DBG_DBGSTOPCR_DBGSTOP_LVD0_Pos = 0x10
	// Bit mask of DBGSTOP_LVD0 field.
	DBG_DBGSTOPCR_DBGSTOP_LVD0_Msk = 0x10000
	// Bit DBGSTOP_LVD0.
	DBG_DBGSTOPCR_DBGSTOP_LVD0 = 0x10000
	// Enable LVD0 reset
	DBG_DBGSTOPCR_DBGSTOP_LVD0_0 = 0x0
	// Mask LVD0 reset
	DBG_DBGSTOPCR_DBGSTOP_LVD0_1 = 0x1
	// Position of DBGSTOP_LVD1 field.
	DBG_DBGSTOPCR_DBGSTOP_LVD1_Pos = 0x11
	// Bit mask of DBGSTOP_LVD1 field.
	DBG_DBGSTOPCR_DBGSTOP_LVD1_Msk = 0x20000
	// Bit DBGSTOP_LVD1.
	DBG_DBGSTOPCR_DBGSTOP_LVD1 = 0x20000
	// Enable LVD1 reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_LVD1_0 = 0x0
	// Mask LVD1 reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_LVD1_1 = 0x1
	// Position of DBGSTOP_LVD2 field.
	DBG_DBGSTOPCR_DBGSTOP_LVD2_Pos = 0x12
	// Bit mask of DBGSTOP_LVD2 field.
	DBG_DBGSTOPCR_DBGSTOP_LVD2_Msk = 0x40000
	// Bit DBGSTOP_LVD2.
	DBG_DBGSTOPCR_DBGSTOP_LVD2 = 0x40000
	// Enable LVD2 reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_LVD2_0 = 0x0
	// Mask LVD2 reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_LVD2_1 = 0x1
	// Position of DBGSTOP_RPER field.
	DBG_DBGSTOPCR_DBGSTOP_RPER_Pos = 0x18
	// Bit mask of DBGSTOP_RPER field.
	DBG_DBGSTOPCR_DBGSTOP_RPER_Msk = 0x1000000
	// Bit DBGSTOP_RPER.
	DBG_DBGSTOPCR_DBGSTOP_RPER = 0x1000000
	// Enable SRAM parity error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RPER_0 = 0x0
	// Mask SRAM parity error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RPER_1 = 0x1
	// Position of DBGSTOP_CPER field.
	DBG_DBGSTOPCR_DBGSTOP_CPER_Pos = 0x1f
	// Bit mask of DBGSTOP_CPER field.
	DBG_DBGSTOPCR_DBGSTOP_CPER_Msk = 0x80000000
	// Bit DBGSTOP_CPER.
	DBG_DBGSTOPCR_DBGSTOP_CPER = 0x80000000
	// Enable Cache SRAM parity error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_CPER_0 = 0x0
	// Mask Cache SRAM parity error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_CPER_1 = 0x1
)

// Constants for FCACHE: SYSTEM/FLASH
const (
	// FCACHEE: Flash Cache Enable Register
	// Position of FCACHEEN field.
	FCACHE_FCACHEE_FCACHEEN_Pos = 0x0
	// Bit mask of FCACHEEN field.
	FCACHE_FCACHEE_FCACHEEN_Msk = 0x1
	// Bit FCACHEEN.
	FCACHE_FCACHEE_FCACHEEN = 0x1
	// FCACHE is disabled
	FCACHE_FCACHEE_FCACHEEN_0 = 0x0
	// FCACHE is enabled
	FCACHE_FCACHEE_FCACHEEN_1 = 0x1

	// FCACHEIV: Flash Cache Invalidate Register
	// Position of FCACHEIV field.
	FCACHE_FCACHEIV_FCACHEIV_Pos = 0x0
	// Bit mask of FCACHEIV field.
	FCACHE_FCACHEIV_FCACHEIV_Msk = 0x1
	// Bit FCACHEIV.
	FCACHE_FCACHEIV_FCACHEIV = 0x1
	// Read: Do not invalidate. Write: The setting is ignored.
	FCACHE_FCACHEIV_FCACHEIV_0 = 0x0
	// Invalidate FCACHE is invalidated.
	FCACHE_FCACHEIV_FCACHEIV_1 = 0x1

	// FLWT: Flash Wait Cycle Register
	// Position of FLWT field.
	FCACHE_FLWT_FLWT_Pos = 0x0
	// Bit mask of FLWT field.
	FCACHE_FLWT_FLWT_Msk = 0x7

	// FSAR: Flash Security Attribution Register
	// Position of FLWTSA field.
	FCACHE_FSAR_FLWTSA_Pos = 0x0
	// Bit mask of FLWTSA field.
	FCACHE_FSAR_FLWTSA_Msk = 0x1
	// Bit FLWTSA.
	FCACHE_FSAR_FLWTSA = 0x1
	// Secure
	FCACHE_FSAR_FLWTSA_0 = 0x0
	// Non-Secure
	FCACHE_FSAR_FLWTSA_1 = 0x1
	// Position of FCKMHZSA field.
	FCACHE_FSAR_FCKMHZSA_Pos = 0x8
	// Bit mask of FCKMHZSA field.
	FCACHE_FSAR_FCKMHZSA_Msk = 0x100
	// Bit FCKMHZSA.
	FCACHE_FSAR_FCKMHZSA = 0x100
	// Secure
	FCACHE_FSAR_FCKMHZSA_0 = 0x0
	// Non-Secure
	FCACHE_FSAR_FCKMHZSA_1 = 0x1
)

// Constants for SYSC: System Control
const (
	// SBYCR: Standby Control Register
	// Position of SSBY field.
	SYSC_SBYCR_SSBY_Pos = 0xf
	// Bit mask of SSBY field.
	SYSC_SBYCR_SSBY_Msk = 0x8000
	// Bit SSBY.
	SYSC_SBYCR_SSBY = 0x8000
	// Sleep mode
	SYSC_SBYCR_SSBY_0 = 0x0
	// Software Standby mode.
	SYSC_SBYCR_SSBY_1 = 0x1

	// SCKDIVCR: System Clock Division Control Register
	// Position of PCKD field.
	SYSC_SCKDIVCR_PCKD_Pos = 0x0
	// Bit mask of PCKD field.
	SYSC_SCKDIVCR_PCKD_Msk = 0x7
	// x 1/1
	SYSC_SCKDIVCR_PCKD_000 = 0x0
	// x 1/2
	SYSC_SCKDIVCR_PCKD_001 = 0x1
	// x 1/4
	SYSC_SCKDIVCR_PCKD_010 = 0x2
	// x 1/8
	SYSC_SCKDIVCR_PCKD_011 = 0x3
	// x 1/16
	SYSC_SCKDIVCR_PCKD_100 = 0x4
	// x 1/32
	SYSC_SCKDIVCR_PCKD_101 = 0x5
	// x 1/64
	SYSC_SCKDIVCR_PCKD_110 = 0x6
	// Position of PCKC field.
	SYSC_SCKDIVCR_PCKC_Pos = 0x4
	// Bit mask of PCKC field.
	SYSC_SCKDIVCR_PCKC_Msk = 0x70
	// x 1/1
	SYSC_SCKDIVCR_PCKC_000 = 0x0
	// x 1/2
	SYSC_SCKDIVCR_PCKC_001 = 0x1
	// x 1/4
	SYSC_SCKDIVCR_PCKC_010 = 0x2
	// x 1/8
	SYSC_SCKDIVCR_PCKC_011 = 0x3
	// x 1/16
	SYSC_SCKDIVCR_PCKC_100 = 0x4
	// x 1/32
	SYSC_SCKDIVCR_PCKC_101 = 0x5
	// x 1/64
	SYSC_SCKDIVCR_PCKC_110 = 0x6
	// Position of PCKB field.
	SYSC_SCKDIVCR_PCKB_Pos = 0x8
	// Bit mask of PCKB field.
	SYSC_SCKDIVCR_PCKB_Msk = 0x700
	// x 1/1
	SYSC_SCKDIVCR_PCKB_000 = 0x0
	// x 1/2
	SYSC_SCKDIVCR_PCKB_001 = 0x1
	// x 1/4
	SYSC_SCKDIVCR_PCKB_010 = 0x2
	// x 1/8
	SYSC_SCKDIVCR_PCKB_011 = 0x3
	// x 1/16
	SYSC_SCKDIVCR_PCKB_100 = 0x4
	// x 1/32
	SYSC_SCKDIVCR_PCKB_101 = 0x5
	// x 1/64
	SYSC_SCKDIVCR_PCKB_110 = 0x6
	// Position of PCKA field.
	SYSC_SCKDIVCR_PCKA_Pos = 0xc
	// Bit mask of PCKA field.
	SYSC_SCKDIVCR_PCKA_Msk = 0x7000
	// x 1/1
	SYSC_SCKDIVCR_PCKA_000 = 0x0
	// x 1/2
	SYSC_SCKDIVCR_PCKA_001 = 0x1
	// x 1/4
	SYSC_SCKDIVCR_PCKA_010 = 0x2
	// x 1/8
	SYSC_SCKDIVCR_PCKA_011 = 0x3
	// x 1/16
	SYSC_SCKDIVCR_PCKA_100 = 0x4
	// x 1/32
	SYSC_SCKDIVCR_PCKA_101 = 0x5
	// x 1/64
	SYSC_SCKDIVCR_PCKA_110 = 0x6
	// Position of RSV field.
	SYSC_SCKDIVCR_RSV_Pos = 0x10
	// Bit mask of RSV field.
	SYSC_SCKDIVCR_RSV_Msk = 0x70000
	// x 1/1
	SYSC_SCKDIVCR_RSV_000 = 0x0
	// x 1/2
	SYSC_SCKDIVCR_RSV_001 = 0x1
	// x 1/4
	SYSC_SCKDIVCR_RSV_010 = 0x2
	// x 1/8
	SYSC_SCKDIVCR_RSV_011 = 0x3
	// x 1/16
	SYSC_SCKDIVCR_RSV_100 = 0x4
	// x 1/32
	SYSC_SCKDIVCR_RSV_101 = 0x5
	// x 1/64
	SYSC_SCKDIVCR_RSV_110 = 0x6
	// Position of ICK field.
	SYSC_SCKDIVCR_ICK_Pos = 0x18
	// Bit mask of ICK field.
	SYSC_SCKDIVCR_ICK_Msk = 0x7000000
	// x 1/1
	SYSC_SCKDIVCR_ICK_000 = 0x0
	// x 1/2
	SYSC_SCKDIVCR_ICK_001 = 0x1
	// x 1/4
	SYSC_SCKDIVCR_ICK_010 = 0x2
	// x 1/8
	SYSC_SCKDIVCR_ICK_011 = 0x3
	// x 1/16
	SYSC_SCKDIVCR_ICK_100 = 0x4
	// x 1/32
	SYSC_SCKDIVCR_ICK_101 = 0x5
	// x 1/64
	SYSC_SCKDIVCR_ICK_110 = 0x6
	// Position of FCK field.
	SYSC_SCKDIVCR_FCK_Pos = 0x1c
	// Bit mask of FCK field.
	SYSC_SCKDIVCR_FCK_Msk = 0x70000000
	// x 1/1
	SYSC_SCKDIVCR_FCK_000 = 0x0
	// x 1/2
	SYSC_SCKDIVCR_FCK_001 = 0x1
	// x 1/4
	SYSC_SCKDIVCR_FCK_010 = 0x2
	// x 1/8
	SYSC_SCKDIVCR_FCK_011 = 0x3
	// x 1/16
	SYSC_SCKDIVCR_FCK_100 = 0x4
	// x 1/32
	SYSC_SCKDIVCR_FCK_101 = 0x5
	// x 1/64
	SYSC_SCKDIVCR_FCK_110 = 0x6

	// SCKSCR: System Clock Source Control Register
	// Position of CKSEL field.
	SYSC_SCKSCR_CKSEL_Pos = 0x0
	// Bit mask of CKSEL field.
	SYSC_SCKSCR_CKSEL_Msk = 0x7
	// HOCO
	SYSC_SCKSCR_CKSEL_000 = 0x0
	// MOCO
	SYSC_SCKSCR_CKSEL_001 = 0x1
	// LOCO
	SYSC_SCKSCR_CKSEL_010 = 0x2
	// Main clock oscillator (MOSC)
	SYSC_SCKSCR_CKSEL_011 = 0x3
	// Sub-clock oscillator (SOSC)
	SYSC_SCKSCR_CKSEL_100 = 0x4
	// PLL
	SYSC_SCKSCR_CKSEL_101 = 0x5
	// Setting prohibited
	SYSC_SCKSCR_CKSEL_110 = 0x6
	// Setting prohibited
	SYSC_SCKSCR_CKSEL_111 = 0x7

	// PLLCCR: PLL Clock Control Register
	// Position of PLIDIV field.
	SYSC_PLLCCR_PLIDIV_Pos = 0x0
	// Bit mask of PLIDIV field.
	SYSC_PLLCCR_PLIDIV_Msk = 0x3
	// /1
	SYSC_PLLCCR_PLIDIV_00 = 0x0
	// /2
	SYSC_PLLCCR_PLIDIV_01 = 0x1
	// /3
	SYSC_PLLCCR_PLIDIV_10 = 0x2
	// Position of PLSRCSEL field.
	SYSC_PLLCCR_PLSRCSEL_Pos = 0x4
	// Bit mask of PLSRCSEL field.
	SYSC_PLLCCR_PLSRCSEL_Msk = 0x10
	// Bit PLSRCSEL.
	SYSC_PLLCCR_PLSRCSEL = 0x10
	// Main clock oscillator
	SYSC_PLLCCR_PLSRCSEL_0 = 0x0
	// HOCO
	SYSC_PLLCCR_PLSRCSEL_1 = 0x1
	// Position of PLLMUL field.
	SYSC_PLLCCR_PLLMUL_Pos = 0x8
	// Bit mask of PLLMUL field.
	SYSC_PLLCCR_PLLMUL_Msk = 0x3f00

	// PLLCR: PLL Control Register
	// Position of PLLSTP field.
	SYSC_PLLCR_PLLSTP_Pos = 0x0
	// Bit mask of PLLSTP field.
	SYSC_PLLCR_PLLSTP_Msk = 0x1
	// Bit PLLSTP.
	SYSC_PLLCR_PLLSTP = 0x1
	// PLL is operating
	SYSC_PLLCR_PLLSTP_0 = 0x0
	// PLL is stopped.
	SYSC_PLLCR_PLLSTP_1 = 0x1

	// MOSCCR: Main Clock Oscillator Control Register
	// Position of MOSTP field.
	SYSC_MOSCCR_MOSTP_Pos = 0x0
	// Bit mask of MOSTP field.
	SYSC_MOSCCR_MOSTP_Msk = 0x1
	// Bit MOSTP.
	SYSC_MOSCCR_MOSTP = 0x1
	// Operate the main clock oscillator
	SYSC_MOSCCR_MOSTP_0 = 0x0
	// Stop the main clock oscillator
	SYSC_MOSCCR_MOSTP_1 = 0x1

	// HOCOCR: High-Speed On-Chip Oscillator Control Register
	// Position of HCSTP field.
	SYSC_HOCOCR_HCSTP_Pos = 0x0
	// Bit mask of HCSTP field.
	SYSC_HOCOCR_HCSTP_Msk = 0x1
	// Bit HCSTP.
	SYSC_HOCOCR_HCSTP = 0x1
	// Operate the HOCO clock
	SYSC_HOCOCR_HCSTP_0 = 0x0
	// Stop the HOCO clock
	SYSC_HOCOCR_HCSTP_1 = 0x1

	// MOCOCR: Middle-Speed On-Chip Oscillator Control Register
	// Position of MCSTP field.
	SYSC_MOCOCR_MCSTP_Pos = 0x0
	// Bit mask of MCSTP field.
	SYSC_MOCOCR_MCSTP_Msk = 0x1
	// Bit MCSTP.
	SYSC_MOCOCR_MCSTP = 0x1
	// MOCO clock is operating
	SYSC_MOCOCR_MCSTP_0 = 0x0
	// MOCO clock is stopped
	SYSC_MOCOCR_MCSTP_1 = 0x1

	// FLLCR1: FLL Control Register1
	// Position of FLLEN field.
	SYSC_FLLCR1_FLLEN_Pos = 0x0
	// Bit mask of FLLEN field.
	SYSC_FLLCR1_FLLEN_Msk = 0x1
	// Bit FLLEN.
	SYSC_FLLCR1_FLLEN = 0x1
	// FLL function is disabled
	SYSC_FLLCR1_FLLEN_0 = 0x0
	// FLL function is enabled.
	SYSC_FLLCR1_FLLEN_1 = 0x1

	// FLLCR2: FLL Control Register2
	// Position of FLLCNTL field.
	SYSC_FLLCR2_FLLCNTL_Pos = 0x0
	// Bit mask of FLLCNTL field.
	SYSC_FLLCR2_FLLCNTL_Msk = 0x7ff

	// OSCSF: Oscillation Stabilization Flag Register
	// Position of HOCOSF field.
	SYSC_OSCSF_HOCOSF_Pos = 0x0
	// Bit mask of HOCOSF field.
	SYSC_OSCSF_HOCOSF_Msk = 0x1
	// Bit HOCOSF.
	SYSC_OSCSF_HOCOSF = 0x1
	// The HOCO clock is stopped or is not yet stable
	SYSC_OSCSF_HOCOSF_0 = 0x0
	// The HOCO clock is stable, so is available for use as the system clock
	SYSC_OSCSF_HOCOSF_1 = 0x1
	// Position of MOSCSF field.
	SYSC_OSCSF_MOSCSF_Pos = 0x3
	// Bit mask of MOSCSF field.
	SYSC_OSCSF_MOSCSF_Msk = 0x8
	// Bit MOSCSF.
	SYSC_OSCSF_MOSCSF = 0x8
	// The main clock oscillator is stopped (MOSTP = 1) or is not yet stable
	SYSC_OSCSF_MOSCSF_0 = 0x0
	// The main clock oscillator is stable, so is available for use as the system clock
	SYSC_OSCSF_MOSCSF_1 = 0x1
	// Position of PLLSF field.
	SYSC_OSCSF_PLLSF_Pos = 0x5
	// Bit mask of PLLSF field.
	SYSC_OSCSF_PLLSF_Msk = 0x20
	// Bit PLLSF.
	SYSC_OSCSF_PLLSF = 0x20
	// The PLL clock is stopped, or oscillation of the PLL clock is not stable yet
	SYSC_OSCSF_PLLSF_0 = 0x0
	// The PLL clock is stable, so is available for use as the system clock
	SYSC_OSCSF_PLLSF_1 = 0x1
	// Position of PLL2SF field.
	SYSC_OSCSF_PLL2SF_Pos = 0x6
	// Bit mask of PLL2SF field.
	SYSC_OSCSF_PLL2SF_Msk = 0x40
	// Bit PLL2SF.
	SYSC_OSCSF_PLL2SF = 0x40
	// The PLL2 clock is stopped, or oscillation of the PLL2 clock is not stable yet
	SYSC_OSCSF_PLL2SF_0 = 0x0
	// The PLL2 clock is stable
	SYSC_OSCSF_PLL2SF_1 = 0x1

	// CKOCR: Clock Out Control Register
	// Position of CKOSEL field.
	SYSC_CKOCR_CKOSEL_Pos = 0x0
	// Bit mask of CKOSEL field.
	SYSC_CKOCR_CKOSEL_Msk = 0x7
	// HOCO(value after reset)
	SYSC_CKOCR_CKOSEL_000 = 0x0
	// MOCO
	SYSC_CKOCR_CKOSEL_001 = 0x1
	// LOCO
	SYSC_CKOCR_CKOSEL_010 = 0x2
	// MOSC
	SYSC_CKOCR_CKOSEL_011 = 0x3
	// SOSC
	SYSC_CKOCR_CKOSEL_100 = 0x4
	// Setting prohibited
	SYSC_CKOCR_CKOSEL_101 = 0x5
	// Position of CKODIV field.
	SYSC_CKOCR_CKODIV_Pos = 0x4
	// Bit mask of CKODIV field.
	SYSC_CKOCR_CKODIV_Msk = 0x70
	// x 1/1
	SYSC_CKOCR_CKODIV_000 = 0x0
	// x 1/2
	SYSC_CKOCR_CKODIV_001 = 0x1
	// x 1/4
	SYSC_CKOCR_CKODIV_010 = 0x2
	// x 1/8
	SYSC_CKOCR_CKODIV_011 = 0x3
	// x 1/16
	SYSC_CKOCR_CKODIV_100 = 0x4
	// x 1/32
	SYSC_CKOCR_CKODIV_101 = 0x5
	// x 1/64
	SYSC_CKOCR_CKODIV_110 = 0x6
	// x 1/128
	SYSC_CKOCR_CKODIV_111 = 0x7
	// Position of CKOEN field.
	SYSC_CKOCR_CKOEN_Pos = 0x7
	// Bit mask of CKOEN field.
	SYSC_CKOCR_CKOEN_Msk = 0x80
	// Bit CKOEN.
	SYSC_CKOCR_CKOEN = 0x80
	// Disable clock out
	SYSC_CKOCR_CKOEN_0 = 0x0
	// Enable clock out
	SYSC_CKOCR_CKOEN_1 = 0x1

	// TRCKCR: Trace Clock Control Register
	// Position of TRCK field.
	SYSC_TRCKCR_TRCK_Pos = 0x0
	// Bit mask of TRCK field.
	SYSC_TRCKCR_TRCK_Msk = 0xf
	// /1
	SYSC_TRCKCR_TRCK_0x0 = 0x0
	// /2 (value after reset)
	SYSC_TRCKCR_TRCK_0x1 = 0x1
	// /4
	SYSC_TRCKCR_TRCK_0x2 = 0x2
	// Position of TRCKEN field.
	SYSC_TRCKCR_TRCKEN_Pos = 0x7
	// Bit mask of TRCKEN field.
	SYSC_TRCKCR_TRCKEN_Msk = 0x80
	// Bit TRCKEN.
	SYSC_TRCKCR_TRCKEN = 0x80
	// Stop
	SYSC_TRCKCR_TRCKEN_0 = 0x0
	// Operation enable
	SYSC_TRCKCR_TRCKEN_1 = 0x1

	// OSTDCR: Oscillation Stop Detection Control Register
	// Position of OSTDIE field.
	SYSC_OSTDCR_OSTDIE_Pos = 0x0
	// Bit mask of OSTDIE field.
	SYSC_OSTDCR_OSTDIE_Msk = 0x1
	// Bit OSTDIE.
	SYSC_OSTDCR_OSTDIE = 0x1
	// Disable oscillation stop detection interrupt (do not notify the POEG)
	SYSC_OSTDCR_OSTDIE_0 = 0x0
	// Enable oscillation stop detection interrupt (notify the POEG)
	SYSC_OSTDCR_OSTDIE_1 = 0x1
	// Position of OSTDE field.
	SYSC_OSTDCR_OSTDE_Pos = 0x7
	// Bit mask of OSTDE field.
	SYSC_OSTDCR_OSTDE_Msk = 0x80
	// Bit OSTDE.
	SYSC_OSTDCR_OSTDE = 0x80
	// Disable oscillation stop detection function
	SYSC_OSTDCR_OSTDE_0 = 0x0
	// Enable oscillation stop detection function
	SYSC_OSTDCR_OSTDE_1 = 0x1

	// OSTDSR: Oscillation Stop Detection Status Register
	// Position of OSTDF field.
	SYSC_OSTDSR_OSTDF_Pos = 0x0
	// Bit mask of OSTDF field.
	SYSC_OSTDSR_OSTDF_Msk = 0x1
	// Bit OSTDF.
	SYSC_OSTDSR_OSTDF = 0x1
	// Main clock oscillation stop not detected
	SYSC_OSTDSR_OSTDF_0 = 0x0
	// Main clock oscillation stop detected
	SYSC_OSTDSR_OSTDF_1 = 0x1

	// PLL2CCR: PLL2 Clock Control Register
	// Position of PL2IDIV field.
	SYSC_PLL2CCR_PL2IDIV_Pos = 0x0
	// Bit mask of PL2IDIV field.
	SYSC_PLL2CCR_PL2IDIV_Msk = 0x3
	// ∕ 1 (value after reset)
	SYSC_PLL2CCR_PL2IDIV_00 = 0x0
	// ∕ 2
	SYSC_PLL2CCR_PL2IDIV_01 = 0x1
	// ∕ 3
	SYSC_PLL2CCR_PL2IDIV_10 = 0x2
	// Position of PL2SRCSEL field.
	SYSC_PLL2CCR_PL2SRCSEL_Pos = 0x4
	// Bit mask of PL2SRCSEL field.
	SYSC_PLL2CCR_PL2SRCSEL_Msk = 0x10
	// Bit PL2SRCSEL.
	SYSC_PLL2CCR_PL2SRCSEL = 0x10
	// Main clock oscillator
	SYSC_PLL2CCR_PL2SRCSEL_0 = 0x0
	// HOCO
	SYSC_PLL2CCR_PL2SRCSEL_1 = 0x1
	// Position of PLL2MUL field.
	SYSC_PLL2CCR_PLL2MUL_Pos = 0x8
	// Bit mask of PLL2MUL field.
	SYSC_PLL2CCR_PLL2MUL_Msk = 0x3f00

	// PLL2CR: PLL2 Control Register
	// Position of PLL2STP field.
	SYSC_PLL2CR_PLL2STP_Pos = 0x0
	// Bit mask of PLL2STP field.
	SYSC_PLL2CR_PLL2STP_Msk = 0x1
	// Bit PLL2STP.
	SYSC_PLL2CR_PLL2STP = 0x1
	// PLL2 is operating
	SYSC_PLL2CR_PLL2STP_0 = 0x0
	// PLL2 is stopped.
	SYSC_PLL2CR_PLL2STP_1 = 0x1

	// MOCOUTCR: MOCO User Trimming Control Register
	// Position of MOCOUTRM field.
	SYSC_MOCOUTCR_MOCOUTRM_Pos = 0x0
	// Bit mask of MOCOUTRM field.
	SYSC_MOCOUTCR_MOCOUTRM_Msk = 0xff

	// HOCOUTCR: HOCO User Trimming Control Register
	// Position of HOCOUTRM field.
	SYSC_HOCOUTCR_HOCOUTRM_Pos = 0x0
	// Bit mask of HOCOUTRM field.
	SYSC_HOCOUTCR_HOCOUTRM_Msk = 0xff

	// USBCKDIVCR: USB Clock Division Control Register
	// Position of USBCKDIV field.
	SYSC_USBCKDIVCR_USBCKDIV_Pos = 0x0
	// Bit mask of USBCKDIV field.
	SYSC_USBCKDIVCR_USBCKDIV_Msk = 0x7
	// ∕ 4
	SYSC_USBCKDIVCR_USBCKDIV_010 = 0x2
	// ∕ 3
	SYSC_USBCKDIVCR_USBCKDIV_101 = 0x5
	// ∕ 5
	SYSC_USBCKDIVCR_USBCKDIV_110 = 0x6

	// USBCKCR: USB Clock Control Register
	// Position of USBCKSEL field.
	SYSC_USBCKCR_USBCKSEL_Pos = 0x0
	// Bit mask of USBCKSEL field.
	SYSC_USBCKCR_USBCKSEL_Msk = 0x7
	// PLL
	SYSC_USBCKCR_USBCKSEL_101 = 0x5
	// PLL2
	SYSC_USBCKCR_USBCKSEL_110 = 0x6
	// Position of USBCKSREQ field.
	SYSC_USBCKCR_USBCKSREQ_Pos = 0x6
	// Bit mask of USBCKSREQ field.
	SYSC_USBCKCR_USBCKSREQ_Msk = 0x40
	// Bit USBCKSREQ.
	SYSC_USBCKCR_USBCKSREQ = 0x40
	// No request
	SYSC_USBCKCR_USBCKSREQ_0 = 0x0
	// Request switching.
	SYSC_USBCKCR_USBCKSREQ_1 = 0x1
	// Position of USBCKSRDY field.
	SYSC_USBCKCR_USBCKSRDY_Pos = 0x7
	// Bit mask of USBCKSRDY field.
	SYSC_USBCKCR_USBCKSRDY_Msk = 0x80
	// Bit USBCKSRDY.
	SYSC_USBCKCR_USBCKSRDY = 0x80
	// Impossible to Switch
	SYSC_USBCKCR_USBCKSRDY_0 = 0x0
	// Possible to Switch
	SYSC_USBCKCR_USBCKSRDY_1 = 0x1

	// SNZREQCR1: Snooze Request Control Register 1
	// Position of SNZREQEN0 field.
	SYSC_SNZREQCR1_SNZREQEN0_Pos = 0x0
	// Bit mask of SNZREQEN0 field.
	SYSC_SNZREQCR1_SNZREQEN0_Msk = 0x1
	// Bit SNZREQEN0.
	SYSC_SNZREQCR1_SNZREQEN0 = 0x1
	// Disable the snooze request
	SYSC_SNZREQCR1_SNZREQEN0_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR1_SNZREQEN0_1 = 0x1
	// Position of SNZREQEN1 field.
	SYSC_SNZREQCR1_SNZREQEN1_Pos = 0x1
	// Bit mask of SNZREQEN1 field.
	SYSC_SNZREQCR1_SNZREQEN1_Msk = 0x2
	// Bit SNZREQEN1.
	SYSC_SNZREQCR1_SNZREQEN1 = 0x2
	// Disable the snooze request
	SYSC_SNZREQCR1_SNZREQEN1_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR1_SNZREQEN1_1 = 0x1
	// Position of SNZREQEN2 field.
	SYSC_SNZREQCR1_SNZREQEN2_Pos = 0x2
	// Bit mask of SNZREQEN2 field.
	SYSC_SNZREQCR1_SNZREQEN2_Msk = 0x4
	// Bit SNZREQEN2.
	SYSC_SNZREQCR1_SNZREQEN2 = 0x4
	// Disable the snooze request
	SYSC_SNZREQCR1_SNZREQEN2_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR1_SNZREQEN2_1 = 0x1

	// SNZCR: Snooze Control Register
	// Position of RXDREQEN field.
	SYSC_SNZCR_RXDREQEN_Pos = 0x0
	// Bit mask of RXDREQEN field.
	SYSC_SNZCR_RXDREQEN_Msk = 0x1
	// Bit RXDREQEN.
	SYSC_SNZCR_RXDREQEN = 0x1
	// Ignore RXD0 falling edge in Software Standby mode
	SYSC_SNZCR_RXDREQEN_0 = 0x0
	// Detect RXD0 falling edge in Software Standby mode
	SYSC_SNZCR_RXDREQEN_1 = 0x1
	// Position of SNZDTCEN field.
	SYSC_SNZCR_SNZDTCEN_Pos = 0x1
	// Bit mask of SNZDTCEN field.
	SYSC_SNZCR_SNZDTCEN_Msk = 0x2
	// Bit SNZDTCEN.
	SYSC_SNZCR_SNZDTCEN = 0x2
	// Disable DTC operation
	SYSC_SNZCR_SNZDTCEN_0 = 0x0
	// Enable DTC operation
	SYSC_SNZCR_SNZDTCEN_1 = 0x1
	// Position of SNZE field.
	SYSC_SNZCR_SNZE_Pos = 0x7
	// Bit mask of SNZE field.
	SYSC_SNZCR_SNZE_Msk = 0x80
	// Bit SNZE.
	SYSC_SNZCR_SNZE = 0x80
	// Disable Snooze mode
	SYSC_SNZCR_SNZE_0 = 0x0
	// Enable Snooze mode
	SYSC_SNZCR_SNZE_1 = 0x1

	// SNZEDCR0: Snooze End Control Register 0
	// Position of AGTUNFED field.
	SYSC_SNZEDCR0_AGTUNFED_Pos = 0x0
	// Bit mask of AGTUNFED field.
	SYSC_SNZEDCR0_AGTUNFED_Msk = 0x1
	// Bit AGTUNFED.
	SYSC_SNZEDCR0_AGTUNFED = 0x1
	// Disable the snooze end request
	SYSC_SNZEDCR0_AGTUNFED_0 = 0x0
	// Enable the snooze end request
	SYSC_SNZEDCR0_AGTUNFED_1 = 0x1
	// Position of DTCZRED field.
	SYSC_SNZEDCR0_DTCZRED_Pos = 0x1
	// Bit mask of DTCZRED field.
	SYSC_SNZEDCR0_DTCZRED_Msk = 0x2
	// Bit DTCZRED.
	SYSC_SNZEDCR0_DTCZRED = 0x2
	// Disable the snooze end request
	SYSC_SNZEDCR0_DTCZRED_0 = 0x0
	// Enable the snooze end request
	SYSC_SNZEDCR0_DTCZRED_1 = 0x1
	// Position of DTCNZRED field.
	SYSC_SNZEDCR0_DTCNZRED_Pos = 0x2
	// Bit mask of DTCNZRED field.
	SYSC_SNZEDCR0_DTCNZRED_Msk = 0x4
	// Bit DTCNZRED.
	SYSC_SNZEDCR0_DTCNZRED = 0x4
	// Disable the snooze end request
	SYSC_SNZEDCR0_DTCNZRED_0 = 0x0
	// Enable the snooze end request
	SYSC_SNZEDCR0_DTCNZRED_1 = 0x1
	// Position of AD0MATED field.
	SYSC_SNZEDCR0_AD0MATED_Pos = 0x3
	// Bit mask of AD0MATED field.
	SYSC_SNZEDCR0_AD0MATED_Msk = 0x8
	// Bit AD0MATED.
	SYSC_SNZEDCR0_AD0MATED = 0x8
	// Disable the snooze end request
	SYSC_SNZEDCR0_AD0MATED_0 = 0x0
	// Enable the snooze end request
	SYSC_SNZEDCR0_AD0MATED_1 = 0x1
	// Position of AD0UMTED field.
	SYSC_SNZEDCR0_AD0UMTED_Pos = 0x4
	// Bit mask of AD0UMTED field.
	SYSC_SNZEDCR0_AD0UMTED_Msk = 0x10
	// Bit AD0UMTED.
	SYSC_SNZEDCR0_AD0UMTED = 0x10
	// Disable the snooze end request
	SYSC_SNZEDCR0_AD0UMTED_0 = 0x0
	// Enable the snooze end request
	SYSC_SNZEDCR0_AD0UMTED_1 = 0x1
	// Position of SCI0UMTED field.
	SYSC_SNZEDCR0_SCI0UMTED_Pos = 0x7
	// Bit mask of SCI0UMTED field.
	SYSC_SNZEDCR0_SCI0UMTED_Msk = 0x80
	// Bit SCI0UMTED.
	SYSC_SNZEDCR0_SCI0UMTED = 0x80
	// Disable the snooze end request
	SYSC_SNZEDCR0_SCI0UMTED_0 = 0x0
	// Enable the snooze end request
	SYSC_SNZEDCR0_SCI0UMTED_1 = 0x1

	// SNZEDCR1: Snooze End Control Register 1
	// Position of AGT3UNFED field.
	SYSC_SNZEDCR1_AGT3UNFED_Pos = 0x0
	// Bit mask of AGT3UNFED field.
	SYSC_SNZEDCR1_AGT3UNFED_Msk = 0x1
	// Bit AGT3UNFED.
	SYSC_SNZEDCR1_AGT3UNFED = 0x1
	// Disable the Snooze End request
	SYSC_SNZEDCR1_AGT3UNFED_0 = 0x0
	// Enable the Snooze End request
	SYSC_SNZEDCR1_AGT3UNFED_1 = 0x1

	// SNZREQCR0: Snooze Request Control Register 0
	// Position of SNZREQEN0 field.
	SYSC_SNZREQCR0_SNZREQEN0_Pos = 0x0
	// Bit mask of SNZREQEN0 field.
	SYSC_SNZREQCR0_SNZREQEN0_Msk = 0x1
	// Bit SNZREQEN0.
	SYSC_SNZREQCR0_SNZREQEN0 = 0x1
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN0_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN0_1 = 0x1
	// Position of SNZREQEN1 field.
	SYSC_SNZREQCR0_SNZREQEN1_Pos = 0x1
	// Bit mask of SNZREQEN1 field.
	SYSC_SNZREQCR0_SNZREQEN1_Msk = 0x2
	// Bit SNZREQEN1.
	SYSC_SNZREQCR0_SNZREQEN1 = 0x2
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN1_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN1_1 = 0x1
	// Position of SNZREQEN2 field.
	SYSC_SNZREQCR0_SNZREQEN2_Pos = 0x2
	// Bit mask of SNZREQEN2 field.
	SYSC_SNZREQCR0_SNZREQEN2_Msk = 0x4
	// Bit SNZREQEN2.
	SYSC_SNZREQCR0_SNZREQEN2 = 0x4
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN2_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN2_1 = 0x1
	// Position of SNZREQEN3 field.
	SYSC_SNZREQCR0_SNZREQEN3_Pos = 0x3
	// Bit mask of SNZREQEN3 field.
	SYSC_SNZREQCR0_SNZREQEN3_Msk = 0x8
	// Bit SNZREQEN3.
	SYSC_SNZREQCR0_SNZREQEN3 = 0x8
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN3_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN3_1 = 0x1
	// Position of SNZREQEN4 field.
	SYSC_SNZREQCR0_SNZREQEN4_Pos = 0x4
	// Bit mask of SNZREQEN4 field.
	SYSC_SNZREQCR0_SNZREQEN4_Msk = 0x10
	// Bit SNZREQEN4.
	SYSC_SNZREQCR0_SNZREQEN4 = 0x10
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN4_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN4_1 = 0x1
	// Position of SNZREQEN5 field.
	SYSC_SNZREQCR0_SNZREQEN5_Pos = 0x5
	// Bit mask of SNZREQEN5 field.
	SYSC_SNZREQCR0_SNZREQEN5_Msk = 0x20
	// Bit SNZREQEN5.
	SYSC_SNZREQCR0_SNZREQEN5 = 0x20
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN5_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN5_1 = 0x1
	// Position of SNZREQEN6 field.
	SYSC_SNZREQCR0_SNZREQEN6_Pos = 0x6
	// Bit mask of SNZREQEN6 field.
	SYSC_SNZREQCR0_SNZREQEN6_Msk = 0x40
	// Bit SNZREQEN6.
	SYSC_SNZREQCR0_SNZREQEN6 = 0x40
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN6_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN6_1 = 0x1
	// Position of SNZREQEN7 field.
	SYSC_SNZREQCR0_SNZREQEN7_Pos = 0x7
	// Bit mask of SNZREQEN7 field.
	SYSC_SNZREQCR0_SNZREQEN7_Msk = 0x80
	// Bit SNZREQEN7.
	SYSC_SNZREQCR0_SNZREQEN7 = 0x80
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN7_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN7_1 = 0x1
	// Position of SNZREQEN8 field.
	SYSC_SNZREQCR0_SNZREQEN8_Pos = 0x8
	// Bit mask of SNZREQEN8 field.
	SYSC_SNZREQCR0_SNZREQEN8_Msk = 0x100
	// Bit SNZREQEN8.
	SYSC_SNZREQCR0_SNZREQEN8 = 0x100
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN8_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN8_1 = 0x1
	// Position of SNZREQEN9 field.
	SYSC_SNZREQCR0_SNZREQEN9_Pos = 0x9
	// Bit mask of SNZREQEN9 field.
	SYSC_SNZREQCR0_SNZREQEN9_Msk = 0x200
	// Bit SNZREQEN9.
	SYSC_SNZREQCR0_SNZREQEN9 = 0x200
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN9_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN9_1 = 0x1
	// Position of SNZREQEN10 field.
	SYSC_SNZREQCR0_SNZREQEN10_Pos = 0xa
	// Bit mask of SNZREQEN10 field.
	SYSC_SNZREQCR0_SNZREQEN10_Msk = 0x400
	// Bit SNZREQEN10.
	SYSC_SNZREQCR0_SNZREQEN10 = 0x400
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN10_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN10_1 = 0x1
	// Position of SNZREQEN11 field.
	SYSC_SNZREQCR0_SNZREQEN11_Pos = 0xb
	// Bit mask of SNZREQEN11 field.
	SYSC_SNZREQCR0_SNZREQEN11_Msk = 0x800
	// Bit SNZREQEN11.
	SYSC_SNZREQCR0_SNZREQEN11 = 0x800
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN11_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN11_1 = 0x1
	// Position of SNZREQEN12 field.
	SYSC_SNZREQCR0_SNZREQEN12_Pos = 0xc
	// Bit mask of SNZREQEN12 field.
	SYSC_SNZREQCR0_SNZREQEN12_Msk = 0x1000
	// Bit SNZREQEN12.
	SYSC_SNZREQCR0_SNZREQEN12 = 0x1000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN12_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN12_1 = 0x1
	// Position of SNZREQEN13 field.
	SYSC_SNZREQCR0_SNZREQEN13_Pos = 0xd
	// Bit mask of SNZREQEN13 field.
	SYSC_SNZREQCR0_SNZREQEN13_Msk = 0x2000
	// Bit SNZREQEN13.
	SYSC_SNZREQCR0_SNZREQEN13 = 0x2000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN13_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN13_1 = 0x1
	// Position of SNZREQEN14 field.
	SYSC_SNZREQCR0_SNZREQEN14_Pos = 0xe
	// Bit mask of SNZREQEN14 field.
	SYSC_SNZREQCR0_SNZREQEN14_Msk = 0x4000
	// Bit SNZREQEN14.
	SYSC_SNZREQCR0_SNZREQEN14 = 0x4000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN14_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN14_1 = 0x1
	// Position of SNZREQEN15 field.
	SYSC_SNZREQCR0_SNZREQEN15_Pos = 0xf
	// Bit mask of SNZREQEN15 field.
	SYSC_SNZREQCR0_SNZREQEN15_Msk = 0x8000
	// Bit SNZREQEN15.
	SYSC_SNZREQCR0_SNZREQEN15 = 0x8000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN15_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN15_1 = 0x1
	// Position of SNZREQEN24 field.
	SYSC_SNZREQCR0_SNZREQEN24_Pos = 0x18
	// Bit mask of SNZREQEN24 field.
	SYSC_SNZREQCR0_SNZREQEN24_Msk = 0x1000000
	// Bit SNZREQEN24.
	SYSC_SNZREQCR0_SNZREQEN24 = 0x1000000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN24_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN24_1 = 0x1
	// Position of SNZREQEN25 field.
	SYSC_SNZREQCR0_SNZREQEN25_Pos = 0x19
	// Bit mask of SNZREQEN25 field.
	SYSC_SNZREQCR0_SNZREQEN25_Msk = 0x2000000
	// Bit SNZREQEN25.
	SYSC_SNZREQCR0_SNZREQEN25 = 0x2000000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN25_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN25_1 = 0x1
	// Position of SNZREQEN28 field.
	SYSC_SNZREQCR0_SNZREQEN28_Pos = 0x1c
	// Bit mask of SNZREQEN28 field.
	SYSC_SNZREQCR0_SNZREQEN28_Msk = 0x10000000
	// Bit SNZREQEN28.
	SYSC_SNZREQCR0_SNZREQEN28 = 0x10000000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN28_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN28_1 = 0x1
	// Position of SNZREQEN29 field.
	SYSC_SNZREQCR0_SNZREQEN29_Pos = 0x1d
	// Bit mask of SNZREQEN29 field.
	SYSC_SNZREQCR0_SNZREQEN29_Msk = 0x20000000
	// Bit SNZREQEN29.
	SYSC_SNZREQCR0_SNZREQEN29 = 0x20000000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN29_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN29_1 = 0x1
	// Position of SNZREQEN30 field.
	SYSC_SNZREQCR0_SNZREQEN30_Pos = 0x1e
	// Bit mask of SNZREQEN30 field.
	SYSC_SNZREQCR0_SNZREQEN30_Msk = 0x40000000
	// Bit SNZREQEN30.
	SYSC_SNZREQCR0_SNZREQEN30 = 0x40000000
	// Disable the snooze request
	SYSC_SNZREQCR0_SNZREQEN30_0 = 0x0
	// Enable the snooze request
	SYSC_SNZREQCR0_SNZREQEN30_1 = 0x1

	// OPCCR: Operating Power Control Register
	// Position of OPCM field.
	SYSC_OPCCR_OPCM_Pos = 0x0
	// Bit mask of OPCM field.
	SYSC_OPCCR_OPCM_Msk = 0x3
	// High-speed mode
	SYSC_OPCCR_OPCM_00 = 0x0
	// Setting prohibited
	SYSC_OPCCR_OPCM_01 = 0x1
	// Setting prohibited
	SYSC_OPCCR_OPCM_10 = 0x2
	// Low-speed mode
	SYSC_OPCCR_OPCM_11 = 0x3
	// Position of OPCMTSF field.
	SYSC_OPCCR_OPCMTSF_Pos = 0x4
	// Bit mask of OPCMTSF field.
	SYSC_OPCCR_OPCMTSF_Msk = 0x10
	// Bit OPCMTSF.
	SYSC_OPCCR_OPCMTSF = 0x10
	// Transition completed
	SYSC_OPCCR_OPCMTSF_0 = 0x0
	// During transition
	SYSC_OPCCR_OPCMTSF_1 = 0x1

	// MOSCWTCR: Main Clock Oscillator Wait Control Register
	// Position of MSTS field.
	SYSC_MOSCWTCR_MSTS_Pos = 0x0
	// Bit mask of MSTS field.
	SYSC_MOSCWTCR_MSTS_Msk = 0xf
	// Wait time = 3 cycles (11.4 us)
	SYSC_MOSCWTCR_MSTS_0x0 = 0x0
	// Wait time = 35 cycles (133.5 us)
	SYSC_MOSCWTCR_MSTS_0x1 = 0x1
	// Wait time = 67 cycles (255.6 us)
	SYSC_MOSCWTCR_MSTS_0x2 = 0x2
	// Wait time = 131 cycles (499.7 us)
	SYSC_MOSCWTCR_MSTS_0x3 = 0x3
	// Wait time = 259 cycles (988.0 us)
	SYSC_MOSCWTCR_MSTS_0x4 = 0x4
	// Wait time = 547 cycles (2086.6 us)
	SYSC_MOSCWTCR_MSTS_0x5 = 0x5
	// Wait time = 1059 cycles (4039.8 us)
	SYSC_MOSCWTCR_MSTS_0x6 = 0x6
	// Wait time = 2147 cycles (8190.2 us)
	SYSC_MOSCWTCR_MSTS_0x7 = 0x7
	// Wait time = 4291 cycles (16368.9 us)
	SYSC_MOSCWTCR_MSTS_0x8 = 0x8
	// Wait time = 8163 cycles (31139.4 us)
	SYSC_MOSCWTCR_MSTS_0x9 = 0x9

	// SOPCCR: Sub Operating Power Control Register
	// Position of SOPCM field.
	SYSC_SOPCCR_SOPCM_Pos = 0x0
	// Bit mask of SOPCM field.
	SYSC_SOPCCR_SOPCM_Msk = 0x1
	// Bit SOPCM.
	SYSC_SOPCCR_SOPCM = 0x1
	// Other than Subosc-speed mode
	SYSC_SOPCCR_SOPCM_0 = 0x0
	// Subosc-speed mode
	SYSC_SOPCCR_SOPCM_1 = 0x1
	// Position of SOPCMTSF field.
	SYSC_SOPCCR_SOPCMTSF_Pos = 0x4
	// Bit mask of SOPCMTSF field.
	SYSC_SOPCCR_SOPCMTSF_Msk = 0x10
	// Bit SOPCMTSF.
	SYSC_SOPCCR_SOPCMTSF = 0x10
	// Transition completed
	SYSC_SOPCCR_SOPCMTSF_0 = 0x0
	// During transition
	SYSC_SOPCCR_SOPCMTSF_1 = 0x1

	// RSTSR1: Reset Status Register 1
	// Position of IWDTRF field.
	SYSC_RSTSR1_IWDTRF_Pos = 0x0
	// Bit mask of IWDTRF field.
	SYSC_RSTSR1_IWDTRF_Msk = 0x1
	// Bit IWDTRF.
	SYSC_RSTSR1_IWDTRF = 0x1
	// Independent watchdog timer reset not detected
	SYSC_RSTSR1_IWDTRF_0 = 0x0
	// Independent watchdog timer reset detected
	SYSC_RSTSR1_IWDTRF_1 = 0x1
	// Position of WDTRF field.
	SYSC_RSTSR1_WDTRF_Pos = 0x1
	// Bit mask of WDTRF field.
	SYSC_RSTSR1_WDTRF_Msk = 0x2
	// Bit WDTRF.
	SYSC_RSTSR1_WDTRF = 0x2
	// Watchdog timer reset not detected
	SYSC_RSTSR1_WDTRF_0 = 0x0
	// Watchdog timer reset detected
	SYSC_RSTSR1_WDTRF_1 = 0x1
	// Position of SWRF field.
	SYSC_RSTSR1_SWRF_Pos = 0x2
	// Bit mask of SWRF field.
	SYSC_RSTSR1_SWRF_Msk = 0x4
	// Bit SWRF.
	SYSC_RSTSR1_SWRF = 0x4
	// Software reset not detected
	SYSC_RSTSR1_SWRF_0 = 0x0
	// Software reset detected
	SYSC_RSTSR1_SWRF_1 = 0x1
	// Position of RPERF field.
	SYSC_RSTSR1_RPERF_Pos = 0x8
	// Bit mask of RPERF field.
	SYSC_RSTSR1_RPERF_Msk = 0x100
	// Bit RPERF.
	SYSC_RSTSR1_RPERF = 0x100
	// SRAM parity error reset not detected
	SYSC_RSTSR1_RPERF_0 = 0x0
	// SRAM parity error reset detected
	SYSC_RSTSR1_RPERF_1 = 0x1
	// Position of BUSMRF field.
	SYSC_RSTSR1_BUSMRF_Pos = 0xb
	// Bit mask of BUSMRF field.
	SYSC_RSTSR1_BUSMRF_Msk = 0x800
	// Bit BUSMRF.
	SYSC_RSTSR1_BUSMRF = 0x800
	// Bus master MPU error reset not detected
	SYSC_RSTSR1_BUSMRF_0 = 0x0
	// Bus master MPU error reset detected
	SYSC_RSTSR1_BUSMRF_1 = 0x1
	// Position of TZERF field.
	SYSC_RSTSR1_TZERF_Pos = 0xd
	// Bit mask of TZERF field.
	SYSC_RSTSR1_TZERF_Msk = 0x2000
	// Bit TZERF.
	SYSC_RSTSR1_TZERF = 0x2000
	// TrustZone error reset not detected.
	SYSC_RSTSR1_TZERF_0 = 0x0
	// TrustZone error reset detected.
	SYSC_RSTSR1_TZERF_1 = 0x1
	// Position of CPERF field.
	SYSC_RSTSR1_CPERF_Pos = 0xf
	// Bit mask of CPERF field.
	SYSC_RSTSR1_CPERF_Msk = 0x8000
	// Bit CPERF.
	SYSC_RSTSR1_CPERF = 0x8000
	// Cache Parity error reset not detected.
	SYSC_RSTSR1_CPERF_0 = 0x0
	// Cache Parity error reset detected.
	SYSC_RSTSR1_CPERF_1 = 0x1

	// LVD1CR1: Voltage Monitor 1 Circuit Control Register
	// Position of IDTSEL field.
	SYSC_LVD1CR1_IDTSEL_Pos = 0x0
	// Bit mask of IDTSEL field.
	SYSC_LVD1CR1_IDTSEL_Msk = 0x3
	// When VCC >= Vdet1 (rise) is detected
	SYSC_LVD1CR1_IDTSEL_00 = 0x0
	// When VCC < Vdet1 (fall) is detected
	SYSC_LVD1CR1_IDTSEL_01 = 0x1
	// When fall and rise are detected
	SYSC_LVD1CR1_IDTSEL_10 = 0x2
	// Settings prohibited
	SYSC_LVD1CR1_IDTSEL_11 = 0x3
	// Position of IRQSEL field.
	SYSC_LVD1CR1_IRQSEL_Pos = 0x2
	// Bit mask of IRQSEL field.
	SYSC_LVD1CR1_IRQSEL_Msk = 0x4
	// Bit IRQSEL.
	SYSC_LVD1CR1_IRQSEL = 0x4
	// Non-maskable interrupt
	SYSC_LVD1CR1_IRQSEL_0 = 0x0
	// Maskable interrupt
	SYSC_LVD1CR1_IRQSEL_1 = 0x1

	// LVD1SR: Voltage Monitor 1 Circuit Status Register
	// Position of DET field.
	SYSC_LVD1SR_DET_Pos = 0x0
	// Bit mask of DET field.
	SYSC_LVD1SR_DET_Msk = 0x1
	// Bit DET.
	SYSC_LVD1SR_DET = 0x1
	// Not detected
	SYSC_LVD1SR_DET_0 = 0x0
	// Vdet1 crossing is detected
	SYSC_LVD1SR_DET_1 = 0x1
	// Position of MON field.
	SYSC_LVD1SR_MON_Pos = 0x1
	// Bit mask of MON field.
	SYSC_LVD1SR_MON_Msk = 0x2
	// Bit MON.
	SYSC_LVD1SR_MON = 0x2
	// VCC < Vdet1
	SYSC_LVD1SR_MON_0 = 0x0
	// VCC >= Vdet1 or MON is disabled
	SYSC_LVD1SR_MON_1 = 0x1

	// LVD2CR1: Voltage Monitor 2 Circuit Control Register 1
	// Position of IDTSEL field.
	SYSC_LVD2CR1_IDTSEL_Pos = 0x0
	// Bit mask of IDTSEL field.
	SYSC_LVD2CR1_IDTSEL_Msk = 0x3
	// When VCC>= Vdet2 (rise) is detected
	SYSC_LVD2CR1_IDTSEL_00 = 0x0
	// When VCC < Vdet2 (fall) is detected
	SYSC_LVD2CR1_IDTSEL_01 = 0x1
	// When fall and rise are detected
	SYSC_LVD2CR1_IDTSEL_10 = 0x2
	// Settings prohibited
	SYSC_LVD2CR1_IDTSEL_11 = 0x3
	// Position of IRQSEL field.
	SYSC_LVD2CR1_IRQSEL_Pos = 0x2
	// Bit mask of IRQSEL field.
	SYSC_LVD2CR1_IRQSEL_Msk = 0x4
	// Bit IRQSEL.
	SYSC_LVD2CR1_IRQSEL = 0x4
	// Non-maskable interrupt
	SYSC_LVD2CR1_IRQSEL_0 = 0x0
	// Maskable interrupt
	SYSC_LVD2CR1_IRQSEL_1 = 0x1

	// LVD2SR: Voltage Monitor 2 Circuit Status Register
	// Position of DET field.
	SYSC_LVD2SR_DET_Pos = 0x0
	// Bit mask of DET field.
	SYSC_LVD2SR_DET_Msk = 0x1
	// Bit DET.
	SYSC_LVD2SR_DET = 0x1
	// Not detected
	SYSC_LVD2SR_DET_0 = 0x0
	// Vdet2 crossing is detected
	SYSC_LVD2SR_DET_1 = 0x1
	// Position of MON field.
	SYSC_LVD2SR_MON_Pos = 0x1
	// Bit mask of MON field.
	SYSC_LVD2SR_MON_Msk = 0x2
	// Bit MON.
	SYSC_LVD2SR_MON = 0x2
	// VCC < Vdet2
	SYSC_LVD2SR_MON_0 = 0x0
	// VCC>= Vdet2 or MON is disabled
	SYSC_LVD2SR_MON_1 = 0x1

	// CGFSAR: Clock Generation Function Security Attribute Register
	// Position of NONSEC00 field.
	SYSC_CGFSAR_NONSEC00_Pos = 0x0
	// Bit mask of NONSEC00 field.
	SYSC_CGFSAR_NONSEC00_Msk = 0x1
	// Bit NONSEC00.
	SYSC_CGFSAR_NONSEC00 = 0x1
	// Secure
	SYSC_CGFSAR_NONSEC00_0 = 0x0
	// Non Secure
	SYSC_CGFSAR_NONSEC00_1 = 0x1
	// Position of NONSEC02 field.
	SYSC_CGFSAR_NONSEC02_Pos = 0x2
	// Bit mask of NONSEC02 field.
	SYSC_CGFSAR_NONSEC02_Msk = 0x4
	// Bit NONSEC02.
	SYSC_CGFSAR_NONSEC02 = 0x4
	// Secure
	SYSC_CGFSAR_NONSEC02_0 = 0x0
	// Non Secure
	SYSC_CGFSAR_NONSEC02_1 = 0x1
	// Position of NONSEC03 field.
	SYSC_CGFSAR_NONSEC03_Pos = 0x3
	// Bit mask of NONSEC03 field.
	SYSC_CGFSAR_NONSEC03_Msk = 0x8
	// Bit NONSEC03.
	SYSC_CGFSAR_NONSEC03 = 0x8
	// Secure
	SYSC_CGFSAR_NONSEC03_0 = 0x0
	// Non Secure
	SYSC_CGFSAR_NONSEC03_1 = 0x1
	// Position of NONSEC04 field.
	SYSC_CGFSAR_NONSEC04_Pos = 0x4
	// Bit mask of NONSEC04 field.
	SYSC_CGFSAR_NONSEC04_Msk = 0x10
	// Bit NONSEC04.
	SYSC_CGFSAR_NONSEC04 = 0x10
	// Secure
	SYSC_CGFSAR_NONSEC04_0 = 0x0
	// Non Secure
	SYSC_CGFSAR_NONSEC04_1 = 0x1
	// Position of NONSEC05 field.
	SYSC_CGFSAR_NONSEC05_Pos = 0x5
	// Bit mask of NONSEC05 field.
	SYSC_CGFSAR_NONSEC05_Msk = 0x20
	// Bit NONSEC05.
	SYSC_CGFSAR_NONSEC05 = 0x20
	// Secure
	SYSC_CGFSAR_NONSEC05_0 = 0x0
	// Non Secure
	SYSC_CGFSAR_NONSEC05_1 = 0x1
	// Position of NONSEC06 field.
	SYSC_CGFSAR_NONSEC06_Pos = 0x6
	// Bit mask of NONSEC06 field.
	SYSC_CGFSAR_NONSEC06_Msk = 0x40
	// Bit NONSEC06.
	SYSC_CGFSAR_NONSEC06 = 0x40
	// Secure
	SYSC_CGFSAR_NONSEC06_0 = 0x0
	// Non Secure
	SYSC_CGFSAR_NONSEC06_1 = 0x1
	// Position of NONSEC07 field.
	SYSC_CGFSAR_NONSEC07_Pos = 0x7
	// Bit mask of NONSEC07 field.
	SYSC_CGFSAR_NONSEC07_Msk = 0x80
	// Bit NONSEC07.
	SYSC_CGFSAR_NONSEC07 = 0x80
	// Secure
	SYSC_CGFSAR_NONSEC07_0 = 0x0
	// Non Secure
	SYSC_CGFSAR_NONSEC07_1 = 0x1
	// Position of NONSEC08 field.
	SYSC_CGFSAR_NONSEC08_Pos = 0x8
	// Bit mask of NONSEC08 field.
	SYSC_CGFSAR_NONSEC08_Msk = 0x100
	// Bit NONSEC08.
	SYSC_CGFSAR_NONSEC08 = 0x100
	// Secure
	SYSC_CGFSAR_NONSEC08_0 = 0x0
	// Non Secure
	SYSC_CGFSAR_NONSEC08_1 = 0x1
	// Position of NONSEC09 field.
	SYSC_CGFSAR_NONSEC09_Pos = 0x9
	// Bit mask of NONSEC09 field.
	SYSC_CGFSAR_NONSEC09_Msk = 0x200
	// Bit NONSEC09.
	SYSC_CGFSAR_NONSEC09 = 0x200
	// Secure
	SYSC_CGFSAR_NONSEC09_0 = 0x0
	// Non Secure
	SYSC_CGFSAR_NONSEC09_1 = 0x1
	// Position of NONSEC11 field.
	SYSC_CGFSAR_NONSEC11_Pos = 0xb
	// Bit mask of NONSEC11 field.
	SYSC_CGFSAR_NONSEC11_Msk = 0x800
	// Bit NONSEC11.
	SYSC_CGFSAR_NONSEC11 = 0x800
	// Secure
	SYSC_CGFSAR_NONSEC11_0 = 0x0
	// Non Secure
	SYSC_CGFSAR_NONSEC11_1 = 0x1
	// Position of NONSEC16 field.
	SYSC_CGFSAR_NONSEC16_Pos = 0x10
	// Bit mask of NONSEC16 field.
	SYSC_CGFSAR_NONSEC16_Msk = 0x10000
	// Bit NONSEC16.
	SYSC_CGFSAR_NONSEC16 = 0x10000
	// Secure
	SYSC_CGFSAR_NONSEC16_0 = 0x0
	// Non Secure
	SYSC_CGFSAR_NONSEC16_1 = 0x1

	// RSTSAR: Reset Security Attribution Register
	// Position of NONSEC0 field.
	SYSC_RSTSAR_NONSEC0_Pos = 0x0
	// Bit mask of NONSEC0 field.
	SYSC_RSTSAR_NONSEC0_Msk = 0x1
	// Bit NONSEC0.
	SYSC_RSTSAR_NONSEC0 = 0x1
	// Secure
	SYSC_RSTSAR_NONSEC0_0 = 0x0
	// Non Secure
	SYSC_RSTSAR_NONSEC0_1 = 0x1
	// Position of NONSEC1 field.
	SYSC_RSTSAR_NONSEC1_Pos = 0x1
	// Bit mask of NONSEC1 field.
	SYSC_RSTSAR_NONSEC1_Msk = 0x2
	// Bit NONSEC1.
	SYSC_RSTSAR_NONSEC1 = 0x2
	// Secure
	SYSC_RSTSAR_NONSEC1_0 = 0x0
	// Non Secure
	SYSC_RSTSAR_NONSEC1_1 = 0x1
	// Position of NONSEC2 field.
	SYSC_RSTSAR_NONSEC2_Pos = 0x2
	// Bit mask of NONSEC2 field.
	SYSC_RSTSAR_NONSEC2_Msk = 0x4
	// Bit NONSEC2.
	SYSC_RSTSAR_NONSEC2 = 0x4
	// Secure
	SYSC_RSTSAR_NONSEC2_0 = 0x0
	// Non Secure
	SYSC_RSTSAR_NONSEC2_1 = 0x1

	// LPMSAR: Low Power Mode Security Attribution Register
	// Position of NONSEC0 field.
	SYSC_LPMSAR_NONSEC0_Pos = 0x0
	// Bit mask of NONSEC0 field.
	SYSC_LPMSAR_NONSEC0_Msk = 0x1
	// Bit NONSEC0.
	SYSC_LPMSAR_NONSEC0 = 0x1
	// Secure
	SYSC_LPMSAR_NONSEC0_0 = 0x0
	// Non Secure
	SYSC_LPMSAR_NONSEC0_1 = 0x1
	// Position of NONSEC2 field.
	SYSC_LPMSAR_NONSEC2_Pos = 0x2
	// Bit mask of NONSEC2 field.
	SYSC_LPMSAR_NONSEC2_Msk = 0x4
	// Bit NONSEC2.
	SYSC_LPMSAR_NONSEC2 = 0x4
	// Secure
	SYSC_LPMSAR_NONSEC2_0 = 0x0
	// Non Secure
	SYSC_LPMSAR_NONSEC2_1 = 0x1
	// Position of NONSEC4 field.
	SYSC_LPMSAR_NONSEC4_Pos = 0x4
	// Bit mask of NONSEC4 field.
	SYSC_LPMSAR_NONSEC4_Msk = 0x10
	// Bit NONSEC4.
	SYSC_LPMSAR_NONSEC4 = 0x10
	// Secure
	SYSC_LPMSAR_NONSEC4_0 = 0x0
	// Non Secure
	SYSC_LPMSAR_NONSEC4_1 = 0x1
	// Position of NONSEC8 field.
	SYSC_LPMSAR_NONSEC8_Pos = 0x8
	// Bit mask of NONSEC8 field.
	SYSC_LPMSAR_NONSEC8_Msk = 0x100
	// Bit NONSEC8.
	SYSC_LPMSAR_NONSEC8 = 0x100
	// Secure
	SYSC_LPMSAR_NONSEC8_0 = 0x0
	// Non Secure
	SYSC_LPMSAR_NONSEC8_1 = 0x1
	// Position of NONSEC9 field.
	SYSC_LPMSAR_NONSEC9_Pos = 0x9
	// Bit mask of NONSEC9 field.
	SYSC_LPMSAR_NONSEC9_Msk = 0x200
	// Bit NONSEC9.
	SYSC_LPMSAR_NONSEC9 = 0x200
	// Secure
	SYSC_LPMSAR_NONSEC9_0 = 0x0
	// Non Secure
	SYSC_LPMSAR_NONSEC9_1 = 0x1

	// LVDSAR: Low Voltage Detection Security Attribution Register
	// Position of NONSEC0 field.
	SYSC_LVDSAR_NONSEC0_Pos = 0x0
	// Bit mask of NONSEC0 field.
	SYSC_LVDSAR_NONSEC0_Msk = 0x1
	// Bit NONSEC0.
	SYSC_LVDSAR_NONSEC0 = 0x1
	// Secure
	SYSC_LVDSAR_NONSEC0_0 = 0x0
	// Non Secure
	SYSC_LVDSAR_NONSEC0_1 = 0x1
	// Position of NONSEC1 field.
	SYSC_LVDSAR_NONSEC1_Pos = 0x1
	// Bit mask of NONSEC1 field.
	SYSC_LVDSAR_NONSEC1_Msk = 0x2
	// Bit NONSEC1.
	SYSC_LVDSAR_NONSEC1 = 0x2
	// Secure
	SYSC_LVDSAR_NONSEC1_0 = 0x0
	// Non Secure
	SYSC_LVDSAR_NONSEC1_1 = 0x1

	// BBFSAR: Battery Backup Function Security Attribute Register
	// Position of NONSEC0 field.
	SYSC_BBFSAR_NONSEC0_Pos = 0x0
	// Bit mask of NONSEC0 field.
	SYSC_BBFSAR_NONSEC0_Msk = 0x1
	// Bit NONSEC0.
	SYSC_BBFSAR_NONSEC0 = 0x1
	// Secure
	SYSC_BBFSAR_NONSEC0_0 = 0x0
	// Non Secure
	SYSC_BBFSAR_NONSEC0_1 = 0x1
	// Position of NONSEC1 field.
	SYSC_BBFSAR_NONSEC1_Pos = 0x1
	// Bit mask of NONSEC1 field.
	SYSC_BBFSAR_NONSEC1_Msk = 0x2
	// Bit NONSEC1.
	SYSC_BBFSAR_NONSEC1 = 0x2
	// Secure
	SYSC_BBFSAR_NONSEC1_0 = 0x0
	// Non Secure
	SYSC_BBFSAR_NONSEC1_1 = 0x1
	// Position of NONSEC2 field.
	SYSC_BBFSAR_NONSEC2_Pos = 0x2
	// Bit mask of NONSEC2 field.
	SYSC_BBFSAR_NONSEC2_Msk = 0x4
	// Bit NONSEC2.
	SYSC_BBFSAR_NONSEC2 = 0x4
	// Secure
	SYSC_BBFSAR_NONSEC2_0 = 0x0
	// Non Secure
	SYSC_BBFSAR_NONSEC2_1 = 0x1
	// Position of NONSEC16 field.
	SYSC_BBFSAR_NONSEC16_Pos = 0x10
	// Bit mask of NONSEC16 field.
	SYSC_BBFSAR_NONSEC16_Msk = 0x10000
	// Bit NONSEC16.
	SYSC_BBFSAR_NONSEC16 = 0x10000
	// Secure
	SYSC_BBFSAR_NONSEC16_0 = 0x0
	// Non Secure
	SYSC_BBFSAR_NONSEC16_1 = 0x1
	// Position of NONSEC17 field.
	SYSC_BBFSAR_NONSEC17_Pos = 0x11
	// Bit mask of NONSEC17 field.
	SYSC_BBFSAR_NONSEC17_Msk = 0x20000
	// Bit NONSEC17.
	SYSC_BBFSAR_NONSEC17 = 0x20000
	// Secure
	SYSC_BBFSAR_NONSEC17_0 = 0x0
	// Non Secure
	SYSC_BBFSAR_NONSEC17_1 = 0x1
	// Position of NONSEC18 field.
	SYSC_BBFSAR_NONSEC18_Pos = 0x12
	// Bit mask of NONSEC18 field.
	SYSC_BBFSAR_NONSEC18_Msk = 0x40000
	// Bit NONSEC18.
	SYSC_BBFSAR_NONSEC18 = 0x40000
	// Secure
	SYSC_BBFSAR_NONSEC18_0 = 0x0
	// Non Secure
	SYSC_BBFSAR_NONSEC18_1 = 0x1
	// Position of NONSEC19 field.
	SYSC_BBFSAR_NONSEC19_Pos = 0x13
	// Bit mask of NONSEC19 field.
	SYSC_BBFSAR_NONSEC19_Msk = 0x80000
	// Bit NONSEC19.
	SYSC_BBFSAR_NONSEC19 = 0x80000
	// Secure
	SYSC_BBFSAR_NONSEC19_0 = 0x0
	// Non Secure
	SYSC_BBFSAR_NONSEC19_1 = 0x1
	// Position of NONSEC20 field.
	SYSC_BBFSAR_NONSEC20_Pos = 0x14
	// Bit mask of NONSEC20 field.
	SYSC_BBFSAR_NONSEC20_Msk = 0x100000
	// Bit NONSEC20.
	SYSC_BBFSAR_NONSEC20 = 0x100000
	// Secure
	SYSC_BBFSAR_NONSEC20_0 = 0x0
	// Non Secure
	SYSC_BBFSAR_NONSEC20_1 = 0x1
	// Position of NONSEC21 field.
	SYSC_BBFSAR_NONSEC21_Pos = 0x15
	// Bit mask of NONSEC21 field.
	SYSC_BBFSAR_NONSEC21_Msk = 0x200000
	// Bit NONSEC21.
	SYSC_BBFSAR_NONSEC21 = 0x200000
	// Secure
	SYSC_BBFSAR_NONSEC21_0 = 0x0
	// Non Secure
	SYSC_BBFSAR_NONSEC21_1 = 0x1
	// Position of NONSEC22 field.
	SYSC_BBFSAR_NONSEC22_Pos = 0x16
	// Bit mask of NONSEC22 field.
	SYSC_BBFSAR_NONSEC22_Msk = 0x400000
	// Bit NONSEC22.
	SYSC_BBFSAR_NONSEC22 = 0x400000
	// Secure
	SYSC_BBFSAR_NONSEC22_0 = 0x0
	// Non Secure
	SYSC_BBFSAR_NONSEC22_1 = 0x1
	// Position of NONSEC23 field.
	SYSC_BBFSAR_NONSEC23_Pos = 0x17
	// Bit mask of NONSEC23 field.
	SYSC_BBFSAR_NONSEC23_Msk = 0x800000
	// Bit NONSEC23.
	SYSC_BBFSAR_NONSEC23 = 0x800000
	// Secure
	SYSC_BBFSAR_NONSEC23_0 = 0x0
	// Non Secure
	SYSC_BBFSAR_NONSEC23_1 = 0x1

	// DPFSAR: Deep Standby Interrupt Factor Security Attribution Register
	// Position of DPFSA00 field.
	SYSC_DPFSAR_DPFSA00_Pos = 0x0
	// Bit mask of DPFSA00 field.
	SYSC_DPFSAR_DPFSA00_Msk = 0x1
	// Bit DPFSA00.
	SYSC_DPFSAR_DPFSA00 = 0x1
	// Secure
	SYSC_DPFSAR_DPFSA00_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA00_1 = 0x1
	// Position of DPFSA01 field.
	SYSC_DPFSAR_DPFSA01_Pos = 0x1
	// Bit mask of DPFSA01 field.
	SYSC_DPFSAR_DPFSA01_Msk = 0x2
	// Bit DPFSA01.
	SYSC_DPFSAR_DPFSA01 = 0x2
	// Secure
	SYSC_DPFSAR_DPFSA01_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA01_1 = 0x1
	// Position of DPFSA04 field.
	SYSC_DPFSAR_DPFSA04_Pos = 0x4
	// Bit mask of DPFSA04 field.
	SYSC_DPFSAR_DPFSA04_Msk = 0x10
	// Bit DPFSA04.
	SYSC_DPFSAR_DPFSA04 = 0x10
	// Secure
	SYSC_DPFSAR_DPFSA04_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA04_1 = 0x1
	// Position of DPFSA05 field.
	SYSC_DPFSAR_DPFSA05_Pos = 0x5
	// Bit mask of DPFSA05 field.
	SYSC_DPFSAR_DPFSA05_Msk = 0x20
	// Bit DPFSA05.
	SYSC_DPFSAR_DPFSA05 = 0x20
	// Secure
	SYSC_DPFSAR_DPFSA05_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA05_1 = 0x1
	// Position of DPFSA06 field.
	SYSC_DPFSAR_DPFSA06_Pos = 0x6
	// Bit mask of DPFSA06 field.
	SYSC_DPFSAR_DPFSA06_Msk = 0x40
	// Bit DPFSA06.
	SYSC_DPFSAR_DPFSA06 = 0x40
	// Secure
	SYSC_DPFSAR_DPFSA06_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA06_1 = 0x1
	// Position of DPFSA07 field.
	SYSC_DPFSAR_DPFSA07_Pos = 0x7
	// Bit mask of DPFSA07 field.
	SYSC_DPFSAR_DPFSA07_Msk = 0x80
	// Bit DPFSA07.
	SYSC_DPFSAR_DPFSA07 = 0x80
	// Secure
	SYSC_DPFSAR_DPFSA07_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA07_1 = 0x1
	// Position of DPFSA08 field.
	SYSC_DPFSAR_DPFSA08_Pos = 0x8
	// Bit mask of DPFSA08 field.
	SYSC_DPFSAR_DPFSA08_Msk = 0x100
	// Bit DPFSA08.
	SYSC_DPFSAR_DPFSA08 = 0x100
	// Secure
	SYSC_DPFSAR_DPFSA08_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA08_1 = 0x1
	// Position of DPFSA09 field.
	SYSC_DPFSAR_DPFSA09_Pos = 0x9
	// Bit mask of DPFSA09 field.
	SYSC_DPFSAR_DPFSA09_Msk = 0x200
	// Bit DPFSA09.
	SYSC_DPFSAR_DPFSA09 = 0x200
	// Secure
	SYSC_DPFSAR_DPFSA09_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA09_1 = 0x1
	// Position of DPFSA10 field.
	SYSC_DPFSAR_DPFSA10_Pos = 0xa
	// Bit mask of DPFSA10 field.
	SYSC_DPFSAR_DPFSA10_Msk = 0x400
	// Bit DPFSA10.
	SYSC_DPFSAR_DPFSA10 = 0x400
	// Secure
	SYSC_DPFSAR_DPFSA10_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA10_1 = 0x1
	// Position of DPFSA11 field.
	SYSC_DPFSAR_DPFSA11_Pos = 0xb
	// Bit mask of DPFSA11 field.
	SYSC_DPFSAR_DPFSA11_Msk = 0x800
	// Bit DPFSA11.
	SYSC_DPFSAR_DPFSA11 = 0x800
	// Secure
	SYSC_DPFSAR_DPFSA11_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA11_1 = 0x1
	// Position of DPFSA12 field.
	SYSC_DPFSAR_DPFSA12_Pos = 0xc
	// Bit mask of DPFSA12 field.
	SYSC_DPFSAR_DPFSA12_Msk = 0x1000
	// Bit DPFSA12.
	SYSC_DPFSAR_DPFSA12 = 0x1000
	// Secure
	SYSC_DPFSAR_DPFSA12_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA12_1 = 0x1
	// Position of DPFSA14 field.
	SYSC_DPFSAR_DPFSA14_Pos = 0xe
	// Bit mask of DPFSA14 field.
	SYSC_DPFSAR_DPFSA14_Msk = 0x4000
	// Bit DPFSA14.
	SYSC_DPFSAR_DPFSA14 = 0x4000
	// Secure
	SYSC_DPFSAR_DPFSA14_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA14_1 = 0x1
	// Position of DPFSA15 field.
	SYSC_DPFSAR_DPFSA15_Pos = 0xf
	// Bit mask of DPFSA15 field.
	SYSC_DPFSAR_DPFSA15_Msk = 0x8000
	// Bit DPFSA15.
	SYSC_DPFSAR_DPFSA15 = 0x8000
	// Secure
	SYSC_DPFSAR_DPFSA15_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA15_1 = 0x1
	// Position of DPFSA16 field.
	SYSC_DPFSAR_DPFSA16_Pos = 0x10
	// Bit mask of DPFSA16 field.
	SYSC_DPFSAR_DPFSA16_Msk = 0x10000
	// Bit DPFSA16.
	SYSC_DPFSAR_DPFSA16 = 0x10000
	// Secure
	SYSC_DPFSAR_DPFSA16_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA16_1 = 0x1
	// Position of DPFSA17 field.
	SYSC_DPFSAR_DPFSA17_Pos = 0x11
	// Bit mask of DPFSA17 field.
	SYSC_DPFSAR_DPFSA17_Msk = 0x20000
	// Bit DPFSA17.
	SYSC_DPFSAR_DPFSA17 = 0x20000
	// Secure
	SYSC_DPFSAR_DPFSA17_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA17_1 = 0x1
	// Position of DPFSA18 field.
	SYSC_DPFSAR_DPFSA18_Pos = 0x12
	// Bit mask of DPFSA18 field.
	SYSC_DPFSAR_DPFSA18_Msk = 0x40000
	// Bit DPFSA18.
	SYSC_DPFSAR_DPFSA18 = 0x40000
	// Secure
	SYSC_DPFSAR_DPFSA18_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA18_1 = 0x1
	// Position of DPFSA19 field.
	SYSC_DPFSAR_DPFSA19_Pos = 0x13
	// Bit mask of DPFSA19 field.
	SYSC_DPFSAR_DPFSA19_Msk = 0x80000
	// Bit DPFSA19.
	SYSC_DPFSAR_DPFSA19 = 0x80000
	// Secure
	SYSC_DPFSAR_DPFSA19_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA19_1 = 0x1
	// Position of DPFSA20 field.
	SYSC_DPFSAR_DPFSA20_Pos = 0x14
	// Bit mask of DPFSA20 field.
	SYSC_DPFSAR_DPFSA20_Msk = 0x100000
	// Bit DPFSA20.
	SYSC_DPFSAR_DPFSA20 = 0x100000
	// Secure
	SYSC_DPFSAR_DPFSA20_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA20_1 = 0x1
	// Position of DPFSA24 field.
	SYSC_DPFSAR_DPFSA24_Pos = 0x18
	// Bit mask of DPFSA24 field.
	SYSC_DPFSAR_DPFSA24_Msk = 0x1000000
	// Bit DPFSA24.
	SYSC_DPFSAR_DPFSA24 = 0x1000000
	// Secure
	SYSC_DPFSAR_DPFSA24_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA24_1 = 0x1
	// Position of DPFSA26 field.
	SYSC_DPFSAR_DPFSA26_Pos = 0x1a
	// Bit mask of DPFSA26 field.
	SYSC_DPFSAR_DPFSA26_Msk = 0x4000000
	// Bit DPFSA26.
	SYSC_DPFSAR_DPFSA26 = 0x4000000
	// Secure
	SYSC_DPFSAR_DPFSA26_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA26_1 = 0x1
	// Position of DPFSA27 field.
	SYSC_DPFSAR_DPFSA27_Pos = 0x1b
	// Bit mask of DPFSA27 field.
	SYSC_DPFSAR_DPFSA27_Msk = 0x8000000
	// Bit DPFSA27.
	SYSC_DPFSAR_DPFSA27 = 0x8000000
	// Secure
	SYSC_DPFSAR_DPFSA27_0 = 0x0
	// Non Secure
	SYSC_DPFSAR_DPFSA27_1 = 0x1

	// PRCR: Protect Register
	// Position of PRC0 field.
	SYSC_PRCR_PRC0_Pos = 0x0
	// Bit mask of PRC0 field.
	SYSC_PRCR_PRC0_Msk = 0x1
	// Bit PRC0.
	SYSC_PRCR_PRC0 = 0x1
	// Disable writes
	SYSC_PRCR_PRC0_0 = 0x0
	// Enable writes
	SYSC_PRCR_PRC0_1 = 0x1
	// Position of PRC1 field.
	SYSC_PRCR_PRC1_Pos = 0x1
	// Bit mask of PRC1 field.
	SYSC_PRCR_PRC1_Msk = 0x2
	// Bit PRC1.
	SYSC_PRCR_PRC1 = 0x2
	// Disable writes
	SYSC_PRCR_PRC1_0 = 0x0
	// Enable writes
	SYSC_PRCR_PRC1_1 = 0x1
	// Position of PRC3 field.
	SYSC_PRCR_PRC3_Pos = 0x3
	// Bit mask of PRC3 field.
	SYSC_PRCR_PRC3_Msk = 0x8
	// Bit PRC3.
	SYSC_PRCR_PRC3 = 0x8
	// Disable writes
	SYSC_PRCR_PRC3_0 = 0x0
	// Enable writes
	SYSC_PRCR_PRC3_1 = 0x1
	// Position of PRC4 field.
	SYSC_PRCR_PRC4_Pos = 0x4
	// Bit mask of PRC4 field.
	SYSC_PRCR_PRC4_Msk = 0x10
	// Bit PRC4.
	SYSC_PRCR_PRC4 = 0x10
	// Disable writes
	SYSC_PRCR_PRC4_0 = 0x0
	// Enable writes
	SYSC_PRCR_PRC4_1 = 0x1
	// Position of PRKEY field.
	SYSC_PRCR_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	SYSC_PRCR_PRKEY_Msk = 0xff00

	// DPSBYCR: Deep Standby Control Register
	// Position of DEEPCUT field.
	SYSC_DPSBYCR_DEEPCUT_Pos = 0x0
	// Bit mask of DEEPCUT field.
	SYSC_DPSBYCR_DEEPCUT_Msk = 0x3
	// Power to the standby RAM, Low-speed on-chip oscillator, AGTn (n = 0 to 3), and USBFS resume detecting unit is supplied in Deep Software Standby mode.
	SYSC_DPSBYCR_DEEPCUT_00 = 0x0
	// Power to the standby RAM, Low-speed on-chip oscillator, AGT, and USBFS resume detecting unit is not supplied in Deep Software Standby mode.
	SYSC_DPSBYCR_DEEPCUT_01 = 0x1
	// Setting prohibited
	SYSC_DPSBYCR_DEEPCUT_10 = 0x2
	// Power to the standby RAM, Low-speed on-chip oscillator, AGT, and USBFS resume detecting unit is not supplied in Deep Software Standby mode. In addition, LVD is disabled and the low power function in a power-on reset circuit is enabled.
	SYSC_DPSBYCR_DEEPCUT_11 = 0x3
	// Position of IOKEEP field.
	SYSC_DPSBYCR_IOKEEP_Pos = 0x6
	// Bit mask of IOKEEP field.
	SYSC_DPSBYCR_IOKEEP_Msk = 0x40
	// Bit IOKEEP.
	SYSC_DPSBYCR_IOKEEP = 0x40
	// When the Deep Software Standby mode is canceled, the I/O ports are in the reset state.
	SYSC_DPSBYCR_IOKEEP_0 = 0x0
	// When the Deep Software Standby mode is canceled, the I/O ports are in the same state as in the Deep Software Standby mode.
	SYSC_DPSBYCR_IOKEEP_1 = 0x1
	// Position of DPSBY field.
	SYSC_DPSBYCR_DPSBY_Pos = 0x7
	// Bit mask of DPSBY field.
	SYSC_DPSBYCR_DPSBY_Msk = 0x80
	// Bit DPSBY.
	SYSC_DPSBYCR_DPSBY = 0x80
	// Sleep mode (SBYCR.SSBY=0) / Software Standby mode (SBYCR.SSBY=1)
	SYSC_DPSBYCR_DPSBY_0 = 0x0
	// Sleep mode (SBYCR.SSBY=0) / Deep Software Standby mode (SBYCR.SSBY=1)
	SYSC_DPSBYCR_DPSBY_1 = 0x1

	// DPSWCR: Deep Standby Wait Control Register
	// Position of WTSTS field.
	SYSC_DPSWCR_WTSTS_Pos = 0x0
	// Bit mask of WTSTS field.
	SYSC_DPSWCR_WTSTS_Msk = 0x3f
	// Wait cycle for fast recovery
	SYSC_DPSWCR_WTSTS_0x0E = 0xe
	// Wait cycle for slow recovery
	SYSC_DPSWCR_WTSTS_0x19 = 0x19

	// DPSIER0: Deep Standby Interrupt Enable Register 0
	// Position of DIRQ0E field.
	SYSC_DPSIER0_DIRQ0E_Pos = 0x0
	// Bit mask of DIRQ0E field.
	SYSC_DPSIER0_DIRQ0E_Msk = 0x1
	// Bit DIRQ0E.
	SYSC_DPSIER0_DIRQ0E = 0x1
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER0_DIRQ0E_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER0_DIRQ0E_1 = 0x1
	// Position of DIRQ1E field.
	SYSC_DPSIER0_DIRQ1E_Pos = 0x1
	// Bit mask of DIRQ1E field.
	SYSC_DPSIER0_DIRQ1E_Msk = 0x2
	// Bit DIRQ1E.
	SYSC_DPSIER0_DIRQ1E = 0x2
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER0_DIRQ1E_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER0_DIRQ1E_1 = 0x1
	// Position of DIRQ4E field.
	SYSC_DPSIER0_DIRQ4E_Pos = 0x4
	// Bit mask of DIRQ4E field.
	SYSC_DPSIER0_DIRQ4E_Msk = 0x10
	// Bit DIRQ4E.
	SYSC_DPSIER0_DIRQ4E = 0x10
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER0_DIRQ4E_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER0_DIRQ4E_1 = 0x1
	// Position of DIRQ5E field.
	SYSC_DPSIER0_DIRQ5E_Pos = 0x5
	// Bit mask of DIRQ5E field.
	SYSC_DPSIER0_DIRQ5E_Msk = 0x20
	// Bit DIRQ5E.
	SYSC_DPSIER0_DIRQ5E = 0x20
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER0_DIRQ5E_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER0_DIRQ5E_1 = 0x1
	// Position of DIRQ6E field.
	SYSC_DPSIER0_DIRQ6E_Pos = 0x6
	// Bit mask of DIRQ6E field.
	SYSC_DPSIER0_DIRQ6E_Msk = 0x40
	// Bit DIRQ6E.
	SYSC_DPSIER0_DIRQ6E = 0x40
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER0_DIRQ6E_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER0_DIRQ6E_1 = 0x1
	// Position of DIRQ7E field.
	SYSC_DPSIER0_DIRQ7E_Pos = 0x7
	// Bit mask of DIRQ7E field.
	SYSC_DPSIER0_DIRQ7E_Msk = 0x80
	// Bit DIRQ7E.
	SYSC_DPSIER0_DIRQ7E = 0x80
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER0_DIRQ7E_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER0_DIRQ7E_1 = 0x1

	// DPSIER1: Deep Standby Interrupt Enable Register 1
	// Position of DIRQ8E field.
	SYSC_DPSIER1_DIRQ8E_Pos = 0x0
	// Bit mask of DIRQ8E field.
	SYSC_DPSIER1_DIRQ8E_Msk = 0x1
	// Bit DIRQ8E.
	SYSC_DPSIER1_DIRQ8E = 0x1
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER1_DIRQ8E_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER1_DIRQ8E_1 = 0x1
	// Position of DIRQ9E field.
	SYSC_DPSIER1_DIRQ9E_Pos = 0x1
	// Bit mask of DIRQ9E field.
	SYSC_DPSIER1_DIRQ9E_Msk = 0x2
	// Bit DIRQ9E.
	SYSC_DPSIER1_DIRQ9E = 0x2
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER1_DIRQ9E_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER1_DIRQ9E_1 = 0x1
	// Position of DIRQ10E field.
	SYSC_DPSIER1_DIRQ10E_Pos = 0x2
	// Bit mask of DIRQ10E field.
	SYSC_DPSIER1_DIRQ10E_Msk = 0x4
	// Bit DIRQ10E.
	SYSC_DPSIER1_DIRQ10E = 0x4
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER1_DIRQ10E_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER1_DIRQ10E_1 = 0x1
	// Position of DIRQ11E field.
	SYSC_DPSIER1_DIRQ11E_Pos = 0x3
	// Bit mask of DIRQ11E field.
	SYSC_DPSIER1_DIRQ11E_Msk = 0x8
	// Bit DIRQ11E.
	SYSC_DPSIER1_DIRQ11E = 0x8
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER1_DIRQ11E_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER1_DIRQ11E_1 = 0x1
	// Position of DIRQ12E field.
	SYSC_DPSIER1_DIRQ12E_Pos = 0x4
	// Bit mask of DIRQ12E field.
	SYSC_DPSIER1_DIRQ12E_Msk = 0x10
	// Bit DIRQ12E.
	SYSC_DPSIER1_DIRQ12E = 0x10
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER1_DIRQ12E_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER1_DIRQ12E_1 = 0x1
	// Position of DIRQ14E field.
	SYSC_DPSIER1_DIRQ14E_Pos = 0x6
	// Bit mask of DIRQ14E field.
	SYSC_DPSIER1_DIRQ14E_Msk = 0x40
	// Bit DIRQ14E.
	SYSC_DPSIER1_DIRQ14E = 0x40
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER1_DIRQ14E_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER1_DIRQ14E_1 = 0x1
	// Position of DIRQ15E field.
	SYSC_DPSIER1_DIRQ15E_Pos = 0x7
	// Bit mask of DIRQ15E field.
	SYSC_DPSIER1_DIRQ15E_Msk = 0x80
	// Bit DIRQ15E.
	SYSC_DPSIER1_DIRQ15E = 0x80
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER1_DIRQ15E_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER1_DIRQ15E_1 = 0x1

	// DPSIER2: Deep Standby Interrupt Enable Register 2
	// Position of DLVD1IE field.
	SYSC_DPSIER2_DLVD1IE_Pos = 0x0
	// Bit mask of DLVD1IE field.
	SYSC_DPSIER2_DLVD1IE_Msk = 0x1
	// Bit DLVD1IE.
	SYSC_DPSIER2_DLVD1IE = 0x1
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER2_DLVD1IE_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER2_DLVD1IE_1 = 0x1
	// Position of DLVD2IE field.
	SYSC_DPSIER2_DLVD2IE_Pos = 0x1
	// Bit mask of DLVD2IE field.
	SYSC_DPSIER2_DLVD2IE_Msk = 0x2
	// Bit DLVD2IE.
	SYSC_DPSIER2_DLVD2IE = 0x2
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER2_DLVD2IE_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER2_DLVD2IE_1 = 0x1
	// Position of DRTCIIE field.
	SYSC_DPSIER2_DRTCIIE_Pos = 0x2
	// Bit mask of DRTCIIE field.
	SYSC_DPSIER2_DRTCIIE_Msk = 0x4
	// Bit DRTCIIE.
	SYSC_DPSIER2_DRTCIIE = 0x4
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER2_DRTCIIE_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER2_DRTCIIE_1 = 0x1
	// Position of DRTCAIE field.
	SYSC_DPSIER2_DRTCAIE_Pos = 0x3
	// Bit mask of DRTCAIE field.
	SYSC_DPSIER2_DRTCAIE_Msk = 0x8
	// Bit DRTCAIE.
	SYSC_DPSIER2_DRTCAIE = 0x8
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER2_DRTCAIE_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER2_DRTCAIE_1 = 0x1
	// Position of DNMIE field.
	SYSC_DPSIER2_DNMIE_Pos = 0x4
	// Bit mask of DNMIE field.
	SYSC_DPSIER2_DNMIE_Msk = 0x10
	// Bit DNMIE.
	SYSC_DPSIER2_DNMIE = 0x10
	// Cancelling Deep Software Standby mode is disabled
	SYSC_DPSIER2_DNMIE_0 = 0x0
	// Cancelling Deep Software Standby mode is enabled
	SYSC_DPSIER2_DNMIE_1 = 0x1

	// DPSIER3: Deep Standby Interrupt Enable Register 3
	// Position of DUSBFS0IE field.
	SYSC_DPSIER3_DUSBFS0IE_Pos = 0x0
	// Bit mask of DUSBFS0IE field.
	SYSC_DPSIER3_DUSBFS0IE_Msk = 0x1
	// Bit DUSBFS0IE.
	SYSC_DPSIER3_DUSBFS0IE = 0x1
	// Cancelling deep standby mode is disabled
	SYSC_DPSIER3_DUSBFS0IE_0 = 0x0
	// Cancelling deep standby mode is enabled
	SYSC_DPSIER3_DUSBFS0IE_1 = 0x1
	// Position of DAGT1IE field.
	SYSC_DPSIER3_DAGT1IE_Pos = 0x2
	// Bit mask of DAGT1IE field.
	SYSC_DPSIER3_DAGT1IE_Msk = 0x4
	// Bit DAGT1IE.
	SYSC_DPSIER3_DAGT1IE = 0x4
	// Cancelling deep standby mode is disabled
	SYSC_DPSIER3_DAGT1IE_0 = 0x0
	// Cancelling deep standby mode is enabled
	SYSC_DPSIER3_DAGT1IE_1 = 0x1
	// Position of DAGT3IE field.
	SYSC_DPSIER3_DAGT3IE_Pos = 0x3
	// Bit mask of DAGT3IE field.
	SYSC_DPSIER3_DAGT3IE_Msk = 0x8
	// Bit DAGT3IE.
	SYSC_DPSIER3_DAGT3IE = 0x8
	// Cancelling deep standby mode is disabled
	SYSC_DPSIER3_DAGT3IE_0 = 0x0
	// Cancelling deep standby mode is enabled
	SYSC_DPSIER3_DAGT3IE_1 = 0x1

	// DPSIFR0: Deep Standby Interrupt Flag Register 0
	// Position of DIRQ0F field.
	SYSC_DPSIFR0_DIRQ0F_Pos = 0x0
	// Bit mask of DIRQ0F field.
	SYSC_DPSIFR0_DIRQ0F_Msk = 0x1
	// Bit DIRQ0F.
	SYSC_DPSIFR0_DIRQ0F = 0x1
	// The cancel request is not generated
	SYSC_DPSIFR0_DIRQ0F_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR0_DIRQ0F_1 = 0x1
	// Position of DIRQ1F field.
	SYSC_DPSIFR0_DIRQ1F_Pos = 0x1
	// Bit mask of DIRQ1F field.
	SYSC_DPSIFR0_DIRQ1F_Msk = 0x2
	// Bit DIRQ1F.
	SYSC_DPSIFR0_DIRQ1F = 0x2
	// The cancel request is not generated
	SYSC_DPSIFR0_DIRQ1F_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR0_DIRQ1F_1 = 0x1
	// Position of DIRQ4F field.
	SYSC_DPSIFR0_DIRQ4F_Pos = 0x4
	// Bit mask of DIRQ4F field.
	SYSC_DPSIFR0_DIRQ4F_Msk = 0x10
	// Bit DIRQ4F.
	SYSC_DPSIFR0_DIRQ4F = 0x10
	// The cancel request is not generated
	SYSC_DPSIFR0_DIRQ4F_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR0_DIRQ4F_1 = 0x1
	// Position of DIRQ5F field.
	SYSC_DPSIFR0_DIRQ5F_Pos = 0x5
	// Bit mask of DIRQ5F field.
	SYSC_DPSIFR0_DIRQ5F_Msk = 0x20
	// Bit DIRQ5F.
	SYSC_DPSIFR0_DIRQ5F = 0x20
	// The cancel request is not generated
	SYSC_DPSIFR0_DIRQ5F_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR0_DIRQ5F_1 = 0x1
	// Position of DIRQ6F field.
	SYSC_DPSIFR0_DIRQ6F_Pos = 0x6
	// Bit mask of DIRQ6F field.
	SYSC_DPSIFR0_DIRQ6F_Msk = 0x40
	// Bit DIRQ6F.
	SYSC_DPSIFR0_DIRQ6F = 0x40
	// The cancel request is not generated
	SYSC_DPSIFR0_DIRQ6F_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR0_DIRQ6F_1 = 0x1
	// Position of DIRQ7F field.
	SYSC_DPSIFR0_DIRQ7F_Pos = 0x7
	// Bit mask of DIRQ7F field.
	SYSC_DPSIFR0_DIRQ7F_Msk = 0x80
	// Bit DIRQ7F.
	SYSC_DPSIFR0_DIRQ7F = 0x80
	// The cancel request is not generated
	SYSC_DPSIFR0_DIRQ7F_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR0_DIRQ7F_1 = 0x1

	// DPSIFR1: Deep Standby Interrupt Flag Register 1
	// Position of DIRQ8F field.
	SYSC_DPSIFR1_DIRQ8F_Pos = 0x0
	// Bit mask of DIRQ8F field.
	SYSC_DPSIFR1_DIRQ8F_Msk = 0x1
	// Bit DIRQ8F.
	SYSC_DPSIFR1_DIRQ8F = 0x1
	// The cancel request is not generated
	SYSC_DPSIFR1_DIRQ8F_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR1_DIRQ8F_1 = 0x1
	// Position of DIRQ9F field.
	SYSC_DPSIFR1_DIRQ9F_Pos = 0x1
	// Bit mask of DIRQ9F field.
	SYSC_DPSIFR1_DIRQ9F_Msk = 0x2
	// Bit DIRQ9F.
	SYSC_DPSIFR1_DIRQ9F = 0x2
	// The cancel request is not generated
	SYSC_DPSIFR1_DIRQ9F_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR1_DIRQ9F_1 = 0x1
	// Position of DIRQ10F field.
	SYSC_DPSIFR1_DIRQ10F_Pos = 0x2
	// Bit mask of DIRQ10F field.
	SYSC_DPSIFR1_DIRQ10F_Msk = 0x4
	// Bit DIRQ10F.
	SYSC_DPSIFR1_DIRQ10F = 0x4
	// The cancel request is not generated
	SYSC_DPSIFR1_DIRQ10F_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR1_DIRQ10F_1 = 0x1
	// Position of DIRQ11F field.
	SYSC_DPSIFR1_DIRQ11F_Pos = 0x3
	// Bit mask of DIRQ11F field.
	SYSC_DPSIFR1_DIRQ11F_Msk = 0x8
	// Bit DIRQ11F.
	SYSC_DPSIFR1_DIRQ11F = 0x8
	// The cancel request is not generated
	SYSC_DPSIFR1_DIRQ11F_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR1_DIRQ11F_1 = 0x1
	// Position of DIRQ12F field.
	SYSC_DPSIFR1_DIRQ12F_Pos = 0x4
	// Bit mask of DIRQ12F field.
	SYSC_DPSIFR1_DIRQ12F_Msk = 0x10
	// Bit DIRQ12F.
	SYSC_DPSIFR1_DIRQ12F = 0x10
	// The cancel request is not generated
	SYSC_DPSIFR1_DIRQ12F_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR1_DIRQ12F_1 = 0x1
	// Position of DIRQ14F field.
	SYSC_DPSIFR1_DIRQ14F_Pos = 0x6
	// Bit mask of DIRQ14F field.
	SYSC_DPSIFR1_DIRQ14F_Msk = 0x40
	// Bit DIRQ14F.
	SYSC_DPSIFR1_DIRQ14F = 0x40
	// The cancel request is not generated
	SYSC_DPSIFR1_DIRQ14F_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR1_DIRQ14F_1 = 0x1
	// Position of DIRQ15F field.
	SYSC_DPSIFR1_DIRQ15F_Pos = 0x7
	// Bit mask of DIRQ15F field.
	SYSC_DPSIFR1_DIRQ15F_Msk = 0x80
	// Bit DIRQ15F.
	SYSC_DPSIFR1_DIRQ15F = 0x80
	// The cancel request is not generated
	SYSC_DPSIFR1_DIRQ15F_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR1_DIRQ15F_1 = 0x1

	// DPSIFR2: Deep Standby Interrupt Flag Register 2
	// Position of DLVD1IF field.
	SYSC_DPSIFR2_DLVD1IF_Pos = 0x0
	// Bit mask of DLVD1IF field.
	SYSC_DPSIFR2_DLVD1IF_Msk = 0x1
	// Bit DLVD1IF.
	SYSC_DPSIFR2_DLVD1IF = 0x1
	// The cancel request is not generated
	SYSC_DPSIFR2_DLVD1IF_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR2_DLVD1IF_1 = 0x1
	// Position of DLVD2IF field.
	SYSC_DPSIFR2_DLVD2IF_Pos = 0x1
	// Bit mask of DLVD2IF field.
	SYSC_DPSIFR2_DLVD2IF_Msk = 0x2
	// Bit DLVD2IF.
	SYSC_DPSIFR2_DLVD2IF = 0x2
	// The cancel request is not generated
	SYSC_DPSIFR2_DLVD2IF_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR2_DLVD2IF_1 = 0x1
	// Position of DRTCIIF field.
	SYSC_DPSIFR2_DRTCIIF_Pos = 0x2
	// Bit mask of DRTCIIF field.
	SYSC_DPSIFR2_DRTCIIF_Msk = 0x4
	// Bit DRTCIIF.
	SYSC_DPSIFR2_DRTCIIF = 0x4
	// The cancel request is not generated
	SYSC_DPSIFR2_DRTCIIF_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR2_DRTCIIF_1 = 0x1
	// Position of DRTCAIF field.
	SYSC_DPSIFR2_DRTCAIF_Pos = 0x3
	// Bit mask of DRTCAIF field.
	SYSC_DPSIFR2_DRTCAIF_Msk = 0x8
	// Bit DRTCAIF.
	SYSC_DPSIFR2_DRTCAIF = 0x8
	// The cancel request is not generated
	SYSC_DPSIFR2_DRTCAIF_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR2_DRTCAIF_1 = 0x1
	// Position of DNMIF field.
	SYSC_DPSIFR2_DNMIF_Pos = 0x4
	// Bit mask of DNMIF field.
	SYSC_DPSIFR2_DNMIF_Msk = 0x10
	// Bit DNMIF.
	SYSC_DPSIFR2_DNMIF = 0x10
	// The cancel request is not generated
	SYSC_DPSIFR2_DNMIF_0 = 0x0
	// The cancel request is generated
	SYSC_DPSIFR2_DNMIF_1 = 0x1

	// DPSIFR3: Deep Standby Interrupt Flag Register 3
	// Position of DUSBFS0IF field.
	SYSC_DPSIFR3_DUSBFS0IF_Pos = 0x0
	// Bit mask of DUSBFS0IF field.
	SYSC_DPSIFR3_DUSBFS0IF_Msk = 0x1
	// Bit DUSBFS0IF.
	SYSC_DPSIFR3_DUSBFS0IF = 0x1
	// The cancel request is not generated.
	SYSC_DPSIFR3_DUSBFS0IF_0 = 0x0
	// The cancel request is generated.
	SYSC_DPSIFR3_DUSBFS0IF_1 = 0x1
	// Position of DAGT1IF field.
	SYSC_DPSIFR3_DAGT1IF_Pos = 0x2
	// Bit mask of DAGT1IF field.
	SYSC_DPSIFR3_DAGT1IF_Msk = 0x4
	// Bit DAGT1IF.
	SYSC_DPSIFR3_DAGT1IF = 0x4
	// The cancel request is not generated.
	SYSC_DPSIFR3_DAGT1IF_0 = 0x0
	// The cancel request is generated.
	SYSC_DPSIFR3_DAGT1IF_1 = 0x1
	// Position of DAGT3IF field.
	SYSC_DPSIFR3_DAGT3IF_Pos = 0x3
	// Bit mask of DAGT3IF field.
	SYSC_DPSIFR3_DAGT3IF_Msk = 0x8
	// Bit DAGT3IF.
	SYSC_DPSIFR3_DAGT3IF = 0x8
	// The cancel request is not generated.
	SYSC_DPSIFR3_DAGT3IF_0 = 0x0
	// The cancel request is generated.
	SYSC_DPSIFR3_DAGT3IF_1 = 0x1

	// DPSIEGR0: Deep Standby Interrupt Edge Register 0
	// Position of DIRQ0EG field.
	SYSC_DPSIEGR0_DIRQ0EG_Pos = 0x0
	// Bit mask of DIRQ0EG field.
	SYSC_DPSIEGR0_DIRQ0EG_Msk = 0x1
	// Bit DIRQ0EG.
	SYSC_DPSIEGR0_DIRQ0EG = 0x1
	// A cancel request is generated at a falling edge
	SYSC_DPSIEGR0_DIRQ0EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSC_DPSIEGR0_DIRQ0EG_1 = 0x1
	// Position of DIRQ1EG field.
	SYSC_DPSIEGR0_DIRQ1EG_Pos = 0x1
	// Bit mask of DIRQ1EG field.
	SYSC_DPSIEGR0_DIRQ1EG_Msk = 0x2
	// Bit DIRQ1EG.
	SYSC_DPSIEGR0_DIRQ1EG = 0x2
	// A cancel request is generated at a falling edge
	SYSC_DPSIEGR0_DIRQ1EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSC_DPSIEGR0_DIRQ1EG_1 = 0x1
	// Position of DIRQ4EG field.
	SYSC_DPSIEGR0_DIRQ4EG_Pos = 0x4
	// Bit mask of DIRQ4EG field.
	SYSC_DPSIEGR0_DIRQ4EG_Msk = 0x10
	// Bit DIRQ4EG.
	SYSC_DPSIEGR0_DIRQ4EG = 0x10
	// A cancel request is generated at a falling edge
	SYSC_DPSIEGR0_DIRQ4EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSC_DPSIEGR0_DIRQ4EG_1 = 0x1
	// Position of DIRQ5EG field.
	SYSC_DPSIEGR0_DIRQ5EG_Pos = 0x5
	// Bit mask of DIRQ5EG field.
	SYSC_DPSIEGR0_DIRQ5EG_Msk = 0x20
	// Bit DIRQ5EG.
	SYSC_DPSIEGR0_DIRQ5EG = 0x20
	// A cancel request is generated at a falling edge
	SYSC_DPSIEGR0_DIRQ5EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSC_DPSIEGR0_DIRQ5EG_1 = 0x1
	// Position of DIRQ6EG field.
	SYSC_DPSIEGR0_DIRQ6EG_Pos = 0x6
	// Bit mask of DIRQ6EG field.
	SYSC_DPSIEGR0_DIRQ6EG_Msk = 0x40
	// Bit DIRQ6EG.
	SYSC_DPSIEGR0_DIRQ6EG = 0x40
	// A cancel request is generated at a falling edge
	SYSC_DPSIEGR0_DIRQ6EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSC_DPSIEGR0_DIRQ6EG_1 = 0x1
	// Position of DIRQ7EG field.
	SYSC_DPSIEGR0_DIRQ7EG_Pos = 0x7
	// Bit mask of DIRQ7EG field.
	SYSC_DPSIEGR0_DIRQ7EG_Msk = 0x80
	// Bit DIRQ7EG.
	SYSC_DPSIEGR0_DIRQ7EG = 0x80
	// A cancel request is generated at a falling edge
	SYSC_DPSIEGR0_DIRQ7EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSC_DPSIEGR0_DIRQ7EG_1 = 0x1

	// DPSIEGR1: Deep Standby Interrupt Edge Register 1
	// Position of DIRQ8EG field.
	SYSC_DPSIEGR1_DIRQ8EG_Pos = 0x0
	// Bit mask of DIRQ8EG field.
	SYSC_DPSIEGR1_DIRQ8EG_Msk = 0x1
	// Bit DIRQ8EG.
	SYSC_DPSIEGR1_DIRQ8EG = 0x1
	// A cancel request is generated at a falling edge.
	SYSC_DPSIEGR1_DIRQ8EG_0 = 0x0
	// A cancel request is generated at a rising edge.
	SYSC_DPSIEGR1_DIRQ8EG_1 = 0x1
	// Position of DIRQ9EG field.
	SYSC_DPSIEGR1_DIRQ9EG_Pos = 0x1
	// Bit mask of DIRQ9EG field.
	SYSC_DPSIEGR1_DIRQ9EG_Msk = 0x2
	// Bit DIRQ9EG.
	SYSC_DPSIEGR1_DIRQ9EG = 0x2
	// A cancel request is generated at a falling edge.
	SYSC_DPSIEGR1_DIRQ9EG_0 = 0x0
	// A cancel request is generated at a rising edge.
	SYSC_DPSIEGR1_DIRQ9EG_1 = 0x1
	// Position of DIRQ10EG field.
	SYSC_DPSIEGR1_DIRQ10EG_Pos = 0x2
	// Bit mask of DIRQ10EG field.
	SYSC_DPSIEGR1_DIRQ10EG_Msk = 0x4
	// Bit DIRQ10EG.
	SYSC_DPSIEGR1_DIRQ10EG = 0x4
	// A cancel request is generated at a falling edge.
	SYSC_DPSIEGR1_DIRQ10EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSC_DPSIEGR1_DIRQ10EG_1 = 0x1
	// Position of DIRQ11EG field.
	SYSC_DPSIEGR1_DIRQ11EG_Pos = 0x3
	// Bit mask of DIRQ11EG field.
	SYSC_DPSIEGR1_DIRQ11EG_Msk = 0x8
	// Bit DIRQ11EG.
	SYSC_DPSIEGR1_DIRQ11EG = 0x8
	// A cancel request is generated at a falling edge.
	SYSC_DPSIEGR1_DIRQ11EG_0 = 0x0
	// A cancel request is generated at a rising edge.
	SYSC_DPSIEGR1_DIRQ11EG_1 = 0x1
	// Position of DIRQ12EG field.
	SYSC_DPSIEGR1_DIRQ12EG_Pos = 0x4
	// Bit mask of DIRQ12EG field.
	SYSC_DPSIEGR1_DIRQ12EG_Msk = 0x10
	// Bit DIRQ12EG.
	SYSC_DPSIEGR1_DIRQ12EG = 0x10
	// A cancel request is generated at a falling edge.
	SYSC_DPSIEGR1_DIRQ12EG_0 = 0x0
	// A cancel request is generated at a rising edge.
	SYSC_DPSIEGR1_DIRQ12EG_1 = 0x1
	// Position of DIRQ14EG field.
	SYSC_DPSIEGR1_DIRQ14EG_Pos = 0x6
	// Bit mask of DIRQ14EG field.
	SYSC_DPSIEGR1_DIRQ14EG_Msk = 0x40
	// Bit DIRQ14EG.
	SYSC_DPSIEGR1_DIRQ14EG = 0x40
	// A cancel request is generated at a falling edge.
	SYSC_DPSIEGR1_DIRQ14EG_0 = 0x0
	// A cancel request is generated at a rising edge.
	SYSC_DPSIEGR1_DIRQ14EG_1 = 0x1
	// Position of DIRQ15EG field.
	SYSC_DPSIEGR1_DIRQ15EG_Pos = 0x7
	// Bit mask of DIRQ15EG field.
	SYSC_DPSIEGR1_DIRQ15EG_Msk = 0x80
	// Bit DIRQ15EG.
	SYSC_DPSIEGR1_DIRQ15EG = 0x80
	// A cancel request is generated at a falling edge.
	SYSC_DPSIEGR1_DIRQ15EG_0 = 0x0
	// A cancel request is generated at a rising edge.
	SYSC_DPSIEGR1_DIRQ15EG_1 = 0x1

	// DPSIEGR2: Deep Standby Interrupt Edge Register 2
	// Position of DLVD1EG field.
	SYSC_DPSIEGR2_DLVD1EG_Pos = 0x0
	// Bit mask of DLVD1EG field.
	SYSC_DPSIEGR2_DLVD1EG_Msk = 0x1
	// Bit DLVD1EG.
	SYSC_DPSIEGR2_DLVD1EG = 0x1
	// A cancel request is generated when VCC < Vdet1 (fall) is detected
	SYSC_DPSIEGR2_DLVD1EG_0 = 0x0
	// A cancel request is generated when VCC ≥ Vdet1 (rise) is detected
	SYSC_DPSIEGR2_DLVD1EG_1 = 0x1
	// Position of DLVD2EG field.
	SYSC_DPSIEGR2_DLVD2EG_Pos = 0x1
	// Bit mask of DLVD2EG field.
	SYSC_DPSIEGR2_DLVD2EG_Msk = 0x2
	// Bit DLVD2EG.
	SYSC_DPSIEGR2_DLVD2EG = 0x2
	// A cancel request is generated when VCC < Vdet2 (fall) is detected
	SYSC_DPSIEGR2_DLVD2EG_0 = 0x0
	// A cancel request is generated when VCC ≥ Vdet2 (rise) is detected
	SYSC_DPSIEGR2_DLVD2EG_1 = 0x1
	// Position of DNMIEG field.
	SYSC_DPSIEGR2_DNMIEG_Pos = 0x4
	// Bit mask of DNMIEG field.
	SYSC_DPSIEGR2_DNMIEG_Msk = 0x10
	// Bit DNMIEG.
	SYSC_DPSIEGR2_DNMIEG = 0x10
	// A cancel request is generated at a falling edge
	SYSC_DPSIEGR2_DNMIEG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSC_DPSIEGR2_DNMIEG_1 = 0x1

	// SYOCDCR: System Control OCD Control Register
	// Position of DOCDF field.
	SYSC_SYOCDCR_DOCDF_Pos = 0x0
	// Bit mask of DOCDF field.
	SYSC_SYOCDCR_DOCDF_Msk = 0x1
	// Bit DOCDF.
	SYSC_SYOCDCR_DOCDF = 0x1
	// DBIRQ is not generated
	SYSC_SYOCDCR_DOCDF_0 = 0x0
	// DBIRQ is generated
	SYSC_SYOCDCR_DOCDF_1 = 0x1
	// Position of DBGEN field.
	SYSC_SYOCDCR_DBGEN_Pos = 0x7
	// Bit mask of DBGEN field.
	SYSC_SYOCDCR_DBGEN_Msk = 0x80
	// Bit DBGEN.
	SYSC_SYOCDCR_DBGEN = 0x80
	// On-chip debugger is disabled
	SYSC_SYOCDCR_DBGEN_0 = 0x0
	// On-chip debugger is enabled
	SYSC_SYOCDCR_DBGEN_1 = 0x1

	// RSTSR0: Reset Status Register 0
	// Position of PORF field.
	SYSC_RSTSR0_PORF_Pos = 0x0
	// Bit mask of PORF field.
	SYSC_RSTSR0_PORF_Msk = 0x1
	// Bit PORF.
	SYSC_RSTSR0_PORF = 0x1
	// Power-on reset not detected
	SYSC_RSTSR0_PORF_0 = 0x0
	// Power-on reset detected
	SYSC_RSTSR0_PORF_1 = 0x1
	// Position of LVD0RF field.
	SYSC_RSTSR0_LVD0RF_Pos = 0x1
	// Bit mask of LVD0RF field.
	SYSC_RSTSR0_LVD0RF_Msk = 0x2
	// Bit LVD0RF.
	SYSC_RSTSR0_LVD0RF = 0x2
	// Voltage monitor 0 reset not detected
	SYSC_RSTSR0_LVD0RF_0 = 0x0
	// Voltage monitor 0 reset detected
	SYSC_RSTSR0_LVD0RF_1 = 0x1
	// Position of LVD1RF field.
	SYSC_RSTSR0_LVD1RF_Pos = 0x2
	// Bit mask of LVD1RF field.
	SYSC_RSTSR0_LVD1RF_Msk = 0x4
	// Bit LVD1RF.
	SYSC_RSTSR0_LVD1RF = 0x4
	// Voltage monitor 1 reset not detected
	SYSC_RSTSR0_LVD1RF_0 = 0x0
	// Voltage monitor 1 reset detected
	SYSC_RSTSR0_LVD1RF_1 = 0x1
	// Position of LVD2RF field.
	SYSC_RSTSR0_LVD2RF_Pos = 0x3
	// Bit mask of LVD2RF field.
	SYSC_RSTSR0_LVD2RF_Msk = 0x8
	// Bit LVD2RF.
	SYSC_RSTSR0_LVD2RF = 0x8
	// Voltage monitor 2 reset not detected
	SYSC_RSTSR0_LVD2RF_0 = 0x0
	// Voltage monitor 2 reset detected
	SYSC_RSTSR0_LVD2RF_1 = 0x1
	// Position of DPSRSTF field.
	SYSC_RSTSR0_DPSRSTF_Pos = 0x7
	// Bit mask of DPSRSTF field.
	SYSC_RSTSR0_DPSRSTF_Msk = 0x80
	// Bit DPSRSTF.
	SYSC_RSTSR0_DPSRSTF = 0x80
	// Deep software standby mode cancellation not requested by an interrupt.
	SYSC_RSTSR0_DPSRSTF_0 = 0x0
	// Deep software standby mode cancellation requested by an interrupt.
	SYSC_RSTSR0_DPSRSTF_1 = 0x1

	// RSTSR2: Reset Status Register 2
	// Position of CWSF field.
	SYSC_RSTSR2_CWSF_Pos = 0x0
	// Bit mask of CWSF field.
	SYSC_RSTSR2_CWSF_Msk = 0x1
	// Bit CWSF.
	SYSC_RSTSR2_CWSF = 0x1
	// Cold start
	SYSC_RSTSR2_CWSF_0 = 0x0
	// Warm start
	SYSC_RSTSR2_CWSF_1 = 0x1

	// MOMCR: Main Clock Oscillator Mode Oscillation Control Register
	// Position of MODRV field.
	SYSC_MOMCR_MODRV_Pos = 0x4
	// Bit mask of MODRV field.
	SYSC_MOMCR_MODRV_Msk = 0x30
	// 20 MHz to 24 MHz
	SYSC_MOMCR_MODRV_00 = 0x0
	// 16 MHz to 20 MHz
	SYSC_MOMCR_MODRV_01 = 0x1
	// 8 MHz to 16 MHz
	SYSC_MOMCR_MODRV_10 = 0x2
	// 8 MHz
	SYSC_MOMCR_MODRV_11 = 0x3
	// Position of MOSEL field.
	SYSC_MOMCR_MOSEL_Pos = 0x6
	// Bit mask of MOSEL field.
	SYSC_MOMCR_MOSEL_Msk = 0x40
	// Bit MOSEL.
	SYSC_MOMCR_MOSEL = 0x40
	// Resonator
	SYSC_MOMCR_MOSEL_0 = 0x0
	// External clock input
	SYSC_MOMCR_MOSEL_1 = 0x1

	// FWEPROR: Flash P/E Protect Register
	// Position of FLWE field.
	SYSC_FWEPROR_FLWE_Pos = 0x0
	// Bit mask of FLWE field.
	SYSC_FWEPROR_FLWE_Msk = 0x3
	// Prohibits Program, Block Erase, Multi Block Erase, Blank Check, and Configuration set command processing.
	SYSC_FWEPROR_FLWE_00 = 0x0
	// Permits Program, Block Erase, Multi Block Erase, Blank Check, and Configuration set command processing.
	SYSC_FWEPROR_FLWE_01 = 0x1
	// Prohibits Program, Block Erase, Multi Block Erase, Blank Check, and Configuration set command processing.
	SYSC_FWEPROR_FLWE_10 = 0x2
	// Prohibits Program, Block Erase, Multi Block Erase, Blank Check, and Configuration set command processing.
	SYSC_FWEPROR_FLWE_11 = 0x3

	// LVD1CMPCR: Voltage Monitoring 1 Comparator Control Register
	// Position of LVD1LVL field.
	SYSC_LVD1CMPCR_LVD1LVL_Pos = 0x0
	// Bit mask of LVD1LVL field.
	SYSC_LVD1CMPCR_LVD1LVL_Msk = 0x1f
	// 2.99 V (Vdet1_11)
	SYSC_LVD1CMPCR_LVD1LVL_0x11 = 0x11
	// 2.92 V (Vdet1_12)
	SYSC_LVD1CMPCR_LVD1LVL_0x12 = 0x12
	// 2.85 V (Vdet1_13)
	SYSC_LVD1CMPCR_LVD1LVL_0x13 = 0x13
	// Position of LVD1E field.
	SYSC_LVD1CMPCR_LVD1E_Pos = 0x7
	// Bit mask of LVD1E field.
	SYSC_LVD1CMPCR_LVD1E_Msk = 0x80
	// Bit LVD1E.
	SYSC_LVD1CMPCR_LVD1E = 0x80
	// Voltage detection 1 circuit disabled
	SYSC_LVD1CMPCR_LVD1E_0 = 0x0
	// Voltage detection 1 circuit enabled
	SYSC_LVD1CMPCR_LVD1E_1 = 0x1

	// LVD2CMPCR: Voltage Monitoring 2 Comparator Control Register
	// Position of LVD2LVL field.
	SYSC_LVD2CMPCR_LVD2LVL_Pos = 0x0
	// Bit mask of LVD2LVL field.
	SYSC_LVD2CMPCR_LVD2LVL_Msk = 0x7
	// 2.99 V (Vdet2_5)
	SYSC_LVD2CMPCR_LVD2LVL_101 = 0x5
	// 2.92 V (Vdet2_6)
	SYSC_LVD2CMPCR_LVD2LVL_110 = 0x6
	// 2.85 V (Vdet2_7)
	SYSC_LVD2CMPCR_LVD2LVL_111 = 0x7
	// Position of LVD2E field.
	SYSC_LVD2CMPCR_LVD2E_Pos = 0x7
	// Bit mask of LVD2E field.
	SYSC_LVD2CMPCR_LVD2E_Msk = 0x80
	// Bit LVD2E.
	SYSC_LVD2CMPCR_LVD2E = 0x80
	// Voltage detection 2 circuit disabled
	SYSC_LVD2CMPCR_LVD2E_0 = 0x0
	// Voltage detection 2 circuit enabled
	SYSC_LVD2CMPCR_LVD2E_1 = 0x1

	// LVD1CR0: Voltage Monitor 1 Circuit Control Register 0
	// Position of RIE field.
	SYSC_LVD1CR0_RIE_Pos = 0x0
	// Bit mask of RIE field.
	SYSC_LVD1CR0_RIE_Msk = 0x1
	// Bit RIE.
	SYSC_LVD1CR0_RIE = 0x1
	// Disable
	SYSC_LVD1CR0_RIE_0 = 0x0
	// Enable
	SYSC_LVD1CR0_RIE_1 = 0x1
	// Position of DFDIS field.
	SYSC_LVD1CR0_DFDIS_Pos = 0x1
	// Bit mask of DFDIS field.
	SYSC_LVD1CR0_DFDIS_Msk = 0x2
	// Bit DFDIS.
	SYSC_LVD1CR0_DFDIS = 0x2
	// Enable the digital filter
	SYSC_LVD1CR0_DFDIS_0 = 0x0
	// Disable the digital filter
	SYSC_LVD1CR0_DFDIS_1 = 0x1
	// Position of CMPE field.
	SYSC_LVD1CR0_CMPE_Pos = 0x2
	// Bit mask of CMPE field.
	SYSC_LVD1CR0_CMPE_Msk = 0x4
	// Bit CMPE.
	SYSC_LVD1CR0_CMPE = 0x4
	// Disable voltage monitor 1 circuit comparison result output
	SYSC_LVD1CR0_CMPE_0 = 0x0
	// Enable voltage monitor 1 circuit comparison result output
	SYSC_LVD1CR0_CMPE_1 = 0x1
	// Position of FSAMP field.
	SYSC_LVD1CR0_FSAMP_Pos = 0x4
	// Bit mask of FSAMP field.
	SYSC_LVD1CR0_FSAMP_Msk = 0x30
	// 1/2 LOCO frequency
	SYSC_LVD1CR0_FSAMP_00 = 0x0
	// 1/4 LOCO frequency
	SYSC_LVD1CR0_FSAMP_01 = 0x1
	// 1/8 LOCO frequency
	SYSC_LVD1CR0_FSAMP_10 = 0x2
	// 1/16 LOCO frequency
	SYSC_LVD1CR0_FSAMP_11 = 0x3
	// Position of RI field.
	SYSC_LVD1CR0_RI_Pos = 0x6
	// Bit mask of RI field.
	SYSC_LVD1CR0_RI_Msk = 0x40
	// Bit RI.
	SYSC_LVD1CR0_RI = 0x40
	// Generate voltage monitor 1 interrupt on Vdet1 crossing
	SYSC_LVD1CR0_RI_0 = 0x0
	// Enable voltage monitor 1 reset when the voltage falls to and below Vdet1
	SYSC_LVD1CR0_RI_1 = 0x1
	// Position of RN field.
	SYSC_LVD1CR0_RN_Pos = 0x7
	// Bit mask of RN field.
	SYSC_LVD1CR0_RN_Msk = 0x80
	// Bit RN.
	SYSC_LVD1CR0_RN = 0x80
	// Negate after a stabilization time (tLVD1) when VCC > Vdet1 is detected
	SYSC_LVD1CR0_RN_0 = 0x0
	// Negate after a stabilization time (tLVD1) on assertion of the LVD1 reset
	SYSC_LVD1CR0_RN_1 = 0x1

	// LVD2CR0: Voltage Monitor 2 Circuit Control Register 0
	// Position of RIE field.
	SYSC_LVD2CR0_RIE_Pos = 0x0
	// Bit mask of RIE field.
	SYSC_LVD2CR0_RIE_Msk = 0x1
	// Bit RIE.
	SYSC_LVD2CR0_RIE = 0x1
	// Disable
	SYSC_LVD2CR0_RIE_0 = 0x0
	// Enable
	SYSC_LVD2CR0_RIE_1 = 0x1
	// Position of DFDIS field.
	SYSC_LVD2CR0_DFDIS_Pos = 0x1
	// Bit mask of DFDIS field.
	SYSC_LVD2CR0_DFDIS_Msk = 0x2
	// Bit DFDIS.
	SYSC_LVD2CR0_DFDIS = 0x2
	// Enable the digital filter
	SYSC_LVD2CR0_DFDIS_0 = 0x0
	// Disable the digital filter
	SYSC_LVD2CR0_DFDIS_1 = 0x1
	// Position of CMPE field.
	SYSC_LVD2CR0_CMPE_Pos = 0x2
	// Bit mask of CMPE field.
	SYSC_LVD2CR0_CMPE_Msk = 0x4
	// Bit CMPE.
	SYSC_LVD2CR0_CMPE = 0x4
	// Disable voltage monitor 2 circuit comparison result output
	SYSC_LVD2CR0_CMPE_0 = 0x0
	// Enable voltage monitor 2 circuit comparison result output
	SYSC_LVD2CR0_CMPE_1 = 0x1
	// Position of FSAMP field.
	SYSC_LVD2CR0_FSAMP_Pos = 0x4
	// Bit mask of FSAMP field.
	SYSC_LVD2CR0_FSAMP_Msk = 0x30
	// 1/2 LOCO frequency
	SYSC_LVD2CR0_FSAMP_00 = 0x0
	// 1/4 LOCO frequency
	SYSC_LVD2CR0_FSAMP_01 = 0x1
	// 1/8 LOCO frequency
	SYSC_LVD2CR0_FSAMP_10 = 0x2
	// 1/16 LOCO frequency
	SYSC_LVD2CR0_FSAMP_11 = 0x3
	// Position of RI field.
	SYSC_LVD2CR0_RI_Pos = 0x6
	// Bit mask of RI field.
	SYSC_LVD2CR0_RI_Msk = 0x40
	// Bit RI.
	SYSC_LVD2CR0_RI = 0x40
	// Generate voltage monitor 2 interrupt on Vdet2 crossing
	SYSC_LVD2CR0_RI_0 = 0x0
	// Enable voltage monitor 2 reset when the voltage falls to and below Vdet2
	SYSC_LVD2CR0_RI_1 = 0x1
	// Position of RN field.
	SYSC_LVD2CR0_RN_Pos = 0x7
	// Bit mask of RN field.
	SYSC_LVD2CR0_RN_Msk = 0x80
	// Bit RN.
	SYSC_LVD2CR0_RN = 0x80
	// Negate after a stabilization time (tLVD2) when VCC > Vdet2 is detected
	SYSC_LVD2CR0_RN_0 = 0x0
	// Negate after a stabilization time (tLVD2) on assertion of the LVD2 reset
	SYSC_LVD2CR0_RN_1 = 0x1

	// VBATTMNSELR: Battery Backup Voltage Monitor Function Select Register
	// Position of VBATTMNSEL field.
	SYSC_VBATTMNSELR_VBATTMNSEL_Pos = 0x0
	// Bit mask of VBATTMNSEL field.
	SYSC_VBATTMNSELR_VBATTMNSEL_Msk = 0x1
	// Bit VBATTMNSEL.
	SYSC_VBATTMNSELR_VBATTMNSEL = 0x1
	// Disables VBATT low voltage detect function
	SYSC_VBATTMNSELR_VBATTMNSEL_0 = 0x0
	// Enables VBATT low voltage detect function
	SYSC_VBATTMNSELR_VBATTMNSEL_1 = 0x1

	// VBATTMONR: Battery Backup Voltage Monitor Register
	// Position of VBATTMON field.
	SYSC_VBATTMONR_VBATTMON_Pos = 0x0
	// Bit mask of VBATTMON field.
	SYSC_VBATTMONR_VBATTMON_Msk = 0x1
	// Bit VBATTMON.
	SYSC_VBATTMONR_VBATTMON = 0x1
	// VBATT ≥ Vbattldet
	SYSC_VBATTMONR_VBATTMON_0 = 0x0
	// VBATT < Vbattldet
	SYSC_VBATTMONR_VBATTMON_1 = 0x1

	// SOSCCR: Sub-Clock Oscillator Control Register
	// Position of SOSTP field.
	SYSC_SOSCCR_SOSTP_Pos = 0x0
	// Bit mask of SOSTP field.
	SYSC_SOSCCR_SOSTP_Msk = 0x1
	// Bit SOSTP.
	SYSC_SOSCCR_SOSTP = 0x1
	// Operate the sub-clock oscillator
	SYSC_SOSCCR_SOSTP_0 = 0x0
	// Stop the sub-clock oscillator
	SYSC_SOSCCR_SOSTP_1 = 0x1

	// SOMCR: Sub-Clock Oscillator Mode Control Register
	// Position of SODRV field.
	SYSC_SOMCR_SODRV_Pos = 0x1
	// Bit mask of SODRV field.
	SYSC_SOMCR_SODRV_Msk = 0x2
	// Bit SODRV.
	SYSC_SOMCR_SODRV = 0x2
	// Standard
	SYSC_SOMCR_SODRV_0 = 0x0
	// Low
	SYSC_SOMCR_SODRV_1 = 0x1

	// LOCOCR: Low-Speed On-Chip Oscillator Control Register
	// Position of LCSTP field.
	SYSC_LOCOCR_LCSTP_Pos = 0x0
	// Bit mask of LCSTP field.
	SYSC_LOCOCR_LCSTP_Msk = 0x1
	// Bit LCSTP.
	SYSC_LOCOCR_LCSTP = 0x1
	// Operate the LOCO clock
	SYSC_LOCOCR_LCSTP_0 = 0x0
	// Stop the LOCO clock
	SYSC_LOCOCR_LCSTP_1 = 0x1

	// LOCOUTCR: LOCO User Trimming Control Register
	// Position of LOCOUTRM field.
	SYSC_LOCOUTCR_LOCOUTRM_Pos = 0x0
	// Bit mask of LOCOUTRM field.
	SYSC_LOCOUTCR_LOCOUTRM_Msk = 0xff

	// VBTICTLR: VBATT Input Control Register
	// Position of VCH0INEN field.
	SYSC_VBTICTLR_VCH0INEN_Pos = 0x0
	// Bit mask of VCH0INEN field.
	SYSC_VBTICTLR_VCH0INEN_Msk = 0x1
	// Bit VCH0INEN.
	SYSC_VBTICTLR_VCH0INEN = 0x1
	// RTCIC0 input disable
	SYSC_VBTICTLR_VCH0INEN_0 = 0x0
	// RTCIC0 input enable
	SYSC_VBTICTLR_VCH0INEN_1 = 0x1
	// Position of VCH1INEN field.
	SYSC_VBTICTLR_VCH1INEN_Pos = 0x1
	// Bit mask of VCH1INEN field.
	SYSC_VBTICTLR_VCH1INEN_Msk = 0x2
	// Bit VCH1INEN.
	SYSC_VBTICTLR_VCH1INEN = 0x2
	// RTCIC1 input disable
	SYSC_VBTICTLR_VCH1INEN_0 = 0x0
	// RTCIC1 input enable
	SYSC_VBTICTLR_VCH1INEN_1 = 0x1
	// Position of VCH2INEN field.
	SYSC_VBTICTLR_VCH2INEN_Pos = 0x2
	// Bit mask of VCH2INEN field.
	SYSC_VBTICTLR_VCH2INEN_Msk = 0x4
	// Bit VCH2INEN.
	SYSC_VBTICTLR_VCH2INEN = 0x4
	// RTCIC2 input disable
	SYSC_VBTICTLR_VCH2INEN_0 = 0x0
	// RTCIC2 input enable
	SYSC_VBTICTLR_VCH2INEN_1 = 0x1

	// VBTBER: VBATT Backup Enable Register
	// Position of VBAE field.
	SYSC_VBTBER_VBAE_Pos = 0x3
	// Bit mask of VBAE field.
	SYSC_VBTBER_VBAE_Msk = 0x8
	// Bit VBAE.
	SYSC_VBTBER_VBAE = 0x8
	// Disable to access VBTBKR
	SYSC_VBTBER_VBAE_0 = 0x0
	// Enable to access VBTBKR
	SYSC_VBTBER_VBAE_1 = 0x1

	// VBTBKR: VBATT Backup Register
	// Position of VBTBKR field.
	SYSC_VBTBKR_VBTBKR_Pos = 0x0
	// Bit mask of VBTBKR field.
	SYSC_VBTBKR_VBTBKR_Msk = 0xff
)

// Constants for PORT0: Pmn Pin FunctionPort 0 Control RegistersPmn Pin Function Control Register
const (
	// PCNTR1: Port Control Register 1
	// Position of PDR00 field.
	PORT0_PCNTR1_PDR00_Pos = 0x0
	// Bit mask of PDR00 field.
	PORT0_PCNTR1_PDR00_Msk = 0x1
	// Bit PDR00.
	PORT0_PCNTR1_PDR00 = 0x1
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR00_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR00_1 = 0x1
	// Position of PDR01 field.
	PORT0_PCNTR1_PDR01_Pos = 0x1
	// Bit mask of PDR01 field.
	PORT0_PCNTR1_PDR01_Msk = 0x2
	// Bit PDR01.
	PORT0_PCNTR1_PDR01 = 0x2
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR01_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR01_1 = 0x1
	// Position of PDR02 field.
	PORT0_PCNTR1_PDR02_Pos = 0x2
	// Bit mask of PDR02 field.
	PORT0_PCNTR1_PDR02_Msk = 0x4
	// Bit PDR02.
	PORT0_PCNTR1_PDR02 = 0x4
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR02_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR02_1 = 0x1
	// Position of PDR03 field.
	PORT0_PCNTR1_PDR03_Pos = 0x3
	// Bit mask of PDR03 field.
	PORT0_PCNTR1_PDR03_Msk = 0x8
	// Bit PDR03.
	PORT0_PCNTR1_PDR03 = 0x8
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR03_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR03_1 = 0x1
	// Position of PDR04 field.
	PORT0_PCNTR1_PDR04_Pos = 0x4
	// Bit mask of PDR04 field.
	PORT0_PCNTR1_PDR04_Msk = 0x10
	// Bit PDR04.
	PORT0_PCNTR1_PDR04 = 0x10
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR04_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR04_1 = 0x1
	// Position of PDR05 field.
	PORT0_PCNTR1_PDR05_Pos = 0x5
	// Bit mask of PDR05 field.
	PORT0_PCNTR1_PDR05_Msk = 0x20
	// Bit PDR05.
	PORT0_PCNTR1_PDR05 = 0x20
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR05_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR05_1 = 0x1
	// Position of PDR06 field.
	PORT0_PCNTR1_PDR06_Pos = 0x6
	// Bit mask of PDR06 field.
	PORT0_PCNTR1_PDR06_Msk = 0x40
	// Bit PDR06.
	PORT0_PCNTR1_PDR06 = 0x40
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR06_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR06_1 = 0x1
	// Position of PDR07 field.
	PORT0_PCNTR1_PDR07_Pos = 0x7
	// Bit mask of PDR07 field.
	PORT0_PCNTR1_PDR07_Msk = 0x80
	// Bit PDR07.
	PORT0_PCNTR1_PDR07 = 0x80
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR07_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR07_1 = 0x1
	// Position of PDR08 field.
	PORT0_PCNTR1_PDR08_Pos = 0x8
	// Bit mask of PDR08 field.
	PORT0_PCNTR1_PDR08_Msk = 0x100
	// Bit PDR08.
	PORT0_PCNTR1_PDR08 = 0x100
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR08_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR08_1 = 0x1
	// Position of PDR09 field.
	PORT0_PCNTR1_PDR09_Pos = 0x9
	// Bit mask of PDR09 field.
	PORT0_PCNTR1_PDR09_Msk = 0x200
	// Bit PDR09.
	PORT0_PCNTR1_PDR09 = 0x200
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR09_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR09_1 = 0x1
	// Position of PDR10 field.
	PORT0_PCNTR1_PDR10_Pos = 0xa
	// Bit mask of PDR10 field.
	PORT0_PCNTR1_PDR10_Msk = 0x400
	// Bit PDR10.
	PORT0_PCNTR1_PDR10 = 0x400
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR10_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR10_1 = 0x1
	// Position of PDR11 field.
	PORT0_PCNTR1_PDR11_Pos = 0xb
	// Bit mask of PDR11 field.
	PORT0_PCNTR1_PDR11_Msk = 0x800
	// Bit PDR11.
	PORT0_PCNTR1_PDR11 = 0x800
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR11_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR11_1 = 0x1
	// Position of PDR12 field.
	PORT0_PCNTR1_PDR12_Pos = 0xc
	// Bit mask of PDR12 field.
	PORT0_PCNTR1_PDR12_Msk = 0x1000
	// Bit PDR12.
	PORT0_PCNTR1_PDR12 = 0x1000
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR12_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR12_1 = 0x1
	// Position of PDR13 field.
	PORT0_PCNTR1_PDR13_Pos = 0xd
	// Bit mask of PDR13 field.
	PORT0_PCNTR1_PDR13_Msk = 0x2000
	// Bit PDR13.
	PORT0_PCNTR1_PDR13 = 0x2000
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR13_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR13_1 = 0x1
	// Position of PDR14 field.
	PORT0_PCNTR1_PDR14_Pos = 0xe
	// Bit mask of PDR14 field.
	PORT0_PCNTR1_PDR14_Msk = 0x4000
	// Bit PDR14.
	PORT0_PCNTR1_PDR14 = 0x4000
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR14_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR14_1 = 0x1
	// Position of PDR15 field.
	PORT0_PCNTR1_PDR15_Pos = 0xf
	// Bit mask of PDR15 field.
	PORT0_PCNTR1_PDR15_Msk = 0x8000
	// Bit PDR15.
	PORT0_PCNTR1_PDR15 = 0x8000
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR15_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PCNTR1_PDR15_1 = 0x1
	// Position of PODR00 field.
	PORT0_PCNTR1_PODR00_Pos = 0x10
	// Bit mask of PODR00 field.
	PORT0_PCNTR1_PODR00_Msk = 0x10000
	// Bit PODR00.
	PORT0_PCNTR1_PODR00 = 0x10000
	// Low output
	PORT0_PCNTR1_PODR00_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR00_1 = 0x1
	// Position of PODR01 field.
	PORT0_PCNTR1_PODR01_Pos = 0x11
	// Bit mask of PODR01 field.
	PORT0_PCNTR1_PODR01_Msk = 0x20000
	// Bit PODR01.
	PORT0_PCNTR1_PODR01 = 0x20000
	// Low output
	PORT0_PCNTR1_PODR01_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR01_1 = 0x1
	// Position of PODR02 field.
	PORT0_PCNTR1_PODR02_Pos = 0x12
	// Bit mask of PODR02 field.
	PORT0_PCNTR1_PODR02_Msk = 0x40000
	// Bit PODR02.
	PORT0_PCNTR1_PODR02 = 0x40000
	// Low output
	PORT0_PCNTR1_PODR02_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR02_1 = 0x1
	// Position of PODR03 field.
	PORT0_PCNTR1_PODR03_Pos = 0x13
	// Bit mask of PODR03 field.
	PORT0_PCNTR1_PODR03_Msk = 0x80000
	// Bit PODR03.
	PORT0_PCNTR1_PODR03 = 0x80000
	// Low output
	PORT0_PCNTR1_PODR03_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR03_1 = 0x1
	// Position of PODR04 field.
	PORT0_PCNTR1_PODR04_Pos = 0x14
	// Bit mask of PODR04 field.
	PORT0_PCNTR1_PODR04_Msk = 0x100000
	// Bit PODR04.
	PORT0_PCNTR1_PODR04 = 0x100000
	// Low output
	PORT0_PCNTR1_PODR04_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR04_1 = 0x1
	// Position of PODR05 field.
	PORT0_PCNTR1_PODR05_Pos = 0x15
	// Bit mask of PODR05 field.
	PORT0_PCNTR1_PODR05_Msk = 0x200000
	// Bit PODR05.
	PORT0_PCNTR1_PODR05 = 0x200000
	// Low output
	PORT0_PCNTR1_PODR05_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR05_1 = 0x1
	// Position of PODR06 field.
	PORT0_PCNTR1_PODR06_Pos = 0x16
	// Bit mask of PODR06 field.
	PORT0_PCNTR1_PODR06_Msk = 0x400000
	// Bit PODR06.
	PORT0_PCNTR1_PODR06 = 0x400000
	// Low output
	PORT0_PCNTR1_PODR06_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR06_1 = 0x1
	// Position of PODR07 field.
	PORT0_PCNTR1_PODR07_Pos = 0x17
	// Bit mask of PODR07 field.
	PORT0_PCNTR1_PODR07_Msk = 0x800000
	// Bit PODR07.
	PORT0_PCNTR1_PODR07 = 0x800000
	// Low output
	PORT0_PCNTR1_PODR07_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR07_1 = 0x1
	// Position of PODR08 field.
	PORT0_PCNTR1_PODR08_Pos = 0x18
	// Bit mask of PODR08 field.
	PORT0_PCNTR1_PODR08_Msk = 0x1000000
	// Bit PODR08.
	PORT0_PCNTR1_PODR08 = 0x1000000
	// Low output
	PORT0_PCNTR1_PODR08_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR08_1 = 0x1
	// Position of PODR09 field.
	PORT0_PCNTR1_PODR09_Pos = 0x19
	// Bit mask of PODR09 field.
	PORT0_PCNTR1_PODR09_Msk = 0x2000000
	// Bit PODR09.
	PORT0_PCNTR1_PODR09 = 0x2000000
	// Low output
	PORT0_PCNTR1_PODR09_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR09_1 = 0x1
	// Position of PODR10 field.
	PORT0_PCNTR1_PODR10_Pos = 0x1a
	// Bit mask of PODR10 field.
	PORT0_PCNTR1_PODR10_Msk = 0x4000000
	// Bit PODR10.
	PORT0_PCNTR1_PODR10 = 0x4000000
	// Low output
	PORT0_PCNTR1_PODR10_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR10_1 = 0x1
	// Position of PODR11 field.
	PORT0_PCNTR1_PODR11_Pos = 0x1b
	// Bit mask of PODR11 field.
	PORT0_PCNTR1_PODR11_Msk = 0x8000000
	// Bit PODR11.
	PORT0_PCNTR1_PODR11 = 0x8000000
	// Low output
	PORT0_PCNTR1_PODR11_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR11_1 = 0x1
	// Position of PODR12 field.
	PORT0_PCNTR1_PODR12_Pos = 0x1c
	// Bit mask of PODR12 field.
	PORT0_PCNTR1_PODR12_Msk = 0x10000000
	// Bit PODR12.
	PORT0_PCNTR1_PODR12 = 0x10000000
	// Low output
	PORT0_PCNTR1_PODR12_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR12_1 = 0x1
	// Position of PODR13 field.
	PORT0_PCNTR1_PODR13_Pos = 0x1d
	// Bit mask of PODR13 field.
	PORT0_PCNTR1_PODR13_Msk = 0x20000000
	// Bit PODR13.
	PORT0_PCNTR1_PODR13 = 0x20000000
	// Low output
	PORT0_PCNTR1_PODR13_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR13_1 = 0x1
	// Position of PODR14 field.
	PORT0_PCNTR1_PODR14_Pos = 0x1e
	// Bit mask of PODR14 field.
	PORT0_PCNTR1_PODR14_Msk = 0x40000000
	// Bit PODR14.
	PORT0_PCNTR1_PODR14 = 0x40000000
	// Low output
	PORT0_PCNTR1_PODR14_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR14_1 = 0x1
	// Position of PODR15 field.
	PORT0_PCNTR1_PODR15_Pos = 0x1f
	// Bit mask of PODR15 field.
	PORT0_PCNTR1_PODR15_Msk = 0x80000000
	// Bit PODR15.
	PORT0_PCNTR1_PODR15 = 0x80000000
	// Low output
	PORT0_PCNTR1_PODR15_0 = 0x0
	// High output
	PORT0_PCNTR1_PODR15_1 = 0x1

	// PODR: Port Control Register 1
	// Position of PODR00 field.
	PORT0_PODR_PODR00_Pos = 0x0
	// Bit mask of PODR00 field.
	PORT0_PODR_PODR00_Msk = 0x1
	// Bit PODR00.
	PORT0_PODR_PODR00 = 0x1
	// Low output
	PORT0_PODR_PODR00_0 = 0x0
	// High output
	PORT0_PODR_PODR00_1 = 0x1
	// Position of PODR01 field.
	PORT0_PODR_PODR01_Pos = 0x1
	// Bit mask of PODR01 field.
	PORT0_PODR_PODR01_Msk = 0x2
	// Bit PODR01.
	PORT0_PODR_PODR01 = 0x2
	// Low output
	PORT0_PODR_PODR01_0 = 0x0
	// High output
	PORT0_PODR_PODR01_1 = 0x1
	// Position of PODR02 field.
	PORT0_PODR_PODR02_Pos = 0x2
	// Bit mask of PODR02 field.
	PORT0_PODR_PODR02_Msk = 0x4
	// Bit PODR02.
	PORT0_PODR_PODR02 = 0x4
	// Low output
	PORT0_PODR_PODR02_0 = 0x0
	// High output
	PORT0_PODR_PODR02_1 = 0x1
	// Position of PODR03 field.
	PORT0_PODR_PODR03_Pos = 0x3
	// Bit mask of PODR03 field.
	PORT0_PODR_PODR03_Msk = 0x8
	// Bit PODR03.
	PORT0_PODR_PODR03 = 0x8
	// Low output
	PORT0_PODR_PODR03_0 = 0x0
	// High output
	PORT0_PODR_PODR03_1 = 0x1
	// Position of PODR04 field.
	PORT0_PODR_PODR04_Pos = 0x4
	// Bit mask of PODR04 field.
	PORT0_PODR_PODR04_Msk = 0x10
	// Bit PODR04.
	PORT0_PODR_PODR04 = 0x10
	// Low output
	PORT0_PODR_PODR04_0 = 0x0
	// High output
	PORT0_PODR_PODR04_1 = 0x1
	// Position of PODR05 field.
	PORT0_PODR_PODR05_Pos = 0x5
	// Bit mask of PODR05 field.
	PORT0_PODR_PODR05_Msk = 0x20
	// Bit PODR05.
	PORT0_PODR_PODR05 = 0x20
	// Low output
	PORT0_PODR_PODR05_0 = 0x0
	// High output
	PORT0_PODR_PODR05_1 = 0x1
	// Position of PODR06 field.
	PORT0_PODR_PODR06_Pos = 0x6
	// Bit mask of PODR06 field.
	PORT0_PODR_PODR06_Msk = 0x40
	// Bit PODR06.
	PORT0_PODR_PODR06 = 0x40
	// Low output
	PORT0_PODR_PODR06_0 = 0x0
	// High output
	PORT0_PODR_PODR06_1 = 0x1
	// Position of PODR07 field.
	PORT0_PODR_PODR07_Pos = 0x7
	// Bit mask of PODR07 field.
	PORT0_PODR_PODR07_Msk = 0x80
	// Bit PODR07.
	PORT0_PODR_PODR07 = 0x80
	// Low output
	PORT0_PODR_PODR07_0 = 0x0
	// High output
	PORT0_PODR_PODR07_1 = 0x1
	// Position of PODR08 field.
	PORT0_PODR_PODR08_Pos = 0x8
	// Bit mask of PODR08 field.
	PORT0_PODR_PODR08_Msk = 0x100
	// Bit PODR08.
	PORT0_PODR_PODR08 = 0x100
	// Low output
	PORT0_PODR_PODR08_0 = 0x0
	// High output
	PORT0_PODR_PODR08_1 = 0x1
	// Position of PODR09 field.
	PORT0_PODR_PODR09_Pos = 0x9
	// Bit mask of PODR09 field.
	PORT0_PODR_PODR09_Msk = 0x200
	// Bit PODR09.
	PORT0_PODR_PODR09 = 0x200
	// Low output
	PORT0_PODR_PODR09_0 = 0x0
	// High output
	PORT0_PODR_PODR09_1 = 0x1
	// Position of PODR10 field.
	PORT0_PODR_PODR10_Pos = 0xa
	// Bit mask of PODR10 field.
	PORT0_PODR_PODR10_Msk = 0x400
	// Bit PODR10.
	PORT0_PODR_PODR10 = 0x400
	// Low output
	PORT0_PODR_PODR10_0 = 0x0
	// High output
	PORT0_PODR_PODR10_1 = 0x1
	// Position of PODR11 field.
	PORT0_PODR_PODR11_Pos = 0xb
	// Bit mask of PODR11 field.
	PORT0_PODR_PODR11_Msk = 0x800
	// Bit PODR11.
	PORT0_PODR_PODR11 = 0x800
	// Low output
	PORT0_PODR_PODR11_0 = 0x0
	// High output
	PORT0_PODR_PODR11_1 = 0x1
	// Position of PODR12 field.
	PORT0_PODR_PODR12_Pos = 0xc
	// Bit mask of PODR12 field.
	PORT0_PODR_PODR12_Msk = 0x1000
	// Bit PODR12.
	PORT0_PODR_PODR12 = 0x1000
	// Low output
	PORT0_PODR_PODR12_0 = 0x0
	// High output
	PORT0_PODR_PODR12_1 = 0x1
	// Position of PODR13 field.
	PORT0_PODR_PODR13_Pos = 0xd
	// Bit mask of PODR13 field.
	PORT0_PODR_PODR13_Msk = 0x2000
	// Bit PODR13.
	PORT0_PODR_PODR13 = 0x2000
	// Low output
	PORT0_PODR_PODR13_0 = 0x0
	// High output
	PORT0_PODR_PODR13_1 = 0x1
	// Position of PODR14 field.
	PORT0_PODR_PODR14_Pos = 0xe
	// Bit mask of PODR14 field.
	PORT0_PODR_PODR14_Msk = 0x4000
	// Bit PODR14.
	PORT0_PODR_PODR14 = 0x4000
	// Low output
	PORT0_PODR_PODR14_0 = 0x0
	// High output
	PORT0_PODR_PODR14_1 = 0x1
	// Position of PODR15 field.
	PORT0_PODR_PODR15_Pos = 0xf
	// Bit mask of PODR15 field.
	PORT0_PODR_PODR15_Msk = 0x8000
	// Bit PODR15.
	PORT0_PODR_PODR15 = 0x8000
	// Low output
	PORT0_PODR_PODR15_0 = 0x0
	// High output
	PORT0_PODR_PODR15_1 = 0x1

	// PDR: Port Control Register 1
	// Position of PDR00 field.
	PORT0_PDR_PDR00_Pos = 0x0
	// Bit mask of PDR00 field.
	PORT0_PDR_PDR00_Msk = 0x1
	// Bit PDR00.
	PORT0_PDR_PDR00 = 0x1
	// Input (functions as an input pin)
	PORT0_PDR_PDR00_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR00_1 = 0x1
	// Position of PDR01 field.
	PORT0_PDR_PDR01_Pos = 0x1
	// Bit mask of PDR01 field.
	PORT0_PDR_PDR01_Msk = 0x2
	// Bit PDR01.
	PORT0_PDR_PDR01 = 0x2
	// Input (functions as an input pin)
	PORT0_PDR_PDR01_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR01_1 = 0x1
	// Position of PDR02 field.
	PORT0_PDR_PDR02_Pos = 0x2
	// Bit mask of PDR02 field.
	PORT0_PDR_PDR02_Msk = 0x4
	// Bit PDR02.
	PORT0_PDR_PDR02 = 0x4
	// Input (functions as an input pin)
	PORT0_PDR_PDR02_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR02_1 = 0x1
	// Position of PDR03 field.
	PORT0_PDR_PDR03_Pos = 0x3
	// Bit mask of PDR03 field.
	PORT0_PDR_PDR03_Msk = 0x8
	// Bit PDR03.
	PORT0_PDR_PDR03 = 0x8
	// Input (functions as an input pin)
	PORT0_PDR_PDR03_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR03_1 = 0x1
	// Position of PDR04 field.
	PORT0_PDR_PDR04_Pos = 0x4
	// Bit mask of PDR04 field.
	PORT0_PDR_PDR04_Msk = 0x10
	// Bit PDR04.
	PORT0_PDR_PDR04 = 0x10
	// Input (functions as an input pin)
	PORT0_PDR_PDR04_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR04_1 = 0x1
	// Position of PDR05 field.
	PORT0_PDR_PDR05_Pos = 0x5
	// Bit mask of PDR05 field.
	PORT0_PDR_PDR05_Msk = 0x20
	// Bit PDR05.
	PORT0_PDR_PDR05 = 0x20
	// Input (functions as an input pin)
	PORT0_PDR_PDR05_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR05_1 = 0x1
	// Position of PDR06 field.
	PORT0_PDR_PDR06_Pos = 0x6
	// Bit mask of PDR06 field.
	PORT0_PDR_PDR06_Msk = 0x40
	// Bit PDR06.
	PORT0_PDR_PDR06 = 0x40
	// Input (functions as an input pin)
	PORT0_PDR_PDR06_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR06_1 = 0x1
	// Position of PDR07 field.
	PORT0_PDR_PDR07_Pos = 0x7
	// Bit mask of PDR07 field.
	PORT0_PDR_PDR07_Msk = 0x80
	// Bit PDR07.
	PORT0_PDR_PDR07 = 0x80
	// Input (functions as an input pin)
	PORT0_PDR_PDR07_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR07_1 = 0x1
	// Position of PDR08 field.
	PORT0_PDR_PDR08_Pos = 0x8
	// Bit mask of PDR08 field.
	PORT0_PDR_PDR08_Msk = 0x100
	// Bit PDR08.
	PORT0_PDR_PDR08 = 0x100
	// Input (functions as an input pin)
	PORT0_PDR_PDR08_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR08_1 = 0x1
	// Position of PDR09 field.
	PORT0_PDR_PDR09_Pos = 0x9
	// Bit mask of PDR09 field.
	PORT0_PDR_PDR09_Msk = 0x200
	// Bit PDR09.
	PORT0_PDR_PDR09 = 0x200
	// Input (functions as an input pin)
	PORT0_PDR_PDR09_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR09_1 = 0x1
	// Position of PDR10 field.
	PORT0_PDR_PDR10_Pos = 0xa
	// Bit mask of PDR10 field.
	PORT0_PDR_PDR10_Msk = 0x400
	// Bit PDR10.
	PORT0_PDR_PDR10 = 0x400
	// Input (functions as an input pin)
	PORT0_PDR_PDR10_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR10_1 = 0x1
	// Position of PDR11 field.
	PORT0_PDR_PDR11_Pos = 0xb
	// Bit mask of PDR11 field.
	PORT0_PDR_PDR11_Msk = 0x800
	// Bit PDR11.
	PORT0_PDR_PDR11 = 0x800
	// Input (functions as an input pin)
	PORT0_PDR_PDR11_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR11_1 = 0x1
	// Position of PDR12 field.
	PORT0_PDR_PDR12_Pos = 0xc
	// Bit mask of PDR12 field.
	PORT0_PDR_PDR12_Msk = 0x1000
	// Bit PDR12.
	PORT0_PDR_PDR12 = 0x1000
	// Input (functions as an input pin)
	PORT0_PDR_PDR12_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR12_1 = 0x1
	// Position of PDR13 field.
	PORT0_PDR_PDR13_Pos = 0xd
	// Bit mask of PDR13 field.
	PORT0_PDR_PDR13_Msk = 0x2000
	// Bit PDR13.
	PORT0_PDR_PDR13 = 0x2000
	// Input (functions as an input pin)
	PORT0_PDR_PDR13_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR13_1 = 0x1
	// Position of PDR14 field.
	PORT0_PDR_PDR14_Pos = 0xe
	// Bit mask of PDR14 field.
	PORT0_PDR_PDR14_Msk = 0x4000
	// Bit PDR14.
	PORT0_PDR_PDR14 = 0x4000
	// Input (functions as an input pin)
	PORT0_PDR_PDR14_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR14_1 = 0x1
	// Position of PDR15 field.
	PORT0_PDR_PDR15_Pos = 0xf
	// Bit mask of PDR15 field.
	PORT0_PDR_PDR15_Msk = 0x8000
	// Bit PDR15.
	PORT0_PDR_PDR15 = 0x8000
	// Input (functions as an input pin)
	PORT0_PDR_PDR15_0 = 0x0
	// Output (functions as an output pin)
	PORT0_PDR_PDR15_1 = 0x1

	// PCNTR2: Port Control Register 2
	// Position of PIDR00 field.
	PORT0_PCNTR2_PIDR00_Pos = 0x0
	// Bit mask of PIDR00 field.
	PORT0_PCNTR2_PIDR00_Msk = 0x1
	// Bit PIDR00.
	PORT0_PCNTR2_PIDR00 = 0x1
	// Low level
	PORT0_PCNTR2_PIDR00_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR00_1 = 0x1
	// Position of PIDR01 field.
	PORT0_PCNTR2_PIDR01_Pos = 0x1
	// Bit mask of PIDR01 field.
	PORT0_PCNTR2_PIDR01_Msk = 0x2
	// Bit PIDR01.
	PORT0_PCNTR2_PIDR01 = 0x2
	// Low level
	PORT0_PCNTR2_PIDR01_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR01_1 = 0x1
	// Position of PIDR02 field.
	PORT0_PCNTR2_PIDR02_Pos = 0x2
	// Bit mask of PIDR02 field.
	PORT0_PCNTR2_PIDR02_Msk = 0x4
	// Bit PIDR02.
	PORT0_PCNTR2_PIDR02 = 0x4
	// Low level
	PORT0_PCNTR2_PIDR02_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR02_1 = 0x1
	// Position of PIDR03 field.
	PORT0_PCNTR2_PIDR03_Pos = 0x3
	// Bit mask of PIDR03 field.
	PORT0_PCNTR2_PIDR03_Msk = 0x8
	// Bit PIDR03.
	PORT0_PCNTR2_PIDR03 = 0x8
	// Low level
	PORT0_PCNTR2_PIDR03_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR03_1 = 0x1
	// Position of PIDR04 field.
	PORT0_PCNTR2_PIDR04_Pos = 0x4
	// Bit mask of PIDR04 field.
	PORT0_PCNTR2_PIDR04_Msk = 0x10
	// Bit PIDR04.
	PORT0_PCNTR2_PIDR04 = 0x10
	// Low level
	PORT0_PCNTR2_PIDR04_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR04_1 = 0x1
	// Position of PIDR05 field.
	PORT0_PCNTR2_PIDR05_Pos = 0x5
	// Bit mask of PIDR05 field.
	PORT0_PCNTR2_PIDR05_Msk = 0x20
	// Bit PIDR05.
	PORT0_PCNTR2_PIDR05 = 0x20
	// Low level
	PORT0_PCNTR2_PIDR05_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR05_1 = 0x1
	// Position of PIDR06 field.
	PORT0_PCNTR2_PIDR06_Pos = 0x6
	// Bit mask of PIDR06 field.
	PORT0_PCNTR2_PIDR06_Msk = 0x40
	// Bit PIDR06.
	PORT0_PCNTR2_PIDR06 = 0x40
	// Low level
	PORT0_PCNTR2_PIDR06_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR06_1 = 0x1
	// Position of PIDR07 field.
	PORT0_PCNTR2_PIDR07_Pos = 0x7
	// Bit mask of PIDR07 field.
	PORT0_PCNTR2_PIDR07_Msk = 0x80
	// Bit PIDR07.
	PORT0_PCNTR2_PIDR07 = 0x80
	// Low level
	PORT0_PCNTR2_PIDR07_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR07_1 = 0x1
	// Position of PIDR08 field.
	PORT0_PCNTR2_PIDR08_Pos = 0x8
	// Bit mask of PIDR08 field.
	PORT0_PCNTR2_PIDR08_Msk = 0x100
	// Bit PIDR08.
	PORT0_PCNTR2_PIDR08 = 0x100
	// Low level
	PORT0_PCNTR2_PIDR08_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR08_1 = 0x1
	// Position of PIDR09 field.
	PORT0_PCNTR2_PIDR09_Pos = 0x9
	// Bit mask of PIDR09 field.
	PORT0_PCNTR2_PIDR09_Msk = 0x200
	// Bit PIDR09.
	PORT0_PCNTR2_PIDR09 = 0x200
	// Low level
	PORT0_PCNTR2_PIDR09_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR09_1 = 0x1
	// Position of PIDR10 field.
	PORT0_PCNTR2_PIDR10_Pos = 0xa
	// Bit mask of PIDR10 field.
	PORT0_PCNTR2_PIDR10_Msk = 0x400
	// Bit PIDR10.
	PORT0_PCNTR2_PIDR10 = 0x400
	// Low level
	PORT0_PCNTR2_PIDR10_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR10_1 = 0x1
	// Position of PIDR11 field.
	PORT0_PCNTR2_PIDR11_Pos = 0xb
	// Bit mask of PIDR11 field.
	PORT0_PCNTR2_PIDR11_Msk = 0x800
	// Bit PIDR11.
	PORT0_PCNTR2_PIDR11 = 0x800
	// Low level
	PORT0_PCNTR2_PIDR11_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR11_1 = 0x1
	// Position of PIDR12 field.
	PORT0_PCNTR2_PIDR12_Pos = 0xc
	// Bit mask of PIDR12 field.
	PORT0_PCNTR2_PIDR12_Msk = 0x1000
	// Bit PIDR12.
	PORT0_PCNTR2_PIDR12 = 0x1000
	// Low level
	PORT0_PCNTR2_PIDR12_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR12_1 = 0x1
	// Position of PIDR13 field.
	PORT0_PCNTR2_PIDR13_Pos = 0xd
	// Bit mask of PIDR13 field.
	PORT0_PCNTR2_PIDR13_Msk = 0x2000
	// Bit PIDR13.
	PORT0_PCNTR2_PIDR13 = 0x2000
	// Low level
	PORT0_PCNTR2_PIDR13_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR13_1 = 0x1
	// Position of PIDR14 field.
	PORT0_PCNTR2_PIDR14_Pos = 0xe
	// Bit mask of PIDR14 field.
	PORT0_PCNTR2_PIDR14_Msk = 0x4000
	// Bit PIDR14.
	PORT0_PCNTR2_PIDR14 = 0x4000
	// Low level
	PORT0_PCNTR2_PIDR14_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR14_1 = 0x1
	// Position of PIDR15 field.
	PORT0_PCNTR2_PIDR15_Pos = 0xf
	// Bit mask of PIDR15 field.
	PORT0_PCNTR2_PIDR15_Msk = 0x8000
	// Bit PIDR15.
	PORT0_PCNTR2_PIDR15 = 0x8000
	// Low level
	PORT0_PCNTR2_PIDR15_0 = 0x0
	// High level
	PORT0_PCNTR2_PIDR15_1 = 0x1

	// PIDR: Port Control Register 2
	// Position of PIDR00 field.
	PORT0_PIDR_PIDR00_Pos = 0x0
	// Bit mask of PIDR00 field.
	PORT0_PIDR_PIDR00_Msk = 0x1
	// Bit PIDR00.
	PORT0_PIDR_PIDR00 = 0x1
	// Low level
	PORT0_PIDR_PIDR00_0 = 0x0
	// High level
	PORT0_PIDR_PIDR00_1 = 0x1
	// Position of PIDR01 field.
	PORT0_PIDR_PIDR01_Pos = 0x1
	// Bit mask of PIDR01 field.
	PORT0_PIDR_PIDR01_Msk = 0x2
	// Bit PIDR01.
	PORT0_PIDR_PIDR01 = 0x2
	// Low level
	PORT0_PIDR_PIDR01_0 = 0x0
	// High level
	PORT0_PIDR_PIDR01_1 = 0x1
	// Position of PIDR02 field.
	PORT0_PIDR_PIDR02_Pos = 0x2
	// Bit mask of PIDR02 field.
	PORT0_PIDR_PIDR02_Msk = 0x4
	// Bit PIDR02.
	PORT0_PIDR_PIDR02 = 0x4
	// Low level
	PORT0_PIDR_PIDR02_0 = 0x0
	// High level
	PORT0_PIDR_PIDR02_1 = 0x1
	// Position of PIDR03 field.
	PORT0_PIDR_PIDR03_Pos = 0x3
	// Bit mask of PIDR03 field.
	PORT0_PIDR_PIDR03_Msk = 0x8
	// Bit PIDR03.
	PORT0_PIDR_PIDR03 = 0x8
	// Low level
	PORT0_PIDR_PIDR03_0 = 0x0
	// High level
	PORT0_PIDR_PIDR03_1 = 0x1
	// Position of PIDR04 field.
	PORT0_PIDR_PIDR04_Pos = 0x4
	// Bit mask of PIDR04 field.
	PORT0_PIDR_PIDR04_Msk = 0x10
	// Bit PIDR04.
	PORT0_PIDR_PIDR04 = 0x10
	// Low level
	PORT0_PIDR_PIDR04_0 = 0x0
	// High level
	PORT0_PIDR_PIDR04_1 = 0x1
	// Position of PIDR05 field.
	PORT0_PIDR_PIDR05_Pos = 0x5
	// Bit mask of PIDR05 field.
	PORT0_PIDR_PIDR05_Msk = 0x20
	// Bit PIDR05.
	PORT0_PIDR_PIDR05 = 0x20
	// Low level
	PORT0_PIDR_PIDR05_0 = 0x0
	// High level
	PORT0_PIDR_PIDR05_1 = 0x1
	// Position of PIDR06 field.
	PORT0_PIDR_PIDR06_Pos = 0x6
	// Bit mask of PIDR06 field.
	PORT0_PIDR_PIDR06_Msk = 0x40
	// Bit PIDR06.
	PORT0_PIDR_PIDR06 = 0x40
	// Low level
	PORT0_PIDR_PIDR06_0 = 0x0
	// High level
	PORT0_PIDR_PIDR06_1 = 0x1
	// Position of PIDR07 field.
	PORT0_PIDR_PIDR07_Pos = 0x7
	// Bit mask of PIDR07 field.
	PORT0_PIDR_PIDR07_Msk = 0x80
	// Bit PIDR07.
	PORT0_PIDR_PIDR07 = 0x80
	// Low level
	PORT0_PIDR_PIDR07_0 = 0x0
	// High level
	PORT0_PIDR_PIDR07_1 = 0x1
	// Position of PIDR08 field.
	PORT0_PIDR_PIDR08_Pos = 0x8
	// Bit mask of PIDR08 field.
	PORT0_PIDR_PIDR08_Msk = 0x100
	// Bit PIDR08.
	PORT0_PIDR_PIDR08 = 0x100
	// Low level
	PORT0_PIDR_PIDR08_0 = 0x0
	// High level
	PORT0_PIDR_PIDR08_1 = 0x1
	// Position of PIDR09 field.
	PORT0_PIDR_PIDR09_Pos = 0x9
	// Bit mask of PIDR09 field.
	PORT0_PIDR_PIDR09_Msk = 0x200
	// Bit PIDR09.
	PORT0_PIDR_PIDR09 = 0x200
	// Low level
	PORT0_PIDR_PIDR09_0 = 0x0
	// High level
	PORT0_PIDR_PIDR09_1 = 0x1
	// Position of PIDR10 field.
	PORT0_PIDR_PIDR10_Pos = 0xa
	// Bit mask of PIDR10 field.
	PORT0_PIDR_PIDR10_Msk = 0x400
	// Bit PIDR10.
	PORT0_PIDR_PIDR10 = 0x400
	// Low level
	PORT0_PIDR_PIDR10_0 = 0x0
	// High level
	PORT0_PIDR_PIDR10_1 = 0x1
	// Position of PIDR11 field.
	PORT0_PIDR_PIDR11_Pos = 0xb
	// Bit mask of PIDR11 field.
	PORT0_PIDR_PIDR11_Msk = 0x800
	// Bit PIDR11.
	PORT0_PIDR_PIDR11 = 0x800
	// Low level
	PORT0_PIDR_PIDR11_0 = 0x0
	// High level
	PORT0_PIDR_PIDR11_1 = 0x1
	// Position of PIDR12 field.
	PORT0_PIDR_PIDR12_Pos = 0xc
	// Bit mask of PIDR12 field.
	PORT0_PIDR_PIDR12_Msk = 0x1000
	// Bit PIDR12.
	PORT0_PIDR_PIDR12 = 0x1000
	// Low level
	PORT0_PIDR_PIDR12_0 = 0x0
	// High level
	PORT0_PIDR_PIDR12_1 = 0x1
	// Position of PIDR13 field.
	PORT0_PIDR_PIDR13_Pos = 0xd
	// Bit mask of PIDR13 field.
	PORT0_PIDR_PIDR13_Msk = 0x2000
	// Bit PIDR13.
	PORT0_PIDR_PIDR13 = 0x2000
	// Low level
	PORT0_PIDR_PIDR13_0 = 0x0
	// High level
	PORT0_PIDR_PIDR13_1 = 0x1
	// Position of PIDR14 field.
	PORT0_PIDR_PIDR14_Pos = 0xe
	// Bit mask of PIDR14 field.
	PORT0_PIDR_PIDR14_Msk = 0x4000
	// Bit PIDR14.
	PORT0_PIDR_PIDR14 = 0x4000
	// Low level
	PORT0_PIDR_PIDR14_0 = 0x0
	// High level
	PORT0_PIDR_PIDR14_1 = 0x1
	// Position of PIDR15 field.
	PORT0_PIDR_PIDR15_Pos = 0xf
	// Bit mask of PIDR15 field.
	PORT0_PIDR_PIDR15_Msk = 0x8000
	// Bit PIDR15.
	PORT0_PIDR_PIDR15 = 0x8000
	// Low level
	PORT0_PIDR_PIDR15_0 = 0x0
	// High level
	PORT0_PIDR_PIDR15_1 = 0x1

	// PCNTR3: Port Control Register 3
	// Position of POSR00 field.
	PORT0_PCNTR3_POSR00_Pos = 0x0
	// Bit mask of POSR00 field.
	PORT0_PCNTR3_POSR00_Msk = 0x1
	// Bit POSR00.
	PORT0_PCNTR3_POSR00 = 0x1
	// No effect on output
	PORT0_PCNTR3_POSR00_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR00_1 = 0x1
	// Position of POSR01 field.
	PORT0_PCNTR3_POSR01_Pos = 0x1
	// Bit mask of POSR01 field.
	PORT0_PCNTR3_POSR01_Msk = 0x2
	// Bit POSR01.
	PORT0_PCNTR3_POSR01 = 0x2
	// No effect on output
	PORT0_PCNTR3_POSR01_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR01_1 = 0x1
	// Position of POSR02 field.
	PORT0_PCNTR3_POSR02_Pos = 0x2
	// Bit mask of POSR02 field.
	PORT0_PCNTR3_POSR02_Msk = 0x4
	// Bit POSR02.
	PORT0_PCNTR3_POSR02 = 0x4
	// No effect on output
	PORT0_PCNTR3_POSR02_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR02_1 = 0x1
	// Position of POSR03 field.
	PORT0_PCNTR3_POSR03_Pos = 0x3
	// Bit mask of POSR03 field.
	PORT0_PCNTR3_POSR03_Msk = 0x8
	// Bit POSR03.
	PORT0_PCNTR3_POSR03 = 0x8
	// No effect on output
	PORT0_PCNTR3_POSR03_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR03_1 = 0x1
	// Position of POSR04 field.
	PORT0_PCNTR3_POSR04_Pos = 0x4
	// Bit mask of POSR04 field.
	PORT0_PCNTR3_POSR04_Msk = 0x10
	// Bit POSR04.
	PORT0_PCNTR3_POSR04 = 0x10
	// No effect on output
	PORT0_PCNTR3_POSR04_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR04_1 = 0x1
	// Position of POSR05 field.
	PORT0_PCNTR3_POSR05_Pos = 0x5
	// Bit mask of POSR05 field.
	PORT0_PCNTR3_POSR05_Msk = 0x20
	// Bit POSR05.
	PORT0_PCNTR3_POSR05 = 0x20
	// No effect on output
	PORT0_PCNTR3_POSR05_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR05_1 = 0x1
	// Position of POSR06 field.
	PORT0_PCNTR3_POSR06_Pos = 0x6
	// Bit mask of POSR06 field.
	PORT0_PCNTR3_POSR06_Msk = 0x40
	// Bit POSR06.
	PORT0_PCNTR3_POSR06 = 0x40
	// No effect on output
	PORT0_PCNTR3_POSR06_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR06_1 = 0x1
	// Position of POSR07 field.
	PORT0_PCNTR3_POSR07_Pos = 0x7
	// Bit mask of POSR07 field.
	PORT0_PCNTR3_POSR07_Msk = 0x80
	// Bit POSR07.
	PORT0_PCNTR3_POSR07 = 0x80
	// No effect on output
	PORT0_PCNTR3_POSR07_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR07_1 = 0x1
	// Position of POSR08 field.
	PORT0_PCNTR3_POSR08_Pos = 0x8
	// Bit mask of POSR08 field.
	PORT0_PCNTR3_POSR08_Msk = 0x100
	// Bit POSR08.
	PORT0_PCNTR3_POSR08 = 0x100
	// No effect on output
	PORT0_PCNTR3_POSR08_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR08_1 = 0x1
	// Position of POSR09 field.
	PORT0_PCNTR3_POSR09_Pos = 0x9
	// Bit mask of POSR09 field.
	PORT0_PCNTR3_POSR09_Msk = 0x200
	// Bit POSR09.
	PORT0_PCNTR3_POSR09 = 0x200
	// No effect on output
	PORT0_PCNTR3_POSR09_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR09_1 = 0x1
	// Position of POSR10 field.
	PORT0_PCNTR3_POSR10_Pos = 0xa
	// Bit mask of POSR10 field.
	PORT0_PCNTR3_POSR10_Msk = 0x400
	// Bit POSR10.
	PORT0_PCNTR3_POSR10 = 0x400
	// No effect on output
	PORT0_PCNTR3_POSR10_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR10_1 = 0x1
	// Position of POSR11 field.
	PORT0_PCNTR3_POSR11_Pos = 0xb
	// Bit mask of POSR11 field.
	PORT0_PCNTR3_POSR11_Msk = 0x800
	// Bit POSR11.
	PORT0_PCNTR3_POSR11 = 0x800
	// No effect on output
	PORT0_PCNTR3_POSR11_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR11_1 = 0x1
	// Position of POSR12 field.
	PORT0_PCNTR3_POSR12_Pos = 0xc
	// Bit mask of POSR12 field.
	PORT0_PCNTR3_POSR12_Msk = 0x1000
	// Bit POSR12.
	PORT0_PCNTR3_POSR12 = 0x1000
	// No effect on output
	PORT0_PCNTR3_POSR12_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR12_1 = 0x1
	// Position of POSR13 field.
	PORT0_PCNTR3_POSR13_Pos = 0xd
	// Bit mask of POSR13 field.
	PORT0_PCNTR3_POSR13_Msk = 0x2000
	// Bit POSR13.
	PORT0_PCNTR3_POSR13 = 0x2000
	// No effect on output
	PORT0_PCNTR3_POSR13_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR13_1 = 0x1
	// Position of POSR14 field.
	PORT0_PCNTR3_POSR14_Pos = 0xe
	// Bit mask of POSR14 field.
	PORT0_PCNTR3_POSR14_Msk = 0x4000
	// Bit POSR14.
	PORT0_PCNTR3_POSR14 = 0x4000
	// No effect on output
	PORT0_PCNTR3_POSR14_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR14_1 = 0x1
	// Position of POSR15 field.
	PORT0_PCNTR3_POSR15_Pos = 0xf
	// Bit mask of POSR15 field.
	PORT0_PCNTR3_POSR15_Msk = 0x8000
	// Bit POSR15.
	PORT0_PCNTR3_POSR15 = 0x8000
	// No effect on output
	PORT0_PCNTR3_POSR15_0 = 0x0
	// High output
	PORT0_PCNTR3_POSR15_1 = 0x1
	// Position of PORR00 field.
	PORT0_PCNTR3_PORR00_Pos = 0x10
	// Bit mask of PORR00 field.
	PORT0_PCNTR3_PORR00_Msk = 0x10000
	// Bit PORR00.
	PORT0_PCNTR3_PORR00 = 0x10000
	// No effect on output
	PORT0_PCNTR3_PORR00_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR00_1 = 0x1
	// Position of PORR01 field.
	PORT0_PCNTR3_PORR01_Pos = 0x11
	// Bit mask of PORR01 field.
	PORT0_PCNTR3_PORR01_Msk = 0x20000
	// Bit PORR01.
	PORT0_PCNTR3_PORR01 = 0x20000
	// No effect on output
	PORT0_PCNTR3_PORR01_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR01_1 = 0x1
	// Position of PORR02 field.
	PORT0_PCNTR3_PORR02_Pos = 0x12
	// Bit mask of PORR02 field.
	PORT0_PCNTR3_PORR02_Msk = 0x40000
	// Bit PORR02.
	PORT0_PCNTR3_PORR02 = 0x40000
	// No effect on output
	PORT0_PCNTR3_PORR02_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR02_1 = 0x1
	// Position of PORR03 field.
	PORT0_PCNTR3_PORR03_Pos = 0x13
	// Bit mask of PORR03 field.
	PORT0_PCNTR3_PORR03_Msk = 0x80000
	// Bit PORR03.
	PORT0_PCNTR3_PORR03 = 0x80000
	// No effect on output
	PORT0_PCNTR3_PORR03_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR03_1 = 0x1
	// Position of PORR04 field.
	PORT0_PCNTR3_PORR04_Pos = 0x14
	// Bit mask of PORR04 field.
	PORT0_PCNTR3_PORR04_Msk = 0x100000
	// Bit PORR04.
	PORT0_PCNTR3_PORR04 = 0x100000
	// No effect on output
	PORT0_PCNTR3_PORR04_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR04_1 = 0x1
	// Position of PORR05 field.
	PORT0_PCNTR3_PORR05_Pos = 0x15
	// Bit mask of PORR05 field.
	PORT0_PCNTR3_PORR05_Msk = 0x200000
	// Bit PORR05.
	PORT0_PCNTR3_PORR05 = 0x200000
	// No effect on output
	PORT0_PCNTR3_PORR05_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR05_1 = 0x1
	// Position of PORR06 field.
	PORT0_PCNTR3_PORR06_Pos = 0x16
	// Bit mask of PORR06 field.
	PORT0_PCNTR3_PORR06_Msk = 0x400000
	// Bit PORR06.
	PORT0_PCNTR3_PORR06 = 0x400000
	// No effect on output
	PORT0_PCNTR3_PORR06_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR06_1 = 0x1
	// Position of PORR07 field.
	PORT0_PCNTR3_PORR07_Pos = 0x17
	// Bit mask of PORR07 field.
	PORT0_PCNTR3_PORR07_Msk = 0x800000
	// Bit PORR07.
	PORT0_PCNTR3_PORR07 = 0x800000
	// No effect on output
	PORT0_PCNTR3_PORR07_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR07_1 = 0x1
	// Position of PORR08 field.
	PORT0_PCNTR3_PORR08_Pos = 0x18
	// Bit mask of PORR08 field.
	PORT0_PCNTR3_PORR08_Msk = 0x1000000
	// Bit PORR08.
	PORT0_PCNTR3_PORR08 = 0x1000000
	// No effect on output
	PORT0_PCNTR3_PORR08_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR08_1 = 0x1
	// Position of PORR09 field.
	PORT0_PCNTR3_PORR09_Pos = 0x19
	// Bit mask of PORR09 field.
	PORT0_PCNTR3_PORR09_Msk = 0x2000000
	// Bit PORR09.
	PORT0_PCNTR3_PORR09 = 0x2000000
	// No effect on output
	PORT0_PCNTR3_PORR09_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR09_1 = 0x1
	// Position of PORR10 field.
	PORT0_PCNTR3_PORR10_Pos = 0x1a
	// Bit mask of PORR10 field.
	PORT0_PCNTR3_PORR10_Msk = 0x4000000
	// Bit PORR10.
	PORT0_PCNTR3_PORR10 = 0x4000000
	// No effect on output
	PORT0_PCNTR3_PORR10_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR10_1 = 0x1
	// Position of PORR11 field.
	PORT0_PCNTR3_PORR11_Pos = 0x1b
	// Bit mask of PORR11 field.
	PORT0_PCNTR3_PORR11_Msk = 0x8000000
	// Bit PORR11.
	PORT0_PCNTR3_PORR11 = 0x8000000
	// No effect on output
	PORT0_PCNTR3_PORR11_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR11_1 = 0x1
	// Position of PORR12 field.
	PORT0_PCNTR3_PORR12_Pos = 0x1c
	// Bit mask of PORR12 field.
	PORT0_PCNTR3_PORR12_Msk = 0x10000000
	// Bit PORR12.
	PORT0_PCNTR3_PORR12 = 0x10000000
	// No effect on output
	PORT0_PCNTR3_PORR12_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR12_1 = 0x1
	// Position of PORR13 field.
	PORT0_PCNTR3_PORR13_Pos = 0x1d
	// Bit mask of PORR13 field.
	PORT0_PCNTR3_PORR13_Msk = 0x20000000
	// Bit PORR13.
	PORT0_PCNTR3_PORR13 = 0x20000000
	// No effect on output
	PORT0_PCNTR3_PORR13_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR13_1 = 0x1
	// Position of PORR14 field.
	PORT0_PCNTR3_PORR14_Pos = 0x1e
	// Bit mask of PORR14 field.
	PORT0_PCNTR3_PORR14_Msk = 0x40000000
	// Bit PORR14.
	PORT0_PCNTR3_PORR14 = 0x40000000
	// No effect on output
	PORT0_PCNTR3_PORR14_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR14_1 = 0x1
	// Position of PORR15 field.
	PORT0_PCNTR3_PORR15_Pos = 0x1f
	// Bit mask of PORR15 field.
	PORT0_PCNTR3_PORR15_Msk = 0x80000000
	// Bit PORR15.
	PORT0_PCNTR3_PORR15 = 0x80000000
	// No effect on output
	PORT0_PCNTR3_PORR15_0 = 0x0
	// Low output
	PORT0_PCNTR3_PORR15_1 = 0x1

	// PORR: Port Control Register 3
	// Position of PORR00 field.
	PORT0_PORR_PORR00_Pos = 0x0
	// Bit mask of PORR00 field.
	PORT0_PORR_PORR00_Msk = 0x1
	// Bit PORR00.
	PORT0_PORR_PORR00 = 0x1
	// No effect on output
	PORT0_PORR_PORR00_0 = 0x0
	// Low output
	PORT0_PORR_PORR00_1 = 0x1
	// Position of PORR01 field.
	PORT0_PORR_PORR01_Pos = 0x1
	// Bit mask of PORR01 field.
	PORT0_PORR_PORR01_Msk = 0x2
	// Bit PORR01.
	PORT0_PORR_PORR01 = 0x2
	// No effect on output
	PORT0_PORR_PORR01_0 = 0x0
	// Low output
	PORT0_PORR_PORR01_1 = 0x1
	// Position of PORR02 field.
	PORT0_PORR_PORR02_Pos = 0x2
	// Bit mask of PORR02 field.
	PORT0_PORR_PORR02_Msk = 0x4
	// Bit PORR02.
	PORT0_PORR_PORR02 = 0x4
	// No effect on output
	PORT0_PORR_PORR02_0 = 0x0
	// Low output
	PORT0_PORR_PORR02_1 = 0x1
	// Position of PORR03 field.
	PORT0_PORR_PORR03_Pos = 0x3
	// Bit mask of PORR03 field.
	PORT0_PORR_PORR03_Msk = 0x8
	// Bit PORR03.
	PORT0_PORR_PORR03 = 0x8
	// No effect on output
	PORT0_PORR_PORR03_0 = 0x0
	// Low output
	PORT0_PORR_PORR03_1 = 0x1
	// Position of PORR04 field.
	PORT0_PORR_PORR04_Pos = 0x4
	// Bit mask of PORR04 field.
	PORT0_PORR_PORR04_Msk = 0x10
	// Bit PORR04.
	PORT0_PORR_PORR04 = 0x10
	// No effect on output
	PORT0_PORR_PORR04_0 = 0x0
	// Low output
	PORT0_PORR_PORR04_1 = 0x1
	// Position of PORR05 field.
	PORT0_PORR_PORR05_Pos = 0x5
	// Bit mask of PORR05 field.
	PORT0_PORR_PORR05_Msk = 0x20
	// Bit PORR05.
	PORT0_PORR_PORR05 = 0x20
	// No effect on output
	PORT0_PORR_PORR05_0 = 0x0
	// Low output
	PORT0_PORR_PORR05_1 = 0x1
	// Position of PORR06 field.
	PORT0_PORR_PORR06_Pos = 0x6
	// Bit mask of PORR06 field.
	PORT0_PORR_PORR06_Msk = 0x40
	// Bit PORR06.
	PORT0_PORR_PORR06 = 0x40
	// No effect on output
	PORT0_PORR_PORR06_0 = 0x0
	// Low output
	PORT0_PORR_PORR06_1 = 0x1
	// Position of PORR07 field.
	PORT0_PORR_PORR07_Pos = 0x7
	// Bit mask of PORR07 field.
	PORT0_PORR_PORR07_Msk = 0x80
	// Bit PORR07.
	PORT0_PORR_PORR07 = 0x80
	// No effect on output
	PORT0_PORR_PORR07_0 = 0x0
	// Low output
	PORT0_PORR_PORR07_1 = 0x1
	// Position of PORR08 field.
	PORT0_PORR_PORR08_Pos = 0x8
	// Bit mask of PORR08 field.
	PORT0_PORR_PORR08_Msk = 0x100
	// Bit PORR08.
	PORT0_PORR_PORR08 = 0x100
	// No effect on output
	PORT0_PORR_PORR08_0 = 0x0
	// Low output
	PORT0_PORR_PORR08_1 = 0x1
	// Position of PORR09 field.
	PORT0_PORR_PORR09_Pos = 0x9
	// Bit mask of PORR09 field.
	PORT0_PORR_PORR09_Msk = 0x200
	// Bit PORR09.
	PORT0_PORR_PORR09 = 0x200
	// No effect on output
	PORT0_PORR_PORR09_0 = 0x0
	// Low output
	PORT0_PORR_PORR09_1 = 0x1
	// Position of PORR10 field.
	PORT0_PORR_PORR10_Pos = 0xa
	// Bit mask of PORR10 field.
	PORT0_PORR_PORR10_Msk = 0x400
	// Bit PORR10.
	PORT0_PORR_PORR10 = 0x400
	// No effect on output
	PORT0_PORR_PORR10_0 = 0x0
	// Low output
	PORT0_PORR_PORR10_1 = 0x1
	// Position of PORR11 field.
	PORT0_PORR_PORR11_Pos = 0xb
	// Bit mask of PORR11 field.
	PORT0_PORR_PORR11_Msk = 0x800
	// Bit PORR11.
	PORT0_PORR_PORR11 = 0x800
	// No effect on output
	PORT0_PORR_PORR11_0 = 0x0
	// Low output
	PORT0_PORR_PORR11_1 = 0x1
	// Position of PORR12 field.
	PORT0_PORR_PORR12_Pos = 0xc
	// Bit mask of PORR12 field.
	PORT0_PORR_PORR12_Msk = 0x1000
	// Bit PORR12.
	PORT0_PORR_PORR12 = 0x1000
	// No effect on output
	PORT0_PORR_PORR12_0 = 0x0
	// Low output
	PORT0_PORR_PORR12_1 = 0x1
	// Position of PORR13 field.
	PORT0_PORR_PORR13_Pos = 0xd
	// Bit mask of PORR13 field.
	PORT0_PORR_PORR13_Msk = 0x2000
	// Bit PORR13.
	PORT0_PORR_PORR13 = 0x2000
	// No effect on output
	PORT0_PORR_PORR13_0 = 0x0
	// Low output
	PORT0_PORR_PORR13_1 = 0x1
	// Position of PORR14 field.
	PORT0_PORR_PORR14_Pos = 0xe
	// Bit mask of PORR14 field.
	PORT0_PORR_PORR14_Msk = 0x4000
	// Bit PORR14.
	PORT0_PORR_PORR14 = 0x4000
	// No effect on output
	PORT0_PORR_PORR14_0 = 0x0
	// Low output
	PORT0_PORR_PORR14_1 = 0x1
	// Position of PORR15 field.
	PORT0_PORR_PORR15_Pos = 0xf
	// Bit mask of PORR15 field.
	PORT0_PORR_PORR15_Msk = 0x8000
	// Bit PORR15.
	PORT0_PORR_PORR15 = 0x8000
	// No effect on output
	PORT0_PORR_PORR15_0 = 0x0
	// Low output
	PORT0_PORR_PORR15_1 = 0x1

	// POSR: Port Control Register 3
	// Position of POSR00 field.
	PORT0_POSR_POSR00_Pos = 0x0
	// Bit mask of POSR00 field.
	PORT0_POSR_POSR00_Msk = 0x1
	// Bit POSR00.
	PORT0_POSR_POSR00 = 0x1
	// No effect on output
	PORT0_POSR_POSR00_0 = 0x0
	// High output
	PORT0_POSR_POSR00_1 = 0x1
	// Position of POSR01 field.
	PORT0_POSR_POSR01_Pos = 0x1
	// Bit mask of POSR01 field.
	PORT0_POSR_POSR01_Msk = 0x2
	// Bit POSR01.
	PORT0_POSR_POSR01 = 0x2
	// No effect on output
	PORT0_POSR_POSR01_0 = 0x0
	// High output
	PORT0_POSR_POSR01_1 = 0x1
	// Position of POSR02 field.
	PORT0_POSR_POSR02_Pos = 0x2
	// Bit mask of POSR02 field.
	PORT0_POSR_POSR02_Msk = 0x4
	// Bit POSR02.
	PORT0_POSR_POSR02 = 0x4
	// No effect on output
	PORT0_POSR_POSR02_0 = 0x0
	// High output
	PORT0_POSR_POSR02_1 = 0x1
	// Position of POSR03 field.
	PORT0_POSR_POSR03_Pos = 0x3
	// Bit mask of POSR03 field.
	PORT0_POSR_POSR03_Msk = 0x8
	// Bit POSR03.
	PORT0_POSR_POSR03 = 0x8
	// No effect on output
	PORT0_POSR_POSR03_0 = 0x0
	// High output
	PORT0_POSR_POSR03_1 = 0x1
	// Position of POSR04 field.
	PORT0_POSR_POSR04_Pos = 0x4
	// Bit mask of POSR04 field.
	PORT0_POSR_POSR04_Msk = 0x10
	// Bit POSR04.
	PORT0_POSR_POSR04 = 0x10
	// No effect on output
	PORT0_POSR_POSR04_0 = 0x0
	// High output
	PORT0_POSR_POSR04_1 = 0x1
	// Position of POSR05 field.
	PORT0_POSR_POSR05_Pos = 0x5
	// Bit mask of POSR05 field.
	PORT0_POSR_POSR05_Msk = 0x20
	// Bit POSR05.
	PORT0_POSR_POSR05 = 0x20
	// No effect on output
	PORT0_POSR_POSR05_0 = 0x0
	// High output
	PORT0_POSR_POSR05_1 = 0x1
	// Position of POSR06 field.
	PORT0_POSR_POSR06_Pos = 0x6
	// Bit mask of POSR06 field.
	PORT0_POSR_POSR06_Msk = 0x40
	// Bit POSR06.
	PORT0_POSR_POSR06 = 0x40
	// No effect on output
	PORT0_POSR_POSR06_0 = 0x0
	// High output
	PORT0_POSR_POSR06_1 = 0x1
	// Position of POSR07 field.
	PORT0_POSR_POSR07_Pos = 0x7
	// Bit mask of POSR07 field.
	PORT0_POSR_POSR07_Msk = 0x80
	// Bit POSR07.
	PORT0_POSR_POSR07 = 0x80
	// No effect on output
	PORT0_POSR_POSR07_0 = 0x0
	// High output
	PORT0_POSR_POSR07_1 = 0x1
	// Position of POSR08 field.
	PORT0_POSR_POSR08_Pos = 0x8
	// Bit mask of POSR08 field.
	PORT0_POSR_POSR08_Msk = 0x100
	// Bit POSR08.
	PORT0_POSR_POSR08 = 0x100
	// No effect on output
	PORT0_POSR_POSR08_0 = 0x0
	// High output
	PORT0_POSR_POSR08_1 = 0x1
	// Position of POSR09 field.
	PORT0_POSR_POSR09_Pos = 0x9
	// Bit mask of POSR09 field.
	PORT0_POSR_POSR09_Msk = 0x200
	// Bit POSR09.
	PORT0_POSR_POSR09 = 0x200
	// No effect on output
	PORT0_POSR_POSR09_0 = 0x0
	// High output
	PORT0_POSR_POSR09_1 = 0x1
	// Position of POSR10 field.
	PORT0_POSR_POSR10_Pos = 0xa
	// Bit mask of POSR10 field.
	PORT0_POSR_POSR10_Msk = 0x400
	// Bit POSR10.
	PORT0_POSR_POSR10 = 0x400
	// No effect on output
	PORT0_POSR_POSR10_0 = 0x0
	// High output
	PORT0_POSR_POSR10_1 = 0x1
	// Position of POSR11 field.
	PORT0_POSR_POSR11_Pos = 0xb
	// Bit mask of POSR11 field.
	PORT0_POSR_POSR11_Msk = 0x800
	// Bit POSR11.
	PORT0_POSR_POSR11 = 0x800
	// No effect on output
	PORT0_POSR_POSR11_0 = 0x0
	// High output
	PORT0_POSR_POSR11_1 = 0x1
	// Position of POSR12 field.
	PORT0_POSR_POSR12_Pos = 0xc
	// Bit mask of POSR12 field.
	PORT0_POSR_POSR12_Msk = 0x1000
	// Bit POSR12.
	PORT0_POSR_POSR12 = 0x1000
	// No effect on output
	PORT0_POSR_POSR12_0 = 0x0
	// High output
	PORT0_POSR_POSR12_1 = 0x1
	// Position of POSR13 field.
	PORT0_POSR_POSR13_Pos = 0xd
	// Bit mask of POSR13 field.
	PORT0_POSR_POSR13_Msk = 0x2000
	// Bit POSR13.
	PORT0_POSR_POSR13 = 0x2000
	// No effect on output
	PORT0_POSR_POSR13_0 = 0x0
	// High output
	PORT0_POSR_POSR13_1 = 0x1
	// Position of POSR14 field.
	PORT0_POSR_POSR14_Pos = 0xe
	// Bit mask of POSR14 field.
	PORT0_POSR_POSR14_Msk = 0x4000
	// Bit POSR14.
	PORT0_POSR_POSR14 = 0x4000
	// No effect on output
	PORT0_POSR_POSR14_0 = 0x0
	// High output
	PORT0_POSR_POSR14_1 = 0x1
	// Position of POSR15 field.
	PORT0_POSR_POSR15_Pos = 0xf
	// Bit mask of POSR15 field.
	PORT0_POSR_POSR15_Msk = 0x8000
	// Bit POSR15.
	PORT0_POSR_POSR15 = 0x8000
	// No effect on output
	PORT0_POSR_POSR15_0 = 0x0
	// High output
	PORT0_POSR_POSR15_1 = 0x1
)

// Constants for PORT1: Pmn Pin FunctionPort 1 Control RegistersPmn Pin Function Control Register
const (
	// PCNTR1: Port Control Register 1
	// Position of PDR00 field.
	PORT1_PCNTR1_PDR00_Pos = 0x0
	// Bit mask of PDR00 field.
	PORT1_PCNTR1_PDR00_Msk = 0x1
	// Bit PDR00.
	PORT1_PCNTR1_PDR00 = 0x1
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR00_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR00_1 = 0x1
	// Position of PDR01 field.
	PORT1_PCNTR1_PDR01_Pos = 0x1
	// Bit mask of PDR01 field.
	PORT1_PCNTR1_PDR01_Msk = 0x2
	// Bit PDR01.
	PORT1_PCNTR1_PDR01 = 0x2
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR01_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR01_1 = 0x1
	// Position of PDR02 field.
	PORT1_PCNTR1_PDR02_Pos = 0x2
	// Bit mask of PDR02 field.
	PORT1_PCNTR1_PDR02_Msk = 0x4
	// Bit PDR02.
	PORT1_PCNTR1_PDR02 = 0x4
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR02_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR02_1 = 0x1
	// Position of PDR03 field.
	PORT1_PCNTR1_PDR03_Pos = 0x3
	// Bit mask of PDR03 field.
	PORT1_PCNTR1_PDR03_Msk = 0x8
	// Bit PDR03.
	PORT1_PCNTR1_PDR03 = 0x8
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR03_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR03_1 = 0x1
	// Position of PDR04 field.
	PORT1_PCNTR1_PDR04_Pos = 0x4
	// Bit mask of PDR04 field.
	PORT1_PCNTR1_PDR04_Msk = 0x10
	// Bit PDR04.
	PORT1_PCNTR1_PDR04 = 0x10
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR04_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR04_1 = 0x1
	// Position of PDR05 field.
	PORT1_PCNTR1_PDR05_Pos = 0x5
	// Bit mask of PDR05 field.
	PORT1_PCNTR1_PDR05_Msk = 0x20
	// Bit PDR05.
	PORT1_PCNTR1_PDR05 = 0x20
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR05_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR05_1 = 0x1
	// Position of PDR06 field.
	PORT1_PCNTR1_PDR06_Pos = 0x6
	// Bit mask of PDR06 field.
	PORT1_PCNTR1_PDR06_Msk = 0x40
	// Bit PDR06.
	PORT1_PCNTR1_PDR06 = 0x40
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR06_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR06_1 = 0x1
	// Position of PDR07 field.
	PORT1_PCNTR1_PDR07_Pos = 0x7
	// Bit mask of PDR07 field.
	PORT1_PCNTR1_PDR07_Msk = 0x80
	// Bit PDR07.
	PORT1_PCNTR1_PDR07 = 0x80
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR07_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR07_1 = 0x1
	// Position of PDR08 field.
	PORT1_PCNTR1_PDR08_Pos = 0x8
	// Bit mask of PDR08 field.
	PORT1_PCNTR1_PDR08_Msk = 0x100
	// Bit PDR08.
	PORT1_PCNTR1_PDR08 = 0x100
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR08_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR08_1 = 0x1
	// Position of PDR09 field.
	PORT1_PCNTR1_PDR09_Pos = 0x9
	// Bit mask of PDR09 field.
	PORT1_PCNTR1_PDR09_Msk = 0x200
	// Bit PDR09.
	PORT1_PCNTR1_PDR09 = 0x200
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR09_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR09_1 = 0x1
	// Position of PDR10 field.
	PORT1_PCNTR1_PDR10_Pos = 0xa
	// Bit mask of PDR10 field.
	PORT1_PCNTR1_PDR10_Msk = 0x400
	// Bit PDR10.
	PORT1_PCNTR1_PDR10 = 0x400
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR10_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR10_1 = 0x1
	// Position of PDR11 field.
	PORT1_PCNTR1_PDR11_Pos = 0xb
	// Bit mask of PDR11 field.
	PORT1_PCNTR1_PDR11_Msk = 0x800
	// Bit PDR11.
	PORT1_PCNTR1_PDR11 = 0x800
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR11_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR11_1 = 0x1
	// Position of PDR12 field.
	PORT1_PCNTR1_PDR12_Pos = 0xc
	// Bit mask of PDR12 field.
	PORT1_PCNTR1_PDR12_Msk = 0x1000
	// Bit PDR12.
	PORT1_PCNTR1_PDR12 = 0x1000
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR12_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR12_1 = 0x1
	// Position of PDR13 field.
	PORT1_PCNTR1_PDR13_Pos = 0xd
	// Bit mask of PDR13 field.
	PORT1_PCNTR1_PDR13_Msk = 0x2000
	// Bit PDR13.
	PORT1_PCNTR1_PDR13 = 0x2000
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR13_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR13_1 = 0x1
	// Position of PDR14 field.
	PORT1_PCNTR1_PDR14_Pos = 0xe
	// Bit mask of PDR14 field.
	PORT1_PCNTR1_PDR14_Msk = 0x4000
	// Bit PDR14.
	PORT1_PCNTR1_PDR14 = 0x4000
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR14_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR14_1 = 0x1
	// Position of PDR15 field.
	PORT1_PCNTR1_PDR15_Pos = 0xf
	// Bit mask of PDR15 field.
	PORT1_PCNTR1_PDR15_Msk = 0x8000
	// Bit PDR15.
	PORT1_PCNTR1_PDR15 = 0x8000
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR15_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PCNTR1_PDR15_1 = 0x1
	// Position of PODR00 field.
	PORT1_PCNTR1_PODR00_Pos = 0x10
	// Bit mask of PODR00 field.
	PORT1_PCNTR1_PODR00_Msk = 0x10000
	// Bit PODR00.
	PORT1_PCNTR1_PODR00 = 0x10000
	// Low output
	PORT1_PCNTR1_PODR00_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR00_1 = 0x1
	// Position of PODR01 field.
	PORT1_PCNTR1_PODR01_Pos = 0x11
	// Bit mask of PODR01 field.
	PORT1_PCNTR1_PODR01_Msk = 0x20000
	// Bit PODR01.
	PORT1_PCNTR1_PODR01 = 0x20000
	// Low output
	PORT1_PCNTR1_PODR01_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR01_1 = 0x1
	// Position of PODR02 field.
	PORT1_PCNTR1_PODR02_Pos = 0x12
	// Bit mask of PODR02 field.
	PORT1_PCNTR1_PODR02_Msk = 0x40000
	// Bit PODR02.
	PORT1_PCNTR1_PODR02 = 0x40000
	// Low output
	PORT1_PCNTR1_PODR02_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR02_1 = 0x1
	// Position of PODR03 field.
	PORT1_PCNTR1_PODR03_Pos = 0x13
	// Bit mask of PODR03 field.
	PORT1_PCNTR1_PODR03_Msk = 0x80000
	// Bit PODR03.
	PORT1_PCNTR1_PODR03 = 0x80000
	// Low output
	PORT1_PCNTR1_PODR03_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR03_1 = 0x1
	// Position of PODR04 field.
	PORT1_PCNTR1_PODR04_Pos = 0x14
	// Bit mask of PODR04 field.
	PORT1_PCNTR1_PODR04_Msk = 0x100000
	// Bit PODR04.
	PORT1_PCNTR1_PODR04 = 0x100000
	// Low output
	PORT1_PCNTR1_PODR04_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR04_1 = 0x1
	// Position of PODR05 field.
	PORT1_PCNTR1_PODR05_Pos = 0x15
	// Bit mask of PODR05 field.
	PORT1_PCNTR1_PODR05_Msk = 0x200000
	// Bit PODR05.
	PORT1_PCNTR1_PODR05 = 0x200000
	// Low output
	PORT1_PCNTR1_PODR05_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR05_1 = 0x1
	// Position of PODR06 field.
	PORT1_PCNTR1_PODR06_Pos = 0x16
	// Bit mask of PODR06 field.
	PORT1_PCNTR1_PODR06_Msk = 0x400000
	// Bit PODR06.
	PORT1_PCNTR1_PODR06 = 0x400000
	// Low output
	PORT1_PCNTR1_PODR06_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR06_1 = 0x1
	// Position of PODR07 field.
	PORT1_PCNTR1_PODR07_Pos = 0x17
	// Bit mask of PODR07 field.
	PORT1_PCNTR1_PODR07_Msk = 0x800000
	// Bit PODR07.
	PORT1_PCNTR1_PODR07 = 0x800000
	// Low output
	PORT1_PCNTR1_PODR07_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR07_1 = 0x1
	// Position of PODR08 field.
	PORT1_PCNTR1_PODR08_Pos = 0x18
	// Bit mask of PODR08 field.
	PORT1_PCNTR1_PODR08_Msk = 0x1000000
	// Bit PODR08.
	PORT1_PCNTR1_PODR08 = 0x1000000
	// Low output
	PORT1_PCNTR1_PODR08_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR08_1 = 0x1
	// Position of PODR09 field.
	PORT1_PCNTR1_PODR09_Pos = 0x19
	// Bit mask of PODR09 field.
	PORT1_PCNTR1_PODR09_Msk = 0x2000000
	// Bit PODR09.
	PORT1_PCNTR1_PODR09 = 0x2000000
	// Low output
	PORT1_PCNTR1_PODR09_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR09_1 = 0x1
	// Position of PODR10 field.
	PORT1_PCNTR1_PODR10_Pos = 0x1a
	// Bit mask of PODR10 field.
	PORT1_PCNTR1_PODR10_Msk = 0x4000000
	// Bit PODR10.
	PORT1_PCNTR1_PODR10 = 0x4000000
	// Low output
	PORT1_PCNTR1_PODR10_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR10_1 = 0x1
	// Position of PODR11 field.
	PORT1_PCNTR1_PODR11_Pos = 0x1b
	// Bit mask of PODR11 field.
	PORT1_PCNTR1_PODR11_Msk = 0x8000000
	// Bit PODR11.
	PORT1_PCNTR1_PODR11 = 0x8000000
	// Low output
	PORT1_PCNTR1_PODR11_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR11_1 = 0x1
	// Position of PODR12 field.
	PORT1_PCNTR1_PODR12_Pos = 0x1c
	// Bit mask of PODR12 field.
	PORT1_PCNTR1_PODR12_Msk = 0x10000000
	// Bit PODR12.
	PORT1_PCNTR1_PODR12 = 0x10000000
	// Low output
	PORT1_PCNTR1_PODR12_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR12_1 = 0x1
	// Position of PODR13 field.
	PORT1_PCNTR1_PODR13_Pos = 0x1d
	// Bit mask of PODR13 field.
	PORT1_PCNTR1_PODR13_Msk = 0x20000000
	// Bit PODR13.
	PORT1_PCNTR1_PODR13 = 0x20000000
	// Low output
	PORT1_PCNTR1_PODR13_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR13_1 = 0x1
	// Position of PODR14 field.
	PORT1_PCNTR1_PODR14_Pos = 0x1e
	// Bit mask of PODR14 field.
	PORT1_PCNTR1_PODR14_Msk = 0x40000000
	// Bit PODR14.
	PORT1_PCNTR1_PODR14 = 0x40000000
	// Low output
	PORT1_PCNTR1_PODR14_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR14_1 = 0x1
	// Position of PODR15 field.
	PORT1_PCNTR1_PODR15_Pos = 0x1f
	// Bit mask of PODR15 field.
	PORT1_PCNTR1_PODR15_Msk = 0x80000000
	// Bit PODR15.
	PORT1_PCNTR1_PODR15 = 0x80000000
	// Low output
	PORT1_PCNTR1_PODR15_0 = 0x0
	// High output
	PORT1_PCNTR1_PODR15_1 = 0x1

	// PODR: Port Control Register 1
	// Position of PODR00 field.
	PORT1_PODR_PODR00_Pos = 0x0
	// Bit mask of PODR00 field.
	PORT1_PODR_PODR00_Msk = 0x1
	// Bit PODR00.
	PORT1_PODR_PODR00 = 0x1
	// Low output
	PORT1_PODR_PODR00_0 = 0x0
	// High output
	PORT1_PODR_PODR00_1 = 0x1
	// Position of PODR01 field.
	PORT1_PODR_PODR01_Pos = 0x1
	// Bit mask of PODR01 field.
	PORT1_PODR_PODR01_Msk = 0x2
	// Bit PODR01.
	PORT1_PODR_PODR01 = 0x2
	// Low output
	PORT1_PODR_PODR01_0 = 0x0
	// High output
	PORT1_PODR_PODR01_1 = 0x1
	// Position of PODR02 field.
	PORT1_PODR_PODR02_Pos = 0x2
	// Bit mask of PODR02 field.
	PORT1_PODR_PODR02_Msk = 0x4
	// Bit PODR02.
	PORT1_PODR_PODR02 = 0x4
	// Low output
	PORT1_PODR_PODR02_0 = 0x0
	// High output
	PORT1_PODR_PODR02_1 = 0x1
	// Position of PODR03 field.
	PORT1_PODR_PODR03_Pos = 0x3
	// Bit mask of PODR03 field.
	PORT1_PODR_PODR03_Msk = 0x8
	// Bit PODR03.
	PORT1_PODR_PODR03 = 0x8
	// Low output
	PORT1_PODR_PODR03_0 = 0x0
	// High output
	PORT1_PODR_PODR03_1 = 0x1
	// Position of PODR04 field.
	PORT1_PODR_PODR04_Pos = 0x4
	// Bit mask of PODR04 field.
	PORT1_PODR_PODR04_Msk = 0x10
	// Bit PODR04.
	PORT1_PODR_PODR04 = 0x10
	// Low output
	PORT1_PODR_PODR04_0 = 0x0
	// High output
	PORT1_PODR_PODR04_1 = 0x1
	// Position of PODR05 field.
	PORT1_PODR_PODR05_Pos = 0x5
	// Bit mask of PODR05 field.
	PORT1_PODR_PODR05_Msk = 0x20
	// Bit PODR05.
	PORT1_PODR_PODR05 = 0x20
	// Low output
	PORT1_PODR_PODR05_0 = 0x0
	// High output
	PORT1_PODR_PODR05_1 = 0x1
	// Position of PODR06 field.
	PORT1_PODR_PODR06_Pos = 0x6
	// Bit mask of PODR06 field.
	PORT1_PODR_PODR06_Msk = 0x40
	// Bit PODR06.
	PORT1_PODR_PODR06 = 0x40
	// Low output
	PORT1_PODR_PODR06_0 = 0x0
	// High output
	PORT1_PODR_PODR06_1 = 0x1
	// Position of PODR07 field.
	PORT1_PODR_PODR07_Pos = 0x7
	// Bit mask of PODR07 field.
	PORT1_PODR_PODR07_Msk = 0x80
	// Bit PODR07.
	PORT1_PODR_PODR07 = 0x80
	// Low output
	PORT1_PODR_PODR07_0 = 0x0
	// High output
	PORT1_PODR_PODR07_1 = 0x1
	// Position of PODR08 field.
	PORT1_PODR_PODR08_Pos = 0x8
	// Bit mask of PODR08 field.
	PORT1_PODR_PODR08_Msk = 0x100
	// Bit PODR08.
	PORT1_PODR_PODR08 = 0x100
	// Low output
	PORT1_PODR_PODR08_0 = 0x0
	// High output
	PORT1_PODR_PODR08_1 = 0x1
	// Position of PODR09 field.
	PORT1_PODR_PODR09_Pos = 0x9
	// Bit mask of PODR09 field.
	PORT1_PODR_PODR09_Msk = 0x200
	// Bit PODR09.
	PORT1_PODR_PODR09 = 0x200
	// Low output
	PORT1_PODR_PODR09_0 = 0x0
	// High output
	PORT1_PODR_PODR09_1 = 0x1
	// Position of PODR10 field.
	PORT1_PODR_PODR10_Pos = 0xa
	// Bit mask of PODR10 field.
	PORT1_PODR_PODR10_Msk = 0x400
	// Bit PODR10.
	PORT1_PODR_PODR10 = 0x400
	// Low output
	PORT1_PODR_PODR10_0 = 0x0
	// High output
	PORT1_PODR_PODR10_1 = 0x1
	// Position of PODR11 field.
	PORT1_PODR_PODR11_Pos = 0xb
	// Bit mask of PODR11 field.
	PORT1_PODR_PODR11_Msk = 0x800
	// Bit PODR11.
	PORT1_PODR_PODR11 = 0x800
	// Low output
	PORT1_PODR_PODR11_0 = 0x0
	// High output
	PORT1_PODR_PODR11_1 = 0x1
	// Position of PODR12 field.
	PORT1_PODR_PODR12_Pos = 0xc
	// Bit mask of PODR12 field.
	PORT1_PODR_PODR12_Msk = 0x1000
	// Bit PODR12.
	PORT1_PODR_PODR12 = 0x1000
	// Low output
	PORT1_PODR_PODR12_0 = 0x0
	// High output
	PORT1_PODR_PODR12_1 = 0x1
	// Position of PODR13 field.
	PORT1_PODR_PODR13_Pos = 0xd
	// Bit mask of PODR13 field.
	PORT1_PODR_PODR13_Msk = 0x2000
	// Bit PODR13.
	PORT1_PODR_PODR13 = 0x2000
	// Low output
	PORT1_PODR_PODR13_0 = 0x0
	// High output
	PORT1_PODR_PODR13_1 = 0x1
	// Position of PODR14 field.
	PORT1_PODR_PODR14_Pos = 0xe
	// Bit mask of PODR14 field.
	PORT1_PODR_PODR14_Msk = 0x4000
	// Bit PODR14.
	PORT1_PODR_PODR14 = 0x4000
	// Low output
	PORT1_PODR_PODR14_0 = 0x0
	// High output
	PORT1_PODR_PODR14_1 = 0x1
	// Position of PODR15 field.
	PORT1_PODR_PODR15_Pos = 0xf
	// Bit mask of PODR15 field.
	PORT1_PODR_PODR15_Msk = 0x8000
	// Bit PODR15.
	PORT1_PODR_PODR15 = 0x8000
	// Low output
	PORT1_PODR_PODR15_0 = 0x0
	// High output
	PORT1_PODR_PODR15_1 = 0x1

	// PDR: Port Control Register 1
	// Position of PDR00 field.
	PORT1_PDR_PDR00_Pos = 0x0
	// Bit mask of PDR00 field.
	PORT1_PDR_PDR00_Msk = 0x1
	// Bit PDR00.
	PORT1_PDR_PDR00 = 0x1
	// Input (functions as an input pin)
	PORT1_PDR_PDR00_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR00_1 = 0x1
	// Position of PDR01 field.
	PORT1_PDR_PDR01_Pos = 0x1
	// Bit mask of PDR01 field.
	PORT1_PDR_PDR01_Msk = 0x2
	// Bit PDR01.
	PORT1_PDR_PDR01 = 0x2
	// Input (functions as an input pin)
	PORT1_PDR_PDR01_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR01_1 = 0x1
	// Position of PDR02 field.
	PORT1_PDR_PDR02_Pos = 0x2
	// Bit mask of PDR02 field.
	PORT1_PDR_PDR02_Msk = 0x4
	// Bit PDR02.
	PORT1_PDR_PDR02 = 0x4
	// Input (functions as an input pin)
	PORT1_PDR_PDR02_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR02_1 = 0x1
	// Position of PDR03 field.
	PORT1_PDR_PDR03_Pos = 0x3
	// Bit mask of PDR03 field.
	PORT1_PDR_PDR03_Msk = 0x8
	// Bit PDR03.
	PORT1_PDR_PDR03 = 0x8
	// Input (functions as an input pin)
	PORT1_PDR_PDR03_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR03_1 = 0x1
	// Position of PDR04 field.
	PORT1_PDR_PDR04_Pos = 0x4
	// Bit mask of PDR04 field.
	PORT1_PDR_PDR04_Msk = 0x10
	// Bit PDR04.
	PORT1_PDR_PDR04 = 0x10
	// Input (functions as an input pin)
	PORT1_PDR_PDR04_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR04_1 = 0x1
	// Position of PDR05 field.
	PORT1_PDR_PDR05_Pos = 0x5
	// Bit mask of PDR05 field.
	PORT1_PDR_PDR05_Msk = 0x20
	// Bit PDR05.
	PORT1_PDR_PDR05 = 0x20
	// Input (functions as an input pin)
	PORT1_PDR_PDR05_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR05_1 = 0x1
	// Position of PDR06 field.
	PORT1_PDR_PDR06_Pos = 0x6
	// Bit mask of PDR06 field.
	PORT1_PDR_PDR06_Msk = 0x40
	// Bit PDR06.
	PORT1_PDR_PDR06 = 0x40
	// Input (functions as an input pin)
	PORT1_PDR_PDR06_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR06_1 = 0x1
	// Position of PDR07 field.
	PORT1_PDR_PDR07_Pos = 0x7
	// Bit mask of PDR07 field.
	PORT1_PDR_PDR07_Msk = 0x80
	// Bit PDR07.
	PORT1_PDR_PDR07 = 0x80
	// Input (functions as an input pin)
	PORT1_PDR_PDR07_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR07_1 = 0x1
	// Position of PDR08 field.
	PORT1_PDR_PDR08_Pos = 0x8
	// Bit mask of PDR08 field.
	PORT1_PDR_PDR08_Msk = 0x100
	// Bit PDR08.
	PORT1_PDR_PDR08 = 0x100
	// Input (functions as an input pin)
	PORT1_PDR_PDR08_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR08_1 = 0x1
	// Position of PDR09 field.
	PORT1_PDR_PDR09_Pos = 0x9
	// Bit mask of PDR09 field.
	PORT1_PDR_PDR09_Msk = 0x200
	// Bit PDR09.
	PORT1_PDR_PDR09 = 0x200
	// Input (functions as an input pin)
	PORT1_PDR_PDR09_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR09_1 = 0x1
	// Position of PDR10 field.
	PORT1_PDR_PDR10_Pos = 0xa
	// Bit mask of PDR10 field.
	PORT1_PDR_PDR10_Msk = 0x400
	// Bit PDR10.
	PORT1_PDR_PDR10 = 0x400
	// Input (functions as an input pin)
	PORT1_PDR_PDR10_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR10_1 = 0x1
	// Position of PDR11 field.
	PORT1_PDR_PDR11_Pos = 0xb
	// Bit mask of PDR11 field.
	PORT1_PDR_PDR11_Msk = 0x800
	// Bit PDR11.
	PORT1_PDR_PDR11 = 0x800
	// Input (functions as an input pin)
	PORT1_PDR_PDR11_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR11_1 = 0x1
	// Position of PDR12 field.
	PORT1_PDR_PDR12_Pos = 0xc
	// Bit mask of PDR12 field.
	PORT1_PDR_PDR12_Msk = 0x1000
	// Bit PDR12.
	PORT1_PDR_PDR12 = 0x1000
	// Input (functions as an input pin)
	PORT1_PDR_PDR12_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR12_1 = 0x1
	// Position of PDR13 field.
	PORT1_PDR_PDR13_Pos = 0xd
	// Bit mask of PDR13 field.
	PORT1_PDR_PDR13_Msk = 0x2000
	// Bit PDR13.
	PORT1_PDR_PDR13 = 0x2000
	// Input (functions as an input pin)
	PORT1_PDR_PDR13_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR13_1 = 0x1
	// Position of PDR14 field.
	PORT1_PDR_PDR14_Pos = 0xe
	// Bit mask of PDR14 field.
	PORT1_PDR_PDR14_Msk = 0x4000
	// Bit PDR14.
	PORT1_PDR_PDR14 = 0x4000
	// Input (functions as an input pin)
	PORT1_PDR_PDR14_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR14_1 = 0x1
	// Position of PDR15 field.
	PORT1_PDR_PDR15_Pos = 0xf
	// Bit mask of PDR15 field.
	PORT1_PDR_PDR15_Msk = 0x8000
	// Bit PDR15.
	PORT1_PDR_PDR15 = 0x8000
	// Input (functions as an input pin)
	PORT1_PDR_PDR15_0 = 0x0
	// Output (functions as an output pin)
	PORT1_PDR_PDR15_1 = 0x1

	// PCNTR2: Port Control Register 2
	// Position of PIDR00 field.
	PORT1_PCNTR2_PIDR00_Pos = 0x0
	// Bit mask of PIDR00 field.
	PORT1_PCNTR2_PIDR00_Msk = 0x1
	// Bit PIDR00.
	PORT1_PCNTR2_PIDR00 = 0x1
	// Low level
	PORT1_PCNTR2_PIDR00_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR00_1 = 0x1
	// Position of PIDR01 field.
	PORT1_PCNTR2_PIDR01_Pos = 0x1
	// Bit mask of PIDR01 field.
	PORT1_PCNTR2_PIDR01_Msk = 0x2
	// Bit PIDR01.
	PORT1_PCNTR2_PIDR01 = 0x2
	// Low level
	PORT1_PCNTR2_PIDR01_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR01_1 = 0x1
	// Position of PIDR02 field.
	PORT1_PCNTR2_PIDR02_Pos = 0x2
	// Bit mask of PIDR02 field.
	PORT1_PCNTR2_PIDR02_Msk = 0x4
	// Bit PIDR02.
	PORT1_PCNTR2_PIDR02 = 0x4
	// Low level
	PORT1_PCNTR2_PIDR02_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR02_1 = 0x1
	// Position of PIDR03 field.
	PORT1_PCNTR2_PIDR03_Pos = 0x3
	// Bit mask of PIDR03 field.
	PORT1_PCNTR2_PIDR03_Msk = 0x8
	// Bit PIDR03.
	PORT1_PCNTR2_PIDR03 = 0x8
	// Low level
	PORT1_PCNTR2_PIDR03_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR03_1 = 0x1
	// Position of PIDR04 field.
	PORT1_PCNTR2_PIDR04_Pos = 0x4
	// Bit mask of PIDR04 field.
	PORT1_PCNTR2_PIDR04_Msk = 0x10
	// Bit PIDR04.
	PORT1_PCNTR2_PIDR04 = 0x10
	// Low level
	PORT1_PCNTR2_PIDR04_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR04_1 = 0x1
	// Position of PIDR05 field.
	PORT1_PCNTR2_PIDR05_Pos = 0x5
	// Bit mask of PIDR05 field.
	PORT1_PCNTR2_PIDR05_Msk = 0x20
	// Bit PIDR05.
	PORT1_PCNTR2_PIDR05 = 0x20
	// Low level
	PORT1_PCNTR2_PIDR05_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR05_1 = 0x1
	// Position of PIDR06 field.
	PORT1_PCNTR2_PIDR06_Pos = 0x6
	// Bit mask of PIDR06 field.
	PORT1_PCNTR2_PIDR06_Msk = 0x40
	// Bit PIDR06.
	PORT1_PCNTR2_PIDR06 = 0x40
	// Low level
	PORT1_PCNTR2_PIDR06_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR06_1 = 0x1
	// Position of PIDR07 field.
	PORT1_PCNTR2_PIDR07_Pos = 0x7
	// Bit mask of PIDR07 field.
	PORT1_PCNTR2_PIDR07_Msk = 0x80
	// Bit PIDR07.
	PORT1_PCNTR2_PIDR07 = 0x80
	// Low level
	PORT1_PCNTR2_PIDR07_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR07_1 = 0x1
	// Position of PIDR08 field.
	PORT1_PCNTR2_PIDR08_Pos = 0x8
	// Bit mask of PIDR08 field.
	PORT1_PCNTR2_PIDR08_Msk = 0x100
	// Bit PIDR08.
	PORT1_PCNTR2_PIDR08 = 0x100
	// Low level
	PORT1_PCNTR2_PIDR08_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR08_1 = 0x1
	// Position of PIDR09 field.
	PORT1_PCNTR2_PIDR09_Pos = 0x9
	// Bit mask of PIDR09 field.
	PORT1_PCNTR2_PIDR09_Msk = 0x200
	// Bit PIDR09.
	PORT1_PCNTR2_PIDR09 = 0x200
	// Low level
	PORT1_PCNTR2_PIDR09_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR09_1 = 0x1
	// Position of PIDR10 field.
	PORT1_PCNTR2_PIDR10_Pos = 0xa
	// Bit mask of PIDR10 field.
	PORT1_PCNTR2_PIDR10_Msk = 0x400
	// Bit PIDR10.
	PORT1_PCNTR2_PIDR10 = 0x400
	// Low level
	PORT1_PCNTR2_PIDR10_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR10_1 = 0x1
	// Position of PIDR11 field.
	PORT1_PCNTR2_PIDR11_Pos = 0xb
	// Bit mask of PIDR11 field.
	PORT1_PCNTR2_PIDR11_Msk = 0x800
	// Bit PIDR11.
	PORT1_PCNTR2_PIDR11 = 0x800
	// Low level
	PORT1_PCNTR2_PIDR11_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR11_1 = 0x1
	// Position of PIDR12 field.
	PORT1_PCNTR2_PIDR12_Pos = 0xc
	// Bit mask of PIDR12 field.
	PORT1_PCNTR2_PIDR12_Msk = 0x1000
	// Bit PIDR12.
	PORT1_PCNTR2_PIDR12 = 0x1000
	// Low level
	PORT1_PCNTR2_PIDR12_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR12_1 = 0x1
	// Position of PIDR13 field.
	PORT1_PCNTR2_PIDR13_Pos = 0xd
	// Bit mask of PIDR13 field.
	PORT1_PCNTR2_PIDR13_Msk = 0x2000
	// Bit PIDR13.
	PORT1_PCNTR2_PIDR13 = 0x2000
	// Low level
	PORT1_PCNTR2_PIDR13_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR13_1 = 0x1
	// Position of PIDR14 field.
	PORT1_PCNTR2_PIDR14_Pos = 0xe
	// Bit mask of PIDR14 field.
	PORT1_PCNTR2_PIDR14_Msk = 0x4000
	// Bit PIDR14.
	PORT1_PCNTR2_PIDR14 = 0x4000
	// Low level
	PORT1_PCNTR2_PIDR14_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR14_1 = 0x1
	// Position of PIDR15 field.
	PORT1_PCNTR2_PIDR15_Pos = 0xf
	// Bit mask of PIDR15 field.
	PORT1_PCNTR2_PIDR15_Msk = 0x8000
	// Bit PIDR15.
	PORT1_PCNTR2_PIDR15 = 0x8000
	// Low level
	PORT1_PCNTR2_PIDR15_0 = 0x0
	// High level
	PORT1_PCNTR2_PIDR15_1 = 0x1
	// Position of EIDR00 field.
	PORT1_PCNTR2_EIDR00_Pos = 0x10
	// Bit mask of EIDR00 field.
	PORT1_PCNTR2_EIDR00_Msk = 0x10000
	// Bit EIDR00.
	PORT1_PCNTR2_EIDR00 = 0x10000
	// Low input
	PORT1_PCNTR2_EIDR00_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR00_1 = 0x1
	// Position of EIDR01 field.
	PORT1_PCNTR2_EIDR01_Pos = 0x11
	// Bit mask of EIDR01 field.
	PORT1_PCNTR2_EIDR01_Msk = 0x20000
	// Bit EIDR01.
	PORT1_PCNTR2_EIDR01 = 0x20000
	// Low input
	PORT1_PCNTR2_EIDR01_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR01_1 = 0x1
	// Position of EIDR02 field.
	PORT1_PCNTR2_EIDR02_Pos = 0x12
	// Bit mask of EIDR02 field.
	PORT1_PCNTR2_EIDR02_Msk = 0x40000
	// Bit EIDR02.
	PORT1_PCNTR2_EIDR02 = 0x40000
	// Low input
	PORT1_PCNTR2_EIDR02_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR02_1 = 0x1
	// Position of EIDR03 field.
	PORT1_PCNTR2_EIDR03_Pos = 0x13
	// Bit mask of EIDR03 field.
	PORT1_PCNTR2_EIDR03_Msk = 0x80000
	// Bit EIDR03.
	PORT1_PCNTR2_EIDR03 = 0x80000
	// Low input
	PORT1_PCNTR2_EIDR03_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR03_1 = 0x1
	// Position of EIDR04 field.
	PORT1_PCNTR2_EIDR04_Pos = 0x14
	// Bit mask of EIDR04 field.
	PORT1_PCNTR2_EIDR04_Msk = 0x100000
	// Bit EIDR04.
	PORT1_PCNTR2_EIDR04 = 0x100000
	// Low input
	PORT1_PCNTR2_EIDR04_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR04_1 = 0x1
	// Position of EIDR05 field.
	PORT1_PCNTR2_EIDR05_Pos = 0x15
	// Bit mask of EIDR05 field.
	PORT1_PCNTR2_EIDR05_Msk = 0x200000
	// Bit EIDR05.
	PORT1_PCNTR2_EIDR05 = 0x200000
	// Low input
	PORT1_PCNTR2_EIDR05_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR05_1 = 0x1
	// Position of EIDR06 field.
	PORT1_PCNTR2_EIDR06_Pos = 0x16
	// Bit mask of EIDR06 field.
	PORT1_PCNTR2_EIDR06_Msk = 0x400000
	// Bit EIDR06.
	PORT1_PCNTR2_EIDR06 = 0x400000
	// Low input
	PORT1_PCNTR2_EIDR06_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR06_1 = 0x1
	// Position of EIDR07 field.
	PORT1_PCNTR2_EIDR07_Pos = 0x17
	// Bit mask of EIDR07 field.
	PORT1_PCNTR2_EIDR07_Msk = 0x800000
	// Bit EIDR07.
	PORT1_PCNTR2_EIDR07 = 0x800000
	// Low input
	PORT1_PCNTR2_EIDR07_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR07_1 = 0x1
	// Position of EIDR08 field.
	PORT1_PCNTR2_EIDR08_Pos = 0x18
	// Bit mask of EIDR08 field.
	PORT1_PCNTR2_EIDR08_Msk = 0x1000000
	// Bit EIDR08.
	PORT1_PCNTR2_EIDR08 = 0x1000000
	// Low input
	PORT1_PCNTR2_EIDR08_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR08_1 = 0x1
	// Position of EIDR09 field.
	PORT1_PCNTR2_EIDR09_Pos = 0x19
	// Bit mask of EIDR09 field.
	PORT1_PCNTR2_EIDR09_Msk = 0x2000000
	// Bit EIDR09.
	PORT1_PCNTR2_EIDR09 = 0x2000000
	// Low input
	PORT1_PCNTR2_EIDR09_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR09_1 = 0x1
	// Position of EIDR10 field.
	PORT1_PCNTR2_EIDR10_Pos = 0x1a
	// Bit mask of EIDR10 field.
	PORT1_PCNTR2_EIDR10_Msk = 0x4000000
	// Bit EIDR10.
	PORT1_PCNTR2_EIDR10 = 0x4000000
	// Low input
	PORT1_PCNTR2_EIDR10_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR10_1 = 0x1
	// Position of EIDR11 field.
	PORT1_PCNTR2_EIDR11_Pos = 0x1b
	// Bit mask of EIDR11 field.
	PORT1_PCNTR2_EIDR11_Msk = 0x8000000
	// Bit EIDR11.
	PORT1_PCNTR2_EIDR11 = 0x8000000
	// Low input
	PORT1_PCNTR2_EIDR11_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR11_1 = 0x1
	// Position of EIDR12 field.
	PORT1_PCNTR2_EIDR12_Pos = 0x1c
	// Bit mask of EIDR12 field.
	PORT1_PCNTR2_EIDR12_Msk = 0x10000000
	// Bit EIDR12.
	PORT1_PCNTR2_EIDR12 = 0x10000000
	// Low input
	PORT1_PCNTR2_EIDR12_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR12_1 = 0x1
	// Position of EIDR13 field.
	PORT1_PCNTR2_EIDR13_Pos = 0x1d
	// Bit mask of EIDR13 field.
	PORT1_PCNTR2_EIDR13_Msk = 0x20000000
	// Bit EIDR13.
	PORT1_PCNTR2_EIDR13 = 0x20000000
	// Low input
	PORT1_PCNTR2_EIDR13_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR13_1 = 0x1
	// Position of EIDR14 field.
	PORT1_PCNTR2_EIDR14_Pos = 0x1e
	// Bit mask of EIDR14 field.
	PORT1_PCNTR2_EIDR14_Msk = 0x40000000
	// Bit EIDR14.
	PORT1_PCNTR2_EIDR14 = 0x40000000
	// Low input
	PORT1_PCNTR2_EIDR14_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR14_1 = 0x1
	// Position of EIDR15 field.
	PORT1_PCNTR2_EIDR15_Pos = 0x1f
	// Bit mask of EIDR15 field.
	PORT1_PCNTR2_EIDR15_Msk = 0x80000000
	// Bit EIDR15.
	PORT1_PCNTR2_EIDR15 = 0x80000000
	// Low input
	PORT1_PCNTR2_EIDR15_0 = 0x0
	// High input
	PORT1_PCNTR2_EIDR15_1 = 0x1

	// EIDR: Port Control Register 2
	// Position of EIDR00 field.
	PORT1_EIDR_EIDR00_Pos = 0x0
	// Bit mask of EIDR00 field.
	PORT1_EIDR_EIDR00_Msk = 0x1
	// Bit EIDR00.
	PORT1_EIDR_EIDR00 = 0x1
	// Low input
	PORT1_EIDR_EIDR00_0 = 0x0
	// High input
	PORT1_EIDR_EIDR00_1 = 0x1
	// Position of EIDR01 field.
	PORT1_EIDR_EIDR01_Pos = 0x1
	// Bit mask of EIDR01 field.
	PORT1_EIDR_EIDR01_Msk = 0x2
	// Bit EIDR01.
	PORT1_EIDR_EIDR01 = 0x2
	// Low input
	PORT1_EIDR_EIDR01_0 = 0x0
	// High input
	PORT1_EIDR_EIDR01_1 = 0x1
	// Position of EIDR02 field.
	PORT1_EIDR_EIDR02_Pos = 0x2
	// Bit mask of EIDR02 field.
	PORT1_EIDR_EIDR02_Msk = 0x4
	// Bit EIDR02.
	PORT1_EIDR_EIDR02 = 0x4
	// Low input
	PORT1_EIDR_EIDR02_0 = 0x0
	// High input
	PORT1_EIDR_EIDR02_1 = 0x1
	// Position of EIDR03 field.
	PORT1_EIDR_EIDR03_Pos = 0x3
	// Bit mask of EIDR03 field.
	PORT1_EIDR_EIDR03_Msk = 0x8
	// Bit EIDR03.
	PORT1_EIDR_EIDR03 = 0x8
	// Low input
	PORT1_EIDR_EIDR03_0 = 0x0
	// High input
	PORT1_EIDR_EIDR03_1 = 0x1
	// Position of EIDR04 field.
	PORT1_EIDR_EIDR04_Pos = 0x4
	// Bit mask of EIDR04 field.
	PORT1_EIDR_EIDR04_Msk = 0x10
	// Bit EIDR04.
	PORT1_EIDR_EIDR04 = 0x10
	// Low input
	PORT1_EIDR_EIDR04_0 = 0x0
	// High input
	PORT1_EIDR_EIDR04_1 = 0x1
	// Position of EIDR05 field.
	PORT1_EIDR_EIDR05_Pos = 0x5
	// Bit mask of EIDR05 field.
	PORT1_EIDR_EIDR05_Msk = 0x20
	// Bit EIDR05.
	PORT1_EIDR_EIDR05 = 0x20
	// Low input
	PORT1_EIDR_EIDR05_0 = 0x0
	// High input
	PORT1_EIDR_EIDR05_1 = 0x1
	// Position of EIDR06 field.
	PORT1_EIDR_EIDR06_Pos = 0x6
	// Bit mask of EIDR06 field.
	PORT1_EIDR_EIDR06_Msk = 0x40
	// Bit EIDR06.
	PORT1_EIDR_EIDR06 = 0x40
	// Low input
	PORT1_EIDR_EIDR06_0 = 0x0
	// High input
	PORT1_EIDR_EIDR06_1 = 0x1
	// Position of EIDR07 field.
	PORT1_EIDR_EIDR07_Pos = 0x7
	// Bit mask of EIDR07 field.
	PORT1_EIDR_EIDR07_Msk = 0x80
	// Bit EIDR07.
	PORT1_EIDR_EIDR07 = 0x80
	// Low input
	PORT1_EIDR_EIDR07_0 = 0x0
	// High input
	PORT1_EIDR_EIDR07_1 = 0x1
	// Position of EIDR08 field.
	PORT1_EIDR_EIDR08_Pos = 0x8
	// Bit mask of EIDR08 field.
	PORT1_EIDR_EIDR08_Msk = 0x100
	// Bit EIDR08.
	PORT1_EIDR_EIDR08 = 0x100
	// Low input
	PORT1_EIDR_EIDR08_0 = 0x0
	// High input
	PORT1_EIDR_EIDR08_1 = 0x1
	// Position of EIDR09 field.
	PORT1_EIDR_EIDR09_Pos = 0x9
	// Bit mask of EIDR09 field.
	PORT1_EIDR_EIDR09_Msk = 0x200
	// Bit EIDR09.
	PORT1_EIDR_EIDR09 = 0x200
	// Low input
	PORT1_EIDR_EIDR09_0 = 0x0
	// High input
	PORT1_EIDR_EIDR09_1 = 0x1
	// Position of EIDR10 field.
	PORT1_EIDR_EIDR10_Pos = 0xa
	// Bit mask of EIDR10 field.
	PORT1_EIDR_EIDR10_Msk = 0x400
	// Bit EIDR10.
	PORT1_EIDR_EIDR10 = 0x400
	// Low input
	PORT1_EIDR_EIDR10_0 = 0x0
	// High input
	PORT1_EIDR_EIDR10_1 = 0x1
	// Position of EIDR11 field.
	PORT1_EIDR_EIDR11_Pos = 0xb
	// Bit mask of EIDR11 field.
	PORT1_EIDR_EIDR11_Msk = 0x800
	// Bit EIDR11.
	PORT1_EIDR_EIDR11 = 0x800
	// Low input
	PORT1_EIDR_EIDR11_0 = 0x0
	// High input
	PORT1_EIDR_EIDR11_1 = 0x1
	// Position of EIDR12 field.
	PORT1_EIDR_EIDR12_Pos = 0xc
	// Bit mask of EIDR12 field.
	PORT1_EIDR_EIDR12_Msk = 0x1000
	// Bit EIDR12.
	PORT1_EIDR_EIDR12 = 0x1000
	// Low input
	PORT1_EIDR_EIDR12_0 = 0x0
	// High input
	PORT1_EIDR_EIDR12_1 = 0x1
	// Position of EIDR13 field.
	PORT1_EIDR_EIDR13_Pos = 0xd
	// Bit mask of EIDR13 field.
	PORT1_EIDR_EIDR13_Msk = 0x2000
	// Bit EIDR13.
	PORT1_EIDR_EIDR13 = 0x2000
	// Low input
	PORT1_EIDR_EIDR13_0 = 0x0
	// High input
	PORT1_EIDR_EIDR13_1 = 0x1
	// Position of EIDR14 field.
	PORT1_EIDR_EIDR14_Pos = 0xe
	// Bit mask of EIDR14 field.
	PORT1_EIDR_EIDR14_Msk = 0x4000
	// Bit EIDR14.
	PORT1_EIDR_EIDR14 = 0x4000
	// Low input
	PORT1_EIDR_EIDR14_0 = 0x0
	// High input
	PORT1_EIDR_EIDR14_1 = 0x1
	// Position of EIDR15 field.
	PORT1_EIDR_EIDR15_Pos = 0xf
	// Bit mask of EIDR15 field.
	PORT1_EIDR_EIDR15_Msk = 0x8000
	// Bit EIDR15.
	PORT1_EIDR_EIDR15 = 0x8000
	// Low input
	PORT1_EIDR_EIDR15_0 = 0x0
	// High input
	PORT1_EIDR_EIDR15_1 = 0x1

	// PIDR: Port Control Register 2
	// Position of PIDR00 field.
	PORT1_PIDR_PIDR00_Pos = 0x0
	// Bit mask of PIDR00 field.
	PORT1_PIDR_PIDR00_Msk = 0x1
	// Bit PIDR00.
	PORT1_PIDR_PIDR00 = 0x1
	// Low level
	PORT1_PIDR_PIDR00_0 = 0x0
	// High level
	PORT1_PIDR_PIDR00_1 = 0x1
	// Position of PIDR01 field.
	PORT1_PIDR_PIDR01_Pos = 0x1
	// Bit mask of PIDR01 field.
	PORT1_PIDR_PIDR01_Msk = 0x2
	// Bit PIDR01.
	PORT1_PIDR_PIDR01 = 0x2
	// Low level
	PORT1_PIDR_PIDR01_0 = 0x0
	// High level
	PORT1_PIDR_PIDR01_1 = 0x1
	// Position of PIDR02 field.
	PORT1_PIDR_PIDR02_Pos = 0x2
	// Bit mask of PIDR02 field.
	PORT1_PIDR_PIDR02_Msk = 0x4
	// Bit PIDR02.
	PORT1_PIDR_PIDR02 = 0x4
	// Low level
	PORT1_PIDR_PIDR02_0 = 0x0
	// High level
	PORT1_PIDR_PIDR02_1 = 0x1
	// Position of PIDR03 field.
	PORT1_PIDR_PIDR03_Pos = 0x3
	// Bit mask of PIDR03 field.
	PORT1_PIDR_PIDR03_Msk = 0x8
	// Bit PIDR03.
	PORT1_PIDR_PIDR03 = 0x8
	// Low level
	PORT1_PIDR_PIDR03_0 = 0x0
	// High level
	PORT1_PIDR_PIDR03_1 = 0x1
	// Position of PIDR04 field.
	PORT1_PIDR_PIDR04_Pos = 0x4
	// Bit mask of PIDR04 field.
	PORT1_PIDR_PIDR04_Msk = 0x10
	// Bit PIDR04.
	PORT1_PIDR_PIDR04 = 0x10
	// Low level
	PORT1_PIDR_PIDR04_0 = 0x0
	// High level
	PORT1_PIDR_PIDR04_1 = 0x1
	// Position of PIDR05 field.
	PORT1_PIDR_PIDR05_Pos = 0x5
	// Bit mask of PIDR05 field.
	PORT1_PIDR_PIDR05_Msk = 0x20
	// Bit PIDR05.
	PORT1_PIDR_PIDR05 = 0x20
	// Low level
	PORT1_PIDR_PIDR05_0 = 0x0
	// High level
	PORT1_PIDR_PIDR05_1 = 0x1
	// Position of PIDR06 field.
	PORT1_PIDR_PIDR06_Pos = 0x6
	// Bit mask of PIDR06 field.
	PORT1_PIDR_PIDR06_Msk = 0x40
	// Bit PIDR06.
	PORT1_PIDR_PIDR06 = 0x40
	// Low level
	PORT1_PIDR_PIDR06_0 = 0x0
	// High level
	PORT1_PIDR_PIDR06_1 = 0x1
	// Position of PIDR07 field.
	PORT1_PIDR_PIDR07_Pos = 0x7
	// Bit mask of PIDR07 field.
	PORT1_PIDR_PIDR07_Msk = 0x80
	// Bit PIDR07.
	PORT1_PIDR_PIDR07 = 0x80
	// Low level
	PORT1_PIDR_PIDR07_0 = 0x0
	// High level
	PORT1_PIDR_PIDR07_1 = 0x1
	// Position of PIDR08 field.
	PORT1_PIDR_PIDR08_Pos = 0x8
	// Bit mask of PIDR08 field.
	PORT1_PIDR_PIDR08_Msk = 0x100
	// Bit PIDR08.
	PORT1_PIDR_PIDR08 = 0x100
	// Low level
	PORT1_PIDR_PIDR08_0 = 0x0
	// High level
	PORT1_PIDR_PIDR08_1 = 0x1
	// Position of PIDR09 field.
	PORT1_PIDR_PIDR09_Pos = 0x9
	// Bit mask of PIDR09 field.
	PORT1_PIDR_PIDR09_Msk = 0x200
	// Bit PIDR09.
	PORT1_PIDR_PIDR09 = 0x200
	// Low level
	PORT1_PIDR_PIDR09_0 = 0x0
	// High level
	PORT1_PIDR_PIDR09_1 = 0x1
	// Position of PIDR10 field.
	PORT1_PIDR_PIDR10_Pos = 0xa
	// Bit mask of PIDR10 field.
	PORT1_PIDR_PIDR10_Msk = 0x400
	// Bit PIDR10.
	PORT1_PIDR_PIDR10 = 0x400
	// Low level
	PORT1_PIDR_PIDR10_0 = 0x0
	// High level
	PORT1_PIDR_PIDR10_1 = 0x1
	// Position of PIDR11 field.
	PORT1_PIDR_PIDR11_Pos = 0xb
	// Bit mask of PIDR11 field.
	PORT1_PIDR_PIDR11_Msk = 0x800
	// Bit PIDR11.
	PORT1_PIDR_PIDR11 = 0x800
	// Low level
	PORT1_PIDR_PIDR11_0 = 0x0
	// High level
	PORT1_PIDR_PIDR11_1 = 0x1
	// Position of PIDR12 field.
	PORT1_PIDR_PIDR12_Pos = 0xc
	// Bit mask of PIDR12 field.
	PORT1_PIDR_PIDR12_Msk = 0x1000
	// Bit PIDR12.
	PORT1_PIDR_PIDR12 = 0x1000
	// Low level
	PORT1_PIDR_PIDR12_0 = 0x0
	// High level
	PORT1_PIDR_PIDR12_1 = 0x1
	// Position of PIDR13 field.
	PORT1_PIDR_PIDR13_Pos = 0xd
	// Bit mask of PIDR13 field.
	PORT1_PIDR_PIDR13_Msk = 0x2000
	// Bit PIDR13.
	PORT1_PIDR_PIDR13 = 0x2000
	// Low level
	PORT1_PIDR_PIDR13_0 = 0x0
	// High level
	PORT1_PIDR_PIDR13_1 = 0x1
	// Position of PIDR14 field.
	PORT1_PIDR_PIDR14_Pos = 0xe
	// Bit mask of PIDR14 field.
	PORT1_PIDR_PIDR14_Msk = 0x4000
	// Bit PIDR14.
	PORT1_PIDR_PIDR14 = 0x4000
	// Low level
	PORT1_PIDR_PIDR14_0 = 0x0
	// High level
	PORT1_PIDR_PIDR14_1 = 0x1
	// Position of PIDR15 field.
	PORT1_PIDR_PIDR15_Pos = 0xf
	// Bit mask of PIDR15 field.
	PORT1_PIDR_PIDR15_Msk = 0x8000
	// Bit PIDR15.
	PORT1_PIDR_PIDR15 = 0x8000
	// Low level
	PORT1_PIDR_PIDR15_0 = 0x0
	// High level
	PORT1_PIDR_PIDR15_1 = 0x1

	// PCNTR3: Port Control Register 3
	// Position of POSR00 field.
	PORT1_PCNTR3_POSR00_Pos = 0x0
	// Bit mask of POSR00 field.
	PORT1_PCNTR3_POSR00_Msk = 0x1
	// Bit POSR00.
	PORT1_PCNTR3_POSR00 = 0x1
	// No effect on output
	PORT1_PCNTR3_POSR00_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR00_1 = 0x1
	// Position of POSR01 field.
	PORT1_PCNTR3_POSR01_Pos = 0x1
	// Bit mask of POSR01 field.
	PORT1_PCNTR3_POSR01_Msk = 0x2
	// Bit POSR01.
	PORT1_PCNTR3_POSR01 = 0x2
	// No effect on output
	PORT1_PCNTR3_POSR01_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR01_1 = 0x1
	// Position of POSR02 field.
	PORT1_PCNTR3_POSR02_Pos = 0x2
	// Bit mask of POSR02 field.
	PORT1_PCNTR3_POSR02_Msk = 0x4
	// Bit POSR02.
	PORT1_PCNTR3_POSR02 = 0x4
	// No effect on output
	PORT1_PCNTR3_POSR02_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR02_1 = 0x1
	// Position of POSR03 field.
	PORT1_PCNTR3_POSR03_Pos = 0x3
	// Bit mask of POSR03 field.
	PORT1_PCNTR3_POSR03_Msk = 0x8
	// Bit POSR03.
	PORT1_PCNTR3_POSR03 = 0x8
	// No effect on output
	PORT1_PCNTR3_POSR03_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR03_1 = 0x1
	// Position of POSR04 field.
	PORT1_PCNTR3_POSR04_Pos = 0x4
	// Bit mask of POSR04 field.
	PORT1_PCNTR3_POSR04_Msk = 0x10
	// Bit POSR04.
	PORT1_PCNTR3_POSR04 = 0x10
	// No effect on output
	PORT1_PCNTR3_POSR04_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR04_1 = 0x1
	// Position of POSR05 field.
	PORT1_PCNTR3_POSR05_Pos = 0x5
	// Bit mask of POSR05 field.
	PORT1_PCNTR3_POSR05_Msk = 0x20
	// Bit POSR05.
	PORT1_PCNTR3_POSR05 = 0x20
	// No effect on output
	PORT1_PCNTR3_POSR05_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR05_1 = 0x1
	// Position of POSR06 field.
	PORT1_PCNTR3_POSR06_Pos = 0x6
	// Bit mask of POSR06 field.
	PORT1_PCNTR3_POSR06_Msk = 0x40
	// Bit POSR06.
	PORT1_PCNTR3_POSR06 = 0x40
	// No effect on output
	PORT1_PCNTR3_POSR06_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR06_1 = 0x1
	// Position of POSR07 field.
	PORT1_PCNTR3_POSR07_Pos = 0x7
	// Bit mask of POSR07 field.
	PORT1_PCNTR3_POSR07_Msk = 0x80
	// Bit POSR07.
	PORT1_PCNTR3_POSR07 = 0x80
	// No effect on output
	PORT1_PCNTR3_POSR07_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR07_1 = 0x1
	// Position of POSR08 field.
	PORT1_PCNTR3_POSR08_Pos = 0x8
	// Bit mask of POSR08 field.
	PORT1_PCNTR3_POSR08_Msk = 0x100
	// Bit POSR08.
	PORT1_PCNTR3_POSR08 = 0x100
	// No effect on output
	PORT1_PCNTR3_POSR08_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR08_1 = 0x1
	// Position of POSR09 field.
	PORT1_PCNTR3_POSR09_Pos = 0x9
	// Bit mask of POSR09 field.
	PORT1_PCNTR3_POSR09_Msk = 0x200
	// Bit POSR09.
	PORT1_PCNTR3_POSR09 = 0x200
	// No effect on output
	PORT1_PCNTR3_POSR09_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR09_1 = 0x1
	// Position of POSR10 field.
	PORT1_PCNTR3_POSR10_Pos = 0xa
	// Bit mask of POSR10 field.
	PORT1_PCNTR3_POSR10_Msk = 0x400
	// Bit POSR10.
	PORT1_PCNTR3_POSR10 = 0x400
	// No effect on output
	PORT1_PCNTR3_POSR10_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR10_1 = 0x1
	// Position of POSR11 field.
	PORT1_PCNTR3_POSR11_Pos = 0xb
	// Bit mask of POSR11 field.
	PORT1_PCNTR3_POSR11_Msk = 0x800
	// Bit POSR11.
	PORT1_PCNTR3_POSR11 = 0x800
	// No effect on output
	PORT1_PCNTR3_POSR11_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR11_1 = 0x1
	// Position of POSR12 field.
	PORT1_PCNTR3_POSR12_Pos = 0xc
	// Bit mask of POSR12 field.
	PORT1_PCNTR3_POSR12_Msk = 0x1000
	// Bit POSR12.
	PORT1_PCNTR3_POSR12 = 0x1000
	// No effect on output
	PORT1_PCNTR3_POSR12_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR12_1 = 0x1
	// Position of POSR13 field.
	PORT1_PCNTR3_POSR13_Pos = 0xd
	// Bit mask of POSR13 field.
	PORT1_PCNTR3_POSR13_Msk = 0x2000
	// Bit POSR13.
	PORT1_PCNTR3_POSR13 = 0x2000
	// No effect on output
	PORT1_PCNTR3_POSR13_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR13_1 = 0x1
	// Position of POSR14 field.
	PORT1_PCNTR3_POSR14_Pos = 0xe
	// Bit mask of POSR14 field.
	PORT1_PCNTR3_POSR14_Msk = 0x4000
	// Bit POSR14.
	PORT1_PCNTR3_POSR14 = 0x4000
	// No effect on output
	PORT1_PCNTR3_POSR14_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR14_1 = 0x1
	// Position of POSR15 field.
	PORT1_PCNTR3_POSR15_Pos = 0xf
	// Bit mask of POSR15 field.
	PORT1_PCNTR3_POSR15_Msk = 0x8000
	// Bit POSR15.
	PORT1_PCNTR3_POSR15 = 0x8000
	// No effect on output
	PORT1_PCNTR3_POSR15_0 = 0x0
	// High output
	PORT1_PCNTR3_POSR15_1 = 0x1
	// Position of PORR00 field.
	PORT1_PCNTR3_PORR00_Pos = 0x10
	// Bit mask of PORR00 field.
	PORT1_PCNTR3_PORR00_Msk = 0x10000
	// Bit PORR00.
	PORT1_PCNTR3_PORR00 = 0x10000
	// No effect on output
	PORT1_PCNTR3_PORR00_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR00_1 = 0x1
	// Position of PORR01 field.
	PORT1_PCNTR3_PORR01_Pos = 0x11
	// Bit mask of PORR01 field.
	PORT1_PCNTR3_PORR01_Msk = 0x20000
	// Bit PORR01.
	PORT1_PCNTR3_PORR01 = 0x20000
	// No effect on output
	PORT1_PCNTR3_PORR01_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR01_1 = 0x1
	// Position of PORR02 field.
	PORT1_PCNTR3_PORR02_Pos = 0x12
	// Bit mask of PORR02 field.
	PORT1_PCNTR3_PORR02_Msk = 0x40000
	// Bit PORR02.
	PORT1_PCNTR3_PORR02 = 0x40000
	// No effect on output
	PORT1_PCNTR3_PORR02_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR02_1 = 0x1
	// Position of PORR03 field.
	PORT1_PCNTR3_PORR03_Pos = 0x13
	// Bit mask of PORR03 field.
	PORT1_PCNTR3_PORR03_Msk = 0x80000
	// Bit PORR03.
	PORT1_PCNTR3_PORR03 = 0x80000
	// No effect on output
	PORT1_PCNTR3_PORR03_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR03_1 = 0x1
	// Position of PORR04 field.
	PORT1_PCNTR3_PORR04_Pos = 0x14
	// Bit mask of PORR04 field.
	PORT1_PCNTR3_PORR04_Msk = 0x100000
	// Bit PORR04.
	PORT1_PCNTR3_PORR04 = 0x100000
	// No effect on output
	PORT1_PCNTR3_PORR04_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR04_1 = 0x1
	// Position of PORR05 field.
	PORT1_PCNTR3_PORR05_Pos = 0x15
	// Bit mask of PORR05 field.
	PORT1_PCNTR3_PORR05_Msk = 0x200000
	// Bit PORR05.
	PORT1_PCNTR3_PORR05 = 0x200000
	// No effect on output
	PORT1_PCNTR3_PORR05_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR05_1 = 0x1
	// Position of PORR06 field.
	PORT1_PCNTR3_PORR06_Pos = 0x16
	// Bit mask of PORR06 field.
	PORT1_PCNTR3_PORR06_Msk = 0x400000
	// Bit PORR06.
	PORT1_PCNTR3_PORR06 = 0x400000
	// No effect on output
	PORT1_PCNTR3_PORR06_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR06_1 = 0x1
	// Position of PORR07 field.
	PORT1_PCNTR3_PORR07_Pos = 0x17
	// Bit mask of PORR07 field.
	PORT1_PCNTR3_PORR07_Msk = 0x800000
	// Bit PORR07.
	PORT1_PCNTR3_PORR07 = 0x800000
	// No effect on output
	PORT1_PCNTR3_PORR07_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR07_1 = 0x1
	// Position of PORR08 field.
	PORT1_PCNTR3_PORR08_Pos = 0x18
	// Bit mask of PORR08 field.
	PORT1_PCNTR3_PORR08_Msk = 0x1000000
	// Bit PORR08.
	PORT1_PCNTR3_PORR08 = 0x1000000
	// No effect on output
	PORT1_PCNTR3_PORR08_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR08_1 = 0x1
	// Position of PORR09 field.
	PORT1_PCNTR3_PORR09_Pos = 0x19
	// Bit mask of PORR09 field.
	PORT1_PCNTR3_PORR09_Msk = 0x2000000
	// Bit PORR09.
	PORT1_PCNTR3_PORR09 = 0x2000000
	// No effect on output
	PORT1_PCNTR3_PORR09_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR09_1 = 0x1
	// Position of PORR10 field.
	PORT1_PCNTR3_PORR10_Pos = 0x1a
	// Bit mask of PORR10 field.
	PORT1_PCNTR3_PORR10_Msk = 0x4000000
	// Bit PORR10.
	PORT1_PCNTR3_PORR10 = 0x4000000
	// No effect on output
	PORT1_PCNTR3_PORR10_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR10_1 = 0x1
	// Position of PORR11 field.
	PORT1_PCNTR3_PORR11_Pos = 0x1b
	// Bit mask of PORR11 field.
	PORT1_PCNTR3_PORR11_Msk = 0x8000000
	// Bit PORR11.
	PORT1_PCNTR3_PORR11 = 0x8000000
	// No effect on output
	PORT1_PCNTR3_PORR11_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR11_1 = 0x1
	// Position of PORR12 field.
	PORT1_PCNTR3_PORR12_Pos = 0x1c
	// Bit mask of PORR12 field.
	PORT1_PCNTR3_PORR12_Msk = 0x10000000
	// Bit PORR12.
	PORT1_PCNTR3_PORR12 = 0x10000000
	// No effect on output
	PORT1_PCNTR3_PORR12_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR12_1 = 0x1
	// Position of PORR13 field.
	PORT1_PCNTR3_PORR13_Pos = 0x1d
	// Bit mask of PORR13 field.
	PORT1_PCNTR3_PORR13_Msk = 0x20000000
	// Bit PORR13.
	PORT1_PCNTR3_PORR13 = 0x20000000
	// No effect on output
	PORT1_PCNTR3_PORR13_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR13_1 = 0x1
	// Position of PORR14 field.
	PORT1_PCNTR3_PORR14_Pos = 0x1e
	// Bit mask of PORR14 field.
	PORT1_PCNTR3_PORR14_Msk = 0x40000000
	// Bit PORR14.
	PORT1_PCNTR3_PORR14 = 0x40000000
	// No effect on output
	PORT1_PCNTR3_PORR14_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR14_1 = 0x1
	// Position of PORR15 field.
	PORT1_PCNTR3_PORR15_Pos = 0x1f
	// Bit mask of PORR15 field.
	PORT1_PCNTR3_PORR15_Msk = 0x80000000
	// Bit PORR15.
	PORT1_PCNTR3_PORR15 = 0x80000000
	// No effect on output
	PORT1_PCNTR3_PORR15_0 = 0x0
	// Low output
	PORT1_PCNTR3_PORR15_1 = 0x1

	// PORR: Port Control Register 3
	// Position of PORR00 field.
	PORT1_PORR_PORR00_Pos = 0x0
	// Bit mask of PORR00 field.
	PORT1_PORR_PORR00_Msk = 0x1
	// Bit PORR00.
	PORT1_PORR_PORR00 = 0x1
	// No effect on output
	PORT1_PORR_PORR00_0 = 0x0
	// Low output
	PORT1_PORR_PORR00_1 = 0x1
	// Position of PORR01 field.
	PORT1_PORR_PORR01_Pos = 0x1
	// Bit mask of PORR01 field.
	PORT1_PORR_PORR01_Msk = 0x2
	// Bit PORR01.
	PORT1_PORR_PORR01 = 0x2
	// No effect on output
	PORT1_PORR_PORR01_0 = 0x0
	// Low output
	PORT1_PORR_PORR01_1 = 0x1
	// Position of PORR02 field.
	PORT1_PORR_PORR02_Pos = 0x2
	// Bit mask of PORR02 field.
	PORT1_PORR_PORR02_Msk = 0x4
	// Bit PORR02.
	PORT1_PORR_PORR02 = 0x4
	// No effect on output
	PORT1_PORR_PORR02_0 = 0x0
	// Low output
	PORT1_PORR_PORR02_1 = 0x1
	// Position of PORR03 field.
	PORT1_PORR_PORR03_Pos = 0x3
	// Bit mask of PORR03 field.
	PORT1_PORR_PORR03_Msk = 0x8
	// Bit PORR03.
	PORT1_PORR_PORR03 = 0x8
	// No effect on output
	PORT1_PORR_PORR03_0 = 0x0
	// Low output
	PORT1_PORR_PORR03_1 = 0x1
	// Position of PORR04 field.
	PORT1_PORR_PORR04_Pos = 0x4
	// Bit mask of PORR04 field.
	PORT1_PORR_PORR04_Msk = 0x10
	// Bit PORR04.
	PORT1_PORR_PORR04 = 0x10
	// No effect on output
	PORT1_PORR_PORR04_0 = 0x0
	// Low output
	PORT1_PORR_PORR04_1 = 0x1
	// Position of PORR05 field.
	PORT1_PORR_PORR05_Pos = 0x5
	// Bit mask of PORR05 field.
	PORT1_PORR_PORR05_Msk = 0x20
	// Bit PORR05.
	PORT1_PORR_PORR05 = 0x20
	// No effect on output
	PORT1_PORR_PORR05_0 = 0x0
	// Low output
	PORT1_PORR_PORR05_1 = 0x1
	// Position of PORR06 field.
	PORT1_PORR_PORR06_Pos = 0x6
	// Bit mask of PORR06 field.
	PORT1_PORR_PORR06_Msk = 0x40
	// Bit PORR06.
	PORT1_PORR_PORR06 = 0x40
	// No effect on output
	PORT1_PORR_PORR06_0 = 0x0
	// Low output
	PORT1_PORR_PORR06_1 = 0x1
	// Position of PORR07 field.
	PORT1_PORR_PORR07_Pos = 0x7
	// Bit mask of PORR07 field.
	PORT1_PORR_PORR07_Msk = 0x80
	// Bit PORR07.
	PORT1_PORR_PORR07 = 0x80
	// No effect on output
	PORT1_PORR_PORR07_0 = 0x0
	// Low output
	PORT1_PORR_PORR07_1 = 0x1
	// Position of PORR08 field.
	PORT1_PORR_PORR08_Pos = 0x8
	// Bit mask of PORR08 field.
	PORT1_PORR_PORR08_Msk = 0x100
	// Bit PORR08.
	PORT1_PORR_PORR08 = 0x100
	// No effect on output
	PORT1_PORR_PORR08_0 = 0x0
	// Low output
	PORT1_PORR_PORR08_1 = 0x1
	// Position of PORR09 field.
	PORT1_PORR_PORR09_Pos = 0x9
	// Bit mask of PORR09 field.
	PORT1_PORR_PORR09_Msk = 0x200
	// Bit PORR09.
	PORT1_PORR_PORR09 = 0x200
	// No effect on output
	PORT1_PORR_PORR09_0 = 0x0
	// Low output
	PORT1_PORR_PORR09_1 = 0x1
	// Position of PORR10 field.
	PORT1_PORR_PORR10_Pos = 0xa
	// Bit mask of PORR10 field.
	PORT1_PORR_PORR10_Msk = 0x400
	// Bit PORR10.
	PORT1_PORR_PORR10 = 0x400
	// No effect on output
	PORT1_PORR_PORR10_0 = 0x0
	// Low output
	PORT1_PORR_PORR10_1 = 0x1
	// Position of PORR11 field.
	PORT1_PORR_PORR11_Pos = 0xb
	// Bit mask of PORR11 field.
	PORT1_PORR_PORR11_Msk = 0x800
	// Bit PORR11.
	PORT1_PORR_PORR11 = 0x800
	// No effect on output
	PORT1_PORR_PORR11_0 = 0x0
	// Low output
	PORT1_PORR_PORR11_1 = 0x1
	// Position of PORR12 field.
	PORT1_PORR_PORR12_Pos = 0xc
	// Bit mask of PORR12 field.
	PORT1_PORR_PORR12_Msk = 0x1000
	// Bit PORR12.
	PORT1_PORR_PORR12 = 0x1000
	// No effect on output
	PORT1_PORR_PORR12_0 = 0x0
	// Low output
	PORT1_PORR_PORR12_1 = 0x1
	// Position of PORR13 field.
	PORT1_PORR_PORR13_Pos = 0xd
	// Bit mask of PORR13 field.
	PORT1_PORR_PORR13_Msk = 0x2000
	// Bit PORR13.
	PORT1_PORR_PORR13 = 0x2000
	// No effect on output
	PORT1_PORR_PORR13_0 = 0x0
	// Low output
	PORT1_PORR_PORR13_1 = 0x1
	// Position of PORR14 field.
	PORT1_PORR_PORR14_Pos = 0xe
	// Bit mask of PORR14 field.
	PORT1_PORR_PORR14_Msk = 0x4000
	// Bit PORR14.
	PORT1_PORR_PORR14 = 0x4000
	// No effect on output
	PORT1_PORR_PORR14_0 = 0x0
	// Low output
	PORT1_PORR_PORR14_1 = 0x1
	// Position of PORR15 field.
	PORT1_PORR_PORR15_Pos = 0xf
	// Bit mask of PORR15 field.
	PORT1_PORR_PORR15_Msk = 0x8000
	// Bit PORR15.
	PORT1_PORR_PORR15 = 0x8000
	// No effect on output
	PORT1_PORR_PORR15_0 = 0x0
	// Low output
	PORT1_PORR_PORR15_1 = 0x1

	// POSR: Port Control Register 3
	// Position of POSR00 field.
	PORT1_POSR_POSR00_Pos = 0x0
	// Bit mask of POSR00 field.
	PORT1_POSR_POSR00_Msk = 0x1
	// Bit POSR00.
	PORT1_POSR_POSR00 = 0x1
	// No effect on output
	PORT1_POSR_POSR00_0 = 0x0
	// High output
	PORT1_POSR_POSR00_1 = 0x1
	// Position of POSR01 field.
	PORT1_POSR_POSR01_Pos = 0x1
	// Bit mask of POSR01 field.
	PORT1_POSR_POSR01_Msk = 0x2
	// Bit POSR01.
	PORT1_POSR_POSR01 = 0x2
	// No effect on output
	PORT1_POSR_POSR01_0 = 0x0
	// High output
	PORT1_POSR_POSR01_1 = 0x1
	// Position of POSR02 field.
	PORT1_POSR_POSR02_Pos = 0x2
	// Bit mask of POSR02 field.
	PORT1_POSR_POSR02_Msk = 0x4
	// Bit POSR02.
	PORT1_POSR_POSR02 = 0x4
	// No effect on output
	PORT1_POSR_POSR02_0 = 0x0
	// High output
	PORT1_POSR_POSR02_1 = 0x1
	// Position of POSR03 field.
	PORT1_POSR_POSR03_Pos = 0x3
	// Bit mask of POSR03 field.
	PORT1_POSR_POSR03_Msk = 0x8
	// Bit POSR03.
	PORT1_POSR_POSR03 = 0x8
	// No effect on output
	PORT1_POSR_POSR03_0 = 0x0
	// High output
	PORT1_POSR_POSR03_1 = 0x1
	// Position of POSR04 field.
	PORT1_POSR_POSR04_Pos = 0x4
	// Bit mask of POSR04 field.
	PORT1_POSR_POSR04_Msk = 0x10
	// Bit POSR04.
	PORT1_POSR_POSR04 = 0x10
	// No effect on output
	PORT1_POSR_POSR04_0 = 0x0
	// High output
	PORT1_POSR_POSR04_1 = 0x1
	// Position of POSR05 field.
	PORT1_POSR_POSR05_Pos = 0x5
	// Bit mask of POSR05 field.
	PORT1_POSR_POSR05_Msk = 0x20
	// Bit POSR05.
	PORT1_POSR_POSR05 = 0x20
	// No effect on output
	PORT1_POSR_POSR05_0 = 0x0
	// High output
	PORT1_POSR_POSR05_1 = 0x1
	// Position of POSR06 field.
	PORT1_POSR_POSR06_Pos = 0x6
	// Bit mask of POSR06 field.
	PORT1_POSR_POSR06_Msk = 0x40
	// Bit POSR06.
	PORT1_POSR_POSR06 = 0x40
	// No effect on output
	PORT1_POSR_POSR06_0 = 0x0
	// High output
	PORT1_POSR_POSR06_1 = 0x1
	// Position of POSR07 field.
	PORT1_POSR_POSR07_Pos = 0x7
	// Bit mask of POSR07 field.
	PORT1_POSR_POSR07_Msk = 0x80
	// Bit POSR07.
	PORT1_POSR_POSR07 = 0x80
	// No effect on output
	PORT1_POSR_POSR07_0 = 0x0
	// High output
	PORT1_POSR_POSR07_1 = 0x1
	// Position of POSR08 field.
	PORT1_POSR_POSR08_Pos = 0x8
	// Bit mask of POSR08 field.
	PORT1_POSR_POSR08_Msk = 0x100
	// Bit POSR08.
	PORT1_POSR_POSR08 = 0x100
	// No effect on output
	PORT1_POSR_POSR08_0 = 0x0
	// High output
	PORT1_POSR_POSR08_1 = 0x1
	// Position of POSR09 field.
	PORT1_POSR_POSR09_Pos = 0x9
	// Bit mask of POSR09 field.
	PORT1_POSR_POSR09_Msk = 0x200
	// Bit POSR09.
	PORT1_POSR_POSR09 = 0x200
	// No effect on output
	PORT1_POSR_POSR09_0 = 0x0
	// High output
	PORT1_POSR_POSR09_1 = 0x1
	// Position of POSR10 field.
	PORT1_POSR_POSR10_Pos = 0xa
	// Bit mask of POSR10 field.
	PORT1_POSR_POSR10_Msk = 0x400
	// Bit POSR10.
	PORT1_POSR_POSR10 = 0x400
	// No effect on output
	PORT1_POSR_POSR10_0 = 0x0
	// High output
	PORT1_POSR_POSR10_1 = 0x1
	// Position of POSR11 field.
	PORT1_POSR_POSR11_Pos = 0xb
	// Bit mask of POSR11 field.
	PORT1_POSR_POSR11_Msk = 0x800
	// Bit POSR11.
	PORT1_POSR_POSR11 = 0x800
	// No effect on output
	PORT1_POSR_POSR11_0 = 0x0
	// High output
	PORT1_POSR_POSR11_1 = 0x1
	// Position of POSR12 field.
	PORT1_POSR_POSR12_Pos = 0xc
	// Bit mask of POSR12 field.
	PORT1_POSR_POSR12_Msk = 0x1000
	// Bit POSR12.
	PORT1_POSR_POSR12 = 0x1000
	// No effect on output
	PORT1_POSR_POSR12_0 = 0x0
	// High output
	PORT1_POSR_POSR12_1 = 0x1
	// Position of POSR13 field.
	PORT1_POSR_POSR13_Pos = 0xd
	// Bit mask of POSR13 field.
	PORT1_POSR_POSR13_Msk = 0x2000
	// Bit POSR13.
	PORT1_POSR_POSR13 = 0x2000
	// No effect on output
	PORT1_POSR_POSR13_0 = 0x0
	// High output
	PORT1_POSR_POSR13_1 = 0x1
	// Position of POSR14 field.
	PORT1_POSR_POSR14_Pos = 0xe
	// Bit mask of POSR14 field.
	PORT1_POSR_POSR14_Msk = 0x4000
	// Bit POSR14.
	PORT1_POSR_POSR14 = 0x4000
	// No effect on output
	PORT1_POSR_POSR14_0 = 0x0
	// High output
	PORT1_POSR_POSR14_1 = 0x1
	// Position of POSR15 field.
	PORT1_POSR_POSR15_Pos = 0xf
	// Bit mask of POSR15 field.
	PORT1_POSR_POSR15_Msk = 0x8000
	// Bit POSR15.
	PORT1_POSR_POSR15 = 0x8000
	// No effect on output
	PORT1_POSR_POSR15_0 = 0x0
	// High output
	PORT1_POSR_POSR15_1 = 0x1

	// PCNTR4: Port Control Register 4
	// Position of EOSR00 field.
	PORT1_PCNTR4_EOSR00_Pos = 0x0
	// Bit mask of EOSR00 field.
	PORT1_PCNTR4_EOSR00_Msk = 0x1
	// Bit EOSR00.
	PORT1_PCNTR4_EOSR00 = 0x1
	// No effect on output
	PORT1_PCNTR4_EOSR00_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR00_1 = 0x1
	// Position of EOSR01 field.
	PORT1_PCNTR4_EOSR01_Pos = 0x1
	// Bit mask of EOSR01 field.
	PORT1_PCNTR4_EOSR01_Msk = 0x2
	// Bit EOSR01.
	PORT1_PCNTR4_EOSR01 = 0x2
	// No effect on output
	PORT1_PCNTR4_EOSR01_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR01_1 = 0x1
	// Position of EOSR02 field.
	PORT1_PCNTR4_EOSR02_Pos = 0x2
	// Bit mask of EOSR02 field.
	PORT1_PCNTR4_EOSR02_Msk = 0x4
	// Bit EOSR02.
	PORT1_PCNTR4_EOSR02 = 0x4
	// No effect on output
	PORT1_PCNTR4_EOSR02_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR02_1 = 0x1
	// Position of EOSR03 field.
	PORT1_PCNTR4_EOSR03_Pos = 0x3
	// Bit mask of EOSR03 field.
	PORT1_PCNTR4_EOSR03_Msk = 0x8
	// Bit EOSR03.
	PORT1_PCNTR4_EOSR03 = 0x8
	// No effect on output
	PORT1_PCNTR4_EOSR03_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR03_1 = 0x1
	// Position of EOSR04 field.
	PORT1_PCNTR4_EOSR04_Pos = 0x4
	// Bit mask of EOSR04 field.
	PORT1_PCNTR4_EOSR04_Msk = 0x10
	// Bit EOSR04.
	PORT1_PCNTR4_EOSR04 = 0x10
	// No effect on output
	PORT1_PCNTR4_EOSR04_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR04_1 = 0x1
	// Position of EOSR05 field.
	PORT1_PCNTR4_EOSR05_Pos = 0x5
	// Bit mask of EOSR05 field.
	PORT1_PCNTR4_EOSR05_Msk = 0x20
	// Bit EOSR05.
	PORT1_PCNTR4_EOSR05 = 0x20
	// No effect on output
	PORT1_PCNTR4_EOSR05_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR05_1 = 0x1
	// Position of EOSR06 field.
	PORT1_PCNTR4_EOSR06_Pos = 0x6
	// Bit mask of EOSR06 field.
	PORT1_PCNTR4_EOSR06_Msk = 0x40
	// Bit EOSR06.
	PORT1_PCNTR4_EOSR06 = 0x40
	// No effect on output
	PORT1_PCNTR4_EOSR06_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR06_1 = 0x1
	// Position of EOSR07 field.
	PORT1_PCNTR4_EOSR07_Pos = 0x7
	// Bit mask of EOSR07 field.
	PORT1_PCNTR4_EOSR07_Msk = 0x80
	// Bit EOSR07.
	PORT1_PCNTR4_EOSR07 = 0x80
	// No effect on output
	PORT1_PCNTR4_EOSR07_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR07_1 = 0x1
	// Position of EOSR08 field.
	PORT1_PCNTR4_EOSR08_Pos = 0x8
	// Bit mask of EOSR08 field.
	PORT1_PCNTR4_EOSR08_Msk = 0x100
	// Bit EOSR08.
	PORT1_PCNTR4_EOSR08 = 0x100
	// No effect on output
	PORT1_PCNTR4_EOSR08_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR08_1 = 0x1
	// Position of EOSR09 field.
	PORT1_PCNTR4_EOSR09_Pos = 0x9
	// Bit mask of EOSR09 field.
	PORT1_PCNTR4_EOSR09_Msk = 0x200
	// Bit EOSR09.
	PORT1_PCNTR4_EOSR09 = 0x200
	// No effect on output
	PORT1_PCNTR4_EOSR09_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR09_1 = 0x1
	// Position of EOSR10 field.
	PORT1_PCNTR4_EOSR10_Pos = 0xa
	// Bit mask of EOSR10 field.
	PORT1_PCNTR4_EOSR10_Msk = 0x400
	// Bit EOSR10.
	PORT1_PCNTR4_EOSR10 = 0x400
	// No effect on output
	PORT1_PCNTR4_EOSR10_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR10_1 = 0x1
	// Position of EOSR11 field.
	PORT1_PCNTR4_EOSR11_Pos = 0xb
	// Bit mask of EOSR11 field.
	PORT1_PCNTR4_EOSR11_Msk = 0x800
	// Bit EOSR11.
	PORT1_PCNTR4_EOSR11 = 0x800
	// No effect on output
	PORT1_PCNTR4_EOSR11_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR11_1 = 0x1
	// Position of EOSR12 field.
	PORT1_PCNTR4_EOSR12_Pos = 0xc
	// Bit mask of EOSR12 field.
	PORT1_PCNTR4_EOSR12_Msk = 0x1000
	// Bit EOSR12.
	PORT1_PCNTR4_EOSR12 = 0x1000
	// No effect on output
	PORT1_PCNTR4_EOSR12_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR12_1 = 0x1
	// Position of EOSR13 field.
	PORT1_PCNTR4_EOSR13_Pos = 0xd
	// Bit mask of EOSR13 field.
	PORT1_PCNTR4_EOSR13_Msk = 0x2000
	// Bit EOSR13.
	PORT1_PCNTR4_EOSR13 = 0x2000
	// No effect on output
	PORT1_PCNTR4_EOSR13_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR13_1 = 0x1
	// Position of EOSR14 field.
	PORT1_PCNTR4_EOSR14_Pos = 0xe
	// Bit mask of EOSR14 field.
	PORT1_PCNTR4_EOSR14_Msk = 0x4000
	// Bit EOSR14.
	PORT1_PCNTR4_EOSR14 = 0x4000
	// No effect on output
	PORT1_PCNTR4_EOSR14_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR14_1 = 0x1
	// Position of EOSR15 field.
	PORT1_PCNTR4_EOSR15_Pos = 0xf
	// Bit mask of EOSR15 field.
	PORT1_PCNTR4_EOSR15_Msk = 0x8000
	// Bit EOSR15.
	PORT1_PCNTR4_EOSR15 = 0x8000
	// No effect on output
	PORT1_PCNTR4_EOSR15_0 = 0x0
	// High output
	PORT1_PCNTR4_EOSR15_1 = 0x1
	// Position of EORR00 field.
	PORT1_PCNTR4_EORR00_Pos = 0x10
	// Bit mask of EORR00 field.
	PORT1_PCNTR4_EORR00_Msk = 0x10000
	// Bit EORR00.
	PORT1_PCNTR4_EORR00 = 0x10000
	// No effect on output
	PORT1_PCNTR4_EORR00_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR00_1 = 0x1
	// Position of EORR01 field.
	PORT1_PCNTR4_EORR01_Pos = 0x11
	// Bit mask of EORR01 field.
	PORT1_PCNTR4_EORR01_Msk = 0x20000
	// Bit EORR01.
	PORT1_PCNTR4_EORR01 = 0x20000
	// No effect on output
	PORT1_PCNTR4_EORR01_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR01_1 = 0x1
	// Position of EORR02 field.
	PORT1_PCNTR4_EORR02_Pos = 0x12
	// Bit mask of EORR02 field.
	PORT1_PCNTR4_EORR02_Msk = 0x40000
	// Bit EORR02.
	PORT1_PCNTR4_EORR02 = 0x40000
	// No effect on output
	PORT1_PCNTR4_EORR02_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR02_1 = 0x1
	// Position of EORR03 field.
	PORT1_PCNTR4_EORR03_Pos = 0x13
	// Bit mask of EORR03 field.
	PORT1_PCNTR4_EORR03_Msk = 0x80000
	// Bit EORR03.
	PORT1_PCNTR4_EORR03 = 0x80000
	// No effect on output
	PORT1_PCNTR4_EORR03_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR03_1 = 0x1
	// Position of EORR04 field.
	PORT1_PCNTR4_EORR04_Pos = 0x14
	// Bit mask of EORR04 field.
	PORT1_PCNTR4_EORR04_Msk = 0x100000
	// Bit EORR04.
	PORT1_PCNTR4_EORR04 = 0x100000
	// No effect on output
	PORT1_PCNTR4_EORR04_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR04_1 = 0x1
	// Position of EORR05 field.
	PORT1_PCNTR4_EORR05_Pos = 0x15
	// Bit mask of EORR05 field.
	PORT1_PCNTR4_EORR05_Msk = 0x200000
	// Bit EORR05.
	PORT1_PCNTR4_EORR05 = 0x200000
	// No effect on output
	PORT1_PCNTR4_EORR05_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR05_1 = 0x1
	// Position of EORR06 field.
	PORT1_PCNTR4_EORR06_Pos = 0x16
	// Bit mask of EORR06 field.
	PORT1_PCNTR4_EORR06_Msk = 0x400000
	// Bit EORR06.
	PORT1_PCNTR4_EORR06 = 0x400000
	// No effect on output
	PORT1_PCNTR4_EORR06_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR06_1 = 0x1
	// Position of EORR07 field.
	PORT1_PCNTR4_EORR07_Pos = 0x17
	// Bit mask of EORR07 field.
	PORT1_PCNTR4_EORR07_Msk = 0x800000
	// Bit EORR07.
	PORT1_PCNTR4_EORR07 = 0x800000
	// No effect on output
	PORT1_PCNTR4_EORR07_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR07_1 = 0x1
	// Position of EORR08 field.
	PORT1_PCNTR4_EORR08_Pos = 0x18
	// Bit mask of EORR08 field.
	PORT1_PCNTR4_EORR08_Msk = 0x1000000
	// Bit EORR08.
	PORT1_PCNTR4_EORR08 = 0x1000000
	// No effect on output
	PORT1_PCNTR4_EORR08_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR08_1 = 0x1
	// Position of EORR09 field.
	PORT1_PCNTR4_EORR09_Pos = 0x19
	// Bit mask of EORR09 field.
	PORT1_PCNTR4_EORR09_Msk = 0x2000000
	// Bit EORR09.
	PORT1_PCNTR4_EORR09 = 0x2000000
	// No effect on output
	PORT1_PCNTR4_EORR09_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR09_1 = 0x1
	// Position of EORR10 field.
	PORT1_PCNTR4_EORR10_Pos = 0x1a
	// Bit mask of EORR10 field.
	PORT1_PCNTR4_EORR10_Msk = 0x4000000
	// Bit EORR10.
	PORT1_PCNTR4_EORR10 = 0x4000000
	// No effect on output
	PORT1_PCNTR4_EORR10_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR10_1 = 0x1
	// Position of EORR11 field.
	PORT1_PCNTR4_EORR11_Pos = 0x1b
	// Bit mask of EORR11 field.
	PORT1_PCNTR4_EORR11_Msk = 0x8000000
	// Bit EORR11.
	PORT1_PCNTR4_EORR11 = 0x8000000
	// No effect on output
	PORT1_PCNTR4_EORR11_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR11_1 = 0x1
	// Position of EORR12 field.
	PORT1_PCNTR4_EORR12_Pos = 0x1c
	// Bit mask of EORR12 field.
	PORT1_PCNTR4_EORR12_Msk = 0x10000000
	// Bit EORR12.
	PORT1_PCNTR4_EORR12 = 0x10000000
	// No effect on output
	PORT1_PCNTR4_EORR12_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR12_1 = 0x1
	// Position of EORR13 field.
	PORT1_PCNTR4_EORR13_Pos = 0x1d
	// Bit mask of EORR13 field.
	PORT1_PCNTR4_EORR13_Msk = 0x20000000
	// Bit EORR13.
	PORT1_PCNTR4_EORR13 = 0x20000000
	// No effect on output
	PORT1_PCNTR4_EORR13_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR13_1 = 0x1
	// Position of EORR14 field.
	PORT1_PCNTR4_EORR14_Pos = 0x1e
	// Bit mask of EORR14 field.
	PORT1_PCNTR4_EORR14_Msk = 0x40000000
	// Bit EORR14.
	PORT1_PCNTR4_EORR14 = 0x40000000
	// No effect on output
	PORT1_PCNTR4_EORR14_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR14_1 = 0x1
	// Position of EORR15 field.
	PORT1_PCNTR4_EORR15_Pos = 0x1f
	// Bit mask of EORR15 field.
	PORT1_PCNTR4_EORR15_Msk = 0x80000000
	// Bit EORR15.
	PORT1_PCNTR4_EORR15 = 0x80000000
	// No effect on output
	PORT1_PCNTR4_EORR15_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR15_1 = 0x1

	// EORR: Port Control Register 4
	// Position of EORR00 field.
	PORT1_EORR_EORR00_Pos = 0x0
	// Bit mask of EORR00 field.
	PORT1_EORR_EORR00_Msk = 0x1
	// Bit EORR00.
	PORT1_EORR_EORR00 = 0x1
	// No effect on output
	PORT1_EORR_EORR00_0 = 0x0
	// Low output
	PORT1_EORR_EORR00_1 = 0x1
	// Position of EORR01 field.
	PORT1_EORR_EORR01_Pos = 0x1
	// Bit mask of EORR01 field.
	PORT1_EORR_EORR01_Msk = 0x2
	// Bit EORR01.
	PORT1_EORR_EORR01 = 0x2
	// No effect on output
	PORT1_EORR_EORR01_0 = 0x0
	// Low output
	PORT1_EORR_EORR01_1 = 0x1
	// Position of EORR02 field.
	PORT1_EORR_EORR02_Pos = 0x2
	// Bit mask of EORR02 field.
	PORT1_EORR_EORR02_Msk = 0x4
	// Bit EORR02.
	PORT1_EORR_EORR02 = 0x4
	// No effect on output
	PORT1_EORR_EORR02_0 = 0x0
	// Low output
	PORT1_EORR_EORR02_1 = 0x1
	// Position of EORR03 field.
	PORT1_EORR_EORR03_Pos = 0x3
	// Bit mask of EORR03 field.
	PORT1_EORR_EORR03_Msk = 0x8
	// Bit EORR03.
	PORT1_EORR_EORR03 = 0x8
	// No effect on output
	PORT1_EORR_EORR03_0 = 0x0
	// Low output
	PORT1_EORR_EORR03_1 = 0x1
	// Position of EORR04 field.
	PORT1_EORR_EORR04_Pos = 0x4
	// Bit mask of EORR04 field.
	PORT1_EORR_EORR04_Msk = 0x10
	// Bit EORR04.
	PORT1_EORR_EORR04 = 0x10
	// No effect on output
	PORT1_EORR_EORR04_0 = 0x0
	// Low output
	PORT1_EORR_EORR04_1 = 0x1
	// Position of EORR05 field.
	PORT1_EORR_EORR05_Pos = 0x5
	// Bit mask of EORR05 field.
	PORT1_EORR_EORR05_Msk = 0x20
	// Bit EORR05.
	PORT1_EORR_EORR05 = 0x20
	// No effect on output
	PORT1_EORR_EORR05_0 = 0x0
	// Low output
	PORT1_EORR_EORR05_1 = 0x1
	// Position of EORR06 field.
	PORT1_EORR_EORR06_Pos = 0x6
	// Bit mask of EORR06 field.
	PORT1_EORR_EORR06_Msk = 0x40
	// Bit EORR06.
	PORT1_EORR_EORR06 = 0x40
	// No effect on output
	PORT1_EORR_EORR06_0 = 0x0
	// Low output
	PORT1_EORR_EORR06_1 = 0x1
	// Position of EORR07 field.
	PORT1_EORR_EORR07_Pos = 0x7
	// Bit mask of EORR07 field.
	PORT1_EORR_EORR07_Msk = 0x80
	// Bit EORR07.
	PORT1_EORR_EORR07 = 0x80
	// No effect on output
	PORT1_EORR_EORR07_0 = 0x0
	// Low output
	PORT1_EORR_EORR07_1 = 0x1
	// Position of EORR08 field.
	PORT1_EORR_EORR08_Pos = 0x8
	// Bit mask of EORR08 field.
	PORT1_EORR_EORR08_Msk = 0x100
	// Bit EORR08.
	PORT1_EORR_EORR08 = 0x100
	// No effect on output
	PORT1_EORR_EORR08_0 = 0x0
	// Low output
	PORT1_EORR_EORR08_1 = 0x1
	// Position of EORR09 field.
	PORT1_EORR_EORR09_Pos = 0x9
	// Bit mask of EORR09 field.
	PORT1_EORR_EORR09_Msk = 0x200
	// Bit EORR09.
	PORT1_EORR_EORR09 = 0x200
	// No effect on output
	PORT1_EORR_EORR09_0 = 0x0
	// Low output
	PORT1_EORR_EORR09_1 = 0x1
	// Position of EORR10 field.
	PORT1_EORR_EORR10_Pos = 0xa
	// Bit mask of EORR10 field.
	PORT1_EORR_EORR10_Msk = 0x400
	// Bit EORR10.
	PORT1_EORR_EORR10 = 0x400
	// No effect on output
	PORT1_EORR_EORR10_0 = 0x0
	// Low output
	PORT1_EORR_EORR10_1 = 0x1
	// Position of EORR11 field.
	PORT1_EORR_EORR11_Pos = 0xb
	// Bit mask of EORR11 field.
	PORT1_EORR_EORR11_Msk = 0x800
	// Bit EORR11.
	PORT1_EORR_EORR11 = 0x800
	// No effect on output
	PORT1_EORR_EORR11_0 = 0x0
	// Low output
	PORT1_EORR_EORR11_1 = 0x1
	// Position of EORR12 field.
	PORT1_EORR_EORR12_Pos = 0xc
	// Bit mask of EORR12 field.
	PORT1_EORR_EORR12_Msk = 0x1000
	// Bit EORR12.
	PORT1_EORR_EORR12 = 0x1000
	// No effect on output
	PORT1_EORR_EORR12_0 = 0x0
	// Low output
	PORT1_EORR_EORR12_1 = 0x1
	// Position of EORR13 field.
	PORT1_EORR_EORR13_Pos = 0xd
	// Bit mask of EORR13 field.
	PORT1_EORR_EORR13_Msk = 0x2000
	// Bit EORR13.
	PORT1_EORR_EORR13 = 0x2000
	// No effect on output
	PORT1_EORR_EORR13_0 = 0x0
	// Low output
	PORT1_EORR_EORR13_1 = 0x1
	// Position of EORR14 field.
	PORT1_EORR_EORR14_Pos = 0xe
	// Bit mask of EORR14 field.
	PORT1_EORR_EORR14_Msk = 0x4000
	// Bit EORR14.
	PORT1_EORR_EORR14 = 0x4000
	// No effect on output
	PORT1_EORR_EORR14_0 = 0x0
	// Low output
	PORT1_EORR_EORR14_1 = 0x1
	// Position of EORR15 field.
	PORT1_EORR_EORR15_Pos = 0xf
	// Bit mask of EORR15 field.
	PORT1_EORR_EORR15_Msk = 0x8000
	// Bit EORR15.
	PORT1_EORR_EORR15 = 0x8000
	// No effect on output
	PORT1_EORR_EORR15_0 = 0x0
	// Low output
	PORT1_EORR_EORR15_1 = 0x1

	// EOSR: Port Control Register 4
	// Position of EOSR00 field.
	PORT1_EOSR_EOSR00_Pos = 0x0
	// Bit mask of EOSR00 field.
	PORT1_EOSR_EOSR00_Msk = 0x1
	// Bit EOSR00.
	PORT1_EOSR_EOSR00 = 0x1
	// No effect on output
	PORT1_EOSR_EOSR00_0 = 0x0
	// High output
	PORT1_EOSR_EOSR00_1 = 0x1
	// Position of EOSR01 field.
	PORT1_EOSR_EOSR01_Pos = 0x1
	// Bit mask of EOSR01 field.
	PORT1_EOSR_EOSR01_Msk = 0x2
	// Bit EOSR01.
	PORT1_EOSR_EOSR01 = 0x2
	// No effect on output
	PORT1_EOSR_EOSR01_0 = 0x0
	// High output
	PORT1_EOSR_EOSR01_1 = 0x1
	// Position of EOSR02 field.
	PORT1_EOSR_EOSR02_Pos = 0x2
	// Bit mask of EOSR02 field.
	PORT1_EOSR_EOSR02_Msk = 0x4
	// Bit EOSR02.
	PORT1_EOSR_EOSR02 = 0x4
	// No effect on output
	PORT1_EOSR_EOSR02_0 = 0x0
	// High output
	PORT1_EOSR_EOSR02_1 = 0x1
	// Position of EOSR03 field.
	PORT1_EOSR_EOSR03_Pos = 0x3
	// Bit mask of EOSR03 field.
	PORT1_EOSR_EOSR03_Msk = 0x8
	// Bit EOSR03.
	PORT1_EOSR_EOSR03 = 0x8
	// No effect on output
	PORT1_EOSR_EOSR03_0 = 0x0
	// High output
	PORT1_EOSR_EOSR03_1 = 0x1
	// Position of EOSR04 field.
	PORT1_EOSR_EOSR04_Pos = 0x4
	// Bit mask of EOSR04 field.
	PORT1_EOSR_EOSR04_Msk = 0x10
	// Bit EOSR04.
	PORT1_EOSR_EOSR04 = 0x10
	// No effect on output
	PORT1_EOSR_EOSR04_0 = 0x0
	// High output
	PORT1_EOSR_EOSR04_1 = 0x1
	// Position of EOSR05 field.
	PORT1_EOSR_EOSR05_Pos = 0x5
	// Bit mask of EOSR05 field.
	PORT1_EOSR_EOSR05_Msk = 0x20
	// Bit EOSR05.
	PORT1_EOSR_EOSR05 = 0x20
	// No effect on output
	PORT1_EOSR_EOSR05_0 = 0x0
	// High output
	PORT1_EOSR_EOSR05_1 = 0x1
	// Position of EOSR06 field.
	PORT1_EOSR_EOSR06_Pos = 0x6
	// Bit mask of EOSR06 field.
	PORT1_EOSR_EOSR06_Msk = 0x40
	// Bit EOSR06.
	PORT1_EOSR_EOSR06 = 0x40
	// No effect on output
	PORT1_EOSR_EOSR06_0 = 0x0
	// High output
	PORT1_EOSR_EOSR06_1 = 0x1
	// Position of EOSR07 field.
	PORT1_EOSR_EOSR07_Pos = 0x7
	// Bit mask of EOSR07 field.
	PORT1_EOSR_EOSR07_Msk = 0x80
	// Bit EOSR07.
	PORT1_EOSR_EOSR07 = 0x80
	// No effect on output
	PORT1_EOSR_EOSR07_0 = 0x0
	// High output
	PORT1_EOSR_EOSR07_1 = 0x1
	// Position of EOSR08 field.
	PORT1_EOSR_EOSR08_Pos = 0x8
	// Bit mask of EOSR08 field.
	PORT1_EOSR_EOSR08_Msk = 0x100
	// Bit EOSR08.
	PORT1_EOSR_EOSR08 = 0x100
	// No effect on output
	PORT1_EOSR_EOSR08_0 = 0x0
	// High output
	PORT1_EOSR_EOSR08_1 = 0x1
	// Position of EOSR09 field.
	PORT1_EOSR_EOSR09_Pos = 0x9
	// Bit mask of EOSR09 field.
	PORT1_EOSR_EOSR09_Msk = 0x200
	// Bit EOSR09.
	PORT1_EOSR_EOSR09 = 0x200
	// No effect on output
	PORT1_EOSR_EOSR09_0 = 0x0
	// High output
	PORT1_EOSR_EOSR09_1 = 0x1
	// Position of EOSR10 field.
	PORT1_EOSR_EOSR10_Pos = 0xa
	// Bit mask of EOSR10 field.
	PORT1_EOSR_EOSR10_Msk = 0x400
	// Bit EOSR10.
	PORT1_EOSR_EOSR10 = 0x400
	// No effect on output
	PORT1_EOSR_EOSR10_0 = 0x0
	// High output
	PORT1_EOSR_EOSR10_1 = 0x1
	// Position of EOSR11 field.
	PORT1_EOSR_EOSR11_Pos = 0xb
	// Bit mask of EOSR11 field.
	PORT1_EOSR_EOSR11_Msk = 0x800
	// Bit EOSR11.
	PORT1_EOSR_EOSR11 = 0x800
	// No effect on output
	PORT1_EOSR_EOSR11_0 = 0x0
	// High output
	PORT1_EOSR_EOSR11_1 = 0x1
	// Position of EOSR12 field.
	PORT1_EOSR_EOSR12_Pos = 0xc
	// Bit mask of EOSR12 field.
	PORT1_EOSR_EOSR12_Msk = 0x1000
	// Bit EOSR12.
	PORT1_EOSR_EOSR12 = 0x1000
	// No effect on output
	PORT1_EOSR_EOSR12_0 = 0x0
	// High output
	PORT1_EOSR_EOSR12_1 = 0x1
	// Position of EOSR13 field.
	PORT1_EOSR_EOSR13_Pos = 0xd
	// Bit mask of EOSR13 field.
	PORT1_EOSR_EOSR13_Msk = 0x2000
	// Bit EOSR13.
	PORT1_EOSR_EOSR13 = 0x2000
	// No effect on output
	PORT1_EOSR_EOSR13_0 = 0x0
	// High output
	PORT1_EOSR_EOSR13_1 = 0x1
	// Position of EOSR14 field.
	PORT1_EOSR_EOSR14_Pos = 0xe
	// Bit mask of EOSR14 field.
	PORT1_EOSR_EOSR14_Msk = 0x4000
	// Bit EOSR14.
	PORT1_EOSR_EOSR14 = 0x4000
	// No effect on output
	PORT1_EOSR_EOSR14_0 = 0x0
	// High output
	PORT1_EOSR_EOSR14_1 = 0x1
	// Position of EOSR15 field.
	PORT1_EOSR_EOSR15_Pos = 0xf
	// Bit mask of EOSR15 field.
	PORT1_EOSR_EOSR15_Msk = 0x8000
	// Bit EOSR15.
	PORT1_EOSR_EOSR15 = 0x8000
	// No effect on output
	PORT1_EOSR_EOSR15_0 = 0x0
	// High output
	PORT1_EOSR_EOSR15_1 = 0x1
)

// Constants for PFS: Control Register
const (
	// P000PFS: Port 00%s Pin Function Select Register
	// Position of PODR field.
	PFS_P00PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P00PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P00PFS_PODR = 0x1
	// Output low
	PFS_P00PFS_PODR_0 = 0x0
	// Output high
	PFS_P00PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P00PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P00PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P00PFS_PIDR = 0x2
	// Low level
	PFS_P00PFS_PIDR_0 = 0x0
	// High level
	PFS_P00PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P00PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P00PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P00PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P00PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P00PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P00PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P00PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P00PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P00PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P00PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P00PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P00PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P00PFS_NCODR = 0x40
	// Output CMOS
	PFS_P00PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P00PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P00PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P00PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P00PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P00PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P00PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P00PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P00PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P00PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P00PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P00PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P00PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P00PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P00PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P00PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P00PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P00PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P00PFS_PSEL_Msk = 0x1f000000

	// P000PFS_HA: Port 00%s Pin Function Select Register
	// Position of PODR field.
	PFS_P00PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P00PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P00PFS_HA_PODR = 0x1
	// Output low
	PFS_P00PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P00PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P00PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P00PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P00PFS_HA_PIDR = 0x2
	// Low level
	PFS_P00PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P00PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P00PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P00PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P00PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P00PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P00PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P00PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P00PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P00PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P00PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P00PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P00PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P00PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P00PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P00PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P00PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P00PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P00PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P00PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P00PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P00PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P00PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P00PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P00PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P00PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P00PFS_HA_ASEL_1 = 0x1

	// P000PFS_BY: Port 00%s Pin Function Select Register
	// Position of PODR field.
	PFS_P00PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P00PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P00PFS_BY_PODR = 0x1
	// Output low
	PFS_P00PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P00PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P00PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P00PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P00PFS_BY_PIDR = 0x2
	// Low level
	PFS_P00PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P00PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P00PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P00PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P00PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P00PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P00PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P00PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P00PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P00PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P00PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P00PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P00PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P00PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P00PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P00PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P00PFS_BY_NCODR_1 = 0x1

	// P008PFS: Port 008 Pin Function Select Register
	// Position of PODR field.
	PFS_P008PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P008PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P008PFS_PODR = 0x1
	// Output low
	PFS_P008PFS_PODR_0 = 0x0
	// Output high
	PFS_P008PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P008PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P008PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P008PFS_PIDR = 0x2
	// Low level
	PFS_P008PFS_PIDR_0 = 0x0
	// High level
	PFS_P008PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P008PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P008PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P008PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P008PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P008PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P008PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P008PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P008PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P008PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P008PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P008PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P008PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P008PFS_NCODR = 0x40
	// Output CMOS
	PFS_P008PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P008PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P008PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P008PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P008PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P008PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P008PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P008PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P008PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P008PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P008PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P008PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P008PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P008PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P008PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P008PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P008PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P008PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P008PFS_PSEL_Msk = 0x1f000000

	// P008PFS_HA: Port 008 Pin Function Select Register
	// Position of PODR field.
	PFS_P008PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P008PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P008PFS_HA_PODR = 0x1
	// Output low
	PFS_P008PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P008PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P008PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P008PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P008PFS_HA_PIDR = 0x2
	// Low level
	PFS_P008PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P008PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P008PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P008PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P008PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P008PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P008PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P008PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P008PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P008PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P008PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P008PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P008PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P008PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P008PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P008PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P008PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P008PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P008PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P008PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P008PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P008PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P008PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P008PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P008PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P008PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P008PFS_HA_ASEL_1 = 0x1

	// P008PFS_BY: Port 008 Pin Function Select Register
	// Position of PODR field.
	PFS_P008PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P008PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P008PFS_BY_PODR = 0x1
	// Output low
	PFS_P008PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P008PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P008PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P008PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P008PFS_BY_PIDR = 0x2
	// Low level
	PFS_P008PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P008PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P008PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P008PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P008PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P008PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P008PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P008PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P008PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P008PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P008PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P008PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P008PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P008PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P008PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P008PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P008PFS_BY_NCODR_1 = 0x1

	// P014PFS: Port 0%s Pin Function Select Register
	// Position of PODR field.
	PFS_P0PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P0PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P0PFS_PODR = 0x1
	// Output low
	PFS_P0PFS_PODR_0 = 0x0
	// Output high
	PFS_P0PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P0PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P0PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P0PFS_PIDR = 0x2
	// Low level
	PFS_P0PFS_PIDR_0 = 0x0
	// High level
	PFS_P0PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P0PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P0PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P0PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P0PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P0PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P0PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P0PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P0PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P0PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P0PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P0PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P0PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P0PFS_NCODR = 0x40
	// Output CMOS
	PFS_P0PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P0PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P0PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P0PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P0PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P0PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P0PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P0PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P0PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P0PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P0PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P0PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P0PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P0PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P0PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P0PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P0PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P0PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P0PFS_PSEL_Msk = 0x1f000000

	// P014PFS_HA: Port 0%s Pin Function Select Register
	// Position of PODR field.
	PFS_P0PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P0PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P0PFS_HA_PODR = 0x1
	// Output low
	PFS_P0PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P0PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P0PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P0PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P0PFS_HA_PIDR = 0x2
	// Low level
	PFS_P0PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P0PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P0PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P0PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P0PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P0PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P0PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P0PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P0PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P0PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P0PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P0PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P0PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P0PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P0PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P0PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P0PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P0PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P0PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P0PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P0PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P0PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P0PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P0PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P0PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P0PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P0PFS_HA_ASEL_1 = 0x1

	// P014PFS_BY: Port 0%s Pin Function Select Register
	// Position of PODR field.
	PFS_P0PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P0PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P0PFS_BY_PODR = 0x1
	// Output low
	PFS_P0PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P0PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P0PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P0PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P0PFS_BY_PIDR = 0x2
	// Low level
	PFS_P0PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P0PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P0PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P0PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P0PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P0PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P0PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P0PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P0PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P0PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P0PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P0PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P0PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P0PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P0PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P0PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P0PFS_BY_NCODR_1 = 0x1

	// P100PFS: Port 10%s Pin Function Select Register
	// Position of PODR field.
	PFS_P10PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P10PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P10PFS_PODR = 0x1
	// Output low
	PFS_P10PFS_PODR_0 = 0x0
	// Output high
	PFS_P10PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P10PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P10PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P10PFS_PIDR = 0x2
	// Low level
	PFS_P10PFS_PIDR_0 = 0x0
	// High level
	PFS_P10PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P10PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P10PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P10PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P10PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P10PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P10PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P10PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P10PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P10PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P10PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P10PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P10PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P10PFS_NCODR = 0x40
	// Output CMOS
	PFS_P10PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P10PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P10PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P10PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P10PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P10PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P10PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P10PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P10PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P10PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P10PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P10PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P10PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P10PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P10PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P10PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P10PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P10PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P10PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P10PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P10PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P10PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P10PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P10PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P10PFS_PSEL_Msk = 0x1f000000

	// P100PFS_HA: Port 10%s Pin Function Select Register
	// Position of PODR field.
	PFS_P10PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P10PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P10PFS_HA_PODR = 0x1
	// Output low
	PFS_P10PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P10PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P10PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P10PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P10PFS_HA_PIDR = 0x2
	// Low level
	PFS_P10PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P10PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P10PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P10PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P10PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P10PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P10PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P10PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P10PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P10PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P10PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P10PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P10PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P10PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P10PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P10PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P10PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P10PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P10PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P10PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P10PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P10PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P10PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P10PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P10PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P10PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P10PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P10PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P10PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P10PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P10PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P10PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P10PFS_HA_ASEL_1 = 0x1

	// P100PFS_BY: Port 10%s Pin Function Select Register
	// Position of PODR field.
	PFS_P10PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P10PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P10PFS_BY_PODR = 0x1
	// Output low
	PFS_P10PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P10PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P10PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P10PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P10PFS_BY_PIDR = 0x2
	// Low level
	PFS_P10PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P10PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P10PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P10PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P10PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P10PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P10PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P10PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P10PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P10PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P10PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P10PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P10PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P10PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P10PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P10PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P10PFS_BY_NCODR_1 = 0x1

	// P110PFS: Port 1%s Pin Function Select Register
	// Position of PODR field.
	PFS_P1PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P1PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P1PFS_PODR = 0x1
	// Output low
	PFS_P1PFS_PODR_0 = 0x0
	// Output high
	PFS_P1PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P1PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P1PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P1PFS_PIDR = 0x2
	// Low level
	PFS_P1PFS_PIDR_0 = 0x0
	// High level
	PFS_P1PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P1PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P1PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P1PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P1PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P1PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P1PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P1PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P1PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P1PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P1PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P1PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P1PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P1PFS_NCODR = 0x40
	// Output CMOS
	PFS_P1PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P1PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P1PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P1PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P1PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P1PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P1PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P1PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P1PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P1PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P1PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P1PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P1PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P1PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P1PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P1PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P1PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P1PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P1PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P1PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P1PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P1PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P1PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P1PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P1PFS_PSEL_Msk = 0x1f000000

	// P110PFS_HA: Port 1%s Pin Function Select Register
	// Position of PODR field.
	PFS_P1PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P1PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P1PFS_HA_PODR = 0x1
	// Output low
	PFS_P1PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P1PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P1PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P1PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P1PFS_HA_PIDR = 0x2
	// Low level
	PFS_P1PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P1PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P1PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P1PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P1PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P1PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P1PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P1PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P1PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P1PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P1PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P1PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P1PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P1PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P1PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P1PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P1PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P1PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P1PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P1PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P1PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P1PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P1PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P1PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P1PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P1PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P1PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P1PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P1PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P1PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P1PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P1PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P1PFS_HA_ASEL_1 = 0x1

	// P110PFS_BY: Port 1%s Pin Function Select Register
	// Position of PODR field.
	PFS_P1PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P1PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P1PFS_BY_PODR = 0x1
	// Output low
	PFS_P1PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P1PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P1PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P1PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P1PFS_BY_PIDR = 0x2
	// Low level
	PFS_P1PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P1PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P1PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P1PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P1PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P1PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P1PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P1PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P1PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P1PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P1PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P1PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P1PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P1PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P1PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P1PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P1PFS_BY_NCODR_1 = 0x1

	// P200PFS: Port 200 Pin Function Select Register
	// Position of PODR field.
	PFS_P200PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P200PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P200PFS_PODR = 0x1
	// Output low
	PFS_P200PFS_PODR_0 = 0x0
	// Output high
	PFS_P200PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P200PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P200PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P200PFS_PIDR = 0x2
	// Low level
	PFS_P200PFS_PIDR_0 = 0x0
	// High level
	PFS_P200PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P200PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P200PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P200PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P200PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P200PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P200PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P200PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P200PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P200PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P200PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P200PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P200PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P200PFS_NCODR = 0x40
	// Output CMOS
	PFS_P200PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P200PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P200PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P200PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P200PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P200PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P200PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P200PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P200PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P200PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P200PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P200PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P200PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P200PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P200PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P200PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P200PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P200PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P200PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P200PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P200PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P200PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P200PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P200PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P200PFS_PSEL_Msk = 0x1f000000

	// P200PFS_HA: Port 200 Pin Function Select Register
	// Position of PODR field.
	PFS_P200PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P200PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P200PFS_HA_PODR = 0x1
	// Output low
	PFS_P200PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P200PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P200PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P200PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P200PFS_HA_PIDR = 0x2
	// Low level
	PFS_P200PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P200PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P200PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P200PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P200PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P200PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P200PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P200PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P200PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P200PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P200PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P200PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P200PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P200PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P200PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P200PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P200PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P200PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P200PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P200PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P200PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P200PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P200PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P200PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P200PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P200PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P200PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P200PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P200PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P200PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P200PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P200PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P200PFS_HA_ASEL_1 = 0x1

	// P200PFS_BY: Port 200 Pin Function Select Register
	// Position of PODR field.
	PFS_P200PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P200PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P200PFS_BY_PODR = 0x1
	// Output low
	PFS_P200PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P200PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P200PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P200PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P200PFS_BY_PIDR = 0x2
	// Low level
	PFS_P200PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P200PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P200PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P200PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P200PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P200PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P200PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P200PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P200PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P200PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P200PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P200PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P200PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P200PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P200PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P200PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P200PFS_BY_NCODR_1 = 0x1

	// P201PFS: Port 201 Pin Function Select Register
	// Position of PODR field.
	PFS_P201PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P201PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P201PFS_PODR = 0x1
	// Output low
	PFS_P201PFS_PODR_0 = 0x0
	// Output high
	PFS_P201PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P201PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P201PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P201PFS_PIDR = 0x2
	// Low level
	PFS_P201PFS_PIDR_0 = 0x0
	// High level
	PFS_P201PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P201PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P201PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P201PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P201PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P201PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P201PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P201PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P201PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P201PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P201PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P201PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P201PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P201PFS_NCODR = 0x40
	// Output CMOS
	PFS_P201PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P201PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P201PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P201PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P201PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P201PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P201PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P201PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P201PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P201PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P201PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P201PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P201PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P201PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P201PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P201PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P201PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P201PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P201PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P201PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P201PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P201PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P201PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P201PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P201PFS_PSEL_Msk = 0x1f000000

	// P201PFS_HA: Port 201 Pin Function Select Register
	// Position of PODR field.
	PFS_P201PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P201PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P201PFS_HA_PODR = 0x1
	// Output low
	PFS_P201PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P201PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P201PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P201PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P201PFS_HA_PIDR = 0x2
	// Low level
	PFS_P201PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P201PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P201PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P201PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P201PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P201PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P201PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P201PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P201PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P201PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P201PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P201PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P201PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P201PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P201PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P201PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P201PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P201PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P201PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P201PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P201PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P201PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P201PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P201PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P201PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P201PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P201PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P201PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P201PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P201PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P201PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P201PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P201PFS_HA_ASEL_1 = 0x1

	// P201PFS_BY: Port 201 Pin Function Select Register
	// Position of PODR field.
	PFS_P201PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P201PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P201PFS_BY_PODR = 0x1
	// Output low
	PFS_P201PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P201PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P201PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P201PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P201PFS_BY_PIDR = 0x2
	// Low level
	PFS_P201PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P201PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P201PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P201PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P201PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P201PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P201PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P201PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P201PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P201PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P201PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P201PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P201PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P201PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P201PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P201PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P201PFS_BY_NCODR_1 = 0x1

	// P205PFS: Port 20%s Pin Function Select Register
	// Position of PODR field.
	PFS_P20PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P20PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P20PFS_PODR = 0x1
	// Output low
	PFS_P20PFS_PODR_0 = 0x0
	// Output high
	PFS_P20PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P20PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P20PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P20PFS_PIDR = 0x2
	// Low level
	PFS_P20PFS_PIDR_0 = 0x0
	// High level
	PFS_P20PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P20PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P20PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P20PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P20PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P20PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P20PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P20PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P20PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P20PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P20PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P20PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P20PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P20PFS_NCODR = 0x40
	// Output CMOS
	PFS_P20PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P20PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P20PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P20PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P20PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P20PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P20PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P20PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P20PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P20PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P20PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P20PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P20PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P20PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P20PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P20PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P20PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P20PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P20PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P20PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P20PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P20PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P20PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P20PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P20PFS_PSEL_Msk = 0x1f000000

	// P205PFS_HA: Port 20%s Pin Function Select Register
	// Position of PODR field.
	PFS_P20PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P20PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P20PFS_HA_PODR = 0x1
	// Output low
	PFS_P20PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P20PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P20PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P20PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P20PFS_HA_PIDR = 0x2
	// Low level
	PFS_P20PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P20PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P20PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P20PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P20PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P20PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P20PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P20PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P20PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P20PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P20PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P20PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P20PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P20PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P20PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P20PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P20PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P20PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P20PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P20PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P20PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P20PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P20PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P20PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P20PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P20PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P20PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P20PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P20PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P20PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P20PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P20PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P20PFS_HA_ASEL_1 = 0x1

	// P205PFS_BY: Port 20%s Pin Function Select Register
	// Position of PODR field.
	PFS_P20PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P20PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P20PFS_BY_PODR = 0x1
	// Output low
	PFS_P20PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P20PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P20PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P20PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P20PFS_BY_PIDR = 0x2
	// Low level
	PFS_P20PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P20PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P20PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P20PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P20PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P20PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P20PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P20PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P20PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P20PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P20PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P20PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P20PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P20PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P20PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P20PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P20PFS_BY_NCODR_1 = 0x1

	// P210PFS: Port 2%s Pin Function Select Register
	// Position of PODR field.
	PFS_P2PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P2PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P2PFS_PODR = 0x1
	// Output low
	PFS_P2PFS_PODR_0 = 0x0
	// Output high
	PFS_P2PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P2PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P2PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P2PFS_PIDR = 0x2
	// Low level
	PFS_P2PFS_PIDR_0 = 0x0
	// High level
	PFS_P2PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P2PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P2PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P2PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P2PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P2PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P2PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P2PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P2PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P2PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P2PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P2PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P2PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P2PFS_NCODR = 0x40
	// Output CMOS
	PFS_P2PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P2PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P2PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P2PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P2PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P2PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P2PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P2PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P2PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P2PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P2PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P2PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P2PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P2PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P2PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P2PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P2PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P2PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P2PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P2PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P2PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P2PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P2PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P2PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P2PFS_PSEL_Msk = 0x1f000000

	// P210PFS_HA: Port 2%s Pin Function Select Register
	// Position of PODR field.
	PFS_P2PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P2PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P2PFS_HA_PODR = 0x1
	// Output low
	PFS_P2PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P2PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P2PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P2PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P2PFS_HA_PIDR = 0x2
	// Low level
	PFS_P2PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P2PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P2PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P2PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P2PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P2PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P2PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P2PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P2PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P2PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P2PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P2PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P2PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P2PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P2PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P2PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P2PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P2PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P2PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P2PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P2PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P2PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P2PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P2PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P2PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P2PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P2PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P2PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P2PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P2PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P2PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P2PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P2PFS_HA_ASEL_1 = 0x1

	// P210PFS_BY: Port 2%s Pin Function Select Register
	// Position of PODR field.
	PFS_P2PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P2PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P2PFS_BY_PODR = 0x1
	// Output low
	PFS_P2PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P2PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P2PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P2PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P2PFS_BY_PIDR = 0x2
	// Low level
	PFS_P2PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P2PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P2PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P2PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P2PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P2PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P2PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P2PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P2PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P2PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P2PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P2PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P2PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P2PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P2PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P2PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P2PFS_BY_NCODR_1 = 0x1

	// P300PFS: Port 300 Pin Function Select Register
	// Position of PODR field.
	PFS_P300PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P300PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P300PFS_PODR = 0x1
	// Output low
	PFS_P300PFS_PODR_0 = 0x0
	// Output high
	PFS_P300PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P300PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P300PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P300PFS_PIDR = 0x2
	// Low level
	PFS_P300PFS_PIDR_0 = 0x0
	// High level
	PFS_P300PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P300PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P300PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P300PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P300PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P300PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P300PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P300PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P300PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P300PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P300PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P300PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P300PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P300PFS_NCODR = 0x40
	// Output CMOS
	PFS_P300PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P300PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P300PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P300PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P300PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P300PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P300PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P300PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P300PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P300PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P300PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P300PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P300PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P300PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P300PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P300PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P300PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P300PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P300PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P300PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P300PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P300PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P300PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P300PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P300PFS_PSEL_Msk = 0x1f000000

	// P300PFS_HA: Port 300 Pin Function Select Register
	// Position of PODR field.
	PFS_P300PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P300PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P300PFS_HA_PODR = 0x1
	// Output low
	PFS_P300PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P300PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P300PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P300PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P300PFS_HA_PIDR = 0x2
	// Low level
	PFS_P300PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P300PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P300PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P300PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P300PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P300PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P300PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P300PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P300PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P300PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P300PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P300PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P300PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P300PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P300PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P300PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P300PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P300PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P300PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P300PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P300PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P300PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P300PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P300PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P300PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P300PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P300PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P300PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P300PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P300PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P300PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P300PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P300PFS_HA_ASEL_1 = 0x1

	// P300PFS_BY: Port 300 Pin Function Select Register
	// Position of PODR field.
	PFS_P300PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P300PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P300PFS_BY_PODR = 0x1
	// Output low
	PFS_P300PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P300PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P300PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P300PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P300PFS_BY_PIDR = 0x2
	// Low level
	PFS_P300PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P300PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P300PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P300PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P300PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P300PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P300PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P300PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P300PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P300PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P300PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P300PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P300PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P300PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P300PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P300PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P300PFS_BY_NCODR_1 = 0x1

	// P301PFS: Port 30%s Pin Function Select Register
	// Position of PODR field.
	PFS_P30PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P30PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P30PFS_PODR = 0x1
	// Output low
	PFS_P30PFS_PODR_0 = 0x0
	// Output high
	PFS_P30PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P30PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P30PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P30PFS_PIDR = 0x2
	// Low level
	PFS_P30PFS_PIDR_0 = 0x0
	// High level
	PFS_P30PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P30PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P30PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P30PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P30PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P30PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P30PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P30PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P30PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P30PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P30PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P30PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P30PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P30PFS_NCODR = 0x40
	// Output CMOS
	PFS_P30PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P30PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P30PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P30PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P30PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P30PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P30PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P30PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P30PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P30PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P30PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P30PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P30PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P30PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P30PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P30PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P30PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P30PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P30PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P30PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P30PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P30PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P30PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P30PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P30PFS_PSEL_Msk = 0x1f000000

	// P301PFS_HA: Port 30%s Pin Function Select Register
	// Position of PODR field.
	PFS_P30PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P30PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P30PFS_HA_PODR = 0x1
	// Output low
	PFS_P30PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P30PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P30PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P30PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P30PFS_HA_PIDR = 0x2
	// Low level
	PFS_P30PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P30PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P30PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P30PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P30PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P30PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P30PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P30PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P30PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P30PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P30PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P30PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P30PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P30PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P30PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P30PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P30PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P30PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P30PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P30PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P30PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P30PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P30PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P30PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P30PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P30PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P30PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P30PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P30PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P30PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P30PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P30PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P30PFS_HA_ASEL_1 = 0x1

	// P301PFS_BY: Port 30%s Pin Function Select Register
	// Position of PODR field.
	PFS_P30PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P30PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P30PFS_BY_PODR = 0x1
	// Output low
	PFS_P30PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P30PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P30PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P30PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P30PFS_BY_PIDR = 0x2
	// Low level
	PFS_P30PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P30PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P30PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P30PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P30PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P30PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P30PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P30PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P30PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P30PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P30PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P30PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P30PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P30PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P30PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P30PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P30PFS_BY_NCODR_1 = 0x1

	// P400PFS: Port 40%s Pin Function Select Register
	// Position of PODR field.
	PFS_P40PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P40PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P40PFS_PODR = 0x1
	// Output low
	PFS_P40PFS_PODR_0 = 0x0
	// Output high
	PFS_P40PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P40PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P40PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P40PFS_PIDR = 0x2
	// Low level
	PFS_P40PFS_PIDR_0 = 0x0
	// High level
	PFS_P40PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P40PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P40PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P40PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P40PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P40PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P40PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P40PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P40PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P40PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P40PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P40PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P40PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P40PFS_NCODR = 0x40
	// Output CMOS
	PFS_P40PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P40PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P40PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P40PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P40PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P40PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P40PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P40PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P40PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P40PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P40PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P40PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P40PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P40PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P40PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P40PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P40PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P40PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P40PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P40PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P40PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P40PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P40PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P40PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P40PFS_PSEL_Msk = 0x1f000000

	// P400PFS_HA: Port 40%s Pin Function Select Register
	// Position of PODR field.
	PFS_P40PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P40PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P40PFS_HA_PODR = 0x1
	// Output low
	PFS_P40PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P40PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P40PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P40PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P40PFS_HA_PIDR = 0x2
	// Low level
	PFS_P40PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P40PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P40PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P40PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P40PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P40PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P40PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P40PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P40PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P40PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P40PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P40PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P40PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P40PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P40PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P40PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P40PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P40PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P40PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P40PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P40PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P40PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P40PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P40PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P40PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P40PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P40PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P40PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P40PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P40PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P40PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P40PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P40PFS_HA_ASEL_1 = 0x1

	// P400PFS_BY: Port 40%s Pin Function Select Register
	// Position of PODR field.
	PFS_P40PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P40PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P40PFS_BY_PODR = 0x1
	// Output low
	PFS_P40PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P40PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P40PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P40PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P40PFS_BY_PIDR = 0x2
	// Low level
	PFS_P40PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P40PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P40PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P40PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P40PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P40PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P40PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P40PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P40PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P40PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P40PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P40PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P40PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P40PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P40PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P40PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P40PFS_BY_NCODR_1 = 0x1

	// P410PFS: Port 4%s Pin Function Select Register
	// Position of PODR field.
	PFS_P4PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P4PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P4PFS_PODR = 0x1
	// Output low
	PFS_P4PFS_PODR_0 = 0x0
	// Output high
	PFS_P4PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P4PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P4PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P4PFS_PIDR = 0x2
	// Low level
	PFS_P4PFS_PIDR_0 = 0x0
	// High level
	PFS_P4PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P4PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P4PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P4PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P4PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P4PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P4PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P4PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P4PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P4PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P4PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P4PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P4PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P4PFS_NCODR = 0x40
	// Output CMOS
	PFS_P4PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P4PFS_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P4PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P4PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P4PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P4PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P4PFS_EOFR_10 = 0x2
	// Detect both edges
	PFS_P4PFS_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P4PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P4PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P4PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P4PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P4PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P4PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P4PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P4PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P4PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P4PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P4PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P4PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P4PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P4PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P4PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P4PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P4PFS_PSEL_Msk = 0x1f000000

	// P410PFS_HA: Port 4%s Pin Function Select Register
	// Position of PODR field.
	PFS_P4PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P4PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P4PFS_HA_PODR = 0x1
	// Output low
	PFS_P4PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P4PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P4PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P4PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P4PFS_HA_PIDR = 0x2
	// Low level
	PFS_P4PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P4PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P4PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P4PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P4PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P4PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P4PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P4PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P4PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P4PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P4PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P4PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P4PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P4PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P4PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P4PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P4PFS_HA_NCODR_1 = 0x1
	// Position of EOFR field.
	PFS_P4PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P4PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P4PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P4PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P4PFS_HA_EOFR_10 = 0x2
	// Detect both edges
	PFS_P4PFS_HA_EOFR_11 = 0x3
	// Position of ISEL field.
	PFS_P4PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P4PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P4PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P4PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P4PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P4PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P4PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P4PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P4PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P4PFS_HA_ASEL_1 = 0x1

	// P410PFS_BY: Port 4%s Pin Function Select Register
	// Position of PODR field.
	PFS_P4PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P4PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P4PFS_BY_PODR = 0x1
	// Output low
	PFS_P4PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P4PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P4PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P4PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P4PFS_BY_PIDR = 0x2
	// Low level
	PFS_P4PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P4PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P4PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P4PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P4PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P4PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P4PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P4PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P4PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P4PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P4PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P4PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P4PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P4PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P4PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P4PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P4PFS_BY_NCODR_1 = 0x1

	// P500PFS: Port 50%s Pin Function Select Register
	// Position of PODR field.
	PFS_P50PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P50PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P50PFS_PODR = 0x1
	// Output low
	PFS_P50PFS_PODR_0 = 0x0
	// Output high
	PFS_P50PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P50PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P50PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P50PFS_PIDR = 0x2
	// Low level
	PFS_P50PFS_PIDR_0 = 0x0
	// High level
	PFS_P50PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P50PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P50PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P50PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P50PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P50PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P50PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P50PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P50PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P50PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P50PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P50PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P50PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P50PFS_NCODR = 0x40
	// Output CMOS
	PFS_P50PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P50PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P50PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P50PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P50PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P50PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P50PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P50PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P50PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P50PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P50PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P50PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P50PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P50PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P50PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P50PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P50PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P50PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P50PFS_PSEL_Msk = 0x1f000000

	// P500PFS_HA: Port 50%s Pin Function Select Register
	// Position of PODR field.
	PFS_P50PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P50PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P50PFS_HA_PODR = 0x1
	// Output low
	PFS_P50PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P50PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P50PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P50PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P50PFS_HA_PIDR = 0x2
	// Low level
	PFS_P50PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P50PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P50PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P50PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P50PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P50PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P50PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P50PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P50PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P50PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P50PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P50PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P50PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P50PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P50PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P50PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P50PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P50PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P50PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P50PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P50PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P50PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P50PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P50PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P50PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P50PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P50PFS_HA_ASEL_1 = 0x1

	// P500PFS_BY: Port 50%s Pin Function Select Register
	// Position of PODR field.
	PFS_P50PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P50PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P50PFS_BY_PODR = 0x1
	// Output low
	PFS_P50PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P50PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P50PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P50PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P50PFS_BY_PIDR = 0x2
	// Low level
	PFS_P50PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P50PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P50PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P50PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P50PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P50PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P50PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P50PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P50PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P50PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P50PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P50PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P50PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P50PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P50PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P50PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P50PFS_BY_NCODR_1 = 0x1

	// P600PFS: Port 60%s Pin Function Select Register
	// Position of PODR field.
	PFS_P60PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P60PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P60PFS_PODR = 0x1
	// Output low
	PFS_P60PFS_PODR_0 = 0x0
	// Output high
	PFS_P60PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P60PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P60PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P60PFS_PIDR = 0x2
	// Low level
	PFS_P60PFS_PIDR_0 = 0x0
	// High level
	PFS_P60PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P60PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P60PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P60PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P60PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P60PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P60PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P60PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P60PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P60PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P60PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P60PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P60PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P60PFS_NCODR = 0x40
	// Output CMOS
	PFS_P60PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P60PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P60PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P60PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P60PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P60PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P60PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P60PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P60PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P60PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P60PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P60PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P60PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P60PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P60PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P60PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P60PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P60PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P60PFS_PSEL_Msk = 0x1f000000

	// P600PFS_HA: Port 60%s Pin Function Select Register
	// Position of PODR field.
	PFS_P60PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P60PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P60PFS_HA_PODR = 0x1
	// Output low
	PFS_P60PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P60PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P60PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P60PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P60PFS_HA_PIDR = 0x2
	// Low level
	PFS_P60PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P60PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P60PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P60PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P60PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P60PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P60PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P60PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P60PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P60PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P60PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P60PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P60PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P60PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P60PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P60PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P60PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P60PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P60PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P60PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P60PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P60PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P60PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P60PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P60PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P60PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P60PFS_HA_ASEL_1 = 0x1

	// P600PFS_BY: Port 60%s Pin Function Select Register
	// Position of PODR field.
	PFS_P60PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P60PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P60PFS_BY_PODR = 0x1
	// Output low
	PFS_P60PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P60PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P60PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P60PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P60PFS_BY_PIDR = 0x2
	// Low level
	PFS_P60PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P60PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P60PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P60PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P60PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P60PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P60PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P60PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P60PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P60PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P60PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P60PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P60PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P60PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P60PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P60PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P60PFS_BY_NCODR_1 = 0x1

	// P608PFS: Port 60%s Pin Function Select Register
	// Position of PODR field.
	PFS_P60PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P60PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P60PFS_PODR = 0x1
	// Output low
	PFS_P60PFS_PODR_0 = 0x0
	// Output high
	PFS_P60PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P60PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P60PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P60PFS_PIDR = 0x2
	// Low level
	PFS_P60PFS_PIDR_0 = 0x0
	// High level
	PFS_P60PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P60PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P60PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P60PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P60PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P60PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P60PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P60PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P60PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P60PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P60PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P60PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P60PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P60PFS_NCODR = 0x40
	// Output CMOS
	PFS_P60PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P60PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P60PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P60PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P60PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P60PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P60PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P60PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P60PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P60PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P60PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P60PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P60PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P60PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P60PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P60PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P60PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P60PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P60PFS_PSEL_Msk = 0x1f000000

	// P608PFS_HA: Port 60%s Pin Function Select Register
	// Position of PODR field.
	PFS_P60PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P60PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P60PFS_HA_PODR = 0x1
	// Output low
	PFS_P60PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P60PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P60PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P60PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P60PFS_HA_PIDR = 0x2
	// Low level
	PFS_P60PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P60PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P60PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P60PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P60PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P60PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P60PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P60PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P60PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P60PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P60PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P60PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P60PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P60PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P60PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P60PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P60PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P60PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P60PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P60PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P60PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P60PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P60PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P60PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P60PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P60PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P60PFS_HA_ASEL_1 = 0x1

	// P608PFS_BY: Port 60%s Pin Function Select Register
	// Position of PODR field.
	PFS_P60PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P60PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P60PFS_BY_PODR = 0x1
	// Output low
	PFS_P60PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P60PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P60PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P60PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P60PFS_BY_PIDR = 0x2
	// Low level
	PFS_P60PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P60PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P60PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P60PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P60PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P60PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P60PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P60PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P60PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P60PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P60PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P60PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P60PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P60PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P60PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P60PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P60PFS_BY_NCODR_1 = 0x1

	// P610PFS: Port 610 Pin Function Select Register
	// Position of PODR field.
	PFS_P610PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P610PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P610PFS_PODR = 0x1
	// Output low
	PFS_P610PFS_PODR_0 = 0x0
	// Output high
	PFS_P610PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P610PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P610PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P610PFS_PIDR = 0x2
	// Low level
	PFS_P610PFS_PIDR_0 = 0x0
	// High level
	PFS_P610PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P610PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P610PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P610PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P610PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P610PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P610PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P610PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P610PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P610PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P610PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P610PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P610PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P610PFS_NCODR = 0x40
	// Output CMOS
	PFS_P610PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P610PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P610PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P610PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P610PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P610PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P610PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P610PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P610PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P610PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P610PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P610PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P610PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P610PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P610PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P610PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P610PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P610PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P610PFS_PSEL_Msk = 0x1f000000

	// P610PFS_HA: Port 610 Pin Function Select Register
	// Position of PODR field.
	PFS_P610PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P610PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P610PFS_HA_PODR = 0x1
	// Output low
	PFS_P610PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P610PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P610PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P610PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P610PFS_HA_PIDR = 0x2
	// Low level
	PFS_P610PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P610PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P610PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P610PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P610PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P610PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P610PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P610PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P610PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P610PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P610PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P610PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P610PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P610PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P610PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P610PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P610PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P610PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P610PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P610PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P610PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P610PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P610PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P610PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P610PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P610PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P610PFS_HA_ASEL_1 = 0x1

	// P610PFS_BY: Port 610 Pin Function Select Register
	// Position of PODR field.
	PFS_P610PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P610PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P610PFS_BY_PODR = 0x1
	// Output low
	PFS_P610PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P610PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P610PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P610PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P610PFS_BY_PIDR = 0x2
	// Low level
	PFS_P610PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P610PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P610PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P610PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P610PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P610PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P610PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P610PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P610PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P610PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P610PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P610PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P610PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P610PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P610PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P610PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P610PFS_BY_NCODR_1 = 0x1

	// P708PFS: Port 708 Pin Function Select Register
	// Position of PODR field.
	PFS_P708PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P708PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P708PFS_PODR = 0x1
	// Output low
	PFS_P708PFS_PODR_0 = 0x0
	// Output high
	PFS_P708PFS_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P708PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P708PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P708PFS_PIDR = 0x2
	// Low level
	PFS_P708PFS_PIDR_0 = 0x0
	// High level
	PFS_P708PFS_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P708PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P708PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P708PFS_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P708PFS_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P708PFS_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P708PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P708PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P708PFS_PCR = 0x10
	// Disable input pull-up
	PFS_P708PFS_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P708PFS_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P708PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P708PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P708PFS_NCODR = 0x40
	// Output CMOS
	PFS_P708PFS_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P708PFS_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P708PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P708PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P708PFS_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P708PFS_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P708PFS_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P708PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P708PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P708PFS_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P708PFS_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P708PFS_ASEL_1 = 0x1
	// Position of PMR field.
	PFS_P708PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P708PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P708PFS_PMR = 0x10000
	// Use as general I/O pin
	PFS_P708PFS_PMR_0 = 0x0
	// Use as I/O port for peripheral functions
	PFS_P708PFS_PMR_1 = 0x1
	// Position of PSEL field.
	PFS_P708PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P708PFS_PSEL_Msk = 0x1f000000

	// P708PFS_HA: Port 708 Pin Function Select Register
	// Position of PODR field.
	PFS_P708PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P708PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P708PFS_HA_PODR = 0x1
	// Output low
	PFS_P708PFS_HA_PODR_0 = 0x0
	// Output high
	PFS_P708PFS_HA_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P708PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P708PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P708PFS_HA_PIDR = 0x2
	// Low level
	PFS_P708PFS_HA_PIDR_0 = 0x0
	// High level
	PFS_P708PFS_HA_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P708PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P708PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P708PFS_HA_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P708PFS_HA_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P708PFS_HA_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P708PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P708PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P708PFS_HA_PCR = 0x10
	// Disable input pull-up
	PFS_P708PFS_HA_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P708PFS_HA_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P708PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P708PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P708PFS_HA_NCODR = 0x40
	// Output CMOS
	PFS_P708PFS_HA_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P708PFS_HA_NCODR_1 = 0x1
	// Position of ISEL field.
	PFS_P708PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P708PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P708PFS_HA_ISEL = 0x4000
	// Do not use as IRQn input pin
	PFS_P708PFS_HA_ISEL_0 = 0x0
	// Use as IRQn input pin
	PFS_P708PFS_HA_ISEL_1 = 0x1
	// Position of ASEL field.
	PFS_P708PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P708PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P708PFS_HA_ASEL = 0x8000
	// Do not use as analog pin
	PFS_P708PFS_HA_ASEL_0 = 0x0
	// Use as analog pin
	PFS_P708PFS_HA_ASEL_1 = 0x1

	// P708PFS_BY: Port 708 Pin Function Select Register
	// Position of PODR field.
	PFS_P708PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P708PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P708PFS_BY_PODR = 0x1
	// Output low
	PFS_P708PFS_BY_PODR_0 = 0x0
	// Output high
	PFS_P708PFS_BY_PODR_1 = 0x1
	// Position of PIDR field.
	PFS_P708PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P708PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P708PFS_BY_PIDR = 0x2
	// Low level
	PFS_P708PFS_BY_PIDR_0 = 0x0
	// High level
	PFS_P708PFS_BY_PIDR_1 = 0x1
	// Position of PDR field.
	PFS_P708PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P708PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P708PFS_BY_PDR = 0x4
	// Input (functions as an input pin)
	PFS_P708PFS_BY_PDR_0 = 0x0
	// Output (functions as an output pin)
	PFS_P708PFS_BY_PDR_1 = 0x1
	// Position of PCR field.
	PFS_P708PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P708PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P708PFS_BY_PCR = 0x10
	// Disable input pull-up
	PFS_P708PFS_BY_PCR_0 = 0x0
	// Enable input pull-up
	PFS_P708PFS_BY_PCR_1 = 0x1
	// Position of NCODR field.
	PFS_P708PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P708PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P708PFS_BY_NCODR = 0x40
	// Output CMOS
	PFS_P708PFS_BY_NCODR_0 = 0x0
	// Output NMOS open-drain
	PFS_P708PFS_BY_NCODR_1 = 0x1

	// PFENET: Ethernet Control Register
	// Position of PHYMODE0 field.
	PFS_PFENET_PHYMODE0_Pos = 0x4
	// Bit mask of PHYMODE0 field.
	PFS_PFENET_PHYMODE0_Msk = 0x10
	// Bit PHYMODE0.
	PFS_PFENET_PHYMODE0 = 0x10
	// RMII mode (ETHERC channel 0)
	PFS_PFENET_PHYMODE0_0 = 0x0
	// Setting prohibited
	PFS_PFENET_PHYMODE0_1 = 0x1

	// PWPR: Write-Protect Register
	// Position of PFSWE field.
	PFS_PWPR_PFSWE_Pos = 0x6
	// Bit mask of PFSWE field.
	PFS_PWPR_PFSWE_Msk = 0x40
	// Bit PFSWE.
	PFS_PWPR_PFSWE = 0x40
	// Writing to the PmnPFS register is disabled
	PFS_PWPR_PFSWE_0 = 0x0
	// Writing to the PmnPFS register is enabled
	PFS_PWPR_PFSWE_1 = 0x1
	// Position of B0WI field.
	PFS_PWPR_B0WI_Pos = 0x7
	// Bit mask of B0WI field.
	PFS_PWPR_B0WI_Msk = 0x80
	// Bit B0WI.
	PFS_PWPR_B0WI = 0x80
	// Writing to the PFSWE bit is enabled
	PFS_PWPR_B0WI_0 = 0x0
	// Writing to the PFSWE bit is disabled
	PFS_PWPR_B0WI_1 = 0x1

	// PWPRS: Write-Protect Register for Secure
	// Position of PFSWE field.
	PFS_PWPRS_PFSWE_Pos = 0x6
	// Bit mask of PFSWE field.
	PFS_PWPRS_PFSWE_Msk = 0x40
	// Bit PFSWE.
	PFS_PWPRS_PFSWE = 0x40
	// Disable writes to the PmnPFS register
	PFS_PWPRS_PFSWE_0 = 0x0
	// Enable writes to the PmnPFS register
	PFS_PWPRS_PFSWE_1 = 0x1
	// Position of B0WI field.
	PFS_PWPRS_B0WI_Pos = 0x7
	// Bit mask of B0WI field.
	PFS_PWPRS_B0WI_Msk = 0x80
	// Bit B0WI.
	PFS_PWPRS_B0WI = 0x80
	// Enable writes the PFSWE bit
	PFS_PWPRS_B0WI_0 = 0x0
	// Disable writes to the PFSWE bit
	PFS_PWPRS_B0WI_1 = 0x1

	// P0SAR: Port Security Attribution register
	// Position of PMNSA field.
	PFS_PSAR_PMNSA_Pos = 0x0
	// Bit mask of PMNSA field.
	PFS_PSAR_PMNSA_Msk = 0xffff
	// Secure
	PFS_PSAR_PMNSA_0 = 0x0
	// Non Secure
	PFS_PSAR_PMNSA_1 = 0x1
)

// Constants for ELC: Event Link Controller
const (
	// ELCR: Event Link Controller Register
	// Position of ELCON field.
	ELC_ELCR_ELCON_Pos = 0x7
	// Bit mask of ELCON field.
	ELC_ELCR_ELCON_Msk = 0x80
	// Bit ELCON.
	ELC_ELCR_ELCON = 0x80
	// ELC function is disabled.
	ELC_ELCR_ELCON_0 = 0x0
	// ELC function is enabled.
	ELC_ELCR_ELCON_1 = 0x1

	// ELSEGR0: Event Link Software Event Generation Register %s
	// Position of SEG field.
	ELC_ELSEGR_SEG_Pos = 0x0
	// Bit mask of SEG field.
	ELC_ELSEGR_SEG_Msk = 0x1
	// Bit SEG.
	ELC_ELSEGR_SEG = 0x1
	// Normal operation
	ELC_ELSEGR_SEG_0 = 0x0
	// Software event is generated.
	ELC_ELSEGR_SEG_1 = 0x1
	// Position of WE field.
	ELC_ELSEGR_WE_Pos = 0x6
	// Bit mask of WE field.
	ELC_ELSEGR_WE_Msk = 0x40
	// Bit WE.
	ELC_ELSEGR_WE = 0x40
	// Write to SEG bit disabled.
	ELC_ELSEGR_WE_0 = 0x0
	// Write to SEG bit enabled.
	ELC_ELSEGR_WE_1 = 0x1
	// Position of WI field.
	ELC_ELSEGR_WI_Pos = 0x7
	// Bit mask of WI field.
	ELC_ELSEGR_WI_Msk = 0x80
	// Bit WI.
	ELC_ELSEGR_WI = 0x80
	// Write to ELSEGR register enabled.
	ELC_ELSEGR_WI_0 = 0x0
	// Write to ELSEGR register disabled.
	ELC_ELSEGR_WI_1 = 0x1

	// ELSR0: Event Link Setting Register %s
	// Position of ELS field.
	ELC_ELSR_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR_ELS_Msk = 0x1ff

	// ELSR12: Event Link Setting Register 12
	// Position of ELS field.
	ELC_ELSR12_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR12_ELS_Msk = 0x1ff

	// ELSR14: Event Link Setting Register %s
	// Position of ELS field.
	ELC_ELSR_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR_ELS_Msk = 0x1ff

	// ELCSARA: Event Link Controller Security Attribution Register A
	// Position of ELCR field.
	ELC_ELCSARA_ELCR_Pos = 0x0
	// Bit mask of ELCR field.
	ELC_ELCSARA_ELCR_Msk = 0x1
	// Bit ELCR.
	ELC_ELCSARA_ELCR = 0x1
	// Secure
	ELC_ELCSARA_ELCR_0 = 0x0
	// Non-secure
	ELC_ELCSARA_ELCR_1 = 0x1
	// Position of ELSEGR0 field.
	ELC_ELCSARA_ELSEGR0_Pos = 0x1
	// Bit mask of ELSEGR0 field.
	ELC_ELCSARA_ELSEGR0_Msk = 0x2
	// Bit ELSEGR0.
	ELC_ELCSARA_ELSEGR0 = 0x2
	// Secure
	ELC_ELCSARA_ELSEGR0_0 = 0x0
	// Non-secure
	ELC_ELCSARA_ELSEGR0_1 = 0x1
	// Position of ELSEGR1 field.
	ELC_ELCSARA_ELSEGR1_Pos = 0x2
	// Bit mask of ELSEGR1 field.
	ELC_ELCSARA_ELSEGR1_Msk = 0x4
	// Bit ELSEGR1.
	ELC_ELCSARA_ELSEGR1 = 0x4
	// Secure
	ELC_ELCSARA_ELSEGR1_0 = 0x0
	// Non-secure
	ELC_ELCSARA_ELSEGR1_1 = 0x1

	// ELCSARB: Event Link Controller Security Attribution Register B
	// Position of ELSR field.
	ELC_ELCSARB_ELSR_Pos = 0x0
	// Bit mask of ELSR field.
	ELC_ELCSARB_ELSR_Msk = 0xffff
	// Secure
	ELC_ELCSARB_ELSR_0 = 0x0
	// Non-secure
	ELC_ELCSARB_ELSR_1 = 0x1

	// ELCSARC: Event Link Controller Security Attribution Register C
	// Position of ELSR field.
	ELC_ELCSARC_ELSR_Pos = 0x0
	// Bit mask of ELSR field.
	ELC_ELCSARC_ELSR_Msk = 0x3
	// Secure
	ELC_ELCSARC_ELSR_0 = 0x0
	// Non-secure
	ELC_ELCSARC_ELSR_1 = 0x1
)

// Constants for RTC: Realtime Clock
const (
	// R64CNT: 64-Hz Counter
	// Position of F64HZ field.
	RTC_R64CNT_F64HZ_Pos = 0x0
	// Bit mask of F64HZ field.
	RTC_R64CNT_F64HZ_Msk = 0x1
	// Bit F64HZ.
	RTC_R64CNT_F64HZ = 0x1
	// Position of F32HZ field.
	RTC_R64CNT_F32HZ_Pos = 0x1
	// Bit mask of F32HZ field.
	RTC_R64CNT_F32HZ_Msk = 0x2
	// Bit F32HZ.
	RTC_R64CNT_F32HZ = 0x2
	// Position of F16HZ field.
	RTC_R64CNT_F16HZ_Pos = 0x2
	// Bit mask of F16HZ field.
	RTC_R64CNT_F16HZ_Msk = 0x4
	// Bit F16HZ.
	RTC_R64CNT_F16HZ = 0x4
	// Position of F8HZ field.
	RTC_R64CNT_F8HZ_Pos = 0x3
	// Bit mask of F8HZ field.
	RTC_R64CNT_F8HZ_Msk = 0x8
	// Bit F8HZ.
	RTC_R64CNT_F8HZ = 0x8
	// Position of F4HZ field.
	RTC_R64CNT_F4HZ_Pos = 0x4
	// Bit mask of F4HZ field.
	RTC_R64CNT_F4HZ_Msk = 0x10
	// Bit F4HZ.
	RTC_R64CNT_F4HZ = 0x10
	// Position of F2HZ field.
	RTC_R64CNT_F2HZ_Pos = 0x5
	// Bit mask of F2HZ field.
	RTC_R64CNT_F2HZ_Msk = 0x20
	// Bit F2HZ.
	RTC_R64CNT_F2HZ = 0x20
	// Position of F1HZ field.
	RTC_R64CNT_F1HZ_Pos = 0x6
	// Bit mask of F1HZ field.
	RTC_R64CNT_F1HZ_Msk = 0x40
	// Bit F1HZ.
	RTC_R64CNT_F1HZ = 0x40

	// BCNT0: Binary Counter %s
	// Position of BCNT field.
	RTC_BCNT_BCNT_Pos = 0x0
	// Bit mask of BCNT field.
	RTC_BCNT_BCNT_Msk = 0xff

	// RSECCNT: Second Counter (in Calendar Count Mode)
	// Position of SEC1 field.
	RTC_RSECCNT_SEC1_Pos = 0x0
	// Bit mask of SEC1 field.
	RTC_RSECCNT_SEC1_Msk = 0xf
	// Position of SEC10 field.
	RTC_RSECCNT_SEC10_Pos = 0x4
	// Bit mask of SEC10 field.
	RTC_RSECCNT_SEC10_Msk = 0x70

	// RMINCNT: Minute Counter (in Calendar Count Mode)
	// Position of MIN1 field.
	RTC_RMINCNT_MIN1_Pos = 0x0
	// Bit mask of MIN1 field.
	RTC_RMINCNT_MIN1_Msk = 0xf
	// Position of MIN10 field.
	RTC_RMINCNT_MIN10_Pos = 0x4
	// Bit mask of MIN10 field.
	RTC_RMINCNT_MIN10_Msk = 0x70

	// RHRCNT: Hour Counter (in Calendar Count Mode)
	// Position of HR1 field.
	RTC_RHRCNT_HR1_Pos = 0x0
	// Bit mask of HR1 field.
	RTC_RHRCNT_HR1_Msk = 0xf
	// Position of HR10 field.
	RTC_RHRCNT_HR10_Pos = 0x4
	// Bit mask of HR10 field.
	RTC_RHRCNT_HR10_Msk = 0x30
	// Position of PM field.
	RTC_RHRCNT_PM_Pos = 0x6
	// Bit mask of PM field.
	RTC_RHRCNT_PM_Msk = 0x40
	// Bit PM.
	RTC_RHRCNT_PM = 0x40
	// AM
	RTC_RHRCNT_PM_0 = 0x0
	// PM
	RTC_RHRCNT_PM_1 = 0x1

	// RWKCNT: Day-of-Week Counter (in Calendar Count Mode)
	// Position of DAYW field.
	RTC_RWKCNT_DAYW_Pos = 0x0
	// Bit mask of DAYW field.
	RTC_RWKCNT_DAYW_Msk = 0x7
	// Sunday
	RTC_RWKCNT_DAYW_000 = 0x0
	// Monday
	RTC_RWKCNT_DAYW_001 = 0x1
	// Tuesday
	RTC_RWKCNT_DAYW_010 = 0x2
	// Wednesday
	RTC_RWKCNT_DAYW_011 = 0x3
	// Thursday
	RTC_RWKCNT_DAYW_100 = 0x4
	// Friday
	RTC_RWKCNT_DAYW_101 = 0x5
	// Saturday
	RTC_RWKCNT_DAYW_110 = 0x6
	// Setting prohibited
	RTC_RWKCNT_DAYW_111 = 0x7

	// RDAYCNT: Day Counter
	// Position of DATE1 field.
	RTC_RDAYCNT_DATE1_Pos = 0x0
	// Bit mask of DATE1 field.
	RTC_RDAYCNT_DATE1_Msk = 0xf
	// Position of DATE10 field.
	RTC_RDAYCNT_DATE10_Pos = 0x4
	// Bit mask of DATE10 field.
	RTC_RDAYCNT_DATE10_Msk = 0x30

	// RMONCNT: Month Counter
	// Position of MON1 field.
	RTC_RMONCNT_MON1_Pos = 0x0
	// Bit mask of MON1 field.
	RTC_RMONCNT_MON1_Msk = 0xf
	// Position of MON10 field.
	RTC_RMONCNT_MON10_Pos = 0x4
	// Bit mask of MON10 field.
	RTC_RMONCNT_MON10_Msk = 0x10
	// Bit MON10.
	RTC_RMONCNT_MON10 = 0x10

	// RYRCNT: Year Counter
	// Position of YR1 field.
	RTC_RYRCNT_YR1_Pos = 0x0
	// Bit mask of YR1 field.
	RTC_RYRCNT_YR1_Msk = 0xf
	// Position of YR10 field.
	RTC_RYRCNT_YR10_Pos = 0x4
	// Bit mask of YR10 field.
	RTC_RYRCNT_YR10_Msk = 0xf0

	// BCNT0AR: Binary Counter %s Alarm Register
	// Position of BCNTAR field.
	RTC_BCNTAR_BCNTAR_Pos = 0x0
	// Bit mask of BCNTAR field.
	RTC_BCNTAR_BCNTAR_Msk = 0xff

	// RSECAR: Second Alarm Register (in Calendar Count Mode)
	// Position of SEC1 field.
	RTC_RSECAR_SEC1_Pos = 0x0
	// Bit mask of SEC1 field.
	RTC_RSECAR_SEC1_Msk = 0xf
	// Position of SEC10 field.
	RTC_RSECAR_SEC10_Pos = 0x4
	// Bit mask of SEC10 field.
	RTC_RSECAR_SEC10_Msk = 0x70
	// Position of ENB field.
	RTC_RSECAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RSECAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RSECAR_ENB = 0x80
	// Do not compare register value with RSECCNT counter value
	RTC_RSECAR_ENB_0 = 0x0
	// Compare register value with RSECCNT counter value
	RTC_RSECAR_ENB_1 = 0x1

	// RMINAR: Minute Alarm Register (in Calendar Count Mode)
	// Position of MIN1 field.
	RTC_RMINAR_MIN1_Pos = 0x0
	// Bit mask of MIN1 field.
	RTC_RMINAR_MIN1_Msk = 0xf
	// Position of MIN10 field.
	RTC_RMINAR_MIN10_Pos = 0x4
	// Bit mask of MIN10 field.
	RTC_RMINAR_MIN10_Msk = 0x70
	// Position of ENB field.
	RTC_RMINAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RMINAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RMINAR_ENB = 0x80
	// Do not compare register value with RMINCNT counter value
	RTC_RMINAR_ENB_0 = 0x0
	// Compare register value with RMINCNT counter value
	RTC_RMINAR_ENB_1 = 0x1

	// RHRAR: Hour Alarm Register (in Calendar Count Mode)
	// Position of HR1 field.
	RTC_RHRAR_HR1_Pos = 0x0
	// Bit mask of HR1 field.
	RTC_RHRAR_HR1_Msk = 0xf
	// Position of HR10 field.
	RTC_RHRAR_HR10_Pos = 0x4
	// Bit mask of HR10 field.
	RTC_RHRAR_HR10_Msk = 0x30
	// Position of PM field.
	RTC_RHRAR_PM_Pos = 0x6
	// Bit mask of PM field.
	RTC_RHRAR_PM_Msk = 0x40
	// Bit PM.
	RTC_RHRAR_PM = 0x40
	// AM
	RTC_RHRAR_PM_0 = 0x0
	// PM
	RTC_RHRAR_PM_1 = 0x1
	// Position of ENB field.
	RTC_RHRAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RHRAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RHRAR_ENB = 0x80
	// Do not compare register value with RHRCNT counter value
	RTC_RHRAR_ENB_0 = 0x0
	// Compare register value with RHRCNT counter value
	RTC_RHRAR_ENB_1 = 0x1

	// RWKAR: Day-of-Week Alarm Register (in Calendar Count Mode)
	// Position of DAYW field.
	RTC_RWKAR_DAYW_Pos = 0x0
	// Bit mask of DAYW field.
	RTC_RWKAR_DAYW_Msk = 0x7
	// Sunday
	RTC_RWKAR_DAYW_000 = 0x0
	// Monday
	RTC_RWKAR_DAYW_001 = 0x1
	// Tuesday
	RTC_RWKAR_DAYW_010 = 0x2
	// Wednesday
	RTC_RWKAR_DAYW_011 = 0x3
	// Thursday
	RTC_RWKAR_DAYW_100 = 0x4
	// Friday
	RTC_RWKAR_DAYW_101 = 0x5
	// Saturday
	RTC_RWKAR_DAYW_110 = 0x6
	// Setting prohibited
	RTC_RWKAR_DAYW_111 = 0x7
	// Position of ENB field.
	RTC_RWKAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RWKAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RWKAR_ENB = 0x80
	// Do not compare register value with RWKCNT counter value
	RTC_RWKAR_ENB_0 = 0x0
	// Compare register value with RWKCNT counter value
	RTC_RWKAR_ENB_1 = 0x1

	// BCNT0AER: Binary Counter %s Alarm Enable Register
	// Position of ENB field.
	RTC_BCNTAER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNTAER_ENB_Msk = 0xff

	// RDAYAR: Date Alarm Register (in Calendar Count Mode)
	// Position of DATE1 field.
	RTC_RDAYAR_DATE1_Pos = 0x0
	// Bit mask of DATE1 field.
	RTC_RDAYAR_DATE1_Msk = 0xf
	// Position of DATE10 field.
	RTC_RDAYAR_DATE10_Pos = 0x4
	// Bit mask of DATE10 field.
	RTC_RDAYAR_DATE10_Msk = 0x30
	// Position of ENB field.
	RTC_RDAYAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RDAYAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RDAYAR_ENB = 0x80
	// Do not compare register value with RDAYCNT counter value
	RTC_RDAYAR_ENB_0 = 0x0
	// Compare register value with RDAYCNT counter value
	RTC_RDAYAR_ENB_1 = 0x1

	// RMONAR: Month Alarm Register (in Calendar Count Mode)
	// Position of MON1 field.
	RTC_RMONAR_MON1_Pos = 0x0
	// Bit mask of MON1 field.
	RTC_RMONAR_MON1_Msk = 0xf
	// Position of MON10 field.
	RTC_RMONAR_MON10_Pos = 0x4
	// Bit mask of MON10 field.
	RTC_RMONAR_MON10_Msk = 0x10
	// Bit MON10.
	RTC_RMONAR_MON10 = 0x10
	// Position of ENB field.
	RTC_RMONAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RMONAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RMONAR_ENB = 0x80
	// Do not compare register value with RMONCNT counter value
	RTC_RMONAR_ENB_0 = 0x0
	// Compare register value with RMONCNT counter value
	RTC_RMONAR_ENB_1 = 0x1

	// BCNT2AER: Binary Counter 2 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT2AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT2AER_ENB_Msk = 0xff

	// RYRAR: Year Alarm Register (in Calendar Count Mode)
	// Position of YR1 field.
	RTC_RYRAR_YR1_Pos = 0x0
	// Bit mask of YR1 field.
	RTC_RYRAR_YR1_Msk = 0xf
	// Position of YR10 field.
	RTC_RYRAR_YR10_Pos = 0x4
	// Bit mask of YR10 field.
	RTC_RYRAR_YR10_Msk = 0xf0

	// BCNT3AER: Binary Counter 3 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT3AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT3AER_ENB_Msk = 0xff

	// RYRAREN: Year Alarm Enable Register (in Calendar Count Mode)
	// Position of ENB field.
	RTC_RYRAREN_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RYRAREN_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RYRAREN_ENB = 0x80
	// Do not compare register value with the RYRCNT counter value
	RTC_RYRAREN_ENB_0 = 0x0
	// Compare register value with the RYRCNT counter value
	RTC_RYRAREN_ENB_1 = 0x1

	// RCR1: RTC Control Register 1
	// Position of AIE field.
	RTC_RCR1_AIE_Pos = 0x0
	// Bit mask of AIE field.
	RTC_RCR1_AIE_Msk = 0x1
	// Bit AIE.
	RTC_RCR1_AIE = 0x1
	// Disable alarm interrupt requests
	RTC_RCR1_AIE_0 = 0x0
	// Enable alarm interrupt requests
	RTC_RCR1_AIE_1 = 0x1
	// Position of CIE field.
	RTC_RCR1_CIE_Pos = 0x1
	// Bit mask of CIE field.
	RTC_RCR1_CIE_Msk = 0x2
	// Bit CIE.
	RTC_RCR1_CIE = 0x2
	// Disable carry interrupt requests
	RTC_RCR1_CIE_0 = 0x0
	// Enable carry interrupt requests
	RTC_RCR1_CIE_1 = 0x1
	// Position of PIE field.
	RTC_RCR1_PIE_Pos = 0x2
	// Bit mask of PIE field.
	RTC_RCR1_PIE_Msk = 0x4
	// Bit PIE.
	RTC_RCR1_PIE = 0x4
	// Disable periodic interrupt requests
	RTC_RCR1_PIE_0 = 0x0
	// Enable periodic interrupt requests
	RTC_RCR1_PIE_1 = 0x1
	// Position of RTCOS field.
	RTC_RCR1_RTCOS_Pos = 0x3
	// Bit mask of RTCOS field.
	RTC_RCR1_RTCOS_Msk = 0x8
	// Bit RTCOS.
	RTC_RCR1_RTCOS = 0x8
	// Outputs 1 Hz on RTCOUT
	RTC_RCR1_RTCOS_0 = 0x0
	// Outputs 64 Hz RTCOUT
	RTC_RCR1_RTCOS_1 = 0x1
	// Position of PES field.
	RTC_RCR1_PES_Pos = 0x4
	// Bit mask of PES field.
	RTC_RCR1_PES_Msk = 0xf0
	// Generate periodic interrupt every 1/256 second
	RTC_RCR1_PES_0x6 = 0x6
	// Generate periodic interrupt every 1/128 second
	RTC_RCR1_PES_0x7 = 0x7
	// Generate periodic interrupt every 1/64 second
	RTC_RCR1_PES_0x8 = 0x8
	// Generate periodic interrupt every 1/32 second
	RTC_RCR1_PES_0x9 = 0x9
	// Generate periodic interrupt every 1/16 second
	RTC_RCR1_PES_0xA = 0xa
	// Generate periodic interrupt every 1/8 second
	RTC_RCR1_PES_0xB = 0xb
	// Generate periodic interrupt every 1/4 second
	RTC_RCR1_PES_0xC = 0xc
	// Generate periodic interrupt every 1/2 second
	RTC_RCR1_PES_0xD = 0xd
	// Generate periodic interrupt every 1 second
	RTC_RCR1_PES_0xE = 0xe
	// Generate periodic interrupt every 2 seconds
	RTC_RCR1_PES_0xF = 0xf

	// RCR2: RTC Control Register 2 (in Calendar Count Mode)
	// Position of START field.
	RTC_RCR2_START_Pos = 0x0
	// Bit mask of START field.
	RTC_RCR2_START_Msk = 0x1
	// Bit START.
	RTC_RCR2_START = 0x1
	// Stop prescaler and time counter
	RTC_RCR2_START_0 = 0x0
	// Operate prescaler and time counter normally
	RTC_RCR2_START_1 = 0x1
	// Position of RESET field.
	RTC_RCR2_RESET_Pos = 0x1
	// Bit mask of RESET field.
	RTC_RCR2_RESET_Msk = 0x2
	// Bit RESET.
	RTC_RCR2_RESET = 0x2
	// In writing: Invalid (writing 0 has no effect). In reading: Normal time operation in progress, or an RTC software reset has completed.
	RTC_RCR2_RESET_0 = 0x0
	// In writing: Initialize the prescaler and target registers for RTC software reset. In reading: RTC software reset in progress.
	RTC_RCR2_RESET_1 = 0x1
	// Position of ADJ30 field.
	RTC_RCR2_ADJ30_Pos = 0x2
	// Bit mask of ADJ30 field.
	RTC_RCR2_ADJ30_Msk = 0x4
	// Bit ADJ30.
	RTC_RCR2_ADJ30 = 0x4
	// In writing: Invalid (writing 0 has no effect). In reading: Normal time operation in progress, or 30-second adjustment has completed.
	RTC_RCR2_ADJ30_0 = 0x0
	// In writing: Execute 30-second adjustment. In reading: 30-second adjustment in progress.
	RTC_RCR2_ADJ30_1 = 0x1
	// Position of RTCOE field.
	RTC_RCR2_RTCOE_Pos = 0x3
	// Bit mask of RTCOE field.
	RTC_RCR2_RTCOE_Msk = 0x8
	// Bit RTCOE.
	RTC_RCR2_RTCOE = 0x8
	// Disable RTCOUT output
	RTC_RCR2_RTCOE_0 = 0x0
	// Enable RTCOUT output
	RTC_RCR2_RTCOE_1 = 0x1
	// Position of AADJE field.
	RTC_RCR2_AADJE_Pos = 0x4
	// Bit mask of AADJE field.
	RTC_RCR2_AADJE_Msk = 0x10
	// Bit AADJE.
	RTC_RCR2_AADJE = 0x10
	// Disable automatic adjustment
	RTC_RCR2_AADJE_0 = 0x0
	// Enable automatic adjustment
	RTC_RCR2_AADJE_1 = 0x1
	// Position of AADJP field.
	RTC_RCR2_AADJP_Pos = 0x5
	// Bit mask of AADJP field.
	RTC_RCR2_AADJP_Msk = 0x20
	// Bit AADJP.
	RTC_RCR2_AADJP = 0x20
	// The RADJ.ADJ[5:0] setting from the count value of the prescaler every minute.
	RTC_RCR2_AADJP_0 = 0x0
	// The RADJ.ADJ[5:0] setting value is adjusted from the coun tvalue of the prescaler every 10 seconds.
	RTC_RCR2_AADJP_1 = 0x1
	// Position of HR24 field.
	RTC_RCR2_HR24_Pos = 0x6
	// Bit mask of HR24 field.
	RTC_RCR2_HR24_Msk = 0x40
	// Bit HR24.
	RTC_RCR2_HR24 = 0x40
	// Operate RTC in 12-hour mode
	RTC_RCR2_HR24_0 = 0x0
	// Operate RTC in 24-hour mode
	RTC_RCR2_HR24_1 = 0x1
	// Position of CNTMD field.
	RTC_RCR2_CNTMD_Pos = 0x7
	// Bit mask of CNTMD field.
	RTC_RCR2_CNTMD_Msk = 0x80
	// Bit CNTMD.
	RTC_RCR2_CNTMD = 0x80
	// Calendar count mode
	RTC_RCR2_CNTMD_0 = 0x0
	// Binary count mode
	RTC_RCR2_CNTMD_1 = 0x1

	// RCR2_BCNT: RTC Control Register 2 (in Binary Count Mode)
	// Position of START field.
	RTC_RCR2_BCNT_START_Pos = 0x0
	// Bit mask of START field.
	RTC_RCR2_BCNT_START_Msk = 0x1
	// Bit START.
	RTC_RCR2_BCNT_START = 0x1
	// Stop the 32-bit binary counter, 64-Hz counter, and prescaler
	RTC_RCR2_BCNT_START_0 = 0x0
	// Operate the 32-bit binary counter, 64-Hz counter, and prescaler normally
	RTC_RCR2_BCNT_START_1 = 0x1
	// Position of RESET field.
	RTC_RCR2_BCNT_RESET_Pos = 0x1
	// Bit mask of RESET field.
	RTC_RCR2_BCNT_RESET_Msk = 0x2
	// Bit RESET.
	RTC_RCR2_BCNT_RESET = 0x2
	// In writing: Invalid (writing 0 has no effect). In reading: Normal time operation in progress, or an RTC software reset has completed.
	RTC_RCR2_BCNT_RESET_0 = 0x0
	// In writing: Initialize the prescaler and target registers for RTC software reset. In reading: RTC software reset in progress.
	RTC_RCR2_BCNT_RESET_1 = 0x1
	// Position of RTCOE field.
	RTC_RCR2_BCNT_RTCOE_Pos = 0x3
	// Bit mask of RTCOE field.
	RTC_RCR2_BCNT_RTCOE_Msk = 0x8
	// Bit RTCOE.
	RTC_RCR2_BCNT_RTCOE = 0x8
	// Disable RTCOUT output
	RTC_RCR2_BCNT_RTCOE_0 = 0x0
	// Enable RTCOUT output
	RTC_RCR2_BCNT_RTCOE_1 = 0x1
	// Position of AADJE field.
	RTC_RCR2_BCNT_AADJE_Pos = 0x4
	// Bit mask of AADJE field.
	RTC_RCR2_BCNT_AADJE_Msk = 0x10
	// Bit AADJE.
	RTC_RCR2_BCNT_AADJE = 0x10
	// Disable automatic adjustment
	RTC_RCR2_BCNT_AADJE_0 = 0x0
	// Enable automatic adjustment
	RTC_RCR2_BCNT_AADJE_1 = 0x1
	// Position of AADJP field.
	RTC_RCR2_BCNT_AADJP_Pos = 0x5
	// Bit mask of AADJP field.
	RTC_RCR2_BCNT_AADJP_Msk = 0x20
	// Bit AADJP.
	RTC_RCR2_BCNT_AADJP = 0x20
	// Add or subtract RADJ.ADJ [5:0] bits from prescaler count value every 32 seconds
	RTC_RCR2_BCNT_AADJP_0 = 0x0
	// Add or subtract RADJ.ADJ [5:0] bits from prescaler countvalue every 8 seconds.
	RTC_RCR2_BCNT_AADJP_1 = 0x1
	// Position of CNTMD field.
	RTC_RCR2_BCNT_CNTMD_Pos = 0x7
	// Bit mask of CNTMD field.
	RTC_RCR2_BCNT_CNTMD_Msk = 0x80
	// Bit CNTMD.
	RTC_RCR2_BCNT_CNTMD = 0x80
	// Calendar count mode
	RTC_RCR2_BCNT_CNTMD_0 = 0x0
	// Binary count mode
	RTC_RCR2_BCNT_CNTMD_1 = 0x1

	// RCR4: RTC Control Register 4
	// Position of RCKSEL field.
	RTC_RCR4_RCKSEL_Pos = 0x0
	// Bit mask of RCKSEL field.
	RTC_RCR4_RCKSEL_Msk = 0x1
	// Bit RCKSEL.
	RTC_RCR4_RCKSEL = 0x1
	// Sub-clock oscillator is selected
	RTC_RCR4_RCKSEL_0 = 0x0
	// LOCO is selected
	RTC_RCR4_RCKSEL_1 = 0x1

	// RFRH: Frequency Register H
	// Position of RFC16 field.
	RTC_RFRH_RFC16_Pos = 0x0
	// Bit mask of RFC16 field.
	RTC_RFRH_RFC16_Msk = 0x1
	// Bit RFC16.
	RTC_RFRH_RFC16 = 0x1

	// RFRL: Frequency Register L
	// Position of RFC field.
	RTC_RFRL_RFC_Pos = 0x0
	// Bit mask of RFC field.
	RTC_RFRL_RFC_Msk = 0xffff

	// RADJ: Time Error Adjustment Register
	// Position of ADJ field.
	RTC_RADJ_ADJ_Pos = 0x0
	// Bit mask of ADJ field.
	RTC_RADJ_ADJ_Msk = 0x3f
	// Position of PMADJ field.
	RTC_RADJ_PMADJ_Pos = 0x6
	// Bit mask of PMADJ field.
	RTC_RADJ_PMADJ_Msk = 0xc0
	// Do not perform adjustment.
	RTC_RADJ_PMADJ_00 = 0x0
	// Adjustment is performed by the addition to the prescaler
	RTC_RADJ_PMADJ_01 = 0x1
	// Adjustment is performed by the subtraction from the prescaler
	RTC_RADJ_PMADJ_10 = 0x2
	// Setting prohibited.
	RTC_RADJ_PMADJ_11 = 0x3

	// RTCCR0: Time Capture Control Register %s
	// Position of TCCT field.
	RTC_RTCCR_TCCT_Pos = 0x0
	// Bit mask of TCCT field.
	RTC_RTCCR_TCCT_Msk = 0x3
	// Do not detect events
	RTC_RTCCR_TCCT_00 = 0x0
	// Detect rising edge
	RTC_RTCCR_TCCT_01 = 0x1
	// Detect falling edge
	RTC_RTCCR_TCCT_10 = 0x2
	// Detect both edges
	RTC_RTCCR_TCCT_11 = 0x3
	// Position of TCST field.
	RTC_RTCCR_TCST_Pos = 0x2
	// Bit mask of TCST field.
	RTC_RTCCR_TCST_Msk = 0x4
	// Bit TCST.
	RTC_RTCCR_TCST = 0x4
	// No event detected
	RTC_RTCCR_TCST_0 = 0x0
	// Event detected
	RTC_RTCCR_TCST_1 = 0x1
	// Position of TCNF field.
	RTC_RTCCR_TCNF_Pos = 0x4
	// Bit mask of TCNF field.
	RTC_RTCCR_TCNF_Msk = 0x30
	// Turn noise filter off
	RTC_RTCCR_TCNF_00 = 0x0
	// Setting prohibited
	RTC_RTCCR_TCNF_01 = 0x1
	// Turn noise filter on (count source)
	RTC_RTCCR_TCNF_10 = 0x2
	// Turn noise filter on (count source by divided by 32)
	RTC_RTCCR_TCNF_11 = 0x3
	// Position of TCEN field.
	RTC_RTCCR_TCEN_Pos = 0x7
	// Bit mask of TCEN field.
	RTC_RTCCR_TCEN_Msk = 0x80
	// Bit TCEN.
	RTC_RTCCR_TCEN = 0x80
	// Disable the RTCICn pin as the time capture event input pin
	RTC_RTCCR_TCEN_0 = 0x0
	// Enable the RTCICn pin as the time capture event input pin
	RTC_RTCCR_TCEN_1 = 0x1

	// RSECCP0: Second Capture Register %s
	// Position of SEC1 field.
	RTC_RSECCP_SEC1_Pos = 0x0
	// Bit mask of SEC1 field.
	RTC_RSECCP_SEC1_Msk = 0xf
	// Position of SEC10 field.
	RTC_RSECCP_SEC10_Pos = 0x4
	// Bit mask of SEC10 field.
	RTC_RSECCP_SEC10_Msk = 0x70

	// RMINCP0: Minute Capture Register %s
	// Position of MIN1 field.
	RTC_RMINCP_MIN1_Pos = 0x0
	// Bit mask of MIN1 field.
	RTC_RMINCP_MIN1_Msk = 0xf
	// Position of MIN10 field.
	RTC_RMINCP_MIN10_Pos = 0x4
	// Bit mask of MIN10 field.
	RTC_RMINCP_MIN10_Msk = 0x70

	// RHRCP0: Hour Capture Register %s
	// Position of HR1 field.
	RTC_RHRCP_HR1_Pos = 0x0
	// Bit mask of HR1 field.
	RTC_RHRCP_HR1_Msk = 0xf
	// Position of HR10 field.
	RTC_RHRCP_HR10_Pos = 0x4
	// Bit mask of HR10 field.
	RTC_RHRCP_HR10_Msk = 0x30
	// Position of PM field.
	RTC_RHRCP_PM_Pos = 0x6
	// Bit mask of PM field.
	RTC_RHRCP_PM_Msk = 0x40
	// Bit PM.
	RTC_RHRCP_PM = 0x40
	// AM
	RTC_RHRCP_PM_0 = 0x0
	// PM
	RTC_RHRCP_PM_1 = 0x1

	// RDAYCP0: Date Capture Register %s
	// Position of DATE1 field.
	RTC_RDAYCP_DATE1_Pos = 0x0
	// Bit mask of DATE1 field.
	RTC_RDAYCP_DATE1_Msk = 0xf
	// Position of DATE10 field.
	RTC_RDAYCP_DATE10_Pos = 0x4
	// Bit mask of DATE10 field.
	RTC_RDAYCP_DATE10_Msk = 0x30

	// RMONCP0: Month Capture Register %s
	// Position of MON1 field.
	RTC_RMONCP_MON1_Pos = 0x0
	// Bit mask of MON1 field.
	RTC_RMONCP_MON1_Msk = 0xf
	// Position of MON10 field.
	RTC_RMONCP_MON10_Pos = 0x4
	// Bit mask of MON10 field.
	RTC_RMONCP_MON10_Msk = 0x10
	// Bit MON10.
	RTC_RMONCP_MON10 = 0x10
)

// Constants for IWDT: Independent Watchdog Timer
const (
	// IWDTSR: IWDT Status Register
	// Position of CNTVAL field.
	IWDT_IWDTSR_CNTVAL_Pos = 0x0
	// Bit mask of CNTVAL field.
	IWDT_IWDTSR_CNTVAL_Msk = 0x3fff
	// Position of UNDFF field.
	IWDT_IWDTSR_UNDFF_Pos = 0xe
	// Bit mask of UNDFF field.
	IWDT_IWDTSR_UNDFF_Msk = 0x4000
	// Bit UNDFF.
	IWDT_IWDTSR_UNDFF = 0x4000
	// No underflow occurred
	IWDT_IWDTSR_UNDFF_0 = 0x0
	// Underflow occurred
	IWDT_IWDTSR_UNDFF_1 = 0x1
	// Position of REFEF field.
	IWDT_IWDTSR_REFEF_Pos = 0xf
	// Bit mask of REFEF field.
	IWDT_IWDTSR_REFEF_Msk = 0x8000
	// Bit REFEF.
	IWDT_IWDTSR_REFEF = 0x8000
	// No refresh error occurred
	IWDT_IWDTSR_REFEF_0 = 0x0
	// Refresh error occurred
	IWDT_IWDTSR_REFEF_1 = 0x1
)

// Constants for WDT: Watchdog Timer
const (
	// WDTCR: WDT Control Register
	// Position of TOPS field.
	WDT_WDTCR_TOPS_Pos = 0x0
	// Bit mask of TOPS field.
	WDT_WDTCR_TOPS_Msk = 0x3
	// 1024 cycles (0x03FF)
	WDT_WDTCR_TOPS_00 = 0x0
	// 4096 cycles (0x0FFF)
	WDT_WDTCR_TOPS_01 = 0x1
	// 8192 cycles (0x1FFF)
	WDT_WDTCR_TOPS_10 = 0x2
	// 16384 cycles (0x3FFF)
	WDT_WDTCR_TOPS_11 = 0x3
	// Position of CKS field.
	WDT_WDTCR_CKS_Pos = 0x4
	// Bit mask of CKS field.
	WDT_WDTCR_CKS_Msk = 0xf0
	// PCLKB/4
	WDT_WDTCR_CKS_0x1 = 0x1
	// PCLKB/64
	WDT_WDTCR_CKS_0x4 = 0x4
	// PCLKB/128
	WDT_WDTCR_CKS_0xF = 0xf
	// PCLKB/512
	WDT_WDTCR_CKS_0x6 = 0x6
	// PCLKB/2048
	WDT_WDTCR_CKS_0x7 = 0x7
	// PCLKB/8192
	WDT_WDTCR_CKS_0x8 = 0x8
	// Position of RPES field.
	WDT_WDTCR_RPES_Pos = 0x8
	// Bit mask of RPES field.
	WDT_WDTCR_RPES_Msk = 0x300
	// 75%
	WDT_WDTCR_RPES_00 = 0x0
	// 50%
	WDT_WDTCR_RPES_01 = 0x1
	// 25%
	WDT_WDTCR_RPES_10 = 0x2
	// 0% (do not specify window end position).
	WDT_WDTCR_RPES_11 = 0x3
	// Position of RPSS field.
	WDT_WDTCR_RPSS_Pos = 0xc
	// Bit mask of RPSS field.
	WDT_WDTCR_RPSS_Msk = 0x3000
	// 25%
	WDT_WDTCR_RPSS_00 = 0x0
	// 50%
	WDT_WDTCR_RPSS_01 = 0x1
	// 75%
	WDT_WDTCR_RPSS_10 = 0x2
	// 100% (do not specify window start position).
	WDT_WDTCR_RPSS_11 = 0x3

	// WDTSR: WDT Status Register
	// Position of CNTVAL field.
	WDT_WDTSR_CNTVAL_Pos = 0x0
	// Bit mask of CNTVAL field.
	WDT_WDTSR_CNTVAL_Msk = 0x3fff
	// Position of UNDFF field.
	WDT_WDTSR_UNDFF_Pos = 0xe
	// Bit mask of UNDFF field.
	WDT_WDTSR_UNDFF_Msk = 0x4000
	// Bit UNDFF.
	WDT_WDTSR_UNDFF = 0x4000
	// No underflow occurred
	WDT_WDTSR_UNDFF_0 = 0x0
	// Underflow occurred
	WDT_WDTSR_UNDFF_1 = 0x1
	// Position of REFEF field.
	WDT_WDTSR_REFEF_Pos = 0xf
	// Bit mask of REFEF field.
	WDT_WDTSR_REFEF_Msk = 0x8000
	// Bit REFEF.
	WDT_WDTSR_REFEF = 0x8000
	// No refresh error occurred
	WDT_WDTSR_REFEF_0 = 0x0
	// Refresh error occurred
	WDT_WDTSR_REFEF_1 = 0x1

	// WDTRCR: WDT Reset Control Register
	// Position of RSTIRQS field.
	WDT_WDTRCR_RSTIRQS_Pos = 0x7
	// Bit mask of RSTIRQS field.
	WDT_WDTRCR_RSTIRQS_Msk = 0x80
	// Bit RSTIRQS.
	WDT_WDTRCR_RSTIRQS = 0x80
	// Enable non-maskable interrupt request or interrupt request output
	WDT_WDTRCR_RSTIRQS_0 = 0x0
	// Enable reset output
	WDT_WDTRCR_RSTIRQS_1 = 0x1

	// WDTCSTPR: WDT Count Stop Control Register
	// Position of SLCSTP field.
	WDT_WDTCSTPR_SLCSTP_Pos = 0x7
	// Bit mask of SLCSTP field.
	WDT_WDTCSTPR_SLCSTP_Msk = 0x80
	// Bit SLCSTP.
	WDT_WDTCSTPR_SLCSTP = 0x80
	// Disable count stop
	WDT_WDTCSTPR_SLCSTP_0 = 0x0
	// Stop count on transition to Sleep mode
	WDT_WDTCSTPR_SLCSTP_1 = 0x1
)

// Constants for CAC: Clock Frequency Accuracy Measurement Circuit
const (
	// CACR0: CAC Control Register 0
	// Position of CFME field.
	CAC_CACR0_CFME_Pos = 0x0
	// Bit mask of CFME field.
	CAC_CACR0_CFME_Msk = 0x1
	// Bit CFME.
	CAC_CACR0_CFME = 0x1
	// Disable
	CAC_CACR0_CFME_0 = 0x0
	// Enable
	CAC_CACR0_CFME_1 = 0x1

	// CACR1: CAC Control Register 1
	// Position of CACREFE field.
	CAC_CACR1_CACREFE_Pos = 0x0
	// Bit mask of CACREFE field.
	CAC_CACR1_CACREFE_Msk = 0x1
	// Bit CACREFE.
	CAC_CACR1_CACREFE = 0x1
	// Disable
	CAC_CACR1_CACREFE_0 = 0x0
	// Enable
	CAC_CACR1_CACREFE_1 = 0x1
	// Position of FMCS field.
	CAC_CACR1_FMCS_Pos = 0x1
	// Bit mask of FMCS field.
	CAC_CACR1_FMCS_Msk = 0xe
	// Main clock oscillator
	CAC_CACR1_FMCS_000 = 0x0
	// Sub-clock oscillator
	CAC_CACR1_FMCS_001 = 0x1
	// HOCO clock
	CAC_CACR1_FMCS_010 = 0x2
	// MOCO clock
	CAC_CACR1_FMCS_011 = 0x3
	// LOCO clock
	CAC_CACR1_FMCS_100 = 0x4
	// Peripheral module clock B (PCLKB)
	CAC_CACR1_FMCS_101 = 0x5
	// IWDT-dedicated clock
	CAC_CACR1_FMCS_110 = 0x6
	// Setting prohibited
	CAC_CACR1_FMCS_111 = 0x7
	// Position of TCSS field.
	CAC_CACR1_TCSS_Pos = 0x4
	// Bit mask of TCSS field.
	CAC_CACR1_TCSS_Msk = 0x30
	// No division
	CAC_CACR1_TCSS_00 = 0x0
	// x 1/4 clock
	CAC_CACR1_TCSS_01 = 0x1
	// x 1/8 clock
	CAC_CACR1_TCSS_10 = 0x2
	// x 1/32 clock
	CAC_CACR1_TCSS_11 = 0x3
	// Position of EDGES field.
	CAC_CACR1_EDGES_Pos = 0x6
	// Bit mask of EDGES field.
	CAC_CACR1_EDGES_Msk = 0xc0
	// Rising edge
	CAC_CACR1_EDGES_00 = 0x0
	// Falling edge
	CAC_CACR1_EDGES_01 = 0x1
	// Both rising and falling edges
	CAC_CACR1_EDGES_10 = 0x2
	// Setting prohibited
	CAC_CACR1_EDGES_11 = 0x3

	// CACR2: CAC Control Register 2
	// Position of RPS field.
	CAC_CACR2_RPS_Pos = 0x0
	// Bit mask of RPS field.
	CAC_CACR2_RPS_Msk = 0x1
	// Bit RPS.
	CAC_CACR2_RPS = 0x1
	// CACREF pin input
	CAC_CACR2_RPS_0 = 0x0
	// Internal clock (internally generated signal)
	CAC_CACR2_RPS_1 = 0x1
	// Position of RSCS field.
	CAC_CACR2_RSCS_Pos = 0x1
	// Bit mask of RSCS field.
	CAC_CACR2_RSCS_Msk = 0xe
	// Main clock oscillator
	CAC_CACR2_RSCS_000 = 0x0
	// Sub-clock oscillator
	CAC_CACR2_RSCS_001 = 0x1
	// HOCO clock
	CAC_CACR2_RSCS_010 = 0x2
	// MOCO clock
	CAC_CACR2_RSCS_011 = 0x3
	// LOCO clock
	CAC_CACR2_RSCS_100 = 0x4
	// Peripheral module clock B (PCLKB)
	CAC_CACR2_RSCS_101 = 0x5
	// IWDT-dedicated clock
	CAC_CACR2_RSCS_110 = 0x6
	// Setting prohibited
	CAC_CACR2_RSCS_111 = 0x7
	// Position of RCDS field.
	CAC_CACR2_RCDS_Pos = 0x4
	// Bit mask of RCDS field.
	CAC_CACR2_RCDS_Msk = 0x30
	// x 1/32 clock
	CAC_CACR2_RCDS_00 = 0x0
	// x 1/128 clock
	CAC_CACR2_RCDS_01 = 0x1
	// x 1/1024 clock
	CAC_CACR2_RCDS_10 = 0x2
	// x 1/8192 clock
	CAC_CACR2_RCDS_11 = 0x3
	// Position of DFS field.
	CAC_CACR2_DFS_Pos = 0x6
	// Bit mask of DFS field.
	CAC_CACR2_DFS_Msk = 0xc0
	// Disable digital filtering
	CAC_CACR2_DFS_00 = 0x0
	// Use sampling clock for the digital filter as the frequency measuring clock
	CAC_CACR2_DFS_01 = 0x1
	// Use sampling clock for the digital filter as the frequency measuring clock divided by 4
	CAC_CACR2_DFS_10 = 0x2
	// Use sampling clock for the digital filter as the frequency measuring clock divided by 16.
	CAC_CACR2_DFS_11 = 0x3

	// CAICR: CAC Interrupt Control Register
	// Position of FERRIE field.
	CAC_CAICR_FERRIE_Pos = 0x0
	// Bit mask of FERRIE field.
	CAC_CAICR_FERRIE_Msk = 0x1
	// Bit FERRIE.
	CAC_CAICR_FERRIE = 0x1
	// Disable
	CAC_CAICR_FERRIE_0 = 0x0
	// Enable
	CAC_CAICR_FERRIE_1 = 0x1
	// Position of MENDIE field.
	CAC_CAICR_MENDIE_Pos = 0x1
	// Bit mask of MENDIE field.
	CAC_CAICR_MENDIE_Msk = 0x2
	// Bit MENDIE.
	CAC_CAICR_MENDIE = 0x2
	// Disable
	CAC_CAICR_MENDIE_0 = 0x0
	// Enable
	CAC_CAICR_MENDIE_1 = 0x1
	// Position of OVFIE field.
	CAC_CAICR_OVFIE_Pos = 0x2
	// Bit mask of OVFIE field.
	CAC_CAICR_OVFIE_Msk = 0x4
	// Bit OVFIE.
	CAC_CAICR_OVFIE = 0x4
	// Disable
	CAC_CAICR_OVFIE_0 = 0x0
	// Enable
	CAC_CAICR_OVFIE_1 = 0x1
	// Position of FERRFCL field.
	CAC_CAICR_FERRFCL_Pos = 0x4
	// Bit mask of FERRFCL field.
	CAC_CAICR_FERRFCL_Msk = 0x10
	// Bit FERRFCL.
	CAC_CAICR_FERRFCL = 0x10
	// No effect
	CAC_CAICR_FERRFCL_0 = 0x0
	// The CASTR.FERRF flag is cleared
	CAC_CAICR_FERRFCL_1 = 0x1
	// Position of MENDFCL field.
	CAC_CAICR_MENDFCL_Pos = 0x5
	// Bit mask of MENDFCL field.
	CAC_CAICR_MENDFCL_Msk = 0x20
	// Bit MENDFCL.
	CAC_CAICR_MENDFCL = 0x20
	// No effect
	CAC_CAICR_MENDFCL_0 = 0x0
	// The CASTR.MENDF flag is cleared
	CAC_CAICR_MENDFCL_1 = 0x1
	// Position of OVFFCL field.
	CAC_CAICR_OVFFCL_Pos = 0x6
	// Bit mask of OVFFCL field.
	CAC_CAICR_OVFFCL_Msk = 0x40
	// Bit OVFFCL.
	CAC_CAICR_OVFFCL = 0x40
	// No effect
	CAC_CAICR_OVFFCL_0 = 0x0
	// The CASTR.OVFF flag is cleared.
	CAC_CAICR_OVFFCL_1 = 0x1

	// CASTR: CAC Status Register
	// Position of FERRF field.
	CAC_CASTR_FERRF_Pos = 0x0
	// Bit mask of FERRF field.
	CAC_CASTR_FERRF_Msk = 0x1
	// Bit FERRF.
	CAC_CASTR_FERRF = 0x1
	// Clock frequency is within the allowable range
	CAC_CASTR_FERRF_0 = 0x0
	// Clock frequency has deviated beyond the allowable range (frequency error).
	CAC_CASTR_FERRF_1 = 0x1
	// Position of MENDF field.
	CAC_CASTR_MENDF_Pos = 0x1
	// Bit mask of MENDF field.
	CAC_CASTR_MENDF_Msk = 0x2
	// Bit MENDF.
	CAC_CASTR_MENDF = 0x2
	// Measurement is in progress
	CAC_CASTR_MENDF_0 = 0x0
	// Measurement ended
	CAC_CASTR_MENDF_1 = 0x1
	// Position of OVFF field.
	CAC_CASTR_OVFF_Pos = 0x2
	// Bit mask of OVFF field.
	CAC_CASTR_OVFF_Msk = 0x4
	// Bit OVFF.
	CAC_CASTR_OVFF = 0x4
	// Counter has not overflowed
	CAC_CASTR_OVFF_0 = 0x0
	// Counter overflowed
	CAC_CASTR_OVFF_1 = 0x1
)

// Constants for MSTP: Module Stop Control
const (
	// MSTPCRA: Module Stop Control Register A
	// Position of MSTPA0 field.
	MSTP_MSTPCRA_MSTPA0_Pos = 0x0
	// Bit mask of MSTPA0 field.
	MSTP_MSTPCRA_MSTPA0_Msk = 0x1
	// Bit MSTPA0.
	MSTP_MSTPCRA_MSTPA0 = 0x1
	// Cancel the module-stop state
	MSTP_MSTPCRA_MSTPA0_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRA_MSTPA0_1 = 0x1
	// Position of MSTPA7 field.
	MSTP_MSTPCRA_MSTPA7_Pos = 0x7
	// Bit mask of MSTPA7 field.
	MSTP_MSTPCRA_MSTPA7_Msk = 0x80
	// Bit MSTPA7.
	MSTP_MSTPCRA_MSTPA7 = 0x80
	// Cancel the module-stop state
	MSTP_MSTPCRA_MSTPA7_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRA_MSTPA7_1 = 0x1
	// Position of MSTPA22 field.
	MSTP_MSTPCRA_MSTPA22_Pos = 0x16
	// Bit mask of MSTPA22 field.
	MSTP_MSTPCRA_MSTPA22_Msk = 0x400000
	// Bit MSTPA22.
	MSTP_MSTPCRA_MSTPA22 = 0x400000
	// Cancel the module-stop state
	MSTP_MSTPCRA_MSTPA22_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRA_MSTPA22_1 = 0x1

	// MSTPCRB: Module Stop Control Register B
	// Position of MSTPB2 field.
	MSTP_MSTPCRB_MSTPB2_Pos = 0x2
	// Bit mask of MSTPB2 field.
	MSTP_MSTPCRB_MSTPB2_Msk = 0x4
	// Bit MSTPB2.
	MSTP_MSTPCRB_MSTPB2 = 0x4
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB2_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB2_1 = 0x1
	// Position of MSTPB6 field.
	MSTP_MSTPCRB_MSTPB6_Pos = 0x6
	// Bit mask of MSTPB6 field.
	MSTP_MSTPCRB_MSTPB6_Msk = 0x40
	// Bit MSTPB6.
	MSTP_MSTPCRB_MSTPB6 = 0x40
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB6_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB6_1 = 0x1
	// Position of MSTPB8 field.
	MSTP_MSTPCRB_MSTPB8_Pos = 0x8
	// Bit mask of MSTPB8 field.
	MSTP_MSTPCRB_MSTPB8_Msk = 0x100
	// Bit MSTPB8.
	MSTP_MSTPCRB_MSTPB8 = 0x100
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB8_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB8_1 = 0x1
	// Position of MSTPB9 field.
	MSTP_MSTPCRB_MSTPB9_Pos = 0x9
	// Bit mask of MSTPB9 field.
	MSTP_MSTPCRB_MSTPB9_Msk = 0x200
	// Bit MSTPB9.
	MSTP_MSTPCRB_MSTPB9 = 0x200
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB9_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB9_1 = 0x1
	// Position of MSTPB11 field.
	MSTP_MSTPCRB_MSTPB11_Pos = 0xb
	// Bit mask of MSTPB11 field.
	MSTP_MSTPCRB_MSTPB11_Msk = 0x800
	// Bit MSTPB11.
	MSTP_MSTPCRB_MSTPB11 = 0x800
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB11_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB11_1 = 0x1
	// Position of MSTPB15 field.
	MSTP_MSTPCRB_MSTPB15_Pos = 0xf
	// Bit mask of MSTPB15 field.
	MSTP_MSTPCRB_MSTPB15_Msk = 0x8000
	// Bit MSTPB15.
	MSTP_MSTPCRB_MSTPB15 = 0x8000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB15_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB15_1 = 0x1
	// Position of MSTPB18 field.
	MSTP_MSTPCRB_MSTPB18_Pos = 0x12
	// Bit mask of MSTPB18 field.
	MSTP_MSTPCRB_MSTPB18_Msk = 0x40000
	// Bit MSTPB18.
	MSTP_MSTPCRB_MSTPB18 = 0x40000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB18_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB18_1 = 0x1
	// Position of MSTPB19 field.
	MSTP_MSTPCRB_MSTPB19_Pos = 0x13
	// Bit mask of MSTPB19 field.
	MSTP_MSTPCRB_MSTPB19_Msk = 0x80000
	// Bit MSTPB19.
	MSTP_MSTPCRB_MSTPB19 = 0x80000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB19_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB19_1 = 0x1
	// Position of MSTPB22 field.
	MSTP_MSTPCRB_MSTPB22_Pos = 0x16
	// Bit mask of MSTPB22 field.
	MSTP_MSTPCRB_MSTPB22_Msk = 0x400000
	// Bit MSTPB22.
	MSTP_MSTPCRB_MSTPB22 = 0x400000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB22_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB22_1 = 0x1
	// Position of MSTPB27 field.
	MSTP_MSTPCRB_MSTPB27_Pos = 0x1b
	// Bit mask of MSTPB27 field.
	MSTP_MSTPCRB_MSTPB27_Msk = 0x8000000
	// Bit MSTPB27.
	MSTP_MSTPCRB_MSTPB27 = 0x8000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB27_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB27_1 = 0x1
	// Position of MSTPB28 field.
	MSTP_MSTPCRB_MSTPB28_Pos = 0x1c
	// Bit mask of MSTPB28 field.
	MSTP_MSTPCRB_MSTPB28_Msk = 0x10000000
	// Bit MSTPB28.
	MSTP_MSTPCRB_MSTPB28 = 0x10000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB28_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB28_1 = 0x1
	// Position of MSTPB29 field.
	MSTP_MSTPCRB_MSTPB29_Pos = 0x1d
	// Bit mask of MSTPB29 field.
	MSTP_MSTPCRB_MSTPB29_Msk = 0x20000000
	// Bit MSTPB29.
	MSTP_MSTPCRB_MSTPB29 = 0x20000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB29_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB29_1 = 0x1
	// Position of MSTPB30 field.
	MSTP_MSTPCRB_MSTPB30_Pos = 0x1e
	// Bit mask of MSTPB30 field.
	MSTP_MSTPCRB_MSTPB30_Msk = 0x40000000
	// Bit MSTPB30.
	MSTP_MSTPCRB_MSTPB30 = 0x40000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB30_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB30_1 = 0x1
	// Position of MSTPB31 field.
	MSTP_MSTPCRB_MSTPB31_Pos = 0x1f
	// Bit mask of MSTPB31 field.
	MSTP_MSTPCRB_MSTPB31_Msk = 0x80000000
	// Bit MSTPB31.
	MSTP_MSTPCRB_MSTPB31 = 0x80000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB31_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB31_1 = 0x1

	// MSTPCRC: Module Stop Control Register C
	// Position of MSTPC0 field.
	MSTP_MSTPCRC_MSTPC0_Pos = 0x0
	// Bit mask of MSTPC0 field.
	MSTP_MSTPCRC_MSTPC0_Msk = 0x1
	// Bit MSTPC0.
	MSTP_MSTPCRC_MSTPC0 = 0x1
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC0_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC0_1 = 0x1
	// Position of MSTPC1 field.
	MSTP_MSTPCRC_MSTPC1_Pos = 0x1
	// Bit mask of MSTPC1 field.
	MSTP_MSTPCRC_MSTPC1_Msk = 0x2
	// Bit MSTPC1.
	MSTP_MSTPCRC_MSTPC1 = 0x2
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC1_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC1_1 = 0x1
	// Position of MSTPC8 field.
	MSTP_MSTPCRC_MSTPC8_Pos = 0x8
	// Bit mask of MSTPC8 field.
	MSTP_MSTPCRC_MSTPC8_Msk = 0x100
	// Bit MSTPC8.
	MSTP_MSTPCRC_MSTPC8 = 0x100
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC8_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC8_1 = 0x1
	// Position of MSTPC12 field.
	MSTP_MSTPCRC_MSTPC12_Pos = 0xc
	// Bit mask of MSTPC12 field.
	MSTP_MSTPCRC_MSTPC12_Msk = 0x1000
	// Bit MSTPC12.
	MSTP_MSTPCRC_MSTPC12 = 0x1000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC12_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC12_1 = 0x1
	// Position of MSTPC13 field.
	MSTP_MSTPCRC_MSTPC13_Pos = 0xd
	// Bit mask of MSTPC13 field.
	MSTP_MSTPCRC_MSTPC13_Msk = 0x2000
	// Bit MSTPC13.
	MSTP_MSTPCRC_MSTPC13 = 0x2000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC13_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC13_1 = 0x1
	// Position of MSTPC14 field.
	MSTP_MSTPCRC_MSTPC14_Pos = 0xe
	// Bit mask of MSTPC14 field.
	MSTP_MSTPCRC_MSTPC14_Msk = 0x4000
	// Bit MSTPC14.
	MSTP_MSTPCRC_MSTPC14 = 0x4000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC14_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC14_1 = 0x1
	// Position of MSTPC31 field.
	MSTP_MSTPCRC_MSTPC31_Pos = 0x1f
	// Bit mask of MSTPC31 field.
	MSTP_MSTPCRC_MSTPC31_Msk = 0x80000000
	// Bit MSTPC31.
	MSTP_MSTPCRC_MSTPC31 = 0x80000000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC31_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC31_1 = 0x1

	// MSTPCRD: Module Stop Control Register D
	// Position of MSTPD0 field.
	MSTP_MSTPCRD_MSTPD0_Pos = 0x0
	// Bit mask of MSTPD0 field.
	MSTP_MSTPCRD_MSTPD0_Msk = 0x1
	// Bit MSTPD0.
	MSTP_MSTPCRD_MSTPD0 = 0x1
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD0_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD0_1 = 0x1
	// Position of MSTPD1 field.
	MSTP_MSTPCRD_MSTPD1_Pos = 0x1
	// Bit mask of MSTPD1 field.
	MSTP_MSTPCRD_MSTPD1_Msk = 0x2
	// Bit MSTPD1.
	MSTP_MSTPCRD_MSTPD1 = 0x2
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD1_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD1_1 = 0x1
	// Position of MSTPD2 field.
	MSTP_MSTPCRD_MSTPD2_Pos = 0x2
	// Bit mask of MSTPD2 field.
	MSTP_MSTPCRD_MSTPD2_Msk = 0x4
	// Bit MSTPD2.
	MSTP_MSTPCRD_MSTPD2 = 0x4
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD2_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD2_1 = 0x1
	// Position of MSTPD3 field.
	MSTP_MSTPCRD_MSTPD3_Pos = 0x3
	// Bit mask of MSTPD3 field.
	MSTP_MSTPCRD_MSTPD3_Msk = 0x8
	// Bit MSTPD3.
	MSTP_MSTPCRD_MSTPD3 = 0x8
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD3_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD3_1 = 0x1
	// Position of MSTPD11 field.
	MSTP_MSTPCRD_MSTPD11_Pos = 0xb
	// Bit mask of MSTPD11 field.
	MSTP_MSTPCRD_MSTPD11_Msk = 0x800
	// Bit MSTPD11.
	MSTP_MSTPCRD_MSTPD11 = 0x800
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD11_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD11_1 = 0x1
	// Position of MSTPD12 field.
	MSTP_MSTPCRD_MSTPD12_Pos = 0xc
	// Bit mask of MSTPD12 field.
	MSTP_MSTPCRD_MSTPD12_Msk = 0x1000
	// Bit MSTPD12.
	MSTP_MSTPCRD_MSTPD12 = 0x1000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD12_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD12_1 = 0x1
	// Position of MSTPD13 field.
	MSTP_MSTPCRD_MSTPD13_Pos = 0xd
	// Bit mask of MSTPD13 field.
	MSTP_MSTPCRD_MSTPD13_Msk = 0x2000
	// Bit MSTPD13.
	MSTP_MSTPCRD_MSTPD13 = 0x2000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD13_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD13_1 = 0x1
	// Position of MSTPD14 field.
	MSTP_MSTPCRD_MSTPD14_Pos = 0xe
	// Bit mask of MSTPD14 field.
	MSTP_MSTPCRD_MSTPD14_Msk = 0x4000
	// Bit MSTPD14.
	MSTP_MSTPCRD_MSTPD14 = 0x4000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD14_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD14_1 = 0x1
	// Position of MSTPD16 field.
	MSTP_MSTPCRD_MSTPD16_Pos = 0x10
	// Bit mask of MSTPD16 field.
	MSTP_MSTPCRD_MSTPD16_Msk = 0x10000
	// Bit MSTPD16.
	MSTP_MSTPCRD_MSTPD16 = 0x10000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD16_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD16_1 = 0x1
	// Position of MSTPD20 field.
	MSTP_MSTPCRD_MSTPD20_Pos = 0x14
	// Bit mask of MSTPD20 field.
	MSTP_MSTPCRD_MSTPD20_Msk = 0x100000
	// Bit MSTPD20.
	MSTP_MSTPCRD_MSTPD20 = 0x100000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD20_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD20_1 = 0x1

	// MSTPCRE: Module Stop Control Register E
	// Position of MSTPE14 field.
	MSTP_MSTPCRE_MSTPE14_Pos = 0xe
	// Bit mask of MSTPE14 field.
	MSTP_MSTPCRE_MSTPE14_Msk = 0x4000
	// Bit MSTPE14.
	MSTP_MSTPCRE_MSTPE14 = 0x4000
	// Cancel the module-stop state
	MSTP_MSTPCRE_MSTPE14_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRE_MSTPE14_1 = 0x1
	// Position of MSTPE15 field.
	MSTP_MSTPCRE_MSTPE15_Pos = 0xf
	// Bit mask of MSTPE15 field.
	MSTP_MSTPCRE_MSTPE15_Msk = 0x8000
	// Bit MSTPE15.
	MSTP_MSTPCRE_MSTPE15 = 0x8000
	// Cancel the module-stop state
	MSTP_MSTPCRE_MSTPE15_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRE_MSTPE15_1 = 0x1
	// Position of MSTPE24 field.
	MSTP_MSTPCRE_MSTPE24_Pos = 0x18
	// Bit mask of MSTPE24 field.
	MSTP_MSTPCRE_MSTPE24_Msk = 0x1000000
	// Bit MSTPE24.
	MSTP_MSTPCRE_MSTPE24 = 0x1000000
	// Cancel the module-stop state
	MSTP_MSTPCRE_MSTPE24_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRE_MSTPE24_1 = 0x1
	// Position of MSTPE25 field.
	MSTP_MSTPCRE_MSTPE25_Pos = 0x19
	// Bit mask of MSTPE25 field.
	MSTP_MSTPCRE_MSTPE25_Msk = 0x2000000
	// Bit MSTPE25.
	MSTP_MSTPCRE_MSTPE25 = 0x2000000
	// Cancel the module-stop state
	MSTP_MSTPCRE_MSTPE25_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRE_MSTPE25_1 = 0x1
	// Position of MSTPE26 field.
	MSTP_MSTPCRE_MSTPE26_Pos = 0x1a
	// Bit mask of MSTPE26 field.
	MSTP_MSTPCRE_MSTPE26_Msk = 0x4000000
	// Bit MSTPE26.
	MSTP_MSTPCRE_MSTPE26 = 0x4000000
	// Cancel the module-stop state
	MSTP_MSTPCRE_MSTPE26_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRE_MSTPE26_1 = 0x1
	// Position of MSTPE27 field.
	MSTP_MSTPCRE_MSTPE27_Pos = 0x1b
	// Bit mask of MSTPE27 field.
	MSTP_MSTPCRE_MSTPE27_Msk = 0x8000000
	// Bit MSTPE27.
	MSTP_MSTPCRE_MSTPE27 = 0x8000000
	// Cancel the module-stop state
	MSTP_MSTPCRE_MSTPE27_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRE_MSTPE27_1 = 0x1
	// Position of MSTPE29 field.
	MSTP_MSTPCRE_MSTPE29_Pos = 0x1d
	// Bit mask of MSTPE29 field.
	MSTP_MSTPCRE_MSTPE29_Msk = 0x20000000
	// Bit MSTPE29.
	MSTP_MSTPCRE_MSTPE29 = 0x20000000
	// Cancel the module-stop state
	MSTP_MSTPCRE_MSTPE29_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRE_MSTPE29_1 = 0x1
	// Position of MSTPE30 field.
	MSTP_MSTPCRE_MSTPE30_Pos = 0x1e
	// Bit mask of MSTPE30 field.
	MSTP_MSTPCRE_MSTPE30_Msk = 0x40000000
	// Bit MSTPE30.
	MSTP_MSTPCRE_MSTPE30 = 0x40000000
	// Cancel the module-stop state
	MSTP_MSTPCRE_MSTPE30_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRE_MSTPE30_1 = 0x1
)

// Constants for POEG: Port Output Enable Module for GPT
const (
	// POEGGA: POEG Group A Setting Register
	// Position of PIDF field.
	POEG_POEGGA_PIDF_Pos = 0x0
	// Bit mask of PIDF field.
	POEG_POEGGA_PIDF_Msk = 0x1
	// Bit PIDF.
	POEG_POEGGA_PIDF = 0x1
	// No output-disable request from the GTETRGn pin occurred
	POEG_POEGGA_PIDF_0 = 0x0
	// Output-disable request from the GTETRGn pin occurred.
	POEG_POEGGA_PIDF_1 = 0x1
	// Position of IOCF field.
	POEG_POEGGA_IOCF_Pos = 0x1
	// Bit mask of IOCF field.
	POEG_POEGGA_IOCF_Msk = 0x2
	// Bit IOCF.
	POEG_POEGGA_IOCF = 0x2
	// No output-disable request from GPT occurred.
	POEG_POEGGA_IOCF_0 = 0x0
	// Output-disable request from GPT occurred.
	POEG_POEGGA_IOCF_1 = 0x1
	// Position of OSTPF field.
	POEG_POEGGA_OSTPF_Pos = 0x2
	// Bit mask of OSTPF field.
	POEG_POEGGA_OSTPF_Msk = 0x4
	// Bit OSTPF.
	POEG_POEGGA_OSTPF = 0x4
	// No output-disable request from oscillation stop detection occurred
	POEG_POEGGA_OSTPF_0 = 0x0
	// Output-disable request from oscillation stop detection occurred
	POEG_POEGGA_OSTPF_1 = 0x1
	// Position of SSF field.
	POEG_POEGGA_SSF_Pos = 0x3
	// Bit mask of SSF field.
	POEG_POEGGA_SSF_Msk = 0x8
	// Bit SSF.
	POEG_POEGGA_SSF = 0x8
	// No output-disable request from software occurred
	POEG_POEGGA_SSF_0 = 0x0
	// Output-disable request from software occurred
	POEG_POEGGA_SSF_1 = 0x1
	// Position of PIDE field.
	POEG_POEGGA_PIDE_Pos = 0x4
	// Bit mask of PIDE field.
	POEG_POEGGA_PIDE_Msk = 0x10
	// Bit PIDE.
	POEG_POEGGA_PIDE = 0x10
	// Disable output-disable requests from the GTETRGn pins
	POEG_POEGGA_PIDE_0 = 0x0
	// Enable output-disable requests from the GTETRGn pins
	POEG_POEGGA_PIDE_1 = 0x1
	// Position of IOCE field.
	POEG_POEGGA_IOCE_Pos = 0x5
	// Bit mask of IOCE field.
	POEG_POEGGA_IOCE_Msk = 0x20
	// Bit IOCE.
	POEG_POEGGA_IOCE = 0x20
	// Disable output-disable requests from GPT
	POEG_POEGGA_IOCE_0 = 0x0
	// Enable output-disable requests from GPT
	POEG_POEGGA_IOCE_1 = 0x1
	// Position of OSTPE field.
	POEG_POEGGA_OSTPE_Pos = 0x6
	// Bit mask of OSTPE field.
	POEG_POEGGA_OSTPE_Msk = 0x40
	// Bit OSTPE.
	POEG_POEGGA_OSTPE = 0x40
	// Disable output-disable requests from oscillation stop detection
	POEG_POEGGA_OSTPE_0 = 0x0
	// Enable output-disable requests from oscillation stop detection
	POEG_POEGGA_OSTPE_1 = 0x1
	// Position of ST field.
	POEG_POEGGA_ST_Pos = 0x10
	// Bit mask of ST field.
	POEG_POEGGA_ST_Msk = 0x10000
	// Bit ST.
	POEG_POEGGA_ST = 0x10000
	// GTETRGn input after filtering was 0
	POEG_POEGGA_ST_0 = 0x0
	// GTETRGn input after filtering was 1
	POEG_POEGGA_ST_1 = 0x1
	// Position of INV field.
	POEG_POEGGA_INV_Pos = 0x1c
	// Bit mask of INV field.
	POEG_POEGGA_INV_Msk = 0x10000000
	// Bit INV.
	POEG_POEGGA_INV = 0x10000000
	// Input GTETRGn as-is
	POEG_POEGGA_INV_0 = 0x0
	// Input GTETRGn in reverse
	POEG_POEGGA_INV_1 = 0x1
	// Position of NFEN field.
	POEG_POEGGA_NFEN_Pos = 0x1d
	// Bit mask of NFEN field.
	POEG_POEGGA_NFEN_Msk = 0x20000000
	// Bit NFEN.
	POEG_POEGGA_NFEN = 0x20000000
	// Disable noise filtering
	POEG_POEGGA_NFEN_0 = 0x0
	// Enable noise filtering
	POEG_POEGGA_NFEN_1 = 0x1
	// Position of NFCS field.
	POEG_POEGGA_NFCS_Pos = 0x1e
	// Bit mask of NFCS field.
	POEG_POEGGA_NFCS_Msk = 0xc0000000
	// Sample GTETRGn pin input level three times every PCLKB
	POEG_POEGGA_NFCS_00 = 0x0
	// Sample GTETRGn pin input level three times every PCLKB/8
	POEG_POEGGA_NFCS_01 = 0x1
	// Sample GTETRGn pin input level three times every PCLKB/32
	POEG_POEGGA_NFCS_10 = 0x2
	// Sample GTETRGn pin input level three times every PCLKB/128
	POEG_POEGGA_NFCS_11 = 0x3

	// POEGGB: POEG Group B Setting Register
	// Position of PIDF field.
	POEG_POEGGB_PIDF_Pos = 0x0
	// Bit mask of PIDF field.
	POEG_POEGGB_PIDF_Msk = 0x1
	// Bit PIDF.
	POEG_POEGGB_PIDF = 0x1
	// No output-disable request from the GTETRGn pin occurred
	POEG_POEGGB_PIDF_0 = 0x0
	// Output-disable request from the GTETRGn pin occurred.
	POEG_POEGGB_PIDF_1 = 0x1
	// Position of IOCF field.
	POEG_POEGGB_IOCF_Pos = 0x1
	// Bit mask of IOCF field.
	POEG_POEGGB_IOCF_Msk = 0x2
	// Bit IOCF.
	POEG_POEGGB_IOCF = 0x2
	// No output-disable request from GPT occurred.
	POEG_POEGGB_IOCF_0 = 0x0
	// Output-disable request from GPT occurred.
	POEG_POEGGB_IOCF_1 = 0x1
	// Position of OSTPF field.
	POEG_POEGGB_OSTPF_Pos = 0x2
	// Bit mask of OSTPF field.
	POEG_POEGGB_OSTPF_Msk = 0x4
	// Bit OSTPF.
	POEG_POEGGB_OSTPF = 0x4
	// No output-disable request from oscillation stop detection occurred
	POEG_POEGGB_OSTPF_0 = 0x0
	// Output-disable request from oscillation stop detection occurred
	POEG_POEGGB_OSTPF_1 = 0x1
	// Position of SSF field.
	POEG_POEGGB_SSF_Pos = 0x3
	// Bit mask of SSF field.
	POEG_POEGGB_SSF_Msk = 0x8
	// Bit SSF.
	POEG_POEGGB_SSF = 0x8
	// No output-disable request from software occurred
	POEG_POEGGB_SSF_0 = 0x0
	// Output-disable request from software occurred
	POEG_POEGGB_SSF_1 = 0x1
	// Position of PIDE field.
	POEG_POEGGB_PIDE_Pos = 0x4
	// Bit mask of PIDE field.
	POEG_POEGGB_PIDE_Msk = 0x10
	// Bit PIDE.
	POEG_POEGGB_PIDE = 0x10
	// Disable output-disable requests from the GTETRGn pins
	POEG_POEGGB_PIDE_0 = 0x0
	// Enable output-disable requests from the GTETRGn pins
	POEG_POEGGB_PIDE_1 = 0x1
	// Position of IOCE field.
	POEG_POEGGB_IOCE_Pos = 0x5
	// Bit mask of IOCE field.
	POEG_POEGGB_IOCE_Msk = 0x20
	// Bit IOCE.
	POEG_POEGGB_IOCE = 0x20
	// Disable output-disable requests from GPT
	POEG_POEGGB_IOCE_0 = 0x0
	// Enable output-disable requests from GPT
	POEG_POEGGB_IOCE_1 = 0x1
	// Position of OSTPE field.
	POEG_POEGGB_OSTPE_Pos = 0x6
	// Bit mask of OSTPE field.
	POEG_POEGGB_OSTPE_Msk = 0x40
	// Bit OSTPE.
	POEG_POEGGB_OSTPE = 0x40
	// Disable output-disable requests from oscillation stop detection
	POEG_POEGGB_OSTPE_0 = 0x0
	// Enable output-disable requests from oscillation stop detection
	POEG_POEGGB_OSTPE_1 = 0x1
	// Position of ST field.
	POEG_POEGGB_ST_Pos = 0x10
	// Bit mask of ST field.
	POEG_POEGGB_ST_Msk = 0x10000
	// Bit ST.
	POEG_POEGGB_ST = 0x10000
	// GTETRGn input after filtering was 0
	POEG_POEGGB_ST_0 = 0x0
	// GTETRGn input after filtering was 1
	POEG_POEGGB_ST_1 = 0x1
	// Position of INV field.
	POEG_POEGGB_INV_Pos = 0x1c
	// Bit mask of INV field.
	POEG_POEGGB_INV_Msk = 0x10000000
	// Bit INV.
	POEG_POEGGB_INV = 0x10000000
	// Input GTETRGn as-is
	POEG_POEGGB_INV_0 = 0x0
	// Input GTETRGn in reverse
	POEG_POEGGB_INV_1 = 0x1
	// Position of NFEN field.
	POEG_POEGGB_NFEN_Pos = 0x1d
	// Bit mask of NFEN field.
	POEG_POEGGB_NFEN_Msk = 0x20000000
	// Bit NFEN.
	POEG_POEGGB_NFEN = 0x20000000
	// Disable noise filtering
	POEG_POEGGB_NFEN_0 = 0x0
	// Enable noise filtering
	POEG_POEGGB_NFEN_1 = 0x1
	// Position of NFCS field.
	POEG_POEGGB_NFCS_Pos = 0x1e
	// Bit mask of NFCS field.
	POEG_POEGGB_NFCS_Msk = 0xc0000000
	// Sample GTETRGn pin input level three times every PCLKB
	POEG_POEGGB_NFCS_00 = 0x0
	// Sample GTETRGn pin input level three times every PCLKB/8
	POEG_POEGGB_NFCS_01 = 0x1
	// Sample GTETRGn pin input level three times every PCLKB/32
	POEG_POEGGB_NFCS_10 = 0x2
	// Sample GTETRGn pin input level three times every PCLKB/128
	POEG_POEGGB_NFCS_11 = 0x3

	// POEGGC: POEG Group C Setting Register
	// Position of PIDF field.
	POEG_POEGGC_PIDF_Pos = 0x0
	// Bit mask of PIDF field.
	POEG_POEGGC_PIDF_Msk = 0x1
	// Bit PIDF.
	POEG_POEGGC_PIDF = 0x1
	// No output-disable request from the GTETRGn pin occurred
	POEG_POEGGC_PIDF_0 = 0x0
	// Output-disable request from the GTETRGn pin occurred.
	POEG_POEGGC_PIDF_1 = 0x1
	// Position of IOCF field.
	POEG_POEGGC_IOCF_Pos = 0x1
	// Bit mask of IOCF field.
	POEG_POEGGC_IOCF_Msk = 0x2
	// Bit IOCF.
	POEG_POEGGC_IOCF = 0x2
	// No output-disable request from GPT occurred.
	POEG_POEGGC_IOCF_0 = 0x0
	// Output-disable request from GPT occurred.
	POEG_POEGGC_IOCF_1 = 0x1
	// Position of OSTPF field.
	POEG_POEGGC_OSTPF_Pos = 0x2
	// Bit mask of OSTPF field.
	POEG_POEGGC_OSTPF_Msk = 0x4
	// Bit OSTPF.
	POEG_POEGGC_OSTPF = 0x4
	// No output-disable request from oscillation stop detection occurred
	POEG_POEGGC_OSTPF_0 = 0x0
	// Output-disable request from oscillation stop detection occurred
	POEG_POEGGC_OSTPF_1 = 0x1
	// Position of SSF field.
	POEG_POEGGC_SSF_Pos = 0x3
	// Bit mask of SSF field.
	POEG_POEGGC_SSF_Msk = 0x8
	// Bit SSF.
	POEG_POEGGC_SSF = 0x8
	// No output-disable request from software occurred
	POEG_POEGGC_SSF_0 = 0x0
	// Output-disable request from software occurred
	POEG_POEGGC_SSF_1 = 0x1
	// Position of PIDE field.
	POEG_POEGGC_PIDE_Pos = 0x4
	// Bit mask of PIDE field.
	POEG_POEGGC_PIDE_Msk = 0x10
	// Bit PIDE.
	POEG_POEGGC_PIDE = 0x10
	// Disable output-disable requests from the GTETRGn pins
	POEG_POEGGC_PIDE_0 = 0x0
	// Enable output-disable requests from the GTETRGn pins
	POEG_POEGGC_PIDE_1 = 0x1
	// Position of IOCE field.
	POEG_POEGGC_IOCE_Pos = 0x5
	// Bit mask of IOCE field.
	POEG_POEGGC_IOCE_Msk = 0x20
	// Bit IOCE.
	POEG_POEGGC_IOCE = 0x20
	// Disable output-disable requests from GPT
	POEG_POEGGC_IOCE_0 = 0x0
	// Enable output-disable requests from GPT
	POEG_POEGGC_IOCE_1 = 0x1
	// Position of OSTPE field.
	POEG_POEGGC_OSTPE_Pos = 0x6
	// Bit mask of OSTPE field.
	POEG_POEGGC_OSTPE_Msk = 0x40
	// Bit OSTPE.
	POEG_POEGGC_OSTPE = 0x40
	// Disable output-disable requests from oscillation stop detection
	POEG_POEGGC_OSTPE_0 = 0x0
	// Enable output-disable requests from oscillation stop detection
	POEG_POEGGC_OSTPE_1 = 0x1
	// Position of ST field.
	POEG_POEGGC_ST_Pos = 0x10
	// Bit mask of ST field.
	POEG_POEGGC_ST_Msk = 0x10000
	// Bit ST.
	POEG_POEGGC_ST = 0x10000
	// GTETRGn input after filtering was 0
	POEG_POEGGC_ST_0 = 0x0
	// GTETRGn input after filtering was 1
	POEG_POEGGC_ST_1 = 0x1
	// Position of INV field.
	POEG_POEGGC_INV_Pos = 0x1c
	// Bit mask of INV field.
	POEG_POEGGC_INV_Msk = 0x10000000
	// Bit INV.
	POEG_POEGGC_INV = 0x10000000
	// Input GTETRGn as-is
	POEG_POEGGC_INV_0 = 0x0
	// Input GTETRGn in reverse
	POEG_POEGGC_INV_1 = 0x1
	// Position of NFEN field.
	POEG_POEGGC_NFEN_Pos = 0x1d
	// Bit mask of NFEN field.
	POEG_POEGGC_NFEN_Msk = 0x20000000
	// Bit NFEN.
	POEG_POEGGC_NFEN = 0x20000000
	// Disable noise filtering
	POEG_POEGGC_NFEN_0 = 0x0
	// Enable noise filtering
	POEG_POEGGC_NFEN_1 = 0x1
	// Position of NFCS field.
	POEG_POEGGC_NFCS_Pos = 0x1e
	// Bit mask of NFCS field.
	POEG_POEGGC_NFCS_Msk = 0xc0000000
	// Sample GTETRGn pin input level three times every PCLKB
	POEG_POEGGC_NFCS_00 = 0x0
	// Sample GTETRGn pin input level three times every PCLKB/8
	POEG_POEGGC_NFCS_01 = 0x1
	// Sample GTETRGn pin input level three times every PCLKB/32
	POEG_POEGGC_NFCS_10 = 0x2
	// Sample GTETRGn pin input level three times every PCLKB/128
	POEG_POEGGC_NFCS_11 = 0x3

	// POEGGD: POEG Group D Setting Register
	// Position of PIDF field.
	POEG_POEGGD_PIDF_Pos = 0x0
	// Bit mask of PIDF field.
	POEG_POEGGD_PIDF_Msk = 0x1
	// Bit PIDF.
	POEG_POEGGD_PIDF = 0x1
	// No output-disable request from the GTETRGn pin occurred
	POEG_POEGGD_PIDF_0 = 0x0
	// Output-disable request from the GTETRGn pin occurred.
	POEG_POEGGD_PIDF_1 = 0x1
	// Position of IOCF field.
	POEG_POEGGD_IOCF_Pos = 0x1
	// Bit mask of IOCF field.
	POEG_POEGGD_IOCF_Msk = 0x2
	// Bit IOCF.
	POEG_POEGGD_IOCF = 0x2
	// No output-disable request from GPT occurred.
	POEG_POEGGD_IOCF_0 = 0x0
	// Output-disable request from GPT occurred.
	POEG_POEGGD_IOCF_1 = 0x1
	// Position of OSTPF field.
	POEG_POEGGD_OSTPF_Pos = 0x2
	// Bit mask of OSTPF field.
	POEG_POEGGD_OSTPF_Msk = 0x4
	// Bit OSTPF.
	POEG_POEGGD_OSTPF = 0x4
	// No output-disable request from oscillation stop detection occurred
	POEG_POEGGD_OSTPF_0 = 0x0
	// Output-disable request from oscillation stop detection occurred
	POEG_POEGGD_OSTPF_1 = 0x1
	// Position of SSF field.
	POEG_POEGGD_SSF_Pos = 0x3
	// Bit mask of SSF field.
	POEG_POEGGD_SSF_Msk = 0x8
	// Bit SSF.
	POEG_POEGGD_SSF = 0x8
	// No output-disable request from software occurred
	POEG_POEGGD_SSF_0 = 0x0
	// Output-disable request from software occurred
	POEG_POEGGD_SSF_1 = 0x1
	// Position of PIDE field.
	POEG_POEGGD_PIDE_Pos = 0x4
	// Bit mask of PIDE field.
	POEG_POEGGD_PIDE_Msk = 0x10
	// Bit PIDE.
	POEG_POEGGD_PIDE = 0x10
	// Disable output-disable requests from the GTETRGn pins
	POEG_POEGGD_PIDE_0 = 0x0
	// Enable output-disable requests from the GTETRGn pins
	POEG_POEGGD_PIDE_1 = 0x1
	// Position of IOCE field.
	POEG_POEGGD_IOCE_Pos = 0x5
	// Bit mask of IOCE field.
	POEG_POEGGD_IOCE_Msk = 0x20
	// Bit IOCE.
	POEG_POEGGD_IOCE = 0x20
	// Disable output-disable requests from GPT
	POEG_POEGGD_IOCE_0 = 0x0
	// Enable output-disable requests from GPT
	POEG_POEGGD_IOCE_1 = 0x1
	// Position of OSTPE field.
	POEG_POEGGD_OSTPE_Pos = 0x6
	// Bit mask of OSTPE field.
	POEG_POEGGD_OSTPE_Msk = 0x40
	// Bit OSTPE.
	POEG_POEGGD_OSTPE = 0x40
	// Disable output-disable requests from oscillation stop detection
	POEG_POEGGD_OSTPE_0 = 0x0
	// Enable output-disable requests from oscillation stop detection
	POEG_POEGGD_OSTPE_1 = 0x1
	// Position of ST field.
	POEG_POEGGD_ST_Pos = 0x10
	// Bit mask of ST field.
	POEG_POEGGD_ST_Msk = 0x10000
	// Bit ST.
	POEG_POEGGD_ST = 0x10000
	// GTETRGn input after filtering was 0
	POEG_POEGGD_ST_0 = 0x0
	// GTETRGn input after filtering was 1
	POEG_POEGGD_ST_1 = 0x1
	// Position of INV field.
	POEG_POEGGD_INV_Pos = 0x1c
	// Bit mask of INV field.
	POEG_POEGGD_INV_Msk = 0x10000000
	// Bit INV.
	POEG_POEGGD_INV = 0x10000000
	// Input GTETRGn as-is
	POEG_POEGGD_INV_0 = 0x0
	// Input GTETRGn in reverse
	POEG_POEGGD_INV_1 = 0x1
	// Position of NFEN field.
	POEG_POEGGD_NFEN_Pos = 0x1d
	// Bit mask of NFEN field.
	POEG_POEGGD_NFEN_Msk = 0x20000000
	// Bit NFEN.
	POEG_POEGGD_NFEN = 0x20000000
	// Disable noise filtering
	POEG_POEGGD_NFEN_0 = 0x0
	// Enable noise filtering
	POEG_POEGGD_NFEN_1 = 0x1
	// Position of NFCS field.
	POEG_POEGGD_NFCS_Pos = 0x1e
	// Bit mask of NFCS field.
	POEG_POEGGD_NFCS_Msk = 0xc0000000
	// Sample GTETRGn pin input level three times every PCLKB
	POEG_POEGGD_NFCS_00 = 0x0
	// Sample GTETRGn pin input level three times every PCLKB/8
	POEG_POEGGD_NFCS_01 = 0x1
	// Sample GTETRGn pin input level three times every PCLKB/32
	POEG_POEGGD_NFCS_10 = 0x2
	// Sample GTETRGn pin input level three times every PCLKB/128
	POEG_POEGGD_NFCS_11 = 0x3
)

// Constants for USBFS: USB 2.0 Full-Speed Module
const (
	// SYSCFG: System Configuration Control Register
	// Position of USBE field.
	USBFS_SYSCFG_USBE_Pos = 0x0
	// Bit mask of USBE field.
	USBFS_SYSCFG_USBE_Msk = 0x1
	// Bit USBE.
	USBFS_SYSCFG_USBE = 0x1
	// Disable
	USBFS_SYSCFG_USBE_0 = 0x0
	// Enable
	USBFS_SYSCFG_USBE_1 = 0x1
	// Position of DPRPU field.
	USBFS_SYSCFG_DPRPU_Pos = 0x4
	// Bit mask of DPRPU field.
	USBFS_SYSCFG_DPRPU_Msk = 0x10
	// Bit DPRPU.
	USBFS_SYSCFG_DPRPU = 0x10
	// Disable line pull-up
	USBFS_SYSCFG_DPRPU_0 = 0x0
	// Enable line pull-up
	USBFS_SYSCFG_DPRPU_1 = 0x1
	// Position of DRPD field.
	USBFS_SYSCFG_DRPD_Pos = 0x5
	// Bit mask of DRPD field.
	USBFS_SYSCFG_DRPD_Msk = 0x20
	// Bit DRPD.
	USBFS_SYSCFG_DRPD = 0x20
	// Disable line pull-down
	USBFS_SYSCFG_DRPD_0 = 0x0
	// Enable line pull-down
	USBFS_SYSCFG_DRPD_1 = 0x1
	// Position of DCFM field.
	USBFS_SYSCFG_DCFM_Pos = 0x6
	// Bit mask of DCFM field.
	USBFS_SYSCFG_DCFM_Msk = 0x40
	// Bit DCFM.
	USBFS_SYSCFG_DCFM = 0x40
	// Select device controller
	USBFS_SYSCFG_DCFM_0 = 0x0
	// Select host controller
	USBFS_SYSCFG_DCFM_1 = 0x1
	// Position of SCKE field.
	USBFS_SYSCFG_SCKE_Pos = 0xa
	// Bit mask of SCKE field.
	USBFS_SYSCFG_SCKE_Msk = 0x400
	// Bit SCKE.
	USBFS_SYSCFG_SCKE = 0x400
	// Stop clock supply to the USBFS
	USBFS_SYSCFG_SCKE_0 = 0x0
	// Enable clock supply to the USBFS
	USBFS_SYSCFG_SCKE_1 = 0x1

	// SYSSTS0: System Configuration Status Register 0
	// Position of LNST field.
	USBFS_SYSSTS0_LNST_Pos = 0x0
	// Bit mask of LNST field.
	USBFS_SYSSTS0_LNST_Msk = 0x3
	// Position of IDMON field.
	USBFS_SYSSTS0_IDMON_Pos = 0x2
	// Bit mask of IDMON field.
	USBFS_SYSSTS0_IDMON_Msk = 0x4
	// Bit IDMON.
	USBFS_SYSSTS0_IDMON = 0x4
	// USB_ID pin is low
	USBFS_SYSSTS0_IDMON_0 = 0x0
	// USB_ID pin is high
	USBFS_SYSSTS0_IDMON_1 = 0x1
	// Position of SOFEA field.
	USBFS_SYSSTS0_SOFEA_Pos = 0x5
	// Bit mask of SOFEA field.
	USBFS_SYSSTS0_SOFEA_Msk = 0x20
	// Bit SOFEA.
	USBFS_SYSSTS0_SOFEA = 0x20
	// SOF output stopped
	USBFS_SYSSTS0_SOFEA_0 = 0x0
	// SOF output operating
	USBFS_SYSSTS0_SOFEA_1 = 0x1
	// Position of HTACT field.
	USBFS_SYSSTS0_HTACT_Pos = 0x6
	// Bit mask of HTACT field.
	USBFS_SYSSTS0_HTACT_Msk = 0x40
	// Bit HTACT.
	USBFS_SYSSTS0_HTACT = 0x40
	// Host sequencer completely stopped
	USBFS_SYSSTS0_HTACT_0 = 0x0
	// Host sequencer not completely stopped
	USBFS_SYSSTS0_HTACT_1 = 0x1
	// Position of OVCMON field.
	USBFS_SYSSTS0_OVCMON_Pos = 0xe
	// Bit mask of OVCMON field.
	USBFS_SYSSTS0_OVCMON_Msk = 0xc000

	// DVSTCTR0: Device State Control Register 0
	// Position of RHST field.
	USBFS_DVSTCTR0_RHST_Pos = 0x0
	// Bit mask of RHST field.
	USBFS_DVSTCTR0_RHST_Msk = 0x7
	// In host controller mode: Communication speed indeterminate (powered state or no connection) In device controller mode: Communication speed indeterminate
	USBFS_DVSTCTR0_RHST_000 = 0x0
	// In host controller mode: Low-speed connection In device controller mode: USB bus reset in progress
	USBFS_DVSTCTR0_RHST_001 = 0x1
	// In host controller mode: Full-speed connection In device controller mode: USB bus reset in progress or full-speed connection
	USBFS_DVSTCTR0_RHST_010 = 0x2
	// Setting prohibited
	USBFS_DVSTCTR0_RHST_011 = 0x3
	// Position of UACT field.
	USBFS_DVSTCTR0_UACT_Pos = 0x4
	// Bit mask of UACT field.
	USBFS_DVSTCTR0_UACT_Msk = 0x10
	// Bit UACT.
	USBFS_DVSTCTR0_UACT = 0x10
	// Disable downstream port (disable SOF transmission)
	USBFS_DVSTCTR0_UACT_0 = 0x0
	// Enable downstream port (enable SOF transmission)
	USBFS_DVSTCTR0_UACT_1 = 0x1
	// Position of RESUME field.
	USBFS_DVSTCTR0_RESUME_Pos = 0x5
	// Bit mask of RESUME field.
	USBFS_DVSTCTR0_RESUME_Msk = 0x20
	// Bit RESUME.
	USBFS_DVSTCTR0_RESUME = 0x20
	// Do not output resume signal
	USBFS_DVSTCTR0_RESUME_0 = 0x0
	// Output resume signal
	USBFS_DVSTCTR0_RESUME_1 = 0x1
	// Position of USBRST field.
	USBFS_DVSTCTR0_USBRST_Pos = 0x6
	// Bit mask of USBRST field.
	USBFS_DVSTCTR0_USBRST_Msk = 0x40
	// Bit USBRST.
	USBFS_DVSTCTR0_USBRST = 0x40
	// Do not output USB bus reset signal
	USBFS_DVSTCTR0_USBRST_0 = 0x0
	// Output USB bus reset signal
	USBFS_DVSTCTR0_USBRST_1 = 0x1
	// Position of RWUPE field.
	USBFS_DVSTCTR0_RWUPE_Pos = 0x7
	// Bit mask of RWUPE field.
	USBFS_DVSTCTR0_RWUPE_Msk = 0x80
	// Bit RWUPE.
	USBFS_DVSTCTR0_RWUPE = 0x80
	// Disable downstream port remote wakeup
	USBFS_DVSTCTR0_RWUPE_0 = 0x0
	// Enable downstream port remote wakeup
	USBFS_DVSTCTR0_RWUPE_1 = 0x1
	// Position of WKUP field.
	USBFS_DVSTCTR0_WKUP_Pos = 0x8
	// Bit mask of WKUP field.
	USBFS_DVSTCTR0_WKUP_Msk = 0x100
	// Bit WKUP.
	USBFS_DVSTCTR0_WKUP = 0x100
	// Do not output remote wakeup signal
	USBFS_DVSTCTR0_WKUP_0 = 0x0
	// Output remote wakeup signal
	USBFS_DVSTCTR0_WKUP_1 = 0x1
	// Position of VBUSEN field.
	USBFS_DVSTCTR0_VBUSEN_Pos = 0x9
	// Bit mask of VBUSEN field.
	USBFS_DVSTCTR0_VBUSEN_Msk = 0x200
	// Bit VBUSEN.
	USBFS_DVSTCTR0_VBUSEN = 0x200
	// Output low on external USB_VBUSEN pin
	USBFS_DVSTCTR0_VBUSEN_0 = 0x0
	// Output high on external USB_VBUSEN pin
	USBFS_DVSTCTR0_VBUSEN_1 = 0x1
	// Position of EXICEN field.
	USBFS_DVSTCTR0_EXICEN_Pos = 0xa
	// Bit mask of EXICEN field.
	USBFS_DVSTCTR0_EXICEN_Msk = 0x400
	// Bit EXICEN.
	USBFS_DVSTCTR0_EXICEN = 0x400
	// Output low on external USB_EXICEN pin
	USBFS_DVSTCTR0_EXICEN_0 = 0x0
	// Output high on external USB_EXICEN pin
	USBFS_DVSTCTR0_EXICEN_1 = 0x1
	// Position of HNPBTOA field.
	USBFS_DVSTCTR0_HNPBTOA_Pos = 0xb
	// Bit mask of HNPBTOA field.
	USBFS_DVSTCTR0_HNPBTOA_Msk = 0x800
	// Bit HNPBTOA.
	USBFS_DVSTCTR0_HNPBTOA = 0x800

	// CFIFO: CFIFO Port Register
	// Position of FIFOPORT field.
	USBFS_CFIFO_FIFOPORT_Pos = 0x0
	// Bit mask of FIFOPORT field.
	USBFS_CFIFO_FIFOPORT_Msk = 0xffff

	// D0FIFO: D%sFIFO Port Register
	// Position of FIFOPORT field.
	USBFS_DFIFO_FIFOPORT_Pos = 0x0
	// Bit mask of FIFOPORT field.
	USBFS_DFIFO_FIFOPORT_Msk = 0xffff

	// CFIFOSEL: CFIFO Port Select Register
	// Position of CURPIPE field.
	USBFS_CFIFOSEL_CURPIPE_Pos = 0x0
	// Bit mask of CURPIPE field.
	USBFS_CFIFOSEL_CURPIPE_Msk = 0xf
	// Default Control Pipe
	USBFS_CFIFOSEL_CURPIPE_0x0 = 0x0
	// Pipe 1
	USBFS_CFIFOSEL_CURPIPE_0x1 = 0x1
	// Pipe 2
	USBFS_CFIFOSEL_CURPIPE_0x2 = 0x2
	// Pipe 3
	USBFS_CFIFOSEL_CURPIPE_0x3 = 0x3
	// Pipe 4
	USBFS_CFIFOSEL_CURPIPE_0x4 = 0x4
	// Pipe 5
	USBFS_CFIFOSEL_CURPIPE_0x5 = 0x5
	// Pipe 6
	USBFS_CFIFOSEL_CURPIPE_0x6 = 0x6
	// Pipe 7
	USBFS_CFIFOSEL_CURPIPE_0x7 = 0x7
	// Pipe 8
	USBFS_CFIFOSEL_CURPIPE_0x8 = 0x8
	// Pipe 9
	USBFS_CFIFOSEL_CURPIPE_0x9 = 0x9
	// Position of ISEL field.
	USBFS_CFIFOSEL_ISEL_Pos = 0x5
	// Bit mask of ISEL field.
	USBFS_CFIFOSEL_ISEL_Msk = 0x20
	// Bit ISEL.
	USBFS_CFIFOSEL_ISEL = 0x20
	// Select reading from the FIFO buffer
	USBFS_CFIFOSEL_ISEL_0 = 0x0
	// Select writing to the FIFO buffer
	USBFS_CFIFOSEL_ISEL_1 = 0x1
	// Position of BIGEND field.
	USBFS_CFIFOSEL_BIGEND_Pos = 0x8
	// Bit mask of BIGEND field.
	USBFS_CFIFOSEL_BIGEND_Msk = 0x100
	// Bit BIGEND.
	USBFS_CFIFOSEL_BIGEND = 0x100
	// Little endian
	USBFS_CFIFOSEL_BIGEND_0 = 0x0
	// Big endian
	USBFS_CFIFOSEL_BIGEND_1 = 0x1
	// Position of MBW field.
	USBFS_CFIFOSEL_MBW_Pos = 0xa
	// Bit mask of MBW field.
	USBFS_CFIFOSEL_MBW_Msk = 0x400
	// Bit MBW.
	USBFS_CFIFOSEL_MBW = 0x400
	// 8-bit width
	USBFS_CFIFOSEL_MBW_0 = 0x0
	// 16-bit width
	USBFS_CFIFOSEL_MBW_1 = 0x1
	// Position of REW field.
	USBFS_CFIFOSEL_REW_Pos = 0xe
	// Bit mask of REW field.
	USBFS_CFIFOSEL_REW_Msk = 0x4000
	// Bit REW.
	USBFS_CFIFOSEL_REW = 0x4000
	// Do not rewind buffer pointer
	USBFS_CFIFOSEL_REW_0 = 0x0
	// Rewind buffer pointer
	USBFS_CFIFOSEL_REW_1 = 0x1
	// Position of RCNT field.
	USBFS_CFIFOSEL_RCNT_Pos = 0xf
	// Bit mask of RCNT field.
	USBFS_CFIFOSEL_RCNT_Msk = 0x8000
	// Bit RCNT.
	USBFS_CFIFOSEL_RCNT = 0x8000
	// The DTLN[8:0] bits (CFIFOCTR.DTLN[8:0], D0FIFOCTR.DTLN[8:0], D1FIFOCTR.DTLN[8:0]) are cleared when all receive data is read from the CFIFO. In double buffer mode, the DTLN[8:0] value is cleared when all data is read from only a single plane.
	USBFS_CFIFOSEL_RCNT_0 = 0x0
	// The DTLN[8:0] bits are decremented each time the receive data is read from the CFIFO.
	USBFS_CFIFOSEL_RCNT_1 = 0x1

	// CFIFOCTR: CFIFO Port Control Register
	// Position of DTLN field.
	USBFS_CFIFOCTR_DTLN_Pos = 0x0
	// Bit mask of DTLN field.
	USBFS_CFIFOCTR_DTLN_Msk = 0x1ff
	// Position of FRDY field.
	USBFS_CFIFOCTR_FRDY_Pos = 0xd
	// Bit mask of FRDY field.
	USBFS_CFIFOCTR_FRDY_Msk = 0x2000
	// Bit FRDY.
	USBFS_CFIFOCTR_FRDY = 0x2000
	// FIFO port access disabled
	USBFS_CFIFOCTR_FRDY_0 = 0x0
	// FIFO port access enabled
	USBFS_CFIFOCTR_FRDY_1 = 0x1
	// Position of BCLR field.
	USBFS_CFIFOCTR_BCLR_Pos = 0xe
	// Bit mask of BCLR field.
	USBFS_CFIFOCTR_BCLR_Msk = 0x4000
	// Bit BCLR.
	USBFS_CFIFOCTR_BCLR = 0x4000
	// No operation
	USBFS_CFIFOCTR_BCLR_0 = 0x0
	// Clear FIFO buffer on the CPU side
	USBFS_CFIFOCTR_BCLR_1 = 0x1
	// Position of BVAL field.
	USBFS_CFIFOCTR_BVAL_Pos = 0xf
	// Bit mask of BVAL field.
	USBFS_CFIFOCTR_BVAL_Msk = 0x8000
	// Bit BVAL.
	USBFS_CFIFOCTR_BVAL = 0x8000
	// Invalid (writing 0 has no effect)
	USBFS_CFIFOCTR_BVAL_0 = 0x0
	// Writing ended
	USBFS_CFIFOCTR_BVAL_1 = 0x1

	// D0FIFOSEL: D%sFIFO Port Select Register
	// Position of CURPIPE field.
	USBFS_DFIFOSEL_CURPIPE_Pos = 0x0
	// Bit mask of CURPIPE field.
	USBFS_DFIFOSEL_CURPIPE_Msk = 0xf
	// Default Control Pipe
	USBFS_DFIFOSEL_CURPIPE_0x0 = 0x0
	// Pipe 1
	USBFS_DFIFOSEL_CURPIPE_0x1 = 0x1
	// Pipe 2
	USBFS_DFIFOSEL_CURPIPE_0x2 = 0x2
	// Pipe 3
	USBFS_DFIFOSEL_CURPIPE_0x3 = 0x3
	// Pipe 4
	USBFS_DFIFOSEL_CURPIPE_0x4 = 0x4
	// Pipe 5
	USBFS_DFIFOSEL_CURPIPE_0x5 = 0x5
	// Pipe 6
	USBFS_DFIFOSEL_CURPIPE_0x6 = 0x6
	// Pipe 7
	USBFS_DFIFOSEL_CURPIPE_0x7 = 0x7
	// Pipe 8
	USBFS_DFIFOSEL_CURPIPE_0x8 = 0x8
	// Pipe 9
	USBFS_DFIFOSEL_CURPIPE_0x9 = 0x9
	// Position of BIGEND field.
	USBFS_DFIFOSEL_BIGEND_Pos = 0x8
	// Bit mask of BIGEND field.
	USBFS_DFIFOSEL_BIGEND_Msk = 0x100
	// Bit BIGEND.
	USBFS_DFIFOSEL_BIGEND = 0x100
	// Little endian
	USBFS_DFIFOSEL_BIGEND_0 = 0x0
	// Big endian
	USBFS_DFIFOSEL_BIGEND_1 = 0x1
	// Position of MBW field.
	USBFS_DFIFOSEL_MBW_Pos = 0xa
	// Bit mask of MBW field.
	USBFS_DFIFOSEL_MBW_Msk = 0x400
	// Bit MBW.
	USBFS_DFIFOSEL_MBW = 0x400
	// 8-bit width
	USBFS_DFIFOSEL_MBW_0 = 0x0
	// 16-bit width
	USBFS_DFIFOSEL_MBW_1 = 0x1
	// Position of DREQE field.
	USBFS_DFIFOSEL_DREQE_Pos = 0xc
	// Bit mask of DREQE field.
	USBFS_DFIFOSEL_DREQE_Msk = 0x1000
	// Bit DREQE.
	USBFS_DFIFOSEL_DREQE = 0x1000
	// Disable DMA/DTC transfer request
	USBFS_DFIFOSEL_DREQE_0 = 0x0
	// Enable DMA/DTC transfer request
	USBFS_DFIFOSEL_DREQE_1 = 0x1
	// Position of DCLRM field.
	USBFS_DFIFOSEL_DCLRM_Pos = 0xd
	// Bit mask of DCLRM field.
	USBFS_DFIFOSEL_DCLRM_Msk = 0x2000
	// Bit DCLRM.
	USBFS_DFIFOSEL_DCLRM = 0x2000
	// Disable auto buffer clear mode
	USBFS_DFIFOSEL_DCLRM_0 = 0x0
	// Enable auto buffer clear mode
	USBFS_DFIFOSEL_DCLRM_1 = 0x1
	// Position of REW field.
	USBFS_DFIFOSEL_REW_Pos = 0xe
	// Bit mask of REW field.
	USBFS_DFIFOSEL_REW_Msk = 0x4000
	// Bit REW.
	USBFS_DFIFOSEL_REW = 0x4000
	// Do not rewind buffer pointer
	USBFS_DFIFOSEL_REW_0 = 0x0
	// Rewind buffer pointer
	USBFS_DFIFOSEL_REW_1 = 0x1
	// Position of RCNT field.
	USBFS_DFIFOSEL_RCNT_Pos = 0xf
	// Bit mask of RCNT field.
	USBFS_DFIFOSEL_RCNT_Msk = 0x8000
	// Bit RCNT.
	USBFS_DFIFOSEL_RCNT = 0x8000
	// Clear DTLN[8:0] bits in (CFIFOCTR.DTLN[8:0], D0FIFOCTR.DTLN[8:0], D1FIFOCTR.DTLN[8:0]) when all receive data is read from DnFIFO (after read of a single plane in double buffer mode)
	USBFS_DFIFOSEL_RCNT_0 = 0x0
	// Decrement DTLN[8:0] bits each time receive data is read from DnFIFO
	USBFS_DFIFOSEL_RCNT_1 = 0x1

	// D0FIFOCTR: D%sFIFO Port Control Register
	// Position of DTLN field.
	USBFS_DFIFOCTR_DTLN_Pos = 0x0
	// Bit mask of DTLN field.
	USBFS_DFIFOCTR_DTLN_Msk = 0x1ff
	// Position of FRDY field.
	USBFS_DFIFOCTR_FRDY_Pos = 0xd
	// Bit mask of FRDY field.
	USBFS_DFIFOCTR_FRDY_Msk = 0x2000
	// Bit FRDY.
	USBFS_DFIFOCTR_FRDY = 0x2000
	// FIFO port access disabled
	USBFS_DFIFOCTR_FRDY_0 = 0x0
	// FIFO port access enabled
	USBFS_DFIFOCTR_FRDY_1 = 0x1
	// Position of BCLR field.
	USBFS_DFIFOCTR_BCLR_Pos = 0xe
	// Bit mask of BCLR field.
	USBFS_DFIFOCTR_BCLR_Msk = 0x4000
	// Bit BCLR.
	USBFS_DFIFOCTR_BCLR = 0x4000
	// No operation
	USBFS_DFIFOCTR_BCLR_0 = 0x0
	// Clear FIFO buffer on the CPU side
	USBFS_DFIFOCTR_BCLR_1 = 0x1
	// Position of BVAL field.
	USBFS_DFIFOCTR_BVAL_Pos = 0xf
	// Bit mask of BVAL field.
	USBFS_DFIFOCTR_BVAL_Msk = 0x8000
	// Bit BVAL.
	USBFS_DFIFOCTR_BVAL = 0x8000
	// Invalid (writing 0 has no effect)
	USBFS_DFIFOCTR_BVAL_0 = 0x0
	// Writing ended
	USBFS_DFIFOCTR_BVAL_1 = 0x1

	// INTENB0: Interrupt Enable Register 0
	// Position of BRDYE field.
	USBFS_INTENB0_BRDYE_Pos = 0x8
	// Bit mask of BRDYE field.
	USBFS_INTENB0_BRDYE_Msk = 0x100
	// Bit BRDYE.
	USBFS_INTENB0_BRDYE = 0x100
	// Disable interrupt request
	USBFS_INTENB0_BRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB0_BRDYE_1 = 0x1
	// Position of NRDYE field.
	USBFS_INTENB0_NRDYE_Pos = 0x9
	// Bit mask of NRDYE field.
	USBFS_INTENB0_NRDYE_Msk = 0x200
	// Bit NRDYE.
	USBFS_INTENB0_NRDYE = 0x200
	// Disable interrupt request
	USBFS_INTENB0_NRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB0_NRDYE_1 = 0x1
	// Position of BEMPE field.
	USBFS_INTENB0_BEMPE_Pos = 0xa
	// Bit mask of BEMPE field.
	USBFS_INTENB0_BEMPE_Msk = 0x400
	// Bit BEMPE.
	USBFS_INTENB0_BEMPE = 0x400
	// Disable interrupt request
	USBFS_INTENB0_BEMPE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB0_BEMPE_1 = 0x1
	// Position of CTRE field.
	USBFS_INTENB0_CTRE_Pos = 0xb
	// Bit mask of CTRE field.
	USBFS_INTENB0_CTRE_Msk = 0x800
	// Bit CTRE.
	USBFS_INTENB0_CTRE = 0x800
	// Disable interrupt request
	USBFS_INTENB0_CTRE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB0_CTRE_1 = 0x1
	// Position of DVSE field.
	USBFS_INTENB0_DVSE_Pos = 0xc
	// Bit mask of DVSE field.
	USBFS_INTENB0_DVSE_Msk = 0x1000
	// Bit DVSE.
	USBFS_INTENB0_DVSE = 0x1000
	// Disable interrupt request
	USBFS_INTENB0_DVSE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB0_DVSE_1 = 0x1
	// Position of SOFE field.
	USBFS_INTENB0_SOFE_Pos = 0xd
	// Bit mask of SOFE field.
	USBFS_INTENB0_SOFE_Msk = 0x2000
	// Bit SOFE.
	USBFS_INTENB0_SOFE = 0x2000
	// Disable interrupt request
	USBFS_INTENB0_SOFE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB0_SOFE_1 = 0x1
	// Position of RSME field.
	USBFS_INTENB0_RSME_Pos = 0xe
	// Bit mask of RSME field.
	USBFS_INTENB0_RSME_Msk = 0x4000
	// Bit RSME.
	USBFS_INTENB0_RSME = 0x4000
	// Disable interrupt request
	USBFS_INTENB0_RSME_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB0_RSME_1 = 0x1
	// Position of VBSE field.
	USBFS_INTENB0_VBSE_Pos = 0xf
	// Bit mask of VBSE field.
	USBFS_INTENB0_VBSE_Msk = 0x8000
	// Bit VBSE.
	USBFS_INTENB0_VBSE = 0x8000
	// Disable interrupt request
	USBFS_INTENB0_VBSE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB0_VBSE_1 = 0x1

	// INTENB1: Interrupt Enable Register 1
	// Position of PDDETINTE field.
	USBFS_INTENB1_PDDETINTE_Pos = 0x0
	// Bit mask of PDDETINTE field.
	USBFS_INTENB1_PDDETINTE_Msk = 0x1
	// Bit PDDETINTE.
	USBFS_INTENB1_PDDETINTE = 0x1
	// Disable interrupt request
	USBFS_INTENB1_PDDETINTE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB1_PDDETINTE_1 = 0x1
	// Position of SACKE field.
	USBFS_INTENB1_SACKE_Pos = 0x4
	// Bit mask of SACKE field.
	USBFS_INTENB1_SACKE_Msk = 0x10
	// Bit SACKE.
	USBFS_INTENB1_SACKE = 0x10
	// Disable interrupt request
	USBFS_INTENB1_SACKE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB1_SACKE_1 = 0x1
	// Position of SIGNE field.
	USBFS_INTENB1_SIGNE_Pos = 0x5
	// Bit mask of SIGNE field.
	USBFS_INTENB1_SIGNE_Msk = 0x20
	// Bit SIGNE.
	USBFS_INTENB1_SIGNE = 0x20
	// Disable interrupt request
	USBFS_INTENB1_SIGNE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB1_SIGNE_1 = 0x1
	// Position of EOFERRE field.
	USBFS_INTENB1_EOFERRE_Pos = 0x6
	// Bit mask of EOFERRE field.
	USBFS_INTENB1_EOFERRE_Msk = 0x40
	// Bit EOFERRE.
	USBFS_INTENB1_EOFERRE = 0x40
	// Disable interrupt request
	USBFS_INTENB1_EOFERRE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB1_EOFERRE_1 = 0x1
	// Position of ATTCHE field.
	USBFS_INTENB1_ATTCHE_Pos = 0xb
	// Bit mask of ATTCHE field.
	USBFS_INTENB1_ATTCHE_Msk = 0x800
	// Bit ATTCHE.
	USBFS_INTENB1_ATTCHE = 0x800
	// Disable interrupt request
	USBFS_INTENB1_ATTCHE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB1_ATTCHE_1 = 0x1
	// Position of DTCHE field.
	USBFS_INTENB1_DTCHE_Pos = 0xc
	// Bit mask of DTCHE field.
	USBFS_INTENB1_DTCHE_Msk = 0x1000
	// Bit DTCHE.
	USBFS_INTENB1_DTCHE = 0x1000
	// Disable interrupt request
	USBFS_INTENB1_DTCHE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB1_DTCHE_1 = 0x1
	// Position of BCHGE field.
	USBFS_INTENB1_BCHGE_Pos = 0xe
	// Bit mask of BCHGE field.
	USBFS_INTENB1_BCHGE_Msk = 0x4000
	// Bit BCHGE.
	USBFS_INTENB1_BCHGE = 0x4000
	// Disable interrupt request
	USBFS_INTENB1_BCHGE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB1_BCHGE_1 = 0x1
	// Position of OVRCRE field.
	USBFS_INTENB1_OVRCRE_Pos = 0xf
	// Bit mask of OVRCRE field.
	USBFS_INTENB1_OVRCRE_Msk = 0x8000
	// Bit OVRCRE.
	USBFS_INTENB1_OVRCRE = 0x8000
	// Disable interrupt request
	USBFS_INTENB1_OVRCRE_0 = 0x0
	// Enable interrupt request
	USBFS_INTENB1_OVRCRE_1 = 0x1

	// BRDYENB: BRDY Interrupt Enable Register
	// Position of PIPE0BRDYE field.
	USBFS_BRDYENB_PIPE0BRDYE_Pos = 0x0
	// Bit mask of PIPE0BRDYE field.
	USBFS_BRDYENB_PIPE0BRDYE_Msk = 0x1
	// Bit PIPE0BRDYE.
	USBFS_BRDYENB_PIPE0BRDYE = 0x1
	// Disable interrupt request
	USBFS_BRDYENB_PIPE0BRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_BRDYENB_PIPE0BRDYE_1 = 0x1
	// Position of PIPE1BRDYE field.
	USBFS_BRDYENB_PIPE1BRDYE_Pos = 0x1
	// Bit mask of PIPE1BRDYE field.
	USBFS_BRDYENB_PIPE1BRDYE_Msk = 0x2
	// Bit PIPE1BRDYE.
	USBFS_BRDYENB_PIPE1BRDYE = 0x2
	// Disable interrupt request
	USBFS_BRDYENB_PIPE1BRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_BRDYENB_PIPE1BRDYE_1 = 0x1
	// Position of PIPE2BRDYE field.
	USBFS_BRDYENB_PIPE2BRDYE_Pos = 0x2
	// Bit mask of PIPE2BRDYE field.
	USBFS_BRDYENB_PIPE2BRDYE_Msk = 0x4
	// Bit PIPE2BRDYE.
	USBFS_BRDYENB_PIPE2BRDYE = 0x4
	// Disable interrupt request
	USBFS_BRDYENB_PIPE2BRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_BRDYENB_PIPE2BRDYE_1 = 0x1
	// Position of PIPE3BRDYE field.
	USBFS_BRDYENB_PIPE3BRDYE_Pos = 0x3
	// Bit mask of PIPE3BRDYE field.
	USBFS_BRDYENB_PIPE3BRDYE_Msk = 0x8
	// Bit PIPE3BRDYE.
	USBFS_BRDYENB_PIPE3BRDYE = 0x8
	// Disable interrupt request
	USBFS_BRDYENB_PIPE3BRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_BRDYENB_PIPE3BRDYE_1 = 0x1
	// Position of PIPE4BRDYE field.
	USBFS_BRDYENB_PIPE4BRDYE_Pos = 0x4
	// Bit mask of PIPE4BRDYE field.
	USBFS_BRDYENB_PIPE4BRDYE_Msk = 0x10
	// Bit PIPE4BRDYE.
	USBFS_BRDYENB_PIPE4BRDYE = 0x10
	// Disable interrupt request
	USBFS_BRDYENB_PIPE4BRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_BRDYENB_PIPE4BRDYE_1 = 0x1
	// Position of PIPE5BRDYE field.
	USBFS_BRDYENB_PIPE5BRDYE_Pos = 0x5
	// Bit mask of PIPE5BRDYE field.
	USBFS_BRDYENB_PIPE5BRDYE_Msk = 0x20
	// Bit PIPE5BRDYE.
	USBFS_BRDYENB_PIPE5BRDYE = 0x20
	// Disable interrupt request
	USBFS_BRDYENB_PIPE5BRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_BRDYENB_PIPE5BRDYE_1 = 0x1
	// Position of PIPE6BRDYE field.
	USBFS_BRDYENB_PIPE6BRDYE_Pos = 0x6
	// Bit mask of PIPE6BRDYE field.
	USBFS_BRDYENB_PIPE6BRDYE_Msk = 0x40
	// Bit PIPE6BRDYE.
	USBFS_BRDYENB_PIPE6BRDYE = 0x40
	// Disable interrupt request
	USBFS_BRDYENB_PIPE6BRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_BRDYENB_PIPE6BRDYE_1 = 0x1
	// Position of PIPE7BRDYE field.
	USBFS_BRDYENB_PIPE7BRDYE_Pos = 0x7
	// Bit mask of PIPE7BRDYE field.
	USBFS_BRDYENB_PIPE7BRDYE_Msk = 0x80
	// Bit PIPE7BRDYE.
	USBFS_BRDYENB_PIPE7BRDYE = 0x80
	// Disable interrupt request
	USBFS_BRDYENB_PIPE7BRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_BRDYENB_PIPE7BRDYE_1 = 0x1
	// Position of PIPE8BRDYE field.
	USBFS_BRDYENB_PIPE8BRDYE_Pos = 0x8
	// Bit mask of PIPE8BRDYE field.
	USBFS_BRDYENB_PIPE8BRDYE_Msk = 0x100
	// Bit PIPE8BRDYE.
	USBFS_BRDYENB_PIPE8BRDYE = 0x100
	// Disable interrupt request
	USBFS_BRDYENB_PIPE8BRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_BRDYENB_PIPE8BRDYE_1 = 0x1
	// Position of PIPE9BRDYE field.
	USBFS_BRDYENB_PIPE9BRDYE_Pos = 0x9
	// Bit mask of PIPE9BRDYE field.
	USBFS_BRDYENB_PIPE9BRDYE_Msk = 0x200
	// Bit PIPE9BRDYE.
	USBFS_BRDYENB_PIPE9BRDYE = 0x200
	// Disable interrupt request
	USBFS_BRDYENB_PIPE9BRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_BRDYENB_PIPE9BRDYE_1 = 0x1

	// NRDYENB: NRDY Interrupt Enable Register
	// Position of PIPE0NRDYE field.
	USBFS_NRDYENB_PIPE0NRDYE_Pos = 0x0
	// Bit mask of PIPE0NRDYE field.
	USBFS_NRDYENB_PIPE0NRDYE_Msk = 0x1
	// Bit PIPE0NRDYE.
	USBFS_NRDYENB_PIPE0NRDYE = 0x1
	// Disable interrupt request
	USBFS_NRDYENB_PIPE0NRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_NRDYENB_PIPE0NRDYE_1 = 0x1
	// Position of PIPE1NRDYE field.
	USBFS_NRDYENB_PIPE1NRDYE_Pos = 0x1
	// Bit mask of PIPE1NRDYE field.
	USBFS_NRDYENB_PIPE1NRDYE_Msk = 0x2
	// Bit PIPE1NRDYE.
	USBFS_NRDYENB_PIPE1NRDYE = 0x2
	// Disable interrupt request
	USBFS_NRDYENB_PIPE1NRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_NRDYENB_PIPE1NRDYE_1 = 0x1
	// Position of PIPE2NRDYE field.
	USBFS_NRDYENB_PIPE2NRDYE_Pos = 0x2
	// Bit mask of PIPE2NRDYE field.
	USBFS_NRDYENB_PIPE2NRDYE_Msk = 0x4
	// Bit PIPE2NRDYE.
	USBFS_NRDYENB_PIPE2NRDYE = 0x4
	// Disable interrupt request
	USBFS_NRDYENB_PIPE2NRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_NRDYENB_PIPE2NRDYE_1 = 0x1
	// Position of PIPE3NRDYE field.
	USBFS_NRDYENB_PIPE3NRDYE_Pos = 0x3
	// Bit mask of PIPE3NRDYE field.
	USBFS_NRDYENB_PIPE3NRDYE_Msk = 0x8
	// Bit PIPE3NRDYE.
	USBFS_NRDYENB_PIPE3NRDYE = 0x8
	// Disable interrupt request
	USBFS_NRDYENB_PIPE3NRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_NRDYENB_PIPE3NRDYE_1 = 0x1
	// Position of PIPE4NRDYE field.
	USBFS_NRDYENB_PIPE4NRDYE_Pos = 0x4
	// Bit mask of PIPE4NRDYE field.
	USBFS_NRDYENB_PIPE4NRDYE_Msk = 0x10
	// Bit PIPE4NRDYE.
	USBFS_NRDYENB_PIPE4NRDYE = 0x10
	// Disable interrupt request
	USBFS_NRDYENB_PIPE4NRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_NRDYENB_PIPE4NRDYE_1 = 0x1
	// Position of PIPE5NRDYE field.
	USBFS_NRDYENB_PIPE5NRDYE_Pos = 0x5
	// Bit mask of PIPE5NRDYE field.
	USBFS_NRDYENB_PIPE5NRDYE_Msk = 0x20
	// Bit PIPE5NRDYE.
	USBFS_NRDYENB_PIPE5NRDYE = 0x20
	// Disable interrupt request
	USBFS_NRDYENB_PIPE5NRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_NRDYENB_PIPE5NRDYE_1 = 0x1
	// Position of PIPE6NRDYE field.
	USBFS_NRDYENB_PIPE6NRDYE_Pos = 0x6
	// Bit mask of PIPE6NRDYE field.
	USBFS_NRDYENB_PIPE6NRDYE_Msk = 0x40
	// Bit PIPE6NRDYE.
	USBFS_NRDYENB_PIPE6NRDYE = 0x40
	// Disable interrupt request
	USBFS_NRDYENB_PIPE6NRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_NRDYENB_PIPE6NRDYE_1 = 0x1
	// Position of PIPE7NRDYE field.
	USBFS_NRDYENB_PIPE7NRDYE_Pos = 0x7
	// Bit mask of PIPE7NRDYE field.
	USBFS_NRDYENB_PIPE7NRDYE_Msk = 0x80
	// Bit PIPE7NRDYE.
	USBFS_NRDYENB_PIPE7NRDYE = 0x80
	// Disable interrupt request
	USBFS_NRDYENB_PIPE7NRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_NRDYENB_PIPE7NRDYE_1 = 0x1
	// Position of PIPE8NRDYE field.
	USBFS_NRDYENB_PIPE8NRDYE_Pos = 0x8
	// Bit mask of PIPE8NRDYE field.
	USBFS_NRDYENB_PIPE8NRDYE_Msk = 0x100
	// Bit PIPE8NRDYE.
	USBFS_NRDYENB_PIPE8NRDYE = 0x100
	// Disable interrupt request
	USBFS_NRDYENB_PIPE8NRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_NRDYENB_PIPE8NRDYE_1 = 0x1
	// Position of PIPE9NRDYE field.
	USBFS_NRDYENB_PIPE9NRDYE_Pos = 0x9
	// Bit mask of PIPE9NRDYE field.
	USBFS_NRDYENB_PIPE9NRDYE_Msk = 0x200
	// Bit PIPE9NRDYE.
	USBFS_NRDYENB_PIPE9NRDYE = 0x200
	// Disable interrupt request
	USBFS_NRDYENB_PIPE9NRDYE_0 = 0x0
	// Enable interrupt request
	USBFS_NRDYENB_PIPE9NRDYE_1 = 0x1

	// BEMPENB: BEMP Interrupt Enable Register
	// Position of PIPE0BEMPE field.
	USBFS_BEMPENB_PIPE0BEMPE_Pos = 0x0
	// Bit mask of PIPE0BEMPE field.
	USBFS_BEMPENB_PIPE0BEMPE_Msk = 0x1
	// Bit PIPE0BEMPE.
	USBFS_BEMPENB_PIPE0BEMPE = 0x1
	// Disable interrupt request
	USBFS_BEMPENB_PIPE0BEMPE_0 = 0x0
	// Enable interrupt request
	USBFS_BEMPENB_PIPE0BEMPE_1 = 0x1
	// Position of PIPE1BEMPE field.
	USBFS_BEMPENB_PIPE1BEMPE_Pos = 0x1
	// Bit mask of PIPE1BEMPE field.
	USBFS_BEMPENB_PIPE1BEMPE_Msk = 0x2
	// Bit PIPE1BEMPE.
	USBFS_BEMPENB_PIPE1BEMPE = 0x2
	// Disable interrupt request
	USBFS_BEMPENB_PIPE1BEMPE_0 = 0x0
	// Enable interrupt request
	USBFS_BEMPENB_PIPE1BEMPE_1 = 0x1
	// Position of PIPE2BEMPE field.
	USBFS_BEMPENB_PIPE2BEMPE_Pos = 0x2
	// Bit mask of PIPE2BEMPE field.
	USBFS_BEMPENB_PIPE2BEMPE_Msk = 0x4
	// Bit PIPE2BEMPE.
	USBFS_BEMPENB_PIPE2BEMPE = 0x4
	// Disable interrupt request
	USBFS_BEMPENB_PIPE2BEMPE_0 = 0x0
	// Enable interrupt request
	USBFS_BEMPENB_PIPE2BEMPE_1 = 0x1
	// Position of PIPE3BEMPE field.
	USBFS_BEMPENB_PIPE3BEMPE_Pos = 0x3
	// Bit mask of PIPE3BEMPE field.
	USBFS_BEMPENB_PIPE3BEMPE_Msk = 0x8
	// Bit PIPE3BEMPE.
	USBFS_BEMPENB_PIPE3BEMPE = 0x8
	// Disable interrupt request
	USBFS_BEMPENB_PIPE3BEMPE_0 = 0x0
	// Enable interrupt request
	USBFS_BEMPENB_PIPE3BEMPE_1 = 0x1
	// Position of PIPE4BEMPE field.
	USBFS_BEMPENB_PIPE4BEMPE_Pos = 0x4
	// Bit mask of PIPE4BEMPE field.
	USBFS_BEMPENB_PIPE4BEMPE_Msk = 0x10
	// Bit PIPE4BEMPE.
	USBFS_BEMPENB_PIPE4BEMPE = 0x10
	// Disable interrupt request
	USBFS_BEMPENB_PIPE4BEMPE_0 = 0x0
	// Enable interrupt request
	USBFS_BEMPENB_PIPE4BEMPE_1 = 0x1
	// Position of PIPE5BEMPE field.
	USBFS_BEMPENB_PIPE5BEMPE_Pos = 0x5
	// Bit mask of PIPE5BEMPE field.
	USBFS_BEMPENB_PIPE5BEMPE_Msk = 0x20
	// Bit PIPE5BEMPE.
	USBFS_BEMPENB_PIPE5BEMPE = 0x20
	// Disable interrupt request
	USBFS_BEMPENB_PIPE5BEMPE_0 = 0x0
	// Enable interrupt request
	USBFS_BEMPENB_PIPE5BEMPE_1 = 0x1
	// Position of PIPE6BEMPE field.
	USBFS_BEMPENB_PIPE6BEMPE_Pos = 0x6
	// Bit mask of PIPE6BEMPE field.
	USBFS_BEMPENB_PIPE6BEMPE_Msk = 0x40
	// Bit PIPE6BEMPE.
	USBFS_BEMPENB_PIPE6BEMPE = 0x40
	// Disable interrupt request
	USBFS_BEMPENB_PIPE6BEMPE_0 = 0x0
	// Enable interrupt request
	USBFS_BEMPENB_PIPE6BEMPE_1 = 0x1
	// Position of PIPE7BEMPE field.
	USBFS_BEMPENB_PIPE7BEMPE_Pos = 0x7
	// Bit mask of PIPE7BEMPE field.
	USBFS_BEMPENB_PIPE7BEMPE_Msk = 0x80
	// Bit PIPE7BEMPE.
	USBFS_BEMPENB_PIPE7BEMPE = 0x80
	// Disable interrupt request
	USBFS_BEMPENB_PIPE7BEMPE_0 = 0x0
	// Enable interrupt request
	USBFS_BEMPENB_PIPE7BEMPE_1 = 0x1
	// Position of PIPE8BEMPE field.
	USBFS_BEMPENB_PIPE8BEMPE_Pos = 0x8
	// Bit mask of PIPE8BEMPE field.
	USBFS_BEMPENB_PIPE8BEMPE_Msk = 0x100
	// Bit PIPE8BEMPE.
	USBFS_BEMPENB_PIPE8BEMPE = 0x100
	// Disable interrupt request
	USBFS_BEMPENB_PIPE8BEMPE_0 = 0x0
	// Enable interrupt request
	USBFS_BEMPENB_PIPE8BEMPE_1 = 0x1
	// Position of PIPE9BEMPE field.
	USBFS_BEMPENB_PIPE9BEMPE_Pos = 0x9
	// Bit mask of PIPE9BEMPE field.
	USBFS_BEMPENB_PIPE9BEMPE_Msk = 0x200
	// Bit PIPE9BEMPE.
	USBFS_BEMPENB_PIPE9BEMPE = 0x200
	// Disable interrupt request
	USBFS_BEMPENB_PIPE9BEMPE_0 = 0x0
	// Enable interrupt request
	USBFS_BEMPENB_PIPE9BEMPE_1 = 0x1

	// SOFCFG: SOF Output Configuration Register
	// Position of EDGESTS field.
	USBFS_SOFCFG_EDGESTS_Pos = 0x4
	// Bit mask of EDGESTS field.
	USBFS_SOFCFG_EDGESTS_Msk = 0x10
	// Bit EDGESTS.
	USBFS_SOFCFG_EDGESTS = 0x10
	// Position of BRDYM field.
	USBFS_SOFCFG_BRDYM_Pos = 0x6
	// Bit mask of BRDYM field.
	USBFS_SOFCFG_BRDYM_Msk = 0x40
	// Bit BRDYM.
	USBFS_SOFCFG_BRDYM = 0x40
	// Clear BRDY flag by software
	USBFS_SOFCFG_BRDYM_0 = 0x0
	// Clear BRDY flag by the USBFS through a data read from the FIFO buffer or data write to the FIFO buffer
	USBFS_SOFCFG_BRDYM_1 = 0x1
	// Position of TRNENSEL field.
	USBFS_SOFCFG_TRNENSEL_Pos = 0x8
	// Bit mask of TRNENSEL field.
	USBFS_SOFCFG_TRNENSEL_Msk = 0x100
	// Bit TRNENSEL.
	USBFS_SOFCFG_TRNENSEL = 0x100
	// Not low-speed communication
	USBFS_SOFCFG_TRNENSEL_0 = 0x0
	// Low-speed communication
	USBFS_SOFCFG_TRNENSEL_1 = 0x1

	// INTSTS0: Interrupt Status Register 0
	// Position of CTSQ field.
	USBFS_INTSTS0_CTSQ_Pos = 0x0
	// Bit mask of CTSQ field.
	USBFS_INTSTS0_CTSQ_Msk = 0x7
	// Idle or setup stage
	USBFS_INTSTS0_CTSQ_000 = 0x0
	// Control read data stage
	USBFS_INTSTS0_CTSQ_001 = 0x1
	// Control read status stage
	USBFS_INTSTS0_CTSQ_010 = 0x2
	// Control write data stage
	USBFS_INTSTS0_CTSQ_011 = 0x3
	// Control write status stage
	USBFS_INTSTS0_CTSQ_100 = 0x4
	// Control write (no data) status stage
	USBFS_INTSTS0_CTSQ_101 = 0x5
	// Control transfer sequence error
	USBFS_INTSTS0_CTSQ_110 = 0x6
	// Position of VALID field.
	USBFS_INTSTS0_VALID_Pos = 0x3
	// Bit mask of VALID field.
	USBFS_INTSTS0_VALID_Msk = 0x8
	// Bit VALID.
	USBFS_INTSTS0_VALID = 0x8
	// Setup packet not received
	USBFS_INTSTS0_VALID_0 = 0x0
	// Setup packet received
	USBFS_INTSTS0_VALID_1 = 0x1
	// Position of DVSQ field.
	USBFS_INTSTS0_DVSQ_Pos = 0x4
	// Bit mask of DVSQ field.
	USBFS_INTSTS0_DVSQ_Msk = 0x70
	// Powered state
	USBFS_INTSTS0_DVSQ_000 = 0x0
	// Default state
	USBFS_INTSTS0_DVSQ_001 = 0x1
	// Address state
	USBFS_INTSTS0_DVSQ_010 = 0x2
	// Configured state
	USBFS_INTSTS0_DVSQ_011 = 0x3
	// Position of VBSTS field.
	USBFS_INTSTS0_VBSTS_Pos = 0x7
	// Bit mask of VBSTS field.
	USBFS_INTSTS0_VBSTS_Msk = 0x80
	// Bit VBSTS.
	USBFS_INTSTS0_VBSTS = 0x80
	// USB_VBUS pin is low
	USBFS_INTSTS0_VBSTS_0 = 0x0
	// USB_VBUS pin is high
	USBFS_INTSTS0_VBSTS_1 = 0x1
	// Position of BRDY field.
	USBFS_INTSTS0_BRDY_Pos = 0x8
	// Bit mask of BRDY field.
	USBFS_INTSTS0_BRDY_Msk = 0x100
	// Bit BRDY.
	USBFS_INTSTS0_BRDY = 0x100
	// No BRDY interrupt occurred
	USBFS_INTSTS0_BRDY_0 = 0x0
	// BRDY interrupt occurred
	USBFS_INTSTS0_BRDY_1 = 0x1
	// Position of NRDY field.
	USBFS_INTSTS0_NRDY_Pos = 0x9
	// Bit mask of NRDY field.
	USBFS_INTSTS0_NRDY_Msk = 0x200
	// Bit NRDY.
	USBFS_INTSTS0_NRDY = 0x200
	// No NRDY interrupt occurred
	USBFS_INTSTS0_NRDY_0 = 0x0
	// NRDY interrupt occurred
	USBFS_INTSTS0_NRDY_1 = 0x1
	// Position of BEMP field.
	USBFS_INTSTS0_BEMP_Pos = 0xa
	// Bit mask of BEMP field.
	USBFS_INTSTS0_BEMP_Msk = 0x400
	// Bit BEMP.
	USBFS_INTSTS0_BEMP = 0x400
	// No BEMP interrupt occurred
	USBFS_INTSTS0_BEMP_0 = 0x0
	// BEMP interrupt occurred
	USBFS_INTSTS0_BEMP_1 = 0x1
	// Position of CTRT field.
	USBFS_INTSTS0_CTRT_Pos = 0xb
	// Bit mask of CTRT field.
	USBFS_INTSTS0_CTRT_Msk = 0x800
	// Bit CTRT.
	USBFS_INTSTS0_CTRT = 0x800
	// No control transfer stage transition interrupt occurred
	USBFS_INTSTS0_CTRT_0 = 0x0
	// Control transfer stage transition interrupt occurred
	USBFS_INTSTS0_CTRT_1 = 0x1
	// Position of DVST field.
	USBFS_INTSTS0_DVST_Pos = 0xc
	// Bit mask of DVST field.
	USBFS_INTSTS0_DVST_Msk = 0x1000
	// Bit DVST.
	USBFS_INTSTS0_DVST = 0x1000
	// No device state transition interrupt occurred
	USBFS_INTSTS0_DVST_0 = 0x0
	// Device state transition interrupt occurred
	USBFS_INTSTS0_DVST_1 = 0x1
	// Position of SOFR field.
	USBFS_INTSTS0_SOFR_Pos = 0xd
	// Bit mask of SOFR field.
	USBFS_INTSTS0_SOFR_Msk = 0x2000
	// Bit SOFR.
	USBFS_INTSTS0_SOFR = 0x2000
	// No SOF interrupt occurred
	USBFS_INTSTS0_SOFR_0 = 0x0
	// SOF interrupt occurred
	USBFS_INTSTS0_SOFR_1 = 0x1
	// Position of RESM field.
	USBFS_INTSTS0_RESM_Pos = 0xe
	// Bit mask of RESM field.
	USBFS_INTSTS0_RESM_Msk = 0x4000
	// Bit RESM.
	USBFS_INTSTS0_RESM = 0x4000
	// No resume interrupt occurred
	USBFS_INTSTS0_RESM_0 = 0x0
	// Resume interrupt occurred
	USBFS_INTSTS0_RESM_1 = 0x1
	// Position of VBINT field.
	USBFS_INTSTS0_VBINT_Pos = 0xf
	// Bit mask of VBINT field.
	USBFS_INTSTS0_VBINT_Msk = 0x8000
	// Bit VBINT.
	USBFS_INTSTS0_VBINT = 0x8000
	// No VBUS interrupt occurred
	USBFS_INTSTS0_VBINT_0 = 0x0
	// VBUS interrupt occurred
	USBFS_INTSTS0_VBINT_1 = 0x1

	// INTSTS1: Interrupt Status Register 1
	// Position of PDDETINT field.
	USBFS_INTSTS1_PDDETINT_Pos = 0x0
	// Bit mask of PDDETINT field.
	USBFS_INTSTS1_PDDETINT_Msk = 0x1
	// Bit PDDETINT.
	USBFS_INTSTS1_PDDETINT = 0x1
	// No PDDET interrupt occurred
	USBFS_INTSTS1_PDDETINT_0 = 0x0
	// PDDET interrupt occurred
	USBFS_INTSTS1_PDDETINT_1 = 0x1
	// Position of SACK field.
	USBFS_INTSTS1_SACK_Pos = 0x4
	// Bit mask of SACK field.
	USBFS_INTSTS1_SACK_Msk = 0x10
	// Bit SACK.
	USBFS_INTSTS1_SACK = 0x10
	// No SACK interrupt occurred
	USBFS_INTSTS1_SACK_0 = 0x0
	// SACK interrupt occurred
	USBFS_INTSTS1_SACK_1 = 0x1
	// Position of SIGN field.
	USBFS_INTSTS1_SIGN_Pos = 0x5
	// Bit mask of SIGN field.
	USBFS_INTSTS1_SIGN_Msk = 0x20
	// Bit SIGN.
	USBFS_INTSTS1_SIGN = 0x20
	// No SIGN interrupt occurred
	USBFS_INTSTS1_SIGN_0 = 0x0
	// SIGN interrupt occurred
	USBFS_INTSTS1_SIGN_1 = 0x1
	// Position of EOFERR field.
	USBFS_INTSTS1_EOFERR_Pos = 0x6
	// Bit mask of EOFERR field.
	USBFS_INTSTS1_EOFERR_Msk = 0x40
	// Bit EOFERR.
	USBFS_INTSTS1_EOFERR = 0x40
	// No EOFERR interrupt occurred
	USBFS_INTSTS1_EOFERR_0 = 0x0
	// EOFERR interrupt occurred
	USBFS_INTSTS1_EOFERR_1 = 0x1
	// Position of ATTCH field.
	USBFS_INTSTS1_ATTCH_Pos = 0xb
	// Bit mask of ATTCH field.
	USBFS_INTSTS1_ATTCH_Msk = 0x800
	// Bit ATTCH.
	USBFS_INTSTS1_ATTCH = 0x800
	// No ATTCH interrupt occurred
	USBFS_INTSTS1_ATTCH_0 = 0x0
	// ATTCH interrupt occurred
	USBFS_INTSTS1_ATTCH_1 = 0x1
	// Position of DTCH field.
	USBFS_INTSTS1_DTCH_Pos = 0xc
	// Bit mask of DTCH field.
	USBFS_INTSTS1_DTCH_Msk = 0x1000
	// Bit DTCH.
	USBFS_INTSTS1_DTCH = 0x1000
	// No DTCH interrupt occurred
	USBFS_INTSTS1_DTCH_0 = 0x0
	// DTCH interrupt occurred
	USBFS_INTSTS1_DTCH_1 = 0x1
	// Position of BCHG field.
	USBFS_INTSTS1_BCHG_Pos = 0xe
	// Bit mask of BCHG field.
	USBFS_INTSTS1_BCHG_Msk = 0x4000
	// Bit BCHG.
	USBFS_INTSTS1_BCHG = 0x4000
	// No BCHG interrupt occurred
	USBFS_INTSTS1_BCHG_0 = 0x0
	// BCHG interrupt occurred
	USBFS_INTSTS1_BCHG_1 = 0x1
	// Position of OVRCR field.
	USBFS_INTSTS1_OVRCR_Pos = 0xf
	// Bit mask of OVRCR field.
	USBFS_INTSTS1_OVRCR_Msk = 0x8000
	// Bit OVRCR.
	USBFS_INTSTS1_OVRCR = 0x8000
	// No OVRCR interrupt occurred
	USBFS_INTSTS1_OVRCR_0 = 0x0
	// OVRCR interrupt occurred
	USBFS_INTSTS1_OVRCR_1 = 0x1

	// BRDYSTS: BRDY Interrupt Status Register
	// Position of PIPE0BRDY field.
	USBFS_BRDYSTS_PIPE0BRDY_Pos = 0x0
	// Bit mask of PIPE0BRDY field.
	USBFS_BRDYSTS_PIPE0BRDY_Msk = 0x1
	// Bit PIPE0BRDY.
	USBFS_BRDYSTS_PIPE0BRDY = 0x1
	// No BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE0BRDY_0 = 0x0
	// BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE0BRDY_1 = 0x1
	// Position of PIPE1BRDY field.
	USBFS_BRDYSTS_PIPE1BRDY_Pos = 0x1
	// Bit mask of PIPE1BRDY field.
	USBFS_BRDYSTS_PIPE1BRDY_Msk = 0x2
	// Bit PIPE1BRDY.
	USBFS_BRDYSTS_PIPE1BRDY = 0x2
	// No BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE1BRDY_0 = 0x0
	// BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE1BRDY_1 = 0x1
	// Position of PIPE2BRDY field.
	USBFS_BRDYSTS_PIPE2BRDY_Pos = 0x2
	// Bit mask of PIPE2BRDY field.
	USBFS_BRDYSTS_PIPE2BRDY_Msk = 0x4
	// Bit PIPE2BRDY.
	USBFS_BRDYSTS_PIPE2BRDY = 0x4
	// No BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE2BRDY_0 = 0x0
	// BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE2BRDY_1 = 0x1
	// Position of PIPE3BRDY field.
	USBFS_BRDYSTS_PIPE3BRDY_Pos = 0x3
	// Bit mask of PIPE3BRDY field.
	USBFS_BRDYSTS_PIPE3BRDY_Msk = 0x8
	// Bit PIPE3BRDY.
	USBFS_BRDYSTS_PIPE3BRDY = 0x8
	// No BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE3BRDY_0 = 0x0
	// BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE3BRDY_1 = 0x1
	// Position of PIPE4BRDY field.
	USBFS_BRDYSTS_PIPE4BRDY_Pos = 0x4
	// Bit mask of PIPE4BRDY field.
	USBFS_BRDYSTS_PIPE4BRDY_Msk = 0x10
	// Bit PIPE4BRDY.
	USBFS_BRDYSTS_PIPE4BRDY = 0x10
	// No BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE4BRDY_0 = 0x0
	// BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE4BRDY_1 = 0x1
	// Position of PIPE5BRDY field.
	USBFS_BRDYSTS_PIPE5BRDY_Pos = 0x5
	// Bit mask of PIPE5BRDY field.
	USBFS_BRDYSTS_PIPE5BRDY_Msk = 0x20
	// Bit PIPE5BRDY.
	USBFS_BRDYSTS_PIPE5BRDY = 0x20
	// No BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE5BRDY_0 = 0x0
	// BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE5BRDY_1 = 0x1
	// Position of PIPE6BRDY field.
	USBFS_BRDYSTS_PIPE6BRDY_Pos = 0x6
	// Bit mask of PIPE6BRDY field.
	USBFS_BRDYSTS_PIPE6BRDY_Msk = 0x40
	// Bit PIPE6BRDY.
	USBFS_BRDYSTS_PIPE6BRDY = 0x40
	// No BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE6BRDY_0 = 0x0
	// BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE6BRDY_1 = 0x1
	// Position of PIPE7BRDY field.
	USBFS_BRDYSTS_PIPE7BRDY_Pos = 0x7
	// Bit mask of PIPE7BRDY field.
	USBFS_BRDYSTS_PIPE7BRDY_Msk = 0x80
	// Bit PIPE7BRDY.
	USBFS_BRDYSTS_PIPE7BRDY = 0x80
	// No BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE7BRDY_0 = 0x0
	// BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE7BRDY_1 = 0x1
	// Position of PIPE8BRDY field.
	USBFS_BRDYSTS_PIPE8BRDY_Pos = 0x8
	// Bit mask of PIPE8BRDY field.
	USBFS_BRDYSTS_PIPE8BRDY_Msk = 0x100
	// Bit PIPE8BRDY.
	USBFS_BRDYSTS_PIPE8BRDY = 0x100
	// No BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE8BRDY_0 = 0x0
	// BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE8BRDY_1 = 0x1
	// Position of PIPE9BRDY field.
	USBFS_BRDYSTS_PIPE9BRDY_Pos = 0x9
	// Bit mask of PIPE9BRDY field.
	USBFS_BRDYSTS_PIPE9BRDY_Msk = 0x200
	// Bit PIPE9BRDY.
	USBFS_BRDYSTS_PIPE9BRDY = 0x200
	// No BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE9BRDY_0 = 0x0
	// BRDY interrupt occurred
	USBFS_BRDYSTS_PIPE9BRDY_1 = 0x1

	// NRDYSTS: NRDY Interrupt Status Register
	// Position of PIPE0NRDY field.
	USBFS_NRDYSTS_PIPE0NRDY_Pos = 0x0
	// Bit mask of PIPE0NRDY field.
	USBFS_NRDYSTS_PIPE0NRDY_Msk = 0x1
	// Bit PIPE0NRDY.
	USBFS_NRDYSTS_PIPE0NRDY = 0x1
	// No NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE0NRDY_0 = 0x0
	// NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE0NRDY_1 = 0x1
	// Position of PIPE1NRDY field.
	USBFS_NRDYSTS_PIPE1NRDY_Pos = 0x1
	// Bit mask of PIPE1NRDY field.
	USBFS_NRDYSTS_PIPE1NRDY_Msk = 0x2
	// Bit PIPE1NRDY.
	USBFS_NRDYSTS_PIPE1NRDY = 0x2
	// No NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE1NRDY_0 = 0x0
	// NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE1NRDY_1 = 0x1
	// Position of PIPE2NRDY field.
	USBFS_NRDYSTS_PIPE2NRDY_Pos = 0x2
	// Bit mask of PIPE2NRDY field.
	USBFS_NRDYSTS_PIPE2NRDY_Msk = 0x4
	// Bit PIPE2NRDY.
	USBFS_NRDYSTS_PIPE2NRDY = 0x4
	// No NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE2NRDY_0 = 0x0
	// NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE2NRDY_1 = 0x1
	// Position of PIPE3NRDY field.
	USBFS_NRDYSTS_PIPE3NRDY_Pos = 0x3
	// Bit mask of PIPE3NRDY field.
	USBFS_NRDYSTS_PIPE3NRDY_Msk = 0x8
	// Bit PIPE3NRDY.
	USBFS_NRDYSTS_PIPE3NRDY = 0x8
	// No NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE3NRDY_0 = 0x0
	// NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE3NRDY_1 = 0x1
	// Position of PIPE4NRDY field.
	USBFS_NRDYSTS_PIPE4NRDY_Pos = 0x4
	// Bit mask of PIPE4NRDY field.
	USBFS_NRDYSTS_PIPE4NRDY_Msk = 0x10
	// Bit PIPE4NRDY.
	USBFS_NRDYSTS_PIPE4NRDY = 0x10
	// No NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE4NRDY_0 = 0x0
	// NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE4NRDY_1 = 0x1
	// Position of PIPE5NRDY field.
	USBFS_NRDYSTS_PIPE5NRDY_Pos = 0x5
	// Bit mask of PIPE5NRDY field.
	USBFS_NRDYSTS_PIPE5NRDY_Msk = 0x20
	// Bit PIPE5NRDY.
	USBFS_NRDYSTS_PIPE5NRDY = 0x20
	// No NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE5NRDY_0 = 0x0
	// NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE5NRDY_1 = 0x1
	// Position of PIPE6NRDY field.
	USBFS_NRDYSTS_PIPE6NRDY_Pos = 0x6
	// Bit mask of PIPE6NRDY field.
	USBFS_NRDYSTS_PIPE6NRDY_Msk = 0x40
	// Bit PIPE6NRDY.
	USBFS_NRDYSTS_PIPE6NRDY = 0x40
	// No NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE6NRDY_0 = 0x0
	// NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE6NRDY_1 = 0x1
	// Position of PIPE7NRDY field.
	USBFS_NRDYSTS_PIPE7NRDY_Pos = 0x7
	// Bit mask of PIPE7NRDY field.
	USBFS_NRDYSTS_PIPE7NRDY_Msk = 0x80
	// Bit PIPE7NRDY.
	USBFS_NRDYSTS_PIPE7NRDY = 0x80
	// No NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE7NRDY_0 = 0x0
	// NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE7NRDY_1 = 0x1
	// Position of PIPE8NRDY field.
	USBFS_NRDYSTS_PIPE8NRDY_Pos = 0x8
	// Bit mask of PIPE8NRDY field.
	USBFS_NRDYSTS_PIPE8NRDY_Msk = 0x100
	// Bit PIPE8NRDY.
	USBFS_NRDYSTS_PIPE8NRDY = 0x100
	// No NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE8NRDY_0 = 0x0
	// NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE8NRDY_1 = 0x1
	// Position of PIPE9NRDY field.
	USBFS_NRDYSTS_PIPE9NRDY_Pos = 0x9
	// Bit mask of PIPE9NRDY field.
	USBFS_NRDYSTS_PIPE9NRDY_Msk = 0x200
	// Bit PIPE9NRDY.
	USBFS_NRDYSTS_PIPE9NRDY = 0x200
	// No NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE9NRDY_0 = 0x0
	// NRDY interrupt occurred
	USBFS_NRDYSTS_PIPE9NRDY_1 = 0x1

	// BEMPSTS: BEMP Interrupt Status Register
	// Position of PIPE0BEMP field.
	USBFS_BEMPSTS_PIPE0BEMP_Pos = 0x0
	// Bit mask of PIPE0BEMP field.
	USBFS_BEMPSTS_PIPE0BEMP_Msk = 0x1
	// Bit PIPE0BEMP.
	USBFS_BEMPSTS_PIPE0BEMP = 0x1
	// No BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE0BEMP_0 = 0x0
	// BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE0BEMP_1 = 0x1
	// Position of PIPE1BEMP field.
	USBFS_BEMPSTS_PIPE1BEMP_Pos = 0x1
	// Bit mask of PIPE1BEMP field.
	USBFS_BEMPSTS_PIPE1BEMP_Msk = 0x2
	// Bit PIPE1BEMP.
	USBFS_BEMPSTS_PIPE1BEMP = 0x2
	// No BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE1BEMP_0 = 0x0
	// BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE1BEMP_1 = 0x1
	// Position of PIPE2BEMP field.
	USBFS_BEMPSTS_PIPE2BEMP_Pos = 0x2
	// Bit mask of PIPE2BEMP field.
	USBFS_BEMPSTS_PIPE2BEMP_Msk = 0x4
	// Bit PIPE2BEMP.
	USBFS_BEMPSTS_PIPE2BEMP = 0x4
	// No BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE2BEMP_0 = 0x0
	// BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE2BEMP_1 = 0x1
	// Position of PIPE3BEMP field.
	USBFS_BEMPSTS_PIPE3BEMP_Pos = 0x3
	// Bit mask of PIPE3BEMP field.
	USBFS_BEMPSTS_PIPE3BEMP_Msk = 0x8
	// Bit PIPE3BEMP.
	USBFS_BEMPSTS_PIPE3BEMP = 0x8
	// No BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE3BEMP_0 = 0x0
	// BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE3BEMP_1 = 0x1
	// Position of PIPE4BEMP field.
	USBFS_BEMPSTS_PIPE4BEMP_Pos = 0x4
	// Bit mask of PIPE4BEMP field.
	USBFS_BEMPSTS_PIPE4BEMP_Msk = 0x10
	// Bit PIPE4BEMP.
	USBFS_BEMPSTS_PIPE4BEMP = 0x10
	// No BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE4BEMP_0 = 0x0
	// BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE4BEMP_1 = 0x1
	// Position of PIPE5BEMP field.
	USBFS_BEMPSTS_PIPE5BEMP_Pos = 0x5
	// Bit mask of PIPE5BEMP field.
	USBFS_BEMPSTS_PIPE5BEMP_Msk = 0x20
	// Bit PIPE5BEMP.
	USBFS_BEMPSTS_PIPE5BEMP = 0x20
	// No BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE5BEMP_0 = 0x0
	// BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE5BEMP_1 = 0x1
	// Position of PIPE6BEMP field.
	USBFS_BEMPSTS_PIPE6BEMP_Pos = 0x6
	// Bit mask of PIPE6BEMP field.
	USBFS_BEMPSTS_PIPE6BEMP_Msk = 0x40
	// Bit PIPE6BEMP.
	USBFS_BEMPSTS_PIPE6BEMP = 0x40
	// No BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE6BEMP_0 = 0x0
	// BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE6BEMP_1 = 0x1
	// Position of PIPE7BEMP field.
	USBFS_BEMPSTS_PIPE7BEMP_Pos = 0x7
	// Bit mask of PIPE7BEMP field.
	USBFS_BEMPSTS_PIPE7BEMP_Msk = 0x80
	// Bit PIPE7BEMP.
	USBFS_BEMPSTS_PIPE7BEMP = 0x80
	// No BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE7BEMP_0 = 0x0
	// BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE7BEMP_1 = 0x1
	// Position of PIPE8BEMP field.
	USBFS_BEMPSTS_PIPE8BEMP_Pos = 0x8
	// Bit mask of PIPE8BEMP field.
	USBFS_BEMPSTS_PIPE8BEMP_Msk = 0x100
	// Bit PIPE8BEMP.
	USBFS_BEMPSTS_PIPE8BEMP = 0x100
	// No BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE8BEMP_0 = 0x0
	// BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE8BEMP_1 = 0x1
	// Position of PIPE9BEMP field.
	USBFS_BEMPSTS_PIPE9BEMP_Pos = 0x9
	// Bit mask of PIPE9BEMP field.
	USBFS_BEMPSTS_PIPE9BEMP_Msk = 0x200
	// Bit PIPE9BEMP.
	USBFS_BEMPSTS_PIPE9BEMP = 0x200
	// No BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE9BEMP_0 = 0x0
	// BEMP interrupt occurred
	USBFS_BEMPSTS_PIPE9BEMP_1 = 0x1

	// FRMNUM: Frame Number Register
	// Position of FRNM field.
	USBFS_FRMNUM_FRNM_Pos = 0x0
	// Bit mask of FRNM field.
	USBFS_FRMNUM_FRNM_Msk = 0x7ff
	// Position of CRCE field.
	USBFS_FRMNUM_CRCE_Pos = 0xe
	// Bit mask of CRCE field.
	USBFS_FRMNUM_CRCE_Msk = 0x4000
	// Bit CRCE.
	USBFS_FRMNUM_CRCE = 0x4000
	// No error occurred
	USBFS_FRMNUM_CRCE_0 = 0x0
	// Error occurred
	USBFS_FRMNUM_CRCE_1 = 0x1
	// Position of OVRN field.
	USBFS_FRMNUM_OVRN_Pos = 0xf
	// Bit mask of OVRN field.
	USBFS_FRMNUM_OVRN_Msk = 0x8000
	// Bit OVRN.
	USBFS_FRMNUM_OVRN = 0x8000
	// No error occurred
	USBFS_FRMNUM_OVRN_0 = 0x0
	// Error occurred
	USBFS_FRMNUM_OVRN_1 = 0x1

	// DVCHGR: Device State Change Register
	// Position of DVCHG field.
	USBFS_DVCHGR_DVCHG_Pos = 0xf
	// Bit mask of DVCHG field.
	USBFS_DVCHGR_DVCHG_Msk = 0x8000
	// Bit DVCHG.
	USBFS_DVCHGR_DVCHG = 0x8000
	// Disable writes to the USBADDR.STSRECOV[3:0] and USBADDR.USBADDR[6:0] bits
	USBFS_DVCHGR_DVCHG_0 = 0x0
	// Enable writes to the USBADDR.STSRECOV[3:0] and USBADDR.USBADDR[6:0] bits
	USBFS_DVCHGR_DVCHG_1 = 0x1

	// USBADDR: USB Address Register
	// Position of USBADDR field.
	USBFS_USBADDR_USBADDR_Pos = 0x0
	// Bit mask of USBADDR field.
	USBFS_USBADDR_USBADDR_Msk = 0x7f
	// Position of STSRECOV field.
	USBFS_USBADDR_STSRECOV_Pos = 0x8
	// Bit mask of STSRECOV field.
	USBFS_USBADDR_STSRECOV_Msk = 0xf00
	// Recovery in device controller mode: Setting prohibited Recovery in host controller mode: Return to the low-speed state (bits DVSTCTR0.RHST[2:0] = 001b)
	USBFS_USBADDR_STSRECOV_0x4 = 0x4
	// Recovery in device controller mode: Setting prohibited Recovery in host controller mode: Return to the full-speed state (bits DVSTCTR0.RHST[2:0] = 010b)
	USBFS_USBADDR_STSRECOV_0x8 = 0x8
	// Recovery in device controller mode: Return to the full-speed state (bits DVSTCTR0.RHST[2:0] = 010b), bits INTSTS0.DVSQ[2:0] = 001b (default state) Recovery in host controller mode: Setting prohibited
	USBFS_USBADDR_STSRECOV_0x9 = 0x9
	// Recovery in device controller mode: Return to the full-speed state (bits DVSTCTR0.RHST[2:0] = 010b), bits INTSTS0.DVSQ[2:0] = 010b (address state) Recovery in host controller mode: Setting prohibited
	USBFS_USBADDR_STSRECOV_0xA = 0xa
	// Recovery in device controller mode: Return to the full-speed state (bits DVSTCTR0.RHST[2:0] = 010b), bits INTSTS0.DVSQ[2:0] = 011b (configured state) Recovery in host controller mode: Setting prohibited
	USBFS_USBADDR_STSRECOV_0xB = 0xb

	// USBREQ: USB Request Type Register
	// Position of BMREQUESTTYPE field.
	USBFS_USBREQ_BMREQUESTTYPE_Pos = 0x0
	// Bit mask of BMREQUESTTYPE field.
	USBFS_USBREQ_BMREQUESTTYPE_Msk = 0xff
	// Position of BREQUEST field.
	USBFS_USBREQ_BREQUEST_Pos = 0x8
	// Bit mask of BREQUEST field.
	USBFS_USBREQ_BREQUEST_Msk = 0xff00

	// USBVAL: USB Request Value Register
	// Position of WVALUE field.
	USBFS_USBVAL_WVALUE_Pos = 0x0
	// Bit mask of WVALUE field.
	USBFS_USBVAL_WVALUE_Msk = 0xffff

	// USBINDX: USB Request Index Register
	// Position of WINDEX field.
	USBFS_USBINDX_WINDEX_Pos = 0x0
	// Bit mask of WINDEX field.
	USBFS_USBINDX_WINDEX_Msk = 0xffff

	// USBLENG: USB Request Length Register
	// Position of WLENTUH field.
	USBFS_USBLENG_WLENTUH_Pos = 0x0
	// Bit mask of WLENTUH field.
	USBFS_USBLENG_WLENTUH_Msk = 0xffff

	// DCPCFG: DCP Configuration Register
	// Position of DIR field.
	USBFS_DCPCFG_DIR_Pos = 0x4
	// Bit mask of DIR field.
	USBFS_DCPCFG_DIR_Msk = 0x10
	// Bit DIR.
	USBFS_DCPCFG_DIR = 0x10
	// Data receiving direction
	USBFS_DCPCFG_DIR_0 = 0x0
	// Data transmitting direction
	USBFS_DCPCFG_DIR_1 = 0x1
	// Position of SHTNAK field.
	USBFS_DCPCFG_SHTNAK_Pos = 0x7
	// Bit mask of SHTNAK field.
	USBFS_DCPCFG_SHTNAK_Msk = 0x80
	// Bit SHTNAK.
	USBFS_DCPCFG_SHTNAK = 0x80
	// Keep pipe open after transfer ends
	USBFS_DCPCFG_SHTNAK_0 = 0x0
	// Disable pipe after transfer ends
	USBFS_DCPCFG_SHTNAK_1 = 0x1

	// DCPMAXP: DCP Maximum Packet Size Register
	// Position of MXPS field.
	USBFS_DCPMAXP_MXPS_Pos = 0x0
	// Bit mask of MXPS field.
	USBFS_DCPMAXP_MXPS_Msk = 0x7f
	// Position of DEVSEL field.
	USBFS_DCPMAXP_DEVSEL_Pos = 0xc
	// Bit mask of DEVSEL field.
	USBFS_DCPMAXP_DEVSEL_Msk = 0xf000
	// Address 0000b
	USBFS_DCPMAXP_DEVSEL_0x0 = 0x0
	// Address 0001b
	USBFS_DCPMAXP_DEVSEL_0x1 = 0x1
	// Address 0010b
	USBFS_DCPMAXP_DEVSEL_0x2 = 0x2
	// Address 0011b
	USBFS_DCPMAXP_DEVSEL_0x3 = 0x3
	// Address 0100b
	USBFS_DCPMAXP_DEVSEL_0x4 = 0x4
	// Address 0101b
	USBFS_DCPMAXP_DEVSEL_0x5 = 0x5

	// DCPCTR: DCP Control Register
	// Position of PID field.
	USBFS_DCPCTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBFS_DCPCTR_PID_Msk = 0x3
	// NAK response
	USBFS_DCPCTR_PID_00 = 0x0
	// BUF response (depends on the buffer state)
	USBFS_DCPCTR_PID_01 = 0x1
	// STALL response
	USBFS_DCPCTR_PID_10 = 0x2
	// STALL response
	USBFS_DCPCTR_PID_11 = 0x3
	// Position of CCPL field.
	USBFS_DCPCTR_CCPL_Pos = 0x2
	// Bit mask of CCPL field.
	USBFS_DCPCTR_CCPL_Msk = 0x4
	// Bit CCPL.
	USBFS_DCPCTR_CCPL = 0x4
	// Disable control transfer completion
	USBFS_DCPCTR_CCPL_0 = 0x0
	// Enable control transfer completion
	USBFS_DCPCTR_CCPL_1 = 0x1
	// Position of PBUSY field.
	USBFS_DCPCTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBFS_DCPCTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBFS_DCPCTR_PBUSY = 0x20
	// DCP not used for the USB bus
	USBFS_DCPCTR_PBUSY_0 = 0x0
	// DCP in use for the USB bus
	USBFS_DCPCTR_PBUSY_1 = 0x1
	// Position of SQMON field.
	USBFS_DCPCTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBFS_DCPCTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBFS_DCPCTR_SQMON = 0x40
	// DATA0
	USBFS_DCPCTR_SQMON_0 = 0x0
	// ATA1
	USBFS_DCPCTR_SQMON_1 = 0x1
	// Position of SQSET field.
	USBFS_DCPCTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBFS_DCPCTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBFS_DCPCTR_SQSET = 0x80
	// Invalid (writing 0 has no effect)
	USBFS_DCPCTR_SQSET_0 = 0x0
	// Set the expected value for the next transaction to DATA1
	USBFS_DCPCTR_SQSET_1 = 0x1
	// Position of SQCLR field.
	USBFS_DCPCTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBFS_DCPCTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBFS_DCPCTR_SQCLR = 0x100
	// Invalid (writing 0 has no effect)
	USBFS_DCPCTR_SQCLR_0 = 0x0
	// Clear the expected value for the next transaction to DATA0
	USBFS_DCPCTR_SQCLR_1 = 0x1
	// Position of SUREQCLR field.
	USBFS_DCPCTR_SUREQCLR_Pos = 0xb
	// Bit mask of SUREQCLR field.
	USBFS_DCPCTR_SUREQCLR_Msk = 0x800
	// Bit SUREQCLR.
	USBFS_DCPCTR_SUREQCLR = 0x800
	// Invalid (writing 0 has no effect)
	USBFS_DCPCTR_SUREQCLR_0 = 0x0
	// Clear SUREQ to 0
	USBFS_DCPCTR_SUREQCLR_1 = 0x1
	// Position of SUREQ field.
	USBFS_DCPCTR_SUREQ_Pos = 0xe
	// Bit mask of SUREQ field.
	USBFS_DCPCTR_SUREQ_Msk = 0x4000
	// Bit SUREQ.
	USBFS_DCPCTR_SUREQ = 0x4000
	// Invalid (writing 0 has no effect)
	USBFS_DCPCTR_SUREQ_0 = 0x0
	// Transmit setup packet
	USBFS_DCPCTR_SUREQ_1 = 0x1
	// Position of BSTS field.
	USBFS_DCPCTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBFS_DCPCTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBFS_DCPCTR_BSTS = 0x8000
	// Buffer access disabled
	USBFS_DCPCTR_BSTS_0 = 0x0
	// Buffer access enabled
	USBFS_DCPCTR_BSTS_1 = 0x1

	// PIPESEL: Pipe Window Select Register
	// Position of PIPESEL field.
	USBFS_PIPESEL_PIPESEL_Pos = 0x0
	// Bit mask of PIPESEL field.
	USBFS_PIPESEL_PIPESEL_Msk = 0xf
	// No pipe selected
	USBFS_PIPESEL_PIPESEL_0x0 = 0x0
	// Pipe 1
	USBFS_PIPESEL_PIPESEL_0x1 = 0x1
	// Pipe 2
	USBFS_PIPESEL_PIPESEL_0x2 = 0x2
	// Pipe 3
	USBFS_PIPESEL_PIPESEL_0x3 = 0x3
	// Pipe 4
	USBFS_PIPESEL_PIPESEL_0x4 = 0x4
	// Pipe 5
	USBFS_PIPESEL_PIPESEL_0x5 = 0x5
	// Pipe 6
	USBFS_PIPESEL_PIPESEL_0x6 = 0x6
	// Pipe 7
	USBFS_PIPESEL_PIPESEL_0x7 = 0x7
	// Pipe 8
	USBFS_PIPESEL_PIPESEL_0x8 = 0x8
	// Pipe 9
	USBFS_PIPESEL_PIPESEL_0x9 = 0x9

	// PIPECFG: Pipe Configuration Register
	// Position of EPNUM field.
	USBFS_PIPECFG_EPNUM_Pos = 0x0
	// Bit mask of EPNUM field.
	USBFS_PIPECFG_EPNUM_Msk = 0xf
	// Position of DIR field.
	USBFS_PIPECFG_DIR_Pos = 0x4
	// Bit mask of DIR field.
	USBFS_PIPECFG_DIR_Msk = 0x10
	// Bit DIR.
	USBFS_PIPECFG_DIR = 0x10
	// Receiving direction
	USBFS_PIPECFG_DIR_0 = 0x0
	// Transmitting direction
	USBFS_PIPECFG_DIR_1 = 0x1
	// Position of SHTNAK field.
	USBFS_PIPECFG_SHTNAK_Pos = 0x7
	// Bit mask of SHTNAK field.
	USBFS_PIPECFG_SHTNAK_Msk = 0x80
	// Bit SHTNAK.
	USBFS_PIPECFG_SHTNAK = 0x80
	// Continue pipe operation after transfer ends
	USBFS_PIPECFG_SHTNAK_0 = 0x0
	// Disable pipe after transfer ends
	USBFS_PIPECFG_SHTNAK_1 = 0x1
	// Position of DBLB field.
	USBFS_PIPECFG_DBLB_Pos = 0x9
	// Bit mask of DBLB field.
	USBFS_PIPECFG_DBLB_Msk = 0x200
	// Bit DBLB.
	USBFS_PIPECFG_DBLB = 0x200
	// Single buffer
	USBFS_PIPECFG_DBLB_0 = 0x0
	// Double buffer
	USBFS_PIPECFG_DBLB_1 = 0x1
	// Position of BFRE field.
	USBFS_PIPECFG_BFRE_Pos = 0xa
	// Bit mask of BFRE field.
	USBFS_PIPECFG_BFRE_Msk = 0x400
	// Bit BFRE.
	USBFS_PIPECFG_BFRE = 0x400
	// Generate BRDY interrupt on transmitting or receiving data
	USBFS_PIPECFG_BFRE_0 = 0x0
	// Generate BRDY interrupt on completion of reading data
	USBFS_PIPECFG_BFRE_1 = 0x1
	// Position of TYPE field.
	USBFS_PIPECFG_TYPE_Pos = 0xe
	// Bit mask of TYPE field.
	USBFS_PIPECFG_TYPE_Msk = 0xc000
	// Pipe not used
	USBFS_PIPECFG_TYPE_00 = 0x0
	// Pipes 1 and 2: Bulk transfer Pipes 3 to 5: Bulk transfer Pipes 6 to 9: Setting prohibited
	USBFS_PIPECFG_TYPE_01 = 0x1
	// Pipes 1 and 2: Setting prohibited Pipes 3 to 5: Setting prohibited Pipes 6 to 9: Interrupt transfer
	USBFS_PIPECFG_TYPE_10 = 0x2
	// Pipes 1 and 2: Isochronous transfer Pipes 3 to 5: Setting prohibited Pipes 6 to 9: Setting prohibited
	USBFS_PIPECFG_TYPE_11 = 0x3

	// PIPEMAXP: Pipe Maximum Packet Size Register
	// Position of MXPS field.
	USBFS_PIPEMAXP_MXPS_Pos = 0x0
	// Bit mask of MXPS field.
	USBFS_PIPEMAXP_MXPS_Msk = 0x1ff
	// Position of DEVSEL field.
	USBFS_PIPEMAXP_DEVSEL_Pos = 0xc
	// Bit mask of DEVSEL field.
	USBFS_PIPEMAXP_DEVSEL_Msk = 0xf000
	// Address 0000b
	USBFS_PIPEMAXP_DEVSEL_0x0 = 0x0
	// Address 0001b
	USBFS_PIPEMAXP_DEVSEL_0x1 = 0x1
	// Address 0010b
	USBFS_PIPEMAXP_DEVSEL_0x2 = 0x2
	// Address 0011b
	USBFS_PIPEMAXP_DEVSEL_0x3 = 0x3
	// Address 0100b
	USBFS_PIPEMAXP_DEVSEL_0x4 = 0x4
	// Address 0101b
	USBFS_PIPEMAXP_DEVSEL_0x5 = 0x5

	// PIPEPERI: Pipe Cycle Control Register
	// Position of IITV field.
	USBFS_PIPEPERI_IITV_Pos = 0x0
	// Bit mask of IITV field.
	USBFS_PIPEPERI_IITV_Msk = 0x7
	// Position of IFIS field.
	USBFS_PIPEPERI_IFIS_Pos = 0xc
	// Bit mask of IFIS field.
	USBFS_PIPEPERI_IFIS_Msk = 0x1000
	// Bit IFIS.
	USBFS_PIPEPERI_IFIS = 0x1000
	// Do not flush buffer
	USBFS_PIPEPERI_IFIS_0 = 0x0
	// Flush buffer
	USBFS_PIPEPERI_IFIS_1 = 0x1

	// PIPE1CTR: PIPE%s Control Registers
	// Position of PID field.
	USBFS_PIPECTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBFS_PIPECTR_PID_Msk = 0x3
	// NAK response
	USBFS_PIPECTR_PID_00 = 0x0
	// BUF response (depends buffer state)
	USBFS_PIPECTR_PID_01 = 0x1
	// STALL response
	USBFS_PIPECTR_PID_10 = 0x2
	// STALL response
	USBFS_PIPECTR_PID_11 = 0x3
	// Position of PBUSY field.
	USBFS_PIPECTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBFS_PIPECTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBFS_PIPECTR_PBUSY = 0x20
	// Pipe n not in use for the transaction
	USBFS_PIPECTR_PBUSY_0 = 0x0
	// Pipe n in use for the transaction
	USBFS_PIPECTR_PBUSY_1 = 0x1
	// Position of SQMON field.
	USBFS_PIPECTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBFS_PIPECTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBFS_PIPECTR_SQMON = 0x40
	// DATA0
	USBFS_PIPECTR_SQMON_0 = 0x0
	// DATA1
	USBFS_PIPECTR_SQMON_1 = 0x1
	// Position of SQSET field.
	USBFS_PIPECTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBFS_PIPECTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBFS_PIPECTR_SQSET = 0x80
	// Invalid (writing 0 has no effect)
	USBFS_PIPECTR_SQSET_0 = 0x0
	// Set the expected value for the next transaction to DATA1
	USBFS_PIPECTR_SQSET_1 = 0x1
	// Position of SQCLR field.
	USBFS_PIPECTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBFS_PIPECTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBFS_PIPECTR_SQCLR = 0x100
	// Invalid (writing 0 has no effect)
	USBFS_PIPECTR_SQCLR_0 = 0x0
	// Clear the expected value for the next transaction to DATA0
	USBFS_PIPECTR_SQCLR_1 = 0x1
	// Position of ACLRM field.
	USBFS_PIPECTR_ACLRM_Pos = 0x9
	// Bit mask of ACLRM field.
	USBFS_PIPECTR_ACLRM_Msk = 0x200
	// Bit ACLRM.
	USBFS_PIPECTR_ACLRM = 0x200
	// Disable
	USBFS_PIPECTR_ACLRM_0 = 0x0
	// Enable (initialize all buffers)
	USBFS_PIPECTR_ACLRM_1 = 0x1
	// Position of ATREPM field.
	USBFS_PIPECTR_ATREPM_Pos = 0xa
	// Bit mask of ATREPM field.
	USBFS_PIPECTR_ATREPM_Msk = 0x400
	// Bit ATREPM.
	USBFS_PIPECTR_ATREPM = 0x400
	// Disable auto response mode
	USBFS_PIPECTR_ATREPM_0 = 0x0
	// Enable auto response mode
	USBFS_PIPECTR_ATREPM_1 = 0x1
	// Position of INBUFM field.
	USBFS_PIPECTR_INBUFM_Pos = 0xe
	// Bit mask of INBUFM field.
	USBFS_PIPECTR_INBUFM_Msk = 0x4000
	// Bit INBUFM.
	USBFS_PIPECTR_INBUFM = 0x4000
	// No data to be transmitted is in the FIFO buffer
	USBFS_PIPECTR_INBUFM_0 = 0x0
	// Data to be transmitted is in the FIFO buffer
	USBFS_PIPECTR_INBUFM_1 = 0x1
	// Position of BSTS field.
	USBFS_PIPECTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBFS_PIPECTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBFS_PIPECTR_BSTS = 0x8000
	// Buffer access by the CPU disabled
	USBFS_PIPECTR_BSTS_0 = 0x0
	// Buffer access by the CPU enabled
	USBFS_PIPECTR_BSTS_1 = 0x1

	// PIPE6CTR: PIPE%s Control Registers
	// Position of PID field.
	USBFS_PIPECTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBFS_PIPECTR_PID_Msk = 0x3
	// NAK response
	USBFS_PIPECTR_PID_00 = 0x0
	// BUF response (depends buffer state)
	USBFS_PIPECTR_PID_01 = 0x1
	// STALL response
	USBFS_PIPECTR_PID_10 = 0x2
	// STALL response
	USBFS_PIPECTR_PID_11 = 0x3
	// Position of PBUSY field.
	USBFS_PIPECTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBFS_PIPECTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBFS_PIPECTR_PBUSY = 0x20
	// Pipe n not in use for the transaction
	USBFS_PIPECTR_PBUSY_0 = 0x0
	// Pipe n in use for the transaction
	USBFS_PIPECTR_PBUSY_1 = 0x1
	// Position of SQMON field.
	USBFS_PIPECTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBFS_PIPECTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBFS_PIPECTR_SQMON = 0x40
	// DATA0
	USBFS_PIPECTR_SQMON_0 = 0x0
	// DATA1
	USBFS_PIPECTR_SQMON_1 = 0x1
	// Position of SQSET field.
	USBFS_PIPECTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBFS_PIPECTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBFS_PIPECTR_SQSET = 0x80
	// Invalid (writing 0 has no effect)
	USBFS_PIPECTR_SQSET_0 = 0x0
	// Set the expected value for the next transaction to DATA0
	USBFS_PIPECTR_SQSET_1 = 0x1
	// Position of SQCLR field.
	USBFS_PIPECTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBFS_PIPECTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBFS_PIPECTR_SQCLR = 0x100
	// Invalid (writing 0 has no effect)
	USBFS_PIPECTR_SQCLR_0 = 0x0
	// Clear the expected value for the next transaction to DATA0
	USBFS_PIPECTR_SQCLR_1 = 0x1
	// Position of ACLRM field.
	USBFS_PIPECTR_ACLRM_Pos = 0x9
	// Bit mask of ACLRM field.
	USBFS_PIPECTR_ACLRM_Msk = 0x200
	// Bit ACLRM.
	USBFS_PIPECTR_ACLRM = 0x200
	// Disable
	USBFS_PIPECTR_ACLRM_0 = 0x0
	// Enable (all buffers initialized)
	USBFS_PIPECTR_ACLRM_1 = 0x1
	// Position of BSTS field.
	USBFS_PIPECTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBFS_PIPECTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBFS_PIPECTR_BSTS = 0x8000
	// Buffer access disabled
	USBFS_PIPECTR_BSTS_0 = 0x0
	// Buffer access enabled
	USBFS_PIPECTR_BSTS_1 = 0x1

	// PIPE1TRE: PIPE%s Transaction Counter Enable Register
	// Position of TRCLR field.
	USBFS_PIPETRE_TRCLR_Pos = 0x8
	// Bit mask of TRCLR field.
	USBFS_PIPETRE_TRCLR_Msk = 0x100
	// Bit TRCLR.
	USBFS_PIPETRE_TRCLR = 0x100
	// Invalid (writing 0 has no effect)
	USBFS_PIPETRE_TRCLR_0 = 0x0
	// Clear counter value
	USBFS_PIPETRE_TRCLR_1 = 0x1
	// Position of TRENB field.
	USBFS_PIPETRE_TRENB_Pos = 0x9
	// Bit mask of TRENB field.
	USBFS_PIPETRE_TRENB_Msk = 0x200
	// Bit TRENB.
	USBFS_PIPETRE_TRENB = 0x200
	// Disable transaction counter
	USBFS_PIPETRE_TRENB_0 = 0x0
	// Enable transaction counter
	USBFS_PIPETRE_TRENB_1 = 0x1

	// PIPE1TRN: PIPE%s Transaction Counter Register
	// Position of TRNCNT field.
	USBFS_PIPETRN_TRNCNT_Pos = 0x0
	// Bit mask of TRNCNT field.
	USBFS_PIPETRN_TRNCNT_Msk = 0xffff

	// BCCTRL1: Battery Charging Control Register 1
	// Position of RPDME field.
	USBFS_BCCTRL1_RPDME_Pos = 0x0
	// Bit mask of RPDME field.
	USBFS_BCCTRL1_RPDME_Msk = 0x1
	// Bit RPDME.
	USBFS_BCCTRL1_RPDME = 0x1
	// Disable D- Line Pull-down
	USBFS_BCCTRL1_RPDME_0 = 0x0
	// Enable D- Line Pull-down
	USBFS_BCCTRL1_RPDME_1 = 0x1
	// Position of IDPSRCE field.
	USBFS_BCCTRL1_IDPSRCE_Pos = 0x1
	// Bit mask of IDPSRCE field.
	USBFS_BCCTRL1_IDPSRCE_Msk = 0x2
	// Bit IDPSRCE.
	USBFS_BCCTRL1_IDPSRCE = 0x2
	// Stopped
	USBFS_BCCTRL1_IDPSRCE_0 = 0x0
	// 10 µA output
	USBFS_BCCTRL1_IDPSRCE_1 = 0x1
	// Position of VDMSRCE field.
	USBFS_BCCTRL1_VDMSRCE_Pos = 0x2
	// Bit mask of VDMSRCE field.
	USBFS_BCCTRL1_VDMSRCE_Msk = 0x4
	// Bit VDMSRCE.
	USBFS_BCCTRL1_VDMSRCE = 0x4
	// Stopped
	USBFS_BCCTRL1_VDMSRCE_0 = 0x0
	// 0.6 V output
	USBFS_BCCTRL1_VDMSRCE_1 = 0x1
	// Position of VDPSRCE field.
	USBFS_BCCTRL1_VDPSRCE_Pos = 0x3
	// Bit mask of VDPSRCE field.
	USBFS_BCCTRL1_VDPSRCE_Msk = 0x8
	// Bit VDPSRCE.
	USBFS_BCCTRL1_VDPSRCE = 0x8
	// Stopped
	USBFS_BCCTRL1_VDPSRCE_0 = 0x0
	// 0.6 V output
	USBFS_BCCTRL1_VDPSRCE_1 = 0x1
	// Position of PDDETE field.
	USBFS_BCCTRL1_PDDETE_Pos = 0x4
	// Bit mask of PDDETE field.
	USBFS_BCCTRL1_PDDETE_Msk = 0x10
	// Bit PDDETE.
	USBFS_BCCTRL1_PDDETE = 0x10
	// Disable detection
	USBFS_BCCTRL1_PDDETE_0 = 0x0
	// Enable detection
	USBFS_BCCTRL1_PDDETE_1 = 0x1
	// Position of CHGDETE field.
	USBFS_BCCTRL1_CHGDETE_Pos = 0x5
	// Bit mask of CHGDETE field.
	USBFS_BCCTRL1_CHGDETE_Msk = 0x20
	// Bit CHGDETE.
	USBFS_BCCTRL1_CHGDETE = 0x20
	// Disable detection
	USBFS_BCCTRL1_CHGDETE_0 = 0x0
	// Enable detection
	USBFS_BCCTRL1_CHGDETE_1 = 0x1
	// Position of PDDETSTS field.
	USBFS_BCCTRL1_PDDETSTS_Pos = 0x8
	// Bit mask of PDDETSTS field.
	USBFS_BCCTRL1_PDDETSTS_Msk = 0x100
	// Bit PDDETSTS.
	USBFS_BCCTRL1_PDDETSTS = 0x100
	// Not detected
	USBFS_BCCTRL1_PDDETSTS_0 = 0x0
	// Detected
	USBFS_BCCTRL1_PDDETSTS_1 = 0x1
	// Position of CHGDETSTS field.
	USBFS_BCCTRL1_CHGDETSTS_Pos = 0x9
	// Bit mask of CHGDETSTS field.
	USBFS_BCCTRL1_CHGDETSTS_Msk = 0x200
	// Bit CHGDETSTS.
	USBFS_BCCTRL1_CHGDETSTS = 0x200
	// Not detected
	USBFS_BCCTRL1_CHGDETSTS_0 = 0x0
	// Detected
	USBFS_BCCTRL1_CHGDETSTS_1 = 0x1

	// BCCTRL2: Battery Charging Control Register 2
	// Position of DCPMODE field.
	USBFS_BCCTRL2_DCPMODE_Pos = 0x6
	// Bit mask of DCPMODE field.
	USBFS_BCCTRL2_DCPMODE_Msk = 0x40
	// Bit DCPMODE.
	USBFS_BCCTRL2_DCPMODE = 0x40
	// Disable DCP
	USBFS_BCCTRL2_DCPMODE_0 = 0x0
	// Enable DCP
	USBFS_BCCTRL2_DCPMODE_1 = 0x1
	// Position of BATCHGE field.
	USBFS_BCCTRL2_BATCHGE_Pos = 0x7
	// Bit mask of BATCHGE field.
	USBFS_BCCTRL2_BATCHGE_Msk = 0x80
	// Bit BATCHGE.
	USBFS_BCCTRL2_BATCHGE = 0x80
	// Disable Battery Charging
	USBFS_BCCTRL2_BATCHGE_0 = 0x0
	// Enable Battery Charging
	USBFS_BCCTRL2_BATCHGE_1 = 0x1
	// Position of PHYDET field.
	USBFS_BCCTRL2_PHYDET_Pos = 0xc
	// Bit mask of PHYDET field.
	USBFS_BCCTRL2_PHYDET_Msk = 0x3000

	// DEVADD0: Device Address %s Configuration Register
	// Position of USBSPD field.
	USBFS_DEVADD_USBSPD_Pos = 0x6
	// Bit mask of USBSPD field.
	USBFS_DEVADD_USBSPD_Msk = 0xc0
	// Do not use DEVADDn
	USBFS_DEVADD_USBSPD_00 = 0x0
	// Low-speed
	USBFS_DEVADD_USBSPD_01 = 0x1
	// Full-speed
	USBFS_DEVADD_USBSPD_10 = 0x2
	// Setting prohibited
	USBFS_DEVADD_USBSPD_11 = 0x3

	// PHYSECTRL: PHY Single-ended Receiver Control Register
	// Position of CNEN field.
	USBFS_PHYSECTRL_CNEN_Pos = 0x4
	// Bit mask of CNEN field.
	USBFS_PHYSECTRL_CNEN_Msk = 0x10
	// Bit CNEN.
	USBFS_PHYSECTRL_CNEN = 0x10
	// Single-ended receiver operation is disabled
	USBFS_PHYSECTRL_CNEN_0 = 0x0
	// Single-ended receiver operation is enabled
	USBFS_PHYSECTRL_CNEN_1 = 0x1

	// DPUSR0R: Deep Software Standby USB Transceiver Control/Pin Monitor Register
	// Position of SRPC0 field.
	USBFS_DPUSR0R_SRPC0_Pos = 0x0
	// Bit mask of SRPC0 field.
	USBFS_DPUSR0R_SRPC0_Msk = 0x1
	// Bit SRPC0.
	USBFS_DPUSR0R_SRPC0 = 0x1
	// Disable input through DP and DM inputs
	USBFS_DPUSR0R_SRPC0_0 = 0x0
	// Enable input through DP and DM inputs
	USBFS_DPUSR0R_SRPC0_1 = 0x1
	// Position of RPUE0 field.
	USBFS_DPUSR0R_RPUE0_Pos = 0x1
	// Bit mask of RPUE0 field.
	USBFS_DPUSR0R_RPUE0_Msk = 0x2
	// Bit RPUE0.
	USBFS_DPUSR0R_RPUE0 = 0x2
	// Disable DP pull-up resistor
	USBFS_DPUSR0R_RPUE0_0 = 0x0
	// Enable DP pull-up resistor
	USBFS_DPUSR0R_RPUE0_1 = 0x1
	// Position of DRPD0 field.
	USBFS_DPUSR0R_DRPD0_Pos = 0x3
	// Bit mask of DRPD0 field.
	USBFS_DPUSR0R_DRPD0_Msk = 0x8
	// Bit DRPD0.
	USBFS_DPUSR0R_DRPD0 = 0x8
	// Disable DP/DM pull-down resistor
	USBFS_DPUSR0R_DRPD0_0 = 0x0
	// Enable DP/DM pull-down resistor
	USBFS_DPUSR0R_DRPD0_1 = 0x1
	// Position of FIXPHY0 field.
	USBFS_DPUSR0R_FIXPHY0_Pos = 0x4
	// Bit mask of FIXPHY0 field.
	USBFS_DPUSR0R_FIXPHY0_Msk = 0x10
	// Bit FIXPHY0.
	USBFS_DPUSR0R_FIXPHY0 = 0x10
	// Fix outputs in Normal mode and on return from Deep Software Standby mode
	USBFS_DPUSR0R_FIXPHY0_0 = 0x0
	// Fix outputs on transition to Deep Software Standby mode
	USBFS_DPUSR0R_FIXPHY0_1 = 0x1
	// Position of DP0 field.
	USBFS_DPUSR0R_DP0_Pos = 0x10
	// Bit mask of DP0 field.
	USBFS_DPUSR0R_DP0_Msk = 0x10000
	// Bit DP0.
	USBFS_DPUSR0R_DP0 = 0x10000
	// Position of DM0 field.
	USBFS_DPUSR0R_DM0_Pos = 0x11
	// Bit mask of DM0 field.
	USBFS_DPUSR0R_DM0_Msk = 0x20000
	// Bit DM0.
	USBFS_DPUSR0R_DM0 = 0x20000
	// Position of DOVCA0 field.
	USBFS_DPUSR0R_DOVCA0_Pos = 0x14
	// Bit mask of DOVCA0 field.
	USBFS_DPUSR0R_DOVCA0_Msk = 0x100000
	// Bit DOVCA0.
	USBFS_DPUSR0R_DOVCA0 = 0x100000
	// Position of DOVCB0 field.
	USBFS_DPUSR0R_DOVCB0_Pos = 0x15
	// Bit mask of DOVCB0 field.
	USBFS_DPUSR0R_DOVCB0_Msk = 0x200000
	// Bit DOVCB0.
	USBFS_DPUSR0R_DOVCB0 = 0x200000
	// Position of DVBSTS0 field.
	USBFS_DPUSR0R_DVBSTS0_Pos = 0x17
	// Bit mask of DVBSTS0 field.
	USBFS_DPUSR0R_DVBSTS0_Msk = 0x800000
	// Bit DVBSTS0.
	USBFS_DPUSR0R_DVBSTS0 = 0x800000

	// DPUSR1R: Deep Software Standby USB Suspend/Resume Interrupt Register
	// Position of DPINTE0 field.
	USBFS_DPUSR1R_DPINTE0_Pos = 0x0
	// Bit mask of DPINTE0 field.
	USBFS_DPUSR1R_DPINTE0_Msk = 0x1
	// Bit DPINTE0.
	USBFS_DPUSR1R_DPINTE0 = 0x1
	// Disable recovery from Deep Software Standby mode by DP input
	USBFS_DPUSR1R_DPINTE0_0 = 0x0
	// Enable recovery from Deep Software Standby mode by DP input
	USBFS_DPUSR1R_DPINTE0_1 = 0x1
	// Position of DMINTE0 field.
	USBFS_DPUSR1R_DMINTE0_Pos = 0x1
	// Bit mask of DMINTE0 field.
	USBFS_DPUSR1R_DMINTE0_Msk = 0x2
	// Bit DMINTE0.
	USBFS_DPUSR1R_DMINTE0 = 0x2
	// Disable recovery from Deep Software Standby mode by DM input
	USBFS_DPUSR1R_DMINTE0_0 = 0x0
	// Enable recovery from Deep Software Standby mode by DM input
	USBFS_DPUSR1R_DMINTE0_1 = 0x1
	// Position of DOVRCRAE0 field.
	USBFS_DPUSR1R_DOVRCRAE0_Pos = 0x4
	// Bit mask of DOVRCRAE0 field.
	USBFS_DPUSR1R_DOVRCRAE0_Msk = 0x10
	// Bit DOVRCRAE0.
	USBFS_DPUSR1R_DOVRCRAE0 = 0x10
	// Disable recovery from Deep Software Standby mode by OVRCURA input
	USBFS_DPUSR1R_DOVRCRAE0_0 = 0x0
	// Enable recovery from Deep Software Standby mode by OVRCURA input
	USBFS_DPUSR1R_DOVRCRAE0_1 = 0x1
	// Position of DOVRCRBE0 field.
	USBFS_DPUSR1R_DOVRCRBE0_Pos = 0x5
	// Bit mask of DOVRCRBE0 field.
	USBFS_DPUSR1R_DOVRCRBE0_Msk = 0x20
	// Bit DOVRCRBE0.
	USBFS_DPUSR1R_DOVRCRBE0 = 0x20
	// Disable recovery from Deep Software Standby mode by OVRCURB input
	USBFS_DPUSR1R_DOVRCRBE0_0 = 0x0
	// Enable recovery from Deep Software Standby mode by OVRCURB input
	USBFS_DPUSR1R_DOVRCRBE0_1 = 0x1
	// Position of DVBSE0 field.
	USBFS_DPUSR1R_DVBSE0_Pos = 0x7
	// Bit mask of DVBSE0 field.
	USBFS_DPUSR1R_DVBSE0_Msk = 0x80
	// Bit DVBSE0.
	USBFS_DPUSR1R_DVBSE0 = 0x80
	// Disable recovery from Deep Software Standby mode by VBUS input
	USBFS_DPUSR1R_DVBSE0_0 = 0x0
	// Enable recovery from Deep Software Standby mode by VBUS input
	USBFS_DPUSR1R_DVBSE0_1 = 0x1
	// Position of DPINT0 field.
	USBFS_DPUSR1R_DPINT0_Pos = 0x10
	// Bit mask of DPINT0 field.
	USBFS_DPUSR1R_DPINT0_Msk = 0x10000
	// Bit DPINT0.
	USBFS_DPUSR1R_DPINT0 = 0x10000
	// System has not recovered from Deep Software Standby mode
	USBFS_DPUSR1R_DPINT0_0 = 0x0
	// System recovered from Deep Software Standby mode because of DP
	USBFS_DPUSR1R_DPINT0_1 = 0x1
	// Position of DMINT0 field.
	USBFS_DPUSR1R_DMINT0_Pos = 0x11
	// Bit mask of DMINT0 field.
	USBFS_DPUSR1R_DMINT0_Msk = 0x20000
	// Bit DMINT0.
	USBFS_DPUSR1R_DMINT0 = 0x20000
	// System has not recovered from Deep Software Standby mode
	USBFS_DPUSR1R_DMINT0_0 = 0x0
	// System recovered from Deep Software Standby mode because of DM input
	USBFS_DPUSR1R_DMINT0_1 = 0x1
	// Position of DOVRCRA0 field.
	USBFS_DPUSR1R_DOVRCRA0_Pos = 0x14
	// Bit mask of DOVRCRA0 field.
	USBFS_DPUSR1R_DOVRCRA0_Msk = 0x100000
	// Bit DOVRCRA0.
	USBFS_DPUSR1R_DOVRCRA0 = 0x100000
	// System has not recovered from Deep Software Standby mode
	USBFS_DPUSR1R_DOVRCRA0_0 = 0x0
	// System recovered from Deep Software Standby mode because of OVRCURA input
	USBFS_DPUSR1R_DOVRCRA0_1 = 0x1
	// Position of DOVRCRB0 field.
	USBFS_DPUSR1R_DOVRCRB0_Pos = 0x15
	// Bit mask of DOVRCRB0 field.
	USBFS_DPUSR1R_DOVRCRB0_Msk = 0x200000
	// Bit DOVRCRB0.
	USBFS_DPUSR1R_DOVRCRB0 = 0x200000
	// System has not recovered from Deep Software Standby mode
	USBFS_DPUSR1R_DOVRCRB0_0 = 0x0
	// System recovered from Deep Software Standby mode because of OVRCURB input
	USBFS_DPUSR1R_DOVRCRB0_1 = 0x1
	// Position of DVBINT0 field.
	USBFS_DPUSR1R_DVBINT0_Pos = 0x17
	// Bit mask of DVBINT0 field.
	USBFS_DPUSR1R_DVBINT0_Msk = 0x800000
	// Bit DVBINT0.
	USBFS_DPUSR1R_DVBINT0 = 0x800000
	// System has not recovered from Deep Software Standby mode
	USBFS_DPUSR1R_DVBINT0_0 = 0x0
	// System recovered from Deep Software Standby mode because of VBUS input
	USBFS_DPUSR1R_DVBINT0_1 = 0x1
)

// Constants for SDHI0: SD Host Interface 0
const (
	// SD_CMD: Command Type Register
	// Position of CMDIDX field.
	SDHI0_SD_CMD_CMDIDX_Pos = 0x0
	// Bit mask of CMDIDX field.
	SDHI0_SD_CMD_CMDIDX_Msk = 0x3f
	// CMD6
	SDHI0_SD_CMD_CMDIDX_0x06 = 0x6
	// CMD18
	SDHI0_SD_CMD_CMDIDX_0x12 = 0x12
	// ACMD13
	SDHI0_SD_CMD_CMDIDX_0x4D = 0x4d
	// Position of ACMD field.
	SDHI0_SD_CMD_ACMD_Pos = 0x6
	// Bit mask of ACMD field.
	SDHI0_SD_CMD_ACMD_Msk = 0xc0
	// CMD
	SDHI0_SD_CMD_ACMD_00 = 0x0
	// ACMD
	SDHI0_SD_CMD_ACMD_01 = 0x1
	// Position of RSPTP field.
	SDHI0_SD_CMD_RSPTP_Pos = 0x8
	// Bit mask of RSPTP field.
	SDHI0_SD_CMD_RSPTP_Msk = 0x700
	// Normal mode Depending on the command, the response type and transfer method are selected in the ACMD[1:0] and CMDIDX[5:0] bits. At this time, the values for bits 15 to 11 in this register are invalid.
	SDHI0_SD_CMD_RSPTP_000 = 0x0
	// Extended mode and no response
	SDHI0_SD_CMD_RSPTP_011 = 0x3
	// Extended mode and R1, R5, R6, or R7 response
	SDHI0_SD_CMD_RSPTP_100 = 0x4
	// Extended mode and R1b response
	SDHI0_SD_CMD_RSPTP_101 = 0x5
	// Extended mode and R2 response
	SDHI0_SD_CMD_RSPTP_110 = 0x6
	// Extended mode and R3 or R4 response
	SDHI0_SD_CMD_RSPTP_111 = 0x7
	// Position of CMDTP field.
	SDHI0_SD_CMD_CMDTP_Pos = 0xb
	// Bit mask of CMDTP field.
	SDHI0_SD_CMD_CMDTP_Msk = 0x800
	// Bit CMDTP.
	SDHI0_SD_CMD_CMDTP = 0x800
	// Do not include data transfer (bc, bcr, or ac) in command
	SDHI0_SD_CMD_CMDTP_0 = 0x0
	// Include data transfer (adtc) in command
	SDHI0_SD_CMD_CMDTP_1 = 0x1
	// Position of CMDRW field.
	SDHI0_SD_CMD_CMDRW_Pos = 0xc
	// Bit mask of CMDRW field.
	SDHI0_SD_CMD_CMDRW_Msk = 0x1000
	// Bit CMDRW.
	SDHI0_SD_CMD_CMDRW = 0x1000
	// Write (SD/MMC Host Interface → SD card/MMC)
	SDHI0_SD_CMD_CMDRW_0 = 0x0
	// Read (SD/MMC Host Interface ← SD card/MMC)
	SDHI0_SD_CMD_CMDRW_1 = 0x1
	// Position of TRSTP field.
	SDHI0_SD_CMD_TRSTP_Pos = 0xd
	// Bit mask of TRSTP field.
	SDHI0_SD_CMD_TRSTP_Msk = 0x2000
	// Bit TRSTP.
	SDHI0_SD_CMD_TRSTP = 0x2000
	// Single block transfer
	SDHI0_SD_CMD_TRSTP_0 = 0x0
	// Multiple blocks transfer
	SDHI0_SD_CMD_TRSTP_1 = 0x1
	// Position of CMD12AT field.
	SDHI0_SD_CMD_CMD12AT_Pos = 0xe
	// Bit mask of CMD12AT field.
	SDHI0_SD_CMD_CMD12AT_Msk = 0xc000
	// Automatically issue CMD12 during multiblock transfer
	SDHI0_SD_CMD_CMD12AT_00 = 0x0
	// Do not automatically issue CMD12 during multiblock transfer
	SDHI0_SD_CMD_CMD12AT_01 = 0x1

	// SD_STOP: Data Stop Register
	// Position of STP field.
	SDHI0_SD_STOP_STP_Pos = 0x0
	// Bit mask of STP field.
	SDHI0_SD_STOP_STP_Msk = 0x1
	// Bit STP.
	SDHI0_SD_STOP_STP = 0x1
	// Position of SEC field.
	SDHI0_SD_STOP_SEC_Pos = 0x8
	// Bit mask of SEC field.
	SDHI0_SD_STOP_SEC_Msk = 0x100
	// Bit SEC.
	SDHI0_SD_STOP_SEC = 0x100
	// Disable SD_SECCNT register value
	SDHI0_SD_STOP_SEC_0 = 0x0
	// Enable SD_SECCNT register value
	SDHI0_SD_STOP_SEC_1 = 0x1

	// SD_RSP76: SD Card Response Register 76
	// Position of SD_RSP76 field.
	SDHI0_SD_RSP76_SD_RSP76_Pos = 0x0
	// Bit mask of SD_RSP76 field.
	SDHI0_SD_RSP76_SD_RSP76_Msk = 0xffffff

	// SD_RSP7: SD Card Response Register 7
	// Position of SD_RSP7 field.
	SDHI0_SD_RSP7_SD_RSP7_Pos = 0x0
	// Bit mask of SD_RSP7 field.
	SDHI0_SD_RSP7_SD_RSP7_Msk = 0xff

	// SD_INFO1: SD Card Interrupt Flag Register 1
	// Position of RSPEND field.
	SDHI0_SD_INFO1_RSPEND_Pos = 0x0
	// Bit mask of RSPEND field.
	SDHI0_SD_INFO1_RSPEND_Msk = 0x1
	// Bit RSPEND.
	SDHI0_SD_INFO1_RSPEND = 0x1
	// Response end not detected
	SDHI0_SD_INFO1_RSPEND_0 = 0x0
	// Response end detected
	SDHI0_SD_INFO1_RSPEND_1 = 0x1
	// Position of ACEND field.
	SDHI0_SD_INFO1_ACEND_Pos = 0x2
	// Bit mask of ACEND field.
	SDHI0_SD_INFO1_ACEND_Msk = 0x4
	// Bit ACEND.
	SDHI0_SD_INFO1_ACEND = 0x4
	// Access end not detected
	SDHI0_SD_INFO1_ACEND_0 = 0x0
	// Access end detected
	SDHI0_SD_INFO1_ACEND_1 = 0x1
	// Position of SDCDRM field.
	SDHI0_SD_INFO1_SDCDRM_Pos = 0x3
	// Bit mask of SDCDRM field.
	SDHI0_SD_INFO1_SDCDRM_Msk = 0x8
	// Bit SDCDRM.
	SDHI0_SD_INFO1_SDCDRM = 0x8
	// SD card/MMC removal not detected by the SDnCD pin
	SDHI0_SD_INFO1_SDCDRM_0 = 0x0
	// SD card/MMC removal detected by the SDnCD pin
	SDHI0_SD_INFO1_SDCDRM_1 = 0x1
	// Position of SDCDIN field.
	SDHI0_SD_INFO1_SDCDIN_Pos = 0x4
	// Bit mask of SDCDIN field.
	SDHI0_SD_INFO1_SDCDIN_Msk = 0x10
	// Bit SDCDIN.
	SDHI0_SD_INFO1_SDCDIN = 0x10
	// SD card/MMC insertion not detected by the SDnCD pin
	SDHI0_SD_INFO1_SDCDIN_0 = 0x0
	// SD card/MMC insertion detected by the SDnCD pin
	SDHI0_SD_INFO1_SDCDIN_1 = 0x1
	// Position of SDCDMON field.
	SDHI0_SD_INFO1_SDCDMON_Pos = 0x5
	// Bit mask of SDCDMON field.
	SDHI0_SD_INFO1_SDCDMON_Msk = 0x20
	// Bit SDCDMON.
	SDHI0_SD_INFO1_SDCDMON = 0x20
	// SDnCD pin level is high
	SDHI0_SD_INFO1_SDCDMON_0 = 0x0
	// SDnCD pin level is low
	SDHI0_SD_INFO1_SDCDMON_1 = 0x1
	// Position of SDWPMON field.
	SDHI0_SD_INFO1_SDWPMON_Pos = 0x7
	// Bit mask of SDWPMON field.
	SDHI0_SD_INFO1_SDWPMON_Msk = 0x80
	// Bit SDWPMON.
	SDHI0_SD_INFO1_SDWPMON = 0x80
	// SDnWP pin level is high
	SDHI0_SD_INFO1_SDWPMON_0 = 0x0
	// SDnWP pin level is low
	SDHI0_SD_INFO1_SDWPMON_1 = 0x1
	// Position of SDD3RM field.
	SDHI0_SD_INFO1_SDD3RM_Pos = 0x8
	// Bit mask of SDD3RM field.
	SDHI0_SD_INFO1_SDD3RM_Msk = 0x100
	// Bit SDD3RM.
	SDHI0_SD_INFO1_SDD3RM = 0x100
	// SD card/MMC removal not detected by the SDnDAT3 pin
	SDHI0_SD_INFO1_SDD3RM_0 = 0x0
	// SD card/MMC removal detected by the SDnDAT3 pin
	SDHI0_SD_INFO1_SDD3RM_1 = 0x1
	// Position of SDD3IN field.
	SDHI0_SD_INFO1_SDD3IN_Pos = 0x9
	// Bit mask of SDD3IN field.
	SDHI0_SD_INFO1_SDD3IN_Msk = 0x200
	// Bit SDD3IN.
	SDHI0_SD_INFO1_SDD3IN = 0x200
	// SD card/MMC insertion not detected by the SDnDAT3 pin
	SDHI0_SD_INFO1_SDD3IN_0 = 0x0
	// SD card/MMC insertion detected by the SDnDAT3 pin
	SDHI0_SD_INFO1_SDD3IN_1 = 0x1
	// Position of SDD3MON field.
	SDHI0_SD_INFO1_SDD3MON_Pos = 0xa
	// Bit mask of SDD3MON field.
	SDHI0_SD_INFO1_SDD3MON_Msk = 0x400
	// Bit SDD3MON.
	SDHI0_SD_INFO1_SDD3MON = 0x400
	// SDnDAT3 pin level is low
	SDHI0_SD_INFO1_SDD3MON_0 = 0x0
	// SDnDAT3 pin level is high
	SDHI0_SD_INFO1_SDD3MON_1 = 0x1

	// SD_INFO2: SD Card Interrupt Flag Register 2
	// Position of CMDE field.
	SDHI0_SD_INFO2_CMDE_Pos = 0x0
	// Bit mask of CMDE field.
	SDHI0_SD_INFO2_CMDE_Msk = 0x1
	// Bit CMDE.
	SDHI0_SD_INFO2_CMDE = 0x1
	// Command error not detected
	SDHI0_SD_INFO2_CMDE_0 = 0x0
	// Command error detected
	SDHI0_SD_INFO2_CMDE_1 = 0x1
	// Position of CRCE field.
	SDHI0_SD_INFO2_CRCE_Pos = 0x1
	// Bit mask of CRCE field.
	SDHI0_SD_INFO2_CRCE_Msk = 0x2
	// Bit CRCE.
	SDHI0_SD_INFO2_CRCE = 0x2
	// CRC error not detected
	SDHI0_SD_INFO2_CRCE_0 = 0x0
	// CRC error detected
	SDHI0_SD_INFO2_CRCE_1 = 0x1
	// Position of ENDE field.
	SDHI0_SD_INFO2_ENDE_Pos = 0x2
	// Bit mask of ENDE field.
	SDHI0_SD_INFO2_ENDE_Msk = 0x4
	// Bit ENDE.
	SDHI0_SD_INFO2_ENDE = 0x4
	// End bit error not detected
	SDHI0_SD_INFO2_ENDE_0 = 0x0
	// End bit error detected
	SDHI0_SD_INFO2_ENDE_1 = 0x1
	// Position of DTO field.
	SDHI0_SD_INFO2_DTO_Pos = 0x3
	// Bit mask of DTO field.
	SDHI0_SD_INFO2_DTO_Msk = 0x8
	// Bit DTO.
	SDHI0_SD_INFO2_DTO = 0x8
	// Data timeout not detected
	SDHI0_SD_INFO2_DTO_0 = 0x0
	// Data timeout detected
	SDHI0_SD_INFO2_DTO_1 = 0x1
	// Position of ILW field.
	SDHI0_SD_INFO2_ILW_Pos = 0x4
	// Bit mask of ILW field.
	SDHI0_SD_INFO2_ILW_Msk = 0x10
	// Bit ILW.
	SDHI0_SD_INFO2_ILW = 0x10
	// Illegal write access to the SD_BUF0 register not detected
	SDHI0_SD_INFO2_ILW_0 = 0x0
	// Illegal write access to the SD_BUF0 register detected
	SDHI0_SD_INFO2_ILW_1 = 0x1
	// Position of ILR field.
	SDHI0_SD_INFO2_ILR_Pos = 0x5
	// Bit mask of ILR field.
	SDHI0_SD_INFO2_ILR_Msk = 0x20
	// Bit ILR.
	SDHI0_SD_INFO2_ILR = 0x20
	// Illegal read access to the SD_BUF0 register not detected
	SDHI0_SD_INFO2_ILR_0 = 0x0
	// Illegal read access to the SD_BUF0 register detected
	SDHI0_SD_INFO2_ILR_1 = 0x1
	// Position of RSPTO field.
	SDHI0_SD_INFO2_RSPTO_Pos = 0x6
	// Bit mask of RSPTO field.
	SDHI0_SD_INFO2_RSPTO_Msk = 0x40
	// Bit RSPTO.
	SDHI0_SD_INFO2_RSPTO = 0x40
	// Response timeout not detected
	SDHI0_SD_INFO2_RSPTO_0 = 0x0
	// Response timeout detected
	SDHI0_SD_INFO2_RSPTO_1 = 0x1
	// Position of SDD0MON field.
	SDHI0_SD_INFO2_SDD0MON_Pos = 0x7
	// Bit mask of SDD0MON field.
	SDHI0_SD_INFO2_SDD0MON_Msk = 0x80
	// Bit SDD0MON.
	SDHI0_SD_INFO2_SDD0MON = 0x80
	// SDnDAT0 pin is low
	SDHI0_SD_INFO2_SDD0MON_0 = 0x0
	// SDnDAT0 pin is high
	SDHI0_SD_INFO2_SDD0MON_1 = 0x1
	// Position of BRE field.
	SDHI0_SD_INFO2_BRE_Pos = 0x8
	// Bit mask of BRE field.
	SDHI0_SD_INFO2_BRE_Msk = 0x100
	// Bit BRE.
	SDHI0_SD_INFO2_BRE = 0x100
	// Disable read access to the SD_BUF0 register
	SDHI0_SD_INFO2_BRE_0 = 0x0
	// Enable read access to the SD_BUF0 register
	SDHI0_SD_INFO2_BRE_1 = 0x1
	// Position of BWE field.
	SDHI0_SD_INFO2_BWE_Pos = 0x9
	// Bit mask of BWE field.
	SDHI0_SD_INFO2_BWE_Msk = 0x200
	// Bit BWE.
	SDHI0_SD_INFO2_BWE = 0x200
	// Disable write access to the SD_BUF0 register
	SDHI0_SD_INFO2_BWE_0 = 0x0
	// Enable write access to the SD_BUF0 register
	SDHI0_SD_INFO2_BWE_1 = 0x1
	// Position of SD_CLK_CTRLEN field.
	SDHI0_SD_INFO2_SD_CLK_CTRLEN_Pos = 0xd
	// Bit mask of SD_CLK_CTRLEN field.
	SDHI0_SD_INFO2_SD_CLK_CTRLEN_Msk = 0x2000
	// Bit SD_CLK_CTRLEN.
	SDHI0_SD_INFO2_SD_CLK_CTRLEN = 0x2000
	// SD/MMC bus (CMD and DAT lines) is busy, so write access to the SD_CLK_CTRL.CLKEN and CLKSEL[7:0] bits is disabled
	SDHI0_SD_INFO2_SD_CLK_CTRLEN_0 = 0x0
	// SD/MMC bus (CMD and DAT lines) is not busy, so write access to the SD_CLK_CTRL.CLKEN and CLKSEL[7:0] bits is enabled
	SDHI0_SD_INFO2_SD_CLK_CTRLEN_1 = 0x1
	// Position of CBSY field.
	SDHI0_SD_INFO2_CBSY_Pos = 0xe
	// Bit mask of CBSY field.
	SDHI0_SD_INFO2_CBSY_Msk = 0x4000
	// Bit CBSY.
	SDHI0_SD_INFO2_CBSY = 0x4000
	// Command sequence complete
	SDHI0_SD_INFO2_CBSY_0 = 0x0
	// Command sequence in progress (busy)
	SDHI0_SD_INFO2_CBSY_1 = 0x1
	// Position of ILA field.
	SDHI0_SD_INFO2_ILA_Pos = 0xf
	// Bit mask of ILA field.
	SDHI0_SD_INFO2_ILA_Msk = 0x8000
	// Bit ILA.
	SDHI0_SD_INFO2_ILA = 0x8000
	// Illegal access error not detected
	SDHI0_SD_INFO2_ILA_0 = 0x0
	// Illegal access error detected
	SDHI0_SD_INFO2_ILA_1 = 0x1

	// SD_INFO1_MASK: SD INFO1 Interrupt Mask Register
	// Position of RSPENDM field.
	SDHI0_SD_INFO1_MASK_RSPENDM_Pos = 0x0
	// Bit mask of RSPENDM field.
	SDHI0_SD_INFO1_MASK_RSPENDM_Msk = 0x1
	// Bit RSPENDM.
	SDHI0_SD_INFO1_MASK_RSPENDM = 0x1
	// Do not mask response end interrupt request
	SDHI0_SD_INFO1_MASK_RSPENDM_0 = 0x0
	// Mask response end interrupt request
	SDHI0_SD_INFO1_MASK_RSPENDM_1 = 0x1
	// Position of ACENDM field.
	SDHI0_SD_INFO1_MASK_ACENDM_Pos = 0x2
	// Bit mask of ACENDM field.
	SDHI0_SD_INFO1_MASK_ACENDM_Msk = 0x4
	// Bit ACENDM.
	SDHI0_SD_INFO1_MASK_ACENDM = 0x4
	// Do not mask access end interrupt request
	SDHI0_SD_INFO1_MASK_ACENDM_0 = 0x0
	// Mask access end interrupt request
	SDHI0_SD_INFO1_MASK_ACENDM_1 = 0x1
	// Position of SDCDRMM field.
	SDHI0_SD_INFO1_MASK_SDCDRMM_Pos = 0x3
	// Bit mask of SDCDRMM field.
	SDHI0_SD_INFO1_MASK_SDCDRMM_Msk = 0x8
	// Bit SDCDRMM.
	SDHI0_SD_INFO1_MASK_SDCDRMM = 0x8
	// Do not mask SD card/MMC removal interrupt request by the SDnCD pin
	SDHI0_SD_INFO1_MASK_SDCDRMM_0 = 0x0
	// Mask SD card/MMC removal interrupt request by the SDnCD pin
	SDHI0_SD_INFO1_MASK_SDCDRMM_1 = 0x1
	// Position of SDCDINM field.
	SDHI0_SD_INFO1_MASK_SDCDINM_Pos = 0x4
	// Bit mask of SDCDINM field.
	SDHI0_SD_INFO1_MASK_SDCDINM_Msk = 0x10
	// Bit SDCDINM.
	SDHI0_SD_INFO1_MASK_SDCDINM = 0x10
	// Do not mask SD card/MMC insertion interrupt request by the SDnCD pin
	SDHI0_SD_INFO1_MASK_SDCDINM_0 = 0x0
	// Mask SD card/MMC insertion interrupt request by the SDnCD pin
	SDHI0_SD_INFO1_MASK_SDCDINM_1 = 0x1
	// Position of SDD3RMM field.
	SDHI0_SD_INFO1_MASK_SDD3RMM_Pos = 0x8
	// Bit mask of SDD3RMM field.
	SDHI0_SD_INFO1_MASK_SDD3RMM_Msk = 0x100
	// Bit SDD3RMM.
	SDHI0_SD_INFO1_MASK_SDD3RMM = 0x100
	// Do not mask SD card/MMC removal interrupt request by the SDnDAT3 pin
	SDHI0_SD_INFO1_MASK_SDD3RMM_0 = 0x0
	// Mask SD card/MMC removal interrupt request by the SDnDAT3 pin
	SDHI0_SD_INFO1_MASK_SDD3RMM_1 = 0x1
	// Position of SDD3INM field.
	SDHI0_SD_INFO1_MASK_SDD3INM_Pos = 0x9
	// Bit mask of SDD3INM field.
	SDHI0_SD_INFO1_MASK_SDD3INM_Msk = 0x200
	// Bit SDD3INM.
	SDHI0_SD_INFO1_MASK_SDD3INM = 0x200
	// Do not mask SD card/MMC insertion interrupt request by the SDnDAT3 pin
	SDHI0_SD_INFO1_MASK_SDD3INM_0 = 0x0
	// Mask SD card/MMC insertion interrupt request by the SDnDAT3 pin
	SDHI0_SD_INFO1_MASK_SDD3INM_1 = 0x1

	// SD_INFO2_MASK: SD INFO2 Interrupt Mask Register
	// Position of CMDEM field.
	SDHI0_SD_INFO2_MASK_CMDEM_Pos = 0x0
	// Bit mask of CMDEM field.
	SDHI0_SD_INFO2_MASK_CMDEM_Msk = 0x1
	// Bit CMDEM.
	SDHI0_SD_INFO2_MASK_CMDEM = 0x1
	// Do not mask command error interrupt request
	SDHI0_SD_INFO2_MASK_CMDEM_0 = 0x0
	// Mask command error interrupt request
	SDHI0_SD_INFO2_MASK_CMDEM_1 = 0x1
	// Position of CRCEM field.
	SDHI0_SD_INFO2_MASK_CRCEM_Pos = 0x1
	// Bit mask of CRCEM field.
	SDHI0_SD_INFO2_MASK_CRCEM_Msk = 0x2
	// Bit CRCEM.
	SDHI0_SD_INFO2_MASK_CRCEM = 0x2
	// Do not mask CRC error interrupt request
	SDHI0_SD_INFO2_MASK_CRCEM_0 = 0x0
	// Mask CRC error interrupt request
	SDHI0_SD_INFO2_MASK_CRCEM_1 = 0x1
	// Position of ENDEM field.
	SDHI0_SD_INFO2_MASK_ENDEM_Pos = 0x2
	// Bit mask of ENDEM field.
	SDHI0_SD_INFO2_MASK_ENDEM_Msk = 0x4
	// Bit ENDEM.
	SDHI0_SD_INFO2_MASK_ENDEM = 0x4
	// Do not mask end bit detection error interrupt request
	SDHI0_SD_INFO2_MASK_ENDEM_0 = 0x0
	// Mask end bit detection error interrupt request
	SDHI0_SD_INFO2_MASK_ENDEM_1 = 0x1
	// Position of DTOM field.
	SDHI0_SD_INFO2_MASK_DTOM_Pos = 0x3
	// Bit mask of DTOM field.
	SDHI0_SD_INFO2_MASK_DTOM_Msk = 0x8
	// Bit DTOM.
	SDHI0_SD_INFO2_MASK_DTOM = 0x8
	// Do not mask data timeout interrupt request
	SDHI0_SD_INFO2_MASK_DTOM_0 = 0x0
	// Mask data timeout interrupt request
	SDHI0_SD_INFO2_MASK_DTOM_1 = 0x1
	// Position of ILWM field.
	SDHI0_SD_INFO2_MASK_ILWM_Pos = 0x4
	// Bit mask of ILWM field.
	SDHI0_SD_INFO2_MASK_ILWM_Msk = 0x10
	// Bit ILWM.
	SDHI0_SD_INFO2_MASK_ILWM = 0x10
	// Do not mask illegal write detection interrupt request for the SD_BUF0 register
	SDHI0_SD_INFO2_MASK_ILWM_0 = 0x0
	// Mask illegal write detection interrupt request for the SD_BUF0 register
	SDHI0_SD_INFO2_MASK_ILWM_1 = 0x1
	// Position of ILRM field.
	SDHI0_SD_INFO2_MASK_ILRM_Pos = 0x5
	// Bit mask of ILRM field.
	SDHI0_SD_INFO2_MASK_ILRM_Msk = 0x20
	// Bit ILRM.
	SDHI0_SD_INFO2_MASK_ILRM = 0x20
	// Do not mask illegal read detection interrupt request for the SD_BUF0 register
	SDHI0_SD_INFO2_MASK_ILRM_0 = 0x0
	// Mask illegal read detection interrupt request for the SD_BUF0 register
	SDHI0_SD_INFO2_MASK_ILRM_1 = 0x1
	// Position of RSPTOM field.
	SDHI0_SD_INFO2_MASK_RSPTOM_Pos = 0x6
	// Bit mask of RSPTOM field.
	SDHI0_SD_INFO2_MASK_RSPTOM_Msk = 0x40
	// Bit RSPTOM.
	SDHI0_SD_INFO2_MASK_RSPTOM = 0x40
	// Do not mask response timeout interrupt request
	SDHI0_SD_INFO2_MASK_RSPTOM_0 = 0x0
	// Mask response timeout interrupt request
	SDHI0_SD_INFO2_MASK_RSPTOM_1 = 0x1
	// Position of BREM field.
	SDHI0_SD_INFO2_MASK_BREM_Pos = 0x8
	// Bit mask of BREM field.
	SDHI0_SD_INFO2_MASK_BREM_Msk = 0x100
	// Bit BREM.
	SDHI0_SD_INFO2_MASK_BREM = 0x100
	// Do not mask read enable interrupt request for the SD buffer
	SDHI0_SD_INFO2_MASK_BREM_0 = 0x0
	// Mask read enable interrupt request for the SD buffer
	SDHI0_SD_INFO2_MASK_BREM_1 = 0x1
	// Position of BWEM field.
	SDHI0_SD_INFO2_MASK_BWEM_Pos = 0x9
	// Bit mask of BWEM field.
	SDHI0_SD_INFO2_MASK_BWEM_Msk = 0x200
	// Bit BWEM.
	SDHI0_SD_INFO2_MASK_BWEM = 0x200
	// Do not mask write enable interrupt request for the SD_BUF0 register
	SDHI0_SD_INFO2_MASK_BWEM_0 = 0x0
	// Mask write enable interrupt request for the SD_BUF0 register
	SDHI0_SD_INFO2_MASK_BWEM_1 = 0x1
	// Position of ILAM field.
	SDHI0_SD_INFO2_MASK_ILAM_Pos = 0xf
	// Bit mask of ILAM field.
	SDHI0_SD_INFO2_MASK_ILAM_Msk = 0x8000
	// Bit ILAM.
	SDHI0_SD_INFO2_MASK_ILAM = 0x8000
	// Do not mask illegal access error interrupt request
	SDHI0_SD_INFO2_MASK_ILAM_0 = 0x0
	// Mask illegal access error interrupt request
	SDHI0_SD_INFO2_MASK_ILAM_1 = 0x1

	// SD_CLK_CTRL: SD Clock Control Register
	// Position of CLKSEL field.
	SDHI0_SD_CLK_CTRL_CLKSEL_Pos = 0x0
	// Bit mask of CLKSEL field.
	SDHI0_SD_CLK_CTRL_CLKSEL_Msk = 0xff
	// PCLKB
	SDHI0_SD_CLK_CTRL_CLKSEL_0xFF = 0xff
	// PCLKB/2
	SDHI0_SD_CLK_CTRL_CLKSEL_0x00 = 0x0
	// PCLKB/4
	SDHI0_SD_CLK_CTRL_CLKSEL_0x01 = 0x1
	// PCLKB/8
	SDHI0_SD_CLK_CTRL_CLKSEL_0x02 = 0x2
	// PCLKB/16
	SDHI0_SD_CLK_CTRL_CLKSEL_0x04 = 0x4
	// PCLKB/32
	SDHI0_SD_CLK_CTRL_CLKSEL_0x08 = 0x8
	// PCLKB/64
	SDHI0_SD_CLK_CTRL_CLKSEL_0x10 = 0x10
	// PCLKB/128
	SDHI0_SD_CLK_CTRL_CLKSEL_0x20 = 0x20
	// PCLKB/256
	SDHI0_SD_CLK_CTRL_CLKSEL_0x40 = 0x40
	// PCLKB/512
	SDHI0_SD_CLK_CTRL_CLKSEL_0x80 = 0x80
	// Position of CLKEN field.
	SDHI0_SD_CLK_CTRL_CLKEN_Pos = 0x8
	// Bit mask of CLKEN field.
	SDHI0_SD_CLK_CTRL_CLKEN_Msk = 0x100
	// Bit CLKEN.
	SDHI0_SD_CLK_CTRL_CLKEN = 0x100
	// Disable SD/MMC clock output (fix SDnCLK signal low)
	SDHI0_SD_CLK_CTRL_CLKEN_0 = 0x0
	// Enable SD/MMC clock output
	SDHI0_SD_CLK_CTRL_CLKEN_1 = 0x1
	// Position of CLKCTRLEN field.
	SDHI0_SD_CLK_CTRL_CLKCTRLEN_Pos = 0x9
	// Bit mask of CLKCTRLEN field.
	SDHI0_SD_CLK_CTRL_CLKCTRLEN_Msk = 0x200
	// Bit CLKCTRLEN.
	SDHI0_SD_CLK_CTRL_CLKCTRLEN = 0x200
	// Disable automatic control of SD/MMC clock output
	SDHI0_SD_CLK_CTRL_CLKCTRLEN_0 = 0x0
	// Enable automatic control of SD/MMC clock output
	SDHI0_SD_CLK_CTRL_CLKCTRLEN_1 = 0x1

	// SD_SIZE: Transfer Data Length Register
	// Position of LEN field.
	SDHI0_SD_SIZE_LEN_Pos = 0x0
	// Bit mask of LEN field.
	SDHI0_SD_SIZE_LEN_Msk = 0x3ff

	// SD_OPTION: SD Card Access Control Option Register
	// Position of CTOP field.
	SDHI0_SD_OPTION_CTOP_Pos = 0x0
	// Bit mask of CTOP field.
	SDHI0_SD_OPTION_CTOP_Msk = 0xf
	// PCLKB × 210
	SDHI0_SD_OPTION_CTOP_0x0 = 0x0
	// PCLKB × 211
	SDHI0_SD_OPTION_CTOP_0x1 = 0x1
	// PCLKB × 212
	SDHI0_SD_OPTION_CTOP_0x2 = 0x2
	// PCLKB × 213
	SDHI0_SD_OPTION_CTOP_0x3 = 0x3
	// PCLKB × 214
	SDHI0_SD_OPTION_CTOP_0x4 = 0x4
	// PCLKB × 215
	SDHI0_SD_OPTION_CTOP_0x5 = 0x5
	// PCLKB × 216
	SDHI0_SD_OPTION_CTOP_0x6 = 0x6
	// PCLKB × 217
	SDHI0_SD_OPTION_CTOP_0x7 = 0x7
	// PCLKB × 218
	SDHI0_SD_OPTION_CTOP_0x8 = 0x8
	// PCLKB × 219
	SDHI0_SD_OPTION_CTOP_0x9 = 0x9
	// PCLKB × 220
	SDHI0_SD_OPTION_CTOP_0xA = 0xa
	// PCLKB × 221
	SDHI0_SD_OPTION_CTOP_0xB = 0xb
	// PCLKB × 222
	SDHI0_SD_OPTION_CTOP_0xC = 0xc
	// PCLKB × 223
	SDHI0_SD_OPTION_CTOP_0xD = 0xd
	// PCLKB × 224
	SDHI0_SD_OPTION_CTOP_0xE = 0xe
	// Setting prohibited
	SDHI0_SD_OPTION_CTOP_0xF = 0xf
	// Position of TOP field.
	SDHI0_SD_OPTION_TOP_Pos = 0x4
	// Bit mask of TOP field.
	SDHI0_SD_OPTION_TOP_Msk = 0xf0
	// SDHI clock × 213
	SDHI0_SD_OPTION_TOP_0x0 = 0x0
	// SDHI clock × 214
	SDHI0_SD_OPTION_TOP_0x1 = 0x1
	// SDHI clock × 215
	SDHI0_SD_OPTION_TOP_0x2 = 0x2
	// SDHI clock × 216
	SDHI0_SD_OPTION_TOP_0x3 = 0x3
	// SDHI clock × 217
	SDHI0_SD_OPTION_TOP_0x4 = 0x4
	// SDHI clock × 218
	SDHI0_SD_OPTION_TOP_0x5 = 0x5
	// SDHI clock × 219
	SDHI0_SD_OPTION_TOP_0x6 = 0x6
	// SDHI clock × 220
	SDHI0_SD_OPTION_TOP_0x7 = 0x7
	// SDHI clock × 221
	SDHI0_SD_OPTION_TOP_0x8 = 0x8
	// SDHI clock × 222
	SDHI0_SD_OPTION_TOP_0x9 = 0x9
	// SDHI clock × 223
	SDHI0_SD_OPTION_TOP_0xA = 0xa
	// SDHI clock × 224
	SDHI0_SD_OPTION_TOP_0xB = 0xb
	// SDHI clock × 225
	SDHI0_SD_OPTION_TOP_0xC = 0xc
	// SDHI clock × 226
	SDHI0_SD_OPTION_TOP_0xD = 0xd
	// SDHI clock × 227
	SDHI0_SD_OPTION_TOP_0xE = 0xe
	// Setting prohibited
	SDHI0_SD_OPTION_TOP_0xF = 0xf
	// Position of TOUTMASK field.
	SDHI0_SD_OPTION_TOUTMASK_Pos = 0x8
	// Bit mask of TOUTMASK field.
	SDHI0_SD_OPTION_TOUTMASK_Msk = 0x100
	// Bit TOUTMASK.
	SDHI0_SD_OPTION_TOUTMASK = 0x100
	// Activate timeout
	SDHI0_SD_OPTION_TOUTMASK_0 = 0x0
	// Inactivate timeout (do not set RSPTO and DTO bits of SD_INFO2 or CRCBSYTO, CRCTO, RDTO, BSYTO1, BSYTO0, RSPTO1 and RSPTO0 bits of SD_ERR_STS2) When timeout occurs because of an inactivated timeout, execute a software reset to terminate the command sequence.
	SDHI0_SD_OPTION_TOUTMASK_1 = 0x1
	// Position of WIDTH8 field.
	SDHI0_SD_OPTION_WIDTH8_Pos = 0xd
	// Bit mask of WIDTH8 field.
	SDHI0_SD_OPTION_WIDTH8_Msk = 0x2000
	// Bit WIDTH8.
	SDHI0_SD_OPTION_WIDTH8 = 0x2000
	// Position of WIDTH field.
	SDHI0_SD_OPTION_WIDTH_Pos = 0xf
	// Bit mask of WIDTH field.
	SDHI0_SD_OPTION_WIDTH_Msk = 0x8000
	// Bit WIDTH.
	SDHI0_SD_OPTION_WIDTH = 0x8000

	// SD_ERR_STS1: SD Error Status Register 1
	// Position of CMDE0 field.
	SDHI0_SD_ERR_STS1_CMDE0_Pos = 0x0
	// Bit mask of CMDE0 field.
	SDHI0_SD_ERR_STS1_CMDE0_Msk = 0x1
	// Bit CMDE0.
	SDHI0_SD_ERR_STS1_CMDE0 = 0x1
	// No error exists in command index field value of a command response
	SDHI0_SD_ERR_STS1_CMDE0_0 = 0x0
	// Error exists in command index field value of a command response
	SDHI0_SD_ERR_STS1_CMDE0_1 = 0x1
	// Position of CMDE1 field.
	SDHI0_SD_ERR_STS1_CMDE1_Pos = 0x1
	// Bit mask of CMDE1 field.
	SDHI0_SD_ERR_STS1_CMDE1_Msk = 0x2
	// Bit CMDE1.
	SDHI0_SD_ERR_STS1_CMDE1 = 0x2
	// No error exists in command index field value of a command response
	SDHI0_SD_ERR_STS1_CMDE1_0 = 0x0
	// Error exists in command index field value of a command response (with SD_CMD.CMDIDX[5:0] setting, an error that occurs with CMD12 issue is indicated in the CMDE0 flag)
	SDHI0_SD_ERR_STS1_CMDE1_1 = 0x1
	// Position of RSPLENE0 field.
	SDHI0_SD_ERR_STS1_RSPLENE0_Pos = 0x2
	// Bit mask of RSPLENE0 field.
	SDHI0_SD_ERR_STS1_RSPLENE0_Msk = 0x4
	// Bit RSPLENE0.
	SDHI0_SD_ERR_STS1_RSPLENE0 = 0x4
	// No error exists in command response length
	SDHI0_SD_ERR_STS1_RSPLENE0_0 = 0x0
	// Error exists in command response length
	SDHI0_SD_ERR_STS1_RSPLENE0_1 = 0x1
	// Position of RSPLENE1 field.
	SDHI0_SD_ERR_STS1_RSPLENE1_Pos = 0x3
	// Bit mask of RSPLENE1 field.
	SDHI0_SD_ERR_STS1_RSPLENE1_Msk = 0x8
	// Bit RSPLENE1.
	SDHI0_SD_ERR_STS1_RSPLENE1 = 0x8
	// No error exists in command response length
	SDHI0_SD_ERR_STS1_RSPLENE1_0 = 0x0
	// Error exists in command response length (with SD_CMD.CMDIDX[5:0] setting, an error that occurs with CMD12 issue is indicated in the RSPLENE0 flag)
	SDHI0_SD_ERR_STS1_RSPLENE1_1 = 0x1
	// Position of RDLENE field.
	SDHI0_SD_ERR_STS1_RDLENE_Pos = 0x4
	// Bit mask of RDLENE field.
	SDHI0_SD_ERR_STS1_RDLENE_Msk = 0x10
	// Bit RDLENE.
	SDHI0_SD_ERR_STS1_RDLENE = 0x10
	// No read data length error occurred
	SDHI0_SD_ERR_STS1_RDLENE_0 = 0x0
	// Read data length error occurred
	SDHI0_SD_ERR_STS1_RDLENE_1 = 0x1
	// Position of CRCLENE field.
	SDHI0_SD_ERR_STS1_CRCLENE_Pos = 0x5
	// Bit mask of CRCLENE field.
	SDHI0_SD_ERR_STS1_CRCLENE_Msk = 0x20
	// Bit CRCLENE.
	SDHI0_SD_ERR_STS1_CRCLENE = 0x20
	// No CRC status token length error occurred
	SDHI0_SD_ERR_STS1_CRCLENE_0 = 0x0
	// CRC status token length error occurred
	SDHI0_SD_ERR_STS1_CRCLENE_1 = 0x1
	// Position of RSPCRCE0 field.
	SDHI0_SD_ERR_STS1_RSPCRCE0_Pos = 0x8
	// Bit mask of RSPCRCE0 field.
	SDHI0_SD_ERR_STS1_RSPCRCE0_Msk = 0x100
	// Bit RSPCRCE0.
	SDHI0_SD_ERR_STS1_RSPCRCE0 = 0x100
	// No CRC error detected in command response
	SDHI0_SD_ERR_STS1_RSPCRCE0_0 = 0x0
	// CRC error detected in command response
	SDHI0_SD_ERR_STS1_RSPCRCE0_1 = 0x1
	// Position of RSPCRCE1 field.
	SDHI0_SD_ERR_STS1_RSPCRCE1_Pos = 0x9
	// Bit mask of RSPCRCE1 field.
	SDHI0_SD_ERR_STS1_RSPCRCE1_Msk = 0x200
	// Bit RSPCRCE1.
	SDHI0_SD_ERR_STS1_RSPCRCE1 = 0x200
	// No CRC error detected in command response (with SD_CMD.CMDIDX[5:0] setting, an error that occurs with CMD12 issue is indicated in the RSPCRCE0 flag)
	SDHI0_SD_ERR_STS1_RSPCRCE1_0 = 0x0
	// CRC error detected in command response
	SDHI0_SD_ERR_STS1_RSPCRCE1_1 = 0x1
	// Position of RDCRCE field.
	SDHI0_SD_ERR_STS1_RDCRCE_Pos = 0xa
	// Bit mask of RDCRCE field.
	SDHI0_SD_ERR_STS1_RDCRCE_Msk = 0x400
	// Bit RDCRCE.
	SDHI0_SD_ERR_STS1_RDCRCE = 0x400
	// No CRC error detected in read data
	SDHI0_SD_ERR_STS1_RDCRCE_0 = 0x0
	// CRC error detected in read data
	SDHI0_SD_ERR_STS1_RDCRCE_1 = 0x1
	// Position of CRCTKE field.
	SDHI0_SD_ERR_STS1_CRCTKE_Pos = 0xb
	// Bit mask of CRCTKE field.
	SDHI0_SD_ERR_STS1_CRCTKE_Msk = 0x800
	// Bit CRCTKE.
	SDHI0_SD_ERR_STS1_CRCTKE = 0x800
	// No error detected in CRC status token
	SDHI0_SD_ERR_STS1_CRCTKE_0 = 0x0
	// Error detected in CRC status token
	SDHI0_SD_ERR_STS1_CRCTKE_1 = 0x1
	// Position of CRCTK field.
	SDHI0_SD_ERR_STS1_CRCTK_Pos = 0xc
	// Bit mask of CRCTK field.
	SDHI0_SD_ERR_STS1_CRCTK_Msk = 0x7000

	// SD_ERR_STS2: SD Error Status Register 2
	// Position of RSPTO0 field.
	SDHI0_SD_ERR_STS2_RSPTO0_Pos = 0x0
	// Bit mask of RSPTO0 field.
	SDHI0_SD_ERR_STS2_RSPTO0_Msk = 0x1
	// Bit RSPTO0.
	SDHI0_SD_ERR_STS2_RSPTO0 = 0x1
	// After command was issued, response was received in less than 640 cycles of the SD/MMC clock
	SDHI0_SD_ERR_STS2_RSPTO0_0 = 0x0
	// After command was issued, response was not received in 640 or more cycles of the SD/MMC clock
	SDHI0_SD_ERR_STS2_RSPTO0_1 = 0x1
	// Position of RSPTO1 field.
	SDHI0_SD_ERR_STS2_RSPTO1_Pos = 0x1
	// Bit mask of RSPTO1 field.
	SDHI0_SD_ERR_STS2_RSPTO1_Msk = 0x2
	// Bit RSPTO1.
	SDHI0_SD_ERR_STS2_RSPTO1 = 0x2
	// After command was issued, response was received in less than 640 cycles of the SD/MMC clock
	SDHI0_SD_ERR_STS2_RSPTO1_0 = 0x0
	// After command was issued, response was not received after 640 or more cycles of the SD/MMC clock (with SD_CMD.CMDIDX[5:0] setting, an error that occurs with CMD12 issue is indicated in the RSPTO0 flag)
	SDHI0_SD_ERR_STS2_RSPTO1_1 = 0x1
	// Position of BSYTO0 field.
	SDHI0_SD_ERR_STS2_BSYTO0_Pos = 0x2
	// Bit mask of BSYTO0 field.
	SDHI0_SD_ERR_STS2_BSYTO0_Msk = 0x4
	// Bit BSYTO0.
	SDHI0_SD_ERR_STS2_BSYTO0 = 0x4
	// After R1b response was received, SD/MMC was released from the busy state during the specified period
	SDHI0_SD_ERR_STS2_BSYTO0_0 = 0x0
	// After R1b response was received, SD/MMC was in the busy state after the specified period elapsed
	SDHI0_SD_ERR_STS2_BSYTO0_1 = 0x1
	// Position of BSYTO1 field.
	SDHI0_SD_ERR_STS2_BSYTO1_Pos = 0x3
	// Bit mask of BSYTO1 field.
	SDHI0_SD_ERR_STS2_BSYTO1_Msk = 0x8
	// Bit BSYTO1.
	SDHI0_SD_ERR_STS2_BSYTO1 = 0x8
	// After CMD12 was automatically issued, SD/MMC was released from the busy state during the specified period
	SDHI0_SD_ERR_STS2_BSYTO1_0 = 0x0
	// After CMD12 was automatically issued, SD/MMC was in the busy state after the specified period elapsed (with SD_CMD.CMDIDX[5:0] setting, an error that occurs with CMD12 issue is indicated in the BSYTO0 flag)
	SDHI0_SD_ERR_STS2_BSYTO1_1 = 0x1
	// Position of RDTO field.
	SDHI0_SD_ERR_STS2_RDTO_Pos = 0x4
	// Bit mask of RDTO field.
	SDHI0_SD_ERR_STS2_RDTO_Msk = 0x10
	// Bit RDTO.
	SDHI0_SD_ERR_STS2_RDTO = 0x10
	// Position of CRCTO field.
	SDHI0_SD_ERR_STS2_CRCTO_Pos = 0x5
	// Bit mask of CRCTO field.
	SDHI0_SD_ERR_STS2_CRCTO_Msk = 0x20
	// Bit CRCTO.
	SDHI0_SD_ERR_STS2_CRCTO = 0x20
	// After CRC data was written to the SD card/MMC, a CRC status token was received during the specified period
	SDHI0_SD_ERR_STS2_CRCTO_0 = 0x0
	// After CRC data was written to the SD card/MMC, a CRC status token was not received after the specified period elapsed
	SDHI0_SD_ERR_STS2_CRCTO_1 = 0x1
	// Position of CRCBSYTO field.
	SDHI0_SD_ERR_STS2_CRCBSYTO_Pos = 0x6
	// Bit mask of CRCBSYTO field.
	SDHI0_SD_ERR_STS2_CRCBSYTO_Msk = 0x40
	// Bit CRCBSYTO.
	SDHI0_SD_ERR_STS2_CRCBSYTO = 0x40
	// After a CRC status token was received, the SD/MMC was released from the busy state during the specified period
	SDHI0_SD_ERR_STS2_CRCBSYTO_0 = 0x0
	// After a CRC status token was received, the SD/MMC was in the busy state after the specified period elapsed
	SDHI0_SD_ERR_STS2_CRCBSYTO_1 = 0x1

	// SDIO_MODE: SDIO Mode Control Register
	// Position of INTEN field.
	SDHI0_SDIO_MODE_INTEN_Pos = 0x0
	// Bit mask of INTEN field.
	SDHI0_SDIO_MODE_INTEN_Msk = 0x1
	// Bit INTEN.
	SDHI0_SDIO_MODE_INTEN = 0x1
	// Disable SDIO interrupt acceptance
	SDHI0_SDIO_MODE_INTEN_0 = 0x0
	// Enable SDIO interrupt acceptance
	SDHI0_SDIO_MODE_INTEN_1 = 0x1
	// Position of RWREQ field.
	SDHI0_SDIO_MODE_RWREQ_Pos = 0x2
	// Bit mask of RWREQ field.
	SDHI0_SDIO_MODE_RWREQ_Msk = 0x4
	// Bit RWREQ.
	SDHI0_SDIO_MODE_RWREQ = 0x4
	// Allow SD/MMC to exit read wait state
	SDHI0_SDIO_MODE_RWREQ_0 = 0x0
	// Request for SD/MMC to enter read wait state
	SDHI0_SDIO_MODE_RWREQ_1 = 0x1
	// Position of IOABT field.
	SDHI0_SDIO_MODE_IOABT_Pos = 0x8
	// Bit mask of IOABT field.
	SDHI0_SDIO_MODE_IOABT_Msk = 0x100
	// Bit IOABT.
	SDHI0_SDIO_MODE_IOABT = 0x100
	// Position of C52PUB field.
	SDHI0_SDIO_MODE_C52PUB_Pos = 0x9
	// Bit mask of C52PUB field.
	SDHI0_SDIO_MODE_C52PUB_Msk = 0x200
	// Bit C52PUB.
	SDHI0_SDIO_MODE_C52PUB = 0x200

	// SDIO_INFO1: SDIO Interrupt Flag Register
	// Position of IOIRQ field.
	SDHI0_SDIO_INFO1_IOIRQ_Pos = 0x0
	// Bit mask of IOIRQ field.
	SDHI0_SDIO_INFO1_IOIRQ_Msk = 0x1
	// Bit IOIRQ.
	SDHI0_SDIO_INFO1_IOIRQ = 0x1
	// No SDIO interrupt detected
	SDHI0_SDIO_INFO1_IOIRQ_0 = 0x0
	// SDIO interrupt detected
	SDHI0_SDIO_INFO1_IOIRQ_1 = 0x1
	// Position of EXPUB52 field.
	SDHI0_SDIO_INFO1_EXPUB52_Pos = 0xe
	// Bit mask of EXPUB52 field.
	SDHI0_SDIO_INFO1_EXPUB52_Msk = 0x4000
	// Bit EXPUB52.
	SDHI0_SDIO_INFO1_EXPUB52 = 0x4000
	// Position of EXWT field.
	SDHI0_SDIO_INFO1_EXWT_Pos = 0xf
	// Bit mask of EXWT field.
	SDHI0_SDIO_INFO1_EXWT_Msk = 0x8000
	// Bit EXWT.
	SDHI0_SDIO_INFO1_EXWT = 0x8000

	// SDIO_INFO1_MASK: SDIO INFO1 Interrupt Mask Register
	// Position of IOIRQM field.
	SDHI0_SDIO_INFO1_MASK_IOIRQM_Pos = 0x0
	// Bit mask of IOIRQM field.
	SDHI0_SDIO_INFO1_MASK_IOIRQM_Msk = 0x1
	// Bit IOIRQM.
	SDHI0_SDIO_INFO1_MASK_IOIRQM = 0x1
	// Do not mask IOIRQ interrupts
	SDHI0_SDIO_INFO1_MASK_IOIRQM_0 = 0x0
	// Mask IOIRQ interrupts
	SDHI0_SDIO_INFO1_MASK_IOIRQM_1 = 0x1
	// Position of EXPUB52M field.
	SDHI0_SDIO_INFO1_MASK_EXPUB52M_Pos = 0xe
	// Bit mask of EXPUB52M field.
	SDHI0_SDIO_INFO1_MASK_EXPUB52M_Msk = 0x4000
	// Bit EXPUB52M.
	SDHI0_SDIO_INFO1_MASK_EXPUB52M = 0x4000
	// Do not mask EXPUB52 interrupt requests
	SDHI0_SDIO_INFO1_MASK_EXPUB52M_0 = 0x0
	// Mask EXPUB52 interrupt requests
	SDHI0_SDIO_INFO1_MASK_EXPUB52M_1 = 0x1
	// Position of EXWTM field.
	SDHI0_SDIO_INFO1_MASK_EXWTM_Pos = 0xf
	// Bit mask of EXWTM field.
	SDHI0_SDIO_INFO1_MASK_EXWTM_Msk = 0x8000
	// Bit EXWTM.
	SDHI0_SDIO_INFO1_MASK_EXWTM = 0x8000
	// Do not mask EXWT interrupt requests
	SDHI0_SDIO_INFO1_MASK_EXWTM_0 = 0x0
	// Mask EXWT interrupt requests
	SDHI0_SDIO_INFO1_MASK_EXWTM_1 = 0x1

	// SD_DMAEN: DMA Mode Enable Register
	// Position of DMAEN field.
	SDHI0_SD_DMAEN_DMAEN_Pos = 0x1
	// Bit mask of DMAEN field.
	SDHI0_SD_DMAEN_DMAEN_Msk = 0x2
	// Bit DMAEN.
	SDHI0_SD_DMAEN_DMAEN = 0x2
	// Disable use of DMA transfer to access SD_BUF0 register
	SDHI0_SD_DMAEN_DMAEN_0 = 0x0
	// Enable use of DMA transfer to access SD_BUF0 register
	SDHI0_SD_DMAEN_DMAEN_1 = 0x1

	// SOFT_RST: Software Reset Register
	// Position of SDRST field.
	SDHI0_SOFT_RST_SDRST_Pos = 0x0
	// Bit mask of SDRST field.
	SDHI0_SOFT_RST_SDRST_Msk = 0x1
	// Bit SDRST.
	SDHI0_SOFT_RST_SDRST = 0x1
	// Reset SD/MMC Host Interface software
	SDHI0_SOFT_RST_SDRST_0 = 0x0
	// Cancel reset of SD/MMC Host Interface software
	SDHI0_SOFT_RST_SDRST_1 = 0x1

	// SDIF_MODE: SD Interface Mode Setting Register
	// Position of NOCHKCR field.
	SDHI0_SDIF_MODE_NOCHKCR_Pos = 0x8
	// Bit mask of NOCHKCR field.
	SDHI0_SDIF_MODE_NOCHKCR_Msk = 0x100
	// Bit NOCHKCR.
	SDHI0_SDIF_MODE_NOCHKCR = 0x100
	// Enable CRC check
	SDHI0_SDIF_MODE_NOCHKCR_0 = 0x0
	// Disable CRC Check (ignore CRC16 valued when reading and ignore CRC status value when writing)
	SDHI0_SDIF_MODE_NOCHKCR_1 = 0x1

	// EXT_SWAP: Swap Control Register
	// Position of BWSWP field.
	SDHI0_EXT_SWAP_BWSWP_Pos = 0x6
	// Bit mask of BWSWP field.
	SDHI0_EXT_SWAP_BWSWP_Msk = 0x40
	// Bit BWSWP.
	SDHI0_EXT_SWAP_BWSWP = 0x40
	// Normal write operation
	SDHI0_EXT_SWAP_BWSWP_0 = 0x0
	// Swap the byte endian order before writing to SD_BUF0 register
	SDHI0_EXT_SWAP_BWSWP_1 = 0x1
	// Position of BRSWP field.
	SDHI0_EXT_SWAP_BRSWP_Pos = 0x7
	// Bit mask of BRSWP field.
	SDHI0_EXT_SWAP_BRSWP_Msk = 0x80
	// Bit BRSWP.
	SDHI0_EXT_SWAP_BRSWP = 0x80
	// Normal read operation
	SDHI0_EXT_SWAP_BRSWP_0 = 0x0
	// Swap the byte endian order before reading SD_BUF0 register
	SDHI0_EXT_SWAP_BRSWP_1 = 0x1
)

// Constants for SSIE0: Serial Sound Interface Enhanced (SSIE)
const (
	// SSICR: Control Register
	// Position of REN field.
	SSIE0_SSICR_REN_Pos = 0x0
	// Bit mask of REN field.
	SSIE0_SSICR_REN_Msk = 0x1
	// Bit REN.
	SSIE0_SSICR_REN = 0x1
	// Disables reception
	SSIE0_SSICR_REN_0 = 0x0
	// Enables reception (starts reception)
	SSIE0_SSICR_REN_1 = 0x1
	// Position of TEN field.
	SSIE0_SSICR_TEN_Pos = 0x1
	// Bit mask of TEN field.
	SSIE0_SSICR_TEN_Msk = 0x2
	// Bit TEN.
	SSIE0_SSICR_TEN = 0x2
	// Disables transmission
	SSIE0_SSICR_TEN_0 = 0x0
	// Enables transmission (starts transmission)
	SSIE0_SSICR_TEN_1 = 0x1
	// Position of MUEN field.
	SSIE0_SSICR_MUEN_Pos = 0x3
	// Bit mask of MUEN field.
	SSIE0_SSICR_MUEN_Msk = 0x8
	// Bit MUEN.
	SSIE0_SSICR_MUEN = 0x8
	// Disables muting on the next frame boundary
	SSIE0_SSICR_MUEN_0 = 0x0
	// Enables muting on the next frame boundary
	SSIE0_SSICR_MUEN_1 = 0x1
	// Position of CKDV field.
	SSIE0_SSICR_CKDV_Pos = 0x4
	// Bit mask of CKDV field.
	SSIE0_SSICR_CKDV_Msk = 0xf0
	// AUDIO_MCK
	SSIE0_SSICR_CKDV_0x0 = 0x0
	// AUDIO_MCK/2
	SSIE0_SSICR_CKDV_0x1 = 0x1
	// AUDIO_MCK/4
	SSIE0_SSICR_CKDV_0x2 = 0x2
	// AUDIO_MCK/8
	SSIE0_SSICR_CKDV_0x3 = 0x3
	// AUDIO_MCK/16
	SSIE0_SSICR_CKDV_0x4 = 0x4
	// AUDIO_MCK/32
	SSIE0_SSICR_CKDV_0x5 = 0x5
	// AUDIO_MCK/64
	SSIE0_SSICR_CKDV_0x6 = 0x6
	// AUDIO_MCK/128
	SSIE0_SSICR_CKDV_0x7 = 0x7
	// AUDIO_MCK/6
	SSIE0_SSICR_CKDV_0x8 = 0x8
	// AUDIO_MCK/12
	SSIE0_SSICR_CKDV_0x9 = 0x9
	// AUDIO_MCK/24
	SSIE0_SSICR_CKDV_0xA = 0xa
	// AUDIO_MCK/48
	SSIE0_SSICR_CKDV_0xB = 0xb
	// AUDIO_MCK/96
	SSIE0_SSICR_CKDV_0xC = 0xc
	// Position of DEL field.
	SSIE0_SSICR_DEL_Pos = 0x8
	// Bit mask of DEL field.
	SSIE0_SSICR_DEL_Msk = 0x100
	// Bit DEL.
	SSIE0_SSICR_DEL = 0x100
	// Delay of 1 cycle of SSIBCK between SSILRCK/SSIFS and SSITXD0/SSIRXD0/SSIDATA0
	SSIE0_SSICR_DEL_0 = 0x0
	// No delay between SSILRCK/SSIFS and SSITXD0/SSIRXD0/SSIDATA0
	SSIE0_SSICR_DEL_1 = 0x1
	// Position of PDTA field.
	SSIE0_SSICR_PDTA_Pos = 0x9
	// Bit mask of PDTA field.
	SSIE0_SSICR_PDTA_Msk = 0x200
	// Bit PDTA.
	SSIE0_SSICR_PDTA = 0x200
	// Left-justifies placement data (SSIFTDR, SSIFRDR)
	SSIE0_SSICR_PDTA_0 = 0x0
	// Right-justifies placement data (SSIFTDR, SSIFRDR)
	SSIE0_SSICR_PDTA_1 = 0x1
	// Position of SDTA field.
	SSIE0_SSICR_SDTA_Pos = 0xa
	// Bit mask of SDTA field.
	SSIE0_SSICR_SDTA_Msk = 0x400
	// Bit SDTA.
	SSIE0_SSICR_SDTA = 0x400
	// Transmits and receives serial data first and then padding bits
	SSIE0_SSICR_SDTA_0 = 0x0
	// Transmit and receives padding bits first and then serial data
	SSIE0_SSICR_SDTA_1 = 0x1
	// Position of SPDP field.
	SSIE0_SSICR_SPDP_Pos = 0xb
	// Bit mask of SPDP field.
	SSIE0_SSICR_SPDP_Msk = 0x800
	// Bit SPDP.
	SSIE0_SSICR_SPDP = 0x800
	// Padding data is at a low level
	SSIE0_SSICR_SPDP_0 = 0x0
	// Padding data is at a high level
	SSIE0_SSICR_SPDP_1 = 0x1
	// Position of LRCKP field.
	SSIE0_SSICR_LRCKP_Pos = 0xc
	// Bit mask of LRCKP field.
	SSIE0_SSICR_LRCKP_Msk = 0x1000
	// Bit LRCKP.
	SSIE0_SSICR_LRCKP = 0x1000
	// The initial value is at a high level. The start trigger for a frame is synchronized with a falling edge of SSILRCK/SSIFS.
	SSIE0_SSICR_LRCKP_0 = 0x0
	// The initial value is at a low level. The start trigger for a frame is synchronized with a rising edge of SSILRCK/SSIFS.
	SSIE0_SSICR_LRCKP_1 = 0x1
	// Position of BCKP field.
	SSIE0_SSICR_BCKP_Pos = 0xd
	// Bit mask of BCKP field.
	SSIE0_SSICR_BCKP_Msk = 0x2000
	// Bit BCKP.
	SSIE0_SSICR_BCKP = 0x2000
	// SSILRCK/SSIFS and SSITXD0/SSIRXD0/SSIDATA0 change at a falling edge (SSILRCK/SSIFS and SSIRXD0/SSIDATA0 are sampled at a rising edge of SSIBCK).
	SSIE0_SSICR_BCKP_0 = 0x0
	// SSILRCK/SSIFS and SSITXD0/SSIRXD0/SSIDATA0 change at a rising edge (SSILRCK/SSIFS and SSIRXD0/SSIDATA0 are sampled at a falling edge of SSIBCK).
	SSIE0_SSICR_BCKP_1 = 0x1
	// Position of MST field.
	SSIE0_SSICR_MST_Pos = 0xe
	// Bit mask of MST field.
	SSIE0_SSICR_MST_Msk = 0x4000
	// Bit MST.
	SSIE0_SSICR_MST = 0x4000
	// Slave-mode communication
	SSIE0_SSICR_MST_0 = 0x0
	// Master-mode communication
	SSIE0_SSICR_MST_1 = 0x1
	// Position of SWL field.
	SSIE0_SSICR_SWL_Pos = 0x10
	// Bit mask of SWL field.
	SSIE0_SSICR_SWL_Msk = 0x70000
	// 8 bits
	SSIE0_SSICR_SWL_000 = 0x0
	// 16 bits
	SSIE0_SSICR_SWL_001 = 0x1
	// 24 bits
	SSIE0_SSICR_SWL_010 = 0x2
	// 32 bits
	SSIE0_SSICR_SWL_011 = 0x3
	// 48 bits
	SSIE0_SSICR_SWL_100 = 0x4
	// 64 bits
	SSIE0_SSICR_SWL_101 = 0x5
	// 128 bits
	SSIE0_SSICR_SWL_110 = 0x6
	// 256 bits
	SSIE0_SSICR_SWL_111 = 0x7
	// Position of DWL field.
	SSIE0_SSICR_DWL_Pos = 0x13
	// Bit mask of DWL field.
	SSIE0_SSICR_DWL_Msk = 0x380000
	// 8 bits
	SSIE0_SSICR_DWL_000 = 0x0
	// 16 bits
	SSIE0_SSICR_DWL_001 = 0x1
	// 18 bits
	SSIE0_SSICR_DWL_010 = 0x2
	// 20 bits
	SSIE0_SSICR_DWL_011 = 0x3
	// 22 bits
	SSIE0_SSICR_DWL_100 = 0x4
	// 24 bits
	SSIE0_SSICR_DWL_101 = 0x5
	// 32 bits
	SSIE0_SSICR_DWL_110 = 0x6
	// Setting prohibited
	SSIE0_SSICR_DWL_111 = 0x7
	// Position of FRM field.
	SSIE0_SSICR_FRM_Pos = 0x16
	// Bit mask of FRM field.
	SSIE0_SSICR_FRM_Msk = 0xc00000
	// Position of IIEN field.
	SSIE0_SSICR_IIEN_Pos = 0x19
	// Bit mask of IIEN field.
	SSIE0_SSICR_IIEN_Msk = 0x2000000
	// Bit IIEN.
	SSIE0_SSICR_IIEN = 0x2000000
	// Disables idle mode interrupt output
	SSIE0_SSICR_IIEN_0 = 0x0
	// Enables idle mode interrupt output
	SSIE0_SSICR_IIEN_1 = 0x1
	// Position of ROIEN field.
	SSIE0_SSICR_ROIEN_Pos = 0x1a
	// Bit mask of ROIEN field.
	SSIE0_SSICR_ROIEN_Msk = 0x4000000
	// Bit ROIEN.
	SSIE0_SSICR_ROIEN = 0x4000000
	// Disables receive overflow interrupt output
	SSIE0_SSICR_ROIEN_0 = 0x0
	// Enables receive overflow interrupt output
	SSIE0_SSICR_ROIEN_1 = 0x1
	// Position of RUIEN field.
	SSIE0_SSICR_RUIEN_Pos = 0x1b
	// Bit mask of RUIEN field.
	SSIE0_SSICR_RUIEN_Msk = 0x8000000
	// Bit RUIEN.
	SSIE0_SSICR_RUIEN = 0x8000000
	// Disables receive underflow interrupt output
	SSIE0_SSICR_RUIEN_0 = 0x0
	// Enables receive underflow interrupt output
	SSIE0_SSICR_RUIEN_1 = 0x1
	// Position of TOIEN field.
	SSIE0_SSICR_TOIEN_Pos = 0x1c
	// Bit mask of TOIEN field.
	SSIE0_SSICR_TOIEN_Msk = 0x10000000
	// Bit TOIEN.
	SSIE0_SSICR_TOIEN = 0x10000000
	// Disables transmit overflow interrupt output
	SSIE0_SSICR_TOIEN_0 = 0x0
	// Enables transmit overflow interrupt output
	SSIE0_SSICR_TOIEN_1 = 0x1
	// Position of TUIEN field.
	SSIE0_SSICR_TUIEN_Pos = 0x1d
	// Bit mask of TUIEN field.
	SSIE0_SSICR_TUIEN_Msk = 0x20000000
	// Bit TUIEN.
	SSIE0_SSICR_TUIEN = 0x20000000
	// Disables transmit underflow interrupt output
	SSIE0_SSICR_TUIEN_0 = 0x0
	// Enables transmit underflow interrupt output
	SSIE0_SSICR_TUIEN_1 = 0x1

	// SSISR: Status Register
	// Position of IIRQ field.
	SSIE0_SSISR_IIRQ_Pos = 0x19
	// Bit mask of IIRQ field.
	SSIE0_SSISR_IIRQ_Msk = 0x2000000
	// Bit IIRQ.
	SSIE0_SSISR_IIRQ = 0x2000000
	// In the communication state
	SSIE0_SSISR_IIRQ_0 = 0x0
	// In the idle state
	SSIE0_SSISR_IIRQ_1 = 0x1
	// Position of ROIRQ field.
	SSIE0_SSISR_ROIRQ_Pos = 0x1a
	// Bit mask of ROIRQ field.
	SSIE0_SSISR_ROIRQ_Msk = 0x4000000
	// Bit ROIRQ.
	SSIE0_SSISR_ROIRQ = 0x4000000
	// No receive overflow error is generated.
	SSIE0_SSISR_ROIRQ_0 = 0x0
	// A receive overflow error is generated.
	SSIE0_SSISR_ROIRQ_1 = 0x1
	// Position of RUIRQ field.
	SSIE0_SSISR_RUIRQ_Pos = 0x1b
	// Bit mask of RUIRQ field.
	SSIE0_SSISR_RUIRQ_Msk = 0x8000000
	// Bit RUIRQ.
	SSIE0_SSISR_RUIRQ = 0x8000000
	// No receive underflow error is generated.
	SSIE0_SSISR_RUIRQ_0 = 0x0
	// A receive underflow error is generated.
	SSIE0_SSISR_RUIRQ_1 = 0x1
	// Position of TOIRQ field.
	SSIE0_SSISR_TOIRQ_Pos = 0x1c
	// Bit mask of TOIRQ field.
	SSIE0_SSISR_TOIRQ_Msk = 0x10000000
	// Bit TOIRQ.
	SSIE0_SSISR_TOIRQ = 0x10000000
	// No transmit overflow error is generated.
	SSIE0_SSISR_TOIRQ_0 = 0x0
	// A transmit overflow error is generated.
	SSIE0_SSISR_TOIRQ_1 = 0x1
	// Position of TUIRQ field.
	SSIE0_SSISR_TUIRQ_Pos = 0x1d
	// Bit mask of TUIRQ field.
	SSIE0_SSISR_TUIRQ_Msk = 0x20000000
	// Bit TUIRQ.
	SSIE0_SSISR_TUIRQ = 0x20000000
	// No transmit underflow error is generated.
	SSIE0_SSISR_TUIRQ_0 = 0x0
	// A transmit underflow error is generated.
	SSIE0_SSISR_TUIRQ_1 = 0x1

	// SSIFCR: FIFO Control Register
	// Position of RFRST field.
	SSIE0_SSIFCR_RFRST_Pos = 0x0
	// Bit mask of RFRST field.
	SSIE0_SSIFCR_RFRST_Msk = 0x1
	// Bit RFRST.
	SSIE0_SSIFCR_RFRST = 0x1
	// Clears a receive data FIFO reset condition
	SSIE0_SSIFCR_RFRST_0 = 0x0
	// Sets a receive data FIFO reset condition
	SSIE0_SSIFCR_RFRST_1 = 0x1
	// Position of TFRST field.
	SSIE0_SSIFCR_TFRST_Pos = 0x1
	// Bit mask of TFRST field.
	SSIE0_SSIFCR_TFRST_Msk = 0x2
	// Bit TFRST.
	SSIE0_SSIFCR_TFRST = 0x2
	// Clears a transmit data FIFO reset condition
	SSIE0_SSIFCR_TFRST_0 = 0x0
	// Sets a transmit data FIFO reset condition
	SSIE0_SSIFCR_TFRST_1 = 0x1
	// Position of RIE field.
	SSIE0_SSIFCR_RIE_Pos = 0x2
	// Bit mask of RIE field.
	SSIE0_SSIFCR_RIE_Msk = 0x4
	// Bit RIE.
	SSIE0_SSIFCR_RIE = 0x4
	// Disables receive data full interrupts
	SSIE0_SSIFCR_RIE_0 = 0x0
	// Enables receive data full interrupts
	SSIE0_SSIFCR_RIE_1 = 0x1
	// Position of TIE field.
	SSIE0_SSIFCR_TIE_Pos = 0x3
	// Bit mask of TIE field.
	SSIE0_SSIFCR_TIE_Msk = 0x8
	// Bit TIE.
	SSIE0_SSIFCR_TIE = 0x8
	// Disables transmit data empty interrupts
	SSIE0_SSIFCR_TIE_0 = 0x0
	// Enables transmit data empty interrupts
	SSIE0_SSIFCR_TIE_1 = 0x1
	// Position of BSW field.
	SSIE0_SSIFCR_BSW_Pos = 0xb
	// Bit mask of BSW field.
	SSIE0_SSIFCR_BSW_Msk = 0x800
	// Bit BSW.
	SSIE0_SSIFCR_BSW = 0x800
	// Disables byte swap
	SSIE0_SSIFCR_BSW_0 = 0x0
	// Enables byte swap
	SSIE0_SSIFCR_BSW_1 = 0x1
	// Position of SSIRST field.
	SSIE0_SSIFCR_SSIRST_Pos = 0x10
	// Bit mask of SSIRST field.
	SSIE0_SSIFCR_SSIRST_Msk = 0x10000
	// Bit SSIRST.
	SSIE0_SSIFCR_SSIRST = 0x10000
	// Clears a software reset condition
	SSIE0_SSIFCR_SSIRST_0 = 0x0
	// Sets a software reset condition
	SSIE0_SSIFCR_SSIRST_1 = 0x1
	// Position of AUCKE field.
	SSIE0_SSIFCR_AUCKE_Pos = 0x1f
	// Bit mask of AUCKE field.
	SSIE0_SSIFCR_AUCKE_Msk = 0x80000000
	// Bit AUCKE.
	SSIE0_SSIFCR_AUCKE = 0x80000000
	// Disables supply of AUDIO_MCK
	SSIE0_SSIFCR_AUCKE_0 = 0x0
	// Enables supply of AUDIO_MCK
	SSIE0_SSIFCR_AUCKE_1 = 0x1

	// SSIFSR: FIFO Status Register
	// Position of RDF field.
	SSIE0_SSIFSR_RDF_Pos = 0x0
	// Bit mask of RDF field.
	SSIE0_SSIFSR_RDF_Msk = 0x1
	// Bit RDF.
	SSIE0_SSIFSR_RDF = 0x1
	// The size of received data in SSIFRDR is not more than the value of SSISCR.RDFS.
	SSIE0_SSIFSR_RDF_0 = 0x0
	// The size of received data in SSIFRDR is not less than the value of SSISCR.RDFS plus one.
	SSIE0_SSIFSR_RDF_1 = 0x1
	// Position of RDC field.
	SSIE0_SSIFSR_RDC_Pos = 0x8
	// Bit mask of RDC field.
	SSIE0_SSIFSR_RDC_Msk = 0x3f00
	// Position of TDE field.
	SSIE0_SSIFSR_TDE_Pos = 0x10
	// Bit mask of TDE field.
	SSIE0_SSIFSR_TDE_Msk = 0x10000
	// Bit TDE.
	SSIE0_SSIFSR_TDE = 0x10000
	// The free space of SSIFTDR is not more than the value of SSISCR.TDES.
	SSIE0_SSIFSR_TDE_0 = 0x0
	// The free space of SSIFTDR is not less than the value of SSISCR.TDES plus one.
	SSIE0_SSIFSR_TDE_1 = 0x1
	// Position of TDC field.
	SSIE0_SSIFSR_TDC_Pos = 0x18
	// Bit mask of TDC field.
	SSIE0_SSIFSR_TDC_Msk = 0x3f000000

	// SSIFTDR: Transmit FIFO Data Register
	// Position of SSIFTDR field.
	SSIE0_SSIFTDR_SSIFTDR_Pos = 0x0
	// Bit mask of SSIFTDR field.
	SSIE0_SSIFTDR_SSIFTDR_Msk = 0xffffffff

	// SSIFRDR: Receive FIFO Data Register
	// Position of SSIFRDR field.
	SSIE0_SSIFRDR_SSIFRDR_Pos = 0x0
	// Bit mask of SSIFRDR field.
	SSIE0_SSIFRDR_SSIFRDR_Msk = 0xffffffff

	// SSIOFR: Audio Format Register
	// Position of OMOD field.
	SSIE0_SSIOFR_OMOD_Pos = 0x0
	// Bit mask of OMOD field.
	SSIE0_SSIOFR_OMOD_Msk = 0x3
	// I2S format
	SSIE0_SSIOFR_OMOD_00 = 0x0
	// TDM format
	SSIE0_SSIOFR_OMOD_01 = 0x1
	// Monaural format
	SSIE0_SSIOFR_OMOD_10 = 0x2
	// Setting prohibited
	SSIE0_SSIOFR_OMOD_11 = 0x3
	// Position of LRCONT field.
	SSIE0_SSIOFR_LRCONT_Pos = 0x8
	// Bit mask of LRCONT field.
	SSIE0_SSIOFR_LRCONT_Msk = 0x100
	// Bit LRCONT.
	SSIE0_SSIOFR_LRCONT = 0x100
	// Disables LRCK/FS continuation
	SSIE0_SSIOFR_LRCONT_0 = 0x0
	// Enables LRCK/FS continuation
	SSIE0_SSIOFR_LRCONT_1 = 0x1
	// Position of BCKASTP field.
	SSIE0_SSIOFR_BCKASTP_Pos = 0x9
	// Bit mask of BCKASTP field.
	SSIE0_SSIOFR_BCKASTP_Msk = 0x200
	// Bit BCKASTP.
	SSIE0_SSIOFR_BCKASTP = 0x200
	// Always outputs BCK to the SSIBCK pin
	SSIE0_SSIOFR_BCKASTP_0 = 0x0
	// Automatically controls output of BCK to the SSIBCK pin
	SSIE0_SSIOFR_BCKASTP_1 = 0x1

	// SSISCR: Status Control Register
	// Position of RDFS field.
	SSIE0_SSISCR_RDFS_Pos = 0x0
	// Bit mask of RDFS field.
	SSIE0_SSISCR_RDFS_Msk = 0x1f
	// Position of TDES field.
	SSIE0_SSISCR_TDES_Pos = 0x8
	// Bit mask of TDES field.
	SSIE0_SSISCR_TDES_Msk = 0x1f00
)

// Constants for IIC0: Inter-Integrated Circuit 0
const (
	// ICCR1: I2C Bus Control Register 1
	// Position of SDAI field.
	IIC0_ICCR1_SDAI_Pos = 0x0
	// Bit mask of SDAI field.
	IIC0_ICCR1_SDAI_Msk = 0x1
	// Bit SDAI.
	IIC0_ICCR1_SDAI = 0x1
	// SDAn line is low
	IIC0_ICCR1_SDAI_0 = 0x0
	// SDAn line is high
	IIC0_ICCR1_SDAI_1 = 0x1
	// Position of SCLI field.
	IIC0_ICCR1_SCLI_Pos = 0x1
	// Bit mask of SCLI field.
	IIC0_ICCR1_SCLI_Msk = 0x2
	// Bit SCLI.
	IIC0_ICCR1_SCLI = 0x2
	// SCLn line is low
	IIC0_ICCR1_SCLI_0 = 0x0
	// SCLn line is high
	IIC0_ICCR1_SCLI_1 = 0x1
	// Position of SDAO field.
	IIC0_ICCR1_SDAO_Pos = 0x2
	// Bit mask of SDAO field.
	IIC0_ICCR1_SDAO_Msk = 0x4
	// Bit SDAO.
	IIC0_ICCR1_SDAO = 0x4
	// Read: IIC drives SDAn pin low Write: IIC drives SDAn pin low
	IIC0_ICCR1_SDAO_0 = 0x0
	// Read: IIC releases SDAn pin Write: IIC releases SDAn pin
	IIC0_ICCR1_SDAO_1 = 0x1
	// Position of SCLO field.
	IIC0_ICCR1_SCLO_Pos = 0x3
	// Bit mask of SCLO field.
	IIC0_ICCR1_SCLO_Msk = 0x8
	// Bit SCLO.
	IIC0_ICCR1_SCLO = 0x8
	// Read: IIC drives SCLn pin low Write: IIC drives SCLn pin low
	IIC0_ICCR1_SCLO_0 = 0x0
	// Read: IIC releases SCLn pin Write: IIC releases SCLn pin
	IIC0_ICCR1_SCLO_1 = 0x1
	// Position of SOWP field.
	IIC0_ICCR1_SOWP_Pos = 0x4
	// Bit mask of SOWP field.
	IIC0_ICCR1_SOWP_Msk = 0x10
	// Bit SOWP.
	IIC0_ICCR1_SOWP = 0x10
	// Write enable SCLO and SDAO bits
	IIC0_ICCR1_SOWP_0 = 0x0
	// Write protect SCLO and SDAO bits
	IIC0_ICCR1_SOWP_1 = 0x1
	// Position of CLO field.
	IIC0_ICCR1_CLO_Pos = 0x5
	// Bit mask of CLO field.
	IIC0_ICCR1_CLO_Msk = 0x20
	// Bit CLO.
	IIC0_ICCR1_CLO = 0x20
	// Do not output extra SCL clock cycle (default)
	IIC0_ICCR1_CLO_0 = 0x0
	// Output extra SCL clock cycle
	IIC0_ICCR1_CLO_1 = 0x1
	// Position of IICRST field.
	IIC0_ICCR1_IICRST_Pos = 0x6
	// Bit mask of IICRST field.
	IIC0_ICCR1_IICRST_Msk = 0x40
	// Bit IICRST.
	IIC0_ICCR1_IICRST = 0x40
	// Release IIC reset or internal reset
	IIC0_ICCR1_IICRST_0 = 0x0
	// Initiate IIC reset or internal reset
	IIC0_ICCR1_IICRST_1 = 0x1
	// Position of ICE field.
	IIC0_ICCR1_ICE_Pos = 0x7
	// Bit mask of ICE field.
	IIC0_ICCR1_ICE_Msk = 0x80
	// Bit ICE.
	IIC0_ICCR1_ICE = 0x80
	// Disable (SCLn and SDAn pins in inactive state)
	IIC0_ICCR1_ICE_0 = 0x0
	// Enable (SCLn and SDAn pins in active state)
	IIC0_ICCR1_ICE_1 = 0x1

	// ICCR2: I2C Bus Control Register 2
	// Position of ST field.
	IIC0_ICCR2_ST_Pos = 0x1
	// Bit mask of ST field.
	IIC0_ICCR2_ST_Msk = 0x2
	// Bit ST.
	IIC0_ICCR2_ST = 0x2
	// Do not issue a start condition request
	IIC0_ICCR2_ST_0 = 0x0
	// Issue a start condition request
	IIC0_ICCR2_ST_1 = 0x1
	// Position of RS field.
	IIC0_ICCR2_RS_Pos = 0x2
	// Bit mask of RS field.
	IIC0_ICCR2_RS_Msk = 0x4
	// Bit RS.
	IIC0_ICCR2_RS = 0x4
	// Do not issue a restart condition request
	IIC0_ICCR2_RS_0 = 0x0
	// Issue a restart condition request
	IIC0_ICCR2_RS_1 = 0x1
	// Position of SP field.
	IIC0_ICCR2_SP_Pos = 0x3
	// Bit mask of SP field.
	IIC0_ICCR2_SP_Msk = 0x8
	// Bit SP.
	IIC0_ICCR2_SP = 0x8
	// Do not issue a stop condition request
	IIC0_ICCR2_SP_0 = 0x0
	// Issue a stop condition request
	IIC0_ICCR2_SP_1 = 0x1
	// Position of TRS field.
	IIC0_ICCR2_TRS_Pos = 0x5
	// Bit mask of TRS field.
	IIC0_ICCR2_TRS_Msk = 0x20
	// Bit TRS.
	IIC0_ICCR2_TRS = 0x20
	// Receive mode
	IIC0_ICCR2_TRS_0 = 0x0
	// Transmit mode
	IIC0_ICCR2_TRS_1 = 0x1
	// Position of MST field.
	IIC0_ICCR2_MST_Pos = 0x6
	// Bit mask of MST field.
	IIC0_ICCR2_MST_Msk = 0x40
	// Bit MST.
	IIC0_ICCR2_MST = 0x40
	// Slave mode
	IIC0_ICCR2_MST_0 = 0x0
	// Master mode
	IIC0_ICCR2_MST_1 = 0x1
	// Position of BBSY field.
	IIC0_ICCR2_BBSY_Pos = 0x7
	// Bit mask of BBSY field.
	IIC0_ICCR2_BBSY_Msk = 0x80
	// Bit BBSY.
	IIC0_ICCR2_BBSY = 0x80
	// I2C bus released (bus free state)
	IIC0_ICCR2_BBSY_0 = 0x0
	// I2C bus occupied (bus busy state)
	IIC0_ICCR2_BBSY_1 = 0x1

	// ICMR1: I2C Bus Mode Register 1
	// Position of BC field.
	IIC0_ICMR1_BC_Pos = 0x0
	// Bit mask of BC field.
	IIC0_ICMR1_BC_Msk = 0x7
	// 9 bits
	IIC0_ICMR1_BC_000 = 0x0
	// 2 bits
	IIC0_ICMR1_BC_001 = 0x1
	// 3 bits
	IIC0_ICMR1_BC_010 = 0x2
	// 4 bits
	IIC0_ICMR1_BC_011 = 0x3
	// 5 bits
	IIC0_ICMR1_BC_100 = 0x4
	// 6 bits
	IIC0_ICMR1_BC_101 = 0x5
	// 7 bits
	IIC0_ICMR1_BC_110 = 0x6
	// 8 bits
	IIC0_ICMR1_BC_111 = 0x7
	// Position of BCWP field.
	IIC0_ICMR1_BCWP_Pos = 0x3
	// Bit mask of BCWP field.
	IIC0_ICMR1_BCWP_Msk = 0x8
	// Bit BCWP.
	IIC0_ICMR1_BCWP = 0x8
	// Write enable BC[2:0] bits
	IIC0_ICMR1_BCWP_0 = 0x0
	// Write protect BC[2:0] bits
	IIC0_ICMR1_BCWP_1 = 0x1
	// Position of CKS field.
	IIC0_ICMR1_CKS_Pos = 0x4
	// Bit mask of CKS field.
	IIC0_ICMR1_CKS_Msk = 0x70
	// Position of MTWP field.
	IIC0_ICMR1_MTWP_Pos = 0x7
	// Bit mask of MTWP field.
	IIC0_ICMR1_MTWP_Msk = 0x80
	// Bit MTWP.
	IIC0_ICMR1_MTWP = 0x80
	// Write protect MST and TRS bits in ICCR2
	IIC0_ICMR1_MTWP_0 = 0x0
	// Write enable MST and TRS bits in ICCR2
	IIC0_ICMR1_MTWP_1 = 0x1

	// ICMR2: I2C Bus Mode Register 2
	// Position of TMOS field.
	IIC0_ICMR2_TMOS_Pos = 0x0
	// Bit mask of TMOS field.
	IIC0_ICMR2_TMOS_Msk = 0x1
	// Bit TMOS.
	IIC0_ICMR2_TMOS = 0x1
	// Select long mode
	IIC0_ICMR2_TMOS_0 = 0x0
	// Select short mode
	IIC0_ICMR2_TMOS_1 = 0x1
	// Position of TMOL field.
	IIC0_ICMR2_TMOL_Pos = 0x1
	// Bit mask of TMOL field.
	IIC0_ICMR2_TMOL_Msk = 0x2
	// Bit TMOL.
	IIC0_ICMR2_TMOL = 0x2
	// Disable count while SCLn line is low
	IIC0_ICMR2_TMOL_0 = 0x0
	// Enable count while SCLn line is low
	IIC0_ICMR2_TMOL_1 = 0x1
	// Position of TMOH field.
	IIC0_ICMR2_TMOH_Pos = 0x2
	// Bit mask of TMOH field.
	IIC0_ICMR2_TMOH_Msk = 0x4
	// Bit TMOH.
	IIC0_ICMR2_TMOH = 0x4
	// Disable count while SCLn line is high
	IIC0_ICMR2_TMOH_0 = 0x0
	// Enable count while SCLn line is high
	IIC0_ICMR2_TMOH_1 = 0x1
	// Position of SDDL field.
	IIC0_ICMR2_SDDL_Pos = 0x4
	// Bit mask of SDDL field.
	IIC0_ICMR2_SDDL_Msk = 0x70
	// No output delay
	IIC0_ICMR2_SDDL_000 = 0x0
	// 1 IIC-phi cycle (When ICMR2.DLCS = 0 (IIC-phi)) 1 or 2 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_001 = 0x1
	// 2 IIC-phi cycles (When ICMR2.DLCS = 0 (IIC-phi)) 3 or 4 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_010 = 0x2
	// 3 IIC-phi cycles (When ICMR2.DLCS = 0 (IIC-phi)) 5 or 6 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_011 = 0x3
	// 4 IIC-phi cycles (When ICMR2.DLCS = 0 (IIC-phi)) 7 or 8 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_100 = 0x4
	// 5 IIC-phi cycles (When ICMR2.DLCS = 0 (IIC-phi)) 9 or 10 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_101 = 0x5
	// 6 IIC-phi cycles (When ICMR2.DLCS = 0 (IIC-phi)) 11 or 12 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_110 = 0x6
	// 7 IIC-phi cycles (When ICMR2.DLCS = 0 (IIC-phi)) 13 or 14 IIC-phi cycles (When ICMR2.DLCS = 1 (IIC-phi/2))
	IIC0_ICMR2_SDDL_111 = 0x7
	// Position of DLCS field.
	IIC0_ICMR2_DLCS_Pos = 0x7
	// Bit mask of DLCS field.
	IIC0_ICMR2_DLCS_Msk = 0x80
	// Bit DLCS.
	IIC0_ICMR2_DLCS = 0x80
	// Select internal reference clock (IIC-phi) as the clock source for SDA output delay counter
	IIC0_ICMR2_DLCS_0 = 0x0
	// Select internal reference clock divided by 2 (IIC-phi/2) as the clock source for SDA output delay counter
	IIC0_ICMR2_DLCS_1 = 0x1

	// ICMR3: I2C Bus Mode Register 3
	// Position of NF field.
	IIC0_ICMR3_NF_Pos = 0x0
	// Bit mask of NF field.
	IIC0_ICMR3_NF_Msk = 0x3
	// Filter out noise of up to 1 IIC-phi cycle (single-stage filter)
	IIC0_ICMR3_NF_00 = 0x0
	// Filter out noise of up to 2 IIC-phi cycles (2-stage filter)
	IIC0_ICMR3_NF_01 = 0x1
	// Filter out noise of up to 3 IIC-phi cycles (3-stage filter)
	IIC0_ICMR3_NF_10 = 0x2
	// Filter out noise of up to 4 IIC-phi cycles (4-stage filter)
	IIC0_ICMR3_NF_11 = 0x3
	// Position of ACKBR field.
	IIC0_ICMR3_ACKBR_Pos = 0x2
	// Bit mask of ACKBR field.
	IIC0_ICMR3_ACKBR_Msk = 0x4
	// Bit ACKBR.
	IIC0_ICMR3_ACKBR = 0x4
	// 0 received as the acknowledge bit (ACK reception)
	IIC0_ICMR3_ACKBR_0 = 0x0
	// 1 received as the acknowledge bit (NACK reception)
	IIC0_ICMR3_ACKBR_1 = 0x1
	// Position of ACKBT field.
	IIC0_ICMR3_ACKBT_Pos = 0x3
	// Bit mask of ACKBT field.
	IIC0_ICMR3_ACKBT_Msk = 0x8
	// Bit ACKBT.
	IIC0_ICMR3_ACKBT = 0x8
	// Send 0 as the acknowledge bit (ACK transmission)
	IIC0_ICMR3_ACKBT_0 = 0x0
	// Send 1 as the acknowledge bit (NACK transmission)
	IIC0_ICMR3_ACKBT_1 = 0x1
	// Position of ACKWP field.
	IIC0_ICMR3_ACKWP_Pos = 0x4
	// Bit mask of ACKWP field.
	IIC0_ICMR3_ACKWP_Msk = 0x10
	// Bit ACKWP.
	IIC0_ICMR3_ACKWP = 0x10
	// Write protect ACKBT bit
	IIC0_ICMR3_ACKWP_0 = 0x0
	// Write enable ACKBT bit
	IIC0_ICMR3_ACKWP_1 = 0x1
	// Position of RDRFS field.
	IIC0_ICMR3_RDRFS_Pos = 0x5
	// Bit mask of RDRFS field.
	IIC0_ICMR3_RDRFS_Msk = 0x20
	// Bit RDRFS.
	IIC0_ICMR3_RDRFS = 0x20
	// Set the RDRF flag on the rising edge of the 9th SCL clock cycle. The SCLn line is not held low on the falling edge of the 8th clock cycle.
	IIC0_ICMR3_RDRFS_0 = 0x0
	// Set the RDRF flag on the rising edge of the 8th SCL clock cycle. The SCLn line is held low on the falling edge of the 8th clock cycle.
	IIC0_ICMR3_RDRFS_1 = 0x1
	// Position of WAIT field.
	IIC0_ICMR3_WAIT_Pos = 0x6
	// Bit mask of WAIT field.
	IIC0_ICMR3_WAIT_Msk = 0x40
	// Bit WAIT.
	IIC0_ICMR3_WAIT = 0x40
	// No wait (The SCLn line is not held low during the period between the 9th clock cycle and the 1st clock cycle.)
	IIC0_ICMR3_WAIT_0 = 0x0
	// Wait (The SCLn line is held low during the period between the 9th clock cycle and the 1st clock cycle.)
	IIC0_ICMR3_WAIT_1 = 0x1
	// Position of SMBS field.
	IIC0_ICMR3_SMBS_Pos = 0x7
	// Bit mask of SMBS field.
	IIC0_ICMR3_SMBS_Msk = 0x80
	// Bit SMBS.
	IIC0_ICMR3_SMBS = 0x80
	// Select I2C Bus
	IIC0_ICMR3_SMBS_0 = 0x0
	// Select SMBus
	IIC0_ICMR3_SMBS_1 = 0x1

	// ICFER: I2C Bus Function Enable Register
	// Position of TMOE field.
	IIC0_ICFER_TMOE_Pos = 0x0
	// Bit mask of TMOE field.
	IIC0_ICFER_TMOE_Msk = 0x1
	// Bit TMOE.
	IIC0_ICFER_TMOE = 0x1
	// Disable
	IIC0_ICFER_TMOE_0 = 0x0
	// Enable
	IIC0_ICFER_TMOE_1 = 0x1
	// Position of MALE field.
	IIC0_ICFER_MALE_Pos = 0x1
	// Bit mask of MALE field.
	IIC0_ICFER_MALE_Msk = 0x2
	// Bit MALE.
	IIC0_ICFER_MALE = 0x2
	// Disable the arbitration-lost detection function and disable automatic clearing of the MST and TRS bits in ICCR2 when arbitration is lost
	IIC0_ICFER_MALE_0 = 0x0
	// Enable the arbitration-lost detection function and enable automatic clearing of the MST and TRS bits in ICCR2 when arbitration is lost
	IIC0_ICFER_MALE_1 = 0x1
	// Position of NALE field.
	IIC0_ICFER_NALE_Pos = 0x2
	// Bit mask of NALE field.
	IIC0_ICFER_NALE_Msk = 0x4
	// Bit NALE.
	IIC0_ICFER_NALE = 0x4
	// Disable
	IIC0_ICFER_NALE_0 = 0x0
	// Enable
	IIC0_ICFER_NALE_1 = 0x1
	// Position of SALE field.
	IIC0_ICFER_SALE_Pos = 0x3
	// Bit mask of SALE field.
	IIC0_ICFER_SALE_Msk = 0x8
	// Bit SALE.
	IIC0_ICFER_SALE = 0x8
	// Disable
	IIC0_ICFER_SALE_0 = 0x0
	// Enable
	IIC0_ICFER_SALE_1 = 0x1
	// Position of NACKE field.
	IIC0_ICFER_NACKE_Pos = 0x4
	// Bit mask of NACKE field.
	IIC0_ICFER_NACKE_Msk = 0x10
	// Bit NACKE.
	IIC0_ICFER_NACKE = 0x10
	// Do not suspend transfer operation during NACK reception (disable transfer suspension)
	IIC0_ICFER_NACKE_0 = 0x0
	// Suspend transfer operation during NACK reception (enable transfer suspension)
	IIC0_ICFER_NACKE_1 = 0x1
	// Position of NFE field.
	IIC0_ICFER_NFE_Pos = 0x5
	// Bit mask of NFE field.
	IIC0_ICFER_NFE_Msk = 0x20
	// Bit NFE.
	IIC0_ICFER_NFE = 0x20
	// Do not use the digital noise filter circuit
	IIC0_ICFER_NFE_0 = 0x0
	// Use the digital noise filter circuit
	IIC0_ICFER_NFE_1 = 0x1
	// Position of SCLE field.
	IIC0_ICFER_SCLE_Pos = 0x6
	// Bit mask of SCLE field.
	IIC0_ICFER_SCLE_Msk = 0x40
	// Bit SCLE.
	IIC0_ICFER_SCLE = 0x40
	// Do not use the SCL synchronous circuit
	IIC0_ICFER_SCLE_0 = 0x0
	// Use the SCL synchronous circuit
	IIC0_ICFER_SCLE_1 = 0x1
	// Position of FMPE field.
	IIC0_ICFER_FMPE_Pos = 0x7
	// Bit mask of FMPE field.
	IIC0_ICFER_FMPE_Msk = 0x80
	// Bit FMPE.
	IIC0_ICFER_FMPE = 0x80
	// Do not use the Fm+ slope control circuit for the SCLn and SDAn pins
	IIC0_ICFER_FMPE_0 = 0x0
	// Use the Fm+ slope control circuit for the SCLn and SDAn pins.
	IIC0_ICFER_FMPE_1 = 0x1

	// ICSER: I2C Bus Status Enable Register
	// Position of SAR0E field.
	IIC0_ICSER_SAR0E_Pos = 0x0
	// Bit mask of SAR0E field.
	IIC0_ICSER_SAR0E_Msk = 0x1
	// Bit SAR0E.
	IIC0_ICSER_SAR0E = 0x1
	// Disable slave address in SARL0 and SARU0
	IIC0_ICSER_SAR0E_0 = 0x0
	// Enable slave address in SARL0 and SARU0
	IIC0_ICSER_SAR0E_1 = 0x1
	// Position of SAR1E field.
	IIC0_ICSER_SAR1E_Pos = 0x1
	// Bit mask of SAR1E field.
	IIC0_ICSER_SAR1E_Msk = 0x2
	// Bit SAR1E.
	IIC0_ICSER_SAR1E = 0x2
	// Disable slave address in SARL1 and SARU1
	IIC0_ICSER_SAR1E_0 = 0x0
	// Enable slave address in SARL1 and SARU1
	IIC0_ICSER_SAR1E_1 = 0x1
	// Position of SAR2E field.
	IIC0_ICSER_SAR2E_Pos = 0x2
	// Bit mask of SAR2E field.
	IIC0_ICSER_SAR2E_Msk = 0x4
	// Bit SAR2E.
	IIC0_ICSER_SAR2E = 0x4
	// Disable slave address in SARL2 and SARU2
	IIC0_ICSER_SAR2E_0 = 0x0
	// Enable slave address in SARL2 and SARU2
	IIC0_ICSER_SAR2E_1 = 0x1
	// Position of GCAE field.
	IIC0_ICSER_GCAE_Pos = 0x3
	// Bit mask of GCAE field.
	IIC0_ICSER_GCAE_Msk = 0x8
	// Bit GCAE.
	IIC0_ICSER_GCAE = 0x8
	// Disable general call address detection
	IIC0_ICSER_GCAE_0 = 0x0
	// Enable general call address detection
	IIC0_ICSER_GCAE_1 = 0x1
	// Position of DIDE field.
	IIC0_ICSER_DIDE_Pos = 0x5
	// Bit mask of DIDE field.
	IIC0_ICSER_DIDE_Msk = 0x20
	// Bit DIDE.
	IIC0_ICSER_DIDE = 0x20
	// Disable device-ID address detection
	IIC0_ICSER_DIDE_0 = 0x0
	// Enable device-ID address detection
	IIC0_ICSER_DIDE_1 = 0x1
	// Position of HOAE field.
	IIC0_ICSER_HOAE_Pos = 0x7
	// Bit mask of HOAE field.
	IIC0_ICSER_HOAE_Msk = 0x80
	// Bit HOAE.
	IIC0_ICSER_HOAE = 0x80
	// Disable host address detection
	IIC0_ICSER_HOAE_0 = 0x0
	// Enable host address detection
	IIC0_ICSER_HOAE_1 = 0x1

	// ICIER: I2C Bus Interrupt Enable Register
	// Position of TMOIE field.
	IIC0_ICIER_TMOIE_Pos = 0x0
	// Bit mask of TMOIE field.
	IIC0_ICIER_TMOIE_Msk = 0x1
	// Bit TMOIE.
	IIC0_ICIER_TMOIE = 0x1
	// Disable timeout interrupt (TMOI) request
	IIC0_ICIER_TMOIE_0 = 0x0
	// Enable timeout interrupt (TMOI) request
	IIC0_ICIER_TMOIE_1 = 0x1
	// Position of ALIE field.
	IIC0_ICIER_ALIE_Pos = 0x1
	// Bit mask of ALIE field.
	IIC0_ICIER_ALIE_Msk = 0x2
	// Bit ALIE.
	IIC0_ICIER_ALIE = 0x2
	// Disable arbitration-lost interrupt (ALI) request
	IIC0_ICIER_ALIE_0 = 0x0
	// Enable arbitration-lost interrupt (ALI) request
	IIC0_ICIER_ALIE_1 = 0x1
	// Position of STIE field.
	IIC0_ICIER_STIE_Pos = 0x2
	// Bit mask of STIE field.
	IIC0_ICIER_STIE_Msk = 0x4
	// Bit STIE.
	IIC0_ICIER_STIE = 0x4
	// Disable start condition detection interrupt (STI) request
	IIC0_ICIER_STIE_0 = 0x0
	// Enable start condition detection interrupt (STI) request
	IIC0_ICIER_STIE_1 = 0x1
	// Position of SPIE field.
	IIC0_ICIER_SPIE_Pos = 0x3
	// Bit mask of SPIE field.
	IIC0_ICIER_SPIE_Msk = 0x8
	// Bit SPIE.
	IIC0_ICIER_SPIE = 0x8
	// Disable stop condition detection interrupt (SPI) request
	IIC0_ICIER_SPIE_0 = 0x0
	// Enable stop condition detection interrupt (SPI) request
	IIC0_ICIER_SPIE_1 = 0x1
	// Position of NAKIE field.
	IIC0_ICIER_NAKIE_Pos = 0x4
	// Bit mask of NAKIE field.
	IIC0_ICIER_NAKIE_Msk = 0x10
	// Bit NAKIE.
	IIC0_ICIER_NAKIE = 0x10
	// Disable NACK reception interrupt (NAKI) request
	IIC0_ICIER_NAKIE_0 = 0x0
	// Enable NACK reception interrupt (NAKI) request
	IIC0_ICIER_NAKIE_1 = 0x1
	// Position of RIE field.
	IIC0_ICIER_RIE_Pos = 0x5
	// Bit mask of RIE field.
	IIC0_ICIER_RIE_Msk = 0x20
	// Bit RIE.
	IIC0_ICIER_RIE = 0x20
	// Disable receive data full interrupt (IICn_RXI) request
	IIC0_ICIER_RIE_0 = 0x0
	// Enable receive data full interrupt (IICn_RXI) request
	IIC0_ICIER_RIE_1 = 0x1
	// Position of TEIE field.
	IIC0_ICIER_TEIE_Pos = 0x6
	// Bit mask of TEIE field.
	IIC0_ICIER_TEIE_Msk = 0x40
	// Bit TEIE.
	IIC0_ICIER_TEIE = 0x40
	// Disable transmit end interrupt (IICn_TEI) request
	IIC0_ICIER_TEIE_0 = 0x0
	// Enable transmit end interrupt (IICn_TEI) request
	IIC0_ICIER_TEIE_1 = 0x1
	// Position of TIE field.
	IIC0_ICIER_TIE_Pos = 0x7
	// Bit mask of TIE field.
	IIC0_ICIER_TIE_Msk = 0x80
	// Bit TIE.
	IIC0_ICIER_TIE = 0x80
	// Disable transmit data empty interrupt (IICn_TXI) request
	IIC0_ICIER_TIE_0 = 0x0
	// Enable transmit data empty interrupt (IICn_TXI) request
	IIC0_ICIER_TIE_1 = 0x1

	// ICSR1: I2C Bus Status Register 1
	// Position of AAS0 field.
	IIC0_ICSR1_AAS0_Pos = 0x0
	// Bit mask of AAS0 field.
	IIC0_ICSR1_AAS0_Msk = 0x1
	// Bit AAS0.
	IIC0_ICSR1_AAS0 = 0x1
	// Slave address 0 not detected
	IIC0_ICSR1_AAS0_0 = 0x0
	// Slave address 0 detected
	IIC0_ICSR1_AAS0_1 = 0x1
	// Position of AAS1 field.
	IIC0_ICSR1_AAS1_Pos = 0x1
	// Bit mask of AAS1 field.
	IIC0_ICSR1_AAS1_Msk = 0x2
	// Bit AAS1.
	IIC0_ICSR1_AAS1 = 0x2
	// Slave address 1 not detected
	IIC0_ICSR1_AAS1_0 = 0x0
	// Slave address 1 detected
	IIC0_ICSR1_AAS1_1 = 0x1
	// Position of AAS2 field.
	IIC0_ICSR1_AAS2_Pos = 0x2
	// Bit mask of AAS2 field.
	IIC0_ICSR1_AAS2_Msk = 0x4
	// Bit AAS2.
	IIC0_ICSR1_AAS2 = 0x4
	// Slave address 2 not detected
	IIC0_ICSR1_AAS2_0 = 0x0
	// Slave address 2 detected
	IIC0_ICSR1_AAS2_1 = 0x1
	// Position of GCA field.
	IIC0_ICSR1_GCA_Pos = 0x3
	// Bit mask of GCA field.
	IIC0_ICSR1_GCA_Msk = 0x8
	// Bit GCA.
	IIC0_ICSR1_GCA = 0x8
	// General call address not detected
	IIC0_ICSR1_GCA_0 = 0x0
	// General call address detected
	IIC0_ICSR1_GCA_1 = 0x1
	// Position of DID field.
	IIC0_ICSR1_DID_Pos = 0x5
	// Bit mask of DID field.
	IIC0_ICSR1_DID_Msk = 0x20
	// Bit DID.
	IIC0_ICSR1_DID = 0x20
	// Device-ID command not detected
	IIC0_ICSR1_DID_0 = 0x0
	// Device-ID command detected
	IIC0_ICSR1_DID_1 = 0x1
	// Position of HOA field.
	IIC0_ICSR1_HOA_Pos = 0x7
	// Bit mask of HOA field.
	IIC0_ICSR1_HOA_Msk = 0x80
	// Bit HOA.
	IIC0_ICSR1_HOA = 0x80
	// Host address not detected
	IIC0_ICSR1_HOA_0 = 0x0
	// Host address detected
	IIC0_ICSR1_HOA_1 = 0x1

	// ICSR2: I2C Bus Status Register 2
	// Position of TMOF field.
	IIC0_ICSR2_TMOF_Pos = 0x0
	// Bit mask of TMOF field.
	IIC0_ICSR2_TMOF_Msk = 0x1
	// Bit TMOF.
	IIC0_ICSR2_TMOF = 0x1
	// Timeout not detected
	IIC0_ICSR2_TMOF_0 = 0x0
	// Timeout detected
	IIC0_ICSR2_TMOF_1 = 0x1
	// Position of AL field.
	IIC0_ICSR2_AL_Pos = 0x1
	// Bit mask of AL field.
	IIC0_ICSR2_AL_Msk = 0x2
	// Bit AL.
	IIC0_ICSR2_AL = 0x2
	// Arbitration not lost
	IIC0_ICSR2_AL_0 = 0x0
	// Arbitration lost
	IIC0_ICSR2_AL_1 = 0x1
	// Position of START field.
	IIC0_ICSR2_START_Pos = 0x2
	// Bit mask of START field.
	IIC0_ICSR2_START_Msk = 0x4
	// Bit START.
	IIC0_ICSR2_START = 0x4
	// Start condition not detected
	IIC0_ICSR2_START_0 = 0x0
	// Start condition detected
	IIC0_ICSR2_START_1 = 0x1
	// Position of STOP field.
	IIC0_ICSR2_STOP_Pos = 0x3
	// Bit mask of STOP field.
	IIC0_ICSR2_STOP_Msk = 0x8
	// Bit STOP.
	IIC0_ICSR2_STOP = 0x8
	// Stop condition not detected
	IIC0_ICSR2_STOP_0 = 0x0
	// Stop condition detected
	IIC0_ICSR2_STOP_1 = 0x1
	// Position of NACKF field.
	IIC0_ICSR2_NACKF_Pos = 0x4
	// Bit mask of NACKF field.
	IIC0_ICSR2_NACKF_Msk = 0x10
	// Bit NACKF.
	IIC0_ICSR2_NACKF = 0x10
	// NACK not detected
	IIC0_ICSR2_NACKF_0 = 0x0
	// NACK detected
	IIC0_ICSR2_NACKF_1 = 0x1
	// Position of RDRF field.
	IIC0_ICSR2_RDRF_Pos = 0x5
	// Bit mask of RDRF field.
	IIC0_ICSR2_RDRF_Msk = 0x20
	// Bit RDRF.
	IIC0_ICSR2_RDRF = 0x20
	// ICDRR contains no receive data
	IIC0_ICSR2_RDRF_0 = 0x0
	// ICDRR contains receive data
	IIC0_ICSR2_RDRF_1 = 0x1
	// Position of TEND field.
	IIC0_ICSR2_TEND_Pos = 0x6
	// Bit mask of TEND field.
	IIC0_ICSR2_TEND_Msk = 0x40
	// Bit TEND.
	IIC0_ICSR2_TEND = 0x40
	// Data being transmitted
	IIC0_ICSR2_TEND_0 = 0x0
	// Data transmit complete
	IIC0_ICSR2_TEND_1 = 0x1
	// Position of TDRE field.
	IIC0_ICSR2_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	IIC0_ICSR2_TDRE_Msk = 0x80
	// Bit TDRE.
	IIC0_ICSR2_TDRE = 0x80
	// ICDRT contains transmit data
	IIC0_ICSR2_TDRE_0 = 0x0
	// ICDRT contains no transmit data
	IIC0_ICSR2_TDRE_1 = 0x1

	// SARL0: Slave Address Register Ly
	// Position of SVA0 field.
	IIC0_SARL_SVA0_Pos = 0x0
	// Bit mask of SVA0 field.
	IIC0_SARL_SVA0_Msk = 0x1
	// Bit SVA0.
	IIC0_SARL_SVA0 = 0x1
	// Position of SVA field.
	IIC0_SARL_SVA_Pos = 0x1
	// Bit mask of SVA field.
	IIC0_SARL_SVA_Msk = 0xfe

	// SARU0: Slave Address Register Uy
	// Position of FS field.
	IIC0_SARU_FS_Pos = 0x0
	// Bit mask of FS field.
	IIC0_SARU_FS_Msk = 0x1
	// Bit FS.
	IIC0_SARU_FS = 0x1
	// Select 7-bit address format
	IIC0_SARU_FS_0 = 0x0
	// Select 10-bit address format
	IIC0_SARU_FS_1 = 0x1
	// Position of SVA field.
	IIC0_SARU_SVA_Pos = 0x1
	// Bit mask of SVA field.
	IIC0_SARU_SVA_Msk = 0x6

	// ICBRL: I2C Bus Bit Rate Low-Level Register
	// Position of BRL field.
	IIC0_ICBRL_BRL_Pos = 0x0
	// Bit mask of BRL field.
	IIC0_ICBRL_BRL_Msk = 0x1f

	// ICBRH: I2C Bus Bit Rate High-Level Register
	// Position of BRH field.
	IIC0_ICBRH_BRH_Pos = 0x0
	// Bit mask of BRH field.
	IIC0_ICBRH_BRH_Msk = 0x1f
)

// Constants for IIC0WU: Inter-Integrated Circuit 0 Wake-up Unit
const (
	// ICWUR: I2C Bus Wakeup Unit Register
	// Position of WUAFA field.
	IIC0WU_ICWUR_WUAFA_Pos = 0x0
	// Bit mask of WUAFA field.
	IIC0WU_ICWUR_WUAFA_Msk = 0x1
	// Bit WUAFA.
	IIC0WU_ICWUR_WUAFA = 0x1
	// Do not add the wakeup analog filter
	IIC0WU_ICWUR_WUAFA_0 = 0x0
	// Add the wakeup analog filter
	IIC0WU_ICWUR_WUAFA_1 = 0x1
	// Position of WUACK field.
	IIC0WU_ICWUR_WUACK_Pos = 0x4
	// Bit mask of WUACK field.
	IIC0WU_ICWUR_WUACK_Msk = 0x10
	// Bit WUACK.
	IIC0WU_ICWUR_WUACK = 0x10
	// Position of WUF field.
	IIC0WU_ICWUR_WUF_Pos = 0x5
	// Bit mask of WUF field.
	IIC0WU_ICWUR_WUF_Msk = 0x20
	// Bit WUF.
	IIC0WU_ICWUR_WUF = 0x20
	// Slave address not matching during wakeup
	IIC0WU_ICWUR_WUF_0 = 0x0
	// Slave address matching during wakeup
	IIC0WU_ICWUR_WUF_1 = 0x1
	// Position of WUIE field.
	IIC0WU_ICWUR_WUIE_Pos = 0x6
	// Bit mask of WUIE field.
	IIC0WU_ICWUR_WUIE_Msk = 0x40
	// Bit WUIE.
	IIC0WU_ICWUR_WUIE = 0x40
	// Disable wakeup interrupt request (IIC0_WUI)
	IIC0WU_ICWUR_WUIE_0 = 0x0
	// Enable wakeup interrupt request (IIC0_WUI)
	IIC0WU_ICWUR_WUIE_1 = 0x1
	// Position of WUE field.
	IIC0WU_ICWUR_WUE_Pos = 0x7
	// Bit mask of WUE field.
	IIC0WU_ICWUR_WUE_Msk = 0x80
	// Bit WUE.
	IIC0WU_ICWUR_WUE = 0x80
	// Disable wakeup function
	IIC0WU_ICWUR_WUE_0 = 0x0
	// Enable wakeup function
	IIC0WU_ICWUR_WUE_1 = 0x1

	// ICWUR2: I2C Bus Wakeup Unit Register 2
	// Position of WUSEN field.
	IIC0WU_ICWUR2_WUSEN_Pos = 0x0
	// Bit mask of WUSEN field.
	IIC0WU_ICWUR2_WUSEN_Msk = 0x1
	// Bit WUSEN.
	IIC0WU_ICWUR2_WUSEN = 0x1
	// IIC asynchronous circuit enable
	IIC0WU_ICWUR2_WUSEN_0 = 0x0
	// IIC synchronous circuit enable
	IIC0WU_ICWUR2_WUSEN_1 = 0x1
	// Position of WUASYF field.
	IIC0WU_ICWUR2_WUASYF_Pos = 0x1
	// Bit mask of WUASYF field.
	IIC0WU_ICWUR2_WUASYF_Msk = 0x2
	// Bit WUASYF.
	IIC0WU_ICWUR2_WUASYF = 0x2
	// IIC synchronous circuit enable condition
	IIC0WU_ICWUR2_WUASYF_0 = 0x0
	// IIC asynchronous circuit enable condition
	IIC0WU_ICWUR2_WUASYF_1 = 0x1
	// Position of WUSYF field.
	IIC0WU_ICWUR2_WUSYF_Pos = 0x2
	// Bit mask of WUSYF field.
	IIC0WU_ICWUR2_WUSYF_Msk = 0x4
	// Bit WUSYF.
	IIC0WU_ICWUR2_WUSYF = 0x4
	// IIC asynchronous circuit enable condition
	IIC0WU_ICWUR2_WUSYF_0 = 0x0
	// IIC synchronous circuit enable condition
	IIC0WU_ICWUR2_WUSYF_1 = 0x1
)

// Constants for CAN0: Controller Area Network
const (
	// MB0_ID: Mailbox ID Register %s
	// Position of EID field.
	CAN0_MB_ID_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_MB_ID_EID_Msk = 0x3ffff
	// Position of SID field.
	CAN0_MB_ID_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_MB_ID_SID_Msk = 0x1ffc0000
	// Position of RTR field.
	CAN0_MB_ID_RTR_Pos = 0x1e
	// Bit mask of RTR field.
	CAN0_MB_ID_RTR_Msk = 0x40000000
	// Bit RTR.
	CAN0_MB_ID_RTR = 0x40000000
	// Data frame
	CAN0_MB_ID_RTR_0 = 0x0
	// Remote frame
	CAN0_MB_ID_RTR_1 = 0x1
	// Position of IDE field.
	CAN0_MB_ID_IDE_Pos = 0x1f
	// Bit mask of IDE field.
	CAN0_MB_ID_IDE_Msk = 0x80000000
	// Bit IDE.
	CAN0_MB_ID_IDE = 0x80000000
	// Standard ID
	CAN0_MB_ID_IDE_0 = 0x0
	// Extended ID
	CAN0_MB_ID_IDE_1 = 0x1

	// MB0_DL: Mailbox Data Length Register %s
	// Position of DLC field.
	CAN0_MB_DL_DLC_Pos = 0x0
	// Bit mask of DLC field.
	CAN0_MB_DL_DLC_Msk = 0xf
	// Data length = 0 byte
	CAN0_MB_DL_DLC_0x0 = 0x0
	// Data length = 1 byte
	CAN0_MB_DL_DLC_0x1 = 0x1
	// Data length = 2 bytes
	CAN0_MB_DL_DLC_0x2 = 0x2
	// Data length = 3 bytes
	CAN0_MB_DL_DLC_0x3 = 0x3
	// Data length = 4 bytes
	CAN0_MB_DL_DLC_0x4 = 0x4
	// Data length = 5 bytes
	CAN0_MB_DL_DLC_0x5 = 0x5
	// Data length = 6 bytes
	CAN0_MB_DL_DLC_0x6 = 0x6
	// Data length = 7 bytes
	CAN0_MB_DL_DLC_0x7 = 0x7

	// MB0_D0: Mailbox Data Register %s
	// Position of DATA0 field.
	CAN0_MB_D0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	CAN0_MB_D0_DATA0_Msk = 0xff

	// MB0_D1: Mailbox Data Register %s
	// Position of DATA1 field.
	CAN0_MB_D1_DATA1_Pos = 0x0
	// Bit mask of DATA1 field.
	CAN0_MB_D1_DATA1_Msk = 0xff

	// MB0_D2: Mailbox Data Register %s
	// Position of DATA2 field.
	CAN0_MB_D2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	CAN0_MB_D2_DATA2_Msk = 0xff

	// MB0_D3: Mailbox Data Register %s
	// Position of DATA3 field.
	CAN0_MB_D3_DATA3_Pos = 0x0
	// Bit mask of DATA3 field.
	CAN0_MB_D3_DATA3_Msk = 0xff

	// MB0_D4: Mailbox Data Register %s
	// Position of DATA4 field.
	CAN0_MB_D4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	CAN0_MB_D4_DATA4_Msk = 0xff

	// MB0_D5: Mailbox Data Register %s
	// Position of DATA5 field.
	CAN0_MB_D5_DATA5_Pos = 0x0
	// Bit mask of DATA5 field.
	CAN0_MB_D5_DATA5_Msk = 0xff

	// MB0_D6: Mailbox Data Register %s
	// Position of DATA6 field.
	CAN0_MB_D6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	CAN0_MB_D6_DATA6_Msk = 0xff

	// MB0_D7: Mailbox Data Register %s
	// Position of DATA7 field.
	CAN0_MB_D7_DATA7_Pos = 0x0
	// Bit mask of DATA7 field.
	CAN0_MB_D7_DATA7_Msk = 0xff

	// MB0_TS: Mailbox Time Stamp Register %s
	// Position of TSL field.
	CAN0_MB_TS_TSL_Pos = 0x0
	// Bit mask of TSL field.
	CAN0_MB_TS_TSL_Msk = 0xff
	// Position of TSH field.
	CAN0_MB_TS_TSH_Pos = 0x8
	// Bit mask of TSH field.
	CAN0_MB_TS_TSH_Msk = 0xff00

	// MKR: Mask Register %s
	// Position of EID field.
	CAN0_MKR_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_MKR_EID_Msk = 0x3ffff
	// Do not compare associated EID[17:0] bits
	CAN0_MKR_EID_0 = 0x0
	// Compare associated EID[17:0] bits
	CAN0_MKR_EID_1 = 0x1
	// Position of SID field.
	CAN0_MKR_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_MKR_SID_Msk = 0x1ffc0000
	// Do not compare associated SID[10:0] bits
	CAN0_MKR_SID_0 = 0x0
	// Compare associated SID[10:0] bits
	CAN0_MKR_SID_1 = 0x1

	// FIDCR0: FIFO Received ID Compare Register %s
	// Position of EID field.
	CAN0_FIDCR_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_FIDCR_EID_Msk = 0x3ffff
	// Position of SID field.
	CAN0_FIDCR_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_FIDCR_SID_Msk = 0x1ffc0000
	// Position of RTR field.
	CAN0_FIDCR_RTR_Pos = 0x1e
	// Bit mask of RTR field.
	CAN0_FIDCR_RTR_Msk = 0x40000000
	// Bit RTR.
	CAN0_FIDCR_RTR = 0x40000000
	// Data frame
	CAN0_FIDCR_RTR_0 = 0x0
	// Remote frame
	CAN0_FIDCR_RTR_1 = 0x1
	// Position of IDE field.
	CAN0_FIDCR_IDE_Pos = 0x1f
	// Bit mask of IDE field.
	CAN0_FIDCR_IDE_Msk = 0x80000000
	// Bit IDE.
	CAN0_FIDCR_IDE = 0x80000000
	// Standard ID
	CAN0_FIDCR_IDE_0 = 0x0
	// Extended ID
	CAN0_FIDCR_IDE_1 = 0x1

	// MKIVLR: Mask Invalid Register
	// Position of MB00 field.
	CAN0_MKIVLR_MB00_Pos = 0x0
	// Bit mask of MB00 field.
	CAN0_MKIVLR_MB00_Msk = 0x1
	// Bit MB00.
	CAN0_MKIVLR_MB00 = 0x1
	// Mask valid
	CAN0_MKIVLR_MB00_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB00_1 = 0x1
	// Position of MB01 field.
	CAN0_MKIVLR_MB01_Pos = 0x1
	// Bit mask of MB01 field.
	CAN0_MKIVLR_MB01_Msk = 0x2
	// Bit MB01.
	CAN0_MKIVLR_MB01 = 0x2
	// Mask valid
	CAN0_MKIVLR_MB01_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB01_1 = 0x1
	// Position of MB02 field.
	CAN0_MKIVLR_MB02_Pos = 0x2
	// Bit mask of MB02 field.
	CAN0_MKIVLR_MB02_Msk = 0x4
	// Bit MB02.
	CAN0_MKIVLR_MB02 = 0x4
	// Mask valid
	CAN0_MKIVLR_MB02_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB02_1 = 0x1
	// Position of MB03 field.
	CAN0_MKIVLR_MB03_Pos = 0x3
	// Bit mask of MB03 field.
	CAN0_MKIVLR_MB03_Msk = 0x8
	// Bit MB03.
	CAN0_MKIVLR_MB03 = 0x8
	// Mask valid
	CAN0_MKIVLR_MB03_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB03_1 = 0x1
	// Position of MB04 field.
	CAN0_MKIVLR_MB04_Pos = 0x4
	// Bit mask of MB04 field.
	CAN0_MKIVLR_MB04_Msk = 0x10
	// Bit MB04.
	CAN0_MKIVLR_MB04 = 0x10
	// Mask valid
	CAN0_MKIVLR_MB04_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB04_1 = 0x1
	// Position of MB05 field.
	CAN0_MKIVLR_MB05_Pos = 0x5
	// Bit mask of MB05 field.
	CAN0_MKIVLR_MB05_Msk = 0x20
	// Bit MB05.
	CAN0_MKIVLR_MB05 = 0x20
	// Mask valid
	CAN0_MKIVLR_MB05_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB05_1 = 0x1
	// Position of MB06 field.
	CAN0_MKIVLR_MB06_Pos = 0x6
	// Bit mask of MB06 field.
	CAN0_MKIVLR_MB06_Msk = 0x40
	// Bit MB06.
	CAN0_MKIVLR_MB06 = 0x40
	// Mask valid
	CAN0_MKIVLR_MB06_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB06_1 = 0x1
	// Position of MB07 field.
	CAN0_MKIVLR_MB07_Pos = 0x7
	// Bit mask of MB07 field.
	CAN0_MKIVLR_MB07_Msk = 0x80
	// Bit MB07.
	CAN0_MKIVLR_MB07 = 0x80
	// Mask valid
	CAN0_MKIVLR_MB07_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB07_1 = 0x1
	// Position of MB08 field.
	CAN0_MKIVLR_MB08_Pos = 0x8
	// Bit mask of MB08 field.
	CAN0_MKIVLR_MB08_Msk = 0x100
	// Bit MB08.
	CAN0_MKIVLR_MB08 = 0x100
	// Mask valid
	CAN0_MKIVLR_MB08_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB08_1 = 0x1
	// Position of MB09 field.
	CAN0_MKIVLR_MB09_Pos = 0x9
	// Bit mask of MB09 field.
	CAN0_MKIVLR_MB09_Msk = 0x200
	// Bit MB09.
	CAN0_MKIVLR_MB09 = 0x200
	// Mask valid
	CAN0_MKIVLR_MB09_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB09_1 = 0x1
	// Position of MB10 field.
	CAN0_MKIVLR_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MKIVLR_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MKIVLR_MB10 = 0x400
	// Mask valid
	CAN0_MKIVLR_MB10_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB10_1 = 0x1
	// Position of MB11 field.
	CAN0_MKIVLR_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MKIVLR_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MKIVLR_MB11 = 0x800
	// Mask valid
	CAN0_MKIVLR_MB11_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB11_1 = 0x1
	// Position of MB12 field.
	CAN0_MKIVLR_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MKIVLR_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MKIVLR_MB12 = 0x1000
	// Mask valid
	CAN0_MKIVLR_MB12_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB12_1 = 0x1
	// Position of MB13 field.
	CAN0_MKIVLR_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MKIVLR_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MKIVLR_MB13 = 0x2000
	// Mask valid
	CAN0_MKIVLR_MB13_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB13_1 = 0x1
	// Position of MB14 field.
	CAN0_MKIVLR_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MKIVLR_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MKIVLR_MB14 = 0x4000
	// Mask valid
	CAN0_MKIVLR_MB14_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB14_1 = 0x1
	// Position of MB15 field.
	CAN0_MKIVLR_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MKIVLR_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MKIVLR_MB15 = 0x8000
	// Mask valid
	CAN0_MKIVLR_MB15_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB15_1 = 0x1
	// Position of MB16 field.
	CAN0_MKIVLR_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MKIVLR_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MKIVLR_MB16 = 0x10000
	// Mask valid
	CAN0_MKIVLR_MB16_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB16_1 = 0x1
	// Position of MB17 field.
	CAN0_MKIVLR_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MKIVLR_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MKIVLR_MB17 = 0x20000
	// Mask valid
	CAN0_MKIVLR_MB17_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB17_1 = 0x1
	// Position of MB18 field.
	CAN0_MKIVLR_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MKIVLR_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MKIVLR_MB18 = 0x40000
	// Mask valid
	CAN0_MKIVLR_MB18_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB18_1 = 0x1
	// Position of MB19 field.
	CAN0_MKIVLR_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MKIVLR_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MKIVLR_MB19 = 0x80000
	// Mask valid
	CAN0_MKIVLR_MB19_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB19_1 = 0x1
	// Position of MB20 field.
	CAN0_MKIVLR_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MKIVLR_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MKIVLR_MB20 = 0x100000
	// Mask valid
	CAN0_MKIVLR_MB20_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB20_1 = 0x1
	// Position of MB21 field.
	CAN0_MKIVLR_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MKIVLR_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MKIVLR_MB21 = 0x200000
	// Mask valid
	CAN0_MKIVLR_MB21_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB21_1 = 0x1
	// Position of MB22 field.
	CAN0_MKIVLR_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MKIVLR_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MKIVLR_MB22 = 0x400000
	// Mask valid
	CAN0_MKIVLR_MB22_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB22_1 = 0x1
	// Position of MB23 field.
	CAN0_MKIVLR_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MKIVLR_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MKIVLR_MB23 = 0x800000
	// Mask valid
	CAN0_MKIVLR_MB23_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB23_1 = 0x1
	// Position of MB24 field.
	CAN0_MKIVLR_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MKIVLR_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MKIVLR_MB24 = 0x1000000
	// Mask valid
	CAN0_MKIVLR_MB24_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB24_1 = 0x1
	// Position of MB25 field.
	CAN0_MKIVLR_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MKIVLR_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MKIVLR_MB25 = 0x2000000
	// Mask valid
	CAN0_MKIVLR_MB25_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB25_1 = 0x1
	// Position of MB26 field.
	CAN0_MKIVLR_MB26_Pos = 0x1a
	// Bit mask of MB26 field.
	CAN0_MKIVLR_MB26_Msk = 0x4000000
	// Bit MB26.
	CAN0_MKIVLR_MB26 = 0x4000000
	// Mask valid
	CAN0_MKIVLR_MB26_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB26_1 = 0x1
	// Position of MB27 field.
	CAN0_MKIVLR_MB27_Pos = 0x1b
	// Bit mask of MB27 field.
	CAN0_MKIVLR_MB27_Msk = 0x8000000
	// Bit MB27.
	CAN0_MKIVLR_MB27 = 0x8000000
	// Mask valid
	CAN0_MKIVLR_MB27_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB27_1 = 0x1
	// Position of MB28 field.
	CAN0_MKIVLR_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MKIVLR_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MKIVLR_MB28 = 0x10000000
	// Mask valid
	CAN0_MKIVLR_MB28_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB28_1 = 0x1
	// Position of MB29 field.
	CAN0_MKIVLR_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MKIVLR_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MKIVLR_MB29 = 0x20000000
	// Mask valid
	CAN0_MKIVLR_MB29_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB29_1 = 0x1
	// Position of MB30 field.
	CAN0_MKIVLR_MB30_Pos = 0x1e
	// Bit mask of MB30 field.
	CAN0_MKIVLR_MB30_Msk = 0x40000000
	// Bit MB30.
	CAN0_MKIVLR_MB30 = 0x40000000
	// Mask valid
	CAN0_MKIVLR_MB30_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB30_1 = 0x1
	// Position of MB31 field.
	CAN0_MKIVLR_MB31_Pos = 0x1f
	// Bit mask of MB31 field.
	CAN0_MKIVLR_MB31_Msk = 0x80000000
	// Bit MB31.
	CAN0_MKIVLR_MB31 = 0x80000000
	// Mask valid
	CAN0_MKIVLR_MB31_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB31_1 = 0x1

	// MIER: Mailbox Interrupt Enable Register
	// Position of MB00 field.
	CAN0_MIER_MB00_Pos = 0x0
	// Bit mask of MB00 field.
	CAN0_MIER_MB00_Msk = 0x1
	// Bit MB00.
	CAN0_MIER_MB00 = 0x1
	// Disable interrupt
	CAN0_MIER_MB00_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB00_1 = 0x1
	// Position of MB01 field.
	CAN0_MIER_MB01_Pos = 0x1
	// Bit mask of MB01 field.
	CAN0_MIER_MB01_Msk = 0x2
	// Bit MB01.
	CAN0_MIER_MB01 = 0x2
	// Disable interrupt
	CAN0_MIER_MB01_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB01_1 = 0x1
	// Position of MB02 field.
	CAN0_MIER_MB02_Pos = 0x2
	// Bit mask of MB02 field.
	CAN0_MIER_MB02_Msk = 0x4
	// Bit MB02.
	CAN0_MIER_MB02 = 0x4
	// Disable interrupt
	CAN0_MIER_MB02_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB02_1 = 0x1
	// Position of MB03 field.
	CAN0_MIER_MB03_Pos = 0x3
	// Bit mask of MB03 field.
	CAN0_MIER_MB03_Msk = 0x8
	// Bit MB03.
	CAN0_MIER_MB03 = 0x8
	// Disable interrupt
	CAN0_MIER_MB03_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB03_1 = 0x1
	// Position of MB04 field.
	CAN0_MIER_MB04_Pos = 0x4
	// Bit mask of MB04 field.
	CAN0_MIER_MB04_Msk = 0x10
	// Bit MB04.
	CAN0_MIER_MB04 = 0x10
	// Disable interrupt
	CAN0_MIER_MB04_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB04_1 = 0x1
	// Position of MB05 field.
	CAN0_MIER_MB05_Pos = 0x5
	// Bit mask of MB05 field.
	CAN0_MIER_MB05_Msk = 0x20
	// Bit MB05.
	CAN0_MIER_MB05 = 0x20
	// Disable interrupt
	CAN0_MIER_MB05_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB05_1 = 0x1
	// Position of MB06 field.
	CAN0_MIER_MB06_Pos = 0x6
	// Bit mask of MB06 field.
	CAN0_MIER_MB06_Msk = 0x40
	// Bit MB06.
	CAN0_MIER_MB06 = 0x40
	// Disable interrupt
	CAN0_MIER_MB06_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB06_1 = 0x1
	// Position of MB07 field.
	CAN0_MIER_MB07_Pos = 0x7
	// Bit mask of MB07 field.
	CAN0_MIER_MB07_Msk = 0x80
	// Bit MB07.
	CAN0_MIER_MB07 = 0x80
	// Disable interrupt
	CAN0_MIER_MB07_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB07_1 = 0x1
	// Position of MB08 field.
	CAN0_MIER_MB08_Pos = 0x8
	// Bit mask of MB08 field.
	CAN0_MIER_MB08_Msk = 0x100
	// Bit MB08.
	CAN0_MIER_MB08 = 0x100
	// Disable interrupt
	CAN0_MIER_MB08_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB08_1 = 0x1
	// Position of MB09 field.
	CAN0_MIER_MB09_Pos = 0x9
	// Bit mask of MB09 field.
	CAN0_MIER_MB09_Msk = 0x200
	// Bit MB09.
	CAN0_MIER_MB09 = 0x200
	// Disable interrupt
	CAN0_MIER_MB09_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB09_1 = 0x1
	// Position of MB10 field.
	CAN0_MIER_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MIER_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MIER_MB10 = 0x400
	// Disable interrupt
	CAN0_MIER_MB10_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB10_1 = 0x1
	// Position of MB11 field.
	CAN0_MIER_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MIER_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MIER_MB11 = 0x800
	// Disable interrupt
	CAN0_MIER_MB11_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB11_1 = 0x1
	// Position of MB12 field.
	CAN0_MIER_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MIER_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MIER_MB12 = 0x1000
	// Disable interrupt
	CAN0_MIER_MB12_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB12_1 = 0x1
	// Position of MB13 field.
	CAN0_MIER_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MIER_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MIER_MB13 = 0x2000
	// Disable interrupt
	CAN0_MIER_MB13_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB13_1 = 0x1
	// Position of MB14 field.
	CAN0_MIER_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MIER_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MIER_MB14 = 0x4000
	// Disable interrupt
	CAN0_MIER_MB14_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB14_1 = 0x1
	// Position of MB15 field.
	CAN0_MIER_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MIER_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MIER_MB15 = 0x8000
	// Disable interrupt
	CAN0_MIER_MB15_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB15_1 = 0x1
	// Position of MB16 field.
	CAN0_MIER_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MIER_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MIER_MB16 = 0x10000
	// Disable interrupt
	CAN0_MIER_MB16_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB16_1 = 0x1
	// Position of MB17 field.
	CAN0_MIER_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MIER_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MIER_MB17 = 0x20000
	// Disable interrupt
	CAN0_MIER_MB17_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB17_1 = 0x1
	// Position of MB18 field.
	CAN0_MIER_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MIER_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MIER_MB18 = 0x40000
	// Disable interrupt
	CAN0_MIER_MB18_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB18_1 = 0x1
	// Position of MB19 field.
	CAN0_MIER_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MIER_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MIER_MB19 = 0x80000
	// Disable interrupt
	CAN0_MIER_MB19_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB19_1 = 0x1
	// Position of MB20 field.
	CAN0_MIER_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MIER_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MIER_MB20 = 0x100000
	// Disable interrupt
	CAN0_MIER_MB20_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB20_1 = 0x1
	// Position of MB21 field.
	CAN0_MIER_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MIER_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MIER_MB21 = 0x200000
	// Disable interrupt
	CAN0_MIER_MB21_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB21_1 = 0x1
	// Position of MB22 field.
	CAN0_MIER_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MIER_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MIER_MB22 = 0x400000
	// Disable interrupt
	CAN0_MIER_MB22_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB22_1 = 0x1
	// Position of MB23 field.
	CAN0_MIER_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MIER_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MIER_MB23 = 0x800000
	// Disable interrupt
	CAN0_MIER_MB23_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB23_1 = 0x1
	// Position of MB24 field.
	CAN0_MIER_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MIER_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MIER_MB24 = 0x1000000
	// Disable interrupt
	CAN0_MIER_MB24_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB24_1 = 0x1
	// Position of MB25 field.
	CAN0_MIER_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MIER_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MIER_MB25 = 0x2000000
	// Disable interrupt
	CAN0_MIER_MB25_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB25_1 = 0x1
	// Position of MB26 field.
	CAN0_MIER_MB26_Pos = 0x1a
	// Bit mask of MB26 field.
	CAN0_MIER_MB26_Msk = 0x4000000
	// Bit MB26.
	CAN0_MIER_MB26 = 0x4000000
	// Disable interrupt
	CAN0_MIER_MB26_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB26_1 = 0x1
	// Position of MB27 field.
	CAN0_MIER_MB27_Pos = 0x1b
	// Bit mask of MB27 field.
	CAN0_MIER_MB27_Msk = 0x8000000
	// Bit MB27.
	CAN0_MIER_MB27 = 0x8000000
	// Disable interrupt
	CAN0_MIER_MB27_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB27_1 = 0x1
	// Position of MB28 field.
	CAN0_MIER_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MIER_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MIER_MB28 = 0x10000000
	// Disable interrupt
	CAN0_MIER_MB28_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB28_1 = 0x1
	// Position of MB29 field.
	CAN0_MIER_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MIER_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MIER_MB29 = 0x20000000
	// Disable interrupt
	CAN0_MIER_MB29_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB29_1 = 0x1
	// Position of MB30 field.
	CAN0_MIER_MB30_Pos = 0x1e
	// Bit mask of MB30 field.
	CAN0_MIER_MB30_Msk = 0x40000000
	// Bit MB30.
	CAN0_MIER_MB30 = 0x40000000
	// Disable interrupt
	CAN0_MIER_MB30_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB30_1 = 0x1
	// Position of MB31 field.
	CAN0_MIER_MB31_Pos = 0x1f
	// Bit mask of MB31 field.
	CAN0_MIER_MB31_Msk = 0x80000000
	// Bit MB31.
	CAN0_MIER_MB31 = 0x80000000
	// Disable interrupt
	CAN0_MIER_MB31_0 = 0x0
	// Enable interrupt
	CAN0_MIER_MB31_1 = 0x1

	// MIER_FIFO: Mailbox Interrupt Enable Register for FIFO Mailbox Mode
	// Position of MB00 field.
	CAN0_MIER_FIFO_MB00_Pos = 0x0
	// Bit mask of MB00 field.
	CAN0_MIER_FIFO_MB00_Msk = 0x1
	// Bit MB00.
	CAN0_MIER_FIFO_MB00 = 0x1
	// Disable interrupt
	CAN0_MIER_FIFO_MB00_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB00_1 = 0x1
	// Position of MB01 field.
	CAN0_MIER_FIFO_MB01_Pos = 0x1
	// Bit mask of MB01 field.
	CAN0_MIER_FIFO_MB01_Msk = 0x2
	// Bit MB01.
	CAN0_MIER_FIFO_MB01 = 0x2
	// Disable interrupt
	CAN0_MIER_FIFO_MB01_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB01_1 = 0x1
	// Position of MB02 field.
	CAN0_MIER_FIFO_MB02_Pos = 0x2
	// Bit mask of MB02 field.
	CAN0_MIER_FIFO_MB02_Msk = 0x4
	// Bit MB02.
	CAN0_MIER_FIFO_MB02 = 0x4
	// Disable interrupt
	CAN0_MIER_FIFO_MB02_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB02_1 = 0x1
	// Position of MB03 field.
	CAN0_MIER_FIFO_MB03_Pos = 0x3
	// Bit mask of MB03 field.
	CAN0_MIER_FIFO_MB03_Msk = 0x8
	// Bit MB03.
	CAN0_MIER_FIFO_MB03 = 0x8
	// Disable interrupt
	CAN0_MIER_FIFO_MB03_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB03_1 = 0x1
	// Position of MB04 field.
	CAN0_MIER_FIFO_MB04_Pos = 0x4
	// Bit mask of MB04 field.
	CAN0_MIER_FIFO_MB04_Msk = 0x10
	// Bit MB04.
	CAN0_MIER_FIFO_MB04 = 0x10
	// Disable interrupt
	CAN0_MIER_FIFO_MB04_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB04_1 = 0x1
	// Position of MB05 field.
	CAN0_MIER_FIFO_MB05_Pos = 0x5
	// Bit mask of MB05 field.
	CAN0_MIER_FIFO_MB05_Msk = 0x20
	// Bit MB05.
	CAN0_MIER_FIFO_MB05 = 0x20
	// Disable interrupt
	CAN0_MIER_FIFO_MB05_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB05_1 = 0x1
	// Position of MB06 field.
	CAN0_MIER_FIFO_MB06_Pos = 0x6
	// Bit mask of MB06 field.
	CAN0_MIER_FIFO_MB06_Msk = 0x40
	// Bit MB06.
	CAN0_MIER_FIFO_MB06 = 0x40
	// Disable interrupt
	CAN0_MIER_FIFO_MB06_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB06_1 = 0x1
	// Position of MB07 field.
	CAN0_MIER_FIFO_MB07_Pos = 0x7
	// Bit mask of MB07 field.
	CAN0_MIER_FIFO_MB07_Msk = 0x80
	// Bit MB07.
	CAN0_MIER_FIFO_MB07 = 0x80
	// Disable interrupt
	CAN0_MIER_FIFO_MB07_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB07_1 = 0x1
	// Position of MB08 field.
	CAN0_MIER_FIFO_MB08_Pos = 0x8
	// Bit mask of MB08 field.
	CAN0_MIER_FIFO_MB08_Msk = 0x100
	// Bit MB08.
	CAN0_MIER_FIFO_MB08 = 0x100
	// Disable interrupt
	CAN0_MIER_FIFO_MB08_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB08_1 = 0x1
	// Position of MB09 field.
	CAN0_MIER_FIFO_MB09_Pos = 0x9
	// Bit mask of MB09 field.
	CAN0_MIER_FIFO_MB09_Msk = 0x200
	// Bit MB09.
	CAN0_MIER_FIFO_MB09 = 0x200
	// Disable interrupt
	CAN0_MIER_FIFO_MB09_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB09_1 = 0x1
	// Position of MB10 field.
	CAN0_MIER_FIFO_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MIER_FIFO_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MIER_FIFO_MB10 = 0x400
	// Disable interrupt
	CAN0_MIER_FIFO_MB10_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB10_1 = 0x1
	// Position of MB11 field.
	CAN0_MIER_FIFO_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MIER_FIFO_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MIER_FIFO_MB11 = 0x800
	// Disable interrupt
	CAN0_MIER_FIFO_MB11_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB11_1 = 0x1
	// Position of MB12 field.
	CAN0_MIER_FIFO_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MIER_FIFO_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MIER_FIFO_MB12 = 0x1000
	// Disable interrupt
	CAN0_MIER_FIFO_MB12_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB12_1 = 0x1
	// Position of MB13 field.
	CAN0_MIER_FIFO_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MIER_FIFO_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MIER_FIFO_MB13 = 0x2000
	// Disable interrupt
	CAN0_MIER_FIFO_MB13_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB13_1 = 0x1
	// Position of MB14 field.
	CAN0_MIER_FIFO_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MIER_FIFO_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MIER_FIFO_MB14 = 0x4000
	// Disable interrupt
	CAN0_MIER_FIFO_MB14_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB14_1 = 0x1
	// Position of MB15 field.
	CAN0_MIER_FIFO_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MIER_FIFO_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MIER_FIFO_MB15 = 0x8000
	// Disable interrupt
	CAN0_MIER_FIFO_MB15_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB15_1 = 0x1
	// Position of MB16 field.
	CAN0_MIER_FIFO_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MIER_FIFO_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MIER_FIFO_MB16 = 0x10000
	// Disable interrupt
	CAN0_MIER_FIFO_MB16_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB16_1 = 0x1
	// Position of MB17 field.
	CAN0_MIER_FIFO_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MIER_FIFO_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MIER_FIFO_MB17 = 0x20000
	// Disable interrupt
	CAN0_MIER_FIFO_MB17_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB17_1 = 0x1
	// Position of MB18 field.
	CAN0_MIER_FIFO_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MIER_FIFO_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MIER_FIFO_MB18 = 0x40000
	// Disable interrupt
	CAN0_MIER_FIFO_MB18_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB18_1 = 0x1
	// Position of MB19 field.
	CAN0_MIER_FIFO_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MIER_FIFO_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MIER_FIFO_MB19 = 0x80000
	// Disable interrupt
	CAN0_MIER_FIFO_MB19_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB19_1 = 0x1
	// Position of MB20 field.
	CAN0_MIER_FIFO_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MIER_FIFO_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MIER_FIFO_MB20 = 0x100000
	// Disable interrupt
	CAN0_MIER_FIFO_MB20_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB20_1 = 0x1
	// Position of MB21 field.
	CAN0_MIER_FIFO_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MIER_FIFO_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MIER_FIFO_MB21 = 0x200000
	// Disable interrupt
	CAN0_MIER_FIFO_MB21_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB21_1 = 0x1
	// Position of MB22 field.
	CAN0_MIER_FIFO_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MIER_FIFO_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MIER_FIFO_MB22 = 0x400000
	// Disable interrupt
	CAN0_MIER_FIFO_MB22_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB22_1 = 0x1
	// Position of MB23 field.
	CAN0_MIER_FIFO_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MIER_FIFO_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MIER_FIFO_MB23 = 0x800000
	// Disable interrupt
	CAN0_MIER_FIFO_MB23_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB23_1 = 0x1
	// Position of MB24 field.
	CAN0_MIER_FIFO_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MIER_FIFO_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MIER_FIFO_MB24 = 0x1000000
	// Disable interrupt
	CAN0_MIER_FIFO_MB24_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB24_1 = 0x1
	// Position of MB25 field.
	CAN0_MIER_FIFO_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MIER_FIFO_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MIER_FIFO_MB25 = 0x2000000
	// Generate every time transmission completes
	CAN0_MIER_FIFO_MB25_0 = 0x0
	// Generate when the transmit FIFO empties on transmission completion
	CAN0_MIER_FIFO_MB25_1 = 0x1
	// Position of MB28 field.
	CAN0_MIER_FIFO_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MIER_FIFO_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MIER_FIFO_MB28 = 0x10000000
	// Disable interrupt
	CAN0_MIER_FIFO_MB28_0 = 0x0
	// Enable interrupt
	CAN0_MIER_FIFO_MB28_1 = 0x1
	// Position of MB29 field.
	CAN0_MIER_FIFO_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MIER_FIFO_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MIER_FIFO_MB29 = 0x20000000
	// Generate every time reception completes
	CAN0_MIER_FIFO_MB29_0 = 0x0
	// Generate when the receive FIFO becomes a buffer warning on reception completion
	CAN0_MIER_FIFO_MB29_1 = 0x1

	// MCTL_RX: Message Control Register for Receive
	// Position of NEWDATA field.
	CAN0_MCTL_RX_NEWDATA_Pos = 0x0
	// Bit mask of NEWDATA field.
	CAN0_MCTL_RX_NEWDATA_Msk = 0x1
	// Bit NEWDATA.
	CAN0_MCTL_RX_NEWDATA = 0x1
	// No data received, or 0 was written to the flag
	CAN0_MCTL_RX_NEWDATA_0 = 0x0
	// New message being stored or was stored in the mailbox
	CAN0_MCTL_RX_NEWDATA_1 = 0x1
	// Position of INVALDATA field.
	CAN0_MCTL_RX_INVALDATA_Pos = 0x1
	// Bit mask of INVALDATA field.
	CAN0_MCTL_RX_INVALDATA_Msk = 0x2
	// Bit INVALDATA.
	CAN0_MCTL_RX_INVALDATA = 0x2
	// Message valid
	CAN0_MCTL_RX_INVALDATA_0 = 0x0
	// Message being updated
	CAN0_MCTL_RX_INVALDATA_1 = 0x1
	// Position of MSGLOST field.
	CAN0_MCTL_RX_MSGLOST_Pos = 0x2
	// Bit mask of MSGLOST field.
	CAN0_MCTL_RX_MSGLOST_Msk = 0x4
	// Bit MSGLOST.
	CAN0_MCTL_RX_MSGLOST = 0x4
	// Message not overwritten or overrun
	CAN0_MCTL_RX_MSGLOST_0 = 0x0
	// Message overwritten or overrun
	CAN0_MCTL_RX_MSGLOST_1 = 0x1
	// Position of ONESHOT field.
	CAN0_MCTL_RX_ONESHOT_Pos = 0x4
	// Bit mask of ONESHOT field.
	CAN0_MCTL_RX_ONESHOT_Msk = 0x10
	// Bit ONESHOT.
	CAN0_MCTL_RX_ONESHOT = 0x10
	// Disable one-shot reception
	CAN0_MCTL_RX_ONESHOT_0 = 0x0
	// Enable one-shot reception
	CAN0_MCTL_RX_ONESHOT_1 = 0x1
	// Position of RECREQ field.
	CAN0_MCTL_RX_RECREQ_Pos = 0x6
	// Bit mask of RECREQ field.
	CAN0_MCTL_RX_RECREQ_Msk = 0x40
	// Bit RECREQ.
	CAN0_MCTL_RX_RECREQ = 0x40
	// Do not configure for reception
	CAN0_MCTL_RX_RECREQ_0 = 0x0
	// Configure for reception
	CAN0_MCTL_RX_RECREQ_1 = 0x1
	// Position of TRMREQ field.
	CAN0_MCTL_RX_TRMREQ_Pos = 0x7
	// Bit mask of TRMREQ field.
	CAN0_MCTL_RX_TRMREQ_Msk = 0x80
	// Bit TRMREQ.
	CAN0_MCTL_RX_TRMREQ = 0x80
	// Do not configure for transmission
	CAN0_MCTL_RX_TRMREQ_0 = 0x0
	// Configure for transmission
	CAN0_MCTL_RX_TRMREQ_1 = 0x1

	// MCTL_TX: Message Control Register for Transmit
	// Position of SENTDATA field.
	CAN0_MCTL_TX_SENTDATA_Pos = 0x0
	// Bit mask of SENTDATA field.
	CAN0_MCTL_TX_SENTDATA_Msk = 0x1
	// Bit SENTDATA.
	CAN0_MCTL_TX_SENTDATA = 0x1
	// Transmission not complete
	CAN0_MCTL_TX_SENTDATA_0 = 0x0
	// Transmission complete
	CAN0_MCTL_TX_SENTDATA_1 = 0x1
	// Position of TRMACTIVE field.
	CAN0_MCTL_TX_TRMACTIVE_Pos = 0x1
	// Bit mask of TRMACTIVE field.
	CAN0_MCTL_TX_TRMACTIVE_Msk = 0x2
	// Bit TRMACTIVE.
	CAN0_MCTL_TX_TRMACTIVE = 0x2
	// Transmission pending or not requested
	CAN0_MCTL_TX_TRMACTIVE_0 = 0x0
	// Transmission in progress
	CAN0_MCTL_TX_TRMACTIVE_1 = 0x1
	// Position of TRMABT field.
	CAN0_MCTL_TX_TRMABT_Pos = 0x2
	// Bit mask of TRMABT field.
	CAN0_MCTL_TX_TRMABT_Msk = 0x4
	// Bit TRMABT.
	CAN0_MCTL_TX_TRMABT = 0x4
	// Transmission started, transmission abort failed because transmission completed, or transmission abort not requested
	CAN0_MCTL_TX_TRMABT_0 = 0x0
	// Transmission abort complete
	CAN0_MCTL_TX_TRMABT_1 = 0x1
	// Position of ONESHOT field.
	CAN0_MCTL_TX_ONESHOT_Pos = 0x4
	// Bit mask of ONESHOT field.
	CAN0_MCTL_TX_ONESHOT_Msk = 0x10
	// Bit ONESHOT.
	CAN0_MCTL_TX_ONESHOT = 0x10
	// Disable one-shot transmission
	CAN0_MCTL_TX_ONESHOT_0 = 0x0
	// Enable one-shot transmission
	CAN0_MCTL_TX_ONESHOT_1 = 0x1
	// Position of RECREQ field.
	CAN0_MCTL_TX_RECREQ_Pos = 0x6
	// Bit mask of RECREQ field.
	CAN0_MCTL_TX_RECREQ_Msk = 0x40
	// Bit RECREQ.
	CAN0_MCTL_TX_RECREQ = 0x40
	// Do not configure for reception
	CAN0_MCTL_TX_RECREQ_0 = 0x0
	// Configure for reception
	CAN0_MCTL_TX_RECREQ_1 = 0x1
	// Position of TRMREQ field.
	CAN0_MCTL_TX_TRMREQ_Pos = 0x7
	// Bit mask of TRMREQ field.
	CAN0_MCTL_TX_TRMREQ_Msk = 0x80
	// Bit TRMREQ.
	CAN0_MCTL_TX_TRMREQ = 0x80
	// Do not configure for transmission
	CAN0_MCTL_TX_TRMREQ_0 = 0x0
	// Configure for transmission
	CAN0_MCTL_TX_TRMREQ_1 = 0x1

	// CTLR: Control Register
	// Position of MBM field.
	CAN0_CTLR_MBM_Pos = 0x0
	// Bit mask of MBM field.
	CAN0_CTLR_MBM_Msk = 0x1
	// Bit MBM.
	CAN0_CTLR_MBM = 0x1
	// Normal mailbox mode
	CAN0_CTLR_MBM_0 = 0x0
	// FIFO mailbox mode
	CAN0_CTLR_MBM_1 = 0x1
	// Position of IDFM field.
	CAN0_CTLR_IDFM_Pos = 0x1
	// Bit mask of IDFM field.
	CAN0_CTLR_IDFM_Msk = 0x6
	// Standard ID mode All mailboxes, including FIFO mailboxes, handle only standard IDs
	CAN0_CTLR_IDFM_00 = 0x0
	// Extended ID mode All mailboxes, including FIFO mailboxes, handle only extended IDs
	CAN0_CTLR_IDFM_01 = 0x1
	// Mixed ID mode All mailboxes, including FIFO mailboxes, handle both standard and extended IDs. In normal mailbox mode, use the associated IDE bit to differentiate standard and extended IDs. In FIFO mailbox mode, the associated IDE bits are used for mailboxes 0 to 23, the IDE bits in FIDCR0 and FIDCR1 are used for the receive FIFO, and the IDE bit associated with mailbox 24 is used for the transmit FIFO.
	CAN0_CTLR_IDFM_10 = 0x2
	// Setting prohibited
	CAN0_CTLR_IDFM_11 = 0x3
	// Position of MLM field.
	CAN0_CTLR_MLM_Pos = 0x3
	// Bit mask of MLM field.
	CAN0_CTLR_MLM_Msk = 0x8
	// Bit MLM.
	CAN0_CTLR_MLM = 0x8
	// Overwrite mode
	CAN0_CTLR_MLM_0 = 0x0
	// Overrun mode
	CAN0_CTLR_MLM_1 = 0x1
	// Position of TPM field.
	CAN0_CTLR_TPM_Pos = 0x4
	// Bit mask of TPM field.
	CAN0_CTLR_TPM_Msk = 0x10
	// Bit TPM.
	CAN0_CTLR_TPM = 0x10
	// ID priority transmit mode
	CAN0_CTLR_TPM_0 = 0x0
	// Mailbox number priority transmit mode
	CAN0_CTLR_TPM_1 = 0x1
	// Position of TSRC field.
	CAN0_CTLR_TSRC_Pos = 0x5
	// Bit mask of TSRC field.
	CAN0_CTLR_TSRC_Msk = 0x20
	// Bit TSRC.
	CAN0_CTLR_TSRC = 0x20
	// Do not reset time stamp counter
	CAN0_CTLR_TSRC_0 = 0x0
	// Reset time stamp counter
	CAN0_CTLR_TSRC_1 = 0x1
	// Position of TSPS field.
	CAN0_CTLR_TSPS_Pos = 0x6
	// Bit mask of TSPS field.
	CAN0_CTLR_TSPS_Msk = 0xc0
	// Every 1-bit time
	CAN0_CTLR_TSPS_00 = 0x0
	// Every 2-bit time
	CAN0_CTLR_TSPS_01 = 0x1
	// Every 4-bit time
	CAN0_CTLR_TSPS_10 = 0x2
	// Every 8-bit time
	CAN0_CTLR_TSPS_11 = 0x3
	// Position of CANM field.
	CAN0_CTLR_CANM_Pos = 0x8
	// Bit mask of CANM field.
	CAN0_CTLR_CANM_Msk = 0x300
	// CAN operation mode
	CAN0_CTLR_CANM_00 = 0x0
	// CAN reset mode
	CAN0_CTLR_CANM_01 = 0x1
	// CAN halt mode
	CAN0_CTLR_CANM_10 = 0x2
	// CAN reset mode (forced transition)
	CAN0_CTLR_CANM_11 = 0x3
	// Position of SLPM field.
	CAN0_CTLR_SLPM_Pos = 0xa
	// Bit mask of SLPM field.
	CAN0_CTLR_SLPM_Msk = 0x400
	// Bit SLPM.
	CAN0_CTLR_SLPM = 0x400
	// All other modes
	CAN0_CTLR_SLPM_0 = 0x0
	// CAN sleep mode
	CAN0_CTLR_SLPM_1 = 0x1
	// Position of BOM field.
	CAN0_CTLR_BOM_Pos = 0xb
	// Bit mask of BOM field.
	CAN0_CTLR_BOM_Msk = 0x1800
	// Normal mode (ISO11898-1-compliant)
	CAN0_CTLR_BOM_00 = 0x0
	// Enter CAN halt mode automatically on entering bus-off state
	CAN0_CTLR_BOM_01 = 0x1
	// Enter CAN halt mode automatically at the end of bus-off state
	CAN0_CTLR_BOM_10 = 0x2
	// Enter CAN halt mode during bus-off recovery period through a software request
	CAN0_CTLR_BOM_11 = 0x3
	// Position of RBOC field.
	CAN0_CTLR_RBOC_Pos = 0xd
	// Bit mask of RBOC field.
	CAN0_CTLR_RBOC_Msk = 0x2000
	// Bit RBOC.
	CAN0_CTLR_RBOC = 0x2000
	// No return occurred
	CAN0_CTLR_RBOC_0 = 0x0
	// Forced return from bus-off state
	CAN0_CTLR_RBOC_1 = 0x1

	// STR: Status Register
	// Position of NDST field.
	CAN0_STR_NDST_Pos = 0x0
	// Bit mask of NDST field.
	CAN0_STR_NDST_Msk = 0x1
	// Bit NDST.
	CAN0_STR_NDST = 0x1
	// No mailbox with NEWDATA = 1
	CAN0_STR_NDST_0 = 0x0
	// One or more mailboxes with NEWDATA = 1
	CAN0_STR_NDST_1 = 0x1
	// Position of SDST field.
	CAN0_STR_SDST_Pos = 0x1
	// Bit mask of SDST field.
	CAN0_STR_SDST_Msk = 0x2
	// Bit SDST.
	CAN0_STR_SDST = 0x2
	// No mailbox with SENTDATA = 1
	CAN0_STR_SDST_0 = 0x0
	// One or more mailboxes with SENTDATA = 1
	CAN0_STR_SDST_1 = 0x1
	// Position of RFST field.
	CAN0_STR_RFST_Pos = 0x2
	// Bit mask of RFST field.
	CAN0_STR_RFST_Msk = 0x4
	// Bit RFST.
	CAN0_STR_RFST = 0x4
	// Receive FIFO empty
	CAN0_STR_RFST_0 = 0x0
	// Message in receive FIFO
	CAN0_STR_RFST_1 = 0x1
	// Position of TFST field.
	CAN0_STR_TFST_Pos = 0x3
	// Bit mask of TFST field.
	CAN0_STR_TFST_Msk = 0x8
	// Bit TFST.
	CAN0_STR_TFST = 0x8
	// Transmit FIFO is full
	CAN0_STR_TFST_0 = 0x0
	// Transmit FIFO is not full
	CAN0_STR_TFST_1 = 0x1
	// Position of NMLST field.
	CAN0_STR_NMLST_Pos = 0x4
	// Bit mask of NMLST field.
	CAN0_STR_NMLST_Msk = 0x10
	// Bit NMLST.
	CAN0_STR_NMLST = 0x10
	// No mailbox with MSGLOST = 1
	CAN0_STR_NMLST_0 = 0x0
	// One or more mailboxes with MSGLOST = 1
	CAN0_STR_NMLST_1 = 0x1
	// Position of FMLST field.
	CAN0_STR_FMLST_Pos = 0x5
	// Bit mask of FMLST field.
	CAN0_STR_FMLST_Msk = 0x20
	// Bit FMLST.
	CAN0_STR_FMLST = 0x20
	// RFMLF = 0
	CAN0_STR_FMLST_0 = 0x0
	// RFMLF = 1
	CAN0_STR_FMLST_1 = 0x1
	// Position of TABST field.
	CAN0_STR_TABST_Pos = 0x6
	// Bit mask of TABST field.
	CAN0_STR_TABST_Msk = 0x40
	// Bit TABST.
	CAN0_STR_TABST = 0x40
	// No mailbox with TRMABT = 1
	CAN0_STR_TABST_0 = 0x0
	// One or more mailboxes with TRMABT = 1
	CAN0_STR_TABST_1 = 0x1
	// Position of EST field.
	CAN0_STR_EST_Pos = 0x7
	// Bit mask of EST field.
	CAN0_STR_EST_Msk = 0x80
	// Bit EST.
	CAN0_STR_EST = 0x80
	// No error occurred
	CAN0_STR_EST_0 = 0x0
	// Error occurred
	CAN0_STR_EST_1 = 0x1
	// Position of RSTST field.
	CAN0_STR_RSTST_Pos = 0x8
	// Bit mask of RSTST field.
	CAN0_STR_RSTST_Msk = 0x100
	// Bit RSTST.
	CAN0_STR_RSTST = 0x100
	// Not in CAN reset mode
	CAN0_STR_RSTST_0 = 0x0
	// In CAN reset mode
	CAN0_STR_RSTST_1 = 0x1
	// Position of HLTST field.
	CAN0_STR_HLTST_Pos = 0x9
	// Bit mask of HLTST field.
	CAN0_STR_HLTST_Msk = 0x200
	// Bit HLTST.
	CAN0_STR_HLTST = 0x200
	// Not in CAN halt mode
	CAN0_STR_HLTST_0 = 0x0
	// In CAN halt mode
	CAN0_STR_HLTST_1 = 0x1
	// Position of SLPST field.
	CAN0_STR_SLPST_Pos = 0xa
	// Bit mask of SLPST field.
	CAN0_STR_SLPST_Msk = 0x400
	// Bit SLPST.
	CAN0_STR_SLPST = 0x400
	// Not in CAN sleep mode
	CAN0_STR_SLPST_0 = 0x0
	// In CAN sleep mode
	CAN0_STR_SLPST_1 = 0x1
	// Position of EPST field.
	CAN0_STR_EPST_Pos = 0xb
	// Bit mask of EPST field.
	CAN0_STR_EPST_Msk = 0x800
	// Bit EPST.
	CAN0_STR_EPST = 0x800
	// Not in error-passive state
	CAN0_STR_EPST_0 = 0x0
	// In error-passive state
	CAN0_STR_EPST_1 = 0x1
	// Position of BOST field.
	CAN0_STR_BOST_Pos = 0xc
	// Bit mask of BOST field.
	CAN0_STR_BOST_Msk = 0x1000
	// Bit BOST.
	CAN0_STR_BOST = 0x1000
	// Not in bus-off state
	CAN0_STR_BOST_0 = 0x0
	// In bus-off state
	CAN0_STR_BOST_1 = 0x1
	// Position of TRMST field.
	CAN0_STR_TRMST_Pos = 0xd
	// Bit mask of TRMST field.
	CAN0_STR_TRMST_Msk = 0x2000
	// Bit TRMST.
	CAN0_STR_TRMST = 0x2000
	// Bus idle or reception in progress
	CAN0_STR_TRMST_0 = 0x0
	// Transmission in progress or module in bus-off state
	CAN0_STR_TRMST_1 = 0x1
	// Position of RECST field.
	CAN0_STR_RECST_Pos = 0xe
	// Bit mask of RECST field.
	CAN0_STR_RECST_Msk = 0x4000
	// Bit RECST.
	CAN0_STR_RECST = 0x4000
	// Bus idle or transmission in progress
	CAN0_STR_RECST_0 = 0x0
	// Reception in progress
	CAN0_STR_RECST_1 = 0x1

	// BCR: Bit Configuration Register
	// Position of CCLKS field.
	CAN0_BCR_CCLKS_Pos = 0x0
	// Bit mask of CCLKS field.
	CAN0_BCR_CCLKS_Msk = 0x1
	// Bit CCLKS.
	CAN0_BCR_CCLKS = 0x1
	// PCLKB (generated by the PLL clock)
	CAN0_BCR_CCLKS_0 = 0x0
	// CANMCLK (generated by the main clock oscillator)
	CAN0_BCR_CCLKS_1 = 0x1
	// Position of TSEG2 field.
	CAN0_BCR_TSEG2_Pos = 0x8
	// Bit mask of TSEG2 field.
	CAN0_BCR_TSEG2_Msk = 0x700
	// Setting prohibited
	CAN0_BCR_TSEG2_000 = 0x0
	// 2 Tq
	CAN0_BCR_TSEG2_001 = 0x1
	// 3 Tq
	CAN0_BCR_TSEG2_010 = 0x2
	// 4 Tq
	CAN0_BCR_TSEG2_011 = 0x3
	// 5 Tq
	CAN0_BCR_TSEG2_100 = 0x4
	// 6 Tq
	CAN0_BCR_TSEG2_101 = 0x5
	// 7 Tq
	CAN0_BCR_TSEG2_110 = 0x6
	// 8 Tq
	CAN0_BCR_TSEG2_111 = 0x7
	// Position of SJW field.
	CAN0_BCR_SJW_Pos = 0xc
	// Bit mask of SJW field.
	CAN0_BCR_SJW_Msk = 0x3000
	// 1 Tq
	CAN0_BCR_SJW_00 = 0x0
	// 2 Tq
	CAN0_BCR_SJW_01 = 0x1
	// 3 Tq
	CAN0_BCR_SJW_10 = 0x2
	// 4 Tq
	CAN0_BCR_SJW_11 = 0x3
	// Position of BRP field.
	CAN0_BCR_BRP_Pos = 0x10
	// Bit mask of BRP field.
	CAN0_BCR_BRP_Msk = 0x3ff0000
	// Position of TSEG1 field.
	CAN0_BCR_TSEG1_Pos = 0x1c
	// Bit mask of TSEG1 field.
	CAN0_BCR_TSEG1_Msk = 0xf0000000
	// 4 Tq
	CAN0_BCR_TSEG1_0x3 = 0x3
	// 5 Tq
	CAN0_BCR_TSEG1_0x4 = 0x4
	// 6 Tq
	CAN0_BCR_TSEG1_0x5 = 0x5
	// 7 Tq
	CAN0_BCR_TSEG1_0x6 = 0x6
	// 8 Tq
	CAN0_BCR_TSEG1_0x7 = 0x7
	// 9 Tq
	CAN0_BCR_TSEG1_0x8 = 0x8
	// 10 Tq
	CAN0_BCR_TSEG1_0x9 = 0x9
	// 11 Tq
	CAN0_BCR_TSEG1_0xA = 0xa
	// 12 Tq
	CAN0_BCR_TSEG1_0xB = 0xb
	// 13 Tq
	CAN0_BCR_TSEG1_0xC = 0xc
	// 14 Tq
	CAN0_BCR_TSEG1_0xD = 0xd
	// 15 Tq
	CAN0_BCR_TSEG1_0xE = 0xe
	// 16 Tq
	CAN0_BCR_TSEG1_0xF = 0xf

	// RFCR: Receive FIFO Control Register
	// Position of RFE field.
	CAN0_RFCR_RFE_Pos = 0x0
	// Bit mask of RFE field.
	CAN0_RFCR_RFE_Msk = 0x1
	// Bit RFE.
	CAN0_RFCR_RFE = 0x1
	// Disable receive FIFO
	CAN0_RFCR_RFE_0 = 0x0
	// Enable receive FIFO
	CAN0_RFCR_RFE_1 = 0x1
	// Position of RFUST field.
	CAN0_RFCR_RFUST_Pos = 0x1
	// Bit mask of RFUST field.
	CAN0_RFCR_RFUST_Msk = 0xe
	// No unread message
	CAN0_RFCR_RFUST_000 = 0x0
	// 1 unread message
	CAN0_RFCR_RFUST_001 = 0x1
	// 2 unread messages
	CAN0_RFCR_RFUST_010 = 0x2
	// 3 unread messages
	CAN0_RFCR_RFUST_011 = 0x3
	// 4 unread messages
	CAN0_RFCR_RFUST_100 = 0x4
	// Reserved
	CAN0_RFCR_RFUST_101 = 0x5
	// Reserved
	CAN0_RFCR_RFUST_110 = 0x6
	// Reserved
	CAN0_RFCR_RFUST_111 = 0x7
	// Position of RFMLF field.
	CAN0_RFCR_RFMLF_Pos = 0x4
	// Bit mask of RFMLF field.
	CAN0_RFCR_RFMLF_Msk = 0x10
	// Bit RFMLF.
	CAN0_RFCR_RFMLF = 0x10
	// Receive FIFO message not lost
	CAN0_RFCR_RFMLF_0 = 0x0
	// Receive FIFO message lost
	CAN0_RFCR_RFMLF_1 = 0x1
	// Position of RFFST field.
	CAN0_RFCR_RFFST_Pos = 0x5
	// Bit mask of RFFST field.
	CAN0_RFCR_RFFST_Msk = 0x20
	// Bit RFFST.
	CAN0_RFCR_RFFST = 0x20
	// Receive FIFO not full
	CAN0_RFCR_RFFST_0 = 0x0
	// Receive FIFO full (4 unread messages)
	CAN0_RFCR_RFFST_1 = 0x1
	// Position of RFWST field.
	CAN0_RFCR_RFWST_Pos = 0x6
	// Bit mask of RFWST field.
	CAN0_RFCR_RFWST_Msk = 0x40
	// Bit RFWST.
	CAN0_RFCR_RFWST = 0x40
	// Receive FIFO is not buffer warning
	CAN0_RFCR_RFWST_0 = 0x0
	// Receive FIFO is buffer warning (3 unread messages)
	CAN0_RFCR_RFWST_1 = 0x1
	// Position of RFEST field.
	CAN0_RFCR_RFEST_Pos = 0x7
	// Bit mask of RFEST field.
	CAN0_RFCR_RFEST_Msk = 0x80
	// Bit RFEST.
	CAN0_RFCR_RFEST = 0x80
	// Unread message in receive FIFO
	CAN0_RFCR_RFEST_0 = 0x0
	// No unread message in receive FIFO
	CAN0_RFCR_RFEST_1 = 0x1

	// TFCR: Transmit FIFO Control Register
	// Position of TFE field.
	CAN0_TFCR_TFE_Pos = 0x0
	// Bit mask of TFE field.
	CAN0_TFCR_TFE_Msk = 0x1
	// Bit TFE.
	CAN0_TFCR_TFE = 0x1
	// Disable transmit FIFO
	CAN0_TFCR_TFE_0 = 0x0
	// Enable transmit FIFO
	CAN0_TFCR_TFE_1 = 0x1
	// Position of TFUST field.
	CAN0_TFCR_TFUST_Pos = 0x1
	// Bit mask of TFUST field.
	CAN0_TFCR_TFUST_Msk = 0xe
	// 0 unsent messages
	CAN0_TFCR_TFUST_000 = 0x0
	// 1 unsent message
	CAN0_TFCR_TFUST_001 = 0x1
	// 2 unsent messages
	CAN0_TFCR_TFUST_010 = 0x2
	// 3 unread messages
	CAN0_TFCR_TFUST_011 = 0x3
	// 4 unread messages
	CAN0_TFCR_TFUST_100 = 0x4
	// Reserved
	CAN0_TFCR_TFUST_101 = 0x5
	// Reserved
	CAN0_TFCR_TFUST_110 = 0x6
	// Reserved
	CAN0_TFCR_TFUST_111 = 0x7
	// Position of TFFST field.
	CAN0_TFCR_TFFST_Pos = 0x6
	// Bit mask of TFFST field.
	CAN0_TFCR_TFFST_Msk = 0x40
	// Bit TFFST.
	CAN0_TFCR_TFFST = 0x40
	// Transmit FIFO not full
	CAN0_TFCR_TFFST_0 = 0x0
	// Transmit FIFO full (4 unsent messages)
	CAN0_TFCR_TFFST_1 = 0x1
	// Position of TFEST field.
	CAN0_TFCR_TFEST_Pos = 0x7
	// Bit mask of TFEST field.
	CAN0_TFCR_TFEST_Msk = 0x80
	// Bit TFEST.
	CAN0_TFCR_TFEST = 0x80
	// Unsent message in transmit FIFO
	CAN0_TFCR_TFEST_0 = 0x0
	// No unsent message in transmit FIFO
	CAN0_TFCR_TFEST_1 = 0x1

	// EIER: Error Interrupt Enable Register
	// Position of BEIE field.
	CAN0_EIER_BEIE_Pos = 0x0
	// Bit mask of BEIE field.
	CAN0_EIER_BEIE_Msk = 0x1
	// Bit BEIE.
	CAN0_EIER_BEIE = 0x1
	// Disable interrupt
	CAN0_EIER_BEIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_BEIE_1 = 0x1
	// Position of EWIE field.
	CAN0_EIER_EWIE_Pos = 0x1
	// Bit mask of EWIE field.
	CAN0_EIER_EWIE_Msk = 0x2
	// Bit EWIE.
	CAN0_EIER_EWIE = 0x2
	// Disable interrupt
	CAN0_EIER_EWIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_EWIE_1 = 0x1
	// Position of EPIE field.
	CAN0_EIER_EPIE_Pos = 0x2
	// Bit mask of EPIE field.
	CAN0_EIER_EPIE_Msk = 0x4
	// Bit EPIE.
	CAN0_EIER_EPIE = 0x4
	// Disable interrupt
	CAN0_EIER_EPIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_EPIE_1 = 0x1
	// Position of BOEIE field.
	CAN0_EIER_BOEIE_Pos = 0x3
	// Bit mask of BOEIE field.
	CAN0_EIER_BOEIE_Msk = 0x8
	// Bit BOEIE.
	CAN0_EIER_BOEIE = 0x8
	// Disable interrupt
	CAN0_EIER_BOEIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_BOEIE_1 = 0x1
	// Position of BORIE field.
	CAN0_EIER_BORIE_Pos = 0x4
	// Bit mask of BORIE field.
	CAN0_EIER_BORIE_Msk = 0x10
	// Bit BORIE.
	CAN0_EIER_BORIE = 0x10
	// Disable interrupt
	CAN0_EIER_BORIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_BORIE_1 = 0x1
	// Position of ORIE field.
	CAN0_EIER_ORIE_Pos = 0x5
	// Bit mask of ORIE field.
	CAN0_EIER_ORIE_Msk = 0x20
	// Bit ORIE.
	CAN0_EIER_ORIE = 0x20
	// Disable interrupt
	CAN0_EIER_ORIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_ORIE_1 = 0x1
	// Position of OLIE field.
	CAN0_EIER_OLIE_Pos = 0x6
	// Bit mask of OLIE field.
	CAN0_EIER_OLIE_Msk = 0x40
	// Bit OLIE.
	CAN0_EIER_OLIE = 0x40
	// Disable interrupt
	CAN0_EIER_OLIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_OLIE_1 = 0x1
	// Position of BLIE field.
	CAN0_EIER_BLIE_Pos = 0x7
	// Bit mask of BLIE field.
	CAN0_EIER_BLIE_Msk = 0x80
	// Bit BLIE.
	CAN0_EIER_BLIE = 0x80
	// Disable interrupt
	CAN0_EIER_BLIE_0 = 0x0
	// Enable interrupt
	CAN0_EIER_BLIE_1 = 0x1

	// EIFR: Error Interrupt Factor Judge Register
	// Position of BEIF field.
	CAN0_EIFR_BEIF_Pos = 0x0
	// Bit mask of BEIF field.
	CAN0_EIFR_BEIF_Msk = 0x1
	// Bit BEIF.
	CAN0_EIFR_BEIF = 0x1
	// No bus error detected
	CAN0_EIFR_BEIF_0 = 0x0
	// Bus error detected
	CAN0_EIFR_BEIF_1 = 0x1
	// Position of EWIF field.
	CAN0_EIFR_EWIF_Pos = 0x1
	// Bit mask of EWIF field.
	CAN0_EIFR_EWIF_Msk = 0x2
	// Bit EWIF.
	CAN0_EIFR_EWIF = 0x2
	// No error-warning detected
	CAN0_EIFR_EWIF_0 = 0x0
	// Error-warning detected
	CAN0_EIFR_EWIF_1 = 0x1
	// Position of EPIF field.
	CAN0_EIFR_EPIF_Pos = 0x2
	// Bit mask of EPIF field.
	CAN0_EIFR_EPIF_Msk = 0x4
	// Bit EPIF.
	CAN0_EIFR_EPIF = 0x4
	// No error-passive detected
	CAN0_EIFR_EPIF_0 = 0x0
	// Error-passive detected
	CAN0_EIFR_EPIF_1 = 0x1
	// Position of BOEIF field.
	CAN0_EIFR_BOEIF_Pos = 0x3
	// Bit mask of BOEIF field.
	CAN0_EIFR_BOEIF_Msk = 0x8
	// Bit BOEIF.
	CAN0_EIFR_BOEIF = 0x8
	// No bus-off entry detected
	CAN0_EIFR_BOEIF_0 = 0x0
	// Bus-off entry detected
	CAN0_EIFR_BOEIF_1 = 0x1
	// Position of BORIF field.
	CAN0_EIFR_BORIF_Pos = 0x4
	// Bit mask of BORIF field.
	CAN0_EIFR_BORIF_Msk = 0x10
	// Bit BORIF.
	CAN0_EIFR_BORIF = 0x10
	// No bus-off recovery detected
	CAN0_EIFR_BORIF_0 = 0x0
	// Bus-off recovery detected
	CAN0_EIFR_BORIF_1 = 0x1
	// Position of ORIF field.
	CAN0_EIFR_ORIF_Pos = 0x5
	// Bit mask of ORIF field.
	CAN0_EIFR_ORIF_Msk = 0x20
	// Bit ORIF.
	CAN0_EIFR_ORIF = 0x20
	// No receive overrun detected
	CAN0_EIFR_ORIF_0 = 0x0
	// Receive overrun detected
	CAN0_EIFR_ORIF_1 = 0x1
	// Position of OLIF field.
	CAN0_EIFR_OLIF_Pos = 0x6
	// Bit mask of OLIF field.
	CAN0_EIFR_OLIF_Msk = 0x40
	// Bit OLIF.
	CAN0_EIFR_OLIF = 0x40
	// No overload frame transmission detected
	CAN0_EIFR_OLIF_0 = 0x0
	// Overload frame transmission detected
	CAN0_EIFR_OLIF_1 = 0x1
	// Position of BLIF field.
	CAN0_EIFR_BLIF_Pos = 0x7
	// Bit mask of BLIF field.
	CAN0_EIFR_BLIF_Msk = 0x80
	// Bit BLIF.
	CAN0_EIFR_BLIF = 0x80
	// No bus lock detected
	CAN0_EIFR_BLIF_0 = 0x0
	// Bus lock detected
	CAN0_EIFR_BLIF_1 = 0x1

	// ECSR: Error Code Store Register
	// Position of SEF field.
	CAN0_ECSR_SEF_Pos = 0x0
	// Bit mask of SEF field.
	CAN0_ECSR_SEF_Msk = 0x1
	// Bit SEF.
	CAN0_ECSR_SEF = 0x1
	// No stuff error detected
	CAN0_ECSR_SEF_0 = 0x0
	// Stuff error detected
	CAN0_ECSR_SEF_1 = 0x1
	// Position of FEF field.
	CAN0_ECSR_FEF_Pos = 0x1
	// Bit mask of FEF field.
	CAN0_ECSR_FEF_Msk = 0x2
	// Bit FEF.
	CAN0_ECSR_FEF = 0x2
	// No form error detected
	CAN0_ECSR_FEF_0 = 0x0
	// Form error detected
	CAN0_ECSR_FEF_1 = 0x1
	// Position of AEF field.
	CAN0_ECSR_AEF_Pos = 0x2
	// Bit mask of AEF field.
	CAN0_ECSR_AEF_Msk = 0x4
	// Bit AEF.
	CAN0_ECSR_AEF = 0x4
	// No ACK error detected
	CAN0_ECSR_AEF_0 = 0x0
	// ACK error detected
	CAN0_ECSR_AEF_1 = 0x1
	// Position of CEF field.
	CAN0_ECSR_CEF_Pos = 0x3
	// Bit mask of CEF field.
	CAN0_ECSR_CEF_Msk = 0x8
	// Bit CEF.
	CAN0_ECSR_CEF = 0x8
	// No CRC error detected
	CAN0_ECSR_CEF_0 = 0x0
	// CRC error detected
	CAN0_ECSR_CEF_1 = 0x1
	// Position of BE1F field.
	CAN0_ECSR_BE1F_Pos = 0x4
	// Bit mask of BE1F field.
	CAN0_ECSR_BE1F_Msk = 0x10
	// Bit BE1F.
	CAN0_ECSR_BE1F = 0x10
	// No bit error (recessive) detected
	CAN0_ECSR_BE1F_0 = 0x0
	// Bit error (recessive) detected
	CAN0_ECSR_BE1F_1 = 0x1
	// Position of BE0F field.
	CAN0_ECSR_BE0F_Pos = 0x5
	// Bit mask of BE0F field.
	CAN0_ECSR_BE0F_Msk = 0x20
	// Bit BE0F.
	CAN0_ECSR_BE0F = 0x20
	// No bit error (dominant) detected
	CAN0_ECSR_BE0F_0 = 0x0
	// Bit error (dominant) detected
	CAN0_ECSR_BE0F_1 = 0x1
	// Position of ADEF field.
	CAN0_ECSR_ADEF_Pos = 0x6
	// Bit mask of ADEF field.
	CAN0_ECSR_ADEF_Msk = 0x40
	// Bit ADEF.
	CAN0_ECSR_ADEF = 0x40
	// No ACK delimiter error detected
	CAN0_ECSR_ADEF_0 = 0x0
	// ACK delimiter error detected
	CAN0_ECSR_ADEF_1 = 0x1
	// Position of EDPM field.
	CAN0_ECSR_EDPM_Pos = 0x7
	// Bit mask of EDPM field.
	CAN0_ECSR_EDPM_Msk = 0x80
	// Bit EDPM.
	CAN0_ECSR_EDPM = 0x80
	// Output first detected error code
	CAN0_ECSR_EDPM_0 = 0x0
	// Output accumulated error code
	CAN0_ECSR_EDPM_1 = 0x1

	// MSSR: Mailbox Search Status Register
	// Position of MBNST field.
	CAN0_MSSR_MBNST_Pos = 0x0
	// Bit mask of MBNST field.
	CAN0_MSSR_MBNST_Msk = 0x1f
	// Position of SEST field.
	CAN0_MSSR_SEST_Pos = 0x7
	// Bit mask of SEST field.
	CAN0_MSSR_SEST_Msk = 0x80
	// Bit SEST.
	CAN0_MSSR_SEST = 0x80
	// Search result found
	CAN0_MSSR_SEST_0 = 0x0
	// No search result
	CAN0_MSSR_SEST_1 = 0x1

	// MSMR: Mailbox Search Mode Register
	// Position of MBSM field.
	CAN0_MSMR_MBSM_Pos = 0x0
	// Bit mask of MBSM field.
	CAN0_MSMR_MBSM_Msk = 0x3
	// Receive mailbox search mode
	CAN0_MSMR_MBSM_00 = 0x0
	// Transmit mailbox search mode
	CAN0_MSMR_MBSM_01 = 0x1
	// Message lost search mode
	CAN0_MSMR_MBSM_10 = 0x2
	// Channel search mode
	CAN0_MSMR_MBSM_11 = 0x3

	// TCR: Test Control Register
	// Position of TSTE field.
	CAN0_TCR_TSTE_Pos = 0x0
	// Bit mask of TSTE field.
	CAN0_TCR_TSTE_Msk = 0x1
	// Bit TSTE.
	CAN0_TCR_TSTE = 0x1
	// Disable CAN test mode
	CAN0_TCR_TSTE_0 = 0x0
	// Enable CAN test mode
	CAN0_TCR_TSTE_1 = 0x1
	// Position of TSTM field.
	CAN0_TCR_TSTM_Pos = 0x1
	// Bit mask of TSTM field.
	CAN0_TCR_TSTM_Msk = 0x6
	// Not CAN test mode
	CAN0_TCR_TSTM_00 = 0x0
	// Listen-only mode
	CAN0_TCR_TSTM_01 = 0x1
	// Self-test mode 0 (external loopback)
	CAN0_TCR_TSTM_10 = 0x2
	// Self-test mode 1 (internal loopback)
	CAN0_TCR_TSTM_11 = 0x3
)

// Constants for PSCU: Peripheral Security Control Unit
const (
	// PSARB: Peripheral Security Attribution Register B
	// Position of PSARB2 field.
	PSCU_PSARB_PSARB2_Pos = 0x2
	// Bit mask of PSARB2 field.
	PSCU_PSARB_PSARB2_Msk = 0x4
	// Bit PSARB2.
	PSCU_PSARB_PSARB2 = 0x4
	// Secure
	PSCU_PSARB_PSARB2_0 = 0x0
	// Non-secure
	PSCU_PSARB_PSARB2_1 = 0x1
	// Position of PSARB6 field.
	PSCU_PSARB_PSARB6_Pos = 0x6
	// Bit mask of PSARB6 field.
	PSCU_PSARB_PSARB6_Msk = 0x40
	// Bit PSARB6.
	PSCU_PSARB_PSARB6 = 0x40
	// Position of PSARB8 field.
	PSCU_PSARB_PSARB8_Pos = 0x8
	// Bit mask of PSARB8 field.
	PSCU_PSARB_PSARB8_Msk = 0x100
	// Bit PSARB8.
	PSCU_PSARB_PSARB8 = 0x100
	// Secure
	PSCU_PSARB_PSARB8_0 = 0x0
	// Non-secure
	PSCU_PSARB_PSARB8_1 = 0x1
	// Position of PSARB9 field.
	PSCU_PSARB_PSARB9_Pos = 0x9
	// Bit mask of PSARB9 field.
	PSCU_PSARB_PSARB9_Msk = 0x200
	// Bit PSARB9.
	PSCU_PSARB_PSARB9 = 0x200
	// Secure
	PSCU_PSARB_PSARB9_0 = 0x0
	// Non-secure
	PSCU_PSARB_PSARB9_1 = 0x1
	// Position of PSARB11 field.
	PSCU_PSARB_PSARB11_Pos = 0xb
	// Bit mask of PSARB11 field.
	PSCU_PSARB_PSARB11_Msk = 0x800
	// Bit PSARB11.
	PSCU_PSARB_PSARB11 = 0x800
	// Secure
	PSCU_PSARB_PSARB11_0 = 0x0
	// Non-secure
	PSCU_PSARB_PSARB11_1 = 0x1
	// Position of PSARB15 field.
	PSCU_PSARB_PSARB15_Pos = 0xf
	// Bit mask of PSARB15 field.
	PSCU_PSARB_PSARB15_Msk = 0x8000
	// Bit PSARB15.
	PSCU_PSARB_PSARB15 = 0x8000
	// Position of PSARB18 field.
	PSCU_PSARB_PSARB18_Pos = 0x12
	// Bit mask of PSARB18 field.
	PSCU_PSARB_PSARB18_Msk = 0x40000
	// Bit PSARB18.
	PSCU_PSARB_PSARB18 = 0x40000
	// Secure
	PSCU_PSARB_PSARB18_0 = 0x0
	// Non-secure
	PSCU_PSARB_PSARB18_1 = 0x1
	// Position of PSARB19 field.
	PSCU_PSARB_PSARB19_Pos = 0x13
	// Bit mask of PSARB19 field.
	PSCU_PSARB_PSARB19_Msk = 0x80000
	// Bit PSARB19.
	PSCU_PSARB_PSARB19 = 0x80000
	// Secure
	PSCU_PSARB_PSARB19_0 = 0x0
	// Non-secure
	PSCU_PSARB_PSARB19_1 = 0x1
	// Position of PSARB22 field.
	PSCU_PSARB_PSARB22_Pos = 0x16
	// Bit mask of PSARB22 field.
	PSCU_PSARB_PSARB22_Msk = 0x400000
	// Bit PSARB22.
	PSCU_PSARB_PSARB22 = 0x400000
	// Secure
	PSCU_PSARB_PSARB22_0 = 0x0
	// Non-secure
	PSCU_PSARB_PSARB22_1 = 0x1
	// Position of PSARB27 field.
	PSCU_PSARB_PSARB27_Pos = 0x1b
	// Bit mask of PSARB27 field.
	PSCU_PSARB_PSARB27_Msk = 0x8000000
	// Bit PSARB27.
	PSCU_PSARB_PSARB27 = 0x8000000
	// Secure
	PSCU_PSARB_PSARB27_0 = 0x0
	// Non-secure
	PSCU_PSARB_PSARB27_1 = 0x1
	// Position of PSARB28 field.
	PSCU_PSARB_PSARB28_Pos = 0x1c
	// Bit mask of PSARB28 field.
	PSCU_PSARB_PSARB28_Msk = 0x10000000
	// Bit PSARB28.
	PSCU_PSARB_PSARB28 = 0x10000000
	// Secure
	PSCU_PSARB_PSARB28_0 = 0x0
	// Non-secure
	PSCU_PSARB_PSARB28_1 = 0x1
	// Position of PSARB29 field.
	PSCU_PSARB_PSARB29_Pos = 0x1d
	// Bit mask of PSARB29 field.
	PSCU_PSARB_PSARB29_Msk = 0x20000000
	// Bit PSARB29.
	PSCU_PSARB_PSARB29 = 0x20000000
	// Secure
	PSCU_PSARB_PSARB29_0 = 0x0
	// Non-secure
	PSCU_PSARB_PSARB29_1 = 0x1
	// Position of PSARB30 field.
	PSCU_PSARB_PSARB30_Pos = 0x1e
	// Bit mask of PSARB30 field.
	PSCU_PSARB_PSARB30_Msk = 0x40000000
	// Bit PSARB30.
	PSCU_PSARB_PSARB30 = 0x40000000
	// Secure
	PSCU_PSARB_PSARB30_0 = 0x0
	// Non-secure
	PSCU_PSARB_PSARB30_1 = 0x1
	// Position of PSARB31 field.
	PSCU_PSARB_PSARB31_Pos = 0x1f
	// Bit mask of PSARB31 field.
	PSCU_PSARB_PSARB31_Msk = 0x80000000
	// Bit PSARB31.
	PSCU_PSARB_PSARB31 = 0x80000000
	// Secure
	PSCU_PSARB_PSARB31_0 = 0x0
	// Non-secure
	PSCU_PSARB_PSARB31_1 = 0x1

	// PSARC: Peripheral Security Attribution Register C
	// Position of PSARC0 field.
	PSCU_PSARC_PSARC0_Pos = 0x0
	// Bit mask of PSARC0 field.
	PSCU_PSARC_PSARC0_Msk = 0x1
	// Bit PSARC0.
	PSCU_PSARC_PSARC0 = 0x1
	// Secure
	PSCU_PSARC_PSARC0_0 = 0x0
	// Non-secure
	PSCU_PSARC_PSARC0_1 = 0x1
	// Position of PSARC1 field.
	PSCU_PSARC_PSARC1_Pos = 0x1
	// Bit mask of PSARC1 field.
	PSCU_PSARC_PSARC1_Msk = 0x2
	// Bit PSARC1.
	PSCU_PSARC_PSARC1 = 0x2
	// Secure
	PSCU_PSARC_PSARC1_0 = 0x0
	// Non-secure
	PSCU_PSARC_PSARC1_1 = 0x1
	// Position of PSARC8 field.
	PSCU_PSARC_PSARC8_Pos = 0x8
	// Bit mask of PSARC8 field.
	PSCU_PSARC_PSARC8_Msk = 0x100
	// Bit PSARC8.
	PSCU_PSARC_PSARC8 = 0x100
	// Secure
	PSCU_PSARC_PSARC8_0 = 0x0
	// Non-secure
	PSCU_PSARC_PSARC8_1 = 0x1
	// Position of PSARC12 field.
	PSCU_PSARC_PSARC12_Pos = 0xc
	// Bit mask of PSARC12 field.
	PSCU_PSARC_PSARC12_Msk = 0x1000
	// Bit PSARC12.
	PSCU_PSARC_PSARC12 = 0x1000
	// Secure
	PSCU_PSARC_PSARC12_0 = 0x0
	// Non-secure
	PSCU_PSARC_PSARC12_1 = 0x1
	// Position of PSARC13 field.
	PSCU_PSARC_PSARC13_Pos = 0xd
	// Bit mask of PSARC13 field.
	PSCU_PSARC_PSARC13_Msk = 0x2000
	// Bit PSARC13.
	PSCU_PSARC_PSARC13 = 0x2000
	// Secure
	PSCU_PSARC_PSARC13_0 = 0x0
	// Non-secure
	PSCU_PSARC_PSARC13_1 = 0x1
	// Position of PSARC31 field.
	PSCU_PSARC_PSARC31_Pos = 0x1f
	// Bit mask of PSARC31 field.
	PSCU_PSARC_PSARC31_Msk = 0x80000000
	// Bit PSARC31.
	PSCU_PSARC_PSARC31 = 0x80000000
	// Secure
	PSCU_PSARC_PSARC31_0 = 0x0
	// Non-secure
	PSCU_PSARC_PSARC31_1 = 0x1

	// PSARD: Peripheral Security Attribution Register D
	// Position of PSARD0 field.
	PSCU_PSARD_PSARD0_Pos = 0x0
	// Bit mask of PSARD0 field.
	PSCU_PSARD_PSARD0_Msk = 0x1
	// Bit PSARD0.
	PSCU_PSARD_PSARD0 = 0x1
	// Secure
	PSCU_PSARD_PSARD0_0 = 0x0
	// Non-secure
	PSCU_PSARD_PSARD0_1 = 0x1
	// Position of PSARD1 field.
	PSCU_PSARD_PSARD1_Pos = 0x1
	// Bit mask of PSARD1 field.
	PSCU_PSARD_PSARD1_Msk = 0x2
	// Bit PSARD1.
	PSCU_PSARD_PSARD1 = 0x2
	// Secure
	PSCU_PSARD_PSARD1_0 = 0x0
	// Non-secure
	PSCU_PSARD_PSARD1_1 = 0x1
	// Position of PSARD2 field.
	PSCU_PSARD_PSARD2_Pos = 0x2
	// Bit mask of PSARD2 field.
	PSCU_PSARD_PSARD2_Msk = 0x4
	// Bit PSARD2.
	PSCU_PSARD_PSARD2 = 0x4
	// Secure
	PSCU_PSARD_PSARD2_0 = 0x0
	// Non-secure
	PSCU_PSARD_PSARD2_1 = 0x1
	// Position of PSARD3 field.
	PSCU_PSARD_PSARD3_Pos = 0x3
	// Bit mask of PSARD3 field.
	PSCU_PSARD_PSARD3_Msk = 0x8
	// Bit PSARD3.
	PSCU_PSARD_PSARD3 = 0x8
	// Secure
	PSCU_PSARD_PSARD3_0 = 0x0
	// Non-secure
	PSCU_PSARD_PSARD3_1 = 0x1
	// Position of PSARD11 field.
	PSCU_PSARD_PSARD11_Pos = 0xb
	// Bit mask of PSARD11 field.
	PSCU_PSARD_PSARD11_Msk = 0x800
	// Bit PSARD11.
	PSCU_PSARD_PSARD11 = 0x800
	// Secure
	PSCU_PSARD_PSARD11_0 = 0x0
	// Non-secure
	PSCU_PSARD_PSARD11_1 = 0x1
	// Position of PSARD12 field.
	PSCU_PSARD_PSARD12_Pos = 0xc
	// Bit mask of PSARD12 field.
	PSCU_PSARD_PSARD12_Msk = 0x1000
	// Bit PSARD12.
	PSCU_PSARD_PSARD12 = 0x1000
	// Secure
	PSCU_PSARD_PSARD12_0 = 0x0
	// Non-secure
	PSCU_PSARD_PSARD12_1 = 0x1
	// Position of PSARD13 field.
	PSCU_PSARD_PSARD13_Pos = 0xd
	// Bit mask of PSARD13 field.
	PSCU_PSARD_PSARD13_Msk = 0x2000
	// Bit PSARD13.
	PSCU_PSARD_PSARD13 = 0x2000
	// Secure
	PSCU_PSARD_PSARD13_0 = 0x0
	// Non-secure
	PSCU_PSARD_PSARD13_1 = 0x1
	// Position of PSARD14 field.
	PSCU_PSARD_PSARD14_Pos = 0xe
	// Bit mask of PSARD14 field.
	PSCU_PSARD_PSARD14_Msk = 0x4000
	// Bit PSARD14.
	PSCU_PSARD_PSARD14 = 0x4000
	// Secure
	PSCU_PSARD_PSARD14_0 = 0x0
	// Non-secure
	PSCU_PSARD_PSARD14_1 = 0x1
	// Position of PSARD16 field.
	PSCU_PSARD_PSARD16_Pos = 0x10
	// Bit mask of PSARD16 field.
	PSCU_PSARD_PSARD16_Msk = 0x10000
	// Bit PSARD16.
	PSCU_PSARD_PSARD16 = 0x10000
	// Secure
	PSCU_PSARD_PSARD16_0 = 0x0
	// Non-secure
	PSCU_PSARD_PSARD16_1 = 0x1
	// Position of PSARD20 field.
	PSCU_PSARD_PSARD20_Pos = 0x14
	// Bit mask of PSARD20 field.
	PSCU_PSARD_PSARD20_Msk = 0x100000
	// Bit PSARD20.
	PSCU_PSARD_PSARD20 = 0x100000
	// Secure
	PSCU_PSARD_PSARD20_0 = 0x0
	// Non-secure
	PSCU_PSARD_PSARD20_1 = 0x1

	// PSARE: Peripheral Security Attribution Register E
	// Position of PSARE0 field.
	PSCU_PSARE_PSARE0_Pos = 0x0
	// Bit mask of PSARE0 field.
	PSCU_PSARE_PSARE0_Msk = 0x1
	// Bit PSARE0.
	PSCU_PSARE_PSARE0 = 0x1
	// Secure
	PSCU_PSARE_PSARE0_0 = 0x0
	// Non-secure
	PSCU_PSARE_PSARE0_1 = 0x1
	// Position of PSARE1 field.
	PSCU_PSARE_PSARE1_Pos = 0x1
	// Bit mask of PSARE1 field.
	PSCU_PSARE_PSARE1_Msk = 0x2
	// Bit PSARE1.
	PSCU_PSARE_PSARE1 = 0x2
	// Secure
	PSCU_PSARE_PSARE1_0 = 0x0
	// Non-secure
	PSCU_PSARE_PSARE1_1 = 0x1
	// Position of PSARE2 field.
	PSCU_PSARE_PSARE2_Pos = 0x2
	// Bit mask of PSARE2 field.
	PSCU_PSARE_PSARE2_Msk = 0x4
	// Bit PSARE2.
	PSCU_PSARE_PSARE2 = 0x4
	// Secure
	PSCU_PSARE_PSARE2_0 = 0x0
	// Non-secure
	PSCU_PSARE_PSARE2_1 = 0x1
	// Position of PSARE14 field.
	PSCU_PSARE_PSARE14_Pos = 0xe
	// Bit mask of PSARE14 field.
	PSCU_PSARE_PSARE14_Msk = 0x4000
	// Bit PSARE14.
	PSCU_PSARE_PSARE14 = 0x4000
	// Secure
	PSCU_PSARE_PSARE14_0 = 0x0
	// Non-secure
	PSCU_PSARE_PSARE14_1 = 0x1
	// Position of PSARE15 field.
	PSCU_PSARE_PSARE15_Pos = 0xf
	// Bit mask of PSARE15 field.
	PSCU_PSARE_PSARE15_Msk = 0x8000
	// Bit PSARE15.
	PSCU_PSARE_PSARE15 = 0x8000
	// Secure
	PSCU_PSARE_PSARE15_0 = 0x0
	// Non-secure
	PSCU_PSARE_PSARE15_1 = 0x1
	// Position of PSARE24 field.
	PSCU_PSARE_PSARE24_Pos = 0x18
	// Bit mask of PSARE24 field.
	PSCU_PSARE_PSARE24_Msk = 0x1000000
	// Bit PSARE24.
	PSCU_PSARE_PSARE24 = 0x1000000
	// Secure
	PSCU_PSARE_PSARE24_0 = 0x0
	// Non-secure
	PSCU_PSARE_PSARE24_1 = 0x1
	// Position of PSARE25 field.
	PSCU_PSARE_PSARE25_Pos = 0x19
	// Bit mask of PSARE25 field.
	PSCU_PSARE_PSARE25_Msk = 0x2000000
	// Bit PSARE25.
	PSCU_PSARE_PSARE25 = 0x2000000
	// Secure
	PSCU_PSARE_PSARE25_0 = 0x0
	// Non-secure
	PSCU_PSARE_PSARE25_1 = 0x1
	// Position of PSARE26 field.
	PSCU_PSARE_PSARE26_Pos = 0x1a
	// Bit mask of PSARE26 field.
	PSCU_PSARE_PSARE26_Msk = 0x4000000
	// Bit PSARE26.
	PSCU_PSARE_PSARE26 = 0x4000000
	// Secure
	PSCU_PSARE_PSARE26_0 = 0x0
	// Non-secure
	PSCU_PSARE_PSARE26_1 = 0x1
	// Position of PSARE27 field.
	PSCU_PSARE_PSARE27_Pos = 0x1b
	// Bit mask of PSARE27 field.
	PSCU_PSARE_PSARE27_Msk = 0x8000000
	// Bit PSARE27.
	PSCU_PSARE_PSARE27 = 0x8000000
	// Secure
	PSCU_PSARE_PSARE27_0 = 0x0
	// Non-secure
	PSCU_PSARE_PSARE27_1 = 0x1
	// Position of PSARE29 field.
	PSCU_PSARE_PSARE29_Pos = 0x1d
	// Bit mask of PSARE29 field.
	PSCU_PSARE_PSARE29_Msk = 0x20000000
	// Bit PSARE29.
	PSCU_PSARE_PSARE29 = 0x20000000
	// Secure
	PSCU_PSARE_PSARE29_0 = 0x0
	// Non-secure
	PSCU_PSARE_PSARE29_1 = 0x1
	// Position of PSARE30 field.
	PSCU_PSARE_PSARE30_Pos = 0x1e
	// Bit mask of PSARE30 field.
	PSCU_PSARE_PSARE30_Msk = 0x40000000
	// Bit PSARE30.
	PSCU_PSARE_PSARE30 = 0x40000000
	// Secure
	PSCU_PSARE_PSARE30_0 = 0x0
	// Non-secure
	PSCU_PSARE_PSARE30_1 = 0x1

	// MSSAR: Module Stop Security Attribution Register
	// Position of MSSAR0 field.
	PSCU_MSSAR_MSSAR0_Pos = 0x0
	// Bit mask of MSSAR0 field.
	PSCU_MSSAR_MSSAR0_Msk = 0x1
	// Bit MSSAR0.
	PSCU_MSSAR_MSSAR0 = 0x1
	// Secure
	PSCU_MSSAR_MSSAR0_0 = 0x0
	// Non-secure
	PSCU_MSSAR_MSSAR0_1 = 0x1
	// Position of MSSAR1 field.
	PSCU_MSSAR_MSSAR1_Pos = 0x1
	// Bit mask of MSSAR1 field.
	PSCU_MSSAR_MSSAR1_Msk = 0x2
	// Bit MSSAR1.
	PSCU_MSSAR_MSSAR1 = 0x2
	// Secure
	PSCU_MSSAR_MSSAR1_0 = 0x0
	// Non-secure
	PSCU_MSSAR_MSSAR1_1 = 0x1
	// Position of MSSAR2 field.
	PSCU_MSSAR_MSSAR2_Pos = 0x2
	// Bit mask of MSSAR2 field.
	PSCU_MSSAR_MSSAR2_Msk = 0x4
	// Bit MSSAR2.
	PSCU_MSSAR_MSSAR2 = 0x4
	// Secure
	PSCU_MSSAR_MSSAR2_0 = 0x0
	// Non-secure
	PSCU_MSSAR_MSSAR2_1 = 0x1
	// Position of MSSAR3 field.
	PSCU_MSSAR_MSSAR3_Pos = 0x3
	// Bit mask of MSSAR3 field.
	PSCU_MSSAR_MSSAR3_Msk = 0x8
	// Bit MSSAR3.
	PSCU_MSSAR_MSSAR3 = 0x8
	// Secure
	PSCU_MSSAR_MSSAR3_0 = 0x0
	// Non-secure
	PSCU_MSSAR_MSSAR3_1 = 0x1

	// CFSAMONA: Code Flash Security Attribution Monitor Register A
	// Position of CFS2 field.
	PSCU_CFSAMONA_CFS2_Pos = 0xf
	// Bit mask of CFS2 field.
	PSCU_CFSAMONA_CFS2_Msk = 0xff8000

	// CFSAMONB: Code Flash Security Attribution Monitor Register B
	// Position of CFS1 field.
	PSCU_CFSAMONB_CFS1_Pos = 0xa
	// Bit mask of CFS1 field.
	PSCU_CFSAMONB_CFS1_Msk = 0xfffc00

	// DFSAMON: Data Flash Security Attribution Monitor Register
	// Position of DFS field.
	PSCU_DFSAMON_DFS_Pos = 0xa
	// Bit mask of DFS field.
	PSCU_DFSAMON_DFS_Msk = 0xfc00

	// SSAMONA: SRAM Security Attribution Monitor Register A
	// Position of SS2 field.
	PSCU_SSAMONA_SS2_Pos = 0xd
	// Bit mask of SS2 field.
	PSCU_SSAMONA_SS2_Msk = 0x1fe000

	// SSAMONB: SRAM Security Attribution Monitor Register B
	// Position of SS1 field.
	PSCU_SSAMONB_SS1_Pos = 0xa
	// Bit mask of SS1 field.
	PSCU_SSAMONB_SS1_Msk = 0x1ffc00

	// DLMMON: Device Lifecycle Management State Monitor Register
	// Position of DLMMON field.
	PSCU_DLMMON_DLMMON_Pos = 0x0
	// Bit mask of DLMMON field.
	PSCU_DLMMON_DLMMON_Msk = 0xf
	// CM
	PSCU_DLMMON_DLMMON_0x1 = 0x1
	// SSD
	PSCU_DLMMON_DLMMON_0x2 = 0x2
	// NSECSD
	PSCU_DLMMON_DLMMON_0x3 = 0x3
	// DPL
	PSCU_DLMMON_DLMMON_0x4 = 0x4
	// LCK_DBG
	PSCU_DLMMON_DLMMON_0x5 = 0x5
	// LCK_BOOT
	PSCU_DLMMON_DLMMON_0x6 = 0x6
	// RMA_REQ
	PSCU_DLMMON_DLMMON_0x7 = 0x7
	// RMA_ACK
	PSCU_DLMMON_DLMMON_0x8 = 0x8
)

// Constants for AGT0: Low Power Asynchronous General Purpose Timer 0
const (
	// AGTCR: AGT Control Register
	// Position of TSTART field.
	AGT0_AGTCR_TSTART_Pos = 0x0
	// Bit mask of TSTART field.
	AGT0_AGTCR_TSTART_Msk = 0x1
	// Bit TSTART.
	AGT0_AGTCR_TSTART = 0x1
	// Count stops
	AGT0_AGTCR_TSTART_0 = 0x0
	// Count starts
	AGT0_AGTCR_TSTART_1 = 0x1
	// Position of TCSTF field.
	AGT0_AGTCR_TCSTF_Pos = 0x1
	// Bit mask of TCSTF field.
	AGT0_AGTCR_TCSTF_Msk = 0x2
	// Bit TCSTF.
	AGT0_AGTCR_TCSTF = 0x2
	// Count stopped
	AGT0_AGTCR_TCSTF_0 = 0x0
	// Count in progress
	AGT0_AGTCR_TCSTF_1 = 0x1
	// Position of TSTOP field.
	AGT0_AGTCR_TSTOP_Pos = 0x2
	// Bit mask of TSTOP field.
	AGT0_AGTCR_TSTOP_Msk = 0x4
	// Bit TSTOP.
	AGT0_AGTCR_TSTOP = 0x4
	// Writing is invalid
	AGT0_AGTCR_TSTOP_0 = 0x0
	// The count is forcibly stopped
	AGT0_AGTCR_TSTOP_1 = 0x1
	// Position of TEDGF field.
	AGT0_AGTCR_TEDGF_Pos = 0x4
	// Bit mask of TEDGF field.
	AGT0_AGTCR_TEDGF_Msk = 0x10
	// Bit TEDGF.
	AGT0_AGTCR_TEDGF = 0x10
	// No active edge received
	AGT0_AGTCR_TEDGF_0 = 0x0
	// Active edge received
	AGT0_AGTCR_TEDGF_1 = 0x1
	// Position of TUNDF field.
	AGT0_AGTCR_TUNDF_Pos = 0x5
	// Bit mask of TUNDF field.
	AGT0_AGTCR_TUNDF_Msk = 0x20
	// Bit TUNDF.
	AGT0_AGTCR_TUNDF = 0x20
	// No underflow
	AGT0_AGTCR_TUNDF_0 = 0x0
	// Underflow
	AGT0_AGTCR_TUNDF_1 = 0x1
	// Position of TCMAF field.
	AGT0_AGTCR_TCMAF_Pos = 0x6
	// Bit mask of TCMAF field.
	AGT0_AGTCR_TCMAF_Msk = 0x40
	// Bit TCMAF.
	AGT0_AGTCR_TCMAF = 0x40
	// No match
	AGT0_AGTCR_TCMAF_0 = 0x0
	// Match
	AGT0_AGTCR_TCMAF_1 = 0x1
	// Position of TCMBF field.
	AGT0_AGTCR_TCMBF_Pos = 0x7
	// Bit mask of TCMBF field.
	AGT0_AGTCR_TCMBF_Msk = 0x80
	// Bit TCMBF.
	AGT0_AGTCR_TCMBF = 0x80
	// No match
	AGT0_AGTCR_TCMBF_0 = 0x0
	// Match
	AGT0_AGTCR_TCMBF_1 = 0x1

	// AGTMR1: AGT Mode Register 1
	// Position of TMOD field.
	AGT0_AGTMR1_TMOD_Pos = 0x0
	// Bit mask of TMOD field.
	AGT0_AGTMR1_TMOD_Msk = 0x7
	// Timer mode
	AGT0_AGTMR1_TMOD_000 = 0x0
	// Pulse output mode
	AGT0_AGTMR1_TMOD_001 = 0x1
	// Event counter mode
	AGT0_AGTMR1_TMOD_010 = 0x2
	// Pulse width measurement mode
	AGT0_AGTMR1_TMOD_011 = 0x3
	// Pulse period measurement mode
	AGT0_AGTMR1_TMOD_100 = 0x4
	// Position of TEDGPL field.
	AGT0_AGTMR1_TEDGPL_Pos = 0x3
	// Bit mask of TEDGPL field.
	AGT0_AGTMR1_TEDGPL_Msk = 0x8
	// Bit TEDGPL.
	AGT0_AGTMR1_TEDGPL = 0x8
	// Single-edge
	AGT0_AGTMR1_TEDGPL_0 = 0x0
	// Both-edge
	AGT0_AGTMR1_TEDGPL_1 = 0x1
	// Position of TCK field.
	AGT0_AGTMR1_TCK_Pos = 0x4
	// Bit mask of TCK field.
	AGT0_AGTMR1_TCK_Msk = 0x70
	// PCLKB
	AGT0_AGTMR1_TCK_000 = 0x0
	// PCLKB/8
	AGT0_AGTMR1_TCK_001 = 0x1
	// PCLKB/2
	AGT0_AGTMR1_TCK_011 = 0x3
	// Divided clock AGTLCLK specified by CKS[2:0] bits in the AGTMR2 register
	AGT0_AGTMR1_TCK_100 = 0x4
	// Underflow event signal from AGTn (n = 0, 2, 4)
	AGT0_AGTMR1_TCK_101 = 0x5
	// Divided clock AGTSCLK specified by CKS[2:0] bits in the AGTMR2 register
	AGT0_AGTMR1_TCK_110 = 0x6

	// AGTMR2: AGT Mode Register 2
	// Position of CKS field.
	AGT0_AGTMR2_CKS_Pos = 0x0
	// Bit mask of CKS field.
	AGT0_AGTMR2_CKS_Msk = 0x7
	// 1/1
	AGT0_AGTMR2_CKS_000 = 0x0
	// 1/2
	AGT0_AGTMR2_CKS_001 = 0x1
	// 1/4
	AGT0_AGTMR2_CKS_010 = 0x2
	// 1/8
	AGT0_AGTMR2_CKS_011 = 0x3
	// 1/16
	AGT0_AGTMR2_CKS_100 = 0x4
	// 1/32
	AGT0_AGTMR2_CKS_101 = 0x5
	// 1/64
	AGT0_AGTMR2_CKS_110 = 0x6
	// 1/128
	AGT0_AGTMR2_CKS_111 = 0x7
	// Position of LPM field.
	AGT0_AGTMR2_LPM_Pos = 0x7
	// Bit mask of LPM field.
	AGT0_AGTMR2_LPM_Msk = 0x80
	// Bit LPM.
	AGT0_AGTMR2_LPM = 0x80
	// Normal mode
	AGT0_AGTMR2_LPM_0 = 0x0
	// Low power mode
	AGT0_AGTMR2_LPM_1 = 0x1

	// AGTIOC: AGT I/O Control Register
	// Position of TEDGSEL field.
	AGT0_AGTIOC_TEDGSEL_Pos = 0x0
	// Bit mask of TEDGSEL field.
	AGT0_AGTIOC_TEDGSEL_Msk = 0x1
	// Bit TEDGSEL.
	AGT0_AGTIOC_TEDGSEL = 0x1
	// Position of TOE field.
	AGT0_AGTIOC_TOE_Pos = 0x2
	// Bit mask of TOE field.
	AGT0_AGTIOC_TOE_Msk = 0x4
	// Bit TOE.
	AGT0_AGTIOC_TOE = 0x4
	// AGTOn pin output disabled
	AGT0_AGTIOC_TOE_0 = 0x0
	// AGTOn pin output enabled
	AGT0_AGTIOC_TOE_1 = 0x1
	// Position of TIPF field.
	AGT0_AGTIOC_TIPF_Pos = 0x4
	// Bit mask of TIPF field.
	AGT0_AGTIOC_TIPF_Msk = 0x30
	// No filter
	AGT0_AGTIOC_TIPF_00 = 0x0
	// Filter sampled at PCLKB
	AGT0_AGTIOC_TIPF_01 = 0x1
	// Filter sampled at PCLKB/8
	AGT0_AGTIOC_TIPF_10 = 0x2
	// Filter sampled at PCLKB/32
	AGT0_AGTIOC_TIPF_11 = 0x3
	// Position of TIOGT field.
	AGT0_AGTIOC_TIOGT_Pos = 0x6
	// Bit mask of TIOGT field.
	AGT0_AGTIOC_TIOGT_Msk = 0xc0
	// Event is always counted
	AGT0_AGTIOC_TIOGT_00 = 0x0
	// Event is counted during polarity period specified for AGTEEn pin
	AGT0_AGTIOC_TIOGT_01 = 0x1

	// AGTISR: AGT Event Pin Select Register
	// Position of EEPS field.
	AGT0_AGTISR_EEPS_Pos = 0x2
	// Bit mask of EEPS field.
	AGT0_AGTISR_EEPS_Msk = 0x4
	// Bit EEPS.
	AGT0_AGTISR_EEPS = 0x4
	// An event is counted during the low-level period
	AGT0_AGTISR_EEPS_0 = 0x0
	// An event is counted during the high-level period
	AGT0_AGTISR_EEPS_1 = 0x1

	// AGTCMSR: AGT Compare Match Function Select Register
	// Position of TCMEA field.
	AGT0_AGTCMSR_TCMEA_Pos = 0x0
	// Bit mask of TCMEA field.
	AGT0_AGTCMSR_TCMEA_Msk = 0x1
	// Bit TCMEA.
	AGT0_AGTCMSR_TCMEA = 0x1
	// AGT Compare match A register disabled
	AGT0_AGTCMSR_TCMEA_0 = 0x0
	// AGT Compare match A register enabled
	AGT0_AGTCMSR_TCMEA_1 = 0x1
	// Position of TOEA field.
	AGT0_AGTCMSR_TOEA_Pos = 0x1
	// Bit mask of TOEA field.
	AGT0_AGTCMSR_TOEA_Msk = 0x2
	// Bit TOEA.
	AGT0_AGTCMSR_TOEA = 0x2
	// AGTOAn pin output disabled
	AGT0_AGTCMSR_TOEA_0 = 0x0
	// AGTOAn pin output enabled
	AGT0_AGTCMSR_TOEA_1 = 0x1
	// Position of TOPOLA field.
	AGT0_AGTCMSR_TOPOLA_Pos = 0x2
	// Bit mask of TOPOLA field.
	AGT0_AGTCMSR_TOPOLA_Msk = 0x4
	// Bit TOPOLA.
	AGT0_AGTCMSR_TOPOLA = 0x4
	// AGTOAn pin output is started on low. i.e. normal output
	AGT0_AGTCMSR_TOPOLA_0 = 0x0
	// AGTOAn pin output is started on high. i.e. inverted output
	AGT0_AGTCMSR_TOPOLA_1 = 0x1
	// Position of TCMEB field.
	AGT0_AGTCMSR_TCMEB_Pos = 0x4
	// Bit mask of TCMEB field.
	AGT0_AGTCMSR_TCMEB_Msk = 0x10
	// Bit TCMEB.
	AGT0_AGTCMSR_TCMEB = 0x10
	// Compare match B register disabled
	AGT0_AGTCMSR_TCMEB_0 = 0x0
	// Compare match B register enabled
	AGT0_AGTCMSR_TCMEB_1 = 0x1
	// Position of TOEB field.
	AGT0_AGTCMSR_TOEB_Pos = 0x5
	// Bit mask of TOEB field.
	AGT0_AGTCMSR_TOEB_Msk = 0x20
	// Bit TOEB.
	AGT0_AGTCMSR_TOEB = 0x20
	// AGTOBn pin output disabled
	AGT0_AGTCMSR_TOEB_0 = 0x0
	// AGTOBn pin output enabled
	AGT0_AGTCMSR_TOEB_1 = 0x1
	// Position of TOPOLB field.
	AGT0_AGTCMSR_TOPOLB_Pos = 0x6
	// Bit mask of TOPOLB field.
	AGT0_AGTCMSR_TOPOLB_Msk = 0x40
	// Bit TOPOLB.
	AGT0_AGTCMSR_TOPOLB = 0x40
	// AGTOBn pin output is started on low. i.e. normal output
	AGT0_AGTCMSR_TOPOLB_0 = 0x0
	// AGTOBn pin output is started on high. i.e. inverted output
	AGT0_AGTCMSR_TOPOLB_1 = 0x1

	// AGTIOSEL: AGT Pin Select Register
	// Position of SEL field.
	AGT0_AGTIOSEL_SEL_Pos = 0x0
	// Bit mask of SEL field.
	AGT0_AGTIOSEL_SEL_Msk = 0x3
	// Select Pm/AGTIO as AGTIO. Pm/AGTIO can not be used as AGTIO input pin in Deep Software Standby mode. (m = 100, 301, 407, and 705 (AGT0), m = 204 and 400 (AGT1), m = 103 (AGT2), m = 600(AGT3).)
	AGT0_AGTIOSEL_SEL_00 = 0x0
	// Select P404/AGTIO as AGTIO P404/AGTIO can be used as AGTIO input pin in Deep Software Standby mode. P404/AGTIOn is input only. It cannot be used for output.
	AGT0_AGTIOSEL_SEL_01 = 0x1
	// Select P402/AGTIO as AGTIO P402/AGTIO can be used as AGTIO input pin in Deep Software Standby mode. P402/AGTIOn is input only. It cannot be used for output.
	AGT0_AGTIOSEL_SEL_10 = 0x2
	// Select P403/AGTIO as AGTIO. P403/AGTIO can be used as AGTIO input pin in Deep Software Standby mode. P403/AGTIOn is input only. It cannot be used for output.
	AGT0_AGTIOSEL_SEL_11 = 0x3
	// Position of TIES field.
	AGT0_AGTIOSEL_TIES_Pos = 0x4
	// Bit mask of TIES field.
	AGT0_AGTIOSEL_TIES_Msk = 0x10
	// Bit TIES.
	AGT0_AGTIOSEL_TIES = 0x10
	// External event input is disabled during Software Standby mode
	AGT0_AGTIOSEL_TIES_0 = 0x0
	// External event input is enabled during Software Standby mode
	AGT0_AGTIOSEL_TIES_1 = 0x1
)

// Constants for CRC: Cyclic Redundancy Check Calculator
const (
	// CRCCR0: CRC Control Register 0
	// Position of GPS field.
	CRC_CRCCR0_GPS_Pos = 0x0
	// Bit mask of GPS field.
	CRC_CRCCR0_GPS_Msk = 0x7
	// 8-bit CRC-8 (X8 + X2 + X + 1)
	CRC_CRCCR0_GPS_001 = 0x1
	// 16-bit CRC-16 (X16 + X15 + X2 + 1)
	CRC_CRCCR0_GPS_010 = 0x2
	// 16-bit CRC-CCITT (X16 + X12 + X5 + 1)
	CRC_CRCCR0_GPS_011 = 0x3
	// 32-bit CRC-32 (X32 + X26 + X23 + X22 + X16 + X12 + X11 +X10 + X8 + X7 + X5 + X4 + X2 + X + 1)
	CRC_CRCCR0_GPS_100 = 0x4
	// 32-bit CRC-32C (X32 + X28 + X27 + X26 + X25 + X23 + X22 + X20 + X19 + X18 + X14 + X13 + X11 + X10 + X9 + X8 + X6 + 1)
	CRC_CRCCR0_GPS_101 = 0x5
	// Position of LMS field.
	CRC_CRCCR0_LMS_Pos = 0x6
	// Bit mask of LMS field.
	CRC_CRCCR0_LMS_Msk = 0x40
	// Bit LMS.
	CRC_CRCCR0_LMS = 0x40
	// Generate CRC code for LSB-first communication
	CRC_CRCCR0_LMS_0 = 0x0
	// Generate CRC code for MSB-first communication
	CRC_CRCCR0_LMS_1 = 0x1
	// Position of DORCLR field.
	CRC_CRCCR0_DORCLR_Pos = 0x7
	// Bit mask of DORCLR field.
	CRC_CRCCR0_DORCLR_Msk = 0x80
	// Bit DORCLR.
	CRC_CRCCR0_DORCLR = 0x80
	// No effect
	CRC_CRCCR0_DORCLR_0 = 0x0
	// Clear the CRCDOR/CRCDOR_HA/CRCDOR_BY register
	CRC_CRCCR0_DORCLR_1 = 0x1
)

// Constants for DOC: Data Operation Circuit
const (
	// DOCR: DOC Control Register
	// Position of OMS field.
	DOC_DOCR_OMS_Pos = 0x0
	// Bit mask of OMS field.
	DOC_DOCR_OMS_Msk = 0x3
	// Data comparison mode
	DOC_DOCR_OMS_00 = 0x0
	// Data addition mode
	DOC_DOCR_OMS_01 = 0x1
	// Data subtraction mode
	DOC_DOCR_OMS_10 = 0x2
	// Setting prohibited
	DOC_DOCR_OMS_11 = 0x3
	// Position of DCSEL field.
	DOC_DOCR_DCSEL_Pos = 0x2
	// Bit mask of DCSEL field.
	DOC_DOCR_DCSEL_Msk = 0x4
	// Bit DCSEL.
	DOC_DOCR_DCSEL = 0x4
	// Set DOPCF flag when data mismatch is detected
	DOC_DOCR_DCSEL_0 = 0x0
	// Set DOPCF flag when data match is detected
	DOC_DOCR_DCSEL_1 = 0x1
	// Position of DOPCF field.
	DOC_DOCR_DOPCF_Pos = 0x5
	// Bit mask of DOPCF field.
	DOC_DOCR_DOPCF_Msk = 0x20
	// Bit DOPCF.
	DOC_DOCR_DOPCF = 0x20
	// Position of DOPCFCL field.
	DOC_DOCR_DOPCFCL_Pos = 0x6
	// Bit mask of DOPCFCL field.
	DOC_DOCR_DOPCFCL_Msk = 0x40
	// Bit DOPCFCL.
	DOC_DOCR_DOPCFCL = 0x40
	// Retain DOPCF flag state
	DOC_DOCR_DOPCFCL_0 = 0x0
	// Clear DOPCF flag
	DOC_DOCR_DOPCFCL_1 = 0x1
)

// Constants for EDMAC0: DMA Controller for the Ethernet Controller Channel 0
const (
	// EDMR: EDMAC Mode Register
	// Position of SWR field.
	EDMAC0_EDMR_SWR_Pos = 0x0
	// Bit mask of SWR field.
	EDMAC0_EDMR_SWR_Msk = 0x1
	// Bit SWR.
	EDMAC0_EDMR_SWR = 0x1
	// Position of DL field.
	EDMAC0_EDMR_DL_Pos = 0x4
	// Bit mask of DL field.
	EDMAC0_EDMR_DL_Msk = 0x30
	// 16 bytes
	EDMAC0_EDMR_DL_00 = 0x0
	// 32 bytes
	EDMAC0_EDMR_DL_01 = 0x1
	// 64 bytes
	EDMAC0_EDMR_DL_10 = 0x2
	// 16 bytes.
	EDMAC0_EDMR_DL_11 = 0x3
	// Position of DE field.
	EDMAC0_EDMR_DE_Pos = 0x6
	// Bit mask of DE field.
	EDMAC0_EDMR_DE_Msk = 0x40
	// Bit DE.
	EDMAC0_EDMR_DE = 0x40
	// Big endian mode
	EDMAC0_EDMR_DE_0 = 0x0
	// Little endian mode.
	EDMAC0_EDMR_DE_1 = 0x1

	// EDTRR: EDMAC Transmit Request Register
	// Position of TR field.
	EDMAC0_EDTRR_TR_Pos = 0x0
	// Bit mask of TR field.
	EDMAC0_EDTRR_TR_Msk = 0x1
	// Bit TR.
	EDMAC0_EDTRR_TR = 0x1

	// EDRRR: EDMAC Receive Request Register
	// Position of RR field.
	EDMAC0_EDRRR_RR_Pos = 0x0
	// Bit mask of RR field.
	EDMAC0_EDRRR_RR_Msk = 0x1
	// Bit RR.
	EDMAC0_EDRRR_RR = 0x1
	// Disable the receive function
	EDMAC0_EDRRR_RR_0 = 0x0
	// Read receive descriptor and enable the receive function.
	EDMAC0_EDRRR_RR_1 = 0x1

	// EESR: ETHERC/EDMAC Status Register
	// Position of CERF field.
	EDMAC0_EESR_CERF_Pos = 0x0
	// Bit mask of CERF field.
	EDMAC0_EESR_CERF_Msk = 0x1
	// Bit CERF.
	EDMAC0_EESR_CERF = 0x1
	// CRC error not detected
	EDMAC0_EESR_CERF_0 = 0x0
	// CRC error detected.
	EDMAC0_EESR_CERF_1 = 0x1
	// Position of PRE field.
	EDMAC0_EESR_PRE_Pos = 0x1
	// Bit mask of PRE field.
	EDMAC0_EESR_PRE_Msk = 0x2
	// Bit PRE.
	EDMAC0_EESR_PRE = 0x2
	// PHY-LSI receive error not detected
	EDMAC0_EESR_PRE_0 = 0x0
	// PHY-LSI receive error detected.
	EDMAC0_EESR_PRE_1 = 0x1
	// Position of RTSF field.
	EDMAC0_EESR_RTSF_Pos = 0x2
	// Bit mask of RTSF field.
	EDMAC0_EESR_RTSF_Msk = 0x4
	// Bit RTSF.
	EDMAC0_EESR_RTSF = 0x4
	// Frame-too-short error not detected
	EDMAC0_EESR_RTSF_0 = 0x0
	// Frame-too-short error detected.
	EDMAC0_EESR_RTSF_1 = 0x1
	// Position of RTLF field.
	EDMAC0_EESR_RTLF_Pos = 0x3
	// Bit mask of RTLF field.
	EDMAC0_EESR_RTLF_Msk = 0x8
	// Bit RTLF.
	EDMAC0_EESR_RTLF = 0x8
	// Frame-too-long error not detected
	EDMAC0_EESR_RTLF_0 = 0x0
	// Frame-too-long error detected.
	EDMAC0_EESR_RTLF_1 = 0x1
	// Position of RRF field.
	EDMAC0_EESR_RRF_Pos = 0x4
	// Bit mask of RRF field.
	EDMAC0_EESR_RRF_Msk = 0x10
	// Bit RRF.
	EDMAC0_EESR_RRF = 0x10
	// Alignment error not detected
	EDMAC0_EESR_RRF_0 = 0x0
	// Alignment error detected.
	EDMAC0_EESR_RRF_1 = 0x1
	// Position of RMAF field.
	EDMAC0_EESR_RMAF_Pos = 0x7
	// Bit mask of RMAF field.
	EDMAC0_EESR_RMAF_Msk = 0x80
	// Bit RMAF.
	EDMAC0_EESR_RMAF = 0x80
	// Multicast address frame not received
	EDMAC0_EESR_RMAF_0 = 0x0
	// Multicast address frame received.
	EDMAC0_EESR_RMAF_1 = 0x1
	// Position of TRO field.
	EDMAC0_EESR_TRO_Pos = 0x8
	// Bit mask of TRO field.
	EDMAC0_EESR_TRO_Msk = 0x100
	// Bit TRO.
	EDMAC0_EESR_TRO = 0x100
	// Transmit retry-over condition not detected
	EDMAC0_EESR_TRO_0 = 0x0
	// Transmit retry-over condition detected.
	EDMAC0_EESR_TRO_1 = 0x1
	// Position of CD field.
	EDMAC0_EESR_CD_Pos = 0x9
	// Bit mask of CD field.
	EDMAC0_EESR_CD_Msk = 0x200
	// Bit CD.
	EDMAC0_EESR_CD = 0x200
	// Late collision not detected
	EDMAC0_EESR_CD_0 = 0x0
	// Late collision detected during frame transmission.
	EDMAC0_EESR_CD_1 = 0x1
	// Position of DLC field.
	EDMAC0_EESR_DLC_Pos = 0xa
	// Bit mask of DLC field.
	EDMAC0_EESR_DLC_Msk = 0x400
	// Bit DLC.
	EDMAC0_EESR_DLC = 0x400
	// Loss of carrier not detected
	EDMAC0_EESR_DLC_0 = 0x0
	// Loss of carrier detected during frame transmission.
	EDMAC0_EESR_DLC_1 = 0x1
	// Position of CND field.
	EDMAC0_EESR_CND_Pos = 0xb
	// Bit mask of CND field.
	EDMAC0_EESR_CND_Msk = 0x800
	// Bit CND.
	EDMAC0_EESR_CND = 0x800
	// Carrier detected when transmission started
	EDMAC0_EESR_CND_0 = 0x0
	// Carrier not detected during preamble transmission.
	EDMAC0_EESR_CND_1 = 0x1
	// Position of RFOF field.
	EDMAC0_EESR_RFOF_Pos = 0x10
	// Bit mask of RFOF field.
	EDMAC0_EESR_RFOF_Msk = 0x10000
	// Bit RFOF.
	EDMAC0_EESR_RFOF = 0x10000
	// No overflow occurred
	EDMAC0_EESR_RFOF_0 = 0x0
	// Overflow occurred.
	EDMAC0_EESR_RFOF_1 = 0x1
	// Position of RDE field.
	EDMAC0_EESR_RDE_Pos = 0x11
	// Bit mask of RDE field.
	EDMAC0_EESR_RDE_Msk = 0x20000
	// Bit RDE.
	EDMAC0_EESR_RDE = 0x20000
	// EDMAC detected that the receive descriptor valid bit (RD0.RACT) is 1
	EDMAC0_EESR_RDE_0 = 0x0
	// EDMAC detected that the receive descriptor valid bit (RD0.RACT) is 0.
	EDMAC0_EESR_RDE_1 = 0x1
	// Position of FR field.
	EDMAC0_EESR_FR_Pos = 0x12
	// Bit mask of FR field.
	EDMAC0_EESR_FR_Msk = 0x40000
	// Bit FR.
	EDMAC0_EESR_FR = 0x40000
	// Frame not received
	EDMAC0_EESR_FR_0 = 0x0
	// Frame received and update of the receive descriptor is complete.
	EDMAC0_EESR_FR_1 = 0x1
	// Position of TFUF field.
	EDMAC0_EESR_TFUF_Pos = 0x13
	// Bit mask of TFUF field.
	EDMAC0_EESR_TFUF_Msk = 0x80000
	// Bit TFUF.
	EDMAC0_EESR_TFUF = 0x80000
	// No underflow occurred
	EDMAC0_EESR_TFUF_0 = 0x0
	// Underflow occurred.
	EDMAC0_EESR_TFUF_1 = 0x1
	// Position of TDE field.
	EDMAC0_EESR_TDE_Pos = 0x14
	// Bit mask of TDE field.
	EDMAC0_EESR_TDE_Msk = 0x100000
	// Bit TDE.
	EDMAC0_EESR_TDE = 0x100000
	// EDMAC detected that the transmit descriptor valid bit (TD0.TACT) is 1
	EDMAC0_EESR_TDE_0 = 0x0
	// EDMAC detected that the transmit descriptor valid bit (TD0.TACT) is 0.
	EDMAC0_EESR_TDE_1 = 0x1
	// Position of TC field.
	EDMAC0_EESR_TC_Pos = 0x15
	// Bit mask of TC field.
	EDMAC0_EESR_TC_Msk = 0x200000
	// Bit TC.
	EDMAC0_EESR_TC = 0x200000
	// Transfer not complete or no transfer requested
	EDMAC0_EESR_TC_0 = 0x0
	// All frames indicated in the transmit descriptor were completely transferred to the transmit FIFO.
	EDMAC0_EESR_TC_1 = 0x1
	// Position of ECI field.
	EDMAC0_EESR_ECI_Pos = 0x16
	// Bit mask of ECI field.
	EDMAC0_EESR_ECI_Msk = 0x400000
	// Bit ECI.
	EDMAC0_EESR_ECI = 0x400000
	// ETHERC status interrupt source not detected
	EDMAC0_EESR_ECI_0 = 0x0
	// ETHERC status interrupt source detected.
	EDMAC0_EESR_ECI_1 = 0x1
	// Position of ADE field.
	EDMAC0_EESR_ADE_Pos = 0x17
	// Bit mask of ADE field.
	EDMAC0_EESR_ADE_Msk = 0x800000
	// Bit ADE.
	EDMAC0_EESR_ADE = 0x800000
	// Invalid memory address not detected (normal operation)
	EDMAC0_EESR_ADE_0 = 0x0
	// Invalid memory address detected.
	EDMAC0_EESR_ADE_1 = 0x1
	// Position of RFCOF field.
	EDMAC0_EESR_RFCOF_Pos = 0x18
	// Bit mask of RFCOF field.
	EDMAC0_EESR_RFCOF_Msk = 0x1000000
	// Bit RFCOF.
	EDMAC0_EESR_RFCOF = 0x1000000
	// Receive frame counter did not overflow
	EDMAC0_EESR_RFCOF_0 = 0x0
	// Receive frame counter overflowed.
	EDMAC0_EESR_RFCOF_1 = 0x1
	// Position of RABT field.
	EDMAC0_EESR_RABT_Pos = 0x19
	// Bit mask of RABT field.
	EDMAC0_EESR_RABT_Msk = 0x2000000
	// Bit RABT.
	EDMAC0_EESR_RABT = 0x2000000
	// Frame reception not aborted or no reception requested
	EDMAC0_EESR_RABT_0 = 0x0
	// Frame reception aborted.
	EDMAC0_EESR_RABT_1 = 0x1
	// Position of TABT field.
	EDMAC0_EESR_TABT_Pos = 0x1a
	// Bit mask of TABT field.
	EDMAC0_EESR_TABT_Msk = 0x4000000
	// Bit TABT.
	EDMAC0_EESR_TABT = 0x4000000
	// Frame transmission not aborted or no transmission requested.
	EDMAC0_EESR_TABT_0 = 0x0
	// Frame transmission aborted.
	EDMAC0_EESR_TABT_1 = 0x1
	// Position of TWB field.
	EDMAC0_EESR_TWB_Pos = 0x1e
	// Bit mask of TWB field.
	EDMAC0_EESR_TWB_Msk = 0x40000000
	// Bit TWB.
	EDMAC0_EESR_TWB = 0x40000000
	// Write-back not complete or no transmission requested
	EDMAC0_EESR_TWB_0 = 0x0
	// Write-back to the transmit descriptor completed.
	EDMAC0_EESR_TWB_1 = 0x1

	// EESIPR: ETHERC/EDMAC Status Interrupt Enable Register
	// Position of CERFIP field.
	EDMAC0_EESIPR_CERFIP_Pos = 0x0
	// Bit mask of CERFIP field.
	EDMAC0_EESIPR_CERFIP_Msk = 0x1
	// Bit CERFIP.
	EDMAC0_EESIPR_CERFIP = 0x1
	// Disable CRC error interrupt requests
	EDMAC0_EESIPR_CERFIP_0 = 0x0
	// Enable CRC error interrupt requests.
	EDMAC0_EESIPR_CERFIP_1 = 0x1
	// Position of PREIP field.
	EDMAC0_EESIPR_PREIP_Pos = 0x1
	// Bit mask of PREIP field.
	EDMAC0_EESIPR_PREIP_Msk = 0x2
	// Bit PREIP.
	EDMAC0_EESIPR_PREIP = 0x2
	// Disable PHY-LSI receive error interrupt requests
	EDMAC0_EESIPR_PREIP_0 = 0x0
	// Enable PHY-LSI receive error interrupt requests.
	EDMAC0_EESIPR_PREIP_1 = 0x1
	// Position of RTSFIP field.
	EDMAC0_EESIPR_RTSFIP_Pos = 0x2
	// Bit mask of RTSFIP field.
	EDMAC0_EESIPR_RTSFIP_Msk = 0x4
	// Bit RTSFIP.
	EDMAC0_EESIPR_RTSFIP = 0x4
	// Disable frame-too-short error interrupt requests
	EDMAC0_EESIPR_RTSFIP_0 = 0x0
	// Enable frame-too-short error interrupt requests.
	EDMAC0_EESIPR_RTSFIP_1 = 0x1
	// Position of RTLFIP field.
	EDMAC0_EESIPR_RTLFIP_Pos = 0x3
	// Bit mask of RTLFIP field.
	EDMAC0_EESIPR_RTLFIP_Msk = 0x8
	// Bit RTLFIP.
	EDMAC0_EESIPR_RTLFIP = 0x8
	// Disable frame-too-long error interrupt requests
	EDMAC0_EESIPR_RTLFIP_0 = 0x0
	// Enable frame-too-long error interrupt requests.
	EDMAC0_EESIPR_RTLFIP_1 = 0x1
	// Position of RRFIP field.
	EDMAC0_EESIPR_RRFIP_Pos = 0x4
	// Bit mask of RRFIP field.
	EDMAC0_EESIPR_RRFIP_Msk = 0x10
	// Bit RRFIP.
	EDMAC0_EESIPR_RRFIP = 0x10
	// Disable alignment error interrupt requests
	EDMAC0_EESIPR_RRFIP_0 = 0x0
	// Enable alignment error interrupt requests.
	EDMAC0_EESIPR_RRFIP_1 = 0x1
	// Position of RMAFIP field.
	EDMAC0_EESIPR_RMAFIP_Pos = 0x7
	// Bit mask of RMAFIP field.
	EDMAC0_EESIPR_RMAFIP_Msk = 0x80
	// Bit RMAFIP.
	EDMAC0_EESIPR_RMAFIP = 0x80
	// Disable multicast address frame receive interrupt requests
	EDMAC0_EESIPR_RMAFIP_0 = 0x0
	// Enable multicast address frame receive interrupt requests.
	EDMAC0_EESIPR_RMAFIP_1 = 0x1
	// Position of TROIP field.
	EDMAC0_EESIPR_TROIP_Pos = 0x8
	// Bit mask of TROIP field.
	EDMAC0_EESIPR_TROIP_Msk = 0x100
	// Bit TROIP.
	EDMAC0_EESIPR_TROIP = 0x100
	// Disable transmit retry over interrupt requests
	EDMAC0_EESIPR_TROIP_0 = 0x0
	// Enable transmit retry over interrupt requests.
	EDMAC0_EESIPR_TROIP_1 = 0x1
	// Position of CDIP field.
	EDMAC0_EESIPR_CDIP_Pos = 0x9
	// Bit mask of CDIP field.
	EDMAC0_EESIPR_CDIP_Msk = 0x200
	// Bit CDIP.
	EDMAC0_EESIPR_CDIP = 0x200
	// Disable late collision detected interrupt requests
	EDMAC0_EESIPR_CDIP_0 = 0x0
	// Enable late collision detected interrupt requests.
	EDMAC0_EESIPR_CDIP_1 = 0x1
	// Position of DLCIP field.
	EDMAC0_EESIPR_DLCIP_Pos = 0xa
	// Bit mask of DLCIP field.
	EDMAC0_EESIPR_DLCIP_Msk = 0x400
	// Bit DLCIP.
	EDMAC0_EESIPR_DLCIP = 0x400
	// Disable loss of carrier detected interrupt requests
	EDMAC0_EESIPR_DLCIP_0 = 0x0
	// Enable loss of carrier detected interrupt requests.
	EDMAC0_EESIPR_DLCIP_1 = 0x1
	// Position of CNDIP field.
	EDMAC0_EESIPR_CNDIP_Pos = 0xb
	// Bit mask of CNDIP field.
	EDMAC0_EESIPR_CNDIP_Msk = 0x800
	// Bit CNDIP.
	EDMAC0_EESIPR_CNDIP = 0x800
	// Disable carrier not detected interrupt requests
	EDMAC0_EESIPR_CNDIP_0 = 0x0
	// Enable carrier not detected interrupt requests.
	EDMAC0_EESIPR_CNDIP_1 = 0x1
	// Position of RFOFIP field.
	EDMAC0_EESIPR_RFOFIP_Pos = 0x10
	// Bit mask of RFOFIP field.
	EDMAC0_EESIPR_RFOFIP_Msk = 0x10000
	// Bit RFOFIP.
	EDMAC0_EESIPR_RFOFIP = 0x10000
	// Disable overflow interrupt requests
	EDMAC0_EESIPR_RFOFIP_0 = 0x0
	// Enable overflow interrupt requests.
	EDMAC0_EESIPR_RFOFIP_1 = 0x1
	// Position of RDEIP field.
	EDMAC0_EESIPR_RDEIP_Pos = 0x11
	// Bit mask of RDEIP field.
	EDMAC0_EESIPR_RDEIP_Msk = 0x20000
	// Bit RDEIP.
	EDMAC0_EESIPR_RDEIP = 0x20000
	// Disable receive descriptor empty interrupt requests
	EDMAC0_EESIPR_RDEIP_0 = 0x0
	// Enable receive descriptor empty interrupt requests.
	EDMAC0_EESIPR_RDEIP_1 = 0x1
	// Position of FRIP field.
	EDMAC0_EESIPR_FRIP_Pos = 0x12
	// Bit mask of FRIP field.
	EDMAC0_EESIPR_FRIP_Msk = 0x40000
	// Bit FRIP.
	EDMAC0_EESIPR_FRIP = 0x40000
	// Disable frame reception interrupt requests
	EDMAC0_EESIPR_FRIP_0 = 0x0
	// Enable frame reception interrupt requests.
	EDMAC0_EESIPR_FRIP_1 = 0x1
	// Position of TFUFIP field.
	EDMAC0_EESIPR_TFUFIP_Pos = 0x13
	// Bit mask of TFUFIP field.
	EDMAC0_EESIPR_TFUFIP_Msk = 0x80000
	// Bit TFUFIP.
	EDMAC0_EESIPR_TFUFIP = 0x80000
	// Disable underflow interrupt requests
	EDMAC0_EESIPR_TFUFIP_0 = 0x0
	// Enable underflow interrupt requests.
	EDMAC0_EESIPR_TFUFIP_1 = 0x1
	// Position of TDEIP field.
	EDMAC0_EESIPR_TDEIP_Pos = 0x14
	// Bit mask of TDEIP field.
	EDMAC0_EESIPR_TDEIP_Msk = 0x100000
	// Bit TDEIP.
	EDMAC0_EESIPR_TDEIP = 0x100000
	// Disable transmit descriptor empty interrupt requests
	EDMAC0_EESIPR_TDEIP_0 = 0x0
	// Enable transmit descriptor empty interrupt requests.
	EDMAC0_EESIPR_TDEIP_1 = 0x1
	// Position of TCIP field.
	EDMAC0_EESIPR_TCIP_Pos = 0x15
	// Bit mask of TCIP field.
	EDMAC0_EESIPR_TCIP_Msk = 0x200000
	// Bit TCIP.
	EDMAC0_EESIPR_TCIP = 0x200000
	// Disable frame transmission complete interrupt requests
	EDMAC0_EESIPR_TCIP_0 = 0x0
	// Enable frame transmission complete interrupt requests.
	EDMAC0_EESIPR_TCIP_1 = 0x1
	// Position of ECIIP field.
	EDMAC0_EESIPR_ECIIP_Pos = 0x16
	// Bit mask of ECIIP field.
	EDMAC0_EESIPR_ECIIP_Msk = 0x400000
	// Bit ECIIP.
	EDMAC0_EESIPR_ECIIP = 0x400000
	// Disable ETHERC status interrupt requests
	EDMAC0_EESIPR_ECIIP_0 = 0x0
	// Enable ETHERC status interrupt requests.
	EDMAC0_EESIPR_ECIIP_1 = 0x1
	// Position of ADEIP field.
	EDMAC0_EESIPR_ADEIP_Pos = 0x17
	// Bit mask of ADEIP field.
	EDMAC0_EESIPR_ADEIP_Msk = 0x800000
	// Bit ADEIP.
	EDMAC0_EESIPR_ADEIP = 0x800000
	// Disable address error interrupt requests
	EDMAC0_EESIPR_ADEIP_0 = 0x0
	// Enable address error interrupt requests.
	EDMAC0_EESIPR_ADEIP_1 = 0x1
	// Position of RFCOFIP field.
	EDMAC0_EESIPR_RFCOFIP_Pos = 0x18
	// Bit mask of RFCOFIP field.
	EDMAC0_EESIPR_RFCOFIP_Msk = 0x1000000
	// Bit RFCOFIP.
	EDMAC0_EESIPR_RFCOFIP = 0x1000000
	// Disable receive frame counter overflow interrupt requests
	EDMAC0_EESIPR_RFCOFIP_0 = 0x0
	// Enable receive frame counter overflow interrupt requests.
	EDMAC0_EESIPR_RFCOFIP_1 = 0x1
	// Position of RABTIP field.
	EDMAC0_EESIPR_RABTIP_Pos = 0x19
	// Bit mask of RABTIP field.
	EDMAC0_EESIPR_RABTIP_Msk = 0x2000000
	// Bit RABTIP.
	EDMAC0_EESIPR_RABTIP = 0x2000000
	// Disable receive abort detected interrupt requests
	EDMAC0_EESIPR_RABTIP_0 = 0x0
	// Enable receive abort detected interrupt requests.
	EDMAC0_EESIPR_RABTIP_1 = 0x1
	// Position of TABTIP field.
	EDMAC0_EESIPR_TABTIP_Pos = 0x1a
	// Bit mask of TABTIP field.
	EDMAC0_EESIPR_TABTIP_Msk = 0x4000000
	// Bit TABTIP.
	EDMAC0_EESIPR_TABTIP = 0x4000000
	// Disable transmit abort detected interrupt requests
	EDMAC0_EESIPR_TABTIP_0 = 0x0
	// Enable transmit abort detected interrupt requests.
	EDMAC0_EESIPR_TABTIP_1 = 0x1
	// Position of TWBIP field.
	EDMAC0_EESIPR_TWBIP_Pos = 0x1e
	// Bit mask of TWBIP field.
	EDMAC0_EESIPR_TWBIP_Msk = 0x40000000
	// Bit TWBIP.
	EDMAC0_EESIPR_TWBIP = 0x40000000
	// Disable write-back complete interrupt requests
	EDMAC0_EESIPR_TWBIP_0 = 0x0
	// Enable write-back complete interrupt requests.
	EDMAC0_EESIPR_TWBIP_1 = 0x1

	// TRSCER: ETHERC/EDMAC Transmit/Receive Status Copy Enable Register
	// Position of RRFCE field.
	EDMAC0_TRSCER_RRFCE_Pos = 0x4
	// Bit mask of RRFCE field.
	EDMAC0_TRSCER_RRFCE_Msk = 0x10
	// Bit RRFCE.
	EDMAC0_TRSCER_RRFCE = 0x10
	// Reflect the EESR.RRF flag status in the RD0.RFE bit of the receive descriptor
	EDMAC0_TRSCER_RRFCE_0 = 0x0
	// Do not reflect the EESR.RRF flag status in the RD0.RFE bit of the receive descriptor.
	EDMAC0_TRSCER_RRFCE_1 = 0x1
	// Position of RMAFCE field.
	EDMAC0_TRSCER_RMAFCE_Pos = 0x7
	// Bit mask of RMAFCE field.
	EDMAC0_TRSCER_RMAFCE_Msk = 0x80
	// Bit RMAFCE.
	EDMAC0_TRSCER_RMAFCE = 0x80
	// Reflect the EESR.RMAF flag status in the RD0.RFE bit of the receive descriptor
	EDMAC0_TRSCER_RMAFCE_0 = 0x0
	// Do not reflect the EESR.RMAF flag status in the RD0.RFE bit of the receive descriptor.
	EDMAC0_TRSCER_RMAFCE_1 = 0x1

	// RMFCR: Missed-Frame Counter Register
	// Position of MFC field.
	EDMAC0_RMFCR_MFC_Pos = 0x0
	// Bit mask of MFC field.
	EDMAC0_RMFCR_MFC_Msk = 0xffff

	// TFTR: Transmit FIFO Threshold Register
	// Position of TFT field.
	EDMAC0_TFTR_TFT_Pos = 0x0
	// Bit mask of TFT field.
	EDMAC0_TFTR_TFT_Msk = 0x7ff

	// FDR: FIFO Depth Register
	// Position of RFD field.
	EDMAC0_FDR_RFD_Pos = 0x0
	// Bit mask of RFD field.
	EDMAC0_FDR_RFD_Msk = 0x1f
	// 4096 bytes
	EDMAC0_FDR_RFD_0x0F = 0xf
	// Position of TFD field.
	EDMAC0_FDR_TFD_Pos = 0x8
	// Bit mask of TFD field.
	EDMAC0_FDR_TFD_Msk = 0x1f00
	// 2048 bytes
	EDMAC0_FDR_TFD_0x07 = 0x7

	// RMCR: Receive Method Control Register
	// Position of RNR field.
	EDMAC0_RMCR_RNR_Pos = 0x0
	// Bit mask of RNR field.
	EDMAC0_RMCR_RNR_Msk = 0x1
	// Bit RNR.
	EDMAC0_RMCR_RNR = 0x1
	// EDRRR.RR bit (receive request bit) is cleared to 0 when one frame is received
	EDMAC0_RMCR_RNR_0 = 0x0
	// EDRRR.RR bit (receive request bit) is not cleared to 0 when one frame is received.
	EDMAC0_RMCR_RNR_1 = 0x1

	// TFUCR: Transmit FIFO Underflow Counter
	// Position of UNDER field.
	EDMAC0_TFUCR_UNDER_Pos = 0x0
	// Bit mask of UNDER field.
	EDMAC0_TFUCR_UNDER_Msk = 0xffff

	// RFOCR: Receive FIFO Overflow Counter
	// Position of OVER field.
	EDMAC0_RFOCR_OVER_Pos = 0x0
	// Bit mask of OVER field.
	EDMAC0_RFOCR_OVER_Msk = 0xffff

	// IOSR: Independent Output Signal Setting Register
	// Position of ELB field.
	EDMAC0_IOSR_ELB_Pos = 0x0
	// Bit mask of ELB field.
	EDMAC0_IOSR_ELB_Msk = 0x1
	// Bit ELB.
	EDMAC0_IOSR_ELB = 0x1
	// Output low on the ET0_EXOUT pin
	EDMAC0_IOSR_ELB_0 = 0x0
	// Output high on the ET0_EXOUT pin.
	EDMAC0_IOSR_ELB_1 = 0x1

	// FCFTR: Flow Control Start FIFO Threshold Setting Register
	// Position of RFDO field.
	EDMAC0_FCFTR_RFDO_Pos = 0x0
	// Bit mask of RFDO field.
	EDMAC0_FCFTR_RFDO_Msk = 0x7
	// Position of RFFO field.
	EDMAC0_FCFTR_RFFO_Pos = 0x10
	// Bit mask of RFFO field.
	EDMAC0_FCFTR_RFFO_Msk = 0x70000

	// RPADIR: Receive Data Padding Insert Register
	// Position of PADR field.
	EDMAC0_RPADIR_PADR_Pos = 0x0
	// Bit mask of PADR field.
	EDMAC0_RPADIR_PADR_Msk = 0x3f
	// Position of PADS field.
	EDMAC0_RPADIR_PADS_Pos = 0x10
	// Bit mask of PADS field.
	EDMAC0_RPADIR_PADS_Msk = 0x30000
	// Do not insert padding
	EDMAC0_RPADIR_PADS_00 = 0x0

	// TRIMD: Transmit Interrupt Setting Register
	// Position of TIS field.
	EDMAC0_TRIMD_TIS_Pos = 0x0
	// Bit mask of TIS field.
	EDMAC0_TRIMD_TIS_Msk = 0x1
	// Bit TIS.
	EDMAC0_TRIMD_TIS = 0x1
	// Disable transmit interrupts
	EDMAC0_TRIMD_TIS_0 = 0x0
	// Enable transmit Interrupts.
	EDMAC0_TRIMD_TIS_1 = 0x1
	// Position of TIM field.
	EDMAC0_TRIMD_TIM_Pos = 0x4
	// Bit mask of TIM field.
	EDMAC0_TRIMD_TIM_Msk = 0x10
	// Bit TIM.
	EDMAC0_TRIMD_TIM = 0x10
	// Select transmission complete interrupt mode, where an interrupt occurs when a frame is transmitted
	EDMAC0_TRIMD_TIM_0 = 0x0
	// Select write-back complete interrupt mode, where an interrupt occurs when write-back to the transmit descriptor is complete while the TWBI bit is 1.
	EDMAC0_TRIMD_TIM_1 = 0x1
)

// Constants for ETHERC0: Ethernet Controller Channel 0
const (
	// ECMR: ETHERC Mode Register
	// Position of PRM field.
	ETHERC0_ECMR_PRM_Pos = 0x0
	// Bit mask of PRM field.
	ETHERC0_ECMR_PRM_Msk = 0x1
	// Bit PRM.
	ETHERC0_ECMR_PRM = 0x1
	// Disable promiscuous mode
	ETHERC0_ECMR_PRM_0 = 0x0
	// Enable promiscuous mode.
	ETHERC0_ECMR_PRM_1 = 0x1
	// Position of DM field.
	ETHERC0_ECMR_DM_Pos = 0x1
	// Bit mask of DM field.
	ETHERC0_ECMR_DM_Msk = 0x2
	// Bit DM.
	ETHERC0_ECMR_DM = 0x2
	// Half-duplex mode
	ETHERC0_ECMR_DM_0 = 0x0
	// Full-duplex mode.
	ETHERC0_ECMR_DM_1 = 0x1
	// Position of RTM field.
	ETHERC0_ECMR_RTM_Pos = 0x2
	// Bit mask of RTM field.
	ETHERC0_ECMR_RTM_Msk = 0x4
	// Bit RTM.
	ETHERC0_ECMR_RTM = 0x4
	// 10 Mbps
	ETHERC0_ECMR_RTM_0 = 0x0
	// 100 Mbps.
	ETHERC0_ECMR_RTM_1 = 0x1
	// Position of ILB field.
	ETHERC0_ECMR_ILB_Pos = 0x3
	// Bit mask of ILB field.
	ETHERC0_ECMR_ILB_Msk = 0x8
	// Bit ILB.
	ETHERC0_ECMR_ILB = 0x8
	// Perform normal data transmission or reception
	ETHERC0_ECMR_ILB_0 = 0x0
	// Loop data back in the ETHERC when full-duplex mode is selected.
	ETHERC0_ECMR_ILB_1 = 0x1
	// Position of TE field.
	ETHERC0_ECMR_TE_Pos = 0x5
	// Bit mask of TE field.
	ETHERC0_ECMR_TE_Msk = 0x20
	// Bit TE.
	ETHERC0_ECMR_TE = 0x20
	// Disable transmit function
	ETHERC0_ECMR_TE_0 = 0x0
	// Enable transmit function.
	ETHERC0_ECMR_TE_1 = 0x1
	// Position of RE field.
	ETHERC0_ECMR_RE_Pos = 0x6
	// Bit mask of RE field.
	ETHERC0_ECMR_RE_Msk = 0x40
	// Bit RE.
	ETHERC0_ECMR_RE = 0x40
	// Disable receive function
	ETHERC0_ECMR_RE_0 = 0x0
	// Enable receive function.
	ETHERC0_ECMR_RE_1 = 0x1
	// Position of MPDE field.
	ETHERC0_ECMR_MPDE_Pos = 0x9
	// Bit mask of MPDE field.
	ETHERC0_ECMR_MPDE_Msk = 0x200
	// Bit MPDE.
	ETHERC0_ECMR_MPDE = 0x200
	// Disable Magic Packet detection
	ETHERC0_ECMR_MPDE_0 = 0x0
	// Enable Magic Packet detection.
	ETHERC0_ECMR_MPDE_1 = 0x1
	// Position of PRCEF field.
	ETHERC0_ECMR_PRCEF_Pos = 0xc
	// Bit mask of PRCEF field.
	ETHERC0_ECMR_PRCEF_Msk = 0x1000
	// Bit PRCEF.
	ETHERC0_ECMR_PRCEF = 0x1000
	// Notify EDMAC of a CRC error
	ETHERC0_ECMR_PRCEF_0 = 0x0
	// Do not notify EDMAC of a CRC error.
	ETHERC0_ECMR_PRCEF_1 = 0x1
	// Position of TXF field.
	ETHERC0_ECMR_TXF_Pos = 0x10
	// Bit mask of TXF field.
	ETHERC0_ECMR_TXF_Msk = 0x10000
	// Bit TXF.
	ETHERC0_ECMR_TXF = 0x10000
	// Disable automatic PAUSE frame transmission (PAUSE frame is not automatically transmitted)
	ETHERC0_ECMR_TXF_0 = 0x0
	// Enable automatic PAUSE frame transmission (PAUSE frame is automatically transmitted as required).
	ETHERC0_ECMR_TXF_1 = 0x1
	// Position of RXF field.
	ETHERC0_ECMR_RXF_Pos = 0x11
	// Bit mask of RXF field.
	ETHERC0_ECMR_RXF_Msk = 0x20000
	// Bit RXF.
	ETHERC0_ECMR_RXF = 0x20000
	// Disable PAUSE frame detection
	ETHERC0_ECMR_RXF_0 = 0x0
	// Enable PAUSE frame detection.
	ETHERC0_ECMR_RXF_1 = 0x1
	// Position of PFR field.
	ETHERC0_ECMR_PFR_Pos = 0x12
	// Bit mask of PFR field.
	ETHERC0_ECMR_PFR_Msk = 0x40000
	// Bit PFR.
	ETHERC0_ECMR_PFR = 0x40000
	// Do not transfer PAUSE frame to the EDMAC
	ETHERC0_ECMR_PFR_0 = 0x0
	// Transfer PAUSE frame to the EDMAC.
	ETHERC0_ECMR_PFR_1 = 0x1
	// Position of ZPF field.
	ETHERC0_ECMR_ZPF_Pos = 0x13
	// Bit mask of ZPF field.
	ETHERC0_ECMR_ZPF_Msk = 0x80000
	// Bit ZPF.
	ETHERC0_ECMR_ZPF = 0x80000
	// Do not use PAUSE frames that containing a pause_time parameter of 0
	ETHERC0_ECMR_ZPF_0 = 0x0
	// Use PAUSE frames that containing a pause_time parameter of 0.
	ETHERC0_ECMR_ZPF_1 = 0x1
	// Position of TPC field.
	ETHERC0_ECMR_TPC_Pos = 0x14
	// Bit mask of TPC field.
	ETHERC0_ECMR_TPC_Msk = 0x100000
	// Bit TPC.
	ETHERC0_ECMR_TPC = 0x100000
	// Transmit PAUSE frame even during a PAUSE period
	ETHERC0_ECMR_TPC_0 = 0x0
	// Do not transmit PAUSE frame during a PAUSE period.
	ETHERC0_ECMR_TPC_1 = 0x1

	// RFLR: Receive Frame Maximum Length Register
	// Position of RFL field.
	ETHERC0_RFLR_RFL_Pos = 0x0
	// Bit mask of RFL field.
	ETHERC0_RFLR_RFL_Msk = 0xfff

	// ECSR: ETHERC Status Register
	// Position of ICD field.
	ETHERC0_ECSR_ICD_Pos = 0x0
	// Bit mask of ICD field.
	ETHERC0_ECSR_ICD_Msk = 0x1
	// Bit ICD.
	ETHERC0_ECSR_ICD = 0x1
	// PHY-LSI has not detected a false carrier on the line
	ETHERC0_ECSR_ICD_0 = 0x0
	// PHY-LSI detected a false carrier on the line.
	ETHERC0_ECSR_ICD_1 = 0x1
	// Position of MPD field.
	ETHERC0_ECSR_MPD_Pos = 0x1
	// Bit mask of MPD field.
	ETHERC0_ECSR_MPD_Msk = 0x2
	// Bit MPD.
	ETHERC0_ECSR_MPD = 0x2
	// Magic Packet not detected
	ETHERC0_ECSR_MPD_0 = 0x0
	// Magic Packet detected.
	ETHERC0_ECSR_MPD_1 = 0x1
	// Position of LCHNG field.
	ETHERC0_ECSR_LCHNG_Pos = 0x2
	// Bit mask of LCHNG field.
	ETHERC0_ECSR_LCHNG_Msk = 0x4
	// Bit LCHNG.
	ETHERC0_ECSR_LCHNG = 0x4
	// Change in the ET0_LINKSTA signal not detected
	ETHERC0_ECSR_LCHNG_0 = 0x0
	// Change in the ET0_LINKSTA signal detected (high to low, or low to high).
	ETHERC0_ECSR_LCHNG_1 = 0x1
	// Position of PSRTO field.
	ETHERC0_ECSR_PSRTO_Pos = 0x4
	// Bit mask of PSRTO field.
	ETHERC0_ECSR_PSRTO_Msk = 0x10
	// Bit PSRTO.
	ETHERC0_ECSR_PSRTO = 0x10
	// PAUSE frame retransmit count has not reached the upper limit
	ETHERC0_ECSR_PSRTO_0 = 0x0
	// PAUSE frame retransmit count reached the upper limit.
	ETHERC0_ECSR_PSRTO_1 = 0x1
	// Position of BFR field.
	ETHERC0_ECSR_BFR_Pos = 0x5
	// Bit mask of BFR field.
	ETHERC0_ECSR_BFR_Msk = 0x20
	// Bit BFR.
	ETHERC0_ECSR_BFR = 0x20
	// Continuous reception of broadcast frames not detected
	ETHERC0_ECSR_BFR_0 = 0x0
	// Continuous reception of broadcast frames detected.
	ETHERC0_ECSR_BFR_1 = 0x1

	// ECSIPR: ETHERC Interrupt Enable Register
	// Position of ICDIP field.
	ETHERC0_ECSIPR_ICDIP_Pos = 0x0
	// Bit mask of ICDIP field.
	ETHERC0_ECSIPR_ICDIP_Msk = 0x1
	// Bit ICDIP.
	ETHERC0_ECSIPR_ICDIP = 0x1
	// Disable interrupt notification
	ETHERC0_ECSIPR_ICDIP_0 = 0x0
	// Enable interrupt notification.
	ETHERC0_ECSIPR_ICDIP_1 = 0x1
	// Position of MPDIP field.
	ETHERC0_ECSIPR_MPDIP_Pos = 0x1
	// Bit mask of MPDIP field.
	ETHERC0_ECSIPR_MPDIP_Msk = 0x2
	// Bit MPDIP.
	ETHERC0_ECSIPR_MPDIP = 0x2
	// Disable interrupt notification
	ETHERC0_ECSIPR_MPDIP_0 = 0x0
	// Enable interrupt notification.
	ETHERC0_ECSIPR_MPDIP_1 = 0x1
	// Position of LCHNGIP field.
	ETHERC0_ECSIPR_LCHNGIP_Pos = 0x2
	// Bit mask of LCHNGIP field.
	ETHERC0_ECSIPR_LCHNGIP_Msk = 0x4
	// Bit LCHNGIP.
	ETHERC0_ECSIPR_LCHNGIP = 0x4
	// Disable interrupt notification
	ETHERC0_ECSIPR_LCHNGIP_0 = 0x0
	// Enable interrupt notification.
	ETHERC0_ECSIPR_LCHNGIP_1 = 0x1
	// Position of PSRTOIP field.
	ETHERC0_ECSIPR_PSRTOIP_Pos = 0x4
	// Bit mask of PSRTOIP field.
	ETHERC0_ECSIPR_PSRTOIP_Msk = 0x10
	// Bit PSRTOIP.
	ETHERC0_ECSIPR_PSRTOIP = 0x10
	// Disable interrupt notification
	ETHERC0_ECSIPR_PSRTOIP_0 = 0x0
	// Enable interrupt notification.
	ETHERC0_ECSIPR_PSRTOIP_1 = 0x1
	// Position of BFSIPR field.
	ETHERC0_ECSIPR_BFSIPR_Pos = 0x5
	// Bit mask of BFSIPR field.
	ETHERC0_ECSIPR_BFSIPR_Msk = 0x20
	// Bit BFSIPR.
	ETHERC0_ECSIPR_BFSIPR = 0x20
	// Disable interrupt notification
	ETHERC0_ECSIPR_BFSIPR_0 = 0x0
	// Enable interrupt notification.
	ETHERC0_ECSIPR_BFSIPR_1 = 0x1

	// PIR: PHY Interface Register
	// Position of MDC field.
	ETHERC0_PIR_MDC_Pos = 0x0
	// Bit mask of MDC field.
	ETHERC0_PIR_MDC_Msk = 0x1
	// Bit MDC.
	ETHERC0_PIR_MDC = 0x1
	// Position of MMD field.
	ETHERC0_PIR_MMD_Pos = 0x1
	// Bit mask of MMD field.
	ETHERC0_PIR_MMD_Msk = 0x2
	// Bit MMD.
	ETHERC0_PIR_MMD = 0x2
	// Read
	ETHERC0_PIR_MMD_0 = 0x0
	// Write.
	ETHERC0_PIR_MMD_1 = 0x1
	// Position of MDO field.
	ETHERC0_PIR_MDO_Pos = 0x2
	// Bit mask of MDO field.
	ETHERC0_PIR_MDO_Msk = 0x4
	// Bit MDO.
	ETHERC0_PIR_MDO = 0x4
	// Position of MDI field.
	ETHERC0_PIR_MDI_Pos = 0x3
	// Bit mask of MDI field.
	ETHERC0_PIR_MDI_Msk = 0x8
	// Bit MDI.
	ETHERC0_PIR_MDI = 0x8

	// PSR: PHY Status Register
	// Position of LMON field.
	ETHERC0_PSR_LMON_Pos = 0x0
	// Bit mask of LMON field.
	ETHERC0_PSR_LMON_Msk = 0x1
	// Bit LMON.
	ETHERC0_PSR_LMON = 0x1

	// RDMLR: Random Number Generation Counter Upper Limit Setting Register
	// Position of RMD field.
	ETHERC0_RDMLR_RMD_Pos = 0x0
	// Bit mask of RMD field.
	ETHERC0_RDMLR_RMD_Msk = 0xfffff

	// IPGR: Interpacket Gap Register
	// Position of IPG field.
	ETHERC0_IPGR_IPG_Pos = 0x0
	// Bit mask of IPG field.
	ETHERC0_IPGR_IPG_Msk = 0x1f

	// APR: Automatic PAUSE Frame Register
	// Position of AP field.
	ETHERC0_APR_AP_Pos = 0x0
	// Bit mask of AP field.
	ETHERC0_APR_AP_Msk = 0xffff

	// MPR: Manual PAUSE Frame Register
	// Position of MP field.
	ETHERC0_MPR_MP_Pos = 0x0
	// Bit mask of MP field.
	ETHERC0_MPR_MP_Msk = 0xffff

	// RFCF: Received PAUSE Frame Counter
	// Position of RPAUSE field.
	ETHERC0_RFCF_RPAUSE_Pos = 0x0
	// Bit mask of RPAUSE field.
	ETHERC0_RFCF_RPAUSE_Msk = 0xff

	// TPAUSER: PAUSE Frame Retransmit Count Setting Register
	// Position of TPAUSE field.
	ETHERC0_TPAUSER_TPAUSE_Pos = 0x0
	// Bit mask of TPAUSE field.
	ETHERC0_TPAUSER_TPAUSE_Msk = 0xffff

	// TPAUSECR: PAUSE Frame Retransmit Counter
	// Position of TXP field.
	ETHERC0_TPAUSECR_TXP_Pos = 0x0
	// Bit mask of TXP field.
	ETHERC0_TPAUSECR_TXP_Msk = 0xff

	// BCFRR: Broadcast Frame Receive Count Setting Register
	// Position of BCF field.
	ETHERC0_BCFRR_BCF_Pos = 0x0
	// Bit mask of BCF field.
	ETHERC0_BCFRR_BCF_Msk = 0xffff

	// MAHR: MAC Address Upper Bit Register
	// Position of MAHR field.
	ETHERC0_MAHR_MAHR_Pos = 0x0
	// Bit mask of MAHR field.
	ETHERC0_MAHR_MAHR_Msk = 0xffffffff

	// MALR: MAC Address Lower Bit Register
	// Position of MALR field.
	ETHERC0_MALR_MALR_Pos = 0x0
	// Bit mask of MALR field.
	ETHERC0_MALR_MALR_Msk = 0xffff

	// TROCR: Transmit Retry Over Counter Register
	// Position of TROCR field.
	ETHERC0_TROCR_TROCR_Pos = 0x0
	// Bit mask of TROCR field.
	ETHERC0_TROCR_TROCR_Msk = 0xffffffff

	// CDCR: Late Collision Detect Counter Register
	// Position of CDCR field.
	ETHERC0_CDCR_CDCR_Pos = 0x0
	// Bit mask of CDCR field.
	ETHERC0_CDCR_CDCR_Msk = 0xffffffff

	// LCCR: Lost Carrier Counter Register
	// Position of LCCR field.
	ETHERC0_LCCR_LCCR_Pos = 0x0
	// Bit mask of LCCR field.
	ETHERC0_LCCR_LCCR_Msk = 0xffffffff

	// CNDCR: Carrier Not Detect Counter Register
	// Position of CNDCR field.
	ETHERC0_CNDCR_CNDCR_Pos = 0x0
	// Bit mask of CNDCR field.
	ETHERC0_CNDCR_CNDCR_Msk = 0xffffffff

	// CEFCR: CRC Error Frame Receive Counter Register
	// Position of CEFCR field.
	ETHERC0_CEFCR_CEFCR_Pos = 0x0
	// Bit mask of CEFCR field.
	ETHERC0_CEFCR_CEFCR_Msk = 0xffffffff

	// TSFRCR: Too-Short Frame Receive Counter Register
	// Position of TSFRCR field.
	ETHERC0_TSFRCR_TSFRCR_Pos = 0x0
	// Bit mask of TSFRCR field.
	ETHERC0_TSFRCR_TSFRCR_Msk = 0xffffffff

	// TLFRCR: Too-Long Frame Receive Counter Register
	// Position of TLFRCR field.
	ETHERC0_TLFRCR_TLFRCR_Pos = 0x0
	// Bit mask of TLFRCR field.
	ETHERC0_TLFRCR_TLFRCR_Msk = 0xffffffff

	// RFCR: Received Alignment Error Frame Counter Register
	// Position of RFCR field.
	ETHERC0_RFCR_RFCR_Pos = 0x0
	// Bit mask of RFCR field.
	ETHERC0_RFCR_RFCR_Msk = 0xffffffff

	// MAFCR: Multicast Address Frame Receive Counter Register
	// Position of MAFCR field.
	ETHERC0_MAFCR_MAFCR_Pos = 0x0
	// Bit mask of MAFCR field.
	ETHERC0_MAFCR_MAFCR_Msk = 0xffffffff
)

// Constants for SCI0: Serial Communication Interface
const (
	// SMR: Serial Mode Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
	// Position of CKS field.
	SCI0_SMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI0_SMR_CKS_Msk = 0x3
	// PCLK clock (n = 0)
	SCI0_SMR_CKS_00 = 0x0
	// PCLK/4 clock (n = 1)
	SCI0_SMR_CKS_01 = 0x1
	// PCLK/16 clock (n = 2)
	SCI0_SMR_CKS_10 = 0x2
	// PCLK/64 clock (n = 3)
	SCI0_SMR_CKS_11 = 0x3
	// Position of MP field.
	SCI0_SMR_MP_Pos = 0x2
	// Bit mask of MP field.
	SCI0_SMR_MP_Msk = 0x4
	// Bit MP.
	SCI0_SMR_MP = 0x4
	// Disable multi-processor communications function
	SCI0_SMR_MP_0 = 0x0
	// Enable multi-processor communications function
	SCI0_SMR_MP_1 = 0x1
	// Position of STOP field.
	SCI0_SMR_STOP_Pos = 0x3
	// Bit mask of STOP field.
	SCI0_SMR_STOP_Msk = 0x8
	// Bit STOP.
	SCI0_SMR_STOP = 0x8
	// 1 stop bit
	SCI0_SMR_STOP_0 = 0x0
	// 2 stop bits
	SCI0_SMR_STOP_1 = 0x1
	// Position of PM field.
	SCI0_SMR_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI0_SMR_PM_Msk = 0x10
	// Bit PM.
	SCI0_SMR_PM = 0x10
	// Even parity
	SCI0_SMR_PM_0 = 0x0
	// Odd parity
	SCI0_SMR_PM_1 = 0x1
	// Position of PE field.
	SCI0_SMR_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI0_SMR_PE_Msk = 0x20
	// Bit PE.
	SCI0_SMR_PE = 0x20
	// When transmitting: Do not add parity bit When receiving: Do not check parity bit
	SCI0_SMR_PE_0 = 0x0
	// When transmitting: Add parity bit When receiving: Check parity bit
	SCI0_SMR_PE_1 = 0x1
	// Position of CHR field.
	SCI0_SMR_CHR_Pos = 0x6
	// Bit mask of CHR field.
	SCI0_SMR_CHR_Msk = 0x40
	// Bit CHR.
	SCI0_SMR_CHR = 0x40
	// SCMR.CHR1 = 0: Transmit/receive in 9-bit data length SCMR.CHR1 = 1: Transmit/receive in 8-bit data length (initial value)
	SCI0_SMR_CHR_0 = 0x0
	// SCMR.CHR1 = 0: Transmit/receive in 9-bit data length SCMR.CHR1 = 1: Transmit/receive in 7-bit data length
	SCI0_SMR_CHR_1 = 0x1
	// Position of CM field.
	SCI0_SMR_CM_Pos = 0x7
	// Bit mask of CM field.
	SCI0_SMR_CM_Msk = 0x80
	// Bit CM.
	SCI0_SMR_CM = 0x80
	// Asynchronous mode or simple IIC mode
	SCI0_SMR_CM_0 = 0x0
	// Clock synchronous mode or simple SPI mode
	SCI0_SMR_CM_1 = 0x1

	// SMR_SMCI: Serial Mode Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of CKS field.
	SCI0_SMR_SMCI_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI0_SMR_SMCI_CKS_Msk = 0x3
	// PCLK clock (n = 0)
	SCI0_SMR_SMCI_CKS_00 = 0x0
	// PCLK/4 clock (n = 1)
	SCI0_SMR_SMCI_CKS_01 = 0x1
	// PCLK/16 clock (n = 2)
	SCI0_SMR_SMCI_CKS_10 = 0x2
	// PCLK/64 clock (n = 3)
	SCI0_SMR_SMCI_CKS_11 = 0x3
	// Position of BCP field.
	SCI0_SMR_SMCI_BCP_Pos = 0x2
	// Bit mask of BCP field.
	SCI0_SMR_SMCI_BCP_Msk = 0xc
	// Position of PM field.
	SCI0_SMR_SMCI_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI0_SMR_SMCI_PM_Msk = 0x10
	// Bit PM.
	SCI0_SMR_SMCI_PM = 0x10
	// Even parity
	SCI0_SMR_SMCI_PM_0 = 0x0
	// Odd parity
	SCI0_SMR_SMCI_PM_1 = 0x1
	// Position of PE field.
	SCI0_SMR_SMCI_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI0_SMR_SMCI_PE_Msk = 0x20
	// Bit PE.
	SCI0_SMR_SMCI_PE = 0x20
	// Position of BLK field.
	SCI0_SMR_SMCI_BLK_Pos = 0x6
	// Bit mask of BLK field.
	SCI0_SMR_SMCI_BLK_Msk = 0x40
	// Bit BLK.
	SCI0_SMR_SMCI_BLK = 0x40
	// Normal mode operation
	SCI0_SMR_SMCI_BLK_0 = 0x0
	// Block transfer mode operation
	SCI0_SMR_SMCI_BLK_1 = 0x1
	// Position of GM field.
	SCI0_SMR_SMCI_GM_Pos = 0x7
	// Bit mask of GM field.
	SCI0_SMR_SMCI_GM_Msk = 0x80
	// Bit GM.
	SCI0_SMR_SMCI_GM = 0x80
	// Normal mode operation
	SCI0_SMR_SMCI_GM_0 = 0x0
	// GSM mode operation
	SCI0_SMR_SMCI_GM_1 = 0x1

	// SCR: Serial Control Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
	// Position of CKE field.
	SCI0_SCR_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI0_SCR_CKE_Msk = 0x3
	// In asynchronous mode, the SCKn pin is available for use as an I/O port based on the I/O port settings. In clock synchronous mode, the SCKn pin functions as the clock output pin.
	SCI0_SCR_CKE_00 = 0x0
	// In asynchronous mode, a clock with the same frequency as the bit rate is output from the SCKn pin. In clock synchronous mode, the SCKn pin functions as the clock output pin.
	SCI0_SCR_CKE_01 = 0x1
	// Position of TEIE field.
	SCI0_SCR_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI0_SCR_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI0_SCR_TEIE = 0x4
	// Disable SCIn_TEI interrupt requests
	SCI0_SCR_TEIE_0 = 0x0
	// Enable SCIn_TEI interrupt requests
	SCI0_SCR_TEIE_1 = 0x1
	// Position of MPIE field.
	SCI0_SCR_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI0_SCR_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI0_SCR_MPIE = 0x8
	// Normal reception
	SCI0_SCR_MPIE_0 = 0x0
	// When data with the multi-processor bit set to 0 is received, the data is not read, and setting the status flags RDRF, ORER, and FER in SSR to 1 and the status flags SYER, PFER, and SBER in MESR are disabled. When data with the multi-processor bit set to 1 is received, the MPIE bit is automatically set to 0, and normal reception is resumed.
	SCI0_SCR_MPIE_1 = 0x1
	// Position of RE field.
	SCI0_SCR_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI0_SCR_RE_Msk = 0x10
	// Bit RE.
	SCI0_SCR_RE = 0x10
	// Disable serial reception
	SCI0_SCR_RE_0 = 0x0
	// Enable serial reception
	SCI0_SCR_RE_1 = 0x1
	// Position of TE field.
	SCI0_SCR_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI0_SCR_TE_Msk = 0x20
	// Bit TE.
	SCI0_SCR_TE = 0x20
	// Disable serial transmission
	SCI0_SCR_TE_0 = 0x0
	// Enable serial transmission
	SCI0_SCR_TE_1 = 0x1
	// Position of RIE field.
	SCI0_SCR_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI0_SCR_RIE_Msk = 0x40
	// Bit RIE.
	SCI0_SCR_RIE = 0x40
	// Disable SCIn_RXI and SCIn_ERI interrupt requests
	SCI0_SCR_RIE_0 = 0x0
	// Enable SCIn_RXI and SCIn_ERI interrupt requests
	SCI0_SCR_RIE_1 = 0x1
	// Position of TIE field.
	SCI0_SCR_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI0_SCR_TIE_Msk = 0x80
	// Bit TIE.
	SCI0_SCR_TIE = 0x80
	// Disable SCIn_TXI interrupt requests
	SCI0_SCR_TIE_0 = 0x0
	// Enable SCIn_TXI interrupt requests
	SCI0_SCR_TIE_1 = 0x1

	// SCR_SMCI: Serial Control Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of CKE field.
	SCI0_SCR_SMCI_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI0_SCR_SMCI_CKE_Msk = 0x3
	// When SMR_SMCI.GM = 0: Disable output The SCKn pin is available for use as an I/O port if set up in the I/O port settings When SMR_SMCI.GM = 1: Fix output low
	SCI0_SCR_SMCI_CKE_00 = 0x0
	// When SMR_SMCI.GM = 0: Output clock When SMR_SMCI.GM = 1: Output clock
	SCI0_SCR_SMCI_CKE_01 = 0x1
	// When SMR_SMCI.GM = 0: Setting prohibited When SMR_SMCI.GM = 1: Fix output high
	SCI0_SCR_SMCI_CKE_10 = 0x2
	// When SMR_SMCI.GM = 0: Setting prohibited When SMR_SMCI.GM = 1: Output clock
	SCI0_SCR_SMCI_CKE_11 = 0x3
	// Position of TEIE field.
	SCI0_SCR_SMCI_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI0_SCR_SMCI_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI0_SCR_SMCI_TEIE = 0x4
	// Position of MPIE field.
	SCI0_SCR_SMCI_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI0_SCR_SMCI_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI0_SCR_SMCI_MPIE = 0x8
	// Position of RE field.
	SCI0_SCR_SMCI_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI0_SCR_SMCI_RE_Msk = 0x10
	// Bit RE.
	SCI0_SCR_SMCI_RE = 0x10
	// Disable serial reception
	SCI0_SCR_SMCI_RE_0 = 0x0
	// Enable serial reception
	SCI0_SCR_SMCI_RE_1 = 0x1
	// Position of TE field.
	SCI0_SCR_SMCI_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI0_SCR_SMCI_TE_Msk = 0x20
	// Bit TE.
	SCI0_SCR_SMCI_TE = 0x20
	// Disable serial transmission
	SCI0_SCR_SMCI_TE_0 = 0x0
	// Enable serial transmission
	SCI0_SCR_SMCI_TE_1 = 0x1
	// Position of RIE field.
	SCI0_SCR_SMCI_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI0_SCR_SMCI_RIE_Msk = 0x40
	// Bit RIE.
	SCI0_SCR_SMCI_RIE = 0x40
	// Disable SCIn_RXI and SCIn_ERI interrupt requests
	SCI0_SCR_SMCI_RIE_0 = 0x0
	// Enable SCIn_RXI and SCIn_ERI interrupt requests
	SCI0_SCR_SMCI_RIE_1 = 0x1
	// Position of TIE field.
	SCI0_SCR_SMCI_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI0_SCR_SMCI_TIE_Msk = 0x80
	// Bit TIE.
	SCI0_SCR_SMCI_TIE = 0x80
	// Disable SCIn_TXI interrupt requests
	SCI0_SCR_SMCI_TIE_0 = 0x0
	// Enable SCIn_TXI interrupt requests
	SCI0_SCR_SMCI_TIE_1 = 0x1

	// SSR: Serial Status Register for Non-Smart Card Interface and Non-FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0, and MMR.MANEN = 0)
	// Position of MPBT field.
	SCI0_SSR_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI0_SSR_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI0_SSR_MPBT = 0x1
	// Data transmission cycle
	SCI0_SSR_MPBT_0 = 0x0
	// ID transmission cycle
	SCI0_SSR_MPBT_1 = 0x1
	// Position of MPB field.
	SCI0_SSR_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_SSR_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_SSR_MPB = 0x2
	// Data transmission cycle
	SCI0_SSR_MPB_0 = 0x0
	// ID transmission cycle
	SCI0_SSR_MPB_1 = 0x1
	// Position of TEND field.
	SCI0_SSR_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_TEND = 0x4
	// A character is being transmitted
	SCI0_SSR_TEND_0 = 0x0
	// Character transfer is complete
	SCI0_SSR_TEND_1 = 0x1
	// Position of PER field.
	SCI0_SSR_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_PER = 0x8
	// No parity error occurred
	SCI0_SSR_PER_0 = 0x0
	// Parity error occurred
	SCI0_SSR_PER_1 = 0x1
	// Position of FER field.
	SCI0_SSR_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_SSR_FER_Msk = 0x10
	// Bit FER.
	SCI0_SSR_FER = 0x10
	// No framing error occurred
	SCI0_SSR_FER_0 = 0x0
	// Framing error occurred
	SCI0_SSR_FER_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_ORER_0 = 0x0
	// Overrun error occurred
	SCI0_SSR_ORER_1 = 0x1
	// Position of RDRF field.
	SCI0_SSR_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI0_SSR_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI0_SSR_RDRF = 0x40
	// No received data in RDR register
	SCI0_SSR_RDRF_0 = 0x0
	// Received data in RDR register
	SCI0_SSR_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI0_SSR_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI0_SSR_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI0_SSR_TDRE = 0x80
	// Transmit data in TDR register
	SCI0_SSR_TDRE_0 = 0x0
	// No transmit data in TDR register
	SCI0_SSR_TDRE_1 = 0x1

	// SSR_FIFO: Serial Status Register for Non-Smart Card Interface and FIFO Mode (SCMR.SMIF = 0, FCR.FM = 1, and MMR.MANEN = 0)
	// Position of DR field.
	SCI0_SSR_FIFO_DR_Pos = 0x0
	// Bit mask of DR field.
	SCI0_SSR_FIFO_DR_Msk = 0x1
	// Bit DR.
	SCI0_SSR_FIFO_DR = 0x1
	// Receiving is in progress, or no received data remains in FRDRHL after successfully completed reception (receive FIFO empty)
	SCI0_SSR_FIFO_DR_0 = 0x0
	// Next receive data is not received for a period after normal receiving is complete, when the amount of data stored in the FIFO is equal to or less than the receive triggering number
	SCI0_SSR_FIFO_DR_1 = 0x1
	// Position of TEND field.
	SCI0_SSR_FIFO_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_FIFO_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_FIFO_TEND = 0x4
	// A character is being transmitted
	SCI0_SSR_FIFO_TEND_0 = 0x0
	// Character transfer is complete
	SCI0_SSR_FIFO_TEND_1 = 0x1
	// Position of PER field.
	SCI0_SSR_FIFO_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_FIFO_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_FIFO_PER = 0x8
	// No parity error occurred
	SCI0_SSR_FIFO_PER_0 = 0x0
	// Parity error occurred
	SCI0_SSR_FIFO_PER_1 = 0x1
	// Position of FER field.
	SCI0_SSR_FIFO_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_SSR_FIFO_FER_Msk = 0x10
	// Bit FER.
	SCI0_SSR_FIFO_FER = 0x10
	// No framing error occurred
	SCI0_SSR_FIFO_FER_0 = 0x0
	// Framing error occurred
	SCI0_SSR_FIFO_FER_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_FIFO_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_FIFO_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_FIFO_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_FIFO_ORER_0 = 0x0
	// Overrun error occurred
	SCI0_SSR_FIFO_ORER_1 = 0x1
	// Position of RDF field.
	SCI0_SSR_FIFO_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI0_SSR_FIFO_RDF_Msk = 0x40
	// Bit RDF.
	SCI0_SSR_FIFO_RDF = 0x40
	// The amount of receive data written in FRDRHL is less than the specified receive triggering number
	SCI0_SSR_FIFO_RDF_0 = 0x0
	// The amount of receive data written in FRDRHL is equal to or greater than the specified receive triggering number
	SCI0_SSR_FIFO_RDF_1 = 0x1
	// Position of TDFE field.
	SCI0_SSR_FIFO_TDFE_Pos = 0x7
	// Bit mask of TDFE field.
	SCI0_SSR_FIFO_TDFE_Msk = 0x80
	// Bit TDFE.
	SCI0_SSR_FIFO_TDFE = 0x80
	// The amount of transmit data written in FTDRHL exceeds the specified transmit triggering number
	SCI0_SSR_FIFO_TDFE_0 = 0x0
	// The amount of transmit data written in FTDRHL is equal to or less than the specified transmit triggering number
	SCI0_SSR_FIFO_TDFE_1 = 0x1

	// SSR_SMCI: Serial Status Register for Smart Card Interface Mode (SCMR.SMIF = 1, and MMR.MANEN = 0)
	// Position of MPBT field.
	SCI0_SSR_SMCI_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI0_SSR_SMCI_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI0_SSR_SMCI_MPBT = 0x1
	// Position of MPB field.
	SCI0_SSR_SMCI_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_SSR_SMCI_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_SSR_SMCI_MPB = 0x2
	// Position of TEND field.
	SCI0_SSR_SMCI_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_SMCI_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_SMCI_TEND = 0x4
	// A character is being transmitted
	SCI0_SSR_SMCI_TEND_0 = 0x0
	// Character transfer is complete
	SCI0_SSR_SMCI_TEND_1 = 0x1
	// Position of PER field.
	SCI0_SSR_SMCI_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_SMCI_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_SMCI_PER = 0x8
	// No parity error occurred
	SCI0_SSR_SMCI_PER_0 = 0x0
	// Parity error occurred
	SCI0_SSR_SMCI_PER_1 = 0x1
	// Position of ERS field.
	SCI0_SSR_SMCI_ERS_Pos = 0x4
	// Bit mask of ERS field.
	SCI0_SSR_SMCI_ERS_Msk = 0x10
	// Bit ERS.
	SCI0_SSR_SMCI_ERS = 0x10
	// No low error signal response
	SCI0_SSR_SMCI_ERS_0 = 0x0
	// Low error signal response occurred
	SCI0_SSR_SMCI_ERS_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_SMCI_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_SMCI_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_SMCI_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_SMCI_ORER_0 = 0x0
	// Overrun error occurred
	SCI0_SSR_SMCI_ORER_1 = 0x1
	// Position of RDRF field.
	SCI0_SSR_SMCI_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI0_SSR_SMCI_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI0_SSR_SMCI_RDRF = 0x40
	// No received data in RDR register
	SCI0_SSR_SMCI_RDRF_0 = 0x0
	// Received data in RDR register
	SCI0_SSR_SMCI_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI0_SSR_SMCI_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI0_SSR_SMCI_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI0_SSR_SMCI_TDRE = 0x80
	// Transmit data in TDR register
	SCI0_SSR_SMCI_TDRE_0 = 0x0
	// No transmit data in TDR register
	SCI0_SSR_SMCI_TDRE_1 = 0x1

	// SCMR: Smart Card Mode Register
	// Position of SMIF field.
	SCI0_SCMR_SMIF_Pos = 0x0
	// Bit mask of SMIF field.
	SCI0_SCMR_SMIF_Msk = 0x1
	// Bit SMIF.
	SCI0_SCMR_SMIF = 0x1
	// Non-smart card interface mode (asynchronous mode, clock synchronous mode, simple SPI mode, or simple IIC mode)
	SCI0_SCMR_SMIF_0 = 0x0
	// Smart card interface mode
	SCI0_SCMR_SMIF_1 = 0x1
	// Position of SINV field.
	SCI0_SCMR_SINV_Pos = 0x2
	// Bit mask of SINV field.
	SCI0_SCMR_SINV_Msk = 0x4
	// Bit SINV.
	SCI0_SCMR_SINV = 0x4
	// TDR contents are transmitted as they are. Received data is stored as received in the RDR register.
	SCI0_SCMR_SINV_0 = 0x0
	// TDR register contents are inverted before transmission. Receive data is stored in inverted form in the RDR register.
	SCI0_SCMR_SINV_1 = 0x1
	// Position of SDIR field.
	SCI0_SCMR_SDIR_Pos = 0x3
	// Bit mask of SDIR field.
	SCI0_SCMR_SDIR_Msk = 0x8
	// Bit SDIR.
	SCI0_SCMR_SDIR = 0x8
	// Transfer LSB-first
	SCI0_SCMR_SDIR_0 = 0x0
	// Transfer MSB-first
	SCI0_SCMR_SDIR_1 = 0x1
	// Position of CHR1 field.
	SCI0_SCMR_CHR1_Pos = 0x4
	// Bit mask of CHR1 field.
	SCI0_SCMR_CHR1_Msk = 0x10
	// Bit CHR1.
	SCI0_SCMR_CHR1 = 0x10
	// SMR.CHR = 0: Transmit/receive in 9-bit data length SMR.CHR = 1: Transmit/receive in 9-bit data length
	SCI0_SCMR_CHR1_0 = 0x0
	// SMR.CHR = 0: Transmit/receive in 8-bit data length (initial value) SMR.CHR = 1: Transmit/receive in 7-bit data length
	SCI0_SCMR_CHR1_1 = 0x1
	// Position of BCP2 field.
	SCI0_SCMR_BCP2_Pos = 0x7
	// Bit mask of BCP2 field.
	SCI0_SCMR_BCP2_Msk = 0x80
	// Bit BCP2.
	SCI0_SCMR_BCP2 = 0x80

	// SEMR: Serial Extended Mode Register
	// Position of ACS0 field.
	SCI0_SEMR_ACS0_Pos = 0x0
	// Bit mask of ACS0 field.
	SCI0_SEMR_ACS0_Msk = 0x1
	// Bit ACS0.
	SCI0_SEMR_ACS0 = 0x1
	// External clock input
	SCI0_SEMR_ACS0_0 = 0x0
	// Logical AND of compare matches output from the internal GPT. These bit for the other SCI channels than SCIn (n = 2) are reserved.
	SCI0_SEMR_ACS0_1 = 0x1
	// Position of PADIS field.
	SCI0_SEMR_PADIS_Pos = 0x1
	// Bit mask of PADIS field.
	SCI0_SEMR_PADIS_Msk = 0x2
	// Bit PADIS.
	SCI0_SEMR_PADIS = 0x2
	// Preamble output function is enabled
	SCI0_SEMR_PADIS_0 = 0x0
	// Preamble output function is disabled These bits for the other SCI channels than SCIn (n = 0, 3, 4, 9) are reserved.
	SCI0_SEMR_PADIS_1 = 0x1
	// Position of BRME field.
	SCI0_SEMR_BRME_Pos = 0x2
	// Bit mask of BRME field.
	SCI0_SEMR_BRME_Msk = 0x4
	// Bit BRME.
	SCI0_SEMR_BRME = 0x4
	// Disable bit rate modulation function
	SCI0_SEMR_BRME_0 = 0x0
	// Enable bit rate modulation function
	SCI0_SEMR_BRME_1 = 0x1
	// Position of ABCSE field.
	SCI0_SEMR_ABCSE_Pos = 0x3
	// Bit mask of ABCSE field.
	SCI0_SEMR_ABCSE_Msk = 0x8
	// Bit ABCSE.
	SCI0_SEMR_ABCSE = 0x8
	// Clock cycles for 1-bit period determined by combination of the BGDM and ABCS bits in the SEMR register
	SCI0_SEMR_ABCSE_0 = 0x0
	// Baud rate is 6 base clock cycles for 1-bit period These bits for the other SCI channels than SCIn (n = 0, 3, 4, 9) are reserved.
	SCI0_SEMR_ABCSE_1 = 0x1
	// Position of ABCS field.
	SCI0_SEMR_ABCS_Pos = 0x4
	// Bit mask of ABCS field.
	SCI0_SEMR_ABCS_Msk = 0x10
	// Bit ABCS.
	SCI0_SEMR_ABCS = 0x10
	// Select 16 base clock cycles for 1-bit period
	SCI0_SEMR_ABCS_0 = 0x0
	// Select 8 base clock cycles for 1-bit period
	SCI0_SEMR_ABCS_1 = 0x1
	// Position of NFEN field.
	SCI0_SEMR_NFEN_Pos = 0x5
	// Bit mask of NFEN field.
	SCI0_SEMR_NFEN_Msk = 0x20
	// Bit NFEN.
	SCI0_SEMR_NFEN = 0x20
	// In asynchronous mode: Disable noise cancellation function for RXDn input signal In simple I2C mode: Disable noise cancellation function for SCLn and SDAn input signals
	SCI0_SEMR_NFEN_0 = 0x0
	// In asynchronous mode: Enable noise cancellation function for RXDn input signal In simple I2C mode: Enable noise cancellation function for SCLn and SDAn input signals
	SCI0_SEMR_NFEN_1 = 0x1
	// Position of BGDM field.
	SCI0_SEMR_BGDM_Pos = 0x6
	// Bit mask of BGDM field.
	SCI0_SEMR_BGDM_Msk = 0x40
	// Bit BGDM.
	SCI0_SEMR_BGDM = 0x40
	// Output clock from baud rate generator with normal frequency
	SCI0_SEMR_BGDM_0 = 0x0
	// Output clock from baud rate generator with doubled frequency
	SCI0_SEMR_BGDM_1 = 0x1
	// Position of RXDESEL field.
	SCI0_SEMR_RXDESEL_Pos = 0x7
	// Bit mask of RXDESEL field.
	SCI0_SEMR_RXDESEL_Msk = 0x80
	// Bit RXDESEL.
	SCI0_SEMR_RXDESEL = 0x80
	// Detect low level on RXDn pin as start bit
	SCI0_SEMR_RXDESEL_0 = 0x0
	// Detect falling edge of RXDn pin as start bit
	SCI0_SEMR_RXDESEL_1 = 0x1

	// SNFR: Noise Filter Setting Register
	// Position of NFCS field.
	SCI0_SNFR_NFCS_Pos = 0x0
	// Bit mask of NFCS field.
	SCI0_SNFR_NFCS_Msk = 0x7
	// In asynchronous mode: Use clock signal divided by 1 with noise filter In simple I2C mode: Setting prohibited
	SCI0_SNFR_NFCS_000 = 0x0
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 1 with noise filter
	SCI0_SNFR_NFCS_001 = 0x1
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 2 with noise filter
	SCI0_SNFR_NFCS_010 = 0x2
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 4 with noise filter
	SCI0_SNFR_NFCS_011 = 0x3
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 8 with noise filter
	SCI0_SNFR_NFCS_100 = 0x4

	// SIMR1: IIC Mode Register 1
	// Position of IICM field.
	SCI0_SIMR1_IICM_Pos = 0x0
	// Bit mask of IICM field.
	SCI0_SIMR1_IICM_Msk = 0x1
	// Bit IICM.
	SCI0_SIMR1_IICM = 0x1
	// SCMR.SMIF = 0: Asynchronous mode (including multi-processor mode), clock synchronous mode, or simple SPI mode SCMR.SMIF = 1: Smart card interface mode
	SCI0_SIMR1_IICM_0 = 0x0
	// SCMR.SMIF = 0: Simple IIC mode SCMR.SMIF = 1: Setting prohibited
	SCI0_SIMR1_IICM_1 = 0x1
	// Position of IICDL field.
	SCI0_SIMR1_IICDL_Pos = 0x3
	// Bit mask of IICDL field.
	SCI0_SIMR1_IICDL_Msk = 0xf8
	// No output delay
	SCI0_SIMR1_IICDL_0x00 = 0x0

	// SIMR2: IIC Mode Register 2
	// Position of IICINTM field.
	SCI0_SIMR2_IICINTM_Pos = 0x0
	// Bit mask of IICINTM field.
	SCI0_SIMR2_IICINTM_Msk = 0x1
	// Bit IICINTM.
	SCI0_SIMR2_IICINTM = 0x1
	// Use ACK/NACK interrupts
	SCI0_SIMR2_IICINTM_0 = 0x0
	// Use reception and transmission interrupts
	SCI0_SIMR2_IICINTM_1 = 0x1
	// Position of IICCSC field.
	SCI0_SIMR2_IICCSC_Pos = 0x1
	// Bit mask of IICCSC field.
	SCI0_SIMR2_IICCSC_Msk = 0x2
	// Bit IICCSC.
	SCI0_SIMR2_IICCSC = 0x2
	// Do not synchronize with clock signal
	SCI0_SIMR2_IICCSC_0 = 0x0
	// Synchronize with clock signal
	SCI0_SIMR2_IICCSC_1 = 0x1
	// Position of IICACKT field.
	SCI0_SIMR2_IICACKT_Pos = 0x5
	// Bit mask of IICACKT field.
	SCI0_SIMR2_IICACKT_Msk = 0x20
	// Bit IICACKT.
	SCI0_SIMR2_IICACKT = 0x20
	// ACK transmission
	SCI0_SIMR2_IICACKT_0 = 0x0
	// NACK transmission and ACK/NACK reception
	SCI0_SIMR2_IICACKT_1 = 0x1

	// SIMR3: IIC Mode Register 3
	// Position of IICSTAREQ field.
	SCI0_SIMR3_IICSTAREQ_Pos = 0x0
	// Bit mask of IICSTAREQ field.
	SCI0_SIMR3_IICSTAREQ_Msk = 0x1
	// Bit IICSTAREQ.
	SCI0_SIMR3_IICSTAREQ = 0x1
	// Do not generate start condition
	SCI0_SIMR3_IICSTAREQ_0 = 0x0
	// Generate start condition
	SCI0_SIMR3_IICSTAREQ_1 = 0x1
	// Position of IICRSTAREQ field.
	SCI0_SIMR3_IICRSTAREQ_Pos = 0x1
	// Bit mask of IICRSTAREQ field.
	SCI0_SIMR3_IICRSTAREQ_Msk = 0x2
	// Bit IICRSTAREQ.
	SCI0_SIMR3_IICRSTAREQ = 0x2
	// Do not generate restart condition
	SCI0_SIMR3_IICRSTAREQ_0 = 0x0
	// Generate restart condition
	SCI0_SIMR3_IICRSTAREQ_1 = 0x1
	// Position of IICSTPREQ field.
	SCI0_SIMR3_IICSTPREQ_Pos = 0x2
	// Bit mask of IICSTPREQ field.
	SCI0_SIMR3_IICSTPREQ_Msk = 0x4
	// Bit IICSTPREQ.
	SCI0_SIMR3_IICSTPREQ = 0x4
	// Do not generate stop condition
	SCI0_SIMR3_IICSTPREQ_0 = 0x0
	// Generate stop condition
	SCI0_SIMR3_IICSTPREQ_1 = 0x1
	// Position of IICSTIF field.
	SCI0_SIMR3_IICSTIF_Pos = 0x3
	// Bit mask of IICSTIF field.
	SCI0_SIMR3_IICSTIF_Msk = 0x8
	// Bit IICSTIF.
	SCI0_SIMR3_IICSTIF = 0x8
	// No requests are being made for generating conditions, or a condition is being generated
	SCI0_SIMR3_IICSTIF_0 = 0x0
	// Generation of start, restart, or stop condition is complete. When 0 is written to IICSTIF, it is set to 0
	SCI0_SIMR3_IICSTIF_1 = 0x1
	// Position of IICSDAS field.
	SCI0_SIMR3_IICSDAS_Pos = 0x4
	// Bit mask of IICSDAS field.
	SCI0_SIMR3_IICSDAS_Msk = 0x30
	// Output serial data
	SCI0_SIMR3_IICSDAS_00 = 0x0
	// Generate start, restart, or stop condition
	SCI0_SIMR3_IICSDAS_01 = 0x1
	// Output low on SDAn pin
	SCI0_SIMR3_IICSDAS_10 = 0x2
	// Drive SDAn pin to high-impedance state
	SCI0_SIMR3_IICSDAS_11 = 0x3
	// Position of IICSCLS field.
	SCI0_SIMR3_IICSCLS_Pos = 0x6
	// Bit mask of IICSCLS field.
	SCI0_SIMR3_IICSCLS_Msk = 0xc0
	// Output serial clock
	SCI0_SIMR3_IICSCLS_00 = 0x0
	// Generate start, restart, or stop condition
	SCI0_SIMR3_IICSCLS_01 = 0x1
	// Output low on SCLn pin
	SCI0_SIMR3_IICSCLS_10 = 0x2
	// Drive SCLn pin to high-impedance state
	SCI0_SIMR3_IICSCLS_11 = 0x3

	// SISR: IIC Status Register
	// Position of IICACKR field.
	SCI0_SISR_IICACKR_Pos = 0x0
	// Bit mask of IICACKR field.
	SCI0_SISR_IICACKR_Msk = 0x1
	// Bit IICACKR.
	SCI0_SISR_IICACKR = 0x1
	// ACK received
	SCI0_SISR_IICACKR_0 = 0x0
	// NACK received
	SCI0_SISR_IICACKR_1 = 0x1

	// SPMR: SPI Mode Register
	// Position of SSE field.
	SCI0_SPMR_SSE_Pos = 0x0
	// Bit mask of SSE field.
	SCI0_SPMR_SSE_Msk = 0x1
	// Bit SSE.
	SCI0_SPMR_SSE = 0x1
	// Disable SSn pin function
	SCI0_SPMR_SSE_0 = 0x0
	// Enable SSn pin function
	SCI0_SPMR_SSE_1 = 0x1
	// Position of CTSE field.
	SCI0_SPMR_CTSE_Pos = 0x1
	// Bit mask of CTSE field.
	SCI0_SPMR_CTSE_Msk = 0x2
	// Bit CTSE.
	SCI0_SPMR_CTSE = 0x2
	// Disable CTS function (enable RTS output function)
	SCI0_SPMR_CTSE_0 = 0x0
	// Enable CTS function
	SCI0_SPMR_CTSE_1 = 0x1
	// Position of MSS field.
	SCI0_SPMR_MSS_Pos = 0x2
	// Bit mask of MSS field.
	SCI0_SPMR_MSS_Msk = 0x4
	// Bit MSS.
	SCI0_SPMR_MSS = 0x4
	// Transmit through TXDn pin and receive through RXDn pin (master mode)
	SCI0_SPMR_MSS_0 = 0x0
	// Receive through TXDn pin and transmit through RXDn pin (slave mode)
	SCI0_SPMR_MSS_1 = 0x1
	// Position of CTSPEN field.
	SCI0_SPMR_CTSPEN_Pos = 0x3
	// Bit mask of CTSPEN field.
	SCI0_SPMR_CTSPEN_Msk = 0x8
	// Bit CTSPEN.
	SCI0_SPMR_CTSPEN = 0x8
	// Alternate setting to use CTS and RTS functions as either one terminal
	SCI0_SPMR_CTSPEN_0 = 0x0
	// Dedicated setting for separately using CTS and RTS functions with 2 terminals These bits for the other SCI channels than SCIn (n = 0, 3, 4, 9) are reserved.
	SCI0_SPMR_CTSPEN_1 = 0x1
	// Position of MFF field.
	SCI0_SPMR_MFF_Pos = 0x4
	// Bit mask of MFF field.
	SCI0_SPMR_MFF_Msk = 0x10
	// Bit MFF.
	SCI0_SPMR_MFF = 0x10
	// No mode fault error
	SCI0_SPMR_MFF_0 = 0x0
	// Mode fault error
	SCI0_SPMR_MFF_1 = 0x1
	// Position of CKPOL field.
	SCI0_SPMR_CKPOL_Pos = 0x6
	// Bit mask of CKPOL field.
	SCI0_SPMR_CKPOL_Msk = 0x40
	// Bit CKPOL.
	SCI0_SPMR_CKPOL = 0x40
	// Do not invert clock polarity
	SCI0_SPMR_CKPOL_0 = 0x0
	// Invert clock polarity
	SCI0_SPMR_CKPOL_1 = 0x1
	// Position of CKPH field.
	SCI0_SPMR_CKPH_Pos = 0x7
	// Bit mask of CKPH field.
	SCI0_SPMR_CKPH_Msk = 0x80
	// Bit CKPH.
	SCI0_SPMR_CKPH = 0x80
	// Do not delay clock
	SCI0_SPMR_CKPH_0 = 0x0
	// Delay clock
	SCI0_SPMR_CKPH_1 = 0x1

	// FTDRHL: Transmit FIFO Data Register
	// Position of TDAT field.
	SCI0_FTDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI0_FTDRHL_TDAT_Msk = 0x1ff
	// Position of MPBT field.
	SCI0_FTDRHL_MPBT_Pos = 0x9
	// Bit mask of MPBT field.
	SCI0_FTDRHL_MPBT_Msk = 0x200
	// Bit MPBT.
	SCI0_FTDRHL_MPBT = 0x200
	// Data transmission cycle
	SCI0_FTDRHL_MPBT_0 = 0x0
	// ID transmission cycle
	SCI0_FTDRHL_MPBT_1 = 0x1

	// TDRHL: Transmit Data Register for Non-Manchester mode (MMR.MANEN = 0)
	// Position of TDAT field.
	SCI0_TDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI0_TDRHL_TDAT_Msk = 0x1ff

	// FTDRH: Transmit FIFO Data Register
	// Position of MPBT field.
	SCI0_FTDRH_MPBT_Pos = 0x1
	// Bit mask of MPBT field.
	SCI0_FTDRH_MPBT_Msk = 0x2
	// Bit MPBT.
	SCI0_FTDRH_MPBT = 0x2
	// Data transmission cycle
	SCI0_FTDRH_MPBT_0 = 0x0
	// ID transmission cycle
	SCI0_FTDRH_MPBT_1 = 0x1

	// FTDRL: Transmit FIFO Data Register
	// Position of TDAT field.
	SCI0_FTDRL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI0_FTDRL_TDAT_Msk = 0xff

	// FRDRHL: Receive FIFO Data Register
	// Position of RDAT field.
	SCI0_FRDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI0_FRDRHL_RDAT_Msk = 0x1ff
	// Position of MPB field.
	SCI0_FRDRHL_MPB_Pos = 0x9
	// Bit mask of MPB field.
	SCI0_FRDRHL_MPB_Msk = 0x200
	// Bit MPB.
	SCI0_FRDRHL_MPB = 0x200
	// Data transmission cycle
	SCI0_FRDRHL_MPB_0 = 0x0
	// ID transmission cycle
	SCI0_FRDRHL_MPB_1 = 0x1
	// Position of DR field.
	SCI0_FRDRHL_DR_Pos = 0xa
	// Bit mask of DR field.
	SCI0_FRDRHL_DR_Msk = 0x400
	// Bit DR.
	SCI0_FRDRHL_DR = 0x400
	// Receiving is in progress, or no received data remains in the FRDRH and FRDRL registers after successfully completed reception
	SCI0_FRDRHL_DR_0 = 0x0
	// Next receive data is not received for a period after successfully completed reception
	SCI0_FRDRHL_DR_1 = 0x1
	// Position of PER field.
	SCI0_FRDRHL_PER_Pos = 0xb
	// Bit mask of PER field.
	SCI0_FRDRHL_PER_Msk = 0x800
	// Bit PER.
	SCI0_FRDRHL_PER = 0x800
	// No parity error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRHL_PER_0 = 0x0
	// Parity error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRHL_PER_1 = 0x1
	// Position of FER field.
	SCI0_FRDRHL_FER_Pos = 0xc
	// Bit mask of FER field.
	SCI0_FRDRHL_FER_Msk = 0x1000
	// Bit FER.
	SCI0_FRDRHL_FER = 0x1000
	// No framing error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRHL_FER_0 = 0x0
	// Framing error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRHL_FER_1 = 0x1
	// Position of ORER field.
	SCI0_FRDRHL_ORER_Pos = 0xd
	// Bit mask of ORER field.
	SCI0_FRDRHL_ORER_Msk = 0x2000
	// Bit ORER.
	SCI0_FRDRHL_ORER = 0x2000
	// No overrun error occurred
	SCI0_FRDRHL_ORER_0 = 0x0
	// Overrun error occurred
	SCI0_FRDRHL_ORER_1 = 0x1
	// Position of RDF field.
	SCI0_FRDRHL_RDF_Pos = 0xe
	// Bit mask of RDF field.
	SCI0_FRDRHL_RDF_Msk = 0x4000
	// Bit RDF.
	SCI0_FRDRHL_RDF = 0x4000
	// The amount of receive data written in FRDRH and FRDRL is less than the specified receive triggering number
	SCI0_FRDRHL_RDF_0 = 0x0
	// The amount of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number
	SCI0_FRDRHL_RDF_1 = 0x1

	// RDRHL: Receive Data Register for Non-Manchester mode (MMR.MANEN = 0)
	// Position of RDAT field.
	SCI0_RDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI0_RDRHL_RDAT_Msk = 0x1ff

	// FRDRH: Receive FIFO Data Register
	// Position of MPB field.
	SCI0_FRDRH_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_FRDRH_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_FRDRH_MPB = 0x2
	// Data transmission cycle
	SCI0_FRDRH_MPB_0 = 0x0
	// ID transmission cycle
	SCI0_FRDRH_MPB_1 = 0x1
	// Position of DR field.
	SCI0_FRDRH_DR_Pos = 0x2
	// Bit mask of DR field.
	SCI0_FRDRH_DR_Msk = 0x4
	// Bit DR.
	SCI0_FRDRH_DR = 0x4
	// Receiving is in progress, or no received data remains in the FRDRH and FRDRL registers after successfully completed reception
	SCI0_FRDRH_DR_0 = 0x0
	// Next receive data is not received for a period after successfully completed reception
	SCI0_FRDRH_DR_1 = 0x1
	// Position of PER field.
	SCI0_FRDRH_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_FRDRH_PER_Msk = 0x8
	// Bit PER.
	SCI0_FRDRH_PER = 0x8
	// No parity error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRH_PER_0 = 0x0
	// Parity error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRH_PER_1 = 0x1
	// Position of FER field.
	SCI0_FRDRH_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_FRDRH_FER_Msk = 0x10
	// Bit FER.
	SCI0_FRDRH_FER = 0x10
	// No framing error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRH_FER_0 = 0x0
	// Framing error occurred in the first data of FRDRH and FRDRL
	SCI0_FRDRH_FER_1 = 0x1
	// Position of ORER field.
	SCI0_FRDRH_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_FRDRH_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_FRDRH_ORER = 0x20
	// No overrun error occurred
	SCI0_FRDRH_ORER_0 = 0x0
	// Overrun error occurred
	SCI0_FRDRH_ORER_1 = 0x1
	// Position of RDF field.
	SCI0_FRDRH_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI0_FRDRH_RDF_Msk = 0x40
	// Bit RDF.
	SCI0_FRDRH_RDF = 0x40
	// The amount of receive data written in FRDRH and FRDRL is less than the specified receive triggering number
	SCI0_FRDRH_RDF_0 = 0x0
	// The amount of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number
	SCI0_FRDRH_RDF_1 = 0x1

	// FRDRL: Receive FIFO Data Register
	// Position of RDAT field.
	SCI0_FRDRL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI0_FRDRL_RDAT_Msk = 0xff

	// DCCR: Data Compare Match Control Register
	// Position of DCMF field.
	SCI0_DCCR_DCMF_Pos = 0x0
	// Bit mask of DCMF field.
	SCI0_DCCR_DCMF_Msk = 0x1
	// Bit DCMF.
	SCI0_DCCR_DCMF = 0x1
	// Not matched
	SCI0_DCCR_DCMF_0 = 0x0
	// Matched
	SCI0_DCCR_DCMF_1 = 0x1
	// Position of DPER field.
	SCI0_DCCR_DPER_Pos = 0x3
	// Bit mask of DPER field.
	SCI0_DCCR_DPER_Msk = 0x8
	// Bit DPER.
	SCI0_DCCR_DPER = 0x8
	// No parity error occurred
	SCI0_DCCR_DPER_0 = 0x0
	// Parity error occurred
	SCI0_DCCR_DPER_1 = 0x1
	// Position of DFER field.
	SCI0_DCCR_DFER_Pos = 0x4
	// Bit mask of DFER field.
	SCI0_DCCR_DFER_Msk = 0x10
	// Bit DFER.
	SCI0_DCCR_DFER = 0x10
	// No framing error occurred
	SCI0_DCCR_DFER_0 = 0x0
	// Framing error occurred
	SCI0_DCCR_DFER_1 = 0x1
	// Position of IDSEL field.
	SCI0_DCCR_IDSEL_Pos = 0x6
	// Bit mask of IDSEL field.
	SCI0_DCCR_IDSEL_Msk = 0x40
	// Bit IDSEL.
	SCI0_DCCR_IDSEL = 0x40
	// Always compare data regardless of the MPB bit value
	SCI0_DCCR_IDSEL_0 = 0x0
	// Only compare data when MPB bit = 1 (ID frame)
	SCI0_DCCR_IDSEL_1 = 0x1
	// Position of DCME field.
	SCI0_DCCR_DCME_Pos = 0x7
	// Bit mask of DCME field.
	SCI0_DCCR_DCME_Msk = 0x80
	// Bit DCME.
	SCI0_DCCR_DCME = 0x80
	// Disable address match function
	SCI0_DCCR_DCME_0 = 0x0
	// Enable address match function
	SCI0_DCCR_DCME_1 = 0x1

	// FCR: FIFO Control Register
	// Position of FM field.
	SCI0_FCR_FM_Pos = 0x0
	// Bit mask of FM field.
	SCI0_FCR_FM_Msk = 0x1
	// Bit FM.
	SCI0_FCR_FM = 0x1
	// Non-FIFO mode. Selects TDR/RDR or TDRHL/RDRHL for communication.
	SCI0_FCR_FM_0 = 0x0
	// FIFO mode. Selects FTDRHL/FRDRHL for communication.
	SCI0_FCR_FM_1 = 0x1
	// Position of RFRST field.
	SCI0_FCR_RFRST_Pos = 0x1
	// Bit mask of RFRST field.
	SCI0_FCR_RFRST_Msk = 0x2
	// Bit RFRST.
	SCI0_FCR_RFRST = 0x2
	// Do not reset FRDRHL
	SCI0_FCR_RFRST_0 = 0x0
	// Reset FRDRHL
	SCI0_FCR_RFRST_1 = 0x1
	// Position of TFRST field.
	SCI0_FCR_TFRST_Pos = 0x2
	// Bit mask of TFRST field.
	SCI0_FCR_TFRST_Msk = 0x4
	// Bit TFRST.
	SCI0_FCR_TFRST = 0x4
	// Do not reset FTDRHL
	SCI0_FCR_TFRST_0 = 0x0
	// Reset FTDRHL
	SCI0_FCR_TFRST_1 = 0x1
	// Position of DRES field.
	SCI0_FCR_DRES_Pos = 0x3
	// Bit mask of DRES field.
	SCI0_FCR_DRES_Msk = 0x8
	// Bit DRES.
	SCI0_FCR_DRES = 0x8
	// Receive data full interrupt (SCIn_RXI)
	SCI0_FCR_DRES_0 = 0x0
	// Receive error interrupt (SCIn_ERI)
	SCI0_FCR_DRES_1 = 0x1
	// Position of TTRG field.
	SCI0_FCR_TTRG_Pos = 0x4
	// Bit mask of TTRG field.
	SCI0_FCR_TTRG_Msk = 0xf0
	// Position of RTRG field.
	SCI0_FCR_RTRG_Pos = 0x8
	// Bit mask of RTRG field.
	SCI0_FCR_RTRG_Msk = 0xf00
	// Position of RSTRG field.
	SCI0_FCR_RSTRG_Pos = 0xc
	// Bit mask of RSTRG field.
	SCI0_FCR_RSTRG_Msk = 0xf000

	// FDR: FIFO Data Count Register
	// Position of R field.
	SCI0_FDR_R_Pos = 0x0
	// Bit mask of R field.
	SCI0_FDR_R_Msk = 0x1f
	// Position of T field.
	SCI0_FDR_T_Pos = 0x8
	// Bit mask of T field.
	SCI0_FDR_T_Msk = 0x1f00

	// LSR: Line Status Register
	// Position of ORER field.
	SCI0_LSR_ORER_Pos = 0x0
	// Bit mask of ORER field.
	SCI0_LSR_ORER_Msk = 0x1
	// Bit ORER.
	SCI0_LSR_ORER = 0x1
	// No overrun error occurred
	SCI0_LSR_ORER_0 = 0x0
	// Overrun error occurred
	SCI0_LSR_ORER_1 = 0x1
	// Position of FNUM field.
	SCI0_LSR_FNUM_Pos = 0x2
	// Bit mask of FNUM field.
	SCI0_LSR_FNUM_Msk = 0x7c
	// Position of PNUM field.
	SCI0_LSR_PNUM_Pos = 0x8
	// Bit mask of PNUM field.
	SCI0_LSR_PNUM_Msk = 0x1f00

	// CDR: Compare Match Data Register
	// Position of CMPD field.
	SCI0_CDR_CMPD_Pos = 0x0
	// Bit mask of CMPD field.
	SCI0_CDR_CMPD_Msk = 0x1ff

	// SPTR: Serial Port Register
	// Position of RXDMON field.
	SCI0_SPTR_RXDMON_Pos = 0x0
	// Bit mask of RXDMON field.
	SCI0_SPTR_RXDMON_Msk = 0x1
	// Bit RXDMON.
	SCI0_SPTR_RXDMON = 0x1
	// Position of SPB2DT field.
	SCI0_SPTR_SPB2DT_Pos = 0x1
	// Bit mask of SPB2DT field.
	SCI0_SPTR_SPB2DT_Msk = 0x2
	// Bit SPB2DT.
	SCI0_SPTR_SPB2DT = 0x2
	// Position of SPB2IO field.
	SCI0_SPTR_SPB2IO_Pos = 0x2
	// Bit mask of SPB2IO field.
	SCI0_SPTR_SPB2IO_Msk = 0x4
	// Bit SPB2IO.
	SCI0_SPTR_SPB2IO = 0x4
	// Do not output value of SPB2DT bit on TXDn pin
	SCI0_SPTR_SPB2IO_0 = 0x0
	// Output value of SPB2DT bit on TXDn pin
	SCI0_SPTR_SPB2IO_1 = 0x1
	// Position of RINV field.
	SCI0_SPTR_RINV_Pos = 0x4
	// Bit mask of RINV field.
	SCI0_SPTR_RINV_Msk = 0x10
	// Bit RINV.
	SCI0_SPTR_RINV = 0x10
	// Received data from RXDn is not inverted and input.
	SCI0_SPTR_RINV_0 = 0x0
	// Received data from RXDn is inverted and input.
	SCI0_SPTR_RINV_1 = 0x1
	// Position of TINV field.
	SCI0_SPTR_TINV_Pos = 0x5
	// Bit mask of TINV field.
	SCI0_SPTR_TINV_Msk = 0x20
	// Bit TINV.
	SCI0_SPTR_TINV = 0x20
	// Transmit data is not inverted and output to TXDn.
	SCI0_SPTR_TINV_0 = 0x0
	// Transmit data is inverted and output to TXDn.
	SCI0_SPTR_TINV_1 = 0x1
	// Position of ASEN field.
	SCI0_SPTR_ASEN_Pos = 0x6
	// Bit mask of ASEN field.
	SCI0_SPTR_ASEN_Msk = 0x40
	// Bit ASEN.
	SCI0_SPTR_ASEN = 0x40
	// Adjust sampling timing disable.
	SCI0_SPTR_ASEN_0 = 0x0
	// Adjust sampling timing enable.
	SCI0_SPTR_ASEN_1 = 0x1
	// Position of ATEN field.
	SCI0_SPTR_ATEN_Pos = 0x7
	// Bit mask of ATEN field.
	SCI0_SPTR_ATEN_Msk = 0x80
	// Bit ATEN.
	SCI0_SPTR_ATEN = 0x80
	// Adjust transmit timing disable.
	SCI0_SPTR_ATEN_0 = 0x0
	// Adjust transmit timing enable.
	SCI0_SPTR_ATEN_1 = 0x1

	// ACTR: Adjustment Communication Timing Register
	// Position of AST field.
	SCI0_ACTR_AST_Pos = 0x0
	// Bit mask of AST field.
	SCI0_ACTR_AST_Msk = 0x7
	// Position of AJD field.
	SCI0_ACTR_AJD_Pos = 0x3
	// Bit mask of AJD field.
	SCI0_ACTR_AJD_Msk = 0x8
	// Bit AJD.
	SCI0_ACTR_AJD = 0x8
	// The sampling timing is adjusted backward to the middle of bit.
	SCI0_ACTR_AJD_0 = 0x0
	// The sampling timing is adjusted forward to the middle of bit.
	SCI0_ACTR_AJD_1 = 0x1
	// Position of ATT field.
	SCI0_ACTR_ATT_Pos = 0x4
	// Bit mask of ATT field.
	SCI0_ACTR_ATT_Msk = 0x70
	// Position of AET field.
	SCI0_ACTR_AET_Pos = 0x7
	// Bit mask of AET field.
	SCI0_ACTR_AET_Msk = 0x80
	// Bit AET.
	SCI0_ACTR_AET = 0x80
	// Adjust the rising edge timing.
	SCI0_ACTR_AET_0 = 0x0
	// Adjust the falling edge timing.
	SCI0_ACTR_AET_1 = 0x1
)

// Constants for SCI1: Serial Communication Interface 1
const (
	// SMR: Serial Mode Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
	// Position of CKS field.
	SCI1_SMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI1_SMR_CKS_Msk = 0x3
	// PCLK clock (n = 0)
	SCI1_SMR_CKS_00 = 0x0
	// PCLK/4 clock (n = 1)
	SCI1_SMR_CKS_01 = 0x1
	// PCLK/16 clock (n = 2)
	SCI1_SMR_CKS_10 = 0x2
	// PCLK/64 clock (n = 3)
	SCI1_SMR_CKS_11 = 0x3
	// Position of MP field.
	SCI1_SMR_MP_Pos = 0x2
	// Bit mask of MP field.
	SCI1_SMR_MP_Msk = 0x4
	// Bit MP.
	SCI1_SMR_MP = 0x4
	// Disable multi-processor communications function
	SCI1_SMR_MP_0 = 0x0
	// Enable multi-processor communications function
	SCI1_SMR_MP_1 = 0x1
	// Position of STOP field.
	SCI1_SMR_STOP_Pos = 0x3
	// Bit mask of STOP field.
	SCI1_SMR_STOP_Msk = 0x8
	// Bit STOP.
	SCI1_SMR_STOP = 0x8
	// 1 stop bit
	SCI1_SMR_STOP_0 = 0x0
	// 2 stop bits
	SCI1_SMR_STOP_1 = 0x1
	// Position of PM field.
	SCI1_SMR_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI1_SMR_PM_Msk = 0x10
	// Bit PM.
	SCI1_SMR_PM = 0x10
	// Even parity
	SCI1_SMR_PM_0 = 0x0
	// Odd parity
	SCI1_SMR_PM_1 = 0x1
	// Position of PE field.
	SCI1_SMR_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI1_SMR_PE_Msk = 0x20
	// Bit PE.
	SCI1_SMR_PE = 0x20
	// When transmitting: Do not add parity bit When receiving: Do not check parity bit
	SCI1_SMR_PE_0 = 0x0
	// When transmitting: Add parity bit When receiving: Check parity bit
	SCI1_SMR_PE_1 = 0x1
	// Position of CHR field.
	SCI1_SMR_CHR_Pos = 0x6
	// Bit mask of CHR field.
	SCI1_SMR_CHR_Msk = 0x40
	// Bit CHR.
	SCI1_SMR_CHR = 0x40
	// SCMR.CHR1 = 0: Transmit/receive in 9-bit data length SCMR.CHR1 = 1: Transmit/receive in 8-bit data length (initial value)
	SCI1_SMR_CHR_0 = 0x0
	// SCMR.CHR1 = 0: Transmit/receive in 9-bit data length SCMR.CHR1 = 1: Transmit/receive in 7-bit data length
	SCI1_SMR_CHR_1 = 0x1
	// Position of CM field.
	SCI1_SMR_CM_Pos = 0x7
	// Bit mask of CM field.
	SCI1_SMR_CM_Msk = 0x80
	// Bit CM.
	SCI1_SMR_CM = 0x80
	// Asynchronous mode or simple IIC mode
	SCI1_SMR_CM_0 = 0x0
	// Clock synchronous mode or simple SPI mode
	SCI1_SMR_CM_1 = 0x1

	// SMR_SMCI: Serial Mode Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of CKS field.
	SCI1_SMR_SMCI_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI1_SMR_SMCI_CKS_Msk = 0x3
	// PCLK clock (n = 0)
	SCI1_SMR_SMCI_CKS_00 = 0x0
	// PCLK/4 clock (n = 1)
	SCI1_SMR_SMCI_CKS_01 = 0x1
	// PCLK/16 clock (n = 2)
	SCI1_SMR_SMCI_CKS_10 = 0x2
	// PCLK/64 clock (n = 3)
	SCI1_SMR_SMCI_CKS_11 = 0x3
	// Position of BCP field.
	SCI1_SMR_SMCI_BCP_Pos = 0x2
	// Bit mask of BCP field.
	SCI1_SMR_SMCI_BCP_Msk = 0xc
	// Position of PM field.
	SCI1_SMR_SMCI_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI1_SMR_SMCI_PM_Msk = 0x10
	// Bit PM.
	SCI1_SMR_SMCI_PM = 0x10
	// Even parity
	SCI1_SMR_SMCI_PM_0 = 0x0
	// Odd parity
	SCI1_SMR_SMCI_PM_1 = 0x1
	// Position of PE field.
	SCI1_SMR_SMCI_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI1_SMR_SMCI_PE_Msk = 0x20
	// Bit PE.
	SCI1_SMR_SMCI_PE = 0x20
	// Position of BLK field.
	SCI1_SMR_SMCI_BLK_Pos = 0x6
	// Bit mask of BLK field.
	SCI1_SMR_SMCI_BLK_Msk = 0x40
	// Bit BLK.
	SCI1_SMR_SMCI_BLK = 0x40
	// Normal mode operation
	SCI1_SMR_SMCI_BLK_0 = 0x0
	// Block transfer mode operation
	SCI1_SMR_SMCI_BLK_1 = 0x1
	// Position of GM field.
	SCI1_SMR_SMCI_GM_Pos = 0x7
	// Bit mask of GM field.
	SCI1_SMR_SMCI_GM_Msk = 0x80
	// Bit GM.
	SCI1_SMR_SMCI_GM = 0x80
	// Normal mode operation
	SCI1_SMR_SMCI_GM_0 = 0x0
	// GSM mode operation
	SCI1_SMR_SMCI_GM_1 = 0x1

	// SCR: Serial Control Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
	// Position of CKE field.
	SCI1_SCR_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI1_SCR_CKE_Msk = 0x3
	// In asynchronous mode, the SCKn pin is available for use as an I/O port based on the I/O port settings. In clock synchronous mode, the SCKn pin functions as the clock output pin.
	SCI1_SCR_CKE_00 = 0x0
	// In asynchronous mode, a clock with the same frequency as the bit rate is output from the SCKn pin. In clock synchronous mode, the SCKn pin functions as the clock output pin.
	SCI1_SCR_CKE_01 = 0x1
	// Position of TEIE field.
	SCI1_SCR_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI1_SCR_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI1_SCR_TEIE = 0x4
	// Disable SCIn_TEI interrupt requests
	SCI1_SCR_TEIE_0 = 0x0
	// Enable SCIn_TEI interrupt requests
	SCI1_SCR_TEIE_1 = 0x1
	// Position of MPIE field.
	SCI1_SCR_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI1_SCR_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI1_SCR_MPIE = 0x8
	// Normal reception
	SCI1_SCR_MPIE_0 = 0x0
	// When data with the multi-processor bit set to 0 is received, the data is not read, and setting the status flags RDRF, ORER, and FER in SSR to 1 and the status flags SYER, PFER, and SBER in MESR are disabled. When data with the multi-processor bit set to 1 is received, the MPIE bit is automatically set to 0, and normal reception is resumed.
	SCI1_SCR_MPIE_1 = 0x1
	// Position of RE field.
	SCI1_SCR_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI1_SCR_RE_Msk = 0x10
	// Bit RE.
	SCI1_SCR_RE = 0x10
	// Disable serial reception
	SCI1_SCR_RE_0 = 0x0
	// Enable serial reception
	SCI1_SCR_RE_1 = 0x1
	// Position of TE field.
	SCI1_SCR_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI1_SCR_TE_Msk = 0x20
	// Bit TE.
	SCI1_SCR_TE = 0x20
	// Disable serial transmission
	SCI1_SCR_TE_0 = 0x0
	// Enable serial transmission
	SCI1_SCR_TE_1 = 0x1
	// Position of RIE field.
	SCI1_SCR_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI1_SCR_RIE_Msk = 0x40
	// Bit RIE.
	SCI1_SCR_RIE = 0x40
	// Disable SCIn_RXI and SCIn_ERI interrupt requests
	SCI1_SCR_RIE_0 = 0x0
	// Enable SCIn_RXI and SCIn_ERI interrupt requests
	SCI1_SCR_RIE_1 = 0x1
	// Position of TIE field.
	SCI1_SCR_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI1_SCR_TIE_Msk = 0x80
	// Bit TIE.
	SCI1_SCR_TIE = 0x80
	// Disable SCIn_TXI interrupt requests
	SCI1_SCR_TIE_0 = 0x0
	// Enable SCIn_TXI interrupt requests
	SCI1_SCR_TIE_1 = 0x1

	// SCR_SMCI: Serial Control Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of CKE field.
	SCI1_SCR_SMCI_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI1_SCR_SMCI_CKE_Msk = 0x3
	// When SMR_SMCI.GM = 0: Disable output The SCKn pin is available for use as an I/O port if set up in the I/O port settings When SMR_SMCI.GM = 1: Fix output low
	SCI1_SCR_SMCI_CKE_00 = 0x0
	// When SMR_SMCI.GM = 0: Output clock When SMR_SMCI.GM = 1: Output clock
	SCI1_SCR_SMCI_CKE_01 = 0x1
	// When SMR_SMCI.GM = 0: Setting prohibited When SMR_SMCI.GM = 1: Fix output high
	SCI1_SCR_SMCI_CKE_10 = 0x2
	// When SMR_SMCI.GM = 0: Setting prohibited When SMR_SMCI.GM = 1: Output clock
	SCI1_SCR_SMCI_CKE_11 = 0x3
	// Position of TEIE field.
	SCI1_SCR_SMCI_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI1_SCR_SMCI_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI1_SCR_SMCI_TEIE = 0x4
	// Position of MPIE field.
	SCI1_SCR_SMCI_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI1_SCR_SMCI_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI1_SCR_SMCI_MPIE = 0x8
	// Position of RE field.
	SCI1_SCR_SMCI_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI1_SCR_SMCI_RE_Msk = 0x10
	// Bit RE.
	SCI1_SCR_SMCI_RE = 0x10
	// Disable serial reception
	SCI1_SCR_SMCI_RE_0 = 0x0
	// Enable serial reception
	SCI1_SCR_SMCI_RE_1 = 0x1
	// Position of TE field.
	SCI1_SCR_SMCI_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI1_SCR_SMCI_TE_Msk = 0x20
	// Bit TE.
	SCI1_SCR_SMCI_TE = 0x20
	// Disable serial transmission
	SCI1_SCR_SMCI_TE_0 = 0x0
	// Enable serial transmission
	SCI1_SCR_SMCI_TE_1 = 0x1
	// Position of RIE field.
	SCI1_SCR_SMCI_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI1_SCR_SMCI_RIE_Msk = 0x40
	// Bit RIE.
	SCI1_SCR_SMCI_RIE = 0x40
	// Disable SCIn_RXI and SCIn_ERI interrupt requests
	SCI1_SCR_SMCI_RIE_0 = 0x0
	// Enable SCIn_RXI and SCIn_ERI interrupt requests
	SCI1_SCR_SMCI_RIE_1 = 0x1
	// Position of TIE field.
	SCI1_SCR_SMCI_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI1_SCR_SMCI_TIE_Msk = 0x80
	// Bit TIE.
	SCI1_SCR_SMCI_TIE = 0x80
	// Disable SCIn_TXI interrupt requests
	SCI1_SCR_SMCI_TIE_0 = 0x0
	// Enable SCIn_TXI interrupt requests
	SCI1_SCR_SMCI_TIE_1 = 0x1

	// SSR: Serial Status Register for Non-Smart Card Interface and Non-FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0, and MMR.MANEN = 0)
	// Position of MPBT field.
	SCI1_SSR_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI1_SSR_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI1_SSR_MPBT = 0x1
	// Data transmission cycle
	SCI1_SSR_MPBT_0 = 0x0
	// ID transmission cycle
	SCI1_SSR_MPBT_1 = 0x1
	// Position of MPB field.
	SCI1_SSR_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI1_SSR_MPB_Msk = 0x2
	// Bit MPB.
	SCI1_SSR_MPB = 0x2
	// Data transmission cycle
	SCI1_SSR_MPB_0 = 0x0
	// ID transmission cycle
	SCI1_SSR_MPB_1 = 0x1
	// Position of TEND field.
	SCI1_SSR_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI1_SSR_TEND_Msk = 0x4
	// Bit TEND.
	SCI1_SSR_TEND = 0x4
	// A character is being transmitted
	SCI1_SSR_TEND_0 = 0x0
	// Character transfer is complete
	SCI1_SSR_TEND_1 = 0x1
	// Position of PER field.
	SCI1_SSR_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI1_SSR_PER_Msk = 0x8
	// Bit PER.
	SCI1_SSR_PER = 0x8
	// No parity error occurred
	SCI1_SSR_PER_0 = 0x0
	// Parity error occurred
	SCI1_SSR_PER_1 = 0x1
	// Position of FER field.
	SCI1_SSR_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI1_SSR_FER_Msk = 0x10
	// Bit FER.
	SCI1_SSR_FER = 0x10
	// No framing error occurred
	SCI1_SSR_FER_0 = 0x0
	// Framing error occurred
	SCI1_SSR_FER_1 = 0x1
	// Position of ORER field.
	SCI1_SSR_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI1_SSR_ORER_Msk = 0x20
	// Bit ORER.
	SCI1_SSR_ORER = 0x20
	// No overrun error occurred
	SCI1_SSR_ORER_0 = 0x0
	// Overrun error occurred
	SCI1_SSR_ORER_1 = 0x1
	// Position of RDRF field.
	SCI1_SSR_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI1_SSR_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI1_SSR_RDRF = 0x40
	// No received data in RDR register
	SCI1_SSR_RDRF_0 = 0x0
	// Received data in RDR register
	SCI1_SSR_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI1_SSR_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI1_SSR_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI1_SSR_TDRE = 0x80
	// Transmit data in TDR register
	SCI1_SSR_TDRE_0 = 0x0
	// No transmit data in TDR register
	SCI1_SSR_TDRE_1 = 0x1

	// SSR_FIFO: Serial Status Register for Non-Smart Card Interface and FIFO Mode (SCMR.SMIF = 0, FCR.FM = 1, and MMR.MANEN = 0)
	// Position of DR field.
	SCI1_SSR_FIFO_DR_Pos = 0x0
	// Bit mask of DR field.
	SCI1_SSR_FIFO_DR_Msk = 0x1
	// Bit DR.
	SCI1_SSR_FIFO_DR = 0x1
	// Receiving is in progress, or no received data remains in FRDRHL after successfully completed reception (receive FIFO empty)
	SCI1_SSR_FIFO_DR_0 = 0x0
	// Next receive data is not received for a period after normal receiving is complete, when the amount of data stored in the FIFO is equal to or less than the receive triggering number
	SCI1_SSR_FIFO_DR_1 = 0x1
	// Position of TEND field.
	SCI1_SSR_FIFO_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI1_SSR_FIFO_TEND_Msk = 0x4
	// Bit TEND.
	SCI1_SSR_FIFO_TEND = 0x4
	// A character is being transmitted
	SCI1_SSR_FIFO_TEND_0 = 0x0
	// Character transfer is complete
	SCI1_SSR_FIFO_TEND_1 = 0x1
	// Position of PER field.
	SCI1_SSR_FIFO_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI1_SSR_FIFO_PER_Msk = 0x8
	// Bit PER.
	SCI1_SSR_FIFO_PER = 0x8
	// No parity error occurred
	SCI1_SSR_FIFO_PER_0 = 0x0
	// Parity error occurred
	SCI1_SSR_FIFO_PER_1 = 0x1
	// Position of FER field.
	SCI1_SSR_FIFO_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI1_SSR_FIFO_FER_Msk = 0x10
	// Bit FER.
	SCI1_SSR_FIFO_FER = 0x10
	// No framing error occurred
	SCI1_SSR_FIFO_FER_0 = 0x0
	// Framing error occurred
	SCI1_SSR_FIFO_FER_1 = 0x1
	// Position of ORER field.
	SCI1_SSR_FIFO_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI1_SSR_FIFO_ORER_Msk = 0x20
	// Bit ORER.
	SCI1_SSR_FIFO_ORER = 0x20
	// No overrun error occurred
	SCI1_SSR_FIFO_ORER_0 = 0x0
	// Overrun error occurred
	SCI1_SSR_FIFO_ORER_1 = 0x1
	// Position of RDF field.
	SCI1_SSR_FIFO_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI1_SSR_FIFO_RDF_Msk = 0x40
	// Bit RDF.
	SCI1_SSR_FIFO_RDF = 0x40
	// The amount of receive data written in FRDRHL is less than the specified receive triggering number
	SCI1_SSR_FIFO_RDF_0 = 0x0
	// The amount of receive data written in FRDRHL is equal to or greater than the specified receive triggering number
	SCI1_SSR_FIFO_RDF_1 = 0x1
	// Position of TDFE field.
	SCI1_SSR_FIFO_TDFE_Pos = 0x7
	// Bit mask of TDFE field.
	SCI1_SSR_FIFO_TDFE_Msk = 0x80
	// Bit TDFE.
	SCI1_SSR_FIFO_TDFE = 0x80
	// The amount of transmit data written in FTDRHL exceeds the specified transmit triggering number
	SCI1_SSR_FIFO_TDFE_0 = 0x0
	// The amount of transmit data written in FTDRHL is equal to or less than the specified transmit triggering number
	SCI1_SSR_FIFO_TDFE_1 = 0x1

	// SSR_MANC: Serial Status Register for Manchester Mode (SCMR.SMIF = 0, and MMR.MANEN = 1)
	// Position of MER field.
	SCI1_SSR_MANC_MER_Pos = 0x0
	// Bit mask of MER field.
	SCI1_SSR_MANC_MER_Msk = 0x1
	// Bit MER.
	SCI1_SSR_MANC_MER = 0x1
	// No Manchester error occurred
	SCI1_SSR_MANC_MER_0 = 0x0
	// Manchester error has occurred
	SCI1_SSR_MANC_MER_1 = 0x1
	// Position of MPB field.
	SCI1_SSR_MANC_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI1_SSR_MANC_MPB_Msk = 0x2
	// Bit MPB.
	SCI1_SSR_MANC_MPB = 0x2
	// Data transmission cycles
	SCI1_SSR_MANC_MPB_0 = 0x0
	// ID transmission cycles
	SCI1_SSR_MANC_MPB_1 = 0x1
	// Position of TEND field.
	SCI1_SSR_MANC_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI1_SSR_MANC_TEND_Msk = 0x4
	// Bit TEND.
	SCI1_SSR_MANC_TEND = 0x4
	// A character is being transmitted
	SCI1_SSR_MANC_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI1_SSR_MANC_TEND_1 = 0x1
	// Position of PER field.
	SCI1_SSR_MANC_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI1_SSR_MANC_PER_Msk = 0x8
	// Bit PER.
	SCI1_SSR_MANC_PER = 0x8
	// No parity error occurred
	SCI1_SSR_MANC_PER_0 = 0x0
	// A parity error has occurred
	SCI1_SSR_MANC_PER_1 = 0x1
	// Position of FER field.
	SCI1_SSR_MANC_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI1_SSR_MANC_FER_Msk = 0x10
	// Bit FER.
	SCI1_SSR_MANC_FER = 0x10
	// No framing error occurred
	SCI1_SSR_MANC_FER_0 = 0x0
	// A framing error has occurred
	SCI1_SSR_MANC_FER_1 = 0x1
	// Position of ORER field.
	SCI1_SSR_MANC_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI1_SSR_MANC_ORER_Msk = 0x20
	// Bit ORER.
	SCI1_SSR_MANC_ORER = 0x20
	// No overrun error occurred
	SCI1_SSR_MANC_ORER_0 = 0x0
	// An overrun error has occurred
	SCI1_SSR_MANC_ORER_1 = 0x1
	// Position of RDRF field.
	SCI1_SSR_MANC_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI1_SSR_MANC_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI1_SSR_MANC_RDRF = 0x40
	// No received data is in RDR register
	SCI1_SSR_MANC_RDRF_0 = 0x0
	// Received data is in RDR register
	SCI1_SSR_MANC_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI1_SSR_MANC_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI1_SSR_MANC_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI1_SSR_MANC_TDRE = 0x80
	// Transmit data is in TDR register
	SCI1_SSR_MANC_TDRE_0 = 0x0
	// No transmit data is in TDR register
	SCI1_SSR_MANC_TDRE_1 = 0x1

	// SSR_SMCI: Serial Status Register for Smart Card Interface Mode (SCMR.SMIF = 1, and MMR.MANEN = 0)
	// Position of MPBT field.
	SCI1_SSR_SMCI_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI1_SSR_SMCI_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI1_SSR_SMCI_MPBT = 0x1
	// Position of MPB field.
	SCI1_SSR_SMCI_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI1_SSR_SMCI_MPB_Msk = 0x2
	// Bit MPB.
	SCI1_SSR_SMCI_MPB = 0x2
	// Position of TEND field.
	SCI1_SSR_SMCI_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI1_SSR_SMCI_TEND_Msk = 0x4
	// Bit TEND.
	SCI1_SSR_SMCI_TEND = 0x4
	// A character is being transmitted
	SCI1_SSR_SMCI_TEND_0 = 0x0
	// Character transfer is complete
	SCI1_SSR_SMCI_TEND_1 = 0x1
	// Position of PER field.
	SCI1_SSR_SMCI_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI1_SSR_SMCI_PER_Msk = 0x8
	// Bit PER.
	SCI1_SSR_SMCI_PER = 0x8
	// No parity error occurred
	SCI1_SSR_SMCI_PER_0 = 0x0
	// Parity error occurred
	SCI1_SSR_SMCI_PER_1 = 0x1
	// Position of ERS field.
	SCI1_SSR_SMCI_ERS_Pos = 0x4
	// Bit mask of ERS field.
	SCI1_SSR_SMCI_ERS_Msk = 0x10
	// Bit ERS.
	SCI1_SSR_SMCI_ERS = 0x10
	// No low error signal response
	SCI1_SSR_SMCI_ERS_0 = 0x0
	// Low error signal response occurred
	SCI1_SSR_SMCI_ERS_1 = 0x1
	// Position of ORER field.
	SCI1_SSR_SMCI_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI1_SSR_SMCI_ORER_Msk = 0x20
	// Bit ORER.
	SCI1_SSR_SMCI_ORER = 0x20
	// No overrun error occurred
	SCI1_SSR_SMCI_ORER_0 = 0x0
	// Overrun error occurred
	SCI1_SSR_SMCI_ORER_1 = 0x1
	// Position of RDRF field.
	SCI1_SSR_SMCI_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI1_SSR_SMCI_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI1_SSR_SMCI_RDRF = 0x40
	// No received data in RDR register
	SCI1_SSR_SMCI_RDRF_0 = 0x0
	// Received data in RDR register
	SCI1_SSR_SMCI_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI1_SSR_SMCI_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI1_SSR_SMCI_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI1_SSR_SMCI_TDRE = 0x80
	// Transmit data in TDR register
	SCI1_SSR_SMCI_TDRE_0 = 0x0
	// No transmit data in TDR register
	SCI1_SSR_SMCI_TDRE_1 = 0x1

	// SCMR: Smart Card Mode Register
	// Position of SMIF field.
	SCI1_SCMR_SMIF_Pos = 0x0
	// Bit mask of SMIF field.
	SCI1_SCMR_SMIF_Msk = 0x1
	// Bit SMIF.
	SCI1_SCMR_SMIF = 0x1
	// Non-smart card interface mode (asynchronous mode, clock synchronous mode, simple SPI mode, or simple IIC mode)
	SCI1_SCMR_SMIF_0 = 0x0
	// Smart card interface mode
	SCI1_SCMR_SMIF_1 = 0x1
	// Position of SINV field.
	SCI1_SCMR_SINV_Pos = 0x2
	// Bit mask of SINV field.
	SCI1_SCMR_SINV_Msk = 0x4
	// Bit SINV.
	SCI1_SCMR_SINV = 0x4
	// TDR contents are transmitted as they are. Received data is stored as received in the RDR register.
	SCI1_SCMR_SINV_0 = 0x0
	// TDR register contents are inverted before transmission. Receive data is stored in inverted form in the RDR register.
	SCI1_SCMR_SINV_1 = 0x1
	// Position of SDIR field.
	SCI1_SCMR_SDIR_Pos = 0x3
	// Bit mask of SDIR field.
	SCI1_SCMR_SDIR_Msk = 0x8
	// Bit SDIR.
	SCI1_SCMR_SDIR = 0x8
	// Transfer LSB-first
	SCI1_SCMR_SDIR_0 = 0x0
	// Transfer MSB-first
	SCI1_SCMR_SDIR_1 = 0x1
	// Position of CHR1 field.
	SCI1_SCMR_CHR1_Pos = 0x4
	// Bit mask of CHR1 field.
	SCI1_SCMR_CHR1_Msk = 0x10
	// Bit CHR1.
	SCI1_SCMR_CHR1 = 0x10
	// SMR.CHR = 0: Transmit/receive in 9-bit data length SMR.CHR = 1: Transmit/receive in 9-bit data length
	SCI1_SCMR_CHR1_0 = 0x0
	// SMR.CHR = 0: Transmit/receive in 8-bit data length (initial value) SMR.CHR = 1: Transmit/receive in 7-bit data length
	SCI1_SCMR_CHR1_1 = 0x1
	// Position of BCP2 field.
	SCI1_SCMR_BCP2_Pos = 0x7
	// Bit mask of BCP2 field.
	SCI1_SCMR_BCP2_Msk = 0x80
	// Bit BCP2.
	SCI1_SCMR_BCP2 = 0x80

	// SNFR: Noise Filter Setting Register
	// Position of NFCS field.
	SCI1_SNFR_NFCS_Pos = 0x0
	// Bit mask of NFCS field.
	SCI1_SNFR_NFCS_Msk = 0x7
	// In asynchronous mode: Use clock signal divided by 1 with noise filter In simple I2C mode: Setting prohibited
	SCI1_SNFR_NFCS_000 = 0x0
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 1 with noise filter
	SCI1_SNFR_NFCS_001 = 0x1
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 2 with noise filter
	SCI1_SNFR_NFCS_010 = 0x2
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 4 with noise filter
	SCI1_SNFR_NFCS_011 = 0x3
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 8 with noise filter
	SCI1_SNFR_NFCS_100 = 0x4

	// SIMR1: IIC Mode Register 1
	// Position of IICM field.
	SCI1_SIMR1_IICM_Pos = 0x0
	// Bit mask of IICM field.
	SCI1_SIMR1_IICM_Msk = 0x1
	// Bit IICM.
	SCI1_SIMR1_IICM = 0x1
	// SCMR.SMIF = 0: Asynchronous mode (including multi-processor mode), clock synchronous mode, or simple SPI mode SCMR.SMIF = 1: Smart card interface mode
	SCI1_SIMR1_IICM_0 = 0x0
	// SCMR.SMIF = 0: Simple IIC mode SCMR.SMIF = 1: Setting prohibited
	SCI1_SIMR1_IICM_1 = 0x1
	// Position of IICDL field.
	SCI1_SIMR1_IICDL_Pos = 0x3
	// Bit mask of IICDL field.
	SCI1_SIMR1_IICDL_Msk = 0xf8
	// No output delay
	SCI1_SIMR1_IICDL_0x00 = 0x0

	// SIMR2: IIC Mode Register 2
	// Position of IICINTM field.
	SCI1_SIMR2_IICINTM_Pos = 0x0
	// Bit mask of IICINTM field.
	SCI1_SIMR2_IICINTM_Msk = 0x1
	// Bit IICINTM.
	SCI1_SIMR2_IICINTM = 0x1
	// Use ACK/NACK interrupts
	SCI1_SIMR2_IICINTM_0 = 0x0
	// Use reception and transmission interrupts
	SCI1_SIMR2_IICINTM_1 = 0x1
	// Position of IICCSC field.
	SCI1_SIMR2_IICCSC_Pos = 0x1
	// Bit mask of IICCSC field.
	SCI1_SIMR2_IICCSC_Msk = 0x2
	// Bit IICCSC.
	SCI1_SIMR2_IICCSC = 0x2
	// Do not synchronize with clock signal
	SCI1_SIMR2_IICCSC_0 = 0x0
	// Synchronize with clock signal
	SCI1_SIMR2_IICCSC_1 = 0x1
	// Position of IICACKT field.
	SCI1_SIMR2_IICACKT_Pos = 0x5
	// Bit mask of IICACKT field.
	SCI1_SIMR2_IICACKT_Msk = 0x20
	// Bit IICACKT.
	SCI1_SIMR2_IICACKT = 0x20
	// ACK transmission
	SCI1_SIMR2_IICACKT_0 = 0x0
	// NACK transmission and ACK/NACK reception
	SCI1_SIMR2_IICACKT_1 = 0x1

	// SIMR3: IIC Mode Register 3
	// Position of IICSTAREQ field.
	SCI1_SIMR3_IICSTAREQ_Pos = 0x0
	// Bit mask of IICSTAREQ field.
	SCI1_SIMR3_IICSTAREQ_Msk = 0x1
	// Bit IICSTAREQ.
	SCI1_SIMR3_IICSTAREQ = 0x1
	// Do not generate start condition
	SCI1_SIMR3_IICSTAREQ_0 = 0x0
	// Generate start condition
	SCI1_SIMR3_IICSTAREQ_1 = 0x1
	// Position of IICRSTAREQ field.
	SCI1_SIMR3_IICRSTAREQ_Pos = 0x1
	// Bit mask of IICRSTAREQ field.
	SCI1_SIMR3_IICRSTAREQ_Msk = 0x2
	// Bit IICRSTAREQ.
	SCI1_SIMR3_IICRSTAREQ = 0x2
	// Do not generate restart condition
	SCI1_SIMR3_IICRSTAREQ_0 = 0x0
	// Generate restart condition
	SCI1_SIMR3_IICRSTAREQ_1 = 0x1
	// Position of IICSTPREQ field.
	SCI1_SIMR3_IICSTPREQ_Pos = 0x2
	// Bit mask of IICSTPREQ field.
	SCI1_SIMR3_IICSTPREQ_Msk = 0x4
	// Bit IICSTPREQ.
	SCI1_SIMR3_IICSTPREQ = 0x4
	// Do not generate stop condition
	SCI1_SIMR3_IICSTPREQ_0 = 0x0
	// Generate stop condition
	SCI1_SIMR3_IICSTPREQ_1 = 0x1
	// Position of IICSTIF field.
	SCI1_SIMR3_IICSTIF_Pos = 0x3
	// Bit mask of IICSTIF field.
	SCI1_SIMR3_IICSTIF_Msk = 0x8
	// Bit IICSTIF.
	SCI1_SIMR3_IICSTIF = 0x8
	// No requests are being made for generating conditions, or a condition is being generated
	SCI1_SIMR3_IICSTIF_0 = 0x0
	// Generation of start, restart, or stop condition is complete. When 0 is written to IICSTIF, it is set to 0
	SCI1_SIMR3_IICSTIF_1 = 0x1
	// Position of IICSDAS field.
	SCI1_SIMR3_IICSDAS_Pos = 0x4
	// Bit mask of IICSDAS field.
	SCI1_SIMR3_IICSDAS_Msk = 0x30
	// Output serial data
	SCI1_SIMR3_IICSDAS_00 = 0x0
	// Generate start, restart, or stop condition
	SCI1_SIMR3_IICSDAS_01 = 0x1
	// Output low on SDAn pin
	SCI1_SIMR3_IICSDAS_10 = 0x2
	// Drive SDAn pin to high-impedance state
	SCI1_SIMR3_IICSDAS_11 = 0x3
	// Position of IICSCLS field.
	SCI1_SIMR3_IICSCLS_Pos = 0x6
	// Bit mask of IICSCLS field.
	SCI1_SIMR3_IICSCLS_Msk = 0xc0
	// Output serial clock
	SCI1_SIMR3_IICSCLS_00 = 0x0
	// Generate start, restart, or stop condition
	SCI1_SIMR3_IICSCLS_01 = 0x1
	// Output low on SCLn pin
	SCI1_SIMR3_IICSCLS_10 = 0x2
	// Drive SCLn pin to high-impedance state
	SCI1_SIMR3_IICSCLS_11 = 0x3

	// SISR: IIC Status Register
	// Position of IICACKR field.
	SCI1_SISR_IICACKR_Pos = 0x0
	// Bit mask of IICACKR field.
	SCI1_SISR_IICACKR_Msk = 0x1
	// Bit IICACKR.
	SCI1_SISR_IICACKR = 0x1
	// ACK received
	SCI1_SISR_IICACKR_0 = 0x0
	// NACK received
	SCI1_SISR_IICACKR_1 = 0x1

	// SPMR: SPI Mode Register
	// Position of SSE field.
	SCI1_SPMR_SSE_Pos = 0x0
	// Bit mask of SSE field.
	SCI1_SPMR_SSE_Msk = 0x1
	// Bit SSE.
	SCI1_SPMR_SSE = 0x1
	// Disable SSn pin function
	SCI1_SPMR_SSE_0 = 0x0
	// Enable SSn pin function
	SCI1_SPMR_SSE_1 = 0x1
	// Position of CTSE field.
	SCI1_SPMR_CTSE_Pos = 0x1
	// Bit mask of CTSE field.
	SCI1_SPMR_CTSE_Msk = 0x2
	// Bit CTSE.
	SCI1_SPMR_CTSE = 0x2
	// Disable CTS function (enable RTS output function)
	SCI1_SPMR_CTSE_0 = 0x0
	// Enable CTS function
	SCI1_SPMR_CTSE_1 = 0x1
	// Position of MSS field.
	SCI1_SPMR_MSS_Pos = 0x2
	// Bit mask of MSS field.
	SCI1_SPMR_MSS_Msk = 0x4
	// Bit MSS.
	SCI1_SPMR_MSS = 0x4
	// Transmit through TXDn pin and receive through RXDn pin (master mode)
	SCI1_SPMR_MSS_0 = 0x0
	// Receive through TXDn pin and transmit through RXDn pin (slave mode)
	SCI1_SPMR_MSS_1 = 0x1
	// Position of CTSPEN field.
	SCI1_SPMR_CTSPEN_Pos = 0x3
	// Bit mask of CTSPEN field.
	SCI1_SPMR_CTSPEN_Msk = 0x8
	// Bit CTSPEN.
	SCI1_SPMR_CTSPEN = 0x8
	// Alternate setting to use CTS and RTS functions as either one terminal
	SCI1_SPMR_CTSPEN_0 = 0x0
	// Dedicated setting for separately using CTS and RTS functions with 2 terminals These bits for the other SCI channels than SCIn (n = 0, 3, 4, 9) are reserved.
	SCI1_SPMR_CTSPEN_1 = 0x1
	// Position of MFF field.
	SCI1_SPMR_MFF_Pos = 0x4
	// Bit mask of MFF field.
	SCI1_SPMR_MFF_Msk = 0x10
	// Bit MFF.
	SCI1_SPMR_MFF = 0x10
	// No mode fault error
	SCI1_SPMR_MFF_0 = 0x0
	// Mode fault error
	SCI1_SPMR_MFF_1 = 0x1
	// Position of CKPOL field.
	SCI1_SPMR_CKPOL_Pos = 0x6
	// Bit mask of CKPOL field.
	SCI1_SPMR_CKPOL_Msk = 0x40
	// Bit CKPOL.
	SCI1_SPMR_CKPOL = 0x40
	// Do not invert clock polarity
	SCI1_SPMR_CKPOL_0 = 0x0
	// Invert clock polarity
	SCI1_SPMR_CKPOL_1 = 0x1
	// Position of CKPH field.
	SCI1_SPMR_CKPH_Pos = 0x7
	// Bit mask of CKPH field.
	SCI1_SPMR_CKPH_Msk = 0x80
	// Bit CKPH.
	SCI1_SPMR_CKPH = 0x80
	// Do not delay clock
	SCI1_SPMR_CKPH_0 = 0x0
	// Delay clock
	SCI1_SPMR_CKPH_1 = 0x1

	// FTDRHL: Transmit FIFO Data Register
	// Position of TDAT field.
	SCI1_FTDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI1_FTDRHL_TDAT_Msk = 0x1ff
	// Position of MPBT field.
	SCI1_FTDRHL_MPBT_Pos = 0x9
	// Bit mask of MPBT field.
	SCI1_FTDRHL_MPBT_Msk = 0x200
	// Bit MPBT.
	SCI1_FTDRHL_MPBT = 0x200
	// Data transmission cycle
	SCI1_FTDRHL_MPBT_0 = 0x0
	// ID transmission cycle
	SCI1_FTDRHL_MPBT_1 = 0x1

	// TDRHL: Transmit Data Register for Non-Manchester mode (MMR.MANEN = 0)
	// Position of TDAT field.
	SCI1_TDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI1_TDRHL_TDAT_Msk = 0x1ff

	// FTDRH: Transmit FIFO Data Register
	// Position of MPBT field.
	SCI1_FTDRH_MPBT_Pos = 0x1
	// Bit mask of MPBT field.
	SCI1_FTDRH_MPBT_Msk = 0x2
	// Bit MPBT.
	SCI1_FTDRH_MPBT = 0x2
	// Data transmission cycle
	SCI1_FTDRH_MPBT_0 = 0x0
	// ID transmission cycle
	SCI1_FTDRH_MPBT_1 = 0x1

	// FTDRL: Transmit FIFO Data Register
	// Position of TDAT field.
	SCI1_FTDRL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI1_FTDRL_TDAT_Msk = 0xff

	// FRDRHL: Receive FIFO Data Register
	// Position of RDAT field.
	SCI1_FRDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI1_FRDRHL_RDAT_Msk = 0x1ff
	// Position of MPB field.
	SCI1_FRDRHL_MPB_Pos = 0x9
	// Bit mask of MPB field.
	SCI1_FRDRHL_MPB_Msk = 0x200
	// Bit MPB.
	SCI1_FRDRHL_MPB = 0x200
	// Data transmission cycle
	SCI1_FRDRHL_MPB_0 = 0x0
	// ID transmission cycle
	SCI1_FRDRHL_MPB_1 = 0x1
	// Position of DR field.
	SCI1_FRDRHL_DR_Pos = 0xa
	// Bit mask of DR field.
	SCI1_FRDRHL_DR_Msk = 0x400
	// Bit DR.
	SCI1_FRDRHL_DR = 0x400
	// Receiving is in progress, or no received data remains in the FRDRH and FRDRL registers after successfully completed reception
	SCI1_FRDRHL_DR_0 = 0x0
	// Next receive data is not received for a period after successfully completed reception
	SCI1_FRDRHL_DR_1 = 0x1
	// Position of PER field.
	SCI1_FRDRHL_PER_Pos = 0xb
	// Bit mask of PER field.
	SCI1_FRDRHL_PER_Msk = 0x800
	// Bit PER.
	SCI1_FRDRHL_PER = 0x800
	// No parity error occurred in the first data of FRDRH and FRDRL
	SCI1_FRDRHL_PER_0 = 0x0
	// Parity error occurred in the first data of FRDRH and FRDRL
	SCI1_FRDRHL_PER_1 = 0x1
	// Position of FER field.
	SCI1_FRDRHL_FER_Pos = 0xc
	// Bit mask of FER field.
	SCI1_FRDRHL_FER_Msk = 0x1000
	// Bit FER.
	SCI1_FRDRHL_FER = 0x1000
	// No framing error occurred in the first data of FRDRH and FRDRL
	SCI1_FRDRHL_FER_0 = 0x0
	// Framing error occurred in the first data of FRDRH and FRDRL
	SCI1_FRDRHL_FER_1 = 0x1
	// Position of ORER field.
	SCI1_FRDRHL_ORER_Pos = 0xd
	// Bit mask of ORER field.
	SCI1_FRDRHL_ORER_Msk = 0x2000
	// Bit ORER.
	SCI1_FRDRHL_ORER = 0x2000
	// No overrun error occurred
	SCI1_FRDRHL_ORER_0 = 0x0
	// Overrun error occurred
	SCI1_FRDRHL_ORER_1 = 0x1
	// Position of RDF field.
	SCI1_FRDRHL_RDF_Pos = 0xe
	// Bit mask of RDF field.
	SCI1_FRDRHL_RDF_Msk = 0x4000
	// Bit RDF.
	SCI1_FRDRHL_RDF = 0x4000
	// The amount of receive data written in FRDRH and FRDRL is less than the specified receive triggering number
	SCI1_FRDRHL_RDF_0 = 0x0
	// The amount of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number
	SCI1_FRDRHL_RDF_1 = 0x1

	// RDRHL: Receive Data Register for Non-Manchester mode (MMR.MANEN = 0)
	// Position of RDAT field.
	SCI1_RDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI1_RDRHL_RDAT_Msk = 0x1ff

	// FRDRH: Receive FIFO Data Register
	// Position of MPB field.
	SCI1_FRDRH_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI1_FRDRH_MPB_Msk = 0x2
	// Bit MPB.
	SCI1_FRDRH_MPB = 0x2
	// Data transmission cycle
	SCI1_FRDRH_MPB_0 = 0x0
	// ID transmission cycle
	SCI1_FRDRH_MPB_1 = 0x1
	// Position of DR field.
	SCI1_FRDRH_DR_Pos = 0x2
	// Bit mask of DR field.
	SCI1_FRDRH_DR_Msk = 0x4
	// Bit DR.
	SCI1_FRDRH_DR = 0x4
	// Receiving is in progress, or no received data remains in the FRDRH and FRDRL registers after successfully completed reception
	SCI1_FRDRH_DR_0 = 0x0
	// Next receive data is not received for a period after successfully completed reception
	SCI1_FRDRH_DR_1 = 0x1
	// Position of PER field.
	SCI1_FRDRH_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI1_FRDRH_PER_Msk = 0x8
	// Bit PER.
	SCI1_FRDRH_PER = 0x8
	// No parity error occurred in the first data of FRDRH and FRDRL
	SCI1_FRDRH_PER_0 = 0x0
	// Parity error occurred in the first data of FRDRH and FRDRL
	SCI1_FRDRH_PER_1 = 0x1
	// Position of FER field.
	SCI1_FRDRH_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI1_FRDRH_FER_Msk = 0x10
	// Bit FER.
	SCI1_FRDRH_FER = 0x10
	// No framing error occurred in the first data of FRDRH and FRDRL
	SCI1_FRDRH_FER_0 = 0x0
	// Framing error occurred in the first data of FRDRH and FRDRL
	SCI1_FRDRH_FER_1 = 0x1
	// Position of ORER field.
	SCI1_FRDRH_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI1_FRDRH_ORER_Msk = 0x20
	// Bit ORER.
	SCI1_FRDRH_ORER = 0x20
	// No overrun error occurred
	SCI1_FRDRH_ORER_0 = 0x0
	// Overrun error occurred
	SCI1_FRDRH_ORER_1 = 0x1
	// Position of RDF field.
	SCI1_FRDRH_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI1_FRDRH_RDF_Msk = 0x40
	// Bit RDF.
	SCI1_FRDRH_RDF = 0x40
	// The amount of receive data written in FRDRH and FRDRL is less than the specified receive triggering number
	SCI1_FRDRH_RDF_0 = 0x0
	// The amount of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number
	SCI1_FRDRH_RDF_1 = 0x1

	// FRDRL: Receive FIFO Data Register
	// Position of RDAT field.
	SCI1_FRDRL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI1_FRDRL_RDAT_Msk = 0xff

	// DCCR: Data Compare Match Control Register
	// Position of DCMF field.
	SCI1_DCCR_DCMF_Pos = 0x0
	// Bit mask of DCMF field.
	SCI1_DCCR_DCMF_Msk = 0x1
	// Bit DCMF.
	SCI1_DCCR_DCMF = 0x1
	// Not matched
	SCI1_DCCR_DCMF_0 = 0x0
	// Matched
	SCI1_DCCR_DCMF_1 = 0x1
	// Position of DPER field.
	SCI1_DCCR_DPER_Pos = 0x3
	// Bit mask of DPER field.
	SCI1_DCCR_DPER_Msk = 0x8
	// Bit DPER.
	SCI1_DCCR_DPER = 0x8
	// No parity error occurred
	SCI1_DCCR_DPER_0 = 0x0
	// Parity error occurred
	SCI1_DCCR_DPER_1 = 0x1
	// Position of DFER field.
	SCI1_DCCR_DFER_Pos = 0x4
	// Bit mask of DFER field.
	SCI1_DCCR_DFER_Msk = 0x10
	// Bit DFER.
	SCI1_DCCR_DFER = 0x10
	// No framing error occurred
	SCI1_DCCR_DFER_0 = 0x0
	// Framing error occurred
	SCI1_DCCR_DFER_1 = 0x1
	// Position of IDSEL field.
	SCI1_DCCR_IDSEL_Pos = 0x6
	// Bit mask of IDSEL field.
	SCI1_DCCR_IDSEL_Msk = 0x40
	// Bit IDSEL.
	SCI1_DCCR_IDSEL = 0x40
	// Always compare data regardless of the MPB bit value
	SCI1_DCCR_IDSEL_0 = 0x0
	// Only compare data when MPB bit = 1 (ID frame)
	SCI1_DCCR_IDSEL_1 = 0x1
	// Position of DCME field.
	SCI1_DCCR_DCME_Pos = 0x7
	// Bit mask of DCME field.
	SCI1_DCCR_DCME_Msk = 0x80
	// Bit DCME.
	SCI1_DCCR_DCME = 0x80
	// Disable address match function
	SCI1_DCCR_DCME_0 = 0x0
	// Enable address match function
	SCI1_DCCR_DCME_1 = 0x1

	// FCR: FIFO Control Register
	// Position of FM field.
	SCI1_FCR_FM_Pos = 0x0
	// Bit mask of FM field.
	SCI1_FCR_FM_Msk = 0x1
	// Bit FM.
	SCI1_FCR_FM = 0x1
	// Non-FIFO mode. Selects TDR/RDR or TDRHL/RDRHL for communication.
	SCI1_FCR_FM_0 = 0x0
	// FIFO mode. Selects FTDRHL/FRDRHL for communication.
	SCI1_FCR_FM_1 = 0x1
	// Position of RFRST field.
	SCI1_FCR_RFRST_Pos = 0x1
	// Bit mask of RFRST field.
	SCI1_FCR_RFRST_Msk = 0x2
	// Bit RFRST.
	SCI1_FCR_RFRST = 0x2
	// Do not reset FRDRHL
	SCI1_FCR_RFRST_0 = 0x0
	// Reset FRDRHL
	SCI1_FCR_RFRST_1 = 0x1
	// Position of TFRST field.
	SCI1_FCR_TFRST_Pos = 0x2
	// Bit mask of TFRST field.
	SCI1_FCR_TFRST_Msk = 0x4
	// Bit TFRST.
	SCI1_FCR_TFRST = 0x4
	// Do not reset FTDRHL
	SCI1_FCR_TFRST_0 = 0x0
	// Reset FTDRHL
	SCI1_FCR_TFRST_1 = 0x1
	// Position of DRES field.
	SCI1_FCR_DRES_Pos = 0x3
	// Bit mask of DRES field.
	SCI1_FCR_DRES_Msk = 0x8
	// Bit DRES.
	SCI1_FCR_DRES = 0x8
	// Receive data full interrupt (SCIn_RXI)
	SCI1_FCR_DRES_0 = 0x0
	// Receive error interrupt (SCIn_ERI)
	SCI1_FCR_DRES_1 = 0x1
	// Position of TTRG field.
	SCI1_FCR_TTRG_Pos = 0x4
	// Bit mask of TTRG field.
	SCI1_FCR_TTRG_Msk = 0xf0
	// Position of RTRG field.
	SCI1_FCR_RTRG_Pos = 0x8
	// Bit mask of RTRG field.
	SCI1_FCR_RTRG_Msk = 0xf00
	// Position of RSTRG field.
	SCI1_FCR_RSTRG_Pos = 0xc
	// Bit mask of RSTRG field.
	SCI1_FCR_RSTRG_Msk = 0xf000

	// FDR: FIFO Data Count Register
	// Position of R field.
	SCI1_FDR_R_Pos = 0x0
	// Bit mask of R field.
	SCI1_FDR_R_Msk = 0x1f
	// Position of T field.
	SCI1_FDR_T_Pos = 0x8
	// Bit mask of T field.
	SCI1_FDR_T_Msk = 0x1f00

	// LSR: Line Status Register
	// Position of ORER field.
	SCI1_LSR_ORER_Pos = 0x0
	// Bit mask of ORER field.
	SCI1_LSR_ORER_Msk = 0x1
	// Bit ORER.
	SCI1_LSR_ORER = 0x1
	// No overrun error occurred
	SCI1_LSR_ORER_0 = 0x0
	// Overrun error occurred
	SCI1_LSR_ORER_1 = 0x1
	// Position of FNUM field.
	SCI1_LSR_FNUM_Pos = 0x2
	// Bit mask of FNUM field.
	SCI1_LSR_FNUM_Msk = 0x7c
	// Position of PNUM field.
	SCI1_LSR_PNUM_Pos = 0x8
	// Bit mask of PNUM field.
	SCI1_LSR_PNUM_Msk = 0x1f00

	// CDR: Compare Match Data Register
	// Position of CMPD field.
	SCI1_CDR_CMPD_Pos = 0x0
	// Bit mask of CMPD field.
	SCI1_CDR_CMPD_Msk = 0x1ff

	// SPTR: Serial Port Register
	// Position of RXDMON field.
	SCI1_SPTR_RXDMON_Pos = 0x0
	// Bit mask of RXDMON field.
	SCI1_SPTR_RXDMON_Msk = 0x1
	// Bit RXDMON.
	SCI1_SPTR_RXDMON = 0x1
	// Position of SPB2DT field.
	SCI1_SPTR_SPB2DT_Pos = 0x1
	// Bit mask of SPB2DT field.
	SCI1_SPTR_SPB2DT_Msk = 0x2
	// Bit SPB2DT.
	SCI1_SPTR_SPB2DT = 0x2
	// Position of SPB2IO field.
	SCI1_SPTR_SPB2IO_Pos = 0x2
	// Bit mask of SPB2IO field.
	SCI1_SPTR_SPB2IO_Msk = 0x4
	// Bit SPB2IO.
	SCI1_SPTR_SPB2IO = 0x4
	// Do not output value of SPB2DT bit on TXDn pin
	SCI1_SPTR_SPB2IO_0 = 0x0
	// Output value of SPB2DT bit on TXDn pin
	SCI1_SPTR_SPB2IO_1 = 0x1
	// Position of RINV field.
	SCI1_SPTR_RINV_Pos = 0x4
	// Bit mask of RINV field.
	SCI1_SPTR_RINV_Msk = 0x10
	// Bit RINV.
	SCI1_SPTR_RINV = 0x10
	// Received data from RXDn is not inverted and input.
	SCI1_SPTR_RINV_0 = 0x0
	// Received data from RXDn is inverted and input.
	SCI1_SPTR_RINV_1 = 0x1
	// Position of TINV field.
	SCI1_SPTR_TINV_Pos = 0x5
	// Bit mask of TINV field.
	SCI1_SPTR_TINV_Msk = 0x20
	// Bit TINV.
	SCI1_SPTR_TINV = 0x20
	// Transmit data is not inverted and output to TXDn.
	SCI1_SPTR_TINV_0 = 0x0
	// Transmit data is inverted and output to TXDn.
	SCI1_SPTR_TINV_1 = 0x1
	// Position of ASEN field.
	SCI1_SPTR_ASEN_Pos = 0x6
	// Bit mask of ASEN field.
	SCI1_SPTR_ASEN_Msk = 0x40
	// Bit ASEN.
	SCI1_SPTR_ASEN = 0x40
	// Adjust sampling timing disable.
	SCI1_SPTR_ASEN_0 = 0x0
	// Adjust sampling timing enable.
	SCI1_SPTR_ASEN_1 = 0x1
	// Position of ATEN field.
	SCI1_SPTR_ATEN_Pos = 0x7
	// Bit mask of ATEN field.
	SCI1_SPTR_ATEN_Msk = 0x80
	// Bit ATEN.
	SCI1_SPTR_ATEN = 0x80
	// Adjust transmit timing disable.
	SCI1_SPTR_ATEN_0 = 0x0
	// Adjust transmit timing enable.
	SCI1_SPTR_ATEN_1 = 0x1

	// ACTR: Adjustment Communication Timing Register
	// Position of AST field.
	SCI1_ACTR_AST_Pos = 0x0
	// Bit mask of AST field.
	SCI1_ACTR_AST_Msk = 0x7
	// Position of AJD field.
	SCI1_ACTR_AJD_Pos = 0x3
	// Bit mask of AJD field.
	SCI1_ACTR_AJD_Msk = 0x8
	// Bit AJD.
	SCI1_ACTR_AJD = 0x8
	// The sampling timing is adjusted backward to the middle of bit.
	SCI1_ACTR_AJD_0 = 0x0
	// The sampling timing is adjusted forward to the middle of bit.
	SCI1_ACTR_AJD_1 = 0x1
	// Position of ATT field.
	SCI1_ACTR_ATT_Pos = 0x4
	// Bit mask of ATT field.
	SCI1_ACTR_ATT_Msk = 0x70
	// Position of AET field.
	SCI1_ACTR_AET_Pos = 0x7
	// Bit mask of AET field.
	SCI1_ACTR_AET_Msk = 0x80
	// Bit AET.
	SCI1_ACTR_AET = 0x80
	// Adjust the rising edge timing.
	SCI1_ACTR_AET_0 = 0x0
	// Adjust the falling edge timing.
	SCI1_ACTR_AET_1 = 0x1

	// MMR: Manchester Mode Register
	// Position of RMPOL field.
	SCI1_MMR_RMPOL_Pos = 0x0
	// Bit mask of RMPOL field.
	SCI1_MMR_RMPOL_Msk = 0x1
	// Bit RMPOL.
	SCI1_MMR_RMPOL = 0x1
	// Logic 0 is coded as a zero-to-one transition in Manchester code Logic 1 is coded as a one-to-zero transition in Manchester code
	SCI1_MMR_RMPOL_0 = 0x0
	// Logic 0 is coded as a one-to-zero transition in Manchester code Logic 1 is coded as a zero-to-one transition in Manchester code
	SCI1_MMR_RMPOL_1 = 0x1
	// Position of TMPOL field.
	SCI1_MMR_TMPOL_Pos = 0x1
	// Bit mask of TMPOL field.
	SCI1_MMR_TMPOL_Msk = 0x2
	// Bit TMPOL.
	SCI1_MMR_TMPOL = 0x2
	// Logic 0 is coded as a zero-to-one transition in Manchester code Logic 1 is coded as a one-to-zero transition in Manchester code
	SCI1_MMR_TMPOL_0 = 0x0
	// Logic 0 is coded as a one-to-zero transition in Manchester code Logic 1 is coded as a zero-to-one transition in Manchester code
	SCI1_MMR_TMPOL_1 = 0x1
	// Position of ERTEN field.
	SCI1_MMR_ERTEN_Pos = 0x2
	// Bit mask of ERTEN field.
	SCI1_MMR_ERTEN_Msk = 0x4
	// Bit ERTEN.
	SCI1_MMR_ERTEN = 0x4
	// Disables the receive retiming function
	SCI1_MMR_ERTEN_0 = 0x0
	// Enables the receive retiming function
	SCI1_MMR_ERTEN_1 = 0x1
	// Position of SYNVAL field.
	SCI1_MMR_SYNVAL_Pos = 0x4
	// Bit mask of SYNVAL field.
	SCI1_MMR_SYNVAL_Msk = 0x10
	// Bit SYNVAL.
	SCI1_MMR_SYNVAL = 0x10
	// The start bit is added as a zero-to-one transition.
	SCI1_MMR_SYNVAL_0 = 0x0
	// The start bit is added as a one-to-zero transition.
	SCI1_MMR_SYNVAL_1 = 0x1
	// Position of SYNSEL field.
	SCI1_MMR_SYNSEL_Pos = 0x5
	// Bit mask of SYNSEL field.
	SCI1_MMR_SYNSEL_Msk = 0x20
	// Bit SYNSEL.
	SCI1_MMR_SYNSEL = 0x20
	// The start bit pattern is set with the SYNVAL bit
	SCI1_MMR_SYNSEL_0 = 0x0
	// The start bit pattern is set with the TSYNC bit.
	SCI1_MMR_SYNSEL_1 = 0x1
	// Position of SBSEL field.
	SCI1_MMR_SBSEL_Pos = 0x6
	// Bit mask of SBSEL field.
	SCI1_MMR_SBSEL_Msk = 0x40
	// Bit SBSEL.
	SCI1_MMR_SBSEL = 0x40
	// The start bit area consists of one bit.
	SCI1_MMR_SBSEL_0 = 0x0
	// The start bit area consists of three bits (COMMAND SYNC or DATA SYNC)
	SCI1_MMR_SBSEL_1 = 0x1
	// Position of MANEN field.
	SCI1_MMR_MANEN_Pos = 0x7
	// Bit mask of MANEN field.
	SCI1_MMR_MANEN_Msk = 0x80
	// Bit MANEN.
	SCI1_MMR_MANEN = 0x80
	// Disables the Manchester mode
	SCI1_MMR_MANEN_0 = 0x0
	// Enables the Manchester mode
	SCI1_MMR_MANEN_1 = 0x1

	// TMPR: Transmit Manchester Preface Setting Register
	// Position of TPLEN field.
	SCI1_TMPR_TPLEN_Pos = 0x0
	// Bit mask of TPLEN field.
	SCI1_TMPR_TPLEN_Msk = 0xf
	// Disables the transmit preface generation
	SCI1_TMPR_TPLEN_0x0 = 0x0
	// Position of TPPAT field.
	SCI1_TMPR_TPPAT_Pos = 0x4
	// Bit mask of TPPAT field.
	SCI1_TMPR_TPPAT_Msk = 0x30
	// ALL ZERO
	SCI1_TMPR_TPPAT_00 = 0x0
	// ZERO ONE
	SCI1_TMPR_TPPAT_01 = 0x1
	// ONE ZERO
	SCI1_TMPR_TPPAT_10 = 0x2
	// ALL ONE
	SCI1_TMPR_TPPAT_11 = 0x3

	// RMPR: Receive Manchester Preface Setting Register
	// Position of RPLEN field.
	SCI1_RMPR_RPLEN_Pos = 0x0
	// Bit mask of RPLEN field.
	SCI1_RMPR_RPLEN_Msk = 0xf
	// Disables the receive preface generation
	SCI1_RMPR_RPLEN_0 = 0x0
	// Position of RPPAT field.
	SCI1_RMPR_RPPAT_Pos = 0x4
	// Bit mask of RPPAT field.
	SCI1_RMPR_RPPAT_Msk = 0x30
	// ALL ZERO
	SCI1_RMPR_RPPAT_00 = 0x0
	// ZERO ONE
	SCI1_RMPR_RPPAT_01 = 0x1
	// ONE ZERO
	SCI1_RMPR_RPPAT_10 = 0x2
	// ALL ONE
	SCI1_RMPR_RPPAT_11 = 0x3

	// MESR: Manchester Extended Error Status Register
	// Position of PFER field.
	SCI1_MESR_PFER_Pos = 0x0
	// Bit mask of PFER field.
	SCI1_MESR_PFER_Msk = 0x1
	// Bit PFER.
	SCI1_MESR_PFER = 0x1
	// No preface error detected
	SCI1_MESR_PFER_0 = 0x0
	// Preface error detected
	SCI1_MESR_PFER_1 = 0x1
	// Position of SYER field.
	SCI1_MESR_SYER_Pos = 0x1
	// Bit mask of SYER field.
	SCI1_MESR_SYER_Msk = 0x2
	// Bit SYER.
	SCI1_MESR_SYER = 0x2
	// No receive SYNC error detected
	SCI1_MESR_SYER_0 = 0x0
	// Receive SYNC error detected
	SCI1_MESR_SYER_1 = 0x1
	// Position of SBER field.
	SCI1_MESR_SBER_Pos = 0x2
	// Bit mask of SBER field.
	SCI1_MESR_SBER_Msk = 0x4
	// Bit SBER.
	SCI1_MESR_SBER = 0x4
	// No start bit error detected
	SCI1_MESR_SBER_0 = 0x0
	// Start bit error detected
	SCI1_MESR_SBER_1 = 0x1

	// MECR: Manchester Extended Error Control Register
	// Position of PFEREN field.
	SCI1_MECR_PFEREN_Pos = 0x0
	// Bit mask of PFEREN field.
	SCI1_MECR_PFEREN_Msk = 0x1
	// Bit PFEREN.
	SCI1_MECR_PFEREN = 0x1
	// Does not handle a preface error as an interrupt source
	SCI1_MECR_PFEREN_0 = 0x0
	// Handles a preface error as an interrupt source
	SCI1_MECR_PFEREN_1 = 0x1
	// Position of SYEREN field.
	SCI1_MECR_SYEREN_Pos = 0x1
	// Bit mask of SYEREN field.
	SCI1_MECR_SYEREN_Msk = 0x2
	// Bit SYEREN.
	SCI1_MECR_SYEREN = 0x2
	// Does not handle a receive SYNC error as an interrupt source
	SCI1_MECR_SYEREN_0 = 0x0
	// Handles a receive SYNC error as an interrupt source
	SCI1_MECR_SYEREN_1 = 0x1
	// Position of SBEREN field.
	SCI1_MECR_SBEREN_Pos = 0x2
	// Bit mask of SBEREN field.
	SCI1_MECR_SBEREN_Msk = 0x4
	// Bit SBEREN.
	SCI1_MECR_SBEREN = 0x4
	// Does not handle a start bit error as an interrupt source
	SCI1_MECR_SBEREN_0 = 0x0
	// Handles a start bit error as an interrupt source
	SCI1_MECR_SBEREN_1 = 0x1
)

// Constants for SCI2: Serial Communication Interface 2
const (
	// SMR: Serial Mode Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
	// Position of CKS field.
	SCI2_SMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI2_SMR_CKS_Msk = 0x3
	// PCLK clock (n = 0)
	SCI2_SMR_CKS_00 = 0x0
	// PCLK/4 clock (n = 1)
	SCI2_SMR_CKS_01 = 0x1
	// PCLK/16 clock (n = 2)
	SCI2_SMR_CKS_10 = 0x2
	// PCLK/64 clock (n = 3)
	SCI2_SMR_CKS_11 = 0x3
	// Position of MP field.
	SCI2_SMR_MP_Pos = 0x2
	// Bit mask of MP field.
	SCI2_SMR_MP_Msk = 0x4
	// Bit MP.
	SCI2_SMR_MP = 0x4
	// Disable multi-processor communications function
	SCI2_SMR_MP_0 = 0x0
	// Enable multi-processor communications function
	SCI2_SMR_MP_1 = 0x1
	// Position of STOP field.
	SCI2_SMR_STOP_Pos = 0x3
	// Bit mask of STOP field.
	SCI2_SMR_STOP_Msk = 0x8
	// Bit STOP.
	SCI2_SMR_STOP = 0x8
	// 1 stop bit
	SCI2_SMR_STOP_0 = 0x0
	// 2 stop bits
	SCI2_SMR_STOP_1 = 0x1
	// Position of PM field.
	SCI2_SMR_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI2_SMR_PM_Msk = 0x10
	// Bit PM.
	SCI2_SMR_PM = 0x10
	// Even parity
	SCI2_SMR_PM_0 = 0x0
	// Odd parity
	SCI2_SMR_PM_1 = 0x1
	// Position of PE field.
	SCI2_SMR_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI2_SMR_PE_Msk = 0x20
	// Bit PE.
	SCI2_SMR_PE = 0x20
	// When transmitting: Do not add parity bit When receiving: Do not check parity bit
	SCI2_SMR_PE_0 = 0x0
	// When transmitting: Add parity bit When receiving: Check parity bit
	SCI2_SMR_PE_1 = 0x1
	// Position of CHR field.
	SCI2_SMR_CHR_Pos = 0x6
	// Bit mask of CHR field.
	SCI2_SMR_CHR_Msk = 0x40
	// Bit CHR.
	SCI2_SMR_CHR = 0x40
	// SCMR.CHR1 = 0: Transmit/receive in 9-bit data length SCMR.CHR1 = 1: Transmit/receive in 8-bit data length (initial value)
	SCI2_SMR_CHR_0 = 0x0
	// SCMR.CHR1 = 0: Transmit/receive in 9-bit data length SCMR.CHR1 = 1: Transmit/receive in 7-bit data length
	SCI2_SMR_CHR_1 = 0x1
	// Position of CM field.
	SCI2_SMR_CM_Pos = 0x7
	// Bit mask of CM field.
	SCI2_SMR_CM_Msk = 0x80
	// Bit CM.
	SCI2_SMR_CM = 0x80
	// Asynchronous mode or simple IIC mode
	SCI2_SMR_CM_0 = 0x0
	// Clock synchronous mode or simple SPI mode
	SCI2_SMR_CM_1 = 0x1

	// SMR_SMCI: Serial Mode Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of CKS field.
	SCI2_SMR_SMCI_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI2_SMR_SMCI_CKS_Msk = 0x3
	// PCLK clock (n = 0)
	SCI2_SMR_SMCI_CKS_00 = 0x0
	// PCLK/4 clock (n = 1)
	SCI2_SMR_SMCI_CKS_01 = 0x1
	// PCLK/16 clock (n = 2)
	SCI2_SMR_SMCI_CKS_10 = 0x2
	// PCLK/64 clock (n = 3)
	SCI2_SMR_SMCI_CKS_11 = 0x3
	// Position of BCP field.
	SCI2_SMR_SMCI_BCP_Pos = 0x2
	// Bit mask of BCP field.
	SCI2_SMR_SMCI_BCP_Msk = 0xc
	// Position of PM field.
	SCI2_SMR_SMCI_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI2_SMR_SMCI_PM_Msk = 0x10
	// Bit PM.
	SCI2_SMR_SMCI_PM = 0x10
	// Even parity
	SCI2_SMR_SMCI_PM_0 = 0x0
	// Odd parity
	SCI2_SMR_SMCI_PM_1 = 0x1
	// Position of PE field.
	SCI2_SMR_SMCI_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI2_SMR_SMCI_PE_Msk = 0x20
	// Bit PE.
	SCI2_SMR_SMCI_PE = 0x20
	// Position of BLK field.
	SCI2_SMR_SMCI_BLK_Pos = 0x6
	// Bit mask of BLK field.
	SCI2_SMR_SMCI_BLK_Msk = 0x40
	// Bit BLK.
	SCI2_SMR_SMCI_BLK = 0x40
	// Normal mode operation
	SCI2_SMR_SMCI_BLK_0 = 0x0
	// Block transfer mode operation
	SCI2_SMR_SMCI_BLK_1 = 0x1
	// Position of GM field.
	SCI2_SMR_SMCI_GM_Pos = 0x7
	// Bit mask of GM field.
	SCI2_SMR_SMCI_GM_Msk = 0x80
	// Bit GM.
	SCI2_SMR_SMCI_GM = 0x80
	// Normal mode operation
	SCI2_SMR_SMCI_GM_0 = 0x0
	// GSM mode operation
	SCI2_SMR_SMCI_GM_1 = 0x1

	// SCR: Serial Control Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
	// Position of CKE field.
	SCI2_SCR_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI2_SCR_CKE_Msk = 0x3
	// In asynchronous mode, the SCKn pin is available for use as an I/O port based on the I/O port settings. In clock synchronous mode, the SCKn pin functions as the clock output pin.
	SCI2_SCR_CKE_00 = 0x0
	// In asynchronous mode, a clock with the same frequency as the bit rate is output from the SCKn pin. In clock synchronous mode, the SCKn pin functions as the clock output pin.
	SCI2_SCR_CKE_01 = 0x1
	// Position of TEIE field.
	SCI2_SCR_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI2_SCR_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI2_SCR_TEIE = 0x4
	// Disable SCIn_TEI interrupt requests
	SCI2_SCR_TEIE_0 = 0x0
	// Enable SCIn_TEI interrupt requests
	SCI2_SCR_TEIE_1 = 0x1
	// Position of MPIE field.
	SCI2_SCR_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI2_SCR_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI2_SCR_MPIE = 0x8
	// Normal reception
	SCI2_SCR_MPIE_0 = 0x0
	// When data with the multi-processor bit set to 0 is received, the data is not read, and setting the status flags RDRF, ORER, and FER in SSR to 1 and the status flags SYER, PFER, and SBER in MESR are disabled. When data with the multi-processor bit set to 1 is received, the MPIE bit is automatically set to 0, and normal reception is resumed.
	SCI2_SCR_MPIE_1 = 0x1
	// Position of RE field.
	SCI2_SCR_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI2_SCR_RE_Msk = 0x10
	// Bit RE.
	SCI2_SCR_RE = 0x10
	// Disable serial reception
	SCI2_SCR_RE_0 = 0x0
	// Enable serial reception
	SCI2_SCR_RE_1 = 0x1
	// Position of TE field.
	SCI2_SCR_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI2_SCR_TE_Msk = 0x20
	// Bit TE.
	SCI2_SCR_TE = 0x20
	// Disable serial transmission
	SCI2_SCR_TE_0 = 0x0
	// Enable serial transmission
	SCI2_SCR_TE_1 = 0x1
	// Position of RIE field.
	SCI2_SCR_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI2_SCR_RIE_Msk = 0x40
	// Bit RIE.
	SCI2_SCR_RIE = 0x40
	// Disable SCIn_RXI and SCIn_ERI interrupt requests
	SCI2_SCR_RIE_0 = 0x0
	// Enable SCIn_RXI and SCIn_ERI interrupt requests
	SCI2_SCR_RIE_1 = 0x1
	// Position of TIE field.
	SCI2_SCR_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI2_SCR_TIE_Msk = 0x80
	// Bit TIE.
	SCI2_SCR_TIE = 0x80
	// Disable SCIn_TXI interrupt requests
	SCI2_SCR_TIE_0 = 0x0
	// Enable SCIn_TXI interrupt requests
	SCI2_SCR_TIE_1 = 0x1

	// SCR_SMCI: Serial Control Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of CKE field.
	SCI2_SCR_SMCI_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI2_SCR_SMCI_CKE_Msk = 0x3
	// When SMR_SMCI.GM = 0: Disable output The SCKn pin is available for use as an I/O port if set up in the I/O port settings When SMR_SMCI.GM = 1: Fix output low
	SCI2_SCR_SMCI_CKE_00 = 0x0
	// When SMR_SMCI.GM = 0: Output clock When SMR_SMCI.GM = 1: Output clock
	SCI2_SCR_SMCI_CKE_01 = 0x1
	// When SMR_SMCI.GM = 0: Setting prohibited When SMR_SMCI.GM = 1: Fix output high
	SCI2_SCR_SMCI_CKE_10 = 0x2
	// When SMR_SMCI.GM = 0: Setting prohibited When SMR_SMCI.GM = 1: Output clock
	SCI2_SCR_SMCI_CKE_11 = 0x3
	// Position of TEIE field.
	SCI2_SCR_SMCI_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI2_SCR_SMCI_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI2_SCR_SMCI_TEIE = 0x4
	// Position of MPIE field.
	SCI2_SCR_SMCI_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI2_SCR_SMCI_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI2_SCR_SMCI_MPIE = 0x8
	// Position of RE field.
	SCI2_SCR_SMCI_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI2_SCR_SMCI_RE_Msk = 0x10
	// Bit RE.
	SCI2_SCR_SMCI_RE = 0x10
	// Disable serial reception
	SCI2_SCR_SMCI_RE_0 = 0x0
	// Enable serial reception
	SCI2_SCR_SMCI_RE_1 = 0x1
	// Position of TE field.
	SCI2_SCR_SMCI_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI2_SCR_SMCI_TE_Msk = 0x20
	// Bit TE.
	SCI2_SCR_SMCI_TE = 0x20
	// Disable serial transmission
	SCI2_SCR_SMCI_TE_0 = 0x0
	// Enable serial transmission
	SCI2_SCR_SMCI_TE_1 = 0x1
	// Position of RIE field.
	SCI2_SCR_SMCI_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI2_SCR_SMCI_RIE_Msk = 0x40
	// Bit RIE.
	SCI2_SCR_SMCI_RIE = 0x40
	// Disable SCIn_RXI and SCIn_ERI interrupt requests
	SCI2_SCR_SMCI_RIE_0 = 0x0
	// Enable SCIn_RXI and SCIn_ERI interrupt requests
	SCI2_SCR_SMCI_RIE_1 = 0x1
	// Position of TIE field.
	SCI2_SCR_SMCI_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI2_SCR_SMCI_TIE_Msk = 0x80
	// Bit TIE.
	SCI2_SCR_SMCI_TIE = 0x80
	// Disable SCIn_TXI interrupt requests
	SCI2_SCR_SMCI_TIE_0 = 0x0
	// Enable SCIn_TXI interrupt requests
	SCI2_SCR_SMCI_TIE_1 = 0x1

	// SSR: Serial Status Register for Non-Smart Card Interface and Non-FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0, and MMR.MANEN = 0)
	// Position of MPBT field.
	SCI2_SSR_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI2_SSR_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI2_SSR_MPBT = 0x1
	// Data transmission cycle
	SCI2_SSR_MPBT_0 = 0x0
	// ID transmission cycle
	SCI2_SSR_MPBT_1 = 0x1
	// Position of MPB field.
	SCI2_SSR_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI2_SSR_MPB_Msk = 0x2
	// Bit MPB.
	SCI2_SSR_MPB = 0x2
	// Data transmission cycle
	SCI2_SSR_MPB_0 = 0x0
	// ID transmission cycle
	SCI2_SSR_MPB_1 = 0x1
	// Position of TEND field.
	SCI2_SSR_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI2_SSR_TEND_Msk = 0x4
	// Bit TEND.
	SCI2_SSR_TEND = 0x4
	// A character is being transmitted
	SCI2_SSR_TEND_0 = 0x0
	// Character transfer is complete
	SCI2_SSR_TEND_1 = 0x1
	// Position of PER field.
	SCI2_SSR_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI2_SSR_PER_Msk = 0x8
	// Bit PER.
	SCI2_SSR_PER = 0x8
	// No parity error occurred
	SCI2_SSR_PER_0 = 0x0
	// Parity error occurred
	SCI2_SSR_PER_1 = 0x1
	// Position of FER field.
	SCI2_SSR_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI2_SSR_FER_Msk = 0x10
	// Bit FER.
	SCI2_SSR_FER = 0x10
	// No framing error occurred
	SCI2_SSR_FER_0 = 0x0
	// Framing error occurred
	SCI2_SSR_FER_1 = 0x1
	// Position of ORER field.
	SCI2_SSR_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI2_SSR_ORER_Msk = 0x20
	// Bit ORER.
	SCI2_SSR_ORER = 0x20
	// No overrun error occurred
	SCI2_SSR_ORER_0 = 0x0
	// Overrun error occurred
	SCI2_SSR_ORER_1 = 0x1
	// Position of RDRF field.
	SCI2_SSR_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI2_SSR_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI2_SSR_RDRF = 0x40
	// No received data in RDR register
	SCI2_SSR_RDRF_0 = 0x0
	// Received data in RDR register
	SCI2_SSR_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI2_SSR_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI2_SSR_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI2_SSR_TDRE = 0x80
	// Transmit data in TDR register
	SCI2_SSR_TDRE_0 = 0x0
	// No transmit data in TDR register
	SCI2_SSR_TDRE_1 = 0x1

	// SSR_FIFO: Serial Status Register for Non-Smart Card Interface and FIFO Mode (SCMR.SMIF = 0, FCR.FM = 1, and MMR.MANEN = 0)
	// Position of DR field.
	SCI2_SSR_FIFO_DR_Pos = 0x0
	// Bit mask of DR field.
	SCI2_SSR_FIFO_DR_Msk = 0x1
	// Bit DR.
	SCI2_SSR_FIFO_DR = 0x1
	// Receiving is in progress, or no received data remains in FRDRHL after successfully completed reception (receive FIFO empty)
	SCI2_SSR_FIFO_DR_0 = 0x0
	// Next receive data is not received for a period after normal receiving is complete, when the amount of data stored in the FIFO is equal to or less than the receive triggering number
	SCI2_SSR_FIFO_DR_1 = 0x1
	// Position of TEND field.
	SCI2_SSR_FIFO_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI2_SSR_FIFO_TEND_Msk = 0x4
	// Bit TEND.
	SCI2_SSR_FIFO_TEND = 0x4
	// A character is being transmitted
	SCI2_SSR_FIFO_TEND_0 = 0x0
	// Character transfer is complete
	SCI2_SSR_FIFO_TEND_1 = 0x1
	// Position of PER field.
	SCI2_SSR_FIFO_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI2_SSR_FIFO_PER_Msk = 0x8
	// Bit PER.
	SCI2_SSR_FIFO_PER = 0x8
	// No parity error occurred
	SCI2_SSR_FIFO_PER_0 = 0x0
	// Parity error occurred
	SCI2_SSR_FIFO_PER_1 = 0x1
	// Position of FER field.
	SCI2_SSR_FIFO_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI2_SSR_FIFO_FER_Msk = 0x10
	// Bit FER.
	SCI2_SSR_FIFO_FER = 0x10
	// No framing error occurred
	SCI2_SSR_FIFO_FER_0 = 0x0
	// Framing error occurred
	SCI2_SSR_FIFO_FER_1 = 0x1
	// Position of ORER field.
	SCI2_SSR_FIFO_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI2_SSR_FIFO_ORER_Msk = 0x20
	// Bit ORER.
	SCI2_SSR_FIFO_ORER = 0x20
	// No overrun error occurred
	SCI2_SSR_FIFO_ORER_0 = 0x0
	// Overrun error occurred
	SCI2_SSR_FIFO_ORER_1 = 0x1
	// Position of RDF field.
	SCI2_SSR_FIFO_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI2_SSR_FIFO_RDF_Msk = 0x40
	// Bit RDF.
	SCI2_SSR_FIFO_RDF = 0x40
	// The amount of receive data written in FRDRHL is less than the specified receive triggering number
	SCI2_SSR_FIFO_RDF_0 = 0x0
	// The amount of receive data written in FRDRHL is equal to or greater than the specified receive triggering number
	SCI2_SSR_FIFO_RDF_1 = 0x1
	// Position of TDFE field.
	SCI2_SSR_FIFO_TDFE_Pos = 0x7
	// Bit mask of TDFE field.
	SCI2_SSR_FIFO_TDFE_Msk = 0x80
	// Bit TDFE.
	SCI2_SSR_FIFO_TDFE = 0x80
	// The amount of transmit data written in FTDRHL exceeds the specified transmit triggering number
	SCI2_SSR_FIFO_TDFE_0 = 0x0
	// The amount of transmit data written in FTDRHL is equal to or less than the specified transmit triggering number
	SCI2_SSR_FIFO_TDFE_1 = 0x1

	// SSR_MANC: Serial Status Register for Manchester Mode (SCMR.SMIF = 0, and MMR.MANEN = 1)
	// Position of MER field.
	SCI2_SSR_MANC_MER_Pos = 0x0
	// Bit mask of MER field.
	SCI2_SSR_MANC_MER_Msk = 0x1
	// Bit MER.
	SCI2_SSR_MANC_MER = 0x1
	// No Manchester error occurred
	SCI2_SSR_MANC_MER_0 = 0x0
	// Manchester error has occurred
	SCI2_SSR_MANC_MER_1 = 0x1
	// Position of MPB field.
	SCI2_SSR_MANC_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI2_SSR_MANC_MPB_Msk = 0x2
	// Bit MPB.
	SCI2_SSR_MANC_MPB = 0x2
	// Data transmission cycles
	SCI2_SSR_MANC_MPB_0 = 0x0
	// ID transmission cycles
	SCI2_SSR_MANC_MPB_1 = 0x1
	// Position of TEND field.
	SCI2_SSR_MANC_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI2_SSR_MANC_TEND_Msk = 0x4
	// Bit TEND.
	SCI2_SSR_MANC_TEND = 0x4
	// A character is being transmitted
	SCI2_SSR_MANC_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI2_SSR_MANC_TEND_1 = 0x1
	// Position of PER field.
	SCI2_SSR_MANC_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI2_SSR_MANC_PER_Msk = 0x8
	// Bit PER.
	SCI2_SSR_MANC_PER = 0x8
	// No parity error occurred
	SCI2_SSR_MANC_PER_0 = 0x0
	// A parity error has occurred
	SCI2_SSR_MANC_PER_1 = 0x1
	// Position of FER field.
	SCI2_SSR_MANC_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI2_SSR_MANC_FER_Msk = 0x10
	// Bit FER.
	SCI2_SSR_MANC_FER = 0x10
	// No framing error occurred
	SCI2_SSR_MANC_FER_0 = 0x0
	// A framing error has occurred
	SCI2_SSR_MANC_FER_1 = 0x1
	// Position of ORER field.
	SCI2_SSR_MANC_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI2_SSR_MANC_ORER_Msk = 0x20
	// Bit ORER.
	SCI2_SSR_MANC_ORER = 0x20
	// No overrun error occurred
	SCI2_SSR_MANC_ORER_0 = 0x0
	// An overrun error has occurred
	SCI2_SSR_MANC_ORER_1 = 0x1
	// Position of RDRF field.
	SCI2_SSR_MANC_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI2_SSR_MANC_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI2_SSR_MANC_RDRF = 0x40
	// No received data is in RDR register
	SCI2_SSR_MANC_RDRF_0 = 0x0
	// Received data is in RDR register
	SCI2_SSR_MANC_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI2_SSR_MANC_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI2_SSR_MANC_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI2_SSR_MANC_TDRE = 0x80
	// Transmit data is in TDR register
	SCI2_SSR_MANC_TDRE_0 = 0x0
	// No transmit data is in TDR register
	SCI2_SSR_MANC_TDRE_1 = 0x1

	// SSR_SMCI: Serial Status Register for Smart Card Interface Mode (SCMR.SMIF = 1, and MMR.MANEN = 0)
	// Position of MPBT field.
	SCI2_SSR_SMCI_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI2_SSR_SMCI_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI2_SSR_SMCI_MPBT = 0x1
	// Position of MPB field.
	SCI2_SSR_SMCI_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI2_SSR_SMCI_MPB_Msk = 0x2
	// Bit MPB.
	SCI2_SSR_SMCI_MPB = 0x2
	// Position of TEND field.
	SCI2_SSR_SMCI_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI2_SSR_SMCI_TEND_Msk = 0x4
	// Bit TEND.
	SCI2_SSR_SMCI_TEND = 0x4
	// A character is being transmitted
	SCI2_SSR_SMCI_TEND_0 = 0x0
	// Character transfer is complete
	SCI2_SSR_SMCI_TEND_1 = 0x1
	// Position of PER field.
	SCI2_SSR_SMCI_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI2_SSR_SMCI_PER_Msk = 0x8
	// Bit PER.
	SCI2_SSR_SMCI_PER = 0x8
	// No parity error occurred
	SCI2_SSR_SMCI_PER_0 = 0x0
	// Parity error occurred
	SCI2_SSR_SMCI_PER_1 = 0x1
	// Position of ERS field.
	SCI2_SSR_SMCI_ERS_Pos = 0x4
	// Bit mask of ERS field.
	SCI2_SSR_SMCI_ERS_Msk = 0x10
	// Bit ERS.
	SCI2_SSR_SMCI_ERS = 0x10
	// No low error signal response
	SCI2_SSR_SMCI_ERS_0 = 0x0
	// Low error signal response occurred
	SCI2_SSR_SMCI_ERS_1 = 0x1
	// Position of ORER field.
	SCI2_SSR_SMCI_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI2_SSR_SMCI_ORER_Msk = 0x20
	// Bit ORER.
	SCI2_SSR_SMCI_ORER = 0x20
	// No overrun error occurred
	SCI2_SSR_SMCI_ORER_0 = 0x0
	// Overrun error occurred
	SCI2_SSR_SMCI_ORER_1 = 0x1
	// Position of RDRF field.
	SCI2_SSR_SMCI_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI2_SSR_SMCI_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI2_SSR_SMCI_RDRF = 0x40
	// No received data in RDR register
	SCI2_SSR_SMCI_RDRF_0 = 0x0
	// Received data in RDR register
	SCI2_SSR_SMCI_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI2_SSR_SMCI_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI2_SSR_SMCI_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI2_SSR_SMCI_TDRE = 0x80
	// Transmit data in TDR register
	SCI2_SSR_SMCI_TDRE_0 = 0x0
	// No transmit data in TDR register
	SCI2_SSR_SMCI_TDRE_1 = 0x1

	// SCMR: Smart Card Mode Register
	// Position of SMIF field.
	SCI2_SCMR_SMIF_Pos = 0x0
	// Bit mask of SMIF field.
	SCI2_SCMR_SMIF_Msk = 0x1
	// Bit SMIF.
	SCI2_SCMR_SMIF = 0x1
	// Non-smart card interface mode (asynchronous mode, clock synchronous mode, simple SPI mode, or simple IIC mode)
	SCI2_SCMR_SMIF_0 = 0x0
	// Smart card interface mode
	SCI2_SCMR_SMIF_1 = 0x1
	// Position of SINV field.
	SCI2_SCMR_SINV_Pos = 0x2
	// Bit mask of SINV field.
	SCI2_SCMR_SINV_Msk = 0x4
	// Bit SINV.
	SCI2_SCMR_SINV = 0x4
	// TDR contents are transmitted as they are. Received data is stored as received in the RDR register.
	SCI2_SCMR_SINV_0 = 0x0
	// TDR register contents are inverted before transmission. Receive data is stored in inverted form in the RDR register.
	SCI2_SCMR_SINV_1 = 0x1
	// Position of SDIR field.
	SCI2_SCMR_SDIR_Pos = 0x3
	// Bit mask of SDIR field.
	SCI2_SCMR_SDIR_Msk = 0x8
	// Bit SDIR.
	SCI2_SCMR_SDIR = 0x8
	// Transfer LSB-first
	SCI2_SCMR_SDIR_0 = 0x0
	// Transfer MSB-first
	SCI2_SCMR_SDIR_1 = 0x1
	// Position of CHR1 field.
	SCI2_SCMR_CHR1_Pos = 0x4
	// Bit mask of CHR1 field.
	SCI2_SCMR_CHR1_Msk = 0x10
	// Bit CHR1.
	SCI2_SCMR_CHR1 = 0x10
	// SMR.CHR = 0: Transmit/receive in 9-bit data length SMR.CHR = 1: Transmit/receive in 9-bit data length
	SCI2_SCMR_CHR1_0 = 0x0
	// SMR.CHR = 0: Transmit/receive in 8-bit data length (initial value) SMR.CHR = 1: Transmit/receive in 7-bit data length
	SCI2_SCMR_CHR1_1 = 0x1
	// Position of BCP2 field.
	SCI2_SCMR_BCP2_Pos = 0x7
	// Bit mask of BCP2 field.
	SCI2_SCMR_BCP2_Msk = 0x80
	// Bit BCP2.
	SCI2_SCMR_BCP2 = 0x80

	// SEMR: Serial Extended Mode Register
	// Position of ACS0 field.
	SCI2_SEMR_ACS0_Pos = 0x0
	// Bit mask of ACS0 field.
	SCI2_SEMR_ACS0_Msk = 0x1
	// Bit ACS0.
	SCI2_SEMR_ACS0 = 0x1
	// External clock input
	SCI2_SEMR_ACS0_0 = 0x0
	// Logical AND of compare matches output from the internal GPT. These bit for the other SCI channels than SCIn (n = 2) are reserved.
	SCI2_SEMR_ACS0_1 = 0x1
	// Position of PADIS field.
	SCI2_SEMR_PADIS_Pos = 0x1
	// Bit mask of PADIS field.
	SCI2_SEMR_PADIS_Msk = 0x2
	// Bit PADIS.
	SCI2_SEMR_PADIS = 0x2
	// Preamble output function is enabled
	SCI2_SEMR_PADIS_0 = 0x0
	// Preamble output function is disabled These bits for the other SCI channels than SCIn (n = 0, 3, 4, 9) are reserved.
	SCI2_SEMR_PADIS_1 = 0x1
	// Position of BRME field.
	SCI2_SEMR_BRME_Pos = 0x2
	// Bit mask of BRME field.
	SCI2_SEMR_BRME_Msk = 0x4
	// Bit BRME.
	SCI2_SEMR_BRME = 0x4
	// Disable bit rate modulation function
	SCI2_SEMR_BRME_0 = 0x0
	// Enable bit rate modulation function
	SCI2_SEMR_BRME_1 = 0x1
	// Position of ABCSE field.
	SCI2_SEMR_ABCSE_Pos = 0x3
	// Bit mask of ABCSE field.
	SCI2_SEMR_ABCSE_Msk = 0x8
	// Bit ABCSE.
	SCI2_SEMR_ABCSE = 0x8
	// Clock cycles for 1-bit period determined by combination of the BGDM and ABCS bits in the SEMR register
	SCI2_SEMR_ABCSE_0 = 0x0
	// Baud rate is 6 base clock cycles for 1-bit period These bits for the other SCI channels than SCIn (n = 0, 3, 4, 9) are reserved.
	SCI2_SEMR_ABCSE_1 = 0x1
	// Position of ABCS field.
	SCI2_SEMR_ABCS_Pos = 0x4
	// Bit mask of ABCS field.
	SCI2_SEMR_ABCS_Msk = 0x10
	// Bit ABCS.
	SCI2_SEMR_ABCS = 0x10
	// Select 16 base clock cycles for 1-bit period
	SCI2_SEMR_ABCS_0 = 0x0
	// Select 8 base clock cycles for 1-bit period
	SCI2_SEMR_ABCS_1 = 0x1
	// Position of NFEN field.
	SCI2_SEMR_NFEN_Pos = 0x5
	// Bit mask of NFEN field.
	SCI2_SEMR_NFEN_Msk = 0x20
	// Bit NFEN.
	SCI2_SEMR_NFEN = 0x20
	// In asynchronous mode: Disable noise cancellation function for RXDn input signal In simple I2C mode: Disable noise cancellation function for SCLn and SDAn input signals
	SCI2_SEMR_NFEN_0 = 0x0
	// In asynchronous mode: Enable noise cancellation function for RXDn input signal In simple I2C mode: Enable noise cancellation function for SCLn and SDAn input signals
	SCI2_SEMR_NFEN_1 = 0x1
	// Position of BGDM field.
	SCI2_SEMR_BGDM_Pos = 0x6
	// Bit mask of BGDM field.
	SCI2_SEMR_BGDM_Msk = 0x40
	// Bit BGDM.
	SCI2_SEMR_BGDM = 0x40
	// Output clock from baud rate generator with normal frequency
	SCI2_SEMR_BGDM_0 = 0x0
	// Output clock from baud rate generator with doubled frequency
	SCI2_SEMR_BGDM_1 = 0x1
	// Position of RXDESEL field.
	SCI2_SEMR_RXDESEL_Pos = 0x7
	// Bit mask of RXDESEL field.
	SCI2_SEMR_RXDESEL_Msk = 0x80
	// Bit RXDESEL.
	SCI2_SEMR_RXDESEL = 0x80
	// Detect low level on RXDn pin as start bit
	SCI2_SEMR_RXDESEL_0 = 0x0
	// Detect falling edge of RXDn pin as start bit
	SCI2_SEMR_RXDESEL_1 = 0x1

	// SNFR: Noise Filter Setting Register
	// Position of NFCS field.
	SCI2_SNFR_NFCS_Pos = 0x0
	// Bit mask of NFCS field.
	SCI2_SNFR_NFCS_Msk = 0x7
	// In asynchronous mode: Use clock signal divided by 1 with noise filter In simple I2C mode: Setting prohibited
	SCI2_SNFR_NFCS_000 = 0x0
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 1 with noise filter
	SCI2_SNFR_NFCS_001 = 0x1
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 2 with noise filter
	SCI2_SNFR_NFCS_010 = 0x2
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 4 with noise filter
	SCI2_SNFR_NFCS_011 = 0x3
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 8 with noise filter
	SCI2_SNFR_NFCS_100 = 0x4

	// SIMR1: IIC Mode Register 1
	// Position of IICM field.
	SCI2_SIMR1_IICM_Pos = 0x0
	// Bit mask of IICM field.
	SCI2_SIMR1_IICM_Msk = 0x1
	// Bit IICM.
	SCI2_SIMR1_IICM = 0x1
	// SCMR.SMIF = 0: Asynchronous mode (including multi-processor mode), clock synchronous mode, or simple SPI mode SCMR.SMIF = 1: Smart card interface mode
	SCI2_SIMR1_IICM_0 = 0x0
	// SCMR.SMIF = 0: Simple IIC mode SCMR.SMIF = 1: Setting prohibited
	SCI2_SIMR1_IICM_1 = 0x1
	// Position of IICDL field.
	SCI2_SIMR1_IICDL_Pos = 0x3
	// Bit mask of IICDL field.
	SCI2_SIMR1_IICDL_Msk = 0xf8
	// No output delay
	SCI2_SIMR1_IICDL_0x00 = 0x0

	// SIMR2: IIC Mode Register 2
	// Position of IICINTM field.
	SCI2_SIMR2_IICINTM_Pos = 0x0
	// Bit mask of IICINTM field.
	SCI2_SIMR2_IICINTM_Msk = 0x1
	// Bit IICINTM.
	SCI2_SIMR2_IICINTM = 0x1
	// Use ACK/NACK interrupts
	SCI2_SIMR2_IICINTM_0 = 0x0
	// Use reception and transmission interrupts
	SCI2_SIMR2_IICINTM_1 = 0x1
	// Position of IICCSC field.
	SCI2_SIMR2_IICCSC_Pos = 0x1
	// Bit mask of IICCSC field.
	SCI2_SIMR2_IICCSC_Msk = 0x2
	// Bit IICCSC.
	SCI2_SIMR2_IICCSC = 0x2
	// Do not synchronize with clock signal
	SCI2_SIMR2_IICCSC_0 = 0x0
	// Synchronize with clock signal
	SCI2_SIMR2_IICCSC_1 = 0x1
	// Position of IICACKT field.
	SCI2_SIMR2_IICACKT_Pos = 0x5
	// Bit mask of IICACKT field.
	SCI2_SIMR2_IICACKT_Msk = 0x20
	// Bit IICACKT.
	SCI2_SIMR2_IICACKT = 0x20
	// ACK transmission
	SCI2_SIMR2_IICACKT_0 = 0x0
	// NACK transmission and ACK/NACK reception
	SCI2_SIMR2_IICACKT_1 = 0x1

	// SIMR3: IIC Mode Register 3
	// Position of IICSTAREQ field.
	SCI2_SIMR3_IICSTAREQ_Pos = 0x0
	// Bit mask of IICSTAREQ field.
	SCI2_SIMR3_IICSTAREQ_Msk = 0x1
	// Bit IICSTAREQ.
	SCI2_SIMR3_IICSTAREQ = 0x1
	// Do not generate start condition
	SCI2_SIMR3_IICSTAREQ_0 = 0x0
	// Generate start condition
	SCI2_SIMR3_IICSTAREQ_1 = 0x1
	// Position of IICRSTAREQ field.
	SCI2_SIMR3_IICRSTAREQ_Pos = 0x1
	// Bit mask of IICRSTAREQ field.
	SCI2_SIMR3_IICRSTAREQ_Msk = 0x2
	// Bit IICRSTAREQ.
	SCI2_SIMR3_IICRSTAREQ = 0x2
	// Do not generate restart condition
	SCI2_SIMR3_IICRSTAREQ_0 = 0x0
	// Generate restart condition
	SCI2_SIMR3_IICRSTAREQ_1 = 0x1
	// Position of IICSTPREQ field.
	SCI2_SIMR3_IICSTPREQ_Pos = 0x2
	// Bit mask of IICSTPREQ field.
	SCI2_SIMR3_IICSTPREQ_Msk = 0x4
	// Bit IICSTPREQ.
	SCI2_SIMR3_IICSTPREQ = 0x4
	// Do not generate stop condition
	SCI2_SIMR3_IICSTPREQ_0 = 0x0
	// Generate stop condition
	SCI2_SIMR3_IICSTPREQ_1 = 0x1
	// Position of IICSTIF field.
	SCI2_SIMR3_IICSTIF_Pos = 0x3
	// Bit mask of IICSTIF field.
	SCI2_SIMR3_IICSTIF_Msk = 0x8
	// Bit IICSTIF.
	SCI2_SIMR3_IICSTIF = 0x8
	// No requests are being made for generating conditions, or a condition is being generated
	SCI2_SIMR3_IICSTIF_0 = 0x0
	// Generation of start, restart, or stop condition is complete. When 0 is written to IICSTIF, it is set to 0
	SCI2_SIMR3_IICSTIF_1 = 0x1
	// Position of IICSDAS field.
	SCI2_SIMR3_IICSDAS_Pos = 0x4
	// Bit mask of IICSDAS field.
	SCI2_SIMR3_IICSDAS_Msk = 0x30
	// Output serial data
	SCI2_SIMR3_IICSDAS_00 = 0x0
	// Generate start, restart, or stop condition
	SCI2_SIMR3_IICSDAS_01 = 0x1
	// Output low on SDAn pin
	SCI2_SIMR3_IICSDAS_10 = 0x2
	// Drive SDAn pin to high-impedance state
	SCI2_SIMR3_IICSDAS_11 = 0x3
	// Position of IICSCLS field.
	SCI2_SIMR3_IICSCLS_Pos = 0x6
	// Bit mask of IICSCLS field.
	SCI2_SIMR3_IICSCLS_Msk = 0xc0
	// Output serial clock
	SCI2_SIMR3_IICSCLS_00 = 0x0
	// Generate start, restart, or stop condition
	SCI2_SIMR3_IICSCLS_01 = 0x1
	// Output low on SCLn pin
	SCI2_SIMR3_IICSCLS_10 = 0x2
	// Drive SCLn pin to high-impedance state
	SCI2_SIMR3_IICSCLS_11 = 0x3

	// SISR: IIC Status Register
	// Position of IICACKR field.
	SCI2_SISR_IICACKR_Pos = 0x0
	// Bit mask of IICACKR field.
	SCI2_SISR_IICACKR_Msk = 0x1
	// Bit IICACKR.
	SCI2_SISR_IICACKR = 0x1
	// ACK received
	SCI2_SISR_IICACKR_0 = 0x0
	// NACK received
	SCI2_SISR_IICACKR_1 = 0x1

	// SPMR: SPI Mode Register
	// Position of SSE field.
	SCI2_SPMR_SSE_Pos = 0x0
	// Bit mask of SSE field.
	SCI2_SPMR_SSE_Msk = 0x1
	// Bit SSE.
	SCI2_SPMR_SSE = 0x1
	// Disable SSn pin function
	SCI2_SPMR_SSE_0 = 0x0
	// Enable SSn pin function
	SCI2_SPMR_SSE_1 = 0x1
	// Position of CTSE field.
	SCI2_SPMR_CTSE_Pos = 0x1
	// Bit mask of CTSE field.
	SCI2_SPMR_CTSE_Msk = 0x2
	// Bit CTSE.
	SCI2_SPMR_CTSE = 0x2
	// Disable CTS function (enable RTS output function)
	SCI2_SPMR_CTSE_0 = 0x0
	// Enable CTS function
	SCI2_SPMR_CTSE_1 = 0x1
	// Position of MSS field.
	SCI2_SPMR_MSS_Pos = 0x2
	// Bit mask of MSS field.
	SCI2_SPMR_MSS_Msk = 0x4
	// Bit MSS.
	SCI2_SPMR_MSS = 0x4
	// Transmit through TXDn pin and receive through RXDn pin (master mode)
	SCI2_SPMR_MSS_0 = 0x0
	// Receive through TXDn pin and transmit through RXDn pin (slave mode)
	SCI2_SPMR_MSS_1 = 0x1
	// Position of CTSPEN field.
	SCI2_SPMR_CTSPEN_Pos = 0x3
	// Bit mask of CTSPEN field.
	SCI2_SPMR_CTSPEN_Msk = 0x8
	// Bit CTSPEN.
	SCI2_SPMR_CTSPEN = 0x8
	// Alternate setting to use CTS and RTS functions as either one terminal
	SCI2_SPMR_CTSPEN_0 = 0x0
	// Dedicated setting for separately using CTS and RTS functions with 2 terminals These bits for the other SCI channels than SCIn (n = 0, 3, 4, 9) are reserved.
	SCI2_SPMR_CTSPEN_1 = 0x1
	// Position of MFF field.
	SCI2_SPMR_MFF_Pos = 0x4
	// Bit mask of MFF field.
	SCI2_SPMR_MFF_Msk = 0x10
	// Bit MFF.
	SCI2_SPMR_MFF = 0x10
	// No mode fault error
	SCI2_SPMR_MFF_0 = 0x0
	// Mode fault error
	SCI2_SPMR_MFF_1 = 0x1
	// Position of CKPOL field.
	SCI2_SPMR_CKPOL_Pos = 0x6
	// Bit mask of CKPOL field.
	SCI2_SPMR_CKPOL_Msk = 0x40
	// Bit CKPOL.
	SCI2_SPMR_CKPOL = 0x40
	// Do not invert clock polarity
	SCI2_SPMR_CKPOL_0 = 0x0
	// Invert clock polarity
	SCI2_SPMR_CKPOL_1 = 0x1
	// Position of CKPH field.
	SCI2_SPMR_CKPH_Pos = 0x7
	// Bit mask of CKPH field.
	SCI2_SPMR_CKPH_Msk = 0x80
	// Bit CKPH.
	SCI2_SPMR_CKPH = 0x80
	// Do not delay clock
	SCI2_SPMR_CKPH_0 = 0x0
	// Delay clock
	SCI2_SPMR_CKPH_1 = 0x1

	// FTDRHL: Transmit FIFO Data Register
	// Position of TDAT field.
	SCI2_FTDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI2_FTDRHL_TDAT_Msk = 0x1ff
	// Position of MPBT field.
	SCI2_FTDRHL_MPBT_Pos = 0x9
	// Bit mask of MPBT field.
	SCI2_FTDRHL_MPBT_Msk = 0x200
	// Bit MPBT.
	SCI2_FTDRHL_MPBT = 0x200
	// Data transmission cycle
	SCI2_FTDRHL_MPBT_0 = 0x0
	// ID transmission cycle
	SCI2_FTDRHL_MPBT_1 = 0x1

	// TDRHL: Transmit Data Register for Non-Manchester mode (MMR.MANEN = 0)
	// Position of TDAT field.
	SCI2_TDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI2_TDRHL_TDAT_Msk = 0x1ff

	// FTDRH: Transmit FIFO Data Register
	// Position of MPBT field.
	SCI2_FTDRH_MPBT_Pos = 0x1
	// Bit mask of MPBT field.
	SCI2_FTDRH_MPBT_Msk = 0x2
	// Bit MPBT.
	SCI2_FTDRH_MPBT = 0x2
	// Data transmission cycle
	SCI2_FTDRH_MPBT_0 = 0x0
	// ID transmission cycle
	SCI2_FTDRH_MPBT_1 = 0x1

	// FTDRL: Transmit FIFO Data Register
	// Position of TDAT field.
	SCI2_FTDRL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI2_FTDRL_TDAT_Msk = 0xff

	// FRDRHL: Receive FIFO Data Register
	// Position of RDAT field.
	SCI2_FRDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI2_FRDRHL_RDAT_Msk = 0x1ff
	// Position of MPB field.
	SCI2_FRDRHL_MPB_Pos = 0x9
	// Bit mask of MPB field.
	SCI2_FRDRHL_MPB_Msk = 0x200
	// Bit MPB.
	SCI2_FRDRHL_MPB = 0x200
	// Data transmission cycle
	SCI2_FRDRHL_MPB_0 = 0x0
	// ID transmission cycle
	SCI2_FRDRHL_MPB_1 = 0x1
	// Position of DR field.
	SCI2_FRDRHL_DR_Pos = 0xa
	// Bit mask of DR field.
	SCI2_FRDRHL_DR_Msk = 0x400
	// Bit DR.
	SCI2_FRDRHL_DR = 0x400
	// Receiving is in progress, or no received data remains in the FRDRH and FRDRL registers after successfully completed reception
	SCI2_FRDRHL_DR_0 = 0x0
	// Next receive data is not received for a period after successfully completed reception
	SCI2_FRDRHL_DR_1 = 0x1
	// Position of PER field.
	SCI2_FRDRHL_PER_Pos = 0xb
	// Bit mask of PER field.
	SCI2_FRDRHL_PER_Msk = 0x800
	// Bit PER.
	SCI2_FRDRHL_PER = 0x800
	// No parity error occurred in the first data of FRDRH and FRDRL
	SCI2_FRDRHL_PER_0 = 0x0
	// Parity error occurred in the first data of FRDRH and FRDRL
	SCI2_FRDRHL_PER_1 = 0x1
	// Position of FER field.
	SCI2_FRDRHL_FER_Pos = 0xc
	// Bit mask of FER field.
	SCI2_FRDRHL_FER_Msk = 0x1000
	// Bit FER.
	SCI2_FRDRHL_FER = 0x1000
	// No framing error occurred in the first data of FRDRH and FRDRL
	SCI2_FRDRHL_FER_0 = 0x0
	// Framing error occurred in the first data of FRDRH and FRDRL
	SCI2_FRDRHL_FER_1 = 0x1
	// Position of ORER field.
	SCI2_FRDRHL_ORER_Pos = 0xd
	// Bit mask of ORER field.
	SCI2_FRDRHL_ORER_Msk = 0x2000
	// Bit ORER.
	SCI2_FRDRHL_ORER = 0x2000
	// No overrun error occurred
	SCI2_FRDRHL_ORER_0 = 0x0
	// Overrun error occurred
	SCI2_FRDRHL_ORER_1 = 0x1
	// Position of RDF field.
	SCI2_FRDRHL_RDF_Pos = 0xe
	// Bit mask of RDF field.
	SCI2_FRDRHL_RDF_Msk = 0x4000
	// Bit RDF.
	SCI2_FRDRHL_RDF = 0x4000
	// The amount of receive data written in FRDRH and FRDRL is less than the specified receive triggering number
	SCI2_FRDRHL_RDF_0 = 0x0
	// The amount of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number
	SCI2_FRDRHL_RDF_1 = 0x1

	// RDRHL: Receive Data Register for Non-Manchester mode (MMR.MANEN = 0)
	// Position of RDAT field.
	SCI2_RDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI2_RDRHL_RDAT_Msk = 0x1ff

	// FRDRH: Receive FIFO Data Register
	// Position of MPB field.
	SCI2_FRDRH_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI2_FRDRH_MPB_Msk = 0x2
	// Bit MPB.
	SCI2_FRDRH_MPB = 0x2
	// Data transmission cycle
	SCI2_FRDRH_MPB_0 = 0x0
	// ID transmission cycle
	SCI2_FRDRH_MPB_1 = 0x1
	// Position of DR field.
	SCI2_FRDRH_DR_Pos = 0x2
	// Bit mask of DR field.
	SCI2_FRDRH_DR_Msk = 0x4
	// Bit DR.
	SCI2_FRDRH_DR = 0x4
	// Receiving is in progress, or no received data remains in the FRDRH and FRDRL registers after successfully completed reception
	SCI2_FRDRH_DR_0 = 0x0
	// Next receive data is not received for a period after successfully completed reception
	SCI2_FRDRH_DR_1 = 0x1
	// Position of PER field.
	SCI2_FRDRH_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI2_FRDRH_PER_Msk = 0x8
	// Bit PER.
	SCI2_FRDRH_PER = 0x8
	// No parity error occurred in the first data of FRDRH and FRDRL
	SCI2_FRDRH_PER_0 = 0x0
	// Parity error occurred in the first data of FRDRH and FRDRL
	SCI2_FRDRH_PER_1 = 0x1
	// Position of FER field.
	SCI2_FRDRH_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI2_FRDRH_FER_Msk = 0x10
	// Bit FER.
	SCI2_FRDRH_FER = 0x10
	// No framing error occurred in the first data of FRDRH and FRDRL
	SCI2_FRDRH_FER_0 = 0x0
	// Framing error occurred in the first data of FRDRH and FRDRL
	SCI2_FRDRH_FER_1 = 0x1
	// Position of ORER field.
	SCI2_FRDRH_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI2_FRDRH_ORER_Msk = 0x20
	// Bit ORER.
	SCI2_FRDRH_ORER = 0x20
	// No overrun error occurred
	SCI2_FRDRH_ORER_0 = 0x0
	// Overrun error occurred
	SCI2_FRDRH_ORER_1 = 0x1
	// Position of RDF field.
	SCI2_FRDRH_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI2_FRDRH_RDF_Msk = 0x40
	// Bit RDF.
	SCI2_FRDRH_RDF = 0x40
	// The amount of receive data written in FRDRH and FRDRL is less than the specified receive triggering number
	SCI2_FRDRH_RDF_0 = 0x0
	// The amount of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number
	SCI2_FRDRH_RDF_1 = 0x1

	// FRDRL: Receive FIFO Data Register
	// Position of RDAT field.
	SCI2_FRDRL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI2_FRDRL_RDAT_Msk = 0xff

	// DCCR: Data Compare Match Control Register
	// Position of DCMF field.
	SCI2_DCCR_DCMF_Pos = 0x0
	// Bit mask of DCMF field.
	SCI2_DCCR_DCMF_Msk = 0x1
	// Bit DCMF.
	SCI2_DCCR_DCMF = 0x1
	// Not matched
	SCI2_DCCR_DCMF_0 = 0x0
	// Matched
	SCI2_DCCR_DCMF_1 = 0x1
	// Position of DPER field.
	SCI2_DCCR_DPER_Pos = 0x3
	// Bit mask of DPER field.
	SCI2_DCCR_DPER_Msk = 0x8
	// Bit DPER.
	SCI2_DCCR_DPER = 0x8
	// No parity error occurred
	SCI2_DCCR_DPER_0 = 0x0
	// Parity error occurred
	SCI2_DCCR_DPER_1 = 0x1
	// Position of DFER field.
	SCI2_DCCR_DFER_Pos = 0x4
	// Bit mask of DFER field.
	SCI2_DCCR_DFER_Msk = 0x10
	// Bit DFER.
	SCI2_DCCR_DFER = 0x10
	// No framing error occurred
	SCI2_DCCR_DFER_0 = 0x0
	// Framing error occurred
	SCI2_DCCR_DFER_1 = 0x1
	// Position of IDSEL field.
	SCI2_DCCR_IDSEL_Pos = 0x6
	// Bit mask of IDSEL field.
	SCI2_DCCR_IDSEL_Msk = 0x40
	// Bit IDSEL.
	SCI2_DCCR_IDSEL = 0x40
	// Always compare data regardless of the MPB bit value
	SCI2_DCCR_IDSEL_0 = 0x0
	// Only compare data when MPB bit = 1 (ID frame)
	SCI2_DCCR_IDSEL_1 = 0x1
	// Position of DCME field.
	SCI2_DCCR_DCME_Pos = 0x7
	// Bit mask of DCME field.
	SCI2_DCCR_DCME_Msk = 0x80
	// Bit DCME.
	SCI2_DCCR_DCME = 0x80
	// Disable address match function
	SCI2_DCCR_DCME_0 = 0x0
	// Enable address match function
	SCI2_DCCR_DCME_1 = 0x1

	// FCR: FIFO Control Register
	// Position of FM field.
	SCI2_FCR_FM_Pos = 0x0
	// Bit mask of FM field.
	SCI2_FCR_FM_Msk = 0x1
	// Bit FM.
	SCI2_FCR_FM = 0x1
	// Non-FIFO mode. Selects TDR/RDR or TDRHL/RDRHL for communication.
	SCI2_FCR_FM_0 = 0x0
	// FIFO mode. Selects FTDRHL/FRDRHL for communication.
	SCI2_FCR_FM_1 = 0x1
	// Position of RFRST field.
	SCI2_FCR_RFRST_Pos = 0x1
	// Bit mask of RFRST field.
	SCI2_FCR_RFRST_Msk = 0x2
	// Bit RFRST.
	SCI2_FCR_RFRST = 0x2
	// Do not reset FRDRHL
	SCI2_FCR_RFRST_0 = 0x0
	// Reset FRDRHL
	SCI2_FCR_RFRST_1 = 0x1
	// Position of TFRST field.
	SCI2_FCR_TFRST_Pos = 0x2
	// Bit mask of TFRST field.
	SCI2_FCR_TFRST_Msk = 0x4
	// Bit TFRST.
	SCI2_FCR_TFRST = 0x4
	// Do not reset FTDRHL
	SCI2_FCR_TFRST_0 = 0x0
	// Reset FTDRHL
	SCI2_FCR_TFRST_1 = 0x1
	// Position of DRES field.
	SCI2_FCR_DRES_Pos = 0x3
	// Bit mask of DRES field.
	SCI2_FCR_DRES_Msk = 0x8
	// Bit DRES.
	SCI2_FCR_DRES = 0x8
	// Receive data full interrupt (SCIn_RXI)
	SCI2_FCR_DRES_0 = 0x0
	// Receive error interrupt (SCIn_ERI)
	SCI2_FCR_DRES_1 = 0x1
	// Position of TTRG field.
	SCI2_FCR_TTRG_Pos = 0x4
	// Bit mask of TTRG field.
	SCI2_FCR_TTRG_Msk = 0xf0
	// Position of RTRG field.
	SCI2_FCR_RTRG_Pos = 0x8
	// Bit mask of RTRG field.
	SCI2_FCR_RTRG_Msk = 0xf00
	// Position of RSTRG field.
	SCI2_FCR_RSTRG_Pos = 0xc
	// Bit mask of RSTRG field.
	SCI2_FCR_RSTRG_Msk = 0xf000

	// FDR: FIFO Data Count Register
	// Position of R field.
	SCI2_FDR_R_Pos = 0x0
	// Bit mask of R field.
	SCI2_FDR_R_Msk = 0x1f
	// Position of T field.
	SCI2_FDR_T_Pos = 0x8
	// Bit mask of T field.
	SCI2_FDR_T_Msk = 0x1f00

	// LSR: Line Status Register
	// Position of ORER field.
	SCI2_LSR_ORER_Pos = 0x0
	// Bit mask of ORER field.
	SCI2_LSR_ORER_Msk = 0x1
	// Bit ORER.
	SCI2_LSR_ORER = 0x1
	// No overrun error occurred
	SCI2_LSR_ORER_0 = 0x0
	// Overrun error occurred
	SCI2_LSR_ORER_1 = 0x1
	// Position of FNUM field.
	SCI2_LSR_FNUM_Pos = 0x2
	// Bit mask of FNUM field.
	SCI2_LSR_FNUM_Msk = 0x7c
	// Position of PNUM field.
	SCI2_LSR_PNUM_Pos = 0x8
	// Bit mask of PNUM field.
	SCI2_LSR_PNUM_Msk = 0x1f00

	// CDR: Compare Match Data Register
	// Position of CMPD field.
	SCI2_CDR_CMPD_Pos = 0x0
	// Bit mask of CMPD field.
	SCI2_CDR_CMPD_Msk = 0x1ff

	// SPTR: Serial Port Register
	// Position of RXDMON field.
	SCI2_SPTR_RXDMON_Pos = 0x0
	// Bit mask of RXDMON field.
	SCI2_SPTR_RXDMON_Msk = 0x1
	// Bit RXDMON.
	SCI2_SPTR_RXDMON = 0x1
	// Position of SPB2DT field.
	SCI2_SPTR_SPB2DT_Pos = 0x1
	// Bit mask of SPB2DT field.
	SCI2_SPTR_SPB2DT_Msk = 0x2
	// Bit SPB2DT.
	SCI2_SPTR_SPB2DT = 0x2
	// Position of SPB2IO field.
	SCI2_SPTR_SPB2IO_Pos = 0x2
	// Bit mask of SPB2IO field.
	SCI2_SPTR_SPB2IO_Msk = 0x4
	// Bit SPB2IO.
	SCI2_SPTR_SPB2IO = 0x4
	// Do not output value of SPB2DT bit on TXDn pin
	SCI2_SPTR_SPB2IO_0 = 0x0
	// Output value of SPB2DT bit on TXDn pin
	SCI2_SPTR_SPB2IO_1 = 0x1
	// Position of RINV field.
	SCI2_SPTR_RINV_Pos = 0x4
	// Bit mask of RINV field.
	SCI2_SPTR_RINV_Msk = 0x10
	// Bit RINV.
	SCI2_SPTR_RINV = 0x10
	// Received data from RXDn is not inverted and input.
	SCI2_SPTR_RINV_0 = 0x0
	// Received data from RXDn is inverted and input.
	SCI2_SPTR_RINV_1 = 0x1
	// Position of TINV field.
	SCI2_SPTR_TINV_Pos = 0x5
	// Bit mask of TINV field.
	SCI2_SPTR_TINV_Msk = 0x20
	// Bit TINV.
	SCI2_SPTR_TINV = 0x20
	// Transmit data is not inverted and output to TXDn.
	SCI2_SPTR_TINV_0 = 0x0
	// Transmit data is inverted and output to TXDn.
	SCI2_SPTR_TINV_1 = 0x1
	// Position of ASEN field.
	SCI2_SPTR_ASEN_Pos = 0x6
	// Bit mask of ASEN field.
	SCI2_SPTR_ASEN_Msk = 0x40
	// Bit ASEN.
	SCI2_SPTR_ASEN = 0x40
	// Adjust sampling timing disable.
	SCI2_SPTR_ASEN_0 = 0x0
	// Adjust sampling timing enable.
	SCI2_SPTR_ASEN_1 = 0x1
	// Position of ATEN field.
	SCI2_SPTR_ATEN_Pos = 0x7
	// Bit mask of ATEN field.
	SCI2_SPTR_ATEN_Msk = 0x80
	// Bit ATEN.
	SCI2_SPTR_ATEN = 0x80
	// Adjust transmit timing disable.
	SCI2_SPTR_ATEN_0 = 0x0
	// Adjust transmit timing enable.
	SCI2_SPTR_ATEN_1 = 0x1

	// ACTR: Adjustment Communication Timing Register
	// Position of AST field.
	SCI2_ACTR_AST_Pos = 0x0
	// Bit mask of AST field.
	SCI2_ACTR_AST_Msk = 0x7
	// Position of AJD field.
	SCI2_ACTR_AJD_Pos = 0x3
	// Bit mask of AJD field.
	SCI2_ACTR_AJD_Msk = 0x8
	// Bit AJD.
	SCI2_ACTR_AJD = 0x8
	// The sampling timing is adjusted backward to the middle of bit.
	SCI2_ACTR_AJD_0 = 0x0
	// The sampling timing is adjusted forward to the middle of bit.
	SCI2_ACTR_AJD_1 = 0x1
	// Position of ATT field.
	SCI2_ACTR_ATT_Pos = 0x4
	// Bit mask of ATT field.
	SCI2_ACTR_ATT_Msk = 0x70
	// Position of AET field.
	SCI2_ACTR_AET_Pos = 0x7
	// Bit mask of AET field.
	SCI2_ACTR_AET_Msk = 0x80
	// Bit AET.
	SCI2_ACTR_AET = 0x80
	// Adjust the rising edge timing.
	SCI2_ACTR_AET_0 = 0x0
	// Adjust the falling edge timing.
	SCI2_ACTR_AET_1 = 0x1

	// ESMER: Extended Serial Module Enable Register
	// Position of ESME field.
	SCI2_ESMER_ESME_Pos = 0x0
	// Bit mask of ESME field.
	SCI2_ESMER_ESME_Msk = 0x1
	// Bit ESME.
	SCI2_ESMER_ESME = 0x1
	// The extended serial mode is disabled.
	SCI2_ESMER_ESME_0 = 0x0
	// The extended serial mode is enabled.
	SCI2_ESMER_ESME_1 = 0x1

	// MMR: Manchester Mode Register
	// Position of RMPOL field.
	SCI2_MMR_RMPOL_Pos = 0x0
	// Bit mask of RMPOL field.
	SCI2_MMR_RMPOL_Msk = 0x1
	// Bit RMPOL.
	SCI2_MMR_RMPOL = 0x1
	// Logic 0 is coded as a zero-to-one transition in Manchester code Logic 1 is coded as a one-to-zero transition in Manchester code
	SCI2_MMR_RMPOL_0 = 0x0
	// Logic 0 is coded as a one-to-zero transition in Manchester code Logic 1 is coded as a zero-to-one transition in Manchester code
	SCI2_MMR_RMPOL_1 = 0x1
	// Position of TMPOL field.
	SCI2_MMR_TMPOL_Pos = 0x1
	// Bit mask of TMPOL field.
	SCI2_MMR_TMPOL_Msk = 0x2
	// Bit TMPOL.
	SCI2_MMR_TMPOL = 0x2
	// Logic 0 is coded as a zero-to-one transition in Manchester code Logic 1 is coded as a one-to-zero transition in Manchester code
	SCI2_MMR_TMPOL_0 = 0x0
	// Logic 0 is coded as a one-to-zero transition in Manchester code Logic 1 is coded as a zero-to-one transition in Manchester code
	SCI2_MMR_TMPOL_1 = 0x1
	// Position of ERTEN field.
	SCI2_MMR_ERTEN_Pos = 0x2
	// Bit mask of ERTEN field.
	SCI2_MMR_ERTEN_Msk = 0x4
	// Bit ERTEN.
	SCI2_MMR_ERTEN = 0x4
	// Disables the receive retiming function
	SCI2_MMR_ERTEN_0 = 0x0
	// Enables the receive retiming function
	SCI2_MMR_ERTEN_1 = 0x1
	// Position of SYNVAL field.
	SCI2_MMR_SYNVAL_Pos = 0x4
	// Bit mask of SYNVAL field.
	SCI2_MMR_SYNVAL_Msk = 0x10
	// Bit SYNVAL.
	SCI2_MMR_SYNVAL = 0x10
	// The start bit is added as a zero-to-one transition.
	SCI2_MMR_SYNVAL_0 = 0x0
	// The start bit is added as a one-to-zero transition.
	SCI2_MMR_SYNVAL_1 = 0x1
	// Position of SYNSEL field.
	SCI2_MMR_SYNSEL_Pos = 0x5
	// Bit mask of SYNSEL field.
	SCI2_MMR_SYNSEL_Msk = 0x20
	// Bit SYNSEL.
	SCI2_MMR_SYNSEL = 0x20
	// The start bit pattern is set with the SYNVAL bit
	SCI2_MMR_SYNSEL_0 = 0x0
	// The start bit pattern is set with the TSYNC bit.
	SCI2_MMR_SYNSEL_1 = 0x1
	// Position of SBSEL field.
	SCI2_MMR_SBSEL_Pos = 0x6
	// Bit mask of SBSEL field.
	SCI2_MMR_SBSEL_Msk = 0x40
	// Bit SBSEL.
	SCI2_MMR_SBSEL = 0x40
	// The start bit area consists of one bit.
	SCI2_MMR_SBSEL_0 = 0x0
	// The start bit area consists of three bits (COMMAND SYNC or DATA SYNC)
	SCI2_MMR_SBSEL_1 = 0x1
	// Position of MANEN field.
	SCI2_MMR_MANEN_Pos = 0x7
	// Bit mask of MANEN field.
	SCI2_MMR_MANEN_Msk = 0x80
	// Bit MANEN.
	SCI2_MMR_MANEN = 0x80
	// Disables the Manchester mode
	SCI2_MMR_MANEN_0 = 0x0
	// Enables the Manchester mode
	SCI2_MMR_MANEN_1 = 0x1

	// CR0: Control Register 0
	// Position of SFSF field.
	SCI2_CR0_SFSF_Pos = 0x1
	// Bit mask of SFSF field.
	SCI2_CR0_SFSF_Msk = 0x2
	// Bit SFSF.
	SCI2_CR0_SFSF = 0x2
	// Start Frame detection function is disabled.
	SCI2_CR0_SFSF_0 = 0x0
	// Start Frame detection function is enabled.
	SCI2_CR0_SFSF_1 = 0x1
	// Position of RXDSF field.
	SCI2_CR0_RXDSF_Pos = 0x2
	// Bit mask of RXDSF field.
	SCI2_CR0_RXDSF_Msk = 0x4
	// Bit RXDSF.
	SCI2_CR0_RXDSF = 0x4
	// RXDXn input is enabled.
	SCI2_CR0_RXDSF_0 = 0x0
	// RXDXn input is disabled.
	SCI2_CR0_RXDSF_1 = 0x1
	// Position of BRME field.
	SCI2_CR0_BRME_Pos = 0x3
	// Bit mask of BRME field.
	SCI2_CR0_BRME_Msk = 0x8
	// Bit BRME.
	SCI2_CR0_BRME = 0x8
	// Measurement of bit rate is disabled.
	SCI2_CR0_BRME_0 = 0x0
	// Measurement of bit rate is enabled.
	SCI2_CR0_BRME_1 = 0x1

	// CR1: Control Register 1
	// Position of BFE field.
	SCI2_CR1_BFE_Pos = 0x0
	// Bit mask of BFE field.
	SCI2_CR1_BFE_Msk = 0x1
	// Bit BFE.
	SCI2_CR1_BFE = 0x1
	// Break Field detection is disabled.
	SCI2_CR1_BFE_0 = 0x0
	// Break Field detection is enabled.
	SCI2_CR1_BFE_1 = 0x1
	// Position of CF0RE field.
	SCI2_CR1_CF0RE_Pos = 0x1
	// Bit mask of CF0RE field.
	SCI2_CR1_CF0RE_Msk = 0x2
	// Bit CF0RE.
	SCI2_CR1_CF0RE = 0x2
	// Reception of Control Field 0 is disabled.
	SCI2_CR1_CF0RE_0 = 0x0
	// Reception of Control Field 0 is enabled.
	SCI2_CR1_CF0RE_1 = 0x1
	// Position of CF1DS field.
	SCI2_CR1_CF1DS_Pos = 0x2
	// Bit mask of CF1DS field.
	SCI2_CR1_CF1DS_Msk = 0xc
	// Selects comparison with the value in PCF1DR.
	SCI2_CR1_CF1DS_00 = 0x0
	// Selects comparison with the value in SCF1DR.
	SCI2_CR1_CF1DS_01 = 0x1
	// Selects comparison with the values in PCF1DR and SCF1DR.
	SCI2_CR1_CF1DS_10 = 0x2
	// Setting prohibited.
	SCI2_CR1_CF1DS_11 = 0x3
	// Position of PIBE field.
	SCI2_CR1_PIBE_Pos = 0x4
	// Bit mask of PIBE field.
	SCI2_CR1_PIBE_Msk = 0x10
	// Bit PIBE.
	SCI2_CR1_PIBE = 0x10
	// The priority interrupt bit is disabled.
	SCI2_CR1_PIBE_0 = 0x0
	// The priority interrupt bit is enabled.
	SCI2_CR1_PIBE_1 = 0x1
	// Position of PIBS field.
	SCI2_CR1_PIBS_Pos = 0x5
	// Bit mask of PIBS field.
	SCI2_CR1_PIBS_Msk = 0xe0
	// 0th bit of Control Field 1
	SCI2_CR1_PIBS_000 = 0x0
	// 1st bit of Control Field 1
	SCI2_CR1_PIBS_001 = 0x1
	// 2nd bit of Control Field 1
	SCI2_CR1_PIBS_010 = 0x2
	// 3rd bit of Control Field 1
	SCI2_CR1_PIBS_011 = 0x3
	// 4th bit of Control Field 1
	SCI2_CR1_PIBS_100 = 0x4
	// 5th bit of Control Field 1
	SCI2_CR1_PIBS_101 = 0x5
	// 6th bit of Control Field 1
	SCI2_CR1_PIBS_110 = 0x6
	// 7th bit of Control Field 1
	SCI2_CR1_PIBS_111 = 0x7

	// TMPR: Transmit Manchester Preface Setting Register
	// Position of TPLEN field.
	SCI2_TMPR_TPLEN_Pos = 0x0
	// Bit mask of TPLEN field.
	SCI2_TMPR_TPLEN_Msk = 0xf
	// Disables the transmit preface generation
	SCI2_TMPR_TPLEN_0x0 = 0x0
	// Position of TPPAT field.
	SCI2_TMPR_TPPAT_Pos = 0x4
	// Bit mask of TPPAT field.
	SCI2_TMPR_TPPAT_Msk = 0x30
	// ALL ZERO
	SCI2_TMPR_TPPAT_00 = 0x0
	// ZERO ONE
	SCI2_TMPR_TPPAT_01 = 0x1
	// ONE ZERO
	SCI2_TMPR_TPPAT_10 = 0x2
	// ALL ONE
	SCI2_TMPR_TPPAT_11 = 0x3

	// CR2: Control Register 2
	// Position of DFCS field.
	SCI2_CR2_DFCS_Pos = 0x0
	// Bit mask of DFCS field.
	SCI2_CR2_DFCS_Msk = 0x7
	// Filter is disabled.
	SCI2_CR2_DFCS_000 = 0x0
	// Filter clock is SCI base clock
	SCI2_CR2_DFCS_001 = 0x1
	// Filter clock is PCLK/8
	SCI2_CR2_DFCS_010 = 0x2
	// Filter clock is PCLK/16
	SCI2_CR2_DFCS_011 = 0x3
	// Filter clock is PCLK/32
	SCI2_CR2_DFCS_100 = 0x4
	// Filter clock is PCLK/64
	SCI2_CR2_DFCS_101 = 0x5
	// Filter clock is PCLK/128
	SCI2_CR2_DFCS_110 = 0x6
	// Setting prohibited
	SCI2_CR2_DFCS_111 = 0x7
	// Position of BCCS field.
	SCI2_CR2_BCCS_Pos = 0x4
	// Bit mask of BCCS field.
	SCI2_CR2_BCCS_Msk = 0x30
	// SCI base clock
	SCI2_CR2_BCCS_00 = 0x0
	// SCI base clock frequency divided by 2
	SCI2_CR2_BCCS_01 = 0x1
	// SCI base clock frequency divided by 4
	SCI2_CR2_BCCS_10 = 0x2
	// Setting prohibited
	SCI2_CR2_BCCS_11 = 0x3
	// Position of RTS field.
	SCI2_CR2_RTS_Pos = 0x6
	// Bit mask of RTS field.
	SCI2_CR2_RTS_Msk = 0xc0
	// Rising edge of the 8th cycle of SCI base clock
	SCI2_CR2_RTS_00 = 0x0
	// Rising edge of the 10th cycle of SCI base clock
	SCI2_CR2_RTS_01 = 0x1
	// Rising edge of the 12th cycle of SCI base clock
	SCI2_CR2_RTS_10 = 0x2
	// Rising edge of the 14th cycle of SCI base clock
	SCI2_CR2_RTS_11 = 0x3

	// RMPR: Receive Manchester Preface Setting Register
	// Position of RPLEN field.
	SCI2_RMPR_RPLEN_Pos = 0x0
	// Bit mask of RPLEN field.
	SCI2_RMPR_RPLEN_Msk = 0xf
	// Disables the receive preface generation
	SCI2_RMPR_RPLEN_0 = 0x0
	// Position of RPPAT field.
	SCI2_RMPR_RPPAT_Pos = 0x4
	// Bit mask of RPPAT field.
	SCI2_RMPR_RPPAT_Msk = 0x30
	// ALL ZERO
	SCI2_RMPR_RPPAT_00 = 0x0
	// ZERO ONE
	SCI2_RMPR_RPPAT_01 = 0x1
	// ONE ZERO
	SCI2_RMPR_RPPAT_10 = 0x2
	// ALL ONE
	SCI2_RMPR_RPPAT_11 = 0x3

	// CR3: Control Register 3
	// Position of SDST field.
	SCI2_CR3_SDST_Pos = 0x0
	// Bit mask of SDST field.
	SCI2_CR3_SDST_Msk = 0x1
	// Bit SDST.
	SCI2_CR3_SDST = 0x1
	// Detection of Start Frame is not performed.
	SCI2_CR3_SDST_0 = 0x0
	// Detection of Start Frame is performed.
	SCI2_CR3_SDST_1 = 0x1

	// MESR: Manchester Extended Error Status Register
	// Position of PFER field.
	SCI2_MESR_PFER_Pos = 0x0
	// Bit mask of PFER field.
	SCI2_MESR_PFER_Msk = 0x1
	// Bit PFER.
	SCI2_MESR_PFER = 0x1
	// No preface error detected
	SCI2_MESR_PFER_0 = 0x0
	// Preface error detected
	SCI2_MESR_PFER_1 = 0x1
	// Position of SYER field.
	SCI2_MESR_SYER_Pos = 0x1
	// Bit mask of SYER field.
	SCI2_MESR_SYER_Msk = 0x2
	// Bit SYER.
	SCI2_MESR_SYER = 0x2
	// No receive SYNC error detected
	SCI2_MESR_SYER_0 = 0x0
	// Receive SYNC error detected
	SCI2_MESR_SYER_1 = 0x1
	// Position of SBER field.
	SCI2_MESR_SBER_Pos = 0x2
	// Bit mask of SBER field.
	SCI2_MESR_SBER_Msk = 0x4
	// Bit SBER.
	SCI2_MESR_SBER = 0x4
	// No start bit error detected
	SCI2_MESR_SBER_0 = 0x0
	// Start bit error detected
	SCI2_MESR_SBER_1 = 0x1

	// MECR: Manchester Extended Error Control Register
	// Position of PFEREN field.
	SCI2_MECR_PFEREN_Pos = 0x0
	// Bit mask of PFEREN field.
	SCI2_MECR_PFEREN_Msk = 0x1
	// Bit PFEREN.
	SCI2_MECR_PFEREN = 0x1
	// Does not handle a preface error as an interrupt source
	SCI2_MECR_PFEREN_0 = 0x0
	// Handles a preface error as an interrupt source
	SCI2_MECR_PFEREN_1 = 0x1
	// Position of SYEREN field.
	SCI2_MECR_SYEREN_Pos = 0x1
	// Bit mask of SYEREN field.
	SCI2_MECR_SYEREN_Msk = 0x2
	// Bit SYEREN.
	SCI2_MECR_SYEREN = 0x2
	// Does not handle a receive SYNC error as an interrupt source
	SCI2_MECR_SYEREN_0 = 0x0
	// Handles a receive SYNC error as an interrupt source
	SCI2_MECR_SYEREN_1 = 0x1
	// Position of SBEREN field.
	SCI2_MECR_SBEREN_Pos = 0x2
	// Bit mask of SBEREN field.
	SCI2_MECR_SBEREN_Msk = 0x4
	// Bit SBEREN.
	SCI2_MECR_SBEREN = 0x4
	// Does not handle a start bit error as an interrupt source
	SCI2_MECR_SBEREN_0 = 0x0
	// Handles a start bit error as an interrupt source
	SCI2_MECR_SBEREN_1 = 0x1

	// PCR: Port Control Register
	// Position of TXDXPS field.
	SCI2_PCR_TXDXPS_Pos = 0x0
	// Bit mask of TXDXPS field.
	SCI2_PCR_TXDXPS_Msk = 0x1
	// Bit TXDXPS.
	SCI2_PCR_TXDXPS = 0x1
	// The polarity of TXDXn signal is not inverted for output.
	SCI2_PCR_TXDXPS_0 = 0x0
	// The polarity of TXDXn signal is inverted for output.
	SCI2_PCR_TXDXPS_1 = 0x1
	// Position of RXDXPS field.
	SCI2_PCR_RXDXPS_Pos = 0x1
	// Bit mask of RXDXPS field.
	SCI2_PCR_RXDXPS_Msk = 0x2
	// Bit RXDXPS.
	SCI2_PCR_RXDXPS = 0x2
	// The polarity of RXDXn signal is not inverted for input.
	SCI2_PCR_RXDXPS_0 = 0x0
	// The polarity of RXDXn signal is inverted for input.
	SCI2_PCR_RXDXPS_1 = 0x1
	// Position of SHARPS field.
	SCI2_PCR_SHARPS_Pos = 0x4
	// Bit mask of SHARPS field.
	SCI2_PCR_SHARPS_Msk = 0x10
	// Bit SHARPS.
	SCI2_PCR_SHARPS = 0x10
	// The TXDXn and RXDXn pins are independent.
	SCI2_PCR_SHARPS_0 = 0x0
	// The TXDXn and RXDXn signals are multiplexed on the same pin.
	SCI2_PCR_SHARPS_1 = 0x1

	// ICR: Interrupt Control Register
	// Position of BFDIE field.
	SCI2_ICR_BFDIE_Pos = 0x0
	// Bit mask of BFDIE field.
	SCI2_ICR_BFDIE_Msk = 0x1
	// Bit BFDIE.
	SCI2_ICR_BFDIE = 0x1
	// Interrupts on detection of the low width for a Break Field are disabled.
	SCI2_ICR_BFDIE_0 = 0x0
	// Interrupts on detection of the low width for a Break Field are enabled.
	SCI2_ICR_BFDIE_1 = 0x1
	// Position of CF0MIE field.
	SCI2_ICR_CF0MIE_Pos = 0x1
	// Bit mask of CF0MIE field.
	SCI2_ICR_CF0MIE_Msk = 0x2
	// Bit CF0MIE.
	SCI2_ICR_CF0MIE = 0x2
	// Interrupts on detection of a match with Control Field 0 are disabled.
	SCI2_ICR_CF0MIE_0 = 0x0
	// Interrupts on detection of a match with Control Field 0 are enabled.
	SCI2_ICR_CF0MIE_1 = 0x1
	// Position of CF1MIE field.
	SCI2_ICR_CF1MIE_Pos = 0x2
	// Bit mask of CF1MIE field.
	SCI2_ICR_CF1MIE_Msk = 0x4
	// Bit CF1MIE.
	SCI2_ICR_CF1MIE = 0x4
	// Interrupts on detection of a match with Control Field 1 are disabled.
	SCI2_ICR_CF1MIE_0 = 0x0
	// Interrupts on detection of a match with Control Field 1 are enabled.
	SCI2_ICR_CF1MIE_1 = 0x1
	// Position of PIBDIE field.
	SCI2_ICR_PIBDIE_Pos = 0x3
	// Bit mask of PIBDIE field.
	SCI2_ICR_PIBDIE_Msk = 0x8
	// Bit PIBDIE.
	SCI2_ICR_PIBDIE = 0x8
	// Interrupts on detection of the priority interrupt bit are disabled.
	SCI2_ICR_PIBDIE_0 = 0x0
	// Interrupts on detection of the priority interrupt bit are enabled.
	SCI2_ICR_PIBDIE_1 = 0x1
	// Position of BCDIE field.
	SCI2_ICR_BCDIE_Pos = 0x4
	// Bit mask of BCDIE field.
	SCI2_ICR_BCDIE_Msk = 0x10
	// Bit BCDIE.
	SCI2_ICR_BCDIE = 0x10
	// Interrupts on detection of a bus collision are disabled.
	SCI2_ICR_BCDIE_0 = 0x0
	// Interrupts on detection of a bus collision are enabled.
	SCI2_ICR_BCDIE_1 = 0x1
	// Position of AEDIE field.
	SCI2_ICR_AEDIE_Pos = 0x5
	// Bit mask of AEDIE field.
	SCI2_ICR_AEDIE_Msk = 0x20
	// Bit AEDIE.
	SCI2_ICR_AEDIE = 0x20
	// Interrupts on detection of a valid edge are disabled.
	SCI2_ICR_AEDIE_0 = 0x0
	// Interrupts on detection of a valid edge are enabled.
	SCI2_ICR_AEDIE_1 = 0x1

	// STR: Status Register
	// Position of BFDF field.
	SCI2_STR_BFDF_Pos = 0x0
	// Bit mask of BFDF field.
	SCI2_STR_BFDF_Msk = 0x1
	// Bit BFDF.
	SCI2_STR_BFDF = 0x1
	// Position of CF0MF field.
	SCI2_STR_CF0MF_Pos = 0x1
	// Bit mask of CF0MF field.
	SCI2_STR_CF0MF_Msk = 0x2
	// Bit CF0MF.
	SCI2_STR_CF0MF = 0x2
	// Position of CF1MF field.
	SCI2_STR_CF1MF_Pos = 0x2
	// Bit mask of CF1MF field.
	SCI2_STR_CF1MF_Msk = 0x4
	// Bit CF1MF.
	SCI2_STR_CF1MF = 0x4
	// Position of PIBDF field.
	SCI2_STR_PIBDF_Pos = 0x3
	// Bit mask of PIBDF field.
	SCI2_STR_PIBDF_Msk = 0x8
	// Bit PIBDF.
	SCI2_STR_PIBDF = 0x8
	// Position of BCDF field.
	SCI2_STR_BCDF_Pos = 0x4
	// Bit mask of BCDF field.
	SCI2_STR_BCDF_Msk = 0x10
	// Bit BCDF.
	SCI2_STR_BCDF = 0x10
	// Position of AEDF field.
	SCI2_STR_AEDF_Pos = 0x5
	// Bit mask of AEDF field.
	SCI2_STR_AEDF_Msk = 0x20
	// Bit AEDF.
	SCI2_STR_AEDF = 0x20

	// STCR: Status Clear Register
	// Position of BFDCL field.
	SCI2_STCR_BFDCL_Pos = 0x0
	// Bit mask of BFDCL field.
	SCI2_STCR_BFDCL_Msk = 0x1
	// Bit BFDCL.
	SCI2_STCR_BFDCL = 0x1
	// Position of CF0MCL field.
	SCI2_STCR_CF0MCL_Pos = 0x1
	// Bit mask of CF0MCL field.
	SCI2_STCR_CF0MCL_Msk = 0x2
	// Bit CF0MCL.
	SCI2_STCR_CF0MCL = 0x2
	// Position of CF1MCL field.
	SCI2_STCR_CF1MCL_Pos = 0x2
	// Bit mask of CF1MCL field.
	SCI2_STCR_CF1MCL_Msk = 0x4
	// Bit CF1MCL.
	SCI2_STCR_CF1MCL = 0x4
	// Position of PIBDCL field.
	SCI2_STCR_PIBDCL_Pos = 0x3
	// Bit mask of PIBDCL field.
	SCI2_STCR_PIBDCL_Msk = 0x8
	// Bit PIBDCL.
	SCI2_STCR_PIBDCL = 0x8
	// Position of BCDCL field.
	SCI2_STCR_BCDCL_Pos = 0x4
	// Bit mask of BCDCL field.
	SCI2_STCR_BCDCL_Msk = 0x10
	// Bit BCDCL.
	SCI2_STCR_BCDCL = 0x10
	// Position of AEDCL field.
	SCI2_STCR_AEDCL_Pos = 0x5
	// Bit mask of AEDCL field.
	SCI2_STCR_AEDCL_Msk = 0x20
	// Bit AEDCL.
	SCI2_STCR_AEDCL = 0x20

	// CF0CR: Control Field 0 Compare Enable Register
	// Position of CF0CE0 field.
	SCI2_CF0CR_CF0CE0_Pos = 0x0
	// Bit mask of CF0CE0 field.
	SCI2_CF0CR_CF0CE0_Msk = 0x1
	// Bit CF0CE0.
	SCI2_CF0CR_CF0CE0 = 0x1
	// Comparison with bit 0 of Control Field 0 is disabled.
	SCI2_CF0CR_CF0CE0_0 = 0x0
	// Comparison with bit 0 of Control Field 0 is enabled.
	SCI2_CF0CR_CF0CE0_1 = 0x1
	// Position of CF0CE1 field.
	SCI2_CF0CR_CF0CE1_Pos = 0x1
	// Bit mask of CF0CE1 field.
	SCI2_CF0CR_CF0CE1_Msk = 0x2
	// Bit CF0CE1.
	SCI2_CF0CR_CF0CE1 = 0x2
	// Comparison with bit 1 of Control Field 0 is disabled.
	SCI2_CF0CR_CF0CE1_0 = 0x0
	// Comparison with bit 1 of Control Field 0 is enabled.
	SCI2_CF0CR_CF0CE1_1 = 0x1
	// Position of CF0CE2 field.
	SCI2_CF0CR_CF0CE2_Pos = 0x2
	// Bit mask of CF0CE2 field.
	SCI2_CF0CR_CF0CE2_Msk = 0x4
	// Bit CF0CE2.
	SCI2_CF0CR_CF0CE2 = 0x4
	// Comparison with bit 2 of Control Field 0 is disabled.
	SCI2_CF0CR_CF0CE2_0 = 0x0
	// Comparison with bit 2 of Control Field 0 is enabled.
	SCI2_CF0CR_CF0CE2_1 = 0x1
	// Position of CF0CE3 field.
	SCI2_CF0CR_CF0CE3_Pos = 0x3
	// Bit mask of CF0CE3 field.
	SCI2_CF0CR_CF0CE3_Msk = 0x8
	// Bit CF0CE3.
	SCI2_CF0CR_CF0CE3 = 0x8
	// Comparison with bit 3 of Control Field 0 is disabled.
	SCI2_CF0CR_CF0CE3_0 = 0x0
	// Comparison with bit 3 of Control Field 0 is enabled.
	SCI2_CF0CR_CF0CE3_1 = 0x1
	// Position of CF0CE4 field.
	SCI2_CF0CR_CF0CE4_Pos = 0x4
	// Bit mask of CF0CE4 field.
	SCI2_CF0CR_CF0CE4_Msk = 0x10
	// Bit CF0CE4.
	SCI2_CF0CR_CF0CE4 = 0x10
	// Comparison with bit 4 of Control Field 0 is disabled.
	SCI2_CF0CR_CF0CE4_0 = 0x0
	// Comparison with bit 4 of Control Field 0 is enabled.
	SCI2_CF0CR_CF0CE4_1 = 0x1
	// Position of CF0CE5 field.
	SCI2_CF0CR_CF0CE5_Pos = 0x5
	// Bit mask of CF0CE5 field.
	SCI2_CF0CR_CF0CE5_Msk = 0x20
	// Bit CF0CE5.
	SCI2_CF0CR_CF0CE5 = 0x20
	// Comparison with bit 5 of Control Field 0 is disabled.
	SCI2_CF0CR_CF0CE5_0 = 0x0
	// Comparison with bit 5 of Control Field 0 is enabled.
	SCI2_CF0CR_CF0CE5_1 = 0x1
	// Position of CF0CE6 field.
	SCI2_CF0CR_CF0CE6_Pos = 0x6
	// Bit mask of CF0CE6 field.
	SCI2_CF0CR_CF0CE6_Msk = 0x40
	// Bit CF0CE6.
	SCI2_CF0CR_CF0CE6 = 0x40
	// Comparison with bit 6 of Control Field 0 is disabled.
	SCI2_CF0CR_CF0CE6_0 = 0x0
	// Comparison with bit 6 of Control Field 0 is enabled.
	SCI2_CF0CR_CF0CE6_1 = 0x1
	// Position of CF0CE7 field.
	SCI2_CF0CR_CF0CE7_Pos = 0x7
	// Bit mask of CF0CE7 field.
	SCI2_CF0CR_CF0CE7_Msk = 0x80
	// Bit CF0CE7.
	SCI2_CF0CR_CF0CE7 = 0x80
	// Comparison with bit 7 of Control Field 0 is disabled.
	SCI2_CF0CR_CF0CE7_0 = 0x0
	// Comparison with bit 7 of Control Field 0 is enabled.
	SCI2_CF0CR_CF0CE7_1 = 0x1

	// CF1CR: Control Field 1 Compare Enable Register
	// Position of CF1CE0 field.
	SCI2_CF1CR_CF1CE0_Pos = 0x0
	// Bit mask of CF1CE0 field.
	SCI2_CF1CR_CF1CE0_Msk = 0x1
	// Bit CF1CE0.
	SCI2_CF1CR_CF1CE0 = 0x1
	// Comparison with bit 0 of Control Field 1 is disabled.
	SCI2_CF1CR_CF1CE0_0 = 0x0
	// Comparison with bit 0 of Control Field 1 is enabled.
	SCI2_CF1CR_CF1CE0_1 = 0x1
	// Position of CF1CE1 field.
	SCI2_CF1CR_CF1CE1_Pos = 0x1
	// Bit mask of CF1CE1 field.
	SCI2_CF1CR_CF1CE1_Msk = 0x2
	// Bit CF1CE1.
	SCI2_CF1CR_CF1CE1 = 0x2
	// Comparison with bit 1 of Control Field 1 is disabled.
	SCI2_CF1CR_CF1CE1_0 = 0x0
	// Comparison with bit 1 of Control Field 1 is enabled.
	SCI2_CF1CR_CF1CE1_1 = 0x1
	// Position of CF1CE2 field.
	SCI2_CF1CR_CF1CE2_Pos = 0x2
	// Bit mask of CF1CE2 field.
	SCI2_CF1CR_CF1CE2_Msk = 0x4
	// Bit CF1CE2.
	SCI2_CF1CR_CF1CE2 = 0x4
	// Comparison with bit 2 of Control Field 1 is disabled.
	SCI2_CF1CR_CF1CE2_0 = 0x0
	// Comparison with bit 2 of Control Field 1 is enabled.
	SCI2_CF1CR_CF1CE2_1 = 0x1
	// Position of CF1CE3 field.
	SCI2_CF1CR_CF1CE3_Pos = 0x3
	// Bit mask of CF1CE3 field.
	SCI2_CF1CR_CF1CE3_Msk = 0x8
	// Bit CF1CE3.
	SCI2_CF1CR_CF1CE3 = 0x8
	// Comparison with bit 3 of Control Field 1 is disabled.
	SCI2_CF1CR_CF1CE3_0 = 0x0
	// Comparison with bit 3 of Control Field 1 is enabled.
	SCI2_CF1CR_CF1CE3_1 = 0x1
	// Position of CF1CE4 field.
	SCI2_CF1CR_CF1CE4_Pos = 0x4
	// Bit mask of CF1CE4 field.
	SCI2_CF1CR_CF1CE4_Msk = 0x10
	// Bit CF1CE4.
	SCI2_CF1CR_CF1CE4 = 0x10
	// Comparison with bit 4 of Control Field 1 is disabled.
	SCI2_CF1CR_CF1CE4_0 = 0x0
	// Comparison with bit 4 of Control Field 1 is enabled.
	SCI2_CF1CR_CF1CE4_1 = 0x1
	// Position of CF1CE5 field.
	SCI2_CF1CR_CF1CE5_Pos = 0x5
	// Bit mask of CF1CE5 field.
	SCI2_CF1CR_CF1CE5_Msk = 0x20
	// Bit CF1CE5.
	SCI2_CF1CR_CF1CE5 = 0x20
	// Comparison with bit 5 of Control Field 1 is disabled.
	SCI2_CF1CR_CF1CE5_0 = 0x0
	// Comparison with bit 5 of Control Field 1 is enabled.
	SCI2_CF1CR_CF1CE5_1 = 0x1
	// Position of CF1CE6 field.
	SCI2_CF1CR_CF1CE6_Pos = 0x6
	// Bit mask of CF1CE6 field.
	SCI2_CF1CR_CF1CE6_Msk = 0x40
	// Bit CF1CE6.
	SCI2_CF1CR_CF1CE6 = 0x40
	// Comparison with bit 6 of Control Field 1 is disabled.
	SCI2_CF1CR_CF1CE6_0 = 0x0
	// Comparison with bit 6 of Control Field 1 is enabled.
	SCI2_CF1CR_CF1CE6_1 = 0x1
	// Position of CF1CE7 field.
	SCI2_CF1CR_CF1CE7_Pos = 0x7
	// Bit mask of CF1CE7 field.
	SCI2_CF1CR_CF1CE7_Msk = 0x80
	// Bit CF1CE7.
	SCI2_CF1CR_CF1CE7 = 0x80
	// Comparison with bit 7 of Control Field 1 is disabled.
	SCI2_CF1CR_CF1CE7_0 = 0x0
	// Comparison with bit 7 of Control Field 1 is enabled.
	SCI2_CF1CR_CF1CE7_1 = 0x1

	// TCR: Timer Control Register
	// Position of TCST field.
	SCI2_TCR_TCST_Pos = 0x0
	// Bit mask of TCST field.
	SCI2_TCR_TCST_Msk = 0x1
	// Bit TCST.
	SCI2_TCR_TCST = 0x1
	// Stops the timer counting
	SCI2_TCR_TCST_0 = 0x0
	// Starts the timer counting
	SCI2_TCR_TCST_1 = 0x1

	// TMR: Timer Mode Register
	// Position of TOMS field.
	SCI2_TMR_TOMS_Pos = 0x0
	// Bit mask of TOMS field.
	SCI2_TMR_TOMS_Msk = 0x3
	// Timer mode
	SCI2_TMR_TOMS_00 = 0x0
	// Break Field low width determination mode
	SCI2_TMR_TOMS_01 = 0x1
	// Break Field low width output mode
	SCI2_TMR_TOMS_10 = 0x2
	// Setting prohibited
	SCI2_TMR_TOMS_11 = 0x3
	// Position of TWRC field.
	SCI2_TMR_TWRC_Pos = 0x3
	// Bit mask of TWRC field.
	SCI2_TMR_TWRC_Msk = 0x8
	// Bit TWRC.
	SCI2_TMR_TWRC = 0x8
	// Data is written to the reload register and counter
	SCI2_TMR_TWRC_0 = 0x0
	// Data is written to the reload register only
	SCI2_TMR_TWRC_1 = 0x1
	// Position of TCSS field.
	SCI2_TMR_TCSS_Pos = 0x4
	// Bit mask of TCSS field.
	SCI2_TMR_TCSS_Msk = 0x70
	// PCLK
	SCI2_TMR_TCSS_000 = 0x0
	// PCLK/2
	SCI2_TMR_TCSS_001 = 0x1
	// PCLK/4
	SCI2_TMR_TCSS_010 = 0x2
	// PCLK/8
	SCI2_TMR_TCSS_011 = 0x3
	// PCLK/16
	SCI2_TMR_TCSS_100 = 0x4
	// PCLK/32
	SCI2_TMR_TCSS_101 = 0x5
	// PCLK/64
	SCI2_TMR_TCSS_110 = 0x6
	// PCLK/128
	SCI2_TMR_TCSS_111 = 0x7
)

// Constants for SCI3: Serial Communication Interface
const (
	// SMR: Serial Mode Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
	// Position of CKS field.
	SCI3_SMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI3_SMR_CKS_Msk = 0x3
	// PCLK clock (n = 0)
	SCI3_SMR_CKS_00 = 0x0
	// PCLK/4 clock (n = 1)
	SCI3_SMR_CKS_01 = 0x1
	// PCLK/16 clock (n = 2)
	SCI3_SMR_CKS_10 = 0x2
	// PCLK/64 clock (n = 3)
	SCI3_SMR_CKS_11 = 0x3
	// Position of MP field.
	SCI3_SMR_MP_Pos = 0x2
	// Bit mask of MP field.
	SCI3_SMR_MP_Msk = 0x4
	// Bit MP.
	SCI3_SMR_MP = 0x4
	// Disable multi-processor communications function
	SCI3_SMR_MP_0 = 0x0
	// Enable multi-processor communications function
	SCI3_SMR_MP_1 = 0x1
	// Position of STOP field.
	SCI3_SMR_STOP_Pos = 0x3
	// Bit mask of STOP field.
	SCI3_SMR_STOP_Msk = 0x8
	// Bit STOP.
	SCI3_SMR_STOP = 0x8
	// 1 stop bit
	SCI3_SMR_STOP_0 = 0x0
	// 2 stop bits
	SCI3_SMR_STOP_1 = 0x1
	// Position of PM field.
	SCI3_SMR_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI3_SMR_PM_Msk = 0x10
	// Bit PM.
	SCI3_SMR_PM = 0x10
	// Even parity
	SCI3_SMR_PM_0 = 0x0
	// Odd parity
	SCI3_SMR_PM_1 = 0x1
	// Position of PE field.
	SCI3_SMR_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI3_SMR_PE_Msk = 0x20
	// Bit PE.
	SCI3_SMR_PE = 0x20
	// When transmitting: Do not add parity bit When receiving: Do not check parity bit
	SCI3_SMR_PE_0 = 0x0
	// When transmitting: Add parity bit When receiving: Check parity bit
	SCI3_SMR_PE_1 = 0x1
	// Position of CHR field.
	SCI3_SMR_CHR_Pos = 0x6
	// Bit mask of CHR field.
	SCI3_SMR_CHR_Msk = 0x40
	// Bit CHR.
	SCI3_SMR_CHR = 0x40
	// SCMR.CHR1 = 0: Transmit/receive in 9-bit data length SCMR.CHR1 = 1: Transmit/receive in 8-bit data length (initial value)
	SCI3_SMR_CHR_0 = 0x0
	// SCMR.CHR1 = 0: Transmit/receive in 9-bit data length SCMR.CHR1 = 1: Transmit/receive in 7-bit data length
	SCI3_SMR_CHR_1 = 0x1
	// Position of CM field.
	SCI3_SMR_CM_Pos = 0x7
	// Bit mask of CM field.
	SCI3_SMR_CM_Msk = 0x80
	// Bit CM.
	SCI3_SMR_CM = 0x80
	// Asynchronous mode or simple IIC mode
	SCI3_SMR_CM_0 = 0x0
	// Clock synchronous mode or simple SPI mode
	SCI3_SMR_CM_1 = 0x1

	// SMR_SMCI: Serial Mode Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of CKS field.
	SCI3_SMR_SMCI_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI3_SMR_SMCI_CKS_Msk = 0x3
	// PCLK clock (n = 0)
	SCI3_SMR_SMCI_CKS_00 = 0x0
	// PCLK/4 clock (n = 1)
	SCI3_SMR_SMCI_CKS_01 = 0x1
	// PCLK/16 clock (n = 2)
	SCI3_SMR_SMCI_CKS_10 = 0x2
	// PCLK/64 clock (n = 3)
	SCI3_SMR_SMCI_CKS_11 = 0x3
	// Position of BCP field.
	SCI3_SMR_SMCI_BCP_Pos = 0x2
	// Bit mask of BCP field.
	SCI3_SMR_SMCI_BCP_Msk = 0xc
	// Position of PM field.
	SCI3_SMR_SMCI_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI3_SMR_SMCI_PM_Msk = 0x10
	// Bit PM.
	SCI3_SMR_SMCI_PM = 0x10
	// Even parity
	SCI3_SMR_SMCI_PM_0 = 0x0
	// Odd parity
	SCI3_SMR_SMCI_PM_1 = 0x1
	// Position of PE field.
	SCI3_SMR_SMCI_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI3_SMR_SMCI_PE_Msk = 0x20
	// Bit PE.
	SCI3_SMR_SMCI_PE = 0x20
	// Position of BLK field.
	SCI3_SMR_SMCI_BLK_Pos = 0x6
	// Bit mask of BLK field.
	SCI3_SMR_SMCI_BLK_Msk = 0x40
	// Bit BLK.
	SCI3_SMR_SMCI_BLK = 0x40
	// Normal mode operation
	SCI3_SMR_SMCI_BLK_0 = 0x0
	// Block transfer mode operation
	SCI3_SMR_SMCI_BLK_1 = 0x1
	// Position of GM field.
	SCI3_SMR_SMCI_GM_Pos = 0x7
	// Bit mask of GM field.
	SCI3_SMR_SMCI_GM_Msk = 0x80
	// Bit GM.
	SCI3_SMR_SMCI_GM = 0x80
	// Normal mode operation
	SCI3_SMR_SMCI_GM_0 = 0x0
	// GSM mode operation
	SCI3_SMR_SMCI_GM_1 = 0x1

	// SCR: Serial Control Register for Non-Smart Card Interface Mode (SCMR.SMIF = 0)
	// Position of CKE field.
	SCI3_SCR_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI3_SCR_CKE_Msk = 0x3
	// In asynchronous mode, the SCKn pin is available for use as an I/O port based on the I/O port settings. In clock synchronous mode, the SCKn pin functions as the clock output pin.
	SCI3_SCR_CKE_00 = 0x0
	// In asynchronous mode, a clock with the same frequency as the bit rate is output from the SCKn pin. In clock synchronous mode, the SCKn pin functions as the clock output pin.
	SCI3_SCR_CKE_01 = 0x1
	// Position of TEIE field.
	SCI3_SCR_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI3_SCR_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI3_SCR_TEIE = 0x4
	// Disable SCIn_TEI interrupt requests
	SCI3_SCR_TEIE_0 = 0x0
	// Enable SCIn_TEI interrupt requests
	SCI3_SCR_TEIE_1 = 0x1
	// Position of MPIE field.
	SCI3_SCR_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI3_SCR_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI3_SCR_MPIE = 0x8
	// Normal reception
	SCI3_SCR_MPIE_0 = 0x0
	// When data with the multi-processor bit set to 0 is received, the data is not read, and setting the status flags RDRF, ORER, and FER in SSR to 1 and the status flags SYER, PFER, and SBER in MESR are disabled. When data with the multi-processor bit set to 1 is received, the MPIE bit is automatically set to 0, and normal reception is resumed.
	SCI3_SCR_MPIE_1 = 0x1
	// Position of RE field.
	SCI3_SCR_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI3_SCR_RE_Msk = 0x10
	// Bit RE.
	SCI3_SCR_RE = 0x10
	// Disable serial reception
	SCI3_SCR_RE_0 = 0x0
	// Enable serial reception
	SCI3_SCR_RE_1 = 0x1
	// Position of TE field.
	SCI3_SCR_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI3_SCR_TE_Msk = 0x20
	// Bit TE.
	SCI3_SCR_TE = 0x20
	// Disable serial transmission
	SCI3_SCR_TE_0 = 0x0
	// Enable serial transmission
	SCI3_SCR_TE_1 = 0x1
	// Position of RIE field.
	SCI3_SCR_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI3_SCR_RIE_Msk = 0x40
	// Bit RIE.
	SCI3_SCR_RIE = 0x40
	// Disable SCIn_RXI and SCIn_ERI interrupt requests
	SCI3_SCR_RIE_0 = 0x0
	// Enable SCIn_RXI and SCIn_ERI interrupt requests
	SCI3_SCR_RIE_1 = 0x1
	// Position of TIE field.
	SCI3_SCR_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI3_SCR_TIE_Msk = 0x80
	// Bit TIE.
	SCI3_SCR_TIE = 0x80
	// Disable SCIn_TXI interrupt requests
	SCI3_SCR_TIE_0 = 0x0
	// Enable SCIn_TXI interrupt requests
	SCI3_SCR_TIE_1 = 0x1

	// SCR_SMCI: Serial Control Register for Smart Card Interface Mode (SCMR.SMIF = 1)
	// Position of CKE field.
	SCI3_SCR_SMCI_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI3_SCR_SMCI_CKE_Msk = 0x3
	// When SMR_SMCI.GM = 0: Disable output The SCKn pin is available for use as an I/O port if set up in the I/O port settings When SMR_SMCI.GM = 1: Fix output low
	SCI3_SCR_SMCI_CKE_00 = 0x0
	// When SMR_SMCI.GM = 0: Output clock When SMR_SMCI.GM = 1: Output clock
	SCI3_SCR_SMCI_CKE_01 = 0x1
	// When SMR_SMCI.GM = 0: Setting prohibited When SMR_SMCI.GM = 1: Fix output high
	SCI3_SCR_SMCI_CKE_10 = 0x2
	// When SMR_SMCI.GM = 0: Setting prohibited When SMR_SMCI.GM = 1: Output clock
	SCI3_SCR_SMCI_CKE_11 = 0x3
	// Position of TEIE field.
	SCI3_SCR_SMCI_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI3_SCR_SMCI_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI3_SCR_SMCI_TEIE = 0x4
	// Position of MPIE field.
	SCI3_SCR_SMCI_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI3_SCR_SMCI_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI3_SCR_SMCI_MPIE = 0x8
	// Position of RE field.
	SCI3_SCR_SMCI_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI3_SCR_SMCI_RE_Msk = 0x10
	// Bit RE.
	SCI3_SCR_SMCI_RE = 0x10
	// Disable serial reception
	SCI3_SCR_SMCI_RE_0 = 0x0
	// Enable serial reception
	SCI3_SCR_SMCI_RE_1 = 0x1
	// Position of TE field.
	SCI3_SCR_SMCI_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI3_SCR_SMCI_TE_Msk = 0x20
	// Bit TE.
	SCI3_SCR_SMCI_TE = 0x20
	// Disable serial transmission
	SCI3_SCR_SMCI_TE_0 = 0x0
	// Enable serial transmission
	SCI3_SCR_SMCI_TE_1 = 0x1
	// Position of RIE field.
	SCI3_SCR_SMCI_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI3_SCR_SMCI_RIE_Msk = 0x40
	// Bit RIE.
	SCI3_SCR_SMCI_RIE = 0x40
	// Disable SCIn_RXI and SCIn_ERI interrupt requests
	SCI3_SCR_SMCI_RIE_0 = 0x0
	// Enable SCIn_RXI and SCIn_ERI interrupt requests
	SCI3_SCR_SMCI_RIE_1 = 0x1
	// Position of TIE field.
	SCI3_SCR_SMCI_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI3_SCR_SMCI_TIE_Msk = 0x80
	// Bit TIE.
	SCI3_SCR_SMCI_TIE = 0x80
	// Disable SCIn_TXI interrupt requests
	SCI3_SCR_SMCI_TIE_0 = 0x0
	// Enable SCIn_TXI interrupt requests
	SCI3_SCR_SMCI_TIE_1 = 0x1

	// SSR: Serial Status Register for Non-Smart Card Interface and Non-FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0, and MMR.MANEN = 0)
	// Position of MPBT field.
	SCI3_SSR_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI3_SSR_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI3_SSR_MPBT = 0x1
	// Data transmission cycle
	SCI3_SSR_MPBT_0 = 0x0
	// ID transmission cycle
	SCI3_SSR_MPBT_1 = 0x1
	// Position of MPB field.
	SCI3_SSR_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI3_SSR_MPB_Msk = 0x2
	// Bit MPB.
	SCI3_SSR_MPB = 0x2
	// Data transmission cycle
	SCI3_SSR_MPB_0 = 0x0
	// ID transmission cycle
	SCI3_SSR_MPB_1 = 0x1
	// Position of TEND field.
	SCI3_SSR_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI3_SSR_TEND_Msk = 0x4
	// Bit TEND.
	SCI3_SSR_TEND = 0x4
	// A character is being transmitted
	SCI3_SSR_TEND_0 = 0x0
	// Character transfer is complete
	SCI3_SSR_TEND_1 = 0x1
	// Position of PER field.
	SCI3_SSR_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI3_SSR_PER_Msk = 0x8
	// Bit PER.
	SCI3_SSR_PER = 0x8
	// No parity error occurred
	SCI3_SSR_PER_0 = 0x0
	// Parity error occurred
	SCI3_SSR_PER_1 = 0x1
	// Position of FER field.
	SCI3_SSR_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI3_SSR_FER_Msk = 0x10
	// Bit FER.
	SCI3_SSR_FER = 0x10
	// No framing error occurred
	SCI3_SSR_FER_0 = 0x0
	// Framing error occurred
	SCI3_SSR_FER_1 = 0x1
	// Position of ORER field.
	SCI3_SSR_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI3_SSR_ORER_Msk = 0x20
	// Bit ORER.
	SCI3_SSR_ORER = 0x20
	// No overrun error occurred
	SCI3_SSR_ORER_0 = 0x0
	// Overrun error occurred
	SCI3_SSR_ORER_1 = 0x1
	// Position of RDRF field.
	SCI3_SSR_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI3_SSR_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI3_SSR_RDRF = 0x40
	// No received data in RDR register
	SCI3_SSR_RDRF_0 = 0x0
	// Received data in RDR register
	SCI3_SSR_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI3_SSR_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI3_SSR_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI3_SSR_TDRE = 0x80
	// Transmit data in TDR register
	SCI3_SSR_TDRE_0 = 0x0
	// No transmit data in TDR register
	SCI3_SSR_TDRE_1 = 0x1

	// SSR_FIFO: Serial Status Register for Non-Smart Card Interface and FIFO Mode (SCMR.SMIF = 0, FCR.FM = 1, and MMR.MANEN = 0)
	// Position of DR field.
	SCI3_SSR_FIFO_DR_Pos = 0x0
	// Bit mask of DR field.
	SCI3_SSR_FIFO_DR_Msk = 0x1
	// Bit DR.
	SCI3_SSR_FIFO_DR = 0x1
	// Receiving is in progress, or no received data remains in FRDRHL after successfully completed reception (receive FIFO empty)
	SCI3_SSR_FIFO_DR_0 = 0x0
	// Next receive data is not received for a period after normal receiving is complete, when the amount of data stored in the FIFO is equal to or less than the receive triggering number
	SCI3_SSR_FIFO_DR_1 = 0x1
	// Position of TEND field.
	SCI3_SSR_FIFO_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI3_SSR_FIFO_TEND_Msk = 0x4
	// Bit TEND.
	SCI3_SSR_FIFO_TEND = 0x4
	// A character is being transmitted
	SCI3_SSR_FIFO_TEND_0 = 0x0
	// Character transfer is complete
	SCI3_SSR_FIFO_TEND_1 = 0x1
	// Position of PER field.
	SCI3_SSR_FIFO_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI3_SSR_FIFO_PER_Msk = 0x8
	// Bit PER.
	SCI3_SSR_FIFO_PER = 0x8
	// No parity error occurred
	SCI3_SSR_FIFO_PER_0 = 0x0
	// Parity error occurred
	SCI3_SSR_FIFO_PER_1 = 0x1
	// Position of FER field.
	SCI3_SSR_FIFO_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI3_SSR_FIFO_FER_Msk = 0x10
	// Bit FER.
	SCI3_SSR_FIFO_FER = 0x10
	// No framing error occurred
	SCI3_SSR_FIFO_FER_0 = 0x0
	// Framing error occurred
	SCI3_SSR_FIFO_FER_1 = 0x1
	// Position of ORER field.
	SCI3_SSR_FIFO_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI3_SSR_FIFO_ORER_Msk = 0x20
	// Bit ORER.
	SCI3_SSR_FIFO_ORER = 0x20
	// No overrun error occurred
	SCI3_SSR_FIFO_ORER_0 = 0x0
	// Overrun error occurred
	SCI3_SSR_FIFO_ORER_1 = 0x1
	// Position of RDF field.
	SCI3_SSR_FIFO_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI3_SSR_FIFO_RDF_Msk = 0x40
	// Bit RDF.
	SCI3_SSR_FIFO_RDF = 0x40
	// The amount of receive data written in FRDRHL is less than the specified receive triggering number
	SCI3_SSR_FIFO_RDF_0 = 0x0
	// The amount of receive data written in FRDRHL is equal to or greater than the specified receive triggering number
	SCI3_SSR_FIFO_RDF_1 = 0x1
	// Position of TDFE field.
	SCI3_SSR_FIFO_TDFE_Pos = 0x7
	// Bit mask of TDFE field.
	SCI3_SSR_FIFO_TDFE_Msk = 0x80
	// Bit TDFE.
	SCI3_SSR_FIFO_TDFE = 0x80
	// The amount of transmit data written in FTDRHL exceeds the specified transmit triggering number
	SCI3_SSR_FIFO_TDFE_0 = 0x0
	// The amount of transmit data written in FTDRHL is equal to or less than the specified transmit triggering number
	SCI3_SSR_FIFO_TDFE_1 = 0x1

	// SSR_MANC: Serial Status Register for Manchester Mode (SCMR.SMIF = 0, and MMR.MANEN = 1)
	// Position of MER field.
	SCI3_SSR_MANC_MER_Pos = 0x0
	// Bit mask of MER field.
	SCI3_SSR_MANC_MER_Msk = 0x1
	// Bit MER.
	SCI3_SSR_MANC_MER = 0x1
	// No Manchester error occurred
	SCI3_SSR_MANC_MER_0 = 0x0
	// Manchester error has occurred
	SCI3_SSR_MANC_MER_1 = 0x1
	// Position of MPB field.
	SCI3_SSR_MANC_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI3_SSR_MANC_MPB_Msk = 0x2
	// Bit MPB.
	SCI3_SSR_MANC_MPB = 0x2
	// Data transmission cycles
	SCI3_SSR_MANC_MPB_0 = 0x0
	// ID transmission cycles
	SCI3_SSR_MANC_MPB_1 = 0x1
	// Position of TEND field.
	SCI3_SSR_MANC_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI3_SSR_MANC_TEND_Msk = 0x4
	// Bit TEND.
	SCI3_SSR_MANC_TEND = 0x4
	// A character is being transmitted
	SCI3_SSR_MANC_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI3_SSR_MANC_TEND_1 = 0x1
	// Position of PER field.
	SCI3_SSR_MANC_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI3_SSR_MANC_PER_Msk = 0x8
	// Bit PER.
	SCI3_SSR_MANC_PER = 0x8
	// No parity error occurred
	SCI3_SSR_MANC_PER_0 = 0x0
	// A parity error has occurred
	SCI3_SSR_MANC_PER_1 = 0x1
	// Position of FER field.
	SCI3_SSR_MANC_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI3_SSR_MANC_FER_Msk = 0x10
	// Bit FER.
	SCI3_SSR_MANC_FER = 0x10
	// No framing error occurred
	SCI3_SSR_MANC_FER_0 = 0x0
	// A framing error has occurred
	SCI3_SSR_MANC_FER_1 = 0x1
	// Position of ORER field.
	SCI3_SSR_MANC_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI3_SSR_MANC_ORER_Msk = 0x20
	// Bit ORER.
	SCI3_SSR_MANC_ORER = 0x20
	// No overrun error occurred
	SCI3_SSR_MANC_ORER_0 = 0x0
	// An overrun error has occurred
	SCI3_SSR_MANC_ORER_1 = 0x1
	// Position of RDRF field.
	SCI3_SSR_MANC_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI3_SSR_MANC_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI3_SSR_MANC_RDRF = 0x40
	// No received data is in RDR register
	SCI3_SSR_MANC_RDRF_0 = 0x0
	// Received data is in RDR register
	SCI3_SSR_MANC_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI3_SSR_MANC_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI3_SSR_MANC_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI3_SSR_MANC_TDRE = 0x80
	// Transmit data is in TDR register
	SCI3_SSR_MANC_TDRE_0 = 0x0
	// No transmit data is in TDR register
	SCI3_SSR_MANC_TDRE_1 = 0x1

	// SSR_SMCI: Serial Status Register for Smart Card Interface Mode (SCMR.SMIF = 1, and MMR.MANEN = 0)
	// Position of MPBT field.
	SCI3_SSR_SMCI_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI3_SSR_SMCI_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI3_SSR_SMCI_MPBT = 0x1
	// Position of MPB field.
	SCI3_SSR_SMCI_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI3_SSR_SMCI_MPB_Msk = 0x2
	// Bit MPB.
	SCI3_SSR_SMCI_MPB = 0x2
	// Position of TEND field.
	SCI3_SSR_SMCI_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI3_SSR_SMCI_TEND_Msk = 0x4
	// Bit TEND.
	SCI3_SSR_SMCI_TEND = 0x4
	// A character is being transmitted
	SCI3_SSR_SMCI_TEND_0 = 0x0
	// Character transfer is complete
	SCI3_SSR_SMCI_TEND_1 = 0x1
	// Position of PER field.
	SCI3_SSR_SMCI_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI3_SSR_SMCI_PER_Msk = 0x8
	// Bit PER.
	SCI3_SSR_SMCI_PER = 0x8
	// No parity error occurred
	SCI3_SSR_SMCI_PER_0 = 0x0
	// Parity error occurred
	SCI3_SSR_SMCI_PER_1 = 0x1
	// Position of ERS field.
	SCI3_SSR_SMCI_ERS_Pos = 0x4
	// Bit mask of ERS field.
	SCI3_SSR_SMCI_ERS_Msk = 0x10
	// Bit ERS.
	SCI3_SSR_SMCI_ERS = 0x10
	// No low error signal response
	SCI3_SSR_SMCI_ERS_0 = 0x0
	// Low error signal response occurred
	SCI3_SSR_SMCI_ERS_1 = 0x1
	// Position of ORER field.
	SCI3_SSR_SMCI_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI3_SSR_SMCI_ORER_Msk = 0x20
	// Bit ORER.
	SCI3_SSR_SMCI_ORER = 0x20
	// No overrun error occurred
	SCI3_SSR_SMCI_ORER_0 = 0x0
	// Overrun error occurred
	SCI3_SSR_SMCI_ORER_1 = 0x1
	// Position of RDRF field.
	SCI3_SSR_SMCI_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI3_SSR_SMCI_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI3_SSR_SMCI_RDRF = 0x40
	// No received data in RDR register
	SCI3_SSR_SMCI_RDRF_0 = 0x0
	// Received data in RDR register
	SCI3_SSR_SMCI_RDRF_1 = 0x1
	// Position of TDRE field.
	SCI3_SSR_SMCI_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI3_SSR_SMCI_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI3_SSR_SMCI_TDRE = 0x80
	// Transmit data in TDR register
	SCI3_SSR_SMCI_TDRE_0 = 0x0
	// No transmit data in TDR register
	SCI3_SSR_SMCI_TDRE_1 = 0x1

	// SCMR: Smart Card Mode Register
	// Position of SMIF field.
	SCI3_SCMR_SMIF_Pos = 0x0
	// Bit mask of SMIF field.
	SCI3_SCMR_SMIF_Msk = 0x1
	// Bit SMIF.
	SCI3_SCMR_SMIF = 0x1
	// Non-smart card interface mode (asynchronous mode, clock synchronous mode, simple SPI mode, or simple IIC mode)
	SCI3_SCMR_SMIF_0 = 0x0
	// Smart card interface mode
	SCI3_SCMR_SMIF_1 = 0x1
	// Position of SINV field.
	SCI3_SCMR_SINV_Pos = 0x2
	// Bit mask of SINV field.
	SCI3_SCMR_SINV_Msk = 0x4
	// Bit SINV.
	SCI3_SCMR_SINV = 0x4
	// TDR contents are transmitted as they are. Received data is stored as received in the RDR register.
	SCI3_SCMR_SINV_0 = 0x0
	// TDR register contents are inverted before transmission. Receive data is stored in inverted form in the RDR register.
	SCI3_SCMR_SINV_1 = 0x1
	// Position of SDIR field.
	SCI3_SCMR_SDIR_Pos = 0x3
	// Bit mask of SDIR field.
	SCI3_SCMR_SDIR_Msk = 0x8
	// Bit SDIR.
	SCI3_SCMR_SDIR = 0x8
	// Transfer LSB-first
	SCI3_SCMR_SDIR_0 = 0x0
	// Transfer MSB-first
	SCI3_SCMR_SDIR_1 = 0x1
	// Position of CHR1 field.
	SCI3_SCMR_CHR1_Pos = 0x4
	// Bit mask of CHR1 field.
	SCI3_SCMR_CHR1_Msk = 0x10
	// Bit CHR1.
	SCI3_SCMR_CHR1 = 0x10
	// SMR.CHR = 0: Transmit/receive in 9-bit data length SMR.CHR = 1: Transmit/receive in 9-bit data length
	SCI3_SCMR_CHR1_0 = 0x0
	// SMR.CHR = 0: Transmit/receive in 8-bit data length (initial value) SMR.CHR = 1: Transmit/receive in 7-bit data length
	SCI3_SCMR_CHR1_1 = 0x1
	// Position of BCP2 field.
	SCI3_SCMR_BCP2_Pos = 0x7
	// Bit mask of BCP2 field.
	SCI3_SCMR_BCP2_Msk = 0x80
	// Bit BCP2.
	SCI3_SCMR_BCP2 = 0x80

	// SEMR: Serial Extended Mode Register
	// Position of ACS0 field.
	SCI3_SEMR_ACS0_Pos = 0x0
	// Bit mask of ACS0 field.
	SCI3_SEMR_ACS0_Msk = 0x1
	// Bit ACS0.
	SCI3_SEMR_ACS0 = 0x1
	// External clock input
	SCI3_SEMR_ACS0_0 = 0x0
	// Logical AND of compare matches output from the internal GPT. These bit for the other SCI channels than SCIn (n = 2) are reserved.
	SCI3_SEMR_ACS0_1 = 0x1
	// Position of PADIS field.
	SCI3_SEMR_PADIS_Pos = 0x1
	// Bit mask of PADIS field.
	SCI3_SEMR_PADIS_Msk = 0x2
	// Bit PADIS.
	SCI3_SEMR_PADIS = 0x2
	// Preamble output function is enabled
	SCI3_SEMR_PADIS_0 = 0x0
	// Preamble output function is disabled These bits for the other SCI channels than SCIn (n = 0, 3, 4, 9) are reserved.
	SCI3_SEMR_PADIS_1 = 0x1
	// Position of BRME field.
	SCI3_SEMR_BRME_Pos = 0x2
	// Bit mask of BRME field.
	SCI3_SEMR_BRME_Msk = 0x4
	// Bit BRME.
	SCI3_SEMR_BRME = 0x4
	// Disable bit rate modulation function
	SCI3_SEMR_BRME_0 = 0x0
	// Enable bit rate modulation function
	SCI3_SEMR_BRME_1 = 0x1
	// Position of ABCSE field.
	SCI3_SEMR_ABCSE_Pos = 0x3
	// Bit mask of ABCSE field.
	SCI3_SEMR_ABCSE_Msk = 0x8
	// Bit ABCSE.
	SCI3_SEMR_ABCSE = 0x8
	// Clock cycles for 1-bit period determined by combination of the BGDM and ABCS bits in the SEMR register
	SCI3_SEMR_ABCSE_0 = 0x0
	// Baud rate is 6 base clock cycles for 1-bit period These bits for the other SCI channels than SCIn (n = 0, 3, 4, 9) are reserved.
	SCI3_SEMR_ABCSE_1 = 0x1
	// Position of ABCS field.
	SCI3_SEMR_ABCS_Pos = 0x4
	// Bit mask of ABCS field.
	SCI3_SEMR_ABCS_Msk = 0x10
	// Bit ABCS.
	SCI3_SEMR_ABCS = 0x10
	// Select 16 base clock cycles for 1-bit period
	SCI3_SEMR_ABCS_0 = 0x0
	// Select 8 base clock cycles for 1-bit period
	SCI3_SEMR_ABCS_1 = 0x1
	// Position of NFEN field.
	SCI3_SEMR_NFEN_Pos = 0x5
	// Bit mask of NFEN field.
	SCI3_SEMR_NFEN_Msk = 0x20
	// Bit NFEN.
	SCI3_SEMR_NFEN = 0x20
	// In asynchronous mode: Disable noise cancellation function for RXDn input signal In simple I2C mode: Disable noise cancellation function for SCLn and SDAn input signals
	SCI3_SEMR_NFEN_0 = 0x0
	// In asynchronous mode: Enable noise cancellation function for RXDn input signal In simple I2C mode: Enable noise cancellation function for SCLn and SDAn input signals
	SCI3_SEMR_NFEN_1 = 0x1
	// Position of BGDM field.
	SCI3_SEMR_BGDM_Pos = 0x6
	// Bit mask of BGDM field.
	SCI3_SEMR_BGDM_Msk = 0x40
	// Bit BGDM.
	SCI3_SEMR_BGDM = 0x40
	// Output clock from baud rate generator with normal frequency
	SCI3_SEMR_BGDM_0 = 0x0
	// Output clock from baud rate generator with doubled frequency
	SCI3_SEMR_BGDM_1 = 0x1
	// Position of RXDESEL field.
	SCI3_SEMR_RXDESEL_Pos = 0x7
	// Bit mask of RXDESEL field.
	SCI3_SEMR_RXDESEL_Msk = 0x80
	// Bit RXDESEL.
	SCI3_SEMR_RXDESEL = 0x80
	// Detect low level on RXDn pin as start bit
	SCI3_SEMR_RXDESEL_0 = 0x0
	// Detect falling edge of RXDn pin as start bit
	SCI3_SEMR_RXDESEL_1 = 0x1

	// SNFR: Noise Filter Setting Register
	// Position of NFCS field.
	SCI3_SNFR_NFCS_Pos = 0x0
	// Bit mask of NFCS field.
	SCI3_SNFR_NFCS_Msk = 0x7
	// In asynchronous mode: Use clock signal divided by 1 with noise filter In simple I2C mode: Setting prohibited
	SCI3_SNFR_NFCS_000 = 0x0
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 1 with noise filter
	SCI3_SNFR_NFCS_001 = 0x1
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 2 with noise filter
	SCI3_SNFR_NFCS_010 = 0x2
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 4 with noise filter
	SCI3_SNFR_NFCS_011 = 0x3
	// In asynchronous mode: Setting prohibited In simple I2C mode: Use clock signal divided by 8 with noise filter
	SCI3_SNFR_NFCS_100 = 0x4

	// SIMR1: IIC Mode Register 1
	// Position of IICM field.
	SCI3_SIMR1_IICM_Pos = 0x0
	// Bit mask of IICM field.
	SCI3_SIMR1_IICM_Msk = 0x1
	// Bit IICM.
	SCI3_SIMR1_IICM = 0x1
	// SCMR.SMIF = 0: Asynchronous mode (including multi-processor mode), clock synchronous mode, or simple SPI mode SCMR.SMIF = 1: Smart card interface mode
	SCI3_SIMR1_IICM_0 = 0x0
	// SCMR.SMIF = 0: Simple IIC mode SCMR.SMIF = 1: Setting prohibited
	SCI3_SIMR1_IICM_1 = 0x1
	// Position of IICDL field.
	SCI3_SIMR1_IICDL_Pos = 0x3
	// Bit mask of IICDL field.
	SCI3_SIMR1_IICDL_Msk = 0xf8
	// No output delay
	SCI3_SIMR1_IICDL_0x00 = 0x0

	// SIMR2: IIC Mode Register 2
	// Position of IICINTM field.
	SCI3_SIMR2_IICINTM_Pos = 0x0
	// Bit mask of IICINTM field.
	SCI3_SIMR2_IICINTM_Msk = 0x1
	// Bit IICINTM.
	SCI3_SIMR2_IICINTM = 0x1
	// Use ACK/NACK interrupts
	SCI3_SIMR2_IICINTM_0 = 0x0
	// Use reception and transmission interrupts
	SCI3_SIMR2_IICINTM_1 = 0x1
	// Position of IICCSC field.
	SCI3_SIMR2_IICCSC_Pos = 0x1
	// Bit mask of IICCSC field.
	SCI3_SIMR2_IICCSC_Msk = 0x2
	// Bit IICCSC.
	SCI3_SIMR2_IICCSC = 0x2
	// Do not synchronize with clock signal
	SCI3_SIMR2_IICCSC_0 = 0x0
	// Synchronize with clock signal
	SCI3_SIMR2_IICCSC_1 = 0x1
	// Position of IICACKT field.
	SCI3_SIMR2_IICACKT_Pos = 0x5
	// Bit mask of IICACKT field.
	SCI3_SIMR2_IICACKT_Msk = 0x20
	// Bit IICACKT.
	SCI3_SIMR2_IICACKT = 0x20
	// ACK transmission
	SCI3_SIMR2_IICACKT_0 = 0x0
	// NACK transmission and ACK/NACK reception
	SCI3_SIMR2_IICACKT_1 = 0x1

	// SIMR3: IIC Mode Register 3
	// Position of IICSTAREQ field.
	SCI3_SIMR3_IICSTAREQ_Pos = 0x0
	// Bit mask of IICSTAREQ field.
	SCI3_SIMR3_IICSTAREQ_Msk = 0x1
	// Bit IICSTAREQ.
	SCI3_SIMR3_IICSTAREQ = 0x1
	// Do not generate start condition
	SCI3_SIMR3_IICSTAREQ_0 = 0x0
	// Generate start condition
	SCI3_SIMR3_IICSTAREQ_1 = 0x1
	// Position of IICRSTAREQ field.
	SCI3_SIMR3_IICRSTAREQ_Pos = 0x1
	// Bit mask of IICRSTAREQ field.
	SCI3_SIMR3_IICRSTAREQ_Msk = 0x2
	// Bit IICRSTAREQ.
	SCI3_SIMR3_IICRSTAREQ = 0x2
	// Do not generate restart condition
	SCI3_SIMR3_IICRSTAREQ_0 = 0x0
	// Generate restart condition
	SCI3_SIMR3_IICRSTAREQ_1 = 0x1
	// Position of IICSTPREQ field.
	SCI3_SIMR3_IICSTPREQ_Pos = 0x2
	// Bit mask of IICSTPREQ field.
	SCI3_SIMR3_IICSTPREQ_Msk = 0x4
	// Bit IICSTPREQ.
	SCI3_SIMR3_IICSTPREQ = 0x4
	// Do not generate stop condition
	SCI3_SIMR3_IICSTPREQ_0 = 0x0
	// Generate stop condition
	SCI3_SIMR3_IICSTPREQ_1 = 0x1
	// Position of IICSTIF field.
	SCI3_SIMR3_IICSTIF_Pos = 0x3
	// Bit mask of IICSTIF field.
	SCI3_SIMR3_IICSTIF_Msk = 0x8
	// Bit IICSTIF.
	SCI3_SIMR3_IICSTIF = 0x8
	// No requests are being made for generating conditions, or a condition is being generated
	SCI3_SIMR3_IICSTIF_0 = 0x0
	// Generation of start, restart, or stop condition is complete. When 0 is written to IICSTIF, it is set to 0
	SCI3_SIMR3_IICSTIF_1 = 0x1
	// Position of IICSDAS field.
	SCI3_SIMR3_IICSDAS_Pos = 0x4
	// Bit mask of IICSDAS field.
	SCI3_SIMR3_IICSDAS_Msk = 0x30
	// Output serial data
	SCI3_SIMR3_IICSDAS_00 = 0x0
	// Generate start, restart, or stop condition
	SCI3_SIMR3_IICSDAS_01 = 0x1
	// Output low on SDAn pin
	SCI3_SIMR3_IICSDAS_10 = 0x2
	// Drive SDAn pin to high-impedance state
	SCI3_SIMR3_IICSDAS_11 = 0x3
	// Position of IICSCLS field.
	SCI3_SIMR3_IICSCLS_Pos = 0x6
	// Bit mask of IICSCLS field.
	SCI3_SIMR3_IICSCLS_Msk = 0xc0
	// Output serial clock
	SCI3_SIMR3_IICSCLS_00 = 0x0
	// Generate start, restart, or stop condition
	SCI3_SIMR3_IICSCLS_01 = 0x1
	// Output low on SCLn pin
	SCI3_SIMR3_IICSCLS_10 = 0x2
	// Drive SCLn pin to high-impedance state
	SCI3_SIMR3_IICSCLS_11 = 0x3

	// SISR: IIC Status Register
	// Position of IICACKR field.
	SCI3_SISR_IICACKR_Pos = 0x0
	// Bit mask of IICACKR field.
	SCI3_SISR_IICACKR_Msk = 0x1
	// Bit IICACKR.
	SCI3_SISR_IICACKR = 0x1
	// ACK received
	SCI3_SISR_IICACKR_0 = 0x0
	// NACK received
	SCI3_SISR_IICACKR_1 = 0x1

	// SPMR: SPI Mode Register
	// Position of SSE field.
	SCI3_SPMR_SSE_Pos = 0x0
	// Bit mask of SSE field.
	SCI3_SPMR_SSE_Msk = 0x1
	// Bit SSE.
	SCI3_SPMR_SSE = 0x1
	// Disable SSn pin function
	SCI3_SPMR_SSE_0 = 0x0
	// Enable SSn pin function
	SCI3_SPMR_SSE_1 = 0x1
	// Position of CTSE field.
	SCI3_SPMR_CTSE_Pos = 0x1
	// Bit mask of CTSE field.
	SCI3_SPMR_CTSE_Msk = 0x2
	// Bit CTSE.
	SCI3_SPMR_CTSE = 0x2
	// Disable CTS function (enable RTS output function)
	SCI3_SPMR_CTSE_0 = 0x0
	// Enable CTS function
	SCI3_SPMR_CTSE_1 = 0x1
	// Position of MSS field.
	SCI3_SPMR_MSS_Pos = 0x2
	// Bit mask of MSS field.
	SCI3_SPMR_MSS_Msk = 0x4
	// Bit MSS.
	SCI3_SPMR_MSS = 0x4
	// Transmit through TXDn pin and receive through RXDn pin (master mode)
	SCI3_SPMR_MSS_0 = 0x0
	// Receive through TXDn pin and transmit through RXDn pin (slave mode)
	SCI3_SPMR_MSS_1 = 0x1
	// Position of CTSPEN field.
	SCI3_SPMR_CTSPEN_Pos = 0x3
	// Bit mask of CTSPEN field.
	SCI3_SPMR_CTSPEN_Msk = 0x8
	// Bit CTSPEN.
	SCI3_SPMR_CTSPEN = 0x8
	// Alternate setting to use CTS and RTS functions as either one terminal
	SCI3_SPMR_CTSPEN_0 = 0x0
	// Dedicated setting for separately using CTS and RTS functions with 2 terminals These bits for the other SCI channels than SCIn (n = 0, 3, 4, 9) are reserved.
	SCI3_SPMR_CTSPEN_1 = 0x1
	// Position of MFF field.
	SCI3_SPMR_MFF_Pos = 0x4
	// Bit mask of MFF field.
	SCI3_SPMR_MFF_Msk = 0x10
	// Bit MFF.
	SCI3_SPMR_MFF = 0x10
	// No mode fault error
	SCI3_SPMR_MFF_0 = 0x0
	// Mode fault error
	SCI3_SPMR_MFF_1 = 0x1
	// Position of CKPOL field.
	SCI3_SPMR_CKPOL_Pos = 0x6
	// Bit mask of CKPOL field.
	SCI3_SPMR_CKPOL_Msk = 0x40
	// Bit CKPOL.
	SCI3_SPMR_CKPOL = 0x40
	// Do not invert clock polarity
	SCI3_SPMR_CKPOL_0 = 0x0
	// Invert clock polarity
	SCI3_SPMR_CKPOL_1 = 0x1
	// Position of CKPH field.
	SCI3_SPMR_CKPH_Pos = 0x7
	// Bit mask of CKPH field.
	SCI3_SPMR_CKPH_Msk = 0x80
	// Bit CKPH.
	SCI3_SPMR_CKPH = 0x80
	// Do not delay clock
	SCI3_SPMR_CKPH_0 = 0x0
	// Delay clock
	SCI3_SPMR_CKPH_1 = 0x1

	// FTDRHL: Transmit FIFO Data Register
	// Position of TDAT field.
	SCI3_FTDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI3_FTDRHL_TDAT_Msk = 0x1ff
	// Position of MPBT field.
	SCI3_FTDRHL_MPBT_Pos = 0x9
	// Bit mask of MPBT field.
	SCI3_FTDRHL_MPBT_Msk = 0x200
	// Bit MPBT.
	SCI3_FTDRHL_MPBT = 0x200
	// Data transmission cycle
	SCI3_FTDRHL_MPBT_0 = 0x0
	// ID transmission cycle
	SCI3_FTDRHL_MPBT_1 = 0x1

	// TDRHL: Transmit Data Register for Non-Manchester mode (MMR.MANEN = 0)
	// Position of TDAT field.
	SCI3_TDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI3_TDRHL_TDAT_Msk = 0x1ff

	// TDRHL_MAN: Transmit Data Register for Manchester mode (MMR.MANEN = 1)
	// Position of TDAT field.
	SCI3_TDRHL_MAN_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI3_TDRHL_MAN_TDAT_Msk = 0x1ff
	// Position of MPBT field.
	SCI3_TDRHL_MAN_MPBT_Pos = 0x9
	// Bit mask of MPBT field.
	SCI3_TDRHL_MAN_MPBT_Msk = 0x200
	// Bit MPBT.
	SCI3_TDRHL_MAN_MPBT = 0x200
	// Data transmission cycles
	SCI3_TDRHL_MAN_MPBT_0 = 0x0
	// ID transmission cycles
	SCI3_TDRHL_MAN_MPBT_1 = 0x1
	// Position of TSYNC field.
	SCI3_TDRHL_MAN_TSYNC_Pos = 0xc
	// Bit mask of TSYNC field.
	SCI3_TDRHL_MAN_TSYNC_Msk = 0x1000
	// Bit TSYNC.
	SCI3_TDRHL_MAN_TSYNC = 0x1000
	// The Start Bit is transmitted as DATA SYNC.
	SCI3_TDRHL_MAN_TSYNC_0 = 0x0
	// The Start Bit is transmitted as COMMAND SYNC.
	SCI3_TDRHL_MAN_TSYNC_1 = 0x1

	// FTDRH: Transmit FIFO Data Register
	// Position of MPBT field.
	SCI3_FTDRH_MPBT_Pos = 0x1
	// Bit mask of MPBT field.
	SCI3_FTDRH_MPBT_Msk = 0x2
	// Bit MPBT.
	SCI3_FTDRH_MPBT = 0x2
	// Data transmission cycle
	SCI3_FTDRH_MPBT_0 = 0x0
	// ID transmission cycle
	SCI3_FTDRH_MPBT_1 = 0x1

	// FTDRL: Transmit FIFO Data Register
	// Position of TDAT field.
	SCI3_FTDRL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI3_FTDRL_TDAT_Msk = 0xff

	// FRDRHL: Receive FIFO Data Register
	// Position of RDAT field.
	SCI3_FRDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI3_FRDRHL_RDAT_Msk = 0x1ff
	// Position of MPB field.
	SCI3_FRDRHL_MPB_Pos = 0x9
	// Bit mask of MPB field.
	SCI3_FRDRHL_MPB_Msk = 0x200
	// Bit MPB.
	SCI3_FRDRHL_MPB = 0x200
	// Data transmission cycle
	SCI3_FRDRHL_MPB_0 = 0x0
	// ID transmission cycle
	SCI3_FRDRHL_MPB_1 = 0x1
	// Position of DR field.
	SCI3_FRDRHL_DR_Pos = 0xa
	// Bit mask of DR field.
	SCI3_FRDRHL_DR_Msk = 0x400
	// Bit DR.
	SCI3_FRDRHL_DR = 0x400
	// Receiving is in progress, or no received data remains in the FRDRH and FRDRL registers after successfully completed reception
	SCI3_FRDRHL_DR_0 = 0x0
	// Next receive data is not received for a period after successfully completed reception
	SCI3_FRDRHL_DR_1 = 0x1
	// Position of PER field.
	SCI3_FRDRHL_PER_Pos = 0xb
	// Bit mask of PER field.
	SCI3_FRDRHL_PER_Msk = 0x800
	// Bit PER.
	SCI3_FRDRHL_PER = 0x800
	// No parity error occurred in the first data of FRDRH and FRDRL
	SCI3_FRDRHL_PER_0 = 0x0
	// Parity error occurred in the first data of FRDRH and FRDRL
	SCI3_FRDRHL_PER_1 = 0x1
	// Position of FER field.
	SCI3_FRDRHL_FER_Pos = 0xc
	// Bit mask of FER field.
	SCI3_FRDRHL_FER_Msk = 0x1000
	// Bit FER.
	SCI3_FRDRHL_FER = 0x1000
	// No framing error occurred in the first data of FRDRH and FRDRL
	SCI3_FRDRHL_FER_0 = 0x0
	// Framing error occurred in the first data of FRDRH and FRDRL
	SCI3_FRDRHL_FER_1 = 0x1
	// Position of ORER field.
	SCI3_FRDRHL_ORER_Pos = 0xd
	// Bit mask of ORER field.
	SCI3_FRDRHL_ORER_Msk = 0x2000
	// Bit ORER.
	SCI3_FRDRHL_ORER = 0x2000
	// No overrun error occurred
	SCI3_FRDRHL_ORER_0 = 0x0
	// Overrun error occurred
	SCI3_FRDRHL_ORER_1 = 0x1
	// Position of RDF field.
	SCI3_FRDRHL_RDF_Pos = 0xe
	// Bit mask of RDF field.
	SCI3_FRDRHL_RDF_Msk = 0x4000
	// Bit RDF.
	SCI3_FRDRHL_RDF = 0x4000
	// The amount of receive data written in FRDRH and FRDRL is less than the specified receive triggering number
	SCI3_FRDRHL_RDF_0 = 0x0
	// The amount of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number
	SCI3_FRDRHL_RDF_1 = 0x1

	// RDRHL: Receive Data Register for Non-Manchester mode (MMR.MANEN = 0)
	// Position of RDAT field.
	SCI3_RDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI3_RDRHL_RDAT_Msk = 0x1ff

	// RDRHL_MAN: Receive Data Register for Manchester mode (MMR.MANEN = 1)
	// Position of RDAT field.
	SCI3_RDRHL_MAN_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI3_RDRHL_MAN_RDAT_Msk = 0x1ff
	// Position of MPB field.
	SCI3_RDRHL_MAN_MPB_Pos = 0x9
	// Bit mask of MPB field.
	SCI3_RDRHL_MAN_MPB_Msk = 0x200
	// Bit MPB.
	SCI3_RDRHL_MAN_MPB = 0x200
	// Data transmission cycles
	SCI3_RDRHL_MAN_MPB_0 = 0x0
	// ID transmission cycles
	SCI3_RDRHL_MAN_MPB_1 = 0x1
	// Position of RSYNC field.
	SCI3_RDRHL_MAN_RSYNC_Pos = 0xc
	// Bit mask of RSYNC field.
	SCI3_RDRHL_MAN_RSYNC_Msk = 0x1000
	// Bit RSYNC.
	SCI3_RDRHL_MAN_RSYNC = 0x1000
	// The received the Start Bit is DATA SYNC
	SCI3_RDRHL_MAN_RSYNC_0 = 0x0
	// The received the Start Bit is COMMAND SYNC
	SCI3_RDRHL_MAN_RSYNC_1 = 0x1

	// FRDRH: Receive FIFO Data Register
	// Position of MPB field.
	SCI3_FRDRH_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI3_FRDRH_MPB_Msk = 0x2
	// Bit MPB.
	SCI3_FRDRH_MPB = 0x2
	// Data transmission cycle
	SCI3_FRDRH_MPB_0 = 0x0
	// ID transmission cycle
	SCI3_FRDRH_MPB_1 = 0x1
	// Position of DR field.
	SCI3_FRDRH_DR_Pos = 0x2
	// Bit mask of DR field.
	SCI3_FRDRH_DR_Msk = 0x4
	// Bit DR.
	SCI3_FRDRH_DR = 0x4
	// Receiving is in progress, or no received data remains in the FRDRH and FRDRL registers after successfully completed reception
	SCI3_FRDRH_DR_0 = 0x0
	// Next receive data is not received for a period after successfully completed reception
	SCI3_FRDRH_DR_1 = 0x1
	// Position of PER field.
	SCI3_FRDRH_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI3_FRDRH_PER_Msk = 0x8
	// Bit PER.
	SCI3_FRDRH_PER = 0x8
	// No parity error occurred in the first data of FRDRH and FRDRL
	SCI3_FRDRH_PER_0 = 0x0
	// Parity error occurred in the first data of FRDRH and FRDRL
	SCI3_FRDRH_PER_1 = 0x1
	// Position of FER field.
	SCI3_FRDRH_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI3_FRDRH_FER_Msk = 0x10
	// Bit FER.
	SCI3_FRDRH_FER = 0x10
	// No framing error occurred in the first data of FRDRH and FRDRL
	SCI3_FRDRH_FER_0 = 0x0
	// Framing error occurred in the first data of FRDRH and FRDRL
	SCI3_FRDRH_FER_1 = 0x1
	// Position of ORER field.
	SCI3_FRDRH_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI3_FRDRH_ORER_Msk = 0x20
	// Bit ORER.
	SCI3_FRDRH_ORER = 0x20
	// No overrun error occurred
	SCI3_FRDRH_ORER_0 = 0x0
	// Overrun error occurred
	SCI3_FRDRH_ORER_1 = 0x1
	// Position of RDF field.
	SCI3_FRDRH_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI3_FRDRH_RDF_Msk = 0x40
	// Bit RDF.
	SCI3_FRDRH_RDF = 0x40
	// The amount of receive data written in FRDRH and FRDRL is less than the specified receive triggering number
	SCI3_FRDRH_RDF_0 = 0x0
	// The amount of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number
	SCI3_FRDRH_RDF_1 = 0x1

	// FRDRL: Receive FIFO Data Register
	// Position of RDAT field.
	SCI3_FRDRL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI3_FRDRL_RDAT_Msk = 0xff

	// DCCR: Data Compare Match Control Register
	// Position of DCMF field.
	SCI3_DCCR_DCMF_Pos = 0x0
	// Bit mask of DCMF field.
	SCI3_DCCR_DCMF_Msk = 0x1
	// Bit DCMF.
	SCI3_DCCR_DCMF = 0x1
	// Not matched
	SCI3_DCCR_DCMF_0 = 0x0
	// Matched
	SCI3_DCCR_DCMF_1 = 0x1
	// Position of DPER field.
	SCI3_DCCR_DPER_Pos = 0x3
	// Bit mask of DPER field.
	SCI3_DCCR_DPER_Msk = 0x8
	// Bit DPER.
	SCI3_DCCR_DPER = 0x8
	// No parity error occurred
	SCI3_DCCR_DPER_0 = 0x0
	// Parity error occurred
	SCI3_DCCR_DPER_1 = 0x1
	// Position of DFER field.
	SCI3_DCCR_DFER_Pos = 0x4
	// Bit mask of DFER field.
	SCI3_DCCR_DFER_Msk = 0x10
	// Bit DFER.
	SCI3_DCCR_DFER = 0x10
	// No framing error occurred
	SCI3_DCCR_DFER_0 = 0x0
	// Framing error occurred
	SCI3_DCCR_DFER_1 = 0x1
	// Position of IDSEL field.
	SCI3_DCCR_IDSEL_Pos = 0x6
	// Bit mask of IDSEL field.
	SCI3_DCCR_IDSEL_Msk = 0x40
	// Bit IDSEL.
	SCI3_DCCR_IDSEL = 0x40
	// Always compare data regardless of the MPB bit value
	SCI3_DCCR_IDSEL_0 = 0x0
	// Only compare data when MPB bit = 1 (ID frame)
	SCI3_DCCR_IDSEL_1 = 0x1
	// Position of DCME field.
	SCI3_DCCR_DCME_Pos = 0x7
	// Bit mask of DCME field.
	SCI3_DCCR_DCME_Msk = 0x80
	// Bit DCME.
	SCI3_DCCR_DCME = 0x80
	// Disable address match function
	SCI3_DCCR_DCME_0 = 0x0
	// Enable address match function
	SCI3_DCCR_DCME_1 = 0x1

	// FCR: FIFO Control Register
	// Position of FM field.
	SCI3_FCR_FM_Pos = 0x0
	// Bit mask of FM field.
	SCI3_FCR_FM_Msk = 0x1
	// Bit FM.
	SCI3_FCR_FM = 0x1
	// Non-FIFO mode. Selects TDR/RDR or TDRHL/RDRHL for communication.
	SCI3_FCR_FM_0 = 0x0
	// FIFO mode. Selects FTDRHL/FRDRHL for communication.
	SCI3_FCR_FM_1 = 0x1
	// Position of RFRST field.
	SCI3_FCR_RFRST_Pos = 0x1
	// Bit mask of RFRST field.
	SCI3_FCR_RFRST_Msk = 0x2
	// Bit RFRST.
	SCI3_FCR_RFRST = 0x2
	// Do not reset FRDRHL
	SCI3_FCR_RFRST_0 = 0x0
	// Reset FRDRHL
	SCI3_FCR_RFRST_1 = 0x1
	// Position of TFRST field.
	SCI3_FCR_TFRST_Pos = 0x2
	// Bit mask of TFRST field.
	SCI3_FCR_TFRST_Msk = 0x4
	// Bit TFRST.
	SCI3_FCR_TFRST = 0x4
	// Do not reset FTDRHL
	SCI3_FCR_TFRST_0 = 0x0
	// Reset FTDRHL
	SCI3_FCR_TFRST_1 = 0x1
	// Position of DRES field.
	SCI3_FCR_DRES_Pos = 0x3
	// Bit mask of DRES field.
	SCI3_FCR_DRES_Msk = 0x8
	// Bit DRES.
	SCI3_FCR_DRES = 0x8
	// Receive data full interrupt (SCIn_RXI)
	SCI3_FCR_DRES_0 = 0x0
	// Receive error interrupt (SCIn_ERI)
	SCI3_FCR_DRES_1 = 0x1
	// Position of TTRG field.
	SCI3_FCR_TTRG_Pos = 0x4
	// Bit mask of TTRG field.
	SCI3_FCR_TTRG_Msk = 0xf0
	// Position of RTRG field.
	SCI3_FCR_RTRG_Pos = 0x8
	// Bit mask of RTRG field.
	SCI3_FCR_RTRG_Msk = 0xf00
	// Position of RSTRG field.
	SCI3_FCR_RSTRG_Pos = 0xc
	// Bit mask of RSTRG field.
	SCI3_FCR_RSTRG_Msk = 0xf000

	// FDR: FIFO Data Count Register
	// Position of R field.
	SCI3_FDR_R_Pos = 0x0
	// Bit mask of R field.
	SCI3_FDR_R_Msk = 0x1f
	// Position of T field.
	SCI3_FDR_T_Pos = 0x8
	// Bit mask of T field.
	SCI3_FDR_T_Msk = 0x1f00

	// LSR: Line Status Register
	// Position of ORER field.
	SCI3_LSR_ORER_Pos = 0x0
	// Bit mask of ORER field.
	SCI3_LSR_ORER_Msk = 0x1
	// Bit ORER.
	SCI3_LSR_ORER = 0x1
	// No overrun error occurred
	SCI3_LSR_ORER_0 = 0x0
	// Overrun error occurred
	SCI3_LSR_ORER_1 = 0x1
	// Position of FNUM field.
	SCI3_LSR_FNUM_Pos = 0x2
	// Bit mask of FNUM field.
	SCI3_LSR_FNUM_Msk = 0x7c
	// Position of PNUM field.
	SCI3_LSR_PNUM_Pos = 0x8
	// Bit mask of PNUM field.
	SCI3_LSR_PNUM_Msk = 0x1f00

	// CDR: Compare Match Data Register
	// Position of CMPD field.
	SCI3_CDR_CMPD_Pos = 0x0
	// Bit mask of CMPD field.
	SCI3_CDR_CMPD_Msk = 0x1ff

	// SPTR: Serial Port Register
	// Position of RXDMON field.
	SCI3_SPTR_RXDMON_Pos = 0x0
	// Bit mask of RXDMON field.
	SCI3_SPTR_RXDMON_Msk = 0x1
	// Bit RXDMON.
	SCI3_SPTR_RXDMON = 0x1
	// Position of SPB2DT field.
	SCI3_SPTR_SPB2DT_Pos = 0x1
	// Bit mask of SPB2DT field.
	SCI3_SPTR_SPB2DT_Msk = 0x2
	// Bit SPB2DT.
	SCI3_SPTR_SPB2DT = 0x2
	// Position of SPB2IO field.
	SCI3_SPTR_SPB2IO_Pos = 0x2
	// Bit mask of SPB2IO field.
	SCI3_SPTR_SPB2IO_Msk = 0x4
	// Bit SPB2IO.
	SCI3_SPTR_SPB2IO = 0x4
	// Do not output value of SPB2DT bit on TXDn pin
	SCI3_SPTR_SPB2IO_0 = 0x0
	// Output value of SPB2DT bit on TXDn pin
	SCI3_SPTR_SPB2IO_1 = 0x1
	// Position of RINV field.
	SCI3_SPTR_RINV_Pos = 0x4
	// Bit mask of RINV field.
	SCI3_SPTR_RINV_Msk = 0x10
	// Bit RINV.
	SCI3_SPTR_RINV = 0x10
	// Received data from RXDn is not inverted and input.
	SCI3_SPTR_RINV_0 = 0x0
	// Received data from RXDn is inverted and input.
	SCI3_SPTR_RINV_1 = 0x1
	// Position of TINV field.
	SCI3_SPTR_TINV_Pos = 0x5
	// Bit mask of TINV field.
	SCI3_SPTR_TINV_Msk = 0x20
	// Bit TINV.
	SCI3_SPTR_TINV = 0x20
	// Transmit data is not inverted and output to TXDn.
	SCI3_SPTR_TINV_0 = 0x0
	// Transmit data is inverted and output to TXDn.
	SCI3_SPTR_TINV_1 = 0x1
	// Position of ASEN field.
	SCI3_SPTR_ASEN_Pos = 0x6
	// Bit mask of ASEN field.
	SCI3_SPTR_ASEN_Msk = 0x40
	// Bit ASEN.
	SCI3_SPTR_ASEN = 0x40
	// Adjust sampling timing disable.
	SCI3_SPTR_ASEN_0 = 0x0
	// Adjust sampling timing enable.
	SCI3_SPTR_ASEN_1 = 0x1
	// Position of ATEN field.
	SCI3_SPTR_ATEN_Pos = 0x7
	// Bit mask of ATEN field.
	SCI3_SPTR_ATEN_Msk = 0x80
	// Bit ATEN.
	SCI3_SPTR_ATEN = 0x80
	// Adjust transmit timing disable.
	SCI3_SPTR_ATEN_0 = 0x0
	// Adjust transmit timing enable.
	SCI3_SPTR_ATEN_1 = 0x1

	// ACTR: Adjustment Communication Timing Register
	// Position of AST field.
	SCI3_ACTR_AST_Pos = 0x0
	// Bit mask of AST field.
	SCI3_ACTR_AST_Msk = 0x7
	// Position of AJD field.
	SCI3_ACTR_AJD_Pos = 0x3
	// Bit mask of AJD field.
	SCI3_ACTR_AJD_Msk = 0x8
	// Bit AJD.
	SCI3_ACTR_AJD = 0x8
	// The sampling timing is adjusted backward to the middle of bit.
	SCI3_ACTR_AJD_0 = 0x0
	// The sampling timing is adjusted forward to the middle of bit.
	SCI3_ACTR_AJD_1 = 0x1
	// Position of ATT field.
	SCI3_ACTR_ATT_Pos = 0x4
	// Bit mask of ATT field.
	SCI3_ACTR_ATT_Msk = 0x70
	// Position of AET field.
	SCI3_ACTR_AET_Pos = 0x7
	// Bit mask of AET field.
	SCI3_ACTR_AET_Msk = 0x80
	// Bit AET.
	SCI3_ACTR_AET = 0x80
	// Adjust the rising edge timing.
	SCI3_ACTR_AET_0 = 0x0
	// Adjust the falling edge timing.
	SCI3_ACTR_AET_1 = 0x1

	// MMR: Manchester Mode Register
	// Position of RMPOL field.
	SCI3_MMR_RMPOL_Pos = 0x0
	// Bit mask of RMPOL field.
	SCI3_MMR_RMPOL_Msk = 0x1
	// Bit RMPOL.
	SCI3_MMR_RMPOL = 0x1
	// Logic 0 is coded as a zero-to-one transition in Manchester code Logic 1 is coded as a one-to-zero transition in Manchester code
	SCI3_MMR_RMPOL_0 = 0x0
	// Logic 0 is coded as a one-to-zero transition in Manchester code Logic 1 is coded as a zero-to-one transition in Manchester code
	SCI3_MMR_RMPOL_1 = 0x1
	// Position of TMPOL field.
	SCI3_MMR_TMPOL_Pos = 0x1
	// Bit mask of TMPOL field.
	SCI3_MMR_TMPOL_Msk = 0x2
	// Bit TMPOL.
	SCI3_MMR_TMPOL = 0x2
	// Logic 0 is coded as a zero-to-one transition in Manchester code Logic 1 is coded as a one-to-zero transition in Manchester code
	SCI3_MMR_TMPOL_0 = 0x0
	// Logic 0 is coded as a one-to-zero transition in Manchester code Logic 1 is coded as a zero-to-one transition in Manchester code
	SCI3_MMR_TMPOL_1 = 0x1
	// Position of ERTEN field.
	SCI3_MMR_ERTEN_Pos = 0x2
	// Bit mask of ERTEN field.
	SCI3_MMR_ERTEN_Msk = 0x4
	// Bit ERTEN.
	SCI3_MMR_ERTEN = 0x4
	// Disables the receive retiming function
	SCI3_MMR_ERTEN_0 = 0x0
	// Enables the receive retiming function
	SCI3_MMR_ERTEN_1 = 0x1
	// Position of SYNVAL field.
	SCI3_MMR_SYNVAL_Pos = 0x4
	// Bit mask of SYNVAL field.
	SCI3_MMR_SYNVAL_Msk = 0x10
	// Bit SYNVAL.
	SCI3_MMR_SYNVAL = 0x10
	// The start bit is added as a zero-to-one transition.
	SCI3_MMR_SYNVAL_0 = 0x0
	// The start bit is added as a one-to-zero transition.
	SCI3_MMR_SYNVAL_1 = 0x1
	// Position of SYNSEL field.
	SCI3_MMR_SYNSEL_Pos = 0x5
	// Bit mask of SYNSEL field.
	SCI3_MMR_SYNSEL_Msk = 0x20
	// Bit SYNSEL.
	SCI3_MMR_SYNSEL = 0x20
	// The start bit pattern is set with the SYNVAL bit
	SCI3_MMR_SYNSEL_0 = 0x0
	// The start bit pattern is set with the TSYNC bit.
	SCI3_MMR_SYNSEL_1 = 0x1
	// Position of SBSEL field.
	SCI3_MMR_SBSEL_Pos = 0x6
	// Bit mask of SBSEL field.
	SCI3_MMR_SBSEL_Msk = 0x40
	// Bit SBSEL.
	SCI3_MMR_SBSEL = 0x40
	// The start bit area consists of one bit.
	SCI3_MMR_SBSEL_0 = 0x0
	// The start bit area consists of three bits (COMMAND SYNC or DATA SYNC)
	SCI3_MMR_SBSEL_1 = 0x1
	// Position of MANEN field.
	SCI3_MMR_MANEN_Pos = 0x7
	// Bit mask of MANEN field.
	SCI3_MMR_MANEN_Msk = 0x80
	// Bit MANEN.
	SCI3_MMR_MANEN = 0x80
	// Disables the Manchester mode
	SCI3_MMR_MANEN_0 = 0x0
	// Enables the Manchester mode
	SCI3_MMR_MANEN_1 = 0x1

	// TMPR: Transmit Manchester Preface Setting Register
	// Position of TPLEN field.
	SCI3_TMPR_TPLEN_Pos = 0x0
	// Bit mask of TPLEN field.
	SCI3_TMPR_TPLEN_Msk = 0xf
	// Disables the transmit preface generation
	SCI3_TMPR_TPLEN_0x0 = 0x0
	// Position of TPPAT field.
	SCI3_TMPR_TPPAT_Pos = 0x4
	// Bit mask of TPPAT field.
	SCI3_TMPR_TPPAT_Msk = 0x30
	// ALL ZERO
	SCI3_TMPR_TPPAT_00 = 0x0
	// ZERO ONE
	SCI3_TMPR_TPPAT_01 = 0x1
	// ONE ZERO
	SCI3_TMPR_TPPAT_10 = 0x2
	// ALL ONE
	SCI3_TMPR_TPPAT_11 = 0x3

	// RMPR: Receive Manchester Preface Setting Register
	// Position of RPLEN field.
	SCI3_RMPR_RPLEN_Pos = 0x0
	// Bit mask of RPLEN field.
	SCI3_RMPR_RPLEN_Msk = 0xf
	// Disables the receive preface generation
	SCI3_RMPR_RPLEN_0 = 0x0
	// Position of RPPAT field.
	SCI3_RMPR_RPPAT_Pos = 0x4
	// Bit mask of RPPAT field.
	SCI3_RMPR_RPPAT_Msk = 0x30
	// ALL ZERO
	SCI3_RMPR_RPPAT_00 = 0x0
	// ZERO ONE
	SCI3_RMPR_RPPAT_01 = 0x1
	// ONE ZERO
	SCI3_RMPR_RPPAT_10 = 0x2
	// ALL ONE
	SCI3_RMPR_RPPAT_11 = 0x3

	// MESR: Manchester Extended Error Status Register
	// Position of PFER field.
	SCI3_MESR_PFER_Pos = 0x0
	// Bit mask of PFER field.
	SCI3_MESR_PFER_Msk = 0x1
	// Bit PFER.
	SCI3_MESR_PFER = 0x1
	// No preface error detected
	SCI3_MESR_PFER_0 = 0x0
	// Preface error detected
	SCI3_MESR_PFER_1 = 0x1
	// Position of SYER field.
	SCI3_MESR_SYER_Pos = 0x1
	// Bit mask of SYER field.
	SCI3_MESR_SYER_Msk = 0x2
	// Bit SYER.
	SCI3_MESR_SYER = 0x2
	// No receive SYNC error detected
	SCI3_MESR_SYER_0 = 0x0
	// Receive SYNC error detected
	SCI3_MESR_SYER_1 = 0x1
	// Position of SBER field.
	SCI3_MESR_SBER_Pos = 0x2
	// Bit mask of SBER field.
	SCI3_MESR_SBER_Msk = 0x4
	// Bit SBER.
	SCI3_MESR_SBER = 0x4
	// No start bit error detected
	SCI3_MESR_SBER_0 = 0x0
	// Start bit error detected
	SCI3_MESR_SBER_1 = 0x1

	// MECR: Manchester Extended Error Control Register
	// Position of PFEREN field.
	SCI3_MECR_PFEREN_Pos = 0x0
	// Bit mask of PFEREN field.
	SCI3_MECR_PFEREN_Msk = 0x1
	// Bit PFEREN.
	SCI3_MECR_PFEREN = 0x1
	// Does not handle a preface error as an interrupt source
	SCI3_MECR_PFEREN_0 = 0x0
	// Handles a preface error as an interrupt source
	SCI3_MECR_PFEREN_1 = 0x1
	// Position of SYEREN field.
	SCI3_MECR_SYEREN_Pos = 0x1
	// Bit mask of SYEREN field.
	SCI3_MECR_SYEREN_Msk = 0x2
	// Bit SYEREN.
	SCI3_MECR_SYEREN = 0x2
	// Does not handle a receive SYNC error as an interrupt source
	SCI3_MECR_SYEREN_0 = 0x0
	// Handles a receive SYNC error as an interrupt source
	SCI3_MECR_SYEREN_1 = 0x1
	// Position of SBEREN field.
	SCI3_MECR_SBEREN_Pos = 0x2
	// Bit mask of SBEREN field.
	SCI3_MECR_SBEREN_Msk = 0x4
	// Bit SBEREN.
	SCI3_MECR_SBEREN = 0x4
	// Does not handle a start bit error as an interrupt source
	SCI3_MECR_SBEREN_0 = 0x0
	// Handles a start bit error as an interrupt source
	SCI3_MECR_SBEREN_1 = 0x1
)

// Constants for SPI0: Serial Peripheral Interface 0
const (
	// SPCR: SPI Control Register
	// Position of SPMS field.
	SPI0_SPCR_SPMS_Pos = 0x0
	// Bit mask of SPMS field.
	SPI0_SPCR_SPMS_Msk = 0x1
	// Bit SPMS.
	SPI0_SPCR_SPMS = 0x1
	// Select SPI operation (4-wire method)
	SPI0_SPCR_SPMS_0 = 0x0
	// Select clock synchronous operation (3-wire method)
	SPI0_SPCR_SPMS_1 = 0x1
	// Position of TXMD field.
	SPI0_SPCR_TXMD_Pos = 0x1
	// Bit mask of TXMD field.
	SPI0_SPCR_TXMD_Msk = 0x2
	// Bit TXMD.
	SPI0_SPCR_TXMD = 0x2
	// Select full-duplex synchronous serial communications
	SPI0_SPCR_TXMD_0 = 0x0
	// Select serial communications with transmit-only
	SPI0_SPCR_TXMD_1 = 0x1
	// Position of MODFEN field.
	SPI0_SPCR_MODFEN_Pos = 0x2
	// Bit mask of MODFEN field.
	SPI0_SPCR_MODFEN_Msk = 0x4
	// Bit MODFEN.
	SPI0_SPCR_MODFEN = 0x4
	// Disable detection of mode fault errors
	SPI0_SPCR_MODFEN_0 = 0x0
	// Enable detection of mode fault errors
	SPI0_SPCR_MODFEN_1 = 0x1
	// Position of MSTR field.
	SPI0_SPCR_MSTR_Pos = 0x3
	// Bit mask of MSTR field.
	SPI0_SPCR_MSTR_Msk = 0x8
	// Bit MSTR.
	SPI0_SPCR_MSTR = 0x8
	// Select slave mode
	SPI0_SPCR_MSTR_0 = 0x0
	// Select master mode
	SPI0_SPCR_MSTR_1 = 0x1
	// Position of SPEIE field.
	SPI0_SPCR_SPEIE_Pos = 0x4
	// Bit mask of SPEIE field.
	SPI0_SPCR_SPEIE_Msk = 0x10
	// Bit SPEIE.
	SPI0_SPCR_SPEIE = 0x10
	// Disable SPI error interrupt requests
	SPI0_SPCR_SPEIE_0 = 0x0
	// Enable SPI error interrupt requests
	SPI0_SPCR_SPEIE_1 = 0x1
	// Position of SPTIE field.
	SPI0_SPCR_SPTIE_Pos = 0x5
	// Bit mask of SPTIE field.
	SPI0_SPCR_SPTIE_Msk = 0x20
	// Bit SPTIE.
	SPI0_SPCR_SPTIE = 0x20
	// Disable transmit buffer empty interrupt requests
	SPI0_SPCR_SPTIE_0 = 0x0
	// Enable transmit buffer empty interrupt requests
	SPI0_SPCR_SPTIE_1 = 0x1
	// Position of SPE field.
	SPI0_SPCR_SPE_Pos = 0x6
	// Bit mask of SPE field.
	SPI0_SPCR_SPE_Msk = 0x40
	// Bit SPE.
	SPI0_SPCR_SPE = 0x40
	// Disable SPI function
	SPI0_SPCR_SPE_0 = 0x0
	// Enable SPI function
	SPI0_SPCR_SPE_1 = 0x1
	// Position of SPRIE field.
	SPI0_SPCR_SPRIE_Pos = 0x7
	// Bit mask of SPRIE field.
	SPI0_SPCR_SPRIE_Msk = 0x80
	// Bit SPRIE.
	SPI0_SPCR_SPRIE = 0x80
	// Disable SPI receive buffer full interrupt requests
	SPI0_SPCR_SPRIE_0 = 0x0
	// Enable SPI receive buffer full interrupt requests
	SPI0_SPCR_SPRIE_1 = 0x1

	// SSLP: SPI Slave Select Polarity Register
	// Position of SSL0P field.
	SPI0_SSLP_SSL0P_Pos = 0x0
	// Bit mask of SSL0P field.
	SPI0_SSLP_SSL0P_Msk = 0x1
	// Bit SSL0P.
	SPI0_SSLP_SSL0P = 0x1
	// Set SSLn0 signal to active-low
	SPI0_SSLP_SSL0P_0 = 0x0
	// Set SSLn0 signal to active-high
	SPI0_SSLP_SSL0P_1 = 0x1
	// Position of SSL1P field.
	SPI0_SSLP_SSL1P_Pos = 0x1
	// Bit mask of SSL1P field.
	SPI0_SSLP_SSL1P_Msk = 0x2
	// Bit SSL1P.
	SPI0_SSLP_SSL1P = 0x2
	// Set SSLn1 signal to active-low
	SPI0_SSLP_SSL1P_0 = 0x0
	// Set SSLn1 signal to active-high
	SPI0_SSLP_SSL1P_1 = 0x1
	// Position of SSL2P field.
	SPI0_SSLP_SSL2P_Pos = 0x2
	// Bit mask of SSL2P field.
	SPI0_SSLP_SSL2P_Msk = 0x4
	// Bit SSL2P.
	SPI0_SSLP_SSL2P = 0x4
	// Set SSLn2 signal to active-low
	SPI0_SSLP_SSL2P_0 = 0x0
	// Set SSLn2 signal to active-high
	SPI0_SSLP_SSL2P_1 = 0x1
	// Position of SSL3P field.
	SPI0_SSLP_SSL3P_Pos = 0x3
	// Bit mask of SSL3P field.
	SPI0_SSLP_SSL3P_Msk = 0x8
	// Bit SSL3P.
	SPI0_SSLP_SSL3P = 0x8
	// Set SSLn3 signal to active-low
	SPI0_SSLP_SSL3P_0 = 0x0
	// Set SSLn3 signal to active-high
	SPI0_SSLP_SSL3P_1 = 0x1

	// SPPCR: SPI Pin Control Register
	// Position of SPLP field.
	SPI0_SPPCR_SPLP_Pos = 0x0
	// Bit mask of SPLP field.
	SPI0_SPPCR_SPLP_Msk = 0x1
	// Bit SPLP.
	SPI0_SPPCR_SPLP = 0x1
	// Normal mode
	SPI0_SPPCR_SPLP_0 = 0x0
	// Loopback mode (receive data = inverted transmit data)
	SPI0_SPPCR_SPLP_1 = 0x1
	// Position of SPLP2 field.
	SPI0_SPPCR_SPLP2_Pos = 0x1
	// Bit mask of SPLP2 field.
	SPI0_SPPCR_SPLP2_Msk = 0x2
	// Bit SPLP2.
	SPI0_SPPCR_SPLP2 = 0x2
	// Normal mode
	SPI0_SPPCR_SPLP2_0 = 0x0
	// Loopback mode (receive data = transmit data)
	SPI0_SPPCR_SPLP2_1 = 0x1
	// Position of MOIFV field.
	SPI0_SPPCR_MOIFV_Pos = 0x4
	// Bit mask of MOIFV field.
	SPI0_SPPCR_MOIFV_Msk = 0x10
	// Bit MOIFV.
	SPI0_SPPCR_MOIFV = 0x10
	// Set level output on MOSIn pin during MOSI idling to low
	SPI0_SPPCR_MOIFV_0 = 0x0
	// Set level output on MOSIn pin during MOSI idling to high
	SPI0_SPPCR_MOIFV_1 = 0x1
	// Position of MOIFE field.
	SPI0_SPPCR_MOIFE_Pos = 0x5
	// Bit mask of MOIFE field.
	SPI0_SPPCR_MOIFE_Msk = 0x20
	// Bit MOIFE.
	SPI0_SPPCR_MOIFE = 0x20
	// Set MOSI output value to equal final data from previous transfer
	SPI0_SPPCR_MOIFE_0 = 0x0
	// Set MOSI output value to equal value set in the MOIFV bit
	SPI0_SPPCR_MOIFE_1 = 0x1

	// SPSR: SPI Status Register
	// Position of OVRF field.
	SPI0_SPSR_OVRF_Pos = 0x0
	// Bit mask of OVRF field.
	SPI0_SPSR_OVRF_Msk = 0x1
	// Bit OVRF.
	SPI0_SPSR_OVRF = 0x1
	// No overrun error occurred
	SPI0_SPSR_OVRF_0 = 0x0
	// Overrun error occurred
	SPI0_SPSR_OVRF_1 = 0x1
	// Position of IDLNF field.
	SPI0_SPSR_IDLNF_Pos = 0x1
	// Bit mask of IDLNF field.
	SPI0_SPSR_IDLNF_Msk = 0x2
	// Bit IDLNF.
	SPI0_SPSR_IDLNF = 0x2
	// SPI is in the idle state
	SPI0_SPSR_IDLNF_0 = 0x0
	// SPI is in the transfer state
	SPI0_SPSR_IDLNF_1 = 0x1
	// Position of MODF field.
	SPI0_SPSR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI0_SPSR_MODF_Msk = 0x4
	// Bit MODF.
	SPI0_SPSR_MODF = 0x4
	// No mode fault or underrun error occurred
	SPI0_SPSR_MODF_0 = 0x0
	// Mode fault error or underrun error occurred
	SPI0_SPSR_MODF_1 = 0x1
	// Position of PERF field.
	SPI0_SPSR_PERF_Pos = 0x3
	// Bit mask of PERF field.
	SPI0_SPSR_PERF_Msk = 0x8
	// Bit PERF.
	SPI0_SPSR_PERF = 0x8
	// No parity error occurred
	SPI0_SPSR_PERF_0 = 0x0
	// Parity error occurred
	SPI0_SPSR_PERF_1 = 0x1
	// Position of UDRF field.
	SPI0_SPSR_UDRF_Pos = 0x4
	// Bit mask of UDRF field.
	SPI0_SPSR_UDRF_Msk = 0x10
	// Bit UDRF.
	SPI0_SPSR_UDRF = 0x10
	// Mode fault error occurred (MODF = 1)
	SPI0_SPSR_UDRF_0 = 0x0
	// Underrun error occurred (MODF = 1)
	SPI0_SPSR_UDRF_1 = 0x1
	// Position of SPTEF field.
	SPI0_SPSR_SPTEF_Pos = 0x5
	// Bit mask of SPTEF field.
	SPI0_SPSR_SPTEF_Msk = 0x20
	// Bit SPTEF.
	SPI0_SPSR_SPTEF = 0x20
	// Data is in the transmit buffer
	SPI0_SPSR_SPTEF_0 = 0x0
	// No data is in the transmit buffer
	SPI0_SPSR_SPTEF_1 = 0x1
	// Position of CENDF field.
	SPI0_SPSR_CENDF_Pos = 0x6
	// Bit mask of CENDF field.
	SPI0_SPSR_CENDF_Msk = 0x40
	// Bit CENDF.
	SPI0_SPSR_CENDF = 0x40
	// Not communicating or communicating
	SPI0_SPSR_CENDF_0 = 0x0
	// Communication completed
	SPI0_SPSR_CENDF_1 = 0x1
	// Position of SPRF field.
	SPI0_SPSR_SPRF_Pos = 0x7
	// Bit mask of SPRF field.
	SPI0_SPSR_SPRF_Msk = 0x80
	// Bit SPRF.
	SPI0_SPSR_SPRF = 0x80
	// No valid data is in SPDR/SPDR_HA
	SPI0_SPSR_SPRF_0 = 0x0
	// Valid data is in SPDR/SPDR_HA
	SPI0_SPSR_SPRF_1 = 0x1

	// SPSCR: SPI Sequence Control Register
	// Position of SPSLN field.
	SPI0_SPSCR_SPSLN_Pos = 0x0
	// Bit mask of SPSLN field.
	SPI0_SPSCR_SPSLN_Msk = 0x7
	// Sequence Length is 1 (Referenced SPCMDn, n = 0→0→…)
	SPI0_SPSCR_SPSLN_000 = 0x0
	// Sequence Length is 2 (Referenced SPCMDn, n = 0→1→0→…)
	SPI0_SPSCR_SPSLN_001 = 0x1
	// Sequence Length is 3 (Referenced SPCMDn, n = 0→1→2→0→…)
	SPI0_SPSCR_SPSLN_010 = 0x2
	// Sequence Length is 4 (Referenced SPCMDn, n = 0→1→2→3→0→…)
	SPI0_SPSCR_SPSLN_011 = 0x3
	// Sequence Length is 5 (Referenced SPCMDn, n = 0→1→2→3→4→0→…)
	SPI0_SPSCR_SPSLN_100 = 0x4
	// Sequence Length is 6 (Referenced SPCMDn, n = 0→1→2→3→4→5→0→…)
	SPI0_SPSCR_SPSLN_101 = 0x5
	// Sequence Length is 7 (Referenced SPCMDn, n = 0→1→2→3→4→5→6→0→…)
	SPI0_SPSCR_SPSLN_110 = 0x6
	// Sequence Length is 8 (Referenced SPCMDn, n = 0→1→2→3→4→5→6→7→0→…)
	SPI0_SPSCR_SPSLN_111 = 0x7

	// SPSSR: SPI Sequence Status Register
	// Position of SPCP field.
	SPI0_SPSSR_SPCP_Pos = 0x0
	// Bit mask of SPCP field.
	SPI0_SPSSR_SPCP_Msk = 0x7
	// SPCMD0
	SPI0_SPSSR_SPCP_000 = 0x0
	// SPCMD1
	SPI0_SPSSR_SPCP_001 = 0x1
	// SPCMD2
	SPI0_SPSSR_SPCP_010 = 0x2
	// SPCMD3
	SPI0_SPSSR_SPCP_011 = 0x3
	// SPCMD4
	SPI0_SPSSR_SPCP_100 = 0x4
	// SPCMD5
	SPI0_SPSSR_SPCP_101 = 0x5
	// SPCMD6
	SPI0_SPSSR_SPCP_110 = 0x6
	// SPCMD7
	SPI0_SPSSR_SPCP_111 = 0x7
	// Position of SPECM field.
	SPI0_SPSSR_SPECM_Pos = 0x4
	// Bit mask of SPECM field.
	SPI0_SPSSR_SPECM_Msk = 0x70
	// SPCMD0
	SPI0_SPSSR_SPECM_000 = 0x0
	// SPCMD1
	SPI0_SPSSR_SPECM_001 = 0x1
	// SPCMD2
	SPI0_SPSSR_SPECM_010 = 0x2
	// SPCMD3
	SPI0_SPSSR_SPECM_011 = 0x3
	// SPCMD4
	SPI0_SPSSR_SPECM_100 = 0x4
	// SPCMD5
	SPI0_SPSSR_SPECM_101 = 0x5
	// SPCMD6
	SPI0_SPSSR_SPECM_110 = 0x6
	// SPCMD7
	SPI0_SPSSR_SPECM_111 = 0x7

	// SPDCR: SPI Data Control Register
	// Position of SPFC field.
	SPI0_SPDCR_SPFC_Pos = 0x0
	// Bit mask of SPFC field.
	SPI0_SPDCR_SPFC_Msk = 0x3
	// 1 frame
	SPI0_SPDCR_SPFC_00 = 0x0
	// 2 frames
	SPI0_SPDCR_SPFC_01 = 0x1
	// 3 frames
	SPI0_SPDCR_SPFC_10 = 0x2
	// 4 frames
	SPI0_SPDCR_SPFC_11 = 0x3
	// Position of SPRDTD field.
	SPI0_SPDCR_SPRDTD_Pos = 0x4
	// Bit mask of SPRDTD field.
	SPI0_SPDCR_SPRDTD_Msk = 0x10
	// Bit SPRDTD.
	SPI0_SPDCR_SPRDTD = 0x10
	// Read SPDR/SPDR_HA values from receive buffer
	SPI0_SPDCR_SPRDTD_0 = 0x0
	// Read SPDR/SPDR_HA values from transmit buffer, but only if the transmit buffer is empty
	SPI0_SPDCR_SPRDTD_1 = 0x1
	// Position of SPLW field.
	SPI0_SPDCR_SPLW_Pos = 0x5
	// Bit mask of SPLW field.
	SPI0_SPDCR_SPLW_Msk = 0x20
	// Bit SPLW.
	SPI0_SPDCR_SPLW = 0x20
	// Set SPDR_HA to valid for halfword access
	SPI0_SPDCR_SPLW_0 = 0x0
	// Set SPDR to valid for word access
	SPI0_SPDCR_SPLW_1 = 0x1
	// Position of SPBYT field.
	SPI0_SPDCR_SPBYT_Pos = 0x6
	// Bit mask of SPBYT field.
	SPI0_SPDCR_SPBYT_Msk = 0x40
	// Bit SPBYT.
	SPI0_SPDCR_SPBYT = 0x40
	// SPDR/SPDR_HA is accessed in halfword or word (SPLW is valid)
	SPI0_SPDCR_SPBYT_0 = 0x0
	// SPDR_BY is accessed in byte (SPLW is invalid)
	SPI0_SPDCR_SPBYT_1 = 0x1

	// SPCKD: SPI Clock Delay Register
	// Position of SCKDL field.
	SPI0_SPCKD_SCKDL_Pos = 0x0
	// Bit mask of SCKDL field.
	SPI0_SPCKD_SCKDL_Msk = 0x7
	// 1 RSPCK
	SPI0_SPCKD_SCKDL_000 = 0x0
	// 2 RSPCK
	SPI0_SPCKD_SCKDL_001 = 0x1
	// 3 RSPCK
	SPI0_SPCKD_SCKDL_010 = 0x2
	// 4 RSPCK
	SPI0_SPCKD_SCKDL_011 = 0x3
	// 5 RSPCK
	SPI0_SPCKD_SCKDL_100 = 0x4
	// 6 RSPCK
	SPI0_SPCKD_SCKDL_101 = 0x5
	// 7 RSPCK
	SPI0_SPCKD_SCKDL_110 = 0x6
	// 8 RSPCK
	SPI0_SPCKD_SCKDL_111 = 0x7

	// SSLND: SPI Slave Select Negation Delay Register
	// Position of SLNDL field.
	SPI0_SSLND_SLNDL_Pos = 0x0
	// Bit mask of SLNDL field.
	SPI0_SSLND_SLNDL_Msk = 0x7
	// 1 RSPCK
	SPI0_SSLND_SLNDL_000 = 0x0
	// 2 RSPCK
	SPI0_SSLND_SLNDL_001 = 0x1
	// 3 RSPCK
	SPI0_SSLND_SLNDL_010 = 0x2
	// 4 RSPCK
	SPI0_SSLND_SLNDL_011 = 0x3
	// 5 RSPCK
	SPI0_SSLND_SLNDL_100 = 0x4
	// 6 RSPCK
	SPI0_SSLND_SLNDL_101 = 0x5
	// 7 RSPCK
	SPI0_SSLND_SLNDL_110 = 0x6
	// 8 RSPCK
	SPI0_SSLND_SLNDL_111 = 0x7

	// SPND: SPI Next-Access Delay Register
	// Position of SPNDL field.
	SPI0_SPND_SPNDL_Pos = 0x0
	// Bit mask of SPNDL field.
	SPI0_SPND_SPNDL_Msk = 0x7
	// 1 RSPCK + 2 PCLKA
	SPI0_SPND_SPNDL_000 = 0x0
	// 2 RSPCK + 2 PCLKA
	SPI0_SPND_SPNDL_001 = 0x1
	// 3 RSPCK + 2 PCLKA
	SPI0_SPND_SPNDL_010 = 0x2
	// 4 RSPCK + 2 PCLKA
	SPI0_SPND_SPNDL_011 = 0x3
	// 5 RSPCK + 2 PCLKA
	SPI0_SPND_SPNDL_100 = 0x4
	// 6 RSPCK + 2 PCLKA
	SPI0_SPND_SPNDL_101 = 0x5
	// 7 RSPCK + 2 PCLKA
	SPI0_SPND_SPNDL_110 = 0x6
	// 8 RSPCK + 2 PCLKA
	SPI0_SPND_SPNDL_111 = 0x7

	// SPCR2: SPI Control Register 2
	// Position of SPPE field.
	SPI0_SPCR2_SPPE_Pos = 0x0
	// Bit mask of SPPE field.
	SPI0_SPCR2_SPPE_Msk = 0x1
	// Bit SPPE.
	SPI0_SPCR2_SPPE = 0x1
	// Do not add parity bit to transmit data and do not check parity bit of receive data
	SPI0_SPCR2_SPPE_0 = 0x0
	// When SPCR.TXMD = 0: Add parity bit to transmit data and check parity bit of receive data When SPCR.TXMD = 1: Add parity bit to transmit data but do not check parity bit of receive data
	SPI0_SPCR2_SPPE_1 = 0x1
	// Position of SPOE field.
	SPI0_SPCR2_SPOE_Pos = 0x1
	// Bit mask of SPOE field.
	SPI0_SPCR2_SPOE_Msk = 0x2
	// Bit SPOE.
	SPI0_SPCR2_SPOE = 0x2
	// Select even parity for transmission and reception
	SPI0_SPCR2_SPOE_0 = 0x0
	// Select odd parity for transmission and reception
	SPI0_SPCR2_SPOE_1 = 0x1
	// Position of SPIIE field.
	SPI0_SPCR2_SPIIE_Pos = 0x2
	// Bit mask of SPIIE field.
	SPI0_SPCR2_SPIIE_Msk = 0x4
	// Bit SPIIE.
	SPI0_SPCR2_SPIIE = 0x4
	// Disable idle interrupt requests
	SPI0_SPCR2_SPIIE_0 = 0x0
	// Enable idle interrupt requests
	SPI0_SPCR2_SPIIE_1 = 0x1
	// Position of PTE field.
	SPI0_SPCR2_PTE_Pos = 0x3
	// Bit mask of PTE field.
	SPI0_SPCR2_PTE_Msk = 0x8
	// Bit PTE.
	SPI0_SPCR2_PTE = 0x8
	// Disable self-diagnosis function of the parity circuit
	SPI0_SPCR2_PTE_0 = 0x0
	// Enable self-diagnosis function of the parity circuit
	SPI0_SPCR2_PTE_1 = 0x1
	// Position of SCKASE field.
	SPI0_SPCR2_SCKASE_Pos = 0x4
	// Bit mask of SCKASE field.
	SPI0_SPCR2_SCKASE_Msk = 0x10
	// Bit SCKASE.
	SPI0_SPCR2_SCKASE = 0x10
	// Disable RSPCK auto-stop function
	SPI0_SPCR2_SCKASE_0 = 0x0
	// Enable RSPCK auto-stop function
	SPI0_SPCR2_SCKASE_1 = 0x1

	// SPCMD0: SPI Command Register %s
	// Position of CPHA field.
	SPI0_SPCMD_CPHA_Pos = 0x0
	// Bit mask of CPHA field.
	SPI0_SPCMD_CPHA_Msk = 0x1
	// Bit CPHA.
	SPI0_SPCMD_CPHA = 0x1
	// Select data sampling on leading edge, data change on trailing edge
	SPI0_SPCMD_CPHA_0 = 0x0
	// Select data change on leading edge, data sampling on trailing edge
	SPI0_SPCMD_CPHA_1 = 0x1
	// Position of CPOL field.
	SPI0_SPCMD_CPOL_Pos = 0x1
	// Bit mask of CPOL field.
	SPI0_SPCMD_CPOL_Msk = 0x2
	// Bit CPOL.
	SPI0_SPCMD_CPOL = 0x2
	// Set RSPCK low during idle
	SPI0_SPCMD_CPOL_0 = 0x0
	// Set RSPCK high during idle
	SPI0_SPCMD_CPOL_1 = 0x1
	// Position of BRDV field.
	SPI0_SPCMD_BRDV_Pos = 0x2
	// Bit mask of BRDV field.
	SPI0_SPCMD_BRDV_Msk = 0xc
	// Base bit rate
	SPI0_SPCMD_BRDV_00 = 0x0
	// Base bit rate divided by 2
	SPI0_SPCMD_BRDV_01 = 0x1
	// Base bit rate divided by 4
	SPI0_SPCMD_BRDV_10 = 0x2
	// Base bit rate divided by 8
	SPI0_SPCMD_BRDV_11 = 0x3
	// Position of SSLA field.
	SPI0_SPCMD_SSLA_Pos = 0x4
	// Bit mask of SSLA field.
	SPI0_SPCMD_SSLA_Msk = 0x70
	// SSL0
	SPI0_SPCMD_SSLA_000 = 0x0
	// SSL1
	SPI0_SPCMD_SSLA_001 = 0x1
	// SSL2
	SPI0_SPCMD_SSLA_010 = 0x2
	// SSL3
	SPI0_SPCMD_SSLA_011 = 0x3
	// Position of SSLKP field.
	SPI0_SPCMD_SSLKP_Pos = 0x7
	// Bit mask of SSLKP field.
	SPI0_SPCMD_SSLKP_Msk = 0x80
	// Bit SSLKP.
	SPI0_SPCMD_SSLKP = 0x80
	// Negate all SSL signals on completion of transfer
	SPI0_SPCMD_SSLKP_0 = 0x0
	// Keep SSL signal level from the end of transfer until the beginning of the next access
	SPI0_SPCMD_SSLKP_1 = 0x1
	// Position of SPB field.
	SPI0_SPCMD_SPB_Pos = 0x8
	// Bit mask of SPB field.
	SPI0_SPCMD_SPB_Msk = 0xf00
	// 20 bits
	SPI0_SPCMD_SPB_0x0 = 0x0
	// 24 bits
	SPI0_SPCMD_SPB_0x1 = 0x1
	// 32 bits
	SPI0_SPCMD_SPB_0x2 = 0x2
	// 32 bits
	SPI0_SPCMD_SPB_0x3 = 0x3
	// 9 bits
	SPI0_SPCMD_SPB_0x8 = 0x8
	// 10 bits
	SPI0_SPCMD_SPB_0x9 = 0x9
	// 11 bits
	SPI0_SPCMD_SPB_0xA = 0xa
	// 12 bits
	SPI0_SPCMD_SPB_0xB = 0xb
	// 13 bits
	SPI0_SPCMD_SPB_0xC = 0xc
	// 14 bits
	SPI0_SPCMD_SPB_0xD = 0xd
	// 15 bits
	SPI0_SPCMD_SPB_0xE = 0xe
	// 16 bits
	SPI0_SPCMD_SPB_0xF = 0xf
	// Position of LSBF field.
	SPI0_SPCMD_LSBF_Pos = 0xc
	// Bit mask of LSBF field.
	SPI0_SPCMD_LSBF_Msk = 0x1000
	// Bit LSBF.
	SPI0_SPCMD_LSBF = 0x1000
	// MSB-first
	SPI0_SPCMD_LSBF_0 = 0x0
	// LSB-first
	SPI0_SPCMD_LSBF_1 = 0x1
	// Position of SPNDEN field.
	SPI0_SPCMD_SPNDEN_Pos = 0xd
	// Bit mask of SPNDEN field.
	SPI0_SPCMD_SPNDEN_Msk = 0x2000
	// Bit SPNDEN.
	SPI0_SPCMD_SPNDEN = 0x2000
	// Select next-access delay of 1 RSPCK + 2 PCLKA
	SPI0_SPCMD_SPNDEN_0 = 0x0
	// Select next-access delay equal to the setting in the SPI Next-Access Delay Register (SPND)
	SPI0_SPCMD_SPNDEN_1 = 0x1
	// Position of SLNDEN field.
	SPI0_SPCMD_SLNDEN_Pos = 0xe
	// Bit mask of SLNDEN field.
	SPI0_SPCMD_SLNDEN_Msk = 0x4000
	// Bit SLNDEN.
	SPI0_SPCMD_SLNDEN = 0x4000
	// Select SSL negation delay of 1 RSPCK
	SPI0_SPCMD_SLNDEN_0 = 0x0
	// Select SSL negation delay equal to the setting in the SPI Slave Select Negation Delay Register (SSLND)
	SPI0_SPCMD_SLNDEN_1 = 0x1
	// Position of SCKDEN field.
	SPI0_SPCMD_SCKDEN_Pos = 0xf
	// Bit mask of SCKDEN field.
	SPI0_SPCMD_SCKDEN_Msk = 0x8000
	// Bit SCKDEN.
	SPI0_SPCMD_SCKDEN = 0x8000
	// Select RSPCK delay of 1 RSPCK
	SPI0_SPCMD_SCKDEN_0 = 0x0
	// Select RSPCK delay equal to the setting in the SPI Clock Delay Register (SPCKD)
	SPI0_SPCMD_SCKDEN_1 = 0x1

	// SPDCR2: SPI Data Control Register 2
	// Position of BYSW field.
	SPI0_SPDCR2_BYSW_Pos = 0x0
	// Bit mask of BYSW field.
	SPI0_SPDCR2_BYSW_Msk = 0x1
	// Bit BYSW.
	SPI0_SPDCR2_BYSW = 0x1
	// Byte Swap OFF
	SPI0_SPDCR2_BYSW_0 = 0x0
	// Byte Swap ON
	SPI0_SPDCR2_BYSW_1 = 0x1
	// Position of SINV field.
	SPI0_SPDCR2_SINV_Pos = 0x1
	// Bit mask of SINV field.
	SPI0_SPDCR2_SINV_Msk = 0x2
	// Bit SINV.
	SPI0_SPDCR2_SINV = 0x2
	// Not invert serial data
	SPI0_SPDCR2_SINV_0 = 0x0
	// Invert serial data
	SPI0_SPDCR2_SINV_1 = 0x1

	// SPCR3: SPI Control Register 3
	// Position of ETXMD field.
	SPI0_SPCR3_ETXMD_Pos = 0x0
	// Bit mask of ETXMD field.
	SPI0_SPCR3_ETXMD_Msk = 0x1
	// Bit ETXMD.
	SPI0_SPCR3_ETXMD = 0x1
	// Full-duplex synchronous or transmit-only serial communications. [the SPCR.TXMD bit is enabled]
	SPI0_SPCR3_ETXMD_0 = 0x0
	// Receive-only serial communications in slave mode (SPCR.MSTR bit = 0). [the SPCR.TXMD bit is disabled] Setting is prohibited in master mode (SPCR.MSTR bit = 1).
	SPI0_SPCR3_ETXMD_1 = 0x1
	// Position of BFDS field.
	SPI0_SPCR3_BFDS_Pos = 0x1
	// Bit mask of BFDS field.
	SPI0_SPCR3_BFDS_Msk = 0x2
	// Bit BFDS.
	SPI0_SPCR3_BFDS = 0x2
	// Delay (RSPCK delay, SSL negation delay and next-access delay) between frames is inserted in burst transfer.
	SPI0_SPCR3_BFDS_0 = 0x0
	// Delay between frames is not inserted in burst transfer.
	SPI0_SPCR3_BFDS_1 = 0x1
	// Position of CENDIE field.
	SPI0_SPCR3_CENDIE_Pos = 0x4
	// Bit mask of CENDIE field.
	SPI0_SPCR3_CENDIE_Msk = 0x10
	// Bit CENDIE.
	SPI0_SPCR3_CENDIE = 0x10
	// Communication end interrupt request is disabled.
	SPI0_SPCR3_CENDIE_0 = 0x0
	// Communication end interrupt request is enabled.
	SPI0_SPCR3_CENDIE_1 = 0x1
)

// Constants for GPT321: General PWM 32-bit Timer 1
const (
	// GTWP: General PWM Timer Write-Protection Register
	// Position of WP field.
	GPT321_GTWP_WP_Pos = 0x0
	// Bit mask of WP field.
	GPT321_GTWP_WP_Msk = 0x1
	// Bit WP.
	GPT321_GTWP_WP = 0x1
	// Write to the register enabled
	GPT321_GTWP_WP_0 = 0x0
	// Write to the register disabled
	GPT321_GTWP_WP_1 = 0x1
	// Position of STRWP field.
	GPT321_GTWP_STRWP_Pos = 0x1
	// Bit mask of STRWP field.
	GPT321_GTWP_STRWP_Msk = 0x2
	// Bit STRWP.
	GPT321_GTWP_STRWP = 0x2
	// Write to the bit is enabled
	GPT321_GTWP_STRWP_0 = 0x0
	// Write to the bit is disabled
	GPT321_GTWP_STRWP_1 = 0x1
	// Position of STPWP field.
	GPT321_GTWP_STPWP_Pos = 0x2
	// Bit mask of STPWP field.
	GPT321_GTWP_STPWP_Msk = 0x4
	// Bit STPWP.
	GPT321_GTWP_STPWP = 0x4
	// Write to the bit is enabled
	GPT321_GTWP_STPWP_0 = 0x0
	// Write to the bit is disabled
	GPT321_GTWP_STPWP_1 = 0x1
	// Position of CLRWP field.
	GPT321_GTWP_CLRWP_Pos = 0x3
	// Bit mask of CLRWP field.
	GPT321_GTWP_CLRWP_Msk = 0x8
	// Bit CLRWP.
	GPT321_GTWP_CLRWP = 0x8
	// Write to the bit is enabled
	GPT321_GTWP_CLRWP_0 = 0x0
	// Write to the bit is disabled
	GPT321_GTWP_CLRWP_1 = 0x1
	// Position of CMNWP field.
	GPT321_GTWP_CMNWP_Pos = 0x4
	// Bit mask of CMNWP field.
	GPT321_GTWP_CMNWP_Msk = 0x10
	// Bit CMNWP.
	GPT321_GTWP_CMNWP = 0x10
	// Write to the register is enabled
	GPT321_GTWP_CMNWP_0 = 0x0
	// Write to the register is disabled
	GPT321_GTWP_CMNWP_1 = 0x1
	// Position of PRKEY field.
	GPT321_GTWP_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	GPT321_GTWP_PRKEY_Msk = 0xff00

	// GTSTR: General PWM Timer Software Start Register
	// Position of CSTRT0 field.
	GPT321_GTSTR_CSTRT0_Pos = 0x0
	// Bit mask of CSTRT0 field.
	GPT321_GTSTR_CSTRT0_Msk = 0x1
	// Bit CSTRT0.
	GPT321_GTSTR_CSTRT0 = 0x1
	// GTCNT counter not start
	GPT321_GTSTR_CSTRT0_0 = 0x0
	// GTCNT counter start
	GPT321_GTSTR_CSTRT0_1 = 0x1
	// Position of CSTRT1 field.
	GPT321_GTSTR_CSTRT1_Pos = 0x1
	// Bit mask of CSTRT1 field.
	GPT321_GTSTR_CSTRT1_Msk = 0x2
	// Bit CSTRT1.
	GPT321_GTSTR_CSTRT1 = 0x2
	// GTCNT counter not start
	GPT321_GTSTR_CSTRT1_0 = 0x0
	// GTCNT counter start
	GPT321_GTSTR_CSTRT1_1 = 0x1
	// Position of CSTRT2 field.
	GPT321_GTSTR_CSTRT2_Pos = 0x2
	// Bit mask of CSTRT2 field.
	GPT321_GTSTR_CSTRT2_Msk = 0x4
	// Bit CSTRT2.
	GPT321_GTSTR_CSTRT2 = 0x4
	// GTCNT counter not start
	GPT321_GTSTR_CSTRT2_0 = 0x0
	// GTCNT counter start
	GPT321_GTSTR_CSTRT2_1 = 0x1
	// Position of CSTRT3 field.
	GPT321_GTSTR_CSTRT3_Pos = 0x3
	// Bit mask of CSTRT3 field.
	GPT321_GTSTR_CSTRT3_Msk = 0x8
	// Bit CSTRT3.
	GPT321_GTSTR_CSTRT3 = 0x8
	// GTCNT counter not start
	GPT321_GTSTR_CSTRT3_0 = 0x0
	// GTCNT counter start
	GPT321_GTSTR_CSTRT3_1 = 0x1
	// Position of CSTRT4 field.
	GPT321_GTSTR_CSTRT4_Pos = 0x4
	// Bit mask of CSTRT4 field.
	GPT321_GTSTR_CSTRT4_Msk = 0x10
	// Bit CSTRT4.
	GPT321_GTSTR_CSTRT4 = 0x10
	// GTCNT counter not start
	GPT321_GTSTR_CSTRT4_0 = 0x0
	// GTCNT counter start
	GPT321_GTSTR_CSTRT4_1 = 0x1
	// Position of CSTRT5 field.
	GPT321_GTSTR_CSTRT5_Pos = 0x5
	// Bit mask of CSTRT5 field.
	GPT321_GTSTR_CSTRT5_Msk = 0x20
	// Bit CSTRT5.
	GPT321_GTSTR_CSTRT5 = 0x20
	// GTCNT counter not start
	GPT321_GTSTR_CSTRT5_0 = 0x0
	// GTCNT counter start
	GPT321_GTSTR_CSTRT5_1 = 0x1
	// Position of CSTRT6 field.
	GPT321_GTSTR_CSTRT6_Pos = 0x6
	// Bit mask of CSTRT6 field.
	GPT321_GTSTR_CSTRT6_Msk = 0x40
	// Bit CSTRT6.
	GPT321_GTSTR_CSTRT6 = 0x40
	// GTCNT counter not start
	GPT321_GTSTR_CSTRT6_0 = 0x0
	// GTCNT counter start
	GPT321_GTSTR_CSTRT6_1 = 0x1
	// Position of CSTRT7 field.
	GPT321_GTSTR_CSTRT7_Pos = 0x7
	// Bit mask of CSTRT7 field.
	GPT321_GTSTR_CSTRT7_Msk = 0x80
	// Bit CSTRT7.
	GPT321_GTSTR_CSTRT7 = 0x80
	// GTCNT counter not start
	GPT321_GTSTR_CSTRT7_0 = 0x0
	// GTCNT counter start
	GPT321_GTSTR_CSTRT7_1 = 0x1
	// Position of CSTRT8 field.
	GPT321_GTSTR_CSTRT8_Pos = 0x8
	// Bit mask of CSTRT8 field.
	GPT321_GTSTR_CSTRT8_Msk = 0x100
	// Bit CSTRT8.
	GPT321_GTSTR_CSTRT8 = 0x100
	// GTCNT counter not start
	GPT321_GTSTR_CSTRT8_0 = 0x0
	// GTCNT counter start
	GPT321_GTSTR_CSTRT8_1 = 0x1
	// Position of CSTRT9 field.
	GPT321_GTSTR_CSTRT9_Pos = 0x9
	// Bit mask of CSTRT9 field.
	GPT321_GTSTR_CSTRT9_Msk = 0x200
	// Bit CSTRT9.
	GPT321_GTSTR_CSTRT9 = 0x200
	// GTCNT counter not start
	GPT321_GTSTR_CSTRT9_0 = 0x0
	// GTCNT counter start
	GPT321_GTSTR_CSTRT9_1 = 0x1

	// GTSTP: General PWM Timer Software Stop Register
	// Position of CSTOP0 field.
	GPT321_GTSTP_CSTOP0_Pos = 0x0
	// Bit mask of CSTOP0 field.
	GPT321_GTSTP_CSTOP0_Msk = 0x1
	// Bit CSTOP0.
	GPT321_GTSTP_CSTOP0 = 0x1
	// GTCNT counter not stop
	GPT321_GTSTP_CSTOP0_0 = 0x0
	// GTCNT counter stop
	GPT321_GTSTP_CSTOP0_1 = 0x1
	// Position of CSTOP1 field.
	GPT321_GTSTP_CSTOP1_Pos = 0x1
	// Bit mask of CSTOP1 field.
	GPT321_GTSTP_CSTOP1_Msk = 0x2
	// Bit CSTOP1.
	GPT321_GTSTP_CSTOP1 = 0x2
	// GTCNT counter not stop
	GPT321_GTSTP_CSTOP1_0 = 0x0
	// GTCNT counter stop
	GPT321_GTSTP_CSTOP1_1 = 0x1
	// Position of CSTOP2 field.
	GPT321_GTSTP_CSTOP2_Pos = 0x2
	// Bit mask of CSTOP2 field.
	GPT321_GTSTP_CSTOP2_Msk = 0x4
	// Bit CSTOP2.
	GPT321_GTSTP_CSTOP2 = 0x4
	// GTCNT counter not stop
	GPT321_GTSTP_CSTOP2_0 = 0x0
	// GTCNT counter stop
	GPT321_GTSTP_CSTOP2_1 = 0x1
	// Position of CSTOP3 field.
	GPT321_GTSTP_CSTOP3_Pos = 0x3
	// Bit mask of CSTOP3 field.
	GPT321_GTSTP_CSTOP3_Msk = 0x8
	// Bit CSTOP3.
	GPT321_GTSTP_CSTOP3 = 0x8
	// GTCNT counter not stop
	GPT321_GTSTP_CSTOP3_0 = 0x0
	// GTCNT counter stop
	GPT321_GTSTP_CSTOP3_1 = 0x1
	// Position of CSTOP4 field.
	GPT321_GTSTP_CSTOP4_Pos = 0x4
	// Bit mask of CSTOP4 field.
	GPT321_GTSTP_CSTOP4_Msk = 0x10
	// Bit CSTOP4.
	GPT321_GTSTP_CSTOP4 = 0x10
	// GTCNT counter not stop
	GPT321_GTSTP_CSTOP4_0 = 0x0
	// GTCNT counter stop
	GPT321_GTSTP_CSTOP4_1 = 0x1
	// Position of CSTOP5 field.
	GPT321_GTSTP_CSTOP5_Pos = 0x5
	// Bit mask of CSTOP5 field.
	GPT321_GTSTP_CSTOP5_Msk = 0x20
	// Bit CSTOP5.
	GPT321_GTSTP_CSTOP5 = 0x20
	// GTCNT counter not stop
	GPT321_GTSTP_CSTOP5_0 = 0x0
	// GTCNT counter stop
	GPT321_GTSTP_CSTOP5_1 = 0x1
	// Position of CSTOP6 field.
	GPT321_GTSTP_CSTOP6_Pos = 0x6
	// Bit mask of CSTOP6 field.
	GPT321_GTSTP_CSTOP6_Msk = 0x40
	// Bit CSTOP6.
	GPT321_GTSTP_CSTOP6 = 0x40
	// GTCNT counter not stop
	GPT321_GTSTP_CSTOP6_0 = 0x0
	// GTCNT counter stop
	GPT321_GTSTP_CSTOP6_1 = 0x1
	// Position of CSTOP7 field.
	GPT321_GTSTP_CSTOP7_Pos = 0x7
	// Bit mask of CSTOP7 field.
	GPT321_GTSTP_CSTOP7_Msk = 0x80
	// Bit CSTOP7.
	GPT321_GTSTP_CSTOP7 = 0x80
	// GTCNT counter not stop
	GPT321_GTSTP_CSTOP7_0 = 0x0
	// GTCNT counter stop
	GPT321_GTSTP_CSTOP7_1 = 0x1
	// Position of CSTOP8 field.
	GPT321_GTSTP_CSTOP8_Pos = 0x8
	// Bit mask of CSTOP8 field.
	GPT321_GTSTP_CSTOP8_Msk = 0x100
	// Bit CSTOP8.
	GPT321_GTSTP_CSTOP8 = 0x100
	// GTCNT counter not stop
	GPT321_GTSTP_CSTOP8_0 = 0x0
	// GTCNT counter stop
	GPT321_GTSTP_CSTOP8_1 = 0x1
	// Position of CSTOP9 field.
	GPT321_GTSTP_CSTOP9_Pos = 0x9
	// Bit mask of CSTOP9 field.
	GPT321_GTSTP_CSTOP9_Msk = 0x200
	// Bit CSTOP9.
	GPT321_GTSTP_CSTOP9 = 0x200
	// GTCNT counter not stop
	GPT321_GTSTP_CSTOP9_0 = 0x0
	// GTCNT counter stop
	GPT321_GTSTP_CSTOP9_1 = 0x1

	// GTCLR: General PWM Timer Software Clear Register
	// Position of CCLR0 field.
	GPT321_GTCLR_CCLR0_Pos = 0x0
	// Bit mask of CCLR0 field.
	GPT321_GTCLR_CCLR0_Msk = 0x1
	// Bit CCLR0.
	GPT321_GTCLR_CCLR0 = 0x1
	// GTCNT counter is not cleared
	GPT321_GTCLR_CCLR0_0 = 0x0
	// GTCNT counter is cleared
	GPT321_GTCLR_CCLR0_1 = 0x1
	// Position of CCLR1 field.
	GPT321_GTCLR_CCLR1_Pos = 0x1
	// Bit mask of CCLR1 field.
	GPT321_GTCLR_CCLR1_Msk = 0x2
	// Bit CCLR1.
	GPT321_GTCLR_CCLR1 = 0x2
	// GTCNT counter is not cleared
	GPT321_GTCLR_CCLR1_0 = 0x0
	// GTCNT counter is cleared
	GPT321_GTCLR_CCLR1_1 = 0x1
	// Position of CCLR2 field.
	GPT321_GTCLR_CCLR2_Pos = 0x2
	// Bit mask of CCLR2 field.
	GPT321_GTCLR_CCLR2_Msk = 0x4
	// Bit CCLR2.
	GPT321_GTCLR_CCLR2 = 0x4
	// GTCNT counter is not cleared
	GPT321_GTCLR_CCLR2_0 = 0x0
	// GTCNT counter is cleared
	GPT321_GTCLR_CCLR2_1 = 0x1
	// Position of CCLR3 field.
	GPT321_GTCLR_CCLR3_Pos = 0x3
	// Bit mask of CCLR3 field.
	GPT321_GTCLR_CCLR3_Msk = 0x8
	// Bit CCLR3.
	GPT321_GTCLR_CCLR3 = 0x8
	// GTCNT counter is not cleared
	GPT321_GTCLR_CCLR3_0 = 0x0
	// GTCNT counter is cleared
	GPT321_GTCLR_CCLR3_1 = 0x1
	// Position of CCLR4 field.
	GPT321_GTCLR_CCLR4_Pos = 0x4
	// Bit mask of CCLR4 field.
	GPT321_GTCLR_CCLR4_Msk = 0x10
	// Bit CCLR4.
	GPT321_GTCLR_CCLR4 = 0x10
	// GTCNT counter is not cleared
	GPT321_GTCLR_CCLR4_0 = 0x0
	// GTCNT counter is cleared
	GPT321_GTCLR_CCLR4_1 = 0x1
	// Position of CCLR5 field.
	GPT321_GTCLR_CCLR5_Pos = 0x5
	// Bit mask of CCLR5 field.
	GPT321_GTCLR_CCLR5_Msk = 0x20
	// Bit CCLR5.
	GPT321_GTCLR_CCLR5 = 0x20
	// GTCNT counter is not cleared
	GPT321_GTCLR_CCLR5_0 = 0x0
	// GTCNT counter is cleared
	GPT321_GTCLR_CCLR5_1 = 0x1
	// Position of CCLR6 field.
	GPT321_GTCLR_CCLR6_Pos = 0x6
	// Bit mask of CCLR6 field.
	GPT321_GTCLR_CCLR6_Msk = 0x40
	// Bit CCLR6.
	GPT321_GTCLR_CCLR6 = 0x40
	// GTCNT counter is not cleared
	GPT321_GTCLR_CCLR6_0 = 0x0
	// GTCNT counter is cleared
	GPT321_GTCLR_CCLR6_1 = 0x1
	// Position of CCLR7 field.
	GPT321_GTCLR_CCLR7_Pos = 0x7
	// Bit mask of CCLR7 field.
	GPT321_GTCLR_CCLR7_Msk = 0x80
	// Bit CCLR7.
	GPT321_GTCLR_CCLR7 = 0x80
	// GTCNT counter is not cleared
	GPT321_GTCLR_CCLR7_0 = 0x0
	// GTCNT counter is cleared
	GPT321_GTCLR_CCLR7_1 = 0x1
	// Position of CCLR8 field.
	GPT321_GTCLR_CCLR8_Pos = 0x8
	// Bit mask of CCLR8 field.
	GPT321_GTCLR_CCLR8_Msk = 0x100
	// Bit CCLR8.
	GPT321_GTCLR_CCLR8 = 0x100
	// GTCNT counter is not cleared
	GPT321_GTCLR_CCLR8_0 = 0x0
	// GTCNT counter is cleared
	GPT321_GTCLR_CCLR8_1 = 0x1
	// Position of CCLR9 field.
	GPT321_GTCLR_CCLR9_Pos = 0x9
	// Bit mask of CCLR9 field.
	GPT321_GTCLR_CCLR9_Msk = 0x200
	// Bit CCLR9.
	GPT321_GTCLR_CCLR9 = 0x200
	// GTCNT counter is not cleared
	GPT321_GTCLR_CCLR9_0 = 0x0
	// GTCNT counter is cleared
	GPT321_GTCLR_CCLR9_1 = 0x1

	// GTSSR: General PWM Timer Start Source Select Register
	// Position of SSGTRGAR field.
	GPT321_GTSSR_SSGTRGAR_Pos = 0x0
	// Bit mask of SSGTRGAR field.
	GPT321_GTSSR_SSGTRGAR_Msk = 0x1
	// Bit SSGTRGAR.
	GPT321_GTSSR_SSGTRGAR = 0x1
	// Counter start disabled on the rising edge of GTETRGA input
	GPT321_GTSSR_SSGTRGAR_0 = 0x0
	// Counter start enabled on the rising edge of GTETRGA input
	GPT321_GTSSR_SSGTRGAR_1 = 0x1
	// Position of SSGTRGAF field.
	GPT321_GTSSR_SSGTRGAF_Pos = 0x1
	// Bit mask of SSGTRGAF field.
	GPT321_GTSSR_SSGTRGAF_Msk = 0x2
	// Bit SSGTRGAF.
	GPT321_GTSSR_SSGTRGAF = 0x2
	// Counter start disabled on the falling edge of GTETRGA input
	GPT321_GTSSR_SSGTRGAF_0 = 0x0
	// Counter start enabled on the falling edge of GTETRGA input
	GPT321_GTSSR_SSGTRGAF_1 = 0x1
	// Position of SSGTRGBR field.
	GPT321_GTSSR_SSGTRGBR_Pos = 0x2
	// Bit mask of SSGTRGBR field.
	GPT321_GTSSR_SSGTRGBR_Msk = 0x4
	// Bit SSGTRGBR.
	GPT321_GTSSR_SSGTRGBR = 0x4
	// Counter start disabled on the rising edge of GTETRGB input
	GPT321_GTSSR_SSGTRGBR_0 = 0x0
	// Counter start enabled on the rising edge of GTETRGB input
	GPT321_GTSSR_SSGTRGBR_1 = 0x1
	// Position of SSGTRGBF field.
	GPT321_GTSSR_SSGTRGBF_Pos = 0x3
	// Bit mask of SSGTRGBF field.
	GPT321_GTSSR_SSGTRGBF_Msk = 0x8
	// Bit SSGTRGBF.
	GPT321_GTSSR_SSGTRGBF = 0x8
	// Counter start disabled on the falling edge of GTETRGB input
	GPT321_GTSSR_SSGTRGBF_0 = 0x0
	// Counter start enabled on the falling edge of GTETRGB input
	GPT321_GTSSR_SSGTRGBF_1 = 0x1
	// Position of SSGTRGCR field.
	GPT321_GTSSR_SSGTRGCR_Pos = 0x4
	// Bit mask of SSGTRGCR field.
	GPT321_GTSSR_SSGTRGCR_Msk = 0x10
	// Bit SSGTRGCR.
	GPT321_GTSSR_SSGTRGCR = 0x10
	// Counter start disabled on the rising edge of GTETRGC input
	GPT321_GTSSR_SSGTRGCR_0 = 0x0
	// Counter start enabled on the rising edge of GTETRGC input
	GPT321_GTSSR_SSGTRGCR_1 = 0x1
	// Position of SSGTRGCF field.
	GPT321_GTSSR_SSGTRGCF_Pos = 0x5
	// Bit mask of SSGTRGCF field.
	GPT321_GTSSR_SSGTRGCF_Msk = 0x20
	// Bit SSGTRGCF.
	GPT321_GTSSR_SSGTRGCF = 0x20
	// Counter start disabled on the falling edge of GTETRGC input
	GPT321_GTSSR_SSGTRGCF_0 = 0x0
	// Counter start enabled on the falling edge of GTETRGC input
	GPT321_GTSSR_SSGTRGCF_1 = 0x1
	// Position of SSGTRGDR field.
	GPT321_GTSSR_SSGTRGDR_Pos = 0x6
	// Bit mask of SSGTRGDR field.
	GPT321_GTSSR_SSGTRGDR_Msk = 0x40
	// Bit SSGTRGDR.
	GPT321_GTSSR_SSGTRGDR = 0x40
	// Counter start disabled on the rising edge of GTETRGD input
	GPT321_GTSSR_SSGTRGDR_0 = 0x0
	// Counter start enabled on the rising edge of GTETRGD input
	GPT321_GTSSR_SSGTRGDR_1 = 0x1
	// Position of SSGTRGDF field.
	GPT321_GTSSR_SSGTRGDF_Pos = 0x7
	// Bit mask of SSGTRGDF field.
	GPT321_GTSSR_SSGTRGDF_Msk = 0x80
	// Bit SSGTRGDF.
	GPT321_GTSSR_SSGTRGDF = 0x80
	// Counter start disabled on the falling edge of GTETRGD input
	GPT321_GTSSR_SSGTRGDF_0 = 0x0
	// Counter start enabled on the falling edge of GTETRGD input
	GPT321_GTSSR_SSGTRGDF_1 = 0x1
	// Position of SSCARBL field.
	GPT321_GTSSR_SSCARBL_Pos = 0x8
	// Bit mask of SSCARBL field.
	GPT321_GTSSR_SSCARBL_Msk = 0x100
	// Bit SSCARBL.
	GPT321_GTSSR_SSCARBL = 0x100
	// Counter start disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTSSR_SSCARBL_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTSSR_SSCARBL_1 = 0x1
	// Position of SSCARBH field.
	GPT321_GTSSR_SSCARBH_Pos = 0x9
	// Bit mask of SSCARBH field.
	GPT321_GTSSR_SSCARBH_Msk = 0x200
	// Bit SSCARBH.
	GPT321_GTSSR_SSCARBH = 0x200
	// Counter start disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTSSR_SSCARBH_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTSSR_SSCARBH_1 = 0x1
	// Position of SSCAFBL field.
	GPT321_GTSSR_SSCAFBL_Pos = 0xa
	// Bit mask of SSCAFBL field.
	GPT321_GTSSR_SSCAFBL_Msk = 0x400
	// Bit SSCAFBL.
	GPT321_GTSSR_SSCAFBL = 0x400
	// Counter start disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTSSR_SSCAFBL_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTSSR_SSCAFBL_1 = 0x1
	// Position of SSCAFBH field.
	GPT321_GTSSR_SSCAFBH_Pos = 0xb
	// Bit mask of SSCAFBH field.
	GPT321_GTSSR_SSCAFBH_Msk = 0x800
	// Bit SSCAFBH.
	GPT321_GTSSR_SSCAFBH = 0x800
	// Counter start disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTSSR_SSCAFBH_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTSSR_SSCAFBH_1 = 0x1
	// Position of SSCBRAL field.
	GPT321_GTSSR_SSCBRAL_Pos = 0xc
	// Bit mask of SSCBRAL field.
	GPT321_GTSSR_SSCBRAL_Msk = 0x1000
	// Bit SSCBRAL.
	GPT321_GTSSR_SSCBRAL = 0x1000
	// Counter start disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTSSR_SSCBRAL_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTSSR_SSCBRAL_1 = 0x1
	// Position of SSCBRAH field.
	GPT321_GTSSR_SSCBRAH_Pos = 0xd
	// Bit mask of SSCBRAH field.
	GPT321_GTSSR_SSCBRAH_Msk = 0x2000
	// Bit SSCBRAH.
	GPT321_GTSSR_SSCBRAH = 0x2000
	// Counter start disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTSSR_SSCBRAH_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTSSR_SSCBRAH_1 = 0x1
	// Position of SSCBFAL field.
	GPT321_GTSSR_SSCBFAL_Pos = 0xe
	// Bit mask of SSCBFAL field.
	GPT321_GTSSR_SSCBFAL_Msk = 0x4000
	// Bit SSCBFAL.
	GPT321_GTSSR_SSCBFAL = 0x4000
	// Counter start disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTSSR_SSCBFAL_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTSSR_SSCBFAL_1 = 0x1
	// Position of SSCBFAH field.
	GPT321_GTSSR_SSCBFAH_Pos = 0xf
	// Bit mask of SSCBFAH field.
	GPT321_GTSSR_SSCBFAH_Msk = 0x8000
	// Bit SSCBFAH.
	GPT321_GTSSR_SSCBFAH = 0x8000
	// Counter start disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTSSR_SSCBFAH_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTSSR_SSCBFAH_1 = 0x1
	// Position of SSELCA field.
	GPT321_GTSSR_SSELCA_Pos = 0x10
	// Bit mask of SSELCA field.
	GPT321_GTSSR_SSELCA_Msk = 0x10000
	// Bit SSELCA.
	GPT321_GTSSR_SSELCA = 0x10000
	// Counter start disabled at the ELC_GPTA input
	GPT321_GTSSR_SSELCA_0 = 0x0
	// Counter start enabled at the ELC_GPTA input
	GPT321_GTSSR_SSELCA_1 = 0x1
	// Position of SSELCB field.
	GPT321_GTSSR_SSELCB_Pos = 0x11
	// Bit mask of SSELCB field.
	GPT321_GTSSR_SSELCB_Msk = 0x20000
	// Bit SSELCB.
	GPT321_GTSSR_SSELCB = 0x20000
	// Counter start disabled at the ELC_GPTB input
	GPT321_GTSSR_SSELCB_0 = 0x0
	// Counter start enabled at the ELC_GPTB input
	GPT321_GTSSR_SSELCB_1 = 0x1
	// Position of SSELCC field.
	GPT321_GTSSR_SSELCC_Pos = 0x12
	// Bit mask of SSELCC field.
	GPT321_GTSSR_SSELCC_Msk = 0x40000
	// Bit SSELCC.
	GPT321_GTSSR_SSELCC = 0x40000
	// Counter start disabled at the ELC_GPTC input
	GPT321_GTSSR_SSELCC_0 = 0x0
	// Counter start enabled at the ELC_GPTC input
	GPT321_GTSSR_SSELCC_1 = 0x1
	// Position of SSELCD field.
	GPT321_GTSSR_SSELCD_Pos = 0x13
	// Bit mask of SSELCD field.
	GPT321_GTSSR_SSELCD_Msk = 0x80000
	// Bit SSELCD.
	GPT321_GTSSR_SSELCD = 0x80000
	// Counter start disabled at the ELC_GPTD input
	GPT321_GTSSR_SSELCD_0 = 0x0
	// Counter start enabled at the ELC_GPTD input
	GPT321_GTSSR_SSELCD_1 = 0x1
	// Position of SSELCE field.
	GPT321_GTSSR_SSELCE_Pos = 0x14
	// Bit mask of SSELCE field.
	GPT321_GTSSR_SSELCE_Msk = 0x100000
	// Bit SSELCE.
	GPT321_GTSSR_SSELCE = 0x100000
	// Counter start disabled at the ELC_GPTE input
	GPT321_GTSSR_SSELCE_0 = 0x0
	// Counter start enabled at the ELC_GPTE input
	GPT321_GTSSR_SSELCE_1 = 0x1
	// Position of SSELCF field.
	GPT321_GTSSR_SSELCF_Pos = 0x15
	// Bit mask of SSELCF field.
	GPT321_GTSSR_SSELCF_Msk = 0x200000
	// Bit SSELCF.
	GPT321_GTSSR_SSELCF = 0x200000
	// Counter start disabled at the ELC_GPTF input
	GPT321_GTSSR_SSELCF_0 = 0x0
	// Counter start enabled at the ELC_GPTF input
	GPT321_GTSSR_SSELCF_1 = 0x1
	// Position of SSELCG field.
	GPT321_GTSSR_SSELCG_Pos = 0x16
	// Bit mask of SSELCG field.
	GPT321_GTSSR_SSELCG_Msk = 0x400000
	// Bit SSELCG.
	GPT321_GTSSR_SSELCG = 0x400000
	// Counter start disabled at the ELC_GPTG input
	GPT321_GTSSR_SSELCG_0 = 0x0
	// Counter start enabled at the ELC_GPTG input
	GPT321_GTSSR_SSELCG_1 = 0x1
	// Position of SSELCH field.
	GPT321_GTSSR_SSELCH_Pos = 0x17
	// Bit mask of SSELCH field.
	GPT321_GTSSR_SSELCH_Msk = 0x800000
	// Bit SSELCH.
	GPT321_GTSSR_SSELCH = 0x800000
	// Counter start disabled at the ELC_GPTH input
	GPT321_GTSSR_SSELCH_0 = 0x0
	// Counter start enabled at the ELC_GPTH input
	GPT321_GTSSR_SSELCH_1 = 0x1
	// Position of CSTRT field.
	GPT321_GTSSR_CSTRT_Pos = 0x1f
	// Bit mask of CSTRT field.
	GPT321_GTSSR_CSTRT_Msk = 0x80000000
	// Bit CSTRT.
	GPT321_GTSSR_CSTRT = 0x80000000
	// Counter start disabled by the GTSTR register
	GPT321_GTSSR_CSTRT_0 = 0x0
	// Counter start enabled by the GTSTR register
	GPT321_GTSSR_CSTRT_1 = 0x1

	// GTPSR: General PWM Timer Stop Source Select Register
	// Position of PSGTRGAR field.
	GPT321_GTPSR_PSGTRGAR_Pos = 0x0
	// Bit mask of PSGTRGAR field.
	GPT321_GTPSR_PSGTRGAR_Msk = 0x1
	// Bit PSGTRGAR.
	GPT321_GTPSR_PSGTRGAR = 0x1
	// Counter stop disabled on the rising edge of GTETRGA input
	GPT321_GTPSR_PSGTRGAR_0 = 0x0
	// Counter stop enabled on the rising edge of GTETRGA input
	GPT321_GTPSR_PSGTRGAR_1 = 0x1
	// Position of PSGTRGAF field.
	GPT321_GTPSR_PSGTRGAF_Pos = 0x1
	// Bit mask of PSGTRGAF field.
	GPT321_GTPSR_PSGTRGAF_Msk = 0x2
	// Bit PSGTRGAF.
	GPT321_GTPSR_PSGTRGAF = 0x2
	// Counter stop disabled on the falling edge of GTETRGA input
	GPT321_GTPSR_PSGTRGAF_0 = 0x0
	// Counter stop enabled on the falling edge of GTETRGA input
	GPT321_GTPSR_PSGTRGAF_1 = 0x1
	// Position of PSGTRGBR field.
	GPT321_GTPSR_PSGTRGBR_Pos = 0x2
	// Bit mask of PSGTRGBR field.
	GPT321_GTPSR_PSGTRGBR_Msk = 0x4
	// Bit PSGTRGBR.
	GPT321_GTPSR_PSGTRGBR = 0x4
	// Counter stop disabled on the rising edge of GTETRGB input
	GPT321_GTPSR_PSGTRGBR_0 = 0x0
	// Counter stop enabled on the rising edge of GTETRGB input
	GPT321_GTPSR_PSGTRGBR_1 = 0x1
	// Position of PSGTRGBF field.
	GPT321_GTPSR_PSGTRGBF_Pos = 0x3
	// Bit mask of PSGTRGBF field.
	GPT321_GTPSR_PSGTRGBF_Msk = 0x8
	// Bit PSGTRGBF.
	GPT321_GTPSR_PSGTRGBF = 0x8
	// Counter stop disabled on the falling edge of GTETRGB input
	GPT321_GTPSR_PSGTRGBF_0 = 0x0
	// Counter stop enabled on the falling edge of GTETRGB input
	GPT321_GTPSR_PSGTRGBF_1 = 0x1
	// Position of PSGTRGCR field.
	GPT321_GTPSR_PSGTRGCR_Pos = 0x4
	// Bit mask of PSGTRGCR field.
	GPT321_GTPSR_PSGTRGCR_Msk = 0x10
	// Bit PSGTRGCR.
	GPT321_GTPSR_PSGTRGCR = 0x10
	// Counter stop disabled on the rising edge of GTETRGC input
	GPT321_GTPSR_PSGTRGCR_0 = 0x0
	// Counter stop enabled on the rising edge of GTETRGC input
	GPT321_GTPSR_PSGTRGCR_1 = 0x1
	// Position of PSGTRGCF field.
	GPT321_GTPSR_PSGTRGCF_Pos = 0x5
	// Bit mask of PSGTRGCF field.
	GPT321_GTPSR_PSGTRGCF_Msk = 0x20
	// Bit PSGTRGCF.
	GPT321_GTPSR_PSGTRGCF = 0x20
	// Counter stop disabled on the falling edge of GTETRGC input
	GPT321_GTPSR_PSGTRGCF_0 = 0x0
	// Counter stop enabled on the falling edge of GTETRGC input
	GPT321_GTPSR_PSGTRGCF_1 = 0x1
	// Position of PSGTRGDR field.
	GPT321_GTPSR_PSGTRGDR_Pos = 0x6
	// Bit mask of PSGTRGDR field.
	GPT321_GTPSR_PSGTRGDR_Msk = 0x40
	// Bit PSGTRGDR.
	GPT321_GTPSR_PSGTRGDR = 0x40
	// Counter stop disabled on the rising edge of GTETRGD input
	GPT321_GTPSR_PSGTRGDR_0 = 0x0
	// Counter stop enabled on the rising edge of GTETRGD input
	GPT321_GTPSR_PSGTRGDR_1 = 0x1
	// Position of PSGTRGDF field.
	GPT321_GTPSR_PSGTRGDF_Pos = 0x7
	// Bit mask of PSGTRGDF field.
	GPT321_GTPSR_PSGTRGDF_Msk = 0x80
	// Bit PSGTRGDF.
	GPT321_GTPSR_PSGTRGDF = 0x80
	// Counter stop disabled on the falling edge of GTETRGD input
	GPT321_GTPSR_PSGTRGDF_0 = 0x0
	// Counter stop enabled on the falling edge of GTETRGD input
	GPT321_GTPSR_PSGTRGDF_1 = 0x1
	// Position of PSCARBL field.
	GPT321_GTPSR_PSCARBL_Pos = 0x8
	// Bit mask of PSCARBL field.
	GPT321_GTPSR_PSCARBL_Msk = 0x100
	// Bit PSCARBL.
	GPT321_GTPSR_PSCARBL = 0x100
	// Counter stop disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTPSR_PSCARBL_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTPSR_PSCARBL_1 = 0x1
	// Position of PSCARBH field.
	GPT321_GTPSR_PSCARBH_Pos = 0x9
	// Bit mask of PSCARBH field.
	GPT321_GTPSR_PSCARBH_Msk = 0x200
	// Bit PSCARBH.
	GPT321_GTPSR_PSCARBH = 0x200
	// Counter stop disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTPSR_PSCARBH_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTPSR_PSCARBH_1 = 0x1
	// Position of PSCAFBL field.
	GPT321_GTPSR_PSCAFBL_Pos = 0xa
	// Bit mask of PSCAFBL field.
	GPT321_GTPSR_PSCAFBL_Msk = 0x400
	// Bit PSCAFBL.
	GPT321_GTPSR_PSCAFBL = 0x400
	// Counter stop disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTPSR_PSCAFBL_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTPSR_PSCAFBL_1 = 0x1
	// Position of PSCAFBH field.
	GPT321_GTPSR_PSCAFBH_Pos = 0xb
	// Bit mask of PSCAFBH field.
	GPT321_GTPSR_PSCAFBH_Msk = 0x800
	// Bit PSCAFBH.
	GPT321_GTPSR_PSCAFBH = 0x800
	// Counter stop disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTPSR_PSCAFBH_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTPSR_PSCAFBH_1 = 0x1
	// Position of PSCBRAL field.
	GPT321_GTPSR_PSCBRAL_Pos = 0xc
	// Bit mask of PSCBRAL field.
	GPT321_GTPSR_PSCBRAL_Msk = 0x1000
	// Bit PSCBRAL.
	GPT321_GTPSR_PSCBRAL = 0x1000
	// Counter stop disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTPSR_PSCBRAL_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTPSR_PSCBRAL_1 = 0x1
	// Position of PSCBRAH field.
	GPT321_GTPSR_PSCBRAH_Pos = 0xd
	// Bit mask of PSCBRAH field.
	GPT321_GTPSR_PSCBRAH_Msk = 0x2000
	// Bit PSCBRAH.
	GPT321_GTPSR_PSCBRAH = 0x2000
	// Counter stop disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTPSR_PSCBRAH_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTPSR_PSCBRAH_1 = 0x1
	// Position of PSCBFAL field.
	GPT321_GTPSR_PSCBFAL_Pos = 0xe
	// Bit mask of PSCBFAL field.
	GPT321_GTPSR_PSCBFAL_Msk = 0x4000
	// Bit PSCBFAL.
	GPT321_GTPSR_PSCBFAL = 0x4000
	// Counter stop disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTPSR_PSCBFAL_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTPSR_PSCBFAL_1 = 0x1
	// Position of PSCBFAH field.
	GPT321_GTPSR_PSCBFAH_Pos = 0xf
	// Bit mask of PSCBFAH field.
	GPT321_GTPSR_PSCBFAH_Msk = 0x8000
	// Bit PSCBFAH.
	GPT321_GTPSR_PSCBFAH = 0x8000
	// Counter stop disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTPSR_PSCBFAH_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTPSR_PSCBFAH_1 = 0x1
	// Position of PSELCA field.
	GPT321_GTPSR_PSELCA_Pos = 0x10
	// Bit mask of PSELCA field.
	GPT321_GTPSR_PSELCA_Msk = 0x10000
	// Bit PSELCA.
	GPT321_GTPSR_PSELCA = 0x10000
	// Counter stop disabled at the ELC_GPTA input
	GPT321_GTPSR_PSELCA_0 = 0x0
	// Counter stop enabled at the ELC_GPTA input
	GPT321_GTPSR_PSELCA_1 = 0x1
	// Position of PSELCB field.
	GPT321_GTPSR_PSELCB_Pos = 0x11
	// Bit mask of PSELCB field.
	GPT321_GTPSR_PSELCB_Msk = 0x20000
	// Bit PSELCB.
	GPT321_GTPSR_PSELCB = 0x20000
	// Counter stop disabled at the ELC_GPTB input
	GPT321_GTPSR_PSELCB_0 = 0x0
	// Counter stop enabled at the ELC_GPTB input
	GPT321_GTPSR_PSELCB_1 = 0x1
	// Position of PSELCC field.
	GPT321_GTPSR_PSELCC_Pos = 0x12
	// Bit mask of PSELCC field.
	GPT321_GTPSR_PSELCC_Msk = 0x40000
	// Bit PSELCC.
	GPT321_GTPSR_PSELCC = 0x40000
	// Counter stop disabled at the ELC_GPTC input
	GPT321_GTPSR_PSELCC_0 = 0x0
	// Counter stop enabled at the ELC_GPTC input
	GPT321_GTPSR_PSELCC_1 = 0x1
	// Position of PSELCD field.
	GPT321_GTPSR_PSELCD_Pos = 0x13
	// Bit mask of PSELCD field.
	GPT321_GTPSR_PSELCD_Msk = 0x80000
	// Bit PSELCD.
	GPT321_GTPSR_PSELCD = 0x80000
	// Counter stop disabled at the ELC_GPTD input
	GPT321_GTPSR_PSELCD_0 = 0x0
	// Counter stop enabled at the ELC_GPTD input
	GPT321_GTPSR_PSELCD_1 = 0x1
	// Position of PSELCE field.
	GPT321_GTPSR_PSELCE_Pos = 0x14
	// Bit mask of PSELCE field.
	GPT321_GTPSR_PSELCE_Msk = 0x100000
	// Bit PSELCE.
	GPT321_GTPSR_PSELCE = 0x100000
	// Counter stop disabled at the ELC_GPTE input
	GPT321_GTPSR_PSELCE_0 = 0x0
	// Counter stop enabled at the ELC_GPTE input
	GPT321_GTPSR_PSELCE_1 = 0x1
	// Position of PSELCF field.
	GPT321_GTPSR_PSELCF_Pos = 0x15
	// Bit mask of PSELCF field.
	GPT321_GTPSR_PSELCF_Msk = 0x200000
	// Bit PSELCF.
	GPT321_GTPSR_PSELCF = 0x200000
	// Counter stop disabled at the ELC_GPTF input
	GPT321_GTPSR_PSELCF_0 = 0x0
	// Counter stop enabled at the ELC_GPTF input
	GPT321_GTPSR_PSELCF_1 = 0x1
	// Position of PSELCG field.
	GPT321_GTPSR_PSELCG_Pos = 0x16
	// Bit mask of PSELCG field.
	GPT321_GTPSR_PSELCG_Msk = 0x400000
	// Bit PSELCG.
	GPT321_GTPSR_PSELCG = 0x400000
	// Counter stop disabled at the ELC_GPTG input
	GPT321_GTPSR_PSELCG_0 = 0x0
	// Counter stop enabled at the ELC_GPTG input
	GPT321_GTPSR_PSELCG_1 = 0x1
	// Position of PSELCH field.
	GPT321_GTPSR_PSELCH_Pos = 0x17
	// Bit mask of PSELCH field.
	GPT321_GTPSR_PSELCH_Msk = 0x800000
	// Bit PSELCH.
	GPT321_GTPSR_PSELCH = 0x800000
	// Counter stop disabled at the ELC_GPTH input
	GPT321_GTPSR_PSELCH_0 = 0x0
	// Counter stop enabled at the ELC_GPTH input
	GPT321_GTPSR_PSELCH_1 = 0x1
	// Position of CSTOP field.
	GPT321_GTPSR_CSTOP_Pos = 0x1f
	// Bit mask of CSTOP field.
	GPT321_GTPSR_CSTOP_Msk = 0x80000000
	// Bit CSTOP.
	GPT321_GTPSR_CSTOP = 0x80000000
	// Counter stop disabled by the GTSTP register
	GPT321_GTPSR_CSTOP_0 = 0x0
	// Counter stop enabled by the GTSTP register
	GPT321_GTPSR_CSTOP_1 = 0x1

	// GTCSR: General PWM Timer Clear Source Select Register
	// Position of CSGTRGAR field.
	GPT321_GTCSR_CSGTRGAR_Pos = 0x0
	// Bit mask of CSGTRGAR field.
	GPT321_GTCSR_CSGTRGAR_Msk = 0x1
	// Bit CSGTRGAR.
	GPT321_GTCSR_CSGTRGAR = 0x1
	// Counter clear disabled on the rising edge of GTETRGA input
	GPT321_GTCSR_CSGTRGAR_0 = 0x0
	// Counter clear enabled on the rising edge of GTETRGA input
	GPT321_GTCSR_CSGTRGAR_1 = 0x1
	// Position of CSGTRGAF field.
	GPT321_GTCSR_CSGTRGAF_Pos = 0x1
	// Bit mask of CSGTRGAF field.
	GPT321_GTCSR_CSGTRGAF_Msk = 0x2
	// Bit CSGTRGAF.
	GPT321_GTCSR_CSGTRGAF = 0x2
	// Counter clear disabled on the falling edge of GTETRGA input
	GPT321_GTCSR_CSGTRGAF_0 = 0x0
	// Counter clear enabled on the falling edge of GTETRGA input
	GPT321_GTCSR_CSGTRGAF_1 = 0x1
	// Position of CSGTRGBR field.
	GPT321_GTCSR_CSGTRGBR_Pos = 0x2
	// Bit mask of CSGTRGBR field.
	GPT321_GTCSR_CSGTRGBR_Msk = 0x4
	// Bit CSGTRGBR.
	GPT321_GTCSR_CSGTRGBR = 0x4
	// Disable counter clear on the rising edge of GTETRGB input
	GPT321_GTCSR_CSGTRGBR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGB input
	GPT321_GTCSR_CSGTRGBR_1 = 0x1
	// Position of CSGTRGBF field.
	GPT321_GTCSR_CSGTRGBF_Pos = 0x3
	// Bit mask of CSGTRGBF field.
	GPT321_GTCSR_CSGTRGBF_Msk = 0x8
	// Bit CSGTRGBF.
	GPT321_GTCSR_CSGTRGBF = 0x8
	// Counter clear disabled on the falling edge of GTETRGB input
	GPT321_GTCSR_CSGTRGBF_0 = 0x0
	// Counter clear enabled on the falling edge of GTETRGB input
	GPT321_GTCSR_CSGTRGBF_1 = 0x1
	// Position of CSGTRGCR field.
	GPT321_GTCSR_CSGTRGCR_Pos = 0x4
	// Bit mask of CSGTRGCR field.
	GPT321_GTCSR_CSGTRGCR_Msk = 0x10
	// Bit CSGTRGCR.
	GPT321_GTCSR_CSGTRGCR = 0x10
	// Disable counter clear on the rising edge of GTETRGC input
	GPT321_GTCSR_CSGTRGCR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGC input
	GPT321_GTCSR_CSGTRGCR_1 = 0x1
	// Position of CSGTRGCF field.
	GPT321_GTCSR_CSGTRGCF_Pos = 0x5
	// Bit mask of CSGTRGCF field.
	GPT321_GTCSR_CSGTRGCF_Msk = 0x20
	// Bit CSGTRGCF.
	GPT321_GTCSR_CSGTRGCF = 0x20
	// Counter clear disabled on the falling edge of GTETRGC input
	GPT321_GTCSR_CSGTRGCF_0 = 0x0
	// Counter clear enabled on the falling edge of GTETRGC input
	GPT321_GTCSR_CSGTRGCF_1 = 0x1
	// Position of CSGTRGDR field.
	GPT321_GTCSR_CSGTRGDR_Pos = 0x6
	// Bit mask of CSGTRGDR field.
	GPT321_GTCSR_CSGTRGDR_Msk = 0x40
	// Bit CSGTRGDR.
	GPT321_GTCSR_CSGTRGDR = 0x40
	// Disable counter clear on the rising edge of GTETRGD input
	GPT321_GTCSR_CSGTRGDR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGD input
	GPT321_GTCSR_CSGTRGDR_1 = 0x1
	// Position of CSGTRGDF field.
	GPT321_GTCSR_CSGTRGDF_Pos = 0x7
	// Bit mask of CSGTRGDF field.
	GPT321_GTCSR_CSGTRGDF_Msk = 0x80
	// Bit CSGTRGDF.
	GPT321_GTCSR_CSGTRGDF = 0x80
	// Counter clear disabled on the falling edge of GTETRGD input
	GPT321_GTCSR_CSGTRGDF_0 = 0x0
	// Counter clear enabled on the falling edge of GTETRGD input
	GPT321_GTCSR_CSGTRGDF_1 = 0x1
	// Position of CSCARBL field.
	GPT321_GTCSR_CSCARBL_Pos = 0x8
	// Bit mask of CSCARBL field.
	GPT321_GTCSR_CSCARBL_Msk = 0x100
	// Bit CSCARBL.
	GPT321_GTCSR_CSCARBL = 0x100
	// Counter clear disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTCSR_CSCARBL_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTCSR_CSCARBL_1 = 0x1
	// Position of CSCARBH field.
	GPT321_GTCSR_CSCARBH_Pos = 0x9
	// Bit mask of CSCARBH field.
	GPT321_GTCSR_CSCARBH_Msk = 0x200
	// Bit CSCARBH.
	GPT321_GTCSR_CSCARBH = 0x200
	// Counter clear disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTCSR_CSCARBH_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTCSR_CSCARBH_1 = 0x1
	// Position of CSCAFBL field.
	GPT321_GTCSR_CSCAFBL_Pos = 0xa
	// Bit mask of CSCAFBL field.
	GPT321_GTCSR_CSCAFBL_Msk = 0x400
	// Bit CSCAFBL.
	GPT321_GTCSR_CSCAFBL = 0x400
	// Counter clear disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTCSR_CSCAFBL_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTCSR_CSCAFBL_1 = 0x1
	// Position of CSCAFBH field.
	GPT321_GTCSR_CSCAFBH_Pos = 0xb
	// Bit mask of CSCAFBH field.
	GPT321_GTCSR_CSCAFBH_Msk = 0x800
	// Bit CSCAFBH.
	GPT321_GTCSR_CSCAFBH = 0x800
	// Counter clear disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTCSR_CSCAFBH_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTCSR_CSCAFBH_1 = 0x1
	// Position of CSCBRAL field.
	GPT321_GTCSR_CSCBRAL_Pos = 0xc
	// Bit mask of CSCBRAL field.
	GPT321_GTCSR_CSCBRAL_Msk = 0x1000
	// Bit CSCBRAL.
	GPT321_GTCSR_CSCBRAL = 0x1000
	// Counter clear disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTCSR_CSCBRAL_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTCSR_CSCBRAL_1 = 0x1
	// Position of CSCBRAH field.
	GPT321_GTCSR_CSCBRAH_Pos = 0xd
	// Bit mask of CSCBRAH field.
	GPT321_GTCSR_CSCBRAH_Msk = 0x2000
	// Bit CSCBRAH.
	GPT321_GTCSR_CSCBRAH = 0x2000
	// Counter clear disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTCSR_CSCBRAH_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTCSR_CSCBRAH_1 = 0x1
	// Position of CSCBFAL field.
	GPT321_GTCSR_CSCBFAL_Pos = 0xe
	// Bit mask of CSCBFAL field.
	GPT321_GTCSR_CSCBFAL_Msk = 0x4000
	// Bit CSCBFAL.
	GPT321_GTCSR_CSCBFAL = 0x4000
	// Counter clear disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTCSR_CSCBFAL_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTCSR_CSCBFAL_1 = 0x1
	// Position of CSCBFAH field.
	GPT321_GTCSR_CSCBFAH_Pos = 0xf
	// Bit mask of CSCBFAH field.
	GPT321_GTCSR_CSCBFAH_Msk = 0x8000
	// Bit CSCBFAH.
	GPT321_GTCSR_CSCBFAH = 0x8000
	// Counter clear disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTCSR_CSCBFAH_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTCSR_CSCBFAH_1 = 0x1
	// Position of CSELCA field.
	GPT321_GTCSR_CSELCA_Pos = 0x10
	// Bit mask of CSELCA field.
	GPT321_GTCSR_CSELCA_Msk = 0x10000
	// Bit CSELCA.
	GPT321_GTCSR_CSELCA = 0x10000
	// Counter clear disabled at the ELC_GPTA input
	GPT321_GTCSR_CSELCA_0 = 0x0
	// Counter clear enabled at the ELC_GPTA input
	GPT321_GTCSR_CSELCA_1 = 0x1
	// Position of CSELCB field.
	GPT321_GTCSR_CSELCB_Pos = 0x11
	// Bit mask of CSELCB field.
	GPT321_GTCSR_CSELCB_Msk = 0x20000
	// Bit CSELCB.
	GPT321_GTCSR_CSELCB = 0x20000
	// Counter clear disabled at the ELC_GPTB input
	GPT321_GTCSR_CSELCB_0 = 0x0
	// Counter clear enabled at the ELC_GPTB input
	GPT321_GTCSR_CSELCB_1 = 0x1
	// Position of CSELCC field.
	GPT321_GTCSR_CSELCC_Pos = 0x12
	// Bit mask of CSELCC field.
	GPT321_GTCSR_CSELCC_Msk = 0x40000
	// Bit CSELCC.
	GPT321_GTCSR_CSELCC = 0x40000
	// Counter clear disabled at the ELC_GPTC input
	GPT321_GTCSR_CSELCC_0 = 0x0
	// Counter clear enabled at the ELC_GPTC input
	GPT321_GTCSR_CSELCC_1 = 0x1
	// Position of CSELCD field.
	GPT321_GTCSR_CSELCD_Pos = 0x13
	// Bit mask of CSELCD field.
	GPT321_GTCSR_CSELCD_Msk = 0x80000
	// Bit CSELCD.
	GPT321_GTCSR_CSELCD = 0x80000
	// Counter clear disabled at the ELC_GPTD input
	GPT321_GTCSR_CSELCD_0 = 0x0
	// Counter clear enabled at the ELC_GPTD input
	GPT321_GTCSR_CSELCD_1 = 0x1
	// Position of CSELCE field.
	GPT321_GTCSR_CSELCE_Pos = 0x14
	// Bit mask of CSELCE field.
	GPT321_GTCSR_CSELCE_Msk = 0x100000
	// Bit CSELCE.
	GPT321_GTCSR_CSELCE = 0x100000
	// Counter clear disabled at the ELC_GPTE input
	GPT321_GTCSR_CSELCE_0 = 0x0
	// Counter clear enabled at the ELC_GPTE input
	GPT321_GTCSR_CSELCE_1 = 0x1
	// Position of CSELCF field.
	GPT321_GTCSR_CSELCF_Pos = 0x15
	// Bit mask of CSELCF field.
	GPT321_GTCSR_CSELCF_Msk = 0x200000
	// Bit CSELCF.
	GPT321_GTCSR_CSELCF = 0x200000
	// Counter clear disabled at the ELC_GPTF input
	GPT321_GTCSR_CSELCF_0 = 0x0
	// Counter clear enabled at the ELC_GPTF input
	GPT321_GTCSR_CSELCF_1 = 0x1
	// Position of CSELCG field.
	GPT321_GTCSR_CSELCG_Pos = 0x16
	// Bit mask of CSELCG field.
	GPT321_GTCSR_CSELCG_Msk = 0x400000
	// Bit CSELCG.
	GPT321_GTCSR_CSELCG = 0x400000
	// Counter clear disabled at the ELC_GPTG input
	GPT321_GTCSR_CSELCG_0 = 0x0
	// Counter clear enabled at the ELC_GPTG input
	GPT321_GTCSR_CSELCG_1 = 0x1
	// Position of CSELCH field.
	GPT321_GTCSR_CSELCH_Pos = 0x17
	// Bit mask of CSELCH field.
	GPT321_GTCSR_CSELCH_Msk = 0x800000
	// Bit CSELCH.
	GPT321_GTCSR_CSELCH = 0x800000
	// Counter clear disabled at the ELC_GPTH input
	GPT321_GTCSR_CSELCH_0 = 0x0
	// Counter clear enabled at the ELC_GPTH input
	GPT321_GTCSR_CSELCH_1 = 0x1
	// Position of CCLR field.
	GPT321_GTCSR_CCLR_Pos = 0x1f
	// Bit mask of CCLR field.
	GPT321_GTCSR_CCLR_Msk = 0x80000000
	// Bit CCLR.
	GPT321_GTCSR_CCLR = 0x80000000
	// Counter clear disabled by the GTCLR register
	GPT321_GTCSR_CCLR_0 = 0x0
	// Counter clear enabled by the GTCLR register
	GPT321_GTCSR_CCLR_1 = 0x1

	// GTUPSR: General PWM Timer Up Count Source Select Register
	// Position of USGTRGAR field.
	GPT321_GTUPSR_USGTRGAR_Pos = 0x0
	// Bit mask of USGTRGAR field.
	GPT321_GTUPSR_USGTRGAR_Msk = 0x1
	// Bit USGTRGAR.
	GPT321_GTUPSR_USGTRGAR = 0x1
	// Counter count up disabled on the rising edge of GTETRGA input
	GPT321_GTUPSR_USGTRGAR_0 = 0x0
	// Counter count up enabled on the rising edge of GTETRGA input
	GPT321_GTUPSR_USGTRGAR_1 = 0x1
	// Position of USGTRGAF field.
	GPT321_GTUPSR_USGTRGAF_Pos = 0x1
	// Bit mask of USGTRGAF field.
	GPT321_GTUPSR_USGTRGAF_Msk = 0x2
	// Bit USGTRGAF.
	GPT321_GTUPSR_USGTRGAF = 0x2
	// Counter count up disabled on the falling edge of GTETRGA input
	GPT321_GTUPSR_USGTRGAF_0 = 0x0
	// Counter count up enabled on the falling edge of GTETRGA input
	GPT321_GTUPSR_USGTRGAF_1 = 0x1
	// Position of USGTRGBR field.
	GPT321_GTUPSR_USGTRGBR_Pos = 0x2
	// Bit mask of USGTRGBR field.
	GPT321_GTUPSR_USGTRGBR_Msk = 0x4
	// Bit USGTRGBR.
	GPT321_GTUPSR_USGTRGBR = 0x4
	// Counter count up disabled on the rising edge of GTETRGB input
	GPT321_GTUPSR_USGTRGBR_0 = 0x0
	// Counter count up enabled on the rising edge of GTETRGB input
	GPT321_GTUPSR_USGTRGBR_1 = 0x1
	// Position of USGTRGBF field.
	GPT321_GTUPSR_USGTRGBF_Pos = 0x3
	// Bit mask of USGTRGBF field.
	GPT321_GTUPSR_USGTRGBF_Msk = 0x8
	// Bit USGTRGBF.
	GPT321_GTUPSR_USGTRGBF = 0x8
	// Counter count up disabled on the falling edge of GTETRGB input
	GPT321_GTUPSR_USGTRGBF_0 = 0x0
	// Counter count up enabled on the falling edge of GTETRGB input
	GPT321_GTUPSR_USGTRGBF_1 = 0x1
	// Position of USGTRGCR field.
	GPT321_GTUPSR_USGTRGCR_Pos = 0x4
	// Bit mask of USGTRGCR field.
	GPT321_GTUPSR_USGTRGCR_Msk = 0x10
	// Bit USGTRGCR.
	GPT321_GTUPSR_USGTRGCR = 0x10
	// Counter count up disabled on the rising edge of GTETRGC input
	GPT321_GTUPSR_USGTRGCR_0 = 0x0
	// Counter count up enabled on the rising edge of GTETRGC input
	GPT321_GTUPSR_USGTRGCR_1 = 0x1
	// Position of USGTRGCF field.
	GPT321_GTUPSR_USGTRGCF_Pos = 0x5
	// Bit mask of USGTRGCF field.
	GPT321_GTUPSR_USGTRGCF_Msk = 0x20
	// Bit USGTRGCF.
	GPT321_GTUPSR_USGTRGCF = 0x20
	// Counter count up disabled on the falling edge of GTETRGC input
	GPT321_GTUPSR_USGTRGCF_0 = 0x0
	// Counter count up enabled on the falling edge of GTETRGC input
	GPT321_GTUPSR_USGTRGCF_1 = 0x1
	// Position of USGTRGDR field.
	GPT321_GTUPSR_USGTRGDR_Pos = 0x6
	// Bit mask of USGTRGDR field.
	GPT321_GTUPSR_USGTRGDR_Msk = 0x40
	// Bit USGTRGDR.
	GPT321_GTUPSR_USGTRGDR = 0x40
	// Counter count up disabled on the rising edge of GTETRGD input
	GPT321_GTUPSR_USGTRGDR_0 = 0x0
	// Counter count up enabled on the rising edge of GTETRGD input
	GPT321_GTUPSR_USGTRGDR_1 = 0x1
	// Position of USGTRGDF field.
	GPT321_GTUPSR_USGTRGDF_Pos = 0x7
	// Bit mask of USGTRGDF field.
	GPT321_GTUPSR_USGTRGDF_Msk = 0x80
	// Bit USGTRGDF.
	GPT321_GTUPSR_USGTRGDF = 0x80
	// Counter count up disabled on the falling edge of GTETRGD input
	GPT321_GTUPSR_USGTRGDF_0 = 0x0
	// Counter count up enabled on the falling edge of GTETRGD input
	GPT321_GTUPSR_USGTRGDF_1 = 0x1
	// Position of USCARBL field.
	GPT321_GTUPSR_USCARBL_Pos = 0x8
	// Bit mask of USCARBL field.
	GPT321_GTUPSR_USCARBL_Msk = 0x100
	// Bit USCARBL.
	GPT321_GTUPSR_USCARBL = 0x100
	// Counter count up disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTUPSR_USCARBL_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTUPSR_USCARBL_1 = 0x1
	// Position of USCARBH field.
	GPT321_GTUPSR_USCARBH_Pos = 0x9
	// Bit mask of USCARBH field.
	GPT321_GTUPSR_USCARBH_Msk = 0x200
	// Bit USCARBH.
	GPT321_GTUPSR_USCARBH = 0x200
	// Counter count up disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTUPSR_USCARBH_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTUPSR_USCARBH_1 = 0x1
	// Position of USCAFBL field.
	GPT321_GTUPSR_USCAFBL_Pos = 0xa
	// Bit mask of USCAFBL field.
	GPT321_GTUPSR_USCAFBL_Msk = 0x400
	// Bit USCAFBL.
	GPT321_GTUPSR_USCAFBL = 0x400
	// Counter count up disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTUPSR_USCAFBL_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTUPSR_USCAFBL_1 = 0x1
	// Position of USCAFBH field.
	GPT321_GTUPSR_USCAFBH_Pos = 0xb
	// Bit mask of USCAFBH field.
	GPT321_GTUPSR_USCAFBH_Msk = 0x800
	// Bit USCAFBH.
	GPT321_GTUPSR_USCAFBH = 0x800
	// Counter count up disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTUPSR_USCAFBH_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTUPSR_USCAFBH_1 = 0x1
	// Position of USCBRAL field.
	GPT321_GTUPSR_USCBRAL_Pos = 0xc
	// Bit mask of USCBRAL field.
	GPT321_GTUPSR_USCBRAL_Msk = 0x1000
	// Bit USCBRAL.
	GPT321_GTUPSR_USCBRAL = 0x1000
	// Counter count up disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTUPSR_USCBRAL_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTUPSR_USCBRAL_1 = 0x1
	// Position of USCBRAH field.
	GPT321_GTUPSR_USCBRAH_Pos = 0xd
	// Bit mask of USCBRAH field.
	GPT321_GTUPSR_USCBRAH_Msk = 0x2000
	// Bit USCBRAH.
	GPT321_GTUPSR_USCBRAH = 0x2000
	// Counter count up disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTUPSR_USCBRAH_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTUPSR_USCBRAH_1 = 0x1
	// Position of USCBFAL field.
	GPT321_GTUPSR_USCBFAL_Pos = 0xe
	// Bit mask of USCBFAL field.
	GPT321_GTUPSR_USCBFAL_Msk = 0x4000
	// Bit USCBFAL.
	GPT321_GTUPSR_USCBFAL = 0x4000
	// Counter count up disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTUPSR_USCBFAL_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTUPSR_USCBFAL_1 = 0x1
	// Position of USCBFAH field.
	GPT321_GTUPSR_USCBFAH_Pos = 0xf
	// Bit mask of USCBFAH field.
	GPT321_GTUPSR_USCBFAH_Msk = 0x8000
	// Bit USCBFAH.
	GPT321_GTUPSR_USCBFAH = 0x8000
	// Counter count up disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTUPSR_USCBFAH_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTUPSR_USCBFAH_1 = 0x1
	// Position of USELCA field.
	GPT321_GTUPSR_USELCA_Pos = 0x10
	// Bit mask of USELCA field.
	GPT321_GTUPSR_USELCA_Msk = 0x10000
	// Bit USELCA.
	GPT321_GTUPSR_USELCA = 0x10000
	// Counter count up disabled at the ELC_GPTA input
	GPT321_GTUPSR_USELCA_0 = 0x0
	// Counter count up enabled at the ELC_GPTA input
	GPT321_GTUPSR_USELCA_1 = 0x1
	// Position of USELCB field.
	GPT321_GTUPSR_USELCB_Pos = 0x11
	// Bit mask of USELCB field.
	GPT321_GTUPSR_USELCB_Msk = 0x20000
	// Bit USELCB.
	GPT321_GTUPSR_USELCB = 0x20000
	// Counter count up disabled at the ELC_GPTB input
	GPT321_GTUPSR_USELCB_0 = 0x0
	// Counter count up enabled at the ELC_GPTB input
	GPT321_GTUPSR_USELCB_1 = 0x1
	// Position of USELCC field.
	GPT321_GTUPSR_USELCC_Pos = 0x12
	// Bit mask of USELCC field.
	GPT321_GTUPSR_USELCC_Msk = 0x40000
	// Bit USELCC.
	GPT321_GTUPSR_USELCC = 0x40000
	// Counter count up disabled at the ELC_GPTC input
	GPT321_GTUPSR_USELCC_0 = 0x0
	// Counter count up enabled at the ELC_GPTC input
	GPT321_GTUPSR_USELCC_1 = 0x1
	// Position of USELCD field.
	GPT321_GTUPSR_USELCD_Pos = 0x13
	// Bit mask of USELCD field.
	GPT321_GTUPSR_USELCD_Msk = 0x80000
	// Bit USELCD.
	GPT321_GTUPSR_USELCD = 0x80000
	// Counter count up disabled at the ELC_GPTD input
	GPT321_GTUPSR_USELCD_0 = 0x0
	// Counter count up enabled at the ELC_GPTD input
	GPT321_GTUPSR_USELCD_1 = 0x1
	// Position of USELCE field.
	GPT321_GTUPSR_USELCE_Pos = 0x14
	// Bit mask of USELCE field.
	GPT321_GTUPSR_USELCE_Msk = 0x100000
	// Bit USELCE.
	GPT321_GTUPSR_USELCE = 0x100000
	// Counter count up disabled at the ELC_GPTE input
	GPT321_GTUPSR_USELCE_0 = 0x0
	// Counter count up enabled at the ELC_GPTE input
	GPT321_GTUPSR_USELCE_1 = 0x1
	// Position of USELCF field.
	GPT321_GTUPSR_USELCF_Pos = 0x15
	// Bit mask of USELCF field.
	GPT321_GTUPSR_USELCF_Msk = 0x200000
	// Bit USELCF.
	GPT321_GTUPSR_USELCF = 0x200000
	// Counter count up disabled at the ELC_GPTF input
	GPT321_GTUPSR_USELCF_0 = 0x0
	// Counter count up enabled at the ELC_GPTF input
	GPT321_GTUPSR_USELCF_1 = 0x1
	// Position of USELCG field.
	GPT321_GTUPSR_USELCG_Pos = 0x16
	// Bit mask of USELCG field.
	GPT321_GTUPSR_USELCG_Msk = 0x400000
	// Bit USELCG.
	GPT321_GTUPSR_USELCG = 0x400000
	// Counter count up disabled at the ELC_GPTG input
	GPT321_GTUPSR_USELCG_0 = 0x0
	// Counter count up enabled at the ELC_GPTG input
	GPT321_GTUPSR_USELCG_1 = 0x1
	// Position of USELCH field.
	GPT321_GTUPSR_USELCH_Pos = 0x17
	// Bit mask of USELCH field.
	GPT321_GTUPSR_USELCH_Msk = 0x800000
	// Bit USELCH.
	GPT321_GTUPSR_USELCH = 0x800000
	// Counter count up disabled at the ELC_GPTH input
	GPT321_GTUPSR_USELCH_0 = 0x0
	// Counter count up enabled at the ELC_GPTH input
	GPT321_GTUPSR_USELCH_1 = 0x1

	// GTDNSR: General PWM Timer Down Count Source Select Register
	// Position of DSGTRGAR field.
	GPT321_GTDNSR_DSGTRGAR_Pos = 0x0
	// Bit mask of DSGTRGAR field.
	GPT321_GTDNSR_DSGTRGAR_Msk = 0x1
	// Bit DSGTRGAR.
	GPT321_GTDNSR_DSGTRGAR = 0x1
	// Counter count down disabled on the rising edge of GTETRGA input
	GPT321_GTDNSR_DSGTRGAR_0 = 0x0
	// Counter count down enabled on the rising edge of GTETRGA input
	GPT321_GTDNSR_DSGTRGAR_1 = 0x1
	// Position of DSGTRGAF field.
	GPT321_GTDNSR_DSGTRGAF_Pos = 0x1
	// Bit mask of DSGTRGAF field.
	GPT321_GTDNSR_DSGTRGAF_Msk = 0x2
	// Bit DSGTRGAF.
	GPT321_GTDNSR_DSGTRGAF = 0x2
	// Counter count down disabled on the falling edge of GTETRGA input
	GPT321_GTDNSR_DSGTRGAF_0 = 0x0
	// Counter count down enabled on the falling edge of GTETRGA input
	GPT321_GTDNSR_DSGTRGAF_1 = 0x1
	// Position of DSGTRGBR field.
	GPT321_GTDNSR_DSGTRGBR_Pos = 0x2
	// Bit mask of DSGTRGBR field.
	GPT321_GTDNSR_DSGTRGBR_Msk = 0x4
	// Bit DSGTRGBR.
	GPT321_GTDNSR_DSGTRGBR = 0x4
	// Counter count down disabled on the rising edge of GTETRGB input
	GPT321_GTDNSR_DSGTRGBR_0 = 0x0
	// Counter count down enabled on the rising edge of GTETRGB input
	GPT321_GTDNSR_DSGTRGBR_1 = 0x1
	// Position of DSGTRGBF field.
	GPT321_GTDNSR_DSGTRGBF_Pos = 0x3
	// Bit mask of DSGTRGBF field.
	GPT321_GTDNSR_DSGTRGBF_Msk = 0x8
	// Bit DSGTRGBF.
	GPT321_GTDNSR_DSGTRGBF = 0x8
	// Counter count down disabled on the falling edge of GTETRGB input
	GPT321_GTDNSR_DSGTRGBF_0 = 0x0
	// Counter count down enabled on the falling edge of GTETRGB input
	GPT321_GTDNSR_DSGTRGBF_1 = 0x1
	// Position of DSGTRGCR field.
	GPT321_GTDNSR_DSGTRGCR_Pos = 0x4
	// Bit mask of DSGTRGCR field.
	GPT321_GTDNSR_DSGTRGCR_Msk = 0x10
	// Bit DSGTRGCR.
	GPT321_GTDNSR_DSGTRGCR = 0x10
	// Counter count down disabled on the rising edge of GTETRGC input
	GPT321_GTDNSR_DSGTRGCR_0 = 0x0
	// Counter count down enabled on the rising edge of GTETRGC input
	GPT321_GTDNSR_DSGTRGCR_1 = 0x1
	// Position of DSGTRGCF field.
	GPT321_GTDNSR_DSGTRGCF_Pos = 0x5
	// Bit mask of DSGTRGCF field.
	GPT321_GTDNSR_DSGTRGCF_Msk = 0x20
	// Bit DSGTRGCF.
	GPT321_GTDNSR_DSGTRGCF = 0x20
	// Counter count down disabled on the falling edge of GTETRGC input
	GPT321_GTDNSR_DSGTRGCF_0 = 0x0
	// Counter count down enabled on the falling edge of GTETRGC input
	GPT321_GTDNSR_DSGTRGCF_1 = 0x1
	// Position of DSGTRGDR field.
	GPT321_GTDNSR_DSGTRGDR_Pos = 0x6
	// Bit mask of DSGTRGDR field.
	GPT321_GTDNSR_DSGTRGDR_Msk = 0x40
	// Bit DSGTRGDR.
	GPT321_GTDNSR_DSGTRGDR = 0x40
	// Counter count down disabled on the rising edge of GTETRGD input
	GPT321_GTDNSR_DSGTRGDR_0 = 0x0
	// Counter count down enabled on the rising edge of GTETRGD input
	GPT321_GTDNSR_DSGTRGDR_1 = 0x1
	// Position of DSGTRGDF field.
	GPT321_GTDNSR_DSGTRGDF_Pos = 0x7
	// Bit mask of DSGTRGDF field.
	GPT321_GTDNSR_DSGTRGDF_Msk = 0x80
	// Bit DSGTRGDF.
	GPT321_GTDNSR_DSGTRGDF = 0x80
	// Counter count down disabled on the falling edge of GTETRGD input
	GPT321_GTDNSR_DSGTRGDF_0 = 0x0
	// Counter count down enabled on the falling edge of GTETRGD input
	GPT321_GTDNSR_DSGTRGDF_1 = 0x1
	// Position of DSCARBL field.
	GPT321_GTDNSR_DSCARBL_Pos = 0x8
	// Bit mask of DSCARBL field.
	GPT321_GTDNSR_DSCARBL_Msk = 0x100
	// Bit DSCARBL.
	GPT321_GTDNSR_DSCARBL = 0x100
	// Counter count down disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTDNSR_DSCARBL_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTDNSR_DSCARBL_1 = 0x1
	// Position of DSCARBH field.
	GPT321_GTDNSR_DSCARBH_Pos = 0x9
	// Bit mask of DSCARBH field.
	GPT321_GTDNSR_DSCARBH_Msk = 0x200
	// Bit DSCARBH.
	GPT321_GTDNSR_DSCARBH = 0x200
	// Counter count down disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTDNSR_DSCARBH_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTDNSR_DSCARBH_1 = 0x1
	// Position of DSCAFBL field.
	GPT321_GTDNSR_DSCAFBL_Pos = 0xa
	// Bit mask of DSCAFBL field.
	GPT321_GTDNSR_DSCAFBL_Msk = 0x400
	// Bit DSCAFBL.
	GPT321_GTDNSR_DSCAFBL = 0x400
	// Counter count down disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTDNSR_DSCAFBL_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTDNSR_DSCAFBL_1 = 0x1
	// Position of DSCAFBH field.
	GPT321_GTDNSR_DSCAFBH_Pos = 0xb
	// Bit mask of DSCAFBH field.
	GPT321_GTDNSR_DSCAFBH_Msk = 0x800
	// Bit DSCAFBH.
	GPT321_GTDNSR_DSCAFBH = 0x800
	// Counter count down disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTDNSR_DSCAFBH_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTDNSR_DSCAFBH_1 = 0x1
	// Position of DSCBRAL field.
	GPT321_GTDNSR_DSCBRAL_Pos = 0xc
	// Bit mask of DSCBRAL field.
	GPT321_GTDNSR_DSCBRAL_Msk = 0x1000
	// Bit DSCBRAL.
	GPT321_GTDNSR_DSCBRAL = 0x1000
	// Counter count down disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTDNSR_DSCBRAL_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTDNSR_DSCBRAL_1 = 0x1
	// Position of DSCBRAH field.
	GPT321_GTDNSR_DSCBRAH_Pos = 0xd
	// Bit mask of DSCBRAH field.
	GPT321_GTDNSR_DSCBRAH_Msk = 0x2000
	// Bit DSCBRAH.
	GPT321_GTDNSR_DSCBRAH = 0x2000
	// Counter count down disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTDNSR_DSCBRAH_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTDNSR_DSCBRAH_1 = 0x1
	// Position of DSCBFAL field.
	GPT321_GTDNSR_DSCBFAL_Pos = 0xe
	// Bit mask of DSCBFAL field.
	GPT321_GTDNSR_DSCBFAL_Msk = 0x4000
	// Bit DSCBFAL.
	GPT321_GTDNSR_DSCBFAL = 0x4000
	// Counter count down disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTDNSR_DSCBFAL_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTDNSR_DSCBFAL_1 = 0x1
	// Position of DSCBFAH field.
	GPT321_GTDNSR_DSCBFAH_Pos = 0xf
	// Bit mask of DSCBFAH field.
	GPT321_GTDNSR_DSCBFAH_Msk = 0x8000
	// Bit DSCBFAH.
	GPT321_GTDNSR_DSCBFAH = 0x8000
	// Counter count down disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTDNSR_DSCBFAH_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTDNSR_DSCBFAH_1 = 0x1
	// Position of DSELCA field.
	GPT321_GTDNSR_DSELCA_Pos = 0x10
	// Bit mask of DSELCA field.
	GPT321_GTDNSR_DSELCA_Msk = 0x10000
	// Bit DSELCA.
	GPT321_GTDNSR_DSELCA = 0x10000
	// Counter count down disabled at the ELC_GPTA input
	GPT321_GTDNSR_DSELCA_0 = 0x0
	// Counter count down enabled at the ELC_GPTA input
	GPT321_GTDNSR_DSELCA_1 = 0x1
	// Position of DSELCB field.
	GPT321_GTDNSR_DSELCB_Pos = 0x11
	// Bit mask of DSELCB field.
	GPT321_GTDNSR_DSELCB_Msk = 0x20000
	// Bit DSELCB.
	GPT321_GTDNSR_DSELCB = 0x20000
	// Counter count down disabled at the ELC_GPTB input
	GPT321_GTDNSR_DSELCB_0 = 0x0
	// Counter count down enabled at the ELC_GPTB input
	GPT321_GTDNSR_DSELCB_1 = 0x1
	// Position of DSELCC field.
	GPT321_GTDNSR_DSELCC_Pos = 0x12
	// Bit mask of DSELCC field.
	GPT321_GTDNSR_DSELCC_Msk = 0x40000
	// Bit DSELCC.
	GPT321_GTDNSR_DSELCC = 0x40000
	// Counter count down disabled at the ELC_GPTC input
	GPT321_GTDNSR_DSELCC_0 = 0x0
	// Counter count down enabled at the ELC_GPTC input
	GPT321_GTDNSR_DSELCC_1 = 0x1
	// Position of DSELCD field.
	GPT321_GTDNSR_DSELCD_Pos = 0x13
	// Bit mask of DSELCD field.
	GPT321_GTDNSR_DSELCD_Msk = 0x80000
	// Bit DSELCD.
	GPT321_GTDNSR_DSELCD = 0x80000
	// Counter count down disabled at the ELC_GPTD input
	GPT321_GTDNSR_DSELCD_0 = 0x0
	// Counter count down enabled at the ELC_GPTD input
	GPT321_GTDNSR_DSELCD_1 = 0x1
	// Position of DSELCE field.
	GPT321_GTDNSR_DSELCE_Pos = 0x14
	// Bit mask of DSELCE field.
	GPT321_GTDNSR_DSELCE_Msk = 0x100000
	// Bit DSELCE.
	GPT321_GTDNSR_DSELCE = 0x100000
	// Counter count down disabled at the ELC_GPTE input
	GPT321_GTDNSR_DSELCE_0 = 0x0
	// Counter count down enabled at the ELC_GPTE input
	GPT321_GTDNSR_DSELCE_1 = 0x1
	// Position of DSELCF field.
	GPT321_GTDNSR_DSELCF_Pos = 0x15
	// Bit mask of DSELCF field.
	GPT321_GTDNSR_DSELCF_Msk = 0x200000
	// Bit DSELCF.
	GPT321_GTDNSR_DSELCF = 0x200000
	// Counter count down disabled at the ELC_GPTF input
	GPT321_GTDNSR_DSELCF_0 = 0x0
	// Counter count down enabled at the ELC_GPTF input
	GPT321_GTDNSR_DSELCF_1 = 0x1
	// Position of DSELCG field.
	GPT321_GTDNSR_DSELCG_Pos = 0x16
	// Bit mask of DSELCG field.
	GPT321_GTDNSR_DSELCG_Msk = 0x400000
	// Bit DSELCG.
	GPT321_GTDNSR_DSELCG = 0x400000
	// Counter count down disabled at the ELC_GPTG input
	GPT321_GTDNSR_DSELCG_0 = 0x0
	// Counter count down enabled at the ELC_GPTG input
	GPT321_GTDNSR_DSELCG_1 = 0x1
	// Position of DSELCH field.
	GPT321_GTDNSR_DSELCH_Pos = 0x17
	// Bit mask of DSELCH field.
	GPT321_GTDNSR_DSELCH_Msk = 0x800000
	// Bit DSELCH.
	GPT321_GTDNSR_DSELCH = 0x800000
	// Counter count down disabled at the ELC_GPTF input
	GPT321_GTDNSR_DSELCH_0 = 0x0
	// Counter count down enabled at the ELC_GPTF input
	GPT321_GTDNSR_DSELCH_1 = 0x1

	// GTICASR: General PWM Timer Input Capture Source Select Register A
	// Position of ASGTRGAR field.
	GPT321_GTICASR_ASGTRGAR_Pos = 0x0
	// Bit mask of ASGTRGAR field.
	GPT321_GTICASR_ASGTRGAR_Msk = 0x1
	// Bit ASGTRGAR.
	GPT321_GTICASR_ASGTRGAR = 0x1
	// GTCCRA input capture disabled on the rising edge of GTETRGA input
	GPT321_GTICASR_ASGTRGAR_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTETRGA input
	GPT321_GTICASR_ASGTRGAR_1 = 0x1
	// Position of ASGTRGAF field.
	GPT321_GTICASR_ASGTRGAF_Pos = 0x1
	// Bit mask of ASGTRGAF field.
	GPT321_GTICASR_ASGTRGAF_Msk = 0x2
	// Bit ASGTRGAF.
	GPT321_GTICASR_ASGTRGAF = 0x2
	// GTCCRA input capture disabled on the falling edge of GTETRGA input
	GPT321_GTICASR_ASGTRGAF_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTETRGA input
	GPT321_GTICASR_ASGTRGAF_1 = 0x1
	// Position of ASGTRGBR field.
	GPT321_GTICASR_ASGTRGBR_Pos = 0x2
	// Bit mask of ASGTRGBR field.
	GPT321_GTICASR_ASGTRGBR_Msk = 0x4
	// Bit ASGTRGBR.
	GPT321_GTICASR_ASGTRGBR = 0x4
	// GTCCRA input capture disabled on the rising edge of GTETRGB input
	GPT321_GTICASR_ASGTRGBR_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTETRGB input
	GPT321_GTICASR_ASGTRGBR_1 = 0x1
	// Position of ASGTRGBF field.
	GPT321_GTICASR_ASGTRGBF_Pos = 0x3
	// Bit mask of ASGTRGBF field.
	GPT321_GTICASR_ASGTRGBF_Msk = 0x8
	// Bit ASGTRGBF.
	GPT321_GTICASR_ASGTRGBF = 0x8
	// GTCCRA input capture disabled on the falling edge of GTETRGB input
	GPT321_GTICASR_ASGTRGBF_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTETRGB input
	GPT321_GTICASR_ASGTRGBF_1 = 0x1
	// Position of ASGTRGCR field.
	GPT321_GTICASR_ASGTRGCR_Pos = 0x4
	// Bit mask of ASGTRGCR field.
	GPT321_GTICASR_ASGTRGCR_Msk = 0x10
	// Bit ASGTRGCR.
	GPT321_GTICASR_ASGTRGCR = 0x10
	// GTCCRA input capture disabled on the rising edge of GTETRGC input
	GPT321_GTICASR_ASGTRGCR_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTETRGC input
	GPT321_GTICASR_ASGTRGCR_1 = 0x1
	// Position of ASGTRGCF field.
	GPT321_GTICASR_ASGTRGCF_Pos = 0x5
	// Bit mask of ASGTRGCF field.
	GPT321_GTICASR_ASGTRGCF_Msk = 0x20
	// Bit ASGTRGCF.
	GPT321_GTICASR_ASGTRGCF = 0x20
	// GTCCRA input capture disabled on the falling edge of GTETRGC input
	GPT321_GTICASR_ASGTRGCF_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTETRGC input
	GPT321_GTICASR_ASGTRGCF_1 = 0x1
	// Position of ASGTRGDR field.
	GPT321_GTICASR_ASGTRGDR_Pos = 0x6
	// Bit mask of ASGTRGDR field.
	GPT321_GTICASR_ASGTRGDR_Msk = 0x40
	// Bit ASGTRGDR.
	GPT321_GTICASR_ASGTRGDR = 0x40
	// GTCCRA input capture disabled on the rising edge of GTETRGD input
	GPT321_GTICASR_ASGTRGDR_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTETRGD input
	GPT321_GTICASR_ASGTRGDR_1 = 0x1
	// Position of ASGTRGDF field.
	GPT321_GTICASR_ASGTRGDF_Pos = 0x7
	// Bit mask of ASGTRGDF field.
	GPT321_GTICASR_ASGTRGDF_Msk = 0x80
	// Bit ASGTRGDF.
	GPT321_GTICASR_ASGTRGDF = 0x80
	// GTCCRA input capture disabled on the falling edge of GTETRGD input
	GPT321_GTICASR_ASGTRGDF_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTETRGD input
	GPT321_GTICASR_ASGTRGDF_1 = 0x1
	// Position of ASCARBL field.
	GPT321_GTICASR_ASCARBL_Pos = 0x8
	// Bit mask of ASCARBL field.
	GPT321_GTICASR_ASCARBL_Msk = 0x100
	// Bit ASCARBL.
	GPT321_GTICASR_ASCARBL = 0x100
	// GTCCRA input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTICASR_ASCARBL_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTICASR_ASCARBL_1 = 0x1
	// Position of ASCARBH field.
	GPT321_GTICASR_ASCARBH_Pos = 0x9
	// Bit mask of ASCARBH field.
	GPT321_GTICASR_ASCARBH_Msk = 0x200
	// Bit ASCARBH.
	GPT321_GTICASR_ASCARBH = 0x200
	// GTCCRA input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTICASR_ASCARBH_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTICASR_ASCARBH_1 = 0x1
	// Position of ASCAFBL field.
	GPT321_GTICASR_ASCAFBL_Pos = 0xa
	// Bit mask of ASCAFBL field.
	GPT321_GTICASR_ASCAFBL_Msk = 0x400
	// Bit ASCAFBL.
	GPT321_GTICASR_ASCAFBL = 0x400
	// GTCCRA input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTICASR_ASCAFBL_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTICASR_ASCAFBL_1 = 0x1
	// Position of ASCAFBH field.
	GPT321_GTICASR_ASCAFBH_Pos = 0xb
	// Bit mask of ASCAFBH field.
	GPT321_GTICASR_ASCAFBH_Msk = 0x800
	// Bit ASCAFBH.
	GPT321_GTICASR_ASCAFBH = 0x800
	// GTCCRA input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTICASR_ASCAFBH_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTICASR_ASCAFBH_1 = 0x1
	// Position of ASCBRAL field.
	GPT321_GTICASR_ASCBRAL_Pos = 0xc
	// Bit mask of ASCBRAL field.
	GPT321_GTICASR_ASCBRAL_Msk = 0x1000
	// Bit ASCBRAL.
	GPT321_GTICASR_ASCBRAL = 0x1000
	// GTCCRA input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTICASR_ASCBRAL_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTICASR_ASCBRAL_1 = 0x1
	// Position of ASCBRAH field.
	GPT321_GTICASR_ASCBRAH_Pos = 0xd
	// Bit mask of ASCBRAH field.
	GPT321_GTICASR_ASCBRAH_Msk = 0x2000
	// Bit ASCBRAH.
	GPT321_GTICASR_ASCBRAH = 0x2000
	// GTCCRA input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTICASR_ASCBRAH_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTICASR_ASCBRAH_1 = 0x1
	// Position of ASCBFAL field.
	GPT321_GTICASR_ASCBFAL_Pos = 0xe
	// Bit mask of ASCBFAL field.
	GPT321_GTICASR_ASCBFAL_Msk = 0x4000
	// Bit ASCBFAL.
	GPT321_GTICASR_ASCBFAL = 0x4000
	// GTCCRA input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTICASR_ASCBFAL_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTICASR_ASCBFAL_1 = 0x1
	// Position of ASCBFAH field.
	GPT321_GTICASR_ASCBFAH_Pos = 0xf
	// Bit mask of ASCBFAH field.
	GPT321_GTICASR_ASCBFAH_Msk = 0x8000
	// Bit ASCBFAH.
	GPT321_GTICASR_ASCBFAH = 0x8000
	// GTCCRA input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTICASR_ASCBFAH_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTICASR_ASCBFAH_1 = 0x1
	// Position of ASELCA field.
	GPT321_GTICASR_ASELCA_Pos = 0x10
	// Bit mask of ASELCA field.
	GPT321_GTICASR_ASELCA_Msk = 0x10000
	// Bit ASELCA.
	GPT321_GTICASR_ASELCA = 0x10000
	// GTCCRA input capture disabled at the ELC_GPTA input
	GPT321_GTICASR_ASELCA_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTA input
	GPT321_GTICASR_ASELCA_1 = 0x1
	// Position of ASELCB field.
	GPT321_GTICASR_ASELCB_Pos = 0x11
	// Bit mask of ASELCB field.
	GPT321_GTICASR_ASELCB_Msk = 0x20000
	// Bit ASELCB.
	GPT321_GTICASR_ASELCB = 0x20000
	// GTCCRA input capture disabled at the ELC_GPTB input
	GPT321_GTICASR_ASELCB_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTB input
	GPT321_GTICASR_ASELCB_1 = 0x1
	// Position of ASELCC field.
	GPT321_GTICASR_ASELCC_Pos = 0x12
	// Bit mask of ASELCC field.
	GPT321_GTICASR_ASELCC_Msk = 0x40000
	// Bit ASELCC.
	GPT321_GTICASR_ASELCC = 0x40000
	// GTCCRA input capture disabled at the ELC_GPTC input
	GPT321_GTICASR_ASELCC_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTC input
	GPT321_GTICASR_ASELCC_1 = 0x1
	// Position of ASELCD field.
	GPT321_GTICASR_ASELCD_Pos = 0x13
	// Bit mask of ASELCD field.
	GPT321_GTICASR_ASELCD_Msk = 0x80000
	// Bit ASELCD.
	GPT321_GTICASR_ASELCD = 0x80000
	// GTCCRA input capture disabled at the ELC_GPTD input
	GPT321_GTICASR_ASELCD_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTD input
	GPT321_GTICASR_ASELCD_1 = 0x1
	// Position of ASELCE field.
	GPT321_GTICASR_ASELCE_Pos = 0x14
	// Bit mask of ASELCE field.
	GPT321_GTICASR_ASELCE_Msk = 0x100000
	// Bit ASELCE.
	GPT321_GTICASR_ASELCE = 0x100000
	// GTCCRA input capture disabled at the ELC_GPTE input
	GPT321_GTICASR_ASELCE_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTE input
	GPT321_GTICASR_ASELCE_1 = 0x1
	// Position of ASELCF field.
	GPT321_GTICASR_ASELCF_Pos = 0x15
	// Bit mask of ASELCF field.
	GPT321_GTICASR_ASELCF_Msk = 0x200000
	// Bit ASELCF.
	GPT321_GTICASR_ASELCF = 0x200000
	// GTCCRA input capture disabled at the ELC_GPTF input
	GPT321_GTICASR_ASELCF_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTF input
	GPT321_GTICASR_ASELCF_1 = 0x1
	// Position of ASELCG field.
	GPT321_GTICASR_ASELCG_Pos = 0x16
	// Bit mask of ASELCG field.
	GPT321_GTICASR_ASELCG_Msk = 0x400000
	// Bit ASELCG.
	GPT321_GTICASR_ASELCG = 0x400000
	// GTCCRA input capture disabled at the ELC_GPTG input
	GPT321_GTICASR_ASELCG_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTG input
	GPT321_GTICASR_ASELCG_1 = 0x1
	// Position of ASELCH field.
	GPT321_GTICASR_ASELCH_Pos = 0x17
	// Bit mask of ASELCH field.
	GPT321_GTICASR_ASELCH_Msk = 0x800000
	// Bit ASELCH.
	GPT321_GTICASR_ASELCH = 0x800000
	// GTCCRA input capture disabled at the ELC_GPTH input
	GPT321_GTICASR_ASELCH_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTH input
	GPT321_GTICASR_ASELCH_1 = 0x1

	// GTICBSR: General PWM Timer Input Capture Source Select Register B
	// Position of BSGTRGAR field.
	GPT321_GTICBSR_BSGTRGAR_Pos = 0x0
	// Bit mask of BSGTRGAR field.
	GPT321_GTICBSR_BSGTRGAR_Msk = 0x1
	// Bit BSGTRGAR.
	GPT321_GTICBSR_BSGTRGAR = 0x1
	// GTCCRB input capture disabled on the rising edge of GTETRGA input
	GPT321_GTICBSR_BSGTRGAR_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTETRGA input
	GPT321_GTICBSR_BSGTRGAR_1 = 0x1
	// Position of BSGTRGAF field.
	GPT321_GTICBSR_BSGTRGAF_Pos = 0x1
	// Bit mask of BSGTRGAF field.
	GPT321_GTICBSR_BSGTRGAF_Msk = 0x2
	// Bit BSGTRGAF.
	GPT321_GTICBSR_BSGTRGAF = 0x2
	// GTCCRB input capture disabled on the falling edge of GTETRGA input
	GPT321_GTICBSR_BSGTRGAF_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTETRGA input
	GPT321_GTICBSR_BSGTRGAF_1 = 0x1
	// Position of BSGTRGBR field.
	GPT321_GTICBSR_BSGTRGBR_Pos = 0x2
	// Bit mask of BSGTRGBR field.
	GPT321_GTICBSR_BSGTRGBR_Msk = 0x4
	// Bit BSGTRGBR.
	GPT321_GTICBSR_BSGTRGBR = 0x4
	// GTCCRB input capture disabled on the rising edge of GTETRGB input
	GPT321_GTICBSR_BSGTRGBR_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTETRGB input
	GPT321_GTICBSR_BSGTRGBR_1 = 0x1
	// Position of BSGTRGBF field.
	GPT321_GTICBSR_BSGTRGBF_Pos = 0x3
	// Bit mask of BSGTRGBF field.
	GPT321_GTICBSR_BSGTRGBF_Msk = 0x8
	// Bit BSGTRGBF.
	GPT321_GTICBSR_BSGTRGBF = 0x8
	// GTCCRB input capture disabled on the falling edge of GTETRGB input
	GPT321_GTICBSR_BSGTRGBF_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTETRGB input
	GPT321_GTICBSR_BSGTRGBF_1 = 0x1
	// Position of BSGTRGCR field.
	GPT321_GTICBSR_BSGTRGCR_Pos = 0x4
	// Bit mask of BSGTRGCR field.
	GPT321_GTICBSR_BSGTRGCR_Msk = 0x10
	// Bit BSGTRGCR.
	GPT321_GTICBSR_BSGTRGCR = 0x10
	// GTCCRB input capture disabled on the rising edge of GTETRGC input
	GPT321_GTICBSR_BSGTRGCR_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTETRGC input
	GPT321_GTICBSR_BSGTRGCR_1 = 0x1
	// Position of BSGTRGCF field.
	GPT321_GTICBSR_BSGTRGCF_Pos = 0x5
	// Bit mask of BSGTRGCF field.
	GPT321_GTICBSR_BSGTRGCF_Msk = 0x20
	// Bit BSGTRGCF.
	GPT321_GTICBSR_BSGTRGCF = 0x20
	// GTCCRB input capture disabled on the falling edge of GTETRGC input
	GPT321_GTICBSR_BSGTRGCF_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTETRGC input
	GPT321_GTICBSR_BSGTRGCF_1 = 0x1
	// Position of BSGTRGDR field.
	GPT321_GTICBSR_BSGTRGDR_Pos = 0x6
	// Bit mask of BSGTRGDR field.
	GPT321_GTICBSR_BSGTRGDR_Msk = 0x40
	// Bit BSGTRGDR.
	GPT321_GTICBSR_BSGTRGDR = 0x40
	// GTCCRB input capture disabled on the rising edge of GTETRGD input
	GPT321_GTICBSR_BSGTRGDR_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTETRGD input
	GPT321_GTICBSR_BSGTRGDR_1 = 0x1
	// Position of BSGTRGDF field.
	GPT321_GTICBSR_BSGTRGDF_Pos = 0x7
	// Bit mask of BSGTRGDF field.
	GPT321_GTICBSR_BSGTRGDF_Msk = 0x80
	// Bit BSGTRGDF.
	GPT321_GTICBSR_BSGTRGDF = 0x80
	// GTCCRB input capture disabled on the falling edge of GTETRGD input
	GPT321_GTICBSR_BSGTRGDF_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTETRGD input
	GPT321_GTICBSR_BSGTRGDF_1 = 0x1
	// Position of BSCARBL field.
	GPT321_GTICBSR_BSCARBL_Pos = 0x8
	// Bit mask of BSCARBL field.
	GPT321_GTICBSR_BSCARBL_Msk = 0x100
	// Bit BSCARBL.
	GPT321_GTICBSR_BSCARBL = 0x100
	// GTCCRB input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTICBSR_BSCARBL_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTICBSR_BSCARBL_1 = 0x1
	// Position of BSCARBH field.
	GPT321_GTICBSR_BSCARBH_Pos = 0x9
	// Bit mask of BSCARBH field.
	GPT321_GTICBSR_BSCARBH_Msk = 0x200
	// Bit BSCARBH.
	GPT321_GTICBSR_BSCARBH = 0x200
	// GTCCRB input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTICBSR_BSCARBH_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTICBSR_BSCARBH_1 = 0x1
	// Position of BSCAFBL field.
	GPT321_GTICBSR_BSCAFBL_Pos = 0xa
	// Bit mask of BSCAFBL field.
	GPT321_GTICBSR_BSCAFBL_Msk = 0x400
	// Bit BSCAFBL.
	GPT321_GTICBSR_BSCAFBL = 0x400
	// GTCCRB input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTICBSR_BSCAFBL_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT321_GTICBSR_BSCAFBL_1 = 0x1
	// Position of BSCAFBH field.
	GPT321_GTICBSR_BSCAFBH_Pos = 0xb
	// Bit mask of BSCAFBH field.
	GPT321_GTICBSR_BSCAFBH_Msk = 0x800
	// Bit BSCAFBH.
	GPT321_GTICBSR_BSCAFBH = 0x800
	// GTCCRB input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTICBSR_BSCAFBH_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT321_GTICBSR_BSCAFBH_1 = 0x1
	// Position of BSCBRAL field.
	GPT321_GTICBSR_BSCBRAL_Pos = 0xc
	// Bit mask of BSCBRAL field.
	GPT321_GTICBSR_BSCBRAL_Msk = 0x1000
	// Bit BSCBRAL.
	GPT321_GTICBSR_BSCBRAL = 0x1000
	// GTCCRB input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTICBSR_BSCBRAL_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTICBSR_BSCBRAL_1 = 0x1
	// Position of BSCBRAH field.
	GPT321_GTICBSR_BSCBRAH_Pos = 0xd
	// Bit mask of BSCBRAH field.
	GPT321_GTICBSR_BSCBRAH_Msk = 0x2000
	// Bit BSCBRAH.
	GPT321_GTICBSR_BSCBRAH = 0x2000
	// GTCCRB input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTICBSR_BSCBRAH_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTICBSR_BSCBRAH_1 = 0x1
	// Position of BSCBFAL field.
	GPT321_GTICBSR_BSCBFAL_Pos = 0xe
	// Bit mask of BSCBFAL field.
	GPT321_GTICBSR_BSCBFAL_Msk = 0x4000
	// Bit BSCBFAL.
	GPT321_GTICBSR_BSCBFAL = 0x4000
	// GTCCRB input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTICBSR_BSCBFAL_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT321_GTICBSR_BSCBFAL_1 = 0x1
	// Position of BSCBFAH field.
	GPT321_GTICBSR_BSCBFAH_Pos = 0xf
	// Bit mask of BSCBFAH field.
	GPT321_GTICBSR_BSCBFAH_Msk = 0x8000
	// Bit BSCBFAH.
	GPT321_GTICBSR_BSCBFAH = 0x8000
	// GTCCRB input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTICBSR_BSCBFAH_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT321_GTICBSR_BSCBFAH_1 = 0x1
	// Position of BSELCA field.
	GPT321_GTICBSR_BSELCA_Pos = 0x10
	// Bit mask of BSELCA field.
	GPT321_GTICBSR_BSELCA_Msk = 0x10000
	// Bit BSELCA.
	GPT321_GTICBSR_BSELCA = 0x10000
	// GTCCRB input capture disabled at the ELC_GPTA input
	GPT321_GTICBSR_BSELCA_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTA input
	GPT321_GTICBSR_BSELCA_1 = 0x1
	// Position of BSELCB field.
	GPT321_GTICBSR_BSELCB_Pos = 0x11
	// Bit mask of BSELCB field.
	GPT321_GTICBSR_BSELCB_Msk = 0x20000
	// Bit BSELCB.
	GPT321_GTICBSR_BSELCB = 0x20000
	// GTCCRB input capture disabled at the ELC_GPTB input
	GPT321_GTICBSR_BSELCB_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTB input
	GPT321_GTICBSR_BSELCB_1 = 0x1
	// Position of BSELCC field.
	GPT321_GTICBSR_BSELCC_Pos = 0x12
	// Bit mask of BSELCC field.
	GPT321_GTICBSR_BSELCC_Msk = 0x40000
	// Bit BSELCC.
	GPT321_GTICBSR_BSELCC = 0x40000
	// GTCCRB input capture disabled at the ELC_GPTC input
	GPT321_GTICBSR_BSELCC_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTC input
	GPT321_GTICBSR_BSELCC_1 = 0x1
	// Position of BSELCD field.
	GPT321_GTICBSR_BSELCD_Pos = 0x13
	// Bit mask of BSELCD field.
	GPT321_GTICBSR_BSELCD_Msk = 0x80000
	// Bit BSELCD.
	GPT321_GTICBSR_BSELCD = 0x80000
	// GTCCRB input capture disabled at the ELC_GPTD input
	GPT321_GTICBSR_BSELCD_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTD input
	GPT321_GTICBSR_BSELCD_1 = 0x1
	// Position of BSELCE field.
	GPT321_GTICBSR_BSELCE_Pos = 0x14
	// Bit mask of BSELCE field.
	GPT321_GTICBSR_BSELCE_Msk = 0x100000
	// Bit BSELCE.
	GPT321_GTICBSR_BSELCE = 0x100000
	// GTCCRB input capture disabled at the ELC_GPTE input
	GPT321_GTICBSR_BSELCE_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTE input
	GPT321_GTICBSR_BSELCE_1 = 0x1
	// Position of BSELCF field.
	GPT321_GTICBSR_BSELCF_Pos = 0x15
	// Bit mask of BSELCF field.
	GPT321_GTICBSR_BSELCF_Msk = 0x200000
	// Bit BSELCF.
	GPT321_GTICBSR_BSELCF = 0x200000
	// GTCCRB input capture disabled at the ELC_GPTF input
	GPT321_GTICBSR_BSELCF_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTF input
	GPT321_GTICBSR_BSELCF_1 = 0x1
	// Position of BSELCG field.
	GPT321_GTICBSR_BSELCG_Pos = 0x16
	// Bit mask of BSELCG field.
	GPT321_GTICBSR_BSELCG_Msk = 0x400000
	// Bit BSELCG.
	GPT321_GTICBSR_BSELCG = 0x400000
	// GTCCRB input capture disabled at the ELC_GPTG input
	GPT321_GTICBSR_BSELCG_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTG input
	GPT321_GTICBSR_BSELCG_1 = 0x1
	// Position of BSELCH field.
	GPT321_GTICBSR_BSELCH_Pos = 0x17
	// Bit mask of BSELCH field.
	GPT321_GTICBSR_BSELCH_Msk = 0x800000
	// Bit BSELCH.
	GPT321_GTICBSR_BSELCH = 0x800000
	// GTCCRB input capture disabled at the ELC_GPTH input
	GPT321_GTICBSR_BSELCH_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTH input
	GPT321_GTICBSR_BSELCH_1 = 0x1

	// GTCR: General PWM Timer Control Register
	// Position of CST field.
	GPT321_GTCR_CST_Pos = 0x0
	// Bit mask of CST field.
	GPT321_GTCR_CST_Msk = 0x1
	// Bit CST.
	GPT321_GTCR_CST = 0x1
	// Count operation is stopped
	GPT321_GTCR_CST_0 = 0x0
	// Count operation is performed
	GPT321_GTCR_CST_1 = 0x1
	// Position of MD field.
	GPT321_GTCR_MD_Pos = 0x10
	// Bit mask of MD field.
	GPT321_GTCR_MD_Msk = 0x70000
	// Saw-wave PWM mode (single buffer or double buffer possible)
	GPT321_GTCR_MD_000 = 0x0
	// Saw-wave one-shot pulse mode (fixed buffer operation)
	GPT321_GTCR_MD_001 = 0x1
	// Setting prohibited
	GPT321_GTCR_MD_010 = 0x2
	// Setting prohibited
	GPT321_GTCR_MD_011 = 0x3
	// Triangle-wave PWM mode 1 (32-bit transfer at trough) (single buffer or double buffer is possible)
	GPT321_GTCR_MD_100 = 0x4
	// Triangle-wave PWM mode 2 (32-bit transfer at crest and trough) (single buffer or double buffer is possible)
	GPT321_GTCR_MD_101 = 0x5
	// Triangle-wave PWM mode 3 (64-bit transfer at trough) (fixed buffer operation)
	GPT321_GTCR_MD_110 = 0x6
	// Setting prohibited
	GPT321_GTCR_MD_111 = 0x7
	// Position of TPCS field.
	GPT321_GTCR_TPCS_Pos = 0x17
	// Bit mask of TPCS field.
	GPT321_GTCR_TPCS_Msk = 0x7800000
	// PCLKD/1
	GPT321_GTCR_TPCS_0x0 = 0x0
	// PCLKD/2
	GPT321_GTCR_TPCS_0x1 = 0x1
	// PCLKD/4
	GPT321_GTCR_TPCS_0x2 = 0x2
	// PCLKD/8
	GPT321_GTCR_TPCS_0x3 = 0x3
	// PCLKD/16
	GPT321_GTCR_TPCS_0x4 = 0x4
	// PCLKD/32
	GPT321_GTCR_TPCS_0x5 = 0x5
	// PCLKD/64
	GPT321_GTCR_TPCS_0x6 = 0x6
	// Setting prohibited
	GPT321_GTCR_TPCS_0x7 = 0x7
	// PCLKD/256
	GPT321_GTCR_TPCS_0x8 = 0x8
	// Setting prohibited
	GPT321_GTCR_TPCS_0x9 = 0x9
	// PCLKD/1024
	GPT321_GTCR_TPCS_0xA = 0xa
	// Setting prohibited
	GPT321_GTCR_TPCS_0xB = 0xb
	// GTETRGA (Via the POEG)
	GPT321_GTCR_TPCS_0xC = 0xc
	// GTETRGB (Via the POEG)
	GPT321_GTCR_TPCS_0xD = 0xd
	// GTETRGC (Via the POEG)
	GPT321_GTCR_TPCS_0xE = 0xe
	// GTETRGD (Via the POEG)
	GPT321_GTCR_TPCS_0xF = 0xf

	// GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
	// Position of UD field.
	GPT321_GTUDDTYC_UD_Pos = 0x0
	// Bit mask of UD field.
	GPT321_GTUDDTYC_UD_Msk = 0x1
	// Bit UD.
	GPT321_GTUDDTYC_UD = 0x1
	// GTCNT counts down
	GPT321_GTUDDTYC_UD_0 = 0x0
	// GTCNT counts up
	GPT321_GTUDDTYC_UD_1 = 0x1
	// Position of UDF field.
	GPT321_GTUDDTYC_UDF_Pos = 0x1
	// Bit mask of UDF field.
	GPT321_GTUDDTYC_UDF_Msk = 0x2
	// Bit UDF.
	GPT321_GTUDDTYC_UDF = 0x2
	// Not forcibly set
	GPT321_GTUDDTYC_UDF_0 = 0x0
	// Forcibly set
	GPT321_GTUDDTYC_UDF_1 = 0x1
	// Position of OADTY field.
	GPT321_GTUDDTYC_OADTY_Pos = 0x10
	// Bit mask of OADTY field.
	GPT321_GTUDDTYC_OADTY_Msk = 0x30000
	// GTIOCnA pin duty depends on the compare match
	GPT321_GTUDDTYC_OADTY_00 = 0x0
	// GTIOCnA pin duty depends on the compare match
	GPT321_GTUDDTYC_OADTY_01 = 0x1
	// GTIOCnA pin duty 0%
	GPT321_GTUDDTYC_OADTY_10 = 0x2
	// GTIOCnA pin duty 100%
	GPT321_GTUDDTYC_OADTY_11 = 0x3
	// Position of OADTYF field.
	GPT321_GTUDDTYC_OADTYF_Pos = 0x12
	// Bit mask of OADTYF field.
	GPT321_GTUDDTYC_OADTYF_Msk = 0x40000
	// Bit OADTYF.
	GPT321_GTUDDTYC_OADTYF = 0x40000
	// Not forcibly set
	GPT321_GTUDDTYC_OADTYF_0 = 0x0
	// Forcibly set
	GPT321_GTUDDTYC_OADTYF_1 = 0x1
	// Position of OADTYR field.
	GPT321_GTUDDTYC_OADTYR_Pos = 0x13
	// Bit mask of OADTYR field.
	GPT321_GTUDDTYC_OADTYR_Msk = 0x80000
	// Bit OADTYR.
	GPT321_GTUDDTYC_OADTYR = 0x80000
	// The function selected by the GTIOA[3:2] bits is applied to the output value when the duty cycle is set after release from the 0 or 100% duty-cycle setting.
	GPT321_GTUDDTYC_OADTYR_0 = 0x0
	// The function selected by the GTIOA[3:2] bits is applied to the compare match output value which is masked after release from the 0 or 100% duty-cycle setting.
	GPT321_GTUDDTYC_OADTYR_1 = 0x1
	// Position of OBDTY field.
	GPT321_GTUDDTYC_OBDTY_Pos = 0x18
	// Bit mask of OBDTY field.
	GPT321_GTUDDTYC_OBDTY_Msk = 0x3000000
	// GTIOCnB pin duty depends on the compare match
	GPT321_GTUDDTYC_OBDTY_00 = 0x0
	// GTIOCnB pin duty depends on the compare match
	GPT321_GTUDDTYC_OBDTY_01 = 0x1
	// GTIOCnB pin duty 0%
	GPT321_GTUDDTYC_OBDTY_10 = 0x2
	// GTIOCnB pin duty 100%
	GPT321_GTUDDTYC_OBDTY_11 = 0x3
	// Position of OBDTYF field.
	GPT321_GTUDDTYC_OBDTYF_Pos = 0x1a
	// Bit mask of OBDTYF field.
	GPT321_GTUDDTYC_OBDTYF_Msk = 0x4000000
	// Bit OBDTYF.
	GPT321_GTUDDTYC_OBDTYF = 0x4000000
	// Not forcibly set
	GPT321_GTUDDTYC_OBDTYF_0 = 0x0
	// Forcibly set
	GPT321_GTUDDTYC_OBDTYF_1 = 0x1
	// Position of OBDTYR field.
	GPT321_GTUDDTYC_OBDTYR_Pos = 0x1b
	// Bit mask of OBDTYR field.
	GPT321_GTUDDTYC_OBDTYR_Msk = 0x8000000
	// Bit OBDTYR.
	GPT321_GTUDDTYC_OBDTYR = 0x8000000
	// The function selected by the GTIOB[3:2] bits is applied to the output value when the duty cycle is set after release from the 0 or 100% duty-cycle setting.
	GPT321_GTUDDTYC_OBDTYR_0 = 0x0
	// The function selected by the GTIOB[3:2] bits is applied to the compare match output value which is masked after release from the 0 or 100% duty-cycle setting.
	GPT321_GTUDDTYC_OBDTYR_1 = 0x1

	// GTIOR: General PWM Timer I/O Control Register
	// Position of GTIOA field.
	GPT321_GTIOR_GTIOA_Pos = 0x0
	// Bit mask of GTIOA field.
	GPT321_GTIOR_GTIOA_Msk = 0x1f
	// Position of OADFLT field.
	GPT321_GTIOR_OADFLT_Pos = 0x6
	// Bit mask of OADFLT field.
	GPT321_GTIOR_OADFLT_Msk = 0x40
	// Bit OADFLT.
	GPT321_GTIOR_OADFLT = 0x40
	// The GTIOCnA pin outputs low when counting stops
	GPT321_GTIOR_OADFLT_0 = 0x0
	// The GTIOCnA pin outputs high when counting stops
	GPT321_GTIOR_OADFLT_1 = 0x1
	// Position of OAHLD field.
	GPT321_GTIOR_OAHLD_Pos = 0x7
	// Bit mask of OAHLD field.
	GPT321_GTIOR_OAHLD_Msk = 0x80
	// Bit OAHLD.
	GPT321_GTIOR_OAHLD = 0x80
	// The GTIOCnA pin output level at the start or stop of counting depends on the register setting
	GPT321_GTIOR_OAHLD_0 = 0x0
	// The GTIOCnA pin output level is retained at the start or stop of counting
	GPT321_GTIOR_OAHLD_1 = 0x1
	// Position of OAE field.
	GPT321_GTIOR_OAE_Pos = 0x8
	// Bit mask of OAE field.
	GPT321_GTIOR_OAE_Msk = 0x100
	// Bit OAE.
	GPT321_GTIOR_OAE = 0x100
	// Output is disabled
	GPT321_GTIOR_OAE_0 = 0x0
	// Output is enabled
	GPT321_GTIOR_OAE_1 = 0x1
	// Position of OADF field.
	GPT321_GTIOR_OADF_Pos = 0x9
	// Bit mask of OADF field.
	GPT321_GTIOR_OADF_Msk = 0x600
	// None of the below options are specified
	GPT321_GTIOR_OADF_00 = 0x0
	// GTIOCnA pin is set to Hi-Z in response to controlling the output negation
	GPT321_GTIOR_OADF_01 = 0x1
	// GTIOCnA pin is set to 0 in response to controlling the output negation
	GPT321_GTIOR_OADF_10 = 0x2
	// GTIOCnA pin is set to 1 in response to controlling the output negation
	GPT321_GTIOR_OADF_11 = 0x3
	// Position of NFAEN field.
	GPT321_GTIOR_NFAEN_Pos = 0xd
	// Bit mask of NFAEN field.
	GPT321_GTIOR_NFAEN_Msk = 0x2000
	// Bit NFAEN.
	GPT321_GTIOR_NFAEN = 0x2000
	// The noise filter for the GTIOCnA pin is disabled
	GPT321_GTIOR_NFAEN_0 = 0x0
	// The noise filter for the GTIOCnA pin is enabled
	GPT321_GTIOR_NFAEN_1 = 0x1
	// Position of NFCSA field.
	GPT321_GTIOR_NFCSA_Pos = 0xe
	// Bit mask of NFCSA field.
	GPT321_GTIOR_NFCSA_Msk = 0xc000
	// PCLKD/1
	GPT321_GTIOR_NFCSA_00 = 0x0
	// PCLKD/4
	GPT321_GTIOR_NFCSA_01 = 0x1
	// PCLKD/16
	GPT321_GTIOR_NFCSA_10 = 0x2
	// PCLKD/64
	GPT321_GTIOR_NFCSA_11 = 0x3
	// Position of GTIOB field.
	GPT321_GTIOR_GTIOB_Pos = 0x10
	// Bit mask of GTIOB field.
	GPT321_GTIOR_GTIOB_Msk = 0x1f0000
	// Position of OBDFLT field.
	GPT321_GTIOR_OBDFLT_Pos = 0x16
	// Bit mask of OBDFLT field.
	GPT321_GTIOR_OBDFLT_Msk = 0x400000
	// Bit OBDFLT.
	GPT321_GTIOR_OBDFLT = 0x400000
	// The GTIOCnB pin outputs low when counting stops
	GPT321_GTIOR_OBDFLT_0 = 0x0
	// The GTIOCnB pin outputs high when counting stops
	GPT321_GTIOR_OBDFLT_1 = 0x1
	// Position of OBHLD field.
	GPT321_GTIOR_OBHLD_Pos = 0x17
	// Bit mask of OBHLD field.
	GPT321_GTIOR_OBHLD_Msk = 0x800000
	// Bit OBHLD.
	GPT321_GTIOR_OBHLD = 0x800000
	// The GTIOCnB pin output level at the start/stop of counting depends on the register setting
	GPT321_GTIOR_OBHLD_0 = 0x0
	// The GTIOCnB pin output level is retained at the start/stop of counting
	GPT321_GTIOR_OBHLD_1 = 0x1
	// Position of OBE field.
	GPT321_GTIOR_OBE_Pos = 0x18
	// Bit mask of OBE field.
	GPT321_GTIOR_OBE_Msk = 0x1000000
	// Bit OBE.
	GPT321_GTIOR_OBE = 0x1000000
	// Output is disabled
	GPT321_GTIOR_OBE_0 = 0x0
	// Output is enabled
	GPT321_GTIOR_OBE_1 = 0x1
	// Position of OBDF field.
	GPT321_GTIOR_OBDF_Pos = 0x19
	// Bit mask of OBDF field.
	GPT321_GTIOR_OBDF_Msk = 0x6000000
	// None of the below options are specified
	GPT321_GTIOR_OBDF_00 = 0x0
	// GTIOCnB pin is set to Hi-Z in response to controlling the output negation
	GPT321_GTIOR_OBDF_01 = 0x1
	// GTIOCnB pin is set to 0 in response to controlling the output negation
	GPT321_GTIOR_OBDF_10 = 0x2
	// GTIOCnB pin is set to 1 in response to controlling the output negation
	GPT321_GTIOR_OBDF_11 = 0x3
	// Position of NFBEN field.
	GPT321_GTIOR_NFBEN_Pos = 0x1d
	// Bit mask of NFBEN field.
	GPT321_GTIOR_NFBEN_Msk = 0x20000000
	// Bit NFBEN.
	GPT321_GTIOR_NFBEN = 0x20000000
	// The noise filter for the GTIOCnB pin is disabled
	GPT321_GTIOR_NFBEN_0 = 0x0
	// The noise filter for the GTIOCnB pin is enabled
	GPT321_GTIOR_NFBEN_1 = 0x1
	// Position of NFCSB field.
	GPT321_GTIOR_NFCSB_Pos = 0x1e
	// Bit mask of NFCSB field.
	GPT321_GTIOR_NFCSB_Msk = 0xc0000000
	// PCLKD/1
	GPT321_GTIOR_NFCSB_00 = 0x0
	// PCLKD/4
	GPT321_GTIOR_NFCSB_01 = 0x1
	// PCLKD/16
	GPT321_GTIOR_NFCSB_10 = 0x2
	// PCLKD/64
	GPT321_GTIOR_NFCSB_11 = 0x3

	// GTINTAD: General PWM Timer Interrupt Output Setting Register
	// Position of GRP field.
	GPT321_GTINTAD_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT321_GTINTAD_GRP_Msk = 0x3000000
	// Group A output disable request is selected
	GPT321_GTINTAD_GRP_00 = 0x0
	// Group B output disable request is selected
	GPT321_GTINTAD_GRP_01 = 0x1
	// Group C output disable request is selected
	GPT321_GTINTAD_GRP_10 = 0x2
	// Group D output disable request is selected
	GPT321_GTINTAD_GRP_11 = 0x3
	// Position of GRPABH field.
	GPT321_GTINTAD_GRPABH_Pos = 0x1d
	// Bit mask of GRPABH field.
	GPT321_GTINTAD_GRPABH_Msk = 0x20000000
	// Bit GRPABH.
	GPT321_GTINTAD_GRPABH = 0x20000000
	// Same time output level high disable request disabled
	GPT321_GTINTAD_GRPABH_0 = 0x0
	// Same time output level high disable request enabled
	GPT321_GTINTAD_GRPABH_1 = 0x1
	// Position of GRPABL field.
	GPT321_GTINTAD_GRPABL_Pos = 0x1e
	// Bit mask of GRPABL field.
	GPT321_GTINTAD_GRPABL_Msk = 0x40000000
	// Bit GRPABL.
	GPT321_GTINTAD_GRPABL = 0x40000000
	// Same time output level low disable request disabled
	GPT321_GTINTAD_GRPABL_0 = 0x0
	// Same time output level low disable request enabled
	GPT321_GTINTAD_GRPABL_1 = 0x1

	// GTST: General PWM Timer Status Register
	// Position of TCFA field.
	GPT321_GTST_TCFA_Pos = 0x0
	// Bit mask of TCFA field.
	GPT321_GTST_TCFA_Msk = 0x1
	// Bit TCFA.
	GPT321_GTST_TCFA = 0x1
	// No input capture/compare match of GTCCRA is generated
	GPT321_GTST_TCFA_0 = 0x0
	// An input capture/compare match of GTCCRA is generated
	GPT321_GTST_TCFA_1 = 0x1
	// Position of TCFB field.
	GPT321_GTST_TCFB_Pos = 0x1
	// Bit mask of TCFB field.
	GPT321_GTST_TCFB_Msk = 0x2
	// Bit TCFB.
	GPT321_GTST_TCFB = 0x2
	// No input capture/compare match of GTCCRB is generated
	GPT321_GTST_TCFB_0 = 0x0
	// An input capture/compare match of GTCCRB is generated
	GPT321_GTST_TCFB_1 = 0x1
	// Position of TCFC field.
	GPT321_GTST_TCFC_Pos = 0x2
	// Bit mask of TCFC field.
	GPT321_GTST_TCFC_Msk = 0x4
	// Bit TCFC.
	GPT321_GTST_TCFC = 0x4
	// No compare match of GTCCRC is generated
	GPT321_GTST_TCFC_0 = 0x0
	// A compare match of GTCCRC is generated
	GPT321_GTST_TCFC_1 = 0x1
	// Position of TCFD field.
	GPT321_GTST_TCFD_Pos = 0x3
	// Bit mask of TCFD field.
	GPT321_GTST_TCFD_Msk = 0x8
	// Bit TCFD.
	GPT321_GTST_TCFD = 0x8
	// No compare match of GTCCRD is generated
	GPT321_GTST_TCFD_0 = 0x0
	// A compare match of GTCCRD is generated
	GPT321_GTST_TCFD_1 = 0x1
	// Position of TCFE field.
	GPT321_GTST_TCFE_Pos = 0x4
	// Bit mask of TCFE field.
	GPT321_GTST_TCFE_Msk = 0x10
	// Bit TCFE.
	GPT321_GTST_TCFE = 0x10
	// No compare match of GTCCRE is generated
	GPT321_GTST_TCFE_0 = 0x0
	// A compare match of GTCCRE is generated
	GPT321_GTST_TCFE_1 = 0x1
	// Position of TCFF field.
	GPT321_GTST_TCFF_Pos = 0x5
	// Bit mask of TCFF field.
	GPT321_GTST_TCFF_Msk = 0x20
	// Bit TCFF.
	GPT321_GTST_TCFF = 0x20
	// No compare match of GTCCRF is generated
	GPT321_GTST_TCFF_0 = 0x0
	// A compare match of GTCCRF is generated
	GPT321_GTST_TCFF_1 = 0x1
	// Position of TCFPO field.
	GPT321_GTST_TCFPO_Pos = 0x6
	// Bit mask of TCFPO field.
	GPT321_GTST_TCFPO_Msk = 0x40
	// Bit TCFPO.
	GPT321_GTST_TCFPO = 0x40
	// No overflow (crest) occurred
	GPT321_GTST_TCFPO_0 = 0x0
	// An overflow (crest) occurred
	GPT321_GTST_TCFPO_1 = 0x1
	// Position of TCFPU field.
	GPT321_GTST_TCFPU_Pos = 0x7
	// Bit mask of TCFPU field.
	GPT321_GTST_TCFPU_Msk = 0x80
	// Bit TCFPU.
	GPT321_GTST_TCFPU = 0x80
	// No underflow (trough) occurred
	GPT321_GTST_TCFPU_0 = 0x0
	// An underflow (trough) occurred
	GPT321_GTST_TCFPU_1 = 0x1
	// Position of TUCF field.
	GPT321_GTST_TUCF_Pos = 0xf
	// Bit mask of TUCF field.
	GPT321_GTST_TUCF_Msk = 0x8000
	// Bit TUCF.
	GPT321_GTST_TUCF = 0x8000
	// GTCNT counter counts downward
	GPT321_GTST_TUCF_0 = 0x0
	// GTCNT counter counts upward
	GPT321_GTST_TUCF_1 = 0x1
	// Position of ODF field.
	GPT321_GTST_ODF_Pos = 0x18
	// Bit mask of ODF field.
	GPT321_GTST_ODF_Msk = 0x1000000
	// Bit ODF.
	GPT321_GTST_ODF = 0x1000000
	// No output disable request is generated
	GPT321_GTST_ODF_0 = 0x0
	// An output disable request is generated
	GPT321_GTST_ODF_1 = 0x1
	// Position of OABHF field.
	GPT321_GTST_OABHF_Pos = 0x1d
	// Bit mask of OABHF field.
	GPT321_GTST_OABHF_Msk = 0x20000000
	// Bit OABHF.
	GPT321_GTST_OABHF = 0x20000000
	// No simultaneous generation of 1 both for the GTIOCA and GTIOCB pins has occurred.
	GPT321_GTST_OABHF_0 = 0x0
	// A simultaneous generation of 1 both for the GTIOCA and GTIOCB pins has occurred.
	GPT321_GTST_OABHF_1 = 0x1
	// Position of OABLF field.
	GPT321_GTST_OABLF_Pos = 0x1e
	// Bit mask of OABLF field.
	GPT321_GTST_OABLF_Msk = 0x40000000
	// Bit OABLF.
	GPT321_GTST_OABLF = 0x40000000
	// No simultaneous generation of 0 both for the GTIOCA and GTIOCB pins has occurred.
	GPT321_GTST_OABLF_0 = 0x0
	// A simultaneous generation of 0 both for the GTIOCA and GTIOCB pins has occurred.
	GPT321_GTST_OABLF_1 = 0x1
	// Position of PCF field.
	GPT321_GTST_PCF_Pos = 0x1f
	// Bit mask of PCF field.
	GPT321_GTST_PCF_Msk = 0x80000000
	// Bit PCF.
	GPT321_GTST_PCF = 0x80000000
	// No period count function finish has occurred
	GPT321_GTST_PCF_0 = 0x0
	// A period count function finish has occurred
	GPT321_GTST_PCF_1 = 0x1

	// GTBER: General PWM Timer Buffer Enable Register
	// Position of BD0 field.
	GPT321_GTBER_BD0_Pos = 0x0
	// Bit mask of BD0 field.
	GPT321_GTBER_BD0_Msk = 0x1
	// Bit BD0.
	GPT321_GTBER_BD0 = 0x1
	// Buffer operation is enabled
	GPT321_GTBER_BD0_0 = 0x0
	// Buffer operation is disabled
	GPT321_GTBER_BD0_1 = 0x1
	// Position of BD1 field.
	GPT321_GTBER_BD1_Pos = 0x1
	// Bit mask of BD1 field.
	GPT321_GTBER_BD1_Msk = 0x2
	// Bit BD1.
	GPT321_GTBER_BD1 = 0x2
	// Buffer operation is enabled
	GPT321_GTBER_BD1_0 = 0x0
	// Buffer operation is disabled
	GPT321_GTBER_BD1_1 = 0x1
	// Position of CCRA field.
	GPT321_GTBER_CCRA_Pos = 0x10
	// Bit mask of CCRA field.
	GPT321_GTBER_CCRA_Msk = 0x30000
	// No buffer operation
	GPT321_GTBER_CCRA_00 = 0x0
	// Single buffer operation (GTCCRA <---->GTCCRC)
	GPT321_GTBER_CCRA_01 = 0x1
	// Position of CCRB field.
	GPT321_GTBER_CCRB_Pos = 0x12
	// Bit mask of CCRB field.
	GPT321_GTBER_CCRB_Msk = 0xc0000
	// No buffer operation
	GPT321_GTBER_CCRB_00 = 0x0
	// Single buffer operation (GTCCRB <----> GTCCRE)
	GPT321_GTBER_CCRB_01 = 0x1
	// Position of PR field.
	GPT321_GTBER_PR_Pos = 0x14
	// Bit mask of PR field.
	GPT321_GTBER_PR_Msk = 0x300000
	// No buffer operation
	GPT321_GTBER_PR_00 = 0x0
	// Single buffer operation (GTPBR --> GTPR)
	GPT321_GTBER_PR_01 = 0x1
	// Position of CCRSWT field.
	GPT321_GTBER_CCRSWT_Pos = 0x16
	// Bit mask of CCRSWT field.
	GPT321_GTBER_CCRSWT_Msk = 0x400000
	// Bit CCRSWT.
	GPT321_GTBER_CCRSWT = 0x400000

	// GTDTCR: General PWM Timer Dead Time Control Register
	// Position of TDE field.
	GPT321_GTDTCR_TDE_Pos = 0x0
	// Bit mask of TDE field.
	GPT321_GTDTCR_TDE_Msk = 0x1
	// Bit TDE.
	GPT321_GTDTCR_TDE = 0x1
	// GTCCRB is set without using GTDVU
	GPT321_GTDTCR_TDE_0 = 0x0
	// GTDVU is used to set the compare match value for negative-phase waveform with dead time automatically in GTCCRB
	GPT321_GTDTCR_TDE_1 = 0x1

	// GTICLF: General PWM Timer Inter Channel Logical Operation Function Setting Register
	// Position of ICLFA field.
	GPT321_GTICLF_ICLFA_Pos = 0x0
	// Bit mask of ICLFA field.
	GPT321_GTICLF_ICLFA_Msk = 0x7
	// A (no delay)
	GPT321_GTICLF_ICLFA_000 = 0x0
	// NOT A (no delay)
	GPT321_GTICLF_ICLFA_001 = 0x1
	// C (1PCLKD delay)
	GPT321_GTICLF_ICLFA_010 = 0x2
	// NOT C (1PCLKD delay)
	GPT321_GTICLF_ICLFA_011 = 0x3
	// A AND C (1PCLKD delay)
	GPT321_GTICLF_ICLFA_100 = 0x4
	// A OR C (1PCLKD delay)
	GPT321_GTICLF_ICLFA_101 = 0x5
	// A EXOR C (1PCLKD delay)
	GPT321_GTICLF_ICLFA_110 = 0x6
	// A NOR C (1PCLKD delay)
	GPT321_GTICLF_ICLFA_111 = 0x7
	// Position of ICLFSELC field.
	GPT321_GTICLF_ICLFSELC_Pos = 0x4
	// Bit mask of ICLFSELC field.
	GPT321_GTICLF_ICLFSELC_Msk = 0x3f0
	// GTIOC0A
	GPT321_GTICLF_ICLFSELC_0x00 = 0x0
	// GTIOC0B
	GPT321_GTICLF_ICLFSELC_0x01 = 0x1
	// GTIOC1A
	GPT321_GTICLF_ICLFSELC_0x02 = 0x2
	// GTIOC1B
	GPT321_GTICLF_ICLFSELC_0x03 = 0x3
	// GTIOC2A
	GPT321_GTICLF_ICLFSELC_0x04 = 0x4
	// GTIOC2B
	GPT321_GTICLF_ICLFSELC_0x05 = 0x5
	// GTIOC3A
	GPT321_GTICLF_ICLFSELC_0x06 = 0x6
	// GTIOC3B
	GPT321_GTICLF_ICLFSELC_0x07 = 0x7
	// GTIOC4A
	GPT321_GTICLF_ICLFSELC_0x08 = 0x8
	// GTIOC4B
	GPT321_GTICLF_ICLFSELC_0x09 = 0x9
	// GTIOC5A
	GPT321_GTICLF_ICLFSELC_0x0A = 0xa
	// GTIOC5B
	GPT321_GTICLF_ICLFSELC_0x0B = 0xb
	// GTIOC6A
	GPT321_GTICLF_ICLFSELC_0x0C = 0xc
	// GTIOC6B
	GPT321_GTICLF_ICLFSELC_0x0D = 0xd
	// GTIOC7A
	GPT321_GTICLF_ICLFSELC_0x0E = 0xe
	// GTIOC7B
	GPT321_GTICLF_ICLFSELC_0x0F = 0xf
	// GTIOC8A
	GPT321_GTICLF_ICLFSELC_0x10 = 0x10
	// GTIOC8B
	GPT321_GTICLF_ICLFSELC_0x11 = 0x11
	// GTIOC9A
	GPT321_GTICLF_ICLFSELC_0x12 = 0x12
	// GTIOC9B
	GPT321_GTICLF_ICLFSELC_0x13 = 0x13
	// Position of ICLFB field.
	GPT321_GTICLF_ICLFB_Pos = 0x10
	// Bit mask of ICLFB field.
	GPT321_GTICLF_ICLFB_Msk = 0x70000
	// B (no delay)
	GPT321_GTICLF_ICLFB_000 = 0x0
	// NOT B (no delay)
	GPT321_GTICLF_ICLFB_001 = 0x1
	// D (1PCLKD delay)
	GPT321_GTICLF_ICLFB_010 = 0x2
	// NOT D (1PCLKD delay)
	GPT321_GTICLF_ICLFB_011 = 0x3
	// B AND D (1PCLKD delay)
	GPT321_GTICLF_ICLFB_100 = 0x4
	// B OR D (1PCLKDn delay)
	GPT321_GTICLF_ICLFB_101 = 0x5
	// B EXOR D (1PCLKD delay)
	GPT321_GTICLF_ICLFB_110 = 0x6
	// B NOR D (1PCLKD delay)
	GPT321_GTICLF_ICLFB_111 = 0x7
	// Position of ICLFSELD field.
	GPT321_GTICLF_ICLFSELD_Pos = 0x14
	// Bit mask of ICLFSELD field.
	GPT321_GTICLF_ICLFSELD_Msk = 0x3f00000
	// GTIOC0A
	GPT321_GTICLF_ICLFSELD_0x00 = 0x0
	// GTIOC0B
	GPT321_GTICLF_ICLFSELD_0x01 = 0x1
	// GTIOC1A
	GPT321_GTICLF_ICLFSELD_0x02 = 0x2
	// GTIOC1B
	GPT321_GTICLF_ICLFSELD_0x03 = 0x3
	// GTIOC2A
	GPT321_GTICLF_ICLFSELD_0x04 = 0x4
	// GTIOC2B
	GPT321_GTICLF_ICLFSELD_0x05 = 0x5
	// GTIOC3A
	GPT321_GTICLF_ICLFSELD_0x06 = 0x6
	// GTIOC3B
	GPT321_GTICLF_ICLFSELD_0x07 = 0x7
	// GTIOC4A
	GPT321_GTICLF_ICLFSELD_0x08 = 0x8
	// GTIOC4B
	GPT321_GTICLF_ICLFSELD_0x09 = 0x9
	// GTIOC5A
	GPT321_GTICLF_ICLFSELD_0x0A = 0xa
	// GTIOC5B
	GPT321_GTICLF_ICLFSELD_0x0B = 0xb
	// GTIOC6A
	GPT321_GTICLF_ICLFSELD_0x0C = 0xc
	// GTIOC6B
	GPT321_GTICLF_ICLFSELD_0x0D = 0xd
	// GTIOC7A
	GPT321_GTICLF_ICLFSELD_0x0E = 0xe
	// GTIOC7B
	GPT321_GTICLF_ICLFSELD_0x0F = 0xf
	// GTIOC8A
	GPT321_GTICLF_ICLFSELD_0x10 = 0x10
	// GTIOC8B
	GPT321_GTICLF_ICLFSELD_0x11 = 0x11
	// GTIOC9A
	GPT321_GTICLF_ICLFSELD_0x12 = 0x12
	// GTIOC9B
	GPT321_GTICLF_ICLFSELD_0x13 = 0x13

	// GTPC: General PWM Timer Period Count Register
	// Position of PCEN field.
	GPT321_GTPC_PCEN_Pos = 0x0
	// Bit mask of PCEN field.
	GPT321_GTPC_PCEN_Msk = 0x1
	// Bit PCEN.
	GPT321_GTPC_PCEN = 0x1
	// Period count function is disabled
	GPT321_GTPC_PCEN_0 = 0x0
	// Period count function is enabled
	GPT321_GTPC_PCEN_1 = 0x1
	// Position of ASTP field.
	GPT321_GTPC_ASTP_Pos = 0x8
	// Bit mask of ASTP field.
	GPT321_GTPC_ASTP_Msk = 0x100
	// Bit ASTP.
	GPT321_GTPC_ASTP = 0x100
	// Automatic stop function is disabled
	GPT321_GTPC_ASTP_0 = 0x0
	// Automatic stop function is enabled
	GPT321_GTPC_ASTP_1 = 0x1
	// Position of PCNT field.
	GPT321_GTPC_PCNT_Pos = 0x10
	// Bit mask of PCNT field.
	GPT321_GTPC_PCNT_Msk = 0xfff0000

	// GTSECSR: General PWM Timer Operation Enable Bit Simultaneous Control Channel Select Register
	// Position of SECSEL0 field.
	GPT321_GTSECSR_SECSEL0_Pos = 0x0
	// Bit mask of SECSEL0 field.
	GPT321_GTSECSR_SECSEL0_Msk = 0x1
	// Bit SECSEL0.
	GPT321_GTSECSR_SECSEL0 = 0x1
	// Disable simultaneous control
	GPT321_GTSECSR_SECSEL0_0 = 0x0
	// Enable simultaneous control
	GPT321_GTSECSR_SECSEL0_1 = 0x1
	// Position of SECSEL1 field.
	GPT321_GTSECSR_SECSEL1_Pos = 0x1
	// Bit mask of SECSEL1 field.
	GPT321_GTSECSR_SECSEL1_Msk = 0x2
	// Bit SECSEL1.
	GPT321_GTSECSR_SECSEL1 = 0x2
	// Disable simultaneous control
	GPT321_GTSECSR_SECSEL1_0 = 0x0
	// Enable simultaneous control
	GPT321_GTSECSR_SECSEL1_1 = 0x1
	// Position of SECSEL2 field.
	GPT321_GTSECSR_SECSEL2_Pos = 0x2
	// Bit mask of SECSEL2 field.
	GPT321_GTSECSR_SECSEL2_Msk = 0x4
	// Bit SECSEL2.
	GPT321_GTSECSR_SECSEL2 = 0x4
	// Disable simultaneous control
	GPT321_GTSECSR_SECSEL2_0 = 0x0
	// Enable simultaneous control
	GPT321_GTSECSR_SECSEL2_1 = 0x1
	// Position of SECSEL3 field.
	GPT321_GTSECSR_SECSEL3_Pos = 0x3
	// Bit mask of SECSEL3 field.
	GPT321_GTSECSR_SECSEL3_Msk = 0x8
	// Bit SECSEL3.
	GPT321_GTSECSR_SECSEL3 = 0x8
	// Disable simultaneous control
	GPT321_GTSECSR_SECSEL3_0 = 0x0
	// Enable simultaneous control
	GPT321_GTSECSR_SECSEL3_1 = 0x1
	// Position of SECSEL4 field.
	GPT321_GTSECSR_SECSEL4_Pos = 0x4
	// Bit mask of SECSEL4 field.
	GPT321_GTSECSR_SECSEL4_Msk = 0x10
	// Bit SECSEL4.
	GPT321_GTSECSR_SECSEL4 = 0x10
	// Disable simultaneous control
	GPT321_GTSECSR_SECSEL4_0 = 0x0
	// Enable simultaneous control
	GPT321_GTSECSR_SECSEL4_1 = 0x1
	// Position of SECSEL5 field.
	GPT321_GTSECSR_SECSEL5_Pos = 0x5
	// Bit mask of SECSEL5 field.
	GPT321_GTSECSR_SECSEL5_Msk = 0x20
	// Bit SECSEL5.
	GPT321_GTSECSR_SECSEL5 = 0x20
	// Disable simultaneous control
	GPT321_GTSECSR_SECSEL5_0 = 0x0
	// Enable simultaneous control
	GPT321_GTSECSR_SECSEL5_1 = 0x1
	// Position of SECSEL6 field.
	GPT321_GTSECSR_SECSEL6_Pos = 0x6
	// Bit mask of SECSEL6 field.
	GPT321_GTSECSR_SECSEL6_Msk = 0x40
	// Bit SECSEL6.
	GPT321_GTSECSR_SECSEL6 = 0x40
	// Disable simultaneous control
	GPT321_GTSECSR_SECSEL6_0 = 0x0
	// Enable simultaneous control
	GPT321_GTSECSR_SECSEL6_1 = 0x1
	// Position of SECSEL7 field.
	GPT321_GTSECSR_SECSEL7_Pos = 0x7
	// Bit mask of SECSEL7 field.
	GPT321_GTSECSR_SECSEL7_Msk = 0x80
	// Bit SECSEL7.
	GPT321_GTSECSR_SECSEL7 = 0x80
	// Disable simultaneous control
	GPT321_GTSECSR_SECSEL7_0 = 0x0
	// Enable simultaneous control
	GPT321_GTSECSR_SECSEL7_1 = 0x1
	// Position of SECSEL8 field.
	GPT321_GTSECSR_SECSEL8_Pos = 0x8
	// Bit mask of SECSEL8 field.
	GPT321_GTSECSR_SECSEL8_Msk = 0x100
	// Bit SECSEL8.
	GPT321_GTSECSR_SECSEL8 = 0x100
	// Disable simultaneous control
	GPT321_GTSECSR_SECSEL8_0 = 0x0
	// Enable simultaneous control
	GPT321_GTSECSR_SECSEL8_1 = 0x1
	// Position of SECSEL9 field.
	GPT321_GTSECSR_SECSEL9_Pos = 0x9
	// Bit mask of SECSEL9 field.
	GPT321_GTSECSR_SECSEL9_Msk = 0x200
	// Bit SECSEL9.
	GPT321_GTSECSR_SECSEL9 = 0x200
	// Disable simultaneous control
	GPT321_GTSECSR_SECSEL9_0 = 0x0
	// Enable simultaneous control
	GPT321_GTSECSR_SECSEL9_1 = 0x1

	// GTSECR: General PWM Timer Operation Enable Bit Simultaneous Control Register
	// Position of SBDCE field.
	GPT321_GTSECR_SBDCE_Pos = 0x0
	// Bit mask of SBDCE field.
	GPT321_GTSECR_SBDCE_Msk = 0x1
	// Bit SBDCE.
	GPT321_GTSECR_SBDCE = 0x1
	// Disable simultaneous enabling GTCCR buffer operations
	GPT321_GTSECR_SBDCE_0 = 0x0
	// Enable GTCCR register buffer operations simultaneously
	GPT321_GTSECR_SBDCE_1 = 0x1
	// Position of SBDPE field.
	GPT321_GTSECR_SBDPE_Pos = 0x1
	// Bit mask of SBDPE field.
	GPT321_GTSECR_SBDPE_Msk = 0x2
	// Bit SBDPE.
	GPT321_GTSECR_SBDPE = 0x2
	// Disable simultaneous enabling GTPR buffer operations
	GPT321_GTSECR_SBDPE_0 = 0x0
	// Enable GTPR register buffer operations simultaneously
	GPT321_GTSECR_SBDPE_1 = 0x1
	// Position of SBDCD field.
	GPT321_GTSECR_SBDCD_Pos = 0x8
	// Bit mask of SBDCD field.
	GPT321_GTSECR_SBDCD_Msk = 0x100
	// Bit SBDCD.
	GPT321_GTSECR_SBDCD = 0x100
	// Disable simultaneous disabling GTCCR buffer operations
	GPT321_GTSECR_SBDCD_0 = 0x0
	// Disable GTCCR register buffer operations simultaneously
	GPT321_GTSECR_SBDCD_1 = 0x1
	// Position of SBDPD field.
	GPT321_GTSECR_SBDPD_Pos = 0x9
	// Bit mask of SBDPD field.
	GPT321_GTSECR_SBDPD_Msk = 0x200
	// Bit SBDPD.
	GPT321_GTSECR_SBDPD = 0x200
	// Disable simultaneous disabling GTPR buffer operations
	GPT321_GTSECR_SBDPD_0 = 0x0
	// Disable GTPR register buffer operations simultaneously
	GPT321_GTSECR_SBDPD_1 = 0x1
	// Position of SPCE field.
	GPT321_GTSECR_SPCE_Pos = 0x10
	// Bit mask of SPCE field.
	GPT321_GTSECR_SPCE_Msk = 0x10000
	// Bit SPCE.
	GPT321_GTSECR_SPCE = 0x10000
	// Disable simultaneous enabling period count function
	GPT321_GTSECR_SPCE_0 = 0x0
	// Enable period count function simultaneously
	GPT321_GTSECR_SPCE_1 = 0x1
	// Position of SPCD field.
	GPT321_GTSECR_SPCD_Pos = 0x18
	// Bit mask of SPCD field.
	GPT321_GTSECR_SPCD_Msk = 0x1000000
	// Bit SPCD.
	GPT321_GTSECR_SPCD = 0x1000000
	// Disable simultaneous disabling period count function
	GPT321_GTSECR_SPCD_0 = 0x0
	// Disable period count function simultaneously
	GPT321_GTSECR_SPCD_1 = 0x1
)

// Constants for GPT164: General PWM 16-bit Timer 4
const (
	// GTWP: General PWM Timer Write-Protection Register
	// Position of WP field.
	GPT164_GTWP_WP_Pos = 0x0
	// Bit mask of WP field.
	GPT164_GTWP_WP_Msk = 0x1
	// Bit WP.
	GPT164_GTWP_WP = 0x1
	// Write to the register enabled
	GPT164_GTWP_WP_0 = 0x0
	// Write to the register disabled
	GPT164_GTWP_WP_1 = 0x1
	// Position of STRWP field.
	GPT164_GTWP_STRWP_Pos = 0x1
	// Bit mask of STRWP field.
	GPT164_GTWP_STRWP_Msk = 0x2
	// Bit STRWP.
	GPT164_GTWP_STRWP = 0x2
	// Write to the bit is enabled
	GPT164_GTWP_STRWP_0 = 0x0
	// Write to the bit is disabled
	GPT164_GTWP_STRWP_1 = 0x1
	// Position of STPWP field.
	GPT164_GTWP_STPWP_Pos = 0x2
	// Bit mask of STPWP field.
	GPT164_GTWP_STPWP_Msk = 0x4
	// Bit STPWP.
	GPT164_GTWP_STPWP = 0x4
	// Write to the bit is enabled
	GPT164_GTWP_STPWP_0 = 0x0
	// Write to the bit is disabled
	GPT164_GTWP_STPWP_1 = 0x1
	// Position of CLRWP field.
	GPT164_GTWP_CLRWP_Pos = 0x3
	// Bit mask of CLRWP field.
	GPT164_GTWP_CLRWP_Msk = 0x8
	// Bit CLRWP.
	GPT164_GTWP_CLRWP = 0x8
	// Write to the bit is enabled
	GPT164_GTWP_CLRWP_0 = 0x0
	// Write to the bit is disabled
	GPT164_GTWP_CLRWP_1 = 0x1
	// Position of CMNWP field.
	GPT164_GTWP_CMNWP_Pos = 0x4
	// Bit mask of CMNWP field.
	GPT164_GTWP_CMNWP_Msk = 0x10
	// Bit CMNWP.
	GPT164_GTWP_CMNWP = 0x10
	// Write to the register is enabled
	GPT164_GTWP_CMNWP_0 = 0x0
	// Write to the register is disabled
	GPT164_GTWP_CMNWP_1 = 0x1
	// Position of PRKEY field.
	GPT164_GTWP_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	GPT164_GTWP_PRKEY_Msk = 0xff00

	// GTSTR: General PWM Timer Software Start Register
	// Position of CSTRT0 field.
	GPT164_GTSTR_CSTRT0_Pos = 0x0
	// Bit mask of CSTRT0 field.
	GPT164_GTSTR_CSTRT0_Msk = 0x1
	// Bit CSTRT0.
	GPT164_GTSTR_CSTRT0 = 0x1
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT0_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT0_1 = 0x1
	// Position of CSTRT1 field.
	GPT164_GTSTR_CSTRT1_Pos = 0x1
	// Bit mask of CSTRT1 field.
	GPT164_GTSTR_CSTRT1_Msk = 0x2
	// Bit CSTRT1.
	GPT164_GTSTR_CSTRT1 = 0x2
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT1_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT1_1 = 0x1
	// Position of CSTRT2 field.
	GPT164_GTSTR_CSTRT2_Pos = 0x2
	// Bit mask of CSTRT2 field.
	GPT164_GTSTR_CSTRT2_Msk = 0x4
	// Bit CSTRT2.
	GPT164_GTSTR_CSTRT2 = 0x4
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT2_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT2_1 = 0x1
	// Position of CSTRT3 field.
	GPT164_GTSTR_CSTRT3_Pos = 0x3
	// Bit mask of CSTRT3 field.
	GPT164_GTSTR_CSTRT3_Msk = 0x8
	// Bit CSTRT3.
	GPT164_GTSTR_CSTRT3 = 0x8
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT3_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT3_1 = 0x1
	// Position of CSTRT4 field.
	GPT164_GTSTR_CSTRT4_Pos = 0x4
	// Bit mask of CSTRT4 field.
	GPT164_GTSTR_CSTRT4_Msk = 0x10
	// Bit CSTRT4.
	GPT164_GTSTR_CSTRT4 = 0x10
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT4_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT4_1 = 0x1
	// Position of CSTRT5 field.
	GPT164_GTSTR_CSTRT5_Pos = 0x5
	// Bit mask of CSTRT5 field.
	GPT164_GTSTR_CSTRT5_Msk = 0x20
	// Bit CSTRT5.
	GPT164_GTSTR_CSTRT5 = 0x20
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT5_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT5_1 = 0x1
	// Position of CSTRT6 field.
	GPT164_GTSTR_CSTRT6_Pos = 0x6
	// Bit mask of CSTRT6 field.
	GPT164_GTSTR_CSTRT6_Msk = 0x40
	// Bit CSTRT6.
	GPT164_GTSTR_CSTRT6 = 0x40
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT6_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT6_1 = 0x1
	// Position of CSTRT7 field.
	GPT164_GTSTR_CSTRT7_Pos = 0x7
	// Bit mask of CSTRT7 field.
	GPT164_GTSTR_CSTRT7_Msk = 0x80
	// Bit CSTRT7.
	GPT164_GTSTR_CSTRT7 = 0x80
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT7_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT7_1 = 0x1
	// Position of CSTRT8 field.
	GPT164_GTSTR_CSTRT8_Pos = 0x8
	// Bit mask of CSTRT8 field.
	GPT164_GTSTR_CSTRT8_Msk = 0x100
	// Bit CSTRT8.
	GPT164_GTSTR_CSTRT8 = 0x100
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT8_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT8_1 = 0x1
	// Position of CSTRT9 field.
	GPT164_GTSTR_CSTRT9_Pos = 0x9
	// Bit mask of CSTRT9 field.
	GPT164_GTSTR_CSTRT9_Msk = 0x200
	// Bit CSTRT9.
	GPT164_GTSTR_CSTRT9 = 0x200
	// GTCNT counter not start
	GPT164_GTSTR_CSTRT9_0 = 0x0
	// GTCNT counter start
	GPT164_GTSTR_CSTRT9_1 = 0x1

	// GTSTP: General PWM Timer Software Stop Register
	// Position of CSTOP0 field.
	GPT164_GTSTP_CSTOP0_Pos = 0x0
	// Bit mask of CSTOP0 field.
	GPT164_GTSTP_CSTOP0_Msk = 0x1
	// Bit CSTOP0.
	GPT164_GTSTP_CSTOP0 = 0x1
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP0_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP0_1 = 0x1
	// Position of CSTOP1 field.
	GPT164_GTSTP_CSTOP1_Pos = 0x1
	// Bit mask of CSTOP1 field.
	GPT164_GTSTP_CSTOP1_Msk = 0x2
	// Bit CSTOP1.
	GPT164_GTSTP_CSTOP1 = 0x2
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP1_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP1_1 = 0x1
	// Position of CSTOP2 field.
	GPT164_GTSTP_CSTOP2_Pos = 0x2
	// Bit mask of CSTOP2 field.
	GPT164_GTSTP_CSTOP2_Msk = 0x4
	// Bit CSTOP2.
	GPT164_GTSTP_CSTOP2 = 0x4
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP2_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP2_1 = 0x1
	// Position of CSTOP3 field.
	GPT164_GTSTP_CSTOP3_Pos = 0x3
	// Bit mask of CSTOP3 field.
	GPT164_GTSTP_CSTOP3_Msk = 0x8
	// Bit CSTOP3.
	GPT164_GTSTP_CSTOP3 = 0x8
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP3_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP3_1 = 0x1
	// Position of CSTOP4 field.
	GPT164_GTSTP_CSTOP4_Pos = 0x4
	// Bit mask of CSTOP4 field.
	GPT164_GTSTP_CSTOP4_Msk = 0x10
	// Bit CSTOP4.
	GPT164_GTSTP_CSTOP4 = 0x10
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP4_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP4_1 = 0x1
	// Position of CSTOP5 field.
	GPT164_GTSTP_CSTOP5_Pos = 0x5
	// Bit mask of CSTOP5 field.
	GPT164_GTSTP_CSTOP5_Msk = 0x20
	// Bit CSTOP5.
	GPT164_GTSTP_CSTOP5 = 0x20
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP5_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP5_1 = 0x1
	// Position of CSTOP6 field.
	GPT164_GTSTP_CSTOP6_Pos = 0x6
	// Bit mask of CSTOP6 field.
	GPT164_GTSTP_CSTOP6_Msk = 0x40
	// Bit CSTOP6.
	GPT164_GTSTP_CSTOP6 = 0x40
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP6_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP6_1 = 0x1
	// Position of CSTOP7 field.
	GPT164_GTSTP_CSTOP7_Pos = 0x7
	// Bit mask of CSTOP7 field.
	GPT164_GTSTP_CSTOP7_Msk = 0x80
	// Bit CSTOP7.
	GPT164_GTSTP_CSTOP7 = 0x80
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP7_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP7_1 = 0x1
	// Position of CSTOP8 field.
	GPT164_GTSTP_CSTOP8_Pos = 0x8
	// Bit mask of CSTOP8 field.
	GPT164_GTSTP_CSTOP8_Msk = 0x100
	// Bit CSTOP8.
	GPT164_GTSTP_CSTOP8 = 0x100
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP8_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP8_1 = 0x1
	// Position of CSTOP9 field.
	GPT164_GTSTP_CSTOP9_Pos = 0x9
	// Bit mask of CSTOP9 field.
	GPT164_GTSTP_CSTOP9_Msk = 0x200
	// Bit CSTOP9.
	GPT164_GTSTP_CSTOP9 = 0x200
	// GTCNT counter not stop
	GPT164_GTSTP_CSTOP9_0 = 0x0
	// GTCNT counter stop
	GPT164_GTSTP_CSTOP9_1 = 0x1

	// GTCLR: General PWM Timer Software Clear Register
	// Position of CCLR0 field.
	GPT164_GTCLR_CCLR0_Pos = 0x0
	// Bit mask of CCLR0 field.
	GPT164_GTCLR_CCLR0_Msk = 0x1
	// Bit CCLR0.
	GPT164_GTCLR_CCLR0 = 0x1
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR0_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR0_1 = 0x1
	// Position of CCLR1 field.
	GPT164_GTCLR_CCLR1_Pos = 0x1
	// Bit mask of CCLR1 field.
	GPT164_GTCLR_CCLR1_Msk = 0x2
	// Bit CCLR1.
	GPT164_GTCLR_CCLR1 = 0x2
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR1_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR1_1 = 0x1
	// Position of CCLR2 field.
	GPT164_GTCLR_CCLR2_Pos = 0x2
	// Bit mask of CCLR2 field.
	GPT164_GTCLR_CCLR2_Msk = 0x4
	// Bit CCLR2.
	GPT164_GTCLR_CCLR2 = 0x4
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR2_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR2_1 = 0x1
	// Position of CCLR3 field.
	GPT164_GTCLR_CCLR3_Pos = 0x3
	// Bit mask of CCLR3 field.
	GPT164_GTCLR_CCLR3_Msk = 0x8
	// Bit CCLR3.
	GPT164_GTCLR_CCLR3 = 0x8
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR3_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR3_1 = 0x1
	// Position of CCLR4 field.
	GPT164_GTCLR_CCLR4_Pos = 0x4
	// Bit mask of CCLR4 field.
	GPT164_GTCLR_CCLR4_Msk = 0x10
	// Bit CCLR4.
	GPT164_GTCLR_CCLR4 = 0x10
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR4_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR4_1 = 0x1
	// Position of CCLR5 field.
	GPT164_GTCLR_CCLR5_Pos = 0x5
	// Bit mask of CCLR5 field.
	GPT164_GTCLR_CCLR5_Msk = 0x20
	// Bit CCLR5.
	GPT164_GTCLR_CCLR5 = 0x20
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR5_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR5_1 = 0x1
	// Position of CCLR6 field.
	GPT164_GTCLR_CCLR6_Pos = 0x6
	// Bit mask of CCLR6 field.
	GPT164_GTCLR_CCLR6_Msk = 0x40
	// Bit CCLR6.
	GPT164_GTCLR_CCLR6 = 0x40
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR6_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR6_1 = 0x1
	// Position of CCLR7 field.
	GPT164_GTCLR_CCLR7_Pos = 0x7
	// Bit mask of CCLR7 field.
	GPT164_GTCLR_CCLR7_Msk = 0x80
	// Bit CCLR7.
	GPT164_GTCLR_CCLR7 = 0x80
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR7_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR7_1 = 0x1
	// Position of CCLR8 field.
	GPT164_GTCLR_CCLR8_Pos = 0x8
	// Bit mask of CCLR8 field.
	GPT164_GTCLR_CCLR8_Msk = 0x100
	// Bit CCLR8.
	GPT164_GTCLR_CCLR8 = 0x100
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR8_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR8_1 = 0x1
	// Position of CCLR9 field.
	GPT164_GTCLR_CCLR9_Pos = 0x9
	// Bit mask of CCLR9 field.
	GPT164_GTCLR_CCLR9_Msk = 0x200
	// Bit CCLR9.
	GPT164_GTCLR_CCLR9 = 0x200
	// GTCNT counter is not cleared
	GPT164_GTCLR_CCLR9_0 = 0x0
	// GTCNT counter is cleared
	GPT164_GTCLR_CCLR9_1 = 0x1

	// GTSSR: General PWM Timer Start Source Select Register
	// Position of SSGTRGAR field.
	GPT164_GTSSR_SSGTRGAR_Pos = 0x0
	// Bit mask of SSGTRGAR field.
	GPT164_GTSSR_SSGTRGAR_Msk = 0x1
	// Bit SSGTRGAR.
	GPT164_GTSSR_SSGTRGAR = 0x1
	// Counter start disabled on the rising edge of GTETRGA input
	GPT164_GTSSR_SSGTRGAR_0 = 0x0
	// Counter start enabled on the rising edge of GTETRGA input
	GPT164_GTSSR_SSGTRGAR_1 = 0x1
	// Position of SSGTRGAF field.
	GPT164_GTSSR_SSGTRGAF_Pos = 0x1
	// Bit mask of SSGTRGAF field.
	GPT164_GTSSR_SSGTRGAF_Msk = 0x2
	// Bit SSGTRGAF.
	GPT164_GTSSR_SSGTRGAF = 0x2
	// Counter start disabled on the falling edge of GTETRGA input
	GPT164_GTSSR_SSGTRGAF_0 = 0x0
	// Counter start enabled on the falling edge of GTETRGA input
	GPT164_GTSSR_SSGTRGAF_1 = 0x1
	// Position of SSGTRGBR field.
	GPT164_GTSSR_SSGTRGBR_Pos = 0x2
	// Bit mask of SSGTRGBR field.
	GPT164_GTSSR_SSGTRGBR_Msk = 0x4
	// Bit SSGTRGBR.
	GPT164_GTSSR_SSGTRGBR = 0x4
	// Counter start disabled on the rising edge of GTETRGB input
	GPT164_GTSSR_SSGTRGBR_0 = 0x0
	// Counter start enabled on the rising edge of GTETRGB input
	GPT164_GTSSR_SSGTRGBR_1 = 0x1
	// Position of SSGTRGBF field.
	GPT164_GTSSR_SSGTRGBF_Pos = 0x3
	// Bit mask of SSGTRGBF field.
	GPT164_GTSSR_SSGTRGBF_Msk = 0x8
	// Bit SSGTRGBF.
	GPT164_GTSSR_SSGTRGBF = 0x8
	// Counter start disabled on the falling edge of GTETRGB input
	GPT164_GTSSR_SSGTRGBF_0 = 0x0
	// Counter start enabled on the falling edge of GTETRGB input
	GPT164_GTSSR_SSGTRGBF_1 = 0x1
	// Position of SSGTRGCR field.
	GPT164_GTSSR_SSGTRGCR_Pos = 0x4
	// Bit mask of SSGTRGCR field.
	GPT164_GTSSR_SSGTRGCR_Msk = 0x10
	// Bit SSGTRGCR.
	GPT164_GTSSR_SSGTRGCR = 0x10
	// Counter start disabled on the rising edge of GTETRGC input
	GPT164_GTSSR_SSGTRGCR_0 = 0x0
	// Counter start enabled on the rising edge of GTETRGC input
	GPT164_GTSSR_SSGTRGCR_1 = 0x1
	// Position of SSGTRGCF field.
	GPT164_GTSSR_SSGTRGCF_Pos = 0x5
	// Bit mask of SSGTRGCF field.
	GPT164_GTSSR_SSGTRGCF_Msk = 0x20
	// Bit SSGTRGCF.
	GPT164_GTSSR_SSGTRGCF = 0x20
	// Counter start disabled on the falling edge of GTETRGC input
	GPT164_GTSSR_SSGTRGCF_0 = 0x0
	// Counter start enabled on the falling edge of GTETRGC input
	GPT164_GTSSR_SSGTRGCF_1 = 0x1
	// Position of SSGTRGDR field.
	GPT164_GTSSR_SSGTRGDR_Pos = 0x6
	// Bit mask of SSGTRGDR field.
	GPT164_GTSSR_SSGTRGDR_Msk = 0x40
	// Bit SSGTRGDR.
	GPT164_GTSSR_SSGTRGDR = 0x40
	// Counter start disabled on the rising edge of GTETRGD input
	GPT164_GTSSR_SSGTRGDR_0 = 0x0
	// Counter start enabled on the rising edge of GTETRGD input
	GPT164_GTSSR_SSGTRGDR_1 = 0x1
	// Position of SSGTRGDF field.
	GPT164_GTSSR_SSGTRGDF_Pos = 0x7
	// Bit mask of SSGTRGDF field.
	GPT164_GTSSR_SSGTRGDF_Msk = 0x80
	// Bit SSGTRGDF.
	GPT164_GTSSR_SSGTRGDF = 0x80
	// Counter start disabled on the falling edge of GTETRGD input
	GPT164_GTSSR_SSGTRGDF_0 = 0x0
	// Counter start enabled on the falling edge of GTETRGD input
	GPT164_GTSSR_SSGTRGDF_1 = 0x1
	// Position of SSCARBL field.
	GPT164_GTSSR_SSCARBL_Pos = 0x8
	// Bit mask of SSCARBL field.
	GPT164_GTSSR_SSCARBL_Msk = 0x100
	// Bit SSCARBL.
	GPT164_GTSSR_SSCARBL = 0x100
	// Counter start disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTSSR_SSCARBL_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTSSR_SSCARBL_1 = 0x1
	// Position of SSCARBH field.
	GPT164_GTSSR_SSCARBH_Pos = 0x9
	// Bit mask of SSCARBH field.
	GPT164_GTSSR_SSCARBH_Msk = 0x200
	// Bit SSCARBH.
	GPT164_GTSSR_SSCARBH = 0x200
	// Counter start disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTSSR_SSCARBH_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTSSR_SSCARBH_1 = 0x1
	// Position of SSCAFBL field.
	GPT164_GTSSR_SSCAFBL_Pos = 0xa
	// Bit mask of SSCAFBL field.
	GPT164_GTSSR_SSCAFBL_Msk = 0x400
	// Bit SSCAFBL.
	GPT164_GTSSR_SSCAFBL = 0x400
	// Counter start disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTSSR_SSCAFBL_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTSSR_SSCAFBL_1 = 0x1
	// Position of SSCAFBH field.
	GPT164_GTSSR_SSCAFBH_Pos = 0xb
	// Bit mask of SSCAFBH field.
	GPT164_GTSSR_SSCAFBH_Msk = 0x800
	// Bit SSCAFBH.
	GPT164_GTSSR_SSCAFBH = 0x800
	// Counter start disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTSSR_SSCAFBH_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTSSR_SSCAFBH_1 = 0x1
	// Position of SSCBRAL field.
	GPT164_GTSSR_SSCBRAL_Pos = 0xc
	// Bit mask of SSCBRAL field.
	GPT164_GTSSR_SSCBRAL_Msk = 0x1000
	// Bit SSCBRAL.
	GPT164_GTSSR_SSCBRAL = 0x1000
	// Counter start disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTSSR_SSCBRAL_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTSSR_SSCBRAL_1 = 0x1
	// Position of SSCBRAH field.
	GPT164_GTSSR_SSCBRAH_Pos = 0xd
	// Bit mask of SSCBRAH field.
	GPT164_GTSSR_SSCBRAH_Msk = 0x2000
	// Bit SSCBRAH.
	GPT164_GTSSR_SSCBRAH = 0x2000
	// Counter start disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTSSR_SSCBRAH_0 = 0x0
	// Counter start enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTSSR_SSCBRAH_1 = 0x1
	// Position of SSCBFAL field.
	GPT164_GTSSR_SSCBFAL_Pos = 0xe
	// Bit mask of SSCBFAL field.
	GPT164_GTSSR_SSCBFAL_Msk = 0x4000
	// Bit SSCBFAL.
	GPT164_GTSSR_SSCBFAL = 0x4000
	// Counter start disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTSSR_SSCBFAL_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTSSR_SSCBFAL_1 = 0x1
	// Position of SSCBFAH field.
	GPT164_GTSSR_SSCBFAH_Pos = 0xf
	// Bit mask of SSCBFAH field.
	GPT164_GTSSR_SSCBFAH_Msk = 0x8000
	// Bit SSCBFAH.
	GPT164_GTSSR_SSCBFAH = 0x8000
	// Counter start disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTSSR_SSCBFAH_0 = 0x0
	// Counter start enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTSSR_SSCBFAH_1 = 0x1
	// Position of SSELCA field.
	GPT164_GTSSR_SSELCA_Pos = 0x10
	// Bit mask of SSELCA field.
	GPT164_GTSSR_SSELCA_Msk = 0x10000
	// Bit SSELCA.
	GPT164_GTSSR_SSELCA = 0x10000
	// Counter start disabled at the ELC_GPTA input
	GPT164_GTSSR_SSELCA_0 = 0x0
	// Counter start enabled at the ELC_GPTA input
	GPT164_GTSSR_SSELCA_1 = 0x1
	// Position of SSELCB field.
	GPT164_GTSSR_SSELCB_Pos = 0x11
	// Bit mask of SSELCB field.
	GPT164_GTSSR_SSELCB_Msk = 0x20000
	// Bit SSELCB.
	GPT164_GTSSR_SSELCB = 0x20000
	// Counter start disabled at the ELC_GPTB input
	GPT164_GTSSR_SSELCB_0 = 0x0
	// Counter start enabled at the ELC_GPTB input
	GPT164_GTSSR_SSELCB_1 = 0x1
	// Position of SSELCC field.
	GPT164_GTSSR_SSELCC_Pos = 0x12
	// Bit mask of SSELCC field.
	GPT164_GTSSR_SSELCC_Msk = 0x40000
	// Bit SSELCC.
	GPT164_GTSSR_SSELCC = 0x40000
	// Counter start disabled at the ELC_GPTC input
	GPT164_GTSSR_SSELCC_0 = 0x0
	// Counter start enabled at the ELC_GPTC input
	GPT164_GTSSR_SSELCC_1 = 0x1
	// Position of SSELCD field.
	GPT164_GTSSR_SSELCD_Pos = 0x13
	// Bit mask of SSELCD field.
	GPT164_GTSSR_SSELCD_Msk = 0x80000
	// Bit SSELCD.
	GPT164_GTSSR_SSELCD = 0x80000
	// Counter start disabled at the ELC_GPTD input
	GPT164_GTSSR_SSELCD_0 = 0x0
	// Counter start enabled at the ELC_GPTD input
	GPT164_GTSSR_SSELCD_1 = 0x1
	// Position of SSELCE field.
	GPT164_GTSSR_SSELCE_Pos = 0x14
	// Bit mask of SSELCE field.
	GPT164_GTSSR_SSELCE_Msk = 0x100000
	// Bit SSELCE.
	GPT164_GTSSR_SSELCE = 0x100000
	// Counter start disabled at the ELC_GPTE input
	GPT164_GTSSR_SSELCE_0 = 0x0
	// Counter start enabled at the ELC_GPTE input
	GPT164_GTSSR_SSELCE_1 = 0x1
	// Position of SSELCF field.
	GPT164_GTSSR_SSELCF_Pos = 0x15
	// Bit mask of SSELCF field.
	GPT164_GTSSR_SSELCF_Msk = 0x200000
	// Bit SSELCF.
	GPT164_GTSSR_SSELCF = 0x200000
	// Counter start disabled at the ELC_GPTF input
	GPT164_GTSSR_SSELCF_0 = 0x0
	// Counter start enabled at the ELC_GPTF input
	GPT164_GTSSR_SSELCF_1 = 0x1
	// Position of SSELCG field.
	GPT164_GTSSR_SSELCG_Pos = 0x16
	// Bit mask of SSELCG field.
	GPT164_GTSSR_SSELCG_Msk = 0x400000
	// Bit SSELCG.
	GPT164_GTSSR_SSELCG = 0x400000
	// Counter start disabled at the ELC_GPTG input
	GPT164_GTSSR_SSELCG_0 = 0x0
	// Counter start enabled at the ELC_GPTG input
	GPT164_GTSSR_SSELCG_1 = 0x1
	// Position of SSELCH field.
	GPT164_GTSSR_SSELCH_Pos = 0x17
	// Bit mask of SSELCH field.
	GPT164_GTSSR_SSELCH_Msk = 0x800000
	// Bit SSELCH.
	GPT164_GTSSR_SSELCH = 0x800000
	// Counter start disabled at the ELC_GPTH input
	GPT164_GTSSR_SSELCH_0 = 0x0
	// Counter start enabled at the ELC_GPTH input
	GPT164_GTSSR_SSELCH_1 = 0x1
	// Position of CSTRT field.
	GPT164_GTSSR_CSTRT_Pos = 0x1f
	// Bit mask of CSTRT field.
	GPT164_GTSSR_CSTRT_Msk = 0x80000000
	// Bit CSTRT.
	GPT164_GTSSR_CSTRT = 0x80000000
	// Counter start disabled by the GTSTR register
	GPT164_GTSSR_CSTRT_0 = 0x0
	// Counter start enabled by the GTSTR register
	GPT164_GTSSR_CSTRT_1 = 0x1

	// GTPSR: General PWM Timer Stop Source Select Register
	// Position of PSGTRGAR field.
	GPT164_GTPSR_PSGTRGAR_Pos = 0x0
	// Bit mask of PSGTRGAR field.
	GPT164_GTPSR_PSGTRGAR_Msk = 0x1
	// Bit PSGTRGAR.
	GPT164_GTPSR_PSGTRGAR = 0x1
	// Counter stop disabled on the rising edge of GTETRGA input
	GPT164_GTPSR_PSGTRGAR_0 = 0x0
	// Counter stop enabled on the rising edge of GTETRGA input
	GPT164_GTPSR_PSGTRGAR_1 = 0x1
	// Position of PSGTRGAF field.
	GPT164_GTPSR_PSGTRGAF_Pos = 0x1
	// Bit mask of PSGTRGAF field.
	GPT164_GTPSR_PSGTRGAF_Msk = 0x2
	// Bit PSGTRGAF.
	GPT164_GTPSR_PSGTRGAF = 0x2
	// Counter stop disabled on the falling edge of GTETRGA input
	GPT164_GTPSR_PSGTRGAF_0 = 0x0
	// Counter stop enabled on the falling edge of GTETRGA input
	GPT164_GTPSR_PSGTRGAF_1 = 0x1
	// Position of PSGTRGBR field.
	GPT164_GTPSR_PSGTRGBR_Pos = 0x2
	// Bit mask of PSGTRGBR field.
	GPT164_GTPSR_PSGTRGBR_Msk = 0x4
	// Bit PSGTRGBR.
	GPT164_GTPSR_PSGTRGBR = 0x4
	// Counter stop disabled on the rising edge of GTETRGB input
	GPT164_GTPSR_PSGTRGBR_0 = 0x0
	// Counter stop enabled on the rising edge of GTETRGB input
	GPT164_GTPSR_PSGTRGBR_1 = 0x1
	// Position of PSGTRGBF field.
	GPT164_GTPSR_PSGTRGBF_Pos = 0x3
	// Bit mask of PSGTRGBF field.
	GPT164_GTPSR_PSGTRGBF_Msk = 0x8
	// Bit PSGTRGBF.
	GPT164_GTPSR_PSGTRGBF = 0x8
	// Counter stop disabled on the falling edge of GTETRGB input
	GPT164_GTPSR_PSGTRGBF_0 = 0x0
	// Counter stop enabled on the falling edge of GTETRGB input
	GPT164_GTPSR_PSGTRGBF_1 = 0x1
	// Position of PSGTRGCR field.
	GPT164_GTPSR_PSGTRGCR_Pos = 0x4
	// Bit mask of PSGTRGCR field.
	GPT164_GTPSR_PSGTRGCR_Msk = 0x10
	// Bit PSGTRGCR.
	GPT164_GTPSR_PSGTRGCR = 0x10
	// Counter stop disabled on the rising edge of GTETRGC input
	GPT164_GTPSR_PSGTRGCR_0 = 0x0
	// Counter stop enabled on the rising edge of GTETRGC input
	GPT164_GTPSR_PSGTRGCR_1 = 0x1
	// Position of PSGTRGCF field.
	GPT164_GTPSR_PSGTRGCF_Pos = 0x5
	// Bit mask of PSGTRGCF field.
	GPT164_GTPSR_PSGTRGCF_Msk = 0x20
	// Bit PSGTRGCF.
	GPT164_GTPSR_PSGTRGCF = 0x20
	// Counter stop disabled on the falling edge of GTETRGC input
	GPT164_GTPSR_PSGTRGCF_0 = 0x0
	// Counter stop enabled on the falling edge of GTETRGC input
	GPT164_GTPSR_PSGTRGCF_1 = 0x1
	// Position of PSGTRGDR field.
	GPT164_GTPSR_PSGTRGDR_Pos = 0x6
	// Bit mask of PSGTRGDR field.
	GPT164_GTPSR_PSGTRGDR_Msk = 0x40
	// Bit PSGTRGDR.
	GPT164_GTPSR_PSGTRGDR = 0x40
	// Counter stop disabled on the rising edge of GTETRGD input
	GPT164_GTPSR_PSGTRGDR_0 = 0x0
	// Counter stop enabled on the rising edge of GTETRGD input
	GPT164_GTPSR_PSGTRGDR_1 = 0x1
	// Position of PSGTRGDF field.
	GPT164_GTPSR_PSGTRGDF_Pos = 0x7
	// Bit mask of PSGTRGDF field.
	GPT164_GTPSR_PSGTRGDF_Msk = 0x80
	// Bit PSGTRGDF.
	GPT164_GTPSR_PSGTRGDF = 0x80
	// Counter stop disabled on the falling edge of GTETRGD input
	GPT164_GTPSR_PSGTRGDF_0 = 0x0
	// Counter stop enabled on the falling edge of GTETRGD input
	GPT164_GTPSR_PSGTRGDF_1 = 0x1
	// Position of PSCARBL field.
	GPT164_GTPSR_PSCARBL_Pos = 0x8
	// Bit mask of PSCARBL field.
	GPT164_GTPSR_PSCARBL_Msk = 0x100
	// Bit PSCARBL.
	GPT164_GTPSR_PSCARBL = 0x100
	// Counter stop disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTPSR_PSCARBL_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTPSR_PSCARBL_1 = 0x1
	// Position of PSCARBH field.
	GPT164_GTPSR_PSCARBH_Pos = 0x9
	// Bit mask of PSCARBH field.
	GPT164_GTPSR_PSCARBH_Msk = 0x200
	// Bit PSCARBH.
	GPT164_GTPSR_PSCARBH = 0x200
	// Counter stop disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTPSR_PSCARBH_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTPSR_PSCARBH_1 = 0x1
	// Position of PSCAFBL field.
	GPT164_GTPSR_PSCAFBL_Pos = 0xa
	// Bit mask of PSCAFBL field.
	GPT164_GTPSR_PSCAFBL_Msk = 0x400
	// Bit PSCAFBL.
	GPT164_GTPSR_PSCAFBL = 0x400
	// Counter stop disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTPSR_PSCAFBL_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTPSR_PSCAFBL_1 = 0x1
	// Position of PSCAFBH field.
	GPT164_GTPSR_PSCAFBH_Pos = 0xb
	// Bit mask of PSCAFBH field.
	GPT164_GTPSR_PSCAFBH_Msk = 0x800
	// Bit PSCAFBH.
	GPT164_GTPSR_PSCAFBH = 0x800
	// Counter stop disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTPSR_PSCAFBH_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTPSR_PSCAFBH_1 = 0x1
	// Position of PSCBRAL field.
	GPT164_GTPSR_PSCBRAL_Pos = 0xc
	// Bit mask of PSCBRAL field.
	GPT164_GTPSR_PSCBRAL_Msk = 0x1000
	// Bit PSCBRAL.
	GPT164_GTPSR_PSCBRAL = 0x1000
	// Counter stop disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTPSR_PSCBRAL_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTPSR_PSCBRAL_1 = 0x1
	// Position of PSCBRAH field.
	GPT164_GTPSR_PSCBRAH_Pos = 0xd
	// Bit mask of PSCBRAH field.
	GPT164_GTPSR_PSCBRAH_Msk = 0x2000
	// Bit PSCBRAH.
	GPT164_GTPSR_PSCBRAH = 0x2000
	// Counter stop disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTPSR_PSCBRAH_0 = 0x0
	// Counter stop enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTPSR_PSCBRAH_1 = 0x1
	// Position of PSCBFAL field.
	GPT164_GTPSR_PSCBFAL_Pos = 0xe
	// Bit mask of PSCBFAL field.
	GPT164_GTPSR_PSCBFAL_Msk = 0x4000
	// Bit PSCBFAL.
	GPT164_GTPSR_PSCBFAL = 0x4000
	// Counter stop disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTPSR_PSCBFAL_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTPSR_PSCBFAL_1 = 0x1
	// Position of PSCBFAH field.
	GPT164_GTPSR_PSCBFAH_Pos = 0xf
	// Bit mask of PSCBFAH field.
	GPT164_GTPSR_PSCBFAH_Msk = 0x8000
	// Bit PSCBFAH.
	GPT164_GTPSR_PSCBFAH = 0x8000
	// Counter stop disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTPSR_PSCBFAH_0 = 0x0
	// Counter stop enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTPSR_PSCBFAH_1 = 0x1
	// Position of PSELCA field.
	GPT164_GTPSR_PSELCA_Pos = 0x10
	// Bit mask of PSELCA field.
	GPT164_GTPSR_PSELCA_Msk = 0x10000
	// Bit PSELCA.
	GPT164_GTPSR_PSELCA = 0x10000
	// Counter stop disabled at the ELC_GPTA input
	GPT164_GTPSR_PSELCA_0 = 0x0
	// Counter stop enabled at the ELC_GPTA input
	GPT164_GTPSR_PSELCA_1 = 0x1
	// Position of PSELCB field.
	GPT164_GTPSR_PSELCB_Pos = 0x11
	// Bit mask of PSELCB field.
	GPT164_GTPSR_PSELCB_Msk = 0x20000
	// Bit PSELCB.
	GPT164_GTPSR_PSELCB = 0x20000
	// Counter stop disabled at the ELC_GPTB input
	GPT164_GTPSR_PSELCB_0 = 0x0
	// Counter stop enabled at the ELC_GPTB input
	GPT164_GTPSR_PSELCB_1 = 0x1
	// Position of PSELCC field.
	GPT164_GTPSR_PSELCC_Pos = 0x12
	// Bit mask of PSELCC field.
	GPT164_GTPSR_PSELCC_Msk = 0x40000
	// Bit PSELCC.
	GPT164_GTPSR_PSELCC = 0x40000
	// Counter stop disabled at the ELC_GPTC input
	GPT164_GTPSR_PSELCC_0 = 0x0
	// Counter stop enabled at the ELC_GPTC input
	GPT164_GTPSR_PSELCC_1 = 0x1
	// Position of PSELCD field.
	GPT164_GTPSR_PSELCD_Pos = 0x13
	// Bit mask of PSELCD field.
	GPT164_GTPSR_PSELCD_Msk = 0x80000
	// Bit PSELCD.
	GPT164_GTPSR_PSELCD = 0x80000
	// Counter stop disabled at the ELC_GPTD input
	GPT164_GTPSR_PSELCD_0 = 0x0
	// Counter stop enabled at the ELC_GPTD input
	GPT164_GTPSR_PSELCD_1 = 0x1
	// Position of PSELCE field.
	GPT164_GTPSR_PSELCE_Pos = 0x14
	// Bit mask of PSELCE field.
	GPT164_GTPSR_PSELCE_Msk = 0x100000
	// Bit PSELCE.
	GPT164_GTPSR_PSELCE = 0x100000
	// Counter stop disabled at the ELC_GPTE input
	GPT164_GTPSR_PSELCE_0 = 0x0
	// Counter stop enabled at the ELC_GPTE input
	GPT164_GTPSR_PSELCE_1 = 0x1
	// Position of PSELCF field.
	GPT164_GTPSR_PSELCF_Pos = 0x15
	// Bit mask of PSELCF field.
	GPT164_GTPSR_PSELCF_Msk = 0x200000
	// Bit PSELCF.
	GPT164_GTPSR_PSELCF = 0x200000
	// Counter stop disabled at the ELC_GPTF input
	GPT164_GTPSR_PSELCF_0 = 0x0
	// Counter stop enabled at the ELC_GPTF input
	GPT164_GTPSR_PSELCF_1 = 0x1
	// Position of PSELCG field.
	GPT164_GTPSR_PSELCG_Pos = 0x16
	// Bit mask of PSELCG field.
	GPT164_GTPSR_PSELCG_Msk = 0x400000
	// Bit PSELCG.
	GPT164_GTPSR_PSELCG = 0x400000
	// Counter stop disabled at the ELC_GPTG input
	GPT164_GTPSR_PSELCG_0 = 0x0
	// Counter stop enabled at the ELC_GPTG input
	GPT164_GTPSR_PSELCG_1 = 0x1
	// Position of PSELCH field.
	GPT164_GTPSR_PSELCH_Pos = 0x17
	// Bit mask of PSELCH field.
	GPT164_GTPSR_PSELCH_Msk = 0x800000
	// Bit PSELCH.
	GPT164_GTPSR_PSELCH = 0x800000
	// Counter stop disabled at the ELC_GPTH input
	GPT164_GTPSR_PSELCH_0 = 0x0
	// Counter stop enabled at the ELC_GPTH input
	GPT164_GTPSR_PSELCH_1 = 0x1
	// Position of CSTOP field.
	GPT164_GTPSR_CSTOP_Pos = 0x1f
	// Bit mask of CSTOP field.
	GPT164_GTPSR_CSTOP_Msk = 0x80000000
	// Bit CSTOP.
	GPT164_GTPSR_CSTOP = 0x80000000
	// Counter stop disabled by the GTSTP register
	GPT164_GTPSR_CSTOP_0 = 0x0
	// Counter stop enabled by the GTSTP register
	GPT164_GTPSR_CSTOP_1 = 0x1

	// GTCSR: General PWM Timer Clear Source Select Register
	// Position of CSGTRGAR field.
	GPT164_GTCSR_CSGTRGAR_Pos = 0x0
	// Bit mask of CSGTRGAR field.
	GPT164_GTCSR_CSGTRGAR_Msk = 0x1
	// Bit CSGTRGAR.
	GPT164_GTCSR_CSGTRGAR = 0x1
	// Counter clear disabled on the rising edge of GTETRGA input
	GPT164_GTCSR_CSGTRGAR_0 = 0x0
	// Counter clear enabled on the rising edge of GTETRGA input
	GPT164_GTCSR_CSGTRGAR_1 = 0x1
	// Position of CSGTRGAF field.
	GPT164_GTCSR_CSGTRGAF_Pos = 0x1
	// Bit mask of CSGTRGAF field.
	GPT164_GTCSR_CSGTRGAF_Msk = 0x2
	// Bit CSGTRGAF.
	GPT164_GTCSR_CSGTRGAF = 0x2
	// Counter clear disabled on the falling edge of GTETRGA input
	GPT164_GTCSR_CSGTRGAF_0 = 0x0
	// Counter clear enabled on the falling edge of GTETRGA input
	GPT164_GTCSR_CSGTRGAF_1 = 0x1
	// Position of CSGTRGBR field.
	GPT164_GTCSR_CSGTRGBR_Pos = 0x2
	// Bit mask of CSGTRGBR field.
	GPT164_GTCSR_CSGTRGBR_Msk = 0x4
	// Bit CSGTRGBR.
	GPT164_GTCSR_CSGTRGBR = 0x4
	// Disable counter clear on the rising edge of GTETRGB input
	GPT164_GTCSR_CSGTRGBR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGB input
	GPT164_GTCSR_CSGTRGBR_1 = 0x1
	// Position of CSGTRGBF field.
	GPT164_GTCSR_CSGTRGBF_Pos = 0x3
	// Bit mask of CSGTRGBF field.
	GPT164_GTCSR_CSGTRGBF_Msk = 0x8
	// Bit CSGTRGBF.
	GPT164_GTCSR_CSGTRGBF = 0x8
	// Counter clear disabled on the falling edge of GTETRGB input
	GPT164_GTCSR_CSGTRGBF_0 = 0x0
	// Counter clear enabled on the falling edge of GTETRGB input
	GPT164_GTCSR_CSGTRGBF_1 = 0x1
	// Position of CSGTRGCR field.
	GPT164_GTCSR_CSGTRGCR_Pos = 0x4
	// Bit mask of CSGTRGCR field.
	GPT164_GTCSR_CSGTRGCR_Msk = 0x10
	// Bit CSGTRGCR.
	GPT164_GTCSR_CSGTRGCR = 0x10
	// Disable counter clear on the rising edge of GTETRGC input
	GPT164_GTCSR_CSGTRGCR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGC input
	GPT164_GTCSR_CSGTRGCR_1 = 0x1
	// Position of CSGTRGCF field.
	GPT164_GTCSR_CSGTRGCF_Pos = 0x5
	// Bit mask of CSGTRGCF field.
	GPT164_GTCSR_CSGTRGCF_Msk = 0x20
	// Bit CSGTRGCF.
	GPT164_GTCSR_CSGTRGCF = 0x20
	// Counter clear disabled on the falling edge of GTETRGC input
	GPT164_GTCSR_CSGTRGCF_0 = 0x0
	// Counter clear enabled on the falling edge of GTETRGC input
	GPT164_GTCSR_CSGTRGCF_1 = 0x1
	// Position of CSGTRGDR field.
	GPT164_GTCSR_CSGTRGDR_Pos = 0x6
	// Bit mask of CSGTRGDR field.
	GPT164_GTCSR_CSGTRGDR_Msk = 0x40
	// Bit CSGTRGDR.
	GPT164_GTCSR_CSGTRGDR = 0x40
	// Disable counter clear on the rising edge of GTETRGD input
	GPT164_GTCSR_CSGTRGDR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGD input
	GPT164_GTCSR_CSGTRGDR_1 = 0x1
	// Position of CSGTRGDF field.
	GPT164_GTCSR_CSGTRGDF_Pos = 0x7
	// Bit mask of CSGTRGDF field.
	GPT164_GTCSR_CSGTRGDF_Msk = 0x80
	// Bit CSGTRGDF.
	GPT164_GTCSR_CSGTRGDF = 0x80
	// Counter clear disabled on the falling edge of GTETRGD input
	GPT164_GTCSR_CSGTRGDF_0 = 0x0
	// Counter clear enabled on the falling edge of GTETRGD input
	GPT164_GTCSR_CSGTRGDF_1 = 0x1
	// Position of CSCARBL field.
	GPT164_GTCSR_CSCARBL_Pos = 0x8
	// Bit mask of CSCARBL field.
	GPT164_GTCSR_CSCARBL_Msk = 0x100
	// Bit CSCARBL.
	GPT164_GTCSR_CSCARBL = 0x100
	// Counter clear disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTCSR_CSCARBL_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTCSR_CSCARBL_1 = 0x1
	// Position of CSCARBH field.
	GPT164_GTCSR_CSCARBH_Pos = 0x9
	// Bit mask of CSCARBH field.
	GPT164_GTCSR_CSCARBH_Msk = 0x200
	// Bit CSCARBH.
	GPT164_GTCSR_CSCARBH = 0x200
	// Counter clear disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTCSR_CSCARBH_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTCSR_CSCARBH_1 = 0x1
	// Position of CSCAFBL field.
	GPT164_GTCSR_CSCAFBL_Pos = 0xa
	// Bit mask of CSCAFBL field.
	GPT164_GTCSR_CSCAFBL_Msk = 0x400
	// Bit CSCAFBL.
	GPT164_GTCSR_CSCAFBL = 0x400
	// Counter clear disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTCSR_CSCAFBL_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTCSR_CSCAFBL_1 = 0x1
	// Position of CSCAFBH field.
	GPT164_GTCSR_CSCAFBH_Pos = 0xb
	// Bit mask of CSCAFBH field.
	GPT164_GTCSR_CSCAFBH_Msk = 0x800
	// Bit CSCAFBH.
	GPT164_GTCSR_CSCAFBH = 0x800
	// Counter clear disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTCSR_CSCAFBH_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTCSR_CSCAFBH_1 = 0x1
	// Position of CSCBRAL field.
	GPT164_GTCSR_CSCBRAL_Pos = 0xc
	// Bit mask of CSCBRAL field.
	GPT164_GTCSR_CSCBRAL_Msk = 0x1000
	// Bit CSCBRAL.
	GPT164_GTCSR_CSCBRAL = 0x1000
	// Counter clear disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTCSR_CSCBRAL_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTCSR_CSCBRAL_1 = 0x1
	// Position of CSCBRAH field.
	GPT164_GTCSR_CSCBRAH_Pos = 0xd
	// Bit mask of CSCBRAH field.
	GPT164_GTCSR_CSCBRAH_Msk = 0x2000
	// Bit CSCBRAH.
	GPT164_GTCSR_CSCBRAH = 0x2000
	// Counter clear disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTCSR_CSCBRAH_0 = 0x0
	// Counter clear enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTCSR_CSCBRAH_1 = 0x1
	// Position of CSCBFAL field.
	GPT164_GTCSR_CSCBFAL_Pos = 0xe
	// Bit mask of CSCBFAL field.
	GPT164_GTCSR_CSCBFAL_Msk = 0x4000
	// Bit CSCBFAL.
	GPT164_GTCSR_CSCBFAL = 0x4000
	// Counter clear disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTCSR_CSCBFAL_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTCSR_CSCBFAL_1 = 0x1
	// Position of CSCBFAH field.
	GPT164_GTCSR_CSCBFAH_Pos = 0xf
	// Bit mask of CSCBFAH field.
	GPT164_GTCSR_CSCBFAH_Msk = 0x8000
	// Bit CSCBFAH.
	GPT164_GTCSR_CSCBFAH = 0x8000
	// Counter clear disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTCSR_CSCBFAH_0 = 0x0
	// Counter clear enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTCSR_CSCBFAH_1 = 0x1
	// Position of CSELCA field.
	GPT164_GTCSR_CSELCA_Pos = 0x10
	// Bit mask of CSELCA field.
	GPT164_GTCSR_CSELCA_Msk = 0x10000
	// Bit CSELCA.
	GPT164_GTCSR_CSELCA = 0x10000
	// Counter clear disabled at the ELC_GPTA input
	GPT164_GTCSR_CSELCA_0 = 0x0
	// Counter clear enabled at the ELC_GPTA input
	GPT164_GTCSR_CSELCA_1 = 0x1
	// Position of CSELCB field.
	GPT164_GTCSR_CSELCB_Pos = 0x11
	// Bit mask of CSELCB field.
	GPT164_GTCSR_CSELCB_Msk = 0x20000
	// Bit CSELCB.
	GPT164_GTCSR_CSELCB = 0x20000
	// Counter clear disabled at the ELC_GPTB input
	GPT164_GTCSR_CSELCB_0 = 0x0
	// Counter clear enabled at the ELC_GPTB input
	GPT164_GTCSR_CSELCB_1 = 0x1
	// Position of CSELCC field.
	GPT164_GTCSR_CSELCC_Pos = 0x12
	// Bit mask of CSELCC field.
	GPT164_GTCSR_CSELCC_Msk = 0x40000
	// Bit CSELCC.
	GPT164_GTCSR_CSELCC = 0x40000
	// Counter clear disabled at the ELC_GPTC input
	GPT164_GTCSR_CSELCC_0 = 0x0
	// Counter clear enabled at the ELC_GPTC input
	GPT164_GTCSR_CSELCC_1 = 0x1
	// Position of CSELCD field.
	GPT164_GTCSR_CSELCD_Pos = 0x13
	// Bit mask of CSELCD field.
	GPT164_GTCSR_CSELCD_Msk = 0x80000
	// Bit CSELCD.
	GPT164_GTCSR_CSELCD = 0x80000
	// Counter clear disabled at the ELC_GPTD input
	GPT164_GTCSR_CSELCD_0 = 0x0
	// Counter clear enabled at the ELC_GPTD input
	GPT164_GTCSR_CSELCD_1 = 0x1
	// Position of CSELCE field.
	GPT164_GTCSR_CSELCE_Pos = 0x14
	// Bit mask of CSELCE field.
	GPT164_GTCSR_CSELCE_Msk = 0x100000
	// Bit CSELCE.
	GPT164_GTCSR_CSELCE = 0x100000
	// Counter clear disabled at the ELC_GPTE input
	GPT164_GTCSR_CSELCE_0 = 0x0
	// Counter clear enabled at the ELC_GPTE input
	GPT164_GTCSR_CSELCE_1 = 0x1
	// Position of CSELCF field.
	GPT164_GTCSR_CSELCF_Pos = 0x15
	// Bit mask of CSELCF field.
	GPT164_GTCSR_CSELCF_Msk = 0x200000
	// Bit CSELCF.
	GPT164_GTCSR_CSELCF = 0x200000
	// Counter clear disabled at the ELC_GPTF input
	GPT164_GTCSR_CSELCF_0 = 0x0
	// Counter clear enabled at the ELC_GPTF input
	GPT164_GTCSR_CSELCF_1 = 0x1
	// Position of CSELCG field.
	GPT164_GTCSR_CSELCG_Pos = 0x16
	// Bit mask of CSELCG field.
	GPT164_GTCSR_CSELCG_Msk = 0x400000
	// Bit CSELCG.
	GPT164_GTCSR_CSELCG = 0x400000
	// Counter clear disabled at the ELC_GPTG input
	GPT164_GTCSR_CSELCG_0 = 0x0
	// Counter clear enabled at the ELC_GPTG input
	GPT164_GTCSR_CSELCG_1 = 0x1
	// Position of CSELCH field.
	GPT164_GTCSR_CSELCH_Pos = 0x17
	// Bit mask of CSELCH field.
	GPT164_GTCSR_CSELCH_Msk = 0x800000
	// Bit CSELCH.
	GPT164_GTCSR_CSELCH = 0x800000
	// Counter clear disabled at the ELC_GPTH input
	GPT164_GTCSR_CSELCH_0 = 0x0
	// Counter clear enabled at the ELC_GPTH input
	GPT164_GTCSR_CSELCH_1 = 0x1
	// Position of CCLR field.
	GPT164_GTCSR_CCLR_Pos = 0x1f
	// Bit mask of CCLR field.
	GPT164_GTCSR_CCLR_Msk = 0x80000000
	// Bit CCLR.
	GPT164_GTCSR_CCLR = 0x80000000
	// Counter clear disabled by the GTCLR register
	GPT164_GTCSR_CCLR_0 = 0x0
	// Counter clear enabled by the GTCLR register
	GPT164_GTCSR_CCLR_1 = 0x1

	// GTUPSR: General PWM Timer Up Count Source Select Register
	// Position of USGTRGAR field.
	GPT164_GTUPSR_USGTRGAR_Pos = 0x0
	// Bit mask of USGTRGAR field.
	GPT164_GTUPSR_USGTRGAR_Msk = 0x1
	// Bit USGTRGAR.
	GPT164_GTUPSR_USGTRGAR = 0x1
	// Counter count up disabled on the rising edge of GTETRGA input
	GPT164_GTUPSR_USGTRGAR_0 = 0x0
	// Counter count up enabled on the rising edge of GTETRGA input
	GPT164_GTUPSR_USGTRGAR_1 = 0x1
	// Position of USGTRGAF field.
	GPT164_GTUPSR_USGTRGAF_Pos = 0x1
	// Bit mask of USGTRGAF field.
	GPT164_GTUPSR_USGTRGAF_Msk = 0x2
	// Bit USGTRGAF.
	GPT164_GTUPSR_USGTRGAF = 0x2
	// Counter count up disabled on the falling edge of GTETRGA input
	GPT164_GTUPSR_USGTRGAF_0 = 0x0
	// Counter count up enabled on the falling edge of GTETRGA input
	GPT164_GTUPSR_USGTRGAF_1 = 0x1
	// Position of USGTRGBR field.
	GPT164_GTUPSR_USGTRGBR_Pos = 0x2
	// Bit mask of USGTRGBR field.
	GPT164_GTUPSR_USGTRGBR_Msk = 0x4
	// Bit USGTRGBR.
	GPT164_GTUPSR_USGTRGBR = 0x4
	// Counter count up disabled on the rising edge of GTETRGB input
	GPT164_GTUPSR_USGTRGBR_0 = 0x0
	// Counter count up enabled on the rising edge of GTETRGB input
	GPT164_GTUPSR_USGTRGBR_1 = 0x1
	// Position of USGTRGBF field.
	GPT164_GTUPSR_USGTRGBF_Pos = 0x3
	// Bit mask of USGTRGBF field.
	GPT164_GTUPSR_USGTRGBF_Msk = 0x8
	// Bit USGTRGBF.
	GPT164_GTUPSR_USGTRGBF = 0x8
	// Counter count up disabled on the falling edge of GTETRGB input
	GPT164_GTUPSR_USGTRGBF_0 = 0x0
	// Counter count up enabled on the falling edge of GTETRGB input
	GPT164_GTUPSR_USGTRGBF_1 = 0x1
	// Position of USGTRGCR field.
	GPT164_GTUPSR_USGTRGCR_Pos = 0x4
	// Bit mask of USGTRGCR field.
	GPT164_GTUPSR_USGTRGCR_Msk = 0x10
	// Bit USGTRGCR.
	GPT164_GTUPSR_USGTRGCR = 0x10
	// Counter count up disabled on the rising edge of GTETRGC input
	GPT164_GTUPSR_USGTRGCR_0 = 0x0
	// Counter count up enabled on the rising edge of GTETRGC input
	GPT164_GTUPSR_USGTRGCR_1 = 0x1
	// Position of USGTRGCF field.
	GPT164_GTUPSR_USGTRGCF_Pos = 0x5
	// Bit mask of USGTRGCF field.
	GPT164_GTUPSR_USGTRGCF_Msk = 0x20
	// Bit USGTRGCF.
	GPT164_GTUPSR_USGTRGCF = 0x20
	// Counter count up disabled on the falling edge of GTETRGC input
	GPT164_GTUPSR_USGTRGCF_0 = 0x0
	// Counter count up enabled on the falling edge of GTETRGC input
	GPT164_GTUPSR_USGTRGCF_1 = 0x1
	// Position of USGTRGDR field.
	GPT164_GTUPSR_USGTRGDR_Pos = 0x6
	// Bit mask of USGTRGDR field.
	GPT164_GTUPSR_USGTRGDR_Msk = 0x40
	// Bit USGTRGDR.
	GPT164_GTUPSR_USGTRGDR = 0x40
	// Counter count up disabled on the rising edge of GTETRGD input
	GPT164_GTUPSR_USGTRGDR_0 = 0x0
	// Counter count up enabled on the rising edge of GTETRGD input
	GPT164_GTUPSR_USGTRGDR_1 = 0x1
	// Position of USGTRGDF field.
	GPT164_GTUPSR_USGTRGDF_Pos = 0x7
	// Bit mask of USGTRGDF field.
	GPT164_GTUPSR_USGTRGDF_Msk = 0x80
	// Bit USGTRGDF.
	GPT164_GTUPSR_USGTRGDF = 0x80
	// Counter count up disabled on the falling edge of GTETRGD input
	GPT164_GTUPSR_USGTRGDF_0 = 0x0
	// Counter count up enabled on the falling edge of GTETRGD input
	GPT164_GTUPSR_USGTRGDF_1 = 0x1
	// Position of USCARBL field.
	GPT164_GTUPSR_USCARBL_Pos = 0x8
	// Bit mask of USCARBL field.
	GPT164_GTUPSR_USCARBL_Msk = 0x100
	// Bit USCARBL.
	GPT164_GTUPSR_USCARBL = 0x100
	// Counter count up disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTUPSR_USCARBL_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTUPSR_USCARBL_1 = 0x1
	// Position of USCARBH field.
	GPT164_GTUPSR_USCARBH_Pos = 0x9
	// Bit mask of USCARBH field.
	GPT164_GTUPSR_USCARBH_Msk = 0x200
	// Bit USCARBH.
	GPT164_GTUPSR_USCARBH = 0x200
	// Counter count up disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTUPSR_USCARBH_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTUPSR_USCARBH_1 = 0x1
	// Position of USCAFBL field.
	GPT164_GTUPSR_USCAFBL_Pos = 0xa
	// Bit mask of USCAFBL field.
	GPT164_GTUPSR_USCAFBL_Msk = 0x400
	// Bit USCAFBL.
	GPT164_GTUPSR_USCAFBL = 0x400
	// Counter count up disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTUPSR_USCAFBL_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTUPSR_USCAFBL_1 = 0x1
	// Position of USCAFBH field.
	GPT164_GTUPSR_USCAFBH_Pos = 0xb
	// Bit mask of USCAFBH field.
	GPT164_GTUPSR_USCAFBH_Msk = 0x800
	// Bit USCAFBH.
	GPT164_GTUPSR_USCAFBH = 0x800
	// Counter count up disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTUPSR_USCAFBH_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTUPSR_USCAFBH_1 = 0x1
	// Position of USCBRAL field.
	GPT164_GTUPSR_USCBRAL_Pos = 0xc
	// Bit mask of USCBRAL field.
	GPT164_GTUPSR_USCBRAL_Msk = 0x1000
	// Bit USCBRAL.
	GPT164_GTUPSR_USCBRAL = 0x1000
	// Counter count up disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTUPSR_USCBRAL_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTUPSR_USCBRAL_1 = 0x1
	// Position of USCBRAH field.
	GPT164_GTUPSR_USCBRAH_Pos = 0xd
	// Bit mask of USCBRAH field.
	GPT164_GTUPSR_USCBRAH_Msk = 0x2000
	// Bit USCBRAH.
	GPT164_GTUPSR_USCBRAH = 0x2000
	// Counter count up disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTUPSR_USCBRAH_0 = 0x0
	// Counter count up enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTUPSR_USCBRAH_1 = 0x1
	// Position of USCBFAL field.
	GPT164_GTUPSR_USCBFAL_Pos = 0xe
	// Bit mask of USCBFAL field.
	GPT164_GTUPSR_USCBFAL_Msk = 0x4000
	// Bit USCBFAL.
	GPT164_GTUPSR_USCBFAL = 0x4000
	// Counter count up disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTUPSR_USCBFAL_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTUPSR_USCBFAL_1 = 0x1
	// Position of USCBFAH field.
	GPT164_GTUPSR_USCBFAH_Pos = 0xf
	// Bit mask of USCBFAH field.
	GPT164_GTUPSR_USCBFAH_Msk = 0x8000
	// Bit USCBFAH.
	GPT164_GTUPSR_USCBFAH = 0x8000
	// Counter count up disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTUPSR_USCBFAH_0 = 0x0
	// Counter count up enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTUPSR_USCBFAH_1 = 0x1
	// Position of USELCA field.
	GPT164_GTUPSR_USELCA_Pos = 0x10
	// Bit mask of USELCA field.
	GPT164_GTUPSR_USELCA_Msk = 0x10000
	// Bit USELCA.
	GPT164_GTUPSR_USELCA = 0x10000
	// Counter count up disabled at the ELC_GPTA input
	GPT164_GTUPSR_USELCA_0 = 0x0
	// Counter count up enabled at the ELC_GPTA input
	GPT164_GTUPSR_USELCA_1 = 0x1
	// Position of USELCB field.
	GPT164_GTUPSR_USELCB_Pos = 0x11
	// Bit mask of USELCB field.
	GPT164_GTUPSR_USELCB_Msk = 0x20000
	// Bit USELCB.
	GPT164_GTUPSR_USELCB = 0x20000
	// Counter count up disabled at the ELC_GPTB input
	GPT164_GTUPSR_USELCB_0 = 0x0
	// Counter count up enabled at the ELC_GPTB input
	GPT164_GTUPSR_USELCB_1 = 0x1
	// Position of USELCC field.
	GPT164_GTUPSR_USELCC_Pos = 0x12
	// Bit mask of USELCC field.
	GPT164_GTUPSR_USELCC_Msk = 0x40000
	// Bit USELCC.
	GPT164_GTUPSR_USELCC = 0x40000
	// Counter count up disabled at the ELC_GPTC input
	GPT164_GTUPSR_USELCC_0 = 0x0
	// Counter count up enabled at the ELC_GPTC input
	GPT164_GTUPSR_USELCC_1 = 0x1
	// Position of USELCD field.
	GPT164_GTUPSR_USELCD_Pos = 0x13
	// Bit mask of USELCD field.
	GPT164_GTUPSR_USELCD_Msk = 0x80000
	// Bit USELCD.
	GPT164_GTUPSR_USELCD = 0x80000
	// Counter count up disabled at the ELC_GPTD input
	GPT164_GTUPSR_USELCD_0 = 0x0
	// Counter count up enabled at the ELC_GPTD input
	GPT164_GTUPSR_USELCD_1 = 0x1
	// Position of USELCE field.
	GPT164_GTUPSR_USELCE_Pos = 0x14
	// Bit mask of USELCE field.
	GPT164_GTUPSR_USELCE_Msk = 0x100000
	// Bit USELCE.
	GPT164_GTUPSR_USELCE = 0x100000
	// Counter count up disabled at the ELC_GPTE input
	GPT164_GTUPSR_USELCE_0 = 0x0
	// Counter count up enabled at the ELC_GPTE input
	GPT164_GTUPSR_USELCE_1 = 0x1
	// Position of USELCF field.
	GPT164_GTUPSR_USELCF_Pos = 0x15
	// Bit mask of USELCF field.
	GPT164_GTUPSR_USELCF_Msk = 0x200000
	// Bit USELCF.
	GPT164_GTUPSR_USELCF = 0x200000
	// Counter count up disabled at the ELC_GPTF input
	GPT164_GTUPSR_USELCF_0 = 0x0
	// Counter count up enabled at the ELC_GPTF input
	GPT164_GTUPSR_USELCF_1 = 0x1
	// Position of USELCG field.
	GPT164_GTUPSR_USELCG_Pos = 0x16
	// Bit mask of USELCG field.
	GPT164_GTUPSR_USELCG_Msk = 0x400000
	// Bit USELCG.
	GPT164_GTUPSR_USELCG = 0x400000
	// Counter count up disabled at the ELC_GPTG input
	GPT164_GTUPSR_USELCG_0 = 0x0
	// Counter count up enabled at the ELC_GPTG input
	GPT164_GTUPSR_USELCG_1 = 0x1
	// Position of USELCH field.
	GPT164_GTUPSR_USELCH_Pos = 0x17
	// Bit mask of USELCH field.
	GPT164_GTUPSR_USELCH_Msk = 0x800000
	// Bit USELCH.
	GPT164_GTUPSR_USELCH = 0x800000
	// Counter count up disabled at the ELC_GPTH input
	GPT164_GTUPSR_USELCH_0 = 0x0
	// Counter count up enabled at the ELC_GPTH input
	GPT164_GTUPSR_USELCH_1 = 0x1

	// GTDNSR: General PWM Timer Down Count Source Select Register
	// Position of DSGTRGAR field.
	GPT164_GTDNSR_DSGTRGAR_Pos = 0x0
	// Bit mask of DSGTRGAR field.
	GPT164_GTDNSR_DSGTRGAR_Msk = 0x1
	// Bit DSGTRGAR.
	GPT164_GTDNSR_DSGTRGAR = 0x1
	// Counter count down disabled on the rising edge of GTETRGA input
	GPT164_GTDNSR_DSGTRGAR_0 = 0x0
	// Counter count down enabled on the rising edge of GTETRGA input
	GPT164_GTDNSR_DSGTRGAR_1 = 0x1
	// Position of DSGTRGAF field.
	GPT164_GTDNSR_DSGTRGAF_Pos = 0x1
	// Bit mask of DSGTRGAF field.
	GPT164_GTDNSR_DSGTRGAF_Msk = 0x2
	// Bit DSGTRGAF.
	GPT164_GTDNSR_DSGTRGAF = 0x2
	// Counter count down disabled on the falling edge of GTETRGA input
	GPT164_GTDNSR_DSGTRGAF_0 = 0x0
	// Counter count down enabled on the falling edge of GTETRGA input
	GPT164_GTDNSR_DSGTRGAF_1 = 0x1
	// Position of DSGTRGBR field.
	GPT164_GTDNSR_DSGTRGBR_Pos = 0x2
	// Bit mask of DSGTRGBR field.
	GPT164_GTDNSR_DSGTRGBR_Msk = 0x4
	// Bit DSGTRGBR.
	GPT164_GTDNSR_DSGTRGBR = 0x4
	// Counter count down disabled on the rising edge of GTETRGB input
	GPT164_GTDNSR_DSGTRGBR_0 = 0x0
	// Counter count down enabled on the rising edge of GTETRGB input
	GPT164_GTDNSR_DSGTRGBR_1 = 0x1
	// Position of DSGTRGBF field.
	GPT164_GTDNSR_DSGTRGBF_Pos = 0x3
	// Bit mask of DSGTRGBF field.
	GPT164_GTDNSR_DSGTRGBF_Msk = 0x8
	// Bit DSGTRGBF.
	GPT164_GTDNSR_DSGTRGBF = 0x8
	// Counter count down disabled on the falling edge of GTETRGB input
	GPT164_GTDNSR_DSGTRGBF_0 = 0x0
	// Counter count down enabled on the falling edge of GTETRGB input
	GPT164_GTDNSR_DSGTRGBF_1 = 0x1
	// Position of DSGTRGCR field.
	GPT164_GTDNSR_DSGTRGCR_Pos = 0x4
	// Bit mask of DSGTRGCR field.
	GPT164_GTDNSR_DSGTRGCR_Msk = 0x10
	// Bit DSGTRGCR.
	GPT164_GTDNSR_DSGTRGCR = 0x10
	// Counter count down disabled on the rising edge of GTETRGC input
	GPT164_GTDNSR_DSGTRGCR_0 = 0x0
	// Counter count down enabled on the rising edge of GTETRGC input
	GPT164_GTDNSR_DSGTRGCR_1 = 0x1
	// Position of DSGTRGCF field.
	GPT164_GTDNSR_DSGTRGCF_Pos = 0x5
	// Bit mask of DSGTRGCF field.
	GPT164_GTDNSR_DSGTRGCF_Msk = 0x20
	// Bit DSGTRGCF.
	GPT164_GTDNSR_DSGTRGCF = 0x20
	// Counter count down disabled on the falling edge of GTETRGC input
	GPT164_GTDNSR_DSGTRGCF_0 = 0x0
	// Counter count down enabled on the falling edge of GTETRGC input
	GPT164_GTDNSR_DSGTRGCF_1 = 0x1
	// Position of DSGTRGDR field.
	GPT164_GTDNSR_DSGTRGDR_Pos = 0x6
	// Bit mask of DSGTRGDR field.
	GPT164_GTDNSR_DSGTRGDR_Msk = 0x40
	// Bit DSGTRGDR.
	GPT164_GTDNSR_DSGTRGDR = 0x40
	// Counter count down disabled on the rising edge of GTETRGD input
	GPT164_GTDNSR_DSGTRGDR_0 = 0x0
	// Counter count down enabled on the rising edge of GTETRGD input
	GPT164_GTDNSR_DSGTRGDR_1 = 0x1
	// Position of DSGTRGDF field.
	GPT164_GTDNSR_DSGTRGDF_Pos = 0x7
	// Bit mask of DSGTRGDF field.
	GPT164_GTDNSR_DSGTRGDF_Msk = 0x80
	// Bit DSGTRGDF.
	GPT164_GTDNSR_DSGTRGDF = 0x80
	// Counter count down disabled on the falling edge of GTETRGD input
	GPT164_GTDNSR_DSGTRGDF_0 = 0x0
	// Counter count down enabled on the falling edge of GTETRGD input
	GPT164_GTDNSR_DSGTRGDF_1 = 0x1
	// Position of DSCARBL field.
	GPT164_GTDNSR_DSCARBL_Pos = 0x8
	// Bit mask of DSCARBL field.
	GPT164_GTDNSR_DSCARBL_Msk = 0x100
	// Bit DSCARBL.
	GPT164_GTDNSR_DSCARBL = 0x100
	// Counter count down disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTDNSR_DSCARBL_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTDNSR_DSCARBL_1 = 0x1
	// Position of DSCARBH field.
	GPT164_GTDNSR_DSCARBH_Pos = 0x9
	// Bit mask of DSCARBH field.
	GPT164_GTDNSR_DSCARBH_Msk = 0x200
	// Bit DSCARBH.
	GPT164_GTDNSR_DSCARBH = 0x200
	// Counter count down disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTDNSR_DSCARBH_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTDNSR_DSCARBH_1 = 0x1
	// Position of DSCAFBL field.
	GPT164_GTDNSR_DSCAFBL_Pos = 0xa
	// Bit mask of DSCAFBL field.
	GPT164_GTDNSR_DSCAFBL_Msk = 0x400
	// Bit DSCAFBL.
	GPT164_GTDNSR_DSCAFBL = 0x400
	// Counter count down disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTDNSR_DSCAFBL_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTDNSR_DSCAFBL_1 = 0x1
	// Position of DSCAFBH field.
	GPT164_GTDNSR_DSCAFBH_Pos = 0xb
	// Bit mask of DSCAFBH field.
	GPT164_GTDNSR_DSCAFBH_Msk = 0x800
	// Bit DSCAFBH.
	GPT164_GTDNSR_DSCAFBH = 0x800
	// Counter count down disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTDNSR_DSCAFBH_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTDNSR_DSCAFBH_1 = 0x1
	// Position of DSCBRAL field.
	GPT164_GTDNSR_DSCBRAL_Pos = 0xc
	// Bit mask of DSCBRAL field.
	GPT164_GTDNSR_DSCBRAL_Msk = 0x1000
	// Bit DSCBRAL.
	GPT164_GTDNSR_DSCBRAL = 0x1000
	// Counter count down disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTDNSR_DSCBRAL_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTDNSR_DSCBRAL_1 = 0x1
	// Position of DSCBRAH field.
	GPT164_GTDNSR_DSCBRAH_Pos = 0xd
	// Bit mask of DSCBRAH field.
	GPT164_GTDNSR_DSCBRAH_Msk = 0x2000
	// Bit DSCBRAH.
	GPT164_GTDNSR_DSCBRAH = 0x2000
	// Counter count down disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTDNSR_DSCBRAH_0 = 0x0
	// Counter count down enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTDNSR_DSCBRAH_1 = 0x1
	// Position of DSCBFAL field.
	GPT164_GTDNSR_DSCBFAL_Pos = 0xe
	// Bit mask of DSCBFAL field.
	GPT164_GTDNSR_DSCBFAL_Msk = 0x4000
	// Bit DSCBFAL.
	GPT164_GTDNSR_DSCBFAL = 0x4000
	// Counter count down disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTDNSR_DSCBFAL_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTDNSR_DSCBFAL_1 = 0x1
	// Position of DSCBFAH field.
	GPT164_GTDNSR_DSCBFAH_Pos = 0xf
	// Bit mask of DSCBFAH field.
	GPT164_GTDNSR_DSCBFAH_Msk = 0x8000
	// Bit DSCBFAH.
	GPT164_GTDNSR_DSCBFAH = 0x8000
	// Counter count down disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTDNSR_DSCBFAH_0 = 0x0
	// Counter count down enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTDNSR_DSCBFAH_1 = 0x1
	// Position of DSELCA field.
	GPT164_GTDNSR_DSELCA_Pos = 0x10
	// Bit mask of DSELCA field.
	GPT164_GTDNSR_DSELCA_Msk = 0x10000
	// Bit DSELCA.
	GPT164_GTDNSR_DSELCA = 0x10000
	// Counter count down disabled at the ELC_GPTA input
	GPT164_GTDNSR_DSELCA_0 = 0x0
	// Counter count down enabled at the ELC_GPTA input
	GPT164_GTDNSR_DSELCA_1 = 0x1
	// Position of DSELCB field.
	GPT164_GTDNSR_DSELCB_Pos = 0x11
	// Bit mask of DSELCB field.
	GPT164_GTDNSR_DSELCB_Msk = 0x20000
	// Bit DSELCB.
	GPT164_GTDNSR_DSELCB = 0x20000
	// Counter count down disabled at the ELC_GPTB input
	GPT164_GTDNSR_DSELCB_0 = 0x0
	// Counter count down enabled at the ELC_GPTB input
	GPT164_GTDNSR_DSELCB_1 = 0x1
	// Position of DSELCC field.
	GPT164_GTDNSR_DSELCC_Pos = 0x12
	// Bit mask of DSELCC field.
	GPT164_GTDNSR_DSELCC_Msk = 0x40000
	// Bit DSELCC.
	GPT164_GTDNSR_DSELCC = 0x40000
	// Counter count down disabled at the ELC_GPTC input
	GPT164_GTDNSR_DSELCC_0 = 0x0
	// Counter count down enabled at the ELC_GPTC input
	GPT164_GTDNSR_DSELCC_1 = 0x1
	// Position of DSELCD field.
	GPT164_GTDNSR_DSELCD_Pos = 0x13
	// Bit mask of DSELCD field.
	GPT164_GTDNSR_DSELCD_Msk = 0x80000
	// Bit DSELCD.
	GPT164_GTDNSR_DSELCD = 0x80000
	// Counter count down disabled at the ELC_GPTD input
	GPT164_GTDNSR_DSELCD_0 = 0x0
	// Counter count down enabled at the ELC_GPTD input
	GPT164_GTDNSR_DSELCD_1 = 0x1
	// Position of DSELCE field.
	GPT164_GTDNSR_DSELCE_Pos = 0x14
	// Bit mask of DSELCE field.
	GPT164_GTDNSR_DSELCE_Msk = 0x100000
	// Bit DSELCE.
	GPT164_GTDNSR_DSELCE = 0x100000
	// Counter count down disabled at the ELC_GPTE input
	GPT164_GTDNSR_DSELCE_0 = 0x0
	// Counter count down enabled at the ELC_GPTE input
	GPT164_GTDNSR_DSELCE_1 = 0x1
	// Position of DSELCF field.
	GPT164_GTDNSR_DSELCF_Pos = 0x15
	// Bit mask of DSELCF field.
	GPT164_GTDNSR_DSELCF_Msk = 0x200000
	// Bit DSELCF.
	GPT164_GTDNSR_DSELCF = 0x200000
	// Counter count down disabled at the ELC_GPTF input
	GPT164_GTDNSR_DSELCF_0 = 0x0
	// Counter count down enabled at the ELC_GPTF input
	GPT164_GTDNSR_DSELCF_1 = 0x1
	// Position of DSELCG field.
	GPT164_GTDNSR_DSELCG_Pos = 0x16
	// Bit mask of DSELCG field.
	GPT164_GTDNSR_DSELCG_Msk = 0x400000
	// Bit DSELCG.
	GPT164_GTDNSR_DSELCG = 0x400000
	// Counter count down disabled at the ELC_GPTG input
	GPT164_GTDNSR_DSELCG_0 = 0x0
	// Counter count down enabled at the ELC_GPTG input
	GPT164_GTDNSR_DSELCG_1 = 0x1
	// Position of DSELCH field.
	GPT164_GTDNSR_DSELCH_Pos = 0x17
	// Bit mask of DSELCH field.
	GPT164_GTDNSR_DSELCH_Msk = 0x800000
	// Bit DSELCH.
	GPT164_GTDNSR_DSELCH = 0x800000
	// Counter count down disabled at the ELC_GPTF input
	GPT164_GTDNSR_DSELCH_0 = 0x0
	// Counter count down enabled at the ELC_GPTF input
	GPT164_GTDNSR_DSELCH_1 = 0x1

	// GTICASR: General PWM Timer Input Capture Source Select Register A
	// Position of ASGTRGAR field.
	GPT164_GTICASR_ASGTRGAR_Pos = 0x0
	// Bit mask of ASGTRGAR field.
	GPT164_GTICASR_ASGTRGAR_Msk = 0x1
	// Bit ASGTRGAR.
	GPT164_GTICASR_ASGTRGAR = 0x1
	// GTCCRA input capture disabled on the rising edge of GTETRGA input
	GPT164_GTICASR_ASGTRGAR_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTETRGA input
	GPT164_GTICASR_ASGTRGAR_1 = 0x1
	// Position of ASGTRGAF field.
	GPT164_GTICASR_ASGTRGAF_Pos = 0x1
	// Bit mask of ASGTRGAF field.
	GPT164_GTICASR_ASGTRGAF_Msk = 0x2
	// Bit ASGTRGAF.
	GPT164_GTICASR_ASGTRGAF = 0x2
	// GTCCRA input capture disabled on the falling edge of GTETRGA input
	GPT164_GTICASR_ASGTRGAF_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTETRGA input
	GPT164_GTICASR_ASGTRGAF_1 = 0x1
	// Position of ASGTRGBR field.
	GPT164_GTICASR_ASGTRGBR_Pos = 0x2
	// Bit mask of ASGTRGBR field.
	GPT164_GTICASR_ASGTRGBR_Msk = 0x4
	// Bit ASGTRGBR.
	GPT164_GTICASR_ASGTRGBR = 0x4
	// GTCCRA input capture disabled on the rising edge of GTETRGB input
	GPT164_GTICASR_ASGTRGBR_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTETRGB input
	GPT164_GTICASR_ASGTRGBR_1 = 0x1
	// Position of ASGTRGBF field.
	GPT164_GTICASR_ASGTRGBF_Pos = 0x3
	// Bit mask of ASGTRGBF field.
	GPT164_GTICASR_ASGTRGBF_Msk = 0x8
	// Bit ASGTRGBF.
	GPT164_GTICASR_ASGTRGBF = 0x8
	// GTCCRA input capture disabled on the falling edge of GTETRGB input
	GPT164_GTICASR_ASGTRGBF_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTETRGB input
	GPT164_GTICASR_ASGTRGBF_1 = 0x1
	// Position of ASGTRGCR field.
	GPT164_GTICASR_ASGTRGCR_Pos = 0x4
	// Bit mask of ASGTRGCR field.
	GPT164_GTICASR_ASGTRGCR_Msk = 0x10
	// Bit ASGTRGCR.
	GPT164_GTICASR_ASGTRGCR = 0x10
	// GTCCRA input capture disabled on the rising edge of GTETRGC input
	GPT164_GTICASR_ASGTRGCR_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTETRGC input
	GPT164_GTICASR_ASGTRGCR_1 = 0x1
	// Position of ASGTRGCF field.
	GPT164_GTICASR_ASGTRGCF_Pos = 0x5
	// Bit mask of ASGTRGCF field.
	GPT164_GTICASR_ASGTRGCF_Msk = 0x20
	// Bit ASGTRGCF.
	GPT164_GTICASR_ASGTRGCF = 0x20
	// GTCCRA input capture disabled on the falling edge of GTETRGC input
	GPT164_GTICASR_ASGTRGCF_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTETRGC input
	GPT164_GTICASR_ASGTRGCF_1 = 0x1
	// Position of ASGTRGDR field.
	GPT164_GTICASR_ASGTRGDR_Pos = 0x6
	// Bit mask of ASGTRGDR field.
	GPT164_GTICASR_ASGTRGDR_Msk = 0x40
	// Bit ASGTRGDR.
	GPT164_GTICASR_ASGTRGDR = 0x40
	// GTCCRA input capture disabled on the rising edge of GTETRGD input
	GPT164_GTICASR_ASGTRGDR_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTETRGD input
	GPT164_GTICASR_ASGTRGDR_1 = 0x1
	// Position of ASGTRGDF field.
	GPT164_GTICASR_ASGTRGDF_Pos = 0x7
	// Bit mask of ASGTRGDF field.
	GPT164_GTICASR_ASGTRGDF_Msk = 0x80
	// Bit ASGTRGDF.
	GPT164_GTICASR_ASGTRGDF = 0x80
	// GTCCRA input capture disabled on the falling edge of GTETRGD input
	GPT164_GTICASR_ASGTRGDF_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTETRGD input
	GPT164_GTICASR_ASGTRGDF_1 = 0x1
	// Position of ASCARBL field.
	GPT164_GTICASR_ASCARBL_Pos = 0x8
	// Bit mask of ASCARBL field.
	GPT164_GTICASR_ASCARBL_Msk = 0x100
	// Bit ASCARBL.
	GPT164_GTICASR_ASCARBL = 0x100
	// GTCCRA input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICASR_ASCARBL_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICASR_ASCARBL_1 = 0x1
	// Position of ASCARBH field.
	GPT164_GTICASR_ASCARBH_Pos = 0x9
	// Bit mask of ASCARBH field.
	GPT164_GTICASR_ASCARBH_Msk = 0x200
	// Bit ASCARBH.
	GPT164_GTICASR_ASCARBH = 0x200
	// GTCCRA input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICASR_ASCARBH_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICASR_ASCARBH_1 = 0x1
	// Position of ASCAFBL field.
	GPT164_GTICASR_ASCAFBL_Pos = 0xa
	// Bit mask of ASCAFBL field.
	GPT164_GTICASR_ASCAFBL_Msk = 0x400
	// Bit ASCAFBL.
	GPT164_GTICASR_ASCAFBL = 0x400
	// GTCCRA input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICASR_ASCAFBL_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICASR_ASCAFBL_1 = 0x1
	// Position of ASCAFBH field.
	GPT164_GTICASR_ASCAFBH_Pos = 0xb
	// Bit mask of ASCAFBH field.
	GPT164_GTICASR_ASCAFBH_Msk = 0x800
	// Bit ASCAFBH.
	GPT164_GTICASR_ASCAFBH = 0x800
	// GTCCRA input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICASR_ASCAFBH_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICASR_ASCAFBH_1 = 0x1
	// Position of ASCBRAL field.
	GPT164_GTICASR_ASCBRAL_Pos = 0xc
	// Bit mask of ASCBRAL field.
	GPT164_GTICASR_ASCBRAL_Msk = 0x1000
	// Bit ASCBRAL.
	GPT164_GTICASR_ASCBRAL = 0x1000
	// GTCCRA input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICASR_ASCBRAL_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICASR_ASCBRAL_1 = 0x1
	// Position of ASCBRAH field.
	GPT164_GTICASR_ASCBRAH_Pos = 0xd
	// Bit mask of ASCBRAH field.
	GPT164_GTICASR_ASCBRAH_Msk = 0x2000
	// Bit ASCBRAH.
	GPT164_GTICASR_ASCBRAH = 0x2000
	// GTCCRA input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICASR_ASCBRAH_0 = 0x0
	// GTCCRA input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICASR_ASCBRAH_1 = 0x1
	// Position of ASCBFAL field.
	GPT164_GTICASR_ASCBFAL_Pos = 0xe
	// Bit mask of ASCBFAL field.
	GPT164_GTICASR_ASCBFAL_Msk = 0x4000
	// Bit ASCBFAL.
	GPT164_GTICASR_ASCBFAL = 0x4000
	// GTCCRA input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICASR_ASCBFAL_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICASR_ASCBFAL_1 = 0x1
	// Position of ASCBFAH field.
	GPT164_GTICASR_ASCBFAH_Pos = 0xf
	// Bit mask of ASCBFAH field.
	GPT164_GTICASR_ASCBFAH_Msk = 0x8000
	// Bit ASCBFAH.
	GPT164_GTICASR_ASCBFAH = 0x8000
	// GTCCRA input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICASR_ASCBFAH_0 = 0x0
	// GTCCRA input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICASR_ASCBFAH_1 = 0x1
	// Position of ASELCA field.
	GPT164_GTICASR_ASELCA_Pos = 0x10
	// Bit mask of ASELCA field.
	GPT164_GTICASR_ASELCA_Msk = 0x10000
	// Bit ASELCA.
	GPT164_GTICASR_ASELCA = 0x10000
	// GTCCRA input capture disabled at the ELC_GPTA input
	GPT164_GTICASR_ASELCA_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTA input
	GPT164_GTICASR_ASELCA_1 = 0x1
	// Position of ASELCB field.
	GPT164_GTICASR_ASELCB_Pos = 0x11
	// Bit mask of ASELCB field.
	GPT164_GTICASR_ASELCB_Msk = 0x20000
	// Bit ASELCB.
	GPT164_GTICASR_ASELCB = 0x20000
	// GTCCRA input capture disabled at the ELC_GPTB input
	GPT164_GTICASR_ASELCB_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTB input
	GPT164_GTICASR_ASELCB_1 = 0x1
	// Position of ASELCC field.
	GPT164_GTICASR_ASELCC_Pos = 0x12
	// Bit mask of ASELCC field.
	GPT164_GTICASR_ASELCC_Msk = 0x40000
	// Bit ASELCC.
	GPT164_GTICASR_ASELCC = 0x40000
	// GTCCRA input capture disabled at the ELC_GPTC input
	GPT164_GTICASR_ASELCC_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTC input
	GPT164_GTICASR_ASELCC_1 = 0x1
	// Position of ASELCD field.
	GPT164_GTICASR_ASELCD_Pos = 0x13
	// Bit mask of ASELCD field.
	GPT164_GTICASR_ASELCD_Msk = 0x80000
	// Bit ASELCD.
	GPT164_GTICASR_ASELCD = 0x80000
	// GTCCRA input capture disabled at the ELC_GPTD input
	GPT164_GTICASR_ASELCD_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTD input
	GPT164_GTICASR_ASELCD_1 = 0x1
	// Position of ASELCE field.
	GPT164_GTICASR_ASELCE_Pos = 0x14
	// Bit mask of ASELCE field.
	GPT164_GTICASR_ASELCE_Msk = 0x100000
	// Bit ASELCE.
	GPT164_GTICASR_ASELCE = 0x100000
	// GTCCRA input capture disabled at the ELC_GPTE input
	GPT164_GTICASR_ASELCE_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTE input
	GPT164_GTICASR_ASELCE_1 = 0x1
	// Position of ASELCF field.
	GPT164_GTICASR_ASELCF_Pos = 0x15
	// Bit mask of ASELCF field.
	GPT164_GTICASR_ASELCF_Msk = 0x200000
	// Bit ASELCF.
	GPT164_GTICASR_ASELCF = 0x200000
	// GTCCRA input capture disabled at the ELC_GPTF input
	GPT164_GTICASR_ASELCF_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTF input
	GPT164_GTICASR_ASELCF_1 = 0x1
	// Position of ASELCG field.
	GPT164_GTICASR_ASELCG_Pos = 0x16
	// Bit mask of ASELCG field.
	GPT164_GTICASR_ASELCG_Msk = 0x400000
	// Bit ASELCG.
	GPT164_GTICASR_ASELCG = 0x400000
	// GTCCRA input capture disabled at the ELC_GPTG input
	GPT164_GTICASR_ASELCG_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTG input
	GPT164_GTICASR_ASELCG_1 = 0x1
	// Position of ASELCH field.
	GPT164_GTICASR_ASELCH_Pos = 0x17
	// Bit mask of ASELCH field.
	GPT164_GTICASR_ASELCH_Msk = 0x800000
	// Bit ASELCH.
	GPT164_GTICASR_ASELCH = 0x800000
	// GTCCRA input capture disabled at the ELC_GPTH input
	GPT164_GTICASR_ASELCH_0 = 0x0
	// GTCCRA input capture enabled at the ELC_GPTH input
	GPT164_GTICASR_ASELCH_1 = 0x1

	// GTICBSR: General PWM Timer Input Capture Source Select Register B
	// Position of BSGTRGAR field.
	GPT164_GTICBSR_BSGTRGAR_Pos = 0x0
	// Bit mask of BSGTRGAR field.
	GPT164_GTICBSR_BSGTRGAR_Msk = 0x1
	// Bit BSGTRGAR.
	GPT164_GTICBSR_BSGTRGAR = 0x1
	// GTCCRB input capture disabled on the rising edge of GTETRGA input
	GPT164_GTICBSR_BSGTRGAR_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTETRGA input
	GPT164_GTICBSR_BSGTRGAR_1 = 0x1
	// Position of BSGTRGAF field.
	GPT164_GTICBSR_BSGTRGAF_Pos = 0x1
	// Bit mask of BSGTRGAF field.
	GPT164_GTICBSR_BSGTRGAF_Msk = 0x2
	// Bit BSGTRGAF.
	GPT164_GTICBSR_BSGTRGAF = 0x2
	// GTCCRB input capture disabled on the falling edge of GTETRGA input
	GPT164_GTICBSR_BSGTRGAF_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTETRGA input
	GPT164_GTICBSR_BSGTRGAF_1 = 0x1
	// Position of BSGTRGBR field.
	GPT164_GTICBSR_BSGTRGBR_Pos = 0x2
	// Bit mask of BSGTRGBR field.
	GPT164_GTICBSR_BSGTRGBR_Msk = 0x4
	// Bit BSGTRGBR.
	GPT164_GTICBSR_BSGTRGBR = 0x4
	// GTCCRB input capture disabled on the rising edge of GTETRGB input
	GPT164_GTICBSR_BSGTRGBR_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTETRGB input
	GPT164_GTICBSR_BSGTRGBR_1 = 0x1
	// Position of BSGTRGBF field.
	GPT164_GTICBSR_BSGTRGBF_Pos = 0x3
	// Bit mask of BSGTRGBF field.
	GPT164_GTICBSR_BSGTRGBF_Msk = 0x8
	// Bit BSGTRGBF.
	GPT164_GTICBSR_BSGTRGBF = 0x8
	// GTCCRB input capture disabled on the falling edge of GTETRGB input
	GPT164_GTICBSR_BSGTRGBF_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTETRGB input
	GPT164_GTICBSR_BSGTRGBF_1 = 0x1
	// Position of BSGTRGCR field.
	GPT164_GTICBSR_BSGTRGCR_Pos = 0x4
	// Bit mask of BSGTRGCR field.
	GPT164_GTICBSR_BSGTRGCR_Msk = 0x10
	// Bit BSGTRGCR.
	GPT164_GTICBSR_BSGTRGCR = 0x10
	// GTCCRB input capture disabled on the rising edge of GTETRGC input
	GPT164_GTICBSR_BSGTRGCR_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTETRGC input
	GPT164_GTICBSR_BSGTRGCR_1 = 0x1
	// Position of BSGTRGCF field.
	GPT164_GTICBSR_BSGTRGCF_Pos = 0x5
	// Bit mask of BSGTRGCF field.
	GPT164_GTICBSR_BSGTRGCF_Msk = 0x20
	// Bit BSGTRGCF.
	GPT164_GTICBSR_BSGTRGCF = 0x20
	// GTCCRB input capture disabled on the falling edge of GTETRGC input
	GPT164_GTICBSR_BSGTRGCF_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTETRGC input
	GPT164_GTICBSR_BSGTRGCF_1 = 0x1
	// Position of BSGTRGDR field.
	GPT164_GTICBSR_BSGTRGDR_Pos = 0x6
	// Bit mask of BSGTRGDR field.
	GPT164_GTICBSR_BSGTRGDR_Msk = 0x40
	// Bit BSGTRGDR.
	GPT164_GTICBSR_BSGTRGDR = 0x40
	// GTCCRB input capture disabled on the rising edge of GTETRGD input
	GPT164_GTICBSR_BSGTRGDR_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTETRGD input
	GPT164_GTICBSR_BSGTRGDR_1 = 0x1
	// Position of BSGTRGDF field.
	GPT164_GTICBSR_BSGTRGDF_Pos = 0x7
	// Bit mask of BSGTRGDF field.
	GPT164_GTICBSR_BSGTRGDF_Msk = 0x80
	// Bit BSGTRGDF.
	GPT164_GTICBSR_BSGTRGDF = 0x80
	// GTCCRB input capture disabled on the falling edge of GTETRGD input
	GPT164_GTICBSR_BSGTRGDF_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTETRGD input
	GPT164_GTICBSR_BSGTRGDF_1 = 0x1
	// Position of BSCARBL field.
	GPT164_GTICBSR_BSCARBL_Pos = 0x8
	// Bit mask of BSCARBL field.
	GPT164_GTICBSR_BSCARBL_Msk = 0x100
	// Bit BSCARBL.
	GPT164_GTICBSR_BSCARBL = 0x100
	// GTCCRB input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICBSR_BSCARBL_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICBSR_BSCARBL_1 = 0x1
	// Position of BSCARBH field.
	GPT164_GTICBSR_BSCARBH_Pos = 0x9
	// Bit mask of BSCARBH field.
	GPT164_GTICBSR_BSCARBH_Msk = 0x200
	// Bit BSCARBH.
	GPT164_GTICBSR_BSCARBH = 0x200
	// GTCCRB input capture disabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICBSR_BSCARBH_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICBSR_BSCARBH_1 = 0x1
	// Position of BSCAFBL field.
	GPT164_GTICBSR_BSCAFBL_Pos = 0xa
	// Bit mask of BSCAFBL field.
	GPT164_GTICBSR_BSCAFBL_Msk = 0x400
	// Bit BSCAFBL.
	GPT164_GTICBSR_BSCAFBL = 0x400
	// GTCCRB input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICBSR_BSCAFBL_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 0
	GPT164_GTICBSR_BSCAFBL_1 = 0x1
	// Position of BSCAFBH field.
	GPT164_GTICBSR_BSCAFBH_Pos = 0xb
	// Bit mask of BSCAFBH field.
	GPT164_GTICBSR_BSCAFBH_Msk = 0x800
	// Bit BSCAFBH.
	GPT164_GTICBSR_BSCAFBH = 0x800
	// GTCCRB input capture disabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICBSR_BSCAFBH_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnA input when GTIOCnB input is 1
	GPT164_GTICBSR_BSCAFBH_1 = 0x1
	// Position of BSCBRAL field.
	GPT164_GTICBSR_BSCBRAL_Pos = 0xc
	// Bit mask of BSCBRAL field.
	GPT164_GTICBSR_BSCBRAL_Msk = 0x1000
	// Bit BSCBRAL.
	GPT164_GTICBSR_BSCBRAL = 0x1000
	// GTCCRB input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICBSR_BSCBRAL_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICBSR_BSCBRAL_1 = 0x1
	// Position of BSCBRAH field.
	GPT164_GTICBSR_BSCBRAH_Pos = 0xd
	// Bit mask of BSCBRAH field.
	GPT164_GTICBSR_BSCBRAH_Msk = 0x2000
	// Bit BSCBRAH.
	GPT164_GTICBSR_BSCBRAH = 0x2000
	// GTCCRB input capture disabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICBSR_BSCBRAH_0 = 0x0
	// GTCCRB input capture enabled on the rising edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICBSR_BSCBRAH_1 = 0x1
	// Position of BSCBFAL field.
	GPT164_GTICBSR_BSCBFAL_Pos = 0xe
	// Bit mask of BSCBFAL field.
	GPT164_GTICBSR_BSCBFAL_Msk = 0x4000
	// Bit BSCBFAL.
	GPT164_GTICBSR_BSCBFAL = 0x4000
	// GTCCRB input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICBSR_BSCBFAL_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 0
	GPT164_GTICBSR_BSCBFAL_1 = 0x1
	// Position of BSCBFAH field.
	GPT164_GTICBSR_BSCBFAH_Pos = 0xf
	// Bit mask of BSCBFAH field.
	GPT164_GTICBSR_BSCBFAH_Msk = 0x8000
	// Bit BSCBFAH.
	GPT164_GTICBSR_BSCBFAH = 0x8000
	// GTCCRB input capture disabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICBSR_BSCBFAH_0 = 0x0
	// GTCCRB input capture enabled on the falling edge of GTIOCnB input when GTIOCnA input is 1
	GPT164_GTICBSR_BSCBFAH_1 = 0x1
	// Position of BSELCA field.
	GPT164_GTICBSR_BSELCA_Pos = 0x10
	// Bit mask of BSELCA field.
	GPT164_GTICBSR_BSELCA_Msk = 0x10000
	// Bit BSELCA.
	GPT164_GTICBSR_BSELCA = 0x10000
	// GTCCRB input capture disabled at the ELC_GPTA input
	GPT164_GTICBSR_BSELCA_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTA input
	GPT164_GTICBSR_BSELCA_1 = 0x1
	// Position of BSELCB field.
	GPT164_GTICBSR_BSELCB_Pos = 0x11
	// Bit mask of BSELCB field.
	GPT164_GTICBSR_BSELCB_Msk = 0x20000
	// Bit BSELCB.
	GPT164_GTICBSR_BSELCB = 0x20000
	// GTCCRB input capture disabled at the ELC_GPTB input
	GPT164_GTICBSR_BSELCB_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTB input
	GPT164_GTICBSR_BSELCB_1 = 0x1
	// Position of BSELCC field.
	GPT164_GTICBSR_BSELCC_Pos = 0x12
	// Bit mask of BSELCC field.
	GPT164_GTICBSR_BSELCC_Msk = 0x40000
	// Bit BSELCC.
	GPT164_GTICBSR_BSELCC = 0x40000
	// GTCCRB input capture disabled at the ELC_GPTC input
	GPT164_GTICBSR_BSELCC_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTC input
	GPT164_GTICBSR_BSELCC_1 = 0x1
	// Position of BSELCD field.
	GPT164_GTICBSR_BSELCD_Pos = 0x13
	// Bit mask of BSELCD field.
	GPT164_GTICBSR_BSELCD_Msk = 0x80000
	// Bit BSELCD.
	GPT164_GTICBSR_BSELCD = 0x80000
	// GTCCRB input capture disabled at the ELC_GPTD input
	GPT164_GTICBSR_BSELCD_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTD input
	GPT164_GTICBSR_BSELCD_1 = 0x1
	// Position of BSELCE field.
	GPT164_GTICBSR_BSELCE_Pos = 0x14
	// Bit mask of BSELCE field.
	GPT164_GTICBSR_BSELCE_Msk = 0x100000
	// Bit BSELCE.
	GPT164_GTICBSR_BSELCE = 0x100000
	// GTCCRB input capture disabled at the ELC_GPTE input
	GPT164_GTICBSR_BSELCE_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTE input
	GPT164_GTICBSR_BSELCE_1 = 0x1
	// Position of BSELCF field.
	GPT164_GTICBSR_BSELCF_Pos = 0x15
	// Bit mask of BSELCF field.
	GPT164_GTICBSR_BSELCF_Msk = 0x200000
	// Bit BSELCF.
	GPT164_GTICBSR_BSELCF = 0x200000
	// GTCCRB input capture disabled at the ELC_GPTF input
	GPT164_GTICBSR_BSELCF_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTF input
	GPT164_GTICBSR_BSELCF_1 = 0x1
	// Position of BSELCG field.
	GPT164_GTICBSR_BSELCG_Pos = 0x16
	// Bit mask of BSELCG field.
	GPT164_GTICBSR_BSELCG_Msk = 0x400000
	// Bit BSELCG.
	GPT164_GTICBSR_BSELCG = 0x400000
	// GTCCRB input capture disabled at the ELC_GPTG input
	GPT164_GTICBSR_BSELCG_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTG input
	GPT164_GTICBSR_BSELCG_1 = 0x1
	// Position of BSELCH field.
	GPT164_GTICBSR_BSELCH_Pos = 0x17
	// Bit mask of BSELCH field.
	GPT164_GTICBSR_BSELCH_Msk = 0x800000
	// Bit BSELCH.
	GPT164_GTICBSR_BSELCH = 0x800000
	// GTCCRB input capture disabled at the ELC_GPTH input
	GPT164_GTICBSR_BSELCH_0 = 0x0
	// GTCCRB input capture enabled at the ELC_GPTH input
	GPT164_GTICBSR_BSELCH_1 = 0x1

	// GTCR: General PWM Timer Control Register
	// Position of CST field.
	GPT164_GTCR_CST_Pos = 0x0
	// Bit mask of CST field.
	GPT164_GTCR_CST_Msk = 0x1
	// Bit CST.
	GPT164_GTCR_CST = 0x1
	// Count operation is stopped
	GPT164_GTCR_CST_0 = 0x0
	// Count operation is performed
	GPT164_GTCR_CST_1 = 0x1
	// Position of MD field.
	GPT164_GTCR_MD_Pos = 0x10
	// Bit mask of MD field.
	GPT164_GTCR_MD_Msk = 0x70000
	// Saw-wave PWM mode (single buffer or double buffer possible)
	GPT164_GTCR_MD_000 = 0x0
	// Saw-wave one-shot pulse mode (fixed buffer operation)
	GPT164_GTCR_MD_001 = 0x1
	// Setting prohibited
	GPT164_GTCR_MD_010 = 0x2
	// Setting prohibited
	GPT164_GTCR_MD_011 = 0x3
	// Triangle-wave PWM mode 1 (32-bit transfer at trough) (single buffer or double buffer is possible)
	GPT164_GTCR_MD_100 = 0x4
	// Triangle-wave PWM mode 2 (32-bit transfer at crest and trough) (single buffer or double buffer is possible)
	GPT164_GTCR_MD_101 = 0x5
	// Triangle-wave PWM mode 3 (64-bit transfer at trough) (fixed buffer operation)
	GPT164_GTCR_MD_110 = 0x6
	// Setting prohibited
	GPT164_GTCR_MD_111 = 0x7
	// Position of TPCS field.
	GPT164_GTCR_TPCS_Pos = 0x17
	// Bit mask of TPCS field.
	GPT164_GTCR_TPCS_Msk = 0x7800000
	// PCLKD/1
	GPT164_GTCR_TPCS_0x0 = 0x0
	// PCLKD/2
	GPT164_GTCR_TPCS_0x1 = 0x1
	// PCLKD/4
	GPT164_GTCR_TPCS_0x2 = 0x2
	// PCLKD/8
	GPT164_GTCR_TPCS_0x3 = 0x3
	// PCLKD/16
	GPT164_GTCR_TPCS_0x4 = 0x4
	// PCLKD/32
	GPT164_GTCR_TPCS_0x5 = 0x5
	// PCLKD/64
	GPT164_GTCR_TPCS_0x6 = 0x6
	// Setting prohibited
	GPT164_GTCR_TPCS_0x7 = 0x7
	// PCLKD/256
	GPT164_GTCR_TPCS_0x8 = 0x8
	// Setting prohibited
	GPT164_GTCR_TPCS_0x9 = 0x9
	// PCLKD/1024
	GPT164_GTCR_TPCS_0xA = 0xa
	// Setting prohibited
	GPT164_GTCR_TPCS_0xB = 0xb
	// GTETRGA (Via the POEG)
	GPT164_GTCR_TPCS_0xC = 0xc
	// GTETRGB (Via the POEG)
	GPT164_GTCR_TPCS_0xD = 0xd
	// GTETRGC (Via the POEG)
	GPT164_GTCR_TPCS_0xE = 0xe
	// GTETRGD (Via the POEG)
	GPT164_GTCR_TPCS_0xF = 0xf

	// GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
	// Position of UD field.
	GPT164_GTUDDTYC_UD_Pos = 0x0
	// Bit mask of UD field.
	GPT164_GTUDDTYC_UD_Msk = 0x1
	// Bit UD.
	GPT164_GTUDDTYC_UD = 0x1
	// GTCNT counts down
	GPT164_GTUDDTYC_UD_0 = 0x0
	// GTCNT counts up
	GPT164_GTUDDTYC_UD_1 = 0x1
	// Position of UDF field.
	GPT164_GTUDDTYC_UDF_Pos = 0x1
	// Bit mask of UDF field.
	GPT164_GTUDDTYC_UDF_Msk = 0x2
	// Bit UDF.
	GPT164_GTUDDTYC_UDF = 0x2
	// Not forcibly set
	GPT164_GTUDDTYC_UDF_0 = 0x0
	// Forcibly set
	GPT164_GTUDDTYC_UDF_1 = 0x1
	// Position of OADTY field.
	GPT164_GTUDDTYC_OADTY_Pos = 0x10
	// Bit mask of OADTY field.
	GPT164_GTUDDTYC_OADTY_Msk = 0x30000
	// GTIOCnA pin duty depends on the compare match
	GPT164_GTUDDTYC_OADTY_00 = 0x0
	// GTIOCnA pin duty depends on the compare match
	GPT164_GTUDDTYC_OADTY_01 = 0x1
	// GTIOCnA pin duty 0%
	GPT164_GTUDDTYC_OADTY_10 = 0x2
	// GTIOCnA pin duty 100%
	GPT164_GTUDDTYC_OADTY_11 = 0x3
	// Position of OADTYF field.
	GPT164_GTUDDTYC_OADTYF_Pos = 0x12
	// Bit mask of OADTYF field.
	GPT164_GTUDDTYC_OADTYF_Msk = 0x40000
	// Bit OADTYF.
	GPT164_GTUDDTYC_OADTYF = 0x40000
	// Not forcibly set
	GPT164_GTUDDTYC_OADTYF_0 = 0x0
	// Forcibly set
	GPT164_GTUDDTYC_OADTYF_1 = 0x1
	// Position of OADTYR field.
	GPT164_GTUDDTYC_OADTYR_Pos = 0x13
	// Bit mask of OADTYR field.
	GPT164_GTUDDTYC_OADTYR_Msk = 0x80000
	// Bit OADTYR.
	GPT164_GTUDDTYC_OADTYR = 0x80000
	// The function selected by the GTIOA[3:2] bits is applied to the output value when the duty cycle is set after release from the 0 or 100% duty-cycle setting.
	GPT164_GTUDDTYC_OADTYR_0 = 0x0
	// The function selected by the GTIOA[3:2] bits is applied to the compare match output value which is masked after release from the 0 or 100% duty-cycle setting.
	GPT164_GTUDDTYC_OADTYR_1 = 0x1
	// Position of OBDTY field.
	GPT164_GTUDDTYC_OBDTY_Pos = 0x18
	// Bit mask of OBDTY field.
	GPT164_GTUDDTYC_OBDTY_Msk = 0x3000000
	// GTIOCnB pin duty depends on the compare match
	GPT164_GTUDDTYC_OBDTY_00 = 0x0
	// GTIOCnB pin duty depends on the compare match
	GPT164_GTUDDTYC_OBDTY_01 = 0x1
	// GTIOCnB pin duty 0%
	GPT164_GTUDDTYC_OBDTY_10 = 0x2
	// GTIOCnB pin duty 100%
	GPT164_GTUDDTYC_OBDTY_11 = 0x3
	// Position of OBDTYF field.
	GPT164_GTUDDTYC_OBDTYF_Pos = 0x1a
	// Bit mask of OBDTYF field.
	GPT164_GTUDDTYC_OBDTYF_Msk = 0x4000000
	// Bit OBDTYF.
	GPT164_GTUDDTYC_OBDTYF = 0x4000000
	// Not forcibly set
	GPT164_GTUDDTYC_OBDTYF_0 = 0x0
	// Forcibly set
	GPT164_GTUDDTYC_OBDTYF_1 = 0x1
	// Position of OBDTYR field.
	GPT164_GTUDDTYC_OBDTYR_Pos = 0x1b
	// Bit mask of OBDTYR field.
	GPT164_GTUDDTYC_OBDTYR_Msk = 0x8000000
	// Bit OBDTYR.
	GPT164_GTUDDTYC_OBDTYR = 0x8000000
	// The function selected by the GTIOB[3:2] bits is applied to the output value when the duty cycle is set after release from the 0 or 100% duty-cycle setting.
	GPT164_GTUDDTYC_OBDTYR_0 = 0x0
	// The function selected by the GTIOB[3:2] bits is applied to the compare match output value which is masked after release from the 0 or 100% duty-cycle setting.
	GPT164_GTUDDTYC_OBDTYR_1 = 0x1

	// GTIOR: General PWM Timer I/O Control Register
	// Position of GTIOA field.
	GPT164_GTIOR_GTIOA_Pos = 0x0
	// Bit mask of GTIOA field.
	GPT164_GTIOR_GTIOA_Msk = 0x1f
	// Position of OADFLT field.
	GPT164_GTIOR_OADFLT_Pos = 0x6
	// Bit mask of OADFLT field.
	GPT164_GTIOR_OADFLT_Msk = 0x40
	// Bit OADFLT.
	GPT164_GTIOR_OADFLT = 0x40
	// The GTIOCnA pin outputs low when counting stops
	GPT164_GTIOR_OADFLT_0 = 0x0
	// The GTIOCnA pin outputs high when counting stops
	GPT164_GTIOR_OADFLT_1 = 0x1
	// Position of OAHLD field.
	GPT164_GTIOR_OAHLD_Pos = 0x7
	// Bit mask of OAHLD field.
	GPT164_GTIOR_OAHLD_Msk = 0x80
	// Bit OAHLD.
	GPT164_GTIOR_OAHLD = 0x80
	// The GTIOCnA pin output level at the start or stop of counting depends on the register setting
	GPT164_GTIOR_OAHLD_0 = 0x0
	// The GTIOCnA pin output level is retained at the start or stop of counting
	GPT164_GTIOR_OAHLD_1 = 0x1
	// Position of OAE field.
	GPT164_GTIOR_OAE_Pos = 0x8
	// Bit mask of OAE field.
	GPT164_GTIOR_OAE_Msk = 0x100
	// Bit OAE.
	GPT164_GTIOR_OAE = 0x100
	// Output is disabled
	GPT164_GTIOR_OAE_0 = 0x0
	// Output is enabled
	GPT164_GTIOR_OAE_1 = 0x1
	// Position of OADF field.
	GPT164_GTIOR_OADF_Pos = 0x9
	// Bit mask of OADF field.
	GPT164_GTIOR_OADF_Msk = 0x600
	// None of the below options are specified
	GPT164_GTIOR_OADF_00 = 0x0
	// GTIOCnA pin is set to Hi-Z in response to controlling the output negation
	GPT164_GTIOR_OADF_01 = 0x1
	// GTIOCnA pin is set to 0 in response to controlling the output negation
	GPT164_GTIOR_OADF_10 = 0x2
	// GTIOCnA pin is set to 1 in response to controlling the output negation
	GPT164_GTIOR_OADF_11 = 0x3
	// Position of NFAEN field.
	GPT164_GTIOR_NFAEN_Pos = 0xd
	// Bit mask of NFAEN field.
	GPT164_GTIOR_NFAEN_Msk = 0x2000
	// Bit NFAEN.
	GPT164_GTIOR_NFAEN = 0x2000
	// The noise filter for the GTIOCnA pin is disabled
	GPT164_GTIOR_NFAEN_0 = 0x0
	// The noise filter for the GTIOCnA pin is enabled
	GPT164_GTIOR_NFAEN_1 = 0x1
	// Position of NFCSA field.
	GPT164_GTIOR_NFCSA_Pos = 0xe
	// Bit mask of NFCSA field.
	GPT164_GTIOR_NFCSA_Msk = 0xc000
	// PCLKD/1
	GPT164_GTIOR_NFCSA_00 = 0x0
	// PCLKD/4
	GPT164_GTIOR_NFCSA_01 = 0x1
	// PCLKD/16
	GPT164_GTIOR_NFCSA_10 = 0x2
	// PCLKD/64
	GPT164_GTIOR_NFCSA_11 = 0x3
	// Position of GTIOB field.
	GPT164_GTIOR_GTIOB_Pos = 0x10
	// Bit mask of GTIOB field.
	GPT164_GTIOR_GTIOB_Msk = 0x1f0000
	// Position of OBDFLT field.
	GPT164_GTIOR_OBDFLT_Pos = 0x16
	// Bit mask of OBDFLT field.
	GPT164_GTIOR_OBDFLT_Msk = 0x400000
	// Bit OBDFLT.
	GPT164_GTIOR_OBDFLT = 0x400000
	// The GTIOCnB pin outputs low when counting stops
	GPT164_GTIOR_OBDFLT_0 = 0x0
	// The GTIOCnB pin outputs high when counting stops
	GPT164_GTIOR_OBDFLT_1 = 0x1
	// Position of OBHLD field.
	GPT164_GTIOR_OBHLD_Pos = 0x17
	// Bit mask of OBHLD field.
	GPT164_GTIOR_OBHLD_Msk = 0x800000
	// Bit OBHLD.
	GPT164_GTIOR_OBHLD = 0x800000
	// The GTIOCnB pin output level at the start/stop of counting depends on the register setting
	GPT164_GTIOR_OBHLD_0 = 0x0
	// The GTIOCnB pin output level is retained at the start/stop of counting
	GPT164_GTIOR_OBHLD_1 = 0x1
	// Position of OBE field.
	GPT164_GTIOR_OBE_Pos = 0x18
	// Bit mask of OBE field.
	GPT164_GTIOR_OBE_Msk = 0x1000000
	// Bit OBE.
	GPT164_GTIOR_OBE = 0x1000000
	// Output is disabled
	GPT164_GTIOR_OBE_0 = 0x0
	// Output is enabled
	GPT164_GTIOR_OBE_1 = 0x1
	// Position of OBDF field.
	GPT164_GTIOR_OBDF_Pos = 0x19
	// Bit mask of OBDF field.
	GPT164_GTIOR_OBDF_Msk = 0x6000000
	// None of the below options are specified
	GPT164_GTIOR_OBDF_00 = 0x0
	// GTIOCnB pin is set to Hi-Z in response to controlling the output negation
	GPT164_GTIOR_OBDF_01 = 0x1
	// GTIOCnB pin is set to 0 in response to controlling the output negation
	GPT164_GTIOR_OBDF_10 = 0x2
	// GTIOCnB pin is set to 1 in response to controlling the output negation
	GPT164_GTIOR_OBDF_11 = 0x3
	// Position of NFBEN field.
	GPT164_GTIOR_NFBEN_Pos = 0x1d
	// Bit mask of NFBEN field.
	GPT164_GTIOR_NFBEN_Msk = 0x20000000
	// Bit NFBEN.
	GPT164_GTIOR_NFBEN = 0x20000000
	// The noise filter for the GTIOCnB pin is disabled
	GPT164_GTIOR_NFBEN_0 = 0x0
	// The noise filter for the GTIOCnB pin is enabled
	GPT164_GTIOR_NFBEN_1 = 0x1
	// Position of NFCSB field.
	GPT164_GTIOR_NFCSB_Pos = 0x1e
	// Bit mask of NFCSB field.
	GPT164_GTIOR_NFCSB_Msk = 0xc0000000
	// PCLKD/1
	GPT164_GTIOR_NFCSB_00 = 0x0
	// PCLKD/4
	GPT164_GTIOR_NFCSB_01 = 0x1
	// PCLKD/16
	GPT164_GTIOR_NFCSB_10 = 0x2
	// PCLKD/64
	GPT164_GTIOR_NFCSB_11 = 0x3

	// GTINTAD: General PWM Timer Interrupt Output Setting Register
	// Position of GRP field.
	GPT164_GTINTAD_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT164_GTINTAD_GRP_Msk = 0x3000000
	// Group A output disable request is selected
	GPT164_GTINTAD_GRP_00 = 0x0
	// Group B output disable request is selected
	GPT164_GTINTAD_GRP_01 = 0x1
	// Group C output disable request is selected
	GPT164_GTINTAD_GRP_10 = 0x2
	// Group D output disable request is selected
	GPT164_GTINTAD_GRP_11 = 0x3
	// Position of GRPABH field.
	GPT164_GTINTAD_GRPABH_Pos = 0x1d
	// Bit mask of GRPABH field.
	GPT164_GTINTAD_GRPABH_Msk = 0x20000000
	// Bit GRPABH.
	GPT164_GTINTAD_GRPABH = 0x20000000
	// Same time output level high disable request disabled
	GPT164_GTINTAD_GRPABH_0 = 0x0
	// Same time output level high disable request enabled
	GPT164_GTINTAD_GRPABH_1 = 0x1
	// Position of GRPABL field.
	GPT164_GTINTAD_GRPABL_Pos = 0x1e
	// Bit mask of GRPABL field.
	GPT164_GTINTAD_GRPABL_Msk = 0x40000000
	// Bit GRPABL.
	GPT164_GTINTAD_GRPABL = 0x40000000
	// Same time output level low disable request disabled
	GPT164_GTINTAD_GRPABL_0 = 0x0
	// Same time output level low disable request enabled
	GPT164_GTINTAD_GRPABL_1 = 0x1

	// GTST: General PWM Timer Status Register
	// Position of TCFA field.
	GPT164_GTST_TCFA_Pos = 0x0
	// Bit mask of TCFA field.
	GPT164_GTST_TCFA_Msk = 0x1
	// Bit TCFA.
	GPT164_GTST_TCFA = 0x1
	// No input capture/compare match of GTCCRA is generated
	GPT164_GTST_TCFA_0 = 0x0
	// An input capture/compare match of GTCCRA is generated
	GPT164_GTST_TCFA_1 = 0x1
	// Position of TCFB field.
	GPT164_GTST_TCFB_Pos = 0x1
	// Bit mask of TCFB field.
	GPT164_GTST_TCFB_Msk = 0x2
	// Bit TCFB.
	GPT164_GTST_TCFB = 0x2
	// No input capture/compare match of GTCCRB is generated
	GPT164_GTST_TCFB_0 = 0x0
	// An input capture/compare match of GTCCRB is generated
	GPT164_GTST_TCFB_1 = 0x1
	// Position of TCFC field.
	GPT164_GTST_TCFC_Pos = 0x2
	// Bit mask of TCFC field.
	GPT164_GTST_TCFC_Msk = 0x4
	// Bit TCFC.
	GPT164_GTST_TCFC = 0x4
	// No compare match of GTCCRC is generated
	GPT164_GTST_TCFC_0 = 0x0
	// A compare match of GTCCRC is generated
	GPT164_GTST_TCFC_1 = 0x1
	// Position of TCFD field.
	GPT164_GTST_TCFD_Pos = 0x3
	// Bit mask of TCFD field.
	GPT164_GTST_TCFD_Msk = 0x8
	// Bit TCFD.
	GPT164_GTST_TCFD = 0x8
	// No compare match of GTCCRD is generated
	GPT164_GTST_TCFD_0 = 0x0
	// A compare match of GTCCRD is generated
	GPT164_GTST_TCFD_1 = 0x1
	// Position of TCFE field.
	GPT164_GTST_TCFE_Pos = 0x4
	// Bit mask of TCFE field.
	GPT164_GTST_TCFE_Msk = 0x10
	// Bit TCFE.
	GPT164_GTST_TCFE = 0x10
	// No compare match of GTCCRE is generated
	GPT164_GTST_TCFE_0 = 0x0
	// A compare match of GTCCRE is generated
	GPT164_GTST_TCFE_1 = 0x1
	// Position of TCFF field.
	GPT164_GTST_TCFF_Pos = 0x5
	// Bit mask of TCFF field.
	GPT164_GTST_TCFF_Msk = 0x20
	// Bit TCFF.
	GPT164_GTST_TCFF = 0x20
	// No compare match of GTCCRF is generated
	GPT164_GTST_TCFF_0 = 0x0
	// A compare match of GTCCRF is generated
	GPT164_GTST_TCFF_1 = 0x1
	// Position of TCFPO field.
	GPT164_GTST_TCFPO_Pos = 0x6
	// Bit mask of TCFPO field.
	GPT164_GTST_TCFPO_Msk = 0x40
	// Bit TCFPO.
	GPT164_GTST_TCFPO = 0x40
	// No overflow (crest) occurred
	GPT164_GTST_TCFPO_0 = 0x0
	// An overflow (crest) occurred
	GPT164_GTST_TCFPO_1 = 0x1
	// Position of TCFPU field.
	GPT164_GTST_TCFPU_Pos = 0x7
	// Bit mask of TCFPU field.
	GPT164_GTST_TCFPU_Msk = 0x80
	// Bit TCFPU.
	GPT164_GTST_TCFPU = 0x80
	// No underflow (trough) occurred
	GPT164_GTST_TCFPU_0 = 0x0
	// An underflow (trough) occurred
	GPT164_GTST_TCFPU_1 = 0x1
	// Position of TUCF field.
	GPT164_GTST_TUCF_Pos = 0xf
	// Bit mask of TUCF field.
	GPT164_GTST_TUCF_Msk = 0x8000
	// Bit TUCF.
	GPT164_GTST_TUCF = 0x8000
	// GTCNT counter counts downward
	GPT164_GTST_TUCF_0 = 0x0
	// GTCNT counter counts upward
	GPT164_GTST_TUCF_1 = 0x1
	// Position of ODF field.
	GPT164_GTST_ODF_Pos = 0x18
	// Bit mask of ODF field.
	GPT164_GTST_ODF_Msk = 0x1000000
	// Bit ODF.
	GPT164_GTST_ODF = 0x1000000
	// No output disable request is generated
	GPT164_GTST_ODF_0 = 0x0
	// An output disable request is generated
	GPT164_GTST_ODF_1 = 0x1
	// Position of OABHF field.
	GPT164_GTST_OABHF_Pos = 0x1d
	// Bit mask of OABHF field.
	GPT164_GTST_OABHF_Msk = 0x20000000
	// Bit OABHF.
	GPT164_GTST_OABHF = 0x20000000
	// No simultaneous generation of 1 both for the GTIOCA and GTIOCB pins has occurred.
	GPT164_GTST_OABHF_0 = 0x0
	// A simultaneous generation of 1 both for the GTIOCA and GTIOCB pins has occurred.
	GPT164_GTST_OABHF_1 = 0x1
	// Position of OABLF field.
	GPT164_GTST_OABLF_Pos = 0x1e
	// Bit mask of OABLF field.
	GPT164_GTST_OABLF_Msk = 0x40000000
	// Bit OABLF.
	GPT164_GTST_OABLF = 0x40000000
	// No simultaneous generation of 0 both for the GTIOCA and GTIOCB pins has occurred.
	GPT164_GTST_OABLF_0 = 0x0
	// A simultaneous generation of 0 both for the GTIOCA and GTIOCB pins has occurred.
	GPT164_GTST_OABLF_1 = 0x1
	// Position of PCF field.
	GPT164_GTST_PCF_Pos = 0x1f
	// Bit mask of PCF field.
	GPT164_GTST_PCF_Msk = 0x80000000
	// Bit PCF.
	GPT164_GTST_PCF = 0x80000000
	// No period count function finish has occurred
	GPT164_GTST_PCF_0 = 0x0
	// A period count function finish has occurred
	GPT164_GTST_PCF_1 = 0x1

	// GTBER: General PWM Timer Buffer Enable Register
	// Position of BD0 field.
	GPT164_GTBER_BD0_Pos = 0x0
	// Bit mask of BD0 field.
	GPT164_GTBER_BD0_Msk = 0x1
	// Bit BD0.
	GPT164_GTBER_BD0 = 0x1
	// Buffer operation is enabled
	GPT164_GTBER_BD0_0 = 0x0
	// Buffer operation is disabled
	GPT164_GTBER_BD0_1 = 0x1
	// Position of BD1 field.
	GPT164_GTBER_BD1_Pos = 0x1
	// Bit mask of BD1 field.
	GPT164_GTBER_BD1_Msk = 0x2
	// Bit BD1.
	GPT164_GTBER_BD1 = 0x2
	// Buffer operation is enabled
	GPT164_GTBER_BD1_0 = 0x0
	// Buffer operation is disabled
	GPT164_GTBER_BD1_1 = 0x1
	// Position of CCRA field.
	GPT164_GTBER_CCRA_Pos = 0x10
	// Bit mask of CCRA field.
	GPT164_GTBER_CCRA_Msk = 0x30000
	// No buffer operation
	GPT164_GTBER_CCRA_00 = 0x0
	// Single buffer operation (GTCCRA <---->GTCCRC)
	GPT164_GTBER_CCRA_01 = 0x1
	// Position of CCRB field.
	GPT164_GTBER_CCRB_Pos = 0x12
	// Bit mask of CCRB field.
	GPT164_GTBER_CCRB_Msk = 0xc0000
	// No buffer operation
	GPT164_GTBER_CCRB_00 = 0x0
	// Single buffer operation (GTCCRB <----> GTCCRE)
	GPT164_GTBER_CCRB_01 = 0x1
	// Position of PR field.
	GPT164_GTBER_PR_Pos = 0x14
	// Bit mask of PR field.
	GPT164_GTBER_PR_Msk = 0x300000
	// No buffer operation
	GPT164_GTBER_PR_00 = 0x0
	// Single buffer operation (GTPBR --> GTPR)
	GPT164_GTBER_PR_01 = 0x1
	// Position of CCRSWT field.
	GPT164_GTBER_CCRSWT_Pos = 0x16
	// Bit mask of CCRSWT field.
	GPT164_GTBER_CCRSWT_Msk = 0x400000
	// Bit CCRSWT.
	GPT164_GTBER_CCRSWT = 0x400000

	// GTDTCR: General PWM Timer Dead Time Control Register
	// Position of TDE field.
	GPT164_GTDTCR_TDE_Pos = 0x0
	// Bit mask of TDE field.
	GPT164_GTDTCR_TDE_Msk = 0x1
	// Bit TDE.
	GPT164_GTDTCR_TDE = 0x1
	// GTCCRB is set without using GTDVU
	GPT164_GTDTCR_TDE_0 = 0x0
	// GTDVU is used to set the compare match value for negative-phase waveform with dead time automatically in GTCCRB
	GPT164_GTDTCR_TDE_1 = 0x1

	// GTICLF: General PWM Timer Inter Channel Logical Operation Function Setting Register
	// Position of ICLFA field.
	GPT164_GTICLF_ICLFA_Pos = 0x0
	// Bit mask of ICLFA field.
	GPT164_GTICLF_ICLFA_Msk = 0x7
	// A (no delay)
	GPT164_GTICLF_ICLFA_000 = 0x0
	// NOT A (no delay)
	GPT164_GTICLF_ICLFA_001 = 0x1
	// C (1PCLKD delay)
	GPT164_GTICLF_ICLFA_010 = 0x2
	// NOT C (1PCLKD delay)
	GPT164_GTICLF_ICLFA_011 = 0x3
	// A AND C (1PCLKD delay)
	GPT164_GTICLF_ICLFA_100 = 0x4
	// A OR C (1PCLKD delay)
	GPT164_GTICLF_ICLFA_101 = 0x5
	// A EXOR C (1PCLKD delay)
	GPT164_GTICLF_ICLFA_110 = 0x6
	// A NOR C (1PCLKD delay)
	GPT164_GTICLF_ICLFA_111 = 0x7
	// Position of ICLFSELC field.
	GPT164_GTICLF_ICLFSELC_Pos = 0x4
	// Bit mask of ICLFSELC field.
	GPT164_GTICLF_ICLFSELC_Msk = 0x3f0
	// GTIOC0A
	GPT164_GTICLF_ICLFSELC_0x00 = 0x0
	// GTIOC0B
	GPT164_GTICLF_ICLFSELC_0x01 = 0x1
	// GTIOC1A
	GPT164_GTICLF_ICLFSELC_0x02 = 0x2
	// GTIOC1B
	GPT164_GTICLF_ICLFSELC_0x03 = 0x3
	// GTIOC2A
	GPT164_GTICLF_ICLFSELC_0x04 = 0x4
	// GTIOC2B
	GPT164_GTICLF_ICLFSELC_0x05 = 0x5
	// GTIOC3A
	GPT164_GTICLF_ICLFSELC_0x06 = 0x6
	// GTIOC3B
	GPT164_GTICLF_ICLFSELC_0x07 = 0x7
	// GTIOC4A
	GPT164_GTICLF_ICLFSELC_0x08 = 0x8
	// GTIOC4B
	GPT164_GTICLF_ICLFSELC_0x09 = 0x9
	// GTIOC5A
	GPT164_GTICLF_ICLFSELC_0x0A = 0xa
	// GTIOC5B
	GPT164_GTICLF_ICLFSELC_0x0B = 0xb
	// GTIOC6A
	GPT164_GTICLF_ICLFSELC_0x0C = 0xc
	// GTIOC6B
	GPT164_GTICLF_ICLFSELC_0x0D = 0xd
	// GTIOC7A
	GPT164_GTICLF_ICLFSELC_0x0E = 0xe
	// GTIOC7B
	GPT164_GTICLF_ICLFSELC_0x0F = 0xf
	// GTIOC8A
	GPT164_GTICLF_ICLFSELC_0x10 = 0x10
	// GTIOC8B
	GPT164_GTICLF_ICLFSELC_0x11 = 0x11
	// GTIOC9A
	GPT164_GTICLF_ICLFSELC_0x12 = 0x12
	// GTIOC9B
	GPT164_GTICLF_ICLFSELC_0x13 = 0x13
	// Position of ICLFB field.
	GPT164_GTICLF_ICLFB_Pos = 0x10
	// Bit mask of ICLFB field.
	GPT164_GTICLF_ICLFB_Msk = 0x70000
	// B (no delay)
	GPT164_GTICLF_ICLFB_000 = 0x0
	// NOT B (no delay)
	GPT164_GTICLF_ICLFB_001 = 0x1
	// D (1PCLKD delay)
	GPT164_GTICLF_ICLFB_010 = 0x2
	// NOT D (1PCLKD delay)
	GPT164_GTICLF_ICLFB_011 = 0x3
	// B AND D (1PCLKD delay)
	GPT164_GTICLF_ICLFB_100 = 0x4
	// B OR D (1PCLKDn delay)
	GPT164_GTICLF_ICLFB_101 = 0x5
	// B EXOR D (1PCLKD delay)
	GPT164_GTICLF_ICLFB_110 = 0x6
	// B NOR D (1PCLKD delay)
	GPT164_GTICLF_ICLFB_111 = 0x7
	// Position of ICLFSELD field.
	GPT164_GTICLF_ICLFSELD_Pos = 0x14
	// Bit mask of ICLFSELD field.
	GPT164_GTICLF_ICLFSELD_Msk = 0x3f00000
	// GTIOC0A
	GPT164_GTICLF_ICLFSELD_0x00 = 0x0
	// GTIOC0B
	GPT164_GTICLF_ICLFSELD_0x01 = 0x1
	// GTIOC1A
	GPT164_GTICLF_ICLFSELD_0x02 = 0x2
	// GTIOC1B
	GPT164_GTICLF_ICLFSELD_0x03 = 0x3
	// GTIOC2A
	GPT164_GTICLF_ICLFSELD_0x04 = 0x4
	// GTIOC2B
	GPT164_GTICLF_ICLFSELD_0x05 = 0x5
	// GTIOC3A
	GPT164_GTICLF_ICLFSELD_0x06 = 0x6
	// GTIOC3B
	GPT164_GTICLF_ICLFSELD_0x07 = 0x7
	// GTIOC4A
	GPT164_GTICLF_ICLFSELD_0x08 = 0x8
	// GTIOC4B
	GPT164_GTICLF_ICLFSELD_0x09 = 0x9
	// GTIOC5A
	GPT164_GTICLF_ICLFSELD_0x0A = 0xa
	// GTIOC5B
	GPT164_GTICLF_ICLFSELD_0x0B = 0xb
	// GTIOC6A
	GPT164_GTICLF_ICLFSELD_0x0C = 0xc
	// GTIOC6B
	GPT164_GTICLF_ICLFSELD_0x0D = 0xd
	// GTIOC7A
	GPT164_GTICLF_ICLFSELD_0x0E = 0xe
	// GTIOC7B
	GPT164_GTICLF_ICLFSELD_0x0F = 0xf
	// GTIOC8A
	GPT164_GTICLF_ICLFSELD_0x10 = 0x10
	// GTIOC8B
	GPT164_GTICLF_ICLFSELD_0x11 = 0x11
	// GTIOC9A
	GPT164_GTICLF_ICLFSELD_0x12 = 0x12
	// GTIOC9B
	GPT164_GTICLF_ICLFSELD_0x13 = 0x13

	// GTPC: General PWM Timer Period Count Register
	// Position of PCEN field.
	GPT164_GTPC_PCEN_Pos = 0x0
	// Bit mask of PCEN field.
	GPT164_GTPC_PCEN_Msk = 0x1
	// Bit PCEN.
	GPT164_GTPC_PCEN = 0x1
	// Period count function is disabled
	GPT164_GTPC_PCEN_0 = 0x0
	// Period count function is enabled
	GPT164_GTPC_PCEN_1 = 0x1
	// Position of ASTP field.
	GPT164_GTPC_ASTP_Pos = 0x8
	// Bit mask of ASTP field.
	GPT164_GTPC_ASTP_Msk = 0x100
	// Bit ASTP.
	GPT164_GTPC_ASTP = 0x100
	// Automatic stop function is disabled
	GPT164_GTPC_ASTP_0 = 0x0
	// Automatic stop function is enabled
	GPT164_GTPC_ASTP_1 = 0x1
	// Position of PCNT field.
	GPT164_GTPC_PCNT_Pos = 0x10
	// Bit mask of PCNT field.
	GPT164_GTPC_PCNT_Msk = 0xfff0000

	// GTSECSR: General PWM Timer Operation Enable Bit Simultaneous Control Channel Select Register
	// Position of SECSEL0 field.
	GPT164_GTSECSR_SECSEL0_Pos = 0x0
	// Bit mask of SECSEL0 field.
	GPT164_GTSECSR_SECSEL0_Msk = 0x1
	// Bit SECSEL0.
	GPT164_GTSECSR_SECSEL0 = 0x1
	// Disable simultaneous control
	GPT164_GTSECSR_SECSEL0_0 = 0x0
	// Enable simultaneous control
	GPT164_GTSECSR_SECSEL0_1 = 0x1
	// Position of SECSEL1 field.
	GPT164_GTSECSR_SECSEL1_Pos = 0x1
	// Bit mask of SECSEL1 field.
	GPT164_GTSECSR_SECSEL1_Msk = 0x2
	// Bit SECSEL1.
	GPT164_GTSECSR_SECSEL1 = 0x2
	// Disable simultaneous control
	GPT164_GTSECSR_SECSEL1_0 = 0x0
	// Enable simultaneous control
	GPT164_GTSECSR_SECSEL1_1 = 0x1
	// Position of SECSEL2 field.
	GPT164_GTSECSR_SECSEL2_Pos = 0x2
	// Bit mask of SECSEL2 field.
	GPT164_GTSECSR_SECSEL2_Msk = 0x4
	// Bit SECSEL2.
	GPT164_GTSECSR_SECSEL2 = 0x4
	// Disable simultaneous control
	GPT164_GTSECSR_SECSEL2_0 = 0x0
	// Enable simultaneous control
	GPT164_GTSECSR_SECSEL2_1 = 0x1
	// Position of SECSEL3 field.
	GPT164_GTSECSR_SECSEL3_Pos = 0x3
	// Bit mask of SECSEL3 field.
	GPT164_GTSECSR_SECSEL3_Msk = 0x8
	// Bit SECSEL3.
	GPT164_GTSECSR_SECSEL3 = 0x8
	// Disable simultaneous control
	GPT164_GTSECSR_SECSEL3_0 = 0x0
	// Enable simultaneous control
	GPT164_GTSECSR_SECSEL3_1 = 0x1
	// Position of SECSEL4 field.
	GPT164_GTSECSR_SECSEL4_Pos = 0x4
	// Bit mask of SECSEL4 field.
	GPT164_GTSECSR_SECSEL4_Msk = 0x10
	// Bit SECSEL4.
	GPT164_GTSECSR_SECSEL4 = 0x10
	// Disable simultaneous control
	GPT164_GTSECSR_SECSEL4_0 = 0x0
	// Enable simultaneous control
	GPT164_GTSECSR_SECSEL4_1 = 0x1
	// Position of SECSEL5 field.
	GPT164_GTSECSR_SECSEL5_Pos = 0x5
	// Bit mask of SECSEL5 field.
	GPT164_GTSECSR_SECSEL5_Msk = 0x20
	// Bit SECSEL5.
	GPT164_GTSECSR_SECSEL5 = 0x20
	// Disable simultaneous control
	GPT164_GTSECSR_SECSEL5_0 = 0x0
	// Enable simultaneous control
	GPT164_GTSECSR_SECSEL5_1 = 0x1
	// Position of SECSEL6 field.
	GPT164_GTSECSR_SECSEL6_Pos = 0x6
	// Bit mask of SECSEL6 field.
	GPT164_GTSECSR_SECSEL6_Msk = 0x40
	// Bit SECSEL6.
	GPT164_GTSECSR_SECSEL6 = 0x40
	// Disable simultaneous control
	GPT164_GTSECSR_SECSEL6_0 = 0x0
	// Enable simultaneous control
	GPT164_GTSECSR_SECSEL6_1 = 0x1
	// Position of SECSEL7 field.
	GPT164_GTSECSR_SECSEL7_Pos = 0x7
	// Bit mask of SECSEL7 field.
	GPT164_GTSECSR_SECSEL7_Msk = 0x80
	// Bit SECSEL7.
	GPT164_GTSECSR_SECSEL7 = 0x80
	// Disable simultaneous control
	GPT164_GTSECSR_SECSEL7_0 = 0x0
	// Enable simultaneous control
	GPT164_GTSECSR_SECSEL7_1 = 0x1
	// Position of SECSEL8 field.
	GPT164_GTSECSR_SECSEL8_Pos = 0x8
	// Bit mask of SECSEL8 field.
	GPT164_GTSECSR_SECSEL8_Msk = 0x100
	// Bit SECSEL8.
	GPT164_GTSECSR_SECSEL8 = 0x100
	// Disable simultaneous control
	GPT164_GTSECSR_SECSEL8_0 = 0x0
	// Enable simultaneous control
	GPT164_GTSECSR_SECSEL8_1 = 0x1
	// Position of SECSEL9 field.
	GPT164_GTSECSR_SECSEL9_Pos = 0x9
	// Bit mask of SECSEL9 field.
	GPT164_GTSECSR_SECSEL9_Msk = 0x200
	// Bit SECSEL9.
	GPT164_GTSECSR_SECSEL9 = 0x200
	// Disable simultaneous control
	GPT164_GTSECSR_SECSEL9_0 = 0x0
	// Enable simultaneous control
	GPT164_GTSECSR_SECSEL9_1 = 0x1

	// GTSECR: General PWM Timer Operation Enable Bit Simultaneous Control Register
	// Position of SBDCE field.
	GPT164_GTSECR_SBDCE_Pos = 0x0
	// Bit mask of SBDCE field.
	GPT164_GTSECR_SBDCE_Msk = 0x1
	// Bit SBDCE.
	GPT164_GTSECR_SBDCE = 0x1
	// Disable simultaneous enabling GTCCR buffer operations
	GPT164_GTSECR_SBDCE_0 = 0x0
	// Enable GTCCR register buffer operations simultaneously
	GPT164_GTSECR_SBDCE_1 = 0x1
	// Position of SBDPE field.
	GPT164_GTSECR_SBDPE_Pos = 0x1
	// Bit mask of SBDPE field.
	GPT164_GTSECR_SBDPE_Msk = 0x2
	// Bit SBDPE.
	GPT164_GTSECR_SBDPE = 0x2
	// Disable simultaneous enabling GTPR buffer operations
	GPT164_GTSECR_SBDPE_0 = 0x0
	// Enable GTPR register buffer operations simultaneously
	GPT164_GTSECR_SBDPE_1 = 0x1
	// Position of SBDCD field.
	GPT164_GTSECR_SBDCD_Pos = 0x8
	// Bit mask of SBDCD field.
	GPT164_GTSECR_SBDCD_Msk = 0x100
	// Bit SBDCD.
	GPT164_GTSECR_SBDCD = 0x100
	// Disable simultaneous disabling GTCCR buffer operations
	GPT164_GTSECR_SBDCD_0 = 0x0
	// Disable GTCCR register buffer operations simultaneously
	GPT164_GTSECR_SBDCD_1 = 0x1
	// Position of SBDPD field.
	GPT164_GTSECR_SBDPD_Pos = 0x9
	// Bit mask of SBDPD field.
	GPT164_GTSECR_SBDPD_Msk = 0x200
	// Bit SBDPD.
	GPT164_GTSECR_SBDPD = 0x200
	// Disable simultaneous disabling GTPR buffer operations
	GPT164_GTSECR_SBDPD_0 = 0x0
	// Disable GTPR register buffer operations simultaneously
	GPT164_GTSECR_SBDPD_1 = 0x1
	// Position of SPCE field.
	GPT164_GTSECR_SPCE_Pos = 0x10
	// Bit mask of SPCE field.
	GPT164_GTSECR_SPCE_Msk = 0x10000
	// Bit SPCE.
	GPT164_GTSECR_SPCE = 0x10000
	// Disable simultaneous enabling period count function
	GPT164_GTSECR_SPCE_0 = 0x0
	// Enable period count function simultaneously
	GPT164_GTSECR_SPCE_1 = 0x1
	// Position of SPCD field.
	GPT164_GTSECR_SPCD_Pos = 0x18
	// Bit mask of SPCD field.
	GPT164_GTSECR_SPCD_Msk = 0x1000000
	// Bit SPCD.
	GPT164_GTSECR_SPCD = 0x1000000
	// Disable simultaneous disabling period count function
	GPT164_GTSECR_SPCD_0 = 0x0
	// Disable period count function simultaneously
	GPT164_GTSECR_SPCD_1 = 0x1
)

// Constants for ADC120: 12-bit A/D Converter
const (
	// ADCSR: A/D Control Register
	// Position of DBLANS field.
	ADC120_ADCSR_DBLANS_Pos = 0x0
	// Bit mask of DBLANS field.
	ADC120_ADCSR_DBLANS_Msk = 0x1f
	// Position of GBADIE field.
	ADC120_ADCSR_GBADIE_Pos = 0x6
	// Bit mask of GBADIE field.
	ADC120_ADCSR_GBADIE_Msk = 0x40
	// Bit GBADIE.
	ADC120_ADCSR_GBADIE = 0x40
	// Disable ADC120_GBADI interrupt generation on group B scan completion.
	ADC120_ADCSR_GBADIE_0 = 0x0
	// Enable ADC120_GBADI interrupt generation on group B scan completion.
	ADC120_ADCSR_GBADIE_1 = 0x1
	// Position of DBLE field.
	ADC120_ADCSR_DBLE_Pos = 0x7
	// Bit mask of DBLE field.
	ADC120_ADCSR_DBLE_Msk = 0x80
	// Bit DBLE.
	ADC120_ADCSR_DBLE = 0x80
	// Deselect double-trigger mode.
	ADC120_ADCSR_DBLE_0 = 0x0
	// Select double-trigger mode.
	ADC120_ADCSR_DBLE_1 = 0x1
	// Position of EXTRG field.
	ADC120_ADCSR_EXTRG_Pos = 0x8
	// Bit mask of EXTRG field.
	ADC120_ADCSR_EXTRG_Msk = 0x100
	// Bit EXTRG.
	ADC120_ADCSR_EXTRG = 0x100
	// Start A/D conversion by the synchronous trigger (ELC).
	ADC120_ADCSR_EXTRG_0 = 0x0
	// Start A/D conversion by the asynchronous trigger (ADTRG0).
	ADC120_ADCSR_EXTRG_1 = 0x1
	// Position of TRGE field.
	ADC120_ADCSR_TRGE_Pos = 0x9
	// Bit mask of TRGE field.
	ADC120_ADCSR_TRGE_Msk = 0x200
	// Bit TRGE.
	ADC120_ADCSR_TRGE = 0x200
	// Disable A/D conversion to be started by the synchronous or asynchronous trigger
	ADC120_ADCSR_TRGE_0 = 0x0
	// Enable A/D conversion to be started by the synchronous or asynchronous trigger
	ADC120_ADCSR_TRGE_1 = 0x1
	// Position of ADCS field.
	ADC120_ADCSR_ADCS_Pos = 0xd
	// Bit mask of ADCS field.
	ADC120_ADCSR_ADCS_Msk = 0x6000
	// Single scan mode
	ADC120_ADCSR_ADCS_00 = 0x0
	// Group scan mode
	ADC120_ADCSR_ADCS_01 = 0x1
	// Continuous scan mode
	ADC120_ADCSR_ADCS_10 = 0x2
	// Setting prohibited
	ADC120_ADCSR_ADCS_11 = 0x3
	// Position of ADST field.
	ADC120_ADCSR_ADST_Pos = 0xf
	// Bit mask of ADST field.
	ADC120_ADCSR_ADST_Msk = 0x8000
	// Bit ADST.
	ADC120_ADCSR_ADST = 0x8000
	// Stop A/D conversion process.
	ADC120_ADCSR_ADST_0 = 0x0
	// Start A/D conversion process.
	ADC120_ADCSR_ADST_1 = 0x1

	// ADANSA0: A/D Channel Select Register A0
	// Position of ANSA0 field.
	ADC120_ADANSA0_ANSA0_Pos = 0x0
	// Bit mask of ANSA0 field.
	ADC120_ADANSA0_ANSA0_Msk = 0x1
	// Bit ANSA0.
	ADC120_ADANSA0_ANSA0 = 0x1
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA0_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA0_1 = 0x1
	// Position of ANSA1 field.
	ADC120_ADANSA0_ANSA1_Pos = 0x1
	// Bit mask of ANSA1 field.
	ADC120_ADANSA0_ANSA1_Msk = 0x2
	// Bit ANSA1.
	ADC120_ADANSA0_ANSA1 = 0x2
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA1_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA1_1 = 0x1
	// Position of ANSA2 field.
	ADC120_ADANSA0_ANSA2_Pos = 0x2
	// Bit mask of ANSA2 field.
	ADC120_ADANSA0_ANSA2_Msk = 0x4
	// Bit ANSA2.
	ADC120_ADANSA0_ANSA2 = 0x4
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA2_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA2_1 = 0x1
	// Position of ANSA3 field.
	ADC120_ADANSA0_ANSA3_Pos = 0x3
	// Bit mask of ANSA3 field.
	ADC120_ADANSA0_ANSA3_Msk = 0x8
	// Bit ANSA3.
	ADC120_ADANSA0_ANSA3 = 0x8
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA3_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA3_1 = 0x1
	// Position of ANSA4 field.
	ADC120_ADANSA0_ANSA4_Pos = 0x4
	// Bit mask of ANSA4 field.
	ADC120_ADANSA0_ANSA4_Msk = 0x10
	// Bit ANSA4.
	ADC120_ADANSA0_ANSA4 = 0x10
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA4_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA4_1 = 0x1
	// Position of ANSA5 field.
	ADC120_ADANSA0_ANSA5_Pos = 0x5
	// Bit mask of ANSA5 field.
	ADC120_ADANSA0_ANSA5_Msk = 0x20
	// Bit ANSA5.
	ADC120_ADANSA0_ANSA5 = 0x20
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA5_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA5_1 = 0x1
	// Position of ANSA6 field.
	ADC120_ADANSA0_ANSA6_Pos = 0x6
	// Bit mask of ANSA6 field.
	ADC120_ADANSA0_ANSA6_Msk = 0x40
	// Bit ANSA6.
	ADC120_ADANSA0_ANSA6 = 0x40
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA6_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA6_1 = 0x1
	// Position of ANSA7 field.
	ADC120_ADANSA0_ANSA7_Pos = 0x7
	// Bit mask of ANSA7 field.
	ADC120_ADANSA0_ANSA7_Msk = 0x80
	// Bit ANSA7.
	ADC120_ADANSA0_ANSA7 = 0x80
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA7_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA7_1 = 0x1
	// Position of ANSA8 field.
	ADC120_ADANSA0_ANSA8_Pos = 0x8
	// Bit mask of ANSA8 field.
	ADC120_ADANSA0_ANSA8_Msk = 0x100
	// Bit ANSA8.
	ADC120_ADANSA0_ANSA8 = 0x100
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA8_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA8_1 = 0x1
	// Position of ANSA12 field.
	ADC120_ADANSA0_ANSA12_Pos = 0xc
	// Bit mask of ANSA12 field.
	ADC120_ADANSA0_ANSA12_Msk = 0x1000
	// Bit ANSA12.
	ADC120_ADANSA0_ANSA12 = 0x1000
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA12_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA12_1 = 0x1
	// Position of ANSA13 field.
	ADC120_ADANSA0_ANSA13_Pos = 0xd
	// Bit mask of ANSA13 field.
	ADC120_ADANSA0_ANSA13_Msk = 0x2000
	// Bit ANSA13.
	ADC120_ADANSA0_ANSA13 = 0x2000
	// Do not select associated input channel.
	ADC120_ADANSA0_ANSA13_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSA0_ANSA13_1 = 0x1

	// ADADS0: A/D-Converted Value Addition/Average Channel Select Register 0
	// Position of ADS0 field.
	ADC120_ADADS0_ADS0_Pos = 0x0
	// Bit mask of ADS0 field.
	ADC120_ADADS0_ADS0_Msk = 0x1
	// Bit ADS0.
	ADC120_ADADS0_ADS0 = 0x1
	// Do not select associated input channel.
	ADC120_ADADS0_ADS0_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS0_1 = 0x1
	// Position of ADS1 field.
	ADC120_ADADS0_ADS1_Pos = 0x1
	// Bit mask of ADS1 field.
	ADC120_ADADS0_ADS1_Msk = 0x2
	// Bit ADS1.
	ADC120_ADADS0_ADS1 = 0x2
	// Do not select associated input channel.
	ADC120_ADADS0_ADS1_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS1_1 = 0x1
	// Position of ADS2 field.
	ADC120_ADADS0_ADS2_Pos = 0x2
	// Bit mask of ADS2 field.
	ADC120_ADADS0_ADS2_Msk = 0x4
	// Bit ADS2.
	ADC120_ADADS0_ADS2 = 0x4
	// Do not select associated input channel.
	ADC120_ADADS0_ADS2_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS2_1 = 0x1
	// Position of ADS3 field.
	ADC120_ADADS0_ADS3_Pos = 0x3
	// Bit mask of ADS3 field.
	ADC120_ADADS0_ADS3_Msk = 0x8
	// Bit ADS3.
	ADC120_ADADS0_ADS3 = 0x8
	// Do not select associated input channel.
	ADC120_ADADS0_ADS3_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS3_1 = 0x1
	// Position of ADS4 field.
	ADC120_ADADS0_ADS4_Pos = 0x4
	// Bit mask of ADS4 field.
	ADC120_ADADS0_ADS4_Msk = 0x10
	// Bit ADS4.
	ADC120_ADADS0_ADS4 = 0x10
	// Do not select associated input channel.
	ADC120_ADADS0_ADS4_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS4_1 = 0x1
	// Position of ADS5 field.
	ADC120_ADADS0_ADS5_Pos = 0x5
	// Bit mask of ADS5 field.
	ADC120_ADADS0_ADS5_Msk = 0x20
	// Bit ADS5.
	ADC120_ADADS0_ADS5 = 0x20
	// Do not select associated input channel.
	ADC120_ADADS0_ADS5_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS5_1 = 0x1
	// Position of ADS6 field.
	ADC120_ADADS0_ADS6_Pos = 0x6
	// Bit mask of ADS6 field.
	ADC120_ADADS0_ADS6_Msk = 0x40
	// Bit ADS6.
	ADC120_ADADS0_ADS6 = 0x40
	// Do not select associated input channel.
	ADC120_ADADS0_ADS6_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS6_1 = 0x1
	// Position of ADS7 field.
	ADC120_ADADS0_ADS7_Pos = 0x7
	// Bit mask of ADS7 field.
	ADC120_ADADS0_ADS7_Msk = 0x80
	// Bit ADS7.
	ADC120_ADADS0_ADS7 = 0x80
	// Do not select associated input channel.
	ADC120_ADADS0_ADS7_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS7_1 = 0x1
	// Position of ADS8 field.
	ADC120_ADADS0_ADS8_Pos = 0x8
	// Bit mask of ADS8 field.
	ADC120_ADADS0_ADS8_Msk = 0x100
	// Bit ADS8.
	ADC120_ADADS0_ADS8 = 0x100
	// Do not select associated input channel.
	ADC120_ADADS0_ADS8_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS8_1 = 0x1
	// Position of ADS12 field.
	ADC120_ADADS0_ADS12_Pos = 0xc
	// Bit mask of ADS12 field.
	ADC120_ADADS0_ADS12_Msk = 0x1000
	// Bit ADS12.
	ADC120_ADADS0_ADS12 = 0x1000
	// Do not select associated input channel.
	ADC120_ADADS0_ADS12_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS12_1 = 0x1
	// Position of ADS13 field.
	ADC120_ADADS0_ADS13_Pos = 0xd
	// Bit mask of ADS13 field.
	ADC120_ADADS0_ADS13_Msk = 0x2000
	// Bit ADS13.
	ADC120_ADADS0_ADS13 = 0x2000
	// Do not select associated input channel.
	ADC120_ADADS0_ADS13_0 = 0x0
	// Select associated input channel.
	ADC120_ADADS0_ADS13_1 = 0x1

	// ADADC: A/D-Converted Value Addition/Average Count Select Register
	// Position of ADC field.
	ADC120_ADADC_ADC_Pos = 0x0
	// Bit mask of ADC field.
	ADC120_ADADC_ADC_Msk = 0x7
	// 1-time conversion (no addition, same as normal conversion)
	ADC120_ADADC_ADC_000 = 0x0
	// 2-time conversion (one addition)
	ADC120_ADADC_ADC_001 = 0x1
	// 3-time conversion (two additions)
	ADC120_ADADC_ADC_010 = 0x2
	// 4-time conversion (three additions)
	ADC120_ADADC_ADC_011 = 0x3
	// 16-time conversion (15 additions)
	ADC120_ADADC_ADC_101 = 0x5
	// Position of AVEE field.
	ADC120_ADADC_AVEE_Pos = 0x7
	// Bit mask of AVEE field.
	ADC120_ADADC_AVEE_Msk = 0x80
	// Bit AVEE.
	ADC120_ADADC_AVEE = 0x80
	// Enable addition mode
	ADC120_ADADC_AVEE_0 = 0x0
	// Enable average mode
	ADC120_ADADC_AVEE_1 = 0x1

	// ADCER: A/D Control Extended Register
	// Position of ADPRC field.
	ADC120_ADCER_ADPRC_Pos = 0x1
	// Bit mask of ADPRC field.
	ADC120_ADCER_ADPRC_Msk = 0x6
	// 12-bit accuracy
	ADC120_ADCER_ADPRC_00 = 0x0
	// 10-bit accuracy
	ADC120_ADCER_ADPRC_01 = 0x1
	// 8-bit accuracy
	ADC120_ADCER_ADPRC_10 = 0x2
	// Setting prohibited
	ADC120_ADCER_ADPRC_11 = 0x3
	// Position of ACE field.
	ADC120_ADCER_ACE_Pos = 0x5
	// Bit mask of ACE field.
	ADC120_ADCER_ACE_Msk = 0x20
	// Bit ACE.
	ADC120_ADCER_ACE = 0x20
	// Disable automatic clearing
	ADC120_ADCER_ACE_0 = 0x0
	// Enable automatic clearing
	ADC120_ADCER_ACE_1 = 0x1
	// Position of DIAGVAL field.
	ADC120_ADCER_DIAGVAL_Pos = 0x8
	// Bit mask of DIAGVAL field.
	ADC120_ADCER_DIAGVAL_Msk = 0x300
	// Setting prohibited when self-diagnosis is enabled
	ADC120_ADCER_DIAGVAL_00 = 0x0
	// 0 volts
	ADC120_ADCER_DIAGVAL_01 = 0x1
	// Reference voltage × 1/2
	ADC120_ADCER_DIAGVAL_10 = 0x2
	// Reference voltage
	ADC120_ADCER_DIAGVAL_11 = 0x3
	// Position of DIAGLD field.
	ADC120_ADCER_DIAGLD_Pos = 0xa
	// Bit mask of DIAGLD field.
	ADC120_ADCER_DIAGLD_Msk = 0x400
	// Bit DIAGLD.
	ADC120_ADCER_DIAGLD = 0x400
	// Select rotation mode for self-diagnosis voltage
	ADC120_ADCER_DIAGLD_0 = 0x0
	// Select mixed mode for self-diagnosis voltage
	ADC120_ADCER_DIAGLD_1 = 0x1
	// Position of DIAGM field.
	ADC120_ADCER_DIAGM_Pos = 0xb
	// Bit mask of DIAGM field.
	ADC120_ADCER_DIAGM_Msk = 0x800
	// Bit DIAGM.
	ADC120_ADCER_DIAGM = 0x800
	// Disable ADC12 self-diagnosis
	ADC120_ADCER_DIAGM_0 = 0x0
	// Enable ADC12 self-diagnosis
	ADC120_ADCER_DIAGM_1 = 0x1
	// Position of ADRFMT field.
	ADC120_ADCER_ADRFMT_Pos = 0xf
	// Bit mask of ADRFMT field.
	ADC120_ADCER_ADRFMT_Msk = 0x8000
	// Bit ADRFMT.
	ADC120_ADCER_ADRFMT = 0x8000
	// Select right-justified for the A/D data register format
	ADC120_ADCER_ADRFMT_0 = 0x0
	// Select left-justified for the A/D data register format
	ADC120_ADCER_ADRFMT_1 = 0x1

	// ADSTRGR: A/D Conversion Start Trigger Select Register
	// Position of TRSB field.
	ADC120_ADSTRGR_TRSB_Pos = 0x0
	// Bit mask of TRSB field.
	ADC120_ADSTRGR_TRSB_Msk = 0x3f
	// Position of TRSA field.
	ADC120_ADSTRGR_TRSA_Pos = 0x8
	// Bit mask of TRSA field.
	ADC120_ADSTRGR_TRSA_Msk = 0x3f00

	// ADEXICR: A/D Conversion Extended Input Control Registers
	// Position of OCSAD field.
	ADC120_ADEXICR_OCSAD_Pos = 0x1
	// Bit mask of OCSAD field.
	ADC120_ADEXICR_OCSAD_Msk = 0x2
	// Bit OCSAD.
	ADC120_ADEXICR_OCSAD = 0x2
	// Do not select addition/average mode for internal reference voltage.
	ADC120_ADEXICR_OCSAD_0 = 0x0
	// Select addition/average mode for internal reference voltage.
	ADC120_ADEXICR_OCSAD_1 = 0x1
	// Position of OCSA field.
	ADC120_ADEXICR_OCSA_Pos = 0x9
	// Bit mask of OCSA field.
	ADC120_ADEXICR_OCSA_Msk = 0x200
	// Bit OCSA.
	ADC120_ADEXICR_OCSA = 0x200
	// Disable A/D conversion of internal reference voltage
	ADC120_ADEXICR_OCSA_0 = 0x0
	// Enable A/D conversion of internal reference voltage
	ADC120_ADEXICR_OCSA_1 = 0x1
	// Position of OCSB field.
	ADC120_ADEXICR_OCSB_Pos = 0xb
	// Bit mask of OCSB field.
	ADC120_ADEXICR_OCSB_Msk = 0x800
	// Bit OCSB.
	ADC120_ADEXICR_OCSB = 0x800
	// Disable A/D conversion of internal reference voltage
	ADC120_ADEXICR_OCSB_0 = 0x0
	// Enable A/D conversion of internal reference voltage
	ADC120_ADEXICR_OCSB_1 = 0x1

	// ADANSB0: A/D Channel Select Register B0
	// Position of ANSB0 field.
	ADC120_ADANSB0_ANSB0_Pos = 0x0
	// Bit mask of ANSB0 field.
	ADC120_ADANSB0_ANSB0_Msk = 0x1
	// Bit ANSB0.
	ADC120_ADANSB0_ANSB0 = 0x1
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB0_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB0_1 = 0x1
	// Position of ANSB1 field.
	ADC120_ADANSB0_ANSB1_Pos = 0x1
	// Bit mask of ANSB1 field.
	ADC120_ADANSB0_ANSB1_Msk = 0x2
	// Bit ANSB1.
	ADC120_ADANSB0_ANSB1 = 0x2
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB1_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB1_1 = 0x1
	// Position of ANSB2 field.
	ADC120_ADANSB0_ANSB2_Pos = 0x2
	// Bit mask of ANSB2 field.
	ADC120_ADANSB0_ANSB2_Msk = 0x4
	// Bit ANSB2.
	ADC120_ADANSB0_ANSB2 = 0x4
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB2_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB2_1 = 0x1
	// Position of ANSB3 field.
	ADC120_ADANSB0_ANSB3_Pos = 0x3
	// Bit mask of ANSB3 field.
	ADC120_ADANSB0_ANSB3_Msk = 0x8
	// Bit ANSB3.
	ADC120_ADANSB0_ANSB3 = 0x8
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB3_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB3_1 = 0x1
	// Position of ANSB4 field.
	ADC120_ADANSB0_ANSB4_Pos = 0x4
	// Bit mask of ANSB4 field.
	ADC120_ADANSB0_ANSB4_Msk = 0x10
	// Bit ANSB4.
	ADC120_ADANSB0_ANSB4 = 0x10
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB4_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB4_1 = 0x1
	// Position of ANSB5 field.
	ADC120_ADANSB0_ANSB5_Pos = 0x5
	// Bit mask of ANSB5 field.
	ADC120_ADANSB0_ANSB5_Msk = 0x20
	// Bit ANSB5.
	ADC120_ADANSB0_ANSB5 = 0x20
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB5_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB5_1 = 0x1
	// Position of ANSB6 field.
	ADC120_ADANSB0_ANSB6_Pos = 0x6
	// Bit mask of ANSB6 field.
	ADC120_ADANSB0_ANSB6_Msk = 0x40
	// Bit ANSB6.
	ADC120_ADANSB0_ANSB6 = 0x40
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB6_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB6_1 = 0x1
	// Position of ANSB7 field.
	ADC120_ADANSB0_ANSB7_Pos = 0x7
	// Bit mask of ANSB7 field.
	ADC120_ADANSB0_ANSB7_Msk = 0x80
	// Bit ANSB7.
	ADC120_ADANSB0_ANSB7 = 0x80
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB7_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB7_1 = 0x1
	// Position of ANSB8 field.
	ADC120_ADANSB0_ANSB8_Pos = 0x8
	// Bit mask of ANSB8 field.
	ADC120_ADANSB0_ANSB8_Msk = 0x100
	// Bit ANSB8.
	ADC120_ADANSB0_ANSB8 = 0x100
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB8_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB8_1 = 0x1
	// Position of ANSB12 field.
	ADC120_ADANSB0_ANSB12_Pos = 0xc
	// Bit mask of ANSB12 field.
	ADC120_ADANSB0_ANSB12_Msk = 0x1000
	// Bit ANSB12.
	ADC120_ADANSB0_ANSB12 = 0x1000
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB12_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB12_1 = 0x1
	// Position of ANSB13 field.
	ADC120_ADANSB0_ANSB13_Pos = 0xd
	// Bit mask of ANSB13 field.
	ADC120_ADANSB0_ANSB13_Msk = 0x2000
	// Bit ANSB13.
	ADC120_ADANSB0_ANSB13 = 0x2000
	// Do not select associated input channel.
	ADC120_ADANSB0_ANSB13_0 = 0x0
	// Select associated input channel.
	ADC120_ADANSB0_ANSB13_1 = 0x1

	// ADDBLDR: A/D Data Duplexing Register
	// Position of ADDBLDR field.
	ADC120_ADDBLDR_ADDBLDR_Pos = 0x0
	// Bit mask of ADDBLDR field.
	ADC120_ADDBLDR_ADDBLDR_Msk = 0xffff

	// ADOCDR: A/D Internal Reference Voltage Data Register
	// Position of ADOCDR field.
	ADC120_ADOCDR_ADOCDR_Pos = 0x0
	// Bit mask of ADOCDR field.
	ADC120_ADOCDR_ADOCDR_Msk = 0xffff

	// ADRD: A/D Self-Diagnosis Data Register
	// Position of AD field.
	ADC120_ADRD_AD_Pos = 0x0
	// Bit mask of AD field.
	ADC120_ADRD_AD_Msk = 0xfff
	// Position of DIAGST field.
	ADC120_ADRD_DIAGST_Pos = 0xe
	// Bit mask of DIAGST field.
	ADC120_ADRD_DIAGST_Msk = 0xc000
	// Self-diagnosis not executed after power-on.
	ADC120_ADRD_DIAGST_00 = 0x0
	// Self-diagnosis was executed using the 0 V voltage.
	ADC120_ADRD_DIAGST_01 = 0x1
	// Self-diagnosis was executed using the reference voltage × 1/2.
	ADC120_ADRD_DIAGST_10 = 0x2
	// Self-diagnosis was executed using the reference voltage .
	ADC120_ADRD_DIAGST_11 = 0x3

	// ADDR0: A/D Data Registers %s
	// Position of ADDR field.
	ADC120_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ADC120_ADDR_ADDR_Msk = 0xffff

	// ADDR12: A/D Data Registers %s
	// Position of ADDR field.
	ADC120_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ADC120_ADDR_ADDR_Msk = 0xffff

	// ADDISCR: A/D Disconnection Detection Control Register
	// Position of ADNDIS field.
	ADC120_ADDISCR_ADNDIS_Pos = 0x0
	// Bit mask of ADNDIS field.
	ADC120_ADDISCR_ADNDIS_Msk = 0xf
	// The disconnection detection assist function is disabled
	ADC120_ADDISCR_ADNDIS_0x0 = 0x0
	// Setting prohibited
	ADC120_ADDISCR_ADNDIS_0x1 = 0x1
	// Position of PCHG field.
	ADC120_ADDISCR_PCHG_Pos = 0x4
	// Bit mask of PCHG field.
	ADC120_ADDISCR_PCHG_Msk = 0x10
	// Bit PCHG.
	ADC120_ADDISCR_PCHG = 0x10
	// Discharge
	ADC120_ADDISCR_PCHG_0 = 0x0
	// Precharge
	ADC120_ADDISCR_PCHG_1 = 0x1

	// ADGSPCR: A/D Group Scan Priority Control Register
	// Position of PGS field.
	ADC120_ADGSPCR_PGS_Pos = 0x0
	// Bit mask of PGS field.
	ADC120_ADGSPCR_PGS_Msk = 0x1
	// Bit PGS.
	ADC120_ADGSPCR_PGS = 0x1
	// Operate without group priority control.
	ADC120_ADGSPCR_PGS_0 = 0x0
	// Operate with group priority control.
	ADC120_ADGSPCR_PGS_1 = 0x1
	// Position of GBRSCN field.
	ADC120_ADGSPCR_GBRSCN_Pos = 0x1
	// Bit mask of GBRSCN field.
	ADC120_ADGSPCR_GBRSCN_Msk = 0x2
	// Bit GBRSCN.
	ADC120_ADGSPCR_GBRSCN = 0x2
	// Disable rescanning of the group that was stopped in group priority operation
	ADC120_ADGSPCR_GBRSCN_0 = 0x0
	// Enable rescanning of the group that was stopped in group priority operation.
	ADC120_ADGSPCR_GBRSCN_1 = 0x1
	// Position of LGRRS field.
	ADC120_ADGSPCR_LGRRS_Pos = 0xe
	// Bit mask of LGRRS field.
	ADC120_ADGSPCR_LGRRS_Msk = 0x4000
	// Bit LGRRS.
	ADC120_ADGSPCR_LGRRS = 0x4000
	// Start rescanning from the first channel for scanning
	ADC120_ADGSPCR_LGRRS_0 = 0x0
	// Start rescanning from the channel for which A/D conversion is not completed.
	ADC120_ADGSPCR_LGRRS_1 = 0x1
	// Position of GBRP field.
	ADC120_ADGSPCR_GBRP_Pos = 0xf
	// Bit mask of GBRP field.
	ADC120_ADGSPCR_GBRP_Msk = 0x8000
	// Bit GBRP.
	ADC120_ADGSPCR_GBRP = 0x8000
	// Single scan is not continuously activated.
	ADC120_ADGSPCR_GBRP_0 = 0x0
	// Single scan for the group with the lower-priority is continuously activated.
	ADC120_ADGSPCR_GBRP_1 = 0x1

	// ADDBLDRA: A/D Data Duplexing Register A
	// Position of ADDBLDR field.
	ADC120_ADDBLDRA_ADDBLDR_Pos = 0x0
	// Bit mask of ADDBLDR field.
	ADC120_ADDBLDRA_ADDBLDR_Msk = 0xffff

	// ADDBLDRB: A/D Data Duplexing Register B
	// Position of ADDBLDR field.
	ADC120_ADDBLDRB_ADDBLDR_Pos = 0x0
	// Bit mask of ADDBLDR field.
	ADC120_ADDBLDRB_ADDBLDR_Msk = 0xffff

	// ADWINMON: A/D Compare Function Window A/B Status Monitor Register
	// Position of MONCOMB field.
	ADC120_ADWINMON_MONCOMB_Pos = 0x0
	// Bit mask of MONCOMB field.
	ADC120_ADWINMON_MONCOMB_Msk = 0x1
	// Bit MONCOMB.
	ADC120_ADWINMON_MONCOMB = 0x1
	// Window A/B composite conditions are not met.
	ADC120_ADWINMON_MONCOMB_0 = 0x0
	// Window A/B composite conditions are met.
	ADC120_ADWINMON_MONCOMB_1 = 0x1
	// Position of MONCMPA field.
	ADC120_ADWINMON_MONCMPA_Pos = 0x4
	// Bit mask of MONCMPA field.
	ADC120_ADWINMON_MONCMPA_Msk = 0x10
	// Bit MONCMPA.
	ADC120_ADWINMON_MONCMPA = 0x10
	// Window A comparison conditions are not met.
	ADC120_ADWINMON_MONCMPA_0 = 0x0
	// Window A comparison conditions are met.
	ADC120_ADWINMON_MONCMPA_1 = 0x1
	// Position of MONCMPB field.
	ADC120_ADWINMON_MONCMPB_Pos = 0x5
	// Bit mask of MONCMPB field.
	ADC120_ADWINMON_MONCMPB_Msk = 0x20
	// Bit MONCMPB.
	ADC120_ADWINMON_MONCMPB = 0x20
	// Window B comparison conditions are not met.
	ADC120_ADWINMON_MONCMPB_0 = 0x0
	// Window B comparison conditions are met.
	ADC120_ADWINMON_MONCMPB_1 = 0x1

	// ADCMPCR: A/D Compare Function Control Register
	// Position of CMPAB field.
	ADC120_ADCMPCR_CMPAB_Pos = 0x0
	// Bit mask of CMPAB field.
	ADC120_ADCMPCR_CMPAB_Msk = 0x3
	// Output ADC120_WCMPM when window A OR window B comparison conditions are met. Otherwise, output ADC120_WCMPUM.
	ADC120_ADCMPCR_CMPAB_00 = 0x0
	// Output ADC120_WCMPM when window A EXOR window B comparison conditions are met. Otherwise, output ADC120_WCMPUM.
	ADC120_ADCMPCR_CMPAB_01 = 0x1
	// Output ADC120_WCMPM when window A AND window B comparison conditions are met. Otherwise, output ADC120_WCMPUM.
	ADC120_ADCMPCR_CMPAB_10 = 0x2
	// Setting prohibited.
	ADC120_ADCMPCR_CMPAB_11 = 0x3
	// Position of CMPBE field.
	ADC120_ADCMPCR_CMPBE_Pos = 0x9
	// Bit mask of CMPBE field.
	ADC120_ADCMPCR_CMPBE_Msk = 0x200
	// Bit CMPBE.
	ADC120_ADCMPCR_CMPBE = 0x200
	// Disable compare window B operation. Disable ADC120_WCMPM and ADC120_WCMPUM outputs.
	ADC120_ADCMPCR_CMPBE_0 = 0x0
	// Enable compare window B operation.
	ADC120_ADCMPCR_CMPBE_1 = 0x1
	// Position of CMPAE field.
	ADC120_ADCMPCR_CMPAE_Pos = 0xb
	// Bit mask of CMPAE field.
	ADC120_ADCMPCR_CMPAE_Msk = 0x800
	// Bit CMPAE.
	ADC120_ADCMPCR_CMPAE = 0x800
	// Disable compare window A operation. Disable ADC120_WCMPM and ADC120_WCMPUM outputs.
	ADC120_ADCMPCR_CMPAE_0 = 0x0
	// Enable compare window A operation.
	ADC120_ADCMPCR_CMPAE_1 = 0x1
	// Position of CMPBIE field.
	ADC120_ADCMPCR_CMPBIE_Pos = 0xd
	// Bit mask of CMPBIE field.
	ADC120_ADCMPCR_CMPBIE_Msk = 0x2000
	// Bit CMPBIE.
	ADC120_ADCMPCR_CMPBIE = 0x2000
	// Disable ADC120_CMPBI interrupt when comparison conditions (window B) are met.
	ADC120_ADCMPCR_CMPBIE_0 = 0x0
	// Enable ADC120_CMPBI interrupt when comparison conditions (window B) are met.
	ADC120_ADCMPCR_CMPBIE_1 = 0x1
	// Position of WCMPE field.
	ADC120_ADCMPCR_WCMPE_Pos = 0xe
	// Bit mask of WCMPE field.
	ADC120_ADCMPCR_WCMPE_Msk = 0x4000
	// Bit WCMPE.
	ADC120_ADCMPCR_WCMPE = 0x4000
	// Disable window function Window A and window B operate as a comparator to compare the single value on the lower side with the A/D conversion result.
	ADC120_ADCMPCR_WCMPE_0 = 0x0
	// Enable window function Window A and window B operate as a comparator to compare the two values on the upper and lower sides with the A/D conversion result.
	ADC120_ADCMPCR_WCMPE_1 = 0x1
	// Position of CMPAIE field.
	ADC120_ADCMPCR_CMPAIE_Pos = 0xf
	// Bit mask of CMPAIE field.
	ADC120_ADCMPCR_CMPAIE_Msk = 0x8000
	// Bit CMPAIE.
	ADC120_ADCMPCR_CMPAIE = 0x8000
	// Disable ADC120_CMPAI interrupt when comparison conditions (window A) are met.
	ADC120_ADCMPCR_CMPAIE_0 = 0x0
	// Enable ADC120_CMPAI interrupt when comparison conditions (window A) are met.
	ADC120_ADCMPCR_CMPAIE_1 = 0x1

	// ADCMPANSER: A/D Compare Function Window A Extended Input Select Register
	// Position of CMPOCA field.
	ADC120_ADCMPANSER_CMPOCA_Pos = 0x1
	// Bit mask of CMPOCA field.
	ADC120_ADCMPANSER_CMPOCA_Msk = 0x2
	// Bit CMPOCA.
	ADC120_ADCMPANSER_CMPOCA = 0x2
	// Exclude the internal reference voltage from the compare Window A target range.
	ADC120_ADCMPANSER_CMPOCA_0 = 0x0
	// Include the internal reference voltage in the compare Window A target range.
	ADC120_ADCMPANSER_CMPOCA_1 = 0x1

	// ADCMPLER: A/D Compare Function Window A Extended Input Comparison Condition Setting Register
	// Position of CMPLOCA field.
	ADC120_ADCMPLER_CMPLOCA_Pos = 0x1
	// Bit mask of CMPLOCA field.
	ADC120_ADCMPLER_CMPLOCA_Msk = 0x2
	// Bit CMPLOCA.
	ADC120_ADCMPLER_CMPLOCA = 0x2
	// When window function is disabled (ADCMPCR.WCMPE = 0) : ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or A/D-converted value > ADCMPDR1 value
	ADC120_ADCMPLER_CMPLOCA_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLER_CMPLOCA_1 = 0x1

	// ADCMPANSR0: A/D Compare Function Window A Channel Select Register 0
	// Position of CMPCHA0 field.
	ADC120_ADCMPANSR0_CMPCHA0_Pos = 0x0
	// Bit mask of CMPCHA0 field.
	ADC120_ADCMPANSR0_CMPCHA0_Msk = 0x1
	// Bit CMPCHA0.
	ADC120_ADCMPANSR0_CMPCHA0 = 0x1
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA0_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA0_1 = 0x1
	// Position of CMPCHA1 field.
	ADC120_ADCMPANSR0_CMPCHA1_Pos = 0x1
	// Bit mask of CMPCHA1 field.
	ADC120_ADCMPANSR0_CMPCHA1_Msk = 0x2
	// Bit CMPCHA1.
	ADC120_ADCMPANSR0_CMPCHA1 = 0x2
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA1_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA1_1 = 0x1
	// Position of CMPCHA2 field.
	ADC120_ADCMPANSR0_CMPCHA2_Pos = 0x2
	// Bit mask of CMPCHA2 field.
	ADC120_ADCMPANSR0_CMPCHA2_Msk = 0x4
	// Bit CMPCHA2.
	ADC120_ADCMPANSR0_CMPCHA2 = 0x4
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA2_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA2_1 = 0x1
	// Position of CMPCHA3 field.
	ADC120_ADCMPANSR0_CMPCHA3_Pos = 0x3
	// Bit mask of CMPCHA3 field.
	ADC120_ADCMPANSR0_CMPCHA3_Msk = 0x8
	// Bit CMPCHA3.
	ADC120_ADCMPANSR0_CMPCHA3 = 0x8
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA3_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA3_1 = 0x1
	// Position of CMPCHA4 field.
	ADC120_ADCMPANSR0_CMPCHA4_Pos = 0x4
	// Bit mask of CMPCHA4 field.
	ADC120_ADCMPANSR0_CMPCHA4_Msk = 0x10
	// Bit CMPCHA4.
	ADC120_ADCMPANSR0_CMPCHA4 = 0x10
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA4_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA4_1 = 0x1
	// Position of CMPCHA5 field.
	ADC120_ADCMPANSR0_CMPCHA5_Pos = 0x5
	// Bit mask of CMPCHA5 field.
	ADC120_ADCMPANSR0_CMPCHA5_Msk = 0x20
	// Bit CMPCHA5.
	ADC120_ADCMPANSR0_CMPCHA5 = 0x20
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA5_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA5_1 = 0x1
	// Position of CMPCHA6 field.
	ADC120_ADCMPANSR0_CMPCHA6_Pos = 0x6
	// Bit mask of CMPCHA6 field.
	ADC120_ADCMPANSR0_CMPCHA6_Msk = 0x40
	// Bit CMPCHA6.
	ADC120_ADCMPANSR0_CMPCHA6 = 0x40
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA6_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA6_1 = 0x1
	// Position of CMPCHA7 field.
	ADC120_ADCMPANSR0_CMPCHA7_Pos = 0x7
	// Bit mask of CMPCHA7 field.
	ADC120_ADCMPANSR0_CMPCHA7_Msk = 0x80
	// Bit CMPCHA7.
	ADC120_ADCMPANSR0_CMPCHA7 = 0x80
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA7_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA7_1 = 0x1
	// Position of CMPCHA8 field.
	ADC120_ADCMPANSR0_CMPCHA8_Pos = 0x8
	// Bit mask of CMPCHA8 field.
	ADC120_ADCMPANSR0_CMPCHA8_Msk = 0x100
	// Bit CMPCHA8.
	ADC120_ADCMPANSR0_CMPCHA8 = 0x100
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA8_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA8_1 = 0x1
	// Position of CMPCHA12 field.
	ADC120_ADCMPANSR0_CMPCHA12_Pos = 0xc
	// Bit mask of CMPCHA12 field.
	ADC120_ADCMPANSR0_CMPCHA12_Msk = 0x1000
	// Bit CMPCHA12.
	ADC120_ADCMPANSR0_CMPCHA12 = 0x1000
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA12_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA12_1 = 0x1
	// Position of CMPCHA13 field.
	ADC120_ADCMPANSR0_CMPCHA13_Pos = 0xd
	// Bit mask of CMPCHA13 field.
	ADC120_ADCMPANSR0_CMPCHA13_Msk = 0x2000
	// Bit CMPCHA13.
	ADC120_ADCMPANSR0_CMPCHA13 = 0x2000
	// Disable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA13_0 = 0x0
	// Enable compare function for associated input channel
	ADC120_ADCMPANSR0_CMPCHA13_1 = 0x1

	// ADCMPLR0: A/D Compare Function Window A Comparison Condition Setting Register 0
	// Position of CMPLCHA0 field.
	ADC120_ADCMPLR0_CMPLCHA0_Pos = 0x0
	// Bit mask of CMPLCHA0 field.
	ADC120_ADCMPLR0_CMPLCHA0_Msk = 0x1
	// Bit CMPLCHA0.
	ADC120_ADCMPLR0_CMPLCHA0 = 0x1
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA0_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA0_1 = 0x1
	// Position of CMPLCHA1 field.
	ADC120_ADCMPLR0_CMPLCHA1_Pos = 0x1
	// Bit mask of CMPLCHA1 field.
	ADC120_ADCMPLR0_CMPLCHA1_Msk = 0x2
	// Bit CMPLCHA1.
	ADC120_ADCMPLR0_CMPLCHA1 = 0x2
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA1_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA1_1 = 0x1
	// Position of CMPLCHA2 field.
	ADC120_ADCMPLR0_CMPLCHA2_Pos = 0x2
	// Bit mask of CMPLCHA2 field.
	ADC120_ADCMPLR0_CMPLCHA2_Msk = 0x4
	// Bit CMPLCHA2.
	ADC120_ADCMPLR0_CMPLCHA2 = 0x4
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA2_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA2_1 = 0x1
	// Position of CMPLCHA3 field.
	ADC120_ADCMPLR0_CMPLCHA3_Pos = 0x3
	// Bit mask of CMPLCHA3 field.
	ADC120_ADCMPLR0_CMPLCHA3_Msk = 0x8
	// Bit CMPLCHA3.
	ADC120_ADCMPLR0_CMPLCHA3 = 0x8
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA3_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA3_1 = 0x1
	// Position of CMPLCHA4 field.
	ADC120_ADCMPLR0_CMPLCHA4_Pos = 0x4
	// Bit mask of CMPLCHA4 field.
	ADC120_ADCMPLR0_CMPLCHA4_Msk = 0x10
	// Bit CMPLCHA4.
	ADC120_ADCMPLR0_CMPLCHA4 = 0x10
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA4_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA4_1 = 0x1
	// Position of CMPLCHA5 field.
	ADC120_ADCMPLR0_CMPLCHA5_Pos = 0x5
	// Bit mask of CMPLCHA5 field.
	ADC120_ADCMPLR0_CMPLCHA5_Msk = 0x20
	// Bit CMPLCHA5.
	ADC120_ADCMPLR0_CMPLCHA5 = 0x20
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA5_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA5_1 = 0x1
	// Position of CMPLCHA6 field.
	ADC120_ADCMPLR0_CMPLCHA6_Pos = 0x6
	// Bit mask of CMPLCHA6 field.
	ADC120_ADCMPLR0_CMPLCHA6_Msk = 0x40
	// Bit CMPLCHA6.
	ADC120_ADCMPLR0_CMPLCHA6 = 0x40
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA6_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA6_1 = 0x1
	// Position of CMPLCHA7 field.
	ADC120_ADCMPLR0_CMPLCHA7_Pos = 0x7
	// Bit mask of CMPLCHA7 field.
	ADC120_ADCMPLR0_CMPLCHA7_Msk = 0x80
	// Bit CMPLCHA7.
	ADC120_ADCMPLR0_CMPLCHA7 = 0x80
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA7_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA7_1 = 0x1
	// Position of CMPLCHA8 field.
	ADC120_ADCMPLR0_CMPLCHA8_Pos = 0x8
	// Bit mask of CMPLCHA8 field.
	ADC120_ADCMPLR0_CMPLCHA8_Msk = 0x100
	// Bit CMPLCHA8.
	ADC120_ADCMPLR0_CMPLCHA8 = 0x100
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA8_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA8_1 = 0x1
	// Position of CMPLCHA12 field.
	ADC120_ADCMPLR0_CMPLCHA12_Pos = 0xc
	// Bit mask of CMPLCHA12 field.
	ADC120_ADCMPLR0_CMPLCHA12_Msk = 0x1000
	// Bit CMPLCHA12.
	ADC120_ADCMPLR0_CMPLCHA12 = 0x1000
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA12_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA12_1 = 0x1
	// Position of CMPLCHA13 field.
	ADC120_ADCMPLR0_CMPLCHA13_Pos = 0xd
	// Bit mask of CMPLCHA13 field.
	ADC120_ADCMPLR0_CMPLCHA13_Msk = 0x2000
	// Bit CMPLCHA13.
	ADC120_ADCMPLR0_CMPLCHA13 = 0x2000
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADCMPDR0 value, or ADCMPDR1 value < A/D-converted value
	ADC120_ADCMPLR0_CMPLCHA13_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADCMPDR0 value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADCMPDR0 value < A/D-converted value < ADCMPDR1 value
	ADC120_ADCMPLR0_CMPLCHA13_1 = 0x1

	// ADCMPSR0: A/D Compare Function Window A Channel Status Register 0
	// Position of CMPSTCHA0 field.
	ADC120_ADCMPSR0_CMPSTCHA0_Pos = 0x0
	// Bit mask of CMPSTCHA0 field.
	ADC120_ADCMPSR0_CMPSTCHA0_Msk = 0x1
	// Bit CMPSTCHA0.
	ADC120_ADCMPSR0_CMPSTCHA0 = 0x1
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA0_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA0_1 = 0x1
	// Position of CMPSTCHA1 field.
	ADC120_ADCMPSR0_CMPSTCHA1_Pos = 0x1
	// Bit mask of CMPSTCHA1 field.
	ADC120_ADCMPSR0_CMPSTCHA1_Msk = 0x2
	// Bit CMPSTCHA1.
	ADC120_ADCMPSR0_CMPSTCHA1 = 0x2
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA1_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA1_1 = 0x1
	// Position of CMPSTCHA2 field.
	ADC120_ADCMPSR0_CMPSTCHA2_Pos = 0x2
	// Bit mask of CMPSTCHA2 field.
	ADC120_ADCMPSR0_CMPSTCHA2_Msk = 0x4
	// Bit CMPSTCHA2.
	ADC120_ADCMPSR0_CMPSTCHA2 = 0x4
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA2_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA2_1 = 0x1
	// Position of CMPSTCHA3 field.
	ADC120_ADCMPSR0_CMPSTCHA3_Pos = 0x3
	// Bit mask of CMPSTCHA3 field.
	ADC120_ADCMPSR0_CMPSTCHA3_Msk = 0x8
	// Bit CMPSTCHA3.
	ADC120_ADCMPSR0_CMPSTCHA3 = 0x8
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA3_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA3_1 = 0x1
	// Position of CMPSTCHA4 field.
	ADC120_ADCMPSR0_CMPSTCHA4_Pos = 0x4
	// Bit mask of CMPSTCHA4 field.
	ADC120_ADCMPSR0_CMPSTCHA4_Msk = 0x10
	// Bit CMPSTCHA4.
	ADC120_ADCMPSR0_CMPSTCHA4 = 0x10
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA4_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA4_1 = 0x1
	// Position of CMPSTCHA5 field.
	ADC120_ADCMPSR0_CMPSTCHA5_Pos = 0x5
	// Bit mask of CMPSTCHA5 field.
	ADC120_ADCMPSR0_CMPSTCHA5_Msk = 0x20
	// Bit CMPSTCHA5.
	ADC120_ADCMPSR0_CMPSTCHA5 = 0x20
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA5_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA5_1 = 0x1
	// Position of CMPSTCHA6 field.
	ADC120_ADCMPSR0_CMPSTCHA6_Pos = 0x6
	// Bit mask of CMPSTCHA6 field.
	ADC120_ADCMPSR0_CMPSTCHA6_Msk = 0x40
	// Bit CMPSTCHA6.
	ADC120_ADCMPSR0_CMPSTCHA6 = 0x40
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA6_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA6_1 = 0x1
	// Position of CMPSTCHA7 field.
	ADC120_ADCMPSR0_CMPSTCHA7_Pos = 0x7
	// Bit mask of CMPSTCHA7 field.
	ADC120_ADCMPSR0_CMPSTCHA7_Msk = 0x80
	// Bit CMPSTCHA7.
	ADC120_ADCMPSR0_CMPSTCHA7 = 0x80
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA7_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA7_1 = 0x1
	// Position of CMPSTCHA8 field.
	ADC120_ADCMPSR0_CMPSTCHA8_Pos = 0x8
	// Bit mask of CMPSTCHA8 field.
	ADC120_ADCMPSR0_CMPSTCHA8_Msk = 0x100
	// Bit CMPSTCHA8.
	ADC120_ADCMPSR0_CMPSTCHA8 = 0x100
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA8_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA8_1 = 0x1
	// Position of CMPSTCHA12 field.
	ADC120_ADCMPSR0_CMPSTCHA12_Pos = 0xc
	// Bit mask of CMPSTCHA12 field.
	ADC120_ADCMPSR0_CMPSTCHA12_Msk = 0x1000
	// Bit CMPSTCHA12.
	ADC120_ADCMPSR0_CMPSTCHA12 = 0x1000
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA12_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA12_1 = 0x1
	// Position of CMPSTCHA13 field.
	ADC120_ADCMPSR0_CMPSTCHA13_Pos = 0xd
	// Bit mask of CMPSTCHA13 field.
	ADC120_ADCMPSR0_CMPSTCHA13_Msk = 0x2000
	// Bit CMPSTCHA13.
	ADC120_ADCMPSR0_CMPSTCHA13 = 0x2000
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA13_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA13_1 = 0x1

	// ADCMPSER: A/D Compare Function Window A Extended Input Channel Status Register
	// Position of CMPSTOCA field.
	ADC120_ADCMPSER_CMPSTOCA_Pos = 0x1
	// Bit mask of CMPSTOCA field.
	ADC120_ADCMPSER_CMPSTOCA_Msk = 0x2
	// Bit CMPSTOCA.
	ADC120_ADCMPSER_CMPSTOCA = 0x2
	// Comparison conditions are not met.
	ADC120_ADCMPSER_CMPSTOCA_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSER_CMPSTOCA_1 = 0x1

	// ADCMPBNSR: A/D Compare Function Window B Channel Select Register
	// Position of CMPCHB field.
	ADC120_ADCMPBNSR_CMPCHB_Pos = 0x0
	// Bit mask of CMPCHB field.
	ADC120_ADCMPBNSR_CMPCHB_Msk = 0x3f
	// Position of CMPLB field.
	ADC120_ADCMPBNSR_CMPLB_Pos = 0x7
	// Bit mask of CMPLB field.
	ADC120_ADCMPBNSR_CMPLB_Msk = 0x80
	// Bit CMPLB.
	ADC120_ADCMPBNSR_CMPLB = 0x80
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADWINLLB value > A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): A/D-converted value < ADWINLLB value, or ADWINULB value < A/D-converted value
	ADC120_ADCMPBNSR_CMPLB_0 = 0x0
	// When window function is disabled (ADCMPCR.WCMPE = 0): ADWINLLB value < A/D-converted value When window function is enabled (ADCMPCR.WCMPE = 1): ADWINLLB value < A/D-converted value < ADWINULB value
	ADC120_ADCMPBNSR_CMPLB_1 = 0x1

	// ADCMPBSR: A/D Compare Function Window B Status Register
	// Position of CMPSTB field.
	ADC120_ADCMPBSR_CMPSTB_Pos = 0x0
	// Bit mask of CMPSTB field.
	ADC120_ADCMPBSR_CMPSTB_Msk = 0x1
	// Bit CMPSTB.
	ADC120_ADCMPBSR_CMPSTB = 0x1
	// Comparison conditions are not met.
	ADC120_ADCMPBSR_CMPSTB_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPBSR_CMPSTB_1 = 0x1

	// ADBUFEN: A/D Data Buffer Enable Register
	// Position of BUFEN field.
	ADC120_ADBUFEN_BUFEN_Pos = 0x0
	// Bit mask of BUFEN field.
	ADC120_ADBUFEN_BUFEN_Msk = 0x1
	// Bit BUFEN.
	ADC120_ADBUFEN_BUFEN = 0x1
	// The data buffer is not used.
	ADC120_ADBUFEN_BUFEN_0 = 0x0
	// The data buffer is used.
	ADC120_ADBUFEN_BUFEN_1 = 0x1

	// ADBUFPTR: A/D Data Buffer Pointer Register
	// Position of BUFPTR field.
	ADC120_ADBUFPTR_BUFPTR_Pos = 0x0
	// Bit mask of BUFPTR field.
	ADC120_ADBUFPTR_BUFPTR_Msk = 0xf
	// Position of PTROVF field.
	ADC120_ADBUFPTR_PTROVF_Pos = 0x4
	// Bit mask of PTROVF field.
	ADC120_ADBUFPTR_PTROVF_Msk = 0x10
	// Bit PTROVF.
	ADC120_ADBUFPTR_PTROVF = 0x10
	// The data buffer pointer has not overflowed.
	ADC120_ADBUFPTR_PTROVF_0 = 0x0
	// The data buffer pointer has overflowed.
	ADC120_ADBUFPTR_PTROVF_1 = 0x1

	// ADSSTRO: A/D Sampling State Register
	// Position of SST field.
	ADC120_ADSSTRO_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC120_ADSSTRO_SST_Msk = 0xff

	// ADSSTR0: A/D Sampling State Register
	// Position of SST field.
	ADC120_ADSSTR_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC120_ADSSTR_SST_Msk = 0xff

	// ADSSTR12: A/D Sampling State Register
	// Position of SST field.
	ADC120_ADSSTR_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC120_ADSSTR_SST_Msk = 0xff
)

// Constants for DAC12: 12-bit D/A converter
const (
	// DACR: D/A Control Register
	// Position of DAE field.
	DAC12_DACR_DAE_Pos = 0x5
	// Bit mask of DAE field.
	DAC12_DACR_DAE_Msk = 0x20
	// Bit DAE.
	DAC12_DACR_DAE = 0x20
	// Control D/A conversion of channels 0 and 1 individually
	DAC12_DACR_DAE_0 = 0x0
	// Control D/A conversion of channels 0 and 1 collectively
	DAC12_DACR_DAE_1 = 0x1
	// Position of DAOE0 field.
	DAC12_DACR_DAOE0_Pos = 0x6
	// Bit mask of DAOE0 field.
	DAC12_DACR_DAOE0_Msk = 0x40
	// Bit DAOE0.
	DAC12_DACR_DAOE0 = 0x40
	// Disable analog output of channel 0 (DA0)
	DAC12_DACR_DAOE0_0 = 0x0
	// Enable D/A conversion of channel 0 (DA0)
	DAC12_DACR_DAOE0_1 = 0x1

	// DADPR: DADR Format Select Register
	// Position of DPSEL field.
	DAC12_DADPR_DPSEL_Pos = 0x7
	// Bit mask of DPSEL field.
	DAC12_DADPR_DPSEL_Msk = 0x80
	// Bit DPSEL.
	DAC12_DADPR_DPSEL = 0x80
	// Right-justified format
	DAC12_DADPR_DPSEL_0 = 0x0
	// Left-justified format
	DAC12_DADPR_DPSEL_1 = 0x1

	// DAADSCR: D/A A/D Synchronous Start Control Register
	// Position of DAADST field.
	DAC12_DAADSCR_DAADST_Pos = 0x7
	// Bit mask of DAADST field.
	DAC12_DAADSCR_DAADST_Msk = 0x80
	// Bit DAADST.
	DAC12_DAADSCR_DAADST = 0x80
	// Do not synchronize DAC12 with ADC12 operation (disable interference reduction between D/A and A/D conversion).
	DAC12_DAADSCR_DAADST_0 = 0x0
	// Synchronize DAC12 with ADC12 operation (enable interference reduction between D/A and A/D conversion).
	DAC12_DAADSCR_DAADST_1 = 0x1

	// DAAMPCR: D/A Output Amplifier Control Register
	// Position of DAAMP0 field.
	DAC12_DAAMPCR_DAAMP0_Pos = 0x6
	// Bit mask of DAAMP0 field.
	DAC12_DAAMPCR_DAAMP0_Msk = 0x40
	// Bit DAAMP0.
	DAC12_DAAMPCR_DAAMP0 = 0x40
	// Do not use channel 0 output amplifier
	DAC12_DAAMPCR_DAAMP0_0 = 0x0
	// Use channel 0 output amplifier
	DAC12_DAAMPCR_DAAMP0_1 = 0x1

	// DAASWCR: D/A Amplifier Stabilization Wait Control Register
	// Position of DAASW0 field.
	DAC12_DAASWCR_DAASW0_Pos = 0x6
	// Bit mask of DAASW0 field.
	DAC12_DAASWCR_DAASW0_Msk = 0x40
	// Bit DAASW0.
	DAC12_DAASWCR_DAASW0 = 0x40
	// Amplifier stabilization wait off (output) for channel 0
	DAC12_DAASWCR_DAASW0_0 = 0x0
	// Amplifier stabilization wait on (high-Z) for channel 0
	DAC12_DAASWCR_DAASW0_1 = 0x1

	// DAADUSR: D/A A/D Synchronous Unit Select Register
	// Position of AMADSEL0 field.
	DAC12_DAADUSR_AMADSEL0_Pos = 0x0
	// Bit mask of AMADSEL0 field.
	DAC12_DAADUSR_AMADSEL0_Msk = 0x1
	// Bit AMADSEL0.
	DAC12_DAADUSR_AMADSEL0 = 0x1
	// Do not select unit 0
	DAC12_DAADUSR_AMADSEL0_0 = 0x0
	// Select unit 0
	DAC12_DAADUSR_AMADSEL0_1 = 0x1
)

// Constants for FLAD: Data Flash
const (
	// FCKMHZ: Data Flash Access Frequency Register
	// Position of FCKMHZ field.
	FLAD_FCKMHZ_FCKMHZ_Pos = 0x0
	// Bit mask of FCKMHZ field.
	FLAD_FCKMHZ_FCKMHZ_Msk = 0xff
)

// Constants for FACI: Flash/CPU Interface
const (
	// FASTAT: Flash Access Status Register
	// Position of DFAE field.
	FACI_FASTAT_DFAE_Pos = 0x3
	// Bit mask of DFAE field.
	FACI_FASTAT_DFAE_Msk = 0x8
	// Bit DFAE.
	FACI_FASTAT_DFAE = 0x8
	// No data flash memory access violation has occurred
	FACI_FASTAT_DFAE_0 = 0x0
	// A data flash memory access violation has occurred.
	FACI_FASTAT_DFAE_1 = 0x1
	// Position of CMDLK field.
	FACI_FASTAT_CMDLK_Pos = 0x4
	// Bit mask of CMDLK field.
	FACI_FASTAT_CMDLK_Msk = 0x10
	// Bit CMDLK.
	FACI_FASTAT_CMDLK = 0x10
	// The flash sequencer is not in the command-locked state
	FACI_FASTAT_CMDLK_0 = 0x0
	// The flash sequencer is in the command-locked state.
	FACI_FASTAT_CMDLK_1 = 0x1
	// Position of CFAE field.
	FACI_FASTAT_CFAE_Pos = 0x7
	// Bit mask of CFAE field.
	FACI_FASTAT_CFAE_Msk = 0x80
	// Bit CFAE.
	FACI_FASTAT_CFAE = 0x80
	// No code flash memory access violation has occurred
	FACI_FASTAT_CFAE_0 = 0x0
	// A code flash memory access violation has occurred.
	FACI_FASTAT_CFAE_1 = 0x1

	// FAEINT: Flash Access Error Interrupt Enable Register
	// Position of DFAEIE field.
	FACI_FAEINT_DFAEIE_Pos = 0x3
	// Bit mask of DFAEIE field.
	FACI_FAEINT_DFAEIE_Msk = 0x8
	// Bit DFAEIE.
	FACI_FAEINT_DFAEIE = 0x8
	// Generation of an FIFERR interrupt request is disabled when FASTAT.DFAE is set to 1
	FACI_FAEINT_DFAEIE_0 = 0x0
	// Generation of an FIFERR interrupt request is enabled when FASTAT.DFAE is set to 1.
	FACI_FAEINT_DFAEIE_1 = 0x1
	// Position of CMDLKIE field.
	FACI_FAEINT_CMDLKIE_Pos = 0x4
	// Bit mask of CMDLKIE field.
	FACI_FAEINT_CMDLKIE_Msk = 0x10
	// Bit CMDLKIE.
	FACI_FAEINT_CMDLKIE = 0x10
	// Generation of an FIFERR interrupt request is disabled when FASTAT.CMDLK is set to 1
	FACI_FAEINT_CMDLKIE_0 = 0x0
	// Generation of an FIFERR interrupt request is enabled when FASTAT.CMDLK is set to 1.
	FACI_FAEINT_CMDLKIE_1 = 0x1
	// Position of CFAEIE field.
	FACI_FAEINT_CFAEIE_Pos = 0x7
	// Bit mask of CFAEIE field.
	FACI_FAEINT_CFAEIE_Msk = 0x80
	// Bit CFAEIE.
	FACI_FAEINT_CFAEIE = 0x80
	// Generation of an FIFERR interrupt request is disabled when FASTAT.CFAE is set to 1
	FACI_FAEINT_CFAEIE_0 = 0x0
	// Generation of an FIFERR interrupt request is enabled when FASTAT.CFAE is set to 1.
	FACI_FAEINT_CFAEIE_1 = 0x1

	// FRDYIE: Flash Ready Interrupt Enable Register
	// Position of FRDYIE field.
	FACI_FRDYIE_FRDYIE_Pos = 0x0
	// Bit mask of FRDYIE field.
	FACI_FRDYIE_FRDYIE_Msk = 0x1
	// Bit FRDYIE.
	FACI_FRDYIE_FRDYIE = 0x1
	// Generation of an FRDY interrupt request is disabled
	FACI_FRDYIE_FRDYIE_0 = 0x0
	// Generation of an FRDY interrupt request is enabled.
	FACI_FRDYIE_FRDYIE_1 = 0x1

	// FEADDR: FACI Command End Address Register
	// Position of FEADDR field.
	FACI_FEADDR_FEADDR_Pos = 0x0
	// Bit mask of FEADDR field.
	FACI_FEADDR_FEADDR_Msk = 0xffffffff

	// FMEPROT: Flash P/E Mode Entry Protection Register
	// Position of CEPROT field.
	FACI_FMEPROT_CEPROT_Pos = 0x0
	// Bit mask of CEPROT field.
	FACI_FMEPROT_CEPROT_Msk = 0x1
	// Bit CEPROT.
	FACI_FMEPROT_CEPROT = 0x1
	// FENTRYC bit is not protected
	FACI_FMEPROT_CEPROT_0 = 0x0
	// FENTRYC bit is protected.
	FACI_FMEPROT_CEPROT_1 = 0x1
	// Position of KEY field.
	FACI_FMEPROT_KEY_Pos = 0x8
	// Bit mask of KEY field.
	FACI_FMEPROT_KEY_Msk = 0xff00

	// FBPROT0: Flash Block Protection Register
	// Position of BPCN0 field.
	FACI_FBPROT0_BPCN0_Pos = 0x0
	// Bit mask of BPCN0 field.
	FACI_FBPROT0_BPCN0_Msk = 0x1
	// Bit BPCN0.
	FACI_FBPROT0_BPCN0 = 0x1
	// Block protection is enabled
	FACI_FBPROT0_BPCN0_0 = 0x0
	// Block protection is disabled.
	FACI_FBPROT0_BPCN0_1 = 0x1
	// Position of KEY field.
	FACI_FBPROT0_KEY_Pos = 0x8
	// Bit mask of KEY field.
	FACI_FBPROT0_KEY_Msk = 0xff00

	// FBPROT1: Flash Block Protection for Secure Register
	// Position of BPCN1 field.
	FACI_FBPROT1_BPCN1_Pos = 0x0
	// Bit mask of BPCN1 field.
	FACI_FBPROT1_BPCN1_Msk = 0x1
	// Bit BPCN1.
	FACI_FBPROT1_BPCN1 = 0x1
	// Block protection is enabled
	FACI_FBPROT1_BPCN1_0 = 0x0
	// Block protection is disabled.
	FACI_FBPROT1_BPCN1_1 = 0x1
	// Position of KEY field.
	FACI_FBPROT1_KEY_Pos = 0x8
	// Bit mask of KEY field.
	FACI_FBPROT1_KEY_Msk = 0xff00

	// FSTATR: Flash Status Register
	// Position of FLWEERR field.
	FACI_FSTATR_FLWEERR_Pos = 0x6
	// Bit mask of FLWEERR field.
	FACI_FSTATR_FLWEERR_Msk = 0x40
	// Bit FLWEERR.
	FACI_FSTATR_FLWEERR = 0x40
	// An error has not occurred
	FACI_FSTATR_FLWEERR_0 = 0x0
	// An error has occurred.
	FACI_FSTATR_FLWEERR_1 = 0x1
	// Position of PRGSPD field.
	FACI_FSTATR_PRGSPD_Pos = 0x8
	// Bit mask of PRGSPD field.
	FACI_FSTATR_PRGSPD_Msk = 0x100
	// Bit PRGSPD.
	FACI_FSTATR_PRGSPD = 0x100
	// The flash sequencer is in a state other than those corresponding to the value 1
	FACI_FSTATR_PRGSPD_0 = 0x0
	// The flash sequencer is in the programming suspension processing state or programming suspended state.
	FACI_FSTATR_PRGSPD_1 = 0x1
	// Position of ERSSPD field.
	FACI_FSTATR_ERSSPD_Pos = 0x9
	// Bit mask of ERSSPD field.
	FACI_FSTATR_ERSSPD_Msk = 0x200
	// Bit ERSSPD.
	FACI_FSTATR_ERSSPD = 0x200
	// The flash sequencer is in a state other than those corresponding to the value 1
	FACI_FSTATR_ERSSPD_0 = 0x0
	// The flash sequencer is in the erasure suspension processing state or the erasure suspended state.
	FACI_FSTATR_ERSSPD_1 = 0x1
	// Position of DBFULL field.
	FACI_FSTATR_DBFULL_Pos = 0xa
	// Bit mask of DBFULL field.
	FACI_FSTATR_DBFULL_Msk = 0x400
	// Bit DBFULL.
	FACI_FSTATR_DBFULL = 0x400
	// The data buffer is empty
	FACI_FSTATR_DBFULL_0 = 0x0
	// The data buffer is full.
	FACI_FSTATR_DBFULL_1 = 0x1
	// Position of SUSRDY field.
	FACI_FSTATR_SUSRDY_Pos = 0xb
	// Bit mask of SUSRDY field.
	FACI_FSTATR_SUSRDY_Msk = 0x800
	// Bit SUSRDY.
	FACI_FSTATR_SUSRDY = 0x800
	// The flash sequencer cannot receive P/E suspend commands
	FACI_FSTATR_SUSRDY_0 = 0x0
	// The flash sequencer can receive P/E suspend commands.
	FACI_FSTATR_SUSRDY_1 = 0x1
	// Position of PRGERR field.
	FACI_FSTATR_PRGERR_Pos = 0xc
	// Bit mask of PRGERR field.
	FACI_FSTATR_PRGERR_Msk = 0x1000
	// Bit PRGERR.
	FACI_FSTATR_PRGERR = 0x1000
	// Programming has completed successfully
	FACI_FSTATR_PRGERR_0 = 0x0
	// An error has occurred during programming.
	FACI_FSTATR_PRGERR_1 = 0x1
	// Position of ERSERR field.
	FACI_FSTATR_ERSERR_Pos = 0xd
	// Bit mask of ERSERR field.
	FACI_FSTATR_ERSERR_Msk = 0x2000
	// Bit ERSERR.
	FACI_FSTATR_ERSERR = 0x2000
	// Erasure has completed successfully
	FACI_FSTATR_ERSERR_0 = 0x0
	// An error has occurred during erasure.
	FACI_FSTATR_ERSERR_1 = 0x1
	// Position of ILGLERR field.
	FACI_FSTATR_ILGLERR_Pos = 0xe
	// Bit mask of ILGLERR field.
	FACI_FSTATR_ILGLERR_Msk = 0x4000
	// Bit ILGLERR.
	FACI_FSTATR_ILGLERR = 0x4000
	// The flash sequencer has not detected an illegal FACI command or illegal flash memory access
	FACI_FSTATR_ILGLERR_0 = 0x0
	// The flash sequencer has detected an illegal FACI command or illegal flash memory access.
	FACI_FSTATR_ILGLERR_1 = 0x1
	// Position of FRDY field.
	FACI_FSTATR_FRDY_Pos = 0xf
	// Bit mask of FRDY field.
	FACI_FSTATR_FRDY_Msk = 0x8000
	// Bit FRDY.
	FACI_FSTATR_FRDY = 0x8000
	// Program, Block Erase, Multi Block Erase, P/E suspend, P/E resume, Forced Stop, Blank Check, or Configuration set command processing is in progress
	FACI_FSTATR_FRDY_0 = 0x0
	// None of the above is in progress.
	FACI_FSTATR_FRDY_1 = 0x1
	// Position of OTERR field.
	FACI_FSTATR_OTERR_Pos = 0x14
	// Bit mask of OTERR field.
	FACI_FSTATR_OTERR_Msk = 0x100000
	// Bit OTERR.
	FACI_FSTATR_OTERR = 0x100000
	// A status clear or forced stop command processing is complete
	FACI_FSTATR_OTERR_0 = 0x0
	// An error has occurred.
	FACI_FSTATR_OTERR_1 = 0x1
	// Position of SECERR field.
	FACI_FSTATR_SECERR_Pos = 0x15
	// Bit mask of SECERR field.
	FACI_FSTATR_SECERR_Msk = 0x200000
	// Bit SECERR.
	FACI_FSTATR_SECERR = 0x200000
	// A status clear or forced stop command processing is complete
	FACI_FSTATR_SECERR_0 = 0x0
	// An error has occurred.
	FACI_FSTATR_SECERR_1 = 0x1
	// Position of FESETERR field.
	FACI_FSTATR_FESETERR_Pos = 0x16
	// Bit mask of FESETERR field.
	FACI_FSTATR_FESETERR_Msk = 0x400000
	// Bit FESETERR.
	FACI_FSTATR_FESETERR = 0x400000
	// A status clear or forced stop command processing is complete
	FACI_FSTATR_FESETERR_0 = 0x0
	// An error has occurred.
	FACI_FSTATR_FESETERR_1 = 0x1
	// Position of ILGCOMERR field.
	FACI_FSTATR_ILGCOMERR_Pos = 0x17
	// Bit mask of ILGCOMERR field.
	FACI_FSTATR_ILGCOMERR_Msk = 0x800000
	// Bit ILGCOMERR.
	FACI_FSTATR_ILGCOMERR = 0x800000
	// A status clear or forced stop command processing is complete
	FACI_FSTATR_ILGCOMERR_0 = 0x0
	// An error has occurred.
	FACI_FSTATR_ILGCOMERR_1 = 0x1

	// FENTRYR: Flash P/E Mode Entry Register
	// Position of FENTRYC field.
	FACI_FENTRYR_FENTRYC_Pos = 0x0
	// Bit mask of FENTRYC field.
	FACI_FENTRYR_FENTRYC_Msk = 0x1
	// Bit FENTRYC.
	FACI_FENTRYR_FENTRYC = 0x1
	// Code flash is in read mode
	FACI_FENTRYR_FENTRYC_0 = 0x0
	// Code flash is in P/E mode.
	FACI_FENTRYR_FENTRYC_1 = 0x1
	// Position of FENTRYD field.
	FACI_FENTRYR_FENTRYD_Pos = 0x7
	// Bit mask of FENTRYD field.
	FACI_FENTRYR_FENTRYD_Msk = 0x80
	// Bit FENTRYD.
	FACI_FENTRYR_FENTRYD = 0x80
	// Data flash is in read mode
	FACI_FENTRYR_FENTRYD_0 = 0x0
	// Data flash is in P/E mode.
	FACI_FENTRYR_FENTRYD_1 = 0x1
	// Position of KEY field.
	FACI_FENTRYR_KEY_Pos = 0x8
	// Bit mask of KEY field.
	FACI_FENTRYR_KEY_Msk = 0xff00

	// FSUINITR: Flash Sequencer Setup Initialization Register
	// Position of SUINIT field.
	FACI_FSUINITR_SUINIT_Pos = 0x0
	// Bit mask of SUINIT field.
	FACI_FSUINITR_SUINIT_Msk = 0x1
	// Bit SUINIT.
	FACI_FSUINITR_SUINIT = 0x1
	// The FSADDR, FEADDR, FBPROT0, FBPROT1, FENTRYR, FBCCNT, and FCPSR flash sequencer setup registers keep their current values
	FACI_FSUINITR_SUINIT_0 = 0x0
	// The FSADDR, FEADDR, FBPROT0, FBRPOT1, FENTRYR, FBCCNT, and FCPSR flash sequencer setup registers are initialized.
	FACI_FSUINITR_SUINIT_1 = 0x1
	// Position of KEY field.
	FACI_FSUINITR_KEY_Pos = 0x8
	// Bit mask of KEY field.
	FACI_FSUINITR_KEY_Msk = 0xff00

	// FCMDR: FACI Command Register
	// Position of PCMDR field.
	FACI_FCMDR_PCMDR_Pos = 0x0
	// Bit mask of PCMDR field.
	FACI_FCMDR_PCMDR_Msk = 0xff
	// Position of CMDR field.
	FACI_FCMDR_CMDR_Pos = 0x8
	// Bit mask of CMDR field.
	FACI_FCMDR_CMDR_Msk = 0xff00

	// FBCCNT: Blank Check Control Register
	// Position of BCDIR field.
	FACI_FBCCNT_BCDIR_Pos = 0x0
	// Bit mask of BCDIR field.
	FACI_FBCCNT_BCDIR_Msk = 0x1
	// Bit BCDIR.
	FACI_FBCCNT_BCDIR = 0x1
	// Blank checking is executed from the lower addresses to the higher addresses (incremental mode)
	FACI_FBCCNT_BCDIR_0 = 0x0
	// Blank checking is executed from the higher addresses to the lower addresses (decremental mode).
	FACI_FBCCNT_BCDIR_1 = 0x1

	// FBCSTAT: Blank Check Status Register
	// Position of BCST field.
	FACI_FBCSTAT_BCST_Pos = 0x0
	// Bit mask of BCST field.
	FACI_FBCSTAT_BCST_Msk = 0x1
	// Bit BCST.
	FACI_FBCSTAT_BCST = 0x1
	// The target area is in the non-programmed state, that is, the area has been erased but has not yet been reprogrammed
	FACI_FBCSTAT_BCST_0 = 0x0
	// The target area has been programmed with 0s or 1s.
	FACI_FBCSTAT_BCST_1 = 0x1

	// FPSADDR: Data Flash Programming Start Address Register
	// Position of PSADR field.
	FACI_FPSADDR_PSADR_Pos = 0x0
	// Bit mask of PSADR field.
	FACI_FPSADDR_PSADR_Msk = 0x1ffff

	// FSUASMON: Flash Startup Area Select Monitor Register
	// Position of FSPR field.
	FACI_FSUASMON_FSPR_Pos = 0xf
	// Bit mask of FSPR field.
	FACI_FSUASMON_FSPR_Msk = 0x8000
	// Bit FSPR.
	FACI_FSUASMON_FSPR = 0x8000
	// Protected state
	FACI_FSUASMON_FSPR_0 = 0x0
	// Non-protected state.
	FACI_FSUASMON_FSPR_1 = 0x1
	// Position of BTFLG field.
	FACI_FSUASMON_BTFLG_Pos = 0x1f
	// Bit mask of BTFLG field.
	FACI_FSUASMON_BTFLG_Msk = 0x80000000
	// Bit BTFLG.
	FACI_FSUASMON_BTFLG = 0x80000000
	// The startup area is the alternate block (block 1)
	FACI_FSUASMON_BTFLG_0 = 0x0
	// The startup area is the default block (block 0).
	FACI_FSUASMON_BTFLG_1 = 0x1

	// FCPSR: Flash Sequencer Processing Switching Register
	// Position of ESUSPMD field.
	FACI_FCPSR_ESUSPMD_Pos = 0x0
	// Bit mask of ESUSPMD field.
	FACI_FCPSR_ESUSPMD_Msk = 0x1
	// Bit ESUSPMD.
	FACI_FCPSR_ESUSPMD = 0x1
	// Suspension priority mode
	FACI_FCPSR_ESUSPMD_0 = 0x0
	// Erasure priority mode.
	FACI_FCPSR_ESUSPMD_1 = 0x1

	// FPCKAR: Flash Sequencer Processing Clock Notification Register
	// Position of PCKA field.
	FACI_FPCKAR_PCKA_Pos = 0x0
	// Bit mask of PCKA field.
	FACI_FPCKAR_PCKA_Msk = 0xff
	// Position of KEY field.
	FACI_FPCKAR_KEY_Pos = 0x8
	// Bit mask of KEY field.
	FACI_FPCKAR_KEY_Msk = 0xff00

	// FSUACR: Flash Startup Area Control Register
	// Position of SAS field.
	FACI_FSUACR_SAS_Pos = 0x0
	// Bit mask of SAS field.
	FACI_FSUACR_SAS_Msk = 0x3
	// Startup area is selected by BTFLG bit
	FACI_FSUACR_SAS_00 = 0x0
	// Startup area is selected by BTFLG bit
	FACI_FSUACR_SAS_01 = 0x1
	// Startup area is temporarily switched to the default area (block 0)
	FACI_FSUACR_SAS_10 = 0x2
	// Startup area is temporarily switched to the alternate area (block 1).
	FACI_FSUACR_SAS_11 = 0x3
	// Position of KEY field.
	FACI_FSUACR_KEY_Pos = 0x8
	// Bit mask of KEY field.
	FACI_FSUACR_KEY_Msk = 0xff00
)

// Constants for QSPI: Quad Serial Peripheral Interface
const (
	// SFMSMD: Transfer Mode Control Register
	// Position of SFMRM field.
	QSPI_SFMSMD_SFMRM_Pos = 0x0
	// Bit mask of SFMRM field.
	QSPI_SFMSMD_SFMRM_Msk = 0x7
	// Standard Read
	QSPI_SFMSMD_SFMRM_000 = 0x0
	// Fast Read
	QSPI_SFMSMD_SFMRM_001 = 0x1
	// Fast Read Dual Output
	QSPI_SFMSMD_SFMRM_010 = 0x2
	// Fast Read Dual I/O
	QSPI_SFMSMD_SFMRM_011 = 0x3
	// Fast Read Quad Output
	QSPI_SFMSMD_SFMRM_100 = 0x4
	// Fast Read Quad I/O
	QSPI_SFMSMD_SFMRM_101 = 0x5
	// Position of SFMSE field.
	QSPI_SFMSMD_SFMSE_Pos = 0x4
	// Bit mask of SFMSE field.
	QSPI_SFMSMD_SFMSE_Msk = 0x30
	// Do not extend QSSL
	QSPI_SFMSMD_SFMSE_00 = 0x0
	// Extend QSSL by 33 QSPCLK
	QSPI_SFMSMD_SFMSE_01 = 0x1
	// Extend QSSL by 129 QSPCLK
	QSPI_SFMSMD_SFMSE_10 = 0x2
	// Extend QSSL infinitely
	QSPI_SFMSMD_SFMSE_11 = 0x3
	// Position of SFMPFE field.
	QSPI_SFMSMD_SFMPFE_Pos = 0x6
	// Bit mask of SFMPFE field.
	QSPI_SFMSMD_SFMPFE_Msk = 0x40
	// Bit SFMPFE.
	QSPI_SFMSMD_SFMPFE = 0x40
	// Disable function
	QSPI_SFMSMD_SFMPFE_0 = 0x0
	// Enable function
	QSPI_SFMSMD_SFMPFE_1 = 0x1
	// Position of SFMPAE field.
	QSPI_SFMSMD_SFMPAE_Pos = 0x7
	// Bit mask of SFMPAE field.
	QSPI_SFMSMD_SFMPAE_Msk = 0x80
	// Bit SFMPAE.
	QSPI_SFMSMD_SFMPAE = 0x80
	// Disable function
	QSPI_SFMSMD_SFMPAE_0 = 0x0
	// Enable function
	QSPI_SFMSMD_SFMPAE_1 = 0x1
	// Position of SFMMD3 field.
	QSPI_SFMSMD_SFMMD3_Pos = 0x8
	// Bit mask of SFMMD3 field.
	QSPI_SFMSMD_SFMMD3_Msk = 0x100
	// Bit SFMMD3.
	QSPI_SFMSMD_SFMMD3 = 0x100
	// SPI mode 0
	QSPI_SFMSMD_SFMMD3_0 = 0x0
	// SPI mode 3
	QSPI_SFMSMD_SFMMD3_1 = 0x1
	// Position of SFMOEX field.
	QSPI_SFMSMD_SFMOEX_Pos = 0x9
	// Bit mask of SFMOEX field.
	QSPI_SFMSMD_SFMOEX_Msk = 0x200
	// Bit SFMOEX.
	QSPI_SFMSMD_SFMOEX = 0x200
	// Do not extend
	QSPI_SFMSMD_SFMOEX_0 = 0x0
	// Extend by 1 QSPCLK
	QSPI_SFMSMD_SFMOEX_1 = 0x1
	// Position of SFMOHW field.
	QSPI_SFMSMD_SFMOHW_Pos = 0xa
	// Bit mask of SFMOHW field.
	QSPI_SFMSMD_SFMOHW_Msk = 0x400
	// Bit SFMOHW.
	QSPI_SFMSMD_SFMOHW = 0x400
	// Do not extend high-level width of QSPCLK during transmission
	QSPI_SFMSMD_SFMOHW_0 = 0x0
	// Extend high-level width of QSPCLK by 1 PCLKA during transmission
	QSPI_SFMSMD_SFMOHW_1 = 0x1
	// Position of SFMOSW field.
	QSPI_SFMSMD_SFMOSW_Pos = 0xb
	// Bit mask of SFMOSW field.
	QSPI_SFMSMD_SFMOSW_Msk = 0x800
	// Bit SFMOSW.
	QSPI_SFMSMD_SFMOSW = 0x800
	// Do not extend low-level width of QSPCLK during transmission
	QSPI_SFMSMD_SFMOSW_0 = 0x0
	// Extend low-level width of QSPCLK by 1 PCLKA during transmission
	QSPI_SFMSMD_SFMOSW_1 = 0x1
	// Position of SFMCCE field.
	QSPI_SFMSMD_SFMCCE_Pos = 0xf
	// Bit mask of SFMCCE field.
	QSPI_SFMSMD_SFMCCE_Msk = 0x8000
	// Bit SFMCCE.
	QSPI_SFMSMD_SFMCCE = 0x8000
	// Uses automatically generated SPI instruction code
	QSPI_SFMSMD_SFMCCE_0 = 0x0
	// Use instruction code in the SFMSIC register
	QSPI_SFMSMD_SFMCCE_1 = 0x1

	// SFMSSC: Chip Selection Control Register
	// Position of SFMSW field.
	QSPI_SFMSSC_SFMSW_Pos = 0x0
	// Bit mask of SFMSW field.
	QSPI_SFMSSC_SFMSW_Msk = 0xf
	// 1 QSPCLK
	QSPI_SFMSSC_SFMSW_0x0 = 0x0
	// 2 QSPCLK
	QSPI_SFMSSC_SFMSW_0x1 = 0x1
	// 3 QSPCLK
	QSPI_SFMSSC_SFMSW_0x2 = 0x2
	// 4 QSPCLK
	QSPI_SFMSSC_SFMSW_0x3 = 0x3
	// 5 QSPCLK
	QSPI_SFMSSC_SFMSW_0x4 = 0x4
	// 6 QSPCLK
	QSPI_SFMSSC_SFMSW_0x5 = 0x5
	// 7 QSPCLK
	QSPI_SFMSSC_SFMSW_0x6 = 0x6
	// 8 QSPCLK
	QSPI_SFMSSC_SFMSW_0x7 = 0x7
	// 9 QSPCLK
	QSPI_SFMSSC_SFMSW_0x8 = 0x8
	// 10 QSPCLK
	QSPI_SFMSSC_SFMSW_0x9 = 0x9
	// 11 QSPCLK
	QSPI_SFMSSC_SFMSW_0xA = 0xa
	// 12 QSPCLK
	QSPI_SFMSSC_SFMSW_0xB = 0xb
	// 13 QSPCLK
	QSPI_SFMSSC_SFMSW_0xC = 0xc
	// 14 QSPCLK
	QSPI_SFMSSC_SFMSW_0xD = 0xd
	// 15 QSPCLK
	QSPI_SFMSSC_SFMSW_0xE = 0xe
	// 16 QSPCLK
	QSPI_SFMSSC_SFMSW_0xF = 0xf
	// Position of SFMSHD field.
	QSPI_SFMSSC_SFMSHD_Pos = 0x4
	// Bit mask of SFMSHD field.
	QSPI_SFMSSC_SFMSHD_Msk = 0x10
	// Bit SFMSHD.
	QSPI_SFMSSC_SFMSHD = 0x10
	// QSSL outputs high after 0.5 QSPCLK cycles from the last rising edge of QSPCLK.
	QSPI_SFMSSC_SFMSHD_0 = 0x0
	// QSSL outputs high after 1.5 QSPCLK cycles from the last rising edge of QSPCLK.
	QSPI_SFMSSC_SFMSHD_1 = 0x1
	// Position of SFMSLD field.
	QSPI_SFMSSC_SFMSLD_Pos = 0x5
	// Bit mask of SFMSLD field.
	QSPI_SFMSSC_SFMSLD_Msk = 0x20
	// Bit SFMSLD.
	QSPI_SFMSSC_SFMSLD = 0x20
	// QSSL outputs low before 0.5 QSPCLK cycles from the first rising edge of QSPCLK.
	QSPI_SFMSSC_SFMSLD_0 = 0x0
	// QSSL outputs low before 1.5 QSPCLK cycles from the first rising edge of QSPCLK.
	QSPI_SFMSSC_SFMSLD_1 = 0x1

	// SFMSKC: Clock Control Register
	// Position of SFMDV field.
	QSPI_SFMSKC_SFMDV_Pos = 0x0
	// Bit mask of SFMDV field.
	QSPI_SFMSKC_SFMDV_Msk = 0x1f
	// 2 PCLKA
	QSPI_SFMSKC_SFMDV_0x00 = 0x0
	// 3 PCLKA (divided by an odd number)
	QSPI_SFMSKC_SFMDV_0x01 = 0x1
	// 4 PCLKA
	QSPI_SFMSKC_SFMDV_0x02 = 0x2
	// 5 PCLKA (divided by an odd number)
	QSPI_SFMSKC_SFMDV_0x03 = 0x3
	// 6 PCLKA
	QSPI_SFMSKC_SFMDV_0x04 = 0x4
	// 7 PCLKA (divided by an odd number)
	QSPI_SFMSKC_SFMDV_0x05 = 0x5
	// 8 PCLKA
	QSPI_SFMSKC_SFMDV_0x06 = 0x6
	// 9 PCLKA (divided by an odd number)
	QSPI_SFMSKC_SFMDV_0x07 = 0x7
	// 10 PCLKA
	QSPI_SFMSKC_SFMDV_0x08 = 0x8
	// 11 PCLKA (divided by an odd number)
	QSPI_SFMSKC_SFMDV_0x09 = 0x9
	// 12 PCLKA
	QSPI_SFMSKC_SFMDV_0x0A = 0xa
	// 13 PCLKA (divided by an odd number)
	QSPI_SFMSKC_SFMDV_0x0B = 0xb
	// 14 PCLKA
	QSPI_SFMSKC_SFMDV_0x0C = 0xc
	// 15 PCLKA (divided by an odd number)
	QSPI_SFMSKC_SFMDV_0x0D = 0xd
	// 16 PCLKA
	QSPI_SFMSKC_SFMDV_0x0E = 0xe
	// 17 PCLKA (divided by an odd number)
	QSPI_SFMSKC_SFMDV_0x0F = 0xf
	// 18 PCLKA
	QSPI_SFMSKC_SFMDV_0x10 = 0x10
	// 20 PCLKA
	QSPI_SFMSKC_SFMDV_0x11 = 0x11
	// 22 PCLKA
	QSPI_SFMSKC_SFMDV_0x12 = 0x12
	// 24 PCLKA
	QSPI_SFMSKC_SFMDV_0x13 = 0x13
	// 26 PCLKA
	QSPI_SFMSKC_SFMDV_0x14 = 0x14
	// 28 PCLKA
	QSPI_SFMSKC_SFMDV_0x15 = 0x15
	// 30 PCLKA
	QSPI_SFMSKC_SFMDV_0x16 = 0x16
	// 32 PCLKA
	QSPI_SFMSKC_SFMDV_0x17 = 0x17
	// 34 PCLKA
	QSPI_SFMSKC_SFMDV_0x18 = 0x18
	// 36 PCLKA
	QSPI_SFMSKC_SFMDV_0x19 = 0x19
	// 38 PCLKA
	QSPI_SFMSKC_SFMDV_0x1A = 0x1a
	// 40 PCLKA
	QSPI_SFMSKC_SFMDV_0x1B = 0x1b
	// 42 PCLKA
	QSPI_SFMSKC_SFMDV_0x1C = 0x1c
	// 44 PCLKA
	QSPI_SFMSKC_SFMDV_0x1D = 0x1d
	// 46 PCLKA
	QSPI_SFMSKC_SFMDV_0x1E = 0x1e
	// 48 PCLKA
	QSPI_SFMSKC_SFMDV_0x1F = 0x1f
	// Position of SFMDTY field.
	QSPI_SFMSKC_SFMDTY_Pos = 0x5
	// Bit mask of SFMDTY field.
	QSPI_SFMSKC_SFMDTY_Msk = 0x20
	// Bit SFMDTY.
	QSPI_SFMSKC_SFMDTY = 0x20
	// Make no correction
	QSPI_SFMSKC_SFMDTY_0 = 0x0
	// Make correction
	QSPI_SFMSKC_SFMDTY_1 = 0x1

	// SFMSST: Status Register
	// Position of PFCNT field.
	QSPI_SFMSST_PFCNT_Pos = 0x0
	// Bit mask of PFCNT field.
	QSPI_SFMSST_PFCNT_Msk = 0x1f
	// 0 byte
	QSPI_SFMSST_PFCNT_0x00 = 0x0
	// 1 byte
	QSPI_SFMSST_PFCNT_0x01 = 0x1
	// 2 bytes
	QSPI_SFMSST_PFCNT_0x02 = 0x2
	// 3 bytes
	QSPI_SFMSST_PFCNT_0x03 = 0x3
	// 4 bytes
	QSPI_SFMSST_PFCNT_0x04 = 0x4
	// 5 bytes
	QSPI_SFMSST_PFCNT_0x05 = 0x5
	// 6 bytes
	QSPI_SFMSST_PFCNT_0x06 = 0x6
	// 7 bytes
	QSPI_SFMSST_PFCNT_0x07 = 0x7
	// 8 bytes
	QSPI_SFMSST_PFCNT_0x08 = 0x8
	// 9 bytes
	QSPI_SFMSST_PFCNT_0x09 = 0x9
	// 10 bytes
	QSPI_SFMSST_PFCNT_0x0A = 0xa
	// 11 bytes
	QSPI_SFMSST_PFCNT_0x0B = 0xb
	// 12 bytes
	QSPI_SFMSST_PFCNT_0x0C = 0xc
	// 13 bytes
	QSPI_SFMSST_PFCNT_0x0D = 0xd
	// 14 bytes
	QSPI_SFMSST_PFCNT_0x0E = 0xe
	// 15 bytes
	QSPI_SFMSST_PFCNT_0x0F = 0xf
	// 16 bytes
	QSPI_SFMSST_PFCNT_0x10 = 0x10
	// 17 bytes
	QSPI_SFMSST_PFCNT_0x11 = 0x11
	// 18 bytes
	QSPI_SFMSST_PFCNT_0x12 = 0x12
	// Position of PFFUL field.
	QSPI_SFMSST_PFFUL_Pos = 0x6
	// Bit mask of PFFUL field.
	QSPI_SFMSST_PFFUL_Msk = 0x40
	// Bit PFFUL.
	QSPI_SFMSST_PFFUL = 0x40
	// Prefetch buffer has free space
	QSPI_SFMSST_PFFUL_0 = 0x0
	// Prefetch buffer is full
	QSPI_SFMSST_PFFUL_1 = 0x1
	// Position of PFOFF field.
	QSPI_SFMSST_PFOFF_Pos = 0x7
	// Bit mask of PFOFF field.
	QSPI_SFMSST_PFOFF_Msk = 0x80
	// Bit PFOFF.
	QSPI_SFMSST_PFOFF = 0x80
	// Prefetch function operating
	QSPI_SFMSST_PFOFF_0 = 0x0
	// Prefetch function not enabled or not operating
	QSPI_SFMSST_PFOFF_1 = 0x1

	// SFMCOM: Communication Port Register
	// Position of SFMD field.
	QSPI_SFMCOM_SFMD_Pos = 0x0
	// Bit mask of SFMD field.
	QSPI_SFMCOM_SFMD_Msk = 0xff

	// SFMCMD: Communication Mode Control Register
	// Position of DCOM field.
	QSPI_SFMCMD_DCOM_Pos = 0x0
	// Bit mask of DCOM field.
	QSPI_SFMCMD_DCOM_Msk = 0x1
	// Bit DCOM.
	QSPI_SFMCMD_DCOM = 0x1
	// ROM access mode
	QSPI_SFMCMD_DCOM_0 = 0x0
	// Direct communication mode
	QSPI_SFMCMD_DCOM_1 = 0x1

	// SFMCST: Communication Status Register
	// Position of COMBSY field.
	QSPI_SFMCST_COMBSY_Pos = 0x0
	// Bit mask of COMBSY field.
	QSPI_SFMCST_COMBSY_Msk = 0x1
	// Bit COMBSY.
	QSPI_SFMCST_COMBSY = 0x1
	// No serial transfer being processed
	QSPI_SFMCST_COMBSY_0 = 0x0
	// Serial transfer being processed
	QSPI_SFMCST_COMBSY_1 = 0x1
	// Position of EROMR field.
	QSPI_SFMCST_EROMR_Pos = 0x7
	// Bit mask of EROMR field.
	QSPI_SFMCST_EROMR_Msk = 0x80
	// Bit EROMR.
	QSPI_SFMCST_EROMR = 0x80
	// ROM access not detected
	QSPI_SFMCST_EROMR_0 = 0x0
	// ROM access detected
	QSPI_SFMCST_EROMR_1 = 0x1

	// SFMSIC: Instruction Code Register
	// Position of SFMCIC field.
	QSPI_SFMSIC_SFMCIC_Pos = 0x0
	// Bit mask of SFMCIC field.
	QSPI_SFMSIC_SFMCIC_Msk = 0xff

	// SFMSAC: Address Mode Control Register
	// Position of SFMAS field.
	QSPI_SFMSAC_SFMAS_Pos = 0x0
	// Bit mask of SFMAS field.
	QSPI_SFMSAC_SFMAS_Msk = 0x3
	// 1 byte
	QSPI_SFMSAC_SFMAS_00 = 0x0
	// 2 bytes
	QSPI_SFMSAC_SFMAS_01 = 0x1
	// 3 bytes
	QSPI_SFMSAC_SFMAS_10 = 0x2
	// 4 bytes
	QSPI_SFMSAC_SFMAS_11 = 0x3
	// Position of SFM4BC field.
	QSPI_SFMSAC_SFM4BC_Pos = 0x4
	// Bit mask of SFM4BC field.
	QSPI_SFMSAC_SFM4BC_Msk = 0x10
	// Bit SFM4BC.
	QSPI_SFMSAC_SFM4BC = 0x10
	// Do not use 4-byte address read instruction code
	QSPI_SFMSAC_SFM4BC_0 = 0x0
	// Use 4-byte address read instruction code
	QSPI_SFMSAC_SFM4BC_1 = 0x1

	// SFMSDC: Dummy Cycle Control Register
	// Position of SFMDN field.
	QSPI_SFMSDC_SFMDN_Pos = 0x0
	// Bit mask of SFMDN field.
	QSPI_SFMSDC_SFMDN_Msk = 0xf
	// Default dummy cycles for each instruction: - Fast Read Quad I/O: 6 QSPCLK - Fast Read Quad Output: 8 QSPCLK - Fast Read Dual I/O: 4 QSPCLK - Fast Read Dual Output: 8 QSPCLK - Fast Read: 8 QSPCLK
	QSPI_SFMSDC_SFMDN_0x0 = 0x0
	// 3 QSPCLK
	QSPI_SFMSDC_SFMDN_0x1 = 0x1
	// 4 QSPCLK
	QSPI_SFMSDC_SFMDN_0x2 = 0x2
	// 5 QSPCLK
	QSPI_SFMSDC_SFMDN_0x3 = 0x3
	// 6 QSPCLK
	QSPI_SFMSDC_SFMDN_0x4 = 0x4
	// 7 QSPCLK
	QSPI_SFMSDC_SFMDN_0x5 = 0x5
	// 8 QSPCLK
	QSPI_SFMSDC_SFMDN_0x6 = 0x6
	// 9 QSPCLK
	QSPI_SFMSDC_SFMDN_0x7 = 0x7
	// 10 QSPCLK
	QSPI_SFMSDC_SFMDN_0x8 = 0x8
	// 11 QSPCLK
	QSPI_SFMSDC_SFMDN_0x9 = 0x9
	// 12 QSPCLK
	QSPI_SFMSDC_SFMDN_0xA = 0xa
	// 13 QSPCLK
	QSPI_SFMSDC_SFMDN_0xB = 0xb
	// 14 QSPCLK
	QSPI_SFMSDC_SFMDN_0xC = 0xc
	// 15 QSPCLK
	QSPI_SFMSDC_SFMDN_0xD = 0xd
	// 16 QSPCLK
	QSPI_SFMSDC_SFMDN_0xE = 0xe
	// 17 QSPCLK
	QSPI_SFMSDC_SFMDN_0xF = 0xf
	// Position of SFMXST field.
	QSPI_SFMSDC_SFMXST_Pos = 0x6
	// Bit mask of SFMXST field.
	QSPI_SFMSDC_SFMXST_Msk = 0x40
	// Bit SFMXST.
	QSPI_SFMSDC_SFMXST = 0x40
	// Normal (non-XIP) mode
	QSPI_SFMSDC_SFMXST_0 = 0x0
	// XIP mode
	QSPI_SFMSDC_SFMXST_1 = 0x1
	// Position of SFMXEN field.
	QSPI_SFMSDC_SFMXEN_Pos = 0x7
	// Bit mask of SFMXEN field.
	QSPI_SFMSDC_SFMXEN_Msk = 0x80
	// Bit SFMXEN.
	QSPI_SFMSDC_SFMXEN = 0x80
	// Prohibit XIP mode
	QSPI_SFMSDC_SFMXEN_0 = 0x0
	// Permit XIP mode
	QSPI_SFMSDC_SFMXEN_1 = 0x1
	// Position of SFMXD field.
	QSPI_SFMSDC_SFMXD_Pos = 0x8
	// Bit mask of SFMXD field.
	QSPI_SFMSDC_SFMXD_Msk = 0xff00

	// SFMSPC: SPI Protocol Control Register
	// Position of SFMSPI field.
	QSPI_SFMSPC_SFMSPI_Pos = 0x0
	// Bit mask of SFMSPI field.
	QSPI_SFMSPC_SFMSPI_Msk = 0x3
	// Single SPI Protocol, Extended SPI protocol
	QSPI_SFMSPC_SFMSPI_00 = 0x0
	// Dual SPI protocol
	QSPI_SFMSPC_SFMSPI_01 = 0x1
	// Quad SPI protocol
	QSPI_SFMSPC_SFMSPI_10 = 0x2
	// Setting prohibited
	QSPI_SFMSPC_SFMSPI_11 = 0x3
	// Position of SFMSDE field.
	QSPI_SFMSPC_SFMSDE_Pos = 0x4
	// Bit mask of SFMSDE field.
	QSPI_SFMSPC_SFMSDE_Msk = 0x10
	// Bit SFMSDE.
	QSPI_SFMSPC_SFMSDE = 0x10
	// No QSPCLK extension
	QSPI_SFMSPC_SFMSDE_0 = 0x0
	// QSPCLK expansion when switching I/O direction of QIOn pin
	QSPI_SFMSPC_SFMSDE_1 = 0x1

	// SFMPMD: Port Control Register
	// Position of SFMWPL field.
	QSPI_SFMPMD_SFMWPL_Pos = 0x2
	// Bit mask of SFMWPL field.
	QSPI_SFMPMD_SFMWPL_Msk = 0x4
	// Bit SFMWPL.
	QSPI_SFMPMD_SFMWPL = 0x4
	// Low level
	QSPI_SFMPMD_SFMWPL_0 = 0x0
	// High level
	QSPI_SFMPMD_SFMWPL_1 = 0x1

	// SFMCNT1: External QSPI Address Register
	// Position of QSPI_EXT field.
	QSPI_SFMCNT1_QSPI_EXT_Pos = 0x1a
	// Bit mask of QSPI_EXT field.
	QSPI_SFMCNT1_QSPI_EXT_Msk = 0xfc000000
)
