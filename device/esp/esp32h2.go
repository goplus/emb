// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from esp32h2.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/Espressif

//go:build esp && esp32h2

/*
// 32-bit RISC-V MCU & Bluetooth 5 (LE) & IEEE 802.15.4
*/
//     Copyright 2023 Espressif Systems (Shanghai) PTE LTD Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
package esp

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "ESP32-H2"
	CPU          = "RV32IMAC"
	FPUPresent   = false
	NVICPrioBits = 0
)

// Interrupt numbers.
const (
	// PMU Peripheral
	IRQ_PMU = 0

	// eFuse Controller
	IRQ_EFUSE = 1

	// Low-power Timer
	IRQ_LP_RTC_TIMER = 2

	// Low-power Timer
	IRQ_LP_BLE_TIMER = 3

	// Low-power Watchdog Timer
	IRQ_LP_WDT = 4

	// LP_PERI Peripheral
	IRQ_LP_PERI_TIMEOUT = 5

	// Low-power Access Permission Management Controller
	IRQ_LP_APM_M0 = 6

	// Interrupt Controller (Core 0)
	IRQ_FROM_CPU_INTR0 = 7

	// Interrupt Controller (Core 0)
	IRQ_FROM_CPU_INTR1 = 8

	// Interrupt Controller (Core 0)
	IRQ_FROM_CPU_INTR2 = 9

	// Interrupt Controller (Core 0)
	IRQ_FROM_CPU_INTR3 = 10

	// Debug Assist
	IRQ_ASSIST_DEBUG = 11

	// RISC-V Trace Encoder
	IRQ_TRACE = 12

	// Interrupt Controller (Core 0)
	IRQ_CACHE = 13

	// Interrupt Controller (Core 0)
	IRQ_CPU_PERI_TIMEOUT = 14

	// Interrupt Controller (Core 0)
	IRQ_BT_MAC = 15

	// Interrupt Controller (Core 0)
	IRQ_BT_BB = 16

	// Interrupt Controller (Core 0)
	IRQ_BT_BB_NMI = 17

	// Interrupt Controller (Core 0)
	IRQ_COEX = 18

	// Interrupt Controller (Core 0)
	IRQ_BLE_TIMER = 19

	// Interrupt Controller (Core 0)
	IRQ_BLE_SEC = 20

	// Interrupt Controller (Core 0)
	IRQ_ZB_MAC = 21

	// General Purpose Input/Output
	IRQ_GPIO = 22

	// General Purpose Input/Output
	IRQ_GPIO_NMI = 23

	// PAU Peripheral
	IRQ_PAU = 24

	// High-Power System
	IRQ_HP_PERI_TIMEOUT = 25

	// HP_APM Peripheral
	IRQ_HP_APM_M0 = 26

	// HP_APM Peripheral
	IRQ_HP_APM_M1 = 27

	// HP_APM Peripheral
	IRQ_HP_APM_M2 = 28

	// HP_APM Peripheral
	IRQ_HP_APM_M3 = 29

	// SPI (Serial Peripheral Interface) Controller 2
	IRQ_MSPI = 30

	// I2S (Inter-IC Sound) Controller 0
	IRQ_I2S1 = 31

	// Universal Host Controller Interface 0
	IRQ_UHCI0 = 32

	// UART (Universal Asynchronous Receiver-Transmitter) Controller 0
	IRQ_UART0 = 33

	// UART (Universal Asynchronous Receiver-Transmitter) Controller 1
	IRQ_UART1 = 34

	// LED Control PWM (Pulse Width Modulation)
	IRQ_LEDC = 35

	// Two-Wire Automotive Interface
	IRQ_TWAI0 = 36

	// Full-speed USB Serial/JTAG Controller
	IRQ_USB_DEVICE = 37

	// Remote Control
	IRQ_RMT = 38

	// I2C (Inter-Integrated Circuit) Controller 0
	IRQ_I2C_EXT0 = 39

	// I2C (Inter-Integrated Circuit) Controller 1
	IRQ_I2C_EXT1 = 40

	// Timer Group 0
	IRQ_TG0_T0_LEVEL = 41

	// Timer Group 0
	IRQ_TG0_WDT_LEVEL = 42

	// Timer Group 1
	IRQ_TG1_T0_LEVEL = 43

	// Timer Group 1
	IRQ_TG1_WDT_LEVEL = 44

	// System Timer
	IRQ_SYSTIMER_TARGET0 = 45

	// System Timer
	IRQ_SYSTIMER_TARGET1 = 46

	// System Timer
	IRQ_SYSTIMER_TARGET2 = 47

	// SAR (Successive Approximation Register) Analog-to-Digital Converter
	IRQ_APB_ADC = 48

	// Motor Control Pulse-Width Modulation 0
	IRQ_MCPWM0 = 49

	// Pulse Count Controller
	IRQ_PCNT = 50

	// Parallel IO Controller
	IRQ_PARL_IO_TX = 51

	// Parallel IO Controller
	IRQ_PARL_IO_RX = 52

	// DMA (Direct Memory Access) Controller
	IRQ_DMA_IN_CH0 = 53

	// DMA (Direct Memory Access) Controller
	IRQ_DMA_IN_CH1 = 54

	// DMA (Direct Memory Access) Controller
	IRQ_DMA_IN_CH2 = 55

	// DMA (Direct Memory Access) Controller
	IRQ_DMA_OUT_CH0 = 56

	// DMA (Direct Memory Access) Controller
	IRQ_DMA_OUT_CH1 = 57

	// DMA (Direct Memory Access) Controller
	IRQ_DMA_OUT_CH2 = 58

	// SPI (Serial Peripheral Interface) Controller 2
	IRQ_GPSPI2 = 59

	// AES (Advanced Encryption Standard) Accelerator
	IRQ_AES = 60

	// SHA (Secure Hash Algorithm) Accelerator
	IRQ_SHA = 61

	// RSA (Rivest Shamir Adleman) Accelerator
	IRQ_RSA = 62

	// ECC (ECC Hardware Accelerator)
	IRQ_ECC = 63

	// Interrupt Controller (Core 0)
	IRQ_ECDSA = 64

	// Highest interrupt number on this device.
	IRQ_max = 64
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)
func HandleInterrupt(num int) {
	switch num {
	case IRQ_PMU:
		callHandlers(IRQ_PMU)
	case IRQ_EFUSE:
		callHandlers(IRQ_EFUSE)
	case IRQ_LP_RTC_TIMER:
		callHandlers(IRQ_LP_RTC_TIMER)
	case IRQ_LP_BLE_TIMER:
		callHandlers(IRQ_LP_BLE_TIMER)
	case IRQ_LP_WDT:
		callHandlers(IRQ_LP_WDT)
	case IRQ_LP_PERI_TIMEOUT:
		callHandlers(IRQ_LP_PERI_TIMEOUT)
	case IRQ_LP_APM_M0:
		callHandlers(IRQ_LP_APM_M0)
	case IRQ_FROM_CPU_INTR0:
		callHandlers(IRQ_FROM_CPU_INTR0)
	case IRQ_FROM_CPU_INTR1:
		callHandlers(IRQ_FROM_CPU_INTR1)
	case IRQ_FROM_CPU_INTR2:
		callHandlers(IRQ_FROM_CPU_INTR2)
	case IRQ_FROM_CPU_INTR3:
		callHandlers(IRQ_FROM_CPU_INTR3)
	case IRQ_ASSIST_DEBUG:
		callHandlers(IRQ_ASSIST_DEBUG)
	case IRQ_TRACE:
		callHandlers(IRQ_TRACE)
	case IRQ_CACHE:
		callHandlers(IRQ_CACHE)
	case IRQ_CPU_PERI_TIMEOUT:
		callHandlers(IRQ_CPU_PERI_TIMEOUT)
	case IRQ_BT_MAC:
		callHandlers(IRQ_BT_MAC)
	case IRQ_BT_BB:
		callHandlers(IRQ_BT_BB)
	case IRQ_BT_BB_NMI:
		callHandlers(IRQ_BT_BB_NMI)
	case IRQ_COEX:
		callHandlers(IRQ_COEX)
	case IRQ_BLE_TIMER:
		callHandlers(IRQ_BLE_TIMER)
	case IRQ_BLE_SEC:
		callHandlers(IRQ_BLE_SEC)
	case IRQ_ZB_MAC:
		callHandlers(IRQ_ZB_MAC)
	case IRQ_GPIO:
		callHandlers(IRQ_GPIO)
	case IRQ_GPIO_NMI:
		callHandlers(IRQ_GPIO_NMI)
	case IRQ_PAU:
		callHandlers(IRQ_PAU)
	case IRQ_HP_PERI_TIMEOUT:
		callHandlers(IRQ_HP_PERI_TIMEOUT)
	case IRQ_HP_APM_M0:
		callHandlers(IRQ_HP_APM_M0)
	case IRQ_HP_APM_M1:
		callHandlers(IRQ_HP_APM_M1)
	case IRQ_HP_APM_M2:
		callHandlers(IRQ_HP_APM_M2)
	case IRQ_HP_APM_M3:
		callHandlers(IRQ_HP_APM_M3)
	case IRQ_MSPI:
		callHandlers(IRQ_MSPI)
	case IRQ_I2S1:
		callHandlers(IRQ_I2S1)
	case IRQ_UHCI0:
		callHandlers(IRQ_UHCI0)
	case IRQ_UART0:
		callHandlers(IRQ_UART0)
	case IRQ_UART1:
		callHandlers(IRQ_UART1)
	case IRQ_LEDC:
		callHandlers(IRQ_LEDC)
	case IRQ_TWAI0:
		callHandlers(IRQ_TWAI0)
	case IRQ_USB_DEVICE:
		callHandlers(IRQ_USB_DEVICE)
	case IRQ_RMT:
		callHandlers(IRQ_RMT)
	case IRQ_I2C_EXT0:
		callHandlers(IRQ_I2C_EXT0)
	case IRQ_I2C_EXT1:
		callHandlers(IRQ_I2C_EXT1)
	case IRQ_TG0_T0_LEVEL:
		callHandlers(IRQ_TG0_T0_LEVEL)
	case IRQ_TG0_WDT_LEVEL:
		callHandlers(IRQ_TG0_WDT_LEVEL)
	case IRQ_TG1_T0_LEVEL:
		callHandlers(IRQ_TG1_T0_LEVEL)
	case IRQ_TG1_WDT_LEVEL:
		callHandlers(IRQ_TG1_WDT_LEVEL)
	case IRQ_SYSTIMER_TARGET0:
		callHandlers(IRQ_SYSTIMER_TARGET0)
	case IRQ_SYSTIMER_TARGET1:
		callHandlers(IRQ_SYSTIMER_TARGET1)
	case IRQ_SYSTIMER_TARGET2:
		callHandlers(IRQ_SYSTIMER_TARGET2)
	case IRQ_APB_ADC:
		callHandlers(IRQ_APB_ADC)
	case IRQ_MCPWM0:
		callHandlers(IRQ_MCPWM0)
	case IRQ_PCNT:
		callHandlers(IRQ_PCNT)
	case IRQ_PARL_IO_TX:
		callHandlers(IRQ_PARL_IO_TX)
	case IRQ_PARL_IO_RX:
		callHandlers(IRQ_PARL_IO_RX)
	case IRQ_DMA_IN_CH0:
		callHandlers(IRQ_DMA_IN_CH0)
	case IRQ_DMA_IN_CH1:
		callHandlers(IRQ_DMA_IN_CH1)
	case IRQ_DMA_IN_CH2:
		callHandlers(IRQ_DMA_IN_CH2)
	case IRQ_DMA_OUT_CH0:
		callHandlers(IRQ_DMA_OUT_CH0)
	case IRQ_DMA_OUT_CH1:
		callHandlers(IRQ_DMA_OUT_CH1)
	case IRQ_DMA_OUT_CH2:
		callHandlers(IRQ_DMA_OUT_CH2)
	case IRQ_GPSPI2:
		callHandlers(IRQ_GPSPI2)
	case IRQ_AES:
		callHandlers(IRQ_AES)
	case IRQ_SHA:
		callHandlers(IRQ_SHA)
	case IRQ_RSA:
		callHandlers(IRQ_RSA)
	case IRQ_ECC:
		callHandlers(IRQ_ECC)
	case IRQ_ECDSA:
		callHandlers(IRQ_ECDSA)
	}
}

// Peripherals.
var (
	// AES (Advanced Encryption Standard) Accelerator
	AES = (*AES_Type)(unsafe.Pointer(uintptr(0x60088000)))

	// SAR (Successive Approximation Register) Analog-to-Digital Converter
	APB_SARADC = (*APB_SARADC_Type)(unsafe.Pointer(uintptr(0x6000e000)))

	// Debug Assist
	ASSIST_DEBUG = (*ASSIST_DEBUG_Type)(unsafe.Pointer(uintptr(0x600c2000)))

	// DMA (Direct Memory Access) Controller
	DMA = (*DMA_Type)(unsafe.Pointer(uintptr(0x60080000)))

	// Digital Signature
	DS = (*DS_Type)(unsafe.Pointer(uintptr(0x6008c000)))

	// ECC (ECC Hardware Accelerator)
	ECC = (*ECC_Type)(unsafe.Pointer(uintptr(0x6008b000)))

	// eFuse Controller
	EFUSE = (*EFUSE_Type)(unsafe.Pointer(uintptr(0x600b0800)))

	// General Purpose Input/Output
	GPIO = (*GPIO_Type)(unsafe.Pointer(uintptr(0x60091000)))

	// Sigma-Delta Modulation
	GPIO_SD = (*GPIOSD_Type)(unsafe.Pointer(uintptr(0x60091f00)))

	// HMAC (Hash-based Message Authentication Code) Accelerator
	HMAC = (*HMAC_Type)(unsafe.Pointer(uintptr(0x6008d000)))

	// HP_APM Peripheral
	HP_APM = (*HP_APM_Type)(unsafe.Pointer(uintptr(0x60099000)))

	// High-Power System
	HP_SYS = (*HP_SYS_Type)(unsafe.Pointer(uintptr(0x60095000)))

	// I2C (Inter-Integrated Circuit) Controller 0
	I2C0 = (*I2C_Type)(unsafe.Pointer(uintptr(0x60004000)))

	// I2S (Inter-IC Sound) Controller 0
	I2S0 = (*I2S_Type)(unsafe.Pointer(uintptr(0x6000d000)))

	// Interrupt Controller (Core 0)
	INTERRUPT_CORE0 = (*INTMTX_CORE0_Type)(unsafe.Pointer(uintptr(0x60010000)))

	// INTPRI Peripheral
	INTPRI = (*INTPRI_Type)(unsafe.Pointer(uintptr(0x600c5000)))

	// Input/Output Multiplexer
	IO_MUX = (*IO_MUX_Type)(unsafe.Pointer(uintptr(0x60090000)))

	// LED Control PWM (Pulse Width Modulation)
	LEDC = (*LEDC_Type)(unsafe.Pointer(uintptr(0x60008000)))

	// LP_PERI Peripheral
	LP_PERI = (*LPPERI_Type)(unsafe.Pointer(uintptr(0x600b2800)))

	// LP_ANA Peripheral
	LP_ANA = (*LP_ANA_Type)(unsafe.Pointer(uintptr(0x600b2c00)))

	// LP_AON Peripheral
	LP_AON = (*LP_AON_Type)(unsafe.Pointer(uintptr(0x600b1000)))

	// Low-power Access Permission Management Controller
	LP_APM = (*LP_APM_Type)(unsafe.Pointer(uintptr(0x600b3800)))

	// LP_CLKRST Peripheral
	LP_CLKRST = (*LP_CLKRST_Type)(unsafe.Pointer(uintptr(0x600b0400)))

	// Low-power Timer
	LP_TIMER = (*LP_TIMER_Type)(unsafe.Pointer(uintptr(0x600b0c00)))

	// Low-power Watchdog Timer
	LP_WDT = (*LP_WDT_Type)(unsafe.Pointer(uintptr(0x600b1c00)))

	// Motor Control Pulse-Width Modulation 0
	MCPWM0 = (*MCPWM_Type)(unsafe.Pointer(uintptr(0x60014000)))

	// MEM_MONITOR Peripheral
	MEM_MONITOR = (*MEM_MONITOR_Type)(unsafe.Pointer(uintptr(0x60092000)))

	// MODEM_LPCON Peripheral
	MODEM_LPCON = (*MODEM_LPCON_Type)(unsafe.Pointer(uintptr(0x600ad000)))

	// MODEM_SYSCON Peripheral
	MODEM_SYSCON = (*MODEM_SYSCON_Type)(unsafe.Pointer(uintptr(0x600a5400)))

	// OTP_DEBUG Peripheral
	OTP_DEBUG = (*OTP_DEBUG_Type)(unsafe.Pointer(uintptr(0x600b3c00)))

	// Parallel IO Controller
	PARL_IO = (*PARL_IO_Type)(unsafe.Pointer(uintptr(0x60015000)))

	// PAU Peripheral
	PAU = (*PAU_Type)(unsafe.Pointer(uintptr(0x60093000)))

	// Pulse Count Controller
	PCNT = (*PCNT_Type)(unsafe.Pointer(uintptr(0x60012000)))

	// PCR Peripheral
	PCR = (*PCR_Type)(unsafe.Pointer(uintptr(0x60096000)))

	// PMU Peripheral
	PMU = (*PMU_Type)(unsafe.Pointer(uintptr(0x600b0000)))

	// Remote Control
	RMT = (*RMT_Type)(unsafe.Pointer(uintptr(0x60007000)))

	// Hardware Random Number Generator
	RNG = (*RNG_Type)(unsafe.Pointer(uintptr(0x600b2800)))

	// RSA (Rivest Shamir Adleman) Accelerator
	RSA = (*RSA_Type)(unsafe.Pointer(uintptr(0x6008a000)))

	// SHA (Secure Hash Algorithm) Accelerator
	SHA = (*SHA_Type)(unsafe.Pointer(uintptr(0x60089000)))

	// Event Task Matrix
	SOC_ETM = (*SOC_ETM_Type)(unsafe.Pointer(uintptr(0x60013000)))

	// SPI (Serial Peripheral Interface) Controller 0
	SPI0 = (*SPI0_Type)(unsafe.Pointer(uintptr(0x60002000)))

	// SPI (Serial Peripheral Interface) Controller 1
	SPI1 = (*SPI1_Type)(unsafe.Pointer(uintptr(0x60003000)))

	// SPI (Serial Peripheral Interface) Controller 2
	SPI2 = (*SPI2_Type)(unsafe.Pointer(uintptr(0x60081000)))

	// System Timer
	SYSTIMER = (*SYSTIMER_Type)(unsafe.Pointer(uintptr(0x6000b000)))

	// TEE Peripheral
	TEE = (*TEE_Type)(unsafe.Pointer(uintptr(0x60098000)))

	// Timer Group 0
	TIMG0 = (*TIMG_Type)(unsafe.Pointer(uintptr(0x60009000)))

	// RISC-V Trace Encoder
	TRACE = (*TRACE_Type)(unsafe.Pointer(uintptr(0x600c0000)))

	// Two-Wire Automotive Interface
	TWAI0 = (*TWAI_Type)(unsafe.Pointer(uintptr(0x6000c000)))

	// UART (Universal Asynchronous Receiver-Transmitter) Controller 0
	UART0 = (*UART_Type)(unsafe.Pointer(uintptr(0x60000000)))

	// Universal Host Controller Interface 0
	UHCI0 = (*UHCI_Type)(unsafe.Pointer(uintptr(0x60006000)))

	// Full-speed USB Serial/JTAG Controller
	USB_DEVICE = (*USB_DEVICE_Type)(unsafe.Pointer(uintptr(0x6000f000)))

	// I2C (Inter-Integrated Circuit) Controller 1
	I2C1 = (*I2C_Type)(unsafe.Pointer(uintptr(0x60005000)))

	// Timer Group 1
	TIMG1 = (*TIMG_Type)(unsafe.Pointer(uintptr(0x6000a000)))

	// UART (Universal Asynchronous Receiver-Transmitter) Controller 1
	UART1 = (*UART_Type)(unsafe.Pointer(uintptr(0x60001000)))
)

// AES (Advanced Encryption Standard) Accelerator
type AES_Type struct {
	KEY_0             volatile.Register32    // 0x0
	KEY_1             volatile.Register32    // 0x4
	KEY_2             volatile.Register32    // 0x8
	KEY_3             volatile.Register32    // 0xC
	KEY_4             volatile.Register32    // 0x10
	KEY_5             volatile.Register32    // 0x14
	KEY_6             volatile.Register32    // 0x18
	KEY_7             volatile.Register32    // 0x1C
	TEXT_IN_0         volatile.Register32    // 0x20
	TEXT_IN_1         volatile.Register32    // 0x24
	TEXT_IN_2         volatile.Register32    // 0x28
	TEXT_IN_3         volatile.Register32    // 0x2C
	TEXT_OUT_0        volatile.Register32    // 0x30
	TEXT_OUT_1        volatile.Register32    // 0x34
	TEXT_OUT_2        volatile.Register32    // 0x38
	TEXT_OUT_3        volatile.Register32    // 0x3C
	MODE              volatile.Register32    // 0x40
	ENDIAN            volatile.Register32    // 0x44
	TRIGGER           volatile.Register32    // 0x48
	STATE             volatile.Register32    // 0x4C
	IV_MEM            [16]volatile.Register8 // 0x50
	H_MEM             [16]volatile.Register8 // 0x60
	J0_MEM            [16]volatile.Register8 // 0x70
	T0_MEM            [16]volatile.Register8 // 0x80
	DMA_ENABLE        volatile.Register32    // 0x90
	BLOCK_MODE        volatile.Register32    // 0x94
	BLOCK_NUM         volatile.Register32    // 0x98
	INC_SEL           volatile.Register32    // 0x9C
	AAD_BLOCK_NUM     volatile.Register32    // 0xA0
	REMAINDER_BIT_NUM volatile.Register32    // 0xA4
	CONTINUE          volatile.Register32    // 0xA8
	INT_CLEAR         volatile.Register32    // 0xAC
	INT_ENA           volatile.Register32    // 0xB0
	DATE              volatile.Register32    // 0xB4
	DMA_EXIT          volatile.Register32    // 0xB8
}

// AES.KEY_0: Key material key_0 configure register
func (o *AES_Type) SetKEY_0(value uint32) {
	volatile.StoreUint32(&o.KEY_0.Reg, value)
}
func (o *AES_Type) GetKEY_0() uint32 {
	return volatile.LoadUint32(&o.KEY_0.Reg)
}

// AES.KEY_1: Key material key_1 configure register
func (o *AES_Type) SetKEY_1(value uint32) {
	volatile.StoreUint32(&o.KEY_1.Reg, value)
}
func (o *AES_Type) GetKEY_1() uint32 {
	return volatile.LoadUint32(&o.KEY_1.Reg)
}

// AES.KEY_2: Key material key_2 configure register
func (o *AES_Type) SetKEY_2(value uint32) {
	volatile.StoreUint32(&o.KEY_2.Reg, value)
}
func (o *AES_Type) GetKEY_2() uint32 {
	return volatile.LoadUint32(&o.KEY_2.Reg)
}

// AES.KEY_3: Key material key_3 configure register
func (o *AES_Type) SetKEY_3(value uint32) {
	volatile.StoreUint32(&o.KEY_3.Reg, value)
}
func (o *AES_Type) GetKEY_3() uint32 {
	return volatile.LoadUint32(&o.KEY_3.Reg)
}

// AES.KEY_4: Key material key_4 configure register
func (o *AES_Type) SetKEY_4(value uint32) {
	volatile.StoreUint32(&o.KEY_4.Reg, value)
}
func (o *AES_Type) GetKEY_4() uint32 {
	return volatile.LoadUint32(&o.KEY_4.Reg)
}

// AES.KEY_5: Key material key_5 configure register
func (o *AES_Type) SetKEY_5(value uint32) {
	volatile.StoreUint32(&o.KEY_5.Reg, value)
}
func (o *AES_Type) GetKEY_5() uint32 {
	return volatile.LoadUint32(&o.KEY_5.Reg)
}

// AES.KEY_6: Key material key_6 configure register
func (o *AES_Type) SetKEY_6(value uint32) {
	volatile.StoreUint32(&o.KEY_6.Reg, value)
}
func (o *AES_Type) GetKEY_6() uint32 {
	return volatile.LoadUint32(&o.KEY_6.Reg)
}

// AES.KEY_7: Key material key_7 configure register
func (o *AES_Type) SetKEY_7(value uint32) {
	volatile.StoreUint32(&o.KEY_7.Reg, value)
}
func (o *AES_Type) GetKEY_7() uint32 {
	return volatile.LoadUint32(&o.KEY_7.Reg)
}

// AES.TEXT_IN_0: source text material text_in_0 configure register
func (o *AES_Type) SetTEXT_IN_0(value uint32) {
	volatile.StoreUint32(&o.TEXT_IN_0.Reg, value)
}
func (o *AES_Type) GetTEXT_IN_0() uint32 {
	return volatile.LoadUint32(&o.TEXT_IN_0.Reg)
}

// AES.TEXT_IN_1: source text material text_in_1 configure register
func (o *AES_Type) SetTEXT_IN_1(value uint32) {
	volatile.StoreUint32(&o.TEXT_IN_1.Reg, value)
}
func (o *AES_Type) GetTEXT_IN_1() uint32 {
	return volatile.LoadUint32(&o.TEXT_IN_1.Reg)
}

// AES.TEXT_IN_2: source text material text_in_2 configure register
func (o *AES_Type) SetTEXT_IN_2(value uint32) {
	volatile.StoreUint32(&o.TEXT_IN_2.Reg, value)
}
func (o *AES_Type) GetTEXT_IN_2() uint32 {
	return volatile.LoadUint32(&o.TEXT_IN_2.Reg)
}

// AES.TEXT_IN_3: source text material text_in_3 configure register
func (o *AES_Type) SetTEXT_IN_3(value uint32) {
	volatile.StoreUint32(&o.TEXT_IN_3.Reg, value)
}
func (o *AES_Type) GetTEXT_IN_3() uint32 {
	return volatile.LoadUint32(&o.TEXT_IN_3.Reg)
}

// AES.TEXT_OUT_0: result text material text_out_0 configure register
func (o *AES_Type) SetTEXT_OUT_0(value uint32) {
	volatile.StoreUint32(&o.TEXT_OUT_0.Reg, value)
}
func (o *AES_Type) GetTEXT_OUT_0() uint32 {
	return volatile.LoadUint32(&o.TEXT_OUT_0.Reg)
}

// AES.TEXT_OUT_1: result text material text_out_1 configure register
func (o *AES_Type) SetTEXT_OUT_1(value uint32) {
	volatile.StoreUint32(&o.TEXT_OUT_1.Reg, value)
}
func (o *AES_Type) GetTEXT_OUT_1() uint32 {
	return volatile.LoadUint32(&o.TEXT_OUT_1.Reg)
}

// AES.TEXT_OUT_2: result text material text_out_2 configure register
func (o *AES_Type) SetTEXT_OUT_2(value uint32) {
	volatile.StoreUint32(&o.TEXT_OUT_2.Reg, value)
}
func (o *AES_Type) GetTEXT_OUT_2() uint32 {
	return volatile.LoadUint32(&o.TEXT_OUT_2.Reg)
}

// AES.TEXT_OUT_3: result text material text_out_3 configure register
func (o *AES_Type) SetTEXT_OUT_3(value uint32) {
	volatile.StoreUint32(&o.TEXT_OUT_3.Reg, value)
}
func (o *AES_Type) GetTEXT_OUT_3() uint32 {
	return volatile.LoadUint32(&o.TEXT_OUT_3.Reg)
}

// AES.MODE: AES Mode register
func (o *AES_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x7)|value)
}
func (o *AES_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x7
}

// AES.ENDIAN: AES Endian configure register
func (o *AES_Type) SetENDIAN(value uint32) {
	volatile.StoreUint32(&o.ENDIAN.Reg, volatile.LoadUint32(&o.ENDIAN.Reg)&^(0x3f)|value)
}
func (o *AES_Type) GetENDIAN() uint32 {
	return volatile.LoadUint32(&o.ENDIAN.Reg) & 0x3f
}

// AES.TRIGGER: AES trigger register
func (o *AES_Type) SetTRIGGER(value uint32) {
	volatile.StoreUint32(&o.TRIGGER.Reg, volatile.LoadUint32(&o.TRIGGER.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetTRIGGER() uint32 {
	return volatile.LoadUint32(&o.TRIGGER.Reg) & 0x1
}

// AES.STATE: AES state register
func (o *AES_Type) SetSTATE(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x3)|value)
}
func (o *AES_Type) GetSTATE() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0x3
}

// AES.DMA_ENABLE: DMA-AES working mode register
func (o *AES_Type) SetDMA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA_ENABLE.Reg, volatile.LoadUint32(&o.DMA_ENABLE.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetDMA_ENABLE() uint32 {
	return volatile.LoadUint32(&o.DMA_ENABLE.Reg) & 0x1
}

// AES.BLOCK_MODE: AES cipher block mode register
func (o *AES_Type) SetBLOCK_MODE(value uint32) {
	volatile.StoreUint32(&o.BLOCK_MODE.Reg, volatile.LoadUint32(&o.BLOCK_MODE.Reg)&^(0x7)|value)
}
func (o *AES_Type) GetBLOCK_MODE() uint32 {
	return volatile.LoadUint32(&o.BLOCK_MODE.Reg) & 0x7
}

// AES.BLOCK_NUM: AES block number register
func (o *AES_Type) SetBLOCK_NUM(value uint32) {
	volatile.StoreUint32(&o.BLOCK_NUM.Reg, value)
}
func (o *AES_Type) GetBLOCK_NUM() uint32 {
	return volatile.LoadUint32(&o.BLOCK_NUM.Reg)
}

// AES.INC_SEL: Standard incrementing function configure register
func (o *AES_Type) SetINC_SEL(value uint32) {
	volatile.StoreUint32(&o.INC_SEL.Reg, volatile.LoadUint32(&o.INC_SEL.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetINC_SEL() uint32 {
	return volatile.LoadUint32(&o.INC_SEL.Reg) & 0x1
}

// AES.AAD_BLOCK_NUM: Additional Authential Data block number register
func (o *AES_Type) SetAAD_BLOCK_NUM(value uint32) {
	volatile.StoreUint32(&o.AAD_BLOCK_NUM.Reg, value)
}
func (o *AES_Type) GetAAD_BLOCK_NUM() uint32 {
	return volatile.LoadUint32(&o.AAD_BLOCK_NUM.Reg)
}

// AES.REMAINDER_BIT_NUM: AES remainder bit number register
func (o *AES_Type) SetREMAINDER_BIT_NUM(value uint32) {
	volatile.StoreUint32(&o.REMAINDER_BIT_NUM.Reg, volatile.LoadUint32(&o.REMAINDER_BIT_NUM.Reg)&^(0x7f)|value)
}
func (o *AES_Type) GetREMAINDER_BIT_NUM() uint32 {
	return volatile.LoadUint32(&o.REMAINDER_BIT_NUM.Reg) & 0x7f
}

// AES.CONTINUE: AES continue register
func (o *AES_Type) SetCONTINUE(value uint32) {
	volatile.StoreUint32(&o.CONTINUE.Reg, volatile.LoadUint32(&o.CONTINUE.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetCONTINUE() uint32 {
	return volatile.LoadUint32(&o.CONTINUE.Reg) & 0x1
}

// AES.INT_CLEAR: AES Interrupt clear register
func (o *AES_Type) SetINT_CLEAR(value uint32) {
	volatile.StoreUint32(&o.INT_CLEAR.Reg, volatile.LoadUint32(&o.INT_CLEAR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetINT_CLEAR() uint32 {
	return volatile.LoadUint32(&o.INT_CLEAR.Reg) & 0x1
}

// AES.INT_ENA: AES Interrupt enable register
func (o *AES_Type) SetINT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetINT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}

// AES.DATE: AES version control register
func (o *AES_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *AES_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// AES.DMA_EXIT: AES-DMA exit config
func (o *AES_Type) SetDMA_EXIT(value uint32) {
	volatile.StoreUint32(&o.DMA_EXIT.Reg, volatile.LoadUint32(&o.DMA_EXIT.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetDMA_EXIT() uint32 {
	return volatile.LoadUint32(&o.DMA_EXIT.Reg) & 0x1
}

// SAR (Successive Approximation Register) Analog-to-Digital Converter
type APB_SARADC_Type struct {
	CTRL             volatile.Register32 // 0x0
	CTRL2            volatile.Register32 // 0x4
	FILTER_CTRL1     volatile.Register32 // 0x8
	FSM_WAIT         volatile.Register32 // 0xC
	SAR1_STATUS      volatile.Register32 // 0x10
	SAR2_STATUS      volatile.Register32 // 0x14
	SAR_PATT_TAB1    volatile.Register32 // 0x18
	SAR_PATT_TAB2    volatile.Register32 // 0x1C
	ONETIME_SAMPLE   volatile.Register32 // 0x20
	ARB_CTRL         volatile.Register32 // 0x24
	FILTER_CTRL0     volatile.Register32 // 0x28
	SAR1DATA_STATUS  volatile.Register32 // 0x2C
	SAR2DATA_STATUS  volatile.Register32 // 0x30
	THRES0_CTRL      volatile.Register32 // 0x34
	THRES1_CTRL      volatile.Register32 // 0x38
	THRES_CTRL       volatile.Register32 // 0x3C
	INT_ENA          volatile.Register32 // 0x40
	INT_RAW          volatile.Register32 // 0x44
	INT_ST           volatile.Register32 // 0x48
	INT_CLR          volatile.Register32 // 0x4C
	DMA_CONF         volatile.Register32 // 0x50
	CLKM_CONF        volatile.Register32 // 0x54
	APB_TSENS_CTRL   volatile.Register32 // 0x58
	TSENS_CTRL2      volatile.Register32 // 0x5C
	CALI             volatile.Register32 // 0x60
	APB_TSENS_WAKE   volatile.Register32 // 0x64
	APB_TSENS_SAMPLE volatile.Register32 // 0x68
	_                [912]byte
	CTRL_DATE        volatile.Register32 // 0x3FC
}

// APB_SARADC.CTRL: digital saradc configure register
func (o *APB_SARADC_Type) SetCTRL_SARADC_START_FORCE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *APB_SARADC_Type) GetCTRL_SARADC_START_FORCE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *APB_SARADC_Type) SetCTRL_SARADC_START(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *APB_SARADC_Type) GetCTRL_SARADC_START() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *APB_SARADC_Type) SetCTRL_SARADC_SAR_CLK_GATED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *APB_SARADC_Type) GetCTRL_SARADC_SAR_CLK_GATED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *APB_SARADC_Type) SetCTRL_SARADC_SAR_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x7f80)|value<<7)
}
func (o *APB_SARADC_Type) GetCTRL_SARADC_SAR_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x7f80) >> 7
}
func (o *APB_SARADC_Type) SetCTRL_SARADC_SAR_PATT_LEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x38000)|value<<15)
}
func (o *APB_SARADC_Type) GetCTRL_SARADC_SAR_PATT_LEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x38000) >> 15
}
func (o *APB_SARADC_Type) SetCTRL_SARADC_SAR_PATT_P_CLEAR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *APB_SARADC_Type) GetCTRL_SARADC_SAR_PATT_P_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800000) >> 23
}
func (o *APB_SARADC_Type) SetCTRL_SARADC_XPD_SAR_FORCE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x18000000)|value<<27)
}
func (o *APB_SARADC_Type) GetCTRL_SARADC_XPD_SAR_FORCE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x18000000) >> 27
}
func (o *APB_SARADC_Type) SetCTRL_SARADC2_PWDET_DRV(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetCTRL_SARADC2_PWDET_DRV() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetCTRL_SARADC_WAIT_ARB_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc0000000)|value<<30)
}
func (o *APB_SARADC_Type) GetCTRL_SARADC_WAIT_ARB_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc0000000) >> 30
}

// APB_SARADC.CTRL2: digital saradc configure register
func (o *APB_SARADC_Type) SetCTRL2_SARADC_MEAS_NUM_LIMIT(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x1)|value)
}
func (o *APB_SARADC_Type) GetCTRL2_SARADC_MEAS_NUM_LIMIT() uint32 {
	return volatile.LoadUint32(&o.CTRL2.Reg) & 0x1
}
func (o *APB_SARADC_Type) SetCTRL2_SARADC_MAX_MEAS_NUM(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x1fe)|value<<1)
}
func (o *APB_SARADC_Type) GetCTRL2_SARADC_MAX_MEAS_NUM() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x1fe) >> 1
}
func (o *APB_SARADC_Type) SetCTRL2_SARADC_SAR1_INV(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x200)|value<<9)
}
func (o *APB_SARADC_Type) GetCTRL2_SARADC_SAR1_INV() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x200) >> 9
}
func (o *APB_SARADC_Type) SetCTRL2_SARADC_SAR2_INV(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x400)|value<<10)
}
func (o *APB_SARADC_Type) GetCTRL2_SARADC_SAR2_INV() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x400) >> 10
}
func (o *APB_SARADC_Type) SetCTRL2_SARADC_TIMER_TARGET(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0xfff000)|value<<12)
}
func (o *APB_SARADC_Type) GetCTRL2_SARADC_TIMER_TARGET() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0xfff000) >> 12
}
func (o *APB_SARADC_Type) SetCTRL2_SARADC_TIMER_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x1000000)|value<<24)
}
func (o *APB_SARADC_Type) GetCTRL2_SARADC_TIMER_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x1000000) >> 24
}

// APB_SARADC.FILTER_CTRL1: digital saradc configure register
func (o *APB_SARADC_Type) SetFILTER_CTRL1_APB_SARADC_FILTER_FACTOR1(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL1.Reg, volatile.LoadUint32(&o.FILTER_CTRL1.Reg)&^(0x1c000000)|value<<26)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL1_APB_SARADC_FILTER_FACTOR1() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL1.Reg) & 0x1c000000) >> 26
}
func (o *APB_SARADC_Type) SetFILTER_CTRL1_APB_SARADC_FILTER_FACTOR0(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL1.Reg, volatile.LoadUint32(&o.FILTER_CTRL1.Reg)&^(0xe0000000)|value<<29)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL1_APB_SARADC_FILTER_FACTOR0() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL1.Reg) & 0xe0000000) >> 29
}

// APB_SARADC.FSM_WAIT: digital saradc configure register
func (o *APB_SARADC_Type) SetFSM_WAIT_SARADC_XPD_WAIT(value uint32) {
	volatile.StoreUint32(&o.FSM_WAIT.Reg, volatile.LoadUint32(&o.FSM_WAIT.Reg)&^(0xff)|value)
}
func (o *APB_SARADC_Type) GetFSM_WAIT_SARADC_XPD_WAIT() uint32 {
	return volatile.LoadUint32(&o.FSM_WAIT.Reg) & 0xff
}
func (o *APB_SARADC_Type) SetFSM_WAIT_SARADC_RSTB_WAIT(value uint32) {
	volatile.StoreUint32(&o.FSM_WAIT.Reg, volatile.LoadUint32(&o.FSM_WAIT.Reg)&^(0xff00)|value<<8)
}
func (o *APB_SARADC_Type) GetFSM_WAIT_SARADC_RSTB_WAIT() uint32 {
	return (volatile.LoadUint32(&o.FSM_WAIT.Reg) & 0xff00) >> 8
}
func (o *APB_SARADC_Type) SetFSM_WAIT_SARADC_STANDBY_WAIT(value uint32) {
	volatile.StoreUint32(&o.FSM_WAIT.Reg, volatile.LoadUint32(&o.FSM_WAIT.Reg)&^(0xff0000)|value<<16)
}
func (o *APB_SARADC_Type) GetFSM_WAIT_SARADC_STANDBY_WAIT() uint32 {
	return (volatile.LoadUint32(&o.FSM_WAIT.Reg) & 0xff0000) >> 16
}

// APB_SARADC.SAR1_STATUS: digital saradc configure register
func (o *APB_SARADC_Type) SetSAR1_STATUS(value uint32) {
	volatile.StoreUint32(&o.SAR1_STATUS.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR1_STATUS() uint32 {
	return volatile.LoadUint32(&o.SAR1_STATUS.Reg)
}

// APB_SARADC.SAR2_STATUS: digital saradc configure register
func (o *APB_SARADC_Type) SetSAR2_STATUS(value uint32) {
	volatile.StoreUint32(&o.SAR2_STATUS.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR2_STATUS() uint32 {
	return volatile.LoadUint32(&o.SAR2_STATUS.Reg)
}

// APB_SARADC.SAR_PATT_TAB1: digital saradc configure register
func (o *APB_SARADC_Type) SetSAR_PATT_TAB1_SARADC_SAR_PATT_TAB1(value uint32) {
	volatile.StoreUint32(&o.SAR_PATT_TAB1.Reg, volatile.LoadUint32(&o.SAR_PATT_TAB1.Reg)&^(0xffffff)|value)
}
func (o *APB_SARADC_Type) GetSAR_PATT_TAB1_SARADC_SAR_PATT_TAB1() uint32 {
	return volatile.LoadUint32(&o.SAR_PATT_TAB1.Reg) & 0xffffff
}

// APB_SARADC.SAR_PATT_TAB2: digital saradc configure register
func (o *APB_SARADC_Type) SetSAR_PATT_TAB2_SARADC_SAR_PATT_TAB2(value uint32) {
	volatile.StoreUint32(&o.SAR_PATT_TAB2.Reg, volatile.LoadUint32(&o.SAR_PATT_TAB2.Reg)&^(0xffffff)|value)
}
func (o *APB_SARADC_Type) GetSAR_PATT_TAB2_SARADC_SAR_PATT_TAB2() uint32 {
	return volatile.LoadUint32(&o.SAR_PATT_TAB2.Reg) & 0xffffff
}

// APB_SARADC.ONETIME_SAMPLE: digital saradc configure register
func (o *APB_SARADC_Type) SetONETIME_SAMPLE_SARADC_ONETIME_ATTEN(value uint32) {
	volatile.StoreUint32(&o.ONETIME_SAMPLE.Reg, volatile.LoadUint32(&o.ONETIME_SAMPLE.Reg)&^(0x1800000)|value<<23)
}
func (o *APB_SARADC_Type) GetONETIME_SAMPLE_SARADC_ONETIME_ATTEN() uint32 {
	return (volatile.LoadUint32(&o.ONETIME_SAMPLE.Reg) & 0x1800000) >> 23
}
func (o *APB_SARADC_Type) SetONETIME_SAMPLE_SARADC_ONETIME_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.ONETIME_SAMPLE.Reg, volatile.LoadUint32(&o.ONETIME_SAMPLE.Reg)&^(0x1e000000)|value<<25)
}
func (o *APB_SARADC_Type) GetONETIME_SAMPLE_SARADC_ONETIME_CHANNEL() uint32 {
	return (volatile.LoadUint32(&o.ONETIME_SAMPLE.Reg) & 0x1e000000) >> 25
}
func (o *APB_SARADC_Type) SetONETIME_SAMPLE_SARADC_ONETIME_START(value uint32) {
	volatile.StoreUint32(&o.ONETIME_SAMPLE.Reg, volatile.LoadUint32(&o.ONETIME_SAMPLE.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetONETIME_SAMPLE_SARADC_ONETIME_START() uint32 {
	return (volatile.LoadUint32(&o.ONETIME_SAMPLE.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetONETIME_SAMPLE_SARADC2_ONETIME_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.ONETIME_SAMPLE.Reg, volatile.LoadUint32(&o.ONETIME_SAMPLE.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetONETIME_SAMPLE_SARADC2_ONETIME_SAMPLE() uint32 {
	return (volatile.LoadUint32(&o.ONETIME_SAMPLE.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetONETIME_SAMPLE_SARADC1_ONETIME_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.ONETIME_SAMPLE.Reg, volatile.LoadUint32(&o.ONETIME_SAMPLE.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetONETIME_SAMPLE_SARADC1_ONETIME_SAMPLE() uint32 {
	return (volatile.LoadUint32(&o.ONETIME_SAMPLE.Reg) & 0x80000000) >> 31
}

// APB_SARADC.ARB_CTRL: digital saradc configure register
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_APB_FORCE(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_APB_FORCE() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x4) >> 2
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_RTC_FORCE(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_RTC_FORCE() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x8) >> 3
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_WIFI_FORCE(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_WIFI_FORCE() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x10) >> 4
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_GRANT_FORCE(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_GRANT_FORCE() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x20) >> 5
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_APB_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0xc0)|value<<6)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_APB_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0xc0) >> 6
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_RTC_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_RTC_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x300) >> 8
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_WIFI_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_WIFI_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0xc00) >> 10
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_FIX_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_FIX_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x1000) >> 12
}

// APB_SARADC.FILTER_CTRL0: digital saradc configure register
func (o *APB_SARADC_Type) SetFILTER_CTRL0_APB_SARADC_FILTER_CHANNEL1(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL0.Reg, volatile.LoadUint32(&o.FILTER_CTRL0.Reg)&^(0x3c0000)|value<<18)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL0_APB_SARADC_FILTER_CHANNEL1() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL0.Reg) & 0x3c0000) >> 18
}
func (o *APB_SARADC_Type) SetFILTER_CTRL0_APB_SARADC_FILTER_CHANNEL0(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL0.Reg, volatile.LoadUint32(&o.FILTER_CTRL0.Reg)&^(0x3c00000)|value<<22)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL0_APB_SARADC_FILTER_CHANNEL0() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL0.Reg) & 0x3c00000) >> 22
}
func (o *APB_SARADC_Type) SetFILTER_CTRL0_APB_SARADC_FILTER_RESET(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL0.Reg, volatile.LoadUint32(&o.FILTER_CTRL0.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL0_APB_SARADC_FILTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL0.Reg) & 0x80000000) >> 31
}

// APB_SARADC.SAR1DATA_STATUS: digital saradc configure register
func (o *APB_SARADC_Type) SetSAR1DATA_STATUS_APB_SARADC1_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR1DATA_STATUS.Reg, volatile.LoadUint32(&o.SAR1DATA_STATUS.Reg)&^(0x1ffff)|value)
}
func (o *APB_SARADC_Type) GetSAR1DATA_STATUS_APB_SARADC1_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR1DATA_STATUS.Reg) & 0x1ffff
}

// APB_SARADC.SAR2DATA_STATUS: digital saradc configure register
func (o *APB_SARADC_Type) SetSAR2DATA_STATUS_APB_SARADC2_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR2DATA_STATUS.Reg, volatile.LoadUint32(&o.SAR2DATA_STATUS.Reg)&^(0x1ffff)|value)
}
func (o *APB_SARADC_Type) GetSAR2DATA_STATUS_APB_SARADC2_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR2DATA_STATUS.Reg) & 0x1ffff
}

// APB_SARADC.THRES0_CTRL: digital saradc configure register
func (o *APB_SARADC_Type) SetTHRES0_CTRL_APB_SARADC_THRES0_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.THRES0_CTRL.Reg, volatile.LoadUint32(&o.THRES0_CTRL.Reg)&^(0xf)|value)
}
func (o *APB_SARADC_Type) GetTHRES0_CTRL_APB_SARADC_THRES0_CHANNEL() uint32 {
	return volatile.LoadUint32(&o.THRES0_CTRL.Reg) & 0xf
}
func (o *APB_SARADC_Type) SetTHRES0_CTRL_APB_SARADC_THRES0_HIGH(value uint32) {
	volatile.StoreUint32(&o.THRES0_CTRL.Reg, volatile.LoadUint32(&o.THRES0_CTRL.Reg)&^(0x3ffe0)|value<<5)
}
func (o *APB_SARADC_Type) GetTHRES0_CTRL_APB_SARADC_THRES0_HIGH() uint32 {
	return (volatile.LoadUint32(&o.THRES0_CTRL.Reg) & 0x3ffe0) >> 5
}
func (o *APB_SARADC_Type) SetTHRES0_CTRL_APB_SARADC_THRES0_LOW(value uint32) {
	volatile.StoreUint32(&o.THRES0_CTRL.Reg, volatile.LoadUint32(&o.THRES0_CTRL.Reg)&^(0x7ffc0000)|value<<18)
}
func (o *APB_SARADC_Type) GetTHRES0_CTRL_APB_SARADC_THRES0_LOW() uint32 {
	return (volatile.LoadUint32(&o.THRES0_CTRL.Reg) & 0x7ffc0000) >> 18
}

// APB_SARADC.THRES1_CTRL: digital saradc configure register
func (o *APB_SARADC_Type) SetTHRES1_CTRL_APB_SARADC_THRES1_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.THRES1_CTRL.Reg, volatile.LoadUint32(&o.THRES1_CTRL.Reg)&^(0xf)|value)
}
func (o *APB_SARADC_Type) GetTHRES1_CTRL_APB_SARADC_THRES1_CHANNEL() uint32 {
	return volatile.LoadUint32(&o.THRES1_CTRL.Reg) & 0xf
}
func (o *APB_SARADC_Type) SetTHRES1_CTRL_APB_SARADC_THRES1_HIGH(value uint32) {
	volatile.StoreUint32(&o.THRES1_CTRL.Reg, volatile.LoadUint32(&o.THRES1_CTRL.Reg)&^(0x3ffe0)|value<<5)
}
func (o *APB_SARADC_Type) GetTHRES1_CTRL_APB_SARADC_THRES1_HIGH() uint32 {
	return (volatile.LoadUint32(&o.THRES1_CTRL.Reg) & 0x3ffe0) >> 5
}
func (o *APB_SARADC_Type) SetTHRES1_CTRL_APB_SARADC_THRES1_LOW(value uint32) {
	volatile.StoreUint32(&o.THRES1_CTRL.Reg, volatile.LoadUint32(&o.THRES1_CTRL.Reg)&^(0x7ffc0000)|value<<18)
}
func (o *APB_SARADC_Type) GetTHRES1_CTRL_APB_SARADC_THRES1_LOW() uint32 {
	return (volatile.LoadUint32(&o.THRES1_CTRL.Reg) & 0x7ffc0000) >> 18
}

// APB_SARADC.THRES_CTRL: digital saradc configure register
func (o *APB_SARADC_Type) SetTHRES_CTRL_APB_SARADC_THRES_ALL_EN(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_APB_SARADC_THRES_ALL_EN() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x8000000) >> 27
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_APB_SARADC_THRES1_EN(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_APB_SARADC_THRES1_EN() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_APB_SARADC_THRES0_EN(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_APB_SARADC_THRES0_EN() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x80000000) >> 31
}

// APB_SARADC.INT_ENA: digital saradc int register
func (o *APB_SARADC_Type) SetINT_ENA_APB_SARADC_TSENS_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000000)|value<<25)
}
func (o *APB_SARADC_Type) GetINT_ENA_APB_SARADC_TSENS_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000000) >> 25
}
func (o *APB_SARADC_Type) SetINT_ENA_APB_SARADC_THRES1_LOW_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000000)|value<<26)
}
func (o *APB_SARADC_Type) GetINT_ENA_APB_SARADC_THRES1_LOW_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000000) >> 26
}
func (o *APB_SARADC_Type) SetINT_ENA_APB_SARADC_THRES0_LOW_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000000)|value<<27)
}
func (o *APB_SARADC_Type) GetINT_ENA_APB_SARADC_THRES0_LOW_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000000) >> 27
}
func (o *APB_SARADC_Type) SetINT_ENA_APB_SARADC_THRES1_HIGH_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000000)|value<<28)
}
func (o *APB_SARADC_Type) GetINT_ENA_APB_SARADC_THRES1_HIGH_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000000) >> 28
}
func (o *APB_SARADC_Type) SetINT_ENA_APB_SARADC_THRES0_HIGH_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetINT_ENA_APB_SARADC_THRES0_HIGH_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetINT_ENA_APB_SARADC2_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetINT_ENA_APB_SARADC2_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetINT_ENA_APB_SARADC1_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetINT_ENA_APB_SARADC1_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80000000) >> 31
}

// APB_SARADC.INT_RAW: digital saradc int register
func (o *APB_SARADC_Type) SetINT_RAW_APB_SARADC_TSENS_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000000)|value<<25)
}
func (o *APB_SARADC_Type) GetINT_RAW_APB_SARADC_TSENS_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000000) >> 25
}
func (o *APB_SARADC_Type) SetINT_RAW_APB_SARADC_THRES1_LOW_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000000)|value<<26)
}
func (o *APB_SARADC_Type) GetINT_RAW_APB_SARADC_THRES1_LOW_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000000) >> 26
}
func (o *APB_SARADC_Type) SetINT_RAW_APB_SARADC_THRES0_LOW_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000000)|value<<27)
}
func (o *APB_SARADC_Type) GetINT_RAW_APB_SARADC_THRES0_LOW_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000000) >> 27
}
func (o *APB_SARADC_Type) SetINT_RAW_APB_SARADC_THRES1_HIGH_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000000)|value<<28)
}
func (o *APB_SARADC_Type) GetINT_RAW_APB_SARADC_THRES1_HIGH_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000000) >> 28
}
func (o *APB_SARADC_Type) SetINT_RAW_APB_SARADC_THRES0_HIGH_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetINT_RAW_APB_SARADC_THRES0_HIGH_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetINT_RAW_APB_SARADC2_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetINT_RAW_APB_SARADC2_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetINT_RAW_APB_SARADC1_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetINT_RAW_APB_SARADC1_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000000) >> 31
}

// APB_SARADC.INT_ST: digital saradc int register
func (o *APB_SARADC_Type) SetINT_ST_APB_SARADC_TSENS_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000000)|value<<25)
}
func (o *APB_SARADC_Type) GetINT_ST_APB_SARADC_TSENS_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000000) >> 25
}
func (o *APB_SARADC_Type) SetINT_ST_APB_SARADC_THRES1_LOW_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000000)|value<<26)
}
func (o *APB_SARADC_Type) GetINT_ST_APB_SARADC_THRES1_LOW_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000000) >> 26
}
func (o *APB_SARADC_Type) SetINT_ST_APB_SARADC_THRES0_LOW_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000000)|value<<27)
}
func (o *APB_SARADC_Type) GetINT_ST_APB_SARADC_THRES0_LOW_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000000) >> 27
}
func (o *APB_SARADC_Type) SetINT_ST_APB_SARADC_THRES1_HIGH_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000000)|value<<28)
}
func (o *APB_SARADC_Type) GetINT_ST_APB_SARADC_THRES1_HIGH_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000000) >> 28
}
func (o *APB_SARADC_Type) SetINT_ST_APB_SARADC_THRES0_HIGH_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetINT_ST_APB_SARADC_THRES0_HIGH_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetINT_ST_APB_SARADC2_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetINT_ST_APB_SARADC2_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetINT_ST_APB_SARADC1_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetINT_ST_APB_SARADC1_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80000000) >> 31
}

// APB_SARADC.INT_CLR: digital saradc int register
func (o *APB_SARADC_Type) SetINT_CLR_APB_SARADC_TSENS_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000000)|value<<25)
}
func (o *APB_SARADC_Type) GetINT_CLR_APB_SARADC_TSENS_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000000) >> 25
}
func (o *APB_SARADC_Type) SetINT_CLR_APB_SARADC_THRES1_LOW_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000000)|value<<26)
}
func (o *APB_SARADC_Type) GetINT_CLR_APB_SARADC_THRES1_LOW_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000000) >> 26
}
func (o *APB_SARADC_Type) SetINT_CLR_APB_SARADC_THRES0_LOW_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000000)|value<<27)
}
func (o *APB_SARADC_Type) GetINT_CLR_APB_SARADC_THRES0_LOW_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000000) >> 27
}
func (o *APB_SARADC_Type) SetINT_CLR_APB_SARADC_THRES1_HIGH_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *APB_SARADC_Type) GetINT_CLR_APB_SARADC_THRES1_HIGH_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000000) >> 28
}
func (o *APB_SARADC_Type) SetINT_CLR_APB_SARADC_THRES0_HIGH_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetINT_CLR_APB_SARADC_THRES0_HIGH_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetINT_CLR_APB_SARADC2_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetINT_CLR_APB_SARADC2_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetINT_CLR_APB_SARADC1_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetINT_CLR_APB_SARADC1_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80000000) >> 31
}

// APB_SARADC.DMA_CONF: digital saradc configure register
func (o *APB_SARADC_Type) SetDMA_CONF_APB_ADC_EOF_NUM(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0xffff)|value)
}
func (o *APB_SARADC_Type) GetDMA_CONF_APB_ADC_EOF_NUM() uint32 {
	return volatile.LoadUint32(&o.DMA_CONF.Reg) & 0xffff
}
func (o *APB_SARADC_Type) SetDMA_CONF_APB_ADC_RESET_FSM(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetDMA_CONF_APB_ADC_RESET_FSM() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetDMA_CONF_APB_ADC_TRANS(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetDMA_CONF_APB_ADC_TRANS() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x80000000) >> 31
}

// APB_SARADC.CLKM_CONF: digital saradc configure register
func (o *APB_SARADC_Type) SetCLKM_CONF_CLKM_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0xff)|value)
}
func (o *APB_SARADC_Type) GetCLKM_CONF_CLKM_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0xff
}
func (o *APB_SARADC_Type) SetCLKM_CONF_CLKM_DIV_B(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0x3f00)|value<<8)
}
func (o *APB_SARADC_Type) GetCLKM_CONF_CLKM_DIV_B() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0x3f00) >> 8
}
func (o *APB_SARADC_Type) SetCLKM_CONF_CLKM_DIV_A(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0xfc000)|value<<14)
}
func (o *APB_SARADC_Type) GetCLKM_CONF_CLKM_DIV_A() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0xfc000) >> 14
}
func (o *APB_SARADC_Type) SetCLKM_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *APB_SARADC_Type) GetCLKM_CONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0x100000) >> 20
}
func (o *APB_SARADC_Type) SetCLKM_CONF_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0x600000)|value<<21)
}
func (o *APB_SARADC_Type) GetCLKM_CONF_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0x600000) >> 21
}

// APB_SARADC.APB_TSENS_CTRL: digital tsens configure register
func (o *APB_SARADC_Type) SetAPB_TSENS_CTRL_TSENS_OUT(value uint32) {
	volatile.StoreUint32(&o.APB_TSENS_CTRL.Reg, volatile.LoadUint32(&o.APB_TSENS_CTRL.Reg)&^(0xff)|value)
}
func (o *APB_SARADC_Type) GetAPB_TSENS_CTRL_TSENS_OUT() uint32 {
	return volatile.LoadUint32(&o.APB_TSENS_CTRL.Reg) & 0xff
}
func (o *APB_SARADC_Type) SetAPB_TSENS_CTRL_TSENS_IN_INV(value uint32) {
	volatile.StoreUint32(&o.APB_TSENS_CTRL.Reg, volatile.LoadUint32(&o.APB_TSENS_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *APB_SARADC_Type) GetAPB_TSENS_CTRL_TSENS_IN_INV() uint32 {
	return (volatile.LoadUint32(&o.APB_TSENS_CTRL.Reg) & 0x2000) >> 13
}
func (o *APB_SARADC_Type) SetAPB_TSENS_CTRL_TSENS_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.APB_TSENS_CTRL.Reg, volatile.LoadUint32(&o.APB_TSENS_CTRL.Reg)&^(0x3fc000)|value<<14)
}
func (o *APB_SARADC_Type) GetAPB_TSENS_CTRL_TSENS_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.APB_TSENS_CTRL.Reg) & 0x3fc000) >> 14
}
func (o *APB_SARADC_Type) SetAPB_TSENS_CTRL_TSENS_PU(value uint32) {
	volatile.StoreUint32(&o.APB_TSENS_CTRL.Reg, volatile.LoadUint32(&o.APB_TSENS_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *APB_SARADC_Type) GetAPB_TSENS_CTRL_TSENS_PU() uint32 {
	return (volatile.LoadUint32(&o.APB_TSENS_CTRL.Reg) & 0x400000) >> 22
}

// APB_SARADC.TSENS_CTRL2: digital tsens configure register
func (o *APB_SARADC_Type) SetTSENS_CTRL2_TSENS_XPD_WAIT(value uint32) {
	volatile.StoreUint32(&o.TSENS_CTRL2.Reg, volatile.LoadUint32(&o.TSENS_CTRL2.Reg)&^(0xfff)|value)
}
func (o *APB_SARADC_Type) GetTSENS_CTRL2_TSENS_XPD_WAIT() uint32 {
	return volatile.LoadUint32(&o.TSENS_CTRL2.Reg) & 0xfff
}
func (o *APB_SARADC_Type) SetTSENS_CTRL2_TSENS_XPD_FORCE(value uint32) {
	volatile.StoreUint32(&o.TSENS_CTRL2.Reg, volatile.LoadUint32(&o.TSENS_CTRL2.Reg)&^(0x3000)|value<<12)
}
func (o *APB_SARADC_Type) GetTSENS_CTRL2_TSENS_XPD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.TSENS_CTRL2.Reg) & 0x3000) >> 12
}
func (o *APB_SARADC_Type) SetTSENS_CTRL2_TSENS_CLK_INV(value uint32) {
	volatile.StoreUint32(&o.TSENS_CTRL2.Reg, volatile.LoadUint32(&o.TSENS_CTRL2.Reg)&^(0x4000)|value<<14)
}
func (o *APB_SARADC_Type) GetTSENS_CTRL2_TSENS_CLK_INV() uint32 {
	return (volatile.LoadUint32(&o.TSENS_CTRL2.Reg) & 0x4000) >> 14
}
func (o *APB_SARADC_Type) SetTSENS_CTRL2_TSENS_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.TSENS_CTRL2.Reg, volatile.LoadUint32(&o.TSENS_CTRL2.Reg)&^(0x8000)|value<<15)
}
func (o *APB_SARADC_Type) GetTSENS_CTRL2_TSENS_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TSENS_CTRL2.Reg) & 0x8000) >> 15
}

// APB_SARADC.CALI: digital saradc configure register
func (o *APB_SARADC_Type) SetCALI_APB_SARADC_CALI_CFG(value uint32) {
	volatile.StoreUint32(&o.CALI.Reg, volatile.LoadUint32(&o.CALI.Reg)&^(0x1ffff)|value)
}
func (o *APB_SARADC_Type) GetCALI_APB_SARADC_CALI_CFG() uint32 {
	return volatile.LoadUint32(&o.CALI.Reg) & 0x1ffff
}

// APB_SARADC.APB_TSENS_WAKE: digital tsens configure register
func (o *APB_SARADC_Type) SetAPB_TSENS_WAKE_WAKEUP_TH_LOW(value uint32) {
	volatile.StoreUint32(&o.APB_TSENS_WAKE.Reg, volatile.LoadUint32(&o.APB_TSENS_WAKE.Reg)&^(0xff)|value)
}
func (o *APB_SARADC_Type) GetAPB_TSENS_WAKE_WAKEUP_TH_LOW() uint32 {
	return volatile.LoadUint32(&o.APB_TSENS_WAKE.Reg) & 0xff
}
func (o *APB_SARADC_Type) SetAPB_TSENS_WAKE_WAKEUP_TH_HIGH(value uint32) {
	volatile.StoreUint32(&o.APB_TSENS_WAKE.Reg, volatile.LoadUint32(&o.APB_TSENS_WAKE.Reg)&^(0xff00)|value<<8)
}
func (o *APB_SARADC_Type) GetAPB_TSENS_WAKE_WAKEUP_TH_HIGH() uint32 {
	return (volatile.LoadUint32(&o.APB_TSENS_WAKE.Reg) & 0xff00) >> 8
}
func (o *APB_SARADC_Type) SetAPB_TSENS_WAKE_WAKEUP_OVER_UPPER_TH(value uint32) {
	volatile.StoreUint32(&o.APB_TSENS_WAKE.Reg, volatile.LoadUint32(&o.APB_TSENS_WAKE.Reg)&^(0x10000)|value<<16)
}
func (o *APB_SARADC_Type) GetAPB_TSENS_WAKE_WAKEUP_OVER_UPPER_TH() uint32 {
	return (volatile.LoadUint32(&o.APB_TSENS_WAKE.Reg) & 0x10000) >> 16
}
func (o *APB_SARADC_Type) SetAPB_TSENS_WAKE_WAKEUP_MODE(value uint32) {
	volatile.StoreUint32(&o.APB_TSENS_WAKE.Reg, volatile.LoadUint32(&o.APB_TSENS_WAKE.Reg)&^(0x20000)|value<<17)
}
func (o *APB_SARADC_Type) GetAPB_TSENS_WAKE_WAKEUP_MODE() uint32 {
	return (volatile.LoadUint32(&o.APB_TSENS_WAKE.Reg) & 0x20000) >> 17
}
func (o *APB_SARADC_Type) SetAPB_TSENS_WAKE_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.APB_TSENS_WAKE.Reg, volatile.LoadUint32(&o.APB_TSENS_WAKE.Reg)&^(0x40000)|value<<18)
}
func (o *APB_SARADC_Type) GetAPB_TSENS_WAKE_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.APB_TSENS_WAKE.Reg) & 0x40000) >> 18
}

// APB_SARADC.APB_TSENS_SAMPLE: digital tsens configure register
func (o *APB_SARADC_Type) SetAPB_TSENS_SAMPLE_TSENS_SAMPLE_RATE(value uint32) {
	volatile.StoreUint32(&o.APB_TSENS_SAMPLE.Reg, volatile.LoadUint32(&o.APB_TSENS_SAMPLE.Reg)&^(0xffff)|value)
}
func (o *APB_SARADC_Type) GetAPB_TSENS_SAMPLE_TSENS_SAMPLE_RATE() uint32 {
	return volatile.LoadUint32(&o.APB_TSENS_SAMPLE.Reg) & 0xffff
}
func (o *APB_SARADC_Type) SetAPB_TSENS_SAMPLE_TSENS_SAMPLE_EN(value uint32) {
	volatile.StoreUint32(&o.APB_TSENS_SAMPLE.Reg, volatile.LoadUint32(&o.APB_TSENS_SAMPLE.Reg)&^(0x10000)|value<<16)
}
func (o *APB_SARADC_Type) GetAPB_TSENS_SAMPLE_TSENS_SAMPLE_EN() uint32 {
	return (volatile.LoadUint32(&o.APB_TSENS_SAMPLE.Reg) & 0x10000) >> 16
}

// APB_SARADC.CTRL_DATE: version
func (o *APB_SARADC_Type) SetCTRL_DATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_DATE.Reg, value)
}
func (o *APB_SARADC_Type) GetCTRL_DATE() uint32 {
	return volatile.LoadUint32(&o.CTRL_DATE.Reg)
}

// Debug Assist
type ASSIST_DEBUG_Type struct {
	CORE_0_MONTR_ENA                       volatile.Register32 // 0x0
	CORE_0_INTR_RAW                        volatile.Register32 // 0x4
	CORE_0_INTR_ENA                        volatile.Register32 // 0x8
	CORE_0_INTR_CLR                        volatile.Register32 // 0xC
	CORE_0_AREA_DRAM0_0_MIN                volatile.Register32 // 0x10
	CORE_0_AREA_DRAM0_0_MAX                volatile.Register32 // 0x14
	CORE_0_AREA_DRAM0_1_MIN                volatile.Register32 // 0x18
	CORE_0_AREA_DRAM0_1_MAX                volatile.Register32 // 0x1C
	CORE_0_AREA_PIF_0_MIN                  volatile.Register32 // 0x20
	CORE_0_AREA_PIF_0_MAX                  volatile.Register32 // 0x24
	CORE_0_AREA_PIF_1_MIN                  volatile.Register32 // 0x28
	CORE_0_AREA_PIF_1_MAX                  volatile.Register32 // 0x2C
	CORE_0_AREA_PC                         volatile.Register32 // 0x30
	CORE_0_AREA_SP                         volatile.Register32 // 0x34
	CORE_0_SP_MIN                          volatile.Register32 // 0x38
	CORE_0_SP_MAX                          volatile.Register32 // 0x3C
	CORE_0_SP_PC                           volatile.Register32 // 0x40
	CORE_0_RCD_EN                          volatile.Register32 // 0x44
	CORE_0_RCD_PDEBUGPC                    volatile.Register32 // 0x48
	CORE_0_RCD_PDEBUGSP                    volatile.Register32 // 0x4C
	CORE_0_IRAM0_EXCEPTION_MONITOR_0       volatile.Register32 // 0x50
	CORE_0_IRAM0_EXCEPTION_MONITOR_1       volatile.Register32 // 0x54
	CORE_0_DRAM0_EXCEPTION_MONITOR_0       volatile.Register32 // 0x58
	CORE_0_DRAM0_EXCEPTION_MONITOR_1       volatile.Register32 // 0x5C
	CORE_0_DRAM0_EXCEPTION_MONITOR_2       volatile.Register32 // 0x60
	CORE_0_DRAM0_EXCEPTION_MONITOR_3       volatile.Register32 // 0x64
	CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0 volatile.Register32 // 0x68
	CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1 volatile.Register32 // 0x6C
	C0RE_0_LASTPC_BEFORE_EXCEPTION         volatile.Register32 // 0x70
	C0RE_0_DEBUG_MODE                      volatile.Register32 // 0x74
	CLOCK_GATE                             volatile.Register32 // 0x78
	_                                      [896]byte
	DATE                                   volatile.Register32 // 0x3FC
}

// ASSIST_DEBUG.CORE_0_MONTR_ENA: core0 monitor enable configuration register
func (o *ASSIST_DEBUG_Type) SetCORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_0_RD_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_MONTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg)&^(0x1)|value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_0_RD_ENA() uint32 {
	return volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg) & 0x1
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_0_WR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_MONTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg)&^(0x2)|value<<1)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_0_WR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg) & 0x2) >> 1
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_1_RD_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_MONTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg)&^(0x4)|value<<2)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_1_RD_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg) & 0x4) >> 2
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_1_WR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_MONTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg)&^(0x8)|value<<3)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_1_WR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg) & 0x8) >> 3
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_MONTR_ENA_CORE_0_AREA_PIF_0_RD_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_MONTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg)&^(0x10)|value<<4)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_MONTR_ENA_CORE_0_AREA_PIF_0_RD_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg) & 0x10) >> 4
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_MONTR_ENA_CORE_0_AREA_PIF_0_WR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_MONTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg)&^(0x20)|value<<5)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_MONTR_ENA_CORE_0_AREA_PIF_0_WR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg) & 0x20) >> 5
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_MONTR_ENA_CORE_0_AREA_PIF_1_RD_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_MONTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg)&^(0x40)|value<<6)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_MONTR_ENA_CORE_0_AREA_PIF_1_RD_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg) & 0x40) >> 6
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_MONTR_ENA_CORE_0_AREA_PIF_1_WR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_MONTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg)&^(0x80)|value<<7)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_MONTR_ENA_CORE_0_AREA_PIF_1_WR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg) & 0x80) >> 7
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_MONTR_ENA_CORE_0_SP_SPILL_MIN_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_MONTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg)&^(0x100)|value<<8)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_MONTR_ENA_CORE_0_SP_SPILL_MIN_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg) & 0x100) >> 8
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_MONTR_ENA_CORE_0_SP_SPILL_MAX_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_MONTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg)&^(0x200)|value<<9)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_MONTR_ENA_CORE_0_SP_SPILL_MAX_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg) & 0x200) >> 9
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_MONTR_ENA_CORE_0_IRAM0_EXCEPTION_MONITOR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_MONTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg)&^(0x400)|value<<10)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_MONTR_ENA_CORE_0_IRAM0_EXCEPTION_MONITOR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg) & 0x400) >> 10
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_MONTR_ENA_CORE_0_DRAM0_EXCEPTION_MONITOR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_MONTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg)&^(0x800)|value<<11)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_MONTR_ENA_CORE_0_DRAM0_EXCEPTION_MONITOR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_MONTR_ENA.Reg) & 0x800) >> 11
}

// ASSIST_DEBUG.CORE_0_INTR_RAW: core0 monitor interrupt status register
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_RAW_CORE_0_AREA_DRAM0_0_RD_RAW(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_RAW.Reg, volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg)&^(0x1)|value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_RAW_CORE_0_AREA_DRAM0_0_RD_RAW() uint32 {
	return volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg) & 0x1
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_RAW_CORE_0_AREA_DRAM0_0_WR_RAW(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_RAW.Reg, volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg)&^(0x2)|value<<1)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_RAW_CORE_0_AREA_DRAM0_0_WR_RAW() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg) & 0x2) >> 1
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_RAW_CORE_0_AREA_DRAM0_1_RD_RAW(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_RAW.Reg, volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg)&^(0x4)|value<<2)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_RAW_CORE_0_AREA_DRAM0_1_RD_RAW() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg) & 0x4) >> 2
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_RAW_CORE_0_AREA_DRAM0_1_WR_RAW(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_RAW.Reg, volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg)&^(0x8)|value<<3)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_RAW_CORE_0_AREA_DRAM0_1_WR_RAW() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg) & 0x8) >> 3
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_RAW_CORE_0_AREA_PIF_0_RD_RAW(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_RAW.Reg, volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg)&^(0x10)|value<<4)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_RAW_CORE_0_AREA_PIF_0_RD_RAW() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg) & 0x10) >> 4
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_RAW_CORE_0_AREA_PIF_0_WR_RAW(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_RAW.Reg, volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg)&^(0x20)|value<<5)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_RAW_CORE_0_AREA_PIF_0_WR_RAW() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg) & 0x20) >> 5
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_RAW_CORE_0_AREA_PIF_1_RD_RAW(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_RAW.Reg, volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg)&^(0x40)|value<<6)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_RAW_CORE_0_AREA_PIF_1_RD_RAW() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg) & 0x40) >> 6
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_RAW_CORE_0_AREA_PIF_1_WR_RAW(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_RAW.Reg, volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg)&^(0x80)|value<<7)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_RAW_CORE_0_AREA_PIF_1_WR_RAW() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg) & 0x80) >> 7
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_RAW_CORE_0_SP_SPILL_MIN_RAW(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_RAW.Reg, volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg)&^(0x100)|value<<8)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_RAW_CORE_0_SP_SPILL_MIN_RAW() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg) & 0x100) >> 8
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_RAW_CORE_0_SP_SPILL_MAX_RAW(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_RAW.Reg, volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg)&^(0x200)|value<<9)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_RAW_CORE_0_SP_SPILL_MAX_RAW() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg) & 0x200) >> 9
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_RAW_CORE_0_IRAM0_EXCEPTION_MONITOR_RAW(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_RAW.Reg, volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg)&^(0x400)|value<<10)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_RAW_CORE_0_IRAM0_EXCEPTION_MONITOR_RAW() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg) & 0x400) >> 10
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_RAW_CORE_0_DRAM0_EXCEPTION_MONITOR_RAW(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_RAW.Reg, volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg)&^(0x800)|value<<11)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_RAW_CORE_0_DRAM0_EXCEPTION_MONITOR_RAW() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_RAW.Reg) & 0x800) >> 11
}

// ASSIST_DEBUG.CORE_0_INTR_ENA: core0 monitor interrupt enable register
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_ENA_CORE_0_AREA_DRAM0_0_RD_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg)&^(0x1)|value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_ENA_CORE_0_AREA_DRAM0_0_RD_INTR_ENA() uint32 {
	return volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg) & 0x1
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_ENA_CORE_0_AREA_DRAM0_0_WR_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg)&^(0x2)|value<<1)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_ENA_CORE_0_AREA_DRAM0_0_WR_INTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg) & 0x2) >> 1
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_ENA_CORE_0_AREA_DRAM0_1_RD_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg)&^(0x4)|value<<2)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_ENA_CORE_0_AREA_DRAM0_1_RD_INTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg) & 0x4) >> 2
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_ENA_CORE_0_AREA_DRAM0_1_WR_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg)&^(0x8)|value<<3)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_ENA_CORE_0_AREA_DRAM0_1_WR_INTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg) & 0x8) >> 3
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_ENA_CORE_0_AREA_PIF_0_RD_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg)&^(0x10)|value<<4)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_ENA_CORE_0_AREA_PIF_0_RD_INTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg) & 0x10) >> 4
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_ENA_CORE_0_AREA_PIF_0_WR_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg)&^(0x20)|value<<5)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_ENA_CORE_0_AREA_PIF_0_WR_INTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg) & 0x20) >> 5
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_ENA_CORE_0_AREA_PIF_1_RD_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg)&^(0x40)|value<<6)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_ENA_CORE_0_AREA_PIF_1_RD_INTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg) & 0x40) >> 6
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_ENA_CORE_0_AREA_PIF_1_WR_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg)&^(0x80)|value<<7)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_ENA_CORE_0_AREA_PIF_1_WR_INTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg) & 0x80) >> 7
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_ENA_CORE_0_SP_SPILL_MIN_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg)&^(0x100)|value<<8)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_ENA_CORE_0_SP_SPILL_MIN_INTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg) & 0x100) >> 8
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_ENA_CORE_0_SP_SPILL_MAX_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg)&^(0x200)|value<<9)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_ENA_CORE_0_SP_SPILL_MAX_INTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg) & 0x200) >> 9
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_ENA_CORE_0_IRAM0_EXCEPTION_MONITOR_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg)&^(0x400)|value<<10)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_ENA_CORE_0_IRAM0_EXCEPTION_MONITOR_INTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg) & 0x400) >> 10
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_ENA_CORE_0_DRAM0_EXCEPTION_MONITOR_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_ENA.Reg, volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg)&^(0x800)|value<<11)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_ENA_CORE_0_DRAM0_EXCEPTION_MONITOR_INTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_ENA.Reg) & 0x800) >> 11
}

// ASSIST_DEBUG.CORE_0_INTR_CLR: core0 monitor interrupt clr register
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_CLR_CORE_0_AREA_DRAM0_0_RD_CLR(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_CLR.Reg, volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg)&^(0x1)|value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_CLR_CORE_0_AREA_DRAM0_0_RD_CLR() uint32 {
	return volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg) & 0x1
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_CLR_CORE_0_AREA_DRAM0_0_WR_CLR(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_CLR.Reg, volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg)&^(0x2)|value<<1)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_CLR_CORE_0_AREA_DRAM0_0_WR_CLR() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg) & 0x2) >> 1
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_CLR_CORE_0_AREA_DRAM0_1_RD_CLR(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_CLR.Reg, volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg)&^(0x4)|value<<2)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_CLR_CORE_0_AREA_DRAM0_1_RD_CLR() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg) & 0x4) >> 2
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_CLR_CORE_0_AREA_DRAM0_1_WR_CLR(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_CLR.Reg, volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg)&^(0x8)|value<<3)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_CLR_CORE_0_AREA_DRAM0_1_WR_CLR() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg) & 0x8) >> 3
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_CLR_CORE_0_AREA_PIF_0_RD_CLR(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_CLR.Reg, volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg)&^(0x10)|value<<4)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_CLR_CORE_0_AREA_PIF_0_RD_CLR() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg) & 0x10) >> 4
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_CLR_CORE_0_AREA_PIF_0_WR_CLR(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_CLR.Reg, volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg)&^(0x20)|value<<5)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_CLR_CORE_0_AREA_PIF_0_WR_CLR() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg) & 0x20) >> 5
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_CLR_CORE_0_AREA_PIF_1_RD_CLR(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_CLR.Reg, volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg)&^(0x40)|value<<6)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_CLR_CORE_0_AREA_PIF_1_RD_CLR() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg) & 0x40) >> 6
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_CLR_CORE_0_AREA_PIF_1_WR_CLR(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_CLR.Reg, volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg)&^(0x80)|value<<7)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_CLR_CORE_0_AREA_PIF_1_WR_CLR() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg) & 0x80) >> 7
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_CLR_CORE_0_SP_SPILL_MIN_CLR(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_CLR.Reg, volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg)&^(0x100)|value<<8)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_CLR_CORE_0_SP_SPILL_MIN_CLR() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg) & 0x100) >> 8
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_CLR_CORE_0_SP_SPILL_MAX_CLR(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_CLR.Reg, volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg)&^(0x200)|value<<9)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_CLR_CORE_0_SP_SPILL_MAX_CLR() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg) & 0x200) >> 9
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_CLR_CORE_0_IRAM0_EXCEPTION_MONITOR_CLR(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_CLR.Reg, volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg)&^(0x400)|value<<10)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_CLR_CORE_0_IRAM0_EXCEPTION_MONITOR_CLR() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg) & 0x400) >> 10
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_INTR_CLR_CORE_0_DRAM0_EXCEPTION_MONITOR_CLR(value uint32) {
	volatile.StoreUint32(&o.CORE_0_INTR_CLR.Reg, volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg)&^(0x800)|value<<11)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_INTR_CLR_CORE_0_DRAM0_EXCEPTION_MONITOR_CLR() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_INTR_CLR.Reg) & 0x800) >> 11
}

// ASSIST_DEBUG.CORE_0_AREA_DRAM0_0_MIN: core0 dram0 region0 addr configuration register
func (o *ASSIST_DEBUG_Type) SetCORE_0_AREA_DRAM0_0_MIN(value uint32) {
	volatile.StoreUint32(&o.CORE_0_AREA_DRAM0_0_MIN.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_AREA_DRAM0_0_MIN() uint32 {
	return volatile.LoadUint32(&o.CORE_0_AREA_DRAM0_0_MIN.Reg)
}

// ASSIST_DEBUG.CORE_0_AREA_DRAM0_0_MAX: core0 dram0 region0 addr configuration register
func (o *ASSIST_DEBUG_Type) SetCORE_0_AREA_DRAM0_0_MAX(value uint32) {
	volatile.StoreUint32(&o.CORE_0_AREA_DRAM0_0_MAX.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_AREA_DRAM0_0_MAX() uint32 {
	return volatile.LoadUint32(&o.CORE_0_AREA_DRAM0_0_MAX.Reg)
}

// ASSIST_DEBUG.CORE_0_AREA_DRAM0_1_MIN: core0 dram0 region1 addr configuration register
func (o *ASSIST_DEBUG_Type) SetCORE_0_AREA_DRAM0_1_MIN(value uint32) {
	volatile.StoreUint32(&o.CORE_0_AREA_DRAM0_1_MIN.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_AREA_DRAM0_1_MIN() uint32 {
	return volatile.LoadUint32(&o.CORE_0_AREA_DRAM0_1_MIN.Reg)
}

// ASSIST_DEBUG.CORE_0_AREA_DRAM0_1_MAX: core0 dram0 region1 addr configuration register
func (o *ASSIST_DEBUG_Type) SetCORE_0_AREA_DRAM0_1_MAX(value uint32) {
	volatile.StoreUint32(&o.CORE_0_AREA_DRAM0_1_MAX.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_AREA_DRAM0_1_MAX() uint32 {
	return volatile.LoadUint32(&o.CORE_0_AREA_DRAM0_1_MAX.Reg)
}

// ASSIST_DEBUG.CORE_0_AREA_PIF_0_MIN: core0 PIF region0 addr configuration register
func (o *ASSIST_DEBUG_Type) SetCORE_0_AREA_PIF_0_MIN(value uint32) {
	volatile.StoreUint32(&o.CORE_0_AREA_PIF_0_MIN.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_AREA_PIF_0_MIN() uint32 {
	return volatile.LoadUint32(&o.CORE_0_AREA_PIF_0_MIN.Reg)
}

// ASSIST_DEBUG.CORE_0_AREA_PIF_0_MAX: core0 PIF region0 addr configuration register
func (o *ASSIST_DEBUG_Type) SetCORE_0_AREA_PIF_0_MAX(value uint32) {
	volatile.StoreUint32(&o.CORE_0_AREA_PIF_0_MAX.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_AREA_PIF_0_MAX() uint32 {
	return volatile.LoadUint32(&o.CORE_0_AREA_PIF_0_MAX.Reg)
}

// ASSIST_DEBUG.CORE_0_AREA_PIF_1_MIN: core0 PIF region1 addr configuration register
func (o *ASSIST_DEBUG_Type) SetCORE_0_AREA_PIF_1_MIN(value uint32) {
	volatile.StoreUint32(&o.CORE_0_AREA_PIF_1_MIN.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_AREA_PIF_1_MIN() uint32 {
	return volatile.LoadUint32(&o.CORE_0_AREA_PIF_1_MIN.Reg)
}

// ASSIST_DEBUG.CORE_0_AREA_PIF_1_MAX: core0 PIF region1 addr configuration register
func (o *ASSIST_DEBUG_Type) SetCORE_0_AREA_PIF_1_MAX(value uint32) {
	volatile.StoreUint32(&o.CORE_0_AREA_PIF_1_MAX.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_AREA_PIF_1_MAX() uint32 {
	return volatile.LoadUint32(&o.CORE_0_AREA_PIF_1_MAX.Reg)
}

// ASSIST_DEBUG.CORE_0_AREA_PC: core0 area pc status register
func (o *ASSIST_DEBUG_Type) SetCORE_0_AREA_PC(value uint32) {
	volatile.StoreUint32(&o.CORE_0_AREA_PC.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_AREA_PC() uint32 {
	return volatile.LoadUint32(&o.CORE_0_AREA_PC.Reg)
}

// ASSIST_DEBUG.CORE_0_AREA_SP: core0 area sp status register
func (o *ASSIST_DEBUG_Type) SetCORE_0_AREA_SP(value uint32) {
	volatile.StoreUint32(&o.CORE_0_AREA_SP.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_AREA_SP() uint32 {
	return volatile.LoadUint32(&o.CORE_0_AREA_SP.Reg)
}

// ASSIST_DEBUG.CORE_0_SP_MIN: stack min value
func (o *ASSIST_DEBUG_Type) SetCORE_0_SP_MIN(value uint32) {
	volatile.StoreUint32(&o.CORE_0_SP_MIN.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_SP_MIN() uint32 {
	return volatile.LoadUint32(&o.CORE_0_SP_MIN.Reg)
}

// ASSIST_DEBUG.CORE_0_SP_MAX: stack max value
func (o *ASSIST_DEBUG_Type) SetCORE_0_SP_MAX(value uint32) {
	volatile.StoreUint32(&o.CORE_0_SP_MAX.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_SP_MAX() uint32 {
	return volatile.LoadUint32(&o.CORE_0_SP_MAX.Reg)
}

// ASSIST_DEBUG.CORE_0_SP_PC: stack monitor pc status register
func (o *ASSIST_DEBUG_Type) SetCORE_0_SP_PC(value uint32) {
	volatile.StoreUint32(&o.CORE_0_SP_PC.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_SP_PC() uint32 {
	return volatile.LoadUint32(&o.CORE_0_SP_PC.Reg)
}

// ASSIST_DEBUG.CORE_0_RCD_EN: record enable configuration register
func (o *ASSIST_DEBUG_Type) SetCORE_0_RCD_EN_CORE_0_RCD_RECORDEN(value uint32) {
	volatile.StoreUint32(&o.CORE_0_RCD_EN.Reg, volatile.LoadUint32(&o.CORE_0_RCD_EN.Reg)&^(0x1)|value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_RCD_EN_CORE_0_RCD_RECORDEN() uint32 {
	return volatile.LoadUint32(&o.CORE_0_RCD_EN.Reg) & 0x1
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_RCD_EN_CORE_0_RCD_PDEBUGEN(value uint32) {
	volatile.StoreUint32(&o.CORE_0_RCD_EN.Reg, volatile.LoadUint32(&o.CORE_0_RCD_EN.Reg)&^(0x2)|value<<1)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_RCD_EN_CORE_0_RCD_PDEBUGEN() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_RCD_EN.Reg) & 0x2) >> 1
}

// ASSIST_DEBUG.CORE_0_RCD_PDEBUGPC: record status regsiter
func (o *ASSIST_DEBUG_Type) SetCORE_0_RCD_PDEBUGPC(value uint32) {
	volatile.StoreUint32(&o.CORE_0_RCD_PDEBUGPC.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_RCD_PDEBUGPC() uint32 {
	return volatile.LoadUint32(&o.CORE_0_RCD_PDEBUGPC.Reg)
}

// ASSIST_DEBUG.CORE_0_RCD_PDEBUGSP: record status regsiter
func (o *ASSIST_DEBUG_Type) SetCORE_0_RCD_PDEBUGSP(value uint32) {
	volatile.StoreUint32(&o.CORE_0_RCD_PDEBUGSP.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_RCD_PDEBUGSP() uint32 {
	return volatile.LoadUint32(&o.CORE_0_RCD_PDEBUGSP.Reg)
}

// ASSIST_DEBUG.CORE_0_IRAM0_EXCEPTION_MONITOR_0: exception monitor status register0
func (o *ASSIST_DEBUG_Type) SetCORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_ADDR_0(value uint32) {
	volatile.StoreUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_0.Reg, volatile.LoadUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_0.Reg)&^(0xffffff)|value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_ADDR_0() uint32 {
	return volatile.LoadUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_0.Reg) & 0xffffff
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_WR_0(value uint32) {
	volatile.StoreUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_0.Reg, volatile.LoadUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_0.Reg)&^(0x1000000)|value<<24)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_WR_0() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_0.Reg) & 0x1000000) >> 24
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_LOADSTORE_0(value uint32) {
	volatile.StoreUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_0.Reg, volatile.LoadUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_0.Reg)&^(0x2000000)|value<<25)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_LOADSTORE_0() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_0.Reg) & 0x2000000) >> 25
}

// ASSIST_DEBUG.CORE_0_IRAM0_EXCEPTION_MONITOR_1: exception monitor status register1
func (o *ASSIST_DEBUG_Type) SetCORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_ADDR_1(value uint32) {
	volatile.StoreUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_1.Reg, volatile.LoadUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_1.Reg)&^(0xffffff)|value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_ADDR_1() uint32 {
	return volatile.LoadUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_1.Reg) & 0xffffff
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_WR_1(value uint32) {
	volatile.StoreUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_1.Reg, volatile.LoadUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_1.Reg)&^(0x1000000)|value<<24)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_WR_1() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_1.Reg) & 0x1000000) >> 24
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_LOADSTORE_1(value uint32) {
	volatile.StoreUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_1.Reg, volatile.LoadUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_1.Reg)&^(0x2000000)|value<<25)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_LOADSTORE_1() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_IRAM0_EXCEPTION_MONITOR_1.Reg) & 0x2000000) >> 25
}

// ASSIST_DEBUG.CORE_0_DRAM0_EXCEPTION_MONITOR_0: exception monitor status register2
func (o *ASSIST_DEBUG_Type) SetCORE_0_DRAM0_EXCEPTION_MONITOR_0_CORE_0_DRAM0_RECORDING_ADDR_0(value uint32) {
	volatile.StoreUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_0.Reg, volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_0.Reg)&^(0xffffff)|value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_DRAM0_EXCEPTION_MONITOR_0_CORE_0_DRAM0_RECORDING_ADDR_0() uint32 {
	return volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_0.Reg) & 0xffffff
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_DRAM0_EXCEPTION_MONITOR_0_CORE_0_DRAM0_RECORDING_WR_0(value uint32) {
	volatile.StoreUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_0.Reg, volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_0.Reg)&^(0x1000000)|value<<24)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_DRAM0_EXCEPTION_MONITOR_0_CORE_0_DRAM0_RECORDING_WR_0() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_0.Reg) & 0x1000000) >> 24
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_DRAM0_EXCEPTION_MONITOR_0_CORE_0_DRAM0_RECORDING_BYTEEN_0(value uint32) {
	volatile.StoreUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_0.Reg, volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_0.Reg)&^(0x1e000000)|value<<25)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_DRAM0_EXCEPTION_MONITOR_0_CORE_0_DRAM0_RECORDING_BYTEEN_0() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_0.Reg) & 0x1e000000) >> 25
}

// ASSIST_DEBUG.CORE_0_DRAM0_EXCEPTION_MONITOR_1: exception monitor status register3
func (o *ASSIST_DEBUG_Type) SetCORE_0_DRAM0_EXCEPTION_MONITOR_1(value uint32) {
	volatile.StoreUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_1.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_DRAM0_EXCEPTION_MONITOR_1() uint32 {
	return volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_1.Reg)
}

// ASSIST_DEBUG.CORE_0_DRAM0_EXCEPTION_MONITOR_2: exception monitor status register4
func (o *ASSIST_DEBUG_Type) SetCORE_0_DRAM0_EXCEPTION_MONITOR_2_CORE_0_DRAM0_RECORDING_ADDR_1(value uint32) {
	volatile.StoreUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_2.Reg, volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_2.Reg)&^(0xffffff)|value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_DRAM0_EXCEPTION_MONITOR_2_CORE_0_DRAM0_RECORDING_ADDR_1() uint32 {
	return volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_2.Reg) & 0xffffff
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_DRAM0_EXCEPTION_MONITOR_2_CORE_0_DRAM0_RECORDING_WR_1(value uint32) {
	volatile.StoreUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_2.Reg, volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_2.Reg)&^(0x1000000)|value<<24)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_DRAM0_EXCEPTION_MONITOR_2_CORE_0_DRAM0_RECORDING_WR_1() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_2.Reg) & 0x1000000) >> 24
}
func (o *ASSIST_DEBUG_Type) SetCORE_0_DRAM0_EXCEPTION_MONITOR_2_CORE_0_DRAM0_RECORDING_BYTEEN_1(value uint32) {
	volatile.StoreUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_2.Reg, volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_2.Reg)&^(0x1e000000)|value<<25)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_DRAM0_EXCEPTION_MONITOR_2_CORE_0_DRAM0_RECORDING_BYTEEN_1() uint32 {
	return (volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_2.Reg) & 0x1e000000) >> 25
}

// ASSIST_DEBUG.CORE_0_DRAM0_EXCEPTION_MONITOR_3: exception monitor status register5
func (o *ASSIST_DEBUG_Type) SetCORE_0_DRAM0_EXCEPTION_MONITOR_3(value uint32) {
	volatile.StoreUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_3.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_0_DRAM0_EXCEPTION_MONITOR_3() uint32 {
	return volatile.LoadUint32(&o.CORE_0_DRAM0_EXCEPTION_MONITOR_3.Reg)
}

// ASSIST_DEBUG.CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0: exception monitor status register6
func (o *ASSIST_DEBUG_Type) SetCORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0(value uint32) {
	volatile.StoreUint32(&o.CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0.Reg, volatile.LoadUint32(&o.CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0.Reg)&^(0xfffff)|value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0() uint32 {
	return volatile.LoadUint32(&o.CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0.Reg) & 0xfffff
}

// ASSIST_DEBUG.CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1: exception monitor status register7
func (o *ASSIST_DEBUG_Type) SetCORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1(value uint32) {
	volatile.StoreUint32(&o.CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1.Reg, volatile.LoadUint32(&o.CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1.Reg)&^(0xfffff)|value)
}
func (o *ASSIST_DEBUG_Type) GetCORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1() uint32 {
	return volatile.LoadUint32(&o.CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1.Reg) & 0xfffff
}

// ASSIST_DEBUG.C0RE_0_LASTPC_BEFORE_EXCEPTION: cpu status register
func (o *ASSIST_DEBUG_Type) SetC0RE_0_LASTPC_BEFORE_EXCEPTION(value uint32) {
	volatile.StoreUint32(&o.C0RE_0_LASTPC_BEFORE_EXCEPTION.Reg, value)
}
func (o *ASSIST_DEBUG_Type) GetC0RE_0_LASTPC_BEFORE_EXCEPTION() uint32 {
	return volatile.LoadUint32(&o.C0RE_0_LASTPC_BEFORE_EXCEPTION.Reg)
}

// ASSIST_DEBUG.C0RE_0_DEBUG_MODE: cpu status register
func (o *ASSIST_DEBUG_Type) SetC0RE_0_DEBUG_MODE_CORE_0_DEBUG_MODE(value uint32) {
	volatile.StoreUint32(&o.C0RE_0_DEBUG_MODE.Reg, volatile.LoadUint32(&o.C0RE_0_DEBUG_MODE.Reg)&^(0x1)|value)
}
func (o *ASSIST_DEBUG_Type) GetC0RE_0_DEBUG_MODE_CORE_0_DEBUG_MODE() uint32 {
	return volatile.LoadUint32(&o.C0RE_0_DEBUG_MODE.Reg) & 0x1
}
func (o *ASSIST_DEBUG_Type) SetC0RE_0_DEBUG_MODE_CORE_0_DEBUG_MODULE_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.C0RE_0_DEBUG_MODE.Reg, volatile.LoadUint32(&o.C0RE_0_DEBUG_MODE.Reg)&^(0x2)|value<<1)
}
func (o *ASSIST_DEBUG_Type) GetC0RE_0_DEBUG_MODE_CORE_0_DEBUG_MODULE_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.C0RE_0_DEBUG_MODE.Reg) & 0x2) >> 1
}

// ASSIST_DEBUG.CLOCK_GATE: clock register
func (o *ASSIST_DEBUG_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *ASSIST_DEBUG_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// ASSIST_DEBUG.DATE: version register
func (o *ASSIST_DEBUG_Type) SetDATE_ASSIST_DEBUG_DATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *ASSIST_DEBUG_Type) GetDATE_ASSIST_DEBUG_DATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// DMA (Direct Memory Access) Controller
type DMA_Type struct {
	IN_INT_RAW_CH0           volatile.Register32 // 0x0
	IN_INT_ST_CH0            volatile.Register32 // 0x4
	IN_INT_ENA_CH0           volatile.Register32 // 0x8
	IN_INT_CLR_CH0           volatile.Register32 // 0xC
	IN_INT_RAW_CH1           volatile.Register32 // 0x10
	IN_INT_ST_CH1            volatile.Register32 // 0x14
	IN_INT_ENA_CH1           volatile.Register32 // 0x18
	IN_INT_CLR_CH1           volatile.Register32 // 0x1C
	IN_INT_RAW_CH2           volatile.Register32 // 0x20
	IN_INT_ST_CH2            volatile.Register32 // 0x24
	IN_INT_ENA_CH2           volatile.Register32 // 0x28
	IN_INT_CLR_CH2           volatile.Register32 // 0x2C
	OUT_INT_RAW_CH0          volatile.Register32 // 0x30
	OUT_INT_ST_CH0           volatile.Register32 // 0x34
	OUT_INT_ENA_CH0          volatile.Register32 // 0x38
	OUT_INT_CLR_CH0          volatile.Register32 // 0x3C
	OUT_INT_RAW_CH1          volatile.Register32 // 0x40
	OUT_INT_ST_CH1           volatile.Register32 // 0x44
	OUT_INT_ENA_CH1          volatile.Register32 // 0x48
	OUT_INT_CLR_CH1          volatile.Register32 // 0x4C
	OUT_INT_RAW_CH2          volatile.Register32 // 0x50
	OUT_INT_ST_CH2           volatile.Register32 // 0x54
	OUT_INT_ENA_CH2          volatile.Register32 // 0x58
	OUT_INT_CLR_CH2          volatile.Register32 // 0x5C
	AHB_TEST                 volatile.Register32 // 0x60
	MISC_CONF                volatile.Register32 // 0x64
	DATE                     volatile.Register32 // 0x68
	_                        [4]byte
	IN_CONF0_CH0             volatile.Register32 // 0x70
	IN_CONF1_CH0             volatile.Register32 // 0x74
	INFIFO_STATUS_CH0        volatile.Register32 // 0x78
	IN_POP_CH0               volatile.Register32 // 0x7C
	IN_LINK_CH0              volatile.Register32 // 0x80
	IN_STATE_CH0             volatile.Register32 // 0x84
	IN_SUC_EOF_DES_ADDR_CH0  volatile.Register32 // 0x88
	IN_ERR_EOF_DES_ADDR_CH0  volatile.Register32 // 0x8C
	IN_DSCR_CH0              volatile.Register32 // 0x90
	IN_DSCR_BF0_CH0          volatile.Register32 // 0x94
	IN_DSCR_BF1_CH0          volatile.Register32 // 0x98
	IN_PRI_CH0               volatile.Register32 // 0x9C
	IN_PERI_SEL_CH0          volatile.Register32 // 0xA0
	_                        [48]byte
	OUT_CONF1_CH0            volatile.Register32 // 0xD4
	OUTFIFO_STATUS_CH0       volatile.Register32 // 0xD8
	OUT_PUSH_CH0             volatile.Register32 // 0xDC
	OUT_LINK_CH0             volatile.Register32 // 0xE0
	OUT_STATE_CH0            volatile.Register32 // 0xE4
	OUT_EOF_DES_ADDR_CH0     volatile.Register32 // 0xE8
	OUT_EOF_BFR_DES_ADDR_CH0 volatile.Register32 // 0xEC
	OUT_DSCR_CH0             volatile.Register32 // 0xF0
	OUT_DSCR_BF0_CH0         volatile.Register32 // 0xF4
	OUT_DSCR_BF1_CH0         volatile.Register32 // 0xF8
	OUT_PRI_CH0              volatile.Register32 // 0xFC
	OUT_PERI_SEL_CH0         volatile.Register32 // 0x100
	_                        [44]byte
	IN_CONF0_CH1             volatile.Register32 // 0x130
	IN_CONF1_CH1             volatile.Register32 // 0x134
	INFIFO_STATUS_CH1        volatile.Register32 // 0x138
	IN_POP_CH1               volatile.Register32 // 0x13C
	IN_LINK_CH1              volatile.Register32 // 0x140
	IN_STATE_CH1             volatile.Register32 // 0x144
	IN_SUC_EOF_DES_ADDR_CH1  volatile.Register32 // 0x148
	IN_ERR_EOF_DES_ADDR_CH1  volatile.Register32 // 0x14C
	IN_DSCR_CH1              volatile.Register32 // 0x150
	IN_DSCR_BF0_CH1          volatile.Register32 // 0x154
	IN_DSCR_BF1_CH1          volatile.Register32 // 0x158
	IN_PRI_CH1               volatile.Register32 // 0x15C
	IN_PERI_SEL_CH1          volatile.Register32 // 0x160
	_                        [44]byte
	OUT_CONF0_CH0            volatile.Register32 // 0x190
	OUT_CONF1_CH1            volatile.Register32 // 0x194
	OUTFIFO_STATUS_CH1       volatile.Register32 // 0x198
	OUT_PUSH_CH1             volatile.Register32 // 0x19C
	OUT_LINK_CH1             volatile.Register32 // 0x1A0
	OUT_STATE_CH1            volatile.Register32 // 0x1A4
	OUT_EOF_DES_ADDR_CH1     volatile.Register32 // 0x1A8
	OUT_EOF_BFR_DES_ADDR_CH1 volatile.Register32 // 0x1AC
	OUT_DSCR_CH1             volatile.Register32 // 0x1B0
	OUT_DSCR_BF0_CH1         volatile.Register32 // 0x1B4
	OUT_DSCR_BF1_CH1         volatile.Register32 // 0x1B8
	OUT_PRI_CH1              volatile.Register32 // 0x1BC
	OUT_PERI_SEL_CH1         volatile.Register32 // 0x1C0
	_                        [44]byte
	IN_CONF0_CH2             volatile.Register32 // 0x1F0
	IN_CONF1_CH2             volatile.Register32 // 0x1F4
	INFIFO_STATUS_CH2        volatile.Register32 // 0x1F8
	IN_POP_CH2               volatile.Register32 // 0x1FC
	IN_LINK_CH2              volatile.Register32 // 0x200
	IN_STATE_CH2             volatile.Register32 // 0x204
	IN_SUC_EOF_DES_ADDR_CH2  volatile.Register32 // 0x208
	IN_ERR_EOF_DES_ADDR_CH2  volatile.Register32 // 0x20C
	IN_DSCR_CH2              volatile.Register32 // 0x210
	IN_DSCR_BF0_CH2          volatile.Register32 // 0x214
	IN_DSCR_BF1_CH2          volatile.Register32 // 0x218
	IN_PRI_CH2               volatile.Register32 // 0x21C
	IN_PERI_SEL_CH2          volatile.Register32 // 0x220
	_                        [44]byte
	OUT_CONF0_CH1            volatile.Register32 // 0x250
	OUT_CONF1_CH2            volatile.Register32 // 0x254
	OUTFIFO_STATUS_CH2       volatile.Register32 // 0x258
	OUT_PUSH_CH2             volatile.Register32 // 0x25C
	OUT_LINK_CH2             volatile.Register32 // 0x260
	OUT_STATE_CH2            volatile.Register32 // 0x264
	OUT_EOF_DES_ADDR_CH2     volatile.Register32 // 0x268
	OUT_EOF_BFR_DES_ADDR_CH2 volatile.Register32 // 0x26C
	OUT_DSCR_CH2             volatile.Register32 // 0x270
	OUT_DSCR_BF0_CH2         volatile.Register32 // 0x274
	OUT_DSCR_BF1_CH2         volatile.Register32 // 0x278
	OUT_PRI_CH2              volatile.Register32 // 0x27C
	OUT_PERI_SEL_CH2         volatile.Register32 // 0x280
	_                        [140]byte
	OUT_CONF0_CH2            volatile.Register32 // 0x310
}

// DMA.IN_INT_RAW_CH0: Raw status interrupt of channel 0
func (o *DMA_Type) SetIN_INT_RAW_CH0_IN_DONE(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH0.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_INT_RAW_CH0_IN_DONE() uint32 {
	return volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg) & 0x1
}
func (o *DMA_Type) SetIN_INT_RAW_CH0_IN_SUC_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH0.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_INT_RAW_CH0_IN_SUC_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_INT_RAW_CH0_IN_ERR_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH0.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_INT_RAW_CH0_IN_ERR_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_INT_RAW_CH0_IN_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH0.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_INT_RAW_CH0_IN_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_INT_RAW_CH0_IN_DSCR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH0.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_INT_RAW_CH0_IN_DSCR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_INT_RAW_CH0_INFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH0.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_INT_RAW_CH0_INFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIN_INT_RAW_CH0_INFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH0.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIN_INT_RAW_CH0_INFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH0.Reg) & 0x40) >> 6
}

// DMA.IN_INT_ST_CH0: Masked interrupt of channel 0
func (o *DMA_Type) SetIN_INT_ST_CH0_IN_DONE(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_INT_ST_CH0_IN_DONE() uint32 {
	return volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg) & 0x1
}
func (o *DMA_Type) SetIN_INT_ST_CH0_IN_SUC_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_INT_ST_CH0_IN_SUC_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_INT_ST_CH0_IN_ERR_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_INT_ST_CH0_IN_ERR_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_INT_ST_CH0_IN_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_INT_ST_CH0_IN_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_INT_ST_CH0_IN_DSCR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_INT_ST_CH0_IN_DSCR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_INT_ST_CH0_INFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_INT_ST_CH0_INFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIN_INT_ST_CH0_INFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIN_INT_ST_CH0_INFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH0.Reg) & 0x40) >> 6
}

// DMA.IN_INT_ENA_CH0: Interrupt enable bits of channel 0
func (o *DMA_Type) SetIN_INT_ENA_CH0_IN_DONE(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_INT_ENA_CH0_IN_DONE() uint32 {
	return volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg) & 0x1
}
func (o *DMA_Type) SetIN_INT_ENA_CH0_IN_SUC_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_INT_ENA_CH0_IN_SUC_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_INT_ENA_CH0_IN_ERR_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_INT_ENA_CH0_IN_ERR_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_INT_ENA_CH0_IN_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_INT_ENA_CH0_IN_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_INT_ENA_CH0_IN_DSCR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_INT_ENA_CH0_IN_DSCR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_INT_ENA_CH0_INFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_INT_ENA_CH0_INFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIN_INT_ENA_CH0_INFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH0.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIN_INT_ENA_CH0_INFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH0.Reg) & 0x40) >> 6
}

// DMA.IN_INT_CLR_CH0: Interrupt clear bits of channel 0
func (o *DMA_Type) SetIN_INT_CLR_CH0_IN_DONE(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH0.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_INT_CLR_CH0_IN_DONE() uint32 {
	return volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg) & 0x1
}
func (o *DMA_Type) SetIN_INT_CLR_CH0_IN_SUC_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH0.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_INT_CLR_CH0_IN_SUC_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_INT_CLR_CH0_IN_ERR_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH0.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_INT_CLR_CH0_IN_ERR_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_INT_CLR_CH0_IN_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH0.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_INT_CLR_CH0_IN_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_INT_CLR_CH0_IN_DSCR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH0.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_INT_CLR_CH0_IN_DSCR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_INT_CLR_CH0_INFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH0.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_INT_CLR_CH0_INFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIN_INT_CLR_CH0_INFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH0.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIN_INT_CLR_CH0_INFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH0.Reg) & 0x40) >> 6
}

// DMA.IN_INT_RAW_CH1: Raw status interrupt of channel 0
func (o *DMA_Type) SetIN_INT_RAW_CH1_IN_DONE(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH1.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_INT_RAW_CH1_IN_DONE() uint32 {
	return volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg) & 0x1
}
func (o *DMA_Type) SetIN_INT_RAW_CH1_IN_SUC_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH1.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_INT_RAW_CH1_IN_SUC_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_INT_RAW_CH1_IN_ERR_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH1.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_INT_RAW_CH1_IN_ERR_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_INT_RAW_CH1_IN_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH1.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_INT_RAW_CH1_IN_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_INT_RAW_CH1_IN_DSCR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH1.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_INT_RAW_CH1_IN_DSCR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_INT_RAW_CH1_INFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH1.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_INT_RAW_CH1_INFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIN_INT_RAW_CH1_INFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH1.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIN_INT_RAW_CH1_INFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH1.Reg) & 0x40) >> 6
}

// DMA.IN_INT_ST_CH1: Masked interrupt of channel 0
func (o *DMA_Type) SetIN_INT_ST_CH1_IN_DONE(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_INT_ST_CH1_IN_DONE() uint32 {
	return volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg) & 0x1
}
func (o *DMA_Type) SetIN_INT_ST_CH1_IN_SUC_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_INT_ST_CH1_IN_SUC_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_INT_ST_CH1_IN_ERR_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_INT_ST_CH1_IN_ERR_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_INT_ST_CH1_IN_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_INT_ST_CH1_IN_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_INT_ST_CH1_IN_DSCR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_INT_ST_CH1_IN_DSCR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_INT_ST_CH1_INFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_INT_ST_CH1_INFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIN_INT_ST_CH1_INFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIN_INT_ST_CH1_INFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH1.Reg) & 0x40) >> 6
}

// DMA.IN_INT_ENA_CH1: Interrupt enable bits of channel 0
func (o *DMA_Type) SetIN_INT_ENA_CH1_IN_DONE(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_INT_ENA_CH1_IN_DONE() uint32 {
	return volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg) & 0x1
}
func (o *DMA_Type) SetIN_INT_ENA_CH1_IN_SUC_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_INT_ENA_CH1_IN_SUC_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_INT_ENA_CH1_IN_ERR_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_INT_ENA_CH1_IN_ERR_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_INT_ENA_CH1_IN_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_INT_ENA_CH1_IN_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_INT_ENA_CH1_IN_DSCR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_INT_ENA_CH1_IN_DSCR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_INT_ENA_CH1_INFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_INT_ENA_CH1_INFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIN_INT_ENA_CH1_INFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH1.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIN_INT_ENA_CH1_INFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH1.Reg) & 0x40) >> 6
}

// DMA.IN_INT_CLR_CH1: Interrupt clear bits of channel 0
func (o *DMA_Type) SetIN_INT_CLR_CH1_IN_DONE(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH1.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_INT_CLR_CH1_IN_DONE() uint32 {
	return volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg) & 0x1
}
func (o *DMA_Type) SetIN_INT_CLR_CH1_IN_SUC_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH1.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_INT_CLR_CH1_IN_SUC_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_INT_CLR_CH1_IN_ERR_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH1.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_INT_CLR_CH1_IN_ERR_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_INT_CLR_CH1_IN_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH1.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_INT_CLR_CH1_IN_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_INT_CLR_CH1_IN_DSCR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH1.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_INT_CLR_CH1_IN_DSCR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_INT_CLR_CH1_INFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH1.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_INT_CLR_CH1_INFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIN_INT_CLR_CH1_INFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH1.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIN_INT_CLR_CH1_INFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH1.Reg) & 0x40) >> 6
}

// DMA.IN_INT_RAW_CH2: Raw status interrupt of channel 0
func (o *DMA_Type) SetIN_INT_RAW_CH2_IN_DONE(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH2.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_INT_RAW_CH2_IN_DONE() uint32 {
	return volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg) & 0x1
}
func (o *DMA_Type) SetIN_INT_RAW_CH2_IN_SUC_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH2.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_INT_RAW_CH2_IN_SUC_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_INT_RAW_CH2_IN_ERR_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH2.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_INT_RAW_CH2_IN_ERR_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_INT_RAW_CH2_IN_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH2.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_INT_RAW_CH2_IN_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_INT_RAW_CH2_IN_DSCR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH2.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_INT_RAW_CH2_IN_DSCR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_INT_RAW_CH2_INFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH2.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_INT_RAW_CH2_INFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIN_INT_RAW_CH2_INFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_RAW_CH2.Reg, volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIN_INT_RAW_CH2_INFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_RAW_CH2.Reg) & 0x40) >> 6
}

// DMA.IN_INT_ST_CH2: Masked interrupt of channel 0
func (o *DMA_Type) SetIN_INT_ST_CH2_IN_DONE(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_INT_ST_CH2_IN_DONE() uint32 {
	return volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg) & 0x1
}
func (o *DMA_Type) SetIN_INT_ST_CH2_IN_SUC_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_INT_ST_CH2_IN_SUC_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_INT_ST_CH2_IN_ERR_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_INT_ST_CH2_IN_ERR_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_INT_ST_CH2_IN_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_INT_ST_CH2_IN_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_INT_ST_CH2_IN_DSCR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_INT_ST_CH2_IN_DSCR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_INT_ST_CH2_INFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_INT_ST_CH2_INFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIN_INT_ST_CH2_INFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ST_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIN_INT_ST_CH2_INFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ST_CH2.Reg) & 0x40) >> 6
}

// DMA.IN_INT_ENA_CH2: Interrupt enable bits of channel 0
func (o *DMA_Type) SetIN_INT_ENA_CH2_IN_DONE(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_INT_ENA_CH2_IN_DONE() uint32 {
	return volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg) & 0x1
}
func (o *DMA_Type) SetIN_INT_ENA_CH2_IN_SUC_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_INT_ENA_CH2_IN_SUC_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_INT_ENA_CH2_IN_ERR_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_INT_ENA_CH2_IN_ERR_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_INT_ENA_CH2_IN_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_INT_ENA_CH2_IN_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_INT_ENA_CH2_IN_DSCR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_INT_ENA_CH2_IN_DSCR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_INT_ENA_CH2_INFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_INT_ENA_CH2_INFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIN_INT_ENA_CH2_INFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_ENA_CH2.Reg, volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIN_INT_ENA_CH2_INFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_ENA_CH2.Reg) & 0x40) >> 6
}

// DMA.IN_INT_CLR_CH2: Interrupt clear bits of channel 0
func (o *DMA_Type) SetIN_INT_CLR_CH2_IN_DONE(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH2.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_INT_CLR_CH2_IN_DONE() uint32 {
	return volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg) & 0x1
}
func (o *DMA_Type) SetIN_INT_CLR_CH2_IN_SUC_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH2.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_INT_CLR_CH2_IN_SUC_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_INT_CLR_CH2_IN_ERR_EOF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH2.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_INT_CLR_CH2_IN_ERR_EOF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_INT_CLR_CH2_IN_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH2.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_INT_CLR_CH2_IN_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_INT_CLR_CH2_IN_DSCR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH2.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_INT_CLR_CH2_IN_DSCR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_INT_CLR_CH2_INFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH2.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_INT_CLR_CH2_INFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIN_INT_CLR_CH2_INFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.IN_INT_CLR_CH2.Reg, volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIN_INT_CLR_CH2_INFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.IN_INT_CLR_CH2.Reg) & 0x40) >> 6
}

// DMA.OUT_INT_RAW_CH0: Raw status interrupt of channel 0
func (o *DMA_Type) SetOUT_INT_RAW_CH0_OUT_DONE(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH0.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH0_OUT_DONE() uint32 {
	return volatile.LoadUint32(&o.OUT_INT_RAW_CH0.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_INT_RAW_CH0_OUT_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH0.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH0_OUT_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH0.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_INT_RAW_CH0_OUT_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH0.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH0_OUT_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH0.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_INT_RAW_CH0_OUT_TOTAL_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH0.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH0_OUT_TOTAL_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH0.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_INT_RAW_CH0_OUTFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH0.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH0_OUTFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH0.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_INT_RAW_CH0_OUTFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH0.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH0_OUTFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH0.Reg) & 0x20) >> 5
}

// DMA.OUT_INT_ST_CH0: Masked interrupt of channel 0
func (o *DMA_Type) SetOUT_INT_ST_CH0_OUT_DONE(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH0.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_INT_ST_CH0_OUT_DONE() uint32 {
	return volatile.LoadUint32(&o.OUT_INT_ST_CH0.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_INT_ST_CH0_OUT_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH0.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_INT_ST_CH0_OUT_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH0.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_INT_ST_CH0_OUT_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH0.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_INT_ST_CH0_OUT_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH0.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_INT_ST_CH0_OUT_TOTAL_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH0.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_INT_ST_CH0_OUT_TOTAL_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH0.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_INT_ST_CH0_OUTFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH0.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_INT_ST_CH0_OUTFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH0.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_INT_ST_CH0_OUTFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH0.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_INT_ST_CH0_OUTFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH0.Reg) & 0x20) >> 5
}

// DMA.OUT_INT_ENA_CH0: Interrupt enable bits of channel 0
func (o *DMA_Type) SetOUT_INT_ENA_CH0_OUT_DONE(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH0.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH0_OUT_DONE() uint32 {
	return volatile.LoadUint32(&o.OUT_INT_ENA_CH0.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_INT_ENA_CH0_OUT_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH0.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH0_OUT_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH0.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_INT_ENA_CH0_OUT_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH0.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH0_OUT_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH0.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_INT_ENA_CH0_OUT_TOTAL_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH0.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH0_OUT_TOTAL_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH0.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_INT_ENA_CH0_OUTFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH0.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH0_OUTFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH0.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_INT_ENA_CH0_OUTFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH0.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH0_OUTFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH0.Reg) & 0x20) >> 5
}

// DMA.OUT_INT_CLR_CH0: Interrupt clear bits of channel 0
func (o *DMA_Type) SetOUT_INT_CLR_CH0_OUT_DONE(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH0.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH0_OUT_DONE() uint32 {
	return volatile.LoadUint32(&o.OUT_INT_CLR_CH0.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_INT_CLR_CH0_OUT_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH0.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH0_OUT_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH0.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_INT_CLR_CH0_OUT_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH0.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH0_OUT_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH0.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_INT_CLR_CH0_OUT_TOTAL_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH0.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH0_OUT_TOTAL_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH0.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_INT_CLR_CH0_OUTFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH0.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH0_OUTFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH0.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_INT_CLR_CH0_OUTFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH0.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH0.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH0_OUTFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH0.Reg) & 0x20) >> 5
}

// DMA.OUT_INT_RAW_CH1: Raw status interrupt of channel 0
func (o *DMA_Type) SetOUT_INT_RAW_CH1_OUT_DONE(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH1_OUT_DONE() uint32 {
	return volatile.LoadUint32(&o.OUT_INT_RAW_CH1.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_INT_RAW_CH1_OUT_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH1_OUT_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_INT_RAW_CH1_OUT_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH1.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH1_OUT_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH1.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_INT_RAW_CH1_OUT_TOTAL_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH1.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH1_OUT_TOTAL_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH1.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_INT_RAW_CH1_OUTFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH1.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH1_OUTFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH1.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_INT_RAW_CH1_OUTFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH1.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH1_OUTFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH1.Reg) & 0x20) >> 5
}

// DMA.OUT_INT_ST_CH1: Masked interrupt of channel 0
func (o *DMA_Type) SetOUT_INT_ST_CH1_OUT_DONE(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_INT_ST_CH1_OUT_DONE() uint32 {
	return volatile.LoadUint32(&o.OUT_INT_ST_CH1.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_INT_ST_CH1_OUT_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_INT_ST_CH1_OUT_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_INT_ST_CH1_OUT_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH1.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_INT_ST_CH1_OUT_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH1.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_INT_ST_CH1_OUT_TOTAL_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH1.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_INT_ST_CH1_OUT_TOTAL_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH1.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_INT_ST_CH1_OUTFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH1.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_INT_ST_CH1_OUTFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH1.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_INT_ST_CH1_OUTFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH1.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_INT_ST_CH1_OUTFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH1.Reg) & 0x20) >> 5
}

// DMA.OUT_INT_ENA_CH1: Interrupt enable bits of channel 0
func (o *DMA_Type) SetOUT_INT_ENA_CH1_OUT_DONE(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH1_OUT_DONE() uint32 {
	return volatile.LoadUint32(&o.OUT_INT_ENA_CH1.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_INT_ENA_CH1_OUT_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH1_OUT_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_INT_ENA_CH1_OUT_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH1.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH1_OUT_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH1.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_INT_ENA_CH1_OUT_TOTAL_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH1.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH1_OUT_TOTAL_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH1.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_INT_ENA_CH1_OUTFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH1.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH1_OUTFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH1.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_INT_ENA_CH1_OUTFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH1.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH1_OUTFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH1.Reg) & 0x20) >> 5
}

// DMA.OUT_INT_CLR_CH1: Interrupt clear bits of channel 0
func (o *DMA_Type) SetOUT_INT_CLR_CH1_OUT_DONE(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH1_OUT_DONE() uint32 {
	return volatile.LoadUint32(&o.OUT_INT_CLR_CH1.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_INT_CLR_CH1_OUT_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH1_OUT_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_INT_CLR_CH1_OUT_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH1.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH1_OUT_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH1.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_INT_CLR_CH1_OUT_TOTAL_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH1.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH1_OUT_TOTAL_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH1.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_INT_CLR_CH1_OUTFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH1.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH1_OUTFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH1.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_INT_CLR_CH1_OUTFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH1.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH1.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH1_OUTFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH1.Reg) & 0x20) >> 5
}

// DMA.OUT_INT_RAW_CH2: Raw status interrupt of channel 0
func (o *DMA_Type) SetOUT_INT_RAW_CH2_OUT_DONE(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH2_OUT_DONE() uint32 {
	return volatile.LoadUint32(&o.OUT_INT_RAW_CH2.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_INT_RAW_CH2_OUT_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH2_OUT_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_INT_RAW_CH2_OUT_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH2.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH2_OUT_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH2.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_INT_RAW_CH2_OUT_TOTAL_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH2.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH2_OUT_TOTAL_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH2.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_INT_RAW_CH2_OUTFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH2.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH2_OUTFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH2.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_INT_RAW_CH2_OUTFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_RAW_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_RAW_CH2.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_INT_RAW_CH2_OUTFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_RAW_CH2.Reg) & 0x20) >> 5
}

// DMA.OUT_INT_ST_CH2: Masked interrupt of channel 0
func (o *DMA_Type) SetOUT_INT_ST_CH2_OUT_DONE(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_INT_ST_CH2_OUT_DONE() uint32 {
	return volatile.LoadUint32(&o.OUT_INT_ST_CH2.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_INT_ST_CH2_OUT_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_INT_ST_CH2_OUT_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_INT_ST_CH2_OUT_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH2.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_INT_ST_CH2_OUT_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH2.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_INT_ST_CH2_OUT_TOTAL_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH2.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_INT_ST_CH2_OUT_TOTAL_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH2.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_INT_ST_CH2_OUTFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH2.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_INT_ST_CH2_OUTFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH2.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_INT_ST_CH2_OUTFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ST_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_ST_CH2.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_INT_ST_CH2_OUTFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ST_CH2.Reg) & 0x20) >> 5
}

// DMA.OUT_INT_ENA_CH2: Interrupt enable bits of channel 0
func (o *DMA_Type) SetOUT_INT_ENA_CH2_OUT_DONE(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH2_OUT_DONE() uint32 {
	return volatile.LoadUint32(&o.OUT_INT_ENA_CH2.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_INT_ENA_CH2_OUT_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH2_OUT_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_INT_ENA_CH2_OUT_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH2.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH2_OUT_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH2.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_INT_ENA_CH2_OUT_TOTAL_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH2.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH2_OUT_TOTAL_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH2.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_INT_ENA_CH2_OUTFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH2.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH2_OUTFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH2.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_INT_ENA_CH2_OUTFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_ENA_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_ENA_CH2.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_INT_ENA_CH2_OUTFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_ENA_CH2.Reg) & 0x20) >> 5
}

// DMA.OUT_INT_CLR_CH2: Interrupt clear bits of channel 0
func (o *DMA_Type) SetOUT_INT_CLR_CH2_OUT_DONE(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH2_OUT_DONE() uint32 {
	return volatile.LoadUint32(&o.OUT_INT_CLR_CH2.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_INT_CLR_CH2_OUT_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH2_OUT_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_INT_CLR_CH2_OUT_DSCR_ERR(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH2.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH2_OUT_DSCR_ERR() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH2.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_INT_CLR_CH2_OUT_TOTAL_EOF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH2.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH2_OUT_TOTAL_EOF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH2.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_INT_CLR_CH2_OUTFIFO_OVF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH2.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH2_OUTFIFO_OVF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH2.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_INT_CLR_CH2_OUTFIFO_UDF(value uint32) {
	volatile.StoreUint32(&o.OUT_INT_CLR_CH2.Reg, volatile.LoadUint32(&o.OUT_INT_CLR_CH2.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_INT_CLR_CH2_OUTFIFO_UDF() uint32 {
	return (volatile.LoadUint32(&o.OUT_INT_CLR_CH2.Reg) & 0x20) >> 5
}

// DMA.AHB_TEST: reserved
func (o *DMA_Type) SetAHB_TEST_AHB_TESTMODE(value uint32) {
	volatile.StoreUint32(&o.AHB_TEST.Reg, volatile.LoadUint32(&o.AHB_TEST.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetAHB_TEST_AHB_TESTMODE() uint32 {
	return volatile.LoadUint32(&o.AHB_TEST.Reg) & 0x7
}
func (o *DMA_Type) SetAHB_TEST_AHB_TESTADDR(value uint32) {
	volatile.StoreUint32(&o.AHB_TEST.Reg, volatile.LoadUint32(&o.AHB_TEST.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetAHB_TEST_AHB_TESTADDR() uint32 {
	return (volatile.LoadUint32(&o.AHB_TEST.Reg) & 0x30) >> 4
}

// DMA.MISC_CONF: MISC register
func (o *DMA_Type) SetMISC_CONF_AHBM_RST_INTER(value uint32) {
	volatile.StoreUint32(&o.MISC_CONF.Reg, volatile.LoadUint32(&o.MISC_CONF.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetMISC_CONF_AHBM_RST_INTER() uint32 {
	return volatile.LoadUint32(&o.MISC_CONF.Reg) & 0x1
}
func (o *DMA_Type) SetMISC_CONF_ARB_PRI_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC_CONF.Reg, volatile.LoadUint32(&o.MISC_CONF.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetMISC_CONF_ARB_PRI_DIS() uint32 {
	return (volatile.LoadUint32(&o.MISC_CONF.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetMISC_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC_CONF.Reg, volatile.LoadUint32(&o.MISC_CONF.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetMISC_CONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC_CONF.Reg) & 0x8) >> 3
}

// DMA.DATE: Version control register
func (o *DMA_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *DMA_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// DMA.IN_CONF0_CH0: Configure 0 register of Rx channel 0
func (o *DMA_Type) SetIN_CONF0_CH0_IN_RST(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH0.Reg, volatile.LoadUint32(&o.IN_CONF0_CH0.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_CONF0_CH0_IN_RST() uint32 {
	return volatile.LoadUint32(&o.IN_CONF0_CH0.Reg) & 0x1
}
func (o *DMA_Type) SetIN_CONF0_CH0_IN_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH0.Reg, volatile.LoadUint32(&o.IN_CONF0_CH0.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_CONF0_CH0_IN_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH0.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_CONF0_CH0_INDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH0.Reg, volatile.LoadUint32(&o.IN_CONF0_CH0.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_CONF0_CH0_INDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH0.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_CONF0_CH0_IN_DATA_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH0.Reg, volatile.LoadUint32(&o.IN_CONF0_CH0.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_CONF0_CH0_IN_DATA_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH0.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_CONF0_CH0_MEM_TRANS_EN(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH0.Reg, volatile.LoadUint32(&o.IN_CONF0_CH0.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_CONF0_CH0_MEM_TRANS_EN() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH0.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_CONF0_CH0_IN_ETM_EN(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH0.Reg, volatile.LoadUint32(&o.IN_CONF0_CH0.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_CONF0_CH0_IN_ETM_EN() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH0.Reg) & 0x20) >> 5
}

// DMA.IN_CONF1_CH0: Configure 1 register of Rx channel 0
func (o *DMA_Type) SetIN_CONF1_CH0_IN_CHECK_OWNER(value uint32) {
	volatile.StoreUint32(&o.IN_CONF1_CH0.Reg, volatile.LoadUint32(&o.IN_CONF1_CH0.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetIN_CONF1_CH0_IN_CHECK_OWNER() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF1_CH0.Reg) & 0x1000) >> 12
}

// DMA.INFIFO_STATUS_CH0: Receive FIFO status of Rx channel 0
func (o *DMA_Type) SetINFIFO_STATUS_CH0_INFIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH0_INFIFO_FULL() uint32 {
	return volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg) & 0x1
}
func (o *DMA_Type) SetINFIFO_STATUS_CH0_INFIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH0_INFIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetINFIFO_STATUS_CH0_INFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg)&^(0xfc)|value<<2)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH0_INFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg) & 0xfc) >> 2
}
func (o *DMA_Type) SetINFIFO_STATUS_CH0_IN_REMAIN_UNDER_1B(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH0_IN_REMAIN_UNDER_1B() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetINFIFO_STATUS_CH0_IN_REMAIN_UNDER_2B(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH0_IN_REMAIN_UNDER_2B() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetINFIFO_STATUS_CH0_IN_REMAIN_UNDER_3B(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH0_IN_REMAIN_UNDER_3B() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetINFIFO_STATUS_CH0_IN_REMAIN_UNDER_4B(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH0_IN_REMAIN_UNDER_4B() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetINFIFO_STATUS_CH0_IN_BUF_HUNGRY(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH0_IN_BUF_HUNGRY() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH0.Reg) & 0x8000000) >> 27
}

// DMA.IN_POP_CH0: Pop control register of Rx channel 0
func (o *DMA_Type) SetIN_POP_CH0_INFIFO_RDATA(value uint32) {
	volatile.StoreUint32(&o.IN_POP_CH0.Reg, volatile.LoadUint32(&o.IN_POP_CH0.Reg)&^(0xfff)|value)
}
func (o *DMA_Type) GetIN_POP_CH0_INFIFO_RDATA() uint32 {
	return volatile.LoadUint32(&o.IN_POP_CH0.Reg) & 0xfff
}
func (o *DMA_Type) SetIN_POP_CH0_INFIFO_POP(value uint32) {
	volatile.StoreUint32(&o.IN_POP_CH0.Reg, volatile.LoadUint32(&o.IN_POP_CH0.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetIN_POP_CH0_INFIFO_POP() uint32 {
	return (volatile.LoadUint32(&o.IN_POP_CH0.Reg) & 0x1000) >> 12
}

// DMA.IN_LINK_CH0: Link descriptor configure and control register of Rx channel 0
func (o *DMA_Type) SetIN_LINK_CH0_INLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH0.Reg, volatile.LoadUint32(&o.IN_LINK_CH0.Reg)&^(0xfffff)|value)
}
func (o *DMA_Type) GetIN_LINK_CH0_INLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.IN_LINK_CH0.Reg) & 0xfffff
}
func (o *DMA_Type) SetIN_LINK_CH0_INLINK_AUTO_RET(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH0.Reg, volatile.LoadUint32(&o.IN_LINK_CH0.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetIN_LINK_CH0_INLINK_AUTO_RET() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH0.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetIN_LINK_CH0_INLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH0.Reg, volatile.LoadUint32(&o.IN_LINK_CH0.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetIN_LINK_CH0_INLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH0.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetIN_LINK_CH0_INLINK_START(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH0.Reg, volatile.LoadUint32(&o.IN_LINK_CH0.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetIN_LINK_CH0_INLINK_START() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH0.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetIN_LINK_CH0_INLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH0.Reg, volatile.LoadUint32(&o.IN_LINK_CH0.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetIN_LINK_CH0_INLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH0.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetIN_LINK_CH0_INLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH0.Reg, volatile.LoadUint32(&o.IN_LINK_CH0.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetIN_LINK_CH0_INLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH0.Reg) & 0x1000000) >> 24
}

// DMA.IN_STATE_CH0: Receive status of Rx channel 0
func (o *DMA_Type) SetIN_STATE_CH0_INLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_STATE_CH0.Reg, volatile.LoadUint32(&o.IN_STATE_CH0.Reg)&^(0x3ffff)|value)
}
func (o *DMA_Type) GetIN_STATE_CH0_INLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.IN_STATE_CH0.Reg) & 0x3ffff
}
func (o *DMA_Type) SetIN_STATE_CH0_IN_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.IN_STATE_CH0.Reg, volatile.LoadUint32(&o.IN_STATE_CH0.Reg)&^(0xc0000)|value<<18)
}
func (o *DMA_Type) GetIN_STATE_CH0_IN_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.IN_STATE_CH0.Reg) & 0xc0000) >> 18
}
func (o *DMA_Type) SetIN_STATE_CH0_IN_STATE(value uint32) {
	volatile.StoreUint32(&o.IN_STATE_CH0.Reg, volatile.LoadUint32(&o.IN_STATE_CH0.Reg)&^(0x700000)|value<<20)
}
func (o *DMA_Type) GetIN_STATE_CH0_IN_STATE() uint32 {
	return (volatile.LoadUint32(&o.IN_STATE_CH0.Reg) & 0x700000) >> 20
}

// DMA.IN_SUC_EOF_DES_ADDR_CH0: Inlink descriptor address when EOF occurs of Rx channel 0
func (o *DMA_Type) SetIN_SUC_EOF_DES_ADDR_CH0(value uint32) {
	volatile.StoreUint32(&o.IN_SUC_EOF_DES_ADDR_CH0.Reg, value)
}
func (o *DMA_Type) GetIN_SUC_EOF_DES_ADDR_CH0() uint32 {
	return volatile.LoadUint32(&o.IN_SUC_EOF_DES_ADDR_CH0.Reg)
}

// DMA.IN_ERR_EOF_DES_ADDR_CH0: Inlink descriptor address when errors occur of Rx channel 0
func (o *DMA_Type) SetIN_ERR_EOF_DES_ADDR_CH0(value uint32) {
	volatile.StoreUint32(&o.IN_ERR_EOF_DES_ADDR_CH0.Reg, value)
}
func (o *DMA_Type) GetIN_ERR_EOF_DES_ADDR_CH0() uint32 {
	return volatile.LoadUint32(&o.IN_ERR_EOF_DES_ADDR_CH0.Reg)
}

// DMA.IN_DSCR_CH0: Current inlink descriptor address of Rx channel 0
func (o *DMA_Type) SetIN_DSCR_CH0(value uint32) {
	volatile.StoreUint32(&o.IN_DSCR_CH0.Reg, value)
}
func (o *DMA_Type) GetIN_DSCR_CH0() uint32 {
	return volatile.LoadUint32(&o.IN_DSCR_CH0.Reg)
}

// DMA.IN_DSCR_BF0_CH0: The last inlink descriptor address of Rx channel 0
func (o *DMA_Type) SetIN_DSCR_BF0_CH0(value uint32) {
	volatile.StoreUint32(&o.IN_DSCR_BF0_CH0.Reg, value)
}
func (o *DMA_Type) GetIN_DSCR_BF0_CH0() uint32 {
	return volatile.LoadUint32(&o.IN_DSCR_BF0_CH0.Reg)
}

// DMA.IN_DSCR_BF1_CH0: The second-to-last inlink descriptor address of Rx channel 0
func (o *DMA_Type) SetIN_DSCR_BF1_CH0(value uint32) {
	volatile.StoreUint32(&o.IN_DSCR_BF1_CH0.Reg, value)
}
func (o *DMA_Type) GetIN_DSCR_BF1_CH0() uint32 {
	return volatile.LoadUint32(&o.IN_DSCR_BF1_CH0.Reg)
}

// DMA.IN_PRI_CH0: Priority register of Rx channel 0
func (o *DMA_Type) SetIN_PRI_CH0_RX_PRI(value uint32) {
	volatile.StoreUint32(&o.IN_PRI_CH0.Reg, volatile.LoadUint32(&o.IN_PRI_CH0.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetIN_PRI_CH0_RX_PRI() uint32 {
	return volatile.LoadUint32(&o.IN_PRI_CH0.Reg) & 0xf
}

// DMA.IN_PERI_SEL_CH0: Peripheral selection of Rx channel 0
func (o *DMA_Type) SetIN_PERI_SEL_CH0_PERI_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.IN_PERI_SEL_CH0.Reg, volatile.LoadUint32(&o.IN_PERI_SEL_CH0.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetIN_PERI_SEL_CH0_PERI_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.IN_PERI_SEL_CH0.Reg) & 0x3f
}

// DMA.OUT_CONF1_CH0: Configure 1 register of Tx channel 0
func (o *DMA_Type) SetOUT_CONF1_CH0_OUT_CHECK_OWNER(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF1_CH0.Reg, volatile.LoadUint32(&o.OUT_CONF1_CH0.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetOUT_CONF1_CH0_OUT_CHECK_OWNER() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF1_CH0.Reg) & 0x1000) >> 12
}

// DMA.OUTFIFO_STATUS_CH0: Transmit FIFO status of Tx channel 0
func (o *DMA_Type) SetOUTFIFO_STATUS_CH0_OUTFIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH0_OUTFIFO_FULL() uint32 {
	return volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg) & 0x1
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH0_OUTFIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH0_OUTFIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH0_OUTFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg)&^(0xfc)|value<<2)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH0_OUTFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg) & 0xfc) >> 2
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH0_OUT_REMAIN_UNDER_1B(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH0_OUT_REMAIN_UNDER_1B() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH0_OUT_REMAIN_UNDER_2B(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH0_OUT_REMAIN_UNDER_2B() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH0_OUT_REMAIN_UNDER_3B(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH0_OUT_REMAIN_UNDER_3B() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH0_OUT_REMAIN_UNDER_4B(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH0.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH0_OUT_REMAIN_UNDER_4B() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH0.Reg) & 0x4000000) >> 26
}

// DMA.OUT_PUSH_CH0: Push control register of Rx channel 0
func (o *DMA_Type) SetOUT_PUSH_CH0_OUTFIFO_WDATA(value uint32) {
	volatile.StoreUint32(&o.OUT_PUSH_CH0.Reg, volatile.LoadUint32(&o.OUT_PUSH_CH0.Reg)&^(0x1ff)|value)
}
func (o *DMA_Type) GetOUT_PUSH_CH0_OUTFIFO_WDATA() uint32 {
	return volatile.LoadUint32(&o.OUT_PUSH_CH0.Reg) & 0x1ff
}
func (o *DMA_Type) SetOUT_PUSH_CH0_OUTFIFO_PUSH(value uint32) {
	volatile.StoreUint32(&o.OUT_PUSH_CH0.Reg, volatile.LoadUint32(&o.OUT_PUSH_CH0.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetOUT_PUSH_CH0_OUTFIFO_PUSH() uint32 {
	return (volatile.LoadUint32(&o.OUT_PUSH_CH0.Reg) & 0x200) >> 9
}

// DMA.OUT_LINK_CH0: Link descriptor configure and control register of Tx channel 0
func (o *DMA_Type) SetOUT_LINK_CH0_OUTLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH0.Reg, volatile.LoadUint32(&o.OUT_LINK_CH0.Reg)&^(0xfffff)|value)
}
func (o *DMA_Type) GetOUT_LINK_CH0_OUTLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_LINK_CH0.Reg) & 0xfffff
}
func (o *DMA_Type) SetOUT_LINK_CH0_OUTLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH0.Reg, volatile.LoadUint32(&o.OUT_LINK_CH0.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetOUT_LINK_CH0_OUTLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK_CH0.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetOUT_LINK_CH0_OUTLINK_START(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH0.Reg, volatile.LoadUint32(&o.OUT_LINK_CH0.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetOUT_LINK_CH0_OUTLINK_START() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK_CH0.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetOUT_LINK_CH0_OUTLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH0.Reg, volatile.LoadUint32(&o.OUT_LINK_CH0.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetOUT_LINK_CH0_OUTLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK_CH0.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetOUT_LINK_CH0_OUTLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH0.Reg, volatile.LoadUint32(&o.OUT_LINK_CH0.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetOUT_LINK_CH0_OUTLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK_CH0.Reg) & 0x800000) >> 23
}

// DMA.OUT_STATE_CH0: Transmit status of Tx channel 0
func (o *DMA_Type) SetOUT_STATE_CH0_OUTLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_STATE_CH0.Reg, volatile.LoadUint32(&o.OUT_STATE_CH0.Reg)&^(0x3ffff)|value)
}
func (o *DMA_Type) GetOUT_STATE_CH0_OUTLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_STATE_CH0.Reg) & 0x3ffff
}
func (o *DMA_Type) SetOUT_STATE_CH0_OUT_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.OUT_STATE_CH0.Reg, volatile.LoadUint32(&o.OUT_STATE_CH0.Reg)&^(0xc0000)|value<<18)
}
func (o *DMA_Type) GetOUT_STATE_CH0_OUT_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.OUT_STATE_CH0.Reg) & 0xc0000) >> 18
}
func (o *DMA_Type) SetOUT_STATE_CH0_OUT_STATE(value uint32) {
	volatile.StoreUint32(&o.OUT_STATE_CH0.Reg, volatile.LoadUint32(&o.OUT_STATE_CH0.Reg)&^(0x700000)|value<<20)
}
func (o *DMA_Type) GetOUT_STATE_CH0_OUT_STATE() uint32 {
	return (volatile.LoadUint32(&o.OUT_STATE_CH0.Reg) & 0x700000) >> 20
}

// DMA.OUT_EOF_DES_ADDR_CH0: Outlink descriptor address when EOF occurs of Tx channel 0
func (o *DMA_Type) SetOUT_EOF_DES_ADDR_CH0(value uint32) {
	volatile.StoreUint32(&o.OUT_EOF_DES_ADDR_CH0.Reg, value)
}
func (o *DMA_Type) GetOUT_EOF_DES_ADDR_CH0() uint32 {
	return volatile.LoadUint32(&o.OUT_EOF_DES_ADDR_CH0.Reg)
}

// DMA.OUT_EOF_BFR_DES_ADDR_CH0: The last outlink descriptor address when EOF occurs of Tx channel 0
func (o *DMA_Type) SetOUT_EOF_BFR_DES_ADDR_CH0(value uint32) {
	volatile.StoreUint32(&o.OUT_EOF_BFR_DES_ADDR_CH0.Reg, value)
}
func (o *DMA_Type) GetOUT_EOF_BFR_DES_ADDR_CH0() uint32 {
	return volatile.LoadUint32(&o.OUT_EOF_BFR_DES_ADDR_CH0.Reg)
}

// DMA.OUT_DSCR_CH0: Current inlink descriptor address of Tx channel 0
func (o *DMA_Type) SetOUT_DSCR_CH0(value uint32) {
	volatile.StoreUint32(&o.OUT_DSCR_CH0.Reg, value)
}
func (o *DMA_Type) GetOUT_DSCR_CH0() uint32 {
	return volatile.LoadUint32(&o.OUT_DSCR_CH0.Reg)
}

// DMA.OUT_DSCR_BF0_CH0: The last inlink descriptor address of Tx channel 0
func (o *DMA_Type) SetOUT_DSCR_BF0_CH0(value uint32) {
	volatile.StoreUint32(&o.OUT_DSCR_BF0_CH0.Reg, value)
}
func (o *DMA_Type) GetOUT_DSCR_BF0_CH0() uint32 {
	return volatile.LoadUint32(&o.OUT_DSCR_BF0_CH0.Reg)
}

// DMA.OUT_DSCR_BF1_CH0: The second-to-last inlink descriptor address of Tx channel 0
func (o *DMA_Type) SetOUT_DSCR_BF1_CH0(value uint32) {
	volatile.StoreUint32(&o.OUT_DSCR_BF1_CH0.Reg, value)
}
func (o *DMA_Type) GetOUT_DSCR_BF1_CH0() uint32 {
	return volatile.LoadUint32(&o.OUT_DSCR_BF1_CH0.Reg)
}

// DMA.OUT_PRI_CH0: Priority register of Tx channel 0.
func (o *DMA_Type) SetOUT_PRI_CH0_TX_PRI(value uint32) {
	volatile.StoreUint32(&o.OUT_PRI_CH0.Reg, volatile.LoadUint32(&o.OUT_PRI_CH0.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetOUT_PRI_CH0_TX_PRI() uint32 {
	return volatile.LoadUint32(&o.OUT_PRI_CH0.Reg) & 0xf
}

// DMA.OUT_PERI_SEL_CH0: Peripheral selection of Tx channel 0
func (o *DMA_Type) SetOUT_PERI_SEL_CH0_PERI_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.OUT_PERI_SEL_CH0.Reg, volatile.LoadUint32(&o.OUT_PERI_SEL_CH0.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetOUT_PERI_SEL_CH0_PERI_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.OUT_PERI_SEL_CH0.Reg) & 0x3f
}

// DMA.IN_CONF0_CH1: Configure 0 register of Rx channel 0
func (o *DMA_Type) SetIN_CONF0_CH1_IN_RST(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH1.Reg, volatile.LoadUint32(&o.IN_CONF0_CH1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_CONF0_CH1_IN_RST() uint32 {
	return volatile.LoadUint32(&o.IN_CONF0_CH1.Reg) & 0x1
}
func (o *DMA_Type) SetIN_CONF0_CH1_IN_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH1.Reg, volatile.LoadUint32(&o.IN_CONF0_CH1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_CONF0_CH1_IN_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_CONF0_CH1_INDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH1.Reg, volatile.LoadUint32(&o.IN_CONF0_CH1.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_CONF0_CH1_INDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH1.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_CONF0_CH1_IN_DATA_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH1.Reg, volatile.LoadUint32(&o.IN_CONF0_CH1.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_CONF0_CH1_IN_DATA_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH1.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_CONF0_CH1_MEM_TRANS_EN(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH1.Reg, volatile.LoadUint32(&o.IN_CONF0_CH1.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_CONF0_CH1_MEM_TRANS_EN() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH1.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_CONF0_CH1_IN_ETM_EN(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH1.Reg, volatile.LoadUint32(&o.IN_CONF0_CH1.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_CONF0_CH1_IN_ETM_EN() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH1.Reg) & 0x20) >> 5
}

// DMA.IN_CONF1_CH1: Configure 1 register of Rx channel 0
func (o *DMA_Type) SetIN_CONF1_CH1_IN_CHECK_OWNER(value uint32) {
	volatile.StoreUint32(&o.IN_CONF1_CH1.Reg, volatile.LoadUint32(&o.IN_CONF1_CH1.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetIN_CONF1_CH1_IN_CHECK_OWNER() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF1_CH1.Reg) & 0x1000) >> 12
}

// DMA.INFIFO_STATUS_CH1: Receive FIFO status of Rx channel 0
func (o *DMA_Type) SetINFIFO_STATUS_CH1_INFIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH1_INFIFO_FULL() uint32 {
	return volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg) & 0x1
}
func (o *DMA_Type) SetINFIFO_STATUS_CH1_INFIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH1_INFIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetINFIFO_STATUS_CH1_INFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg)&^(0xfc)|value<<2)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH1_INFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg) & 0xfc) >> 2
}
func (o *DMA_Type) SetINFIFO_STATUS_CH1_IN_REMAIN_UNDER_1B(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH1_IN_REMAIN_UNDER_1B() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetINFIFO_STATUS_CH1_IN_REMAIN_UNDER_2B(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH1_IN_REMAIN_UNDER_2B() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetINFIFO_STATUS_CH1_IN_REMAIN_UNDER_3B(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH1_IN_REMAIN_UNDER_3B() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetINFIFO_STATUS_CH1_IN_REMAIN_UNDER_4B(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH1_IN_REMAIN_UNDER_4B() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetINFIFO_STATUS_CH1_IN_BUF_HUNGRY(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH1_IN_BUF_HUNGRY() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH1.Reg) & 0x8000000) >> 27
}

// DMA.IN_POP_CH1: Pop control register of Rx channel 0
func (o *DMA_Type) SetIN_POP_CH1_INFIFO_RDATA(value uint32) {
	volatile.StoreUint32(&o.IN_POP_CH1.Reg, volatile.LoadUint32(&o.IN_POP_CH1.Reg)&^(0xfff)|value)
}
func (o *DMA_Type) GetIN_POP_CH1_INFIFO_RDATA() uint32 {
	return volatile.LoadUint32(&o.IN_POP_CH1.Reg) & 0xfff
}
func (o *DMA_Type) SetIN_POP_CH1_INFIFO_POP(value uint32) {
	volatile.StoreUint32(&o.IN_POP_CH1.Reg, volatile.LoadUint32(&o.IN_POP_CH1.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetIN_POP_CH1_INFIFO_POP() uint32 {
	return (volatile.LoadUint32(&o.IN_POP_CH1.Reg) & 0x1000) >> 12
}

// DMA.IN_LINK_CH1: Link descriptor configure and control register of Rx channel 0
func (o *DMA_Type) SetIN_LINK_CH1_INLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH1.Reg, volatile.LoadUint32(&o.IN_LINK_CH1.Reg)&^(0xfffff)|value)
}
func (o *DMA_Type) GetIN_LINK_CH1_INLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.IN_LINK_CH1.Reg) & 0xfffff
}
func (o *DMA_Type) SetIN_LINK_CH1_INLINK_AUTO_RET(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH1.Reg, volatile.LoadUint32(&o.IN_LINK_CH1.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetIN_LINK_CH1_INLINK_AUTO_RET() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH1.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetIN_LINK_CH1_INLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH1.Reg, volatile.LoadUint32(&o.IN_LINK_CH1.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetIN_LINK_CH1_INLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH1.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetIN_LINK_CH1_INLINK_START(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH1.Reg, volatile.LoadUint32(&o.IN_LINK_CH1.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetIN_LINK_CH1_INLINK_START() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH1.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetIN_LINK_CH1_INLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH1.Reg, volatile.LoadUint32(&o.IN_LINK_CH1.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetIN_LINK_CH1_INLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH1.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetIN_LINK_CH1_INLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH1.Reg, volatile.LoadUint32(&o.IN_LINK_CH1.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetIN_LINK_CH1_INLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH1.Reg) & 0x1000000) >> 24
}

// DMA.IN_STATE_CH1: Receive status of Rx channel 0
func (o *DMA_Type) SetIN_STATE_CH1_INLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_STATE_CH1.Reg, volatile.LoadUint32(&o.IN_STATE_CH1.Reg)&^(0x3ffff)|value)
}
func (o *DMA_Type) GetIN_STATE_CH1_INLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.IN_STATE_CH1.Reg) & 0x3ffff
}
func (o *DMA_Type) SetIN_STATE_CH1_IN_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.IN_STATE_CH1.Reg, volatile.LoadUint32(&o.IN_STATE_CH1.Reg)&^(0xc0000)|value<<18)
}
func (o *DMA_Type) GetIN_STATE_CH1_IN_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.IN_STATE_CH1.Reg) & 0xc0000) >> 18
}
func (o *DMA_Type) SetIN_STATE_CH1_IN_STATE(value uint32) {
	volatile.StoreUint32(&o.IN_STATE_CH1.Reg, volatile.LoadUint32(&o.IN_STATE_CH1.Reg)&^(0x700000)|value<<20)
}
func (o *DMA_Type) GetIN_STATE_CH1_IN_STATE() uint32 {
	return (volatile.LoadUint32(&o.IN_STATE_CH1.Reg) & 0x700000) >> 20
}

// DMA.IN_SUC_EOF_DES_ADDR_CH1: Inlink descriptor address when EOF occurs of Rx channel 0
func (o *DMA_Type) SetIN_SUC_EOF_DES_ADDR_CH1(value uint32) {
	volatile.StoreUint32(&o.IN_SUC_EOF_DES_ADDR_CH1.Reg, value)
}
func (o *DMA_Type) GetIN_SUC_EOF_DES_ADDR_CH1() uint32 {
	return volatile.LoadUint32(&o.IN_SUC_EOF_DES_ADDR_CH1.Reg)
}

// DMA.IN_ERR_EOF_DES_ADDR_CH1: Inlink descriptor address when errors occur of Rx channel 0
func (o *DMA_Type) SetIN_ERR_EOF_DES_ADDR_CH1(value uint32) {
	volatile.StoreUint32(&o.IN_ERR_EOF_DES_ADDR_CH1.Reg, value)
}
func (o *DMA_Type) GetIN_ERR_EOF_DES_ADDR_CH1() uint32 {
	return volatile.LoadUint32(&o.IN_ERR_EOF_DES_ADDR_CH1.Reg)
}

// DMA.IN_DSCR_CH1: Current inlink descriptor address of Rx channel 0
func (o *DMA_Type) SetIN_DSCR_CH1(value uint32) {
	volatile.StoreUint32(&o.IN_DSCR_CH1.Reg, value)
}
func (o *DMA_Type) GetIN_DSCR_CH1() uint32 {
	return volatile.LoadUint32(&o.IN_DSCR_CH1.Reg)
}

// DMA.IN_DSCR_BF0_CH1: The last inlink descriptor address of Rx channel 0
func (o *DMA_Type) SetIN_DSCR_BF0_CH1(value uint32) {
	volatile.StoreUint32(&o.IN_DSCR_BF0_CH1.Reg, value)
}
func (o *DMA_Type) GetIN_DSCR_BF0_CH1() uint32 {
	return volatile.LoadUint32(&o.IN_DSCR_BF0_CH1.Reg)
}

// DMA.IN_DSCR_BF1_CH1: The second-to-last inlink descriptor address of Rx channel 0
func (o *DMA_Type) SetIN_DSCR_BF1_CH1(value uint32) {
	volatile.StoreUint32(&o.IN_DSCR_BF1_CH1.Reg, value)
}
func (o *DMA_Type) GetIN_DSCR_BF1_CH1() uint32 {
	return volatile.LoadUint32(&o.IN_DSCR_BF1_CH1.Reg)
}

// DMA.IN_PRI_CH1: Priority register of Rx channel 0
func (o *DMA_Type) SetIN_PRI_CH1_RX_PRI(value uint32) {
	volatile.StoreUint32(&o.IN_PRI_CH1.Reg, volatile.LoadUint32(&o.IN_PRI_CH1.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetIN_PRI_CH1_RX_PRI() uint32 {
	return volatile.LoadUint32(&o.IN_PRI_CH1.Reg) & 0xf
}

// DMA.IN_PERI_SEL_CH1: Peripheral selection of Rx channel 0
func (o *DMA_Type) SetIN_PERI_SEL_CH1_PERI_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.IN_PERI_SEL_CH1.Reg, volatile.LoadUint32(&o.IN_PERI_SEL_CH1.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetIN_PERI_SEL_CH1_PERI_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.IN_PERI_SEL_CH1.Reg) & 0x3f
}

// DMA.OUT_CONF0_CH0: Configure 0 register of Tx channel 1
func (o *DMA_Type) SetOUT_CONF0_CH0_OUT_RST(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH0.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_CONF0_CH0_OUT_RST() uint32 {
	return volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_CONF0_CH0_OUT_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH0.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_CONF0_CH0_OUT_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_CONF0_CH0_OUT_AUTO_WRBACK(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH0.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_CONF0_CH0_OUT_AUTO_WRBACK() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_CONF0_CH0_OUT_EOF_MODE(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH0.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_CONF0_CH0_OUT_EOF_MODE() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_CONF0_CH0_OUTDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH0.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_CONF0_CH0_OUTDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_CONF0_CH0_OUT_DATA_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH0.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_CONF0_CH0_OUT_DATA_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetOUT_CONF0_CH0_OUT_ETM_EN(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH0.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetOUT_CONF0_CH0_OUT_ETM_EN() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH0.Reg) & 0x40) >> 6
}

// DMA.OUT_CONF1_CH1: Configure 1 register of Tx channel 0
func (o *DMA_Type) SetOUT_CONF1_CH1_OUT_CHECK_OWNER(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF1_CH1.Reg, volatile.LoadUint32(&o.OUT_CONF1_CH1.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetOUT_CONF1_CH1_OUT_CHECK_OWNER() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF1_CH1.Reg) & 0x1000) >> 12
}

// DMA.OUTFIFO_STATUS_CH1: Transmit FIFO status of Tx channel 0
func (o *DMA_Type) SetOUTFIFO_STATUS_CH1_OUTFIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH1_OUTFIFO_FULL() uint32 {
	return volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg) & 0x1
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH1_OUTFIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH1_OUTFIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH1_OUTFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg)&^(0xfc)|value<<2)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH1_OUTFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg) & 0xfc) >> 2
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH1_OUT_REMAIN_UNDER_1B(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH1_OUT_REMAIN_UNDER_1B() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH1_OUT_REMAIN_UNDER_2B(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH1_OUT_REMAIN_UNDER_2B() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH1_OUT_REMAIN_UNDER_3B(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH1_OUT_REMAIN_UNDER_3B() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH1_OUT_REMAIN_UNDER_4B(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH1.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH1_OUT_REMAIN_UNDER_4B() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH1.Reg) & 0x4000000) >> 26
}

// DMA.OUT_PUSH_CH1: Push control register of Rx channel 0
func (o *DMA_Type) SetOUT_PUSH_CH1_OUTFIFO_WDATA(value uint32) {
	volatile.StoreUint32(&o.OUT_PUSH_CH1.Reg, volatile.LoadUint32(&o.OUT_PUSH_CH1.Reg)&^(0x1ff)|value)
}
func (o *DMA_Type) GetOUT_PUSH_CH1_OUTFIFO_WDATA() uint32 {
	return volatile.LoadUint32(&o.OUT_PUSH_CH1.Reg) & 0x1ff
}
func (o *DMA_Type) SetOUT_PUSH_CH1_OUTFIFO_PUSH(value uint32) {
	volatile.StoreUint32(&o.OUT_PUSH_CH1.Reg, volatile.LoadUint32(&o.OUT_PUSH_CH1.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetOUT_PUSH_CH1_OUTFIFO_PUSH() uint32 {
	return (volatile.LoadUint32(&o.OUT_PUSH_CH1.Reg) & 0x200) >> 9
}

// DMA.OUT_LINK_CH1: Link descriptor configure and control register of Tx channel 0
func (o *DMA_Type) SetOUT_LINK_CH1_OUTLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH1.Reg, volatile.LoadUint32(&o.OUT_LINK_CH1.Reg)&^(0xfffff)|value)
}
func (o *DMA_Type) GetOUT_LINK_CH1_OUTLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_LINK_CH1.Reg) & 0xfffff
}
func (o *DMA_Type) SetOUT_LINK_CH1_OUTLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH1.Reg, volatile.LoadUint32(&o.OUT_LINK_CH1.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetOUT_LINK_CH1_OUTLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK_CH1.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetOUT_LINK_CH1_OUTLINK_START(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH1.Reg, volatile.LoadUint32(&o.OUT_LINK_CH1.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetOUT_LINK_CH1_OUTLINK_START() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK_CH1.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetOUT_LINK_CH1_OUTLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH1.Reg, volatile.LoadUint32(&o.OUT_LINK_CH1.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetOUT_LINK_CH1_OUTLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK_CH1.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetOUT_LINK_CH1_OUTLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH1.Reg, volatile.LoadUint32(&o.OUT_LINK_CH1.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetOUT_LINK_CH1_OUTLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK_CH1.Reg) & 0x800000) >> 23
}

// DMA.OUT_STATE_CH1: Transmit status of Tx channel 0
func (o *DMA_Type) SetOUT_STATE_CH1_OUTLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_STATE_CH1.Reg, volatile.LoadUint32(&o.OUT_STATE_CH1.Reg)&^(0x3ffff)|value)
}
func (o *DMA_Type) GetOUT_STATE_CH1_OUTLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_STATE_CH1.Reg) & 0x3ffff
}
func (o *DMA_Type) SetOUT_STATE_CH1_OUT_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.OUT_STATE_CH1.Reg, volatile.LoadUint32(&o.OUT_STATE_CH1.Reg)&^(0xc0000)|value<<18)
}
func (o *DMA_Type) GetOUT_STATE_CH1_OUT_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.OUT_STATE_CH1.Reg) & 0xc0000) >> 18
}
func (o *DMA_Type) SetOUT_STATE_CH1_OUT_STATE(value uint32) {
	volatile.StoreUint32(&o.OUT_STATE_CH1.Reg, volatile.LoadUint32(&o.OUT_STATE_CH1.Reg)&^(0x700000)|value<<20)
}
func (o *DMA_Type) GetOUT_STATE_CH1_OUT_STATE() uint32 {
	return (volatile.LoadUint32(&o.OUT_STATE_CH1.Reg) & 0x700000) >> 20
}

// DMA.OUT_EOF_DES_ADDR_CH1: Outlink descriptor address when EOF occurs of Tx channel 0
func (o *DMA_Type) SetOUT_EOF_DES_ADDR_CH1(value uint32) {
	volatile.StoreUint32(&o.OUT_EOF_DES_ADDR_CH1.Reg, value)
}
func (o *DMA_Type) GetOUT_EOF_DES_ADDR_CH1() uint32 {
	return volatile.LoadUint32(&o.OUT_EOF_DES_ADDR_CH1.Reg)
}

// DMA.OUT_EOF_BFR_DES_ADDR_CH1: The last outlink descriptor address when EOF occurs of Tx channel 0
func (o *DMA_Type) SetOUT_EOF_BFR_DES_ADDR_CH1(value uint32) {
	volatile.StoreUint32(&o.OUT_EOF_BFR_DES_ADDR_CH1.Reg, value)
}
func (o *DMA_Type) GetOUT_EOF_BFR_DES_ADDR_CH1() uint32 {
	return volatile.LoadUint32(&o.OUT_EOF_BFR_DES_ADDR_CH1.Reg)
}

// DMA.OUT_DSCR_CH1: Current inlink descriptor address of Tx channel 0
func (o *DMA_Type) SetOUT_DSCR_CH1(value uint32) {
	volatile.StoreUint32(&o.OUT_DSCR_CH1.Reg, value)
}
func (o *DMA_Type) GetOUT_DSCR_CH1() uint32 {
	return volatile.LoadUint32(&o.OUT_DSCR_CH1.Reg)
}

// DMA.OUT_DSCR_BF0_CH1: The last inlink descriptor address of Tx channel 0
func (o *DMA_Type) SetOUT_DSCR_BF0_CH1(value uint32) {
	volatile.StoreUint32(&o.OUT_DSCR_BF0_CH1.Reg, value)
}
func (o *DMA_Type) GetOUT_DSCR_BF0_CH1() uint32 {
	return volatile.LoadUint32(&o.OUT_DSCR_BF0_CH1.Reg)
}

// DMA.OUT_DSCR_BF1_CH1: The second-to-last inlink descriptor address of Tx channel 0
func (o *DMA_Type) SetOUT_DSCR_BF1_CH1(value uint32) {
	volatile.StoreUint32(&o.OUT_DSCR_BF1_CH1.Reg, value)
}
func (o *DMA_Type) GetOUT_DSCR_BF1_CH1() uint32 {
	return volatile.LoadUint32(&o.OUT_DSCR_BF1_CH1.Reg)
}

// DMA.OUT_PRI_CH1: Priority register of Tx channel 0.
func (o *DMA_Type) SetOUT_PRI_CH1_TX_PRI(value uint32) {
	volatile.StoreUint32(&o.OUT_PRI_CH1.Reg, volatile.LoadUint32(&o.OUT_PRI_CH1.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetOUT_PRI_CH1_TX_PRI() uint32 {
	return volatile.LoadUint32(&o.OUT_PRI_CH1.Reg) & 0xf
}

// DMA.OUT_PERI_SEL_CH1: Peripheral selection of Tx channel 0
func (o *DMA_Type) SetOUT_PERI_SEL_CH1_PERI_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.OUT_PERI_SEL_CH1.Reg, volatile.LoadUint32(&o.OUT_PERI_SEL_CH1.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetOUT_PERI_SEL_CH1_PERI_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.OUT_PERI_SEL_CH1.Reg) & 0x3f
}

// DMA.IN_CONF0_CH2: Configure 0 register of Rx channel 0
func (o *DMA_Type) SetIN_CONF0_CH2_IN_RST(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH2.Reg, volatile.LoadUint32(&o.IN_CONF0_CH2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIN_CONF0_CH2_IN_RST() uint32 {
	return volatile.LoadUint32(&o.IN_CONF0_CH2.Reg) & 0x1
}
func (o *DMA_Type) SetIN_CONF0_CH2_IN_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH2.Reg, volatile.LoadUint32(&o.IN_CONF0_CH2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIN_CONF0_CH2_IN_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIN_CONF0_CH2_INDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH2.Reg, volatile.LoadUint32(&o.IN_CONF0_CH2.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIN_CONF0_CH2_INDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH2.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIN_CONF0_CH2_IN_DATA_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH2.Reg, volatile.LoadUint32(&o.IN_CONF0_CH2.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIN_CONF0_CH2_IN_DATA_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH2.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIN_CONF0_CH2_MEM_TRANS_EN(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH2.Reg, volatile.LoadUint32(&o.IN_CONF0_CH2.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIN_CONF0_CH2_MEM_TRANS_EN() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH2.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIN_CONF0_CH2_IN_ETM_EN(value uint32) {
	volatile.StoreUint32(&o.IN_CONF0_CH2.Reg, volatile.LoadUint32(&o.IN_CONF0_CH2.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIN_CONF0_CH2_IN_ETM_EN() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF0_CH2.Reg) & 0x20) >> 5
}

// DMA.IN_CONF1_CH2: Configure 1 register of Rx channel 0
func (o *DMA_Type) SetIN_CONF1_CH2_IN_CHECK_OWNER(value uint32) {
	volatile.StoreUint32(&o.IN_CONF1_CH2.Reg, volatile.LoadUint32(&o.IN_CONF1_CH2.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetIN_CONF1_CH2_IN_CHECK_OWNER() uint32 {
	return (volatile.LoadUint32(&o.IN_CONF1_CH2.Reg) & 0x1000) >> 12
}

// DMA.INFIFO_STATUS_CH2: Receive FIFO status of Rx channel 0
func (o *DMA_Type) SetINFIFO_STATUS_CH2_INFIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH2_INFIFO_FULL() uint32 {
	return volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg) & 0x1
}
func (o *DMA_Type) SetINFIFO_STATUS_CH2_INFIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH2_INFIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetINFIFO_STATUS_CH2_INFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg)&^(0xfc)|value<<2)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH2_INFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg) & 0xfc) >> 2
}
func (o *DMA_Type) SetINFIFO_STATUS_CH2_IN_REMAIN_UNDER_1B(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH2_IN_REMAIN_UNDER_1B() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetINFIFO_STATUS_CH2_IN_REMAIN_UNDER_2B(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH2_IN_REMAIN_UNDER_2B() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetINFIFO_STATUS_CH2_IN_REMAIN_UNDER_3B(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH2_IN_REMAIN_UNDER_3B() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetINFIFO_STATUS_CH2_IN_REMAIN_UNDER_4B(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH2_IN_REMAIN_UNDER_4B() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetINFIFO_STATUS_CH2_IN_BUF_HUNGRY(value uint32) {
	volatile.StoreUint32(&o.INFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetINFIFO_STATUS_CH2_IN_BUF_HUNGRY() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_STATUS_CH2.Reg) & 0x8000000) >> 27
}

// DMA.IN_POP_CH2: Pop control register of Rx channel 0
func (o *DMA_Type) SetIN_POP_CH2_INFIFO_RDATA(value uint32) {
	volatile.StoreUint32(&o.IN_POP_CH2.Reg, volatile.LoadUint32(&o.IN_POP_CH2.Reg)&^(0xfff)|value)
}
func (o *DMA_Type) GetIN_POP_CH2_INFIFO_RDATA() uint32 {
	return volatile.LoadUint32(&o.IN_POP_CH2.Reg) & 0xfff
}
func (o *DMA_Type) SetIN_POP_CH2_INFIFO_POP(value uint32) {
	volatile.StoreUint32(&o.IN_POP_CH2.Reg, volatile.LoadUint32(&o.IN_POP_CH2.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetIN_POP_CH2_INFIFO_POP() uint32 {
	return (volatile.LoadUint32(&o.IN_POP_CH2.Reg) & 0x1000) >> 12
}

// DMA.IN_LINK_CH2: Link descriptor configure and control register of Rx channel 0
func (o *DMA_Type) SetIN_LINK_CH2_INLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH2.Reg, volatile.LoadUint32(&o.IN_LINK_CH2.Reg)&^(0xfffff)|value)
}
func (o *DMA_Type) GetIN_LINK_CH2_INLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.IN_LINK_CH2.Reg) & 0xfffff
}
func (o *DMA_Type) SetIN_LINK_CH2_INLINK_AUTO_RET(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH2.Reg, volatile.LoadUint32(&o.IN_LINK_CH2.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetIN_LINK_CH2_INLINK_AUTO_RET() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH2.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetIN_LINK_CH2_INLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH2.Reg, volatile.LoadUint32(&o.IN_LINK_CH2.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetIN_LINK_CH2_INLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH2.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetIN_LINK_CH2_INLINK_START(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH2.Reg, volatile.LoadUint32(&o.IN_LINK_CH2.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetIN_LINK_CH2_INLINK_START() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH2.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetIN_LINK_CH2_INLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH2.Reg, volatile.LoadUint32(&o.IN_LINK_CH2.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetIN_LINK_CH2_INLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH2.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetIN_LINK_CH2_INLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.IN_LINK_CH2.Reg, volatile.LoadUint32(&o.IN_LINK_CH2.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetIN_LINK_CH2_INLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK_CH2.Reg) & 0x1000000) >> 24
}

// DMA.IN_STATE_CH2: Receive status of Rx channel 0
func (o *DMA_Type) SetIN_STATE_CH2_INLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_STATE_CH2.Reg, volatile.LoadUint32(&o.IN_STATE_CH2.Reg)&^(0x3ffff)|value)
}
func (o *DMA_Type) GetIN_STATE_CH2_INLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.IN_STATE_CH2.Reg) & 0x3ffff
}
func (o *DMA_Type) SetIN_STATE_CH2_IN_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.IN_STATE_CH2.Reg, volatile.LoadUint32(&o.IN_STATE_CH2.Reg)&^(0xc0000)|value<<18)
}
func (o *DMA_Type) GetIN_STATE_CH2_IN_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.IN_STATE_CH2.Reg) & 0xc0000) >> 18
}
func (o *DMA_Type) SetIN_STATE_CH2_IN_STATE(value uint32) {
	volatile.StoreUint32(&o.IN_STATE_CH2.Reg, volatile.LoadUint32(&o.IN_STATE_CH2.Reg)&^(0x700000)|value<<20)
}
func (o *DMA_Type) GetIN_STATE_CH2_IN_STATE() uint32 {
	return (volatile.LoadUint32(&o.IN_STATE_CH2.Reg) & 0x700000) >> 20
}

// DMA.IN_SUC_EOF_DES_ADDR_CH2: Inlink descriptor address when EOF occurs of Rx channel 0
func (o *DMA_Type) SetIN_SUC_EOF_DES_ADDR_CH2(value uint32) {
	volatile.StoreUint32(&o.IN_SUC_EOF_DES_ADDR_CH2.Reg, value)
}
func (o *DMA_Type) GetIN_SUC_EOF_DES_ADDR_CH2() uint32 {
	return volatile.LoadUint32(&o.IN_SUC_EOF_DES_ADDR_CH2.Reg)
}

// DMA.IN_ERR_EOF_DES_ADDR_CH2: Inlink descriptor address when errors occur of Rx channel 0
func (o *DMA_Type) SetIN_ERR_EOF_DES_ADDR_CH2(value uint32) {
	volatile.StoreUint32(&o.IN_ERR_EOF_DES_ADDR_CH2.Reg, value)
}
func (o *DMA_Type) GetIN_ERR_EOF_DES_ADDR_CH2() uint32 {
	return volatile.LoadUint32(&o.IN_ERR_EOF_DES_ADDR_CH2.Reg)
}

// DMA.IN_DSCR_CH2: Current inlink descriptor address of Rx channel 0
func (o *DMA_Type) SetIN_DSCR_CH2(value uint32) {
	volatile.StoreUint32(&o.IN_DSCR_CH2.Reg, value)
}
func (o *DMA_Type) GetIN_DSCR_CH2() uint32 {
	return volatile.LoadUint32(&o.IN_DSCR_CH2.Reg)
}

// DMA.IN_DSCR_BF0_CH2: The last inlink descriptor address of Rx channel 0
func (o *DMA_Type) SetIN_DSCR_BF0_CH2(value uint32) {
	volatile.StoreUint32(&o.IN_DSCR_BF0_CH2.Reg, value)
}
func (o *DMA_Type) GetIN_DSCR_BF0_CH2() uint32 {
	return volatile.LoadUint32(&o.IN_DSCR_BF0_CH2.Reg)
}

// DMA.IN_DSCR_BF1_CH2: The second-to-last inlink descriptor address of Rx channel 0
func (o *DMA_Type) SetIN_DSCR_BF1_CH2(value uint32) {
	volatile.StoreUint32(&o.IN_DSCR_BF1_CH2.Reg, value)
}
func (o *DMA_Type) GetIN_DSCR_BF1_CH2() uint32 {
	return volatile.LoadUint32(&o.IN_DSCR_BF1_CH2.Reg)
}

// DMA.IN_PRI_CH2: Priority register of Rx channel 0
func (o *DMA_Type) SetIN_PRI_CH2_RX_PRI(value uint32) {
	volatile.StoreUint32(&o.IN_PRI_CH2.Reg, volatile.LoadUint32(&o.IN_PRI_CH2.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetIN_PRI_CH2_RX_PRI() uint32 {
	return volatile.LoadUint32(&o.IN_PRI_CH2.Reg) & 0xf
}

// DMA.IN_PERI_SEL_CH2: Peripheral selection of Rx channel 0
func (o *DMA_Type) SetIN_PERI_SEL_CH2_PERI_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.IN_PERI_SEL_CH2.Reg, volatile.LoadUint32(&o.IN_PERI_SEL_CH2.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetIN_PERI_SEL_CH2_PERI_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.IN_PERI_SEL_CH2.Reg) & 0x3f
}

// DMA.OUT_CONF0_CH1: Configure 0 register of Tx channel 1
func (o *DMA_Type) SetOUT_CONF0_CH1_OUT_RST(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH1.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_CONF0_CH1_OUT_RST() uint32 {
	return volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_CONF0_CH1_OUT_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH1.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_CONF0_CH1_OUT_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_CONF0_CH1_OUT_AUTO_WRBACK(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH1.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_CONF0_CH1_OUT_AUTO_WRBACK() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_CONF0_CH1_OUT_EOF_MODE(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH1.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_CONF0_CH1_OUT_EOF_MODE() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_CONF0_CH1_OUTDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH1.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_CONF0_CH1_OUTDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_CONF0_CH1_OUT_DATA_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH1.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_CONF0_CH1_OUT_DATA_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetOUT_CONF0_CH1_OUT_ETM_EN(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH1.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetOUT_CONF0_CH1_OUT_ETM_EN() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH1.Reg) & 0x40) >> 6
}

// DMA.OUT_CONF1_CH2: Configure 1 register of Tx channel 0
func (o *DMA_Type) SetOUT_CONF1_CH2_OUT_CHECK_OWNER(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF1_CH2.Reg, volatile.LoadUint32(&o.OUT_CONF1_CH2.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetOUT_CONF1_CH2_OUT_CHECK_OWNER() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF1_CH2.Reg) & 0x1000) >> 12
}

// DMA.OUTFIFO_STATUS_CH2: Transmit FIFO status of Tx channel 0
func (o *DMA_Type) SetOUTFIFO_STATUS_CH2_OUTFIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH2_OUTFIFO_FULL() uint32 {
	return volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg) & 0x1
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH2_OUTFIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH2_OUTFIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH2_OUTFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg)&^(0xfc)|value<<2)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH2_OUTFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg) & 0xfc) >> 2
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH2_OUT_REMAIN_UNDER_1B(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH2_OUT_REMAIN_UNDER_1B() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH2_OUT_REMAIN_UNDER_2B(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH2_OUT_REMAIN_UNDER_2B() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH2_OUT_REMAIN_UNDER_3B(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH2_OUT_REMAIN_UNDER_3B() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetOUTFIFO_STATUS_CH2_OUT_REMAIN_UNDER_4B(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_STATUS_CH2.Reg, volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetOUTFIFO_STATUS_CH2_OUT_REMAIN_UNDER_4B() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_STATUS_CH2.Reg) & 0x4000000) >> 26
}

// DMA.OUT_PUSH_CH2: Push control register of Rx channel 0
func (o *DMA_Type) SetOUT_PUSH_CH2_OUTFIFO_WDATA(value uint32) {
	volatile.StoreUint32(&o.OUT_PUSH_CH2.Reg, volatile.LoadUint32(&o.OUT_PUSH_CH2.Reg)&^(0x1ff)|value)
}
func (o *DMA_Type) GetOUT_PUSH_CH2_OUTFIFO_WDATA() uint32 {
	return volatile.LoadUint32(&o.OUT_PUSH_CH2.Reg) & 0x1ff
}
func (o *DMA_Type) SetOUT_PUSH_CH2_OUTFIFO_PUSH(value uint32) {
	volatile.StoreUint32(&o.OUT_PUSH_CH2.Reg, volatile.LoadUint32(&o.OUT_PUSH_CH2.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetOUT_PUSH_CH2_OUTFIFO_PUSH() uint32 {
	return (volatile.LoadUint32(&o.OUT_PUSH_CH2.Reg) & 0x200) >> 9
}

// DMA.OUT_LINK_CH2: Link descriptor configure and control register of Tx channel 0
func (o *DMA_Type) SetOUT_LINK_CH2_OUTLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH2.Reg, volatile.LoadUint32(&o.OUT_LINK_CH2.Reg)&^(0xfffff)|value)
}
func (o *DMA_Type) GetOUT_LINK_CH2_OUTLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_LINK_CH2.Reg) & 0xfffff
}
func (o *DMA_Type) SetOUT_LINK_CH2_OUTLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH2.Reg, volatile.LoadUint32(&o.OUT_LINK_CH2.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetOUT_LINK_CH2_OUTLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK_CH2.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetOUT_LINK_CH2_OUTLINK_START(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH2.Reg, volatile.LoadUint32(&o.OUT_LINK_CH2.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetOUT_LINK_CH2_OUTLINK_START() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK_CH2.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetOUT_LINK_CH2_OUTLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH2.Reg, volatile.LoadUint32(&o.OUT_LINK_CH2.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetOUT_LINK_CH2_OUTLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK_CH2.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetOUT_LINK_CH2_OUTLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK_CH2.Reg, volatile.LoadUint32(&o.OUT_LINK_CH2.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetOUT_LINK_CH2_OUTLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK_CH2.Reg) & 0x800000) >> 23
}

// DMA.OUT_STATE_CH2: Transmit status of Tx channel 0
func (o *DMA_Type) SetOUT_STATE_CH2_OUTLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_STATE_CH2.Reg, volatile.LoadUint32(&o.OUT_STATE_CH2.Reg)&^(0x3ffff)|value)
}
func (o *DMA_Type) GetOUT_STATE_CH2_OUTLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_STATE_CH2.Reg) & 0x3ffff
}
func (o *DMA_Type) SetOUT_STATE_CH2_OUT_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.OUT_STATE_CH2.Reg, volatile.LoadUint32(&o.OUT_STATE_CH2.Reg)&^(0xc0000)|value<<18)
}
func (o *DMA_Type) GetOUT_STATE_CH2_OUT_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.OUT_STATE_CH2.Reg) & 0xc0000) >> 18
}
func (o *DMA_Type) SetOUT_STATE_CH2_OUT_STATE(value uint32) {
	volatile.StoreUint32(&o.OUT_STATE_CH2.Reg, volatile.LoadUint32(&o.OUT_STATE_CH2.Reg)&^(0x700000)|value<<20)
}
func (o *DMA_Type) GetOUT_STATE_CH2_OUT_STATE() uint32 {
	return (volatile.LoadUint32(&o.OUT_STATE_CH2.Reg) & 0x700000) >> 20
}

// DMA.OUT_EOF_DES_ADDR_CH2: Outlink descriptor address when EOF occurs of Tx channel 0
func (o *DMA_Type) SetOUT_EOF_DES_ADDR_CH2(value uint32) {
	volatile.StoreUint32(&o.OUT_EOF_DES_ADDR_CH2.Reg, value)
}
func (o *DMA_Type) GetOUT_EOF_DES_ADDR_CH2() uint32 {
	return volatile.LoadUint32(&o.OUT_EOF_DES_ADDR_CH2.Reg)
}

// DMA.OUT_EOF_BFR_DES_ADDR_CH2: The last outlink descriptor address when EOF occurs of Tx channel 0
func (o *DMA_Type) SetOUT_EOF_BFR_DES_ADDR_CH2(value uint32) {
	volatile.StoreUint32(&o.OUT_EOF_BFR_DES_ADDR_CH2.Reg, value)
}
func (o *DMA_Type) GetOUT_EOF_BFR_DES_ADDR_CH2() uint32 {
	return volatile.LoadUint32(&o.OUT_EOF_BFR_DES_ADDR_CH2.Reg)
}

// DMA.OUT_DSCR_CH2: Current inlink descriptor address of Tx channel 0
func (o *DMA_Type) SetOUT_DSCR_CH2(value uint32) {
	volatile.StoreUint32(&o.OUT_DSCR_CH2.Reg, value)
}
func (o *DMA_Type) GetOUT_DSCR_CH2() uint32 {
	return volatile.LoadUint32(&o.OUT_DSCR_CH2.Reg)
}

// DMA.OUT_DSCR_BF0_CH2: The last inlink descriptor address of Tx channel 0
func (o *DMA_Type) SetOUT_DSCR_BF0_CH2(value uint32) {
	volatile.StoreUint32(&o.OUT_DSCR_BF0_CH2.Reg, value)
}
func (o *DMA_Type) GetOUT_DSCR_BF0_CH2() uint32 {
	return volatile.LoadUint32(&o.OUT_DSCR_BF0_CH2.Reg)
}

// DMA.OUT_DSCR_BF1_CH2: The second-to-last inlink descriptor address of Tx channel 0
func (o *DMA_Type) SetOUT_DSCR_BF1_CH2(value uint32) {
	volatile.StoreUint32(&o.OUT_DSCR_BF1_CH2.Reg, value)
}
func (o *DMA_Type) GetOUT_DSCR_BF1_CH2() uint32 {
	return volatile.LoadUint32(&o.OUT_DSCR_BF1_CH2.Reg)
}

// DMA.OUT_PRI_CH2: Priority register of Tx channel 0.
func (o *DMA_Type) SetOUT_PRI_CH2_TX_PRI(value uint32) {
	volatile.StoreUint32(&o.OUT_PRI_CH2.Reg, volatile.LoadUint32(&o.OUT_PRI_CH2.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetOUT_PRI_CH2_TX_PRI() uint32 {
	return volatile.LoadUint32(&o.OUT_PRI_CH2.Reg) & 0xf
}

// DMA.OUT_PERI_SEL_CH2: Peripheral selection of Tx channel 0
func (o *DMA_Type) SetOUT_PERI_SEL_CH2_PERI_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.OUT_PERI_SEL_CH2.Reg, volatile.LoadUint32(&o.OUT_PERI_SEL_CH2.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetOUT_PERI_SEL_CH2_PERI_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.OUT_PERI_SEL_CH2.Reg) & 0x3f
}

// DMA.OUT_CONF0_CH2: Configure 0 register of Tx channel 1
func (o *DMA_Type) SetOUT_CONF0_CH2_OUT_RST(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH2.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetOUT_CONF0_CH2_OUT_RST() uint32 {
	return volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg) & 0x1
}
func (o *DMA_Type) SetOUT_CONF0_CH2_OUT_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH2.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetOUT_CONF0_CH2_OUT_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetOUT_CONF0_CH2_OUT_AUTO_WRBACK(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH2.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetOUT_CONF0_CH2_OUT_AUTO_WRBACK() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetOUT_CONF0_CH2_OUT_EOF_MODE(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH2.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetOUT_CONF0_CH2_OUT_EOF_MODE() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetOUT_CONF0_CH2_OUTDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH2.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetOUT_CONF0_CH2_OUTDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetOUT_CONF0_CH2_OUT_DATA_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH2.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetOUT_CONF0_CH2_OUT_DATA_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetOUT_CONF0_CH2_OUT_ETM_EN(value uint32) {
	volatile.StoreUint32(&o.OUT_CONF0_CH2.Reg, volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetOUT_CONF0_CH2_OUT_ETM_EN() uint32 {
	return (volatile.LoadUint32(&o.OUT_CONF0_CH2.Reg) & 0x40) >> 6
}

// Digital Signature
type DS_Type struct {
	Y_MEM           [512]volatile.Register8 // 0x0
	M_MEM           [512]volatile.Register8 // 0x200
	RB_MEM          [512]volatile.Register8 // 0x400
	BOX_MEM         [48]volatile.Register8  // 0x600
	IV_MEM          [16]volatile.Register8  // 0x630
	_               [448]byte
	X_MEM           [512]volatile.Register8 // 0x800
	Z_MEM           [512]volatile.Register8 // 0xA00
	_               [512]byte
	SET_START       volatile.Register32 // 0xE00
	SET_CONTINUE    volatile.Register32 // 0xE04
	SET_FINISH      volatile.Register32 // 0xE08
	QUERY_BUSY      volatile.Register32 // 0xE0C
	QUERY_KEY_WRONG volatile.Register32 // 0xE10
	QUERY_CHECK     volatile.Register32 // 0xE14
	_               [8]byte
	DATE            volatile.Register32 // 0xE20
}

// DS.SET_START: DS start control register
func (o *DS_Type) SetSET_START(value uint32) {
	volatile.StoreUint32(&o.SET_START.Reg, volatile.LoadUint32(&o.SET_START.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetSET_START() uint32 {
	return volatile.LoadUint32(&o.SET_START.Reg) & 0x1
}

// DS.SET_CONTINUE: DS continue control register
func (o *DS_Type) SetSET_CONTINUE(value uint32) {
	volatile.StoreUint32(&o.SET_CONTINUE.Reg, volatile.LoadUint32(&o.SET_CONTINUE.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetSET_CONTINUE() uint32 {
	return volatile.LoadUint32(&o.SET_CONTINUE.Reg) & 0x1
}

// DS.SET_FINISH: DS finish control register
func (o *DS_Type) SetSET_FINISH(value uint32) {
	volatile.StoreUint32(&o.SET_FINISH.Reg, volatile.LoadUint32(&o.SET_FINISH.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetSET_FINISH() uint32 {
	return volatile.LoadUint32(&o.SET_FINISH.Reg) & 0x1
}

// DS.QUERY_BUSY: DS query busy register
func (o *DS_Type) SetQUERY_BUSY(value uint32) {
	volatile.StoreUint32(&o.QUERY_BUSY.Reg, volatile.LoadUint32(&o.QUERY_BUSY.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetQUERY_BUSY() uint32 {
	return volatile.LoadUint32(&o.QUERY_BUSY.Reg) & 0x1
}

// DS.QUERY_KEY_WRONG: DS query key-wrong counter register
func (o *DS_Type) SetQUERY_KEY_WRONG(value uint32) {
	volatile.StoreUint32(&o.QUERY_KEY_WRONG.Reg, volatile.LoadUint32(&o.QUERY_KEY_WRONG.Reg)&^(0xf)|value)
}
func (o *DS_Type) GetQUERY_KEY_WRONG() uint32 {
	return volatile.LoadUint32(&o.QUERY_KEY_WRONG.Reg) & 0xf
}

// DS.QUERY_CHECK: DS query check result register
func (o *DS_Type) SetQUERY_CHECK_MD_ERROR(value uint32) {
	volatile.StoreUint32(&o.QUERY_CHECK.Reg, volatile.LoadUint32(&o.QUERY_CHECK.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetQUERY_CHECK_MD_ERROR() uint32 {
	return volatile.LoadUint32(&o.QUERY_CHECK.Reg) & 0x1
}
func (o *DS_Type) SetQUERY_CHECK_PADDING_BAD(value uint32) {
	volatile.StoreUint32(&o.QUERY_CHECK.Reg, volatile.LoadUint32(&o.QUERY_CHECK.Reg)&^(0x2)|value<<1)
}
func (o *DS_Type) GetQUERY_CHECK_PADDING_BAD() uint32 {
	return (volatile.LoadUint32(&o.QUERY_CHECK.Reg) & 0x2) >> 1
}

// DS.DATE: DS version control register
func (o *DS_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *DS_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// ECC (ECC Hardware Accelerator)
type ECC_Type struct {
	_            [12]byte
	MULT_INT_RAW volatile.Register32 // 0xC
	MULT_INT_ST  volatile.Register32 // 0x10
	MULT_INT_ENA volatile.Register32 // 0x14
	MULT_INT_CLR volatile.Register32 // 0x18
	MULT_CONF    volatile.Register32 // 0x1C
	_            [220]byte
	MULT_DATE    volatile.Register32    // 0xFC
	K_MEM        [32]volatile.Register8 // 0x100
	PX_MEM       [32]volatile.Register8 // 0x120
	PY_MEM       [32]volatile.Register8 // 0x140
	QX_MEM0      volatile.Register8     // 0x160
	QX_MEM1      volatile.Register8     // 0x161
	QX_MEM2      volatile.Register8     // 0x162
	QX_MEM3      volatile.Register8     // 0x163
	QX_MEM4      volatile.Register8     // 0x164
	QX_MEM5      volatile.Register8     // 0x165
	QX_MEM6      volatile.Register8     // 0x166
	QX_MEM7      volatile.Register8     // 0x167
	QX_MEM8      volatile.Register8     // 0x168
	QX_MEM9      volatile.Register8     // 0x169
	QX_MEM10     volatile.Register8     // 0x16A
	QX_MEM11     volatile.Register8     // 0x16B
	QX_MEM12     volatile.Register8     // 0x16C
	QX_MEM13     volatile.Register8     // 0x16D
	QX_MEM14     volatile.Register8     // 0x16E
	QX_MEM15     volatile.Register8     // 0x16F
	QX_MEM16     volatile.Register8     // 0x170
	QX_MEM17     volatile.Register8     // 0x171
	QX_MEM18     volatile.Register8     // 0x172
	QX_MEM19     volatile.Register8     // 0x173
	QX_MEM20     volatile.Register8     // 0x174
	QX_MEM21     volatile.Register8     // 0x175
	QX_MEM22     volatile.Register8     // 0x176
	QX_MEM23     volatile.Register8     // 0x177
	QX_MEM24     volatile.Register8     // 0x178
	QX_MEM25     volatile.Register8     // 0x179
	QX_MEM26     volatile.Register8     // 0x17A
	QX_MEM27     volatile.Register8     // 0x17B
	QX_MEM28     volatile.Register8     // 0x17C
	QX_MEM29     volatile.Register8     // 0x17D
	QX_MEM30     volatile.Register8     // 0x17E
	QX_MEM31     volatile.Register8     // 0x17F
	QY_MEM0      volatile.Register8     // 0x180
	QY_MEM1      volatile.Register8     // 0x181
	QY_MEM2      volatile.Register8     // 0x182
	QY_MEM3      volatile.Register8     // 0x183
	QY_MEM4      volatile.Register8     // 0x184
	QY_MEM5      volatile.Register8     // 0x185
	QY_MEM6      volatile.Register8     // 0x186
	QY_MEM7      volatile.Register8     // 0x187
	QY_MEM8      volatile.Register8     // 0x188
	QY_MEM9      volatile.Register8     // 0x189
	QY_MEM10     volatile.Register8     // 0x18A
	QY_MEM11     volatile.Register8     // 0x18B
	QY_MEM12     volatile.Register8     // 0x18C
	QY_MEM13     volatile.Register8     // 0x18D
	QY_MEM14     volatile.Register8     // 0x18E
	QY_MEM15     volatile.Register8     // 0x18F
	QY_MEM16     volatile.Register8     // 0x190
	QY_MEM17     volatile.Register8     // 0x191
	QY_MEM18     volatile.Register8     // 0x192
	QY_MEM19     volatile.Register8     // 0x193
	QY_MEM20     volatile.Register8     // 0x194
	QY_MEM21     volatile.Register8     // 0x195
	QY_MEM22     volatile.Register8     // 0x196
	QY_MEM23     volatile.Register8     // 0x197
	QY_MEM24     volatile.Register8     // 0x198
	QY_MEM25     volatile.Register8     // 0x199
	QY_MEM26     volatile.Register8     // 0x19A
	QY_MEM27     volatile.Register8     // 0x19B
	QY_MEM28     volatile.Register8     // 0x19C
	QY_MEM29     volatile.Register8     // 0x19D
	QY_MEM30     volatile.Register8     // 0x19E
	QY_MEM31     volatile.Register8     // 0x19F
	QZ_MEM0      volatile.Register8     // 0x1A0
	QZ_MEM1      volatile.Register8     // 0x1A1
	QZ_MEM2      volatile.Register8     // 0x1A2
	QZ_MEM3      volatile.Register8     // 0x1A3
	QZ_MEM4      volatile.Register8     // 0x1A4
	QZ_MEM5      volatile.Register8     // 0x1A5
	QZ_MEM6      volatile.Register8     // 0x1A6
	QZ_MEM7      volatile.Register8     // 0x1A7
	QZ_MEM8      volatile.Register8     // 0x1A8
	QZ_MEM9      volatile.Register8     // 0x1A9
	QZ_MEM10     volatile.Register8     // 0x1AA
	QZ_MEM11     volatile.Register8     // 0x1AB
	QZ_MEM12     volatile.Register8     // 0x1AC
	QZ_MEM13     volatile.Register8     // 0x1AD
	QZ_MEM14     volatile.Register8     // 0x1AE
	QZ_MEM15     volatile.Register8     // 0x1AF
	QZ_MEM16     volatile.Register8     // 0x1B0
	QZ_MEM17     volatile.Register8     // 0x1B1
	QZ_MEM18     volatile.Register8     // 0x1B2
	QZ_MEM19     volatile.Register8     // 0x1B3
	QZ_MEM20     volatile.Register8     // 0x1B4
	QZ_MEM21     volatile.Register8     // 0x1B5
	QZ_MEM22     volatile.Register8     // 0x1B6
	QZ_MEM23     volatile.Register8     // 0x1B7
	QZ_MEM24     volatile.Register8     // 0x1B8
	QZ_MEM25     volatile.Register8     // 0x1B9
	QZ_MEM26     volatile.Register8     // 0x1BA
	QZ_MEM27     volatile.Register8     // 0x1BB
	QZ_MEM28     volatile.Register8     // 0x1BC
	QZ_MEM29     volatile.Register8     // 0x1BD
	QZ_MEM30     volatile.Register8     // 0x1BE
	QZ_MEM31     volatile.Register8     // 0x1BF
}

// ECC.MULT_INT_RAW: ECC interrupt raw register, valid in level.
func (o *ECC_Type) SetMULT_INT_RAW_CALC_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.MULT_INT_RAW.Reg, volatile.LoadUint32(&o.MULT_INT_RAW.Reg)&^(0x1)|value)
}
func (o *ECC_Type) GetMULT_INT_RAW_CALC_DONE_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.MULT_INT_RAW.Reg) & 0x1
}

// ECC.MULT_INT_ST: ECC interrupt status register.
func (o *ECC_Type) SetMULT_INT_ST_CALC_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.MULT_INT_ST.Reg, volatile.LoadUint32(&o.MULT_INT_ST.Reg)&^(0x1)|value)
}
func (o *ECC_Type) GetMULT_INT_ST_CALC_DONE_INT_ST() uint32 {
	return volatile.LoadUint32(&o.MULT_INT_ST.Reg) & 0x1
}

// ECC.MULT_INT_ENA: ECC interrupt enable register.
func (o *ECC_Type) SetMULT_INT_ENA_CALC_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.MULT_INT_ENA.Reg, volatile.LoadUint32(&o.MULT_INT_ENA.Reg)&^(0x1)|value)
}
func (o *ECC_Type) GetMULT_INT_ENA_CALC_DONE_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.MULT_INT_ENA.Reg) & 0x1
}

// ECC.MULT_INT_CLR: ECC interrupt clear register.
func (o *ECC_Type) SetMULT_INT_CLR_CALC_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.MULT_INT_CLR.Reg, volatile.LoadUint32(&o.MULT_INT_CLR.Reg)&^(0x1)|value)
}
func (o *ECC_Type) GetMULT_INT_CLR_CALC_DONE_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.MULT_INT_CLR.Reg) & 0x1
}

// ECC.MULT_CONF: ECC configure register
func (o *ECC_Type) SetMULT_CONF_START(value uint32) {
	volatile.StoreUint32(&o.MULT_CONF.Reg, volatile.LoadUint32(&o.MULT_CONF.Reg)&^(0x1)|value)
}
func (o *ECC_Type) GetMULT_CONF_START() uint32 {
	return volatile.LoadUint32(&o.MULT_CONF.Reg) & 0x1
}
func (o *ECC_Type) SetMULT_CONF_RESET(value uint32) {
	volatile.StoreUint32(&o.MULT_CONF.Reg, volatile.LoadUint32(&o.MULT_CONF.Reg)&^(0x2)|value<<1)
}
func (o *ECC_Type) GetMULT_CONF_RESET() uint32 {
	return (volatile.LoadUint32(&o.MULT_CONF.Reg) & 0x2) >> 1
}
func (o *ECC_Type) SetMULT_CONF_KEY_LENGTH(value uint32) {
	volatile.StoreUint32(&o.MULT_CONF.Reg, volatile.LoadUint32(&o.MULT_CONF.Reg)&^(0x4)|value<<2)
}
func (o *ECC_Type) GetMULT_CONF_KEY_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.MULT_CONF.Reg) & 0x4) >> 2
}
func (o *ECC_Type) SetMULT_CONF_MOD_BASE(value uint32) {
	volatile.StoreUint32(&o.MULT_CONF.Reg, volatile.LoadUint32(&o.MULT_CONF.Reg)&^(0x8)|value<<3)
}
func (o *ECC_Type) GetMULT_CONF_MOD_BASE() uint32 {
	return (volatile.LoadUint32(&o.MULT_CONF.Reg) & 0x8) >> 3
}
func (o *ECC_Type) SetMULT_CONF_WORK_MODE(value uint32) {
	volatile.StoreUint32(&o.MULT_CONF.Reg, volatile.LoadUint32(&o.MULT_CONF.Reg)&^(0xf0)|value<<4)
}
func (o *ECC_Type) GetMULT_CONF_WORK_MODE() uint32 {
	return (volatile.LoadUint32(&o.MULT_CONF.Reg) & 0xf0) >> 4
}
func (o *ECC_Type) SetMULT_CONF_SECURITY_MODE(value uint32) {
	volatile.StoreUint32(&o.MULT_CONF.Reg, volatile.LoadUint32(&o.MULT_CONF.Reg)&^(0x100)|value<<8)
}
func (o *ECC_Type) GetMULT_CONF_SECURITY_MODE() uint32 {
	return (volatile.LoadUint32(&o.MULT_CONF.Reg) & 0x100) >> 8
}
func (o *ECC_Type) SetMULT_CONF_VERIFICATION_RESULT(value uint32) {
	volatile.StoreUint32(&o.MULT_CONF.Reg, volatile.LoadUint32(&o.MULT_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *ECC_Type) GetMULT_CONF_VERIFICATION_RESULT() uint32 {
	return (volatile.LoadUint32(&o.MULT_CONF.Reg) & 0x20000000) >> 29
}
func (o *ECC_Type) SetMULT_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.MULT_CONF.Reg, volatile.LoadUint32(&o.MULT_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *ECC_Type) GetMULT_CONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.MULT_CONF.Reg) & 0x40000000) >> 30
}
func (o *ECC_Type) SetMULT_CONF_MEM_CLOCK_GATE_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.MULT_CONF.Reg, volatile.LoadUint32(&o.MULT_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *ECC_Type) GetMULT_CONF_MEM_CLOCK_GATE_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.MULT_CONF.Reg) & 0x80000000) >> 31
}

// ECC.MULT_DATE: Version control register
func (o *ECC_Type) SetMULT_DATE_DATE(value uint32) {
	volatile.StoreUint32(&o.MULT_DATE.Reg, volatile.LoadUint32(&o.MULT_DATE.Reg)&^(0xfffffff)|value)
}
func (o *ECC_Type) GetMULT_DATE_DATE() uint32 {
	return volatile.LoadUint32(&o.MULT_DATE.Reg) & 0xfffffff
}

// eFuse Controller
type EFUSE_Type struct {
	PGM_DATA0              volatile.Register32 // 0x0
	PGM_DATA1              volatile.Register32 // 0x4
	PGM_DATA2              volatile.Register32 // 0x8
	PGM_DATA3              volatile.Register32 // 0xC
	PGM_DATA4              volatile.Register32 // 0x10
	PGM_DATA5              volatile.Register32 // 0x14
	PGM_DATA6              volatile.Register32 // 0x18
	PGM_DATA7              volatile.Register32 // 0x1C
	PGM_CHECK_VALUE0       volatile.Register32 // 0x20
	PGM_CHECK_VALUE1       volatile.Register32 // 0x24
	PGM_CHECK_VALUE2       volatile.Register32 // 0x28
	RD_WR_DIS              volatile.Register32 // 0x2C
	RD_REPEAT_DATA0        volatile.Register32 // 0x30
	RD_REPEAT_DATA1        volatile.Register32 // 0x34
	RD_REPEAT_DATA2        volatile.Register32 // 0x38
	RD_REPEAT_DATA3        volatile.Register32 // 0x3C
	RD_REPEAT_DATA4        volatile.Register32 // 0x40
	RD_MAC_SYS_0           volatile.Register32 // 0x44
	RD_MAC_SYS_1           volatile.Register32 // 0x48
	RD_MAC_SYS_2           volatile.Register32 // 0x4C
	RD_MAC_SYS_3           volatile.Register32 // 0x50
	RD_MAC_SYS_4           volatile.Register32 // 0x54
	RD_MAC_SYS_5           volatile.Register32 // 0x58
	RD_SYS_PART1_DATA0     volatile.Register32 // 0x5C
	RD_SYS_PART1_DATA1     volatile.Register32 // 0x60
	RD_SYS_PART1_DATA2     volatile.Register32 // 0x64
	RD_SYS_PART1_DATA3     volatile.Register32 // 0x68
	RD_SYS_PART1_DATA4     volatile.Register32 // 0x6C
	RD_SYS_PART1_DATA5     volatile.Register32 // 0x70
	RD_SYS_PART1_DATA6     volatile.Register32 // 0x74
	RD_SYS_PART1_DATA7     volatile.Register32 // 0x78
	RD_USR_DATA0           volatile.Register32 // 0x7C
	RD_USR_DATA1           volatile.Register32 // 0x80
	RD_USR_DATA2           volatile.Register32 // 0x84
	RD_USR_DATA3           volatile.Register32 // 0x88
	RD_USR_DATA4           volatile.Register32 // 0x8C
	RD_USR_DATA5           volatile.Register32 // 0x90
	RD_USR_DATA6           volatile.Register32 // 0x94
	RD_USR_DATA7           volatile.Register32 // 0x98
	RD_KEY0_DATA0          volatile.Register32 // 0x9C
	RD_KEY0_DATA1          volatile.Register32 // 0xA0
	RD_KEY0_DATA2          volatile.Register32 // 0xA4
	RD_KEY0_DATA3          volatile.Register32 // 0xA8
	RD_KEY0_DATA4          volatile.Register32 // 0xAC
	RD_KEY0_DATA5          volatile.Register32 // 0xB0
	RD_KEY0_DATA6          volatile.Register32 // 0xB4
	RD_KEY0_DATA7          volatile.Register32 // 0xB8
	RD_KEY1_DATA0          volatile.Register32 // 0xBC
	RD_KEY1_DATA1          volatile.Register32 // 0xC0
	RD_KEY1_DATA2          volatile.Register32 // 0xC4
	RD_KEY1_DATA3          volatile.Register32 // 0xC8
	RD_KEY1_DATA4          volatile.Register32 // 0xCC
	RD_KEY1_DATA5          volatile.Register32 // 0xD0
	RD_KEY1_DATA6          volatile.Register32 // 0xD4
	RD_KEY1_DATA7          volatile.Register32 // 0xD8
	RD_KEY2_DATA0          volatile.Register32 // 0xDC
	RD_KEY2_DATA1          volatile.Register32 // 0xE0
	RD_KEY2_DATA2          volatile.Register32 // 0xE4
	RD_KEY2_DATA3          volatile.Register32 // 0xE8
	RD_KEY2_DATA4          volatile.Register32 // 0xEC
	RD_KEY2_DATA5          volatile.Register32 // 0xF0
	RD_KEY2_DATA6          volatile.Register32 // 0xF4
	RD_KEY2_DATA7          volatile.Register32 // 0xF8
	RD_KEY3_DATA0          volatile.Register32 // 0xFC
	RD_KEY3_DATA1          volatile.Register32 // 0x100
	RD_KEY3_DATA2          volatile.Register32 // 0x104
	RD_KEY3_DATA3          volatile.Register32 // 0x108
	RD_KEY3_DATA4          volatile.Register32 // 0x10C
	RD_KEY3_DATA5          volatile.Register32 // 0x110
	RD_KEY3_DATA6          volatile.Register32 // 0x114
	RD_KEY3_DATA7          volatile.Register32 // 0x118
	RD_KEY4_DATA0          volatile.Register32 // 0x11C
	RD_KEY4_DATA1          volatile.Register32 // 0x120
	RD_KEY4_DATA2          volatile.Register32 // 0x124
	RD_KEY4_DATA3          volatile.Register32 // 0x128
	RD_KEY4_DATA4          volatile.Register32 // 0x12C
	RD_KEY4_DATA5          volatile.Register32 // 0x130
	RD_KEY4_DATA6          volatile.Register32 // 0x134
	RD_KEY4_DATA7          volatile.Register32 // 0x138
	RD_KEY5_DATA0          volatile.Register32 // 0x13C
	RD_KEY5_DATA1          volatile.Register32 // 0x140
	RD_KEY5_DATA2          volatile.Register32 // 0x144
	RD_KEY5_DATA3          volatile.Register32 // 0x148
	RD_KEY5_DATA4          volatile.Register32 // 0x14C
	RD_KEY5_DATA5          volatile.Register32 // 0x150
	RD_KEY5_DATA6          volatile.Register32 // 0x154
	RD_KEY5_DATA7          volatile.Register32 // 0x158
	RD_SYS_PART2_DATA0     volatile.Register32 // 0x15C
	RD_SYS_PART2_DATA1     volatile.Register32 // 0x160
	RD_SYS_PART2_DATA2     volatile.Register32 // 0x164
	RD_SYS_PART2_DATA3     volatile.Register32 // 0x168
	RD_SYS_PART2_DATA4     volatile.Register32 // 0x16C
	RD_SYS_PART2_DATA5     volatile.Register32 // 0x170
	RD_SYS_PART2_DATA6     volatile.Register32 // 0x174
	RD_SYS_PART2_DATA7     volatile.Register32 // 0x178
	RD_REPEAT_ERR0         volatile.Register32 // 0x17C
	RD_REPEAT_ERR1         volatile.Register32 // 0x180
	RD_REPEAT_ERR2         volatile.Register32 // 0x184
	RD_REPEAT_ERR3         volatile.Register32 // 0x188
	RD_REPEAT_ERR4         volatile.Register32 // 0x18C
	_                      [48]byte
	RD_RS_ERR0             volatile.Register32 // 0x1C0
	RD_RS_ERR1             volatile.Register32 // 0x1C4
	CLK                    volatile.Register32 // 0x1C8
	CONF                   volatile.Register32 // 0x1CC
	STATUS                 volatile.Register32 // 0x1D0
	CMD                    volatile.Register32 // 0x1D4
	INT_RAW                volatile.Register32 // 0x1D8
	INT_ST                 volatile.Register32 // 0x1DC
	INT_ENA                volatile.Register32 // 0x1E0
	INT_CLR                volatile.Register32 // 0x1E4
	DAC_CONF               volatile.Register32 // 0x1E8
	RD_TIM_CONF            volatile.Register32 // 0x1EC
	WR_TIM_CONF1           volatile.Register32 // 0x1F0
	WR_TIM_CONF2           volatile.Register32 // 0x1F4
	WR_TIM_CONF0_RS_BYPASS volatile.Register32 // 0x1F8
	DATE                   volatile.Register32 // 0x1FC
}

// EFUSE.PGM_DATA0: Register 0 that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA0(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA0() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA0.Reg)
}

// EFUSE.PGM_DATA1: Register 1 that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA1(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA1() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA1.Reg)
}

// EFUSE.PGM_DATA2: Register 2 that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA2(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA2() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA2.Reg)
}

// EFUSE.PGM_DATA3: Register 3 that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA3(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA3() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA3.Reg)
}

// EFUSE.PGM_DATA4: Register 4 that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA4(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA4() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA4.Reg)
}

// EFUSE.PGM_DATA5: Register 5 that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA5(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA5() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA5.Reg)
}

// EFUSE.PGM_DATA6: Register 6 that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA6(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA6() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA6.Reg)
}

// EFUSE.PGM_DATA7: Register 7 that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA7(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA7() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA7.Reg)
}

// EFUSE.PGM_CHECK_VALUE0: Register 0 that stores the RS code to be programmed.
func (o *EFUSE_Type) SetPGM_CHECK_VALUE0(value uint32) {
	volatile.StoreUint32(&o.PGM_CHECK_VALUE0.Reg, value)
}
func (o *EFUSE_Type) GetPGM_CHECK_VALUE0() uint32 {
	return volatile.LoadUint32(&o.PGM_CHECK_VALUE0.Reg)
}

// EFUSE.PGM_CHECK_VALUE1: Register 1 that stores the RS code to be programmed.
func (o *EFUSE_Type) SetPGM_CHECK_VALUE1(value uint32) {
	volatile.StoreUint32(&o.PGM_CHECK_VALUE1.Reg, value)
}
func (o *EFUSE_Type) GetPGM_CHECK_VALUE1() uint32 {
	return volatile.LoadUint32(&o.PGM_CHECK_VALUE1.Reg)
}

// EFUSE.PGM_CHECK_VALUE2: Register 2 that stores the RS code to be programmed.
func (o *EFUSE_Type) SetPGM_CHECK_VALUE2(value uint32) {
	volatile.StoreUint32(&o.PGM_CHECK_VALUE2.Reg, value)
}
func (o *EFUSE_Type) GetPGM_CHECK_VALUE2() uint32 {
	return volatile.LoadUint32(&o.PGM_CHECK_VALUE2.Reg)
}

// EFUSE.RD_WR_DIS: BLOCK0 data register 0.
func (o *EFUSE_Type) SetRD_WR_DIS(value uint32) {
	volatile.StoreUint32(&o.RD_WR_DIS.Reg, value)
}
func (o *EFUSE_Type) GetRD_WR_DIS() uint32 {
	return volatile.LoadUint32(&o.RD_WR_DIS.Reg)
}

// EFUSE.RD_REPEAT_DATA0: BLOCK0 data register 1.
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_RD_DIS(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x7f)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_RD_DIS() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x7f
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_RPT4_RESERVED0_4(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_RPT4_RESERVED0_4() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_ICACHE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_ICACHE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_USB_JTAG(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x200)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_USB_JTAG() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x200) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_POWERGLITCH_EN(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x400)|value<<10)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_POWERGLITCH_EN() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x400) >> 10
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_USB_SERIAL_JTAG(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x800)|value<<11)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_USB_SERIAL_JTAG() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x800) >> 11
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x1000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x1000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_SPI_DOWNLOAD_MSPI_DIS(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x2000)|value<<13)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_SPI_DOWNLOAD_MSPI_DIS() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x2000) >> 13
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_CAN(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x4000)|value<<14)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_CAN() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x4000) >> 14
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_JTAG_SEL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x8000)|value<<15)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_JTAG_SEL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x8000) >> 15
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_SOFT_DIS_JTAG(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x70000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_SOFT_DIS_JTAG() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x70000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_PAD_JTAG(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x80000)|value<<19)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_PAD_JTAG() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x80000) >> 19
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x100000)|value<<20)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x100000) >> 20
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_USB_DREFH(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x600000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_USB_DREFH() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x600000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_USB_DREFL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x1800000)|value<<23)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_USB_DREFL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x1800000) >> 23
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_USB_EXCHG_PINS(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x2000000)|value<<25)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_USB_EXCHG_PINS() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x2000000) >> 25
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_VDD_SPI_AS_GPIO(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x4000000)|value<<26)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_VDD_SPI_AS_GPIO() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x4000000) >> 26
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_RPT4_RESERVED0_2(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x18000000)|value<<27)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_RPT4_RESERVED0_2() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x18000000) >> 27
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_RPT4_RESERVED0_1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x20000000)|value<<29)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_RPT4_RESERVED0_1() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x20000000) >> 29
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_RPT4_RESERVED0_0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0xc0000000)|value<<30)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_RPT4_RESERVED0_0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0xc0000000) >> 30
}

// EFUSE.RD_REPEAT_DATA1: BLOCK0 data register 2.
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_RPT4_RESERVED1_1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0xffff)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_RPT4_RESERVED1_1() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0xffff
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_WDT_DELAY_SEL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x30000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_WDT_DELAY_SEL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x30000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_SPI_BOOT_CRYPT_CNT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x1c0000)|value<<18)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_SPI_BOOT_CRYPT_CNT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x1c0000) >> 18
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x200000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x200000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x400000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x400000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x800000)|value<<23)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x800000) >> 23
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_KEY_PURPOSE_0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0xf000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_KEY_PURPOSE_0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0xf000000) >> 24
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_KEY_PURPOSE_1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0xf0000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_KEY_PURPOSE_1() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0xf0000000) >> 28
}

// EFUSE.RD_REPEAT_DATA2: BLOCK0 data register 3.
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_2(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_2() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_3(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf0)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_3() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf0) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_4(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf00)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_4() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf00) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_5(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_5() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_SEC_DPA_LEVEL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0x30000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_SEC_DPA_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0x30000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_ECDSA_FORCE_USE_HARDWARE_K(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0x40000)|value<<18)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_ECDSA_FORCE_USE_HARDWARE_K() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0x40000) >> 18
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_CRYPT_DPA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0x80000)|value<<19)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_CRYPT_DPA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0x80000) >> 19
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_SECURE_BOOT_EN(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0x100000)|value<<20)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_SECURE_BOOT_EN() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0x100000) >> 20
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0x200000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0x200000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_RPT4_RESERVED2_0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xfc00000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_RPT4_RESERVED2_0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xfc00000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_FLASH_TPUW(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf0000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_FLASH_TPUW() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf0000000) >> 28
}

// EFUSE.RD_REPEAT_DATA3: BLOCK0 data register 4.
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_DIS_DOWNLOAD_MODE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_DIS_DOWNLOAD_MODE() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x1
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_DIS_DIRECT_BOOT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_DIS_DIRECT_BOOT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x2) >> 1
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_DIS_USB_PRINT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x4)|value<<2)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_DIS_USB_PRINT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x4) >> 2
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_RPT4_RESERVED3_5(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x8)|value<<3)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_RPT4_RESERVED3_5() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x8) >> 3
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x10)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x10) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x20)|value<<5)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x20) >> 5
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_UART_PRINT_CONTROL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0xc0)|value<<6)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_UART_PRINT_CONTROL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0xc0) >> 6
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_FORCE_SEND_RESUME(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_FORCE_SEND_RESUME() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_SECURE_VERSION(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x1fffe00)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_SECURE_VERSION() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x1fffe00) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_SECURE_BOOT_DISABLE_FAST_WAKE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x2000000)|value<<25)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_SECURE_BOOT_DISABLE_FAST_WAKE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x2000000) >> 25
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_HYS_EN_PAD0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0xfc000000)|value<<26)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_HYS_EN_PAD0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0xfc000000) >> 26
}

// EFUSE.RD_REPEAT_DATA4: BLOCK0 data register 5.
func (o *EFUSE_Type) SetRD_REPEAT_DATA4_HYS_EN_PAD1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA4.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA4.Reg)&^(0x3fffff)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA4_HYS_EN_PAD1() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA4.Reg) & 0x3fffff
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA4_RPT4_RESERVED4_1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA4.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA4.Reg)&^(0xc00000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA4_RPT4_RESERVED4_1() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA4.Reg) & 0xc00000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA4_RPT4_RESERVED4_0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA4.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA4.Reg)&^(0xff000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA4_RPT4_RESERVED4_0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA4.Reg) & 0xff000000) >> 24
}

// EFUSE.RD_MAC_SYS_0: BLOCK1 data register $n.
func (o *EFUSE_Type) SetRD_MAC_SYS_0(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SYS_0.Reg, value)
}
func (o *EFUSE_Type) GetRD_MAC_SYS_0() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SYS_0.Reg)
}

// EFUSE.RD_MAC_SYS_1: BLOCK1 data register $n.
func (o *EFUSE_Type) SetRD_MAC_SYS_1_MAC_1(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SYS_1.Reg, volatile.LoadUint32(&o.RD_MAC_SYS_1.Reg)&^(0xffff)|value)
}
func (o *EFUSE_Type) GetRD_MAC_SYS_1_MAC_1() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SYS_1.Reg) & 0xffff
}
func (o *EFUSE_Type) SetRD_MAC_SYS_1_MAC_EXT(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SYS_1.Reg, volatile.LoadUint32(&o.RD_MAC_SYS_1.Reg)&^(0xffff0000)|value<<16)
}
func (o *EFUSE_Type) GetRD_MAC_SYS_1_MAC_EXT() uint32 {
	return (volatile.LoadUint32(&o.RD_MAC_SYS_1.Reg) & 0xffff0000) >> 16
}

// EFUSE.RD_MAC_SYS_2: BLOCK1 data register $n.
func (o *EFUSE_Type) SetRD_MAC_SYS_2_MAC_RESERVED_1(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SYS_2.Reg, volatile.LoadUint32(&o.RD_MAC_SYS_2.Reg)&^(0x3fff)|value)
}
func (o *EFUSE_Type) GetRD_MAC_SYS_2_MAC_RESERVED_1() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SYS_2.Reg) & 0x3fff
}
func (o *EFUSE_Type) SetRD_MAC_SYS_2_MAC_RESERVED_0(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SYS_2.Reg, volatile.LoadUint32(&o.RD_MAC_SYS_2.Reg)&^(0xffffc000)|value<<14)
}
func (o *EFUSE_Type) GetRD_MAC_SYS_2_MAC_RESERVED_0() uint32 {
	return (volatile.LoadUint32(&o.RD_MAC_SYS_2.Reg) & 0xffffc000) >> 14
}

// EFUSE.RD_MAC_SYS_3: BLOCK1 data register $n.
func (o *EFUSE_Type) SetRD_MAC_SYS_3_MAC_RESERVED_2(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SYS_3.Reg, volatile.LoadUint32(&o.RD_MAC_SYS_3.Reg)&^(0x3ffff)|value)
}
func (o *EFUSE_Type) GetRD_MAC_SYS_3_MAC_RESERVED_2() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SYS_3.Reg) & 0x3ffff
}
func (o *EFUSE_Type) SetRD_MAC_SYS_3_SYS_DATA_PART0_0(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SYS_3.Reg, volatile.LoadUint32(&o.RD_MAC_SYS_3.Reg)&^(0xfffc0000)|value<<18)
}
func (o *EFUSE_Type) GetRD_MAC_SYS_3_SYS_DATA_PART0_0() uint32 {
	return (volatile.LoadUint32(&o.RD_MAC_SYS_3.Reg) & 0xfffc0000) >> 18
}

// EFUSE.RD_MAC_SYS_4: BLOCK1 data register $n.
func (o *EFUSE_Type) SetRD_MAC_SYS_4(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SYS_4.Reg, value)
}
func (o *EFUSE_Type) GetRD_MAC_SYS_4() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SYS_4.Reg)
}

// EFUSE.RD_MAC_SYS_5: BLOCK1 data register $n.
func (o *EFUSE_Type) SetRD_MAC_SYS_5(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SYS_5.Reg, value)
}
func (o *EFUSE_Type) GetRD_MAC_SYS_5() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SYS_5.Reg)
}

// EFUSE.RD_SYS_PART1_DATA0: Register $n of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_PART1_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART1_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART1_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART1_DATA0.Reg)
}

// EFUSE.RD_SYS_PART1_DATA1: Register $n of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_PART1_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART1_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART1_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART1_DATA1.Reg)
}

// EFUSE.RD_SYS_PART1_DATA2: Register $n of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_PART1_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART1_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART1_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART1_DATA2.Reg)
}

// EFUSE.RD_SYS_PART1_DATA3: Register $n of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_PART1_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART1_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART1_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART1_DATA3.Reg)
}

// EFUSE.RD_SYS_PART1_DATA4: Register $n of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_PART1_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART1_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART1_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART1_DATA4.Reg)
}

// EFUSE.RD_SYS_PART1_DATA5: Register $n of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_PART1_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART1_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART1_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART1_DATA5.Reg)
}

// EFUSE.RD_SYS_PART1_DATA6: Register $n of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_PART1_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART1_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART1_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART1_DATA6.Reg)
}

// EFUSE.RD_SYS_PART1_DATA7: Register $n of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_PART1_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART1_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART1_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART1_DATA7.Reg)
}

// EFUSE.RD_USR_DATA0: Register $n of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA0.Reg)
}

// EFUSE.RD_USR_DATA1: Register $n of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA1.Reg)
}

// EFUSE.RD_USR_DATA2: Register $n of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA2.Reg)
}

// EFUSE.RD_USR_DATA3: Register $n of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA3.Reg)
}

// EFUSE.RD_USR_DATA4: Register $n of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA4.Reg)
}

// EFUSE.RD_USR_DATA5: Register $n of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA5.Reg)
}

// EFUSE.RD_USR_DATA6: Register $n of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA6.Reg)
}

// EFUSE.RD_USR_DATA7: Register $n of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA7.Reg)
}

// EFUSE.RD_KEY0_DATA0: Register $n of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA0.Reg)
}

// EFUSE.RD_KEY0_DATA1: Register $n of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA1.Reg)
}

// EFUSE.RD_KEY0_DATA2: Register $n of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA2.Reg)
}

// EFUSE.RD_KEY0_DATA3: Register $n of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA3.Reg)
}

// EFUSE.RD_KEY0_DATA4: Register $n of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA4.Reg)
}

// EFUSE.RD_KEY0_DATA5: Register $n of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA5.Reg)
}

// EFUSE.RD_KEY0_DATA6: Register $n of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA6.Reg)
}

// EFUSE.RD_KEY0_DATA7: Register $n of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA7.Reg)
}

// EFUSE.RD_KEY1_DATA0: Register $n of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA0.Reg)
}

// EFUSE.RD_KEY1_DATA1: Register $n of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA1.Reg)
}

// EFUSE.RD_KEY1_DATA2: Register $n of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA2.Reg)
}

// EFUSE.RD_KEY1_DATA3: Register $n of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA3.Reg)
}

// EFUSE.RD_KEY1_DATA4: Register $n of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA4.Reg)
}

// EFUSE.RD_KEY1_DATA5: Register $n of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA5.Reg)
}

// EFUSE.RD_KEY1_DATA6: Register $n of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA6.Reg)
}

// EFUSE.RD_KEY1_DATA7: Register $n of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA7.Reg)
}

// EFUSE.RD_KEY2_DATA0: Register $n of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA0.Reg)
}

// EFUSE.RD_KEY2_DATA1: Register $n of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA1.Reg)
}

// EFUSE.RD_KEY2_DATA2: Register $n of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA2.Reg)
}

// EFUSE.RD_KEY2_DATA3: Register $n of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA3.Reg)
}

// EFUSE.RD_KEY2_DATA4: Register $n of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA4.Reg)
}

// EFUSE.RD_KEY2_DATA5: Register $n of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA5.Reg)
}

// EFUSE.RD_KEY2_DATA6: Register $n of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA6.Reg)
}

// EFUSE.RD_KEY2_DATA7: Register $n of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA7.Reg)
}

// EFUSE.RD_KEY3_DATA0: Register $n of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA0.Reg)
}

// EFUSE.RD_KEY3_DATA1: Register $n of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA1.Reg)
}

// EFUSE.RD_KEY3_DATA2: Register $n of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA2.Reg)
}

// EFUSE.RD_KEY3_DATA3: Register $n of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA3.Reg)
}

// EFUSE.RD_KEY3_DATA4: Register $n of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA4.Reg)
}

// EFUSE.RD_KEY3_DATA5: Register $n of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA5.Reg)
}

// EFUSE.RD_KEY3_DATA6: Register $n of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA6.Reg)
}

// EFUSE.RD_KEY3_DATA7: Register $n of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA7.Reg)
}

// EFUSE.RD_KEY4_DATA0: Register $n of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA0.Reg)
}

// EFUSE.RD_KEY4_DATA1: Register $n of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA1.Reg)
}

// EFUSE.RD_KEY4_DATA2: Register $n of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA2.Reg)
}

// EFUSE.RD_KEY4_DATA3: Register $n of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA3.Reg)
}

// EFUSE.RD_KEY4_DATA4: Register $n of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA4.Reg)
}

// EFUSE.RD_KEY4_DATA5: Register $n of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA5.Reg)
}

// EFUSE.RD_KEY4_DATA6: Register $n of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA6.Reg)
}

// EFUSE.RD_KEY4_DATA7: Register $n of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA7.Reg)
}

// EFUSE.RD_KEY5_DATA0: Register $n of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA0.Reg)
}

// EFUSE.RD_KEY5_DATA1: Register $n of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA1.Reg)
}

// EFUSE.RD_KEY5_DATA2: Register $n of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA2.Reg)
}

// EFUSE.RD_KEY5_DATA3: Register $n of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA3.Reg)
}

// EFUSE.RD_KEY5_DATA4: Register $n of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA4.Reg)
}

// EFUSE.RD_KEY5_DATA5: Register $n of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA5.Reg)
}

// EFUSE.RD_KEY5_DATA6: Register $n of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA6.Reg)
}

// EFUSE.RD_KEY5_DATA7: Register $n of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA7.Reg)
}

// EFUSE.RD_SYS_PART2_DATA0: Register $n of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_PART2_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART2_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART2_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART2_DATA0.Reg)
}

// EFUSE.RD_SYS_PART2_DATA1: Register $n of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_SYS_PART2_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART2_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART2_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART2_DATA1.Reg)
}

// EFUSE.RD_SYS_PART2_DATA2: Register $n of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_PART2_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART2_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART2_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART2_DATA2.Reg)
}

// EFUSE.RD_SYS_PART2_DATA3: Register $n of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_PART2_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART2_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART2_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART2_DATA3.Reg)
}

// EFUSE.RD_SYS_PART2_DATA4: Register $n of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_PART2_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART2_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART2_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART2_DATA4.Reg)
}

// EFUSE.RD_SYS_PART2_DATA5: Register $n of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_PART2_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART2_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART2_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART2_DATA5.Reg)
}

// EFUSE.RD_SYS_PART2_DATA6: Register $n of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_PART2_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART2_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART2_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART2_DATA6.Reg)
}

// EFUSE.RD_SYS_PART2_DATA7: Register $n of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_PART2_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_PART2_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_PART2_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_PART2_DATA7.Reg)
}

// EFUSE.RD_REPEAT_ERR0: Programming error record register 0 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_RD_DIS_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x7f)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_RD_DIS_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x7f
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_RPT4_RESERVED0_ERR_4(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_RPT4_RESERVED0_ERR_4() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_ICACHE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_ICACHE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_USB_JTAG_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x200)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_USB_JTAG_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x200) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_POWERGLITCH_EN_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x400)|value<<10)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_POWERGLITCH_EN_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x400) >> 10
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_USB_SERIAL_JTAG_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x800)|value<<11)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_USB_SERIAL_JTAG_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x800) >> 11
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x1000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x1000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_SPI_DOWNLOAD_MSPI_DIS_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x2000)|value<<13)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_SPI_DOWNLOAD_MSPI_DIS_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x2000) >> 13
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_TWAI_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x4000)|value<<14)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_TWAI_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x4000) >> 14
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_JTAG_SEL_ENABLE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x8000)|value<<15)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_JTAG_SEL_ENABLE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x8000) >> 15
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x70000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x70000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_PAD_JTAG_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x80000)|value<<19)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_PAD_JTAG_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x80000) >> 19
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x100000)|value<<20)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x100000) >> 20
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_USB_DREFH_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x600000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_USB_DREFH_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x600000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_USB_DREFL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x1800000)|value<<23)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_USB_DREFL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x1800000) >> 23
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_USB_EXCHG_PINS_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x2000000)|value<<25)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_USB_EXCHG_PINS_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x2000000) >> 25
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_VDD_SPI_AS_GPIO_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x4000000)|value<<26)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_VDD_SPI_AS_GPIO_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x4000000) >> 26
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_RPT4_RESERVED0_ERR_2(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x18000000)|value<<27)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_RPT4_RESERVED0_ERR_2() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x18000000) >> 27
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_RPT4_RESERVED0_ERR_1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x20000000)|value<<29)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_RPT4_RESERVED0_ERR_1() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x20000000) >> 29
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_RPT4_RESERVED0_ERR_0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0xc0000000)|value<<30)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_RPT4_RESERVED0_ERR_0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0xc0000000) >> 30
}

// EFUSE.RD_REPEAT_ERR1: Programming error record register 1 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_RPT4_RESERVED1_ERR_0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0xffff)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_RPT4_RESERVED1_ERR_0() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0xffff
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_WDT_DELAY_SEL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x30000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_WDT_DELAY_SEL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x30000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_SPI_BOOT_CRYPT_CNT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x1c0000)|value<<18)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_SPI_BOOT_CRYPT_CNT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x1c0000) >> 18
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x200000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x200000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x400000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x400000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x800000)|value<<23)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x800000) >> 23
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_KEY_PURPOSE_0_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0xf000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_KEY_PURPOSE_0_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0xf000000) >> 24
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_KEY_PURPOSE_1_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0xf0000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_KEY_PURPOSE_1_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0xf0000000) >> 28
}

// EFUSE.RD_REPEAT_ERR2: Programming error record register 2 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_2_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_2_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_3_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf0)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_3_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf0) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_4_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf00)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_4_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf00) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_5_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_5_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_SEC_DPA_LEVEL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0x30000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_SEC_DPA_LEVEL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0x30000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_RPT4_RESERVED2_ERR_1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0x40000)|value<<18)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_RPT4_RESERVED2_ERR_1() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0x40000) >> 18
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_CRYPT_DPA_ENABLE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0x80000)|value<<19)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_CRYPT_DPA_ENABLE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0x80000) >> 19
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_SECURE_BOOT_EN_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0x100000)|value<<20)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_SECURE_BOOT_EN_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0x100000) >> 20
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0x200000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0x200000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_RPT4_RESERVED2_ERR_0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xfc00000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_RPT4_RESERVED2_ERR_0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xfc00000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_FLASH_TPUW_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf0000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_FLASH_TPUW_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf0000000) >> 28
}

// EFUSE.RD_REPEAT_ERR3: Programming error record register 3 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x1
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_DIS_DIRECT_BOOT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_DIS_DIRECT_BOOT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x2) >> 1
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_USB_PRINT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x4)|value<<2)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_USB_PRINT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x4) >> 2
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_RPT4_RESERVED3_ERR_5(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x8)|value<<3)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_RPT4_RESERVED3_ERR_5() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x8) >> 3
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x10)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x10) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x20)|value<<5)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x20) >> 5
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_UART_PRINT_CONTROL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0xc0)|value<<6)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_UART_PRINT_CONTROL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0xc0) >> 6
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_SECURE_VERSION_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x1fffe00)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_SECURE_VERSION_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x1fffe00) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_SECURE_BOOT_DISABLE_FAST_WAKE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x2000000)|value<<25)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_SECURE_BOOT_DISABLE_FAST_WAKE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x2000000) >> 25
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_HYS_EN_PAD0_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0xfc000000)|value<<26)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_HYS_EN_PAD0_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0xfc000000) >> 26
}

// EFUSE.RD_REPEAT_ERR4: Programming error record register 4 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR4_HYS_EN_PAD1_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR4.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR4.Reg)&^(0x3fffff)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR4_HYS_EN_PAD1_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR4.Reg) & 0x3fffff
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR4_RPT4_RESERVED4_ERR_1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR4.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR4.Reg)&^(0xc00000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR4_RPT4_RESERVED4_ERR_1() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR4.Reg) & 0xc00000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR4_RPT4_RESERVED4_ERR_0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR4.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR4.Reg)&^(0xff000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR4_RPT4_RESERVED4_ERR_0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR4.Reg) & 0xff000000) >> 24
}

// EFUSE.RD_RS_ERR0: Programming error record register 0 of BLOCK1-10.
func (o *EFUSE_Type) SetRD_RS_ERR0_MAC_SPI_8M_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x7)|value)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_MAC_SPI_8M_ERR_NUM() uint32 {
	return volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x7
}
func (o *EFUSE_Type) SetRD_RS_ERR0_MAC_SPI_8M_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x8)|value<<3)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_MAC_SPI_8M_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x8) >> 3
}
func (o *EFUSE_Type) SetRD_RS_ERR0_SYS_PART1_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x70)|value<<4)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_SYS_PART1_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x70) >> 4
}
func (o *EFUSE_Type) SetRD_RS_ERR0_SYS_PART1_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_SYS_PART1_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetRD_RS_ERR0_USR_DATA_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x700)|value<<8)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_USR_DATA_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x700) >> 8
}
func (o *EFUSE_Type) SetRD_RS_ERR0_USR_DATA_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x800)|value<<11)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_USR_DATA_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x800) >> 11
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY0_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x7000)|value<<12)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY0_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x7000) >> 12
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY0_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x8000)|value<<15)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY0_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x8000) >> 15
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY1_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x70000)|value<<16)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY1_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x70000) >> 16
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY1_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x80000)|value<<19)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY1_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x80000) >> 19
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY2_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x700000)|value<<20)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY2_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x700000) >> 20
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY2_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x800000)|value<<23)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY2_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x800000) >> 23
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY3_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x7000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY3_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x7000000) >> 24
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY3_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x8000000)|value<<27)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY3_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x8000000) >> 27
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY4_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x70000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY4_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x70000000) >> 28
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY4_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x80000000)|value<<31)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY4_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x80000000) >> 31
}

// EFUSE.RD_RS_ERR1: Programming error record register 1 of BLOCK1-10.
func (o *EFUSE_Type) SetRD_RS_ERR1_KEY5_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR1.Reg, volatile.LoadUint32(&o.RD_RS_ERR1.Reg)&^(0x7)|value)
}
func (o *EFUSE_Type) GetRD_RS_ERR1_KEY5_ERR_NUM() uint32 {
	return volatile.LoadUint32(&o.RD_RS_ERR1.Reg) & 0x7
}
func (o *EFUSE_Type) SetRD_RS_ERR1_KEY5_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR1.Reg, volatile.LoadUint32(&o.RD_RS_ERR1.Reg)&^(0x8)|value<<3)
}
func (o *EFUSE_Type) GetRD_RS_ERR1_KEY5_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR1.Reg) & 0x8) >> 3
}
func (o *EFUSE_Type) SetRD_RS_ERR1_SYS_PART2_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR1.Reg, volatile.LoadUint32(&o.RD_RS_ERR1.Reg)&^(0x70)|value<<4)
}
func (o *EFUSE_Type) GetRD_RS_ERR1_SYS_PART2_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR1.Reg) & 0x70) >> 4
}
func (o *EFUSE_Type) SetRD_RS_ERR1_SYS_PART2_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR1.Reg, volatile.LoadUint32(&o.RD_RS_ERR1.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_RS_ERR1_SYS_PART2_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR1.Reg) & 0x80) >> 7
}

// EFUSE.CLK: eFuse clcok configuration register.
func (o *EFUSE_Type) SetCLK_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetCLK_MEM_FORCE_PD() uint32 {
	return volatile.LoadUint32(&o.CLK.Reg) & 0x1
}
func (o *EFUSE_Type) SetCLK_MEM_CLK_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetCLK_MEM_CLK_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0x2) >> 1
}
func (o *EFUSE_Type) SetCLK_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x4)|value<<2)
}
func (o *EFUSE_Type) GetCLK_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0x4) >> 2
}
func (o *EFUSE_Type) SetCLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x10000)|value<<16)
}
func (o *EFUSE_Type) GetCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0x10000) >> 16
}

// EFUSE.CONF: eFuse operation mode configuraiton register
func (o *EFUSE_Type) SetCONF_OP_CODE(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xffff)|value)
}
func (o *EFUSE_Type) GetCONF_OP_CODE() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0xffff
}
func (o *EFUSE_Type) SetCONF_CFG_ECDSA_BLK(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xf0000)|value<<16)
}
func (o *EFUSE_Type) GetCONF_CFG_ECDSA_BLK() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0xf0000) >> 16
}

// EFUSE.STATUS: eFuse status register.
func (o *EFUSE_Type) SetSTATUS_STATE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xf)|value)
}
func (o *EFUSE_Type) GetSTATUS_STATE() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0xf
}
func (o *EFUSE_Type) SetSTATUS_OTP_LOAD_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *EFUSE_Type) GetSTATUS_OTP_LOAD_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *EFUSE_Type) SetSTATUS_OTP_VDDQ_C_SYNC2(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *EFUSE_Type) GetSTATUS_OTP_VDDQ_C_SYNC2() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *EFUSE_Type) SetSTATUS_OTP_STROBE_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *EFUSE_Type) GetSTATUS_OTP_STROBE_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *EFUSE_Type) SetSTATUS_OTP_CSB_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetSTATUS_OTP_CSB_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetSTATUS_OTP_PGENB_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetSTATUS_OTP_PGENB_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetSTATUS_OTP_VDDQ_IS_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *EFUSE_Type) GetSTATUS_OTP_VDDQ_IS_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *EFUSE_Type) SetSTATUS_BLK0_VALID_BIT_CNT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xffc00)|value<<10)
}
func (o *EFUSE_Type) GetSTATUS_BLK0_VALID_BIT_CNT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xffc00) >> 10
}
func (o *EFUSE_Type) SetSTATUS_CUR_ECDSA_BLK(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xf00000)|value<<20)
}
func (o *EFUSE_Type) GetSTATUS_CUR_ECDSA_BLK() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xf00000) >> 20
}

// EFUSE.CMD: eFuse command register.
func (o *EFUSE_Type) SetCMD_READ_CMD(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetCMD_READ_CMD() uint32 {
	return volatile.LoadUint32(&o.CMD.Reg) & 0x1
}
func (o *EFUSE_Type) SetCMD_PGM_CMD(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetCMD_PGM_CMD() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x2) >> 1
}
func (o *EFUSE_Type) SetCMD_BLK_NUM(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x3c)|value<<2)
}
func (o *EFUSE_Type) GetCMD_BLK_NUM() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x3c) >> 2
}

// EFUSE.INT_RAW: eFuse raw interrupt register.
func (o *EFUSE_Type) SetINT_RAW_READ_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetINT_RAW_READ_DONE_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *EFUSE_Type) SetINT_RAW_PGM_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetINT_RAW_PGM_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}

// EFUSE.INT_ST: eFuse interrupt status register.
func (o *EFUSE_Type) SetINT_ST_READ_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetINT_ST_READ_DONE_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *EFUSE_Type) SetINT_ST_PGM_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetINT_ST_PGM_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}

// EFUSE.INT_ENA: eFuse interrupt enable register.
func (o *EFUSE_Type) SetINT_ENA_READ_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetINT_ENA_READ_DONE_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *EFUSE_Type) SetINT_ENA_PGM_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetINT_ENA_PGM_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}

// EFUSE.INT_CLR: eFuse interrupt clear register.
func (o *EFUSE_Type) SetINT_CLR_READ_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetINT_CLR_READ_DONE_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *EFUSE_Type) SetINT_CLR_PGM_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetINT_CLR_PGM_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}

// EFUSE.DAC_CONF: Controls the eFuse programming voltage.
func (o *EFUSE_Type) SetDAC_CONF_DAC_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.DAC_CONF.Reg, volatile.LoadUint32(&o.DAC_CONF.Reg)&^(0xff)|value)
}
func (o *EFUSE_Type) GetDAC_CONF_DAC_CLK_DIV() uint32 {
	return volatile.LoadUint32(&o.DAC_CONF.Reg) & 0xff
}
func (o *EFUSE_Type) SetDAC_CONF_DAC_CLK_PAD_SEL(value uint32) {
	volatile.StoreUint32(&o.DAC_CONF.Reg, volatile.LoadUint32(&o.DAC_CONF.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetDAC_CONF_DAC_CLK_PAD_SEL() uint32 {
	return (volatile.LoadUint32(&o.DAC_CONF.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetDAC_CONF_DAC_NUM(value uint32) {
	volatile.StoreUint32(&o.DAC_CONF.Reg, volatile.LoadUint32(&o.DAC_CONF.Reg)&^(0x1fe00)|value<<9)
}
func (o *EFUSE_Type) GetDAC_CONF_DAC_NUM() uint32 {
	return (volatile.LoadUint32(&o.DAC_CONF.Reg) & 0x1fe00) >> 9
}
func (o *EFUSE_Type) SetDAC_CONF_OE_CLR(value uint32) {
	volatile.StoreUint32(&o.DAC_CONF.Reg, volatile.LoadUint32(&o.DAC_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *EFUSE_Type) GetDAC_CONF_OE_CLR() uint32 {
	return (volatile.LoadUint32(&o.DAC_CONF.Reg) & 0x20000) >> 17
}

// EFUSE.RD_TIM_CONF: Configures read timing parameters.
func (o *EFUSE_Type) SetRD_TIM_CONF_THR_A(value uint32) {
	volatile.StoreUint32(&o.RD_TIM_CONF.Reg, volatile.LoadUint32(&o.RD_TIM_CONF.Reg)&^(0xff)|value)
}
func (o *EFUSE_Type) GetRD_TIM_CONF_THR_A() uint32 {
	return volatile.LoadUint32(&o.RD_TIM_CONF.Reg) & 0xff
}
func (o *EFUSE_Type) SetRD_TIM_CONF_TRD(value uint32) {
	volatile.StoreUint32(&o.RD_TIM_CONF.Reg, volatile.LoadUint32(&o.RD_TIM_CONF.Reg)&^(0xff00)|value<<8)
}
func (o *EFUSE_Type) GetRD_TIM_CONF_TRD() uint32 {
	return (volatile.LoadUint32(&o.RD_TIM_CONF.Reg) & 0xff00) >> 8
}
func (o *EFUSE_Type) SetRD_TIM_CONF_TSUR_A(value uint32) {
	volatile.StoreUint32(&o.RD_TIM_CONF.Reg, volatile.LoadUint32(&o.RD_TIM_CONF.Reg)&^(0xff0000)|value<<16)
}
func (o *EFUSE_Type) GetRD_TIM_CONF_TSUR_A() uint32 {
	return (volatile.LoadUint32(&o.RD_TIM_CONF.Reg) & 0xff0000) >> 16
}
func (o *EFUSE_Type) SetRD_TIM_CONF_READ_INIT_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_TIM_CONF.Reg, volatile.LoadUint32(&o.RD_TIM_CONF.Reg)&^(0xff000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_TIM_CONF_READ_INIT_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_TIM_CONF.Reg) & 0xff000000) >> 24
}

// EFUSE.WR_TIM_CONF1: Configurarion register 1 of eFuse programming timing parameters.
func (o *EFUSE_Type) SetWR_TIM_CONF1_TSUP_A(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF1.Reg, volatile.LoadUint32(&o.WR_TIM_CONF1.Reg)&^(0xff)|value)
}
func (o *EFUSE_Type) GetWR_TIM_CONF1_TSUP_A() uint32 {
	return volatile.LoadUint32(&o.WR_TIM_CONF1.Reg) & 0xff
}
func (o *EFUSE_Type) SetWR_TIM_CONF1_PWR_ON_NUM(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF1.Reg, volatile.LoadUint32(&o.WR_TIM_CONF1.Reg)&^(0xffff00)|value<<8)
}
func (o *EFUSE_Type) GetWR_TIM_CONF1_PWR_ON_NUM() uint32 {
	return (volatile.LoadUint32(&o.WR_TIM_CONF1.Reg) & 0xffff00) >> 8
}
func (o *EFUSE_Type) SetWR_TIM_CONF1_THP_A(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF1.Reg, volatile.LoadUint32(&o.WR_TIM_CONF1.Reg)&^(0xff000000)|value<<24)
}
func (o *EFUSE_Type) GetWR_TIM_CONF1_THP_A() uint32 {
	return (volatile.LoadUint32(&o.WR_TIM_CONF1.Reg) & 0xff000000) >> 24
}

// EFUSE.WR_TIM_CONF2: Configurarion register 2 of eFuse programming timing parameters.
func (o *EFUSE_Type) SetWR_TIM_CONF2_PWR_OFF_NUM(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF2.Reg, volatile.LoadUint32(&o.WR_TIM_CONF2.Reg)&^(0xffff)|value)
}
func (o *EFUSE_Type) GetWR_TIM_CONF2_PWR_OFF_NUM() uint32 {
	return volatile.LoadUint32(&o.WR_TIM_CONF2.Reg) & 0xffff
}
func (o *EFUSE_Type) SetWR_TIM_CONF2_TPGM(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF2.Reg, volatile.LoadUint32(&o.WR_TIM_CONF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *EFUSE_Type) GetWR_TIM_CONF2_TPGM() uint32 {
	return (volatile.LoadUint32(&o.WR_TIM_CONF2.Reg) & 0xffff0000) >> 16
}

// EFUSE.WR_TIM_CONF0_RS_BYPASS: Configurarion register0 of eFuse programming time parameters and rs bypass operation.
func (o *EFUSE_Type) SetWR_TIM_CONF0_RS_BYPASS_BYPASS_RS_CORRECTION(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF0_RS_BYPASS.Reg, volatile.LoadUint32(&o.WR_TIM_CONF0_RS_BYPASS.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetWR_TIM_CONF0_RS_BYPASS_BYPASS_RS_CORRECTION() uint32 {
	return volatile.LoadUint32(&o.WR_TIM_CONF0_RS_BYPASS.Reg) & 0x1
}
func (o *EFUSE_Type) SetWR_TIM_CONF0_RS_BYPASS_BYPASS_RS_BLK_NUM(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF0_RS_BYPASS.Reg, volatile.LoadUint32(&o.WR_TIM_CONF0_RS_BYPASS.Reg)&^(0xffe)|value<<1)
}
func (o *EFUSE_Type) GetWR_TIM_CONF0_RS_BYPASS_BYPASS_RS_BLK_NUM() uint32 {
	return (volatile.LoadUint32(&o.WR_TIM_CONF0_RS_BYPASS.Reg) & 0xffe) >> 1
}
func (o *EFUSE_Type) SetWR_TIM_CONF0_RS_BYPASS_UPDATE(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF0_RS_BYPASS.Reg, volatile.LoadUint32(&o.WR_TIM_CONF0_RS_BYPASS.Reg)&^(0x1000)|value<<12)
}
func (o *EFUSE_Type) GetWR_TIM_CONF0_RS_BYPASS_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.WR_TIM_CONF0_RS_BYPASS.Reg) & 0x1000) >> 12
}
func (o *EFUSE_Type) SetWR_TIM_CONF0_RS_BYPASS_TPGM_INACTIVE(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF0_RS_BYPASS.Reg, volatile.LoadUint32(&o.WR_TIM_CONF0_RS_BYPASS.Reg)&^(0x1fe000)|value<<13)
}
func (o *EFUSE_Type) GetWR_TIM_CONF0_RS_BYPASS_TPGM_INACTIVE() uint32 {
	return (volatile.LoadUint32(&o.WR_TIM_CONF0_RS_BYPASS.Reg) & 0x1fe000) >> 13
}

// EFUSE.DATE: eFuse version register.
func (o *EFUSE_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *EFUSE_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// General Purpose Input/Output
type GPIO_Type struct {
	BT_SELECT          volatile.Register32 // 0x0
	OUT                volatile.Register32 // 0x4
	OUT_W1TS           volatile.Register32 // 0x8
	OUT_W1TC           volatile.Register32 // 0xC
	_                  [12]byte
	SDIO_SELECT        volatile.Register32 // 0x1C
	ENABLE             volatile.Register32 // 0x20
	ENABLE_W1TS        volatile.Register32 // 0x24
	ENABLE_W1TC        volatile.Register32 // 0x28
	_                  [12]byte
	STRAP              volatile.Register32 // 0x38
	IN                 volatile.Register32 // 0x3C
	_                  [4]byte
	STATUS             volatile.Register32 // 0x44
	STATUS_W1TS        volatile.Register32 // 0x48
	STATUS_W1TC        volatile.Register32 // 0x4C
	_                  [12]byte
	PCPU_INT           volatile.Register32 // 0x5C
	PCPU_NMI_INT       volatile.Register32 // 0x60
	CPUSDIO_INT        volatile.Register32 // 0x64
	_                  [12]byte
	PIN0               volatile.Register32 // 0x74
	PIN1               volatile.Register32 // 0x78
	PIN2               volatile.Register32 // 0x7C
	PIN3               volatile.Register32 // 0x80
	PIN4               volatile.Register32 // 0x84
	PIN5               volatile.Register32 // 0x88
	PIN6               volatile.Register32 // 0x8C
	PIN7               volatile.Register32 // 0x90
	PIN8               volatile.Register32 // 0x94
	PIN9               volatile.Register32 // 0x98
	PIN10              volatile.Register32 // 0x9C
	PIN11              volatile.Register32 // 0xA0
	PIN12              volatile.Register32 // 0xA4
	PIN13              volatile.Register32 // 0xA8
	PIN14              volatile.Register32 // 0xAC
	PIN15              volatile.Register32 // 0xB0
	PIN16              volatile.Register32 // 0xB4
	PIN17              volatile.Register32 // 0xB8
	PIN18              volatile.Register32 // 0xBC
	PIN19              volatile.Register32 // 0xC0
	PIN20              volatile.Register32 // 0xC4
	PIN21              volatile.Register32 // 0xC8
	PIN22              volatile.Register32 // 0xCC
	PIN23              volatile.Register32 // 0xD0
	PIN24              volatile.Register32 // 0xD4
	PIN25              volatile.Register32 // 0xD8
	PIN26              volatile.Register32 // 0xDC
	PIN27              volatile.Register32 // 0xE0
	PIN28              volatile.Register32 // 0xE4
	PIN29              volatile.Register32 // 0xE8
	PIN30              volatile.Register32 // 0xEC
	PIN31              volatile.Register32 // 0xF0
	_                  [88]byte
	STATUS_NEXT        volatile.Register32 // 0x14C
	_                  [4]byte
	FUNC0_IN_SEL_CFG   volatile.Register32 // 0x154
	FUNC1_IN_SEL_CFG   volatile.Register32 // 0x158
	FUNC2_IN_SEL_CFG   volatile.Register32 // 0x15C
	FUNC3_IN_SEL_CFG   volatile.Register32 // 0x160
	FUNC4_IN_SEL_CFG   volatile.Register32 // 0x164
	FUNC5_IN_SEL_CFG   volatile.Register32 // 0x168
	FUNC6_IN_SEL_CFG   volatile.Register32 // 0x16C
	FUNC7_IN_SEL_CFG   volatile.Register32 // 0x170
	FUNC8_IN_SEL_CFG   volatile.Register32 // 0x174
	FUNC9_IN_SEL_CFG   volatile.Register32 // 0x178
	FUNC10_IN_SEL_CFG  volatile.Register32 // 0x17C
	FUNC11_IN_SEL_CFG  volatile.Register32 // 0x180
	FUNC12_IN_SEL_CFG  volatile.Register32 // 0x184
	FUNC13_IN_SEL_CFG  volatile.Register32 // 0x188
	FUNC14_IN_SEL_CFG  volatile.Register32 // 0x18C
	FUNC15_IN_SEL_CFG  volatile.Register32 // 0x190
	FUNC16_IN_SEL_CFG  volatile.Register32 // 0x194
	FUNC17_IN_SEL_CFG  volatile.Register32 // 0x198
	FUNC18_IN_SEL_CFG  volatile.Register32 // 0x19C
	FUNC19_IN_SEL_CFG  volatile.Register32 // 0x1A0
	FUNC20_IN_SEL_CFG  volatile.Register32 // 0x1A4
	FUNC21_IN_SEL_CFG  volatile.Register32 // 0x1A8
	FUNC22_IN_SEL_CFG  volatile.Register32 // 0x1AC
	FUNC23_IN_SEL_CFG  volatile.Register32 // 0x1B0
	FUNC24_IN_SEL_CFG  volatile.Register32 // 0x1B4
	FUNC25_IN_SEL_CFG  volatile.Register32 // 0x1B8
	FUNC26_IN_SEL_CFG  volatile.Register32 // 0x1BC
	FUNC27_IN_SEL_CFG  volatile.Register32 // 0x1C0
	FUNC28_IN_SEL_CFG  volatile.Register32 // 0x1C4
	FUNC29_IN_SEL_CFG  volatile.Register32 // 0x1C8
	FUNC30_IN_SEL_CFG  volatile.Register32 // 0x1CC
	FUNC31_IN_SEL_CFG  volatile.Register32 // 0x1D0
	FUNC32_IN_SEL_CFG  volatile.Register32 // 0x1D4
	FUNC33_IN_SEL_CFG  volatile.Register32 // 0x1D8
	FUNC34_IN_SEL_CFG  volatile.Register32 // 0x1DC
	FUNC35_IN_SEL_CFG  volatile.Register32 // 0x1E0
	FUNC36_IN_SEL_CFG  volatile.Register32 // 0x1E4
	FUNC37_IN_SEL_CFG  volatile.Register32 // 0x1E8
	FUNC38_IN_SEL_CFG  volatile.Register32 // 0x1EC
	FUNC39_IN_SEL_CFG  volatile.Register32 // 0x1F0
	FUNC40_IN_SEL_CFG  volatile.Register32 // 0x1F4
	FUNC41_IN_SEL_CFG  volatile.Register32 // 0x1F8
	FUNC42_IN_SEL_CFG  volatile.Register32 // 0x1FC
	FUNC43_IN_SEL_CFG  volatile.Register32 // 0x200
	FUNC44_IN_SEL_CFG  volatile.Register32 // 0x204
	FUNC45_IN_SEL_CFG  volatile.Register32 // 0x208
	FUNC46_IN_SEL_CFG  volatile.Register32 // 0x20C
	FUNC47_IN_SEL_CFG  volatile.Register32 // 0x210
	FUNC48_IN_SEL_CFG  volatile.Register32 // 0x214
	FUNC49_IN_SEL_CFG  volatile.Register32 // 0x218
	FUNC50_IN_SEL_CFG  volatile.Register32 // 0x21C
	FUNC51_IN_SEL_CFG  volatile.Register32 // 0x220
	FUNC52_IN_SEL_CFG  volatile.Register32 // 0x224
	FUNC53_IN_SEL_CFG  volatile.Register32 // 0x228
	FUNC54_IN_SEL_CFG  volatile.Register32 // 0x22C
	FUNC55_IN_SEL_CFG  volatile.Register32 // 0x230
	FUNC56_IN_SEL_CFG  volatile.Register32 // 0x234
	FUNC57_IN_SEL_CFG  volatile.Register32 // 0x238
	FUNC58_IN_SEL_CFG  volatile.Register32 // 0x23C
	FUNC59_IN_SEL_CFG  volatile.Register32 // 0x240
	FUNC60_IN_SEL_CFG  volatile.Register32 // 0x244
	FUNC61_IN_SEL_CFG  volatile.Register32 // 0x248
	FUNC62_IN_SEL_CFG  volatile.Register32 // 0x24C
	FUNC63_IN_SEL_CFG  volatile.Register32 // 0x250
	FUNC64_IN_SEL_CFG  volatile.Register32 // 0x254
	FUNC65_IN_SEL_CFG  volatile.Register32 // 0x258
	FUNC66_IN_SEL_CFG  volatile.Register32 // 0x25C
	FUNC67_IN_SEL_CFG  volatile.Register32 // 0x260
	FUNC68_IN_SEL_CFG  volatile.Register32 // 0x264
	FUNC69_IN_SEL_CFG  volatile.Register32 // 0x268
	FUNC70_IN_SEL_CFG  volatile.Register32 // 0x26C
	FUNC71_IN_SEL_CFG  volatile.Register32 // 0x270
	FUNC72_IN_SEL_CFG  volatile.Register32 // 0x274
	FUNC73_IN_SEL_CFG  volatile.Register32 // 0x278
	FUNC74_IN_SEL_CFG  volatile.Register32 // 0x27C
	FUNC75_IN_SEL_CFG  volatile.Register32 // 0x280
	FUNC76_IN_SEL_CFG  volatile.Register32 // 0x284
	FUNC77_IN_SEL_CFG  volatile.Register32 // 0x288
	FUNC78_IN_SEL_CFG  volatile.Register32 // 0x28C
	FUNC79_IN_SEL_CFG  volatile.Register32 // 0x290
	FUNC80_IN_SEL_CFG  volatile.Register32 // 0x294
	FUNC81_IN_SEL_CFG  volatile.Register32 // 0x298
	FUNC82_IN_SEL_CFG  volatile.Register32 // 0x29C
	FUNC83_IN_SEL_CFG  volatile.Register32 // 0x2A0
	FUNC84_IN_SEL_CFG  volatile.Register32 // 0x2A4
	FUNC85_IN_SEL_CFG  volatile.Register32 // 0x2A8
	FUNC86_IN_SEL_CFG  volatile.Register32 // 0x2AC
	FUNC87_IN_SEL_CFG  volatile.Register32 // 0x2B0
	FUNC88_IN_SEL_CFG  volatile.Register32 // 0x2B4
	FUNC89_IN_SEL_CFG  volatile.Register32 // 0x2B8
	FUNC90_IN_SEL_CFG  volatile.Register32 // 0x2BC
	FUNC91_IN_SEL_CFG  volatile.Register32 // 0x2C0
	FUNC92_IN_SEL_CFG  volatile.Register32 // 0x2C4
	FUNC93_IN_SEL_CFG  volatile.Register32 // 0x2C8
	FUNC94_IN_SEL_CFG  volatile.Register32 // 0x2CC
	FUNC95_IN_SEL_CFG  volatile.Register32 // 0x2D0
	FUNC96_IN_SEL_CFG  volatile.Register32 // 0x2D4
	FUNC97_IN_SEL_CFG  volatile.Register32 // 0x2D8
	FUNC98_IN_SEL_CFG  volatile.Register32 // 0x2DC
	FUNC99_IN_SEL_CFG  volatile.Register32 // 0x2E0
	FUNC100_IN_SEL_CFG volatile.Register32 // 0x2E4
	FUNC101_IN_SEL_CFG volatile.Register32 // 0x2E8
	FUNC102_IN_SEL_CFG volatile.Register32 // 0x2EC
	FUNC103_IN_SEL_CFG volatile.Register32 // 0x2F0
	FUNC104_IN_SEL_CFG volatile.Register32 // 0x2F4
	FUNC105_IN_SEL_CFG volatile.Register32 // 0x2F8
	FUNC106_IN_SEL_CFG volatile.Register32 // 0x2FC
	FUNC107_IN_SEL_CFG volatile.Register32 // 0x300
	FUNC108_IN_SEL_CFG volatile.Register32 // 0x304
	FUNC109_IN_SEL_CFG volatile.Register32 // 0x308
	FUNC110_IN_SEL_CFG volatile.Register32 // 0x30C
	FUNC111_IN_SEL_CFG volatile.Register32 // 0x310
	FUNC112_IN_SEL_CFG volatile.Register32 // 0x314
	FUNC113_IN_SEL_CFG volatile.Register32 // 0x318
	FUNC114_IN_SEL_CFG volatile.Register32 // 0x31C
	FUNC115_IN_SEL_CFG volatile.Register32 // 0x320
	FUNC116_IN_SEL_CFG volatile.Register32 // 0x324
	FUNC117_IN_SEL_CFG volatile.Register32 // 0x328
	FUNC118_IN_SEL_CFG volatile.Register32 // 0x32C
	FUNC119_IN_SEL_CFG volatile.Register32 // 0x330
	FUNC120_IN_SEL_CFG volatile.Register32 // 0x334
	FUNC121_IN_SEL_CFG volatile.Register32 // 0x338
	FUNC122_IN_SEL_CFG volatile.Register32 // 0x33C
	FUNC123_IN_SEL_CFG volatile.Register32 // 0x340
	FUNC124_IN_SEL_CFG volatile.Register32 // 0x344
	FUNC125_IN_SEL_CFG volatile.Register32 // 0x348
	FUNC126_IN_SEL_CFG volatile.Register32 // 0x34C
	FUNC127_IN_SEL_CFG volatile.Register32 // 0x350
	_                  [512]byte
	FUNC0_OUT_SEL_CFG  volatile.Register32 // 0x554
	FUNC1_OUT_SEL_CFG  volatile.Register32 // 0x558
	FUNC2_OUT_SEL_CFG  volatile.Register32 // 0x55C
	FUNC3_OUT_SEL_CFG  volatile.Register32 // 0x560
	FUNC4_OUT_SEL_CFG  volatile.Register32 // 0x564
	FUNC5_OUT_SEL_CFG  volatile.Register32 // 0x568
	FUNC6_OUT_SEL_CFG  volatile.Register32 // 0x56C
	FUNC7_OUT_SEL_CFG  volatile.Register32 // 0x570
	FUNC8_OUT_SEL_CFG  volatile.Register32 // 0x574
	FUNC9_OUT_SEL_CFG  volatile.Register32 // 0x578
	FUNC10_OUT_SEL_CFG volatile.Register32 // 0x57C
	FUNC11_OUT_SEL_CFG volatile.Register32 // 0x580
	FUNC12_OUT_SEL_CFG volatile.Register32 // 0x584
	FUNC13_OUT_SEL_CFG volatile.Register32 // 0x588
	FUNC14_OUT_SEL_CFG volatile.Register32 // 0x58C
	FUNC15_OUT_SEL_CFG volatile.Register32 // 0x590
	FUNC16_OUT_SEL_CFG volatile.Register32 // 0x594
	FUNC17_OUT_SEL_CFG volatile.Register32 // 0x598
	FUNC18_OUT_SEL_CFG volatile.Register32 // 0x59C
	FUNC19_OUT_SEL_CFG volatile.Register32 // 0x5A0
	FUNC20_OUT_SEL_CFG volatile.Register32 // 0x5A4
	FUNC21_OUT_SEL_CFG volatile.Register32 // 0x5A8
	FUNC22_OUT_SEL_CFG volatile.Register32 // 0x5AC
	FUNC23_OUT_SEL_CFG volatile.Register32 // 0x5B0
	FUNC24_OUT_SEL_CFG volatile.Register32 // 0x5B4
	FUNC25_OUT_SEL_CFG volatile.Register32 // 0x5B8
	FUNC26_OUT_SEL_CFG volatile.Register32 // 0x5BC
	FUNC27_OUT_SEL_CFG volatile.Register32 // 0x5C0
	FUNC28_OUT_SEL_CFG volatile.Register32 // 0x5C4
	FUNC29_OUT_SEL_CFG volatile.Register32 // 0x5C8
	_                  [96]byte
	CLOCK_GATE         volatile.Register32 // 0x62C
	_                  [204]byte
	DATE               volatile.Register32 // 0x6FC
}

// GPIO.BT_SELECT: GPIO bit select register
func (o *GPIO_Type) SetBT_SELECT(value uint32) {
	volatile.StoreUint32(&o.BT_SELECT.Reg, value)
}
func (o *GPIO_Type) GetBT_SELECT() uint32 {
	return volatile.LoadUint32(&o.BT_SELECT.Reg)
}

// GPIO.OUT: GPIO output register for GPIO0-31
func (o *GPIO_Type) SetOUT(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, value)
}
func (o *GPIO_Type) GetOUT() uint32 {
	return volatile.LoadUint32(&o.OUT.Reg)
}

// GPIO.OUT_W1TS: GPIO output set register for GPIO0-31
func (o *GPIO_Type) SetOUT_W1TS(value uint32) {
	volatile.StoreUint32(&o.OUT_W1TS.Reg, value)
}
func (o *GPIO_Type) GetOUT_W1TS() uint32 {
	return volatile.LoadUint32(&o.OUT_W1TS.Reg)
}

// GPIO.OUT_W1TC: GPIO output clear register for GPIO0-31
func (o *GPIO_Type) SetOUT_W1TC(value uint32) {
	volatile.StoreUint32(&o.OUT_W1TC.Reg, value)
}
func (o *GPIO_Type) GetOUT_W1TC() uint32 {
	return volatile.LoadUint32(&o.OUT_W1TC.Reg)
}

// GPIO.SDIO_SELECT: GPIO sdio select register
func (o *GPIO_Type) SetSDIO_SELECT_SDIO_SEL(value uint32) {
	volatile.StoreUint32(&o.SDIO_SELECT.Reg, volatile.LoadUint32(&o.SDIO_SELECT.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetSDIO_SELECT_SDIO_SEL() uint32 {
	return volatile.LoadUint32(&o.SDIO_SELECT.Reg) & 0xff
}

// GPIO.ENABLE: GPIO output enable register for GPIO0-31
func (o *GPIO_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, value)
}
func (o *GPIO_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg)
}

// GPIO.ENABLE_W1TS: GPIO output enable set register for GPIO0-31
func (o *GPIO_Type) SetENABLE_W1TS(value uint32) {
	volatile.StoreUint32(&o.ENABLE_W1TS.Reg, value)
}
func (o *GPIO_Type) GetENABLE_W1TS() uint32 {
	return volatile.LoadUint32(&o.ENABLE_W1TS.Reg)
}

// GPIO.ENABLE_W1TC: GPIO output enable clear register for GPIO0-31
func (o *GPIO_Type) SetENABLE_W1TC(value uint32) {
	volatile.StoreUint32(&o.ENABLE_W1TC.Reg, value)
}
func (o *GPIO_Type) GetENABLE_W1TC() uint32 {
	return volatile.LoadUint32(&o.ENABLE_W1TC.Reg)
}

// GPIO.STRAP: pad strapping register
func (o *GPIO_Type) SetSTRAP_STRAPPING(value uint32) {
	volatile.StoreUint32(&o.STRAP.Reg, volatile.LoadUint32(&o.STRAP.Reg)&^(0xffff)|value)
}
func (o *GPIO_Type) GetSTRAP_STRAPPING() uint32 {
	return volatile.LoadUint32(&o.STRAP.Reg) & 0xffff
}

// GPIO.IN: GPIO input register for GPIO0-31
func (o *GPIO_Type) SetIN(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, value)
}
func (o *GPIO_Type) GetIN() uint32 {
	return volatile.LoadUint32(&o.IN.Reg)
}

// GPIO.STATUS: GPIO interrupt status register for GPIO0-31
func (o *GPIO_Type) SetSTATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, value)
}
func (o *GPIO_Type) GetSTATUS() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg)
}

// GPIO.STATUS_W1TS: GPIO interrupt status set register for GPIO0-31
func (o *GPIO_Type) SetSTATUS_W1TS(value uint32) {
	volatile.StoreUint32(&o.STATUS_W1TS.Reg, value)
}
func (o *GPIO_Type) GetSTATUS_W1TS() uint32 {
	return volatile.LoadUint32(&o.STATUS_W1TS.Reg)
}

// GPIO.STATUS_W1TC: GPIO interrupt status clear register for GPIO0-31
func (o *GPIO_Type) SetSTATUS_W1TC(value uint32) {
	volatile.StoreUint32(&o.STATUS_W1TC.Reg, value)
}
func (o *GPIO_Type) GetSTATUS_W1TC() uint32 {
	return volatile.LoadUint32(&o.STATUS_W1TC.Reg)
}

// GPIO.PCPU_INT: GPIO PRO_CPU interrupt status register for GPIO0-31
func (o *GPIO_Type) SetPCPU_INT(value uint32) {
	volatile.StoreUint32(&o.PCPU_INT.Reg, value)
}
func (o *GPIO_Type) GetPCPU_INT() uint32 {
	return volatile.LoadUint32(&o.PCPU_INT.Reg)
}

// GPIO.PCPU_NMI_INT: GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-31
func (o *GPIO_Type) SetPCPU_NMI_INT(value uint32) {
	volatile.StoreUint32(&o.PCPU_NMI_INT.Reg, value)
}
func (o *GPIO_Type) GetPCPU_NMI_INT() uint32 {
	return volatile.LoadUint32(&o.PCPU_NMI_INT.Reg)
}

// GPIO.CPUSDIO_INT: GPIO CPUSDIO interrupt status register for GPIO0-31
func (o *GPIO_Type) SetCPUSDIO_INT(value uint32) {
	volatile.StoreUint32(&o.CPUSDIO_INT.Reg, value)
}
func (o *GPIO_Type) GetCPUSDIO_INT() uint32 {
	return volatile.LoadUint32(&o.CPUSDIO_INT.Reg)
}

// GPIO.PIN0: GPIO pin configuration register
func (o *GPIO_Type) SetPIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN0.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x3e000) >> 13
}

// GPIO.PIN1: GPIO pin configuration register
func (o *GPIO_Type) SetPIN1_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN1_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN1.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN1_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN1_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN1_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN1_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN1_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN1_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN1_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN1_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN1_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN1_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x3e000) >> 13
}

// GPIO.PIN2: GPIO pin configuration register
func (o *GPIO_Type) SetPIN2_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN2_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN2.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN2_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN2_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN2_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN2_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN2_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN2_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN2_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN2_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN2_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN2_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x3e000) >> 13
}

// GPIO.PIN3: GPIO pin configuration register
func (o *GPIO_Type) SetPIN3_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN3_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN3.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN3_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN3_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN3_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN3_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN3_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN3_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN3_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN3_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN3_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN3_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN3_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN3_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x3e000) >> 13
}

// GPIO.PIN4: GPIO pin configuration register
func (o *GPIO_Type) SetPIN4_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN4_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN4.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN4_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN4_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN4_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN4_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN4_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN4_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN4_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN4_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN4_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN4_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN4_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN4_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x3e000) >> 13
}

// GPIO.PIN5: GPIO pin configuration register
func (o *GPIO_Type) SetPIN5_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN5_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN5.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN5_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN5_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN5_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN5_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN5_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN5_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN5_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN5_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN5_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN5_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN5_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN5_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x3e000) >> 13
}

// GPIO.PIN6: GPIO pin configuration register
func (o *GPIO_Type) SetPIN6_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN6_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN6.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN6_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN6_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN6_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN6_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN6_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN6_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN6_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN6_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN6_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN6_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN6_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN6_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x3e000) >> 13
}

// GPIO.PIN7: GPIO pin configuration register
func (o *GPIO_Type) SetPIN7_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN7_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN7.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN7_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN7_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN7_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN7_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN7_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN7_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN7_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN7_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN7_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN7_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN7_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN7_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x3e000) >> 13
}

// GPIO.PIN8: GPIO pin configuration register
func (o *GPIO_Type) SetPIN8_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN8_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN8.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN8_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN8_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN8_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN8_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN8_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN8_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN8_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN8_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN8_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN8_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN8_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN8_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x3e000) >> 13
}

// GPIO.PIN9: GPIO pin configuration register
func (o *GPIO_Type) SetPIN9_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN9_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN9.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN9_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN9_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN9_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN9_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN9_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN9_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN9_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN9_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN9_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN9_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN9_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN9_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x3e000) >> 13
}

// GPIO.PIN10: GPIO pin configuration register
func (o *GPIO_Type) SetPIN10_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN10_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN10.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN10_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN10_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN10_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN10_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN10_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN10_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN10_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN10_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN10_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN10_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN10_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN10_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x3e000) >> 13
}

// GPIO.PIN11: GPIO pin configuration register
func (o *GPIO_Type) SetPIN11_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN11_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN11.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN11_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN11_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN11_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN11_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN11_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN11_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN11_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN11_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN11_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN11_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN11_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN11_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x3e000) >> 13
}

// GPIO.PIN12: GPIO pin configuration register
func (o *GPIO_Type) SetPIN12_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN12_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN12.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN12_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN12_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN12_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN12_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN12_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN12_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN12_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN12_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN12_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN12_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN12_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN12_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x3e000) >> 13
}

// GPIO.PIN13: GPIO pin configuration register
func (o *GPIO_Type) SetPIN13_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN13_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN13.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN13_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN13_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN13_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN13_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN13_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN13_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN13_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN13_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN13_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN13_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN13_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN13_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x3e000) >> 13
}

// GPIO.PIN14: GPIO pin configuration register
func (o *GPIO_Type) SetPIN14_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN14_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN14.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN14_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN14_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN14_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN14_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN14_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN14_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN14_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN14_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN14_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN14_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN14_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN14_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x3e000) >> 13
}

// GPIO.PIN15: GPIO pin configuration register
func (o *GPIO_Type) SetPIN15_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN15_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN15.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN15_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN15_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN15_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN15_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN15_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN15_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN15_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN15_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN15_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN15_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN15_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN15_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x3e000) >> 13
}

// GPIO.PIN16: GPIO pin configuration register
func (o *GPIO_Type) SetPIN16_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN16_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN16.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN16_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN16_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN16_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN16_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN16_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN16_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN16_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN16_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN16_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN16_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN16_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN16_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x3e000) >> 13
}

// GPIO.PIN17: GPIO pin configuration register
func (o *GPIO_Type) SetPIN17_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN17_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN17.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN17_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN17_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN17_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN17_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN17_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN17_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN17_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN17_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN17_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN17_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN17_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN17_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x3e000) >> 13
}

// GPIO.PIN18: GPIO pin configuration register
func (o *GPIO_Type) SetPIN18_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN18_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN18.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN18_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN18_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN18_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN18_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN18_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN18_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN18_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN18_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN18_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN18_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN18_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN18_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x3e000) >> 13
}

// GPIO.PIN19: GPIO pin configuration register
func (o *GPIO_Type) SetPIN19_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN19_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN19.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN19_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN19_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN19_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN19_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN19_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN19_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN19_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN19_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN19_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN19_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN19_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN19_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x3e000) >> 13
}

// GPIO.PIN20: GPIO pin configuration register
func (o *GPIO_Type) SetPIN20_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN20_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN20.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN20_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN20_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN20_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN20_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN20_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN20_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN20_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN20_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN20_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN20_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN20_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN20_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x3e000) >> 13
}

// GPIO.PIN21: GPIO pin configuration register
func (o *GPIO_Type) SetPIN21_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN21_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN21.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN21_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN21_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN21_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN21_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN21_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN21_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN21_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN21_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN21_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN21_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN21_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN21_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x3e000) >> 13
}

// GPIO.PIN22: GPIO pin configuration register
func (o *GPIO_Type) SetPIN22_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN22_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN22.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN22_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN22_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN22_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN22_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN22_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN22_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN22_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN22_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN22_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN22_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN22_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN22_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x3e000) >> 13
}

// GPIO.PIN23: GPIO pin configuration register
func (o *GPIO_Type) SetPIN23_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN23_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN23.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN23_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN23_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN23_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN23_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN23_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN23_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN23_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN23_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN23_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN23_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN23_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN23_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x3e000) >> 13
}

// GPIO.PIN24: GPIO pin configuration register
func (o *GPIO_Type) SetPIN24_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN24_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN24.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN24_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN24_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN24_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN24_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN24_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN24_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN24_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN24_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN24_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN24_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN24_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN24_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x3e000) >> 13
}

// GPIO.PIN25: GPIO pin configuration register
func (o *GPIO_Type) SetPIN25_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN25_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN25.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN25_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN25_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN25_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN25_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN25_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN25_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN25_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN25_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN25_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN25_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN25_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN25_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x3e000) >> 13
}

// GPIO.PIN26: GPIO pin configuration register
func (o *GPIO_Type) SetPIN26_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN26_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN26.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN26_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN26_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN26_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN26_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN26_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN26_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN26_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN26_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN26_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN26_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN26_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN26_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x3e000) >> 13
}

// GPIO.PIN27: GPIO pin configuration register
func (o *GPIO_Type) SetPIN27_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN27_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN27.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN27_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN27_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN27_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN27_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN27_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN27_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN27_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN27_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN27_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN27_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN27_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN27_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x3e000) >> 13
}

// GPIO.PIN28: GPIO pin configuration register
func (o *GPIO_Type) SetPIN28_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN28_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN28.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN28_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN28_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN28_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN28_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN28_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN28_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN28_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN28_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN28_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN28_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN28_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN28_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x3e000) >> 13
}

// GPIO.PIN29: GPIO pin configuration register
func (o *GPIO_Type) SetPIN29_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN29_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN29.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN29_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN29_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN29_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN29_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN29_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN29_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN29_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN29_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN29_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN29_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN29_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN29_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x3e000) >> 13
}

// GPIO.PIN30: GPIO pin configuration register
func (o *GPIO_Type) SetPIN30_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN30_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN30.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN30_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN30_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN30_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN30_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN30_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN30_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN30_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN30_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN30_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN30_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN30_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN30_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x3e000) >> 13
}

// GPIO.PIN31: GPIO pin configuration register
func (o *GPIO_Type) SetPIN31_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN31_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN31.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN31_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN31_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN31_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN31_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN31_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN31_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN31_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN31_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN31_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN31_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN31_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN31_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x3e000) >> 13
}

// GPIO.STATUS_NEXT: GPIO interrupt source register for GPIO0-31
func (o *GPIO_Type) SetSTATUS_NEXT(value uint32) {
	volatile.StoreUint32(&o.STATUS_NEXT.Reg, value)
}
func (o *GPIO_Type) GetSTATUS_NEXT() uint32 {
	return volatile.LoadUint32(&o.STATUS_NEXT.Reg)
}

// GPIO.FUNC0_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC0_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC0_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC0_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC0_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC0_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC0_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC1_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC1_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC1_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC1_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC1_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC1_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC1_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC2_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC2_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC2_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC2_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC2_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC2_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC2_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC3_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC3_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC3_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC3_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC3_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC3_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC3_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC4_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC4_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC4_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC4_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC4_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC4_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC4_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC5_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC5_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC5_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC5_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC5_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC5_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC5_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC6_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC6_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC6_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC6_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC6_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC6_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC6_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC7_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC7_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC7_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC7_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC7_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC7_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC7_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC8_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC8_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC8_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC8_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC8_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC8_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC8_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC9_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC9_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC9_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC9_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC9_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC9_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC9_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC10_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC10_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC10_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC10_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC10_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC10_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC10_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC11_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC11_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC11_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC11_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC11_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC11_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC11_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC12_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC12_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC12_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC12_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC12_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC12_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC12_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC13_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC13_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC13_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC13_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC13_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC13_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC13_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC14_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC14_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC14_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC14_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC14_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC14_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC14_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC15_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC15_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC15_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC15_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC15_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC15_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC15_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC16_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC16_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC16_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC16_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC16_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC16_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC16_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC17_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC17_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC17_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC17_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC17_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC17_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC17_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC18_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC18_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC18_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC18_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC18_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC18_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC18_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC19_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC19_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC19_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC19_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC19_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC19_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC19_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC20_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC20_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC20_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC20_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC20_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC20_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC20_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC21_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC21_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC21_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC21_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC21_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC21_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC21_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC22_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC22_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC22_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC22_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC22_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC22_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC22_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC23_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC23_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC23_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC23_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC23_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC23_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC23_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC24_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC24_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC24_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC24_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC24_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC24_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC24_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC25_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC25_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC25_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC25_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC25_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC25_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC25_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC26_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC26_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC26_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC26_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC26_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC26_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC26_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC27_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC27_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC27_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC27_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC27_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC27_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC27_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC28_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC28_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC28_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC28_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC28_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC28_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC28_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC29_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC29_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC29_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC29_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC29_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC29_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC29_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC30_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC30_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC30_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC30_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC30_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC30_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC30_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC31_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC31_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC31_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC31_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC31_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC31_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC31_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC32_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC32_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC32_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC32_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC32_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC32_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC32_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC33_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC33_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC33_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC33_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC33_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC33_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC33_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC34_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC34_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC34_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC34_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC34_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC34_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC34_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC35_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC35_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC35_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC35_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC35_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC35_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC35_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC36_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC36_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC36_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC36_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC36_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC36_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC36_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC37_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC37_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC37_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC37_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC37_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC37_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC37_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC38_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC38_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC38_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC38_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC38_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC38_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC38_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC39_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC39_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC39_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC39_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC39_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC39_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC39_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC40_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC40_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC40_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC40_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC40_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC40_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC40_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC41_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC41_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC41_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC41_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC41_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC41_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC41_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC42_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC42_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC42_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC42_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC42_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC42_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC42_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC43_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC43_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC43_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC43_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC43_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC43_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC43_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC44_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC44_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC44_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC44_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC44_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC44_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC44_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC45_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC45_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC45_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC45_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC45_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC45_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC45_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC46_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC46_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC46_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC46_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC46_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC46_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC46_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC47_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC47_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC47_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC47_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC47_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC47_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC47_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC48_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC48_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC48_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC48_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC48_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC48_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC48_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC49_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC49_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC49_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC49_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC49_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC49_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC49_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC50_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC50_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC50_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC50_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC50_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC50_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC50_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC51_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC51_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC51_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC51_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC51_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC51_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC51_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC52_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC52_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC52_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC52_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC52_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC52_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC52_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC53_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC53_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC53_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC53_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC53_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC53_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC53_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC54_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC54_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC54_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC54_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC54_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC54_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC54_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC54_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC54_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC54_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC55_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC55_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC55_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC55_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC55_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC55_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC55_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC55_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC55_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC55_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC56_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC56_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC56_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC56_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC56_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC56_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC56_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC56_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC56_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC56_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC57_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC57_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC57_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC57_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC57_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC57_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC57_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC57_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC57_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC57_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC58_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC58_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC58_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC58_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC58_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC58_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC58_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC58_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC58_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC58_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC59_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC59_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC59_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC59_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC59_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC59_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC59_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC59_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC59_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC59_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC60_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC60_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC60_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC60_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC60_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC60_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC60_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC60_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC60_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC60_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC61_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC61_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC61_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC61_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC61_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC61_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC61_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC61_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC61_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC61_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC62_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC62_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC62_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC62_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC62_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC62_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC62_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC62_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC62_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC62_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC63_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC63_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC63_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC63_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC63_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC63_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC63_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC63_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC63_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC63_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC64_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC64_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC64_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC64_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC64_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC64_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC64_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC64_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC64_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC64_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC65_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC65_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC65_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC65_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC65_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC65_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC65_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC65_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC65_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC65_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC66_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC66_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC66_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC66_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC66_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC66_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC66_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC66_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC66_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC66_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC67_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC67_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC67_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC67_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC67_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC67_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC67_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC67_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC67_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC67_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC68_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC68_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC68_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC68_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC68_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC68_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC68_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC68_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC68_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC68_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC69_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC69_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC69_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC69_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC69_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC69_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC69_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC69_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC69_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC69_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC70_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC70_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC70_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC70_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC70_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC70_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC70_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC70_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC70_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC70_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC71_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC71_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC71_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC71_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC71_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC71_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC71_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC71_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC71_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC71_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC72_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC72_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC72_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC72_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC72_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC72_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC72_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC72_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC72_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC72_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC73_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC73_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC73_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC73_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC73_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC73_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC73_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC73_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC73_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC73_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC74_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC74_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC74_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC74_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC74_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC74_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC74_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC74_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC74_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC74_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC75_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC75_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC75_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC75_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC75_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC75_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC75_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC75_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC75_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC75_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC76_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC76_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC76_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC76_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC76_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC76_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC76_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC76_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC76_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC76_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC77_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC77_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC77_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC77_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC77_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC77_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC77_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC77_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC77_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC77_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC78_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC78_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC78_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC78_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC78_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC78_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC78_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC78_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC78_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC78_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC79_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC79_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC79_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC79_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC79_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC79_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC79_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC79_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC79_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC79_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC80_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC80_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC80_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC80_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC80_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC80_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC80_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC80_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC80_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC80_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC81_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC81_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC81_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC81_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC81_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC81_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC81_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC81_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC81_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC81_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC82_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC82_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC82_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC82_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC82_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC82_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC82_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC82_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC82_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC82_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC83_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC83_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC83_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC83_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC83_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC83_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC83_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC83_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC83_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC83_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC84_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC84_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC84_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC84_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC84_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC84_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC84_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC84_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC84_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC84_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC85_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC85_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC85_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC85_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC85_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC85_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC85_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC85_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC85_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC85_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC86_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC86_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC86_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC86_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC86_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC86_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC86_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC86_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC86_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC86_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC87_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC87_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC87_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC87_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC87_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC87_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC87_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC87_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC87_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC87_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC88_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC88_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC88_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC88_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC88_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC88_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC88_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC88_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC88_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC88_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC89_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC89_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC89_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC89_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC89_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC89_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC89_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC89_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC89_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC89_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC90_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC90_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC90_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC90_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC90_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC90_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC90_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC90_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC90_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC90_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC91_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC91_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC91_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC91_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC91_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC91_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC91_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC91_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC91_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC91_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC92_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC92_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC92_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC92_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC92_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC92_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC92_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC92_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC92_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC92_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC93_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC93_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC93_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC93_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC93_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC93_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC93_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC93_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC93_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC93_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC94_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC94_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC94_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC94_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC94_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC94_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC94_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC94_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC94_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC94_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC95_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC95_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC95_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC95_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC95_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC95_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC95_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC95_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC95_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC95_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC96_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC96_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC96_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC96_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC96_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC96_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC96_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC96_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC96_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC96_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC97_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC97_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC97_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC97_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC97_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC97_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC97_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC97_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC97_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC97_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC98_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC98_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC98_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC98_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC98_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC98_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC98_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC98_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC98_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC98_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC99_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC99_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC99_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC99_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC99_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC99_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC99_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC99_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC99_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC99_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC100_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC100_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC100_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC100_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC100_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC100_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC100_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC100_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC100_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC100_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC101_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC101_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC101_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC101_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC101_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC101_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC101_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC101_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC101_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC101_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC102_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC102_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC102_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC102_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC102_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC102_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC102_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC102_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC102_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC102_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC103_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC103_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC103_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC103_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC103_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC103_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC103_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC103_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC103_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC103_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC104_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC104_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC104_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC104_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC104_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC104_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC104_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC104_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC104_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC104_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC105_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC105_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC105_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC105_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC105_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC105_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC105_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC105_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC105_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC105_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC106_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC106_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC106_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC106_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC106_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC106_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC106_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC106_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC106_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC106_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC107_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC107_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC107_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC107_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC107_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC107_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC107_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC107_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC107_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC107_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC108_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC108_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC108_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC108_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC108_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC108_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC108_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC108_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC108_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC108_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC109_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC109_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC109_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC109_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC109_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC109_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC109_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC109_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC109_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC109_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC110_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC110_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC110_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC110_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC110_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC110_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC110_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC110_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC110_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC110_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC111_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC111_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC111_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC111_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC111_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC111_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC111_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC111_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC111_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC111_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC112_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC112_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC112_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC112_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC112_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC112_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC112_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC112_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC112_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC112_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC113_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC113_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC113_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC113_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC113_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC113_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC113_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC113_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC113_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC113_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC114_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC114_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC114_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC114_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC114_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC114_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC114_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC114_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC114_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC114_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC115_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC115_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC115_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC115_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC115_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC115_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC115_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC115_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC115_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC115_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC116_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC116_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC116_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC116_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC116_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC116_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC116_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC116_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC116_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC116_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC117_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC117_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC117_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC117_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC117_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC117_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC117_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC117_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC117_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC117_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC118_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC118_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC118_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC118_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC118_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC118_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC118_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC118_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC118_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC118_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC119_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC119_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC119_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC119_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC119_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC119_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC119_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC119_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC119_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC119_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC120_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC120_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC120_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC120_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC120_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC120_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC120_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC120_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC120_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC120_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC121_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC121_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC121_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC121_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC121_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC121_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC121_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC121_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC121_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC121_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC122_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC122_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC122_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC122_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC122_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC122_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC122_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC122_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC122_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC122_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC123_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC123_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC123_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC123_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC123_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC123_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC123_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC123_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC123_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC123_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC124_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC124_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC124_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC124_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC124_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC124_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC124_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC124_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC124_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC124_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC125_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC125_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC125_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC125_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC125_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC125_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC125_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC125_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC125_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC125_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC126_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC126_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC126_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC126_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC126_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC126_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC126_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC126_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC126_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC126_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC127_IN_SEL_CFG: GPIO input function configuration register
func (o *GPIO_Type) SetFUNC127_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC127_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC127_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC127_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC127_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC127_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC127_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC127_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC127_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC0_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC0_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC0_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC0_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC0_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC0_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC0_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC0_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC0_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC1_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC1_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC1_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC1_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC1_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC1_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC1_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC1_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC1_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC2_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC2_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC2_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC2_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC2_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC2_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC2_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC2_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC2_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC3_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC3_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC3_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC3_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC3_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC3_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC3_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC3_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC3_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC4_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC4_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC4_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC4_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC4_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC4_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC4_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC4_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC4_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC5_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC5_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC5_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC5_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC5_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC5_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC5_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC5_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC5_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC6_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC6_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC6_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC6_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC6_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC6_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC6_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC6_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC6_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC7_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC7_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC7_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC7_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC7_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC7_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC7_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC7_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC7_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC8_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC8_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC8_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC8_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC8_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC8_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC8_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC8_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC8_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC9_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC9_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC9_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC9_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC9_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC9_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC9_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC9_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC9_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC10_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC10_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC10_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC10_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC10_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC10_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC10_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC10_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC10_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC11_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC11_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC11_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC11_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC11_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC11_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC11_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC11_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC11_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC12_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC12_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC12_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC12_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC12_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC12_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC12_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC12_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC12_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC13_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC13_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC13_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC13_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC13_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC13_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC13_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC13_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC13_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC14_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC14_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC14_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC14_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC14_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC14_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC14_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC14_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC14_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC15_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC15_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC15_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC15_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC15_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC15_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC15_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC15_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC15_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC16_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC16_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC16_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC16_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC16_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC16_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC16_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC16_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC16_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC17_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC17_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC17_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC17_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC17_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC17_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC17_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC17_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC17_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC18_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC18_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC18_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC18_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC18_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC18_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC18_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC18_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC18_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC19_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC19_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC19_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC19_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC19_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC19_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC19_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC19_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC19_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC20_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC20_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC20_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC20_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC20_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC20_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC20_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC20_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC20_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC21_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC21_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC21_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC21_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC21_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC21_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC21_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC21_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC21_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC22_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC22_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC22_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC22_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC22_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC22_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC22_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC22_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC22_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC23_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC23_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC23_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC23_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC23_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC23_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC23_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC23_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC23_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC24_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC24_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC24_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC24_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC24_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC24_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC24_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC24_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC24_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC25_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC25_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC25_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC25_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC25_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC25_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC25_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC25_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC25_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC26_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC26_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC26_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC26_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC26_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC26_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC26_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC26_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC26_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC27_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC27_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC27_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC27_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC27_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC27_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC27_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC27_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC27_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC28_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC28_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC28_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC28_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC28_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC28_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC28_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC28_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC28_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.FUNC29_OUT_SEL_CFG: GPIO output function select register
func (o *GPIO_Type) SetFUNC29_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetFUNC29_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg) & 0xff
}
func (o *GPIO_Type) SetFUNC29_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetFUNC29_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetFUNC29_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC29_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC29_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC29_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg) & 0x400) >> 10
}

// GPIO.CLOCK_GATE: GPIO clock gate register
func (o *GPIO_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// GPIO.DATE: GPIO version register
func (o *GPIO_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *GPIO_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// Sigma-Delta Modulation
type GPIOSD_Type struct {
	SIGMADELTA0       volatile.Register32 // 0x0
	SIGMADELTA1       volatile.Register32 // 0x4
	SIGMADELTA2       volatile.Register32 // 0x8
	SIGMADELTA3       volatile.Register32 // 0xC
	_                 [16]byte
	CLOCK_GATE        volatile.Register32 // 0x20
	SIGMADELTA_MISC   volatile.Register32 // 0x24
	PAD_COMP_CONFIG   volatile.Register32 // 0x28
	PAD_COMP_FILTER   volatile.Register32 // 0x2C
	GLITCH_FILTER_CH0 volatile.Register32 // 0x30
	GLITCH_FILTER_CH1 volatile.Register32 // 0x34
	GLITCH_FILTER_CH2 volatile.Register32 // 0x38
	GLITCH_FILTER_CH3 volatile.Register32 // 0x3C
	GLITCH_FILTER_CH4 volatile.Register32 // 0x40
	GLITCH_FILTER_CH5 volatile.Register32 // 0x44
	GLITCH_FILTER_CH6 volatile.Register32 // 0x48
	GLITCH_FILTER_CH7 volatile.Register32 // 0x4C
	_                 [16]byte
	ETM_EVENT_CH0_CFG volatile.Register32 // 0x60
	ETM_EVENT_CH1_CFG volatile.Register32 // 0x64
	ETM_EVENT_CH2_CFG volatile.Register32 // 0x68
	ETM_EVENT_CH3_CFG volatile.Register32 // 0x6C
	ETM_EVENT_CH4_CFG volatile.Register32 // 0x70
	ETM_EVENT_CH5_CFG volatile.Register32 // 0x74
	ETM_EVENT_CH6_CFG volatile.Register32 // 0x78
	ETM_EVENT_CH7_CFG volatile.Register32 // 0x7C
	_                 [32]byte
	ETM_TASK_P0_CFG   volatile.Register32 // 0xA0
	ETM_TASK_P1_CFG   volatile.Register32 // 0xA4
	ETM_TASK_P2_CFG   volatile.Register32 // 0xA8
	ETM_TASK_P3_CFG   volatile.Register32 // 0xAC
	ETM_TASK_P4_CFG   volatile.Register32 // 0xB0
	ETM_TASK_P5_CFG   volatile.Register32 // 0xB4
	ETM_TASK_P6_CFG   volatile.Register32 // 0xB8
	_                 [36]byte
	INT_RAW           volatile.Register32 // 0xE0
	INT_ST            volatile.Register32 // 0xE4
	INT_ENA           volatile.Register32 // 0xE8
	INT_CLR           volatile.Register32 // 0xEC
	_                 [12]byte
	VERSION           volatile.Register32 // 0xFC
}

// GPIOSD.SIGMADELTA0: Duty Cycle Configure Register of SDM%s
func (o *GPIOSD_Type) SetSIGMADELTA0_SD_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA0.Reg, volatile.LoadUint32(&o.SIGMADELTA0.Reg)&^(0xff)|value)
}
func (o *GPIOSD_Type) GetSIGMADELTA0_SD_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA0.Reg) & 0xff
}
func (o *GPIOSD_Type) SetSIGMADELTA0_SD_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA0.Reg, volatile.LoadUint32(&o.SIGMADELTA0.Reg)&^(0xff00)|value<<8)
}
func (o *GPIOSD_Type) GetSIGMADELTA0_SD_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA0.Reg) & 0xff00) >> 8
}

// GPIOSD.SIGMADELTA1: Duty Cycle Configure Register of SDM%s
func (o *GPIOSD_Type) SetSIGMADELTA1_SD_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA1.Reg, volatile.LoadUint32(&o.SIGMADELTA1.Reg)&^(0xff)|value)
}
func (o *GPIOSD_Type) GetSIGMADELTA1_SD_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA1.Reg) & 0xff
}
func (o *GPIOSD_Type) SetSIGMADELTA1_SD_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA1.Reg, volatile.LoadUint32(&o.SIGMADELTA1.Reg)&^(0xff00)|value<<8)
}
func (o *GPIOSD_Type) GetSIGMADELTA1_SD_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA1.Reg) & 0xff00) >> 8
}

// GPIOSD.SIGMADELTA2: Duty Cycle Configure Register of SDM%s
func (o *GPIOSD_Type) SetSIGMADELTA2_SD_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA2.Reg, volatile.LoadUint32(&o.SIGMADELTA2.Reg)&^(0xff)|value)
}
func (o *GPIOSD_Type) GetSIGMADELTA2_SD_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA2.Reg) & 0xff
}
func (o *GPIOSD_Type) SetSIGMADELTA2_SD_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA2.Reg, volatile.LoadUint32(&o.SIGMADELTA2.Reg)&^(0xff00)|value<<8)
}
func (o *GPIOSD_Type) GetSIGMADELTA2_SD_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA2.Reg) & 0xff00) >> 8
}

// GPIOSD.SIGMADELTA3: Duty Cycle Configure Register of SDM%s
func (o *GPIOSD_Type) SetSIGMADELTA3_SD_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA3.Reg, volatile.LoadUint32(&o.SIGMADELTA3.Reg)&^(0xff)|value)
}
func (o *GPIOSD_Type) GetSIGMADELTA3_SD_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA3.Reg) & 0xff
}
func (o *GPIOSD_Type) SetSIGMADELTA3_SD_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA3.Reg, volatile.LoadUint32(&o.SIGMADELTA3.Reg)&^(0xff00)|value<<8)
}
func (o *GPIOSD_Type) GetSIGMADELTA3_SD_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA3.Reg) & 0xff00) >> 8
}

// GPIOSD.CLOCK_GATE: Clock Gating Configure Register
func (o *GPIOSD_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// GPIOSD.SIGMADELTA_MISC: MISC Register
func (o *GPIOSD_Type) SetSIGMADELTA_MISC_FUNCTION_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA_MISC.Reg, volatile.LoadUint32(&o.SIGMADELTA_MISC.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIOSD_Type) GetSIGMADELTA_MISC_FUNCTION_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA_MISC.Reg) & 0x40000000) >> 30
}
func (o *GPIOSD_Type) SetSIGMADELTA_MISC_SPI_SWAP(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA_MISC.Reg, volatile.LoadUint32(&o.SIGMADELTA_MISC.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOSD_Type) GetSIGMADELTA_MISC_SPI_SWAP() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA_MISC.Reg) & 0x80000000) >> 31
}

// GPIOSD.PAD_COMP_CONFIG: PAD Compare configure Register
func (o *GPIOSD_Type) SetPAD_COMP_CONFIG_XPD_COMP(value uint32) {
	volatile.StoreUint32(&o.PAD_COMP_CONFIG.Reg, volatile.LoadUint32(&o.PAD_COMP_CONFIG.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetPAD_COMP_CONFIG_XPD_COMP() uint32 {
	return volatile.LoadUint32(&o.PAD_COMP_CONFIG.Reg) & 0x1
}
func (o *GPIOSD_Type) SetPAD_COMP_CONFIG_MODE_COMP(value uint32) {
	volatile.StoreUint32(&o.PAD_COMP_CONFIG.Reg, volatile.LoadUint32(&o.PAD_COMP_CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *GPIOSD_Type) GetPAD_COMP_CONFIG_MODE_COMP() uint32 {
	return (volatile.LoadUint32(&o.PAD_COMP_CONFIG.Reg) & 0x2) >> 1
}
func (o *GPIOSD_Type) SetPAD_COMP_CONFIG_DREF_COMP(value uint32) {
	volatile.StoreUint32(&o.PAD_COMP_CONFIG.Reg, volatile.LoadUint32(&o.PAD_COMP_CONFIG.Reg)&^(0x1c)|value<<2)
}
func (o *GPIOSD_Type) GetPAD_COMP_CONFIG_DREF_COMP() uint32 {
	return (volatile.LoadUint32(&o.PAD_COMP_CONFIG.Reg) & 0x1c) >> 2
}
func (o *GPIOSD_Type) SetPAD_COMP_CONFIG_ZERO_DET_MODE(value uint32) {
	volatile.StoreUint32(&o.PAD_COMP_CONFIG.Reg, volatile.LoadUint32(&o.PAD_COMP_CONFIG.Reg)&^(0x60)|value<<5)
}
func (o *GPIOSD_Type) GetPAD_COMP_CONFIG_ZERO_DET_MODE() uint32 {
	return (volatile.LoadUint32(&o.PAD_COMP_CONFIG.Reg) & 0x60) >> 5
}

// GPIOSD.PAD_COMP_FILTER: Zero Detect filter Register
func (o *GPIOSD_Type) SetPAD_COMP_FILTER(value uint32) {
	volatile.StoreUint32(&o.PAD_COMP_FILTER.Reg, value)
}
func (o *GPIOSD_Type) GetPAD_COMP_FILTER() uint32 {
	return volatile.LoadUint32(&o.PAD_COMP_FILTER.Reg)
}

// GPIOSD.GLITCH_FILTER_CH0: Glitch Filter Configure Register of Channel%s
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH0_FILTER_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH0.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH0.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH0_FILTER_CH0_EN() uint32 {
	return volatile.LoadUint32(&o.GLITCH_FILTER_CH0.Reg) & 0x1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH0_FILTER_CH0_INPUT_IO_NUM(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH0.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH0.Reg)&^(0x7e)|value<<1)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH0_FILTER_CH0_INPUT_IO_NUM() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH0.Reg) & 0x7e) >> 1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH0_FILTER_CH0_WINDOW_THRES(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH0.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH0.Reg)&^(0x1f80)|value<<7)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH0_FILTER_CH0_WINDOW_THRES() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH0.Reg) & 0x1f80) >> 7
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH0_FILTER_CH0_WINDOW_WIDTH(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH0.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH0.Reg)&^(0x7e000)|value<<13)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH0_FILTER_CH0_WINDOW_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH0.Reg) & 0x7e000) >> 13
}

// GPIOSD.GLITCH_FILTER_CH1: Glitch Filter Configure Register of Channel%s
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH1_FILTER_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH1.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH1.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH1_FILTER_CH0_EN() uint32 {
	return volatile.LoadUint32(&o.GLITCH_FILTER_CH1.Reg) & 0x1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH1_FILTER_CH0_INPUT_IO_NUM(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH1.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH1.Reg)&^(0x7e)|value<<1)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH1_FILTER_CH0_INPUT_IO_NUM() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH1.Reg) & 0x7e) >> 1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH1_FILTER_CH0_WINDOW_THRES(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH1.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH1.Reg)&^(0x1f80)|value<<7)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH1_FILTER_CH0_WINDOW_THRES() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH1.Reg) & 0x1f80) >> 7
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH1_FILTER_CH0_WINDOW_WIDTH(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH1.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH1.Reg)&^(0x7e000)|value<<13)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH1_FILTER_CH0_WINDOW_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH1.Reg) & 0x7e000) >> 13
}

// GPIOSD.GLITCH_FILTER_CH2: Glitch Filter Configure Register of Channel%s
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH2_FILTER_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH2.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH2.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH2_FILTER_CH0_EN() uint32 {
	return volatile.LoadUint32(&o.GLITCH_FILTER_CH2.Reg) & 0x1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH2_FILTER_CH0_INPUT_IO_NUM(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH2.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH2.Reg)&^(0x7e)|value<<1)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH2_FILTER_CH0_INPUT_IO_NUM() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH2.Reg) & 0x7e) >> 1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH2_FILTER_CH0_WINDOW_THRES(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH2.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH2.Reg)&^(0x1f80)|value<<7)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH2_FILTER_CH0_WINDOW_THRES() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH2.Reg) & 0x1f80) >> 7
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH2_FILTER_CH0_WINDOW_WIDTH(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH2.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH2.Reg)&^(0x7e000)|value<<13)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH2_FILTER_CH0_WINDOW_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH2.Reg) & 0x7e000) >> 13
}

// GPIOSD.GLITCH_FILTER_CH3: Glitch Filter Configure Register of Channel%s
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH3_FILTER_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH3.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH3.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH3_FILTER_CH0_EN() uint32 {
	return volatile.LoadUint32(&o.GLITCH_FILTER_CH3.Reg) & 0x1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH3_FILTER_CH0_INPUT_IO_NUM(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH3.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH3.Reg)&^(0x7e)|value<<1)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH3_FILTER_CH0_INPUT_IO_NUM() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH3.Reg) & 0x7e) >> 1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH3_FILTER_CH0_WINDOW_THRES(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH3.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH3.Reg)&^(0x1f80)|value<<7)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH3_FILTER_CH0_WINDOW_THRES() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH3.Reg) & 0x1f80) >> 7
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH3_FILTER_CH0_WINDOW_WIDTH(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH3.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH3.Reg)&^(0x7e000)|value<<13)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH3_FILTER_CH0_WINDOW_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH3.Reg) & 0x7e000) >> 13
}

// GPIOSD.GLITCH_FILTER_CH4: Glitch Filter Configure Register of Channel%s
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH4_FILTER_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH4.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH4.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH4_FILTER_CH0_EN() uint32 {
	return volatile.LoadUint32(&o.GLITCH_FILTER_CH4.Reg) & 0x1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH4_FILTER_CH0_INPUT_IO_NUM(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH4.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH4.Reg)&^(0x7e)|value<<1)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH4_FILTER_CH0_INPUT_IO_NUM() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH4.Reg) & 0x7e) >> 1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH4_FILTER_CH0_WINDOW_THRES(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH4.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH4.Reg)&^(0x1f80)|value<<7)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH4_FILTER_CH0_WINDOW_THRES() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH4.Reg) & 0x1f80) >> 7
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH4_FILTER_CH0_WINDOW_WIDTH(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH4.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH4.Reg)&^(0x7e000)|value<<13)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH4_FILTER_CH0_WINDOW_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH4.Reg) & 0x7e000) >> 13
}

// GPIOSD.GLITCH_FILTER_CH5: Glitch Filter Configure Register of Channel%s
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH5_FILTER_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH5.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH5.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH5_FILTER_CH0_EN() uint32 {
	return volatile.LoadUint32(&o.GLITCH_FILTER_CH5.Reg) & 0x1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH5_FILTER_CH0_INPUT_IO_NUM(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH5.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH5.Reg)&^(0x7e)|value<<1)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH5_FILTER_CH0_INPUT_IO_NUM() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH5.Reg) & 0x7e) >> 1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH5_FILTER_CH0_WINDOW_THRES(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH5.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH5.Reg)&^(0x1f80)|value<<7)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH5_FILTER_CH0_WINDOW_THRES() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH5.Reg) & 0x1f80) >> 7
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH5_FILTER_CH0_WINDOW_WIDTH(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH5.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH5.Reg)&^(0x7e000)|value<<13)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH5_FILTER_CH0_WINDOW_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH5.Reg) & 0x7e000) >> 13
}

// GPIOSD.GLITCH_FILTER_CH6: Glitch Filter Configure Register of Channel%s
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH6_FILTER_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH6.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH6.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH6_FILTER_CH0_EN() uint32 {
	return volatile.LoadUint32(&o.GLITCH_FILTER_CH6.Reg) & 0x1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH6_FILTER_CH0_INPUT_IO_NUM(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH6.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH6.Reg)&^(0x7e)|value<<1)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH6_FILTER_CH0_INPUT_IO_NUM() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH6.Reg) & 0x7e) >> 1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH6_FILTER_CH0_WINDOW_THRES(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH6.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH6.Reg)&^(0x1f80)|value<<7)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH6_FILTER_CH0_WINDOW_THRES() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH6.Reg) & 0x1f80) >> 7
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH6_FILTER_CH0_WINDOW_WIDTH(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH6.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH6.Reg)&^(0x7e000)|value<<13)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH6_FILTER_CH0_WINDOW_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH6.Reg) & 0x7e000) >> 13
}

// GPIOSD.GLITCH_FILTER_CH7: Glitch Filter Configure Register of Channel%s
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH7_FILTER_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH7.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH7.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH7_FILTER_CH0_EN() uint32 {
	return volatile.LoadUint32(&o.GLITCH_FILTER_CH7.Reg) & 0x1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH7_FILTER_CH0_INPUT_IO_NUM(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH7.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH7.Reg)&^(0x7e)|value<<1)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH7_FILTER_CH0_INPUT_IO_NUM() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH7.Reg) & 0x7e) >> 1
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH7_FILTER_CH0_WINDOW_THRES(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH7.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH7.Reg)&^(0x1f80)|value<<7)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH7_FILTER_CH0_WINDOW_THRES() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH7.Reg) & 0x1f80) >> 7
}
func (o *GPIOSD_Type) SetGLITCH_FILTER_CH7_FILTER_CH0_WINDOW_WIDTH(value uint32) {
	volatile.StoreUint32(&o.GLITCH_FILTER_CH7.Reg, volatile.LoadUint32(&o.GLITCH_FILTER_CH7.Reg)&^(0x7e000)|value<<13)
}
func (o *GPIOSD_Type) GetGLITCH_FILTER_CH7_FILTER_CH0_WINDOW_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.GLITCH_FILTER_CH7.Reg) & 0x7e000) >> 13
}

// GPIOSD.ETM_EVENT_CH0_CFG: Etm Config register of Channel%s
func (o *GPIOSD_Type) SetETM_EVENT_CH0_CFG_ETM_CH0_EVENT_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH0_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH0_CFG.Reg)&^(0x1f)|value)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH0_CFG_ETM_CH0_EVENT_SEL() uint32 {
	return volatile.LoadUint32(&o.ETM_EVENT_CH0_CFG.Reg) & 0x1f
}
func (o *GPIOSD_Type) SetETM_EVENT_CH0_CFG_ETM_CH0_EVENT_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH0_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH0_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH0_CFG_ETM_CH0_EVENT_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_EVENT_CH0_CFG.Reg) & 0x80) >> 7
}

// GPIOSD.ETM_EVENT_CH1_CFG: Etm Config register of Channel%s
func (o *GPIOSD_Type) SetETM_EVENT_CH1_CFG_ETM_CH0_EVENT_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH1_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH1_CFG.Reg)&^(0x1f)|value)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH1_CFG_ETM_CH0_EVENT_SEL() uint32 {
	return volatile.LoadUint32(&o.ETM_EVENT_CH1_CFG.Reg) & 0x1f
}
func (o *GPIOSD_Type) SetETM_EVENT_CH1_CFG_ETM_CH0_EVENT_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH1_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH1_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH1_CFG_ETM_CH0_EVENT_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_EVENT_CH1_CFG.Reg) & 0x80) >> 7
}

// GPIOSD.ETM_EVENT_CH2_CFG: Etm Config register of Channel%s
func (o *GPIOSD_Type) SetETM_EVENT_CH2_CFG_ETM_CH0_EVENT_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH2_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH2_CFG.Reg)&^(0x1f)|value)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH2_CFG_ETM_CH0_EVENT_SEL() uint32 {
	return volatile.LoadUint32(&o.ETM_EVENT_CH2_CFG.Reg) & 0x1f
}
func (o *GPIOSD_Type) SetETM_EVENT_CH2_CFG_ETM_CH0_EVENT_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH2_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH2_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH2_CFG_ETM_CH0_EVENT_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_EVENT_CH2_CFG.Reg) & 0x80) >> 7
}

// GPIOSD.ETM_EVENT_CH3_CFG: Etm Config register of Channel%s
func (o *GPIOSD_Type) SetETM_EVENT_CH3_CFG_ETM_CH0_EVENT_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH3_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH3_CFG.Reg)&^(0x1f)|value)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH3_CFG_ETM_CH0_EVENT_SEL() uint32 {
	return volatile.LoadUint32(&o.ETM_EVENT_CH3_CFG.Reg) & 0x1f
}
func (o *GPIOSD_Type) SetETM_EVENT_CH3_CFG_ETM_CH0_EVENT_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH3_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH3_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH3_CFG_ETM_CH0_EVENT_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_EVENT_CH3_CFG.Reg) & 0x80) >> 7
}

// GPIOSD.ETM_EVENT_CH4_CFG: Etm Config register of Channel%s
func (o *GPIOSD_Type) SetETM_EVENT_CH4_CFG_ETM_CH0_EVENT_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH4_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH4_CFG.Reg)&^(0x1f)|value)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH4_CFG_ETM_CH0_EVENT_SEL() uint32 {
	return volatile.LoadUint32(&o.ETM_EVENT_CH4_CFG.Reg) & 0x1f
}
func (o *GPIOSD_Type) SetETM_EVENT_CH4_CFG_ETM_CH0_EVENT_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH4_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH4_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH4_CFG_ETM_CH0_EVENT_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_EVENT_CH4_CFG.Reg) & 0x80) >> 7
}

// GPIOSD.ETM_EVENT_CH5_CFG: Etm Config register of Channel%s
func (o *GPIOSD_Type) SetETM_EVENT_CH5_CFG_ETM_CH0_EVENT_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH5_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH5_CFG.Reg)&^(0x1f)|value)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH5_CFG_ETM_CH0_EVENT_SEL() uint32 {
	return volatile.LoadUint32(&o.ETM_EVENT_CH5_CFG.Reg) & 0x1f
}
func (o *GPIOSD_Type) SetETM_EVENT_CH5_CFG_ETM_CH0_EVENT_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH5_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH5_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH5_CFG_ETM_CH0_EVENT_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_EVENT_CH5_CFG.Reg) & 0x80) >> 7
}

// GPIOSD.ETM_EVENT_CH6_CFG: Etm Config register of Channel%s
func (o *GPIOSD_Type) SetETM_EVENT_CH6_CFG_ETM_CH0_EVENT_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH6_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH6_CFG.Reg)&^(0x1f)|value)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH6_CFG_ETM_CH0_EVENT_SEL() uint32 {
	return volatile.LoadUint32(&o.ETM_EVENT_CH6_CFG.Reg) & 0x1f
}
func (o *GPIOSD_Type) SetETM_EVENT_CH6_CFG_ETM_CH0_EVENT_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH6_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH6_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH6_CFG_ETM_CH0_EVENT_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_EVENT_CH6_CFG.Reg) & 0x80) >> 7
}

// GPIOSD.ETM_EVENT_CH7_CFG: Etm Config register of Channel%s
func (o *GPIOSD_Type) SetETM_EVENT_CH7_CFG_ETM_CH0_EVENT_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH7_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH7_CFG.Reg)&^(0x1f)|value)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH7_CFG_ETM_CH0_EVENT_SEL() uint32 {
	return volatile.LoadUint32(&o.ETM_EVENT_CH7_CFG.Reg) & 0x1f
}
func (o *GPIOSD_Type) SetETM_EVENT_CH7_CFG_ETM_CH0_EVENT_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_EVENT_CH7_CFG.Reg, volatile.LoadUint32(&o.ETM_EVENT_CH7_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIOSD_Type) GetETM_EVENT_CH7_CFG_ETM_CH0_EVENT_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_EVENT_CH7_CFG.Reg) & 0x80) >> 7
}

// GPIOSD.ETM_TASK_P0_CFG: Etm Configure Register to decide which GPIO been chosen
func (o *GPIOSD_Type) SetETM_TASK_P0_CFG_ETM_TASK_GPIO0_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P0_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetETM_TASK_P0_CFG_ETM_TASK_GPIO0_EN() uint32 {
	return volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg) & 0x1
}
func (o *GPIOSD_Type) SetETM_TASK_P0_CFG_ETM_TASK_GPIO0_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P0_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg)&^(0xe)|value<<1)
}
func (o *GPIOSD_Type) GetETM_TASK_P0_CFG_ETM_TASK_GPIO0_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg) & 0xe) >> 1
}
func (o *GPIOSD_Type) SetETM_TASK_P0_CFG_ETM_TASK_GPIO1_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P0_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIOSD_Type) GetETM_TASK_P0_CFG_ETM_TASK_GPIO1_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg) & 0x100) >> 8
}
func (o *GPIOSD_Type) SetETM_TASK_P0_CFG_ETM_TASK_GPIO1_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P0_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg)&^(0xe00)|value<<9)
}
func (o *GPIOSD_Type) GetETM_TASK_P0_CFG_ETM_TASK_GPIO1_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg) & 0xe00) >> 9
}
func (o *GPIOSD_Type) SetETM_TASK_P0_CFG_ETM_TASK_GPIO2_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P0_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOSD_Type) GetETM_TASK_P0_CFG_ETM_TASK_GPIO2_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg) & 0x10000) >> 16
}
func (o *GPIOSD_Type) SetETM_TASK_P0_CFG_ETM_TASK_GPIO2_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P0_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg)&^(0xe0000)|value<<17)
}
func (o *GPIOSD_Type) GetETM_TASK_P0_CFG_ETM_TASK_GPIO2_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg) & 0xe0000) >> 17
}
func (o *GPIOSD_Type) SetETM_TASK_P0_CFG_ETM_TASK_GPIO3_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P0_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOSD_Type) GetETM_TASK_P0_CFG_ETM_TASK_GPIO3_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg) & 0x1000000) >> 24
}
func (o *GPIOSD_Type) SetETM_TASK_P0_CFG_ETM_TASK_GPIO3_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P0_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg)&^(0xe000000)|value<<25)
}
func (o *GPIOSD_Type) GetETM_TASK_P0_CFG_ETM_TASK_GPIO3_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P0_CFG.Reg) & 0xe000000) >> 25
}

// GPIOSD.ETM_TASK_P1_CFG: Etm Configure Register to decide which GPIO been chosen
func (o *GPIOSD_Type) SetETM_TASK_P1_CFG_ETM_TASK_GPIO4_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P1_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetETM_TASK_P1_CFG_ETM_TASK_GPIO4_EN() uint32 {
	return volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg) & 0x1
}
func (o *GPIOSD_Type) SetETM_TASK_P1_CFG_ETM_TASK_GPIO4_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P1_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg)&^(0xe)|value<<1)
}
func (o *GPIOSD_Type) GetETM_TASK_P1_CFG_ETM_TASK_GPIO4_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg) & 0xe) >> 1
}
func (o *GPIOSD_Type) SetETM_TASK_P1_CFG_ETM_TASK_GPIO5_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P1_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIOSD_Type) GetETM_TASK_P1_CFG_ETM_TASK_GPIO5_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg) & 0x100) >> 8
}
func (o *GPIOSD_Type) SetETM_TASK_P1_CFG_ETM_TASK_GPIO5_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P1_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg)&^(0xe00)|value<<9)
}
func (o *GPIOSD_Type) GetETM_TASK_P1_CFG_ETM_TASK_GPIO5_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg) & 0xe00) >> 9
}
func (o *GPIOSD_Type) SetETM_TASK_P1_CFG_ETM_TASK_GPIO6_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P1_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOSD_Type) GetETM_TASK_P1_CFG_ETM_TASK_GPIO6_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg) & 0x10000) >> 16
}
func (o *GPIOSD_Type) SetETM_TASK_P1_CFG_ETM_TASK_GPIO6_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P1_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg)&^(0xe0000)|value<<17)
}
func (o *GPIOSD_Type) GetETM_TASK_P1_CFG_ETM_TASK_GPIO6_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg) & 0xe0000) >> 17
}
func (o *GPIOSD_Type) SetETM_TASK_P1_CFG_ETM_TASK_GPIO7_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P1_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOSD_Type) GetETM_TASK_P1_CFG_ETM_TASK_GPIO7_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg) & 0x1000000) >> 24
}
func (o *GPIOSD_Type) SetETM_TASK_P1_CFG_ETM_TASK_GPIO7_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P1_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg)&^(0xe000000)|value<<25)
}
func (o *GPIOSD_Type) GetETM_TASK_P1_CFG_ETM_TASK_GPIO7_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P1_CFG.Reg) & 0xe000000) >> 25
}

// GPIOSD.ETM_TASK_P2_CFG: Etm Configure Register to decide which GPIO been chosen
func (o *GPIOSD_Type) SetETM_TASK_P2_CFG_ETM_TASK_GPIO8_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P2_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetETM_TASK_P2_CFG_ETM_TASK_GPIO8_EN() uint32 {
	return volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg) & 0x1
}
func (o *GPIOSD_Type) SetETM_TASK_P2_CFG_ETM_TASK_GPIO8_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P2_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg)&^(0xe)|value<<1)
}
func (o *GPIOSD_Type) GetETM_TASK_P2_CFG_ETM_TASK_GPIO8_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg) & 0xe) >> 1
}
func (o *GPIOSD_Type) SetETM_TASK_P2_CFG_ETM_TASK_GPIO9_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P2_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIOSD_Type) GetETM_TASK_P2_CFG_ETM_TASK_GPIO9_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg) & 0x100) >> 8
}
func (o *GPIOSD_Type) SetETM_TASK_P2_CFG_ETM_TASK_GPIO9_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P2_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg)&^(0xe00)|value<<9)
}
func (o *GPIOSD_Type) GetETM_TASK_P2_CFG_ETM_TASK_GPIO9_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg) & 0xe00) >> 9
}
func (o *GPIOSD_Type) SetETM_TASK_P2_CFG_ETM_TASK_GPIO10_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P2_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOSD_Type) GetETM_TASK_P2_CFG_ETM_TASK_GPIO10_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg) & 0x10000) >> 16
}
func (o *GPIOSD_Type) SetETM_TASK_P2_CFG_ETM_TASK_GPIO10_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P2_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg)&^(0xe0000)|value<<17)
}
func (o *GPIOSD_Type) GetETM_TASK_P2_CFG_ETM_TASK_GPIO10_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg) & 0xe0000) >> 17
}
func (o *GPIOSD_Type) SetETM_TASK_P2_CFG_ETM_TASK_GPIO11_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P2_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOSD_Type) GetETM_TASK_P2_CFG_ETM_TASK_GPIO11_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg) & 0x1000000) >> 24
}
func (o *GPIOSD_Type) SetETM_TASK_P2_CFG_ETM_TASK_GPIO11_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P2_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg)&^(0xe000000)|value<<25)
}
func (o *GPIOSD_Type) GetETM_TASK_P2_CFG_ETM_TASK_GPIO11_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P2_CFG.Reg) & 0xe000000) >> 25
}

// GPIOSD.ETM_TASK_P3_CFG: Etm Configure Register to decide which GPIO been chosen
func (o *GPIOSD_Type) SetETM_TASK_P3_CFG_ETM_TASK_GPIO12_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P3_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetETM_TASK_P3_CFG_ETM_TASK_GPIO12_EN() uint32 {
	return volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg) & 0x1
}
func (o *GPIOSD_Type) SetETM_TASK_P3_CFG_ETM_TASK_GPIO12_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P3_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg)&^(0xe)|value<<1)
}
func (o *GPIOSD_Type) GetETM_TASK_P3_CFG_ETM_TASK_GPIO12_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg) & 0xe) >> 1
}
func (o *GPIOSD_Type) SetETM_TASK_P3_CFG_ETM_TASK_GPIO13_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P3_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIOSD_Type) GetETM_TASK_P3_CFG_ETM_TASK_GPIO13_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg) & 0x100) >> 8
}
func (o *GPIOSD_Type) SetETM_TASK_P3_CFG_ETM_TASK_GPIO13_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P3_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg)&^(0xe00)|value<<9)
}
func (o *GPIOSD_Type) GetETM_TASK_P3_CFG_ETM_TASK_GPIO13_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg) & 0xe00) >> 9
}
func (o *GPIOSD_Type) SetETM_TASK_P3_CFG_ETM_TASK_GPIO14_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P3_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOSD_Type) GetETM_TASK_P3_CFG_ETM_TASK_GPIO14_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg) & 0x10000) >> 16
}
func (o *GPIOSD_Type) SetETM_TASK_P3_CFG_ETM_TASK_GPIO14_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P3_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg)&^(0xe0000)|value<<17)
}
func (o *GPIOSD_Type) GetETM_TASK_P3_CFG_ETM_TASK_GPIO14_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg) & 0xe0000) >> 17
}
func (o *GPIOSD_Type) SetETM_TASK_P3_CFG_ETM_TASK_GPIO15_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P3_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOSD_Type) GetETM_TASK_P3_CFG_ETM_TASK_GPIO15_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg) & 0x1000000) >> 24
}
func (o *GPIOSD_Type) SetETM_TASK_P3_CFG_ETM_TASK_GPIO15_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P3_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg)&^(0xe000000)|value<<25)
}
func (o *GPIOSD_Type) GetETM_TASK_P3_CFG_ETM_TASK_GPIO15_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P3_CFG.Reg) & 0xe000000) >> 25
}

// GPIOSD.ETM_TASK_P4_CFG: Etm Configure Register to decide which GPIO been chosen
func (o *GPIOSD_Type) SetETM_TASK_P4_CFG_ETM_TASK_GPIO16_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P4_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetETM_TASK_P4_CFG_ETM_TASK_GPIO16_EN() uint32 {
	return volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg) & 0x1
}
func (o *GPIOSD_Type) SetETM_TASK_P4_CFG_ETM_TASK_GPIO16_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P4_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg)&^(0xe)|value<<1)
}
func (o *GPIOSD_Type) GetETM_TASK_P4_CFG_ETM_TASK_GPIO16_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg) & 0xe) >> 1
}
func (o *GPIOSD_Type) SetETM_TASK_P4_CFG_ETM_TASK_GPIO17_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P4_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIOSD_Type) GetETM_TASK_P4_CFG_ETM_TASK_GPIO17_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg) & 0x100) >> 8
}
func (o *GPIOSD_Type) SetETM_TASK_P4_CFG_ETM_TASK_GPIO17_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P4_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg)&^(0xe00)|value<<9)
}
func (o *GPIOSD_Type) GetETM_TASK_P4_CFG_ETM_TASK_GPIO17_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg) & 0xe00) >> 9
}
func (o *GPIOSD_Type) SetETM_TASK_P4_CFG_ETM_TASK_GPIO18_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P4_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOSD_Type) GetETM_TASK_P4_CFG_ETM_TASK_GPIO18_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg) & 0x10000) >> 16
}
func (o *GPIOSD_Type) SetETM_TASK_P4_CFG_ETM_TASK_GPIO18_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P4_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg)&^(0xe0000)|value<<17)
}
func (o *GPIOSD_Type) GetETM_TASK_P4_CFG_ETM_TASK_GPIO18_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg) & 0xe0000) >> 17
}
func (o *GPIOSD_Type) SetETM_TASK_P4_CFG_ETM_TASK_GPIO19_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P4_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOSD_Type) GetETM_TASK_P4_CFG_ETM_TASK_GPIO19_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg) & 0x1000000) >> 24
}
func (o *GPIOSD_Type) SetETM_TASK_P4_CFG_ETM_TASK_GPIO19_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P4_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg)&^(0xe000000)|value<<25)
}
func (o *GPIOSD_Type) GetETM_TASK_P4_CFG_ETM_TASK_GPIO19_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P4_CFG.Reg) & 0xe000000) >> 25
}

// GPIOSD.ETM_TASK_P5_CFG: Etm Configure Register to decide which GPIO been chosen
func (o *GPIOSD_Type) SetETM_TASK_P5_CFG_ETM_TASK_GPIO20_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P5_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetETM_TASK_P5_CFG_ETM_TASK_GPIO20_EN() uint32 {
	return volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg) & 0x1
}
func (o *GPIOSD_Type) SetETM_TASK_P5_CFG_ETM_TASK_GPIO20_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P5_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg)&^(0xe)|value<<1)
}
func (o *GPIOSD_Type) GetETM_TASK_P5_CFG_ETM_TASK_GPIO20_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg) & 0xe) >> 1
}
func (o *GPIOSD_Type) SetETM_TASK_P5_CFG_ETM_TASK_GPIO21_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P5_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIOSD_Type) GetETM_TASK_P5_CFG_ETM_TASK_GPIO21_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg) & 0x100) >> 8
}
func (o *GPIOSD_Type) SetETM_TASK_P5_CFG_ETM_TASK_GPIO21_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P5_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg)&^(0xe00)|value<<9)
}
func (o *GPIOSD_Type) GetETM_TASK_P5_CFG_ETM_TASK_GPIO21_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg) & 0xe00) >> 9
}
func (o *GPIOSD_Type) SetETM_TASK_P5_CFG_ETM_TASK_GPIO22_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P5_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOSD_Type) GetETM_TASK_P5_CFG_ETM_TASK_GPIO22_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg) & 0x10000) >> 16
}
func (o *GPIOSD_Type) SetETM_TASK_P5_CFG_ETM_TASK_GPIO22_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P5_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg)&^(0xe0000)|value<<17)
}
func (o *GPIOSD_Type) GetETM_TASK_P5_CFG_ETM_TASK_GPIO22_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg) & 0xe0000) >> 17
}
func (o *GPIOSD_Type) SetETM_TASK_P5_CFG_ETM_TASK_GPIO23_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P5_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOSD_Type) GetETM_TASK_P5_CFG_ETM_TASK_GPIO23_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg) & 0x1000000) >> 24
}
func (o *GPIOSD_Type) SetETM_TASK_P5_CFG_ETM_TASK_GPIO23_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P5_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg)&^(0xe000000)|value<<25)
}
func (o *GPIOSD_Type) GetETM_TASK_P5_CFG_ETM_TASK_GPIO23_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P5_CFG.Reg) & 0xe000000) >> 25
}

// GPIOSD.ETM_TASK_P6_CFG: Etm Configure Register to decide which GPIO been chosen
func (o *GPIOSD_Type) SetETM_TASK_P6_CFG_ETM_TASK_GPIO24_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P6_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetETM_TASK_P6_CFG_ETM_TASK_GPIO24_EN() uint32 {
	return volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg) & 0x1
}
func (o *GPIOSD_Type) SetETM_TASK_P6_CFG_ETM_TASK_GPIO24_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P6_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg)&^(0xe)|value<<1)
}
func (o *GPIOSD_Type) GetETM_TASK_P6_CFG_ETM_TASK_GPIO24_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg) & 0xe) >> 1
}
func (o *GPIOSD_Type) SetETM_TASK_P6_CFG_ETM_TASK_GPIO25_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P6_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg)&^(0x100)|value<<8)
}
func (o *GPIOSD_Type) GetETM_TASK_P6_CFG_ETM_TASK_GPIO25_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg) & 0x100) >> 8
}
func (o *GPIOSD_Type) SetETM_TASK_P6_CFG_ETM_TASK_GPIO25_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P6_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg)&^(0xe00)|value<<9)
}
func (o *GPIOSD_Type) GetETM_TASK_P6_CFG_ETM_TASK_GPIO25_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg) & 0xe00) >> 9
}
func (o *GPIOSD_Type) SetETM_TASK_P6_CFG_ETM_TASK_GPIO26_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P6_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOSD_Type) GetETM_TASK_P6_CFG_ETM_TASK_GPIO26_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg) & 0x10000) >> 16
}
func (o *GPIOSD_Type) SetETM_TASK_P6_CFG_ETM_TASK_GPIO26_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P6_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg)&^(0xe0000)|value<<17)
}
func (o *GPIOSD_Type) GetETM_TASK_P6_CFG_ETM_TASK_GPIO26_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg) & 0xe0000) >> 17
}
func (o *GPIOSD_Type) SetETM_TASK_P6_CFG_ETM_TASK_GPIO27_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P6_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOSD_Type) GetETM_TASK_P6_CFG_ETM_TASK_GPIO27_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg) & 0x1000000) >> 24
}
func (o *GPIOSD_Type) SetETM_TASK_P6_CFG_ETM_TASK_GPIO27_SEL(value uint32) {
	volatile.StoreUint32(&o.ETM_TASK_P6_CFG.Reg, volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg)&^(0xe000000)|value<<25)
}
func (o *GPIOSD_Type) GetETM_TASK_P6_CFG_ETM_TASK_GPIO27_SEL() uint32 {
	return (volatile.LoadUint32(&o.ETM_TASK_P6_CFG.Reg) & 0xe000000) >> 25
}

// GPIOSD.INT_RAW: GPIOSD interrupt raw register
func (o *GPIOSD_Type) SetINT_RAW_PAD_COMP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetINT_RAW_PAD_COMP_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}

// GPIOSD.INT_ST: GPIOSD interrupt masked register
func (o *GPIOSD_Type) SetINT_ST_PAD_COMP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetINT_ST_PAD_COMP_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}

// GPIOSD.INT_ENA: GPIOSD interrupt enable register
func (o *GPIOSD_Type) SetINT_ENA_PAD_COMP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetINT_ENA_PAD_COMP_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}

// GPIOSD.INT_CLR: GPIOSD interrupt clear register
func (o *GPIOSD_Type) SetINT_CLR_PAD_COMP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *GPIOSD_Type) GetINT_CLR_PAD_COMP_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}

// GPIOSD.VERSION: Version Control Register
func (o *GPIOSD_Type) SetVERSION_GPIO_SD_DATE(value uint32) {
	volatile.StoreUint32(&o.VERSION.Reg, volatile.LoadUint32(&o.VERSION.Reg)&^(0xfffffff)|value)
}
func (o *GPIOSD_Type) GetVERSION_GPIO_SD_DATE() uint32 {
	return volatile.LoadUint32(&o.VERSION.Reg) & 0xfffffff
}

// HMAC (Hash-based Message Authentication Code) Accelerator
type HMAC_Type struct {
	_                   [64]byte
	SET_START           volatile.Register32 // 0x40
	SET_PARA_PURPOSE    volatile.Register32 // 0x44
	SET_PARA_KEY        volatile.Register32 // 0x48
	SET_PARA_FINISH     volatile.Register32 // 0x4C
	SET_MESSAGE_ONE     volatile.Register32 // 0x50
	SET_MESSAGE_ING     volatile.Register32 // 0x54
	SET_MESSAGE_END     volatile.Register32 // 0x58
	SET_RESULT_FINISH   volatile.Register32 // 0x5C
	SET_INVALIDATE_JTAG volatile.Register32 // 0x60
	SET_INVALIDATE_DS   volatile.Register32 // 0x64
	QUERY_ERROR         volatile.Register32 // 0x68
	QUERY_BUSY          volatile.Register32 // 0x6C
	_                   [16]byte
	WR_MESSAGE_MEM      [64]volatile.Register8 // 0x80
	RD_RESULT_MEM       [32]volatile.Register8 // 0xC0
	_                   [16]byte
	SET_MESSAGE_PAD     volatile.Register32 // 0xF0
	ONE_BLOCK           volatile.Register32 // 0xF4
	SOFT_JTAG_CTRL      volatile.Register32 // 0xF8
	WR_JTAG             volatile.Register32 // 0xFC
	_                   [252]byte
	DATE                volatile.Register32 // 0x1FC
}

// HMAC.SET_START: Process control register 0.
func (o *HMAC_Type) SetSET_START(value uint32) {
	volatile.StoreUint32(&o.SET_START.Reg, volatile.LoadUint32(&o.SET_START.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_START() uint32 {
	return volatile.LoadUint32(&o.SET_START.Reg) & 0x1
}

// HMAC.SET_PARA_PURPOSE: Configure purpose.
func (o *HMAC_Type) SetSET_PARA_PURPOSE_PURPOSE_SET(value uint32) {
	volatile.StoreUint32(&o.SET_PARA_PURPOSE.Reg, volatile.LoadUint32(&o.SET_PARA_PURPOSE.Reg)&^(0xf)|value)
}
func (o *HMAC_Type) GetSET_PARA_PURPOSE_PURPOSE_SET() uint32 {
	return volatile.LoadUint32(&o.SET_PARA_PURPOSE.Reg) & 0xf
}

// HMAC.SET_PARA_KEY: Configure key.
func (o *HMAC_Type) SetSET_PARA_KEY_KEY_SET(value uint32) {
	volatile.StoreUint32(&o.SET_PARA_KEY.Reg, volatile.LoadUint32(&o.SET_PARA_KEY.Reg)&^(0x7)|value)
}
func (o *HMAC_Type) GetSET_PARA_KEY_KEY_SET() uint32 {
	return volatile.LoadUint32(&o.SET_PARA_KEY.Reg) & 0x7
}

// HMAC.SET_PARA_FINISH: Finish initial configuration.
func (o *HMAC_Type) SetSET_PARA_FINISH_SET_PARA_END(value uint32) {
	volatile.StoreUint32(&o.SET_PARA_FINISH.Reg, volatile.LoadUint32(&o.SET_PARA_FINISH.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_PARA_FINISH_SET_PARA_END() uint32 {
	return volatile.LoadUint32(&o.SET_PARA_FINISH.Reg) & 0x1
}

// HMAC.SET_MESSAGE_ONE: Process control register 1.
func (o *HMAC_Type) SetSET_MESSAGE_ONE_SET_TEXT_ONE(value uint32) {
	volatile.StoreUint32(&o.SET_MESSAGE_ONE.Reg, volatile.LoadUint32(&o.SET_MESSAGE_ONE.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_MESSAGE_ONE_SET_TEXT_ONE() uint32 {
	return volatile.LoadUint32(&o.SET_MESSAGE_ONE.Reg) & 0x1
}

// HMAC.SET_MESSAGE_ING: Process control register 2.
func (o *HMAC_Type) SetSET_MESSAGE_ING_SET_TEXT_ING(value uint32) {
	volatile.StoreUint32(&o.SET_MESSAGE_ING.Reg, volatile.LoadUint32(&o.SET_MESSAGE_ING.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_MESSAGE_ING_SET_TEXT_ING() uint32 {
	return volatile.LoadUint32(&o.SET_MESSAGE_ING.Reg) & 0x1
}

// HMAC.SET_MESSAGE_END: Process control register 3.
func (o *HMAC_Type) SetSET_MESSAGE_END_SET_TEXT_END(value uint32) {
	volatile.StoreUint32(&o.SET_MESSAGE_END.Reg, volatile.LoadUint32(&o.SET_MESSAGE_END.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_MESSAGE_END_SET_TEXT_END() uint32 {
	return volatile.LoadUint32(&o.SET_MESSAGE_END.Reg) & 0x1
}

// HMAC.SET_RESULT_FINISH: Process control register 4.
func (o *HMAC_Type) SetSET_RESULT_FINISH_SET_RESULT_END(value uint32) {
	volatile.StoreUint32(&o.SET_RESULT_FINISH.Reg, volatile.LoadUint32(&o.SET_RESULT_FINISH.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_RESULT_FINISH_SET_RESULT_END() uint32 {
	return volatile.LoadUint32(&o.SET_RESULT_FINISH.Reg) & 0x1
}

// HMAC.SET_INVALIDATE_JTAG: Invalidate register 0.
func (o *HMAC_Type) SetSET_INVALIDATE_JTAG(value uint32) {
	volatile.StoreUint32(&o.SET_INVALIDATE_JTAG.Reg, volatile.LoadUint32(&o.SET_INVALIDATE_JTAG.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_INVALIDATE_JTAG() uint32 {
	return volatile.LoadUint32(&o.SET_INVALIDATE_JTAG.Reg) & 0x1
}

// HMAC.SET_INVALIDATE_DS: Invalidate register 1.
func (o *HMAC_Type) SetSET_INVALIDATE_DS(value uint32) {
	volatile.StoreUint32(&o.SET_INVALIDATE_DS.Reg, volatile.LoadUint32(&o.SET_INVALIDATE_DS.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_INVALIDATE_DS() uint32 {
	return volatile.LoadUint32(&o.SET_INVALIDATE_DS.Reg) & 0x1
}

// HMAC.QUERY_ERROR: Error register.
func (o *HMAC_Type) SetQUERY_ERROR_QUERY_CHECK(value uint32) {
	volatile.StoreUint32(&o.QUERY_ERROR.Reg, volatile.LoadUint32(&o.QUERY_ERROR.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetQUERY_ERROR_QUERY_CHECK() uint32 {
	return volatile.LoadUint32(&o.QUERY_ERROR.Reg) & 0x1
}

// HMAC.QUERY_BUSY: Busy register.
func (o *HMAC_Type) SetQUERY_BUSY_BUSY_STATE(value uint32) {
	volatile.StoreUint32(&o.QUERY_BUSY.Reg, volatile.LoadUint32(&o.QUERY_BUSY.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetQUERY_BUSY_BUSY_STATE() uint32 {
	return volatile.LoadUint32(&o.QUERY_BUSY.Reg) & 0x1
}

// HMAC.SET_MESSAGE_PAD: Process control register 5.
func (o *HMAC_Type) SetSET_MESSAGE_PAD_SET_TEXT_PAD(value uint32) {
	volatile.StoreUint32(&o.SET_MESSAGE_PAD.Reg, volatile.LoadUint32(&o.SET_MESSAGE_PAD.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_MESSAGE_PAD_SET_TEXT_PAD() uint32 {
	return volatile.LoadUint32(&o.SET_MESSAGE_PAD.Reg) & 0x1
}

// HMAC.ONE_BLOCK: Process control register 6.
func (o *HMAC_Type) SetONE_BLOCK_SET_ONE_BLOCK(value uint32) {
	volatile.StoreUint32(&o.ONE_BLOCK.Reg, volatile.LoadUint32(&o.ONE_BLOCK.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetONE_BLOCK_SET_ONE_BLOCK() uint32 {
	return volatile.LoadUint32(&o.ONE_BLOCK.Reg) & 0x1
}

// HMAC.SOFT_JTAG_CTRL: Jtag register 0.
func (o *HMAC_Type) SetSOFT_JTAG_CTRL(value uint32) {
	volatile.StoreUint32(&o.SOFT_JTAG_CTRL.Reg, volatile.LoadUint32(&o.SOFT_JTAG_CTRL.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSOFT_JTAG_CTRL() uint32 {
	return volatile.LoadUint32(&o.SOFT_JTAG_CTRL.Reg) & 0x1
}

// HMAC.WR_JTAG: Jtag register 1.
func (o *HMAC_Type) SetWR_JTAG(value uint32) {
	volatile.StoreUint32(&o.WR_JTAG.Reg, value)
}
func (o *HMAC_Type) GetWR_JTAG() uint32 {
	return volatile.LoadUint32(&o.WR_JTAG.Reg)
}

// HMAC.DATE: Date register.
func (o *HMAC_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *HMAC_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// HP_APM Peripheral
type HP_APM_Type struct {
	REGION_FILTER_EN    volatile.Register32 // 0x0
	REGION0_ADDR_START  volatile.Register32 // 0x4
	REGION0_ADDR_END    volatile.Register32 // 0x8
	REGION0_PMS_ATTR    volatile.Register32 // 0xC
	REGION1_ADDR_START  volatile.Register32 // 0x10
	REGION1_ADDR_END    volatile.Register32 // 0x14
	REGION1_PMS_ATTR    volatile.Register32 // 0x18
	REGION2_ADDR_START  volatile.Register32 // 0x1C
	REGION2_ADDR_END    volatile.Register32 // 0x20
	REGION2_PMS_ATTR    volatile.Register32 // 0x24
	REGION3_ADDR_START  volatile.Register32 // 0x28
	REGION3_ADDR_END    volatile.Register32 // 0x2C
	REGION3_PMS_ATTR    volatile.Register32 // 0x30
	REGION4_ADDR_START  volatile.Register32 // 0x34
	REGION4_ADDR_END    volatile.Register32 // 0x38
	REGION4_PMS_ATTR    volatile.Register32 // 0x3C
	REGION5_ADDR_START  volatile.Register32 // 0x40
	REGION5_ADDR_END    volatile.Register32 // 0x44
	REGION5_PMS_ATTR    volatile.Register32 // 0x48
	REGION6_ADDR_START  volatile.Register32 // 0x4C
	REGION6_ADDR_END    volatile.Register32 // 0x50
	REGION6_PMS_ATTR    volatile.Register32 // 0x54
	REGION7_ADDR_START  volatile.Register32 // 0x58
	REGION7_ADDR_END    volatile.Register32 // 0x5C
	REGION7_PMS_ATTR    volatile.Register32 // 0x60
	REGION8_ADDR_START  volatile.Register32 // 0x64
	REGION8_ADDR_END    volatile.Register32 // 0x68
	REGION8_PMS_ATTR    volatile.Register32 // 0x6C
	REGION9_ADDR_START  volatile.Register32 // 0x70
	REGION9_ADDR_END    volatile.Register32 // 0x74
	REGION9_PMS_ATTR    volatile.Register32 // 0x78
	REGION10_ADDR_START volatile.Register32 // 0x7C
	REGION10_ADDR_END   volatile.Register32 // 0x80
	REGION10_PMS_ATTR   volatile.Register32 // 0x84
	REGION11_ADDR_START volatile.Register32 // 0x88
	REGION11_ADDR_END   volatile.Register32 // 0x8C
	REGION11_PMS_ATTR   volatile.Register32 // 0x90
	REGION12_ADDR_START volatile.Register32 // 0x94
	REGION12_ADDR_END   volatile.Register32 // 0x98
	REGION12_PMS_ATTR   volatile.Register32 // 0x9C
	REGION13_ADDR_START volatile.Register32 // 0xA0
	REGION13_ADDR_END   volatile.Register32 // 0xA4
	REGION13_PMS_ATTR   volatile.Register32 // 0xA8
	REGION14_ADDR_START volatile.Register32 // 0xAC
	REGION14_ADDR_END   volatile.Register32 // 0xB0
	REGION14_PMS_ATTR   volatile.Register32 // 0xB4
	REGION15_ADDR_START volatile.Register32 // 0xB8
	REGION15_ADDR_END   volatile.Register32 // 0xBC
	REGION15_PMS_ATTR   volatile.Register32 // 0xC0
	FUNC_CTRL           volatile.Register32 // 0xC4
	M0_STATUS           volatile.Register32 // 0xC8
	M0_STATUS_CLR       volatile.Register32 // 0xCC
	M0_EXCEPTION_INFO0  volatile.Register32 // 0xD0
	M0_EXCEPTION_INFO1  volatile.Register32 // 0xD4
	M1_STATUS           volatile.Register32 // 0xD8
	M1_STATUS_CLR       volatile.Register32 // 0xDC
	M1_EXCEPTION_INFO0  volatile.Register32 // 0xE0
	M1_EXCEPTION_INFO1  volatile.Register32 // 0xE4
	M2_STATUS           volatile.Register32 // 0xE8
	M2_STATUS_CLR       volatile.Register32 // 0xEC
	M2_EXCEPTION_INFO0  volatile.Register32 // 0xF0
	M2_EXCEPTION_INFO1  volatile.Register32 // 0xF4
	M3_STATUS           volatile.Register32 // 0xF8
	M3_STATUS_CLR       volatile.Register32 // 0xFC
	M3_EXCEPTION_INFO0  volatile.Register32 // 0x100
	M3_EXCEPTION_INFO1  volatile.Register32 // 0x104
	INT_EN              volatile.Register32 // 0x108
	CLOCK_GATE          volatile.Register32 // 0x10C
	_                   [1772]byte
	DATE                volatile.Register32 // 0x7FC
}

// HP_APM.REGION_FILTER_EN: Region filter enable register
func (o *HP_APM_Type) SetREGION_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.REGION_FILTER_EN.Reg, volatile.LoadUint32(&o.REGION_FILTER_EN.Reg)&^(0xffff)|value)
}
func (o *HP_APM_Type) GetREGION_FILTER_EN() uint32 {
	return volatile.LoadUint32(&o.REGION_FILTER_EN.Reg) & 0xffff
}

// HP_APM.REGION0_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION0_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION0_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION0_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION0_ADDR_START.Reg)
}

// HP_APM.REGION0_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION0_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION0_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION0_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION0_ADDR_END.Reg)
}

// HP_APM.REGION0_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION1_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION1_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION1_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION1_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION1_ADDR_START.Reg)
}

// HP_APM.REGION1_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION1_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION1_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION1_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION1_ADDR_END.Reg)
}

// HP_APM.REGION1_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION2_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION2_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION2_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION2_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION2_ADDR_START.Reg)
}

// HP_APM.REGION2_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION2_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION2_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION2_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION2_ADDR_END.Reg)
}

// HP_APM.REGION2_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION2_PMS_ATTR_REGION2_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION2_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION2_PMS_ATTR_REGION2_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION2_PMS_ATTR_REGION2_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION2_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION2_PMS_ATTR_REGION2_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION2_PMS_ATTR_REGION2_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION2_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION2_PMS_ATTR_REGION2_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION2_PMS_ATTR_REGION2_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION2_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION2_PMS_ATTR_REGION2_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION2_PMS_ATTR_REGION2_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION2_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION2_PMS_ATTR_REGION2_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION2_PMS_ATTR_REGION2_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION2_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION2_PMS_ATTR_REGION2_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION2_PMS_ATTR_REGION2_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION2_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION2_PMS_ATTR_REGION2_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION2_PMS_ATTR_REGION2_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION2_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION2_PMS_ATTR_REGION2_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION2_PMS_ATTR_REGION2_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION2_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION2_PMS_ATTR_REGION2_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION2_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION3_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION3_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION3_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION3_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION3_ADDR_START.Reg)
}

// HP_APM.REGION3_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION3_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION3_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION3_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION3_ADDR_END.Reg)
}

// HP_APM.REGION3_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION3_PMS_ATTR_REGION3_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION3_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION3_PMS_ATTR_REGION3_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION3_PMS_ATTR_REGION3_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION3_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION3_PMS_ATTR_REGION3_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION3_PMS_ATTR_REGION3_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION3_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION3_PMS_ATTR_REGION3_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION3_PMS_ATTR_REGION3_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION3_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION3_PMS_ATTR_REGION3_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION3_PMS_ATTR_REGION3_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION3_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION3_PMS_ATTR_REGION3_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION3_PMS_ATTR_REGION3_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION3_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION3_PMS_ATTR_REGION3_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION3_PMS_ATTR_REGION3_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION3_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION3_PMS_ATTR_REGION3_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION3_PMS_ATTR_REGION3_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION3_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION3_PMS_ATTR_REGION3_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION3_PMS_ATTR_REGION3_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION3_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION3_PMS_ATTR_REGION3_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION3_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION4_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION4_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION4_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION4_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION4_ADDR_START.Reg)
}

// HP_APM.REGION4_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION4_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION4_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION4_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION4_ADDR_END.Reg)
}

// HP_APM.REGION4_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION4_PMS_ATTR_REGION4_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION4_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION4_PMS_ATTR_REGION4_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION4_PMS_ATTR_REGION4_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION4_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION4_PMS_ATTR_REGION4_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION4_PMS_ATTR_REGION4_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION4_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION4_PMS_ATTR_REGION4_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION4_PMS_ATTR_REGION4_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION4_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION4_PMS_ATTR_REGION4_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION4_PMS_ATTR_REGION4_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION4_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION4_PMS_ATTR_REGION4_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION4_PMS_ATTR_REGION4_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION4_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION4_PMS_ATTR_REGION4_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION4_PMS_ATTR_REGION4_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION4_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION4_PMS_ATTR_REGION4_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION4_PMS_ATTR_REGION4_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION4_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION4_PMS_ATTR_REGION4_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION4_PMS_ATTR_REGION4_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION4_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION4_PMS_ATTR_REGION4_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION4_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION5_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION5_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION5_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION5_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION5_ADDR_START.Reg)
}

// HP_APM.REGION5_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION5_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION5_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION5_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION5_ADDR_END.Reg)
}

// HP_APM.REGION5_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION5_PMS_ATTR_REGION5_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION5_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION5_PMS_ATTR_REGION5_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION5_PMS_ATTR_REGION5_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION5_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION5_PMS_ATTR_REGION5_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION5_PMS_ATTR_REGION5_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION5_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION5_PMS_ATTR_REGION5_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION5_PMS_ATTR_REGION5_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION5_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION5_PMS_ATTR_REGION5_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION5_PMS_ATTR_REGION5_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION5_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION5_PMS_ATTR_REGION5_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION5_PMS_ATTR_REGION5_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION5_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION5_PMS_ATTR_REGION5_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION5_PMS_ATTR_REGION5_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION5_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION5_PMS_ATTR_REGION5_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION5_PMS_ATTR_REGION5_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION5_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION5_PMS_ATTR_REGION5_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION5_PMS_ATTR_REGION5_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION5_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION5_PMS_ATTR_REGION5_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION5_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION6_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION6_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION6_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION6_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION6_ADDR_START.Reg)
}

// HP_APM.REGION6_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION6_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION6_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION6_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION6_ADDR_END.Reg)
}

// HP_APM.REGION6_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION6_PMS_ATTR_REGION6_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION6_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION6_PMS_ATTR_REGION6_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION6_PMS_ATTR_REGION6_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION6_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION6_PMS_ATTR_REGION6_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION6_PMS_ATTR_REGION6_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION6_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION6_PMS_ATTR_REGION6_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION6_PMS_ATTR_REGION6_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION6_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION6_PMS_ATTR_REGION6_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION6_PMS_ATTR_REGION6_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION6_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION6_PMS_ATTR_REGION6_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION6_PMS_ATTR_REGION6_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION6_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION6_PMS_ATTR_REGION6_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION6_PMS_ATTR_REGION6_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION6_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION6_PMS_ATTR_REGION6_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION6_PMS_ATTR_REGION6_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION6_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION6_PMS_ATTR_REGION6_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION6_PMS_ATTR_REGION6_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION6_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION6_PMS_ATTR_REGION6_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION6_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION7_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION7_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION7_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION7_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION7_ADDR_START.Reg)
}

// HP_APM.REGION7_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION7_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION7_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION7_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION7_ADDR_END.Reg)
}

// HP_APM.REGION7_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION7_PMS_ATTR_REGION7_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION7_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION7_PMS_ATTR_REGION7_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION7_PMS_ATTR_REGION7_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION7_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION7_PMS_ATTR_REGION7_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION7_PMS_ATTR_REGION7_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION7_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION7_PMS_ATTR_REGION7_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION7_PMS_ATTR_REGION7_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION7_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION7_PMS_ATTR_REGION7_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION7_PMS_ATTR_REGION7_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION7_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION7_PMS_ATTR_REGION7_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION7_PMS_ATTR_REGION7_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION7_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION7_PMS_ATTR_REGION7_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION7_PMS_ATTR_REGION7_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION7_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION7_PMS_ATTR_REGION7_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION7_PMS_ATTR_REGION7_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION7_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION7_PMS_ATTR_REGION7_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION7_PMS_ATTR_REGION7_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION7_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION7_PMS_ATTR_REGION7_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION7_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION8_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION8_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION8_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION8_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION8_ADDR_START.Reg)
}

// HP_APM.REGION8_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION8_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION8_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION8_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION8_ADDR_END.Reg)
}

// HP_APM.REGION8_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION8_PMS_ATTR_REGION8_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION8_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION8_PMS_ATTR_REGION8_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION8_PMS_ATTR_REGION8_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION8_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION8_PMS_ATTR_REGION8_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION8_PMS_ATTR_REGION8_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION8_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION8_PMS_ATTR_REGION8_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION8_PMS_ATTR_REGION8_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION8_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION8_PMS_ATTR_REGION8_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION8_PMS_ATTR_REGION8_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION8_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION8_PMS_ATTR_REGION8_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION8_PMS_ATTR_REGION8_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION8_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION8_PMS_ATTR_REGION8_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION8_PMS_ATTR_REGION8_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION8_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION8_PMS_ATTR_REGION8_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION8_PMS_ATTR_REGION8_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION8_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION8_PMS_ATTR_REGION8_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION8_PMS_ATTR_REGION8_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION8_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION8_PMS_ATTR_REGION8_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION8_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION9_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION9_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION9_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION9_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION9_ADDR_START.Reg)
}

// HP_APM.REGION9_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION9_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION9_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION9_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION9_ADDR_END.Reg)
}

// HP_APM.REGION9_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION9_PMS_ATTR_REGION9_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION9_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION9_PMS_ATTR_REGION9_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION9_PMS_ATTR_REGION9_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION9_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION9_PMS_ATTR_REGION9_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION9_PMS_ATTR_REGION9_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION9_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION9_PMS_ATTR_REGION9_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION9_PMS_ATTR_REGION9_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION9_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION9_PMS_ATTR_REGION9_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION9_PMS_ATTR_REGION9_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION9_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION9_PMS_ATTR_REGION9_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION9_PMS_ATTR_REGION9_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION9_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION9_PMS_ATTR_REGION9_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION9_PMS_ATTR_REGION9_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION9_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION9_PMS_ATTR_REGION9_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION9_PMS_ATTR_REGION9_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION9_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION9_PMS_ATTR_REGION9_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION9_PMS_ATTR_REGION9_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION9_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION9_PMS_ATTR_REGION9_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION9_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION10_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION10_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION10_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION10_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION10_ADDR_START.Reg)
}

// HP_APM.REGION10_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION10_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION10_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION10_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION10_ADDR_END.Reg)
}

// HP_APM.REGION10_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION10_PMS_ATTR_REGION10_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION10_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION10_PMS_ATTR_REGION10_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION10_PMS_ATTR_REGION10_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION10_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION10_PMS_ATTR_REGION10_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION10_PMS_ATTR_REGION10_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION10_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION10_PMS_ATTR_REGION10_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION10_PMS_ATTR_REGION10_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION10_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION10_PMS_ATTR_REGION10_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION10_PMS_ATTR_REGION10_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION10_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION10_PMS_ATTR_REGION10_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION10_PMS_ATTR_REGION10_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION10_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION10_PMS_ATTR_REGION10_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION10_PMS_ATTR_REGION10_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION10_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION10_PMS_ATTR_REGION10_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION10_PMS_ATTR_REGION10_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION10_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION10_PMS_ATTR_REGION10_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION10_PMS_ATTR_REGION10_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION10_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION10_PMS_ATTR_REGION10_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION10_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION11_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION11_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION11_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION11_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION11_ADDR_START.Reg)
}

// HP_APM.REGION11_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION11_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION11_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION11_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION11_ADDR_END.Reg)
}

// HP_APM.REGION11_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION11_PMS_ATTR_REGION11_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION11_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION11_PMS_ATTR_REGION11_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION11_PMS_ATTR_REGION11_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION11_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION11_PMS_ATTR_REGION11_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION11_PMS_ATTR_REGION11_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION11_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION11_PMS_ATTR_REGION11_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION11_PMS_ATTR_REGION11_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION11_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION11_PMS_ATTR_REGION11_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION11_PMS_ATTR_REGION11_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION11_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION11_PMS_ATTR_REGION11_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION11_PMS_ATTR_REGION11_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION11_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION11_PMS_ATTR_REGION11_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION11_PMS_ATTR_REGION11_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION11_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION11_PMS_ATTR_REGION11_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION11_PMS_ATTR_REGION11_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION11_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION11_PMS_ATTR_REGION11_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION11_PMS_ATTR_REGION11_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION11_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION11_PMS_ATTR_REGION11_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION11_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION12_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION12_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION12_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION12_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION12_ADDR_START.Reg)
}

// HP_APM.REGION12_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION12_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION12_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION12_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION12_ADDR_END.Reg)
}

// HP_APM.REGION12_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION12_PMS_ATTR_REGION12_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION12_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION12_PMS_ATTR_REGION12_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION12_PMS_ATTR_REGION12_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION12_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION12_PMS_ATTR_REGION12_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION12_PMS_ATTR_REGION12_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION12_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION12_PMS_ATTR_REGION12_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION12_PMS_ATTR_REGION12_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION12_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION12_PMS_ATTR_REGION12_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION12_PMS_ATTR_REGION12_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION12_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION12_PMS_ATTR_REGION12_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION12_PMS_ATTR_REGION12_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION12_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION12_PMS_ATTR_REGION12_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION12_PMS_ATTR_REGION12_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION12_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION12_PMS_ATTR_REGION12_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION12_PMS_ATTR_REGION12_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION12_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION12_PMS_ATTR_REGION12_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION12_PMS_ATTR_REGION12_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION12_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION12_PMS_ATTR_REGION12_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION12_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION13_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION13_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION13_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION13_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION13_ADDR_START.Reg)
}

// HP_APM.REGION13_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION13_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION13_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION13_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION13_ADDR_END.Reg)
}

// HP_APM.REGION13_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION13_PMS_ATTR_REGION13_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION13_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION13_PMS_ATTR_REGION13_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION13_PMS_ATTR_REGION13_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION13_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION13_PMS_ATTR_REGION13_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION13_PMS_ATTR_REGION13_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION13_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION13_PMS_ATTR_REGION13_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION13_PMS_ATTR_REGION13_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION13_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION13_PMS_ATTR_REGION13_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION13_PMS_ATTR_REGION13_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION13_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION13_PMS_ATTR_REGION13_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION13_PMS_ATTR_REGION13_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION13_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION13_PMS_ATTR_REGION13_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION13_PMS_ATTR_REGION13_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION13_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION13_PMS_ATTR_REGION13_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION13_PMS_ATTR_REGION13_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION13_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION13_PMS_ATTR_REGION13_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION13_PMS_ATTR_REGION13_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION13_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION13_PMS_ATTR_REGION13_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION13_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION14_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION14_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION14_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION14_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION14_ADDR_START.Reg)
}

// HP_APM.REGION14_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION14_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION14_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION14_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION14_ADDR_END.Reg)
}

// HP_APM.REGION14_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION14_PMS_ATTR_REGION14_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION14_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION14_PMS_ATTR_REGION14_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION14_PMS_ATTR_REGION14_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION14_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION14_PMS_ATTR_REGION14_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION14_PMS_ATTR_REGION14_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION14_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION14_PMS_ATTR_REGION14_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION14_PMS_ATTR_REGION14_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION14_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION14_PMS_ATTR_REGION14_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION14_PMS_ATTR_REGION14_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION14_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION14_PMS_ATTR_REGION14_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION14_PMS_ATTR_REGION14_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION14_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION14_PMS_ATTR_REGION14_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION14_PMS_ATTR_REGION14_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION14_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION14_PMS_ATTR_REGION14_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION14_PMS_ATTR_REGION14_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION14_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION14_PMS_ATTR_REGION14_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION14_PMS_ATTR_REGION14_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION14_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION14_PMS_ATTR_REGION14_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION14_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.REGION15_ADDR_START: Region address register
func (o *HP_APM_Type) SetREGION15_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION15_ADDR_START.Reg, value)
}
func (o *HP_APM_Type) GetREGION15_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION15_ADDR_START.Reg)
}

// HP_APM.REGION15_ADDR_END: Region address register
func (o *HP_APM_Type) SetREGION15_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION15_ADDR_END.Reg, value)
}
func (o *HP_APM_Type) GetREGION15_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION15_ADDR_END.Reg)
}

// HP_APM.REGION15_PMS_ATTR: Region access authority attribute register
func (o *HP_APM_Type) SetREGION15_PMS_ATTR_REGION15_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION15_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetREGION15_PMS_ATTR_REGION15_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg) & 0x1
}
func (o *HP_APM_Type) SetREGION15_PMS_ATTR_REGION15_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION15_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetREGION15_PMS_ATTR_REGION15_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetREGION15_PMS_ATTR_REGION15_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION15_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetREGION15_PMS_ATTR_REGION15_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetREGION15_PMS_ATTR_REGION15_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION15_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *HP_APM_Type) GetREGION15_PMS_ATTR_REGION15_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *HP_APM_Type) SetREGION15_PMS_ATTR_REGION15_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION15_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *HP_APM_Type) GetREGION15_PMS_ATTR_REGION15_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *HP_APM_Type) SetREGION15_PMS_ATTR_REGION15_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION15_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *HP_APM_Type) GetREGION15_PMS_ATTR_REGION15_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *HP_APM_Type) SetREGION15_PMS_ATTR_REGION15_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION15_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *HP_APM_Type) GetREGION15_PMS_ATTR_REGION15_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *HP_APM_Type) SetREGION15_PMS_ATTR_REGION15_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION15_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *HP_APM_Type) GetREGION15_PMS_ATTR_REGION15_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *HP_APM_Type) SetREGION15_PMS_ATTR_REGION15_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION15_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *HP_APM_Type) GetREGION15_PMS_ATTR_REGION15_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION15_PMS_ATTR.Reg) & 0x400) >> 10
}

// HP_APM.FUNC_CTRL: PMS function control register
func (o *HP_APM_Type) SetFUNC_CTRL_M0_PMS_FUNC_EN(value uint32) {
	volatile.StoreUint32(&o.FUNC_CTRL.Reg, volatile.LoadUint32(&o.FUNC_CTRL.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetFUNC_CTRL_M0_PMS_FUNC_EN() uint32 {
	return volatile.LoadUint32(&o.FUNC_CTRL.Reg) & 0x1
}
func (o *HP_APM_Type) SetFUNC_CTRL_M1_PMS_FUNC_EN(value uint32) {
	volatile.StoreUint32(&o.FUNC_CTRL.Reg, volatile.LoadUint32(&o.FUNC_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetFUNC_CTRL_M1_PMS_FUNC_EN() uint32 {
	return (volatile.LoadUint32(&o.FUNC_CTRL.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetFUNC_CTRL_M2_PMS_FUNC_EN(value uint32) {
	volatile.StoreUint32(&o.FUNC_CTRL.Reg, volatile.LoadUint32(&o.FUNC_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetFUNC_CTRL_M2_PMS_FUNC_EN() uint32 {
	return (volatile.LoadUint32(&o.FUNC_CTRL.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetFUNC_CTRL_M3_PMS_FUNC_EN(value uint32) {
	volatile.StoreUint32(&o.FUNC_CTRL.Reg, volatile.LoadUint32(&o.FUNC_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *HP_APM_Type) GetFUNC_CTRL_M3_PMS_FUNC_EN() uint32 {
	return (volatile.LoadUint32(&o.FUNC_CTRL.Reg) & 0x8) >> 3
}

// HP_APM.M0_STATUS: M0 status register
func (o *HP_APM_Type) SetM0_STATUS_M0_EXCEPTION_STATUS(value uint32) {
	volatile.StoreUint32(&o.M0_STATUS.Reg, volatile.LoadUint32(&o.M0_STATUS.Reg)&^(0x3)|value)
}
func (o *HP_APM_Type) GetM0_STATUS_M0_EXCEPTION_STATUS() uint32 {
	return volatile.LoadUint32(&o.M0_STATUS.Reg) & 0x3
}

// HP_APM.M0_STATUS_CLR: M0 status clear register
func (o *HP_APM_Type) SetM0_STATUS_CLR_M0_REGION_STATUS_CLR(value uint32) {
	volatile.StoreUint32(&o.M0_STATUS_CLR.Reg, volatile.LoadUint32(&o.M0_STATUS_CLR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetM0_STATUS_CLR_M0_REGION_STATUS_CLR() uint32 {
	return volatile.LoadUint32(&o.M0_STATUS_CLR.Reg) & 0x1
}

// HP_APM.M0_EXCEPTION_INFO0: M0 exception_info0 register
func (o *HP_APM_Type) SetM0_EXCEPTION_INFO0_M0_EXCEPTION_REGION(value uint32) {
	volatile.StoreUint32(&o.M0_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M0_EXCEPTION_INFO0.Reg)&^(0xffff)|value)
}
func (o *HP_APM_Type) GetM0_EXCEPTION_INFO0_M0_EXCEPTION_REGION() uint32 {
	return volatile.LoadUint32(&o.M0_EXCEPTION_INFO0.Reg) & 0xffff
}
func (o *HP_APM_Type) SetM0_EXCEPTION_INFO0_M0_EXCEPTION_MODE(value uint32) {
	volatile.StoreUint32(&o.M0_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M0_EXCEPTION_INFO0.Reg)&^(0x30000)|value<<16)
}
func (o *HP_APM_Type) GetM0_EXCEPTION_INFO0_M0_EXCEPTION_MODE() uint32 {
	return (volatile.LoadUint32(&o.M0_EXCEPTION_INFO0.Reg) & 0x30000) >> 16
}
func (o *HP_APM_Type) SetM0_EXCEPTION_INFO0_M0_EXCEPTION_ID(value uint32) {
	volatile.StoreUint32(&o.M0_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M0_EXCEPTION_INFO0.Reg)&^(0x7c0000)|value<<18)
}
func (o *HP_APM_Type) GetM0_EXCEPTION_INFO0_M0_EXCEPTION_ID() uint32 {
	return (volatile.LoadUint32(&o.M0_EXCEPTION_INFO0.Reg) & 0x7c0000) >> 18
}

// HP_APM.M0_EXCEPTION_INFO1: M0 exception_info1 register
func (o *HP_APM_Type) SetM0_EXCEPTION_INFO1(value uint32) {
	volatile.StoreUint32(&o.M0_EXCEPTION_INFO1.Reg, value)
}
func (o *HP_APM_Type) GetM0_EXCEPTION_INFO1() uint32 {
	return volatile.LoadUint32(&o.M0_EXCEPTION_INFO1.Reg)
}

// HP_APM.M1_STATUS: M1 status register
func (o *HP_APM_Type) SetM1_STATUS_M1_EXCEPTION_STATUS(value uint32) {
	volatile.StoreUint32(&o.M1_STATUS.Reg, volatile.LoadUint32(&o.M1_STATUS.Reg)&^(0x3)|value)
}
func (o *HP_APM_Type) GetM1_STATUS_M1_EXCEPTION_STATUS() uint32 {
	return volatile.LoadUint32(&o.M1_STATUS.Reg) & 0x3
}

// HP_APM.M1_STATUS_CLR: M1 status clear register
func (o *HP_APM_Type) SetM1_STATUS_CLR_M1_REGION_STATUS_CLR(value uint32) {
	volatile.StoreUint32(&o.M1_STATUS_CLR.Reg, volatile.LoadUint32(&o.M1_STATUS_CLR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetM1_STATUS_CLR_M1_REGION_STATUS_CLR() uint32 {
	return volatile.LoadUint32(&o.M1_STATUS_CLR.Reg) & 0x1
}

// HP_APM.M1_EXCEPTION_INFO0: M1 exception_info0 register
func (o *HP_APM_Type) SetM1_EXCEPTION_INFO0_M1_EXCEPTION_REGION(value uint32) {
	volatile.StoreUint32(&o.M1_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M1_EXCEPTION_INFO0.Reg)&^(0xffff)|value)
}
func (o *HP_APM_Type) GetM1_EXCEPTION_INFO0_M1_EXCEPTION_REGION() uint32 {
	return volatile.LoadUint32(&o.M1_EXCEPTION_INFO0.Reg) & 0xffff
}
func (o *HP_APM_Type) SetM1_EXCEPTION_INFO0_M1_EXCEPTION_MODE(value uint32) {
	volatile.StoreUint32(&o.M1_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M1_EXCEPTION_INFO0.Reg)&^(0x30000)|value<<16)
}
func (o *HP_APM_Type) GetM1_EXCEPTION_INFO0_M1_EXCEPTION_MODE() uint32 {
	return (volatile.LoadUint32(&o.M1_EXCEPTION_INFO0.Reg) & 0x30000) >> 16
}
func (o *HP_APM_Type) SetM1_EXCEPTION_INFO0_M1_EXCEPTION_ID(value uint32) {
	volatile.StoreUint32(&o.M1_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M1_EXCEPTION_INFO0.Reg)&^(0x7c0000)|value<<18)
}
func (o *HP_APM_Type) GetM1_EXCEPTION_INFO0_M1_EXCEPTION_ID() uint32 {
	return (volatile.LoadUint32(&o.M1_EXCEPTION_INFO0.Reg) & 0x7c0000) >> 18
}

// HP_APM.M1_EXCEPTION_INFO1: M1 exception_info1 register
func (o *HP_APM_Type) SetM1_EXCEPTION_INFO1(value uint32) {
	volatile.StoreUint32(&o.M1_EXCEPTION_INFO1.Reg, value)
}
func (o *HP_APM_Type) GetM1_EXCEPTION_INFO1() uint32 {
	return volatile.LoadUint32(&o.M1_EXCEPTION_INFO1.Reg)
}

// HP_APM.M2_STATUS: M2 status register
func (o *HP_APM_Type) SetM2_STATUS_M2_EXCEPTION_STATUS(value uint32) {
	volatile.StoreUint32(&o.M2_STATUS.Reg, volatile.LoadUint32(&o.M2_STATUS.Reg)&^(0x3)|value)
}
func (o *HP_APM_Type) GetM2_STATUS_M2_EXCEPTION_STATUS() uint32 {
	return volatile.LoadUint32(&o.M2_STATUS.Reg) & 0x3
}

// HP_APM.M2_STATUS_CLR: M2 status clear register
func (o *HP_APM_Type) SetM2_STATUS_CLR_M2_REGION_STATUS_CLR(value uint32) {
	volatile.StoreUint32(&o.M2_STATUS_CLR.Reg, volatile.LoadUint32(&o.M2_STATUS_CLR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetM2_STATUS_CLR_M2_REGION_STATUS_CLR() uint32 {
	return volatile.LoadUint32(&o.M2_STATUS_CLR.Reg) & 0x1
}

// HP_APM.M2_EXCEPTION_INFO0: M2 exception_info0 register
func (o *HP_APM_Type) SetM2_EXCEPTION_INFO0_M2_EXCEPTION_REGION(value uint32) {
	volatile.StoreUint32(&o.M2_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M2_EXCEPTION_INFO0.Reg)&^(0xffff)|value)
}
func (o *HP_APM_Type) GetM2_EXCEPTION_INFO0_M2_EXCEPTION_REGION() uint32 {
	return volatile.LoadUint32(&o.M2_EXCEPTION_INFO0.Reg) & 0xffff
}
func (o *HP_APM_Type) SetM2_EXCEPTION_INFO0_M2_EXCEPTION_MODE(value uint32) {
	volatile.StoreUint32(&o.M2_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M2_EXCEPTION_INFO0.Reg)&^(0x30000)|value<<16)
}
func (o *HP_APM_Type) GetM2_EXCEPTION_INFO0_M2_EXCEPTION_MODE() uint32 {
	return (volatile.LoadUint32(&o.M2_EXCEPTION_INFO0.Reg) & 0x30000) >> 16
}
func (o *HP_APM_Type) SetM2_EXCEPTION_INFO0_M2_EXCEPTION_ID(value uint32) {
	volatile.StoreUint32(&o.M2_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M2_EXCEPTION_INFO0.Reg)&^(0x7c0000)|value<<18)
}
func (o *HP_APM_Type) GetM2_EXCEPTION_INFO0_M2_EXCEPTION_ID() uint32 {
	return (volatile.LoadUint32(&o.M2_EXCEPTION_INFO0.Reg) & 0x7c0000) >> 18
}

// HP_APM.M2_EXCEPTION_INFO1: M2 exception_info1 register
func (o *HP_APM_Type) SetM2_EXCEPTION_INFO1(value uint32) {
	volatile.StoreUint32(&o.M2_EXCEPTION_INFO1.Reg, value)
}
func (o *HP_APM_Type) GetM2_EXCEPTION_INFO1() uint32 {
	return volatile.LoadUint32(&o.M2_EXCEPTION_INFO1.Reg)
}

// HP_APM.M3_STATUS: M3 status register
func (o *HP_APM_Type) SetM3_STATUS_M3_EXCEPTION_STATUS(value uint32) {
	volatile.StoreUint32(&o.M3_STATUS.Reg, volatile.LoadUint32(&o.M3_STATUS.Reg)&^(0x3)|value)
}
func (o *HP_APM_Type) GetM3_STATUS_M3_EXCEPTION_STATUS() uint32 {
	return volatile.LoadUint32(&o.M3_STATUS.Reg) & 0x3
}

// HP_APM.M3_STATUS_CLR: M3 status clear register
func (o *HP_APM_Type) SetM3_STATUS_CLR_M3_REGION_STATUS_CLR(value uint32) {
	volatile.StoreUint32(&o.M3_STATUS_CLR.Reg, volatile.LoadUint32(&o.M3_STATUS_CLR.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetM3_STATUS_CLR_M3_REGION_STATUS_CLR() uint32 {
	return volatile.LoadUint32(&o.M3_STATUS_CLR.Reg) & 0x1
}

// HP_APM.M3_EXCEPTION_INFO0: M3 exception_info0 register
func (o *HP_APM_Type) SetM3_EXCEPTION_INFO0_M3_EXCEPTION_REGION(value uint32) {
	volatile.StoreUint32(&o.M3_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M3_EXCEPTION_INFO0.Reg)&^(0xffff)|value)
}
func (o *HP_APM_Type) GetM3_EXCEPTION_INFO0_M3_EXCEPTION_REGION() uint32 {
	return volatile.LoadUint32(&o.M3_EXCEPTION_INFO0.Reg) & 0xffff
}
func (o *HP_APM_Type) SetM3_EXCEPTION_INFO0_M3_EXCEPTION_MODE(value uint32) {
	volatile.StoreUint32(&o.M3_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M3_EXCEPTION_INFO0.Reg)&^(0x30000)|value<<16)
}
func (o *HP_APM_Type) GetM3_EXCEPTION_INFO0_M3_EXCEPTION_MODE() uint32 {
	return (volatile.LoadUint32(&o.M3_EXCEPTION_INFO0.Reg) & 0x30000) >> 16
}
func (o *HP_APM_Type) SetM3_EXCEPTION_INFO0_M3_EXCEPTION_ID(value uint32) {
	volatile.StoreUint32(&o.M3_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M3_EXCEPTION_INFO0.Reg)&^(0x7c0000)|value<<18)
}
func (o *HP_APM_Type) GetM3_EXCEPTION_INFO0_M3_EXCEPTION_ID() uint32 {
	return (volatile.LoadUint32(&o.M3_EXCEPTION_INFO0.Reg) & 0x7c0000) >> 18
}

// HP_APM.M3_EXCEPTION_INFO1: M3 exception_info1 register
func (o *HP_APM_Type) SetM3_EXCEPTION_INFO1(value uint32) {
	volatile.StoreUint32(&o.M3_EXCEPTION_INFO1.Reg, value)
}
func (o *HP_APM_Type) GetM3_EXCEPTION_INFO1() uint32 {
	return volatile.LoadUint32(&o.M3_EXCEPTION_INFO1.Reg)
}

// HP_APM.INT_EN: APM interrupt enable register
func (o *HP_APM_Type) SetINT_EN_M0_APM_INT_EN(value uint32) {
	volatile.StoreUint32(&o.INT_EN.Reg, volatile.LoadUint32(&o.INT_EN.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetINT_EN_M0_APM_INT_EN() uint32 {
	return volatile.LoadUint32(&o.INT_EN.Reg) & 0x1
}
func (o *HP_APM_Type) SetINT_EN_M1_APM_INT_EN(value uint32) {
	volatile.StoreUint32(&o.INT_EN.Reg, volatile.LoadUint32(&o.INT_EN.Reg)&^(0x2)|value<<1)
}
func (o *HP_APM_Type) GetINT_EN_M1_APM_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.INT_EN.Reg) & 0x2) >> 1
}
func (o *HP_APM_Type) SetINT_EN_M2_APM_INT_EN(value uint32) {
	volatile.StoreUint32(&o.INT_EN.Reg, volatile.LoadUint32(&o.INT_EN.Reg)&^(0x4)|value<<2)
}
func (o *HP_APM_Type) GetINT_EN_M2_APM_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.INT_EN.Reg) & 0x4) >> 2
}
func (o *HP_APM_Type) SetINT_EN_M3_APM_INT_EN(value uint32) {
	volatile.StoreUint32(&o.INT_EN.Reg, volatile.LoadUint32(&o.INT_EN.Reg)&^(0x8)|value<<3)
}
func (o *HP_APM_Type) GetINT_EN_M3_APM_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.INT_EN.Reg) & 0x8) >> 3
}

// HP_APM.CLOCK_GATE: clock gating register
func (o *HP_APM_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *HP_APM_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// HP_APM.DATE: Version register
func (o *HP_APM_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *HP_APM_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// High-Power System
type HP_SYS_Type struct {
	EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL volatile.Register32 // 0x0
	SRAM_USAGE_CONF                         volatile.Register32 // 0x4
	SEC_DPA_CONF                            volatile.Register32 // 0x8
	CPU_PERI_TIMEOUT_CONF                   volatile.Register32 // 0xC
	CPU_PERI_TIMEOUT_ADDR                   volatile.Register32 // 0x10
	CPU_PERI_TIMEOUT_UID                    volatile.Register32 // 0x14
	HP_PERI_TIMEOUT_CONF                    volatile.Register32 // 0x18
	HP_PERI_TIMEOUT_ADDR                    volatile.Register32 // 0x1C
	HP_PERI_TIMEOUT_UID                     volatile.Register32 // 0x20
	ROM_TABLE_LOCK                          volatile.Register32 // 0x24
	ROM_TABLE                               volatile.Register32 // 0x28
	MEM_TEST_CONF                           volatile.Register32 // 0x2C
	_                                       [944]byte
	RND_ECO                                 volatile.Register32 // 0x3E0
	RND_ECO_LOW                             volatile.Register32 // 0x3E4
	RND_ECO_HIGH                            volatile.Register32 // 0x3E8
	_                                       [12]byte
	CLOCK_GATE                              volatile.Register32 // 0x3F8
	DATE                                    volatile.Register32 // 0x3FC
}

// HP_SYS.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL: EXTERNAL DEVICE ENCRYPTION/DECRYPTION configuration register
func (o *HP_SYS_Type) SetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg, volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg)&^(0x1)|value)
}
func (o *HP_SYS_Type) GetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT() uint32 {
	return volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg) & 0x1
}
func (o *HP_SYS_Type) SetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg, volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg)&^(0x2)|value<<1)
}
func (o *HP_SYS_Type) GetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT() uint32 {
	return (volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg) & 0x2) >> 1
}
func (o *HP_SYS_Type) SetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT(value uint32) {
	volatile.StoreUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg, volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg)&^(0x4)|value<<2)
}
func (o *HP_SYS_Type) GetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT() uint32 {
	return (volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg) & 0x4) >> 2
}
func (o *HP_SYS_Type) SetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg, volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg)&^(0x8)|value<<3)
}
func (o *HP_SYS_Type) GetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT() uint32 {
	return (volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg) & 0x8) >> 3
}

// HP_SYS.SRAM_USAGE_CONF: HP memory usage configuration register
func (o *HP_SYS_Type) SetSRAM_USAGE_CONF_SRAM_USAGE(value uint32) {
	volatile.StoreUint32(&o.SRAM_USAGE_CONF.Reg, volatile.LoadUint32(&o.SRAM_USAGE_CONF.Reg)&^(0x7c00)|value<<10)
}
func (o *HP_SYS_Type) GetSRAM_USAGE_CONF_SRAM_USAGE() uint32 {
	return (volatile.LoadUint32(&o.SRAM_USAGE_CONF.Reg) & 0x7c00) >> 10
}
func (o *HP_SYS_Type) SetSRAM_USAGE_CONF_MAC_DUMP_ALLOC(value uint32) {
	volatile.StoreUint32(&o.SRAM_USAGE_CONF.Reg, volatile.LoadUint32(&o.SRAM_USAGE_CONF.Reg)&^(0x1f00000)|value<<20)
}
func (o *HP_SYS_Type) GetSRAM_USAGE_CONF_MAC_DUMP_ALLOC() uint32 {
	return (volatile.LoadUint32(&o.SRAM_USAGE_CONF.Reg) & 0x1f00000) >> 20
}
func (o *HP_SYS_Type) SetSRAM_USAGE_CONF_CACHE_USAGE(value uint32) {
	volatile.StoreUint32(&o.SRAM_USAGE_CONF.Reg, volatile.LoadUint32(&o.SRAM_USAGE_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *HP_SYS_Type) GetSRAM_USAGE_CONF_CACHE_USAGE() uint32 {
	return (volatile.LoadUint32(&o.SRAM_USAGE_CONF.Reg) & 0x80000000) >> 31
}

// HP_SYS.SEC_DPA_CONF: HP anti-DPA security configuration register
func (o *HP_SYS_Type) SetSEC_DPA_CONF_SEC_DPA_LEVEL(value uint32) {
	volatile.StoreUint32(&o.SEC_DPA_CONF.Reg, volatile.LoadUint32(&o.SEC_DPA_CONF.Reg)&^(0x3)|value)
}
func (o *HP_SYS_Type) GetSEC_DPA_CONF_SEC_DPA_LEVEL() uint32 {
	return volatile.LoadUint32(&o.SEC_DPA_CONF.Reg) & 0x3
}
func (o *HP_SYS_Type) SetSEC_DPA_CONF_SEC_DPA_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.SEC_DPA_CONF.Reg, volatile.LoadUint32(&o.SEC_DPA_CONF.Reg)&^(0x4)|value<<2)
}
func (o *HP_SYS_Type) GetSEC_DPA_CONF_SEC_DPA_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.SEC_DPA_CONF.Reg) & 0x4) >> 2
}

// HP_SYS.CPU_PERI_TIMEOUT_CONF: CPU_PERI_TIMEOUT configuration register
func (o *HP_SYS_Type) SetCPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_THRES(value uint32) {
	volatile.StoreUint32(&o.CPU_PERI_TIMEOUT_CONF.Reg, volatile.LoadUint32(&o.CPU_PERI_TIMEOUT_CONF.Reg)&^(0xffff)|value)
}
func (o *HP_SYS_Type) GetCPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_THRES() uint32 {
	return volatile.LoadUint32(&o.CPU_PERI_TIMEOUT_CONF.Reg) & 0xffff
}
func (o *HP_SYS_Type) SetCPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_INT_CLEAR(value uint32) {
	volatile.StoreUint32(&o.CPU_PERI_TIMEOUT_CONF.Reg, volatile.LoadUint32(&o.CPU_PERI_TIMEOUT_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *HP_SYS_Type) GetCPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_INT_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERI_TIMEOUT_CONF.Reg) & 0x10000) >> 16
}
func (o *HP_SYS_Type) SetCPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_PROTECT_EN(value uint32) {
	volatile.StoreUint32(&o.CPU_PERI_TIMEOUT_CONF.Reg, volatile.LoadUint32(&o.CPU_PERI_TIMEOUT_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *HP_SYS_Type) GetCPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_PROTECT_EN() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERI_TIMEOUT_CONF.Reg) & 0x20000) >> 17
}

// HP_SYS.CPU_PERI_TIMEOUT_ADDR: CPU_PERI_TIMEOUT_ADDR register
func (o *HP_SYS_Type) SetCPU_PERI_TIMEOUT_ADDR(value uint32) {
	volatile.StoreUint32(&o.CPU_PERI_TIMEOUT_ADDR.Reg, value)
}
func (o *HP_SYS_Type) GetCPU_PERI_TIMEOUT_ADDR() uint32 {
	return volatile.LoadUint32(&o.CPU_PERI_TIMEOUT_ADDR.Reg)
}

// HP_SYS.CPU_PERI_TIMEOUT_UID: CPU_PERI_TIMEOUT_UID register
func (o *HP_SYS_Type) SetCPU_PERI_TIMEOUT_UID(value uint32) {
	volatile.StoreUint32(&o.CPU_PERI_TIMEOUT_UID.Reg, volatile.LoadUint32(&o.CPU_PERI_TIMEOUT_UID.Reg)&^(0x7f)|value)
}
func (o *HP_SYS_Type) GetCPU_PERI_TIMEOUT_UID() uint32 {
	return volatile.LoadUint32(&o.CPU_PERI_TIMEOUT_UID.Reg) & 0x7f
}

// HP_SYS.HP_PERI_TIMEOUT_CONF: HP_PERI_TIMEOUT configuration register
func (o *HP_SYS_Type) SetHP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_THRES(value uint32) {
	volatile.StoreUint32(&o.HP_PERI_TIMEOUT_CONF.Reg, volatile.LoadUint32(&o.HP_PERI_TIMEOUT_CONF.Reg)&^(0xffff)|value)
}
func (o *HP_SYS_Type) GetHP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_THRES() uint32 {
	return volatile.LoadUint32(&o.HP_PERI_TIMEOUT_CONF.Reg) & 0xffff
}
func (o *HP_SYS_Type) SetHP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_INT_CLEAR(value uint32) {
	volatile.StoreUint32(&o.HP_PERI_TIMEOUT_CONF.Reg, volatile.LoadUint32(&o.HP_PERI_TIMEOUT_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *HP_SYS_Type) GetHP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_INT_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.HP_PERI_TIMEOUT_CONF.Reg) & 0x10000) >> 16
}
func (o *HP_SYS_Type) SetHP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_PROTECT_EN(value uint32) {
	volatile.StoreUint32(&o.HP_PERI_TIMEOUT_CONF.Reg, volatile.LoadUint32(&o.HP_PERI_TIMEOUT_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *HP_SYS_Type) GetHP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_PROTECT_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_PERI_TIMEOUT_CONF.Reg) & 0x20000) >> 17
}

// HP_SYS.HP_PERI_TIMEOUT_ADDR: HP_PERI_TIMEOUT_ADDR register
func (o *HP_SYS_Type) SetHP_PERI_TIMEOUT_ADDR(value uint32) {
	volatile.StoreUint32(&o.HP_PERI_TIMEOUT_ADDR.Reg, value)
}
func (o *HP_SYS_Type) GetHP_PERI_TIMEOUT_ADDR() uint32 {
	return volatile.LoadUint32(&o.HP_PERI_TIMEOUT_ADDR.Reg)
}

// HP_SYS.HP_PERI_TIMEOUT_UID: HP_PERI_TIMEOUT_UID register
func (o *HP_SYS_Type) SetHP_PERI_TIMEOUT_UID(value uint32) {
	volatile.StoreUint32(&o.HP_PERI_TIMEOUT_UID.Reg, volatile.LoadUint32(&o.HP_PERI_TIMEOUT_UID.Reg)&^(0x7f)|value)
}
func (o *HP_SYS_Type) GetHP_PERI_TIMEOUT_UID() uint32 {
	return volatile.LoadUint32(&o.HP_PERI_TIMEOUT_UID.Reg) & 0x7f
}

// HP_SYS.ROM_TABLE_LOCK: Rom-Table lock register
func (o *HP_SYS_Type) SetROM_TABLE_LOCK(value uint32) {
	volatile.StoreUint32(&o.ROM_TABLE_LOCK.Reg, volatile.LoadUint32(&o.ROM_TABLE_LOCK.Reg)&^(0x1)|value)
}
func (o *HP_SYS_Type) GetROM_TABLE_LOCK() uint32 {
	return volatile.LoadUint32(&o.ROM_TABLE_LOCK.Reg) & 0x1
}

// HP_SYS.ROM_TABLE: Rom-Table register
func (o *HP_SYS_Type) SetROM_TABLE(value uint32) {
	volatile.StoreUint32(&o.ROM_TABLE.Reg, value)
}
func (o *HP_SYS_Type) GetROM_TABLE() uint32 {
	return volatile.LoadUint32(&o.ROM_TABLE.Reg)
}

// HP_SYS.MEM_TEST_CONF: MEM_TEST configuration register
func (o *HP_SYS_Type) SetMEM_TEST_CONF_HP_MEM_WPULSE(value uint32) {
	volatile.StoreUint32(&o.MEM_TEST_CONF.Reg, volatile.LoadUint32(&o.MEM_TEST_CONF.Reg)&^(0x7)|value)
}
func (o *HP_SYS_Type) GetMEM_TEST_CONF_HP_MEM_WPULSE() uint32 {
	return volatile.LoadUint32(&o.MEM_TEST_CONF.Reg) & 0x7
}
func (o *HP_SYS_Type) SetMEM_TEST_CONF_HP_MEM_WA(value uint32) {
	volatile.StoreUint32(&o.MEM_TEST_CONF.Reg, volatile.LoadUint32(&o.MEM_TEST_CONF.Reg)&^(0x38)|value<<3)
}
func (o *HP_SYS_Type) GetMEM_TEST_CONF_HP_MEM_WA() uint32 {
	return (volatile.LoadUint32(&o.MEM_TEST_CONF.Reg) & 0x38) >> 3
}
func (o *HP_SYS_Type) SetMEM_TEST_CONF_HP_MEM_RA(value uint32) {
	volatile.StoreUint32(&o.MEM_TEST_CONF.Reg, volatile.LoadUint32(&o.MEM_TEST_CONF.Reg)&^(0xc0)|value<<6)
}
func (o *HP_SYS_Type) GetMEM_TEST_CONF_HP_MEM_RA() uint32 {
	return (volatile.LoadUint32(&o.MEM_TEST_CONF.Reg) & 0xc0) >> 6
}
func (o *HP_SYS_Type) SetMEM_TEST_CONF_HP_MEM_RM(value uint32) {
	volatile.StoreUint32(&o.MEM_TEST_CONF.Reg, volatile.LoadUint32(&o.MEM_TEST_CONF.Reg)&^(0xf00)|value<<8)
}
func (o *HP_SYS_Type) GetMEM_TEST_CONF_HP_MEM_RM() uint32 {
	return (volatile.LoadUint32(&o.MEM_TEST_CONF.Reg) & 0xf00) >> 8
}
func (o *HP_SYS_Type) SetMEM_TEST_CONF_ROM_RM(value uint32) {
	volatile.StoreUint32(&o.MEM_TEST_CONF.Reg, volatile.LoadUint32(&o.MEM_TEST_CONF.Reg)&^(0xf000)|value<<12)
}
func (o *HP_SYS_Type) GetMEM_TEST_CONF_ROM_RM() uint32 {
	return (volatile.LoadUint32(&o.MEM_TEST_CONF.Reg) & 0xf000) >> 12
}

// HP_SYS.RND_ECO: redcy eco register.
func (o *HP_SYS_Type) SetRND_ECO_REDCY_ENA(value uint32) {
	volatile.StoreUint32(&o.RND_ECO.Reg, volatile.LoadUint32(&o.RND_ECO.Reg)&^(0x1)|value)
}
func (o *HP_SYS_Type) GetRND_ECO_REDCY_ENA() uint32 {
	return volatile.LoadUint32(&o.RND_ECO.Reg) & 0x1
}
func (o *HP_SYS_Type) SetRND_ECO_REDCY_RESULT(value uint32) {
	volatile.StoreUint32(&o.RND_ECO.Reg, volatile.LoadUint32(&o.RND_ECO.Reg)&^(0x2)|value<<1)
}
func (o *HP_SYS_Type) GetRND_ECO_REDCY_RESULT() uint32 {
	return (volatile.LoadUint32(&o.RND_ECO.Reg) & 0x2) >> 1
}

// HP_SYS.RND_ECO_LOW: redcy eco low register.
func (o *HP_SYS_Type) SetRND_ECO_LOW(value uint32) {
	volatile.StoreUint32(&o.RND_ECO_LOW.Reg, value)
}
func (o *HP_SYS_Type) GetRND_ECO_LOW() uint32 {
	return volatile.LoadUint32(&o.RND_ECO_LOW.Reg)
}

// HP_SYS.RND_ECO_HIGH: redcy eco high register.
func (o *HP_SYS_Type) SetRND_ECO_HIGH(value uint32) {
	volatile.StoreUint32(&o.RND_ECO_HIGH.Reg, value)
}
func (o *HP_SYS_Type) GetRND_ECO_HIGH() uint32 {
	return volatile.LoadUint32(&o.RND_ECO_HIGH.Reg)
}

// HP_SYS.CLOCK_GATE: HP-SYSTEM clock gating configure register
func (o *HP_SYS_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *HP_SYS_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// HP_SYS.DATE: Date register.
func (o *HP_SYS_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *HP_SYS_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// I2C (Inter-Integrated Circuit) Controller 0
type I2C_Type struct {
	SCL_LOW_PERIOD       volatile.Register32 // 0x0
	CTR                  volatile.Register32 // 0x4
	SR                   volatile.Register32 // 0x8
	TO                   volatile.Register32 // 0xC
	SLAVE_ADDR           volatile.Register32 // 0x10
	FIFO_ST              volatile.Register32 // 0x14
	FIFO_CONF            volatile.Register32 // 0x18
	DATA                 volatile.Register32 // 0x1C
	INT_RAW              volatile.Register32 // 0x20
	INT_CLR              volatile.Register32 // 0x24
	INT_ENA              volatile.Register32 // 0x28
	INT_STATUS           volatile.Register32 // 0x2C
	SDA_HOLD             volatile.Register32 // 0x30
	SDA_SAMPLE           volatile.Register32 // 0x34
	SCL_HIGH_PERIOD      volatile.Register32 // 0x38
	_                    [4]byte
	SCL_START_HOLD       volatile.Register32 // 0x40
	SCL_RSTART_SETUP     volatile.Register32 // 0x44
	SCL_STOP_HOLD        volatile.Register32 // 0x48
	SCL_STOP_SETUP       volatile.Register32 // 0x4C
	FILTER_CFG           volatile.Register32 // 0x50
	CLK_CONF             volatile.Register32 // 0x54
	COMD0                volatile.Register32 // 0x58
	COMD1                volatile.Register32 // 0x5C
	COMD2                volatile.Register32 // 0x60
	COMD3                volatile.Register32 // 0x64
	COMD4                volatile.Register32 // 0x68
	COMD5                volatile.Register32 // 0x6C
	COMD6                volatile.Register32 // 0x70
	COMD7                volatile.Register32 // 0x74
	SCL_ST_TIME_OUT      volatile.Register32 // 0x78
	SCL_MAIN_ST_TIME_OUT volatile.Register32 // 0x7C
	SCL_SP_CONF          volatile.Register32 // 0x80
	SCL_STRETCH_CONF     volatile.Register32 // 0x84
	_                    [112]byte
	DATE                 volatile.Register32 // 0xF8
	_                    [4]byte
	TXFIFO_START_ADDR    volatile.Register32 // 0x100
	_                    [124]byte
	RXFIFO_START_ADDR    volatile.Register32 // 0x180
}

// I2C.SCL_LOW_PERIOD: Configures the low level width of the SCL Clock
func (o *I2C_Type) SetSCL_LOW_PERIOD(value uint32) {
	volatile.StoreUint32(&o.SCL_LOW_PERIOD.Reg, volatile.LoadUint32(&o.SCL_LOW_PERIOD.Reg)&^(0x1ff)|value)
}
func (o *I2C_Type) GetSCL_LOW_PERIOD() uint32 {
	return volatile.LoadUint32(&o.SCL_LOW_PERIOD.Reg) & 0x1ff
}

// I2C.CTR: Transmission setting
func (o *I2C_Type) SetCTR_SDA_FORCE_OUT(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetCTR_SDA_FORCE_OUT() uint32 {
	return volatile.LoadUint32(&o.CTR.Reg) & 0x1
}
func (o *I2C_Type) SetCTR_SCL_FORCE_OUT(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetCTR_SCL_FORCE_OUT() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetCTR_SAMPLE_SCL_LEVEL(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCTR_SAMPLE_SCL_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCTR_RX_FULL_ACK_LEVEL(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCTR_RX_FULL_ACK_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCTR_MS_MODE(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCTR_MS_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCTR_TRANS_START(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCTR_TRANS_START() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCTR_TX_LSB_FIRST(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCTR_TX_LSB_FIRST() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCTR_RX_LSB_FIRST(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetCTR_RX_LSB_FIRST() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetCTR_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetCTR_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetCTR_ARBITRATION_EN(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetCTR_ARBITRATION_EN() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetCTR_FSM_RST(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetCTR_FSM_RST() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetCTR_CONF_UPGATE(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetCTR_CONF_UPGATE() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetCTR_SLV_TX_AUTO_START_EN(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetCTR_SLV_TX_AUTO_START_EN() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetCTR_ADDR_10BIT_RW_CHECK_EN(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetCTR_ADDR_10BIT_RW_CHECK_EN() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetCTR_ADDR_BROADCASTING_EN(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetCTR_ADDR_BROADCASTING_EN() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x4000) >> 14
}

// I2C.SR: Describe I2C work status.
func (o *I2C_Type) SetSR_RESP_REC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetSR_RESP_REC() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *I2C_Type) SetSR_SLAVE_RW(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetSR_SLAVE_RW() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetSR_ARB_LOST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetSR_ARB_LOST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetSR_BUS_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetSR_BUS_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetSR_SLAVE_ADDRESSED(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetSR_SLAVE_ADDRESSED() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetSR_RXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x3f00)|value<<8)
}
func (o *I2C_Type) GetSR_RXFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x3f00) >> 8
}
func (o *I2C_Type) SetSR_STRETCH_CAUSE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xc000)|value<<14)
}
func (o *I2C_Type) GetSR_STRETCH_CAUSE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xc000) >> 14
}
func (o *I2C_Type) SetSR_TXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xfc0000)|value<<18)
}
func (o *I2C_Type) GetSR_TXFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xfc0000) >> 18
}
func (o *I2C_Type) SetSR_SCL_MAIN_STATE_LAST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x7000000)|value<<24)
}
func (o *I2C_Type) GetSR_SCL_MAIN_STATE_LAST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x7000000) >> 24
}
func (o *I2C_Type) SetSR_SCL_STATE_LAST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x70000000)|value<<28)
}
func (o *I2C_Type) GetSR_SCL_STATE_LAST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x70000000) >> 28
}

// I2C.TO: Setting time out control for receiving data.
func (o *I2C_Type) SetTO_TIME_OUT_VALUE(value uint32) {
	volatile.StoreUint32(&o.TO.Reg, volatile.LoadUint32(&o.TO.Reg)&^(0x1f)|value)
}
func (o *I2C_Type) GetTO_TIME_OUT_VALUE() uint32 {
	return volatile.LoadUint32(&o.TO.Reg) & 0x1f
}
func (o *I2C_Type) SetTO_TIME_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.TO.Reg, volatile.LoadUint32(&o.TO.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetTO_TIME_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.TO.Reg) & 0x20) >> 5
}

// I2C.SLAVE_ADDR: Local slave address setting
func (o *I2C_Type) SetSLAVE_ADDR(value uint32) {
	volatile.StoreUint32(&o.SLAVE_ADDR.Reg, volatile.LoadUint32(&o.SLAVE_ADDR.Reg)&^(0x7fff)|value)
}
func (o *I2C_Type) GetSLAVE_ADDR() uint32 {
	return volatile.LoadUint32(&o.SLAVE_ADDR.Reg) & 0x7fff
}
func (o *I2C_Type) SetSLAVE_ADDR_ADDR_10BIT_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE_ADDR.Reg, volatile.LoadUint32(&o.SLAVE_ADDR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetSLAVE_ADDR_ADDR_10BIT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE_ADDR.Reg) & 0x80000000) >> 31
}

// I2C.FIFO_ST: FIFO status register.
func (o *I2C_Type) SetFIFO_ST_RXFIFO_RADDR(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x1f)|value)
}
func (o *I2C_Type) GetFIFO_ST_RXFIFO_RADDR() uint32 {
	return volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x1f
}
func (o *I2C_Type) SetFIFO_ST_RXFIFO_WADDR(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x3e0)|value<<5)
}
func (o *I2C_Type) GetFIFO_ST_RXFIFO_WADDR() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x3e0) >> 5
}
func (o *I2C_Type) SetFIFO_ST_TXFIFO_RADDR(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x7c00)|value<<10)
}
func (o *I2C_Type) GetFIFO_ST_TXFIFO_RADDR() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x7c00) >> 10
}
func (o *I2C_Type) SetFIFO_ST_TXFIFO_WADDR(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0xf8000)|value<<15)
}
func (o *I2C_Type) GetFIFO_ST_TXFIFO_WADDR() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0xf8000) >> 15
}
func (o *I2C_Type) SetFIFO_ST_SLAVE_RW_POINT(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x3fc00000)|value<<22)
}
func (o *I2C_Type) GetFIFO_ST_SLAVE_RW_POINT() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x3fc00000) >> 22
}

// I2C.FIFO_CONF: FIFO configuration register.
func (o *I2C_Type) SetFIFO_CONF_RXFIFO_WM_THRHD(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x1f)|value)
}
func (o *I2C_Type) GetFIFO_CONF_RXFIFO_WM_THRHD() uint32 {
	return volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x1f
}
func (o *I2C_Type) SetFIFO_CONF_TXFIFO_WM_THRHD(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x3e0)|value<<5)
}
func (o *I2C_Type) GetFIFO_CONF_TXFIFO_WM_THRHD() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x3e0) >> 5
}
func (o *I2C_Type) SetFIFO_CONF_NONFIFO_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetFIFO_CONF_NONFIFO_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetFIFO_CONF_FIFO_ADDR_CFG_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetFIFO_CONF_FIFO_ADDR_CFG_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetFIFO_CONF_RX_FIFO_RST(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetFIFO_CONF_RX_FIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetFIFO_CONF_TX_FIFO_RST(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetFIFO_CONF_TX_FIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetFIFO_CONF_FIFO_PRT_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetFIFO_CONF_FIFO_PRT_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x4000) >> 14
}

// I2C.DATA: Rx FIFO read data.
func (o *I2C_Type) SetDATA_FIFO_RDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetDATA_FIFO_RDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg) & 0xff
}

// I2C.INT_RAW: Raw interrupt status
func (o *I2C_Type) SetINT_RAW_RXFIFO_WM_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetINT_RAW_RXFIFO_WM_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *I2C_Type) SetINT_RAW_TXFIFO_WM_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetINT_RAW_TXFIFO_WM_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetINT_RAW_RXFIFO_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetINT_RAW_RXFIFO_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetINT_RAW_END_DETECT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetINT_RAW_END_DETECT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetINT_RAW_BYTE_TRANS_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetINT_RAW_BYTE_TRANS_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetINT_RAW_ARBITRATION_LOST_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetINT_RAW_ARBITRATION_LOST_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetINT_RAW_MST_TXFIFO_UDF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetINT_RAW_MST_TXFIFO_UDF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetINT_RAW_TRANS_COMPLETE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetINT_RAW_TRANS_COMPLETE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetINT_RAW_TIME_OUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetINT_RAW_TIME_OUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetINT_RAW_TRANS_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetINT_RAW_TRANS_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetINT_RAW_NACK_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetINT_RAW_NACK_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetINT_RAW_TXFIFO_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetINT_RAW_TXFIFO_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetINT_RAW_RXFIFO_UDF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetINT_RAW_RXFIFO_UDF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetINT_RAW_SCL_ST_TO_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetINT_RAW_SCL_ST_TO_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetINT_RAW_SCL_MAIN_ST_TO_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetINT_RAW_SCL_MAIN_ST_TO_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetINT_RAW_DET_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetINT_RAW_DET_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetINT_RAW_SLAVE_STRETCH_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetINT_RAW_SLAVE_STRETCH_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetINT_RAW_GENERAL_CALL_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000)|value<<17)
}
func (o *I2C_Type) GetINT_RAW_GENERAL_CALL_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000) >> 17
}
func (o *I2C_Type) SetINT_RAW_SLAVE_ADDR_UNMATCH_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000)|value<<18)
}
func (o *I2C_Type) GetINT_RAW_SLAVE_ADDR_UNMATCH_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000) >> 18
}

// I2C.INT_CLR: Interrupt clear bits
func (o *I2C_Type) SetINT_CLR_RXFIFO_WM_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetINT_CLR_RXFIFO_WM_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *I2C_Type) SetINT_CLR_TXFIFO_WM_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetINT_CLR_TXFIFO_WM_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetINT_CLR_RXFIFO_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetINT_CLR_RXFIFO_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetINT_CLR_END_DETECT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetINT_CLR_END_DETECT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetINT_CLR_BYTE_TRANS_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetINT_CLR_BYTE_TRANS_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetINT_CLR_ARBITRATION_LOST_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetINT_CLR_ARBITRATION_LOST_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetINT_CLR_MST_TXFIFO_UDF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetINT_CLR_MST_TXFIFO_UDF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetINT_CLR_TRANS_COMPLETE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetINT_CLR_TRANS_COMPLETE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetINT_CLR_TIME_OUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetINT_CLR_TIME_OUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetINT_CLR_TRANS_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetINT_CLR_TRANS_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetINT_CLR_NACK_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetINT_CLR_NACK_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetINT_CLR_TXFIFO_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetINT_CLR_TXFIFO_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetINT_CLR_RXFIFO_UDF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetINT_CLR_RXFIFO_UDF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetINT_CLR_SCL_ST_TO_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetINT_CLR_SCL_ST_TO_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetINT_CLR_SCL_MAIN_ST_TO_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetINT_CLR_SCL_MAIN_ST_TO_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetINT_CLR_DET_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetINT_CLR_DET_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetINT_CLR_SLAVE_STRETCH_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetINT_CLR_SLAVE_STRETCH_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetINT_CLR_GENERAL_CALL_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *I2C_Type) GetINT_CLR_GENERAL_CALL_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000) >> 17
}
func (o *I2C_Type) SetINT_CLR_SLAVE_ADDR_UNMATCH_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *I2C_Type) GetINT_CLR_SLAVE_ADDR_UNMATCH_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40000) >> 18
}

// I2C.INT_ENA: Interrupt enable bits
func (o *I2C_Type) SetINT_ENA_RXFIFO_WM_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetINT_ENA_RXFIFO_WM_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *I2C_Type) SetINT_ENA_TXFIFO_WM_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetINT_ENA_TXFIFO_WM_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetINT_ENA_RXFIFO_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetINT_ENA_RXFIFO_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetINT_ENA_END_DETECT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetINT_ENA_END_DETECT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetINT_ENA_BYTE_TRANS_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetINT_ENA_BYTE_TRANS_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetINT_ENA_ARBITRATION_LOST_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetINT_ENA_ARBITRATION_LOST_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetINT_ENA_MST_TXFIFO_UDF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetINT_ENA_MST_TXFIFO_UDF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetINT_ENA_TRANS_COMPLETE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetINT_ENA_TRANS_COMPLETE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetINT_ENA_TIME_OUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetINT_ENA_TIME_OUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetINT_ENA_TRANS_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetINT_ENA_TRANS_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetINT_ENA_NACK_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetINT_ENA_NACK_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetINT_ENA_TXFIFO_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetINT_ENA_TXFIFO_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetINT_ENA_RXFIFO_UDF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetINT_ENA_RXFIFO_UDF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetINT_ENA_SCL_ST_TO_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetINT_ENA_SCL_ST_TO_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetINT_ENA_SCL_MAIN_ST_TO_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetINT_ENA_SCL_MAIN_ST_TO_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetINT_ENA_DET_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetINT_ENA_DET_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetINT_ENA_SLAVE_STRETCH_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetINT_ENA_SLAVE_STRETCH_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetINT_ENA_GENERAL_CALL_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *I2C_Type) GetINT_ENA_GENERAL_CALL_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000) >> 17
}
func (o *I2C_Type) SetINT_ENA_SLAVE_ADDR_UNMATCH_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40000)|value<<18)
}
func (o *I2C_Type) GetINT_ENA_SLAVE_ADDR_UNMATCH_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40000) >> 18
}

// I2C.INT_STATUS: Status of captured I2C communication events
func (o *I2C_Type) SetINT_STATUS_RXFIFO_WM_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetINT_STATUS_RXFIFO_WM_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x1
}
func (o *I2C_Type) SetINT_STATUS_TXFIFO_WM_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetINT_STATUS_TXFIFO_WM_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetINT_STATUS_RXFIFO_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetINT_STATUS_RXFIFO_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetINT_STATUS_END_DETECT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetINT_STATUS_END_DETECT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetINT_STATUS_BYTE_TRANS_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetINT_STATUS_BYTE_TRANS_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetINT_STATUS_ARBITRATION_LOST_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetINT_STATUS_ARBITRATION_LOST_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetINT_STATUS_MST_TXFIFO_UDF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetINT_STATUS_MST_TXFIFO_UDF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetINT_STATUS_TRANS_COMPLETE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetINT_STATUS_TRANS_COMPLETE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetINT_STATUS_TIME_OUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetINT_STATUS_TIME_OUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetINT_STATUS_TRANS_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetINT_STATUS_TRANS_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetINT_STATUS_NACK_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetINT_STATUS_NACK_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetINT_STATUS_TXFIFO_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetINT_STATUS_TXFIFO_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetINT_STATUS_RXFIFO_UDF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetINT_STATUS_RXFIFO_UDF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetINT_STATUS_SCL_ST_TO_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetINT_STATUS_SCL_ST_TO_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetINT_STATUS_SCL_MAIN_ST_TO_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetINT_STATUS_SCL_MAIN_ST_TO_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetINT_STATUS_DET_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetINT_STATUS_DET_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetINT_STATUS_SLAVE_STRETCH_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetINT_STATUS_SLAVE_STRETCH_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetINT_STATUS_GENERAL_CALL_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *I2C_Type) GetINT_STATUS_GENERAL_CALL_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x20000) >> 17
}
func (o *I2C_Type) SetINT_STATUS_SLAVE_ADDR_UNMATCH_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x40000)|value<<18)
}
func (o *I2C_Type) GetINT_STATUS_SLAVE_ADDR_UNMATCH_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x40000) >> 18
}

// I2C.SDA_HOLD: Configures the hold time after a negative SCL edge.
func (o *I2C_Type) SetSDA_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.SDA_HOLD.Reg, volatile.LoadUint32(&o.SDA_HOLD.Reg)&^(0x1ff)|value)
}
func (o *I2C_Type) GetSDA_HOLD_TIME() uint32 {
	return volatile.LoadUint32(&o.SDA_HOLD.Reg) & 0x1ff
}

// I2C.SDA_SAMPLE: Configures the sample time after a positive SCL edge.
func (o *I2C_Type) SetSDA_SAMPLE_TIME(value uint32) {
	volatile.StoreUint32(&o.SDA_SAMPLE.Reg, volatile.LoadUint32(&o.SDA_SAMPLE.Reg)&^(0x1ff)|value)
}
func (o *I2C_Type) GetSDA_SAMPLE_TIME() uint32 {
	return volatile.LoadUint32(&o.SDA_SAMPLE.Reg) & 0x1ff
}

// I2C.SCL_HIGH_PERIOD: Configures the high level width of SCL
func (o *I2C_Type) SetSCL_HIGH_PERIOD(value uint32) {
	volatile.StoreUint32(&o.SCL_HIGH_PERIOD.Reg, volatile.LoadUint32(&o.SCL_HIGH_PERIOD.Reg)&^(0x1ff)|value)
}
func (o *I2C_Type) GetSCL_HIGH_PERIOD() uint32 {
	return volatile.LoadUint32(&o.SCL_HIGH_PERIOD.Reg) & 0x1ff
}
func (o *I2C_Type) SetSCL_HIGH_PERIOD_SCL_WAIT_HIGH_PERIOD(value uint32) {
	volatile.StoreUint32(&o.SCL_HIGH_PERIOD.Reg, volatile.LoadUint32(&o.SCL_HIGH_PERIOD.Reg)&^(0xfe00)|value<<9)
}
func (o *I2C_Type) GetSCL_HIGH_PERIOD_SCL_WAIT_HIGH_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.SCL_HIGH_PERIOD.Reg) & 0xfe00) >> 9
}

// I2C.SCL_START_HOLD: Configures the delay between the SDA and SCL negative edge for a start condition
func (o *I2C_Type) SetSCL_START_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.SCL_START_HOLD.Reg, volatile.LoadUint32(&o.SCL_START_HOLD.Reg)&^(0x1ff)|value)
}
func (o *I2C_Type) GetSCL_START_HOLD_TIME() uint32 {
	return volatile.LoadUint32(&o.SCL_START_HOLD.Reg) & 0x1ff
}

// I2C.SCL_RSTART_SETUP: Configures the delay between the positive edge of SCL and the negative edge of SDA
func (o *I2C_Type) SetSCL_RSTART_SETUP_TIME(value uint32) {
	volatile.StoreUint32(&o.SCL_RSTART_SETUP.Reg, volatile.LoadUint32(&o.SCL_RSTART_SETUP.Reg)&^(0x1ff)|value)
}
func (o *I2C_Type) GetSCL_RSTART_SETUP_TIME() uint32 {
	return volatile.LoadUint32(&o.SCL_RSTART_SETUP.Reg) & 0x1ff
}

// I2C.SCL_STOP_HOLD: Configures the delay after the SCL clock edge for a stop condition
func (o *I2C_Type) SetSCL_STOP_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.SCL_STOP_HOLD.Reg, volatile.LoadUint32(&o.SCL_STOP_HOLD.Reg)&^(0x1ff)|value)
}
func (o *I2C_Type) GetSCL_STOP_HOLD_TIME() uint32 {
	return volatile.LoadUint32(&o.SCL_STOP_HOLD.Reg) & 0x1ff
}

// I2C.SCL_STOP_SETUP: Configures the delay between the SDA and SCL positive edge for a stop condition
func (o *I2C_Type) SetSCL_STOP_SETUP_TIME(value uint32) {
	volatile.StoreUint32(&o.SCL_STOP_SETUP.Reg, volatile.LoadUint32(&o.SCL_STOP_SETUP.Reg)&^(0x1ff)|value)
}
func (o *I2C_Type) GetSCL_STOP_SETUP_TIME() uint32 {
	return volatile.LoadUint32(&o.SCL_STOP_SETUP.Reg) & 0x1ff
}

// I2C.FILTER_CFG: SCL and SDA filter configuration register
func (o *I2C_Type) SetFILTER_CFG_SCL_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.FILTER_CFG.Reg, volatile.LoadUint32(&o.FILTER_CFG.Reg)&^(0xf)|value)
}
func (o *I2C_Type) GetFILTER_CFG_SCL_FILTER_THRES() uint32 {
	return volatile.LoadUint32(&o.FILTER_CFG.Reg) & 0xf
}
func (o *I2C_Type) SetFILTER_CFG_SDA_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.FILTER_CFG.Reg, volatile.LoadUint32(&o.FILTER_CFG.Reg)&^(0xf0)|value<<4)
}
func (o *I2C_Type) GetFILTER_CFG_SDA_FILTER_THRES() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CFG.Reg) & 0xf0) >> 4
}
func (o *I2C_Type) SetFILTER_CFG_SCL_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.FILTER_CFG.Reg, volatile.LoadUint32(&o.FILTER_CFG.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetFILTER_CFG_SCL_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CFG.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetFILTER_CFG_SDA_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.FILTER_CFG.Reg, volatile.LoadUint32(&o.FILTER_CFG.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetFILTER_CFG_SDA_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CFG.Reg) & 0x200) >> 9
}

// I2C.CLK_CONF: I2C CLK configuration register
func (o *I2C_Type) SetCLK_CONF_SCLK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetCLK_CONF_SCLK_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.CLK_CONF.Reg) & 0xff
}
func (o *I2C_Type) SetCLK_CONF_SCLK_DIV_A(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x3f00)|value<<8)
}
func (o *I2C_Type) GetCLK_CONF_SCLK_DIV_A() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x3f00) >> 8
}
func (o *I2C_Type) SetCLK_CONF_SCLK_DIV_B(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0xfc000)|value<<14)
}
func (o *I2C_Type) GetCLK_CONF_SCLK_DIV_B() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0xfc000) >> 14
}
func (o *I2C_Type) SetCLK_CONF_SCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *I2C_Type) GetCLK_CONF_SCLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x100000) >> 20
}
func (o *I2C_Type) SetCLK_CONF_SCLK_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *I2C_Type) GetCLK_CONF_SCLK_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x200000) >> 21
}

// I2C.COMD0: I2C command register %s
func (o *I2C_Type) SetCOMD0_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD0.Reg, volatile.LoadUint32(&o.COMD0.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD0_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD0.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD0_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD0.Reg, volatile.LoadUint32(&o.COMD0.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD0_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD0.Reg) & 0x80000000) >> 31
}

// I2C.COMD1: I2C command register %s
func (o *I2C_Type) SetCOMD1_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD1.Reg, volatile.LoadUint32(&o.COMD1.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD1_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD1.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD1_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD1.Reg, volatile.LoadUint32(&o.COMD1.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD1_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD1.Reg) & 0x80000000) >> 31
}

// I2C.COMD2: I2C command register %s
func (o *I2C_Type) SetCOMD2_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD2.Reg, volatile.LoadUint32(&o.COMD2.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD2_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD2.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD2_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD2.Reg, volatile.LoadUint32(&o.COMD2.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD2_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD2.Reg) & 0x80000000) >> 31
}

// I2C.COMD3: I2C command register %s
func (o *I2C_Type) SetCOMD3_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD3.Reg, volatile.LoadUint32(&o.COMD3.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD3_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD3.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD3_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD3.Reg, volatile.LoadUint32(&o.COMD3.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD3_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD3.Reg) & 0x80000000) >> 31
}

// I2C.COMD4: I2C command register %s
func (o *I2C_Type) SetCOMD4_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD4.Reg, volatile.LoadUint32(&o.COMD4.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD4_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD4.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD4_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD4.Reg, volatile.LoadUint32(&o.COMD4.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD4_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD4.Reg) & 0x80000000) >> 31
}

// I2C.COMD5: I2C command register %s
func (o *I2C_Type) SetCOMD5_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD5.Reg, volatile.LoadUint32(&o.COMD5.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD5_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD5.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD5_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD5.Reg, volatile.LoadUint32(&o.COMD5.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD5_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD5.Reg) & 0x80000000) >> 31
}

// I2C.COMD6: I2C command register %s
func (o *I2C_Type) SetCOMD6_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD6.Reg, volatile.LoadUint32(&o.COMD6.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD6_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD6.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD6_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD6.Reg, volatile.LoadUint32(&o.COMD6.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD6_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD6.Reg) & 0x80000000) >> 31
}

// I2C.COMD7: I2C command register %s
func (o *I2C_Type) SetCOMD7_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD7.Reg, volatile.LoadUint32(&o.COMD7.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD7_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD7.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD7_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD7.Reg, volatile.LoadUint32(&o.COMD7.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD7_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD7.Reg) & 0x80000000) >> 31
}

// I2C.SCL_ST_TIME_OUT: SCL status time out register
func (o *I2C_Type) SetSCL_ST_TIME_OUT_SCL_ST_TO_I2C(value uint32) {
	volatile.StoreUint32(&o.SCL_ST_TIME_OUT.Reg, volatile.LoadUint32(&o.SCL_ST_TIME_OUT.Reg)&^(0x1f)|value)
}
func (o *I2C_Type) GetSCL_ST_TIME_OUT_SCL_ST_TO_I2C() uint32 {
	return volatile.LoadUint32(&o.SCL_ST_TIME_OUT.Reg) & 0x1f
}

// I2C.SCL_MAIN_ST_TIME_OUT: SCL main status time out register
func (o *I2C_Type) SetSCL_MAIN_ST_TIME_OUT_SCL_MAIN_ST_TO_I2C(value uint32) {
	volatile.StoreUint32(&o.SCL_MAIN_ST_TIME_OUT.Reg, volatile.LoadUint32(&o.SCL_MAIN_ST_TIME_OUT.Reg)&^(0x1f)|value)
}
func (o *I2C_Type) GetSCL_MAIN_ST_TIME_OUT_SCL_MAIN_ST_TO_I2C() uint32 {
	return volatile.LoadUint32(&o.SCL_MAIN_ST_TIME_OUT.Reg) & 0x1f
}

// I2C.SCL_SP_CONF: Power configuration register
func (o *I2C_Type) SetSCL_SP_CONF_SCL_RST_SLV_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_SP_CONF.Reg, volatile.LoadUint32(&o.SCL_SP_CONF.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetSCL_SP_CONF_SCL_RST_SLV_EN() uint32 {
	return volatile.LoadUint32(&o.SCL_SP_CONF.Reg) & 0x1
}
func (o *I2C_Type) SetSCL_SP_CONF_SCL_RST_SLV_NUM(value uint32) {
	volatile.StoreUint32(&o.SCL_SP_CONF.Reg, volatile.LoadUint32(&o.SCL_SP_CONF.Reg)&^(0x3e)|value<<1)
}
func (o *I2C_Type) GetSCL_SP_CONF_SCL_RST_SLV_NUM() uint32 {
	return (volatile.LoadUint32(&o.SCL_SP_CONF.Reg) & 0x3e) >> 1
}
func (o *I2C_Type) SetSCL_SP_CONF_SCL_PD_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_SP_CONF.Reg, volatile.LoadUint32(&o.SCL_SP_CONF.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetSCL_SP_CONF_SCL_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.SCL_SP_CONF.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetSCL_SP_CONF_SDA_PD_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_SP_CONF.Reg, volatile.LoadUint32(&o.SCL_SP_CONF.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetSCL_SP_CONF_SDA_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.SCL_SP_CONF.Reg) & 0x80) >> 7
}

// I2C.SCL_STRETCH_CONF: Set SCL stretch of I2C slave
func (o *I2C_Type) SetSCL_STRETCH_CONF_STRETCH_PROTECT_NUM(value uint32) {
	volatile.StoreUint32(&o.SCL_STRETCH_CONF.Reg, volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetSCL_STRETCH_CONF_STRETCH_PROTECT_NUM() uint32 {
	return volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg) & 0x3ff
}
func (o *I2C_Type) SetSCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_STRETCH_CONF.Reg, volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetSCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN() uint32 {
	return (volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetSCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR(value uint32) {
	volatile.StoreUint32(&o.SCL_STRETCH_CONF.Reg, volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetSCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR() uint32 {
	return (volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetSCL_STRETCH_CONF_SLAVE_BYTE_ACK_CTL_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_STRETCH_CONF.Reg, volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetSCL_STRETCH_CONF_SLAVE_BYTE_ACK_CTL_EN() uint32 {
	return (volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetSCL_STRETCH_CONF_SLAVE_BYTE_ACK_LVL(value uint32) {
	volatile.StoreUint32(&o.SCL_STRETCH_CONF.Reg, volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetSCL_STRETCH_CONF_SLAVE_BYTE_ACK_LVL() uint32 {
	return (volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg) & 0x2000) >> 13
}

// I2C.DATE: Version register
func (o *I2C_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *I2C_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// I2C.TXFIFO_START_ADDR: I2C TXFIFO base address register
func (o *I2C_Type) SetTXFIFO_START_ADDR(value uint32) {
	volatile.StoreUint32(&o.TXFIFO_START_ADDR.Reg, value)
}
func (o *I2C_Type) GetTXFIFO_START_ADDR() uint32 {
	return volatile.LoadUint32(&o.TXFIFO_START_ADDR.Reg)
}

// I2C.RXFIFO_START_ADDR: I2C RXFIFO base address register
func (o *I2C_Type) SetRXFIFO_START_ADDR(value uint32) {
	volatile.StoreUint32(&o.RXFIFO_START_ADDR.Reg, value)
}
func (o *I2C_Type) GetRXFIFO_START_ADDR() uint32 {
	return volatile.LoadUint32(&o.RXFIFO_START_ADDR.Reg)
}

// I2S (Inter-IC Sound) Controller 0
type I2S_Type struct {
	_                [12]byte
	INT_RAW          volatile.Register32 // 0xC
	INT_ST           volatile.Register32 // 0x10
	INT_ENA          volatile.Register32 // 0x14
	INT_CLR          volatile.Register32 // 0x18
	_                [4]byte
	RX_CONF          volatile.Register32 // 0x20
	TX_CONF          volatile.Register32 // 0x24
	RX_CONF1         volatile.Register32 // 0x28
	TX_CONF1         volatile.Register32 // 0x2C
	RX_CLKM_CONF     volatile.Register32 // 0x30
	TX_CLKM_CONF     volatile.Register32 // 0x34
	RX_CLKM_DIV_CONF volatile.Register32 // 0x38
	TX_CLKM_DIV_CONF volatile.Register32 // 0x3C
	TX_PCM2PDM_CONF  volatile.Register32 // 0x40
	TX_PCM2PDM_CONF1 volatile.Register32 // 0x44
	_                [8]byte
	RX_TDM_CTRL      volatile.Register32 // 0x50
	TX_TDM_CTRL      volatile.Register32 // 0x54
	RX_TIMING        volatile.Register32 // 0x58
	TX_TIMING        volatile.Register32 // 0x5C
	LC_HUNG_CONF     volatile.Register32 // 0x60
	RXEOF_NUM        volatile.Register32 // 0x64
	CONF_SIGLE_DATA  volatile.Register32 // 0x68
	STATE            volatile.Register32 // 0x6C
	ETM_CONF         volatile.Register32 // 0x70
	_                [12]byte
	DATE             volatile.Register32 // 0x80
}

// I2S.INT_RAW: I2S interrupt raw register, valid in level.
func (o *I2S_Type) SetINT_RAW_RX_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINT_RAW_RX_DONE_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *I2S_Type) SetINT_RAW_TX_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINT_RAW_TX_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINT_RAW_RX_HUNG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINT_RAW_RX_HUNG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINT_RAW_TX_HUNG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetINT_RAW_TX_HUNG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}

// I2S.INT_ST: I2S interrupt status register.
func (o *I2S_Type) SetINT_ST_RX_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINT_ST_RX_DONE_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *I2S_Type) SetINT_ST_TX_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINT_ST_TX_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINT_ST_RX_HUNG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINT_ST_RX_HUNG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINT_ST_TX_HUNG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetINT_ST_TX_HUNG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}

// I2S.INT_ENA: I2S interrupt enable register.
func (o *I2S_Type) SetINT_ENA_RX_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINT_ENA_RX_DONE_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *I2S_Type) SetINT_ENA_TX_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINT_ENA_TX_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINT_ENA_RX_HUNG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINT_ENA_RX_HUNG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINT_ENA_TX_HUNG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetINT_ENA_TX_HUNG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}

// I2S.INT_CLR: I2S interrupt clear register.
func (o *I2S_Type) SetINT_CLR_RX_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINT_CLR_RX_DONE_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *I2S_Type) SetINT_CLR_TX_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINT_CLR_TX_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINT_CLR_RX_HUNG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINT_CLR_RX_HUNG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINT_CLR_TX_HUNG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetINT_CLR_TX_HUNG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}

// I2S.RX_CONF: I2S RX configure register
func (o *I2S_Type) SetRX_CONF_RX_RESET(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetRX_CONF_RX_RESET() uint32 {
	return volatile.LoadUint32(&o.RX_CONF.Reg) & 0x1
}
func (o *I2S_Type) SetRX_CONF_RX_FIFO_RESET(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetRX_CONF_RX_FIFO_RESET() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetRX_CONF_RX_START(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetRX_CONF_RX_START() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetRX_CONF_RX_SLAVE_MOD(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetRX_CONF_RX_SLAVE_MOD() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetRX_CONF_RX_STOP_MODE(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x30)|value<<4)
}
func (o *I2S_Type) GetRX_CONF_RX_STOP_MODE() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x30) >> 4
}
func (o *I2S_Type) SetRX_CONF_RX_MONO(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetRX_CONF_RX_MONO() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetRX_CONF_RX_BIG_ENDIAN(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetRX_CONF_RX_BIG_ENDIAN() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetRX_CONF_RX_UPDATE(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetRX_CONF_RX_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetRX_CONF_RX_MONO_FST_VLD(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetRX_CONF_RX_MONO_FST_VLD() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetRX_CONF_RX_PCM_CONF(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0xc00)|value<<10)
}
func (o *I2S_Type) GetRX_CONF_RX_PCM_CONF() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0xc00) >> 10
}
func (o *I2S_Type) SetRX_CONF_RX_PCM_BYPASS(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetRX_CONF_RX_PCM_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetRX_CONF_RX_MSB_SHIFT(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetRX_CONF_RX_MSB_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetRX_CONF_RX_LEFT_ALIGN(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetRX_CONF_RX_LEFT_ALIGN() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetRX_CONF_RX_24_FILL_EN(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetRX_CONF_RX_24_FILL_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetRX_CONF_RX_WS_IDLE_POL(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetRX_CONF_RX_WS_IDLE_POL() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x20000) >> 17
}
func (o *I2S_Type) SetRX_CONF_RX_BIT_ORDER(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *I2S_Type) GetRX_CONF_RX_BIT_ORDER() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x40000) >> 18
}
func (o *I2S_Type) SetRX_CONF_RX_TDM_EN(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *I2S_Type) GetRX_CONF_RX_TDM_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x80000) >> 19
}
func (o *I2S_Type) SetRX_CONF_RX_PDM_EN(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetRX_CONF_RX_PDM_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetRX_CONF_RX_BCK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.RX_CONF.Reg, volatile.LoadUint32(&o.RX_CONF.Reg)&^(0x7e00000)|value<<21)
}
func (o *I2S_Type) GetRX_CONF_RX_BCK_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF.Reg) & 0x7e00000) >> 21
}

// I2S.TX_CONF: I2S TX configure register
func (o *I2S_Type) SetTX_CONF_TX_RESET(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetTX_CONF_TX_RESET() uint32 {
	return volatile.LoadUint32(&o.TX_CONF.Reg) & 0x1
}
func (o *I2S_Type) SetTX_CONF_TX_FIFO_RESET(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetTX_CONF_TX_FIFO_RESET() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetTX_CONF_TX_START(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetTX_CONF_TX_START() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetTX_CONF_TX_SLAVE_MOD(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetTX_CONF_TX_SLAVE_MOD() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetTX_CONF_TX_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetTX_CONF_TX_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetTX_CONF_TX_CHAN_EQUAL(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetTX_CONF_TX_CHAN_EQUAL() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetTX_CONF_TX_MONO(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetTX_CONF_TX_MONO() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetTX_CONF_TX_BIG_ENDIAN(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetTX_CONF_TX_BIG_ENDIAN() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetTX_CONF_TX_UPDATE(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetTX_CONF_TX_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetTX_CONF_TX_MONO_FST_VLD(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetTX_CONF_TX_MONO_FST_VLD() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetTX_CONF_TX_PCM_CONF(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0xc00)|value<<10)
}
func (o *I2S_Type) GetTX_CONF_TX_PCM_CONF() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0xc00) >> 10
}
func (o *I2S_Type) SetTX_CONF_TX_PCM_BYPASS(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetTX_CONF_TX_PCM_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetTX_CONF_TX_MSB_SHIFT(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetTX_CONF_TX_MSB_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetTX_CONF_TX_BCK_NO_DLY(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetTX_CONF_TX_BCK_NO_DLY() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetTX_CONF_TX_LEFT_ALIGN(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetTX_CONF_TX_LEFT_ALIGN() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetTX_CONF_TX_24_FILL_EN(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetTX_CONF_TX_24_FILL_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetTX_CONF_TX_WS_IDLE_POL(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetTX_CONF_TX_WS_IDLE_POL() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x20000) >> 17
}
func (o *I2S_Type) SetTX_CONF_TX_BIT_ORDER(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *I2S_Type) GetTX_CONF_TX_BIT_ORDER() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x40000) >> 18
}
func (o *I2S_Type) SetTX_CONF_TX_TDM_EN(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *I2S_Type) GetTX_CONF_TX_TDM_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x80000) >> 19
}
func (o *I2S_Type) SetTX_CONF_TX_PDM_EN(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetTX_CONF_TX_PDM_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetTX_CONF_TX_BCK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x7e00000)|value<<21)
}
func (o *I2S_Type) GetTX_CONF_TX_BCK_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x7e00000) >> 21
}
func (o *I2S_Type) SetTX_CONF_TX_CHAN_MOD(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x38000000)|value<<27)
}
func (o *I2S_Type) GetTX_CONF_TX_CHAN_MOD() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x38000000) >> 27
}
func (o *I2S_Type) SetTX_CONF_SIG_LOOPBACK(value uint32) {
	volatile.StoreUint32(&o.TX_CONF.Reg, volatile.LoadUint32(&o.TX_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S_Type) GetTX_CONF_SIG_LOOPBACK() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF.Reg) & 0x40000000) >> 30
}

// I2S.RX_CONF1: I2S RX configure register 1
func (o *I2S_Type) SetRX_CONF1_RX_TDM_WS_WIDTH(value uint32) {
	volatile.StoreUint32(&o.RX_CONF1.Reg, volatile.LoadUint32(&o.RX_CONF1.Reg)&^(0x1ff)|value)
}
func (o *I2S_Type) GetRX_CONF1_RX_TDM_WS_WIDTH() uint32 {
	return volatile.LoadUint32(&o.RX_CONF1.Reg) & 0x1ff
}
func (o *I2S_Type) SetRX_CONF1_RX_BITS_MOD(value uint32) {
	volatile.StoreUint32(&o.RX_CONF1.Reg, volatile.LoadUint32(&o.RX_CONF1.Reg)&^(0x7c000)|value<<14)
}
func (o *I2S_Type) GetRX_CONF1_RX_BITS_MOD() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF1.Reg) & 0x7c000) >> 14
}
func (o *I2S_Type) SetRX_CONF1_RX_HALF_SAMPLE_BITS(value uint32) {
	volatile.StoreUint32(&o.RX_CONF1.Reg, volatile.LoadUint32(&o.RX_CONF1.Reg)&^(0x7f80000)|value<<19)
}
func (o *I2S_Type) GetRX_CONF1_RX_HALF_SAMPLE_BITS() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF1.Reg) & 0x7f80000) >> 19
}
func (o *I2S_Type) SetRX_CONF1_RX_TDM_CHAN_BITS(value uint32) {
	volatile.StoreUint32(&o.RX_CONF1.Reg, volatile.LoadUint32(&o.RX_CONF1.Reg)&^(0xf8000000)|value<<27)
}
func (o *I2S_Type) GetRX_CONF1_RX_TDM_CHAN_BITS() uint32 {
	return (volatile.LoadUint32(&o.RX_CONF1.Reg) & 0xf8000000) >> 27
}

// I2S.TX_CONF1: I2S TX configure register 1
func (o *I2S_Type) SetTX_CONF1_TX_TDM_WS_WIDTH(value uint32) {
	volatile.StoreUint32(&o.TX_CONF1.Reg, volatile.LoadUint32(&o.TX_CONF1.Reg)&^(0x1ff)|value)
}
func (o *I2S_Type) GetTX_CONF1_TX_TDM_WS_WIDTH() uint32 {
	return volatile.LoadUint32(&o.TX_CONF1.Reg) & 0x1ff
}
func (o *I2S_Type) SetTX_CONF1_TX_BITS_MOD(value uint32) {
	volatile.StoreUint32(&o.TX_CONF1.Reg, volatile.LoadUint32(&o.TX_CONF1.Reg)&^(0x7c000)|value<<14)
}
func (o *I2S_Type) GetTX_CONF1_TX_BITS_MOD() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF1.Reg) & 0x7c000) >> 14
}
func (o *I2S_Type) SetTX_CONF1_TX_HALF_SAMPLE_BITS(value uint32) {
	volatile.StoreUint32(&o.TX_CONF1.Reg, volatile.LoadUint32(&o.TX_CONF1.Reg)&^(0x7f80000)|value<<19)
}
func (o *I2S_Type) GetTX_CONF1_TX_HALF_SAMPLE_BITS() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF1.Reg) & 0x7f80000) >> 19
}
func (o *I2S_Type) SetTX_CONF1_TX_TDM_CHAN_BITS(value uint32) {
	volatile.StoreUint32(&o.TX_CONF1.Reg, volatile.LoadUint32(&o.TX_CONF1.Reg)&^(0xf8000000)|value<<27)
}
func (o *I2S_Type) GetTX_CONF1_TX_TDM_CHAN_BITS() uint32 {
	return (volatile.LoadUint32(&o.TX_CONF1.Reg) & 0xf8000000) >> 27
}

// I2S.RX_CLKM_CONF: I2S RX clock configure register
func (o *I2S_Type) SetRX_CLKM_CONF_RX_CLKM_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.RX_CLKM_CONF.Reg, volatile.LoadUint32(&o.RX_CLKM_CONF.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetRX_CLKM_CONF_RX_CLKM_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.RX_CLKM_CONF.Reg) & 0xff
}
func (o *I2S_Type) SetRX_CLKM_CONF_RX_CLK_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.RX_CLKM_CONF.Reg, volatile.LoadUint32(&o.RX_CLKM_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *I2S_Type) GetRX_CLKM_CONF_RX_CLK_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.RX_CLKM_CONF.Reg) & 0x4000000) >> 26
}
func (o *I2S_Type) SetRX_CLKM_CONF_RX_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.RX_CLKM_CONF.Reg, volatile.LoadUint32(&o.RX_CLKM_CONF.Reg)&^(0x18000000)|value<<27)
}
func (o *I2S_Type) GetRX_CLKM_CONF_RX_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.RX_CLKM_CONF.Reg) & 0x18000000) >> 27
}
func (o *I2S_Type) SetRX_CLKM_CONF_MCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.RX_CLKM_CONF.Reg, volatile.LoadUint32(&o.RX_CLKM_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S_Type) GetRX_CLKM_CONF_MCLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.RX_CLKM_CONF.Reg) & 0x20000000) >> 29
}

// I2S.TX_CLKM_CONF: I2S TX clock configure register
func (o *I2S_Type) SetTX_CLKM_CONF_TX_CLKM_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.TX_CLKM_CONF.Reg, volatile.LoadUint32(&o.TX_CLKM_CONF.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetTX_CLKM_CONF_TX_CLKM_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.TX_CLKM_CONF.Reg) & 0xff
}
func (o *I2S_Type) SetTX_CLKM_CONF_TX_CLK_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.TX_CLKM_CONF.Reg, volatile.LoadUint32(&o.TX_CLKM_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *I2S_Type) GetTX_CLKM_CONF_TX_CLK_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.TX_CLKM_CONF.Reg) & 0x4000000) >> 26
}
func (o *I2S_Type) SetTX_CLKM_CONF_TX_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.TX_CLKM_CONF.Reg, volatile.LoadUint32(&o.TX_CLKM_CONF.Reg)&^(0x18000000)|value<<27)
}
func (o *I2S_Type) GetTX_CLKM_CONF_TX_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TX_CLKM_CONF.Reg) & 0x18000000) >> 27
}
func (o *I2S_Type) SetTX_CLKM_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.TX_CLKM_CONF.Reg, volatile.LoadUint32(&o.TX_CLKM_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S_Type) GetTX_CLKM_CONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_CLKM_CONF.Reg) & 0x20000000) >> 29
}

// I2S.RX_CLKM_DIV_CONF: I2S RX module clock divider configure register
func (o *I2S_Type) SetRX_CLKM_DIV_CONF_RX_CLKM_DIV_Z(value uint32) {
	volatile.StoreUint32(&o.RX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.RX_CLKM_DIV_CONF.Reg)&^(0x1ff)|value)
}
func (o *I2S_Type) GetRX_CLKM_DIV_CONF_RX_CLKM_DIV_Z() uint32 {
	return volatile.LoadUint32(&o.RX_CLKM_DIV_CONF.Reg) & 0x1ff
}
func (o *I2S_Type) SetRX_CLKM_DIV_CONF_RX_CLKM_DIV_Y(value uint32) {
	volatile.StoreUint32(&o.RX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.RX_CLKM_DIV_CONF.Reg)&^(0x3fe00)|value<<9)
}
func (o *I2S_Type) GetRX_CLKM_DIV_CONF_RX_CLKM_DIV_Y() uint32 {
	return (volatile.LoadUint32(&o.RX_CLKM_DIV_CONF.Reg) & 0x3fe00) >> 9
}
func (o *I2S_Type) SetRX_CLKM_DIV_CONF_RX_CLKM_DIV_X(value uint32) {
	volatile.StoreUint32(&o.RX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.RX_CLKM_DIV_CONF.Reg)&^(0x7fc0000)|value<<18)
}
func (o *I2S_Type) GetRX_CLKM_DIV_CONF_RX_CLKM_DIV_X() uint32 {
	return (volatile.LoadUint32(&o.RX_CLKM_DIV_CONF.Reg) & 0x7fc0000) >> 18
}
func (o *I2S_Type) SetRX_CLKM_DIV_CONF_RX_CLKM_DIV_YN1(value uint32) {
	volatile.StoreUint32(&o.RX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.RX_CLKM_DIV_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *I2S_Type) GetRX_CLKM_DIV_CONF_RX_CLKM_DIV_YN1() uint32 {
	return (volatile.LoadUint32(&o.RX_CLKM_DIV_CONF.Reg) & 0x8000000) >> 27
}

// I2S.TX_CLKM_DIV_CONF: I2S TX module clock divider configure register
func (o *I2S_Type) SetTX_CLKM_DIV_CONF_TX_CLKM_DIV_Z(value uint32) {
	volatile.StoreUint32(&o.TX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.TX_CLKM_DIV_CONF.Reg)&^(0x1ff)|value)
}
func (o *I2S_Type) GetTX_CLKM_DIV_CONF_TX_CLKM_DIV_Z() uint32 {
	return volatile.LoadUint32(&o.TX_CLKM_DIV_CONF.Reg) & 0x1ff
}
func (o *I2S_Type) SetTX_CLKM_DIV_CONF_TX_CLKM_DIV_Y(value uint32) {
	volatile.StoreUint32(&o.TX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.TX_CLKM_DIV_CONF.Reg)&^(0x3fe00)|value<<9)
}
func (o *I2S_Type) GetTX_CLKM_DIV_CONF_TX_CLKM_DIV_Y() uint32 {
	return (volatile.LoadUint32(&o.TX_CLKM_DIV_CONF.Reg) & 0x3fe00) >> 9
}
func (o *I2S_Type) SetTX_CLKM_DIV_CONF_TX_CLKM_DIV_X(value uint32) {
	volatile.StoreUint32(&o.TX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.TX_CLKM_DIV_CONF.Reg)&^(0x7fc0000)|value<<18)
}
func (o *I2S_Type) GetTX_CLKM_DIV_CONF_TX_CLKM_DIV_X() uint32 {
	return (volatile.LoadUint32(&o.TX_CLKM_DIV_CONF.Reg) & 0x7fc0000) >> 18
}
func (o *I2S_Type) SetTX_CLKM_DIV_CONF_TX_CLKM_DIV_YN1(value uint32) {
	volatile.StoreUint32(&o.TX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.TX_CLKM_DIV_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *I2S_Type) GetTX_CLKM_DIV_CONF_TX_CLKM_DIV_YN1() uint32 {
	return (volatile.LoadUint32(&o.TX_CLKM_DIV_CONF.Reg) & 0x8000000) >> 27
}

// I2S.TX_PCM2PDM_CONF: I2S TX PCM2PDM configuration register
func (o *I2S_Type) SetTX_PCM2PDM_CONF_TX_PDM_HP_BYPASS(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF_TX_PDM_HP_BYPASS() uint32 {
	return volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg) & 0x1
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF_TX_PDM_SINC_OSR2(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg)&^(0x1e)|value<<1)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF_TX_PDM_SINC_OSR2() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg) & 0x1e) >> 1
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF_TX_PDM_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg)&^(0x1fe0)|value<<5)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF_TX_PDM_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg) & 0x1fe0) >> 5
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF_TX_PDM_HP_IN_SHIFT(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg)&^(0x6000)|value<<13)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF_TX_PDM_HP_IN_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg) & 0x6000) >> 13
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF_TX_PDM_LP_IN_SHIFT(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg)&^(0x18000)|value<<15)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF_TX_PDM_LP_IN_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg) & 0x18000) >> 15
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF_TX_PDM_SINC_IN_SHIFT(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg)&^(0x60000)|value<<17)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF_TX_PDM_SINC_IN_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg) & 0x60000) >> 17
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_IN_SHIFT(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg)&^(0x180000)|value<<19)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_IN_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg) & 0x180000) >> 19
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_DITHER2(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_DITHER2() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg) & 0x200000) >> 21
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_DITHER(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_DITHER() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg) & 0x400000) >> 22
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF_TX_PDM_DAC_2OUT_EN(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF_TX_PDM_DAC_2OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg) & 0x800000) >> 23
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF_TX_PDM_DAC_MODE_EN(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF_TX_PDM_DAC_MODE_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg) & 0x1000000) >> 24
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF_PCM2PDM_CONV_EN(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF_PCM2PDM_CONV_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF.Reg) & 0x2000000) >> 25
}

// I2S.TX_PCM2PDM_CONF1: I2S TX PCM2PDM configuration register
func (o *I2S_Type) SetTX_PCM2PDM_CONF1_TX_PDM_FP(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF1.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF1.Reg)&^(0x3ff)|value)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF1_TX_PDM_FP() uint32 {
	return volatile.LoadUint32(&o.TX_PCM2PDM_CONF1.Reg) & 0x3ff
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF1_TX_PDM_FS(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF1.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF1_TX_PDM_FS() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF1.Reg) & 0xffc00) >> 10
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF1_TX_IIR_HP_MULT12_5(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF1.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF1.Reg)&^(0x700000)|value<<20)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF1_TX_IIR_HP_MULT12_5() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF1.Reg) & 0x700000) >> 20
}
func (o *I2S_Type) SetTX_PCM2PDM_CONF1_TX_IIR_HP_MULT12_0(value uint32) {
	volatile.StoreUint32(&o.TX_PCM2PDM_CONF1.Reg, volatile.LoadUint32(&o.TX_PCM2PDM_CONF1.Reg)&^(0x3800000)|value<<23)
}
func (o *I2S_Type) GetTX_PCM2PDM_CONF1_TX_IIR_HP_MULT12_0() uint32 {
	return (volatile.LoadUint32(&o.TX_PCM2PDM_CONF1.Reg) & 0x3800000) >> 23
}

// I2S.RX_TDM_CTRL: I2S TX TDM mode control register
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_PDM_CHAN0_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_PDM_CHAN0_EN() uint32 {
	return volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x1
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_PDM_CHAN1_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_PDM_CHAN1_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_PDM_CHAN2_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_PDM_CHAN2_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_PDM_CHAN3_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_PDM_CHAN3_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_PDM_CHAN4_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_PDM_CHAN4_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_PDM_CHAN5_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_PDM_CHAN5_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_PDM_CHAN6_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_PDM_CHAN6_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_PDM_CHAN7_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_PDM_CHAN7_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_CHAN8_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_CHAN8_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_CHAN9_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_CHAN9_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_CHAN10_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_CHAN10_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_CHAN11_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_CHAN11_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_CHAN12_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_CHAN12_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_CHAN13_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_CHAN13_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_CHAN14_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_CHAN14_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_CHAN15_EN(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_CHAN15_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetRX_TDM_CTRL_RX_TDM_TOT_CHAN_NUM(value uint32) {
	volatile.StoreUint32(&o.RX_TDM_CTRL.Reg, volatile.LoadUint32(&o.RX_TDM_CTRL.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S_Type) GetRX_TDM_CTRL_RX_TDM_TOT_CHAN_NUM() uint32 {
	return (volatile.LoadUint32(&o.RX_TDM_CTRL.Reg) & 0xf0000) >> 16
}

// I2S.TX_TDM_CTRL: I2S TX TDM mode control register
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN0_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN0_EN() uint32 {
	return volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x1
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN1_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN1_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN2_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN2_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN3_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN3_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN4_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN4_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN5_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN5_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN6_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN6_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN7_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN7_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN8_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN8_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN9_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN9_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN10_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN10_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN11_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN11_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN12_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN12_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN13_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN13_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN14_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN14_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_CHAN15_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_CHAN15_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_TOT_CHAN_NUM(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_TOT_CHAN_NUM() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0xf0000) >> 16
}
func (o *I2S_Type) SetTX_TDM_CTRL_TX_TDM_SKIP_MSK_EN(value uint32) {
	volatile.StoreUint32(&o.TX_TDM_CTRL.Reg, volatile.LoadUint32(&o.TX_TDM_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetTX_TDM_CTRL_TX_TDM_SKIP_MSK_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_TDM_CTRL.Reg) & 0x100000) >> 20
}

// I2S.RX_TIMING: I2S RX timing control register
func (o *I2S_Type) SetRX_TIMING_RX_SD_IN_DM(value uint32) {
	volatile.StoreUint32(&o.RX_TIMING.Reg, volatile.LoadUint32(&o.RX_TIMING.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetRX_TIMING_RX_SD_IN_DM() uint32 {
	return volatile.LoadUint32(&o.RX_TIMING.Reg) & 0x3
}
func (o *I2S_Type) SetRX_TIMING_RX_WS_OUT_DM(value uint32) {
	volatile.StoreUint32(&o.RX_TIMING.Reg, volatile.LoadUint32(&o.RX_TIMING.Reg)&^(0x30000)|value<<16)
}
func (o *I2S_Type) GetRX_TIMING_RX_WS_OUT_DM() uint32 {
	return (volatile.LoadUint32(&o.RX_TIMING.Reg) & 0x30000) >> 16
}
func (o *I2S_Type) SetRX_TIMING_RX_BCK_OUT_DM(value uint32) {
	volatile.StoreUint32(&o.RX_TIMING.Reg, volatile.LoadUint32(&o.RX_TIMING.Reg)&^(0x300000)|value<<20)
}
func (o *I2S_Type) GetRX_TIMING_RX_BCK_OUT_DM() uint32 {
	return (volatile.LoadUint32(&o.RX_TIMING.Reg) & 0x300000) >> 20
}
func (o *I2S_Type) SetRX_TIMING_RX_WS_IN_DM(value uint32) {
	volatile.StoreUint32(&o.RX_TIMING.Reg, volatile.LoadUint32(&o.RX_TIMING.Reg)&^(0x3000000)|value<<24)
}
func (o *I2S_Type) GetRX_TIMING_RX_WS_IN_DM() uint32 {
	return (volatile.LoadUint32(&o.RX_TIMING.Reg) & 0x3000000) >> 24
}
func (o *I2S_Type) SetRX_TIMING_RX_BCK_IN_DM(value uint32) {
	volatile.StoreUint32(&o.RX_TIMING.Reg, volatile.LoadUint32(&o.RX_TIMING.Reg)&^(0x30000000)|value<<28)
}
func (o *I2S_Type) GetRX_TIMING_RX_BCK_IN_DM() uint32 {
	return (volatile.LoadUint32(&o.RX_TIMING.Reg) & 0x30000000) >> 28
}

// I2S.TX_TIMING: I2S TX timing control register
func (o *I2S_Type) SetTX_TIMING_TX_SD_OUT_DM(value uint32) {
	volatile.StoreUint32(&o.TX_TIMING.Reg, volatile.LoadUint32(&o.TX_TIMING.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetTX_TIMING_TX_SD_OUT_DM() uint32 {
	return volatile.LoadUint32(&o.TX_TIMING.Reg) & 0x3
}
func (o *I2S_Type) SetTX_TIMING_TX_SD1_OUT_DM(value uint32) {
	volatile.StoreUint32(&o.TX_TIMING.Reg, volatile.LoadUint32(&o.TX_TIMING.Reg)&^(0x30)|value<<4)
}
func (o *I2S_Type) GetTX_TIMING_TX_SD1_OUT_DM() uint32 {
	return (volatile.LoadUint32(&o.TX_TIMING.Reg) & 0x30) >> 4
}
func (o *I2S_Type) SetTX_TIMING_TX_WS_OUT_DM(value uint32) {
	volatile.StoreUint32(&o.TX_TIMING.Reg, volatile.LoadUint32(&o.TX_TIMING.Reg)&^(0x30000)|value<<16)
}
func (o *I2S_Type) GetTX_TIMING_TX_WS_OUT_DM() uint32 {
	return (volatile.LoadUint32(&o.TX_TIMING.Reg) & 0x30000) >> 16
}
func (o *I2S_Type) SetTX_TIMING_TX_BCK_OUT_DM(value uint32) {
	volatile.StoreUint32(&o.TX_TIMING.Reg, volatile.LoadUint32(&o.TX_TIMING.Reg)&^(0x300000)|value<<20)
}
func (o *I2S_Type) GetTX_TIMING_TX_BCK_OUT_DM() uint32 {
	return (volatile.LoadUint32(&o.TX_TIMING.Reg) & 0x300000) >> 20
}
func (o *I2S_Type) SetTX_TIMING_TX_WS_IN_DM(value uint32) {
	volatile.StoreUint32(&o.TX_TIMING.Reg, volatile.LoadUint32(&o.TX_TIMING.Reg)&^(0x3000000)|value<<24)
}
func (o *I2S_Type) GetTX_TIMING_TX_WS_IN_DM() uint32 {
	return (volatile.LoadUint32(&o.TX_TIMING.Reg) & 0x3000000) >> 24
}
func (o *I2S_Type) SetTX_TIMING_TX_BCK_IN_DM(value uint32) {
	volatile.StoreUint32(&o.TX_TIMING.Reg, volatile.LoadUint32(&o.TX_TIMING.Reg)&^(0x30000000)|value<<28)
}
func (o *I2S_Type) GetTX_TIMING_TX_BCK_IN_DM() uint32 {
	return (volatile.LoadUint32(&o.TX_TIMING.Reg) & 0x30000000) >> 28
}

// I2S.LC_HUNG_CONF: I2S HUNG configure register.
func (o *I2S_Type) SetLC_HUNG_CONF_LC_FIFO_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.LC_HUNG_CONF.Reg, volatile.LoadUint32(&o.LC_HUNG_CONF.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetLC_HUNG_CONF_LC_FIFO_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.LC_HUNG_CONF.Reg) & 0xff
}
func (o *I2S_Type) SetLC_HUNG_CONF_LC_FIFO_TIMEOUT_SHIFT(value uint32) {
	volatile.StoreUint32(&o.LC_HUNG_CONF.Reg, volatile.LoadUint32(&o.LC_HUNG_CONF.Reg)&^(0x700)|value<<8)
}
func (o *I2S_Type) GetLC_HUNG_CONF_LC_FIFO_TIMEOUT_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.LC_HUNG_CONF.Reg) & 0x700) >> 8
}
func (o *I2S_Type) SetLC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA(value uint32) {
	volatile.StoreUint32(&o.LC_HUNG_CONF.Reg, volatile.LoadUint32(&o.LC_HUNG_CONF.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetLC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LC_HUNG_CONF.Reg) & 0x800) >> 11
}

// I2S.RXEOF_NUM: I2S RX data number control register.
func (o *I2S_Type) SetRXEOF_NUM_RX_EOF_NUM(value uint32) {
	volatile.StoreUint32(&o.RXEOF_NUM.Reg, volatile.LoadUint32(&o.RXEOF_NUM.Reg)&^(0xfff)|value)
}
func (o *I2S_Type) GetRXEOF_NUM_RX_EOF_NUM() uint32 {
	return volatile.LoadUint32(&o.RXEOF_NUM.Reg) & 0xfff
}

// I2S.CONF_SIGLE_DATA: I2S signal data register
func (o *I2S_Type) SetCONF_SIGLE_DATA(value uint32) {
	volatile.StoreUint32(&o.CONF_SIGLE_DATA.Reg, value)
}
func (o *I2S_Type) GetCONF_SIGLE_DATA() uint32 {
	return volatile.LoadUint32(&o.CONF_SIGLE_DATA.Reg)
}

// I2S.STATE: I2S TX status register
func (o *I2S_Type) SetSTATE_TX_IDLE(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetSTATE_TX_IDLE() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0x1
}

// I2S.ETM_CONF: I2S ETM configure register
func (o *I2S_Type) SetETM_CONF_ETM_TX_SEND_WORD_NUM(value uint32) {
	volatile.StoreUint32(&o.ETM_CONF.Reg, volatile.LoadUint32(&o.ETM_CONF.Reg)&^(0x3ff)|value)
}
func (o *I2S_Type) GetETM_CONF_ETM_TX_SEND_WORD_NUM() uint32 {
	return volatile.LoadUint32(&o.ETM_CONF.Reg) & 0x3ff
}
func (o *I2S_Type) SetETM_CONF_ETM_RX_RECEIVE_WORD_NUM(value uint32) {
	volatile.StoreUint32(&o.ETM_CONF.Reg, volatile.LoadUint32(&o.ETM_CONF.Reg)&^(0xffc00)|value<<10)
}
func (o *I2S_Type) GetETM_CONF_ETM_RX_RECEIVE_WORD_NUM() uint32 {
	return (volatile.LoadUint32(&o.ETM_CONF.Reg) & 0xffc00) >> 10
}

// I2S.DATE: Version control register
func (o *I2S_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *I2S_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// Interrupt Controller (Core 0)
type INTMTX_CORE0_Type struct {
	PMU_INTR_MAP               volatile.Register32 // 0x0
	EFUSE_INTR_MAP             volatile.Register32 // 0x4
	LP_RTC_TIMER_INTR_MAP      volatile.Register32 // 0x8
	LP_BLE_TIMER_INTR_MAP      volatile.Register32 // 0xC
	LP_WDT_INTR_MAP            volatile.Register32 // 0x10
	LP_PERI_TIMEOUT_INTR_MAP   volatile.Register32 // 0x14
	LP_APM_M0_INTR_MAP         volatile.Register32 // 0x18
	CPU_INTR_FROM_CPU_0_MAP    volatile.Register32 // 0x1C
	CPU_INTR_FROM_CPU_1_MAP    volatile.Register32 // 0x20
	CPU_INTR_FROM_CPU_2_MAP    volatile.Register32 // 0x24
	CPU_INTR_FROM_CPU_3_MAP    volatile.Register32 // 0x28
	ASSIST_DEBUG_INTR_MAP      volatile.Register32 // 0x2C
	TRACE_INTR_MAP             volatile.Register32 // 0x30
	CACHE_INTR_MAP             volatile.Register32 // 0x34
	CPU_PERI_TIMEOUT_INTR_MAP  volatile.Register32 // 0x38
	BT_MAC_INTR_MAP            volatile.Register32 // 0x3C
	BT_BB_INTR_MAP             volatile.Register32 // 0x40
	BT_BB_NMI_MAP              volatile.Register32 // 0x44
	COEX_INTR_MAP              volatile.Register32 // 0x48
	BLE_TIMER_INTR_MAP         volatile.Register32 // 0x4C
	BLE_SEC_INTR_MAP           volatile.Register32 // 0x50
	ZB_MAC_INTR_MAP            volatile.Register32 // 0x54
	GPIO_INTERRUPT_PRO_MAP     volatile.Register32 // 0x58
	GPIO_INTERRUPT_PRO_NMI_MAP volatile.Register32 // 0x5C
	PAU_INTR_MAP               volatile.Register32 // 0x60
	HP_PERI_TIMEOUT_INTR_MAP   volatile.Register32 // 0x64
	HP_APM_M0_INTR_MAP         volatile.Register32 // 0x68
	HP_APM_M1_INTR_MAP         volatile.Register32 // 0x6C
	HP_APM_M2_INTR_MAP         volatile.Register32 // 0x70
	HP_APM_M3_INTR_MAP         volatile.Register32 // 0x74
	MSPI_INTR_MAP              volatile.Register32 // 0x78
	I2S1_INTR_MAP              volatile.Register32 // 0x7C
	UHCI0_INTR_MAP             volatile.Register32 // 0x80
	UART0_INTR_MAP             volatile.Register32 // 0x84
	UART1_INTR_MAP             volatile.Register32 // 0x88
	LEDC_INTR_MAP              volatile.Register32 // 0x8C
	CAN0_INTR_MAP              volatile.Register32 // 0x90
	USB_INTR_MAP               volatile.Register32 // 0x94
	RMT_INTR_MAP               volatile.Register32 // 0x98
	I2C_EXT0_INTR_MAP          volatile.Register32 // 0x9C
	I2C_EXT1_INTR_MAP          volatile.Register32 // 0xA0
	TG0_T0_INTR_MAP            volatile.Register32 // 0xA4
	TG0_WDT_INTR_MAP           volatile.Register32 // 0xA8
	TG1_T0_INTR_MAP            volatile.Register32 // 0xAC
	TG1_WDT_INTR_MAP           volatile.Register32 // 0xB0
	SYSTIMER_TARGET0_INTR_MAP  volatile.Register32 // 0xB4
	SYSTIMER_TARGET1_INTR_MAP  volatile.Register32 // 0xB8
	SYSTIMER_TARGET2_INTR_MAP  volatile.Register32 // 0xBC
	APB_ADC_INTR_MAP           volatile.Register32 // 0xC0
	PWM_INTR_MAP               volatile.Register32 // 0xC4
	PCNT_INTR_MAP              volatile.Register32 // 0xC8
	PARL_IO_TX_INTR_MAP        volatile.Register32 // 0xCC
	PARL_IO_RX_INTR_MAP        volatile.Register32 // 0xD0
	DMA_IN_CH0_INTR_MAP        volatile.Register32 // 0xD4
	DMA_IN_CH1_INTR_MAP        volatile.Register32 // 0xD8
	DMA_IN_CH2_INTR_MAP        volatile.Register32 // 0xDC
	DMA_OUT_CH0_INTR_MAP       volatile.Register32 // 0xE0
	DMA_OUT_CH1_INTR_MAP       volatile.Register32 // 0xE4
	DMA_OUT_CH2_INTR_MAP       volatile.Register32 // 0xE8
	GPSPI2_INTR_MAP            volatile.Register32 // 0xEC
	AES_INTR_MAP               volatile.Register32 // 0xF0
	SHA_INTR_MAP               volatile.Register32 // 0xF4
	RSA_INTR_MAP               volatile.Register32 // 0xF8
	ECC_INTR_MAP               volatile.Register32 // 0xFC
	ECDSA_INTR_MAP             volatile.Register32 // 0x100
	INTR_STATUS_REG_0          volatile.Register32 // 0x104
	INTR_STATUS_REG_1          volatile.Register32 // 0x108
	INT_STATUS_REG_2           volatile.Register32 // 0x10C
	CLOCK_GATE                 volatile.Register32 // 0x110
	_                          [1768]byte
	INTERRUPT_REG_DATE         volatile.Register32 // 0x7FC
}

// INTMTX_CORE0.PMU_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetPMU_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PMU_INTR_MAP.Reg, volatile.LoadUint32(&o.PMU_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetPMU_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PMU_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.EFUSE_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetEFUSE_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.EFUSE_INTR_MAP.Reg, volatile.LoadUint32(&o.EFUSE_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetEFUSE_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.EFUSE_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.LP_RTC_TIMER_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetLP_RTC_TIMER_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.LP_RTC_TIMER_INTR_MAP.Reg, volatile.LoadUint32(&o.LP_RTC_TIMER_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetLP_RTC_TIMER_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.LP_RTC_TIMER_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.LP_BLE_TIMER_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetLP_BLE_TIMER_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.LP_BLE_TIMER_INTR_MAP.Reg, volatile.LoadUint32(&o.LP_BLE_TIMER_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetLP_BLE_TIMER_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.LP_BLE_TIMER_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.LP_WDT_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetLP_WDT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.LP_WDT_INTR_MAP.Reg, volatile.LoadUint32(&o.LP_WDT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetLP_WDT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.LP_WDT_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.LP_PERI_TIMEOUT_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetLP_PERI_TIMEOUT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.LP_PERI_TIMEOUT_INTR_MAP.Reg, volatile.LoadUint32(&o.LP_PERI_TIMEOUT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetLP_PERI_TIMEOUT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.LP_PERI_TIMEOUT_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.LP_APM_M0_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetLP_APM_M0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.LP_APM_M0_INTR_MAP.Reg, volatile.LoadUint32(&o.LP_APM_M0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetLP_APM_M0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.LP_APM_M0_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.CPU_INTR_FROM_CPU_0_MAP: register description
func (o *INTMTX_CORE0_Type) SetCPU_INTR_FROM_CPU_0_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_0_MAP.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_0_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetCPU_INTR_FROM_CPU_0_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_0_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.CPU_INTR_FROM_CPU_1_MAP: register description
func (o *INTMTX_CORE0_Type) SetCPU_INTR_FROM_CPU_1_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_1_MAP.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_1_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetCPU_INTR_FROM_CPU_1_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_1_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.CPU_INTR_FROM_CPU_2_MAP: register description
func (o *INTMTX_CORE0_Type) SetCPU_INTR_FROM_CPU_2_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_2_MAP.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_2_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetCPU_INTR_FROM_CPU_2_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_2_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.CPU_INTR_FROM_CPU_3_MAP: register description
func (o *INTMTX_CORE0_Type) SetCPU_INTR_FROM_CPU_3_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_3_MAP.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_3_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetCPU_INTR_FROM_CPU_3_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_3_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.ASSIST_DEBUG_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetASSIST_DEBUG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.ASSIST_DEBUG_INTR_MAP.Reg, volatile.LoadUint32(&o.ASSIST_DEBUG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetASSIST_DEBUG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.ASSIST_DEBUG_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.TRACE_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetTRACE_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.TRACE_INTR_MAP.Reg, volatile.LoadUint32(&o.TRACE_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetTRACE_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.TRACE_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.CACHE_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetCACHE_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.CACHE_INTR_MAP.Reg, volatile.LoadUint32(&o.CACHE_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetCACHE_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.CACHE_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.CPU_PERI_TIMEOUT_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetCPU_PERI_TIMEOUT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_PERI_TIMEOUT_INTR_MAP.Reg, volatile.LoadUint32(&o.CPU_PERI_TIMEOUT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetCPU_PERI_TIMEOUT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_PERI_TIMEOUT_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.BT_MAC_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetBT_MAC_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.BT_MAC_INTR_MAP.Reg, volatile.LoadUint32(&o.BT_MAC_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetBT_MAC_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.BT_MAC_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.BT_BB_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetBT_BB_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.BT_BB_INTR_MAP.Reg, volatile.LoadUint32(&o.BT_BB_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetBT_BB_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.BT_BB_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.BT_BB_NMI_MAP: register description
func (o *INTMTX_CORE0_Type) SetBT_BB_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.BT_BB_NMI_MAP.Reg, volatile.LoadUint32(&o.BT_BB_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetBT_BB_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.BT_BB_NMI_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.COEX_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetCOEX_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.COEX_INTR_MAP.Reg, volatile.LoadUint32(&o.COEX_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetCOEX_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.COEX_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.BLE_TIMER_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetBLE_TIMER_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.BLE_TIMER_INTR_MAP.Reg, volatile.LoadUint32(&o.BLE_TIMER_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetBLE_TIMER_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.BLE_TIMER_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.BLE_SEC_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetBLE_SEC_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.BLE_SEC_INTR_MAP.Reg, volatile.LoadUint32(&o.BLE_SEC_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetBLE_SEC_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.BLE_SEC_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.ZB_MAC_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetZB_MAC_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.ZB_MAC_INTR_MAP.Reg, volatile.LoadUint32(&o.ZB_MAC_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetZB_MAC_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.ZB_MAC_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.GPIO_INTERRUPT_PRO_MAP: register description
func (o *INTMTX_CORE0_Type) SetGPIO_INTERRUPT_PRO_MAP(value uint32) {
	volatile.StoreUint32(&o.GPIO_INTERRUPT_PRO_MAP.Reg, volatile.LoadUint32(&o.GPIO_INTERRUPT_PRO_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetGPIO_INTERRUPT_PRO_MAP() uint32 {
	return volatile.LoadUint32(&o.GPIO_INTERRUPT_PRO_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.GPIO_INTERRUPT_PRO_NMI_MAP: register description
func (o *INTMTX_CORE0_Type) SetGPIO_INTERRUPT_PRO_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.GPIO_INTERRUPT_PRO_NMI_MAP.Reg, volatile.LoadUint32(&o.GPIO_INTERRUPT_PRO_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetGPIO_INTERRUPT_PRO_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.GPIO_INTERRUPT_PRO_NMI_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.PAU_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetPAU_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PAU_INTR_MAP.Reg, volatile.LoadUint32(&o.PAU_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetPAU_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PAU_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.HP_PERI_TIMEOUT_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetHP_PERI_TIMEOUT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.HP_PERI_TIMEOUT_INTR_MAP.Reg, volatile.LoadUint32(&o.HP_PERI_TIMEOUT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetHP_PERI_TIMEOUT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.HP_PERI_TIMEOUT_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.HP_APM_M0_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetHP_APM_M0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.HP_APM_M0_INTR_MAP.Reg, volatile.LoadUint32(&o.HP_APM_M0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetHP_APM_M0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.HP_APM_M0_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.HP_APM_M1_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetHP_APM_M1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.HP_APM_M1_INTR_MAP.Reg, volatile.LoadUint32(&o.HP_APM_M1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetHP_APM_M1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.HP_APM_M1_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.HP_APM_M2_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetHP_APM_M2_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.HP_APM_M2_INTR_MAP.Reg, volatile.LoadUint32(&o.HP_APM_M2_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetHP_APM_M2_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.HP_APM_M2_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.HP_APM_M3_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetHP_APM_M3_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.HP_APM_M3_INTR_MAP.Reg, volatile.LoadUint32(&o.HP_APM_M3_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetHP_APM_M3_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.HP_APM_M3_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.MSPI_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetMSPI_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.MSPI_INTR_MAP.Reg, volatile.LoadUint32(&o.MSPI_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetMSPI_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.MSPI_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.I2S1_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetI2S1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.I2S1_INTR_MAP.Reg, volatile.LoadUint32(&o.I2S1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetI2S1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.I2S1_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.UHCI0_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetUHCI0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.UHCI0_INTR_MAP.Reg, volatile.LoadUint32(&o.UHCI0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetUHCI0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.UHCI0_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.UART0_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetUART0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.UART0_INTR_MAP.Reg, volatile.LoadUint32(&o.UART0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetUART0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.UART0_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.UART1_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetUART1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.UART1_INTR_MAP.Reg, volatile.LoadUint32(&o.UART1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetUART1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.UART1_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.LEDC_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetLEDC_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.LEDC_INTR_MAP.Reg, volatile.LoadUint32(&o.LEDC_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetLEDC_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.LEDC_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.CAN0_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetCAN0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.CAN0_INTR_MAP.Reg, volatile.LoadUint32(&o.CAN0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetCAN0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.CAN0_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.USB_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetUSB_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.USB_INTR_MAP.Reg, volatile.LoadUint32(&o.USB_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetUSB_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.USB_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.RMT_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetRMT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.RMT_INTR_MAP.Reg, volatile.LoadUint32(&o.RMT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetRMT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.RMT_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.I2C_EXT0_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetI2C_EXT0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.I2C_EXT0_INTR_MAP.Reg, volatile.LoadUint32(&o.I2C_EXT0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetI2C_EXT0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.I2C_EXT0_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.I2C_EXT1_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetI2C_EXT1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.I2C_EXT1_INTR_MAP.Reg, volatile.LoadUint32(&o.I2C_EXT1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetI2C_EXT1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.I2C_EXT1_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.TG0_T0_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetTG0_T0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.TG0_T0_INTR_MAP.Reg, volatile.LoadUint32(&o.TG0_T0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetTG0_T0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.TG0_T0_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.TG0_WDT_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetTG0_WDT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.TG0_WDT_INTR_MAP.Reg, volatile.LoadUint32(&o.TG0_WDT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetTG0_WDT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.TG0_WDT_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.TG1_T0_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetTG1_T0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.TG1_T0_INTR_MAP.Reg, volatile.LoadUint32(&o.TG1_T0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetTG1_T0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.TG1_T0_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.TG1_WDT_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetTG1_WDT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.TG1_WDT_INTR_MAP.Reg, volatile.LoadUint32(&o.TG1_WDT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetTG1_WDT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.TG1_WDT_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.SYSTIMER_TARGET0_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetSYSTIMER_TARGET0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.SYSTIMER_TARGET0_INTR_MAP.Reg, volatile.LoadUint32(&o.SYSTIMER_TARGET0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetSYSTIMER_TARGET0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.SYSTIMER_TARGET0_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.SYSTIMER_TARGET1_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetSYSTIMER_TARGET1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.SYSTIMER_TARGET1_INTR_MAP.Reg, volatile.LoadUint32(&o.SYSTIMER_TARGET1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetSYSTIMER_TARGET1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.SYSTIMER_TARGET1_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.SYSTIMER_TARGET2_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetSYSTIMER_TARGET2_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.SYSTIMER_TARGET2_INTR_MAP.Reg, volatile.LoadUint32(&o.SYSTIMER_TARGET2_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetSYSTIMER_TARGET2_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.SYSTIMER_TARGET2_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.APB_ADC_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetAPB_ADC_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.APB_ADC_INTR_MAP.Reg, volatile.LoadUint32(&o.APB_ADC_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetAPB_ADC_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.APB_ADC_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.PWM_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetPWM_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PWM_INTR_MAP.Reg, volatile.LoadUint32(&o.PWM_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetPWM_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PWM_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.PCNT_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetPCNT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PCNT_INTR_MAP.Reg, volatile.LoadUint32(&o.PCNT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetPCNT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PCNT_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.PARL_IO_TX_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetPARL_IO_TX_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PARL_IO_TX_INTR_MAP.Reg, volatile.LoadUint32(&o.PARL_IO_TX_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetPARL_IO_TX_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PARL_IO_TX_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.PARL_IO_RX_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetPARL_IO_RX_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PARL_IO_RX_INTR_MAP.Reg, volatile.LoadUint32(&o.PARL_IO_RX_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetPARL_IO_RX_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PARL_IO_RX_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.DMA_IN_CH0_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetDMA_IN_CH0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_CH0_INTR_MAP.Reg, volatile.LoadUint32(&o.DMA_IN_CH0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetDMA_IN_CH0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_CH0_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.DMA_IN_CH1_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetDMA_IN_CH1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_CH1_INTR_MAP.Reg, volatile.LoadUint32(&o.DMA_IN_CH1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetDMA_IN_CH1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_CH1_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.DMA_IN_CH2_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetDMA_IN_CH2_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_CH2_INTR_MAP.Reg, volatile.LoadUint32(&o.DMA_IN_CH2_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetDMA_IN_CH2_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_CH2_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.DMA_OUT_CH0_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetDMA_OUT_CH0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_CH0_INTR_MAP.Reg, volatile.LoadUint32(&o.DMA_OUT_CH0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetDMA_OUT_CH0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_CH0_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.DMA_OUT_CH1_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetDMA_OUT_CH1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_CH1_INTR_MAP.Reg, volatile.LoadUint32(&o.DMA_OUT_CH1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetDMA_OUT_CH1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_CH1_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.DMA_OUT_CH2_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetDMA_OUT_CH2_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_CH2_INTR_MAP.Reg, volatile.LoadUint32(&o.DMA_OUT_CH2_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetDMA_OUT_CH2_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_CH2_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.GPSPI2_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetGPSPI2_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.GPSPI2_INTR_MAP.Reg, volatile.LoadUint32(&o.GPSPI2_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetGPSPI2_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.GPSPI2_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.AES_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetAES_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.AES_INTR_MAP.Reg, volatile.LoadUint32(&o.AES_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetAES_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.AES_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.SHA_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetSHA_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.SHA_INTR_MAP.Reg, volatile.LoadUint32(&o.SHA_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetSHA_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.SHA_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.RSA_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetRSA_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.RSA_INTR_MAP.Reg, volatile.LoadUint32(&o.RSA_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetRSA_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.RSA_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.ECC_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetECC_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.ECC_INTR_MAP.Reg, volatile.LoadUint32(&o.ECC_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetECC_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.ECC_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.ECDSA_INTR_MAP: register description
func (o *INTMTX_CORE0_Type) SetECDSA_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.ECDSA_INTR_MAP.Reg, volatile.LoadUint32(&o.ECDSA_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTMTX_CORE0_Type) GetECDSA_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.ECDSA_INTR_MAP.Reg) & 0x1f
}

// INTMTX_CORE0.INTR_STATUS_REG_0: register description
func (o *INTMTX_CORE0_Type) SetINTR_STATUS_REG_0(value uint32) {
	volatile.StoreUint32(&o.INTR_STATUS_REG_0.Reg, value)
}
func (o *INTMTX_CORE0_Type) GetINTR_STATUS_REG_0() uint32 {
	return volatile.LoadUint32(&o.INTR_STATUS_REG_0.Reg)
}

// INTMTX_CORE0.INTR_STATUS_REG_1: register description
func (o *INTMTX_CORE0_Type) SetINTR_STATUS_REG_1(value uint32) {
	volatile.StoreUint32(&o.INTR_STATUS_REG_1.Reg, value)
}
func (o *INTMTX_CORE0_Type) GetINTR_STATUS_REG_1() uint32 {
	return volatile.LoadUint32(&o.INTR_STATUS_REG_1.Reg)
}

// INTMTX_CORE0.INT_STATUS_REG_2: register description
func (o *INTMTX_CORE0_Type) SetINT_STATUS_REG_2(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS_REG_2.Reg, value)
}
func (o *INTMTX_CORE0_Type) GetINT_STATUS_REG_2() uint32 {
	return volatile.LoadUint32(&o.INT_STATUS_REG_2.Reg)
}

// INTMTX_CORE0.CLOCK_GATE: register description
func (o *INTMTX_CORE0_Type) SetCLOCK_GATE_REG_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *INTMTX_CORE0_Type) GetCLOCK_GATE_REG_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// INTMTX_CORE0.INTERRUPT_REG_DATE: register description
func (o *INTMTX_CORE0_Type) SetINTERRUPT_REG_DATE(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT_REG_DATE.Reg, volatile.LoadUint32(&o.INTERRUPT_REG_DATE.Reg)&^(0xfffffff)|value)
}
func (o *INTMTX_CORE0_Type) GetINTERRUPT_REG_DATE() uint32 {
	return volatile.LoadUint32(&o.INTERRUPT_REG_DATE.Reg) & 0xfffffff
}

// INTPRI Peripheral
type INTPRI_Type struct {
	CPU_INT_ENABLE      volatile.Register32 // 0x0
	CPU_INT_TYPE        volatile.Register32 // 0x4
	CPU_INT_EIP_STATUS  volatile.Register32 // 0x8
	CPU_INT_PRI_0       volatile.Register32 // 0xC
	CPU_INT_PRI_1       volatile.Register32 // 0x10
	CPU_INT_PRI_2       volatile.Register32 // 0x14
	CPU_INT_PRI_3       volatile.Register32 // 0x18
	CPU_INT_PRI_4       volatile.Register32 // 0x1C
	CPU_INT_PRI_5       volatile.Register32 // 0x20
	CPU_INT_PRI_6       volatile.Register32 // 0x24
	CPU_INT_PRI_7       volatile.Register32 // 0x28
	CPU_INT_PRI_8       volatile.Register32 // 0x2C
	CPU_INT_PRI_9       volatile.Register32 // 0x30
	CPU_INT_PRI_10      volatile.Register32 // 0x34
	CPU_INT_PRI_11      volatile.Register32 // 0x38
	CPU_INT_PRI_12      volatile.Register32 // 0x3C
	CPU_INT_PRI_13      volatile.Register32 // 0x40
	CPU_INT_PRI_14      volatile.Register32 // 0x44
	CPU_INT_PRI_15      volatile.Register32 // 0x48
	CPU_INT_PRI_16      volatile.Register32 // 0x4C
	CPU_INT_PRI_17      volatile.Register32 // 0x50
	CPU_INT_PRI_18      volatile.Register32 // 0x54
	CPU_INT_PRI_19      volatile.Register32 // 0x58
	CPU_INT_PRI_20      volatile.Register32 // 0x5C
	CPU_INT_PRI_21      volatile.Register32 // 0x60
	CPU_INT_PRI_22      volatile.Register32 // 0x64
	CPU_INT_PRI_23      volatile.Register32 // 0x68
	CPU_INT_PRI_24      volatile.Register32 // 0x6C
	CPU_INT_PRI_25      volatile.Register32 // 0x70
	CPU_INT_PRI_26      volatile.Register32 // 0x74
	CPU_INT_PRI_27      volatile.Register32 // 0x78
	CPU_INT_PRI_28      volatile.Register32 // 0x7C
	CPU_INT_PRI_29      volatile.Register32 // 0x80
	CPU_INT_PRI_30      volatile.Register32 // 0x84
	CPU_INT_PRI_31      volatile.Register32 // 0x88
	CPU_INT_THRESH      volatile.Register32 // 0x8C
	CPU_INTR_FROM_CPU_0 volatile.Register32 // 0x90
	CPU_INTR_FROM_CPU_1 volatile.Register32 // 0x94
	CPU_INTR_FROM_CPU_2 volatile.Register32 // 0x98
	CPU_INTR_FROM_CPU_3 volatile.Register32 // 0x9C
	DATE                volatile.Register32 // 0xA0
	CLOCK_GATE          volatile.Register32 // 0xA4
	CPU_INT_CLEAR       volatile.Register32 // 0xA8
	RND_ECO             volatile.Register32 // 0xAC
	RND_ECO_LOW         volatile.Register32 // 0xB0
	_                   [840]byte
	RND_ECO_HIGH        volatile.Register32 // 0x3FC
}

// INTPRI.CPU_INT_ENABLE: register description
func (o *INTPRI_Type) SetCPU_INT_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_ENABLE.Reg, value)
}
func (o *INTPRI_Type) GetCPU_INT_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_ENABLE.Reg)
}

// INTPRI.CPU_INT_TYPE: register description
func (o *INTPRI_Type) SetCPU_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_TYPE.Reg, value)
}
func (o *INTPRI_Type) GetCPU_INT_TYPE() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_TYPE.Reg)
}

// INTPRI.CPU_INT_EIP_STATUS: register description
func (o *INTPRI_Type) SetCPU_INT_EIP_STATUS(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_EIP_STATUS.Reg, value)
}
func (o *INTPRI_Type) GetCPU_INT_EIP_STATUS() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_EIP_STATUS.Reg)
}

// INTPRI.CPU_INT_PRI_0: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_0_CPU_PRI_0_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_0.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_0.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_0_CPU_PRI_0_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_0.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_1: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_1_CPU_PRI_1_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_1.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_1.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_1_CPU_PRI_1_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_1.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_2: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_2_CPU_PRI_2_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_2.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_2.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_2_CPU_PRI_2_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_2.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_3: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_3_CPU_PRI_3_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_3.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_3.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_3_CPU_PRI_3_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_3.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_4: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_4_CPU_PRI_4_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_4.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_4.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_4_CPU_PRI_4_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_4.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_5: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_5_CPU_PRI_5_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_5.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_5.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_5_CPU_PRI_5_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_5.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_6: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_6_CPU_PRI_6_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_6.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_6.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_6_CPU_PRI_6_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_6.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_7: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_7_CPU_PRI_7_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_7.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_7.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_7_CPU_PRI_7_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_7.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_8: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_8_CPU_PRI_8_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_8.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_8.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_8_CPU_PRI_8_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_8.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_9: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_9_CPU_PRI_9_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_9.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_9.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_9_CPU_PRI_9_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_9.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_10: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_10_CPU_PRI_10_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_10.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_10.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_10_CPU_PRI_10_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_10.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_11: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_11_CPU_PRI_11_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_11.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_11.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_11_CPU_PRI_11_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_11.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_12: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_12_CPU_PRI_12_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_12.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_12.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_12_CPU_PRI_12_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_12.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_13: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_13_CPU_PRI_13_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_13.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_13.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_13_CPU_PRI_13_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_13.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_14: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_14_CPU_PRI_14_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_14.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_14.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_14_CPU_PRI_14_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_14.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_15: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_15_CPU_PRI_15_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_15.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_15.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_15_CPU_PRI_15_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_15.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_16: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_16_CPU_PRI_16_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_16.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_16.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_16_CPU_PRI_16_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_16.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_17: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_17_CPU_PRI_17_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_17.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_17.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_17_CPU_PRI_17_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_17.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_18: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_18_CPU_PRI_18_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_18.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_18.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_18_CPU_PRI_18_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_18.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_19: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_19_CPU_PRI_19_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_19.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_19.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_19_CPU_PRI_19_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_19.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_20: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_20_CPU_PRI_20_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_20.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_20.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_20_CPU_PRI_20_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_20.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_21: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_21_CPU_PRI_21_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_21.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_21.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_21_CPU_PRI_21_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_21.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_22: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_22_CPU_PRI_22_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_22.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_22.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_22_CPU_PRI_22_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_22.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_23: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_23_CPU_PRI_23_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_23.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_23.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_23_CPU_PRI_23_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_23.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_24: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_24_CPU_PRI_24_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_24.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_24.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_24_CPU_PRI_24_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_24.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_25: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_25_CPU_PRI_25_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_25.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_25.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_25_CPU_PRI_25_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_25.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_26: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_26_CPU_PRI_26_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_26.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_26.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_26_CPU_PRI_26_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_26.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_27: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_27_CPU_PRI_27_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_27.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_27.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_27_CPU_PRI_27_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_27.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_28: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_28_CPU_PRI_28_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_28.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_28.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_28_CPU_PRI_28_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_28.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_29: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_29_CPU_PRI_29_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_29.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_29.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_29_CPU_PRI_29_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_29.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_30: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_30_CPU_PRI_30_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_30.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_30.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_30_CPU_PRI_30_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_30.Reg) & 0xf
}

// INTPRI.CPU_INT_PRI_31: register description
func (o *INTPRI_Type) SetCPU_INT_PRI_31_CPU_PRI_31_MAP(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_PRI_31.Reg, volatile.LoadUint32(&o.CPU_INT_PRI_31.Reg)&^(0xf)|value)
}
func (o *INTPRI_Type) GetCPU_INT_PRI_31_CPU_PRI_31_MAP() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_PRI_31.Reg) & 0xf
}

// INTPRI.CPU_INT_THRESH: register description
func (o *INTPRI_Type) SetCPU_INT_THRESH(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_THRESH.Reg, volatile.LoadUint32(&o.CPU_INT_THRESH.Reg)&^(0xff)|value)
}
func (o *INTPRI_Type) GetCPU_INT_THRESH() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_THRESH.Reg) & 0xff
}

// INTPRI.CPU_INTR_FROM_CPU_0: register description
func (o *INTPRI_Type) SetCPU_INTR_FROM_CPU_0(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_0.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_0.Reg)&^(0x1)|value)
}
func (o *INTPRI_Type) GetCPU_INTR_FROM_CPU_0() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_0.Reg) & 0x1
}

// INTPRI.CPU_INTR_FROM_CPU_1: register description
func (o *INTPRI_Type) SetCPU_INTR_FROM_CPU_1(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_1.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_1.Reg)&^(0x1)|value)
}
func (o *INTPRI_Type) GetCPU_INTR_FROM_CPU_1() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_1.Reg) & 0x1
}

// INTPRI.CPU_INTR_FROM_CPU_2: register description
func (o *INTPRI_Type) SetCPU_INTR_FROM_CPU_2(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_2.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_2.Reg)&^(0x1)|value)
}
func (o *INTPRI_Type) GetCPU_INTR_FROM_CPU_2() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_2.Reg) & 0x1
}

// INTPRI.CPU_INTR_FROM_CPU_3: register description
func (o *INTPRI_Type) SetCPU_INTR_FROM_CPU_3(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_3.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_3.Reg)&^(0x1)|value)
}
func (o *INTPRI_Type) GetCPU_INTR_FROM_CPU_3() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_3.Reg) & 0x1
}

// INTPRI.DATE: register description
func (o *INTPRI_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *INTPRI_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// INTPRI.CLOCK_GATE: register description
func (o *INTPRI_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *INTPRI_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// INTPRI.CPU_INT_CLEAR: register description
func (o *INTPRI_Type) SetCPU_INT_CLEAR(value uint32) {
	volatile.StoreUint32(&o.CPU_INT_CLEAR.Reg, value)
}
func (o *INTPRI_Type) GetCPU_INT_CLEAR() uint32 {
	return volatile.LoadUint32(&o.CPU_INT_CLEAR.Reg)
}

// INTPRI.RND_ECO: redcy eco register.
func (o *INTPRI_Type) SetRND_ECO_REDCY_ENA(value uint32) {
	volatile.StoreUint32(&o.RND_ECO.Reg, volatile.LoadUint32(&o.RND_ECO.Reg)&^(0x1)|value)
}
func (o *INTPRI_Type) GetRND_ECO_REDCY_ENA() uint32 {
	return volatile.LoadUint32(&o.RND_ECO.Reg) & 0x1
}
func (o *INTPRI_Type) SetRND_ECO_REDCY_RESULT(value uint32) {
	volatile.StoreUint32(&o.RND_ECO.Reg, volatile.LoadUint32(&o.RND_ECO.Reg)&^(0x2)|value<<1)
}
func (o *INTPRI_Type) GetRND_ECO_REDCY_RESULT() uint32 {
	return (volatile.LoadUint32(&o.RND_ECO.Reg) & 0x2) >> 1
}

// INTPRI.RND_ECO_LOW: redcy eco low register.
func (o *INTPRI_Type) SetRND_ECO_LOW(value uint32) {
	volatile.StoreUint32(&o.RND_ECO_LOW.Reg, value)
}
func (o *INTPRI_Type) GetRND_ECO_LOW() uint32 {
	return volatile.LoadUint32(&o.RND_ECO_LOW.Reg)
}

// INTPRI.RND_ECO_HIGH: redcy eco high register.
func (o *INTPRI_Type) SetRND_ECO_HIGH(value uint32) {
	volatile.StoreUint32(&o.RND_ECO_HIGH.Reg, value)
}
func (o *INTPRI_Type) GetRND_ECO_HIGH() uint32 {
	return volatile.LoadUint32(&o.RND_ECO_HIGH.Reg)
}

// Input/Output Multiplexer
type IO_MUX_Type struct {
	PIN_CTRL      volatile.Register32 // 0x0
	GPIO0         volatile.Register32 // 0x4
	GPIO1         volatile.Register32 // 0x8
	GPIO2         volatile.Register32 // 0xC
	GPIO3         volatile.Register32 // 0x10
	GPIO4         volatile.Register32 // 0x14
	GPIO5         volatile.Register32 // 0x18
	GPIO6         volatile.Register32 // 0x1C
	GPIO7         volatile.Register32 // 0x20
	GPIO8         volatile.Register32 // 0x24
	GPIO9         volatile.Register32 // 0x28
	GPIO10        volatile.Register32 // 0x2C
	GPIO11        volatile.Register32 // 0x30
	GPIO12        volatile.Register32 // 0x34
	GPIO13        volatile.Register32 // 0x38
	GPIO14        volatile.Register32 // 0x3C
	GPIO15        volatile.Register32 // 0x40
	GPIO16        volatile.Register32 // 0x44
	GPIO17        volatile.Register32 // 0x48
	GPIO18        volatile.Register32 // 0x4C
	GPIO19        volatile.Register32 // 0x50
	GPIO20        volatile.Register32 // 0x54
	GPIO21        volatile.Register32 // 0x58
	GPIO22        volatile.Register32 // 0x5C
	GPIO23        volatile.Register32 // 0x60
	GPIO24        volatile.Register32 // 0x64
	GPIO25        volatile.Register32 // 0x68
	GPIO26        volatile.Register32 // 0x6C
	GPIO27        volatile.Register32 // 0x70
	_             [72]byte
	MODEM_DIAG_EN volatile.Register32 // 0xBC
	_             [60]byte
	DATE          volatile.Register32 // 0xFC
}

// IO_MUX.PIN_CTRL: Clock Output Configuration Register
func (o *IO_MUX_Type) SetPIN_CTRL_CLK_OUT1(value uint32) {
	volatile.StoreUint32(&o.PIN_CTRL.Reg, volatile.LoadUint32(&o.PIN_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_MUX_Type) GetPIN_CTRL_CLK_OUT1() uint32 {
	return volatile.LoadUint32(&o.PIN_CTRL.Reg) & 0x1f
}
func (o *IO_MUX_Type) SetPIN_CTRL_CLK_OUT2(value uint32) {
	volatile.StoreUint32(&o.PIN_CTRL.Reg, volatile.LoadUint32(&o.PIN_CTRL.Reg)&^(0x3e0)|value<<5)
}
func (o *IO_MUX_Type) GetPIN_CTRL_CLK_OUT2() uint32 {
	return (volatile.LoadUint32(&o.PIN_CTRL.Reg) & 0x3e0) >> 5
}
func (o *IO_MUX_Type) SetPIN_CTRL_CLK_OUT3(value uint32) {
	volatile.StoreUint32(&o.PIN_CTRL.Reg, volatile.LoadUint32(&o.PIN_CTRL.Reg)&^(0x7c00)|value<<10)
}
func (o *IO_MUX_Type) GetPIN_CTRL_CLK_OUT3() uint32 {
	return (volatile.LoadUint32(&o.PIN_CTRL.Reg) & 0x7c00) >> 10
}

// IO_MUX.GPIO0: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO0_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO0.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO0_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO0_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO0_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO0_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO0_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO0_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO0_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO0_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO0_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO0_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO0_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO0_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO0_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO0_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO0_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO0_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO0_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO1: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO1_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO1.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO1_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO1_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO1_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO1_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO1_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO1_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO1_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO1_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO1_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO1_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO1_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO1_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO1_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO1_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO1_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO1_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO1_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO1_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO1_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO1_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO1_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO2: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO2_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO2.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO2_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO2_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO2_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO2_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO2_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO2_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO2_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO2_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO2_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO2_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO2_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO2_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO2_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO2_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO2_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO2_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO2_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO2_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO2_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO2_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO2_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO3: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO3_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO3.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO3_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO3_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO3_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO3_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO3_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO3_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO3_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO3_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO3_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO3_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO3_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO3_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO3_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO3_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO3_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO3_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO3_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO3_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO3_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO3_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO3_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO4: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO4_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO4.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO4_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO4_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO4_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO4_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO4_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO4_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO4_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO4_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO4_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO4_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO4_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO4_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO4_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO4_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO4_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO4_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO4_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO4_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO4_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO4_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO4_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO5: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO5_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO5.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO5_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO5_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO5_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO5_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO5_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO5_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO5_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO5_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO5_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO5_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO5_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO5_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO5_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO5_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO5_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO5_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO5_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO5_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO5_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO5_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO5_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO6: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO6_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO6.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO6_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO6_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO6_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO6_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO6_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO6_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO6_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO6_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO6_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO6_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO6_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO6_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO6_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO6_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO6_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO6_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO6_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO6_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO6_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO6_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO6_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO7: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO7_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO7.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO7_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO7_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO7_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO7_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO7_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO7_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO7_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO7_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO7_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO7_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO7_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO7_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO7_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO7_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO7_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO7_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO7_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO7_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO7_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO7_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO7_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO8: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO8_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO8.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO8_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO8_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO8_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO8_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO8_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO8_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO8_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO8_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO8_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO8_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO8_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO8_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO8_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO8_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO8_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO8_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO8_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO8_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO8_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO8_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO8_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO9: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO9_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO9.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO9_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO9_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO9_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO9_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO9_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO9_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO9_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO9_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO9_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO9_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO9_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO9_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO9_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO9_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO9_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO9_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO9_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO9_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO9_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO9_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO9_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO10: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO10_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO10.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO10_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO10_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO10_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO10_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO10_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO10_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO10_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO10_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO10_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO10_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO10_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO10_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO10_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO10_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO10_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO10_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO10_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO10_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO10_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO10_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO10_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO11: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO11_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO11.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO11_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO11_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO11_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO11_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO11_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO11_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO11_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO11_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO11_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO11_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO11_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO11_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO11_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO11_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO11_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO11_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO11_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO11_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO11_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO11_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO11_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO12: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO12_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO12.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO12_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO12_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO12_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO12_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO12_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO12_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO12_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO12_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO12_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO12_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO12_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO12_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO12_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO12_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO12_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO12_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO12_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO12_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO12_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO12_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO12_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO13: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO13_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO13.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO13_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO13_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO13_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO13_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO13_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO13_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO13_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO13_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO13_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO13_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO13_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO13_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO13_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO13_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO13_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO13_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO13_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO13_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO13_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO13_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO13_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO14: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO14_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO14.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO14_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO14_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO14_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO14_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO14_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO14_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO14_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO14_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO14_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO14_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO14_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO14_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO14_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO14_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO14_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO14_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO14_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO14_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO14_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO14_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO14_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO15: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO15_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO15_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO15.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO15_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO15_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO15_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO15_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO15_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO15_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO15_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO15_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO15_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO15_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO15_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO15_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO15_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO15_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO15_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO15_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO15_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO15_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO15_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO15_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO15_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO15_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO15_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO15_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO15_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO15_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO16: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO16_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO16_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO16.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO16_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO16_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO16_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO16_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO16_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO16_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO16_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO16_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO16_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO16_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO16_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO16_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO16_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO16_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO16_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO16_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO16_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO16_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO16_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO16_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO16_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO16_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO16_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO16_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO16_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO16_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO17: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO17_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO17_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO17.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO17_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO17_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO17_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO17_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO17_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO17_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO17_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO17_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO17_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO17_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO17_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO17_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO17_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO17_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO17_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO17_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO17_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO17_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO17_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO17_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO17_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO17_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO17_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO17_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO17_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO17_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO18: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO18_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO18_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO18.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO18_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO18_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO18_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO18_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO18_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO18_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO18_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO18_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO18_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO18_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO18_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO18_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO18_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO18_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO18_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO18_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO18_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO18_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO18_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO18_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO18_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO18_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO18_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO18_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO18_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO18_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO19: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO19_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO19.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO19_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO19_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO19_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO19_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO19_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO19_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO19_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO19_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO19_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO19_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO19_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO19_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO19_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO19_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO19_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO19_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO19_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO19_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO19_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO19_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO19_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO20: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO20_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO20.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO20_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO20_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO20_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO20_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO20_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO20_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO20_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO20_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO20_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO20_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO20_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO20_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO20_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO20_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO20_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO20_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO20_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO20_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO20_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO20_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO20_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO21: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO21_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO21.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO21_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO21_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO21_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO21_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO21_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO21_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO21_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO21_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO21_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO21_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO21_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO21_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO21_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO21_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO21_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO21_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO21_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO21_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO21_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO21_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO21_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO22: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO22_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO22_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO22.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO22_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO22_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO22_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO22_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO22_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO22_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO22_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO22_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO22_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO22_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO22_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO22_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO22_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO22_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO22_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO22_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO22_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO22_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO22_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO22_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO22_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO22_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO22_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO22_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO22_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO22_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO23: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO23_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO23_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO23.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO23_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO23_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO23_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO23_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO23_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO23_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO23_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO23_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO23_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO23_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO23_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO23_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO23_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO23_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO23_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO23_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO23_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO23_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO23_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO23_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO23_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO23_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO23_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO23_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO23_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO23_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO24: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO24_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO24_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO24.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO24_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO24_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO24_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO24_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO24_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO24_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO24_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO24_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO24_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO24_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO24_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO24_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO24_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO24_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO24_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO24_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO24_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO24_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO24_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO24_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO24_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO24_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO24_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO24_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO24_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO24_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO25: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO25_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO25_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO25.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO25_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO25_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO25_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO25_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO25_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO25_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO25_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO25_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO25_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO25_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO25_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO25_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO25_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO25_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO25_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO25_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO25_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO25_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO25_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO25_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO25_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO25_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO25_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO25_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO25_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO25_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO26: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO26_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO26_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO26.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO26_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO26_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO26_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO26_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO26_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO26_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO26_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO26_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO26_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO26_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO26_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO26_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO26_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO26_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO26_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO26_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO26_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO26_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO26_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO26_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO26_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO26_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO26_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO26_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO26_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO26_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x20000) >> 17
}

// IO_MUX.GPIO27: IO MUX Configure Register for pad GPIO0
func (o *IO_MUX_Type) SetGPIO27_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO27_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO27.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO27_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO27_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO27_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO27_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO27_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO27_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO27_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO27_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO27_MCU_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x60)|value<<5)
}
func (o *IO_MUX_Type) GetGPIO27_MCU_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x60) >> 5
}
func (o *IO_MUX_Type) SetGPIO27_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO27_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO27_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO27_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO27_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO27_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO27_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO27_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO27_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO27_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO27_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO27_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x8000) >> 15
}
func (o *IO_MUX_Type) SetGPIO27_HYS_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x10000)|value<<16)
}
func (o *IO_MUX_Type) GetGPIO27_HYS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x10000) >> 16
}
func (o *IO_MUX_Type) SetGPIO27_HYS_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x20000)|value<<17)
}
func (o *IO_MUX_Type) GetGPIO27_HYS_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x20000) >> 17
}

// IO_MUX.MODEM_DIAG_EN: GPIO MATRIX Configure Register for modem diag
func (o *IO_MUX_Type) SetMODEM_DIAG_EN(value uint32) {
	volatile.StoreUint32(&o.MODEM_DIAG_EN.Reg, value)
}
func (o *IO_MUX_Type) GetMODEM_DIAG_EN() uint32 {
	return volatile.LoadUint32(&o.MODEM_DIAG_EN.Reg)
}

// IO_MUX.DATE: IO MUX Version Control Register
func (o *IO_MUX_Type) SetDATE_REG_DATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *IO_MUX_Type) GetDATE_REG_DATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// LED Control PWM (Pulse Width Modulation)
type LEDC_Type struct {
	CH0_CONF0         volatile.Register32 // 0x0
	CH0_HPOINT        volatile.Register32 // 0x4
	CH0_DUTY          volatile.Register32 // 0x8
	CH0_CONF1         volatile.Register32 // 0xC
	CH0_DUTY_R        volatile.Register32 // 0x10
	CH1_CONF0         volatile.Register32 // 0x14
	CH1_HPOINT        volatile.Register32 // 0x18
	CH1_DUTY          volatile.Register32 // 0x1C
	CH1_CONF1         volatile.Register32 // 0x20
	CH1_DUTY_R        volatile.Register32 // 0x24
	CH2_CONF0         volatile.Register32 // 0x28
	CH2_HPOINT        volatile.Register32 // 0x2C
	CH2_DUTY          volatile.Register32 // 0x30
	CH2_CONF1         volatile.Register32 // 0x34
	CH2_DUTY_R        volatile.Register32 // 0x38
	CH3_CONF0         volatile.Register32 // 0x3C
	CH3_HPOINT        volatile.Register32 // 0x40
	CH3_DUTY          volatile.Register32 // 0x44
	CH3_CONF1         volatile.Register32 // 0x48
	CH3_DUTY_R        volatile.Register32 // 0x4C
	CH4_CONF0         volatile.Register32 // 0x50
	CH4_HPOINT        volatile.Register32 // 0x54
	CH4_DUTY          volatile.Register32 // 0x58
	CH4_CONF1         volatile.Register32 // 0x5C
	CH4_DUTY_R        volatile.Register32 // 0x60
	CH5_CONF0         volatile.Register32 // 0x64
	CH5_HPOINT        volatile.Register32 // 0x68
	CH5_DUTY          volatile.Register32 // 0x6C
	CH5_CONF1         volatile.Register32 // 0x70
	CH5_DUTY_R        volatile.Register32 // 0x74
	_                 [40]byte
	TIMER0_CONF       volatile.Register32 // 0xA0
	TIMER0_VALUE      volatile.Register32 // 0xA4
	TIMER1_CONF       volatile.Register32 // 0xA8
	TIMER1_VALUE      volatile.Register32 // 0xAC
	TIMER2_CONF       volatile.Register32 // 0xB0
	TIMER2_VALUE      volatile.Register32 // 0xB4
	TIMER3_CONF       volatile.Register32 // 0xB8
	TIMER3_VALUE      volatile.Register32 // 0xBC
	INT_RAW           volatile.Register32 // 0xC0
	INT_ST            volatile.Register32 // 0xC4
	INT_ENA           volatile.Register32 // 0xC8
	INT_CLR           volatile.Register32 // 0xCC
	_                 [48]byte
	CH0_GAMMA_WR      volatile.Register32 // 0x100
	CH0_GAMMA_WR_ADDR volatile.Register32 // 0x104
	CH0_GAMMA_RD_ADDR volatile.Register32 // 0x108
	CH0_GAMMA_RD_DATA volatile.Register32 // 0x10C
	CH1_GAMMA_WR      volatile.Register32 // 0x110
	CH1_GAMMA_WR_ADDR volatile.Register32 // 0x114
	CH1_GAMMA_RD_ADDR volatile.Register32 // 0x118
	CH1_GAMMA_RD_DATA volatile.Register32 // 0x11C
	CH2_GAMMA_WR      volatile.Register32 // 0x120
	CH2_GAMMA_WR_ADDR volatile.Register32 // 0x124
	CH2_GAMMA_RD_ADDR volatile.Register32 // 0x128
	CH2_GAMMA_RD_DATA volatile.Register32 // 0x12C
	CH3_GAMMA_WR      volatile.Register32 // 0x130
	CH3_GAMMA_WR_ADDR volatile.Register32 // 0x134
	CH3_GAMMA_RD_ADDR volatile.Register32 // 0x138
	CH3_GAMMA_RD_DATA volatile.Register32 // 0x13C
	CH4_GAMMA_WR      volatile.Register32 // 0x140
	CH4_GAMMA_WR_ADDR volatile.Register32 // 0x144
	CH4_GAMMA_RD_ADDR volatile.Register32 // 0x148
	CH4_GAMMA_RD_DATA volatile.Register32 // 0x14C
	CH5_GAMMA_WR      volatile.Register32 // 0x150
	CH5_GAMMA_WR_ADDR volatile.Register32 // 0x154
	CH5_GAMMA_RD_ADDR volatile.Register32 // 0x158
	CH5_GAMMA_RD_DATA volatile.Register32 // 0x15C
	_                 [32]byte
	CH0_GAMMA_CONF    volatile.Register32 // 0x180
	CH1_GAMMA_CONF    volatile.Register32 // 0x184
	CH2_GAMMA_CONF    volatile.Register32 // 0x188
	CH3_GAMMA_CONF    volatile.Register32 // 0x18C
	CH4_GAMMA_CONF    volatile.Register32 // 0x190
	CH5_GAMMA_CONF    volatile.Register32 // 0x194
	_                 [8]byte
	EVT_TASK_EN0      volatile.Register32 // 0x1A0
	EVT_TASK_EN1      volatile.Register32 // 0x1A4
	EVT_TASK_EN2      volatile.Register32 // 0x1A8
	_                 [4]byte
	TIMER0_CMP        volatile.Register32 // 0x1B0
	TIMER1_CMP        volatile.Register32 // 0x1B4
	TIMER2_CMP        volatile.Register32 // 0x1B8
	TIMER3_CMP        volatile.Register32 // 0x1BC
	TIMER0_CNT_CAP    volatile.Register32 // 0x1C0
	TIMER1_CNT_CAP    volatile.Register32 // 0x1C4
	TIMER2_CNT_CAP    volatile.Register32 // 0x1C8
	TIMER3_CNT_CAP    volatile.Register32 // 0x1CC
	_                 [32]byte
	CONF              volatile.Register32 // 0x1F0
	_                 [8]byte
	DATE              volatile.Register32 // 0x1FC
}

// LEDC.CH0_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH0_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH0_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH0_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH0_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH0_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH0_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH0_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH0_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH0_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH0_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH0_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH0_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH0_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH0_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x10000) >> 16
}

// LEDC.CH0_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH0_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH0_HPOINT.Reg, volatile.LoadUint32(&o.CH0_HPOINT.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetCH0_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH0_HPOINT.Reg) & 0xfffff
}

// LEDC.CH0_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH0_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH0_DUTY.Reg, volatile.LoadUint32(&o.CH0_DUTY.Reg)&^(0x1ffffff)|value)
}
func (o *LEDC_Type) GetCH0_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH0_DUTY.Reg) & 0x1ffffff
}

// LEDC.CH0_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH0_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF1.Reg, volatile.LoadUint32(&o.CH0_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH0_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH0_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH0_DUTY_R_DUTY_CH_R(value uint32) {
	volatile.StoreUint32(&o.CH0_DUTY_R.Reg, volatile.LoadUint32(&o.CH0_DUTY_R.Reg)&^(0x1ffffff)|value)
}
func (o *LEDC_Type) GetCH0_DUTY_R_DUTY_CH_R() uint32 {
	return volatile.LoadUint32(&o.CH0_DUTY_R.Reg) & 0x1ffffff
}

// LEDC.CH1_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH1_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH1_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH1_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH1_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH1_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH1_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH1_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH1_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH1_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH1_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH1_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH1_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH1_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH1_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x10000) >> 16
}

// LEDC.CH1_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH1_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH1_HPOINT.Reg, volatile.LoadUint32(&o.CH1_HPOINT.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetCH1_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH1_HPOINT.Reg) & 0xfffff
}

// LEDC.CH1_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH1_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH1_DUTY.Reg, volatile.LoadUint32(&o.CH1_DUTY.Reg)&^(0x1ffffff)|value)
}
func (o *LEDC_Type) GetCH1_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH1_DUTY.Reg) & 0x1ffffff
}

// LEDC.CH1_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH1_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF1.Reg, volatile.LoadUint32(&o.CH1_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH1_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH1_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH1_DUTY_R_DUTY_CH_R(value uint32) {
	volatile.StoreUint32(&o.CH1_DUTY_R.Reg, volatile.LoadUint32(&o.CH1_DUTY_R.Reg)&^(0x1ffffff)|value)
}
func (o *LEDC_Type) GetCH1_DUTY_R_DUTY_CH_R() uint32 {
	return volatile.LoadUint32(&o.CH1_DUTY_R.Reg) & 0x1ffffff
}

// LEDC.CH2_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH2_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH2_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH2_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH2_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH2_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH2_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH2_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH2_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH2_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH2_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH2_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH2_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH2_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH2_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x10000) >> 16
}

// LEDC.CH2_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH2_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH2_HPOINT.Reg, volatile.LoadUint32(&o.CH2_HPOINT.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetCH2_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH2_HPOINT.Reg) & 0xfffff
}

// LEDC.CH2_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH2_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH2_DUTY.Reg, volatile.LoadUint32(&o.CH2_DUTY.Reg)&^(0x1ffffff)|value)
}
func (o *LEDC_Type) GetCH2_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH2_DUTY.Reg) & 0x1ffffff
}

// LEDC.CH2_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH2_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF1.Reg, volatile.LoadUint32(&o.CH2_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH2_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH2_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH2_DUTY_R_DUTY_CH_R(value uint32) {
	volatile.StoreUint32(&o.CH2_DUTY_R.Reg, volatile.LoadUint32(&o.CH2_DUTY_R.Reg)&^(0x1ffffff)|value)
}
func (o *LEDC_Type) GetCH2_DUTY_R_DUTY_CH_R() uint32 {
	return volatile.LoadUint32(&o.CH2_DUTY_R.Reg) & 0x1ffffff
}

// LEDC.CH3_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH3_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH3_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH3_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH3_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH3_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH3_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH3_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH3_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH3_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH3_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH3_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH3_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH3_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH3_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x10000) >> 16
}

// LEDC.CH3_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH3_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH3_HPOINT.Reg, volatile.LoadUint32(&o.CH3_HPOINT.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetCH3_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH3_HPOINT.Reg) & 0xfffff
}

// LEDC.CH3_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH3_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH3_DUTY.Reg, volatile.LoadUint32(&o.CH3_DUTY.Reg)&^(0x1ffffff)|value)
}
func (o *LEDC_Type) GetCH3_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH3_DUTY.Reg) & 0x1ffffff
}

// LEDC.CH3_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH3_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF1.Reg, volatile.LoadUint32(&o.CH3_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH3_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH3_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH3_DUTY_R_DUTY_CH_R(value uint32) {
	volatile.StoreUint32(&o.CH3_DUTY_R.Reg, volatile.LoadUint32(&o.CH3_DUTY_R.Reg)&^(0x1ffffff)|value)
}
func (o *LEDC_Type) GetCH3_DUTY_R_DUTY_CH_R() uint32 {
	return volatile.LoadUint32(&o.CH3_DUTY_R.Reg) & 0x1ffffff
}

// LEDC.CH4_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH4_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH4_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH4_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH4_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH4_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH4_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH4_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH4_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH4_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH4_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH4_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH4_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH4_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH4_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x10000) >> 16
}

// LEDC.CH4_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH4_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH4_HPOINT.Reg, volatile.LoadUint32(&o.CH4_HPOINT.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetCH4_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH4_HPOINT.Reg) & 0xfffff
}

// LEDC.CH4_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH4_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH4_DUTY.Reg, volatile.LoadUint32(&o.CH4_DUTY.Reg)&^(0x1ffffff)|value)
}
func (o *LEDC_Type) GetCH4_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH4_DUTY.Reg) & 0x1ffffff
}

// LEDC.CH4_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH4_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF1.Reg, volatile.LoadUint32(&o.CH4_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH4_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH4_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH4_DUTY_R_DUTY_CH_R(value uint32) {
	volatile.StoreUint32(&o.CH4_DUTY_R.Reg, volatile.LoadUint32(&o.CH4_DUTY_R.Reg)&^(0x1ffffff)|value)
}
func (o *LEDC_Type) GetCH4_DUTY_R_DUTY_CH_R() uint32 {
	return volatile.LoadUint32(&o.CH4_DUTY_R.Reg) & 0x1ffffff
}

// LEDC.CH5_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH5_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH5_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH5_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH5_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH5_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH5_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH5_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH5_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH5_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH5_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH5_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH5_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH5_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH5_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x10000) >> 16
}

// LEDC.CH5_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH5_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH5_HPOINT.Reg, volatile.LoadUint32(&o.CH5_HPOINT.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetCH5_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH5_HPOINT.Reg) & 0xfffff
}

// LEDC.CH5_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH5_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH5_DUTY.Reg, volatile.LoadUint32(&o.CH5_DUTY.Reg)&^(0x1ffffff)|value)
}
func (o *LEDC_Type) GetCH5_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH5_DUTY.Reg) & 0x1ffffff
}

// LEDC.CH5_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH5_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF1.Reg, volatile.LoadUint32(&o.CH5_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH5_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH5_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH5_DUTY_R_DUTY_CH_R(value uint32) {
	volatile.StoreUint32(&o.CH5_DUTY_R.Reg, volatile.LoadUint32(&o.CH5_DUTY_R.Reg)&^(0x1ffffff)|value)
}
func (o *LEDC_Type) GetCH5_DUTY_R_DUTY_CH_R() uint32 {
	return volatile.LoadUint32(&o.CH5_DUTY_R.Reg) & 0x1ffffff
}

// LEDC.TIMER0_CONF: Timer %s configuration
func (o *LEDC_Type) SetTIMER0_CONF_DUTY_RES(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x1f)|value)
}
func (o *LEDC_Type) GetTIMER0_CONF_DUTY_RES() uint32 {
	return volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x1f
}
func (o *LEDC_Type) SetTIMER0_CONF_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x7fffe0)|value<<5)
}
func (o *LEDC_Type) GetTIMER0_CONF_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x7fffe0) >> 5
}
func (o *LEDC_Type) SetTIMER0_CONF_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *LEDC_Type) GetTIMER0_CONF_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x800000) >> 23
}
func (o *LEDC_Type) SetTIMER0_CONF_RST(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetTIMER0_CONF_RST() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetTIMER0_CONF_TICK_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetTIMER0_CONF_TICK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x2000000) >> 25
}
func (o *LEDC_Type) SetTIMER0_CONF_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *LEDC_Type) GetTIMER0_CONF_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x4000000) >> 26
}

// LEDC.TIMER0_VALUE: Timer %s current counter value
func (o *LEDC_Type) SetTIMER0_VALUE_TIMER_CNT(value uint32) {
	volatile.StoreUint32(&o.TIMER0_VALUE.Reg, volatile.LoadUint32(&o.TIMER0_VALUE.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetTIMER0_VALUE_TIMER_CNT() uint32 {
	return volatile.LoadUint32(&o.TIMER0_VALUE.Reg) & 0xfffff
}

// LEDC.TIMER1_CONF: Timer %s configuration
func (o *LEDC_Type) SetTIMER1_CONF_DUTY_RES(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x1f)|value)
}
func (o *LEDC_Type) GetTIMER1_CONF_DUTY_RES() uint32 {
	return volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x1f
}
func (o *LEDC_Type) SetTIMER1_CONF_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x7fffe0)|value<<5)
}
func (o *LEDC_Type) GetTIMER1_CONF_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x7fffe0) >> 5
}
func (o *LEDC_Type) SetTIMER1_CONF_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *LEDC_Type) GetTIMER1_CONF_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x800000) >> 23
}
func (o *LEDC_Type) SetTIMER1_CONF_RST(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetTIMER1_CONF_RST() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetTIMER1_CONF_TICK_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetTIMER1_CONF_TICK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x2000000) >> 25
}
func (o *LEDC_Type) SetTIMER1_CONF_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *LEDC_Type) GetTIMER1_CONF_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x4000000) >> 26
}

// LEDC.TIMER1_VALUE: Timer %s current counter value
func (o *LEDC_Type) SetTIMER1_VALUE_TIMER_CNT(value uint32) {
	volatile.StoreUint32(&o.TIMER1_VALUE.Reg, volatile.LoadUint32(&o.TIMER1_VALUE.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetTIMER1_VALUE_TIMER_CNT() uint32 {
	return volatile.LoadUint32(&o.TIMER1_VALUE.Reg) & 0xfffff
}

// LEDC.TIMER2_CONF: Timer %s configuration
func (o *LEDC_Type) SetTIMER2_CONF_DUTY_RES(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x1f)|value)
}
func (o *LEDC_Type) GetTIMER2_CONF_DUTY_RES() uint32 {
	return volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x1f
}
func (o *LEDC_Type) SetTIMER2_CONF_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x7fffe0)|value<<5)
}
func (o *LEDC_Type) GetTIMER2_CONF_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x7fffe0) >> 5
}
func (o *LEDC_Type) SetTIMER2_CONF_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *LEDC_Type) GetTIMER2_CONF_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x800000) >> 23
}
func (o *LEDC_Type) SetTIMER2_CONF_RST(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetTIMER2_CONF_RST() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetTIMER2_CONF_TICK_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetTIMER2_CONF_TICK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x2000000) >> 25
}
func (o *LEDC_Type) SetTIMER2_CONF_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *LEDC_Type) GetTIMER2_CONF_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x4000000) >> 26
}

// LEDC.TIMER2_VALUE: Timer %s current counter value
func (o *LEDC_Type) SetTIMER2_VALUE_TIMER_CNT(value uint32) {
	volatile.StoreUint32(&o.TIMER2_VALUE.Reg, volatile.LoadUint32(&o.TIMER2_VALUE.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetTIMER2_VALUE_TIMER_CNT() uint32 {
	return volatile.LoadUint32(&o.TIMER2_VALUE.Reg) & 0xfffff
}

// LEDC.TIMER3_CONF: Timer %s configuration
func (o *LEDC_Type) SetTIMER3_CONF_DUTY_RES(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x1f)|value)
}
func (o *LEDC_Type) GetTIMER3_CONF_DUTY_RES() uint32 {
	return volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x1f
}
func (o *LEDC_Type) SetTIMER3_CONF_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x7fffe0)|value<<5)
}
func (o *LEDC_Type) GetTIMER3_CONF_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x7fffe0) >> 5
}
func (o *LEDC_Type) SetTIMER3_CONF_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *LEDC_Type) GetTIMER3_CONF_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x800000) >> 23
}
func (o *LEDC_Type) SetTIMER3_CONF_RST(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetTIMER3_CONF_RST() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetTIMER3_CONF_TICK_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetTIMER3_CONF_TICK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x2000000) >> 25
}
func (o *LEDC_Type) SetTIMER3_CONF_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *LEDC_Type) GetTIMER3_CONF_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x4000000) >> 26
}

// LEDC.TIMER3_VALUE: Timer %s current counter value
func (o *LEDC_Type) SetTIMER3_VALUE_TIMER_CNT(value uint32) {
	volatile.StoreUint32(&o.TIMER3_VALUE.Reg, volatile.LoadUint32(&o.TIMER3_VALUE.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetTIMER3_VALUE_TIMER_CNT() uint32 {
	return volatile.LoadUint32(&o.TIMER3_VALUE.Reg) & 0xfffff
}

// LEDC.INT_RAW: Raw interrupt status
func (o *LEDC_Type) SetINT_RAW_TIMER0_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetINT_RAW_TIMER0_OVF_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *LEDC_Type) SetINT_RAW_TIMER1_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetINT_RAW_TIMER1_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetINT_RAW_TIMER2_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetINT_RAW_TIMER2_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetINT_RAW_TIMER3_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetINT_RAW_TIMER3_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH0_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH3_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH3_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH4_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH4_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH5_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH5_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH0_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH3_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH3_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH4_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH4_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH5_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH5_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000) >> 17
}

// LEDC.INT_ST: Masked interrupt status
func (o *LEDC_Type) SetINT_ST_TIMER0_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetINT_ST_TIMER0_OVF_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *LEDC_Type) SetINT_ST_TIMER1_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetINT_ST_TIMER1_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetINT_ST_TIMER2_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetINT_ST_TIMER2_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetINT_ST_TIMER3_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetINT_ST_TIMER3_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH0_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH3_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH3_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH4_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH4_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH5_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH5_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH0_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000) >> 14
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH3_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH3_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH4_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH4_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH5_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH5_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000) >> 17
}

// LEDC.INT_ENA: Interrupt enable bits
func (o *LEDC_Type) SetINT_ENA_TIMER0_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetINT_ENA_TIMER0_OVF_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *LEDC_Type) SetINT_ENA_TIMER1_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetINT_ENA_TIMER1_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetINT_ENA_TIMER2_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetINT_ENA_TIMER2_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetINT_ENA_TIMER3_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetINT_ENA_TIMER3_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH3_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH3_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH4_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH4_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH5_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH5_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH3_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH3_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH4_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH4_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH5_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH5_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000) >> 17
}

// LEDC.INT_CLR: Interrupt clear bits
func (o *LEDC_Type) SetINT_CLR_TIMER0_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetINT_CLR_TIMER0_OVF_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *LEDC_Type) SetINT_CLR_TIMER1_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetINT_CLR_TIMER1_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetINT_CLR_TIMER2_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetINT_CLR_TIMER2_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetINT_CLR_TIMER3_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetINT_CLR_TIMER3_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH0_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH3_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH3_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH4_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH4_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH5_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH5_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH0_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH3_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH3_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH4_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH4_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH5_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH5_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000) >> 17
}

// LEDC.CH0_GAMMA_WR: Ledc ch%s gamma ram write register.
func (o *LEDC_Type) SetCH0_GAMMA_WR_CH_GAMMA_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH0_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH0_GAMMA_WR.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetCH0_GAMMA_WR_CH_GAMMA_DUTY_INC() uint32 {
	return volatile.LoadUint32(&o.CH0_GAMMA_WR.Reg) & 0x1
}
func (o *LEDC_Type) SetCH0_GAMMA_WR_CH_GAMMA_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH0_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH0_GAMMA_WR.Reg)&^(0x7fe)|value<<1)
}
func (o *LEDC_Type) GetCH0_GAMMA_WR_CH_GAMMA_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH0_GAMMA_WR.Reg) & 0x7fe) >> 1
}
func (o *LEDC_Type) SetCH0_GAMMA_WR_CH_GAMMA_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH0_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH0_GAMMA_WR.Reg)&^(0x1ff800)|value<<11)
}
func (o *LEDC_Type) GetCH0_GAMMA_WR_CH_GAMMA_SCALE() uint32 {
	return (volatile.LoadUint32(&o.CH0_GAMMA_WR.Reg) & 0x1ff800) >> 11
}
func (o *LEDC_Type) SetCH0_GAMMA_WR_CH_GAMMA_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH0_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH0_GAMMA_WR.Reg)&^(0x7fe00000)|value<<21)
}
func (o *LEDC_Type) GetCH0_GAMMA_WR_CH_GAMMA_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH0_GAMMA_WR.Reg) & 0x7fe00000) >> 21
}

// LEDC.CH0_GAMMA_WR_ADDR: Ledc ch%s gamma ram write address register.
func (o *LEDC_Type) SetCH0_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR(value uint32) {
	volatile.StoreUint32(&o.CH0_GAMMA_WR_ADDR.Reg, volatile.LoadUint32(&o.CH0_GAMMA_WR_ADDR.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetCH0_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR() uint32 {
	return volatile.LoadUint32(&o.CH0_GAMMA_WR_ADDR.Reg) & 0xf
}

// LEDC.CH0_GAMMA_RD_ADDR: Ledc ch%s gamma ram read address register.
func (o *LEDC_Type) SetCH0_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR(value uint32) {
	volatile.StoreUint32(&o.CH0_GAMMA_RD_ADDR.Reg, volatile.LoadUint32(&o.CH0_GAMMA_RD_ADDR.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetCH0_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR() uint32 {
	return volatile.LoadUint32(&o.CH0_GAMMA_RD_ADDR.Reg) & 0xf
}

// LEDC.CH0_GAMMA_RD_DATA: Ledc ch%s gamma ram read data register.
func (o *LEDC_Type) SetCH0_GAMMA_RD_DATA_CH_GAMMA_RD_DATA(value uint32) {
	volatile.StoreUint32(&o.CH0_GAMMA_RD_DATA.Reg, volatile.LoadUint32(&o.CH0_GAMMA_RD_DATA.Reg)&^(0x7fffffff)|value)
}
func (o *LEDC_Type) GetCH0_GAMMA_RD_DATA_CH_GAMMA_RD_DATA() uint32 {
	return volatile.LoadUint32(&o.CH0_GAMMA_RD_DATA.Reg) & 0x7fffffff
}

// LEDC.CH1_GAMMA_WR: Ledc ch%s gamma ram write register.
func (o *LEDC_Type) SetCH1_GAMMA_WR_CH_GAMMA_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH1_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH1_GAMMA_WR.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetCH1_GAMMA_WR_CH_GAMMA_DUTY_INC() uint32 {
	return volatile.LoadUint32(&o.CH1_GAMMA_WR.Reg) & 0x1
}
func (o *LEDC_Type) SetCH1_GAMMA_WR_CH_GAMMA_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH1_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH1_GAMMA_WR.Reg)&^(0x7fe)|value<<1)
}
func (o *LEDC_Type) GetCH1_GAMMA_WR_CH_GAMMA_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH1_GAMMA_WR.Reg) & 0x7fe) >> 1
}
func (o *LEDC_Type) SetCH1_GAMMA_WR_CH_GAMMA_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH1_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH1_GAMMA_WR.Reg)&^(0x1ff800)|value<<11)
}
func (o *LEDC_Type) GetCH1_GAMMA_WR_CH_GAMMA_SCALE() uint32 {
	return (volatile.LoadUint32(&o.CH1_GAMMA_WR.Reg) & 0x1ff800) >> 11
}
func (o *LEDC_Type) SetCH1_GAMMA_WR_CH_GAMMA_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH1_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH1_GAMMA_WR.Reg)&^(0x7fe00000)|value<<21)
}
func (o *LEDC_Type) GetCH1_GAMMA_WR_CH_GAMMA_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH1_GAMMA_WR.Reg) & 0x7fe00000) >> 21
}

// LEDC.CH1_GAMMA_WR_ADDR: Ledc ch%s gamma ram write address register.
func (o *LEDC_Type) SetCH1_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR(value uint32) {
	volatile.StoreUint32(&o.CH1_GAMMA_WR_ADDR.Reg, volatile.LoadUint32(&o.CH1_GAMMA_WR_ADDR.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetCH1_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR() uint32 {
	return volatile.LoadUint32(&o.CH1_GAMMA_WR_ADDR.Reg) & 0xf
}

// LEDC.CH1_GAMMA_RD_ADDR: Ledc ch%s gamma ram read address register.
func (o *LEDC_Type) SetCH1_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR(value uint32) {
	volatile.StoreUint32(&o.CH1_GAMMA_RD_ADDR.Reg, volatile.LoadUint32(&o.CH1_GAMMA_RD_ADDR.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetCH1_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR() uint32 {
	return volatile.LoadUint32(&o.CH1_GAMMA_RD_ADDR.Reg) & 0xf
}

// LEDC.CH1_GAMMA_RD_DATA: Ledc ch%s gamma ram read data register.
func (o *LEDC_Type) SetCH1_GAMMA_RD_DATA_CH_GAMMA_RD_DATA(value uint32) {
	volatile.StoreUint32(&o.CH1_GAMMA_RD_DATA.Reg, volatile.LoadUint32(&o.CH1_GAMMA_RD_DATA.Reg)&^(0x7fffffff)|value)
}
func (o *LEDC_Type) GetCH1_GAMMA_RD_DATA_CH_GAMMA_RD_DATA() uint32 {
	return volatile.LoadUint32(&o.CH1_GAMMA_RD_DATA.Reg) & 0x7fffffff
}

// LEDC.CH2_GAMMA_WR: Ledc ch%s gamma ram write register.
func (o *LEDC_Type) SetCH2_GAMMA_WR_CH_GAMMA_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH2_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH2_GAMMA_WR.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetCH2_GAMMA_WR_CH_GAMMA_DUTY_INC() uint32 {
	return volatile.LoadUint32(&o.CH2_GAMMA_WR.Reg) & 0x1
}
func (o *LEDC_Type) SetCH2_GAMMA_WR_CH_GAMMA_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH2_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH2_GAMMA_WR.Reg)&^(0x7fe)|value<<1)
}
func (o *LEDC_Type) GetCH2_GAMMA_WR_CH_GAMMA_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH2_GAMMA_WR.Reg) & 0x7fe) >> 1
}
func (o *LEDC_Type) SetCH2_GAMMA_WR_CH_GAMMA_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH2_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH2_GAMMA_WR.Reg)&^(0x1ff800)|value<<11)
}
func (o *LEDC_Type) GetCH2_GAMMA_WR_CH_GAMMA_SCALE() uint32 {
	return (volatile.LoadUint32(&o.CH2_GAMMA_WR.Reg) & 0x1ff800) >> 11
}
func (o *LEDC_Type) SetCH2_GAMMA_WR_CH_GAMMA_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH2_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH2_GAMMA_WR.Reg)&^(0x7fe00000)|value<<21)
}
func (o *LEDC_Type) GetCH2_GAMMA_WR_CH_GAMMA_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH2_GAMMA_WR.Reg) & 0x7fe00000) >> 21
}

// LEDC.CH2_GAMMA_WR_ADDR: Ledc ch%s gamma ram write address register.
func (o *LEDC_Type) SetCH2_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR(value uint32) {
	volatile.StoreUint32(&o.CH2_GAMMA_WR_ADDR.Reg, volatile.LoadUint32(&o.CH2_GAMMA_WR_ADDR.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetCH2_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR() uint32 {
	return volatile.LoadUint32(&o.CH2_GAMMA_WR_ADDR.Reg) & 0xf
}

// LEDC.CH2_GAMMA_RD_ADDR: Ledc ch%s gamma ram read address register.
func (o *LEDC_Type) SetCH2_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR(value uint32) {
	volatile.StoreUint32(&o.CH2_GAMMA_RD_ADDR.Reg, volatile.LoadUint32(&o.CH2_GAMMA_RD_ADDR.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetCH2_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR() uint32 {
	return volatile.LoadUint32(&o.CH2_GAMMA_RD_ADDR.Reg) & 0xf
}

// LEDC.CH2_GAMMA_RD_DATA: Ledc ch%s gamma ram read data register.
func (o *LEDC_Type) SetCH2_GAMMA_RD_DATA_CH_GAMMA_RD_DATA(value uint32) {
	volatile.StoreUint32(&o.CH2_GAMMA_RD_DATA.Reg, volatile.LoadUint32(&o.CH2_GAMMA_RD_DATA.Reg)&^(0x7fffffff)|value)
}
func (o *LEDC_Type) GetCH2_GAMMA_RD_DATA_CH_GAMMA_RD_DATA() uint32 {
	return volatile.LoadUint32(&o.CH2_GAMMA_RD_DATA.Reg) & 0x7fffffff
}

// LEDC.CH3_GAMMA_WR: Ledc ch%s gamma ram write register.
func (o *LEDC_Type) SetCH3_GAMMA_WR_CH_GAMMA_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH3_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH3_GAMMA_WR.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetCH3_GAMMA_WR_CH_GAMMA_DUTY_INC() uint32 {
	return volatile.LoadUint32(&o.CH3_GAMMA_WR.Reg) & 0x1
}
func (o *LEDC_Type) SetCH3_GAMMA_WR_CH_GAMMA_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH3_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH3_GAMMA_WR.Reg)&^(0x7fe)|value<<1)
}
func (o *LEDC_Type) GetCH3_GAMMA_WR_CH_GAMMA_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH3_GAMMA_WR.Reg) & 0x7fe) >> 1
}
func (o *LEDC_Type) SetCH3_GAMMA_WR_CH_GAMMA_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH3_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH3_GAMMA_WR.Reg)&^(0x1ff800)|value<<11)
}
func (o *LEDC_Type) GetCH3_GAMMA_WR_CH_GAMMA_SCALE() uint32 {
	return (volatile.LoadUint32(&o.CH3_GAMMA_WR.Reg) & 0x1ff800) >> 11
}
func (o *LEDC_Type) SetCH3_GAMMA_WR_CH_GAMMA_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH3_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH3_GAMMA_WR.Reg)&^(0x7fe00000)|value<<21)
}
func (o *LEDC_Type) GetCH3_GAMMA_WR_CH_GAMMA_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH3_GAMMA_WR.Reg) & 0x7fe00000) >> 21
}

// LEDC.CH3_GAMMA_WR_ADDR: Ledc ch%s gamma ram write address register.
func (o *LEDC_Type) SetCH3_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR(value uint32) {
	volatile.StoreUint32(&o.CH3_GAMMA_WR_ADDR.Reg, volatile.LoadUint32(&o.CH3_GAMMA_WR_ADDR.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetCH3_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR() uint32 {
	return volatile.LoadUint32(&o.CH3_GAMMA_WR_ADDR.Reg) & 0xf
}

// LEDC.CH3_GAMMA_RD_ADDR: Ledc ch%s gamma ram read address register.
func (o *LEDC_Type) SetCH3_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR(value uint32) {
	volatile.StoreUint32(&o.CH3_GAMMA_RD_ADDR.Reg, volatile.LoadUint32(&o.CH3_GAMMA_RD_ADDR.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetCH3_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR() uint32 {
	return volatile.LoadUint32(&o.CH3_GAMMA_RD_ADDR.Reg) & 0xf
}

// LEDC.CH3_GAMMA_RD_DATA: Ledc ch%s gamma ram read data register.
func (o *LEDC_Type) SetCH3_GAMMA_RD_DATA_CH_GAMMA_RD_DATA(value uint32) {
	volatile.StoreUint32(&o.CH3_GAMMA_RD_DATA.Reg, volatile.LoadUint32(&o.CH3_GAMMA_RD_DATA.Reg)&^(0x7fffffff)|value)
}
func (o *LEDC_Type) GetCH3_GAMMA_RD_DATA_CH_GAMMA_RD_DATA() uint32 {
	return volatile.LoadUint32(&o.CH3_GAMMA_RD_DATA.Reg) & 0x7fffffff
}

// LEDC.CH4_GAMMA_WR: Ledc ch%s gamma ram write register.
func (o *LEDC_Type) SetCH4_GAMMA_WR_CH_GAMMA_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH4_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH4_GAMMA_WR.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetCH4_GAMMA_WR_CH_GAMMA_DUTY_INC() uint32 {
	return volatile.LoadUint32(&o.CH4_GAMMA_WR.Reg) & 0x1
}
func (o *LEDC_Type) SetCH4_GAMMA_WR_CH_GAMMA_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH4_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH4_GAMMA_WR.Reg)&^(0x7fe)|value<<1)
}
func (o *LEDC_Type) GetCH4_GAMMA_WR_CH_GAMMA_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH4_GAMMA_WR.Reg) & 0x7fe) >> 1
}
func (o *LEDC_Type) SetCH4_GAMMA_WR_CH_GAMMA_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH4_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH4_GAMMA_WR.Reg)&^(0x1ff800)|value<<11)
}
func (o *LEDC_Type) GetCH4_GAMMA_WR_CH_GAMMA_SCALE() uint32 {
	return (volatile.LoadUint32(&o.CH4_GAMMA_WR.Reg) & 0x1ff800) >> 11
}
func (o *LEDC_Type) SetCH4_GAMMA_WR_CH_GAMMA_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH4_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH4_GAMMA_WR.Reg)&^(0x7fe00000)|value<<21)
}
func (o *LEDC_Type) GetCH4_GAMMA_WR_CH_GAMMA_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH4_GAMMA_WR.Reg) & 0x7fe00000) >> 21
}

// LEDC.CH4_GAMMA_WR_ADDR: Ledc ch%s gamma ram write address register.
func (o *LEDC_Type) SetCH4_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR(value uint32) {
	volatile.StoreUint32(&o.CH4_GAMMA_WR_ADDR.Reg, volatile.LoadUint32(&o.CH4_GAMMA_WR_ADDR.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetCH4_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR() uint32 {
	return volatile.LoadUint32(&o.CH4_GAMMA_WR_ADDR.Reg) & 0xf
}

// LEDC.CH4_GAMMA_RD_ADDR: Ledc ch%s gamma ram read address register.
func (o *LEDC_Type) SetCH4_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR(value uint32) {
	volatile.StoreUint32(&o.CH4_GAMMA_RD_ADDR.Reg, volatile.LoadUint32(&o.CH4_GAMMA_RD_ADDR.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetCH4_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR() uint32 {
	return volatile.LoadUint32(&o.CH4_GAMMA_RD_ADDR.Reg) & 0xf
}

// LEDC.CH4_GAMMA_RD_DATA: Ledc ch%s gamma ram read data register.
func (o *LEDC_Type) SetCH4_GAMMA_RD_DATA_CH_GAMMA_RD_DATA(value uint32) {
	volatile.StoreUint32(&o.CH4_GAMMA_RD_DATA.Reg, volatile.LoadUint32(&o.CH4_GAMMA_RD_DATA.Reg)&^(0x7fffffff)|value)
}
func (o *LEDC_Type) GetCH4_GAMMA_RD_DATA_CH_GAMMA_RD_DATA() uint32 {
	return volatile.LoadUint32(&o.CH4_GAMMA_RD_DATA.Reg) & 0x7fffffff
}

// LEDC.CH5_GAMMA_WR: Ledc ch%s gamma ram write register.
func (o *LEDC_Type) SetCH5_GAMMA_WR_CH_GAMMA_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH5_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH5_GAMMA_WR.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetCH5_GAMMA_WR_CH_GAMMA_DUTY_INC() uint32 {
	return volatile.LoadUint32(&o.CH5_GAMMA_WR.Reg) & 0x1
}
func (o *LEDC_Type) SetCH5_GAMMA_WR_CH_GAMMA_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH5_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH5_GAMMA_WR.Reg)&^(0x7fe)|value<<1)
}
func (o *LEDC_Type) GetCH5_GAMMA_WR_CH_GAMMA_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH5_GAMMA_WR.Reg) & 0x7fe) >> 1
}
func (o *LEDC_Type) SetCH5_GAMMA_WR_CH_GAMMA_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH5_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH5_GAMMA_WR.Reg)&^(0x1ff800)|value<<11)
}
func (o *LEDC_Type) GetCH5_GAMMA_WR_CH_GAMMA_SCALE() uint32 {
	return (volatile.LoadUint32(&o.CH5_GAMMA_WR.Reg) & 0x1ff800) >> 11
}
func (o *LEDC_Type) SetCH5_GAMMA_WR_CH_GAMMA_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH5_GAMMA_WR.Reg, volatile.LoadUint32(&o.CH5_GAMMA_WR.Reg)&^(0x7fe00000)|value<<21)
}
func (o *LEDC_Type) GetCH5_GAMMA_WR_CH_GAMMA_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH5_GAMMA_WR.Reg) & 0x7fe00000) >> 21
}

// LEDC.CH5_GAMMA_WR_ADDR: Ledc ch%s gamma ram write address register.
func (o *LEDC_Type) SetCH5_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR(value uint32) {
	volatile.StoreUint32(&o.CH5_GAMMA_WR_ADDR.Reg, volatile.LoadUint32(&o.CH5_GAMMA_WR_ADDR.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetCH5_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR() uint32 {
	return volatile.LoadUint32(&o.CH5_GAMMA_WR_ADDR.Reg) & 0xf
}

// LEDC.CH5_GAMMA_RD_ADDR: Ledc ch%s gamma ram read address register.
func (o *LEDC_Type) SetCH5_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR(value uint32) {
	volatile.StoreUint32(&o.CH5_GAMMA_RD_ADDR.Reg, volatile.LoadUint32(&o.CH5_GAMMA_RD_ADDR.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetCH5_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR() uint32 {
	return volatile.LoadUint32(&o.CH5_GAMMA_RD_ADDR.Reg) & 0xf
}

// LEDC.CH5_GAMMA_RD_DATA: Ledc ch%s gamma ram read data register.
func (o *LEDC_Type) SetCH5_GAMMA_RD_DATA_CH_GAMMA_RD_DATA(value uint32) {
	volatile.StoreUint32(&o.CH5_GAMMA_RD_DATA.Reg, volatile.LoadUint32(&o.CH5_GAMMA_RD_DATA.Reg)&^(0x7fffffff)|value)
}
func (o *LEDC_Type) GetCH5_GAMMA_RD_DATA_CH_GAMMA_RD_DATA() uint32 {
	return volatile.LoadUint32(&o.CH5_GAMMA_RD_DATA.Reg) & 0x7fffffff
}

// LEDC.CH0_GAMMA_CONF: Ledc ch%s gamma config register.
func (o *LEDC_Type) SetCH0_GAMMA_CONF_CH_GAMMA_ENTRY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH0_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH0_GAMMA_CONF.Reg)&^(0x1f)|value)
}
func (o *LEDC_Type) GetCH0_GAMMA_CONF_CH_GAMMA_ENTRY_NUM() uint32 {
	return volatile.LoadUint32(&o.CH0_GAMMA_CONF.Reg) & 0x1f
}
func (o *LEDC_Type) SetCH0_GAMMA_CONF_CH_GAMMA_PAUSE(value uint32) {
	volatile.StoreUint32(&o.CH0_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH0_GAMMA_CONF.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetCH0_GAMMA_CONF_CH_GAMMA_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.CH0_GAMMA_CONF.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetCH0_GAMMA_CONF_CH_GAMMA_RESUME(value uint32) {
	volatile.StoreUint32(&o.CH0_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH0_GAMMA_CONF.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetCH0_GAMMA_CONF_CH_GAMMA_RESUME() uint32 {
	return (volatile.LoadUint32(&o.CH0_GAMMA_CONF.Reg) & 0x40) >> 6
}

// LEDC.CH1_GAMMA_CONF: Ledc ch%s gamma config register.
func (o *LEDC_Type) SetCH1_GAMMA_CONF_CH_GAMMA_ENTRY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH1_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH1_GAMMA_CONF.Reg)&^(0x1f)|value)
}
func (o *LEDC_Type) GetCH1_GAMMA_CONF_CH_GAMMA_ENTRY_NUM() uint32 {
	return volatile.LoadUint32(&o.CH1_GAMMA_CONF.Reg) & 0x1f
}
func (o *LEDC_Type) SetCH1_GAMMA_CONF_CH_GAMMA_PAUSE(value uint32) {
	volatile.StoreUint32(&o.CH1_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH1_GAMMA_CONF.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetCH1_GAMMA_CONF_CH_GAMMA_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.CH1_GAMMA_CONF.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetCH1_GAMMA_CONF_CH_GAMMA_RESUME(value uint32) {
	volatile.StoreUint32(&o.CH1_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH1_GAMMA_CONF.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetCH1_GAMMA_CONF_CH_GAMMA_RESUME() uint32 {
	return (volatile.LoadUint32(&o.CH1_GAMMA_CONF.Reg) & 0x40) >> 6
}

// LEDC.CH2_GAMMA_CONF: Ledc ch%s gamma config register.
func (o *LEDC_Type) SetCH2_GAMMA_CONF_CH_GAMMA_ENTRY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH2_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH2_GAMMA_CONF.Reg)&^(0x1f)|value)
}
func (o *LEDC_Type) GetCH2_GAMMA_CONF_CH_GAMMA_ENTRY_NUM() uint32 {
	return volatile.LoadUint32(&o.CH2_GAMMA_CONF.Reg) & 0x1f
}
func (o *LEDC_Type) SetCH2_GAMMA_CONF_CH_GAMMA_PAUSE(value uint32) {
	volatile.StoreUint32(&o.CH2_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH2_GAMMA_CONF.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetCH2_GAMMA_CONF_CH_GAMMA_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.CH2_GAMMA_CONF.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetCH2_GAMMA_CONF_CH_GAMMA_RESUME(value uint32) {
	volatile.StoreUint32(&o.CH2_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH2_GAMMA_CONF.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetCH2_GAMMA_CONF_CH_GAMMA_RESUME() uint32 {
	return (volatile.LoadUint32(&o.CH2_GAMMA_CONF.Reg) & 0x40) >> 6
}

// LEDC.CH3_GAMMA_CONF: Ledc ch%s gamma config register.
func (o *LEDC_Type) SetCH3_GAMMA_CONF_CH_GAMMA_ENTRY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH3_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH3_GAMMA_CONF.Reg)&^(0x1f)|value)
}
func (o *LEDC_Type) GetCH3_GAMMA_CONF_CH_GAMMA_ENTRY_NUM() uint32 {
	return volatile.LoadUint32(&o.CH3_GAMMA_CONF.Reg) & 0x1f
}
func (o *LEDC_Type) SetCH3_GAMMA_CONF_CH_GAMMA_PAUSE(value uint32) {
	volatile.StoreUint32(&o.CH3_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH3_GAMMA_CONF.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetCH3_GAMMA_CONF_CH_GAMMA_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.CH3_GAMMA_CONF.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetCH3_GAMMA_CONF_CH_GAMMA_RESUME(value uint32) {
	volatile.StoreUint32(&o.CH3_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH3_GAMMA_CONF.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetCH3_GAMMA_CONF_CH_GAMMA_RESUME() uint32 {
	return (volatile.LoadUint32(&o.CH3_GAMMA_CONF.Reg) & 0x40) >> 6
}

// LEDC.CH4_GAMMA_CONF: Ledc ch%s gamma config register.
func (o *LEDC_Type) SetCH4_GAMMA_CONF_CH_GAMMA_ENTRY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH4_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH4_GAMMA_CONF.Reg)&^(0x1f)|value)
}
func (o *LEDC_Type) GetCH4_GAMMA_CONF_CH_GAMMA_ENTRY_NUM() uint32 {
	return volatile.LoadUint32(&o.CH4_GAMMA_CONF.Reg) & 0x1f
}
func (o *LEDC_Type) SetCH4_GAMMA_CONF_CH_GAMMA_PAUSE(value uint32) {
	volatile.StoreUint32(&o.CH4_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH4_GAMMA_CONF.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetCH4_GAMMA_CONF_CH_GAMMA_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.CH4_GAMMA_CONF.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetCH4_GAMMA_CONF_CH_GAMMA_RESUME(value uint32) {
	volatile.StoreUint32(&o.CH4_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH4_GAMMA_CONF.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetCH4_GAMMA_CONF_CH_GAMMA_RESUME() uint32 {
	return (volatile.LoadUint32(&o.CH4_GAMMA_CONF.Reg) & 0x40) >> 6
}

// LEDC.CH5_GAMMA_CONF: Ledc ch%s gamma config register.
func (o *LEDC_Type) SetCH5_GAMMA_CONF_CH_GAMMA_ENTRY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH5_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH5_GAMMA_CONF.Reg)&^(0x1f)|value)
}
func (o *LEDC_Type) GetCH5_GAMMA_CONF_CH_GAMMA_ENTRY_NUM() uint32 {
	return volatile.LoadUint32(&o.CH5_GAMMA_CONF.Reg) & 0x1f
}
func (o *LEDC_Type) SetCH5_GAMMA_CONF_CH_GAMMA_PAUSE(value uint32) {
	volatile.StoreUint32(&o.CH5_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH5_GAMMA_CONF.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetCH5_GAMMA_CONF_CH_GAMMA_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.CH5_GAMMA_CONF.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetCH5_GAMMA_CONF_CH_GAMMA_RESUME(value uint32) {
	volatile.StoreUint32(&o.CH5_GAMMA_CONF.Reg, volatile.LoadUint32(&o.CH5_GAMMA_CONF.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetCH5_GAMMA_CONF_CH_GAMMA_RESUME() uint32 {
	return (volatile.LoadUint32(&o.CH5_GAMMA_CONF.Reg) & 0x40) >> 6
}

// LEDC.EVT_TASK_EN0: Ledc event task enable bit register0.
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_DUTY_CHNG_END_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_DUTY_CHNG_END_CH0_EN() uint32 {
	return volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x1
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_DUTY_CHNG_END_CH1_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_DUTY_CHNG_END_CH1_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_DUTY_CHNG_END_CH2_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_DUTY_CHNG_END_CH2_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_DUTY_CHNG_END_CH3_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_DUTY_CHNG_END_CH3_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_DUTY_CHNG_END_CH4_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_DUTY_CHNG_END_CH4_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_DUTY_CHNG_END_CH5_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_DUTY_CHNG_END_CH5_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_OVF_CNT_PLS_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_OVF_CNT_PLS_CH0_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_OVF_CNT_PLS_CH1_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_OVF_CNT_PLS_CH1_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_OVF_CNT_PLS_CH2_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x400)|value<<10)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_OVF_CNT_PLS_CH2_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x400) >> 10
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_OVF_CNT_PLS_CH3_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x800)|value<<11)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_OVF_CNT_PLS_CH3_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x800) >> 11
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_OVF_CNT_PLS_CH4_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_OVF_CNT_PLS_CH4_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_OVF_CNT_PLS_CH5_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_OVF_CNT_PLS_CH5_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_TIME_OVF_TIMER0_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_TIME_OVF_TIMER0_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_TIME_OVF_TIMER1_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_TIME_OVF_TIMER1_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x20000) >> 17
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_TIME_OVF_TIMER2_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x40000)|value<<18)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_TIME_OVF_TIMER2_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x40000) >> 18
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_TIME_OVF_TIMER3_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x80000)|value<<19)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_TIME_OVF_TIMER3_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x80000) >> 19
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_TIME0_CMP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x100000)|value<<20)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_TIME0_CMP_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x100000) >> 20
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_TIME1_CMP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x200000)|value<<21)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_TIME1_CMP_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x200000) >> 21
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_TIME2_CMP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x400000)|value<<22)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_TIME2_CMP_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x400000) >> 22
}
func (o *LEDC_Type) SetEVT_TASK_EN0_EVT_TIME3_CMP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x800000)|value<<23)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_EVT_TIME3_CMP_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x800000) >> 23
}
func (o *LEDC_Type) SetEVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH0_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetEVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH1_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH1_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x2000000) >> 25
}
func (o *LEDC_Type) SetEVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH2_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x4000000)|value<<26)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH2_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x4000000) >> 26
}
func (o *LEDC_Type) SetEVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH3_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x8000000)|value<<27)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH3_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x8000000) >> 27
}
func (o *LEDC_Type) SetEVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH4_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x10000000)|value<<28)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH4_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x10000000) >> 28
}
func (o *LEDC_Type) SetEVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH5_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN0.Reg, volatile.LoadUint32(&o.EVT_TASK_EN0.Reg)&^(0x20000000)|value<<29)
}
func (o *LEDC_Type) GetEVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH5_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN0.Reg) & 0x20000000) >> 29
}

// LEDC.EVT_TASK_EN1: Ledc event task enable bit register1.
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER0_RES_UPDATE_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER0_RES_UPDATE_EN() uint32 {
	return volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x1
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER1_RES_UPDATE_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER1_RES_UPDATE_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER2_RES_UPDATE_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER2_RES_UPDATE_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER3_RES_UPDATE_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER3_RES_UPDATE_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER0_CAP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER0_CAP_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER1_CAP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER1_CAP_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER2_CAP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER2_CAP_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER3_CAP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER3_CAP_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_SIG_OUT_DIS_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_SIG_OUT_DIS_CH0_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_SIG_OUT_DIS_CH1_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_SIG_OUT_DIS_CH1_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_SIG_OUT_DIS_CH2_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x400)|value<<10)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_SIG_OUT_DIS_CH2_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x400) >> 10
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_SIG_OUT_DIS_CH3_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x800)|value<<11)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_SIG_OUT_DIS_CH3_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x800) >> 11
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_SIG_OUT_DIS_CH4_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_SIG_OUT_DIS_CH4_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_SIG_OUT_DIS_CH5_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_SIG_OUT_DIS_CH5_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_OVF_CNT_RST_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_OVF_CNT_RST_CH0_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_OVF_CNT_RST_CH1_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_OVF_CNT_RST_CH1_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x20000) >> 17
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_OVF_CNT_RST_CH2_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x40000)|value<<18)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_OVF_CNT_RST_CH2_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x40000) >> 18
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_OVF_CNT_RST_CH3_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x80000)|value<<19)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_OVF_CNT_RST_CH3_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x80000) >> 19
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_OVF_CNT_RST_CH4_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x100000)|value<<20)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_OVF_CNT_RST_CH4_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x100000) >> 20
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_OVF_CNT_RST_CH5_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x200000)|value<<21)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_OVF_CNT_RST_CH5_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x200000) >> 21
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER0_RST_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER0_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER1_RST_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER1_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x2000000) >> 25
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER2_RST_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x4000000)|value<<26)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER2_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x4000000) >> 26
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER3_RST_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x8000000)|value<<27)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER3_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x8000000) >> 27
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER0_PAUSE_RESUME_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x10000000)|value<<28)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER0_PAUSE_RESUME_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x10000000) >> 28
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER1_PAUSE_RESUME_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x20000000)|value<<29)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER1_PAUSE_RESUME_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x20000000) >> 29
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER2_PAUSE_RESUME_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER2_PAUSE_RESUME_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetEVT_TASK_EN1_TASK_TIMER3_PAUSE_RESUME_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN1.Reg, volatile.LoadUint32(&o.EVT_TASK_EN1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetEVT_TASK_EN1_TASK_TIMER3_PAUSE_RESUME_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN1.Reg) & 0x80000000) >> 31
}

// LEDC.EVT_TASK_EN2: Ledc event task enable bit register2.
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_RESTART_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_RESTART_CH0_EN() uint32 {
	return volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x1
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_RESTART_CH1_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_RESTART_CH1_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_RESTART_CH2_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_RESTART_CH2_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_RESTART_CH3_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_RESTART_CH3_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_RESTART_CH4_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_RESTART_CH4_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_RESTART_CH5_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_RESTART_CH5_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_PAUSE_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_PAUSE_CH0_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_PAUSE_CH1_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_PAUSE_CH1_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_PAUSE_CH2_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x400)|value<<10)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_PAUSE_CH2_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x400) >> 10
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_PAUSE_CH3_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x800)|value<<11)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_PAUSE_CH3_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x800) >> 11
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_PAUSE_CH4_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_PAUSE_CH4_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_PAUSE_CH5_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_PAUSE_CH5_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_RESUME_CH0_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_RESUME_CH0_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_RESUME_CH1_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_RESUME_CH1_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x20000) >> 17
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_RESUME_CH2_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x40000)|value<<18)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_RESUME_CH2_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x40000) >> 18
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_RESUME_CH3_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x80000)|value<<19)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_RESUME_CH3_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x80000) >> 19
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_RESUME_CH4_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x100000)|value<<20)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_RESUME_CH4_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x100000) >> 20
}
func (o *LEDC_Type) SetEVT_TASK_EN2_TASK_GAMMA_RESUME_CH5_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_TASK_EN2.Reg, volatile.LoadUint32(&o.EVT_TASK_EN2.Reg)&^(0x200000)|value<<21)
}
func (o *LEDC_Type) GetEVT_TASK_EN2_TASK_GAMMA_RESUME_CH5_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_TASK_EN2.Reg) & 0x200000) >> 21
}

// LEDC.TIMER0_CMP: Ledc timer%s compare value register.
func (o *LEDC_Type) SetTIMER0_CMP_TIMER_CMP(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CMP.Reg, volatile.LoadUint32(&o.TIMER0_CMP.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetTIMER0_CMP_TIMER_CMP() uint32 {
	return volatile.LoadUint32(&o.TIMER0_CMP.Reg) & 0xfffff
}

// LEDC.TIMER1_CMP: Ledc timer%s compare value register.
func (o *LEDC_Type) SetTIMER1_CMP_TIMER_CMP(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CMP.Reg, volatile.LoadUint32(&o.TIMER1_CMP.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetTIMER1_CMP_TIMER_CMP() uint32 {
	return volatile.LoadUint32(&o.TIMER1_CMP.Reg) & 0xfffff
}

// LEDC.TIMER2_CMP: Ledc timer%s compare value register.
func (o *LEDC_Type) SetTIMER2_CMP_TIMER_CMP(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CMP.Reg, volatile.LoadUint32(&o.TIMER2_CMP.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetTIMER2_CMP_TIMER_CMP() uint32 {
	return volatile.LoadUint32(&o.TIMER2_CMP.Reg) & 0xfffff
}

// LEDC.TIMER3_CMP: Ledc timer%s compare value register.
func (o *LEDC_Type) SetTIMER3_CMP_TIMER_CMP(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CMP.Reg, volatile.LoadUint32(&o.TIMER3_CMP.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetTIMER3_CMP_TIMER_CMP() uint32 {
	return volatile.LoadUint32(&o.TIMER3_CMP.Reg) & 0xfffff
}

// LEDC.TIMER0_CNT_CAP: Ledc timer%s count value capture register.
func (o *LEDC_Type) SetTIMER0_CNT_CAP_TIMER_CNT_CAP(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CNT_CAP.Reg, volatile.LoadUint32(&o.TIMER0_CNT_CAP.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetTIMER0_CNT_CAP_TIMER_CNT_CAP() uint32 {
	return volatile.LoadUint32(&o.TIMER0_CNT_CAP.Reg) & 0xfffff
}

// LEDC.TIMER1_CNT_CAP: Ledc timer%s count value capture register.
func (o *LEDC_Type) SetTIMER1_CNT_CAP_TIMER_CNT_CAP(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CNT_CAP.Reg, volatile.LoadUint32(&o.TIMER1_CNT_CAP.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetTIMER1_CNT_CAP_TIMER_CNT_CAP() uint32 {
	return volatile.LoadUint32(&o.TIMER1_CNT_CAP.Reg) & 0xfffff
}

// LEDC.TIMER2_CNT_CAP: Ledc timer%s count value capture register.
func (o *LEDC_Type) SetTIMER2_CNT_CAP_TIMER_CNT_CAP(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CNT_CAP.Reg, volatile.LoadUint32(&o.TIMER2_CNT_CAP.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetTIMER2_CNT_CAP_TIMER_CNT_CAP() uint32 {
	return volatile.LoadUint32(&o.TIMER2_CNT_CAP.Reg) & 0xfffff
}

// LEDC.TIMER3_CNT_CAP: Ledc timer%s count value capture register.
func (o *LEDC_Type) SetTIMER3_CNT_CAP_TIMER_CNT_CAP(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CNT_CAP.Reg, volatile.LoadUint32(&o.TIMER3_CNT_CAP.Reg)&^(0xfffff)|value)
}
func (o *LEDC_Type) GetTIMER3_CNT_CAP_TIMER_CNT_CAP() uint32 {
	return volatile.LoadUint32(&o.TIMER3_CNT_CAP.Reg) & 0xfffff
}

// LEDC.CONF: Global ledc configuration register
func (o *LEDC_Type) SetCONF_APB_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCONF_APB_CLK_SEL() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0x3
}
func (o *LEDC_Type) SetCONF_GAMMA_RAM_CLK_EN_CH0(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCONF_GAMMA_RAM_CLK_EN_CH0() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCONF_GAMMA_RAM_CLK_EN_CH1(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCONF_GAMMA_RAM_CLK_EN_CH1() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCONF_GAMMA_RAM_CLK_EN_CH2(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCONF_GAMMA_RAM_CLK_EN_CH2() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCONF_GAMMA_RAM_CLK_EN_CH3(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetCONF_GAMMA_RAM_CLK_EN_CH3() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetCONF_GAMMA_RAM_CLK_EN_CH4(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetCONF_GAMMA_RAM_CLK_EN_CH4() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetCONF_GAMMA_RAM_CLK_EN_CH5(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetCONF_GAMMA_RAM_CLK_EN_CH5() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetCONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x80000000) >> 31
}

// LEDC.DATE: Version control register
func (o *LEDC_Type) SetDATE_LEDC_DATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *LEDC_Type) GetDATE_LEDC_DATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// LP_PERI Peripheral
type LPPERI_Type struct {
	CLK_EN           volatile.Register32 // 0x0
	RESET_EN         volatile.Register32 // 0x4
	RNG_DATA         volatile.Register32 // 0x8
	CPU              volatile.Register32 // 0xC
	BUS_TIMEOUT      volatile.Register32 // 0x10
	BUS_TIMEOUT_ADDR volatile.Register32 // 0x14
	BUS_TIMEOUT_UID  volatile.Register32 // 0x18
	MEM_CTRL         volatile.Register32 // 0x1C
	INTERRUPT_SOURCE volatile.Register32 // 0x20
	DEBUG_SEL0       volatile.Register32 // 0x24
	DEBUG_SEL1       volatile.Register32 // 0x28
	_                [976]byte
	DATE             volatile.Register32 // 0x3FC
}

// LPPERI.CLK_EN: need_des
func (o *LPPERI_Type) SetCLK_EN_RNG_CK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x1000000)|value<<24)
}
func (o *LPPERI_Type) GetCLK_EN_RNG_CK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x1000000) >> 24
}
func (o *LPPERI_Type) SetCLK_EN_OTP_DBG_CK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x2000000)|value<<25)
}
func (o *LPPERI_Type) GetCLK_EN_OTP_DBG_CK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x2000000) >> 25
}
func (o *LPPERI_Type) SetCLK_EN_LP_UART_CK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x4000000)|value<<26)
}
func (o *LPPERI_Type) GetCLK_EN_LP_UART_CK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x4000000) >> 26
}
func (o *LPPERI_Type) SetCLK_EN_LP_IO_CK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x8000000)|value<<27)
}
func (o *LPPERI_Type) GetCLK_EN_LP_IO_CK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x8000000) >> 27
}
func (o *LPPERI_Type) SetCLK_EN_LP_EXT_I2C_CK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x10000000)|value<<28)
}
func (o *LPPERI_Type) GetCLK_EN_LP_EXT_I2C_CK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x10000000) >> 28
}
func (o *LPPERI_Type) SetCLK_EN_LP_ANA_I2C_CK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x20000000)|value<<29)
}
func (o *LPPERI_Type) GetCLK_EN_LP_ANA_I2C_CK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x20000000) >> 29
}
func (o *LPPERI_Type) SetCLK_EN_EFUSE_CK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x40000000)|value<<30)
}
func (o *LPPERI_Type) GetCLK_EN_EFUSE_CK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x40000000) >> 30
}
func (o *LPPERI_Type) SetCLK_EN_LP_CPU_CK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x80000000)|value<<31)
}
func (o *LPPERI_Type) GetCLK_EN_LP_CPU_CK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_EN.Reg) & 0x80000000) >> 31
}

// LPPERI.RESET_EN: need_des
func (o *LPPERI_Type) SetRESET_EN_BUS_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.RESET_EN.Reg, volatile.LoadUint32(&o.RESET_EN.Reg)&^(0x800000)|value<<23)
}
func (o *LPPERI_Type) GetRESET_EN_BUS_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.RESET_EN.Reg) & 0x800000) >> 23
}
func (o *LPPERI_Type) SetRESET_EN_LP_BLE_TIMER_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.RESET_EN.Reg, volatile.LoadUint32(&o.RESET_EN.Reg)&^(0x1000000)|value<<24)
}
func (o *LPPERI_Type) GetRESET_EN_LP_BLE_TIMER_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.RESET_EN.Reg) & 0x1000000) >> 24
}
func (o *LPPERI_Type) SetRESET_EN_OTP_DBG_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.RESET_EN.Reg, volatile.LoadUint32(&o.RESET_EN.Reg)&^(0x2000000)|value<<25)
}
func (o *LPPERI_Type) GetRESET_EN_OTP_DBG_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.RESET_EN.Reg) & 0x2000000) >> 25
}
func (o *LPPERI_Type) SetRESET_EN_LP_UART_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.RESET_EN.Reg, volatile.LoadUint32(&o.RESET_EN.Reg)&^(0x4000000)|value<<26)
}
func (o *LPPERI_Type) GetRESET_EN_LP_UART_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.RESET_EN.Reg) & 0x4000000) >> 26
}
func (o *LPPERI_Type) SetRESET_EN_LP_IO_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.RESET_EN.Reg, volatile.LoadUint32(&o.RESET_EN.Reg)&^(0x8000000)|value<<27)
}
func (o *LPPERI_Type) GetRESET_EN_LP_IO_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.RESET_EN.Reg) & 0x8000000) >> 27
}
func (o *LPPERI_Type) SetRESET_EN_LP_EXT_I2C_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.RESET_EN.Reg, volatile.LoadUint32(&o.RESET_EN.Reg)&^(0x10000000)|value<<28)
}
func (o *LPPERI_Type) GetRESET_EN_LP_EXT_I2C_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.RESET_EN.Reg) & 0x10000000) >> 28
}
func (o *LPPERI_Type) SetRESET_EN_LP_ANA_I2C_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.RESET_EN.Reg, volatile.LoadUint32(&o.RESET_EN.Reg)&^(0x20000000)|value<<29)
}
func (o *LPPERI_Type) GetRESET_EN_LP_ANA_I2C_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.RESET_EN.Reg) & 0x20000000) >> 29
}
func (o *LPPERI_Type) SetRESET_EN_EFUSE_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.RESET_EN.Reg, volatile.LoadUint32(&o.RESET_EN.Reg)&^(0x40000000)|value<<30)
}
func (o *LPPERI_Type) GetRESET_EN_EFUSE_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.RESET_EN.Reg) & 0x40000000) >> 30
}
func (o *LPPERI_Type) SetRESET_EN_LP_CPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.RESET_EN.Reg, volatile.LoadUint32(&o.RESET_EN.Reg)&^(0x80000000)|value<<31)
}
func (o *LPPERI_Type) GetRESET_EN_LP_CPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.RESET_EN.Reg) & 0x80000000) >> 31
}

// LPPERI.RNG_DATA: need_des
func (o *LPPERI_Type) SetRNG_DATA(value uint32) {
	volatile.StoreUint32(&o.RNG_DATA.Reg, value)
}
func (o *LPPERI_Type) GetRNG_DATA() uint32 {
	return volatile.LoadUint32(&o.RNG_DATA.Reg)
}

// LPPERI.CPU: need_des
func (o *LPPERI_Type) SetCPU_LPCORE_DBGM_UNAVALIABLE(value uint32) {
	volatile.StoreUint32(&o.CPU.Reg, volatile.LoadUint32(&o.CPU.Reg)&^(0x80000000)|value<<31)
}
func (o *LPPERI_Type) GetCPU_LPCORE_DBGM_UNAVALIABLE() uint32 {
	return (volatile.LoadUint32(&o.CPU.Reg) & 0x80000000) >> 31
}

// LPPERI.BUS_TIMEOUT: need_des
func (o *LPPERI_Type) SetBUS_TIMEOUT_LP_PERI_TIMEOUT_THRES(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMEOUT.Reg, volatile.LoadUint32(&o.BUS_TIMEOUT.Reg)&^(0x3fffc000)|value<<14)
}
func (o *LPPERI_Type) GetBUS_TIMEOUT_LP_PERI_TIMEOUT_THRES() uint32 {
	return (volatile.LoadUint32(&o.BUS_TIMEOUT.Reg) & 0x3fffc000) >> 14
}
func (o *LPPERI_Type) SetBUS_TIMEOUT_LP_PERI_TIMEOUT_INT_CLEAR(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMEOUT.Reg, volatile.LoadUint32(&o.BUS_TIMEOUT.Reg)&^(0x40000000)|value<<30)
}
func (o *LPPERI_Type) GetBUS_TIMEOUT_LP_PERI_TIMEOUT_INT_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.BUS_TIMEOUT.Reg) & 0x40000000) >> 30
}
func (o *LPPERI_Type) SetBUS_TIMEOUT_LP_PERI_TIMEOUT_PROTECT_EN(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMEOUT.Reg, volatile.LoadUint32(&o.BUS_TIMEOUT.Reg)&^(0x80000000)|value<<31)
}
func (o *LPPERI_Type) GetBUS_TIMEOUT_LP_PERI_TIMEOUT_PROTECT_EN() uint32 {
	return (volatile.LoadUint32(&o.BUS_TIMEOUT.Reg) & 0x80000000) >> 31
}

// LPPERI.BUS_TIMEOUT_ADDR: need_des
func (o *LPPERI_Type) SetBUS_TIMEOUT_ADDR(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMEOUT_ADDR.Reg, value)
}
func (o *LPPERI_Type) GetBUS_TIMEOUT_ADDR() uint32 {
	return volatile.LoadUint32(&o.BUS_TIMEOUT_ADDR.Reg)
}

// LPPERI.BUS_TIMEOUT_UID: need_des
func (o *LPPERI_Type) SetBUS_TIMEOUT_UID_LP_PERI_TIMEOUT_UID(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMEOUT_UID.Reg, volatile.LoadUint32(&o.BUS_TIMEOUT_UID.Reg)&^(0x7f)|value)
}
func (o *LPPERI_Type) GetBUS_TIMEOUT_UID_LP_PERI_TIMEOUT_UID() uint32 {
	return volatile.LoadUint32(&o.BUS_TIMEOUT_UID.Reg) & 0x7f
}

// LPPERI.MEM_CTRL: need_des
func (o *LPPERI_Type) SetMEM_CTRL_UART_WAKEUP_FLAG_CLR(value uint32) {
	volatile.StoreUint32(&o.MEM_CTRL.Reg, volatile.LoadUint32(&o.MEM_CTRL.Reg)&^(0x1)|value)
}
func (o *LPPERI_Type) GetMEM_CTRL_UART_WAKEUP_FLAG_CLR() uint32 {
	return volatile.LoadUint32(&o.MEM_CTRL.Reg) & 0x1
}
func (o *LPPERI_Type) SetMEM_CTRL_UART_WAKEUP_FLAG(value uint32) {
	volatile.StoreUint32(&o.MEM_CTRL.Reg, volatile.LoadUint32(&o.MEM_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *LPPERI_Type) GetMEM_CTRL_UART_WAKEUP_FLAG() uint32 {
	return (volatile.LoadUint32(&o.MEM_CTRL.Reg) & 0x2) >> 1
}
func (o *LPPERI_Type) SetMEM_CTRL_UART_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.MEM_CTRL.Reg, volatile.LoadUint32(&o.MEM_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *LPPERI_Type) GetMEM_CTRL_UART_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.MEM_CTRL.Reg) & 0x20000000) >> 29
}
func (o *LPPERI_Type) SetMEM_CTRL_UART_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.MEM_CTRL.Reg, volatile.LoadUint32(&o.MEM_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *LPPERI_Type) GetMEM_CTRL_UART_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.MEM_CTRL.Reg) & 0x40000000) >> 30
}
func (o *LPPERI_Type) SetMEM_CTRL_UART_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.MEM_CTRL.Reg, volatile.LoadUint32(&o.MEM_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *LPPERI_Type) GetMEM_CTRL_UART_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.MEM_CTRL.Reg) & 0x80000000) >> 31
}

// LPPERI.INTERRUPT_SOURCE: need_des
func (o *LPPERI_Type) SetINTERRUPT_SOURCE_LP_INTERRUPT_SOURCE(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT_SOURCE.Reg, volatile.LoadUint32(&o.INTERRUPT_SOURCE.Reg)&^(0x3f)|value)
}
func (o *LPPERI_Type) GetINTERRUPT_SOURCE_LP_INTERRUPT_SOURCE() uint32 {
	return volatile.LoadUint32(&o.INTERRUPT_SOURCE.Reg) & 0x3f
}

// LPPERI.DEBUG_SEL0: need des
func (o *LPPERI_Type) SetDEBUG_SEL0(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SEL0.Reg, volatile.LoadUint32(&o.DEBUG_SEL0.Reg)&^(0x7f)|value)
}
func (o *LPPERI_Type) GetDEBUG_SEL0() uint32 {
	return volatile.LoadUint32(&o.DEBUG_SEL0.Reg) & 0x7f
}
func (o *LPPERI_Type) SetDEBUG_SEL0_DEBUG_SEL1(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SEL0.Reg, volatile.LoadUint32(&o.DEBUG_SEL0.Reg)&^(0x3f80)|value<<7)
}
func (o *LPPERI_Type) GetDEBUG_SEL0_DEBUG_SEL1() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SEL0.Reg) & 0x3f80) >> 7
}
func (o *LPPERI_Type) SetDEBUG_SEL0_DEBUG_SEL2(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SEL0.Reg, volatile.LoadUint32(&o.DEBUG_SEL0.Reg)&^(0x1fc000)|value<<14)
}
func (o *LPPERI_Type) GetDEBUG_SEL0_DEBUG_SEL2() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SEL0.Reg) & 0x1fc000) >> 14
}
func (o *LPPERI_Type) SetDEBUG_SEL0_DEBUG_SEL3(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SEL0.Reg, volatile.LoadUint32(&o.DEBUG_SEL0.Reg)&^(0xfe00000)|value<<21)
}
func (o *LPPERI_Type) GetDEBUG_SEL0_DEBUG_SEL3() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SEL0.Reg) & 0xfe00000) >> 21
}

// LPPERI.DEBUG_SEL1: need des
func (o *LPPERI_Type) SetDEBUG_SEL1_DEBUG_SEL4(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SEL1.Reg, volatile.LoadUint32(&o.DEBUG_SEL1.Reg)&^(0x7f)|value)
}
func (o *LPPERI_Type) GetDEBUG_SEL1_DEBUG_SEL4() uint32 {
	return volatile.LoadUint32(&o.DEBUG_SEL1.Reg) & 0x7f
}

// LPPERI.DATE: need_des
func (o *LPPERI_Type) SetDATE_LPPERI_DATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x7fffffff)|value)
}
func (o *LPPERI_Type) GetDATE_LPPERI_DATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x7fffffff
}
func (o *LPPERI_Type) SetDATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x80000000)|value<<31)
}
func (o *LPPERI_Type) GetDATE_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.DATE.Reg) & 0x80000000) >> 31
}

// LP_ANA Peripheral
type LP_ANA_Type struct {
	BOD_MODE0_CNTL     volatile.Register32 // 0x0
	BOD_MODE1_CNTL     volatile.Register32 // 0x4
	VDD_SOURCE_CNTL    volatile.Register32 // 0x8
	VDDBAT_BOD_CNTL    volatile.Register32 // 0xC
	VDDBAT_CHARGE_CNTL volatile.Register32 // 0x10
	CK_GLITCH_CNTL     volatile.Register32 // 0x14
	PG_GLITCH_CNTL     volatile.Register32 // 0x18
	FIB_ENABLE         volatile.Register32 // 0x1C
	INT_RAW            volatile.Register32 // 0x20
	INT_ST             volatile.Register32 // 0x24
	INT_ENA            volatile.Register32 // 0x28
	INT_CLR            volatile.Register32 // 0x2C
	LP_INT_RAW         volatile.Register32 // 0x30
	LP_INT_ST          volatile.Register32 // 0x34
	LP_INT_ENA         volatile.Register32 // 0x38
	LP_INT_CLR         volatile.Register32 // 0x3C
	_                  [956]byte
	DATE               volatile.Register32 // 0x3FC
}

// LP_ANA.BOD_MODE0_CNTL: need_des
func (o *LP_ANA_Type) SetBOD_MODE0_CNTL_BOD_MODE0_CLOSE_FLASH_ENA(value uint32) {
	volatile.StoreUint32(&o.BOD_MODE0_CNTL.Reg, volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg)&^(0x40)|value<<6)
}
func (o *LP_ANA_Type) GetBOD_MODE0_CNTL_BOD_MODE0_CLOSE_FLASH_ENA() uint32 {
	return (volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg) & 0x40) >> 6
}
func (o *LP_ANA_Type) SetBOD_MODE0_CNTL_BOD_MODE0_PD_RF_ENA(value uint32) {
	volatile.StoreUint32(&o.BOD_MODE0_CNTL.Reg, volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg)&^(0x80)|value<<7)
}
func (o *LP_ANA_Type) GetBOD_MODE0_CNTL_BOD_MODE0_PD_RF_ENA() uint32 {
	return (volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg) & 0x80) >> 7
}
func (o *LP_ANA_Type) SetBOD_MODE0_CNTL_BOD_MODE0_INTR_WAIT(value uint32) {
	volatile.StoreUint32(&o.BOD_MODE0_CNTL.Reg, volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg)&^(0x3ff00)|value<<8)
}
func (o *LP_ANA_Type) GetBOD_MODE0_CNTL_BOD_MODE0_INTR_WAIT() uint32 {
	return (volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg) & 0x3ff00) >> 8
}
func (o *LP_ANA_Type) SetBOD_MODE0_CNTL_BOD_MODE0_RESET_WAIT(value uint32) {
	volatile.StoreUint32(&o.BOD_MODE0_CNTL.Reg, volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg)&^(0xffc0000)|value<<18)
}
func (o *LP_ANA_Type) GetBOD_MODE0_CNTL_BOD_MODE0_RESET_WAIT() uint32 {
	return (volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg) & 0xffc0000) >> 18
}
func (o *LP_ANA_Type) SetBOD_MODE0_CNTL_BOD_MODE0_CNT_CLR(value uint32) {
	volatile.StoreUint32(&o.BOD_MODE0_CNTL.Reg, volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg)&^(0x10000000)|value<<28)
}
func (o *LP_ANA_Type) GetBOD_MODE0_CNTL_BOD_MODE0_CNT_CLR() uint32 {
	return (volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg) & 0x10000000) >> 28
}
func (o *LP_ANA_Type) SetBOD_MODE0_CNTL_BOD_MODE0_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.BOD_MODE0_CNTL.Reg, volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg)&^(0x20000000)|value<<29)
}
func (o *LP_ANA_Type) GetBOD_MODE0_CNTL_BOD_MODE0_INTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg) & 0x20000000) >> 29
}
func (o *LP_ANA_Type) SetBOD_MODE0_CNTL_BOD_MODE0_RESET_SEL(value uint32) {
	volatile.StoreUint32(&o.BOD_MODE0_CNTL.Reg, volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_ANA_Type) GetBOD_MODE0_CNTL_BOD_MODE0_RESET_SEL() uint32 {
	return (volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg) & 0x40000000) >> 30
}
func (o *LP_ANA_Type) SetBOD_MODE0_CNTL_BOD_MODE0_RESET_ENA(value uint32) {
	volatile.StoreUint32(&o.BOD_MODE0_CNTL.Reg, volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_ANA_Type) GetBOD_MODE0_CNTL_BOD_MODE0_RESET_ENA() uint32 {
	return (volatile.LoadUint32(&o.BOD_MODE0_CNTL.Reg) & 0x80000000) >> 31
}

// LP_ANA.BOD_MODE1_CNTL: need_des
func (o *LP_ANA_Type) SetBOD_MODE1_CNTL_BOD_MODE1_RESET_ENA(value uint32) {
	volatile.StoreUint32(&o.BOD_MODE1_CNTL.Reg, volatile.LoadUint32(&o.BOD_MODE1_CNTL.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_ANA_Type) GetBOD_MODE1_CNTL_BOD_MODE1_RESET_ENA() uint32 {
	return (volatile.LoadUint32(&o.BOD_MODE1_CNTL.Reg) & 0x80000000) >> 31
}

// LP_ANA.VDD_SOURCE_CNTL: need_des
func (o *LP_ANA_Type) SetVDD_SOURCE_CNTL_DETMODE_SEL(value uint32) {
	volatile.StoreUint32(&o.VDD_SOURCE_CNTL.Reg, volatile.LoadUint32(&o.VDD_SOURCE_CNTL.Reg)&^(0xff)|value)
}
func (o *LP_ANA_Type) GetVDD_SOURCE_CNTL_DETMODE_SEL() uint32 {
	return volatile.LoadUint32(&o.VDD_SOURCE_CNTL.Reg) & 0xff
}
func (o *LP_ANA_Type) SetVDD_SOURCE_CNTL_VGOOD_EVENT_RECORD(value uint32) {
	volatile.StoreUint32(&o.VDD_SOURCE_CNTL.Reg, volatile.LoadUint32(&o.VDD_SOURCE_CNTL.Reg)&^(0xff00)|value<<8)
}
func (o *LP_ANA_Type) GetVDD_SOURCE_CNTL_VGOOD_EVENT_RECORD() uint32 {
	return (volatile.LoadUint32(&o.VDD_SOURCE_CNTL.Reg) & 0xff00) >> 8
}
func (o *LP_ANA_Type) SetVDD_SOURCE_CNTL_VBAT_EVENT_RECORD_CLR(value uint32) {
	volatile.StoreUint32(&o.VDD_SOURCE_CNTL.Reg, volatile.LoadUint32(&o.VDD_SOURCE_CNTL.Reg)&^(0xff0000)|value<<16)
}
func (o *LP_ANA_Type) GetVDD_SOURCE_CNTL_VBAT_EVENT_RECORD_CLR() uint32 {
	return (volatile.LoadUint32(&o.VDD_SOURCE_CNTL.Reg) & 0xff0000) >> 16
}
func (o *LP_ANA_Type) SetVDD_SOURCE_CNTL_BOD_SOURCE_ENA(value uint32) {
	volatile.StoreUint32(&o.VDD_SOURCE_CNTL.Reg, volatile.LoadUint32(&o.VDD_SOURCE_CNTL.Reg)&^(0xff000000)|value<<24)
}
func (o *LP_ANA_Type) GetVDD_SOURCE_CNTL_BOD_SOURCE_ENA() uint32 {
	return (volatile.LoadUint32(&o.VDD_SOURCE_CNTL.Reg) & 0xff000000) >> 24
}

// LP_ANA.VDDBAT_BOD_CNTL: need_des
func (o *LP_ANA_Type) SetVDDBAT_BOD_CNTL_VDDBAT_UNDERVOLTAGE_FLAG(value uint32) {
	volatile.StoreUint32(&o.VDDBAT_BOD_CNTL.Reg, volatile.LoadUint32(&o.VDDBAT_BOD_CNTL.Reg)&^(0x1)|value)
}
func (o *LP_ANA_Type) GetVDDBAT_BOD_CNTL_VDDBAT_UNDERVOLTAGE_FLAG() uint32 {
	return volatile.LoadUint32(&o.VDDBAT_BOD_CNTL.Reg) & 0x1
}
func (o *LP_ANA_Type) SetVDDBAT_BOD_CNTL_VDDBAT_CHARGER(value uint32) {
	volatile.StoreUint32(&o.VDDBAT_BOD_CNTL.Reg, volatile.LoadUint32(&o.VDDBAT_BOD_CNTL.Reg)&^(0x400)|value<<10)
}
func (o *LP_ANA_Type) GetVDDBAT_BOD_CNTL_VDDBAT_CHARGER() uint32 {
	return (volatile.LoadUint32(&o.VDDBAT_BOD_CNTL.Reg) & 0x400) >> 10
}
func (o *LP_ANA_Type) SetVDDBAT_BOD_CNTL_VDDBAT_CNT_CLR(value uint32) {
	volatile.StoreUint32(&o.VDDBAT_BOD_CNTL.Reg, volatile.LoadUint32(&o.VDDBAT_BOD_CNTL.Reg)&^(0x800)|value<<11)
}
func (o *LP_ANA_Type) GetVDDBAT_BOD_CNTL_VDDBAT_CNT_CLR() uint32 {
	return (volatile.LoadUint32(&o.VDDBAT_BOD_CNTL.Reg) & 0x800) >> 11
}
func (o *LP_ANA_Type) SetVDDBAT_BOD_CNTL_VDDBAT_UPVOLTAGE_TARGET(value uint32) {
	volatile.StoreUint32(&o.VDDBAT_BOD_CNTL.Reg, volatile.LoadUint32(&o.VDDBAT_BOD_CNTL.Reg)&^(0x3ff000)|value<<12)
}
func (o *LP_ANA_Type) GetVDDBAT_BOD_CNTL_VDDBAT_UPVOLTAGE_TARGET() uint32 {
	return (volatile.LoadUint32(&o.VDDBAT_BOD_CNTL.Reg) & 0x3ff000) >> 12
}
func (o *LP_ANA_Type) SetVDDBAT_BOD_CNTL_VDDBAT_UNDERVOLTAGE_TARGET(value uint32) {
	volatile.StoreUint32(&o.VDDBAT_BOD_CNTL.Reg, volatile.LoadUint32(&o.VDDBAT_BOD_CNTL.Reg)&^(0xffc00000)|value<<22)
}
func (o *LP_ANA_Type) GetVDDBAT_BOD_CNTL_VDDBAT_UNDERVOLTAGE_TARGET() uint32 {
	return (volatile.LoadUint32(&o.VDDBAT_BOD_CNTL.Reg) & 0xffc00000) >> 22
}

// LP_ANA.VDDBAT_CHARGE_CNTL: need_des
func (o *LP_ANA_Type) SetVDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_UNDERVOLTAGE_FLAG(value uint32) {
	volatile.StoreUint32(&o.VDDBAT_CHARGE_CNTL.Reg, volatile.LoadUint32(&o.VDDBAT_CHARGE_CNTL.Reg)&^(0x1)|value)
}
func (o *LP_ANA_Type) GetVDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_UNDERVOLTAGE_FLAG() uint32 {
	return volatile.LoadUint32(&o.VDDBAT_CHARGE_CNTL.Reg) & 0x1
}
func (o *LP_ANA_Type) SetVDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_CHARGER(value uint32) {
	volatile.StoreUint32(&o.VDDBAT_CHARGE_CNTL.Reg, volatile.LoadUint32(&o.VDDBAT_CHARGE_CNTL.Reg)&^(0x400)|value<<10)
}
func (o *LP_ANA_Type) GetVDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_CHARGER() uint32 {
	return (volatile.LoadUint32(&o.VDDBAT_CHARGE_CNTL.Reg) & 0x400) >> 10
}
func (o *LP_ANA_Type) SetVDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_CNT_CLR(value uint32) {
	volatile.StoreUint32(&o.VDDBAT_CHARGE_CNTL.Reg, volatile.LoadUint32(&o.VDDBAT_CHARGE_CNTL.Reg)&^(0x800)|value<<11)
}
func (o *LP_ANA_Type) GetVDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_CNT_CLR() uint32 {
	return (volatile.LoadUint32(&o.VDDBAT_CHARGE_CNTL.Reg) & 0x800) >> 11
}
func (o *LP_ANA_Type) SetVDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_UPVOLTAGE_TARGET(value uint32) {
	volatile.StoreUint32(&o.VDDBAT_CHARGE_CNTL.Reg, volatile.LoadUint32(&o.VDDBAT_CHARGE_CNTL.Reg)&^(0x3ff000)|value<<12)
}
func (o *LP_ANA_Type) GetVDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_UPVOLTAGE_TARGET() uint32 {
	return (volatile.LoadUint32(&o.VDDBAT_CHARGE_CNTL.Reg) & 0x3ff000) >> 12
}
func (o *LP_ANA_Type) SetVDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_UNDERVOLTAGE_TARGET(value uint32) {
	volatile.StoreUint32(&o.VDDBAT_CHARGE_CNTL.Reg, volatile.LoadUint32(&o.VDDBAT_CHARGE_CNTL.Reg)&^(0xffc00000)|value<<22)
}
func (o *LP_ANA_Type) GetVDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_UNDERVOLTAGE_TARGET() uint32 {
	return (volatile.LoadUint32(&o.VDDBAT_CHARGE_CNTL.Reg) & 0xffc00000) >> 22
}

// LP_ANA.CK_GLITCH_CNTL: need_des
func (o *LP_ANA_Type) SetCK_GLITCH_CNTL_CK_GLITCH_RESET_ENA(value uint32) {
	volatile.StoreUint32(&o.CK_GLITCH_CNTL.Reg, volatile.LoadUint32(&o.CK_GLITCH_CNTL.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_ANA_Type) GetCK_GLITCH_CNTL_CK_GLITCH_RESET_ENA() uint32 {
	return (volatile.LoadUint32(&o.CK_GLITCH_CNTL.Reg) & 0x80000000) >> 31
}

// LP_ANA.PG_GLITCH_CNTL: need_des
func (o *LP_ANA_Type) SetPG_GLITCH_CNTL_POWER_GLITCH_RESET_ENA(value uint32) {
	volatile.StoreUint32(&o.PG_GLITCH_CNTL.Reg, volatile.LoadUint32(&o.PG_GLITCH_CNTL.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_ANA_Type) GetPG_GLITCH_CNTL_POWER_GLITCH_RESET_ENA() uint32 {
	return (volatile.LoadUint32(&o.PG_GLITCH_CNTL.Reg) & 0x80000000) >> 31
}

// LP_ANA.FIB_ENABLE: need_des
func (o *LP_ANA_Type) SetFIB_ENABLE(value uint32) {
	volatile.StoreUint32(&o.FIB_ENABLE.Reg, value)
}
func (o *LP_ANA_Type) GetFIB_ENABLE() uint32 {
	return volatile.LoadUint32(&o.FIB_ENABLE.Reg)
}

// LP_ANA.INT_RAW: need_des
func (o *LP_ANA_Type) SetINT_RAW_VDDBAT_CHARGE_UPVOLTAGE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000000)|value<<27)
}
func (o *LP_ANA_Type) GetINT_RAW_VDDBAT_CHARGE_UPVOLTAGE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000000) >> 27
}
func (o *LP_ANA_Type) SetINT_RAW_VDDBAT_CHARGE_UNDERVOLTAGE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000000)|value<<28)
}
func (o *LP_ANA_Type) GetINT_RAW_VDDBAT_CHARGE_UNDERVOLTAGE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000000) >> 28
}
func (o *LP_ANA_Type) SetINT_RAW_VDDBAT_UPVOLTAGE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000000)|value<<29)
}
func (o *LP_ANA_Type) GetINT_RAW_VDDBAT_UPVOLTAGE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000000) >> 29
}
func (o *LP_ANA_Type) SetINT_RAW_VDDBAT_UNDERVOLTAGE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_ANA_Type) GetINT_RAW_VDDBAT_UNDERVOLTAGE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000000) >> 30
}
func (o *LP_ANA_Type) SetINT_RAW_BOD_MODE0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_ANA_Type) GetINT_RAW_BOD_MODE0_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000000) >> 31
}

// LP_ANA.INT_ST: need_des
func (o *LP_ANA_Type) SetINT_ST_VDDBAT_CHARGE_UPVOLTAGE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000000)|value<<27)
}
func (o *LP_ANA_Type) GetINT_ST_VDDBAT_CHARGE_UPVOLTAGE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000000) >> 27
}
func (o *LP_ANA_Type) SetINT_ST_VDDBAT_CHARGE_UNDERVOLTAGE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000000)|value<<28)
}
func (o *LP_ANA_Type) GetINT_ST_VDDBAT_CHARGE_UNDERVOLTAGE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000000) >> 28
}
func (o *LP_ANA_Type) SetINT_ST_VDDBAT_UPVOLTAGE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000000)|value<<29)
}
func (o *LP_ANA_Type) GetINT_ST_VDDBAT_UPVOLTAGE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000000) >> 29
}
func (o *LP_ANA_Type) SetINT_ST_VDDBAT_UNDERVOLTAGE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_ANA_Type) GetINT_ST_VDDBAT_UNDERVOLTAGE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40000000) >> 30
}
func (o *LP_ANA_Type) SetINT_ST_BOD_MODE0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_ANA_Type) GetINT_ST_BOD_MODE0_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80000000) >> 31
}

// LP_ANA.INT_ENA: need_des
func (o *LP_ANA_Type) SetINT_ENA_VDDBAT_CHARGE_UPVOLTAGE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000000)|value<<27)
}
func (o *LP_ANA_Type) GetINT_ENA_VDDBAT_CHARGE_UPVOLTAGE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000000) >> 27
}
func (o *LP_ANA_Type) SetINT_ENA_VDDBAT_CHARGE_UNDERVOLTAGE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000000)|value<<28)
}
func (o *LP_ANA_Type) GetINT_ENA_VDDBAT_CHARGE_UNDERVOLTAGE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000000) >> 28
}
func (o *LP_ANA_Type) SetINT_ENA_VDDBAT_UPVOLTAGE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000000)|value<<29)
}
func (o *LP_ANA_Type) GetINT_ENA_VDDBAT_UPVOLTAGE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000000) >> 29
}
func (o *LP_ANA_Type) SetINT_ENA_VDDBAT_UNDERVOLTAGE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_ANA_Type) GetINT_ENA_VDDBAT_UNDERVOLTAGE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40000000) >> 30
}
func (o *LP_ANA_Type) SetINT_ENA_BOD_MODE0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_ANA_Type) GetINT_ENA_BOD_MODE0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80000000) >> 31
}

// LP_ANA.INT_CLR: need_des
func (o *LP_ANA_Type) SetINT_CLR_VDDBAT_CHARGE_UPVOLTAGE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000000)|value<<27)
}
func (o *LP_ANA_Type) GetINT_CLR_VDDBAT_CHARGE_UPVOLTAGE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000000) >> 27
}
func (o *LP_ANA_Type) SetINT_CLR_VDDBAT_CHARGE_UNDERVOLTAGE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *LP_ANA_Type) GetINT_CLR_VDDBAT_CHARGE_UNDERVOLTAGE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000000) >> 28
}
func (o *LP_ANA_Type) SetINT_CLR_VDDBAT_UPVOLTAGE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *LP_ANA_Type) GetINT_CLR_VDDBAT_UPVOLTAGE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000000) >> 29
}
func (o *LP_ANA_Type) SetINT_CLR_VDDBAT_UNDERVOLTAGE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_ANA_Type) GetINT_CLR_VDDBAT_UNDERVOLTAGE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40000000) >> 30
}
func (o *LP_ANA_Type) SetINT_CLR_BOD_MODE0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_ANA_Type) GetINT_CLR_BOD_MODE0_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80000000) >> 31
}

// LP_ANA.LP_INT_RAW: need_des
func (o *LP_ANA_Type) SetLP_INT_RAW_BOD_MODE0_LP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.LP_INT_RAW.Reg, volatile.LoadUint32(&o.LP_INT_RAW.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_ANA_Type) GetLP_INT_RAW_BOD_MODE0_LP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_RAW.Reg) & 0x80000000) >> 31
}

// LP_ANA.LP_INT_ST: need_des
func (o *LP_ANA_Type) SetLP_INT_ST_BOD_MODE0_LP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ST.Reg, volatile.LoadUint32(&o.LP_INT_ST.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_ANA_Type) GetLP_INT_ST_BOD_MODE0_LP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ST.Reg) & 0x80000000) >> 31
}

// LP_ANA.LP_INT_ENA: need_des
func (o *LP_ANA_Type) SetLP_INT_ENA_BOD_MODE0_LP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ENA.Reg, volatile.LoadUint32(&o.LP_INT_ENA.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_ANA_Type) GetLP_INT_ENA_BOD_MODE0_LP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ENA.Reg) & 0x80000000) >> 31
}

// LP_ANA.LP_INT_CLR: need_des
func (o *LP_ANA_Type) SetLP_INT_CLR_BOD_MODE0_LP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.LP_INT_CLR.Reg, volatile.LoadUint32(&o.LP_INT_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_ANA_Type) GetLP_INT_CLR_BOD_MODE0_LP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_CLR.Reg) & 0x80000000) >> 31
}

// LP_ANA.DATE: need_des
func (o *LP_ANA_Type) SetDATE_LP_ANA_DATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x7fffffff)|value)
}
func (o *LP_ANA_Type) GetDATE_LP_ANA_DATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x7fffffff
}
func (o *LP_ANA_Type) SetDATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_ANA_Type) GetDATE_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.DATE.Reg) & 0x80000000) >> 31
}

// LP_AON Peripheral
type LP_AON_Type struct {
	STORE0          volatile.Register32 // 0x0
	STORE1          volatile.Register32 // 0x4
	STORE2          volatile.Register32 // 0x8
	STORE3          volatile.Register32 // 0xC
	STORE4          volatile.Register32 // 0x10
	STORE5          volatile.Register32 // 0x14
	STORE6          volatile.Register32 // 0x18
	STORE7          volatile.Register32 // 0x1C
	STORE8          volatile.Register32 // 0x20
	STORE9          volatile.Register32 // 0x24
	GPIO_MUX        volatile.Register32 // 0x28
	GPIO_HOLD0      volatile.Register32 // 0x2C
	GPIO_HOLD1      volatile.Register32 // 0x30
	SYS_CFG         volatile.Register32 // 0x34
	CPUCORE0_CFG    volatile.Register32 // 0x38
	IO_MUX          volatile.Register32 // 0x3C
	EXT_WAKEUP_CNTL volatile.Register32 // 0x40
	USB             volatile.Register32 // 0x44
	LPBUS           volatile.Register32 // 0x48
	SDIO_ACTIVE     volatile.Register32 // 0x4C
	LPCORE          volatile.Register32 // 0x50
	SAR_CCT         volatile.Register32 // 0x54
	JTAG_SEL        volatile.Register32 // 0x58
	_               [928]byte
	DATE            volatile.Register32 // 0x3FC
}

// LP_AON.STORE0: need_des
func (o *LP_AON_Type) SetSTORE0(value uint32) {
	volatile.StoreUint32(&o.STORE0.Reg, value)
}
func (o *LP_AON_Type) GetSTORE0() uint32 {
	return volatile.LoadUint32(&o.STORE0.Reg)
}

// LP_AON.STORE1: need_des
func (o *LP_AON_Type) SetSTORE1(value uint32) {
	volatile.StoreUint32(&o.STORE1.Reg, value)
}
func (o *LP_AON_Type) GetSTORE1() uint32 {
	return volatile.LoadUint32(&o.STORE1.Reg)
}

// LP_AON.STORE2: need_des
func (o *LP_AON_Type) SetSTORE2(value uint32) {
	volatile.StoreUint32(&o.STORE2.Reg, value)
}
func (o *LP_AON_Type) GetSTORE2() uint32 {
	return volatile.LoadUint32(&o.STORE2.Reg)
}

// LP_AON.STORE3: need_des
func (o *LP_AON_Type) SetSTORE3(value uint32) {
	volatile.StoreUint32(&o.STORE3.Reg, value)
}
func (o *LP_AON_Type) GetSTORE3() uint32 {
	return volatile.LoadUint32(&o.STORE3.Reg)
}

// LP_AON.STORE4: need_des
func (o *LP_AON_Type) SetSTORE4(value uint32) {
	volatile.StoreUint32(&o.STORE4.Reg, value)
}
func (o *LP_AON_Type) GetSTORE4() uint32 {
	return volatile.LoadUint32(&o.STORE4.Reg)
}

// LP_AON.STORE5: need_des
func (o *LP_AON_Type) SetSTORE5(value uint32) {
	volatile.StoreUint32(&o.STORE5.Reg, value)
}
func (o *LP_AON_Type) GetSTORE5() uint32 {
	return volatile.LoadUint32(&o.STORE5.Reg)
}

// LP_AON.STORE6: need_des
func (o *LP_AON_Type) SetSTORE6(value uint32) {
	volatile.StoreUint32(&o.STORE6.Reg, value)
}
func (o *LP_AON_Type) GetSTORE6() uint32 {
	return volatile.LoadUint32(&o.STORE6.Reg)
}

// LP_AON.STORE7: need_des
func (o *LP_AON_Type) SetSTORE7(value uint32) {
	volatile.StoreUint32(&o.STORE7.Reg, value)
}
func (o *LP_AON_Type) GetSTORE7() uint32 {
	return volatile.LoadUint32(&o.STORE7.Reg)
}

// LP_AON.STORE8: need_des
func (o *LP_AON_Type) SetSTORE8(value uint32) {
	volatile.StoreUint32(&o.STORE8.Reg, value)
}
func (o *LP_AON_Type) GetSTORE8() uint32 {
	return volatile.LoadUint32(&o.STORE8.Reg)
}

// LP_AON.STORE9: need_des
func (o *LP_AON_Type) SetSTORE9(value uint32) {
	volatile.StoreUint32(&o.STORE9.Reg, value)
}
func (o *LP_AON_Type) GetSTORE9() uint32 {
	return volatile.LoadUint32(&o.STORE9.Reg)
}

// LP_AON.GPIO_MUX: need_des
func (o *LP_AON_Type) SetGPIO_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_MUX.Reg, volatile.LoadUint32(&o.GPIO_MUX.Reg)&^(0xff)|value)
}
func (o *LP_AON_Type) GetGPIO_MUX_SEL() uint32 {
	return volatile.LoadUint32(&o.GPIO_MUX.Reg) & 0xff
}

// LP_AON.GPIO_HOLD0: need_des
func (o *LP_AON_Type) SetGPIO_HOLD0(value uint32) {
	volatile.StoreUint32(&o.GPIO_HOLD0.Reg, value)
}
func (o *LP_AON_Type) GetGPIO_HOLD0() uint32 {
	return volatile.LoadUint32(&o.GPIO_HOLD0.Reg)
}

// LP_AON.GPIO_HOLD1: need_des
func (o *LP_AON_Type) SetGPIO_HOLD1(value uint32) {
	volatile.StoreUint32(&o.GPIO_HOLD1.Reg, value)
}
func (o *LP_AON_Type) GetGPIO_HOLD1() uint32 {
	return volatile.LoadUint32(&o.GPIO_HOLD1.Reg)
}

// LP_AON.SYS_CFG: need_des
func (o *LP_AON_Type) SetSYS_CFG_ANA_FIB_SWD_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYS_CFG.Reg, volatile.LoadUint32(&o.SYS_CFG.Reg)&^(0x1)|value)
}
func (o *LP_AON_Type) GetSYS_CFG_ANA_FIB_SWD_ENABLE() uint32 {
	return volatile.LoadUint32(&o.SYS_CFG.Reg) & 0x1
}
func (o *LP_AON_Type) SetSYS_CFG_ANA_FIB_CK_GLITCH_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYS_CFG.Reg, volatile.LoadUint32(&o.SYS_CFG.Reg)&^(0x2)|value<<1)
}
func (o *LP_AON_Type) GetSYS_CFG_ANA_FIB_CK_GLITCH_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYS_CFG.Reg) & 0x2) >> 1
}
func (o *LP_AON_Type) SetSYS_CFG_ANA_FIB_BOD_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYS_CFG.Reg, volatile.LoadUint32(&o.SYS_CFG.Reg)&^(0x4)|value<<2)
}
func (o *LP_AON_Type) GetSYS_CFG_ANA_FIB_BOD_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYS_CFG.Reg) & 0x4) >> 2
}
func (o *LP_AON_Type) SetSYS_CFG_FORCE_DOWNLOAD_BOOT(value uint32) {
	volatile.StoreUint32(&o.SYS_CFG.Reg, volatile.LoadUint32(&o.SYS_CFG.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_AON_Type) GetSYS_CFG_FORCE_DOWNLOAD_BOOT() uint32 {
	return (volatile.LoadUint32(&o.SYS_CFG.Reg) & 0x40000000) >> 30
}
func (o *LP_AON_Type) SetSYS_CFG_HPSYS_SW_RESET(value uint32) {
	volatile.StoreUint32(&o.SYS_CFG.Reg, volatile.LoadUint32(&o.SYS_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_AON_Type) GetSYS_CFG_HPSYS_SW_RESET() uint32 {
	return (volatile.LoadUint32(&o.SYS_CFG.Reg) & 0x80000000) >> 31
}

// LP_AON.CPUCORE0_CFG: need_des
func (o *LP_AON_Type) SetCPUCORE0_CFG_CPU_CORE0_SW_STALL(value uint32) {
	volatile.StoreUint32(&o.CPUCORE0_CFG.Reg, volatile.LoadUint32(&o.CPUCORE0_CFG.Reg)&^(0xff)|value)
}
func (o *LP_AON_Type) GetCPUCORE0_CFG_CPU_CORE0_SW_STALL() uint32 {
	return volatile.LoadUint32(&o.CPUCORE0_CFG.Reg) & 0xff
}
func (o *LP_AON_Type) SetCPUCORE0_CFG_CPU_CORE0_SW_RESET(value uint32) {
	volatile.StoreUint32(&o.CPUCORE0_CFG.Reg, volatile.LoadUint32(&o.CPUCORE0_CFG.Reg)&^(0x10000000)|value<<28)
}
func (o *LP_AON_Type) GetCPUCORE0_CFG_CPU_CORE0_SW_RESET() uint32 {
	return (volatile.LoadUint32(&o.CPUCORE0_CFG.Reg) & 0x10000000) >> 28
}
func (o *LP_AON_Type) SetCPUCORE0_CFG_CPU_CORE0_OCD_HALT_ON_RESET(value uint32) {
	volatile.StoreUint32(&o.CPUCORE0_CFG.Reg, volatile.LoadUint32(&o.CPUCORE0_CFG.Reg)&^(0x20000000)|value<<29)
}
func (o *LP_AON_Type) GetCPUCORE0_CFG_CPU_CORE0_OCD_HALT_ON_RESET() uint32 {
	return (volatile.LoadUint32(&o.CPUCORE0_CFG.Reg) & 0x20000000) >> 29
}
func (o *LP_AON_Type) SetCPUCORE0_CFG_CPU_CORE0_STAT_VECTOR_SEL(value uint32) {
	volatile.StoreUint32(&o.CPUCORE0_CFG.Reg, volatile.LoadUint32(&o.CPUCORE0_CFG.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_AON_Type) GetCPUCORE0_CFG_CPU_CORE0_STAT_VECTOR_SEL() uint32 {
	return (volatile.LoadUint32(&o.CPUCORE0_CFG.Reg) & 0x40000000) >> 30
}
func (o *LP_AON_Type) SetCPUCORE0_CFG_CPU_CORE0_DRESET_MASK(value uint32) {
	volatile.StoreUint32(&o.CPUCORE0_CFG.Reg, volatile.LoadUint32(&o.CPUCORE0_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_AON_Type) GetCPUCORE0_CFG_CPU_CORE0_DRESET_MASK() uint32 {
	return (volatile.LoadUint32(&o.CPUCORE0_CFG.Reg) & 0x80000000) >> 31
}

// LP_AON.IO_MUX: need_des
func (o *LP_AON_Type) SetIO_MUX_PULL_LDO(value uint32) {
	volatile.StoreUint32(&o.IO_MUX.Reg, volatile.LoadUint32(&o.IO_MUX.Reg)&^(0x70000000)|value<<28)
}
func (o *LP_AON_Type) GetIO_MUX_PULL_LDO() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX.Reg) & 0x70000000) >> 28
}
func (o *LP_AON_Type) SetIO_MUX_RESET_DISABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX.Reg, volatile.LoadUint32(&o.IO_MUX.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_AON_Type) GetIO_MUX_RESET_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX.Reg) & 0x80000000) >> 31
}

// LP_AON.EXT_WAKEUP_CNTL: need_des
func (o *LP_AON_Type) SetEXT_WAKEUP_CNTL_EXT_WAKEUP_STATUS(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP_CNTL.Reg, volatile.LoadUint32(&o.EXT_WAKEUP_CNTL.Reg)&^(0xff)|value)
}
func (o *LP_AON_Type) GetEXT_WAKEUP_CNTL_EXT_WAKEUP_STATUS() uint32 {
	return volatile.LoadUint32(&o.EXT_WAKEUP_CNTL.Reg) & 0xff
}
func (o *LP_AON_Type) SetEXT_WAKEUP_CNTL_EXT_WAKEUP_STATUS_CLR(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP_CNTL.Reg, volatile.LoadUint32(&o.EXT_WAKEUP_CNTL.Reg)&^(0x4000)|value<<14)
}
func (o *LP_AON_Type) GetEXT_WAKEUP_CNTL_EXT_WAKEUP_STATUS_CLR() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP_CNTL.Reg) & 0x4000) >> 14
}
func (o *LP_AON_Type) SetEXT_WAKEUP_CNTL_EXT_WAKEUP_SEL(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP_CNTL.Reg, volatile.LoadUint32(&o.EXT_WAKEUP_CNTL.Reg)&^(0x7f8000)|value<<15)
}
func (o *LP_AON_Type) GetEXT_WAKEUP_CNTL_EXT_WAKEUP_SEL() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP_CNTL.Reg) & 0x7f8000) >> 15
}
func (o *LP_AON_Type) SetEXT_WAKEUP_CNTL_EXT_WAKEUP_LV(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP_CNTL.Reg, volatile.LoadUint32(&o.EXT_WAKEUP_CNTL.Reg)&^(0x7f800000)|value<<23)
}
func (o *LP_AON_Type) GetEXT_WAKEUP_CNTL_EXT_WAKEUP_LV() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP_CNTL.Reg) & 0x7f800000) >> 23
}
func (o *LP_AON_Type) SetEXT_WAKEUP_CNTL_EXT_WAKEUP_FILTER(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP_CNTL.Reg, volatile.LoadUint32(&o.EXT_WAKEUP_CNTL.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_AON_Type) GetEXT_WAKEUP_CNTL_EXT_WAKEUP_FILTER() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP_CNTL.Reg) & 0x80000000) >> 31
}

// LP_AON.USB: need_des
func (o *LP_AON_Type) SetUSB_RESET_DISABLE(value uint32) {
	volatile.StoreUint32(&o.USB.Reg, volatile.LoadUint32(&o.USB.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_AON_Type) GetUSB_RESET_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.USB.Reg) & 0x80000000) >> 31
}

// LP_AON.LPBUS: need_des
func (o *LP_AON_Type) SetLPBUS_FAST_MEM_WPULSE(value uint32) {
	volatile.StoreUint32(&o.LPBUS.Reg, volatile.LoadUint32(&o.LPBUS.Reg)&^(0x70000)|value<<16)
}
func (o *LP_AON_Type) GetLPBUS_FAST_MEM_WPULSE() uint32 {
	return (volatile.LoadUint32(&o.LPBUS.Reg) & 0x70000) >> 16
}
func (o *LP_AON_Type) SetLPBUS_FAST_MEM_WA(value uint32) {
	volatile.StoreUint32(&o.LPBUS.Reg, volatile.LoadUint32(&o.LPBUS.Reg)&^(0x380000)|value<<19)
}
func (o *LP_AON_Type) GetLPBUS_FAST_MEM_WA() uint32 {
	return (volatile.LoadUint32(&o.LPBUS.Reg) & 0x380000) >> 19
}
func (o *LP_AON_Type) SetLPBUS_FAST_MEM_RA(value uint32) {
	volatile.StoreUint32(&o.LPBUS.Reg, volatile.LoadUint32(&o.LPBUS.Reg)&^(0xc00000)|value<<22)
}
func (o *LP_AON_Type) GetLPBUS_FAST_MEM_RA() uint32 {
	return (volatile.LoadUint32(&o.LPBUS.Reg) & 0xc00000) >> 22
}
func (o *LP_AON_Type) SetLPBUS_FAST_MEM_RM(value uint32) {
	volatile.StoreUint32(&o.LPBUS.Reg, volatile.LoadUint32(&o.LPBUS.Reg)&^(0xf000000)|value<<24)
}
func (o *LP_AON_Type) GetLPBUS_FAST_MEM_RM() uint32 {
	return (volatile.LoadUint32(&o.LPBUS.Reg) & 0xf000000) >> 24
}
func (o *LP_AON_Type) SetLPBUS_FAST_MEM_MUX_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.LPBUS.Reg, volatile.LoadUint32(&o.LPBUS.Reg)&^(0x10000000)|value<<28)
}
func (o *LP_AON_Type) GetLPBUS_FAST_MEM_MUX_FSM_IDLE() uint32 {
	return (volatile.LoadUint32(&o.LPBUS.Reg) & 0x10000000) >> 28
}
func (o *LP_AON_Type) SetLPBUS_FAST_MEM_MUX_SEL_STATUS(value uint32) {
	volatile.StoreUint32(&o.LPBUS.Reg, volatile.LoadUint32(&o.LPBUS.Reg)&^(0x20000000)|value<<29)
}
func (o *LP_AON_Type) GetLPBUS_FAST_MEM_MUX_SEL_STATUS() uint32 {
	return (volatile.LoadUint32(&o.LPBUS.Reg) & 0x20000000) >> 29
}
func (o *LP_AON_Type) SetLPBUS_FAST_MEM_MUX_SEL_UPDATE(value uint32) {
	volatile.StoreUint32(&o.LPBUS.Reg, volatile.LoadUint32(&o.LPBUS.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_AON_Type) GetLPBUS_FAST_MEM_MUX_SEL_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.LPBUS.Reg) & 0x40000000) >> 30
}
func (o *LP_AON_Type) SetLPBUS_FAST_MEM_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.LPBUS.Reg, volatile.LoadUint32(&o.LPBUS.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_AON_Type) GetLPBUS_FAST_MEM_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.LPBUS.Reg) & 0x80000000) >> 31
}

// LP_AON.SDIO_ACTIVE: need_des
func (o *LP_AON_Type) SetSDIO_ACTIVE_SDIO_ACT_DNUM(value uint32) {
	volatile.StoreUint32(&o.SDIO_ACTIVE.Reg, volatile.LoadUint32(&o.SDIO_ACTIVE.Reg)&^(0xffc00000)|value<<22)
}
func (o *LP_AON_Type) GetSDIO_ACTIVE_SDIO_ACT_DNUM() uint32 {
	return (volatile.LoadUint32(&o.SDIO_ACTIVE.Reg) & 0xffc00000) >> 22
}

// LP_AON.LPCORE: need_des
func (o *LP_AON_Type) SetLPCORE_ETM_WAKEUP_FLAG_CLR(value uint32) {
	volatile.StoreUint32(&o.LPCORE.Reg, volatile.LoadUint32(&o.LPCORE.Reg)&^(0x1)|value)
}
func (o *LP_AON_Type) GetLPCORE_ETM_WAKEUP_FLAG_CLR() uint32 {
	return volatile.LoadUint32(&o.LPCORE.Reg) & 0x1
}
func (o *LP_AON_Type) SetLPCORE_ETM_WAKEUP_FLAG(value uint32) {
	volatile.StoreUint32(&o.LPCORE.Reg, volatile.LoadUint32(&o.LPCORE.Reg)&^(0x2)|value<<1)
}
func (o *LP_AON_Type) GetLPCORE_ETM_WAKEUP_FLAG() uint32 {
	return (volatile.LoadUint32(&o.LPCORE.Reg) & 0x2) >> 1
}
func (o *LP_AON_Type) SetLPCORE_DISABLE(value uint32) {
	volatile.StoreUint32(&o.LPCORE.Reg, volatile.LoadUint32(&o.LPCORE.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_AON_Type) GetLPCORE_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.LPCORE.Reg) & 0x80000000) >> 31
}

// LP_AON.SAR_CCT: need_des
func (o *LP_AON_Type) SetSAR_CCT_SAR2_PWDET_CCT(value uint32) {
	volatile.StoreUint32(&o.SAR_CCT.Reg, volatile.LoadUint32(&o.SAR_CCT.Reg)&^(0xe0000000)|value<<29)
}
func (o *LP_AON_Type) GetSAR_CCT_SAR2_PWDET_CCT() uint32 {
	return (volatile.LoadUint32(&o.SAR_CCT.Reg) & 0xe0000000) >> 29
}

// LP_AON.JTAG_SEL: need_des
func (o *LP_AON_Type) SetJTAG_SEL_SOFT(value uint32) {
	volatile.StoreUint32(&o.JTAG_SEL.Reg, volatile.LoadUint32(&o.JTAG_SEL.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_AON_Type) GetJTAG_SEL_SOFT() uint32 {
	return (volatile.LoadUint32(&o.JTAG_SEL.Reg) & 0x80000000) >> 31
}

// LP_AON.DATE: need_des
func (o *LP_AON_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x7fffffff)|value)
}
func (o *LP_AON_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x7fffffff
}
func (o *LP_AON_Type) SetDATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_AON_Type) GetDATE_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.DATE.Reg) & 0x80000000) >> 31
}

// Low-power Access Permission Management Controller
type LP_APM_Type struct {
	REGION_FILTER_EN   volatile.Register32 // 0x0
	REGION0_ADDR_START volatile.Register32 // 0x4
	REGION0_ADDR_END   volatile.Register32 // 0x8
	REGION0_PMS_ATTR   volatile.Register32 // 0xC
	REGION1_ADDR_START volatile.Register32 // 0x10
	REGION1_ADDR_END   volatile.Register32 // 0x14
	REGION1_PMS_ATTR   volatile.Register32 // 0x18
	_                  [168]byte
	FUNC_CTRL          volatile.Register32 // 0xC4
	M0_STATUS          volatile.Register32 // 0xC8
	M0_STATUS_CLR      volatile.Register32 // 0xCC
	M0_EXCEPTION_INFO0 volatile.Register32 // 0xD0
	M0_EXCEPTION_INFO1 volatile.Register32 // 0xD4
	_                  [16]byte
	INT_EN             volatile.Register32 // 0xE8
	CLOCK_GATE         volatile.Register32 // 0xEC
	_                  [12]byte
	DATE               volatile.Register32 // 0xFC
}

// LP_APM.REGION_FILTER_EN: Region filter enable register
func (o *LP_APM_Type) SetREGION_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.REGION_FILTER_EN.Reg, volatile.LoadUint32(&o.REGION_FILTER_EN.Reg)&^(0x3)|value)
}
func (o *LP_APM_Type) GetREGION_FILTER_EN() uint32 {
	return volatile.LoadUint32(&o.REGION_FILTER_EN.Reg) & 0x3
}

// LP_APM.REGION0_ADDR_START: Region address register
func (o *LP_APM_Type) SetREGION0_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION0_ADDR_START.Reg, value)
}
func (o *LP_APM_Type) GetREGION0_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION0_ADDR_START.Reg)
}

// LP_APM.REGION0_ADDR_END: Region address register
func (o *LP_APM_Type) SetREGION0_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION0_ADDR_END.Reg, value)
}
func (o *LP_APM_Type) GetREGION0_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION0_ADDR_END.Reg)
}

// LP_APM.REGION0_PMS_ATTR: Region access authority attribute register
func (o *LP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *LP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x1
}
func (o *LP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *LP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *LP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *LP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *LP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *LP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *LP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *LP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *LP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *LP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *LP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *LP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *LP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *LP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *LP_APM_Type) SetREGION0_PMS_ATTR_REGION0_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION0_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *LP_APM_Type) GetREGION0_PMS_ATTR_REGION0_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION0_PMS_ATTR.Reg) & 0x400) >> 10
}

// LP_APM.REGION1_ADDR_START: Region address register
func (o *LP_APM_Type) SetREGION1_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.REGION1_ADDR_START.Reg, value)
}
func (o *LP_APM_Type) GetREGION1_ADDR_START() uint32 {
	return volatile.LoadUint32(&o.REGION1_ADDR_START.Reg)
}

// LP_APM.REGION1_ADDR_END: Region address register
func (o *LP_APM_Type) SetREGION1_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.REGION1_ADDR_END.Reg, value)
}
func (o *LP_APM_Type) GetREGION1_ADDR_END() uint32 {
	return volatile.LoadUint32(&o.REGION1_ADDR_END.Reg)
}

// LP_APM.REGION1_PMS_ATTR: Region access authority attribute register
func (o *LP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R0_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x1)|value)
}
func (o *LP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R0_PMS_X() uint32 {
	return volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x1
}
func (o *LP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R0_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *LP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R0_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x2) >> 1
}
func (o *LP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R0_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *LP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R0_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x4) >> 2
}
func (o *LP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R1_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x10)|value<<4)
}
func (o *LP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R1_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x10) >> 4
}
func (o *LP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R1_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x20)|value<<5)
}
func (o *LP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R1_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x20) >> 5
}
func (o *LP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R1_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x40)|value<<6)
}
func (o *LP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R1_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x40) >> 6
}
func (o *LP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R2_PMS_X(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x100)|value<<8)
}
func (o *LP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R2_PMS_X() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x100) >> 8
}
func (o *LP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R2_PMS_W(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x200)|value<<9)
}
func (o *LP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R2_PMS_W() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x200) >> 9
}
func (o *LP_APM_Type) SetREGION1_PMS_ATTR_REGION1_R2_PMS_R(value uint32) {
	volatile.StoreUint32(&o.REGION1_PMS_ATTR.Reg, volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg)&^(0x400)|value<<10)
}
func (o *LP_APM_Type) GetREGION1_PMS_ATTR_REGION1_R2_PMS_R() uint32 {
	return (volatile.LoadUint32(&o.REGION1_PMS_ATTR.Reg) & 0x400) >> 10
}

// LP_APM.FUNC_CTRL: PMS function control register
func (o *LP_APM_Type) SetFUNC_CTRL_M0_PMS_FUNC_EN(value uint32) {
	volatile.StoreUint32(&o.FUNC_CTRL.Reg, volatile.LoadUint32(&o.FUNC_CTRL.Reg)&^(0x1)|value)
}
func (o *LP_APM_Type) GetFUNC_CTRL_M0_PMS_FUNC_EN() uint32 {
	return volatile.LoadUint32(&o.FUNC_CTRL.Reg) & 0x1
}

// LP_APM.M0_STATUS: M0 status register
func (o *LP_APM_Type) SetM0_STATUS_M0_EXCEPTION_STATUS(value uint32) {
	volatile.StoreUint32(&o.M0_STATUS.Reg, volatile.LoadUint32(&o.M0_STATUS.Reg)&^(0x3)|value)
}
func (o *LP_APM_Type) GetM0_STATUS_M0_EXCEPTION_STATUS() uint32 {
	return volatile.LoadUint32(&o.M0_STATUS.Reg) & 0x3
}

// LP_APM.M0_STATUS_CLR: M0 status clear register
func (o *LP_APM_Type) SetM0_STATUS_CLR_M0_REGION_STATUS_CLR(value uint32) {
	volatile.StoreUint32(&o.M0_STATUS_CLR.Reg, volatile.LoadUint32(&o.M0_STATUS_CLR.Reg)&^(0x1)|value)
}
func (o *LP_APM_Type) GetM0_STATUS_CLR_M0_REGION_STATUS_CLR() uint32 {
	return volatile.LoadUint32(&o.M0_STATUS_CLR.Reg) & 0x1
}

// LP_APM.M0_EXCEPTION_INFO0: M0 exception_info0 register
func (o *LP_APM_Type) SetM0_EXCEPTION_INFO0_M0_EXCEPTION_REGION(value uint32) {
	volatile.StoreUint32(&o.M0_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M0_EXCEPTION_INFO0.Reg)&^(0x3)|value)
}
func (o *LP_APM_Type) GetM0_EXCEPTION_INFO0_M0_EXCEPTION_REGION() uint32 {
	return volatile.LoadUint32(&o.M0_EXCEPTION_INFO0.Reg) & 0x3
}
func (o *LP_APM_Type) SetM0_EXCEPTION_INFO0_M0_EXCEPTION_MODE(value uint32) {
	volatile.StoreUint32(&o.M0_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M0_EXCEPTION_INFO0.Reg)&^(0x30000)|value<<16)
}
func (o *LP_APM_Type) GetM0_EXCEPTION_INFO0_M0_EXCEPTION_MODE() uint32 {
	return (volatile.LoadUint32(&o.M0_EXCEPTION_INFO0.Reg) & 0x30000) >> 16
}
func (o *LP_APM_Type) SetM0_EXCEPTION_INFO0_M0_EXCEPTION_ID(value uint32) {
	volatile.StoreUint32(&o.M0_EXCEPTION_INFO0.Reg, volatile.LoadUint32(&o.M0_EXCEPTION_INFO0.Reg)&^(0x7c0000)|value<<18)
}
func (o *LP_APM_Type) GetM0_EXCEPTION_INFO0_M0_EXCEPTION_ID() uint32 {
	return (volatile.LoadUint32(&o.M0_EXCEPTION_INFO0.Reg) & 0x7c0000) >> 18
}

// LP_APM.M0_EXCEPTION_INFO1: M0 exception_info1 register
func (o *LP_APM_Type) SetM0_EXCEPTION_INFO1(value uint32) {
	volatile.StoreUint32(&o.M0_EXCEPTION_INFO1.Reg, value)
}
func (o *LP_APM_Type) GetM0_EXCEPTION_INFO1() uint32 {
	return volatile.LoadUint32(&o.M0_EXCEPTION_INFO1.Reg)
}

// LP_APM.INT_EN: APM interrupt enable register
func (o *LP_APM_Type) SetINT_EN_M0_APM_INT_EN(value uint32) {
	volatile.StoreUint32(&o.INT_EN.Reg, volatile.LoadUint32(&o.INT_EN.Reg)&^(0x1)|value)
}
func (o *LP_APM_Type) GetINT_EN_M0_APM_INT_EN() uint32 {
	return volatile.LoadUint32(&o.INT_EN.Reg) & 0x1
}

// LP_APM.CLOCK_GATE: clock gating register
func (o *LP_APM_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *LP_APM_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// LP_APM.DATE: Version register
func (o *LP_APM_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *LP_APM_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// LP_CLKRST Peripheral
type LP_CLKRST_Type struct {
	LP_CLK_CONF  volatile.Register32 // 0x0
	LP_CLK_PO_EN volatile.Register32 // 0x4
	LP_CLK_EN    volatile.Register32 // 0x8
	LP_RST_EN    volatile.Register32 // 0xC
	RESET_CAUSE  volatile.Register32 // 0x10
	CPU_RESET    volatile.Register32 // 0x14
	FOSC_CNTL    volatile.Register32 // 0x18
	RC32K_CNTL   volatile.Register32 // 0x1C
	CLK_TO_HP    volatile.Register32 // 0x20
	LPMEM_FORCE  volatile.Register32 // 0x24
	LPPERI       volatile.Register32 // 0x28
	XTAL32K      volatile.Register32 // 0x2C
	_            [972]byte
	DATE         volatile.Register32 // 0x3FC
}

// LP_CLKRST.LP_CLK_CONF: need_des
func (o *LP_CLKRST_Type) SetLP_CLK_CONF_SLOW_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_CONF.Reg, volatile.LoadUint32(&o.LP_CLK_CONF.Reg)&^(0x3)|value)
}
func (o *LP_CLKRST_Type) GetLP_CLK_CONF_SLOW_CLK_SEL() uint32 {
	return volatile.LoadUint32(&o.LP_CLK_CONF.Reg) & 0x3
}
func (o *LP_CLKRST_Type) SetLP_CLK_CONF_FAST_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_CONF.Reg, volatile.LoadUint32(&o.LP_CLK_CONF.Reg)&^(0xc)|value<<2)
}
func (o *LP_CLKRST_Type) GetLP_CLK_CONF_FAST_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.LP_CLK_CONF.Reg) & 0xc) >> 2
}
func (o *LP_CLKRST_Type) SetLP_CLK_CONF_LP_PERI_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_CONF.Reg, volatile.LoadUint32(&o.LP_CLK_CONF.Reg)&^(0xff0)|value<<4)
}
func (o *LP_CLKRST_Type) GetLP_CLK_CONF_LP_PERI_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.LP_CLK_CONF.Reg) & 0xff0) >> 4
}

// LP_CLKRST.LP_CLK_PO_EN: need_des
func (o *LP_CLKRST_Type) SetLP_CLK_PO_EN_AON_SLOW_OEN(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_PO_EN.Reg, volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg)&^(0x1)|value)
}
func (o *LP_CLKRST_Type) GetLP_CLK_PO_EN_AON_SLOW_OEN() uint32 {
	return volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg) & 0x1
}
func (o *LP_CLKRST_Type) SetLP_CLK_PO_EN_AON_FAST_OEN(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_PO_EN.Reg, volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg)&^(0x2)|value<<1)
}
func (o *LP_CLKRST_Type) GetLP_CLK_PO_EN_AON_FAST_OEN() uint32 {
	return (volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg) & 0x2) >> 1
}
func (o *LP_CLKRST_Type) SetLP_CLK_PO_EN_SOSC_OEN(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_PO_EN.Reg, volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg)&^(0x4)|value<<2)
}
func (o *LP_CLKRST_Type) GetLP_CLK_PO_EN_SOSC_OEN() uint32 {
	return (volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg) & 0x4) >> 2
}
func (o *LP_CLKRST_Type) SetLP_CLK_PO_EN_FOSC_OEN(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_PO_EN.Reg, volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg)&^(0x8)|value<<3)
}
func (o *LP_CLKRST_Type) GetLP_CLK_PO_EN_FOSC_OEN() uint32 {
	return (volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg) & 0x8) >> 3
}
func (o *LP_CLKRST_Type) SetLP_CLK_PO_EN_OSC32K_OEN(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_PO_EN.Reg, volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg)&^(0x10)|value<<4)
}
func (o *LP_CLKRST_Type) GetLP_CLK_PO_EN_OSC32K_OEN() uint32 {
	return (volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg) & 0x10) >> 4
}
func (o *LP_CLKRST_Type) SetLP_CLK_PO_EN_XTAL32K_OEN(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_PO_EN.Reg, volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg)&^(0x20)|value<<5)
}
func (o *LP_CLKRST_Type) GetLP_CLK_PO_EN_XTAL32K_OEN() uint32 {
	return (volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg) & 0x20) >> 5
}
func (o *LP_CLKRST_Type) SetLP_CLK_PO_EN_CORE_EFUSE_OEN(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_PO_EN.Reg, volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg)&^(0x40)|value<<6)
}
func (o *LP_CLKRST_Type) GetLP_CLK_PO_EN_CORE_EFUSE_OEN() uint32 {
	return (volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg) & 0x40) >> 6
}
func (o *LP_CLKRST_Type) SetLP_CLK_PO_EN_SLOW_OEN(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_PO_EN.Reg, volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg)&^(0x80)|value<<7)
}
func (o *LP_CLKRST_Type) GetLP_CLK_PO_EN_SLOW_OEN() uint32 {
	return (volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg) & 0x80) >> 7
}
func (o *LP_CLKRST_Type) SetLP_CLK_PO_EN_FAST_OEN(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_PO_EN.Reg, volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg)&^(0x100)|value<<8)
}
func (o *LP_CLKRST_Type) GetLP_CLK_PO_EN_FAST_OEN() uint32 {
	return (volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg) & 0x100) >> 8
}
func (o *LP_CLKRST_Type) SetLP_CLK_PO_EN_RNG_OEN(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_PO_EN.Reg, volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg)&^(0x200)|value<<9)
}
func (o *LP_CLKRST_Type) GetLP_CLK_PO_EN_RNG_OEN() uint32 {
	return (volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg) & 0x200) >> 9
}
func (o *LP_CLKRST_Type) SetLP_CLK_PO_EN_LPBUS_OEN(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_PO_EN.Reg, volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg)&^(0x400)|value<<10)
}
func (o *LP_CLKRST_Type) GetLP_CLK_PO_EN_LPBUS_OEN() uint32 {
	return (volatile.LoadUint32(&o.LP_CLK_PO_EN.Reg) & 0x400) >> 10
}

// LP_CLKRST.LP_CLK_EN: need_des
func (o *LP_CLKRST_Type) SetLP_CLK_EN_FAST_ORI_GATE(value uint32) {
	volatile.StoreUint32(&o.LP_CLK_EN.Reg, volatile.LoadUint32(&o.LP_CLK_EN.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_CLKRST_Type) GetLP_CLK_EN_FAST_ORI_GATE() uint32 {
	return (volatile.LoadUint32(&o.LP_CLK_EN.Reg) & 0x80000000) >> 31
}

// LP_CLKRST.LP_RST_EN: need_des
func (o *LP_CLKRST_Type) SetLP_RST_EN_AON_EFUSE_CORE_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.LP_RST_EN.Reg, volatile.LoadUint32(&o.LP_RST_EN.Reg)&^(0x10000000)|value<<28)
}
func (o *LP_CLKRST_Type) GetLP_RST_EN_AON_EFUSE_CORE_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.LP_RST_EN.Reg) & 0x10000000) >> 28
}
func (o *LP_CLKRST_Type) SetLP_RST_EN_LP_TIMER_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.LP_RST_EN.Reg, volatile.LoadUint32(&o.LP_RST_EN.Reg)&^(0x20000000)|value<<29)
}
func (o *LP_CLKRST_Type) GetLP_RST_EN_LP_TIMER_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.LP_RST_EN.Reg) & 0x20000000) >> 29
}
func (o *LP_CLKRST_Type) SetLP_RST_EN_WDT_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.LP_RST_EN.Reg, volatile.LoadUint32(&o.LP_RST_EN.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_CLKRST_Type) GetLP_RST_EN_WDT_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.LP_RST_EN.Reg) & 0x40000000) >> 30
}
func (o *LP_CLKRST_Type) SetLP_RST_EN_ANA_PERI_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.LP_RST_EN.Reg, volatile.LoadUint32(&o.LP_RST_EN.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_CLKRST_Type) GetLP_RST_EN_ANA_PERI_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.LP_RST_EN.Reg) & 0x80000000) >> 31
}

// LP_CLKRST.RESET_CAUSE: need_des
func (o *LP_CLKRST_Type) SetRESET_CAUSE(value uint32) {
	volatile.StoreUint32(&o.RESET_CAUSE.Reg, volatile.LoadUint32(&o.RESET_CAUSE.Reg)&^(0x1f)|value)
}
func (o *LP_CLKRST_Type) GetRESET_CAUSE() uint32 {
	return volatile.LoadUint32(&o.RESET_CAUSE.Reg) & 0x1f
}
func (o *LP_CLKRST_Type) SetRESET_CAUSE_CORE0_RESET_FLAG(value uint32) {
	volatile.StoreUint32(&o.RESET_CAUSE.Reg, volatile.LoadUint32(&o.RESET_CAUSE.Reg)&^(0x20)|value<<5)
}
func (o *LP_CLKRST_Type) GetRESET_CAUSE_CORE0_RESET_FLAG() uint32 {
	return (volatile.LoadUint32(&o.RESET_CAUSE.Reg) & 0x20) >> 5
}
func (o *LP_CLKRST_Type) SetRESET_CAUSE_CORE0_RESET_CAUSE_CLR(value uint32) {
	volatile.StoreUint32(&o.RESET_CAUSE.Reg, volatile.LoadUint32(&o.RESET_CAUSE.Reg)&^(0x20000000)|value<<29)
}
func (o *LP_CLKRST_Type) GetRESET_CAUSE_CORE0_RESET_CAUSE_CLR() uint32 {
	return (volatile.LoadUint32(&o.RESET_CAUSE.Reg) & 0x20000000) >> 29
}
func (o *LP_CLKRST_Type) SetRESET_CAUSE_CORE0_RESET_FLAG_SET(value uint32) {
	volatile.StoreUint32(&o.RESET_CAUSE.Reg, volatile.LoadUint32(&o.RESET_CAUSE.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_CLKRST_Type) GetRESET_CAUSE_CORE0_RESET_FLAG_SET() uint32 {
	return (volatile.LoadUint32(&o.RESET_CAUSE.Reg) & 0x40000000) >> 30
}
func (o *LP_CLKRST_Type) SetRESET_CAUSE_CORE0_RESET_FLAG_CLR(value uint32) {
	volatile.StoreUint32(&o.RESET_CAUSE.Reg, volatile.LoadUint32(&o.RESET_CAUSE.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_CLKRST_Type) GetRESET_CAUSE_CORE0_RESET_FLAG_CLR() uint32 {
	return (volatile.LoadUint32(&o.RESET_CAUSE.Reg) & 0x80000000) >> 31
}

// LP_CLKRST.CPU_RESET: need_des
func (o *LP_CLKRST_Type) SetCPU_RESET_RTC_WDT_CPU_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.CPU_RESET.Reg, volatile.LoadUint32(&o.CPU_RESET.Reg)&^(0x1c00000)|value<<22)
}
func (o *LP_CLKRST_Type) GetCPU_RESET_RTC_WDT_CPU_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.CPU_RESET.Reg) & 0x1c00000) >> 22
}
func (o *LP_CLKRST_Type) SetCPU_RESET_RTC_WDT_CPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.CPU_RESET.Reg, volatile.LoadUint32(&o.CPU_RESET.Reg)&^(0x2000000)|value<<25)
}
func (o *LP_CLKRST_Type) GetCPU_RESET_RTC_WDT_CPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.CPU_RESET.Reg) & 0x2000000) >> 25
}
func (o *LP_CLKRST_Type) SetCPU_RESET_CPU_STALL_WAIT(value uint32) {
	volatile.StoreUint32(&o.CPU_RESET.Reg, volatile.LoadUint32(&o.CPU_RESET.Reg)&^(0x7c000000)|value<<26)
}
func (o *LP_CLKRST_Type) GetCPU_RESET_CPU_STALL_WAIT() uint32 {
	return (volatile.LoadUint32(&o.CPU_RESET.Reg) & 0x7c000000) >> 26
}
func (o *LP_CLKRST_Type) SetCPU_RESET_CPU_STALL_EN(value uint32) {
	volatile.StoreUint32(&o.CPU_RESET.Reg, volatile.LoadUint32(&o.CPU_RESET.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_CLKRST_Type) GetCPU_RESET_CPU_STALL_EN() uint32 {
	return (volatile.LoadUint32(&o.CPU_RESET.Reg) & 0x80000000) >> 31
}

// LP_CLKRST.FOSC_CNTL: need_des
func (o *LP_CLKRST_Type) SetFOSC_CNTL_FOSC_DFREQ(value uint32) {
	volatile.StoreUint32(&o.FOSC_CNTL.Reg, volatile.LoadUint32(&o.FOSC_CNTL.Reg)&^(0xffc00000)|value<<22)
}
func (o *LP_CLKRST_Type) GetFOSC_CNTL_FOSC_DFREQ() uint32 {
	return (volatile.LoadUint32(&o.FOSC_CNTL.Reg) & 0xffc00000) >> 22
}

// LP_CLKRST.RC32K_CNTL: need_des
func (o *LP_CLKRST_Type) SetRC32K_CNTL_RC32K_DFREQ(value uint32) {
	volatile.StoreUint32(&o.RC32K_CNTL.Reg, volatile.LoadUint32(&o.RC32K_CNTL.Reg)&^(0xffc00000)|value<<22)
}
func (o *LP_CLKRST_Type) GetRC32K_CNTL_RC32K_DFREQ() uint32 {
	return (volatile.LoadUint32(&o.RC32K_CNTL.Reg) & 0xffc00000) >> 22
}

// LP_CLKRST.CLK_TO_HP: need_des
func (o *LP_CLKRST_Type) SetCLK_TO_HP_ICG_HP_XTAL32K(value uint32) {
	volatile.StoreUint32(&o.CLK_TO_HP.Reg, volatile.LoadUint32(&o.CLK_TO_HP.Reg)&^(0x10000000)|value<<28)
}
func (o *LP_CLKRST_Type) GetCLK_TO_HP_ICG_HP_XTAL32K() uint32 {
	return (volatile.LoadUint32(&o.CLK_TO_HP.Reg) & 0x10000000) >> 28
}
func (o *LP_CLKRST_Type) SetCLK_TO_HP_ICG_HP_SOSC(value uint32) {
	volatile.StoreUint32(&o.CLK_TO_HP.Reg, volatile.LoadUint32(&o.CLK_TO_HP.Reg)&^(0x20000000)|value<<29)
}
func (o *LP_CLKRST_Type) GetCLK_TO_HP_ICG_HP_SOSC() uint32 {
	return (volatile.LoadUint32(&o.CLK_TO_HP.Reg) & 0x20000000) >> 29
}
func (o *LP_CLKRST_Type) SetCLK_TO_HP_ICG_HP_OSC32K(value uint32) {
	volatile.StoreUint32(&o.CLK_TO_HP.Reg, volatile.LoadUint32(&o.CLK_TO_HP.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_CLKRST_Type) GetCLK_TO_HP_ICG_HP_OSC32K() uint32 {
	return (volatile.LoadUint32(&o.CLK_TO_HP.Reg) & 0x40000000) >> 30
}
func (o *LP_CLKRST_Type) SetCLK_TO_HP_ICG_HP_FOSC(value uint32) {
	volatile.StoreUint32(&o.CLK_TO_HP.Reg, volatile.LoadUint32(&o.CLK_TO_HP.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_CLKRST_Type) GetCLK_TO_HP_ICG_HP_FOSC() uint32 {
	return (volatile.LoadUint32(&o.CLK_TO_HP.Reg) & 0x80000000) >> 31
}

// LP_CLKRST.LPMEM_FORCE: need_des
func (o *LP_CLKRST_Type) SetLPMEM_FORCE_LPMEM_CLK_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.LPMEM_FORCE.Reg, volatile.LoadUint32(&o.LPMEM_FORCE.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_CLKRST_Type) GetLPMEM_FORCE_LPMEM_CLK_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.LPMEM_FORCE.Reg) & 0x80000000) >> 31
}

// LP_CLKRST.LPPERI: need_des
func (o *LP_CLKRST_Type) SetLPPERI_LP_BLETIMER_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.LPPERI.Reg, volatile.LoadUint32(&o.LPPERI.Reg)&^(0xfff000)|value<<12)
}
func (o *LP_CLKRST_Type) GetLPPERI_LP_BLETIMER_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.LPPERI.Reg) & 0xfff000) >> 12
}
func (o *LP_CLKRST_Type) SetLPPERI_LP_BLETIMER_32K_SEL(value uint32) {
	volatile.StoreUint32(&o.LPPERI.Reg, volatile.LoadUint32(&o.LPPERI.Reg)&^(0x3000000)|value<<24)
}
func (o *LP_CLKRST_Type) GetLPPERI_LP_BLETIMER_32K_SEL() uint32 {
	return (volatile.LoadUint32(&o.LPPERI.Reg) & 0x3000000) >> 24
}
func (o *LP_CLKRST_Type) SetLPPERI_LP_SEL_OSC_SLOW(value uint32) {
	volatile.StoreUint32(&o.LPPERI.Reg, volatile.LoadUint32(&o.LPPERI.Reg)&^(0x4000000)|value<<26)
}
func (o *LP_CLKRST_Type) GetLPPERI_LP_SEL_OSC_SLOW() uint32 {
	return (volatile.LoadUint32(&o.LPPERI.Reg) & 0x4000000) >> 26
}
func (o *LP_CLKRST_Type) SetLPPERI_LP_SEL_OSC_FAST(value uint32) {
	volatile.StoreUint32(&o.LPPERI.Reg, volatile.LoadUint32(&o.LPPERI.Reg)&^(0x8000000)|value<<27)
}
func (o *LP_CLKRST_Type) GetLPPERI_LP_SEL_OSC_FAST() uint32 {
	return (volatile.LoadUint32(&o.LPPERI.Reg) & 0x8000000) >> 27
}
func (o *LP_CLKRST_Type) SetLPPERI_LP_SEL_XTAL(value uint32) {
	volatile.StoreUint32(&o.LPPERI.Reg, volatile.LoadUint32(&o.LPPERI.Reg)&^(0x10000000)|value<<28)
}
func (o *LP_CLKRST_Type) GetLPPERI_LP_SEL_XTAL() uint32 {
	return (volatile.LoadUint32(&o.LPPERI.Reg) & 0x10000000) >> 28
}
func (o *LP_CLKRST_Type) SetLPPERI_LP_SEL_XTAL32K(value uint32) {
	volatile.StoreUint32(&o.LPPERI.Reg, volatile.LoadUint32(&o.LPPERI.Reg)&^(0x20000000)|value<<29)
}
func (o *LP_CLKRST_Type) GetLPPERI_LP_SEL_XTAL32K() uint32 {
	return (volatile.LoadUint32(&o.LPPERI.Reg) & 0x20000000) >> 29
}
func (o *LP_CLKRST_Type) SetLPPERI_LP_I2C_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.LPPERI.Reg, volatile.LoadUint32(&o.LPPERI.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_CLKRST_Type) GetLPPERI_LP_I2C_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.LPPERI.Reg) & 0x40000000) >> 30
}
func (o *LP_CLKRST_Type) SetLPPERI_LP_UART_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.LPPERI.Reg, volatile.LoadUint32(&o.LPPERI.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_CLKRST_Type) GetLPPERI_LP_UART_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.LPPERI.Reg) & 0x80000000) >> 31
}

// LP_CLKRST.XTAL32K: need_des
func (o *LP_CLKRST_Type) SetXTAL32K_DRES_XTAL32K(value uint32) {
	volatile.StoreUint32(&o.XTAL32K.Reg, volatile.LoadUint32(&o.XTAL32K.Reg)&^(0x1c00000)|value<<22)
}
func (o *LP_CLKRST_Type) GetXTAL32K_DRES_XTAL32K() uint32 {
	return (volatile.LoadUint32(&o.XTAL32K.Reg) & 0x1c00000) >> 22
}
func (o *LP_CLKRST_Type) SetXTAL32K_DGM_XTAL32K(value uint32) {
	volatile.StoreUint32(&o.XTAL32K.Reg, volatile.LoadUint32(&o.XTAL32K.Reg)&^(0xe000000)|value<<25)
}
func (o *LP_CLKRST_Type) GetXTAL32K_DGM_XTAL32K() uint32 {
	return (volatile.LoadUint32(&o.XTAL32K.Reg) & 0xe000000) >> 25
}
func (o *LP_CLKRST_Type) SetXTAL32K_DBUF_XTAL32K(value uint32) {
	volatile.StoreUint32(&o.XTAL32K.Reg, volatile.LoadUint32(&o.XTAL32K.Reg)&^(0x10000000)|value<<28)
}
func (o *LP_CLKRST_Type) GetXTAL32K_DBUF_XTAL32K() uint32 {
	return (volatile.LoadUint32(&o.XTAL32K.Reg) & 0x10000000) >> 28
}
func (o *LP_CLKRST_Type) SetXTAL32K_DAC_XTAL32K(value uint32) {
	volatile.StoreUint32(&o.XTAL32K.Reg, volatile.LoadUint32(&o.XTAL32K.Reg)&^(0xe0000000)|value<<29)
}
func (o *LP_CLKRST_Type) GetXTAL32K_DAC_XTAL32K() uint32 {
	return (volatile.LoadUint32(&o.XTAL32K.Reg) & 0xe0000000) >> 29
}

// LP_CLKRST.DATE: need_des
func (o *LP_CLKRST_Type) SetDATE_CLKRST_DATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x7fffffff)|value)
}
func (o *LP_CLKRST_Type) GetDATE_CLKRST_DATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x7fffffff
}
func (o *LP_CLKRST_Type) SetDATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_CLKRST_Type) GetDATE_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.DATE.Reg) & 0x80000000) >> 31
}

// Low-power Timer
type LP_TIMER_Type struct {
	TAR0_LOW       volatile.Register32 // 0x0
	TAR0_HIGH      volatile.Register32 // 0x4
	_              [8]byte
	UPDATE         volatile.Register32 // 0x10
	MAIN_BUF0_LOW  volatile.Register32 // 0x14
	MAIN_BUF0_HIGH volatile.Register32 // 0x18
	MAIN_BUF1_LOW  volatile.Register32 // 0x1C
	MAIN_BUF1_HIGH volatile.Register32 // 0x20
	MAIN_OVERFLOW  volatile.Register32 // 0x24
	INT_RAW        volatile.Register32 // 0x28
	INT_ST         volatile.Register32 // 0x2C
	INT_ENA        volatile.Register32 // 0x30
	INT_CLR        volatile.Register32 // 0x34
	_              [964]byte
	DATE           volatile.Register32 // 0x3FC
}

// LP_TIMER.TAR0_LOW: need_des
func (o *LP_TIMER_Type) SetTAR0_LOW(value uint32) {
	volatile.StoreUint32(&o.TAR0_LOW.Reg, value)
}
func (o *LP_TIMER_Type) GetTAR0_LOW() uint32 {
	return volatile.LoadUint32(&o.TAR0_LOW.Reg)
}

// LP_TIMER.TAR0_HIGH: need_des
func (o *LP_TIMER_Type) SetTAR0_HIGH_MAIN_TIMER_TAR_HIGH0(value uint32) {
	volatile.StoreUint32(&o.TAR0_HIGH.Reg, volatile.LoadUint32(&o.TAR0_HIGH.Reg)&^(0xffff)|value)
}
func (o *LP_TIMER_Type) GetTAR0_HIGH_MAIN_TIMER_TAR_HIGH0() uint32 {
	return volatile.LoadUint32(&o.TAR0_HIGH.Reg) & 0xffff
}
func (o *LP_TIMER_Type) SetTAR0_HIGH_MAIN_TIMER_TAR_EN0(value uint32) {
	volatile.StoreUint32(&o.TAR0_HIGH.Reg, volatile.LoadUint32(&o.TAR0_HIGH.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_TIMER_Type) GetTAR0_HIGH_MAIN_TIMER_TAR_EN0() uint32 {
	return (volatile.LoadUint32(&o.TAR0_HIGH.Reg) & 0x80000000) >> 31
}

// LP_TIMER.UPDATE: need_des
func (o *LP_TIMER_Type) SetUPDATE_MAIN_TIMER_UPDATE(value uint32) {
	volatile.StoreUint32(&o.UPDATE.Reg, volatile.LoadUint32(&o.UPDATE.Reg)&^(0x10000000)|value<<28)
}
func (o *LP_TIMER_Type) GetUPDATE_MAIN_TIMER_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.UPDATE.Reg) & 0x10000000) >> 28
}
func (o *LP_TIMER_Type) SetUPDATE_MAIN_TIMER_XTAL_OFF(value uint32) {
	volatile.StoreUint32(&o.UPDATE.Reg, volatile.LoadUint32(&o.UPDATE.Reg)&^(0x20000000)|value<<29)
}
func (o *LP_TIMER_Type) GetUPDATE_MAIN_TIMER_XTAL_OFF() uint32 {
	return (volatile.LoadUint32(&o.UPDATE.Reg) & 0x20000000) >> 29
}
func (o *LP_TIMER_Type) SetUPDATE_MAIN_TIMER_SYS_STALL(value uint32) {
	volatile.StoreUint32(&o.UPDATE.Reg, volatile.LoadUint32(&o.UPDATE.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_TIMER_Type) GetUPDATE_MAIN_TIMER_SYS_STALL() uint32 {
	return (volatile.LoadUint32(&o.UPDATE.Reg) & 0x40000000) >> 30
}
func (o *LP_TIMER_Type) SetUPDATE_MAIN_TIMER_SYS_RST(value uint32) {
	volatile.StoreUint32(&o.UPDATE.Reg, volatile.LoadUint32(&o.UPDATE.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_TIMER_Type) GetUPDATE_MAIN_TIMER_SYS_RST() uint32 {
	return (volatile.LoadUint32(&o.UPDATE.Reg) & 0x80000000) >> 31
}

// LP_TIMER.MAIN_BUF0_LOW: need_des
func (o *LP_TIMER_Type) SetMAIN_BUF0_LOW(value uint32) {
	volatile.StoreUint32(&o.MAIN_BUF0_LOW.Reg, value)
}
func (o *LP_TIMER_Type) GetMAIN_BUF0_LOW() uint32 {
	return volatile.LoadUint32(&o.MAIN_BUF0_LOW.Reg)
}

// LP_TIMER.MAIN_BUF0_HIGH: need_des
func (o *LP_TIMER_Type) SetMAIN_BUF0_HIGH_MAIN_TIMER_BUF0_HIGH(value uint32) {
	volatile.StoreUint32(&o.MAIN_BUF0_HIGH.Reg, volatile.LoadUint32(&o.MAIN_BUF0_HIGH.Reg)&^(0xffff)|value)
}
func (o *LP_TIMER_Type) GetMAIN_BUF0_HIGH_MAIN_TIMER_BUF0_HIGH() uint32 {
	return volatile.LoadUint32(&o.MAIN_BUF0_HIGH.Reg) & 0xffff
}

// LP_TIMER.MAIN_BUF1_LOW: need_des
func (o *LP_TIMER_Type) SetMAIN_BUF1_LOW(value uint32) {
	volatile.StoreUint32(&o.MAIN_BUF1_LOW.Reg, value)
}
func (o *LP_TIMER_Type) GetMAIN_BUF1_LOW() uint32 {
	return volatile.LoadUint32(&o.MAIN_BUF1_LOW.Reg)
}

// LP_TIMER.MAIN_BUF1_HIGH: need_des
func (o *LP_TIMER_Type) SetMAIN_BUF1_HIGH_MAIN_TIMER_BUF1_HIGH(value uint32) {
	volatile.StoreUint32(&o.MAIN_BUF1_HIGH.Reg, volatile.LoadUint32(&o.MAIN_BUF1_HIGH.Reg)&^(0xffff)|value)
}
func (o *LP_TIMER_Type) GetMAIN_BUF1_HIGH_MAIN_TIMER_BUF1_HIGH() uint32 {
	return volatile.LoadUint32(&o.MAIN_BUF1_HIGH.Reg) & 0xffff
}

// LP_TIMER.MAIN_OVERFLOW: need_des
func (o *LP_TIMER_Type) SetMAIN_OVERFLOW_MAIN_TIMER_ALARM_LOAD(value uint32) {
	volatile.StoreUint32(&o.MAIN_OVERFLOW.Reg, volatile.LoadUint32(&o.MAIN_OVERFLOW.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_TIMER_Type) GetMAIN_OVERFLOW_MAIN_TIMER_ALARM_LOAD() uint32 {
	return (volatile.LoadUint32(&o.MAIN_OVERFLOW.Reg) & 0x80000000) >> 31
}

// LP_TIMER.INT_RAW: need_des
func (o *LP_TIMER_Type) SetINT_RAW_OVERFLOW_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_TIMER_Type) GetINT_RAW_OVERFLOW_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000000) >> 30
}
func (o *LP_TIMER_Type) SetINT_RAW_SOC_WAKEUP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_TIMER_Type) GetINT_RAW_SOC_WAKEUP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000000) >> 31
}

// LP_TIMER.INT_ST: need_des
func (o *LP_TIMER_Type) SetINT_ST_OVERFLOW_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_TIMER_Type) GetINT_ST_OVERFLOW_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40000000) >> 30
}
func (o *LP_TIMER_Type) SetINT_ST_SOC_WAKEUP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_TIMER_Type) GetINT_ST_SOC_WAKEUP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80000000) >> 31
}

// LP_TIMER.INT_ENA: need_des
func (o *LP_TIMER_Type) SetINT_ENA_OVERFLOW_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_TIMER_Type) GetINT_ENA_OVERFLOW_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40000000) >> 30
}
func (o *LP_TIMER_Type) SetINT_ENA_SOC_WAKEUP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_TIMER_Type) GetINT_ENA_SOC_WAKEUP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80000000) >> 31
}

// LP_TIMER.INT_CLR: need_des
func (o *LP_TIMER_Type) SetINT_CLR_OVERFLOW_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_TIMER_Type) GetINT_CLR_OVERFLOW_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40000000) >> 30
}
func (o *LP_TIMER_Type) SetINT_CLR_SOC_WAKEUP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_TIMER_Type) GetINT_CLR_SOC_WAKEUP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80000000) >> 31
}

// LP_TIMER.DATE: need_des
func (o *LP_TIMER_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x7fffffff)|value)
}
func (o *LP_TIMER_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x7fffffff
}
func (o *LP_TIMER_Type) SetDATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_TIMER_Type) GetDATE_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.DATE.Reg) & 0x80000000) >> 31
}

// Low-power Watchdog Timer
type LP_WDT_Type struct {
	WDTCONFIG0   volatile.Register32 // 0x0
	CONFIG1      volatile.Register32 // 0x4
	CONFIG2      volatile.Register32 // 0x8
	CONFIG3      volatile.Register32 // 0xC
	CONFIG4      volatile.Register32 // 0x10
	CONFIG5      volatile.Register32 // 0x14
	WDTFEED      volatile.Register32 // 0x18
	WDTWPROTECT  volatile.Register32 // 0x1C
	SWD_CONF     volatile.Register32 // 0x20
	SWD_WPROTECT volatile.Register32 // 0x24
	INT_RAW      volatile.Register32 // 0x28
	INT_ST_RTC   volatile.Register32 // 0x2C
	INT_ENA_RTC  volatile.Register32 // 0x30
	INT_CLR_RTC  volatile.Register32 // 0x34
	_            [964]byte
	DATE         volatile.Register32 // 0x3FC
}

// LP_WDT.WDTCONFIG0: need_des
func (o *LP_WDT_Type) SetWDTCONFIG0_WDT_PAUSE_IN_SLP(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x200)|value<<9)
}
func (o *LP_WDT_Type) GetWDTCONFIG0_WDT_PAUSE_IN_SLP() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x200) >> 9
}
func (o *LP_WDT_Type) SetWDTCONFIG0_WDT_APPCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x400)|value<<10)
}
func (o *LP_WDT_Type) GetWDTCONFIG0_WDT_APPCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x400) >> 10
}
func (o *LP_WDT_Type) SetWDTCONFIG0_WDT_PROCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x800)|value<<11)
}
func (o *LP_WDT_Type) GetWDTCONFIG0_WDT_PROCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x800) >> 11
}
func (o *LP_WDT_Type) SetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1000)|value<<12)
}
func (o *LP_WDT_Type) GetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1000) >> 12
}
func (o *LP_WDT_Type) SetWDTCONFIG0_WDT_SYS_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0xe000)|value<<13)
}
func (o *LP_WDT_Type) GetWDTCONFIG0_WDT_SYS_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0xe000) >> 13
}
func (o *LP_WDT_Type) SetWDTCONFIG0_WDT_CPU_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x70000)|value<<16)
}
func (o *LP_WDT_Type) GetWDTCONFIG0_WDT_CPU_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x70000) >> 16
}
func (o *LP_WDT_Type) SetWDTCONFIG0_WDT_STG3(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x380000)|value<<19)
}
func (o *LP_WDT_Type) GetWDTCONFIG0_WDT_STG3() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x380000) >> 19
}
func (o *LP_WDT_Type) SetWDTCONFIG0_WDT_STG2(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1c00000)|value<<22)
}
func (o *LP_WDT_Type) GetWDTCONFIG0_WDT_STG2() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1c00000) >> 22
}
func (o *LP_WDT_Type) SetWDTCONFIG0_WDT_STG1(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0xe000000)|value<<25)
}
func (o *LP_WDT_Type) GetWDTCONFIG0_WDT_STG1() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0xe000000) >> 25
}
func (o *LP_WDT_Type) SetWDTCONFIG0_WDT_STG0(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x70000000)|value<<28)
}
func (o *LP_WDT_Type) GetWDTCONFIG0_WDT_STG0() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x70000000) >> 28
}
func (o *LP_WDT_Type) SetWDTCONFIG0_WDT_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_WDT_Type) GetWDTCONFIG0_WDT_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x80000000) >> 31
}

// LP_WDT.CONFIG1: need_des
func (o *LP_WDT_Type) SetCONFIG1(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, value)
}
func (o *LP_WDT_Type) GetCONFIG1() uint32 {
	return volatile.LoadUint32(&o.CONFIG1.Reg)
}

// LP_WDT.CONFIG2: need_des
func (o *LP_WDT_Type) SetCONFIG2(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, value)
}
func (o *LP_WDT_Type) GetCONFIG2() uint32 {
	return volatile.LoadUint32(&o.CONFIG2.Reg)
}

// LP_WDT.CONFIG3: need_des
func (o *LP_WDT_Type) SetCONFIG3(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, value)
}
func (o *LP_WDT_Type) GetCONFIG3() uint32 {
	return volatile.LoadUint32(&o.CONFIG3.Reg)
}

// LP_WDT.CONFIG4: need_des
func (o *LP_WDT_Type) SetCONFIG4(value uint32) {
	volatile.StoreUint32(&o.CONFIG4.Reg, value)
}
func (o *LP_WDT_Type) GetCONFIG4() uint32 {
	return volatile.LoadUint32(&o.CONFIG4.Reg)
}

// LP_WDT.CONFIG5: need_des
func (o *LP_WDT_Type) SetCONFIG5_CHIP_RESET_TARGET(value uint32) {
	volatile.StoreUint32(&o.CONFIG5.Reg, volatile.LoadUint32(&o.CONFIG5.Reg)&^(0xff)|value)
}
func (o *LP_WDT_Type) GetCONFIG5_CHIP_RESET_TARGET() uint32 {
	return volatile.LoadUint32(&o.CONFIG5.Reg) & 0xff
}
func (o *LP_WDT_Type) SetCONFIG5_CHIP_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.CONFIG5.Reg, volatile.LoadUint32(&o.CONFIG5.Reg)&^(0x100)|value<<8)
}
func (o *LP_WDT_Type) GetCONFIG5_CHIP_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.CONFIG5.Reg) & 0x100) >> 8
}
func (o *LP_WDT_Type) SetCONFIG5_CHIP_RESET_KEY(value uint32) {
	volatile.StoreUint32(&o.CONFIG5.Reg, volatile.LoadUint32(&o.CONFIG5.Reg)&^(0x1fe00)|value<<9)
}
func (o *LP_WDT_Type) GetCONFIG5_CHIP_RESET_KEY() uint32 {
	return (volatile.LoadUint32(&o.CONFIG5.Reg) & 0x1fe00) >> 9
}

// LP_WDT.WDTFEED: need_des
func (o *LP_WDT_Type) SetWDTFEED_RTC_WDT_FEED(value uint32) {
	volatile.StoreUint32(&o.WDTFEED.Reg, volatile.LoadUint32(&o.WDTFEED.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_WDT_Type) GetWDTFEED_RTC_WDT_FEED() uint32 {
	return (volatile.LoadUint32(&o.WDTFEED.Reg) & 0x80000000) >> 31
}

// LP_WDT.WDTWPROTECT: need_des
func (o *LP_WDT_Type) SetWDTWPROTECT(value uint32) {
	volatile.StoreUint32(&o.WDTWPROTECT.Reg, value)
}
func (o *LP_WDT_Type) GetWDTWPROTECT() uint32 {
	return volatile.LoadUint32(&o.WDTWPROTECT.Reg)
}

// LP_WDT.SWD_CONF: need_des
func (o *LP_WDT_Type) SetSWD_CONF_SWD_RESET_FLAG(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x1)|value)
}
func (o *LP_WDT_Type) GetSWD_CONF_SWD_RESET_FLAG() uint32 {
	return volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x1
}
func (o *LP_WDT_Type) SetSWD_CONF_SWD_AUTO_FEED_EN(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *LP_WDT_Type) GetSWD_CONF_SWD_AUTO_FEED_EN() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x40000) >> 18
}
func (o *LP_WDT_Type) SetSWD_CONF_SWD_RST_FLAG_CLR(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *LP_WDT_Type) GetSWD_CONF_SWD_RST_FLAG_CLR() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x80000) >> 19
}
func (o *LP_WDT_Type) SetSWD_CONF_SWD_SIGNAL_WIDTH(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LP_WDT_Type) GetSWD_CONF_SWD_SIGNAL_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x3ff00000) >> 20
}
func (o *LP_WDT_Type) SetSWD_CONF_SWD_DISABLE(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_WDT_Type) GetSWD_CONF_SWD_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x40000000) >> 30
}
func (o *LP_WDT_Type) SetSWD_CONF_SWD_FEED(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_WDT_Type) GetSWD_CONF_SWD_FEED() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x80000000) >> 31
}

// LP_WDT.SWD_WPROTECT: need_des
func (o *LP_WDT_Type) SetSWD_WPROTECT(value uint32) {
	volatile.StoreUint32(&o.SWD_WPROTECT.Reg, value)
}
func (o *LP_WDT_Type) GetSWD_WPROTECT() uint32 {
	return volatile.LoadUint32(&o.SWD_WPROTECT.Reg)
}

// LP_WDT.INT_RAW: need_des
func (o *LP_WDT_Type) SetINT_RAW_SUPER_WDT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_WDT_Type) GetINT_RAW_SUPER_WDT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000000) >> 30
}
func (o *LP_WDT_Type) SetINT_RAW_LP_WDT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_WDT_Type) GetINT_RAW_LP_WDT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000000) >> 31
}

// LP_WDT.INT_ST_RTC: need_des
func (o *LP_WDT_Type) SetINT_ST_RTC_SUPER_WDT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_WDT_Type) GetINT_ST_RTC_SUPER_WDT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x40000000) >> 30
}
func (o *LP_WDT_Type) SetINT_ST_RTC_WDT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_WDT_Type) GetINT_ST_RTC_WDT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x80000000) >> 31
}

// LP_WDT.INT_ENA_RTC: need_des
func (o *LP_WDT_Type) SetINT_ENA_RTC_SUPER_WDT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_WDT_Type) GetINT_ENA_RTC_SUPER_WDT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x40000000) >> 30
}
func (o *LP_WDT_Type) SetINT_ENA_RTC_WDT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_WDT_Type) GetINT_ENA_RTC_WDT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x80000000) >> 31
}

// LP_WDT.INT_CLR_RTC: need_des
func (o *LP_WDT_Type) SetINT_CLR_RTC_SUPER_WDT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x40000000)|value<<30)
}
func (o *LP_WDT_Type) GetINT_CLR_RTC_SUPER_WDT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x40000000) >> 30
}
func (o *LP_WDT_Type) SetINT_CLR_RTC_WDT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_WDT_Type) GetINT_CLR_RTC_WDT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x80000000) >> 31
}

// LP_WDT.DATE: need_des
func (o *LP_WDT_Type) SetDATE_LP_WDT_DATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x7fffffff)|value)
}
func (o *LP_WDT_Type) GetDATE_LP_WDT_DATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x7fffffff
}
func (o *LP_WDT_Type) SetDATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x80000000)|value<<31)
}
func (o *LP_WDT_Type) GetDATE_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.DATE.Reg) & 0x80000000) >> 31
}

// Motor Control Pulse-Width Modulation 0
type MCPWM_Type struct {
	CLK_CFG           volatile.Register32 // 0x0
	TIMER0_CFG0       volatile.Register32 // 0x4
	TIMER0_CFG1       volatile.Register32 // 0x8
	TIMER0_SYNC       volatile.Register32 // 0xC
	TIMER0_STATUS     volatile.Register32 // 0x10
	TIMER1_CFG0       volatile.Register32 // 0x14
	TIMER1_CFG1       volatile.Register32 // 0x18
	TIMER1_SYNC       volatile.Register32 // 0x1C
	TIMER1_STATUS     volatile.Register32 // 0x20
	TIMER2_CFG0       volatile.Register32 // 0x24
	TIMER2_CFG1       volatile.Register32 // 0x28
	TIMER2_SYNC       volatile.Register32 // 0x2C
	TIMER2_STATUS     volatile.Register32 // 0x30
	TIMER_SYNCI_CFG   volatile.Register32 // 0x34
	OPERATOR_TIMERSEL volatile.Register32 // 0x38
	GEN0_STMP_CFG     volatile.Register32 // 0x3C
	GEN0_TSTMP_A      volatile.Register32 // 0x40
	GEN0_TSTMP_B      volatile.Register32 // 0x44
	GEN0_CFG0         volatile.Register32 // 0x48
	GEN0_FORCE        volatile.Register32 // 0x4C
	GEN0_A            volatile.Register32 // 0x50
	GEN0_B            volatile.Register32 // 0x54
	DT0_CFG           volatile.Register32 // 0x58
	DT0_FED_CFG       volatile.Register32 // 0x5C
	DT0_RED_CFG       volatile.Register32 // 0x60
	CARRIER0_CFG      volatile.Register32 // 0x64
	FH0_CFG0          volatile.Register32 // 0x68
	FH0_CFG1          volatile.Register32 // 0x6C
	FH0_STATUS        volatile.Register32 // 0x70
	GEN1_STMP_CFG     volatile.Register32 // 0x74
	GEN1_TSTMP_A      volatile.Register32 // 0x78
	GEN1_TSTMP_B      volatile.Register32 // 0x7C
	GEN1_CFG0         volatile.Register32 // 0x80
	GEN1_FORCE        volatile.Register32 // 0x84
	GEN1_A            volatile.Register32 // 0x88
	GEN1_B            volatile.Register32 // 0x8C
	DT1_CFG           volatile.Register32 // 0x90
	DT1_FED_CFG       volatile.Register32 // 0x94
	DT1_RED_CFG       volatile.Register32 // 0x98
	CARRIER1_CFG      volatile.Register32 // 0x9C
	FH1_CFG0          volatile.Register32 // 0xA0
	FH1_CFG1          volatile.Register32 // 0xA4
	FH1_STATUS        volatile.Register32 // 0xA8
	GEN2_STMP_CFG     volatile.Register32 // 0xAC
	GEN2_TSTMP_A      volatile.Register32 // 0xB0
	GEN2_TSTMP_B      volatile.Register32 // 0xB4
	GEN2_CFG0         volatile.Register32 // 0xB8
	GEN2_FORCE        volatile.Register32 // 0xBC
	GEN2_A            volatile.Register32 // 0xC0
	GEN2_B            volatile.Register32 // 0xC4
	DT2_CFG           volatile.Register32 // 0xC8
	DT2_FED_CFG       volatile.Register32 // 0xCC
	DT2_RED_CFG       volatile.Register32 // 0xD0
	CARRIER2_CFG      volatile.Register32 // 0xD4
	FH2_CFG0          volatile.Register32 // 0xD8
	FH2_CFG1          volatile.Register32 // 0xDC
	FH2_STATUS        volatile.Register32 // 0xE0
	FAULT_DETECT      volatile.Register32 // 0xE4
	CAP_TIMER_CFG     volatile.Register32 // 0xE8
	CAP_TIMER_PHASE   volatile.Register32 // 0xEC
	CAP_CH0_CFG       volatile.Register32 // 0xF0
	CAP_CH1_CFG       volatile.Register32 // 0xF4
	CAP_CH2_CFG       volatile.Register32 // 0xF8
	CAP_CH0           volatile.Register32 // 0xFC
	CAP_CH1           volatile.Register32 // 0x100
	CAP_CH2           volatile.Register32 // 0x104
	CAP_STATUS        volatile.Register32 // 0x108
	UPDATE_CFG        volatile.Register32 // 0x10C
	INT_ENA           volatile.Register32 // 0x110
	INT_RAW           volatile.Register32 // 0x114
	INT_ST            volatile.Register32 // 0x118
	INT_CLR           volatile.Register32 // 0x11C
	EVT_EN            volatile.Register32 // 0x120
	TASK_EN           volatile.Register32 // 0x124
	CLK               volatile.Register32 // 0x128
	VERSION           volatile.Register32 // 0x12C
}

// MCPWM.CLK_CFG: PWM clock prescaler register.
func (o *MCPWM_Type) SetCLK_CFG_CLK_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.CLK_CFG.Reg, volatile.LoadUint32(&o.CLK_CFG.Reg)&^(0xff)|value)
}
func (o *MCPWM_Type) GetCLK_CFG_CLK_PRESCALE() uint32 {
	return volatile.LoadUint32(&o.CLK_CFG.Reg) & 0xff
}

// MCPWM.TIMER0_CFG0: PWM timer0 period and update method configuration register.
func (o *MCPWM_Type) SetTIMER0_CFG0_TIMER0_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CFG0.Reg, volatile.LoadUint32(&o.TIMER0_CFG0.Reg)&^(0xff)|value)
}
func (o *MCPWM_Type) GetTIMER0_CFG0_TIMER0_PRESCALE() uint32 {
	return volatile.LoadUint32(&o.TIMER0_CFG0.Reg) & 0xff
}
func (o *MCPWM_Type) SetTIMER0_CFG0_TIMER0_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CFG0.Reg, volatile.LoadUint32(&o.TIMER0_CFG0.Reg)&^(0xffff00)|value<<8)
}
func (o *MCPWM_Type) GetTIMER0_CFG0_TIMER0_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CFG0.Reg) & 0xffff00) >> 8
}
func (o *MCPWM_Type) SetTIMER0_CFG0_TIMER0_PERIOD_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CFG0.Reg, volatile.LoadUint32(&o.TIMER0_CFG0.Reg)&^(0x3000000)|value<<24)
}
func (o *MCPWM_Type) GetTIMER0_CFG0_TIMER0_PERIOD_UPMETHOD() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CFG0.Reg) & 0x3000000) >> 24
}

// MCPWM.TIMER0_CFG1: PWM timer0 working mode and start/stop control configuration register.
func (o *MCPWM_Type) SetTIMER0_CFG1_TIMER0_START(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CFG1.Reg, volatile.LoadUint32(&o.TIMER0_CFG1.Reg)&^(0x7)|value)
}
func (o *MCPWM_Type) GetTIMER0_CFG1_TIMER0_START() uint32 {
	return volatile.LoadUint32(&o.TIMER0_CFG1.Reg) & 0x7
}
func (o *MCPWM_Type) SetTIMER0_CFG1_TIMER0_MOD(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CFG1.Reg, volatile.LoadUint32(&o.TIMER0_CFG1.Reg)&^(0x18)|value<<3)
}
func (o *MCPWM_Type) GetTIMER0_CFG1_TIMER0_MOD() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CFG1.Reg) & 0x18) >> 3
}

// MCPWM.TIMER0_SYNC: PWM timer0 sync function configuration register.
func (o *MCPWM_Type) SetTIMER0_SYNC_TIMER0_SYNCI_EN(value uint32) {
	volatile.StoreUint32(&o.TIMER0_SYNC.Reg, volatile.LoadUint32(&o.TIMER0_SYNC.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetTIMER0_SYNC_TIMER0_SYNCI_EN() uint32 {
	return volatile.LoadUint32(&o.TIMER0_SYNC.Reg) & 0x1
}
func (o *MCPWM_Type) SetTIMER0_SYNC_SW(value uint32) {
	volatile.StoreUint32(&o.TIMER0_SYNC.Reg, volatile.LoadUint32(&o.TIMER0_SYNC.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetTIMER0_SYNC_SW() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_SYNC.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetTIMER0_SYNC_TIMER0_SYNCO_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMER0_SYNC.Reg, volatile.LoadUint32(&o.TIMER0_SYNC.Reg)&^(0xc)|value<<2)
}
func (o *MCPWM_Type) GetTIMER0_SYNC_TIMER0_SYNCO_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_SYNC.Reg) & 0xc) >> 2
}
func (o *MCPWM_Type) SetTIMER0_SYNC_TIMER0_PHASE(value uint32) {
	volatile.StoreUint32(&o.TIMER0_SYNC.Reg, volatile.LoadUint32(&o.TIMER0_SYNC.Reg)&^(0xffff0)|value<<4)
}
func (o *MCPWM_Type) GetTIMER0_SYNC_TIMER0_PHASE() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_SYNC.Reg) & 0xffff0) >> 4
}
func (o *MCPWM_Type) SetTIMER0_SYNC_TIMER0_PHASE_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.TIMER0_SYNC.Reg, volatile.LoadUint32(&o.TIMER0_SYNC.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetTIMER0_SYNC_TIMER0_PHASE_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_SYNC.Reg) & 0x100000) >> 20
}

// MCPWM.TIMER0_STATUS: PWM timer0 status register.
func (o *MCPWM_Type) SetTIMER0_STATUS_TIMER0_VALUE(value uint32) {
	volatile.StoreUint32(&o.TIMER0_STATUS.Reg, volatile.LoadUint32(&o.TIMER0_STATUS.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetTIMER0_STATUS_TIMER0_VALUE() uint32 {
	return volatile.LoadUint32(&o.TIMER0_STATUS.Reg) & 0xffff
}
func (o *MCPWM_Type) SetTIMER0_STATUS_TIMER0_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.TIMER0_STATUS.Reg, volatile.LoadUint32(&o.TIMER0_STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetTIMER0_STATUS_TIMER0_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_STATUS.Reg) & 0x10000) >> 16
}

// MCPWM.TIMER1_CFG0: PWM timer1 period and update method configuration register.
func (o *MCPWM_Type) SetTIMER1_CFG0_TIMER1_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CFG0.Reg, volatile.LoadUint32(&o.TIMER1_CFG0.Reg)&^(0xff)|value)
}
func (o *MCPWM_Type) GetTIMER1_CFG0_TIMER1_PRESCALE() uint32 {
	return volatile.LoadUint32(&o.TIMER1_CFG0.Reg) & 0xff
}
func (o *MCPWM_Type) SetTIMER1_CFG0_TIMER1_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CFG0.Reg, volatile.LoadUint32(&o.TIMER1_CFG0.Reg)&^(0xffff00)|value<<8)
}
func (o *MCPWM_Type) GetTIMER1_CFG0_TIMER1_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CFG0.Reg) & 0xffff00) >> 8
}
func (o *MCPWM_Type) SetTIMER1_CFG0_TIMER1_PERIOD_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CFG0.Reg, volatile.LoadUint32(&o.TIMER1_CFG0.Reg)&^(0x3000000)|value<<24)
}
func (o *MCPWM_Type) GetTIMER1_CFG0_TIMER1_PERIOD_UPMETHOD() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CFG0.Reg) & 0x3000000) >> 24
}

// MCPWM.TIMER1_CFG1: PWM timer1 working mode and start/stop control configuration register.
func (o *MCPWM_Type) SetTIMER1_CFG1_TIMER1_START(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CFG1.Reg, volatile.LoadUint32(&o.TIMER1_CFG1.Reg)&^(0x7)|value)
}
func (o *MCPWM_Type) GetTIMER1_CFG1_TIMER1_START() uint32 {
	return volatile.LoadUint32(&o.TIMER1_CFG1.Reg) & 0x7
}
func (o *MCPWM_Type) SetTIMER1_CFG1_TIMER1_MOD(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CFG1.Reg, volatile.LoadUint32(&o.TIMER1_CFG1.Reg)&^(0x18)|value<<3)
}
func (o *MCPWM_Type) GetTIMER1_CFG1_TIMER1_MOD() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CFG1.Reg) & 0x18) >> 3
}

// MCPWM.TIMER1_SYNC: PWM timer1 sync function configuration register.
func (o *MCPWM_Type) SetTIMER1_SYNC_TIMER1_SYNCI_EN(value uint32) {
	volatile.StoreUint32(&o.TIMER1_SYNC.Reg, volatile.LoadUint32(&o.TIMER1_SYNC.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetTIMER1_SYNC_TIMER1_SYNCI_EN() uint32 {
	return volatile.LoadUint32(&o.TIMER1_SYNC.Reg) & 0x1
}
func (o *MCPWM_Type) SetTIMER1_SYNC_SW(value uint32) {
	volatile.StoreUint32(&o.TIMER1_SYNC.Reg, volatile.LoadUint32(&o.TIMER1_SYNC.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetTIMER1_SYNC_SW() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_SYNC.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetTIMER1_SYNC_TIMER1_SYNCO_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMER1_SYNC.Reg, volatile.LoadUint32(&o.TIMER1_SYNC.Reg)&^(0xc)|value<<2)
}
func (o *MCPWM_Type) GetTIMER1_SYNC_TIMER1_SYNCO_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_SYNC.Reg) & 0xc) >> 2
}
func (o *MCPWM_Type) SetTIMER1_SYNC_TIMER1_PHASE(value uint32) {
	volatile.StoreUint32(&o.TIMER1_SYNC.Reg, volatile.LoadUint32(&o.TIMER1_SYNC.Reg)&^(0xffff0)|value<<4)
}
func (o *MCPWM_Type) GetTIMER1_SYNC_TIMER1_PHASE() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_SYNC.Reg) & 0xffff0) >> 4
}
func (o *MCPWM_Type) SetTIMER1_SYNC_TIMER1_PHASE_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.TIMER1_SYNC.Reg, volatile.LoadUint32(&o.TIMER1_SYNC.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetTIMER1_SYNC_TIMER1_PHASE_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_SYNC.Reg) & 0x100000) >> 20
}

// MCPWM.TIMER1_STATUS: PWM timer1 status register.
func (o *MCPWM_Type) SetTIMER1_STATUS_TIMER1_VALUE(value uint32) {
	volatile.StoreUint32(&o.TIMER1_STATUS.Reg, volatile.LoadUint32(&o.TIMER1_STATUS.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetTIMER1_STATUS_TIMER1_VALUE() uint32 {
	return volatile.LoadUint32(&o.TIMER1_STATUS.Reg) & 0xffff
}
func (o *MCPWM_Type) SetTIMER1_STATUS_TIMER1_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.TIMER1_STATUS.Reg, volatile.LoadUint32(&o.TIMER1_STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetTIMER1_STATUS_TIMER1_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_STATUS.Reg) & 0x10000) >> 16
}

// MCPWM.TIMER2_CFG0: PWM timer2 period and update method configuration register.
func (o *MCPWM_Type) SetTIMER2_CFG0_TIMER2_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CFG0.Reg, volatile.LoadUint32(&o.TIMER2_CFG0.Reg)&^(0xff)|value)
}
func (o *MCPWM_Type) GetTIMER2_CFG0_TIMER2_PRESCALE() uint32 {
	return volatile.LoadUint32(&o.TIMER2_CFG0.Reg) & 0xff
}
func (o *MCPWM_Type) SetTIMER2_CFG0_TIMER2_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CFG0.Reg, volatile.LoadUint32(&o.TIMER2_CFG0.Reg)&^(0xffff00)|value<<8)
}
func (o *MCPWM_Type) GetTIMER2_CFG0_TIMER2_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CFG0.Reg) & 0xffff00) >> 8
}
func (o *MCPWM_Type) SetTIMER2_CFG0_TIMER2_PERIOD_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CFG0.Reg, volatile.LoadUint32(&o.TIMER2_CFG0.Reg)&^(0x3000000)|value<<24)
}
func (o *MCPWM_Type) GetTIMER2_CFG0_TIMER2_PERIOD_UPMETHOD() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CFG0.Reg) & 0x3000000) >> 24
}

// MCPWM.TIMER2_CFG1: PWM timer2 working mode and start/stop control configuration register.
func (o *MCPWM_Type) SetTIMER2_CFG1_TIMER2_START(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CFG1.Reg, volatile.LoadUint32(&o.TIMER2_CFG1.Reg)&^(0x7)|value)
}
func (o *MCPWM_Type) GetTIMER2_CFG1_TIMER2_START() uint32 {
	return volatile.LoadUint32(&o.TIMER2_CFG1.Reg) & 0x7
}
func (o *MCPWM_Type) SetTIMER2_CFG1_TIMER2_MOD(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CFG1.Reg, volatile.LoadUint32(&o.TIMER2_CFG1.Reg)&^(0x18)|value<<3)
}
func (o *MCPWM_Type) GetTIMER2_CFG1_TIMER2_MOD() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CFG1.Reg) & 0x18) >> 3
}

// MCPWM.TIMER2_SYNC: PWM timer2 sync function configuration register.
func (o *MCPWM_Type) SetTIMER2_SYNC_TIMER2_SYNCI_EN(value uint32) {
	volatile.StoreUint32(&o.TIMER2_SYNC.Reg, volatile.LoadUint32(&o.TIMER2_SYNC.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetTIMER2_SYNC_TIMER2_SYNCI_EN() uint32 {
	return volatile.LoadUint32(&o.TIMER2_SYNC.Reg) & 0x1
}
func (o *MCPWM_Type) SetTIMER2_SYNC_SW(value uint32) {
	volatile.StoreUint32(&o.TIMER2_SYNC.Reg, volatile.LoadUint32(&o.TIMER2_SYNC.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetTIMER2_SYNC_SW() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_SYNC.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetTIMER2_SYNC_TIMER2_SYNCO_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMER2_SYNC.Reg, volatile.LoadUint32(&o.TIMER2_SYNC.Reg)&^(0xc)|value<<2)
}
func (o *MCPWM_Type) GetTIMER2_SYNC_TIMER2_SYNCO_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_SYNC.Reg) & 0xc) >> 2
}
func (o *MCPWM_Type) SetTIMER2_SYNC_TIMER2_PHASE(value uint32) {
	volatile.StoreUint32(&o.TIMER2_SYNC.Reg, volatile.LoadUint32(&o.TIMER2_SYNC.Reg)&^(0xffff0)|value<<4)
}
func (o *MCPWM_Type) GetTIMER2_SYNC_TIMER2_PHASE() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_SYNC.Reg) & 0xffff0) >> 4
}
func (o *MCPWM_Type) SetTIMER2_SYNC_TIMER2_PHASE_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.TIMER2_SYNC.Reg, volatile.LoadUint32(&o.TIMER2_SYNC.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetTIMER2_SYNC_TIMER2_PHASE_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_SYNC.Reg) & 0x100000) >> 20
}

// MCPWM.TIMER2_STATUS: PWM timer2 status register.
func (o *MCPWM_Type) SetTIMER2_STATUS_TIMER2_VALUE(value uint32) {
	volatile.StoreUint32(&o.TIMER2_STATUS.Reg, volatile.LoadUint32(&o.TIMER2_STATUS.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetTIMER2_STATUS_TIMER2_VALUE() uint32 {
	return volatile.LoadUint32(&o.TIMER2_STATUS.Reg) & 0xffff
}
func (o *MCPWM_Type) SetTIMER2_STATUS_TIMER2_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.TIMER2_STATUS.Reg, volatile.LoadUint32(&o.TIMER2_STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetTIMER2_STATUS_TIMER2_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_STATUS.Reg) & 0x10000) >> 16
}

// MCPWM.TIMER_SYNCI_CFG: Synchronization input selection for three PWM timers.
func (o *MCPWM_Type) SetTIMER_SYNCI_CFG_TIMER0_SYNCISEL(value uint32) {
	volatile.StoreUint32(&o.TIMER_SYNCI_CFG.Reg, volatile.LoadUint32(&o.TIMER_SYNCI_CFG.Reg)&^(0x7)|value)
}
func (o *MCPWM_Type) GetTIMER_SYNCI_CFG_TIMER0_SYNCISEL() uint32 {
	return volatile.LoadUint32(&o.TIMER_SYNCI_CFG.Reg) & 0x7
}
func (o *MCPWM_Type) SetTIMER_SYNCI_CFG_TIMER1_SYNCISEL(value uint32) {
	volatile.StoreUint32(&o.TIMER_SYNCI_CFG.Reg, volatile.LoadUint32(&o.TIMER_SYNCI_CFG.Reg)&^(0x38)|value<<3)
}
func (o *MCPWM_Type) GetTIMER_SYNCI_CFG_TIMER1_SYNCISEL() uint32 {
	return (volatile.LoadUint32(&o.TIMER_SYNCI_CFG.Reg) & 0x38) >> 3
}
func (o *MCPWM_Type) SetTIMER_SYNCI_CFG_TIMER2_SYNCISEL(value uint32) {
	volatile.StoreUint32(&o.TIMER_SYNCI_CFG.Reg, volatile.LoadUint32(&o.TIMER_SYNCI_CFG.Reg)&^(0x1c0)|value<<6)
}
func (o *MCPWM_Type) GetTIMER_SYNCI_CFG_TIMER2_SYNCISEL() uint32 {
	return (volatile.LoadUint32(&o.TIMER_SYNCI_CFG.Reg) & 0x1c0) >> 6
}
func (o *MCPWM_Type) SetTIMER_SYNCI_CFG_EXTERNAL_SYNCI0_INVERT(value uint32) {
	volatile.StoreUint32(&o.TIMER_SYNCI_CFG.Reg, volatile.LoadUint32(&o.TIMER_SYNCI_CFG.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetTIMER_SYNCI_CFG_EXTERNAL_SYNCI0_INVERT() uint32 {
	return (volatile.LoadUint32(&o.TIMER_SYNCI_CFG.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetTIMER_SYNCI_CFG_EXTERNAL_SYNCI1_INVERT(value uint32) {
	volatile.StoreUint32(&o.TIMER_SYNCI_CFG.Reg, volatile.LoadUint32(&o.TIMER_SYNCI_CFG.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetTIMER_SYNCI_CFG_EXTERNAL_SYNCI1_INVERT() uint32 {
	return (volatile.LoadUint32(&o.TIMER_SYNCI_CFG.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetTIMER_SYNCI_CFG_EXTERNAL_SYNCI2_INVERT(value uint32) {
	volatile.StoreUint32(&o.TIMER_SYNCI_CFG.Reg, volatile.LoadUint32(&o.TIMER_SYNCI_CFG.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetTIMER_SYNCI_CFG_EXTERNAL_SYNCI2_INVERT() uint32 {
	return (volatile.LoadUint32(&o.TIMER_SYNCI_CFG.Reg) & 0x800) >> 11
}

// MCPWM.OPERATOR_TIMERSEL: Select specific timer for PWM operators.
func (o *MCPWM_Type) SetOPERATOR_TIMERSEL_OPERATOR0_TIMERSEL(value uint32) {
	volatile.StoreUint32(&o.OPERATOR_TIMERSEL.Reg, volatile.LoadUint32(&o.OPERATOR_TIMERSEL.Reg)&^(0x3)|value)
}
func (o *MCPWM_Type) GetOPERATOR_TIMERSEL_OPERATOR0_TIMERSEL() uint32 {
	return volatile.LoadUint32(&o.OPERATOR_TIMERSEL.Reg) & 0x3
}
func (o *MCPWM_Type) SetOPERATOR_TIMERSEL_OPERATOR1_TIMERSEL(value uint32) {
	volatile.StoreUint32(&o.OPERATOR_TIMERSEL.Reg, volatile.LoadUint32(&o.OPERATOR_TIMERSEL.Reg)&^(0xc)|value<<2)
}
func (o *MCPWM_Type) GetOPERATOR_TIMERSEL_OPERATOR1_TIMERSEL() uint32 {
	return (volatile.LoadUint32(&o.OPERATOR_TIMERSEL.Reg) & 0xc) >> 2
}
func (o *MCPWM_Type) SetOPERATOR_TIMERSEL_OPERATOR2_TIMERSEL(value uint32) {
	volatile.StoreUint32(&o.OPERATOR_TIMERSEL.Reg, volatile.LoadUint32(&o.OPERATOR_TIMERSEL.Reg)&^(0x30)|value<<4)
}
func (o *MCPWM_Type) GetOPERATOR_TIMERSEL_OPERATOR2_TIMERSEL() uint32 {
	return (volatile.LoadUint32(&o.OPERATOR_TIMERSEL.Reg) & 0x30) >> 4
}

// MCPWM.GEN0_STMP_CFG: Transfer status and update method for time stamp registers A and B
func (o *MCPWM_Type) SetGEN0_STMP_CFG_CMPR0_A_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.GEN0_STMP_CFG.Reg, volatile.LoadUint32(&o.GEN0_STMP_CFG.Reg)&^(0xf)|value)
}
func (o *MCPWM_Type) GetGEN0_STMP_CFG_CMPR0_A_UPMETHOD() uint32 {
	return volatile.LoadUint32(&o.GEN0_STMP_CFG.Reg) & 0xf
}
func (o *MCPWM_Type) SetGEN0_STMP_CFG_CMPR0_B_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.GEN0_STMP_CFG.Reg, volatile.LoadUint32(&o.GEN0_STMP_CFG.Reg)&^(0xf0)|value<<4)
}
func (o *MCPWM_Type) GetGEN0_STMP_CFG_CMPR0_B_UPMETHOD() uint32 {
	return (volatile.LoadUint32(&o.GEN0_STMP_CFG.Reg) & 0xf0) >> 4
}
func (o *MCPWM_Type) SetGEN0_STMP_CFG_CMPR0_A_SHDW_FULL(value uint32) {
	volatile.StoreUint32(&o.GEN0_STMP_CFG.Reg, volatile.LoadUint32(&o.GEN0_STMP_CFG.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetGEN0_STMP_CFG_CMPR0_A_SHDW_FULL() uint32 {
	return (volatile.LoadUint32(&o.GEN0_STMP_CFG.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetGEN0_STMP_CFG_CMPR0_B_SHDW_FULL(value uint32) {
	volatile.StoreUint32(&o.GEN0_STMP_CFG.Reg, volatile.LoadUint32(&o.GEN0_STMP_CFG.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetGEN0_STMP_CFG_CMPR0_B_SHDW_FULL() uint32 {
	return (volatile.LoadUint32(&o.GEN0_STMP_CFG.Reg) & 0x200) >> 9
}

// MCPWM.GEN0_TSTMP_A: Shadow register for register A.
func (o *MCPWM_Type) SetGEN0_TSTMP_A_CMPR0_A(value uint32) {
	volatile.StoreUint32(&o.GEN0_TSTMP_A.Reg, volatile.LoadUint32(&o.GEN0_TSTMP_A.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetGEN0_TSTMP_A_CMPR0_A() uint32 {
	return volatile.LoadUint32(&o.GEN0_TSTMP_A.Reg) & 0xffff
}

// MCPWM.GEN0_TSTMP_B: Shadow register for register B.
func (o *MCPWM_Type) SetGEN0_TSTMP_B_CMPR0_B(value uint32) {
	volatile.StoreUint32(&o.GEN0_TSTMP_B.Reg, volatile.LoadUint32(&o.GEN0_TSTMP_B.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetGEN0_TSTMP_B_CMPR0_B() uint32 {
	return volatile.LoadUint32(&o.GEN0_TSTMP_B.Reg) & 0xffff
}

// MCPWM.GEN0_CFG0: Fault event T0 and T1 handling
func (o *MCPWM_Type) SetGEN0_CFG0_GEN0_CFG_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.GEN0_CFG0.Reg, volatile.LoadUint32(&o.GEN0_CFG0.Reg)&^(0xf)|value)
}
func (o *MCPWM_Type) GetGEN0_CFG0_GEN0_CFG_UPMETHOD() uint32 {
	return volatile.LoadUint32(&o.GEN0_CFG0.Reg) & 0xf
}
func (o *MCPWM_Type) SetGEN0_CFG0_GEN0_T0_SEL(value uint32) {
	volatile.StoreUint32(&o.GEN0_CFG0.Reg, volatile.LoadUint32(&o.GEN0_CFG0.Reg)&^(0x70)|value<<4)
}
func (o *MCPWM_Type) GetGEN0_CFG0_GEN0_T0_SEL() uint32 {
	return (volatile.LoadUint32(&o.GEN0_CFG0.Reg) & 0x70) >> 4
}
func (o *MCPWM_Type) SetGEN0_CFG0_GEN0_T1_SEL(value uint32) {
	volatile.StoreUint32(&o.GEN0_CFG0.Reg, volatile.LoadUint32(&o.GEN0_CFG0.Reg)&^(0x380)|value<<7)
}
func (o *MCPWM_Type) GetGEN0_CFG0_GEN0_T1_SEL() uint32 {
	return (volatile.LoadUint32(&o.GEN0_CFG0.Reg) & 0x380) >> 7
}

// MCPWM.GEN0_FORCE: Permissives to force PWM0A and PWM0B outputs by software
func (o *MCPWM_Type) SetGEN0_FORCE_GEN0_CNTUFORCE_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.GEN0_FORCE.Reg, volatile.LoadUint32(&o.GEN0_FORCE.Reg)&^(0x3f)|value)
}
func (o *MCPWM_Type) GetGEN0_FORCE_GEN0_CNTUFORCE_UPMETHOD() uint32 {
	return volatile.LoadUint32(&o.GEN0_FORCE.Reg) & 0x3f
}
func (o *MCPWM_Type) SetGEN0_FORCE_GEN0_A_CNTUFORCE_MODE(value uint32) {
	volatile.StoreUint32(&o.GEN0_FORCE.Reg, volatile.LoadUint32(&o.GEN0_FORCE.Reg)&^(0xc0)|value<<6)
}
func (o *MCPWM_Type) GetGEN0_FORCE_GEN0_A_CNTUFORCE_MODE() uint32 {
	return (volatile.LoadUint32(&o.GEN0_FORCE.Reg) & 0xc0) >> 6
}
func (o *MCPWM_Type) SetGEN0_FORCE_GEN0_B_CNTUFORCE_MODE(value uint32) {
	volatile.StoreUint32(&o.GEN0_FORCE.Reg, volatile.LoadUint32(&o.GEN0_FORCE.Reg)&^(0x300)|value<<8)
}
func (o *MCPWM_Type) GetGEN0_FORCE_GEN0_B_CNTUFORCE_MODE() uint32 {
	return (volatile.LoadUint32(&o.GEN0_FORCE.Reg) & 0x300) >> 8
}
func (o *MCPWM_Type) SetGEN0_FORCE_GEN0_A_NCIFORCE(value uint32) {
	volatile.StoreUint32(&o.GEN0_FORCE.Reg, volatile.LoadUint32(&o.GEN0_FORCE.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetGEN0_FORCE_GEN0_A_NCIFORCE() uint32 {
	return (volatile.LoadUint32(&o.GEN0_FORCE.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetGEN0_FORCE_GEN0_A_NCIFORCE_MODE(value uint32) {
	volatile.StoreUint32(&o.GEN0_FORCE.Reg, volatile.LoadUint32(&o.GEN0_FORCE.Reg)&^(0x1800)|value<<11)
}
func (o *MCPWM_Type) GetGEN0_FORCE_GEN0_A_NCIFORCE_MODE() uint32 {
	return (volatile.LoadUint32(&o.GEN0_FORCE.Reg) & 0x1800) >> 11
}
func (o *MCPWM_Type) SetGEN0_FORCE_GEN0_B_NCIFORCE(value uint32) {
	volatile.StoreUint32(&o.GEN0_FORCE.Reg, volatile.LoadUint32(&o.GEN0_FORCE.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetGEN0_FORCE_GEN0_B_NCIFORCE() uint32 {
	return (volatile.LoadUint32(&o.GEN0_FORCE.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetGEN0_FORCE_GEN0_B_NCIFORCE_MODE(value uint32) {
	volatile.StoreUint32(&o.GEN0_FORCE.Reg, volatile.LoadUint32(&o.GEN0_FORCE.Reg)&^(0xc000)|value<<14)
}
func (o *MCPWM_Type) GetGEN0_FORCE_GEN0_B_NCIFORCE_MODE() uint32 {
	return (volatile.LoadUint32(&o.GEN0_FORCE.Reg) & 0xc000) >> 14
}

// MCPWM.GEN0_A: Actions triggered by events on PWM0A
func (o *MCPWM_Type) SetGEN0_A_UTEZ(value uint32) {
	volatile.StoreUint32(&o.GEN0_A.Reg, volatile.LoadUint32(&o.GEN0_A.Reg)&^(0x3)|value)
}
func (o *MCPWM_Type) GetGEN0_A_UTEZ() uint32 {
	return volatile.LoadUint32(&o.GEN0_A.Reg) & 0x3
}
func (o *MCPWM_Type) SetGEN0_A_UTEP(value uint32) {
	volatile.StoreUint32(&o.GEN0_A.Reg, volatile.LoadUint32(&o.GEN0_A.Reg)&^(0xc)|value<<2)
}
func (o *MCPWM_Type) GetGEN0_A_UTEP() uint32 {
	return (volatile.LoadUint32(&o.GEN0_A.Reg) & 0xc) >> 2
}
func (o *MCPWM_Type) SetGEN0_A_UTEA(value uint32) {
	volatile.StoreUint32(&o.GEN0_A.Reg, volatile.LoadUint32(&o.GEN0_A.Reg)&^(0x30)|value<<4)
}
func (o *MCPWM_Type) GetGEN0_A_UTEA() uint32 {
	return (volatile.LoadUint32(&o.GEN0_A.Reg) & 0x30) >> 4
}
func (o *MCPWM_Type) SetGEN0_A_UTEB(value uint32) {
	volatile.StoreUint32(&o.GEN0_A.Reg, volatile.LoadUint32(&o.GEN0_A.Reg)&^(0xc0)|value<<6)
}
func (o *MCPWM_Type) GetGEN0_A_UTEB() uint32 {
	return (volatile.LoadUint32(&o.GEN0_A.Reg) & 0xc0) >> 6
}
func (o *MCPWM_Type) SetGEN0_A_UT0(value uint32) {
	volatile.StoreUint32(&o.GEN0_A.Reg, volatile.LoadUint32(&o.GEN0_A.Reg)&^(0x300)|value<<8)
}
func (o *MCPWM_Type) GetGEN0_A_UT0() uint32 {
	return (volatile.LoadUint32(&o.GEN0_A.Reg) & 0x300) >> 8
}
func (o *MCPWM_Type) SetGEN0_A_UT1(value uint32) {
	volatile.StoreUint32(&o.GEN0_A.Reg, volatile.LoadUint32(&o.GEN0_A.Reg)&^(0xc00)|value<<10)
}
func (o *MCPWM_Type) GetGEN0_A_UT1() uint32 {
	return (volatile.LoadUint32(&o.GEN0_A.Reg) & 0xc00) >> 10
}
func (o *MCPWM_Type) SetGEN0_A_DTEZ(value uint32) {
	volatile.StoreUint32(&o.GEN0_A.Reg, volatile.LoadUint32(&o.GEN0_A.Reg)&^(0x3000)|value<<12)
}
func (o *MCPWM_Type) GetGEN0_A_DTEZ() uint32 {
	return (volatile.LoadUint32(&o.GEN0_A.Reg) & 0x3000) >> 12
}
func (o *MCPWM_Type) SetGEN0_A_DTEP(value uint32) {
	volatile.StoreUint32(&o.GEN0_A.Reg, volatile.LoadUint32(&o.GEN0_A.Reg)&^(0xc000)|value<<14)
}
func (o *MCPWM_Type) GetGEN0_A_DTEP() uint32 {
	return (volatile.LoadUint32(&o.GEN0_A.Reg) & 0xc000) >> 14
}
func (o *MCPWM_Type) SetGEN0_A_DTEA(value uint32) {
	volatile.StoreUint32(&o.GEN0_A.Reg, volatile.LoadUint32(&o.GEN0_A.Reg)&^(0x30000)|value<<16)
}
func (o *MCPWM_Type) GetGEN0_A_DTEA() uint32 {
	return (volatile.LoadUint32(&o.GEN0_A.Reg) & 0x30000) >> 16
}
func (o *MCPWM_Type) SetGEN0_A_DTEB(value uint32) {
	volatile.StoreUint32(&o.GEN0_A.Reg, volatile.LoadUint32(&o.GEN0_A.Reg)&^(0xc0000)|value<<18)
}
func (o *MCPWM_Type) GetGEN0_A_DTEB() uint32 {
	return (volatile.LoadUint32(&o.GEN0_A.Reg) & 0xc0000) >> 18
}
func (o *MCPWM_Type) SetGEN0_A_DT0(value uint32) {
	volatile.StoreUint32(&o.GEN0_A.Reg, volatile.LoadUint32(&o.GEN0_A.Reg)&^(0x300000)|value<<20)
}
func (o *MCPWM_Type) GetGEN0_A_DT0() uint32 {
	return (volatile.LoadUint32(&o.GEN0_A.Reg) & 0x300000) >> 20
}
func (o *MCPWM_Type) SetGEN0_A_DT1(value uint32) {
	volatile.StoreUint32(&o.GEN0_A.Reg, volatile.LoadUint32(&o.GEN0_A.Reg)&^(0xc00000)|value<<22)
}
func (o *MCPWM_Type) GetGEN0_A_DT1() uint32 {
	return (volatile.LoadUint32(&o.GEN0_A.Reg) & 0xc00000) >> 22
}

// MCPWM.GEN0_B: Actions triggered by events on PWM0B
func (o *MCPWM_Type) SetGEN0_B_UTEZ(value uint32) {
	volatile.StoreUint32(&o.GEN0_B.Reg, volatile.LoadUint32(&o.GEN0_B.Reg)&^(0x3)|value)
}
func (o *MCPWM_Type) GetGEN0_B_UTEZ() uint32 {
	return volatile.LoadUint32(&o.GEN0_B.Reg) & 0x3
}
func (o *MCPWM_Type) SetGEN0_B_UTEP(value uint32) {
	volatile.StoreUint32(&o.GEN0_B.Reg, volatile.LoadUint32(&o.GEN0_B.Reg)&^(0xc)|value<<2)
}
func (o *MCPWM_Type) GetGEN0_B_UTEP() uint32 {
	return (volatile.LoadUint32(&o.GEN0_B.Reg) & 0xc) >> 2
}
func (o *MCPWM_Type) SetGEN0_B_UTEA(value uint32) {
	volatile.StoreUint32(&o.GEN0_B.Reg, volatile.LoadUint32(&o.GEN0_B.Reg)&^(0x30)|value<<4)
}
func (o *MCPWM_Type) GetGEN0_B_UTEA() uint32 {
	return (volatile.LoadUint32(&o.GEN0_B.Reg) & 0x30) >> 4
}
func (o *MCPWM_Type) SetGEN0_B_UTEB(value uint32) {
	volatile.StoreUint32(&o.GEN0_B.Reg, volatile.LoadUint32(&o.GEN0_B.Reg)&^(0xc0)|value<<6)
}
func (o *MCPWM_Type) GetGEN0_B_UTEB() uint32 {
	return (volatile.LoadUint32(&o.GEN0_B.Reg) & 0xc0) >> 6
}
func (o *MCPWM_Type) SetGEN0_B_UT0(value uint32) {
	volatile.StoreUint32(&o.GEN0_B.Reg, volatile.LoadUint32(&o.GEN0_B.Reg)&^(0x300)|value<<8)
}
func (o *MCPWM_Type) GetGEN0_B_UT0() uint32 {
	return (volatile.LoadUint32(&o.GEN0_B.Reg) & 0x300) >> 8
}
func (o *MCPWM_Type) SetGEN0_B_UT1(value uint32) {
	volatile.StoreUint32(&o.GEN0_B.Reg, volatile.LoadUint32(&o.GEN0_B.Reg)&^(0xc00)|value<<10)
}
func (o *MCPWM_Type) GetGEN0_B_UT1() uint32 {
	return (volatile.LoadUint32(&o.GEN0_B.Reg) & 0xc00) >> 10
}
func (o *MCPWM_Type) SetGEN0_B_DTEZ(value uint32) {
	volatile.StoreUint32(&o.GEN0_B.Reg, volatile.LoadUint32(&o.GEN0_B.Reg)&^(0x3000)|value<<12)
}
func (o *MCPWM_Type) GetGEN0_B_DTEZ() uint32 {
	return (volatile.LoadUint32(&o.GEN0_B.Reg) & 0x3000) >> 12
}
func (o *MCPWM_Type) SetGEN0_B_DTEP(value uint32) {
	volatile.StoreUint32(&o.GEN0_B.Reg, volatile.LoadUint32(&o.GEN0_B.Reg)&^(0xc000)|value<<14)
}
func (o *MCPWM_Type) GetGEN0_B_DTEP() uint32 {
	return (volatile.LoadUint32(&o.GEN0_B.Reg) & 0xc000) >> 14
}
func (o *MCPWM_Type) SetGEN0_B_DTEA(value uint32) {
	volatile.StoreUint32(&o.GEN0_B.Reg, volatile.LoadUint32(&o.GEN0_B.Reg)&^(0x30000)|value<<16)
}
func (o *MCPWM_Type) GetGEN0_B_DTEA() uint32 {
	return (volatile.LoadUint32(&o.GEN0_B.Reg) & 0x30000) >> 16
}
func (o *MCPWM_Type) SetGEN0_B_DTEB(value uint32) {
	volatile.StoreUint32(&o.GEN0_B.Reg, volatile.LoadUint32(&o.GEN0_B.Reg)&^(0xc0000)|value<<18)
}
func (o *MCPWM_Type) GetGEN0_B_DTEB() uint32 {
	return (volatile.LoadUint32(&o.GEN0_B.Reg) & 0xc0000) >> 18
}
func (o *MCPWM_Type) SetGEN0_B_DT0(value uint32) {
	volatile.StoreUint32(&o.GEN0_B.Reg, volatile.LoadUint32(&o.GEN0_B.Reg)&^(0x300000)|value<<20)
}
func (o *MCPWM_Type) GetGEN0_B_DT0() uint32 {
	return (volatile.LoadUint32(&o.GEN0_B.Reg) & 0x300000) >> 20
}
func (o *MCPWM_Type) SetGEN0_B_DT1(value uint32) {
	volatile.StoreUint32(&o.GEN0_B.Reg, volatile.LoadUint32(&o.GEN0_B.Reg)&^(0xc00000)|value<<22)
}
func (o *MCPWM_Type) GetGEN0_B_DT1() uint32 {
	return (volatile.LoadUint32(&o.GEN0_B.Reg) & 0xc00000) >> 22
}

// MCPWM.DT0_CFG: dead time type selection and configuration
func (o *MCPWM_Type) SetDT0_CFG_DB0_FED_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.DT0_CFG.Reg, volatile.LoadUint32(&o.DT0_CFG.Reg)&^(0xf)|value)
}
func (o *MCPWM_Type) GetDT0_CFG_DB0_FED_UPMETHOD() uint32 {
	return volatile.LoadUint32(&o.DT0_CFG.Reg) & 0xf
}
func (o *MCPWM_Type) SetDT0_CFG_DB0_RED_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.DT0_CFG.Reg, volatile.LoadUint32(&o.DT0_CFG.Reg)&^(0xf0)|value<<4)
}
func (o *MCPWM_Type) GetDT0_CFG_DB0_RED_UPMETHOD() uint32 {
	return (volatile.LoadUint32(&o.DT0_CFG.Reg) & 0xf0) >> 4
}
func (o *MCPWM_Type) SetDT0_CFG_DB0_DEB_MODE(value uint32) {
	volatile.StoreUint32(&o.DT0_CFG.Reg, volatile.LoadUint32(&o.DT0_CFG.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetDT0_CFG_DB0_DEB_MODE() uint32 {
	return (volatile.LoadUint32(&o.DT0_CFG.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetDT0_CFG_DB0_A_OUTSWAP(value uint32) {
	volatile.StoreUint32(&o.DT0_CFG.Reg, volatile.LoadUint32(&o.DT0_CFG.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetDT0_CFG_DB0_A_OUTSWAP() uint32 {
	return (volatile.LoadUint32(&o.DT0_CFG.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetDT0_CFG_DB0_B_OUTSWAP(value uint32) {
	volatile.StoreUint32(&o.DT0_CFG.Reg, volatile.LoadUint32(&o.DT0_CFG.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetDT0_CFG_DB0_B_OUTSWAP() uint32 {
	return (volatile.LoadUint32(&o.DT0_CFG.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetDT0_CFG_DB0_RED_INSEL(value uint32) {
	volatile.StoreUint32(&o.DT0_CFG.Reg, volatile.LoadUint32(&o.DT0_CFG.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetDT0_CFG_DB0_RED_INSEL() uint32 {
	return (volatile.LoadUint32(&o.DT0_CFG.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetDT0_CFG_DB0_FED_INSEL(value uint32) {
	volatile.StoreUint32(&o.DT0_CFG.Reg, volatile.LoadUint32(&o.DT0_CFG.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetDT0_CFG_DB0_FED_INSEL() uint32 {
	return (volatile.LoadUint32(&o.DT0_CFG.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetDT0_CFG_DB0_RED_OUTINVERT(value uint32) {
	volatile.StoreUint32(&o.DT0_CFG.Reg, volatile.LoadUint32(&o.DT0_CFG.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetDT0_CFG_DB0_RED_OUTINVERT() uint32 {
	return (volatile.LoadUint32(&o.DT0_CFG.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetDT0_CFG_DB0_FED_OUTINVERT(value uint32) {
	volatile.StoreUint32(&o.DT0_CFG.Reg, volatile.LoadUint32(&o.DT0_CFG.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetDT0_CFG_DB0_FED_OUTINVERT() uint32 {
	return (volatile.LoadUint32(&o.DT0_CFG.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetDT0_CFG_DB0_A_OUTBYPASS(value uint32) {
	volatile.StoreUint32(&o.DT0_CFG.Reg, volatile.LoadUint32(&o.DT0_CFG.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetDT0_CFG_DB0_A_OUTBYPASS() uint32 {
	return (volatile.LoadUint32(&o.DT0_CFG.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetDT0_CFG_DB0_B_OUTBYPASS(value uint32) {
	volatile.StoreUint32(&o.DT0_CFG.Reg, volatile.LoadUint32(&o.DT0_CFG.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetDT0_CFG_DB0_B_OUTBYPASS() uint32 {
	return (volatile.LoadUint32(&o.DT0_CFG.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetDT0_CFG_DB0_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.DT0_CFG.Reg, volatile.LoadUint32(&o.DT0_CFG.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetDT0_CFG_DB0_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.DT0_CFG.Reg) & 0x20000) >> 17
}

// MCPWM.DT0_FED_CFG: Shadow register for falling edge delay (FED).
func (o *MCPWM_Type) SetDT0_FED_CFG_DB0_FED(value uint32) {
	volatile.StoreUint32(&o.DT0_FED_CFG.Reg, volatile.LoadUint32(&o.DT0_FED_CFG.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetDT0_FED_CFG_DB0_FED() uint32 {
	return volatile.LoadUint32(&o.DT0_FED_CFG.Reg) & 0xffff
}

// MCPWM.DT0_RED_CFG: Shadow register for rising edge delay (RED).
func (o *MCPWM_Type) SetDT0_RED_CFG_DB0_RED(value uint32) {
	volatile.StoreUint32(&o.DT0_RED_CFG.Reg, volatile.LoadUint32(&o.DT0_RED_CFG.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetDT0_RED_CFG_DB0_RED() uint32 {
	return volatile.LoadUint32(&o.DT0_RED_CFG.Reg) & 0xffff
}

// MCPWM.CARRIER0_CFG: Carrier enable and configuratoin
func (o *MCPWM_Type) SetCARRIER0_CFG_CHOPPER0_EN(value uint32) {
	volatile.StoreUint32(&o.CARRIER0_CFG.Reg, volatile.LoadUint32(&o.CARRIER0_CFG.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCARRIER0_CFG_CHOPPER0_EN() uint32 {
	return volatile.LoadUint32(&o.CARRIER0_CFG.Reg) & 0x1
}
func (o *MCPWM_Type) SetCARRIER0_CFG_CHOPPER0_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.CARRIER0_CFG.Reg, volatile.LoadUint32(&o.CARRIER0_CFG.Reg)&^(0x1e)|value<<1)
}
func (o *MCPWM_Type) GetCARRIER0_CFG_CHOPPER0_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.CARRIER0_CFG.Reg) & 0x1e) >> 1
}
func (o *MCPWM_Type) SetCARRIER0_CFG_CHOPPER0_DUTY(value uint32) {
	volatile.StoreUint32(&o.CARRIER0_CFG.Reg, volatile.LoadUint32(&o.CARRIER0_CFG.Reg)&^(0xe0)|value<<5)
}
func (o *MCPWM_Type) GetCARRIER0_CFG_CHOPPER0_DUTY() uint32 {
	return (volatile.LoadUint32(&o.CARRIER0_CFG.Reg) & 0xe0) >> 5
}
func (o *MCPWM_Type) SetCARRIER0_CFG_CHOPPER0_OSHTWTH(value uint32) {
	volatile.StoreUint32(&o.CARRIER0_CFG.Reg, volatile.LoadUint32(&o.CARRIER0_CFG.Reg)&^(0xf00)|value<<8)
}
func (o *MCPWM_Type) GetCARRIER0_CFG_CHOPPER0_OSHTWTH() uint32 {
	return (volatile.LoadUint32(&o.CARRIER0_CFG.Reg) & 0xf00) >> 8
}
func (o *MCPWM_Type) SetCARRIER0_CFG_CHOPPER0_OUT_INVERT(value uint32) {
	volatile.StoreUint32(&o.CARRIER0_CFG.Reg, volatile.LoadUint32(&o.CARRIER0_CFG.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCARRIER0_CFG_CHOPPER0_OUT_INVERT() uint32 {
	return (volatile.LoadUint32(&o.CARRIER0_CFG.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCARRIER0_CFG_CHOPPER0_IN_INVERT(value uint32) {
	volatile.StoreUint32(&o.CARRIER0_CFG.Reg, volatile.LoadUint32(&o.CARRIER0_CFG.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCARRIER0_CFG_CHOPPER0_IN_INVERT() uint32 {
	return (volatile.LoadUint32(&o.CARRIER0_CFG.Reg) & 0x2000) >> 13
}

// MCPWM.FH0_CFG0: Actions on PWM0A and PWM0B trip events
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_SW_CBC(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_SW_CBC() uint32 {
	return volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0x1
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_F2_CBC(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_F2_CBC() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_F1_CBC(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_F1_CBC() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_F0_CBC(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_F0_CBC() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_SW_OST(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_SW_OST() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_F2_OST(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_F2_OST() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_F1_OST(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_F1_OST() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_F0_OST(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_F0_OST() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_A_CBC_D(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0x300)|value<<8)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_A_CBC_D() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0x300) >> 8
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_A_CBC_U(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0xc00)|value<<10)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_A_CBC_U() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0xc00) >> 10
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_A_OST_D(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0x3000)|value<<12)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_A_OST_D() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0x3000) >> 12
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_A_OST_U(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0xc000)|value<<14)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_A_OST_U() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0xc000) >> 14
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_B_CBC_D(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0x30000)|value<<16)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_B_CBC_D() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0x30000) >> 16
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_B_CBC_U(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0xc0000)|value<<18)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_B_CBC_U() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0xc0000) >> 18
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_B_OST_D(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0x300000)|value<<20)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_B_OST_D() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0x300000) >> 20
}
func (o *MCPWM_Type) SetFH0_CFG0_TZ0_B_OST_U(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG0.Reg, volatile.LoadUint32(&o.FH0_CFG0.Reg)&^(0xc00000)|value<<22)
}
func (o *MCPWM_Type) GetFH0_CFG0_TZ0_B_OST_U() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG0.Reg) & 0xc00000) >> 22
}

// MCPWM.FH0_CFG1: Software triggers for fault handler actions
func (o *MCPWM_Type) SetFH0_CFG1_TZ0_CLR_OST(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG1.Reg, volatile.LoadUint32(&o.FH0_CFG1.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetFH0_CFG1_TZ0_CLR_OST() uint32 {
	return volatile.LoadUint32(&o.FH0_CFG1.Reg) & 0x1
}
func (o *MCPWM_Type) SetFH0_CFG1_TZ0_CBCPULSE(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG1.Reg, volatile.LoadUint32(&o.FH0_CFG1.Reg)&^(0x6)|value<<1)
}
func (o *MCPWM_Type) GetFH0_CFG1_TZ0_CBCPULSE() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG1.Reg) & 0x6) >> 1
}
func (o *MCPWM_Type) SetFH0_CFG1_TZ0_FORCE_CBC(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG1.Reg, volatile.LoadUint32(&o.FH0_CFG1.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetFH0_CFG1_TZ0_FORCE_CBC() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG1.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetFH0_CFG1_TZ0_FORCE_OST(value uint32) {
	volatile.StoreUint32(&o.FH0_CFG1.Reg, volatile.LoadUint32(&o.FH0_CFG1.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetFH0_CFG1_TZ0_FORCE_OST() uint32 {
	return (volatile.LoadUint32(&o.FH0_CFG1.Reg) & 0x10) >> 4
}

// MCPWM.FH0_STATUS: Status of fault events.
func (o *MCPWM_Type) SetFH0_STATUS_TZ0_CBC_ON(value uint32) {
	volatile.StoreUint32(&o.FH0_STATUS.Reg, volatile.LoadUint32(&o.FH0_STATUS.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetFH0_STATUS_TZ0_CBC_ON() uint32 {
	return volatile.LoadUint32(&o.FH0_STATUS.Reg) & 0x1
}
func (o *MCPWM_Type) SetFH0_STATUS_TZ0_OST_ON(value uint32) {
	volatile.StoreUint32(&o.FH0_STATUS.Reg, volatile.LoadUint32(&o.FH0_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetFH0_STATUS_TZ0_OST_ON() uint32 {
	return (volatile.LoadUint32(&o.FH0_STATUS.Reg) & 0x2) >> 1
}

// MCPWM.GEN1_STMP_CFG: Transfer status and update method for time stamp registers A and B
func (o *MCPWM_Type) SetGEN1_STMP_CFG_CMPR1_A_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.GEN1_STMP_CFG.Reg, volatile.LoadUint32(&o.GEN1_STMP_CFG.Reg)&^(0xf)|value)
}
func (o *MCPWM_Type) GetGEN1_STMP_CFG_CMPR1_A_UPMETHOD() uint32 {
	return volatile.LoadUint32(&o.GEN1_STMP_CFG.Reg) & 0xf
}
func (o *MCPWM_Type) SetGEN1_STMP_CFG_CMPR1_B_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.GEN1_STMP_CFG.Reg, volatile.LoadUint32(&o.GEN1_STMP_CFG.Reg)&^(0xf0)|value<<4)
}
func (o *MCPWM_Type) GetGEN1_STMP_CFG_CMPR1_B_UPMETHOD() uint32 {
	return (volatile.LoadUint32(&o.GEN1_STMP_CFG.Reg) & 0xf0) >> 4
}
func (o *MCPWM_Type) SetGEN1_STMP_CFG_CMPR1_A_SHDW_FULL(value uint32) {
	volatile.StoreUint32(&o.GEN1_STMP_CFG.Reg, volatile.LoadUint32(&o.GEN1_STMP_CFG.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetGEN1_STMP_CFG_CMPR1_A_SHDW_FULL() uint32 {
	return (volatile.LoadUint32(&o.GEN1_STMP_CFG.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetGEN1_STMP_CFG_CMPR1_B_SHDW_FULL(value uint32) {
	volatile.StoreUint32(&o.GEN1_STMP_CFG.Reg, volatile.LoadUint32(&o.GEN1_STMP_CFG.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetGEN1_STMP_CFG_CMPR1_B_SHDW_FULL() uint32 {
	return (volatile.LoadUint32(&o.GEN1_STMP_CFG.Reg) & 0x200) >> 9
}

// MCPWM.GEN1_TSTMP_A: Shadow register for register A.
func (o *MCPWM_Type) SetGEN1_TSTMP_A_CMPR1_A(value uint32) {
	volatile.StoreUint32(&o.GEN1_TSTMP_A.Reg, volatile.LoadUint32(&o.GEN1_TSTMP_A.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetGEN1_TSTMP_A_CMPR1_A() uint32 {
	return volatile.LoadUint32(&o.GEN1_TSTMP_A.Reg) & 0xffff
}

// MCPWM.GEN1_TSTMP_B: Shadow register for register B.
func (o *MCPWM_Type) SetGEN1_TSTMP_B_CMPR1_B(value uint32) {
	volatile.StoreUint32(&o.GEN1_TSTMP_B.Reg, volatile.LoadUint32(&o.GEN1_TSTMP_B.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetGEN1_TSTMP_B_CMPR1_B() uint32 {
	return volatile.LoadUint32(&o.GEN1_TSTMP_B.Reg) & 0xffff
}

// MCPWM.GEN1_CFG0: Fault event T0 and T1 handling
func (o *MCPWM_Type) SetGEN1_CFG0_GEN1_CFG_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.GEN1_CFG0.Reg, volatile.LoadUint32(&o.GEN1_CFG0.Reg)&^(0xf)|value)
}
func (o *MCPWM_Type) GetGEN1_CFG0_GEN1_CFG_UPMETHOD() uint32 {
	return volatile.LoadUint32(&o.GEN1_CFG0.Reg) & 0xf
}
func (o *MCPWM_Type) SetGEN1_CFG0_GEN1_T0_SEL(value uint32) {
	volatile.StoreUint32(&o.GEN1_CFG0.Reg, volatile.LoadUint32(&o.GEN1_CFG0.Reg)&^(0x70)|value<<4)
}
func (o *MCPWM_Type) GetGEN1_CFG0_GEN1_T0_SEL() uint32 {
	return (volatile.LoadUint32(&o.GEN1_CFG0.Reg) & 0x70) >> 4
}
func (o *MCPWM_Type) SetGEN1_CFG0_GEN1_T1_SEL(value uint32) {
	volatile.StoreUint32(&o.GEN1_CFG0.Reg, volatile.LoadUint32(&o.GEN1_CFG0.Reg)&^(0x380)|value<<7)
}
func (o *MCPWM_Type) GetGEN1_CFG0_GEN1_T1_SEL() uint32 {
	return (volatile.LoadUint32(&o.GEN1_CFG0.Reg) & 0x380) >> 7
}

// MCPWM.GEN1_FORCE: Permissives to force PWM1A and PWM1B outputs by software
func (o *MCPWM_Type) SetGEN1_FORCE_GEN1_CNTUFORCE_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.GEN1_FORCE.Reg, volatile.LoadUint32(&o.GEN1_FORCE.Reg)&^(0x3f)|value)
}
func (o *MCPWM_Type) GetGEN1_FORCE_GEN1_CNTUFORCE_UPMETHOD() uint32 {
	return volatile.LoadUint32(&o.GEN1_FORCE.Reg) & 0x3f
}
func (o *MCPWM_Type) SetGEN1_FORCE_GEN1_A_CNTUFORCE_MODE(value uint32) {
	volatile.StoreUint32(&o.GEN1_FORCE.Reg, volatile.LoadUint32(&o.GEN1_FORCE.Reg)&^(0xc0)|value<<6)
}
func (o *MCPWM_Type) GetGEN1_FORCE_GEN1_A_CNTUFORCE_MODE() uint32 {
	return (volatile.LoadUint32(&o.GEN1_FORCE.Reg) & 0xc0) >> 6
}
func (o *MCPWM_Type) SetGEN1_FORCE_GEN1_B_CNTUFORCE_MODE(value uint32) {
	volatile.StoreUint32(&o.GEN1_FORCE.Reg, volatile.LoadUint32(&o.GEN1_FORCE.Reg)&^(0x300)|value<<8)
}
func (o *MCPWM_Type) GetGEN1_FORCE_GEN1_B_CNTUFORCE_MODE() uint32 {
	return (volatile.LoadUint32(&o.GEN1_FORCE.Reg) & 0x300) >> 8
}
func (o *MCPWM_Type) SetGEN1_FORCE_GEN1_A_NCIFORCE(value uint32) {
	volatile.StoreUint32(&o.GEN1_FORCE.Reg, volatile.LoadUint32(&o.GEN1_FORCE.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetGEN1_FORCE_GEN1_A_NCIFORCE() uint32 {
	return (volatile.LoadUint32(&o.GEN1_FORCE.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetGEN1_FORCE_GEN1_A_NCIFORCE_MODE(value uint32) {
	volatile.StoreUint32(&o.GEN1_FORCE.Reg, volatile.LoadUint32(&o.GEN1_FORCE.Reg)&^(0x1800)|value<<11)
}
func (o *MCPWM_Type) GetGEN1_FORCE_GEN1_A_NCIFORCE_MODE() uint32 {
	return (volatile.LoadUint32(&o.GEN1_FORCE.Reg) & 0x1800) >> 11
}
func (o *MCPWM_Type) SetGEN1_FORCE_GEN1_B_NCIFORCE(value uint32) {
	volatile.StoreUint32(&o.GEN1_FORCE.Reg, volatile.LoadUint32(&o.GEN1_FORCE.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetGEN1_FORCE_GEN1_B_NCIFORCE() uint32 {
	return (volatile.LoadUint32(&o.GEN1_FORCE.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetGEN1_FORCE_GEN1_B_NCIFORCE_MODE(value uint32) {
	volatile.StoreUint32(&o.GEN1_FORCE.Reg, volatile.LoadUint32(&o.GEN1_FORCE.Reg)&^(0xc000)|value<<14)
}
func (o *MCPWM_Type) GetGEN1_FORCE_GEN1_B_NCIFORCE_MODE() uint32 {
	return (volatile.LoadUint32(&o.GEN1_FORCE.Reg) & 0xc000) >> 14
}

// MCPWM.GEN1_A: Actions triggered by events on PWM1A
func (o *MCPWM_Type) SetGEN1_A_UTEZ(value uint32) {
	volatile.StoreUint32(&o.GEN1_A.Reg, volatile.LoadUint32(&o.GEN1_A.Reg)&^(0x3)|value)
}
func (o *MCPWM_Type) GetGEN1_A_UTEZ() uint32 {
	return volatile.LoadUint32(&o.GEN1_A.Reg) & 0x3
}
func (o *MCPWM_Type) SetGEN1_A_UTEP(value uint32) {
	volatile.StoreUint32(&o.GEN1_A.Reg, volatile.LoadUint32(&o.GEN1_A.Reg)&^(0xc)|value<<2)
}
func (o *MCPWM_Type) GetGEN1_A_UTEP() uint32 {
	return (volatile.LoadUint32(&o.GEN1_A.Reg) & 0xc) >> 2
}
func (o *MCPWM_Type) SetGEN1_A_UTEA(value uint32) {
	volatile.StoreUint32(&o.GEN1_A.Reg, volatile.LoadUint32(&o.GEN1_A.Reg)&^(0x30)|value<<4)
}
func (o *MCPWM_Type) GetGEN1_A_UTEA() uint32 {
	return (volatile.LoadUint32(&o.GEN1_A.Reg) & 0x30) >> 4
}
func (o *MCPWM_Type) SetGEN1_A_UTEB(value uint32) {
	volatile.StoreUint32(&o.GEN1_A.Reg, volatile.LoadUint32(&o.GEN1_A.Reg)&^(0xc0)|value<<6)
}
func (o *MCPWM_Type) GetGEN1_A_UTEB() uint32 {
	return (volatile.LoadUint32(&o.GEN1_A.Reg) & 0xc0) >> 6
}
func (o *MCPWM_Type) SetGEN1_A_UT0(value uint32) {
	volatile.StoreUint32(&o.GEN1_A.Reg, volatile.LoadUint32(&o.GEN1_A.Reg)&^(0x300)|value<<8)
}
func (o *MCPWM_Type) GetGEN1_A_UT0() uint32 {
	return (volatile.LoadUint32(&o.GEN1_A.Reg) & 0x300) >> 8
}
func (o *MCPWM_Type) SetGEN1_A_UT1(value uint32) {
	volatile.StoreUint32(&o.GEN1_A.Reg, volatile.LoadUint32(&o.GEN1_A.Reg)&^(0xc00)|value<<10)
}
func (o *MCPWM_Type) GetGEN1_A_UT1() uint32 {
	return (volatile.LoadUint32(&o.GEN1_A.Reg) & 0xc00) >> 10
}
func (o *MCPWM_Type) SetGEN1_A_DTEZ(value uint32) {
	volatile.StoreUint32(&o.GEN1_A.Reg, volatile.LoadUint32(&o.GEN1_A.Reg)&^(0x3000)|value<<12)
}
func (o *MCPWM_Type) GetGEN1_A_DTEZ() uint32 {
	return (volatile.LoadUint32(&o.GEN1_A.Reg) & 0x3000) >> 12
}
func (o *MCPWM_Type) SetGEN1_A_DTEP(value uint32) {
	volatile.StoreUint32(&o.GEN1_A.Reg, volatile.LoadUint32(&o.GEN1_A.Reg)&^(0xc000)|value<<14)
}
func (o *MCPWM_Type) GetGEN1_A_DTEP() uint32 {
	return (volatile.LoadUint32(&o.GEN1_A.Reg) & 0xc000) >> 14
}
func (o *MCPWM_Type) SetGEN1_A_DTEA(value uint32) {
	volatile.StoreUint32(&o.GEN1_A.Reg, volatile.LoadUint32(&o.GEN1_A.Reg)&^(0x30000)|value<<16)
}
func (o *MCPWM_Type) GetGEN1_A_DTEA() uint32 {
	return (volatile.LoadUint32(&o.GEN1_A.Reg) & 0x30000) >> 16
}
func (o *MCPWM_Type) SetGEN1_A_DTEB(value uint32) {
	volatile.StoreUint32(&o.GEN1_A.Reg, volatile.LoadUint32(&o.GEN1_A.Reg)&^(0xc0000)|value<<18)
}
func (o *MCPWM_Type) GetGEN1_A_DTEB() uint32 {
	return (volatile.LoadUint32(&o.GEN1_A.Reg) & 0xc0000) >> 18
}
func (o *MCPWM_Type) SetGEN1_A_DT0(value uint32) {
	volatile.StoreUint32(&o.GEN1_A.Reg, volatile.LoadUint32(&o.GEN1_A.Reg)&^(0x300000)|value<<20)
}
func (o *MCPWM_Type) GetGEN1_A_DT0() uint32 {
	return (volatile.LoadUint32(&o.GEN1_A.Reg) & 0x300000) >> 20
}
func (o *MCPWM_Type) SetGEN1_A_DT1(value uint32) {
	volatile.StoreUint32(&o.GEN1_A.Reg, volatile.LoadUint32(&o.GEN1_A.Reg)&^(0xc00000)|value<<22)
}
func (o *MCPWM_Type) GetGEN1_A_DT1() uint32 {
	return (volatile.LoadUint32(&o.GEN1_A.Reg) & 0xc00000) >> 22
}

// MCPWM.GEN1_B: Actions triggered by events on PWM1B
func (o *MCPWM_Type) SetGEN1_B_UTEZ(value uint32) {
	volatile.StoreUint32(&o.GEN1_B.Reg, volatile.LoadUint32(&o.GEN1_B.Reg)&^(0x3)|value)
}
func (o *MCPWM_Type) GetGEN1_B_UTEZ() uint32 {
	return volatile.LoadUint32(&o.GEN1_B.Reg) & 0x3
}
func (o *MCPWM_Type) SetGEN1_B_UTEP(value uint32) {
	volatile.StoreUint32(&o.GEN1_B.Reg, volatile.LoadUint32(&o.GEN1_B.Reg)&^(0xc)|value<<2)
}
func (o *MCPWM_Type) GetGEN1_B_UTEP() uint32 {
	return (volatile.LoadUint32(&o.GEN1_B.Reg) & 0xc) >> 2
}
func (o *MCPWM_Type) SetGEN1_B_UTEA(value uint32) {
	volatile.StoreUint32(&o.GEN1_B.Reg, volatile.LoadUint32(&o.GEN1_B.Reg)&^(0x30)|value<<4)
}
func (o *MCPWM_Type) GetGEN1_B_UTEA() uint32 {
	return (volatile.LoadUint32(&o.GEN1_B.Reg) & 0x30) >> 4
}
func (o *MCPWM_Type) SetGEN1_B_UTEB(value uint32) {
	volatile.StoreUint32(&o.GEN1_B.Reg, volatile.LoadUint32(&o.GEN1_B.Reg)&^(0xc0)|value<<6)
}
func (o *MCPWM_Type) GetGEN1_B_UTEB() uint32 {
	return (volatile.LoadUint32(&o.GEN1_B.Reg) & 0xc0) >> 6
}
func (o *MCPWM_Type) SetGEN1_B_UT0(value uint32) {
	volatile.StoreUint32(&o.GEN1_B.Reg, volatile.LoadUint32(&o.GEN1_B.Reg)&^(0x300)|value<<8)
}
func (o *MCPWM_Type) GetGEN1_B_UT0() uint32 {
	return (volatile.LoadUint32(&o.GEN1_B.Reg) & 0x300) >> 8
}
func (o *MCPWM_Type) SetGEN1_B_UT1(value uint32) {
	volatile.StoreUint32(&o.GEN1_B.Reg, volatile.LoadUint32(&o.GEN1_B.Reg)&^(0xc00)|value<<10)
}
func (o *MCPWM_Type) GetGEN1_B_UT1() uint32 {
	return (volatile.LoadUint32(&o.GEN1_B.Reg) & 0xc00) >> 10
}
func (o *MCPWM_Type) SetGEN1_B_DTEZ(value uint32) {
	volatile.StoreUint32(&o.GEN1_B.Reg, volatile.LoadUint32(&o.GEN1_B.Reg)&^(0x3000)|value<<12)
}
func (o *MCPWM_Type) GetGEN1_B_DTEZ() uint32 {
	return (volatile.LoadUint32(&o.GEN1_B.Reg) & 0x3000) >> 12
}
func (o *MCPWM_Type) SetGEN1_B_DTEP(value uint32) {
	volatile.StoreUint32(&o.GEN1_B.Reg, volatile.LoadUint32(&o.GEN1_B.Reg)&^(0xc000)|value<<14)
}
func (o *MCPWM_Type) GetGEN1_B_DTEP() uint32 {
	return (volatile.LoadUint32(&o.GEN1_B.Reg) & 0xc000) >> 14
}
func (o *MCPWM_Type) SetGEN1_B_DTEA(value uint32) {
	volatile.StoreUint32(&o.GEN1_B.Reg, volatile.LoadUint32(&o.GEN1_B.Reg)&^(0x30000)|value<<16)
}
func (o *MCPWM_Type) GetGEN1_B_DTEA() uint32 {
	return (volatile.LoadUint32(&o.GEN1_B.Reg) & 0x30000) >> 16
}
func (o *MCPWM_Type) SetGEN1_B_DTEB(value uint32) {
	volatile.StoreUint32(&o.GEN1_B.Reg, volatile.LoadUint32(&o.GEN1_B.Reg)&^(0xc0000)|value<<18)
}
func (o *MCPWM_Type) GetGEN1_B_DTEB() uint32 {
	return (volatile.LoadUint32(&o.GEN1_B.Reg) & 0xc0000) >> 18
}
func (o *MCPWM_Type) SetGEN1_B_DT0(value uint32) {
	volatile.StoreUint32(&o.GEN1_B.Reg, volatile.LoadUint32(&o.GEN1_B.Reg)&^(0x300000)|value<<20)
}
func (o *MCPWM_Type) GetGEN1_B_DT0() uint32 {
	return (volatile.LoadUint32(&o.GEN1_B.Reg) & 0x300000) >> 20
}
func (o *MCPWM_Type) SetGEN1_B_DT1(value uint32) {
	volatile.StoreUint32(&o.GEN1_B.Reg, volatile.LoadUint32(&o.GEN1_B.Reg)&^(0xc00000)|value<<22)
}
func (o *MCPWM_Type) GetGEN1_B_DT1() uint32 {
	return (volatile.LoadUint32(&o.GEN1_B.Reg) & 0xc00000) >> 22
}

// MCPWM.DT1_CFG: dead time type selection and configuration
func (o *MCPWM_Type) SetDT1_CFG_DB1_FED_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.DT1_CFG.Reg, volatile.LoadUint32(&o.DT1_CFG.Reg)&^(0xf)|value)
}
func (o *MCPWM_Type) GetDT1_CFG_DB1_FED_UPMETHOD() uint32 {
	return volatile.LoadUint32(&o.DT1_CFG.Reg) & 0xf
}
func (o *MCPWM_Type) SetDT1_CFG_DB1_RED_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.DT1_CFG.Reg, volatile.LoadUint32(&o.DT1_CFG.Reg)&^(0xf0)|value<<4)
}
func (o *MCPWM_Type) GetDT1_CFG_DB1_RED_UPMETHOD() uint32 {
	return (volatile.LoadUint32(&o.DT1_CFG.Reg) & 0xf0) >> 4
}
func (o *MCPWM_Type) SetDT1_CFG_DB1_DEB_MODE(value uint32) {
	volatile.StoreUint32(&o.DT1_CFG.Reg, volatile.LoadUint32(&o.DT1_CFG.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetDT1_CFG_DB1_DEB_MODE() uint32 {
	return (volatile.LoadUint32(&o.DT1_CFG.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetDT1_CFG_DB1_A_OUTSWAP(value uint32) {
	volatile.StoreUint32(&o.DT1_CFG.Reg, volatile.LoadUint32(&o.DT1_CFG.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetDT1_CFG_DB1_A_OUTSWAP() uint32 {
	return (volatile.LoadUint32(&o.DT1_CFG.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetDT1_CFG_DB1_B_OUTSWAP(value uint32) {
	volatile.StoreUint32(&o.DT1_CFG.Reg, volatile.LoadUint32(&o.DT1_CFG.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetDT1_CFG_DB1_B_OUTSWAP() uint32 {
	return (volatile.LoadUint32(&o.DT1_CFG.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetDT1_CFG_DB1_RED_INSEL(value uint32) {
	volatile.StoreUint32(&o.DT1_CFG.Reg, volatile.LoadUint32(&o.DT1_CFG.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetDT1_CFG_DB1_RED_INSEL() uint32 {
	return (volatile.LoadUint32(&o.DT1_CFG.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetDT1_CFG_DB1_FED_INSEL(value uint32) {
	volatile.StoreUint32(&o.DT1_CFG.Reg, volatile.LoadUint32(&o.DT1_CFG.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetDT1_CFG_DB1_FED_INSEL() uint32 {
	return (volatile.LoadUint32(&o.DT1_CFG.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetDT1_CFG_DB1_RED_OUTINVERT(value uint32) {
	volatile.StoreUint32(&o.DT1_CFG.Reg, volatile.LoadUint32(&o.DT1_CFG.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetDT1_CFG_DB1_RED_OUTINVERT() uint32 {
	return (volatile.LoadUint32(&o.DT1_CFG.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetDT1_CFG_DB1_FED_OUTINVERT(value uint32) {
	volatile.StoreUint32(&o.DT1_CFG.Reg, volatile.LoadUint32(&o.DT1_CFG.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetDT1_CFG_DB1_FED_OUTINVERT() uint32 {
	return (volatile.LoadUint32(&o.DT1_CFG.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetDT1_CFG_DB1_A_OUTBYPASS(value uint32) {
	volatile.StoreUint32(&o.DT1_CFG.Reg, volatile.LoadUint32(&o.DT1_CFG.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetDT1_CFG_DB1_A_OUTBYPASS() uint32 {
	return (volatile.LoadUint32(&o.DT1_CFG.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetDT1_CFG_DB1_B_OUTBYPASS(value uint32) {
	volatile.StoreUint32(&o.DT1_CFG.Reg, volatile.LoadUint32(&o.DT1_CFG.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetDT1_CFG_DB1_B_OUTBYPASS() uint32 {
	return (volatile.LoadUint32(&o.DT1_CFG.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetDT1_CFG_DB1_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.DT1_CFG.Reg, volatile.LoadUint32(&o.DT1_CFG.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetDT1_CFG_DB1_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.DT1_CFG.Reg) & 0x20000) >> 17
}

// MCPWM.DT1_FED_CFG: Shadow register for falling edge delay (FED).
func (o *MCPWM_Type) SetDT1_FED_CFG_DB1_FED(value uint32) {
	volatile.StoreUint32(&o.DT1_FED_CFG.Reg, volatile.LoadUint32(&o.DT1_FED_CFG.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetDT1_FED_CFG_DB1_FED() uint32 {
	return volatile.LoadUint32(&o.DT1_FED_CFG.Reg) & 0xffff
}

// MCPWM.DT1_RED_CFG: Shadow register for rising edge delay (RED).
func (o *MCPWM_Type) SetDT1_RED_CFG_DB1_RED(value uint32) {
	volatile.StoreUint32(&o.DT1_RED_CFG.Reg, volatile.LoadUint32(&o.DT1_RED_CFG.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetDT1_RED_CFG_DB1_RED() uint32 {
	return volatile.LoadUint32(&o.DT1_RED_CFG.Reg) & 0xffff
}

// MCPWM.CARRIER1_CFG: Carrier enable and configuratoin
func (o *MCPWM_Type) SetCARRIER1_CFG_CHOPPER1_EN(value uint32) {
	volatile.StoreUint32(&o.CARRIER1_CFG.Reg, volatile.LoadUint32(&o.CARRIER1_CFG.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCARRIER1_CFG_CHOPPER1_EN() uint32 {
	return volatile.LoadUint32(&o.CARRIER1_CFG.Reg) & 0x1
}
func (o *MCPWM_Type) SetCARRIER1_CFG_CHOPPER1_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.CARRIER1_CFG.Reg, volatile.LoadUint32(&o.CARRIER1_CFG.Reg)&^(0x1e)|value<<1)
}
func (o *MCPWM_Type) GetCARRIER1_CFG_CHOPPER1_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.CARRIER1_CFG.Reg) & 0x1e) >> 1
}
func (o *MCPWM_Type) SetCARRIER1_CFG_CHOPPER1_DUTY(value uint32) {
	volatile.StoreUint32(&o.CARRIER1_CFG.Reg, volatile.LoadUint32(&o.CARRIER1_CFG.Reg)&^(0xe0)|value<<5)
}
func (o *MCPWM_Type) GetCARRIER1_CFG_CHOPPER1_DUTY() uint32 {
	return (volatile.LoadUint32(&o.CARRIER1_CFG.Reg) & 0xe0) >> 5
}
func (o *MCPWM_Type) SetCARRIER1_CFG_CHOPPER1_OSHTWTH(value uint32) {
	volatile.StoreUint32(&o.CARRIER1_CFG.Reg, volatile.LoadUint32(&o.CARRIER1_CFG.Reg)&^(0xf00)|value<<8)
}
func (o *MCPWM_Type) GetCARRIER1_CFG_CHOPPER1_OSHTWTH() uint32 {
	return (volatile.LoadUint32(&o.CARRIER1_CFG.Reg) & 0xf00) >> 8
}
func (o *MCPWM_Type) SetCARRIER1_CFG_CHOPPER1_OUT_INVERT(value uint32) {
	volatile.StoreUint32(&o.CARRIER1_CFG.Reg, volatile.LoadUint32(&o.CARRIER1_CFG.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCARRIER1_CFG_CHOPPER1_OUT_INVERT() uint32 {
	return (volatile.LoadUint32(&o.CARRIER1_CFG.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCARRIER1_CFG_CHOPPER1_IN_INVERT(value uint32) {
	volatile.StoreUint32(&o.CARRIER1_CFG.Reg, volatile.LoadUint32(&o.CARRIER1_CFG.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCARRIER1_CFG_CHOPPER1_IN_INVERT() uint32 {
	return (volatile.LoadUint32(&o.CARRIER1_CFG.Reg) & 0x2000) >> 13
}

// MCPWM.FH1_CFG0: Actions on PWM1A and PWM1B trip events
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_SW_CBC(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_SW_CBC() uint32 {
	return volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0x1
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_F2_CBC(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_F2_CBC() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_F1_CBC(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_F1_CBC() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_F0_CBC(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_F0_CBC() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_SW_OST(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_SW_OST() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_F2_OST(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_F2_OST() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_F1_OST(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_F1_OST() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_F0_OST(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_F0_OST() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_A_CBC_D(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0x300)|value<<8)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_A_CBC_D() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0x300) >> 8
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_A_CBC_U(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0xc00)|value<<10)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_A_CBC_U() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0xc00) >> 10
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_A_OST_D(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0x3000)|value<<12)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_A_OST_D() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0x3000) >> 12
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_A_OST_U(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0xc000)|value<<14)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_A_OST_U() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0xc000) >> 14
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_B_CBC_D(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0x30000)|value<<16)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_B_CBC_D() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0x30000) >> 16
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_B_CBC_U(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0xc0000)|value<<18)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_B_CBC_U() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0xc0000) >> 18
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_B_OST_D(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0x300000)|value<<20)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_B_OST_D() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0x300000) >> 20
}
func (o *MCPWM_Type) SetFH1_CFG0_TZ1_B_OST_U(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG0.Reg, volatile.LoadUint32(&o.FH1_CFG0.Reg)&^(0xc00000)|value<<22)
}
func (o *MCPWM_Type) GetFH1_CFG0_TZ1_B_OST_U() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG0.Reg) & 0xc00000) >> 22
}

// MCPWM.FH1_CFG1: Software triggers for fault handler actions
func (o *MCPWM_Type) SetFH1_CFG1_TZ1_CLR_OST(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG1.Reg, volatile.LoadUint32(&o.FH1_CFG1.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetFH1_CFG1_TZ1_CLR_OST() uint32 {
	return volatile.LoadUint32(&o.FH1_CFG1.Reg) & 0x1
}
func (o *MCPWM_Type) SetFH1_CFG1_TZ1_CBCPULSE(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG1.Reg, volatile.LoadUint32(&o.FH1_CFG1.Reg)&^(0x6)|value<<1)
}
func (o *MCPWM_Type) GetFH1_CFG1_TZ1_CBCPULSE() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG1.Reg) & 0x6) >> 1
}
func (o *MCPWM_Type) SetFH1_CFG1_TZ1_FORCE_CBC(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG1.Reg, volatile.LoadUint32(&o.FH1_CFG1.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetFH1_CFG1_TZ1_FORCE_CBC() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG1.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetFH1_CFG1_TZ1_FORCE_OST(value uint32) {
	volatile.StoreUint32(&o.FH1_CFG1.Reg, volatile.LoadUint32(&o.FH1_CFG1.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetFH1_CFG1_TZ1_FORCE_OST() uint32 {
	return (volatile.LoadUint32(&o.FH1_CFG1.Reg) & 0x10) >> 4
}

// MCPWM.FH1_STATUS: Status of fault events.
func (o *MCPWM_Type) SetFH1_STATUS_TZ1_CBC_ON(value uint32) {
	volatile.StoreUint32(&o.FH1_STATUS.Reg, volatile.LoadUint32(&o.FH1_STATUS.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetFH1_STATUS_TZ1_CBC_ON() uint32 {
	return volatile.LoadUint32(&o.FH1_STATUS.Reg) & 0x1
}
func (o *MCPWM_Type) SetFH1_STATUS_TZ1_OST_ON(value uint32) {
	volatile.StoreUint32(&o.FH1_STATUS.Reg, volatile.LoadUint32(&o.FH1_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetFH1_STATUS_TZ1_OST_ON() uint32 {
	return (volatile.LoadUint32(&o.FH1_STATUS.Reg) & 0x2) >> 1
}

// MCPWM.GEN2_STMP_CFG: Transfer status and update method for time stamp registers A and B
func (o *MCPWM_Type) SetGEN2_STMP_CFG_CMPR2_A_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.GEN2_STMP_CFG.Reg, volatile.LoadUint32(&o.GEN2_STMP_CFG.Reg)&^(0xf)|value)
}
func (o *MCPWM_Type) GetGEN2_STMP_CFG_CMPR2_A_UPMETHOD() uint32 {
	return volatile.LoadUint32(&o.GEN2_STMP_CFG.Reg) & 0xf
}
func (o *MCPWM_Type) SetGEN2_STMP_CFG_CMPR2_B_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.GEN2_STMP_CFG.Reg, volatile.LoadUint32(&o.GEN2_STMP_CFG.Reg)&^(0xf0)|value<<4)
}
func (o *MCPWM_Type) GetGEN2_STMP_CFG_CMPR2_B_UPMETHOD() uint32 {
	return (volatile.LoadUint32(&o.GEN2_STMP_CFG.Reg) & 0xf0) >> 4
}
func (o *MCPWM_Type) SetGEN2_STMP_CFG_CMPR2_A_SHDW_FULL(value uint32) {
	volatile.StoreUint32(&o.GEN2_STMP_CFG.Reg, volatile.LoadUint32(&o.GEN2_STMP_CFG.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetGEN2_STMP_CFG_CMPR2_A_SHDW_FULL() uint32 {
	return (volatile.LoadUint32(&o.GEN2_STMP_CFG.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetGEN2_STMP_CFG_CMPR2_B_SHDW_FULL(value uint32) {
	volatile.StoreUint32(&o.GEN2_STMP_CFG.Reg, volatile.LoadUint32(&o.GEN2_STMP_CFG.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetGEN2_STMP_CFG_CMPR2_B_SHDW_FULL() uint32 {
	return (volatile.LoadUint32(&o.GEN2_STMP_CFG.Reg) & 0x200) >> 9
}

// MCPWM.GEN2_TSTMP_A: Shadow register for register A.
func (o *MCPWM_Type) SetGEN2_TSTMP_A_CMPR2_A(value uint32) {
	volatile.StoreUint32(&o.GEN2_TSTMP_A.Reg, volatile.LoadUint32(&o.GEN2_TSTMP_A.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetGEN2_TSTMP_A_CMPR2_A() uint32 {
	return volatile.LoadUint32(&o.GEN2_TSTMP_A.Reg) & 0xffff
}

// MCPWM.GEN2_TSTMP_B: Shadow register for register B.
func (o *MCPWM_Type) SetGEN2_TSTMP_B_CMPR2_B(value uint32) {
	volatile.StoreUint32(&o.GEN2_TSTMP_B.Reg, volatile.LoadUint32(&o.GEN2_TSTMP_B.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetGEN2_TSTMP_B_CMPR2_B() uint32 {
	return volatile.LoadUint32(&o.GEN2_TSTMP_B.Reg) & 0xffff
}

// MCPWM.GEN2_CFG0: Fault event T0 and T1 handling
func (o *MCPWM_Type) SetGEN2_CFG0_GEN2_CFG_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.GEN2_CFG0.Reg, volatile.LoadUint32(&o.GEN2_CFG0.Reg)&^(0xf)|value)
}
func (o *MCPWM_Type) GetGEN2_CFG0_GEN2_CFG_UPMETHOD() uint32 {
	return volatile.LoadUint32(&o.GEN2_CFG0.Reg) & 0xf
}
func (o *MCPWM_Type) SetGEN2_CFG0_GEN2_T0_SEL(value uint32) {
	volatile.StoreUint32(&o.GEN2_CFG0.Reg, volatile.LoadUint32(&o.GEN2_CFG0.Reg)&^(0x70)|value<<4)
}
func (o *MCPWM_Type) GetGEN2_CFG0_GEN2_T0_SEL() uint32 {
	return (volatile.LoadUint32(&o.GEN2_CFG0.Reg) & 0x70) >> 4
}
func (o *MCPWM_Type) SetGEN2_CFG0_GEN2_T1_SEL(value uint32) {
	volatile.StoreUint32(&o.GEN2_CFG0.Reg, volatile.LoadUint32(&o.GEN2_CFG0.Reg)&^(0x380)|value<<7)
}
func (o *MCPWM_Type) GetGEN2_CFG0_GEN2_T1_SEL() uint32 {
	return (volatile.LoadUint32(&o.GEN2_CFG0.Reg) & 0x380) >> 7
}

// MCPWM.GEN2_FORCE: Permissives to force PWM2A and PWM2B outputs by software
func (o *MCPWM_Type) SetGEN2_FORCE_GEN2_CNTUFORCE_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.GEN2_FORCE.Reg, volatile.LoadUint32(&o.GEN2_FORCE.Reg)&^(0x3f)|value)
}
func (o *MCPWM_Type) GetGEN2_FORCE_GEN2_CNTUFORCE_UPMETHOD() uint32 {
	return volatile.LoadUint32(&o.GEN2_FORCE.Reg) & 0x3f
}
func (o *MCPWM_Type) SetGEN2_FORCE_GEN2_A_CNTUFORCE_MODE(value uint32) {
	volatile.StoreUint32(&o.GEN2_FORCE.Reg, volatile.LoadUint32(&o.GEN2_FORCE.Reg)&^(0xc0)|value<<6)
}
func (o *MCPWM_Type) GetGEN2_FORCE_GEN2_A_CNTUFORCE_MODE() uint32 {
	return (volatile.LoadUint32(&o.GEN2_FORCE.Reg) & 0xc0) >> 6
}
func (o *MCPWM_Type) SetGEN2_FORCE_GEN2_B_CNTUFORCE_MODE(value uint32) {
	volatile.StoreUint32(&o.GEN2_FORCE.Reg, volatile.LoadUint32(&o.GEN2_FORCE.Reg)&^(0x300)|value<<8)
}
func (o *MCPWM_Type) GetGEN2_FORCE_GEN2_B_CNTUFORCE_MODE() uint32 {
	return (volatile.LoadUint32(&o.GEN2_FORCE.Reg) & 0x300) >> 8
}
func (o *MCPWM_Type) SetGEN2_FORCE_GEN2_A_NCIFORCE(value uint32) {
	volatile.StoreUint32(&o.GEN2_FORCE.Reg, volatile.LoadUint32(&o.GEN2_FORCE.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetGEN2_FORCE_GEN2_A_NCIFORCE() uint32 {
	return (volatile.LoadUint32(&o.GEN2_FORCE.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetGEN2_FORCE_GEN2_A_NCIFORCE_MODE(value uint32) {
	volatile.StoreUint32(&o.GEN2_FORCE.Reg, volatile.LoadUint32(&o.GEN2_FORCE.Reg)&^(0x1800)|value<<11)
}
func (o *MCPWM_Type) GetGEN2_FORCE_GEN2_A_NCIFORCE_MODE() uint32 {
	return (volatile.LoadUint32(&o.GEN2_FORCE.Reg) & 0x1800) >> 11
}
func (o *MCPWM_Type) SetGEN2_FORCE_GEN2_B_NCIFORCE(value uint32) {
	volatile.StoreUint32(&o.GEN2_FORCE.Reg, volatile.LoadUint32(&o.GEN2_FORCE.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetGEN2_FORCE_GEN2_B_NCIFORCE() uint32 {
	return (volatile.LoadUint32(&o.GEN2_FORCE.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetGEN2_FORCE_GEN2_B_NCIFORCE_MODE(value uint32) {
	volatile.StoreUint32(&o.GEN2_FORCE.Reg, volatile.LoadUint32(&o.GEN2_FORCE.Reg)&^(0xc000)|value<<14)
}
func (o *MCPWM_Type) GetGEN2_FORCE_GEN2_B_NCIFORCE_MODE() uint32 {
	return (volatile.LoadUint32(&o.GEN2_FORCE.Reg) & 0xc000) >> 14
}

// MCPWM.GEN2_A: Actions triggered by events on PWM2A
func (o *MCPWM_Type) SetGEN2_A_UTEZ(value uint32) {
	volatile.StoreUint32(&o.GEN2_A.Reg, volatile.LoadUint32(&o.GEN2_A.Reg)&^(0x3)|value)
}
func (o *MCPWM_Type) GetGEN2_A_UTEZ() uint32 {
	return volatile.LoadUint32(&o.GEN2_A.Reg) & 0x3
}
func (o *MCPWM_Type) SetGEN2_A_UTEP(value uint32) {
	volatile.StoreUint32(&o.GEN2_A.Reg, volatile.LoadUint32(&o.GEN2_A.Reg)&^(0xc)|value<<2)
}
func (o *MCPWM_Type) GetGEN2_A_UTEP() uint32 {
	return (volatile.LoadUint32(&o.GEN2_A.Reg) & 0xc) >> 2
}
func (o *MCPWM_Type) SetGEN2_A_UTEA(value uint32) {
	volatile.StoreUint32(&o.GEN2_A.Reg, volatile.LoadUint32(&o.GEN2_A.Reg)&^(0x30)|value<<4)
}
func (o *MCPWM_Type) GetGEN2_A_UTEA() uint32 {
	return (volatile.LoadUint32(&o.GEN2_A.Reg) & 0x30) >> 4
}
func (o *MCPWM_Type) SetGEN2_A_UTEB(value uint32) {
	volatile.StoreUint32(&o.GEN2_A.Reg, volatile.LoadUint32(&o.GEN2_A.Reg)&^(0xc0)|value<<6)
}
func (o *MCPWM_Type) GetGEN2_A_UTEB() uint32 {
	return (volatile.LoadUint32(&o.GEN2_A.Reg) & 0xc0) >> 6
}
func (o *MCPWM_Type) SetGEN2_A_UT0(value uint32) {
	volatile.StoreUint32(&o.GEN2_A.Reg, volatile.LoadUint32(&o.GEN2_A.Reg)&^(0x300)|value<<8)
}
func (o *MCPWM_Type) GetGEN2_A_UT0() uint32 {
	return (volatile.LoadUint32(&o.GEN2_A.Reg) & 0x300) >> 8
}
func (o *MCPWM_Type) SetGEN2_A_UT1(value uint32) {
	volatile.StoreUint32(&o.GEN2_A.Reg, volatile.LoadUint32(&o.GEN2_A.Reg)&^(0xc00)|value<<10)
}
func (o *MCPWM_Type) GetGEN2_A_UT1() uint32 {
	return (volatile.LoadUint32(&o.GEN2_A.Reg) & 0xc00) >> 10
}
func (o *MCPWM_Type) SetGEN2_A_DTEZ(value uint32) {
	volatile.StoreUint32(&o.GEN2_A.Reg, volatile.LoadUint32(&o.GEN2_A.Reg)&^(0x3000)|value<<12)
}
func (o *MCPWM_Type) GetGEN2_A_DTEZ() uint32 {
	return (volatile.LoadUint32(&o.GEN2_A.Reg) & 0x3000) >> 12
}
func (o *MCPWM_Type) SetGEN2_A_DTEP(value uint32) {
	volatile.StoreUint32(&o.GEN2_A.Reg, volatile.LoadUint32(&o.GEN2_A.Reg)&^(0xc000)|value<<14)
}
func (o *MCPWM_Type) GetGEN2_A_DTEP() uint32 {
	return (volatile.LoadUint32(&o.GEN2_A.Reg) & 0xc000) >> 14
}
func (o *MCPWM_Type) SetGEN2_A_DTEA(value uint32) {
	volatile.StoreUint32(&o.GEN2_A.Reg, volatile.LoadUint32(&o.GEN2_A.Reg)&^(0x30000)|value<<16)
}
func (o *MCPWM_Type) GetGEN2_A_DTEA() uint32 {
	return (volatile.LoadUint32(&o.GEN2_A.Reg) & 0x30000) >> 16
}
func (o *MCPWM_Type) SetGEN2_A_DTEB(value uint32) {
	volatile.StoreUint32(&o.GEN2_A.Reg, volatile.LoadUint32(&o.GEN2_A.Reg)&^(0xc0000)|value<<18)
}
func (o *MCPWM_Type) GetGEN2_A_DTEB() uint32 {
	return (volatile.LoadUint32(&o.GEN2_A.Reg) & 0xc0000) >> 18
}
func (o *MCPWM_Type) SetGEN2_A_DT0(value uint32) {
	volatile.StoreUint32(&o.GEN2_A.Reg, volatile.LoadUint32(&o.GEN2_A.Reg)&^(0x300000)|value<<20)
}
func (o *MCPWM_Type) GetGEN2_A_DT0() uint32 {
	return (volatile.LoadUint32(&o.GEN2_A.Reg) & 0x300000) >> 20
}
func (o *MCPWM_Type) SetGEN2_A_DT1(value uint32) {
	volatile.StoreUint32(&o.GEN2_A.Reg, volatile.LoadUint32(&o.GEN2_A.Reg)&^(0xc00000)|value<<22)
}
func (o *MCPWM_Type) GetGEN2_A_DT1() uint32 {
	return (volatile.LoadUint32(&o.GEN2_A.Reg) & 0xc00000) >> 22
}

// MCPWM.GEN2_B: Actions triggered by events on PWM2B
func (o *MCPWM_Type) SetGEN2_B_UTEZ(value uint32) {
	volatile.StoreUint32(&o.GEN2_B.Reg, volatile.LoadUint32(&o.GEN2_B.Reg)&^(0x3)|value)
}
func (o *MCPWM_Type) GetGEN2_B_UTEZ() uint32 {
	return volatile.LoadUint32(&o.GEN2_B.Reg) & 0x3
}
func (o *MCPWM_Type) SetGEN2_B_UTEP(value uint32) {
	volatile.StoreUint32(&o.GEN2_B.Reg, volatile.LoadUint32(&o.GEN2_B.Reg)&^(0xc)|value<<2)
}
func (o *MCPWM_Type) GetGEN2_B_UTEP() uint32 {
	return (volatile.LoadUint32(&o.GEN2_B.Reg) & 0xc) >> 2
}
func (o *MCPWM_Type) SetGEN2_B_UTEA(value uint32) {
	volatile.StoreUint32(&o.GEN2_B.Reg, volatile.LoadUint32(&o.GEN2_B.Reg)&^(0x30)|value<<4)
}
func (o *MCPWM_Type) GetGEN2_B_UTEA() uint32 {
	return (volatile.LoadUint32(&o.GEN2_B.Reg) & 0x30) >> 4
}
func (o *MCPWM_Type) SetGEN2_B_UTEB(value uint32) {
	volatile.StoreUint32(&o.GEN2_B.Reg, volatile.LoadUint32(&o.GEN2_B.Reg)&^(0xc0)|value<<6)
}
func (o *MCPWM_Type) GetGEN2_B_UTEB() uint32 {
	return (volatile.LoadUint32(&o.GEN2_B.Reg) & 0xc0) >> 6
}
func (o *MCPWM_Type) SetGEN2_B_UT0(value uint32) {
	volatile.StoreUint32(&o.GEN2_B.Reg, volatile.LoadUint32(&o.GEN2_B.Reg)&^(0x300)|value<<8)
}
func (o *MCPWM_Type) GetGEN2_B_UT0() uint32 {
	return (volatile.LoadUint32(&o.GEN2_B.Reg) & 0x300) >> 8
}
func (o *MCPWM_Type) SetGEN2_B_UT1(value uint32) {
	volatile.StoreUint32(&o.GEN2_B.Reg, volatile.LoadUint32(&o.GEN2_B.Reg)&^(0xc00)|value<<10)
}
func (o *MCPWM_Type) GetGEN2_B_UT1() uint32 {
	return (volatile.LoadUint32(&o.GEN2_B.Reg) & 0xc00) >> 10
}
func (o *MCPWM_Type) SetGEN2_B_DTEZ(value uint32) {
	volatile.StoreUint32(&o.GEN2_B.Reg, volatile.LoadUint32(&o.GEN2_B.Reg)&^(0x3000)|value<<12)
}
func (o *MCPWM_Type) GetGEN2_B_DTEZ() uint32 {
	return (volatile.LoadUint32(&o.GEN2_B.Reg) & 0x3000) >> 12
}
func (o *MCPWM_Type) SetGEN2_B_DTEP(value uint32) {
	volatile.StoreUint32(&o.GEN2_B.Reg, volatile.LoadUint32(&o.GEN2_B.Reg)&^(0xc000)|value<<14)
}
func (o *MCPWM_Type) GetGEN2_B_DTEP() uint32 {
	return (volatile.LoadUint32(&o.GEN2_B.Reg) & 0xc000) >> 14
}
func (o *MCPWM_Type) SetGEN2_B_DTEA(value uint32) {
	volatile.StoreUint32(&o.GEN2_B.Reg, volatile.LoadUint32(&o.GEN2_B.Reg)&^(0x30000)|value<<16)
}
func (o *MCPWM_Type) GetGEN2_B_DTEA() uint32 {
	return (volatile.LoadUint32(&o.GEN2_B.Reg) & 0x30000) >> 16
}
func (o *MCPWM_Type) SetGEN2_B_DTEB(value uint32) {
	volatile.StoreUint32(&o.GEN2_B.Reg, volatile.LoadUint32(&o.GEN2_B.Reg)&^(0xc0000)|value<<18)
}
func (o *MCPWM_Type) GetGEN2_B_DTEB() uint32 {
	return (volatile.LoadUint32(&o.GEN2_B.Reg) & 0xc0000) >> 18
}
func (o *MCPWM_Type) SetGEN2_B_DT0(value uint32) {
	volatile.StoreUint32(&o.GEN2_B.Reg, volatile.LoadUint32(&o.GEN2_B.Reg)&^(0x300000)|value<<20)
}
func (o *MCPWM_Type) GetGEN2_B_DT0() uint32 {
	return (volatile.LoadUint32(&o.GEN2_B.Reg) & 0x300000) >> 20
}
func (o *MCPWM_Type) SetGEN2_B_DT1(value uint32) {
	volatile.StoreUint32(&o.GEN2_B.Reg, volatile.LoadUint32(&o.GEN2_B.Reg)&^(0xc00000)|value<<22)
}
func (o *MCPWM_Type) GetGEN2_B_DT1() uint32 {
	return (volatile.LoadUint32(&o.GEN2_B.Reg) & 0xc00000) >> 22
}

// MCPWM.DT2_CFG: dead time type selection and configuration
func (o *MCPWM_Type) SetDT2_CFG_DB2_FED_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.DT2_CFG.Reg, volatile.LoadUint32(&o.DT2_CFG.Reg)&^(0xf)|value)
}
func (o *MCPWM_Type) GetDT2_CFG_DB2_FED_UPMETHOD() uint32 {
	return volatile.LoadUint32(&o.DT2_CFG.Reg) & 0xf
}
func (o *MCPWM_Type) SetDT2_CFG_DB2_RED_UPMETHOD(value uint32) {
	volatile.StoreUint32(&o.DT2_CFG.Reg, volatile.LoadUint32(&o.DT2_CFG.Reg)&^(0xf0)|value<<4)
}
func (o *MCPWM_Type) GetDT2_CFG_DB2_RED_UPMETHOD() uint32 {
	return (volatile.LoadUint32(&o.DT2_CFG.Reg) & 0xf0) >> 4
}
func (o *MCPWM_Type) SetDT2_CFG_DB2_DEB_MODE(value uint32) {
	volatile.StoreUint32(&o.DT2_CFG.Reg, volatile.LoadUint32(&o.DT2_CFG.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetDT2_CFG_DB2_DEB_MODE() uint32 {
	return (volatile.LoadUint32(&o.DT2_CFG.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetDT2_CFG_DB2_A_OUTSWAP(value uint32) {
	volatile.StoreUint32(&o.DT2_CFG.Reg, volatile.LoadUint32(&o.DT2_CFG.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetDT2_CFG_DB2_A_OUTSWAP() uint32 {
	return (volatile.LoadUint32(&o.DT2_CFG.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetDT2_CFG_DB2_B_OUTSWAP(value uint32) {
	volatile.StoreUint32(&o.DT2_CFG.Reg, volatile.LoadUint32(&o.DT2_CFG.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetDT2_CFG_DB2_B_OUTSWAP() uint32 {
	return (volatile.LoadUint32(&o.DT2_CFG.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetDT2_CFG_DB2_RED_INSEL(value uint32) {
	volatile.StoreUint32(&o.DT2_CFG.Reg, volatile.LoadUint32(&o.DT2_CFG.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetDT2_CFG_DB2_RED_INSEL() uint32 {
	return (volatile.LoadUint32(&o.DT2_CFG.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetDT2_CFG_DB2_FED_INSEL(value uint32) {
	volatile.StoreUint32(&o.DT2_CFG.Reg, volatile.LoadUint32(&o.DT2_CFG.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetDT2_CFG_DB2_FED_INSEL() uint32 {
	return (volatile.LoadUint32(&o.DT2_CFG.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetDT2_CFG_DB2_RED_OUTINVERT(value uint32) {
	volatile.StoreUint32(&o.DT2_CFG.Reg, volatile.LoadUint32(&o.DT2_CFG.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetDT2_CFG_DB2_RED_OUTINVERT() uint32 {
	return (volatile.LoadUint32(&o.DT2_CFG.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetDT2_CFG_DB2_FED_OUTINVERT(value uint32) {
	volatile.StoreUint32(&o.DT2_CFG.Reg, volatile.LoadUint32(&o.DT2_CFG.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetDT2_CFG_DB2_FED_OUTINVERT() uint32 {
	return (volatile.LoadUint32(&o.DT2_CFG.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetDT2_CFG_DB2_A_OUTBYPASS(value uint32) {
	volatile.StoreUint32(&o.DT2_CFG.Reg, volatile.LoadUint32(&o.DT2_CFG.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetDT2_CFG_DB2_A_OUTBYPASS() uint32 {
	return (volatile.LoadUint32(&o.DT2_CFG.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetDT2_CFG_DB2_B_OUTBYPASS(value uint32) {
	volatile.StoreUint32(&o.DT2_CFG.Reg, volatile.LoadUint32(&o.DT2_CFG.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetDT2_CFG_DB2_B_OUTBYPASS() uint32 {
	return (volatile.LoadUint32(&o.DT2_CFG.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetDT2_CFG_DB2_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.DT2_CFG.Reg, volatile.LoadUint32(&o.DT2_CFG.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetDT2_CFG_DB2_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.DT2_CFG.Reg) & 0x20000) >> 17
}

// MCPWM.DT2_FED_CFG: Shadow register for falling edge delay (FED).
func (o *MCPWM_Type) SetDT2_FED_CFG_DB2_FED(value uint32) {
	volatile.StoreUint32(&o.DT2_FED_CFG.Reg, volatile.LoadUint32(&o.DT2_FED_CFG.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetDT2_FED_CFG_DB2_FED() uint32 {
	return volatile.LoadUint32(&o.DT2_FED_CFG.Reg) & 0xffff
}

// MCPWM.DT2_RED_CFG: Shadow register for rising edge delay (RED).
func (o *MCPWM_Type) SetDT2_RED_CFG_DB2_RED(value uint32) {
	volatile.StoreUint32(&o.DT2_RED_CFG.Reg, volatile.LoadUint32(&o.DT2_RED_CFG.Reg)&^(0xffff)|value)
}
func (o *MCPWM_Type) GetDT2_RED_CFG_DB2_RED() uint32 {
	return volatile.LoadUint32(&o.DT2_RED_CFG.Reg) & 0xffff
}

// MCPWM.CARRIER2_CFG: Carrier enable and configuratoin
func (o *MCPWM_Type) SetCARRIER2_CFG_CHOPPER2_EN(value uint32) {
	volatile.StoreUint32(&o.CARRIER2_CFG.Reg, volatile.LoadUint32(&o.CARRIER2_CFG.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCARRIER2_CFG_CHOPPER2_EN() uint32 {
	return volatile.LoadUint32(&o.CARRIER2_CFG.Reg) & 0x1
}
func (o *MCPWM_Type) SetCARRIER2_CFG_CHOPPER2_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.CARRIER2_CFG.Reg, volatile.LoadUint32(&o.CARRIER2_CFG.Reg)&^(0x1e)|value<<1)
}
func (o *MCPWM_Type) GetCARRIER2_CFG_CHOPPER2_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.CARRIER2_CFG.Reg) & 0x1e) >> 1
}
func (o *MCPWM_Type) SetCARRIER2_CFG_CHOPPER2_DUTY(value uint32) {
	volatile.StoreUint32(&o.CARRIER2_CFG.Reg, volatile.LoadUint32(&o.CARRIER2_CFG.Reg)&^(0xe0)|value<<5)
}
func (o *MCPWM_Type) GetCARRIER2_CFG_CHOPPER2_DUTY() uint32 {
	return (volatile.LoadUint32(&o.CARRIER2_CFG.Reg) & 0xe0) >> 5
}
func (o *MCPWM_Type) SetCARRIER2_CFG_CHOPPER2_OSHTWTH(value uint32) {
	volatile.StoreUint32(&o.CARRIER2_CFG.Reg, volatile.LoadUint32(&o.CARRIER2_CFG.Reg)&^(0xf00)|value<<8)
}
func (o *MCPWM_Type) GetCARRIER2_CFG_CHOPPER2_OSHTWTH() uint32 {
	return (volatile.LoadUint32(&o.CARRIER2_CFG.Reg) & 0xf00) >> 8
}
func (o *MCPWM_Type) SetCARRIER2_CFG_CHOPPER2_OUT_INVERT(value uint32) {
	volatile.StoreUint32(&o.CARRIER2_CFG.Reg, volatile.LoadUint32(&o.CARRIER2_CFG.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCARRIER2_CFG_CHOPPER2_OUT_INVERT() uint32 {
	return (volatile.LoadUint32(&o.CARRIER2_CFG.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCARRIER2_CFG_CHOPPER2_IN_INVERT(value uint32) {
	volatile.StoreUint32(&o.CARRIER2_CFG.Reg, volatile.LoadUint32(&o.CARRIER2_CFG.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCARRIER2_CFG_CHOPPER2_IN_INVERT() uint32 {
	return (volatile.LoadUint32(&o.CARRIER2_CFG.Reg) & 0x2000) >> 13
}

// MCPWM.FH2_CFG0: Actions on PWM2A and PWM2B trip events
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_SW_CBC(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_SW_CBC() uint32 {
	return volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0x1
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_F2_CBC(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_F2_CBC() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_F1_CBC(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_F1_CBC() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_F0_CBC(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_F0_CBC() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_SW_OST(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_SW_OST() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_F2_OST(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_F2_OST() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_F1_OST(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_F1_OST() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_F0_OST(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_F0_OST() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_A_CBC_D(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0x300)|value<<8)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_A_CBC_D() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0x300) >> 8
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_A_CBC_U(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0xc00)|value<<10)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_A_CBC_U() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0xc00) >> 10
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_A_OST_D(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0x3000)|value<<12)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_A_OST_D() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0x3000) >> 12
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_A_OST_U(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0xc000)|value<<14)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_A_OST_U() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0xc000) >> 14
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_B_CBC_D(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0x30000)|value<<16)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_B_CBC_D() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0x30000) >> 16
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_B_CBC_U(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0xc0000)|value<<18)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_B_CBC_U() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0xc0000) >> 18
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_B_OST_D(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0x300000)|value<<20)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_B_OST_D() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0x300000) >> 20
}
func (o *MCPWM_Type) SetFH2_CFG0_TZ2_B_OST_U(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG0.Reg, volatile.LoadUint32(&o.FH2_CFG0.Reg)&^(0xc00000)|value<<22)
}
func (o *MCPWM_Type) GetFH2_CFG0_TZ2_B_OST_U() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG0.Reg) & 0xc00000) >> 22
}

// MCPWM.FH2_CFG1: Software triggers for fault handler actions
func (o *MCPWM_Type) SetFH2_CFG1_TZ2_CLR_OST(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG1.Reg, volatile.LoadUint32(&o.FH2_CFG1.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetFH2_CFG1_TZ2_CLR_OST() uint32 {
	return volatile.LoadUint32(&o.FH2_CFG1.Reg) & 0x1
}
func (o *MCPWM_Type) SetFH2_CFG1_TZ2_CBCPULSE(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG1.Reg, volatile.LoadUint32(&o.FH2_CFG1.Reg)&^(0x6)|value<<1)
}
func (o *MCPWM_Type) GetFH2_CFG1_TZ2_CBCPULSE() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG1.Reg) & 0x6) >> 1
}
func (o *MCPWM_Type) SetFH2_CFG1_TZ2_FORCE_CBC(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG1.Reg, volatile.LoadUint32(&o.FH2_CFG1.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetFH2_CFG1_TZ2_FORCE_CBC() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG1.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetFH2_CFG1_TZ2_FORCE_OST(value uint32) {
	volatile.StoreUint32(&o.FH2_CFG1.Reg, volatile.LoadUint32(&o.FH2_CFG1.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetFH2_CFG1_TZ2_FORCE_OST() uint32 {
	return (volatile.LoadUint32(&o.FH2_CFG1.Reg) & 0x10) >> 4
}

// MCPWM.FH2_STATUS: Status of fault events.
func (o *MCPWM_Type) SetFH2_STATUS_TZ2_CBC_ON(value uint32) {
	volatile.StoreUint32(&o.FH2_STATUS.Reg, volatile.LoadUint32(&o.FH2_STATUS.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetFH2_STATUS_TZ2_CBC_ON() uint32 {
	return volatile.LoadUint32(&o.FH2_STATUS.Reg) & 0x1
}
func (o *MCPWM_Type) SetFH2_STATUS_TZ2_OST_ON(value uint32) {
	volatile.StoreUint32(&o.FH2_STATUS.Reg, volatile.LoadUint32(&o.FH2_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetFH2_STATUS_TZ2_OST_ON() uint32 {
	return (volatile.LoadUint32(&o.FH2_STATUS.Reg) & 0x2) >> 1
}

// MCPWM.FAULT_DETECT: Fault detection configuration and status
func (o *MCPWM_Type) SetFAULT_DETECT_F0_EN(value uint32) {
	volatile.StoreUint32(&o.FAULT_DETECT.Reg, volatile.LoadUint32(&o.FAULT_DETECT.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetFAULT_DETECT_F0_EN() uint32 {
	return volatile.LoadUint32(&o.FAULT_DETECT.Reg) & 0x1
}
func (o *MCPWM_Type) SetFAULT_DETECT_F1_EN(value uint32) {
	volatile.StoreUint32(&o.FAULT_DETECT.Reg, volatile.LoadUint32(&o.FAULT_DETECT.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetFAULT_DETECT_F1_EN() uint32 {
	return (volatile.LoadUint32(&o.FAULT_DETECT.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetFAULT_DETECT_F2_EN(value uint32) {
	volatile.StoreUint32(&o.FAULT_DETECT.Reg, volatile.LoadUint32(&o.FAULT_DETECT.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetFAULT_DETECT_F2_EN() uint32 {
	return (volatile.LoadUint32(&o.FAULT_DETECT.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetFAULT_DETECT_F0_POLE(value uint32) {
	volatile.StoreUint32(&o.FAULT_DETECT.Reg, volatile.LoadUint32(&o.FAULT_DETECT.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetFAULT_DETECT_F0_POLE() uint32 {
	return (volatile.LoadUint32(&o.FAULT_DETECT.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetFAULT_DETECT_F1_POLE(value uint32) {
	volatile.StoreUint32(&o.FAULT_DETECT.Reg, volatile.LoadUint32(&o.FAULT_DETECT.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetFAULT_DETECT_F1_POLE() uint32 {
	return (volatile.LoadUint32(&o.FAULT_DETECT.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetFAULT_DETECT_F2_POLE(value uint32) {
	volatile.StoreUint32(&o.FAULT_DETECT.Reg, volatile.LoadUint32(&o.FAULT_DETECT.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetFAULT_DETECT_F2_POLE() uint32 {
	return (volatile.LoadUint32(&o.FAULT_DETECT.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetFAULT_DETECT_EVENT_F0(value uint32) {
	volatile.StoreUint32(&o.FAULT_DETECT.Reg, volatile.LoadUint32(&o.FAULT_DETECT.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetFAULT_DETECT_EVENT_F0() uint32 {
	return (volatile.LoadUint32(&o.FAULT_DETECT.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetFAULT_DETECT_EVENT_F1(value uint32) {
	volatile.StoreUint32(&o.FAULT_DETECT.Reg, volatile.LoadUint32(&o.FAULT_DETECT.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetFAULT_DETECT_EVENT_F1() uint32 {
	return (volatile.LoadUint32(&o.FAULT_DETECT.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetFAULT_DETECT_EVENT_F2(value uint32) {
	volatile.StoreUint32(&o.FAULT_DETECT.Reg, volatile.LoadUint32(&o.FAULT_DETECT.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetFAULT_DETECT_EVENT_F2() uint32 {
	return (volatile.LoadUint32(&o.FAULT_DETECT.Reg) & 0x100) >> 8
}

// MCPWM.CAP_TIMER_CFG: Configure capture timer
func (o *MCPWM_Type) SetCAP_TIMER_CFG_CAP_TIMER_EN(value uint32) {
	volatile.StoreUint32(&o.CAP_TIMER_CFG.Reg, volatile.LoadUint32(&o.CAP_TIMER_CFG.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCAP_TIMER_CFG_CAP_TIMER_EN() uint32 {
	return volatile.LoadUint32(&o.CAP_TIMER_CFG.Reg) & 0x1
}
func (o *MCPWM_Type) SetCAP_TIMER_CFG_CAP_SYNCI_EN(value uint32) {
	volatile.StoreUint32(&o.CAP_TIMER_CFG.Reg, volatile.LoadUint32(&o.CAP_TIMER_CFG.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCAP_TIMER_CFG_CAP_SYNCI_EN() uint32 {
	return (volatile.LoadUint32(&o.CAP_TIMER_CFG.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCAP_TIMER_CFG_CAP_SYNCI_SEL(value uint32) {
	volatile.StoreUint32(&o.CAP_TIMER_CFG.Reg, volatile.LoadUint32(&o.CAP_TIMER_CFG.Reg)&^(0x1c)|value<<2)
}
func (o *MCPWM_Type) GetCAP_TIMER_CFG_CAP_SYNCI_SEL() uint32 {
	return (volatile.LoadUint32(&o.CAP_TIMER_CFG.Reg) & 0x1c) >> 2
}
func (o *MCPWM_Type) SetCAP_TIMER_CFG_CAP_SYNC_SW(value uint32) {
	volatile.StoreUint32(&o.CAP_TIMER_CFG.Reg, volatile.LoadUint32(&o.CAP_TIMER_CFG.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCAP_TIMER_CFG_CAP_SYNC_SW() uint32 {
	return (volatile.LoadUint32(&o.CAP_TIMER_CFG.Reg) & 0x20) >> 5
}

// MCPWM.CAP_TIMER_PHASE: Phase for capture timer sync
func (o *MCPWM_Type) SetCAP_TIMER_PHASE(value uint32) {
	volatile.StoreUint32(&o.CAP_TIMER_PHASE.Reg, value)
}
func (o *MCPWM_Type) GetCAP_TIMER_PHASE() uint32 {
	return volatile.LoadUint32(&o.CAP_TIMER_PHASE.Reg)
}

// MCPWM.CAP_CH0_CFG: Capture channel 0 configuration and enable
func (o *MCPWM_Type) SetCAP_CH0_CFG_CAP0_EN(value uint32) {
	volatile.StoreUint32(&o.CAP_CH0_CFG.Reg, volatile.LoadUint32(&o.CAP_CH0_CFG.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCAP_CH0_CFG_CAP0_EN() uint32 {
	return volatile.LoadUint32(&o.CAP_CH0_CFG.Reg) & 0x1
}
func (o *MCPWM_Type) SetCAP_CH0_CFG_CAP0_MODE(value uint32) {
	volatile.StoreUint32(&o.CAP_CH0_CFG.Reg, volatile.LoadUint32(&o.CAP_CH0_CFG.Reg)&^(0x6)|value<<1)
}
func (o *MCPWM_Type) GetCAP_CH0_CFG_CAP0_MODE() uint32 {
	return (volatile.LoadUint32(&o.CAP_CH0_CFG.Reg) & 0x6) >> 1
}
func (o *MCPWM_Type) SetCAP_CH0_CFG_CAP0_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.CAP_CH0_CFG.Reg, volatile.LoadUint32(&o.CAP_CH0_CFG.Reg)&^(0x7f8)|value<<3)
}
func (o *MCPWM_Type) GetCAP_CH0_CFG_CAP0_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.CAP_CH0_CFG.Reg) & 0x7f8) >> 3
}
func (o *MCPWM_Type) SetCAP_CH0_CFG_CAP0_IN_INVERT(value uint32) {
	volatile.StoreUint32(&o.CAP_CH0_CFG.Reg, volatile.LoadUint32(&o.CAP_CH0_CFG.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCAP_CH0_CFG_CAP0_IN_INVERT() uint32 {
	return (volatile.LoadUint32(&o.CAP_CH0_CFG.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCAP_CH0_CFG_CAP0_SW(value uint32) {
	volatile.StoreUint32(&o.CAP_CH0_CFG.Reg, volatile.LoadUint32(&o.CAP_CH0_CFG.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCAP_CH0_CFG_CAP0_SW() uint32 {
	return (volatile.LoadUint32(&o.CAP_CH0_CFG.Reg) & 0x1000) >> 12
}

// MCPWM.CAP_CH1_CFG: Capture channel 1 configuration and enable
func (o *MCPWM_Type) SetCAP_CH1_CFG_CAP1_EN(value uint32) {
	volatile.StoreUint32(&o.CAP_CH1_CFG.Reg, volatile.LoadUint32(&o.CAP_CH1_CFG.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCAP_CH1_CFG_CAP1_EN() uint32 {
	return volatile.LoadUint32(&o.CAP_CH1_CFG.Reg) & 0x1
}
func (o *MCPWM_Type) SetCAP_CH1_CFG_CAP1_MODE(value uint32) {
	volatile.StoreUint32(&o.CAP_CH1_CFG.Reg, volatile.LoadUint32(&o.CAP_CH1_CFG.Reg)&^(0x6)|value<<1)
}
func (o *MCPWM_Type) GetCAP_CH1_CFG_CAP1_MODE() uint32 {
	return (volatile.LoadUint32(&o.CAP_CH1_CFG.Reg) & 0x6) >> 1
}
func (o *MCPWM_Type) SetCAP_CH1_CFG_CAP1_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.CAP_CH1_CFG.Reg, volatile.LoadUint32(&o.CAP_CH1_CFG.Reg)&^(0x7f8)|value<<3)
}
func (o *MCPWM_Type) GetCAP_CH1_CFG_CAP1_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.CAP_CH1_CFG.Reg) & 0x7f8) >> 3
}
func (o *MCPWM_Type) SetCAP_CH1_CFG_CAP1_IN_INVERT(value uint32) {
	volatile.StoreUint32(&o.CAP_CH1_CFG.Reg, volatile.LoadUint32(&o.CAP_CH1_CFG.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCAP_CH1_CFG_CAP1_IN_INVERT() uint32 {
	return (volatile.LoadUint32(&o.CAP_CH1_CFG.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCAP_CH1_CFG_CAP1_SW(value uint32) {
	volatile.StoreUint32(&o.CAP_CH1_CFG.Reg, volatile.LoadUint32(&o.CAP_CH1_CFG.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCAP_CH1_CFG_CAP1_SW() uint32 {
	return (volatile.LoadUint32(&o.CAP_CH1_CFG.Reg) & 0x1000) >> 12
}

// MCPWM.CAP_CH2_CFG: Capture channel 2 configuration and enable
func (o *MCPWM_Type) SetCAP_CH2_CFG_CAP2_EN(value uint32) {
	volatile.StoreUint32(&o.CAP_CH2_CFG.Reg, volatile.LoadUint32(&o.CAP_CH2_CFG.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCAP_CH2_CFG_CAP2_EN() uint32 {
	return volatile.LoadUint32(&o.CAP_CH2_CFG.Reg) & 0x1
}
func (o *MCPWM_Type) SetCAP_CH2_CFG_CAP2_MODE(value uint32) {
	volatile.StoreUint32(&o.CAP_CH2_CFG.Reg, volatile.LoadUint32(&o.CAP_CH2_CFG.Reg)&^(0x6)|value<<1)
}
func (o *MCPWM_Type) GetCAP_CH2_CFG_CAP2_MODE() uint32 {
	return (volatile.LoadUint32(&o.CAP_CH2_CFG.Reg) & 0x6) >> 1
}
func (o *MCPWM_Type) SetCAP_CH2_CFG_CAP2_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.CAP_CH2_CFG.Reg, volatile.LoadUint32(&o.CAP_CH2_CFG.Reg)&^(0x7f8)|value<<3)
}
func (o *MCPWM_Type) GetCAP_CH2_CFG_CAP2_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.CAP_CH2_CFG.Reg) & 0x7f8) >> 3
}
func (o *MCPWM_Type) SetCAP_CH2_CFG_CAP2_IN_INVERT(value uint32) {
	volatile.StoreUint32(&o.CAP_CH2_CFG.Reg, volatile.LoadUint32(&o.CAP_CH2_CFG.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCAP_CH2_CFG_CAP2_IN_INVERT() uint32 {
	return (volatile.LoadUint32(&o.CAP_CH2_CFG.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCAP_CH2_CFG_CAP2_SW(value uint32) {
	volatile.StoreUint32(&o.CAP_CH2_CFG.Reg, volatile.LoadUint32(&o.CAP_CH2_CFG.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCAP_CH2_CFG_CAP2_SW() uint32 {
	return (volatile.LoadUint32(&o.CAP_CH2_CFG.Reg) & 0x1000) >> 12
}

// MCPWM.CAP_CH0: ch0 capture value status register
func (o *MCPWM_Type) SetCAP_CH0(value uint32) {
	volatile.StoreUint32(&o.CAP_CH0.Reg, value)
}
func (o *MCPWM_Type) GetCAP_CH0() uint32 {
	return volatile.LoadUint32(&o.CAP_CH0.Reg)
}

// MCPWM.CAP_CH1: ch1 capture value status register
func (o *MCPWM_Type) SetCAP_CH1(value uint32) {
	volatile.StoreUint32(&o.CAP_CH1.Reg, value)
}
func (o *MCPWM_Type) GetCAP_CH1() uint32 {
	return volatile.LoadUint32(&o.CAP_CH1.Reg)
}

// MCPWM.CAP_CH2: ch2 capture value status register
func (o *MCPWM_Type) SetCAP_CH2(value uint32) {
	volatile.StoreUint32(&o.CAP_CH2.Reg, value)
}
func (o *MCPWM_Type) GetCAP_CH2() uint32 {
	return volatile.LoadUint32(&o.CAP_CH2.Reg)
}

// MCPWM.CAP_STATUS: Edge of last capture trigger
func (o *MCPWM_Type) SetCAP_STATUS_CAP0_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP_STATUS.Reg, volatile.LoadUint32(&o.CAP_STATUS.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCAP_STATUS_CAP0_EDGE() uint32 {
	return volatile.LoadUint32(&o.CAP_STATUS.Reg) & 0x1
}
func (o *MCPWM_Type) SetCAP_STATUS_CAP1_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP_STATUS.Reg, volatile.LoadUint32(&o.CAP_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCAP_STATUS_CAP1_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP_STATUS.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCAP_STATUS_CAP2_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP_STATUS.Reg, volatile.LoadUint32(&o.CAP_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCAP_STATUS_CAP2_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP_STATUS.Reg) & 0x4) >> 2
}

// MCPWM.UPDATE_CFG: Enable update.
func (o *MCPWM_Type) SetUPDATE_CFG_GLOBAL_UP_EN(value uint32) {
	volatile.StoreUint32(&o.UPDATE_CFG.Reg, volatile.LoadUint32(&o.UPDATE_CFG.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetUPDATE_CFG_GLOBAL_UP_EN() uint32 {
	return volatile.LoadUint32(&o.UPDATE_CFG.Reg) & 0x1
}
func (o *MCPWM_Type) SetUPDATE_CFG_GLOBAL_FORCE_UP(value uint32) {
	volatile.StoreUint32(&o.UPDATE_CFG.Reg, volatile.LoadUint32(&o.UPDATE_CFG.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetUPDATE_CFG_GLOBAL_FORCE_UP() uint32 {
	return (volatile.LoadUint32(&o.UPDATE_CFG.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetUPDATE_CFG_OP0_UP_EN(value uint32) {
	volatile.StoreUint32(&o.UPDATE_CFG.Reg, volatile.LoadUint32(&o.UPDATE_CFG.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetUPDATE_CFG_OP0_UP_EN() uint32 {
	return (volatile.LoadUint32(&o.UPDATE_CFG.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetUPDATE_CFG_OP0_FORCE_UP(value uint32) {
	volatile.StoreUint32(&o.UPDATE_CFG.Reg, volatile.LoadUint32(&o.UPDATE_CFG.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetUPDATE_CFG_OP0_FORCE_UP() uint32 {
	return (volatile.LoadUint32(&o.UPDATE_CFG.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetUPDATE_CFG_OP1_UP_EN(value uint32) {
	volatile.StoreUint32(&o.UPDATE_CFG.Reg, volatile.LoadUint32(&o.UPDATE_CFG.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetUPDATE_CFG_OP1_UP_EN() uint32 {
	return (volatile.LoadUint32(&o.UPDATE_CFG.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetUPDATE_CFG_OP1_FORCE_UP(value uint32) {
	volatile.StoreUint32(&o.UPDATE_CFG.Reg, volatile.LoadUint32(&o.UPDATE_CFG.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetUPDATE_CFG_OP1_FORCE_UP() uint32 {
	return (volatile.LoadUint32(&o.UPDATE_CFG.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetUPDATE_CFG_OP2_UP_EN(value uint32) {
	volatile.StoreUint32(&o.UPDATE_CFG.Reg, volatile.LoadUint32(&o.UPDATE_CFG.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetUPDATE_CFG_OP2_UP_EN() uint32 {
	return (volatile.LoadUint32(&o.UPDATE_CFG.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetUPDATE_CFG_OP2_FORCE_UP(value uint32) {
	volatile.StoreUint32(&o.UPDATE_CFG.Reg, volatile.LoadUint32(&o.UPDATE_CFG.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetUPDATE_CFG_OP2_FORCE_UP() uint32 {
	return (volatile.LoadUint32(&o.UPDATE_CFG.Reg) & 0x80) >> 7
}

// MCPWM.INT_ENA: Interrupt enable bits
func (o *MCPWM_Type) SetINT_ENA_TIMER0_STOP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINT_ENA_TIMER0_STOP_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *MCPWM_Type) SetINT_ENA_TIMER1_STOP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINT_ENA_TIMER1_STOP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINT_ENA_TIMER2_STOP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINT_ENA_TIMER2_STOP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINT_ENA_TIMER0_TEZ_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINT_ENA_TIMER0_TEZ_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINT_ENA_TIMER1_TEZ_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINT_ENA_TIMER1_TEZ_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINT_ENA_TIMER2_TEZ_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINT_ENA_TIMER2_TEZ_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINT_ENA_TIMER0_TEP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINT_ENA_TIMER0_TEP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINT_ENA_TIMER1_TEP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINT_ENA_TIMER1_TEP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINT_ENA_TIMER2_TEP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINT_ENA_TIMER2_TEP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINT_ENA_FAULT0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINT_ENA_FAULT0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINT_ENA_FAULT1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINT_ENA_FAULT1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINT_ENA_FAULT2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetINT_ENA_FAULT2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetINT_ENA_FAULT0_CLR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetINT_ENA_FAULT0_CLR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetINT_ENA_FAULT1_CLR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetINT_ENA_FAULT1_CLR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetINT_ENA_FAULT2_CLR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetINT_ENA_FAULT2_CLR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetINT_ENA_CMPR0_TEA_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINT_ENA_CMPR0_TEA_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINT_ENA_CMPR1_TEA_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetINT_ENA_CMPR1_TEA_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetINT_ENA_CMPR2_TEA_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetINT_ENA_CMPR2_TEA_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetINT_ENA_CMPR0_TEB_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetINT_ENA_CMPR0_TEB_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetINT_ENA_CMPR1_TEB_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetINT_ENA_CMPR1_TEB_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetINT_ENA_CMPR2_TEB_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetINT_ENA_CMPR2_TEB_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetINT_ENA_TZ0_CBC_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200000)|value<<21)
}
func (o *MCPWM_Type) GetINT_ENA_TZ0_CBC_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200000) >> 21
}
func (o *MCPWM_Type) SetINT_ENA_TZ1_CBC_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400000)|value<<22)
}
func (o *MCPWM_Type) GetINT_ENA_TZ1_CBC_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400000) >> 22
}
func (o *MCPWM_Type) SetINT_ENA_TZ2_CBC_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800000)|value<<23)
}
func (o *MCPWM_Type) GetINT_ENA_TZ2_CBC_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800000) >> 23
}
func (o *MCPWM_Type) SetINT_ENA_TZ0_OST_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000000)|value<<24)
}
func (o *MCPWM_Type) GetINT_ENA_TZ0_OST_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000000) >> 24
}
func (o *MCPWM_Type) SetINT_ENA_TZ1_OST_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000000)|value<<25)
}
func (o *MCPWM_Type) GetINT_ENA_TZ1_OST_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000000) >> 25
}
func (o *MCPWM_Type) SetINT_ENA_TZ2_OST_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000000)|value<<26)
}
func (o *MCPWM_Type) GetINT_ENA_TZ2_OST_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000000) >> 26
}
func (o *MCPWM_Type) SetINT_ENA_CAP0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000000)|value<<27)
}
func (o *MCPWM_Type) GetINT_ENA_CAP0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000000) >> 27
}
func (o *MCPWM_Type) SetINT_ENA_CAP1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000000)|value<<28)
}
func (o *MCPWM_Type) GetINT_ENA_CAP1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000000) >> 28
}
func (o *MCPWM_Type) SetINT_ENA_CAP2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetINT_ENA_CAP2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000000) >> 29
}

// MCPWM.INT_RAW: Raw interrupt status
func (o *MCPWM_Type) SetINT_RAW_TIMER0_STOP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINT_RAW_TIMER0_STOP_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *MCPWM_Type) SetINT_RAW_TIMER1_STOP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINT_RAW_TIMER1_STOP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINT_RAW_TIMER2_STOP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINT_RAW_TIMER2_STOP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINT_RAW_TIMER0_TEZ_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINT_RAW_TIMER0_TEZ_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINT_RAW_TIMER1_TEZ_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINT_RAW_TIMER1_TEZ_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINT_RAW_TIMER2_TEZ_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINT_RAW_TIMER2_TEZ_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINT_RAW_TIMER0_TEP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINT_RAW_TIMER0_TEP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINT_RAW_TIMER1_TEP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINT_RAW_TIMER1_TEP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINT_RAW_TIMER2_TEP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINT_RAW_TIMER2_TEP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINT_RAW_FAULT0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINT_RAW_FAULT0_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINT_RAW_FAULT1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINT_RAW_FAULT1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINT_RAW_FAULT2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetINT_RAW_FAULT2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetINT_RAW_FAULT0_CLR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetINT_RAW_FAULT0_CLR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetINT_RAW_FAULT1_CLR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetINT_RAW_FAULT1_CLR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetINT_RAW_FAULT2_CLR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetINT_RAW_FAULT2_CLR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetINT_RAW_CMPR0_TEA_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINT_RAW_CMPR0_TEA_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINT_RAW_CMPR1_TEA_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetINT_RAW_CMPR1_TEA_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetINT_RAW_CMPR2_TEA_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetINT_RAW_CMPR2_TEA_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetINT_RAW_CMPR0_TEB_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetINT_RAW_CMPR0_TEB_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetINT_RAW_CMPR1_TEB_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetINT_RAW_CMPR1_TEB_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetINT_RAW_CMPR2_TEB_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetINT_RAW_CMPR2_TEB_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetINT_RAW_TZ0_CBC_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200000)|value<<21)
}
func (o *MCPWM_Type) GetINT_RAW_TZ0_CBC_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200000) >> 21
}
func (o *MCPWM_Type) SetINT_RAW_TZ1_CBC_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400000)|value<<22)
}
func (o *MCPWM_Type) GetINT_RAW_TZ1_CBC_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400000) >> 22
}
func (o *MCPWM_Type) SetINT_RAW_TZ2_CBC_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800000)|value<<23)
}
func (o *MCPWM_Type) GetINT_RAW_TZ2_CBC_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800000) >> 23
}
func (o *MCPWM_Type) SetINT_RAW_TZ0_OST_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000000)|value<<24)
}
func (o *MCPWM_Type) GetINT_RAW_TZ0_OST_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000000) >> 24
}
func (o *MCPWM_Type) SetINT_RAW_TZ1_OST_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000000)|value<<25)
}
func (o *MCPWM_Type) GetINT_RAW_TZ1_OST_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000000) >> 25
}
func (o *MCPWM_Type) SetINT_RAW_TZ2_OST_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000000)|value<<26)
}
func (o *MCPWM_Type) GetINT_RAW_TZ2_OST_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000000) >> 26
}
func (o *MCPWM_Type) SetINT_RAW_CAP0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000000)|value<<27)
}
func (o *MCPWM_Type) GetINT_RAW_CAP0_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000000) >> 27
}
func (o *MCPWM_Type) SetINT_RAW_CAP1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000000)|value<<28)
}
func (o *MCPWM_Type) GetINT_RAW_CAP1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000000) >> 28
}
func (o *MCPWM_Type) SetINT_RAW_CAP2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetINT_RAW_CAP2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000000) >> 29
}

// MCPWM.INT_ST: Masked interrupt status
func (o *MCPWM_Type) SetINT_ST_TIMER0_STOP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINT_ST_TIMER0_STOP_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *MCPWM_Type) SetINT_ST_TIMER1_STOP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINT_ST_TIMER1_STOP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINT_ST_TIMER2_STOP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINT_ST_TIMER2_STOP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINT_ST_TIMER0_TEZ_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINT_ST_TIMER0_TEZ_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINT_ST_TIMER1_TEZ_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINT_ST_TIMER1_TEZ_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINT_ST_TIMER2_TEZ_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINT_ST_TIMER2_TEZ_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINT_ST_TIMER0_TEP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINT_ST_TIMER0_TEP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINT_ST_TIMER1_TEP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINT_ST_TIMER1_TEP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINT_ST_TIMER2_TEP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINT_ST_TIMER2_TEP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINT_ST_FAULT0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINT_ST_FAULT0_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINT_ST_FAULT1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINT_ST_FAULT1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINT_ST_FAULT2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetINT_ST_FAULT2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetINT_ST_FAULT0_CLR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetINT_ST_FAULT0_CLR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetINT_ST_FAULT1_CLR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetINT_ST_FAULT1_CLR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetINT_ST_FAULT2_CLR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetINT_ST_FAULT2_CLR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetINT_ST_CMPR0_TEA_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINT_ST_CMPR0_TEA_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINT_ST_CMPR1_TEA_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetINT_ST_CMPR1_TEA_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetINT_ST_CMPR2_TEA_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetINT_ST_CMPR2_TEA_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetINT_ST_CMPR0_TEB_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetINT_ST_CMPR0_TEB_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetINT_ST_CMPR1_TEB_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetINT_ST_CMPR1_TEB_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetINT_ST_CMPR2_TEB_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetINT_ST_CMPR2_TEB_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetINT_ST_TZ0_CBC_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200000)|value<<21)
}
func (o *MCPWM_Type) GetINT_ST_TZ0_CBC_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200000) >> 21
}
func (o *MCPWM_Type) SetINT_ST_TZ1_CBC_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400000)|value<<22)
}
func (o *MCPWM_Type) GetINT_ST_TZ1_CBC_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400000) >> 22
}
func (o *MCPWM_Type) SetINT_ST_TZ2_CBC_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x800000)|value<<23)
}
func (o *MCPWM_Type) GetINT_ST_TZ2_CBC_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x800000) >> 23
}
func (o *MCPWM_Type) SetINT_ST_TZ0_OST_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000000)|value<<24)
}
func (o *MCPWM_Type) GetINT_ST_TZ0_OST_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000000) >> 24
}
func (o *MCPWM_Type) SetINT_ST_TZ1_OST_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000000)|value<<25)
}
func (o *MCPWM_Type) GetINT_ST_TZ1_OST_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000000) >> 25
}
func (o *MCPWM_Type) SetINT_ST_TZ2_OST_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000000)|value<<26)
}
func (o *MCPWM_Type) GetINT_ST_TZ2_OST_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000000) >> 26
}
func (o *MCPWM_Type) SetINT_ST_CAP0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000000)|value<<27)
}
func (o *MCPWM_Type) GetINT_ST_CAP0_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000000) >> 27
}
func (o *MCPWM_Type) SetINT_ST_CAP1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000000)|value<<28)
}
func (o *MCPWM_Type) GetINT_ST_CAP1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000000) >> 28
}
func (o *MCPWM_Type) SetINT_ST_CAP2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetINT_ST_CAP2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000000) >> 29
}

// MCPWM.INT_CLR: Interrupt clear bits
func (o *MCPWM_Type) SetINT_CLR_TIMER0_STOP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINT_CLR_TIMER0_STOP_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *MCPWM_Type) SetINT_CLR_TIMER1_STOP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINT_CLR_TIMER1_STOP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINT_CLR_TIMER2_STOP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINT_CLR_TIMER2_STOP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINT_CLR_TIMER0_TEZ_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINT_CLR_TIMER0_TEZ_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINT_CLR_TIMER1_TEZ_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINT_CLR_TIMER1_TEZ_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINT_CLR_TIMER2_TEZ_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINT_CLR_TIMER2_TEZ_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINT_CLR_TIMER0_TEP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINT_CLR_TIMER0_TEP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINT_CLR_TIMER1_TEP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINT_CLR_TIMER1_TEP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINT_CLR_TIMER2_TEP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINT_CLR_TIMER2_TEP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINT_CLR_FAULT0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINT_CLR_FAULT0_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINT_CLR_FAULT1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINT_CLR_FAULT1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINT_CLR_FAULT2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetINT_CLR_FAULT2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetINT_CLR_FAULT0_CLR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetINT_CLR_FAULT0_CLR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetINT_CLR_FAULT1_CLR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetINT_CLR_FAULT1_CLR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetINT_CLR_FAULT2_CLR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetINT_CLR_FAULT2_CLR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetINT_CLR_CMPR0_TEA_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINT_CLR_CMPR0_TEA_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINT_CLR_CMPR1_TEA_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetINT_CLR_CMPR1_TEA_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetINT_CLR_CMPR2_TEA_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetINT_CLR_CMPR2_TEA_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetINT_CLR_CMPR0_TEB_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetINT_CLR_CMPR0_TEB_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetINT_CLR_CMPR1_TEB_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetINT_CLR_CMPR1_TEB_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetINT_CLR_CMPR2_TEB_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetINT_CLR_CMPR2_TEB_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetINT_CLR_TZ0_CBC_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200000)|value<<21)
}
func (o *MCPWM_Type) GetINT_CLR_TZ0_CBC_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200000) >> 21
}
func (o *MCPWM_Type) SetINT_CLR_TZ1_CBC_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400000)|value<<22)
}
func (o *MCPWM_Type) GetINT_CLR_TZ1_CBC_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400000) >> 22
}
func (o *MCPWM_Type) SetINT_CLR_TZ2_CBC_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800000)|value<<23)
}
func (o *MCPWM_Type) GetINT_CLR_TZ2_CBC_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800000) >> 23
}
func (o *MCPWM_Type) SetINT_CLR_TZ0_OST_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000000)|value<<24)
}
func (o *MCPWM_Type) GetINT_CLR_TZ0_OST_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000000) >> 24
}
func (o *MCPWM_Type) SetINT_CLR_TZ1_OST_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000000)|value<<25)
}
func (o *MCPWM_Type) GetINT_CLR_TZ1_OST_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000000) >> 25
}
func (o *MCPWM_Type) SetINT_CLR_TZ2_OST_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000000)|value<<26)
}
func (o *MCPWM_Type) GetINT_CLR_TZ2_OST_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000000) >> 26
}
func (o *MCPWM_Type) SetINT_CLR_CAP0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000000)|value<<27)
}
func (o *MCPWM_Type) GetINT_CLR_CAP0_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000000) >> 27
}
func (o *MCPWM_Type) SetINT_CLR_CAP1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *MCPWM_Type) GetINT_CLR_CAP1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000000) >> 28
}
func (o *MCPWM_Type) SetINT_CLR_CAP2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetINT_CLR_CAP2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000000) >> 29
}

// MCPWM.EVT_EN: MCPWM event enable register
func (o *MCPWM_Type) SetEVT_EN_EVT_TIMER0_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TIMER0_STOP_EN() uint32 {
	return volatile.LoadUint32(&o.EVT_EN.Reg) & 0x1
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TIMER1_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TIMER1_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TIMER2_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TIMER2_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TIMER0_TEZ_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TIMER0_TEZ_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TIMER1_TEZ_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TIMER1_TEZ_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TIMER2_TEZ_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TIMER2_TEZ_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TIMER0_TEP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TIMER0_TEP_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TIMER1_TEP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TIMER1_TEP_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TIMER2_TEP_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TIMER2_TEP_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetEVT_EN_EVT_OP0_TEA_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_OP0_TEA_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetEVT_EN_EVT_OP1_TEA_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_OP1_TEA_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetEVT_EN_EVT_OP2_TEA_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_OP2_TEA_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetEVT_EN_EVT_OP0_TEB_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_OP0_TEB_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetEVT_EN_EVT_OP1_TEB_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_OP1_TEB_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetEVT_EN_EVT_OP2_TEB_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_OP2_TEB_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetEVT_EN_EVT_F0_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_F0_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetEVT_EN_EVT_F1_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_F1_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetEVT_EN_EVT_F2_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_F2_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetEVT_EN_EVT_F0_CLR_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_F0_CLR_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetEVT_EN_EVT_F1_CLR_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_F1_CLR_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetEVT_EN_EVT_F2_CLR_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_F2_CLR_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TZ0_CBC_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x200000)|value<<21)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TZ0_CBC_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x200000) >> 21
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TZ1_CBC_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x400000)|value<<22)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TZ1_CBC_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x400000) >> 22
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TZ2_CBC_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x800000)|value<<23)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TZ2_CBC_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x800000) >> 23
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TZ0_OST_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x1000000)|value<<24)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TZ0_OST_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x1000000) >> 24
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TZ1_OST_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x2000000)|value<<25)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TZ1_OST_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x2000000) >> 25
}
func (o *MCPWM_Type) SetEVT_EN_EVT_TZ2_OST_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x4000000)|value<<26)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_TZ2_OST_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x4000000) >> 26
}
func (o *MCPWM_Type) SetEVT_EN_EVT_CAP0_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x8000000)|value<<27)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_CAP0_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x8000000) >> 27
}
func (o *MCPWM_Type) SetEVT_EN_EVT_CAP1_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x10000000)|value<<28)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_CAP1_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x10000000) >> 28
}
func (o *MCPWM_Type) SetEVT_EN_EVT_CAP2_EN(value uint32) {
	volatile.StoreUint32(&o.EVT_EN.Reg, volatile.LoadUint32(&o.EVT_EN.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetEVT_EN_EVT_CAP2_EN() uint32 {
	return (volatile.LoadUint32(&o.EVT_EN.Reg) & 0x20000000) >> 29
}

// MCPWM.TASK_EN: MCPWM task enable register
func (o *MCPWM_Type) SetTASK_EN_TASK_CMPR0_A_UP_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_CMPR0_A_UP_EN() uint32 {
	return volatile.LoadUint32(&o.TASK_EN.Reg) & 0x1
}
func (o *MCPWM_Type) SetTASK_EN_TASK_CMPR1_A_UP_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_CMPR1_A_UP_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetTASK_EN_TASK_CMPR2_A_UP_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_CMPR2_A_UP_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetTASK_EN_TASK_CMPR0_B_UP_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_CMPR0_B_UP_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetTASK_EN_TASK_CMPR1_B_UP_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_CMPR1_B_UP_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetTASK_EN_TASK_CMPR2_B_UP_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_CMPR2_B_UP_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetTASK_EN_TASK_GEN_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_GEN_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetTASK_EN_TASK_TIMER0_SYNC_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_TIMER0_SYNC_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetTASK_EN_TASK_TIMER1_SYNC_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_TIMER1_SYNC_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetTASK_EN_TASK_TIMER2_SYNC_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_TIMER2_SYNC_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetTASK_EN_TASK_TIMER0_PERIOD_UP_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_TIMER0_PERIOD_UP_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetTASK_EN_TASK_TIMER1_PERIOD_UP_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_TIMER1_PERIOD_UP_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetTASK_EN_TASK_TIMER2_PERIOD_UP_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_TIMER2_PERIOD_UP_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetTASK_EN_TASK_TZ0_OST_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_TZ0_OST_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetTASK_EN_TASK_TZ1_OST_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_TZ1_OST_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetTASK_EN_TASK_TZ2_OST_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_TZ2_OST_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetTASK_EN_TASK_CLR0_OST_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_CLR0_OST_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetTASK_EN_TASK_CLR1_OST_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_CLR1_OST_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetTASK_EN_TASK_CLR2_OST_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_CLR2_OST_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetTASK_EN_TASK_CAP0_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_CAP0_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetTASK_EN_TASK_CAP1_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_CAP1_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetTASK_EN_TASK_CAP2_EN(value uint32) {
	volatile.StoreUint32(&o.TASK_EN.Reg, volatile.LoadUint32(&o.TASK_EN.Reg)&^(0x200000)|value<<21)
}
func (o *MCPWM_Type) GetTASK_EN_TASK_CAP2_EN() uint32 {
	return (volatile.LoadUint32(&o.TASK_EN.Reg) & 0x200000) >> 21
}

// MCPWM.CLK: MCPWM APB configuration register
func (o *MCPWM_Type) SetCLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLK.Reg) & 0x1
}

// MCPWM.VERSION: Version register.
func (o *MCPWM_Type) SetVERSION_DATE(value uint32) {
	volatile.StoreUint32(&o.VERSION.Reg, volatile.LoadUint32(&o.VERSION.Reg)&^(0xfffffff)|value)
}
func (o *MCPWM_Type) GetVERSION_DATE() uint32 {
	return volatile.LoadUint32(&o.VERSION.Reg) & 0xfffffff
}

// MEM_MONITOR Peripheral
type MEM_MONITOR_Type struct {
	LOG_SETTING          volatile.Register32 // 0x0
	LOG_CHECK_DATA       volatile.Register32 // 0x4
	LOG_DATA_MASK        volatile.Register32 // 0x8
	LOG_MIN              volatile.Register32 // 0xC
	LOG_MAX              volatile.Register32 // 0x10
	LOG_MEM_START        volatile.Register32 // 0x14
	LOG_MEM_END          volatile.Register32 // 0x18
	LOG_MEM_CURRENT_ADDR volatile.Register32 // 0x1C
	LOG_MEM_ADDR_UPDATE  volatile.Register32 // 0x20
	LOG_MEM_FULL_FLAG    volatile.Register32 // 0x24
	CLOCK_GATE           volatile.Register32 // 0x28
	_                    [976]byte
	DATE                 volatile.Register32 // 0x3FC
}

// MEM_MONITOR.LOG_SETTING: log config regsiter
func (o *MEM_MONITOR_Type) SetLOG_SETTING_LOG_ENA(value uint32) {
	volatile.StoreUint32(&o.LOG_SETTING.Reg, volatile.LoadUint32(&o.LOG_SETTING.Reg)&^(0x7)|value)
}
func (o *MEM_MONITOR_Type) GetLOG_SETTING_LOG_ENA() uint32 {
	return volatile.LoadUint32(&o.LOG_SETTING.Reg) & 0x7
}
func (o *MEM_MONITOR_Type) SetLOG_SETTING_LOG_MODE(value uint32) {
	volatile.StoreUint32(&o.LOG_SETTING.Reg, volatile.LoadUint32(&o.LOG_SETTING.Reg)&^(0x78)|value<<3)
}
func (o *MEM_MONITOR_Type) GetLOG_SETTING_LOG_MODE() uint32 {
	return (volatile.LoadUint32(&o.LOG_SETTING.Reg) & 0x78) >> 3
}
func (o *MEM_MONITOR_Type) SetLOG_SETTING_LOG_MEM_LOOP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.LOG_SETTING.Reg, volatile.LoadUint32(&o.LOG_SETTING.Reg)&^(0x80)|value<<7)
}
func (o *MEM_MONITOR_Type) GetLOG_SETTING_LOG_MEM_LOOP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.LOG_SETTING.Reg) & 0x80) >> 7
}

// MEM_MONITOR.LOG_CHECK_DATA: check data regsiter
func (o *MEM_MONITOR_Type) SetLOG_CHECK_DATA(value uint32) {
	volatile.StoreUint32(&o.LOG_CHECK_DATA.Reg, value)
}
func (o *MEM_MONITOR_Type) GetLOG_CHECK_DATA() uint32 {
	return volatile.LoadUint32(&o.LOG_CHECK_DATA.Reg)
}

// MEM_MONITOR.LOG_DATA_MASK: check data mask register
func (o *MEM_MONITOR_Type) SetLOG_DATA_MASK(value uint32) {
	volatile.StoreUint32(&o.LOG_DATA_MASK.Reg, volatile.LoadUint32(&o.LOG_DATA_MASK.Reg)&^(0xf)|value)
}
func (o *MEM_MONITOR_Type) GetLOG_DATA_MASK() uint32 {
	return volatile.LoadUint32(&o.LOG_DATA_MASK.Reg) & 0xf
}

// MEM_MONITOR.LOG_MIN: log boundary regsiter
func (o *MEM_MONITOR_Type) SetLOG_MIN(value uint32) {
	volatile.StoreUint32(&o.LOG_MIN.Reg, value)
}
func (o *MEM_MONITOR_Type) GetLOG_MIN() uint32 {
	return volatile.LoadUint32(&o.LOG_MIN.Reg)
}

// MEM_MONITOR.LOG_MAX: log boundary regsiter
func (o *MEM_MONITOR_Type) SetLOG_MAX(value uint32) {
	volatile.StoreUint32(&o.LOG_MAX.Reg, value)
}
func (o *MEM_MONITOR_Type) GetLOG_MAX() uint32 {
	return volatile.LoadUint32(&o.LOG_MAX.Reg)
}

// MEM_MONITOR.LOG_MEM_START: log message store range register
func (o *MEM_MONITOR_Type) SetLOG_MEM_START(value uint32) {
	volatile.StoreUint32(&o.LOG_MEM_START.Reg, value)
}
func (o *MEM_MONITOR_Type) GetLOG_MEM_START() uint32 {
	return volatile.LoadUint32(&o.LOG_MEM_START.Reg)
}

// MEM_MONITOR.LOG_MEM_END: log message store range register
func (o *MEM_MONITOR_Type) SetLOG_MEM_END(value uint32) {
	volatile.StoreUint32(&o.LOG_MEM_END.Reg, value)
}
func (o *MEM_MONITOR_Type) GetLOG_MEM_END() uint32 {
	return volatile.LoadUint32(&o.LOG_MEM_END.Reg)
}

// MEM_MONITOR.LOG_MEM_CURRENT_ADDR: current writing address.
func (o *MEM_MONITOR_Type) SetLOG_MEM_CURRENT_ADDR(value uint32) {
	volatile.StoreUint32(&o.LOG_MEM_CURRENT_ADDR.Reg, value)
}
func (o *MEM_MONITOR_Type) GetLOG_MEM_CURRENT_ADDR() uint32 {
	return volatile.LoadUint32(&o.LOG_MEM_CURRENT_ADDR.Reg)
}

// MEM_MONITOR.LOG_MEM_ADDR_UPDATE: writing address update
func (o *MEM_MONITOR_Type) SetLOG_MEM_ADDR_UPDATE(value uint32) {
	volatile.StoreUint32(&o.LOG_MEM_ADDR_UPDATE.Reg, volatile.LoadUint32(&o.LOG_MEM_ADDR_UPDATE.Reg)&^(0x1)|value)
}
func (o *MEM_MONITOR_Type) GetLOG_MEM_ADDR_UPDATE() uint32 {
	return volatile.LoadUint32(&o.LOG_MEM_ADDR_UPDATE.Reg) & 0x1
}

// MEM_MONITOR.LOG_MEM_FULL_FLAG: full flag status register
func (o *MEM_MONITOR_Type) SetLOG_MEM_FULL_FLAG(value uint32) {
	volatile.StoreUint32(&o.LOG_MEM_FULL_FLAG.Reg, volatile.LoadUint32(&o.LOG_MEM_FULL_FLAG.Reg)&^(0x1)|value)
}
func (o *MEM_MONITOR_Type) GetLOG_MEM_FULL_FLAG() uint32 {
	return volatile.LoadUint32(&o.LOG_MEM_FULL_FLAG.Reg) & 0x1
}
func (o *MEM_MONITOR_Type) SetLOG_MEM_FULL_FLAG_CLR_LOG_MEM_FULL_FLAG(value uint32) {
	volatile.StoreUint32(&o.LOG_MEM_FULL_FLAG.Reg, volatile.LoadUint32(&o.LOG_MEM_FULL_FLAG.Reg)&^(0x2)|value<<1)
}
func (o *MEM_MONITOR_Type) GetLOG_MEM_FULL_FLAG_CLR_LOG_MEM_FULL_FLAG() uint32 {
	return (volatile.LoadUint32(&o.LOG_MEM_FULL_FLAG.Reg) & 0x2) >> 1
}

// MEM_MONITOR.CLOCK_GATE: clock gate force on register
func (o *MEM_MONITOR_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *MEM_MONITOR_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// MEM_MONITOR.DATE: version register
func (o *MEM_MONITOR_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *MEM_MONITOR_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// MODEM_LPCON Peripheral
type MODEM_LPCON_Type struct {
	TEST_CONF         volatile.Register32 // 0x0
	COEX_LP_CLK_CONF  volatile.Register32 // 0x4
	CLK_CONF          volatile.Register32 // 0x8
	CLK_CONF_FORCE_ON volatile.Register32 // 0xC
	TICK_CONF         volatile.Register32 // 0x10
	RST_CONF          volatile.Register32 // 0x14
	MEM_CONF          volatile.Register32 // 0x18
	DATE              volatile.Register32 // 0x1C
}

// MODEM_LPCON.TEST_CONF
func (o *MODEM_LPCON_Type) SetTEST_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.TEST_CONF.Reg, volatile.LoadUint32(&o.TEST_CONF.Reg)&^(0x1)|value)
}
func (o *MODEM_LPCON_Type) GetTEST_CONF_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.TEST_CONF.Reg) & 0x1
}

// MODEM_LPCON.COEX_LP_CLK_CONF
func (o *MODEM_LPCON_Type) SetCOEX_LP_CLK_CONF_CLK_COEX_LP_SEL_OSC_SLOW(value uint32) {
	volatile.StoreUint32(&o.COEX_LP_CLK_CONF.Reg, volatile.LoadUint32(&o.COEX_LP_CLK_CONF.Reg)&^(0x1)|value)
}
func (o *MODEM_LPCON_Type) GetCOEX_LP_CLK_CONF_CLK_COEX_LP_SEL_OSC_SLOW() uint32 {
	return volatile.LoadUint32(&o.COEX_LP_CLK_CONF.Reg) & 0x1
}
func (o *MODEM_LPCON_Type) SetCOEX_LP_CLK_CONF_CLK_COEX_LP_SEL_OSC_FAST(value uint32) {
	volatile.StoreUint32(&o.COEX_LP_CLK_CONF.Reg, volatile.LoadUint32(&o.COEX_LP_CLK_CONF.Reg)&^(0x2)|value<<1)
}
func (o *MODEM_LPCON_Type) GetCOEX_LP_CLK_CONF_CLK_COEX_LP_SEL_OSC_FAST() uint32 {
	return (volatile.LoadUint32(&o.COEX_LP_CLK_CONF.Reg) & 0x2) >> 1
}
func (o *MODEM_LPCON_Type) SetCOEX_LP_CLK_CONF_CLK_COEX_LP_SEL_XTAL(value uint32) {
	volatile.StoreUint32(&o.COEX_LP_CLK_CONF.Reg, volatile.LoadUint32(&o.COEX_LP_CLK_CONF.Reg)&^(0x4)|value<<2)
}
func (o *MODEM_LPCON_Type) GetCOEX_LP_CLK_CONF_CLK_COEX_LP_SEL_XTAL() uint32 {
	return (volatile.LoadUint32(&o.COEX_LP_CLK_CONF.Reg) & 0x4) >> 2
}
func (o *MODEM_LPCON_Type) SetCOEX_LP_CLK_CONF_CLK_COEX_LP_SEL_XTAL32K(value uint32) {
	volatile.StoreUint32(&o.COEX_LP_CLK_CONF.Reg, volatile.LoadUint32(&o.COEX_LP_CLK_CONF.Reg)&^(0x8)|value<<3)
}
func (o *MODEM_LPCON_Type) GetCOEX_LP_CLK_CONF_CLK_COEX_LP_SEL_XTAL32K() uint32 {
	return (volatile.LoadUint32(&o.COEX_LP_CLK_CONF.Reg) & 0x8) >> 3
}
func (o *MODEM_LPCON_Type) SetCOEX_LP_CLK_CONF_CLK_COEX_LP_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.COEX_LP_CLK_CONF.Reg, volatile.LoadUint32(&o.COEX_LP_CLK_CONF.Reg)&^(0xfff0)|value<<4)
}
func (o *MODEM_LPCON_Type) GetCOEX_LP_CLK_CONF_CLK_COEX_LP_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.COEX_LP_CLK_CONF.Reg) & 0xfff0) >> 4
}

// MODEM_LPCON.CLK_CONF
func (o *MODEM_LPCON_Type) SetCLK_CONF_CLK_COEX_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x2)|value<<1)
}
func (o *MODEM_LPCON_Type) GetCLK_CONF_CLK_COEX_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x2) >> 1
}
func (o *MODEM_LPCON_Type) SetCLK_CONF_CLK_I2C_MST_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x4)|value<<2)
}
func (o *MODEM_LPCON_Type) GetCLK_CONF_CLK_I2C_MST_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x4) >> 2
}
func (o *MODEM_LPCON_Type) SetCLK_CONF_CLK_FE_MEM_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x20)|value<<5)
}
func (o *MODEM_LPCON_Type) GetCLK_CONF_CLK_FE_MEM_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x20) >> 5
}

// MODEM_LPCON.CLK_CONF_FORCE_ON
func (o *MODEM_LPCON_Type) SetCLK_CONF_FORCE_ON_CLK_COEX_FO(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF_FORCE_ON.Reg, volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg)&^(0x2)|value<<1)
}
func (o *MODEM_LPCON_Type) GetCLK_CONF_FORCE_ON_CLK_COEX_FO() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg) & 0x2) >> 1
}
func (o *MODEM_LPCON_Type) SetCLK_CONF_FORCE_ON_CLK_I2C_MST_FO(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF_FORCE_ON.Reg, volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg)&^(0x4)|value<<2)
}
func (o *MODEM_LPCON_Type) GetCLK_CONF_FORCE_ON_CLK_I2C_MST_FO() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg) & 0x4) >> 2
}
func (o *MODEM_LPCON_Type) SetCLK_CONF_FORCE_ON_CLK_FE_MEM_FO(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF_FORCE_ON.Reg, volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg)&^(0x20)|value<<5)
}
func (o *MODEM_LPCON_Type) GetCLK_CONF_FORCE_ON_CLK_FE_MEM_FO() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg) & 0x20) >> 5
}

// MODEM_LPCON.TICK_CONF
func (o *MODEM_LPCON_Type) SetTICK_CONF_PWR_TICK_TARGET(value uint32) {
	volatile.StoreUint32(&o.TICK_CONF.Reg, volatile.LoadUint32(&o.TICK_CONF.Reg)&^(0x3f)|value)
}
func (o *MODEM_LPCON_Type) GetTICK_CONF_PWR_TICK_TARGET() uint32 {
	return volatile.LoadUint32(&o.TICK_CONF.Reg) & 0x3f
}

// MODEM_LPCON.RST_CONF
func (o *MODEM_LPCON_Type) SetRST_CONF_RST_COEX(value uint32) {
	volatile.StoreUint32(&o.RST_CONF.Reg, volatile.LoadUint32(&o.RST_CONF.Reg)&^(0x2)|value<<1)
}
func (o *MODEM_LPCON_Type) GetRST_CONF_RST_COEX() uint32 {
	return (volatile.LoadUint32(&o.RST_CONF.Reg) & 0x2) >> 1
}
func (o *MODEM_LPCON_Type) SetRST_CONF_RST_I2C_MST(value uint32) {
	volatile.StoreUint32(&o.RST_CONF.Reg, volatile.LoadUint32(&o.RST_CONF.Reg)&^(0x4)|value<<2)
}
func (o *MODEM_LPCON_Type) GetRST_CONF_RST_I2C_MST() uint32 {
	return (volatile.LoadUint32(&o.RST_CONF.Reg) & 0x4) >> 2
}

// MODEM_LPCON.MEM_CONF
func (o *MODEM_LPCON_Type) SetMEM_CONF_AGC_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x4)|value<<2)
}
func (o *MODEM_LPCON_Type) GetMEM_CONF_AGC_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x4) >> 2
}
func (o *MODEM_LPCON_Type) SetMEM_CONF_AGC_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x8)|value<<3)
}
func (o *MODEM_LPCON_Type) GetMEM_CONF_AGC_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x8) >> 3
}
func (o *MODEM_LPCON_Type) SetMEM_CONF_PBUS_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x10)|value<<4)
}
func (o *MODEM_LPCON_Type) GetMEM_CONF_PBUS_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x10) >> 4
}
func (o *MODEM_LPCON_Type) SetMEM_CONF_PBUS_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x20)|value<<5)
}
func (o *MODEM_LPCON_Type) GetMEM_CONF_PBUS_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x20) >> 5
}
func (o *MODEM_LPCON_Type) SetMEM_CONF_I2C_MST_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x100)|value<<8)
}
func (o *MODEM_LPCON_Type) GetMEM_CONF_I2C_MST_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x100) >> 8
}
func (o *MODEM_LPCON_Type) SetMEM_CONF_I2C_MST_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x200)|value<<9)
}
func (o *MODEM_LPCON_Type) GetMEM_CONF_I2C_MST_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x200) >> 9
}
func (o *MODEM_LPCON_Type) SetMEM_CONF_CHAN_FREQ_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x400)|value<<10)
}
func (o *MODEM_LPCON_Type) GetMEM_CONF_CHAN_FREQ_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x400) >> 10
}
func (o *MODEM_LPCON_Type) SetMEM_CONF_CHAN_FREQ_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x800)|value<<11)
}
func (o *MODEM_LPCON_Type) GetMEM_CONF_CHAN_FREQ_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x800) >> 11
}
func (o *MODEM_LPCON_Type) SetMEM_CONF_MODEM_PWR_MEM_WP(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x7000)|value<<12)
}
func (o *MODEM_LPCON_Type) GetMEM_CONF_MODEM_PWR_MEM_WP() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x7000) >> 12
}
func (o *MODEM_LPCON_Type) SetMEM_CONF_MODEM_PWR_MEM_WA(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x38000)|value<<15)
}
func (o *MODEM_LPCON_Type) GetMEM_CONF_MODEM_PWR_MEM_WA() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x38000) >> 15
}
func (o *MODEM_LPCON_Type) SetMEM_CONF_MODEM_PWR_MEM_RA(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0xc0000)|value<<18)
}
func (o *MODEM_LPCON_Type) GetMEM_CONF_MODEM_PWR_MEM_RA() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0xc0000) >> 18
}
func (o *MODEM_LPCON_Type) SetMEM_CONF_MODEM_PWR_MEM_RM(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0xf00000)|value<<20)
}
func (o *MODEM_LPCON_Type) GetMEM_CONF_MODEM_PWR_MEM_RM() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0xf00000) >> 20
}

// MODEM_LPCON.DATE
func (o *MODEM_LPCON_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *MODEM_LPCON_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// MODEM_SYSCON Peripheral
type MODEM_SYSCON_Type struct {
	TEST_CONF          volatile.Register32 // 0x0
	CLK_CONF           volatile.Register32 // 0x4
	CLK_CONF_FORCE_ON  volatile.Register32 // 0x8
	MODEM_RST_CONF     volatile.Register32 // 0xC
	CLK_CONF1          volatile.Register32 // 0x10
	CLK_CONF1_FORCE_ON volatile.Register32 // 0x14
	MEM_CONF           volatile.Register32 // 0x18
	DATE               volatile.Register32 // 0x1C
}

// MODEM_SYSCON.TEST_CONF
func (o *MODEM_SYSCON_Type) SetTEST_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.TEST_CONF.Reg, volatile.LoadUint32(&o.TEST_CONF.Reg)&^(0x1)|value)
}
func (o *MODEM_SYSCON_Type) GetTEST_CONF_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.TEST_CONF.Reg) & 0x1
}

// MODEM_SYSCON.CLK_CONF
func (o *MODEM_SYSCON_Type) SetCLK_CONF_CLK_ETM_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_CLK_ETM_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x200000) >> 21
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_CLK_ZB_APB_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_CLK_ZB_APB_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x400000) >> 22
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_CLK_ZB_MAC_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_CLK_ZB_MAC_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x800000) >> 23
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_CLK_MODEM_SEC_ECB_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_CLK_MODEM_SEC_ECB_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x1000000) >> 24
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_CLK_MODEM_SEC_CCM_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_CLK_MODEM_SEC_CCM_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x2000000) >> 25
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_CLK_MODEM_SEC_BAH_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_CLK_MODEM_SEC_BAH_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x4000000) >> 26
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_CLK_MODEM_SEC_APB_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_CLK_MODEM_SEC_APB_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x8000000) >> 27
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_CLK_MODEM_SEC_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_CLK_MODEM_SEC_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x10000000) >> 28
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_CLK_BLE_TIMER_APB_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_CLK_BLE_TIMER_APB_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x20000000) >> 29
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_CLK_BLE_TIMER_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_CLK_BLE_TIMER_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x40000000) >> 30
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_CLK_DATA_DUMP_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_CLK_DATA_DUMP_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x80000000) >> 31
}

// MODEM_SYSCON.CLK_CONF_FORCE_ON
func (o *MODEM_SYSCON_Type) SetCLK_CONF_FORCE_ON_CLK_ETM_FO(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF_FORCE_ON.Reg, volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg)&^(0x400000)|value<<22)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_FORCE_ON_CLK_ETM_FO() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg) & 0x400000) >> 22
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_FORCE_ON_CLK_ZB_FO(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF_FORCE_ON.Reg, volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg)&^(0x1000000)|value<<24)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_FORCE_ON_CLK_ZB_FO() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg) & 0x1000000) >> 24
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_FORCE_ON_CLK_MODEM_SEC_FO(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF_FORCE_ON.Reg, volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg)&^(0x20000000)|value<<29)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_FORCE_ON_CLK_MODEM_SEC_FO() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg) & 0x20000000) >> 29
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_FORCE_ON_CLK_BLE_TIMER_FO(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF_FORCE_ON.Reg, volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg)&^(0x40000000)|value<<30)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_FORCE_ON_CLK_BLE_TIMER_FO() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg) & 0x40000000) >> 30
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF_FORCE_ON_CLK_DATA_DUMP_FO(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF_FORCE_ON.Reg, volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg)&^(0x80000000)|value<<31)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF_FORCE_ON_CLK_DATA_DUMP_FO() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF_FORCE_ON.Reg) & 0x80000000) >> 31
}

// MODEM_SYSCON.MODEM_RST_CONF
func (o *MODEM_SYSCON_Type) SetMODEM_RST_CONF_RST_FE(value uint32) {
	volatile.StoreUint32(&o.MODEM_RST_CONF.Reg, volatile.LoadUint32(&o.MODEM_RST_CONF.Reg)&^(0x4000)|value<<14)
}
func (o *MODEM_SYSCON_Type) GetMODEM_RST_CONF_RST_FE() uint32 {
	return (volatile.LoadUint32(&o.MODEM_RST_CONF.Reg) & 0x4000) >> 14
}
func (o *MODEM_SYSCON_Type) SetMODEM_RST_CONF_RST_BTMAC_APB(value uint32) {
	volatile.StoreUint32(&o.MODEM_RST_CONF.Reg, volatile.LoadUint32(&o.MODEM_RST_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *MODEM_SYSCON_Type) GetMODEM_RST_CONF_RST_BTMAC_APB() uint32 {
	return (volatile.LoadUint32(&o.MODEM_RST_CONF.Reg) & 0x8000) >> 15
}
func (o *MODEM_SYSCON_Type) SetMODEM_RST_CONF_RST_BTMAC(value uint32) {
	volatile.StoreUint32(&o.MODEM_RST_CONF.Reg, volatile.LoadUint32(&o.MODEM_RST_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *MODEM_SYSCON_Type) GetMODEM_RST_CONF_RST_BTMAC() uint32 {
	return (volatile.LoadUint32(&o.MODEM_RST_CONF.Reg) & 0x10000) >> 16
}
func (o *MODEM_SYSCON_Type) SetMODEM_RST_CONF_RST_BTBB_APB(value uint32) {
	volatile.StoreUint32(&o.MODEM_RST_CONF.Reg, volatile.LoadUint32(&o.MODEM_RST_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *MODEM_SYSCON_Type) GetMODEM_RST_CONF_RST_BTBB_APB() uint32 {
	return (volatile.LoadUint32(&o.MODEM_RST_CONF.Reg) & 0x20000) >> 17
}
func (o *MODEM_SYSCON_Type) SetMODEM_RST_CONF_RST_BTBB(value uint32) {
	volatile.StoreUint32(&o.MODEM_RST_CONF.Reg, volatile.LoadUint32(&o.MODEM_RST_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *MODEM_SYSCON_Type) GetMODEM_RST_CONF_RST_BTBB() uint32 {
	return (volatile.LoadUint32(&o.MODEM_RST_CONF.Reg) & 0x40000) >> 18
}
func (o *MODEM_SYSCON_Type) SetMODEM_RST_CONF_RST_ETM(value uint32) {
	volatile.StoreUint32(&o.MODEM_RST_CONF.Reg, volatile.LoadUint32(&o.MODEM_RST_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *MODEM_SYSCON_Type) GetMODEM_RST_CONF_RST_ETM() uint32 {
	return (volatile.LoadUint32(&o.MODEM_RST_CONF.Reg) & 0x400000) >> 22
}
func (o *MODEM_SYSCON_Type) SetMODEM_RST_CONF_RST_ZBMAC(value uint32) {
	volatile.StoreUint32(&o.MODEM_RST_CONF.Reg, volatile.LoadUint32(&o.MODEM_RST_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *MODEM_SYSCON_Type) GetMODEM_RST_CONF_RST_ZBMAC() uint32 {
	return (volatile.LoadUint32(&o.MODEM_RST_CONF.Reg) & 0x1000000) >> 24
}
func (o *MODEM_SYSCON_Type) SetMODEM_RST_CONF_RST_MODEM_ECB(value uint32) {
	volatile.StoreUint32(&o.MODEM_RST_CONF.Reg, volatile.LoadUint32(&o.MODEM_RST_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *MODEM_SYSCON_Type) GetMODEM_RST_CONF_RST_MODEM_ECB() uint32 {
	return (volatile.LoadUint32(&o.MODEM_RST_CONF.Reg) & 0x2000000) >> 25
}
func (o *MODEM_SYSCON_Type) SetMODEM_RST_CONF_RST_MODEM_CCM(value uint32) {
	volatile.StoreUint32(&o.MODEM_RST_CONF.Reg, volatile.LoadUint32(&o.MODEM_RST_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *MODEM_SYSCON_Type) GetMODEM_RST_CONF_RST_MODEM_CCM() uint32 {
	return (volatile.LoadUint32(&o.MODEM_RST_CONF.Reg) & 0x4000000) >> 26
}
func (o *MODEM_SYSCON_Type) SetMODEM_RST_CONF_RST_MODEM_BAH(value uint32) {
	volatile.StoreUint32(&o.MODEM_RST_CONF.Reg, volatile.LoadUint32(&o.MODEM_RST_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *MODEM_SYSCON_Type) GetMODEM_RST_CONF_RST_MODEM_BAH() uint32 {
	return (volatile.LoadUint32(&o.MODEM_RST_CONF.Reg) & 0x8000000) >> 27
}
func (o *MODEM_SYSCON_Type) SetMODEM_RST_CONF_RST_MODEM_SEC(value uint32) {
	volatile.StoreUint32(&o.MODEM_RST_CONF.Reg, volatile.LoadUint32(&o.MODEM_RST_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *MODEM_SYSCON_Type) GetMODEM_RST_CONF_RST_MODEM_SEC() uint32 {
	return (volatile.LoadUint32(&o.MODEM_RST_CONF.Reg) & 0x20000000) >> 29
}
func (o *MODEM_SYSCON_Type) SetMODEM_RST_CONF_RST_BLE_TIMER(value uint32) {
	volatile.StoreUint32(&o.MODEM_RST_CONF.Reg, volatile.LoadUint32(&o.MODEM_RST_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *MODEM_SYSCON_Type) GetMODEM_RST_CONF_RST_BLE_TIMER() uint32 {
	return (volatile.LoadUint32(&o.MODEM_RST_CONF.Reg) & 0x40000000) >> 30
}
func (o *MODEM_SYSCON_Type) SetMODEM_RST_CONF_RST_DATA_DUMP(value uint32) {
	volatile.StoreUint32(&o.MODEM_RST_CONF.Reg, volatile.LoadUint32(&o.MODEM_RST_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *MODEM_SYSCON_Type) GetMODEM_RST_CONF_RST_DATA_DUMP() uint32 {
	return (volatile.LoadUint32(&o.MODEM_RST_CONF.Reg) & 0x80000000) >> 31
}

// MODEM_SYSCON.CLK_CONF1
func (o *MODEM_SYSCON_Type) SetCLK_CONF1_CLK_FE_16M_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF1.Reg, volatile.LoadUint32(&o.CLK_CONF1.Reg)&^(0x1000)|value<<12)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF1_CLK_FE_16M_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF1.Reg) & 0x1000) >> 12
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF1_CLK_FE_32M_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF1.Reg, volatile.LoadUint32(&o.CLK_CONF1.Reg)&^(0x2000)|value<<13)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF1_CLK_FE_32M_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF1.Reg) & 0x2000) >> 13
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF1_CLK_FE_SDM_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF1.Reg, volatile.LoadUint32(&o.CLK_CONF1.Reg)&^(0x4000)|value<<14)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF1_CLK_FE_SDM_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF1.Reg) & 0x4000) >> 14
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF1_CLK_FE_ADC_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF1.Reg, volatile.LoadUint32(&o.CLK_CONF1.Reg)&^(0x8000)|value<<15)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF1_CLK_FE_ADC_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF1.Reg) & 0x8000) >> 15
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF1_CLK_FE_APB_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF1.Reg, volatile.LoadUint32(&o.CLK_CONF1.Reg)&^(0x10000)|value<<16)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF1_CLK_FE_APB_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF1.Reg) & 0x10000) >> 16
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF1_CLK_BT_APB_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF1.Reg, volatile.LoadUint32(&o.CLK_CONF1.Reg)&^(0x20000)|value<<17)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF1_CLK_BT_APB_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF1.Reg) & 0x20000) >> 17
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF1_CLK_BT_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF1.Reg, volatile.LoadUint32(&o.CLK_CONF1.Reg)&^(0x40000)|value<<18)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF1_CLK_BT_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF1.Reg) & 0x40000) >> 18
}

// MODEM_SYSCON.CLK_CONF1_FORCE_ON
func (o *MODEM_SYSCON_Type) SetCLK_CONF1_FORCE_ON_CLK_FE_FO(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF1_FORCE_ON.Reg, volatile.LoadUint32(&o.CLK_CONF1_FORCE_ON.Reg)&^(0x10000)|value<<16)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF1_FORCE_ON_CLK_FE_FO() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF1_FORCE_ON.Reg) & 0x10000) >> 16
}
func (o *MODEM_SYSCON_Type) SetCLK_CONF1_FORCE_ON_CLK_BT_FO(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF1_FORCE_ON.Reg, volatile.LoadUint32(&o.CLK_CONF1_FORCE_ON.Reg)&^(0x40000)|value<<18)
}
func (o *MODEM_SYSCON_Type) GetCLK_CONF1_FORCE_ON_CLK_BT_FO() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF1_FORCE_ON.Reg) & 0x40000) >> 18
}

// MODEM_SYSCON.MEM_CONF
func (o *MODEM_SYSCON_Type) SetMEM_CONF_MODEM_MEM_WP(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x7)|value)
}
func (o *MODEM_SYSCON_Type) GetMEM_CONF_MODEM_MEM_WP() uint32 {
	return volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x7
}
func (o *MODEM_SYSCON_Type) SetMEM_CONF_MODEM_MEM_WA(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x38)|value<<3)
}
func (o *MODEM_SYSCON_Type) GetMEM_CONF_MODEM_MEM_WA() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x38) >> 3
}
func (o *MODEM_SYSCON_Type) SetMEM_CONF_MODEM_MEM_RA(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0xc0)|value<<6)
}
func (o *MODEM_SYSCON_Type) GetMEM_CONF_MODEM_MEM_RA() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0xc0) >> 6
}

// MODEM_SYSCON.DATE
func (o *MODEM_SYSCON_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *MODEM_SYSCON_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// OTP_DEBUG Peripheral
type OTP_DEBUG_Type struct {
	WR_DIS          volatile.Register32 // 0x0
	BLK0_BACKUP1_W1 volatile.Register32 // 0x4
	BLK0_BACKUP1_W2 volatile.Register32 // 0x8
	BLK0_BACKUP1_W3 volatile.Register32 // 0xC
	BLK0_BACKUP1_W4 volatile.Register32 // 0x10
	BLK0_BACKUP1_W5 volatile.Register32 // 0x14
	BLK0_BACKUP2_W1 volatile.Register32 // 0x18
	BLK0_BACKUP2_W2 volatile.Register32 // 0x1C
	BLK0_BACKUP2_W3 volatile.Register32 // 0x20
	BLK0_BACKUP2_W4 volatile.Register32 // 0x24
	BLK0_BACKUP2_W5 volatile.Register32 // 0x28
	BLK0_BACKUP3_W1 volatile.Register32 // 0x2C
	BLK0_BACKUP3_W2 volatile.Register32 // 0x30
	BLK0_BACKUP3_W3 volatile.Register32 // 0x34
	BLK0_BACKUP3_W4 volatile.Register32 // 0x38
	BLK0_BACKUP3_W5 volatile.Register32 // 0x3C
	BLK0_BACKUP4_W1 volatile.Register32 // 0x40
	BLK0_BACKUP4_W2 volatile.Register32 // 0x44
	BLK0_BACKUP4_W3 volatile.Register32 // 0x48
	BLK0_BACKUP4_W4 volatile.Register32 // 0x4C
	BLK0_BACKUP4_W5 volatile.Register32 // 0x50
	BLK1_W1         volatile.Register32 // 0x54
	BLK1_W2         volatile.Register32 // 0x58
	BLK1_W3         volatile.Register32 // 0x5C
	BLK1_W4         volatile.Register32 // 0x60
	BLK1_W5         volatile.Register32 // 0x64
	BLK1_W6         volatile.Register32 // 0x68
	BLK1_W7         volatile.Register32 // 0x6C
	BLK1_W8         volatile.Register32 // 0x70
	BLK1_W9         volatile.Register32 // 0x74
	BLK2_W1         volatile.Register32 // 0x78
	BLK2_W2         volatile.Register32 // 0x7C
	BLK2_W3         volatile.Register32 // 0x80
	BLK2_W4         volatile.Register32 // 0x84
	BLK2_W5         volatile.Register32 // 0x88
	BLK2_W6         volatile.Register32 // 0x8C
	BLK2_W7         volatile.Register32 // 0x90
	BLK2_W8         volatile.Register32 // 0x94
	BLK2_W9         volatile.Register32 // 0x98
	BLK2_W10        volatile.Register32 // 0x9C
	BLK2_W11        volatile.Register32 // 0xA0
	BLK3_W1         volatile.Register32 // 0xA4
	BLK3_W2         volatile.Register32 // 0xA8
	BLK3_W3         volatile.Register32 // 0xAC
	BLK3_W4         volatile.Register32 // 0xB0
	BLK3_W5         volatile.Register32 // 0xB4
	BLK3_W6         volatile.Register32 // 0xB8
	BLK3_W7         volatile.Register32 // 0xBC
	BLK3_W8         volatile.Register32 // 0xC0
	BLK3_W9         volatile.Register32 // 0xC4
	BLK3_W10        volatile.Register32 // 0xC8
	BLK3_W11        volatile.Register32 // 0xCC
	BLK4_W1         volatile.Register32 // 0xD0
	BLK4_W2         volatile.Register32 // 0xD4
	BLK4_W3         volatile.Register32 // 0xD8
	BLK4_W4         volatile.Register32 // 0xDC
	BLK4_W5         volatile.Register32 // 0xE0
	BLK4_W6         volatile.Register32 // 0xE4
	BLK4_W7         volatile.Register32 // 0xE8
	BLK4_W8         volatile.Register32 // 0xEC
	BLK4_W9         volatile.Register32 // 0xF0
	BLK4_W10        volatile.Register32 // 0xF4
	BLK4_W11        volatile.Register32 // 0xF8
	BLK5_W1         volatile.Register32 // 0xFC
	BLK5_W2         volatile.Register32 // 0x100
	BLK5_W3         volatile.Register32 // 0x104
	BLK5_W4         volatile.Register32 // 0x108
	BLK5_W5         volatile.Register32 // 0x10C
	BLK5_W6         volatile.Register32 // 0x110
	BLK5_W7         volatile.Register32 // 0x114
	BLK5_W8         volatile.Register32 // 0x118
	BLK5_W9         volatile.Register32 // 0x11C
	BLK5_W10        volatile.Register32 // 0x120
	BLK5_W11        volatile.Register32 // 0x124
	BLK6_W1         volatile.Register32 // 0x128
	BLK6_W2         volatile.Register32 // 0x12C
	BLK6_W3         volatile.Register32 // 0x130
	BLK6_W4         volatile.Register32 // 0x134
	BLK6_W5         volatile.Register32 // 0x138
	BLK6_W6         volatile.Register32 // 0x13C
	BLK6_W7         volatile.Register32 // 0x140
	BLK6_W8         volatile.Register32 // 0x144
	BLK6_W9         volatile.Register32 // 0x148
	BLK6_W10        volatile.Register32 // 0x14C
	BLK6_W11        volatile.Register32 // 0x150
	BLK7_W1         volatile.Register32 // 0x154
	BLK7_W2         volatile.Register32 // 0x158
	BLK7_W3         volatile.Register32 // 0x15C
	BLK7_W4         volatile.Register32 // 0x160
	BLK7_W5         volatile.Register32 // 0x164
	BLK7_W6         volatile.Register32 // 0x168
	BLK7_W7         volatile.Register32 // 0x16C
	BLK7_W8         volatile.Register32 // 0x170
	BLK7_W9         volatile.Register32 // 0x174
	BLK7_W10        volatile.Register32 // 0x178
	BLK7_W11        volatile.Register32 // 0x17C
	BLK8_W1         volatile.Register32 // 0x180
	BLK8_W2         volatile.Register32 // 0x184
	BLK8_W3         volatile.Register32 // 0x188
	BLK8_W4         volatile.Register32 // 0x18C
	BLK8_W5         volatile.Register32 // 0x190
	BLK8_W6         volatile.Register32 // 0x194
	BLK8_W7         volatile.Register32 // 0x198
	BLK8_W8         volatile.Register32 // 0x19C
	BLK8_W9         volatile.Register32 // 0x1A0
	BLK8_W10        volatile.Register32 // 0x1A4
	BLK8_W11        volatile.Register32 // 0x1A8
	BLK9_W1         volatile.Register32 // 0x1AC
	BLK9_W2         volatile.Register32 // 0x1B0
	BLK9_W3         volatile.Register32 // 0x1B4
	BLK9_W4         volatile.Register32 // 0x1B8
	BLK9_W5         volatile.Register32 // 0x1BC
	BLK9_W6         volatile.Register32 // 0x1C0
	BLK9_W7         volatile.Register32 // 0x1C4
	BLK9_W8         volatile.Register32 // 0x1C8
	BLK9_W9         volatile.Register32 // 0x1CC
	BLK9_W10        volatile.Register32 // 0x1D0
	BLK9_W11        volatile.Register32 // 0x1D4
	BLK10_W1        volatile.Register32 // 0x1D8
	BLK10_W2        volatile.Register32 // 0x1DC
	BLK10_W3        volatile.Register32 // 0x1E0
	BLK10_W4        volatile.Register32 // 0x1E4
	BLK10_W5        volatile.Register32 // 0x1E8
	BLK10_W6        volatile.Register32 // 0x1EC
	BLK10_W7        volatile.Register32 // 0x1F0
	BLK10_W8        volatile.Register32 // 0x1F4
	BLK10_W9        volatile.Register32 // 0x1F8
	BLK10_W10       volatile.Register32 // 0x1FC
	BLK10_W11       volatile.Register32 // 0x200
	CLK             volatile.Register32 // 0x204
	APB2OTP_EN      volatile.Register32 // 0x208
	DATE            volatile.Register32 // 0x20C
}

// OTP_DEBUG.WR_DIS: Otp debuger block0 data register1.
func (o *OTP_DEBUG_Type) SetWR_DIS(value uint32) {
	volatile.StoreUint32(&o.WR_DIS.Reg, value)
}
func (o *OTP_DEBUG_Type) GetWR_DIS() uint32 {
	return volatile.LoadUint32(&o.WR_DIS.Reg)
}

// OTP_DEBUG.BLK0_BACKUP1_W1: Otp debuger block0 data register2.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP1_W1(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP1_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP1_W1() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP1_W1.Reg)
}

// OTP_DEBUG.BLK0_BACKUP1_W2: Otp debuger block0 data register3.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP1_W2(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP1_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP1_W2() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP1_W2.Reg)
}

// OTP_DEBUG.BLK0_BACKUP1_W3: Otp debuger block0 data register4.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP1_W3(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP1_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP1_W3() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP1_W3.Reg)
}

// OTP_DEBUG.BLK0_BACKUP1_W4: Otp debuger block0 data register5.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP1_W4(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP1_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP1_W4() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP1_W4.Reg)
}

// OTP_DEBUG.BLK0_BACKUP1_W5: Otp debuger block0 data register6.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP1_W5(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP1_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP1_W5() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP1_W5.Reg)
}

// OTP_DEBUG.BLK0_BACKUP2_W1: Otp debuger block0 data register7.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP2_W1(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP2_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP2_W1() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP2_W1.Reg)
}

// OTP_DEBUG.BLK0_BACKUP2_W2: Otp debuger block0 data register8.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP2_W2(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP2_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP2_W2() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP2_W2.Reg)
}

// OTP_DEBUG.BLK0_BACKUP2_W3: Otp debuger block0 data register9.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP2_W3(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP2_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP2_W3() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP2_W3.Reg)
}

// OTP_DEBUG.BLK0_BACKUP2_W4: Otp debuger block0 data register10.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP2_W4(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP2_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP2_W4() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP2_W4.Reg)
}

// OTP_DEBUG.BLK0_BACKUP2_W5: Otp debuger block0 data register11.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP2_W5(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP2_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP2_W5() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP2_W5.Reg)
}

// OTP_DEBUG.BLK0_BACKUP3_W1: Otp debuger block0 data register12.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP3_W1(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP3_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP3_W1() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP3_W1.Reg)
}

// OTP_DEBUG.BLK0_BACKUP3_W2: Otp debuger block0 data register13.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP3_W2(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP3_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP3_W2() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP3_W2.Reg)
}

// OTP_DEBUG.BLK0_BACKUP3_W3: Otp debuger block0 data register14.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP3_W3(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP3_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP3_W3() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP3_W3.Reg)
}

// OTP_DEBUG.BLK0_BACKUP3_W4: Otp debuger block0 data register15.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP3_W4(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP3_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP3_W4() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP3_W4.Reg)
}

// OTP_DEBUG.BLK0_BACKUP3_W5: Otp debuger block0 data register16.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP3_W5(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP3_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP3_W5() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP3_W5.Reg)
}

// OTP_DEBUG.BLK0_BACKUP4_W1: Otp debuger block0 data register17.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP4_W1(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP4_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP4_W1() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP4_W1.Reg)
}

// OTP_DEBUG.BLK0_BACKUP4_W2: Otp debuger block0 data register18.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP4_W2(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP4_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP4_W2() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP4_W2.Reg)
}

// OTP_DEBUG.BLK0_BACKUP4_W3: Otp debuger block0 data register19.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP4_W3(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP4_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP4_W3() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP4_W3.Reg)
}

// OTP_DEBUG.BLK0_BACKUP4_W4: Otp debuger block0 data register20.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP4_W4(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP4_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP4_W4() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP4_W4.Reg)
}

// OTP_DEBUG.BLK0_BACKUP4_W5: Otp debuger block0 data register21.
func (o *OTP_DEBUG_Type) SetBLK0_BACKUP4_W5(value uint32) {
	volatile.StoreUint32(&o.BLK0_BACKUP4_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK0_BACKUP4_W5() uint32 {
	return volatile.LoadUint32(&o.BLK0_BACKUP4_W5.Reg)
}

// OTP_DEBUG.BLK1_W1: Otp debuger block1 data register1.
func (o *OTP_DEBUG_Type) SetBLK1_W1(value uint32) {
	volatile.StoreUint32(&o.BLK1_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK1_W1() uint32 {
	return volatile.LoadUint32(&o.BLK1_W1.Reg)
}

// OTP_DEBUG.BLK1_W2: Otp debuger block1 data register2.
func (o *OTP_DEBUG_Type) SetBLK1_W2(value uint32) {
	volatile.StoreUint32(&o.BLK1_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK1_W2() uint32 {
	return volatile.LoadUint32(&o.BLK1_W2.Reg)
}

// OTP_DEBUG.BLK1_W3: Otp debuger block1 data register3.
func (o *OTP_DEBUG_Type) SetBLK1_W3(value uint32) {
	volatile.StoreUint32(&o.BLK1_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK1_W3() uint32 {
	return volatile.LoadUint32(&o.BLK1_W3.Reg)
}

// OTP_DEBUG.BLK1_W4: Otp debuger block1 data register4.
func (o *OTP_DEBUG_Type) SetBLK1_W4(value uint32) {
	volatile.StoreUint32(&o.BLK1_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK1_W4() uint32 {
	return volatile.LoadUint32(&o.BLK1_W4.Reg)
}

// OTP_DEBUG.BLK1_W5: Otp debuger block1 data register5.
func (o *OTP_DEBUG_Type) SetBLK1_W5(value uint32) {
	volatile.StoreUint32(&o.BLK1_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK1_W5() uint32 {
	return volatile.LoadUint32(&o.BLK1_W5.Reg)
}

// OTP_DEBUG.BLK1_W6: Otp debuger block1 data register6.
func (o *OTP_DEBUG_Type) SetBLK1_W6(value uint32) {
	volatile.StoreUint32(&o.BLK1_W6.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK1_W6() uint32 {
	return volatile.LoadUint32(&o.BLK1_W6.Reg)
}

// OTP_DEBUG.BLK1_W7: Otp debuger block1 data register7.
func (o *OTP_DEBUG_Type) SetBLK1_W7(value uint32) {
	volatile.StoreUint32(&o.BLK1_W7.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK1_W7() uint32 {
	return volatile.LoadUint32(&o.BLK1_W7.Reg)
}

// OTP_DEBUG.BLK1_W8: Otp debuger block1 data register8.
func (o *OTP_DEBUG_Type) SetBLK1_W8(value uint32) {
	volatile.StoreUint32(&o.BLK1_W8.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK1_W8() uint32 {
	return volatile.LoadUint32(&o.BLK1_W8.Reg)
}

// OTP_DEBUG.BLK1_W9: Otp debuger block1 data register9.
func (o *OTP_DEBUG_Type) SetBLK1_W9(value uint32) {
	volatile.StoreUint32(&o.BLK1_W9.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK1_W9() uint32 {
	return volatile.LoadUint32(&o.BLK1_W9.Reg)
}

// OTP_DEBUG.BLK2_W1: Otp debuger block2 data register1.
func (o *OTP_DEBUG_Type) SetBLK2_W1(value uint32) {
	volatile.StoreUint32(&o.BLK2_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK2_W1() uint32 {
	return volatile.LoadUint32(&o.BLK2_W1.Reg)
}

// OTP_DEBUG.BLK2_W2: Otp debuger block2 data register2.
func (o *OTP_DEBUG_Type) SetBLK2_W2(value uint32) {
	volatile.StoreUint32(&o.BLK2_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK2_W2() uint32 {
	return volatile.LoadUint32(&o.BLK2_W2.Reg)
}

// OTP_DEBUG.BLK2_W3: Otp debuger block2 data register3.
func (o *OTP_DEBUG_Type) SetBLK2_W3(value uint32) {
	volatile.StoreUint32(&o.BLK2_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK2_W3() uint32 {
	return volatile.LoadUint32(&o.BLK2_W3.Reg)
}

// OTP_DEBUG.BLK2_W4: Otp debuger block2 data register4.
func (o *OTP_DEBUG_Type) SetBLK2_W4(value uint32) {
	volatile.StoreUint32(&o.BLK2_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK2_W4() uint32 {
	return volatile.LoadUint32(&o.BLK2_W4.Reg)
}

// OTP_DEBUG.BLK2_W5: Otp debuger block2 data register5.
func (o *OTP_DEBUG_Type) SetBLK2_W5(value uint32) {
	volatile.StoreUint32(&o.BLK2_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK2_W5() uint32 {
	return volatile.LoadUint32(&o.BLK2_W5.Reg)
}

// OTP_DEBUG.BLK2_W6: Otp debuger block2 data register6.
func (o *OTP_DEBUG_Type) SetBLK2_W6(value uint32) {
	volatile.StoreUint32(&o.BLK2_W6.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK2_W6() uint32 {
	return volatile.LoadUint32(&o.BLK2_W6.Reg)
}

// OTP_DEBUG.BLK2_W7: Otp debuger block2 data register7.
func (o *OTP_DEBUG_Type) SetBLK2_W7(value uint32) {
	volatile.StoreUint32(&o.BLK2_W7.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK2_W7() uint32 {
	return volatile.LoadUint32(&o.BLK2_W7.Reg)
}

// OTP_DEBUG.BLK2_W8: Otp debuger block2 data register8.
func (o *OTP_DEBUG_Type) SetBLK2_W8(value uint32) {
	volatile.StoreUint32(&o.BLK2_W8.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK2_W8() uint32 {
	return volatile.LoadUint32(&o.BLK2_W8.Reg)
}

// OTP_DEBUG.BLK2_W9: Otp debuger block2 data register9.
func (o *OTP_DEBUG_Type) SetBLK2_W9(value uint32) {
	volatile.StoreUint32(&o.BLK2_W9.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK2_W9() uint32 {
	return volatile.LoadUint32(&o.BLK2_W9.Reg)
}

// OTP_DEBUG.BLK2_W10: Otp debuger block2 data register10.
func (o *OTP_DEBUG_Type) SetBLK2_W10(value uint32) {
	volatile.StoreUint32(&o.BLK2_W10.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK2_W10() uint32 {
	return volatile.LoadUint32(&o.BLK2_W10.Reg)
}

// OTP_DEBUG.BLK2_W11: Otp debuger block2 data register11.
func (o *OTP_DEBUG_Type) SetBLK2_W11(value uint32) {
	volatile.StoreUint32(&o.BLK2_W11.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK2_W11() uint32 {
	return volatile.LoadUint32(&o.BLK2_W11.Reg)
}

// OTP_DEBUG.BLK3_W1: Otp debuger block3 data register1.
func (o *OTP_DEBUG_Type) SetBLK3_W1(value uint32) {
	volatile.StoreUint32(&o.BLK3_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK3_W1() uint32 {
	return volatile.LoadUint32(&o.BLK3_W1.Reg)
}

// OTP_DEBUG.BLK3_W2: Otp debuger block3 data register2.
func (o *OTP_DEBUG_Type) SetBLK3_W2(value uint32) {
	volatile.StoreUint32(&o.BLK3_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK3_W2() uint32 {
	return volatile.LoadUint32(&o.BLK3_W2.Reg)
}

// OTP_DEBUG.BLK3_W3: Otp debuger block3 data register3.
func (o *OTP_DEBUG_Type) SetBLK3_W3(value uint32) {
	volatile.StoreUint32(&o.BLK3_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK3_W3() uint32 {
	return volatile.LoadUint32(&o.BLK3_W3.Reg)
}

// OTP_DEBUG.BLK3_W4: Otp debuger block3 data register4.
func (o *OTP_DEBUG_Type) SetBLK3_W4(value uint32) {
	volatile.StoreUint32(&o.BLK3_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK3_W4() uint32 {
	return volatile.LoadUint32(&o.BLK3_W4.Reg)
}

// OTP_DEBUG.BLK3_W5: Otp debuger block3 data register5.
func (o *OTP_DEBUG_Type) SetBLK3_W5(value uint32) {
	volatile.StoreUint32(&o.BLK3_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK3_W5() uint32 {
	return volatile.LoadUint32(&o.BLK3_W5.Reg)
}

// OTP_DEBUG.BLK3_W6: Otp debuger block3 data register6.
func (o *OTP_DEBUG_Type) SetBLK3_W6(value uint32) {
	volatile.StoreUint32(&o.BLK3_W6.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK3_W6() uint32 {
	return volatile.LoadUint32(&o.BLK3_W6.Reg)
}

// OTP_DEBUG.BLK3_W7: Otp debuger block3 data register7.
func (o *OTP_DEBUG_Type) SetBLK3_W7(value uint32) {
	volatile.StoreUint32(&o.BLK3_W7.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK3_W7() uint32 {
	return volatile.LoadUint32(&o.BLK3_W7.Reg)
}

// OTP_DEBUG.BLK3_W8: Otp debuger block3 data register8.
func (o *OTP_DEBUG_Type) SetBLK3_W8(value uint32) {
	volatile.StoreUint32(&o.BLK3_W8.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK3_W8() uint32 {
	return volatile.LoadUint32(&o.BLK3_W8.Reg)
}

// OTP_DEBUG.BLK3_W9: Otp debuger block3 data register9.
func (o *OTP_DEBUG_Type) SetBLK3_W9(value uint32) {
	volatile.StoreUint32(&o.BLK3_W9.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK3_W9() uint32 {
	return volatile.LoadUint32(&o.BLK3_W9.Reg)
}

// OTP_DEBUG.BLK3_W10: Otp debuger block3 data register10.
func (o *OTP_DEBUG_Type) SetBLK3_W10(value uint32) {
	volatile.StoreUint32(&o.BLK3_W10.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK3_W10() uint32 {
	return volatile.LoadUint32(&o.BLK3_W10.Reg)
}

// OTP_DEBUG.BLK3_W11: Otp debuger block3 data register11.
func (o *OTP_DEBUG_Type) SetBLK3_W11(value uint32) {
	volatile.StoreUint32(&o.BLK3_W11.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK3_W11() uint32 {
	return volatile.LoadUint32(&o.BLK3_W11.Reg)
}

// OTP_DEBUG.BLK4_W1: Otp debuger block4 data register1.
func (o *OTP_DEBUG_Type) SetBLK4_W1(value uint32) {
	volatile.StoreUint32(&o.BLK4_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK4_W1() uint32 {
	return volatile.LoadUint32(&o.BLK4_W1.Reg)
}

// OTP_DEBUG.BLK4_W2: Otp debuger block4 data register2.
func (o *OTP_DEBUG_Type) SetBLK4_W2(value uint32) {
	volatile.StoreUint32(&o.BLK4_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK4_W2() uint32 {
	return volatile.LoadUint32(&o.BLK4_W2.Reg)
}

// OTP_DEBUG.BLK4_W3: Otp debuger block4 data register3.
func (o *OTP_DEBUG_Type) SetBLK4_W3(value uint32) {
	volatile.StoreUint32(&o.BLK4_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK4_W3() uint32 {
	return volatile.LoadUint32(&o.BLK4_W3.Reg)
}

// OTP_DEBUG.BLK4_W4: Otp debuger block4 data register4.
func (o *OTP_DEBUG_Type) SetBLK4_W4(value uint32) {
	volatile.StoreUint32(&o.BLK4_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK4_W4() uint32 {
	return volatile.LoadUint32(&o.BLK4_W4.Reg)
}

// OTP_DEBUG.BLK4_W5: Otp debuger block4 data register5.
func (o *OTP_DEBUG_Type) SetBLK4_W5(value uint32) {
	volatile.StoreUint32(&o.BLK4_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK4_W5() uint32 {
	return volatile.LoadUint32(&o.BLK4_W5.Reg)
}

// OTP_DEBUG.BLK4_W6: Otp debuger block4 data register6.
func (o *OTP_DEBUG_Type) SetBLK4_W6(value uint32) {
	volatile.StoreUint32(&o.BLK4_W6.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK4_W6() uint32 {
	return volatile.LoadUint32(&o.BLK4_W6.Reg)
}

// OTP_DEBUG.BLK4_W7: Otp debuger block4 data register7.
func (o *OTP_DEBUG_Type) SetBLK4_W7(value uint32) {
	volatile.StoreUint32(&o.BLK4_W7.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK4_W7() uint32 {
	return volatile.LoadUint32(&o.BLK4_W7.Reg)
}

// OTP_DEBUG.BLK4_W8: Otp debuger block4 data register8.
func (o *OTP_DEBUG_Type) SetBLK4_W8(value uint32) {
	volatile.StoreUint32(&o.BLK4_W8.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK4_W8() uint32 {
	return volatile.LoadUint32(&o.BLK4_W8.Reg)
}

// OTP_DEBUG.BLK4_W9: Otp debuger block4 data register9.
func (o *OTP_DEBUG_Type) SetBLK4_W9(value uint32) {
	volatile.StoreUint32(&o.BLK4_W9.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK4_W9() uint32 {
	return volatile.LoadUint32(&o.BLK4_W9.Reg)
}

// OTP_DEBUG.BLK4_W10: Otp debuger block4 data registe10.
func (o *OTP_DEBUG_Type) SetBLK4_W10(value uint32) {
	volatile.StoreUint32(&o.BLK4_W10.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK4_W10() uint32 {
	return volatile.LoadUint32(&o.BLK4_W10.Reg)
}

// OTP_DEBUG.BLK4_W11: Otp debuger block4 data register11.
func (o *OTP_DEBUG_Type) SetBLK4_W11(value uint32) {
	volatile.StoreUint32(&o.BLK4_W11.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK4_W11() uint32 {
	return volatile.LoadUint32(&o.BLK4_W11.Reg)
}

// OTP_DEBUG.BLK5_W1: Otp debuger block5 data register1.
func (o *OTP_DEBUG_Type) SetBLK5_W1(value uint32) {
	volatile.StoreUint32(&o.BLK5_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK5_W1() uint32 {
	return volatile.LoadUint32(&o.BLK5_W1.Reg)
}

// OTP_DEBUG.BLK5_W2: Otp debuger block5 data register2.
func (o *OTP_DEBUG_Type) SetBLK5_W2(value uint32) {
	volatile.StoreUint32(&o.BLK5_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK5_W2() uint32 {
	return volatile.LoadUint32(&o.BLK5_W2.Reg)
}

// OTP_DEBUG.BLK5_W3: Otp debuger block5 data register3.
func (o *OTP_DEBUG_Type) SetBLK5_W3(value uint32) {
	volatile.StoreUint32(&o.BLK5_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK5_W3() uint32 {
	return volatile.LoadUint32(&o.BLK5_W3.Reg)
}

// OTP_DEBUG.BLK5_W4: Otp debuger block5 data register4.
func (o *OTP_DEBUG_Type) SetBLK5_W4(value uint32) {
	volatile.StoreUint32(&o.BLK5_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK5_W4() uint32 {
	return volatile.LoadUint32(&o.BLK5_W4.Reg)
}

// OTP_DEBUG.BLK5_W5: Otp debuger block5 data register5.
func (o *OTP_DEBUG_Type) SetBLK5_W5(value uint32) {
	volatile.StoreUint32(&o.BLK5_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK5_W5() uint32 {
	return volatile.LoadUint32(&o.BLK5_W5.Reg)
}

// OTP_DEBUG.BLK5_W6: Otp debuger block5 data register6.
func (o *OTP_DEBUG_Type) SetBLK5_W6(value uint32) {
	volatile.StoreUint32(&o.BLK5_W6.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK5_W6() uint32 {
	return volatile.LoadUint32(&o.BLK5_W6.Reg)
}

// OTP_DEBUG.BLK5_W7: Otp debuger block5 data register7.
func (o *OTP_DEBUG_Type) SetBLK5_W7(value uint32) {
	volatile.StoreUint32(&o.BLK5_W7.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK5_W7() uint32 {
	return volatile.LoadUint32(&o.BLK5_W7.Reg)
}

// OTP_DEBUG.BLK5_W8: Otp debuger block5 data register8.
func (o *OTP_DEBUG_Type) SetBLK5_W8(value uint32) {
	volatile.StoreUint32(&o.BLK5_W8.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK5_W8() uint32 {
	return volatile.LoadUint32(&o.BLK5_W8.Reg)
}

// OTP_DEBUG.BLK5_W9: Otp debuger block5 data register9.
func (o *OTP_DEBUG_Type) SetBLK5_W9(value uint32) {
	volatile.StoreUint32(&o.BLK5_W9.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK5_W9() uint32 {
	return volatile.LoadUint32(&o.BLK5_W9.Reg)
}

// OTP_DEBUG.BLK5_W10: Otp debuger block5 data register10.
func (o *OTP_DEBUG_Type) SetBLK5_W10(value uint32) {
	volatile.StoreUint32(&o.BLK5_W10.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK5_W10() uint32 {
	return volatile.LoadUint32(&o.BLK5_W10.Reg)
}

// OTP_DEBUG.BLK5_W11: Otp debuger block5 data register11.
func (o *OTP_DEBUG_Type) SetBLK5_W11(value uint32) {
	volatile.StoreUint32(&o.BLK5_W11.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK5_W11() uint32 {
	return volatile.LoadUint32(&o.BLK5_W11.Reg)
}

// OTP_DEBUG.BLK6_W1: Otp debuger block6 data register1.
func (o *OTP_DEBUG_Type) SetBLK6_W1(value uint32) {
	volatile.StoreUint32(&o.BLK6_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK6_W1() uint32 {
	return volatile.LoadUint32(&o.BLK6_W1.Reg)
}

// OTP_DEBUG.BLK6_W2: Otp debuger block6 data register2.
func (o *OTP_DEBUG_Type) SetBLK6_W2(value uint32) {
	volatile.StoreUint32(&o.BLK6_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK6_W2() uint32 {
	return volatile.LoadUint32(&o.BLK6_W2.Reg)
}

// OTP_DEBUG.BLK6_W3: Otp debuger block6 data register3.
func (o *OTP_DEBUG_Type) SetBLK6_W3(value uint32) {
	volatile.StoreUint32(&o.BLK6_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK6_W3() uint32 {
	return volatile.LoadUint32(&o.BLK6_W3.Reg)
}

// OTP_DEBUG.BLK6_W4: Otp debuger block6 data register4.
func (o *OTP_DEBUG_Type) SetBLK6_W4(value uint32) {
	volatile.StoreUint32(&o.BLK6_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK6_W4() uint32 {
	return volatile.LoadUint32(&o.BLK6_W4.Reg)
}

// OTP_DEBUG.BLK6_W5: Otp debuger block6 data register5.
func (o *OTP_DEBUG_Type) SetBLK6_W5(value uint32) {
	volatile.StoreUint32(&o.BLK6_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK6_W5() uint32 {
	return volatile.LoadUint32(&o.BLK6_W5.Reg)
}

// OTP_DEBUG.BLK6_W6: Otp debuger block6 data register6.
func (o *OTP_DEBUG_Type) SetBLK6_W6(value uint32) {
	volatile.StoreUint32(&o.BLK6_W6.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK6_W6() uint32 {
	return volatile.LoadUint32(&o.BLK6_W6.Reg)
}

// OTP_DEBUG.BLK6_W7: Otp debuger block6 data register7.
func (o *OTP_DEBUG_Type) SetBLK6_W7(value uint32) {
	volatile.StoreUint32(&o.BLK6_W7.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK6_W7() uint32 {
	return volatile.LoadUint32(&o.BLK6_W7.Reg)
}

// OTP_DEBUG.BLK6_W8: Otp debuger block6 data register8.
func (o *OTP_DEBUG_Type) SetBLK6_W8(value uint32) {
	volatile.StoreUint32(&o.BLK6_W8.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK6_W8() uint32 {
	return volatile.LoadUint32(&o.BLK6_W8.Reg)
}

// OTP_DEBUG.BLK6_W9: Otp debuger block6 data register9.
func (o *OTP_DEBUG_Type) SetBLK6_W9(value uint32) {
	volatile.StoreUint32(&o.BLK6_W9.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK6_W9() uint32 {
	return volatile.LoadUint32(&o.BLK6_W9.Reg)
}

// OTP_DEBUG.BLK6_W10: Otp debuger block6 data register10.
func (o *OTP_DEBUG_Type) SetBLK6_W10(value uint32) {
	volatile.StoreUint32(&o.BLK6_W10.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK6_W10() uint32 {
	return volatile.LoadUint32(&o.BLK6_W10.Reg)
}

// OTP_DEBUG.BLK6_W11: Otp debuger block6 data register11.
func (o *OTP_DEBUG_Type) SetBLK6_W11(value uint32) {
	volatile.StoreUint32(&o.BLK6_W11.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK6_W11() uint32 {
	return volatile.LoadUint32(&o.BLK6_W11.Reg)
}

// OTP_DEBUG.BLK7_W1: Otp debuger block7 data register1.
func (o *OTP_DEBUG_Type) SetBLK7_W1(value uint32) {
	volatile.StoreUint32(&o.BLK7_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK7_W1() uint32 {
	return volatile.LoadUint32(&o.BLK7_W1.Reg)
}

// OTP_DEBUG.BLK7_W2: Otp debuger block7 data register2.
func (o *OTP_DEBUG_Type) SetBLK7_W2(value uint32) {
	volatile.StoreUint32(&o.BLK7_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK7_W2() uint32 {
	return volatile.LoadUint32(&o.BLK7_W2.Reg)
}

// OTP_DEBUG.BLK7_W3: Otp debuger block7 data register3.
func (o *OTP_DEBUG_Type) SetBLK7_W3(value uint32) {
	volatile.StoreUint32(&o.BLK7_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK7_W3() uint32 {
	return volatile.LoadUint32(&o.BLK7_W3.Reg)
}

// OTP_DEBUG.BLK7_W4: Otp debuger block7 data register4.
func (o *OTP_DEBUG_Type) SetBLK7_W4(value uint32) {
	volatile.StoreUint32(&o.BLK7_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK7_W4() uint32 {
	return volatile.LoadUint32(&o.BLK7_W4.Reg)
}

// OTP_DEBUG.BLK7_W5: Otp debuger block7 data register5.
func (o *OTP_DEBUG_Type) SetBLK7_W5(value uint32) {
	volatile.StoreUint32(&o.BLK7_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK7_W5() uint32 {
	return volatile.LoadUint32(&o.BLK7_W5.Reg)
}

// OTP_DEBUG.BLK7_W6: Otp debuger block7 data register6.
func (o *OTP_DEBUG_Type) SetBLK7_W6(value uint32) {
	volatile.StoreUint32(&o.BLK7_W6.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK7_W6() uint32 {
	return volatile.LoadUint32(&o.BLK7_W6.Reg)
}

// OTP_DEBUG.BLK7_W7: Otp debuger block7 data register7.
func (o *OTP_DEBUG_Type) SetBLK7_W7(value uint32) {
	volatile.StoreUint32(&o.BLK7_W7.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK7_W7() uint32 {
	return volatile.LoadUint32(&o.BLK7_W7.Reg)
}

// OTP_DEBUG.BLK7_W8: Otp debuger block7 data register8.
func (o *OTP_DEBUG_Type) SetBLK7_W8(value uint32) {
	volatile.StoreUint32(&o.BLK7_W8.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK7_W8() uint32 {
	return volatile.LoadUint32(&o.BLK7_W8.Reg)
}

// OTP_DEBUG.BLK7_W9: Otp debuger block7 data register9.
func (o *OTP_DEBUG_Type) SetBLK7_W9(value uint32) {
	volatile.StoreUint32(&o.BLK7_W9.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK7_W9() uint32 {
	return volatile.LoadUint32(&o.BLK7_W9.Reg)
}

// OTP_DEBUG.BLK7_W10: Otp debuger block7 data register10.
func (o *OTP_DEBUG_Type) SetBLK7_W10(value uint32) {
	volatile.StoreUint32(&o.BLK7_W10.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK7_W10() uint32 {
	return volatile.LoadUint32(&o.BLK7_W10.Reg)
}

// OTP_DEBUG.BLK7_W11: Otp debuger block7 data register11.
func (o *OTP_DEBUG_Type) SetBLK7_W11(value uint32) {
	volatile.StoreUint32(&o.BLK7_W11.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK7_W11() uint32 {
	return volatile.LoadUint32(&o.BLK7_W11.Reg)
}

// OTP_DEBUG.BLK8_W1: Otp debuger block8 data register1.
func (o *OTP_DEBUG_Type) SetBLK8_W1(value uint32) {
	volatile.StoreUint32(&o.BLK8_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK8_W1() uint32 {
	return volatile.LoadUint32(&o.BLK8_W1.Reg)
}

// OTP_DEBUG.BLK8_W2: Otp debuger block8 data register2.
func (o *OTP_DEBUG_Type) SetBLK8_W2(value uint32) {
	volatile.StoreUint32(&o.BLK8_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK8_W2() uint32 {
	return volatile.LoadUint32(&o.BLK8_W2.Reg)
}

// OTP_DEBUG.BLK8_W3: Otp debuger block8 data register3.
func (o *OTP_DEBUG_Type) SetBLK8_W3(value uint32) {
	volatile.StoreUint32(&o.BLK8_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK8_W3() uint32 {
	return volatile.LoadUint32(&o.BLK8_W3.Reg)
}

// OTP_DEBUG.BLK8_W4: Otp debuger block8 data register4.
func (o *OTP_DEBUG_Type) SetBLK8_W4(value uint32) {
	volatile.StoreUint32(&o.BLK8_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK8_W4() uint32 {
	return volatile.LoadUint32(&o.BLK8_W4.Reg)
}

// OTP_DEBUG.BLK8_W5: Otp debuger block8 data register5.
func (o *OTP_DEBUG_Type) SetBLK8_W5(value uint32) {
	volatile.StoreUint32(&o.BLK8_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK8_W5() uint32 {
	return volatile.LoadUint32(&o.BLK8_W5.Reg)
}

// OTP_DEBUG.BLK8_W6: Otp debuger block8 data register6.
func (o *OTP_DEBUG_Type) SetBLK8_W6(value uint32) {
	volatile.StoreUint32(&o.BLK8_W6.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK8_W6() uint32 {
	return volatile.LoadUint32(&o.BLK8_W6.Reg)
}

// OTP_DEBUG.BLK8_W7: Otp debuger block8 data register7.
func (o *OTP_DEBUG_Type) SetBLK8_W7(value uint32) {
	volatile.StoreUint32(&o.BLK8_W7.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK8_W7() uint32 {
	return volatile.LoadUint32(&o.BLK8_W7.Reg)
}

// OTP_DEBUG.BLK8_W8: Otp debuger block8 data register8.
func (o *OTP_DEBUG_Type) SetBLK8_W8(value uint32) {
	volatile.StoreUint32(&o.BLK8_W8.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK8_W8() uint32 {
	return volatile.LoadUint32(&o.BLK8_W8.Reg)
}

// OTP_DEBUG.BLK8_W9: Otp debuger block8 data register9.
func (o *OTP_DEBUG_Type) SetBLK8_W9(value uint32) {
	volatile.StoreUint32(&o.BLK8_W9.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK8_W9() uint32 {
	return volatile.LoadUint32(&o.BLK8_W9.Reg)
}

// OTP_DEBUG.BLK8_W10: Otp debuger block8 data register10.
func (o *OTP_DEBUG_Type) SetBLK8_W10(value uint32) {
	volatile.StoreUint32(&o.BLK8_W10.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK8_W10() uint32 {
	return volatile.LoadUint32(&o.BLK8_W10.Reg)
}

// OTP_DEBUG.BLK8_W11: Otp debuger block8 data register11.
func (o *OTP_DEBUG_Type) SetBLK8_W11(value uint32) {
	volatile.StoreUint32(&o.BLK8_W11.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK8_W11() uint32 {
	return volatile.LoadUint32(&o.BLK8_W11.Reg)
}

// OTP_DEBUG.BLK9_W1: Otp debuger block9 data register1.
func (o *OTP_DEBUG_Type) SetBLK9_W1(value uint32) {
	volatile.StoreUint32(&o.BLK9_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK9_W1() uint32 {
	return volatile.LoadUint32(&o.BLK9_W1.Reg)
}

// OTP_DEBUG.BLK9_W2: Otp debuger block9 data register2.
func (o *OTP_DEBUG_Type) SetBLK9_W2(value uint32) {
	volatile.StoreUint32(&o.BLK9_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK9_W2() uint32 {
	return volatile.LoadUint32(&o.BLK9_W2.Reg)
}

// OTP_DEBUG.BLK9_W3: Otp debuger block9 data register3.
func (o *OTP_DEBUG_Type) SetBLK9_W3(value uint32) {
	volatile.StoreUint32(&o.BLK9_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK9_W3() uint32 {
	return volatile.LoadUint32(&o.BLK9_W3.Reg)
}

// OTP_DEBUG.BLK9_W4: Otp debuger block9 data register4.
func (o *OTP_DEBUG_Type) SetBLK9_W4(value uint32) {
	volatile.StoreUint32(&o.BLK9_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK9_W4() uint32 {
	return volatile.LoadUint32(&o.BLK9_W4.Reg)
}

// OTP_DEBUG.BLK9_W5: Otp debuger block9 data register5.
func (o *OTP_DEBUG_Type) SetBLK9_W5(value uint32) {
	volatile.StoreUint32(&o.BLK9_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK9_W5() uint32 {
	return volatile.LoadUint32(&o.BLK9_W5.Reg)
}

// OTP_DEBUG.BLK9_W6: Otp debuger block9 data register6.
func (o *OTP_DEBUG_Type) SetBLK9_W6(value uint32) {
	volatile.StoreUint32(&o.BLK9_W6.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK9_W6() uint32 {
	return volatile.LoadUint32(&o.BLK9_W6.Reg)
}

// OTP_DEBUG.BLK9_W7: Otp debuger block9 data register7.
func (o *OTP_DEBUG_Type) SetBLK9_W7(value uint32) {
	volatile.StoreUint32(&o.BLK9_W7.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK9_W7() uint32 {
	return volatile.LoadUint32(&o.BLK9_W7.Reg)
}

// OTP_DEBUG.BLK9_W8: Otp debuger block9 data register8.
func (o *OTP_DEBUG_Type) SetBLK9_W8(value uint32) {
	volatile.StoreUint32(&o.BLK9_W8.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK9_W8() uint32 {
	return volatile.LoadUint32(&o.BLK9_W8.Reg)
}

// OTP_DEBUG.BLK9_W9: Otp debuger block9 data register9.
func (o *OTP_DEBUG_Type) SetBLK9_W9(value uint32) {
	volatile.StoreUint32(&o.BLK9_W9.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK9_W9() uint32 {
	return volatile.LoadUint32(&o.BLK9_W9.Reg)
}

// OTP_DEBUG.BLK9_W10: Otp debuger block9 data register10.
func (o *OTP_DEBUG_Type) SetBLK9_W10(value uint32) {
	volatile.StoreUint32(&o.BLK9_W10.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK9_W10() uint32 {
	return volatile.LoadUint32(&o.BLK9_W10.Reg)
}

// OTP_DEBUG.BLK9_W11: Otp debuger block9 data register11.
func (o *OTP_DEBUG_Type) SetBLK9_W11(value uint32) {
	volatile.StoreUint32(&o.BLK9_W11.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK9_W11() uint32 {
	return volatile.LoadUint32(&o.BLK9_W11.Reg)
}

// OTP_DEBUG.BLK10_W1: Otp debuger block10 data register1.
func (o *OTP_DEBUG_Type) SetBLK10_W1(value uint32) {
	volatile.StoreUint32(&o.BLK10_W1.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK10_W1() uint32 {
	return volatile.LoadUint32(&o.BLK10_W1.Reg)
}

// OTP_DEBUG.BLK10_W2: Otp debuger block10 data register2.
func (o *OTP_DEBUG_Type) SetBLK10_W2(value uint32) {
	volatile.StoreUint32(&o.BLK10_W2.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK10_W2() uint32 {
	return volatile.LoadUint32(&o.BLK10_W2.Reg)
}

// OTP_DEBUG.BLK10_W3: Otp debuger block10 data register3.
func (o *OTP_DEBUG_Type) SetBLK10_W3(value uint32) {
	volatile.StoreUint32(&o.BLK10_W3.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK10_W3() uint32 {
	return volatile.LoadUint32(&o.BLK10_W3.Reg)
}

// OTP_DEBUG.BLK10_W4: Otp debuger block10 data register4.
func (o *OTP_DEBUG_Type) SetBLK10_W4(value uint32) {
	volatile.StoreUint32(&o.BLK10_W4.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK10_W4() uint32 {
	return volatile.LoadUint32(&o.BLK10_W4.Reg)
}

// OTP_DEBUG.BLK10_W5: Otp debuger block10 data register5.
func (o *OTP_DEBUG_Type) SetBLK10_W5(value uint32) {
	volatile.StoreUint32(&o.BLK10_W5.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK10_W5() uint32 {
	return volatile.LoadUint32(&o.BLK10_W5.Reg)
}

// OTP_DEBUG.BLK10_W6: Otp debuger block10 data register6.
func (o *OTP_DEBUG_Type) SetBLK10_W6(value uint32) {
	volatile.StoreUint32(&o.BLK10_W6.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK10_W6() uint32 {
	return volatile.LoadUint32(&o.BLK10_W6.Reg)
}

// OTP_DEBUG.BLK10_W7: Otp debuger block10 data register7.
func (o *OTP_DEBUG_Type) SetBLK10_W7(value uint32) {
	volatile.StoreUint32(&o.BLK10_W7.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK10_W7() uint32 {
	return volatile.LoadUint32(&o.BLK10_W7.Reg)
}

// OTP_DEBUG.BLK10_W8: Otp debuger block10 data register8.
func (o *OTP_DEBUG_Type) SetBLK10_W8(value uint32) {
	volatile.StoreUint32(&o.BLK10_W8.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK10_W8() uint32 {
	return volatile.LoadUint32(&o.BLK10_W8.Reg)
}

// OTP_DEBUG.BLK10_W9: Otp debuger block10 data register9.
func (o *OTP_DEBUG_Type) SetBLK10_W9(value uint32) {
	volatile.StoreUint32(&o.BLK10_W9.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK10_W9() uint32 {
	return volatile.LoadUint32(&o.BLK10_W9.Reg)
}

// OTP_DEBUG.BLK10_W10: Otp debuger block10 data register10.
func (o *OTP_DEBUG_Type) SetBLK10_W10(value uint32) {
	volatile.StoreUint32(&o.BLK10_W10.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK10_W10() uint32 {
	return volatile.LoadUint32(&o.BLK10_W10.Reg)
}

// OTP_DEBUG.BLK10_W11: Otp debuger block10 data register11.
func (o *OTP_DEBUG_Type) SetBLK10_W11(value uint32) {
	volatile.StoreUint32(&o.BLK10_W11.Reg, value)
}
func (o *OTP_DEBUG_Type) GetBLK10_W11() uint32 {
	return volatile.LoadUint32(&o.BLK10_W11.Reg)
}

// OTP_DEBUG.CLK: Otp debuger clk_en configuration register.
func (o *OTP_DEBUG_Type) SetCLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x1)|value)
}
func (o *OTP_DEBUG_Type) GetCLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLK.Reg) & 0x1
}

// OTP_DEBUG.APB2OTP_EN: Otp_debuger apb2otp enable configuration register.
func (o *OTP_DEBUG_Type) SetAPB2OTP_EN(value uint32) {
	volatile.StoreUint32(&o.APB2OTP_EN.Reg, volatile.LoadUint32(&o.APB2OTP_EN.Reg)&^(0x1)|value)
}
func (o *OTP_DEBUG_Type) GetAPB2OTP_EN() uint32 {
	return volatile.LoadUint32(&o.APB2OTP_EN.Reg) & 0x1
}

// OTP_DEBUG.DATE: eFuse version register.
func (o *OTP_DEBUG_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *OTP_DEBUG_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// Parallel IO Controller
type PARL_IO_Type struct {
	RX_MODE_CFG  volatile.Register32 // 0x0
	RX_DATA_CFG  volatile.Register32 // 0x4
	RX_GENRL_CFG volatile.Register32 // 0x8
	RX_START_CFG volatile.Register32 // 0xC
	TX_DATA_CFG  volatile.Register32 // 0x10
	TX_START_CFG volatile.Register32 // 0x14
	TX_GENRL_CFG volatile.Register32 // 0x18
	FIFO_CFG     volatile.Register32 // 0x1C
	REG_UPDATE   volatile.Register32 // 0x20
	ST           volatile.Register32 // 0x24
	INT_ENA      volatile.Register32 // 0x28
	INT_RAW      volatile.Register32 // 0x2C
	INT_ST       volatile.Register32 // 0x30
	INT_CLR      volatile.Register32 // 0x34
	RX_ST0       volatile.Register32 // 0x38
	RX_ST1       volatile.Register32 // 0x3C
	TX_ST0       volatile.Register32 // 0x40
	RX_CLK_CFG   volatile.Register32 // 0x44
	TX_CLK_CFG   volatile.Register32 // 0x48
	_            [212]byte
	CLK          volatile.Register32 // 0x120
	_            [728]byte
	VERSION      volatile.Register32 // 0x3FC
}

// PARL_IO.RX_MODE_CFG: Parallel RX Sampling mode configuration register.
func (o *PARL_IO_Type) SetRX_MODE_CFG_RX_EXT_EN_SEL(value uint32) {
	volatile.StoreUint32(&o.RX_MODE_CFG.Reg, volatile.LoadUint32(&o.RX_MODE_CFG.Reg)&^(0x1e00000)|value<<21)
}
func (o *PARL_IO_Type) GetRX_MODE_CFG_RX_EXT_EN_SEL() uint32 {
	return (volatile.LoadUint32(&o.RX_MODE_CFG.Reg) & 0x1e00000) >> 21
}
func (o *PARL_IO_Type) SetRX_MODE_CFG_RX_SW_EN(value uint32) {
	volatile.StoreUint32(&o.RX_MODE_CFG.Reg, volatile.LoadUint32(&o.RX_MODE_CFG.Reg)&^(0x2000000)|value<<25)
}
func (o *PARL_IO_Type) GetRX_MODE_CFG_RX_SW_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_MODE_CFG.Reg) & 0x2000000) >> 25
}
func (o *PARL_IO_Type) SetRX_MODE_CFG_RX_EXT_EN_INV(value uint32) {
	volatile.StoreUint32(&o.RX_MODE_CFG.Reg, volatile.LoadUint32(&o.RX_MODE_CFG.Reg)&^(0x4000000)|value<<26)
}
func (o *PARL_IO_Type) GetRX_MODE_CFG_RX_EXT_EN_INV() uint32 {
	return (volatile.LoadUint32(&o.RX_MODE_CFG.Reg) & 0x4000000) >> 26
}
func (o *PARL_IO_Type) SetRX_MODE_CFG_RX_PULSE_SUBMODE_SEL(value uint32) {
	volatile.StoreUint32(&o.RX_MODE_CFG.Reg, volatile.LoadUint32(&o.RX_MODE_CFG.Reg)&^(0x38000000)|value<<27)
}
func (o *PARL_IO_Type) GetRX_MODE_CFG_RX_PULSE_SUBMODE_SEL() uint32 {
	return (volatile.LoadUint32(&o.RX_MODE_CFG.Reg) & 0x38000000) >> 27
}
func (o *PARL_IO_Type) SetRX_MODE_CFG_RX_SMP_MODE_SEL(value uint32) {
	volatile.StoreUint32(&o.RX_MODE_CFG.Reg, volatile.LoadUint32(&o.RX_MODE_CFG.Reg)&^(0xc0000000)|value<<30)
}
func (o *PARL_IO_Type) GetRX_MODE_CFG_RX_SMP_MODE_SEL() uint32 {
	return (volatile.LoadUint32(&o.RX_MODE_CFG.Reg) & 0xc0000000) >> 30
}

// PARL_IO.RX_DATA_CFG: Parallel RX data configuration register.
func (o *PARL_IO_Type) SetRX_DATA_CFG_RX_BITLEN(value uint32) {
	volatile.StoreUint32(&o.RX_DATA_CFG.Reg, volatile.LoadUint32(&o.RX_DATA_CFG.Reg)&^(0xffffe00)|value<<9)
}
func (o *PARL_IO_Type) GetRX_DATA_CFG_RX_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.RX_DATA_CFG.Reg) & 0xffffe00) >> 9
}
func (o *PARL_IO_Type) SetRX_DATA_CFG_RX_DATA_ORDER_INV(value uint32) {
	volatile.StoreUint32(&o.RX_DATA_CFG.Reg, volatile.LoadUint32(&o.RX_DATA_CFG.Reg)&^(0x10000000)|value<<28)
}
func (o *PARL_IO_Type) GetRX_DATA_CFG_RX_DATA_ORDER_INV() uint32 {
	return (volatile.LoadUint32(&o.RX_DATA_CFG.Reg) & 0x10000000) >> 28
}
func (o *PARL_IO_Type) SetRX_DATA_CFG_RX_BUS_WID_SEL(value uint32) {
	volatile.StoreUint32(&o.RX_DATA_CFG.Reg, volatile.LoadUint32(&o.RX_DATA_CFG.Reg)&^(0xe0000000)|value<<29)
}
func (o *PARL_IO_Type) GetRX_DATA_CFG_RX_BUS_WID_SEL() uint32 {
	return (volatile.LoadUint32(&o.RX_DATA_CFG.Reg) & 0xe0000000) >> 29
}

// PARL_IO.RX_GENRL_CFG: Parallel RX general configuration register.
func (o *PARL_IO_Type) SetRX_GENRL_CFG_RX_GATING_EN(value uint32) {
	volatile.StoreUint32(&o.RX_GENRL_CFG.Reg, volatile.LoadUint32(&o.RX_GENRL_CFG.Reg)&^(0x1000)|value<<12)
}
func (o *PARL_IO_Type) GetRX_GENRL_CFG_RX_GATING_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_GENRL_CFG.Reg) & 0x1000) >> 12
}
func (o *PARL_IO_Type) SetRX_GENRL_CFG_RX_TIMEOUT_THRES(value uint32) {
	volatile.StoreUint32(&o.RX_GENRL_CFG.Reg, volatile.LoadUint32(&o.RX_GENRL_CFG.Reg)&^(0x1fffe000)|value<<13)
}
func (o *PARL_IO_Type) GetRX_GENRL_CFG_RX_TIMEOUT_THRES() uint32 {
	return (volatile.LoadUint32(&o.RX_GENRL_CFG.Reg) & 0x1fffe000) >> 13
}
func (o *PARL_IO_Type) SetRX_GENRL_CFG_RX_TIMEOUT_EN(value uint32) {
	volatile.StoreUint32(&o.RX_GENRL_CFG.Reg, volatile.LoadUint32(&o.RX_GENRL_CFG.Reg)&^(0x20000000)|value<<29)
}
func (o *PARL_IO_Type) GetRX_GENRL_CFG_RX_TIMEOUT_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_GENRL_CFG.Reg) & 0x20000000) >> 29
}
func (o *PARL_IO_Type) SetRX_GENRL_CFG_RX_EOF_GEN_SEL(value uint32) {
	volatile.StoreUint32(&o.RX_GENRL_CFG.Reg, volatile.LoadUint32(&o.RX_GENRL_CFG.Reg)&^(0x40000000)|value<<30)
}
func (o *PARL_IO_Type) GetRX_GENRL_CFG_RX_EOF_GEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.RX_GENRL_CFG.Reg) & 0x40000000) >> 30
}

// PARL_IO.RX_START_CFG: Parallel RX Start configuration register.
func (o *PARL_IO_Type) SetRX_START_CFG_RX_START(value uint32) {
	volatile.StoreUint32(&o.RX_START_CFG.Reg, volatile.LoadUint32(&o.RX_START_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *PARL_IO_Type) GetRX_START_CFG_RX_START() uint32 {
	return (volatile.LoadUint32(&o.RX_START_CFG.Reg) & 0x80000000) >> 31
}

// PARL_IO.TX_DATA_CFG: Parallel TX data configuration register.
func (o *PARL_IO_Type) SetTX_DATA_CFG_TX_BITLEN(value uint32) {
	volatile.StoreUint32(&o.TX_DATA_CFG.Reg, volatile.LoadUint32(&o.TX_DATA_CFG.Reg)&^(0xffffe00)|value<<9)
}
func (o *PARL_IO_Type) GetTX_DATA_CFG_TX_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.TX_DATA_CFG.Reg) & 0xffffe00) >> 9
}
func (o *PARL_IO_Type) SetTX_DATA_CFG_TX_DATA_ORDER_INV(value uint32) {
	volatile.StoreUint32(&o.TX_DATA_CFG.Reg, volatile.LoadUint32(&o.TX_DATA_CFG.Reg)&^(0x10000000)|value<<28)
}
func (o *PARL_IO_Type) GetTX_DATA_CFG_TX_DATA_ORDER_INV() uint32 {
	return (volatile.LoadUint32(&o.TX_DATA_CFG.Reg) & 0x10000000) >> 28
}
func (o *PARL_IO_Type) SetTX_DATA_CFG_TX_BUS_WID_SEL(value uint32) {
	volatile.StoreUint32(&o.TX_DATA_CFG.Reg, volatile.LoadUint32(&o.TX_DATA_CFG.Reg)&^(0xe0000000)|value<<29)
}
func (o *PARL_IO_Type) GetTX_DATA_CFG_TX_BUS_WID_SEL() uint32 {
	return (volatile.LoadUint32(&o.TX_DATA_CFG.Reg) & 0xe0000000) >> 29
}

// PARL_IO.TX_START_CFG: Parallel TX Start configuration register.
func (o *PARL_IO_Type) SetTX_START_CFG_TX_START(value uint32) {
	volatile.StoreUint32(&o.TX_START_CFG.Reg, volatile.LoadUint32(&o.TX_START_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *PARL_IO_Type) GetTX_START_CFG_TX_START() uint32 {
	return (volatile.LoadUint32(&o.TX_START_CFG.Reg) & 0x80000000) >> 31
}

// PARL_IO.TX_GENRL_CFG: Parallel TX general configuration register.
func (o *PARL_IO_Type) SetTX_GENRL_CFG_TX_IDLE_VALUE(value uint32) {
	volatile.StoreUint32(&o.TX_GENRL_CFG.Reg, volatile.LoadUint32(&o.TX_GENRL_CFG.Reg)&^(0x3fffc000)|value<<14)
}
func (o *PARL_IO_Type) GetTX_GENRL_CFG_TX_IDLE_VALUE() uint32 {
	return (volatile.LoadUint32(&o.TX_GENRL_CFG.Reg) & 0x3fffc000) >> 14
}
func (o *PARL_IO_Type) SetTX_GENRL_CFG_TX_GATING_EN(value uint32) {
	volatile.StoreUint32(&o.TX_GENRL_CFG.Reg, volatile.LoadUint32(&o.TX_GENRL_CFG.Reg)&^(0x40000000)|value<<30)
}
func (o *PARL_IO_Type) GetTX_GENRL_CFG_TX_GATING_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_GENRL_CFG.Reg) & 0x40000000) >> 30
}
func (o *PARL_IO_Type) SetTX_GENRL_CFG_TX_VALID_OUTPUT_EN(value uint32) {
	volatile.StoreUint32(&o.TX_GENRL_CFG.Reg, volatile.LoadUint32(&o.TX_GENRL_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *PARL_IO_Type) GetTX_GENRL_CFG_TX_VALID_OUTPUT_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_GENRL_CFG.Reg) & 0x80000000) >> 31
}

// PARL_IO.FIFO_CFG: Parallel IO FIFO configuration register.
func (o *PARL_IO_Type) SetFIFO_CFG_TX_FIFO_SRST(value uint32) {
	volatile.StoreUint32(&o.FIFO_CFG.Reg, volatile.LoadUint32(&o.FIFO_CFG.Reg)&^(0x40000000)|value<<30)
}
func (o *PARL_IO_Type) GetFIFO_CFG_TX_FIFO_SRST() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CFG.Reg) & 0x40000000) >> 30
}
func (o *PARL_IO_Type) SetFIFO_CFG_RX_FIFO_SRST(value uint32) {
	volatile.StoreUint32(&o.FIFO_CFG.Reg, volatile.LoadUint32(&o.FIFO_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *PARL_IO_Type) GetFIFO_CFG_RX_FIFO_SRST() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CFG.Reg) & 0x80000000) >> 31
}

// PARL_IO.REG_UPDATE: Parallel IO FIFO configuration register.
func (o *PARL_IO_Type) SetREG_UPDATE_RX_REG_UPDATE(value uint32) {
	volatile.StoreUint32(&o.REG_UPDATE.Reg, volatile.LoadUint32(&o.REG_UPDATE.Reg)&^(0x80000000)|value<<31)
}
func (o *PARL_IO_Type) GetREG_UPDATE_RX_REG_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.REG_UPDATE.Reg) & 0x80000000) >> 31
}

// PARL_IO.ST: Parallel IO module status register0.
func (o *PARL_IO_Type) SetST_TX_READY(value uint32) {
	volatile.StoreUint32(&o.ST.Reg, volatile.LoadUint32(&o.ST.Reg)&^(0x80000000)|value<<31)
}
func (o *PARL_IO_Type) GetST_TX_READY() uint32 {
	return (volatile.LoadUint32(&o.ST.Reg) & 0x80000000) >> 31
}

// PARL_IO.INT_ENA: Parallel IO interrupt enable singal configuration register.
func (o *PARL_IO_Type) SetINT_ENA_TX_FIFO_REMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *PARL_IO_Type) GetINT_ENA_TX_FIFO_REMPTY_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *PARL_IO_Type) SetINT_ENA_RX_FIFO_WOVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *PARL_IO_Type) GetINT_ENA_RX_FIFO_WOVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *PARL_IO_Type) SetINT_ENA_TX_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *PARL_IO_Type) GetINT_ENA_TX_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}

// PARL_IO.INT_RAW: Parallel IO interrupt raw singal status register.
func (o *PARL_IO_Type) SetINT_RAW_TX_FIFO_REMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *PARL_IO_Type) GetINT_RAW_TX_FIFO_REMPTY_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *PARL_IO_Type) SetINT_RAW_RX_FIFO_WOVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *PARL_IO_Type) GetINT_RAW_RX_FIFO_WOVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *PARL_IO_Type) SetINT_RAW_TX_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *PARL_IO_Type) GetINT_RAW_TX_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}

// PARL_IO.INT_ST: Parallel IO interrupt singal status register.
func (o *PARL_IO_Type) SetINT_ST_TX_FIFO_REMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *PARL_IO_Type) GetINT_ST_TX_FIFO_REMPTY_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *PARL_IO_Type) SetINT_ST_RX_FIFO_WOVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *PARL_IO_Type) GetINT_ST_RX_FIFO_WOVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *PARL_IO_Type) SetINT_ST_TX_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *PARL_IO_Type) GetINT_ST_TX_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}

// PARL_IO.INT_CLR: Parallel IO interrupt clear singal configuration register.
func (o *PARL_IO_Type) SetINT_CLR_TX_FIFO_REMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *PARL_IO_Type) GetINT_CLR_TX_FIFO_REMPTY_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *PARL_IO_Type) SetINT_CLR_RX_FIFO_WOVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *PARL_IO_Type) GetINT_CLR_RX_FIFO_WOVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *PARL_IO_Type) SetINT_CLR_TX_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *PARL_IO_Type) GetINT_CLR_TX_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}

// PARL_IO.RX_ST0: Parallel IO RX status register0
func (o *PARL_IO_Type) SetRX_ST0_RX_CNT(value uint32) {
	volatile.StoreUint32(&o.RX_ST0.Reg, volatile.LoadUint32(&o.RX_ST0.Reg)&^(0x1e00)|value<<9)
}
func (o *PARL_IO_Type) GetRX_ST0_RX_CNT() uint32 {
	return (volatile.LoadUint32(&o.RX_ST0.Reg) & 0x1e00) >> 9
}
func (o *PARL_IO_Type) SetRX_ST0_RX_FIFO_WR_BIT_CNT(value uint32) {
	volatile.StoreUint32(&o.RX_ST0.Reg, volatile.LoadUint32(&o.RX_ST0.Reg)&^(0xffffe000)|value<<13)
}
func (o *PARL_IO_Type) GetRX_ST0_RX_FIFO_WR_BIT_CNT() uint32 {
	return (volatile.LoadUint32(&o.RX_ST0.Reg) & 0xffffe000) >> 13
}

// PARL_IO.RX_ST1: Parallel IO RX status register1
func (o *PARL_IO_Type) SetRX_ST1_RX_FIFO_RD_BIT_CNT(value uint32) {
	volatile.StoreUint32(&o.RX_ST1.Reg, volatile.LoadUint32(&o.RX_ST1.Reg)&^(0xffffe000)|value<<13)
}
func (o *PARL_IO_Type) GetRX_ST1_RX_FIFO_RD_BIT_CNT() uint32 {
	return (volatile.LoadUint32(&o.RX_ST1.Reg) & 0xffffe000) >> 13
}

// PARL_IO.TX_ST0: Parallel IO TX status register0
func (o *PARL_IO_Type) SetTX_ST0_TX_CNT(value uint32) {
	volatile.StoreUint32(&o.TX_ST0.Reg, volatile.LoadUint32(&o.TX_ST0.Reg)&^(0x1fc0)|value<<6)
}
func (o *PARL_IO_Type) GetTX_ST0_TX_CNT() uint32 {
	return (volatile.LoadUint32(&o.TX_ST0.Reg) & 0x1fc0) >> 6
}
func (o *PARL_IO_Type) SetTX_ST0_TX_FIFO_RD_BIT_CNT(value uint32) {
	volatile.StoreUint32(&o.TX_ST0.Reg, volatile.LoadUint32(&o.TX_ST0.Reg)&^(0xffffe000)|value<<13)
}
func (o *PARL_IO_Type) GetTX_ST0_TX_FIFO_RD_BIT_CNT() uint32 {
	return (volatile.LoadUint32(&o.TX_ST0.Reg) & 0xffffe000) >> 13
}

// PARL_IO.RX_CLK_CFG: Parallel IO RX clk configuration register
func (o *PARL_IO_Type) SetRX_CLK_CFG_RX_CLK_I_INV(value uint32) {
	volatile.StoreUint32(&o.RX_CLK_CFG.Reg, volatile.LoadUint32(&o.RX_CLK_CFG.Reg)&^(0x40000000)|value<<30)
}
func (o *PARL_IO_Type) GetRX_CLK_CFG_RX_CLK_I_INV() uint32 {
	return (volatile.LoadUint32(&o.RX_CLK_CFG.Reg) & 0x40000000) >> 30
}
func (o *PARL_IO_Type) SetRX_CLK_CFG_RX_CLK_O_INV(value uint32) {
	volatile.StoreUint32(&o.RX_CLK_CFG.Reg, volatile.LoadUint32(&o.RX_CLK_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *PARL_IO_Type) GetRX_CLK_CFG_RX_CLK_O_INV() uint32 {
	return (volatile.LoadUint32(&o.RX_CLK_CFG.Reg) & 0x80000000) >> 31
}

// PARL_IO.TX_CLK_CFG: Parallel IO TX clk configuration register
func (o *PARL_IO_Type) SetTX_CLK_CFG_TX_CLK_I_INV(value uint32) {
	volatile.StoreUint32(&o.TX_CLK_CFG.Reg, volatile.LoadUint32(&o.TX_CLK_CFG.Reg)&^(0x40000000)|value<<30)
}
func (o *PARL_IO_Type) GetTX_CLK_CFG_TX_CLK_I_INV() uint32 {
	return (volatile.LoadUint32(&o.TX_CLK_CFG.Reg) & 0x40000000) >> 30
}
func (o *PARL_IO_Type) SetTX_CLK_CFG_TX_CLK_O_INV(value uint32) {
	volatile.StoreUint32(&o.TX_CLK_CFG.Reg, volatile.LoadUint32(&o.TX_CLK_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *PARL_IO_Type) GetTX_CLK_CFG_TX_CLK_O_INV() uint32 {
	return (volatile.LoadUint32(&o.TX_CLK_CFG.Reg) & 0x80000000) >> 31
}

// PARL_IO.CLK: Parallel IO clk configuration register
func (o *PARL_IO_Type) SetCLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x80000000)|value<<31)
}
func (o *PARL_IO_Type) GetCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0x80000000) >> 31
}

// PARL_IO.VERSION: Version register.
func (o *PARL_IO_Type) SetVERSION_DATE(value uint32) {
	volatile.StoreUint32(&o.VERSION.Reg, volatile.LoadUint32(&o.VERSION.Reg)&^(0xfffffff)|value)
}
func (o *PARL_IO_Type) GetVERSION_DATE() uint32 {
	return volatile.LoadUint32(&o.VERSION.Reg) & 0xfffffff
}

// PAU Peripheral
type PAU_Type struct {
	REGDMA_CONF              volatile.Register32 // 0x0
	REGDMA_CLK_CONF          volatile.Register32 // 0x4
	REGDMA_ETM_CTRL          volatile.Register32 // 0x8
	REGDMA_LINK_0_ADDR       volatile.Register32 // 0xC
	REGDMA_LINK_1_ADDR       volatile.Register32 // 0x10
	REGDMA_LINK_2_ADDR       volatile.Register32 // 0x14
	REGDMA_LINK_3_ADDR       volatile.Register32 // 0x18
	REGDMA_LINK_MAC_ADDR     volatile.Register32 // 0x1C
	REGDMA_CURRENT_LINK_ADDR volatile.Register32 // 0x20
	REGDMA_BACKUP_ADDR       volatile.Register32 // 0x24
	REGDMA_MEM_ADDR          volatile.Register32 // 0x28
	REGDMA_BKP_CONF          volatile.Register32 // 0x2C
	RETENTION_LINK_BASE      volatile.Register32 // 0x30
	RETENTION_CFG            volatile.Register32 // 0x34
	INT_ENA                  volatile.Register32 // 0x38
	INT_RAW                  volatile.Register32 // 0x3C
	INT_CLR                  volatile.Register32 // 0x40
	INT_ST                   volatile.Register32 // 0x44
	_                        [948]byte
	DATE                     volatile.Register32 // 0x3FC
}

// PAU.REGDMA_CONF: Peri backup control register
func (o *PAU_Type) SetREGDMA_CONF_FLOW_ERR(value uint32) {
	volatile.StoreUint32(&o.REGDMA_CONF.Reg, volatile.LoadUint32(&o.REGDMA_CONF.Reg)&^(0x7)|value)
}
func (o *PAU_Type) GetREGDMA_CONF_FLOW_ERR() uint32 {
	return volatile.LoadUint32(&o.REGDMA_CONF.Reg) & 0x7
}
func (o *PAU_Type) SetREGDMA_CONF_START(value uint32) {
	volatile.StoreUint32(&o.REGDMA_CONF.Reg, volatile.LoadUint32(&o.REGDMA_CONF.Reg)&^(0x8)|value<<3)
}
func (o *PAU_Type) GetREGDMA_CONF_START() uint32 {
	return (volatile.LoadUint32(&o.REGDMA_CONF.Reg) & 0x8) >> 3
}
func (o *PAU_Type) SetREGDMA_CONF_TO_MEM(value uint32) {
	volatile.StoreUint32(&o.REGDMA_CONF.Reg, volatile.LoadUint32(&o.REGDMA_CONF.Reg)&^(0x10)|value<<4)
}
func (o *PAU_Type) GetREGDMA_CONF_TO_MEM() uint32 {
	return (volatile.LoadUint32(&o.REGDMA_CONF.Reg) & 0x10) >> 4
}
func (o *PAU_Type) SetREGDMA_CONF_LINK_SEL(value uint32) {
	volatile.StoreUint32(&o.REGDMA_CONF.Reg, volatile.LoadUint32(&o.REGDMA_CONF.Reg)&^(0x60)|value<<5)
}
func (o *PAU_Type) GetREGDMA_CONF_LINK_SEL() uint32 {
	return (volatile.LoadUint32(&o.REGDMA_CONF.Reg) & 0x60) >> 5
}
func (o *PAU_Type) SetREGDMA_CONF_START_MAC(value uint32) {
	volatile.StoreUint32(&o.REGDMA_CONF.Reg, volatile.LoadUint32(&o.REGDMA_CONF.Reg)&^(0x80)|value<<7)
}
func (o *PAU_Type) GetREGDMA_CONF_START_MAC() uint32 {
	return (volatile.LoadUint32(&o.REGDMA_CONF.Reg) & 0x80) >> 7
}
func (o *PAU_Type) SetREGDMA_CONF_TO_MEM_MAC(value uint32) {
	volatile.StoreUint32(&o.REGDMA_CONF.Reg, volatile.LoadUint32(&o.REGDMA_CONF.Reg)&^(0x100)|value<<8)
}
func (o *PAU_Type) GetREGDMA_CONF_TO_MEM_MAC() uint32 {
	return (volatile.LoadUint32(&o.REGDMA_CONF.Reg) & 0x100) >> 8
}
func (o *PAU_Type) SetREGDMA_CONF_SEL_MAC(value uint32) {
	volatile.StoreUint32(&o.REGDMA_CONF.Reg, volatile.LoadUint32(&o.REGDMA_CONF.Reg)&^(0x200)|value<<9)
}
func (o *PAU_Type) GetREGDMA_CONF_SEL_MAC() uint32 {
	return (volatile.LoadUint32(&o.REGDMA_CONF.Reg) & 0x200) >> 9
}

// PAU.REGDMA_CLK_CONF: Clock control register
func (o *PAU_Type) SetREGDMA_CLK_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.REGDMA_CLK_CONF.Reg, volatile.LoadUint32(&o.REGDMA_CLK_CONF.Reg)&^(0x1)|value)
}
func (o *PAU_Type) GetREGDMA_CLK_CONF_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.REGDMA_CLK_CONF.Reg) & 0x1
}

// PAU.REGDMA_ETM_CTRL: ETM start ctrl reg
func (o *PAU_Type) SetREGDMA_ETM_CTRL_ETM_START_0(value uint32) {
	volatile.StoreUint32(&o.REGDMA_ETM_CTRL.Reg, volatile.LoadUint32(&o.REGDMA_ETM_CTRL.Reg)&^(0x1)|value)
}
func (o *PAU_Type) GetREGDMA_ETM_CTRL_ETM_START_0() uint32 {
	return volatile.LoadUint32(&o.REGDMA_ETM_CTRL.Reg) & 0x1
}
func (o *PAU_Type) SetREGDMA_ETM_CTRL_ETM_START_1(value uint32) {
	volatile.StoreUint32(&o.REGDMA_ETM_CTRL.Reg, volatile.LoadUint32(&o.REGDMA_ETM_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *PAU_Type) GetREGDMA_ETM_CTRL_ETM_START_1() uint32 {
	return (volatile.LoadUint32(&o.REGDMA_ETM_CTRL.Reg) & 0x2) >> 1
}
func (o *PAU_Type) SetREGDMA_ETM_CTRL_ETM_START_2(value uint32) {
	volatile.StoreUint32(&o.REGDMA_ETM_CTRL.Reg, volatile.LoadUint32(&o.REGDMA_ETM_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *PAU_Type) GetREGDMA_ETM_CTRL_ETM_START_2() uint32 {
	return (volatile.LoadUint32(&o.REGDMA_ETM_CTRL.Reg) & 0x4) >> 2
}
func (o *PAU_Type) SetREGDMA_ETM_CTRL_ETM_START_3(value uint32) {
	volatile.StoreUint32(&o.REGDMA_ETM_CTRL.Reg, volatile.LoadUint32(&o.REGDMA_ETM_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *PAU_Type) GetREGDMA_ETM_CTRL_ETM_START_3() uint32 {
	return (volatile.LoadUint32(&o.REGDMA_ETM_CTRL.Reg) & 0x8) >> 3
}

// PAU.REGDMA_LINK_0_ADDR: link_0_addr
func (o *PAU_Type) SetREGDMA_LINK_0_ADDR(value uint32) {
	volatile.StoreUint32(&o.REGDMA_LINK_0_ADDR.Reg, value)
}
func (o *PAU_Type) GetREGDMA_LINK_0_ADDR() uint32 {
	return volatile.LoadUint32(&o.REGDMA_LINK_0_ADDR.Reg)
}

// PAU.REGDMA_LINK_1_ADDR: Link_1_addr
func (o *PAU_Type) SetREGDMA_LINK_1_ADDR(value uint32) {
	volatile.StoreUint32(&o.REGDMA_LINK_1_ADDR.Reg, value)
}
func (o *PAU_Type) GetREGDMA_LINK_1_ADDR() uint32 {
	return volatile.LoadUint32(&o.REGDMA_LINK_1_ADDR.Reg)
}

// PAU.REGDMA_LINK_2_ADDR: Link_2_addr
func (o *PAU_Type) SetREGDMA_LINK_2_ADDR(value uint32) {
	volatile.StoreUint32(&o.REGDMA_LINK_2_ADDR.Reg, value)
}
func (o *PAU_Type) GetREGDMA_LINK_2_ADDR() uint32 {
	return volatile.LoadUint32(&o.REGDMA_LINK_2_ADDR.Reg)
}

// PAU.REGDMA_LINK_3_ADDR: Link_3_addr
func (o *PAU_Type) SetREGDMA_LINK_3_ADDR(value uint32) {
	volatile.StoreUint32(&o.REGDMA_LINK_3_ADDR.Reg, value)
}
func (o *PAU_Type) GetREGDMA_LINK_3_ADDR() uint32 {
	return volatile.LoadUint32(&o.REGDMA_LINK_3_ADDR.Reg)
}

// PAU.REGDMA_LINK_MAC_ADDR: Link_mac_addr
func (o *PAU_Type) SetREGDMA_LINK_MAC_ADDR(value uint32) {
	volatile.StoreUint32(&o.REGDMA_LINK_MAC_ADDR.Reg, value)
}
func (o *PAU_Type) GetREGDMA_LINK_MAC_ADDR() uint32 {
	return volatile.LoadUint32(&o.REGDMA_LINK_MAC_ADDR.Reg)
}

// PAU.REGDMA_CURRENT_LINK_ADDR: current link addr
func (o *PAU_Type) SetREGDMA_CURRENT_LINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.REGDMA_CURRENT_LINK_ADDR.Reg, value)
}
func (o *PAU_Type) GetREGDMA_CURRENT_LINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.REGDMA_CURRENT_LINK_ADDR.Reg)
}

// PAU.REGDMA_BACKUP_ADDR: Backup addr
func (o *PAU_Type) SetREGDMA_BACKUP_ADDR(value uint32) {
	volatile.StoreUint32(&o.REGDMA_BACKUP_ADDR.Reg, value)
}
func (o *PAU_Type) GetREGDMA_BACKUP_ADDR() uint32 {
	return volatile.LoadUint32(&o.REGDMA_BACKUP_ADDR.Reg)
}

// PAU.REGDMA_MEM_ADDR: mem addr
func (o *PAU_Type) SetREGDMA_MEM_ADDR(value uint32) {
	volatile.StoreUint32(&o.REGDMA_MEM_ADDR.Reg, value)
}
func (o *PAU_Type) GetREGDMA_MEM_ADDR() uint32 {
	return volatile.LoadUint32(&o.REGDMA_MEM_ADDR.Reg)
}

// PAU.REGDMA_BKP_CONF: backup config
func (o *PAU_Type) SetREGDMA_BKP_CONF_READ_INTERVAL(value uint32) {
	volatile.StoreUint32(&o.REGDMA_BKP_CONF.Reg, volatile.LoadUint32(&o.REGDMA_BKP_CONF.Reg)&^(0x7f)|value)
}
func (o *PAU_Type) GetREGDMA_BKP_CONF_READ_INTERVAL() uint32 {
	return volatile.LoadUint32(&o.REGDMA_BKP_CONF.Reg) & 0x7f
}
func (o *PAU_Type) SetREGDMA_BKP_CONF_LINK_TOUT_THRES(value uint32) {
	volatile.StoreUint32(&o.REGDMA_BKP_CONF.Reg, volatile.LoadUint32(&o.REGDMA_BKP_CONF.Reg)&^(0x1ff80)|value<<7)
}
func (o *PAU_Type) GetREGDMA_BKP_CONF_LINK_TOUT_THRES() uint32 {
	return (volatile.LoadUint32(&o.REGDMA_BKP_CONF.Reg) & 0x1ff80) >> 7
}
func (o *PAU_Type) SetREGDMA_BKP_CONF_BURST_LIMIT(value uint32) {
	volatile.StoreUint32(&o.REGDMA_BKP_CONF.Reg, volatile.LoadUint32(&o.REGDMA_BKP_CONF.Reg)&^(0x3e0000)|value<<17)
}
func (o *PAU_Type) GetREGDMA_BKP_CONF_BURST_LIMIT() uint32 {
	return (volatile.LoadUint32(&o.REGDMA_BKP_CONF.Reg) & 0x3e0000) >> 17
}
func (o *PAU_Type) SetREGDMA_BKP_CONF_BACKUP_TOUT_THRES(value uint32) {
	volatile.StoreUint32(&o.REGDMA_BKP_CONF.Reg, volatile.LoadUint32(&o.REGDMA_BKP_CONF.Reg)&^(0xffc00000)|value<<22)
}
func (o *PAU_Type) GetREGDMA_BKP_CONF_BACKUP_TOUT_THRES() uint32 {
	return (volatile.LoadUint32(&o.REGDMA_BKP_CONF.Reg) & 0xffc00000) >> 22
}

// PAU.RETENTION_LINK_BASE: retention dma link base
func (o *PAU_Type) SetRETENTION_LINK_BASE_LINK_BASE_ADDR(value uint32) {
	volatile.StoreUint32(&o.RETENTION_LINK_BASE.Reg, volatile.LoadUint32(&o.RETENTION_LINK_BASE.Reg)&^(0x7ffffff)|value)
}
func (o *PAU_Type) GetRETENTION_LINK_BASE_LINK_BASE_ADDR() uint32 {
	return volatile.LoadUint32(&o.RETENTION_LINK_BASE.Reg) & 0x7ffffff
}

// PAU.RETENTION_CFG: retention_cfg
func (o *PAU_Type) SetRETENTION_CFG(value uint32) {
	volatile.StoreUint32(&o.RETENTION_CFG.Reg, value)
}
func (o *PAU_Type) GetRETENTION_CFG() uint32 {
	return volatile.LoadUint32(&o.RETENTION_CFG.Reg)
}

// PAU.INT_ENA: Read only register for error and done
func (o *PAU_Type) SetINT_ENA_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *PAU_Type) GetINT_ENA_DONE_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *PAU_Type) SetINT_ENA_ERROR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *PAU_Type) GetINT_ENA_ERROR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}

// PAU.INT_RAW: Read only register for error and done
func (o *PAU_Type) SetINT_RAW_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *PAU_Type) GetINT_RAW_DONE_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *PAU_Type) SetINT_RAW_ERROR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *PAU_Type) GetINT_RAW_ERROR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}

// PAU.INT_CLR: Read only register for error and done
func (o *PAU_Type) SetINT_CLR_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *PAU_Type) GetINT_CLR_DONE_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *PAU_Type) SetINT_CLR_ERROR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *PAU_Type) GetINT_CLR_ERROR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}

// PAU.INT_ST: Read only register for error and done
func (o *PAU_Type) SetINT_ST_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *PAU_Type) GetINT_ST_DONE_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *PAU_Type) SetINT_ST_ERROR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *PAU_Type) GetINT_ST_ERROR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}

// PAU.DATE: Date register.
func (o *PAU_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *PAU_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// Pulse Count Controller
type PCNT_Type struct {
	U0_CONF0  volatile.Register32 // 0x0
	U0_CONF1  volatile.Register32 // 0x4
	U0_CONF2  volatile.Register32 // 0x8
	U1_CONF0  volatile.Register32 // 0xC
	U1_CONF1  volatile.Register32 // 0x10
	U1_CONF2  volatile.Register32 // 0x14
	U2_CONF0  volatile.Register32 // 0x18
	U2_CONF1  volatile.Register32 // 0x1C
	U2_CONF2  volatile.Register32 // 0x20
	U3_CONF0  volatile.Register32 // 0x24
	U3_CONF1  volatile.Register32 // 0x28
	U3_CONF2  volatile.Register32 // 0x2C
	U0_CNT    volatile.Register32 // 0x30
	U1_CNT    volatile.Register32 // 0x34
	U2_CNT    volatile.Register32 // 0x38
	U3_CNT    volatile.Register32 // 0x3C
	INT_RAW   volatile.Register32 // 0x40
	INT_ST    volatile.Register32 // 0x44
	INT_ENA   volatile.Register32 // 0x48
	INT_CLR   volatile.Register32 // 0x4C
	U0_STATUS volatile.Register32 // 0x50
	U1_STATUS volatile.Register32 // 0x54
	U2_STATUS volatile.Register32 // 0x58
	U3_STATUS volatile.Register32 // 0x5C
	CTRL      volatile.Register32 // 0x60
	_         [152]byte
	DATE      volatile.Register32 // 0xFC
}

// PCNT.U0_CONF0: Configuration register 0 for unit %s
func (o *PCNT_Type) SetU0_CONF0_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x3ff)|value)
}
func (o *PCNT_Type) GetU0_CONF0_FILTER_THRES() uint32 {
	return volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x3ff
}
func (o *PCNT_Type) SetU0_CONF0_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x400)|value<<10)
}
func (o *PCNT_Type) GetU0_CONF0_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x400) >> 10
}
func (o *PCNT_Type) SetU0_CONF0_THR_ZERO_EN(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x800)|value<<11)
}
func (o *PCNT_Type) GetU0_CONF0_THR_ZERO_EN() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x800) >> 11
}
func (o *PCNT_Type) SetU0_CONF0_THR_H_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *PCNT_Type) GetU0_CONF0_THR_H_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x1000) >> 12
}
func (o *PCNT_Type) SetU0_CONF0_THR_L_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *PCNT_Type) GetU0_CONF0_THR_L_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x2000) >> 13
}
func (o *PCNT_Type) SetU0_CONF0_THR_THRES0_EN(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *PCNT_Type) GetU0_CONF0_THR_THRES0_EN() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x4000) >> 14
}
func (o *PCNT_Type) SetU0_CONF0_THR_THRES1_EN(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *PCNT_Type) GetU0_CONF0_THR_THRES1_EN() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x8000) >> 15
}
func (o *PCNT_Type) SetU0_CONF0_CH0_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x30000)|value<<16)
}
func (o *PCNT_Type) GetU0_CONF0_CH0_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x30000) >> 16
}
func (o *PCNT_Type) SetU0_CONF0_CH0_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0xc0000)|value<<18)
}
func (o *PCNT_Type) GetU0_CONF0_CH0_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0xc0000) >> 18
}
func (o *PCNT_Type) SetU0_CONF0_CH0_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x300000)|value<<20)
}
func (o *PCNT_Type) GetU0_CONF0_CH0_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x300000) >> 20
}
func (o *PCNT_Type) SetU0_CONF0_CH0_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0xc00000)|value<<22)
}
func (o *PCNT_Type) GetU0_CONF0_CH0_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0xc00000) >> 22
}
func (o *PCNT_Type) SetU0_CONF0_CH1_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x3000000)|value<<24)
}
func (o *PCNT_Type) GetU0_CONF0_CH1_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x3000000) >> 24
}
func (o *PCNT_Type) SetU0_CONF0_CH1_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0xc000000)|value<<26)
}
func (o *PCNT_Type) GetU0_CONF0_CH1_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0xc000000) >> 26
}
func (o *PCNT_Type) SetU0_CONF0_CH1_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x30000000)|value<<28)
}
func (o *PCNT_Type) GetU0_CONF0_CH1_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x30000000) >> 28
}
func (o *PCNT_Type) SetU0_CONF0_CH1_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0xc0000000)|value<<30)
}
func (o *PCNT_Type) GetU0_CONF0_CH1_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0xc0000000) >> 30
}

// PCNT.U0_CONF1: Configuration register 1 for unit %s
func (o *PCNT_Type) SetU0_CONF1_CNT_THRES0(value uint32) {
	volatile.StoreUint32(&o.U0_CONF1.Reg, volatile.LoadUint32(&o.U0_CONF1.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU0_CONF1_CNT_THRES0() uint32 {
	return volatile.LoadUint32(&o.U0_CONF1.Reg) & 0xffff
}
func (o *PCNT_Type) SetU0_CONF1_CNT_THRES1(value uint32) {
	volatile.StoreUint32(&o.U0_CONF1.Reg, volatile.LoadUint32(&o.U0_CONF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU0_CONF1_CNT_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF1.Reg) & 0xffff0000) >> 16
}

// PCNT.U0_CONF2: Configuration register 2 for unit %s
func (o *PCNT_Type) SetU0_CONF2_CNT_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U0_CONF2.Reg, volatile.LoadUint32(&o.U0_CONF2.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU0_CONF2_CNT_H_LIM() uint32 {
	return volatile.LoadUint32(&o.U0_CONF2.Reg) & 0xffff
}
func (o *PCNT_Type) SetU0_CONF2_CNT_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U0_CONF2.Reg, volatile.LoadUint32(&o.U0_CONF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU0_CONF2_CNT_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF2.Reg) & 0xffff0000) >> 16
}

// PCNT.U1_CONF0: Configuration register 0 for unit %s
func (o *PCNT_Type) SetU1_CONF0_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x3ff)|value)
}
func (o *PCNT_Type) GetU1_CONF0_FILTER_THRES() uint32 {
	return volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x3ff
}
func (o *PCNT_Type) SetU1_CONF0_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x400)|value<<10)
}
func (o *PCNT_Type) GetU1_CONF0_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x400) >> 10
}
func (o *PCNT_Type) SetU1_CONF0_THR_ZERO_EN(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x800)|value<<11)
}
func (o *PCNT_Type) GetU1_CONF0_THR_ZERO_EN() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x800) >> 11
}
func (o *PCNT_Type) SetU1_CONF0_THR_H_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *PCNT_Type) GetU1_CONF0_THR_H_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x1000) >> 12
}
func (o *PCNT_Type) SetU1_CONF0_THR_L_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *PCNT_Type) GetU1_CONF0_THR_L_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x2000) >> 13
}
func (o *PCNT_Type) SetU1_CONF0_THR_THRES0_EN(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *PCNT_Type) GetU1_CONF0_THR_THRES0_EN() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x4000) >> 14
}
func (o *PCNT_Type) SetU1_CONF0_THR_THRES1_EN(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *PCNT_Type) GetU1_CONF0_THR_THRES1_EN() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x8000) >> 15
}
func (o *PCNT_Type) SetU1_CONF0_CH0_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x30000)|value<<16)
}
func (o *PCNT_Type) GetU1_CONF0_CH0_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x30000) >> 16
}
func (o *PCNT_Type) SetU1_CONF0_CH0_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0xc0000)|value<<18)
}
func (o *PCNT_Type) GetU1_CONF0_CH0_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0xc0000) >> 18
}
func (o *PCNT_Type) SetU1_CONF0_CH0_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x300000)|value<<20)
}
func (o *PCNT_Type) GetU1_CONF0_CH0_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x300000) >> 20
}
func (o *PCNT_Type) SetU1_CONF0_CH0_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0xc00000)|value<<22)
}
func (o *PCNT_Type) GetU1_CONF0_CH0_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0xc00000) >> 22
}
func (o *PCNT_Type) SetU1_CONF0_CH1_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x3000000)|value<<24)
}
func (o *PCNT_Type) GetU1_CONF0_CH1_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x3000000) >> 24
}
func (o *PCNT_Type) SetU1_CONF0_CH1_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0xc000000)|value<<26)
}
func (o *PCNT_Type) GetU1_CONF0_CH1_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0xc000000) >> 26
}
func (o *PCNT_Type) SetU1_CONF0_CH1_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x30000000)|value<<28)
}
func (o *PCNT_Type) GetU1_CONF0_CH1_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x30000000) >> 28
}
func (o *PCNT_Type) SetU1_CONF0_CH1_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0xc0000000)|value<<30)
}
func (o *PCNT_Type) GetU1_CONF0_CH1_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0xc0000000) >> 30
}

// PCNT.U1_CONF1: Configuration register 1 for unit %s
func (o *PCNT_Type) SetU1_CONF1_CNT_THRES0(value uint32) {
	volatile.StoreUint32(&o.U1_CONF1.Reg, volatile.LoadUint32(&o.U1_CONF1.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU1_CONF1_CNT_THRES0() uint32 {
	return volatile.LoadUint32(&o.U1_CONF1.Reg) & 0xffff
}
func (o *PCNT_Type) SetU1_CONF1_CNT_THRES1(value uint32) {
	volatile.StoreUint32(&o.U1_CONF1.Reg, volatile.LoadUint32(&o.U1_CONF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU1_CONF1_CNT_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF1.Reg) & 0xffff0000) >> 16
}

// PCNT.U1_CONF2: Configuration register 2 for unit %s
func (o *PCNT_Type) SetU1_CONF2_CNT_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U1_CONF2.Reg, volatile.LoadUint32(&o.U1_CONF2.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU1_CONF2_CNT_H_LIM() uint32 {
	return volatile.LoadUint32(&o.U1_CONF2.Reg) & 0xffff
}
func (o *PCNT_Type) SetU1_CONF2_CNT_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U1_CONF2.Reg, volatile.LoadUint32(&o.U1_CONF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU1_CONF2_CNT_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF2.Reg) & 0xffff0000) >> 16
}

// PCNT.U2_CONF0: Configuration register 0 for unit %s
func (o *PCNT_Type) SetU2_CONF0_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x3ff)|value)
}
func (o *PCNT_Type) GetU2_CONF0_FILTER_THRES() uint32 {
	return volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x3ff
}
func (o *PCNT_Type) SetU2_CONF0_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x400)|value<<10)
}
func (o *PCNT_Type) GetU2_CONF0_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x400) >> 10
}
func (o *PCNT_Type) SetU2_CONF0_THR_ZERO_EN(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x800)|value<<11)
}
func (o *PCNT_Type) GetU2_CONF0_THR_ZERO_EN() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x800) >> 11
}
func (o *PCNT_Type) SetU2_CONF0_THR_H_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *PCNT_Type) GetU2_CONF0_THR_H_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x1000) >> 12
}
func (o *PCNT_Type) SetU2_CONF0_THR_L_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *PCNT_Type) GetU2_CONF0_THR_L_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x2000) >> 13
}
func (o *PCNT_Type) SetU2_CONF0_THR_THRES0_EN(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *PCNT_Type) GetU2_CONF0_THR_THRES0_EN() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x4000) >> 14
}
func (o *PCNT_Type) SetU2_CONF0_THR_THRES1_EN(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *PCNT_Type) GetU2_CONF0_THR_THRES1_EN() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x8000) >> 15
}
func (o *PCNT_Type) SetU2_CONF0_CH0_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x30000)|value<<16)
}
func (o *PCNT_Type) GetU2_CONF0_CH0_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x30000) >> 16
}
func (o *PCNT_Type) SetU2_CONF0_CH0_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0xc0000)|value<<18)
}
func (o *PCNT_Type) GetU2_CONF0_CH0_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0xc0000) >> 18
}
func (o *PCNT_Type) SetU2_CONF0_CH0_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x300000)|value<<20)
}
func (o *PCNT_Type) GetU2_CONF0_CH0_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x300000) >> 20
}
func (o *PCNT_Type) SetU2_CONF0_CH0_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0xc00000)|value<<22)
}
func (o *PCNT_Type) GetU2_CONF0_CH0_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0xc00000) >> 22
}
func (o *PCNT_Type) SetU2_CONF0_CH1_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x3000000)|value<<24)
}
func (o *PCNT_Type) GetU2_CONF0_CH1_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x3000000) >> 24
}
func (o *PCNT_Type) SetU2_CONF0_CH1_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0xc000000)|value<<26)
}
func (o *PCNT_Type) GetU2_CONF0_CH1_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0xc000000) >> 26
}
func (o *PCNT_Type) SetU2_CONF0_CH1_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x30000000)|value<<28)
}
func (o *PCNT_Type) GetU2_CONF0_CH1_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x30000000) >> 28
}
func (o *PCNT_Type) SetU2_CONF0_CH1_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0xc0000000)|value<<30)
}
func (o *PCNT_Type) GetU2_CONF0_CH1_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0xc0000000) >> 30
}

// PCNT.U2_CONF1: Configuration register 1 for unit %s
func (o *PCNT_Type) SetU2_CONF1_CNT_THRES0(value uint32) {
	volatile.StoreUint32(&o.U2_CONF1.Reg, volatile.LoadUint32(&o.U2_CONF1.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU2_CONF1_CNT_THRES0() uint32 {
	return volatile.LoadUint32(&o.U2_CONF1.Reg) & 0xffff
}
func (o *PCNT_Type) SetU2_CONF1_CNT_THRES1(value uint32) {
	volatile.StoreUint32(&o.U2_CONF1.Reg, volatile.LoadUint32(&o.U2_CONF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU2_CONF1_CNT_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF1.Reg) & 0xffff0000) >> 16
}

// PCNT.U2_CONF2: Configuration register 2 for unit %s
func (o *PCNT_Type) SetU2_CONF2_CNT_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U2_CONF2.Reg, volatile.LoadUint32(&o.U2_CONF2.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU2_CONF2_CNT_H_LIM() uint32 {
	return volatile.LoadUint32(&o.U2_CONF2.Reg) & 0xffff
}
func (o *PCNT_Type) SetU2_CONF2_CNT_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U2_CONF2.Reg, volatile.LoadUint32(&o.U2_CONF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU2_CONF2_CNT_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF2.Reg) & 0xffff0000) >> 16
}

// PCNT.U3_CONF0: Configuration register 0 for unit %s
func (o *PCNT_Type) SetU3_CONF0_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x3ff)|value)
}
func (o *PCNT_Type) GetU3_CONF0_FILTER_THRES() uint32 {
	return volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x3ff
}
func (o *PCNT_Type) SetU3_CONF0_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x400)|value<<10)
}
func (o *PCNT_Type) GetU3_CONF0_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x400) >> 10
}
func (o *PCNT_Type) SetU3_CONF0_THR_ZERO_EN(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x800)|value<<11)
}
func (o *PCNT_Type) GetU3_CONF0_THR_ZERO_EN() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x800) >> 11
}
func (o *PCNT_Type) SetU3_CONF0_THR_H_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *PCNT_Type) GetU3_CONF0_THR_H_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x1000) >> 12
}
func (o *PCNT_Type) SetU3_CONF0_THR_L_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *PCNT_Type) GetU3_CONF0_THR_L_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x2000) >> 13
}
func (o *PCNT_Type) SetU3_CONF0_THR_THRES0_EN(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *PCNT_Type) GetU3_CONF0_THR_THRES0_EN() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x4000) >> 14
}
func (o *PCNT_Type) SetU3_CONF0_THR_THRES1_EN(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *PCNT_Type) GetU3_CONF0_THR_THRES1_EN() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x8000) >> 15
}
func (o *PCNT_Type) SetU3_CONF0_CH0_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x30000)|value<<16)
}
func (o *PCNT_Type) GetU3_CONF0_CH0_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x30000) >> 16
}
func (o *PCNT_Type) SetU3_CONF0_CH0_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0xc0000)|value<<18)
}
func (o *PCNT_Type) GetU3_CONF0_CH0_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0xc0000) >> 18
}
func (o *PCNT_Type) SetU3_CONF0_CH0_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x300000)|value<<20)
}
func (o *PCNT_Type) GetU3_CONF0_CH0_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x300000) >> 20
}
func (o *PCNT_Type) SetU3_CONF0_CH0_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0xc00000)|value<<22)
}
func (o *PCNT_Type) GetU3_CONF0_CH0_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0xc00000) >> 22
}
func (o *PCNT_Type) SetU3_CONF0_CH1_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x3000000)|value<<24)
}
func (o *PCNT_Type) GetU3_CONF0_CH1_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x3000000) >> 24
}
func (o *PCNT_Type) SetU3_CONF0_CH1_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0xc000000)|value<<26)
}
func (o *PCNT_Type) GetU3_CONF0_CH1_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0xc000000) >> 26
}
func (o *PCNT_Type) SetU3_CONF0_CH1_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x30000000)|value<<28)
}
func (o *PCNT_Type) GetU3_CONF0_CH1_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x30000000) >> 28
}
func (o *PCNT_Type) SetU3_CONF0_CH1_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0xc0000000)|value<<30)
}
func (o *PCNT_Type) GetU3_CONF0_CH1_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0xc0000000) >> 30
}

// PCNT.U3_CONF1: Configuration register 1 for unit %s
func (o *PCNT_Type) SetU3_CONF1_CNT_THRES0(value uint32) {
	volatile.StoreUint32(&o.U3_CONF1.Reg, volatile.LoadUint32(&o.U3_CONF1.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU3_CONF1_CNT_THRES0() uint32 {
	return volatile.LoadUint32(&o.U3_CONF1.Reg) & 0xffff
}
func (o *PCNT_Type) SetU3_CONF1_CNT_THRES1(value uint32) {
	volatile.StoreUint32(&o.U3_CONF1.Reg, volatile.LoadUint32(&o.U3_CONF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU3_CONF1_CNT_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF1.Reg) & 0xffff0000) >> 16
}

// PCNT.U3_CONF2: Configuration register 2 for unit %s
func (o *PCNT_Type) SetU3_CONF2_CNT_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U3_CONF2.Reg, volatile.LoadUint32(&o.U3_CONF2.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU3_CONF2_CNT_H_LIM() uint32 {
	return volatile.LoadUint32(&o.U3_CONF2.Reg) & 0xffff
}
func (o *PCNT_Type) SetU3_CONF2_CNT_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U3_CONF2.Reg, volatile.LoadUint32(&o.U3_CONF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU3_CONF2_CNT_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF2.Reg) & 0xffff0000) >> 16
}

// PCNT.U0_CNT: Counter value for unit %s
func (o *PCNT_Type) SetU0_CNT_CNT(value uint32) {
	volatile.StoreUint32(&o.U0_CNT.Reg, volatile.LoadUint32(&o.U0_CNT.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU0_CNT_CNT() uint32 {
	return volatile.LoadUint32(&o.U0_CNT.Reg) & 0xffff
}

// PCNT.U1_CNT: Counter value for unit %s
func (o *PCNT_Type) SetU1_CNT_CNT(value uint32) {
	volatile.StoreUint32(&o.U1_CNT.Reg, volatile.LoadUint32(&o.U1_CNT.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU1_CNT_CNT() uint32 {
	return volatile.LoadUint32(&o.U1_CNT.Reg) & 0xffff
}

// PCNT.U2_CNT: Counter value for unit %s
func (o *PCNT_Type) SetU2_CNT_CNT(value uint32) {
	volatile.StoreUint32(&o.U2_CNT.Reg, volatile.LoadUint32(&o.U2_CNT.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU2_CNT_CNT() uint32 {
	return volatile.LoadUint32(&o.U2_CNT.Reg) & 0xffff
}

// PCNT.U3_CNT: Counter value for unit %s
func (o *PCNT_Type) SetU3_CNT_CNT(value uint32) {
	volatile.StoreUint32(&o.U3_CNT.Reg, volatile.LoadUint32(&o.U3_CNT.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU3_CNT_CNT() uint32 {
	return volatile.LoadUint32(&o.U3_CNT.Reg) & 0xffff
}

// PCNT.INT_RAW: Interrupt raw status register
func (o *PCNT_Type) SetINT_RAW_CNT_THR_EVENT_U0(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetINT_RAW_CNT_THR_EVENT_U0() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *PCNT_Type) SetINT_RAW_CNT_THR_EVENT_U1(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetINT_RAW_CNT_THR_EVENT_U1() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetINT_RAW_CNT_THR_EVENT_U2(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetINT_RAW_CNT_THR_EVENT_U2() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetINT_RAW_CNT_THR_EVENT_U3(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetINT_RAW_CNT_THR_EVENT_U3() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}

// PCNT.INT_ST: Interrupt status register
func (o *PCNT_Type) SetINT_ST_CNT_THR_EVENT_U0(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetINT_ST_CNT_THR_EVENT_U0() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *PCNT_Type) SetINT_ST_CNT_THR_EVENT_U1(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetINT_ST_CNT_THR_EVENT_U1() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetINT_ST_CNT_THR_EVENT_U2(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetINT_ST_CNT_THR_EVENT_U2() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetINT_ST_CNT_THR_EVENT_U3(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetINT_ST_CNT_THR_EVENT_U3() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}

// PCNT.INT_ENA: Interrupt enable register
func (o *PCNT_Type) SetINT_ENA_CNT_THR_EVENT_U0(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetINT_ENA_CNT_THR_EVENT_U0() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *PCNT_Type) SetINT_ENA_CNT_THR_EVENT_U1(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetINT_ENA_CNT_THR_EVENT_U1() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetINT_ENA_CNT_THR_EVENT_U2(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetINT_ENA_CNT_THR_EVENT_U2() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetINT_ENA_CNT_THR_EVENT_U3(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetINT_ENA_CNT_THR_EVENT_U3() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}

// PCNT.INT_CLR: Interrupt clear register
func (o *PCNT_Type) SetINT_CLR_CNT_THR_EVENT_U0(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetINT_CLR_CNT_THR_EVENT_U0() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *PCNT_Type) SetINT_CLR_CNT_THR_EVENT_U1(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetINT_CLR_CNT_THR_EVENT_U1() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetINT_CLR_CNT_THR_EVENT_U2(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetINT_CLR_CNT_THR_EVENT_U2() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetINT_CLR_CNT_THR_EVENT_U3(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetINT_CLR_CNT_THR_EVENT_U3() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}

// PCNT.U0_STATUS: PNCT UNIT%s status register
func (o *PCNT_Type) SetU0_STATUS_ZERO_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x3)|value)
}
func (o *PCNT_Type) GetU0_STATUS_ZERO_MODE() uint32 {
	return volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x3
}
func (o *PCNT_Type) SetU0_STATUS_THRES1(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetU0_STATUS_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetU0_STATUS_THRES0(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetU0_STATUS_THRES0() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetU0_STATUS_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetU0_STATUS_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetU0_STATUS_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetU0_STATUS_H_LIM() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetU0_STATUS_ZERO(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetU0_STATUS_ZERO() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x40) >> 6
}

// PCNT.U1_STATUS: PNCT UNIT%s status register
func (o *PCNT_Type) SetU1_STATUS_ZERO_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x3)|value)
}
func (o *PCNT_Type) GetU1_STATUS_ZERO_MODE() uint32 {
	return volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x3
}
func (o *PCNT_Type) SetU1_STATUS_THRES1(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetU1_STATUS_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetU1_STATUS_THRES0(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetU1_STATUS_THRES0() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetU1_STATUS_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetU1_STATUS_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetU1_STATUS_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetU1_STATUS_H_LIM() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetU1_STATUS_ZERO(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetU1_STATUS_ZERO() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x40) >> 6
}

// PCNT.U2_STATUS: PNCT UNIT%s status register
func (o *PCNT_Type) SetU2_STATUS_ZERO_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x3)|value)
}
func (o *PCNT_Type) GetU2_STATUS_ZERO_MODE() uint32 {
	return volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x3
}
func (o *PCNT_Type) SetU2_STATUS_THRES1(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetU2_STATUS_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetU2_STATUS_THRES0(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetU2_STATUS_THRES0() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetU2_STATUS_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetU2_STATUS_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetU2_STATUS_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetU2_STATUS_H_LIM() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetU2_STATUS_ZERO(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetU2_STATUS_ZERO() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x40) >> 6
}

// PCNT.U3_STATUS: PNCT UNIT%s status register
func (o *PCNT_Type) SetU3_STATUS_ZERO_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x3)|value)
}
func (o *PCNT_Type) GetU3_STATUS_ZERO_MODE() uint32 {
	return volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x3
}
func (o *PCNT_Type) SetU3_STATUS_THRES1(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetU3_STATUS_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetU3_STATUS_THRES0(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetU3_STATUS_THRES0() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetU3_STATUS_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetU3_STATUS_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetU3_STATUS_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetU3_STATUS_H_LIM() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetU3_STATUS_ZERO(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetU3_STATUS_ZERO() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x40) >> 6
}

// PCNT.CTRL: Control register for all counters
func (o *PCNT_Type) SetCTRL_CNT_RST_U0(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetCTRL_CNT_RST_U0() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *PCNT_Type) SetCTRL_CNT_PAUSE_U0(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetCTRL_CNT_PAUSE_U0() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetCTRL_CNT_RST_U1(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetCTRL_CNT_RST_U1() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetCTRL_CNT_PAUSE_U1(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetCTRL_CNT_PAUSE_U1() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetCTRL_CNT_RST_U2(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetCTRL_CNT_RST_U2() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetCTRL_CNT_PAUSE_U2(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetCTRL_CNT_PAUSE_U2() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetCTRL_CNT_RST_U3(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetCTRL_CNT_RST_U3() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *PCNT_Type) SetCTRL_CNT_PAUSE_U3(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *PCNT_Type) GetCTRL_CNT_PAUSE_U3() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *PCNT_Type) SetCTRL_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *PCNT_Type) GetCTRL_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}

// PCNT.DATE: PCNT version control register
func (o *PCNT_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *PCNT_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// PCR Peripheral
type PCR_Type struct {
	UART0_CONF                 volatile.Register32 // 0x0
	UART0_SCLK_CONF            volatile.Register32 // 0x4
	UART0_PD_CTRL              volatile.Register32 // 0x8
	UART1_CONF                 volatile.Register32 // 0xC
	UART1_SCLK_CONF            volatile.Register32 // 0x10
	UART1_PD_CTRL              volatile.Register32 // 0x14
	MSPI_CONF                  volatile.Register32 // 0x18
	MSPI_CLK_CONF              volatile.Register32 // 0x1C
	I2C0_CONF                  volatile.Register32 // 0x20
	I2C0_SCLK_CONF             volatile.Register32 // 0x24
	I2C1_CONF                  volatile.Register32 // 0x28
	I2C1_SCLK_CONF             volatile.Register32 // 0x2C
	UHCI_CONF                  volatile.Register32 // 0x30
	RMT_CONF                   volatile.Register32 // 0x34
	RMT_SCLK_CONF              volatile.Register32 // 0x38
	LEDC_CONF                  volatile.Register32 // 0x3C
	LEDC_SCLK_CONF             volatile.Register32 // 0x40
	TIMERGROUP0_CONF           volatile.Register32 // 0x44
	TIMERGROUP0_TIMER_CLK_CONF volatile.Register32 // 0x48
	TIMERGROUP0_WDT_CLK_CONF   volatile.Register32 // 0x4C
	TIMERGROUP1_CONF           volatile.Register32 // 0x50
	TIMERGROUP1_TIMER_CLK_CONF volatile.Register32 // 0x54
	TIMERGROUP1_WDT_CLK_CONF   volatile.Register32 // 0x58
	SYSTIMER_CONF              volatile.Register32 // 0x5C
	SYSTIMER_FUNC_CLK_CONF     volatile.Register32 // 0x60
	TWAI0_CONF                 volatile.Register32 // 0x64
	TWAI0_FUNC_CLK_CONF        volatile.Register32 // 0x68
	I2S_CONF                   volatile.Register32 // 0x6C
	I2S_TX_CLKM_CONF           volatile.Register32 // 0x70
	I2S_TX_CLKM_DIV_CONF       volatile.Register32 // 0x74
	I2S_RX_CLKM_CONF           volatile.Register32 // 0x78
	I2S_RX_CLKM_DIV_CONF       volatile.Register32 // 0x7C
	SARADC_CONF                volatile.Register32 // 0x80
	SARADC_CLKM_CONF           volatile.Register32 // 0x84
	TSENS_CLK_CONF             volatile.Register32 // 0x88
	USB_DEVICE_CONF            volatile.Register32 // 0x8C
	INTMTX_CONF                volatile.Register32 // 0x90
	PCNT_CONF                  volatile.Register32 // 0x94
	ETM_CONF                   volatile.Register32 // 0x98
	PWM_CONF                   volatile.Register32 // 0x9C
	PWM_CLK_CONF               volatile.Register32 // 0xA0
	PARL_IO_CONF               volatile.Register32 // 0xA4
	PARL_CLK_RX_CONF           volatile.Register32 // 0xA8
	PARL_CLK_TX_CONF           volatile.Register32 // 0xAC
	PVT_MONITOR_CONF           volatile.Register32 // 0xB0
	PVT_MONITOR_FUNC_CLK_CONF  volatile.Register32 // 0xB4
	GDMA_CONF                  volatile.Register32 // 0xB8
	SPI2_CONF                  volatile.Register32 // 0xBC
	SPI2_CLKM_CONF             volatile.Register32 // 0xC0
	AES_CONF                   volatile.Register32 // 0xC4
	SHA_CONF                   volatile.Register32 // 0xC8
	RSA_CONF                   volatile.Register32 // 0xCC
	RSA_PD_CTRL                volatile.Register32 // 0xD0
	ECC_CONF                   volatile.Register32 // 0xD4
	ECC_PD_CTRL                volatile.Register32 // 0xD8
	DS_CONF                    volatile.Register32 // 0xDC
	HMAC_CONF                  volatile.Register32 // 0xE0
	ECDSA_CONF                 volatile.Register32 // 0xE4
	IOMUX_CONF                 volatile.Register32 // 0xE8
	IOMUX_CLK_CONF             volatile.Register32 // 0xEC
	MEM_MONITOR_CONF           volatile.Register32 // 0xF0
	REGDMA_CONF                volatile.Register32 // 0xF4
	TRACE_CONF                 volatile.Register32 // 0xF8
	ASSIST_CONF                volatile.Register32 // 0xFC
	CACHE_CONF                 volatile.Register32 // 0x100
	MODEM_CONF                 volatile.Register32 // 0x104
	TIMEOUT_CONF               volatile.Register32 // 0x108
	SYSCLK_CONF                volatile.Register32 // 0x10C
	CPU_WAITI_CONF             volatile.Register32 // 0x110
	CPU_FREQ_CONF              volatile.Register32 // 0x114
	AHB_FREQ_CONF              volatile.Register32 // 0x118
	APB_FREQ_CONF              volatile.Register32 // 0x11C
	SYSCLK_FREQ_QUERY_0        volatile.Register32 // 0x120
	PLL_DIV_CLK_EN             volatile.Register32 // 0x124
	CTRL_CLK_OUT_EN            volatile.Register32 // 0x128
	CTRL_TICK_CONF             volatile.Register32 // 0x12C
	CTRL_32K_CONF              volatile.Register32 // 0x130
	SRAM_POWER_CONF_0          volatile.Register32 // 0x134
	SRAM_POWER_CONF_1          volatile.Register32 // 0x138
	SEC_CONF                   volatile.Register32 // 0x13C
	ADC_INV_PHASE_CONF         volatile.Register32 // 0x140
	SDM_INV_PHASE_CONF         volatile.Register32 // 0x144
	BUS_CLK_UPDATE             volatile.Register32 // 0x148
	SAR_CLK_DIV                volatile.Register32 // 0x14C
	PWDET_SAR_CLK_CONF         volatile.Register32 // 0x150
	_                          [3740]byte
	RESET_EVENT_BYPASS         volatile.Register32 // 0xFF0
	FPGA_DEBUG                 volatile.Register32 // 0xFF4
	CLOCK_GATE                 volatile.Register32 // 0xFF8
	DATE                       volatile.Register32 // 0xFFC
}

// PCR.UART0_CONF: UART0 configuration register
func (o *PCR_Type) SetUART0_CONF_UART0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.UART0_CONF.Reg, volatile.LoadUint32(&o.UART0_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetUART0_CONF_UART0_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.UART0_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetUART0_CONF_UART0_RST_EN(value uint32) {
	volatile.StoreUint32(&o.UART0_CONF.Reg, volatile.LoadUint32(&o.UART0_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetUART0_CONF_UART0_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.UART0_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetUART0_CONF_UART0_READY(value uint32) {
	volatile.StoreUint32(&o.UART0_CONF.Reg, volatile.LoadUint32(&o.UART0_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetUART0_CONF_UART0_READY() uint32 {
	return (volatile.LoadUint32(&o.UART0_CONF.Reg) & 0x4) >> 2
}

// PCR.UART0_SCLK_CONF: UART0_SCLK configuration register
func (o *PCR_Type) SetUART0_SCLK_CONF_UART0_SCLK_DIV_A(value uint32) {
	volatile.StoreUint32(&o.UART0_SCLK_CONF.Reg, volatile.LoadUint32(&o.UART0_SCLK_CONF.Reg)&^(0x3f)|value)
}
func (o *PCR_Type) GetUART0_SCLK_CONF_UART0_SCLK_DIV_A() uint32 {
	return volatile.LoadUint32(&o.UART0_SCLK_CONF.Reg) & 0x3f
}
func (o *PCR_Type) SetUART0_SCLK_CONF_UART0_SCLK_DIV_B(value uint32) {
	volatile.StoreUint32(&o.UART0_SCLK_CONF.Reg, volatile.LoadUint32(&o.UART0_SCLK_CONF.Reg)&^(0xfc0)|value<<6)
}
func (o *PCR_Type) GetUART0_SCLK_CONF_UART0_SCLK_DIV_B() uint32 {
	return (volatile.LoadUint32(&o.UART0_SCLK_CONF.Reg) & 0xfc0) >> 6
}
func (o *PCR_Type) SetUART0_SCLK_CONF_UART0_SCLK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.UART0_SCLK_CONF.Reg, volatile.LoadUint32(&o.UART0_SCLK_CONF.Reg)&^(0xff000)|value<<12)
}
func (o *PCR_Type) GetUART0_SCLK_CONF_UART0_SCLK_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.UART0_SCLK_CONF.Reg) & 0xff000) >> 12
}
func (o *PCR_Type) SetUART0_SCLK_CONF_UART0_SCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.UART0_SCLK_CONF.Reg, volatile.LoadUint32(&o.UART0_SCLK_CONF.Reg)&^(0x300000)|value<<20)
}
func (o *PCR_Type) GetUART0_SCLK_CONF_UART0_SCLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.UART0_SCLK_CONF.Reg) & 0x300000) >> 20
}
func (o *PCR_Type) SetUART0_SCLK_CONF_UART0_SCLK_EN(value uint32) {
	volatile.StoreUint32(&o.UART0_SCLK_CONF.Reg, volatile.LoadUint32(&o.UART0_SCLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetUART0_SCLK_CONF_UART0_SCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.UART0_SCLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.UART0_PD_CTRL: UART0 power control register
func (o *PCR_Type) SetUART0_PD_CTRL_UART0_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.UART0_PD_CTRL.Reg, volatile.LoadUint32(&o.UART0_PD_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetUART0_PD_CTRL_UART0_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.UART0_PD_CTRL.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetUART0_PD_CTRL_UART0_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.UART0_PD_CTRL.Reg, volatile.LoadUint32(&o.UART0_PD_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetUART0_PD_CTRL_UART0_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.UART0_PD_CTRL.Reg) & 0x4) >> 2
}

// PCR.UART1_CONF: UART1 configuration register
func (o *PCR_Type) SetUART1_CONF_UART1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.UART1_CONF.Reg, volatile.LoadUint32(&o.UART1_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetUART1_CONF_UART1_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.UART1_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetUART1_CONF_UART1_RST_EN(value uint32) {
	volatile.StoreUint32(&o.UART1_CONF.Reg, volatile.LoadUint32(&o.UART1_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetUART1_CONF_UART1_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.UART1_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetUART1_CONF_UART1_READY(value uint32) {
	volatile.StoreUint32(&o.UART1_CONF.Reg, volatile.LoadUint32(&o.UART1_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetUART1_CONF_UART1_READY() uint32 {
	return (volatile.LoadUint32(&o.UART1_CONF.Reg) & 0x4) >> 2
}

// PCR.UART1_SCLK_CONF: UART1_SCLK configuration register
func (o *PCR_Type) SetUART1_SCLK_CONF_UART1_SCLK_DIV_A(value uint32) {
	volatile.StoreUint32(&o.UART1_SCLK_CONF.Reg, volatile.LoadUint32(&o.UART1_SCLK_CONF.Reg)&^(0x3f)|value)
}
func (o *PCR_Type) GetUART1_SCLK_CONF_UART1_SCLK_DIV_A() uint32 {
	return volatile.LoadUint32(&o.UART1_SCLK_CONF.Reg) & 0x3f
}
func (o *PCR_Type) SetUART1_SCLK_CONF_UART1_SCLK_DIV_B(value uint32) {
	volatile.StoreUint32(&o.UART1_SCLK_CONF.Reg, volatile.LoadUint32(&o.UART1_SCLK_CONF.Reg)&^(0xfc0)|value<<6)
}
func (o *PCR_Type) GetUART1_SCLK_CONF_UART1_SCLK_DIV_B() uint32 {
	return (volatile.LoadUint32(&o.UART1_SCLK_CONF.Reg) & 0xfc0) >> 6
}
func (o *PCR_Type) SetUART1_SCLK_CONF_UART1_SCLK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.UART1_SCLK_CONF.Reg, volatile.LoadUint32(&o.UART1_SCLK_CONF.Reg)&^(0xff000)|value<<12)
}
func (o *PCR_Type) GetUART1_SCLK_CONF_UART1_SCLK_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.UART1_SCLK_CONF.Reg) & 0xff000) >> 12
}
func (o *PCR_Type) SetUART1_SCLK_CONF_UART1_SCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.UART1_SCLK_CONF.Reg, volatile.LoadUint32(&o.UART1_SCLK_CONF.Reg)&^(0x300000)|value<<20)
}
func (o *PCR_Type) GetUART1_SCLK_CONF_UART1_SCLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.UART1_SCLK_CONF.Reg) & 0x300000) >> 20
}
func (o *PCR_Type) SetUART1_SCLK_CONF_UART1_SCLK_EN(value uint32) {
	volatile.StoreUint32(&o.UART1_SCLK_CONF.Reg, volatile.LoadUint32(&o.UART1_SCLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetUART1_SCLK_CONF_UART1_SCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.UART1_SCLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.UART1_PD_CTRL: UART1 power control register
func (o *PCR_Type) SetUART1_PD_CTRL_UART1_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.UART1_PD_CTRL.Reg, volatile.LoadUint32(&o.UART1_PD_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetUART1_PD_CTRL_UART1_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.UART1_PD_CTRL.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetUART1_PD_CTRL_UART1_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.UART1_PD_CTRL.Reg, volatile.LoadUint32(&o.UART1_PD_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetUART1_PD_CTRL_UART1_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.UART1_PD_CTRL.Reg) & 0x4) >> 2
}

// PCR.MSPI_CONF: MSPI configuration register
func (o *PCR_Type) SetMSPI_CONF_MSPI_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.MSPI_CONF.Reg, volatile.LoadUint32(&o.MSPI_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetMSPI_CONF_MSPI_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.MSPI_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetMSPI_CONF_MSPI_RST_EN(value uint32) {
	volatile.StoreUint32(&o.MSPI_CONF.Reg, volatile.LoadUint32(&o.MSPI_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetMSPI_CONF_MSPI_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.MSPI_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetMSPI_CONF_MSPI_PLL_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.MSPI_CONF.Reg, volatile.LoadUint32(&o.MSPI_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetMSPI_CONF_MSPI_PLL_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.MSPI_CONF.Reg) & 0x4) >> 2
}
func (o *PCR_Type) SetMSPI_CONF_MSPI_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.MSPI_CONF.Reg, volatile.LoadUint32(&o.MSPI_CONF.Reg)&^(0x18)|value<<3)
}
func (o *PCR_Type) GetMSPI_CONF_MSPI_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.MSPI_CONF.Reg) & 0x18) >> 3
}
func (o *PCR_Type) SetMSPI_CONF_MSPI_READY(value uint32) {
	volatile.StoreUint32(&o.MSPI_CONF.Reg, volatile.LoadUint32(&o.MSPI_CONF.Reg)&^(0x20)|value<<5)
}
func (o *PCR_Type) GetMSPI_CONF_MSPI_READY() uint32 {
	return (volatile.LoadUint32(&o.MSPI_CONF.Reg) & 0x20) >> 5
}

// PCR.MSPI_CLK_CONF: MSPI_CLK configuration register
func (o *PCR_Type) SetMSPI_CLK_CONF_MSPI_FAST_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.MSPI_CLK_CONF.Reg, volatile.LoadUint32(&o.MSPI_CLK_CONF.Reg)&^(0xff)|value)
}
func (o *PCR_Type) GetMSPI_CLK_CONF_MSPI_FAST_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.MSPI_CLK_CONF.Reg) & 0xff
}

// PCR.I2C0_CONF: I2C configuration register
func (o *PCR_Type) SetI2C0_CONF_I2C0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.I2C0_CONF.Reg, volatile.LoadUint32(&o.I2C0_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetI2C0_CONF_I2C0_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.I2C0_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetI2C0_CONF_I2C0_RST_EN(value uint32) {
	volatile.StoreUint32(&o.I2C0_CONF.Reg, volatile.LoadUint32(&o.I2C0_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetI2C0_CONF_I2C0_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.I2C0_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetI2C0_CONF_I2C0_READY(value uint32) {
	volatile.StoreUint32(&o.I2C0_CONF.Reg, volatile.LoadUint32(&o.I2C0_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetI2C0_CONF_I2C0_READY() uint32 {
	return (volatile.LoadUint32(&o.I2C0_CONF.Reg) & 0x4) >> 2
}

// PCR.I2C0_SCLK_CONF: I2C_SCLK configuration register
func (o *PCR_Type) SetI2C0_SCLK_CONF_I2C0_SCLK_DIV_A(value uint32) {
	volatile.StoreUint32(&o.I2C0_SCLK_CONF.Reg, volatile.LoadUint32(&o.I2C0_SCLK_CONF.Reg)&^(0x3f)|value)
}
func (o *PCR_Type) GetI2C0_SCLK_CONF_I2C0_SCLK_DIV_A() uint32 {
	return volatile.LoadUint32(&o.I2C0_SCLK_CONF.Reg) & 0x3f
}
func (o *PCR_Type) SetI2C0_SCLK_CONF_I2C0_SCLK_DIV_B(value uint32) {
	volatile.StoreUint32(&o.I2C0_SCLK_CONF.Reg, volatile.LoadUint32(&o.I2C0_SCLK_CONF.Reg)&^(0xfc0)|value<<6)
}
func (o *PCR_Type) GetI2C0_SCLK_CONF_I2C0_SCLK_DIV_B() uint32 {
	return (volatile.LoadUint32(&o.I2C0_SCLK_CONF.Reg) & 0xfc0) >> 6
}
func (o *PCR_Type) SetI2C0_SCLK_CONF_I2C0_SCLK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.I2C0_SCLK_CONF.Reg, volatile.LoadUint32(&o.I2C0_SCLK_CONF.Reg)&^(0xff000)|value<<12)
}
func (o *PCR_Type) GetI2C0_SCLK_CONF_I2C0_SCLK_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.I2C0_SCLK_CONF.Reg) & 0xff000) >> 12
}
func (o *PCR_Type) SetI2C0_SCLK_CONF_I2C0_SCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.I2C0_SCLK_CONF.Reg, volatile.LoadUint32(&o.I2C0_SCLK_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *PCR_Type) GetI2C0_SCLK_CONF_I2C0_SCLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.I2C0_SCLK_CONF.Reg) & 0x100000) >> 20
}
func (o *PCR_Type) SetI2C0_SCLK_CONF_I2C0_SCLK_EN(value uint32) {
	volatile.StoreUint32(&o.I2C0_SCLK_CONF.Reg, volatile.LoadUint32(&o.I2C0_SCLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetI2C0_SCLK_CONF_I2C0_SCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.I2C0_SCLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.I2C1_CONF: I2C configuration register
func (o *PCR_Type) SetI2C1_CONF_I2C1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.I2C1_CONF.Reg, volatile.LoadUint32(&o.I2C1_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetI2C1_CONF_I2C1_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.I2C1_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetI2C1_CONF_I2C1_RST_EN(value uint32) {
	volatile.StoreUint32(&o.I2C1_CONF.Reg, volatile.LoadUint32(&o.I2C1_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetI2C1_CONF_I2C1_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.I2C1_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetI2C1_CONF_I2C1_READY(value uint32) {
	volatile.StoreUint32(&o.I2C1_CONF.Reg, volatile.LoadUint32(&o.I2C1_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetI2C1_CONF_I2C1_READY() uint32 {
	return (volatile.LoadUint32(&o.I2C1_CONF.Reg) & 0x4) >> 2
}

// PCR.I2C1_SCLK_CONF: I2C_SCLK configuration register
func (o *PCR_Type) SetI2C1_SCLK_CONF_I2C1_SCLK_DIV_A(value uint32) {
	volatile.StoreUint32(&o.I2C1_SCLK_CONF.Reg, volatile.LoadUint32(&o.I2C1_SCLK_CONF.Reg)&^(0x3f)|value)
}
func (o *PCR_Type) GetI2C1_SCLK_CONF_I2C1_SCLK_DIV_A() uint32 {
	return volatile.LoadUint32(&o.I2C1_SCLK_CONF.Reg) & 0x3f
}
func (o *PCR_Type) SetI2C1_SCLK_CONF_I2C1_SCLK_DIV_B(value uint32) {
	volatile.StoreUint32(&o.I2C1_SCLK_CONF.Reg, volatile.LoadUint32(&o.I2C1_SCLK_CONF.Reg)&^(0xfc0)|value<<6)
}
func (o *PCR_Type) GetI2C1_SCLK_CONF_I2C1_SCLK_DIV_B() uint32 {
	return (volatile.LoadUint32(&o.I2C1_SCLK_CONF.Reg) & 0xfc0) >> 6
}
func (o *PCR_Type) SetI2C1_SCLK_CONF_I2C1_SCLK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.I2C1_SCLK_CONF.Reg, volatile.LoadUint32(&o.I2C1_SCLK_CONF.Reg)&^(0xff000)|value<<12)
}
func (o *PCR_Type) GetI2C1_SCLK_CONF_I2C1_SCLK_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.I2C1_SCLK_CONF.Reg) & 0xff000) >> 12
}
func (o *PCR_Type) SetI2C1_SCLK_CONF_I2C1_SCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.I2C1_SCLK_CONF.Reg, volatile.LoadUint32(&o.I2C1_SCLK_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *PCR_Type) GetI2C1_SCLK_CONF_I2C1_SCLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.I2C1_SCLK_CONF.Reg) & 0x100000) >> 20
}
func (o *PCR_Type) SetI2C1_SCLK_CONF_I2C1_SCLK_EN(value uint32) {
	volatile.StoreUint32(&o.I2C1_SCLK_CONF.Reg, volatile.LoadUint32(&o.I2C1_SCLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetI2C1_SCLK_CONF_I2C1_SCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.I2C1_SCLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.UHCI_CONF: UHCI configuration register
func (o *PCR_Type) SetUHCI_CONF_UHCI_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.UHCI_CONF.Reg, volatile.LoadUint32(&o.UHCI_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetUHCI_CONF_UHCI_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.UHCI_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetUHCI_CONF_UHCI_RST_EN(value uint32) {
	volatile.StoreUint32(&o.UHCI_CONF.Reg, volatile.LoadUint32(&o.UHCI_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetUHCI_CONF_UHCI_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.UHCI_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetUHCI_CONF_UHCI_READY(value uint32) {
	volatile.StoreUint32(&o.UHCI_CONF.Reg, volatile.LoadUint32(&o.UHCI_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetUHCI_CONF_UHCI_READY() uint32 {
	return (volatile.LoadUint32(&o.UHCI_CONF.Reg) & 0x4) >> 2
}

// PCR.RMT_CONF: RMT configuration register
func (o *PCR_Type) SetRMT_CONF_RMT_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.RMT_CONF.Reg, volatile.LoadUint32(&o.RMT_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetRMT_CONF_RMT_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.RMT_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetRMT_CONF_RMT_RST_EN(value uint32) {
	volatile.StoreUint32(&o.RMT_CONF.Reg, volatile.LoadUint32(&o.RMT_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetRMT_CONF_RMT_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.RMT_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetRMT_CONF_RMT_READY(value uint32) {
	volatile.StoreUint32(&o.RMT_CONF.Reg, volatile.LoadUint32(&o.RMT_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetRMT_CONF_RMT_READY() uint32 {
	return (volatile.LoadUint32(&o.RMT_CONF.Reg) & 0x4) >> 2
}

// PCR.RMT_SCLK_CONF: RMT_SCLK configuration register
func (o *PCR_Type) SetRMT_SCLK_CONF_SCLK_DIV_A(value uint32) {
	volatile.StoreUint32(&o.RMT_SCLK_CONF.Reg, volatile.LoadUint32(&o.RMT_SCLK_CONF.Reg)&^(0x3f)|value)
}
func (o *PCR_Type) GetRMT_SCLK_CONF_SCLK_DIV_A() uint32 {
	return volatile.LoadUint32(&o.RMT_SCLK_CONF.Reg) & 0x3f
}
func (o *PCR_Type) SetRMT_SCLK_CONF_SCLK_DIV_B(value uint32) {
	volatile.StoreUint32(&o.RMT_SCLK_CONF.Reg, volatile.LoadUint32(&o.RMT_SCLK_CONF.Reg)&^(0xfc0)|value<<6)
}
func (o *PCR_Type) GetRMT_SCLK_CONF_SCLK_DIV_B() uint32 {
	return (volatile.LoadUint32(&o.RMT_SCLK_CONF.Reg) & 0xfc0) >> 6
}
func (o *PCR_Type) SetRMT_SCLK_CONF_SCLK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.RMT_SCLK_CONF.Reg, volatile.LoadUint32(&o.RMT_SCLK_CONF.Reg)&^(0xff000)|value<<12)
}
func (o *PCR_Type) GetRMT_SCLK_CONF_SCLK_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.RMT_SCLK_CONF.Reg) & 0xff000) >> 12
}
func (o *PCR_Type) SetRMT_SCLK_CONF_SCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.RMT_SCLK_CONF.Reg, volatile.LoadUint32(&o.RMT_SCLK_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *PCR_Type) GetRMT_SCLK_CONF_SCLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.RMT_SCLK_CONF.Reg) & 0x100000) >> 20
}
func (o *PCR_Type) SetRMT_SCLK_CONF_SCLK_EN(value uint32) {
	volatile.StoreUint32(&o.RMT_SCLK_CONF.Reg, volatile.LoadUint32(&o.RMT_SCLK_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *PCR_Type) GetRMT_SCLK_CONF_SCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.RMT_SCLK_CONF.Reg) & 0x200000) >> 21
}

// PCR.LEDC_CONF: LEDC configuration register
func (o *PCR_Type) SetLEDC_CONF_LEDC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.LEDC_CONF.Reg, volatile.LoadUint32(&o.LEDC_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetLEDC_CONF_LEDC_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.LEDC_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetLEDC_CONF_LEDC_RST_EN(value uint32) {
	volatile.StoreUint32(&o.LEDC_CONF.Reg, volatile.LoadUint32(&o.LEDC_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetLEDC_CONF_LEDC_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.LEDC_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetLEDC_CONF_LEDC_READY(value uint32) {
	volatile.StoreUint32(&o.LEDC_CONF.Reg, volatile.LoadUint32(&o.LEDC_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetLEDC_CONF_LEDC_READY() uint32 {
	return (volatile.LoadUint32(&o.LEDC_CONF.Reg) & 0x4) >> 2
}

// PCR.LEDC_SCLK_CONF: LEDC_SCLK configuration register
func (o *PCR_Type) SetLEDC_SCLK_CONF_LEDC_SCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.LEDC_SCLK_CONF.Reg, volatile.LoadUint32(&o.LEDC_SCLK_CONF.Reg)&^(0x300000)|value<<20)
}
func (o *PCR_Type) GetLEDC_SCLK_CONF_LEDC_SCLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.LEDC_SCLK_CONF.Reg) & 0x300000) >> 20
}
func (o *PCR_Type) SetLEDC_SCLK_CONF_LEDC_SCLK_EN(value uint32) {
	volatile.StoreUint32(&o.LEDC_SCLK_CONF.Reg, volatile.LoadUint32(&o.LEDC_SCLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetLEDC_SCLK_CONF_LEDC_SCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.LEDC_SCLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.TIMERGROUP0_CONF: TIMERGROUP0 configuration register
func (o *PCR_Type) SetTIMERGROUP0_CONF_TG0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP0_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP0_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetTIMERGROUP0_CONF_TG0_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.TIMERGROUP0_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetTIMERGROUP0_CONF_TG0_RST_EN(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP0_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP0_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetTIMERGROUP0_CONF_TG0_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP0_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetTIMERGROUP0_CONF_TG0_WDT_READY(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP0_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP0_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetTIMERGROUP0_CONF_TG0_WDT_READY() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP0_CONF.Reg) & 0x4) >> 2
}
func (o *PCR_Type) SetTIMERGROUP0_CONF_TG0_TIMER0_READY(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP0_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP0_CONF.Reg)&^(0x8)|value<<3)
}
func (o *PCR_Type) GetTIMERGROUP0_CONF_TG0_TIMER0_READY() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP0_CONF.Reg) & 0x8) >> 3
}
func (o *PCR_Type) SetTIMERGROUP0_CONF_TG0_TIMER1_READY(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP0_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP0_CONF.Reg)&^(0x10)|value<<4)
}
func (o *PCR_Type) GetTIMERGROUP0_CONF_TG0_TIMER1_READY() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP0_CONF.Reg) & 0x10) >> 4
}

// PCR.TIMERGROUP0_TIMER_CLK_CONF: TIMERGROUP0_TIMER_CLK configuration register
func (o *PCR_Type) SetTIMERGROUP0_TIMER_CLK_CONF_TG0_TIMER_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP0_TIMER_CLK_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP0_TIMER_CLK_CONF.Reg)&^(0x300000)|value<<20)
}
func (o *PCR_Type) GetTIMERGROUP0_TIMER_CLK_CONF_TG0_TIMER_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP0_TIMER_CLK_CONF.Reg) & 0x300000) >> 20
}
func (o *PCR_Type) SetTIMERGROUP0_TIMER_CLK_CONF_TG0_TIMER_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP0_TIMER_CLK_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP0_TIMER_CLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetTIMERGROUP0_TIMER_CLK_CONF_TG0_TIMER_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP0_TIMER_CLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.TIMERGROUP0_WDT_CLK_CONF: TIMERGROUP0_WDT_CLK configuration register
func (o *PCR_Type) SetTIMERGROUP0_WDT_CLK_CONF_TG0_WDT_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP0_WDT_CLK_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP0_WDT_CLK_CONF.Reg)&^(0x300000)|value<<20)
}
func (o *PCR_Type) GetTIMERGROUP0_WDT_CLK_CONF_TG0_WDT_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP0_WDT_CLK_CONF.Reg) & 0x300000) >> 20
}
func (o *PCR_Type) SetTIMERGROUP0_WDT_CLK_CONF_TG0_WDT_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP0_WDT_CLK_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP0_WDT_CLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetTIMERGROUP0_WDT_CLK_CONF_TG0_WDT_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP0_WDT_CLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.TIMERGROUP1_CONF: TIMERGROUP1 configuration register
func (o *PCR_Type) SetTIMERGROUP1_CONF_TG1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP1_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP1_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetTIMERGROUP1_CONF_TG1_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.TIMERGROUP1_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetTIMERGROUP1_CONF_TG1_RST_EN(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP1_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP1_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetTIMERGROUP1_CONF_TG1_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP1_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetTIMERGROUP1_CONF_TG1_WDT_READY(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP1_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP1_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetTIMERGROUP1_CONF_TG1_WDT_READY() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP1_CONF.Reg) & 0x4) >> 2
}
func (o *PCR_Type) SetTIMERGROUP1_CONF_TG1_TIMER0_READY(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP1_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP1_CONF.Reg)&^(0x8)|value<<3)
}
func (o *PCR_Type) GetTIMERGROUP1_CONF_TG1_TIMER0_READY() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP1_CONF.Reg) & 0x8) >> 3
}
func (o *PCR_Type) SetTIMERGROUP1_CONF_TG1_TIMER1_READY(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP1_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP1_CONF.Reg)&^(0x10)|value<<4)
}
func (o *PCR_Type) GetTIMERGROUP1_CONF_TG1_TIMER1_READY() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP1_CONF.Reg) & 0x10) >> 4
}

// PCR.TIMERGROUP1_TIMER_CLK_CONF: TIMERGROUP1_TIMER_CLK configuration register
func (o *PCR_Type) SetTIMERGROUP1_TIMER_CLK_CONF_TG1_TIMER_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP1_TIMER_CLK_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP1_TIMER_CLK_CONF.Reg)&^(0x300000)|value<<20)
}
func (o *PCR_Type) GetTIMERGROUP1_TIMER_CLK_CONF_TG1_TIMER_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP1_TIMER_CLK_CONF.Reg) & 0x300000) >> 20
}
func (o *PCR_Type) SetTIMERGROUP1_TIMER_CLK_CONF_TG1_TIMER_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP1_TIMER_CLK_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP1_TIMER_CLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetTIMERGROUP1_TIMER_CLK_CONF_TG1_TIMER_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP1_TIMER_CLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.TIMERGROUP1_WDT_CLK_CONF: TIMERGROUP1_WDT_CLK configuration register
func (o *PCR_Type) SetTIMERGROUP1_WDT_CLK_CONF_TG1_WDT_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP1_WDT_CLK_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP1_WDT_CLK_CONF.Reg)&^(0x300000)|value<<20)
}
func (o *PCR_Type) GetTIMERGROUP1_WDT_CLK_CONF_TG1_WDT_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP1_WDT_CLK_CONF.Reg) & 0x300000) >> 20
}
func (o *PCR_Type) SetTIMERGROUP1_WDT_CLK_CONF_TG1_WDT_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.TIMERGROUP1_WDT_CLK_CONF.Reg, volatile.LoadUint32(&o.TIMERGROUP1_WDT_CLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetTIMERGROUP1_WDT_CLK_CONF_TG1_WDT_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.TIMERGROUP1_WDT_CLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.SYSTIMER_CONF: SYSTIMER configuration register
func (o *PCR_Type) SetSYSTIMER_CONF_SYSTIMER_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SYSTIMER_CONF.Reg, volatile.LoadUint32(&o.SYSTIMER_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetSYSTIMER_CONF_SYSTIMER_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.SYSTIMER_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetSYSTIMER_CONF_SYSTIMER_RST_EN(value uint32) {
	volatile.StoreUint32(&o.SYSTIMER_CONF.Reg, volatile.LoadUint32(&o.SYSTIMER_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetSYSTIMER_CONF_SYSTIMER_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.SYSTIMER_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetSYSTIMER_CONF_SYSTIMER_READY(value uint32) {
	volatile.StoreUint32(&o.SYSTIMER_CONF.Reg, volatile.LoadUint32(&o.SYSTIMER_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetSYSTIMER_CONF_SYSTIMER_READY() uint32 {
	return (volatile.LoadUint32(&o.SYSTIMER_CONF.Reg) & 0x4) >> 2
}

// PCR.SYSTIMER_FUNC_CLK_CONF: SYSTIMER_FUNC_CLK configuration register
func (o *PCR_Type) SetSYSTIMER_FUNC_CLK_CONF_SYSTIMER_FUNC_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.SYSTIMER_FUNC_CLK_CONF.Reg, volatile.LoadUint32(&o.SYSTIMER_FUNC_CLK_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *PCR_Type) GetSYSTIMER_FUNC_CLK_CONF_SYSTIMER_FUNC_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.SYSTIMER_FUNC_CLK_CONF.Reg) & 0x100000) >> 20
}
func (o *PCR_Type) SetSYSTIMER_FUNC_CLK_CONF_SYSTIMER_FUNC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SYSTIMER_FUNC_CLK_CONF.Reg, volatile.LoadUint32(&o.SYSTIMER_FUNC_CLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetSYSTIMER_FUNC_CLK_CONF_SYSTIMER_FUNC_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.SYSTIMER_FUNC_CLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.TWAI0_CONF: TWAI0 configuration register
func (o *PCR_Type) SetTWAI0_CONF_TWAI0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.TWAI0_CONF.Reg, volatile.LoadUint32(&o.TWAI0_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetTWAI0_CONF_TWAI0_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.TWAI0_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetTWAI0_CONF_TWAI0_RST_EN(value uint32) {
	volatile.StoreUint32(&o.TWAI0_CONF.Reg, volatile.LoadUint32(&o.TWAI0_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetTWAI0_CONF_TWAI0_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.TWAI0_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetTWAI0_CONF_TWAI0_READY(value uint32) {
	volatile.StoreUint32(&o.TWAI0_CONF.Reg, volatile.LoadUint32(&o.TWAI0_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetTWAI0_CONF_TWAI0_READY() uint32 {
	return (volatile.LoadUint32(&o.TWAI0_CONF.Reg) & 0x4) >> 2
}

// PCR.TWAI0_FUNC_CLK_CONF: TWAI0_FUNC_CLK configuration register
func (o *PCR_Type) SetTWAI0_FUNC_CLK_CONF_TWAI0_FUNC_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.TWAI0_FUNC_CLK_CONF.Reg, volatile.LoadUint32(&o.TWAI0_FUNC_CLK_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *PCR_Type) GetTWAI0_FUNC_CLK_CONF_TWAI0_FUNC_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TWAI0_FUNC_CLK_CONF.Reg) & 0x100000) >> 20
}
func (o *PCR_Type) SetTWAI0_FUNC_CLK_CONF_TWAI0_FUNC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.TWAI0_FUNC_CLK_CONF.Reg, volatile.LoadUint32(&o.TWAI0_FUNC_CLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetTWAI0_FUNC_CLK_CONF_TWAI0_FUNC_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.TWAI0_FUNC_CLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.I2S_CONF: I2S configuration register
func (o *PCR_Type) SetI2S_CONF_I2S_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.I2S_CONF.Reg, volatile.LoadUint32(&o.I2S_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetI2S_CONF_I2S_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.I2S_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetI2S_CONF_I2S_RST_EN(value uint32) {
	volatile.StoreUint32(&o.I2S_CONF.Reg, volatile.LoadUint32(&o.I2S_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetI2S_CONF_I2S_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.I2S_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetI2S_CONF_I2S_RX_READY(value uint32) {
	volatile.StoreUint32(&o.I2S_CONF.Reg, volatile.LoadUint32(&o.I2S_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetI2S_CONF_I2S_RX_READY() uint32 {
	return (volatile.LoadUint32(&o.I2S_CONF.Reg) & 0x4) >> 2
}
func (o *PCR_Type) SetI2S_CONF_I2S_TX_READY(value uint32) {
	volatile.StoreUint32(&o.I2S_CONF.Reg, volatile.LoadUint32(&o.I2S_CONF.Reg)&^(0x8)|value<<3)
}
func (o *PCR_Type) GetI2S_CONF_I2S_TX_READY() uint32 {
	return (volatile.LoadUint32(&o.I2S_CONF.Reg) & 0x8) >> 3
}

// PCR.I2S_TX_CLKM_CONF: I2S_TX_CLKM configuration register
func (o *PCR_Type) SetI2S_TX_CLKM_CONF_I2S_TX_CLKM_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.I2S_TX_CLKM_CONF.Reg, volatile.LoadUint32(&o.I2S_TX_CLKM_CONF.Reg)&^(0xff000)|value<<12)
}
func (o *PCR_Type) GetI2S_TX_CLKM_CONF_I2S_TX_CLKM_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.I2S_TX_CLKM_CONF.Reg) & 0xff000) >> 12
}
func (o *PCR_Type) SetI2S_TX_CLKM_CONF_I2S_TX_CLKM_SEL(value uint32) {
	volatile.StoreUint32(&o.I2S_TX_CLKM_CONF.Reg, volatile.LoadUint32(&o.I2S_TX_CLKM_CONF.Reg)&^(0x300000)|value<<20)
}
func (o *PCR_Type) GetI2S_TX_CLKM_CONF_I2S_TX_CLKM_SEL() uint32 {
	return (volatile.LoadUint32(&o.I2S_TX_CLKM_CONF.Reg) & 0x300000) >> 20
}
func (o *PCR_Type) SetI2S_TX_CLKM_CONF_I2S_TX_CLKM_EN(value uint32) {
	volatile.StoreUint32(&o.I2S_TX_CLKM_CONF.Reg, volatile.LoadUint32(&o.I2S_TX_CLKM_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetI2S_TX_CLKM_CONF_I2S_TX_CLKM_EN() uint32 {
	return (volatile.LoadUint32(&o.I2S_TX_CLKM_CONF.Reg) & 0x400000) >> 22
}

// PCR.I2S_TX_CLKM_DIV_CONF: I2S_TX_CLKM_DIV configuration register
func (o *PCR_Type) SetI2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_Z(value uint32) {
	volatile.StoreUint32(&o.I2S_TX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.I2S_TX_CLKM_DIV_CONF.Reg)&^(0x1ff)|value)
}
func (o *PCR_Type) GetI2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_Z() uint32 {
	return volatile.LoadUint32(&o.I2S_TX_CLKM_DIV_CONF.Reg) & 0x1ff
}
func (o *PCR_Type) SetI2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_Y(value uint32) {
	volatile.StoreUint32(&o.I2S_TX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.I2S_TX_CLKM_DIV_CONF.Reg)&^(0x3fe00)|value<<9)
}
func (o *PCR_Type) GetI2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_Y() uint32 {
	return (volatile.LoadUint32(&o.I2S_TX_CLKM_DIV_CONF.Reg) & 0x3fe00) >> 9
}
func (o *PCR_Type) SetI2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_X(value uint32) {
	volatile.StoreUint32(&o.I2S_TX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.I2S_TX_CLKM_DIV_CONF.Reg)&^(0x7fc0000)|value<<18)
}
func (o *PCR_Type) GetI2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_X() uint32 {
	return (volatile.LoadUint32(&o.I2S_TX_CLKM_DIV_CONF.Reg) & 0x7fc0000) >> 18
}
func (o *PCR_Type) SetI2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_YN1(value uint32) {
	volatile.StoreUint32(&o.I2S_TX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.I2S_TX_CLKM_DIV_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *PCR_Type) GetI2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_YN1() uint32 {
	return (volatile.LoadUint32(&o.I2S_TX_CLKM_DIV_CONF.Reg) & 0x8000000) >> 27
}

// PCR.I2S_RX_CLKM_CONF: I2S_RX_CLKM configuration register
func (o *PCR_Type) SetI2S_RX_CLKM_CONF_I2S_RX_CLKM_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.I2S_RX_CLKM_CONF.Reg, volatile.LoadUint32(&o.I2S_RX_CLKM_CONF.Reg)&^(0xff000)|value<<12)
}
func (o *PCR_Type) GetI2S_RX_CLKM_CONF_I2S_RX_CLKM_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.I2S_RX_CLKM_CONF.Reg) & 0xff000) >> 12
}
func (o *PCR_Type) SetI2S_RX_CLKM_CONF_I2S_RX_CLKM_SEL(value uint32) {
	volatile.StoreUint32(&o.I2S_RX_CLKM_CONF.Reg, volatile.LoadUint32(&o.I2S_RX_CLKM_CONF.Reg)&^(0x300000)|value<<20)
}
func (o *PCR_Type) GetI2S_RX_CLKM_CONF_I2S_RX_CLKM_SEL() uint32 {
	return (volatile.LoadUint32(&o.I2S_RX_CLKM_CONF.Reg) & 0x300000) >> 20
}
func (o *PCR_Type) SetI2S_RX_CLKM_CONF_I2S_RX_CLKM_EN(value uint32) {
	volatile.StoreUint32(&o.I2S_RX_CLKM_CONF.Reg, volatile.LoadUint32(&o.I2S_RX_CLKM_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetI2S_RX_CLKM_CONF_I2S_RX_CLKM_EN() uint32 {
	return (volatile.LoadUint32(&o.I2S_RX_CLKM_CONF.Reg) & 0x400000) >> 22
}
func (o *PCR_Type) SetI2S_RX_CLKM_CONF_I2S_MCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.I2S_RX_CLKM_CONF.Reg, volatile.LoadUint32(&o.I2S_RX_CLKM_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *PCR_Type) GetI2S_RX_CLKM_CONF_I2S_MCLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.I2S_RX_CLKM_CONF.Reg) & 0x800000) >> 23
}

// PCR.I2S_RX_CLKM_DIV_CONF: I2S_RX_CLKM_DIV configuration register
func (o *PCR_Type) SetI2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_Z(value uint32) {
	volatile.StoreUint32(&o.I2S_RX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.I2S_RX_CLKM_DIV_CONF.Reg)&^(0x1ff)|value)
}
func (o *PCR_Type) GetI2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_Z() uint32 {
	return volatile.LoadUint32(&o.I2S_RX_CLKM_DIV_CONF.Reg) & 0x1ff
}
func (o *PCR_Type) SetI2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_Y(value uint32) {
	volatile.StoreUint32(&o.I2S_RX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.I2S_RX_CLKM_DIV_CONF.Reg)&^(0x3fe00)|value<<9)
}
func (o *PCR_Type) GetI2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_Y() uint32 {
	return (volatile.LoadUint32(&o.I2S_RX_CLKM_DIV_CONF.Reg) & 0x3fe00) >> 9
}
func (o *PCR_Type) SetI2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_X(value uint32) {
	volatile.StoreUint32(&o.I2S_RX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.I2S_RX_CLKM_DIV_CONF.Reg)&^(0x7fc0000)|value<<18)
}
func (o *PCR_Type) GetI2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_X() uint32 {
	return (volatile.LoadUint32(&o.I2S_RX_CLKM_DIV_CONF.Reg) & 0x7fc0000) >> 18
}
func (o *PCR_Type) SetI2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_YN1(value uint32) {
	volatile.StoreUint32(&o.I2S_RX_CLKM_DIV_CONF.Reg, volatile.LoadUint32(&o.I2S_RX_CLKM_DIV_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *PCR_Type) GetI2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_YN1() uint32 {
	return (volatile.LoadUint32(&o.I2S_RX_CLKM_DIV_CONF.Reg) & 0x8000000) >> 27
}

// PCR.SARADC_CONF: SARADC configuration register
func (o *PCR_Type) SetSARADC_CONF_SARADC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SARADC_CONF.Reg, volatile.LoadUint32(&o.SARADC_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetSARADC_CONF_SARADC_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.SARADC_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetSARADC_CONF_SARADC_RST_EN(value uint32) {
	volatile.StoreUint32(&o.SARADC_CONF.Reg, volatile.LoadUint32(&o.SARADC_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetSARADC_CONF_SARADC_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.SARADC_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetSARADC_CONF_SARADC_REG_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SARADC_CONF.Reg, volatile.LoadUint32(&o.SARADC_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetSARADC_CONF_SARADC_REG_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.SARADC_CONF.Reg) & 0x4) >> 2
}
func (o *PCR_Type) SetSARADC_CONF_SARADC_REG_RST_EN(value uint32) {
	volatile.StoreUint32(&o.SARADC_CONF.Reg, volatile.LoadUint32(&o.SARADC_CONF.Reg)&^(0x8)|value<<3)
}
func (o *PCR_Type) GetSARADC_CONF_SARADC_REG_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.SARADC_CONF.Reg) & 0x8) >> 3
}

// PCR.SARADC_CLKM_CONF: SARADC_CLKM configuration register
func (o *PCR_Type) SetSARADC_CLKM_CONF_SARADC_CLKM_DIV_A(value uint32) {
	volatile.StoreUint32(&o.SARADC_CLKM_CONF.Reg, volatile.LoadUint32(&o.SARADC_CLKM_CONF.Reg)&^(0x3f)|value)
}
func (o *PCR_Type) GetSARADC_CLKM_CONF_SARADC_CLKM_DIV_A() uint32 {
	return volatile.LoadUint32(&o.SARADC_CLKM_CONF.Reg) & 0x3f
}
func (o *PCR_Type) SetSARADC_CLKM_CONF_SARADC_CLKM_DIV_B(value uint32) {
	volatile.StoreUint32(&o.SARADC_CLKM_CONF.Reg, volatile.LoadUint32(&o.SARADC_CLKM_CONF.Reg)&^(0xfc0)|value<<6)
}
func (o *PCR_Type) GetSARADC_CLKM_CONF_SARADC_CLKM_DIV_B() uint32 {
	return (volatile.LoadUint32(&o.SARADC_CLKM_CONF.Reg) & 0xfc0) >> 6
}
func (o *PCR_Type) SetSARADC_CLKM_CONF_SARADC_CLKM_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.SARADC_CLKM_CONF.Reg, volatile.LoadUint32(&o.SARADC_CLKM_CONF.Reg)&^(0xff000)|value<<12)
}
func (o *PCR_Type) GetSARADC_CLKM_CONF_SARADC_CLKM_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.SARADC_CLKM_CONF.Reg) & 0xff000) >> 12
}
func (o *PCR_Type) SetSARADC_CLKM_CONF_SARADC_CLKM_SEL(value uint32) {
	volatile.StoreUint32(&o.SARADC_CLKM_CONF.Reg, volatile.LoadUint32(&o.SARADC_CLKM_CONF.Reg)&^(0x300000)|value<<20)
}
func (o *PCR_Type) GetSARADC_CLKM_CONF_SARADC_CLKM_SEL() uint32 {
	return (volatile.LoadUint32(&o.SARADC_CLKM_CONF.Reg) & 0x300000) >> 20
}
func (o *PCR_Type) SetSARADC_CLKM_CONF_SARADC_CLKM_EN(value uint32) {
	volatile.StoreUint32(&o.SARADC_CLKM_CONF.Reg, volatile.LoadUint32(&o.SARADC_CLKM_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetSARADC_CLKM_CONF_SARADC_CLKM_EN() uint32 {
	return (volatile.LoadUint32(&o.SARADC_CLKM_CONF.Reg) & 0x400000) >> 22
}

// PCR.TSENS_CLK_CONF: TSENS_CLK configuration register
func (o *PCR_Type) SetTSENS_CLK_CONF_TSENS_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.TSENS_CLK_CONF.Reg, volatile.LoadUint32(&o.TSENS_CLK_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *PCR_Type) GetTSENS_CLK_CONF_TSENS_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TSENS_CLK_CONF.Reg) & 0x100000) >> 20
}
func (o *PCR_Type) SetTSENS_CLK_CONF_TSENS_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.TSENS_CLK_CONF.Reg, volatile.LoadUint32(&o.TSENS_CLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetTSENS_CLK_CONF_TSENS_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.TSENS_CLK_CONF.Reg) & 0x400000) >> 22
}
func (o *PCR_Type) SetTSENS_CLK_CONF_TSENS_RST_EN(value uint32) {
	volatile.StoreUint32(&o.TSENS_CLK_CONF.Reg, volatile.LoadUint32(&o.TSENS_CLK_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *PCR_Type) GetTSENS_CLK_CONF_TSENS_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.TSENS_CLK_CONF.Reg) & 0x800000) >> 23
}

// PCR.USB_DEVICE_CONF: USB_DEVICE configuration register
func (o *PCR_Type) SetUSB_DEVICE_CONF_USB_DEVICE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.USB_DEVICE_CONF.Reg, volatile.LoadUint32(&o.USB_DEVICE_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetUSB_DEVICE_CONF_USB_DEVICE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.USB_DEVICE_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetUSB_DEVICE_CONF_USB_DEVICE_RST_EN(value uint32) {
	volatile.StoreUint32(&o.USB_DEVICE_CONF.Reg, volatile.LoadUint32(&o.USB_DEVICE_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetUSB_DEVICE_CONF_USB_DEVICE_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.USB_DEVICE_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetUSB_DEVICE_CONF_USB_DEVICE_READY(value uint32) {
	volatile.StoreUint32(&o.USB_DEVICE_CONF.Reg, volatile.LoadUint32(&o.USB_DEVICE_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetUSB_DEVICE_CONF_USB_DEVICE_READY() uint32 {
	return (volatile.LoadUint32(&o.USB_DEVICE_CONF.Reg) & 0x4) >> 2
}

// PCR.INTMTX_CONF: INTMTX configuration register
func (o *PCR_Type) SetINTMTX_CONF_INTMTX_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.INTMTX_CONF.Reg, volatile.LoadUint32(&o.INTMTX_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetINTMTX_CONF_INTMTX_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.INTMTX_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetINTMTX_CONF_INTMTX_RST_EN(value uint32) {
	volatile.StoreUint32(&o.INTMTX_CONF.Reg, volatile.LoadUint32(&o.INTMTX_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetINTMTX_CONF_INTMTX_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.INTMTX_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetINTMTX_CONF_INTMTX_READY(value uint32) {
	volatile.StoreUint32(&o.INTMTX_CONF.Reg, volatile.LoadUint32(&o.INTMTX_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetINTMTX_CONF_INTMTX_READY() uint32 {
	return (volatile.LoadUint32(&o.INTMTX_CONF.Reg) & 0x4) >> 2
}

// PCR.PCNT_CONF: PCNT configuration register
func (o *PCR_Type) SetPCNT_CONF_PCNT_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PCNT_CONF.Reg, volatile.LoadUint32(&o.PCNT_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetPCNT_CONF_PCNT_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.PCNT_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetPCNT_CONF_PCNT_RST_EN(value uint32) {
	volatile.StoreUint32(&o.PCNT_CONF.Reg, volatile.LoadUint32(&o.PCNT_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetPCNT_CONF_PCNT_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.PCNT_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetPCNT_CONF_PCNT_READY(value uint32) {
	volatile.StoreUint32(&o.PCNT_CONF.Reg, volatile.LoadUint32(&o.PCNT_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetPCNT_CONF_PCNT_READY() uint32 {
	return (volatile.LoadUint32(&o.PCNT_CONF.Reg) & 0x4) >> 2
}

// PCR.ETM_CONF: ETM configuration register
func (o *PCR_Type) SetETM_CONF_ETM_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_CONF.Reg, volatile.LoadUint32(&o.ETM_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetETM_CONF_ETM_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.ETM_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetETM_CONF_ETM_RST_EN(value uint32) {
	volatile.StoreUint32(&o.ETM_CONF.Reg, volatile.LoadUint32(&o.ETM_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetETM_CONF_ETM_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.ETM_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetETM_CONF_ETM_READY(value uint32) {
	volatile.StoreUint32(&o.ETM_CONF.Reg, volatile.LoadUint32(&o.ETM_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetETM_CONF_ETM_READY() uint32 {
	return (volatile.LoadUint32(&o.ETM_CONF.Reg) & 0x4) >> 2
}

// PCR.PWM_CONF: PWM configuration register
func (o *PCR_Type) SetPWM_CONF_PWM_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PWM_CONF.Reg, volatile.LoadUint32(&o.PWM_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetPWM_CONF_PWM_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.PWM_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetPWM_CONF_PWM_RST_EN(value uint32) {
	volatile.StoreUint32(&o.PWM_CONF.Reg, volatile.LoadUint32(&o.PWM_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetPWM_CONF_PWM_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.PWM_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetPWM_CONF_PWM_READY(value uint32) {
	volatile.StoreUint32(&o.PWM_CONF.Reg, volatile.LoadUint32(&o.PWM_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetPWM_CONF_PWM_READY() uint32 {
	return (volatile.LoadUint32(&o.PWM_CONF.Reg) & 0x4) >> 2
}

// PCR.PWM_CLK_CONF: PWM_CLK configuration register
func (o *PCR_Type) SetPWM_CLK_CONF_PWM_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.PWM_CLK_CONF.Reg, volatile.LoadUint32(&o.PWM_CLK_CONF.Reg)&^(0xff000)|value<<12)
}
func (o *PCR_Type) GetPWM_CLK_CONF_PWM_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.PWM_CLK_CONF.Reg) & 0xff000) >> 12
}
func (o *PCR_Type) SetPWM_CLK_CONF_PWM_CLKM_SEL(value uint32) {
	volatile.StoreUint32(&o.PWM_CLK_CONF.Reg, volatile.LoadUint32(&o.PWM_CLK_CONF.Reg)&^(0x300000)|value<<20)
}
func (o *PCR_Type) GetPWM_CLK_CONF_PWM_CLKM_SEL() uint32 {
	return (volatile.LoadUint32(&o.PWM_CLK_CONF.Reg) & 0x300000) >> 20
}
func (o *PCR_Type) SetPWM_CLK_CONF_PWM_CLKM_EN(value uint32) {
	volatile.StoreUint32(&o.PWM_CLK_CONF.Reg, volatile.LoadUint32(&o.PWM_CLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetPWM_CLK_CONF_PWM_CLKM_EN() uint32 {
	return (volatile.LoadUint32(&o.PWM_CLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.PARL_IO_CONF: PARL_IO configuration register
func (o *PCR_Type) SetPARL_IO_CONF_PARL_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PARL_IO_CONF.Reg, volatile.LoadUint32(&o.PARL_IO_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetPARL_IO_CONF_PARL_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.PARL_IO_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetPARL_IO_CONF_PARL_RST_EN(value uint32) {
	volatile.StoreUint32(&o.PARL_IO_CONF.Reg, volatile.LoadUint32(&o.PARL_IO_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetPARL_IO_CONF_PARL_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.PARL_IO_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetPARL_IO_CONF_PARL_READY(value uint32) {
	volatile.StoreUint32(&o.PARL_IO_CONF.Reg, volatile.LoadUint32(&o.PARL_IO_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetPARL_IO_CONF_PARL_READY() uint32 {
	return (volatile.LoadUint32(&o.PARL_IO_CONF.Reg) & 0x4) >> 2
}

// PCR.PARL_CLK_RX_CONF: PARL_CLK_RX configuration register
func (o *PCR_Type) SetPARL_CLK_RX_CONF_PARL_CLK_RX_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.PARL_CLK_RX_CONF.Reg, volatile.LoadUint32(&o.PARL_CLK_RX_CONF.Reg)&^(0xffff)|value)
}
func (o *PCR_Type) GetPARL_CLK_RX_CONF_PARL_CLK_RX_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.PARL_CLK_RX_CONF.Reg) & 0xffff
}
func (o *PCR_Type) SetPARL_CLK_RX_CONF_PARL_CLK_RX_SEL(value uint32) {
	volatile.StoreUint32(&o.PARL_CLK_RX_CONF.Reg, volatile.LoadUint32(&o.PARL_CLK_RX_CONF.Reg)&^(0x30000)|value<<16)
}
func (o *PCR_Type) GetPARL_CLK_RX_CONF_PARL_CLK_RX_SEL() uint32 {
	return (volatile.LoadUint32(&o.PARL_CLK_RX_CONF.Reg) & 0x30000) >> 16
}
func (o *PCR_Type) SetPARL_CLK_RX_CONF_PARL_CLK_RX_EN(value uint32) {
	volatile.StoreUint32(&o.PARL_CLK_RX_CONF.Reg, volatile.LoadUint32(&o.PARL_CLK_RX_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *PCR_Type) GetPARL_CLK_RX_CONF_PARL_CLK_RX_EN() uint32 {
	return (volatile.LoadUint32(&o.PARL_CLK_RX_CONF.Reg) & 0x40000) >> 18
}
func (o *PCR_Type) SetPARL_CLK_RX_CONF_PARL_RX_RST_EN(value uint32) {
	volatile.StoreUint32(&o.PARL_CLK_RX_CONF.Reg, volatile.LoadUint32(&o.PARL_CLK_RX_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *PCR_Type) GetPARL_CLK_RX_CONF_PARL_RX_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.PARL_CLK_RX_CONF.Reg) & 0x80000) >> 19
}

// PCR.PARL_CLK_TX_CONF: PARL_CLK_TX configuration register
func (o *PCR_Type) SetPARL_CLK_TX_CONF_PARL_CLK_TX_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.PARL_CLK_TX_CONF.Reg, volatile.LoadUint32(&o.PARL_CLK_TX_CONF.Reg)&^(0xffff)|value)
}
func (o *PCR_Type) GetPARL_CLK_TX_CONF_PARL_CLK_TX_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.PARL_CLK_TX_CONF.Reg) & 0xffff
}
func (o *PCR_Type) SetPARL_CLK_TX_CONF_PARL_CLK_TX_SEL(value uint32) {
	volatile.StoreUint32(&o.PARL_CLK_TX_CONF.Reg, volatile.LoadUint32(&o.PARL_CLK_TX_CONF.Reg)&^(0x30000)|value<<16)
}
func (o *PCR_Type) GetPARL_CLK_TX_CONF_PARL_CLK_TX_SEL() uint32 {
	return (volatile.LoadUint32(&o.PARL_CLK_TX_CONF.Reg) & 0x30000) >> 16
}
func (o *PCR_Type) SetPARL_CLK_TX_CONF_PARL_CLK_TX_EN(value uint32) {
	volatile.StoreUint32(&o.PARL_CLK_TX_CONF.Reg, volatile.LoadUint32(&o.PARL_CLK_TX_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *PCR_Type) GetPARL_CLK_TX_CONF_PARL_CLK_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.PARL_CLK_TX_CONF.Reg) & 0x40000) >> 18
}
func (o *PCR_Type) SetPARL_CLK_TX_CONF_PARL_TX_RST_EN(value uint32) {
	volatile.StoreUint32(&o.PARL_CLK_TX_CONF.Reg, volatile.LoadUint32(&o.PARL_CLK_TX_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *PCR_Type) GetPARL_CLK_TX_CONF_PARL_TX_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.PARL_CLK_TX_CONF.Reg) & 0x80000) >> 19
}

// PCR.PVT_MONITOR_CONF: PVT_MONITOR configuration register
func (o *PCR_Type) SetPVT_MONITOR_CONF_PVT_MONITOR_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PVT_MONITOR_CONF.Reg, volatile.LoadUint32(&o.PVT_MONITOR_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetPVT_MONITOR_CONF_PVT_MONITOR_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.PVT_MONITOR_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetPVT_MONITOR_CONF_PVT_MONITOR_RST_EN(value uint32) {
	volatile.StoreUint32(&o.PVT_MONITOR_CONF.Reg, volatile.LoadUint32(&o.PVT_MONITOR_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetPVT_MONITOR_CONF_PVT_MONITOR_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.PVT_MONITOR_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetPVT_MONITOR_CONF_PVT_MONITOR_SITE1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PVT_MONITOR_CONF.Reg, volatile.LoadUint32(&o.PVT_MONITOR_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetPVT_MONITOR_CONF_PVT_MONITOR_SITE1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PVT_MONITOR_CONF.Reg) & 0x4) >> 2
}
func (o *PCR_Type) SetPVT_MONITOR_CONF_PVT_MONITOR_SITE2_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PVT_MONITOR_CONF.Reg, volatile.LoadUint32(&o.PVT_MONITOR_CONF.Reg)&^(0x8)|value<<3)
}
func (o *PCR_Type) GetPVT_MONITOR_CONF_PVT_MONITOR_SITE2_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PVT_MONITOR_CONF.Reg) & 0x8) >> 3
}
func (o *PCR_Type) SetPVT_MONITOR_CONF_PVT_MONITOR_SITE3_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PVT_MONITOR_CONF.Reg, volatile.LoadUint32(&o.PVT_MONITOR_CONF.Reg)&^(0x10)|value<<4)
}
func (o *PCR_Type) GetPVT_MONITOR_CONF_PVT_MONITOR_SITE3_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PVT_MONITOR_CONF.Reg) & 0x10) >> 4
}

// PCR.PVT_MONITOR_FUNC_CLK_CONF: PVT_MONITOR function clock configuration register
func (o *PCR_Type) SetPVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.PVT_MONITOR_FUNC_CLK_CONF.Reg, volatile.LoadUint32(&o.PVT_MONITOR_FUNC_CLK_CONF.Reg)&^(0xf)|value)
}
func (o *PCR_Type) GetPVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.PVT_MONITOR_FUNC_CLK_CONF.Reg) & 0xf
}
func (o *PCR_Type) SetPVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.PVT_MONITOR_FUNC_CLK_CONF.Reg, volatile.LoadUint32(&o.PVT_MONITOR_FUNC_CLK_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *PCR_Type) GetPVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.PVT_MONITOR_FUNC_CLK_CONF.Reg) & 0x100000) >> 20
}
func (o *PCR_Type) SetPVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PVT_MONITOR_FUNC_CLK_CONF.Reg, volatile.LoadUint32(&o.PVT_MONITOR_FUNC_CLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetPVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PVT_MONITOR_FUNC_CLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.GDMA_CONF: GDMA configuration register
func (o *PCR_Type) SetGDMA_CONF_GDMA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.GDMA_CONF.Reg, volatile.LoadUint32(&o.GDMA_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetGDMA_CONF_GDMA_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.GDMA_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetGDMA_CONF_GDMA_RST_EN(value uint32) {
	volatile.StoreUint32(&o.GDMA_CONF.Reg, volatile.LoadUint32(&o.GDMA_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetGDMA_CONF_GDMA_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.GDMA_CONF.Reg) & 0x2) >> 1
}

// PCR.SPI2_CONF: SPI2 configuration register
func (o *PCR_Type) SetSPI2_CONF_SPI2_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SPI2_CONF.Reg, volatile.LoadUint32(&o.SPI2_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetSPI2_CONF_SPI2_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.SPI2_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetSPI2_CONF_SPI2_RST_EN(value uint32) {
	volatile.StoreUint32(&o.SPI2_CONF.Reg, volatile.LoadUint32(&o.SPI2_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetSPI2_CONF_SPI2_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI2_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetSPI2_CONF_SPI2_READY(value uint32) {
	volatile.StoreUint32(&o.SPI2_CONF.Reg, volatile.LoadUint32(&o.SPI2_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetSPI2_CONF_SPI2_READY() uint32 {
	return (volatile.LoadUint32(&o.SPI2_CONF.Reg) & 0x4) >> 2
}

// PCR.SPI2_CLKM_CONF: SPI2_CLKM configuration register
func (o *PCR_Type) SetSPI2_CLKM_CONF_SPI2_CLKM_SEL(value uint32) {
	volatile.StoreUint32(&o.SPI2_CLKM_CONF.Reg, volatile.LoadUint32(&o.SPI2_CLKM_CONF.Reg)&^(0x300000)|value<<20)
}
func (o *PCR_Type) GetSPI2_CLKM_CONF_SPI2_CLKM_SEL() uint32 {
	return (volatile.LoadUint32(&o.SPI2_CLKM_CONF.Reg) & 0x300000) >> 20
}
func (o *PCR_Type) SetSPI2_CLKM_CONF_SPI2_CLKM_EN(value uint32) {
	volatile.StoreUint32(&o.SPI2_CLKM_CONF.Reg, volatile.LoadUint32(&o.SPI2_CLKM_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetSPI2_CLKM_CONF_SPI2_CLKM_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI2_CLKM_CONF.Reg) & 0x400000) >> 22
}

// PCR.AES_CONF: AES configuration register
func (o *PCR_Type) SetAES_CONF_AES_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.AES_CONF.Reg, volatile.LoadUint32(&o.AES_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetAES_CONF_AES_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.AES_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetAES_CONF_AES_RST_EN(value uint32) {
	volatile.StoreUint32(&o.AES_CONF.Reg, volatile.LoadUint32(&o.AES_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetAES_CONF_AES_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.AES_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetAES_CONF_AES_READY(value uint32) {
	volatile.StoreUint32(&o.AES_CONF.Reg, volatile.LoadUint32(&o.AES_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetAES_CONF_AES_READY() uint32 {
	return (volatile.LoadUint32(&o.AES_CONF.Reg) & 0x4) >> 2
}

// PCR.SHA_CONF: SHA configuration register
func (o *PCR_Type) SetSHA_CONF_SHA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SHA_CONF.Reg, volatile.LoadUint32(&o.SHA_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetSHA_CONF_SHA_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.SHA_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetSHA_CONF_SHA_RST_EN(value uint32) {
	volatile.StoreUint32(&o.SHA_CONF.Reg, volatile.LoadUint32(&o.SHA_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetSHA_CONF_SHA_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.SHA_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetSHA_CONF_SHA_READY(value uint32) {
	volatile.StoreUint32(&o.SHA_CONF.Reg, volatile.LoadUint32(&o.SHA_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetSHA_CONF_SHA_READY() uint32 {
	return (volatile.LoadUint32(&o.SHA_CONF.Reg) & 0x4) >> 2
}

// PCR.RSA_CONF: RSA configuration register
func (o *PCR_Type) SetRSA_CONF_RSA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.RSA_CONF.Reg, volatile.LoadUint32(&o.RSA_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetRSA_CONF_RSA_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.RSA_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetRSA_CONF_RSA_RST_EN(value uint32) {
	volatile.StoreUint32(&o.RSA_CONF.Reg, volatile.LoadUint32(&o.RSA_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetRSA_CONF_RSA_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.RSA_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetRSA_CONF_RSA_READY(value uint32) {
	volatile.StoreUint32(&o.RSA_CONF.Reg, volatile.LoadUint32(&o.RSA_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetRSA_CONF_RSA_READY() uint32 {
	return (volatile.LoadUint32(&o.RSA_CONF.Reg) & 0x4) >> 2
}

// PCR.RSA_PD_CTRL: RSA power control register
func (o *PCR_Type) SetRSA_PD_CTRL_RSA_MEM_PD(value uint32) {
	volatile.StoreUint32(&o.RSA_PD_CTRL.Reg, volatile.LoadUint32(&o.RSA_PD_CTRL.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetRSA_PD_CTRL_RSA_MEM_PD() uint32 {
	return volatile.LoadUint32(&o.RSA_PD_CTRL.Reg) & 0x1
}
func (o *PCR_Type) SetRSA_PD_CTRL_RSA_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.RSA_PD_CTRL.Reg, volatile.LoadUint32(&o.RSA_PD_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetRSA_PD_CTRL_RSA_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.RSA_PD_CTRL.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetRSA_PD_CTRL_RSA_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.RSA_PD_CTRL.Reg, volatile.LoadUint32(&o.RSA_PD_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetRSA_PD_CTRL_RSA_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.RSA_PD_CTRL.Reg) & 0x4) >> 2
}

// PCR.ECC_CONF: ECC configuration register
func (o *PCR_Type) SetECC_CONF_ECC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.ECC_CONF.Reg, volatile.LoadUint32(&o.ECC_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetECC_CONF_ECC_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.ECC_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetECC_CONF_ECC_RST_EN(value uint32) {
	volatile.StoreUint32(&o.ECC_CONF.Reg, volatile.LoadUint32(&o.ECC_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetECC_CONF_ECC_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.ECC_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetECC_CONF_ECC_READY(value uint32) {
	volatile.StoreUint32(&o.ECC_CONF.Reg, volatile.LoadUint32(&o.ECC_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetECC_CONF_ECC_READY() uint32 {
	return (volatile.LoadUint32(&o.ECC_CONF.Reg) & 0x4) >> 2
}

// PCR.ECC_PD_CTRL: ECC power control register
func (o *PCR_Type) SetECC_PD_CTRL_ECC_MEM_PD(value uint32) {
	volatile.StoreUint32(&o.ECC_PD_CTRL.Reg, volatile.LoadUint32(&o.ECC_PD_CTRL.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetECC_PD_CTRL_ECC_MEM_PD() uint32 {
	return volatile.LoadUint32(&o.ECC_PD_CTRL.Reg) & 0x1
}
func (o *PCR_Type) SetECC_PD_CTRL_ECC_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.ECC_PD_CTRL.Reg, volatile.LoadUint32(&o.ECC_PD_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetECC_PD_CTRL_ECC_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.ECC_PD_CTRL.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetECC_PD_CTRL_ECC_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.ECC_PD_CTRL.Reg, volatile.LoadUint32(&o.ECC_PD_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetECC_PD_CTRL_ECC_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.ECC_PD_CTRL.Reg) & 0x4) >> 2
}

// PCR.DS_CONF: DS configuration register
func (o *PCR_Type) SetDS_CONF_DS_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.DS_CONF.Reg, volatile.LoadUint32(&o.DS_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetDS_CONF_DS_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.DS_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetDS_CONF_DS_RST_EN(value uint32) {
	volatile.StoreUint32(&o.DS_CONF.Reg, volatile.LoadUint32(&o.DS_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetDS_CONF_DS_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.DS_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetDS_CONF_DS_READY(value uint32) {
	volatile.StoreUint32(&o.DS_CONF.Reg, volatile.LoadUint32(&o.DS_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetDS_CONF_DS_READY() uint32 {
	return (volatile.LoadUint32(&o.DS_CONF.Reg) & 0x4) >> 2
}

// PCR.HMAC_CONF: HMAC configuration register
func (o *PCR_Type) SetHMAC_CONF_HMAC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.HMAC_CONF.Reg, volatile.LoadUint32(&o.HMAC_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetHMAC_CONF_HMAC_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.HMAC_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetHMAC_CONF_HMAC_RST_EN(value uint32) {
	volatile.StoreUint32(&o.HMAC_CONF.Reg, volatile.LoadUint32(&o.HMAC_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetHMAC_CONF_HMAC_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.HMAC_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetHMAC_CONF_HMAC_READY(value uint32) {
	volatile.StoreUint32(&o.HMAC_CONF.Reg, volatile.LoadUint32(&o.HMAC_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetHMAC_CONF_HMAC_READY() uint32 {
	return (volatile.LoadUint32(&o.HMAC_CONF.Reg) & 0x4) >> 2
}

// PCR.ECDSA_CONF: ECDSA configuration register
func (o *PCR_Type) SetECDSA_CONF_ECDSA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.ECDSA_CONF.Reg, volatile.LoadUint32(&o.ECDSA_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetECDSA_CONF_ECDSA_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.ECDSA_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetECDSA_CONF_ECDSA_RST_EN(value uint32) {
	volatile.StoreUint32(&o.ECDSA_CONF.Reg, volatile.LoadUint32(&o.ECDSA_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetECDSA_CONF_ECDSA_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.ECDSA_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetECDSA_CONF_ECDSA_READY(value uint32) {
	volatile.StoreUint32(&o.ECDSA_CONF.Reg, volatile.LoadUint32(&o.ECDSA_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetECDSA_CONF_ECDSA_READY() uint32 {
	return (volatile.LoadUint32(&o.ECDSA_CONF.Reg) & 0x4) >> 2
}

// PCR.IOMUX_CONF: IOMUX configuration register
func (o *PCR_Type) SetIOMUX_CONF_IOMUX_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.IOMUX_CONF.Reg, volatile.LoadUint32(&o.IOMUX_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetIOMUX_CONF_IOMUX_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.IOMUX_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetIOMUX_CONF_IOMUX_RST_EN(value uint32) {
	volatile.StoreUint32(&o.IOMUX_CONF.Reg, volatile.LoadUint32(&o.IOMUX_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetIOMUX_CONF_IOMUX_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.IOMUX_CONF.Reg) & 0x2) >> 1
}

// PCR.IOMUX_CLK_CONF: IOMUX_CLK configuration register
func (o *PCR_Type) SetIOMUX_CLK_CONF_IOMUX_FUNC_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.IOMUX_CLK_CONF.Reg, volatile.LoadUint32(&o.IOMUX_CLK_CONF.Reg)&^(0x300000)|value<<20)
}
func (o *PCR_Type) GetIOMUX_CLK_CONF_IOMUX_FUNC_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.IOMUX_CLK_CONF.Reg) & 0x300000) >> 20
}
func (o *PCR_Type) SetIOMUX_CLK_CONF_IOMUX_FUNC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.IOMUX_CLK_CONF.Reg, volatile.LoadUint32(&o.IOMUX_CLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *PCR_Type) GetIOMUX_CLK_CONF_IOMUX_FUNC_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.IOMUX_CLK_CONF.Reg) & 0x400000) >> 22
}

// PCR.MEM_MONITOR_CONF: MEM_MONITOR configuration register
func (o *PCR_Type) SetMEM_MONITOR_CONF_MEM_MONITOR_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.MEM_MONITOR_CONF.Reg, volatile.LoadUint32(&o.MEM_MONITOR_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetMEM_MONITOR_CONF_MEM_MONITOR_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.MEM_MONITOR_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetMEM_MONITOR_CONF_MEM_MONITOR_RST_EN(value uint32) {
	volatile.StoreUint32(&o.MEM_MONITOR_CONF.Reg, volatile.LoadUint32(&o.MEM_MONITOR_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetMEM_MONITOR_CONF_MEM_MONITOR_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.MEM_MONITOR_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetMEM_MONITOR_CONF_MEM_MONITOR_READY(value uint32) {
	volatile.StoreUint32(&o.MEM_MONITOR_CONF.Reg, volatile.LoadUint32(&o.MEM_MONITOR_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetMEM_MONITOR_CONF_MEM_MONITOR_READY() uint32 {
	return (volatile.LoadUint32(&o.MEM_MONITOR_CONF.Reg) & 0x4) >> 2
}

// PCR.REGDMA_CONF: REGDMA configuration register
func (o *PCR_Type) SetREGDMA_CONF_REGDMA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.REGDMA_CONF.Reg, volatile.LoadUint32(&o.REGDMA_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetREGDMA_CONF_REGDMA_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.REGDMA_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetREGDMA_CONF_REGDMA_RST_EN(value uint32) {
	volatile.StoreUint32(&o.REGDMA_CONF.Reg, volatile.LoadUint32(&o.REGDMA_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetREGDMA_CONF_REGDMA_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.REGDMA_CONF.Reg) & 0x2) >> 1
}

// PCR.TRACE_CONF: TRACE configuration register
func (o *PCR_Type) SetTRACE_CONF_TRACE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.TRACE_CONF.Reg, volatile.LoadUint32(&o.TRACE_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetTRACE_CONF_TRACE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.TRACE_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetTRACE_CONF_TRACE_RST_EN(value uint32) {
	volatile.StoreUint32(&o.TRACE_CONF.Reg, volatile.LoadUint32(&o.TRACE_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetTRACE_CONF_TRACE_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.TRACE_CONF.Reg) & 0x2) >> 1
}

// PCR.ASSIST_CONF: ASSIST configuration register
func (o *PCR_Type) SetASSIST_CONF_ASSIST_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.ASSIST_CONF.Reg, volatile.LoadUint32(&o.ASSIST_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetASSIST_CONF_ASSIST_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.ASSIST_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetASSIST_CONF_ASSIST_RST_EN(value uint32) {
	volatile.StoreUint32(&o.ASSIST_CONF.Reg, volatile.LoadUint32(&o.ASSIST_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetASSIST_CONF_ASSIST_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.ASSIST_CONF.Reg) & 0x2) >> 1
}

// PCR.CACHE_CONF: CACHE configuration register
func (o *PCR_Type) SetCACHE_CONF_CACHE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CACHE_CONF.Reg, volatile.LoadUint32(&o.CACHE_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetCACHE_CONF_CACHE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CACHE_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetCACHE_CONF_CACHE_RST_EN(value uint32) {
	volatile.StoreUint32(&o.CACHE_CONF.Reg, volatile.LoadUint32(&o.CACHE_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetCACHE_CONF_CACHE_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.CACHE_CONF.Reg) & 0x2) >> 1
}

// PCR.MODEM_CONF: MODEM_APB configuration register
func (o *PCR_Type) SetMODEM_CONF_MODEM_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.MODEM_CONF.Reg, volatile.LoadUint32(&o.MODEM_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetMODEM_CONF_MODEM_CLK_SEL() uint32 {
	return volatile.LoadUint32(&o.MODEM_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetMODEM_CONF_MODEM_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.MODEM_CONF.Reg, volatile.LoadUint32(&o.MODEM_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetMODEM_CONF_MODEM_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.MODEM_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetMODEM_CONF_MODEM_RST_EN(value uint32) {
	volatile.StoreUint32(&o.MODEM_CONF.Reg, volatile.LoadUint32(&o.MODEM_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetMODEM_CONF_MODEM_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.MODEM_CONF.Reg) & 0x4) >> 2
}

// PCR.TIMEOUT_CONF: TIMEOUT configuration register
func (o *PCR_Type) SetTIMEOUT_CONF_CPU_TIMEOUT_RST_EN(value uint32) {
	volatile.StoreUint32(&o.TIMEOUT_CONF.Reg, volatile.LoadUint32(&o.TIMEOUT_CONF.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetTIMEOUT_CONF_CPU_TIMEOUT_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUT_CONF.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetTIMEOUT_CONF_HP_TIMEOUT_RST_EN(value uint32) {
	volatile.StoreUint32(&o.TIMEOUT_CONF.Reg, volatile.LoadUint32(&o.TIMEOUT_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetTIMEOUT_CONF_HP_TIMEOUT_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUT_CONF.Reg) & 0x4) >> 2
}

// PCR.SYSCLK_CONF: SYSCLK configuration register
func (o *PCR_Type) SetSYSCLK_CONF_LS_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0xff)|value)
}
func (o *PCR_Type) GetSYSCLK_CONF_LS_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0xff
}
func (o *PCR_Type) SetSYSCLK_CONF_HS_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0xff00)|value<<8)
}
func (o *PCR_Type) GetSYSCLK_CONF_HS_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0xff00) >> 8
}
func (o *PCR_Type) SetSYSCLK_CONF_SOC_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0x30000)|value<<16)
}
func (o *PCR_Type) GetSYSCLK_CONF_SOC_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0x30000) >> 16
}
func (o *PCR_Type) SetSYSCLK_CONF_CLK_XTAL_FREQ(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0x7f000000)|value<<24)
}
func (o *PCR_Type) GetSYSCLK_CONF_CLK_XTAL_FREQ() uint32 {
	return (volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0x7f000000) >> 24
}

// PCR.CPU_WAITI_CONF: CPU_WAITI configuration register
func (o *PCR_Type) SetCPU_WAITI_CONF_CPUPERIOD_SEL(value uint32) {
	volatile.StoreUint32(&o.CPU_WAITI_CONF.Reg, volatile.LoadUint32(&o.CPU_WAITI_CONF.Reg)&^(0x3)|value)
}
func (o *PCR_Type) GetCPU_WAITI_CONF_CPUPERIOD_SEL() uint32 {
	return volatile.LoadUint32(&o.CPU_WAITI_CONF.Reg) & 0x3
}
func (o *PCR_Type) SetCPU_WAITI_CONF_PLL_FREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CPU_WAITI_CONF.Reg, volatile.LoadUint32(&o.CPU_WAITI_CONF.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetCPU_WAITI_CONF_PLL_FREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CPU_WAITI_CONF.Reg) & 0x4) >> 2
}
func (o *PCR_Type) SetCPU_WAITI_CONF_CPU_WAIT_MODE_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.CPU_WAITI_CONF.Reg, volatile.LoadUint32(&o.CPU_WAITI_CONF.Reg)&^(0x8)|value<<3)
}
func (o *PCR_Type) GetCPU_WAITI_CONF_CPU_WAIT_MODE_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.CPU_WAITI_CONF.Reg) & 0x8) >> 3
}
func (o *PCR_Type) SetCPU_WAITI_CONF_CPU_WAITI_DELAY_NUM(value uint32) {
	volatile.StoreUint32(&o.CPU_WAITI_CONF.Reg, volatile.LoadUint32(&o.CPU_WAITI_CONF.Reg)&^(0xf0)|value<<4)
}
func (o *PCR_Type) GetCPU_WAITI_CONF_CPU_WAITI_DELAY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CPU_WAITI_CONF.Reg) & 0xf0) >> 4
}

// PCR.CPU_FREQ_CONF: CPU_FREQ configuration register
func (o *PCR_Type) SetCPU_FREQ_CONF_CPU_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.CPU_FREQ_CONF.Reg, volatile.LoadUint32(&o.CPU_FREQ_CONF.Reg)&^(0xff)|value)
}
func (o *PCR_Type) GetCPU_FREQ_CONF_CPU_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.CPU_FREQ_CONF.Reg) & 0xff
}

// PCR.AHB_FREQ_CONF: AHB_FREQ configuration register
func (o *PCR_Type) SetAHB_FREQ_CONF_AHB_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.AHB_FREQ_CONF.Reg, volatile.LoadUint32(&o.AHB_FREQ_CONF.Reg)&^(0xff)|value)
}
func (o *PCR_Type) GetAHB_FREQ_CONF_AHB_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.AHB_FREQ_CONF.Reg) & 0xff
}

// PCR.APB_FREQ_CONF: APB_FREQ configuration register
func (o *PCR_Type) SetAPB_FREQ_CONF_APB_DECREASE_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.APB_FREQ_CONF.Reg, volatile.LoadUint32(&o.APB_FREQ_CONF.Reg)&^(0xff)|value)
}
func (o *PCR_Type) GetAPB_FREQ_CONF_APB_DECREASE_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.APB_FREQ_CONF.Reg) & 0xff
}
func (o *PCR_Type) SetAPB_FREQ_CONF_APB_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.APB_FREQ_CONF.Reg, volatile.LoadUint32(&o.APB_FREQ_CONF.Reg)&^(0xff00)|value<<8)
}
func (o *PCR_Type) GetAPB_FREQ_CONF_APB_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.APB_FREQ_CONF.Reg) & 0xff00) >> 8
}

// PCR.SYSCLK_FREQ_QUERY_0: SYSCLK frequency query 0 register
func (o *PCR_Type) SetSYSCLK_FREQ_QUERY_0_FOSC_FREQ(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_FREQ_QUERY_0.Reg, volatile.LoadUint32(&o.SYSCLK_FREQ_QUERY_0.Reg)&^(0xff)|value)
}
func (o *PCR_Type) GetSYSCLK_FREQ_QUERY_0_FOSC_FREQ() uint32 {
	return volatile.LoadUint32(&o.SYSCLK_FREQ_QUERY_0.Reg) & 0xff
}
func (o *PCR_Type) SetSYSCLK_FREQ_QUERY_0_PLL_FREQ(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_FREQ_QUERY_0.Reg, volatile.LoadUint32(&o.SYSCLK_FREQ_QUERY_0.Reg)&^(0x3ff00)|value<<8)
}
func (o *PCR_Type) GetSYSCLK_FREQ_QUERY_0_PLL_FREQ() uint32 {
	return (volatile.LoadUint32(&o.SYSCLK_FREQ_QUERY_0.Reg) & 0x3ff00) >> 8
}

// PCR.PLL_DIV_CLK_EN: SPLL DIV clock-gating configuration register
func (o *PCR_Type) SetPLL_DIV_CLK_EN_PLL_240M_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PLL_DIV_CLK_EN.Reg, volatile.LoadUint32(&o.PLL_DIV_CLK_EN.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetPLL_DIV_CLK_EN_PLL_240M_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.PLL_DIV_CLK_EN.Reg) & 0x1
}
func (o *PCR_Type) SetPLL_DIV_CLK_EN_PLL_160M_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PLL_DIV_CLK_EN.Reg, volatile.LoadUint32(&o.PLL_DIV_CLK_EN.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetPLL_DIV_CLK_EN_PLL_160M_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PLL_DIV_CLK_EN.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetPLL_DIV_CLK_EN_PLL_120M_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PLL_DIV_CLK_EN.Reg, volatile.LoadUint32(&o.PLL_DIV_CLK_EN.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetPLL_DIV_CLK_EN_PLL_120M_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PLL_DIV_CLK_EN.Reg) & 0x4) >> 2
}
func (o *PCR_Type) SetPLL_DIV_CLK_EN_PLL_80M_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PLL_DIV_CLK_EN.Reg, volatile.LoadUint32(&o.PLL_DIV_CLK_EN.Reg)&^(0x8)|value<<3)
}
func (o *PCR_Type) GetPLL_DIV_CLK_EN_PLL_80M_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PLL_DIV_CLK_EN.Reg) & 0x8) >> 3
}
func (o *PCR_Type) SetPLL_DIV_CLK_EN_PLL_48M_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PLL_DIV_CLK_EN.Reg, volatile.LoadUint32(&o.PLL_DIV_CLK_EN.Reg)&^(0x10)|value<<4)
}
func (o *PCR_Type) GetPLL_DIV_CLK_EN_PLL_48M_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PLL_DIV_CLK_EN.Reg) & 0x10) >> 4
}
func (o *PCR_Type) SetPLL_DIV_CLK_EN_PLL_40M_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PLL_DIV_CLK_EN.Reg, volatile.LoadUint32(&o.PLL_DIV_CLK_EN.Reg)&^(0x20)|value<<5)
}
func (o *PCR_Type) GetPLL_DIV_CLK_EN_PLL_40M_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PLL_DIV_CLK_EN.Reg) & 0x20) >> 5
}

// PCR.CTRL_CLK_OUT_EN: CLK_OUT_EN configuration register
func (o *PCR_Type) SetCTRL_CLK_OUT_EN_CLK8_OEN(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetCTRL_CLK_OUT_EN_CLK8_OEN() uint32 {
	return volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg) & 0x1
}
func (o *PCR_Type) SetCTRL_CLK_OUT_EN_CLK16_OEN(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetCTRL_CLK_OUT_EN_CLK16_OEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg) & 0x2) >> 1
}
func (o *PCR_Type) SetCTRL_CLK_OUT_EN_CLK32_OEN(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg)&^(0x4)|value<<2)
}
func (o *PCR_Type) GetCTRL_CLK_OUT_EN_CLK32_OEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg) & 0x4) >> 2
}
func (o *PCR_Type) SetCTRL_CLK_OUT_EN_CLK_ADC_INF_OEN(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg)&^(0x8)|value<<3)
}
func (o *PCR_Type) GetCTRL_CLK_OUT_EN_CLK_ADC_INF_OEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg) & 0x8) >> 3
}
func (o *PCR_Type) SetCTRL_CLK_OUT_EN_CLK_DFM_INF_OEN(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg)&^(0x10)|value<<4)
}
func (o *PCR_Type) GetCTRL_CLK_OUT_EN_CLK_DFM_INF_OEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg) & 0x10) >> 4
}
func (o *PCR_Type) SetCTRL_CLK_OUT_EN_CLK_SDM_MOD_OEN(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg)&^(0x20)|value<<5)
}
func (o *PCR_Type) GetCTRL_CLK_OUT_EN_CLK_SDM_MOD_OEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg) & 0x20) >> 5
}
func (o *PCR_Type) SetCTRL_CLK_OUT_EN_CLK_XTAL_OEN(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg)&^(0x40)|value<<6)
}
func (o *PCR_Type) GetCTRL_CLK_OUT_EN_CLK_XTAL_OEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLK_OUT_EN.Reg) & 0x40) >> 6
}

// PCR.CTRL_TICK_CONF: TICK configuration register
func (o *PCR_Type) SetCTRL_TICK_CONF_XTAL_TICK_NUM(value uint32) {
	volatile.StoreUint32(&o.CTRL_TICK_CONF.Reg, volatile.LoadUint32(&o.CTRL_TICK_CONF.Reg)&^(0xff)|value)
}
func (o *PCR_Type) GetCTRL_TICK_CONF_XTAL_TICK_NUM() uint32 {
	return volatile.LoadUint32(&o.CTRL_TICK_CONF.Reg) & 0xff
}
func (o *PCR_Type) SetCTRL_TICK_CONF_FOSC_TICK_NUM(value uint32) {
	volatile.StoreUint32(&o.CTRL_TICK_CONF.Reg, volatile.LoadUint32(&o.CTRL_TICK_CONF.Reg)&^(0xff00)|value<<8)
}
func (o *PCR_Type) GetCTRL_TICK_CONF_FOSC_TICK_NUM() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TICK_CONF.Reg) & 0xff00) >> 8
}
func (o *PCR_Type) SetCTRL_TICK_CONF_TICK_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL_TICK_CONF.Reg, volatile.LoadUint32(&o.CTRL_TICK_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *PCR_Type) GetCTRL_TICK_CONF_TICK_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TICK_CONF.Reg) & 0x10000) >> 16
}
func (o *PCR_Type) SetCTRL_TICK_CONF_RST_TICK_CNT(value uint32) {
	volatile.StoreUint32(&o.CTRL_TICK_CONF.Reg, volatile.LoadUint32(&o.CTRL_TICK_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *PCR_Type) GetCTRL_TICK_CONF_RST_TICK_CNT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TICK_CONF.Reg) & 0x20000) >> 17
}

// PCR.CTRL_32K_CONF: 32KHz clock configuration register
func (o *PCR_Type) SetCTRL_32K_CONF_CLK_32K_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL_32K_CONF.Reg, volatile.LoadUint32(&o.CTRL_32K_CONF.Reg)&^(0x3)|value)
}
func (o *PCR_Type) GetCTRL_32K_CONF_CLK_32K_SEL() uint32 {
	return volatile.LoadUint32(&o.CTRL_32K_CONF.Reg) & 0x3
}
func (o *PCR_Type) SetCTRL_32K_CONF__32K_MODEM_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL_32K_CONF.Reg, volatile.LoadUint32(&o.CTRL_32K_CONF.Reg)&^(0xc)|value<<2)
}
func (o *PCR_Type) GetCTRL_32K_CONF__32K_MODEM_SEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL_32K_CONF.Reg) & 0xc) >> 2
}

// PCR.SRAM_POWER_CONF_0: HP SRAM/ROM configuration register
func (o *PCR_Type) SetSRAM_POWER_CONF_0_ROM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.SRAM_POWER_CONF_0.Reg, volatile.LoadUint32(&o.SRAM_POWER_CONF_0.Reg)&^(0x6000)|value<<13)
}
func (o *PCR_Type) GetSRAM_POWER_CONF_0_ROM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.SRAM_POWER_CONF_0.Reg) & 0x6000) >> 13
}
func (o *PCR_Type) SetSRAM_POWER_CONF_0_ROM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.SRAM_POWER_CONF_0.Reg, volatile.LoadUint32(&o.SRAM_POWER_CONF_0.Reg)&^(0x18000)|value<<15)
}
func (o *PCR_Type) GetSRAM_POWER_CONF_0_ROM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.SRAM_POWER_CONF_0.Reg) & 0x18000) >> 15
}
func (o *PCR_Type) SetSRAM_POWER_CONF_0_ROM_CLKGATE_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.SRAM_POWER_CONF_0.Reg, volatile.LoadUint32(&o.SRAM_POWER_CONF_0.Reg)&^(0x60000)|value<<17)
}
func (o *PCR_Type) GetSRAM_POWER_CONF_0_ROM_CLKGATE_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.SRAM_POWER_CONF_0.Reg) & 0x60000) >> 17
}

// PCR.SRAM_POWER_CONF_1: HP SRAM/ROM configuration register
func (o *PCR_Type) SetSRAM_POWER_CONF_1_SRAM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.SRAM_POWER_CONF_1.Reg, volatile.LoadUint32(&o.SRAM_POWER_CONF_1.Reg)&^(0x1f)|value)
}
func (o *PCR_Type) GetSRAM_POWER_CONF_1_SRAM_FORCE_PU() uint32 {
	return volatile.LoadUint32(&o.SRAM_POWER_CONF_1.Reg) & 0x1f
}
func (o *PCR_Type) SetSRAM_POWER_CONF_1_SRAM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.SRAM_POWER_CONF_1.Reg, volatile.LoadUint32(&o.SRAM_POWER_CONF_1.Reg)&^(0x7c00)|value<<10)
}
func (o *PCR_Type) GetSRAM_POWER_CONF_1_SRAM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.SRAM_POWER_CONF_1.Reg) & 0x7c00) >> 10
}
func (o *PCR_Type) SetSRAM_POWER_CONF_1_SRAM_CLKGATE_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.SRAM_POWER_CONF_1.Reg, volatile.LoadUint32(&o.SRAM_POWER_CONF_1.Reg)&^(0x3e000000)|value<<25)
}
func (o *PCR_Type) GetSRAM_POWER_CONF_1_SRAM_CLKGATE_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.SRAM_POWER_CONF_1.Reg) & 0x3e000000) >> 25
}

// PCR.SEC_CONF: xxxx
func (o *PCR_Type) SetSEC_CONF_SEC_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.SEC_CONF.Reg, volatile.LoadUint32(&o.SEC_CONF.Reg)&^(0x3)|value)
}
func (o *PCR_Type) GetSEC_CONF_SEC_CLK_SEL() uint32 {
	return volatile.LoadUint32(&o.SEC_CONF.Reg) & 0x3
}

// PCR.ADC_INV_PHASE_CONF: xxxx
func (o *PCR_Type) SetADC_INV_PHASE_CONF_CLK_ADC_INV_PHASE_ENA(value uint32) {
	volatile.StoreUint32(&o.ADC_INV_PHASE_CONF.Reg, volatile.LoadUint32(&o.ADC_INV_PHASE_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetADC_INV_PHASE_CONF_CLK_ADC_INV_PHASE_ENA() uint32 {
	return volatile.LoadUint32(&o.ADC_INV_PHASE_CONF.Reg) & 0x1
}

// PCR.SDM_INV_PHASE_CONF: xxxx
func (o *PCR_Type) SetSDM_INV_PHASE_CONF_CLK_SDM_INV_PHASE_ENA(value uint32) {
	volatile.StoreUint32(&o.SDM_INV_PHASE_CONF.Reg, volatile.LoadUint32(&o.SDM_INV_PHASE_CONF.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetSDM_INV_PHASE_CONF_CLK_SDM_INV_PHASE_ENA() uint32 {
	return volatile.LoadUint32(&o.SDM_INV_PHASE_CONF.Reg) & 0x1
}
func (o *PCR_Type) SetSDM_INV_PHASE_CONF_CLK_SDM_INV_PHASE_SEL(value uint32) {
	volatile.StoreUint32(&o.SDM_INV_PHASE_CONF.Reg, volatile.LoadUint32(&o.SDM_INV_PHASE_CONF.Reg)&^(0xe)|value<<1)
}
func (o *PCR_Type) GetSDM_INV_PHASE_CONF_CLK_SDM_INV_PHASE_SEL() uint32 {
	return (volatile.LoadUint32(&o.SDM_INV_PHASE_CONF.Reg) & 0xe) >> 1
}

// PCR.BUS_CLK_UPDATE: xxxx
func (o *PCR_Type) SetBUS_CLK_UPDATE_BUS_CLOCK_UPDATE(value uint32) {
	volatile.StoreUint32(&o.BUS_CLK_UPDATE.Reg, volatile.LoadUint32(&o.BUS_CLK_UPDATE.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetBUS_CLK_UPDATE_BUS_CLOCK_UPDATE() uint32 {
	return volatile.LoadUint32(&o.BUS_CLK_UPDATE.Reg) & 0x1
}

// PCR.SAR_CLK_DIV: xxxx
func (o *PCR_Type) SetSAR_CLK_DIV_SAR2_CLK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.SAR_CLK_DIV.Reg, volatile.LoadUint32(&o.SAR_CLK_DIV.Reg)&^(0xff)|value)
}
func (o *PCR_Type) GetSAR_CLK_DIV_SAR2_CLK_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.SAR_CLK_DIV.Reg) & 0xff
}
func (o *PCR_Type) SetSAR_CLK_DIV_SAR1_CLK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.SAR_CLK_DIV.Reg, volatile.LoadUint32(&o.SAR_CLK_DIV.Reg)&^(0xff00)|value<<8)
}
func (o *PCR_Type) GetSAR_CLK_DIV_SAR1_CLK_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.SAR_CLK_DIV.Reg) & 0xff00) >> 8
}

// PCR.PWDET_SAR_CLK_CONF: xxxx
func (o *PCR_Type) SetPWDET_SAR_CLK_CONF_PWDET_SAR_CLK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.PWDET_SAR_CLK_CONF.Reg, volatile.LoadUint32(&o.PWDET_SAR_CLK_CONF.Reg)&^(0xff)|value)
}
func (o *PCR_Type) GetPWDET_SAR_CLK_CONF_PWDET_SAR_CLK_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.PWDET_SAR_CLK_CONF.Reg) & 0xff
}
func (o *PCR_Type) SetPWDET_SAR_CLK_CONF_PWDET_SAR_READER_EN(value uint32) {
	volatile.StoreUint32(&o.PWDET_SAR_CLK_CONF.Reg, volatile.LoadUint32(&o.PWDET_SAR_CLK_CONF.Reg)&^(0x100)|value<<8)
}
func (o *PCR_Type) GetPWDET_SAR_CLK_CONF_PWDET_SAR_READER_EN() uint32 {
	return (volatile.LoadUint32(&o.PWDET_SAR_CLK_CONF.Reg) & 0x100) >> 8
}

// PCR.RESET_EVENT_BYPASS: reset event bypass backdoor configuration register
func (o *PCR_Type) SetRESET_EVENT_BYPASS_APM(value uint32) {
	volatile.StoreUint32(&o.RESET_EVENT_BYPASS.Reg, volatile.LoadUint32(&o.RESET_EVENT_BYPASS.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetRESET_EVENT_BYPASS_APM() uint32 {
	return volatile.LoadUint32(&o.RESET_EVENT_BYPASS.Reg) & 0x1
}
func (o *PCR_Type) SetRESET_EVENT_BYPASS(value uint32) {
	volatile.StoreUint32(&o.RESET_EVENT_BYPASS.Reg, volatile.LoadUint32(&o.RESET_EVENT_BYPASS.Reg)&^(0x2)|value<<1)
}
func (o *PCR_Type) GetRESET_EVENT_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.RESET_EVENT_BYPASS.Reg) & 0x2) >> 1
}

// PCR.FPGA_DEBUG: fpga debug register
func (o *PCR_Type) SetFPGA_DEBUG(value uint32) {
	volatile.StoreUint32(&o.FPGA_DEBUG.Reg, value)
}
func (o *PCR_Type) GetFPGA_DEBUG() uint32 {
	return volatile.LoadUint32(&o.FPGA_DEBUG.Reg)
}

// PCR.CLOCK_GATE: PCR clock gating configure register
func (o *PCR_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *PCR_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// PCR.DATE: Date register.
func (o *PCR_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *PCR_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// PMU Peripheral
type PMU_Type struct {
	HP_ACTIVE_DIG_POWER      volatile.Register32 // 0x0
	HP_ACTIVE_ICG_HP_FUNC    volatile.Register32 // 0x4
	HP_ACTIVE_ICG_HP_APB     volatile.Register32 // 0x8
	HP_ACTIVE_ICG_MODEM      volatile.Register32 // 0xC
	HP_ACTIVE_HP_SYS_CNTL    volatile.Register32 // 0x10
	HP_ACTIVE_HP_CK_POWER    volatile.Register32 // 0x14
	HP_ACTIVE_BIAS           volatile.Register32 // 0x18
	HP_ACTIVE_BACKUP         volatile.Register32 // 0x1C
	HP_ACTIVE_BACKUP_CLK     volatile.Register32 // 0x20
	HP_ACTIVE_SYSCLK         volatile.Register32 // 0x24
	HP_ACTIVE_HP_REGULATOR0  volatile.Register32 // 0x28
	HP_ACTIVE_HP_REGULATOR1  volatile.Register32 // 0x2C
	HP_ACTIVE_XTAL           volatile.Register32 // 0x30
	HP_MODEM_DIG_POWER       volatile.Register32 // 0x34
	HP_MODEM_ICG_HP_FUNC     volatile.Register32 // 0x38
	HP_MODEM_ICG_HP_APB      volatile.Register32 // 0x3C
	HP_MODEM_ICG_MODEM       volatile.Register32 // 0x40
	HP_MODEM_HP_SYS_CNTL     volatile.Register32 // 0x44
	HP_MODEM_HP_CK_POWER     volatile.Register32 // 0x48
	HP_MODEM_BIAS            volatile.Register32 // 0x4C
	HP_MODEM_BACKUP          volatile.Register32 // 0x50
	HP_MODEM_BACKUP_CLK      volatile.Register32 // 0x54
	HP_MODEM_SYSCLK          volatile.Register32 // 0x58
	HP_MODEM_HP_REGULATOR0   volatile.Register32 // 0x5C
	HP_MODEM_HP_REGULATOR1   volatile.Register32 // 0x60
	HP_MODEM_XTAL            volatile.Register32 // 0x64
	HP_SLEEP_DIG_POWER       volatile.Register32 // 0x68
	HP_SLEEP_ICG_HP_FUNC     volatile.Register32 // 0x6C
	HP_SLEEP_ICG_HP_APB      volatile.Register32 // 0x70
	HP_SLEEP_ICG_MODEM       volatile.Register32 // 0x74
	HP_SLEEP_HP_SYS_CNTL     volatile.Register32 // 0x78
	HP_SLEEP_HP_CK_POWER     volatile.Register32 // 0x7C
	HP_SLEEP_BIAS            volatile.Register32 // 0x80
	HP_SLEEP_BACKUP          volatile.Register32 // 0x84
	HP_SLEEP_BACKUP_CLK      volatile.Register32 // 0x88
	HP_SLEEP_SYSCLK          volatile.Register32 // 0x8C
	HP_SLEEP_HP_REGULATOR0   volatile.Register32 // 0x90
	HP_SLEEP_HP_REGULATOR1   volatile.Register32 // 0x94
	HP_SLEEP_XTAL            volatile.Register32 // 0x98
	HP_SLEEP_LP_REGULATOR0   volatile.Register32 // 0x9C
	HP_SLEEP_LP_REGULATOR1   volatile.Register32 // 0xA0
	HP_SLEEP_LP_DCDC_RESERVE volatile.Register32 // 0xA4
	HP_SLEEP_LP_DIG_POWER    volatile.Register32 // 0xA8
	HP_SLEEP_LP_CK_POWER     volatile.Register32 // 0xAC
	LP_SLEEP_LP_BIAS_RESERVE volatile.Register32 // 0xB0
	LP_SLEEP_LP_REGULATOR0   volatile.Register32 // 0xB4
	LP_SLEEP_LP_REGULATOR1   volatile.Register32 // 0xB8
	LP_SLEEP_XTAL            volatile.Register32 // 0xBC
	LP_SLEEP_LP_DIG_POWER    volatile.Register32 // 0xC0
	LP_SLEEP_LP_CK_POWER     volatile.Register32 // 0xC4
	LP_SLEEP_BIAS            volatile.Register32 // 0xC8
	IMM_HP_CK_POWER          volatile.Register32 // 0xCC
	IMM_SLEEP_SYSCLK         volatile.Register32 // 0xD0
	IMM_HP_FUNC_ICG          volatile.Register32 // 0xD4
	IMM_HP_APB_ICG           volatile.Register32 // 0xD8
	IMM_MODEM_ICG            volatile.Register32 // 0xDC
	IMM_LP_ICG               volatile.Register32 // 0xE0
	IMM_PAD_HOLD_ALL         volatile.Register32 // 0xE4
	IMM_I2C_ISO              volatile.Register32 // 0xE8
	POWER_WAIT_TIMER0        volatile.Register32 // 0xEC
	POWER_WAIT_TIMER1        volatile.Register32 // 0xF0
	POWER_PD_TOP_CNTL        volatile.Register32 // 0xF4
	POWER_PD_HPAON_CNTL      volatile.Register32 // 0xF8
	POWER_PD_HPCPU_CNTL      volatile.Register32 // 0xFC
	POWER_PD_HPPERI_RESERVE  volatile.Register32 // 0x100
	POWER_PD_HPWIFI_CNTL     volatile.Register32 // 0x104
	POWER_PD_LPPERI_CNTL     volatile.Register32 // 0x108
	POWER_PD_MEM_CNTL        volatile.Register32 // 0x10C
	POWER_PD_MEM_MASK        volatile.Register32 // 0x110
	POWER_HP_PAD             volatile.Register32 // 0x114
	POWER_VDD_SPI_CNTL       volatile.Register32 // 0x118
	POWER_CK_WAIT_CNTL       volatile.Register32 // 0x11C
	SLP_WAKEUP_CNTL0         volatile.Register32 // 0x120
	SLP_WAKEUP_CNTL1         volatile.Register32 // 0x124
	SLP_WAKEUP_CNTL2         volatile.Register32 // 0x128
	SLP_WAKEUP_CNTL3         volatile.Register32 // 0x12C
	SLP_WAKEUP_CNTL4         volatile.Register32 // 0x130
	SLP_WAKEUP_CNTL5         volatile.Register32 // 0x134
	SLP_WAKEUP_CNTL6         volatile.Register32 // 0x138
	SLP_WAKEUP_CNTL7         volatile.Register32 // 0x13C
	SLP_WAKEUP_STATUS0       volatile.Register32 // 0x140
	SLP_WAKEUP_STATUS1       volatile.Register32 // 0x144
	HP_CK_POWERON            volatile.Register32 // 0x148
	HP_CK_CNTL               volatile.Register32 // 0x14C
	POR_STATUS               volatile.Register32 // 0x150
	RF_PWC                   volatile.Register32 // 0x154
	VDDBAT_CFG               volatile.Register32 // 0x158
	BACKUP_CFG               volatile.Register32 // 0x15C
	INT_RAW                  volatile.Register32 // 0x160
	HP_INT_ST                volatile.Register32 // 0x164
	HP_INT_ENA               volatile.Register32 // 0x168
	HP_INT_CLR               volatile.Register32 // 0x16C
	LP_INT_RAW               volatile.Register32 // 0x170
	LP_INT_ST                volatile.Register32 // 0x174
	LP_INT_ENA               volatile.Register32 // 0x178
	LP_INT_CLR               volatile.Register32 // 0x17C
	LP_CPU_PWR0              volatile.Register32 // 0x180
	LP_CPU_PWR1              volatile.Register32 // 0x184
	HP_LP_CPU_COMM           volatile.Register32 // 0x188
	HP_REGULATOR_CFG         volatile.Register32 // 0x18C
	MAIN_STATE               volatile.Register32 // 0x190
	PWR_STATE                volatile.Register32 // 0x194
	CLK_STATE0               volatile.Register32 // 0x198
	CLK_STATE1               volatile.Register32 // 0x19C
	CLK_STATE2               volatile.Register32 // 0x1A0
	VDD_SPI_STATUS           volatile.Register32 // 0x1A4
	_                        [596]byte
	DATE                     volatile.Register32 // 0x3FC
}

// PMU.HP_ACTIVE_DIG_POWER: need_des
func (o *PMU_Type) SetHP_ACTIVE_DIG_POWER_HP_ACTIVE_VDD_SPI_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg)&^(0x200000)|value<<21)
}
func (o *PMU_Type) GetHP_ACTIVE_DIG_POWER_HP_ACTIVE_VDD_SPI_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg) & 0x200000) >> 21
}
func (o *PMU_Type) SetHP_ACTIVE_DIG_POWER_HP_ACTIVE_HP_MEM_DSLP(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg)&^(0x400000)|value<<22)
}
func (o *PMU_Type) GetHP_ACTIVE_DIG_POWER_HP_ACTIVE_HP_MEM_DSLP() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg) & 0x400000) >> 22
}
func (o *PMU_Type) SetHP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_MEM_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg)&^(0x7800000)|value<<23)
}
func (o *PMU_Type) GetHP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_MEM_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg) & 0x7800000) >> 23
}
func (o *PMU_Type) SetHP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_WIFI_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_WIFI_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_CPU_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_CPU_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_AON_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_AON_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetHP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_TOP_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_TOP_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_DIG_POWER.Reg) & 0x80000000) >> 31
}

// PMU.HP_ACTIVE_ICG_HP_FUNC: need_des
func (o *PMU_Type) SetHP_ACTIVE_ICG_HP_FUNC(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_ICG_HP_FUNC.Reg, value)
}
func (o *PMU_Type) GetHP_ACTIVE_ICG_HP_FUNC() uint32 {
	return volatile.LoadUint32(&o.HP_ACTIVE_ICG_HP_FUNC.Reg)
}

// PMU.HP_ACTIVE_ICG_HP_APB: need_des
func (o *PMU_Type) SetHP_ACTIVE_ICG_HP_APB(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_ICG_HP_APB.Reg, value)
}
func (o *PMU_Type) GetHP_ACTIVE_ICG_HP_APB() uint32 {
	return volatile.LoadUint32(&o.HP_ACTIVE_ICG_HP_APB.Reg)
}

// PMU.HP_ACTIVE_ICG_MODEM: need_des
func (o *PMU_Type) SetHP_ACTIVE_ICG_MODEM_HP_ACTIVE_DIG_ICG_MODEM_CODE(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_ICG_MODEM.Reg, volatile.LoadUint32(&o.HP_ACTIVE_ICG_MODEM.Reg)&^(0xc0000000)|value<<30)
}
func (o *PMU_Type) GetHP_ACTIVE_ICG_MODEM_HP_ACTIVE_DIG_ICG_MODEM_CODE() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_ICG_MODEM.Reg) & 0xc0000000) >> 30
}

// PMU.HP_ACTIVE_HP_SYS_CNTL: need_des
func (o *PMU_Type) SetHP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_UART_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg)&^(0x1000000)|value<<24)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_UART_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg) & 0x1000000) >> 24
}
func (o *PMU_Type) SetHP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_LP_PAD_HOLD_ALL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_LP_PAD_HOLD_ALL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetHP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_HP_PAD_HOLD_ALL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_HP_PAD_HOLD_ALL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetHP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_PAD_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_PAD_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_PAUSE_WDT(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_PAUSE_WDT() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetHP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_CPU_STALL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_CPU_STALL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_SYS_CNTL.Reg) & 0x20000000) >> 29
}

// PMU.HP_ACTIVE_HP_CK_POWER: need_des
func (o *PMU_Type) SetHP_ACTIVE_HP_CK_POWER_HP_ACTIVE_I2C_ISO_EN(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_CK_POWER_HP_ACTIVE_I2C_ISO_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetHP_ACTIVE_HP_CK_POWER_HP_ACTIVE_I2C_RETENTION(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_CK_POWER_HP_ACTIVE_I2C_RETENTION() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BB_I2C(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BB_I2C() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetHP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BBPLL_I2C(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BBPLL_I2C() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BBPLL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BBPLL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_CK_POWER.Reg) & 0x40000000) >> 30
}

// PMU.HP_ACTIVE_BIAS: need_des
func (o *PMU_Type) SetHP_ACTIVE_BIAS_HP_ACTIVE_XPD_TRX(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BIAS.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BIAS.Reg)&^(0x1000000)|value<<24)
}
func (o *PMU_Type) GetHP_ACTIVE_BIAS_HP_ACTIVE_XPD_TRX() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BIAS.Reg) & 0x1000000) >> 24
}
func (o *PMU_Type) SetHP_ACTIVE_BIAS_HP_ACTIVE_XPD_BIAS(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BIAS.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BIAS.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetHP_ACTIVE_BIAS_HP_ACTIVE_XPD_BIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BIAS.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetHP_ACTIVE_BIAS_HP_ACTIVE_PD_CUR(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BIAS.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BIAS.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_ACTIVE_BIAS_HP_ACTIVE_PD_CUR() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BIAS.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetHP_ACTIVE_BIAS_SLEEP(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BIAS.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BIAS.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_ACTIVE_BIAS_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BIAS.Reg) & 0x80000000) >> 31
}

// PMU.HP_ACTIVE_BACKUP: need_des
func (o *PMU_Type) SetHP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_MODEM_CLK_CODE(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BACKUP.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg)&^(0x30)|value<<4)
}
func (o *PMU_Type) GetHP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_MODEM_CLK_CODE() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg) & 0x30) >> 4
}
func (o *PMU_Type) SetHP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_MODEM_CLK_CODE(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BACKUP.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg)&^(0xc0)|value<<6)
}
func (o *PMU_Type) GetHP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_MODEM_CLK_CODE() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg) & 0xc0) >> 6
}
func (o *PMU_Type) SetHP_ACTIVE_BACKUP_HP_ACTIVE_RETENTION_MODE(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BACKUP.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg)&^(0x400)|value<<10)
}
func (o *PMU_Type) GetHP_ACTIVE_BACKUP_HP_ACTIVE_RETENTION_MODE() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg) & 0x400) >> 10
}
func (o *PMU_Type) SetHP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_RETENTION_EN(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BACKUP.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg)&^(0x800)|value<<11)
}
func (o *PMU_Type) GetHP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_RETENTION_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg) & 0x800) >> 11
}
func (o *PMU_Type) SetHP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_RETENTION_EN(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BACKUP.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg)&^(0x1000)|value<<12)
}
func (o *PMU_Type) GetHP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_RETENTION_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg) & 0x1000) >> 12
}
func (o *PMU_Type) SetHP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BACKUP.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg)&^(0xc000)|value<<14)
}
func (o *PMU_Type) GetHP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg) & 0xc000) >> 14
}
func (o *PMU_Type) SetHP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BACKUP.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg)&^(0x30000)|value<<16)
}
func (o *PMU_Type) GetHP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg) & 0x30000) >> 16
}
func (o *PMU_Type) SetHP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_MODE(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BACKUP.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg)&^(0x700000)|value<<20)
}
func (o *PMU_Type) GetHP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_MODE() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg) & 0x700000) >> 20
}
func (o *PMU_Type) SetHP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_MODE(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BACKUP.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg)&^(0x3800000)|value<<23)
}
func (o *PMU_Type) GetHP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_MODE() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg) & 0x3800000) >> 23
}
func (o *PMU_Type) SetHP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_EN(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BACKUP.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_EN(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BACKUP.Reg, volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_BACKUP.Reg) & 0x40000000) >> 30
}

// PMU.HP_ACTIVE_BACKUP_CLK: need_des
func (o *PMU_Type) SetHP_ACTIVE_BACKUP_CLK(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_BACKUP_CLK.Reg, value)
}
func (o *PMU_Type) GetHP_ACTIVE_BACKUP_CLK() uint32 {
	return volatile.LoadUint32(&o.HP_ACTIVE_BACKUP_CLK.Reg)
}

// PMU.HP_ACTIVE_SYSCLK: need_des
func (o *PMU_Type) SetHP_ACTIVE_SYSCLK_HP_ACTIVE_DIG_SYS_CLK_NO_DIV(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_SYSCLK.Reg, volatile.LoadUint32(&o.HP_ACTIVE_SYSCLK.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetHP_ACTIVE_SYSCLK_HP_ACTIVE_DIG_SYS_CLK_NO_DIV() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_SYSCLK.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetHP_ACTIVE_SYSCLK_HP_ACTIVE_ICG_SYS_CLOCK_EN(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_SYSCLK.Reg, volatile.LoadUint32(&o.HP_ACTIVE_SYSCLK.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_ACTIVE_SYSCLK_HP_ACTIVE_ICG_SYS_CLOCK_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_SYSCLK.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_ACTIVE_SYSCLK_HP_ACTIVE_SYS_CLK_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_SYSCLK.Reg, volatile.LoadUint32(&o.HP_ACTIVE_SYSCLK.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetHP_ACTIVE_SYSCLK_HP_ACTIVE_SYS_CLK_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_SYSCLK.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetHP_ACTIVE_SYSCLK_HP_ACTIVE_ICG_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_SYSCLK.Reg, volatile.LoadUint32(&o.HP_ACTIVE_SYSCLK.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_ACTIVE_SYSCLK_HP_ACTIVE_ICG_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_SYSCLK.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_ACTIVE_SYSCLK_HP_ACTIVE_DIG_SYS_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_SYSCLK.Reg, volatile.LoadUint32(&o.HP_ACTIVE_SYSCLK.Reg)&^(0xc0000000)|value<<30)
}
func (o *PMU_Type) GetHP_ACTIVE_SYSCLK_HP_ACTIVE_DIG_SYS_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_SYSCLK.Reg) & 0xc0000000) >> 30
}

// PMU.HP_ACTIVE_HP_REGULATOR0: need_des
func (o *PMU_Type) SetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_POWER_DET_BYPASS(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_POWER_DET_BYPASS() uint32 {
	return volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg) & 0x1
}
func (o *PMU_Type) SetHP_ACTIVE_HP_REGULATOR0_LP_DBIAS_VOL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg)&^(0x1f0)|value<<4)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_REGULATOR0_LP_DBIAS_VOL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg) & 0x1f0) >> 4
}
func (o *PMU_Type) SetHP_ACTIVE_HP_REGULATOR0_HP_DBIAS_VOL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg)&^(0x3e00)|value<<9)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_REGULATOR0_HP_DBIAS_VOL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg) & 0x3e00) >> 9
}
func (o *PMU_Type) SetHP_ACTIVE_HP_REGULATOR0_DIG_REGULATOR0_DBIAS_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg)&^(0x4000)|value<<14)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_REGULATOR0_DIG_REGULATOR0_DBIAS_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg) & 0x4000) >> 14
}
func (o *PMU_Type) SetHP_ACTIVE_HP_REGULATOR0_DIG_DBIAS_INIT(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg)&^(0x8000)|value<<15)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_REGULATOR0_DIG_DBIAS_INIT() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg) & 0x8000) >> 15
}
func (o *PMU_Type) SetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_XPD(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg)&^(0x40000)|value<<18)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_XPD() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg) & 0x40000) >> 18
}
func (o *PMU_Type) SetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_MEM_DBIAS(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg)&^(0x780000)|value<<19)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_MEM_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg) & 0x780000) >> 19
}
func (o *PMU_Type) SetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_DBIAS(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg)&^(0x7800000)|value<<23)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg) & 0x7800000) >> 23
}
func (o *PMU_Type) SetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_DBIAS(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg)&^(0xf8000000)|value<<27)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR0.Reg) & 0xf8000000) >> 27
}

// PMU.HP_ACTIVE_HP_REGULATOR1: need_des
func (o *PMU_Type) SetHP_ACTIVE_HP_REGULATOR1_HP_ACTIVE_HP_REGULATOR_DRV_B(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_HP_REGULATOR1.Reg, volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR1.Reg)&^(0xffffff00)|value<<8)
}
func (o *PMU_Type) GetHP_ACTIVE_HP_REGULATOR1_HP_ACTIVE_HP_REGULATOR_DRV_B() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_HP_REGULATOR1.Reg) & 0xffffff00) >> 8
}

// PMU.HP_ACTIVE_XTAL: need_des
func (o *PMU_Type) SetHP_ACTIVE_XTAL_HP_ACTIVE_XPD_XTAL(value uint32) {
	volatile.StoreUint32(&o.HP_ACTIVE_XTAL.Reg, volatile.LoadUint32(&o.HP_ACTIVE_XTAL.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_ACTIVE_XTAL_HP_ACTIVE_XPD_XTAL() uint32 {
	return (volatile.LoadUint32(&o.HP_ACTIVE_XTAL.Reg) & 0x80000000) >> 31
}

// PMU.HP_MODEM_DIG_POWER: need_des
func (o *PMU_Type) SetHP_MODEM_DIG_POWER_HP_MODEM_VDD_SPI_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg)&^(0x200000)|value<<21)
}
func (o *PMU_Type) GetHP_MODEM_DIG_POWER_HP_MODEM_VDD_SPI_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg) & 0x200000) >> 21
}
func (o *PMU_Type) SetHP_MODEM_DIG_POWER_HP_MODEM_HP_MEM_DSLP(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg)&^(0x400000)|value<<22)
}
func (o *PMU_Type) GetHP_MODEM_DIG_POWER_HP_MODEM_HP_MEM_DSLP() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg) & 0x400000) >> 22
}
func (o *PMU_Type) SetHP_MODEM_DIG_POWER_HP_MODEM_PD_HP_MEM_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg)&^(0x7800000)|value<<23)
}
func (o *PMU_Type) GetHP_MODEM_DIG_POWER_HP_MODEM_PD_HP_MEM_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg) & 0x7800000) >> 23
}
func (o *PMU_Type) SetHP_MODEM_DIG_POWER_HP_MODEM_PD_HP_WIFI_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_MODEM_DIG_POWER_HP_MODEM_PD_HP_WIFI_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_MODEM_DIG_POWER_HP_MODEM_PD_HP_CPU_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_MODEM_DIG_POWER_HP_MODEM_PD_HP_CPU_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_MODEM_DIG_POWER_HP_MODEM_PD_HP_AON_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_MODEM_DIG_POWER_HP_MODEM_PD_HP_AON_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetHP_MODEM_DIG_POWER_HP_MODEM_PD_TOP_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_MODEM_DIG_POWER_HP_MODEM_PD_TOP_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_DIG_POWER.Reg) & 0x80000000) >> 31
}

// PMU.HP_MODEM_ICG_HP_FUNC: need_des
func (o *PMU_Type) SetHP_MODEM_ICG_HP_FUNC(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_ICG_HP_FUNC.Reg, value)
}
func (o *PMU_Type) GetHP_MODEM_ICG_HP_FUNC() uint32 {
	return volatile.LoadUint32(&o.HP_MODEM_ICG_HP_FUNC.Reg)
}

// PMU.HP_MODEM_ICG_HP_APB: need_des
func (o *PMU_Type) SetHP_MODEM_ICG_HP_APB(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_ICG_HP_APB.Reg, value)
}
func (o *PMU_Type) GetHP_MODEM_ICG_HP_APB() uint32 {
	return volatile.LoadUint32(&o.HP_MODEM_ICG_HP_APB.Reg)
}

// PMU.HP_MODEM_ICG_MODEM: need_des
func (o *PMU_Type) SetHP_MODEM_ICG_MODEM_HP_MODEM_DIG_ICG_MODEM_CODE(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_ICG_MODEM.Reg, volatile.LoadUint32(&o.HP_MODEM_ICG_MODEM.Reg)&^(0xc0000000)|value<<30)
}
func (o *PMU_Type) GetHP_MODEM_ICG_MODEM_HP_MODEM_DIG_ICG_MODEM_CODE() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_ICG_MODEM.Reg) & 0xc0000000) >> 30
}

// PMU.HP_MODEM_HP_SYS_CNTL: need_des
func (o *PMU_Type) SetHP_MODEM_HP_SYS_CNTL_HP_MODEM_UART_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg)&^(0x1000000)|value<<24)
}
func (o *PMU_Type) GetHP_MODEM_HP_SYS_CNTL_HP_MODEM_UART_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg) & 0x1000000) >> 24
}
func (o *PMU_Type) SetHP_MODEM_HP_SYS_CNTL_HP_MODEM_LP_PAD_HOLD_ALL(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetHP_MODEM_HP_SYS_CNTL_HP_MODEM_LP_PAD_HOLD_ALL() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetHP_MODEM_HP_SYS_CNTL_HP_MODEM_HP_PAD_HOLD_ALL(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetHP_MODEM_HP_SYS_CNTL_HP_MODEM_HP_PAD_HOLD_ALL() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetHP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_PAD_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_PAD_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_PAUSE_WDT(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetHP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_PAUSE_WDT() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetHP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_CPU_STALL(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_CPU_STALL() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_SYS_CNTL.Reg) & 0x20000000) >> 29
}

// PMU.HP_MODEM_HP_CK_POWER: need_des
func (o *PMU_Type) SetHP_MODEM_HP_CK_POWER_HP_MODEM_I2C_ISO_EN(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_CK_POWER.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetHP_MODEM_HP_CK_POWER_HP_MODEM_I2C_ISO_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_CK_POWER.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetHP_MODEM_HP_CK_POWER_HP_MODEM_I2C_RETENTION(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_CK_POWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_MODEM_HP_CK_POWER_HP_MODEM_I2C_RETENTION() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_CK_POWER.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BB_I2C(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_CK_POWER.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetHP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BB_I2C() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_CK_POWER.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetHP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BBPLL_I2C(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_CK_POWER.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BBPLL_I2C() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_CK_POWER.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BBPLL(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_CK_POWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BBPLL() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_CK_POWER.Reg) & 0x40000000) >> 30
}

// PMU.HP_MODEM_BIAS: need_des
func (o *PMU_Type) SetHP_MODEM_BIAS_HP_MODEM_XPD_TRX(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_BIAS.Reg, volatile.LoadUint32(&o.HP_MODEM_BIAS.Reg)&^(0x1000000)|value<<24)
}
func (o *PMU_Type) GetHP_MODEM_BIAS_HP_MODEM_XPD_TRX() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_BIAS.Reg) & 0x1000000) >> 24
}
func (o *PMU_Type) SetHP_MODEM_BIAS_HP_MODEM_XPD_BIAS(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_BIAS.Reg, volatile.LoadUint32(&o.HP_MODEM_BIAS.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetHP_MODEM_BIAS_HP_MODEM_XPD_BIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_BIAS.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetHP_MODEM_BIAS_HP_MODEM_PD_CUR(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_BIAS.Reg, volatile.LoadUint32(&o.HP_MODEM_BIAS.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_MODEM_BIAS_HP_MODEM_PD_CUR() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_BIAS.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetHP_MODEM_BIAS_SLEEP(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_BIAS.Reg, volatile.LoadUint32(&o.HP_MODEM_BIAS.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_MODEM_BIAS_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_BIAS.Reg) & 0x80000000) >> 31
}

// PMU.HP_MODEM_BACKUP: need_des
func (o *PMU_Type) SetHP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_MODEM_CLK_CODE(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_BACKUP.Reg, volatile.LoadUint32(&o.HP_MODEM_BACKUP.Reg)&^(0x30)|value<<4)
}
func (o *PMU_Type) GetHP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_MODEM_CLK_CODE() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_BACKUP.Reg) & 0x30) >> 4
}
func (o *PMU_Type) SetHP_MODEM_BACKUP_HP_MODEM_RETENTION_MODE(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_BACKUP.Reg, volatile.LoadUint32(&o.HP_MODEM_BACKUP.Reg)&^(0x400)|value<<10)
}
func (o *PMU_Type) GetHP_MODEM_BACKUP_HP_MODEM_RETENTION_MODE() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_BACKUP.Reg) & 0x400) >> 10
}
func (o *PMU_Type) SetHP_MODEM_BACKUP_HP_SLEEP2MODEM_RETENTION_EN(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_BACKUP.Reg, volatile.LoadUint32(&o.HP_MODEM_BACKUP.Reg)&^(0x800)|value<<11)
}
func (o *PMU_Type) GetHP_MODEM_BACKUP_HP_SLEEP2MODEM_RETENTION_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_BACKUP.Reg) & 0x800) >> 11
}
func (o *PMU_Type) SetHP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_BACKUP.Reg, volatile.LoadUint32(&o.HP_MODEM_BACKUP.Reg)&^(0xc000)|value<<14)
}
func (o *PMU_Type) GetHP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_BACKUP.Reg) & 0xc000) >> 14
}
func (o *PMU_Type) SetHP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_MODE(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_BACKUP.Reg, volatile.LoadUint32(&o.HP_MODEM_BACKUP.Reg)&^(0x700000)|value<<20)
}
func (o *PMU_Type) GetHP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_MODE() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_BACKUP.Reg) & 0x700000) >> 20
}
func (o *PMU_Type) SetHP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_EN(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_BACKUP.Reg, volatile.LoadUint32(&o.HP_MODEM_BACKUP.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_BACKUP.Reg) & 0x20000000) >> 29
}

// PMU.HP_MODEM_BACKUP_CLK: need_des
func (o *PMU_Type) SetHP_MODEM_BACKUP_CLK(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_BACKUP_CLK.Reg, value)
}
func (o *PMU_Type) GetHP_MODEM_BACKUP_CLK() uint32 {
	return volatile.LoadUint32(&o.HP_MODEM_BACKUP_CLK.Reg)
}

// PMU.HP_MODEM_SYSCLK: need_des
func (o *PMU_Type) SetHP_MODEM_SYSCLK_HP_MODEM_DIG_SYS_CLK_NO_DIV(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_SYSCLK.Reg, volatile.LoadUint32(&o.HP_MODEM_SYSCLK.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetHP_MODEM_SYSCLK_HP_MODEM_DIG_SYS_CLK_NO_DIV() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_SYSCLK.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetHP_MODEM_SYSCLK_HP_MODEM_ICG_SYS_CLOCK_EN(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_SYSCLK.Reg, volatile.LoadUint32(&o.HP_MODEM_SYSCLK.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_MODEM_SYSCLK_HP_MODEM_ICG_SYS_CLOCK_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_SYSCLK.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_MODEM_SYSCLK_HP_MODEM_SYS_CLK_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_SYSCLK.Reg, volatile.LoadUint32(&o.HP_MODEM_SYSCLK.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetHP_MODEM_SYSCLK_HP_MODEM_SYS_CLK_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_SYSCLK.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetHP_MODEM_SYSCLK_HP_MODEM_ICG_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_SYSCLK.Reg, volatile.LoadUint32(&o.HP_MODEM_SYSCLK.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_MODEM_SYSCLK_HP_MODEM_ICG_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_SYSCLK.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_MODEM_SYSCLK_HP_MODEM_DIG_SYS_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_SYSCLK.Reg, volatile.LoadUint32(&o.HP_MODEM_SYSCLK.Reg)&^(0xc0000000)|value<<30)
}
func (o *PMU_Type) GetHP_MODEM_SYSCLK_HP_MODEM_DIG_SYS_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_SYSCLK.Reg) & 0xc0000000) >> 30
}

// PMU.HP_MODEM_HP_REGULATOR0: need_des
func (o *PMU_Type) SetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_POWER_DET_BYPASS(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_POWER_DET_BYPASS() uint32 {
	return volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg) & 0x1
}
func (o *PMU_Type) SetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_MEM_XPD(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_MEM_XPD() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_XPD(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg)&^(0x40000)|value<<18)
}
func (o *PMU_Type) GetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_XPD() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg) & 0x40000) >> 18
}
func (o *PMU_Type) SetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_MEM_DBIAS(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg)&^(0x780000)|value<<19)
}
func (o *PMU_Type) GetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_MEM_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg) & 0x780000) >> 19
}
func (o *PMU_Type) SetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_LOGIC_DBIAS(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg)&^(0x7800000)|value<<23)
}
func (o *PMU_Type) GetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_LOGIC_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg) & 0x7800000) >> 23
}
func (o *PMU_Type) SetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_DBIAS(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg)&^(0xf8000000)|value<<27)
}
func (o *PMU_Type) GetHP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR0.Reg) & 0xf8000000) >> 27
}

// PMU.HP_MODEM_HP_REGULATOR1: need_des
func (o *PMU_Type) SetHP_MODEM_HP_REGULATOR1_HP_MODEM_HP_REGULATOR_DRV_B(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_HP_REGULATOR1.Reg, volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR1.Reg)&^(0xffffff00)|value<<8)
}
func (o *PMU_Type) GetHP_MODEM_HP_REGULATOR1_HP_MODEM_HP_REGULATOR_DRV_B() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_HP_REGULATOR1.Reg) & 0xffffff00) >> 8
}

// PMU.HP_MODEM_XTAL: need_des
func (o *PMU_Type) SetHP_MODEM_XTAL_HP_MODEM_XPD_XTAL(value uint32) {
	volatile.StoreUint32(&o.HP_MODEM_XTAL.Reg, volatile.LoadUint32(&o.HP_MODEM_XTAL.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_MODEM_XTAL_HP_MODEM_XPD_XTAL() uint32 {
	return (volatile.LoadUint32(&o.HP_MODEM_XTAL.Reg) & 0x80000000) >> 31
}

// PMU.HP_SLEEP_DIG_POWER: need_des
func (o *PMU_Type) SetHP_SLEEP_DIG_POWER_HP_SLEEP_VDD_SPI_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg)&^(0x200000)|value<<21)
}
func (o *PMU_Type) GetHP_SLEEP_DIG_POWER_HP_SLEEP_VDD_SPI_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg) & 0x200000) >> 21
}
func (o *PMU_Type) SetHP_SLEEP_DIG_POWER_HP_SLEEP_HP_MEM_DSLP(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg)&^(0x400000)|value<<22)
}
func (o *PMU_Type) GetHP_SLEEP_DIG_POWER_HP_SLEEP_HP_MEM_DSLP() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg) & 0x400000) >> 22
}
func (o *PMU_Type) SetHP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_MEM_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg)&^(0x7800000)|value<<23)
}
func (o *PMU_Type) GetHP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_MEM_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg) & 0x7800000) >> 23
}
func (o *PMU_Type) SetHP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_WIFI_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_WIFI_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_CPU_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_CPU_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_AON_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_AON_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetHP_SLEEP_DIG_POWER_HP_SLEEP_PD_TOP_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_SLEEP_DIG_POWER_HP_SLEEP_PD_TOP_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_DIG_POWER.Reg) & 0x80000000) >> 31
}

// PMU.HP_SLEEP_ICG_HP_FUNC: need_des
func (o *PMU_Type) SetHP_SLEEP_ICG_HP_FUNC(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_ICG_HP_FUNC.Reg, value)
}
func (o *PMU_Type) GetHP_SLEEP_ICG_HP_FUNC() uint32 {
	return volatile.LoadUint32(&o.HP_SLEEP_ICG_HP_FUNC.Reg)
}

// PMU.HP_SLEEP_ICG_HP_APB: need_des
func (o *PMU_Type) SetHP_SLEEP_ICG_HP_APB(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_ICG_HP_APB.Reg, value)
}
func (o *PMU_Type) GetHP_SLEEP_ICG_HP_APB() uint32 {
	return volatile.LoadUint32(&o.HP_SLEEP_ICG_HP_APB.Reg)
}

// PMU.HP_SLEEP_ICG_MODEM: need_des
func (o *PMU_Type) SetHP_SLEEP_ICG_MODEM_HP_SLEEP_DIG_ICG_MODEM_CODE(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_ICG_MODEM.Reg, volatile.LoadUint32(&o.HP_SLEEP_ICG_MODEM.Reg)&^(0xc0000000)|value<<30)
}
func (o *PMU_Type) GetHP_SLEEP_ICG_MODEM_HP_SLEEP_DIG_ICG_MODEM_CODE() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_ICG_MODEM.Reg) & 0xc0000000) >> 30
}

// PMU.HP_SLEEP_HP_SYS_CNTL: need_des
func (o *PMU_Type) SetHP_SLEEP_HP_SYS_CNTL_HP_SLEEP_UART_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg)&^(0x1000000)|value<<24)
}
func (o *PMU_Type) GetHP_SLEEP_HP_SYS_CNTL_HP_SLEEP_UART_WAKEUP_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg) & 0x1000000) >> 24
}
func (o *PMU_Type) SetHP_SLEEP_HP_SYS_CNTL_HP_SLEEP_LP_PAD_HOLD_ALL(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetHP_SLEEP_HP_SYS_CNTL_HP_SLEEP_LP_PAD_HOLD_ALL() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetHP_SLEEP_HP_SYS_CNTL_HP_SLEEP_HP_PAD_HOLD_ALL(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetHP_SLEEP_HP_SYS_CNTL_HP_SLEEP_HP_PAD_HOLD_ALL() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetHP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_PAD_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_PAD_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_PAUSE_WDT(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetHP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_PAUSE_WDT() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetHP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_CPU_STALL(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_CPU_STALL() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_SYS_CNTL.Reg) & 0x20000000) >> 29
}

// PMU.HP_SLEEP_HP_CK_POWER: need_des
func (o *PMU_Type) SetHP_SLEEP_HP_CK_POWER_HP_SLEEP_I2C_ISO_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_CK_POWER.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetHP_SLEEP_HP_CK_POWER_HP_SLEEP_I2C_ISO_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_CK_POWER.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetHP_SLEEP_HP_CK_POWER_HP_SLEEP_I2C_RETENTION(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_CK_POWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_SLEEP_HP_CK_POWER_HP_SLEEP_I2C_RETENTION() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_CK_POWER.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BB_I2C(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_CK_POWER.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetHP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BB_I2C() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_CK_POWER.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetHP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BBPLL_I2C(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_CK_POWER.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BBPLL_I2C() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_CK_POWER.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BBPLL(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_CK_POWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BBPLL() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_CK_POWER.Reg) & 0x40000000) >> 30
}

// PMU.HP_SLEEP_BIAS: need_des
func (o *PMU_Type) SetHP_SLEEP_BIAS_HP_SLEEP_XPD_TRX(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BIAS.Reg, volatile.LoadUint32(&o.HP_SLEEP_BIAS.Reg)&^(0x1000000)|value<<24)
}
func (o *PMU_Type) GetHP_SLEEP_BIAS_HP_SLEEP_XPD_TRX() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BIAS.Reg) & 0x1000000) >> 24
}
func (o *PMU_Type) SetHP_SLEEP_BIAS_HP_SLEEP_XPD_BIAS(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BIAS.Reg, volatile.LoadUint32(&o.HP_SLEEP_BIAS.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetHP_SLEEP_BIAS_HP_SLEEP_XPD_BIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BIAS.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetHP_SLEEP_BIAS_HP_SLEEP_PD_CUR(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BIAS.Reg, volatile.LoadUint32(&o.HP_SLEEP_BIAS.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_SLEEP_BIAS_HP_SLEEP_PD_CUR() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BIAS.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetHP_SLEEP_BIAS_SLEEP(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BIAS.Reg, volatile.LoadUint32(&o.HP_SLEEP_BIAS.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_SLEEP_BIAS_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BIAS.Reg) & 0x80000000) >> 31
}

// PMU.HP_SLEEP_BACKUP: need_des
func (o *PMU_Type) SetHP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_MODEM_CLK_CODE(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BACKUP.Reg, volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg)&^(0xc0)|value<<6)
}
func (o *PMU_Type) GetHP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_MODEM_CLK_CODE() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg) & 0xc0) >> 6
}
func (o *PMU_Type) SetHP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_MODEM_CLK_CODE(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BACKUP.Reg, volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg)&^(0x300)|value<<8)
}
func (o *PMU_Type) GetHP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_MODEM_CLK_CODE() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg) & 0x300) >> 8
}
func (o *PMU_Type) SetHP_SLEEP_BACKUP_HP_SLEEP_RETENTION_MODE(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BACKUP.Reg, volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg)&^(0x400)|value<<10)
}
func (o *PMU_Type) GetHP_SLEEP_BACKUP_HP_SLEEP_RETENTION_MODE() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg) & 0x400) >> 10
}
func (o *PMU_Type) SetHP_SLEEP_BACKUP_HP_MODEM2SLEEP_RETENTION_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BACKUP.Reg, volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg)&^(0x1000)|value<<12)
}
func (o *PMU_Type) GetHP_SLEEP_BACKUP_HP_MODEM2SLEEP_RETENTION_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg) & 0x1000) >> 12
}
func (o *PMU_Type) SetHP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_RETENTION_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BACKUP.Reg, volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg)&^(0x2000)|value<<13)
}
func (o *PMU_Type) GetHP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_RETENTION_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg) & 0x2000) >> 13
}
func (o *PMU_Type) SetHP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BACKUP.Reg, volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg)&^(0x30000)|value<<16)
}
func (o *PMU_Type) GetHP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg) & 0x30000) >> 16
}
func (o *PMU_Type) SetHP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BACKUP.Reg, volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg)&^(0xc0000)|value<<18)
}
func (o *PMU_Type) GetHP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg) & 0xc0000) >> 18
}
func (o *PMU_Type) SetHP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_MODE(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BACKUP.Reg, volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg)&^(0x3800000)|value<<23)
}
func (o *PMU_Type) GetHP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_MODE() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg) & 0x3800000) >> 23
}
func (o *PMU_Type) SetHP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_MODE(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BACKUP.Reg, volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg)&^(0x1c000000)|value<<26)
}
func (o *PMU_Type) GetHP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_MODE() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg) & 0x1c000000) >> 26
}
func (o *PMU_Type) SetHP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BACKUP.Reg, volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetHP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BACKUP.Reg, volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_BACKUP.Reg) & 0x80000000) >> 31
}

// PMU.HP_SLEEP_BACKUP_CLK: need_des
func (o *PMU_Type) SetHP_SLEEP_BACKUP_CLK(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_BACKUP_CLK.Reg, value)
}
func (o *PMU_Type) GetHP_SLEEP_BACKUP_CLK() uint32 {
	return volatile.LoadUint32(&o.HP_SLEEP_BACKUP_CLK.Reg)
}

// PMU.HP_SLEEP_SYSCLK: need_des
func (o *PMU_Type) SetHP_SLEEP_SYSCLK_HP_SLEEP_DIG_SYS_CLK_NO_DIV(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_SYSCLK.Reg, volatile.LoadUint32(&o.HP_SLEEP_SYSCLK.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetHP_SLEEP_SYSCLK_HP_SLEEP_DIG_SYS_CLK_NO_DIV() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_SYSCLK.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetHP_SLEEP_SYSCLK_HP_SLEEP_ICG_SYS_CLOCK_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_SYSCLK.Reg, volatile.LoadUint32(&o.HP_SLEEP_SYSCLK.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_SLEEP_SYSCLK_HP_SLEEP_ICG_SYS_CLOCK_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_SYSCLK.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_SLEEP_SYSCLK_HP_SLEEP_SYS_CLK_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_SYSCLK.Reg, volatile.LoadUint32(&o.HP_SLEEP_SYSCLK.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetHP_SLEEP_SYSCLK_HP_SLEEP_SYS_CLK_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_SYSCLK.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetHP_SLEEP_SYSCLK_HP_SLEEP_ICG_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_SYSCLK.Reg, volatile.LoadUint32(&o.HP_SLEEP_SYSCLK.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_SLEEP_SYSCLK_HP_SLEEP_ICG_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_SYSCLK.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_SLEEP_SYSCLK_HP_SLEEP_DIG_SYS_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_SYSCLK.Reg, volatile.LoadUint32(&o.HP_SLEEP_SYSCLK.Reg)&^(0xc0000000)|value<<30)
}
func (o *PMU_Type) GetHP_SLEEP_SYSCLK_HP_SLEEP_DIG_SYS_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_SYSCLK.Reg) & 0xc0000000) >> 30
}

// PMU.HP_SLEEP_HP_REGULATOR0: need_des
func (o *PMU_Type) SetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_POWER_DET_BYPASS(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_POWER_DET_BYPASS() uint32 {
	return volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg) & 0x1
}
func (o *PMU_Type) SetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_XPD(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg)&^(0x40000)|value<<18)
}
func (o *PMU_Type) GetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_XPD() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg) & 0x40000) >> 18
}
func (o *PMU_Type) SetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_MEM_DBIAS(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg)&^(0x780000)|value<<19)
}
func (o *PMU_Type) GetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_MEM_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg) & 0x780000) >> 19
}
func (o *PMU_Type) SetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_DBIAS(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg)&^(0x7800000)|value<<23)
}
func (o *PMU_Type) GetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg) & 0x7800000) >> 23
}
func (o *PMU_Type) SetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_DBIAS(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg)&^(0xf8000000)|value<<27)
}
func (o *PMU_Type) GetHP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR0.Reg) & 0xf8000000) >> 27
}

// PMU.HP_SLEEP_HP_REGULATOR1: need_des
func (o *PMU_Type) SetHP_SLEEP_HP_REGULATOR1_HP_SLEEP_HP_REGULATOR_DRV_B(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_HP_REGULATOR1.Reg, volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR1.Reg)&^(0xffffff00)|value<<8)
}
func (o *PMU_Type) GetHP_SLEEP_HP_REGULATOR1_HP_SLEEP_HP_REGULATOR_DRV_B() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_HP_REGULATOR1.Reg) & 0xffffff00) >> 8
}

// PMU.HP_SLEEP_XTAL: need_des
func (o *PMU_Type) SetHP_SLEEP_XTAL_HP_SLEEP_XPD_XTAL(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_XTAL.Reg, volatile.LoadUint32(&o.HP_SLEEP_XTAL.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_SLEEP_XTAL_HP_SLEEP_XPD_XTAL() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_XTAL.Reg) & 0x80000000) >> 31
}

// PMU.HP_SLEEP_LP_REGULATOR0: need_des
func (o *PMU_Type) SetHP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_SLP_XPD(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_REGULATOR0.Reg)&^(0x200000)|value<<21)
}
func (o *PMU_Type) GetHP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_SLP_XPD() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_REGULATOR0.Reg) & 0x200000) >> 21
}
func (o *PMU_Type) SetHP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_XPD(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_REGULATOR0.Reg)&^(0x400000)|value<<22)
}
func (o *PMU_Type) GetHP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_XPD() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_REGULATOR0.Reg) & 0x400000) >> 22
}
func (o *PMU_Type) SetHP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_SLP_DBIAS(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_REGULATOR0.Reg)&^(0x7800000)|value<<23)
}
func (o *PMU_Type) GetHP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_SLP_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_REGULATOR0.Reg) & 0x7800000) >> 23
}
func (o *PMU_Type) SetHP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_DBIAS(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_REGULATOR0.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_REGULATOR0.Reg)&^(0xf8000000)|value<<27)
}
func (o *PMU_Type) GetHP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_REGULATOR0.Reg) & 0xf8000000) >> 27
}

// PMU.HP_SLEEP_LP_REGULATOR1: need_des
func (o *PMU_Type) SetHP_SLEEP_LP_REGULATOR1_HP_SLEEP_LP_REGULATOR_DRV_B(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_REGULATOR1.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_REGULATOR1.Reg)&^(0xf0000000)|value<<28)
}
func (o *PMU_Type) GetHP_SLEEP_LP_REGULATOR1_HP_SLEEP_LP_REGULATOR_DRV_B() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_REGULATOR1.Reg) & 0xf0000000) >> 28
}

// PMU.HP_SLEEP_LP_DCDC_RESERVE: need_des
func (o *PMU_Type) SetHP_SLEEP_LP_DCDC_RESERVE(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_DCDC_RESERVE.Reg, value)
}
func (o *PMU_Type) GetHP_SLEEP_LP_DCDC_RESERVE() uint32 {
	return volatile.LoadUint32(&o.HP_SLEEP_LP_DCDC_RESERVE.Reg)
}

// PMU.HP_SLEEP_LP_DIG_POWER: need_des
func (o *PMU_Type) SetHP_SLEEP_LP_DIG_POWER_HP_SLEEP_BOD_SOURCE_SEL(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_DIG_POWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_SLEEP_LP_DIG_POWER_HP_SLEEP_BOD_SOURCE_SEL() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_DIG_POWER.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_SLEEP_LP_DIG_POWER_HP_SLEEP_VDDBAT_MODE(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_DIG_POWER.Reg)&^(0x30000000)|value<<28)
}
func (o *PMU_Type) GetHP_SLEEP_LP_DIG_POWER_HP_SLEEP_VDDBAT_MODE() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_DIG_POWER.Reg) & 0x30000000) >> 28
}
func (o *PMU_Type) SetHP_SLEEP_LP_DIG_POWER_HP_SLEEP_LP_MEM_DSLP(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_DIG_POWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_SLEEP_LP_DIG_POWER_HP_SLEEP_LP_MEM_DSLP() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_DIG_POWER.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetHP_SLEEP_LP_DIG_POWER_HP_SLEEP_PD_LP_PERI_PD_EN(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_DIG_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_DIG_POWER.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_SLEEP_LP_DIG_POWER_HP_SLEEP_PD_LP_PERI_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_DIG_POWER.Reg) & 0x80000000) >> 31
}

// PMU.HP_SLEEP_LP_CK_POWER: need_des
func (o *PMU_Type) SetHP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_LPPLL(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_CK_POWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_LPPLL() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_CK_POWER.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_XTAL32K(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_CK_POWER.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetHP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_XTAL32K() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_CK_POWER.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetHP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_RC32K(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_CK_POWER.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_RC32K() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_CK_POWER.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_FOSC_CLK(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_CK_POWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_FOSC_CLK() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_CK_POWER.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetHP_SLEEP_LP_CK_POWER_HP_SLEEP_PD_OSC_CLK(value uint32) {
	volatile.StoreUint32(&o.HP_SLEEP_LP_CK_POWER.Reg, volatile.LoadUint32(&o.HP_SLEEP_LP_CK_POWER.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_SLEEP_LP_CK_POWER_HP_SLEEP_PD_OSC_CLK() uint32 {
	return (volatile.LoadUint32(&o.HP_SLEEP_LP_CK_POWER.Reg) & 0x80000000) >> 31
}

// PMU.LP_SLEEP_LP_BIAS_RESERVE: need_des
func (o *PMU_Type) SetLP_SLEEP_LP_BIAS_RESERVE(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_BIAS_RESERVE.Reg, value)
}
func (o *PMU_Type) GetLP_SLEEP_LP_BIAS_RESERVE() uint32 {
	return volatile.LoadUint32(&o.LP_SLEEP_LP_BIAS_RESERVE.Reg)
}

// PMU.LP_SLEEP_LP_REGULATOR0: need_des
func (o *PMU_Type) SetLP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_SLP_XPD(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_REGULATOR0.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_REGULATOR0.Reg)&^(0x200000)|value<<21)
}
func (o *PMU_Type) GetLP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_SLP_XPD() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_REGULATOR0.Reg) & 0x200000) >> 21
}
func (o *PMU_Type) SetLP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_XPD(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_REGULATOR0.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_REGULATOR0.Reg)&^(0x400000)|value<<22)
}
func (o *PMU_Type) GetLP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_XPD() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_REGULATOR0.Reg) & 0x400000) >> 22
}
func (o *PMU_Type) SetLP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_SLP_DBIAS(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_REGULATOR0.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_REGULATOR0.Reg)&^(0x7800000)|value<<23)
}
func (o *PMU_Type) GetLP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_SLP_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_REGULATOR0.Reg) & 0x7800000) >> 23
}
func (o *PMU_Type) SetLP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_DBIAS(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_REGULATOR0.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_REGULATOR0.Reg)&^(0xf8000000)|value<<27)
}
func (o *PMU_Type) GetLP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_REGULATOR0.Reg) & 0xf8000000) >> 27
}

// PMU.LP_SLEEP_LP_REGULATOR1: need_des
func (o *PMU_Type) SetLP_SLEEP_LP_REGULATOR1_LP_SLEEP_LP_REGULATOR_DRV_B(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_REGULATOR1.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_REGULATOR1.Reg)&^(0xf0000000)|value<<28)
}
func (o *PMU_Type) GetLP_SLEEP_LP_REGULATOR1_LP_SLEEP_LP_REGULATOR_DRV_B() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_REGULATOR1.Reg) & 0xf0000000) >> 28
}

// PMU.LP_SLEEP_XTAL: need_des
func (o *PMU_Type) SetLP_SLEEP_XTAL_LP_SLEEP_XPD_XTAL(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_XTAL.Reg, volatile.LoadUint32(&o.LP_SLEEP_XTAL.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetLP_SLEEP_XTAL_LP_SLEEP_XPD_XTAL() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_XTAL.Reg) & 0x80000000) >> 31
}

// PMU.LP_SLEEP_LP_DIG_POWER: need_des
func (o *PMU_Type) SetLP_SLEEP_LP_DIG_POWER_LP_SLEEP_BOD_SOURCE_SEL(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_DIG_POWER.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_DIG_POWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetLP_SLEEP_LP_DIG_POWER_LP_SLEEP_BOD_SOURCE_SEL() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_DIG_POWER.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetLP_SLEEP_LP_DIG_POWER_LP_SLEEP_VDDBAT_MODE(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_DIG_POWER.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_DIG_POWER.Reg)&^(0x30000000)|value<<28)
}
func (o *PMU_Type) GetLP_SLEEP_LP_DIG_POWER_LP_SLEEP_VDDBAT_MODE() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_DIG_POWER.Reg) & 0x30000000) >> 28
}
func (o *PMU_Type) SetLP_SLEEP_LP_DIG_POWER_LP_SLEEP_LP_MEM_DSLP(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_DIG_POWER.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_DIG_POWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetLP_SLEEP_LP_DIG_POWER_LP_SLEEP_LP_MEM_DSLP() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_DIG_POWER.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetLP_SLEEP_LP_DIG_POWER_LP_SLEEP_PD_LP_PERI_PD_EN(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_DIG_POWER.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_DIG_POWER.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetLP_SLEEP_LP_DIG_POWER_LP_SLEEP_PD_LP_PERI_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_DIG_POWER.Reg) & 0x80000000) >> 31
}

// PMU.LP_SLEEP_LP_CK_POWER: need_des
func (o *PMU_Type) SetLP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_LPPLL(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_CK_POWER.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_CK_POWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetLP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_LPPLL() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_CK_POWER.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetLP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_XTAL32K(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_CK_POWER.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_CK_POWER.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetLP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_XTAL32K() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_CK_POWER.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetLP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_RC32K(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_CK_POWER.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_CK_POWER.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetLP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_RC32K() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_CK_POWER.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetLP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_FOSC_CLK(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_CK_POWER.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_CK_POWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetLP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_FOSC_CLK() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_CK_POWER.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetLP_SLEEP_LP_CK_POWER_LP_SLEEP_PD_OSC_CLK(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_LP_CK_POWER.Reg, volatile.LoadUint32(&o.LP_SLEEP_LP_CK_POWER.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetLP_SLEEP_LP_CK_POWER_LP_SLEEP_PD_OSC_CLK() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_LP_CK_POWER.Reg) & 0x80000000) >> 31
}

// PMU.LP_SLEEP_BIAS: need_des
func (o *PMU_Type) SetLP_SLEEP_BIAS_LP_SLEEP_XPD_BIAS(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_BIAS.Reg, volatile.LoadUint32(&o.LP_SLEEP_BIAS.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetLP_SLEEP_BIAS_LP_SLEEP_XPD_BIAS() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_BIAS.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetLP_SLEEP_BIAS_LP_SLEEP_PD_CUR(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_BIAS.Reg, volatile.LoadUint32(&o.LP_SLEEP_BIAS.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetLP_SLEEP_BIAS_LP_SLEEP_PD_CUR() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_BIAS.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetLP_SLEEP_BIAS_SLEEP(value uint32) {
	volatile.StoreUint32(&o.LP_SLEEP_BIAS.Reg, volatile.LoadUint32(&o.LP_SLEEP_BIAS.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetLP_SLEEP_BIAS_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.LP_SLEEP_BIAS.Reg) & 0x80000000) >> 31
}

// PMU.IMM_HP_CK_POWER: need_des
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_LOW_GLOBAL_BBPLL_ICG(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_LOW_GLOBAL_BBPLL_ICG() uint32 {
	return volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x1
}
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_LOW_GLOBAL_XTAL_ICG(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_LOW_GLOBAL_XTAL_ICG() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_LOW_I2C_RETENTION(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_LOW_I2C_RETENTION() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_LOW_XPD_BB_I2C(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_LOW_XPD_BB_I2C() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_LOW_XPD_BBPLL_I2C(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x10)|value<<4)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_LOW_XPD_BBPLL_I2C() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x10) >> 4
}
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_LOW_XPD_BBPLL(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x20)|value<<5)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_LOW_XPD_BBPLL() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x20) >> 5
}
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_LOW_XPD_XTAL(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x40)|value<<6)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_LOW_XPD_XTAL() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x40) >> 6
}
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_HIGH_GLOBAL_BBPLL_ICG(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_HIGH_GLOBAL_BBPLL_ICG() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_HIGH_GLOBAL_XTAL_ICG(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_HIGH_GLOBAL_XTAL_ICG() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_HIGH_I2C_RETENTION(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_HIGH_I2C_RETENTION() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_HIGH_XPD_BB_I2C(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_HIGH_XPD_BB_I2C() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_HIGH_XPD_BBPLL_I2C(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_HIGH_XPD_BBPLL_I2C() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_HIGH_XPD_BBPLL(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_HIGH_XPD_BBPLL() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetIMM_HP_CK_POWER_TIE_HIGH_XPD_XTAL(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_CK_POWER.Reg, volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetIMM_HP_CK_POWER_TIE_HIGH_XPD_XTAL() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_CK_POWER.Reg) & 0x80000000) >> 31
}

// PMU.IMM_SLEEP_SYSCLK: need_des
func (o *PMU_Type) SetIMM_SLEEP_SYSCLK_UPDATE_DIG_ICG_SWITCH(value uint32) {
	volatile.StoreUint32(&o.IMM_SLEEP_SYSCLK.Reg, volatile.LoadUint32(&o.IMM_SLEEP_SYSCLK.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetIMM_SLEEP_SYSCLK_UPDATE_DIG_ICG_SWITCH() uint32 {
	return (volatile.LoadUint32(&o.IMM_SLEEP_SYSCLK.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetIMM_SLEEP_SYSCLK_TIE_LOW_ICG_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.IMM_SLEEP_SYSCLK.Reg, volatile.LoadUint32(&o.IMM_SLEEP_SYSCLK.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetIMM_SLEEP_SYSCLK_TIE_LOW_ICG_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.IMM_SLEEP_SYSCLK.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetIMM_SLEEP_SYSCLK_TIE_HIGH_ICG_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.IMM_SLEEP_SYSCLK.Reg, volatile.LoadUint32(&o.IMM_SLEEP_SYSCLK.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetIMM_SLEEP_SYSCLK_TIE_HIGH_ICG_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.IMM_SLEEP_SYSCLK.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetIMM_SLEEP_SYSCLK_UPDATE_DIG_SYS_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.IMM_SLEEP_SYSCLK.Reg, volatile.LoadUint32(&o.IMM_SLEEP_SYSCLK.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetIMM_SLEEP_SYSCLK_UPDATE_DIG_SYS_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.IMM_SLEEP_SYSCLK.Reg) & 0x80000000) >> 31
}

// PMU.IMM_HP_FUNC_ICG: need_des
func (o *PMU_Type) SetIMM_HP_FUNC_ICG_UPDATE_DIG_ICG_FUNC_EN(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_FUNC_ICG.Reg, volatile.LoadUint32(&o.IMM_HP_FUNC_ICG.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetIMM_HP_FUNC_ICG_UPDATE_DIG_ICG_FUNC_EN() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_FUNC_ICG.Reg) & 0x80000000) >> 31
}

// PMU.IMM_HP_APB_ICG: need_des
func (o *PMU_Type) SetIMM_HP_APB_ICG_UPDATE_DIG_ICG_APB_EN(value uint32) {
	volatile.StoreUint32(&o.IMM_HP_APB_ICG.Reg, volatile.LoadUint32(&o.IMM_HP_APB_ICG.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetIMM_HP_APB_ICG_UPDATE_DIG_ICG_APB_EN() uint32 {
	return (volatile.LoadUint32(&o.IMM_HP_APB_ICG.Reg) & 0x80000000) >> 31
}

// PMU.IMM_MODEM_ICG: need_des
func (o *PMU_Type) SetIMM_MODEM_ICG_UPDATE_DIG_ICG_MODEM_EN(value uint32) {
	volatile.StoreUint32(&o.IMM_MODEM_ICG.Reg, volatile.LoadUint32(&o.IMM_MODEM_ICG.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetIMM_MODEM_ICG_UPDATE_DIG_ICG_MODEM_EN() uint32 {
	return (volatile.LoadUint32(&o.IMM_MODEM_ICG.Reg) & 0x80000000) >> 31
}

// PMU.IMM_LP_ICG: need_des
func (o *PMU_Type) SetIMM_LP_ICG_TIE_LOW_LP_ROOTCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.IMM_LP_ICG.Reg, volatile.LoadUint32(&o.IMM_LP_ICG.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetIMM_LP_ICG_TIE_LOW_LP_ROOTCLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.IMM_LP_ICG.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetIMM_LP_ICG_TIE_HIGH_LP_ROOTCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.IMM_LP_ICG.Reg, volatile.LoadUint32(&o.IMM_LP_ICG.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetIMM_LP_ICG_TIE_HIGH_LP_ROOTCLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.IMM_LP_ICG.Reg) & 0x80000000) >> 31
}

// PMU.IMM_PAD_HOLD_ALL: need_des
func (o *PMU_Type) SetIMM_PAD_HOLD_ALL_TIE_HIGH_LP_PAD_HOLD_ALL(value uint32) {
	volatile.StoreUint32(&o.IMM_PAD_HOLD_ALL.Reg, volatile.LoadUint32(&o.IMM_PAD_HOLD_ALL.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetIMM_PAD_HOLD_ALL_TIE_HIGH_LP_PAD_HOLD_ALL() uint32 {
	return (volatile.LoadUint32(&o.IMM_PAD_HOLD_ALL.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetIMM_PAD_HOLD_ALL_TIE_LOW_LP_PAD_HOLD_ALL(value uint32) {
	volatile.StoreUint32(&o.IMM_PAD_HOLD_ALL.Reg, volatile.LoadUint32(&o.IMM_PAD_HOLD_ALL.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetIMM_PAD_HOLD_ALL_TIE_LOW_LP_PAD_HOLD_ALL() uint32 {
	return (volatile.LoadUint32(&o.IMM_PAD_HOLD_ALL.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetIMM_PAD_HOLD_ALL_TIE_HIGH_HP_PAD_HOLD_ALL(value uint32) {
	volatile.StoreUint32(&o.IMM_PAD_HOLD_ALL.Reg, volatile.LoadUint32(&o.IMM_PAD_HOLD_ALL.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetIMM_PAD_HOLD_ALL_TIE_HIGH_HP_PAD_HOLD_ALL() uint32 {
	return (volatile.LoadUint32(&o.IMM_PAD_HOLD_ALL.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetIMM_PAD_HOLD_ALL_TIE_LOW_HP_PAD_HOLD_ALL(value uint32) {
	volatile.StoreUint32(&o.IMM_PAD_HOLD_ALL.Reg, volatile.LoadUint32(&o.IMM_PAD_HOLD_ALL.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetIMM_PAD_HOLD_ALL_TIE_LOW_HP_PAD_HOLD_ALL() uint32 {
	return (volatile.LoadUint32(&o.IMM_PAD_HOLD_ALL.Reg) & 0x80000000) >> 31
}

// PMU.IMM_I2C_ISO: need_des
func (o *PMU_Type) SetIMM_I2C_ISO_TIE_HIGH_I2C_ISO_EN(value uint32) {
	volatile.StoreUint32(&o.IMM_I2C_ISO.Reg, volatile.LoadUint32(&o.IMM_I2C_ISO.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetIMM_I2C_ISO_TIE_HIGH_I2C_ISO_EN() uint32 {
	return (volatile.LoadUint32(&o.IMM_I2C_ISO.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetIMM_I2C_ISO_TIE_LOW_I2C_ISO_EN(value uint32) {
	volatile.StoreUint32(&o.IMM_I2C_ISO.Reg, volatile.LoadUint32(&o.IMM_I2C_ISO.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetIMM_I2C_ISO_TIE_LOW_I2C_ISO_EN() uint32 {
	return (volatile.LoadUint32(&o.IMM_I2C_ISO.Reg) & 0x80000000) >> 31
}

// PMU.POWER_WAIT_TIMER0: need_des
func (o *PMU_Type) SetPOWER_WAIT_TIMER0_DG_HP_POWERDOWN_TIMER(value uint32) {
	volatile.StoreUint32(&o.POWER_WAIT_TIMER0.Reg, volatile.LoadUint32(&o.POWER_WAIT_TIMER0.Reg)&^(0x3fe0)|value<<5)
}
func (o *PMU_Type) GetPOWER_WAIT_TIMER0_DG_HP_POWERDOWN_TIMER() uint32 {
	return (volatile.LoadUint32(&o.POWER_WAIT_TIMER0.Reg) & 0x3fe0) >> 5
}
func (o *PMU_Type) SetPOWER_WAIT_TIMER0_DG_HP_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.POWER_WAIT_TIMER0.Reg, volatile.LoadUint32(&o.POWER_WAIT_TIMER0.Reg)&^(0x7fc000)|value<<14)
}
func (o *PMU_Type) GetPOWER_WAIT_TIMER0_DG_HP_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.POWER_WAIT_TIMER0.Reg) & 0x7fc000) >> 14
}
func (o *PMU_Type) SetPOWER_WAIT_TIMER0_DG_HP_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.POWER_WAIT_TIMER0.Reg, volatile.LoadUint32(&o.POWER_WAIT_TIMER0.Reg)&^(0xff800000)|value<<23)
}
func (o *PMU_Type) GetPOWER_WAIT_TIMER0_DG_HP_WAIT_TIMER() uint32 {
	return (volatile.LoadUint32(&o.POWER_WAIT_TIMER0.Reg) & 0xff800000) >> 23
}

// PMU.POWER_WAIT_TIMER1: need_des
func (o *PMU_Type) SetPOWER_WAIT_TIMER1_DG_LP_POWERDOWN_TIMER(value uint32) {
	volatile.StoreUint32(&o.POWER_WAIT_TIMER1.Reg, volatile.LoadUint32(&o.POWER_WAIT_TIMER1.Reg)&^(0xfe00)|value<<9)
}
func (o *PMU_Type) GetPOWER_WAIT_TIMER1_DG_LP_POWERDOWN_TIMER() uint32 {
	return (volatile.LoadUint32(&o.POWER_WAIT_TIMER1.Reg) & 0xfe00) >> 9
}
func (o *PMU_Type) SetPOWER_WAIT_TIMER1_DG_LP_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.POWER_WAIT_TIMER1.Reg, volatile.LoadUint32(&o.POWER_WAIT_TIMER1.Reg)&^(0x7f0000)|value<<16)
}
func (o *PMU_Type) GetPOWER_WAIT_TIMER1_DG_LP_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.POWER_WAIT_TIMER1.Reg) & 0x7f0000) >> 16
}
func (o *PMU_Type) SetPOWER_WAIT_TIMER1_DG_LP_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.POWER_WAIT_TIMER1.Reg, volatile.LoadUint32(&o.POWER_WAIT_TIMER1.Reg)&^(0xff800000)|value<<23)
}
func (o *PMU_Type) GetPOWER_WAIT_TIMER1_DG_LP_WAIT_TIMER() uint32 {
	return (volatile.LoadUint32(&o.POWER_WAIT_TIMER1.Reg) & 0xff800000) >> 23
}

// PMU.POWER_PD_TOP_CNTL: need_des
func (o *PMU_Type) SetPOWER_PD_TOP_CNTL_FORCE_TOP_RESET(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_TOP_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetPOWER_PD_TOP_CNTL_FORCE_TOP_RESET() uint32 {
	return volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg) & 0x1
}
func (o *PMU_Type) SetPOWER_PD_TOP_CNTL_FORCE_TOP_ISO(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_TOP_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetPOWER_PD_TOP_CNTL_FORCE_TOP_ISO() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetPOWER_PD_TOP_CNTL_FORCE_TOP_PU(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_TOP_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetPOWER_PD_TOP_CNTL_FORCE_TOP_PU() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetPOWER_PD_TOP_CNTL_FORCE_TOP_NO_RESET(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_TOP_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetPOWER_PD_TOP_CNTL_FORCE_TOP_NO_RESET() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetPOWER_PD_TOP_CNTL_FORCE_TOP_NO_ISO(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_TOP_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg)&^(0x10)|value<<4)
}
func (o *PMU_Type) GetPOWER_PD_TOP_CNTL_FORCE_TOP_NO_ISO() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg) & 0x10) >> 4
}
func (o *PMU_Type) SetPOWER_PD_TOP_CNTL_FORCE_TOP_PD(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_TOP_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg)&^(0x20)|value<<5)
}
func (o *PMU_Type) GetPOWER_PD_TOP_CNTL_FORCE_TOP_PD() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg) & 0x20) >> 5
}
func (o *PMU_Type) SetPOWER_PD_TOP_CNTL_PD_TOP_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_TOP_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg)&^(0x7c0)|value<<6)
}
func (o *PMU_Type) GetPOWER_PD_TOP_CNTL_PD_TOP_MASK() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg) & 0x7c0) >> 6
}
func (o *PMU_Type) SetPOWER_PD_TOP_CNTL_PD_TOP_PD_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_TOP_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg)&^(0xf8000000)|value<<27)
}
func (o *PMU_Type) GetPOWER_PD_TOP_CNTL_PD_TOP_PD_MASK() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_TOP_CNTL.Reg) & 0xf8000000) >> 27
}

// PMU.POWER_PD_HPAON_CNTL: need_des
func (o *PMU_Type) SetPOWER_PD_HPAON_CNTL_FORCE_HP_AON_RESET(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPAON_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetPOWER_PD_HPAON_CNTL_FORCE_HP_AON_RESET() uint32 {
	return volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg) & 0x1
}
func (o *PMU_Type) SetPOWER_PD_HPAON_CNTL_FORCE_HP_AON_ISO(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPAON_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetPOWER_PD_HPAON_CNTL_FORCE_HP_AON_ISO() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetPOWER_PD_HPAON_CNTL_FORCE_HP_AON_PU(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPAON_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetPOWER_PD_HPAON_CNTL_FORCE_HP_AON_PU() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetPOWER_PD_HPAON_CNTL_FORCE_HP_AON_NO_RESET(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPAON_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetPOWER_PD_HPAON_CNTL_FORCE_HP_AON_NO_RESET() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetPOWER_PD_HPAON_CNTL_FORCE_HP_AON_NO_ISO(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPAON_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg)&^(0x10)|value<<4)
}
func (o *PMU_Type) GetPOWER_PD_HPAON_CNTL_FORCE_HP_AON_NO_ISO() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg) & 0x10) >> 4
}
func (o *PMU_Type) SetPOWER_PD_HPAON_CNTL_FORCE_HP_AON_PD(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPAON_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg)&^(0x20)|value<<5)
}
func (o *PMU_Type) GetPOWER_PD_HPAON_CNTL_FORCE_HP_AON_PD() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg) & 0x20) >> 5
}
func (o *PMU_Type) SetPOWER_PD_HPAON_CNTL_PD_HP_AON_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPAON_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg)&^(0x7c0)|value<<6)
}
func (o *PMU_Type) GetPOWER_PD_HPAON_CNTL_PD_HP_AON_MASK() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg) & 0x7c0) >> 6
}
func (o *PMU_Type) SetPOWER_PD_HPAON_CNTL_PD_HP_AON_PD_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPAON_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg)&^(0xf8000000)|value<<27)
}
func (o *PMU_Type) GetPOWER_PD_HPAON_CNTL_PD_HP_AON_PD_MASK() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPAON_CNTL.Reg) & 0xf8000000) >> 27
}

// PMU.POWER_PD_HPCPU_CNTL: need_des
func (o *PMU_Type) SetPOWER_PD_HPCPU_CNTL_FORCE_HP_CPU_RESET(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPCPU_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetPOWER_PD_HPCPU_CNTL_FORCE_HP_CPU_RESET() uint32 {
	return volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg) & 0x1
}
func (o *PMU_Type) SetPOWER_PD_HPCPU_CNTL_FORCE_HP_CPU_ISO(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPCPU_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetPOWER_PD_HPCPU_CNTL_FORCE_HP_CPU_ISO() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetPOWER_PD_HPCPU_CNTL_FORCE_HP_CPU_PU(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPCPU_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetPOWER_PD_HPCPU_CNTL_FORCE_HP_CPU_PU() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetPOWER_PD_HPCPU_CNTL_FORCE_HP_CPU_NO_RESET(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPCPU_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetPOWER_PD_HPCPU_CNTL_FORCE_HP_CPU_NO_RESET() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetPOWER_PD_HPCPU_CNTL_FORCE_HP_CPU_NO_ISO(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPCPU_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg)&^(0x10)|value<<4)
}
func (o *PMU_Type) GetPOWER_PD_HPCPU_CNTL_FORCE_HP_CPU_NO_ISO() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg) & 0x10) >> 4
}
func (o *PMU_Type) SetPOWER_PD_HPCPU_CNTL_FORCE_HP_CPU_PD(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPCPU_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg)&^(0x20)|value<<5)
}
func (o *PMU_Type) GetPOWER_PD_HPCPU_CNTL_FORCE_HP_CPU_PD() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg) & 0x20) >> 5
}
func (o *PMU_Type) SetPOWER_PD_HPCPU_CNTL_PD_HP_CPU_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPCPU_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg)&^(0x7c0)|value<<6)
}
func (o *PMU_Type) GetPOWER_PD_HPCPU_CNTL_PD_HP_CPU_MASK() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg) & 0x7c0) >> 6
}
func (o *PMU_Type) SetPOWER_PD_HPCPU_CNTL_PD_HP_CPU_PD_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPCPU_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg)&^(0xf8000000)|value<<27)
}
func (o *PMU_Type) GetPOWER_PD_HPCPU_CNTL_PD_HP_CPU_PD_MASK() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPCPU_CNTL.Reg) & 0xf8000000) >> 27
}

// PMU.POWER_PD_HPPERI_RESERVE: need_des
func (o *PMU_Type) SetPOWER_PD_HPPERI_RESERVE(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPPERI_RESERVE.Reg, value)
}
func (o *PMU_Type) GetPOWER_PD_HPPERI_RESERVE() uint32 {
	return volatile.LoadUint32(&o.POWER_PD_HPPERI_RESERVE.Reg)
}

// PMU.POWER_PD_HPWIFI_CNTL: need_des
func (o *PMU_Type) SetPOWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_RESET(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPWIFI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetPOWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_RESET() uint32 {
	return volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg) & 0x1
}
func (o *PMU_Type) SetPOWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_ISO(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPWIFI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetPOWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_ISO() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetPOWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_PU(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPWIFI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetPOWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_PU() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetPOWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_NO_RESET(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPWIFI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetPOWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_NO_RESET() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetPOWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_NO_ISO(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPWIFI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg)&^(0x10)|value<<4)
}
func (o *PMU_Type) GetPOWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_NO_ISO() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg) & 0x10) >> 4
}
func (o *PMU_Type) SetPOWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_PD(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPWIFI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg)&^(0x20)|value<<5)
}
func (o *PMU_Type) GetPOWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_PD() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg) & 0x20) >> 5
}
func (o *PMU_Type) SetPOWER_PD_HPWIFI_CNTL_PD_HP_WIFI_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPWIFI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg)&^(0x7c0)|value<<6)
}
func (o *PMU_Type) GetPOWER_PD_HPWIFI_CNTL_PD_HP_WIFI_MASK() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg) & 0x7c0) >> 6
}
func (o *PMU_Type) SetPOWER_PD_HPWIFI_CNTL_PD_HP_WIFI_PD_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_HPWIFI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg)&^(0xf8000000)|value<<27)
}
func (o *PMU_Type) GetPOWER_PD_HPWIFI_CNTL_PD_HP_WIFI_PD_MASK() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_HPWIFI_CNTL.Reg) & 0xf8000000) >> 27
}

// PMU.POWER_PD_LPPERI_CNTL: need_des
func (o *PMU_Type) SetPOWER_PD_LPPERI_CNTL_FORCE_LP_PERI_RESET(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_LPPERI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_LPPERI_CNTL.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetPOWER_PD_LPPERI_CNTL_FORCE_LP_PERI_RESET() uint32 {
	return volatile.LoadUint32(&o.POWER_PD_LPPERI_CNTL.Reg) & 0x1
}
func (o *PMU_Type) SetPOWER_PD_LPPERI_CNTL_FORCE_LP_PERI_ISO(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_LPPERI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_LPPERI_CNTL.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetPOWER_PD_LPPERI_CNTL_FORCE_LP_PERI_ISO() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_LPPERI_CNTL.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetPOWER_PD_LPPERI_CNTL_FORCE_LP_PERI_PU(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_LPPERI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_LPPERI_CNTL.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetPOWER_PD_LPPERI_CNTL_FORCE_LP_PERI_PU() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_LPPERI_CNTL.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetPOWER_PD_LPPERI_CNTL_FORCE_LP_PERI_NO_RESET(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_LPPERI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_LPPERI_CNTL.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetPOWER_PD_LPPERI_CNTL_FORCE_LP_PERI_NO_RESET() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_LPPERI_CNTL.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetPOWER_PD_LPPERI_CNTL_FORCE_LP_PERI_NO_ISO(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_LPPERI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_LPPERI_CNTL.Reg)&^(0x10)|value<<4)
}
func (o *PMU_Type) GetPOWER_PD_LPPERI_CNTL_FORCE_LP_PERI_NO_ISO() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_LPPERI_CNTL.Reg) & 0x10) >> 4
}
func (o *PMU_Type) SetPOWER_PD_LPPERI_CNTL_FORCE_LP_PERI_PD(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_LPPERI_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_LPPERI_CNTL.Reg)&^(0x20)|value<<5)
}
func (o *PMU_Type) GetPOWER_PD_LPPERI_CNTL_FORCE_LP_PERI_PD() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_LPPERI_CNTL.Reg) & 0x20) >> 5
}

// PMU.POWER_PD_MEM_CNTL: need_des
func (o *PMU_Type) SetPOWER_PD_MEM_CNTL_FORCE_HP_MEM_ISO(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_MEM_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_MEM_CNTL.Reg)&^(0xf)|value)
}
func (o *PMU_Type) GetPOWER_PD_MEM_CNTL_FORCE_HP_MEM_ISO() uint32 {
	return volatile.LoadUint32(&o.POWER_PD_MEM_CNTL.Reg) & 0xf
}
func (o *PMU_Type) SetPOWER_PD_MEM_CNTL_FORCE_HP_MEM_PD(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_MEM_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_MEM_CNTL.Reg)&^(0xf0)|value<<4)
}
func (o *PMU_Type) GetPOWER_PD_MEM_CNTL_FORCE_HP_MEM_PD() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_MEM_CNTL.Reg) & 0xf0) >> 4
}
func (o *PMU_Type) SetPOWER_PD_MEM_CNTL_FORCE_HP_MEM_NO_ISO(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_MEM_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_MEM_CNTL.Reg)&^(0xf000000)|value<<24)
}
func (o *PMU_Type) GetPOWER_PD_MEM_CNTL_FORCE_HP_MEM_NO_ISO() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_MEM_CNTL.Reg) & 0xf000000) >> 24
}
func (o *PMU_Type) SetPOWER_PD_MEM_CNTL_FORCE_HP_MEM_PU(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_MEM_CNTL.Reg, volatile.LoadUint32(&o.POWER_PD_MEM_CNTL.Reg)&^(0xf0000000)|value<<28)
}
func (o *PMU_Type) GetPOWER_PD_MEM_CNTL_FORCE_HP_MEM_PU() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_MEM_CNTL.Reg) & 0xf0000000) >> 28
}

// PMU.POWER_PD_MEM_MASK: need_des
func (o *PMU_Type) SetPOWER_PD_MEM_MASK_PD_HP_MEM2_PD_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_MEM_MASK.Reg, volatile.LoadUint32(&o.POWER_PD_MEM_MASK.Reg)&^(0x1f)|value)
}
func (o *PMU_Type) GetPOWER_PD_MEM_MASK_PD_HP_MEM2_PD_MASK() uint32 {
	return volatile.LoadUint32(&o.POWER_PD_MEM_MASK.Reg) & 0x1f
}
func (o *PMU_Type) SetPOWER_PD_MEM_MASK_PD_HP_MEM1_PD_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_MEM_MASK.Reg, volatile.LoadUint32(&o.POWER_PD_MEM_MASK.Reg)&^(0x3e0)|value<<5)
}
func (o *PMU_Type) GetPOWER_PD_MEM_MASK_PD_HP_MEM1_PD_MASK() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_MEM_MASK.Reg) & 0x3e0) >> 5
}
func (o *PMU_Type) SetPOWER_PD_MEM_MASK_PD_HP_MEM0_PD_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_MEM_MASK.Reg, volatile.LoadUint32(&o.POWER_PD_MEM_MASK.Reg)&^(0x7c00)|value<<10)
}
func (o *PMU_Type) GetPOWER_PD_MEM_MASK_PD_HP_MEM0_PD_MASK() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_MEM_MASK.Reg) & 0x7c00) >> 10
}
func (o *PMU_Type) SetPOWER_PD_MEM_MASK_PD_HP_MEM2_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_MEM_MASK.Reg, volatile.LoadUint32(&o.POWER_PD_MEM_MASK.Reg)&^(0x3e0000)|value<<17)
}
func (o *PMU_Type) GetPOWER_PD_MEM_MASK_PD_HP_MEM2_MASK() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_MEM_MASK.Reg) & 0x3e0000) >> 17
}
func (o *PMU_Type) SetPOWER_PD_MEM_MASK_PD_HP_MEM1_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_MEM_MASK.Reg, volatile.LoadUint32(&o.POWER_PD_MEM_MASK.Reg)&^(0x7c00000)|value<<22)
}
func (o *PMU_Type) GetPOWER_PD_MEM_MASK_PD_HP_MEM1_MASK() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_MEM_MASK.Reg) & 0x7c00000) >> 22
}
func (o *PMU_Type) SetPOWER_PD_MEM_MASK_PD_HP_MEM0_MASK(value uint32) {
	volatile.StoreUint32(&o.POWER_PD_MEM_MASK.Reg, volatile.LoadUint32(&o.POWER_PD_MEM_MASK.Reg)&^(0xf8000000)|value<<27)
}
func (o *PMU_Type) GetPOWER_PD_MEM_MASK_PD_HP_MEM0_MASK() uint32 {
	return (volatile.LoadUint32(&o.POWER_PD_MEM_MASK.Reg) & 0xf8000000) >> 27
}

// PMU.POWER_HP_PAD: need_des
func (o *PMU_Type) SetPOWER_HP_PAD_FORCE_HP_PAD_NO_ISO_ALL(value uint32) {
	volatile.StoreUint32(&o.POWER_HP_PAD.Reg, volatile.LoadUint32(&o.POWER_HP_PAD.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetPOWER_HP_PAD_FORCE_HP_PAD_NO_ISO_ALL() uint32 {
	return volatile.LoadUint32(&o.POWER_HP_PAD.Reg) & 0x1
}
func (o *PMU_Type) SetPOWER_HP_PAD_FORCE_HP_PAD_ISO_ALL(value uint32) {
	volatile.StoreUint32(&o.POWER_HP_PAD.Reg, volatile.LoadUint32(&o.POWER_HP_PAD.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetPOWER_HP_PAD_FORCE_HP_PAD_ISO_ALL() uint32 {
	return (volatile.LoadUint32(&o.POWER_HP_PAD.Reg) & 0x2) >> 1
}

// PMU.POWER_VDD_SPI_CNTL: need_des
func (o *PMU_Type) SetPOWER_VDD_SPI_CNTL_VDD_SPI_PWR_WAIT(value uint32) {
	volatile.StoreUint32(&o.POWER_VDD_SPI_CNTL.Reg, volatile.LoadUint32(&o.POWER_VDD_SPI_CNTL.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *PMU_Type) GetPOWER_VDD_SPI_CNTL_VDD_SPI_PWR_WAIT() uint32 {
	return (volatile.LoadUint32(&o.POWER_VDD_SPI_CNTL.Reg) & 0x1ffc0000) >> 18
}
func (o *PMU_Type) SetPOWER_VDD_SPI_CNTL_VDD_SPI_PWR_SW(value uint32) {
	volatile.StoreUint32(&o.POWER_VDD_SPI_CNTL.Reg, volatile.LoadUint32(&o.POWER_VDD_SPI_CNTL.Reg)&^(0x60000000)|value<<29)
}
func (o *PMU_Type) GetPOWER_VDD_SPI_CNTL_VDD_SPI_PWR_SW() uint32 {
	return (volatile.LoadUint32(&o.POWER_VDD_SPI_CNTL.Reg) & 0x60000000) >> 29
}
func (o *PMU_Type) SetPOWER_VDD_SPI_CNTL_VDD_SPI_PWR_SEL_SW(value uint32) {
	volatile.StoreUint32(&o.POWER_VDD_SPI_CNTL.Reg, volatile.LoadUint32(&o.POWER_VDD_SPI_CNTL.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetPOWER_VDD_SPI_CNTL_VDD_SPI_PWR_SEL_SW() uint32 {
	return (volatile.LoadUint32(&o.POWER_VDD_SPI_CNTL.Reg) & 0x80000000) >> 31
}

// PMU.POWER_CK_WAIT_CNTL: need_des
func (o *PMU_Type) SetPOWER_CK_WAIT_CNTL_WAIT_XTL_STABLE(value uint32) {
	volatile.StoreUint32(&o.POWER_CK_WAIT_CNTL.Reg, volatile.LoadUint32(&o.POWER_CK_WAIT_CNTL.Reg)&^(0xffff)|value)
}
func (o *PMU_Type) GetPOWER_CK_WAIT_CNTL_WAIT_XTL_STABLE() uint32 {
	return volatile.LoadUint32(&o.POWER_CK_WAIT_CNTL.Reg) & 0xffff
}
func (o *PMU_Type) SetPOWER_CK_WAIT_CNTL_WAIT_PLL_STABLE(value uint32) {
	volatile.StoreUint32(&o.POWER_CK_WAIT_CNTL.Reg, volatile.LoadUint32(&o.POWER_CK_WAIT_CNTL.Reg)&^(0xffff0000)|value<<16)
}
func (o *PMU_Type) GetPOWER_CK_WAIT_CNTL_WAIT_PLL_STABLE() uint32 {
	return (volatile.LoadUint32(&o.POWER_CK_WAIT_CNTL.Reg) & 0xffff0000) >> 16
}

// PMU.SLP_WAKEUP_CNTL0: need_des
func (o *PMU_Type) SetSLP_WAKEUP_CNTL0_SLEEP_REQ(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CNTL0.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CNTL0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetSLP_WAKEUP_CNTL0_SLEEP_REQ() uint32 {
	return (volatile.LoadUint32(&o.SLP_WAKEUP_CNTL0.Reg) & 0x80000000) >> 31
}

// PMU.SLP_WAKEUP_CNTL1: need_des
func (o *PMU_Type) SetSLP_WAKEUP_CNTL1_SLEEP_REJECT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CNTL1.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CNTL1.Reg)&^(0x7fffffff)|value)
}
func (o *PMU_Type) GetSLP_WAKEUP_CNTL1_SLEEP_REJECT_ENA() uint32 {
	return volatile.LoadUint32(&o.SLP_WAKEUP_CNTL1.Reg) & 0x7fffffff
}
func (o *PMU_Type) SetSLP_WAKEUP_CNTL1_SLP_REJECT_EN(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CNTL1.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CNTL1.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetSLP_WAKEUP_CNTL1_SLP_REJECT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLP_WAKEUP_CNTL1.Reg) & 0x80000000) >> 31
}

// PMU.SLP_WAKEUP_CNTL2: need_des
func (o *PMU_Type) SetSLP_WAKEUP_CNTL2(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CNTL2.Reg, value)
}
func (o *PMU_Type) GetSLP_WAKEUP_CNTL2() uint32 {
	return volatile.LoadUint32(&o.SLP_WAKEUP_CNTL2.Reg)
}

// PMU.SLP_WAKEUP_CNTL3: need_des
func (o *PMU_Type) SetSLP_WAKEUP_CNTL3_LP_MIN_SLP_VAL(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CNTL3.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CNTL3.Reg)&^(0xff)|value)
}
func (o *PMU_Type) GetSLP_WAKEUP_CNTL3_LP_MIN_SLP_VAL() uint32 {
	return volatile.LoadUint32(&o.SLP_WAKEUP_CNTL3.Reg) & 0xff
}
func (o *PMU_Type) SetSLP_WAKEUP_CNTL3_HP_MIN_SLP_VAL(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CNTL3.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CNTL3.Reg)&^(0xff00)|value<<8)
}
func (o *PMU_Type) GetSLP_WAKEUP_CNTL3_HP_MIN_SLP_VAL() uint32 {
	return (volatile.LoadUint32(&o.SLP_WAKEUP_CNTL3.Reg) & 0xff00) >> 8
}
func (o *PMU_Type) SetSLP_WAKEUP_CNTL3_SLEEP_PRT_SEL(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CNTL3.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CNTL3.Reg)&^(0x30000)|value<<16)
}
func (o *PMU_Type) GetSLP_WAKEUP_CNTL3_SLEEP_PRT_SEL() uint32 {
	return (volatile.LoadUint32(&o.SLP_WAKEUP_CNTL3.Reg) & 0x30000) >> 16
}

// PMU.SLP_WAKEUP_CNTL4: need_des
func (o *PMU_Type) SetSLP_WAKEUP_CNTL4_SLP_REJECT_CAUSE_CLR(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CNTL4.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CNTL4.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetSLP_WAKEUP_CNTL4_SLP_REJECT_CAUSE_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLP_WAKEUP_CNTL4.Reg) & 0x80000000) >> 31
}

// PMU.SLP_WAKEUP_CNTL5: need_des
func (o *PMU_Type) SetSLP_WAKEUP_CNTL5_MODEM_WAIT_TARGET(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CNTL5.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CNTL5.Reg)&^(0xfffff)|value)
}
func (o *PMU_Type) GetSLP_WAKEUP_CNTL5_MODEM_WAIT_TARGET() uint32 {
	return volatile.LoadUint32(&o.SLP_WAKEUP_CNTL5.Reg) & 0xfffff
}
func (o *PMU_Type) SetSLP_WAKEUP_CNTL5_LP_ANA_WAIT_TARGET(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CNTL5.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CNTL5.Reg)&^(0xff000000)|value<<24)
}
func (o *PMU_Type) GetSLP_WAKEUP_CNTL5_LP_ANA_WAIT_TARGET() uint32 {
	return (volatile.LoadUint32(&o.SLP_WAKEUP_CNTL5.Reg) & 0xff000000) >> 24
}

// PMU.SLP_WAKEUP_CNTL6: need_des
func (o *PMU_Type) SetSLP_WAKEUP_CNTL6_SOC_WAKEUP_WAIT(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CNTL6.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CNTL6.Reg)&^(0xfffff)|value)
}
func (o *PMU_Type) GetSLP_WAKEUP_CNTL6_SOC_WAKEUP_WAIT() uint32 {
	return volatile.LoadUint32(&o.SLP_WAKEUP_CNTL6.Reg) & 0xfffff
}
func (o *PMU_Type) SetSLP_WAKEUP_CNTL6_SOC_WAKEUP_WAIT_CFG(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CNTL6.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CNTL6.Reg)&^(0xc0000000)|value<<30)
}
func (o *PMU_Type) GetSLP_WAKEUP_CNTL6_SOC_WAKEUP_WAIT_CFG() uint32 {
	return (volatile.LoadUint32(&o.SLP_WAKEUP_CNTL6.Reg) & 0xc0000000) >> 30
}

// PMU.SLP_WAKEUP_CNTL7: need_des
func (o *PMU_Type) SetSLP_WAKEUP_CNTL7_ANA_WAIT_TARGET(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CNTL7.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CNTL7.Reg)&^(0xffff0000)|value<<16)
}
func (o *PMU_Type) GetSLP_WAKEUP_CNTL7_ANA_WAIT_TARGET() uint32 {
	return (volatile.LoadUint32(&o.SLP_WAKEUP_CNTL7.Reg) & 0xffff0000) >> 16
}

// PMU.SLP_WAKEUP_STATUS0: need_des
func (o *PMU_Type) SetSLP_WAKEUP_STATUS0(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_STATUS0.Reg, value)
}
func (o *PMU_Type) GetSLP_WAKEUP_STATUS0() uint32 {
	return volatile.LoadUint32(&o.SLP_WAKEUP_STATUS0.Reg)
}

// PMU.SLP_WAKEUP_STATUS1: need_des
func (o *PMU_Type) SetSLP_WAKEUP_STATUS1(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_STATUS1.Reg, value)
}
func (o *PMU_Type) GetSLP_WAKEUP_STATUS1() uint32 {
	return volatile.LoadUint32(&o.SLP_WAKEUP_STATUS1.Reg)
}

// PMU.HP_CK_POWERON: need_des
func (o *PMU_Type) SetHP_CK_POWERON_I2C_POR_WAIT_TARGET(value uint32) {
	volatile.StoreUint32(&o.HP_CK_POWERON.Reg, volatile.LoadUint32(&o.HP_CK_POWERON.Reg)&^(0xff)|value)
}
func (o *PMU_Type) GetHP_CK_POWERON_I2C_POR_WAIT_TARGET() uint32 {
	return volatile.LoadUint32(&o.HP_CK_POWERON.Reg) & 0xff
}

// PMU.HP_CK_CNTL: need_des
func (o *PMU_Type) SetHP_CK_CNTL_MODIFY_ICG_CNTL_WAIT(value uint32) {
	volatile.StoreUint32(&o.HP_CK_CNTL.Reg, volatile.LoadUint32(&o.HP_CK_CNTL.Reg)&^(0xff)|value)
}
func (o *PMU_Type) GetHP_CK_CNTL_MODIFY_ICG_CNTL_WAIT() uint32 {
	return volatile.LoadUint32(&o.HP_CK_CNTL.Reg) & 0xff
}
func (o *PMU_Type) SetHP_CK_CNTL_SWITCH_ICG_CNTL_WAIT(value uint32) {
	volatile.StoreUint32(&o.HP_CK_CNTL.Reg, volatile.LoadUint32(&o.HP_CK_CNTL.Reg)&^(0xff00)|value<<8)
}
func (o *PMU_Type) GetHP_CK_CNTL_SWITCH_ICG_CNTL_WAIT() uint32 {
	return (volatile.LoadUint32(&o.HP_CK_CNTL.Reg) & 0xff00) >> 8
}

// PMU.POR_STATUS: need_des
func (o *PMU_Type) SetPOR_STATUS_POR_DONE(value uint32) {
	volatile.StoreUint32(&o.POR_STATUS.Reg, volatile.LoadUint32(&o.POR_STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetPOR_STATUS_POR_DONE() uint32 {
	return (volatile.LoadUint32(&o.POR_STATUS.Reg) & 0x80000000) >> 31
}

// PMU.RF_PWC: need_des
func (o *PMU_Type) SetRF_PWC_XPD_PERIF_I2C(value uint32) {
	volatile.StoreUint32(&o.RF_PWC.Reg, volatile.LoadUint32(&o.RF_PWC.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetRF_PWC_XPD_PERIF_I2C() uint32 {
	return (volatile.LoadUint32(&o.RF_PWC.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetRF_PWC_XPD_RFTX_I2C(value uint32) {
	volatile.StoreUint32(&o.RF_PWC.Reg, volatile.LoadUint32(&o.RF_PWC.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetRF_PWC_XPD_RFTX_I2C() uint32 {
	return (volatile.LoadUint32(&o.RF_PWC.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetRF_PWC_XPD_RFRX_I2C(value uint32) {
	volatile.StoreUint32(&o.RF_PWC.Reg, volatile.LoadUint32(&o.RF_PWC.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetRF_PWC_XPD_RFRX_I2C() uint32 {
	return (volatile.LoadUint32(&o.RF_PWC.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetRF_PWC_XPD_RFPLL(value uint32) {
	volatile.StoreUint32(&o.RF_PWC.Reg, volatile.LoadUint32(&o.RF_PWC.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetRF_PWC_XPD_RFPLL() uint32 {
	return (volatile.LoadUint32(&o.RF_PWC.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetRF_PWC_XPD_FORCE_RFPLL(value uint32) {
	volatile.StoreUint32(&o.RF_PWC.Reg, volatile.LoadUint32(&o.RF_PWC.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetRF_PWC_XPD_FORCE_RFPLL() uint32 {
	return (volatile.LoadUint32(&o.RF_PWC.Reg) & 0x80000000) >> 31
}

// PMU.VDDBAT_CFG: need_des
func (o *PMU_Type) SetVDDBAT_CFG_VDDBAT_MODE(value uint32) {
	volatile.StoreUint32(&o.VDDBAT_CFG.Reg, volatile.LoadUint32(&o.VDDBAT_CFG.Reg)&^(0x3)|value)
}
func (o *PMU_Type) GetVDDBAT_CFG_VDDBAT_MODE() uint32 {
	return volatile.LoadUint32(&o.VDDBAT_CFG.Reg) & 0x3
}
func (o *PMU_Type) SetVDDBAT_CFG_VDDBAT_SW_UPDATE(value uint32) {
	volatile.StoreUint32(&o.VDDBAT_CFG.Reg, volatile.LoadUint32(&o.VDDBAT_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetVDDBAT_CFG_VDDBAT_SW_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.VDDBAT_CFG.Reg) & 0x80000000) >> 31
}

// PMU.BACKUP_CFG: need_des
func (o *PMU_Type) SetBACKUP_CFG_BACKUP_SYS_CLK_NO_DIV(value uint32) {
	volatile.StoreUint32(&o.BACKUP_CFG.Reg, volatile.LoadUint32(&o.BACKUP_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetBACKUP_CFG_BACKUP_SYS_CLK_NO_DIV() uint32 {
	return (volatile.LoadUint32(&o.BACKUP_CFG.Reg) & 0x80000000) >> 31
}

// PMU.INT_RAW: need_des
func (o *PMU_Type) SetINT_RAW_LP_CPU_EXC_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetINT_RAW_LP_CPU_EXC_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetINT_RAW_SDIO_IDLE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetINT_RAW_SDIO_IDLE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetINT_RAW_SW_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetINT_RAW_SW_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetINT_RAW_SOC_SLEEP_REJECT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetINT_RAW_SOC_SLEEP_REJECT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetINT_RAW_SOC_WAKEUP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetINT_RAW_SOC_WAKEUP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000000) >> 31
}

// PMU.HP_INT_ST: need_des
func (o *PMU_Type) SetHP_INT_ST_LP_CPU_EXC_INT_ST(value uint32) {
	volatile.StoreUint32(&o.HP_INT_ST.Reg, volatile.LoadUint32(&o.HP_INT_ST.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_INT_ST_LP_CPU_EXC_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_ST.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_INT_ST_SDIO_IDLE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.HP_INT_ST.Reg, volatile.LoadUint32(&o.HP_INT_ST.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetHP_INT_ST_SDIO_IDLE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_ST.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetHP_INT_ST_SW_INT_ST(value uint32) {
	volatile.StoreUint32(&o.HP_INT_ST.Reg, volatile.LoadUint32(&o.HP_INT_ST.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_INT_ST_SW_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_ST.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_INT_ST_SOC_SLEEP_REJECT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.HP_INT_ST.Reg, volatile.LoadUint32(&o.HP_INT_ST.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_INT_ST_SOC_SLEEP_REJECT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_ST.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetHP_INT_ST_SOC_WAKEUP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.HP_INT_ST.Reg, volatile.LoadUint32(&o.HP_INT_ST.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_INT_ST_SOC_WAKEUP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_ST.Reg) & 0x80000000) >> 31
}

// PMU.HP_INT_ENA: need_des
func (o *PMU_Type) SetHP_INT_ENA_LP_CPU_EXC_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.HP_INT_ENA.Reg, volatile.LoadUint32(&o.HP_INT_ENA.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_INT_ENA_LP_CPU_EXC_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_ENA.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_INT_ENA_SDIO_IDLE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.HP_INT_ENA.Reg, volatile.LoadUint32(&o.HP_INT_ENA.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetHP_INT_ENA_SDIO_IDLE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_ENA.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetHP_INT_ENA_SW_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.HP_INT_ENA.Reg, volatile.LoadUint32(&o.HP_INT_ENA.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_INT_ENA_SW_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_ENA.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_INT_ENA_SOC_SLEEP_REJECT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.HP_INT_ENA.Reg, volatile.LoadUint32(&o.HP_INT_ENA.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_INT_ENA_SOC_SLEEP_REJECT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_ENA.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetHP_INT_ENA_SOC_WAKEUP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.HP_INT_ENA.Reg, volatile.LoadUint32(&o.HP_INT_ENA.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_INT_ENA_SOC_WAKEUP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_ENA.Reg) & 0x80000000) >> 31
}

// PMU.HP_INT_CLR: need_des
func (o *PMU_Type) SetHP_INT_CLR_LP_CPU_EXC_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.HP_INT_CLR.Reg, volatile.LoadUint32(&o.HP_INT_CLR.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetHP_INT_CLR_LP_CPU_EXC_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_CLR.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetHP_INT_CLR_SDIO_IDLE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.HP_INT_CLR.Reg, volatile.LoadUint32(&o.HP_INT_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetHP_INT_CLR_SDIO_IDLE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_CLR.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetHP_INT_CLR_SW_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.HP_INT_CLR.Reg, volatile.LoadUint32(&o.HP_INT_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetHP_INT_CLR_SW_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_CLR.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetHP_INT_CLR_SOC_SLEEP_REJECT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.HP_INT_CLR.Reg, volatile.LoadUint32(&o.HP_INT_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_INT_CLR_SOC_SLEEP_REJECT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_CLR.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetHP_INT_CLR_SOC_WAKEUP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.HP_INT_CLR.Reg, volatile.LoadUint32(&o.HP_INT_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_INT_CLR_SOC_WAKEUP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.HP_INT_CLR.Reg) & 0x80000000) >> 31
}

// PMU.LP_INT_RAW: need_des
func (o *PMU_Type) SetLP_INT_RAW_LP_CPU_WAKEUP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.LP_INT_RAW.Reg, volatile.LoadUint32(&o.LP_INT_RAW.Reg)&^(0x100000)|value<<20)
}
func (o *PMU_Type) GetLP_INT_RAW_LP_CPU_WAKEUP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_RAW.Reg) & 0x100000) >> 20
}
func (o *PMU_Type) SetLP_INT_RAW_MODEM_SWITCH_ACTIVE_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.LP_INT_RAW.Reg, volatile.LoadUint32(&o.LP_INT_RAW.Reg)&^(0x200000)|value<<21)
}
func (o *PMU_Type) GetLP_INT_RAW_MODEM_SWITCH_ACTIVE_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_RAW.Reg) & 0x200000) >> 21
}
func (o *PMU_Type) SetLP_INT_RAW_SLEEP_SWITCH_ACTIVE_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.LP_INT_RAW.Reg, volatile.LoadUint32(&o.LP_INT_RAW.Reg)&^(0x400000)|value<<22)
}
func (o *PMU_Type) GetLP_INT_RAW_SLEEP_SWITCH_ACTIVE_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_RAW.Reg) & 0x400000) >> 22
}
func (o *PMU_Type) SetLP_INT_RAW_SLEEP_SWITCH_MODEM_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.LP_INT_RAW.Reg, volatile.LoadUint32(&o.LP_INT_RAW.Reg)&^(0x800000)|value<<23)
}
func (o *PMU_Type) GetLP_INT_RAW_SLEEP_SWITCH_MODEM_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_RAW.Reg) & 0x800000) >> 23
}
func (o *PMU_Type) SetLP_INT_RAW_MODEM_SWITCH_SLEEP_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.LP_INT_RAW.Reg, volatile.LoadUint32(&o.LP_INT_RAW.Reg)&^(0x1000000)|value<<24)
}
func (o *PMU_Type) GetLP_INT_RAW_MODEM_SWITCH_SLEEP_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_RAW.Reg) & 0x1000000) >> 24
}
func (o *PMU_Type) SetLP_INT_RAW_ACTIVE_SWITCH_SLEEP_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.LP_INT_RAW.Reg, volatile.LoadUint32(&o.LP_INT_RAW.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetLP_INT_RAW_ACTIVE_SWITCH_SLEEP_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_RAW.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetLP_INT_RAW_MODEM_SWITCH_ACTIVE_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.LP_INT_RAW.Reg, volatile.LoadUint32(&o.LP_INT_RAW.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetLP_INT_RAW_MODEM_SWITCH_ACTIVE_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_RAW.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetLP_INT_RAW_SLEEP_SWITCH_ACTIVE_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.LP_INT_RAW.Reg, volatile.LoadUint32(&o.LP_INT_RAW.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetLP_INT_RAW_SLEEP_SWITCH_ACTIVE_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_RAW.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetLP_INT_RAW_SLEEP_SWITCH_MODEM_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.LP_INT_RAW.Reg, volatile.LoadUint32(&o.LP_INT_RAW.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetLP_INT_RAW_SLEEP_SWITCH_MODEM_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_RAW.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetLP_INT_RAW_MODEM_SWITCH_SLEEP_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.LP_INT_RAW.Reg, volatile.LoadUint32(&o.LP_INT_RAW.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetLP_INT_RAW_MODEM_SWITCH_SLEEP_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_RAW.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetLP_INT_RAW_ACTIVE_SWITCH_SLEEP_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.LP_INT_RAW.Reg, volatile.LoadUint32(&o.LP_INT_RAW.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetLP_INT_RAW_ACTIVE_SWITCH_SLEEP_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_RAW.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetLP_INT_RAW_HP_SW_TRIGGER_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.LP_INT_RAW.Reg, volatile.LoadUint32(&o.LP_INT_RAW.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetLP_INT_RAW_HP_SW_TRIGGER_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_RAW.Reg) & 0x80000000) >> 31
}

// PMU.LP_INT_ST: need_des
func (o *PMU_Type) SetLP_INT_ST_LP_CPU_WAKEUP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ST.Reg, volatile.LoadUint32(&o.LP_INT_ST.Reg)&^(0x100000)|value<<20)
}
func (o *PMU_Type) GetLP_INT_ST_LP_CPU_WAKEUP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ST.Reg) & 0x100000) >> 20
}
func (o *PMU_Type) SetLP_INT_ST_MODEM_SWITCH_ACTIVE_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ST.Reg, volatile.LoadUint32(&o.LP_INT_ST.Reg)&^(0x200000)|value<<21)
}
func (o *PMU_Type) GetLP_INT_ST_MODEM_SWITCH_ACTIVE_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ST.Reg) & 0x200000) >> 21
}
func (o *PMU_Type) SetLP_INT_ST_SLEEP_SWITCH_ACTIVE_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ST.Reg, volatile.LoadUint32(&o.LP_INT_ST.Reg)&^(0x400000)|value<<22)
}
func (o *PMU_Type) GetLP_INT_ST_SLEEP_SWITCH_ACTIVE_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ST.Reg) & 0x400000) >> 22
}
func (o *PMU_Type) SetLP_INT_ST_SLEEP_SWITCH_MODEM_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ST.Reg, volatile.LoadUint32(&o.LP_INT_ST.Reg)&^(0x800000)|value<<23)
}
func (o *PMU_Type) GetLP_INT_ST_SLEEP_SWITCH_MODEM_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ST.Reg) & 0x800000) >> 23
}
func (o *PMU_Type) SetLP_INT_ST_MODEM_SWITCH_SLEEP_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ST.Reg, volatile.LoadUint32(&o.LP_INT_ST.Reg)&^(0x1000000)|value<<24)
}
func (o *PMU_Type) GetLP_INT_ST_MODEM_SWITCH_SLEEP_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ST.Reg) & 0x1000000) >> 24
}
func (o *PMU_Type) SetLP_INT_ST_ACTIVE_SWITCH_SLEEP_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ST.Reg, volatile.LoadUint32(&o.LP_INT_ST.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetLP_INT_ST_ACTIVE_SWITCH_SLEEP_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ST.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetLP_INT_ST_MODEM_SWITCH_ACTIVE_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ST.Reg, volatile.LoadUint32(&o.LP_INT_ST.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetLP_INT_ST_MODEM_SWITCH_ACTIVE_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ST.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetLP_INT_ST_SLEEP_SWITCH_ACTIVE_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ST.Reg, volatile.LoadUint32(&o.LP_INT_ST.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetLP_INT_ST_SLEEP_SWITCH_ACTIVE_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ST.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetLP_INT_ST_SLEEP_SWITCH_MODEM_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ST.Reg, volatile.LoadUint32(&o.LP_INT_ST.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetLP_INT_ST_SLEEP_SWITCH_MODEM_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ST.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetLP_INT_ST_MODEM_SWITCH_SLEEP_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ST.Reg, volatile.LoadUint32(&o.LP_INT_ST.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetLP_INT_ST_MODEM_SWITCH_SLEEP_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ST.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetLP_INT_ST_ACTIVE_SWITCH_SLEEP_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ST.Reg, volatile.LoadUint32(&o.LP_INT_ST.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetLP_INT_ST_ACTIVE_SWITCH_SLEEP_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ST.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetLP_INT_ST_HP_SW_TRIGGER_INT_ST(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ST.Reg, volatile.LoadUint32(&o.LP_INT_ST.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetLP_INT_ST_HP_SW_TRIGGER_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ST.Reg) & 0x80000000) >> 31
}

// PMU.LP_INT_ENA: need_des
func (o *PMU_Type) SetLP_INT_ENA_LP_CPU_WAKEUP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ENA.Reg, volatile.LoadUint32(&o.LP_INT_ENA.Reg)&^(0x100000)|value<<20)
}
func (o *PMU_Type) GetLP_INT_ENA_LP_CPU_WAKEUP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ENA.Reg) & 0x100000) >> 20
}
func (o *PMU_Type) SetLP_INT_ENA_MODEM_SWITCH_ACTIVE_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ENA.Reg, volatile.LoadUint32(&o.LP_INT_ENA.Reg)&^(0x200000)|value<<21)
}
func (o *PMU_Type) GetLP_INT_ENA_MODEM_SWITCH_ACTIVE_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ENA.Reg) & 0x200000) >> 21
}
func (o *PMU_Type) SetLP_INT_ENA_SLEEP_SWITCH_ACTIVE_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ENA.Reg, volatile.LoadUint32(&o.LP_INT_ENA.Reg)&^(0x400000)|value<<22)
}
func (o *PMU_Type) GetLP_INT_ENA_SLEEP_SWITCH_ACTIVE_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ENA.Reg) & 0x400000) >> 22
}
func (o *PMU_Type) SetLP_INT_ENA_SLEEP_SWITCH_MODEM_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ENA.Reg, volatile.LoadUint32(&o.LP_INT_ENA.Reg)&^(0x800000)|value<<23)
}
func (o *PMU_Type) GetLP_INT_ENA_SLEEP_SWITCH_MODEM_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ENA.Reg) & 0x800000) >> 23
}
func (o *PMU_Type) SetLP_INT_ENA_MODEM_SWITCH_SLEEP_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ENA.Reg, volatile.LoadUint32(&o.LP_INT_ENA.Reg)&^(0x1000000)|value<<24)
}
func (o *PMU_Type) GetLP_INT_ENA_MODEM_SWITCH_SLEEP_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ENA.Reg) & 0x1000000) >> 24
}
func (o *PMU_Type) SetLP_INT_ENA_ACTIVE_SWITCH_SLEEP_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ENA.Reg, volatile.LoadUint32(&o.LP_INT_ENA.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetLP_INT_ENA_ACTIVE_SWITCH_SLEEP_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ENA.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetLP_INT_ENA_MODEM_SWITCH_ACTIVE_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ENA.Reg, volatile.LoadUint32(&o.LP_INT_ENA.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetLP_INT_ENA_MODEM_SWITCH_ACTIVE_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ENA.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetLP_INT_ENA_SLEEP_SWITCH_ACTIVE_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ENA.Reg, volatile.LoadUint32(&o.LP_INT_ENA.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetLP_INT_ENA_SLEEP_SWITCH_ACTIVE_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ENA.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetLP_INT_ENA_SLEEP_SWITCH_MODEM_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ENA.Reg, volatile.LoadUint32(&o.LP_INT_ENA.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetLP_INT_ENA_SLEEP_SWITCH_MODEM_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ENA.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetLP_INT_ENA_MODEM_SWITCH_SLEEP_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ENA.Reg, volatile.LoadUint32(&o.LP_INT_ENA.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetLP_INT_ENA_MODEM_SWITCH_SLEEP_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ENA.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetLP_INT_ENA_ACTIVE_SWITCH_SLEEP_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ENA.Reg, volatile.LoadUint32(&o.LP_INT_ENA.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetLP_INT_ENA_ACTIVE_SWITCH_SLEEP_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ENA.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetLP_INT_ENA_HP_SW_TRIGGER_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.LP_INT_ENA.Reg, volatile.LoadUint32(&o.LP_INT_ENA.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetLP_INT_ENA_HP_SW_TRIGGER_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_ENA.Reg) & 0x80000000) >> 31
}

// PMU.LP_INT_CLR: need_des
func (o *PMU_Type) SetLP_INT_CLR_LP_CPU_WAKEUP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.LP_INT_CLR.Reg, volatile.LoadUint32(&o.LP_INT_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *PMU_Type) GetLP_INT_CLR_LP_CPU_WAKEUP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_CLR.Reg) & 0x100000) >> 20
}
func (o *PMU_Type) SetLP_INT_CLR_MODEM_SWITCH_ACTIVE_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.LP_INT_CLR.Reg, volatile.LoadUint32(&o.LP_INT_CLR.Reg)&^(0x200000)|value<<21)
}
func (o *PMU_Type) GetLP_INT_CLR_MODEM_SWITCH_ACTIVE_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_CLR.Reg) & 0x200000) >> 21
}
func (o *PMU_Type) SetLP_INT_CLR_SLEEP_SWITCH_ACTIVE_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.LP_INT_CLR.Reg, volatile.LoadUint32(&o.LP_INT_CLR.Reg)&^(0x400000)|value<<22)
}
func (o *PMU_Type) GetLP_INT_CLR_SLEEP_SWITCH_ACTIVE_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_CLR.Reg) & 0x400000) >> 22
}
func (o *PMU_Type) SetLP_INT_CLR_SLEEP_SWITCH_MODEM_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.LP_INT_CLR.Reg, volatile.LoadUint32(&o.LP_INT_CLR.Reg)&^(0x800000)|value<<23)
}
func (o *PMU_Type) GetLP_INT_CLR_SLEEP_SWITCH_MODEM_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_CLR.Reg) & 0x800000) >> 23
}
func (o *PMU_Type) SetLP_INT_CLR_MODEM_SWITCH_SLEEP_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.LP_INT_CLR.Reg, volatile.LoadUint32(&o.LP_INT_CLR.Reg)&^(0x1000000)|value<<24)
}
func (o *PMU_Type) GetLP_INT_CLR_MODEM_SWITCH_SLEEP_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_CLR.Reg) & 0x1000000) >> 24
}
func (o *PMU_Type) SetLP_INT_CLR_ACTIVE_SWITCH_SLEEP_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.LP_INT_CLR.Reg, volatile.LoadUint32(&o.LP_INT_CLR.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetLP_INT_CLR_ACTIVE_SWITCH_SLEEP_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_CLR.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetLP_INT_CLR_MODEM_SWITCH_ACTIVE_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.LP_INT_CLR.Reg, volatile.LoadUint32(&o.LP_INT_CLR.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetLP_INT_CLR_MODEM_SWITCH_ACTIVE_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_CLR.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetLP_INT_CLR_SLEEP_SWITCH_ACTIVE_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.LP_INT_CLR.Reg, volatile.LoadUint32(&o.LP_INT_CLR.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetLP_INT_CLR_SLEEP_SWITCH_ACTIVE_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_CLR.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetLP_INT_CLR_SLEEP_SWITCH_MODEM_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.LP_INT_CLR.Reg, volatile.LoadUint32(&o.LP_INT_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetLP_INT_CLR_SLEEP_SWITCH_MODEM_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_CLR.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetLP_INT_CLR_MODEM_SWITCH_SLEEP_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.LP_INT_CLR.Reg, volatile.LoadUint32(&o.LP_INT_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetLP_INT_CLR_MODEM_SWITCH_SLEEP_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_CLR.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetLP_INT_CLR_ACTIVE_SWITCH_SLEEP_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.LP_INT_CLR.Reg, volatile.LoadUint32(&o.LP_INT_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetLP_INT_CLR_ACTIVE_SWITCH_SLEEP_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_CLR.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetLP_INT_CLR_HP_SW_TRIGGER_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.LP_INT_CLR.Reg, volatile.LoadUint32(&o.LP_INT_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetLP_INT_CLR_HP_SW_TRIGGER_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.LP_INT_CLR.Reg) & 0x80000000) >> 31
}

// PMU.LP_CPU_PWR0: need_des
func (o *PMU_Type) SetLP_CPU_PWR0_LP_CPU_WAITI_RDY(value uint32) {
	volatile.StoreUint32(&o.LP_CPU_PWR0.Reg, volatile.LoadUint32(&o.LP_CPU_PWR0.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetLP_CPU_PWR0_LP_CPU_WAITI_RDY() uint32 {
	return volatile.LoadUint32(&o.LP_CPU_PWR0.Reg) & 0x1
}
func (o *PMU_Type) SetLP_CPU_PWR0_LP_CPU_STALL_RDY(value uint32) {
	volatile.StoreUint32(&o.LP_CPU_PWR0.Reg, volatile.LoadUint32(&o.LP_CPU_PWR0.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetLP_CPU_PWR0_LP_CPU_STALL_RDY() uint32 {
	return (volatile.LoadUint32(&o.LP_CPU_PWR0.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetLP_CPU_PWR0_LP_CPU_FORCE_STALL(value uint32) {
	volatile.StoreUint32(&o.LP_CPU_PWR0.Reg, volatile.LoadUint32(&o.LP_CPU_PWR0.Reg)&^(0x40000)|value<<18)
}
func (o *PMU_Type) GetLP_CPU_PWR0_LP_CPU_FORCE_STALL() uint32 {
	return (volatile.LoadUint32(&o.LP_CPU_PWR0.Reg) & 0x40000) >> 18
}
func (o *PMU_Type) SetLP_CPU_PWR0_LP_CPU_SLP_WAITI_FLAG_EN(value uint32) {
	volatile.StoreUint32(&o.LP_CPU_PWR0.Reg, volatile.LoadUint32(&o.LP_CPU_PWR0.Reg)&^(0x80000)|value<<19)
}
func (o *PMU_Type) GetLP_CPU_PWR0_LP_CPU_SLP_WAITI_FLAG_EN() uint32 {
	return (volatile.LoadUint32(&o.LP_CPU_PWR0.Reg) & 0x80000) >> 19
}
func (o *PMU_Type) SetLP_CPU_PWR0_LP_CPU_SLP_STALL_FLAG_EN(value uint32) {
	volatile.StoreUint32(&o.LP_CPU_PWR0.Reg, volatile.LoadUint32(&o.LP_CPU_PWR0.Reg)&^(0x100000)|value<<20)
}
func (o *PMU_Type) GetLP_CPU_PWR0_LP_CPU_SLP_STALL_FLAG_EN() uint32 {
	return (volatile.LoadUint32(&o.LP_CPU_PWR0.Reg) & 0x100000) >> 20
}
func (o *PMU_Type) SetLP_CPU_PWR0_LP_CPU_SLP_STALL_WAIT(value uint32) {
	volatile.StoreUint32(&o.LP_CPU_PWR0.Reg, volatile.LoadUint32(&o.LP_CPU_PWR0.Reg)&^(0x1fe00000)|value<<21)
}
func (o *PMU_Type) GetLP_CPU_PWR0_LP_CPU_SLP_STALL_WAIT() uint32 {
	return (volatile.LoadUint32(&o.LP_CPU_PWR0.Reg) & 0x1fe00000) >> 21
}
func (o *PMU_Type) SetLP_CPU_PWR0_LP_CPU_SLP_STALL_EN(value uint32) {
	volatile.StoreUint32(&o.LP_CPU_PWR0.Reg, volatile.LoadUint32(&o.LP_CPU_PWR0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetLP_CPU_PWR0_LP_CPU_SLP_STALL_EN() uint32 {
	return (volatile.LoadUint32(&o.LP_CPU_PWR0.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetLP_CPU_PWR0_LP_CPU_SLP_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.LP_CPU_PWR0.Reg, volatile.LoadUint32(&o.LP_CPU_PWR0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetLP_CPU_PWR0_LP_CPU_SLP_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.LP_CPU_PWR0.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetLP_CPU_PWR0_LP_CPU_SLP_BYPASS_INTR_EN(value uint32) {
	volatile.StoreUint32(&o.LP_CPU_PWR0.Reg, volatile.LoadUint32(&o.LP_CPU_PWR0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetLP_CPU_PWR0_LP_CPU_SLP_BYPASS_INTR_EN() uint32 {
	return (volatile.LoadUint32(&o.LP_CPU_PWR0.Reg) & 0x80000000) >> 31
}

// PMU.LP_CPU_PWR1: need_des
func (o *PMU_Type) SetLP_CPU_PWR1_LP_CPU_WAKEUP_EN(value uint32) {
	volatile.StoreUint32(&o.LP_CPU_PWR1.Reg, volatile.LoadUint32(&o.LP_CPU_PWR1.Reg)&^(0xffff)|value)
}
func (o *PMU_Type) GetLP_CPU_PWR1_LP_CPU_WAKEUP_EN() uint32 {
	return volatile.LoadUint32(&o.LP_CPU_PWR1.Reg) & 0xffff
}
func (o *PMU_Type) SetLP_CPU_PWR1_LP_CPU_SLEEP_REQ(value uint32) {
	volatile.StoreUint32(&o.LP_CPU_PWR1.Reg, volatile.LoadUint32(&o.LP_CPU_PWR1.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetLP_CPU_PWR1_LP_CPU_SLEEP_REQ() uint32 {
	return (volatile.LoadUint32(&o.LP_CPU_PWR1.Reg) & 0x80000000) >> 31
}

// PMU.HP_LP_CPU_COMM: need_des
func (o *PMU_Type) SetHP_LP_CPU_COMM_LP_TRIGGER_HP(value uint32) {
	volatile.StoreUint32(&o.HP_LP_CPU_COMM.Reg, volatile.LoadUint32(&o.HP_LP_CPU_COMM.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetHP_LP_CPU_COMM_LP_TRIGGER_HP() uint32 {
	return (volatile.LoadUint32(&o.HP_LP_CPU_COMM.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetHP_LP_CPU_COMM_HP_TRIGGER_LP(value uint32) {
	volatile.StoreUint32(&o.HP_LP_CPU_COMM.Reg, volatile.LoadUint32(&o.HP_LP_CPU_COMM.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_LP_CPU_COMM_HP_TRIGGER_LP() uint32 {
	return (volatile.LoadUint32(&o.HP_LP_CPU_COMM.Reg) & 0x80000000) >> 31
}

// PMU.HP_REGULATOR_CFG: need_des
func (o *PMU_Type) SetHP_REGULATOR_CFG_DIG_REGULATOR_EN_CAL(value uint32) {
	volatile.StoreUint32(&o.HP_REGULATOR_CFG.Reg, volatile.LoadUint32(&o.HP_REGULATOR_CFG.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetHP_REGULATOR_CFG_DIG_REGULATOR_EN_CAL() uint32 {
	return (volatile.LoadUint32(&o.HP_REGULATOR_CFG.Reg) & 0x80000000) >> 31
}

// PMU.MAIN_STATE: need_des
func (o *PMU_Type) SetMAIN_STATE_MAIN_LAST_ST_STATE(value uint32) {
	volatile.StoreUint32(&o.MAIN_STATE.Reg, volatile.LoadUint32(&o.MAIN_STATE.Reg)&^(0x3f800)|value<<11)
}
func (o *PMU_Type) GetMAIN_STATE_MAIN_LAST_ST_STATE() uint32 {
	return (volatile.LoadUint32(&o.MAIN_STATE.Reg) & 0x3f800) >> 11
}
func (o *PMU_Type) SetMAIN_STATE_MAIN_TAR_ST_STATE(value uint32) {
	volatile.StoreUint32(&o.MAIN_STATE.Reg, volatile.LoadUint32(&o.MAIN_STATE.Reg)&^(0x1fc0000)|value<<18)
}
func (o *PMU_Type) GetMAIN_STATE_MAIN_TAR_ST_STATE() uint32 {
	return (volatile.LoadUint32(&o.MAIN_STATE.Reg) & 0x1fc0000) >> 18
}
func (o *PMU_Type) SetMAIN_STATE_MAIN_CUR_ST_STATE(value uint32) {
	volatile.StoreUint32(&o.MAIN_STATE.Reg, volatile.LoadUint32(&o.MAIN_STATE.Reg)&^(0xfe000000)|value<<25)
}
func (o *PMU_Type) GetMAIN_STATE_MAIN_CUR_ST_STATE() uint32 {
	return (volatile.LoadUint32(&o.MAIN_STATE.Reg) & 0xfe000000) >> 25
}

// PMU.PWR_STATE: need_des
func (o *PMU_Type) SetPWR_STATE_BACKUP_ST_STATE(value uint32) {
	volatile.StoreUint32(&o.PWR_STATE.Reg, volatile.LoadUint32(&o.PWR_STATE.Reg)&^(0x3e000)|value<<13)
}
func (o *PMU_Type) GetPWR_STATE_BACKUP_ST_STATE() uint32 {
	return (volatile.LoadUint32(&o.PWR_STATE.Reg) & 0x3e000) >> 13
}
func (o *PMU_Type) SetPWR_STATE_LP_PWR_ST_STATE(value uint32) {
	volatile.StoreUint32(&o.PWR_STATE.Reg, volatile.LoadUint32(&o.PWR_STATE.Reg)&^(0x7c0000)|value<<18)
}
func (o *PMU_Type) GetPWR_STATE_LP_PWR_ST_STATE() uint32 {
	return (volatile.LoadUint32(&o.PWR_STATE.Reg) & 0x7c0000) >> 18
}
func (o *PMU_Type) SetPWR_STATE_HP_PWR_ST_STATE(value uint32) {
	volatile.StoreUint32(&o.PWR_STATE.Reg, volatile.LoadUint32(&o.PWR_STATE.Reg)&^(0xff800000)|value<<23)
}
func (o *PMU_Type) GetPWR_STATE_HP_PWR_ST_STATE() uint32 {
	return (volatile.LoadUint32(&o.PWR_STATE.Reg) & 0xff800000) >> 23
}

// PMU.CLK_STATE0: need_des
func (o *PMU_Type) SetCLK_STATE0_STABLE_XPD_BBPLL_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetCLK_STATE0_STABLE_XPD_BBPLL_STATE() uint32 {
	return volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x1
}
func (o *PMU_Type) SetCLK_STATE0_STABLE_XPD_XTAL_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetCLK_STATE0_STABLE_XPD_XTAL_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetCLK_STATE0_SYS_CLK_SLP_SEL_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x8000)|value<<15)
}
func (o *PMU_Type) GetCLK_STATE0_SYS_CLK_SLP_SEL_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x8000) >> 15
}
func (o *PMU_Type) SetCLK_STATE0_SYS_CLK_SEL_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x30000)|value<<16)
}
func (o *PMU_Type) GetCLK_STATE0_SYS_CLK_SEL_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x30000) >> 16
}
func (o *PMU_Type) SetCLK_STATE0_SYS_CLK_NO_DIV_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x40000)|value<<18)
}
func (o *PMU_Type) GetCLK_STATE0_SYS_CLK_NO_DIV_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x40000) >> 18
}
func (o *PMU_Type) SetCLK_STATE0_ICG_SYS_CLK_EN_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x80000)|value<<19)
}
func (o *PMU_Type) GetCLK_STATE0_ICG_SYS_CLK_EN_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x80000) >> 19
}
func (o *PMU_Type) SetCLK_STATE0_ICG_MODEM_SWITCH_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x100000)|value<<20)
}
func (o *PMU_Type) GetCLK_STATE0_ICG_MODEM_SWITCH_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x100000) >> 20
}
func (o *PMU_Type) SetCLK_STATE0_ICG_MODEM_CODE_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x600000)|value<<21)
}
func (o *PMU_Type) GetCLK_STATE0_ICG_MODEM_CODE_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x600000) >> 21
}
func (o *PMU_Type) SetCLK_STATE0_ICG_SLP_SEL_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x800000)|value<<23)
}
func (o *PMU_Type) GetCLK_STATE0_ICG_SLP_SEL_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x800000) >> 23
}
func (o *PMU_Type) SetCLK_STATE0_ICG_GLOBAL_XTAL_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMU_Type) GetCLK_STATE0_ICG_GLOBAL_XTAL_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x1000000) >> 24
}
func (o *PMU_Type) SetCLK_STATE0_ICG_GLOBAL_PLL_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetCLK_STATE0_ICG_GLOBAL_PLL_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetCLK_STATE0_ANA_I2C_ISO_EN_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMU_Type) GetCLK_STATE0_ANA_I2C_ISO_EN_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x4000000) >> 26
}
func (o *PMU_Type) SetCLK_STATE0_ANA_I2C_RETENTION_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetCLK_STATE0_ANA_I2C_RETENTION_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetCLK_STATE0_ANA_XPD_BB_I2C_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetCLK_STATE0_ANA_XPD_BB_I2C_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetCLK_STATE0_ANA_XPD_BBPLL_I2C_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetCLK_STATE0_ANA_XPD_BBPLL_I2C_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetCLK_STATE0_ANA_XPD_BBPLL_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetCLK_STATE0_ANA_XPD_BBPLL_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetCLK_STATE0_ANA_XPD_XTAL_STATE(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE0.Reg, volatile.LoadUint32(&o.CLK_STATE0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetCLK_STATE0_ANA_XPD_XTAL_STATE() uint32 {
	return (volatile.LoadUint32(&o.CLK_STATE0.Reg) & 0x80000000) >> 31
}

// PMU.CLK_STATE1: need_des
func (o *PMU_Type) SetCLK_STATE1(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE1.Reg, value)
}
func (o *PMU_Type) GetCLK_STATE1() uint32 {
	return volatile.LoadUint32(&o.CLK_STATE1.Reg)
}

// PMU.CLK_STATE2: need_des
func (o *PMU_Type) SetCLK_STATE2(value uint32) {
	volatile.StoreUint32(&o.CLK_STATE2.Reg, value)
}
func (o *PMU_Type) GetCLK_STATE2() uint32 {
	return volatile.LoadUint32(&o.CLK_STATE2.Reg)
}

// PMU.VDD_SPI_STATUS: need_des
func (o *PMU_Type) SetVDD_SPI_STATUS_STABLE_VDD_SPI_PWR_DRV(value uint32) {
	volatile.StoreUint32(&o.VDD_SPI_STATUS.Reg, volatile.LoadUint32(&o.VDD_SPI_STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetVDD_SPI_STATUS_STABLE_VDD_SPI_PWR_DRV() uint32 {
	return (volatile.LoadUint32(&o.VDD_SPI_STATUS.Reg) & 0x80000000) >> 31
}

// PMU.DATE: need_des
func (o *PMU_Type) SetDATE_PMU_DATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x7fffffff)|value)
}
func (o *PMU_Type) GetDATE_PMU_DATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x7fffffff
}
func (o *PMU_Type) SetDATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetDATE_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.DATE.Reg) & 0x80000000) >> 31
}

// Remote Control
type RMT_Type struct {
	CH0DATA           volatile.Register32 // 0x0
	CH1DATA           volatile.Register32 // 0x4
	CH2DATA           volatile.Register32 // 0x8
	CH3DATA           volatile.Register32 // 0xC
	CH0_TX_CONF0      volatile.Register32 // 0x10
	CH1_TX_CONF0      volatile.Register32 // 0x14
	CH2_RX_CONF0      volatile.Register32 // 0x18
	CH2_RX_CONF1      volatile.Register32 // 0x1C
	CH3_RX_CONF0      volatile.Register32 // 0x20
	CH3_RX_CONF1      volatile.Register32 // 0x24
	CH0_TX_STATUS     volatile.Register32 // 0x28
	CH1_TX_STATUS     volatile.Register32 // 0x2C
	CH0_RX_STATUS     volatile.Register32 // 0x30
	CH1_RX_STATUS     volatile.Register32 // 0x34
	INT_RAW           volatile.Register32 // 0x38
	INT_ST            volatile.Register32 // 0x3C
	INT_ENA           volatile.Register32 // 0x40
	INT_CLR           volatile.Register32 // 0x44
	CH0CARRIER_DUTY   volatile.Register32 // 0x48
	CH1CARRIER_DUTY   volatile.Register32 // 0x4C
	CH0_RX_CARRIER_RM volatile.Register32 // 0x50
	CH1_RX_CARRIER_RM volatile.Register32 // 0x54
	CH0_TX_LIM        volatile.Register32 // 0x58
	CH1_TX_LIM        volatile.Register32 // 0x5C
	CH0_RX_LIM        volatile.Register32 // 0x60
	CH1_RX_LIM        volatile.Register32 // 0x64
	SYS_CONF          volatile.Register32 // 0x68
	TX_SIM            volatile.Register32 // 0x6C
	REF_CNT_RST       volatile.Register32 // 0x70
	_                 [88]byte
	DATE              volatile.Register32 // 0xCC
}

// RMT.CH0DATA: The read and write data register for CHANNEL%s by apb fifo access.
func (o *RMT_Type) SetCH0DATA(value uint32) {
	volatile.StoreUint32(&o.CH0DATA.Reg, value)
}
func (o *RMT_Type) GetCH0DATA() uint32 {
	return volatile.LoadUint32(&o.CH0DATA.Reg)
}

// RMT.CH1DATA: The read and write data register for CHANNEL%s by apb fifo access.
func (o *RMT_Type) SetCH1DATA(value uint32) {
	volatile.StoreUint32(&o.CH1DATA.Reg, value)
}
func (o *RMT_Type) GetCH1DATA() uint32 {
	return volatile.LoadUint32(&o.CH1DATA.Reg)
}

// RMT.CH2DATA: The read and write data register for CHANNEL%s by apb fifo access.
func (o *RMT_Type) SetCH2DATA(value uint32) {
	volatile.StoreUint32(&o.CH2DATA.Reg, value)
}
func (o *RMT_Type) GetCH2DATA() uint32 {
	return volatile.LoadUint32(&o.CH2DATA.Reg)
}

// RMT.CH3DATA: The read and write data register for CHANNEL%s by apb fifo access.
func (o *RMT_Type) SetCH3DATA(value uint32) {
	volatile.StoreUint32(&o.CH3DATA.Reg, value)
}
func (o *RMT_Type) GetCH3DATA() uint32 {
	return volatile.LoadUint32(&o.CH3DATA.Reg)
}

// RMT.CH0_TX_CONF0: Channel %s configure register 0
func (o *RMT_Type) SetCH0_TX_CONF0_TX_START(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetCH0_TX_CONF0_TX_START() uint32 {
	return volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x1
}
func (o *RMT_Type) SetCH0_TX_CONF0_MEM_RD_RST(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetCH0_TX_CONF0_MEM_RD_RST() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetCH0_TX_CONF0_APB_MEM_RST(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetCH0_TX_CONF0_APB_MEM_RST() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetCH0_TX_CONF0_TX_CONTI_MODE(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetCH0_TX_CONF0_TX_CONTI_MODE() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetCH0_TX_CONF0_MEM_TX_WRAP_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetCH0_TX_CONF0_MEM_TX_WRAP_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetCH0_TX_CONF0_IDLE_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetCH0_TX_CONF0_IDLE_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetCH0_TX_CONF0_IDLE_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetCH0_TX_CONF0_IDLE_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetCH0_TX_CONF0_TX_STOP(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetCH0_TX_CONF0_TX_STOP() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetCH0_TX_CONF0_DIV_CNT(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0xff00)|value<<8)
}
func (o *RMT_Type) GetCH0_TX_CONF0_DIV_CNT() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0xff00) >> 8
}
func (o *RMT_Type) SetCH0_TX_CONF0_MEM_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x70000)|value<<16)
}
func (o *RMT_Type) GetCH0_TX_CONF0_MEM_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x70000) >> 16
}
func (o *RMT_Type) SetCH0_TX_CONF0_CARRIER_EFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH0_TX_CONF0_CARRIER_EFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x100000) >> 20
}
func (o *RMT_Type) SetCH0_TX_CONF0_CARRIER_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x200000)|value<<21)
}
func (o *RMT_Type) GetCH0_TX_CONF0_CARRIER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x200000) >> 21
}
func (o *RMT_Type) SetCH0_TX_CONF0_CARRIER_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x400000)|value<<22)
}
func (o *RMT_Type) GetCH0_TX_CONF0_CARRIER_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x400000) >> 22
}
func (o *RMT_Type) SetCH0_TX_CONF0_AFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x800000)|value<<23)
}
func (o *RMT_Type) GetCH0_TX_CONF0_AFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x800000) >> 23
}
func (o *RMT_Type) SetCH0_TX_CONF0_CONF_UPDATE(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_CONF0.Reg, volatile.LoadUint32(&o.CH0_TX_CONF0.Reg)&^(0x1000000)|value<<24)
}
func (o *RMT_Type) GetCH0_TX_CONF0_CONF_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_CONF0.Reg) & 0x1000000) >> 24
}

// RMT.CH1_TX_CONF0: Channel %s configure register 0
func (o *RMT_Type) SetCH1_TX_CONF0_TX_START(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetCH1_TX_CONF0_TX_START() uint32 {
	return volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x1
}
func (o *RMT_Type) SetCH1_TX_CONF0_MEM_RD_RST(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetCH1_TX_CONF0_MEM_RD_RST() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetCH1_TX_CONF0_APB_MEM_RST(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetCH1_TX_CONF0_APB_MEM_RST() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetCH1_TX_CONF0_TX_CONTI_MODE(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetCH1_TX_CONF0_TX_CONTI_MODE() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetCH1_TX_CONF0_MEM_TX_WRAP_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetCH1_TX_CONF0_MEM_TX_WRAP_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetCH1_TX_CONF0_IDLE_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetCH1_TX_CONF0_IDLE_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetCH1_TX_CONF0_IDLE_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetCH1_TX_CONF0_IDLE_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetCH1_TX_CONF0_TX_STOP(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetCH1_TX_CONF0_TX_STOP() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetCH1_TX_CONF0_DIV_CNT(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0xff00)|value<<8)
}
func (o *RMT_Type) GetCH1_TX_CONF0_DIV_CNT() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0xff00) >> 8
}
func (o *RMT_Type) SetCH1_TX_CONF0_MEM_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x70000)|value<<16)
}
func (o *RMT_Type) GetCH1_TX_CONF0_MEM_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x70000) >> 16
}
func (o *RMT_Type) SetCH1_TX_CONF0_CARRIER_EFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH1_TX_CONF0_CARRIER_EFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x100000) >> 20
}
func (o *RMT_Type) SetCH1_TX_CONF0_CARRIER_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x200000)|value<<21)
}
func (o *RMT_Type) GetCH1_TX_CONF0_CARRIER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x200000) >> 21
}
func (o *RMT_Type) SetCH1_TX_CONF0_CARRIER_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x400000)|value<<22)
}
func (o *RMT_Type) GetCH1_TX_CONF0_CARRIER_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x400000) >> 22
}
func (o *RMT_Type) SetCH1_TX_CONF0_AFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x800000)|value<<23)
}
func (o *RMT_Type) GetCH1_TX_CONF0_AFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x800000) >> 23
}
func (o *RMT_Type) SetCH1_TX_CONF0_CONF_UPDATE(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_CONF0.Reg, volatile.LoadUint32(&o.CH1_TX_CONF0.Reg)&^(0x1000000)|value<<24)
}
func (o *RMT_Type) GetCH1_TX_CONF0_CONF_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_CONF0.Reg) & 0x1000000) >> 24
}

// RMT.CH2_RX_CONF0: Channel %s configure register 0
func (o *RMT_Type) SetCH2_RX_CONF0_DIV_CNT(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF0.Reg, volatile.LoadUint32(&o.CH2_RX_CONF0.Reg)&^(0xff)|value)
}
func (o *RMT_Type) GetCH2_RX_CONF0_DIV_CNT() uint32 {
	return volatile.LoadUint32(&o.CH2_RX_CONF0.Reg) & 0xff
}
func (o *RMT_Type) SetCH2_RX_CONF0_IDLE_THRES(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF0.Reg, volatile.LoadUint32(&o.CH2_RX_CONF0.Reg)&^(0x7fff00)|value<<8)
}
func (o *RMT_Type) GetCH2_RX_CONF0_IDLE_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CONF0.Reg) & 0x7fff00) >> 8
}
func (o *RMT_Type) SetCH2_RX_CONF0_MEM_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF0.Reg, volatile.LoadUint32(&o.CH2_RX_CONF0.Reg)&^(0x3800000)|value<<23)
}
func (o *RMT_Type) GetCH2_RX_CONF0_MEM_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CONF0.Reg) & 0x3800000) >> 23
}
func (o *RMT_Type) SetCH2_RX_CONF0_CARRIER_EN(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF0.Reg, volatile.LoadUint32(&o.CH2_RX_CONF0.Reg)&^(0x10000000)|value<<28)
}
func (o *RMT_Type) GetCH2_RX_CONF0_CARRIER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CONF0.Reg) & 0x10000000) >> 28
}
func (o *RMT_Type) SetCH2_RX_CONF0_CARRIER_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF0.Reg, volatile.LoadUint32(&o.CH2_RX_CONF0.Reg)&^(0x20000000)|value<<29)
}
func (o *RMT_Type) GetCH2_RX_CONF0_CARRIER_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CONF0.Reg) & 0x20000000) >> 29
}

// RMT.CH2_RX_CONF1: Channel %s configure register 1
func (o *RMT_Type) SetCH2_RX_CONF1_RX_EN(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF1.Reg, volatile.LoadUint32(&o.CH2_RX_CONF1.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetCH2_RX_CONF1_RX_EN() uint32 {
	return volatile.LoadUint32(&o.CH2_RX_CONF1.Reg) & 0x1
}
func (o *RMT_Type) SetCH2_RX_CONF1_MEM_WR_RST(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF1.Reg, volatile.LoadUint32(&o.CH2_RX_CONF1.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetCH2_RX_CONF1_MEM_WR_RST() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CONF1.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetCH2_RX_CONF1_APB_MEM_RST(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF1.Reg, volatile.LoadUint32(&o.CH2_RX_CONF1.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetCH2_RX_CONF1_APB_MEM_RST() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CONF1.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetCH2_RX_CONF1_MEM_OWNER(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF1.Reg, volatile.LoadUint32(&o.CH2_RX_CONF1.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetCH2_RX_CONF1_MEM_OWNER() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CONF1.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetCH2_RX_CONF1_RX_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF1.Reg, volatile.LoadUint32(&o.CH2_RX_CONF1.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetCH2_RX_CONF1_RX_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CONF1.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetCH2_RX_CONF1_RX_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF1.Reg, volatile.LoadUint32(&o.CH2_RX_CONF1.Reg)&^(0x1fe0)|value<<5)
}
func (o *RMT_Type) GetCH2_RX_CONF1_RX_FILTER_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CONF1.Reg) & 0x1fe0) >> 5
}
func (o *RMT_Type) SetCH2_RX_CONF1_MEM_RX_WRAP_EN(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF1.Reg, volatile.LoadUint32(&o.CH2_RX_CONF1.Reg)&^(0x2000)|value<<13)
}
func (o *RMT_Type) GetCH2_RX_CONF1_MEM_RX_WRAP_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CONF1.Reg) & 0x2000) >> 13
}
func (o *RMT_Type) SetCH2_RX_CONF1_AFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF1.Reg, volatile.LoadUint32(&o.CH2_RX_CONF1.Reg)&^(0x4000)|value<<14)
}
func (o *RMT_Type) GetCH2_RX_CONF1_AFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CONF1.Reg) & 0x4000) >> 14
}
func (o *RMT_Type) SetCH2_RX_CONF1_CONF_UPDATE(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CONF1.Reg, volatile.LoadUint32(&o.CH2_RX_CONF1.Reg)&^(0x8000)|value<<15)
}
func (o *RMT_Type) GetCH2_RX_CONF1_CONF_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CONF1.Reg) & 0x8000) >> 15
}

// RMT.CH3_RX_CONF0: Channel %s configure register 0
func (o *RMT_Type) SetCH3_RX_CONF0_DIV_CNT(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF0.Reg, volatile.LoadUint32(&o.CH3_RX_CONF0.Reg)&^(0xff)|value)
}
func (o *RMT_Type) GetCH3_RX_CONF0_DIV_CNT() uint32 {
	return volatile.LoadUint32(&o.CH3_RX_CONF0.Reg) & 0xff
}
func (o *RMT_Type) SetCH3_RX_CONF0_IDLE_THRES(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF0.Reg, volatile.LoadUint32(&o.CH3_RX_CONF0.Reg)&^(0x7fff00)|value<<8)
}
func (o *RMT_Type) GetCH3_RX_CONF0_IDLE_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CONF0.Reg) & 0x7fff00) >> 8
}
func (o *RMT_Type) SetCH3_RX_CONF0_MEM_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF0.Reg, volatile.LoadUint32(&o.CH3_RX_CONF0.Reg)&^(0x3800000)|value<<23)
}
func (o *RMT_Type) GetCH3_RX_CONF0_MEM_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CONF0.Reg) & 0x3800000) >> 23
}
func (o *RMT_Type) SetCH3_RX_CONF0_CARRIER_EN(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF0.Reg, volatile.LoadUint32(&o.CH3_RX_CONF0.Reg)&^(0x10000000)|value<<28)
}
func (o *RMT_Type) GetCH3_RX_CONF0_CARRIER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CONF0.Reg) & 0x10000000) >> 28
}
func (o *RMT_Type) SetCH3_RX_CONF0_CARRIER_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF0.Reg, volatile.LoadUint32(&o.CH3_RX_CONF0.Reg)&^(0x20000000)|value<<29)
}
func (o *RMT_Type) GetCH3_RX_CONF0_CARRIER_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CONF0.Reg) & 0x20000000) >> 29
}

// RMT.CH3_RX_CONF1: Channel %s configure register 1
func (o *RMT_Type) SetCH3_RX_CONF1_RX_EN(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF1.Reg, volatile.LoadUint32(&o.CH3_RX_CONF1.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetCH3_RX_CONF1_RX_EN() uint32 {
	return volatile.LoadUint32(&o.CH3_RX_CONF1.Reg) & 0x1
}
func (o *RMT_Type) SetCH3_RX_CONF1_MEM_WR_RST(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF1.Reg, volatile.LoadUint32(&o.CH3_RX_CONF1.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetCH3_RX_CONF1_MEM_WR_RST() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CONF1.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetCH3_RX_CONF1_APB_MEM_RST(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF1.Reg, volatile.LoadUint32(&o.CH3_RX_CONF1.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetCH3_RX_CONF1_APB_MEM_RST() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CONF1.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetCH3_RX_CONF1_MEM_OWNER(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF1.Reg, volatile.LoadUint32(&o.CH3_RX_CONF1.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetCH3_RX_CONF1_MEM_OWNER() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CONF1.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetCH3_RX_CONF1_RX_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF1.Reg, volatile.LoadUint32(&o.CH3_RX_CONF1.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetCH3_RX_CONF1_RX_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CONF1.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetCH3_RX_CONF1_RX_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF1.Reg, volatile.LoadUint32(&o.CH3_RX_CONF1.Reg)&^(0x1fe0)|value<<5)
}
func (o *RMT_Type) GetCH3_RX_CONF1_RX_FILTER_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CONF1.Reg) & 0x1fe0) >> 5
}
func (o *RMT_Type) SetCH3_RX_CONF1_MEM_RX_WRAP_EN(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF1.Reg, volatile.LoadUint32(&o.CH3_RX_CONF1.Reg)&^(0x2000)|value<<13)
}
func (o *RMT_Type) GetCH3_RX_CONF1_MEM_RX_WRAP_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CONF1.Reg) & 0x2000) >> 13
}
func (o *RMT_Type) SetCH3_RX_CONF1_AFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF1.Reg, volatile.LoadUint32(&o.CH3_RX_CONF1.Reg)&^(0x4000)|value<<14)
}
func (o *RMT_Type) GetCH3_RX_CONF1_AFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CONF1.Reg) & 0x4000) >> 14
}
func (o *RMT_Type) SetCH3_RX_CONF1_CONF_UPDATE(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CONF1.Reg, volatile.LoadUint32(&o.CH3_RX_CONF1.Reg)&^(0x8000)|value<<15)
}
func (o *RMT_Type) GetCH3_RX_CONF1_CONF_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CONF1.Reg) & 0x8000) >> 15
}

// RMT.CH0_TX_STATUS: Channel %s status register
func (o *RMT_Type) SetCH0_TX_STATUS_MEM_RADDR_EX(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_STATUS.Reg, volatile.LoadUint32(&o.CH0_TX_STATUS.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH0_TX_STATUS_MEM_RADDR_EX() uint32 {
	return volatile.LoadUint32(&o.CH0_TX_STATUS.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH0_TX_STATUS_STATE(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_STATUS.Reg, volatile.LoadUint32(&o.CH0_TX_STATUS.Reg)&^(0xe00)|value<<9)
}
func (o *RMT_Type) GetCH0_TX_STATUS_STATE() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_STATUS.Reg) & 0xe00) >> 9
}
func (o *RMT_Type) SetCH0_TX_STATUS_APB_MEM_WADDR(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_STATUS.Reg, volatile.LoadUint32(&o.CH0_TX_STATUS.Reg)&^(0x1ff000)|value<<12)
}
func (o *RMT_Type) GetCH0_TX_STATUS_APB_MEM_WADDR() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_STATUS.Reg) & 0x1ff000) >> 12
}
func (o *RMT_Type) SetCH0_TX_STATUS_APB_MEM_RD_ERR(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_STATUS.Reg, volatile.LoadUint32(&o.CH0_TX_STATUS.Reg)&^(0x200000)|value<<21)
}
func (o *RMT_Type) GetCH0_TX_STATUS_APB_MEM_RD_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_STATUS.Reg) & 0x200000) >> 21
}
func (o *RMT_Type) SetCH0_TX_STATUS_MEM_EMPTY(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_STATUS.Reg, volatile.LoadUint32(&o.CH0_TX_STATUS.Reg)&^(0x400000)|value<<22)
}
func (o *RMT_Type) GetCH0_TX_STATUS_MEM_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_STATUS.Reg) & 0x400000) >> 22
}
func (o *RMT_Type) SetCH0_TX_STATUS_APB_MEM_WR_ERR(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_STATUS.Reg, volatile.LoadUint32(&o.CH0_TX_STATUS.Reg)&^(0x800000)|value<<23)
}
func (o *RMT_Type) GetCH0_TX_STATUS_APB_MEM_WR_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_STATUS.Reg) & 0x800000) >> 23
}
func (o *RMT_Type) SetCH0_TX_STATUS_APB_MEM_RADDR(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_STATUS.Reg, volatile.LoadUint32(&o.CH0_TX_STATUS.Reg)&^(0xff000000)|value<<24)
}
func (o *RMT_Type) GetCH0_TX_STATUS_APB_MEM_RADDR() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_STATUS.Reg) & 0xff000000) >> 24
}

// RMT.CH1_TX_STATUS: Channel %s status register
func (o *RMT_Type) SetCH1_TX_STATUS_MEM_RADDR_EX(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_STATUS.Reg, volatile.LoadUint32(&o.CH1_TX_STATUS.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH1_TX_STATUS_MEM_RADDR_EX() uint32 {
	return volatile.LoadUint32(&o.CH1_TX_STATUS.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH1_TX_STATUS_STATE(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_STATUS.Reg, volatile.LoadUint32(&o.CH1_TX_STATUS.Reg)&^(0xe00)|value<<9)
}
func (o *RMT_Type) GetCH1_TX_STATUS_STATE() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_STATUS.Reg) & 0xe00) >> 9
}
func (o *RMT_Type) SetCH1_TX_STATUS_APB_MEM_WADDR(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_STATUS.Reg, volatile.LoadUint32(&o.CH1_TX_STATUS.Reg)&^(0x1ff000)|value<<12)
}
func (o *RMT_Type) GetCH1_TX_STATUS_APB_MEM_WADDR() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_STATUS.Reg) & 0x1ff000) >> 12
}
func (o *RMT_Type) SetCH1_TX_STATUS_APB_MEM_RD_ERR(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_STATUS.Reg, volatile.LoadUint32(&o.CH1_TX_STATUS.Reg)&^(0x200000)|value<<21)
}
func (o *RMT_Type) GetCH1_TX_STATUS_APB_MEM_RD_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_STATUS.Reg) & 0x200000) >> 21
}
func (o *RMT_Type) SetCH1_TX_STATUS_MEM_EMPTY(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_STATUS.Reg, volatile.LoadUint32(&o.CH1_TX_STATUS.Reg)&^(0x400000)|value<<22)
}
func (o *RMT_Type) GetCH1_TX_STATUS_MEM_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_STATUS.Reg) & 0x400000) >> 22
}
func (o *RMT_Type) SetCH1_TX_STATUS_APB_MEM_WR_ERR(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_STATUS.Reg, volatile.LoadUint32(&o.CH1_TX_STATUS.Reg)&^(0x800000)|value<<23)
}
func (o *RMT_Type) GetCH1_TX_STATUS_APB_MEM_WR_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_STATUS.Reg) & 0x800000) >> 23
}
func (o *RMT_Type) SetCH1_TX_STATUS_APB_MEM_RADDR(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_STATUS.Reg, volatile.LoadUint32(&o.CH1_TX_STATUS.Reg)&^(0xff000000)|value<<24)
}
func (o *RMT_Type) GetCH1_TX_STATUS_APB_MEM_RADDR() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_STATUS.Reg) & 0xff000000) >> 24
}

// RMT.CH0_RX_STATUS: Channel %s status register
func (o *RMT_Type) SetCH0_RX_STATUS_MEM_WADDR_EX(value uint32) {
	volatile.StoreUint32(&o.CH0_RX_STATUS.Reg, volatile.LoadUint32(&o.CH0_RX_STATUS.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH0_RX_STATUS_MEM_WADDR_EX() uint32 {
	return volatile.LoadUint32(&o.CH0_RX_STATUS.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH0_RX_STATUS_APB_MEM_RADDR(value uint32) {
	volatile.StoreUint32(&o.CH0_RX_STATUS.Reg, volatile.LoadUint32(&o.CH0_RX_STATUS.Reg)&^(0x1ff000)|value<<12)
}
func (o *RMT_Type) GetCH0_RX_STATUS_APB_MEM_RADDR() uint32 {
	return (volatile.LoadUint32(&o.CH0_RX_STATUS.Reg) & 0x1ff000) >> 12
}
func (o *RMT_Type) SetCH0_RX_STATUS_STATE(value uint32) {
	volatile.StoreUint32(&o.CH0_RX_STATUS.Reg, volatile.LoadUint32(&o.CH0_RX_STATUS.Reg)&^(0x1c00000)|value<<22)
}
func (o *RMT_Type) GetCH0_RX_STATUS_STATE() uint32 {
	return (volatile.LoadUint32(&o.CH0_RX_STATUS.Reg) & 0x1c00000) >> 22
}
func (o *RMT_Type) SetCH0_RX_STATUS_MEM_OWNER_ERR(value uint32) {
	volatile.StoreUint32(&o.CH0_RX_STATUS.Reg, volatile.LoadUint32(&o.CH0_RX_STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *RMT_Type) GetCH0_RX_STATUS_MEM_OWNER_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH0_RX_STATUS.Reg) & 0x2000000) >> 25
}
func (o *RMT_Type) SetCH0_RX_STATUS_MEM_FULL(value uint32) {
	volatile.StoreUint32(&o.CH0_RX_STATUS.Reg, volatile.LoadUint32(&o.CH0_RX_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *RMT_Type) GetCH0_RX_STATUS_MEM_FULL() uint32 {
	return (volatile.LoadUint32(&o.CH0_RX_STATUS.Reg) & 0x4000000) >> 26
}
func (o *RMT_Type) SetCH0_RX_STATUS_APB_MEM_RD_ERR(value uint32) {
	volatile.StoreUint32(&o.CH0_RX_STATUS.Reg, volatile.LoadUint32(&o.CH0_RX_STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH0_RX_STATUS_APB_MEM_RD_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH0_RX_STATUS.Reg) & 0x8000000) >> 27
}

// RMT.CH1_RX_STATUS: Channel %s status register
func (o *RMT_Type) SetCH1_RX_STATUS_MEM_WADDR_EX(value uint32) {
	volatile.StoreUint32(&o.CH1_RX_STATUS.Reg, volatile.LoadUint32(&o.CH1_RX_STATUS.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH1_RX_STATUS_MEM_WADDR_EX() uint32 {
	return volatile.LoadUint32(&o.CH1_RX_STATUS.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH1_RX_STATUS_APB_MEM_RADDR(value uint32) {
	volatile.StoreUint32(&o.CH1_RX_STATUS.Reg, volatile.LoadUint32(&o.CH1_RX_STATUS.Reg)&^(0x1ff000)|value<<12)
}
func (o *RMT_Type) GetCH1_RX_STATUS_APB_MEM_RADDR() uint32 {
	return (volatile.LoadUint32(&o.CH1_RX_STATUS.Reg) & 0x1ff000) >> 12
}
func (o *RMT_Type) SetCH1_RX_STATUS_STATE(value uint32) {
	volatile.StoreUint32(&o.CH1_RX_STATUS.Reg, volatile.LoadUint32(&o.CH1_RX_STATUS.Reg)&^(0x1c00000)|value<<22)
}
func (o *RMT_Type) GetCH1_RX_STATUS_STATE() uint32 {
	return (volatile.LoadUint32(&o.CH1_RX_STATUS.Reg) & 0x1c00000) >> 22
}
func (o *RMT_Type) SetCH1_RX_STATUS_MEM_OWNER_ERR(value uint32) {
	volatile.StoreUint32(&o.CH1_RX_STATUS.Reg, volatile.LoadUint32(&o.CH1_RX_STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *RMT_Type) GetCH1_RX_STATUS_MEM_OWNER_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH1_RX_STATUS.Reg) & 0x2000000) >> 25
}
func (o *RMT_Type) SetCH1_RX_STATUS_MEM_FULL(value uint32) {
	volatile.StoreUint32(&o.CH1_RX_STATUS.Reg, volatile.LoadUint32(&o.CH1_RX_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *RMT_Type) GetCH1_RX_STATUS_MEM_FULL() uint32 {
	return (volatile.LoadUint32(&o.CH1_RX_STATUS.Reg) & 0x4000000) >> 26
}
func (o *RMT_Type) SetCH1_RX_STATUS_APB_MEM_RD_ERR(value uint32) {
	volatile.StoreUint32(&o.CH1_RX_STATUS.Reg, volatile.LoadUint32(&o.CH1_RX_STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH1_RX_STATUS_APB_MEM_RD_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH1_RX_STATUS.Reg) & 0x8000000) >> 27
}

// RMT.INT_RAW: Raw interrupt status
func (o *RMT_Type) SetINT_RAW_CH_s_TX_END(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetINT_RAW_CH_s_TX_END() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *RMT_Type) SetINT_RAW_CH_s_RX_END(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetINT_RAW_CH_s_RX_END() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetINT_RAW_CH_s_TX_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetINT_RAW_CH_s_TX_ERR() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetINT_RAW_CH_s_RX_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetINT_RAW_CH_s_RX_ERR() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetINT_RAW_CH_s_TX_THR_EVENT(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *RMT_Type) GetINT_RAW_CH_s_TX_THR_EVENT() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *RMT_Type) SetINT_RAW_CH_s_RX_THR_EVENT(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *RMT_Type) GetINT_RAW_CH_s_RX_THR_EVENT() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *RMT_Type) SetINT_RAW_CH_s_TX_LOOP(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *RMT_Type) GetINT_RAW_CH_s_TX_LOOP() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}

// RMT.INT_ST: Masked interrupt status
func (o *RMT_Type) SetINT_ST_CH_s_TX_END(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetINT_ST_CH_s_TX_END() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *RMT_Type) SetINT_ST_CH_s_RX_END(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetINT_ST_CH_s_RX_END() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetINT_ST_CH_s_TX_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetINT_ST_CH_s_TX_ERR() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetINT_ST_CH_s_RX_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetINT_ST_CH_s_RX_ERR() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetINT_ST_CH_s_TX_THR_EVENT(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *RMT_Type) GetINT_ST_CH_s_TX_THR_EVENT() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *RMT_Type) SetINT_ST_CH_s_RX_THR_EVENT(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *RMT_Type) GetINT_ST_CH_s_RX_THR_EVENT() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400) >> 10
}
func (o *RMT_Type) SetINT_ST_CH_s_X_LOOP(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *RMT_Type) GetINT_ST_CH_s_X_LOOP() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}

// RMT.INT_ENA: Interrupt enable bits
func (o *RMT_Type) SetINT_ENA_CH_s_TX_END(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetINT_ENA_CH_s_TX_END() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *RMT_Type) SetINT_ENA_CH_s_RX_END(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetINT_ENA_CH_s_RX_END() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetINT_ENA_CH_s_TX_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetINT_ENA_CH_s_TX_ERR() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetINT_ENA_CH_s_RX_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetINT_ENA_CH_s_RX_ERR() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetINT_ENA_CH_s_TX_THR_EVENT(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *RMT_Type) GetINT_ENA_CH_s_TX_THR_EVENT() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *RMT_Type) SetINT_ENA_CH_s_RX_THR_EVENT(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *RMT_Type) GetINT_ENA_CH_s_RX_THR_EVENT() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *RMT_Type) SetINT_ENA_CH_s_X_LOOP(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *RMT_Type) GetINT_ENA_CH_s_X_LOOP() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}

// RMT.INT_CLR: Interrupt clear bits
func (o *RMT_Type) SetINT_CLR_CH_s_TX_END(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetINT_CLR_CH_s_TX_END() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *RMT_Type) SetINT_CLR_CH_s_RX_END(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetINT_CLR_CH_s_RX_END() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetINT_CLR_CH_s_TX_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetINT_CLR_CH_s_TX_ERR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetINT_CLR_CH_s_RX_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetINT_CLR_CH_s_RX_ERR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetINT_CLR_CH_s_TX_THR_EVENT(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *RMT_Type) GetINT_CLR_CH_s_TX_THR_EVENT() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *RMT_Type) SetINT_CLR_CH_s_RX_THR_EVENT(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *RMT_Type) GetINT_CLR_CH_s_RX_THR_EVENT() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *RMT_Type) SetINT_CLR_CH_s_TX_LOOP(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *RMT_Type) GetINT_CLR_CH_s_TX_LOOP() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}

// RMT.CH0CARRIER_DUTY: Channel %s duty cycle configuration register
func (o *RMT_Type) SetCH0CARRIER_DUTY_CARRIER_LOW(value uint32) {
	volatile.StoreUint32(&o.CH0CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH0CARRIER_DUTY.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH0CARRIER_DUTY_CARRIER_LOW() uint32 {
	return volatile.LoadUint32(&o.CH0CARRIER_DUTY.Reg) & 0xffff
}
func (o *RMT_Type) SetCH0CARRIER_DUTY_CARRIER_HIGH(value uint32) {
	volatile.StoreUint32(&o.CH0CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH0CARRIER_DUTY.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH0CARRIER_DUTY_CARRIER_HIGH() uint32 {
	return (volatile.LoadUint32(&o.CH0CARRIER_DUTY.Reg) & 0xffff0000) >> 16
}

// RMT.CH1CARRIER_DUTY: Channel %s duty cycle configuration register
func (o *RMT_Type) SetCH1CARRIER_DUTY_CARRIER_LOW(value uint32) {
	volatile.StoreUint32(&o.CH1CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH1CARRIER_DUTY.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH1CARRIER_DUTY_CARRIER_LOW() uint32 {
	return volatile.LoadUint32(&o.CH1CARRIER_DUTY.Reg) & 0xffff
}
func (o *RMT_Type) SetCH1CARRIER_DUTY_CARRIER_HIGH(value uint32) {
	volatile.StoreUint32(&o.CH1CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH1CARRIER_DUTY.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH1CARRIER_DUTY_CARRIER_HIGH() uint32 {
	return (volatile.LoadUint32(&o.CH1CARRIER_DUTY.Reg) & 0xffff0000) >> 16
}

// RMT.CH0_RX_CARRIER_RM: Channel %s carrier remove register
func (o *RMT_Type) SetCH0_RX_CARRIER_RM_CARRIER_LOW_THRES(value uint32) {
	volatile.StoreUint32(&o.CH0_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH0_RX_CARRIER_RM.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH0_RX_CARRIER_RM_CARRIER_LOW_THRES() uint32 {
	return volatile.LoadUint32(&o.CH0_RX_CARRIER_RM.Reg) & 0xffff
}
func (o *RMT_Type) SetCH0_RX_CARRIER_RM_CARRIER_HIGH_THRES(value uint32) {
	volatile.StoreUint32(&o.CH0_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH0_RX_CARRIER_RM.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH0_RX_CARRIER_RM_CARRIER_HIGH_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH0_RX_CARRIER_RM.Reg) & 0xffff0000) >> 16
}

// RMT.CH1_RX_CARRIER_RM: Channel %s carrier remove register
func (o *RMT_Type) SetCH1_RX_CARRIER_RM_CARRIER_LOW_THRES(value uint32) {
	volatile.StoreUint32(&o.CH1_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH1_RX_CARRIER_RM.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH1_RX_CARRIER_RM_CARRIER_LOW_THRES() uint32 {
	return volatile.LoadUint32(&o.CH1_RX_CARRIER_RM.Reg) & 0xffff
}
func (o *RMT_Type) SetCH1_RX_CARRIER_RM_CARRIER_HIGH_THRES(value uint32) {
	volatile.StoreUint32(&o.CH1_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH1_RX_CARRIER_RM.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH1_RX_CARRIER_RM_CARRIER_HIGH_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH1_RX_CARRIER_RM.Reg) & 0xffff0000) >> 16
}

// RMT.CH0_TX_LIM: Channel %s Tx event configuration register
func (o *RMT_Type) SetCH0_TX_LIM_TX_LIM(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_LIM.Reg, volatile.LoadUint32(&o.CH0_TX_LIM.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH0_TX_LIM_TX_LIM() uint32 {
	return volatile.LoadUint32(&o.CH0_TX_LIM.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH0_TX_LIM_TX_LOOP_NUM(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_LIM.Reg, volatile.LoadUint32(&o.CH0_TX_LIM.Reg)&^(0x7fe00)|value<<9)
}
func (o *RMT_Type) GetCH0_TX_LIM_TX_LOOP_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_LIM.Reg) & 0x7fe00) >> 9
}
func (o *RMT_Type) SetCH0_TX_LIM_TX_LOOP_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_LIM.Reg, volatile.LoadUint32(&o.CH0_TX_LIM.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH0_TX_LIM_TX_LOOP_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_LIM.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH0_TX_LIM_LOOP_COUNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_LIM.Reg, volatile.LoadUint32(&o.CH0_TX_LIM.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH0_TX_LIM_LOOP_COUNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_LIM.Reg) & 0x100000) >> 20
}
func (o *RMT_Type) SetCH0_TX_LIM_LOOP_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_LIM.Reg, volatile.LoadUint32(&o.CH0_TX_LIM.Reg)&^(0x200000)|value<<21)
}
func (o *RMT_Type) GetCH0_TX_LIM_LOOP_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_LIM.Reg) & 0x200000) >> 21
}

// RMT.CH1_TX_LIM: Channel %s Tx event configuration register
func (o *RMT_Type) SetCH1_TX_LIM_TX_LIM(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_LIM.Reg, volatile.LoadUint32(&o.CH1_TX_LIM.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH1_TX_LIM_TX_LIM() uint32 {
	return volatile.LoadUint32(&o.CH1_TX_LIM.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH1_TX_LIM_TX_LOOP_NUM(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_LIM.Reg, volatile.LoadUint32(&o.CH1_TX_LIM.Reg)&^(0x7fe00)|value<<9)
}
func (o *RMT_Type) GetCH1_TX_LIM_TX_LOOP_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_LIM.Reg) & 0x7fe00) >> 9
}
func (o *RMT_Type) SetCH1_TX_LIM_TX_LOOP_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_LIM.Reg, volatile.LoadUint32(&o.CH1_TX_LIM.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH1_TX_LIM_TX_LOOP_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_LIM.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH1_TX_LIM_LOOP_COUNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_LIM.Reg, volatile.LoadUint32(&o.CH1_TX_LIM.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH1_TX_LIM_LOOP_COUNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_LIM.Reg) & 0x100000) >> 20
}
func (o *RMT_Type) SetCH1_TX_LIM_LOOP_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_LIM.Reg, volatile.LoadUint32(&o.CH1_TX_LIM.Reg)&^(0x200000)|value<<21)
}
func (o *RMT_Type) GetCH1_TX_LIM_LOOP_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_LIM.Reg) & 0x200000) >> 21
}

// RMT.CH0_RX_LIM: Channel %s Rx event configuration register
func (o *RMT_Type) SetCH0_RX_LIM_RMT_RX_LIM(value uint32) {
	volatile.StoreUint32(&o.CH0_RX_LIM.Reg, volatile.LoadUint32(&o.CH0_RX_LIM.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH0_RX_LIM_RMT_RX_LIM() uint32 {
	return volatile.LoadUint32(&o.CH0_RX_LIM.Reg) & 0x1ff
}

// RMT.CH1_RX_LIM: Channel %s Rx event configuration register
func (o *RMT_Type) SetCH1_RX_LIM_RMT_RX_LIM(value uint32) {
	volatile.StoreUint32(&o.CH1_RX_LIM.Reg, volatile.LoadUint32(&o.CH1_RX_LIM.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH1_RX_LIM_RMT_RX_LIM() uint32 {
	return volatile.LoadUint32(&o.CH1_RX_LIM.Reg) & 0x1ff
}

// RMT.SYS_CONF: RMT apb configuration register
func (o *RMT_Type) SetSYS_CONF_APB_FIFO_MASK(value uint32) {
	volatile.StoreUint32(&o.SYS_CONF.Reg, volatile.LoadUint32(&o.SYS_CONF.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetSYS_CONF_APB_FIFO_MASK() uint32 {
	return volatile.LoadUint32(&o.SYS_CONF.Reg) & 0x1
}
func (o *RMT_Type) SetSYS_CONF_MEM_CLK_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.SYS_CONF.Reg, volatile.LoadUint32(&o.SYS_CONF.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetSYS_CONF_MEM_CLK_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.SYS_CONF.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetSYS_CONF_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.SYS_CONF.Reg, volatile.LoadUint32(&o.SYS_CONF.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetSYS_CONF_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.SYS_CONF.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetSYS_CONF_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.SYS_CONF.Reg, volatile.LoadUint32(&o.SYS_CONF.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetSYS_CONF_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.SYS_CONF.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetSYS_CONF_SCLK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.SYS_CONF.Reg, volatile.LoadUint32(&o.SYS_CONF.Reg)&^(0xff0)|value<<4)
}
func (o *RMT_Type) GetSYS_CONF_SCLK_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.SYS_CONF.Reg) & 0xff0) >> 4
}
func (o *RMT_Type) SetSYS_CONF_SCLK_DIV_A(value uint32) {
	volatile.StoreUint32(&o.SYS_CONF.Reg, volatile.LoadUint32(&o.SYS_CONF.Reg)&^(0x3f000)|value<<12)
}
func (o *RMT_Type) GetSYS_CONF_SCLK_DIV_A() uint32 {
	return (volatile.LoadUint32(&o.SYS_CONF.Reg) & 0x3f000) >> 12
}
func (o *RMT_Type) SetSYS_CONF_SCLK_DIV_B(value uint32) {
	volatile.StoreUint32(&o.SYS_CONF.Reg, volatile.LoadUint32(&o.SYS_CONF.Reg)&^(0xfc0000)|value<<18)
}
func (o *RMT_Type) GetSYS_CONF_SCLK_DIV_B() uint32 {
	return (volatile.LoadUint32(&o.SYS_CONF.Reg) & 0xfc0000) >> 18
}
func (o *RMT_Type) SetSYS_CONF_SCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.SYS_CONF.Reg, volatile.LoadUint32(&o.SYS_CONF.Reg)&^(0x3000000)|value<<24)
}
func (o *RMT_Type) GetSYS_CONF_SCLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.SYS_CONF.Reg) & 0x3000000) >> 24
}
func (o *RMT_Type) SetSYS_CONF_SCLK_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.SYS_CONF.Reg, volatile.LoadUint32(&o.SYS_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *RMT_Type) GetSYS_CONF_SCLK_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.SYS_CONF.Reg) & 0x4000000) >> 26
}
func (o *RMT_Type) SetSYS_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SYS_CONF.Reg, volatile.LoadUint32(&o.SYS_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RMT_Type) GetSYS_CONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.SYS_CONF.Reg) & 0x80000000) >> 31
}

// RMT.TX_SIM: RMT TX synchronous register
func (o *RMT_Type) SetTX_SIM_CH0(value uint32) {
	volatile.StoreUint32(&o.TX_SIM.Reg, volatile.LoadUint32(&o.TX_SIM.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetTX_SIM_CH0() uint32 {
	return volatile.LoadUint32(&o.TX_SIM.Reg) & 0x1
}
func (o *RMT_Type) SetTX_SIM_CH1(value uint32) {
	volatile.StoreUint32(&o.TX_SIM.Reg, volatile.LoadUint32(&o.TX_SIM.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetTX_SIM_CH1() uint32 {
	return (volatile.LoadUint32(&o.TX_SIM.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetTX_SIM_EN(value uint32) {
	volatile.StoreUint32(&o.TX_SIM.Reg, volatile.LoadUint32(&o.TX_SIM.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetTX_SIM_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_SIM.Reg) & 0x4) >> 2
}

// RMT.REF_CNT_RST: RMT clock divider reset register
func (o *RMT_Type) SetREF_CNT_RST_TX_REF_CNT_RST(value uint32) {
	volatile.StoreUint32(&o.REF_CNT_RST.Reg, volatile.LoadUint32(&o.REF_CNT_RST.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetREF_CNT_RST_TX_REF_CNT_RST() uint32 {
	return volatile.LoadUint32(&o.REF_CNT_RST.Reg) & 0x1
}
func (o *RMT_Type) SetREF_CNT_RST_TX_REF_CNT_RST_CH1(value uint32) {
	volatile.StoreUint32(&o.REF_CNT_RST.Reg, volatile.LoadUint32(&o.REF_CNT_RST.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetREF_CNT_RST_TX_REF_CNT_RST_CH1() uint32 {
	return (volatile.LoadUint32(&o.REF_CNT_RST.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetREF_CNT_RST_RX_REF_CNT_RST_CH2(value uint32) {
	volatile.StoreUint32(&o.REF_CNT_RST.Reg, volatile.LoadUint32(&o.REF_CNT_RST.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetREF_CNT_RST_RX_REF_CNT_RST_CH2() uint32 {
	return (volatile.LoadUint32(&o.REF_CNT_RST.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetREF_CNT_RST_RX_REF_CNT_RST_CH3(value uint32) {
	volatile.StoreUint32(&o.REF_CNT_RST.Reg, volatile.LoadUint32(&o.REF_CNT_RST.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetREF_CNT_RST_RX_REF_CNT_RST_CH3() uint32 {
	return (volatile.LoadUint32(&o.REF_CNT_RST.Reg) & 0x8) >> 3
}

// RMT.DATE: RMT version register
func (o *RMT_Type) SetDATE_RMT_DATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *RMT_Type) GetDATE_RMT_DATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// Hardware Random Number Generator
type RNG_Type struct {
	_    [8]byte
	DATA volatile.Register32 // 0x8
}

// RSA (Rivest Shamir Adleman) Accelerator
type RSA_Type struct {
	M_MEM             [384]volatile.Register8 // 0x0
	_                 [128]byte
	Z_MEM             [384]volatile.Register8 // 0x200
	_                 [128]byte
	Y_MEM             [384]volatile.Register8 // 0x400
	_                 [128]byte
	X_MEM             [384]volatile.Register8 // 0x600
	_                 [128]byte
	M_PRIME           volatile.Register32 // 0x800
	MODE              volatile.Register32 // 0x804
	QUERY_CLEAN       volatile.Register32 // 0x808
	SET_START_MODEXP  volatile.Register32 // 0x80C
	SET_START_MODMULT volatile.Register32 // 0x810
	SET_START_MULT    volatile.Register32 // 0x814
	QUERY_IDLE        volatile.Register32 // 0x818
	INT_CLR           volatile.Register32 // 0x81C
	CONSTANT_TIME     volatile.Register32 // 0x820
	SEARCH_ENABLE     volatile.Register32 // 0x824
	SEARCH_POS        volatile.Register32 // 0x828
	INT_ENA           volatile.Register32 // 0x82C
	DATE              volatile.Register32 // 0x830
}

// RSA.M_PRIME: Represents M’
func (o *RSA_Type) SetM_PRIME(value uint32) {
	volatile.StoreUint32(&o.M_PRIME.Reg, value)
}
func (o *RSA_Type) GetM_PRIME() uint32 {
	return volatile.LoadUint32(&o.M_PRIME.Reg)
}

// RSA.MODE: Configures RSA length
func (o *RSA_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x7f)|value)
}
func (o *RSA_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x7f
}

// RSA.QUERY_CLEAN: RSA clean register
func (o *RSA_Type) SetQUERY_CLEAN(value uint32) {
	volatile.StoreUint32(&o.QUERY_CLEAN.Reg, volatile.LoadUint32(&o.QUERY_CLEAN.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetQUERY_CLEAN() uint32 {
	return volatile.LoadUint32(&o.QUERY_CLEAN.Reg) & 0x1
}

// RSA.SET_START_MODEXP: Starts modular exponentiation
func (o *RSA_Type) SetSET_START_MODEXP(value uint32) {
	volatile.StoreUint32(&o.SET_START_MODEXP.Reg, volatile.LoadUint32(&o.SET_START_MODEXP.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetSET_START_MODEXP() uint32 {
	return volatile.LoadUint32(&o.SET_START_MODEXP.Reg) & 0x1
}

// RSA.SET_START_MODMULT: Starts modular multiplication
func (o *RSA_Type) SetSET_START_MODMULT(value uint32) {
	volatile.StoreUint32(&o.SET_START_MODMULT.Reg, volatile.LoadUint32(&o.SET_START_MODMULT.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetSET_START_MODMULT() uint32 {
	return volatile.LoadUint32(&o.SET_START_MODMULT.Reg) & 0x1
}

// RSA.SET_START_MULT: Starts multiplication
func (o *RSA_Type) SetSET_START_MULT(value uint32) {
	volatile.StoreUint32(&o.SET_START_MULT.Reg, volatile.LoadUint32(&o.SET_START_MULT.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetSET_START_MULT() uint32 {
	return volatile.LoadUint32(&o.SET_START_MULT.Reg) & 0x1
}

// RSA.QUERY_IDLE: Represents the RSA status
func (o *RSA_Type) SetQUERY_IDLE(value uint32) {
	volatile.StoreUint32(&o.QUERY_IDLE.Reg, volatile.LoadUint32(&o.QUERY_IDLE.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetQUERY_IDLE() uint32 {
	return volatile.LoadUint32(&o.QUERY_IDLE.Reg) & 0x1
}

// RSA.INT_CLR: Clears RSA interrupt
func (o *RSA_Type) SetINT_CLR_CLEAR_INTERRUPT(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetINT_CLR_CLEAR_INTERRUPT() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}

// RSA.CONSTANT_TIME: Configures the constant_time option
func (o *RSA_Type) SetCONSTANT_TIME(value uint32) {
	volatile.StoreUint32(&o.CONSTANT_TIME.Reg, volatile.LoadUint32(&o.CONSTANT_TIME.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetCONSTANT_TIME() uint32 {
	return volatile.LoadUint32(&o.CONSTANT_TIME.Reg) & 0x1
}

// RSA.SEARCH_ENABLE: Configures the search option
func (o *RSA_Type) SetSEARCH_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SEARCH_ENABLE.Reg, volatile.LoadUint32(&o.SEARCH_ENABLE.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetSEARCH_ENABLE() uint32 {
	return volatile.LoadUint32(&o.SEARCH_ENABLE.Reg) & 0x1
}

// RSA.SEARCH_POS: Configures the search position
func (o *RSA_Type) SetSEARCH_POS(value uint32) {
	volatile.StoreUint32(&o.SEARCH_POS.Reg, volatile.LoadUint32(&o.SEARCH_POS.Reg)&^(0xfff)|value)
}
func (o *RSA_Type) GetSEARCH_POS() uint32 {
	return volatile.LoadUint32(&o.SEARCH_POS.Reg) & 0xfff
}

// RSA.INT_ENA: Enables the RSA interrupt
func (o *RSA_Type) SetINT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetINT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}

// RSA.DATE: Version control register
func (o *RSA_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *RSA_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// SHA (Secure Hash Algorithm) Accelerator
type SHA_Type struct {
	MODE          volatile.Register32 // 0x0
	T_STRING      volatile.Register32 // 0x4
	T_LENGTH      volatile.Register32 // 0x8
	DMA_BLOCK_NUM volatile.Register32 // 0xC
	START         volatile.Register32 // 0x10
	CONTINUE      volatile.Register32 // 0x14
	BUSY          volatile.Register32 // 0x18
	DMA_START     volatile.Register32 // 0x1C
	DMA_CONTINUE  volatile.Register32 // 0x20
	CLEAR_IRQ     volatile.Register32 // 0x24
	IRQ_ENA       volatile.Register32 // 0x28
	DATE          volatile.Register32 // 0x2C
	_             [16]byte
	H_MEM         [64]volatile.Register8 // 0x40
	M_MEM         [64]volatile.Register8 // 0x80
}

// SHA.MODE: Initial configuration register.
func (o *SHA_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x7)|value)
}
func (o *SHA_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x7
}

// SHA.T_STRING: SHA 512/t configuration register 0.
func (o *SHA_Type) SetT_STRING(value uint32) {
	volatile.StoreUint32(&o.T_STRING.Reg, value)
}
func (o *SHA_Type) GetT_STRING() uint32 {
	return volatile.LoadUint32(&o.T_STRING.Reg)
}

// SHA.T_LENGTH: SHA 512/t configuration register 1.
func (o *SHA_Type) SetT_LENGTH(value uint32) {
	volatile.StoreUint32(&o.T_LENGTH.Reg, volatile.LoadUint32(&o.T_LENGTH.Reg)&^(0x3f)|value)
}
func (o *SHA_Type) GetT_LENGTH() uint32 {
	return volatile.LoadUint32(&o.T_LENGTH.Reg) & 0x3f
}

// SHA.DMA_BLOCK_NUM: DMA configuration register 0.
func (o *SHA_Type) SetDMA_BLOCK_NUM(value uint32) {
	volatile.StoreUint32(&o.DMA_BLOCK_NUM.Reg, volatile.LoadUint32(&o.DMA_BLOCK_NUM.Reg)&^(0x3f)|value)
}
func (o *SHA_Type) GetDMA_BLOCK_NUM() uint32 {
	return volatile.LoadUint32(&o.DMA_BLOCK_NUM.Reg) & 0x3f
}

// SHA.START: Typical SHA configuration register 0.
func (o *SHA_Type) SetSTART(value uint32) {
	volatile.StoreUint32(&o.START.Reg, volatile.LoadUint32(&o.START.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SHA_Type) GetSTART() uint32 {
	return (volatile.LoadUint32(&o.START.Reg) & 0xfffffffe) >> 1
}

// SHA.CONTINUE: Typical SHA configuration register 1.
func (o *SHA_Type) SetCONTINUE(value uint32) {
	volatile.StoreUint32(&o.CONTINUE.Reg, volatile.LoadUint32(&o.CONTINUE.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SHA_Type) GetCONTINUE() uint32 {
	return (volatile.LoadUint32(&o.CONTINUE.Reg) & 0xfffffffe) >> 1
}

// SHA.BUSY: Busy register.
func (o *SHA_Type) SetBUSY_STATE(value uint32) {
	volatile.StoreUint32(&o.BUSY.Reg, volatile.LoadUint32(&o.BUSY.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetBUSY_STATE() uint32 {
	return volatile.LoadUint32(&o.BUSY.Reg) & 0x1
}

// SHA.DMA_START: DMA configuration register 1.
func (o *SHA_Type) SetDMA_START(value uint32) {
	volatile.StoreUint32(&o.DMA_START.Reg, volatile.LoadUint32(&o.DMA_START.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetDMA_START() uint32 {
	return volatile.LoadUint32(&o.DMA_START.Reg) & 0x1
}

// SHA.DMA_CONTINUE: DMA configuration register 2.
func (o *SHA_Type) SetDMA_CONTINUE(value uint32) {
	volatile.StoreUint32(&o.DMA_CONTINUE.Reg, volatile.LoadUint32(&o.DMA_CONTINUE.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetDMA_CONTINUE() uint32 {
	return volatile.LoadUint32(&o.DMA_CONTINUE.Reg) & 0x1
}

// SHA.CLEAR_IRQ: Interrupt clear register.
func (o *SHA_Type) SetCLEAR_IRQ_CLEAR_INTERRUPT(value uint32) {
	volatile.StoreUint32(&o.CLEAR_IRQ.Reg, volatile.LoadUint32(&o.CLEAR_IRQ.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetCLEAR_IRQ_CLEAR_INTERRUPT() uint32 {
	return volatile.LoadUint32(&o.CLEAR_IRQ.Reg) & 0x1
}

// SHA.IRQ_ENA: Interrupt enable register.
func (o *SHA_Type) SetIRQ_ENA_INTERRUPT_ENA(value uint32) {
	volatile.StoreUint32(&o.IRQ_ENA.Reg, volatile.LoadUint32(&o.IRQ_ENA.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetIRQ_ENA_INTERRUPT_ENA() uint32 {
	return volatile.LoadUint32(&o.IRQ_ENA.Reg) & 0x1
}

// SHA.DATE: Date register.
func (o *SHA_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *SHA_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// Event Task Matrix
type SOC_ETM_Type struct {
	CH_ENA_AD0     volatile.Register32 // 0x0
	CH_ENA_AD0_SET volatile.Register32 // 0x4
	CH_ENA_AD0_CLR volatile.Register32 // 0x8
	CH_ENA_AD1     volatile.Register32 // 0xC
	CH_ENA_AD1_SET volatile.Register32 // 0x10
	CH_ENA_AD1_CLR volatile.Register32 // 0x14
	CH0_EVT_ID     volatile.Register32 // 0x18
	CH0_TASK_ID    volatile.Register32 // 0x1C
	CH1_EVT_ID     volatile.Register32 // 0x20
	CH1_TASK_ID    volatile.Register32 // 0x24
	CH2_EVT_ID     volatile.Register32 // 0x28
	CH2_TASK_ID    volatile.Register32 // 0x2C
	CH3_EVT_ID     volatile.Register32 // 0x30
	CH3_TASK_ID    volatile.Register32 // 0x34
	CH4_EVT_ID     volatile.Register32 // 0x38
	CH4_TASK_ID    volatile.Register32 // 0x3C
	CH5_EVT_ID     volatile.Register32 // 0x40
	CH5_TASK_ID    volatile.Register32 // 0x44
	CH6_EVT_ID     volatile.Register32 // 0x48
	CH6_TASK_ID    volatile.Register32 // 0x4C
	CH7_EVT_ID     volatile.Register32 // 0x50
	CH7_TASK_ID    volatile.Register32 // 0x54
	CH8_EVT_ID     volatile.Register32 // 0x58
	CH8_TASK_ID    volatile.Register32 // 0x5C
	CH9_EVT_ID     volatile.Register32 // 0x60
	CH9_TASK_ID    volatile.Register32 // 0x64
	CH10_EVT_ID    volatile.Register32 // 0x68
	CH10_TASK_ID   volatile.Register32 // 0x6C
	CH11_EVT_ID    volatile.Register32 // 0x70
	CH11_TASK_ID   volatile.Register32 // 0x74
	CH12_EVT_ID    volatile.Register32 // 0x78
	CH12_TASK_ID   volatile.Register32 // 0x7C
	CH13_EVT_ID    volatile.Register32 // 0x80
	CH13_TASK_ID   volatile.Register32 // 0x84
	CH14_EVT_ID    volatile.Register32 // 0x88
	CH14_TASK_ID   volatile.Register32 // 0x8C
	CH15_EVT_ID    volatile.Register32 // 0x90
	CH15_TASK_ID   volatile.Register32 // 0x94
	CH16_EVT_ID    volatile.Register32 // 0x98
	CH16_TASK_ID   volatile.Register32 // 0x9C
	CH17_EVT_ID    volatile.Register32 // 0xA0
	CH17_TASK_ID   volatile.Register32 // 0xA4
	CH18_EVT_ID    volatile.Register32 // 0xA8
	CH18_TASK_ID   volatile.Register32 // 0xAC
	CH19_EVT_ID    volatile.Register32 // 0xB0
	CH19_TASK_ID   volatile.Register32 // 0xB4
	CH20_EVT_ID    volatile.Register32 // 0xB8
	CH20_TASK_ID   volatile.Register32 // 0xBC
	CH21_EVT_ID    volatile.Register32 // 0xC0
	CH21_TASK_ID   volatile.Register32 // 0xC4
	CH22_EVT_ID    volatile.Register32 // 0xC8
	CH22_TASK_ID   volatile.Register32 // 0xCC
	CH23_EVT_ID    volatile.Register32 // 0xD0
	CH23_TASK_ID   volatile.Register32 // 0xD4
	CH24_EVT_ID    volatile.Register32 // 0xD8
	CH24_TASK_ID   volatile.Register32 // 0xDC
	CH25_EVT_ID    volatile.Register32 // 0xE0
	CH25_TASK_ID   volatile.Register32 // 0xE4
	CH26_EVT_ID    volatile.Register32 // 0xE8
	CH26_TASK_ID   volatile.Register32 // 0xEC
	CH27_EVT_ID    volatile.Register32 // 0xF0
	CH27_TASK_ID   volatile.Register32 // 0xF4
	CH28_EVT_ID    volatile.Register32 // 0xF8
	CH28_TASK_ID   volatile.Register32 // 0xFC
	CH29_EVT_ID    volatile.Register32 // 0x100
	CH29_TASK_ID   volatile.Register32 // 0x104
	CH30_EVT_ID    volatile.Register32 // 0x108
	CH30_TASK_ID   volatile.Register32 // 0x10C
	CH31_EVT_ID    volatile.Register32 // 0x110
	CH31_TASK_ID   volatile.Register32 // 0x114
	CH32_EVT_ID    volatile.Register32 // 0x118
	CH32_TASK_ID   volatile.Register32 // 0x11C
	CH33_EVT_ID    volatile.Register32 // 0x120
	CH33_TASK_ID   volatile.Register32 // 0x124
	CH34_EVT_ID    volatile.Register32 // 0x128
	CH34_TASK_ID   volatile.Register32 // 0x12C
	CH35_EVT_ID    volatile.Register32 // 0x130
	CH35_TASK_ID   volatile.Register32 // 0x134
	CH36_EVT_ID    volatile.Register32 // 0x138
	CH36_TASK_ID   volatile.Register32 // 0x13C
	CH37_EVT_ID    volatile.Register32 // 0x140
	CH37_TASK_ID   volatile.Register32 // 0x144
	CH38_EVT_ID    volatile.Register32 // 0x148
	CH38_TASK_ID   volatile.Register32 // 0x14C
	CH39_EVT_ID    volatile.Register32 // 0x150
	CH39_TASK_ID   volatile.Register32 // 0x154
	CH40_EVT_ID    volatile.Register32 // 0x158
	CH40_TASK_ID   volatile.Register32 // 0x15C
	CH41_EVT_ID    volatile.Register32 // 0x160
	CH41_TASK_ID   volatile.Register32 // 0x164
	CH42_EVT_ID    volatile.Register32 // 0x168
	CH42_TASK_ID   volatile.Register32 // 0x16C
	CH43_EVT_ID    volatile.Register32 // 0x170
	CH43_TASK_ID   volatile.Register32 // 0x174
	CH44_EVT_ID    volatile.Register32 // 0x178
	CH44_TASK_ID   volatile.Register32 // 0x17C
	CH45_EVT_ID    volatile.Register32 // 0x180
	CH45_TASK_ID   volatile.Register32 // 0x184
	CH46_EVT_ID    volatile.Register32 // 0x188
	CH46_TASK_ID   volatile.Register32 // 0x18C
	CH47_EVT_ID    volatile.Register32 // 0x190
	CH47_TASK_ID   volatile.Register32 // 0x194
	CH48_EVT_ID    volatile.Register32 // 0x198
	CH48_TASK_ID   volatile.Register32 // 0x19C
	CH49_EVT_ID    volatile.Register32 // 0x1A0
	CH49_TASK_ID   volatile.Register32 // 0x1A4
	CLK_EN         volatile.Register32 // 0x1A8
	DATE           volatile.Register32 // 0x1AC
}

// SOC_ETM.CH_ENA_AD0: channel enable register
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA0(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x1)|value)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA0() uint32 {
	return volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x1
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA1(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x2)|value<<1)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA1() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x2) >> 1
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA2(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x4)|value<<2)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA2() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x4) >> 2
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA3(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x8)|value<<3)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA3() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x8) >> 3
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA4(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x10)|value<<4)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA4() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x10) >> 4
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA5(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x20)|value<<5)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA5() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x20) >> 5
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA6(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x40)|value<<6)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA6() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x40) >> 6
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA7(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x80)|value<<7)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA7() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x80) >> 7
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA8(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x100)|value<<8)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA8() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x100) >> 8
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA9(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x200)|value<<9)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA9() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x200) >> 9
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA10(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x400)|value<<10)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA10() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x400) >> 10
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA11(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x800)|value<<11)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA11() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x800) >> 11
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA12(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x1000)|value<<12)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA12() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x1000) >> 12
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA13(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x2000)|value<<13)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA13() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x2000) >> 13
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA14(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x4000)|value<<14)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA14() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x4000) >> 14
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA15(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x8000)|value<<15)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA15() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x8000) >> 15
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA16(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x10000)|value<<16)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA16() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x10000) >> 16
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA17(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x20000)|value<<17)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA17() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x20000) >> 17
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA18(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x40000)|value<<18)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA18() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x40000) >> 18
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA19(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x80000)|value<<19)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA19() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x80000) >> 19
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA20(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x100000)|value<<20)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA20() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x100000) >> 20
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA21(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x200000)|value<<21)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA21() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x200000) >> 21
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA22(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x400000)|value<<22)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA22() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x400000) >> 22
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA23(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x800000)|value<<23)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA23() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x800000) >> 23
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA24(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x1000000)|value<<24)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA24() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x1000000) >> 24
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA25(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x2000000)|value<<25)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA25() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x2000000) >> 25
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA26(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x4000000)|value<<26)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA26() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x4000000) >> 26
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA27(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x8000000)|value<<27)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA27() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x8000000) >> 27
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA28(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x10000000)|value<<28)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA28() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x10000000) >> 28
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA29(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x20000000)|value<<29)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA29() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x20000000) >> 29
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA30(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x40000000)|value<<30)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA30() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x40000000) >> 30
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CH_ENA31(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0.Reg, volatile.LoadUint32(&o.CH_ENA_AD0.Reg)&^(0x80000000)|value<<31)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CH_ENA31() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0.Reg) & 0x80000000) >> 31
}

// SOC_ETM.CH_ENA_AD0_SET: channel enable set register
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET0(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x1)|value)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET0() uint32 {
	return volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x1
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET1(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x2)|value<<1)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET1() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x2) >> 1
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET2(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x4)|value<<2)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET2() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x4) >> 2
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET3(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x8)|value<<3)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET3() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x8) >> 3
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET4(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x10)|value<<4)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET4() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x10) >> 4
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET5(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x20)|value<<5)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET5() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x20) >> 5
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET6(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x40)|value<<6)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET6() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x40) >> 6
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET7(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x80)|value<<7)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET7() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x80) >> 7
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET8(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x100)|value<<8)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET8() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x100) >> 8
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET9(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x200)|value<<9)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET9() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x200) >> 9
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET10(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x400)|value<<10)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET10() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x400) >> 10
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET11(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x800)|value<<11)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET11() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x800) >> 11
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET12(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET12() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x1000) >> 12
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET13(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET13() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x2000) >> 13
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET14(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET14() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x4000) >> 14
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET15(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET15() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x8000) >> 15
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET16(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x10000)|value<<16)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET16() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x10000) >> 16
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET17(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x20000)|value<<17)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET17() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x20000) >> 17
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET18(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x40000)|value<<18)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET18() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x40000) >> 18
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET19(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x80000)|value<<19)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET19() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x80000) >> 19
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET20(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x100000)|value<<20)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET20() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x100000) >> 20
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET21(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x200000)|value<<21)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET21() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x200000) >> 21
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET22(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x400000)|value<<22)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET22() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x400000) >> 22
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET23(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x800000)|value<<23)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET23() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x800000) >> 23
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET24(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x1000000)|value<<24)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET24() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x1000000) >> 24
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET25(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x2000000)|value<<25)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET25() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x2000000) >> 25
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET26(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x4000000)|value<<26)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET26() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x4000000) >> 26
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET27(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x8000000)|value<<27)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET27() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x8000000) >> 27
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET28(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x10000000)|value<<28)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET28() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x10000000) >> 28
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET29(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET29() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x20000000) >> 29
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET30(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET30() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x40000000) >> 30
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_SET_CH_SET31(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_SET_CH_SET31() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_SET.Reg) & 0x80000000) >> 31
}

// SOC_ETM.CH_ENA_AD0_CLR: channel enable clear register
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR0(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x1)|value)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR0() uint32 {
	return volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x1
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR1(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR1() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x2) >> 1
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR2(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR2() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x4) >> 2
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR3(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR3() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x8) >> 3
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR4(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR4() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x10) >> 4
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR5(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR5() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x20) >> 5
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR6(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR6() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x40) >> 6
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR7(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR7() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x80) >> 7
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR8(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR8() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x100) >> 8
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR9(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR9() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x200) >> 9
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR10(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR10() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x400) >> 10
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR11(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR11() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x800) >> 11
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR12(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR12() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x1000) >> 12
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR13(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR13() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x2000) >> 13
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR14(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR14() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x4000) >> 14
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR15(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR15() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x8000) >> 15
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR16(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR16() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x10000) >> 16
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR17(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR17() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x20000) >> 17
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR18(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR18() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x40000) >> 18
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR19(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR19() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x80000) >> 19
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR20(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR20() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x100000) >> 20
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR21(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x200000)|value<<21)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR21() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x200000) >> 21
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR22(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x400000)|value<<22)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR22() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x400000) >> 22
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR23(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x800000)|value<<23)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR23() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x800000) >> 23
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR24(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x1000000)|value<<24)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR24() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x1000000) >> 24
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR25(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x2000000)|value<<25)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR25() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x2000000) >> 25
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR26(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x4000000)|value<<26)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR26() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x4000000) >> 26
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR27(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x8000000)|value<<27)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR27() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x8000000) >> 27
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR28(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR28() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x10000000) >> 28
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR29(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR29() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x20000000) >> 29
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR30(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR30() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x40000000) >> 30
}
func (o *SOC_ETM_Type) SetCH_ENA_AD0_CLR_CH_CLR31(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD0_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD0_CLR_CH_CLR31() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD0_CLR.Reg) & 0x80000000) >> 31
}

// SOC_ETM.CH_ENA_AD1: channel enable register
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA32(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x1)|value)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA32() uint32 {
	return volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x1
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA33(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x2)|value<<1)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA33() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x2) >> 1
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA34(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x4)|value<<2)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA34() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x4) >> 2
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA35(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x8)|value<<3)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA35() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x8) >> 3
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA36(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x10)|value<<4)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA36() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x10) >> 4
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA37(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x20)|value<<5)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA37() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x20) >> 5
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA38(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x40)|value<<6)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA38() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x40) >> 6
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA39(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x80)|value<<7)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA39() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x80) >> 7
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA40(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x100)|value<<8)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA40() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x100) >> 8
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA41(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x200)|value<<9)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA41() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x200) >> 9
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA42(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x400)|value<<10)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA42() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x400) >> 10
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA43(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x800)|value<<11)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA43() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x800) >> 11
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA44(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x1000)|value<<12)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA44() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x1000) >> 12
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA45(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x2000)|value<<13)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA45() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x2000) >> 13
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA46(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x4000)|value<<14)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA46() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x4000) >> 14
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA47(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x8000)|value<<15)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA47() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x8000) >> 15
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA48(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x10000)|value<<16)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA48() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x10000) >> 16
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CH_ENA49(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1.Reg, volatile.LoadUint32(&o.CH_ENA_AD1.Reg)&^(0x20000)|value<<17)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CH_ENA49() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1.Reg) & 0x20000) >> 17
}

// SOC_ETM.CH_ENA_AD1_SET: channel enable set register
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET32(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x1)|value)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET32() uint32 {
	return volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x1
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET33(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x2)|value<<1)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET33() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x2) >> 1
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET34(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x4)|value<<2)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET34() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x4) >> 2
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET35(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x8)|value<<3)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET35() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x8) >> 3
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET36(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x10)|value<<4)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET36() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x10) >> 4
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET37(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x20)|value<<5)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET37() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x20) >> 5
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET38(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x40)|value<<6)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET38() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x40) >> 6
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET39(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x80)|value<<7)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET39() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x80) >> 7
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET40(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x100)|value<<8)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET40() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x100) >> 8
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET41(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x200)|value<<9)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET41() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x200) >> 9
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET42(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x400)|value<<10)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET42() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x400) >> 10
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET43(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x800)|value<<11)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET43() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x800) >> 11
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET44(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET44() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x1000) >> 12
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET45(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET45() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x2000) >> 13
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET46(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET46() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x4000) >> 14
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET47(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET47() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x8000) >> 15
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET48(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x10000)|value<<16)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET48() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x10000) >> 16
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_SET_CH_SET49(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_SET.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg)&^(0x20000)|value<<17)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_SET_CH_SET49() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_SET.Reg) & 0x20000) >> 17
}

// SOC_ETM.CH_ENA_AD1_CLR: channel enable clear register
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR32(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x1)|value)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR32() uint32 {
	return volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x1
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR33(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR33() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x2) >> 1
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR34(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR34() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x4) >> 2
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR35(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR35() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x8) >> 3
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR36(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR36() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x10) >> 4
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR37(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR37() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x20) >> 5
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR38(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR38() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x40) >> 6
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR39(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR39() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x80) >> 7
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR40(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR40() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x100) >> 8
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR41(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR41() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x200) >> 9
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR42(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR42() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x400) >> 10
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR43(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR43() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x800) >> 11
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR44(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR44() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x1000) >> 12
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR45(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR45() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x2000) >> 13
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR46(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR46() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x4000) >> 14
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR47(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR47() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x8000) >> 15
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR48(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR48() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x10000) >> 16
}
func (o *SOC_ETM_Type) SetCH_ENA_AD1_CLR_CH_CLR49(value uint32) {
	volatile.StoreUint32(&o.CH_ENA_AD1_CLR.Reg, volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *SOC_ETM_Type) GetCH_ENA_AD1_CLR_CH_CLR49() uint32 {
	return (volatile.LoadUint32(&o.CH_ENA_AD1_CLR.Reg) & 0x20000) >> 17
}

// SOC_ETM.CH0_EVT_ID: channel0 event id register
func (o *SOC_ETM_Type) SetCH0_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH0_EVT_ID.Reg, volatile.LoadUint32(&o.CH0_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH0_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH0_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH0_TASK_ID: channel0 task id register
func (o *SOC_ETM_Type) SetCH0_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH0_TASK_ID.Reg, volatile.LoadUint32(&o.CH0_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH0_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH0_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH1_EVT_ID: channel1 event id register
func (o *SOC_ETM_Type) SetCH1_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH1_EVT_ID.Reg, volatile.LoadUint32(&o.CH1_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH1_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH1_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH1_TASK_ID: channel1 task id register
func (o *SOC_ETM_Type) SetCH1_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH1_TASK_ID.Reg, volatile.LoadUint32(&o.CH1_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH1_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH1_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH2_EVT_ID: channel2 event id register
func (o *SOC_ETM_Type) SetCH2_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH2_EVT_ID.Reg, volatile.LoadUint32(&o.CH2_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH2_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH2_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH2_TASK_ID: channel2 task id register
func (o *SOC_ETM_Type) SetCH2_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH2_TASK_ID.Reg, volatile.LoadUint32(&o.CH2_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH2_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH2_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH3_EVT_ID: channel3 event id register
func (o *SOC_ETM_Type) SetCH3_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH3_EVT_ID.Reg, volatile.LoadUint32(&o.CH3_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH3_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH3_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH3_TASK_ID: channel3 task id register
func (o *SOC_ETM_Type) SetCH3_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH3_TASK_ID.Reg, volatile.LoadUint32(&o.CH3_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH3_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH3_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH4_EVT_ID: channel4 event id register
func (o *SOC_ETM_Type) SetCH4_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH4_EVT_ID.Reg, volatile.LoadUint32(&o.CH4_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH4_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH4_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH4_TASK_ID: channel4 task id register
func (o *SOC_ETM_Type) SetCH4_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH4_TASK_ID.Reg, volatile.LoadUint32(&o.CH4_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH4_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH4_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH5_EVT_ID: channel5 event id register
func (o *SOC_ETM_Type) SetCH5_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH5_EVT_ID.Reg, volatile.LoadUint32(&o.CH5_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH5_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH5_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH5_TASK_ID: channel5 task id register
func (o *SOC_ETM_Type) SetCH5_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH5_TASK_ID.Reg, volatile.LoadUint32(&o.CH5_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH5_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH5_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH6_EVT_ID: channel6 event id register
func (o *SOC_ETM_Type) SetCH6_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH6_EVT_ID.Reg, volatile.LoadUint32(&o.CH6_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH6_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH6_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH6_TASK_ID: channel6 task id register
func (o *SOC_ETM_Type) SetCH6_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH6_TASK_ID.Reg, volatile.LoadUint32(&o.CH6_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH6_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH6_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH7_EVT_ID: channel7 event id register
func (o *SOC_ETM_Type) SetCH7_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH7_EVT_ID.Reg, volatile.LoadUint32(&o.CH7_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH7_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH7_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH7_TASK_ID: channel7 task id register
func (o *SOC_ETM_Type) SetCH7_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH7_TASK_ID.Reg, volatile.LoadUint32(&o.CH7_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH7_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH7_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH8_EVT_ID: channel8 event id register
func (o *SOC_ETM_Type) SetCH8_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH8_EVT_ID.Reg, volatile.LoadUint32(&o.CH8_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH8_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH8_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH8_TASK_ID: channel8 task id register
func (o *SOC_ETM_Type) SetCH8_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH8_TASK_ID.Reg, volatile.LoadUint32(&o.CH8_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH8_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH8_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH9_EVT_ID: channel9 event id register
func (o *SOC_ETM_Type) SetCH9_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH9_EVT_ID.Reg, volatile.LoadUint32(&o.CH9_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH9_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH9_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH9_TASK_ID: channel9 task id register
func (o *SOC_ETM_Type) SetCH9_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH9_TASK_ID.Reg, volatile.LoadUint32(&o.CH9_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH9_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH9_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH10_EVT_ID: channel10 event id register
func (o *SOC_ETM_Type) SetCH10_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH10_EVT_ID.Reg, volatile.LoadUint32(&o.CH10_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH10_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH10_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH10_TASK_ID: channel10 task id register
func (o *SOC_ETM_Type) SetCH10_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH10_TASK_ID.Reg, volatile.LoadUint32(&o.CH10_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH10_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH10_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH11_EVT_ID: channel11 event id register
func (o *SOC_ETM_Type) SetCH11_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH11_EVT_ID.Reg, volatile.LoadUint32(&o.CH11_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH11_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH11_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH11_TASK_ID: channel11 task id register
func (o *SOC_ETM_Type) SetCH11_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH11_TASK_ID.Reg, volatile.LoadUint32(&o.CH11_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH11_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH11_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH12_EVT_ID: channel12 event id register
func (o *SOC_ETM_Type) SetCH12_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH12_EVT_ID.Reg, volatile.LoadUint32(&o.CH12_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH12_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH12_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH12_TASK_ID: channel12 task id register
func (o *SOC_ETM_Type) SetCH12_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH12_TASK_ID.Reg, volatile.LoadUint32(&o.CH12_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH12_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH12_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH13_EVT_ID: channel13 event id register
func (o *SOC_ETM_Type) SetCH13_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH13_EVT_ID.Reg, volatile.LoadUint32(&o.CH13_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH13_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH13_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH13_TASK_ID: channel13 task id register
func (o *SOC_ETM_Type) SetCH13_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH13_TASK_ID.Reg, volatile.LoadUint32(&o.CH13_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH13_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH13_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH14_EVT_ID: channel14 event id register
func (o *SOC_ETM_Type) SetCH14_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH14_EVT_ID.Reg, volatile.LoadUint32(&o.CH14_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH14_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH14_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH14_TASK_ID: channel14 task id register
func (o *SOC_ETM_Type) SetCH14_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH14_TASK_ID.Reg, volatile.LoadUint32(&o.CH14_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH14_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH14_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH15_EVT_ID: channel15 event id register
func (o *SOC_ETM_Type) SetCH15_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH15_EVT_ID.Reg, volatile.LoadUint32(&o.CH15_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH15_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH15_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH15_TASK_ID: channel15 task id register
func (o *SOC_ETM_Type) SetCH15_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH15_TASK_ID.Reg, volatile.LoadUint32(&o.CH15_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH15_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH15_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH16_EVT_ID: channel16 event id register
func (o *SOC_ETM_Type) SetCH16_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH16_EVT_ID.Reg, volatile.LoadUint32(&o.CH16_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH16_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH16_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH16_TASK_ID: channel16 task id register
func (o *SOC_ETM_Type) SetCH16_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH16_TASK_ID.Reg, volatile.LoadUint32(&o.CH16_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH16_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH16_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH17_EVT_ID: channel17 event id register
func (o *SOC_ETM_Type) SetCH17_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH17_EVT_ID.Reg, volatile.LoadUint32(&o.CH17_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH17_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH17_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH17_TASK_ID: channel17 task id register
func (o *SOC_ETM_Type) SetCH17_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH17_TASK_ID.Reg, volatile.LoadUint32(&o.CH17_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH17_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH17_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH18_EVT_ID: channel18 event id register
func (o *SOC_ETM_Type) SetCH18_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH18_EVT_ID.Reg, volatile.LoadUint32(&o.CH18_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH18_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH18_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH18_TASK_ID: channel18 task id register
func (o *SOC_ETM_Type) SetCH18_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH18_TASK_ID.Reg, volatile.LoadUint32(&o.CH18_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH18_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH18_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH19_EVT_ID: channel19 event id register
func (o *SOC_ETM_Type) SetCH19_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH19_EVT_ID.Reg, volatile.LoadUint32(&o.CH19_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH19_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH19_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH19_TASK_ID: channel19 task id register
func (o *SOC_ETM_Type) SetCH19_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH19_TASK_ID.Reg, volatile.LoadUint32(&o.CH19_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH19_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH19_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH20_EVT_ID: channel20 event id register
func (o *SOC_ETM_Type) SetCH20_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH20_EVT_ID.Reg, volatile.LoadUint32(&o.CH20_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH20_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH20_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH20_TASK_ID: channel20 task id register
func (o *SOC_ETM_Type) SetCH20_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH20_TASK_ID.Reg, volatile.LoadUint32(&o.CH20_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH20_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH20_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH21_EVT_ID: channel21 event id register
func (o *SOC_ETM_Type) SetCH21_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH21_EVT_ID.Reg, volatile.LoadUint32(&o.CH21_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH21_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH21_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH21_TASK_ID: channel21 task id register
func (o *SOC_ETM_Type) SetCH21_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH21_TASK_ID.Reg, volatile.LoadUint32(&o.CH21_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH21_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH21_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH22_EVT_ID: channel22 event id register
func (o *SOC_ETM_Type) SetCH22_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH22_EVT_ID.Reg, volatile.LoadUint32(&o.CH22_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH22_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH22_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH22_TASK_ID: channel22 task id register
func (o *SOC_ETM_Type) SetCH22_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH22_TASK_ID.Reg, volatile.LoadUint32(&o.CH22_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH22_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH22_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH23_EVT_ID: channel23 event id register
func (o *SOC_ETM_Type) SetCH23_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH23_EVT_ID.Reg, volatile.LoadUint32(&o.CH23_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH23_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH23_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH23_TASK_ID: channel23 task id register
func (o *SOC_ETM_Type) SetCH23_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH23_TASK_ID.Reg, volatile.LoadUint32(&o.CH23_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH23_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH23_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH24_EVT_ID: channel24 event id register
func (o *SOC_ETM_Type) SetCH24_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH24_EVT_ID.Reg, volatile.LoadUint32(&o.CH24_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH24_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH24_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH24_TASK_ID: channel24 task id register
func (o *SOC_ETM_Type) SetCH24_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH24_TASK_ID.Reg, volatile.LoadUint32(&o.CH24_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH24_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH24_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH25_EVT_ID: channel25 event id register
func (o *SOC_ETM_Type) SetCH25_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH25_EVT_ID.Reg, volatile.LoadUint32(&o.CH25_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH25_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH25_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH25_TASK_ID: channel25 task id register
func (o *SOC_ETM_Type) SetCH25_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH25_TASK_ID.Reg, volatile.LoadUint32(&o.CH25_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH25_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH25_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH26_EVT_ID: channel26 event id register
func (o *SOC_ETM_Type) SetCH26_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH26_EVT_ID.Reg, volatile.LoadUint32(&o.CH26_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH26_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH26_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH26_TASK_ID: channel26 task id register
func (o *SOC_ETM_Type) SetCH26_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH26_TASK_ID.Reg, volatile.LoadUint32(&o.CH26_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH26_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH26_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH27_EVT_ID: channel27 event id register
func (o *SOC_ETM_Type) SetCH27_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH27_EVT_ID.Reg, volatile.LoadUint32(&o.CH27_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH27_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH27_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH27_TASK_ID: channel27 task id register
func (o *SOC_ETM_Type) SetCH27_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH27_TASK_ID.Reg, volatile.LoadUint32(&o.CH27_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH27_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH27_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH28_EVT_ID: channel28 event id register
func (o *SOC_ETM_Type) SetCH28_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH28_EVT_ID.Reg, volatile.LoadUint32(&o.CH28_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH28_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH28_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH28_TASK_ID: channel28 task id register
func (o *SOC_ETM_Type) SetCH28_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH28_TASK_ID.Reg, volatile.LoadUint32(&o.CH28_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH28_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH28_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH29_EVT_ID: channel29 event id register
func (o *SOC_ETM_Type) SetCH29_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH29_EVT_ID.Reg, volatile.LoadUint32(&o.CH29_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH29_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH29_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH29_TASK_ID: channel29 task id register
func (o *SOC_ETM_Type) SetCH29_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH29_TASK_ID.Reg, volatile.LoadUint32(&o.CH29_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH29_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH29_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH30_EVT_ID: channel30 event id register
func (o *SOC_ETM_Type) SetCH30_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH30_EVT_ID.Reg, volatile.LoadUint32(&o.CH30_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH30_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH30_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH30_TASK_ID: channel30 task id register
func (o *SOC_ETM_Type) SetCH30_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH30_TASK_ID.Reg, volatile.LoadUint32(&o.CH30_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH30_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH30_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH31_EVT_ID: channel31 event id register
func (o *SOC_ETM_Type) SetCH31_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH31_EVT_ID.Reg, volatile.LoadUint32(&o.CH31_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH31_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH31_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH31_TASK_ID: channel31 task id register
func (o *SOC_ETM_Type) SetCH31_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH31_TASK_ID.Reg, volatile.LoadUint32(&o.CH31_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH31_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH31_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH32_EVT_ID: channel32 event id register
func (o *SOC_ETM_Type) SetCH32_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH32_EVT_ID.Reg, volatile.LoadUint32(&o.CH32_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH32_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH32_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH32_TASK_ID: channel32 task id register
func (o *SOC_ETM_Type) SetCH32_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH32_TASK_ID.Reg, volatile.LoadUint32(&o.CH32_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH32_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH32_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH33_EVT_ID: channel33 event id register
func (o *SOC_ETM_Type) SetCH33_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH33_EVT_ID.Reg, volatile.LoadUint32(&o.CH33_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH33_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH33_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH33_TASK_ID: channel33 task id register
func (o *SOC_ETM_Type) SetCH33_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH33_TASK_ID.Reg, volatile.LoadUint32(&o.CH33_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH33_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH33_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH34_EVT_ID: channel34 event id register
func (o *SOC_ETM_Type) SetCH34_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH34_EVT_ID.Reg, volatile.LoadUint32(&o.CH34_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH34_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH34_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH34_TASK_ID: channel34 task id register
func (o *SOC_ETM_Type) SetCH34_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH34_TASK_ID.Reg, volatile.LoadUint32(&o.CH34_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH34_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH34_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH35_EVT_ID: channel35 event id register
func (o *SOC_ETM_Type) SetCH35_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH35_EVT_ID.Reg, volatile.LoadUint32(&o.CH35_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH35_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH35_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH35_TASK_ID: channel35 task id register
func (o *SOC_ETM_Type) SetCH35_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH35_TASK_ID.Reg, volatile.LoadUint32(&o.CH35_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH35_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH35_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH36_EVT_ID: channel36 event id register
func (o *SOC_ETM_Type) SetCH36_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH36_EVT_ID.Reg, volatile.LoadUint32(&o.CH36_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH36_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH36_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH36_TASK_ID: channel36 task id register
func (o *SOC_ETM_Type) SetCH36_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH36_TASK_ID.Reg, volatile.LoadUint32(&o.CH36_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH36_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH36_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH37_EVT_ID: channel37 event id register
func (o *SOC_ETM_Type) SetCH37_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH37_EVT_ID.Reg, volatile.LoadUint32(&o.CH37_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH37_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH37_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH37_TASK_ID: channel37 task id register
func (o *SOC_ETM_Type) SetCH37_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH37_TASK_ID.Reg, volatile.LoadUint32(&o.CH37_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH37_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH37_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH38_EVT_ID: channel38 event id register
func (o *SOC_ETM_Type) SetCH38_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH38_EVT_ID.Reg, volatile.LoadUint32(&o.CH38_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH38_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH38_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH38_TASK_ID: channel38 task id register
func (o *SOC_ETM_Type) SetCH38_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH38_TASK_ID.Reg, volatile.LoadUint32(&o.CH38_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH38_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH38_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH39_EVT_ID: channel39 event id register
func (o *SOC_ETM_Type) SetCH39_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH39_EVT_ID.Reg, volatile.LoadUint32(&o.CH39_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH39_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH39_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH39_TASK_ID: channel39 task id register
func (o *SOC_ETM_Type) SetCH39_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH39_TASK_ID.Reg, volatile.LoadUint32(&o.CH39_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH39_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH39_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH40_EVT_ID: channel40 event id register
func (o *SOC_ETM_Type) SetCH40_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH40_EVT_ID.Reg, volatile.LoadUint32(&o.CH40_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH40_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH40_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH40_TASK_ID: channel40 task id register
func (o *SOC_ETM_Type) SetCH40_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH40_TASK_ID.Reg, volatile.LoadUint32(&o.CH40_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH40_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH40_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH41_EVT_ID: channel41 event id register
func (o *SOC_ETM_Type) SetCH41_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH41_EVT_ID.Reg, volatile.LoadUint32(&o.CH41_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH41_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH41_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH41_TASK_ID: channel41 task id register
func (o *SOC_ETM_Type) SetCH41_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH41_TASK_ID.Reg, volatile.LoadUint32(&o.CH41_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH41_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH41_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH42_EVT_ID: channel42 event id register
func (o *SOC_ETM_Type) SetCH42_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH42_EVT_ID.Reg, volatile.LoadUint32(&o.CH42_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH42_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH42_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH42_TASK_ID: channel42 task id register
func (o *SOC_ETM_Type) SetCH42_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH42_TASK_ID.Reg, volatile.LoadUint32(&o.CH42_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH42_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH42_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH43_EVT_ID: channel43 event id register
func (o *SOC_ETM_Type) SetCH43_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH43_EVT_ID.Reg, volatile.LoadUint32(&o.CH43_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH43_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH43_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH43_TASK_ID: channel43 task id register
func (o *SOC_ETM_Type) SetCH43_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH43_TASK_ID.Reg, volatile.LoadUint32(&o.CH43_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH43_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH43_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH44_EVT_ID: channel44 event id register
func (o *SOC_ETM_Type) SetCH44_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH44_EVT_ID.Reg, volatile.LoadUint32(&o.CH44_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH44_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH44_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH44_TASK_ID: channel44 task id register
func (o *SOC_ETM_Type) SetCH44_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH44_TASK_ID.Reg, volatile.LoadUint32(&o.CH44_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH44_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH44_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH45_EVT_ID: channel45 event id register
func (o *SOC_ETM_Type) SetCH45_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH45_EVT_ID.Reg, volatile.LoadUint32(&o.CH45_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH45_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH45_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH45_TASK_ID: channel45 task id register
func (o *SOC_ETM_Type) SetCH45_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH45_TASK_ID.Reg, volatile.LoadUint32(&o.CH45_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH45_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH45_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH46_EVT_ID: channel46 event id register
func (o *SOC_ETM_Type) SetCH46_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH46_EVT_ID.Reg, volatile.LoadUint32(&o.CH46_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH46_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH46_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH46_TASK_ID: channel46 task id register
func (o *SOC_ETM_Type) SetCH46_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH46_TASK_ID.Reg, volatile.LoadUint32(&o.CH46_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH46_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH46_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH47_EVT_ID: channel47 event id register
func (o *SOC_ETM_Type) SetCH47_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH47_EVT_ID.Reg, volatile.LoadUint32(&o.CH47_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH47_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH47_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH47_TASK_ID: channel47 task id register
func (o *SOC_ETM_Type) SetCH47_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH47_TASK_ID.Reg, volatile.LoadUint32(&o.CH47_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH47_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH47_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH48_EVT_ID: channel48 event id register
func (o *SOC_ETM_Type) SetCH48_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH48_EVT_ID.Reg, volatile.LoadUint32(&o.CH48_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH48_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH48_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH48_TASK_ID: channel48 task id register
func (o *SOC_ETM_Type) SetCH48_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH48_TASK_ID.Reg, volatile.LoadUint32(&o.CH48_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH48_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH48_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CH49_EVT_ID: channel49 event id register
func (o *SOC_ETM_Type) SetCH49_EVT_ID(value uint32) {
	volatile.StoreUint32(&o.CH49_EVT_ID.Reg, volatile.LoadUint32(&o.CH49_EVT_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH49_EVT_ID() uint32 {
	return volatile.LoadUint32(&o.CH49_EVT_ID.Reg) & 0xff
}

// SOC_ETM.CH49_TASK_ID: channel49 task id register
func (o *SOC_ETM_Type) SetCH49_TASK_ID(value uint32) {
	volatile.StoreUint32(&o.CH49_TASK_ID.Reg, volatile.LoadUint32(&o.CH49_TASK_ID.Reg)&^(0xff)|value)
}
func (o *SOC_ETM_Type) GetCH49_TASK_ID() uint32 {
	return volatile.LoadUint32(&o.CH49_TASK_ID.Reg) & 0xff
}

// SOC_ETM.CLK_EN: etm clock enable register
func (o *SOC_ETM_Type) SetCLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_EN.Reg, volatile.LoadUint32(&o.CLK_EN.Reg)&^(0x1)|value)
}
func (o *SOC_ETM_Type) GetCLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLK_EN.Reg) & 0x1
}

// SOC_ETM.DATE: etm date register
func (o *SOC_ETM_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *SOC_ETM_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// SPI (Serial Peripheral Interface) Controller 0
type SPI0_Type struct {
	SPI_MEM_CMD                  volatile.Register32 // 0x0
	_                            [4]byte
	SPI_MEM_CTRL                 volatile.Register32 // 0x8
	SPI_MEM_CTRL1                volatile.Register32 // 0xC
	SPI_MEM_CTRL2                volatile.Register32 // 0x10
	SPI_MEM_CLOCK                volatile.Register32 // 0x14
	SPI_MEM_USER                 volatile.Register32 // 0x18
	SPI_MEM_USER1                volatile.Register32 // 0x1C
	SPI_MEM_USER2                volatile.Register32 // 0x20
	_                            [8]byte
	SPI_MEM_RD_STATUS            volatile.Register32 // 0x2C
	_                            [4]byte
	SPI_MEM_MISC                 volatile.Register32 // 0x34
	_                            [4]byte
	SPI_MEM_CACHE_FCTRL          volatile.Register32 // 0x3C
	SPI_MEM_CACHE_SCTRL          volatile.Register32 // 0x40
	SPI_MEM_SRAM_CMD             volatile.Register32 // 0x44
	SPI_MEM_SRAM_DRD_CMD         volatile.Register32 // 0x48
	SPI_MEM_SRAM_DWR_CMD         volatile.Register32 // 0x4C
	SPI_MEM_SRAM_CLK             volatile.Register32 // 0x50
	SPI_MEM_FSM                  volatile.Register32 // 0x54
	_                            [104]byte
	SPI_MEM_INT_ENA              volatile.Register32 // 0xC0
	SPI_MEM_INT_CLR              volatile.Register32 // 0xC4
	SPI_MEM_INT_RAW              volatile.Register32 // 0xC8
	SPI_MEM_INT_ST               volatile.Register32 // 0xCC
	_                            [4]byte
	SPI_MEM_DDR                  volatile.Register32 // 0xD4
	SPI_SMEM_DDR                 volatile.Register32 // 0xD8
	_                            [36]byte
	SPI_FMEM_PMS0_ATTR           volatile.Register32 // 0x100
	SPI_FMEM_PMS1_ATTR           volatile.Register32 // 0x104
	SPI_FMEM_PMS2_ATTR           volatile.Register32 // 0x108
	SPI_FMEM_PMS3_ATTR           volatile.Register32 // 0x10C
	SPI_FMEM_PMS0_ADDR           volatile.Register32 // 0x110
	SPI_FMEM_PMS1_ADDR           volatile.Register32 // 0x114
	SPI_FMEM_PMS2_ADDR           volatile.Register32 // 0x118
	SPI_FMEM_PMS3_ADDR           volatile.Register32 // 0x11C
	SPI_FMEM_PMS0_SIZE           volatile.Register32 // 0x120
	SPI_FMEM_PMS1_SIZE           volatile.Register32 // 0x124
	SPI_FMEM_PMS2_SIZE           volatile.Register32 // 0x128
	SPI_FMEM_PMS3_SIZE           volatile.Register32 // 0x12C
	SPI_SMEM_PMS0_ATTR           volatile.Register32 // 0x130
	SPI_SMEM_PMS1_ATTR           volatile.Register32 // 0x134
	SPI_SMEM_PMS2_ATTR           volatile.Register32 // 0x138
	SPI_SMEM_PMS3_ATTR           volatile.Register32 // 0x13C
	SPI_SMEM_PMS0_ADDR           volatile.Register32 // 0x140
	SPI_SMEM_PMS1_ADDR           volatile.Register32 // 0x144
	SPI_SMEM_PMS2_ADDR           volatile.Register32 // 0x148
	SPI_SMEM_PMS3_ADDR           volatile.Register32 // 0x14C
	SPI_SMEM_PMS0_SIZE           volatile.Register32 // 0x150
	SPI_SMEM_PMS1_SIZE           volatile.Register32 // 0x154
	SPI_SMEM_PMS2_SIZE           volatile.Register32 // 0x158
	SPI_SMEM_PMS3_SIZE           volatile.Register32 // 0x15C
	_                            [4]byte
	SPI_MEM_PMS_REJECT           volatile.Register32 // 0x164
	SPI_MEM_ECC_CTRL             volatile.Register32 // 0x168
	SPI_MEM_ECC_ERR_ADDR         volatile.Register32 // 0x16C
	SPI_MEM_AXI_ERR_ADDR         volatile.Register32 // 0x170
	SPI_SMEM_ECC_CTRL            volatile.Register32 // 0x174
	_                            [8]byte
	SPI_MEM_TIMING_CALI          volatile.Register32 // 0x180
	SPI_MEM_DIN_MODE             volatile.Register32 // 0x184
	SPI_MEM_DIN_NUM              volatile.Register32 // 0x188
	SPI_MEM_DOUT_MODE            volatile.Register32 // 0x18C
	SPI_SMEM_TIMING_CALI         volatile.Register32 // 0x190
	SPI_SMEM_DIN_MODE            volatile.Register32 // 0x194
	SPI_SMEM_DIN_NUM             volatile.Register32 // 0x198
	SPI_SMEM_DOUT_MODE           volatile.Register32 // 0x19C
	SPI_SMEM_AC                  volatile.Register32 // 0x1A0
	_                            [92]byte
	SPI_MEM_CLOCK_GATE           volatile.Register32 // 0x200
	_                            [252]byte
	SPI_MEM_XTS_PLAIN_BASE       volatile.Register32 // 0x300
	_                            [60]byte
	SPI_MEM_XTS_LINESIZE         volatile.Register32 // 0x340
	SPI_MEM_XTS_DESTINATION      volatile.Register32 // 0x344
	SPI_MEM_XTS_PHYSICAL_ADDRESS volatile.Register32 // 0x348
	SPI_MEM_XTS_TRIGGER          volatile.Register32 // 0x34C
	SPI_MEM_XTS_RELEASE          volatile.Register32 // 0x350
	SPI_MEM_XTS_DESTROY          volatile.Register32 // 0x354
	SPI_MEM_XTS_STATE            volatile.Register32 // 0x358
	SPI_MEM_XTS_DATE             volatile.Register32 // 0x35C
	_                            [28]byte
	SPI_MEM_MMU_ITEM_CONTENT     volatile.Register32 // 0x37C
	SPI_MEM_MMU_ITEM_INDEX       volatile.Register32 // 0x380
	SPI_MEM_MMU_POWER_CTRL       volatile.Register32 // 0x384
	SPI_MEM_DPA_CTRL             volatile.Register32 // 0x388
	_                            [100]byte
	SPI_MEM_REGISTERRND_ECO_HIGH volatile.Register32 // 0x3F0
	SPI_MEM_REGISTERRND_ECO_LOW  volatile.Register32 // 0x3F4
	_                            [4]byte
	SPI_MEM_DATE                 volatile.Register32 // 0x3FC
}

// SPI0.SPI_MEM_CMD: SPI0 FSM status register
func (o *SPI0_Type) SetSPI_MEM_CMD_SPI_MEM_MST_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0xf)|value)
}
func (o *SPI0_Type) GetSPI_MEM_CMD_SPI_MEM_MST_ST() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0xf
}
func (o *SPI0_Type) SetSPI_MEM_CMD_SPI_MEM_SLV_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0xf0)|value<<4)
}
func (o *SPI0_Type) GetSPI_MEM_CMD_SPI_MEM_SLV_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0xf0) >> 4
}
func (o *SPI0_Type) SetSPI_MEM_CMD_SPI_MEM_USR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x40000)|value<<18)
}
func (o *SPI0_Type) GetSPI_MEM_CMD_SPI_MEM_USR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x40000) >> 18
}

// SPI0.SPI_MEM_CTRL: SPI0 control register.
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_WDUMMY_DQS_ALWAYS_OUT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_WDUMMY_DQS_ALWAYS_OUT() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_WDUMMY_ALWAYS_OUT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_WDUMMY_ALWAYS_OUT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_FDUMMY_RIN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_FDUMMY_RIN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_FDUMMY_WOUT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_FDUMMY_WOUT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_FDOUT_OCT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_FDOUT_OCT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_FDIN_OCT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_FDIN_OCT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_FADDR_OCT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_FADDR_OCT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_FCMD_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_FCMD_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x100) >> 8
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_FCMD_OCT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_FCMD_OCT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x200) >> 9
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_FASTRD_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_FASTRD_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_FREAD_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_FREAD_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_Q_POL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_Q_POL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x40000) >> 18
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_D_POL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_D_POL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x80000) >> 19
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_FREAD_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_FREAD_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x100000) >> 20
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_WP(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_WP() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x200000) >> 21
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_FREAD_DIO(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_FREAD_DIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x800000) >> 23
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_FREAD_QIO(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_FREAD_QIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x1000000) >> 24
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_DQS_IE_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_DQS_IE_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x40000000) >> 30
}
func (o *SPI0_Type) SetSPI_MEM_CTRL_SPI_MEM_DATA_IE_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL_SPI_MEM_DATA_IE_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x80000000) >> 31
}

// SPI0.SPI_MEM_CTRL1: SPI0 control1 register.
func (o *SPI0_Type) SetSPI_MEM_CTRL1_SPI_MEM_CLK_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0x3)|value)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL1_SPI_MEM_CLK_MODE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0x3
}
func (o *SPI0_Type) SetSPI_MEM_CTRL1_SPI_AR_SIZE0_1_SUPPORT_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0x200000)|value<<21)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL1_SPI_AR_SIZE0_1_SUPPORT_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0x200000) >> 21
}
func (o *SPI0_Type) SetSPI_MEM_CTRL1_SPI_AW_SIZE0_1_SUPPORT_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0x400000)|value<<22)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL1_SPI_AW_SIZE0_1_SUPPORT_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0x400000) >> 22
}
func (o *SPI0_Type) SetSPI_MEM_CTRL1_SPI_AXI_RDATA_BACK_FAST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0x800000)|value<<23)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL1_SPI_AXI_RDATA_BACK_FAST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0x800000) >> 23
}
func (o *SPI0_Type) SetSPI_MEM_CTRL1_SPI_MEM_RRESP_ECC_ERR_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL1_SPI_MEM_RRESP_ECC_ERR_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0x1000000) >> 24
}
func (o *SPI0_Type) SetSPI_MEM_CTRL1_SPI_MEM_AR_SPLICE_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL1_SPI_MEM_AR_SPLICE_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0x2000000) >> 25
}
func (o *SPI0_Type) SetSPI_MEM_CTRL1_SPI_MEM_AW_SPLICE_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL1_SPI_MEM_AW_SPLICE_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0x4000000) >> 26
}
func (o *SPI0_Type) SetSPI_MEM_CTRL1_SPI_MEM_RAM0_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL1_SPI_MEM_RAM0_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0x8000000) >> 27
}
func (o *SPI0_Type) SetSPI_MEM_CTRL1_SPI_MEM_DUAL_RAM_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL1_SPI_MEM_DUAL_RAM_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0x10000000) >> 28
}
func (o *SPI0_Type) SetSPI_MEM_CTRL1_SPI_MEM_FAST_WRITE_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL1_SPI_MEM_FAST_WRITE_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0x20000000) >> 29
}
func (o *SPI0_Type) SetSPI_MEM_CTRL1_SPI_MEM_RXFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL1_SPI_MEM_RXFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0x40000000) >> 30
}
func (o *SPI0_Type) SetSPI_MEM_CTRL1_SPI_MEM_TXFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL1_SPI_MEM_TXFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0x80000000) >> 31
}

// SPI0.SPI_MEM_CTRL2: SPI0 control2 register.
func (o *SPI0_Type) SetSPI_MEM_CTRL2_SPI_MEM_CS_SETUP_TIME(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL2.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg)&^(0x1f)|value)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL2_SPI_MEM_CS_SETUP_TIME() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg) & 0x1f
}
func (o *SPI0_Type) SetSPI_MEM_CTRL2_SPI_MEM_CS_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL2.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg)&^(0x3e0)|value<<5)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL2_SPI_MEM_CS_HOLD_TIME() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg) & 0x3e0) >> 5
}
func (o *SPI0_Type) SetSPI_MEM_CTRL2_SPI_MEM_ECC_CS_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL2.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg)&^(0x1c00)|value<<10)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL2_SPI_MEM_ECC_CS_HOLD_TIME() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg) & 0x1c00) >> 10
}
func (o *SPI0_Type) SetSPI_MEM_CTRL2_SPI_MEM_ECC_SKIP_PAGE_CORNER(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL2.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL2_SPI_MEM_ECC_SKIP_PAGE_CORNER() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPI_MEM_CTRL2_SPI_MEM_ECC_16TO18_BYTE_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL2.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL2_SPI_MEM_ECC_16TO18_BYTE_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPI_MEM_CTRL2_SPI_MEM_SPLIT_TRANS_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL2.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL2_SPI_MEM_SPLIT_TRANS_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg) & 0x1000000) >> 24
}
func (o *SPI0_Type) SetSPI_MEM_CTRL2_SPI_MEM_CS_HOLD_DELAY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL2.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg)&^(0x7e000000)|value<<25)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL2_SPI_MEM_CS_HOLD_DELAY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg) & 0x7e000000) >> 25
}
func (o *SPI0_Type) SetSPI_MEM_CTRL2_SPI_MEM_SYNC_RESET(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL2.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_MEM_CTRL2_SPI_MEM_SYNC_RESET() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg) & 0x80000000) >> 31
}

// SPI0.SPI_MEM_CLOCK: SPI clock division control register.
func (o *SPI0_Type) SetSPI_MEM_CLOCK_SPI_MEM_CLKCNT_L(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CLOCK.Reg, volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg)&^(0xff)|value)
}
func (o *SPI0_Type) GetSPI_MEM_CLOCK_SPI_MEM_CLKCNT_L() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg) & 0xff
}
func (o *SPI0_Type) SetSPI_MEM_CLOCK_SPI_MEM_CLKCNT_H(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CLOCK.Reg, volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg)&^(0xff00)|value<<8)
}
func (o *SPI0_Type) GetSPI_MEM_CLOCK_SPI_MEM_CLKCNT_H() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg) & 0xff00) >> 8
}
func (o *SPI0_Type) SetSPI_MEM_CLOCK_SPI_MEM_CLKCNT_N(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CLOCK.Reg, volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg)&^(0xff0000)|value<<16)
}
func (o *SPI0_Type) GetSPI_MEM_CLOCK_SPI_MEM_CLKCNT_N() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg) & 0xff0000) >> 16
}
func (o *SPI0_Type) SetSPI_MEM_CLOCK_SPI_MEM_CLK_EQU_SYSCLK(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CLOCK.Reg, volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_MEM_CLOCK_SPI_MEM_CLK_EQU_SYSCLK() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg) & 0x80000000) >> 31
}

// SPI0.SPI_MEM_USER: SPI0 user register.
func (o *SPI0_Type) SetSPI_MEM_USER_SPI_MEM_CS_HOLD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPI_MEM_USER_SPI_MEM_CS_HOLD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPI_MEM_USER_SPI_MEM_CS_SETUP(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPI_MEM_USER_SPI_MEM_CS_SETUP() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPI_MEM_USER_SPI_MEM_CK_OUT_EDGE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x200)|value<<9)
}
func (o *SPI0_Type) GetSPI_MEM_USER_SPI_MEM_CK_OUT_EDGE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x200) >> 9
}
func (o *SPI0_Type) SetSPI_MEM_USER_SPI_MEM_USR_DUMMY_IDLE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI0_Type) GetSPI_MEM_USER_SPI_MEM_USR_DUMMY_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x4000000) >> 26
}
func (o *SPI0_Type) SetSPI_MEM_USER_SPI_MEM_USR_DUMMY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI0_Type) GetSPI_MEM_USER_SPI_MEM_USR_DUMMY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x20000000) >> 29
}

// SPI0.SPI_MEM_USER1: SPI0 user1 register.
func (o *SPI0_Type) SetSPI_MEM_USER1_SPI_MEM_USR_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER1.Reg, volatile.LoadUint32(&o.SPI_MEM_USER1.Reg)&^(0x3f)|value)
}
func (o *SPI0_Type) GetSPI_MEM_USER1_SPI_MEM_USR_DUMMY_CYCLELEN() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_USER1.Reg) & 0x3f
}
func (o *SPI0_Type) SetSPI_MEM_USER1_SPI_MEM_USR_DBYTELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER1.Reg, volatile.LoadUint32(&o.SPI_MEM_USER1.Reg)&^(0x1c0)|value<<6)
}
func (o *SPI0_Type) GetSPI_MEM_USER1_SPI_MEM_USR_DBYTELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER1.Reg) & 0x1c0) >> 6
}
func (o *SPI0_Type) SetSPI_MEM_USER1_SPI_MEM_USR_ADDR_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER1.Reg, volatile.LoadUint32(&o.SPI_MEM_USER1.Reg)&^(0xfc000000)|value<<26)
}
func (o *SPI0_Type) GetSPI_MEM_USER1_SPI_MEM_USR_ADDR_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER1.Reg) & 0xfc000000) >> 26
}

// SPI0.SPI_MEM_USER2: SPI0 user2 register.
func (o *SPI0_Type) SetSPI_MEM_USER2_SPI_MEM_USR_COMMAND_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER2.Reg, volatile.LoadUint32(&o.SPI_MEM_USER2.Reg)&^(0xffff)|value)
}
func (o *SPI0_Type) GetSPI_MEM_USER2_SPI_MEM_USR_COMMAND_VALUE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_USER2.Reg) & 0xffff
}
func (o *SPI0_Type) SetSPI_MEM_USER2_SPI_MEM_USR_COMMAND_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER2.Reg, volatile.LoadUint32(&o.SPI_MEM_USER2.Reg)&^(0xf0000000)|value<<28)
}
func (o *SPI0_Type) GetSPI_MEM_USER2_SPI_MEM_USR_COMMAND_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER2.Reg) & 0xf0000000) >> 28
}

// SPI0.SPI_MEM_RD_STATUS: SPI0 read control register.
func (o *SPI0_Type) SetSPI_MEM_RD_STATUS_SPI_MEM_WB_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_RD_STATUS.Reg, volatile.LoadUint32(&o.SPI_MEM_RD_STATUS.Reg)&^(0xff0000)|value<<16)
}
func (o *SPI0_Type) GetSPI_MEM_RD_STATUS_SPI_MEM_WB_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_RD_STATUS.Reg) & 0xff0000) >> 16
}

// SPI0.SPI_MEM_MISC: SPI0 misc register
func (o *SPI0_Type) SetSPI_MEM_MISC_SPI_MEM_FSUB_PIN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MISC.Reg, volatile.LoadUint32(&o.SPI_MEM_MISC.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPI_MEM_MISC_SPI_MEM_FSUB_PIN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_MISC.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPI_MEM_MISC_SPI_MEM_SSUB_PIN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MISC.Reg, volatile.LoadUint32(&o.SPI_MEM_MISC.Reg)&^(0x100)|value<<8)
}
func (o *SPI0_Type) GetSPI_MEM_MISC_SPI_MEM_SSUB_PIN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_MISC.Reg) & 0x100) >> 8
}
func (o *SPI0_Type) SetSPI_MEM_MISC_SPI_MEM_CK_IDLE_EDGE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MISC.Reg, volatile.LoadUint32(&o.SPI_MEM_MISC.Reg)&^(0x200)|value<<9)
}
func (o *SPI0_Type) GetSPI_MEM_MISC_SPI_MEM_CK_IDLE_EDGE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_MISC.Reg) & 0x200) >> 9
}
func (o *SPI0_Type) SetSPI_MEM_MISC_SPI_MEM_CS_KEEP_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MISC.Reg, volatile.LoadUint32(&o.SPI_MEM_MISC.Reg)&^(0x400)|value<<10)
}
func (o *SPI0_Type) GetSPI_MEM_MISC_SPI_MEM_CS_KEEP_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_MISC.Reg) & 0x400) >> 10
}

// SPI0.SPI_MEM_CACHE_FCTRL: SPI0 bit mode control register.
func (o *SPI0_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_AXI_REQ_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_AXI_REQ_EN() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_USR_ADDR_4BYTE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_USR_ADDR_4BYTE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_FLASH_USR_CMD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_FLASH_USR_CMD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x100)|value<<8)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x100) >> 8
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_FCTRL_SPI_SAME_AW_AR_ADDR_CHK_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_FCTRL_SPI_SAME_AW_AR_ADDR_CHK_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x40000000) >> 30
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_FCTRL_SPI_CLOSE_AXI_INF_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_FCTRL_SPI_CLOSE_AXI_INF_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x80000000) >> 31
}

// SPI0.SPI_MEM_CACHE_SCTRL: SPI0 external RAM control register
func (o *SPI0_Type) SetSPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_USR_SADDR_4BYTE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_SCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_USR_SADDR_4BYTE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_SCTRL_SPI_MEM_USR_SRAM_DIO(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_SCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_SCTRL_SPI_MEM_USR_SRAM_DIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_SCTRL_SPI_MEM_USR_SRAM_QIO(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_SCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_SCTRL_SPI_MEM_USR_SRAM_QIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_SCTRL_SPI_MEM_USR_WR_SRAM_DUMMY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_SCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_SCTRL_SPI_MEM_USR_WR_SRAM_DUMMY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_SCTRL_SPI_MEM_USR_RD_SRAM_DUMMY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_SCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_SCTRL_SPI_MEM_USR_RD_SRAM_DUMMY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_SRAM_USR_RCMD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_SCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_SRAM_USR_RCMD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_RDUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_SCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg)&^(0xfc0)|value<<6)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_RDUMMY_CYCLELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg) & 0xfc0) >> 6
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_ADDR_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_SCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg)&^(0xfc000)|value<<14)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_ADDR_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg) & 0xfc000) >> 14
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_SRAM_USR_WCMD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_SCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_SRAM_USR_WCMD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg) & 0x100000) >> 20
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_OCT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_SCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg)&^(0x200000)|value<<21)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_OCT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg) & 0x200000) >> 21
}
func (o *SPI0_Type) SetSPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_WDUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_SCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg)&^(0xfc00000)|value<<22)
}
func (o *SPI0_Type) GetSPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_WDUMMY_CYCLELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_SCTRL.Reg) & 0xfc00000) >> 22
}

// SPI0.SPI_MEM_SRAM_CMD: SPI0 external RAM mode control register
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SCLK_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x3)|value)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SCLK_MODE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x3
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SWB_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x3fc)|value<<2)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SWB_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x3fc) >> 2
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SDIN_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x400)|value<<10)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SDIN_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x400) >> 10
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x800)|value<<11)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x800) >> 11
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SADDR_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SADDR_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SDIN_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SDIN_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SADDR_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x10000)|value<<16)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SADDR_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x10000) >> 16
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SCMD_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x20000)|value<<17)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SCMD_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x20000) >> 17
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SDIN_OCT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x40000)|value<<18)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SDIN_OCT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x40000) >> 18
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_OCT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x80000)|value<<19)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_OCT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x80000) >> 19
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SADDR_OCT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x100000)|value<<20)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SADDR_OCT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x100000) >> 20
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SCMD_OCT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x200000)|value<<21)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SCMD_OCT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x200000) >> 21
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SDUMMY_RIN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x400000)|value<<22)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SDUMMY_RIN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x400000) >> 22
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_MEM_SDUMMY_WOUT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x800000)|value<<23)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_MEM_SDUMMY_WOUT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x800000) >> 23
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_SMEM_WDUMMY_DQS_ALWAYS_OUT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_SMEM_WDUMMY_DQS_ALWAYS_OUT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x1000000) >> 24
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_SMEM_WDUMMY_ALWAYS_OUT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_SMEM_WDUMMY_ALWAYS_OUT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x2000000) >> 25
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_SMEM_DQS_IE_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_SMEM_DQS_IE_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x40000000) >> 30
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CMD_SPI_SMEM_DATA_IE_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CMD_SPI_SMEM_DATA_IE_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CMD.Reg) & 0x80000000) >> 31
}

// SPI0.SPI_MEM_SRAM_DRD_CMD: SPI0 external RAM DDR read command control register
func (o *SPI0_Type) SetSPI_MEM_SRAM_DRD_CMD_SPI_MEM_CACHE_SRAM_USR_RD_CMD_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_DRD_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_DRD_CMD.Reg)&^(0xffff)|value)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_DRD_CMD_SPI_MEM_CACHE_SRAM_USR_RD_CMD_VALUE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_SRAM_DRD_CMD.Reg) & 0xffff
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_DRD_CMD_SPI_MEM_CACHE_SRAM_USR_RD_CMD_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_DRD_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_DRD_CMD.Reg)&^(0xf0000000)|value<<28)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_DRD_CMD_SPI_MEM_CACHE_SRAM_USR_RD_CMD_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_DRD_CMD.Reg) & 0xf0000000) >> 28
}

// SPI0.SPI_MEM_SRAM_DWR_CMD: SPI0 external RAM DDR write command control register
func (o *SPI0_Type) SetSPI_MEM_SRAM_DWR_CMD_SPI_MEM_CACHE_SRAM_USR_WR_CMD_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_DWR_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_DWR_CMD.Reg)&^(0xffff)|value)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_DWR_CMD_SPI_MEM_CACHE_SRAM_USR_WR_CMD_VALUE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_SRAM_DWR_CMD.Reg) & 0xffff
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_DWR_CMD_SPI_MEM_CACHE_SRAM_USR_WR_CMD_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_DWR_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_DWR_CMD.Reg)&^(0xf0000000)|value<<28)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_DWR_CMD_SPI_MEM_CACHE_SRAM_USR_WR_CMD_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_DWR_CMD.Reg) & 0xf0000000) >> 28
}

// SPI0.SPI_MEM_SRAM_CLK: SPI0 external RAM clock control register
func (o *SPI0_Type) SetSPI_MEM_SRAM_CLK_SPI_MEM_SCLKCNT_L(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CLK.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CLK.Reg)&^(0xff)|value)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CLK_SPI_MEM_SCLKCNT_L() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_SRAM_CLK.Reg) & 0xff
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CLK_SPI_MEM_SCLKCNT_H(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CLK.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CLK.Reg)&^(0xff00)|value<<8)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CLK_SPI_MEM_SCLKCNT_H() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CLK.Reg) & 0xff00) >> 8
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CLK_SPI_MEM_SCLKCNT_N(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CLK.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CLK.Reg)&^(0xff0000)|value<<16)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CLK_SPI_MEM_SCLKCNT_N() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CLK.Reg) & 0xff0000) >> 16
}
func (o *SPI0_Type) SetSPI_MEM_SRAM_CLK_SPI_MEM_SCLK_EQU_SYSCLK(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SRAM_CLK.Reg, volatile.LoadUint32(&o.SPI_MEM_SRAM_CLK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_MEM_SRAM_CLK_SPI_MEM_SCLK_EQU_SYSCLK() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SRAM_CLK.Reg) & 0x80000000) >> 31
}

// SPI0.SPI_MEM_FSM: SPI0 FSM status register
func (o *SPI0_Type) SetSPI_MEM_FSM_SPI_MEM_LOCK_DELAY_TIME(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FSM.Reg, volatile.LoadUint32(&o.SPI_MEM_FSM.Reg)&^(0xf80)|value<<7)
}
func (o *SPI0_Type) GetSPI_MEM_FSM_SPI_MEM_LOCK_DELAY_TIME() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FSM.Reg) & 0xf80) >> 7
}

// SPI0.SPI_MEM_INT_ENA: SPI0 interrupt enable register
func (o *SPI0_Type) SetSPI_MEM_INT_ENA_SPI_MEM_SLV_ST_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ENA.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ENA_SPI_MEM_SLV_ST_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_MEM_INT_ENA_SPI_MEM_MST_ST_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ENA.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ENA_SPI_MEM_MST_ST_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPI_MEM_INT_ENA_SPI_MEM_ECC_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ENA.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ENA_SPI_MEM_ECC_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPI_MEM_INT_ENA_SPI_MEM_PMS_REJECT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ENA.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ENA_SPI_MEM_PMS_REJECT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPI_MEM_INT_ENA_SPI_MEM_AXI_RADDR_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ENA.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ENA_SPI_MEM_AXI_RADDR_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPI_MEM_INT_ENA_SPI_MEM_AXI_WR_FLASH_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ENA.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ENA_SPI_MEM_AXI_WR_FLASH_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg) & 0x100) >> 8
}
func (o *SPI0_Type) SetSPI_MEM_INT_ENA_SPI_MEM_AXI_WADDR_ERR_INT__ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ENA.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ENA_SPI_MEM_AXI_WADDR_ERR_INT__ENA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg) & 0x200) >> 9
}

// SPI0.SPI_MEM_INT_CLR: SPI0 interrupt clear register
func (o *SPI0_Type) SetSPI_MEM_INT_CLR_SPI_MEM_SLV_ST_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_CLR.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_MEM_INT_CLR_SPI_MEM_SLV_ST_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_MEM_INT_CLR_SPI_MEM_MST_ST_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_CLR.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_MEM_INT_CLR_SPI_MEM_MST_ST_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPI_MEM_INT_CLR_SPI_MEM_ECC_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_CLR.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPI_MEM_INT_CLR_SPI_MEM_ECC_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPI_MEM_INT_CLR_SPI_MEM_PMS_REJECT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_CLR.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPI_MEM_INT_CLR_SPI_MEM_PMS_REJECT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPI_MEM_INT_CLR_SPI_MEM_AXI_RADDR_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_CLR.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPI_MEM_INT_CLR_SPI_MEM_AXI_RADDR_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPI_MEM_INT_CLR_SPI_MEM_AXI_WR_FLASH_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_CLR.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SPI0_Type) GetSPI_MEM_INT_CLR_SPI_MEM_AXI_WR_FLASH_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg) & 0x100) >> 8
}
func (o *SPI0_Type) SetSPI_MEM_INT_CLR_SPI_MEM_AXI_WADDR_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_CLR.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SPI0_Type) GetSPI_MEM_INT_CLR_SPI_MEM_AXI_WADDR_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg) & 0x200) >> 9
}

// SPI0.SPI_MEM_INT_RAW: SPI0 interrupt raw register
func (o *SPI0_Type) SetSPI_MEM_INT_RAW_SPI_MEM_SLV_ST_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_RAW.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_MEM_INT_RAW_SPI_MEM_SLV_ST_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_MEM_INT_RAW_SPI_MEM_MST_ST_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_RAW.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_MEM_INT_RAW_SPI_MEM_MST_ST_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPI_MEM_INT_RAW_SPI_MEM_ECC_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_RAW.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPI_MEM_INT_RAW_SPI_MEM_ECC_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPI_MEM_INT_RAW_SPI_MEM_PMS_REJECT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_RAW.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPI_MEM_INT_RAW_SPI_MEM_PMS_REJECT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPI_MEM_INT_RAW_SPI_MEM_AXI_RADDR_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_RAW.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPI_MEM_INT_RAW_SPI_MEM_AXI_RADDR_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPI_MEM_INT_RAW_SPI_MEM_AXI_WR_FLASH_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_RAW.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *SPI0_Type) GetSPI_MEM_INT_RAW_SPI_MEM_AXI_WR_FLASH_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg) & 0x100) >> 8
}
func (o *SPI0_Type) SetSPI_MEM_INT_RAW_SPI_MEM_AXI_WADDR_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_RAW.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *SPI0_Type) GetSPI_MEM_INT_RAW_SPI_MEM_AXI_WADDR_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg) & 0x200) >> 9
}

// SPI0.SPI_MEM_INT_ST: SPI0 interrupt status register
func (o *SPI0_Type) SetSPI_MEM_INT_ST_SPI_MEM_SLV_ST_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ST.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ST_SPI_MEM_SLV_ST_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_MEM_INT_ST_SPI_MEM_MST_ST_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ST.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ST_SPI_MEM_MST_ST_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPI_MEM_INT_ST_SPI_MEM_ECC_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ST.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ST_SPI_MEM_ECC_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPI_MEM_INT_ST_SPI_MEM_PMS_REJECT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ST.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ST_SPI_MEM_PMS_REJECT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPI_MEM_INT_ST_SPI_MEM_AXI_RADDR_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ST.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ST_SPI_MEM_AXI_RADDR_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPI_MEM_INT_ST_SPI_MEM_AXI_WR_FLASH_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ST.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ST_SPI_MEM_AXI_WR_FLASH_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg) & 0x100) >> 8
}
func (o *SPI0_Type) SetSPI_MEM_INT_ST_SPI_MEM_AXI_WADDR_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ST.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *SPI0_Type) GetSPI_MEM_INT_ST_SPI_MEM_AXI_WADDR_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg) & 0x200) >> 9
}

// SPI0.SPI_MEM_DDR: SPI0 flash DDR mode control register
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_DDR_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_DDR_EN() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_VAR_DUMMY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_VAR_DUMMY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_DDR_RDAT_SWP(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_DDR_RDAT_SWP() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_DDR_WDAT_SWP(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_DDR_WDAT_SWP() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_DDR_CMD_DIS(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_DDR_CMD_DIS() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_OUTMINBYTELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0xfe0)|value<<5)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_OUTMINBYTELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0xfe0) >> 5
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_TX_DDR_MSK_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_TX_DDR_MSK_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_RX_DDR_MSK_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_RX_DDR_MSK_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_USR_DDR_DQS_THD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x1fc000)|value<<14)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_USR_DDR_DQS_THD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x1fc000) >> 14
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_DDR_DQS_LOOP(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x200000)|value<<21)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_DDR_DQS_LOOP() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x200000) >> 21
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_CLK_DIFF_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_CLK_DIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x1000000) >> 24
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_DQS_CA_IN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_DQS_CA_IN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x4000000) >> 26
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_HYPERBUS_DUMMY_2X(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_HYPERBUS_DUMMY_2X() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x8000000) >> 27
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_CLK_DIFF_INV(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_CLK_DIFF_INV() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x10000000) >> 28
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_OCTA_RAM_ADDR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_OCTA_RAM_ADDR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x20000000) >> 29
}
func (o *SPI0_Type) SetSPI_MEM_DDR_SPI_FMEM_HYPERBUS_CA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI0_Type) GetSPI_MEM_DDR_SPI_FMEM_HYPERBUS_CA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x40000000) >> 30
}

// SPI0.SPI_SMEM_DDR: SPI0 external RAM DDR mode control register
func (o *SPI0_Type) SetSPI_SMEM_DDR_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_EN() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_SPI_SMEM_VAR_DUMMY(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_SPI_SMEM_VAR_DUMMY() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_RDAT_SWP(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_RDAT_SWP() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_WDAT_SWP(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_WDAT_SWP() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_CMD_DIS(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_CMD_DIS() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_SPI_SMEM_OUTMINBYTELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0xfe0)|value<<5)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_SPI_SMEM_OUTMINBYTELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0xfe0) >> 5
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_SPI_SMEM_TX_DDR_MSK_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_SPI_SMEM_TX_DDR_MSK_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_SPI_SMEM_RX_DDR_MSK_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_SPI_SMEM_RX_DDR_MSK_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_SPI_SMEM_USR_DDR_DQS_THD(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x1fc000)|value<<14)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_SPI_SMEM_USR_DDR_DQS_THD() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x1fc000) >> 14
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_DQS_LOOP(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x200000)|value<<21)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_DQS_LOOP() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x200000) >> 21
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_SPI_SMEM_CLK_DIFF_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_SPI_SMEM_CLK_DIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x1000000) >> 24
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_SPI_SMEM_DQS_CA_IN(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_SPI_SMEM_DQS_CA_IN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x4000000) >> 26
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_SPI_SMEM_HYPERBUS_DUMMY_2X(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_SPI_SMEM_HYPERBUS_DUMMY_2X() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x8000000) >> 27
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_SPI_SMEM_CLK_DIFF_INV(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_SPI_SMEM_CLK_DIFF_INV() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x10000000) >> 28
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_SPI_SMEM_OCTA_RAM_ADDR(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_SPI_SMEM_OCTA_RAM_ADDR() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x20000000) >> 29
}
func (o *SPI0_Type) SetSPI_SMEM_DDR_SPI_SMEM_HYPERBUS_CA(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI0_Type) GetSPI_SMEM_DDR_SPI_SMEM_HYPERBUS_CA() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DDR.Reg) & 0x40000000) >> 30
}

// SPI0.SPI_FMEM_PMS0_ATTR: MSPI flash ACE section %s attribute register
func (o *SPI0_Type) SetSPI_FMEM_PMS0_ATTR_SPI_FMEM_PMS_RD_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS0_ATTR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS0_ATTR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS0_ATTR_SPI_FMEM_PMS_RD_ATTR() uint32 {
	return volatile.LoadUint32(&o.SPI_FMEM_PMS0_ATTR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_FMEM_PMS0_ATTR_SPI_FMEM_PMS_WR_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS0_ATTR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS0_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS0_ATTR_SPI_FMEM_PMS_WR_ATTR() uint32 {
	return (volatile.LoadUint32(&o.SPI_FMEM_PMS0_ATTR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_FMEM_PMS0_ATTR_SPI_FMEM_PMS_ECC(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS0_ATTR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS0_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS0_ATTR_SPI_FMEM_PMS_ECC() uint32 {
	return (volatile.LoadUint32(&o.SPI_FMEM_PMS0_ATTR.Reg) & 0x4) >> 2
}

// SPI0.SPI_FMEM_PMS1_ATTR: MSPI flash ACE section %s attribute register
func (o *SPI0_Type) SetSPI_FMEM_PMS1_ATTR_SPI_FMEM_PMS_RD_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS1_ATTR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS1_ATTR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS1_ATTR_SPI_FMEM_PMS_RD_ATTR() uint32 {
	return volatile.LoadUint32(&o.SPI_FMEM_PMS1_ATTR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_FMEM_PMS1_ATTR_SPI_FMEM_PMS_WR_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS1_ATTR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS1_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS1_ATTR_SPI_FMEM_PMS_WR_ATTR() uint32 {
	return (volatile.LoadUint32(&o.SPI_FMEM_PMS1_ATTR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_FMEM_PMS1_ATTR_SPI_FMEM_PMS_ECC(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS1_ATTR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS1_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS1_ATTR_SPI_FMEM_PMS_ECC() uint32 {
	return (volatile.LoadUint32(&o.SPI_FMEM_PMS1_ATTR.Reg) & 0x4) >> 2
}

// SPI0.SPI_FMEM_PMS2_ATTR: MSPI flash ACE section %s attribute register
func (o *SPI0_Type) SetSPI_FMEM_PMS2_ATTR_SPI_FMEM_PMS_RD_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS2_ATTR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS2_ATTR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS2_ATTR_SPI_FMEM_PMS_RD_ATTR() uint32 {
	return volatile.LoadUint32(&o.SPI_FMEM_PMS2_ATTR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_FMEM_PMS2_ATTR_SPI_FMEM_PMS_WR_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS2_ATTR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS2_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS2_ATTR_SPI_FMEM_PMS_WR_ATTR() uint32 {
	return (volatile.LoadUint32(&o.SPI_FMEM_PMS2_ATTR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_FMEM_PMS2_ATTR_SPI_FMEM_PMS_ECC(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS2_ATTR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS2_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS2_ATTR_SPI_FMEM_PMS_ECC() uint32 {
	return (volatile.LoadUint32(&o.SPI_FMEM_PMS2_ATTR.Reg) & 0x4) >> 2
}

// SPI0.SPI_FMEM_PMS3_ATTR: MSPI flash ACE section %s attribute register
func (o *SPI0_Type) SetSPI_FMEM_PMS3_ATTR_SPI_FMEM_PMS_RD_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS3_ATTR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS3_ATTR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS3_ATTR_SPI_FMEM_PMS_RD_ATTR() uint32 {
	return volatile.LoadUint32(&o.SPI_FMEM_PMS3_ATTR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_FMEM_PMS3_ATTR_SPI_FMEM_PMS_WR_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS3_ATTR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS3_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS3_ATTR_SPI_FMEM_PMS_WR_ATTR() uint32 {
	return (volatile.LoadUint32(&o.SPI_FMEM_PMS3_ATTR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_FMEM_PMS3_ATTR_SPI_FMEM_PMS_ECC(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS3_ATTR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS3_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS3_ATTR_SPI_FMEM_PMS_ECC() uint32 {
	return (volatile.LoadUint32(&o.SPI_FMEM_PMS3_ATTR.Reg) & 0x4) >> 2
}

// SPI0.SPI_FMEM_PMS0_ADDR: SPI1 flash ACE section %s start address register
func (o *SPI0_Type) SetSPI_FMEM_PMS0_ADDR_S(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS0_ADDR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS0_ADDR.Reg)&^(0x3ffffff)|value)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS0_ADDR_S() uint32 {
	return volatile.LoadUint32(&o.SPI_FMEM_PMS0_ADDR.Reg) & 0x3ffffff
}

// SPI0.SPI_FMEM_PMS1_ADDR: SPI1 flash ACE section %s start address register
func (o *SPI0_Type) SetSPI_FMEM_PMS1_ADDR_S(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS1_ADDR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS1_ADDR.Reg)&^(0x3ffffff)|value)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS1_ADDR_S() uint32 {
	return volatile.LoadUint32(&o.SPI_FMEM_PMS1_ADDR.Reg) & 0x3ffffff
}

// SPI0.SPI_FMEM_PMS2_ADDR: SPI1 flash ACE section %s start address register
func (o *SPI0_Type) SetSPI_FMEM_PMS2_ADDR_S(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS2_ADDR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS2_ADDR.Reg)&^(0x3ffffff)|value)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS2_ADDR_S() uint32 {
	return volatile.LoadUint32(&o.SPI_FMEM_PMS2_ADDR.Reg) & 0x3ffffff
}

// SPI0.SPI_FMEM_PMS3_ADDR: SPI1 flash ACE section %s start address register
func (o *SPI0_Type) SetSPI_FMEM_PMS3_ADDR_S(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS3_ADDR.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS3_ADDR.Reg)&^(0x3ffffff)|value)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS3_ADDR_S() uint32 {
	return volatile.LoadUint32(&o.SPI_FMEM_PMS3_ADDR.Reg) & 0x3ffffff
}

// SPI0.SPI_FMEM_PMS0_SIZE: SPI1 flash ACE section %s start address register
func (o *SPI0_Type) SetSPI_FMEM_PMS0_SIZE_SPI_FMEM_PMS_SIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS0_SIZE.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS0_SIZE.Reg)&^(0x3fff)|value)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS0_SIZE_SPI_FMEM_PMS_SIZE() uint32 {
	return volatile.LoadUint32(&o.SPI_FMEM_PMS0_SIZE.Reg) & 0x3fff
}

// SPI0.SPI_FMEM_PMS1_SIZE: SPI1 flash ACE section %s start address register
func (o *SPI0_Type) SetSPI_FMEM_PMS1_SIZE_SPI_FMEM_PMS_SIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS1_SIZE.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS1_SIZE.Reg)&^(0x3fff)|value)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS1_SIZE_SPI_FMEM_PMS_SIZE() uint32 {
	return volatile.LoadUint32(&o.SPI_FMEM_PMS1_SIZE.Reg) & 0x3fff
}

// SPI0.SPI_FMEM_PMS2_SIZE: SPI1 flash ACE section %s start address register
func (o *SPI0_Type) SetSPI_FMEM_PMS2_SIZE_SPI_FMEM_PMS_SIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS2_SIZE.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS2_SIZE.Reg)&^(0x3fff)|value)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS2_SIZE_SPI_FMEM_PMS_SIZE() uint32 {
	return volatile.LoadUint32(&o.SPI_FMEM_PMS2_SIZE.Reg) & 0x3fff
}

// SPI0.SPI_FMEM_PMS3_SIZE: SPI1 flash ACE section %s start address register
func (o *SPI0_Type) SetSPI_FMEM_PMS3_SIZE_SPI_FMEM_PMS_SIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_FMEM_PMS3_SIZE.Reg, volatile.LoadUint32(&o.SPI_FMEM_PMS3_SIZE.Reg)&^(0x3fff)|value)
}
func (o *SPI0_Type) GetSPI_FMEM_PMS3_SIZE_SPI_FMEM_PMS_SIZE() uint32 {
	return volatile.LoadUint32(&o.SPI_FMEM_PMS3_SIZE.Reg) & 0x3fff
}

// SPI0.SPI_SMEM_PMS0_ATTR: SPI1 flash ACE section %s start address register
func (o *SPI0_Type) SetSPI_SMEM_PMS0_ATTR_SPI_SMEM_PMS_RD_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS0_ATTR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS0_ATTR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS0_ATTR_SPI_SMEM_PMS_RD_ATTR() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_PMS0_ATTR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_SMEM_PMS0_ATTR_SPI_SMEM_PMS_WR_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS0_ATTR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS0_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS0_ATTR_SPI_SMEM_PMS_WR_ATTR() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_PMS0_ATTR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_SMEM_PMS0_ATTR_SPI_SMEM_PMS_ECC(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS0_ATTR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS0_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS0_ATTR_SPI_SMEM_PMS_ECC() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_PMS0_ATTR.Reg) & 0x4) >> 2
}

// SPI0.SPI_SMEM_PMS1_ATTR: SPI1 flash ACE section %s start address register
func (o *SPI0_Type) SetSPI_SMEM_PMS1_ATTR_SPI_SMEM_PMS_RD_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS1_ATTR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS1_ATTR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS1_ATTR_SPI_SMEM_PMS_RD_ATTR() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_PMS1_ATTR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_SMEM_PMS1_ATTR_SPI_SMEM_PMS_WR_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS1_ATTR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS1_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS1_ATTR_SPI_SMEM_PMS_WR_ATTR() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_PMS1_ATTR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_SMEM_PMS1_ATTR_SPI_SMEM_PMS_ECC(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS1_ATTR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS1_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS1_ATTR_SPI_SMEM_PMS_ECC() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_PMS1_ATTR.Reg) & 0x4) >> 2
}

// SPI0.SPI_SMEM_PMS2_ATTR: SPI1 flash ACE section %s start address register
func (o *SPI0_Type) SetSPI_SMEM_PMS2_ATTR_SPI_SMEM_PMS_RD_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS2_ATTR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS2_ATTR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS2_ATTR_SPI_SMEM_PMS_RD_ATTR() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_PMS2_ATTR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_SMEM_PMS2_ATTR_SPI_SMEM_PMS_WR_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS2_ATTR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS2_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS2_ATTR_SPI_SMEM_PMS_WR_ATTR() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_PMS2_ATTR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_SMEM_PMS2_ATTR_SPI_SMEM_PMS_ECC(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS2_ATTR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS2_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS2_ATTR_SPI_SMEM_PMS_ECC() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_PMS2_ATTR.Reg) & 0x4) >> 2
}

// SPI0.SPI_SMEM_PMS3_ATTR: SPI1 flash ACE section %s start address register
func (o *SPI0_Type) SetSPI_SMEM_PMS3_ATTR_SPI_SMEM_PMS_RD_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS3_ATTR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS3_ATTR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS3_ATTR_SPI_SMEM_PMS_RD_ATTR() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_PMS3_ATTR.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_SMEM_PMS3_ATTR_SPI_SMEM_PMS_WR_ATTR(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS3_ATTR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS3_ATTR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS3_ATTR_SPI_SMEM_PMS_WR_ATTR() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_PMS3_ATTR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_SMEM_PMS3_ATTR_SPI_SMEM_PMS_ECC(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS3_ATTR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS3_ATTR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS3_ATTR_SPI_SMEM_PMS_ECC() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_PMS3_ATTR.Reg) & 0x4) >> 2
}

// SPI0.SPI_SMEM_PMS0_ADDR: SPI1 external RAM ACE section %s start address register
func (o *SPI0_Type) SetSPI_SMEM_PMS0_ADDR_S(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS0_ADDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS0_ADDR.Reg)&^(0x3ffffff)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS0_ADDR_S() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_PMS0_ADDR.Reg) & 0x3ffffff
}

// SPI0.SPI_SMEM_PMS1_ADDR: SPI1 external RAM ACE section %s start address register
func (o *SPI0_Type) SetSPI_SMEM_PMS1_ADDR_S(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS1_ADDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS1_ADDR.Reg)&^(0x3ffffff)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS1_ADDR_S() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_PMS1_ADDR.Reg) & 0x3ffffff
}

// SPI0.SPI_SMEM_PMS2_ADDR: SPI1 external RAM ACE section %s start address register
func (o *SPI0_Type) SetSPI_SMEM_PMS2_ADDR_S(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS2_ADDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS2_ADDR.Reg)&^(0x3ffffff)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS2_ADDR_S() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_PMS2_ADDR.Reg) & 0x3ffffff
}

// SPI0.SPI_SMEM_PMS3_ADDR: SPI1 external RAM ACE section %s start address register
func (o *SPI0_Type) SetSPI_SMEM_PMS3_ADDR_S(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS3_ADDR.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS3_ADDR.Reg)&^(0x3ffffff)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS3_ADDR_S() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_PMS3_ADDR.Reg) & 0x3ffffff
}

// SPI0.SPI_SMEM_PMS0_SIZE: SPI1 external RAM ACE section %s start address register
func (o *SPI0_Type) SetSPI_SMEM_PMS0_SIZE_SPI_SMEM_PMS_SIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS0_SIZE.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS0_SIZE.Reg)&^(0x3fff)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS0_SIZE_SPI_SMEM_PMS_SIZE() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_PMS0_SIZE.Reg) & 0x3fff
}

// SPI0.SPI_SMEM_PMS1_SIZE: SPI1 external RAM ACE section %s start address register
func (o *SPI0_Type) SetSPI_SMEM_PMS1_SIZE_SPI_SMEM_PMS_SIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS1_SIZE.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS1_SIZE.Reg)&^(0x3fff)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS1_SIZE_SPI_SMEM_PMS_SIZE() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_PMS1_SIZE.Reg) & 0x3fff
}

// SPI0.SPI_SMEM_PMS2_SIZE: SPI1 external RAM ACE section %s start address register
func (o *SPI0_Type) SetSPI_SMEM_PMS2_SIZE_SPI_SMEM_PMS_SIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS2_SIZE.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS2_SIZE.Reg)&^(0x3fff)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS2_SIZE_SPI_SMEM_PMS_SIZE() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_PMS2_SIZE.Reg) & 0x3fff
}

// SPI0.SPI_SMEM_PMS3_SIZE: SPI1 external RAM ACE section %s start address register
func (o *SPI0_Type) SetSPI_SMEM_PMS3_SIZE_SPI_SMEM_PMS_SIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_PMS3_SIZE.Reg, volatile.LoadUint32(&o.SPI_SMEM_PMS3_SIZE.Reg)&^(0x3fff)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_PMS3_SIZE_SPI_SMEM_PMS_SIZE() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_PMS3_SIZE.Reg) & 0x3fff
}

// SPI0.SPI_MEM_PMS_REJECT: SPI1 access reject register
func (o *SPI0_Type) SetSPI_MEM_PMS_REJECT_SPI_MEM_REJECT_ADDR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_PMS_REJECT.Reg, volatile.LoadUint32(&o.SPI_MEM_PMS_REJECT.Reg)&^(0x3ffffff)|value)
}
func (o *SPI0_Type) GetSPI_MEM_PMS_REJECT_SPI_MEM_REJECT_ADDR() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_PMS_REJECT.Reg) & 0x3ffffff
}
func (o *SPI0_Type) SetSPI_MEM_PMS_REJECT_SPI_MEM_PM_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_PMS_REJECT.Reg, volatile.LoadUint32(&o.SPI_MEM_PMS_REJECT.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI0_Type) GetSPI_MEM_PMS_REJECT_SPI_MEM_PM_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_PMS_REJECT.Reg) & 0x4000000) >> 26
}
func (o *SPI0_Type) SetSPI_MEM_PMS_REJECT_SPI_MEM_PMS_LD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_PMS_REJECT.Reg, volatile.LoadUint32(&o.SPI_MEM_PMS_REJECT.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI0_Type) GetSPI_MEM_PMS_REJECT_SPI_MEM_PMS_LD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_PMS_REJECT.Reg) & 0x10000000) >> 28
}
func (o *SPI0_Type) SetSPI_MEM_PMS_REJECT_SPI_MEM_PMS_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_PMS_REJECT.Reg, volatile.LoadUint32(&o.SPI_MEM_PMS_REJECT.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI0_Type) GetSPI_MEM_PMS_REJECT_SPI_MEM_PMS_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_PMS_REJECT.Reg) & 0x20000000) >> 29
}
func (o *SPI0_Type) SetSPI_MEM_PMS_REJECT_SPI_MEM_PMS_MULTI_HIT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_PMS_REJECT.Reg, volatile.LoadUint32(&o.SPI_MEM_PMS_REJECT.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI0_Type) GetSPI_MEM_PMS_REJECT_SPI_MEM_PMS_MULTI_HIT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_PMS_REJECT.Reg) & 0x40000000) >> 30
}
func (o *SPI0_Type) SetSPI_MEM_PMS_REJECT_SPI_MEM_PMS_IVD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_PMS_REJECT.Reg, volatile.LoadUint32(&o.SPI_MEM_PMS_REJECT.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_MEM_PMS_REJECT_SPI_MEM_PMS_IVD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_PMS_REJECT.Reg) & 0x80000000) >> 31
}

// SPI0.SPI_MEM_ECC_CTRL: MSPI ECC control register
func (o *SPI0_Type) SetSPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ERR_INT_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_ECC_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg)&^(0x1f800)|value<<11)
}
func (o *SPI0_Type) GetSPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ERR_INT_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg) & 0x1f800) >> 11
}
func (o *SPI0_Type) SetSPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ERR_INT_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_ECC_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *SPI0_Type) GetSPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ERR_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg) & 0x20000) >> 17
}
func (o *SPI0_Type) SetSPI_MEM_ECC_CTRL_SPI_FMEM_PAGE_SIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_ECC_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg)&^(0xc0000)|value<<18)
}
func (o *SPI0_Type) GetSPI_MEM_ECC_CTRL_SPI_FMEM_PAGE_SIZE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg) & 0xc0000) >> 18
}
func (o *SPI0_Type) SetSPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ADDR_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_ECC_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SPI0_Type) GetSPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ADDR_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg) & 0x100000) >> 20
}
func (o *SPI0_Type) SetSPI_MEM_ECC_CTRL_SPI_MEM_USR_ECC_ADDR_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_ECC_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *SPI0_Type) GetSPI_MEM_ECC_CTRL_SPI_MEM_USR_ECC_ADDR_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg) & 0x200000) >> 21
}
func (o *SPI0_Type) SetSPI_MEM_ECC_CTRL_SPI_MEM_ECC_CONTINUE_RECORD_ERR_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_ECC_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_MEM_ECC_CTRL_SPI_MEM_ECC_CONTINUE_RECORD_ERR_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg) & 0x1000000) >> 24
}
func (o *SPI0_Type) SetSPI_MEM_ECC_CTRL_SPI_MEM_ECC_ERR_BITS(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_ECC_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg)&^(0xfe000000)|value<<25)
}
func (o *SPI0_Type) GetSPI_MEM_ECC_CTRL_SPI_MEM_ECC_ERR_BITS() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_ECC_CTRL.Reg) & 0xfe000000) >> 25
}

// SPI0.SPI_MEM_ECC_ERR_ADDR: MSPI ECC error address register
func (o *SPI0_Type) SetSPI_MEM_ECC_ERR_ADDR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_ECC_ERR_ADDR.Reg, volatile.LoadUint32(&o.SPI_MEM_ECC_ERR_ADDR.Reg)&^(0x3ffffff)|value)
}
func (o *SPI0_Type) GetSPI_MEM_ECC_ERR_ADDR() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_ECC_ERR_ADDR.Reg) & 0x3ffffff
}
func (o *SPI0_Type) SetSPI_MEM_ECC_ERR_ADDR_SPI_MEM_ECC_ERR_CNT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_ECC_ERR_ADDR.Reg, volatile.LoadUint32(&o.SPI_MEM_ECC_ERR_ADDR.Reg)&^(0xfc000000)|value<<26)
}
func (o *SPI0_Type) GetSPI_MEM_ECC_ERR_ADDR_SPI_MEM_ECC_ERR_CNT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_ECC_ERR_ADDR.Reg) & 0xfc000000) >> 26
}

// SPI0.SPI_MEM_AXI_ERR_ADDR: SPI0 AXI request error address.
func (o *SPI0_Type) SetSPI_MEM_AXI_ERR_ADDR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg, volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg)&^(0x3ffffff)|value)
}
func (o *SPI0_Type) GetSPI_MEM_AXI_ERR_ADDR() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg) & 0x3ffffff
}
func (o *SPI0_Type) SetSPI_MEM_AXI_ERR_ADDR_SPI_MEM_ALL_FIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg, volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI0_Type) GetSPI_MEM_AXI_ERR_ADDR_SPI_MEM_ALL_FIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg) & 0x4000000) >> 26
}
func (o *SPI0_Type) SetSPI_MEM_AXI_ERR_ADDR_SPI_RDATA_AFIFO_REMPTY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg, volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI0_Type) GetSPI_MEM_AXI_ERR_ADDR_SPI_RDATA_AFIFO_REMPTY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg) & 0x8000000) >> 27
}
func (o *SPI0_Type) SetSPI_MEM_AXI_ERR_ADDR_SPI_RADDR_AFIFO_REMPTY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg, volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI0_Type) GetSPI_MEM_AXI_ERR_ADDR_SPI_RADDR_AFIFO_REMPTY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg) & 0x10000000) >> 28
}
func (o *SPI0_Type) SetSPI_MEM_AXI_ERR_ADDR_SPI_WDATA_AFIFO_REMPTY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg, volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI0_Type) GetSPI_MEM_AXI_ERR_ADDR_SPI_WDATA_AFIFO_REMPTY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg) & 0x20000000) >> 29
}
func (o *SPI0_Type) SetSPI_MEM_AXI_ERR_ADDR_SPI_WBLEN_AFIFO_REMPTY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg, volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI0_Type) GetSPI_MEM_AXI_ERR_ADDR_SPI_WBLEN_AFIFO_REMPTY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg) & 0x40000000) >> 30
}
func (o *SPI0_Type) SetSPI_MEM_AXI_ERR_ADDR_SPI_ALL_AXI_TRANS_AFIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg, volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_MEM_AXI_ERR_ADDR_SPI_ALL_AXI_TRANS_AFIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_AXI_ERR_ADDR.Reg) & 0x80000000) >> 31
}

// SPI0.SPI_SMEM_ECC_CTRL: MSPI ECC control register
func (o *SPI0_Type) SetSPI_SMEM_ECC_CTRL_SPI_SMEM_ECC_ERR_INT_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_ECC_CTRL.Reg, volatile.LoadUint32(&o.SPI_SMEM_ECC_CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *SPI0_Type) GetSPI_SMEM_ECC_CTRL_SPI_SMEM_ECC_ERR_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_ECC_CTRL.Reg) & 0x20000) >> 17
}
func (o *SPI0_Type) SetSPI_SMEM_ECC_CTRL_SPI_SMEM_PAGE_SIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_ECC_CTRL.Reg, volatile.LoadUint32(&o.SPI_SMEM_ECC_CTRL.Reg)&^(0xc0000)|value<<18)
}
func (o *SPI0_Type) GetSPI_SMEM_ECC_CTRL_SPI_SMEM_PAGE_SIZE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_ECC_CTRL.Reg) & 0xc0000) >> 18
}
func (o *SPI0_Type) SetSPI_SMEM_ECC_CTRL_SPI_SMEM_ECC_ADDR_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_ECC_CTRL.Reg, volatile.LoadUint32(&o.SPI_SMEM_ECC_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SPI0_Type) GetSPI_SMEM_ECC_CTRL_SPI_SMEM_ECC_ADDR_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_ECC_CTRL.Reg) & 0x100000) >> 20
}

// SPI0.SPI_MEM_TIMING_CALI: SPI0 flash timing calibration register
func (o *SPI0_Type) SetSPI_MEM_TIMING_CALI_SPI_MEM_TIMING_CLK_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_TIMING_CALI.Reg, volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_MEM_TIMING_CALI_SPI_MEM_TIMING_CLK_ENA() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_MEM_TIMING_CALI(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_TIMING_CALI.Reg, volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_MEM_TIMING_CALI() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_MEM_TIMING_CALI_SPI_MEM_EXTRA_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_TIMING_CALI.Reg, volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg)&^(0x1c)|value<<2)
}
func (o *SPI0_Type) GetSPI_MEM_TIMING_CALI_SPI_MEM_EXTRA_DUMMY_CYCLELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg) & 0x1c) >> 2
}
func (o *SPI0_Type) SetSPI_MEM_TIMING_CALI_SPI_MEM_DLL_TIMING_CALI(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_TIMING_CALI.Reg, volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPI_MEM_TIMING_CALI_SPI_MEM_DLL_TIMING_CALI() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPI_MEM_TIMING_CALI_UPDATE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_TIMING_CALI.Reg, volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPI_MEM_TIMING_CALI_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg) & 0x40) >> 6
}

// SPI0.SPI_MEM_DIN_MODE: MSPI flash input timing delay mode control register
func (o *SPI0_Type) SetSPI_MEM_DIN_MODE_SPI_MEM_DIN0_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_MODE_SPI_MEM_DIN0_MODE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg) & 0x7
}
func (o *SPI0_Type) SetSPI_MEM_DIN_MODE_SPI_MEM_DIN1_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg)&^(0x38)|value<<3)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_MODE_SPI_MEM_DIN1_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg) & 0x38) >> 3
}
func (o *SPI0_Type) SetSPI_MEM_DIN_MODE_SPI_MEM_DIN2_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg)&^(0x1c0)|value<<6)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_MODE_SPI_MEM_DIN2_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg) & 0x1c0) >> 6
}
func (o *SPI0_Type) SetSPI_MEM_DIN_MODE_SPI_MEM_DIN3_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg)&^(0xe00)|value<<9)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_MODE_SPI_MEM_DIN3_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg) & 0xe00) >> 9
}
func (o *SPI0_Type) SetSPI_MEM_DIN_MODE_SPI_MEM_DIN4_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg)&^(0x7000)|value<<12)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_MODE_SPI_MEM_DIN4_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg) & 0x7000) >> 12
}
func (o *SPI0_Type) SetSPI_MEM_DIN_MODE_SPI_MEM_DIN5_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg)&^(0x38000)|value<<15)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_MODE_SPI_MEM_DIN5_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg) & 0x38000) >> 15
}
func (o *SPI0_Type) SetSPI_MEM_DIN_MODE_SPI_MEM_DIN6_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg)&^(0x1c0000)|value<<18)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_MODE_SPI_MEM_DIN6_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg) & 0x1c0000) >> 18
}
func (o *SPI0_Type) SetSPI_MEM_DIN_MODE_SPI_MEM_DIN7_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg)&^(0xe00000)|value<<21)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_MODE_SPI_MEM_DIN7_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg) & 0xe00000) >> 21
}
func (o *SPI0_Type) SetSPI_MEM_DIN_MODE_SPI_MEM_DINS_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg)&^(0x7000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_MODE_SPI_MEM_DINS_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_MODE.Reg) & 0x7000000) >> 24
}

// SPI0.SPI_MEM_DIN_NUM: MSPI flash input timing delay number control register
func (o *SPI0_Type) SetSPI_MEM_DIN_NUM_SPI_MEM_DIN0_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg)&^(0x3)|value)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_NUM_SPI_MEM_DIN0_NUM() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg) & 0x3
}
func (o *SPI0_Type) SetSPI_MEM_DIN_NUM_SPI_MEM_DIN1_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_NUM_SPI_MEM_DIN1_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPI_MEM_DIN_NUM_SPI_MEM_DIN2_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg)&^(0x30)|value<<4)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_NUM_SPI_MEM_DIN2_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg) & 0x30) >> 4
}
func (o *SPI0_Type) SetSPI_MEM_DIN_NUM_SPI_MEM_DIN3_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg)&^(0xc0)|value<<6)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_NUM_SPI_MEM_DIN3_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg) & 0xc0) >> 6
}
func (o *SPI0_Type) SetSPI_MEM_DIN_NUM_SPI_MEM_DIN4_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg)&^(0x300)|value<<8)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_NUM_SPI_MEM_DIN4_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg) & 0x300) >> 8
}
func (o *SPI0_Type) SetSPI_MEM_DIN_NUM_SPI_MEM_DIN5_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg)&^(0xc00)|value<<10)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_NUM_SPI_MEM_DIN5_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg) & 0xc00) >> 10
}
func (o *SPI0_Type) SetSPI_MEM_DIN_NUM_SPI_MEM_DIN6_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg)&^(0x3000)|value<<12)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_NUM_SPI_MEM_DIN6_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg) & 0x3000) >> 12
}
func (o *SPI0_Type) SetSPI_MEM_DIN_NUM_SPI_MEM_DIN7_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg)&^(0xc000)|value<<14)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_NUM_SPI_MEM_DIN7_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg) & 0xc000) >> 14
}
func (o *SPI0_Type) SetSPI_MEM_DIN_NUM_SPI_MEM_DINS_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg)&^(0x30000)|value<<16)
}
func (o *SPI0_Type) GetSPI_MEM_DIN_NUM_SPI_MEM_DINS_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DIN_NUM.Reg) & 0x30000) >> 16
}

// SPI0.SPI_MEM_DOUT_MODE: MSPI flash output timing adjustment control register
func (o *SPI0_Type) SetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT0_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT0_MODE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT1_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT1_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT2_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT2_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT3_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT3_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT4_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT4_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT5_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT5_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT6_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT6_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT7_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPI_MEM_DOUT_MODE_SPI_MEM_DOUT7_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPI_MEM_DOUT_MODE_SPI_MEM_DOUTS_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg)&^(0x100)|value<<8)
}
func (o *SPI0_Type) GetSPI_MEM_DOUT_MODE_SPI_MEM_DOUTS_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DOUT_MODE.Reg) & 0x100) >> 8
}

// SPI0.SPI_SMEM_TIMING_CALI: MSPI external RAM timing calibration register
func (o *SPI0_Type) SetSPI_SMEM_TIMING_CALI_SPI_SMEM_TIMING_CLK_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_TIMING_CALI.Reg, volatile.LoadUint32(&o.SPI_SMEM_TIMING_CALI.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_TIMING_CALI_SPI_SMEM_TIMING_CLK_ENA() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_TIMING_CALI.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_SMEM_TIMING_CALI(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_TIMING_CALI.Reg, volatile.LoadUint32(&o.SPI_SMEM_TIMING_CALI.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_SMEM_TIMING_CALI() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_TIMING_CALI.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_SMEM_TIMING_CALI_SPI_SMEM_EXTRA_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_TIMING_CALI.Reg, volatile.LoadUint32(&o.SPI_SMEM_TIMING_CALI.Reg)&^(0x1c)|value<<2)
}
func (o *SPI0_Type) GetSPI_SMEM_TIMING_CALI_SPI_SMEM_EXTRA_DUMMY_CYCLELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_TIMING_CALI.Reg) & 0x1c) >> 2
}
func (o *SPI0_Type) SetSPI_SMEM_TIMING_CALI_SPI_SMEM_DLL_TIMING_CALI(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_TIMING_CALI.Reg, volatile.LoadUint32(&o.SPI_SMEM_TIMING_CALI.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPI_SMEM_TIMING_CALI_SPI_SMEM_DLL_TIMING_CALI() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_TIMING_CALI.Reg) & 0x20) >> 5
}

// SPI0.SPI_SMEM_DIN_MODE: MSPI external RAM input timing delay mode control register
func (o *SPI0_Type) SetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN0_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN0_MODE() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg) & 0x7
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN1_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg)&^(0x38)|value<<3)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN1_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg) & 0x38) >> 3
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN2_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg)&^(0x1c0)|value<<6)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN2_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg) & 0x1c0) >> 6
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN3_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg)&^(0xe00)|value<<9)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN3_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg) & 0xe00) >> 9
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN4_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg)&^(0x7000)|value<<12)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN4_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg) & 0x7000) >> 12
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN5_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg)&^(0x38000)|value<<15)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN5_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg) & 0x38000) >> 15
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN6_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg)&^(0x1c0000)|value<<18)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN6_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg) & 0x1c0000) >> 18
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN7_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg)&^(0xe00000)|value<<21)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_MODE_SPI_SMEM_DIN7_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg) & 0xe00000) >> 21
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_MODE_SPI_SMEM_DINS_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg)&^(0x7000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_MODE_SPI_SMEM_DINS_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_MODE.Reg) & 0x7000000) >> 24
}

// SPI0.SPI_SMEM_DIN_NUM: MSPI external RAM input timing delay number control register
func (o *SPI0_Type) SetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN0_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg)&^(0x3)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN0_NUM() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg) & 0x3
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN1_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN1_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN2_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg)&^(0x30)|value<<4)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN2_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg) & 0x30) >> 4
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN3_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg)&^(0xc0)|value<<6)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN3_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg) & 0xc0) >> 6
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN4_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg)&^(0x300)|value<<8)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN4_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg) & 0x300) >> 8
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN5_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg)&^(0xc00)|value<<10)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN5_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg) & 0xc00) >> 10
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN6_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg)&^(0x3000)|value<<12)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN6_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg) & 0x3000) >> 12
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN7_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg)&^(0xc000)|value<<14)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_NUM_SPI_SMEM_DIN7_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg) & 0xc000) >> 14
}
func (o *SPI0_Type) SetSPI_SMEM_DIN_NUM_SPI_SMEM_DINS_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DIN_NUM.Reg, volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg)&^(0x30000)|value<<16)
}
func (o *SPI0_Type) GetSPI_SMEM_DIN_NUM_SPI_SMEM_DINS_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DIN_NUM.Reg) & 0x30000) >> 16
}

// SPI0.SPI_SMEM_DOUT_MODE: MSPI external RAM output timing adjustment control register
func (o *SPI0_Type) SetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT0_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT0_MODE() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT1_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT1_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT2_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT2_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT3_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT3_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT4_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT4_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT5_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT5_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT6_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT6_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT7_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT7_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUTS_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_DOUT_MODE.Reg, volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg)&^(0x100)|value<<8)
}
func (o *SPI0_Type) GetSPI_SMEM_DOUT_MODE_SPI_SMEM_DOUTS_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_DOUT_MODE.Reg) & 0x100) >> 8
}

// SPI0.SPI_SMEM_AC: MSPI external RAM ECC and SPI CS timing control register
func (o *SPI0_Type) SetSPI_SMEM_AC_SPI_SMEM_CS_SETUP(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_AC.Reg, volatile.LoadUint32(&o.SPI_SMEM_AC.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_SMEM_AC_SPI_SMEM_CS_SETUP() uint32 {
	return volatile.LoadUint32(&o.SPI_SMEM_AC.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_SMEM_AC_SPI_SMEM_CS_HOLD(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_AC.Reg, volatile.LoadUint32(&o.SPI_SMEM_AC.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_SMEM_AC_SPI_SMEM_CS_HOLD() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_AC.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_SMEM_AC_SPI_SMEM_CS_SETUP_TIME(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_AC.Reg, volatile.LoadUint32(&o.SPI_SMEM_AC.Reg)&^(0x7c)|value<<2)
}
func (o *SPI0_Type) GetSPI_SMEM_AC_SPI_SMEM_CS_SETUP_TIME() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_AC.Reg) & 0x7c) >> 2
}
func (o *SPI0_Type) SetSPI_SMEM_AC_SPI_SMEM_CS_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_AC.Reg, volatile.LoadUint32(&o.SPI_SMEM_AC.Reg)&^(0xf80)|value<<7)
}
func (o *SPI0_Type) GetSPI_SMEM_AC_SPI_SMEM_CS_HOLD_TIME() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_AC.Reg) & 0xf80) >> 7
}
func (o *SPI0_Type) SetSPI_SMEM_AC_SPI_SMEM_ECC_CS_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_AC.Reg, volatile.LoadUint32(&o.SPI_SMEM_AC.Reg)&^(0x7000)|value<<12)
}
func (o *SPI0_Type) GetSPI_SMEM_AC_SPI_SMEM_ECC_CS_HOLD_TIME() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_AC.Reg) & 0x7000) >> 12
}
func (o *SPI0_Type) SetSPI_SMEM_AC_SPI_SMEM_ECC_SKIP_PAGE_CORNER(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_AC.Reg, volatile.LoadUint32(&o.SPI_SMEM_AC.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPI_SMEM_AC_SPI_SMEM_ECC_SKIP_PAGE_CORNER() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_AC.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPI_SMEM_AC_SPI_SMEM_ECC_16TO18_BYTE_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_AC.Reg, volatile.LoadUint32(&o.SPI_SMEM_AC.Reg)&^(0x10000)|value<<16)
}
func (o *SPI0_Type) GetSPI_SMEM_AC_SPI_SMEM_ECC_16TO18_BYTE_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_AC.Reg) & 0x10000) >> 16
}
func (o *SPI0_Type) SetSPI_SMEM_AC_SPI_SMEM_CS_HOLD_DELAY(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_AC.Reg, volatile.LoadUint32(&o.SPI_SMEM_AC.Reg)&^(0x7e000000)|value<<25)
}
func (o *SPI0_Type) GetSPI_SMEM_AC_SPI_SMEM_CS_HOLD_DELAY() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_AC.Reg) & 0x7e000000) >> 25
}
func (o *SPI0_Type) SetSPI_SMEM_AC_SPI_SMEM_SPLIT_TRANS_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SMEM_AC.Reg, volatile.LoadUint32(&o.SPI_SMEM_AC.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_SMEM_AC_SPI_SMEM_SPLIT_TRANS_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SMEM_AC.Reg) & 0x80000000) >> 31
}

// SPI0.SPI_MEM_CLOCK_GATE: SPI0 clock gate register
func (o *SPI0_Type) SetSPI_MEM_CLOCK_GATE_SPI_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CLOCK_GATE.Reg, volatile.LoadUint32(&o.SPI_MEM_CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_MEM_CLOCK_GATE_SPI_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_CLOCK_GATE.Reg) & 0x1
}

// SPI0.SPI_MEM_XTS_PLAIN_BASE: The base address of the memory that stores plaintext in Manual Encryption
func (o *SPI0_Type) SetSPI_MEM_XTS_PLAIN_BASE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_XTS_PLAIN_BASE.Reg, value)
}
func (o *SPI0_Type) GetSPI_MEM_XTS_PLAIN_BASE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_XTS_PLAIN_BASE.Reg)
}

// SPI0.SPI_MEM_XTS_LINESIZE: Manual Encryption Line-Size register
func (o *SPI0_Type) SetSPI_MEM_XTS_LINESIZE_SPI_XTS_LINESIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_XTS_LINESIZE.Reg, volatile.LoadUint32(&o.SPI_MEM_XTS_LINESIZE.Reg)&^(0x3)|value)
}
func (o *SPI0_Type) GetSPI_MEM_XTS_LINESIZE_SPI_XTS_LINESIZE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_XTS_LINESIZE.Reg) & 0x3
}

// SPI0.SPI_MEM_XTS_DESTINATION: Manual Encryption destination register
func (o *SPI0_Type) SetSPI_MEM_XTS_DESTINATION_SPI_XTS_DESTINATION(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_XTS_DESTINATION.Reg, volatile.LoadUint32(&o.SPI_MEM_XTS_DESTINATION.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_MEM_XTS_DESTINATION_SPI_XTS_DESTINATION() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_XTS_DESTINATION.Reg) & 0x1
}

// SPI0.SPI_MEM_XTS_PHYSICAL_ADDRESS: Manual Encryption physical address register
func (o *SPI0_Type) SetSPI_MEM_XTS_PHYSICAL_ADDRESS_SPI_XTS_PHYSICAL_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_XTS_PHYSICAL_ADDRESS.Reg, volatile.LoadUint32(&o.SPI_MEM_XTS_PHYSICAL_ADDRESS.Reg)&^(0x3ffffff)|value)
}
func (o *SPI0_Type) GetSPI_MEM_XTS_PHYSICAL_ADDRESS_SPI_XTS_PHYSICAL_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_XTS_PHYSICAL_ADDRESS.Reg) & 0x3ffffff
}

// SPI0.SPI_MEM_XTS_TRIGGER: Manual Encryption physical address register
func (o *SPI0_Type) SetSPI_MEM_XTS_TRIGGER_SPI_XTS_TRIGGER(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_XTS_TRIGGER.Reg, volatile.LoadUint32(&o.SPI_MEM_XTS_TRIGGER.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_MEM_XTS_TRIGGER_SPI_XTS_TRIGGER() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_XTS_TRIGGER.Reg) & 0x1
}

// SPI0.SPI_MEM_XTS_RELEASE: Manual Encryption physical address register
func (o *SPI0_Type) SetSPI_MEM_XTS_RELEASE_SPI_XTS_RELEASE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_XTS_RELEASE.Reg, volatile.LoadUint32(&o.SPI_MEM_XTS_RELEASE.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_MEM_XTS_RELEASE_SPI_XTS_RELEASE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_XTS_RELEASE.Reg) & 0x1
}

// SPI0.SPI_MEM_XTS_DESTROY: Manual Encryption physical address register
func (o *SPI0_Type) SetSPI_MEM_XTS_DESTROY_SPI_XTS_DESTROY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_XTS_DESTROY.Reg, volatile.LoadUint32(&o.SPI_MEM_XTS_DESTROY.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_MEM_XTS_DESTROY_SPI_XTS_DESTROY() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_XTS_DESTROY.Reg) & 0x1
}

// SPI0.SPI_MEM_XTS_STATE: Manual Encryption physical address register
func (o *SPI0_Type) SetSPI_MEM_XTS_STATE_SPI_XTS_STATE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_XTS_STATE.Reg, volatile.LoadUint32(&o.SPI_MEM_XTS_STATE.Reg)&^(0x3)|value)
}
func (o *SPI0_Type) GetSPI_MEM_XTS_STATE_SPI_XTS_STATE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_XTS_STATE.Reg) & 0x3
}

// SPI0.SPI_MEM_XTS_DATE: Manual Encryption version register
func (o *SPI0_Type) SetSPI_MEM_XTS_DATE_SPI_XTS_DATE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_XTS_DATE.Reg, volatile.LoadUint32(&o.SPI_MEM_XTS_DATE.Reg)&^(0x3fffffff)|value)
}
func (o *SPI0_Type) GetSPI_MEM_XTS_DATE_SPI_XTS_DATE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_XTS_DATE.Reg) & 0x3fffffff
}

// SPI0.SPI_MEM_MMU_ITEM_CONTENT: MSPI-MMU item content register
func (o *SPI0_Type) SetSPI_MEM_MMU_ITEM_CONTENT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MMU_ITEM_CONTENT.Reg, value)
}
func (o *SPI0_Type) GetSPI_MEM_MMU_ITEM_CONTENT() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_MMU_ITEM_CONTENT.Reg)
}

// SPI0.SPI_MEM_MMU_ITEM_INDEX: MSPI-MMU item index register
func (o *SPI0_Type) SetSPI_MEM_MMU_ITEM_INDEX(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MMU_ITEM_INDEX.Reg, value)
}
func (o *SPI0_Type) GetSPI_MEM_MMU_ITEM_INDEX() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_MMU_ITEM_INDEX.Reg)
}

// SPI0.SPI_MEM_MMU_POWER_CTRL: MSPI MMU power control register
func (o *SPI0_Type) SetSPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_ON() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPI_MEM_MMU_POWER_CTRL_SPI_MMU_PAGE_SIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg)&^(0x18)|value<<3)
}
func (o *SPI0_Type) GetSPI_MEM_MMU_POWER_CTRL_SPI_MMU_PAGE_SIZE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg) & 0x18) >> 3
}
func (o *SPI0_Type) SetSPI_MEM_MMU_POWER_CTRL_SPI_MEM_AUX_CTRL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg)&^(0x3fff0000)|value<<16)
}
func (o *SPI0_Type) GetSPI_MEM_MMU_POWER_CTRL_SPI_MEM_AUX_CTRL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg) & 0x3fff0000) >> 16
}
func (o *SPI0_Type) SetSPI_MEM_MMU_POWER_CTRL_SPI_MEM_RDN_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI0_Type) GetSPI_MEM_MMU_POWER_CTRL_SPI_MEM_RDN_ENA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg) & 0x40000000) >> 30
}
func (o *SPI0_Type) SetSPI_MEM_MMU_POWER_CTRL_SPI_MEM_RDN_RESULT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_MEM_MMU_POWER_CTRL_SPI_MEM_RDN_RESULT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_MMU_POWER_CTRL.Reg) & 0x80000000) >> 31
}

// SPI0.SPI_MEM_DPA_CTRL: SPI memory cryption DPA register
func (o *SPI0_Type) SetSPI_MEM_DPA_CTRL_SPI_CRYPT_SECURITY_LEVEL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DPA_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_DPA_CTRL.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPI_MEM_DPA_CTRL_SPI_CRYPT_SECURITY_LEVEL() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_DPA_CTRL.Reg) & 0x7
}
func (o *SPI0_Type) SetSPI_MEM_DPA_CTRL_SPI_CRYPT_CALC_D_DPA_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DPA_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_DPA_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_MEM_DPA_CTRL_SPI_CRYPT_CALC_D_DPA_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DPA_CTRL.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_MEM_DPA_CTRL_SPI_CRYPT_DPA_SELECT_REGISTER(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DPA_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_DPA_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_MEM_DPA_CTRL_SPI_CRYPT_DPA_SELECT_REGISTER() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DPA_CTRL.Reg) & 0x10) >> 4
}

// SPI0.SPI_MEM_REGISTERRND_ECO_HIGH: MSPI ECO high register
func (o *SPI0_Type) SetSPI_MEM_REGISTERRND_ECO_HIGH(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_REGISTERRND_ECO_HIGH.Reg, value)
}
func (o *SPI0_Type) GetSPI_MEM_REGISTERRND_ECO_HIGH() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_REGISTERRND_ECO_HIGH.Reg)
}

// SPI0.SPI_MEM_REGISTERRND_ECO_LOW: MSPI ECO low register
func (o *SPI0_Type) SetSPI_MEM_REGISTERRND_ECO_LOW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_REGISTERRND_ECO_LOW.Reg, value)
}
func (o *SPI0_Type) GetSPI_MEM_REGISTERRND_ECO_LOW() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_REGISTERRND_ECO_LOW.Reg)
}

// SPI0.SPI_MEM_DATE: SPI0 version control register
func (o *SPI0_Type) SetSPI_MEM_DATE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DATE.Reg, volatile.LoadUint32(&o.SPI_MEM_DATE.Reg)&^(0xfffffff)|value)
}
func (o *SPI0_Type) GetSPI_MEM_DATE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_DATE.Reg) & 0xfffffff
}

// SPI (Serial Peripheral Interface) Controller 1
type SPI1_Type struct {
	SPI_MEM_CMD              volatile.Register32 // 0x0
	SPI_MEM_ADDR             volatile.Register32 // 0x4
	SPI_MEM_CTRL             volatile.Register32 // 0x8
	SPI_MEM_CTRL1            volatile.Register32 // 0xC
	SPI_MEM_CTRL2            volatile.Register32 // 0x10
	SPI_MEM_CLOCK            volatile.Register32 // 0x14
	SPI_MEM_USER             volatile.Register32 // 0x18
	SPI_MEM_USER1            volatile.Register32 // 0x1C
	SPI_MEM_USER2            volatile.Register32 // 0x20
	SPI_MEM_MOSI_DLEN        volatile.Register32 // 0x24
	SPI_MEM_MISO_DLEN        volatile.Register32 // 0x28
	SPI_MEM_RD_STATUS        volatile.Register32 // 0x2C
	_                        [4]byte
	SPI_MEM_MISC             volatile.Register32 // 0x34
	SPI_MEM_TX_CRC           volatile.Register32 // 0x38
	SPI_MEM_CACHE_FCTRL      volatile.Register32 // 0x3C
	_                        [24]byte
	SPI_MEM_W0               volatile.Register32 // 0x58
	SPI_MEM_W1               volatile.Register32 // 0x5C
	SPI_MEM_W2               volatile.Register32 // 0x60
	SPI_MEM_W3               volatile.Register32 // 0x64
	SPI_MEM_W4               volatile.Register32 // 0x68
	SPI_MEM_W5               volatile.Register32 // 0x6C
	SPI_MEM_W6               volatile.Register32 // 0x70
	SPI_MEM_W7               volatile.Register32 // 0x74
	SPI_MEM_W8               volatile.Register32 // 0x78
	SPI_MEM_W9               volatile.Register32 // 0x7C
	SPI_MEM_W10              volatile.Register32 // 0x80
	SPI_MEM_W11              volatile.Register32 // 0x84
	SPI_MEM_W12              volatile.Register32 // 0x88
	SPI_MEM_W13              volatile.Register32 // 0x8C
	SPI_MEM_W14              volatile.Register32 // 0x90
	SPI_MEM_W15              volatile.Register32 // 0x94
	SPI_MEM_FLASH_WAITI_CTRL volatile.Register32 // 0x98
	SPI_MEM_FLASH_SUS_CTRL   volatile.Register32 // 0x9C
	SPI_MEM_FLASH_SUS_CMD    volatile.Register32 // 0xA0
	SPI_MEM_SUS_STATUS       volatile.Register32 // 0xA4
	_                        [24]byte
	SPI_MEM_INT_ENA          volatile.Register32 // 0xC0
	SPI_MEM_INT_CLR          volatile.Register32 // 0xC4
	SPI_MEM_INT_RAW          volatile.Register32 // 0xC8
	SPI_MEM_INT_ST           volatile.Register32 // 0xCC
	_                        [4]byte
	SPI_MEM_DDR              volatile.Register32 // 0xD4
	_                        [168]byte
	SPI_MEM_TIMING_CALI      volatile.Register32 // 0x180
	_                        [124]byte
	SPI_MEM_CLOCK_GATE       volatile.Register32 // 0x200
	_                        [504]byte
	SPI_MEM_DATE             volatile.Register32 // 0x3FC
}

// SPI1.SPI_MEM_CMD: SPI1 memory command register
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_MST_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0xf)|value)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_MST_ST() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0xf
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_SLV_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0xf0)|value<<4)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_SLV_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0xf0) >> 4
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_PE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x20000)|value<<17)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_PE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x20000) >> 17
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_USR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x40000)|value<<18)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_USR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x40000) >> 18
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_HPM(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x80000)|value<<19)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_HPM() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x80000) >> 19
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_RES(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x100000)|value<<20)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_RES() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x100000) >> 20
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_DP(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x200000)|value<<21)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_DP() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x200000) >> 21
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_CE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x400000)|value<<22)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_CE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x400000) >> 22
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_BE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x800000)|value<<23)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_BE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x800000) >> 23
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_SE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_SE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x1000000) >> 24
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_PP(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_PP() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x2000000) >> 25
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_WRSR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_WRSR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x4000000) >> 26
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_RDSR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_RDSR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x8000000) >> 27
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_RDID(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_RDID() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x10000000) >> 28
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_WRDI(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_WRDI() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x20000000) >> 29
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_WREN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_WREN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x40000000) >> 30
}
func (o *SPI1_Type) SetSPI_MEM_CMD_SPI_MEM_FLASH_READ(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_CMD.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI1_Type) GetSPI_MEM_CMD_SPI_MEM_FLASH_READ() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CMD.Reg) & 0x80000000) >> 31
}

// SPI1.SPI_MEM_ADDR: SPI1 address register
func (o *SPI1_Type) SetSPI_MEM_ADDR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_ADDR.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_ADDR() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_ADDR.Reg)
}

// SPI1.SPI_MEM_CTRL: SPI1 control register.
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_FDUMMY_RIN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_FDUMMY_RIN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_FDUMMY_WOUT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_FDUMMY_WOUT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_FDOUT_OCT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_FDOUT_OCT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_FDIN_OCT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_FDIN_OCT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x20) >> 5
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_FADDR_OCT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_FADDR_OCT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x40) >> 6
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_FCMD_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_FCMD_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x100) >> 8
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_FCMD_OCT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_FCMD_OCT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x200) >> 9
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_FCS_CRC_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_FCS_CRC_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x400) >> 10
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_TX_CRC_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_TX_CRC_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x800) >> 11
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_FASTRD_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_FASTRD_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x2000) >> 13
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_FREAD_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_FREAD_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x4000) >> 14
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_RESANDRES(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_RESANDRES() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x8000) >> 15
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_Q_POL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_Q_POL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x40000) >> 18
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_D_POL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_D_POL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x80000) >> 19
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_FREAD_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_FREAD_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x100000) >> 20
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_WP(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_WP() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x200000) >> 21
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_WRSR_2B(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_WRSR_2B() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x400000) >> 22
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_FREAD_DIO(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_FREAD_DIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x800000) >> 23
}
func (o *SPI1_Type) SetSPI_MEM_CTRL_SPI_MEM_FREAD_QIO(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL_SPI_MEM_FREAD_QIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL.Reg) & 0x1000000) >> 24
}

// SPI1.SPI_MEM_CTRL1: SPI1 control1 register.
func (o *SPI1_Type) SetSPI_MEM_CTRL1_SPI_MEM_CLK_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0x3)|value)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL1_SPI_MEM_CLK_MODE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0x3
}
func (o *SPI1_Type) SetSPI_MEM_CTRL1_SPI_MEM_CS_HOLD_DLY_RES(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL1.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg)&^(0xffc)|value<<2)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL1_SPI_MEM_CS_HOLD_DLY_RES() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL1.Reg) & 0xffc) >> 2
}

// SPI1.SPI_MEM_CTRL2: SPI1 control2 register.
func (o *SPI1_Type) SetSPI_MEM_CTRL2_SPI_MEM_SYNC_RESET(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CTRL2.Reg, volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI1_Type) GetSPI_MEM_CTRL2_SPI_MEM_SYNC_RESET() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CTRL2.Reg) & 0x80000000) >> 31
}

// SPI1.SPI_MEM_CLOCK: SPI1 clock division control register.
func (o *SPI1_Type) SetSPI_MEM_CLOCK_SPI_MEM_CLKCNT_L(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CLOCK.Reg, volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg)&^(0xff)|value)
}
func (o *SPI1_Type) GetSPI_MEM_CLOCK_SPI_MEM_CLKCNT_L() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg) & 0xff
}
func (o *SPI1_Type) SetSPI_MEM_CLOCK_SPI_MEM_CLKCNT_H(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CLOCK.Reg, volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg)&^(0xff00)|value<<8)
}
func (o *SPI1_Type) GetSPI_MEM_CLOCK_SPI_MEM_CLKCNT_H() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg) & 0xff00) >> 8
}
func (o *SPI1_Type) SetSPI_MEM_CLOCK_SPI_MEM_CLKCNT_N(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CLOCK.Reg, volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg)&^(0xff0000)|value<<16)
}
func (o *SPI1_Type) GetSPI_MEM_CLOCK_SPI_MEM_CLKCNT_N() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg) & 0xff0000) >> 16
}
func (o *SPI1_Type) SetSPI_MEM_CLOCK_SPI_MEM_CLK_EQU_SYSCLK(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CLOCK.Reg, volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI1_Type) GetSPI_MEM_CLOCK_SPI_MEM_CLK_EQU_SYSCLK() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CLOCK.Reg) & 0x80000000) >> 31
}

// SPI1.SPI_MEM_USER: SPI1 user register.
func (o *SPI1_Type) SetSPI_MEM_USER_SPI_MEM_CK_OUT_EDGE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x200)|value<<9)
}
func (o *SPI1_Type) GetSPI_MEM_USER_SPI_MEM_CK_OUT_EDGE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x200) >> 9
}
func (o *SPI1_Type) SetSPI_MEM_USER_SPI_MEM_FWRITE_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x1000)|value<<12)
}
func (o *SPI1_Type) GetSPI_MEM_USER_SPI_MEM_FWRITE_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x1000) >> 12
}
func (o *SPI1_Type) SetSPI_MEM_USER_SPI_MEM_FWRITE_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x2000)|value<<13)
}
func (o *SPI1_Type) GetSPI_MEM_USER_SPI_MEM_FWRITE_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x2000) >> 13
}
func (o *SPI1_Type) SetSPI_MEM_USER_SPI_MEM_FWRITE_DIO(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x4000)|value<<14)
}
func (o *SPI1_Type) GetSPI_MEM_USER_SPI_MEM_FWRITE_DIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x4000) >> 14
}
func (o *SPI1_Type) SetSPI_MEM_USER_SPI_MEM_FWRITE_QIO(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x8000)|value<<15)
}
func (o *SPI1_Type) GetSPI_MEM_USER_SPI_MEM_FWRITE_QIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x8000) >> 15
}
func (o *SPI1_Type) SetSPI_MEM_USER_SPI_MEM_USR_MISO_HIGHPART(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI1_Type) GetSPI_MEM_USER_SPI_MEM_USR_MISO_HIGHPART() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x1000000) >> 24
}
func (o *SPI1_Type) SetSPI_MEM_USER_SPI_MEM_USR_MOSI_HIGHPART(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI1_Type) GetSPI_MEM_USER_SPI_MEM_USR_MOSI_HIGHPART() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x2000000) >> 25
}
func (o *SPI1_Type) SetSPI_MEM_USER_SPI_MEM_USR_DUMMY_IDLE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI1_Type) GetSPI_MEM_USER_SPI_MEM_USR_DUMMY_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x4000000) >> 26
}
func (o *SPI1_Type) SetSPI_MEM_USER_SPI_MEM_USR_MOSI(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI1_Type) GetSPI_MEM_USER_SPI_MEM_USR_MOSI() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x8000000) >> 27
}
func (o *SPI1_Type) SetSPI_MEM_USER_SPI_MEM_USR_MISO(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI1_Type) GetSPI_MEM_USER_SPI_MEM_USR_MISO() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x10000000) >> 28
}
func (o *SPI1_Type) SetSPI_MEM_USER_SPI_MEM_USR_DUMMY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI1_Type) GetSPI_MEM_USER_SPI_MEM_USR_DUMMY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x20000000) >> 29
}
func (o *SPI1_Type) SetSPI_MEM_USER_SPI_MEM_USR_ADDR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI1_Type) GetSPI_MEM_USER_SPI_MEM_USR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x40000000) >> 30
}
func (o *SPI1_Type) SetSPI_MEM_USER_SPI_MEM_USR_COMMAND(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER.Reg, volatile.LoadUint32(&o.SPI_MEM_USER.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI1_Type) GetSPI_MEM_USER_SPI_MEM_USR_COMMAND() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER.Reg) & 0x80000000) >> 31
}

// SPI1.SPI_MEM_USER1: SPI1 user1 register.
func (o *SPI1_Type) SetSPI_MEM_USER1_SPI_MEM_USR_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER1.Reg, volatile.LoadUint32(&o.SPI_MEM_USER1.Reg)&^(0x3f)|value)
}
func (o *SPI1_Type) GetSPI_MEM_USER1_SPI_MEM_USR_DUMMY_CYCLELEN() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_USER1.Reg) & 0x3f
}
func (o *SPI1_Type) SetSPI_MEM_USER1_SPI_MEM_USR_ADDR_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER1.Reg, volatile.LoadUint32(&o.SPI_MEM_USER1.Reg)&^(0xfc000000)|value<<26)
}
func (o *SPI1_Type) GetSPI_MEM_USER1_SPI_MEM_USR_ADDR_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER1.Reg) & 0xfc000000) >> 26
}

// SPI1.SPI_MEM_USER2: SPI1 user2 register.
func (o *SPI1_Type) SetSPI_MEM_USER2_SPI_MEM_USR_COMMAND_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER2.Reg, volatile.LoadUint32(&o.SPI_MEM_USER2.Reg)&^(0xffff)|value)
}
func (o *SPI1_Type) GetSPI_MEM_USER2_SPI_MEM_USR_COMMAND_VALUE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_USER2.Reg) & 0xffff
}
func (o *SPI1_Type) SetSPI_MEM_USER2_SPI_MEM_USR_COMMAND_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_USER2.Reg, volatile.LoadUint32(&o.SPI_MEM_USER2.Reg)&^(0xf0000000)|value<<28)
}
func (o *SPI1_Type) GetSPI_MEM_USER2_SPI_MEM_USR_COMMAND_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_USER2.Reg) & 0xf0000000) >> 28
}

// SPI1.SPI_MEM_MOSI_DLEN: SPI1 send data bit length control register.
func (o *SPI1_Type) SetSPI_MEM_MOSI_DLEN_SPI_MEM_USR_MOSI_DBITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MOSI_DLEN.Reg, volatile.LoadUint32(&o.SPI_MEM_MOSI_DLEN.Reg)&^(0x3ff)|value)
}
func (o *SPI1_Type) GetSPI_MEM_MOSI_DLEN_SPI_MEM_USR_MOSI_DBITLEN() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_MOSI_DLEN.Reg) & 0x3ff
}

// SPI1.SPI_MEM_MISO_DLEN: SPI1 receive data bit length control register.
func (o *SPI1_Type) SetSPI_MEM_MISO_DLEN_SPI_MEM_USR_MISO_DBITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MISO_DLEN.Reg, volatile.LoadUint32(&o.SPI_MEM_MISO_DLEN.Reg)&^(0x3ff)|value)
}
func (o *SPI1_Type) GetSPI_MEM_MISO_DLEN_SPI_MEM_USR_MISO_DBITLEN() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_MISO_DLEN.Reg) & 0x3ff
}

// SPI1.SPI_MEM_RD_STATUS: SPI1 status register.
func (o *SPI1_Type) SetSPI_MEM_RD_STATUS_SPI_MEM_STATUS(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_RD_STATUS.Reg, volatile.LoadUint32(&o.SPI_MEM_RD_STATUS.Reg)&^(0xffff)|value)
}
func (o *SPI1_Type) GetSPI_MEM_RD_STATUS_SPI_MEM_STATUS() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_RD_STATUS.Reg) & 0xffff
}
func (o *SPI1_Type) SetSPI_MEM_RD_STATUS_SPI_MEM_WB_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_RD_STATUS.Reg, volatile.LoadUint32(&o.SPI_MEM_RD_STATUS.Reg)&^(0xff0000)|value<<16)
}
func (o *SPI1_Type) GetSPI_MEM_RD_STATUS_SPI_MEM_WB_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_RD_STATUS.Reg) & 0xff0000) >> 16
}

// SPI1.SPI_MEM_MISC: SPI1 misc register
func (o *SPI1_Type) SetSPI_MEM_MISC_SPI_MEM_CS0_DIS(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MISC.Reg, volatile.LoadUint32(&o.SPI_MEM_MISC.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_MEM_MISC_SPI_MEM_CS0_DIS() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_MISC.Reg) & 0x1
}
func (o *SPI1_Type) SetSPI_MEM_MISC_SPI_MEM_CS1_DIS(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MISC.Reg, volatile.LoadUint32(&o.SPI_MEM_MISC.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_MEM_MISC_SPI_MEM_CS1_DIS() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_MISC.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_MEM_MISC_SPI_MEM_CK_IDLE_EDGE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MISC.Reg, volatile.LoadUint32(&o.SPI_MEM_MISC.Reg)&^(0x200)|value<<9)
}
func (o *SPI1_Type) GetSPI_MEM_MISC_SPI_MEM_CK_IDLE_EDGE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_MISC.Reg) & 0x200) >> 9
}
func (o *SPI1_Type) SetSPI_MEM_MISC_SPI_MEM_CS_KEEP_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_MISC.Reg, volatile.LoadUint32(&o.SPI_MEM_MISC.Reg)&^(0x400)|value<<10)
}
func (o *SPI1_Type) GetSPI_MEM_MISC_SPI_MEM_CS_KEEP_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_MISC.Reg) & 0x400) >> 10
}

// SPI1.SPI_MEM_TX_CRC: SPI1 TX CRC data register.
func (o *SPI1_Type) SetSPI_MEM_TX_CRC(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_TX_CRC.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_TX_CRC() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_TX_CRC.Reg)
}

// SPI1.SPI_MEM_CACHE_FCTRL: SPI1 bit mode control register.
func (o *SPI1_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_USR_ADDR_4BYTE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_USR_ADDR_4BYTE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x20)|value<<5)
}
func (o *SPI1_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x20) >> 5
}
func (o *SPI1_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x40)|value<<6)
}
func (o *SPI1_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x40) >> 6
}
func (o *SPI1_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x80)|value<<7)
}
func (o *SPI1_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x80) >> 7
}
func (o *SPI1_Type) SetSPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CACHE_FCTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg)&^(0x100)|value<<8)
}
func (o *SPI1_Type) GetSPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_CACHE_FCTRL.Reg) & 0x100) >> 8
}

// SPI1.SPI_MEM_W0: SPI1 memory data buffer0
func (o *SPI1_Type) SetSPI_MEM_W0(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W0.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W0() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W0.Reg)
}

// SPI1.SPI_MEM_W1: SPI1 memory data buffer1
func (o *SPI1_Type) SetSPI_MEM_W1(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W1.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W1() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W1.Reg)
}

// SPI1.SPI_MEM_W2: SPI1 memory data buffer2
func (o *SPI1_Type) SetSPI_MEM_W2(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W2.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W2() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W2.Reg)
}

// SPI1.SPI_MEM_W3: SPI1 memory data buffer3
func (o *SPI1_Type) SetSPI_MEM_W3(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W3.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W3() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W3.Reg)
}

// SPI1.SPI_MEM_W4: SPI1 memory data buffer4
func (o *SPI1_Type) SetSPI_MEM_W4(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W4.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W4() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W4.Reg)
}

// SPI1.SPI_MEM_W5: SPI1 memory data buffer5
func (o *SPI1_Type) SetSPI_MEM_W5(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W5.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W5() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W5.Reg)
}

// SPI1.SPI_MEM_W6: SPI1 memory data buffer6
func (o *SPI1_Type) SetSPI_MEM_W6(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W6.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W6() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W6.Reg)
}

// SPI1.SPI_MEM_W7: SPI1 memory data buffer7
func (o *SPI1_Type) SetSPI_MEM_W7(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W7.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W7() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W7.Reg)
}

// SPI1.SPI_MEM_W8: SPI1 memory data buffer8
func (o *SPI1_Type) SetSPI_MEM_W8(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W8.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W8() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W8.Reg)
}

// SPI1.SPI_MEM_W9: SPI1 memory data buffer9
func (o *SPI1_Type) SetSPI_MEM_W9(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W9.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W9() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W9.Reg)
}

// SPI1.SPI_MEM_W10: SPI1 memory data buffer10
func (o *SPI1_Type) SetSPI_MEM_W10(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W10.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W10() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W10.Reg)
}

// SPI1.SPI_MEM_W11: SPI1 memory data buffer11
func (o *SPI1_Type) SetSPI_MEM_W11(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W11.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W11() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W11.Reg)
}

// SPI1.SPI_MEM_W12: SPI1 memory data buffer12
func (o *SPI1_Type) SetSPI_MEM_W12(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W12.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W12() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W12.Reg)
}

// SPI1.SPI_MEM_W13: SPI1 memory data buffer13
func (o *SPI1_Type) SetSPI_MEM_W13(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W13.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W13() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W13.Reg)
}

// SPI1.SPI_MEM_W14: SPI1 memory data buffer14
func (o *SPI1_Type) SetSPI_MEM_W14(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W14.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W14() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W14.Reg)
}

// SPI1.SPI_MEM_W15: SPI1 memory data buffer15
func (o *SPI1_Type) SetSPI_MEM_W15(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_W15.Reg, value)
}
func (o *SPI1_Type) GetSPI_MEM_W15() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_W15.Reg)
}

// SPI1.SPI_MEM_FLASH_WAITI_CTRL: SPI1 wait idle control register
func (o *SPI1_Type) SetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_EN() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg) & 0x1
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_DUMMY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_DUMMY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_ADDR_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_ADDR_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_ADDR_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg)&^(0x18)|value<<3)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_ADDR_CYCLELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg) & 0x18) >> 3
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_CMD_2B(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_CMD_2B() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg) & 0x200) >> 9
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg)&^(0xfc00)|value<<10)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_DUMMY_CYCLELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg) & 0xfc00) >> 10
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_CMD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_CMD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_WAITI_CTRL.Reg) & 0xffff0000) >> 16
}

// SPI1.SPI_MEM_FLASH_SUS_CTRL: SPI1 flash suspend control register
func (o *SPI1_Type) SetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PER(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PER() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg) & 0x1
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PER_WAIT_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PER_WAIT_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES_WAIT_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES_WAIT_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PES_PER_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PES_PER_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg) & 0x20) >> 5
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PESR_END_MSK(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg)&^(0x3fffc0)|value<<6)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PESR_END_MSK() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg) & 0x3fffc0) >> 6
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_SUS_CTRL_SPI_FMEM_RD_SUS_2B(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_SUS_CTRL_SPI_FMEM_RD_SUS_2B() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg) & 0x400000) >> 22
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PER_END_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PER_END_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg) & 0x800000) >> 23
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PES_END_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PES_END_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg) & 0x1000000) >> 24
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_SUS_TIMEOUT_CNT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg)&^(0xfe000000)|value<<25)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_SUS_CTRL_SPI_MEM_SUS_TIMEOUT_CNT() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CTRL.Reg) & 0xfe000000) >> 25
}

// SPI1.SPI_MEM_FLASH_SUS_CMD: SPI1 flash suspend command register
func (o *SPI1_Type) SetSPI_MEM_FLASH_SUS_CMD_SPI_MEM_FLASH_PES_COMMAND(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_SUS_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CMD.Reg)&^(0xffff)|value)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_SUS_CMD_SPI_MEM_FLASH_PES_COMMAND() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CMD.Reg) & 0xffff
}
func (o *SPI1_Type) SetSPI_MEM_FLASH_SUS_CMD_SPI_MEM_WAIT_PESR_COMMAND(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_FLASH_SUS_CMD.Reg, volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CMD.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI1_Type) GetSPI_MEM_FLASH_SUS_CMD_SPI_MEM_WAIT_PESR_COMMAND() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_FLASH_SUS_CMD.Reg) & 0xffff0000) >> 16
}

// SPI1.SPI_MEM_SUS_STATUS: SPI1 flash suspend status register
func (o *SPI1_Type) SetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_SUS(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SUS_STATUS.Reg, volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_SUS() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg) & 0x1
}
func (o *SPI1_Type) SetSPI_MEM_SUS_STATUS_SPI_MEM_WAIT_PESR_CMD_2B(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SUS_STATUS.Reg, volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_MEM_SUS_STATUS_SPI_MEM_WAIT_PESR_CMD_2B() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_HPM_DLY_128(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SUS_STATUS.Reg, volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_HPM_DLY_128() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_RES_DLY_128(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SUS_STATUS.Reg, volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_RES_DLY_128() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_DP_DLY_128(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SUS_STATUS.Reg, volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_DP_DLY_128() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PER_DLY_128(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SUS_STATUS.Reg, volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *SPI1_Type) GetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PER_DLY_128() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg) & 0x20) >> 5
}
func (o *SPI1_Type) SetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PES_DLY_128(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SUS_STATUS.Reg, volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *SPI1_Type) GetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PES_DLY_128() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg) & 0x40) >> 6
}
func (o *SPI1_Type) SetSPI_MEM_SUS_STATUS_SPI_MEM_SPI0_LOCK_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SUS_STATUS.Reg, volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg)&^(0x80)|value<<7)
}
func (o *SPI1_Type) GetSPI_MEM_SUS_STATUS_SPI_MEM_SPI0_LOCK_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg) & 0x80) >> 7
}
func (o *SPI1_Type) SetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PESR_CMD_2B(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SUS_STATUS.Reg, volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *SPI1_Type) GetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PESR_CMD_2B() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg) & 0x8000) >> 15
}
func (o *SPI1_Type) SetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PER_COMMAND(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_SUS_STATUS.Reg, volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI1_Type) GetSPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PER_COMMAND() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_SUS_STATUS.Reg) & 0xffff0000) >> 16
}

// SPI1.SPI_MEM_INT_ENA: SPI1 interrupt enable register
func (o *SPI1_Type) SetSPI_MEM_INT_ENA_SPI_MEM_PER_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ENA.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_MEM_INT_ENA_SPI_MEM_PER_END_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg) & 0x1
}
func (o *SPI1_Type) SetSPI_MEM_INT_ENA_SPI_MEM_PES_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ENA.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_MEM_INT_ENA_SPI_MEM_PES_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_MEM_INT_ENA_SPI_MEM_WPE_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ENA.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPI_MEM_INT_ENA_SPI_MEM_WPE_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPI_MEM_INT_ENA_SPI_MEM_SLV_ST_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ENA.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPI_MEM_INT_ENA_SPI_MEM_SLV_ST_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPI_MEM_INT_ENA_SPI_MEM_MST_ST_END_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ENA.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPI_MEM_INT_ENA_SPI_MEM_MST_ST_END_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPI_MEM_INT_ENA_SPI_MEM_BROWN_OUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ENA.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *SPI1_Type) GetSPI_MEM_INT_ENA_SPI_MEM_BROWN_OUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ENA.Reg) & 0x400) >> 10
}

// SPI1.SPI_MEM_INT_CLR: SPI1 interrupt clear register
func (o *SPI1_Type) SetSPI_MEM_INT_CLR_SPI_MEM_PER_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_CLR.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_MEM_INT_CLR_SPI_MEM_PER_END_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg) & 0x1
}
func (o *SPI1_Type) SetSPI_MEM_INT_CLR_SPI_MEM_PES_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_CLR.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_MEM_INT_CLR_SPI_MEM_PES_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_MEM_INT_CLR_SPI_MEM_WPE_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_CLR.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPI_MEM_INT_CLR_SPI_MEM_WPE_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPI_MEM_INT_CLR_SPI_MEM_SLV_ST_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_CLR.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPI_MEM_INT_CLR_SPI_MEM_SLV_ST_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPI_MEM_INT_CLR_SPI_MEM_MST_ST_END_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_CLR.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPI_MEM_INT_CLR_SPI_MEM_MST_ST_END_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPI_MEM_INT_CLR_SPI_MEM_BROWN_OUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_CLR.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SPI1_Type) GetSPI_MEM_INT_CLR_SPI_MEM_BROWN_OUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_CLR.Reg) & 0x400) >> 10
}

// SPI1.SPI_MEM_INT_RAW: SPI1 interrupt raw register
func (o *SPI1_Type) SetSPI_MEM_INT_RAW_SPI_MEM_PER_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_RAW.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_MEM_INT_RAW_SPI_MEM_PER_END_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg) & 0x1
}
func (o *SPI1_Type) SetSPI_MEM_INT_RAW_SPI_MEM_PES_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_RAW.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_MEM_INT_RAW_SPI_MEM_PES_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_MEM_INT_RAW_SPI_MEM_WPE_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_RAW.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPI_MEM_INT_RAW_SPI_MEM_WPE_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPI_MEM_INT_RAW_SPI_MEM_SLV_ST_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_RAW.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPI_MEM_INT_RAW_SPI_MEM_SLV_ST_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPI_MEM_INT_RAW_SPI_MEM_MST_ST_END_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_RAW.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPI_MEM_INT_RAW_SPI_MEM_MST_ST_END_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPI_MEM_INT_RAW_SPI_MEM_BROWN_OUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_RAW.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *SPI1_Type) GetSPI_MEM_INT_RAW_SPI_MEM_BROWN_OUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_RAW.Reg) & 0x400) >> 10
}

// SPI1.SPI_MEM_INT_ST: SPI1 interrupt status register
func (o *SPI1_Type) SetSPI_MEM_INT_ST_SPI_MEM_PER_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ST.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_MEM_INT_ST_SPI_MEM_PER_END_INT_ST() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg) & 0x1
}
func (o *SPI1_Type) SetSPI_MEM_INT_ST_SPI_MEM_PES_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ST.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_MEM_INT_ST_SPI_MEM_PES_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_MEM_INT_ST_SPI_MEM_WPE_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ST.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPI_MEM_INT_ST_SPI_MEM_WPE_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPI_MEM_INT_ST_SPI_MEM_SLV_ST_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ST.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPI_MEM_INT_ST_SPI_MEM_SLV_ST_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPI_MEM_INT_ST_SPI_MEM_MST_ST_END_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ST.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPI_MEM_INT_ST_SPI_MEM_MST_ST_END_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPI_MEM_INT_ST_SPI_MEM_BROWN_OUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_INT_ST.Reg, volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *SPI1_Type) GetSPI_MEM_INT_ST_SPI_MEM_BROWN_OUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_INT_ST.Reg) & 0x400) >> 10
}

// SPI1.SPI_MEM_DDR: SPI1 DDR control register
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_DDR_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_DDR_EN() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x1
}
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_VAR_DUMMY(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_VAR_DUMMY() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_DDR_RDAT_SWP(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_DDR_RDAT_SWP() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_DDR_WDAT_SWP(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_DDR_WDAT_SWP() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_DDR_CMD_DIS(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_DDR_CMD_DIS() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_OUTMINBYTELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0xfe0)|value<<5)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_OUTMINBYTELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0xfe0) >> 5
}
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_USR_DDR_DQS_THD(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x1fc000)|value<<14)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_USR_DDR_DQS_THD() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x1fc000) >> 14
}
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_DDR_DQS_LOOP(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x200000)|value<<21)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_DDR_DQS_LOOP() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x200000) >> 21
}
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_CLK_DIFF_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_CLK_DIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x1000000) >> 24
}
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_DQS_CA_IN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_DQS_CA_IN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x4000000) >> 26
}
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_HYPERBUS_DUMMY_2X(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_HYPERBUS_DUMMY_2X() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x8000000) >> 27
}
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_CLK_DIFF_INV(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_CLK_DIFF_INV() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x10000000) >> 28
}
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_OCTA_RAM_ADDR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_OCTA_RAM_ADDR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x20000000) >> 29
}
func (o *SPI1_Type) SetSPI_MEM_DDR_SPI_FMEM_HYPERBUS_CA(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DDR.Reg, volatile.LoadUint32(&o.SPI_MEM_DDR.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI1_Type) GetSPI_MEM_DDR_SPI_FMEM_HYPERBUS_CA() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_DDR.Reg) & 0x40000000) >> 30
}

// SPI1.SPI_MEM_TIMING_CALI: SPI1 timing control register
func (o *SPI1_Type) SetSPI_MEM_TIMING_CALI(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_TIMING_CALI.Reg, volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_MEM_TIMING_CALI() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_MEM_TIMING_CALI_SPI_MEM_EXTRA_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_TIMING_CALI.Reg, volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg)&^(0x1c)|value<<2)
}
func (o *SPI1_Type) GetSPI_MEM_TIMING_CALI_SPI_MEM_EXTRA_DUMMY_CYCLELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_TIMING_CALI.Reg) & 0x1c) >> 2
}

// SPI1.SPI_MEM_CLOCK_GATE: SPI1 clk_gate register
func (o *SPI1_Type) SetSPI_MEM_CLOCK_GATE_SPI_MEM_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_CLOCK_GATE.Reg, volatile.LoadUint32(&o.SPI_MEM_CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_MEM_CLOCK_GATE_SPI_MEM_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_CLOCK_GATE.Reg) & 0x1
}

// SPI1.SPI_MEM_DATE: Version control register
func (o *SPI1_Type) SetSPI_MEM_DATE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_DATE.Reg, volatile.LoadUint32(&o.SPI_MEM_DATE.Reg)&^(0xfffffff)|value)
}
func (o *SPI1_Type) GetSPI_MEM_DATE() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_DATE.Reg) & 0xfffffff
}

// SPI (Serial Peripheral Interface) Controller 2
type SPI2_Type struct {
	CMD         volatile.Register32 // 0x0
	ADDR        volatile.Register32 // 0x4
	CTRL        volatile.Register32 // 0x8
	CLOCK       volatile.Register32 // 0xC
	USER        volatile.Register32 // 0x10
	USER1       volatile.Register32 // 0x14
	USER2       volatile.Register32 // 0x18
	MS_DLEN     volatile.Register32 // 0x1C
	MISC        volatile.Register32 // 0x20
	DIN_MODE    volatile.Register32 // 0x24
	DIN_NUM     volatile.Register32 // 0x28
	DOUT_MODE   volatile.Register32 // 0x2C
	DMA_CONF    volatile.Register32 // 0x30
	DMA_INT_ENA volatile.Register32 // 0x34
	DMA_INT_CLR volatile.Register32 // 0x38
	DMA_INT_RAW volatile.Register32 // 0x3C
	DMA_INT_ST  volatile.Register32 // 0x40
	DMA_INT_SET volatile.Register32 // 0x44
	_           [80]byte
	W0          volatile.Register32 // 0x98
	W1          volatile.Register32 // 0x9C
	W2          volatile.Register32 // 0xA0
	W3          volatile.Register32 // 0xA4
	W4          volatile.Register32 // 0xA8
	W5          volatile.Register32 // 0xAC
	W6          volatile.Register32 // 0xB0
	W7          volatile.Register32 // 0xB4
	W8          volatile.Register32 // 0xB8
	W9          volatile.Register32 // 0xBC
	W10         volatile.Register32 // 0xC0
	W11         volatile.Register32 // 0xC4
	W12         volatile.Register32 // 0xC8
	W13         volatile.Register32 // 0xCC
	W14         volatile.Register32 // 0xD0
	W15         volatile.Register32 // 0xD4
	_           [8]byte
	SLAVE       volatile.Register32 // 0xE0
	SLAVE1      volatile.Register32 // 0xE4
	CLK_GATE    volatile.Register32 // 0xE8
	_           [4]byte
	DATE        volatile.Register32 // 0xF0
}

// SPI2.CMD: Command control register
func (o *SPI2_Type) SetCMD_CONF_BITLEN(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x3ffff)|value)
}
func (o *SPI2_Type) GetCMD_CONF_BITLEN() uint32 {
	return volatile.LoadUint32(&o.CMD.Reg) & 0x3ffff
}
func (o *SPI2_Type) SetCMD_UPDATE(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x800000)|value<<23)
}
func (o *SPI2_Type) GetCMD_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x800000) >> 23
}
func (o *SPI2_Type) SetCMD_USR(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI2_Type) GetCMD_USR() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x1000000) >> 24
}

// SPI2.ADDR: Address value register
func (o *SPI2_Type) SetADDR(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, value)
}
func (o *SPI2_Type) GetADDR() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg)
}

// SPI2.CTRL: SPI control register
func (o *SPI2_Type) SetCTRL_DUMMY_OUT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *SPI2_Type) GetCTRL_DUMMY_OUT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *SPI2_Type) SetCTRL_FADDR_DUAL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SPI2_Type) GetCTRL_FADDR_DUAL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *SPI2_Type) SetCTRL_FADDR_QUAD(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *SPI2_Type) GetCTRL_FADDR_QUAD() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *SPI2_Type) SetCTRL_FADDR_OCT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *SPI2_Type) GetCTRL_FADDR_OCT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *SPI2_Type) SetCTRL_FCMD_DUAL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *SPI2_Type) GetCTRL_FCMD_DUAL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *SPI2_Type) SetCTRL_FCMD_QUAD(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200)|value<<9)
}
func (o *SPI2_Type) GetCTRL_FCMD_QUAD() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200) >> 9
}
func (o *SPI2_Type) SetCTRL_FCMD_OCT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400)|value<<10)
}
func (o *SPI2_Type) GetCTRL_FCMD_OCT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400) >> 10
}
func (o *SPI2_Type) SetCTRL_FREAD_DUAL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SPI2_Type) GetCTRL_FREAD_DUAL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000) >> 14
}
func (o *SPI2_Type) SetCTRL_FREAD_QUAD(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *SPI2_Type) GetCTRL_FREAD_QUAD() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000) >> 15
}
func (o *SPI2_Type) SetCTRL_FREAD_OCT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *SPI2_Type) GetCTRL_FREAD_OCT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}
func (o *SPI2_Type) SetCTRL_Q_POL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *SPI2_Type) GetCTRL_Q_POL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000) >> 18
}
func (o *SPI2_Type) SetCTRL_D_POL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *SPI2_Type) GetCTRL_D_POL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000) >> 19
}
func (o *SPI2_Type) SetCTRL_HOLD_POL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SPI2_Type) GetCTRL_HOLD_POL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100000) >> 20
}
func (o *SPI2_Type) SetCTRL_WP_POL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *SPI2_Type) GetCTRL_WP_POL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200000) >> 21
}
func (o *SPI2_Type) SetCTRL_RD_BIT_ORDER(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1800000)|value<<23)
}
func (o *SPI2_Type) GetCTRL_RD_BIT_ORDER() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1800000) >> 23
}
func (o *SPI2_Type) SetCTRL_WR_BIT_ORDER(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x6000000)|value<<25)
}
func (o *SPI2_Type) GetCTRL_WR_BIT_ORDER() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x6000000) >> 25
}

// SPI2.CLOCK: SPI clock control register
func (o *SPI2_Type) SetCLOCK_CLKCNT_L(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x3f)|value)
}
func (o *SPI2_Type) GetCLOCK_CLKCNT_L() uint32 {
	return volatile.LoadUint32(&o.CLOCK.Reg) & 0x3f
}
func (o *SPI2_Type) SetCLOCK_CLKCNT_H(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0xfc0)|value<<6)
}
func (o *SPI2_Type) GetCLOCK_CLKCNT_H() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0xfc0) >> 6
}
func (o *SPI2_Type) SetCLOCK_CLKCNT_N(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x3f000)|value<<12)
}
func (o *SPI2_Type) GetCLOCK_CLKCNT_N() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0x3f000) >> 12
}
func (o *SPI2_Type) SetCLOCK_CLKDIV_PRE(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x3c0000)|value<<18)
}
func (o *SPI2_Type) GetCLOCK_CLKDIV_PRE() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0x3c0000) >> 18
}
func (o *SPI2_Type) SetCLOCK_CLK_EQU_SYSCLK(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI2_Type) GetCLOCK_CLK_EQU_SYSCLK() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0x80000000) >> 31
}

// SPI2.USER: SPI USER control register
func (o *SPI2_Type) SetUSER_DOUTDIN(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x1)|value)
}
func (o *SPI2_Type) GetUSER_DOUTDIN() uint32 {
	return volatile.LoadUint32(&o.USER.Reg) & 0x1
}
func (o *SPI2_Type) SetUSER_QPI_MODE(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x8)|value<<3)
}
func (o *SPI2_Type) GetUSER_QPI_MODE() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x8) >> 3
}
func (o *SPI2_Type) SetUSER_OPI_MODE(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x10)|value<<4)
}
func (o *SPI2_Type) GetUSER_OPI_MODE() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x10) >> 4
}
func (o *SPI2_Type) SetUSER_TSCK_I_EDGE(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x20)|value<<5)
}
func (o *SPI2_Type) GetUSER_TSCK_I_EDGE() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x20) >> 5
}
func (o *SPI2_Type) SetUSER_CS_HOLD(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x40)|value<<6)
}
func (o *SPI2_Type) GetUSER_CS_HOLD() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x40) >> 6
}
func (o *SPI2_Type) SetUSER_CS_SETUP(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x80)|value<<7)
}
func (o *SPI2_Type) GetUSER_CS_SETUP() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x80) >> 7
}
func (o *SPI2_Type) SetUSER_RSCK_I_EDGE(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x100)|value<<8)
}
func (o *SPI2_Type) GetUSER_RSCK_I_EDGE() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x100) >> 8
}
func (o *SPI2_Type) SetUSER_CK_OUT_EDGE(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x200)|value<<9)
}
func (o *SPI2_Type) GetUSER_CK_OUT_EDGE() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x200) >> 9
}
func (o *SPI2_Type) SetUSER_FWRITE_DUAL(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x1000)|value<<12)
}
func (o *SPI2_Type) GetUSER_FWRITE_DUAL() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x1000) >> 12
}
func (o *SPI2_Type) SetUSER_FWRITE_QUAD(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x2000)|value<<13)
}
func (o *SPI2_Type) GetUSER_FWRITE_QUAD() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x2000) >> 13
}
func (o *SPI2_Type) SetUSER_FWRITE_OCT(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x4000)|value<<14)
}
func (o *SPI2_Type) GetUSER_FWRITE_OCT() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x4000) >> 14
}
func (o *SPI2_Type) SetUSER_USR_CONF_NXT(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x8000)|value<<15)
}
func (o *SPI2_Type) GetUSER_USR_CONF_NXT() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x8000) >> 15
}
func (o *SPI2_Type) SetUSER_SIO(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x20000)|value<<17)
}
func (o *SPI2_Type) GetUSER_SIO() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x20000) >> 17
}
func (o *SPI2_Type) SetUSER_USR_MISO_HIGHPART(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI2_Type) GetUSER_USR_MISO_HIGHPART() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x1000000) >> 24
}
func (o *SPI2_Type) SetUSER_USR_MOSI_HIGHPART(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI2_Type) GetUSER_USR_MOSI_HIGHPART() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x2000000) >> 25
}
func (o *SPI2_Type) SetUSER_USR_DUMMY_IDLE(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI2_Type) GetUSER_USR_DUMMY_IDLE() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x4000000) >> 26
}
func (o *SPI2_Type) SetUSER_USR_MOSI(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI2_Type) GetUSER_USR_MOSI() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x8000000) >> 27
}
func (o *SPI2_Type) SetUSER_USR_MISO(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI2_Type) GetUSER_USR_MISO() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x10000000) >> 28
}
func (o *SPI2_Type) SetUSER_USR_DUMMY(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI2_Type) GetUSER_USR_DUMMY() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x20000000) >> 29
}
func (o *SPI2_Type) SetUSER_USR_ADDR(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI2_Type) GetUSER_USR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x40000000) >> 30
}
func (o *SPI2_Type) SetUSER_USR_COMMAND(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI2_Type) GetUSER_USR_COMMAND() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x80000000) >> 31
}

// SPI2.USER1: SPI USER control register 1
func (o *SPI2_Type) SetUSER1_USR_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.USER1.Reg, volatile.LoadUint32(&o.USER1.Reg)&^(0xff)|value)
}
func (o *SPI2_Type) GetUSER1_USR_DUMMY_CYCLELEN() uint32 {
	return volatile.LoadUint32(&o.USER1.Reg) & 0xff
}
func (o *SPI2_Type) SetUSER1_MST_WFULL_ERR_END_EN(value uint32) {
	volatile.StoreUint32(&o.USER1.Reg, volatile.LoadUint32(&o.USER1.Reg)&^(0x10000)|value<<16)
}
func (o *SPI2_Type) GetUSER1_MST_WFULL_ERR_END_EN() uint32 {
	return (volatile.LoadUint32(&o.USER1.Reg) & 0x10000) >> 16
}
func (o *SPI2_Type) SetUSER1_CS_SETUP_TIME(value uint32) {
	volatile.StoreUint32(&o.USER1.Reg, volatile.LoadUint32(&o.USER1.Reg)&^(0x3e0000)|value<<17)
}
func (o *SPI2_Type) GetUSER1_CS_SETUP_TIME() uint32 {
	return (volatile.LoadUint32(&o.USER1.Reg) & 0x3e0000) >> 17
}
func (o *SPI2_Type) SetUSER1_CS_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.USER1.Reg, volatile.LoadUint32(&o.USER1.Reg)&^(0x7c00000)|value<<22)
}
func (o *SPI2_Type) GetUSER1_CS_HOLD_TIME() uint32 {
	return (volatile.LoadUint32(&o.USER1.Reg) & 0x7c00000) >> 22
}
func (o *SPI2_Type) SetUSER1_USR_ADDR_BITLEN(value uint32) {
	volatile.StoreUint32(&o.USER1.Reg, volatile.LoadUint32(&o.USER1.Reg)&^(0xf8000000)|value<<27)
}
func (o *SPI2_Type) GetUSER1_USR_ADDR_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.USER1.Reg) & 0xf8000000) >> 27
}

// SPI2.USER2: SPI USER control register 2
func (o *SPI2_Type) SetUSER2_USR_COMMAND_VALUE(value uint32) {
	volatile.StoreUint32(&o.USER2.Reg, volatile.LoadUint32(&o.USER2.Reg)&^(0xffff)|value)
}
func (o *SPI2_Type) GetUSER2_USR_COMMAND_VALUE() uint32 {
	return volatile.LoadUint32(&o.USER2.Reg) & 0xffff
}
func (o *SPI2_Type) SetUSER2_MST_REMPTY_ERR_END_EN(value uint32) {
	volatile.StoreUint32(&o.USER2.Reg, volatile.LoadUint32(&o.USER2.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI2_Type) GetUSER2_MST_REMPTY_ERR_END_EN() uint32 {
	return (volatile.LoadUint32(&o.USER2.Reg) & 0x8000000) >> 27
}
func (o *SPI2_Type) SetUSER2_USR_COMMAND_BITLEN(value uint32) {
	volatile.StoreUint32(&o.USER2.Reg, volatile.LoadUint32(&o.USER2.Reg)&^(0xf0000000)|value<<28)
}
func (o *SPI2_Type) GetUSER2_USR_COMMAND_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.USER2.Reg) & 0xf0000000) >> 28
}

// SPI2.MS_DLEN: SPI data bit length control register
func (o *SPI2_Type) SetMS_DLEN_MS_DATA_BITLEN(value uint32) {
	volatile.StoreUint32(&o.MS_DLEN.Reg, volatile.LoadUint32(&o.MS_DLEN.Reg)&^(0x3ffff)|value)
}
func (o *SPI2_Type) GetMS_DLEN_MS_DATA_BITLEN() uint32 {
	return volatile.LoadUint32(&o.MS_DLEN.Reg) & 0x3ffff
}

// SPI2.MISC: SPI misc register
func (o *SPI2_Type) SetMISC_CS0_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x1)|value)
}
func (o *SPI2_Type) GetMISC_CS0_DIS() uint32 {
	return volatile.LoadUint32(&o.MISC.Reg) & 0x1
}
func (o *SPI2_Type) SetMISC_CS1_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x2)|value<<1)
}
func (o *SPI2_Type) GetMISC_CS1_DIS() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x2) >> 1
}
func (o *SPI2_Type) SetMISC_CS2_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x4)|value<<2)
}
func (o *SPI2_Type) GetMISC_CS2_DIS() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x4) >> 2
}
func (o *SPI2_Type) SetMISC_CS3_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x8)|value<<3)
}
func (o *SPI2_Type) GetMISC_CS3_DIS() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x8) >> 3
}
func (o *SPI2_Type) SetMISC_CS4_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x10)|value<<4)
}
func (o *SPI2_Type) GetMISC_CS4_DIS() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x10) >> 4
}
func (o *SPI2_Type) SetMISC_CS5_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x20)|value<<5)
}
func (o *SPI2_Type) GetMISC_CS5_DIS() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x20) >> 5
}
func (o *SPI2_Type) SetMISC_CK_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x40)|value<<6)
}
func (o *SPI2_Type) GetMISC_CK_DIS() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x40) >> 6
}
func (o *SPI2_Type) SetMISC_MASTER_CS_POL(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x1f80)|value<<7)
}
func (o *SPI2_Type) GetMISC_MASTER_CS_POL() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x1f80) >> 7
}
func (o *SPI2_Type) SetMISC_CLK_DATA_DTR_EN(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x10000)|value<<16)
}
func (o *SPI2_Type) GetMISC_CLK_DATA_DTR_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x10000) >> 16
}
func (o *SPI2_Type) SetMISC_DATA_DTR_EN(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x20000)|value<<17)
}
func (o *SPI2_Type) GetMISC_DATA_DTR_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x20000) >> 17
}
func (o *SPI2_Type) SetMISC_ADDR_DTR_EN(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x40000)|value<<18)
}
func (o *SPI2_Type) GetMISC_ADDR_DTR_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x40000) >> 18
}
func (o *SPI2_Type) SetMISC_CMD_DTR_EN(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x80000)|value<<19)
}
func (o *SPI2_Type) GetMISC_CMD_DTR_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x80000) >> 19
}
func (o *SPI2_Type) SetMISC_SLAVE_CS_POL(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x800000)|value<<23)
}
func (o *SPI2_Type) GetMISC_SLAVE_CS_POL() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x800000) >> 23
}
func (o *SPI2_Type) SetMISC_DQS_IDLE_EDGE(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI2_Type) GetMISC_DQS_IDLE_EDGE() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x1000000) >> 24
}
func (o *SPI2_Type) SetMISC_CK_IDLE_EDGE(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI2_Type) GetMISC_CK_IDLE_EDGE() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x20000000) >> 29
}
func (o *SPI2_Type) SetMISC_CS_KEEP_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI2_Type) GetMISC_CS_KEEP_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x40000000) >> 30
}
func (o *SPI2_Type) SetMISC_QUAD_DIN_PIN_SWAP(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI2_Type) GetMISC_QUAD_DIN_PIN_SWAP() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x80000000) >> 31
}

// SPI2.DIN_MODE: SPI input delay mode configuration
func (o *SPI2_Type) SetDIN_MODE_DIN0_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0x3)|value)
}
func (o *SPI2_Type) GetDIN_MODE_DIN0_MODE() uint32 {
	return volatile.LoadUint32(&o.DIN_MODE.Reg) & 0x3
}
func (o *SPI2_Type) SetDIN_MODE_DIN1_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0xc)|value<<2)
}
func (o *SPI2_Type) GetDIN_MODE_DIN1_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0xc) >> 2
}
func (o *SPI2_Type) SetDIN_MODE_DIN2_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0x30)|value<<4)
}
func (o *SPI2_Type) GetDIN_MODE_DIN2_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0x30) >> 4
}
func (o *SPI2_Type) SetDIN_MODE_DIN3_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0xc0)|value<<6)
}
func (o *SPI2_Type) GetDIN_MODE_DIN3_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0xc0) >> 6
}
func (o *SPI2_Type) SetDIN_MODE_DIN4_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0x300)|value<<8)
}
func (o *SPI2_Type) GetDIN_MODE_DIN4_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0x300) >> 8
}
func (o *SPI2_Type) SetDIN_MODE_DIN5_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0xc00)|value<<10)
}
func (o *SPI2_Type) GetDIN_MODE_DIN5_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0xc00) >> 10
}
func (o *SPI2_Type) SetDIN_MODE_DIN6_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0x3000)|value<<12)
}
func (o *SPI2_Type) GetDIN_MODE_DIN6_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0x3000) >> 12
}
func (o *SPI2_Type) SetDIN_MODE_DIN7_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0xc000)|value<<14)
}
func (o *SPI2_Type) GetDIN_MODE_DIN7_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0xc000) >> 14
}
func (o *SPI2_Type) SetDIN_MODE_TIMING_HCLK_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0x10000)|value<<16)
}
func (o *SPI2_Type) GetDIN_MODE_TIMING_HCLK_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0x10000) >> 16
}

// SPI2.DIN_NUM: SPI input delay number configuration
func (o *SPI2_Type) SetDIN_NUM_DIN0_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0x3)|value)
}
func (o *SPI2_Type) GetDIN_NUM_DIN0_NUM() uint32 {
	return volatile.LoadUint32(&o.DIN_NUM.Reg) & 0x3
}
func (o *SPI2_Type) SetDIN_NUM_DIN1_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0xc)|value<<2)
}
func (o *SPI2_Type) GetDIN_NUM_DIN1_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0xc) >> 2
}
func (o *SPI2_Type) SetDIN_NUM_DIN2_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0x30)|value<<4)
}
func (o *SPI2_Type) GetDIN_NUM_DIN2_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0x30) >> 4
}
func (o *SPI2_Type) SetDIN_NUM_DIN3_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0xc0)|value<<6)
}
func (o *SPI2_Type) GetDIN_NUM_DIN3_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0xc0) >> 6
}
func (o *SPI2_Type) SetDIN_NUM_DIN4_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0x300)|value<<8)
}
func (o *SPI2_Type) GetDIN_NUM_DIN4_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0x300) >> 8
}
func (o *SPI2_Type) SetDIN_NUM_DIN5_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0xc00)|value<<10)
}
func (o *SPI2_Type) GetDIN_NUM_DIN5_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0xc00) >> 10
}
func (o *SPI2_Type) SetDIN_NUM_DIN6_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0x3000)|value<<12)
}
func (o *SPI2_Type) GetDIN_NUM_DIN6_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0x3000) >> 12
}
func (o *SPI2_Type) SetDIN_NUM_DIN7_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0xc000)|value<<14)
}
func (o *SPI2_Type) GetDIN_NUM_DIN7_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0xc000) >> 14
}

// SPI2.DOUT_MODE: SPI output delay mode configuration
func (o *SPI2_Type) SetDOUT_MODE_DOUT0_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x1)|value)
}
func (o *SPI2_Type) GetDOUT_MODE_DOUT0_MODE() uint32 {
	return volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x1
}
func (o *SPI2_Type) SetDOUT_MODE_DOUT1_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x2)|value<<1)
}
func (o *SPI2_Type) GetDOUT_MODE_DOUT1_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x2) >> 1
}
func (o *SPI2_Type) SetDOUT_MODE_DOUT2_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x4)|value<<2)
}
func (o *SPI2_Type) GetDOUT_MODE_DOUT2_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x4) >> 2
}
func (o *SPI2_Type) SetDOUT_MODE_DOUT3_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x8)|value<<3)
}
func (o *SPI2_Type) GetDOUT_MODE_DOUT3_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x8) >> 3
}
func (o *SPI2_Type) SetDOUT_MODE_DOUT4_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x10)|value<<4)
}
func (o *SPI2_Type) GetDOUT_MODE_DOUT4_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x10) >> 4
}
func (o *SPI2_Type) SetDOUT_MODE_DOUT5_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x20)|value<<5)
}
func (o *SPI2_Type) GetDOUT_MODE_DOUT5_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x20) >> 5
}
func (o *SPI2_Type) SetDOUT_MODE_DOUT6_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x40)|value<<6)
}
func (o *SPI2_Type) GetDOUT_MODE_DOUT6_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x40) >> 6
}
func (o *SPI2_Type) SetDOUT_MODE_DOUT7_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x80)|value<<7)
}
func (o *SPI2_Type) GetDOUT_MODE_DOUT7_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x80) >> 7
}
func (o *SPI2_Type) SetDOUT_MODE_D_DQS_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x100)|value<<8)
}
func (o *SPI2_Type) GetDOUT_MODE_D_DQS_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x100) >> 8
}

// SPI2.DMA_CONF: SPI DMA control register
func (o *SPI2_Type) SetDMA_CONF_DMA_OUTFIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x1)|value)
}
func (o *SPI2_Type) GetDMA_CONF_DMA_OUTFIFO_EMPTY() uint32 {
	return volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x1
}
func (o *SPI2_Type) SetDMA_CONF_DMA_INFIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x2)|value<<1)
}
func (o *SPI2_Type) GetDMA_CONF_DMA_INFIFO_FULL() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x2) >> 1
}
func (o *SPI2_Type) SetDMA_CONF_DMA_SLV_SEG_TRANS_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *SPI2_Type) GetDMA_CONF_DMA_SLV_SEG_TRANS_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x40000) >> 18
}
func (o *SPI2_Type) SetDMA_CONF_SLV_RX_SEG_TRANS_CLR_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *SPI2_Type) GetDMA_CONF_SLV_RX_SEG_TRANS_CLR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x80000) >> 19
}
func (o *SPI2_Type) SetDMA_CONF_SLV_TX_SEG_TRANS_CLR_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *SPI2_Type) GetDMA_CONF_SLV_TX_SEG_TRANS_CLR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x100000) >> 20
}
func (o *SPI2_Type) SetDMA_CONF_RX_EOF_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *SPI2_Type) GetDMA_CONF_RX_EOF_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x200000) >> 21
}
func (o *SPI2_Type) SetDMA_CONF_DMA_RX_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI2_Type) GetDMA_CONF_DMA_RX_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x8000000) >> 27
}
func (o *SPI2_Type) SetDMA_CONF_DMA_TX_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI2_Type) GetDMA_CONF_DMA_TX_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x10000000) >> 28
}
func (o *SPI2_Type) SetDMA_CONF_RX_AFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI2_Type) GetDMA_CONF_RX_AFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x20000000) >> 29
}
func (o *SPI2_Type) SetDMA_CONF_BUF_AFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI2_Type) GetDMA_CONF_BUF_AFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x40000000) >> 30
}
func (o *SPI2_Type) SetDMA_CONF_DMA_AFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI2_Type) GetDMA_CONF_DMA_AFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x80000000) >> 31
}

// SPI2.DMA_INT_ENA: SPI interrupt enable register
func (o *SPI2_Type) SetDMA_INT_ENA_DMA_INFIFO_FULL_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x1)|value)
}
func (o *SPI2_Type) GetDMA_INT_ENA_DMA_INFIFO_FULL_ERR_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x1
}
func (o *SPI2_Type) SetDMA_INT_ENA_DMA_OUTFIFO_EMPTY_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *SPI2_Type) GetDMA_INT_ENA_DMA_OUTFIFO_EMPTY_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x2) >> 1
}
func (o *SPI2_Type) SetDMA_INT_ENA_SLV_EX_QPI_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *SPI2_Type) GetDMA_INT_ENA_SLV_EX_QPI_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x4) >> 2
}
func (o *SPI2_Type) SetDMA_INT_ENA_SLV_EN_QPI_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *SPI2_Type) GetDMA_INT_ENA_SLV_EN_QPI_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x8) >> 3
}
func (o *SPI2_Type) SetDMA_INT_ENA_SLV_CMD7_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *SPI2_Type) GetDMA_INT_ENA_SLV_CMD7_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x10) >> 4
}
func (o *SPI2_Type) SetDMA_INT_ENA_SLV_CMD8_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *SPI2_Type) GetDMA_INT_ENA_SLV_CMD8_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x20) >> 5
}
func (o *SPI2_Type) SetDMA_INT_ENA_SLV_CMD9_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *SPI2_Type) GetDMA_INT_ENA_SLV_CMD9_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x40) >> 6
}
func (o *SPI2_Type) SetDMA_INT_ENA_SLV_CMDA_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *SPI2_Type) GetDMA_INT_ENA_SLV_CMDA_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x80) >> 7
}
func (o *SPI2_Type) SetDMA_INT_ENA_SLV_RD_DMA_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *SPI2_Type) GetDMA_INT_ENA_SLV_RD_DMA_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x100) >> 8
}
func (o *SPI2_Type) SetDMA_INT_ENA_SLV_WR_DMA_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *SPI2_Type) GetDMA_INT_ENA_SLV_WR_DMA_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x200) >> 9
}
func (o *SPI2_Type) SetDMA_INT_ENA_SLV_RD_BUF_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *SPI2_Type) GetDMA_INT_ENA_SLV_RD_BUF_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x400) >> 10
}
func (o *SPI2_Type) SetDMA_INT_ENA_SLV_WR_BUF_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *SPI2_Type) GetDMA_INT_ENA_SLV_WR_BUF_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x800) >> 11
}
func (o *SPI2_Type) SetDMA_INT_ENA_TRANS_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *SPI2_Type) GetDMA_INT_ENA_TRANS_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x1000) >> 12
}
func (o *SPI2_Type) SetDMA_INT_ENA_DMA_SEG_TRANS_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *SPI2_Type) GetDMA_INT_ENA_DMA_SEG_TRANS_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x2000) >> 13
}
func (o *SPI2_Type) SetDMA_INT_ENA_SEG_MAGIC_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *SPI2_Type) GetDMA_INT_ENA_SEG_MAGIC_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x4000) >> 14
}
func (o *SPI2_Type) SetDMA_INT_ENA_SLV_BUF_ADDR_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *SPI2_Type) GetDMA_INT_ENA_SLV_BUF_ADDR_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x8000) >> 15
}
func (o *SPI2_Type) SetDMA_INT_ENA_SLV_CMD_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *SPI2_Type) GetDMA_INT_ENA_SLV_CMD_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x10000) >> 16
}
func (o *SPI2_Type) SetDMA_INT_ENA_MST_RX_AFIFO_WFULL_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *SPI2_Type) GetDMA_INT_ENA_MST_RX_AFIFO_WFULL_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x20000) >> 17
}
func (o *SPI2_Type) SetDMA_INT_ENA_MST_TX_AFIFO_REMPTY_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x40000)|value<<18)
}
func (o *SPI2_Type) GetDMA_INT_ENA_MST_TX_AFIFO_REMPTY_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x40000) >> 18
}
func (o *SPI2_Type) SetDMA_INT_ENA_APP2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x80000)|value<<19)
}
func (o *SPI2_Type) GetDMA_INT_ENA_APP2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x80000) >> 19
}
func (o *SPI2_Type) SetDMA_INT_ENA_APP1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x100000)|value<<20)
}
func (o *SPI2_Type) GetDMA_INT_ENA_APP1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x100000) >> 20
}

// SPI2.DMA_INT_CLR: SPI interrupt clear register
func (o *SPI2_Type) SetDMA_INT_CLR_DMA_INFIFO_FULL_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x1)|value)
}
func (o *SPI2_Type) GetDMA_INT_CLR_DMA_INFIFO_FULL_ERR_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x1
}
func (o *SPI2_Type) SetDMA_INT_CLR_DMA_OUTFIFO_EMPTY_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SPI2_Type) GetDMA_INT_CLR_DMA_OUTFIFO_EMPTY_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x2) >> 1
}
func (o *SPI2_Type) SetDMA_INT_CLR_SLV_EX_QPI_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SPI2_Type) GetDMA_INT_CLR_SLV_EX_QPI_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x4) >> 2
}
func (o *SPI2_Type) SetDMA_INT_CLR_SLV_EN_QPI_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SPI2_Type) GetDMA_INT_CLR_SLV_EN_QPI_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x8) >> 3
}
func (o *SPI2_Type) SetDMA_INT_CLR_SLV_CMD7_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SPI2_Type) GetDMA_INT_CLR_SLV_CMD7_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x10) >> 4
}
func (o *SPI2_Type) SetDMA_INT_CLR_SLV_CMD8_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SPI2_Type) GetDMA_INT_CLR_SLV_CMD8_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x20) >> 5
}
func (o *SPI2_Type) SetDMA_INT_CLR_SLV_CMD9_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SPI2_Type) GetDMA_INT_CLR_SLV_CMD9_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x40) >> 6
}
func (o *SPI2_Type) SetDMA_INT_CLR_SLV_CMDA_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SPI2_Type) GetDMA_INT_CLR_SLV_CMDA_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x80) >> 7
}
func (o *SPI2_Type) SetDMA_INT_CLR_SLV_RD_DMA_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SPI2_Type) GetDMA_INT_CLR_SLV_RD_DMA_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x100) >> 8
}
func (o *SPI2_Type) SetDMA_INT_CLR_SLV_WR_DMA_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SPI2_Type) GetDMA_INT_CLR_SLV_WR_DMA_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x200) >> 9
}
func (o *SPI2_Type) SetDMA_INT_CLR_SLV_RD_BUF_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SPI2_Type) GetDMA_INT_CLR_SLV_RD_BUF_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x400) >> 10
}
func (o *SPI2_Type) SetDMA_INT_CLR_SLV_WR_BUF_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SPI2_Type) GetDMA_INT_CLR_SLV_WR_BUF_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x800) >> 11
}
func (o *SPI2_Type) SetDMA_INT_CLR_TRANS_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SPI2_Type) GetDMA_INT_CLR_TRANS_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x1000) >> 12
}
func (o *SPI2_Type) SetDMA_INT_CLR_DMA_SEG_TRANS_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SPI2_Type) GetDMA_INT_CLR_DMA_SEG_TRANS_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x2000) >> 13
}
func (o *SPI2_Type) SetDMA_INT_CLR_SEG_MAGIC_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SPI2_Type) GetDMA_INT_CLR_SEG_MAGIC_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x4000) >> 14
}
func (o *SPI2_Type) SetDMA_INT_CLR_SLV_BUF_ADDR_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SPI2_Type) GetDMA_INT_CLR_SLV_BUF_ADDR_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x8000) >> 15
}
func (o *SPI2_Type) SetDMA_INT_CLR_SLV_CMD_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *SPI2_Type) GetDMA_INT_CLR_SLV_CMD_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x10000) >> 16
}
func (o *SPI2_Type) SetDMA_INT_CLR_MST_RX_AFIFO_WFULL_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *SPI2_Type) GetDMA_INT_CLR_MST_RX_AFIFO_WFULL_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x20000) >> 17
}
func (o *SPI2_Type) SetDMA_INT_CLR_MST_TX_AFIFO_REMPTY_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *SPI2_Type) GetDMA_INT_CLR_MST_TX_AFIFO_REMPTY_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x40000) >> 18
}
func (o *SPI2_Type) SetDMA_INT_CLR_APP2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *SPI2_Type) GetDMA_INT_CLR_APP2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x80000) >> 19
}
func (o *SPI2_Type) SetDMA_INT_CLR_APP1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *SPI2_Type) GetDMA_INT_CLR_APP1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x100000) >> 20
}

// SPI2.DMA_INT_RAW: SPI interrupt raw register
func (o *SPI2_Type) SetDMA_INT_RAW_DMA_INFIFO_FULL_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x1)|value)
}
func (o *SPI2_Type) GetDMA_INT_RAW_DMA_INFIFO_FULL_ERR_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x1
}
func (o *SPI2_Type) SetDMA_INT_RAW_DMA_OUTFIFO_EMPTY_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *SPI2_Type) GetDMA_INT_RAW_DMA_OUTFIFO_EMPTY_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x2) >> 1
}
func (o *SPI2_Type) SetDMA_INT_RAW_SLV_EX_QPI_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *SPI2_Type) GetDMA_INT_RAW_SLV_EX_QPI_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x4) >> 2
}
func (o *SPI2_Type) SetDMA_INT_RAW_SLV_EN_QPI_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *SPI2_Type) GetDMA_INT_RAW_SLV_EN_QPI_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x8) >> 3
}
func (o *SPI2_Type) SetDMA_INT_RAW_SLV_CMD7_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *SPI2_Type) GetDMA_INT_RAW_SLV_CMD7_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x10) >> 4
}
func (o *SPI2_Type) SetDMA_INT_RAW_SLV_CMD8_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *SPI2_Type) GetDMA_INT_RAW_SLV_CMD8_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x20) >> 5
}
func (o *SPI2_Type) SetDMA_INT_RAW_SLV_CMD9_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *SPI2_Type) GetDMA_INT_RAW_SLV_CMD9_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x40) >> 6
}
func (o *SPI2_Type) SetDMA_INT_RAW_SLV_CMDA_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *SPI2_Type) GetDMA_INT_RAW_SLV_CMDA_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x80) >> 7
}
func (o *SPI2_Type) SetDMA_INT_RAW_SLV_RD_DMA_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *SPI2_Type) GetDMA_INT_RAW_SLV_RD_DMA_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x100) >> 8
}
func (o *SPI2_Type) SetDMA_INT_RAW_SLV_WR_DMA_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *SPI2_Type) GetDMA_INT_RAW_SLV_WR_DMA_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x200) >> 9
}
func (o *SPI2_Type) SetDMA_INT_RAW_SLV_RD_BUF_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *SPI2_Type) GetDMA_INT_RAW_SLV_RD_BUF_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x400) >> 10
}
func (o *SPI2_Type) SetDMA_INT_RAW_SLV_WR_BUF_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *SPI2_Type) GetDMA_INT_RAW_SLV_WR_BUF_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x800) >> 11
}
func (o *SPI2_Type) SetDMA_INT_RAW_TRANS_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *SPI2_Type) GetDMA_INT_RAW_TRANS_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x1000) >> 12
}
func (o *SPI2_Type) SetDMA_INT_RAW_DMA_SEG_TRANS_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *SPI2_Type) GetDMA_INT_RAW_DMA_SEG_TRANS_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x2000) >> 13
}
func (o *SPI2_Type) SetDMA_INT_RAW_SEG_MAGIC_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *SPI2_Type) GetDMA_INT_RAW_SEG_MAGIC_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x4000) >> 14
}
func (o *SPI2_Type) SetDMA_INT_RAW_SLV_BUF_ADDR_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *SPI2_Type) GetDMA_INT_RAW_SLV_BUF_ADDR_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x8000) >> 15
}
func (o *SPI2_Type) SetDMA_INT_RAW_SLV_CMD_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *SPI2_Type) GetDMA_INT_RAW_SLV_CMD_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x10000) >> 16
}
func (o *SPI2_Type) SetDMA_INT_RAW_MST_RX_AFIFO_WFULL_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x20000)|value<<17)
}
func (o *SPI2_Type) GetDMA_INT_RAW_MST_RX_AFIFO_WFULL_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x20000) >> 17
}
func (o *SPI2_Type) SetDMA_INT_RAW_MST_TX_AFIFO_REMPTY_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x40000)|value<<18)
}
func (o *SPI2_Type) GetDMA_INT_RAW_MST_TX_AFIFO_REMPTY_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x40000) >> 18
}
func (o *SPI2_Type) SetDMA_INT_RAW_APP2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x80000)|value<<19)
}
func (o *SPI2_Type) GetDMA_INT_RAW_APP2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x80000) >> 19
}
func (o *SPI2_Type) SetDMA_INT_RAW_APP1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x100000)|value<<20)
}
func (o *SPI2_Type) GetDMA_INT_RAW_APP1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x100000) >> 20
}

// SPI2.DMA_INT_ST: SPI interrupt status register
func (o *SPI2_Type) SetDMA_INT_ST_DMA_INFIFO_FULL_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x1)|value)
}
func (o *SPI2_Type) GetDMA_INT_ST_DMA_INFIFO_FULL_ERR_INT_ST() uint32 {
	return volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x1
}
func (o *SPI2_Type) SetDMA_INT_ST_DMA_OUTFIFO_EMPTY_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *SPI2_Type) GetDMA_INT_ST_DMA_OUTFIFO_EMPTY_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x2) >> 1
}
func (o *SPI2_Type) SetDMA_INT_ST_SLV_EX_QPI_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *SPI2_Type) GetDMA_INT_ST_SLV_EX_QPI_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x4) >> 2
}
func (o *SPI2_Type) SetDMA_INT_ST_SLV_EN_QPI_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *SPI2_Type) GetDMA_INT_ST_SLV_EN_QPI_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x8) >> 3
}
func (o *SPI2_Type) SetDMA_INT_ST_SLV_CMD7_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *SPI2_Type) GetDMA_INT_ST_SLV_CMD7_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x10) >> 4
}
func (o *SPI2_Type) SetDMA_INT_ST_SLV_CMD8_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *SPI2_Type) GetDMA_INT_ST_SLV_CMD8_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x20) >> 5
}
func (o *SPI2_Type) SetDMA_INT_ST_SLV_CMD9_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *SPI2_Type) GetDMA_INT_ST_SLV_CMD9_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x40) >> 6
}
func (o *SPI2_Type) SetDMA_INT_ST_SLV_CMDA_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *SPI2_Type) GetDMA_INT_ST_SLV_CMDA_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x80) >> 7
}
func (o *SPI2_Type) SetDMA_INT_ST_SLV_RD_DMA_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *SPI2_Type) GetDMA_INT_ST_SLV_RD_DMA_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x100) >> 8
}
func (o *SPI2_Type) SetDMA_INT_ST_SLV_WR_DMA_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *SPI2_Type) GetDMA_INT_ST_SLV_WR_DMA_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x200) >> 9
}
func (o *SPI2_Type) SetDMA_INT_ST_SLV_RD_BUF_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *SPI2_Type) GetDMA_INT_ST_SLV_RD_BUF_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x400) >> 10
}
func (o *SPI2_Type) SetDMA_INT_ST_SLV_WR_BUF_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *SPI2_Type) GetDMA_INT_ST_SLV_WR_BUF_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x800) >> 11
}
func (o *SPI2_Type) SetDMA_INT_ST_TRANS_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *SPI2_Type) GetDMA_INT_ST_TRANS_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x1000) >> 12
}
func (o *SPI2_Type) SetDMA_INT_ST_DMA_SEG_TRANS_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *SPI2_Type) GetDMA_INT_ST_DMA_SEG_TRANS_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x2000) >> 13
}
func (o *SPI2_Type) SetDMA_INT_ST_SEG_MAGIC_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *SPI2_Type) GetDMA_INT_ST_SEG_MAGIC_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x4000) >> 14
}
func (o *SPI2_Type) SetDMA_INT_ST_SLV_BUF_ADDR_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *SPI2_Type) GetDMA_INT_ST_SLV_BUF_ADDR_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x8000) >> 15
}
func (o *SPI2_Type) SetDMA_INT_ST_SLV_CMD_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *SPI2_Type) GetDMA_INT_ST_SLV_CMD_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x10000) >> 16
}
func (o *SPI2_Type) SetDMA_INT_ST_MST_RX_AFIFO_WFULL_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x20000)|value<<17)
}
func (o *SPI2_Type) GetDMA_INT_ST_MST_RX_AFIFO_WFULL_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x20000) >> 17
}
func (o *SPI2_Type) SetDMA_INT_ST_MST_TX_AFIFO_REMPTY_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x40000)|value<<18)
}
func (o *SPI2_Type) GetDMA_INT_ST_MST_TX_AFIFO_REMPTY_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x40000) >> 18
}
func (o *SPI2_Type) SetDMA_INT_ST_APP2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x80000)|value<<19)
}
func (o *SPI2_Type) GetDMA_INT_ST_APP2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x80000) >> 19
}
func (o *SPI2_Type) SetDMA_INT_ST_APP1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x100000)|value<<20)
}
func (o *SPI2_Type) GetDMA_INT_ST_APP1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x100000) >> 20
}

// SPI2.DMA_INT_SET: SPI interrupt software set register
func (o *SPI2_Type) SetDMA_INT_SET_DMA_INFIFO_FULL_ERR_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x1)|value)
}
func (o *SPI2_Type) GetDMA_INT_SET_DMA_INFIFO_FULL_ERR_INT_SET() uint32 {
	return volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x1
}
func (o *SPI2_Type) SetDMA_INT_SET_DMA_OUTFIFO_EMPTY_ERR_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x2)|value<<1)
}
func (o *SPI2_Type) GetDMA_INT_SET_DMA_OUTFIFO_EMPTY_ERR_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x2) >> 1
}
func (o *SPI2_Type) SetDMA_INT_SET_SLV_EX_QPI_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x4)|value<<2)
}
func (o *SPI2_Type) GetDMA_INT_SET_SLV_EX_QPI_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x4) >> 2
}
func (o *SPI2_Type) SetDMA_INT_SET_SLV_EN_QPI_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x8)|value<<3)
}
func (o *SPI2_Type) GetDMA_INT_SET_SLV_EN_QPI_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x8) >> 3
}
func (o *SPI2_Type) SetDMA_INT_SET_SLV_CMD7_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x10)|value<<4)
}
func (o *SPI2_Type) GetDMA_INT_SET_SLV_CMD7_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x10) >> 4
}
func (o *SPI2_Type) SetDMA_INT_SET_SLV_CMD8_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x20)|value<<5)
}
func (o *SPI2_Type) GetDMA_INT_SET_SLV_CMD8_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x20) >> 5
}
func (o *SPI2_Type) SetDMA_INT_SET_SLV_CMD9_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x40)|value<<6)
}
func (o *SPI2_Type) GetDMA_INT_SET_SLV_CMD9_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x40) >> 6
}
func (o *SPI2_Type) SetDMA_INT_SET_SLV_CMDA_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x80)|value<<7)
}
func (o *SPI2_Type) GetDMA_INT_SET_SLV_CMDA_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x80) >> 7
}
func (o *SPI2_Type) SetDMA_INT_SET_SLV_RD_DMA_DONE_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x100)|value<<8)
}
func (o *SPI2_Type) GetDMA_INT_SET_SLV_RD_DMA_DONE_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x100) >> 8
}
func (o *SPI2_Type) SetDMA_INT_SET_SLV_WR_DMA_DONE_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x200)|value<<9)
}
func (o *SPI2_Type) GetDMA_INT_SET_SLV_WR_DMA_DONE_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x200) >> 9
}
func (o *SPI2_Type) SetDMA_INT_SET_SLV_RD_BUF_DONE_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x400)|value<<10)
}
func (o *SPI2_Type) GetDMA_INT_SET_SLV_RD_BUF_DONE_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x400) >> 10
}
func (o *SPI2_Type) SetDMA_INT_SET_SLV_WR_BUF_DONE_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x800)|value<<11)
}
func (o *SPI2_Type) GetDMA_INT_SET_SLV_WR_BUF_DONE_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x800) >> 11
}
func (o *SPI2_Type) SetDMA_INT_SET_TRANS_DONE_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SPI2_Type) GetDMA_INT_SET_TRANS_DONE_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x1000) >> 12
}
func (o *SPI2_Type) SetDMA_INT_SET_DMA_SEG_TRANS_DONE_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SPI2_Type) GetDMA_INT_SET_DMA_SEG_TRANS_DONE_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x2000) >> 13
}
func (o *SPI2_Type) SetDMA_INT_SET_SEG_MAGIC_ERR_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SPI2_Type) GetDMA_INT_SET_SEG_MAGIC_ERR_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x4000) >> 14
}
func (o *SPI2_Type) SetDMA_INT_SET_SLV_BUF_ADDR_ERR_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SPI2_Type) GetDMA_INT_SET_SLV_BUF_ADDR_ERR_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x8000) >> 15
}
func (o *SPI2_Type) SetDMA_INT_SET_SLV_CMD_ERR_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x10000)|value<<16)
}
func (o *SPI2_Type) GetDMA_INT_SET_SLV_CMD_ERR_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x10000) >> 16
}
func (o *SPI2_Type) SetDMA_INT_SET_MST_RX_AFIFO_WFULL_ERR_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x20000)|value<<17)
}
func (o *SPI2_Type) GetDMA_INT_SET_MST_RX_AFIFO_WFULL_ERR_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x20000) >> 17
}
func (o *SPI2_Type) SetDMA_INT_SET_MST_TX_AFIFO_REMPTY_ERR_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x40000)|value<<18)
}
func (o *SPI2_Type) GetDMA_INT_SET_MST_TX_AFIFO_REMPTY_ERR_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x40000) >> 18
}
func (o *SPI2_Type) SetDMA_INT_SET_APP2_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x80000)|value<<19)
}
func (o *SPI2_Type) GetDMA_INT_SET_APP2_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x80000) >> 19
}
func (o *SPI2_Type) SetDMA_INT_SET_APP1_INT_SET(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_SET.Reg, volatile.LoadUint32(&o.DMA_INT_SET.Reg)&^(0x100000)|value<<20)
}
func (o *SPI2_Type) GetDMA_INT_SET_APP1_INT_SET() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_SET.Reg) & 0x100000) >> 20
}

// SPI2.W0: SPI CPU-controlled buffer0
func (o *SPI2_Type) SetW0(value uint32) {
	volatile.StoreUint32(&o.W0.Reg, value)
}
func (o *SPI2_Type) GetW0() uint32 {
	return volatile.LoadUint32(&o.W0.Reg)
}

// SPI2.W1: SPI CPU-controlled buffer1
func (o *SPI2_Type) SetW1(value uint32) {
	volatile.StoreUint32(&o.W1.Reg, value)
}
func (o *SPI2_Type) GetW1() uint32 {
	return volatile.LoadUint32(&o.W1.Reg)
}

// SPI2.W2: SPI CPU-controlled buffer2
func (o *SPI2_Type) SetW2(value uint32) {
	volatile.StoreUint32(&o.W2.Reg, value)
}
func (o *SPI2_Type) GetW2() uint32 {
	return volatile.LoadUint32(&o.W2.Reg)
}

// SPI2.W3: SPI CPU-controlled buffer3
func (o *SPI2_Type) SetW3(value uint32) {
	volatile.StoreUint32(&o.W3.Reg, value)
}
func (o *SPI2_Type) GetW3() uint32 {
	return volatile.LoadUint32(&o.W3.Reg)
}

// SPI2.W4: SPI CPU-controlled buffer4
func (o *SPI2_Type) SetW4(value uint32) {
	volatile.StoreUint32(&o.W4.Reg, value)
}
func (o *SPI2_Type) GetW4() uint32 {
	return volatile.LoadUint32(&o.W4.Reg)
}

// SPI2.W5: SPI CPU-controlled buffer5
func (o *SPI2_Type) SetW5(value uint32) {
	volatile.StoreUint32(&o.W5.Reg, value)
}
func (o *SPI2_Type) GetW5() uint32 {
	return volatile.LoadUint32(&o.W5.Reg)
}

// SPI2.W6: SPI CPU-controlled buffer6
func (o *SPI2_Type) SetW6(value uint32) {
	volatile.StoreUint32(&o.W6.Reg, value)
}
func (o *SPI2_Type) GetW6() uint32 {
	return volatile.LoadUint32(&o.W6.Reg)
}

// SPI2.W7: SPI CPU-controlled buffer7
func (o *SPI2_Type) SetW7(value uint32) {
	volatile.StoreUint32(&o.W7.Reg, value)
}
func (o *SPI2_Type) GetW7() uint32 {
	return volatile.LoadUint32(&o.W7.Reg)
}

// SPI2.W8: SPI CPU-controlled buffer8
func (o *SPI2_Type) SetW8(value uint32) {
	volatile.StoreUint32(&o.W8.Reg, value)
}
func (o *SPI2_Type) GetW8() uint32 {
	return volatile.LoadUint32(&o.W8.Reg)
}

// SPI2.W9: SPI CPU-controlled buffer9
func (o *SPI2_Type) SetW9(value uint32) {
	volatile.StoreUint32(&o.W9.Reg, value)
}
func (o *SPI2_Type) GetW9() uint32 {
	return volatile.LoadUint32(&o.W9.Reg)
}

// SPI2.W10: SPI CPU-controlled buffer10
func (o *SPI2_Type) SetW10(value uint32) {
	volatile.StoreUint32(&o.W10.Reg, value)
}
func (o *SPI2_Type) GetW10() uint32 {
	return volatile.LoadUint32(&o.W10.Reg)
}

// SPI2.W11: SPI CPU-controlled buffer11
func (o *SPI2_Type) SetW11(value uint32) {
	volatile.StoreUint32(&o.W11.Reg, value)
}
func (o *SPI2_Type) GetW11() uint32 {
	return volatile.LoadUint32(&o.W11.Reg)
}

// SPI2.W12: SPI CPU-controlled buffer12
func (o *SPI2_Type) SetW12(value uint32) {
	volatile.StoreUint32(&o.W12.Reg, value)
}
func (o *SPI2_Type) GetW12() uint32 {
	return volatile.LoadUint32(&o.W12.Reg)
}

// SPI2.W13: SPI CPU-controlled buffer13
func (o *SPI2_Type) SetW13(value uint32) {
	volatile.StoreUint32(&o.W13.Reg, value)
}
func (o *SPI2_Type) GetW13() uint32 {
	return volatile.LoadUint32(&o.W13.Reg)
}

// SPI2.W14: SPI CPU-controlled buffer14
func (o *SPI2_Type) SetW14(value uint32) {
	volatile.StoreUint32(&o.W14.Reg, value)
}
func (o *SPI2_Type) GetW14() uint32 {
	return volatile.LoadUint32(&o.W14.Reg)
}

// SPI2.W15: SPI CPU-controlled buffer15
func (o *SPI2_Type) SetW15(value uint32) {
	volatile.StoreUint32(&o.W15.Reg, value)
}
func (o *SPI2_Type) GetW15() uint32 {
	return volatile.LoadUint32(&o.W15.Reg)
}

// SPI2.SLAVE: SPI slave control register
func (o *SPI2_Type) SetSLAVE_CLK_MODE(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x3)|value)
}
func (o *SPI2_Type) GetSLAVE_CLK_MODE() uint32 {
	return volatile.LoadUint32(&o.SLAVE.Reg) & 0x3
}
func (o *SPI2_Type) SetSLAVE_CLK_MODE_13(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x4)|value<<2)
}
func (o *SPI2_Type) GetSLAVE_CLK_MODE_13() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x4) >> 2
}
func (o *SPI2_Type) SetSLAVE_RSCK_DATA_OUT(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x8)|value<<3)
}
func (o *SPI2_Type) GetSLAVE_RSCK_DATA_OUT() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x8) >> 3
}
func (o *SPI2_Type) SetSLAVE_SLV_RDDMA_BITLEN_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x100)|value<<8)
}
func (o *SPI2_Type) GetSLAVE_SLV_RDDMA_BITLEN_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x100) >> 8
}
func (o *SPI2_Type) SetSLAVE_SLV_WRDMA_BITLEN_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x200)|value<<9)
}
func (o *SPI2_Type) GetSLAVE_SLV_WRDMA_BITLEN_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x200) >> 9
}
func (o *SPI2_Type) SetSLAVE_SLV_RDBUF_BITLEN_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x400)|value<<10)
}
func (o *SPI2_Type) GetSLAVE_SLV_RDBUF_BITLEN_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x400) >> 10
}
func (o *SPI2_Type) SetSLAVE_SLV_WRBUF_BITLEN_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x800)|value<<11)
}
func (o *SPI2_Type) GetSLAVE_SLV_WRBUF_BITLEN_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x800) >> 11
}
func (o *SPI2_Type) SetSLAVE_DMA_SEG_MAGIC_VALUE(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x3c00000)|value<<22)
}
func (o *SPI2_Type) GetSLAVE_DMA_SEG_MAGIC_VALUE() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x3c00000) >> 22
}
func (o *SPI2_Type) SetSLAVE_MODE(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI2_Type) GetSLAVE_MODE() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x4000000) >> 26
}
func (o *SPI2_Type) SetSLAVE_SOFT_RESET(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI2_Type) GetSLAVE_SOFT_RESET() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x8000000) >> 27
}
func (o *SPI2_Type) SetSLAVE_USR_CONF(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI2_Type) GetSLAVE_USR_CONF() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x10000000) >> 28
}
func (o *SPI2_Type) SetSLAVE_MST_FD_WAIT_DMA_TX_DATA(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI2_Type) GetSLAVE_MST_FD_WAIT_DMA_TX_DATA() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x20000000) >> 29
}

// SPI2.SLAVE1: SPI slave control register 1
func (o *SPI2_Type) SetSLAVE1_SLV_DATA_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SLAVE1.Reg, volatile.LoadUint32(&o.SLAVE1.Reg)&^(0x3ffff)|value)
}
func (o *SPI2_Type) GetSLAVE1_SLV_DATA_BITLEN() uint32 {
	return volatile.LoadUint32(&o.SLAVE1.Reg) & 0x3ffff
}
func (o *SPI2_Type) SetSLAVE1_SLV_LAST_COMMAND(value uint32) {
	volatile.StoreUint32(&o.SLAVE1.Reg, volatile.LoadUint32(&o.SLAVE1.Reg)&^(0x3fc0000)|value<<18)
}
func (o *SPI2_Type) GetSLAVE1_SLV_LAST_COMMAND() uint32 {
	return (volatile.LoadUint32(&o.SLAVE1.Reg) & 0x3fc0000) >> 18
}
func (o *SPI2_Type) SetSLAVE1_SLV_LAST_ADDR(value uint32) {
	volatile.StoreUint32(&o.SLAVE1.Reg, volatile.LoadUint32(&o.SLAVE1.Reg)&^(0xfc000000)|value<<26)
}
func (o *SPI2_Type) GetSLAVE1_SLV_LAST_ADDR() uint32 {
	return (volatile.LoadUint32(&o.SLAVE1.Reg) & 0xfc000000) >> 26
}

// SPI2.CLK_GATE: SPI module clock and register clock control
func (o *SPI2_Type) SetCLK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_GATE.Reg, volatile.LoadUint32(&o.CLK_GATE.Reg)&^(0x1)|value)
}
func (o *SPI2_Type) GetCLK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLK_GATE.Reg) & 0x1
}
func (o *SPI2_Type) SetCLK_GATE_MST_CLK_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.CLK_GATE.Reg, volatile.LoadUint32(&o.CLK_GATE.Reg)&^(0x2)|value<<1)
}
func (o *SPI2_Type) GetCLK_GATE_MST_CLK_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.CLK_GATE.Reg) & 0x2) >> 1
}
func (o *SPI2_Type) SetCLK_GATE_MST_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_GATE.Reg, volatile.LoadUint32(&o.CLK_GATE.Reg)&^(0x4)|value<<2)
}
func (o *SPI2_Type) GetCLK_GATE_MST_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_GATE.Reg) & 0x4) >> 2
}

// SPI2.DATE: Version control
func (o *SPI2_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *SPI2_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// System Timer
type SYSTIMER_Type struct {
	CONF            volatile.Register32 // 0x0
	UNIT0_OP        volatile.Register32 // 0x4
	UNIT1_OP        volatile.Register32 // 0x8
	UNIT0_LOAD_HI   volatile.Register32 // 0xC
	UNIT0_LOAD_LO   volatile.Register32 // 0x10
	UNIT1_LOAD_HI   volatile.Register32 // 0x14
	UNIT1_LOAD_LO   volatile.Register32 // 0x18
	TARGET0_HI      volatile.Register32 // 0x1C
	TARGET0_LO      volatile.Register32 // 0x20
	TARGET1_HI      volatile.Register32 // 0x24
	TARGET1_LO      volatile.Register32 // 0x28
	TARGET2_HI      volatile.Register32 // 0x2C
	TARGET2_LO      volatile.Register32 // 0x30
	TARGET0_CONF    volatile.Register32 // 0x34
	TARGET1_CONF    volatile.Register32 // 0x38
	TARGET2_CONF    volatile.Register32 // 0x3C
	UNIT0_VALUE_HI  volatile.Register32 // 0x40
	UNIT0_VALUE_LO  volatile.Register32 // 0x44
	UNIT1_VALUE_HI  volatile.Register32 // 0x48
	UNIT1_VALUE_LO  volatile.Register32 // 0x4C
	COMP0_LOAD      volatile.Register32 // 0x50
	COMP1_LOAD      volatile.Register32 // 0x54
	COMP2_LOAD      volatile.Register32 // 0x58
	UNIT0_LOAD      volatile.Register32 // 0x5C
	UNIT1_LOAD      volatile.Register32 // 0x60
	INT_ENA         volatile.Register32 // 0x64
	INT_RAW         volatile.Register32 // 0x68
	INT_CLR         volatile.Register32 // 0x6C
	INT_ST          volatile.Register32 // 0x70
	REAL_TARGET0_LO volatile.Register32 // 0x74
	REAL_TARGET0_HI volatile.Register32 // 0x78
	REAL_TARGET1_LO volatile.Register32 // 0x7C
	REAL_TARGET1_HI volatile.Register32 // 0x80
	REAL_TARGET2_LO volatile.Register32 // 0x84
	REAL_TARGET2_HI volatile.Register32 // 0x88
	_               [112]byte
	DATE            volatile.Register32 // 0xFC
}

// SYSTIMER.CONF: Configure system timer clock
func (o *SYSTIMER_Type) SetCONF_SYSTIMER_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetCONF_SYSTIMER_CLK_FO() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0x1
}
func (o *SYSTIMER_Type) SetCONF_ETM_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x2)|value<<1)
}
func (o *SYSTIMER_Type) GetCONF_ETM_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x2) >> 1
}
func (o *SYSTIMER_Type) SetCONF_TARGET2_WORK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x400000)|value<<22)
}
func (o *SYSTIMER_Type) GetCONF_TARGET2_WORK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x400000) >> 22
}
func (o *SYSTIMER_Type) SetCONF_TARGET1_WORK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x800000)|value<<23)
}
func (o *SYSTIMER_Type) GetCONF_TARGET1_WORK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x800000) >> 23
}
func (o *SYSTIMER_Type) SetCONF_TARGET0_WORK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSTIMER_Type) GetCONF_TARGET0_WORK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x1000000) >> 24
}
func (o *SYSTIMER_Type) SetCONF_TIMER_UNIT1_CORE1_STALL_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSTIMER_Type) GetCONF_TIMER_UNIT1_CORE1_STALL_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x2000000) >> 25
}
func (o *SYSTIMER_Type) SetCONF_TIMER_UNIT1_CORE0_STALL_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSTIMER_Type) GetCONF_TIMER_UNIT1_CORE0_STALL_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x4000000) >> 26
}
func (o *SYSTIMER_Type) SetCONF_TIMER_UNIT0_CORE1_STALL_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSTIMER_Type) GetCONF_TIMER_UNIT0_CORE1_STALL_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x8000000) >> 27
}
func (o *SYSTIMER_Type) SetCONF_TIMER_UNIT0_CORE0_STALL_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSTIMER_Type) GetCONF_TIMER_UNIT0_CORE0_STALL_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x10000000) >> 28
}
func (o *SYSTIMER_Type) SetCONF_TIMER_UNIT1_WORK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSTIMER_Type) GetCONF_TIMER_UNIT1_WORK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x20000000) >> 29
}
func (o *SYSTIMER_Type) SetCONF_TIMER_UNIT0_WORK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetCONF_TIMER_UNIT0_WORK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x40000000) >> 30
}
func (o *SYSTIMER_Type) SetCONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetCONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x80000000) >> 31
}

// SYSTIMER.UNIT0_OP: system timer unit0 value update register
func (o *SYSTIMER_Type) SetUNIT0_OP_TIMER_UNIT0_VALUE_VALID(value uint32) {
	volatile.StoreUint32(&o.UNIT0_OP.Reg, volatile.LoadUint32(&o.UNIT0_OP.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSTIMER_Type) GetUNIT0_OP_TIMER_UNIT0_VALUE_VALID() uint32 {
	return (volatile.LoadUint32(&o.UNIT0_OP.Reg) & 0x20000000) >> 29
}
func (o *SYSTIMER_Type) SetUNIT0_OP_TIMER_UNIT0_UPDATE(value uint32) {
	volatile.StoreUint32(&o.UNIT0_OP.Reg, volatile.LoadUint32(&o.UNIT0_OP.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetUNIT0_OP_TIMER_UNIT0_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.UNIT0_OP.Reg) & 0x40000000) >> 30
}

// SYSTIMER.UNIT1_OP: system timer unit1 value update register
func (o *SYSTIMER_Type) SetUNIT1_OP_TIMER_UNIT1_VALUE_VALID(value uint32) {
	volatile.StoreUint32(&o.UNIT1_OP.Reg, volatile.LoadUint32(&o.UNIT1_OP.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSTIMER_Type) GetUNIT1_OP_TIMER_UNIT1_VALUE_VALID() uint32 {
	return (volatile.LoadUint32(&o.UNIT1_OP.Reg) & 0x20000000) >> 29
}
func (o *SYSTIMER_Type) SetUNIT1_OP_TIMER_UNIT1_UPDATE(value uint32) {
	volatile.StoreUint32(&o.UNIT1_OP.Reg, volatile.LoadUint32(&o.UNIT1_OP.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetUNIT1_OP_TIMER_UNIT1_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.UNIT1_OP.Reg) & 0x40000000) >> 30
}

// SYSTIMER.UNIT0_LOAD_HI: system timer unit0 value high load register
func (o *SYSTIMER_Type) SetUNIT0_LOAD_HI_TIMER_UNIT0_LOAD_HI(value uint32) {
	volatile.StoreUint32(&o.UNIT0_LOAD_HI.Reg, volatile.LoadUint32(&o.UNIT0_LOAD_HI.Reg)&^(0xfffff)|value)
}
func (o *SYSTIMER_Type) GetUNIT0_LOAD_HI_TIMER_UNIT0_LOAD_HI() uint32 {
	return volatile.LoadUint32(&o.UNIT0_LOAD_HI.Reg) & 0xfffff
}

// SYSTIMER.UNIT0_LOAD_LO: system timer unit0 value low load register
func (o *SYSTIMER_Type) SetUNIT0_LOAD_LO(value uint32) {
	volatile.StoreUint32(&o.UNIT0_LOAD_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetUNIT0_LOAD_LO() uint32 {
	return volatile.LoadUint32(&o.UNIT0_LOAD_LO.Reg)
}

// SYSTIMER.UNIT1_LOAD_HI: system timer unit1 value high load register
func (o *SYSTIMER_Type) SetUNIT1_LOAD_HI_TIMER_UNIT1_LOAD_HI(value uint32) {
	volatile.StoreUint32(&o.UNIT1_LOAD_HI.Reg, volatile.LoadUint32(&o.UNIT1_LOAD_HI.Reg)&^(0xfffff)|value)
}
func (o *SYSTIMER_Type) GetUNIT1_LOAD_HI_TIMER_UNIT1_LOAD_HI() uint32 {
	return volatile.LoadUint32(&o.UNIT1_LOAD_HI.Reg) & 0xfffff
}

// SYSTIMER.UNIT1_LOAD_LO: system timer unit1 value low load register
func (o *SYSTIMER_Type) SetUNIT1_LOAD_LO(value uint32) {
	volatile.StoreUint32(&o.UNIT1_LOAD_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetUNIT1_LOAD_LO() uint32 {
	return volatile.LoadUint32(&o.UNIT1_LOAD_LO.Reg)
}

// SYSTIMER.TARGET0_HI: system timer comp0 value high register
func (o *SYSTIMER_Type) SetTARGET0_HI_TIMER_TARGET0_HI(value uint32) {
	volatile.StoreUint32(&o.TARGET0_HI.Reg, volatile.LoadUint32(&o.TARGET0_HI.Reg)&^(0xfffff)|value)
}
func (o *SYSTIMER_Type) GetTARGET0_HI_TIMER_TARGET0_HI() uint32 {
	return volatile.LoadUint32(&o.TARGET0_HI.Reg) & 0xfffff
}

// SYSTIMER.TARGET0_LO: system timer comp0 value low register
func (o *SYSTIMER_Type) SetTARGET0_LO(value uint32) {
	volatile.StoreUint32(&o.TARGET0_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET0_LO() uint32 {
	return volatile.LoadUint32(&o.TARGET0_LO.Reg)
}

// SYSTIMER.TARGET1_HI: system timer comp1 value high register
func (o *SYSTIMER_Type) SetTARGET1_HI_TIMER_TARGET1_HI(value uint32) {
	volatile.StoreUint32(&o.TARGET1_HI.Reg, volatile.LoadUint32(&o.TARGET1_HI.Reg)&^(0xfffff)|value)
}
func (o *SYSTIMER_Type) GetTARGET1_HI_TIMER_TARGET1_HI() uint32 {
	return volatile.LoadUint32(&o.TARGET1_HI.Reg) & 0xfffff
}

// SYSTIMER.TARGET1_LO: system timer comp1 value low register
func (o *SYSTIMER_Type) SetTARGET1_LO(value uint32) {
	volatile.StoreUint32(&o.TARGET1_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET1_LO() uint32 {
	return volatile.LoadUint32(&o.TARGET1_LO.Reg)
}

// SYSTIMER.TARGET2_HI: system timer comp2 value high register
func (o *SYSTIMER_Type) SetTARGET2_HI_TIMER_TARGET2_HI(value uint32) {
	volatile.StoreUint32(&o.TARGET2_HI.Reg, volatile.LoadUint32(&o.TARGET2_HI.Reg)&^(0xfffff)|value)
}
func (o *SYSTIMER_Type) GetTARGET2_HI_TIMER_TARGET2_HI() uint32 {
	return volatile.LoadUint32(&o.TARGET2_HI.Reg) & 0xfffff
}

// SYSTIMER.TARGET2_LO: system timer comp2 value low register
func (o *SYSTIMER_Type) SetTARGET2_LO(value uint32) {
	volatile.StoreUint32(&o.TARGET2_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET2_LO() uint32 {
	return volatile.LoadUint32(&o.TARGET2_LO.Reg)
}

// SYSTIMER.TARGET0_CONF: system timer comp0 target mode register
func (o *SYSTIMER_Type) SetTARGET0_CONF_TARGET0_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TARGET0_CONF.Reg, volatile.LoadUint32(&o.TARGET0_CONF.Reg)&^(0x3ffffff)|value)
}
func (o *SYSTIMER_Type) GetTARGET0_CONF_TARGET0_PERIOD() uint32 {
	return volatile.LoadUint32(&o.TARGET0_CONF.Reg) & 0x3ffffff
}
func (o *SYSTIMER_Type) SetTARGET0_CONF_TARGET0_PERIOD_MODE(value uint32) {
	volatile.StoreUint32(&o.TARGET0_CONF.Reg, volatile.LoadUint32(&o.TARGET0_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetTARGET0_CONF_TARGET0_PERIOD_MODE() uint32 {
	return (volatile.LoadUint32(&o.TARGET0_CONF.Reg) & 0x40000000) >> 30
}
func (o *SYSTIMER_Type) SetTARGET0_CONF_TARGET0_TIMER_UNIT_SEL(value uint32) {
	volatile.StoreUint32(&o.TARGET0_CONF.Reg, volatile.LoadUint32(&o.TARGET0_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetTARGET0_CONF_TARGET0_TIMER_UNIT_SEL() uint32 {
	return (volatile.LoadUint32(&o.TARGET0_CONF.Reg) & 0x80000000) >> 31
}

// SYSTIMER.TARGET1_CONF: system timer comp1 target mode register
func (o *SYSTIMER_Type) SetTARGET1_CONF_TARGET1_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TARGET1_CONF.Reg, volatile.LoadUint32(&o.TARGET1_CONF.Reg)&^(0x3ffffff)|value)
}
func (o *SYSTIMER_Type) GetTARGET1_CONF_TARGET1_PERIOD() uint32 {
	return volatile.LoadUint32(&o.TARGET1_CONF.Reg) & 0x3ffffff
}
func (o *SYSTIMER_Type) SetTARGET1_CONF_TARGET1_PERIOD_MODE(value uint32) {
	volatile.StoreUint32(&o.TARGET1_CONF.Reg, volatile.LoadUint32(&o.TARGET1_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetTARGET1_CONF_TARGET1_PERIOD_MODE() uint32 {
	return (volatile.LoadUint32(&o.TARGET1_CONF.Reg) & 0x40000000) >> 30
}
func (o *SYSTIMER_Type) SetTARGET1_CONF_TARGET1_TIMER_UNIT_SEL(value uint32) {
	volatile.StoreUint32(&o.TARGET1_CONF.Reg, volatile.LoadUint32(&o.TARGET1_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetTARGET1_CONF_TARGET1_TIMER_UNIT_SEL() uint32 {
	return (volatile.LoadUint32(&o.TARGET1_CONF.Reg) & 0x80000000) >> 31
}

// SYSTIMER.TARGET2_CONF: system timer comp2 target mode register
func (o *SYSTIMER_Type) SetTARGET2_CONF_TARGET2_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TARGET2_CONF.Reg, volatile.LoadUint32(&o.TARGET2_CONF.Reg)&^(0x3ffffff)|value)
}
func (o *SYSTIMER_Type) GetTARGET2_CONF_TARGET2_PERIOD() uint32 {
	return volatile.LoadUint32(&o.TARGET2_CONF.Reg) & 0x3ffffff
}
func (o *SYSTIMER_Type) SetTARGET2_CONF_TARGET2_PERIOD_MODE(value uint32) {
	volatile.StoreUint32(&o.TARGET2_CONF.Reg, volatile.LoadUint32(&o.TARGET2_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetTARGET2_CONF_TARGET2_PERIOD_MODE() uint32 {
	return (volatile.LoadUint32(&o.TARGET2_CONF.Reg) & 0x40000000) >> 30
}
func (o *SYSTIMER_Type) SetTARGET2_CONF_TARGET2_TIMER_UNIT_SEL(value uint32) {
	volatile.StoreUint32(&o.TARGET2_CONF.Reg, volatile.LoadUint32(&o.TARGET2_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetTARGET2_CONF_TARGET2_TIMER_UNIT_SEL() uint32 {
	return (volatile.LoadUint32(&o.TARGET2_CONF.Reg) & 0x80000000) >> 31
}

// SYSTIMER.UNIT0_VALUE_HI: system timer unit0 value high register
func (o *SYSTIMER_Type) SetUNIT0_VALUE_HI_TIMER_UNIT0_VALUE_HI(value uint32) {
	volatile.StoreUint32(&o.UNIT0_VALUE_HI.Reg, volatile.LoadUint32(&o.UNIT0_VALUE_HI.Reg)&^(0xfffff)|value)
}
func (o *SYSTIMER_Type) GetUNIT0_VALUE_HI_TIMER_UNIT0_VALUE_HI() uint32 {
	return volatile.LoadUint32(&o.UNIT0_VALUE_HI.Reg) & 0xfffff
}

// SYSTIMER.UNIT0_VALUE_LO: system timer unit0 value low register
func (o *SYSTIMER_Type) SetUNIT0_VALUE_LO(value uint32) {
	volatile.StoreUint32(&o.UNIT0_VALUE_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetUNIT0_VALUE_LO() uint32 {
	return volatile.LoadUint32(&o.UNIT0_VALUE_LO.Reg)
}

// SYSTIMER.UNIT1_VALUE_HI: system timer unit1 value high register
func (o *SYSTIMER_Type) SetUNIT1_VALUE_HI_TIMER_UNIT1_VALUE_HI(value uint32) {
	volatile.StoreUint32(&o.UNIT1_VALUE_HI.Reg, volatile.LoadUint32(&o.UNIT1_VALUE_HI.Reg)&^(0xfffff)|value)
}
func (o *SYSTIMER_Type) GetUNIT1_VALUE_HI_TIMER_UNIT1_VALUE_HI() uint32 {
	return volatile.LoadUint32(&o.UNIT1_VALUE_HI.Reg) & 0xfffff
}

// SYSTIMER.UNIT1_VALUE_LO: system timer unit1 value low register
func (o *SYSTIMER_Type) SetUNIT1_VALUE_LO(value uint32) {
	volatile.StoreUint32(&o.UNIT1_VALUE_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetUNIT1_VALUE_LO() uint32 {
	return volatile.LoadUint32(&o.UNIT1_VALUE_LO.Reg)
}

// SYSTIMER.COMP0_LOAD: system timer comp0 conf sync register
func (o *SYSTIMER_Type) SetCOMP0_LOAD_TIMER_COMP0_LOAD(value uint32) {
	volatile.StoreUint32(&o.COMP0_LOAD.Reg, volatile.LoadUint32(&o.COMP0_LOAD.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetCOMP0_LOAD_TIMER_COMP0_LOAD() uint32 {
	return volatile.LoadUint32(&o.COMP0_LOAD.Reg) & 0x1
}

// SYSTIMER.COMP1_LOAD: system timer comp1 conf sync register
func (o *SYSTIMER_Type) SetCOMP1_LOAD_TIMER_COMP1_LOAD(value uint32) {
	volatile.StoreUint32(&o.COMP1_LOAD.Reg, volatile.LoadUint32(&o.COMP1_LOAD.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetCOMP1_LOAD_TIMER_COMP1_LOAD() uint32 {
	return volatile.LoadUint32(&o.COMP1_LOAD.Reg) & 0x1
}

// SYSTIMER.COMP2_LOAD: system timer comp2 conf sync register
func (o *SYSTIMER_Type) SetCOMP2_LOAD_TIMER_COMP2_LOAD(value uint32) {
	volatile.StoreUint32(&o.COMP2_LOAD.Reg, volatile.LoadUint32(&o.COMP2_LOAD.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetCOMP2_LOAD_TIMER_COMP2_LOAD() uint32 {
	return volatile.LoadUint32(&o.COMP2_LOAD.Reg) & 0x1
}

// SYSTIMER.UNIT0_LOAD: system timer unit0 conf sync register
func (o *SYSTIMER_Type) SetUNIT0_LOAD_TIMER_UNIT0_LOAD(value uint32) {
	volatile.StoreUint32(&o.UNIT0_LOAD.Reg, volatile.LoadUint32(&o.UNIT0_LOAD.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetUNIT0_LOAD_TIMER_UNIT0_LOAD() uint32 {
	return volatile.LoadUint32(&o.UNIT0_LOAD.Reg) & 0x1
}

// SYSTIMER.UNIT1_LOAD: system timer unit1 conf sync register
func (o *SYSTIMER_Type) SetUNIT1_LOAD_TIMER_UNIT1_LOAD(value uint32) {
	volatile.StoreUint32(&o.UNIT1_LOAD.Reg, volatile.LoadUint32(&o.UNIT1_LOAD.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetUNIT1_LOAD_TIMER_UNIT1_LOAD() uint32 {
	return volatile.LoadUint32(&o.UNIT1_LOAD.Reg) & 0x1
}

// SYSTIMER.INT_ENA: systimer interrupt enable register
func (o *SYSTIMER_Type) SetINT_ENA_TARGET0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetINT_ENA_TARGET0_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *SYSTIMER_Type) SetINT_ENA_TARGET1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *SYSTIMER_Type) GetINT_ENA_TARGET1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *SYSTIMER_Type) SetINT_ENA_TARGET2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *SYSTIMER_Type) GetINT_ENA_TARGET2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}

// SYSTIMER.INT_RAW: systimer interrupt raw register
func (o *SYSTIMER_Type) SetINT_RAW_TARGET0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetINT_RAW_TARGET0_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *SYSTIMER_Type) SetINT_RAW_TARGET1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *SYSTIMER_Type) GetINT_RAW_TARGET1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *SYSTIMER_Type) SetINT_RAW_TARGET2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *SYSTIMER_Type) GetINT_RAW_TARGET2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}

// SYSTIMER.INT_CLR: systimer interrupt clear register
func (o *SYSTIMER_Type) SetINT_CLR_TARGET0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetINT_CLR_TARGET0_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *SYSTIMER_Type) SetINT_CLR_TARGET1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTIMER_Type) GetINT_CLR_TARGET1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *SYSTIMER_Type) SetINT_CLR_TARGET2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTIMER_Type) GetINT_CLR_TARGET2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}

// SYSTIMER.INT_ST: systimer interrupt status register
func (o *SYSTIMER_Type) SetINT_ST_TARGET0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetINT_ST_TARGET0_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *SYSTIMER_Type) SetINT_ST_TARGET1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *SYSTIMER_Type) GetINT_ST_TARGET1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *SYSTIMER_Type) SetINT_ST_TARGET2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *SYSTIMER_Type) GetINT_ST_TARGET2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}

// SYSTIMER.REAL_TARGET0_LO: system timer comp0 actual target value low register
func (o *SYSTIMER_Type) SetREAL_TARGET0_LO(value uint32) {
	volatile.StoreUint32(&o.REAL_TARGET0_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetREAL_TARGET0_LO() uint32 {
	return volatile.LoadUint32(&o.REAL_TARGET0_LO.Reg)
}

// SYSTIMER.REAL_TARGET0_HI: system timer comp0 actual target value high register
func (o *SYSTIMER_Type) SetREAL_TARGET0_HI_TARGET0_HI_RO(value uint32) {
	volatile.StoreUint32(&o.REAL_TARGET0_HI.Reg, volatile.LoadUint32(&o.REAL_TARGET0_HI.Reg)&^(0xfffff)|value)
}
func (o *SYSTIMER_Type) GetREAL_TARGET0_HI_TARGET0_HI_RO() uint32 {
	return volatile.LoadUint32(&o.REAL_TARGET0_HI.Reg) & 0xfffff
}

// SYSTIMER.REAL_TARGET1_LO: system timer comp1 actual target value low register
func (o *SYSTIMER_Type) SetREAL_TARGET1_LO(value uint32) {
	volatile.StoreUint32(&o.REAL_TARGET1_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetREAL_TARGET1_LO() uint32 {
	return volatile.LoadUint32(&o.REAL_TARGET1_LO.Reg)
}

// SYSTIMER.REAL_TARGET1_HI: system timer comp1 actual target value high register
func (o *SYSTIMER_Type) SetREAL_TARGET1_HI_TARGET1_HI_RO(value uint32) {
	volatile.StoreUint32(&o.REAL_TARGET1_HI.Reg, volatile.LoadUint32(&o.REAL_TARGET1_HI.Reg)&^(0xfffff)|value)
}
func (o *SYSTIMER_Type) GetREAL_TARGET1_HI_TARGET1_HI_RO() uint32 {
	return volatile.LoadUint32(&o.REAL_TARGET1_HI.Reg) & 0xfffff
}

// SYSTIMER.REAL_TARGET2_LO: system timer comp2 actual target value low register
func (o *SYSTIMER_Type) SetREAL_TARGET2_LO(value uint32) {
	volatile.StoreUint32(&o.REAL_TARGET2_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetREAL_TARGET2_LO() uint32 {
	return volatile.LoadUint32(&o.REAL_TARGET2_LO.Reg)
}

// SYSTIMER.REAL_TARGET2_HI: system timer comp2 actual target value high register
func (o *SYSTIMER_Type) SetREAL_TARGET2_HI_TARGET2_HI_RO(value uint32) {
	volatile.StoreUint32(&o.REAL_TARGET2_HI.Reg, volatile.LoadUint32(&o.REAL_TARGET2_HI.Reg)&^(0xfffff)|value)
}
func (o *SYSTIMER_Type) GetREAL_TARGET2_HI_TARGET2_HI_RO() uint32 {
	return volatile.LoadUint32(&o.REAL_TARGET2_HI.Reg) & 0xfffff
}

// SYSTIMER.DATE: system timer version control register
func (o *SYSTIMER_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *SYSTIMER_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// TEE Peripheral
type TEE_Type struct {
	M0_MODE_CTRL  volatile.Register32 // 0x0
	M1_MODE_CTRL  volatile.Register32 // 0x4
	M2_MODE_CTRL  volatile.Register32 // 0x8
	M3_MODE_CTRL  volatile.Register32 // 0xC
	M4_MODE_CTRL  volatile.Register32 // 0x10
	M5_MODE_CTRL  volatile.Register32 // 0x14
	M6_MODE_CTRL  volatile.Register32 // 0x18
	M7_MODE_CTRL  volatile.Register32 // 0x1C
	M8_MODE_CTRL  volatile.Register32 // 0x20
	M9_MODE_CTRL  volatile.Register32 // 0x24
	M10_MODE_CTRL volatile.Register32 // 0x28
	M11_MODE_CTRL volatile.Register32 // 0x2C
	M12_MODE_CTRL volatile.Register32 // 0x30
	M13_MODE_CTRL volatile.Register32 // 0x34
	M14_MODE_CTRL volatile.Register32 // 0x38
	M15_MODE_CTRL volatile.Register32 // 0x3C
	M16_MODE_CTRL volatile.Register32 // 0x40
	M17_MODE_CTRL volatile.Register32 // 0x44
	M18_MODE_CTRL volatile.Register32 // 0x48
	M19_MODE_CTRL volatile.Register32 // 0x4C
	M20_MODE_CTRL volatile.Register32 // 0x50
	M21_MODE_CTRL volatile.Register32 // 0x54
	M22_MODE_CTRL volatile.Register32 // 0x58
	M23_MODE_CTRL volatile.Register32 // 0x5C
	M24_MODE_CTRL volatile.Register32 // 0x60
	M25_MODE_CTRL volatile.Register32 // 0x64
	M26_MODE_CTRL volatile.Register32 // 0x68
	M27_MODE_CTRL volatile.Register32 // 0x6C
	M28_MODE_CTRL volatile.Register32 // 0x70
	M29_MODE_CTRL volatile.Register32 // 0x74
	M30_MODE_CTRL volatile.Register32 // 0x78
	M31_MODE_CTRL volatile.Register32 // 0x7C
	CLOCK_GATE    volatile.Register32 // 0x80
	_             [3960]byte
	DATE          volatile.Register32 // 0xFFC
}

// TEE.M0_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM0_MODE_CTRL_M0_MODE(value uint32) {
	volatile.StoreUint32(&o.M0_MODE_CTRL.Reg, volatile.LoadUint32(&o.M0_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM0_MODE_CTRL_M0_MODE() uint32 {
	return volatile.LoadUint32(&o.M0_MODE_CTRL.Reg) & 0x3
}

// TEE.M1_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM1_MODE_CTRL_M1_MODE(value uint32) {
	volatile.StoreUint32(&o.M1_MODE_CTRL.Reg, volatile.LoadUint32(&o.M1_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM1_MODE_CTRL_M1_MODE() uint32 {
	return volatile.LoadUint32(&o.M1_MODE_CTRL.Reg) & 0x3
}

// TEE.M2_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM2_MODE_CTRL_M2_MODE(value uint32) {
	volatile.StoreUint32(&o.M2_MODE_CTRL.Reg, volatile.LoadUint32(&o.M2_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM2_MODE_CTRL_M2_MODE() uint32 {
	return volatile.LoadUint32(&o.M2_MODE_CTRL.Reg) & 0x3
}

// TEE.M3_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM3_MODE_CTRL_M3_MODE(value uint32) {
	volatile.StoreUint32(&o.M3_MODE_CTRL.Reg, volatile.LoadUint32(&o.M3_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM3_MODE_CTRL_M3_MODE() uint32 {
	return volatile.LoadUint32(&o.M3_MODE_CTRL.Reg) & 0x3
}

// TEE.M4_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM4_MODE_CTRL_M4_MODE(value uint32) {
	volatile.StoreUint32(&o.M4_MODE_CTRL.Reg, volatile.LoadUint32(&o.M4_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM4_MODE_CTRL_M4_MODE() uint32 {
	return volatile.LoadUint32(&o.M4_MODE_CTRL.Reg) & 0x3
}

// TEE.M5_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM5_MODE_CTRL_M5_MODE(value uint32) {
	volatile.StoreUint32(&o.M5_MODE_CTRL.Reg, volatile.LoadUint32(&o.M5_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM5_MODE_CTRL_M5_MODE() uint32 {
	return volatile.LoadUint32(&o.M5_MODE_CTRL.Reg) & 0x3
}

// TEE.M6_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM6_MODE_CTRL_M6_MODE(value uint32) {
	volatile.StoreUint32(&o.M6_MODE_CTRL.Reg, volatile.LoadUint32(&o.M6_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM6_MODE_CTRL_M6_MODE() uint32 {
	return volatile.LoadUint32(&o.M6_MODE_CTRL.Reg) & 0x3
}

// TEE.M7_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM7_MODE_CTRL_M7_MODE(value uint32) {
	volatile.StoreUint32(&o.M7_MODE_CTRL.Reg, volatile.LoadUint32(&o.M7_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM7_MODE_CTRL_M7_MODE() uint32 {
	return volatile.LoadUint32(&o.M7_MODE_CTRL.Reg) & 0x3
}

// TEE.M8_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM8_MODE_CTRL_M8_MODE(value uint32) {
	volatile.StoreUint32(&o.M8_MODE_CTRL.Reg, volatile.LoadUint32(&o.M8_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM8_MODE_CTRL_M8_MODE() uint32 {
	return volatile.LoadUint32(&o.M8_MODE_CTRL.Reg) & 0x3
}

// TEE.M9_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM9_MODE_CTRL_M9_MODE(value uint32) {
	volatile.StoreUint32(&o.M9_MODE_CTRL.Reg, volatile.LoadUint32(&o.M9_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM9_MODE_CTRL_M9_MODE() uint32 {
	return volatile.LoadUint32(&o.M9_MODE_CTRL.Reg) & 0x3
}

// TEE.M10_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM10_MODE_CTRL_M10_MODE(value uint32) {
	volatile.StoreUint32(&o.M10_MODE_CTRL.Reg, volatile.LoadUint32(&o.M10_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM10_MODE_CTRL_M10_MODE() uint32 {
	return volatile.LoadUint32(&o.M10_MODE_CTRL.Reg) & 0x3
}

// TEE.M11_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM11_MODE_CTRL_M11_MODE(value uint32) {
	volatile.StoreUint32(&o.M11_MODE_CTRL.Reg, volatile.LoadUint32(&o.M11_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM11_MODE_CTRL_M11_MODE() uint32 {
	return volatile.LoadUint32(&o.M11_MODE_CTRL.Reg) & 0x3
}

// TEE.M12_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM12_MODE_CTRL_M12_MODE(value uint32) {
	volatile.StoreUint32(&o.M12_MODE_CTRL.Reg, volatile.LoadUint32(&o.M12_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM12_MODE_CTRL_M12_MODE() uint32 {
	return volatile.LoadUint32(&o.M12_MODE_CTRL.Reg) & 0x3
}

// TEE.M13_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM13_MODE_CTRL_M13_MODE(value uint32) {
	volatile.StoreUint32(&o.M13_MODE_CTRL.Reg, volatile.LoadUint32(&o.M13_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM13_MODE_CTRL_M13_MODE() uint32 {
	return volatile.LoadUint32(&o.M13_MODE_CTRL.Reg) & 0x3
}

// TEE.M14_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM14_MODE_CTRL_M14_MODE(value uint32) {
	volatile.StoreUint32(&o.M14_MODE_CTRL.Reg, volatile.LoadUint32(&o.M14_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM14_MODE_CTRL_M14_MODE() uint32 {
	return volatile.LoadUint32(&o.M14_MODE_CTRL.Reg) & 0x3
}

// TEE.M15_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM15_MODE_CTRL_M15_MODE(value uint32) {
	volatile.StoreUint32(&o.M15_MODE_CTRL.Reg, volatile.LoadUint32(&o.M15_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM15_MODE_CTRL_M15_MODE() uint32 {
	return volatile.LoadUint32(&o.M15_MODE_CTRL.Reg) & 0x3
}

// TEE.M16_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM16_MODE_CTRL_M16_MODE(value uint32) {
	volatile.StoreUint32(&o.M16_MODE_CTRL.Reg, volatile.LoadUint32(&o.M16_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM16_MODE_CTRL_M16_MODE() uint32 {
	return volatile.LoadUint32(&o.M16_MODE_CTRL.Reg) & 0x3
}

// TEE.M17_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM17_MODE_CTRL_M17_MODE(value uint32) {
	volatile.StoreUint32(&o.M17_MODE_CTRL.Reg, volatile.LoadUint32(&o.M17_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM17_MODE_CTRL_M17_MODE() uint32 {
	return volatile.LoadUint32(&o.M17_MODE_CTRL.Reg) & 0x3
}

// TEE.M18_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM18_MODE_CTRL_M18_MODE(value uint32) {
	volatile.StoreUint32(&o.M18_MODE_CTRL.Reg, volatile.LoadUint32(&o.M18_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM18_MODE_CTRL_M18_MODE() uint32 {
	return volatile.LoadUint32(&o.M18_MODE_CTRL.Reg) & 0x3
}

// TEE.M19_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM19_MODE_CTRL_M19_MODE(value uint32) {
	volatile.StoreUint32(&o.M19_MODE_CTRL.Reg, volatile.LoadUint32(&o.M19_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM19_MODE_CTRL_M19_MODE() uint32 {
	return volatile.LoadUint32(&o.M19_MODE_CTRL.Reg) & 0x3
}

// TEE.M20_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM20_MODE_CTRL_M20_MODE(value uint32) {
	volatile.StoreUint32(&o.M20_MODE_CTRL.Reg, volatile.LoadUint32(&o.M20_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM20_MODE_CTRL_M20_MODE() uint32 {
	return volatile.LoadUint32(&o.M20_MODE_CTRL.Reg) & 0x3
}

// TEE.M21_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM21_MODE_CTRL_M21_MODE(value uint32) {
	volatile.StoreUint32(&o.M21_MODE_CTRL.Reg, volatile.LoadUint32(&o.M21_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM21_MODE_CTRL_M21_MODE() uint32 {
	return volatile.LoadUint32(&o.M21_MODE_CTRL.Reg) & 0x3
}

// TEE.M22_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM22_MODE_CTRL_M22_MODE(value uint32) {
	volatile.StoreUint32(&o.M22_MODE_CTRL.Reg, volatile.LoadUint32(&o.M22_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM22_MODE_CTRL_M22_MODE() uint32 {
	return volatile.LoadUint32(&o.M22_MODE_CTRL.Reg) & 0x3
}

// TEE.M23_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM23_MODE_CTRL_M23_MODE(value uint32) {
	volatile.StoreUint32(&o.M23_MODE_CTRL.Reg, volatile.LoadUint32(&o.M23_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM23_MODE_CTRL_M23_MODE() uint32 {
	return volatile.LoadUint32(&o.M23_MODE_CTRL.Reg) & 0x3
}

// TEE.M24_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM24_MODE_CTRL_M24_MODE(value uint32) {
	volatile.StoreUint32(&o.M24_MODE_CTRL.Reg, volatile.LoadUint32(&o.M24_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM24_MODE_CTRL_M24_MODE() uint32 {
	return volatile.LoadUint32(&o.M24_MODE_CTRL.Reg) & 0x3
}

// TEE.M25_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM25_MODE_CTRL_M25_MODE(value uint32) {
	volatile.StoreUint32(&o.M25_MODE_CTRL.Reg, volatile.LoadUint32(&o.M25_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM25_MODE_CTRL_M25_MODE() uint32 {
	return volatile.LoadUint32(&o.M25_MODE_CTRL.Reg) & 0x3
}

// TEE.M26_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM26_MODE_CTRL_M26_MODE(value uint32) {
	volatile.StoreUint32(&o.M26_MODE_CTRL.Reg, volatile.LoadUint32(&o.M26_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM26_MODE_CTRL_M26_MODE() uint32 {
	return volatile.LoadUint32(&o.M26_MODE_CTRL.Reg) & 0x3
}

// TEE.M27_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM27_MODE_CTRL_M27_MODE(value uint32) {
	volatile.StoreUint32(&o.M27_MODE_CTRL.Reg, volatile.LoadUint32(&o.M27_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM27_MODE_CTRL_M27_MODE() uint32 {
	return volatile.LoadUint32(&o.M27_MODE_CTRL.Reg) & 0x3
}

// TEE.M28_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM28_MODE_CTRL_M28_MODE(value uint32) {
	volatile.StoreUint32(&o.M28_MODE_CTRL.Reg, volatile.LoadUint32(&o.M28_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM28_MODE_CTRL_M28_MODE() uint32 {
	return volatile.LoadUint32(&o.M28_MODE_CTRL.Reg) & 0x3
}

// TEE.M29_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM29_MODE_CTRL_M29_MODE(value uint32) {
	volatile.StoreUint32(&o.M29_MODE_CTRL.Reg, volatile.LoadUint32(&o.M29_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM29_MODE_CTRL_M29_MODE() uint32 {
	return volatile.LoadUint32(&o.M29_MODE_CTRL.Reg) & 0x3
}

// TEE.M30_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM30_MODE_CTRL_M30_MODE(value uint32) {
	volatile.StoreUint32(&o.M30_MODE_CTRL.Reg, volatile.LoadUint32(&o.M30_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM30_MODE_CTRL_M30_MODE() uint32 {
	return volatile.LoadUint32(&o.M30_MODE_CTRL.Reg) & 0x3
}

// TEE.M31_MODE_CTRL: Tee mode control register
func (o *TEE_Type) SetM31_MODE_CTRL_M31_MODE(value uint32) {
	volatile.StoreUint32(&o.M31_MODE_CTRL.Reg, volatile.LoadUint32(&o.M31_MODE_CTRL.Reg)&^(0x3)|value)
}
func (o *TEE_Type) GetM31_MODE_CTRL_M31_MODE() uint32 {
	return volatile.LoadUint32(&o.M31_MODE_CTRL.Reg) & 0x3
}

// TEE.CLOCK_GATE: Clock gating register
func (o *TEE_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *TEE_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// TEE.DATE: Version register
func (o *TEE_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *TEE_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// Timer Group 0
type TIMG_Type struct {
	T0CONFIG       volatile.Register32 // 0x0
	T0LO           volatile.Register32 // 0x4
	T0HI           volatile.Register32 // 0x8
	T0UPDATE       volatile.Register32 // 0xC
	T0ALARMLO      volatile.Register32 // 0x10
	T0ALARMHI      volatile.Register32 // 0x14
	T0LOADLO       volatile.Register32 // 0x18
	T0LOADHI       volatile.Register32 // 0x1C
	T0LOAD         volatile.Register32 // 0x20
	_              [36]byte
	WDTCONFIG0     volatile.Register32 // 0x48
	WDTCONFIG1     volatile.Register32 // 0x4C
	WDTCONFIG2     volatile.Register32 // 0x50
	WDTCONFIG3     volatile.Register32 // 0x54
	WDTCONFIG4     volatile.Register32 // 0x58
	WDTCONFIG5     volatile.Register32 // 0x5C
	WDTFEED        volatile.Register32 // 0x60
	WDTWPROTECT    volatile.Register32 // 0x64
	RTCCALICFG     volatile.Register32 // 0x68
	RTCCALICFG1    volatile.Register32 // 0x6C
	INT_ENA_TIMERS volatile.Register32 // 0x70
	INT_RAW_TIMERS volatile.Register32 // 0x74
	INT_ST_TIMERS  volatile.Register32 // 0x78
	INT_CLR_TIMERS volatile.Register32 // 0x7C
	RTCCALICFG2    volatile.Register32 // 0x80
	_              [116]byte
	NTIMERS_DATE   volatile.Register32 // 0xF8
	REGCLK         volatile.Register32 // 0xFC
}

// TIMG.T0CONFIG: Timer %s configuration register
func (o *TIMG_Type) SetT0CONFIG_USE_XTAL(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x200)|value<<9)
}
func (o *TIMG_Type) GetT0CONFIG_USE_XTAL() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x200) >> 9
}
func (o *TIMG_Type) SetT0CONFIG_ALARM_EN(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x400)|value<<10)
}
func (o *TIMG_Type) GetT0CONFIG_ALARM_EN() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x400) >> 10
}
func (o *TIMG_Type) SetT0CONFIG_DIVCNT_RST(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x1000)|value<<12)
}
func (o *TIMG_Type) GetT0CONFIG_DIVCNT_RST() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x1000) >> 12
}
func (o *TIMG_Type) SetT0CONFIG_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x1fffe000)|value<<13)
}
func (o *TIMG_Type) GetT0CONFIG_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x1fffe000) >> 13
}
func (o *TIMG_Type) SetT0CONFIG_AUTORELOAD(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x20000000)|value<<29)
}
func (o *TIMG_Type) GetT0CONFIG_AUTORELOAD() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x20000000) >> 29
}
func (o *TIMG_Type) SetT0CONFIG_INCREASE(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x40000000)|value<<30)
}
func (o *TIMG_Type) GetT0CONFIG_INCREASE() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x40000000) >> 30
}
func (o *TIMG_Type) SetT0CONFIG_EN(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG_Type) GetT0CONFIG_EN() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x80000000) >> 31
}

// TIMG.T0LO: Timer %s current value, low 32 bits
func (o *TIMG_Type) SetT0LO(value uint32) {
	volatile.StoreUint32(&o.T0LO.Reg, value)
}
func (o *TIMG_Type) GetT0LO() uint32 {
	return volatile.LoadUint32(&o.T0LO.Reg)
}

// TIMG.T0HI: Timer %s current value, high 22 bits
func (o *TIMG_Type) SetT0HI_HI(value uint32) {
	volatile.StoreUint32(&o.T0HI.Reg, volatile.LoadUint32(&o.T0HI.Reg)&^(0x3fffff)|value)
}
func (o *TIMG_Type) GetT0HI_HI() uint32 {
	return volatile.LoadUint32(&o.T0HI.Reg) & 0x3fffff
}

// TIMG.T0UPDATE: Write to copy current timer value to TIMGn_T%s_(LO/HI)_REG
func (o *TIMG_Type) SetT0UPDATE_UPDATE(value uint32) {
	volatile.StoreUint32(&o.T0UPDATE.Reg, volatile.LoadUint32(&o.T0UPDATE.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG_Type) GetT0UPDATE_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.T0UPDATE.Reg) & 0x80000000) >> 31
}

// TIMG.T0ALARMLO: Timer %s alarm value, low 32 bits
func (o *TIMG_Type) SetT0ALARMLO(value uint32) {
	volatile.StoreUint32(&o.T0ALARMLO.Reg, value)
}
func (o *TIMG_Type) GetT0ALARMLO() uint32 {
	return volatile.LoadUint32(&o.T0ALARMLO.Reg)
}

// TIMG.T0ALARMHI: Timer %s alarm value, high bits
func (o *TIMG_Type) SetT0ALARMHI_ALARM_HI(value uint32) {
	volatile.StoreUint32(&o.T0ALARMHI.Reg, volatile.LoadUint32(&o.T0ALARMHI.Reg)&^(0x3fffff)|value)
}
func (o *TIMG_Type) GetT0ALARMHI_ALARM_HI() uint32 {
	return volatile.LoadUint32(&o.T0ALARMHI.Reg) & 0x3fffff
}

// TIMG.T0LOADLO: Timer %s reload value, low 32 bits
func (o *TIMG_Type) SetT0LOADLO(value uint32) {
	volatile.StoreUint32(&o.T0LOADLO.Reg, value)
}
func (o *TIMG_Type) GetT0LOADLO() uint32 {
	return volatile.LoadUint32(&o.T0LOADLO.Reg)
}

// TIMG.T0LOADHI: Timer %s reload value, high 22 bits
func (o *TIMG_Type) SetT0LOADHI_LOAD_HI(value uint32) {
	volatile.StoreUint32(&o.T0LOADHI.Reg, volatile.LoadUint32(&o.T0LOADHI.Reg)&^(0x3fffff)|value)
}
func (o *TIMG_Type) GetT0LOADHI_LOAD_HI() uint32 {
	return volatile.LoadUint32(&o.T0LOADHI.Reg) & 0x3fffff
}

// TIMG.T0LOAD: Write to reload timer from TIMG_T%s_(LOADLOLOADHI)_REG
func (o *TIMG_Type) SetT0LOAD(value uint32) {
	volatile.StoreUint32(&o.T0LOAD.Reg, value)
}
func (o *TIMG_Type) GetT0LOAD() uint32 {
	return volatile.LoadUint32(&o.T0LOAD.Reg)
}

// TIMG.WDTCONFIG0: Watchdog timer configuration register
func (o *TIMG_Type) SetWDTCONFIG0_WDT_APPCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1000)|value<<12)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_APPCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1000) >> 12
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_PROCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x2000)|value<<13)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_PROCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x2000) >> 13
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x4000)|value<<14)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x4000) >> 14
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_SYS_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x38000)|value<<15)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_SYS_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x38000) >> 15
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_CPU_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1c0000)|value<<18)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_CPU_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1c0000) >> 18
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_USE_XTAL(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x200000)|value<<21)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_USE_XTAL() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x200000) >> 21
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_CONF_UPDATE_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x400000)|value<<22)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_CONF_UPDATE_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x400000) >> 22
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_STG3(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1800000)|value<<23)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_STG3() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1800000) >> 23
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_STG2(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x6000000)|value<<25)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_STG2() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x6000000) >> 25
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_STG1(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x18000000)|value<<27)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_STG1() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x18000000) >> 27
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_STG0(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x60000000)|value<<29)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_STG0() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x60000000) >> 29
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x80000000) >> 31
}

// TIMG.WDTCONFIG1: Watchdog timer prescaler register
func (o *TIMG_Type) SetWDTCONFIG1_WDT_DIVCNT_RST(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG1.Reg, volatile.LoadUint32(&o.WDTCONFIG1.Reg)&^(0x1)|value)
}
func (o *TIMG_Type) GetWDTCONFIG1_WDT_DIVCNT_RST() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG1.Reg) & 0x1
}
func (o *TIMG_Type) SetWDTCONFIG1_WDT_CLK_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG1.Reg, volatile.LoadUint32(&o.WDTCONFIG1.Reg)&^(0xffff0000)|value<<16)
}
func (o *TIMG_Type) GetWDTCONFIG1_WDT_CLK_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG1.Reg) & 0xffff0000) >> 16
}

// TIMG.WDTCONFIG2: Watchdog timer stage 0 timeout value
func (o *TIMG_Type) SetWDTCONFIG2(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG2.Reg, value)
}
func (o *TIMG_Type) GetWDTCONFIG2() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG2.Reg)
}

// TIMG.WDTCONFIG3: Watchdog timer stage 1 timeout value
func (o *TIMG_Type) SetWDTCONFIG3(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG3.Reg, value)
}
func (o *TIMG_Type) GetWDTCONFIG3() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG3.Reg)
}

// TIMG.WDTCONFIG4: Watchdog timer stage 2 timeout value
func (o *TIMG_Type) SetWDTCONFIG4(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG4.Reg, value)
}
func (o *TIMG_Type) GetWDTCONFIG4() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG4.Reg)
}

// TIMG.WDTCONFIG5: Watchdog timer stage 3 timeout value
func (o *TIMG_Type) SetWDTCONFIG5(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG5.Reg, value)
}
func (o *TIMG_Type) GetWDTCONFIG5() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG5.Reg)
}

// TIMG.WDTFEED: Write to feed the watchdog timer
func (o *TIMG_Type) SetWDTFEED(value uint32) {
	volatile.StoreUint32(&o.WDTFEED.Reg, value)
}
func (o *TIMG_Type) GetWDTFEED() uint32 {
	return volatile.LoadUint32(&o.WDTFEED.Reg)
}

// TIMG.WDTWPROTECT: Watchdog write protect register
func (o *TIMG_Type) SetWDTWPROTECT(value uint32) {
	volatile.StoreUint32(&o.WDTWPROTECT.Reg, value)
}
func (o *TIMG_Type) GetWDTWPROTECT() uint32 {
	return volatile.LoadUint32(&o.WDTWPROTECT.Reg)
}

// TIMG.RTCCALICFG: RTC calibration configure register
func (o *TIMG_Type) SetRTCCALICFG_RTC_CALI_START_CYCLING(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x1000)|value<<12)
}
func (o *TIMG_Type) GetRTCCALICFG_RTC_CALI_START_CYCLING() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x1000) >> 12
}
func (o *TIMG_Type) SetRTCCALICFG_RTC_CALI_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x6000)|value<<13)
}
func (o *TIMG_Type) GetRTCCALICFG_RTC_CALI_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x6000) >> 13
}
func (o *TIMG_Type) SetRTCCALICFG_RTC_CALI_RDY(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x8000)|value<<15)
}
func (o *TIMG_Type) GetRTCCALICFG_RTC_CALI_RDY() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x8000) >> 15
}
func (o *TIMG_Type) SetRTCCALICFG_RTC_CALI_MAX(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x7fff0000)|value<<16)
}
func (o *TIMG_Type) GetRTCCALICFG_RTC_CALI_MAX() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x7fff0000) >> 16
}
func (o *TIMG_Type) SetRTCCALICFG_RTC_CALI_START(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG_Type) GetRTCCALICFG_RTC_CALI_START() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x80000000) >> 31
}

// TIMG.RTCCALICFG1: RTC calibration configure1 register
func (o *TIMG_Type) SetRTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG1.Reg, volatile.LoadUint32(&o.RTCCALICFG1.Reg)&^(0x1)|value)
}
func (o *TIMG_Type) GetRTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD() uint32 {
	return volatile.LoadUint32(&o.RTCCALICFG1.Reg) & 0x1
}
func (o *TIMG_Type) SetRTCCALICFG1_RTC_CALI_VALUE(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG1.Reg, volatile.LoadUint32(&o.RTCCALICFG1.Reg)&^(0xffffff80)|value<<7)
}
func (o *TIMG_Type) GetRTCCALICFG1_RTC_CALI_VALUE() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG1.Reg) & 0xffffff80) >> 7
}

// TIMG.INT_ENA_TIMERS: Interrupt enable bits
func (o *TIMG_Type) SetINT_ENA_TIMERS_T0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_TIMERS.Reg, volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg)&^(0x1)|value)
}
func (o *TIMG_Type) GetINT_ENA_TIMERS_T0_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg) & 0x1
}
func (o *TIMG_Type) SetINT_ENA_TIMERS_WDT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_TIMERS.Reg, volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg)&^(0x2)|value<<1)
}
func (o *TIMG_Type) GetINT_ENA_TIMERS_WDT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg) & 0x2) >> 1
}

// TIMG.INT_RAW_TIMERS: Raw interrupt status
func (o *TIMG_Type) SetINT_RAW_TIMERS_T0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_TIMERS.Reg, volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg)&^(0x1)|value)
}
func (o *TIMG_Type) GetINT_RAW_TIMERS_T0_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg) & 0x1
}
func (o *TIMG_Type) SetINT_RAW_TIMERS_WDT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_TIMERS.Reg, volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg)&^(0x2)|value<<1)
}
func (o *TIMG_Type) GetINT_RAW_TIMERS_WDT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg) & 0x2) >> 1
}

// TIMG.INT_ST_TIMERS: Masked interrupt status
func (o *TIMG_Type) SetINT_ST_TIMERS_T0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_TIMERS.Reg, volatile.LoadUint32(&o.INT_ST_TIMERS.Reg)&^(0x1)|value)
}
func (o *TIMG_Type) GetINT_ST_TIMERS_T0_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST_TIMERS.Reg) & 0x1
}
func (o *TIMG_Type) SetINT_ST_TIMERS_WDT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_TIMERS.Reg, volatile.LoadUint32(&o.INT_ST_TIMERS.Reg)&^(0x2)|value<<1)
}
func (o *TIMG_Type) GetINT_ST_TIMERS_WDT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_TIMERS.Reg) & 0x2) >> 1
}

// TIMG.INT_CLR_TIMERS: Interrupt clear bits
func (o *TIMG_Type) SetINT_CLR_TIMERS_T0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_TIMERS.Reg, volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg)&^(0x1)|value)
}
func (o *TIMG_Type) GetINT_CLR_TIMERS_T0_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg) & 0x1
}
func (o *TIMG_Type) SetINT_CLR_TIMERS_WDT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_TIMERS.Reg, volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg)&^(0x2)|value<<1)
}
func (o *TIMG_Type) GetINT_CLR_TIMERS_WDT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg) & 0x2) >> 1
}

// TIMG.RTCCALICFG2: Timer group calibration register
func (o *TIMG_Type) SetRTCCALICFG2_RTC_CALI_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG2.Reg, volatile.LoadUint32(&o.RTCCALICFG2.Reg)&^(0x1)|value)
}
func (o *TIMG_Type) GetRTCCALICFG2_RTC_CALI_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.RTCCALICFG2.Reg) & 0x1
}
func (o *TIMG_Type) SetRTCCALICFG2_RTC_CALI_TIMEOUT_RST_CNT(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG2.Reg, volatile.LoadUint32(&o.RTCCALICFG2.Reg)&^(0x78)|value<<3)
}
func (o *TIMG_Type) GetRTCCALICFG2_RTC_CALI_TIMEOUT_RST_CNT() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG2.Reg) & 0x78) >> 3
}
func (o *TIMG_Type) SetRTCCALICFG2_RTC_CALI_TIMEOUT_THRES(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG2.Reg, volatile.LoadUint32(&o.RTCCALICFG2.Reg)&^(0xffffff80)|value<<7)
}
func (o *TIMG_Type) GetRTCCALICFG2_RTC_CALI_TIMEOUT_THRES() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG2.Reg) & 0xffffff80) >> 7
}

// TIMG.NTIMERS_DATE: Timer version control register
func (o *TIMG_Type) SetNTIMERS_DATE_NTIMGS_DATE(value uint32) {
	volatile.StoreUint32(&o.NTIMERS_DATE.Reg, volatile.LoadUint32(&o.NTIMERS_DATE.Reg)&^(0xfffffff)|value)
}
func (o *TIMG_Type) GetNTIMERS_DATE_NTIMGS_DATE() uint32 {
	return volatile.LoadUint32(&o.NTIMERS_DATE.Reg) & 0xfffffff
}

// TIMG.REGCLK: Timer group clock gate register
func (o *TIMG_Type) SetREGCLK_ETM_EN(value uint32) {
	volatile.StoreUint32(&o.REGCLK.Reg, volatile.LoadUint32(&o.REGCLK.Reg)&^(0x10000000)|value<<28)
}
func (o *TIMG_Type) GetREGCLK_ETM_EN() uint32 {
	return (volatile.LoadUint32(&o.REGCLK.Reg) & 0x10000000) >> 28
}
func (o *TIMG_Type) SetREGCLK_WDT_CLK_IS_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.REGCLK.Reg, volatile.LoadUint32(&o.REGCLK.Reg)&^(0x20000000)|value<<29)
}
func (o *TIMG_Type) GetREGCLK_WDT_CLK_IS_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.REGCLK.Reg) & 0x20000000) >> 29
}
func (o *TIMG_Type) SetREGCLK_TIMER_CLK_IS_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.REGCLK.Reg, volatile.LoadUint32(&o.REGCLK.Reg)&^(0x40000000)|value<<30)
}
func (o *TIMG_Type) GetREGCLK_TIMER_CLK_IS_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.REGCLK.Reg) & 0x40000000) >> 30
}
func (o *TIMG_Type) SetREGCLK_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.REGCLK.Reg, volatile.LoadUint32(&o.REGCLK.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG_Type) GetREGCLK_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.REGCLK.Reg) & 0x80000000) >> 31
}

// RISC-V Trace Encoder
type TRACE_Type struct {
	MEM_START_ADDR   volatile.Register32 // 0x0
	MEM_END_ADDR     volatile.Register32 // 0x4
	MEM_CURRENT_ADDR volatile.Register32 // 0x8
	MEM_ADDR_UPDATE  volatile.Register32 // 0xC
	FIFO_STATUS      volatile.Register32 // 0x10
	INTR_ENA         volatile.Register32 // 0x14
	INTR_RAW         volatile.Register32 // 0x18
	INTR_CLR         volatile.Register32 // 0x1C
	TRIGGER          volatile.Register32 // 0x20
	RESYNC_PROLONGED volatile.Register32 // 0x24
	CLOCK_GATE       volatile.Register32 // 0x28
	_                [976]byte
	DATE             volatile.Register32 // 0x3FC
}

// TRACE.MEM_START_ADDR: mem start addr
func (o *TRACE_Type) SetMEM_START_ADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_START_ADDR.Reg, value)
}
func (o *TRACE_Type) GetMEM_START_ADDR() uint32 {
	return volatile.LoadUint32(&o.MEM_START_ADDR.Reg)
}

// TRACE.MEM_END_ADDR: mem end addr
func (o *TRACE_Type) SetMEM_END_ADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_END_ADDR.Reg, value)
}
func (o *TRACE_Type) GetMEM_END_ADDR() uint32 {
	return volatile.LoadUint32(&o.MEM_END_ADDR.Reg)
}

// TRACE.MEM_CURRENT_ADDR: mem current addr
func (o *TRACE_Type) SetMEM_CURRENT_ADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_CURRENT_ADDR.Reg, value)
}
func (o *TRACE_Type) GetMEM_CURRENT_ADDR() uint32 {
	return volatile.LoadUint32(&o.MEM_CURRENT_ADDR.Reg)
}

// TRACE.MEM_ADDR_UPDATE: mem addr update
func (o *TRACE_Type) SetMEM_ADDR_UPDATE_MEM_CURRENT_ADDR_UPDATE(value uint32) {
	volatile.StoreUint32(&o.MEM_ADDR_UPDATE.Reg, volatile.LoadUint32(&o.MEM_ADDR_UPDATE.Reg)&^(0x1)|value)
}
func (o *TRACE_Type) GetMEM_ADDR_UPDATE_MEM_CURRENT_ADDR_UPDATE() uint32 {
	return volatile.LoadUint32(&o.MEM_ADDR_UPDATE.Reg) & 0x1
}

// TRACE.FIFO_STATUS: fifo status register
func (o *TRACE_Type) SetFIFO_STATUS_FIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.FIFO_STATUS.Reg, volatile.LoadUint32(&o.FIFO_STATUS.Reg)&^(0x1)|value)
}
func (o *TRACE_Type) GetFIFO_STATUS_FIFO_EMPTY() uint32 {
	return volatile.LoadUint32(&o.FIFO_STATUS.Reg) & 0x1
}
func (o *TRACE_Type) SetFIFO_STATUS_WORK_STATUS(value uint32) {
	volatile.StoreUint32(&o.FIFO_STATUS.Reg, volatile.LoadUint32(&o.FIFO_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *TRACE_Type) GetFIFO_STATUS_WORK_STATUS() uint32 {
	return (volatile.LoadUint32(&o.FIFO_STATUS.Reg) & 0x2) >> 1
}

// TRACE.INTR_ENA: interrupt enable register
func (o *TRACE_Type) SetINTR_ENA_FIFO_OVERFLOW_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_ENA.Reg, volatile.LoadUint32(&o.INTR_ENA.Reg)&^(0x1)|value)
}
func (o *TRACE_Type) GetINTR_ENA_FIFO_OVERFLOW_INTR_ENA() uint32 {
	return volatile.LoadUint32(&o.INTR_ENA.Reg) & 0x1
}
func (o *TRACE_Type) SetINTR_ENA_MEM_FULL_INTR_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_ENA.Reg, volatile.LoadUint32(&o.INTR_ENA.Reg)&^(0x2)|value<<1)
}
func (o *TRACE_Type) GetINTR_ENA_MEM_FULL_INTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_ENA.Reg) & 0x2) >> 1
}

// TRACE.INTR_RAW: interrupt status register
func (o *TRACE_Type) SetINTR_RAW_FIFO_OVERFLOW_INTR_RAW(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x1)|value)
}
func (o *TRACE_Type) GetINTR_RAW_FIFO_OVERFLOW_INTR_RAW() uint32 {
	return volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x1
}
func (o *TRACE_Type) SetINTR_RAW_MEM_FULL_INTR_RAW(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x2)|value<<1)
}
func (o *TRACE_Type) GetINTR_RAW_MEM_FULL_INTR_RAW() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x2) >> 1
}

// TRACE.INTR_CLR: interrupt clear register
func (o *TRACE_Type) SetINTR_CLR_FIFO_OVERFLOW_INTR_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x1)|value)
}
func (o *TRACE_Type) GetINTR_CLR_FIFO_OVERFLOW_INTR_CLR() uint32 {
	return volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x1
}
func (o *TRACE_Type) SetINTR_CLR_MEM_FULL_INTR_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x2)|value<<1)
}
func (o *TRACE_Type) GetINTR_CLR_MEM_FULL_INTR_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x2) >> 1
}

// TRACE.TRIGGER: trigger register
func (o *TRACE_Type) SetTRIGGER_ON(value uint32) {
	volatile.StoreUint32(&o.TRIGGER.Reg, volatile.LoadUint32(&o.TRIGGER.Reg)&^(0x1)|value)
}
func (o *TRACE_Type) GetTRIGGER_ON() uint32 {
	return volatile.LoadUint32(&o.TRIGGER.Reg) & 0x1
}
func (o *TRACE_Type) SetTRIGGER_OFF(value uint32) {
	volatile.StoreUint32(&o.TRIGGER.Reg, volatile.LoadUint32(&o.TRIGGER.Reg)&^(0x2)|value<<1)
}
func (o *TRACE_Type) GetTRIGGER_OFF() uint32 {
	return (volatile.LoadUint32(&o.TRIGGER.Reg) & 0x2) >> 1
}
func (o *TRACE_Type) SetTRIGGER_MEM_LOOP(value uint32) {
	volatile.StoreUint32(&o.TRIGGER.Reg, volatile.LoadUint32(&o.TRIGGER.Reg)&^(0x4)|value<<2)
}
func (o *TRACE_Type) GetTRIGGER_MEM_LOOP() uint32 {
	return (volatile.LoadUint32(&o.TRIGGER.Reg) & 0x4) >> 2
}
func (o *TRACE_Type) SetTRIGGER_RESTART_ENA(value uint32) {
	volatile.StoreUint32(&o.TRIGGER.Reg, volatile.LoadUint32(&o.TRIGGER.Reg)&^(0x8)|value<<3)
}
func (o *TRACE_Type) GetTRIGGER_RESTART_ENA() uint32 {
	return (volatile.LoadUint32(&o.TRIGGER.Reg) & 0x8) >> 3
}

// TRACE.RESYNC_PROLONGED: resync configuration register
func (o *TRACE_Type) SetRESYNC_PROLONGED(value uint32) {
	volatile.StoreUint32(&o.RESYNC_PROLONGED.Reg, volatile.LoadUint32(&o.RESYNC_PROLONGED.Reg)&^(0xffffff)|value)
}
func (o *TRACE_Type) GetRESYNC_PROLONGED() uint32 {
	return volatile.LoadUint32(&o.RESYNC_PROLONGED.Reg) & 0xffffff
}
func (o *TRACE_Type) SetRESYNC_PROLONGED_RESYNC_MODE(value uint32) {
	volatile.StoreUint32(&o.RESYNC_PROLONGED.Reg, volatile.LoadUint32(&o.RESYNC_PROLONGED.Reg)&^(0x1000000)|value<<24)
}
func (o *TRACE_Type) GetRESYNC_PROLONGED_RESYNC_MODE() uint32 {
	return (volatile.LoadUint32(&o.RESYNC_PROLONGED.Reg) & 0x1000000) >> 24
}

// TRACE.CLOCK_GATE: Clock gate control register
func (o *TRACE_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *TRACE_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// TRACE.DATE: Version control register
func (o *TRACE_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *TRACE_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// Two-Wire Automotive Interface
type TWAI_Type struct {
	MODE               volatile.Register32 // 0x0
	CMD                volatile.Register32 // 0x4
	STATUS             volatile.Register32 // 0x8
	INTERRUPT          volatile.Register32 // 0xC
	INTERRUPT_ENABLE   volatile.Register32 // 0x10
	_                  [4]byte
	BUS_TIMING_0       volatile.Register32 // 0x18
	BUS_TIMING_1       volatile.Register32 // 0x1C
	_                  [12]byte
	ARB_LOST_CAP       volatile.Register32 // 0x2C
	ERR_CODE_CAP       volatile.Register32 // 0x30
	ERR_WARNING_LIMIT  volatile.Register32 // 0x34
	RX_ERR_CNT         volatile.Register32 // 0x38
	TX_ERR_CNT         volatile.Register32 // 0x3C
	DATA_0             volatile.Register32 // 0x40
	DATA_1             volatile.Register32 // 0x44
	DATA_2             volatile.Register32 // 0x48
	DATA_3             volatile.Register32 // 0x4C
	DATA_4             volatile.Register32 // 0x50
	DATA_5             volatile.Register32 // 0x54
	DATA_6             volatile.Register32 // 0x58
	DATA_7             volatile.Register32 // 0x5C
	DATA_8             volatile.Register32 // 0x60
	DATA_9             volatile.Register32 // 0x64
	DATA_10            volatile.Register32 // 0x68
	DATA_11            volatile.Register32 // 0x6C
	DATA_12            volatile.Register32 // 0x70
	RX_MESSAGE_COUNTER volatile.Register32 // 0x74
	_                  [4]byte
	CLOCK_DIVIDER      volatile.Register32 // 0x7C
	SW_STANDBY_CFG     volatile.Register32 // 0x80
	HW_CFG             volatile.Register32 // 0x84
	HW_STANDBY_CNT     volatile.Register32 // 0x88
	IDLE_INTR_CNT      volatile.Register32 // 0x8C
	ECO_CFG            volatile.Register32 // 0x90
}

// TWAI.MODE: TWAI mode register.
func (o *TWAI_Type) SetMODE_RESET_MODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1)|value)
}
func (o *TWAI_Type) GetMODE_RESET_MODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x1
}
func (o *TWAI_Type) SetMODE_LISTEN_ONLY_MODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x2)|value<<1)
}
func (o *TWAI_Type) GetMODE_LISTEN_ONLY_MODE() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x2) >> 1
}
func (o *TWAI_Type) SetMODE_SELF_TEST_MODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x4)|value<<2)
}
func (o *TWAI_Type) GetMODE_SELF_TEST_MODE() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x4) >> 2
}
func (o *TWAI_Type) SetMODE_ACCEPTANCE_FILTER_MODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x8)|value<<3)
}
func (o *TWAI_Type) GetMODE_ACCEPTANCE_FILTER_MODE() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x8) >> 3
}

// TWAI.CMD: TWAI command register.
func (o *TWAI_Type) SetCMD_TX_REQUEST(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x1)|value)
}
func (o *TWAI_Type) GetCMD_TX_REQUEST() uint32 {
	return volatile.LoadUint32(&o.CMD.Reg) & 0x1
}
func (o *TWAI_Type) SetCMD_ABORT_TX(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x2)|value<<1)
}
func (o *TWAI_Type) GetCMD_ABORT_TX() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x2) >> 1
}
func (o *TWAI_Type) SetCMD_RELEASE_BUFFER(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x4)|value<<2)
}
func (o *TWAI_Type) GetCMD_RELEASE_BUFFER() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x4) >> 2
}
func (o *TWAI_Type) SetCMD_CLEAR_DATA_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x8)|value<<3)
}
func (o *TWAI_Type) GetCMD_CLEAR_DATA_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x8) >> 3
}
func (o *TWAI_Type) SetCMD_SELF_RX_REQUEST(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x10)|value<<4)
}
func (o *TWAI_Type) GetCMD_SELF_RX_REQUEST() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x10) >> 4
}

// TWAI.STATUS: TWAI status register.
func (o *TWAI_Type) SetSTATUS_RECEIVE_BUFFER(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *TWAI_Type) GetSTATUS_RECEIVE_BUFFER() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *TWAI_Type) SetSTATUS_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *TWAI_Type) GetSTATUS_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *TWAI_Type) SetSTATUS_TRANSMIT_BUFFER(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *TWAI_Type) GetSTATUS_TRANSMIT_BUFFER() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *TWAI_Type) SetSTATUS_TRANSMISSION_COMPLETE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *TWAI_Type) GetSTATUS_TRANSMISSION_COMPLETE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *TWAI_Type) SetSTATUS_RECEIVE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *TWAI_Type) GetSTATUS_RECEIVE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *TWAI_Type) SetSTATUS_TRANSMIT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *TWAI_Type) GetSTATUS_TRANSMIT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *TWAI_Type) SetSTATUS_ERR(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *TWAI_Type) GetSTATUS_ERR() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *TWAI_Type) SetSTATUS_NODE_BUS_OFF(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *TWAI_Type) GetSTATUS_NODE_BUS_OFF() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80) >> 7
}
func (o *TWAI_Type) SetSTATUS_MISS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *TWAI_Type) GetSTATUS_MISS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}

// TWAI.INTERRUPT: Interrupt signals' register.
func (o *TWAI_Type) SetINTERRUPT_RECEIVE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT.Reg, volatile.LoadUint32(&o.INTERRUPT.Reg)&^(0x1)|value)
}
func (o *TWAI_Type) GetINTERRUPT_RECEIVE_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INTERRUPT.Reg) & 0x1
}
func (o *TWAI_Type) SetINTERRUPT_TRANSMIT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT.Reg, volatile.LoadUint32(&o.INTERRUPT.Reg)&^(0x2)|value<<1)
}
func (o *TWAI_Type) GetINTERRUPT_TRANSMIT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT.Reg) & 0x2) >> 1
}
func (o *TWAI_Type) SetINTERRUPT_ERR_WARNING_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT.Reg, volatile.LoadUint32(&o.INTERRUPT.Reg)&^(0x4)|value<<2)
}
func (o *TWAI_Type) GetINTERRUPT_ERR_WARNING_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT.Reg) & 0x4) >> 2
}
func (o *TWAI_Type) SetINTERRUPT_DATA_OVERRUN_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT.Reg, volatile.LoadUint32(&o.INTERRUPT.Reg)&^(0x8)|value<<3)
}
func (o *TWAI_Type) GetINTERRUPT_DATA_OVERRUN_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT.Reg) & 0x8) >> 3
}
func (o *TWAI_Type) SetINTERRUPT_ERR_PASSIVE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT.Reg, volatile.LoadUint32(&o.INTERRUPT.Reg)&^(0x20)|value<<5)
}
func (o *TWAI_Type) GetINTERRUPT_ERR_PASSIVE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT.Reg) & 0x20) >> 5
}
func (o *TWAI_Type) SetINTERRUPT_ARBITRATION_LOST_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT.Reg, volatile.LoadUint32(&o.INTERRUPT.Reg)&^(0x40)|value<<6)
}
func (o *TWAI_Type) GetINTERRUPT_ARBITRATION_LOST_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT.Reg) & 0x40) >> 6
}
func (o *TWAI_Type) SetINTERRUPT_BUS_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT.Reg, volatile.LoadUint32(&o.INTERRUPT.Reg)&^(0x80)|value<<7)
}
func (o *TWAI_Type) GetINTERRUPT_BUS_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT.Reg) & 0x80) >> 7
}
func (o *TWAI_Type) SetINTERRUPT_IDLE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT.Reg, volatile.LoadUint32(&o.INTERRUPT.Reg)&^(0x100)|value<<8)
}
func (o *TWAI_Type) GetINTERRUPT_IDLE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT.Reg) & 0x100) >> 8
}

// TWAI.INTERRUPT_ENABLE: Interrupt enable register.
func (o *TWAI_Type) SetINTERRUPT_ENABLE_EXT_RECEIVE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT_ENABLE.Reg, volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg)&^(0x1)|value)
}
func (o *TWAI_Type) GetINTERRUPT_ENABLE_EXT_RECEIVE_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg) & 0x1
}
func (o *TWAI_Type) SetINTERRUPT_ENABLE_EXT_TRANSMIT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT_ENABLE.Reg, volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg)&^(0x2)|value<<1)
}
func (o *TWAI_Type) GetINTERRUPT_ENABLE_EXT_TRANSMIT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg) & 0x2) >> 1
}
func (o *TWAI_Type) SetINTERRUPT_ENABLE_EXT_ERR_WARNING_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT_ENABLE.Reg, volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg)&^(0x4)|value<<2)
}
func (o *TWAI_Type) GetINTERRUPT_ENABLE_EXT_ERR_WARNING_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg) & 0x4) >> 2
}
func (o *TWAI_Type) SetINTERRUPT_ENABLE_EXT_DATA_OVERRUN_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT_ENABLE.Reg, volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg)&^(0x8)|value<<3)
}
func (o *TWAI_Type) GetINTERRUPT_ENABLE_EXT_DATA_OVERRUN_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg) & 0x8) >> 3
}
func (o *TWAI_Type) SetINTERRUPT_ENABLE_ERR_PASSIVE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT_ENABLE.Reg, volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg)&^(0x20)|value<<5)
}
func (o *TWAI_Type) GetINTERRUPT_ENABLE_ERR_PASSIVE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg) & 0x20) >> 5
}
func (o *TWAI_Type) SetINTERRUPT_ENABLE_ARBITRATION_LOST_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT_ENABLE.Reg, volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg)&^(0x40)|value<<6)
}
func (o *TWAI_Type) GetINTERRUPT_ENABLE_ARBITRATION_LOST_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg) & 0x40) >> 6
}
func (o *TWAI_Type) SetINTERRUPT_ENABLE_BUS_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT_ENABLE.Reg, volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg)&^(0x80)|value<<7)
}
func (o *TWAI_Type) GetINTERRUPT_ENABLE_BUS_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg) & 0x80) >> 7
}
func (o *TWAI_Type) SetINTERRUPT_ENABLE_IDLE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT_ENABLE.Reg, volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg)&^(0x100)|value<<8)
}
func (o *TWAI_Type) GetINTERRUPT_ENABLE_IDLE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTERRUPT_ENABLE.Reg) & 0x100) >> 8
}

// TWAI.BUS_TIMING_0: Bit timing configuration register 0.
func (o *TWAI_Type) SetBUS_TIMING_0_BAUD_PRESC(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMING_0.Reg, volatile.LoadUint32(&o.BUS_TIMING_0.Reg)&^(0x3fff)|value)
}
func (o *TWAI_Type) GetBUS_TIMING_0_BAUD_PRESC() uint32 {
	return volatile.LoadUint32(&o.BUS_TIMING_0.Reg) & 0x3fff
}
func (o *TWAI_Type) SetBUS_TIMING_0_SYNC_JUMP_WIDTH(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMING_0.Reg, volatile.LoadUint32(&o.BUS_TIMING_0.Reg)&^(0xc000)|value<<14)
}
func (o *TWAI_Type) GetBUS_TIMING_0_SYNC_JUMP_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.BUS_TIMING_0.Reg) & 0xc000) >> 14
}

// TWAI.BUS_TIMING_1: Bit timing configuration register 1.
func (o *TWAI_Type) SetBUS_TIMING_1_TIME_SEGMENT1(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMING_1.Reg, volatile.LoadUint32(&o.BUS_TIMING_1.Reg)&^(0xf)|value)
}
func (o *TWAI_Type) GetBUS_TIMING_1_TIME_SEGMENT1() uint32 {
	return volatile.LoadUint32(&o.BUS_TIMING_1.Reg) & 0xf
}
func (o *TWAI_Type) SetBUS_TIMING_1_TIME_SEGMENT2(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMING_1.Reg, volatile.LoadUint32(&o.BUS_TIMING_1.Reg)&^(0x70)|value<<4)
}
func (o *TWAI_Type) GetBUS_TIMING_1_TIME_SEGMENT2() uint32 {
	return (volatile.LoadUint32(&o.BUS_TIMING_1.Reg) & 0x70) >> 4
}
func (o *TWAI_Type) SetBUS_TIMING_1_TIME_SAMPLING(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMING_1.Reg, volatile.LoadUint32(&o.BUS_TIMING_1.Reg)&^(0x80)|value<<7)
}
func (o *TWAI_Type) GetBUS_TIMING_1_TIME_SAMPLING() uint32 {
	return (volatile.LoadUint32(&o.BUS_TIMING_1.Reg) & 0x80) >> 7
}

// TWAI.ARB_LOST_CAP: TWAI arbiter lost capture register.
func (o *TWAI_Type) SetARB_LOST_CAP_ARBITRATION_LOST_CAPTURE(value uint32) {
	volatile.StoreUint32(&o.ARB_LOST_CAP.Reg, volatile.LoadUint32(&o.ARB_LOST_CAP.Reg)&^(0x1f)|value)
}
func (o *TWAI_Type) GetARB_LOST_CAP_ARBITRATION_LOST_CAPTURE() uint32 {
	return volatile.LoadUint32(&o.ARB_LOST_CAP.Reg) & 0x1f
}

// TWAI.ERR_CODE_CAP: TWAI error info capture register.
func (o *TWAI_Type) SetERR_CODE_CAP_ERR_CAPTURE_CODE_SEGMENT(value uint32) {
	volatile.StoreUint32(&o.ERR_CODE_CAP.Reg, volatile.LoadUint32(&o.ERR_CODE_CAP.Reg)&^(0x1f)|value)
}
func (o *TWAI_Type) GetERR_CODE_CAP_ERR_CAPTURE_CODE_SEGMENT() uint32 {
	return volatile.LoadUint32(&o.ERR_CODE_CAP.Reg) & 0x1f
}
func (o *TWAI_Type) SetERR_CODE_CAP_ERR_CAPTURE_CODE_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.ERR_CODE_CAP.Reg, volatile.LoadUint32(&o.ERR_CODE_CAP.Reg)&^(0x20)|value<<5)
}
func (o *TWAI_Type) GetERR_CODE_CAP_ERR_CAPTURE_CODE_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.ERR_CODE_CAP.Reg) & 0x20) >> 5
}
func (o *TWAI_Type) SetERR_CODE_CAP_ERR_CAPTURE_CODE_TYPE(value uint32) {
	volatile.StoreUint32(&o.ERR_CODE_CAP.Reg, volatile.LoadUint32(&o.ERR_CODE_CAP.Reg)&^(0xc0)|value<<6)
}
func (o *TWAI_Type) GetERR_CODE_CAP_ERR_CAPTURE_CODE_TYPE() uint32 {
	return (volatile.LoadUint32(&o.ERR_CODE_CAP.Reg) & 0xc0) >> 6
}

// TWAI.ERR_WARNING_LIMIT: TWAI error threshold configuration register.
func (o *TWAI_Type) SetERR_WARNING_LIMIT(value uint32) {
	volatile.StoreUint32(&o.ERR_WARNING_LIMIT.Reg, volatile.LoadUint32(&o.ERR_WARNING_LIMIT.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetERR_WARNING_LIMIT() uint32 {
	return volatile.LoadUint32(&o.ERR_WARNING_LIMIT.Reg) & 0xff
}

// TWAI.RX_ERR_CNT: Rx error counter register.
func (o *TWAI_Type) SetRX_ERR_CNT(value uint32) {
	volatile.StoreUint32(&o.RX_ERR_CNT.Reg, volatile.LoadUint32(&o.RX_ERR_CNT.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetRX_ERR_CNT() uint32 {
	return volatile.LoadUint32(&o.RX_ERR_CNT.Reg) & 0xff
}

// TWAI.TX_ERR_CNT: Tx error counter register.
func (o *TWAI_Type) SetTX_ERR_CNT(value uint32) {
	volatile.StoreUint32(&o.TX_ERR_CNT.Reg, volatile.LoadUint32(&o.TX_ERR_CNT.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetTX_ERR_CNT() uint32 {
	return volatile.LoadUint32(&o.TX_ERR_CNT.Reg) & 0xff
}

// TWAI.DATA_0: Data register 0.
func (o *TWAI_Type) SetDATA_0(value uint32) {
	volatile.StoreUint32(&o.DATA_0.Reg, volatile.LoadUint32(&o.DATA_0.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_0() uint32 {
	return volatile.LoadUint32(&o.DATA_0.Reg) & 0xff
}

// TWAI.DATA_1: Data register 1.
func (o *TWAI_Type) SetDATA_1(value uint32) {
	volatile.StoreUint32(&o.DATA_1.Reg, volatile.LoadUint32(&o.DATA_1.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_1() uint32 {
	return volatile.LoadUint32(&o.DATA_1.Reg) & 0xff
}

// TWAI.DATA_2: Data register 2.
func (o *TWAI_Type) SetDATA_2(value uint32) {
	volatile.StoreUint32(&o.DATA_2.Reg, volatile.LoadUint32(&o.DATA_2.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_2() uint32 {
	return volatile.LoadUint32(&o.DATA_2.Reg) & 0xff
}

// TWAI.DATA_3: Data register 3.
func (o *TWAI_Type) SetDATA_3(value uint32) {
	volatile.StoreUint32(&o.DATA_3.Reg, volatile.LoadUint32(&o.DATA_3.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_3() uint32 {
	return volatile.LoadUint32(&o.DATA_3.Reg) & 0xff
}

// TWAI.DATA_4: Data register 4.
func (o *TWAI_Type) SetDATA_4(value uint32) {
	volatile.StoreUint32(&o.DATA_4.Reg, volatile.LoadUint32(&o.DATA_4.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_4() uint32 {
	return volatile.LoadUint32(&o.DATA_4.Reg) & 0xff
}

// TWAI.DATA_5: Data register 5.
func (o *TWAI_Type) SetDATA_5(value uint32) {
	volatile.StoreUint32(&o.DATA_5.Reg, volatile.LoadUint32(&o.DATA_5.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_5() uint32 {
	return volatile.LoadUint32(&o.DATA_5.Reg) & 0xff
}

// TWAI.DATA_6: Data register 6.
func (o *TWAI_Type) SetDATA_6(value uint32) {
	volatile.StoreUint32(&o.DATA_6.Reg, volatile.LoadUint32(&o.DATA_6.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_6() uint32 {
	return volatile.LoadUint32(&o.DATA_6.Reg) & 0xff
}

// TWAI.DATA_7: Data register 7.
func (o *TWAI_Type) SetDATA_7(value uint32) {
	volatile.StoreUint32(&o.DATA_7.Reg, volatile.LoadUint32(&o.DATA_7.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_7() uint32 {
	return volatile.LoadUint32(&o.DATA_7.Reg) & 0xff
}

// TWAI.DATA_8: Data register 8.
func (o *TWAI_Type) SetDATA_8(value uint32) {
	volatile.StoreUint32(&o.DATA_8.Reg, volatile.LoadUint32(&o.DATA_8.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_8() uint32 {
	return volatile.LoadUint32(&o.DATA_8.Reg) & 0xff
}

// TWAI.DATA_9: Data register 9.
func (o *TWAI_Type) SetDATA_9(value uint32) {
	volatile.StoreUint32(&o.DATA_9.Reg, volatile.LoadUint32(&o.DATA_9.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_9() uint32 {
	return volatile.LoadUint32(&o.DATA_9.Reg) & 0xff
}

// TWAI.DATA_10: Data register 10.
func (o *TWAI_Type) SetDATA_10(value uint32) {
	volatile.StoreUint32(&o.DATA_10.Reg, volatile.LoadUint32(&o.DATA_10.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_10() uint32 {
	return volatile.LoadUint32(&o.DATA_10.Reg) & 0xff
}

// TWAI.DATA_11: Data register 11.
func (o *TWAI_Type) SetDATA_11(value uint32) {
	volatile.StoreUint32(&o.DATA_11.Reg, volatile.LoadUint32(&o.DATA_11.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_11() uint32 {
	return volatile.LoadUint32(&o.DATA_11.Reg) & 0xff
}

// TWAI.DATA_12: Data register 12.
func (o *TWAI_Type) SetDATA_12(value uint32) {
	volatile.StoreUint32(&o.DATA_12.Reg, volatile.LoadUint32(&o.DATA_12.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_12() uint32 {
	return volatile.LoadUint32(&o.DATA_12.Reg) & 0xff
}

// TWAI.RX_MESSAGE_COUNTER: Received message counter register.
func (o *TWAI_Type) SetRX_MESSAGE_COUNTER(value uint32) {
	volatile.StoreUint32(&o.RX_MESSAGE_COUNTER.Reg, volatile.LoadUint32(&o.RX_MESSAGE_COUNTER.Reg)&^(0x7f)|value)
}
func (o *TWAI_Type) GetRX_MESSAGE_COUNTER() uint32 {
	return volatile.LoadUint32(&o.RX_MESSAGE_COUNTER.Reg) & 0x7f
}

// TWAI.CLOCK_DIVIDER: Clock divider register.
func (o *TWAI_Type) SetCLOCK_DIVIDER_CD(value uint32) {
	volatile.StoreUint32(&o.CLOCK_DIVIDER.Reg, volatile.LoadUint32(&o.CLOCK_DIVIDER.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetCLOCK_DIVIDER_CD() uint32 {
	return volatile.LoadUint32(&o.CLOCK_DIVIDER.Reg) & 0xff
}
func (o *TWAI_Type) SetCLOCK_DIVIDER_CLOCK_OFF(value uint32) {
	volatile.StoreUint32(&o.CLOCK_DIVIDER.Reg, volatile.LoadUint32(&o.CLOCK_DIVIDER.Reg)&^(0x100)|value<<8)
}
func (o *TWAI_Type) GetCLOCK_DIVIDER_CLOCK_OFF() uint32 {
	return (volatile.LoadUint32(&o.CLOCK_DIVIDER.Reg) & 0x100) >> 8
}

// TWAI.SW_STANDBY_CFG: Software configure standby pin directly.
func (o *TWAI_Type) SetSW_STANDBY_CFG_SW_STANDBY_EN(value uint32) {
	volatile.StoreUint32(&o.SW_STANDBY_CFG.Reg, volatile.LoadUint32(&o.SW_STANDBY_CFG.Reg)&^(0x1)|value)
}
func (o *TWAI_Type) GetSW_STANDBY_CFG_SW_STANDBY_EN() uint32 {
	return volatile.LoadUint32(&o.SW_STANDBY_CFG.Reg) & 0x1
}
func (o *TWAI_Type) SetSW_STANDBY_CFG_SW_STANDBY_CLR(value uint32) {
	volatile.StoreUint32(&o.SW_STANDBY_CFG.Reg, volatile.LoadUint32(&o.SW_STANDBY_CFG.Reg)&^(0x2)|value<<1)
}
func (o *TWAI_Type) GetSW_STANDBY_CFG_SW_STANDBY_CLR() uint32 {
	return (volatile.LoadUint32(&o.SW_STANDBY_CFG.Reg) & 0x2) >> 1
}

// TWAI.HW_CFG: Hardware configure standby pin.
func (o *TWAI_Type) SetHW_CFG_HW_STANDBY_EN(value uint32) {
	volatile.StoreUint32(&o.HW_CFG.Reg, volatile.LoadUint32(&o.HW_CFG.Reg)&^(0x1)|value)
}
func (o *TWAI_Type) GetHW_CFG_HW_STANDBY_EN() uint32 {
	return volatile.LoadUint32(&o.HW_CFG.Reg) & 0x1
}

// TWAI.HW_STANDBY_CNT: Configure standby counter.
func (o *TWAI_Type) SetHW_STANDBY_CNT(value uint32) {
	volatile.StoreUint32(&o.HW_STANDBY_CNT.Reg, value)
}
func (o *TWAI_Type) GetHW_STANDBY_CNT() uint32 {
	return volatile.LoadUint32(&o.HW_STANDBY_CNT.Reg)
}

// TWAI.IDLE_INTR_CNT: Configure idle interrupt counter.
func (o *TWAI_Type) SetIDLE_INTR_CNT(value uint32) {
	volatile.StoreUint32(&o.IDLE_INTR_CNT.Reg, value)
}
func (o *TWAI_Type) GetIDLE_INTR_CNT() uint32 {
	return volatile.LoadUint32(&o.IDLE_INTR_CNT.Reg)
}

// TWAI.ECO_CFG: ECO configuration register.
func (o *TWAI_Type) SetECO_CFG_RDN_ENA(value uint32) {
	volatile.StoreUint32(&o.ECO_CFG.Reg, volatile.LoadUint32(&o.ECO_CFG.Reg)&^(0x1)|value)
}
func (o *TWAI_Type) GetECO_CFG_RDN_ENA() uint32 {
	return volatile.LoadUint32(&o.ECO_CFG.Reg) & 0x1
}
func (o *TWAI_Type) SetECO_CFG_RDN_RESULT(value uint32) {
	volatile.StoreUint32(&o.ECO_CFG.Reg, volatile.LoadUint32(&o.ECO_CFG.Reg)&^(0x2)|value<<1)
}
func (o *TWAI_Type) GetECO_CFG_RDN_RESULT() uint32 {
	return (volatile.LoadUint32(&o.ECO_CFG.Reg) & 0x2) >> 1
}

// UART (Universal Asynchronous Receiver-Transmitter) Controller 0
type UART_Type struct {
	FIFO           volatile.Register32 // 0x0
	INT_RAW        volatile.Register32 // 0x4
	INT_ST         volatile.Register32 // 0x8
	INT_ENA        volatile.Register32 // 0xC
	INT_CLR        volatile.Register32 // 0x10
	CLKDIV         volatile.Register32 // 0x14
	RX_FILT        volatile.Register32 // 0x18
	STATUS         volatile.Register32 // 0x1C
	CONF0          volatile.Register32 // 0x20
	CONF1          volatile.Register32 // 0x24
	_              [4]byte
	HWFC_CONF      volatile.Register32 // 0x2C
	SLEEP_CONF0    volatile.Register32 // 0x30
	SLEEP_CONF1    volatile.Register32 // 0x34
	SLEEP_CONF2    volatile.Register32 // 0x38
	SWFC_CONF0     volatile.Register32 // 0x3C
	SWFC_CONF1     volatile.Register32 // 0x40
	TXBRK_CONF     volatile.Register32 // 0x44
	IDLE_CONF      volatile.Register32 // 0x48
	RS485_CONF     volatile.Register32 // 0x4C
	AT_CMD_PRECNT  volatile.Register32 // 0x50
	AT_CMD_POSTCNT volatile.Register32 // 0x54
	AT_CMD_GAPTOUT volatile.Register32 // 0x58
	AT_CMD_CHAR    volatile.Register32 // 0x5C
	MEM_CONF       volatile.Register32 // 0x60
	TOUT_CONF      volatile.Register32 // 0x64
	MEM_TX_STATUS  volatile.Register32 // 0x68
	MEM_RX_STATUS  volatile.Register32 // 0x6C
	FSM_STATUS     volatile.Register32 // 0x70
	POSPULSE       volatile.Register32 // 0x74
	NEGPULSE       volatile.Register32 // 0x78
	LOWPULSE       volatile.Register32 // 0x7C
	HIGHPULSE      volatile.Register32 // 0x80
	RXD_CNT        volatile.Register32 // 0x84
	CLK_CONF       volatile.Register32 // 0x88
	DATE           volatile.Register32 // 0x8C
	AFIFO_STATUS   volatile.Register32 // 0x90
	_              [4]byte
	REG_UPDATE     volatile.Register32 // 0x98
	ID             volatile.Register32 // 0x9C
}

// UART.FIFO: FIFO data register
func (o *UART_Type) SetFIFO_RXFIFO_RD_BYTE(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetFIFO_RXFIFO_RD_BYTE() uint32 {
	return volatile.LoadUint32(&o.FIFO.Reg) & 0xff
}

// UART.INT_RAW: Raw interrupt status
func (o *UART_Type) SetINT_RAW_RXFIFO_FULL_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetINT_RAW_RXFIFO_FULL_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *UART_Type) SetINT_RAW_TXFIFO_EMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetINT_RAW_TXFIFO_EMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetINT_RAW_PARITY_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetINT_RAW_PARITY_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetINT_RAW_FRM_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetINT_RAW_FRM_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetINT_RAW_RXFIFO_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetINT_RAW_RXFIFO_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetINT_RAW_DSR_CHG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetINT_RAW_DSR_CHG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetINT_RAW_CTS_CHG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetINT_RAW_CTS_CHG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetINT_RAW_BRK_DET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetINT_RAW_BRK_DET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetINT_RAW_RXFIFO_TOUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetINT_RAW_RXFIFO_TOUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *UART_Type) SetINT_RAW_SW_XON_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetINT_RAW_SW_XON_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetINT_RAW_SW_XOFF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *UART_Type) GetINT_RAW_SW_XOFF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *UART_Type) SetINT_RAW_GLITCH_DET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *UART_Type) GetINT_RAW_GLITCH_DET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *UART_Type) SetINT_RAW_TX_BRK_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *UART_Type) GetINT_RAW_TX_BRK_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *UART_Type) SetINT_RAW_TX_BRK_IDLE_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *UART_Type) GetINT_RAW_TX_BRK_IDLE_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *UART_Type) SetINT_RAW_TX_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *UART_Type) GetINT_RAW_TX_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *UART_Type) SetINT_RAW_RS485_PARITY_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetINT_RAW_RS485_PARITY_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *UART_Type) SetINT_RAW_RS485_FRM_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *UART_Type) GetINT_RAW_RS485_FRM_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}
func (o *UART_Type) SetINT_RAW_RS485_CLASH_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetINT_RAW_RS485_CLASH_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000) >> 17
}
func (o *UART_Type) SetINT_RAW_AT_CMD_CHAR_DET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000)|value<<18)
}
func (o *UART_Type) GetINT_RAW_AT_CMD_CHAR_DET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000) >> 18
}
func (o *UART_Type) SetINT_RAW_WAKEUP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000)|value<<19)
}
func (o *UART_Type) GetINT_RAW_WAKEUP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000) >> 19
}

// UART.INT_ST: Masked interrupt status
func (o *UART_Type) SetINT_ST_RXFIFO_FULL_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetINT_ST_RXFIFO_FULL_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *UART_Type) SetINT_ST_TXFIFO_EMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetINT_ST_TXFIFO_EMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetINT_ST_PARITY_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetINT_ST_PARITY_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetINT_ST_FRM_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetINT_ST_FRM_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetINT_ST_RXFIFO_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetINT_ST_RXFIFO_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetINT_ST_DSR_CHG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetINT_ST_DSR_CHG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetINT_ST_CTS_CHG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetINT_ST_CTS_CHG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetINT_ST_BRK_DET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetINT_ST_BRK_DET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetINT_ST_RXFIFO_TOUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetINT_ST_RXFIFO_TOUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *UART_Type) SetINT_ST_SW_XON_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetINT_ST_SW_XON_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetINT_ST_SW_XOFF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *UART_Type) GetINT_ST_SW_XOFF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400) >> 10
}
func (o *UART_Type) SetINT_ST_GLITCH_DET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *UART_Type) GetINT_ST_GLITCH_DET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x800) >> 11
}
func (o *UART_Type) SetINT_ST_TX_BRK_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *UART_Type) GetINT_ST_TX_BRK_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *UART_Type) SetINT_ST_TX_BRK_IDLE_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *UART_Type) GetINT_ST_TX_BRK_IDLE_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000) >> 13
}
func (o *UART_Type) SetINT_ST_TX_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *UART_Type) GetINT_ST_TX_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000) >> 14
}
func (o *UART_Type) SetINT_ST_RS485_PARITY_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetINT_ST_RS485_PARITY_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000) >> 15
}
func (o *UART_Type) SetINT_ST_RS485_FRM_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *UART_Type) GetINT_ST_RS485_FRM_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000) >> 16
}
func (o *UART_Type) SetINT_ST_RS485_CLASH_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetINT_ST_RS485_CLASH_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000) >> 17
}
func (o *UART_Type) SetINT_ST_AT_CMD_CHAR_DET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40000)|value<<18)
}
func (o *UART_Type) GetINT_ST_AT_CMD_CHAR_DET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40000) >> 18
}
func (o *UART_Type) SetINT_ST_WAKEUP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80000)|value<<19)
}
func (o *UART_Type) GetINT_ST_WAKEUP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80000) >> 19
}

// UART.INT_ENA: Interrupt enable bits
func (o *UART_Type) SetINT_ENA_RXFIFO_FULL_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetINT_ENA_RXFIFO_FULL_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *UART_Type) SetINT_ENA_TXFIFO_EMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetINT_ENA_TXFIFO_EMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetINT_ENA_PARITY_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetINT_ENA_PARITY_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetINT_ENA_FRM_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetINT_ENA_FRM_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetINT_ENA_RXFIFO_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetINT_ENA_RXFIFO_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetINT_ENA_DSR_CHG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetINT_ENA_DSR_CHG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetINT_ENA_CTS_CHG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetINT_ENA_CTS_CHG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetINT_ENA_BRK_DET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetINT_ENA_BRK_DET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetINT_ENA_RXFIFO_TOUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetINT_ENA_RXFIFO_TOUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *UART_Type) SetINT_ENA_SW_XON_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetINT_ENA_SW_XON_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetINT_ENA_SW_XOFF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *UART_Type) GetINT_ENA_SW_XOFF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *UART_Type) SetINT_ENA_GLITCH_DET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *UART_Type) GetINT_ENA_GLITCH_DET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *UART_Type) SetINT_ENA_TX_BRK_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *UART_Type) GetINT_ENA_TX_BRK_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *UART_Type) SetINT_ENA_TX_BRK_IDLE_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *UART_Type) GetINT_ENA_TX_BRK_IDLE_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *UART_Type) SetINT_ENA_TX_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *UART_Type) GetINT_ENA_TX_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *UART_Type) SetINT_ENA_RS485_PARITY_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetINT_ENA_RS485_PARITY_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *UART_Type) SetINT_ENA_RS485_FRM_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *UART_Type) GetINT_ENA_RS485_FRM_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}
func (o *UART_Type) SetINT_ENA_RS485_CLASH_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetINT_ENA_RS485_CLASH_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000) >> 17
}
func (o *UART_Type) SetINT_ENA_AT_CMD_CHAR_DET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40000)|value<<18)
}
func (o *UART_Type) GetINT_ENA_AT_CMD_CHAR_DET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40000) >> 18
}
func (o *UART_Type) SetINT_ENA_WAKEUP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80000)|value<<19)
}
func (o *UART_Type) GetINT_ENA_WAKEUP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80000) >> 19
}

// UART.INT_CLR: Interrupt clear bits
func (o *UART_Type) SetINT_CLR_RXFIFO_FULL_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetINT_CLR_RXFIFO_FULL_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *UART_Type) SetINT_CLR_TXFIFO_EMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetINT_CLR_TXFIFO_EMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetINT_CLR_PARITY_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetINT_CLR_PARITY_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetINT_CLR_FRM_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetINT_CLR_FRM_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetINT_CLR_RXFIFO_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetINT_CLR_RXFIFO_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetINT_CLR_DSR_CHG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetINT_CLR_DSR_CHG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetINT_CLR_CTS_CHG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetINT_CLR_CTS_CHG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetINT_CLR_BRK_DET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetINT_CLR_BRK_DET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetINT_CLR_RXFIFO_TOUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetINT_CLR_RXFIFO_TOUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *UART_Type) SetINT_CLR_SW_XON_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetINT_CLR_SW_XON_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetINT_CLR_SW_XOFF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *UART_Type) GetINT_CLR_SW_XOFF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *UART_Type) SetINT_CLR_GLITCH_DET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *UART_Type) GetINT_CLR_GLITCH_DET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *UART_Type) SetINT_CLR_TX_BRK_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *UART_Type) GetINT_CLR_TX_BRK_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *UART_Type) SetINT_CLR_TX_BRK_IDLE_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *UART_Type) GetINT_CLR_TX_BRK_IDLE_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *UART_Type) SetINT_CLR_TX_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *UART_Type) GetINT_CLR_TX_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *UART_Type) SetINT_CLR_RS485_PARITY_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetINT_CLR_RS485_PARITY_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *UART_Type) SetINT_CLR_RS485_FRM_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *UART_Type) GetINT_CLR_RS485_FRM_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}
func (o *UART_Type) SetINT_CLR_RS485_CLASH_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetINT_CLR_RS485_CLASH_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000) >> 17
}
func (o *UART_Type) SetINT_CLR_AT_CMD_CHAR_DET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *UART_Type) GetINT_CLR_AT_CMD_CHAR_DET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40000) >> 18
}
func (o *UART_Type) SetINT_CLR_WAKEUP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *UART_Type) GetINT_CLR_WAKEUP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80000) >> 19
}

// UART.CLKDIV: Clock divider configuration
func (o *UART_Type) SetCLKDIV(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xfff)|value)
}
func (o *UART_Type) GetCLKDIV() uint32 {
	return volatile.LoadUint32(&o.CLKDIV.Reg) & 0xfff
}
func (o *UART_Type) SetCLKDIV_FRAG(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xf00000)|value<<20)
}
func (o *UART_Type) GetCLKDIV_FRAG() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV.Reg) & 0xf00000) >> 20
}

// UART.RX_FILT: Rx Filter configuration
func (o *UART_Type) SetRX_FILT_GLITCH_FILT(value uint32) {
	volatile.StoreUint32(&o.RX_FILT.Reg, volatile.LoadUint32(&o.RX_FILT.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetRX_FILT_GLITCH_FILT() uint32 {
	return volatile.LoadUint32(&o.RX_FILT.Reg) & 0xff
}
func (o *UART_Type) SetRX_FILT_GLITCH_FILT_EN(value uint32) {
	volatile.StoreUint32(&o.RX_FILT.Reg, volatile.LoadUint32(&o.RX_FILT.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetRX_FILT_GLITCH_FILT_EN() uint32 {
	return (volatile.LoadUint32(&o.RX_FILT.Reg) & 0x100) >> 8
}

// UART.STATUS: UART status register
func (o *UART_Type) SetSTATUS_RXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetSTATUS_RXFIFO_CNT() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0xff
}
func (o *UART_Type) SetSTATUS_DSRN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *UART_Type) GetSTATUS_DSRN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2000) >> 13
}
func (o *UART_Type) SetSTATUS_CTSN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *UART_Type) GetSTATUS_CTSN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4000) >> 14
}
func (o *UART_Type) SetSTATUS_RXD(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetSTATUS_RXD() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8000) >> 15
}
func (o *UART_Type) SetSTATUS_TXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xff0000)|value<<16)
}
func (o *UART_Type) GetSTATUS_TXFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xff0000) >> 16
}
func (o *UART_Type) SetSTATUS_DTRN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20000000)|value<<29)
}
func (o *UART_Type) GetSTATUS_DTRN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20000000) >> 29
}
func (o *UART_Type) SetSTATUS_RTSN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40000000)|value<<30)
}
func (o *UART_Type) GetSTATUS_RTSN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40000000) >> 30
}
func (o *UART_Type) SetSTATUS_TXD(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *UART_Type) GetSTATUS_TXD() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80000000) >> 31
}

// UART.CONF0: a
func (o *UART_Type) SetCONF0_PARITY(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetCONF0_PARITY() uint32 {
	return volatile.LoadUint32(&o.CONF0.Reg) & 0x1
}
func (o *UART_Type) SetCONF0_PARITY_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetCONF0_PARITY_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetCONF0_BIT_NUM(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0xc)|value<<2)
}
func (o *UART_Type) GetCONF0_BIT_NUM() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0xc) >> 2
}
func (o *UART_Type) SetCONF0_STOP_BIT_NUM(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x30)|value<<4)
}
func (o *UART_Type) GetCONF0_STOP_BIT_NUM() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x30) >> 4
}
func (o *UART_Type) SetCONF0_TXD_BRK(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetCONF0_TXD_BRK() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetCONF0_IRDA_DPLX(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetCONF0_IRDA_DPLX() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetCONF0_IRDA_TX_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetCONF0_IRDA_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x100) >> 8
}
func (o *UART_Type) SetCONF0_IRDA_WCTL(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetCONF0_IRDA_WCTL() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetCONF0_IRDA_TX_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x400)|value<<10)
}
func (o *UART_Type) GetCONF0_IRDA_TX_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x400) >> 10
}
func (o *UART_Type) SetCONF0_IRDA_RX_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x800)|value<<11)
}
func (o *UART_Type) GetCONF0_IRDA_RX_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x800) >> 11
}
func (o *UART_Type) SetCONF0_LOOPBACK(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *UART_Type) GetCONF0_LOOPBACK() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x1000) >> 12
}
func (o *UART_Type) SetCONF0_TX_FLOW_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *UART_Type) GetCONF0_TX_FLOW_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2000) >> 13
}
func (o *UART_Type) SetCONF0_IRDA_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *UART_Type) GetCONF0_IRDA_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x4000) >> 14
}
func (o *UART_Type) SetCONF0_RXD_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetCONF0_RXD_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x8000) >> 15
}
func (o *UART_Type) SetCONF0_TXD_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *UART_Type) GetCONF0_TXD_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x10000) >> 16
}
func (o *UART_Type) SetCONF0_DIS_RX_DAT_OVF(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetCONF0_DIS_RX_DAT_OVF() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x20000) >> 17
}
func (o *UART_Type) SetCONF0_ERR_WR_MASK(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x40000)|value<<18)
}
func (o *UART_Type) GetCONF0_ERR_WR_MASK() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x40000) >> 18
}
func (o *UART_Type) SetCONF0_AUTOBAUD_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x80000)|value<<19)
}
func (o *UART_Type) GetCONF0_AUTOBAUD_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x80000) >> 19
}
func (o *UART_Type) SetCONF0_MEM_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x100000)|value<<20)
}
func (o *UART_Type) GetCONF0_MEM_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x100000) >> 20
}
func (o *UART_Type) SetCONF0_SW_RTS(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x200000)|value<<21)
}
func (o *UART_Type) GetCONF0_SW_RTS() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x200000) >> 21
}
func (o *UART_Type) SetCONF0_RXFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x400000)|value<<22)
}
func (o *UART_Type) GetCONF0_RXFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x400000) >> 22
}
func (o *UART_Type) SetCONF0_TXFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x800000)|value<<23)
}
func (o *UART_Type) GetCONF0_TXFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x800000) >> 23
}

// UART.CONF1: Configuration register 1
func (o *UART_Type) SetCONF1_RXFIFO_FULL_THRHD(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetCONF1_RXFIFO_FULL_THRHD() uint32 {
	return volatile.LoadUint32(&o.CONF1.Reg) & 0xff
}
func (o *UART_Type) SetCONF1_TXFIFO_EMPTY_THRHD(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0xff00)|value<<8)
}
func (o *UART_Type) GetCONF1_TXFIFO_EMPTY_THRHD() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0xff00) >> 8
}
func (o *UART_Type) SetCONF1_CTS_INV(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x10000)|value<<16)
}
func (o *UART_Type) GetCONF1_CTS_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x10000) >> 16
}
func (o *UART_Type) SetCONF1_DSR_INV(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetCONF1_DSR_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x20000) >> 17
}
func (o *UART_Type) SetCONF1_RTS_INV(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x40000)|value<<18)
}
func (o *UART_Type) GetCONF1_RTS_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x40000) >> 18
}
func (o *UART_Type) SetCONF1_DTR_INV(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x80000)|value<<19)
}
func (o *UART_Type) GetCONF1_DTR_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x80000) >> 19
}
func (o *UART_Type) SetCONF1_SW_DTR(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x100000)|value<<20)
}
func (o *UART_Type) GetCONF1_SW_DTR() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x100000) >> 20
}
func (o *UART_Type) SetCONF1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x200000)|value<<21)
}
func (o *UART_Type) GetCONF1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x200000) >> 21
}

// UART.HWFC_CONF: Hardware flow-control configuration
func (o *UART_Type) SetHWFC_CONF_RX_FLOW_THRHD(value uint32) {
	volatile.StoreUint32(&o.HWFC_CONF.Reg, volatile.LoadUint32(&o.HWFC_CONF.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetHWFC_CONF_RX_FLOW_THRHD() uint32 {
	return volatile.LoadUint32(&o.HWFC_CONF.Reg) & 0xff
}
func (o *UART_Type) SetHWFC_CONF_RX_FLOW_EN(value uint32) {
	volatile.StoreUint32(&o.HWFC_CONF.Reg, volatile.LoadUint32(&o.HWFC_CONF.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetHWFC_CONF_RX_FLOW_EN() uint32 {
	return (volatile.LoadUint32(&o.HWFC_CONF.Reg) & 0x100) >> 8
}

// UART.SLEEP_CONF0: UART sleep configure register 0
func (o *UART_Type) SetSLEEP_CONF0_WK_CHAR1(value uint32) {
	volatile.StoreUint32(&o.SLEEP_CONF0.Reg, volatile.LoadUint32(&o.SLEEP_CONF0.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetSLEEP_CONF0_WK_CHAR1() uint32 {
	return volatile.LoadUint32(&o.SLEEP_CONF0.Reg) & 0xff
}
func (o *UART_Type) SetSLEEP_CONF0_WK_CHAR2(value uint32) {
	volatile.StoreUint32(&o.SLEEP_CONF0.Reg, volatile.LoadUint32(&o.SLEEP_CONF0.Reg)&^(0xff00)|value<<8)
}
func (o *UART_Type) GetSLEEP_CONF0_WK_CHAR2() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_CONF0.Reg) & 0xff00) >> 8
}
func (o *UART_Type) SetSLEEP_CONF0_WK_CHAR3(value uint32) {
	volatile.StoreUint32(&o.SLEEP_CONF0.Reg, volatile.LoadUint32(&o.SLEEP_CONF0.Reg)&^(0xff0000)|value<<16)
}
func (o *UART_Type) GetSLEEP_CONF0_WK_CHAR3() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_CONF0.Reg) & 0xff0000) >> 16
}
func (o *UART_Type) SetSLEEP_CONF0_WK_CHAR4(value uint32) {
	volatile.StoreUint32(&o.SLEEP_CONF0.Reg, volatile.LoadUint32(&o.SLEEP_CONF0.Reg)&^(0xff000000)|value<<24)
}
func (o *UART_Type) GetSLEEP_CONF0_WK_CHAR4() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_CONF0.Reg) & 0xff000000) >> 24
}

// UART.SLEEP_CONF1: UART sleep configure register 1
func (o *UART_Type) SetSLEEP_CONF1_WK_CHAR0(value uint32) {
	volatile.StoreUint32(&o.SLEEP_CONF1.Reg, volatile.LoadUint32(&o.SLEEP_CONF1.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetSLEEP_CONF1_WK_CHAR0() uint32 {
	return volatile.LoadUint32(&o.SLEEP_CONF1.Reg) & 0xff
}

// UART.SLEEP_CONF2: UART sleep configure register 2
func (o *UART_Type) SetSLEEP_CONF2_ACTIVE_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.SLEEP_CONF2.Reg, volatile.LoadUint32(&o.SLEEP_CONF2.Reg)&^(0x3ff)|value)
}
func (o *UART_Type) GetSLEEP_CONF2_ACTIVE_THRESHOLD() uint32 {
	return volatile.LoadUint32(&o.SLEEP_CONF2.Reg) & 0x3ff
}
func (o *UART_Type) SetSLEEP_CONF2_RX_WAKE_UP_THRHD(value uint32) {
	volatile.StoreUint32(&o.SLEEP_CONF2.Reg, volatile.LoadUint32(&o.SLEEP_CONF2.Reg)&^(0x3fc00)|value<<10)
}
func (o *UART_Type) GetSLEEP_CONF2_RX_WAKE_UP_THRHD() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_CONF2.Reg) & 0x3fc00) >> 10
}
func (o *UART_Type) SetSLEEP_CONF2_WK_CHAR_NUM(value uint32) {
	volatile.StoreUint32(&o.SLEEP_CONF2.Reg, volatile.LoadUint32(&o.SLEEP_CONF2.Reg)&^(0x1c0000)|value<<18)
}
func (o *UART_Type) GetSLEEP_CONF2_WK_CHAR_NUM() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_CONF2.Reg) & 0x1c0000) >> 18
}
func (o *UART_Type) SetSLEEP_CONF2_WK_CHAR_MASK(value uint32) {
	volatile.StoreUint32(&o.SLEEP_CONF2.Reg, volatile.LoadUint32(&o.SLEEP_CONF2.Reg)&^(0x3e00000)|value<<21)
}
func (o *UART_Type) GetSLEEP_CONF2_WK_CHAR_MASK() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_CONF2.Reg) & 0x3e00000) >> 21
}
func (o *UART_Type) SetSLEEP_CONF2_WK_MODE_SEL(value uint32) {
	volatile.StoreUint32(&o.SLEEP_CONF2.Reg, volatile.LoadUint32(&o.SLEEP_CONF2.Reg)&^(0xc000000)|value<<26)
}
func (o *UART_Type) GetSLEEP_CONF2_WK_MODE_SEL() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_CONF2.Reg) & 0xc000000) >> 26
}

// UART.SWFC_CONF0: Software flow-control character configuration
func (o *UART_Type) SetSWFC_CONF0_XON_CHAR(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF0.Reg, volatile.LoadUint32(&o.SWFC_CONF0.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetSWFC_CONF0_XON_CHAR() uint32 {
	return volatile.LoadUint32(&o.SWFC_CONF0.Reg) & 0xff
}
func (o *UART_Type) SetSWFC_CONF0_XOFF_CHAR(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF0.Reg, volatile.LoadUint32(&o.SWFC_CONF0.Reg)&^(0xff00)|value<<8)
}
func (o *UART_Type) GetSWFC_CONF0_XOFF_CHAR() uint32 {
	return (volatile.LoadUint32(&o.SWFC_CONF0.Reg) & 0xff00) >> 8
}
func (o *UART_Type) SetSWFC_CONF0_XON_XOFF_STILL_SEND(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF0.Reg, volatile.LoadUint32(&o.SWFC_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *UART_Type) GetSWFC_CONF0_XON_XOFF_STILL_SEND() uint32 {
	return (volatile.LoadUint32(&o.SWFC_CONF0.Reg) & 0x10000) >> 16
}
func (o *UART_Type) SetSWFC_CONF0_SW_FLOW_CON_EN(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF0.Reg, volatile.LoadUint32(&o.SWFC_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetSWFC_CONF0_SW_FLOW_CON_EN() uint32 {
	return (volatile.LoadUint32(&o.SWFC_CONF0.Reg) & 0x20000) >> 17
}
func (o *UART_Type) SetSWFC_CONF0_XONOFF_DEL(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF0.Reg, volatile.LoadUint32(&o.SWFC_CONF0.Reg)&^(0x40000)|value<<18)
}
func (o *UART_Type) GetSWFC_CONF0_XONOFF_DEL() uint32 {
	return (volatile.LoadUint32(&o.SWFC_CONF0.Reg) & 0x40000) >> 18
}
func (o *UART_Type) SetSWFC_CONF0_FORCE_XON(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF0.Reg, volatile.LoadUint32(&o.SWFC_CONF0.Reg)&^(0x80000)|value<<19)
}
func (o *UART_Type) GetSWFC_CONF0_FORCE_XON() uint32 {
	return (volatile.LoadUint32(&o.SWFC_CONF0.Reg) & 0x80000) >> 19
}
func (o *UART_Type) SetSWFC_CONF0_FORCE_XOFF(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF0.Reg, volatile.LoadUint32(&o.SWFC_CONF0.Reg)&^(0x100000)|value<<20)
}
func (o *UART_Type) GetSWFC_CONF0_FORCE_XOFF() uint32 {
	return (volatile.LoadUint32(&o.SWFC_CONF0.Reg) & 0x100000) >> 20
}
func (o *UART_Type) SetSWFC_CONF0_SEND_XON(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF0.Reg, volatile.LoadUint32(&o.SWFC_CONF0.Reg)&^(0x200000)|value<<21)
}
func (o *UART_Type) GetSWFC_CONF0_SEND_XON() uint32 {
	return (volatile.LoadUint32(&o.SWFC_CONF0.Reg) & 0x200000) >> 21
}
func (o *UART_Type) SetSWFC_CONF0_SEND_XOFF(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF0.Reg, volatile.LoadUint32(&o.SWFC_CONF0.Reg)&^(0x400000)|value<<22)
}
func (o *UART_Type) GetSWFC_CONF0_SEND_XOFF() uint32 {
	return (volatile.LoadUint32(&o.SWFC_CONF0.Reg) & 0x400000) >> 22
}

// UART.SWFC_CONF1: Software flow-control character configuration
func (o *UART_Type) SetSWFC_CONF1_XON_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF1.Reg, volatile.LoadUint32(&o.SWFC_CONF1.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetSWFC_CONF1_XON_THRESHOLD() uint32 {
	return volatile.LoadUint32(&o.SWFC_CONF1.Reg) & 0xff
}
func (o *UART_Type) SetSWFC_CONF1_XOFF_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF1.Reg, volatile.LoadUint32(&o.SWFC_CONF1.Reg)&^(0xff00)|value<<8)
}
func (o *UART_Type) GetSWFC_CONF1_XOFF_THRESHOLD() uint32 {
	return (volatile.LoadUint32(&o.SWFC_CONF1.Reg) & 0xff00) >> 8
}

// UART.TXBRK_CONF: Tx Break character configuration
func (o *UART_Type) SetTXBRK_CONF_TX_BRK_NUM(value uint32) {
	volatile.StoreUint32(&o.TXBRK_CONF.Reg, volatile.LoadUint32(&o.TXBRK_CONF.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetTXBRK_CONF_TX_BRK_NUM() uint32 {
	return volatile.LoadUint32(&o.TXBRK_CONF.Reg) & 0xff
}

// UART.IDLE_CONF: Frame-end idle configuration
func (o *UART_Type) SetIDLE_CONF_RX_IDLE_THRHD(value uint32) {
	volatile.StoreUint32(&o.IDLE_CONF.Reg, volatile.LoadUint32(&o.IDLE_CONF.Reg)&^(0x3ff)|value)
}
func (o *UART_Type) GetIDLE_CONF_RX_IDLE_THRHD() uint32 {
	return volatile.LoadUint32(&o.IDLE_CONF.Reg) & 0x3ff
}
func (o *UART_Type) SetIDLE_CONF_TX_IDLE_NUM(value uint32) {
	volatile.StoreUint32(&o.IDLE_CONF.Reg, volatile.LoadUint32(&o.IDLE_CONF.Reg)&^(0xffc00)|value<<10)
}
func (o *UART_Type) GetIDLE_CONF_TX_IDLE_NUM() uint32 {
	return (volatile.LoadUint32(&o.IDLE_CONF.Reg) & 0xffc00) >> 10
}

// UART.RS485_CONF: RS485 mode configuration
func (o *UART_Type) SetRS485_CONF_RS485_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetRS485_CONF_RS485_EN() uint32 {
	return volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x1
}
func (o *UART_Type) SetRS485_CONF_DL0_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetRS485_CONF_DL0_EN() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetRS485_CONF_DL1_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetRS485_CONF_DL1_EN() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetRS485_CONF_RS485TX_RX_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetRS485_CONF_RS485TX_RX_EN() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetRS485_CONF_RS485RXBY_TX_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetRS485_CONF_RS485RXBY_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetRS485_CONF_RS485_RX_DLY_NUM(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetRS485_CONF_RS485_RX_DLY_NUM() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetRS485_CONF_RS485_TX_DLY_NUM(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x3c0)|value<<6)
}
func (o *UART_Type) GetRS485_CONF_RS485_TX_DLY_NUM() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x3c0) >> 6
}

// UART.AT_CMD_PRECNT: Pre-sequence timing configuration
func (o *UART_Type) SetAT_CMD_PRECNT_PRE_IDLE_NUM(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_PRECNT.Reg, volatile.LoadUint32(&o.AT_CMD_PRECNT.Reg)&^(0xffff)|value)
}
func (o *UART_Type) GetAT_CMD_PRECNT_PRE_IDLE_NUM() uint32 {
	return volatile.LoadUint32(&o.AT_CMD_PRECNT.Reg) & 0xffff
}

// UART.AT_CMD_POSTCNT: Post-sequence timing configuration
func (o *UART_Type) SetAT_CMD_POSTCNT_POST_IDLE_NUM(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_POSTCNT.Reg, volatile.LoadUint32(&o.AT_CMD_POSTCNT.Reg)&^(0xffff)|value)
}
func (o *UART_Type) GetAT_CMD_POSTCNT_POST_IDLE_NUM() uint32 {
	return volatile.LoadUint32(&o.AT_CMD_POSTCNT.Reg) & 0xffff
}

// UART.AT_CMD_GAPTOUT: Timeout configuration
func (o *UART_Type) SetAT_CMD_GAPTOUT_RX_GAP_TOUT(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_GAPTOUT.Reg, volatile.LoadUint32(&o.AT_CMD_GAPTOUT.Reg)&^(0xffff)|value)
}
func (o *UART_Type) GetAT_CMD_GAPTOUT_RX_GAP_TOUT() uint32 {
	return volatile.LoadUint32(&o.AT_CMD_GAPTOUT.Reg) & 0xffff
}

// UART.AT_CMD_CHAR: AT escape sequence detection configuration
func (o *UART_Type) SetAT_CMD_CHAR(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_CHAR.Reg, volatile.LoadUint32(&o.AT_CMD_CHAR.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetAT_CMD_CHAR() uint32 {
	return volatile.LoadUint32(&o.AT_CMD_CHAR.Reg) & 0xff
}
func (o *UART_Type) SetAT_CMD_CHAR_CHAR_NUM(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_CHAR.Reg, volatile.LoadUint32(&o.AT_CMD_CHAR.Reg)&^(0xff00)|value<<8)
}
func (o *UART_Type) GetAT_CMD_CHAR_CHAR_NUM() uint32 {
	return (volatile.LoadUint32(&o.AT_CMD_CHAR.Reg) & 0xff00) >> 8
}

// UART.MEM_CONF: UART memory power configuration
func (o *UART_Type) SetMEM_CONF_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *UART_Type) GetMEM_CONF_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x2000000) >> 25
}
func (o *UART_Type) SetMEM_CONF_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *UART_Type) GetMEM_CONF_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x4000000) >> 26
}

// UART.TOUT_CONF: UART threshold and allocation configuration
func (o *UART_Type) SetTOUT_CONF_RX_TOUT_EN(value uint32) {
	volatile.StoreUint32(&o.TOUT_CONF.Reg, volatile.LoadUint32(&o.TOUT_CONF.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetTOUT_CONF_RX_TOUT_EN() uint32 {
	return volatile.LoadUint32(&o.TOUT_CONF.Reg) & 0x1
}
func (o *UART_Type) SetTOUT_CONF_RX_TOUT_FLOW_DIS(value uint32) {
	volatile.StoreUint32(&o.TOUT_CONF.Reg, volatile.LoadUint32(&o.TOUT_CONF.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetTOUT_CONF_RX_TOUT_FLOW_DIS() uint32 {
	return (volatile.LoadUint32(&o.TOUT_CONF.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetTOUT_CONF_RX_TOUT_THRHD(value uint32) {
	volatile.StoreUint32(&o.TOUT_CONF.Reg, volatile.LoadUint32(&o.TOUT_CONF.Reg)&^(0xffc)|value<<2)
}
func (o *UART_Type) GetTOUT_CONF_RX_TOUT_THRHD() uint32 {
	return (volatile.LoadUint32(&o.TOUT_CONF.Reg) & 0xffc) >> 2
}

// UART.MEM_TX_STATUS: Tx-SRAM write and read offset address.
func (o *UART_Type) SetMEM_TX_STATUS_TX_SRAM_WADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_TX_STATUS.Reg, volatile.LoadUint32(&o.MEM_TX_STATUS.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetMEM_TX_STATUS_TX_SRAM_WADDR() uint32 {
	return volatile.LoadUint32(&o.MEM_TX_STATUS.Reg) & 0xff
}
func (o *UART_Type) SetMEM_TX_STATUS_TX_SRAM_RADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_TX_STATUS.Reg, volatile.LoadUint32(&o.MEM_TX_STATUS.Reg)&^(0x1fe00)|value<<9)
}
func (o *UART_Type) GetMEM_TX_STATUS_TX_SRAM_RADDR() uint32 {
	return (volatile.LoadUint32(&o.MEM_TX_STATUS.Reg) & 0x1fe00) >> 9
}

// UART.MEM_RX_STATUS: Rx-SRAM write and read offset address.
func (o *UART_Type) SetMEM_RX_STATUS_RX_SRAM_RADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_RX_STATUS.Reg, volatile.LoadUint32(&o.MEM_RX_STATUS.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetMEM_RX_STATUS_RX_SRAM_RADDR() uint32 {
	return volatile.LoadUint32(&o.MEM_RX_STATUS.Reg) & 0xff
}
func (o *UART_Type) SetMEM_RX_STATUS_RX_SRAM_WADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_RX_STATUS.Reg, volatile.LoadUint32(&o.MEM_RX_STATUS.Reg)&^(0x1fe00)|value<<9)
}
func (o *UART_Type) GetMEM_RX_STATUS_RX_SRAM_WADDR() uint32 {
	return (volatile.LoadUint32(&o.MEM_RX_STATUS.Reg) & 0x1fe00) >> 9
}

// UART.FSM_STATUS: UART transmit and receive status.
func (o *UART_Type) SetFSM_STATUS_ST_URX_OUT(value uint32) {
	volatile.StoreUint32(&o.FSM_STATUS.Reg, volatile.LoadUint32(&o.FSM_STATUS.Reg)&^(0xf)|value)
}
func (o *UART_Type) GetFSM_STATUS_ST_URX_OUT() uint32 {
	return volatile.LoadUint32(&o.FSM_STATUS.Reg) & 0xf
}
func (o *UART_Type) SetFSM_STATUS_ST_UTX_OUT(value uint32) {
	volatile.StoreUint32(&o.FSM_STATUS.Reg, volatile.LoadUint32(&o.FSM_STATUS.Reg)&^(0xf0)|value<<4)
}
func (o *UART_Type) GetFSM_STATUS_ST_UTX_OUT() uint32 {
	return (volatile.LoadUint32(&o.FSM_STATUS.Reg) & 0xf0) >> 4
}

// UART.POSPULSE: Autobaud high pulse register
func (o *UART_Type) SetPOSPULSE_POSEDGE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.POSPULSE.Reg, volatile.LoadUint32(&o.POSPULSE.Reg)&^(0xfff)|value)
}
func (o *UART_Type) GetPOSPULSE_POSEDGE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.POSPULSE.Reg) & 0xfff
}

// UART.NEGPULSE: Autobaud low pulse register
func (o *UART_Type) SetNEGPULSE_NEGEDGE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.NEGPULSE.Reg, volatile.LoadUint32(&o.NEGPULSE.Reg)&^(0xfff)|value)
}
func (o *UART_Type) GetNEGPULSE_NEGEDGE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.NEGPULSE.Reg) & 0xfff
}

// UART.LOWPULSE: Autobaud minimum low pulse duration register
func (o *UART_Type) SetLOWPULSE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.LOWPULSE.Reg, volatile.LoadUint32(&o.LOWPULSE.Reg)&^(0xfff)|value)
}
func (o *UART_Type) GetLOWPULSE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.LOWPULSE.Reg) & 0xfff
}

// UART.HIGHPULSE: Autobaud minimum high pulse duration register
func (o *UART_Type) SetHIGHPULSE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.HIGHPULSE.Reg, volatile.LoadUint32(&o.HIGHPULSE.Reg)&^(0xfff)|value)
}
func (o *UART_Type) GetHIGHPULSE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.HIGHPULSE.Reg) & 0xfff
}

// UART.RXD_CNT: Autobaud edge change count register
func (o *UART_Type) SetRXD_CNT_RXD_EDGE_CNT(value uint32) {
	volatile.StoreUint32(&o.RXD_CNT.Reg, volatile.LoadUint32(&o.RXD_CNT.Reg)&^(0x3ff)|value)
}
func (o *UART_Type) GetRXD_CNT_RXD_EDGE_CNT() uint32 {
	return volatile.LoadUint32(&o.RXD_CNT.Reg) & 0x3ff
}

// UART.CLK_CONF: UART core clock configuration
func (o *UART_Type) SetCLK_CONF_TX_SCLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *UART_Type) GetCLK_CONF_TX_SCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x1000000) >> 24
}
func (o *UART_Type) SetCLK_CONF_SCLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *UART_Type) GetCLK_CONF_SCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x2000000) >> 25
}
func (o *UART_Type) SetCLK_CONF_TX_RST_CORE(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *UART_Type) GetCLK_CONF_TX_RST_CORE() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x4000000) >> 26
}
func (o *UART_Type) SetCLK_CONF_RST_CORE(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *UART_Type) GetCLK_CONF_RST_CORE() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x8000000) >> 27
}

// UART.DATE: UART Version register
func (o *UART_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *UART_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// UART.AFIFO_STATUS: UART AFIFO Status
func (o *UART_Type) SetAFIFO_STATUS_TX_AFIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.AFIFO_STATUS.Reg, volatile.LoadUint32(&o.AFIFO_STATUS.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetAFIFO_STATUS_TX_AFIFO_FULL() uint32 {
	return volatile.LoadUint32(&o.AFIFO_STATUS.Reg) & 0x1
}
func (o *UART_Type) SetAFIFO_STATUS_TX_AFIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.AFIFO_STATUS.Reg, volatile.LoadUint32(&o.AFIFO_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetAFIFO_STATUS_TX_AFIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.AFIFO_STATUS.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetAFIFO_STATUS_RX_AFIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.AFIFO_STATUS.Reg, volatile.LoadUint32(&o.AFIFO_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetAFIFO_STATUS_RX_AFIFO_FULL() uint32 {
	return (volatile.LoadUint32(&o.AFIFO_STATUS.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetAFIFO_STATUS_RX_AFIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.AFIFO_STATUS.Reg, volatile.LoadUint32(&o.AFIFO_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetAFIFO_STATUS_RX_AFIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.AFIFO_STATUS.Reg) & 0x8) >> 3
}

// UART.REG_UPDATE: UART Registers Configuration Update register
func (o *UART_Type) SetREG_UPDATE(value uint32) {
	volatile.StoreUint32(&o.REG_UPDATE.Reg, volatile.LoadUint32(&o.REG_UPDATE.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetREG_UPDATE() uint32 {
	return volatile.LoadUint32(&o.REG_UPDATE.Reg) & 0x1
}

// UART.ID: UART ID register
func (o *UART_Type) SetID(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, value)
}
func (o *UART_Type) GetID() uint32 {
	return volatile.LoadUint32(&o.ID.Reg)
}

// Universal Host Controller Interface 0
type UHCI_Type struct {
	CONF0        volatile.Register32 // 0x0
	INT_RAW      volatile.Register32 // 0x4
	INT_ST       volatile.Register32 // 0x8
	INT_ENA      volatile.Register32 // 0xC
	INT_CLR      volatile.Register32 // 0x10
	CONF1        volatile.Register32 // 0x14
	STATE0       volatile.Register32 // 0x18
	STATE1       volatile.Register32 // 0x1C
	ESCAPE_CONF  volatile.Register32 // 0x20
	HUNG_CONF    volatile.Register32 // 0x24
	ACK_NUM      volatile.Register32 // 0x28
	RX_HEAD      volatile.Register32 // 0x2C
	QUICK_SENT   volatile.Register32 // 0x30
	REG_Q0_WORD0 volatile.Register32 // 0x34
	REG_Q0_WORD1 volatile.Register32 // 0x38
	REG_Q1_WORD0 volatile.Register32 // 0x3C
	REG_Q1_WORD1 volatile.Register32 // 0x40
	REG_Q2_WORD0 volatile.Register32 // 0x44
	REG_Q2_WORD1 volatile.Register32 // 0x48
	REG_Q3_WORD0 volatile.Register32 // 0x4C
	REG_Q3_WORD1 volatile.Register32 // 0x50
	REG_Q4_WORD0 volatile.Register32 // 0x54
	REG_Q4_WORD1 volatile.Register32 // 0x58
	REG_Q5_WORD0 volatile.Register32 // 0x5C
	REG_Q5_WORD1 volatile.Register32 // 0x60
	REG_Q6_WORD0 volatile.Register32 // 0x64
	REG_Q6_WORD1 volatile.Register32 // 0x68
	ESC_CONF0    volatile.Register32 // 0x6C
	ESC_CONF1    volatile.Register32 // 0x70
	ESC_CONF2    volatile.Register32 // 0x74
	ESC_CONF3    volatile.Register32 // 0x78
	PKT_THRES    volatile.Register32 // 0x7C
	DATE         volatile.Register32 // 0x80
}

// UHCI.CONF0: a
func (o *UHCI_Type) SetCONF0_TX_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetCONF0_TX_RST() uint32 {
	return volatile.LoadUint32(&o.CONF0.Reg) & 0x1
}
func (o *UHCI_Type) SetCONF0_RX_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetCONF0_RX_RST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetCONF0_UART0_CE(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetCONF0_UART0_CE() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetCONF0_UART1_CE(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetCONF0_UART1_CE() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetCONF0_SEPER_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetCONF0_SEPER_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetCONF0_HEAD_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x40)|value<<6)
}
func (o *UHCI_Type) GetCONF0_HEAD_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x40) >> 6
}
func (o *UHCI_Type) SetCONF0_CRC_REC_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetCONF0_CRC_REC_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x80) >> 7
}
func (o *UHCI_Type) SetCONF0_UART_IDLE_EOF_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x100)|value<<8)
}
func (o *UHCI_Type) GetCONF0_UART_IDLE_EOF_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x100) >> 8
}
func (o *UHCI_Type) SetCONF0_LEN_EOF_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x200)|value<<9)
}
func (o *UHCI_Type) GetCONF0_LEN_EOF_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x200) >> 9
}
func (o *UHCI_Type) SetCONF0_ENCODE_CRC_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x400)|value<<10)
}
func (o *UHCI_Type) GetCONF0_ENCODE_CRC_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x400) >> 10
}
func (o *UHCI_Type) SetCONF0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x800)|value<<11)
}
func (o *UHCI_Type) GetCONF0_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x800) >> 11
}
func (o *UHCI_Type) SetCONF0_UART_RX_BRK_EOF_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *UHCI_Type) GetCONF0_UART_RX_BRK_EOF_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x1000) >> 12
}

// UHCI.INT_RAW: a
func (o *UHCI_Type) SetINT_RAW_RX_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetINT_RAW_RX_START_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *UHCI_Type) SetINT_RAW_TX_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetINT_RAW_TX_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetINT_RAW_RX_HUNG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetINT_RAW_RX_HUNG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetINT_RAW_TX_HUNG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetINT_RAW_TX_HUNG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetINT_RAW_SEND_S_REG_Q_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *UHCI_Type) GetINT_RAW_SEND_S_REG_Q_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *UHCI_Type) SetINT_RAW_SEND_A_REG_Q_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetINT_RAW_SEND_A_REG_Q_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetINT_RAW_OUT_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *UHCI_Type) GetINT_RAW_OUT_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *UHCI_Type) SetINT_RAW_APP_CTRL0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetINT_RAW_APP_CTRL0_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *UHCI_Type) SetINT_RAW_APP_CTRL1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *UHCI_Type) GetINT_RAW_APP_CTRL1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}

// UHCI.INT_ST: a
func (o *UHCI_Type) SetINT_ST_RX_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetINT_ST_RX_START_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *UHCI_Type) SetINT_ST_TX_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetINT_ST_TX_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetINT_ST_RX_HUNG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetINT_ST_RX_HUNG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetINT_ST_TX_HUNG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetINT_ST_TX_HUNG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetINT_ST_SEND_S_REG_Q_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *UHCI_Type) GetINT_ST_SEND_S_REG_Q_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *UHCI_Type) SetINT_ST_SEND_A_REG_Q_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetINT_ST_SEND_A_REG_Q_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetINT_ST_OUTLINK_EOF_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *UHCI_Type) GetINT_ST_OUTLINK_EOF_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *UHCI_Type) SetINT_ST_APP_CTRL0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetINT_ST_APP_CTRL0_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *UHCI_Type) SetINT_ST_APP_CTRL1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *UHCI_Type) GetINT_ST_APP_CTRL1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}

// UHCI.INT_ENA: a
func (o *UHCI_Type) SetINT_ENA_RX_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetINT_ENA_RX_START_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *UHCI_Type) SetINT_ENA_TX_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetINT_ENA_TX_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetINT_ENA_RX_HUNG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetINT_ENA_RX_HUNG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetINT_ENA_TX_HUNG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetINT_ENA_TX_HUNG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetINT_ENA_SEND_S_REG_Q_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *UHCI_Type) GetINT_ENA_SEND_S_REG_Q_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *UHCI_Type) SetINT_ENA_SEND_A_REG_Q_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetINT_ENA_SEND_A_REG_Q_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetINT_ENA_OUTLINK_EOF_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *UHCI_Type) GetINT_ENA_OUTLINK_EOF_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *UHCI_Type) SetINT_ENA_APP_CTRL0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetINT_ENA_APP_CTRL0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *UHCI_Type) SetINT_ENA_APP_CTRL1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *UHCI_Type) GetINT_ENA_APP_CTRL1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}

// UHCI.INT_CLR: a
func (o *UHCI_Type) SetINT_CLR_RX_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetINT_CLR_RX_START_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *UHCI_Type) SetINT_CLR_TX_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetINT_CLR_TX_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetINT_CLR_RX_HUNG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetINT_CLR_RX_HUNG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetINT_CLR_TX_HUNG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetINT_CLR_TX_HUNG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetINT_CLR_SEND_S_REG_Q_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *UHCI_Type) GetINT_CLR_SEND_S_REG_Q_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *UHCI_Type) SetINT_CLR_SEND_A_REG_Q_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetINT_CLR_SEND_A_REG_Q_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetINT_CLR_OUTLINK_EOF_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *UHCI_Type) GetINT_CLR_OUTLINK_EOF_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *UHCI_Type) SetINT_CLR_APP_CTRL0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetINT_CLR_APP_CTRL0_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *UHCI_Type) SetINT_CLR_APP_CTRL1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *UHCI_Type) GetINT_CLR_APP_CTRL1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}

// UHCI.CONF1: a
func (o *UHCI_Type) SetCONF1_CHECK_SUM_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetCONF1_CHECK_SUM_EN() uint32 {
	return volatile.LoadUint32(&o.CONF1.Reg) & 0x1
}
func (o *UHCI_Type) SetCONF1_CHECK_SEQ_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetCONF1_CHECK_SEQ_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetCONF1_CRC_DISABLE(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetCONF1_CRC_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetCONF1_SAVE_HEAD(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetCONF1_SAVE_HEAD() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetCONF1_TX_CHECK_SUM_RE(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x10)|value<<4)
}
func (o *UHCI_Type) GetCONF1_TX_CHECK_SUM_RE() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x10) >> 4
}
func (o *UHCI_Type) SetCONF1_TX_ACK_NUM_RE(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetCONF1_TX_ACK_NUM_RE() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetCONF1_WAIT_SW_START(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetCONF1_WAIT_SW_START() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x80) >> 7
}
func (o *UHCI_Type) SetCONF1_SW_START(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x100)|value<<8)
}
func (o *UHCI_Type) GetCONF1_SW_START() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x100) >> 8
}

// UHCI.STATE0: a
func (o *UHCI_Type) SetSTATE0_RX_ERR_CAUSE(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x7)|value)
}
func (o *UHCI_Type) GetSTATE0_RX_ERR_CAUSE() uint32 {
	return volatile.LoadUint32(&o.STATE0.Reg) & 0x7
}
func (o *UHCI_Type) SetSTATE0_DECODE_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x38)|value<<3)
}
func (o *UHCI_Type) GetSTATE0_DECODE_STATE() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x38) >> 3
}

// UHCI.STATE1: a
func (o *UHCI_Type) SetSTATE1_ENCODE_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE1.Reg, volatile.LoadUint32(&o.STATE1.Reg)&^(0x7)|value)
}
func (o *UHCI_Type) GetSTATE1_ENCODE_STATE() uint32 {
	return volatile.LoadUint32(&o.STATE1.Reg) & 0x7
}

// UHCI.ESCAPE_CONF: a
func (o *UHCI_Type) SetESCAPE_CONF_TX_C0_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetESCAPE_CONF_TX_C0_ESC_EN() uint32 {
	return volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x1
}
func (o *UHCI_Type) SetESCAPE_CONF_TX_DB_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetESCAPE_CONF_TX_DB_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetESCAPE_CONF_TX_11_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetESCAPE_CONF_TX_11_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetESCAPE_CONF_TX_13_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetESCAPE_CONF_TX_13_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetESCAPE_CONF_RX_C0_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x10)|value<<4)
}
func (o *UHCI_Type) GetESCAPE_CONF_RX_C0_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x10) >> 4
}
func (o *UHCI_Type) SetESCAPE_CONF_RX_DB_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetESCAPE_CONF_RX_DB_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetESCAPE_CONF_RX_11_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x40)|value<<6)
}
func (o *UHCI_Type) GetESCAPE_CONF_RX_11_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x40) >> 6
}
func (o *UHCI_Type) SetESCAPE_CONF_RX_13_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetESCAPE_CONF_RX_13_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x80) >> 7
}

// UHCI.HUNG_CONF: a
func (o *UHCI_Type) SetHUNG_CONF_TXFIFO_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0xff)|value)
}
func (o *UHCI_Type) GetHUNG_CONF_TXFIFO_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0xff
}
func (o *UHCI_Type) SetHUNG_CONF_TXFIFO_TIMEOUT_SHIFT(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0x700)|value<<8)
}
func (o *UHCI_Type) GetHUNG_CONF_TXFIFO_TIMEOUT_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0x700) >> 8
}
func (o *UHCI_Type) SetHUNG_CONF_TXFIFO_TIMEOUT_ENA(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0x800)|value<<11)
}
func (o *UHCI_Type) GetHUNG_CONF_TXFIFO_TIMEOUT_ENA() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0x800) >> 11
}
func (o *UHCI_Type) SetHUNG_CONF_RXFIFO_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0xff000)|value<<12)
}
func (o *UHCI_Type) GetHUNG_CONF_RXFIFO_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0xff000) >> 12
}
func (o *UHCI_Type) SetHUNG_CONF_RXFIFO_TIMEOUT_SHIFT(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0x700000)|value<<20)
}
func (o *UHCI_Type) GetHUNG_CONF_RXFIFO_TIMEOUT_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0x700000) >> 20
}
func (o *UHCI_Type) SetHUNG_CONF_RXFIFO_TIMEOUT_ENA(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *UHCI_Type) GetHUNG_CONF_RXFIFO_TIMEOUT_ENA() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0x800000) >> 23
}

// UHCI.ACK_NUM: a
func (o *UHCI_Type) SetACK_NUM(value uint32) {
	volatile.StoreUint32(&o.ACK_NUM.Reg, volatile.LoadUint32(&o.ACK_NUM.Reg)&^(0x7)|value)
}
func (o *UHCI_Type) GetACK_NUM() uint32 {
	return volatile.LoadUint32(&o.ACK_NUM.Reg) & 0x7
}
func (o *UHCI_Type) SetACK_NUM_LOAD(value uint32) {
	volatile.StoreUint32(&o.ACK_NUM.Reg, volatile.LoadUint32(&o.ACK_NUM.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetACK_NUM_LOAD() uint32 {
	return (volatile.LoadUint32(&o.ACK_NUM.Reg) & 0x8) >> 3
}

// UHCI.RX_HEAD: a
func (o *UHCI_Type) SetRX_HEAD(value uint32) {
	volatile.StoreUint32(&o.RX_HEAD.Reg, value)
}
func (o *UHCI_Type) GetRX_HEAD() uint32 {
	return volatile.LoadUint32(&o.RX_HEAD.Reg)
}

// UHCI.QUICK_SENT: a
func (o *UHCI_Type) SetQUICK_SENT_SINGLE_SEND_NUM(value uint32) {
	volatile.StoreUint32(&o.QUICK_SENT.Reg, volatile.LoadUint32(&o.QUICK_SENT.Reg)&^(0x7)|value)
}
func (o *UHCI_Type) GetQUICK_SENT_SINGLE_SEND_NUM() uint32 {
	return volatile.LoadUint32(&o.QUICK_SENT.Reg) & 0x7
}
func (o *UHCI_Type) SetQUICK_SENT_SINGLE_SEND_EN(value uint32) {
	volatile.StoreUint32(&o.QUICK_SENT.Reg, volatile.LoadUint32(&o.QUICK_SENT.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetQUICK_SENT_SINGLE_SEND_EN() uint32 {
	return (volatile.LoadUint32(&o.QUICK_SENT.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetQUICK_SENT_ALWAYS_SEND_NUM(value uint32) {
	volatile.StoreUint32(&o.QUICK_SENT.Reg, volatile.LoadUint32(&o.QUICK_SENT.Reg)&^(0x70)|value<<4)
}
func (o *UHCI_Type) GetQUICK_SENT_ALWAYS_SEND_NUM() uint32 {
	return (volatile.LoadUint32(&o.QUICK_SENT.Reg) & 0x70) >> 4
}
func (o *UHCI_Type) SetQUICK_SENT_ALWAYS_SEND_EN(value uint32) {
	volatile.StoreUint32(&o.QUICK_SENT.Reg, volatile.LoadUint32(&o.QUICK_SENT.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetQUICK_SENT_ALWAYS_SEND_EN() uint32 {
	return (volatile.LoadUint32(&o.QUICK_SENT.Reg) & 0x80) >> 7
}

// UHCI.REG_Q0_WORD0: a
func (o *UHCI_Type) SetREG_Q0_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q0_WORD0.Reg, value)
}
func (o *UHCI_Type) GetREG_Q0_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q0_WORD0.Reg)
}

// UHCI.REG_Q0_WORD1: a
func (o *UHCI_Type) SetREG_Q0_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q0_WORD1.Reg, value)
}
func (o *UHCI_Type) GetREG_Q0_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q0_WORD1.Reg)
}

// UHCI.REG_Q1_WORD0: a
func (o *UHCI_Type) SetREG_Q1_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q1_WORD0.Reg, value)
}
func (o *UHCI_Type) GetREG_Q1_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q1_WORD0.Reg)
}

// UHCI.REG_Q1_WORD1: a
func (o *UHCI_Type) SetREG_Q1_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q1_WORD1.Reg, value)
}
func (o *UHCI_Type) GetREG_Q1_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q1_WORD1.Reg)
}

// UHCI.REG_Q2_WORD0: a
func (o *UHCI_Type) SetREG_Q2_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q2_WORD0.Reg, value)
}
func (o *UHCI_Type) GetREG_Q2_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q2_WORD0.Reg)
}

// UHCI.REG_Q2_WORD1: a
func (o *UHCI_Type) SetREG_Q2_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q2_WORD1.Reg, value)
}
func (o *UHCI_Type) GetREG_Q2_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q2_WORD1.Reg)
}

// UHCI.REG_Q3_WORD0: a
func (o *UHCI_Type) SetREG_Q3_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q3_WORD0.Reg, value)
}
func (o *UHCI_Type) GetREG_Q3_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q3_WORD0.Reg)
}

// UHCI.REG_Q3_WORD1: a
func (o *UHCI_Type) SetREG_Q3_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q3_WORD1.Reg, value)
}
func (o *UHCI_Type) GetREG_Q3_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q3_WORD1.Reg)
}

// UHCI.REG_Q4_WORD0: a
func (o *UHCI_Type) SetREG_Q4_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q4_WORD0.Reg, value)
}
func (o *UHCI_Type) GetREG_Q4_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q4_WORD0.Reg)
}

// UHCI.REG_Q4_WORD1: a
func (o *UHCI_Type) SetREG_Q4_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q4_WORD1.Reg, value)
}
func (o *UHCI_Type) GetREG_Q4_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q4_WORD1.Reg)
}

// UHCI.REG_Q5_WORD0: a
func (o *UHCI_Type) SetREG_Q5_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q5_WORD0.Reg, value)
}
func (o *UHCI_Type) GetREG_Q5_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q5_WORD0.Reg)
}

// UHCI.REG_Q5_WORD1: a
func (o *UHCI_Type) SetREG_Q5_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q5_WORD1.Reg, value)
}
func (o *UHCI_Type) GetREG_Q5_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q5_WORD1.Reg)
}

// UHCI.REG_Q6_WORD0: a
func (o *UHCI_Type) SetREG_Q6_WORD0(value uint32) {
	volatile.StoreUint32(&o.REG_Q6_WORD0.Reg, value)
}
func (o *UHCI_Type) GetREG_Q6_WORD0() uint32 {
	return volatile.LoadUint32(&o.REG_Q6_WORD0.Reg)
}

// UHCI.REG_Q6_WORD1: a
func (o *UHCI_Type) SetREG_Q6_WORD1(value uint32) {
	volatile.StoreUint32(&o.REG_Q6_WORD1.Reg, value)
}
func (o *UHCI_Type) GetREG_Q6_WORD1() uint32 {
	return volatile.LoadUint32(&o.REG_Q6_WORD1.Reg)
}

// UHCI.ESC_CONF0: a
func (o *UHCI_Type) SetESC_CONF0_SEPER_CHAR(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF0.Reg, volatile.LoadUint32(&o.ESC_CONF0.Reg)&^(0xff)|value)
}
func (o *UHCI_Type) GetESC_CONF0_SEPER_CHAR() uint32 {
	return volatile.LoadUint32(&o.ESC_CONF0.Reg) & 0xff
}
func (o *UHCI_Type) SetESC_CONF0_SEPER_ESC_CHAR0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF0.Reg, volatile.LoadUint32(&o.ESC_CONF0.Reg)&^(0xff00)|value<<8)
}
func (o *UHCI_Type) GetESC_CONF0_SEPER_ESC_CHAR0() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF0.Reg) & 0xff00) >> 8
}
func (o *UHCI_Type) SetESC_CONF0_SEPER_ESC_CHAR1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF0.Reg, volatile.LoadUint32(&o.ESC_CONF0.Reg)&^(0xff0000)|value<<16)
}
func (o *UHCI_Type) GetESC_CONF0_SEPER_ESC_CHAR1() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF0.Reg) & 0xff0000) >> 16
}

// UHCI.ESC_CONF1: a
func (o *UHCI_Type) SetESC_CONF1_ESC_SEQ0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF1.Reg, volatile.LoadUint32(&o.ESC_CONF1.Reg)&^(0xff)|value)
}
func (o *UHCI_Type) GetESC_CONF1_ESC_SEQ0() uint32 {
	return volatile.LoadUint32(&o.ESC_CONF1.Reg) & 0xff
}
func (o *UHCI_Type) SetESC_CONF1_ESC_SEQ0_CHAR0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF1.Reg, volatile.LoadUint32(&o.ESC_CONF1.Reg)&^(0xff00)|value<<8)
}
func (o *UHCI_Type) GetESC_CONF1_ESC_SEQ0_CHAR0() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF1.Reg) & 0xff00) >> 8
}
func (o *UHCI_Type) SetESC_CONF1_ESC_SEQ0_CHAR1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF1.Reg, volatile.LoadUint32(&o.ESC_CONF1.Reg)&^(0xff0000)|value<<16)
}
func (o *UHCI_Type) GetESC_CONF1_ESC_SEQ0_CHAR1() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF1.Reg) & 0xff0000) >> 16
}

// UHCI.ESC_CONF2: a
func (o *UHCI_Type) SetESC_CONF2_ESC_SEQ1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF2.Reg, volatile.LoadUint32(&o.ESC_CONF2.Reg)&^(0xff)|value)
}
func (o *UHCI_Type) GetESC_CONF2_ESC_SEQ1() uint32 {
	return volatile.LoadUint32(&o.ESC_CONF2.Reg) & 0xff
}
func (o *UHCI_Type) SetESC_CONF2_ESC_SEQ1_CHAR0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF2.Reg, volatile.LoadUint32(&o.ESC_CONF2.Reg)&^(0xff00)|value<<8)
}
func (o *UHCI_Type) GetESC_CONF2_ESC_SEQ1_CHAR0() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF2.Reg) & 0xff00) >> 8
}
func (o *UHCI_Type) SetESC_CONF2_ESC_SEQ1_CHAR1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF2.Reg, volatile.LoadUint32(&o.ESC_CONF2.Reg)&^(0xff0000)|value<<16)
}
func (o *UHCI_Type) GetESC_CONF2_ESC_SEQ1_CHAR1() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF2.Reg) & 0xff0000) >> 16
}

// UHCI.ESC_CONF3: a
func (o *UHCI_Type) SetESC_CONF3_ESC_SEQ2(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF3.Reg, volatile.LoadUint32(&o.ESC_CONF3.Reg)&^(0xff)|value)
}
func (o *UHCI_Type) GetESC_CONF3_ESC_SEQ2() uint32 {
	return volatile.LoadUint32(&o.ESC_CONF3.Reg) & 0xff
}
func (o *UHCI_Type) SetESC_CONF3_ESC_SEQ2_CHAR0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF3.Reg, volatile.LoadUint32(&o.ESC_CONF3.Reg)&^(0xff00)|value<<8)
}
func (o *UHCI_Type) GetESC_CONF3_ESC_SEQ2_CHAR0() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF3.Reg) & 0xff00) >> 8
}
func (o *UHCI_Type) SetESC_CONF3_ESC_SEQ2_CHAR1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF3.Reg, volatile.LoadUint32(&o.ESC_CONF3.Reg)&^(0xff0000)|value<<16)
}
func (o *UHCI_Type) GetESC_CONF3_ESC_SEQ2_CHAR1() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF3.Reg) & 0xff0000) >> 16
}

// UHCI.PKT_THRES: a
func (o *UHCI_Type) SetPKT_THRES_PKT_THRS(value uint32) {
	volatile.StoreUint32(&o.PKT_THRES.Reg, volatile.LoadUint32(&o.PKT_THRES.Reg)&^(0x1fff)|value)
}
func (o *UHCI_Type) GetPKT_THRES_PKT_THRS() uint32 {
	return volatile.LoadUint32(&o.PKT_THRES.Reg) & 0x1fff
}

// UHCI.DATE: a
func (o *UHCI_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *UHCI_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Full-speed USB Serial/JTAG Controller
type USB_DEVICE_Type struct {
	EP1              volatile.Register32 // 0x0
	EP1_CONF         volatile.Register32 // 0x4
	INT_RAW          volatile.Register32 // 0x8
	INT_ST           volatile.Register32 // 0xC
	INT_ENA          volatile.Register32 // 0x10
	INT_CLR          volatile.Register32 // 0x14
	CONF0            volatile.Register32 // 0x18
	TEST             volatile.Register32 // 0x1C
	JFIFO_ST         volatile.Register32 // 0x20
	FRAM_NUM         volatile.Register32 // 0x24
	IN_EP0_ST        volatile.Register32 // 0x28
	IN_EP1_ST        volatile.Register32 // 0x2C
	IN_EP2_ST        volatile.Register32 // 0x30
	IN_EP3_ST        volatile.Register32 // 0x34
	OUT_EP0_ST       volatile.Register32 // 0x38
	OUT_EP1_ST       volatile.Register32 // 0x3C
	OUT_EP2_ST       volatile.Register32 // 0x40
	MISC_CONF        volatile.Register32 // 0x44
	MEM_CONF         volatile.Register32 // 0x48
	CHIP_RST         volatile.Register32 // 0x4C
	SET_LINE_CODE_W0 volatile.Register32 // 0x50
	SET_LINE_CODE_W1 volatile.Register32 // 0x54
	GET_LINE_CODE_W0 volatile.Register32 // 0x58
	GET_LINE_CODE_W1 volatile.Register32 // 0x5C
	CONFIG_UPDATE    volatile.Register32 // 0x60
	SER_AFIFO_CONFIG volatile.Register32 // 0x64
	BUS_RESET_ST     volatile.Register32 // 0x68
	_                [20]byte
	DATE             volatile.Register32 // 0x80
}

// USB_DEVICE.EP1: FIFO access for the CDC-ACM data IN and OUT endpoints.
func (o *USB_DEVICE_Type) SetEP1_RDWR_BYTE(value uint32) {
	volatile.StoreUint32(&o.EP1.Reg, volatile.LoadUint32(&o.EP1.Reg)&^(0xff)|value)
}
func (o *USB_DEVICE_Type) GetEP1_RDWR_BYTE() uint32 {
	return volatile.LoadUint32(&o.EP1.Reg) & 0xff
}

// USB_DEVICE.EP1_CONF: Configuration and control registers for the CDC-ACM FIFOs.
func (o *USB_DEVICE_Type) SetEP1_CONF_WR_DONE(value uint32) {
	volatile.StoreUint32(&o.EP1_CONF.Reg, volatile.LoadUint32(&o.EP1_CONF.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetEP1_CONF_WR_DONE() uint32 {
	return volatile.LoadUint32(&o.EP1_CONF.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetEP1_CONF_SERIAL_IN_EP_DATA_FREE(value uint32) {
	volatile.StoreUint32(&o.EP1_CONF.Reg, volatile.LoadUint32(&o.EP1_CONF.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetEP1_CONF_SERIAL_IN_EP_DATA_FREE() uint32 {
	return (volatile.LoadUint32(&o.EP1_CONF.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetEP1_CONF_SERIAL_OUT_EP_DATA_AVAIL(value uint32) {
	volatile.StoreUint32(&o.EP1_CONF.Reg, volatile.LoadUint32(&o.EP1_CONF.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetEP1_CONF_SERIAL_OUT_EP_DATA_AVAIL() uint32 {
	return (volatile.LoadUint32(&o.EP1_CONF.Reg) & 0x4) >> 2
}

// USB_DEVICE.INT_RAW: Interrupt raw status register.
func (o *USB_DEVICE_Type) SetINT_RAW_JTAG_IN_FLUSH_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetINT_RAW_JTAG_IN_FLUSH_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetINT_RAW_SOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetINT_RAW_SOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetINT_RAW_SERIAL_OUT_RECV_PKT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetINT_RAW_SERIAL_OUT_RECV_PKT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_Type) SetINT_RAW_SERIAL_IN_EMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_Type) GetINT_RAW_SERIAL_IN_EMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_Type) SetINT_RAW_PID_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_Type) GetINT_RAW_PID_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_Type) SetINT_RAW_CRC5_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_Type) GetINT_RAW_CRC5_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_Type) SetINT_RAW_CRC16_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_Type) GetINT_RAW_CRC16_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *USB_DEVICE_Type) SetINT_RAW_STUFF_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_Type) GetINT_RAW_STUFF_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *USB_DEVICE_Type) SetINT_RAW_IN_TOKEN_REC_IN_EP1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *USB_DEVICE_Type) GetINT_RAW_IN_TOKEN_REC_IN_EP1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *USB_DEVICE_Type) SetINT_RAW_USB_BUS_RESET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *USB_DEVICE_Type) GetINT_RAW_USB_BUS_RESET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *USB_DEVICE_Type) SetINT_RAW_OUT_EP1_ZERO_PAYLOAD_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *USB_DEVICE_Type) GetINT_RAW_OUT_EP1_ZERO_PAYLOAD_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *USB_DEVICE_Type) SetINT_RAW_OUT_EP2_ZERO_PAYLOAD_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *USB_DEVICE_Type) GetINT_RAW_OUT_EP2_ZERO_PAYLOAD_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *USB_DEVICE_Type) SetINT_RAW_RTS_CHG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *USB_DEVICE_Type) GetINT_RAW_RTS_CHG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *USB_DEVICE_Type) SetINT_RAW_DTR_CHG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *USB_DEVICE_Type) GetINT_RAW_DTR_CHG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *USB_DEVICE_Type) SetINT_RAW_GET_LINE_CODE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *USB_DEVICE_Type) GetINT_RAW_GET_LINE_CODE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *USB_DEVICE_Type) SetINT_RAW_SET_LINE_CODE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *USB_DEVICE_Type) GetINT_RAW_SET_LINE_CODE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}

// USB_DEVICE.INT_ST: Interrupt status register.
func (o *USB_DEVICE_Type) SetINT_ST_JTAG_IN_FLUSH_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetINT_ST_JTAG_IN_FLUSH_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetINT_ST_SOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetINT_ST_SOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetINT_ST_SERIAL_OUT_RECV_PKT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetINT_ST_SERIAL_OUT_RECV_PKT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_Type) SetINT_ST_SERIAL_IN_EMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_Type) GetINT_ST_SERIAL_IN_EMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_Type) SetINT_ST_PID_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_Type) GetINT_ST_PID_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_Type) SetINT_ST_CRC5_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_Type) GetINT_ST_CRC5_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_Type) SetINT_ST_CRC16_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_Type) GetINT_ST_CRC16_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *USB_DEVICE_Type) SetINT_ST_STUFF_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_Type) GetINT_ST_STUFF_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *USB_DEVICE_Type) SetINT_ST_IN_TOKEN_REC_IN_EP1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *USB_DEVICE_Type) GetINT_ST_IN_TOKEN_REC_IN_EP1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *USB_DEVICE_Type) SetINT_ST_USB_BUS_RESET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *USB_DEVICE_Type) GetINT_ST_USB_BUS_RESET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200) >> 9
}
func (o *USB_DEVICE_Type) SetINT_ST_OUT_EP1_ZERO_PAYLOAD_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *USB_DEVICE_Type) GetINT_ST_OUT_EP1_ZERO_PAYLOAD_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400) >> 10
}
func (o *USB_DEVICE_Type) SetINT_ST_OUT_EP2_ZERO_PAYLOAD_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *USB_DEVICE_Type) GetINT_ST_OUT_EP2_ZERO_PAYLOAD_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x800) >> 11
}
func (o *USB_DEVICE_Type) SetINT_ST_RTS_CHG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *USB_DEVICE_Type) GetINT_ST_RTS_CHG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *USB_DEVICE_Type) SetINT_ST_DTR_CHG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *USB_DEVICE_Type) GetINT_ST_DTR_CHG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000) >> 13
}
func (o *USB_DEVICE_Type) SetINT_ST_GET_LINE_CODE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *USB_DEVICE_Type) GetINT_ST_GET_LINE_CODE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000) >> 14
}
func (o *USB_DEVICE_Type) SetINT_ST_SET_LINE_CODE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *USB_DEVICE_Type) GetINT_ST_SET_LINE_CODE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000) >> 15
}

// USB_DEVICE.INT_ENA: Interrupt enable status register.
func (o *USB_DEVICE_Type) SetINT_ENA_JTAG_IN_FLUSH_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetINT_ENA_JTAG_IN_FLUSH_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetINT_ENA_SOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetINT_ENA_SOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetINT_ENA_SERIAL_OUT_RECV_PKT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetINT_ENA_SERIAL_OUT_RECV_PKT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_Type) SetINT_ENA_SERIAL_IN_EMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_Type) GetINT_ENA_SERIAL_IN_EMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_Type) SetINT_ENA_PID_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_Type) GetINT_ENA_PID_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_Type) SetINT_ENA_CRC5_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_Type) GetINT_ENA_CRC5_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_Type) SetINT_ENA_CRC16_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_Type) GetINT_ENA_CRC16_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *USB_DEVICE_Type) SetINT_ENA_STUFF_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_Type) GetINT_ENA_STUFF_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *USB_DEVICE_Type) SetINT_ENA_IN_TOKEN_REC_IN_EP1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *USB_DEVICE_Type) GetINT_ENA_IN_TOKEN_REC_IN_EP1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *USB_DEVICE_Type) SetINT_ENA_USB_BUS_RESET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *USB_DEVICE_Type) GetINT_ENA_USB_BUS_RESET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *USB_DEVICE_Type) SetINT_ENA_OUT_EP1_ZERO_PAYLOAD_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *USB_DEVICE_Type) GetINT_ENA_OUT_EP1_ZERO_PAYLOAD_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *USB_DEVICE_Type) SetINT_ENA_OUT_EP2_ZERO_PAYLOAD_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *USB_DEVICE_Type) GetINT_ENA_OUT_EP2_ZERO_PAYLOAD_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *USB_DEVICE_Type) SetINT_ENA_RTS_CHG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *USB_DEVICE_Type) GetINT_ENA_RTS_CHG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *USB_DEVICE_Type) SetINT_ENA_DTR_CHG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *USB_DEVICE_Type) GetINT_ENA_DTR_CHG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *USB_DEVICE_Type) SetINT_ENA_GET_LINE_CODE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *USB_DEVICE_Type) GetINT_ENA_GET_LINE_CODE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *USB_DEVICE_Type) SetINT_ENA_SET_LINE_CODE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *USB_DEVICE_Type) GetINT_ENA_SET_LINE_CODE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}

// USB_DEVICE.INT_CLR: Interrupt clear status register.
func (o *USB_DEVICE_Type) SetINT_CLR_JTAG_IN_FLUSH_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetINT_CLR_JTAG_IN_FLUSH_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetINT_CLR_SOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetINT_CLR_SOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetINT_CLR_SERIAL_OUT_RECV_PKT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetINT_CLR_SERIAL_OUT_RECV_PKT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_Type) SetINT_CLR_SERIAL_IN_EMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_Type) GetINT_CLR_SERIAL_IN_EMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_Type) SetINT_CLR_PID_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_Type) GetINT_CLR_PID_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_Type) SetINT_CLR_CRC5_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_Type) GetINT_CLR_CRC5_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_Type) SetINT_CLR_CRC16_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_Type) GetINT_CLR_CRC16_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *USB_DEVICE_Type) SetINT_CLR_STUFF_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_Type) GetINT_CLR_STUFF_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *USB_DEVICE_Type) SetINT_CLR_IN_TOKEN_REC_IN_EP1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *USB_DEVICE_Type) GetINT_CLR_IN_TOKEN_REC_IN_EP1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *USB_DEVICE_Type) SetINT_CLR_USB_BUS_RESET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *USB_DEVICE_Type) GetINT_CLR_USB_BUS_RESET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *USB_DEVICE_Type) SetINT_CLR_OUT_EP1_ZERO_PAYLOAD_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *USB_DEVICE_Type) GetINT_CLR_OUT_EP1_ZERO_PAYLOAD_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *USB_DEVICE_Type) SetINT_CLR_OUT_EP2_ZERO_PAYLOAD_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *USB_DEVICE_Type) GetINT_CLR_OUT_EP2_ZERO_PAYLOAD_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *USB_DEVICE_Type) SetINT_CLR_RTS_CHG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *USB_DEVICE_Type) GetINT_CLR_RTS_CHG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *USB_DEVICE_Type) SetINT_CLR_DTR_CHG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *USB_DEVICE_Type) GetINT_CLR_DTR_CHG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *USB_DEVICE_Type) SetINT_CLR_GET_LINE_CODE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *USB_DEVICE_Type) GetINT_CLR_GET_LINE_CODE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *USB_DEVICE_Type) SetINT_CLR_SET_LINE_CODE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *USB_DEVICE_Type) GetINT_CLR_SET_LINE_CODE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}

// USB_DEVICE.CONF0: PHY hardware configuration.
func (o *USB_DEVICE_Type) SetCONF0_PHY_SEL(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetCONF0_PHY_SEL() uint32 {
	return volatile.LoadUint32(&o.CONF0.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetCONF0_EXCHG_PINS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetCONF0_EXCHG_PINS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetCONF0_EXCHG_PINS(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetCONF0_EXCHG_PINS() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_Type) SetCONF0_VREFH(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x18)|value<<3)
}
func (o *USB_DEVICE_Type) GetCONF0_VREFH() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x18) >> 3
}
func (o *USB_DEVICE_Type) SetCONF0_VREFL(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x60)|value<<5)
}
func (o *USB_DEVICE_Type) GetCONF0_VREFL() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x60) >> 5
}
func (o *USB_DEVICE_Type) SetCONF0_VREF_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_Type) GetCONF0_VREF_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x80) >> 7
}
func (o *USB_DEVICE_Type) SetCONF0_PAD_PULL_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x100)|value<<8)
}
func (o *USB_DEVICE_Type) GetCONF0_PAD_PULL_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x100) >> 8
}
func (o *USB_DEVICE_Type) SetCONF0_DP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x200)|value<<9)
}
func (o *USB_DEVICE_Type) GetCONF0_DP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x200) >> 9
}
func (o *USB_DEVICE_Type) SetCONF0_DP_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x400)|value<<10)
}
func (o *USB_DEVICE_Type) GetCONF0_DP_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x400) >> 10
}
func (o *USB_DEVICE_Type) SetCONF0_DM_PULLUP(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x800)|value<<11)
}
func (o *USB_DEVICE_Type) GetCONF0_DM_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x800) >> 11
}
func (o *USB_DEVICE_Type) SetCONF0_DM_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *USB_DEVICE_Type) GetCONF0_DM_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x1000) >> 12
}
func (o *USB_DEVICE_Type) SetCONF0_PULLUP_VALUE(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *USB_DEVICE_Type) GetCONF0_PULLUP_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2000) >> 13
}
func (o *USB_DEVICE_Type) SetCONF0_USB_PAD_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *USB_DEVICE_Type) GetCONF0_USB_PAD_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x4000) >> 14
}
func (o *USB_DEVICE_Type) SetCONF0_USB_JTAG_BRIDGE_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *USB_DEVICE_Type) GetCONF0_USB_JTAG_BRIDGE_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x8000) >> 15
}

// USB_DEVICE.TEST: Registers used for debugging the PHY.
func (o *USB_DEVICE_Type) SetTEST_TEST_ENABLE(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetTEST_TEST_ENABLE() uint32 {
	return volatile.LoadUint32(&o.TEST.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetTEST_TEST_USB_OE(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetTEST_TEST_USB_OE() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetTEST_TEST_TX_DP(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetTEST_TEST_TX_DP() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_Type) SetTEST_TEST_TX_DM(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_Type) GetTEST_TEST_TX_DM() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_Type) SetTEST_TEST_RX_RCV(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_Type) GetTEST_TEST_RX_RCV() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_Type) SetTEST_TEST_RX_DP(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_Type) GetTEST_TEST_RX_DP() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_Type) SetTEST_TEST_RX_DM(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_Type) GetTEST_TEST_RX_DM() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x40) >> 6
}

// USB_DEVICE.JFIFO_ST: JTAG FIFO status and control registers.
func (o *USB_DEVICE_Type) SetJFIFO_ST_IN_FIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.JFIFO_ST.Reg, volatile.LoadUint32(&o.JFIFO_ST.Reg)&^(0x3)|value)
}
func (o *USB_DEVICE_Type) GetJFIFO_ST_IN_FIFO_CNT() uint32 {
	return volatile.LoadUint32(&o.JFIFO_ST.Reg) & 0x3
}
func (o *USB_DEVICE_Type) SetJFIFO_ST_IN_FIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.JFIFO_ST.Reg, volatile.LoadUint32(&o.JFIFO_ST.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetJFIFO_ST_IN_FIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.JFIFO_ST.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_Type) SetJFIFO_ST_IN_FIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.JFIFO_ST.Reg, volatile.LoadUint32(&o.JFIFO_ST.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_Type) GetJFIFO_ST_IN_FIFO_FULL() uint32 {
	return (volatile.LoadUint32(&o.JFIFO_ST.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_Type) SetJFIFO_ST_OUT_FIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.JFIFO_ST.Reg, volatile.LoadUint32(&o.JFIFO_ST.Reg)&^(0x30)|value<<4)
}
func (o *USB_DEVICE_Type) GetJFIFO_ST_OUT_FIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.JFIFO_ST.Reg) & 0x30) >> 4
}
func (o *USB_DEVICE_Type) SetJFIFO_ST_OUT_FIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.JFIFO_ST.Reg, volatile.LoadUint32(&o.JFIFO_ST.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_Type) GetJFIFO_ST_OUT_FIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.JFIFO_ST.Reg) & 0x40) >> 6
}
func (o *USB_DEVICE_Type) SetJFIFO_ST_OUT_FIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.JFIFO_ST.Reg, volatile.LoadUint32(&o.JFIFO_ST.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_Type) GetJFIFO_ST_OUT_FIFO_FULL() uint32 {
	return (volatile.LoadUint32(&o.JFIFO_ST.Reg) & 0x80) >> 7
}
func (o *USB_DEVICE_Type) SetJFIFO_ST_IN_FIFO_RESET(value uint32) {
	volatile.StoreUint32(&o.JFIFO_ST.Reg, volatile.LoadUint32(&o.JFIFO_ST.Reg)&^(0x100)|value<<8)
}
func (o *USB_DEVICE_Type) GetJFIFO_ST_IN_FIFO_RESET() uint32 {
	return (volatile.LoadUint32(&o.JFIFO_ST.Reg) & 0x100) >> 8
}
func (o *USB_DEVICE_Type) SetJFIFO_ST_OUT_FIFO_RESET(value uint32) {
	volatile.StoreUint32(&o.JFIFO_ST.Reg, volatile.LoadUint32(&o.JFIFO_ST.Reg)&^(0x200)|value<<9)
}
func (o *USB_DEVICE_Type) GetJFIFO_ST_OUT_FIFO_RESET() uint32 {
	return (volatile.LoadUint32(&o.JFIFO_ST.Reg) & 0x200) >> 9
}

// USB_DEVICE.FRAM_NUM: Last received SOF frame index register.
func (o *USB_DEVICE_Type) SetFRAM_NUM_SOF_FRAME_INDEX(value uint32) {
	volatile.StoreUint32(&o.FRAM_NUM.Reg, volatile.LoadUint32(&o.FRAM_NUM.Reg)&^(0x7ff)|value)
}
func (o *USB_DEVICE_Type) GetFRAM_NUM_SOF_FRAME_INDEX() uint32 {
	return volatile.LoadUint32(&o.FRAM_NUM.Reg) & 0x7ff
}

// USB_DEVICE.IN_EP0_ST: Control IN endpoint status information.
func (o *USB_DEVICE_Type) SetIN_EP0_ST_IN_EP0_STATE(value uint32) {
	volatile.StoreUint32(&o.IN_EP0_ST.Reg, volatile.LoadUint32(&o.IN_EP0_ST.Reg)&^(0x3)|value)
}
func (o *USB_DEVICE_Type) GetIN_EP0_ST_IN_EP0_STATE() uint32 {
	return volatile.LoadUint32(&o.IN_EP0_ST.Reg) & 0x3
}
func (o *USB_DEVICE_Type) SetIN_EP0_ST_IN_EP0_WR_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_EP0_ST.Reg, volatile.LoadUint32(&o.IN_EP0_ST.Reg)&^(0x1fc)|value<<2)
}
func (o *USB_DEVICE_Type) GetIN_EP0_ST_IN_EP0_WR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.IN_EP0_ST.Reg) & 0x1fc) >> 2
}
func (o *USB_DEVICE_Type) SetIN_EP0_ST_IN_EP0_RD_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_EP0_ST.Reg, volatile.LoadUint32(&o.IN_EP0_ST.Reg)&^(0xfe00)|value<<9)
}
func (o *USB_DEVICE_Type) GetIN_EP0_ST_IN_EP0_RD_ADDR() uint32 {
	return (volatile.LoadUint32(&o.IN_EP0_ST.Reg) & 0xfe00) >> 9
}

// USB_DEVICE.IN_EP1_ST: CDC-ACM IN endpoint status information.
func (o *USB_DEVICE_Type) SetIN_EP1_ST_IN_EP1_STATE(value uint32) {
	volatile.StoreUint32(&o.IN_EP1_ST.Reg, volatile.LoadUint32(&o.IN_EP1_ST.Reg)&^(0x3)|value)
}
func (o *USB_DEVICE_Type) GetIN_EP1_ST_IN_EP1_STATE() uint32 {
	return volatile.LoadUint32(&o.IN_EP1_ST.Reg) & 0x3
}
func (o *USB_DEVICE_Type) SetIN_EP1_ST_IN_EP1_WR_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_EP1_ST.Reg, volatile.LoadUint32(&o.IN_EP1_ST.Reg)&^(0x1fc)|value<<2)
}
func (o *USB_DEVICE_Type) GetIN_EP1_ST_IN_EP1_WR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.IN_EP1_ST.Reg) & 0x1fc) >> 2
}
func (o *USB_DEVICE_Type) SetIN_EP1_ST_IN_EP1_RD_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_EP1_ST.Reg, volatile.LoadUint32(&o.IN_EP1_ST.Reg)&^(0xfe00)|value<<9)
}
func (o *USB_DEVICE_Type) GetIN_EP1_ST_IN_EP1_RD_ADDR() uint32 {
	return (volatile.LoadUint32(&o.IN_EP1_ST.Reg) & 0xfe00) >> 9
}

// USB_DEVICE.IN_EP2_ST: CDC-ACM interrupt IN endpoint status information.
func (o *USB_DEVICE_Type) SetIN_EP2_ST_IN_EP2_STATE(value uint32) {
	volatile.StoreUint32(&o.IN_EP2_ST.Reg, volatile.LoadUint32(&o.IN_EP2_ST.Reg)&^(0x3)|value)
}
func (o *USB_DEVICE_Type) GetIN_EP2_ST_IN_EP2_STATE() uint32 {
	return volatile.LoadUint32(&o.IN_EP2_ST.Reg) & 0x3
}
func (o *USB_DEVICE_Type) SetIN_EP2_ST_IN_EP2_WR_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_EP2_ST.Reg, volatile.LoadUint32(&o.IN_EP2_ST.Reg)&^(0x1fc)|value<<2)
}
func (o *USB_DEVICE_Type) GetIN_EP2_ST_IN_EP2_WR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.IN_EP2_ST.Reg) & 0x1fc) >> 2
}
func (o *USB_DEVICE_Type) SetIN_EP2_ST_IN_EP2_RD_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_EP2_ST.Reg, volatile.LoadUint32(&o.IN_EP2_ST.Reg)&^(0xfe00)|value<<9)
}
func (o *USB_DEVICE_Type) GetIN_EP2_ST_IN_EP2_RD_ADDR() uint32 {
	return (volatile.LoadUint32(&o.IN_EP2_ST.Reg) & 0xfe00) >> 9
}

// USB_DEVICE.IN_EP3_ST: JTAG IN endpoint status information.
func (o *USB_DEVICE_Type) SetIN_EP3_ST_IN_EP3_STATE(value uint32) {
	volatile.StoreUint32(&o.IN_EP3_ST.Reg, volatile.LoadUint32(&o.IN_EP3_ST.Reg)&^(0x3)|value)
}
func (o *USB_DEVICE_Type) GetIN_EP3_ST_IN_EP3_STATE() uint32 {
	return volatile.LoadUint32(&o.IN_EP3_ST.Reg) & 0x3
}
func (o *USB_DEVICE_Type) SetIN_EP3_ST_IN_EP3_WR_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_EP3_ST.Reg, volatile.LoadUint32(&o.IN_EP3_ST.Reg)&^(0x1fc)|value<<2)
}
func (o *USB_DEVICE_Type) GetIN_EP3_ST_IN_EP3_WR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.IN_EP3_ST.Reg) & 0x1fc) >> 2
}
func (o *USB_DEVICE_Type) SetIN_EP3_ST_IN_EP3_RD_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_EP3_ST.Reg, volatile.LoadUint32(&o.IN_EP3_ST.Reg)&^(0xfe00)|value<<9)
}
func (o *USB_DEVICE_Type) GetIN_EP3_ST_IN_EP3_RD_ADDR() uint32 {
	return (volatile.LoadUint32(&o.IN_EP3_ST.Reg) & 0xfe00) >> 9
}

// USB_DEVICE.OUT_EP0_ST: Control OUT endpoint status information.
func (o *USB_DEVICE_Type) SetOUT_EP0_ST_OUT_EP0_STATE(value uint32) {
	volatile.StoreUint32(&o.OUT_EP0_ST.Reg, volatile.LoadUint32(&o.OUT_EP0_ST.Reg)&^(0x3)|value)
}
func (o *USB_DEVICE_Type) GetOUT_EP0_ST_OUT_EP0_STATE() uint32 {
	return volatile.LoadUint32(&o.OUT_EP0_ST.Reg) & 0x3
}
func (o *USB_DEVICE_Type) SetOUT_EP0_ST_OUT_EP0_WR_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_EP0_ST.Reg, volatile.LoadUint32(&o.OUT_EP0_ST.Reg)&^(0x1fc)|value<<2)
}
func (o *USB_DEVICE_Type) GetOUT_EP0_ST_OUT_EP0_WR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.OUT_EP0_ST.Reg) & 0x1fc) >> 2
}
func (o *USB_DEVICE_Type) SetOUT_EP0_ST_OUT_EP0_RD_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_EP0_ST.Reg, volatile.LoadUint32(&o.OUT_EP0_ST.Reg)&^(0xfe00)|value<<9)
}
func (o *USB_DEVICE_Type) GetOUT_EP0_ST_OUT_EP0_RD_ADDR() uint32 {
	return (volatile.LoadUint32(&o.OUT_EP0_ST.Reg) & 0xfe00) >> 9
}

// USB_DEVICE.OUT_EP1_ST: CDC-ACM OUT endpoint status information.
func (o *USB_DEVICE_Type) SetOUT_EP1_ST_OUT_EP1_STATE(value uint32) {
	volatile.StoreUint32(&o.OUT_EP1_ST.Reg, volatile.LoadUint32(&o.OUT_EP1_ST.Reg)&^(0x3)|value)
}
func (o *USB_DEVICE_Type) GetOUT_EP1_ST_OUT_EP1_STATE() uint32 {
	return volatile.LoadUint32(&o.OUT_EP1_ST.Reg) & 0x3
}
func (o *USB_DEVICE_Type) SetOUT_EP1_ST_OUT_EP1_WR_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_EP1_ST.Reg, volatile.LoadUint32(&o.OUT_EP1_ST.Reg)&^(0x1fc)|value<<2)
}
func (o *USB_DEVICE_Type) GetOUT_EP1_ST_OUT_EP1_WR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.OUT_EP1_ST.Reg) & 0x1fc) >> 2
}
func (o *USB_DEVICE_Type) SetOUT_EP1_ST_OUT_EP1_RD_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_EP1_ST.Reg, volatile.LoadUint32(&o.OUT_EP1_ST.Reg)&^(0xfe00)|value<<9)
}
func (o *USB_DEVICE_Type) GetOUT_EP1_ST_OUT_EP1_RD_ADDR() uint32 {
	return (volatile.LoadUint32(&o.OUT_EP1_ST.Reg) & 0xfe00) >> 9
}
func (o *USB_DEVICE_Type) SetOUT_EP1_ST_OUT_EP1_REC_DATA_CNT(value uint32) {
	volatile.StoreUint32(&o.OUT_EP1_ST.Reg, volatile.LoadUint32(&o.OUT_EP1_ST.Reg)&^(0x7f0000)|value<<16)
}
func (o *USB_DEVICE_Type) GetOUT_EP1_ST_OUT_EP1_REC_DATA_CNT() uint32 {
	return (volatile.LoadUint32(&o.OUT_EP1_ST.Reg) & 0x7f0000) >> 16
}

// USB_DEVICE.OUT_EP2_ST: JTAG OUT endpoint status information.
func (o *USB_DEVICE_Type) SetOUT_EP2_ST_OUT_EP2_STATE(value uint32) {
	volatile.StoreUint32(&o.OUT_EP2_ST.Reg, volatile.LoadUint32(&o.OUT_EP2_ST.Reg)&^(0x3)|value)
}
func (o *USB_DEVICE_Type) GetOUT_EP2_ST_OUT_EP2_STATE() uint32 {
	return volatile.LoadUint32(&o.OUT_EP2_ST.Reg) & 0x3
}
func (o *USB_DEVICE_Type) SetOUT_EP2_ST_OUT_EP2_WR_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_EP2_ST.Reg, volatile.LoadUint32(&o.OUT_EP2_ST.Reg)&^(0x1fc)|value<<2)
}
func (o *USB_DEVICE_Type) GetOUT_EP2_ST_OUT_EP2_WR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.OUT_EP2_ST.Reg) & 0x1fc) >> 2
}
func (o *USB_DEVICE_Type) SetOUT_EP2_ST_OUT_EP2_RD_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_EP2_ST.Reg, volatile.LoadUint32(&o.OUT_EP2_ST.Reg)&^(0xfe00)|value<<9)
}
func (o *USB_DEVICE_Type) GetOUT_EP2_ST_OUT_EP2_RD_ADDR() uint32 {
	return (volatile.LoadUint32(&o.OUT_EP2_ST.Reg) & 0xfe00) >> 9
}

// USB_DEVICE.MISC_CONF: Clock enable control
func (o *USB_DEVICE_Type) SetMISC_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC_CONF.Reg, volatile.LoadUint32(&o.MISC_CONF.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetMISC_CONF_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.MISC_CONF.Reg) & 0x1
}

// USB_DEVICE.MEM_CONF: Memory power control
func (o *USB_DEVICE_Type) SetMEM_CONF_USB_MEM_PD(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetMEM_CONF_USB_MEM_PD() uint32 {
	return volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetMEM_CONF_USB_MEM_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetMEM_CONF_USB_MEM_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x2) >> 1
}

// USB_DEVICE.CHIP_RST: CDC-ACM chip reset control.
func (o *USB_DEVICE_Type) SetCHIP_RST_RTS(value uint32) {
	volatile.StoreUint32(&o.CHIP_RST.Reg, volatile.LoadUint32(&o.CHIP_RST.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetCHIP_RST_RTS() uint32 {
	return volatile.LoadUint32(&o.CHIP_RST.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetCHIP_RST_DTR(value uint32) {
	volatile.StoreUint32(&o.CHIP_RST.Reg, volatile.LoadUint32(&o.CHIP_RST.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetCHIP_RST_DTR() uint32 {
	return (volatile.LoadUint32(&o.CHIP_RST.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetCHIP_RST_USB_UART_CHIP_RST_DIS(value uint32) {
	volatile.StoreUint32(&o.CHIP_RST.Reg, volatile.LoadUint32(&o.CHIP_RST.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetCHIP_RST_USB_UART_CHIP_RST_DIS() uint32 {
	return (volatile.LoadUint32(&o.CHIP_RST.Reg) & 0x4) >> 2
}

// USB_DEVICE.SET_LINE_CODE_W0: W0 of SET_LINE_CODING command.
func (o *USB_DEVICE_Type) SetSET_LINE_CODE_W0(value uint32) {
	volatile.StoreUint32(&o.SET_LINE_CODE_W0.Reg, value)
}
func (o *USB_DEVICE_Type) GetSET_LINE_CODE_W0() uint32 {
	return volatile.LoadUint32(&o.SET_LINE_CODE_W0.Reg)
}

// USB_DEVICE.SET_LINE_CODE_W1: W1 of SET_LINE_CODING command.
func (o *USB_DEVICE_Type) SetSET_LINE_CODE_W1_BCHAR_FORMAT(value uint32) {
	volatile.StoreUint32(&o.SET_LINE_CODE_W1.Reg, volatile.LoadUint32(&o.SET_LINE_CODE_W1.Reg)&^(0xff)|value)
}
func (o *USB_DEVICE_Type) GetSET_LINE_CODE_W1_BCHAR_FORMAT() uint32 {
	return volatile.LoadUint32(&o.SET_LINE_CODE_W1.Reg) & 0xff
}
func (o *USB_DEVICE_Type) SetSET_LINE_CODE_W1_BPARITY_TYPE(value uint32) {
	volatile.StoreUint32(&o.SET_LINE_CODE_W1.Reg, volatile.LoadUint32(&o.SET_LINE_CODE_W1.Reg)&^(0xff00)|value<<8)
}
func (o *USB_DEVICE_Type) GetSET_LINE_CODE_W1_BPARITY_TYPE() uint32 {
	return (volatile.LoadUint32(&o.SET_LINE_CODE_W1.Reg) & 0xff00) >> 8
}
func (o *USB_DEVICE_Type) SetSET_LINE_CODE_W1_BDATA_BITS(value uint32) {
	volatile.StoreUint32(&o.SET_LINE_CODE_W1.Reg, volatile.LoadUint32(&o.SET_LINE_CODE_W1.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_DEVICE_Type) GetSET_LINE_CODE_W1_BDATA_BITS() uint32 {
	return (volatile.LoadUint32(&o.SET_LINE_CODE_W1.Reg) & 0xff0000) >> 16
}

// USB_DEVICE.GET_LINE_CODE_W0: W0 of GET_LINE_CODING command.
func (o *USB_DEVICE_Type) SetGET_LINE_CODE_W0(value uint32) {
	volatile.StoreUint32(&o.GET_LINE_CODE_W0.Reg, value)
}
func (o *USB_DEVICE_Type) GetGET_LINE_CODE_W0() uint32 {
	return volatile.LoadUint32(&o.GET_LINE_CODE_W0.Reg)
}

// USB_DEVICE.GET_LINE_CODE_W1: W1 of GET_LINE_CODING command.
func (o *USB_DEVICE_Type) SetGET_LINE_CODE_W1_GET_BDATA_BITS(value uint32) {
	volatile.StoreUint32(&o.GET_LINE_CODE_W1.Reg, volatile.LoadUint32(&o.GET_LINE_CODE_W1.Reg)&^(0xff)|value)
}
func (o *USB_DEVICE_Type) GetGET_LINE_CODE_W1_GET_BDATA_BITS() uint32 {
	return volatile.LoadUint32(&o.GET_LINE_CODE_W1.Reg) & 0xff
}
func (o *USB_DEVICE_Type) SetGET_LINE_CODE_W1_GET_BPARITY_TYPE(value uint32) {
	volatile.StoreUint32(&o.GET_LINE_CODE_W1.Reg, volatile.LoadUint32(&o.GET_LINE_CODE_W1.Reg)&^(0xff00)|value<<8)
}
func (o *USB_DEVICE_Type) GetGET_LINE_CODE_W1_GET_BPARITY_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GET_LINE_CODE_W1.Reg) & 0xff00) >> 8
}
func (o *USB_DEVICE_Type) SetGET_LINE_CODE_W1_GET_BCHAR_FORMAT(value uint32) {
	volatile.StoreUint32(&o.GET_LINE_CODE_W1.Reg, volatile.LoadUint32(&o.GET_LINE_CODE_W1.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_DEVICE_Type) GetGET_LINE_CODE_W1_GET_BCHAR_FORMAT() uint32 {
	return (volatile.LoadUint32(&o.GET_LINE_CODE_W1.Reg) & 0xff0000) >> 16
}

// USB_DEVICE.CONFIG_UPDATE: Configuration registers' value update
func (o *USB_DEVICE_Type) SetCONFIG_UPDATE(value uint32) {
	volatile.StoreUint32(&o.CONFIG_UPDATE.Reg, volatile.LoadUint32(&o.CONFIG_UPDATE.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetCONFIG_UPDATE() uint32 {
	return volatile.LoadUint32(&o.CONFIG_UPDATE.Reg) & 0x1
}

// USB_DEVICE.SER_AFIFO_CONFIG: Serial AFIFO configure register
func (o *USB_DEVICE_Type) SetSER_AFIFO_CONFIG_SERIAL_IN_AFIFO_RESET_WR(value uint32) {
	volatile.StoreUint32(&o.SER_AFIFO_CONFIG.Reg, volatile.LoadUint32(&o.SER_AFIFO_CONFIG.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetSER_AFIFO_CONFIG_SERIAL_IN_AFIFO_RESET_WR() uint32 {
	return volatile.LoadUint32(&o.SER_AFIFO_CONFIG.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetSER_AFIFO_CONFIG_SERIAL_IN_AFIFO_RESET_RD(value uint32) {
	volatile.StoreUint32(&o.SER_AFIFO_CONFIG.Reg, volatile.LoadUint32(&o.SER_AFIFO_CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetSER_AFIFO_CONFIG_SERIAL_IN_AFIFO_RESET_RD() uint32 {
	return (volatile.LoadUint32(&o.SER_AFIFO_CONFIG.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetSER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_RESET_WR(value uint32) {
	volatile.StoreUint32(&o.SER_AFIFO_CONFIG.Reg, volatile.LoadUint32(&o.SER_AFIFO_CONFIG.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetSER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_RESET_WR() uint32 {
	return (volatile.LoadUint32(&o.SER_AFIFO_CONFIG.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_Type) SetSER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_RESET_RD(value uint32) {
	volatile.StoreUint32(&o.SER_AFIFO_CONFIG.Reg, volatile.LoadUint32(&o.SER_AFIFO_CONFIG.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_Type) GetSER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_RESET_RD() uint32 {
	return (volatile.LoadUint32(&o.SER_AFIFO_CONFIG.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_Type) SetSER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_REMPTY(value uint32) {
	volatile.StoreUint32(&o.SER_AFIFO_CONFIG.Reg, volatile.LoadUint32(&o.SER_AFIFO_CONFIG.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_Type) GetSER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_REMPTY() uint32 {
	return (volatile.LoadUint32(&o.SER_AFIFO_CONFIG.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_Type) SetSER_AFIFO_CONFIG_SERIAL_IN_AFIFO_WFULL(value uint32) {
	volatile.StoreUint32(&o.SER_AFIFO_CONFIG.Reg, volatile.LoadUint32(&o.SER_AFIFO_CONFIG.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_Type) GetSER_AFIFO_CONFIG_SERIAL_IN_AFIFO_WFULL() uint32 {
	return (volatile.LoadUint32(&o.SER_AFIFO_CONFIG.Reg) & 0x20) >> 5
}

// USB_DEVICE.BUS_RESET_ST: USB Bus reset status register
func (o *USB_DEVICE_Type) SetBUS_RESET_ST_USB_BUS_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.BUS_RESET_ST.Reg, volatile.LoadUint32(&o.BUS_RESET_ST.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetBUS_RESET_ST_USB_BUS_RESET_ST() uint32 {
	return volatile.LoadUint32(&o.BUS_RESET_ST.Reg) & 0x1
}

// USB_DEVICE.DATE: Date register
func (o *USB_DEVICE_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *USB_DEVICE_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Constants for AES: AES (Advanced Encryption Standard) Accelerator
const (
	// KEY_0: Key material key_0 configure register
	// Position of KEY_0 field.
	AES_KEY_0_KEY_0_Pos = 0x0
	// Bit mask of KEY_0 field.
	AES_KEY_0_KEY_0_Msk = 0xffffffff

	// KEY_1: Key material key_1 configure register
	// Position of KEY_1 field.
	AES_KEY_1_KEY_1_Pos = 0x0
	// Bit mask of KEY_1 field.
	AES_KEY_1_KEY_1_Msk = 0xffffffff

	// KEY_2: Key material key_2 configure register
	// Position of KEY_2 field.
	AES_KEY_2_KEY_2_Pos = 0x0
	// Bit mask of KEY_2 field.
	AES_KEY_2_KEY_2_Msk = 0xffffffff

	// KEY_3: Key material key_3 configure register
	// Position of KEY_3 field.
	AES_KEY_3_KEY_3_Pos = 0x0
	// Bit mask of KEY_3 field.
	AES_KEY_3_KEY_3_Msk = 0xffffffff

	// KEY_4: Key material key_4 configure register
	// Position of KEY_4 field.
	AES_KEY_4_KEY_4_Pos = 0x0
	// Bit mask of KEY_4 field.
	AES_KEY_4_KEY_4_Msk = 0xffffffff

	// KEY_5: Key material key_5 configure register
	// Position of KEY_5 field.
	AES_KEY_5_KEY_5_Pos = 0x0
	// Bit mask of KEY_5 field.
	AES_KEY_5_KEY_5_Msk = 0xffffffff

	// KEY_6: Key material key_6 configure register
	// Position of KEY_6 field.
	AES_KEY_6_KEY_6_Pos = 0x0
	// Bit mask of KEY_6 field.
	AES_KEY_6_KEY_6_Msk = 0xffffffff

	// KEY_7: Key material key_7 configure register
	// Position of KEY_7 field.
	AES_KEY_7_KEY_7_Pos = 0x0
	// Bit mask of KEY_7 field.
	AES_KEY_7_KEY_7_Msk = 0xffffffff

	// TEXT_IN_0: source text material text_in_0 configure register
	// Position of TEXT_IN_0 field.
	AES_TEXT_IN_0_TEXT_IN_0_Pos = 0x0
	// Bit mask of TEXT_IN_0 field.
	AES_TEXT_IN_0_TEXT_IN_0_Msk = 0xffffffff

	// TEXT_IN_1: source text material text_in_1 configure register
	// Position of TEXT_IN_1 field.
	AES_TEXT_IN_1_TEXT_IN_1_Pos = 0x0
	// Bit mask of TEXT_IN_1 field.
	AES_TEXT_IN_1_TEXT_IN_1_Msk = 0xffffffff

	// TEXT_IN_2: source text material text_in_2 configure register
	// Position of TEXT_IN_2 field.
	AES_TEXT_IN_2_TEXT_IN_2_Pos = 0x0
	// Bit mask of TEXT_IN_2 field.
	AES_TEXT_IN_2_TEXT_IN_2_Msk = 0xffffffff

	// TEXT_IN_3: source text material text_in_3 configure register
	// Position of TEXT_IN_3 field.
	AES_TEXT_IN_3_TEXT_IN_3_Pos = 0x0
	// Bit mask of TEXT_IN_3 field.
	AES_TEXT_IN_3_TEXT_IN_3_Msk = 0xffffffff

	// TEXT_OUT_0: result text material text_out_0 configure register
	// Position of TEXT_OUT_0 field.
	AES_TEXT_OUT_0_TEXT_OUT_0_Pos = 0x0
	// Bit mask of TEXT_OUT_0 field.
	AES_TEXT_OUT_0_TEXT_OUT_0_Msk = 0xffffffff

	// TEXT_OUT_1: result text material text_out_1 configure register
	// Position of TEXT_OUT_1 field.
	AES_TEXT_OUT_1_TEXT_OUT_1_Pos = 0x0
	// Bit mask of TEXT_OUT_1 field.
	AES_TEXT_OUT_1_TEXT_OUT_1_Msk = 0xffffffff

	// TEXT_OUT_2: result text material text_out_2 configure register
	// Position of TEXT_OUT_2 field.
	AES_TEXT_OUT_2_TEXT_OUT_2_Pos = 0x0
	// Bit mask of TEXT_OUT_2 field.
	AES_TEXT_OUT_2_TEXT_OUT_2_Msk = 0xffffffff

	// TEXT_OUT_3: result text material text_out_3 configure register
	// Position of TEXT_OUT_3 field.
	AES_TEXT_OUT_3_TEXT_OUT_3_Pos = 0x0
	// Bit mask of TEXT_OUT_3 field.
	AES_TEXT_OUT_3_TEXT_OUT_3_Msk = 0xffffffff

	// MODE: AES Mode register
	// Position of MODE field.
	AES_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	AES_MODE_MODE_Msk = 0x7

	// ENDIAN: AES Endian configure register
	// Position of ENDIAN field.
	AES_ENDIAN_ENDIAN_Pos = 0x0
	// Bit mask of ENDIAN field.
	AES_ENDIAN_ENDIAN_Msk = 0x3f

	// TRIGGER: AES trigger register
	// Position of TRIGGER field.
	AES_TRIGGER_TRIGGER_Pos = 0x0
	// Bit mask of TRIGGER field.
	AES_TRIGGER_TRIGGER_Msk = 0x1
	// Bit TRIGGER.
	AES_TRIGGER_TRIGGER = 0x1

	// STATE: AES state register
	// Position of STATE field.
	AES_STATE_STATE_Pos = 0x0
	// Bit mask of STATE field.
	AES_STATE_STATE_Msk = 0x3

	// DMA_ENABLE: DMA-AES working mode register
	// Position of DMA_ENABLE field.
	AES_DMA_ENABLE_DMA_ENABLE_Pos = 0x0
	// Bit mask of DMA_ENABLE field.
	AES_DMA_ENABLE_DMA_ENABLE_Msk = 0x1
	// Bit DMA_ENABLE.
	AES_DMA_ENABLE_DMA_ENABLE = 0x1

	// BLOCK_MODE: AES cipher block mode register
	// Position of BLOCK_MODE field.
	AES_BLOCK_MODE_BLOCK_MODE_Pos = 0x0
	// Bit mask of BLOCK_MODE field.
	AES_BLOCK_MODE_BLOCK_MODE_Msk = 0x7

	// BLOCK_NUM: AES block number register
	// Position of BLOCK_NUM field.
	AES_BLOCK_NUM_BLOCK_NUM_Pos = 0x0
	// Bit mask of BLOCK_NUM field.
	AES_BLOCK_NUM_BLOCK_NUM_Msk = 0xffffffff

	// INC_SEL: Standard incrementing function configure register
	// Position of INC_SEL field.
	AES_INC_SEL_INC_SEL_Pos = 0x0
	// Bit mask of INC_SEL field.
	AES_INC_SEL_INC_SEL_Msk = 0x1
	// Bit INC_SEL.
	AES_INC_SEL_INC_SEL = 0x1

	// AAD_BLOCK_NUM: Additional Authential Data block number register
	// Position of AAD_BLOCK_NUM field.
	AES_AAD_BLOCK_NUM_AAD_BLOCK_NUM_Pos = 0x0
	// Bit mask of AAD_BLOCK_NUM field.
	AES_AAD_BLOCK_NUM_AAD_BLOCK_NUM_Msk = 0xffffffff

	// REMAINDER_BIT_NUM: AES remainder bit number register
	// Position of REMAINDER_BIT_NUM field.
	AES_REMAINDER_BIT_NUM_REMAINDER_BIT_NUM_Pos = 0x0
	// Bit mask of REMAINDER_BIT_NUM field.
	AES_REMAINDER_BIT_NUM_REMAINDER_BIT_NUM_Msk = 0x7f

	// CONTINUE: AES continue register
	// Position of CONTINUE field.
	AES_CONTINUE_CONTINUE_Pos = 0x0
	// Bit mask of CONTINUE field.
	AES_CONTINUE_CONTINUE_Msk = 0x1
	// Bit CONTINUE.
	AES_CONTINUE_CONTINUE = 0x1

	// INT_CLEAR: AES Interrupt clear register
	// Position of INT_CLEAR field.
	AES_INT_CLEAR_INT_CLEAR_Pos = 0x0
	// Bit mask of INT_CLEAR field.
	AES_INT_CLEAR_INT_CLEAR_Msk = 0x1
	// Bit INT_CLEAR.
	AES_INT_CLEAR_INT_CLEAR = 0x1

	// INT_ENA: AES Interrupt enable register
	// Position of INT_ENA field.
	AES_INT_ENA_INT_ENA_Pos = 0x0
	// Bit mask of INT_ENA field.
	AES_INT_ENA_INT_ENA_Msk = 0x1
	// Bit INT_ENA.
	AES_INT_ENA_INT_ENA = 0x1

	// DATE: AES version control register
	// Position of DATE field.
	AES_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	AES_DATE_DATE_Msk = 0x3fffffff

	// DMA_EXIT: AES-DMA exit config
	// Position of DMA_EXIT field.
	AES_DMA_EXIT_DMA_EXIT_Pos = 0x0
	// Bit mask of DMA_EXIT field.
	AES_DMA_EXIT_DMA_EXIT_Msk = 0x1
	// Bit DMA_EXIT.
	AES_DMA_EXIT_DMA_EXIT = 0x1
)

// Constants for APB_SARADC: SAR (Successive Approximation Register) Analog-to-Digital Converter
const (
	// CTRL: digital saradc configure register
	// Position of SARADC_START_FORCE field.
	APB_SARADC_CTRL_SARADC_START_FORCE_Pos = 0x0
	// Bit mask of SARADC_START_FORCE field.
	APB_SARADC_CTRL_SARADC_START_FORCE_Msk = 0x1
	// Bit SARADC_START_FORCE.
	APB_SARADC_CTRL_SARADC_START_FORCE = 0x1
	// Position of SARADC_START field.
	APB_SARADC_CTRL_SARADC_START_Pos = 0x1
	// Bit mask of SARADC_START field.
	APB_SARADC_CTRL_SARADC_START_Msk = 0x2
	// Bit SARADC_START.
	APB_SARADC_CTRL_SARADC_START = 0x2
	// Position of SARADC_SAR_CLK_GATED field.
	APB_SARADC_CTRL_SARADC_SAR_CLK_GATED_Pos = 0x6
	// Bit mask of SARADC_SAR_CLK_GATED field.
	APB_SARADC_CTRL_SARADC_SAR_CLK_GATED_Msk = 0x40
	// Bit SARADC_SAR_CLK_GATED.
	APB_SARADC_CTRL_SARADC_SAR_CLK_GATED = 0x40
	// Position of SARADC_SAR_CLK_DIV field.
	APB_SARADC_CTRL_SARADC_SAR_CLK_DIV_Pos = 0x7
	// Bit mask of SARADC_SAR_CLK_DIV field.
	APB_SARADC_CTRL_SARADC_SAR_CLK_DIV_Msk = 0x7f80
	// Position of SARADC_SAR_PATT_LEN field.
	APB_SARADC_CTRL_SARADC_SAR_PATT_LEN_Pos = 0xf
	// Bit mask of SARADC_SAR_PATT_LEN field.
	APB_SARADC_CTRL_SARADC_SAR_PATT_LEN_Msk = 0x38000
	// Position of SARADC_SAR_PATT_P_CLEAR field.
	APB_SARADC_CTRL_SARADC_SAR_PATT_P_CLEAR_Pos = 0x17
	// Bit mask of SARADC_SAR_PATT_P_CLEAR field.
	APB_SARADC_CTRL_SARADC_SAR_PATT_P_CLEAR_Msk = 0x800000
	// Bit SARADC_SAR_PATT_P_CLEAR.
	APB_SARADC_CTRL_SARADC_SAR_PATT_P_CLEAR = 0x800000
	// Position of SARADC_XPD_SAR_FORCE field.
	APB_SARADC_CTRL_SARADC_XPD_SAR_FORCE_Pos = 0x1b
	// Bit mask of SARADC_XPD_SAR_FORCE field.
	APB_SARADC_CTRL_SARADC_XPD_SAR_FORCE_Msk = 0x18000000
	// Position of SARADC2_PWDET_DRV field.
	APB_SARADC_CTRL_SARADC2_PWDET_DRV_Pos = 0x1d
	// Bit mask of SARADC2_PWDET_DRV field.
	APB_SARADC_CTRL_SARADC2_PWDET_DRV_Msk = 0x20000000
	// Bit SARADC2_PWDET_DRV.
	APB_SARADC_CTRL_SARADC2_PWDET_DRV = 0x20000000
	// Position of SARADC_WAIT_ARB_CYCLE field.
	APB_SARADC_CTRL_SARADC_WAIT_ARB_CYCLE_Pos = 0x1e
	// Bit mask of SARADC_WAIT_ARB_CYCLE field.
	APB_SARADC_CTRL_SARADC_WAIT_ARB_CYCLE_Msk = 0xc0000000

	// CTRL2: digital saradc configure register
	// Position of SARADC_MEAS_NUM_LIMIT field.
	APB_SARADC_CTRL2_SARADC_MEAS_NUM_LIMIT_Pos = 0x0
	// Bit mask of SARADC_MEAS_NUM_LIMIT field.
	APB_SARADC_CTRL2_SARADC_MEAS_NUM_LIMIT_Msk = 0x1
	// Bit SARADC_MEAS_NUM_LIMIT.
	APB_SARADC_CTRL2_SARADC_MEAS_NUM_LIMIT = 0x1
	// Position of SARADC_MAX_MEAS_NUM field.
	APB_SARADC_CTRL2_SARADC_MAX_MEAS_NUM_Pos = 0x1
	// Bit mask of SARADC_MAX_MEAS_NUM field.
	APB_SARADC_CTRL2_SARADC_MAX_MEAS_NUM_Msk = 0x1fe
	// Position of SARADC_SAR1_INV field.
	APB_SARADC_CTRL2_SARADC_SAR1_INV_Pos = 0x9
	// Bit mask of SARADC_SAR1_INV field.
	APB_SARADC_CTRL2_SARADC_SAR1_INV_Msk = 0x200
	// Bit SARADC_SAR1_INV.
	APB_SARADC_CTRL2_SARADC_SAR1_INV = 0x200
	// Position of SARADC_SAR2_INV field.
	APB_SARADC_CTRL2_SARADC_SAR2_INV_Pos = 0xa
	// Bit mask of SARADC_SAR2_INV field.
	APB_SARADC_CTRL2_SARADC_SAR2_INV_Msk = 0x400
	// Bit SARADC_SAR2_INV.
	APB_SARADC_CTRL2_SARADC_SAR2_INV = 0x400
	// Position of SARADC_TIMER_TARGET field.
	APB_SARADC_CTRL2_SARADC_TIMER_TARGET_Pos = 0xc
	// Bit mask of SARADC_TIMER_TARGET field.
	APB_SARADC_CTRL2_SARADC_TIMER_TARGET_Msk = 0xfff000
	// Position of SARADC_TIMER_EN field.
	APB_SARADC_CTRL2_SARADC_TIMER_EN_Pos = 0x18
	// Bit mask of SARADC_TIMER_EN field.
	APB_SARADC_CTRL2_SARADC_TIMER_EN_Msk = 0x1000000
	// Bit SARADC_TIMER_EN.
	APB_SARADC_CTRL2_SARADC_TIMER_EN = 0x1000000

	// FILTER_CTRL1: digital saradc configure register
	// Position of APB_SARADC_FILTER_FACTOR1 field.
	APB_SARADC_FILTER_CTRL1_APB_SARADC_FILTER_FACTOR1_Pos = 0x1a
	// Bit mask of APB_SARADC_FILTER_FACTOR1 field.
	APB_SARADC_FILTER_CTRL1_APB_SARADC_FILTER_FACTOR1_Msk = 0x1c000000
	// Position of APB_SARADC_FILTER_FACTOR0 field.
	APB_SARADC_FILTER_CTRL1_APB_SARADC_FILTER_FACTOR0_Pos = 0x1d
	// Bit mask of APB_SARADC_FILTER_FACTOR0 field.
	APB_SARADC_FILTER_CTRL1_APB_SARADC_FILTER_FACTOR0_Msk = 0xe0000000

	// FSM_WAIT: digital saradc configure register
	// Position of SARADC_XPD_WAIT field.
	APB_SARADC_FSM_WAIT_SARADC_XPD_WAIT_Pos = 0x0
	// Bit mask of SARADC_XPD_WAIT field.
	APB_SARADC_FSM_WAIT_SARADC_XPD_WAIT_Msk = 0xff
	// Position of SARADC_RSTB_WAIT field.
	APB_SARADC_FSM_WAIT_SARADC_RSTB_WAIT_Pos = 0x8
	// Bit mask of SARADC_RSTB_WAIT field.
	APB_SARADC_FSM_WAIT_SARADC_RSTB_WAIT_Msk = 0xff00
	// Position of SARADC_STANDBY_WAIT field.
	APB_SARADC_FSM_WAIT_SARADC_STANDBY_WAIT_Pos = 0x10
	// Bit mask of SARADC_STANDBY_WAIT field.
	APB_SARADC_FSM_WAIT_SARADC_STANDBY_WAIT_Msk = 0xff0000

	// SAR1_STATUS: digital saradc configure register
	// Position of SARADC_SAR1_STATUS field.
	APB_SARADC_SAR1_STATUS_SARADC_SAR1_STATUS_Pos = 0x0
	// Bit mask of SARADC_SAR1_STATUS field.
	APB_SARADC_SAR1_STATUS_SARADC_SAR1_STATUS_Msk = 0xffffffff

	// SAR2_STATUS: digital saradc configure register
	// Position of SARADC_SAR2_STATUS field.
	APB_SARADC_SAR2_STATUS_SARADC_SAR2_STATUS_Pos = 0x0
	// Bit mask of SARADC_SAR2_STATUS field.
	APB_SARADC_SAR2_STATUS_SARADC_SAR2_STATUS_Msk = 0xffffffff

	// SAR_PATT_TAB1: digital saradc configure register
	// Position of SARADC_SAR_PATT_TAB1 field.
	APB_SARADC_SAR_PATT_TAB1_SARADC_SAR_PATT_TAB1_Pos = 0x0
	// Bit mask of SARADC_SAR_PATT_TAB1 field.
	APB_SARADC_SAR_PATT_TAB1_SARADC_SAR_PATT_TAB1_Msk = 0xffffff

	// SAR_PATT_TAB2: digital saradc configure register
	// Position of SARADC_SAR_PATT_TAB2 field.
	APB_SARADC_SAR_PATT_TAB2_SARADC_SAR_PATT_TAB2_Pos = 0x0
	// Bit mask of SARADC_SAR_PATT_TAB2 field.
	APB_SARADC_SAR_PATT_TAB2_SARADC_SAR_PATT_TAB2_Msk = 0xffffff

	// ONETIME_SAMPLE: digital saradc configure register
	// Position of SARADC_ONETIME_ATTEN field.
	APB_SARADC_ONETIME_SAMPLE_SARADC_ONETIME_ATTEN_Pos = 0x17
	// Bit mask of SARADC_ONETIME_ATTEN field.
	APB_SARADC_ONETIME_SAMPLE_SARADC_ONETIME_ATTEN_Msk = 0x1800000
	// Position of SARADC_ONETIME_CHANNEL field.
	APB_SARADC_ONETIME_SAMPLE_SARADC_ONETIME_CHANNEL_Pos = 0x19
	// Bit mask of SARADC_ONETIME_CHANNEL field.
	APB_SARADC_ONETIME_SAMPLE_SARADC_ONETIME_CHANNEL_Msk = 0x1e000000
	// Position of SARADC_ONETIME_START field.
	APB_SARADC_ONETIME_SAMPLE_SARADC_ONETIME_START_Pos = 0x1d
	// Bit mask of SARADC_ONETIME_START field.
	APB_SARADC_ONETIME_SAMPLE_SARADC_ONETIME_START_Msk = 0x20000000
	// Bit SARADC_ONETIME_START.
	APB_SARADC_ONETIME_SAMPLE_SARADC_ONETIME_START = 0x20000000
	// Position of SARADC2_ONETIME_SAMPLE field.
	APB_SARADC_ONETIME_SAMPLE_SARADC2_ONETIME_SAMPLE_Pos = 0x1e
	// Bit mask of SARADC2_ONETIME_SAMPLE field.
	APB_SARADC_ONETIME_SAMPLE_SARADC2_ONETIME_SAMPLE_Msk = 0x40000000
	// Bit SARADC2_ONETIME_SAMPLE.
	APB_SARADC_ONETIME_SAMPLE_SARADC2_ONETIME_SAMPLE = 0x40000000
	// Position of SARADC1_ONETIME_SAMPLE field.
	APB_SARADC_ONETIME_SAMPLE_SARADC1_ONETIME_SAMPLE_Pos = 0x1f
	// Bit mask of SARADC1_ONETIME_SAMPLE field.
	APB_SARADC_ONETIME_SAMPLE_SARADC1_ONETIME_SAMPLE_Msk = 0x80000000
	// Bit SARADC1_ONETIME_SAMPLE.
	APB_SARADC_ONETIME_SAMPLE_SARADC1_ONETIME_SAMPLE = 0x80000000

	// ARB_CTRL: digital saradc configure register
	// Position of ADC_ARB_APB_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_FORCE_Pos = 0x2
	// Bit mask of ADC_ARB_APB_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_FORCE_Msk = 0x4
	// Bit ADC_ARB_APB_FORCE.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_FORCE = 0x4
	// Position of ADC_ARB_RTC_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_FORCE_Pos = 0x3
	// Bit mask of ADC_ARB_RTC_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_FORCE_Msk = 0x8
	// Bit ADC_ARB_RTC_FORCE.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_FORCE = 0x8
	// Position of ADC_ARB_WIFI_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_FORCE_Pos = 0x4
	// Bit mask of ADC_ARB_WIFI_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_FORCE_Msk = 0x10
	// Bit ADC_ARB_WIFI_FORCE.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_FORCE = 0x10
	// Position of ADC_ARB_GRANT_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_GRANT_FORCE_Pos = 0x5
	// Bit mask of ADC_ARB_GRANT_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_GRANT_FORCE_Msk = 0x20
	// Bit ADC_ARB_GRANT_FORCE.
	APB_SARADC_ARB_CTRL_ADC_ARB_GRANT_FORCE = 0x20
	// Position of ADC_ARB_APB_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_PRIORITY_Pos = 0x6
	// Bit mask of ADC_ARB_APB_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_PRIORITY_Msk = 0xc0
	// Position of ADC_ARB_RTC_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_PRIORITY_Pos = 0x8
	// Bit mask of ADC_ARB_RTC_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_PRIORITY_Msk = 0x300
	// Position of ADC_ARB_WIFI_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_PRIORITY_Pos = 0xa
	// Bit mask of ADC_ARB_WIFI_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_PRIORITY_Msk = 0xc00
	// Position of ADC_ARB_FIX_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_FIX_PRIORITY_Pos = 0xc
	// Bit mask of ADC_ARB_FIX_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_FIX_PRIORITY_Msk = 0x1000
	// Bit ADC_ARB_FIX_PRIORITY.
	APB_SARADC_ARB_CTRL_ADC_ARB_FIX_PRIORITY = 0x1000

	// FILTER_CTRL0: digital saradc configure register
	// Position of APB_SARADC_FILTER_CHANNEL1 field.
	APB_SARADC_FILTER_CTRL0_APB_SARADC_FILTER_CHANNEL1_Pos = 0x12
	// Bit mask of APB_SARADC_FILTER_CHANNEL1 field.
	APB_SARADC_FILTER_CTRL0_APB_SARADC_FILTER_CHANNEL1_Msk = 0x3c0000
	// Position of APB_SARADC_FILTER_CHANNEL0 field.
	APB_SARADC_FILTER_CTRL0_APB_SARADC_FILTER_CHANNEL0_Pos = 0x16
	// Bit mask of APB_SARADC_FILTER_CHANNEL0 field.
	APB_SARADC_FILTER_CTRL0_APB_SARADC_FILTER_CHANNEL0_Msk = 0x3c00000
	// Position of APB_SARADC_FILTER_RESET field.
	APB_SARADC_FILTER_CTRL0_APB_SARADC_FILTER_RESET_Pos = 0x1f
	// Bit mask of APB_SARADC_FILTER_RESET field.
	APB_SARADC_FILTER_CTRL0_APB_SARADC_FILTER_RESET_Msk = 0x80000000
	// Bit APB_SARADC_FILTER_RESET.
	APB_SARADC_FILTER_CTRL0_APB_SARADC_FILTER_RESET = 0x80000000

	// SAR1DATA_STATUS: digital saradc configure register
	// Position of APB_SARADC1_DATA field.
	APB_SARADC_SAR1DATA_STATUS_APB_SARADC1_DATA_Pos = 0x0
	// Bit mask of APB_SARADC1_DATA field.
	APB_SARADC_SAR1DATA_STATUS_APB_SARADC1_DATA_Msk = 0x1ffff

	// SAR2DATA_STATUS: digital saradc configure register
	// Position of APB_SARADC2_DATA field.
	APB_SARADC_SAR2DATA_STATUS_APB_SARADC2_DATA_Pos = 0x0
	// Bit mask of APB_SARADC2_DATA field.
	APB_SARADC_SAR2DATA_STATUS_APB_SARADC2_DATA_Msk = 0x1ffff

	// THRES0_CTRL: digital saradc configure register
	// Position of APB_SARADC_THRES0_CHANNEL field.
	APB_SARADC_THRES0_CTRL_APB_SARADC_THRES0_CHANNEL_Pos = 0x0
	// Bit mask of APB_SARADC_THRES0_CHANNEL field.
	APB_SARADC_THRES0_CTRL_APB_SARADC_THRES0_CHANNEL_Msk = 0xf
	// Position of APB_SARADC_THRES0_HIGH field.
	APB_SARADC_THRES0_CTRL_APB_SARADC_THRES0_HIGH_Pos = 0x5
	// Bit mask of APB_SARADC_THRES0_HIGH field.
	APB_SARADC_THRES0_CTRL_APB_SARADC_THRES0_HIGH_Msk = 0x3ffe0
	// Position of APB_SARADC_THRES0_LOW field.
	APB_SARADC_THRES0_CTRL_APB_SARADC_THRES0_LOW_Pos = 0x12
	// Bit mask of APB_SARADC_THRES0_LOW field.
	APB_SARADC_THRES0_CTRL_APB_SARADC_THRES0_LOW_Msk = 0x7ffc0000

	// THRES1_CTRL: digital saradc configure register
	// Position of APB_SARADC_THRES1_CHANNEL field.
	APB_SARADC_THRES1_CTRL_APB_SARADC_THRES1_CHANNEL_Pos = 0x0
	// Bit mask of APB_SARADC_THRES1_CHANNEL field.
	APB_SARADC_THRES1_CTRL_APB_SARADC_THRES1_CHANNEL_Msk = 0xf
	// Position of APB_SARADC_THRES1_HIGH field.
	APB_SARADC_THRES1_CTRL_APB_SARADC_THRES1_HIGH_Pos = 0x5
	// Bit mask of APB_SARADC_THRES1_HIGH field.
	APB_SARADC_THRES1_CTRL_APB_SARADC_THRES1_HIGH_Msk = 0x3ffe0
	// Position of APB_SARADC_THRES1_LOW field.
	APB_SARADC_THRES1_CTRL_APB_SARADC_THRES1_LOW_Pos = 0x12
	// Bit mask of APB_SARADC_THRES1_LOW field.
	APB_SARADC_THRES1_CTRL_APB_SARADC_THRES1_LOW_Msk = 0x7ffc0000

	// THRES_CTRL: digital saradc configure register
	// Position of APB_SARADC_THRES_ALL_EN field.
	APB_SARADC_THRES_CTRL_APB_SARADC_THRES_ALL_EN_Pos = 0x1b
	// Bit mask of APB_SARADC_THRES_ALL_EN field.
	APB_SARADC_THRES_CTRL_APB_SARADC_THRES_ALL_EN_Msk = 0x8000000
	// Bit APB_SARADC_THRES_ALL_EN.
	APB_SARADC_THRES_CTRL_APB_SARADC_THRES_ALL_EN = 0x8000000
	// Position of APB_SARADC_THRES1_EN field.
	APB_SARADC_THRES_CTRL_APB_SARADC_THRES1_EN_Pos = 0x1e
	// Bit mask of APB_SARADC_THRES1_EN field.
	APB_SARADC_THRES_CTRL_APB_SARADC_THRES1_EN_Msk = 0x40000000
	// Bit APB_SARADC_THRES1_EN.
	APB_SARADC_THRES_CTRL_APB_SARADC_THRES1_EN = 0x40000000
	// Position of APB_SARADC_THRES0_EN field.
	APB_SARADC_THRES_CTRL_APB_SARADC_THRES0_EN_Pos = 0x1f
	// Bit mask of APB_SARADC_THRES0_EN field.
	APB_SARADC_THRES_CTRL_APB_SARADC_THRES0_EN_Msk = 0x80000000
	// Bit APB_SARADC_THRES0_EN.
	APB_SARADC_THRES_CTRL_APB_SARADC_THRES0_EN = 0x80000000

	// INT_ENA: digital saradc int register
	// Position of APB_SARADC_TSENS_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC_TSENS_INT_ENA_Pos = 0x19
	// Bit mask of APB_SARADC_TSENS_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC_TSENS_INT_ENA_Msk = 0x2000000
	// Bit APB_SARADC_TSENS_INT_ENA.
	APB_SARADC_INT_ENA_APB_SARADC_TSENS_INT_ENA = 0x2000000
	// Position of APB_SARADC_THRES1_LOW_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC_THRES1_LOW_INT_ENA_Pos = 0x1a
	// Bit mask of APB_SARADC_THRES1_LOW_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC_THRES1_LOW_INT_ENA_Msk = 0x4000000
	// Bit APB_SARADC_THRES1_LOW_INT_ENA.
	APB_SARADC_INT_ENA_APB_SARADC_THRES1_LOW_INT_ENA = 0x4000000
	// Position of APB_SARADC_THRES0_LOW_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC_THRES0_LOW_INT_ENA_Pos = 0x1b
	// Bit mask of APB_SARADC_THRES0_LOW_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC_THRES0_LOW_INT_ENA_Msk = 0x8000000
	// Bit APB_SARADC_THRES0_LOW_INT_ENA.
	APB_SARADC_INT_ENA_APB_SARADC_THRES0_LOW_INT_ENA = 0x8000000
	// Position of APB_SARADC_THRES1_HIGH_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC_THRES1_HIGH_INT_ENA_Pos = 0x1c
	// Bit mask of APB_SARADC_THRES1_HIGH_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC_THRES1_HIGH_INT_ENA_Msk = 0x10000000
	// Bit APB_SARADC_THRES1_HIGH_INT_ENA.
	APB_SARADC_INT_ENA_APB_SARADC_THRES1_HIGH_INT_ENA = 0x10000000
	// Position of APB_SARADC_THRES0_HIGH_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC_THRES0_HIGH_INT_ENA_Pos = 0x1d
	// Bit mask of APB_SARADC_THRES0_HIGH_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC_THRES0_HIGH_INT_ENA_Msk = 0x20000000
	// Bit APB_SARADC_THRES0_HIGH_INT_ENA.
	APB_SARADC_INT_ENA_APB_SARADC_THRES0_HIGH_INT_ENA = 0x20000000
	// Position of APB_SARADC2_DONE_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC2_DONE_INT_ENA_Pos = 0x1e
	// Bit mask of APB_SARADC2_DONE_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC2_DONE_INT_ENA_Msk = 0x40000000
	// Bit APB_SARADC2_DONE_INT_ENA.
	APB_SARADC_INT_ENA_APB_SARADC2_DONE_INT_ENA = 0x40000000
	// Position of APB_SARADC1_DONE_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC1_DONE_INT_ENA_Pos = 0x1f
	// Bit mask of APB_SARADC1_DONE_INT_ENA field.
	APB_SARADC_INT_ENA_APB_SARADC1_DONE_INT_ENA_Msk = 0x80000000
	// Bit APB_SARADC1_DONE_INT_ENA.
	APB_SARADC_INT_ENA_APB_SARADC1_DONE_INT_ENA = 0x80000000

	// INT_RAW: digital saradc int register
	// Position of APB_SARADC_TSENS_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC_TSENS_INT_RAW_Pos = 0x19
	// Bit mask of APB_SARADC_TSENS_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC_TSENS_INT_RAW_Msk = 0x2000000
	// Bit APB_SARADC_TSENS_INT_RAW.
	APB_SARADC_INT_RAW_APB_SARADC_TSENS_INT_RAW = 0x2000000
	// Position of APB_SARADC_THRES1_LOW_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC_THRES1_LOW_INT_RAW_Pos = 0x1a
	// Bit mask of APB_SARADC_THRES1_LOW_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC_THRES1_LOW_INT_RAW_Msk = 0x4000000
	// Bit APB_SARADC_THRES1_LOW_INT_RAW.
	APB_SARADC_INT_RAW_APB_SARADC_THRES1_LOW_INT_RAW = 0x4000000
	// Position of APB_SARADC_THRES0_LOW_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC_THRES0_LOW_INT_RAW_Pos = 0x1b
	// Bit mask of APB_SARADC_THRES0_LOW_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC_THRES0_LOW_INT_RAW_Msk = 0x8000000
	// Bit APB_SARADC_THRES0_LOW_INT_RAW.
	APB_SARADC_INT_RAW_APB_SARADC_THRES0_LOW_INT_RAW = 0x8000000
	// Position of APB_SARADC_THRES1_HIGH_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC_THRES1_HIGH_INT_RAW_Pos = 0x1c
	// Bit mask of APB_SARADC_THRES1_HIGH_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC_THRES1_HIGH_INT_RAW_Msk = 0x10000000
	// Bit APB_SARADC_THRES1_HIGH_INT_RAW.
	APB_SARADC_INT_RAW_APB_SARADC_THRES1_HIGH_INT_RAW = 0x10000000
	// Position of APB_SARADC_THRES0_HIGH_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC_THRES0_HIGH_INT_RAW_Pos = 0x1d
	// Bit mask of APB_SARADC_THRES0_HIGH_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC_THRES0_HIGH_INT_RAW_Msk = 0x20000000
	// Bit APB_SARADC_THRES0_HIGH_INT_RAW.
	APB_SARADC_INT_RAW_APB_SARADC_THRES0_HIGH_INT_RAW = 0x20000000
	// Position of APB_SARADC2_DONE_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC2_DONE_INT_RAW_Pos = 0x1e
	// Bit mask of APB_SARADC2_DONE_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC2_DONE_INT_RAW_Msk = 0x40000000
	// Bit APB_SARADC2_DONE_INT_RAW.
	APB_SARADC_INT_RAW_APB_SARADC2_DONE_INT_RAW = 0x40000000
	// Position of APB_SARADC1_DONE_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC1_DONE_INT_RAW_Pos = 0x1f
	// Bit mask of APB_SARADC1_DONE_INT_RAW field.
	APB_SARADC_INT_RAW_APB_SARADC1_DONE_INT_RAW_Msk = 0x80000000
	// Bit APB_SARADC1_DONE_INT_RAW.
	APB_SARADC_INT_RAW_APB_SARADC1_DONE_INT_RAW = 0x80000000

	// INT_ST: digital saradc int register
	// Position of APB_SARADC_TSENS_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC_TSENS_INT_ST_Pos = 0x19
	// Bit mask of APB_SARADC_TSENS_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC_TSENS_INT_ST_Msk = 0x2000000
	// Bit APB_SARADC_TSENS_INT_ST.
	APB_SARADC_INT_ST_APB_SARADC_TSENS_INT_ST = 0x2000000
	// Position of APB_SARADC_THRES1_LOW_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC_THRES1_LOW_INT_ST_Pos = 0x1a
	// Bit mask of APB_SARADC_THRES1_LOW_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC_THRES1_LOW_INT_ST_Msk = 0x4000000
	// Bit APB_SARADC_THRES1_LOW_INT_ST.
	APB_SARADC_INT_ST_APB_SARADC_THRES1_LOW_INT_ST = 0x4000000
	// Position of APB_SARADC_THRES0_LOW_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC_THRES0_LOW_INT_ST_Pos = 0x1b
	// Bit mask of APB_SARADC_THRES0_LOW_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC_THRES0_LOW_INT_ST_Msk = 0x8000000
	// Bit APB_SARADC_THRES0_LOW_INT_ST.
	APB_SARADC_INT_ST_APB_SARADC_THRES0_LOW_INT_ST = 0x8000000
	// Position of APB_SARADC_THRES1_HIGH_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC_THRES1_HIGH_INT_ST_Pos = 0x1c
	// Bit mask of APB_SARADC_THRES1_HIGH_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC_THRES1_HIGH_INT_ST_Msk = 0x10000000
	// Bit APB_SARADC_THRES1_HIGH_INT_ST.
	APB_SARADC_INT_ST_APB_SARADC_THRES1_HIGH_INT_ST = 0x10000000
	// Position of APB_SARADC_THRES0_HIGH_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC_THRES0_HIGH_INT_ST_Pos = 0x1d
	// Bit mask of APB_SARADC_THRES0_HIGH_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC_THRES0_HIGH_INT_ST_Msk = 0x20000000
	// Bit APB_SARADC_THRES0_HIGH_INT_ST.
	APB_SARADC_INT_ST_APB_SARADC_THRES0_HIGH_INT_ST = 0x20000000
	// Position of APB_SARADC2_DONE_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC2_DONE_INT_ST_Pos = 0x1e
	// Bit mask of APB_SARADC2_DONE_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC2_DONE_INT_ST_Msk = 0x40000000
	// Bit APB_SARADC2_DONE_INT_ST.
	APB_SARADC_INT_ST_APB_SARADC2_DONE_INT_ST = 0x40000000
	// Position of APB_SARADC1_DONE_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC1_DONE_INT_ST_Pos = 0x1f
	// Bit mask of APB_SARADC1_DONE_INT_ST field.
	APB_SARADC_INT_ST_APB_SARADC1_DONE_INT_ST_Msk = 0x80000000
	// Bit APB_SARADC1_DONE_INT_ST.
	APB_SARADC_INT_ST_APB_SARADC1_DONE_INT_ST = 0x80000000

	// INT_CLR: digital saradc int register
	// Position of APB_SARADC_TSENS_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC_TSENS_INT_CLR_Pos = 0x19
	// Bit mask of APB_SARADC_TSENS_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC_TSENS_INT_CLR_Msk = 0x2000000
	// Bit APB_SARADC_TSENS_INT_CLR.
	APB_SARADC_INT_CLR_APB_SARADC_TSENS_INT_CLR = 0x2000000
	// Position of APB_SARADC_THRES1_LOW_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC_THRES1_LOW_INT_CLR_Pos = 0x1a
	// Bit mask of APB_SARADC_THRES1_LOW_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC_THRES1_LOW_INT_CLR_Msk = 0x4000000
	// Bit APB_SARADC_THRES1_LOW_INT_CLR.
	APB_SARADC_INT_CLR_APB_SARADC_THRES1_LOW_INT_CLR = 0x4000000
	// Position of APB_SARADC_THRES0_LOW_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC_THRES0_LOW_INT_CLR_Pos = 0x1b
	// Bit mask of APB_SARADC_THRES0_LOW_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC_THRES0_LOW_INT_CLR_Msk = 0x8000000
	// Bit APB_SARADC_THRES0_LOW_INT_CLR.
	APB_SARADC_INT_CLR_APB_SARADC_THRES0_LOW_INT_CLR = 0x8000000
	// Position of APB_SARADC_THRES1_HIGH_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC_THRES1_HIGH_INT_CLR_Pos = 0x1c
	// Bit mask of APB_SARADC_THRES1_HIGH_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC_THRES1_HIGH_INT_CLR_Msk = 0x10000000
	// Bit APB_SARADC_THRES1_HIGH_INT_CLR.
	APB_SARADC_INT_CLR_APB_SARADC_THRES1_HIGH_INT_CLR = 0x10000000
	// Position of APB_SARADC_THRES0_HIGH_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC_THRES0_HIGH_INT_CLR_Pos = 0x1d
	// Bit mask of APB_SARADC_THRES0_HIGH_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC_THRES0_HIGH_INT_CLR_Msk = 0x20000000
	// Bit APB_SARADC_THRES0_HIGH_INT_CLR.
	APB_SARADC_INT_CLR_APB_SARADC_THRES0_HIGH_INT_CLR = 0x20000000
	// Position of APB_SARADC2_DONE_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC2_DONE_INT_CLR_Pos = 0x1e
	// Bit mask of APB_SARADC2_DONE_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC2_DONE_INT_CLR_Msk = 0x40000000
	// Bit APB_SARADC2_DONE_INT_CLR.
	APB_SARADC_INT_CLR_APB_SARADC2_DONE_INT_CLR = 0x40000000
	// Position of APB_SARADC1_DONE_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC1_DONE_INT_CLR_Pos = 0x1f
	// Bit mask of APB_SARADC1_DONE_INT_CLR field.
	APB_SARADC_INT_CLR_APB_SARADC1_DONE_INT_CLR_Msk = 0x80000000
	// Bit APB_SARADC1_DONE_INT_CLR.
	APB_SARADC_INT_CLR_APB_SARADC1_DONE_INT_CLR = 0x80000000

	// DMA_CONF: digital saradc configure register
	// Position of APB_ADC_EOF_NUM field.
	APB_SARADC_DMA_CONF_APB_ADC_EOF_NUM_Pos = 0x0
	// Bit mask of APB_ADC_EOF_NUM field.
	APB_SARADC_DMA_CONF_APB_ADC_EOF_NUM_Msk = 0xffff
	// Position of APB_ADC_RESET_FSM field.
	APB_SARADC_DMA_CONF_APB_ADC_RESET_FSM_Pos = 0x1e
	// Bit mask of APB_ADC_RESET_FSM field.
	APB_SARADC_DMA_CONF_APB_ADC_RESET_FSM_Msk = 0x40000000
	// Bit APB_ADC_RESET_FSM.
	APB_SARADC_DMA_CONF_APB_ADC_RESET_FSM = 0x40000000
	// Position of APB_ADC_TRANS field.
	APB_SARADC_DMA_CONF_APB_ADC_TRANS_Pos = 0x1f
	// Bit mask of APB_ADC_TRANS field.
	APB_SARADC_DMA_CONF_APB_ADC_TRANS_Msk = 0x80000000
	// Bit APB_ADC_TRANS.
	APB_SARADC_DMA_CONF_APB_ADC_TRANS = 0x80000000

	// CLKM_CONF: digital saradc configure register
	// Position of CLKM_DIV_NUM field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_NUM_Pos = 0x0
	// Bit mask of CLKM_DIV_NUM field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_NUM_Msk = 0xff
	// Position of CLKM_DIV_B field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_B_Pos = 0x8
	// Bit mask of CLKM_DIV_B field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_B_Msk = 0x3f00
	// Position of CLKM_DIV_A field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_A_Pos = 0xe
	// Bit mask of CLKM_DIV_A field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_A_Msk = 0xfc000
	// Position of CLK_EN field.
	APB_SARADC_CLKM_CONF_CLK_EN_Pos = 0x14
	// Bit mask of CLK_EN field.
	APB_SARADC_CLKM_CONF_CLK_EN_Msk = 0x100000
	// Bit CLK_EN.
	APB_SARADC_CLKM_CONF_CLK_EN = 0x100000
	// Position of CLK_SEL field.
	APB_SARADC_CLKM_CONF_CLK_SEL_Pos = 0x15
	// Bit mask of CLK_SEL field.
	APB_SARADC_CLKM_CONF_CLK_SEL_Msk = 0x600000

	// APB_TSENS_CTRL: digital tsens configure register
	// Position of TSENS_OUT field.
	APB_SARADC_APB_TSENS_CTRL_TSENS_OUT_Pos = 0x0
	// Bit mask of TSENS_OUT field.
	APB_SARADC_APB_TSENS_CTRL_TSENS_OUT_Msk = 0xff
	// Position of TSENS_IN_INV field.
	APB_SARADC_APB_TSENS_CTRL_TSENS_IN_INV_Pos = 0xd
	// Bit mask of TSENS_IN_INV field.
	APB_SARADC_APB_TSENS_CTRL_TSENS_IN_INV_Msk = 0x2000
	// Bit TSENS_IN_INV.
	APB_SARADC_APB_TSENS_CTRL_TSENS_IN_INV = 0x2000
	// Position of TSENS_CLK_DIV field.
	APB_SARADC_APB_TSENS_CTRL_TSENS_CLK_DIV_Pos = 0xe
	// Bit mask of TSENS_CLK_DIV field.
	APB_SARADC_APB_TSENS_CTRL_TSENS_CLK_DIV_Msk = 0x3fc000
	// Position of TSENS_PU field.
	APB_SARADC_APB_TSENS_CTRL_TSENS_PU_Pos = 0x16
	// Bit mask of TSENS_PU field.
	APB_SARADC_APB_TSENS_CTRL_TSENS_PU_Msk = 0x400000
	// Bit TSENS_PU.
	APB_SARADC_APB_TSENS_CTRL_TSENS_PU = 0x400000

	// TSENS_CTRL2: digital tsens configure register
	// Position of TSENS_XPD_WAIT field.
	APB_SARADC_TSENS_CTRL2_TSENS_XPD_WAIT_Pos = 0x0
	// Bit mask of TSENS_XPD_WAIT field.
	APB_SARADC_TSENS_CTRL2_TSENS_XPD_WAIT_Msk = 0xfff
	// Position of TSENS_XPD_FORCE field.
	APB_SARADC_TSENS_CTRL2_TSENS_XPD_FORCE_Pos = 0xc
	// Bit mask of TSENS_XPD_FORCE field.
	APB_SARADC_TSENS_CTRL2_TSENS_XPD_FORCE_Msk = 0x3000
	// Position of TSENS_CLK_INV field.
	APB_SARADC_TSENS_CTRL2_TSENS_CLK_INV_Pos = 0xe
	// Bit mask of TSENS_CLK_INV field.
	APB_SARADC_TSENS_CTRL2_TSENS_CLK_INV_Msk = 0x4000
	// Bit TSENS_CLK_INV.
	APB_SARADC_TSENS_CTRL2_TSENS_CLK_INV = 0x4000
	// Position of TSENS_CLK_SEL field.
	APB_SARADC_TSENS_CTRL2_TSENS_CLK_SEL_Pos = 0xf
	// Bit mask of TSENS_CLK_SEL field.
	APB_SARADC_TSENS_CTRL2_TSENS_CLK_SEL_Msk = 0x8000
	// Bit TSENS_CLK_SEL.
	APB_SARADC_TSENS_CTRL2_TSENS_CLK_SEL = 0x8000

	// CALI: digital saradc configure register
	// Position of APB_SARADC_CALI_CFG field.
	APB_SARADC_CALI_APB_SARADC_CALI_CFG_Pos = 0x0
	// Bit mask of APB_SARADC_CALI_CFG field.
	APB_SARADC_CALI_APB_SARADC_CALI_CFG_Msk = 0x1ffff

	// APB_TSENS_WAKE: digital tsens configure register
	// Position of WAKEUP_TH_LOW field.
	APB_SARADC_APB_TSENS_WAKE_WAKEUP_TH_LOW_Pos = 0x0
	// Bit mask of WAKEUP_TH_LOW field.
	APB_SARADC_APB_TSENS_WAKE_WAKEUP_TH_LOW_Msk = 0xff
	// Position of WAKEUP_TH_HIGH field.
	APB_SARADC_APB_TSENS_WAKE_WAKEUP_TH_HIGH_Pos = 0x8
	// Bit mask of WAKEUP_TH_HIGH field.
	APB_SARADC_APB_TSENS_WAKE_WAKEUP_TH_HIGH_Msk = 0xff00
	// Position of WAKEUP_OVER_UPPER_TH field.
	APB_SARADC_APB_TSENS_WAKE_WAKEUP_OVER_UPPER_TH_Pos = 0x10
	// Bit mask of WAKEUP_OVER_UPPER_TH field.
	APB_SARADC_APB_TSENS_WAKE_WAKEUP_OVER_UPPER_TH_Msk = 0x10000
	// Bit WAKEUP_OVER_UPPER_TH.
	APB_SARADC_APB_TSENS_WAKE_WAKEUP_OVER_UPPER_TH = 0x10000
	// Position of WAKEUP_MODE field.
	APB_SARADC_APB_TSENS_WAKE_WAKEUP_MODE_Pos = 0x11
	// Bit mask of WAKEUP_MODE field.
	APB_SARADC_APB_TSENS_WAKE_WAKEUP_MODE_Msk = 0x20000
	// Bit WAKEUP_MODE.
	APB_SARADC_APB_TSENS_WAKE_WAKEUP_MODE = 0x20000
	// Position of WAKEUP_EN field.
	APB_SARADC_APB_TSENS_WAKE_WAKEUP_EN_Pos = 0x12
	// Bit mask of WAKEUP_EN field.
	APB_SARADC_APB_TSENS_WAKE_WAKEUP_EN_Msk = 0x40000
	// Bit WAKEUP_EN.
	APB_SARADC_APB_TSENS_WAKE_WAKEUP_EN = 0x40000

	// APB_TSENS_SAMPLE: digital tsens configure register
	// Position of TSENS_SAMPLE_RATE field.
	APB_SARADC_APB_TSENS_SAMPLE_TSENS_SAMPLE_RATE_Pos = 0x0
	// Bit mask of TSENS_SAMPLE_RATE field.
	APB_SARADC_APB_TSENS_SAMPLE_TSENS_SAMPLE_RATE_Msk = 0xffff
	// Position of TSENS_SAMPLE_EN field.
	APB_SARADC_APB_TSENS_SAMPLE_TSENS_SAMPLE_EN_Pos = 0x10
	// Bit mask of TSENS_SAMPLE_EN field.
	APB_SARADC_APB_TSENS_SAMPLE_TSENS_SAMPLE_EN_Msk = 0x10000
	// Bit TSENS_SAMPLE_EN.
	APB_SARADC_APB_TSENS_SAMPLE_TSENS_SAMPLE_EN = 0x10000

	// CTRL_DATE: version
	// Position of DATE field.
	APB_SARADC_CTRL_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	APB_SARADC_CTRL_DATE_DATE_Msk = 0xffffffff
)

// Constants for ASSIST_DEBUG: Debug Assist
const (
	// CORE_0_MONTR_ENA: core0 monitor enable configuration register
	// Position of CORE_0_AREA_DRAM0_0_RD_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_0_RD_ENA_Pos = 0x0
	// Bit mask of CORE_0_AREA_DRAM0_0_RD_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_0_RD_ENA_Msk = 0x1
	// Bit CORE_0_AREA_DRAM0_0_RD_ENA.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_0_RD_ENA = 0x1
	// Position of CORE_0_AREA_DRAM0_0_WR_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_0_WR_ENA_Pos = 0x1
	// Bit mask of CORE_0_AREA_DRAM0_0_WR_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_0_WR_ENA_Msk = 0x2
	// Bit CORE_0_AREA_DRAM0_0_WR_ENA.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_0_WR_ENA = 0x2
	// Position of CORE_0_AREA_DRAM0_1_RD_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_1_RD_ENA_Pos = 0x2
	// Bit mask of CORE_0_AREA_DRAM0_1_RD_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_1_RD_ENA_Msk = 0x4
	// Bit CORE_0_AREA_DRAM0_1_RD_ENA.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_1_RD_ENA = 0x4
	// Position of CORE_0_AREA_DRAM0_1_WR_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_1_WR_ENA_Pos = 0x3
	// Bit mask of CORE_0_AREA_DRAM0_1_WR_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_1_WR_ENA_Msk = 0x8
	// Bit CORE_0_AREA_DRAM0_1_WR_ENA.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_DRAM0_1_WR_ENA = 0x8
	// Position of CORE_0_AREA_PIF_0_RD_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_PIF_0_RD_ENA_Pos = 0x4
	// Bit mask of CORE_0_AREA_PIF_0_RD_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_PIF_0_RD_ENA_Msk = 0x10
	// Bit CORE_0_AREA_PIF_0_RD_ENA.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_PIF_0_RD_ENA = 0x10
	// Position of CORE_0_AREA_PIF_0_WR_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_PIF_0_WR_ENA_Pos = 0x5
	// Bit mask of CORE_0_AREA_PIF_0_WR_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_PIF_0_WR_ENA_Msk = 0x20
	// Bit CORE_0_AREA_PIF_0_WR_ENA.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_PIF_0_WR_ENA = 0x20
	// Position of CORE_0_AREA_PIF_1_RD_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_PIF_1_RD_ENA_Pos = 0x6
	// Bit mask of CORE_0_AREA_PIF_1_RD_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_PIF_1_RD_ENA_Msk = 0x40
	// Bit CORE_0_AREA_PIF_1_RD_ENA.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_PIF_1_RD_ENA = 0x40
	// Position of CORE_0_AREA_PIF_1_WR_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_PIF_1_WR_ENA_Pos = 0x7
	// Bit mask of CORE_0_AREA_PIF_1_WR_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_PIF_1_WR_ENA_Msk = 0x80
	// Bit CORE_0_AREA_PIF_1_WR_ENA.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_AREA_PIF_1_WR_ENA = 0x80
	// Position of CORE_0_SP_SPILL_MIN_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_SP_SPILL_MIN_ENA_Pos = 0x8
	// Bit mask of CORE_0_SP_SPILL_MIN_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_SP_SPILL_MIN_ENA_Msk = 0x100
	// Bit CORE_0_SP_SPILL_MIN_ENA.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_SP_SPILL_MIN_ENA = 0x100
	// Position of CORE_0_SP_SPILL_MAX_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_SP_SPILL_MAX_ENA_Pos = 0x9
	// Bit mask of CORE_0_SP_SPILL_MAX_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_SP_SPILL_MAX_ENA_Msk = 0x200
	// Bit CORE_0_SP_SPILL_MAX_ENA.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_SP_SPILL_MAX_ENA = 0x200
	// Position of CORE_0_IRAM0_EXCEPTION_MONITOR_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_IRAM0_EXCEPTION_MONITOR_ENA_Pos = 0xa
	// Bit mask of CORE_0_IRAM0_EXCEPTION_MONITOR_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_IRAM0_EXCEPTION_MONITOR_ENA_Msk = 0x400
	// Bit CORE_0_IRAM0_EXCEPTION_MONITOR_ENA.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_IRAM0_EXCEPTION_MONITOR_ENA = 0x400
	// Position of CORE_0_DRAM0_EXCEPTION_MONITOR_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_DRAM0_EXCEPTION_MONITOR_ENA_Pos = 0xb
	// Bit mask of CORE_0_DRAM0_EXCEPTION_MONITOR_ENA field.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_DRAM0_EXCEPTION_MONITOR_ENA_Msk = 0x800
	// Bit CORE_0_DRAM0_EXCEPTION_MONITOR_ENA.
	ASSIST_DEBUG_CORE_0_MONTR_ENA_CORE_0_DRAM0_EXCEPTION_MONITOR_ENA = 0x800

	// CORE_0_INTR_RAW: core0 monitor interrupt status register
	// Position of CORE_0_AREA_DRAM0_0_RD_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_DRAM0_0_RD_RAW_Pos = 0x0
	// Bit mask of CORE_0_AREA_DRAM0_0_RD_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_DRAM0_0_RD_RAW_Msk = 0x1
	// Bit CORE_0_AREA_DRAM0_0_RD_RAW.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_DRAM0_0_RD_RAW = 0x1
	// Position of CORE_0_AREA_DRAM0_0_WR_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_DRAM0_0_WR_RAW_Pos = 0x1
	// Bit mask of CORE_0_AREA_DRAM0_0_WR_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_DRAM0_0_WR_RAW_Msk = 0x2
	// Bit CORE_0_AREA_DRAM0_0_WR_RAW.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_DRAM0_0_WR_RAW = 0x2
	// Position of CORE_0_AREA_DRAM0_1_RD_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_DRAM0_1_RD_RAW_Pos = 0x2
	// Bit mask of CORE_0_AREA_DRAM0_1_RD_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_DRAM0_1_RD_RAW_Msk = 0x4
	// Bit CORE_0_AREA_DRAM0_1_RD_RAW.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_DRAM0_1_RD_RAW = 0x4
	// Position of CORE_0_AREA_DRAM0_1_WR_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_DRAM0_1_WR_RAW_Pos = 0x3
	// Bit mask of CORE_0_AREA_DRAM0_1_WR_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_DRAM0_1_WR_RAW_Msk = 0x8
	// Bit CORE_0_AREA_DRAM0_1_WR_RAW.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_DRAM0_1_WR_RAW = 0x8
	// Position of CORE_0_AREA_PIF_0_RD_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_PIF_0_RD_RAW_Pos = 0x4
	// Bit mask of CORE_0_AREA_PIF_0_RD_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_PIF_0_RD_RAW_Msk = 0x10
	// Bit CORE_0_AREA_PIF_0_RD_RAW.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_PIF_0_RD_RAW = 0x10
	// Position of CORE_0_AREA_PIF_0_WR_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_PIF_0_WR_RAW_Pos = 0x5
	// Bit mask of CORE_0_AREA_PIF_0_WR_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_PIF_0_WR_RAW_Msk = 0x20
	// Bit CORE_0_AREA_PIF_0_WR_RAW.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_PIF_0_WR_RAW = 0x20
	// Position of CORE_0_AREA_PIF_1_RD_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_PIF_1_RD_RAW_Pos = 0x6
	// Bit mask of CORE_0_AREA_PIF_1_RD_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_PIF_1_RD_RAW_Msk = 0x40
	// Bit CORE_0_AREA_PIF_1_RD_RAW.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_PIF_1_RD_RAW = 0x40
	// Position of CORE_0_AREA_PIF_1_WR_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_PIF_1_WR_RAW_Pos = 0x7
	// Bit mask of CORE_0_AREA_PIF_1_WR_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_PIF_1_WR_RAW_Msk = 0x80
	// Bit CORE_0_AREA_PIF_1_WR_RAW.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_AREA_PIF_1_WR_RAW = 0x80
	// Position of CORE_0_SP_SPILL_MIN_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_SP_SPILL_MIN_RAW_Pos = 0x8
	// Bit mask of CORE_0_SP_SPILL_MIN_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_SP_SPILL_MIN_RAW_Msk = 0x100
	// Bit CORE_0_SP_SPILL_MIN_RAW.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_SP_SPILL_MIN_RAW = 0x100
	// Position of CORE_0_SP_SPILL_MAX_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_SP_SPILL_MAX_RAW_Pos = 0x9
	// Bit mask of CORE_0_SP_SPILL_MAX_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_SP_SPILL_MAX_RAW_Msk = 0x200
	// Bit CORE_0_SP_SPILL_MAX_RAW.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_SP_SPILL_MAX_RAW = 0x200
	// Position of CORE_0_IRAM0_EXCEPTION_MONITOR_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_IRAM0_EXCEPTION_MONITOR_RAW_Pos = 0xa
	// Bit mask of CORE_0_IRAM0_EXCEPTION_MONITOR_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_IRAM0_EXCEPTION_MONITOR_RAW_Msk = 0x400
	// Bit CORE_0_IRAM0_EXCEPTION_MONITOR_RAW.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_IRAM0_EXCEPTION_MONITOR_RAW = 0x400
	// Position of CORE_0_DRAM0_EXCEPTION_MONITOR_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_DRAM0_EXCEPTION_MONITOR_RAW_Pos = 0xb
	// Bit mask of CORE_0_DRAM0_EXCEPTION_MONITOR_RAW field.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_DRAM0_EXCEPTION_MONITOR_RAW_Msk = 0x800
	// Bit CORE_0_DRAM0_EXCEPTION_MONITOR_RAW.
	ASSIST_DEBUG_CORE_0_INTR_RAW_CORE_0_DRAM0_EXCEPTION_MONITOR_RAW = 0x800

	// CORE_0_INTR_ENA: core0 monitor interrupt enable register
	// Position of CORE_0_AREA_DRAM0_0_RD_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_DRAM0_0_RD_INTR_ENA_Pos = 0x0
	// Bit mask of CORE_0_AREA_DRAM0_0_RD_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_DRAM0_0_RD_INTR_ENA_Msk = 0x1
	// Bit CORE_0_AREA_DRAM0_0_RD_INTR_ENA.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_DRAM0_0_RD_INTR_ENA = 0x1
	// Position of CORE_0_AREA_DRAM0_0_WR_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_DRAM0_0_WR_INTR_ENA_Pos = 0x1
	// Bit mask of CORE_0_AREA_DRAM0_0_WR_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_DRAM0_0_WR_INTR_ENA_Msk = 0x2
	// Bit CORE_0_AREA_DRAM0_0_WR_INTR_ENA.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_DRAM0_0_WR_INTR_ENA = 0x2
	// Position of CORE_0_AREA_DRAM0_1_RD_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_DRAM0_1_RD_INTR_ENA_Pos = 0x2
	// Bit mask of CORE_0_AREA_DRAM0_1_RD_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_DRAM0_1_RD_INTR_ENA_Msk = 0x4
	// Bit CORE_0_AREA_DRAM0_1_RD_INTR_ENA.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_DRAM0_1_RD_INTR_ENA = 0x4
	// Position of CORE_0_AREA_DRAM0_1_WR_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_DRAM0_1_WR_INTR_ENA_Pos = 0x3
	// Bit mask of CORE_0_AREA_DRAM0_1_WR_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_DRAM0_1_WR_INTR_ENA_Msk = 0x8
	// Bit CORE_0_AREA_DRAM0_1_WR_INTR_ENA.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_DRAM0_1_WR_INTR_ENA = 0x8
	// Position of CORE_0_AREA_PIF_0_RD_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_PIF_0_RD_INTR_ENA_Pos = 0x4
	// Bit mask of CORE_0_AREA_PIF_0_RD_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_PIF_0_RD_INTR_ENA_Msk = 0x10
	// Bit CORE_0_AREA_PIF_0_RD_INTR_ENA.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_PIF_0_RD_INTR_ENA = 0x10
	// Position of CORE_0_AREA_PIF_0_WR_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_PIF_0_WR_INTR_ENA_Pos = 0x5
	// Bit mask of CORE_0_AREA_PIF_0_WR_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_PIF_0_WR_INTR_ENA_Msk = 0x20
	// Bit CORE_0_AREA_PIF_0_WR_INTR_ENA.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_PIF_0_WR_INTR_ENA = 0x20
	// Position of CORE_0_AREA_PIF_1_RD_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_PIF_1_RD_INTR_ENA_Pos = 0x6
	// Bit mask of CORE_0_AREA_PIF_1_RD_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_PIF_1_RD_INTR_ENA_Msk = 0x40
	// Bit CORE_0_AREA_PIF_1_RD_INTR_ENA.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_PIF_1_RD_INTR_ENA = 0x40
	// Position of CORE_0_AREA_PIF_1_WR_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_PIF_1_WR_INTR_ENA_Pos = 0x7
	// Bit mask of CORE_0_AREA_PIF_1_WR_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_PIF_1_WR_INTR_ENA_Msk = 0x80
	// Bit CORE_0_AREA_PIF_1_WR_INTR_ENA.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_AREA_PIF_1_WR_INTR_ENA = 0x80
	// Position of CORE_0_SP_SPILL_MIN_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_SP_SPILL_MIN_INTR_ENA_Pos = 0x8
	// Bit mask of CORE_0_SP_SPILL_MIN_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_SP_SPILL_MIN_INTR_ENA_Msk = 0x100
	// Bit CORE_0_SP_SPILL_MIN_INTR_ENA.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_SP_SPILL_MIN_INTR_ENA = 0x100
	// Position of CORE_0_SP_SPILL_MAX_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_SP_SPILL_MAX_INTR_ENA_Pos = 0x9
	// Bit mask of CORE_0_SP_SPILL_MAX_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_SP_SPILL_MAX_INTR_ENA_Msk = 0x200
	// Bit CORE_0_SP_SPILL_MAX_INTR_ENA.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_SP_SPILL_MAX_INTR_ENA = 0x200
	// Position of CORE_0_IRAM0_EXCEPTION_MONITOR_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_IRAM0_EXCEPTION_MONITOR_INTR_ENA_Pos = 0xa
	// Bit mask of CORE_0_IRAM0_EXCEPTION_MONITOR_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_IRAM0_EXCEPTION_MONITOR_INTR_ENA_Msk = 0x400
	// Bit CORE_0_IRAM0_EXCEPTION_MONITOR_INTR_ENA.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_IRAM0_EXCEPTION_MONITOR_INTR_ENA = 0x400
	// Position of CORE_0_DRAM0_EXCEPTION_MONITOR_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_DRAM0_EXCEPTION_MONITOR_INTR_ENA_Pos = 0xb
	// Bit mask of CORE_0_DRAM0_EXCEPTION_MONITOR_INTR_ENA field.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_DRAM0_EXCEPTION_MONITOR_INTR_ENA_Msk = 0x800
	// Bit CORE_0_DRAM0_EXCEPTION_MONITOR_INTR_ENA.
	ASSIST_DEBUG_CORE_0_INTR_ENA_CORE_0_DRAM0_EXCEPTION_MONITOR_INTR_ENA = 0x800

	// CORE_0_INTR_CLR: core0 monitor interrupt clr register
	// Position of CORE_0_AREA_DRAM0_0_RD_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_DRAM0_0_RD_CLR_Pos = 0x0
	// Bit mask of CORE_0_AREA_DRAM0_0_RD_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_DRAM0_0_RD_CLR_Msk = 0x1
	// Bit CORE_0_AREA_DRAM0_0_RD_CLR.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_DRAM0_0_RD_CLR = 0x1
	// Position of CORE_0_AREA_DRAM0_0_WR_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_DRAM0_0_WR_CLR_Pos = 0x1
	// Bit mask of CORE_0_AREA_DRAM0_0_WR_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_DRAM0_0_WR_CLR_Msk = 0x2
	// Bit CORE_0_AREA_DRAM0_0_WR_CLR.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_DRAM0_0_WR_CLR = 0x2
	// Position of CORE_0_AREA_DRAM0_1_RD_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_DRAM0_1_RD_CLR_Pos = 0x2
	// Bit mask of CORE_0_AREA_DRAM0_1_RD_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_DRAM0_1_RD_CLR_Msk = 0x4
	// Bit CORE_0_AREA_DRAM0_1_RD_CLR.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_DRAM0_1_RD_CLR = 0x4
	// Position of CORE_0_AREA_DRAM0_1_WR_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_DRAM0_1_WR_CLR_Pos = 0x3
	// Bit mask of CORE_0_AREA_DRAM0_1_WR_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_DRAM0_1_WR_CLR_Msk = 0x8
	// Bit CORE_0_AREA_DRAM0_1_WR_CLR.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_DRAM0_1_WR_CLR = 0x8
	// Position of CORE_0_AREA_PIF_0_RD_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_PIF_0_RD_CLR_Pos = 0x4
	// Bit mask of CORE_0_AREA_PIF_0_RD_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_PIF_0_RD_CLR_Msk = 0x10
	// Bit CORE_0_AREA_PIF_0_RD_CLR.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_PIF_0_RD_CLR = 0x10
	// Position of CORE_0_AREA_PIF_0_WR_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_PIF_0_WR_CLR_Pos = 0x5
	// Bit mask of CORE_0_AREA_PIF_0_WR_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_PIF_0_WR_CLR_Msk = 0x20
	// Bit CORE_0_AREA_PIF_0_WR_CLR.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_PIF_0_WR_CLR = 0x20
	// Position of CORE_0_AREA_PIF_1_RD_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_PIF_1_RD_CLR_Pos = 0x6
	// Bit mask of CORE_0_AREA_PIF_1_RD_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_PIF_1_RD_CLR_Msk = 0x40
	// Bit CORE_0_AREA_PIF_1_RD_CLR.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_PIF_1_RD_CLR = 0x40
	// Position of CORE_0_AREA_PIF_1_WR_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_PIF_1_WR_CLR_Pos = 0x7
	// Bit mask of CORE_0_AREA_PIF_1_WR_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_PIF_1_WR_CLR_Msk = 0x80
	// Bit CORE_0_AREA_PIF_1_WR_CLR.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_AREA_PIF_1_WR_CLR = 0x80
	// Position of CORE_0_SP_SPILL_MIN_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_SP_SPILL_MIN_CLR_Pos = 0x8
	// Bit mask of CORE_0_SP_SPILL_MIN_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_SP_SPILL_MIN_CLR_Msk = 0x100
	// Bit CORE_0_SP_SPILL_MIN_CLR.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_SP_SPILL_MIN_CLR = 0x100
	// Position of CORE_0_SP_SPILL_MAX_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_SP_SPILL_MAX_CLR_Pos = 0x9
	// Bit mask of CORE_0_SP_SPILL_MAX_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_SP_SPILL_MAX_CLR_Msk = 0x200
	// Bit CORE_0_SP_SPILL_MAX_CLR.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_SP_SPILL_MAX_CLR = 0x200
	// Position of CORE_0_IRAM0_EXCEPTION_MONITOR_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_IRAM0_EXCEPTION_MONITOR_CLR_Pos = 0xa
	// Bit mask of CORE_0_IRAM0_EXCEPTION_MONITOR_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_IRAM0_EXCEPTION_MONITOR_CLR_Msk = 0x400
	// Bit CORE_0_IRAM0_EXCEPTION_MONITOR_CLR.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_IRAM0_EXCEPTION_MONITOR_CLR = 0x400
	// Position of CORE_0_DRAM0_EXCEPTION_MONITOR_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_DRAM0_EXCEPTION_MONITOR_CLR_Pos = 0xb
	// Bit mask of CORE_0_DRAM0_EXCEPTION_MONITOR_CLR field.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_DRAM0_EXCEPTION_MONITOR_CLR_Msk = 0x800
	// Bit CORE_0_DRAM0_EXCEPTION_MONITOR_CLR.
	ASSIST_DEBUG_CORE_0_INTR_CLR_CORE_0_DRAM0_EXCEPTION_MONITOR_CLR = 0x800

	// CORE_0_AREA_DRAM0_0_MIN: core0 dram0 region0 addr configuration register
	// Position of CORE_0_AREA_DRAM0_0_MIN field.
	ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MIN_CORE_0_AREA_DRAM0_0_MIN_Pos = 0x0
	// Bit mask of CORE_0_AREA_DRAM0_0_MIN field.
	ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MIN_CORE_0_AREA_DRAM0_0_MIN_Msk = 0xffffffff

	// CORE_0_AREA_DRAM0_0_MAX: core0 dram0 region0 addr configuration register
	// Position of CORE_0_AREA_DRAM0_0_MAX field.
	ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MAX_CORE_0_AREA_DRAM0_0_MAX_Pos = 0x0
	// Bit mask of CORE_0_AREA_DRAM0_0_MAX field.
	ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MAX_CORE_0_AREA_DRAM0_0_MAX_Msk = 0xffffffff

	// CORE_0_AREA_DRAM0_1_MIN: core0 dram0 region1 addr configuration register
	// Position of CORE_0_AREA_DRAM0_1_MIN field.
	ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MIN_CORE_0_AREA_DRAM0_1_MIN_Pos = 0x0
	// Bit mask of CORE_0_AREA_DRAM0_1_MIN field.
	ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MIN_CORE_0_AREA_DRAM0_1_MIN_Msk = 0xffffffff

	// CORE_0_AREA_DRAM0_1_MAX: core0 dram0 region1 addr configuration register
	// Position of CORE_0_AREA_DRAM0_1_MAX field.
	ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MAX_CORE_0_AREA_DRAM0_1_MAX_Pos = 0x0
	// Bit mask of CORE_0_AREA_DRAM0_1_MAX field.
	ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MAX_CORE_0_AREA_DRAM0_1_MAX_Msk = 0xffffffff

	// CORE_0_AREA_PIF_0_MIN: core0 PIF region0 addr configuration register
	// Position of CORE_0_AREA_PIF_0_MIN field.
	ASSIST_DEBUG_CORE_0_AREA_PIF_0_MIN_CORE_0_AREA_PIF_0_MIN_Pos = 0x0
	// Bit mask of CORE_0_AREA_PIF_0_MIN field.
	ASSIST_DEBUG_CORE_0_AREA_PIF_0_MIN_CORE_0_AREA_PIF_0_MIN_Msk = 0xffffffff

	// CORE_0_AREA_PIF_0_MAX: core0 PIF region0 addr configuration register
	// Position of CORE_0_AREA_PIF_0_MAX field.
	ASSIST_DEBUG_CORE_0_AREA_PIF_0_MAX_CORE_0_AREA_PIF_0_MAX_Pos = 0x0
	// Bit mask of CORE_0_AREA_PIF_0_MAX field.
	ASSIST_DEBUG_CORE_0_AREA_PIF_0_MAX_CORE_0_AREA_PIF_0_MAX_Msk = 0xffffffff

	// CORE_0_AREA_PIF_1_MIN: core0 PIF region1 addr configuration register
	// Position of CORE_0_AREA_PIF_1_MIN field.
	ASSIST_DEBUG_CORE_0_AREA_PIF_1_MIN_CORE_0_AREA_PIF_1_MIN_Pos = 0x0
	// Bit mask of CORE_0_AREA_PIF_1_MIN field.
	ASSIST_DEBUG_CORE_0_AREA_PIF_1_MIN_CORE_0_AREA_PIF_1_MIN_Msk = 0xffffffff

	// CORE_0_AREA_PIF_1_MAX: core0 PIF region1 addr configuration register
	// Position of CORE_0_AREA_PIF_1_MAX field.
	ASSIST_DEBUG_CORE_0_AREA_PIF_1_MAX_CORE_0_AREA_PIF_1_MAX_Pos = 0x0
	// Bit mask of CORE_0_AREA_PIF_1_MAX field.
	ASSIST_DEBUG_CORE_0_AREA_PIF_1_MAX_CORE_0_AREA_PIF_1_MAX_Msk = 0xffffffff

	// CORE_0_AREA_PC: core0 area pc status register
	// Position of CORE_0_AREA_PC field.
	ASSIST_DEBUG_CORE_0_AREA_PC_CORE_0_AREA_PC_Pos = 0x0
	// Bit mask of CORE_0_AREA_PC field.
	ASSIST_DEBUG_CORE_0_AREA_PC_CORE_0_AREA_PC_Msk = 0xffffffff

	// CORE_0_AREA_SP: core0 area sp status register
	// Position of CORE_0_AREA_SP field.
	ASSIST_DEBUG_CORE_0_AREA_SP_CORE_0_AREA_SP_Pos = 0x0
	// Bit mask of CORE_0_AREA_SP field.
	ASSIST_DEBUG_CORE_0_AREA_SP_CORE_0_AREA_SP_Msk = 0xffffffff

	// CORE_0_SP_MIN: stack min value
	// Position of CORE_0_SP_MIN field.
	ASSIST_DEBUG_CORE_0_SP_MIN_CORE_0_SP_MIN_Pos = 0x0
	// Bit mask of CORE_0_SP_MIN field.
	ASSIST_DEBUG_CORE_0_SP_MIN_CORE_0_SP_MIN_Msk = 0xffffffff

	// CORE_0_SP_MAX: stack max value
	// Position of CORE_0_SP_MAX field.
	ASSIST_DEBUG_CORE_0_SP_MAX_CORE_0_SP_MAX_Pos = 0x0
	// Bit mask of CORE_0_SP_MAX field.
	ASSIST_DEBUG_CORE_0_SP_MAX_CORE_0_SP_MAX_Msk = 0xffffffff

	// CORE_0_SP_PC: stack monitor pc status register
	// Position of CORE_0_SP_PC field.
	ASSIST_DEBUG_CORE_0_SP_PC_CORE_0_SP_PC_Pos = 0x0
	// Bit mask of CORE_0_SP_PC field.
	ASSIST_DEBUG_CORE_0_SP_PC_CORE_0_SP_PC_Msk = 0xffffffff

	// CORE_0_RCD_EN: record enable configuration register
	// Position of CORE_0_RCD_RECORDEN field.
	ASSIST_DEBUG_CORE_0_RCD_EN_CORE_0_RCD_RECORDEN_Pos = 0x0
	// Bit mask of CORE_0_RCD_RECORDEN field.
	ASSIST_DEBUG_CORE_0_RCD_EN_CORE_0_RCD_RECORDEN_Msk = 0x1
	// Bit CORE_0_RCD_RECORDEN.
	ASSIST_DEBUG_CORE_0_RCD_EN_CORE_0_RCD_RECORDEN = 0x1
	// Position of CORE_0_RCD_PDEBUGEN field.
	ASSIST_DEBUG_CORE_0_RCD_EN_CORE_0_RCD_PDEBUGEN_Pos = 0x1
	// Bit mask of CORE_0_RCD_PDEBUGEN field.
	ASSIST_DEBUG_CORE_0_RCD_EN_CORE_0_RCD_PDEBUGEN_Msk = 0x2
	// Bit CORE_0_RCD_PDEBUGEN.
	ASSIST_DEBUG_CORE_0_RCD_EN_CORE_0_RCD_PDEBUGEN = 0x2

	// CORE_0_RCD_PDEBUGPC: record status regsiter
	// Position of CORE_0_RCD_PDEBUGPC field.
	ASSIST_DEBUG_CORE_0_RCD_PDEBUGPC_CORE_0_RCD_PDEBUGPC_Pos = 0x0
	// Bit mask of CORE_0_RCD_PDEBUGPC field.
	ASSIST_DEBUG_CORE_0_RCD_PDEBUGPC_CORE_0_RCD_PDEBUGPC_Msk = 0xffffffff

	// CORE_0_RCD_PDEBUGSP: record status regsiter
	// Position of CORE_0_RCD_PDEBUGSP field.
	ASSIST_DEBUG_CORE_0_RCD_PDEBUGSP_CORE_0_RCD_PDEBUGSP_Pos = 0x0
	// Bit mask of CORE_0_RCD_PDEBUGSP field.
	ASSIST_DEBUG_CORE_0_RCD_PDEBUGSP_CORE_0_RCD_PDEBUGSP_Msk = 0xffffffff

	// CORE_0_IRAM0_EXCEPTION_MONITOR_0: exception monitor status register0
	// Position of CORE_0_IRAM0_RECORDING_ADDR_0 field.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_ADDR_0_Pos = 0x0
	// Bit mask of CORE_0_IRAM0_RECORDING_ADDR_0 field.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_ADDR_0_Msk = 0xffffff
	// Position of CORE_0_IRAM0_RECORDING_WR_0 field.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_WR_0_Pos = 0x18
	// Bit mask of CORE_0_IRAM0_RECORDING_WR_0 field.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_WR_0_Msk = 0x1000000
	// Bit CORE_0_IRAM0_RECORDING_WR_0.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_WR_0 = 0x1000000
	// Position of CORE_0_IRAM0_RECORDING_LOADSTORE_0 field.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_LOADSTORE_0_Pos = 0x19
	// Bit mask of CORE_0_IRAM0_RECORDING_LOADSTORE_0 field.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_LOADSTORE_0_Msk = 0x2000000
	// Bit CORE_0_IRAM0_RECORDING_LOADSTORE_0.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_0_CORE_0_IRAM0_RECORDING_LOADSTORE_0 = 0x2000000

	// CORE_0_IRAM0_EXCEPTION_MONITOR_1: exception monitor status register1
	// Position of CORE_0_IRAM0_RECORDING_ADDR_1 field.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_ADDR_1_Pos = 0x0
	// Bit mask of CORE_0_IRAM0_RECORDING_ADDR_1 field.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_ADDR_1_Msk = 0xffffff
	// Position of CORE_0_IRAM0_RECORDING_WR_1 field.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_WR_1_Pos = 0x18
	// Bit mask of CORE_0_IRAM0_RECORDING_WR_1 field.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_WR_1_Msk = 0x1000000
	// Bit CORE_0_IRAM0_RECORDING_WR_1.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_WR_1 = 0x1000000
	// Position of CORE_0_IRAM0_RECORDING_LOADSTORE_1 field.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_LOADSTORE_1_Pos = 0x19
	// Bit mask of CORE_0_IRAM0_RECORDING_LOADSTORE_1 field.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_LOADSTORE_1_Msk = 0x2000000
	// Bit CORE_0_IRAM0_RECORDING_LOADSTORE_1.
	ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_1_CORE_0_IRAM0_RECORDING_LOADSTORE_1 = 0x2000000

	// CORE_0_DRAM0_EXCEPTION_MONITOR_0: exception monitor status register2
	// Position of CORE_0_DRAM0_RECORDING_ADDR_0 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_0_CORE_0_DRAM0_RECORDING_ADDR_0_Pos = 0x0
	// Bit mask of CORE_0_DRAM0_RECORDING_ADDR_0 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_0_CORE_0_DRAM0_RECORDING_ADDR_0_Msk = 0xffffff
	// Position of CORE_0_DRAM0_RECORDING_WR_0 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_0_CORE_0_DRAM0_RECORDING_WR_0_Pos = 0x18
	// Bit mask of CORE_0_DRAM0_RECORDING_WR_0 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_0_CORE_0_DRAM0_RECORDING_WR_0_Msk = 0x1000000
	// Bit CORE_0_DRAM0_RECORDING_WR_0.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_0_CORE_0_DRAM0_RECORDING_WR_0 = 0x1000000
	// Position of CORE_0_DRAM0_RECORDING_BYTEEN_0 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_0_CORE_0_DRAM0_RECORDING_BYTEEN_0_Pos = 0x19
	// Bit mask of CORE_0_DRAM0_RECORDING_BYTEEN_0 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_0_CORE_0_DRAM0_RECORDING_BYTEEN_0_Msk = 0x1e000000

	// CORE_0_DRAM0_EXCEPTION_MONITOR_1: exception monitor status register3
	// Position of CORE_0_DRAM0_RECORDING_PC_0 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_1_CORE_0_DRAM0_RECORDING_PC_0_Pos = 0x0
	// Bit mask of CORE_0_DRAM0_RECORDING_PC_0 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_1_CORE_0_DRAM0_RECORDING_PC_0_Msk = 0xffffffff

	// CORE_0_DRAM0_EXCEPTION_MONITOR_2: exception monitor status register4
	// Position of CORE_0_DRAM0_RECORDING_ADDR_1 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_2_CORE_0_DRAM0_RECORDING_ADDR_1_Pos = 0x0
	// Bit mask of CORE_0_DRAM0_RECORDING_ADDR_1 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_2_CORE_0_DRAM0_RECORDING_ADDR_1_Msk = 0xffffff
	// Position of CORE_0_DRAM0_RECORDING_WR_1 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_2_CORE_0_DRAM0_RECORDING_WR_1_Pos = 0x18
	// Bit mask of CORE_0_DRAM0_RECORDING_WR_1 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_2_CORE_0_DRAM0_RECORDING_WR_1_Msk = 0x1000000
	// Bit CORE_0_DRAM0_RECORDING_WR_1.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_2_CORE_0_DRAM0_RECORDING_WR_1 = 0x1000000
	// Position of CORE_0_DRAM0_RECORDING_BYTEEN_1 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_2_CORE_0_DRAM0_RECORDING_BYTEEN_1_Pos = 0x19
	// Bit mask of CORE_0_DRAM0_RECORDING_BYTEEN_1 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_2_CORE_0_DRAM0_RECORDING_BYTEEN_1_Msk = 0x1e000000

	// CORE_0_DRAM0_EXCEPTION_MONITOR_3: exception monitor status register5
	// Position of CORE_0_DRAM0_RECORDING_PC_1 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_3_CORE_0_DRAM0_RECORDING_PC_1_Pos = 0x0
	// Bit mask of CORE_0_DRAM0_RECORDING_PC_1 field.
	ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_3_CORE_0_DRAM0_RECORDING_PC_1_Msk = 0xffffffff

	// CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0: exception monitor status register6
	// Position of CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0 field.
	ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0_Pos = 0x0
	// Bit mask of CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0 field.
	ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0_Msk = 0xfffff

	// CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1: exception monitor status register7
	// Position of CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1 field.
	ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1_Pos = 0x0
	// Bit mask of CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1 field.
	ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1_Msk = 0xfffff

	// C0RE_0_LASTPC_BEFORE_EXCEPTION: cpu status register
	// Position of CORE_0_LASTPC_BEFORE_EXC field.
	ASSIST_DEBUG_C0RE_0_LASTPC_BEFORE_EXCEPTION_CORE_0_LASTPC_BEFORE_EXC_Pos = 0x0
	// Bit mask of CORE_0_LASTPC_BEFORE_EXC field.
	ASSIST_DEBUG_C0RE_0_LASTPC_BEFORE_EXCEPTION_CORE_0_LASTPC_BEFORE_EXC_Msk = 0xffffffff

	// C0RE_0_DEBUG_MODE: cpu status register
	// Position of CORE_0_DEBUG_MODE field.
	ASSIST_DEBUG_C0RE_0_DEBUG_MODE_CORE_0_DEBUG_MODE_Pos = 0x0
	// Bit mask of CORE_0_DEBUG_MODE field.
	ASSIST_DEBUG_C0RE_0_DEBUG_MODE_CORE_0_DEBUG_MODE_Msk = 0x1
	// Bit CORE_0_DEBUG_MODE.
	ASSIST_DEBUG_C0RE_0_DEBUG_MODE_CORE_0_DEBUG_MODE = 0x1
	// Position of CORE_0_DEBUG_MODULE_ACTIVE field.
	ASSIST_DEBUG_C0RE_0_DEBUG_MODE_CORE_0_DEBUG_MODULE_ACTIVE_Pos = 0x1
	// Bit mask of CORE_0_DEBUG_MODULE_ACTIVE field.
	ASSIST_DEBUG_C0RE_0_DEBUG_MODE_CORE_0_DEBUG_MODULE_ACTIVE_Msk = 0x2
	// Bit CORE_0_DEBUG_MODULE_ACTIVE.
	ASSIST_DEBUG_C0RE_0_DEBUG_MODE_CORE_0_DEBUG_MODULE_ACTIVE = 0x2

	// CLOCK_GATE: clock register
	// Position of CLK_EN field.
	ASSIST_DEBUG_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	ASSIST_DEBUG_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	ASSIST_DEBUG_CLOCK_GATE_CLK_EN = 0x1

	// DATE: version register
	// Position of ASSIST_DEBUG_DATE field.
	ASSIST_DEBUG_DATE_ASSIST_DEBUG_DATE_Pos = 0x0
	// Bit mask of ASSIST_DEBUG_DATE field.
	ASSIST_DEBUG_DATE_ASSIST_DEBUG_DATE_Msk = 0xfffffff
)

// Constants for DMA: DMA (Direct Memory Access) Controller
const (
	// IN_INT_RAW_CH0: Raw status interrupt of channel 0
	// Position of IN_DONE field.
	DMA_IN_INT_RAW_CH_IN_DONE_Pos = 0x0
	// Bit mask of IN_DONE field.
	DMA_IN_INT_RAW_CH_IN_DONE_Msk = 0x1
	// Bit IN_DONE.
	DMA_IN_INT_RAW_CH_IN_DONE = 0x1
	// Position of IN_SUC_EOF field.
	DMA_IN_INT_RAW_CH_IN_SUC_EOF_Pos = 0x1
	// Bit mask of IN_SUC_EOF field.
	DMA_IN_INT_RAW_CH_IN_SUC_EOF_Msk = 0x2
	// Bit IN_SUC_EOF.
	DMA_IN_INT_RAW_CH_IN_SUC_EOF = 0x2
	// Position of IN_ERR_EOF field.
	DMA_IN_INT_RAW_CH_IN_ERR_EOF_Pos = 0x2
	// Bit mask of IN_ERR_EOF field.
	DMA_IN_INT_RAW_CH_IN_ERR_EOF_Msk = 0x4
	// Bit IN_ERR_EOF.
	DMA_IN_INT_RAW_CH_IN_ERR_EOF = 0x4
	// Position of IN_DSCR_ERR field.
	DMA_IN_INT_RAW_CH_IN_DSCR_ERR_Pos = 0x3
	// Bit mask of IN_DSCR_ERR field.
	DMA_IN_INT_RAW_CH_IN_DSCR_ERR_Msk = 0x8
	// Bit IN_DSCR_ERR.
	DMA_IN_INT_RAW_CH_IN_DSCR_ERR = 0x8
	// Position of IN_DSCR_EMPTY field.
	DMA_IN_INT_RAW_CH_IN_DSCR_EMPTY_Pos = 0x4
	// Bit mask of IN_DSCR_EMPTY field.
	DMA_IN_INT_RAW_CH_IN_DSCR_EMPTY_Msk = 0x10
	// Bit IN_DSCR_EMPTY.
	DMA_IN_INT_RAW_CH_IN_DSCR_EMPTY = 0x10
	// Position of INFIFO_OVF field.
	DMA_IN_INT_RAW_CH_INFIFO_OVF_Pos = 0x5
	// Bit mask of INFIFO_OVF field.
	DMA_IN_INT_RAW_CH_INFIFO_OVF_Msk = 0x20
	// Bit INFIFO_OVF.
	DMA_IN_INT_RAW_CH_INFIFO_OVF = 0x20
	// Position of INFIFO_UDF field.
	DMA_IN_INT_RAW_CH_INFIFO_UDF_Pos = 0x6
	// Bit mask of INFIFO_UDF field.
	DMA_IN_INT_RAW_CH_INFIFO_UDF_Msk = 0x40
	// Bit INFIFO_UDF.
	DMA_IN_INT_RAW_CH_INFIFO_UDF = 0x40

	// IN_INT_ST_CH0: Masked interrupt of channel 0
	// Position of IN_DONE field.
	DMA_IN_INT_ST_CH_IN_DONE_Pos = 0x0
	// Bit mask of IN_DONE field.
	DMA_IN_INT_ST_CH_IN_DONE_Msk = 0x1
	// Bit IN_DONE.
	DMA_IN_INT_ST_CH_IN_DONE = 0x1
	// Position of IN_SUC_EOF field.
	DMA_IN_INT_ST_CH_IN_SUC_EOF_Pos = 0x1
	// Bit mask of IN_SUC_EOF field.
	DMA_IN_INT_ST_CH_IN_SUC_EOF_Msk = 0x2
	// Bit IN_SUC_EOF.
	DMA_IN_INT_ST_CH_IN_SUC_EOF = 0x2
	// Position of IN_ERR_EOF field.
	DMA_IN_INT_ST_CH_IN_ERR_EOF_Pos = 0x2
	// Bit mask of IN_ERR_EOF field.
	DMA_IN_INT_ST_CH_IN_ERR_EOF_Msk = 0x4
	// Bit IN_ERR_EOF.
	DMA_IN_INT_ST_CH_IN_ERR_EOF = 0x4
	// Position of IN_DSCR_ERR field.
	DMA_IN_INT_ST_CH_IN_DSCR_ERR_Pos = 0x3
	// Bit mask of IN_DSCR_ERR field.
	DMA_IN_INT_ST_CH_IN_DSCR_ERR_Msk = 0x8
	// Bit IN_DSCR_ERR.
	DMA_IN_INT_ST_CH_IN_DSCR_ERR = 0x8
	// Position of IN_DSCR_EMPTY field.
	DMA_IN_INT_ST_CH_IN_DSCR_EMPTY_Pos = 0x4
	// Bit mask of IN_DSCR_EMPTY field.
	DMA_IN_INT_ST_CH_IN_DSCR_EMPTY_Msk = 0x10
	// Bit IN_DSCR_EMPTY.
	DMA_IN_INT_ST_CH_IN_DSCR_EMPTY = 0x10
	// Position of INFIFO_OVF field.
	DMA_IN_INT_ST_CH_INFIFO_OVF_Pos = 0x5
	// Bit mask of INFIFO_OVF field.
	DMA_IN_INT_ST_CH_INFIFO_OVF_Msk = 0x20
	// Bit INFIFO_OVF.
	DMA_IN_INT_ST_CH_INFIFO_OVF = 0x20
	// Position of INFIFO_UDF field.
	DMA_IN_INT_ST_CH_INFIFO_UDF_Pos = 0x6
	// Bit mask of INFIFO_UDF field.
	DMA_IN_INT_ST_CH_INFIFO_UDF_Msk = 0x40
	// Bit INFIFO_UDF.
	DMA_IN_INT_ST_CH_INFIFO_UDF = 0x40

	// IN_INT_ENA_CH0: Interrupt enable bits of channel 0
	// Position of IN_DONE field.
	DMA_IN_INT_ENA_CH_IN_DONE_Pos = 0x0
	// Bit mask of IN_DONE field.
	DMA_IN_INT_ENA_CH_IN_DONE_Msk = 0x1
	// Bit IN_DONE.
	DMA_IN_INT_ENA_CH_IN_DONE = 0x1
	// Position of IN_SUC_EOF field.
	DMA_IN_INT_ENA_CH_IN_SUC_EOF_Pos = 0x1
	// Bit mask of IN_SUC_EOF field.
	DMA_IN_INT_ENA_CH_IN_SUC_EOF_Msk = 0x2
	// Bit IN_SUC_EOF.
	DMA_IN_INT_ENA_CH_IN_SUC_EOF = 0x2
	// Position of IN_ERR_EOF field.
	DMA_IN_INT_ENA_CH_IN_ERR_EOF_Pos = 0x2
	// Bit mask of IN_ERR_EOF field.
	DMA_IN_INT_ENA_CH_IN_ERR_EOF_Msk = 0x4
	// Bit IN_ERR_EOF.
	DMA_IN_INT_ENA_CH_IN_ERR_EOF = 0x4
	// Position of IN_DSCR_ERR field.
	DMA_IN_INT_ENA_CH_IN_DSCR_ERR_Pos = 0x3
	// Bit mask of IN_DSCR_ERR field.
	DMA_IN_INT_ENA_CH_IN_DSCR_ERR_Msk = 0x8
	// Bit IN_DSCR_ERR.
	DMA_IN_INT_ENA_CH_IN_DSCR_ERR = 0x8
	// Position of IN_DSCR_EMPTY field.
	DMA_IN_INT_ENA_CH_IN_DSCR_EMPTY_Pos = 0x4
	// Bit mask of IN_DSCR_EMPTY field.
	DMA_IN_INT_ENA_CH_IN_DSCR_EMPTY_Msk = 0x10
	// Bit IN_DSCR_EMPTY.
	DMA_IN_INT_ENA_CH_IN_DSCR_EMPTY = 0x10
	// Position of INFIFO_OVF field.
	DMA_IN_INT_ENA_CH_INFIFO_OVF_Pos = 0x5
	// Bit mask of INFIFO_OVF field.
	DMA_IN_INT_ENA_CH_INFIFO_OVF_Msk = 0x20
	// Bit INFIFO_OVF.
	DMA_IN_INT_ENA_CH_INFIFO_OVF = 0x20
	// Position of INFIFO_UDF field.
	DMA_IN_INT_ENA_CH_INFIFO_UDF_Pos = 0x6
	// Bit mask of INFIFO_UDF field.
	DMA_IN_INT_ENA_CH_INFIFO_UDF_Msk = 0x40
	// Bit INFIFO_UDF.
	DMA_IN_INT_ENA_CH_INFIFO_UDF = 0x40

	// IN_INT_CLR_CH0: Interrupt clear bits of channel 0
	// Position of IN_DONE field.
	DMA_IN_INT_CLR_CH_IN_DONE_Pos = 0x0
	// Bit mask of IN_DONE field.
	DMA_IN_INT_CLR_CH_IN_DONE_Msk = 0x1
	// Bit IN_DONE.
	DMA_IN_INT_CLR_CH_IN_DONE = 0x1
	// Position of IN_SUC_EOF field.
	DMA_IN_INT_CLR_CH_IN_SUC_EOF_Pos = 0x1
	// Bit mask of IN_SUC_EOF field.
	DMA_IN_INT_CLR_CH_IN_SUC_EOF_Msk = 0x2
	// Bit IN_SUC_EOF.
	DMA_IN_INT_CLR_CH_IN_SUC_EOF = 0x2
	// Position of IN_ERR_EOF field.
	DMA_IN_INT_CLR_CH_IN_ERR_EOF_Pos = 0x2
	// Bit mask of IN_ERR_EOF field.
	DMA_IN_INT_CLR_CH_IN_ERR_EOF_Msk = 0x4
	// Bit IN_ERR_EOF.
	DMA_IN_INT_CLR_CH_IN_ERR_EOF = 0x4
	// Position of IN_DSCR_ERR field.
	DMA_IN_INT_CLR_CH_IN_DSCR_ERR_Pos = 0x3
	// Bit mask of IN_DSCR_ERR field.
	DMA_IN_INT_CLR_CH_IN_DSCR_ERR_Msk = 0x8
	// Bit IN_DSCR_ERR.
	DMA_IN_INT_CLR_CH_IN_DSCR_ERR = 0x8
	// Position of IN_DSCR_EMPTY field.
	DMA_IN_INT_CLR_CH_IN_DSCR_EMPTY_Pos = 0x4
	// Bit mask of IN_DSCR_EMPTY field.
	DMA_IN_INT_CLR_CH_IN_DSCR_EMPTY_Msk = 0x10
	// Bit IN_DSCR_EMPTY.
	DMA_IN_INT_CLR_CH_IN_DSCR_EMPTY = 0x10
	// Position of INFIFO_OVF field.
	DMA_IN_INT_CLR_CH_INFIFO_OVF_Pos = 0x5
	// Bit mask of INFIFO_OVF field.
	DMA_IN_INT_CLR_CH_INFIFO_OVF_Msk = 0x20
	// Bit INFIFO_OVF.
	DMA_IN_INT_CLR_CH_INFIFO_OVF = 0x20
	// Position of INFIFO_UDF field.
	DMA_IN_INT_CLR_CH_INFIFO_UDF_Pos = 0x6
	// Bit mask of INFIFO_UDF field.
	DMA_IN_INT_CLR_CH_INFIFO_UDF_Msk = 0x40
	// Bit INFIFO_UDF.
	DMA_IN_INT_CLR_CH_INFIFO_UDF = 0x40

	// OUT_INT_RAW_CH0: Raw status interrupt of channel 0
	// Position of OUT_DONE field.
	DMA_OUT_INT_RAW_CH_OUT_DONE_Pos = 0x0
	// Bit mask of OUT_DONE field.
	DMA_OUT_INT_RAW_CH_OUT_DONE_Msk = 0x1
	// Bit OUT_DONE.
	DMA_OUT_INT_RAW_CH_OUT_DONE = 0x1
	// Position of OUT_EOF field.
	DMA_OUT_INT_RAW_CH_OUT_EOF_Pos = 0x1
	// Bit mask of OUT_EOF field.
	DMA_OUT_INT_RAW_CH_OUT_EOF_Msk = 0x2
	// Bit OUT_EOF.
	DMA_OUT_INT_RAW_CH_OUT_EOF = 0x2
	// Position of OUT_DSCR_ERR field.
	DMA_OUT_INT_RAW_CH_OUT_DSCR_ERR_Pos = 0x2
	// Bit mask of OUT_DSCR_ERR field.
	DMA_OUT_INT_RAW_CH_OUT_DSCR_ERR_Msk = 0x4
	// Bit OUT_DSCR_ERR.
	DMA_OUT_INT_RAW_CH_OUT_DSCR_ERR = 0x4
	// Position of OUT_TOTAL_EOF field.
	DMA_OUT_INT_RAW_CH_OUT_TOTAL_EOF_Pos = 0x3
	// Bit mask of OUT_TOTAL_EOF field.
	DMA_OUT_INT_RAW_CH_OUT_TOTAL_EOF_Msk = 0x8
	// Bit OUT_TOTAL_EOF.
	DMA_OUT_INT_RAW_CH_OUT_TOTAL_EOF = 0x8
	// Position of OUTFIFO_OVF field.
	DMA_OUT_INT_RAW_CH_OUTFIFO_OVF_Pos = 0x4
	// Bit mask of OUTFIFO_OVF field.
	DMA_OUT_INT_RAW_CH_OUTFIFO_OVF_Msk = 0x10
	// Bit OUTFIFO_OVF.
	DMA_OUT_INT_RAW_CH_OUTFIFO_OVF = 0x10
	// Position of OUTFIFO_UDF field.
	DMA_OUT_INT_RAW_CH_OUTFIFO_UDF_Pos = 0x5
	// Bit mask of OUTFIFO_UDF field.
	DMA_OUT_INT_RAW_CH_OUTFIFO_UDF_Msk = 0x20
	// Bit OUTFIFO_UDF.
	DMA_OUT_INT_RAW_CH_OUTFIFO_UDF = 0x20

	// OUT_INT_ST_CH0: Masked interrupt of channel 0
	// Position of OUT_DONE field.
	DMA_OUT_INT_ST_CH_OUT_DONE_Pos = 0x0
	// Bit mask of OUT_DONE field.
	DMA_OUT_INT_ST_CH_OUT_DONE_Msk = 0x1
	// Bit OUT_DONE.
	DMA_OUT_INT_ST_CH_OUT_DONE = 0x1
	// Position of OUT_EOF field.
	DMA_OUT_INT_ST_CH_OUT_EOF_Pos = 0x1
	// Bit mask of OUT_EOF field.
	DMA_OUT_INT_ST_CH_OUT_EOF_Msk = 0x2
	// Bit OUT_EOF.
	DMA_OUT_INT_ST_CH_OUT_EOF = 0x2
	// Position of OUT_DSCR_ERR field.
	DMA_OUT_INT_ST_CH_OUT_DSCR_ERR_Pos = 0x2
	// Bit mask of OUT_DSCR_ERR field.
	DMA_OUT_INT_ST_CH_OUT_DSCR_ERR_Msk = 0x4
	// Bit OUT_DSCR_ERR.
	DMA_OUT_INT_ST_CH_OUT_DSCR_ERR = 0x4
	// Position of OUT_TOTAL_EOF field.
	DMA_OUT_INT_ST_CH_OUT_TOTAL_EOF_Pos = 0x3
	// Bit mask of OUT_TOTAL_EOF field.
	DMA_OUT_INT_ST_CH_OUT_TOTAL_EOF_Msk = 0x8
	// Bit OUT_TOTAL_EOF.
	DMA_OUT_INT_ST_CH_OUT_TOTAL_EOF = 0x8
	// Position of OUTFIFO_OVF field.
	DMA_OUT_INT_ST_CH_OUTFIFO_OVF_Pos = 0x4
	// Bit mask of OUTFIFO_OVF field.
	DMA_OUT_INT_ST_CH_OUTFIFO_OVF_Msk = 0x10
	// Bit OUTFIFO_OVF.
	DMA_OUT_INT_ST_CH_OUTFIFO_OVF = 0x10
	// Position of OUTFIFO_UDF field.
	DMA_OUT_INT_ST_CH_OUTFIFO_UDF_Pos = 0x5
	// Bit mask of OUTFIFO_UDF field.
	DMA_OUT_INT_ST_CH_OUTFIFO_UDF_Msk = 0x20
	// Bit OUTFIFO_UDF.
	DMA_OUT_INT_ST_CH_OUTFIFO_UDF = 0x20

	// OUT_INT_ENA_CH0: Interrupt enable bits of channel 0
	// Position of OUT_DONE field.
	DMA_OUT_INT_ENA_CH_OUT_DONE_Pos = 0x0
	// Bit mask of OUT_DONE field.
	DMA_OUT_INT_ENA_CH_OUT_DONE_Msk = 0x1
	// Bit OUT_DONE.
	DMA_OUT_INT_ENA_CH_OUT_DONE = 0x1
	// Position of OUT_EOF field.
	DMA_OUT_INT_ENA_CH_OUT_EOF_Pos = 0x1
	// Bit mask of OUT_EOF field.
	DMA_OUT_INT_ENA_CH_OUT_EOF_Msk = 0x2
	// Bit OUT_EOF.
	DMA_OUT_INT_ENA_CH_OUT_EOF = 0x2
	// Position of OUT_DSCR_ERR field.
	DMA_OUT_INT_ENA_CH_OUT_DSCR_ERR_Pos = 0x2
	// Bit mask of OUT_DSCR_ERR field.
	DMA_OUT_INT_ENA_CH_OUT_DSCR_ERR_Msk = 0x4
	// Bit OUT_DSCR_ERR.
	DMA_OUT_INT_ENA_CH_OUT_DSCR_ERR = 0x4
	// Position of OUT_TOTAL_EOF field.
	DMA_OUT_INT_ENA_CH_OUT_TOTAL_EOF_Pos = 0x3
	// Bit mask of OUT_TOTAL_EOF field.
	DMA_OUT_INT_ENA_CH_OUT_TOTAL_EOF_Msk = 0x8
	// Bit OUT_TOTAL_EOF.
	DMA_OUT_INT_ENA_CH_OUT_TOTAL_EOF = 0x8
	// Position of OUTFIFO_OVF field.
	DMA_OUT_INT_ENA_CH_OUTFIFO_OVF_Pos = 0x4
	// Bit mask of OUTFIFO_OVF field.
	DMA_OUT_INT_ENA_CH_OUTFIFO_OVF_Msk = 0x10
	// Bit OUTFIFO_OVF.
	DMA_OUT_INT_ENA_CH_OUTFIFO_OVF = 0x10
	// Position of OUTFIFO_UDF field.
	DMA_OUT_INT_ENA_CH_OUTFIFO_UDF_Pos = 0x5
	// Bit mask of OUTFIFO_UDF field.
	DMA_OUT_INT_ENA_CH_OUTFIFO_UDF_Msk = 0x20
	// Bit OUTFIFO_UDF.
	DMA_OUT_INT_ENA_CH_OUTFIFO_UDF = 0x20

	// OUT_INT_CLR_CH0: Interrupt clear bits of channel 0
	// Position of OUT_DONE field.
	DMA_OUT_INT_CLR_CH_OUT_DONE_Pos = 0x0
	// Bit mask of OUT_DONE field.
	DMA_OUT_INT_CLR_CH_OUT_DONE_Msk = 0x1
	// Bit OUT_DONE.
	DMA_OUT_INT_CLR_CH_OUT_DONE = 0x1
	// Position of OUT_EOF field.
	DMA_OUT_INT_CLR_CH_OUT_EOF_Pos = 0x1
	// Bit mask of OUT_EOF field.
	DMA_OUT_INT_CLR_CH_OUT_EOF_Msk = 0x2
	// Bit OUT_EOF.
	DMA_OUT_INT_CLR_CH_OUT_EOF = 0x2
	// Position of OUT_DSCR_ERR field.
	DMA_OUT_INT_CLR_CH_OUT_DSCR_ERR_Pos = 0x2
	// Bit mask of OUT_DSCR_ERR field.
	DMA_OUT_INT_CLR_CH_OUT_DSCR_ERR_Msk = 0x4
	// Bit OUT_DSCR_ERR.
	DMA_OUT_INT_CLR_CH_OUT_DSCR_ERR = 0x4
	// Position of OUT_TOTAL_EOF field.
	DMA_OUT_INT_CLR_CH_OUT_TOTAL_EOF_Pos = 0x3
	// Bit mask of OUT_TOTAL_EOF field.
	DMA_OUT_INT_CLR_CH_OUT_TOTAL_EOF_Msk = 0x8
	// Bit OUT_TOTAL_EOF.
	DMA_OUT_INT_CLR_CH_OUT_TOTAL_EOF = 0x8
	// Position of OUTFIFO_OVF field.
	DMA_OUT_INT_CLR_CH_OUTFIFO_OVF_Pos = 0x4
	// Bit mask of OUTFIFO_OVF field.
	DMA_OUT_INT_CLR_CH_OUTFIFO_OVF_Msk = 0x10
	// Bit OUTFIFO_OVF.
	DMA_OUT_INT_CLR_CH_OUTFIFO_OVF = 0x10
	// Position of OUTFIFO_UDF field.
	DMA_OUT_INT_CLR_CH_OUTFIFO_UDF_Pos = 0x5
	// Bit mask of OUTFIFO_UDF field.
	DMA_OUT_INT_CLR_CH_OUTFIFO_UDF_Msk = 0x20
	// Bit OUTFIFO_UDF.
	DMA_OUT_INT_CLR_CH_OUTFIFO_UDF = 0x20

	// AHB_TEST: reserved
	// Position of AHB_TESTMODE field.
	DMA_AHB_TEST_AHB_TESTMODE_Pos = 0x0
	// Bit mask of AHB_TESTMODE field.
	DMA_AHB_TEST_AHB_TESTMODE_Msk = 0x7
	// Position of AHB_TESTADDR field.
	DMA_AHB_TEST_AHB_TESTADDR_Pos = 0x4
	// Bit mask of AHB_TESTADDR field.
	DMA_AHB_TEST_AHB_TESTADDR_Msk = 0x30

	// MISC_CONF: MISC register
	// Position of AHBM_RST_INTER field.
	DMA_MISC_CONF_AHBM_RST_INTER_Pos = 0x0
	// Bit mask of AHBM_RST_INTER field.
	DMA_MISC_CONF_AHBM_RST_INTER_Msk = 0x1
	// Bit AHBM_RST_INTER.
	DMA_MISC_CONF_AHBM_RST_INTER = 0x1
	// Position of ARB_PRI_DIS field.
	DMA_MISC_CONF_ARB_PRI_DIS_Pos = 0x2
	// Bit mask of ARB_PRI_DIS field.
	DMA_MISC_CONF_ARB_PRI_DIS_Msk = 0x4
	// Bit ARB_PRI_DIS.
	DMA_MISC_CONF_ARB_PRI_DIS = 0x4
	// Position of CLK_EN field.
	DMA_MISC_CONF_CLK_EN_Pos = 0x3
	// Bit mask of CLK_EN field.
	DMA_MISC_CONF_CLK_EN_Msk = 0x8
	// Bit CLK_EN.
	DMA_MISC_CONF_CLK_EN = 0x8

	// DATE: Version control register
	// Position of DATE field.
	DMA_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	DMA_DATE_DATE_Msk = 0xffffffff

	// IN_CONF0_CH0: Configure 0 register of Rx channel 0
	// Position of IN_RST field.
	DMA_IN_CONF0_CH_IN_RST_Pos = 0x0
	// Bit mask of IN_RST field.
	DMA_IN_CONF0_CH_IN_RST_Msk = 0x1
	// Bit IN_RST.
	DMA_IN_CONF0_CH_IN_RST = 0x1
	// Position of IN_LOOP_TEST field.
	DMA_IN_CONF0_CH_IN_LOOP_TEST_Pos = 0x1
	// Bit mask of IN_LOOP_TEST field.
	DMA_IN_CONF0_CH_IN_LOOP_TEST_Msk = 0x2
	// Bit IN_LOOP_TEST.
	DMA_IN_CONF0_CH_IN_LOOP_TEST = 0x2
	// Position of INDSCR_BURST_EN field.
	DMA_IN_CONF0_CH_INDSCR_BURST_EN_Pos = 0x2
	// Bit mask of INDSCR_BURST_EN field.
	DMA_IN_CONF0_CH_INDSCR_BURST_EN_Msk = 0x4
	// Bit INDSCR_BURST_EN.
	DMA_IN_CONF0_CH_INDSCR_BURST_EN = 0x4
	// Position of IN_DATA_BURST_EN field.
	DMA_IN_CONF0_CH_IN_DATA_BURST_EN_Pos = 0x3
	// Bit mask of IN_DATA_BURST_EN field.
	DMA_IN_CONF0_CH_IN_DATA_BURST_EN_Msk = 0x8
	// Bit IN_DATA_BURST_EN.
	DMA_IN_CONF0_CH_IN_DATA_BURST_EN = 0x8
	// Position of MEM_TRANS_EN field.
	DMA_IN_CONF0_CH_MEM_TRANS_EN_Pos = 0x4
	// Bit mask of MEM_TRANS_EN field.
	DMA_IN_CONF0_CH_MEM_TRANS_EN_Msk = 0x10
	// Bit MEM_TRANS_EN.
	DMA_IN_CONF0_CH_MEM_TRANS_EN = 0x10
	// Position of IN_ETM_EN field.
	DMA_IN_CONF0_CH_IN_ETM_EN_Pos = 0x5
	// Bit mask of IN_ETM_EN field.
	DMA_IN_CONF0_CH_IN_ETM_EN_Msk = 0x20
	// Bit IN_ETM_EN.
	DMA_IN_CONF0_CH_IN_ETM_EN = 0x20

	// IN_CONF1_CH0: Configure 1 register of Rx channel 0
	// Position of IN_CHECK_OWNER field.
	DMA_IN_CONF1_CH_IN_CHECK_OWNER_Pos = 0xc
	// Bit mask of IN_CHECK_OWNER field.
	DMA_IN_CONF1_CH_IN_CHECK_OWNER_Msk = 0x1000
	// Bit IN_CHECK_OWNER.
	DMA_IN_CONF1_CH_IN_CHECK_OWNER = 0x1000

	// INFIFO_STATUS_CH0: Receive FIFO status of Rx channel 0
	// Position of INFIFO_FULL field.
	DMA_INFIFO_STATUS_CH_INFIFO_FULL_Pos = 0x0
	// Bit mask of INFIFO_FULL field.
	DMA_INFIFO_STATUS_CH_INFIFO_FULL_Msk = 0x1
	// Bit INFIFO_FULL.
	DMA_INFIFO_STATUS_CH_INFIFO_FULL = 0x1
	// Position of INFIFO_EMPTY field.
	DMA_INFIFO_STATUS_CH_INFIFO_EMPTY_Pos = 0x1
	// Bit mask of INFIFO_EMPTY field.
	DMA_INFIFO_STATUS_CH_INFIFO_EMPTY_Msk = 0x2
	// Bit INFIFO_EMPTY.
	DMA_INFIFO_STATUS_CH_INFIFO_EMPTY = 0x2
	// Position of INFIFO_CNT field.
	DMA_INFIFO_STATUS_CH_INFIFO_CNT_Pos = 0x2
	// Bit mask of INFIFO_CNT field.
	DMA_INFIFO_STATUS_CH_INFIFO_CNT_Msk = 0xfc
	// Position of IN_REMAIN_UNDER_1B field.
	DMA_INFIFO_STATUS_CH_IN_REMAIN_UNDER_1B_Pos = 0x17
	// Bit mask of IN_REMAIN_UNDER_1B field.
	DMA_INFIFO_STATUS_CH_IN_REMAIN_UNDER_1B_Msk = 0x800000
	// Bit IN_REMAIN_UNDER_1B.
	DMA_INFIFO_STATUS_CH_IN_REMAIN_UNDER_1B = 0x800000
	// Position of IN_REMAIN_UNDER_2B field.
	DMA_INFIFO_STATUS_CH_IN_REMAIN_UNDER_2B_Pos = 0x18
	// Bit mask of IN_REMAIN_UNDER_2B field.
	DMA_INFIFO_STATUS_CH_IN_REMAIN_UNDER_2B_Msk = 0x1000000
	// Bit IN_REMAIN_UNDER_2B.
	DMA_INFIFO_STATUS_CH_IN_REMAIN_UNDER_2B = 0x1000000
	// Position of IN_REMAIN_UNDER_3B field.
	DMA_INFIFO_STATUS_CH_IN_REMAIN_UNDER_3B_Pos = 0x19
	// Bit mask of IN_REMAIN_UNDER_3B field.
	DMA_INFIFO_STATUS_CH_IN_REMAIN_UNDER_3B_Msk = 0x2000000
	// Bit IN_REMAIN_UNDER_3B.
	DMA_INFIFO_STATUS_CH_IN_REMAIN_UNDER_3B = 0x2000000
	// Position of IN_REMAIN_UNDER_4B field.
	DMA_INFIFO_STATUS_CH_IN_REMAIN_UNDER_4B_Pos = 0x1a
	// Bit mask of IN_REMAIN_UNDER_4B field.
	DMA_INFIFO_STATUS_CH_IN_REMAIN_UNDER_4B_Msk = 0x4000000
	// Bit IN_REMAIN_UNDER_4B.
	DMA_INFIFO_STATUS_CH_IN_REMAIN_UNDER_4B = 0x4000000
	// Position of IN_BUF_HUNGRY field.
	DMA_INFIFO_STATUS_CH_IN_BUF_HUNGRY_Pos = 0x1b
	// Bit mask of IN_BUF_HUNGRY field.
	DMA_INFIFO_STATUS_CH_IN_BUF_HUNGRY_Msk = 0x8000000
	// Bit IN_BUF_HUNGRY.
	DMA_INFIFO_STATUS_CH_IN_BUF_HUNGRY = 0x8000000

	// IN_POP_CH0: Pop control register of Rx channel 0
	// Position of INFIFO_RDATA field.
	DMA_IN_POP_CH_INFIFO_RDATA_Pos = 0x0
	// Bit mask of INFIFO_RDATA field.
	DMA_IN_POP_CH_INFIFO_RDATA_Msk = 0xfff
	// Position of INFIFO_POP field.
	DMA_IN_POP_CH_INFIFO_POP_Pos = 0xc
	// Bit mask of INFIFO_POP field.
	DMA_IN_POP_CH_INFIFO_POP_Msk = 0x1000
	// Bit INFIFO_POP.
	DMA_IN_POP_CH_INFIFO_POP = 0x1000

	// IN_LINK_CH0: Link descriptor configure and control register of Rx channel 0
	// Position of INLINK_ADDR field.
	DMA_IN_LINK_CH_INLINK_ADDR_Pos = 0x0
	// Bit mask of INLINK_ADDR field.
	DMA_IN_LINK_CH_INLINK_ADDR_Msk = 0xfffff
	// Position of INLINK_AUTO_RET field.
	DMA_IN_LINK_CH_INLINK_AUTO_RET_Pos = 0x14
	// Bit mask of INLINK_AUTO_RET field.
	DMA_IN_LINK_CH_INLINK_AUTO_RET_Msk = 0x100000
	// Bit INLINK_AUTO_RET.
	DMA_IN_LINK_CH_INLINK_AUTO_RET = 0x100000
	// Position of INLINK_STOP field.
	DMA_IN_LINK_CH_INLINK_STOP_Pos = 0x15
	// Bit mask of INLINK_STOP field.
	DMA_IN_LINK_CH_INLINK_STOP_Msk = 0x200000
	// Bit INLINK_STOP.
	DMA_IN_LINK_CH_INLINK_STOP = 0x200000
	// Position of INLINK_START field.
	DMA_IN_LINK_CH_INLINK_START_Pos = 0x16
	// Bit mask of INLINK_START field.
	DMA_IN_LINK_CH_INLINK_START_Msk = 0x400000
	// Bit INLINK_START.
	DMA_IN_LINK_CH_INLINK_START = 0x400000
	// Position of INLINK_RESTART field.
	DMA_IN_LINK_CH_INLINK_RESTART_Pos = 0x17
	// Bit mask of INLINK_RESTART field.
	DMA_IN_LINK_CH_INLINK_RESTART_Msk = 0x800000
	// Bit INLINK_RESTART.
	DMA_IN_LINK_CH_INLINK_RESTART = 0x800000
	// Position of INLINK_PARK field.
	DMA_IN_LINK_CH_INLINK_PARK_Pos = 0x18
	// Bit mask of INLINK_PARK field.
	DMA_IN_LINK_CH_INLINK_PARK_Msk = 0x1000000
	// Bit INLINK_PARK.
	DMA_IN_LINK_CH_INLINK_PARK = 0x1000000

	// IN_STATE_CH0: Receive status of Rx channel 0
	// Position of INLINK_DSCR_ADDR field.
	DMA_IN_STATE_CH_INLINK_DSCR_ADDR_Pos = 0x0
	// Bit mask of INLINK_DSCR_ADDR field.
	DMA_IN_STATE_CH_INLINK_DSCR_ADDR_Msk = 0x3ffff
	// Position of IN_DSCR_STATE field.
	DMA_IN_STATE_CH_IN_DSCR_STATE_Pos = 0x12
	// Bit mask of IN_DSCR_STATE field.
	DMA_IN_STATE_CH_IN_DSCR_STATE_Msk = 0xc0000
	// Position of IN_STATE field.
	DMA_IN_STATE_CH_IN_STATE_Pos = 0x14
	// Bit mask of IN_STATE field.
	DMA_IN_STATE_CH_IN_STATE_Msk = 0x700000

	// IN_SUC_EOF_DES_ADDR_CH0: Inlink descriptor address when EOF occurs of Rx channel 0
	// Position of IN_SUC_EOF_DES_ADDR field.
	DMA_IN_SUC_EOF_DES_ADDR_CH_IN_SUC_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of IN_SUC_EOF_DES_ADDR field.
	DMA_IN_SUC_EOF_DES_ADDR_CH_IN_SUC_EOF_DES_ADDR_Msk = 0xffffffff

	// IN_ERR_EOF_DES_ADDR_CH0: Inlink descriptor address when errors occur of Rx channel 0
	// Position of IN_ERR_EOF_DES_ADDR field.
	DMA_IN_ERR_EOF_DES_ADDR_CH_IN_ERR_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of IN_ERR_EOF_DES_ADDR field.
	DMA_IN_ERR_EOF_DES_ADDR_CH_IN_ERR_EOF_DES_ADDR_Msk = 0xffffffff

	// IN_DSCR_CH0: Current inlink descriptor address of Rx channel 0
	// Position of INLINK_DSCR field.
	DMA_IN_DSCR_CH_INLINK_DSCR_Pos = 0x0
	// Bit mask of INLINK_DSCR field.
	DMA_IN_DSCR_CH_INLINK_DSCR_Msk = 0xffffffff

	// IN_DSCR_BF0_CH0: The last inlink descriptor address of Rx channel 0
	// Position of INLINK_DSCR_BF0 field.
	DMA_IN_DSCR_BF0_CH_INLINK_DSCR_BF0_Pos = 0x0
	// Bit mask of INLINK_DSCR_BF0 field.
	DMA_IN_DSCR_BF0_CH_INLINK_DSCR_BF0_Msk = 0xffffffff

	// IN_DSCR_BF1_CH0: The second-to-last inlink descriptor address of Rx channel 0
	// Position of INLINK_DSCR_BF1 field.
	DMA_IN_DSCR_BF1_CH_INLINK_DSCR_BF1_Pos = 0x0
	// Bit mask of INLINK_DSCR_BF1 field.
	DMA_IN_DSCR_BF1_CH_INLINK_DSCR_BF1_Msk = 0xffffffff

	// IN_PRI_CH0: Priority register of Rx channel 0
	// Position of RX_PRI field.
	DMA_IN_PRI_CH_RX_PRI_Pos = 0x0
	// Bit mask of RX_PRI field.
	DMA_IN_PRI_CH_RX_PRI_Msk = 0xf

	// IN_PERI_SEL_CH0: Peripheral selection of Rx channel 0
	// Position of PERI_IN_SEL field.
	DMA_IN_PERI_SEL_CH_PERI_IN_SEL_Pos = 0x0
	// Bit mask of PERI_IN_SEL field.
	DMA_IN_PERI_SEL_CH_PERI_IN_SEL_Msk = 0x3f

	// OUT_CONF1_CH0: Configure 1 register of Tx channel 0
	// Position of OUT_CHECK_OWNER field.
	DMA_OUT_CONF1_CH_OUT_CHECK_OWNER_Pos = 0xc
	// Bit mask of OUT_CHECK_OWNER field.
	DMA_OUT_CONF1_CH_OUT_CHECK_OWNER_Msk = 0x1000
	// Bit OUT_CHECK_OWNER.
	DMA_OUT_CONF1_CH_OUT_CHECK_OWNER = 0x1000

	// OUTFIFO_STATUS_CH0: Transmit FIFO status of Tx channel 0
	// Position of OUTFIFO_FULL field.
	DMA_OUTFIFO_STATUS_CH_OUTFIFO_FULL_Pos = 0x0
	// Bit mask of OUTFIFO_FULL field.
	DMA_OUTFIFO_STATUS_CH_OUTFIFO_FULL_Msk = 0x1
	// Bit OUTFIFO_FULL.
	DMA_OUTFIFO_STATUS_CH_OUTFIFO_FULL = 0x1
	// Position of OUTFIFO_EMPTY field.
	DMA_OUTFIFO_STATUS_CH_OUTFIFO_EMPTY_Pos = 0x1
	// Bit mask of OUTFIFO_EMPTY field.
	DMA_OUTFIFO_STATUS_CH_OUTFIFO_EMPTY_Msk = 0x2
	// Bit OUTFIFO_EMPTY.
	DMA_OUTFIFO_STATUS_CH_OUTFIFO_EMPTY = 0x2
	// Position of OUTFIFO_CNT field.
	DMA_OUTFIFO_STATUS_CH_OUTFIFO_CNT_Pos = 0x2
	// Bit mask of OUTFIFO_CNT field.
	DMA_OUTFIFO_STATUS_CH_OUTFIFO_CNT_Msk = 0xfc
	// Position of OUT_REMAIN_UNDER_1B field.
	DMA_OUTFIFO_STATUS_CH_OUT_REMAIN_UNDER_1B_Pos = 0x17
	// Bit mask of OUT_REMAIN_UNDER_1B field.
	DMA_OUTFIFO_STATUS_CH_OUT_REMAIN_UNDER_1B_Msk = 0x800000
	// Bit OUT_REMAIN_UNDER_1B.
	DMA_OUTFIFO_STATUS_CH_OUT_REMAIN_UNDER_1B = 0x800000
	// Position of OUT_REMAIN_UNDER_2B field.
	DMA_OUTFIFO_STATUS_CH_OUT_REMAIN_UNDER_2B_Pos = 0x18
	// Bit mask of OUT_REMAIN_UNDER_2B field.
	DMA_OUTFIFO_STATUS_CH_OUT_REMAIN_UNDER_2B_Msk = 0x1000000
	// Bit OUT_REMAIN_UNDER_2B.
	DMA_OUTFIFO_STATUS_CH_OUT_REMAIN_UNDER_2B = 0x1000000
	// Position of OUT_REMAIN_UNDER_3B field.
	DMA_OUTFIFO_STATUS_CH_OUT_REMAIN_UNDER_3B_Pos = 0x19
	// Bit mask of OUT_REMAIN_UNDER_3B field.
	DMA_OUTFIFO_STATUS_CH_OUT_REMAIN_UNDER_3B_Msk = 0x2000000
	// Bit OUT_REMAIN_UNDER_3B.
	DMA_OUTFIFO_STATUS_CH_OUT_REMAIN_UNDER_3B = 0x2000000
	// Position of OUT_REMAIN_UNDER_4B field.
	DMA_OUTFIFO_STATUS_CH_OUT_REMAIN_UNDER_4B_Pos = 0x1a
	// Bit mask of OUT_REMAIN_UNDER_4B field.
	DMA_OUTFIFO_STATUS_CH_OUT_REMAIN_UNDER_4B_Msk = 0x4000000
	// Bit OUT_REMAIN_UNDER_4B.
	DMA_OUTFIFO_STATUS_CH_OUT_REMAIN_UNDER_4B = 0x4000000

	// OUT_PUSH_CH0: Push control register of Rx channel 0
	// Position of OUTFIFO_WDATA field.
	DMA_OUT_PUSH_CH_OUTFIFO_WDATA_Pos = 0x0
	// Bit mask of OUTFIFO_WDATA field.
	DMA_OUT_PUSH_CH_OUTFIFO_WDATA_Msk = 0x1ff
	// Position of OUTFIFO_PUSH field.
	DMA_OUT_PUSH_CH_OUTFIFO_PUSH_Pos = 0x9
	// Bit mask of OUTFIFO_PUSH field.
	DMA_OUT_PUSH_CH_OUTFIFO_PUSH_Msk = 0x200
	// Bit OUTFIFO_PUSH.
	DMA_OUT_PUSH_CH_OUTFIFO_PUSH = 0x200

	// OUT_LINK_CH0: Link descriptor configure and control register of Tx channel 0
	// Position of OUTLINK_ADDR field.
	DMA_OUT_LINK_CH_OUTLINK_ADDR_Pos = 0x0
	// Bit mask of OUTLINK_ADDR field.
	DMA_OUT_LINK_CH_OUTLINK_ADDR_Msk = 0xfffff
	// Position of OUTLINK_STOP field.
	DMA_OUT_LINK_CH_OUTLINK_STOP_Pos = 0x14
	// Bit mask of OUTLINK_STOP field.
	DMA_OUT_LINK_CH_OUTLINK_STOP_Msk = 0x100000
	// Bit OUTLINK_STOP.
	DMA_OUT_LINK_CH_OUTLINK_STOP = 0x100000
	// Position of OUTLINK_START field.
	DMA_OUT_LINK_CH_OUTLINK_START_Pos = 0x15
	// Bit mask of OUTLINK_START field.
	DMA_OUT_LINK_CH_OUTLINK_START_Msk = 0x200000
	// Bit OUTLINK_START.
	DMA_OUT_LINK_CH_OUTLINK_START = 0x200000
	// Position of OUTLINK_RESTART field.
	DMA_OUT_LINK_CH_OUTLINK_RESTART_Pos = 0x16
	// Bit mask of OUTLINK_RESTART field.
	DMA_OUT_LINK_CH_OUTLINK_RESTART_Msk = 0x400000
	// Bit OUTLINK_RESTART.
	DMA_OUT_LINK_CH_OUTLINK_RESTART = 0x400000
	// Position of OUTLINK_PARK field.
	DMA_OUT_LINK_CH_OUTLINK_PARK_Pos = 0x17
	// Bit mask of OUTLINK_PARK field.
	DMA_OUT_LINK_CH_OUTLINK_PARK_Msk = 0x800000
	// Bit OUTLINK_PARK.
	DMA_OUT_LINK_CH_OUTLINK_PARK = 0x800000

	// OUT_STATE_CH0: Transmit status of Tx channel 0
	// Position of OUTLINK_DSCR_ADDR field.
	DMA_OUT_STATE_CH_OUTLINK_DSCR_ADDR_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_ADDR field.
	DMA_OUT_STATE_CH_OUTLINK_DSCR_ADDR_Msk = 0x3ffff
	// Position of OUT_DSCR_STATE field.
	DMA_OUT_STATE_CH_OUT_DSCR_STATE_Pos = 0x12
	// Bit mask of OUT_DSCR_STATE field.
	DMA_OUT_STATE_CH_OUT_DSCR_STATE_Msk = 0xc0000
	// Position of OUT_STATE field.
	DMA_OUT_STATE_CH_OUT_STATE_Pos = 0x14
	// Bit mask of OUT_STATE field.
	DMA_OUT_STATE_CH_OUT_STATE_Msk = 0x700000

	// OUT_EOF_DES_ADDR_CH0: Outlink descriptor address when EOF occurs of Tx channel 0
	// Position of OUT_EOF_DES_ADDR field.
	DMA_OUT_EOF_DES_ADDR_CH_OUT_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of OUT_EOF_DES_ADDR field.
	DMA_OUT_EOF_DES_ADDR_CH_OUT_EOF_DES_ADDR_Msk = 0xffffffff

	// OUT_EOF_BFR_DES_ADDR_CH0: The last outlink descriptor address when EOF occurs of Tx channel 0
	// Position of OUT_EOF_BFR_DES_ADDR field.
	DMA_OUT_EOF_BFR_DES_ADDR_CH_OUT_EOF_BFR_DES_ADDR_Pos = 0x0
	// Bit mask of OUT_EOF_BFR_DES_ADDR field.
	DMA_OUT_EOF_BFR_DES_ADDR_CH_OUT_EOF_BFR_DES_ADDR_Msk = 0xffffffff

	// OUT_DSCR_CH0: Current inlink descriptor address of Tx channel 0
	// Position of OUTLINK_DSCR field.
	DMA_OUT_DSCR_CH_OUTLINK_DSCR_Pos = 0x0
	// Bit mask of OUTLINK_DSCR field.
	DMA_OUT_DSCR_CH_OUTLINK_DSCR_Msk = 0xffffffff

	// OUT_DSCR_BF0_CH0: The last inlink descriptor address of Tx channel 0
	// Position of OUTLINK_DSCR_BF0 field.
	DMA_OUT_DSCR_BF0_CH_OUTLINK_DSCR_BF0_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_BF0 field.
	DMA_OUT_DSCR_BF0_CH_OUTLINK_DSCR_BF0_Msk = 0xffffffff

	// OUT_DSCR_BF1_CH0: The second-to-last inlink descriptor address of Tx channel 0
	// Position of OUTLINK_DSCR_BF1 field.
	DMA_OUT_DSCR_BF1_CH_OUTLINK_DSCR_BF1_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_BF1 field.
	DMA_OUT_DSCR_BF1_CH_OUTLINK_DSCR_BF1_Msk = 0xffffffff

	// OUT_PRI_CH0: Priority register of Tx channel 0.
	// Position of TX_PRI field.
	DMA_OUT_PRI_CH_TX_PRI_Pos = 0x0
	// Bit mask of TX_PRI field.
	DMA_OUT_PRI_CH_TX_PRI_Msk = 0xf

	// OUT_PERI_SEL_CH0: Peripheral selection of Tx channel 0
	// Position of PERI_OUT_SEL field.
	DMA_OUT_PERI_SEL_CH_PERI_OUT_SEL_Pos = 0x0
	// Bit mask of PERI_OUT_SEL field.
	DMA_OUT_PERI_SEL_CH_PERI_OUT_SEL_Msk = 0x3f

	// OUT_CONF0_CH0: Configure 0 register of Tx channel 1
	// Position of OUT_RST field.
	DMA_OUT_CONF0_CH_OUT_RST_Pos = 0x0
	// Bit mask of OUT_RST field.
	DMA_OUT_CONF0_CH_OUT_RST_Msk = 0x1
	// Bit OUT_RST.
	DMA_OUT_CONF0_CH_OUT_RST = 0x1
	// Position of OUT_LOOP_TEST field.
	DMA_OUT_CONF0_CH_OUT_LOOP_TEST_Pos = 0x1
	// Bit mask of OUT_LOOP_TEST field.
	DMA_OUT_CONF0_CH_OUT_LOOP_TEST_Msk = 0x2
	// Bit OUT_LOOP_TEST.
	DMA_OUT_CONF0_CH_OUT_LOOP_TEST = 0x2
	// Position of OUT_AUTO_WRBACK field.
	DMA_OUT_CONF0_CH_OUT_AUTO_WRBACK_Pos = 0x2
	// Bit mask of OUT_AUTO_WRBACK field.
	DMA_OUT_CONF0_CH_OUT_AUTO_WRBACK_Msk = 0x4
	// Bit OUT_AUTO_WRBACK.
	DMA_OUT_CONF0_CH_OUT_AUTO_WRBACK = 0x4
	// Position of OUT_EOF_MODE field.
	DMA_OUT_CONF0_CH_OUT_EOF_MODE_Pos = 0x3
	// Bit mask of OUT_EOF_MODE field.
	DMA_OUT_CONF0_CH_OUT_EOF_MODE_Msk = 0x8
	// Bit OUT_EOF_MODE.
	DMA_OUT_CONF0_CH_OUT_EOF_MODE = 0x8
	// Position of OUTDSCR_BURST_EN field.
	DMA_OUT_CONF0_CH_OUTDSCR_BURST_EN_Pos = 0x4
	// Bit mask of OUTDSCR_BURST_EN field.
	DMA_OUT_CONF0_CH_OUTDSCR_BURST_EN_Msk = 0x10
	// Bit OUTDSCR_BURST_EN.
	DMA_OUT_CONF0_CH_OUTDSCR_BURST_EN = 0x10
	// Position of OUT_DATA_BURST_EN field.
	DMA_OUT_CONF0_CH_OUT_DATA_BURST_EN_Pos = 0x5
	// Bit mask of OUT_DATA_BURST_EN field.
	DMA_OUT_CONF0_CH_OUT_DATA_BURST_EN_Msk = 0x20
	// Bit OUT_DATA_BURST_EN.
	DMA_OUT_CONF0_CH_OUT_DATA_BURST_EN = 0x20
	// Position of OUT_ETM_EN field.
	DMA_OUT_CONF0_CH_OUT_ETM_EN_Pos = 0x6
	// Bit mask of OUT_ETM_EN field.
	DMA_OUT_CONF0_CH_OUT_ETM_EN_Msk = 0x40
	// Bit OUT_ETM_EN.
	DMA_OUT_CONF0_CH_OUT_ETM_EN = 0x40
)

// Constants for DS: Digital Signature
const (
	// SET_START: DS start control register
	// Position of SET_START field.
	DS_SET_START_SET_START_Pos = 0x0
	// Bit mask of SET_START field.
	DS_SET_START_SET_START_Msk = 0x1
	// Bit SET_START.
	DS_SET_START_SET_START = 0x1

	// SET_CONTINUE: DS continue control register
	// Position of SET_CONTINUE field.
	DS_SET_CONTINUE_SET_CONTINUE_Pos = 0x0
	// Bit mask of SET_CONTINUE field.
	DS_SET_CONTINUE_SET_CONTINUE_Msk = 0x1
	// Bit SET_CONTINUE.
	DS_SET_CONTINUE_SET_CONTINUE = 0x1

	// SET_FINISH: DS finish control register
	// Position of SET_FINISH field.
	DS_SET_FINISH_SET_FINISH_Pos = 0x0
	// Bit mask of SET_FINISH field.
	DS_SET_FINISH_SET_FINISH_Msk = 0x1
	// Bit SET_FINISH.
	DS_SET_FINISH_SET_FINISH = 0x1

	// QUERY_BUSY: DS query busy register
	// Position of QUERY_BUSY field.
	DS_QUERY_BUSY_QUERY_BUSY_Pos = 0x0
	// Bit mask of QUERY_BUSY field.
	DS_QUERY_BUSY_QUERY_BUSY_Msk = 0x1
	// Bit QUERY_BUSY.
	DS_QUERY_BUSY_QUERY_BUSY = 0x1

	// QUERY_KEY_WRONG: DS query key-wrong counter register
	// Position of QUERY_KEY_WRONG field.
	DS_QUERY_KEY_WRONG_QUERY_KEY_WRONG_Pos = 0x0
	// Bit mask of QUERY_KEY_WRONG field.
	DS_QUERY_KEY_WRONG_QUERY_KEY_WRONG_Msk = 0xf

	// QUERY_CHECK: DS query check result register
	// Position of MD_ERROR field.
	DS_QUERY_CHECK_MD_ERROR_Pos = 0x0
	// Bit mask of MD_ERROR field.
	DS_QUERY_CHECK_MD_ERROR_Msk = 0x1
	// Bit MD_ERROR.
	DS_QUERY_CHECK_MD_ERROR = 0x1
	// Position of PADDING_BAD field.
	DS_QUERY_CHECK_PADDING_BAD_Pos = 0x1
	// Bit mask of PADDING_BAD field.
	DS_QUERY_CHECK_PADDING_BAD_Msk = 0x2
	// Bit PADDING_BAD.
	DS_QUERY_CHECK_PADDING_BAD = 0x2

	// DATE: DS version control register
	// Position of DATE field.
	DS_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	DS_DATE_DATE_Msk = 0x3fffffff
)

// Constants for ECC: ECC (ECC Hardware Accelerator)
const (
	// MULT_INT_RAW: ECC interrupt raw register, valid in level.
	// Position of CALC_DONE_INT_RAW field.
	ECC_MULT_INT_RAW_CALC_DONE_INT_RAW_Pos = 0x0
	// Bit mask of CALC_DONE_INT_RAW field.
	ECC_MULT_INT_RAW_CALC_DONE_INT_RAW_Msk = 0x1
	// Bit CALC_DONE_INT_RAW.
	ECC_MULT_INT_RAW_CALC_DONE_INT_RAW = 0x1

	// MULT_INT_ST: ECC interrupt status register.
	// Position of CALC_DONE_INT_ST field.
	ECC_MULT_INT_ST_CALC_DONE_INT_ST_Pos = 0x0
	// Bit mask of CALC_DONE_INT_ST field.
	ECC_MULT_INT_ST_CALC_DONE_INT_ST_Msk = 0x1
	// Bit CALC_DONE_INT_ST.
	ECC_MULT_INT_ST_CALC_DONE_INT_ST = 0x1

	// MULT_INT_ENA: ECC interrupt enable register.
	// Position of CALC_DONE_INT_ENA field.
	ECC_MULT_INT_ENA_CALC_DONE_INT_ENA_Pos = 0x0
	// Bit mask of CALC_DONE_INT_ENA field.
	ECC_MULT_INT_ENA_CALC_DONE_INT_ENA_Msk = 0x1
	// Bit CALC_DONE_INT_ENA.
	ECC_MULT_INT_ENA_CALC_DONE_INT_ENA = 0x1

	// MULT_INT_CLR: ECC interrupt clear register.
	// Position of CALC_DONE_INT_CLR field.
	ECC_MULT_INT_CLR_CALC_DONE_INT_CLR_Pos = 0x0
	// Bit mask of CALC_DONE_INT_CLR field.
	ECC_MULT_INT_CLR_CALC_DONE_INT_CLR_Msk = 0x1
	// Bit CALC_DONE_INT_CLR.
	ECC_MULT_INT_CLR_CALC_DONE_INT_CLR = 0x1

	// MULT_CONF: ECC configure register
	// Position of START field.
	ECC_MULT_CONF_START_Pos = 0x0
	// Bit mask of START field.
	ECC_MULT_CONF_START_Msk = 0x1
	// Bit START.
	ECC_MULT_CONF_START = 0x1
	// Position of RESET field.
	ECC_MULT_CONF_RESET_Pos = 0x1
	// Bit mask of RESET field.
	ECC_MULT_CONF_RESET_Msk = 0x2
	// Bit RESET.
	ECC_MULT_CONF_RESET = 0x2
	// Position of KEY_LENGTH field.
	ECC_MULT_CONF_KEY_LENGTH_Pos = 0x2
	// Bit mask of KEY_LENGTH field.
	ECC_MULT_CONF_KEY_LENGTH_Msk = 0x4
	// Bit KEY_LENGTH.
	ECC_MULT_CONF_KEY_LENGTH = 0x4
	// Position of MOD_BASE field.
	ECC_MULT_CONF_MOD_BASE_Pos = 0x3
	// Bit mask of MOD_BASE field.
	ECC_MULT_CONF_MOD_BASE_Msk = 0x8
	// Bit MOD_BASE.
	ECC_MULT_CONF_MOD_BASE = 0x8
	// Position of WORK_MODE field.
	ECC_MULT_CONF_WORK_MODE_Pos = 0x4
	// Bit mask of WORK_MODE field.
	ECC_MULT_CONF_WORK_MODE_Msk = 0xf0
	// Position of SECURITY_MODE field.
	ECC_MULT_CONF_SECURITY_MODE_Pos = 0x8
	// Bit mask of SECURITY_MODE field.
	ECC_MULT_CONF_SECURITY_MODE_Msk = 0x100
	// Bit SECURITY_MODE.
	ECC_MULT_CONF_SECURITY_MODE = 0x100
	// Position of VERIFICATION_RESULT field.
	ECC_MULT_CONF_VERIFICATION_RESULT_Pos = 0x1d
	// Bit mask of VERIFICATION_RESULT field.
	ECC_MULT_CONF_VERIFICATION_RESULT_Msk = 0x20000000
	// Bit VERIFICATION_RESULT.
	ECC_MULT_CONF_VERIFICATION_RESULT = 0x20000000
	// Position of CLK_EN field.
	ECC_MULT_CONF_CLK_EN_Pos = 0x1e
	// Bit mask of CLK_EN field.
	ECC_MULT_CONF_CLK_EN_Msk = 0x40000000
	// Bit CLK_EN.
	ECC_MULT_CONF_CLK_EN = 0x40000000
	// Position of MEM_CLOCK_GATE_FORCE_ON field.
	ECC_MULT_CONF_MEM_CLOCK_GATE_FORCE_ON_Pos = 0x1f
	// Bit mask of MEM_CLOCK_GATE_FORCE_ON field.
	ECC_MULT_CONF_MEM_CLOCK_GATE_FORCE_ON_Msk = 0x80000000
	// Bit MEM_CLOCK_GATE_FORCE_ON.
	ECC_MULT_CONF_MEM_CLOCK_GATE_FORCE_ON = 0x80000000

	// MULT_DATE: Version control register
	// Position of DATE field.
	ECC_MULT_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	ECC_MULT_DATE_DATE_Msk = 0xfffffff
)

// Constants for EFUSE: eFuse Controller
const (
	// PGM_DATA0: Register 0 that stores data to be programmed.
	// Position of PGM_DATA_0 field.
	EFUSE_PGM_DATA0_PGM_DATA_0_Pos = 0x0
	// Bit mask of PGM_DATA_0 field.
	EFUSE_PGM_DATA0_PGM_DATA_0_Msk = 0xffffffff

	// PGM_DATA1: Register 1 that stores data to be programmed.
	// Position of PGM_DATA_1 field.
	EFUSE_PGM_DATA1_PGM_DATA_1_Pos = 0x0
	// Bit mask of PGM_DATA_1 field.
	EFUSE_PGM_DATA1_PGM_DATA_1_Msk = 0xffffffff

	// PGM_DATA2: Register 2 that stores data to be programmed.
	// Position of PGM_DATA_2 field.
	EFUSE_PGM_DATA2_PGM_DATA_2_Pos = 0x0
	// Bit mask of PGM_DATA_2 field.
	EFUSE_PGM_DATA2_PGM_DATA_2_Msk = 0xffffffff

	// PGM_DATA3: Register 3 that stores data to be programmed.
	// Position of PGM_DATA_3 field.
	EFUSE_PGM_DATA3_PGM_DATA_3_Pos = 0x0
	// Bit mask of PGM_DATA_3 field.
	EFUSE_PGM_DATA3_PGM_DATA_3_Msk = 0xffffffff

	// PGM_DATA4: Register 4 that stores data to be programmed.
	// Position of PGM_DATA_4 field.
	EFUSE_PGM_DATA4_PGM_DATA_4_Pos = 0x0
	// Bit mask of PGM_DATA_4 field.
	EFUSE_PGM_DATA4_PGM_DATA_4_Msk = 0xffffffff

	// PGM_DATA5: Register 5 that stores data to be programmed.
	// Position of PGM_DATA_5 field.
	EFUSE_PGM_DATA5_PGM_DATA_5_Pos = 0x0
	// Bit mask of PGM_DATA_5 field.
	EFUSE_PGM_DATA5_PGM_DATA_5_Msk = 0xffffffff

	// PGM_DATA6: Register 6 that stores data to be programmed.
	// Position of PGM_DATA_6 field.
	EFUSE_PGM_DATA6_PGM_DATA_6_Pos = 0x0
	// Bit mask of PGM_DATA_6 field.
	EFUSE_PGM_DATA6_PGM_DATA_6_Msk = 0xffffffff

	// PGM_DATA7: Register 7 that stores data to be programmed.
	// Position of PGM_DATA_7 field.
	EFUSE_PGM_DATA7_PGM_DATA_7_Pos = 0x0
	// Bit mask of PGM_DATA_7 field.
	EFUSE_PGM_DATA7_PGM_DATA_7_Msk = 0xffffffff

	// PGM_CHECK_VALUE0: Register 0 that stores the RS code to be programmed.
	// Position of PGM_RS_DATA_0 field.
	EFUSE_PGM_CHECK_VALUE0_PGM_RS_DATA_0_Pos = 0x0
	// Bit mask of PGM_RS_DATA_0 field.
	EFUSE_PGM_CHECK_VALUE0_PGM_RS_DATA_0_Msk = 0xffffffff

	// PGM_CHECK_VALUE1: Register 1 that stores the RS code to be programmed.
	// Position of PGM_RS_DATA_1 field.
	EFUSE_PGM_CHECK_VALUE1_PGM_RS_DATA_1_Pos = 0x0
	// Bit mask of PGM_RS_DATA_1 field.
	EFUSE_PGM_CHECK_VALUE1_PGM_RS_DATA_1_Msk = 0xffffffff

	// PGM_CHECK_VALUE2: Register 2 that stores the RS code to be programmed.
	// Position of PGM_RS_DATA_2 field.
	EFUSE_PGM_CHECK_VALUE2_PGM_RS_DATA_2_Pos = 0x0
	// Bit mask of PGM_RS_DATA_2 field.
	EFUSE_PGM_CHECK_VALUE2_PGM_RS_DATA_2_Msk = 0xffffffff

	// RD_WR_DIS: BLOCK0 data register 0.
	// Position of WR_DIS field.
	EFUSE_RD_WR_DIS_WR_DIS_Pos = 0x0
	// Bit mask of WR_DIS field.
	EFUSE_RD_WR_DIS_WR_DIS_Msk = 0xffffffff

	// RD_REPEAT_DATA0: BLOCK0 data register 1.
	// Position of RD_DIS field.
	EFUSE_RD_REPEAT_DATA0_RD_DIS_Pos = 0x0
	// Bit mask of RD_DIS field.
	EFUSE_RD_REPEAT_DATA0_RD_DIS_Msk = 0x7f
	// Position of RPT4_RESERVED0_4 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_4_Pos = 0x7
	// Bit mask of RPT4_RESERVED0_4 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_4_Msk = 0x80
	// Bit RPT4_RESERVED0_4.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_4 = 0x80
	// Position of DIS_ICACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_ICACHE_Pos = 0x8
	// Bit mask of DIS_ICACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_ICACHE_Msk = 0x100
	// Bit DIS_ICACHE.
	EFUSE_RD_REPEAT_DATA0_DIS_ICACHE = 0x100
	// Position of DIS_USB_JTAG field.
	EFUSE_RD_REPEAT_DATA0_DIS_USB_JTAG_Pos = 0x9
	// Bit mask of DIS_USB_JTAG field.
	EFUSE_RD_REPEAT_DATA0_DIS_USB_JTAG_Msk = 0x200
	// Bit DIS_USB_JTAG.
	EFUSE_RD_REPEAT_DATA0_DIS_USB_JTAG = 0x200
	// Position of POWERGLITCH_EN field.
	EFUSE_RD_REPEAT_DATA0_POWERGLITCH_EN_Pos = 0xa
	// Bit mask of POWERGLITCH_EN field.
	EFUSE_RD_REPEAT_DATA0_POWERGLITCH_EN_Msk = 0x400
	// Bit POWERGLITCH_EN.
	EFUSE_RD_REPEAT_DATA0_POWERGLITCH_EN = 0x400
	// Position of DIS_USB_SERIAL_JTAG field.
	EFUSE_RD_REPEAT_DATA0_DIS_USB_SERIAL_JTAG_Pos = 0xb
	// Bit mask of DIS_USB_SERIAL_JTAG field.
	EFUSE_RD_REPEAT_DATA0_DIS_USB_SERIAL_JTAG_Msk = 0x800
	// Bit DIS_USB_SERIAL_JTAG.
	EFUSE_RD_REPEAT_DATA0_DIS_USB_SERIAL_JTAG = 0x800
	// Position of DIS_FORCE_DOWNLOAD field.
	EFUSE_RD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD_Pos = 0xc
	// Bit mask of DIS_FORCE_DOWNLOAD field.
	EFUSE_RD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD_Msk = 0x1000
	// Bit DIS_FORCE_DOWNLOAD.
	EFUSE_RD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD = 0x1000
	// Position of SPI_DOWNLOAD_MSPI_DIS field.
	EFUSE_RD_REPEAT_DATA0_SPI_DOWNLOAD_MSPI_DIS_Pos = 0xd
	// Bit mask of SPI_DOWNLOAD_MSPI_DIS field.
	EFUSE_RD_REPEAT_DATA0_SPI_DOWNLOAD_MSPI_DIS_Msk = 0x2000
	// Bit SPI_DOWNLOAD_MSPI_DIS.
	EFUSE_RD_REPEAT_DATA0_SPI_DOWNLOAD_MSPI_DIS = 0x2000
	// Position of DIS_CAN field.
	EFUSE_RD_REPEAT_DATA0_DIS_CAN_Pos = 0xe
	// Bit mask of DIS_CAN field.
	EFUSE_RD_REPEAT_DATA0_DIS_CAN_Msk = 0x4000
	// Bit DIS_CAN.
	EFUSE_RD_REPEAT_DATA0_DIS_CAN = 0x4000
	// Position of JTAG_SEL_ENABLE field.
	EFUSE_RD_REPEAT_DATA0_JTAG_SEL_ENABLE_Pos = 0xf
	// Bit mask of JTAG_SEL_ENABLE field.
	EFUSE_RD_REPEAT_DATA0_JTAG_SEL_ENABLE_Msk = 0x8000
	// Bit JTAG_SEL_ENABLE.
	EFUSE_RD_REPEAT_DATA0_JTAG_SEL_ENABLE = 0x8000
	// Position of SOFT_DIS_JTAG field.
	EFUSE_RD_REPEAT_DATA0_SOFT_DIS_JTAG_Pos = 0x10
	// Bit mask of SOFT_DIS_JTAG field.
	EFUSE_RD_REPEAT_DATA0_SOFT_DIS_JTAG_Msk = 0x70000
	// Position of DIS_PAD_JTAG field.
	EFUSE_RD_REPEAT_DATA0_DIS_PAD_JTAG_Pos = 0x13
	// Bit mask of DIS_PAD_JTAG field.
	EFUSE_RD_REPEAT_DATA0_DIS_PAD_JTAG_Msk = 0x80000
	// Bit DIS_PAD_JTAG.
	EFUSE_RD_REPEAT_DATA0_DIS_PAD_JTAG = 0x80000
	// Position of DIS_DOWNLOAD_MANUAL_ENCRYPT field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT_Pos = 0x14
	// Bit mask of DIS_DOWNLOAD_MANUAL_ENCRYPT field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT_Msk = 0x100000
	// Bit DIS_DOWNLOAD_MANUAL_ENCRYPT.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT = 0x100000
	// Position of USB_DREFH field.
	EFUSE_RD_REPEAT_DATA0_USB_DREFH_Pos = 0x15
	// Bit mask of USB_DREFH field.
	EFUSE_RD_REPEAT_DATA0_USB_DREFH_Msk = 0x600000
	// Position of USB_DREFL field.
	EFUSE_RD_REPEAT_DATA0_USB_DREFL_Pos = 0x17
	// Bit mask of USB_DREFL field.
	EFUSE_RD_REPEAT_DATA0_USB_DREFL_Msk = 0x1800000
	// Position of USB_EXCHG_PINS field.
	EFUSE_RD_REPEAT_DATA0_USB_EXCHG_PINS_Pos = 0x19
	// Bit mask of USB_EXCHG_PINS field.
	EFUSE_RD_REPEAT_DATA0_USB_EXCHG_PINS_Msk = 0x2000000
	// Bit USB_EXCHG_PINS.
	EFUSE_RD_REPEAT_DATA0_USB_EXCHG_PINS = 0x2000000
	// Position of VDD_SPI_AS_GPIO field.
	EFUSE_RD_REPEAT_DATA0_VDD_SPI_AS_GPIO_Pos = 0x1a
	// Bit mask of VDD_SPI_AS_GPIO field.
	EFUSE_RD_REPEAT_DATA0_VDD_SPI_AS_GPIO_Msk = 0x4000000
	// Bit VDD_SPI_AS_GPIO.
	EFUSE_RD_REPEAT_DATA0_VDD_SPI_AS_GPIO = 0x4000000
	// Position of RPT4_RESERVED0_2 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_2_Pos = 0x1b
	// Bit mask of RPT4_RESERVED0_2 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_2_Msk = 0x18000000
	// Position of RPT4_RESERVED0_1 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_1_Pos = 0x1d
	// Bit mask of RPT4_RESERVED0_1 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_1_Msk = 0x20000000
	// Bit RPT4_RESERVED0_1.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_1 = 0x20000000
	// Position of RPT4_RESERVED0_0 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_0_Pos = 0x1e
	// Bit mask of RPT4_RESERVED0_0 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_0_Msk = 0xc0000000

	// RD_REPEAT_DATA1: BLOCK0 data register 2.
	// Position of RPT4_RESERVED1_1 field.
	EFUSE_RD_REPEAT_DATA1_RPT4_RESERVED1_1_Pos = 0x0
	// Bit mask of RPT4_RESERVED1_1 field.
	EFUSE_RD_REPEAT_DATA1_RPT4_RESERVED1_1_Msk = 0xffff
	// Position of WDT_DELAY_SEL field.
	EFUSE_RD_REPEAT_DATA1_WDT_DELAY_SEL_Pos = 0x10
	// Bit mask of WDT_DELAY_SEL field.
	EFUSE_RD_REPEAT_DATA1_WDT_DELAY_SEL_Msk = 0x30000
	// Position of SPI_BOOT_CRYPT_CNT field.
	EFUSE_RD_REPEAT_DATA1_SPI_BOOT_CRYPT_CNT_Pos = 0x12
	// Bit mask of SPI_BOOT_CRYPT_CNT field.
	EFUSE_RD_REPEAT_DATA1_SPI_BOOT_CRYPT_CNT_Msk = 0x1c0000
	// Position of SECURE_BOOT_KEY_REVOKE0 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0_Pos = 0x15
	// Bit mask of SECURE_BOOT_KEY_REVOKE0 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0_Msk = 0x200000
	// Bit SECURE_BOOT_KEY_REVOKE0.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0 = 0x200000
	// Position of SECURE_BOOT_KEY_REVOKE1 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1_Pos = 0x16
	// Bit mask of SECURE_BOOT_KEY_REVOKE1 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1_Msk = 0x400000
	// Bit SECURE_BOOT_KEY_REVOKE1.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1 = 0x400000
	// Position of SECURE_BOOT_KEY_REVOKE2 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2_Pos = 0x17
	// Bit mask of SECURE_BOOT_KEY_REVOKE2 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2_Msk = 0x800000
	// Bit SECURE_BOOT_KEY_REVOKE2.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2 = 0x800000
	// Position of KEY_PURPOSE_0 field.
	EFUSE_RD_REPEAT_DATA1_KEY_PURPOSE_0_Pos = 0x18
	// Bit mask of KEY_PURPOSE_0 field.
	EFUSE_RD_REPEAT_DATA1_KEY_PURPOSE_0_Msk = 0xf000000
	// Position of KEY_PURPOSE_1 field.
	EFUSE_RD_REPEAT_DATA1_KEY_PURPOSE_1_Pos = 0x1c
	// Bit mask of KEY_PURPOSE_1 field.
	EFUSE_RD_REPEAT_DATA1_KEY_PURPOSE_1_Msk = 0xf0000000

	// RD_REPEAT_DATA2: BLOCK0 data register 3.
	// Position of KEY_PURPOSE_2 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_2_Pos = 0x0
	// Bit mask of KEY_PURPOSE_2 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_2_Msk = 0xf
	// Position of KEY_PURPOSE_3 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_3_Pos = 0x4
	// Bit mask of KEY_PURPOSE_3 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_3_Msk = 0xf0
	// Position of KEY_PURPOSE_4 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_4_Pos = 0x8
	// Bit mask of KEY_PURPOSE_4 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_4_Msk = 0xf00
	// Position of KEY_PURPOSE_5 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_5_Pos = 0xc
	// Bit mask of KEY_PURPOSE_5 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_5_Msk = 0xf000
	// Position of SEC_DPA_LEVEL field.
	EFUSE_RD_REPEAT_DATA2_SEC_DPA_LEVEL_Pos = 0x10
	// Bit mask of SEC_DPA_LEVEL field.
	EFUSE_RD_REPEAT_DATA2_SEC_DPA_LEVEL_Msk = 0x30000
	// Position of ECDSA_FORCE_USE_HARDWARE_K field.
	EFUSE_RD_REPEAT_DATA2_ECDSA_FORCE_USE_HARDWARE_K_Pos = 0x12
	// Bit mask of ECDSA_FORCE_USE_HARDWARE_K field.
	EFUSE_RD_REPEAT_DATA2_ECDSA_FORCE_USE_HARDWARE_K_Msk = 0x40000
	// Bit ECDSA_FORCE_USE_HARDWARE_K.
	EFUSE_RD_REPEAT_DATA2_ECDSA_FORCE_USE_HARDWARE_K = 0x40000
	// Position of CRYPT_DPA_ENABLE field.
	EFUSE_RD_REPEAT_DATA2_CRYPT_DPA_ENABLE_Pos = 0x13
	// Bit mask of CRYPT_DPA_ENABLE field.
	EFUSE_RD_REPEAT_DATA2_CRYPT_DPA_ENABLE_Msk = 0x80000
	// Bit CRYPT_DPA_ENABLE.
	EFUSE_RD_REPEAT_DATA2_CRYPT_DPA_ENABLE = 0x80000
	// Position of SECURE_BOOT_EN field.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_EN_Pos = 0x14
	// Bit mask of SECURE_BOOT_EN field.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_EN_Msk = 0x100000
	// Bit SECURE_BOOT_EN.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_EN = 0x100000
	// Position of SECURE_BOOT_AGGRESSIVE_REVOKE field.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE_Pos = 0x15
	// Bit mask of SECURE_BOOT_AGGRESSIVE_REVOKE field.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE_Msk = 0x200000
	// Bit SECURE_BOOT_AGGRESSIVE_REVOKE.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE = 0x200000
	// Position of RPT4_RESERVED2_0 field.
	EFUSE_RD_REPEAT_DATA2_RPT4_RESERVED2_0_Pos = 0x16
	// Bit mask of RPT4_RESERVED2_0 field.
	EFUSE_RD_REPEAT_DATA2_RPT4_RESERVED2_0_Msk = 0xfc00000
	// Position of FLASH_TPUW field.
	EFUSE_RD_REPEAT_DATA2_FLASH_TPUW_Pos = 0x1c
	// Bit mask of FLASH_TPUW field.
	EFUSE_RD_REPEAT_DATA2_FLASH_TPUW_Msk = 0xf0000000

	// RD_REPEAT_DATA3: BLOCK0 data register 4.
	// Position of DIS_DOWNLOAD_MODE field.
	EFUSE_RD_REPEAT_DATA3_DIS_DOWNLOAD_MODE_Pos = 0x0
	// Bit mask of DIS_DOWNLOAD_MODE field.
	EFUSE_RD_REPEAT_DATA3_DIS_DOWNLOAD_MODE_Msk = 0x1
	// Bit DIS_DOWNLOAD_MODE.
	EFUSE_RD_REPEAT_DATA3_DIS_DOWNLOAD_MODE = 0x1
	// Position of DIS_DIRECT_BOOT field.
	EFUSE_RD_REPEAT_DATA3_DIS_DIRECT_BOOT_Pos = 0x1
	// Bit mask of DIS_DIRECT_BOOT field.
	EFUSE_RD_REPEAT_DATA3_DIS_DIRECT_BOOT_Msk = 0x2
	// Bit DIS_DIRECT_BOOT.
	EFUSE_RD_REPEAT_DATA3_DIS_DIRECT_BOOT = 0x2
	// Position of DIS_USB_PRINT field.
	EFUSE_RD_REPEAT_DATA3_DIS_USB_PRINT_Pos = 0x2
	// Bit mask of DIS_USB_PRINT field.
	EFUSE_RD_REPEAT_DATA3_DIS_USB_PRINT_Msk = 0x4
	// Bit DIS_USB_PRINT.
	EFUSE_RD_REPEAT_DATA3_DIS_USB_PRINT = 0x4
	// Position of RPT4_RESERVED3_5 field.
	EFUSE_RD_REPEAT_DATA3_RPT4_RESERVED3_5_Pos = 0x3
	// Bit mask of RPT4_RESERVED3_5 field.
	EFUSE_RD_REPEAT_DATA3_RPT4_RESERVED3_5_Msk = 0x8
	// Bit RPT4_RESERVED3_5.
	EFUSE_RD_REPEAT_DATA3_RPT4_RESERVED3_5 = 0x8
	// Position of DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE field.
	EFUSE_RD_REPEAT_DATA3_DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_Pos = 0x4
	// Bit mask of DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE field.
	EFUSE_RD_REPEAT_DATA3_DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_Msk = 0x10
	// Bit DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE.
	EFUSE_RD_REPEAT_DATA3_DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE = 0x10
	// Position of ENABLE_SECURITY_DOWNLOAD field.
	EFUSE_RD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD_Pos = 0x5
	// Bit mask of ENABLE_SECURITY_DOWNLOAD field.
	EFUSE_RD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD_Msk = 0x20
	// Bit ENABLE_SECURITY_DOWNLOAD.
	EFUSE_RD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD = 0x20
	// Position of UART_PRINT_CONTROL field.
	EFUSE_RD_REPEAT_DATA3_UART_PRINT_CONTROL_Pos = 0x6
	// Bit mask of UART_PRINT_CONTROL field.
	EFUSE_RD_REPEAT_DATA3_UART_PRINT_CONTROL_Msk = 0xc0
	// Position of FORCE_SEND_RESUME field.
	EFUSE_RD_REPEAT_DATA3_FORCE_SEND_RESUME_Pos = 0x8
	// Bit mask of FORCE_SEND_RESUME field.
	EFUSE_RD_REPEAT_DATA3_FORCE_SEND_RESUME_Msk = 0x100
	// Bit FORCE_SEND_RESUME.
	EFUSE_RD_REPEAT_DATA3_FORCE_SEND_RESUME = 0x100
	// Position of SECURE_VERSION field.
	EFUSE_RD_REPEAT_DATA3_SECURE_VERSION_Pos = 0x9
	// Bit mask of SECURE_VERSION field.
	EFUSE_RD_REPEAT_DATA3_SECURE_VERSION_Msk = 0x1fffe00
	// Position of SECURE_BOOT_DISABLE_FAST_WAKE field.
	EFUSE_RD_REPEAT_DATA3_SECURE_BOOT_DISABLE_FAST_WAKE_Pos = 0x19
	// Bit mask of SECURE_BOOT_DISABLE_FAST_WAKE field.
	EFUSE_RD_REPEAT_DATA3_SECURE_BOOT_DISABLE_FAST_WAKE_Msk = 0x2000000
	// Bit SECURE_BOOT_DISABLE_FAST_WAKE.
	EFUSE_RD_REPEAT_DATA3_SECURE_BOOT_DISABLE_FAST_WAKE = 0x2000000
	// Position of HYS_EN_PAD0 field.
	EFUSE_RD_REPEAT_DATA3_HYS_EN_PAD0_Pos = 0x1a
	// Bit mask of HYS_EN_PAD0 field.
	EFUSE_RD_REPEAT_DATA3_HYS_EN_PAD0_Msk = 0xfc000000

	// RD_REPEAT_DATA4: BLOCK0 data register 5.
	// Position of HYS_EN_PAD1 field.
	EFUSE_RD_REPEAT_DATA4_HYS_EN_PAD1_Pos = 0x0
	// Bit mask of HYS_EN_PAD1 field.
	EFUSE_RD_REPEAT_DATA4_HYS_EN_PAD1_Msk = 0x3fffff
	// Position of RPT4_RESERVED4_1 field.
	EFUSE_RD_REPEAT_DATA4_RPT4_RESERVED4_1_Pos = 0x16
	// Bit mask of RPT4_RESERVED4_1 field.
	EFUSE_RD_REPEAT_DATA4_RPT4_RESERVED4_1_Msk = 0xc00000
	// Position of RPT4_RESERVED4_0 field.
	EFUSE_RD_REPEAT_DATA4_RPT4_RESERVED4_0_Pos = 0x18
	// Bit mask of RPT4_RESERVED4_0 field.
	EFUSE_RD_REPEAT_DATA4_RPT4_RESERVED4_0_Msk = 0xff000000

	// RD_MAC_SYS_0: BLOCK1 data register $n.
	// Position of MAC_0 field.
	EFUSE_RD_MAC_SYS_0_MAC_0_Pos = 0x0
	// Bit mask of MAC_0 field.
	EFUSE_RD_MAC_SYS_0_MAC_0_Msk = 0xffffffff

	// RD_MAC_SYS_1: BLOCK1 data register $n.
	// Position of MAC_1 field.
	EFUSE_RD_MAC_SYS_1_MAC_1_Pos = 0x0
	// Bit mask of MAC_1 field.
	EFUSE_RD_MAC_SYS_1_MAC_1_Msk = 0xffff
	// Position of MAC_EXT field.
	EFUSE_RD_MAC_SYS_1_MAC_EXT_Pos = 0x10
	// Bit mask of MAC_EXT field.
	EFUSE_RD_MAC_SYS_1_MAC_EXT_Msk = 0xffff0000

	// RD_MAC_SYS_2: BLOCK1 data register $n.
	// Position of MAC_RESERVED_1 field.
	EFUSE_RD_MAC_SYS_2_MAC_RESERVED_1_Pos = 0x0
	// Bit mask of MAC_RESERVED_1 field.
	EFUSE_RD_MAC_SYS_2_MAC_RESERVED_1_Msk = 0x3fff
	// Position of MAC_RESERVED_0 field.
	EFUSE_RD_MAC_SYS_2_MAC_RESERVED_0_Pos = 0xe
	// Bit mask of MAC_RESERVED_0 field.
	EFUSE_RD_MAC_SYS_2_MAC_RESERVED_0_Msk = 0xffffc000

	// RD_MAC_SYS_3: BLOCK1 data register $n.
	// Position of MAC_RESERVED_2 field.
	EFUSE_RD_MAC_SYS_3_MAC_RESERVED_2_Pos = 0x0
	// Bit mask of MAC_RESERVED_2 field.
	EFUSE_RD_MAC_SYS_3_MAC_RESERVED_2_Msk = 0x3ffff
	// Position of SYS_DATA_PART0_0 field.
	EFUSE_RD_MAC_SYS_3_SYS_DATA_PART0_0_Pos = 0x12
	// Bit mask of SYS_DATA_PART0_0 field.
	EFUSE_RD_MAC_SYS_3_SYS_DATA_PART0_0_Msk = 0xfffc0000

	// RD_MAC_SYS_4: BLOCK1 data register $n.
	// Position of SYS_DATA_PART0_1 field.
	EFUSE_RD_MAC_SYS_4_SYS_DATA_PART0_1_Pos = 0x0
	// Bit mask of SYS_DATA_PART0_1 field.
	EFUSE_RD_MAC_SYS_4_SYS_DATA_PART0_1_Msk = 0xffffffff

	// RD_MAC_SYS_5: BLOCK1 data register $n.
	// Position of SYS_DATA_PART0_2 field.
	EFUSE_RD_MAC_SYS_5_SYS_DATA_PART0_2_Pos = 0x0
	// Bit mask of SYS_DATA_PART0_2 field.
	EFUSE_RD_MAC_SYS_5_SYS_DATA_PART0_2_Msk = 0xffffffff

	// RD_SYS_PART1_DATA0: Register $n of BLOCK2 (system).
	// Position of SYS_DATA_PART1_0 field.
	EFUSE_RD_SYS_PART1_DATA0_SYS_DATA_PART1_0_Pos = 0x0
	// Bit mask of SYS_DATA_PART1_0 field.
	EFUSE_RD_SYS_PART1_DATA0_SYS_DATA_PART1_0_Msk = 0xffffffff

	// RD_SYS_PART1_DATA1: Register $n of BLOCK2 (system).
	// Position of SYS_DATA_PART1_1 field.
	EFUSE_RD_SYS_PART1_DATA1_SYS_DATA_PART1_1_Pos = 0x0
	// Bit mask of SYS_DATA_PART1_1 field.
	EFUSE_RD_SYS_PART1_DATA1_SYS_DATA_PART1_1_Msk = 0xffffffff

	// RD_SYS_PART1_DATA2: Register $n of BLOCK2 (system).
	// Position of SYS_DATA_PART1_2 field.
	EFUSE_RD_SYS_PART1_DATA2_SYS_DATA_PART1_2_Pos = 0x0
	// Bit mask of SYS_DATA_PART1_2 field.
	EFUSE_RD_SYS_PART1_DATA2_SYS_DATA_PART1_2_Msk = 0xffffffff

	// RD_SYS_PART1_DATA3: Register $n of BLOCK2 (system).
	// Position of SYS_DATA_PART1_3 field.
	EFUSE_RD_SYS_PART1_DATA3_SYS_DATA_PART1_3_Pos = 0x0
	// Bit mask of SYS_DATA_PART1_3 field.
	EFUSE_RD_SYS_PART1_DATA3_SYS_DATA_PART1_3_Msk = 0xffffffff

	// RD_SYS_PART1_DATA4: Register $n of BLOCK2 (system).
	// Position of SYS_DATA_PART1_4 field.
	EFUSE_RD_SYS_PART1_DATA4_SYS_DATA_PART1_4_Pos = 0x0
	// Bit mask of SYS_DATA_PART1_4 field.
	EFUSE_RD_SYS_PART1_DATA4_SYS_DATA_PART1_4_Msk = 0xffffffff

	// RD_SYS_PART1_DATA5: Register $n of BLOCK2 (system).
	// Position of SYS_DATA_PART1_5 field.
	EFUSE_RD_SYS_PART1_DATA5_SYS_DATA_PART1_5_Pos = 0x0
	// Bit mask of SYS_DATA_PART1_5 field.
	EFUSE_RD_SYS_PART1_DATA5_SYS_DATA_PART1_5_Msk = 0xffffffff

	// RD_SYS_PART1_DATA6: Register $n of BLOCK2 (system).
	// Position of SYS_DATA_PART1_6 field.
	EFUSE_RD_SYS_PART1_DATA6_SYS_DATA_PART1_6_Pos = 0x0
	// Bit mask of SYS_DATA_PART1_6 field.
	EFUSE_RD_SYS_PART1_DATA6_SYS_DATA_PART1_6_Msk = 0xffffffff

	// RD_SYS_PART1_DATA7: Register $n of BLOCK2 (system).
	// Position of SYS_DATA_PART1_7 field.
	EFUSE_RD_SYS_PART1_DATA7_SYS_DATA_PART1_7_Pos = 0x0
	// Bit mask of SYS_DATA_PART1_7 field.
	EFUSE_RD_SYS_PART1_DATA7_SYS_DATA_PART1_7_Msk = 0xffffffff

	// RD_USR_DATA0: Register $n of BLOCK3 (user).
	// Position of USR_DATA0 field.
	EFUSE_RD_USR_DATA0_USR_DATA0_Pos = 0x0
	// Bit mask of USR_DATA0 field.
	EFUSE_RD_USR_DATA0_USR_DATA0_Msk = 0xffffffff

	// RD_USR_DATA1: Register $n of BLOCK3 (user).
	// Position of USR_DATA1 field.
	EFUSE_RD_USR_DATA1_USR_DATA1_Pos = 0x0
	// Bit mask of USR_DATA1 field.
	EFUSE_RD_USR_DATA1_USR_DATA1_Msk = 0xffffffff

	// RD_USR_DATA2: Register $n of BLOCK3 (user).
	// Position of USR_DATA2 field.
	EFUSE_RD_USR_DATA2_USR_DATA2_Pos = 0x0
	// Bit mask of USR_DATA2 field.
	EFUSE_RD_USR_DATA2_USR_DATA2_Msk = 0xffffffff

	// RD_USR_DATA3: Register $n of BLOCK3 (user).
	// Position of USR_DATA3 field.
	EFUSE_RD_USR_DATA3_USR_DATA3_Pos = 0x0
	// Bit mask of USR_DATA3 field.
	EFUSE_RD_USR_DATA3_USR_DATA3_Msk = 0xffffffff

	// RD_USR_DATA4: Register $n of BLOCK3 (user).
	// Position of USR_DATA4 field.
	EFUSE_RD_USR_DATA4_USR_DATA4_Pos = 0x0
	// Bit mask of USR_DATA4 field.
	EFUSE_RD_USR_DATA4_USR_DATA4_Msk = 0xffffffff

	// RD_USR_DATA5: Register $n of BLOCK3 (user).
	// Position of USR_DATA5 field.
	EFUSE_RD_USR_DATA5_USR_DATA5_Pos = 0x0
	// Bit mask of USR_DATA5 field.
	EFUSE_RD_USR_DATA5_USR_DATA5_Msk = 0xffffffff

	// RD_USR_DATA6: Register $n of BLOCK3 (user).
	// Position of USR_DATA6 field.
	EFUSE_RD_USR_DATA6_USR_DATA6_Pos = 0x0
	// Bit mask of USR_DATA6 field.
	EFUSE_RD_USR_DATA6_USR_DATA6_Msk = 0xffffffff

	// RD_USR_DATA7: Register $n of BLOCK3 (user).
	// Position of USR_DATA7 field.
	EFUSE_RD_USR_DATA7_USR_DATA7_Pos = 0x0
	// Bit mask of USR_DATA7 field.
	EFUSE_RD_USR_DATA7_USR_DATA7_Msk = 0xffffffff

	// RD_KEY0_DATA0: Register $n of BLOCK4 (KEY0).
	// Position of KEY0_DATA0 field.
	EFUSE_RD_KEY0_DATA0_KEY0_DATA0_Pos = 0x0
	// Bit mask of KEY0_DATA0 field.
	EFUSE_RD_KEY0_DATA0_KEY0_DATA0_Msk = 0xffffffff

	// RD_KEY0_DATA1: Register $n of BLOCK4 (KEY0).
	// Position of KEY0_DATA1 field.
	EFUSE_RD_KEY0_DATA1_KEY0_DATA1_Pos = 0x0
	// Bit mask of KEY0_DATA1 field.
	EFUSE_RD_KEY0_DATA1_KEY0_DATA1_Msk = 0xffffffff

	// RD_KEY0_DATA2: Register $n of BLOCK4 (KEY0).
	// Position of KEY0_DATA2 field.
	EFUSE_RD_KEY0_DATA2_KEY0_DATA2_Pos = 0x0
	// Bit mask of KEY0_DATA2 field.
	EFUSE_RD_KEY0_DATA2_KEY0_DATA2_Msk = 0xffffffff

	// RD_KEY0_DATA3: Register $n of BLOCK4 (KEY0).
	// Position of KEY0_DATA3 field.
	EFUSE_RD_KEY0_DATA3_KEY0_DATA3_Pos = 0x0
	// Bit mask of KEY0_DATA3 field.
	EFUSE_RD_KEY0_DATA3_KEY0_DATA3_Msk = 0xffffffff

	// RD_KEY0_DATA4: Register $n of BLOCK4 (KEY0).
	// Position of KEY0_DATA4 field.
	EFUSE_RD_KEY0_DATA4_KEY0_DATA4_Pos = 0x0
	// Bit mask of KEY0_DATA4 field.
	EFUSE_RD_KEY0_DATA4_KEY0_DATA4_Msk = 0xffffffff

	// RD_KEY0_DATA5: Register $n of BLOCK4 (KEY0).
	// Position of KEY0_DATA5 field.
	EFUSE_RD_KEY0_DATA5_KEY0_DATA5_Pos = 0x0
	// Bit mask of KEY0_DATA5 field.
	EFUSE_RD_KEY0_DATA5_KEY0_DATA5_Msk = 0xffffffff

	// RD_KEY0_DATA6: Register $n of BLOCK4 (KEY0).
	// Position of KEY0_DATA6 field.
	EFUSE_RD_KEY0_DATA6_KEY0_DATA6_Pos = 0x0
	// Bit mask of KEY0_DATA6 field.
	EFUSE_RD_KEY0_DATA6_KEY0_DATA6_Msk = 0xffffffff

	// RD_KEY0_DATA7: Register $n of BLOCK4 (KEY0).
	// Position of KEY0_DATA7 field.
	EFUSE_RD_KEY0_DATA7_KEY0_DATA7_Pos = 0x0
	// Bit mask of KEY0_DATA7 field.
	EFUSE_RD_KEY0_DATA7_KEY0_DATA7_Msk = 0xffffffff

	// RD_KEY1_DATA0: Register $n of BLOCK5 (KEY1).
	// Position of KEY1_DATA0 field.
	EFUSE_RD_KEY1_DATA0_KEY1_DATA0_Pos = 0x0
	// Bit mask of KEY1_DATA0 field.
	EFUSE_RD_KEY1_DATA0_KEY1_DATA0_Msk = 0xffffffff

	// RD_KEY1_DATA1: Register $n of BLOCK5 (KEY1).
	// Position of KEY1_DATA1 field.
	EFUSE_RD_KEY1_DATA1_KEY1_DATA1_Pos = 0x0
	// Bit mask of KEY1_DATA1 field.
	EFUSE_RD_KEY1_DATA1_KEY1_DATA1_Msk = 0xffffffff

	// RD_KEY1_DATA2: Register $n of BLOCK5 (KEY1).
	// Position of KEY1_DATA2 field.
	EFUSE_RD_KEY1_DATA2_KEY1_DATA2_Pos = 0x0
	// Bit mask of KEY1_DATA2 field.
	EFUSE_RD_KEY1_DATA2_KEY1_DATA2_Msk = 0xffffffff

	// RD_KEY1_DATA3: Register $n of BLOCK5 (KEY1).
	// Position of KEY1_DATA3 field.
	EFUSE_RD_KEY1_DATA3_KEY1_DATA3_Pos = 0x0
	// Bit mask of KEY1_DATA3 field.
	EFUSE_RD_KEY1_DATA3_KEY1_DATA3_Msk = 0xffffffff

	// RD_KEY1_DATA4: Register $n of BLOCK5 (KEY1).
	// Position of KEY1_DATA4 field.
	EFUSE_RD_KEY1_DATA4_KEY1_DATA4_Pos = 0x0
	// Bit mask of KEY1_DATA4 field.
	EFUSE_RD_KEY1_DATA4_KEY1_DATA4_Msk = 0xffffffff

	// RD_KEY1_DATA5: Register $n of BLOCK5 (KEY1).
	// Position of KEY1_DATA5 field.
	EFUSE_RD_KEY1_DATA5_KEY1_DATA5_Pos = 0x0
	// Bit mask of KEY1_DATA5 field.
	EFUSE_RD_KEY1_DATA5_KEY1_DATA5_Msk = 0xffffffff

	// RD_KEY1_DATA6: Register $n of BLOCK5 (KEY1).
	// Position of KEY1_DATA6 field.
	EFUSE_RD_KEY1_DATA6_KEY1_DATA6_Pos = 0x0
	// Bit mask of KEY1_DATA6 field.
	EFUSE_RD_KEY1_DATA6_KEY1_DATA6_Msk = 0xffffffff

	// RD_KEY1_DATA7: Register $n of BLOCK5 (KEY1).
	// Position of KEY1_DATA7 field.
	EFUSE_RD_KEY1_DATA7_KEY1_DATA7_Pos = 0x0
	// Bit mask of KEY1_DATA7 field.
	EFUSE_RD_KEY1_DATA7_KEY1_DATA7_Msk = 0xffffffff

	// RD_KEY2_DATA0: Register $n of BLOCK6 (KEY2).
	// Position of KEY2_DATA0 field.
	EFUSE_RD_KEY2_DATA0_KEY2_DATA0_Pos = 0x0
	// Bit mask of KEY2_DATA0 field.
	EFUSE_RD_KEY2_DATA0_KEY2_DATA0_Msk = 0xffffffff

	// RD_KEY2_DATA1: Register $n of BLOCK6 (KEY2).
	// Position of KEY2_DATA1 field.
	EFUSE_RD_KEY2_DATA1_KEY2_DATA1_Pos = 0x0
	// Bit mask of KEY2_DATA1 field.
	EFUSE_RD_KEY2_DATA1_KEY2_DATA1_Msk = 0xffffffff

	// RD_KEY2_DATA2: Register $n of BLOCK6 (KEY2).
	// Position of KEY2_DATA2 field.
	EFUSE_RD_KEY2_DATA2_KEY2_DATA2_Pos = 0x0
	// Bit mask of KEY2_DATA2 field.
	EFUSE_RD_KEY2_DATA2_KEY2_DATA2_Msk = 0xffffffff

	// RD_KEY2_DATA3: Register $n of BLOCK6 (KEY2).
	// Position of KEY2_DATA3 field.
	EFUSE_RD_KEY2_DATA3_KEY2_DATA3_Pos = 0x0
	// Bit mask of KEY2_DATA3 field.
	EFUSE_RD_KEY2_DATA3_KEY2_DATA3_Msk = 0xffffffff

	// RD_KEY2_DATA4: Register $n of BLOCK6 (KEY2).
	// Position of KEY2_DATA4 field.
	EFUSE_RD_KEY2_DATA4_KEY2_DATA4_Pos = 0x0
	// Bit mask of KEY2_DATA4 field.
	EFUSE_RD_KEY2_DATA4_KEY2_DATA4_Msk = 0xffffffff

	// RD_KEY2_DATA5: Register $n of BLOCK6 (KEY2).
	// Position of KEY2_DATA5 field.
	EFUSE_RD_KEY2_DATA5_KEY2_DATA5_Pos = 0x0
	// Bit mask of KEY2_DATA5 field.
	EFUSE_RD_KEY2_DATA5_KEY2_DATA5_Msk = 0xffffffff

	// RD_KEY2_DATA6: Register $n of BLOCK6 (KEY2).
	// Position of KEY2_DATA6 field.
	EFUSE_RD_KEY2_DATA6_KEY2_DATA6_Pos = 0x0
	// Bit mask of KEY2_DATA6 field.
	EFUSE_RD_KEY2_DATA6_KEY2_DATA6_Msk = 0xffffffff

	// RD_KEY2_DATA7: Register $n of BLOCK6 (KEY2).
	// Position of KEY2_DATA7 field.
	EFUSE_RD_KEY2_DATA7_KEY2_DATA7_Pos = 0x0
	// Bit mask of KEY2_DATA7 field.
	EFUSE_RD_KEY2_DATA7_KEY2_DATA7_Msk = 0xffffffff

	// RD_KEY3_DATA0: Register $n of BLOCK7 (KEY3).
	// Position of KEY3_DATA0 field.
	EFUSE_RD_KEY3_DATA0_KEY3_DATA0_Pos = 0x0
	// Bit mask of KEY3_DATA0 field.
	EFUSE_RD_KEY3_DATA0_KEY3_DATA0_Msk = 0xffffffff

	// RD_KEY3_DATA1: Register $n of BLOCK7 (KEY3).
	// Position of KEY3_DATA1 field.
	EFUSE_RD_KEY3_DATA1_KEY3_DATA1_Pos = 0x0
	// Bit mask of KEY3_DATA1 field.
	EFUSE_RD_KEY3_DATA1_KEY3_DATA1_Msk = 0xffffffff

	// RD_KEY3_DATA2: Register $n of BLOCK7 (KEY3).
	// Position of KEY3_DATA2 field.
	EFUSE_RD_KEY3_DATA2_KEY3_DATA2_Pos = 0x0
	// Bit mask of KEY3_DATA2 field.
	EFUSE_RD_KEY3_DATA2_KEY3_DATA2_Msk = 0xffffffff

	// RD_KEY3_DATA3: Register $n of BLOCK7 (KEY3).
	// Position of KEY3_DATA3 field.
	EFUSE_RD_KEY3_DATA3_KEY3_DATA3_Pos = 0x0
	// Bit mask of KEY3_DATA3 field.
	EFUSE_RD_KEY3_DATA3_KEY3_DATA3_Msk = 0xffffffff

	// RD_KEY3_DATA4: Register $n of BLOCK7 (KEY3).
	// Position of KEY3_DATA4 field.
	EFUSE_RD_KEY3_DATA4_KEY3_DATA4_Pos = 0x0
	// Bit mask of KEY3_DATA4 field.
	EFUSE_RD_KEY3_DATA4_KEY3_DATA4_Msk = 0xffffffff

	// RD_KEY3_DATA5: Register $n of BLOCK7 (KEY3).
	// Position of KEY3_DATA5 field.
	EFUSE_RD_KEY3_DATA5_KEY3_DATA5_Pos = 0x0
	// Bit mask of KEY3_DATA5 field.
	EFUSE_RD_KEY3_DATA5_KEY3_DATA5_Msk = 0xffffffff

	// RD_KEY3_DATA6: Register $n of BLOCK7 (KEY3).
	// Position of KEY3_DATA6 field.
	EFUSE_RD_KEY3_DATA6_KEY3_DATA6_Pos = 0x0
	// Bit mask of KEY3_DATA6 field.
	EFUSE_RD_KEY3_DATA6_KEY3_DATA6_Msk = 0xffffffff

	// RD_KEY3_DATA7: Register $n of BLOCK7 (KEY3).
	// Position of KEY3_DATA7 field.
	EFUSE_RD_KEY3_DATA7_KEY3_DATA7_Pos = 0x0
	// Bit mask of KEY3_DATA7 field.
	EFUSE_RD_KEY3_DATA7_KEY3_DATA7_Msk = 0xffffffff

	// RD_KEY4_DATA0: Register $n of BLOCK8 (KEY4).
	// Position of KEY4_DATA0 field.
	EFUSE_RD_KEY4_DATA0_KEY4_DATA0_Pos = 0x0
	// Bit mask of KEY4_DATA0 field.
	EFUSE_RD_KEY4_DATA0_KEY4_DATA0_Msk = 0xffffffff

	// RD_KEY4_DATA1: Register $n of BLOCK8 (KEY4).
	// Position of KEY4_DATA1 field.
	EFUSE_RD_KEY4_DATA1_KEY4_DATA1_Pos = 0x0
	// Bit mask of KEY4_DATA1 field.
	EFUSE_RD_KEY4_DATA1_KEY4_DATA1_Msk = 0xffffffff

	// RD_KEY4_DATA2: Register $n of BLOCK8 (KEY4).
	// Position of KEY4_DATA2 field.
	EFUSE_RD_KEY4_DATA2_KEY4_DATA2_Pos = 0x0
	// Bit mask of KEY4_DATA2 field.
	EFUSE_RD_KEY4_DATA2_KEY4_DATA2_Msk = 0xffffffff

	// RD_KEY4_DATA3: Register $n of BLOCK8 (KEY4).
	// Position of KEY4_DATA3 field.
	EFUSE_RD_KEY4_DATA3_KEY4_DATA3_Pos = 0x0
	// Bit mask of KEY4_DATA3 field.
	EFUSE_RD_KEY4_DATA3_KEY4_DATA3_Msk = 0xffffffff

	// RD_KEY4_DATA4: Register $n of BLOCK8 (KEY4).
	// Position of KEY4_DATA4 field.
	EFUSE_RD_KEY4_DATA4_KEY4_DATA4_Pos = 0x0
	// Bit mask of KEY4_DATA4 field.
	EFUSE_RD_KEY4_DATA4_KEY4_DATA4_Msk = 0xffffffff

	// RD_KEY4_DATA5: Register $n of BLOCK8 (KEY4).
	// Position of KEY4_DATA5 field.
	EFUSE_RD_KEY4_DATA5_KEY4_DATA5_Pos = 0x0
	// Bit mask of KEY4_DATA5 field.
	EFUSE_RD_KEY4_DATA5_KEY4_DATA5_Msk = 0xffffffff

	// RD_KEY4_DATA6: Register $n of BLOCK8 (KEY4).
	// Position of KEY4_DATA6 field.
	EFUSE_RD_KEY4_DATA6_KEY4_DATA6_Pos = 0x0
	// Bit mask of KEY4_DATA6 field.
	EFUSE_RD_KEY4_DATA6_KEY4_DATA6_Msk = 0xffffffff

	// RD_KEY4_DATA7: Register $n of BLOCK8 (KEY4).
	// Position of KEY4_DATA7 field.
	EFUSE_RD_KEY4_DATA7_KEY4_DATA7_Pos = 0x0
	// Bit mask of KEY4_DATA7 field.
	EFUSE_RD_KEY4_DATA7_KEY4_DATA7_Msk = 0xffffffff

	// RD_KEY5_DATA0: Register $n of BLOCK9 (KEY5).
	// Position of KEY5_DATA0 field.
	EFUSE_RD_KEY5_DATA0_KEY5_DATA0_Pos = 0x0
	// Bit mask of KEY5_DATA0 field.
	EFUSE_RD_KEY5_DATA0_KEY5_DATA0_Msk = 0xffffffff

	// RD_KEY5_DATA1: Register $n of BLOCK9 (KEY5).
	// Position of KEY5_DATA1 field.
	EFUSE_RD_KEY5_DATA1_KEY5_DATA1_Pos = 0x0
	// Bit mask of KEY5_DATA1 field.
	EFUSE_RD_KEY5_DATA1_KEY5_DATA1_Msk = 0xffffffff

	// RD_KEY5_DATA2: Register $n of BLOCK9 (KEY5).
	// Position of KEY5_DATA2 field.
	EFUSE_RD_KEY5_DATA2_KEY5_DATA2_Pos = 0x0
	// Bit mask of KEY5_DATA2 field.
	EFUSE_RD_KEY5_DATA2_KEY5_DATA2_Msk = 0xffffffff

	// RD_KEY5_DATA3: Register $n of BLOCK9 (KEY5).
	// Position of KEY5_DATA3 field.
	EFUSE_RD_KEY5_DATA3_KEY5_DATA3_Pos = 0x0
	// Bit mask of KEY5_DATA3 field.
	EFUSE_RD_KEY5_DATA3_KEY5_DATA3_Msk = 0xffffffff

	// RD_KEY5_DATA4: Register $n of BLOCK9 (KEY5).
	// Position of KEY5_DATA4 field.
	EFUSE_RD_KEY5_DATA4_KEY5_DATA4_Pos = 0x0
	// Bit mask of KEY5_DATA4 field.
	EFUSE_RD_KEY5_DATA4_KEY5_DATA4_Msk = 0xffffffff

	// RD_KEY5_DATA5: Register $n of BLOCK9 (KEY5).
	// Position of KEY5_DATA5 field.
	EFUSE_RD_KEY5_DATA5_KEY5_DATA5_Pos = 0x0
	// Bit mask of KEY5_DATA5 field.
	EFUSE_RD_KEY5_DATA5_KEY5_DATA5_Msk = 0xffffffff

	// RD_KEY5_DATA6: Register $n of BLOCK9 (KEY5).
	// Position of KEY5_DATA6 field.
	EFUSE_RD_KEY5_DATA6_KEY5_DATA6_Pos = 0x0
	// Bit mask of KEY5_DATA6 field.
	EFUSE_RD_KEY5_DATA6_KEY5_DATA6_Msk = 0xffffffff

	// RD_KEY5_DATA7: Register $n of BLOCK9 (KEY5).
	// Position of KEY5_DATA7 field.
	EFUSE_RD_KEY5_DATA7_KEY5_DATA7_Pos = 0x0
	// Bit mask of KEY5_DATA7 field.
	EFUSE_RD_KEY5_DATA7_KEY5_DATA7_Msk = 0xffffffff

	// RD_SYS_PART2_DATA0: Register $n of BLOCK10 (system).
	// Position of SYS_DATA_PART2_0 field.
	EFUSE_RD_SYS_PART2_DATA0_SYS_DATA_PART2_0_Pos = 0x0
	// Bit mask of SYS_DATA_PART2_0 field.
	EFUSE_RD_SYS_PART2_DATA0_SYS_DATA_PART2_0_Msk = 0xffffffff

	// RD_SYS_PART2_DATA1: Register $n of BLOCK9 (KEY5).
	// Position of SYS_DATA_PART2_1 field.
	EFUSE_RD_SYS_PART2_DATA1_SYS_DATA_PART2_1_Pos = 0x0
	// Bit mask of SYS_DATA_PART2_1 field.
	EFUSE_RD_SYS_PART2_DATA1_SYS_DATA_PART2_1_Msk = 0xffffffff

	// RD_SYS_PART2_DATA2: Register $n of BLOCK10 (system).
	// Position of SYS_DATA_PART2_2 field.
	EFUSE_RD_SYS_PART2_DATA2_SYS_DATA_PART2_2_Pos = 0x0
	// Bit mask of SYS_DATA_PART2_2 field.
	EFUSE_RD_SYS_PART2_DATA2_SYS_DATA_PART2_2_Msk = 0xffffffff

	// RD_SYS_PART2_DATA3: Register $n of BLOCK10 (system).
	// Position of SYS_DATA_PART2_3 field.
	EFUSE_RD_SYS_PART2_DATA3_SYS_DATA_PART2_3_Pos = 0x0
	// Bit mask of SYS_DATA_PART2_3 field.
	EFUSE_RD_SYS_PART2_DATA3_SYS_DATA_PART2_3_Msk = 0xffffffff

	// RD_SYS_PART2_DATA4: Register $n of BLOCK10 (system).
	// Position of SYS_DATA_PART2_4 field.
	EFUSE_RD_SYS_PART2_DATA4_SYS_DATA_PART2_4_Pos = 0x0
	// Bit mask of SYS_DATA_PART2_4 field.
	EFUSE_RD_SYS_PART2_DATA4_SYS_DATA_PART2_4_Msk = 0xffffffff

	// RD_SYS_PART2_DATA5: Register $n of BLOCK10 (system).
	// Position of SYS_DATA_PART2_5 field.
	EFUSE_RD_SYS_PART2_DATA5_SYS_DATA_PART2_5_Pos = 0x0
	// Bit mask of SYS_DATA_PART2_5 field.
	EFUSE_RD_SYS_PART2_DATA5_SYS_DATA_PART2_5_Msk = 0xffffffff

	// RD_SYS_PART2_DATA6: Register $n of BLOCK10 (system).
	// Position of SYS_DATA_PART2_6 field.
	EFUSE_RD_SYS_PART2_DATA6_SYS_DATA_PART2_6_Pos = 0x0
	// Bit mask of SYS_DATA_PART2_6 field.
	EFUSE_RD_SYS_PART2_DATA6_SYS_DATA_PART2_6_Msk = 0xffffffff

	// RD_SYS_PART2_DATA7: Register $n of BLOCK10 (system).
	// Position of SYS_DATA_PART2_7 field.
	EFUSE_RD_SYS_PART2_DATA7_SYS_DATA_PART2_7_Pos = 0x0
	// Bit mask of SYS_DATA_PART2_7 field.
	EFUSE_RD_SYS_PART2_DATA7_SYS_DATA_PART2_7_Msk = 0xffffffff

	// RD_REPEAT_ERR0: Programming error record register 0 of BLOCK0.
	// Position of RD_DIS_ERR field.
	EFUSE_RD_REPEAT_ERR0_RD_DIS_ERR_Pos = 0x0
	// Bit mask of RD_DIS_ERR field.
	EFUSE_RD_REPEAT_ERR0_RD_DIS_ERR_Msk = 0x7f
	// Position of RPT4_RESERVED0_ERR_4 field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_4_Pos = 0x7
	// Bit mask of RPT4_RESERVED0_ERR_4 field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_4_Msk = 0x80
	// Bit RPT4_RESERVED0_ERR_4.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_4 = 0x80
	// Position of DIS_ICACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_ICACHE_ERR_Pos = 0x8
	// Bit mask of DIS_ICACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_ICACHE_ERR_Msk = 0x100
	// Bit DIS_ICACHE_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_ICACHE_ERR = 0x100
	// Position of DIS_USB_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_USB_JTAG_ERR_Pos = 0x9
	// Bit mask of DIS_USB_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_USB_JTAG_ERR_Msk = 0x200
	// Bit DIS_USB_JTAG_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_USB_JTAG_ERR = 0x200
	// Position of POWERGLITCH_EN_ERR field.
	EFUSE_RD_REPEAT_ERR0_POWERGLITCH_EN_ERR_Pos = 0xa
	// Bit mask of POWERGLITCH_EN_ERR field.
	EFUSE_RD_REPEAT_ERR0_POWERGLITCH_EN_ERR_Msk = 0x400
	// Bit POWERGLITCH_EN_ERR.
	EFUSE_RD_REPEAT_ERR0_POWERGLITCH_EN_ERR = 0x400
	// Position of DIS_USB_SERIAL_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_USB_SERIAL_JTAG_ERR_Pos = 0xb
	// Bit mask of DIS_USB_SERIAL_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_USB_SERIAL_JTAG_ERR_Msk = 0x800
	// Bit DIS_USB_SERIAL_JTAG_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_USB_SERIAL_JTAG_ERR = 0x800
	// Position of DIS_FORCE_DOWNLOAD_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR_Pos = 0xc
	// Bit mask of DIS_FORCE_DOWNLOAD_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR_Msk = 0x1000
	// Bit DIS_FORCE_DOWNLOAD_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR = 0x1000
	// Position of SPI_DOWNLOAD_MSPI_DIS_ERR field.
	EFUSE_RD_REPEAT_ERR0_SPI_DOWNLOAD_MSPI_DIS_ERR_Pos = 0xd
	// Bit mask of SPI_DOWNLOAD_MSPI_DIS_ERR field.
	EFUSE_RD_REPEAT_ERR0_SPI_DOWNLOAD_MSPI_DIS_ERR_Msk = 0x2000
	// Bit SPI_DOWNLOAD_MSPI_DIS_ERR.
	EFUSE_RD_REPEAT_ERR0_SPI_DOWNLOAD_MSPI_DIS_ERR = 0x2000
	// Position of DIS_TWAI_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_TWAI_ERR_Pos = 0xe
	// Bit mask of DIS_TWAI_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_TWAI_ERR_Msk = 0x4000
	// Bit DIS_TWAI_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_TWAI_ERR = 0x4000
	// Position of JTAG_SEL_ENABLE_ERR field.
	EFUSE_RD_REPEAT_ERR0_JTAG_SEL_ENABLE_ERR_Pos = 0xf
	// Bit mask of JTAG_SEL_ENABLE_ERR field.
	EFUSE_RD_REPEAT_ERR0_JTAG_SEL_ENABLE_ERR_Msk = 0x8000
	// Bit JTAG_SEL_ENABLE_ERR.
	EFUSE_RD_REPEAT_ERR0_JTAG_SEL_ENABLE_ERR = 0x8000
	// Position of SOFT_DIS_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR_Pos = 0x10
	// Bit mask of SOFT_DIS_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR_Msk = 0x70000
	// Position of DIS_PAD_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_PAD_JTAG_ERR_Pos = 0x13
	// Bit mask of DIS_PAD_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_PAD_JTAG_ERR_Msk = 0x80000
	// Bit DIS_PAD_JTAG_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_PAD_JTAG_ERR = 0x80000
	// Position of DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR_Pos = 0x14
	// Bit mask of DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR_Msk = 0x100000
	// Bit DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR = 0x100000
	// Position of USB_DREFH_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_DREFH_ERR_Pos = 0x15
	// Bit mask of USB_DREFH_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_DREFH_ERR_Msk = 0x600000
	// Position of USB_DREFL_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_DREFL_ERR_Pos = 0x17
	// Bit mask of USB_DREFL_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_DREFL_ERR_Msk = 0x1800000
	// Position of USB_EXCHG_PINS_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_EXCHG_PINS_ERR_Pos = 0x19
	// Bit mask of USB_EXCHG_PINS_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_EXCHG_PINS_ERR_Msk = 0x2000000
	// Bit USB_EXCHG_PINS_ERR.
	EFUSE_RD_REPEAT_ERR0_USB_EXCHG_PINS_ERR = 0x2000000
	// Position of VDD_SPI_AS_GPIO_ERR field.
	EFUSE_RD_REPEAT_ERR0_VDD_SPI_AS_GPIO_ERR_Pos = 0x1a
	// Bit mask of VDD_SPI_AS_GPIO_ERR field.
	EFUSE_RD_REPEAT_ERR0_VDD_SPI_AS_GPIO_ERR_Msk = 0x4000000
	// Bit VDD_SPI_AS_GPIO_ERR.
	EFUSE_RD_REPEAT_ERR0_VDD_SPI_AS_GPIO_ERR = 0x4000000
	// Position of RPT4_RESERVED0_ERR_2 field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_2_Pos = 0x1b
	// Bit mask of RPT4_RESERVED0_ERR_2 field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_2_Msk = 0x18000000
	// Position of RPT4_RESERVED0_ERR_1 field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_1_Pos = 0x1d
	// Bit mask of RPT4_RESERVED0_ERR_1 field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_1_Msk = 0x20000000
	// Bit RPT4_RESERVED0_ERR_1.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_1 = 0x20000000
	// Position of RPT4_RESERVED0_ERR_0 field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_0_Pos = 0x1e
	// Bit mask of RPT4_RESERVED0_ERR_0 field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_0_Msk = 0xc0000000

	// RD_REPEAT_ERR1: Programming error record register 1 of BLOCK0.
	// Position of RPT4_RESERVED1_ERR_0 field.
	EFUSE_RD_REPEAT_ERR1_RPT4_RESERVED1_ERR_0_Pos = 0x0
	// Bit mask of RPT4_RESERVED1_ERR_0 field.
	EFUSE_RD_REPEAT_ERR1_RPT4_RESERVED1_ERR_0_Msk = 0xffff
	// Position of WDT_DELAY_SEL_ERR field.
	EFUSE_RD_REPEAT_ERR1_WDT_DELAY_SEL_ERR_Pos = 0x10
	// Bit mask of WDT_DELAY_SEL_ERR field.
	EFUSE_RD_REPEAT_ERR1_WDT_DELAY_SEL_ERR_Msk = 0x30000
	// Position of SPI_BOOT_CRYPT_CNT_ERR field.
	EFUSE_RD_REPEAT_ERR1_SPI_BOOT_CRYPT_CNT_ERR_Pos = 0x12
	// Bit mask of SPI_BOOT_CRYPT_CNT_ERR field.
	EFUSE_RD_REPEAT_ERR1_SPI_BOOT_CRYPT_CNT_ERR_Msk = 0x1c0000
	// Position of SECURE_BOOT_KEY_REVOKE0_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR_Pos = 0x15
	// Bit mask of SECURE_BOOT_KEY_REVOKE0_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR_Msk = 0x200000
	// Bit SECURE_BOOT_KEY_REVOKE0_ERR.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR = 0x200000
	// Position of SECURE_BOOT_KEY_REVOKE1_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR_Pos = 0x16
	// Bit mask of SECURE_BOOT_KEY_REVOKE1_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR_Msk = 0x400000
	// Bit SECURE_BOOT_KEY_REVOKE1_ERR.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR = 0x400000
	// Position of SECURE_BOOT_KEY_REVOKE2_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR_Pos = 0x17
	// Bit mask of SECURE_BOOT_KEY_REVOKE2_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR_Msk = 0x800000
	// Bit SECURE_BOOT_KEY_REVOKE2_ERR.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR = 0x800000
	// Position of KEY_PURPOSE_0_ERR field.
	EFUSE_RD_REPEAT_ERR1_KEY_PURPOSE_0_ERR_Pos = 0x18
	// Bit mask of KEY_PURPOSE_0_ERR field.
	EFUSE_RD_REPEAT_ERR1_KEY_PURPOSE_0_ERR_Msk = 0xf000000
	// Position of KEY_PURPOSE_1_ERR field.
	EFUSE_RD_REPEAT_ERR1_KEY_PURPOSE_1_ERR_Pos = 0x1c
	// Bit mask of KEY_PURPOSE_1_ERR field.
	EFUSE_RD_REPEAT_ERR1_KEY_PURPOSE_1_ERR_Msk = 0xf0000000

	// RD_REPEAT_ERR2: Programming error record register 2 of BLOCK0.
	// Position of KEY_PURPOSE_2_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_2_ERR_Pos = 0x0
	// Bit mask of KEY_PURPOSE_2_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_2_ERR_Msk = 0xf
	// Position of KEY_PURPOSE_3_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_3_ERR_Pos = 0x4
	// Bit mask of KEY_PURPOSE_3_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_3_ERR_Msk = 0xf0
	// Position of KEY_PURPOSE_4_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_4_ERR_Pos = 0x8
	// Bit mask of KEY_PURPOSE_4_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_4_ERR_Msk = 0xf00
	// Position of KEY_PURPOSE_5_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_5_ERR_Pos = 0xc
	// Bit mask of KEY_PURPOSE_5_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_5_ERR_Msk = 0xf000
	// Position of SEC_DPA_LEVEL_ERR field.
	EFUSE_RD_REPEAT_ERR2_SEC_DPA_LEVEL_ERR_Pos = 0x10
	// Bit mask of SEC_DPA_LEVEL_ERR field.
	EFUSE_RD_REPEAT_ERR2_SEC_DPA_LEVEL_ERR_Msk = 0x30000
	// Position of RPT4_RESERVED2_ERR_1 field.
	EFUSE_RD_REPEAT_ERR2_RPT4_RESERVED2_ERR_1_Pos = 0x12
	// Bit mask of RPT4_RESERVED2_ERR_1 field.
	EFUSE_RD_REPEAT_ERR2_RPT4_RESERVED2_ERR_1_Msk = 0x40000
	// Bit RPT4_RESERVED2_ERR_1.
	EFUSE_RD_REPEAT_ERR2_RPT4_RESERVED2_ERR_1 = 0x40000
	// Position of CRYPT_DPA_ENABLE_ERR field.
	EFUSE_RD_REPEAT_ERR2_CRYPT_DPA_ENABLE_ERR_Pos = 0x13
	// Bit mask of CRYPT_DPA_ENABLE_ERR field.
	EFUSE_RD_REPEAT_ERR2_CRYPT_DPA_ENABLE_ERR_Msk = 0x80000
	// Bit CRYPT_DPA_ENABLE_ERR.
	EFUSE_RD_REPEAT_ERR2_CRYPT_DPA_ENABLE_ERR = 0x80000
	// Position of SECURE_BOOT_EN_ERR field.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_EN_ERR_Pos = 0x14
	// Bit mask of SECURE_BOOT_EN_ERR field.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_EN_ERR_Msk = 0x100000
	// Bit SECURE_BOOT_EN_ERR.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_EN_ERR = 0x100000
	// Position of SECURE_BOOT_AGGRESSIVE_REVOKE_ERR field.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR_Pos = 0x15
	// Bit mask of SECURE_BOOT_AGGRESSIVE_REVOKE_ERR field.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR_Msk = 0x200000
	// Bit SECURE_BOOT_AGGRESSIVE_REVOKE_ERR.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR = 0x200000
	// Position of RPT4_RESERVED2_ERR_0 field.
	EFUSE_RD_REPEAT_ERR2_RPT4_RESERVED2_ERR_0_Pos = 0x16
	// Bit mask of RPT4_RESERVED2_ERR_0 field.
	EFUSE_RD_REPEAT_ERR2_RPT4_RESERVED2_ERR_0_Msk = 0xfc00000
	// Position of FLASH_TPUW_ERR field.
	EFUSE_RD_REPEAT_ERR2_FLASH_TPUW_ERR_Pos = 0x1c
	// Bit mask of FLASH_TPUW_ERR field.
	EFUSE_RD_REPEAT_ERR2_FLASH_TPUW_ERR_Msk = 0xf0000000

	// RD_REPEAT_ERR3: Programming error record register 3 of BLOCK0.
	// Position of DIS_DOWNLOAD_MODE_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR_Pos = 0x0
	// Bit mask of DIS_DOWNLOAD_MODE_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR_Msk = 0x1
	// Bit DIS_DOWNLOAD_MODE_ERR.
	EFUSE_RD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR = 0x1
	// Position of DIS_DIRECT_BOOT_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_DIRECT_BOOT_ERR_Pos = 0x1
	// Bit mask of DIS_DIRECT_BOOT_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_DIRECT_BOOT_ERR_Msk = 0x2
	// Bit DIS_DIRECT_BOOT_ERR.
	EFUSE_RD_REPEAT_ERR3_DIS_DIRECT_BOOT_ERR = 0x2
	// Position of USB_PRINT_ERR field.
	EFUSE_RD_REPEAT_ERR3_USB_PRINT_ERR_Pos = 0x2
	// Bit mask of USB_PRINT_ERR field.
	EFUSE_RD_REPEAT_ERR3_USB_PRINT_ERR_Msk = 0x4
	// Bit USB_PRINT_ERR.
	EFUSE_RD_REPEAT_ERR3_USB_PRINT_ERR = 0x4
	// Position of RPT4_RESERVED3_ERR_5 field.
	EFUSE_RD_REPEAT_ERR3_RPT4_RESERVED3_ERR_5_Pos = 0x3
	// Bit mask of RPT4_RESERVED3_ERR_5 field.
	EFUSE_RD_REPEAT_ERR3_RPT4_RESERVED3_ERR_5_Msk = 0x8
	// Bit RPT4_RESERVED3_ERR_5.
	EFUSE_RD_REPEAT_ERR3_RPT4_RESERVED3_ERR_5 = 0x8
	// Position of DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_ERR_Pos = 0x4
	// Bit mask of DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_ERR_Msk = 0x10
	// Bit DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_ERR.
	EFUSE_RD_REPEAT_ERR3_DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_ERR = 0x10
	// Position of ENABLE_SECURITY_DOWNLOAD_ERR field.
	EFUSE_RD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR_Pos = 0x5
	// Bit mask of ENABLE_SECURITY_DOWNLOAD_ERR field.
	EFUSE_RD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR_Msk = 0x20
	// Bit ENABLE_SECURITY_DOWNLOAD_ERR.
	EFUSE_RD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR = 0x20
	// Position of UART_PRINT_CONTROL_ERR field.
	EFUSE_RD_REPEAT_ERR3_UART_PRINT_CONTROL_ERR_Pos = 0x6
	// Bit mask of UART_PRINT_CONTROL_ERR field.
	EFUSE_RD_REPEAT_ERR3_UART_PRINT_CONTROL_ERR_Msk = 0xc0
	// Position of FORCE_SEND_RESUME_ERR field.
	EFUSE_RD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR_Pos = 0x8
	// Bit mask of FORCE_SEND_RESUME_ERR field.
	EFUSE_RD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR_Msk = 0x100
	// Bit FORCE_SEND_RESUME_ERR.
	EFUSE_RD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR = 0x100
	// Position of SECURE_VERSION_ERR field.
	EFUSE_RD_REPEAT_ERR3_SECURE_VERSION_ERR_Pos = 0x9
	// Bit mask of SECURE_VERSION_ERR field.
	EFUSE_RD_REPEAT_ERR3_SECURE_VERSION_ERR_Msk = 0x1fffe00
	// Position of SECURE_BOOT_DISABLE_FAST_WAKE_ERR field.
	EFUSE_RD_REPEAT_ERR3_SECURE_BOOT_DISABLE_FAST_WAKE_ERR_Pos = 0x19
	// Bit mask of SECURE_BOOT_DISABLE_FAST_WAKE_ERR field.
	EFUSE_RD_REPEAT_ERR3_SECURE_BOOT_DISABLE_FAST_WAKE_ERR_Msk = 0x2000000
	// Bit SECURE_BOOT_DISABLE_FAST_WAKE_ERR.
	EFUSE_RD_REPEAT_ERR3_SECURE_BOOT_DISABLE_FAST_WAKE_ERR = 0x2000000
	// Position of HYS_EN_PAD0_ERR field.
	EFUSE_RD_REPEAT_ERR3_HYS_EN_PAD0_ERR_Pos = 0x1a
	// Bit mask of HYS_EN_PAD0_ERR field.
	EFUSE_RD_REPEAT_ERR3_HYS_EN_PAD0_ERR_Msk = 0xfc000000

	// RD_REPEAT_ERR4: Programming error record register 4 of BLOCK0.
	// Position of HYS_EN_PAD1_ERR field.
	EFUSE_RD_REPEAT_ERR4_HYS_EN_PAD1_ERR_Pos = 0x0
	// Bit mask of HYS_EN_PAD1_ERR field.
	EFUSE_RD_REPEAT_ERR4_HYS_EN_PAD1_ERR_Msk = 0x3fffff
	// Position of RPT4_RESERVED4_ERR_1 field.
	EFUSE_RD_REPEAT_ERR4_RPT4_RESERVED4_ERR_1_Pos = 0x16
	// Bit mask of RPT4_RESERVED4_ERR_1 field.
	EFUSE_RD_REPEAT_ERR4_RPT4_RESERVED4_ERR_1_Msk = 0xc00000
	// Position of RPT4_RESERVED4_ERR_0 field.
	EFUSE_RD_REPEAT_ERR4_RPT4_RESERVED4_ERR_0_Pos = 0x18
	// Bit mask of RPT4_RESERVED4_ERR_0 field.
	EFUSE_RD_REPEAT_ERR4_RPT4_RESERVED4_ERR_0_Msk = 0xff000000

	// RD_RS_ERR0: Programming error record register 0 of BLOCK1-10.
	// Position of MAC_SPI_8M_ERR_NUM field.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_ERR_NUM_Pos = 0x0
	// Bit mask of MAC_SPI_8M_ERR_NUM field.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_ERR_NUM_Msk = 0x7
	// Position of MAC_SPI_8M_FAIL field.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_FAIL_Pos = 0x3
	// Bit mask of MAC_SPI_8M_FAIL field.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_FAIL_Msk = 0x8
	// Bit MAC_SPI_8M_FAIL.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_FAIL = 0x8
	// Position of SYS_PART1_NUM field.
	EFUSE_RD_RS_ERR0_SYS_PART1_NUM_Pos = 0x4
	// Bit mask of SYS_PART1_NUM field.
	EFUSE_RD_RS_ERR0_SYS_PART1_NUM_Msk = 0x70
	// Position of SYS_PART1_FAIL field.
	EFUSE_RD_RS_ERR0_SYS_PART1_FAIL_Pos = 0x7
	// Bit mask of SYS_PART1_FAIL field.
	EFUSE_RD_RS_ERR0_SYS_PART1_FAIL_Msk = 0x80
	// Bit SYS_PART1_FAIL.
	EFUSE_RD_RS_ERR0_SYS_PART1_FAIL = 0x80
	// Position of USR_DATA_ERR_NUM field.
	EFUSE_RD_RS_ERR0_USR_DATA_ERR_NUM_Pos = 0x8
	// Bit mask of USR_DATA_ERR_NUM field.
	EFUSE_RD_RS_ERR0_USR_DATA_ERR_NUM_Msk = 0x700
	// Position of USR_DATA_FAIL field.
	EFUSE_RD_RS_ERR0_USR_DATA_FAIL_Pos = 0xb
	// Bit mask of USR_DATA_FAIL field.
	EFUSE_RD_RS_ERR0_USR_DATA_FAIL_Msk = 0x800
	// Bit USR_DATA_FAIL.
	EFUSE_RD_RS_ERR0_USR_DATA_FAIL = 0x800
	// Position of KEY0_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY0_ERR_NUM_Pos = 0xc
	// Bit mask of KEY0_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY0_ERR_NUM_Msk = 0x7000
	// Position of KEY0_FAIL field.
	EFUSE_RD_RS_ERR0_KEY0_FAIL_Pos = 0xf
	// Bit mask of KEY0_FAIL field.
	EFUSE_RD_RS_ERR0_KEY0_FAIL_Msk = 0x8000
	// Bit KEY0_FAIL.
	EFUSE_RD_RS_ERR0_KEY0_FAIL = 0x8000
	// Position of KEY1_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY1_ERR_NUM_Pos = 0x10
	// Bit mask of KEY1_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY1_ERR_NUM_Msk = 0x70000
	// Position of KEY1_FAIL field.
	EFUSE_RD_RS_ERR0_KEY1_FAIL_Pos = 0x13
	// Bit mask of KEY1_FAIL field.
	EFUSE_RD_RS_ERR0_KEY1_FAIL_Msk = 0x80000
	// Bit KEY1_FAIL.
	EFUSE_RD_RS_ERR0_KEY1_FAIL = 0x80000
	// Position of KEY2_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY2_ERR_NUM_Pos = 0x14
	// Bit mask of KEY2_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY2_ERR_NUM_Msk = 0x700000
	// Position of KEY2_FAIL field.
	EFUSE_RD_RS_ERR0_KEY2_FAIL_Pos = 0x17
	// Bit mask of KEY2_FAIL field.
	EFUSE_RD_RS_ERR0_KEY2_FAIL_Msk = 0x800000
	// Bit KEY2_FAIL.
	EFUSE_RD_RS_ERR0_KEY2_FAIL = 0x800000
	// Position of KEY3_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY3_ERR_NUM_Pos = 0x18
	// Bit mask of KEY3_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY3_ERR_NUM_Msk = 0x7000000
	// Position of KEY3_FAIL field.
	EFUSE_RD_RS_ERR0_KEY3_FAIL_Pos = 0x1b
	// Bit mask of KEY3_FAIL field.
	EFUSE_RD_RS_ERR0_KEY3_FAIL_Msk = 0x8000000
	// Bit KEY3_FAIL.
	EFUSE_RD_RS_ERR0_KEY3_FAIL = 0x8000000
	// Position of KEY4_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY4_ERR_NUM_Pos = 0x1c
	// Bit mask of KEY4_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY4_ERR_NUM_Msk = 0x70000000
	// Position of KEY4_FAIL field.
	EFUSE_RD_RS_ERR0_KEY4_FAIL_Pos = 0x1f
	// Bit mask of KEY4_FAIL field.
	EFUSE_RD_RS_ERR0_KEY4_FAIL_Msk = 0x80000000
	// Bit KEY4_FAIL.
	EFUSE_RD_RS_ERR0_KEY4_FAIL = 0x80000000

	// RD_RS_ERR1: Programming error record register 1 of BLOCK1-10.
	// Position of KEY5_ERR_NUM field.
	EFUSE_RD_RS_ERR1_KEY5_ERR_NUM_Pos = 0x0
	// Bit mask of KEY5_ERR_NUM field.
	EFUSE_RD_RS_ERR1_KEY5_ERR_NUM_Msk = 0x7
	// Position of KEY5_FAIL field.
	EFUSE_RD_RS_ERR1_KEY5_FAIL_Pos = 0x3
	// Bit mask of KEY5_FAIL field.
	EFUSE_RD_RS_ERR1_KEY5_FAIL_Msk = 0x8
	// Bit KEY5_FAIL.
	EFUSE_RD_RS_ERR1_KEY5_FAIL = 0x8
	// Position of SYS_PART2_ERR_NUM field.
	EFUSE_RD_RS_ERR1_SYS_PART2_ERR_NUM_Pos = 0x4
	// Bit mask of SYS_PART2_ERR_NUM field.
	EFUSE_RD_RS_ERR1_SYS_PART2_ERR_NUM_Msk = 0x70
	// Position of SYS_PART2_FAIL field.
	EFUSE_RD_RS_ERR1_SYS_PART2_FAIL_Pos = 0x7
	// Bit mask of SYS_PART2_FAIL field.
	EFUSE_RD_RS_ERR1_SYS_PART2_FAIL_Msk = 0x80
	// Bit SYS_PART2_FAIL.
	EFUSE_RD_RS_ERR1_SYS_PART2_FAIL = 0x80

	// CLK: eFuse clcok configuration register.
	// Position of MEM_FORCE_PD field.
	EFUSE_CLK_MEM_FORCE_PD_Pos = 0x0
	// Bit mask of MEM_FORCE_PD field.
	EFUSE_CLK_MEM_FORCE_PD_Msk = 0x1
	// Bit MEM_FORCE_PD.
	EFUSE_CLK_MEM_FORCE_PD = 0x1
	// Position of MEM_CLK_FORCE_ON field.
	EFUSE_CLK_MEM_CLK_FORCE_ON_Pos = 0x1
	// Bit mask of MEM_CLK_FORCE_ON field.
	EFUSE_CLK_MEM_CLK_FORCE_ON_Msk = 0x2
	// Bit MEM_CLK_FORCE_ON.
	EFUSE_CLK_MEM_CLK_FORCE_ON = 0x2
	// Position of MEM_FORCE_PU field.
	EFUSE_CLK_MEM_FORCE_PU_Pos = 0x2
	// Bit mask of MEM_FORCE_PU field.
	EFUSE_CLK_MEM_FORCE_PU_Msk = 0x4
	// Bit MEM_FORCE_PU.
	EFUSE_CLK_MEM_FORCE_PU = 0x4
	// Position of EN field.
	EFUSE_CLK_EN_Pos = 0x10
	// Bit mask of EN field.
	EFUSE_CLK_EN_Msk = 0x10000
	// Bit EN.
	EFUSE_CLK_EN = 0x10000

	// CONF: eFuse operation mode configuraiton register
	// Position of OP_CODE field.
	EFUSE_CONF_OP_CODE_Pos = 0x0
	// Bit mask of OP_CODE field.
	EFUSE_CONF_OP_CODE_Msk = 0xffff
	// Position of CFG_ECDSA_BLK field.
	EFUSE_CONF_CFG_ECDSA_BLK_Pos = 0x10
	// Bit mask of CFG_ECDSA_BLK field.
	EFUSE_CONF_CFG_ECDSA_BLK_Msk = 0xf0000

	// STATUS: eFuse status register.
	// Position of STATE field.
	EFUSE_STATUS_STATE_Pos = 0x0
	// Bit mask of STATE field.
	EFUSE_STATUS_STATE_Msk = 0xf
	// Position of OTP_LOAD_SW field.
	EFUSE_STATUS_OTP_LOAD_SW_Pos = 0x4
	// Bit mask of OTP_LOAD_SW field.
	EFUSE_STATUS_OTP_LOAD_SW_Msk = 0x10
	// Bit OTP_LOAD_SW.
	EFUSE_STATUS_OTP_LOAD_SW = 0x10
	// Position of OTP_VDDQ_C_SYNC2 field.
	EFUSE_STATUS_OTP_VDDQ_C_SYNC2_Pos = 0x5
	// Bit mask of OTP_VDDQ_C_SYNC2 field.
	EFUSE_STATUS_OTP_VDDQ_C_SYNC2_Msk = 0x20
	// Bit OTP_VDDQ_C_SYNC2.
	EFUSE_STATUS_OTP_VDDQ_C_SYNC2 = 0x20
	// Position of OTP_STROBE_SW field.
	EFUSE_STATUS_OTP_STROBE_SW_Pos = 0x6
	// Bit mask of OTP_STROBE_SW field.
	EFUSE_STATUS_OTP_STROBE_SW_Msk = 0x40
	// Bit OTP_STROBE_SW.
	EFUSE_STATUS_OTP_STROBE_SW = 0x40
	// Position of OTP_CSB_SW field.
	EFUSE_STATUS_OTP_CSB_SW_Pos = 0x7
	// Bit mask of OTP_CSB_SW field.
	EFUSE_STATUS_OTP_CSB_SW_Msk = 0x80
	// Bit OTP_CSB_SW.
	EFUSE_STATUS_OTP_CSB_SW = 0x80
	// Position of OTP_PGENB_SW field.
	EFUSE_STATUS_OTP_PGENB_SW_Pos = 0x8
	// Bit mask of OTP_PGENB_SW field.
	EFUSE_STATUS_OTP_PGENB_SW_Msk = 0x100
	// Bit OTP_PGENB_SW.
	EFUSE_STATUS_OTP_PGENB_SW = 0x100
	// Position of OTP_VDDQ_IS_SW field.
	EFUSE_STATUS_OTP_VDDQ_IS_SW_Pos = 0x9
	// Bit mask of OTP_VDDQ_IS_SW field.
	EFUSE_STATUS_OTP_VDDQ_IS_SW_Msk = 0x200
	// Bit OTP_VDDQ_IS_SW.
	EFUSE_STATUS_OTP_VDDQ_IS_SW = 0x200
	// Position of BLK0_VALID_BIT_CNT field.
	EFUSE_STATUS_BLK0_VALID_BIT_CNT_Pos = 0xa
	// Bit mask of BLK0_VALID_BIT_CNT field.
	EFUSE_STATUS_BLK0_VALID_BIT_CNT_Msk = 0xffc00
	// Position of CUR_ECDSA_BLK field.
	EFUSE_STATUS_CUR_ECDSA_BLK_Pos = 0x14
	// Bit mask of CUR_ECDSA_BLK field.
	EFUSE_STATUS_CUR_ECDSA_BLK_Msk = 0xf00000

	// CMD: eFuse command register.
	// Position of READ_CMD field.
	EFUSE_CMD_READ_CMD_Pos = 0x0
	// Bit mask of READ_CMD field.
	EFUSE_CMD_READ_CMD_Msk = 0x1
	// Bit READ_CMD.
	EFUSE_CMD_READ_CMD = 0x1
	// Position of PGM_CMD field.
	EFUSE_CMD_PGM_CMD_Pos = 0x1
	// Bit mask of PGM_CMD field.
	EFUSE_CMD_PGM_CMD_Msk = 0x2
	// Bit PGM_CMD.
	EFUSE_CMD_PGM_CMD = 0x2
	// Position of BLK_NUM field.
	EFUSE_CMD_BLK_NUM_Pos = 0x2
	// Bit mask of BLK_NUM field.
	EFUSE_CMD_BLK_NUM_Msk = 0x3c

	// INT_RAW: eFuse raw interrupt register.
	// Position of READ_DONE_INT_RAW field.
	EFUSE_INT_RAW_READ_DONE_INT_RAW_Pos = 0x0
	// Bit mask of READ_DONE_INT_RAW field.
	EFUSE_INT_RAW_READ_DONE_INT_RAW_Msk = 0x1
	// Bit READ_DONE_INT_RAW.
	EFUSE_INT_RAW_READ_DONE_INT_RAW = 0x1
	// Position of PGM_DONE_INT_RAW field.
	EFUSE_INT_RAW_PGM_DONE_INT_RAW_Pos = 0x1
	// Bit mask of PGM_DONE_INT_RAW field.
	EFUSE_INT_RAW_PGM_DONE_INT_RAW_Msk = 0x2
	// Bit PGM_DONE_INT_RAW.
	EFUSE_INT_RAW_PGM_DONE_INT_RAW = 0x2

	// INT_ST: eFuse interrupt status register.
	// Position of READ_DONE_INT_ST field.
	EFUSE_INT_ST_READ_DONE_INT_ST_Pos = 0x0
	// Bit mask of READ_DONE_INT_ST field.
	EFUSE_INT_ST_READ_DONE_INT_ST_Msk = 0x1
	// Bit READ_DONE_INT_ST.
	EFUSE_INT_ST_READ_DONE_INT_ST = 0x1
	// Position of PGM_DONE_INT_ST field.
	EFUSE_INT_ST_PGM_DONE_INT_ST_Pos = 0x1
	// Bit mask of PGM_DONE_INT_ST field.
	EFUSE_INT_ST_PGM_DONE_INT_ST_Msk = 0x2
	// Bit PGM_DONE_INT_ST.
	EFUSE_INT_ST_PGM_DONE_INT_ST = 0x2

	// INT_ENA: eFuse interrupt enable register.
	// Position of READ_DONE_INT_ENA field.
	EFUSE_INT_ENA_READ_DONE_INT_ENA_Pos = 0x0
	// Bit mask of READ_DONE_INT_ENA field.
	EFUSE_INT_ENA_READ_DONE_INT_ENA_Msk = 0x1
	// Bit READ_DONE_INT_ENA.
	EFUSE_INT_ENA_READ_DONE_INT_ENA = 0x1
	// Position of PGM_DONE_INT_ENA field.
	EFUSE_INT_ENA_PGM_DONE_INT_ENA_Pos = 0x1
	// Bit mask of PGM_DONE_INT_ENA field.
	EFUSE_INT_ENA_PGM_DONE_INT_ENA_Msk = 0x2
	// Bit PGM_DONE_INT_ENA.
	EFUSE_INT_ENA_PGM_DONE_INT_ENA = 0x2

	// INT_CLR: eFuse interrupt clear register.
	// Position of READ_DONE_INT_CLR field.
	EFUSE_INT_CLR_READ_DONE_INT_CLR_Pos = 0x0
	// Bit mask of READ_DONE_INT_CLR field.
	EFUSE_INT_CLR_READ_DONE_INT_CLR_Msk = 0x1
	// Bit READ_DONE_INT_CLR.
	EFUSE_INT_CLR_READ_DONE_INT_CLR = 0x1
	// Position of PGM_DONE_INT_CLR field.
	EFUSE_INT_CLR_PGM_DONE_INT_CLR_Pos = 0x1
	// Bit mask of PGM_DONE_INT_CLR field.
	EFUSE_INT_CLR_PGM_DONE_INT_CLR_Msk = 0x2
	// Bit PGM_DONE_INT_CLR.
	EFUSE_INT_CLR_PGM_DONE_INT_CLR = 0x2

	// DAC_CONF: Controls the eFuse programming voltage.
	// Position of DAC_CLK_DIV field.
	EFUSE_DAC_CONF_DAC_CLK_DIV_Pos = 0x0
	// Bit mask of DAC_CLK_DIV field.
	EFUSE_DAC_CONF_DAC_CLK_DIV_Msk = 0xff
	// Position of DAC_CLK_PAD_SEL field.
	EFUSE_DAC_CONF_DAC_CLK_PAD_SEL_Pos = 0x8
	// Bit mask of DAC_CLK_PAD_SEL field.
	EFUSE_DAC_CONF_DAC_CLK_PAD_SEL_Msk = 0x100
	// Bit DAC_CLK_PAD_SEL.
	EFUSE_DAC_CONF_DAC_CLK_PAD_SEL = 0x100
	// Position of DAC_NUM field.
	EFUSE_DAC_CONF_DAC_NUM_Pos = 0x9
	// Bit mask of DAC_NUM field.
	EFUSE_DAC_CONF_DAC_NUM_Msk = 0x1fe00
	// Position of OE_CLR field.
	EFUSE_DAC_CONF_OE_CLR_Pos = 0x11
	// Bit mask of OE_CLR field.
	EFUSE_DAC_CONF_OE_CLR_Msk = 0x20000
	// Bit OE_CLR.
	EFUSE_DAC_CONF_OE_CLR = 0x20000

	// RD_TIM_CONF: Configures read timing parameters.
	// Position of THR_A field.
	EFUSE_RD_TIM_CONF_THR_A_Pos = 0x0
	// Bit mask of THR_A field.
	EFUSE_RD_TIM_CONF_THR_A_Msk = 0xff
	// Position of TRD field.
	EFUSE_RD_TIM_CONF_TRD_Pos = 0x8
	// Bit mask of TRD field.
	EFUSE_RD_TIM_CONF_TRD_Msk = 0xff00
	// Position of TSUR_A field.
	EFUSE_RD_TIM_CONF_TSUR_A_Pos = 0x10
	// Bit mask of TSUR_A field.
	EFUSE_RD_TIM_CONF_TSUR_A_Msk = 0xff0000
	// Position of READ_INIT_NUM field.
	EFUSE_RD_TIM_CONF_READ_INIT_NUM_Pos = 0x18
	// Bit mask of READ_INIT_NUM field.
	EFUSE_RD_TIM_CONF_READ_INIT_NUM_Msk = 0xff000000

	// WR_TIM_CONF1: Configurarion register 1 of eFuse programming timing parameters.
	// Position of TSUP_A field.
	EFUSE_WR_TIM_CONF1_TSUP_A_Pos = 0x0
	// Bit mask of TSUP_A field.
	EFUSE_WR_TIM_CONF1_TSUP_A_Msk = 0xff
	// Position of PWR_ON_NUM field.
	EFUSE_WR_TIM_CONF1_PWR_ON_NUM_Pos = 0x8
	// Bit mask of PWR_ON_NUM field.
	EFUSE_WR_TIM_CONF1_PWR_ON_NUM_Msk = 0xffff00
	// Position of THP_A field.
	EFUSE_WR_TIM_CONF1_THP_A_Pos = 0x18
	// Bit mask of THP_A field.
	EFUSE_WR_TIM_CONF1_THP_A_Msk = 0xff000000

	// WR_TIM_CONF2: Configurarion register 2 of eFuse programming timing parameters.
	// Position of PWR_OFF_NUM field.
	EFUSE_WR_TIM_CONF2_PWR_OFF_NUM_Pos = 0x0
	// Bit mask of PWR_OFF_NUM field.
	EFUSE_WR_TIM_CONF2_PWR_OFF_NUM_Msk = 0xffff
	// Position of TPGM field.
	EFUSE_WR_TIM_CONF2_TPGM_Pos = 0x10
	// Bit mask of TPGM field.
	EFUSE_WR_TIM_CONF2_TPGM_Msk = 0xffff0000

	// WR_TIM_CONF0_RS_BYPASS: Configurarion register0 of eFuse programming time parameters and rs bypass operation.
	// Position of BYPASS_RS_CORRECTION field.
	EFUSE_WR_TIM_CONF0_RS_BYPASS_BYPASS_RS_CORRECTION_Pos = 0x0
	// Bit mask of BYPASS_RS_CORRECTION field.
	EFUSE_WR_TIM_CONF0_RS_BYPASS_BYPASS_RS_CORRECTION_Msk = 0x1
	// Bit BYPASS_RS_CORRECTION.
	EFUSE_WR_TIM_CONF0_RS_BYPASS_BYPASS_RS_CORRECTION = 0x1
	// Position of BYPASS_RS_BLK_NUM field.
	EFUSE_WR_TIM_CONF0_RS_BYPASS_BYPASS_RS_BLK_NUM_Pos = 0x1
	// Bit mask of BYPASS_RS_BLK_NUM field.
	EFUSE_WR_TIM_CONF0_RS_BYPASS_BYPASS_RS_BLK_NUM_Msk = 0xffe
	// Position of UPDATE field.
	EFUSE_WR_TIM_CONF0_RS_BYPASS_UPDATE_Pos = 0xc
	// Bit mask of UPDATE field.
	EFUSE_WR_TIM_CONF0_RS_BYPASS_UPDATE_Msk = 0x1000
	// Bit UPDATE.
	EFUSE_WR_TIM_CONF0_RS_BYPASS_UPDATE = 0x1000
	// Position of TPGM_INACTIVE field.
	EFUSE_WR_TIM_CONF0_RS_BYPASS_TPGM_INACTIVE_Pos = 0xd
	// Bit mask of TPGM_INACTIVE field.
	EFUSE_WR_TIM_CONF0_RS_BYPASS_TPGM_INACTIVE_Msk = 0x1fe000

	// DATE: eFuse version register.
	// Position of DATE field.
	EFUSE_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	EFUSE_DATE_DATE_Msk = 0xfffffff
)

// Constants for GPIO: General Purpose Input/Output
const (
	// BT_SELECT: GPIO bit select register
	// Position of BT_SEL field.
	GPIO_BT_SELECT_BT_SEL_Pos = 0x0
	// Bit mask of BT_SEL field.
	GPIO_BT_SELECT_BT_SEL_Msk = 0xffffffff

	// OUT: GPIO output register for GPIO0-31
	// Position of DATA_ORIG field.
	GPIO_OUT_DATA_ORIG_Pos = 0x0
	// Bit mask of DATA_ORIG field.
	GPIO_OUT_DATA_ORIG_Msk = 0xffffffff

	// OUT_W1TS: GPIO output set register for GPIO0-31
	// Position of OUT_W1TS field.
	GPIO_OUT_W1TS_OUT_W1TS_Pos = 0x0
	// Bit mask of OUT_W1TS field.
	GPIO_OUT_W1TS_OUT_W1TS_Msk = 0xffffffff

	// OUT_W1TC: GPIO output clear register for GPIO0-31
	// Position of OUT_W1TC field.
	GPIO_OUT_W1TC_OUT_W1TC_Pos = 0x0
	// Bit mask of OUT_W1TC field.
	GPIO_OUT_W1TC_OUT_W1TC_Msk = 0xffffffff

	// SDIO_SELECT: GPIO sdio select register
	// Position of SDIO_SEL field.
	GPIO_SDIO_SELECT_SDIO_SEL_Pos = 0x0
	// Bit mask of SDIO_SEL field.
	GPIO_SDIO_SELECT_SDIO_SEL_Msk = 0xff

	// ENABLE: GPIO output enable register for GPIO0-31
	// Position of DATA field.
	GPIO_ENABLE_DATA_Pos = 0x0
	// Bit mask of DATA field.
	GPIO_ENABLE_DATA_Msk = 0xffffffff

	// ENABLE_W1TS: GPIO output enable set register for GPIO0-31
	// Position of ENABLE_W1TS field.
	GPIO_ENABLE_W1TS_ENABLE_W1TS_Pos = 0x0
	// Bit mask of ENABLE_W1TS field.
	GPIO_ENABLE_W1TS_ENABLE_W1TS_Msk = 0xffffffff

	// ENABLE_W1TC: GPIO output enable clear register for GPIO0-31
	// Position of ENABLE_W1TC field.
	GPIO_ENABLE_W1TC_ENABLE_W1TC_Pos = 0x0
	// Bit mask of ENABLE_W1TC field.
	GPIO_ENABLE_W1TC_ENABLE_W1TC_Msk = 0xffffffff

	// STRAP: pad strapping register
	// Position of STRAPPING field.
	GPIO_STRAP_STRAPPING_Pos = 0x0
	// Bit mask of STRAPPING field.
	GPIO_STRAP_STRAPPING_Msk = 0xffff

	// IN: GPIO input register for GPIO0-31
	// Position of DATA_NEXT field.
	GPIO_IN_DATA_NEXT_Pos = 0x0
	// Bit mask of DATA_NEXT field.
	GPIO_IN_DATA_NEXT_Msk = 0xffffffff

	// STATUS: GPIO interrupt status register for GPIO0-31
	// Position of INTERRUPT field.
	GPIO_STATUS_INTERRUPT_Pos = 0x0
	// Bit mask of INTERRUPT field.
	GPIO_STATUS_INTERRUPT_Msk = 0xffffffff

	// STATUS_W1TS: GPIO interrupt status set register for GPIO0-31
	// Position of STATUS_W1TS field.
	GPIO_STATUS_W1TS_STATUS_W1TS_Pos = 0x0
	// Bit mask of STATUS_W1TS field.
	GPIO_STATUS_W1TS_STATUS_W1TS_Msk = 0xffffffff

	// STATUS_W1TC: GPIO interrupt status clear register for GPIO0-31
	// Position of STATUS_W1TC field.
	GPIO_STATUS_W1TC_STATUS_W1TC_Pos = 0x0
	// Bit mask of STATUS_W1TC field.
	GPIO_STATUS_W1TC_STATUS_W1TC_Msk = 0xffffffff

	// PCPU_INT: GPIO PRO_CPU interrupt status register for GPIO0-31
	// Position of PROCPU_INT field.
	GPIO_PCPU_INT_PROCPU_INT_Pos = 0x0
	// Bit mask of PROCPU_INT field.
	GPIO_PCPU_INT_PROCPU_INT_Msk = 0xffffffff

	// PCPU_NMI_INT: GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-31
	// Position of PROCPU_NMI_INT field.
	GPIO_PCPU_NMI_INT_PROCPU_NMI_INT_Pos = 0x0
	// Bit mask of PROCPU_NMI_INT field.
	GPIO_PCPU_NMI_INT_PROCPU_NMI_INT_Msk = 0xffffffff

	// CPUSDIO_INT: GPIO CPUSDIO interrupt status register for GPIO0-31
	// Position of SDIO_INT field.
	GPIO_CPUSDIO_INT_SDIO_INT_Pos = 0x0
	// Bit mask of SDIO_INT field.
	GPIO_CPUSDIO_INT_SDIO_INT_Msk = 0xffffffff

	// PIN0: GPIO pin configuration register
	// Position of SYNC2_BYPASS field.
	GPIO_PIN_SYNC2_BYPASS_Pos = 0x0
	// Bit mask of SYNC2_BYPASS field.
	GPIO_PIN_SYNC2_BYPASS_Msk = 0x3
	// Position of PAD_DRIVER field.
	GPIO_PIN_PAD_DRIVER_Pos = 0x2
	// Bit mask of PAD_DRIVER field.
	GPIO_PIN_PAD_DRIVER_Msk = 0x4
	// Bit PAD_DRIVER.
	GPIO_PIN_PAD_DRIVER = 0x4
	// Position of SYNC1_BYPASS field.
	GPIO_PIN_SYNC1_BYPASS_Pos = 0x3
	// Bit mask of SYNC1_BYPASS field.
	GPIO_PIN_SYNC1_BYPASS_Msk = 0x18
	// Position of INT_TYPE field.
	GPIO_PIN_INT_TYPE_Pos = 0x7
	// Bit mask of INT_TYPE field.
	GPIO_PIN_INT_TYPE_Msk = 0x380
	// Position of WAKEUP_ENABLE field.
	GPIO_PIN_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of WAKEUP_ENABLE field.
	GPIO_PIN_WAKEUP_ENABLE_Msk = 0x400
	// Bit WAKEUP_ENABLE.
	GPIO_PIN_WAKEUP_ENABLE = 0x400
	// Position of CONFIG field.
	GPIO_PIN_CONFIG_Pos = 0xb
	// Bit mask of CONFIG field.
	GPIO_PIN_CONFIG_Msk = 0x1800
	// Position of INT_ENA field.
	GPIO_PIN_INT_ENA_Pos = 0xd
	// Bit mask of INT_ENA field.
	GPIO_PIN_INT_ENA_Msk = 0x3e000

	// STATUS_NEXT: GPIO interrupt source register for GPIO0-31
	// Position of STATUS_INTERRUPT_NEXT field.
	GPIO_STATUS_NEXT_STATUS_INTERRUPT_NEXT_Pos = 0x0
	// Bit mask of STATUS_INTERRUPT_NEXT field.
	GPIO_STATUS_NEXT_STATUS_INTERRUPT_NEXT_Msk = 0xffffffff

	// FUNC0_IN_SEL_CFG: GPIO input function configuration register
	// Position of IN_SEL field.
	GPIO_FUNC_IN_SEL_CFG_IN_SEL_Pos = 0x0
	// Bit mask of IN_SEL field.
	GPIO_FUNC_IN_SEL_CFG_IN_SEL_Msk = 0x3f
	// Position of IN_INV_SEL field.
	GPIO_FUNC_IN_SEL_CFG_IN_INV_SEL_Pos = 0x6
	// Bit mask of IN_INV_SEL field.
	GPIO_FUNC_IN_SEL_CFG_IN_INV_SEL_Msk = 0x40
	// Bit IN_INV_SEL.
	GPIO_FUNC_IN_SEL_CFG_IN_INV_SEL = 0x40
	// Position of SEL field.
	GPIO_FUNC_IN_SEL_CFG_SEL_Pos = 0x7
	// Bit mask of SEL field.
	GPIO_FUNC_IN_SEL_CFG_SEL_Msk = 0x80
	// Bit SEL.
	GPIO_FUNC_IN_SEL_CFG_SEL = 0x80

	// FUNC0_OUT_SEL_CFG: GPIO output function select register
	// Position of OUT_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_OUT_SEL_Pos = 0x0
	// Bit mask of OUT_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_OUT_SEL_Msk = 0xff
	// Position of INV_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_INV_SEL_Pos = 0x8
	// Bit mask of INV_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_INV_SEL_Msk = 0x100
	// Bit INV_SEL.
	GPIO_FUNC_OUT_SEL_CFG_INV_SEL = 0x100
	// Position of OEN_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_OEN_SEL_Pos = 0x9
	// Bit mask of OEN_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_OEN_SEL_Msk = 0x200
	// Bit OEN_SEL.
	GPIO_FUNC_OUT_SEL_CFG_OEN_SEL = 0x200
	// Position of OEN_INV_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_OEN_INV_SEL_Pos = 0xa
	// Bit mask of OEN_INV_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_OEN_INV_SEL_Msk = 0x400
	// Bit OEN_INV_SEL.
	GPIO_FUNC_OUT_SEL_CFG_OEN_INV_SEL = 0x400

	// CLOCK_GATE: GPIO clock gate register
	// Position of CLK_EN field.
	GPIO_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	GPIO_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	GPIO_CLOCK_GATE_CLK_EN = 0x1

	// DATE: GPIO version register
	// Position of DATE field.
	GPIO_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	GPIO_DATE_DATE_Msk = 0xfffffff
)

// Constants for GPIO_SD: Sigma-Delta Modulation
const (
	// SIGMADELTA0: Duty Cycle Configure Register of SDM%s
	// Position of SD_IN field.
	GPIOSD_SIGMADELTA_SD_IN_Pos = 0x0
	// Bit mask of SD_IN field.
	GPIOSD_SIGMADELTA_SD_IN_Msk = 0xff
	// Position of SD_PRESCALE field.
	GPIOSD_SIGMADELTA_SD_PRESCALE_Pos = 0x8
	// Bit mask of SD_PRESCALE field.
	GPIOSD_SIGMADELTA_SD_PRESCALE_Msk = 0xff00

	// CLOCK_GATE: Clock Gating Configure Register
	// Position of CLK_EN field.
	GPIOSD_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	GPIOSD_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	GPIOSD_CLOCK_GATE_CLK_EN = 0x1

	// SIGMADELTA_MISC: MISC Register
	// Position of FUNCTION_CLK_EN field.
	GPIOSD_SIGMADELTA_MISC_FUNCTION_CLK_EN_Pos = 0x1e
	// Bit mask of FUNCTION_CLK_EN field.
	GPIOSD_SIGMADELTA_MISC_FUNCTION_CLK_EN_Msk = 0x40000000
	// Bit FUNCTION_CLK_EN.
	GPIOSD_SIGMADELTA_MISC_FUNCTION_CLK_EN = 0x40000000
	// Position of SPI_SWAP field.
	GPIOSD_SIGMADELTA_MISC_SPI_SWAP_Pos = 0x1f
	// Bit mask of SPI_SWAP field.
	GPIOSD_SIGMADELTA_MISC_SPI_SWAP_Msk = 0x80000000
	// Bit SPI_SWAP.
	GPIOSD_SIGMADELTA_MISC_SPI_SWAP = 0x80000000

	// PAD_COMP_CONFIG: PAD Compare configure Register
	// Position of XPD_COMP field.
	GPIOSD_PAD_COMP_CONFIG_XPD_COMP_Pos = 0x0
	// Bit mask of XPD_COMP field.
	GPIOSD_PAD_COMP_CONFIG_XPD_COMP_Msk = 0x1
	// Bit XPD_COMP.
	GPIOSD_PAD_COMP_CONFIG_XPD_COMP = 0x1
	// Position of MODE_COMP field.
	GPIOSD_PAD_COMP_CONFIG_MODE_COMP_Pos = 0x1
	// Bit mask of MODE_COMP field.
	GPIOSD_PAD_COMP_CONFIG_MODE_COMP_Msk = 0x2
	// Bit MODE_COMP.
	GPIOSD_PAD_COMP_CONFIG_MODE_COMP = 0x2
	// Position of DREF_COMP field.
	GPIOSD_PAD_COMP_CONFIG_DREF_COMP_Pos = 0x2
	// Bit mask of DREF_COMP field.
	GPIOSD_PAD_COMP_CONFIG_DREF_COMP_Msk = 0x1c
	// Position of ZERO_DET_MODE field.
	GPIOSD_PAD_COMP_CONFIG_ZERO_DET_MODE_Pos = 0x5
	// Bit mask of ZERO_DET_MODE field.
	GPIOSD_PAD_COMP_CONFIG_ZERO_DET_MODE_Msk = 0x60

	// PAD_COMP_FILTER: Zero Detect filter Register
	// Position of ZERO_DET_FILTER_CNT field.
	GPIOSD_PAD_COMP_FILTER_ZERO_DET_FILTER_CNT_Pos = 0x0
	// Bit mask of ZERO_DET_FILTER_CNT field.
	GPIOSD_PAD_COMP_FILTER_ZERO_DET_FILTER_CNT_Msk = 0xffffffff

	// GLITCH_FILTER_CH0: Glitch Filter Configure Register of Channel%s
	// Position of FILTER_CH0_EN field.
	GPIOSD_GLITCH_FILTER_CH_FILTER_CH0_EN_Pos = 0x0
	// Bit mask of FILTER_CH0_EN field.
	GPIOSD_GLITCH_FILTER_CH_FILTER_CH0_EN_Msk = 0x1
	// Bit FILTER_CH0_EN.
	GPIOSD_GLITCH_FILTER_CH_FILTER_CH0_EN = 0x1
	// Position of FILTER_CH0_INPUT_IO_NUM field.
	GPIOSD_GLITCH_FILTER_CH_FILTER_CH0_INPUT_IO_NUM_Pos = 0x1
	// Bit mask of FILTER_CH0_INPUT_IO_NUM field.
	GPIOSD_GLITCH_FILTER_CH_FILTER_CH0_INPUT_IO_NUM_Msk = 0x7e
	// Position of FILTER_CH0_WINDOW_THRES field.
	GPIOSD_GLITCH_FILTER_CH_FILTER_CH0_WINDOW_THRES_Pos = 0x7
	// Bit mask of FILTER_CH0_WINDOW_THRES field.
	GPIOSD_GLITCH_FILTER_CH_FILTER_CH0_WINDOW_THRES_Msk = 0x1f80
	// Position of FILTER_CH0_WINDOW_WIDTH field.
	GPIOSD_GLITCH_FILTER_CH_FILTER_CH0_WINDOW_WIDTH_Pos = 0xd
	// Bit mask of FILTER_CH0_WINDOW_WIDTH field.
	GPIOSD_GLITCH_FILTER_CH_FILTER_CH0_WINDOW_WIDTH_Msk = 0x7e000

	// ETM_EVENT_CH0_CFG: Etm Config register of Channel%s
	// Position of ETM_CH0_EVENT_SEL field.
	GPIOSD_ETM_EVENT_CH_CFG_ETM_CH0_EVENT_SEL_Pos = 0x0
	// Bit mask of ETM_CH0_EVENT_SEL field.
	GPIOSD_ETM_EVENT_CH_CFG_ETM_CH0_EVENT_SEL_Msk = 0x1f
	// Position of ETM_CH0_EVENT_EN field.
	GPIOSD_ETM_EVENT_CH_CFG_ETM_CH0_EVENT_EN_Pos = 0x7
	// Bit mask of ETM_CH0_EVENT_EN field.
	GPIOSD_ETM_EVENT_CH_CFG_ETM_CH0_EVENT_EN_Msk = 0x80
	// Bit ETM_CH0_EVENT_EN.
	GPIOSD_ETM_EVENT_CH_CFG_ETM_CH0_EVENT_EN = 0x80

	// ETM_TASK_P0_CFG: Etm Configure Register to decide which GPIO been chosen
	// Position of ETM_TASK_GPIO0_EN field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO0_EN_Pos = 0x0
	// Bit mask of ETM_TASK_GPIO0_EN field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO0_EN_Msk = 0x1
	// Bit ETM_TASK_GPIO0_EN.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO0_EN = 0x1
	// Position of ETM_TASK_GPIO0_SEL field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO0_SEL_Pos = 0x1
	// Bit mask of ETM_TASK_GPIO0_SEL field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO0_SEL_Msk = 0xe
	// Position of ETM_TASK_GPIO1_EN field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO1_EN_Pos = 0x8
	// Bit mask of ETM_TASK_GPIO1_EN field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO1_EN_Msk = 0x100
	// Bit ETM_TASK_GPIO1_EN.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO1_EN = 0x100
	// Position of ETM_TASK_GPIO1_SEL field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO1_SEL_Pos = 0x9
	// Bit mask of ETM_TASK_GPIO1_SEL field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO1_SEL_Msk = 0xe00
	// Position of ETM_TASK_GPIO2_EN field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO2_EN_Pos = 0x10
	// Bit mask of ETM_TASK_GPIO2_EN field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO2_EN_Msk = 0x10000
	// Bit ETM_TASK_GPIO2_EN.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO2_EN = 0x10000
	// Position of ETM_TASK_GPIO2_SEL field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO2_SEL_Pos = 0x11
	// Bit mask of ETM_TASK_GPIO2_SEL field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO2_SEL_Msk = 0xe0000
	// Position of ETM_TASK_GPIO3_EN field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO3_EN_Pos = 0x18
	// Bit mask of ETM_TASK_GPIO3_EN field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO3_EN_Msk = 0x1000000
	// Bit ETM_TASK_GPIO3_EN.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO3_EN = 0x1000000
	// Position of ETM_TASK_GPIO3_SEL field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO3_SEL_Pos = 0x19
	// Bit mask of ETM_TASK_GPIO3_SEL field.
	GPIOSD_ETM_TASK_P0_CFG_ETM_TASK_GPIO3_SEL_Msk = 0xe000000

	// ETM_TASK_P1_CFG: Etm Configure Register to decide which GPIO been chosen
	// Position of ETM_TASK_GPIO4_EN field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO4_EN_Pos = 0x0
	// Bit mask of ETM_TASK_GPIO4_EN field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO4_EN_Msk = 0x1
	// Bit ETM_TASK_GPIO4_EN.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO4_EN = 0x1
	// Position of ETM_TASK_GPIO4_SEL field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO4_SEL_Pos = 0x1
	// Bit mask of ETM_TASK_GPIO4_SEL field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO4_SEL_Msk = 0xe
	// Position of ETM_TASK_GPIO5_EN field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO5_EN_Pos = 0x8
	// Bit mask of ETM_TASK_GPIO5_EN field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO5_EN_Msk = 0x100
	// Bit ETM_TASK_GPIO5_EN.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO5_EN = 0x100
	// Position of ETM_TASK_GPIO5_SEL field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO5_SEL_Pos = 0x9
	// Bit mask of ETM_TASK_GPIO5_SEL field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO5_SEL_Msk = 0xe00
	// Position of ETM_TASK_GPIO6_EN field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO6_EN_Pos = 0x10
	// Bit mask of ETM_TASK_GPIO6_EN field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO6_EN_Msk = 0x10000
	// Bit ETM_TASK_GPIO6_EN.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO6_EN = 0x10000
	// Position of ETM_TASK_GPIO6_SEL field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO6_SEL_Pos = 0x11
	// Bit mask of ETM_TASK_GPIO6_SEL field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO6_SEL_Msk = 0xe0000
	// Position of ETM_TASK_GPIO7_EN field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO7_EN_Pos = 0x18
	// Bit mask of ETM_TASK_GPIO7_EN field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO7_EN_Msk = 0x1000000
	// Bit ETM_TASK_GPIO7_EN.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO7_EN = 0x1000000
	// Position of ETM_TASK_GPIO7_SEL field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO7_SEL_Pos = 0x19
	// Bit mask of ETM_TASK_GPIO7_SEL field.
	GPIOSD_ETM_TASK_P1_CFG_ETM_TASK_GPIO7_SEL_Msk = 0xe000000

	// ETM_TASK_P2_CFG: Etm Configure Register to decide which GPIO been chosen
	// Position of ETM_TASK_GPIO8_EN field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO8_EN_Pos = 0x0
	// Bit mask of ETM_TASK_GPIO8_EN field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO8_EN_Msk = 0x1
	// Bit ETM_TASK_GPIO8_EN.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO8_EN = 0x1
	// Position of ETM_TASK_GPIO8_SEL field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO8_SEL_Pos = 0x1
	// Bit mask of ETM_TASK_GPIO8_SEL field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO8_SEL_Msk = 0xe
	// Position of ETM_TASK_GPIO9_EN field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO9_EN_Pos = 0x8
	// Bit mask of ETM_TASK_GPIO9_EN field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO9_EN_Msk = 0x100
	// Bit ETM_TASK_GPIO9_EN.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO9_EN = 0x100
	// Position of ETM_TASK_GPIO9_SEL field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO9_SEL_Pos = 0x9
	// Bit mask of ETM_TASK_GPIO9_SEL field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO9_SEL_Msk = 0xe00
	// Position of ETM_TASK_GPIO10_EN field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO10_EN_Pos = 0x10
	// Bit mask of ETM_TASK_GPIO10_EN field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO10_EN_Msk = 0x10000
	// Bit ETM_TASK_GPIO10_EN.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO10_EN = 0x10000
	// Position of ETM_TASK_GPIO10_SEL field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO10_SEL_Pos = 0x11
	// Bit mask of ETM_TASK_GPIO10_SEL field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO10_SEL_Msk = 0xe0000
	// Position of ETM_TASK_GPIO11_EN field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO11_EN_Pos = 0x18
	// Bit mask of ETM_TASK_GPIO11_EN field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO11_EN_Msk = 0x1000000
	// Bit ETM_TASK_GPIO11_EN.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO11_EN = 0x1000000
	// Position of ETM_TASK_GPIO11_SEL field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO11_SEL_Pos = 0x19
	// Bit mask of ETM_TASK_GPIO11_SEL field.
	GPIOSD_ETM_TASK_P2_CFG_ETM_TASK_GPIO11_SEL_Msk = 0xe000000

	// ETM_TASK_P3_CFG: Etm Configure Register to decide which GPIO been chosen
	// Position of ETM_TASK_GPIO12_EN field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO12_EN_Pos = 0x0
	// Bit mask of ETM_TASK_GPIO12_EN field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO12_EN_Msk = 0x1
	// Bit ETM_TASK_GPIO12_EN.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO12_EN = 0x1
	// Position of ETM_TASK_GPIO12_SEL field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO12_SEL_Pos = 0x1
	// Bit mask of ETM_TASK_GPIO12_SEL field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO12_SEL_Msk = 0xe
	// Position of ETM_TASK_GPIO13_EN field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO13_EN_Pos = 0x8
	// Bit mask of ETM_TASK_GPIO13_EN field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO13_EN_Msk = 0x100
	// Bit ETM_TASK_GPIO13_EN.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO13_EN = 0x100
	// Position of ETM_TASK_GPIO13_SEL field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO13_SEL_Pos = 0x9
	// Bit mask of ETM_TASK_GPIO13_SEL field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO13_SEL_Msk = 0xe00
	// Position of ETM_TASK_GPIO14_EN field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO14_EN_Pos = 0x10
	// Bit mask of ETM_TASK_GPIO14_EN field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO14_EN_Msk = 0x10000
	// Bit ETM_TASK_GPIO14_EN.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO14_EN = 0x10000
	// Position of ETM_TASK_GPIO14_SEL field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO14_SEL_Pos = 0x11
	// Bit mask of ETM_TASK_GPIO14_SEL field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO14_SEL_Msk = 0xe0000
	// Position of ETM_TASK_GPIO15_EN field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO15_EN_Pos = 0x18
	// Bit mask of ETM_TASK_GPIO15_EN field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO15_EN_Msk = 0x1000000
	// Bit ETM_TASK_GPIO15_EN.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO15_EN = 0x1000000
	// Position of ETM_TASK_GPIO15_SEL field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO15_SEL_Pos = 0x19
	// Bit mask of ETM_TASK_GPIO15_SEL field.
	GPIOSD_ETM_TASK_P3_CFG_ETM_TASK_GPIO15_SEL_Msk = 0xe000000

	// ETM_TASK_P4_CFG: Etm Configure Register to decide which GPIO been chosen
	// Position of ETM_TASK_GPIO16_EN field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO16_EN_Pos = 0x0
	// Bit mask of ETM_TASK_GPIO16_EN field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO16_EN_Msk = 0x1
	// Bit ETM_TASK_GPIO16_EN.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO16_EN = 0x1
	// Position of ETM_TASK_GPIO16_SEL field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO16_SEL_Pos = 0x1
	// Bit mask of ETM_TASK_GPIO16_SEL field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO16_SEL_Msk = 0xe
	// Position of ETM_TASK_GPIO17_EN field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO17_EN_Pos = 0x8
	// Bit mask of ETM_TASK_GPIO17_EN field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO17_EN_Msk = 0x100
	// Bit ETM_TASK_GPIO17_EN.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO17_EN = 0x100
	// Position of ETM_TASK_GPIO17_SEL field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO17_SEL_Pos = 0x9
	// Bit mask of ETM_TASK_GPIO17_SEL field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO17_SEL_Msk = 0xe00
	// Position of ETM_TASK_GPIO18_EN field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO18_EN_Pos = 0x10
	// Bit mask of ETM_TASK_GPIO18_EN field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO18_EN_Msk = 0x10000
	// Bit ETM_TASK_GPIO18_EN.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO18_EN = 0x10000
	// Position of ETM_TASK_GPIO18_SEL field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO18_SEL_Pos = 0x11
	// Bit mask of ETM_TASK_GPIO18_SEL field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO18_SEL_Msk = 0xe0000
	// Position of ETM_TASK_GPIO19_EN field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO19_EN_Pos = 0x18
	// Bit mask of ETM_TASK_GPIO19_EN field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO19_EN_Msk = 0x1000000
	// Bit ETM_TASK_GPIO19_EN.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO19_EN = 0x1000000
	// Position of ETM_TASK_GPIO19_SEL field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO19_SEL_Pos = 0x19
	// Bit mask of ETM_TASK_GPIO19_SEL field.
	GPIOSD_ETM_TASK_P4_CFG_ETM_TASK_GPIO19_SEL_Msk = 0xe000000

	// ETM_TASK_P5_CFG: Etm Configure Register to decide which GPIO been chosen
	// Position of ETM_TASK_GPIO20_EN field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO20_EN_Pos = 0x0
	// Bit mask of ETM_TASK_GPIO20_EN field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO20_EN_Msk = 0x1
	// Bit ETM_TASK_GPIO20_EN.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO20_EN = 0x1
	// Position of ETM_TASK_GPIO20_SEL field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO20_SEL_Pos = 0x1
	// Bit mask of ETM_TASK_GPIO20_SEL field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO20_SEL_Msk = 0xe
	// Position of ETM_TASK_GPIO21_EN field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO21_EN_Pos = 0x8
	// Bit mask of ETM_TASK_GPIO21_EN field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO21_EN_Msk = 0x100
	// Bit ETM_TASK_GPIO21_EN.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO21_EN = 0x100
	// Position of ETM_TASK_GPIO21_SEL field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO21_SEL_Pos = 0x9
	// Bit mask of ETM_TASK_GPIO21_SEL field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO21_SEL_Msk = 0xe00
	// Position of ETM_TASK_GPIO22_EN field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO22_EN_Pos = 0x10
	// Bit mask of ETM_TASK_GPIO22_EN field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO22_EN_Msk = 0x10000
	// Bit ETM_TASK_GPIO22_EN.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO22_EN = 0x10000
	// Position of ETM_TASK_GPIO22_SEL field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO22_SEL_Pos = 0x11
	// Bit mask of ETM_TASK_GPIO22_SEL field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO22_SEL_Msk = 0xe0000
	// Position of ETM_TASK_GPIO23_EN field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO23_EN_Pos = 0x18
	// Bit mask of ETM_TASK_GPIO23_EN field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO23_EN_Msk = 0x1000000
	// Bit ETM_TASK_GPIO23_EN.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO23_EN = 0x1000000
	// Position of ETM_TASK_GPIO23_SEL field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO23_SEL_Pos = 0x19
	// Bit mask of ETM_TASK_GPIO23_SEL field.
	GPIOSD_ETM_TASK_P5_CFG_ETM_TASK_GPIO23_SEL_Msk = 0xe000000

	// ETM_TASK_P6_CFG: Etm Configure Register to decide which GPIO been chosen
	// Position of ETM_TASK_GPIO24_EN field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO24_EN_Pos = 0x0
	// Bit mask of ETM_TASK_GPIO24_EN field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO24_EN_Msk = 0x1
	// Bit ETM_TASK_GPIO24_EN.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO24_EN = 0x1
	// Position of ETM_TASK_GPIO24_SEL field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO24_SEL_Pos = 0x1
	// Bit mask of ETM_TASK_GPIO24_SEL field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO24_SEL_Msk = 0xe
	// Position of ETM_TASK_GPIO25_EN field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO25_EN_Pos = 0x8
	// Bit mask of ETM_TASK_GPIO25_EN field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO25_EN_Msk = 0x100
	// Bit ETM_TASK_GPIO25_EN.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO25_EN = 0x100
	// Position of ETM_TASK_GPIO25_SEL field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO25_SEL_Pos = 0x9
	// Bit mask of ETM_TASK_GPIO25_SEL field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO25_SEL_Msk = 0xe00
	// Position of ETM_TASK_GPIO26_EN field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO26_EN_Pos = 0x10
	// Bit mask of ETM_TASK_GPIO26_EN field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO26_EN_Msk = 0x10000
	// Bit ETM_TASK_GPIO26_EN.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO26_EN = 0x10000
	// Position of ETM_TASK_GPIO26_SEL field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO26_SEL_Pos = 0x11
	// Bit mask of ETM_TASK_GPIO26_SEL field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO26_SEL_Msk = 0xe0000
	// Position of ETM_TASK_GPIO27_EN field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO27_EN_Pos = 0x18
	// Bit mask of ETM_TASK_GPIO27_EN field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO27_EN_Msk = 0x1000000
	// Bit ETM_TASK_GPIO27_EN.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO27_EN = 0x1000000
	// Position of ETM_TASK_GPIO27_SEL field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO27_SEL_Pos = 0x19
	// Bit mask of ETM_TASK_GPIO27_SEL field.
	GPIOSD_ETM_TASK_P6_CFG_ETM_TASK_GPIO27_SEL_Msk = 0xe000000

	// INT_RAW: GPIOSD interrupt raw register
	// Position of PAD_COMP_INT_RAW field.
	GPIOSD_INT_RAW_PAD_COMP_INT_RAW_Pos = 0x0
	// Bit mask of PAD_COMP_INT_RAW field.
	GPIOSD_INT_RAW_PAD_COMP_INT_RAW_Msk = 0x1
	// Bit PAD_COMP_INT_RAW.
	GPIOSD_INT_RAW_PAD_COMP_INT_RAW = 0x1

	// INT_ST: GPIOSD interrupt masked register
	// Position of PAD_COMP_INT_ST field.
	GPIOSD_INT_ST_PAD_COMP_INT_ST_Pos = 0x0
	// Bit mask of PAD_COMP_INT_ST field.
	GPIOSD_INT_ST_PAD_COMP_INT_ST_Msk = 0x1
	// Bit PAD_COMP_INT_ST.
	GPIOSD_INT_ST_PAD_COMP_INT_ST = 0x1

	// INT_ENA: GPIOSD interrupt enable register
	// Position of PAD_COMP_INT_ENA field.
	GPIOSD_INT_ENA_PAD_COMP_INT_ENA_Pos = 0x0
	// Bit mask of PAD_COMP_INT_ENA field.
	GPIOSD_INT_ENA_PAD_COMP_INT_ENA_Msk = 0x1
	// Bit PAD_COMP_INT_ENA.
	GPIOSD_INT_ENA_PAD_COMP_INT_ENA = 0x1

	// INT_CLR: GPIOSD interrupt clear register
	// Position of PAD_COMP_INT_CLR field.
	GPIOSD_INT_CLR_PAD_COMP_INT_CLR_Pos = 0x0
	// Bit mask of PAD_COMP_INT_CLR field.
	GPIOSD_INT_CLR_PAD_COMP_INT_CLR_Msk = 0x1
	// Bit PAD_COMP_INT_CLR.
	GPIOSD_INT_CLR_PAD_COMP_INT_CLR = 0x1

	// VERSION: Version Control Register
	// Position of GPIO_SD_DATE field.
	GPIOSD_VERSION_GPIO_SD_DATE_Pos = 0x0
	// Bit mask of GPIO_SD_DATE field.
	GPIOSD_VERSION_GPIO_SD_DATE_Msk = 0xfffffff
)

// Constants for HMAC: HMAC (Hash-based Message Authentication Code) Accelerator
const (
	// SET_START: Process control register 0.
	// Position of SET_START field.
	HMAC_SET_START_SET_START_Pos = 0x0
	// Bit mask of SET_START field.
	HMAC_SET_START_SET_START_Msk = 0x1
	// Bit SET_START.
	HMAC_SET_START_SET_START = 0x1

	// SET_PARA_PURPOSE: Configure purpose.
	// Position of PURPOSE_SET field.
	HMAC_SET_PARA_PURPOSE_PURPOSE_SET_Pos = 0x0
	// Bit mask of PURPOSE_SET field.
	HMAC_SET_PARA_PURPOSE_PURPOSE_SET_Msk = 0xf

	// SET_PARA_KEY: Configure key.
	// Position of KEY_SET field.
	HMAC_SET_PARA_KEY_KEY_SET_Pos = 0x0
	// Bit mask of KEY_SET field.
	HMAC_SET_PARA_KEY_KEY_SET_Msk = 0x7

	// SET_PARA_FINISH: Finish initial configuration.
	// Position of SET_PARA_END field.
	HMAC_SET_PARA_FINISH_SET_PARA_END_Pos = 0x0
	// Bit mask of SET_PARA_END field.
	HMAC_SET_PARA_FINISH_SET_PARA_END_Msk = 0x1
	// Bit SET_PARA_END.
	HMAC_SET_PARA_FINISH_SET_PARA_END = 0x1

	// SET_MESSAGE_ONE: Process control register 1.
	// Position of SET_TEXT_ONE field.
	HMAC_SET_MESSAGE_ONE_SET_TEXT_ONE_Pos = 0x0
	// Bit mask of SET_TEXT_ONE field.
	HMAC_SET_MESSAGE_ONE_SET_TEXT_ONE_Msk = 0x1
	// Bit SET_TEXT_ONE.
	HMAC_SET_MESSAGE_ONE_SET_TEXT_ONE = 0x1

	// SET_MESSAGE_ING: Process control register 2.
	// Position of SET_TEXT_ING field.
	HMAC_SET_MESSAGE_ING_SET_TEXT_ING_Pos = 0x0
	// Bit mask of SET_TEXT_ING field.
	HMAC_SET_MESSAGE_ING_SET_TEXT_ING_Msk = 0x1
	// Bit SET_TEXT_ING.
	HMAC_SET_MESSAGE_ING_SET_TEXT_ING = 0x1

	// SET_MESSAGE_END: Process control register 3.
	// Position of SET_TEXT_END field.
	HMAC_SET_MESSAGE_END_SET_TEXT_END_Pos = 0x0
	// Bit mask of SET_TEXT_END field.
	HMAC_SET_MESSAGE_END_SET_TEXT_END_Msk = 0x1
	// Bit SET_TEXT_END.
	HMAC_SET_MESSAGE_END_SET_TEXT_END = 0x1

	// SET_RESULT_FINISH: Process control register 4.
	// Position of SET_RESULT_END field.
	HMAC_SET_RESULT_FINISH_SET_RESULT_END_Pos = 0x0
	// Bit mask of SET_RESULT_END field.
	HMAC_SET_RESULT_FINISH_SET_RESULT_END_Msk = 0x1
	// Bit SET_RESULT_END.
	HMAC_SET_RESULT_FINISH_SET_RESULT_END = 0x1

	// SET_INVALIDATE_JTAG: Invalidate register 0.
	// Position of SET_INVALIDATE_JTAG field.
	HMAC_SET_INVALIDATE_JTAG_SET_INVALIDATE_JTAG_Pos = 0x0
	// Bit mask of SET_INVALIDATE_JTAG field.
	HMAC_SET_INVALIDATE_JTAG_SET_INVALIDATE_JTAG_Msk = 0x1
	// Bit SET_INVALIDATE_JTAG.
	HMAC_SET_INVALIDATE_JTAG_SET_INVALIDATE_JTAG = 0x1

	// SET_INVALIDATE_DS: Invalidate register 1.
	// Position of SET_INVALIDATE_DS field.
	HMAC_SET_INVALIDATE_DS_SET_INVALIDATE_DS_Pos = 0x0
	// Bit mask of SET_INVALIDATE_DS field.
	HMAC_SET_INVALIDATE_DS_SET_INVALIDATE_DS_Msk = 0x1
	// Bit SET_INVALIDATE_DS.
	HMAC_SET_INVALIDATE_DS_SET_INVALIDATE_DS = 0x1

	// QUERY_ERROR: Error register.
	// Position of QUERY_CHECK field.
	HMAC_QUERY_ERROR_QUERY_CHECK_Pos = 0x0
	// Bit mask of QUERY_CHECK field.
	HMAC_QUERY_ERROR_QUERY_CHECK_Msk = 0x1
	// Bit QUERY_CHECK.
	HMAC_QUERY_ERROR_QUERY_CHECK = 0x1

	// QUERY_BUSY: Busy register.
	// Position of BUSY_STATE field.
	HMAC_QUERY_BUSY_BUSY_STATE_Pos = 0x0
	// Bit mask of BUSY_STATE field.
	HMAC_QUERY_BUSY_BUSY_STATE_Msk = 0x1
	// Bit BUSY_STATE.
	HMAC_QUERY_BUSY_BUSY_STATE = 0x1

	// SET_MESSAGE_PAD: Process control register 5.
	// Position of SET_TEXT_PAD field.
	HMAC_SET_MESSAGE_PAD_SET_TEXT_PAD_Pos = 0x0
	// Bit mask of SET_TEXT_PAD field.
	HMAC_SET_MESSAGE_PAD_SET_TEXT_PAD_Msk = 0x1
	// Bit SET_TEXT_PAD.
	HMAC_SET_MESSAGE_PAD_SET_TEXT_PAD = 0x1

	// ONE_BLOCK: Process control register 6.
	// Position of SET_ONE_BLOCK field.
	HMAC_ONE_BLOCK_SET_ONE_BLOCK_Pos = 0x0
	// Bit mask of SET_ONE_BLOCK field.
	HMAC_ONE_BLOCK_SET_ONE_BLOCK_Msk = 0x1
	// Bit SET_ONE_BLOCK.
	HMAC_ONE_BLOCK_SET_ONE_BLOCK = 0x1

	// SOFT_JTAG_CTRL: Jtag register 0.
	// Position of SOFT_JTAG_CTRL field.
	HMAC_SOFT_JTAG_CTRL_SOFT_JTAG_CTRL_Pos = 0x0
	// Bit mask of SOFT_JTAG_CTRL field.
	HMAC_SOFT_JTAG_CTRL_SOFT_JTAG_CTRL_Msk = 0x1
	// Bit SOFT_JTAG_CTRL.
	HMAC_SOFT_JTAG_CTRL_SOFT_JTAG_CTRL = 0x1

	// WR_JTAG: Jtag register 1.
	// Position of WR_JTAG field.
	HMAC_WR_JTAG_WR_JTAG_Pos = 0x0
	// Bit mask of WR_JTAG field.
	HMAC_WR_JTAG_WR_JTAG_Msk = 0xffffffff

	// DATE: Date register.
	// Position of DATE field.
	HMAC_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	HMAC_DATE_DATE_Msk = 0x3fffffff
)

// Constants for HP_APM: HP_APM Peripheral
const (
	// REGION_FILTER_EN: Region filter enable register
	// Position of REGION_FILTER_EN field.
	HP_APM_REGION_FILTER_EN_REGION_FILTER_EN_Pos = 0x0
	// Bit mask of REGION_FILTER_EN field.
	HP_APM_REGION_FILTER_EN_REGION_FILTER_EN_Msk = 0xffff

	// REGION0_ADDR_START: Region address register
	// Position of REGION0_ADDR_START field.
	HP_APM_REGION0_ADDR_START_REGION0_ADDR_START_Pos = 0x0
	// Bit mask of REGION0_ADDR_START field.
	HP_APM_REGION0_ADDR_START_REGION0_ADDR_START_Msk = 0xffffffff

	// REGION0_ADDR_END: Region address register
	// Position of REGION0_ADDR_END field.
	HP_APM_REGION0_ADDR_END_REGION0_ADDR_END_Pos = 0x0
	// Bit mask of REGION0_ADDR_END field.
	HP_APM_REGION0_ADDR_END_REGION0_ADDR_END_Msk = 0xffffffff

	// REGION0_PMS_ATTR: Region access authority attribute register
	// Position of REGION0_R0_PMS_X field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION0_R0_PMS_X field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_X_Msk = 0x1
	// Bit REGION0_R0_PMS_X.
	HP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_X = 0x1
	// Position of REGION0_R0_PMS_W field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION0_R0_PMS_W field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_W_Msk = 0x2
	// Bit REGION0_R0_PMS_W.
	HP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_W = 0x2
	// Position of REGION0_R0_PMS_R field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION0_R0_PMS_R field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_R_Msk = 0x4
	// Bit REGION0_R0_PMS_R.
	HP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_R = 0x4
	// Position of REGION0_R1_PMS_X field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION0_R1_PMS_X field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_X_Msk = 0x10
	// Bit REGION0_R1_PMS_X.
	HP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_X = 0x10
	// Position of REGION0_R1_PMS_W field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION0_R1_PMS_W field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_W_Msk = 0x20
	// Bit REGION0_R1_PMS_W.
	HP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_W = 0x20
	// Position of REGION0_R1_PMS_R field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION0_R1_PMS_R field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_R_Msk = 0x40
	// Bit REGION0_R1_PMS_R.
	HP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_R = 0x40
	// Position of REGION0_R2_PMS_X field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION0_R2_PMS_X field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_X_Msk = 0x100
	// Bit REGION0_R2_PMS_X.
	HP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_X = 0x100
	// Position of REGION0_R2_PMS_W field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION0_R2_PMS_W field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_W_Msk = 0x200
	// Bit REGION0_R2_PMS_W.
	HP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_W = 0x200
	// Position of REGION0_R2_PMS_R field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION0_R2_PMS_R field.
	HP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_R_Msk = 0x400
	// Bit REGION0_R2_PMS_R.
	HP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_R = 0x400

	// REGION1_ADDR_START: Region address register
	// Position of REGION1_ADDR_START field.
	HP_APM_REGION1_ADDR_START_REGION1_ADDR_START_Pos = 0x0
	// Bit mask of REGION1_ADDR_START field.
	HP_APM_REGION1_ADDR_START_REGION1_ADDR_START_Msk = 0xffffffff

	// REGION1_ADDR_END: Region address register
	// Position of REGION1_ADDR_END field.
	HP_APM_REGION1_ADDR_END_REGION1_ADDR_END_Pos = 0x0
	// Bit mask of REGION1_ADDR_END field.
	HP_APM_REGION1_ADDR_END_REGION1_ADDR_END_Msk = 0xffffffff

	// REGION1_PMS_ATTR: Region access authority attribute register
	// Position of REGION1_R0_PMS_X field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION1_R0_PMS_X field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_X_Msk = 0x1
	// Bit REGION1_R0_PMS_X.
	HP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_X = 0x1
	// Position of REGION1_R0_PMS_W field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION1_R0_PMS_W field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_W_Msk = 0x2
	// Bit REGION1_R0_PMS_W.
	HP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_W = 0x2
	// Position of REGION1_R0_PMS_R field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION1_R0_PMS_R field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_R_Msk = 0x4
	// Bit REGION1_R0_PMS_R.
	HP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_R = 0x4
	// Position of REGION1_R1_PMS_X field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION1_R1_PMS_X field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_X_Msk = 0x10
	// Bit REGION1_R1_PMS_X.
	HP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_X = 0x10
	// Position of REGION1_R1_PMS_W field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION1_R1_PMS_W field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_W_Msk = 0x20
	// Bit REGION1_R1_PMS_W.
	HP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_W = 0x20
	// Position of REGION1_R1_PMS_R field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION1_R1_PMS_R field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_R_Msk = 0x40
	// Bit REGION1_R1_PMS_R.
	HP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_R = 0x40
	// Position of REGION1_R2_PMS_X field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION1_R2_PMS_X field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_X_Msk = 0x100
	// Bit REGION1_R2_PMS_X.
	HP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_X = 0x100
	// Position of REGION1_R2_PMS_W field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION1_R2_PMS_W field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_W_Msk = 0x200
	// Bit REGION1_R2_PMS_W.
	HP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_W = 0x200
	// Position of REGION1_R2_PMS_R field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION1_R2_PMS_R field.
	HP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_R_Msk = 0x400
	// Bit REGION1_R2_PMS_R.
	HP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_R = 0x400

	// REGION2_ADDR_START: Region address register
	// Position of REGION2_ADDR_START field.
	HP_APM_REGION2_ADDR_START_REGION2_ADDR_START_Pos = 0x0
	// Bit mask of REGION2_ADDR_START field.
	HP_APM_REGION2_ADDR_START_REGION2_ADDR_START_Msk = 0xffffffff

	// REGION2_ADDR_END: Region address register
	// Position of REGION2_ADDR_END field.
	HP_APM_REGION2_ADDR_END_REGION2_ADDR_END_Pos = 0x0
	// Bit mask of REGION2_ADDR_END field.
	HP_APM_REGION2_ADDR_END_REGION2_ADDR_END_Msk = 0xffffffff

	// REGION2_PMS_ATTR: Region access authority attribute register
	// Position of REGION2_R0_PMS_X field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION2_R0_PMS_X field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R0_PMS_X_Msk = 0x1
	// Bit REGION2_R0_PMS_X.
	HP_APM_REGION2_PMS_ATTR_REGION2_R0_PMS_X = 0x1
	// Position of REGION2_R0_PMS_W field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION2_R0_PMS_W field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R0_PMS_W_Msk = 0x2
	// Bit REGION2_R0_PMS_W.
	HP_APM_REGION2_PMS_ATTR_REGION2_R0_PMS_W = 0x2
	// Position of REGION2_R0_PMS_R field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION2_R0_PMS_R field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R0_PMS_R_Msk = 0x4
	// Bit REGION2_R0_PMS_R.
	HP_APM_REGION2_PMS_ATTR_REGION2_R0_PMS_R = 0x4
	// Position of REGION2_R1_PMS_X field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION2_R1_PMS_X field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R1_PMS_X_Msk = 0x10
	// Bit REGION2_R1_PMS_X.
	HP_APM_REGION2_PMS_ATTR_REGION2_R1_PMS_X = 0x10
	// Position of REGION2_R1_PMS_W field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION2_R1_PMS_W field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R1_PMS_W_Msk = 0x20
	// Bit REGION2_R1_PMS_W.
	HP_APM_REGION2_PMS_ATTR_REGION2_R1_PMS_W = 0x20
	// Position of REGION2_R1_PMS_R field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION2_R1_PMS_R field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R1_PMS_R_Msk = 0x40
	// Bit REGION2_R1_PMS_R.
	HP_APM_REGION2_PMS_ATTR_REGION2_R1_PMS_R = 0x40
	// Position of REGION2_R2_PMS_X field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION2_R2_PMS_X field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R2_PMS_X_Msk = 0x100
	// Bit REGION2_R2_PMS_X.
	HP_APM_REGION2_PMS_ATTR_REGION2_R2_PMS_X = 0x100
	// Position of REGION2_R2_PMS_W field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION2_R2_PMS_W field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R2_PMS_W_Msk = 0x200
	// Bit REGION2_R2_PMS_W.
	HP_APM_REGION2_PMS_ATTR_REGION2_R2_PMS_W = 0x200
	// Position of REGION2_R2_PMS_R field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION2_R2_PMS_R field.
	HP_APM_REGION2_PMS_ATTR_REGION2_R2_PMS_R_Msk = 0x400
	// Bit REGION2_R2_PMS_R.
	HP_APM_REGION2_PMS_ATTR_REGION2_R2_PMS_R = 0x400

	// REGION3_ADDR_START: Region address register
	// Position of REGION3_ADDR_START field.
	HP_APM_REGION3_ADDR_START_REGION3_ADDR_START_Pos = 0x0
	// Bit mask of REGION3_ADDR_START field.
	HP_APM_REGION3_ADDR_START_REGION3_ADDR_START_Msk = 0xffffffff

	// REGION3_ADDR_END: Region address register
	// Position of REGION3_ADDR_END field.
	HP_APM_REGION3_ADDR_END_REGION3_ADDR_END_Pos = 0x0
	// Bit mask of REGION3_ADDR_END field.
	HP_APM_REGION3_ADDR_END_REGION3_ADDR_END_Msk = 0xffffffff

	// REGION3_PMS_ATTR: Region access authority attribute register
	// Position of REGION3_R0_PMS_X field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION3_R0_PMS_X field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R0_PMS_X_Msk = 0x1
	// Bit REGION3_R0_PMS_X.
	HP_APM_REGION3_PMS_ATTR_REGION3_R0_PMS_X = 0x1
	// Position of REGION3_R0_PMS_W field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION3_R0_PMS_W field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R0_PMS_W_Msk = 0x2
	// Bit REGION3_R0_PMS_W.
	HP_APM_REGION3_PMS_ATTR_REGION3_R0_PMS_W = 0x2
	// Position of REGION3_R0_PMS_R field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION3_R0_PMS_R field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R0_PMS_R_Msk = 0x4
	// Bit REGION3_R0_PMS_R.
	HP_APM_REGION3_PMS_ATTR_REGION3_R0_PMS_R = 0x4
	// Position of REGION3_R1_PMS_X field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION3_R1_PMS_X field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R1_PMS_X_Msk = 0x10
	// Bit REGION3_R1_PMS_X.
	HP_APM_REGION3_PMS_ATTR_REGION3_R1_PMS_X = 0x10
	// Position of REGION3_R1_PMS_W field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION3_R1_PMS_W field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R1_PMS_W_Msk = 0x20
	// Bit REGION3_R1_PMS_W.
	HP_APM_REGION3_PMS_ATTR_REGION3_R1_PMS_W = 0x20
	// Position of REGION3_R1_PMS_R field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION3_R1_PMS_R field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R1_PMS_R_Msk = 0x40
	// Bit REGION3_R1_PMS_R.
	HP_APM_REGION3_PMS_ATTR_REGION3_R1_PMS_R = 0x40
	// Position of REGION3_R2_PMS_X field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION3_R2_PMS_X field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R2_PMS_X_Msk = 0x100
	// Bit REGION3_R2_PMS_X.
	HP_APM_REGION3_PMS_ATTR_REGION3_R2_PMS_X = 0x100
	// Position of REGION3_R2_PMS_W field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION3_R2_PMS_W field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R2_PMS_W_Msk = 0x200
	// Bit REGION3_R2_PMS_W.
	HP_APM_REGION3_PMS_ATTR_REGION3_R2_PMS_W = 0x200
	// Position of REGION3_R2_PMS_R field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION3_R2_PMS_R field.
	HP_APM_REGION3_PMS_ATTR_REGION3_R2_PMS_R_Msk = 0x400
	// Bit REGION3_R2_PMS_R.
	HP_APM_REGION3_PMS_ATTR_REGION3_R2_PMS_R = 0x400

	// REGION4_ADDR_START: Region address register
	// Position of REGION4_ADDR_START field.
	HP_APM_REGION4_ADDR_START_REGION4_ADDR_START_Pos = 0x0
	// Bit mask of REGION4_ADDR_START field.
	HP_APM_REGION4_ADDR_START_REGION4_ADDR_START_Msk = 0xffffffff

	// REGION4_ADDR_END: Region address register
	// Position of REGION4_ADDR_END field.
	HP_APM_REGION4_ADDR_END_REGION4_ADDR_END_Pos = 0x0
	// Bit mask of REGION4_ADDR_END field.
	HP_APM_REGION4_ADDR_END_REGION4_ADDR_END_Msk = 0xffffffff

	// REGION4_PMS_ATTR: Region access authority attribute register
	// Position of REGION4_R0_PMS_X field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION4_R0_PMS_X field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R0_PMS_X_Msk = 0x1
	// Bit REGION4_R0_PMS_X.
	HP_APM_REGION4_PMS_ATTR_REGION4_R0_PMS_X = 0x1
	// Position of REGION4_R0_PMS_W field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION4_R0_PMS_W field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R0_PMS_W_Msk = 0x2
	// Bit REGION4_R0_PMS_W.
	HP_APM_REGION4_PMS_ATTR_REGION4_R0_PMS_W = 0x2
	// Position of REGION4_R0_PMS_R field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION4_R0_PMS_R field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R0_PMS_R_Msk = 0x4
	// Bit REGION4_R0_PMS_R.
	HP_APM_REGION4_PMS_ATTR_REGION4_R0_PMS_R = 0x4
	// Position of REGION4_R1_PMS_X field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION4_R1_PMS_X field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R1_PMS_X_Msk = 0x10
	// Bit REGION4_R1_PMS_X.
	HP_APM_REGION4_PMS_ATTR_REGION4_R1_PMS_X = 0x10
	// Position of REGION4_R1_PMS_W field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION4_R1_PMS_W field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R1_PMS_W_Msk = 0x20
	// Bit REGION4_R1_PMS_W.
	HP_APM_REGION4_PMS_ATTR_REGION4_R1_PMS_W = 0x20
	// Position of REGION4_R1_PMS_R field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION4_R1_PMS_R field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R1_PMS_R_Msk = 0x40
	// Bit REGION4_R1_PMS_R.
	HP_APM_REGION4_PMS_ATTR_REGION4_R1_PMS_R = 0x40
	// Position of REGION4_R2_PMS_X field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION4_R2_PMS_X field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R2_PMS_X_Msk = 0x100
	// Bit REGION4_R2_PMS_X.
	HP_APM_REGION4_PMS_ATTR_REGION4_R2_PMS_X = 0x100
	// Position of REGION4_R2_PMS_W field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION4_R2_PMS_W field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R2_PMS_W_Msk = 0x200
	// Bit REGION4_R2_PMS_W.
	HP_APM_REGION4_PMS_ATTR_REGION4_R2_PMS_W = 0x200
	// Position of REGION4_R2_PMS_R field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION4_R2_PMS_R field.
	HP_APM_REGION4_PMS_ATTR_REGION4_R2_PMS_R_Msk = 0x400
	// Bit REGION4_R2_PMS_R.
	HP_APM_REGION4_PMS_ATTR_REGION4_R2_PMS_R = 0x400

	// REGION5_ADDR_START: Region address register
	// Position of REGION5_ADDR_START field.
	HP_APM_REGION5_ADDR_START_REGION5_ADDR_START_Pos = 0x0
	// Bit mask of REGION5_ADDR_START field.
	HP_APM_REGION5_ADDR_START_REGION5_ADDR_START_Msk = 0xffffffff

	// REGION5_ADDR_END: Region address register
	// Position of REGION5_ADDR_END field.
	HP_APM_REGION5_ADDR_END_REGION5_ADDR_END_Pos = 0x0
	// Bit mask of REGION5_ADDR_END field.
	HP_APM_REGION5_ADDR_END_REGION5_ADDR_END_Msk = 0xffffffff

	// REGION5_PMS_ATTR: Region access authority attribute register
	// Position of REGION5_R0_PMS_X field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION5_R0_PMS_X field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R0_PMS_X_Msk = 0x1
	// Bit REGION5_R0_PMS_X.
	HP_APM_REGION5_PMS_ATTR_REGION5_R0_PMS_X = 0x1
	// Position of REGION5_R0_PMS_W field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION5_R0_PMS_W field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R0_PMS_W_Msk = 0x2
	// Bit REGION5_R0_PMS_W.
	HP_APM_REGION5_PMS_ATTR_REGION5_R0_PMS_W = 0x2
	// Position of REGION5_R0_PMS_R field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION5_R0_PMS_R field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R0_PMS_R_Msk = 0x4
	// Bit REGION5_R0_PMS_R.
	HP_APM_REGION5_PMS_ATTR_REGION5_R0_PMS_R = 0x4
	// Position of REGION5_R1_PMS_X field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION5_R1_PMS_X field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R1_PMS_X_Msk = 0x10
	// Bit REGION5_R1_PMS_X.
	HP_APM_REGION5_PMS_ATTR_REGION5_R1_PMS_X = 0x10
	// Position of REGION5_R1_PMS_W field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION5_R1_PMS_W field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R1_PMS_W_Msk = 0x20
	// Bit REGION5_R1_PMS_W.
	HP_APM_REGION5_PMS_ATTR_REGION5_R1_PMS_W = 0x20
	// Position of REGION5_R1_PMS_R field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION5_R1_PMS_R field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R1_PMS_R_Msk = 0x40
	// Bit REGION5_R1_PMS_R.
	HP_APM_REGION5_PMS_ATTR_REGION5_R1_PMS_R = 0x40
	// Position of REGION5_R2_PMS_X field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION5_R2_PMS_X field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R2_PMS_X_Msk = 0x100
	// Bit REGION5_R2_PMS_X.
	HP_APM_REGION5_PMS_ATTR_REGION5_R2_PMS_X = 0x100
	// Position of REGION5_R2_PMS_W field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION5_R2_PMS_W field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R2_PMS_W_Msk = 0x200
	// Bit REGION5_R2_PMS_W.
	HP_APM_REGION5_PMS_ATTR_REGION5_R2_PMS_W = 0x200
	// Position of REGION5_R2_PMS_R field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION5_R2_PMS_R field.
	HP_APM_REGION5_PMS_ATTR_REGION5_R2_PMS_R_Msk = 0x400
	// Bit REGION5_R2_PMS_R.
	HP_APM_REGION5_PMS_ATTR_REGION5_R2_PMS_R = 0x400

	// REGION6_ADDR_START: Region address register
	// Position of REGION6_ADDR_START field.
	HP_APM_REGION6_ADDR_START_REGION6_ADDR_START_Pos = 0x0
	// Bit mask of REGION6_ADDR_START field.
	HP_APM_REGION6_ADDR_START_REGION6_ADDR_START_Msk = 0xffffffff

	// REGION6_ADDR_END: Region address register
	// Position of REGION6_ADDR_END field.
	HP_APM_REGION6_ADDR_END_REGION6_ADDR_END_Pos = 0x0
	// Bit mask of REGION6_ADDR_END field.
	HP_APM_REGION6_ADDR_END_REGION6_ADDR_END_Msk = 0xffffffff

	// REGION6_PMS_ATTR: Region access authority attribute register
	// Position of REGION6_R0_PMS_X field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION6_R0_PMS_X field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R0_PMS_X_Msk = 0x1
	// Bit REGION6_R0_PMS_X.
	HP_APM_REGION6_PMS_ATTR_REGION6_R0_PMS_X = 0x1
	// Position of REGION6_R0_PMS_W field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION6_R0_PMS_W field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R0_PMS_W_Msk = 0x2
	// Bit REGION6_R0_PMS_W.
	HP_APM_REGION6_PMS_ATTR_REGION6_R0_PMS_W = 0x2
	// Position of REGION6_R0_PMS_R field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION6_R0_PMS_R field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R0_PMS_R_Msk = 0x4
	// Bit REGION6_R0_PMS_R.
	HP_APM_REGION6_PMS_ATTR_REGION6_R0_PMS_R = 0x4
	// Position of REGION6_R1_PMS_X field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION6_R1_PMS_X field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R1_PMS_X_Msk = 0x10
	// Bit REGION6_R1_PMS_X.
	HP_APM_REGION6_PMS_ATTR_REGION6_R1_PMS_X = 0x10
	// Position of REGION6_R1_PMS_W field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION6_R1_PMS_W field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R1_PMS_W_Msk = 0x20
	// Bit REGION6_R1_PMS_W.
	HP_APM_REGION6_PMS_ATTR_REGION6_R1_PMS_W = 0x20
	// Position of REGION6_R1_PMS_R field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION6_R1_PMS_R field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R1_PMS_R_Msk = 0x40
	// Bit REGION6_R1_PMS_R.
	HP_APM_REGION6_PMS_ATTR_REGION6_R1_PMS_R = 0x40
	// Position of REGION6_R2_PMS_X field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION6_R2_PMS_X field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R2_PMS_X_Msk = 0x100
	// Bit REGION6_R2_PMS_X.
	HP_APM_REGION6_PMS_ATTR_REGION6_R2_PMS_X = 0x100
	// Position of REGION6_R2_PMS_W field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION6_R2_PMS_W field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R2_PMS_W_Msk = 0x200
	// Bit REGION6_R2_PMS_W.
	HP_APM_REGION6_PMS_ATTR_REGION6_R2_PMS_W = 0x200
	// Position of REGION6_R2_PMS_R field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION6_R2_PMS_R field.
	HP_APM_REGION6_PMS_ATTR_REGION6_R2_PMS_R_Msk = 0x400
	// Bit REGION6_R2_PMS_R.
	HP_APM_REGION6_PMS_ATTR_REGION6_R2_PMS_R = 0x400

	// REGION7_ADDR_START: Region address register
	// Position of REGION7_ADDR_START field.
	HP_APM_REGION7_ADDR_START_REGION7_ADDR_START_Pos = 0x0
	// Bit mask of REGION7_ADDR_START field.
	HP_APM_REGION7_ADDR_START_REGION7_ADDR_START_Msk = 0xffffffff

	// REGION7_ADDR_END: Region address register
	// Position of REGION7_ADDR_END field.
	HP_APM_REGION7_ADDR_END_REGION7_ADDR_END_Pos = 0x0
	// Bit mask of REGION7_ADDR_END field.
	HP_APM_REGION7_ADDR_END_REGION7_ADDR_END_Msk = 0xffffffff

	// REGION7_PMS_ATTR: Region access authority attribute register
	// Position of REGION7_R0_PMS_X field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION7_R0_PMS_X field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R0_PMS_X_Msk = 0x1
	// Bit REGION7_R0_PMS_X.
	HP_APM_REGION7_PMS_ATTR_REGION7_R0_PMS_X = 0x1
	// Position of REGION7_R0_PMS_W field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION7_R0_PMS_W field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R0_PMS_W_Msk = 0x2
	// Bit REGION7_R0_PMS_W.
	HP_APM_REGION7_PMS_ATTR_REGION7_R0_PMS_W = 0x2
	// Position of REGION7_R0_PMS_R field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION7_R0_PMS_R field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R0_PMS_R_Msk = 0x4
	// Bit REGION7_R0_PMS_R.
	HP_APM_REGION7_PMS_ATTR_REGION7_R0_PMS_R = 0x4
	// Position of REGION7_R1_PMS_X field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION7_R1_PMS_X field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R1_PMS_X_Msk = 0x10
	// Bit REGION7_R1_PMS_X.
	HP_APM_REGION7_PMS_ATTR_REGION7_R1_PMS_X = 0x10
	// Position of REGION7_R1_PMS_W field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION7_R1_PMS_W field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R1_PMS_W_Msk = 0x20
	// Bit REGION7_R1_PMS_W.
	HP_APM_REGION7_PMS_ATTR_REGION7_R1_PMS_W = 0x20
	// Position of REGION7_R1_PMS_R field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION7_R1_PMS_R field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R1_PMS_R_Msk = 0x40
	// Bit REGION7_R1_PMS_R.
	HP_APM_REGION7_PMS_ATTR_REGION7_R1_PMS_R = 0x40
	// Position of REGION7_R2_PMS_X field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION7_R2_PMS_X field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R2_PMS_X_Msk = 0x100
	// Bit REGION7_R2_PMS_X.
	HP_APM_REGION7_PMS_ATTR_REGION7_R2_PMS_X = 0x100
	// Position of REGION7_R2_PMS_W field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION7_R2_PMS_W field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R2_PMS_W_Msk = 0x200
	// Bit REGION7_R2_PMS_W.
	HP_APM_REGION7_PMS_ATTR_REGION7_R2_PMS_W = 0x200
	// Position of REGION7_R2_PMS_R field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION7_R2_PMS_R field.
	HP_APM_REGION7_PMS_ATTR_REGION7_R2_PMS_R_Msk = 0x400
	// Bit REGION7_R2_PMS_R.
	HP_APM_REGION7_PMS_ATTR_REGION7_R2_PMS_R = 0x400

	// REGION8_ADDR_START: Region address register
	// Position of REGION8_ADDR_START field.
	HP_APM_REGION8_ADDR_START_REGION8_ADDR_START_Pos = 0x0
	// Bit mask of REGION8_ADDR_START field.
	HP_APM_REGION8_ADDR_START_REGION8_ADDR_START_Msk = 0xffffffff

	// REGION8_ADDR_END: Region address register
	// Position of REGION8_ADDR_END field.
	HP_APM_REGION8_ADDR_END_REGION8_ADDR_END_Pos = 0x0
	// Bit mask of REGION8_ADDR_END field.
	HP_APM_REGION8_ADDR_END_REGION8_ADDR_END_Msk = 0xffffffff

	// REGION8_PMS_ATTR: Region access authority attribute register
	// Position of REGION8_R0_PMS_X field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION8_R0_PMS_X field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R0_PMS_X_Msk = 0x1
	// Bit REGION8_R0_PMS_X.
	HP_APM_REGION8_PMS_ATTR_REGION8_R0_PMS_X = 0x1
	// Position of REGION8_R0_PMS_W field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION8_R0_PMS_W field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R0_PMS_W_Msk = 0x2
	// Bit REGION8_R0_PMS_W.
	HP_APM_REGION8_PMS_ATTR_REGION8_R0_PMS_W = 0x2
	// Position of REGION8_R0_PMS_R field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION8_R0_PMS_R field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R0_PMS_R_Msk = 0x4
	// Bit REGION8_R0_PMS_R.
	HP_APM_REGION8_PMS_ATTR_REGION8_R0_PMS_R = 0x4
	// Position of REGION8_R1_PMS_X field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION8_R1_PMS_X field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R1_PMS_X_Msk = 0x10
	// Bit REGION8_R1_PMS_X.
	HP_APM_REGION8_PMS_ATTR_REGION8_R1_PMS_X = 0x10
	// Position of REGION8_R1_PMS_W field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION8_R1_PMS_W field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R1_PMS_W_Msk = 0x20
	// Bit REGION8_R1_PMS_W.
	HP_APM_REGION8_PMS_ATTR_REGION8_R1_PMS_W = 0x20
	// Position of REGION8_R1_PMS_R field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION8_R1_PMS_R field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R1_PMS_R_Msk = 0x40
	// Bit REGION8_R1_PMS_R.
	HP_APM_REGION8_PMS_ATTR_REGION8_R1_PMS_R = 0x40
	// Position of REGION8_R2_PMS_X field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION8_R2_PMS_X field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R2_PMS_X_Msk = 0x100
	// Bit REGION8_R2_PMS_X.
	HP_APM_REGION8_PMS_ATTR_REGION8_R2_PMS_X = 0x100
	// Position of REGION8_R2_PMS_W field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION8_R2_PMS_W field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R2_PMS_W_Msk = 0x200
	// Bit REGION8_R2_PMS_W.
	HP_APM_REGION8_PMS_ATTR_REGION8_R2_PMS_W = 0x200
	// Position of REGION8_R2_PMS_R field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION8_R2_PMS_R field.
	HP_APM_REGION8_PMS_ATTR_REGION8_R2_PMS_R_Msk = 0x400
	// Bit REGION8_R2_PMS_R.
	HP_APM_REGION8_PMS_ATTR_REGION8_R2_PMS_R = 0x400

	// REGION9_ADDR_START: Region address register
	// Position of REGION9_ADDR_START field.
	HP_APM_REGION9_ADDR_START_REGION9_ADDR_START_Pos = 0x0
	// Bit mask of REGION9_ADDR_START field.
	HP_APM_REGION9_ADDR_START_REGION9_ADDR_START_Msk = 0xffffffff

	// REGION9_ADDR_END: Region address register
	// Position of REGION9_ADDR_END field.
	HP_APM_REGION9_ADDR_END_REGION9_ADDR_END_Pos = 0x0
	// Bit mask of REGION9_ADDR_END field.
	HP_APM_REGION9_ADDR_END_REGION9_ADDR_END_Msk = 0xffffffff

	// REGION9_PMS_ATTR: Region access authority attribute register
	// Position of REGION9_R0_PMS_X field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION9_R0_PMS_X field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R0_PMS_X_Msk = 0x1
	// Bit REGION9_R0_PMS_X.
	HP_APM_REGION9_PMS_ATTR_REGION9_R0_PMS_X = 0x1
	// Position of REGION9_R0_PMS_W field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION9_R0_PMS_W field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R0_PMS_W_Msk = 0x2
	// Bit REGION9_R0_PMS_W.
	HP_APM_REGION9_PMS_ATTR_REGION9_R0_PMS_W = 0x2
	// Position of REGION9_R0_PMS_R field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION9_R0_PMS_R field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R0_PMS_R_Msk = 0x4
	// Bit REGION9_R0_PMS_R.
	HP_APM_REGION9_PMS_ATTR_REGION9_R0_PMS_R = 0x4
	// Position of REGION9_R1_PMS_X field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION9_R1_PMS_X field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R1_PMS_X_Msk = 0x10
	// Bit REGION9_R1_PMS_X.
	HP_APM_REGION9_PMS_ATTR_REGION9_R1_PMS_X = 0x10
	// Position of REGION9_R1_PMS_W field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION9_R1_PMS_W field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R1_PMS_W_Msk = 0x20
	// Bit REGION9_R1_PMS_W.
	HP_APM_REGION9_PMS_ATTR_REGION9_R1_PMS_W = 0x20
	// Position of REGION9_R1_PMS_R field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION9_R1_PMS_R field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R1_PMS_R_Msk = 0x40
	// Bit REGION9_R1_PMS_R.
	HP_APM_REGION9_PMS_ATTR_REGION9_R1_PMS_R = 0x40
	// Position of REGION9_R2_PMS_X field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION9_R2_PMS_X field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R2_PMS_X_Msk = 0x100
	// Bit REGION9_R2_PMS_X.
	HP_APM_REGION9_PMS_ATTR_REGION9_R2_PMS_X = 0x100
	// Position of REGION9_R2_PMS_W field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION9_R2_PMS_W field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R2_PMS_W_Msk = 0x200
	// Bit REGION9_R2_PMS_W.
	HP_APM_REGION9_PMS_ATTR_REGION9_R2_PMS_W = 0x200
	// Position of REGION9_R2_PMS_R field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION9_R2_PMS_R field.
	HP_APM_REGION9_PMS_ATTR_REGION9_R2_PMS_R_Msk = 0x400
	// Bit REGION9_R2_PMS_R.
	HP_APM_REGION9_PMS_ATTR_REGION9_R2_PMS_R = 0x400

	// REGION10_ADDR_START: Region address register
	// Position of REGION10_ADDR_START field.
	HP_APM_REGION10_ADDR_START_REGION10_ADDR_START_Pos = 0x0
	// Bit mask of REGION10_ADDR_START field.
	HP_APM_REGION10_ADDR_START_REGION10_ADDR_START_Msk = 0xffffffff

	// REGION10_ADDR_END: Region address register
	// Position of REGION10_ADDR_END field.
	HP_APM_REGION10_ADDR_END_REGION10_ADDR_END_Pos = 0x0
	// Bit mask of REGION10_ADDR_END field.
	HP_APM_REGION10_ADDR_END_REGION10_ADDR_END_Msk = 0xffffffff

	// REGION10_PMS_ATTR: Region access authority attribute register
	// Position of REGION10_R0_PMS_X field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION10_R0_PMS_X field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R0_PMS_X_Msk = 0x1
	// Bit REGION10_R0_PMS_X.
	HP_APM_REGION10_PMS_ATTR_REGION10_R0_PMS_X = 0x1
	// Position of REGION10_R0_PMS_W field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION10_R0_PMS_W field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R0_PMS_W_Msk = 0x2
	// Bit REGION10_R0_PMS_W.
	HP_APM_REGION10_PMS_ATTR_REGION10_R0_PMS_W = 0x2
	// Position of REGION10_R0_PMS_R field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION10_R0_PMS_R field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R0_PMS_R_Msk = 0x4
	// Bit REGION10_R0_PMS_R.
	HP_APM_REGION10_PMS_ATTR_REGION10_R0_PMS_R = 0x4
	// Position of REGION10_R1_PMS_X field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION10_R1_PMS_X field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R1_PMS_X_Msk = 0x10
	// Bit REGION10_R1_PMS_X.
	HP_APM_REGION10_PMS_ATTR_REGION10_R1_PMS_X = 0x10
	// Position of REGION10_R1_PMS_W field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION10_R1_PMS_W field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R1_PMS_W_Msk = 0x20
	// Bit REGION10_R1_PMS_W.
	HP_APM_REGION10_PMS_ATTR_REGION10_R1_PMS_W = 0x20
	// Position of REGION10_R1_PMS_R field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION10_R1_PMS_R field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R1_PMS_R_Msk = 0x40
	// Bit REGION10_R1_PMS_R.
	HP_APM_REGION10_PMS_ATTR_REGION10_R1_PMS_R = 0x40
	// Position of REGION10_R2_PMS_X field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION10_R2_PMS_X field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R2_PMS_X_Msk = 0x100
	// Bit REGION10_R2_PMS_X.
	HP_APM_REGION10_PMS_ATTR_REGION10_R2_PMS_X = 0x100
	// Position of REGION10_R2_PMS_W field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION10_R2_PMS_W field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R2_PMS_W_Msk = 0x200
	// Bit REGION10_R2_PMS_W.
	HP_APM_REGION10_PMS_ATTR_REGION10_R2_PMS_W = 0x200
	// Position of REGION10_R2_PMS_R field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION10_R2_PMS_R field.
	HP_APM_REGION10_PMS_ATTR_REGION10_R2_PMS_R_Msk = 0x400
	// Bit REGION10_R2_PMS_R.
	HP_APM_REGION10_PMS_ATTR_REGION10_R2_PMS_R = 0x400

	// REGION11_ADDR_START: Region address register
	// Position of REGION11_ADDR_START field.
	HP_APM_REGION11_ADDR_START_REGION11_ADDR_START_Pos = 0x0
	// Bit mask of REGION11_ADDR_START field.
	HP_APM_REGION11_ADDR_START_REGION11_ADDR_START_Msk = 0xffffffff

	// REGION11_ADDR_END: Region address register
	// Position of REGION11_ADDR_END field.
	HP_APM_REGION11_ADDR_END_REGION11_ADDR_END_Pos = 0x0
	// Bit mask of REGION11_ADDR_END field.
	HP_APM_REGION11_ADDR_END_REGION11_ADDR_END_Msk = 0xffffffff

	// REGION11_PMS_ATTR: Region access authority attribute register
	// Position of REGION11_R0_PMS_X field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION11_R0_PMS_X field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R0_PMS_X_Msk = 0x1
	// Bit REGION11_R0_PMS_X.
	HP_APM_REGION11_PMS_ATTR_REGION11_R0_PMS_X = 0x1
	// Position of REGION11_R0_PMS_W field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION11_R0_PMS_W field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R0_PMS_W_Msk = 0x2
	// Bit REGION11_R0_PMS_W.
	HP_APM_REGION11_PMS_ATTR_REGION11_R0_PMS_W = 0x2
	// Position of REGION11_R0_PMS_R field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION11_R0_PMS_R field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R0_PMS_R_Msk = 0x4
	// Bit REGION11_R0_PMS_R.
	HP_APM_REGION11_PMS_ATTR_REGION11_R0_PMS_R = 0x4
	// Position of REGION11_R1_PMS_X field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION11_R1_PMS_X field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R1_PMS_X_Msk = 0x10
	// Bit REGION11_R1_PMS_X.
	HP_APM_REGION11_PMS_ATTR_REGION11_R1_PMS_X = 0x10
	// Position of REGION11_R1_PMS_W field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION11_R1_PMS_W field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R1_PMS_W_Msk = 0x20
	// Bit REGION11_R1_PMS_W.
	HP_APM_REGION11_PMS_ATTR_REGION11_R1_PMS_W = 0x20
	// Position of REGION11_R1_PMS_R field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION11_R1_PMS_R field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R1_PMS_R_Msk = 0x40
	// Bit REGION11_R1_PMS_R.
	HP_APM_REGION11_PMS_ATTR_REGION11_R1_PMS_R = 0x40
	// Position of REGION11_R2_PMS_X field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION11_R2_PMS_X field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R2_PMS_X_Msk = 0x100
	// Bit REGION11_R2_PMS_X.
	HP_APM_REGION11_PMS_ATTR_REGION11_R2_PMS_X = 0x100
	// Position of REGION11_R2_PMS_W field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION11_R2_PMS_W field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R2_PMS_W_Msk = 0x200
	// Bit REGION11_R2_PMS_W.
	HP_APM_REGION11_PMS_ATTR_REGION11_R2_PMS_W = 0x200
	// Position of REGION11_R2_PMS_R field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION11_R2_PMS_R field.
	HP_APM_REGION11_PMS_ATTR_REGION11_R2_PMS_R_Msk = 0x400
	// Bit REGION11_R2_PMS_R.
	HP_APM_REGION11_PMS_ATTR_REGION11_R2_PMS_R = 0x400

	// REGION12_ADDR_START: Region address register
	// Position of REGION12_ADDR_START field.
	HP_APM_REGION12_ADDR_START_REGION12_ADDR_START_Pos = 0x0
	// Bit mask of REGION12_ADDR_START field.
	HP_APM_REGION12_ADDR_START_REGION12_ADDR_START_Msk = 0xffffffff

	// REGION12_ADDR_END: Region address register
	// Position of REGION12_ADDR_END field.
	HP_APM_REGION12_ADDR_END_REGION12_ADDR_END_Pos = 0x0
	// Bit mask of REGION12_ADDR_END field.
	HP_APM_REGION12_ADDR_END_REGION12_ADDR_END_Msk = 0xffffffff

	// REGION12_PMS_ATTR: Region access authority attribute register
	// Position of REGION12_R0_PMS_X field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION12_R0_PMS_X field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R0_PMS_X_Msk = 0x1
	// Bit REGION12_R0_PMS_X.
	HP_APM_REGION12_PMS_ATTR_REGION12_R0_PMS_X = 0x1
	// Position of REGION12_R0_PMS_W field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION12_R0_PMS_W field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R0_PMS_W_Msk = 0x2
	// Bit REGION12_R0_PMS_W.
	HP_APM_REGION12_PMS_ATTR_REGION12_R0_PMS_W = 0x2
	// Position of REGION12_R0_PMS_R field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION12_R0_PMS_R field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R0_PMS_R_Msk = 0x4
	// Bit REGION12_R0_PMS_R.
	HP_APM_REGION12_PMS_ATTR_REGION12_R0_PMS_R = 0x4
	// Position of REGION12_R1_PMS_X field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION12_R1_PMS_X field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R1_PMS_X_Msk = 0x10
	// Bit REGION12_R1_PMS_X.
	HP_APM_REGION12_PMS_ATTR_REGION12_R1_PMS_X = 0x10
	// Position of REGION12_R1_PMS_W field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION12_R1_PMS_W field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R1_PMS_W_Msk = 0x20
	// Bit REGION12_R1_PMS_W.
	HP_APM_REGION12_PMS_ATTR_REGION12_R1_PMS_W = 0x20
	// Position of REGION12_R1_PMS_R field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION12_R1_PMS_R field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R1_PMS_R_Msk = 0x40
	// Bit REGION12_R1_PMS_R.
	HP_APM_REGION12_PMS_ATTR_REGION12_R1_PMS_R = 0x40
	// Position of REGION12_R2_PMS_X field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION12_R2_PMS_X field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R2_PMS_X_Msk = 0x100
	// Bit REGION12_R2_PMS_X.
	HP_APM_REGION12_PMS_ATTR_REGION12_R2_PMS_X = 0x100
	// Position of REGION12_R2_PMS_W field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION12_R2_PMS_W field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R2_PMS_W_Msk = 0x200
	// Bit REGION12_R2_PMS_W.
	HP_APM_REGION12_PMS_ATTR_REGION12_R2_PMS_W = 0x200
	// Position of REGION12_R2_PMS_R field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION12_R2_PMS_R field.
	HP_APM_REGION12_PMS_ATTR_REGION12_R2_PMS_R_Msk = 0x400
	// Bit REGION12_R2_PMS_R.
	HP_APM_REGION12_PMS_ATTR_REGION12_R2_PMS_R = 0x400

	// REGION13_ADDR_START: Region address register
	// Position of REGION13_ADDR_START field.
	HP_APM_REGION13_ADDR_START_REGION13_ADDR_START_Pos = 0x0
	// Bit mask of REGION13_ADDR_START field.
	HP_APM_REGION13_ADDR_START_REGION13_ADDR_START_Msk = 0xffffffff

	// REGION13_ADDR_END: Region address register
	// Position of REGION13_ADDR_END field.
	HP_APM_REGION13_ADDR_END_REGION13_ADDR_END_Pos = 0x0
	// Bit mask of REGION13_ADDR_END field.
	HP_APM_REGION13_ADDR_END_REGION13_ADDR_END_Msk = 0xffffffff

	// REGION13_PMS_ATTR: Region access authority attribute register
	// Position of REGION13_R0_PMS_X field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION13_R0_PMS_X field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R0_PMS_X_Msk = 0x1
	// Bit REGION13_R0_PMS_X.
	HP_APM_REGION13_PMS_ATTR_REGION13_R0_PMS_X = 0x1
	// Position of REGION13_R0_PMS_W field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION13_R0_PMS_W field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R0_PMS_W_Msk = 0x2
	// Bit REGION13_R0_PMS_W.
	HP_APM_REGION13_PMS_ATTR_REGION13_R0_PMS_W = 0x2
	// Position of REGION13_R0_PMS_R field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION13_R0_PMS_R field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R0_PMS_R_Msk = 0x4
	// Bit REGION13_R0_PMS_R.
	HP_APM_REGION13_PMS_ATTR_REGION13_R0_PMS_R = 0x4
	// Position of REGION13_R1_PMS_X field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION13_R1_PMS_X field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R1_PMS_X_Msk = 0x10
	// Bit REGION13_R1_PMS_X.
	HP_APM_REGION13_PMS_ATTR_REGION13_R1_PMS_X = 0x10
	// Position of REGION13_R1_PMS_W field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION13_R1_PMS_W field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R1_PMS_W_Msk = 0x20
	// Bit REGION13_R1_PMS_W.
	HP_APM_REGION13_PMS_ATTR_REGION13_R1_PMS_W = 0x20
	// Position of REGION13_R1_PMS_R field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION13_R1_PMS_R field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R1_PMS_R_Msk = 0x40
	// Bit REGION13_R1_PMS_R.
	HP_APM_REGION13_PMS_ATTR_REGION13_R1_PMS_R = 0x40
	// Position of REGION13_R2_PMS_X field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION13_R2_PMS_X field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R2_PMS_X_Msk = 0x100
	// Bit REGION13_R2_PMS_X.
	HP_APM_REGION13_PMS_ATTR_REGION13_R2_PMS_X = 0x100
	// Position of REGION13_R2_PMS_W field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION13_R2_PMS_W field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R2_PMS_W_Msk = 0x200
	// Bit REGION13_R2_PMS_W.
	HP_APM_REGION13_PMS_ATTR_REGION13_R2_PMS_W = 0x200
	// Position of REGION13_R2_PMS_R field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION13_R2_PMS_R field.
	HP_APM_REGION13_PMS_ATTR_REGION13_R2_PMS_R_Msk = 0x400
	// Bit REGION13_R2_PMS_R.
	HP_APM_REGION13_PMS_ATTR_REGION13_R2_PMS_R = 0x400

	// REGION14_ADDR_START: Region address register
	// Position of REGION14_ADDR_START field.
	HP_APM_REGION14_ADDR_START_REGION14_ADDR_START_Pos = 0x0
	// Bit mask of REGION14_ADDR_START field.
	HP_APM_REGION14_ADDR_START_REGION14_ADDR_START_Msk = 0xffffffff

	// REGION14_ADDR_END: Region address register
	// Position of REGION14_ADDR_END field.
	HP_APM_REGION14_ADDR_END_REGION14_ADDR_END_Pos = 0x0
	// Bit mask of REGION14_ADDR_END field.
	HP_APM_REGION14_ADDR_END_REGION14_ADDR_END_Msk = 0xffffffff

	// REGION14_PMS_ATTR: Region access authority attribute register
	// Position of REGION14_R0_PMS_X field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION14_R0_PMS_X field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R0_PMS_X_Msk = 0x1
	// Bit REGION14_R0_PMS_X.
	HP_APM_REGION14_PMS_ATTR_REGION14_R0_PMS_X = 0x1
	// Position of REGION14_R0_PMS_W field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION14_R0_PMS_W field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R0_PMS_W_Msk = 0x2
	// Bit REGION14_R0_PMS_W.
	HP_APM_REGION14_PMS_ATTR_REGION14_R0_PMS_W = 0x2
	// Position of REGION14_R0_PMS_R field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION14_R0_PMS_R field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R0_PMS_R_Msk = 0x4
	// Bit REGION14_R0_PMS_R.
	HP_APM_REGION14_PMS_ATTR_REGION14_R0_PMS_R = 0x4
	// Position of REGION14_R1_PMS_X field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION14_R1_PMS_X field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R1_PMS_X_Msk = 0x10
	// Bit REGION14_R1_PMS_X.
	HP_APM_REGION14_PMS_ATTR_REGION14_R1_PMS_X = 0x10
	// Position of REGION14_R1_PMS_W field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION14_R1_PMS_W field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R1_PMS_W_Msk = 0x20
	// Bit REGION14_R1_PMS_W.
	HP_APM_REGION14_PMS_ATTR_REGION14_R1_PMS_W = 0x20
	// Position of REGION14_R1_PMS_R field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION14_R1_PMS_R field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R1_PMS_R_Msk = 0x40
	// Bit REGION14_R1_PMS_R.
	HP_APM_REGION14_PMS_ATTR_REGION14_R1_PMS_R = 0x40
	// Position of REGION14_R2_PMS_X field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION14_R2_PMS_X field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R2_PMS_X_Msk = 0x100
	// Bit REGION14_R2_PMS_X.
	HP_APM_REGION14_PMS_ATTR_REGION14_R2_PMS_X = 0x100
	// Position of REGION14_R2_PMS_W field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION14_R2_PMS_W field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R2_PMS_W_Msk = 0x200
	// Bit REGION14_R2_PMS_W.
	HP_APM_REGION14_PMS_ATTR_REGION14_R2_PMS_W = 0x200
	// Position of REGION14_R2_PMS_R field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION14_R2_PMS_R field.
	HP_APM_REGION14_PMS_ATTR_REGION14_R2_PMS_R_Msk = 0x400
	// Bit REGION14_R2_PMS_R.
	HP_APM_REGION14_PMS_ATTR_REGION14_R2_PMS_R = 0x400

	// REGION15_ADDR_START: Region address register
	// Position of REGION15_ADDR_START field.
	HP_APM_REGION15_ADDR_START_REGION15_ADDR_START_Pos = 0x0
	// Bit mask of REGION15_ADDR_START field.
	HP_APM_REGION15_ADDR_START_REGION15_ADDR_START_Msk = 0xffffffff

	// REGION15_ADDR_END: Region address register
	// Position of REGION15_ADDR_END field.
	HP_APM_REGION15_ADDR_END_REGION15_ADDR_END_Pos = 0x0
	// Bit mask of REGION15_ADDR_END field.
	HP_APM_REGION15_ADDR_END_REGION15_ADDR_END_Msk = 0xffffffff

	// REGION15_PMS_ATTR: Region access authority attribute register
	// Position of REGION15_R0_PMS_X field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION15_R0_PMS_X field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R0_PMS_X_Msk = 0x1
	// Bit REGION15_R0_PMS_X.
	HP_APM_REGION15_PMS_ATTR_REGION15_R0_PMS_X = 0x1
	// Position of REGION15_R0_PMS_W field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION15_R0_PMS_W field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R0_PMS_W_Msk = 0x2
	// Bit REGION15_R0_PMS_W.
	HP_APM_REGION15_PMS_ATTR_REGION15_R0_PMS_W = 0x2
	// Position of REGION15_R0_PMS_R field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION15_R0_PMS_R field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R0_PMS_R_Msk = 0x4
	// Bit REGION15_R0_PMS_R.
	HP_APM_REGION15_PMS_ATTR_REGION15_R0_PMS_R = 0x4
	// Position of REGION15_R1_PMS_X field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION15_R1_PMS_X field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R1_PMS_X_Msk = 0x10
	// Bit REGION15_R1_PMS_X.
	HP_APM_REGION15_PMS_ATTR_REGION15_R1_PMS_X = 0x10
	// Position of REGION15_R1_PMS_W field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION15_R1_PMS_W field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R1_PMS_W_Msk = 0x20
	// Bit REGION15_R1_PMS_W.
	HP_APM_REGION15_PMS_ATTR_REGION15_R1_PMS_W = 0x20
	// Position of REGION15_R1_PMS_R field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION15_R1_PMS_R field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R1_PMS_R_Msk = 0x40
	// Bit REGION15_R1_PMS_R.
	HP_APM_REGION15_PMS_ATTR_REGION15_R1_PMS_R = 0x40
	// Position of REGION15_R2_PMS_X field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION15_R2_PMS_X field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R2_PMS_X_Msk = 0x100
	// Bit REGION15_R2_PMS_X.
	HP_APM_REGION15_PMS_ATTR_REGION15_R2_PMS_X = 0x100
	// Position of REGION15_R2_PMS_W field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION15_R2_PMS_W field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R2_PMS_W_Msk = 0x200
	// Bit REGION15_R2_PMS_W.
	HP_APM_REGION15_PMS_ATTR_REGION15_R2_PMS_W = 0x200
	// Position of REGION15_R2_PMS_R field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION15_R2_PMS_R field.
	HP_APM_REGION15_PMS_ATTR_REGION15_R2_PMS_R_Msk = 0x400
	// Bit REGION15_R2_PMS_R.
	HP_APM_REGION15_PMS_ATTR_REGION15_R2_PMS_R = 0x400

	// FUNC_CTRL: PMS function control register
	// Position of M0_PMS_FUNC_EN field.
	HP_APM_FUNC_CTRL_M0_PMS_FUNC_EN_Pos = 0x0
	// Bit mask of M0_PMS_FUNC_EN field.
	HP_APM_FUNC_CTRL_M0_PMS_FUNC_EN_Msk = 0x1
	// Bit M0_PMS_FUNC_EN.
	HP_APM_FUNC_CTRL_M0_PMS_FUNC_EN = 0x1
	// Position of M1_PMS_FUNC_EN field.
	HP_APM_FUNC_CTRL_M1_PMS_FUNC_EN_Pos = 0x1
	// Bit mask of M1_PMS_FUNC_EN field.
	HP_APM_FUNC_CTRL_M1_PMS_FUNC_EN_Msk = 0x2
	// Bit M1_PMS_FUNC_EN.
	HP_APM_FUNC_CTRL_M1_PMS_FUNC_EN = 0x2
	// Position of M2_PMS_FUNC_EN field.
	HP_APM_FUNC_CTRL_M2_PMS_FUNC_EN_Pos = 0x2
	// Bit mask of M2_PMS_FUNC_EN field.
	HP_APM_FUNC_CTRL_M2_PMS_FUNC_EN_Msk = 0x4
	// Bit M2_PMS_FUNC_EN.
	HP_APM_FUNC_CTRL_M2_PMS_FUNC_EN = 0x4
	// Position of M3_PMS_FUNC_EN field.
	HP_APM_FUNC_CTRL_M3_PMS_FUNC_EN_Pos = 0x3
	// Bit mask of M3_PMS_FUNC_EN field.
	HP_APM_FUNC_CTRL_M3_PMS_FUNC_EN_Msk = 0x8
	// Bit M3_PMS_FUNC_EN.
	HP_APM_FUNC_CTRL_M3_PMS_FUNC_EN = 0x8

	// M0_STATUS: M0 status register
	// Position of M0_EXCEPTION_STATUS field.
	HP_APM_M0_STATUS_M0_EXCEPTION_STATUS_Pos = 0x0
	// Bit mask of M0_EXCEPTION_STATUS field.
	HP_APM_M0_STATUS_M0_EXCEPTION_STATUS_Msk = 0x3

	// M0_STATUS_CLR: M0 status clear register
	// Position of M0_REGION_STATUS_CLR field.
	HP_APM_M0_STATUS_CLR_M0_REGION_STATUS_CLR_Pos = 0x0
	// Bit mask of M0_REGION_STATUS_CLR field.
	HP_APM_M0_STATUS_CLR_M0_REGION_STATUS_CLR_Msk = 0x1
	// Bit M0_REGION_STATUS_CLR.
	HP_APM_M0_STATUS_CLR_M0_REGION_STATUS_CLR = 0x1

	// M0_EXCEPTION_INFO0: M0 exception_info0 register
	// Position of M0_EXCEPTION_REGION field.
	HP_APM_M0_EXCEPTION_INFO0_M0_EXCEPTION_REGION_Pos = 0x0
	// Bit mask of M0_EXCEPTION_REGION field.
	HP_APM_M0_EXCEPTION_INFO0_M0_EXCEPTION_REGION_Msk = 0xffff
	// Position of M0_EXCEPTION_MODE field.
	HP_APM_M0_EXCEPTION_INFO0_M0_EXCEPTION_MODE_Pos = 0x10
	// Bit mask of M0_EXCEPTION_MODE field.
	HP_APM_M0_EXCEPTION_INFO0_M0_EXCEPTION_MODE_Msk = 0x30000
	// Position of M0_EXCEPTION_ID field.
	HP_APM_M0_EXCEPTION_INFO0_M0_EXCEPTION_ID_Pos = 0x12
	// Bit mask of M0_EXCEPTION_ID field.
	HP_APM_M0_EXCEPTION_INFO0_M0_EXCEPTION_ID_Msk = 0x7c0000

	// M0_EXCEPTION_INFO1: M0 exception_info1 register
	// Position of M0_EXCEPTION_ADDR field.
	HP_APM_M0_EXCEPTION_INFO1_M0_EXCEPTION_ADDR_Pos = 0x0
	// Bit mask of M0_EXCEPTION_ADDR field.
	HP_APM_M0_EXCEPTION_INFO1_M0_EXCEPTION_ADDR_Msk = 0xffffffff

	// M1_STATUS: M1 status register
	// Position of M1_EXCEPTION_STATUS field.
	HP_APM_M1_STATUS_M1_EXCEPTION_STATUS_Pos = 0x0
	// Bit mask of M1_EXCEPTION_STATUS field.
	HP_APM_M1_STATUS_M1_EXCEPTION_STATUS_Msk = 0x3

	// M1_STATUS_CLR: M1 status clear register
	// Position of M1_REGION_STATUS_CLR field.
	HP_APM_M1_STATUS_CLR_M1_REGION_STATUS_CLR_Pos = 0x0
	// Bit mask of M1_REGION_STATUS_CLR field.
	HP_APM_M1_STATUS_CLR_M1_REGION_STATUS_CLR_Msk = 0x1
	// Bit M1_REGION_STATUS_CLR.
	HP_APM_M1_STATUS_CLR_M1_REGION_STATUS_CLR = 0x1

	// M1_EXCEPTION_INFO0: M1 exception_info0 register
	// Position of M1_EXCEPTION_REGION field.
	HP_APM_M1_EXCEPTION_INFO0_M1_EXCEPTION_REGION_Pos = 0x0
	// Bit mask of M1_EXCEPTION_REGION field.
	HP_APM_M1_EXCEPTION_INFO0_M1_EXCEPTION_REGION_Msk = 0xffff
	// Position of M1_EXCEPTION_MODE field.
	HP_APM_M1_EXCEPTION_INFO0_M1_EXCEPTION_MODE_Pos = 0x10
	// Bit mask of M1_EXCEPTION_MODE field.
	HP_APM_M1_EXCEPTION_INFO0_M1_EXCEPTION_MODE_Msk = 0x30000
	// Position of M1_EXCEPTION_ID field.
	HP_APM_M1_EXCEPTION_INFO0_M1_EXCEPTION_ID_Pos = 0x12
	// Bit mask of M1_EXCEPTION_ID field.
	HP_APM_M1_EXCEPTION_INFO0_M1_EXCEPTION_ID_Msk = 0x7c0000

	// M1_EXCEPTION_INFO1: M1 exception_info1 register
	// Position of M1_EXCEPTION_ADDR field.
	HP_APM_M1_EXCEPTION_INFO1_M1_EXCEPTION_ADDR_Pos = 0x0
	// Bit mask of M1_EXCEPTION_ADDR field.
	HP_APM_M1_EXCEPTION_INFO1_M1_EXCEPTION_ADDR_Msk = 0xffffffff

	// M2_STATUS: M2 status register
	// Position of M2_EXCEPTION_STATUS field.
	HP_APM_M2_STATUS_M2_EXCEPTION_STATUS_Pos = 0x0
	// Bit mask of M2_EXCEPTION_STATUS field.
	HP_APM_M2_STATUS_M2_EXCEPTION_STATUS_Msk = 0x3

	// M2_STATUS_CLR: M2 status clear register
	// Position of M2_REGION_STATUS_CLR field.
	HP_APM_M2_STATUS_CLR_M2_REGION_STATUS_CLR_Pos = 0x0
	// Bit mask of M2_REGION_STATUS_CLR field.
	HP_APM_M2_STATUS_CLR_M2_REGION_STATUS_CLR_Msk = 0x1
	// Bit M2_REGION_STATUS_CLR.
	HP_APM_M2_STATUS_CLR_M2_REGION_STATUS_CLR = 0x1

	// M2_EXCEPTION_INFO0: M2 exception_info0 register
	// Position of M2_EXCEPTION_REGION field.
	HP_APM_M2_EXCEPTION_INFO0_M2_EXCEPTION_REGION_Pos = 0x0
	// Bit mask of M2_EXCEPTION_REGION field.
	HP_APM_M2_EXCEPTION_INFO0_M2_EXCEPTION_REGION_Msk = 0xffff
	// Position of M2_EXCEPTION_MODE field.
	HP_APM_M2_EXCEPTION_INFO0_M2_EXCEPTION_MODE_Pos = 0x10
	// Bit mask of M2_EXCEPTION_MODE field.
	HP_APM_M2_EXCEPTION_INFO0_M2_EXCEPTION_MODE_Msk = 0x30000
	// Position of M2_EXCEPTION_ID field.
	HP_APM_M2_EXCEPTION_INFO0_M2_EXCEPTION_ID_Pos = 0x12
	// Bit mask of M2_EXCEPTION_ID field.
	HP_APM_M2_EXCEPTION_INFO0_M2_EXCEPTION_ID_Msk = 0x7c0000

	// M2_EXCEPTION_INFO1: M2 exception_info1 register
	// Position of M2_EXCEPTION_ADDR field.
	HP_APM_M2_EXCEPTION_INFO1_M2_EXCEPTION_ADDR_Pos = 0x0
	// Bit mask of M2_EXCEPTION_ADDR field.
	HP_APM_M2_EXCEPTION_INFO1_M2_EXCEPTION_ADDR_Msk = 0xffffffff

	// M3_STATUS: M3 status register
	// Position of M3_EXCEPTION_STATUS field.
	HP_APM_M3_STATUS_M3_EXCEPTION_STATUS_Pos = 0x0
	// Bit mask of M3_EXCEPTION_STATUS field.
	HP_APM_M3_STATUS_M3_EXCEPTION_STATUS_Msk = 0x3

	// M3_STATUS_CLR: M3 status clear register
	// Position of M3_REGION_STATUS_CLR field.
	HP_APM_M3_STATUS_CLR_M3_REGION_STATUS_CLR_Pos = 0x0
	// Bit mask of M3_REGION_STATUS_CLR field.
	HP_APM_M3_STATUS_CLR_M3_REGION_STATUS_CLR_Msk = 0x1
	// Bit M3_REGION_STATUS_CLR.
	HP_APM_M3_STATUS_CLR_M3_REGION_STATUS_CLR = 0x1

	// M3_EXCEPTION_INFO0: M3 exception_info0 register
	// Position of M3_EXCEPTION_REGION field.
	HP_APM_M3_EXCEPTION_INFO0_M3_EXCEPTION_REGION_Pos = 0x0
	// Bit mask of M3_EXCEPTION_REGION field.
	HP_APM_M3_EXCEPTION_INFO0_M3_EXCEPTION_REGION_Msk = 0xffff
	// Position of M3_EXCEPTION_MODE field.
	HP_APM_M3_EXCEPTION_INFO0_M3_EXCEPTION_MODE_Pos = 0x10
	// Bit mask of M3_EXCEPTION_MODE field.
	HP_APM_M3_EXCEPTION_INFO0_M3_EXCEPTION_MODE_Msk = 0x30000
	// Position of M3_EXCEPTION_ID field.
	HP_APM_M3_EXCEPTION_INFO0_M3_EXCEPTION_ID_Pos = 0x12
	// Bit mask of M3_EXCEPTION_ID field.
	HP_APM_M3_EXCEPTION_INFO0_M3_EXCEPTION_ID_Msk = 0x7c0000

	// M3_EXCEPTION_INFO1: M3 exception_info1 register
	// Position of M3_EXCEPTION_ADDR field.
	HP_APM_M3_EXCEPTION_INFO1_M3_EXCEPTION_ADDR_Pos = 0x0
	// Bit mask of M3_EXCEPTION_ADDR field.
	HP_APM_M3_EXCEPTION_INFO1_M3_EXCEPTION_ADDR_Msk = 0xffffffff

	// INT_EN: APM interrupt enable register
	// Position of M0_APM_INT_EN field.
	HP_APM_INT_EN_M0_APM_INT_EN_Pos = 0x0
	// Bit mask of M0_APM_INT_EN field.
	HP_APM_INT_EN_M0_APM_INT_EN_Msk = 0x1
	// Bit M0_APM_INT_EN.
	HP_APM_INT_EN_M0_APM_INT_EN = 0x1
	// Position of M1_APM_INT_EN field.
	HP_APM_INT_EN_M1_APM_INT_EN_Pos = 0x1
	// Bit mask of M1_APM_INT_EN field.
	HP_APM_INT_EN_M1_APM_INT_EN_Msk = 0x2
	// Bit M1_APM_INT_EN.
	HP_APM_INT_EN_M1_APM_INT_EN = 0x2
	// Position of M2_APM_INT_EN field.
	HP_APM_INT_EN_M2_APM_INT_EN_Pos = 0x2
	// Bit mask of M2_APM_INT_EN field.
	HP_APM_INT_EN_M2_APM_INT_EN_Msk = 0x4
	// Bit M2_APM_INT_EN.
	HP_APM_INT_EN_M2_APM_INT_EN = 0x4
	// Position of M3_APM_INT_EN field.
	HP_APM_INT_EN_M3_APM_INT_EN_Pos = 0x3
	// Bit mask of M3_APM_INT_EN field.
	HP_APM_INT_EN_M3_APM_INT_EN_Msk = 0x8
	// Bit M3_APM_INT_EN.
	HP_APM_INT_EN_M3_APM_INT_EN = 0x8

	// CLOCK_GATE: clock gating register
	// Position of CLK_EN field.
	HP_APM_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	HP_APM_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	HP_APM_CLOCK_GATE_CLK_EN = 0x1

	// DATE: Version register
	// Position of DATE field.
	HP_APM_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	HP_APM_DATE_DATE_Msk = 0xfffffff
)

// Constants for HP_SYS: High-Power System
const (
	// EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL: EXTERNAL DEVICE ENCRYPTION/DECRYPTION configuration register
	// Position of ENABLE_SPI_MANUAL_ENCRYPT field.
	HP_SYS_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT_Pos = 0x0
	// Bit mask of ENABLE_SPI_MANUAL_ENCRYPT field.
	HP_SYS_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT_Msk = 0x1
	// Bit ENABLE_SPI_MANUAL_ENCRYPT.
	HP_SYS_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT = 0x1
	// Position of ENABLE_DOWNLOAD_DB_ENCRYPT field.
	HP_SYS_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT_Pos = 0x1
	// Bit mask of ENABLE_DOWNLOAD_DB_ENCRYPT field.
	HP_SYS_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT_Msk = 0x2
	// Bit ENABLE_DOWNLOAD_DB_ENCRYPT.
	HP_SYS_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT = 0x2
	// Position of ENABLE_DOWNLOAD_G0CB_DECRYPT field.
	HP_SYS_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT_Pos = 0x2
	// Bit mask of ENABLE_DOWNLOAD_G0CB_DECRYPT field.
	HP_SYS_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT_Msk = 0x4
	// Bit ENABLE_DOWNLOAD_G0CB_DECRYPT.
	HP_SYS_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT = 0x4
	// Position of ENABLE_DOWNLOAD_MANUAL_ENCRYPT field.
	HP_SYS_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT_Pos = 0x3
	// Bit mask of ENABLE_DOWNLOAD_MANUAL_ENCRYPT field.
	HP_SYS_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT_Msk = 0x8
	// Bit ENABLE_DOWNLOAD_MANUAL_ENCRYPT.
	HP_SYS_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT = 0x8

	// SRAM_USAGE_CONF: HP memory usage configuration register
	// Position of SRAM_USAGE field.
	HP_SYS_SRAM_USAGE_CONF_SRAM_USAGE_Pos = 0xa
	// Bit mask of SRAM_USAGE field.
	HP_SYS_SRAM_USAGE_CONF_SRAM_USAGE_Msk = 0x7c00
	// Position of MAC_DUMP_ALLOC field.
	HP_SYS_SRAM_USAGE_CONF_MAC_DUMP_ALLOC_Pos = 0x14
	// Bit mask of MAC_DUMP_ALLOC field.
	HP_SYS_SRAM_USAGE_CONF_MAC_DUMP_ALLOC_Msk = 0x1f00000
	// Position of CACHE_USAGE field.
	HP_SYS_SRAM_USAGE_CONF_CACHE_USAGE_Pos = 0x1f
	// Bit mask of CACHE_USAGE field.
	HP_SYS_SRAM_USAGE_CONF_CACHE_USAGE_Msk = 0x80000000
	// Bit CACHE_USAGE.
	HP_SYS_SRAM_USAGE_CONF_CACHE_USAGE = 0x80000000

	// SEC_DPA_CONF: HP anti-DPA security configuration register
	// Position of SEC_DPA_LEVEL field.
	HP_SYS_SEC_DPA_CONF_SEC_DPA_LEVEL_Pos = 0x0
	// Bit mask of SEC_DPA_LEVEL field.
	HP_SYS_SEC_DPA_CONF_SEC_DPA_LEVEL_Msk = 0x3
	// Position of SEC_DPA_CFG_SEL field.
	HP_SYS_SEC_DPA_CONF_SEC_DPA_CFG_SEL_Pos = 0x2
	// Bit mask of SEC_DPA_CFG_SEL field.
	HP_SYS_SEC_DPA_CONF_SEC_DPA_CFG_SEL_Msk = 0x4
	// Bit SEC_DPA_CFG_SEL.
	HP_SYS_SEC_DPA_CONF_SEC_DPA_CFG_SEL = 0x4

	// CPU_PERI_TIMEOUT_CONF: CPU_PERI_TIMEOUT configuration register
	// Position of CPU_PERI_TIMEOUT_THRES field.
	HP_SYS_CPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_THRES_Pos = 0x0
	// Bit mask of CPU_PERI_TIMEOUT_THRES field.
	HP_SYS_CPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_THRES_Msk = 0xffff
	// Position of CPU_PERI_TIMEOUT_INT_CLEAR field.
	HP_SYS_CPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_INT_CLEAR_Pos = 0x10
	// Bit mask of CPU_PERI_TIMEOUT_INT_CLEAR field.
	HP_SYS_CPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_INT_CLEAR_Msk = 0x10000
	// Bit CPU_PERI_TIMEOUT_INT_CLEAR.
	HP_SYS_CPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_INT_CLEAR = 0x10000
	// Position of CPU_PERI_TIMEOUT_PROTECT_EN field.
	HP_SYS_CPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_PROTECT_EN_Pos = 0x11
	// Bit mask of CPU_PERI_TIMEOUT_PROTECT_EN field.
	HP_SYS_CPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_PROTECT_EN_Msk = 0x20000
	// Bit CPU_PERI_TIMEOUT_PROTECT_EN.
	HP_SYS_CPU_PERI_TIMEOUT_CONF_CPU_PERI_TIMEOUT_PROTECT_EN = 0x20000

	// CPU_PERI_TIMEOUT_ADDR: CPU_PERI_TIMEOUT_ADDR register
	// Position of CPU_PERI_TIMEOUT_ADDR field.
	HP_SYS_CPU_PERI_TIMEOUT_ADDR_CPU_PERI_TIMEOUT_ADDR_Pos = 0x0
	// Bit mask of CPU_PERI_TIMEOUT_ADDR field.
	HP_SYS_CPU_PERI_TIMEOUT_ADDR_CPU_PERI_TIMEOUT_ADDR_Msk = 0xffffffff

	// CPU_PERI_TIMEOUT_UID: CPU_PERI_TIMEOUT_UID register
	// Position of CPU_PERI_TIMEOUT_UID field.
	HP_SYS_CPU_PERI_TIMEOUT_UID_CPU_PERI_TIMEOUT_UID_Pos = 0x0
	// Bit mask of CPU_PERI_TIMEOUT_UID field.
	HP_SYS_CPU_PERI_TIMEOUT_UID_CPU_PERI_TIMEOUT_UID_Msk = 0x7f

	// HP_PERI_TIMEOUT_CONF: HP_PERI_TIMEOUT configuration register
	// Position of HP_PERI_TIMEOUT_THRES field.
	HP_SYS_HP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_THRES_Pos = 0x0
	// Bit mask of HP_PERI_TIMEOUT_THRES field.
	HP_SYS_HP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_THRES_Msk = 0xffff
	// Position of HP_PERI_TIMEOUT_INT_CLEAR field.
	HP_SYS_HP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_INT_CLEAR_Pos = 0x10
	// Bit mask of HP_PERI_TIMEOUT_INT_CLEAR field.
	HP_SYS_HP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_INT_CLEAR_Msk = 0x10000
	// Bit HP_PERI_TIMEOUT_INT_CLEAR.
	HP_SYS_HP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_INT_CLEAR = 0x10000
	// Position of HP_PERI_TIMEOUT_PROTECT_EN field.
	HP_SYS_HP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_PROTECT_EN_Pos = 0x11
	// Bit mask of HP_PERI_TIMEOUT_PROTECT_EN field.
	HP_SYS_HP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_PROTECT_EN_Msk = 0x20000
	// Bit HP_PERI_TIMEOUT_PROTECT_EN.
	HP_SYS_HP_PERI_TIMEOUT_CONF_HP_PERI_TIMEOUT_PROTECT_EN = 0x20000

	// HP_PERI_TIMEOUT_ADDR: HP_PERI_TIMEOUT_ADDR register
	// Position of HP_PERI_TIMEOUT_ADDR field.
	HP_SYS_HP_PERI_TIMEOUT_ADDR_HP_PERI_TIMEOUT_ADDR_Pos = 0x0
	// Bit mask of HP_PERI_TIMEOUT_ADDR field.
	HP_SYS_HP_PERI_TIMEOUT_ADDR_HP_PERI_TIMEOUT_ADDR_Msk = 0xffffffff

	// HP_PERI_TIMEOUT_UID: HP_PERI_TIMEOUT_UID register
	// Position of HP_PERI_TIMEOUT_UID field.
	HP_SYS_HP_PERI_TIMEOUT_UID_HP_PERI_TIMEOUT_UID_Pos = 0x0
	// Bit mask of HP_PERI_TIMEOUT_UID field.
	HP_SYS_HP_PERI_TIMEOUT_UID_HP_PERI_TIMEOUT_UID_Msk = 0x7f

	// ROM_TABLE_LOCK: Rom-Table lock register
	// Position of ROM_TABLE_LOCK field.
	HP_SYS_ROM_TABLE_LOCK_ROM_TABLE_LOCK_Pos = 0x0
	// Bit mask of ROM_TABLE_LOCK field.
	HP_SYS_ROM_TABLE_LOCK_ROM_TABLE_LOCK_Msk = 0x1
	// Bit ROM_TABLE_LOCK.
	HP_SYS_ROM_TABLE_LOCK_ROM_TABLE_LOCK = 0x1

	// ROM_TABLE: Rom-Table register
	// Position of ROM_TABLE field.
	HP_SYS_ROM_TABLE_ROM_TABLE_Pos = 0x0
	// Bit mask of ROM_TABLE field.
	HP_SYS_ROM_TABLE_ROM_TABLE_Msk = 0xffffffff

	// MEM_TEST_CONF: MEM_TEST configuration register
	// Position of HP_MEM_WPULSE field.
	HP_SYS_MEM_TEST_CONF_HP_MEM_WPULSE_Pos = 0x0
	// Bit mask of HP_MEM_WPULSE field.
	HP_SYS_MEM_TEST_CONF_HP_MEM_WPULSE_Msk = 0x7
	// Position of HP_MEM_WA field.
	HP_SYS_MEM_TEST_CONF_HP_MEM_WA_Pos = 0x3
	// Bit mask of HP_MEM_WA field.
	HP_SYS_MEM_TEST_CONF_HP_MEM_WA_Msk = 0x38
	// Position of HP_MEM_RA field.
	HP_SYS_MEM_TEST_CONF_HP_MEM_RA_Pos = 0x6
	// Bit mask of HP_MEM_RA field.
	HP_SYS_MEM_TEST_CONF_HP_MEM_RA_Msk = 0xc0
	// Position of HP_MEM_RM field.
	HP_SYS_MEM_TEST_CONF_HP_MEM_RM_Pos = 0x8
	// Bit mask of HP_MEM_RM field.
	HP_SYS_MEM_TEST_CONF_HP_MEM_RM_Msk = 0xf00
	// Position of ROM_RM field.
	HP_SYS_MEM_TEST_CONF_ROM_RM_Pos = 0xc
	// Bit mask of ROM_RM field.
	HP_SYS_MEM_TEST_CONF_ROM_RM_Msk = 0xf000

	// RND_ECO: redcy eco register.
	// Position of REDCY_ENA field.
	HP_SYS_RND_ECO_REDCY_ENA_Pos = 0x0
	// Bit mask of REDCY_ENA field.
	HP_SYS_RND_ECO_REDCY_ENA_Msk = 0x1
	// Bit REDCY_ENA.
	HP_SYS_RND_ECO_REDCY_ENA = 0x1
	// Position of REDCY_RESULT field.
	HP_SYS_RND_ECO_REDCY_RESULT_Pos = 0x1
	// Bit mask of REDCY_RESULT field.
	HP_SYS_RND_ECO_REDCY_RESULT_Msk = 0x2
	// Bit REDCY_RESULT.
	HP_SYS_RND_ECO_REDCY_RESULT = 0x2

	// RND_ECO_LOW: redcy eco low register.
	// Position of REDCY_LOW field.
	HP_SYS_RND_ECO_LOW_REDCY_LOW_Pos = 0x0
	// Bit mask of REDCY_LOW field.
	HP_SYS_RND_ECO_LOW_REDCY_LOW_Msk = 0xffffffff

	// RND_ECO_HIGH: redcy eco high register.
	// Position of REDCY_HIGH field.
	HP_SYS_RND_ECO_HIGH_REDCY_HIGH_Pos = 0x0
	// Bit mask of REDCY_HIGH field.
	HP_SYS_RND_ECO_HIGH_REDCY_HIGH_Msk = 0xffffffff

	// CLOCK_GATE: HP-SYSTEM clock gating configure register
	// Position of CLK_EN field.
	HP_SYS_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	HP_SYS_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	HP_SYS_CLOCK_GATE_CLK_EN = 0x1

	// DATE: Date register.
	// Position of DATE field.
	HP_SYS_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	HP_SYS_DATE_DATE_Msk = 0xfffffff
)

// Constants for I2C0: I2C (Inter-Integrated Circuit) Controller 0
const (
	// SCL_LOW_PERIOD: Configures the low level width of the SCL Clock
	// Position of SCL_LOW_PERIOD field.
	I2C_SCL_LOW_PERIOD_SCL_LOW_PERIOD_Pos = 0x0
	// Bit mask of SCL_LOW_PERIOD field.
	I2C_SCL_LOW_PERIOD_SCL_LOW_PERIOD_Msk = 0x1ff

	// CTR: Transmission setting
	// Position of SDA_FORCE_OUT field.
	I2C_CTR_SDA_FORCE_OUT_Pos = 0x0
	// Bit mask of SDA_FORCE_OUT field.
	I2C_CTR_SDA_FORCE_OUT_Msk = 0x1
	// Bit SDA_FORCE_OUT.
	I2C_CTR_SDA_FORCE_OUT = 0x1
	// Position of SCL_FORCE_OUT field.
	I2C_CTR_SCL_FORCE_OUT_Pos = 0x1
	// Bit mask of SCL_FORCE_OUT field.
	I2C_CTR_SCL_FORCE_OUT_Msk = 0x2
	// Bit SCL_FORCE_OUT.
	I2C_CTR_SCL_FORCE_OUT = 0x2
	// Position of SAMPLE_SCL_LEVEL field.
	I2C_CTR_SAMPLE_SCL_LEVEL_Pos = 0x2
	// Bit mask of SAMPLE_SCL_LEVEL field.
	I2C_CTR_SAMPLE_SCL_LEVEL_Msk = 0x4
	// Bit SAMPLE_SCL_LEVEL.
	I2C_CTR_SAMPLE_SCL_LEVEL = 0x4
	// Position of RX_FULL_ACK_LEVEL field.
	I2C_CTR_RX_FULL_ACK_LEVEL_Pos = 0x3
	// Bit mask of RX_FULL_ACK_LEVEL field.
	I2C_CTR_RX_FULL_ACK_LEVEL_Msk = 0x8
	// Bit RX_FULL_ACK_LEVEL.
	I2C_CTR_RX_FULL_ACK_LEVEL = 0x8
	// Position of MS_MODE field.
	I2C_CTR_MS_MODE_Pos = 0x4
	// Bit mask of MS_MODE field.
	I2C_CTR_MS_MODE_Msk = 0x10
	// Bit MS_MODE.
	I2C_CTR_MS_MODE = 0x10
	// Position of TRANS_START field.
	I2C_CTR_TRANS_START_Pos = 0x5
	// Bit mask of TRANS_START field.
	I2C_CTR_TRANS_START_Msk = 0x20
	// Bit TRANS_START.
	I2C_CTR_TRANS_START = 0x20
	// Position of TX_LSB_FIRST field.
	I2C_CTR_TX_LSB_FIRST_Pos = 0x6
	// Bit mask of TX_LSB_FIRST field.
	I2C_CTR_TX_LSB_FIRST_Msk = 0x40
	// Bit TX_LSB_FIRST.
	I2C_CTR_TX_LSB_FIRST = 0x40
	// Position of RX_LSB_FIRST field.
	I2C_CTR_RX_LSB_FIRST_Pos = 0x7
	// Bit mask of RX_LSB_FIRST field.
	I2C_CTR_RX_LSB_FIRST_Msk = 0x80
	// Bit RX_LSB_FIRST.
	I2C_CTR_RX_LSB_FIRST = 0x80
	// Position of CLK_EN field.
	I2C_CTR_CLK_EN_Pos = 0x8
	// Bit mask of CLK_EN field.
	I2C_CTR_CLK_EN_Msk = 0x100
	// Bit CLK_EN.
	I2C_CTR_CLK_EN = 0x100
	// Position of ARBITRATION_EN field.
	I2C_CTR_ARBITRATION_EN_Pos = 0x9
	// Bit mask of ARBITRATION_EN field.
	I2C_CTR_ARBITRATION_EN_Msk = 0x200
	// Bit ARBITRATION_EN.
	I2C_CTR_ARBITRATION_EN = 0x200
	// Position of FSM_RST field.
	I2C_CTR_FSM_RST_Pos = 0xa
	// Bit mask of FSM_RST field.
	I2C_CTR_FSM_RST_Msk = 0x400
	// Bit FSM_RST.
	I2C_CTR_FSM_RST = 0x400
	// Position of CONF_UPGATE field.
	I2C_CTR_CONF_UPGATE_Pos = 0xb
	// Bit mask of CONF_UPGATE field.
	I2C_CTR_CONF_UPGATE_Msk = 0x800
	// Bit CONF_UPGATE.
	I2C_CTR_CONF_UPGATE = 0x800
	// Position of SLV_TX_AUTO_START_EN field.
	I2C_CTR_SLV_TX_AUTO_START_EN_Pos = 0xc
	// Bit mask of SLV_TX_AUTO_START_EN field.
	I2C_CTR_SLV_TX_AUTO_START_EN_Msk = 0x1000
	// Bit SLV_TX_AUTO_START_EN.
	I2C_CTR_SLV_TX_AUTO_START_EN = 0x1000
	// Position of ADDR_10BIT_RW_CHECK_EN field.
	I2C_CTR_ADDR_10BIT_RW_CHECK_EN_Pos = 0xd
	// Bit mask of ADDR_10BIT_RW_CHECK_EN field.
	I2C_CTR_ADDR_10BIT_RW_CHECK_EN_Msk = 0x2000
	// Bit ADDR_10BIT_RW_CHECK_EN.
	I2C_CTR_ADDR_10BIT_RW_CHECK_EN = 0x2000
	// Position of ADDR_BROADCASTING_EN field.
	I2C_CTR_ADDR_BROADCASTING_EN_Pos = 0xe
	// Bit mask of ADDR_BROADCASTING_EN field.
	I2C_CTR_ADDR_BROADCASTING_EN_Msk = 0x4000
	// Bit ADDR_BROADCASTING_EN.
	I2C_CTR_ADDR_BROADCASTING_EN = 0x4000

	// SR: Describe I2C work status.
	// Position of RESP_REC field.
	I2C_SR_RESP_REC_Pos = 0x0
	// Bit mask of RESP_REC field.
	I2C_SR_RESP_REC_Msk = 0x1
	// Bit RESP_REC.
	I2C_SR_RESP_REC = 0x1
	// Position of SLAVE_RW field.
	I2C_SR_SLAVE_RW_Pos = 0x1
	// Bit mask of SLAVE_RW field.
	I2C_SR_SLAVE_RW_Msk = 0x2
	// Bit SLAVE_RW.
	I2C_SR_SLAVE_RW = 0x2
	// Position of ARB_LOST field.
	I2C_SR_ARB_LOST_Pos = 0x3
	// Bit mask of ARB_LOST field.
	I2C_SR_ARB_LOST_Msk = 0x8
	// Bit ARB_LOST.
	I2C_SR_ARB_LOST = 0x8
	// Position of BUS_BUSY field.
	I2C_SR_BUS_BUSY_Pos = 0x4
	// Bit mask of BUS_BUSY field.
	I2C_SR_BUS_BUSY_Msk = 0x10
	// Bit BUS_BUSY.
	I2C_SR_BUS_BUSY = 0x10
	// Position of SLAVE_ADDRESSED field.
	I2C_SR_SLAVE_ADDRESSED_Pos = 0x5
	// Bit mask of SLAVE_ADDRESSED field.
	I2C_SR_SLAVE_ADDRESSED_Msk = 0x20
	// Bit SLAVE_ADDRESSED.
	I2C_SR_SLAVE_ADDRESSED = 0x20
	// Position of RXFIFO_CNT field.
	I2C_SR_RXFIFO_CNT_Pos = 0x8
	// Bit mask of RXFIFO_CNT field.
	I2C_SR_RXFIFO_CNT_Msk = 0x3f00
	// Position of STRETCH_CAUSE field.
	I2C_SR_STRETCH_CAUSE_Pos = 0xe
	// Bit mask of STRETCH_CAUSE field.
	I2C_SR_STRETCH_CAUSE_Msk = 0xc000
	// Position of TXFIFO_CNT field.
	I2C_SR_TXFIFO_CNT_Pos = 0x12
	// Bit mask of TXFIFO_CNT field.
	I2C_SR_TXFIFO_CNT_Msk = 0xfc0000
	// Position of SCL_MAIN_STATE_LAST field.
	I2C_SR_SCL_MAIN_STATE_LAST_Pos = 0x18
	// Bit mask of SCL_MAIN_STATE_LAST field.
	I2C_SR_SCL_MAIN_STATE_LAST_Msk = 0x7000000
	// Position of SCL_STATE_LAST field.
	I2C_SR_SCL_STATE_LAST_Pos = 0x1c
	// Bit mask of SCL_STATE_LAST field.
	I2C_SR_SCL_STATE_LAST_Msk = 0x70000000

	// TO: Setting time out control for receiving data.
	// Position of TIME_OUT_VALUE field.
	I2C_TO_TIME_OUT_VALUE_Pos = 0x0
	// Bit mask of TIME_OUT_VALUE field.
	I2C_TO_TIME_OUT_VALUE_Msk = 0x1f
	// Position of TIME_OUT_EN field.
	I2C_TO_TIME_OUT_EN_Pos = 0x5
	// Bit mask of TIME_OUT_EN field.
	I2C_TO_TIME_OUT_EN_Msk = 0x20
	// Bit TIME_OUT_EN.
	I2C_TO_TIME_OUT_EN = 0x20

	// SLAVE_ADDR: Local slave address setting
	// Position of SLAVE_ADDR field.
	I2C_SLAVE_ADDR_SLAVE_ADDR_Pos = 0x0
	// Bit mask of SLAVE_ADDR field.
	I2C_SLAVE_ADDR_SLAVE_ADDR_Msk = 0x7fff
	// Position of ADDR_10BIT_EN field.
	I2C_SLAVE_ADDR_ADDR_10BIT_EN_Pos = 0x1f
	// Bit mask of ADDR_10BIT_EN field.
	I2C_SLAVE_ADDR_ADDR_10BIT_EN_Msk = 0x80000000
	// Bit ADDR_10BIT_EN.
	I2C_SLAVE_ADDR_ADDR_10BIT_EN = 0x80000000

	// FIFO_ST: FIFO status register.
	// Position of RXFIFO_RADDR field.
	I2C_FIFO_ST_RXFIFO_RADDR_Pos = 0x0
	// Bit mask of RXFIFO_RADDR field.
	I2C_FIFO_ST_RXFIFO_RADDR_Msk = 0x1f
	// Position of RXFIFO_WADDR field.
	I2C_FIFO_ST_RXFIFO_WADDR_Pos = 0x5
	// Bit mask of RXFIFO_WADDR field.
	I2C_FIFO_ST_RXFIFO_WADDR_Msk = 0x3e0
	// Position of TXFIFO_RADDR field.
	I2C_FIFO_ST_TXFIFO_RADDR_Pos = 0xa
	// Bit mask of TXFIFO_RADDR field.
	I2C_FIFO_ST_TXFIFO_RADDR_Msk = 0x7c00
	// Position of TXFIFO_WADDR field.
	I2C_FIFO_ST_TXFIFO_WADDR_Pos = 0xf
	// Bit mask of TXFIFO_WADDR field.
	I2C_FIFO_ST_TXFIFO_WADDR_Msk = 0xf8000
	// Position of SLAVE_RW_POINT field.
	I2C_FIFO_ST_SLAVE_RW_POINT_Pos = 0x16
	// Bit mask of SLAVE_RW_POINT field.
	I2C_FIFO_ST_SLAVE_RW_POINT_Msk = 0x3fc00000

	// FIFO_CONF: FIFO configuration register.
	// Position of RXFIFO_WM_THRHD field.
	I2C_FIFO_CONF_RXFIFO_WM_THRHD_Pos = 0x0
	// Bit mask of RXFIFO_WM_THRHD field.
	I2C_FIFO_CONF_RXFIFO_WM_THRHD_Msk = 0x1f
	// Position of TXFIFO_WM_THRHD field.
	I2C_FIFO_CONF_TXFIFO_WM_THRHD_Pos = 0x5
	// Bit mask of TXFIFO_WM_THRHD field.
	I2C_FIFO_CONF_TXFIFO_WM_THRHD_Msk = 0x3e0
	// Position of NONFIFO_EN field.
	I2C_FIFO_CONF_NONFIFO_EN_Pos = 0xa
	// Bit mask of NONFIFO_EN field.
	I2C_FIFO_CONF_NONFIFO_EN_Msk = 0x400
	// Bit NONFIFO_EN.
	I2C_FIFO_CONF_NONFIFO_EN = 0x400
	// Position of FIFO_ADDR_CFG_EN field.
	I2C_FIFO_CONF_FIFO_ADDR_CFG_EN_Pos = 0xb
	// Bit mask of FIFO_ADDR_CFG_EN field.
	I2C_FIFO_CONF_FIFO_ADDR_CFG_EN_Msk = 0x800
	// Bit FIFO_ADDR_CFG_EN.
	I2C_FIFO_CONF_FIFO_ADDR_CFG_EN = 0x800
	// Position of RX_FIFO_RST field.
	I2C_FIFO_CONF_RX_FIFO_RST_Pos = 0xc
	// Bit mask of RX_FIFO_RST field.
	I2C_FIFO_CONF_RX_FIFO_RST_Msk = 0x1000
	// Bit RX_FIFO_RST.
	I2C_FIFO_CONF_RX_FIFO_RST = 0x1000
	// Position of TX_FIFO_RST field.
	I2C_FIFO_CONF_TX_FIFO_RST_Pos = 0xd
	// Bit mask of TX_FIFO_RST field.
	I2C_FIFO_CONF_TX_FIFO_RST_Msk = 0x2000
	// Bit TX_FIFO_RST.
	I2C_FIFO_CONF_TX_FIFO_RST = 0x2000
	// Position of FIFO_PRT_EN field.
	I2C_FIFO_CONF_FIFO_PRT_EN_Pos = 0xe
	// Bit mask of FIFO_PRT_EN field.
	I2C_FIFO_CONF_FIFO_PRT_EN_Msk = 0x4000
	// Bit FIFO_PRT_EN.
	I2C_FIFO_CONF_FIFO_PRT_EN = 0x4000

	// DATA: Rx FIFO read data.
	// Position of FIFO_RDATA field.
	I2C_DATA_FIFO_RDATA_Pos = 0x0
	// Bit mask of FIFO_RDATA field.
	I2C_DATA_FIFO_RDATA_Msk = 0xff

	// INT_RAW: Raw interrupt status
	// Position of RXFIFO_WM_INT_RAW field.
	I2C_INT_RAW_RXFIFO_WM_INT_RAW_Pos = 0x0
	// Bit mask of RXFIFO_WM_INT_RAW field.
	I2C_INT_RAW_RXFIFO_WM_INT_RAW_Msk = 0x1
	// Bit RXFIFO_WM_INT_RAW.
	I2C_INT_RAW_RXFIFO_WM_INT_RAW = 0x1
	// Position of TXFIFO_WM_INT_RAW field.
	I2C_INT_RAW_TXFIFO_WM_INT_RAW_Pos = 0x1
	// Bit mask of TXFIFO_WM_INT_RAW field.
	I2C_INT_RAW_TXFIFO_WM_INT_RAW_Msk = 0x2
	// Bit TXFIFO_WM_INT_RAW.
	I2C_INT_RAW_TXFIFO_WM_INT_RAW = 0x2
	// Position of RXFIFO_OVF_INT_RAW field.
	I2C_INT_RAW_RXFIFO_OVF_INT_RAW_Pos = 0x2
	// Bit mask of RXFIFO_OVF_INT_RAW field.
	I2C_INT_RAW_RXFIFO_OVF_INT_RAW_Msk = 0x4
	// Bit RXFIFO_OVF_INT_RAW.
	I2C_INT_RAW_RXFIFO_OVF_INT_RAW = 0x4
	// Position of END_DETECT_INT_RAW field.
	I2C_INT_RAW_END_DETECT_INT_RAW_Pos = 0x3
	// Bit mask of END_DETECT_INT_RAW field.
	I2C_INT_RAW_END_DETECT_INT_RAW_Msk = 0x8
	// Bit END_DETECT_INT_RAW.
	I2C_INT_RAW_END_DETECT_INT_RAW = 0x8
	// Position of BYTE_TRANS_DONE_INT_RAW field.
	I2C_INT_RAW_BYTE_TRANS_DONE_INT_RAW_Pos = 0x4
	// Bit mask of BYTE_TRANS_DONE_INT_RAW field.
	I2C_INT_RAW_BYTE_TRANS_DONE_INT_RAW_Msk = 0x10
	// Bit BYTE_TRANS_DONE_INT_RAW.
	I2C_INT_RAW_BYTE_TRANS_DONE_INT_RAW = 0x10
	// Position of ARBITRATION_LOST_INT_RAW field.
	I2C_INT_RAW_ARBITRATION_LOST_INT_RAW_Pos = 0x5
	// Bit mask of ARBITRATION_LOST_INT_RAW field.
	I2C_INT_RAW_ARBITRATION_LOST_INT_RAW_Msk = 0x20
	// Bit ARBITRATION_LOST_INT_RAW.
	I2C_INT_RAW_ARBITRATION_LOST_INT_RAW = 0x20
	// Position of MST_TXFIFO_UDF_INT_RAW field.
	I2C_INT_RAW_MST_TXFIFO_UDF_INT_RAW_Pos = 0x6
	// Bit mask of MST_TXFIFO_UDF_INT_RAW field.
	I2C_INT_RAW_MST_TXFIFO_UDF_INT_RAW_Msk = 0x40
	// Bit MST_TXFIFO_UDF_INT_RAW.
	I2C_INT_RAW_MST_TXFIFO_UDF_INT_RAW = 0x40
	// Position of TRANS_COMPLETE_INT_RAW field.
	I2C_INT_RAW_TRANS_COMPLETE_INT_RAW_Pos = 0x7
	// Bit mask of TRANS_COMPLETE_INT_RAW field.
	I2C_INT_RAW_TRANS_COMPLETE_INT_RAW_Msk = 0x80
	// Bit TRANS_COMPLETE_INT_RAW.
	I2C_INT_RAW_TRANS_COMPLETE_INT_RAW = 0x80
	// Position of TIME_OUT_INT_RAW field.
	I2C_INT_RAW_TIME_OUT_INT_RAW_Pos = 0x8
	// Bit mask of TIME_OUT_INT_RAW field.
	I2C_INT_RAW_TIME_OUT_INT_RAW_Msk = 0x100
	// Bit TIME_OUT_INT_RAW.
	I2C_INT_RAW_TIME_OUT_INT_RAW = 0x100
	// Position of TRANS_START_INT_RAW field.
	I2C_INT_RAW_TRANS_START_INT_RAW_Pos = 0x9
	// Bit mask of TRANS_START_INT_RAW field.
	I2C_INT_RAW_TRANS_START_INT_RAW_Msk = 0x200
	// Bit TRANS_START_INT_RAW.
	I2C_INT_RAW_TRANS_START_INT_RAW = 0x200
	// Position of NACK_INT_RAW field.
	I2C_INT_RAW_NACK_INT_RAW_Pos = 0xa
	// Bit mask of NACK_INT_RAW field.
	I2C_INT_RAW_NACK_INT_RAW_Msk = 0x400
	// Bit NACK_INT_RAW.
	I2C_INT_RAW_NACK_INT_RAW = 0x400
	// Position of TXFIFO_OVF_INT_RAW field.
	I2C_INT_RAW_TXFIFO_OVF_INT_RAW_Pos = 0xb
	// Bit mask of TXFIFO_OVF_INT_RAW field.
	I2C_INT_RAW_TXFIFO_OVF_INT_RAW_Msk = 0x800
	// Bit TXFIFO_OVF_INT_RAW.
	I2C_INT_RAW_TXFIFO_OVF_INT_RAW = 0x800
	// Position of RXFIFO_UDF_INT_RAW field.
	I2C_INT_RAW_RXFIFO_UDF_INT_RAW_Pos = 0xc
	// Bit mask of RXFIFO_UDF_INT_RAW field.
	I2C_INT_RAW_RXFIFO_UDF_INT_RAW_Msk = 0x1000
	// Bit RXFIFO_UDF_INT_RAW.
	I2C_INT_RAW_RXFIFO_UDF_INT_RAW = 0x1000
	// Position of SCL_ST_TO_INT_RAW field.
	I2C_INT_RAW_SCL_ST_TO_INT_RAW_Pos = 0xd
	// Bit mask of SCL_ST_TO_INT_RAW field.
	I2C_INT_RAW_SCL_ST_TO_INT_RAW_Msk = 0x2000
	// Bit SCL_ST_TO_INT_RAW.
	I2C_INT_RAW_SCL_ST_TO_INT_RAW = 0x2000
	// Position of SCL_MAIN_ST_TO_INT_RAW field.
	I2C_INT_RAW_SCL_MAIN_ST_TO_INT_RAW_Pos = 0xe
	// Bit mask of SCL_MAIN_ST_TO_INT_RAW field.
	I2C_INT_RAW_SCL_MAIN_ST_TO_INT_RAW_Msk = 0x4000
	// Bit SCL_MAIN_ST_TO_INT_RAW.
	I2C_INT_RAW_SCL_MAIN_ST_TO_INT_RAW = 0x4000
	// Position of DET_START_INT_RAW field.
	I2C_INT_RAW_DET_START_INT_RAW_Pos = 0xf
	// Bit mask of DET_START_INT_RAW field.
	I2C_INT_RAW_DET_START_INT_RAW_Msk = 0x8000
	// Bit DET_START_INT_RAW.
	I2C_INT_RAW_DET_START_INT_RAW = 0x8000
	// Position of SLAVE_STRETCH_INT_RAW field.
	I2C_INT_RAW_SLAVE_STRETCH_INT_RAW_Pos = 0x10
	// Bit mask of SLAVE_STRETCH_INT_RAW field.
	I2C_INT_RAW_SLAVE_STRETCH_INT_RAW_Msk = 0x10000
	// Bit SLAVE_STRETCH_INT_RAW.
	I2C_INT_RAW_SLAVE_STRETCH_INT_RAW = 0x10000
	// Position of GENERAL_CALL_INT_RAW field.
	I2C_INT_RAW_GENERAL_CALL_INT_RAW_Pos = 0x11
	// Bit mask of GENERAL_CALL_INT_RAW field.
	I2C_INT_RAW_GENERAL_CALL_INT_RAW_Msk = 0x20000
	// Bit GENERAL_CALL_INT_RAW.
	I2C_INT_RAW_GENERAL_CALL_INT_RAW = 0x20000
	// Position of SLAVE_ADDR_UNMATCH_INT_RAW field.
	I2C_INT_RAW_SLAVE_ADDR_UNMATCH_INT_RAW_Pos = 0x12
	// Bit mask of SLAVE_ADDR_UNMATCH_INT_RAW field.
	I2C_INT_RAW_SLAVE_ADDR_UNMATCH_INT_RAW_Msk = 0x40000
	// Bit SLAVE_ADDR_UNMATCH_INT_RAW.
	I2C_INT_RAW_SLAVE_ADDR_UNMATCH_INT_RAW = 0x40000

	// INT_CLR: Interrupt clear bits
	// Position of RXFIFO_WM_INT_CLR field.
	I2C_INT_CLR_RXFIFO_WM_INT_CLR_Pos = 0x0
	// Bit mask of RXFIFO_WM_INT_CLR field.
	I2C_INT_CLR_RXFIFO_WM_INT_CLR_Msk = 0x1
	// Bit RXFIFO_WM_INT_CLR.
	I2C_INT_CLR_RXFIFO_WM_INT_CLR = 0x1
	// Position of TXFIFO_WM_INT_CLR field.
	I2C_INT_CLR_TXFIFO_WM_INT_CLR_Pos = 0x1
	// Bit mask of TXFIFO_WM_INT_CLR field.
	I2C_INT_CLR_TXFIFO_WM_INT_CLR_Msk = 0x2
	// Bit TXFIFO_WM_INT_CLR.
	I2C_INT_CLR_TXFIFO_WM_INT_CLR = 0x2
	// Position of RXFIFO_OVF_INT_CLR field.
	I2C_INT_CLR_RXFIFO_OVF_INT_CLR_Pos = 0x2
	// Bit mask of RXFIFO_OVF_INT_CLR field.
	I2C_INT_CLR_RXFIFO_OVF_INT_CLR_Msk = 0x4
	// Bit RXFIFO_OVF_INT_CLR.
	I2C_INT_CLR_RXFIFO_OVF_INT_CLR = 0x4
	// Position of END_DETECT_INT_CLR field.
	I2C_INT_CLR_END_DETECT_INT_CLR_Pos = 0x3
	// Bit mask of END_DETECT_INT_CLR field.
	I2C_INT_CLR_END_DETECT_INT_CLR_Msk = 0x8
	// Bit END_DETECT_INT_CLR.
	I2C_INT_CLR_END_DETECT_INT_CLR = 0x8
	// Position of BYTE_TRANS_DONE_INT_CLR field.
	I2C_INT_CLR_BYTE_TRANS_DONE_INT_CLR_Pos = 0x4
	// Bit mask of BYTE_TRANS_DONE_INT_CLR field.
	I2C_INT_CLR_BYTE_TRANS_DONE_INT_CLR_Msk = 0x10
	// Bit BYTE_TRANS_DONE_INT_CLR.
	I2C_INT_CLR_BYTE_TRANS_DONE_INT_CLR = 0x10
	// Position of ARBITRATION_LOST_INT_CLR field.
	I2C_INT_CLR_ARBITRATION_LOST_INT_CLR_Pos = 0x5
	// Bit mask of ARBITRATION_LOST_INT_CLR field.
	I2C_INT_CLR_ARBITRATION_LOST_INT_CLR_Msk = 0x20
	// Bit ARBITRATION_LOST_INT_CLR.
	I2C_INT_CLR_ARBITRATION_LOST_INT_CLR = 0x20
	// Position of MST_TXFIFO_UDF_INT_CLR field.
	I2C_INT_CLR_MST_TXFIFO_UDF_INT_CLR_Pos = 0x6
	// Bit mask of MST_TXFIFO_UDF_INT_CLR field.
	I2C_INT_CLR_MST_TXFIFO_UDF_INT_CLR_Msk = 0x40
	// Bit MST_TXFIFO_UDF_INT_CLR.
	I2C_INT_CLR_MST_TXFIFO_UDF_INT_CLR = 0x40
	// Position of TRANS_COMPLETE_INT_CLR field.
	I2C_INT_CLR_TRANS_COMPLETE_INT_CLR_Pos = 0x7
	// Bit mask of TRANS_COMPLETE_INT_CLR field.
	I2C_INT_CLR_TRANS_COMPLETE_INT_CLR_Msk = 0x80
	// Bit TRANS_COMPLETE_INT_CLR.
	I2C_INT_CLR_TRANS_COMPLETE_INT_CLR = 0x80
	// Position of TIME_OUT_INT_CLR field.
	I2C_INT_CLR_TIME_OUT_INT_CLR_Pos = 0x8
	// Bit mask of TIME_OUT_INT_CLR field.
	I2C_INT_CLR_TIME_OUT_INT_CLR_Msk = 0x100
	// Bit TIME_OUT_INT_CLR.
	I2C_INT_CLR_TIME_OUT_INT_CLR = 0x100
	// Position of TRANS_START_INT_CLR field.
	I2C_INT_CLR_TRANS_START_INT_CLR_Pos = 0x9
	// Bit mask of TRANS_START_INT_CLR field.
	I2C_INT_CLR_TRANS_START_INT_CLR_Msk = 0x200
	// Bit TRANS_START_INT_CLR.
	I2C_INT_CLR_TRANS_START_INT_CLR = 0x200
	// Position of NACK_INT_CLR field.
	I2C_INT_CLR_NACK_INT_CLR_Pos = 0xa
	// Bit mask of NACK_INT_CLR field.
	I2C_INT_CLR_NACK_INT_CLR_Msk = 0x400
	// Bit NACK_INT_CLR.
	I2C_INT_CLR_NACK_INT_CLR = 0x400
	// Position of TXFIFO_OVF_INT_CLR field.
	I2C_INT_CLR_TXFIFO_OVF_INT_CLR_Pos = 0xb
	// Bit mask of TXFIFO_OVF_INT_CLR field.
	I2C_INT_CLR_TXFIFO_OVF_INT_CLR_Msk = 0x800
	// Bit TXFIFO_OVF_INT_CLR.
	I2C_INT_CLR_TXFIFO_OVF_INT_CLR = 0x800
	// Position of RXFIFO_UDF_INT_CLR field.
	I2C_INT_CLR_RXFIFO_UDF_INT_CLR_Pos = 0xc
	// Bit mask of RXFIFO_UDF_INT_CLR field.
	I2C_INT_CLR_RXFIFO_UDF_INT_CLR_Msk = 0x1000
	// Bit RXFIFO_UDF_INT_CLR.
	I2C_INT_CLR_RXFIFO_UDF_INT_CLR = 0x1000
	// Position of SCL_ST_TO_INT_CLR field.
	I2C_INT_CLR_SCL_ST_TO_INT_CLR_Pos = 0xd
	// Bit mask of SCL_ST_TO_INT_CLR field.
	I2C_INT_CLR_SCL_ST_TO_INT_CLR_Msk = 0x2000
	// Bit SCL_ST_TO_INT_CLR.
	I2C_INT_CLR_SCL_ST_TO_INT_CLR = 0x2000
	// Position of SCL_MAIN_ST_TO_INT_CLR field.
	I2C_INT_CLR_SCL_MAIN_ST_TO_INT_CLR_Pos = 0xe
	// Bit mask of SCL_MAIN_ST_TO_INT_CLR field.
	I2C_INT_CLR_SCL_MAIN_ST_TO_INT_CLR_Msk = 0x4000
	// Bit SCL_MAIN_ST_TO_INT_CLR.
	I2C_INT_CLR_SCL_MAIN_ST_TO_INT_CLR = 0x4000
	// Position of DET_START_INT_CLR field.
	I2C_INT_CLR_DET_START_INT_CLR_Pos = 0xf
	// Bit mask of DET_START_INT_CLR field.
	I2C_INT_CLR_DET_START_INT_CLR_Msk = 0x8000
	// Bit DET_START_INT_CLR.
	I2C_INT_CLR_DET_START_INT_CLR = 0x8000
	// Position of SLAVE_STRETCH_INT_CLR field.
	I2C_INT_CLR_SLAVE_STRETCH_INT_CLR_Pos = 0x10
	// Bit mask of SLAVE_STRETCH_INT_CLR field.
	I2C_INT_CLR_SLAVE_STRETCH_INT_CLR_Msk = 0x10000
	// Bit SLAVE_STRETCH_INT_CLR.
	I2C_INT_CLR_SLAVE_STRETCH_INT_CLR = 0x10000
	// Position of GENERAL_CALL_INT_CLR field.
	I2C_INT_CLR_GENERAL_CALL_INT_CLR_Pos = 0x11
	// Bit mask of GENERAL_CALL_INT_CLR field.
	I2C_INT_CLR_GENERAL_CALL_INT_CLR_Msk = 0x20000
	// Bit GENERAL_CALL_INT_CLR.
	I2C_INT_CLR_GENERAL_CALL_INT_CLR = 0x20000
	// Position of SLAVE_ADDR_UNMATCH_INT_CLR field.
	I2C_INT_CLR_SLAVE_ADDR_UNMATCH_INT_CLR_Pos = 0x12
	// Bit mask of SLAVE_ADDR_UNMATCH_INT_CLR field.
	I2C_INT_CLR_SLAVE_ADDR_UNMATCH_INT_CLR_Msk = 0x40000
	// Bit SLAVE_ADDR_UNMATCH_INT_CLR.
	I2C_INT_CLR_SLAVE_ADDR_UNMATCH_INT_CLR = 0x40000

	// INT_ENA: Interrupt enable bits
	// Position of RXFIFO_WM_INT_ENA field.
	I2C_INT_ENA_RXFIFO_WM_INT_ENA_Pos = 0x0
	// Bit mask of RXFIFO_WM_INT_ENA field.
	I2C_INT_ENA_RXFIFO_WM_INT_ENA_Msk = 0x1
	// Bit RXFIFO_WM_INT_ENA.
	I2C_INT_ENA_RXFIFO_WM_INT_ENA = 0x1
	// Position of TXFIFO_WM_INT_ENA field.
	I2C_INT_ENA_TXFIFO_WM_INT_ENA_Pos = 0x1
	// Bit mask of TXFIFO_WM_INT_ENA field.
	I2C_INT_ENA_TXFIFO_WM_INT_ENA_Msk = 0x2
	// Bit TXFIFO_WM_INT_ENA.
	I2C_INT_ENA_TXFIFO_WM_INT_ENA = 0x2
	// Position of RXFIFO_OVF_INT_ENA field.
	I2C_INT_ENA_RXFIFO_OVF_INT_ENA_Pos = 0x2
	// Bit mask of RXFIFO_OVF_INT_ENA field.
	I2C_INT_ENA_RXFIFO_OVF_INT_ENA_Msk = 0x4
	// Bit RXFIFO_OVF_INT_ENA.
	I2C_INT_ENA_RXFIFO_OVF_INT_ENA = 0x4
	// Position of END_DETECT_INT_ENA field.
	I2C_INT_ENA_END_DETECT_INT_ENA_Pos = 0x3
	// Bit mask of END_DETECT_INT_ENA field.
	I2C_INT_ENA_END_DETECT_INT_ENA_Msk = 0x8
	// Bit END_DETECT_INT_ENA.
	I2C_INT_ENA_END_DETECT_INT_ENA = 0x8
	// Position of BYTE_TRANS_DONE_INT_ENA field.
	I2C_INT_ENA_BYTE_TRANS_DONE_INT_ENA_Pos = 0x4
	// Bit mask of BYTE_TRANS_DONE_INT_ENA field.
	I2C_INT_ENA_BYTE_TRANS_DONE_INT_ENA_Msk = 0x10
	// Bit BYTE_TRANS_DONE_INT_ENA.
	I2C_INT_ENA_BYTE_TRANS_DONE_INT_ENA = 0x10
	// Position of ARBITRATION_LOST_INT_ENA field.
	I2C_INT_ENA_ARBITRATION_LOST_INT_ENA_Pos = 0x5
	// Bit mask of ARBITRATION_LOST_INT_ENA field.
	I2C_INT_ENA_ARBITRATION_LOST_INT_ENA_Msk = 0x20
	// Bit ARBITRATION_LOST_INT_ENA.
	I2C_INT_ENA_ARBITRATION_LOST_INT_ENA = 0x20
	// Position of MST_TXFIFO_UDF_INT_ENA field.
	I2C_INT_ENA_MST_TXFIFO_UDF_INT_ENA_Pos = 0x6
	// Bit mask of MST_TXFIFO_UDF_INT_ENA field.
	I2C_INT_ENA_MST_TXFIFO_UDF_INT_ENA_Msk = 0x40
	// Bit MST_TXFIFO_UDF_INT_ENA.
	I2C_INT_ENA_MST_TXFIFO_UDF_INT_ENA = 0x40
	// Position of TRANS_COMPLETE_INT_ENA field.
	I2C_INT_ENA_TRANS_COMPLETE_INT_ENA_Pos = 0x7
	// Bit mask of TRANS_COMPLETE_INT_ENA field.
	I2C_INT_ENA_TRANS_COMPLETE_INT_ENA_Msk = 0x80
	// Bit TRANS_COMPLETE_INT_ENA.
	I2C_INT_ENA_TRANS_COMPLETE_INT_ENA = 0x80
	// Position of TIME_OUT_INT_ENA field.
	I2C_INT_ENA_TIME_OUT_INT_ENA_Pos = 0x8
	// Bit mask of TIME_OUT_INT_ENA field.
	I2C_INT_ENA_TIME_OUT_INT_ENA_Msk = 0x100
	// Bit TIME_OUT_INT_ENA.
	I2C_INT_ENA_TIME_OUT_INT_ENA = 0x100
	// Position of TRANS_START_INT_ENA field.
	I2C_INT_ENA_TRANS_START_INT_ENA_Pos = 0x9
	// Bit mask of TRANS_START_INT_ENA field.
	I2C_INT_ENA_TRANS_START_INT_ENA_Msk = 0x200
	// Bit TRANS_START_INT_ENA.
	I2C_INT_ENA_TRANS_START_INT_ENA = 0x200
	// Position of NACK_INT_ENA field.
	I2C_INT_ENA_NACK_INT_ENA_Pos = 0xa
	// Bit mask of NACK_INT_ENA field.
	I2C_INT_ENA_NACK_INT_ENA_Msk = 0x400
	// Bit NACK_INT_ENA.
	I2C_INT_ENA_NACK_INT_ENA = 0x400
	// Position of TXFIFO_OVF_INT_ENA field.
	I2C_INT_ENA_TXFIFO_OVF_INT_ENA_Pos = 0xb
	// Bit mask of TXFIFO_OVF_INT_ENA field.
	I2C_INT_ENA_TXFIFO_OVF_INT_ENA_Msk = 0x800
	// Bit TXFIFO_OVF_INT_ENA.
	I2C_INT_ENA_TXFIFO_OVF_INT_ENA = 0x800
	// Position of RXFIFO_UDF_INT_ENA field.
	I2C_INT_ENA_RXFIFO_UDF_INT_ENA_Pos = 0xc
	// Bit mask of RXFIFO_UDF_INT_ENA field.
	I2C_INT_ENA_RXFIFO_UDF_INT_ENA_Msk = 0x1000
	// Bit RXFIFO_UDF_INT_ENA.
	I2C_INT_ENA_RXFIFO_UDF_INT_ENA = 0x1000
	// Position of SCL_ST_TO_INT_ENA field.
	I2C_INT_ENA_SCL_ST_TO_INT_ENA_Pos = 0xd
	// Bit mask of SCL_ST_TO_INT_ENA field.
	I2C_INT_ENA_SCL_ST_TO_INT_ENA_Msk = 0x2000
	// Bit SCL_ST_TO_INT_ENA.
	I2C_INT_ENA_SCL_ST_TO_INT_ENA = 0x2000
	// Position of SCL_MAIN_ST_TO_INT_ENA field.
	I2C_INT_ENA_SCL_MAIN_ST_TO_INT_ENA_Pos = 0xe
	// Bit mask of SCL_MAIN_ST_TO_INT_ENA field.
	I2C_INT_ENA_SCL_MAIN_ST_TO_INT_ENA_Msk = 0x4000
	// Bit SCL_MAIN_ST_TO_INT_ENA.
	I2C_INT_ENA_SCL_MAIN_ST_TO_INT_ENA = 0x4000
	// Position of DET_START_INT_ENA field.
	I2C_INT_ENA_DET_START_INT_ENA_Pos = 0xf
	// Bit mask of DET_START_INT_ENA field.
	I2C_INT_ENA_DET_START_INT_ENA_Msk = 0x8000
	// Bit DET_START_INT_ENA.
	I2C_INT_ENA_DET_START_INT_ENA = 0x8000
	// Position of SLAVE_STRETCH_INT_ENA field.
	I2C_INT_ENA_SLAVE_STRETCH_INT_ENA_Pos = 0x10
	// Bit mask of SLAVE_STRETCH_INT_ENA field.
	I2C_INT_ENA_SLAVE_STRETCH_INT_ENA_Msk = 0x10000
	// Bit SLAVE_STRETCH_INT_ENA.
	I2C_INT_ENA_SLAVE_STRETCH_INT_ENA = 0x10000
	// Position of GENERAL_CALL_INT_ENA field.
	I2C_INT_ENA_GENERAL_CALL_INT_ENA_Pos = 0x11
	// Bit mask of GENERAL_CALL_INT_ENA field.
	I2C_INT_ENA_GENERAL_CALL_INT_ENA_Msk = 0x20000
	// Bit GENERAL_CALL_INT_ENA.
	I2C_INT_ENA_GENERAL_CALL_INT_ENA = 0x20000
	// Position of SLAVE_ADDR_UNMATCH_INT_ENA field.
	I2C_INT_ENA_SLAVE_ADDR_UNMATCH_INT_ENA_Pos = 0x12
	// Bit mask of SLAVE_ADDR_UNMATCH_INT_ENA field.
	I2C_INT_ENA_SLAVE_ADDR_UNMATCH_INT_ENA_Msk = 0x40000
	// Bit SLAVE_ADDR_UNMATCH_INT_ENA.
	I2C_INT_ENA_SLAVE_ADDR_UNMATCH_INT_ENA = 0x40000

	// INT_STATUS: Status of captured I2C communication events
	// Position of RXFIFO_WM_INT_ST field.
	I2C_INT_STATUS_RXFIFO_WM_INT_ST_Pos = 0x0
	// Bit mask of RXFIFO_WM_INT_ST field.
	I2C_INT_STATUS_RXFIFO_WM_INT_ST_Msk = 0x1
	// Bit RXFIFO_WM_INT_ST.
	I2C_INT_STATUS_RXFIFO_WM_INT_ST = 0x1
	// Position of TXFIFO_WM_INT_ST field.
	I2C_INT_STATUS_TXFIFO_WM_INT_ST_Pos = 0x1
	// Bit mask of TXFIFO_WM_INT_ST field.
	I2C_INT_STATUS_TXFIFO_WM_INT_ST_Msk = 0x2
	// Bit TXFIFO_WM_INT_ST.
	I2C_INT_STATUS_TXFIFO_WM_INT_ST = 0x2
	// Position of RXFIFO_OVF_INT_ST field.
	I2C_INT_STATUS_RXFIFO_OVF_INT_ST_Pos = 0x2
	// Bit mask of RXFIFO_OVF_INT_ST field.
	I2C_INT_STATUS_RXFIFO_OVF_INT_ST_Msk = 0x4
	// Bit RXFIFO_OVF_INT_ST.
	I2C_INT_STATUS_RXFIFO_OVF_INT_ST = 0x4
	// Position of END_DETECT_INT_ST field.
	I2C_INT_STATUS_END_DETECT_INT_ST_Pos = 0x3
	// Bit mask of END_DETECT_INT_ST field.
	I2C_INT_STATUS_END_DETECT_INT_ST_Msk = 0x8
	// Bit END_DETECT_INT_ST.
	I2C_INT_STATUS_END_DETECT_INT_ST = 0x8
	// Position of BYTE_TRANS_DONE_INT_ST field.
	I2C_INT_STATUS_BYTE_TRANS_DONE_INT_ST_Pos = 0x4
	// Bit mask of BYTE_TRANS_DONE_INT_ST field.
	I2C_INT_STATUS_BYTE_TRANS_DONE_INT_ST_Msk = 0x10
	// Bit BYTE_TRANS_DONE_INT_ST.
	I2C_INT_STATUS_BYTE_TRANS_DONE_INT_ST = 0x10
	// Position of ARBITRATION_LOST_INT_ST field.
	I2C_INT_STATUS_ARBITRATION_LOST_INT_ST_Pos = 0x5
	// Bit mask of ARBITRATION_LOST_INT_ST field.
	I2C_INT_STATUS_ARBITRATION_LOST_INT_ST_Msk = 0x20
	// Bit ARBITRATION_LOST_INT_ST.
	I2C_INT_STATUS_ARBITRATION_LOST_INT_ST = 0x20
	// Position of MST_TXFIFO_UDF_INT_ST field.
	I2C_INT_STATUS_MST_TXFIFO_UDF_INT_ST_Pos = 0x6
	// Bit mask of MST_TXFIFO_UDF_INT_ST field.
	I2C_INT_STATUS_MST_TXFIFO_UDF_INT_ST_Msk = 0x40
	// Bit MST_TXFIFO_UDF_INT_ST.
	I2C_INT_STATUS_MST_TXFIFO_UDF_INT_ST = 0x40
	// Position of TRANS_COMPLETE_INT_ST field.
	I2C_INT_STATUS_TRANS_COMPLETE_INT_ST_Pos = 0x7
	// Bit mask of TRANS_COMPLETE_INT_ST field.
	I2C_INT_STATUS_TRANS_COMPLETE_INT_ST_Msk = 0x80
	// Bit TRANS_COMPLETE_INT_ST.
	I2C_INT_STATUS_TRANS_COMPLETE_INT_ST = 0x80
	// Position of TIME_OUT_INT_ST field.
	I2C_INT_STATUS_TIME_OUT_INT_ST_Pos = 0x8
	// Bit mask of TIME_OUT_INT_ST field.
	I2C_INT_STATUS_TIME_OUT_INT_ST_Msk = 0x100
	// Bit TIME_OUT_INT_ST.
	I2C_INT_STATUS_TIME_OUT_INT_ST = 0x100
	// Position of TRANS_START_INT_ST field.
	I2C_INT_STATUS_TRANS_START_INT_ST_Pos = 0x9
	// Bit mask of TRANS_START_INT_ST field.
	I2C_INT_STATUS_TRANS_START_INT_ST_Msk = 0x200
	// Bit TRANS_START_INT_ST.
	I2C_INT_STATUS_TRANS_START_INT_ST = 0x200
	// Position of NACK_INT_ST field.
	I2C_INT_STATUS_NACK_INT_ST_Pos = 0xa
	// Bit mask of NACK_INT_ST field.
	I2C_INT_STATUS_NACK_INT_ST_Msk = 0x400
	// Bit NACK_INT_ST.
	I2C_INT_STATUS_NACK_INT_ST = 0x400
	// Position of TXFIFO_OVF_INT_ST field.
	I2C_INT_STATUS_TXFIFO_OVF_INT_ST_Pos = 0xb
	// Bit mask of TXFIFO_OVF_INT_ST field.
	I2C_INT_STATUS_TXFIFO_OVF_INT_ST_Msk = 0x800
	// Bit TXFIFO_OVF_INT_ST.
	I2C_INT_STATUS_TXFIFO_OVF_INT_ST = 0x800
	// Position of RXFIFO_UDF_INT_ST field.
	I2C_INT_STATUS_RXFIFO_UDF_INT_ST_Pos = 0xc
	// Bit mask of RXFIFO_UDF_INT_ST field.
	I2C_INT_STATUS_RXFIFO_UDF_INT_ST_Msk = 0x1000
	// Bit RXFIFO_UDF_INT_ST.
	I2C_INT_STATUS_RXFIFO_UDF_INT_ST = 0x1000
	// Position of SCL_ST_TO_INT_ST field.
	I2C_INT_STATUS_SCL_ST_TO_INT_ST_Pos = 0xd
	// Bit mask of SCL_ST_TO_INT_ST field.
	I2C_INT_STATUS_SCL_ST_TO_INT_ST_Msk = 0x2000
	// Bit SCL_ST_TO_INT_ST.
	I2C_INT_STATUS_SCL_ST_TO_INT_ST = 0x2000
	// Position of SCL_MAIN_ST_TO_INT_ST field.
	I2C_INT_STATUS_SCL_MAIN_ST_TO_INT_ST_Pos = 0xe
	// Bit mask of SCL_MAIN_ST_TO_INT_ST field.
	I2C_INT_STATUS_SCL_MAIN_ST_TO_INT_ST_Msk = 0x4000
	// Bit SCL_MAIN_ST_TO_INT_ST.
	I2C_INT_STATUS_SCL_MAIN_ST_TO_INT_ST = 0x4000
	// Position of DET_START_INT_ST field.
	I2C_INT_STATUS_DET_START_INT_ST_Pos = 0xf
	// Bit mask of DET_START_INT_ST field.
	I2C_INT_STATUS_DET_START_INT_ST_Msk = 0x8000
	// Bit DET_START_INT_ST.
	I2C_INT_STATUS_DET_START_INT_ST = 0x8000
	// Position of SLAVE_STRETCH_INT_ST field.
	I2C_INT_STATUS_SLAVE_STRETCH_INT_ST_Pos = 0x10
	// Bit mask of SLAVE_STRETCH_INT_ST field.
	I2C_INT_STATUS_SLAVE_STRETCH_INT_ST_Msk = 0x10000
	// Bit SLAVE_STRETCH_INT_ST.
	I2C_INT_STATUS_SLAVE_STRETCH_INT_ST = 0x10000
	// Position of GENERAL_CALL_INT_ST field.
	I2C_INT_STATUS_GENERAL_CALL_INT_ST_Pos = 0x11
	// Bit mask of GENERAL_CALL_INT_ST field.
	I2C_INT_STATUS_GENERAL_CALL_INT_ST_Msk = 0x20000
	// Bit GENERAL_CALL_INT_ST.
	I2C_INT_STATUS_GENERAL_CALL_INT_ST = 0x20000
	// Position of SLAVE_ADDR_UNMATCH_INT_ST field.
	I2C_INT_STATUS_SLAVE_ADDR_UNMATCH_INT_ST_Pos = 0x12
	// Bit mask of SLAVE_ADDR_UNMATCH_INT_ST field.
	I2C_INT_STATUS_SLAVE_ADDR_UNMATCH_INT_ST_Msk = 0x40000
	// Bit SLAVE_ADDR_UNMATCH_INT_ST.
	I2C_INT_STATUS_SLAVE_ADDR_UNMATCH_INT_ST = 0x40000

	// SDA_HOLD: Configures the hold time after a negative SCL edge.
	// Position of TIME field.
	I2C_SDA_HOLD_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C_SDA_HOLD_TIME_Msk = 0x1ff

	// SDA_SAMPLE: Configures the sample time after a positive SCL edge.
	// Position of TIME field.
	I2C_SDA_SAMPLE_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C_SDA_SAMPLE_TIME_Msk = 0x1ff

	// SCL_HIGH_PERIOD: Configures the high level width of SCL
	// Position of SCL_HIGH_PERIOD field.
	I2C_SCL_HIGH_PERIOD_SCL_HIGH_PERIOD_Pos = 0x0
	// Bit mask of SCL_HIGH_PERIOD field.
	I2C_SCL_HIGH_PERIOD_SCL_HIGH_PERIOD_Msk = 0x1ff
	// Position of SCL_WAIT_HIGH_PERIOD field.
	I2C_SCL_HIGH_PERIOD_SCL_WAIT_HIGH_PERIOD_Pos = 0x9
	// Bit mask of SCL_WAIT_HIGH_PERIOD field.
	I2C_SCL_HIGH_PERIOD_SCL_WAIT_HIGH_PERIOD_Msk = 0xfe00

	// SCL_START_HOLD: Configures the delay between the SDA and SCL negative edge for a start condition
	// Position of TIME field.
	I2C_SCL_START_HOLD_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C_SCL_START_HOLD_TIME_Msk = 0x1ff

	// SCL_RSTART_SETUP: Configures the delay between the positive edge of SCL and the negative edge of SDA
	// Position of TIME field.
	I2C_SCL_RSTART_SETUP_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C_SCL_RSTART_SETUP_TIME_Msk = 0x1ff

	// SCL_STOP_HOLD: Configures the delay after the SCL clock edge for a stop condition
	// Position of TIME field.
	I2C_SCL_STOP_HOLD_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C_SCL_STOP_HOLD_TIME_Msk = 0x1ff

	// SCL_STOP_SETUP: Configures the delay between the SDA and SCL positive edge for a stop condition
	// Position of TIME field.
	I2C_SCL_STOP_SETUP_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C_SCL_STOP_SETUP_TIME_Msk = 0x1ff

	// FILTER_CFG: SCL and SDA filter configuration register
	// Position of SCL_FILTER_THRES field.
	I2C_FILTER_CFG_SCL_FILTER_THRES_Pos = 0x0
	// Bit mask of SCL_FILTER_THRES field.
	I2C_FILTER_CFG_SCL_FILTER_THRES_Msk = 0xf
	// Position of SDA_FILTER_THRES field.
	I2C_FILTER_CFG_SDA_FILTER_THRES_Pos = 0x4
	// Bit mask of SDA_FILTER_THRES field.
	I2C_FILTER_CFG_SDA_FILTER_THRES_Msk = 0xf0
	// Position of SCL_FILTER_EN field.
	I2C_FILTER_CFG_SCL_FILTER_EN_Pos = 0x8
	// Bit mask of SCL_FILTER_EN field.
	I2C_FILTER_CFG_SCL_FILTER_EN_Msk = 0x100
	// Bit SCL_FILTER_EN.
	I2C_FILTER_CFG_SCL_FILTER_EN = 0x100
	// Position of SDA_FILTER_EN field.
	I2C_FILTER_CFG_SDA_FILTER_EN_Pos = 0x9
	// Bit mask of SDA_FILTER_EN field.
	I2C_FILTER_CFG_SDA_FILTER_EN_Msk = 0x200
	// Bit SDA_FILTER_EN.
	I2C_FILTER_CFG_SDA_FILTER_EN = 0x200

	// CLK_CONF: I2C CLK configuration register
	// Position of SCLK_DIV_NUM field.
	I2C_CLK_CONF_SCLK_DIV_NUM_Pos = 0x0
	// Bit mask of SCLK_DIV_NUM field.
	I2C_CLK_CONF_SCLK_DIV_NUM_Msk = 0xff
	// Position of SCLK_DIV_A field.
	I2C_CLK_CONF_SCLK_DIV_A_Pos = 0x8
	// Bit mask of SCLK_DIV_A field.
	I2C_CLK_CONF_SCLK_DIV_A_Msk = 0x3f00
	// Position of SCLK_DIV_B field.
	I2C_CLK_CONF_SCLK_DIV_B_Pos = 0xe
	// Bit mask of SCLK_DIV_B field.
	I2C_CLK_CONF_SCLK_DIV_B_Msk = 0xfc000
	// Position of SCLK_SEL field.
	I2C_CLK_CONF_SCLK_SEL_Pos = 0x14
	// Bit mask of SCLK_SEL field.
	I2C_CLK_CONF_SCLK_SEL_Msk = 0x100000
	// Bit SCLK_SEL.
	I2C_CLK_CONF_SCLK_SEL = 0x100000
	// Position of SCLK_ACTIVE field.
	I2C_CLK_CONF_SCLK_ACTIVE_Pos = 0x15
	// Bit mask of SCLK_ACTIVE field.
	I2C_CLK_CONF_SCLK_ACTIVE_Msk = 0x200000
	// Bit SCLK_ACTIVE.
	I2C_CLK_CONF_SCLK_ACTIVE = 0x200000

	// COMD0: I2C command register %s
	// Position of COMMAND field.
	I2C_COMD_COMMAND_Pos = 0x0
	// Bit mask of COMMAND field.
	I2C_COMD_COMMAND_Msk = 0x3fff
	// Position of COMMAND_DONE field.
	I2C_COMD_COMMAND_DONE_Pos = 0x1f
	// Bit mask of COMMAND_DONE field.
	I2C_COMD_COMMAND_DONE_Msk = 0x80000000
	// Bit COMMAND_DONE.
	I2C_COMD_COMMAND_DONE = 0x80000000

	// SCL_ST_TIME_OUT: SCL status time out register
	// Position of SCL_ST_TO_I2C field.
	I2C_SCL_ST_TIME_OUT_SCL_ST_TO_I2C_Pos = 0x0
	// Bit mask of SCL_ST_TO_I2C field.
	I2C_SCL_ST_TIME_OUT_SCL_ST_TO_I2C_Msk = 0x1f

	// SCL_MAIN_ST_TIME_OUT: SCL main status time out register
	// Position of SCL_MAIN_ST_TO_I2C field.
	I2C_SCL_MAIN_ST_TIME_OUT_SCL_MAIN_ST_TO_I2C_Pos = 0x0
	// Bit mask of SCL_MAIN_ST_TO_I2C field.
	I2C_SCL_MAIN_ST_TIME_OUT_SCL_MAIN_ST_TO_I2C_Msk = 0x1f

	// SCL_SP_CONF: Power configuration register
	// Position of SCL_RST_SLV_EN field.
	I2C_SCL_SP_CONF_SCL_RST_SLV_EN_Pos = 0x0
	// Bit mask of SCL_RST_SLV_EN field.
	I2C_SCL_SP_CONF_SCL_RST_SLV_EN_Msk = 0x1
	// Bit SCL_RST_SLV_EN.
	I2C_SCL_SP_CONF_SCL_RST_SLV_EN = 0x1
	// Position of SCL_RST_SLV_NUM field.
	I2C_SCL_SP_CONF_SCL_RST_SLV_NUM_Pos = 0x1
	// Bit mask of SCL_RST_SLV_NUM field.
	I2C_SCL_SP_CONF_SCL_RST_SLV_NUM_Msk = 0x3e
	// Position of SCL_PD_EN field.
	I2C_SCL_SP_CONF_SCL_PD_EN_Pos = 0x6
	// Bit mask of SCL_PD_EN field.
	I2C_SCL_SP_CONF_SCL_PD_EN_Msk = 0x40
	// Bit SCL_PD_EN.
	I2C_SCL_SP_CONF_SCL_PD_EN = 0x40
	// Position of SDA_PD_EN field.
	I2C_SCL_SP_CONF_SDA_PD_EN_Pos = 0x7
	// Bit mask of SDA_PD_EN field.
	I2C_SCL_SP_CONF_SDA_PD_EN_Msk = 0x80
	// Bit SDA_PD_EN.
	I2C_SCL_SP_CONF_SDA_PD_EN = 0x80

	// SCL_STRETCH_CONF: Set SCL stretch of I2C slave
	// Position of STRETCH_PROTECT_NUM field.
	I2C_SCL_STRETCH_CONF_STRETCH_PROTECT_NUM_Pos = 0x0
	// Bit mask of STRETCH_PROTECT_NUM field.
	I2C_SCL_STRETCH_CONF_STRETCH_PROTECT_NUM_Msk = 0x3ff
	// Position of SLAVE_SCL_STRETCH_EN field.
	I2C_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN_Pos = 0xa
	// Bit mask of SLAVE_SCL_STRETCH_EN field.
	I2C_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN_Msk = 0x400
	// Bit SLAVE_SCL_STRETCH_EN.
	I2C_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN = 0x400
	// Position of SLAVE_SCL_STRETCH_CLR field.
	I2C_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR_Pos = 0xb
	// Bit mask of SLAVE_SCL_STRETCH_CLR field.
	I2C_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR_Msk = 0x800
	// Bit SLAVE_SCL_STRETCH_CLR.
	I2C_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR = 0x800
	// Position of SLAVE_BYTE_ACK_CTL_EN field.
	I2C_SCL_STRETCH_CONF_SLAVE_BYTE_ACK_CTL_EN_Pos = 0xc
	// Bit mask of SLAVE_BYTE_ACK_CTL_EN field.
	I2C_SCL_STRETCH_CONF_SLAVE_BYTE_ACK_CTL_EN_Msk = 0x1000
	// Bit SLAVE_BYTE_ACK_CTL_EN.
	I2C_SCL_STRETCH_CONF_SLAVE_BYTE_ACK_CTL_EN = 0x1000
	// Position of SLAVE_BYTE_ACK_LVL field.
	I2C_SCL_STRETCH_CONF_SLAVE_BYTE_ACK_LVL_Pos = 0xd
	// Bit mask of SLAVE_BYTE_ACK_LVL field.
	I2C_SCL_STRETCH_CONF_SLAVE_BYTE_ACK_LVL_Msk = 0x2000
	// Bit SLAVE_BYTE_ACK_LVL.
	I2C_SCL_STRETCH_CONF_SLAVE_BYTE_ACK_LVL = 0x2000

	// DATE: Version register
	// Position of DATE field.
	I2C_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	I2C_DATE_DATE_Msk = 0xffffffff

	// TXFIFO_START_ADDR: I2C TXFIFO base address register
	// Position of TXFIFO_START_ADDR field.
	I2C_TXFIFO_START_ADDR_TXFIFO_START_ADDR_Pos = 0x0
	// Bit mask of TXFIFO_START_ADDR field.
	I2C_TXFIFO_START_ADDR_TXFIFO_START_ADDR_Msk = 0xffffffff

	// RXFIFO_START_ADDR: I2C RXFIFO base address register
	// Position of RXFIFO_START_ADDR field.
	I2C_RXFIFO_START_ADDR_RXFIFO_START_ADDR_Pos = 0x0
	// Bit mask of RXFIFO_START_ADDR field.
	I2C_RXFIFO_START_ADDR_RXFIFO_START_ADDR_Msk = 0xffffffff
)

// Constants for I2S0: I2S (Inter-IC Sound) Controller 0
const (
	// INT_RAW: I2S interrupt raw register, valid in level.
	// Position of RX_DONE_INT_RAW field.
	I2S_INT_RAW_RX_DONE_INT_RAW_Pos = 0x0
	// Bit mask of RX_DONE_INT_RAW field.
	I2S_INT_RAW_RX_DONE_INT_RAW_Msk = 0x1
	// Bit RX_DONE_INT_RAW.
	I2S_INT_RAW_RX_DONE_INT_RAW = 0x1
	// Position of TX_DONE_INT_RAW field.
	I2S_INT_RAW_TX_DONE_INT_RAW_Pos = 0x1
	// Bit mask of TX_DONE_INT_RAW field.
	I2S_INT_RAW_TX_DONE_INT_RAW_Msk = 0x2
	// Bit TX_DONE_INT_RAW.
	I2S_INT_RAW_TX_DONE_INT_RAW = 0x2
	// Position of RX_HUNG_INT_RAW field.
	I2S_INT_RAW_RX_HUNG_INT_RAW_Pos = 0x2
	// Bit mask of RX_HUNG_INT_RAW field.
	I2S_INT_RAW_RX_HUNG_INT_RAW_Msk = 0x4
	// Bit RX_HUNG_INT_RAW.
	I2S_INT_RAW_RX_HUNG_INT_RAW = 0x4
	// Position of TX_HUNG_INT_RAW field.
	I2S_INT_RAW_TX_HUNG_INT_RAW_Pos = 0x3
	// Bit mask of TX_HUNG_INT_RAW field.
	I2S_INT_RAW_TX_HUNG_INT_RAW_Msk = 0x8
	// Bit TX_HUNG_INT_RAW.
	I2S_INT_RAW_TX_HUNG_INT_RAW = 0x8

	// INT_ST: I2S interrupt status register.
	// Position of RX_DONE_INT_ST field.
	I2S_INT_ST_RX_DONE_INT_ST_Pos = 0x0
	// Bit mask of RX_DONE_INT_ST field.
	I2S_INT_ST_RX_DONE_INT_ST_Msk = 0x1
	// Bit RX_DONE_INT_ST.
	I2S_INT_ST_RX_DONE_INT_ST = 0x1
	// Position of TX_DONE_INT_ST field.
	I2S_INT_ST_TX_DONE_INT_ST_Pos = 0x1
	// Bit mask of TX_DONE_INT_ST field.
	I2S_INT_ST_TX_DONE_INT_ST_Msk = 0x2
	// Bit TX_DONE_INT_ST.
	I2S_INT_ST_TX_DONE_INT_ST = 0x2
	// Position of RX_HUNG_INT_ST field.
	I2S_INT_ST_RX_HUNG_INT_ST_Pos = 0x2
	// Bit mask of RX_HUNG_INT_ST field.
	I2S_INT_ST_RX_HUNG_INT_ST_Msk = 0x4
	// Bit RX_HUNG_INT_ST.
	I2S_INT_ST_RX_HUNG_INT_ST = 0x4
	// Position of TX_HUNG_INT_ST field.
	I2S_INT_ST_TX_HUNG_INT_ST_Pos = 0x3
	// Bit mask of TX_HUNG_INT_ST field.
	I2S_INT_ST_TX_HUNG_INT_ST_Msk = 0x8
	// Bit TX_HUNG_INT_ST.
	I2S_INT_ST_TX_HUNG_INT_ST = 0x8

	// INT_ENA: I2S interrupt enable register.
	// Position of RX_DONE_INT_ENA field.
	I2S_INT_ENA_RX_DONE_INT_ENA_Pos = 0x0
	// Bit mask of RX_DONE_INT_ENA field.
	I2S_INT_ENA_RX_DONE_INT_ENA_Msk = 0x1
	// Bit RX_DONE_INT_ENA.
	I2S_INT_ENA_RX_DONE_INT_ENA = 0x1
	// Position of TX_DONE_INT_ENA field.
	I2S_INT_ENA_TX_DONE_INT_ENA_Pos = 0x1
	// Bit mask of TX_DONE_INT_ENA field.
	I2S_INT_ENA_TX_DONE_INT_ENA_Msk = 0x2
	// Bit TX_DONE_INT_ENA.
	I2S_INT_ENA_TX_DONE_INT_ENA = 0x2
	// Position of RX_HUNG_INT_ENA field.
	I2S_INT_ENA_RX_HUNG_INT_ENA_Pos = 0x2
	// Bit mask of RX_HUNG_INT_ENA field.
	I2S_INT_ENA_RX_HUNG_INT_ENA_Msk = 0x4
	// Bit RX_HUNG_INT_ENA.
	I2S_INT_ENA_RX_HUNG_INT_ENA = 0x4
	// Position of TX_HUNG_INT_ENA field.
	I2S_INT_ENA_TX_HUNG_INT_ENA_Pos = 0x3
	// Bit mask of TX_HUNG_INT_ENA field.
	I2S_INT_ENA_TX_HUNG_INT_ENA_Msk = 0x8
	// Bit TX_HUNG_INT_ENA.
	I2S_INT_ENA_TX_HUNG_INT_ENA = 0x8

	// INT_CLR: I2S interrupt clear register.
	// Position of RX_DONE_INT_CLR field.
	I2S_INT_CLR_RX_DONE_INT_CLR_Pos = 0x0
	// Bit mask of RX_DONE_INT_CLR field.
	I2S_INT_CLR_RX_DONE_INT_CLR_Msk = 0x1
	// Bit RX_DONE_INT_CLR.
	I2S_INT_CLR_RX_DONE_INT_CLR = 0x1
	// Position of TX_DONE_INT_CLR field.
	I2S_INT_CLR_TX_DONE_INT_CLR_Pos = 0x1
	// Bit mask of TX_DONE_INT_CLR field.
	I2S_INT_CLR_TX_DONE_INT_CLR_Msk = 0x2
	// Bit TX_DONE_INT_CLR.
	I2S_INT_CLR_TX_DONE_INT_CLR = 0x2
	// Position of RX_HUNG_INT_CLR field.
	I2S_INT_CLR_RX_HUNG_INT_CLR_Pos = 0x2
	// Bit mask of RX_HUNG_INT_CLR field.
	I2S_INT_CLR_RX_HUNG_INT_CLR_Msk = 0x4
	// Bit RX_HUNG_INT_CLR.
	I2S_INT_CLR_RX_HUNG_INT_CLR = 0x4
	// Position of TX_HUNG_INT_CLR field.
	I2S_INT_CLR_TX_HUNG_INT_CLR_Pos = 0x3
	// Bit mask of TX_HUNG_INT_CLR field.
	I2S_INT_CLR_TX_HUNG_INT_CLR_Msk = 0x8
	// Bit TX_HUNG_INT_CLR.
	I2S_INT_CLR_TX_HUNG_INT_CLR = 0x8

	// RX_CONF: I2S RX configure register
	// Position of RX_RESET field.
	I2S_RX_CONF_RX_RESET_Pos = 0x0
	// Bit mask of RX_RESET field.
	I2S_RX_CONF_RX_RESET_Msk = 0x1
	// Bit RX_RESET.
	I2S_RX_CONF_RX_RESET = 0x1
	// Position of RX_FIFO_RESET field.
	I2S_RX_CONF_RX_FIFO_RESET_Pos = 0x1
	// Bit mask of RX_FIFO_RESET field.
	I2S_RX_CONF_RX_FIFO_RESET_Msk = 0x2
	// Bit RX_FIFO_RESET.
	I2S_RX_CONF_RX_FIFO_RESET = 0x2
	// Position of RX_START field.
	I2S_RX_CONF_RX_START_Pos = 0x2
	// Bit mask of RX_START field.
	I2S_RX_CONF_RX_START_Msk = 0x4
	// Bit RX_START.
	I2S_RX_CONF_RX_START = 0x4
	// Position of RX_SLAVE_MOD field.
	I2S_RX_CONF_RX_SLAVE_MOD_Pos = 0x3
	// Bit mask of RX_SLAVE_MOD field.
	I2S_RX_CONF_RX_SLAVE_MOD_Msk = 0x8
	// Bit RX_SLAVE_MOD.
	I2S_RX_CONF_RX_SLAVE_MOD = 0x8
	// Position of RX_STOP_MODE field.
	I2S_RX_CONF_RX_STOP_MODE_Pos = 0x4
	// Bit mask of RX_STOP_MODE field.
	I2S_RX_CONF_RX_STOP_MODE_Msk = 0x30
	// Position of RX_MONO field.
	I2S_RX_CONF_RX_MONO_Pos = 0x6
	// Bit mask of RX_MONO field.
	I2S_RX_CONF_RX_MONO_Msk = 0x40
	// Bit RX_MONO.
	I2S_RX_CONF_RX_MONO = 0x40
	// Position of RX_BIG_ENDIAN field.
	I2S_RX_CONF_RX_BIG_ENDIAN_Pos = 0x7
	// Bit mask of RX_BIG_ENDIAN field.
	I2S_RX_CONF_RX_BIG_ENDIAN_Msk = 0x80
	// Bit RX_BIG_ENDIAN.
	I2S_RX_CONF_RX_BIG_ENDIAN = 0x80
	// Position of RX_UPDATE field.
	I2S_RX_CONF_RX_UPDATE_Pos = 0x8
	// Bit mask of RX_UPDATE field.
	I2S_RX_CONF_RX_UPDATE_Msk = 0x100
	// Bit RX_UPDATE.
	I2S_RX_CONF_RX_UPDATE = 0x100
	// Position of RX_MONO_FST_VLD field.
	I2S_RX_CONF_RX_MONO_FST_VLD_Pos = 0x9
	// Bit mask of RX_MONO_FST_VLD field.
	I2S_RX_CONF_RX_MONO_FST_VLD_Msk = 0x200
	// Bit RX_MONO_FST_VLD.
	I2S_RX_CONF_RX_MONO_FST_VLD = 0x200
	// Position of RX_PCM_CONF field.
	I2S_RX_CONF_RX_PCM_CONF_Pos = 0xa
	// Bit mask of RX_PCM_CONF field.
	I2S_RX_CONF_RX_PCM_CONF_Msk = 0xc00
	// Position of RX_PCM_BYPASS field.
	I2S_RX_CONF_RX_PCM_BYPASS_Pos = 0xc
	// Bit mask of RX_PCM_BYPASS field.
	I2S_RX_CONF_RX_PCM_BYPASS_Msk = 0x1000
	// Bit RX_PCM_BYPASS.
	I2S_RX_CONF_RX_PCM_BYPASS = 0x1000
	// Position of RX_MSB_SHIFT field.
	I2S_RX_CONF_RX_MSB_SHIFT_Pos = 0xd
	// Bit mask of RX_MSB_SHIFT field.
	I2S_RX_CONF_RX_MSB_SHIFT_Msk = 0x2000
	// Bit RX_MSB_SHIFT.
	I2S_RX_CONF_RX_MSB_SHIFT = 0x2000
	// Position of RX_LEFT_ALIGN field.
	I2S_RX_CONF_RX_LEFT_ALIGN_Pos = 0xf
	// Bit mask of RX_LEFT_ALIGN field.
	I2S_RX_CONF_RX_LEFT_ALIGN_Msk = 0x8000
	// Bit RX_LEFT_ALIGN.
	I2S_RX_CONF_RX_LEFT_ALIGN = 0x8000
	// Position of RX_24_FILL_EN field.
	I2S_RX_CONF_RX_24_FILL_EN_Pos = 0x10
	// Bit mask of RX_24_FILL_EN field.
	I2S_RX_CONF_RX_24_FILL_EN_Msk = 0x10000
	// Bit RX_24_FILL_EN.
	I2S_RX_CONF_RX_24_FILL_EN = 0x10000
	// Position of RX_WS_IDLE_POL field.
	I2S_RX_CONF_RX_WS_IDLE_POL_Pos = 0x11
	// Bit mask of RX_WS_IDLE_POL field.
	I2S_RX_CONF_RX_WS_IDLE_POL_Msk = 0x20000
	// Bit RX_WS_IDLE_POL.
	I2S_RX_CONF_RX_WS_IDLE_POL = 0x20000
	// Position of RX_BIT_ORDER field.
	I2S_RX_CONF_RX_BIT_ORDER_Pos = 0x12
	// Bit mask of RX_BIT_ORDER field.
	I2S_RX_CONF_RX_BIT_ORDER_Msk = 0x40000
	// Bit RX_BIT_ORDER.
	I2S_RX_CONF_RX_BIT_ORDER = 0x40000
	// Position of RX_TDM_EN field.
	I2S_RX_CONF_RX_TDM_EN_Pos = 0x13
	// Bit mask of RX_TDM_EN field.
	I2S_RX_CONF_RX_TDM_EN_Msk = 0x80000
	// Bit RX_TDM_EN.
	I2S_RX_CONF_RX_TDM_EN = 0x80000
	// Position of RX_PDM_EN field.
	I2S_RX_CONF_RX_PDM_EN_Pos = 0x14
	// Bit mask of RX_PDM_EN field.
	I2S_RX_CONF_RX_PDM_EN_Msk = 0x100000
	// Bit RX_PDM_EN.
	I2S_RX_CONF_RX_PDM_EN = 0x100000
	// Position of RX_BCK_DIV_NUM field.
	I2S_RX_CONF_RX_BCK_DIV_NUM_Pos = 0x15
	// Bit mask of RX_BCK_DIV_NUM field.
	I2S_RX_CONF_RX_BCK_DIV_NUM_Msk = 0x7e00000

	// TX_CONF: I2S TX configure register
	// Position of TX_RESET field.
	I2S_TX_CONF_TX_RESET_Pos = 0x0
	// Bit mask of TX_RESET field.
	I2S_TX_CONF_TX_RESET_Msk = 0x1
	// Bit TX_RESET.
	I2S_TX_CONF_TX_RESET = 0x1
	// Position of TX_FIFO_RESET field.
	I2S_TX_CONF_TX_FIFO_RESET_Pos = 0x1
	// Bit mask of TX_FIFO_RESET field.
	I2S_TX_CONF_TX_FIFO_RESET_Msk = 0x2
	// Bit TX_FIFO_RESET.
	I2S_TX_CONF_TX_FIFO_RESET = 0x2
	// Position of TX_START field.
	I2S_TX_CONF_TX_START_Pos = 0x2
	// Bit mask of TX_START field.
	I2S_TX_CONF_TX_START_Msk = 0x4
	// Bit TX_START.
	I2S_TX_CONF_TX_START = 0x4
	// Position of TX_SLAVE_MOD field.
	I2S_TX_CONF_TX_SLAVE_MOD_Pos = 0x3
	// Bit mask of TX_SLAVE_MOD field.
	I2S_TX_CONF_TX_SLAVE_MOD_Msk = 0x8
	// Bit TX_SLAVE_MOD.
	I2S_TX_CONF_TX_SLAVE_MOD = 0x8
	// Position of TX_STOP_EN field.
	I2S_TX_CONF_TX_STOP_EN_Pos = 0x4
	// Bit mask of TX_STOP_EN field.
	I2S_TX_CONF_TX_STOP_EN_Msk = 0x10
	// Bit TX_STOP_EN.
	I2S_TX_CONF_TX_STOP_EN = 0x10
	// Position of TX_CHAN_EQUAL field.
	I2S_TX_CONF_TX_CHAN_EQUAL_Pos = 0x5
	// Bit mask of TX_CHAN_EQUAL field.
	I2S_TX_CONF_TX_CHAN_EQUAL_Msk = 0x20
	// Bit TX_CHAN_EQUAL.
	I2S_TX_CONF_TX_CHAN_EQUAL = 0x20
	// Position of TX_MONO field.
	I2S_TX_CONF_TX_MONO_Pos = 0x6
	// Bit mask of TX_MONO field.
	I2S_TX_CONF_TX_MONO_Msk = 0x40
	// Bit TX_MONO.
	I2S_TX_CONF_TX_MONO = 0x40
	// Position of TX_BIG_ENDIAN field.
	I2S_TX_CONF_TX_BIG_ENDIAN_Pos = 0x7
	// Bit mask of TX_BIG_ENDIAN field.
	I2S_TX_CONF_TX_BIG_ENDIAN_Msk = 0x80
	// Bit TX_BIG_ENDIAN.
	I2S_TX_CONF_TX_BIG_ENDIAN = 0x80
	// Position of TX_UPDATE field.
	I2S_TX_CONF_TX_UPDATE_Pos = 0x8
	// Bit mask of TX_UPDATE field.
	I2S_TX_CONF_TX_UPDATE_Msk = 0x100
	// Bit TX_UPDATE.
	I2S_TX_CONF_TX_UPDATE = 0x100
	// Position of TX_MONO_FST_VLD field.
	I2S_TX_CONF_TX_MONO_FST_VLD_Pos = 0x9
	// Bit mask of TX_MONO_FST_VLD field.
	I2S_TX_CONF_TX_MONO_FST_VLD_Msk = 0x200
	// Bit TX_MONO_FST_VLD.
	I2S_TX_CONF_TX_MONO_FST_VLD = 0x200
	// Position of TX_PCM_CONF field.
	I2S_TX_CONF_TX_PCM_CONF_Pos = 0xa
	// Bit mask of TX_PCM_CONF field.
	I2S_TX_CONF_TX_PCM_CONF_Msk = 0xc00
	// Position of TX_PCM_BYPASS field.
	I2S_TX_CONF_TX_PCM_BYPASS_Pos = 0xc
	// Bit mask of TX_PCM_BYPASS field.
	I2S_TX_CONF_TX_PCM_BYPASS_Msk = 0x1000
	// Bit TX_PCM_BYPASS.
	I2S_TX_CONF_TX_PCM_BYPASS = 0x1000
	// Position of TX_MSB_SHIFT field.
	I2S_TX_CONF_TX_MSB_SHIFT_Pos = 0xd
	// Bit mask of TX_MSB_SHIFT field.
	I2S_TX_CONF_TX_MSB_SHIFT_Msk = 0x2000
	// Bit TX_MSB_SHIFT.
	I2S_TX_CONF_TX_MSB_SHIFT = 0x2000
	// Position of TX_BCK_NO_DLY field.
	I2S_TX_CONF_TX_BCK_NO_DLY_Pos = 0xe
	// Bit mask of TX_BCK_NO_DLY field.
	I2S_TX_CONF_TX_BCK_NO_DLY_Msk = 0x4000
	// Bit TX_BCK_NO_DLY.
	I2S_TX_CONF_TX_BCK_NO_DLY = 0x4000
	// Position of TX_LEFT_ALIGN field.
	I2S_TX_CONF_TX_LEFT_ALIGN_Pos = 0xf
	// Bit mask of TX_LEFT_ALIGN field.
	I2S_TX_CONF_TX_LEFT_ALIGN_Msk = 0x8000
	// Bit TX_LEFT_ALIGN.
	I2S_TX_CONF_TX_LEFT_ALIGN = 0x8000
	// Position of TX_24_FILL_EN field.
	I2S_TX_CONF_TX_24_FILL_EN_Pos = 0x10
	// Bit mask of TX_24_FILL_EN field.
	I2S_TX_CONF_TX_24_FILL_EN_Msk = 0x10000
	// Bit TX_24_FILL_EN.
	I2S_TX_CONF_TX_24_FILL_EN = 0x10000
	// Position of TX_WS_IDLE_POL field.
	I2S_TX_CONF_TX_WS_IDLE_POL_Pos = 0x11
	// Bit mask of TX_WS_IDLE_POL field.
	I2S_TX_CONF_TX_WS_IDLE_POL_Msk = 0x20000
	// Bit TX_WS_IDLE_POL.
	I2S_TX_CONF_TX_WS_IDLE_POL = 0x20000
	// Position of TX_BIT_ORDER field.
	I2S_TX_CONF_TX_BIT_ORDER_Pos = 0x12
	// Bit mask of TX_BIT_ORDER field.
	I2S_TX_CONF_TX_BIT_ORDER_Msk = 0x40000
	// Bit TX_BIT_ORDER.
	I2S_TX_CONF_TX_BIT_ORDER = 0x40000
	// Position of TX_TDM_EN field.
	I2S_TX_CONF_TX_TDM_EN_Pos = 0x13
	// Bit mask of TX_TDM_EN field.
	I2S_TX_CONF_TX_TDM_EN_Msk = 0x80000
	// Bit TX_TDM_EN.
	I2S_TX_CONF_TX_TDM_EN = 0x80000
	// Position of TX_PDM_EN field.
	I2S_TX_CONF_TX_PDM_EN_Pos = 0x14
	// Bit mask of TX_PDM_EN field.
	I2S_TX_CONF_TX_PDM_EN_Msk = 0x100000
	// Bit TX_PDM_EN.
	I2S_TX_CONF_TX_PDM_EN = 0x100000
	// Position of TX_BCK_DIV_NUM field.
	I2S_TX_CONF_TX_BCK_DIV_NUM_Pos = 0x15
	// Bit mask of TX_BCK_DIV_NUM field.
	I2S_TX_CONF_TX_BCK_DIV_NUM_Msk = 0x7e00000
	// Position of TX_CHAN_MOD field.
	I2S_TX_CONF_TX_CHAN_MOD_Pos = 0x1b
	// Bit mask of TX_CHAN_MOD field.
	I2S_TX_CONF_TX_CHAN_MOD_Msk = 0x38000000
	// Position of SIG_LOOPBACK field.
	I2S_TX_CONF_SIG_LOOPBACK_Pos = 0x1e
	// Bit mask of SIG_LOOPBACK field.
	I2S_TX_CONF_SIG_LOOPBACK_Msk = 0x40000000
	// Bit SIG_LOOPBACK.
	I2S_TX_CONF_SIG_LOOPBACK = 0x40000000

	// RX_CONF1: I2S RX configure register 1
	// Position of RX_TDM_WS_WIDTH field.
	I2S_RX_CONF1_RX_TDM_WS_WIDTH_Pos = 0x0
	// Bit mask of RX_TDM_WS_WIDTH field.
	I2S_RX_CONF1_RX_TDM_WS_WIDTH_Msk = 0x1ff
	// Position of RX_BITS_MOD field.
	I2S_RX_CONF1_RX_BITS_MOD_Pos = 0xe
	// Bit mask of RX_BITS_MOD field.
	I2S_RX_CONF1_RX_BITS_MOD_Msk = 0x7c000
	// Position of RX_HALF_SAMPLE_BITS field.
	I2S_RX_CONF1_RX_HALF_SAMPLE_BITS_Pos = 0x13
	// Bit mask of RX_HALF_SAMPLE_BITS field.
	I2S_RX_CONF1_RX_HALF_SAMPLE_BITS_Msk = 0x7f80000
	// Position of RX_TDM_CHAN_BITS field.
	I2S_RX_CONF1_RX_TDM_CHAN_BITS_Pos = 0x1b
	// Bit mask of RX_TDM_CHAN_BITS field.
	I2S_RX_CONF1_RX_TDM_CHAN_BITS_Msk = 0xf8000000

	// TX_CONF1: I2S TX configure register 1
	// Position of TX_TDM_WS_WIDTH field.
	I2S_TX_CONF1_TX_TDM_WS_WIDTH_Pos = 0x0
	// Bit mask of TX_TDM_WS_WIDTH field.
	I2S_TX_CONF1_TX_TDM_WS_WIDTH_Msk = 0x1ff
	// Position of TX_BITS_MOD field.
	I2S_TX_CONF1_TX_BITS_MOD_Pos = 0xe
	// Bit mask of TX_BITS_MOD field.
	I2S_TX_CONF1_TX_BITS_MOD_Msk = 0x7c000
	// Position of TX_HALF_SAMPLE_BITS field.
	I2S_TX_CONF1_TX_HALF_SAMPLE_BITS_Pos = 0x13
	// Bit mask of TX_HALF_SAMPLE_BITS field.
	I2S_TX_CONF1_TX_HALF_SAMPLE_BITS_Msk = 0x7f80000
	// Position of TX_TDM_CHAN_BITS field.
	I2S_TX_CONF1_TX_TDM_CHAN_BITS_Pos = 0x1b
	// Bit mask of TX_TDM_CHAN_BITS field.
	I2S_TX_CONF1_TX_TDM_CHAN_BITS_Msk = 0xf8000000

	// RX_CLKM_CONF: I2S RX clock configure register
	// Position of RX_CLKM_DIV_NUM field.
	I2S_RX_CLKM_CONF_RX_CLKM_DIV_NUM_Pos = 0x0
	// Bit mask of RX_CLKM_DIV_NUM field.
	I2S_RX_CLKM_CONF_RX_CLKM_DIV_NUM_Msk = 0xff
	// Position of RX_CLK_ACTIVE field.
	I2S_RX_CLKM_CONF_RX_CLK_ACTIVE_Pos = 0x1a
	// Bit mask of RX_CLK_ACTIVE field.
	I2S_RX_CLKM_CONF_RX_CLK_ACTIVE_Msk = 0x4000000
	// Bit RX_CLK_ACTIVE.
	I2S_RX_CLKM_CONF_RX_CLK_ACTIVE = 0x4000000
	// Position of RX_CLK_SEL field.
	I2S_RX_CLKM_CONF_RX_CLK_SEL_Pos = 0x1b
	// Bit mask of RX_CLK_SEL field.
	I2S_RX_CLKM_CONF_RX_CLK_SEL_Msk = 0x18000000
	// Position of MCLK_SEL field.
	I2S_RX_CLKM_CONF_MCLK_SEL_Pos = 0x1d
	// Bit mask of MCLK_SEL field.
	I2S_RX_CLKM_CONF_MCLK_SEL_Msk = 0x20000000
	// Bit MCLK_SEL.
	I2S_RX_CLKM_CONF_MCLK_SEL = 0x20000000

	// TX_CLKM_CONF: I2S TX clock configure register
	// Position of TX_CLKM_DIV_NUM field.
	I2S_TX_CLKM_CONF_TX_CLKM_DIV_NUM_Pos = 0x0
	// Bit mask of TX_CLKM_DIV_NUM field.
	I2S_TX_CLKM_CONF_TX_CLKM_DIV_NUM_Msk = 0xff
	// Position of TX_CLK_ACTIVE field.
	I2S_TX_CLKM_CONF_TX_CLK_ACTIVE_Pos = 0x1a
	// Bit mask of TX_CLK_ACTIVE field.
	I2S_TX_CLKM_CONF_TX_CLK_ACTIVE_Msk = 0x4000000
	// Bit TX_CLK_ACTIVE.
	I2S_TX_CLKM_CONF_TX_CLK_ACTIVE = 0x4000000
	// Position of TX_CLK_SEL field.
	I2S_TX_CLKM_CONF_TX_CLK_SEL_Pos = 0x1b
	// Bit mask of TX_CLK_SEL field.
	I2S_TX_CLKM_CONF_TX_CLK_SEL_Msk = 0x18000000
	// Position of CLK_EN field.
	I2S_TX_CLKM_CONF_CLK_EN_Pos = 0x1d
	// Bit mask of CLK_EN field.
	I2S_TX_CLKM_CONF_CLK_EN_Msk = 0x20000000
	// Bit CLK_EN.
	I2S_TX_CLKM_CONF_CLK_EN = 0x20000000

	// RX_CLKM_DIV_CONF: I2S RX module clock divider configure register
	// Position of RX_CLKM_DIV_Z field.
	I2S_RX_CLKM_DIV_CONF_RX_CLKM_DIV_Z_Pos = 0x0
	// Bit mask of RX_CLKM_DIV_Z field.
	I2S_RX_CLKM_DIV_CONF_RX_CLKM_DIV_Z_Msk = 0x1ff
	// Position of RX_CLKM_DIV_Y field.
	I2S_RX_CLKM_DIV_CONF_RX_CLKM_DIV_Y_Pos = 0x9
	// Bit mask of RX_CLKM_DIV_Y field.
	I2S_RX_CLKM_DIV_CONF_RX_CLKM_DIV_Y_Msk = 0x3fe00
	// Position of RX_CLKM_DIV_X field.
	I2S_RX_CLKM_DIV_CONF_RX_CLKM_DIV_X_Pos = 0x12
	// Bit mask of RX_CLKM_DIV_X field.
	I2S_RX_CLKM_DIV_CONF_RX_CLKM_DIV_X_Msk = 0x7fc0000
	// Position of RX_CLKM_DIV_YN1 field.
	I2S_RX_CLKM_DIV_CONF_RX_CLKM_DIV_YN1_Pos = 0x1b
	// Bit mask of RX_CLKM_DIV_YN1 field.
	I2S_RX_CLKM_DIV_CONF_RX_CLKM_DIV_YN1_Msk = 0x8000000
	// Bit RX_CLKM_DIV_YN1.
	I2S_RX_CLKM_DIV_CONF_RX_CLKM_DIV_YN1 = 0x8000000

	// TX_CLKM_DIV_CONF: I2S TX module clock divider configure register
	// Position of TX_CLKM_DIV_Z field.
	I2S_TX_CLKM_DIV_CONF_TX_CLKM_DIV_Z_Pos = 0x0
	// Bit mask of TX_CLKM_DIV_Z field.
	I2S_TX_CLKM_DIV_CONF_TX_CLKM_DIV_Z_Msk = 0x1ff
	// Position of TX_CLKM_DIV_Y field.
	I2S_TX_CLKM_DIV_CONF_TX_CLKM_DIV_Y_Pos = 0x9
	// Bit mask of TX_CLKM_DIV_Y field.
	I2S_TX_CLKM_DIV_CONF_TX_CLKM_DIV_Y_Msk = 0x3fe00
	// Position of TX_CLKM_DIV_X field.
	I2S_TX_CLKM_DIV_CONF_TX_CLKM_DIV_X_Pos = 0x12
	// Bit mask of TX_CLKM_DIV_X field.
	I2S_TX_CLKM_DIV_CONF_TX_CLKM_DIV_X_Msk = 0x7fc0000
	// Position of TX_CLKM_DIV_YN1 field.
	I2S_TX_CLKM_DIV_CONF_TX_CLKM_DIV_YN1_Pos = 0x1b
	// Bit mask of TX_CLKM_DIV_YN1 field.
	I2S_TX_CLKM_DIV_CONF_TX_CLKM_DIV_YN1_Msk = 0x8000000
	// Bit TX_CLKM_DIV_YN1.
	I2S_TX_CLKM_DIV_CONF_TX_CLKM_DIV_YN1 = 0x8000000

	// TX_PCM2PDM_CONF: I2S TX PCM2PDM configuration register
	// Position of TX_PDM_HP_BYPASS field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_HP_BYPASS_Pos = 0x0
	// Bit mask of TX_PDM_HP_BYPASS field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_HP_BYPASS_Msk = 0x1
	// Bit TX_PDM_HP_BYPASS.
	I2S_TX_PCM2PDM_CONF_TX_PDM_HP_BYPASS = 0x1
	// Position of TX_PDM_SINC_OSR2 field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_SINC_OSR2_Pos = 0x1
	// Bit mask of TX_PDM_SINC_OSR2 field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_SINC_OSR2_Msk = 0x1e
	// Position of TX_PDM_PRESCALE field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_PRESCALE_Pos = 0x5
	// Bit mask of TX_PDM_PRESCALE field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_PRESCALE_Msk = 0x1fe0
	// Position of TX_PDM_HP_IN_SHIFT field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_HP_IN_SHIFT_Pos = 0xd
	// Bit mask of TX_PDM_HP_IN_SHIFT field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_HP_IN_SHIFT_Msk = 0x6000
	// Position of TX_PDM_LP_IN_SHIFT field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_LP_IN_SHIFT_Pos = 0xf
	// Bit mask of TX_PDM_LP_IN_SHIFT field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_LP_IN_SHIFT_Msk = 0x18000
	// Position of TX_PDM_SINC_IN_SHIFT field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_SINC_IN_SHIFT_Pos = 0x11
	// Bit mask of TX_PDM_SINC_IN_SHIFT field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_SINC_IN_SHIFT_Msk = 0x60000
	// Position of TX_PDM_SIGMADELTA_IN_SHIFT field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_IN_SHIFT_Pos = 0x13
	// Bit mask of TX_PDM_SIGMADELTA_IN_SHIFT field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_IN_SHIFT_Msk = 0x180000
	// Position of TX_PDM_SIGMADELTA_DITHER2 field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_DITHER2_Pos = 0x15
	// Bit mask of TX_PDM_SIGMADELTA_DITHER2 field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_DITHER2_Msk = 0x200000
	// Bit TX_PDM_SIGMADELTA_DITHER2.
	I2S_TX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_DITHER2 = 0x200000
	// Position of TX_PDM_SIGMADELTA_DITHER field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_DITHER_Pos = 0x16
	// Bit mask of TX_PDM_SIGMADELTA_DITHER field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_DITHER_Msk = 0x400000
	// Bit TX_PDM_SIGMADELTA_DITHER.
	I2S_TX_PCM2PDM_CONF_TX_PDM_SIGMADELTA_DITHER = 0x400000
	// Position of TX_PDM_DAC_2OUT_EN field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_DAC_2OUT_EN_Pos = 0x17
	// Bit mask of TX_PDM_DAC_2OUT_EN field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_DAC_2OUT_EN_Msk = 0x800000
	// Bit TX_PDM_DAC_2OUT_EN.
	I2S_TX_PCM2PDM_CONF_TX_PDM_DAC_2OUT_EN = 0x800000
	// Position of TX_PDM_DAC_MODE_EN field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_DAC_MODE_EN_Pos = 0x18
	// Bit mask of TX_PDM_DAC_MODE_EN field.
	I2S_TX_PCM2PDM_CONF_TX_PDM_DAC_MODE_EN_Msk = 0x1000000
	// Bit TX_PDM_DAC_MODE_EN.
	I2S_TX_PCM2PDM_CONF_TX_PDM_DAC_MODE_EN = 0x1000000
	// Position of PCM2PDM_CONV_EN field.
	I2S_TX_PCM2PDM_CONF_PCM2PDM_CONV_EN_Pos = 0x19
	// Bit mask of PCM2PDM_CONV_EN field.
	I2S_TX_PCM2PDM_CONF_PCM2PDM_CONV_EN_Msk = 0x2000000
	// Bit PCM2PDM_CONV_EN.
	I2S_TX_PCM2PDM_CONF_PCM2PDM_CONV_EN = 0x2000000

	// TX_PCM2PDM_CONF1: I2S TX PCM2PDM configuration register
	// Position of TX_PDM_FP field.
	I2S_TX_PCM2PDM_CONF1_TX_PDM_FP_Pos = 0x0
	// Bit mask of TX_PDM_FP field.
	I2S_TX_PCM2PDM_CONF1_TX_PDM_FP_Msk = 0x3ff
	// Position of TX_PDM_FS field.
	I2S_TX_PCM2PDM_CONF1_TX_PDM_FS_Pos = 0xa
	// Bit mask of TX_PDM_FS field.
	I2S_TX_PCM2PDM_CONF1_TX_PDM_FS_Msk = 0xffc00
	// Position of TX_IIR_HP_MULT12_5 field.
	I2S_TX_PCM2PDM_CONF1_TX_IIR_HP_MULT12_5_Pos = 0x14
	// Bit mask of TX_IIR_HP_MULT12_5 field.
	I2S_TX_PCM2PDM_CONF1_TX_IIR_HP_MULT12_5_Msk = 0x700000
	// Position of TX_IIR_HP_MULT12_0 field.
	I2S_TX_PCM2PDM_CONF1_TX_IIR_HP_MULT12_0_Pos = 0x17
	// Bit mask of TX_IIR_HP_MULT12_0 field.
	I2S_TX_PCM2PDM_CONF1_TX_IIR_HP_MULT12_0_Msk = 0x3800000

	// RX_TDM_CTRL: I2S TX TDM mode control register
	// Position of RX_TDM_PDM_CHAN0_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN0_EN_Pos = 0x0
	// Bit mask of RX_TDM_PDM_CHAN0_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN0_EN_Msk = 0x1
	// Bit RX_TDM_PDM_CHAN0_EN.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN0_EN = 0x1
	// Position of RX_TDM_PDM_CHAN1_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN1_EN_Pos = 0x1
	// Bit mask of RX_TDM_PDM_CHAN1_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN1_EN_Msk = 0x2
	// Bit RX_TDM_PDM_CHAN1_EN.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN1_EN = 0x2
	// Position of RX_TDM_PDM_CHAN2_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN2_EN_Pos = 0x2
	// Bit mask of RX_TDM_PDM_CHAN2_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN2_EN_Msk = 0x4
	// Bit RX_TDM_PDM_CHAN2_EN.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN2_EN = 0x4
	// Position of RX_TDM_PDM_CHAN3_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN3_EN_Pos = 0x3
	// Bit mask of RX_TDM_PDM_CHAN3_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN3_EN_Msk = 0x8
	// Bit RX_TDM_PDM_CHAN3_EN.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN3_EN = 0x8
	// Position of RX_TDM_PDM_CHAN4_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN4_EN_Pos = 0x4
	// Bit mask of RX_TDM_PDM_CHAN4_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN4_EN_Msk = 0x10
	// Bit RX_TDM_PDM_CHAN4_EN.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN4_EN = 0x10
	// Position of RX_TDM_PDM_CHAN5_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN5_EN_Pos = 0x5
	// Bit mask of RX_TDM_PDM_CHAN5_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN5_EN_Msk = 0x20
	// Bit RX_TDM_PDM_CHAN5_EN.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN5_EN = 0x20
	// Position of RX_TDM_PDM_CHAN6_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN6_EN_Pos = 0x6
	// Bit mask of RX_TDM_PDM_CHAN6_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN6_EN_Msk = 0x40
	// Bit RX_TDM_PDM_CHAN6_EN.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN6_EN = 0x40
	// Position of RX_TDM_PDM_CHAN7_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN7_EN_Pos = 0x7
	// Bit mask of RX_TDM_PDM_CHAN7_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN7_EN_Msk = 0x80
	// Bit RX_TDM_PDM_CHAN7_EN.
	I2S_RX_TDM_CTRL_RX_TDM_PDM_CHAN7_EN = 0x80
	// Position of RX_TDM_CHAN8_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN8_EN_Pos = 0x8
	// Bit mask of RX_TDM_CHAN8_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN8_EN_Msk = 0x100
	// Bit RX_TDM_CHAN8_EN.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN8_EN = 0x100
	// Position of RX_TDM_CHAN9_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN9_EN_Pos = 0x9
	// Bit mask of RX_TDM_CHAN9_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN9_EN_Msk = 0x200
	// Bit RX_TDM_CHAN9_EN.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN9_EN = 0x200
	// Position of RX_TDM_CHAN10_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN10_EN_Pos = 0xa
	// Bit mask of RX_TDM_CHAN10_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN10_EN_Msk = 0x400
	// Bit RX_TDM_CHAN10_EN.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN10_EN = 0x400
	// Position of RX_TDM_CHAN11_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN11_EN_Pos = 0xb
	// Bit mask of RX_TDM_CHAN11_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN11_EN_Msk = 0x800
	// Bit RX_TDM_CHAN11_EN.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN11_EN = 0x800
	// Position of RX_TDM_CHAN12_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN12_EN_Pos = 0xc
	// Bit mask of RX_TDM_CHAN12_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN12_EN_Msk = 0x1000
	// Bit RX_TDM_CHAN12_EN.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN12_EN = 0x1000
	// Position of RX_TDM_CHAN13_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN13_EN_Pos = 0xd
	// Bit mask of RX_TDM_CHAN13_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN13_EN_Msk = 0x2000
	// Bit RX_TDM_CHAN13_EN.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN13_EN = 0x2000
	// Position of RX_TDM_CHAN14_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN14_EN_Pos = 0xe
	// Bit mask of RX_TDM_CHAN14_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN14_EN_Msk = 0x4000
	// Bit RX_TDM_CHAN14_EN.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN14_EN = 0x4000
	// Position of RX_TDM_CHAN15_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN15_EN_Pos = 0xf
	// Bit mask of RX_TDM_CHAN15_EN field.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN15_EN_Msk = 0x8000
	// Bit RX_TDM_CHAN15_EN.
	I2S_RX_TDM_CTRL_RX_TDM_CHAN15_EN = 0x8000
	// Position of RX_TDM_TOT_CHAN_NUM field.
	I2S_RX_TDM_CTRL_RX_TDM_TOT_CHAN_NUM_Pos = 0x10
	// Bit mask of RX_TDM_TOT_CHAN_NUM field.
	I2S_RX_TDM_CTRL_RX_TDM_TOT_CHAN_NUM_Msk = 0xf0000

	// TX_TDM_CTRL: I2S TX TDM mode control register
	// Position of TX_TDM_CHAN0_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN0_EN_Pos = 0x0
	// Bit mask of TX_TDM_CHAN0_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN0_EN_Msk = 0x1
	// Bit TX_TDM_CHAN0_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN0_EN = 0x1
	// Position of TX_TDM_CHAN1_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN1_EN_Pos = 0x1
	// Bit mask of TX_TDM_CHAN1_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN1_EN_Msk = 0x2
	// Bit TX_TDM_CHAN1_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN1_EN = 0x2
	// Position of TX_TDM_CHAN2_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN2_EN_Pos = 0x2
	// Bit mask of TX_TDM_CHAN2_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN2_EN_Msk = 0x4
	// Bit TX_TDM_CHAN2_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN2_EN = 0x4
	// Position of TX_TDM_CHAN3_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN3_EN_Pos = 0x3
	// Bit mask of TX_TDM_CHAN3_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN3_EN_Msk = 0x8
	// Bit TX_TDM_CHAN3_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN3_EN = 0x8
	// Position of TX_TDM_CHAN4_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN4_EN_Pos = 0x4
	// Bit mask of TX_TDM_CHAN4_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN4_EN_Msk = 0x10
	// Bit TX_TDM_CHAN4_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN4_EN = 0x10
	// Position of TX_TDM_CHAN5_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN5_EN_Pos = 0x5
	// Bit mask of TX_TDM_CHAN5_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN5_EN_Msk = 0x20
	// Bit TX_TDM_CHAN5_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN5_EN = 0x20
	// Position of TX_TDM_CHAN6_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN6_EN_Pos = 0x6
	// Bit mask of TX_TDM_CHAN6_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN6_EN_Msk = 0x40
	// Bit TX_TDM_CHAN6_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN6_EN = 0x40
	// Position of TX_TDM_CHAN7_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN7_EN_Pos = 0x7
	// Bit mask of TX_TDM_CHAN7_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN7_EN_Msk = 0x80
	// Bit TX_TDM_CHAN7_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN7_EN = 0x80
	// Position of TX_TDM_CHAN8_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN8_EN_Pos = 0x8
	// Bit mask of TX_TDM_CHAN8_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN8_EN_Msk = 0x100
	// Bit TX_TDM_CHAN8_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN8_EN = 0x100
	// Position of TX_TDM_CHAN9_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN9_EN_Pos = 0x9
	// Bit mask of TX_TDM_CHAN9_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN9_EN_Msk = 0x200
	// Bit TX_TDM_CHAN9_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN9_EN = 0x200
	// Position of TX_TDM_CHAN10_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN10_EN_Pos = 0xa
	// Bit mask of TX_TDM_CHAN10_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN10_EN_Msk = 0x400
	// Bit TX_TDM_CHAN10_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN10_EN = 0x400
	// Position of TX_TDM_CHAN11_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN11_EN_Pos = 0xb
	// Bit mask of TX_TDM_CHAN11_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN11_EN_Msk = 0x800
	// Bit TX_TDM_CHAN11_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN11_EN = 0x800
	// Position of TX_TDM_CHAN12_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN12_EN_Pos = 0xc
	// Bit mask of TX_TDM_CHAN12_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN12_EN_Msk = 0x1000
	// Bit TX_TDM_CHAN12_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN12_EN = 0x1000
	// Position of TX_TDM_CHAN13_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN13_EN_Pos = 0xd
	// Bit mask of TX_TDM_CHAN13_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN13_EN_Msk = 0x2000
	// Bit TX_TDM_CHAN13_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN13_EN = 0x2000
	// Position of TX_TDM_CHAN14_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN14_EN_Pos = 0xe
	// Bit mask of TX_TDM_CHAN14_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN14_EN_Msk = 0x4000
	// Bit TX_TDM_CHAN14_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN14_EN = 0x4000
	// Position of TX_TDM_CHAN15_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN15_EN_Pos = 0xf
	// Bit mask of TX_TDM_CHAN15_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN15_EN_Msk = 0x8000
	// Bit TX_TDM_CHAN15_EN.
	I2S_TX_TDM_CTRL_TX_TDM_CHAN15_EN = 0x8000
	// Position of TX_TDM_TOT_CHAN_NUM field.
	I2S_TX_TDM_CTRL_TX_TDM_TOT_CHAN_NUM_Pos = 0x10
	// Bit mask of TX_TDM_TOT_CHAN_NUM field.
	I2S_TX_TDM_CTRL_TX_TDM_TOT_CHAN_NUM_Msk = 0xf0000
	// Position of TX_TDM_SKIP_MSK_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_SKIP_MSK_EN_Pos = 0x14
	// Bit mask of TX_TDM_SKIP_MSK_EN field.
	I2S_TX_TDM_CTRL_TX_TDM_SKIP_MSK_EN_Msk = 0x100000
	// Bit TX_TDM_SKIP_MSK_EN.
	I2S_TX_TDM_CTRL_TX_TDM_SKIP_MSK_EN = 0x100000

	// RX_TIMING: I2S RX timing control register
	// Position of RX_SD_IN_DM field.
	I2S_RX_TIMING_RX_SD_IN_DM_Pos = 0x0
	// Bit mask of RX_SD_IN_DM field.
	I2S_RX_TIMING_RX_SD_IN_DM_Msk = 0x3
	// Position of RX_WS_OUT_DM field.
	I2S_RX_TIMING_RX_WS_OUT_DM_Pos = 0x10
	// Bit mask of RX_WS_OUT_DM field.
	I2S_RX_TIMING_RX_WS_OUT_DM_Msk = 0x30000
	// Position of RX_BCK_OUT_DM field.
	I2S_RX_TIMING_RX_BCK_OUT_DM_Pos = 0x14
	// Bit mask of RX_BCK_OUT_DM field.
	I2S_RX_TIMING_RX_BCK_OUT_DM_Msk = 0x300000
	// Position of RX_WS_IN_DM field.
	I2S_RX_TIMING_RX_WS_IN_DM_Pos = 0x18
	// Bit mask of RX_WS_IN_DM field.
	I2S_RX_TIMING_RX_WS_IN_DM_Msk = 0x3000000
	// Position of RX_BCK_IN_DM field.
	I2S_RX_TIMING_RX_BCK_IN_DM_Pos = 0x1c
	// Bit mask of RX_BCK_IN_DM field.
	I2S_RX_TIMING_RX_BCK_IN_DM_Msk = 0x30000000

	// TX_TIMING: I2S TX timing control register
	// Position of TX_SD_OUT_DM field.
	I2S_TX_TIMING_TX_SD_OUT_DM_Pos = 0x0
	// Bit mask of TX_SD_OUT_DM field.
	I2S_TX_TIMING_TX_SD_OUT_DM_Msk = 0x3
	// Position of TX_SD1_OUT_DM field.
	I2S_TX_TIMING_TX_SD1_OUT_DM_Pos = 0x4
	// Bit mask of TX_SD1_OUT_DM field.
	I2S_TX_TIMING_TX_SD1_OUT_DM_Msk = 0x30
	// Position of TX_WS_OUT_DM field.
	I2S_TX_TIMING_TX_WS_OUT_DM_Pos = 0x10
	// Bit mask of TX_WS_OUT_DM field.
	I2S_TX_TIMING_TX_WS_OUT_DM_Msk = 0x30000
	// Position of TX_BCK_OUT_DM field.
	I2S_TX_TIMING_TX_BCK_OUT_DM_Pos = 0x14
	// Bit mask of TX_BCK_OUT_DM field.
	I2S_TX_TIMING_TX_BCK_OUT_DM_Msk = 0x300000
	// Position of TX_WS_IN_DM field.
	I2S_TX_TIMING_TX_WS_IN_DM_Pos = 0x18
	// Bit mask of TX_WS_IN_DM field.
	I2S_TX_TIMING_TX_WS_IN_DM_Msk = 0x3000000
	// Position of TX_BCK_IN_DM field.
	I2S_TX_TIMING_TX_BCK_IN_DM_Pos = 0x1c
	// Bit mask of TX_BCK_IN_DM field.
	I2S_TX_TIMING_TX_BCK_IN_DM_Msk = 0x30000000

	// LC_HUNG_CONF: I2S HUNG configure register.
	// Position of LC_FIFO_TIMEOUT field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_Pos = 0x0
	// Bit mask of LC_FIFO_TIMEOUT field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_Msk = 0xff
	// Position of LC_FIFO_TIMEOUT_SHIFT field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_SHIFT_Pos = 0x8
	// Bit mask of LC_FIFO_TIMEOUT_SHIFT field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_SHIFT_Msk = 0x700
	// Position of LC_FIFO_TIMEOUT_ENA field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA_Pos = 0xb
	// Bit mask of LC_FIFO_TIMEOUT_ENA field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA_Msk = 0x800
	// Bit LC_FIFO_TIMEOUT_ENA.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA = 0x800

	// RXEOF_NUM: I2S RX data number control register.
	// Position of RX_EOF_NUM field.
	I2S_RXEOF_NUM_RX_EOF_NUM_Pos = 0x0
	// Bit mask of RX_EOF_NUM field.
	I2S_RXEOF_NUM_RX_EOF_NUM_Msk = 0xfff

	// CONF_SIGLE_DATA: I2S signal data register
	// Position of SINGLE_DATA field.
	I2S_CONF_SIGLE_DATA_SINGLE_DATA_Pos = 0x0
	// Bit mask of SINGLE_DATA field.
	I2S_CONF_SIGLE_DATA_SINGLE_DATA_Msk = 0xffffffff

	// STATE: I2S TX status register
	// Position of TX_IDLE field.
	I2S_STATE_TX_IDLE_Pos = 0x0
	// Bit mask of TX_IDLE field.
	I2S_STATE_TX_IDLE_Msk = 0x1
	// Bit TX_IDLE.
	I2S_STATE_TX_IDLE = 0x1

	// ETM_CONF: I2S ETM configure register
	// Position of ETM_TX_SEND_WORD_NUM field.
	I2S_ETM_CONF_ETM_TX_SEND_WORD_NUM_Pos = 0x0
	// Bit mask of ETM_TX_SEND_WORD_NUM field.
	I2S_ETM_CONF_ETM_TX_SEND_WORD_NUM_Msk = 0x3ff
	// Position of ETM_RX_RECEIVE_WORD_NUM field.
	I2S_ETM_CONF_ETM_RX_RECEIVE_WORD_NUM_Pos = 0xa
	// Bit mask of ETM_RX_RECEIVE_WORD_NUM field.
	I2S_ETM_CONF_ETM_RX_RECEIVE_WORD_NUM_Msk = 0xffc00

	// DATE: Version control register
	// Position of DATE field.
	I2S_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	I2S_DATE_DATE_Msk = 0xfffffff
)

// Constants for INTERRUPT_CORE0: Interrupt Controller (Core 0)
const (
	// PMU_INTR_MAP: register description
	// Position of PMU_INTR_MAP field.
	INTMTX_CORE0_PMU_INTR_MAP_PMU_INTR_MAP_Pos = 0x0
	// Bit mask of PMU_INTR_MAP field.
	INTMTX_CORE0_PMU_INTR_MAP_PMU_INTR_MAP_Msk = 0x1f

	// EFUSE_INTR_MAP: register description
	// Position of EFUSE_INTR_MAP field.
	INTMTX_CORE0_EFUSE_INTR_MAP_EFUSE_INTR_MAP_Pos = 0x0
	// Bit mask of EFUSE_INTR_MAP field.
	INTMTX_CORE0_EFUSE_INTR_MAP_EFUSE_INTR_MAP_Msk = 0x1f

	// LP_RTC_TIMER_INTR_MAP: register description
	// Position of LP_RTC_TIMER_INTR_MAP field.
	INTMTX_CORE0_LP_RTC_TIMER_INTR_MAP_LP_RTC_TIMER_INTR_MAP_Pos = 0x0
	// Bit mask of LP_RTC_TIMER_INTR_MAP field.
	INTMTX_CORE0_LP_RTC_TIMER_INTR_MAP_LP_RTC_TIMER_INTR_MAP_Msk = 0x1f

	// LP_BLE_TIMER_INTR_MAP: register description
	// Position of LP_BLE_TIMER_INTR_MAP field.
	INTMTX_CORE0_LP_BLE_TIMER_INTR_MAP_LP_BLE_TIMER_INTR_MAP_Pos = 0x0
	// Bit mask of LP_BLE_TIMER_INTR_MAP field.
	INTMTX_CORE0_LP_BLE_TIMER_INTR_MAP_LP_BLE_TIMER_INTR_MAP_Msk = 0x1f

	// LP_WDT_INTR_MAP: register description
	// Position of LP_WDT_INTR_MAP field.
	INTMTX_CORE0_LP_WDT_INTR_MAP_LP_WDT_INTR_MAP_Pos = 0x0
	// Bit mask of LP_WDT_INTR_MAP field.
	INTMTX_CORE0_LP_WDT_INTR_MAP_LP_WDT_INTR_MAP_Msk = 0x1f

	// LP_PERI_TIMEOUT_INTR_MAP: register description
	// Position of LP_PERI_TIMEOUT_INTR_MAP field.
	INTMTX_CORE0_LP_PERI_TIMEOUT_INTR_MAP_LP_PERI_TIMEOUT_INTR_MAP_Pos = 0x0
	// Bit mask of LP_PERI_TIMEOUT_INTR_MAP field.
	INTMTX_CORE0_LP_PERI_TIMEOUT_INTR_MAP_LP_PERI_TIMEOUT_INTR_MAP_Msk = 0x1f

	// LP_APM_M0_INTR_MAP: register description
	// Position of LP_APM_M0_INTR_MAP field.
	INTMTX_CORE0_LP_APM_M0_INTR_MAP_LP_APM_M0_INTR_MAP_Pos = 0x0
	// Bit mask of LP_APM_M0_INTR_MAP field.
	INTMTX_CORE0_LP_APM_M0_INTR_MAP_LP_APM_M0_INTR_MAP_Msk = 0x1f

	// CPU_INTR_FROM_CPU_0_MAP: register description
	// Position of CPU_INTR_FROM_CPU_0_MAP field.
	INTMTX_CORE0_CPU_INTR_FROM_CPU_0_MAP_CPU_INTR_FROM_CPU_0_MAP_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_0_MAP field.
	INTMTX_CORE0_CPU_INTR_FROM_CPU_0_MAP_CPU_INTR_FROM_CPU_0_MAP_Msk = 0x1f

	// CPU_INTR_FROM_CPU_1_MAP: register description
	// Position of CPU_INTR_FROM_CPU_1_MAP field.
	INTMTX_CORE0_CPU_INTR_FROM_CPU_1_MAP_CPU_INTR_FROM_CPU_1_MAP_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_1_MAP field.
	INTMTX_CORE0_CPU_INTR_FROM_CPU_1_MAP_CPU_INTR_FROM_CPU_1_MAP_Msk = 0x1f

	// CPU_INTR_FROM_CPU_2_MAP: register description
	// Position of CPU_INTR_FROM_CPU_2_MAP field.
	INTMTX_CORE0_CPU_INTR_FROM_CPU_2_MAP_CPU_INTR_FROM_CPU_2_MAP_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_2_MAP field.
	INTMTX_CORE0_CPU_INTR_FROM_CPU_2_MAP_CPU_INTR_FROM_CPU_2_MAP_Msk = 0x1f

	// CPU_INTR_FROM_CPU_3_MAP: register description
	// Position of CPU_INTR_FROM_CPU_3_MAP field.
	INTMTX_CORE0_CPU_INTR_FROM_CPU_3_MAP_CPU_INTR_FROM_CPU_3_MAP_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_3_MAP field.
	INTMTX_CORE0_CPU_INTR_FROM_CPU_3_MAP_CPU_INTR_FROM_CPU_3_MAP_Msk = 0x1f

	// ASSIST_DEBUG_INTR_MAP: register description
	// Position of ASSIST_DEBUG_INTR_MAP field.
	INTMTX_CORE0_ASSIST_DEBUG_INTR_MAP_ASSIST_DEBUG_INTR_MAP_Pos = 0x0
	// Bit mask of ASSIST_DEBUG_INTR_MAP field.
	INTMTX_CORE0_ASSIST_DEBUG_INTR_MAP_ASSIST_DEBUG_INTR_MAP_Msk = 0x1f

	// TRACE_INTR_MAP: register description
	// Position of TRACE_INTR_MAP field.
	INTMTX_CORE0_TRACE_INTR_MAP_TRACE_INTR_MAP_Pos = 0x0
	// Bit mask of TRACE_INTR_MAP field.
	INTMTX_CORE0_TRACE_INTR_MAP_TRACE_INTR_MAP_Msk = 0x1f

	// CACHE_INTR_MAP: register description
	// Position of CACHE_INTR_MAP field.
	INTMTX_CORE0_CACHE_INTR_MAP_CACHE_INTR_MAP_Pos = 0x0
	// Bit mask of CACHE_INTR_MAP field.
	INTMTX_CORE0_CACHE_INTR_MAP_CACHE_INTR_MAP_Msk = 0x1f

	// CPU_PERI_TIMEOUT_INTR_MAP: register description
	// Position of CPU_PERI_TIMEOUT_INTR_MAP field.
	INTMTX_CORE0_CPU_PERI_TIMEOUT_INTR_MAP_CPU_PERI_TIMEOUT_INTR_MAP_Pos = 0x0
	// Bit mask of CPU_PERI_TIMEOUT_INTR_MAP field.
	INTMTX_CORE0_CPU_PERI_TIMEOUT_INTR_MAP_CPU_PERI_TIMEOUT_INTR_MAP_Msk = 0x1f

	// BT_MAC_INTR_MAP: register description
	// Position of BT_MAC_INTR_MAP field.
	INTMTX_CORE0_BT_MAC_INTR_MAP_BT_MAC_INTR_MAP_Pos = 0x0
	// Bit mask of BT_MAC_INTR_MAP field.
	INTMTX_CORE0_BT_MAC_INTR_MAP_BT_MAC_INTR_MAP_Msk = 0x1f

	// BT_BB_INTR_MAP: register description
	// Position of BT_BB_INTR_MAP field.
	INTMTX_CORE0_BT_BB_INTR_MAP_BT_BB_INTR_MAP_Pos = 0x0
	// Bit mask of BT_BB_INTR_MAP field.
	INTMTX_CORE0_BT_BB_INTR_MAP_BT_BB_INTR_MAP_Msk = 0x1f

	// BT_BB_NMI_MAP: register description
	// Position of BT_BB_NMI_MAP field.
	INTMTX_CORE0_BT_BB_NMI_MAP_BT_BB_NMI_MAP_Pos = 0x0
	// Bit mask of BT_BB_NMI_MAP field.
	INTMTX_CORE0_BT_BB_NMI_MAP_BT_BB_NMI_MAP_Msk = 0x1f

	// COEX_INTR_MAP: register description
	// Position of COEX_INTR_MAP field.
	INTMTX_CORE0_COEX_INTR_MAP_COEX_INTR_MAP_Pos = 0x0
	// Bit mask of COEX_INTR_MAP field.
	INTMTX_CORE0_COEX_INTR_MAP_COEX_INTR_MAP_Msk = 0x1f

	// BLE_TIMER_INTR_MAP: register description
	// Position of BLE_TIMER_INTR_MAP field.
	INTMTX_CORE0_BLE_TIMER_INTR_MAP_BLE_TIMER_INTR_MAP_Pos = 0x0
	// Bit mask of BLE_TIMER_INTR_MAP field.
	INTMTX_CORE0_BLE_TIMER_INTR_MAP_BLE_TIMER_INTR_MAP_Msk = 0x1f

	// BLE_SEC_INTR_MAP: register description
	// Position of BLE_SEC_INTR_MAP field.
	INTMTX_CORE0_BLE_SEC_INTR_MAP_BLE_SEC_INTR_MAP_Pos = 0x0
	// Bit mask of BLE_SEC_INTR_MAP field.
	INTMTX_CORE0_BLE_SEC_INTR_MAP_BLE_SEC_INTR_MAP_Msk = 0x1f

	// ZB_MAC_INTR_MAP: register description
	// Position of ZB_MAC_INTR_MAP field.
	INTMTX_CORE0_ZB_MAC_INTR_MAP_ZB_MAC_INTR_MAP_Pos = 0x0
	// Bit mask of ZB_MAC_INTR_MAP field.
	INTMTX_CORE0_ZB_MAC_INTR_MAP_ZB_MAC_INTR_MAP_Msk = 0x1f

	// GPIO_INTERRUPT_PRO_MAP: register description
	// Position of GPIO_INTERRUPT_PRO_MAP field.
	INTMTX_CORE0_GPIO_INTERRUPT_PRO_MAP_GPIO_INTERRUPT_PRO_MAP_Pos = 0x0
	// Bit mask of GPIO_INTERRUPT_PRO_MAP field.
	INTMTX_CORE0_GPIO_INTERRUPT_PRO_MAP_GPIO_INTERRUPT_PRO_MAP_Msk = 0x1f

	// GPIO_INTERRUPT_PRO_NMI_MAP: register description
	// Position of GPIO_INTERRUPT_PRO_NMI_MAP field.
	INTMTX_CORE0_GPIO_INTERRUPT_PRO_NMI_MAP_GPIO_INTERRUPT_PRO_NMI_MAP_Pos = 0x0
	// Bit mask of GPIO_INTERRUPT_PRO_NMI_MAP field.
	INTMTX_CORE0_GPIO_INTERRUPT_PRO_NMI_MAP_GPIO_INTERRUPT_PRO_NMI_MAP_Msk = 0x1f

	// PAU_INTR_MAP: register description
	// Position of PAU_INTR_MAP field.
	INTMTX_CORE0_PAU_INTR_MAP_PAU_INTR_MAP_Pos = 0x0
	// Bit mask of PAU_INTR_MAP field.
	INTMTX_CORE0_PAU_INTR_MAP_PAU_INTR_MAP_Msk = 0x1f

	// HP_PERI_TIMEOUT_INTR_MAP: register description
	// Position of HP_PERI_TIMEOUT_INTR_MAP field.
	INTMTX_CORE0_HP_PERI_TIMEOUT_INTR_MAP_HP_PERI_TIMEOUT_INTR_MAP_Pos = 0x0
	// Bit mask of HP_PERI_TIMEOUT_INTR_MAP field.
	INTMTX_CORE0_HP_PERI_TIMEOUT_INTR_MAP_HP_PERI_TIMEOUT_INTR_MAP_Msk = 0x1f

	// HP_APM_M0_INTR_MAP: register description
	// Position of HP_APM_M0_INTR_MAP field.
	INTMTX_CORE0_HP_APM_M0_INTR_MAP_HP_APM_M0_INTR_MAP_Pos = 0x0
	// Bit mask of HP_APM_M0_INTR_MAP field.
	INTMTX_CORE0_HP_APM_M0_INTR_MAP_HP_APM_M0_INTR_MAP_Msk = 0x1f

	// HP_APM_M1_INTR_MAP: register description
	// Position of HP_APM_M1_INTR_MAP field.
	INTMTX_CORE0_HP_APM_M1_INTR_MAP_HP_APM_M1_INTR_MAP_Pos = 0x0
	// Bit mask of HP_APM_M1_INTR_MAP field.
	INTMTX_CORE0_HP_APM_M1_INTR_MAP_HP_APM_M1_INTR_MAP_Msk = 0x1f

	// HP_APM_M2_INTR_MAP: register description
	// Position of HP_APM_M2_INTR_MAP field.
	INTMTX_CORE0_HP_APM_M2_INTR_MAP_HP_APM_M2_INTR_MAP_Pos = 0x0
	// Bit mask of HP_APM_M2_INTR_MAP field.
	INTMTX_CORE0_HP_APM_M2_INTR_MAP_HP_APM_M2_INTR_MAP_Msk = 0x1f

	// HP_APM_M3_INTR_MAP: register description
	// Position of HP_APM_M3_INTR_MAP field.
	INTMTX_CORE0_HP_APM_M3_INTR_MAP_HP_APM_M3_INTR_MAP_Pos = 0x0
	// Bit mask of HP_APM_M3_INTR_MAP field.
	INTMTX_CORE0_HP_APM_M3_INTR_MAP_HP_APM_M3_INTR_MAP_Msk = 0x1f

	// MSPI_INTR_MAP: register description
	// Position of MSPI_INTR_MAP field.
	INTMTX_CORE0_MSPI_INTR_MAP_MSPI_INTR_MAP_Pos = 0x0
	// Bit mask of MSPI_INTR_MAP field.
	INTMTX_CORE0_MSPI_INTR_MAP_MSPI_INTR_MAP_Msk = 0x1f

	// I2S1_INTR_MAP: register description
	// Position of I2S1_INTR_MAP field.
	INTMTX_CORE0_I2S1_INTR_MAP_I2S1_INTR_MAP_Pos = 0x0
	// Bit mask of I2S1_INTR_MAP field.
	INTMTX_CORE0_I2S1_INTR_MAP_I2S1_INTR_MAP_Msk = 0x1f

	// UHCI0_INTR_MAP: register description
	// Position of UHCI0_INTR_MAP field.
	INTMTX_CORE0_UHCI0_INTR_MAP_UHCI0_INTR_MAP_Pos = 0x0
	// Bit mask of UHCI0_INTR_MAP field.
	INTMTX_CORE0_UHCI0_INTR_MAP_UHCI0_INTR_MAP_Msk = 0x1f

	// UART0_INTR_MAP: register description
	// Position of UART0_INTR_MAP field.
	INTMTX_CORE0_UART0_INTR_MAP_UART0_INTR_MAP_Pos = 0x0
	// Bit mask of UART0_INTR_MAP field.
	INTMTX_CORE0_UART0_INTR_MAP_UART0_INTR_MAP_Msk = 0x1f

	// UART1_INTR_MAP: register description
	// Position of UART1_INTR_MAP field.
	INTMTX_CORE0_UART1_INTR_MAP_UART1_INTR_MAP_Pos = 0x0
	// Bit mask of UART1_INTR_MAP field.
	INTMTX_CORE0_UART1_INTR_MAP_UART1_INTR_MAP_Msk = 0x1f

	// LEDC_INTR_MAP: register description
	// Position of LEDC_INTR_MAP field.
	INTMTX_CORE0_LEDC_INTR_MAP_LEDC_INTR_MAP_Pos = 0x0
	// Bit mask of LEDC_INTR_MAP field.
	INTMTX_CORE0_LEDC_INTR_MAP_LEDC_INTR_MAP_Msk = 0x1f

	// CAN0_INTR_MAP: register description
	// Position of CAN0_INTR_MAP field.
	INTMTX_CORE0_CAN0_INTR_MAP_CAN0_INTR_MAP_Pos = 0x0
	// Bit mask of CAN0_INTR_MAP field.
	INTMTX_CORE0_CAN0_INTR_MAP_CAN0_INTR_MAP_Msk = 0x1f

	// USB_INTR_MAP: register description
	// Position of USB_INTR_MAP field.
	INTMTX_CORE0_USB_INTR_MAP_USB_INTR_MAP_Pos = 0x0
	// Bit mask of USB_INTR_MAP field.
	INTMTX_CORE0_USB_INTR_MAP_USB_INTR_MAP_Msk = 0x1f

	// RMT_INTR_MAP: register description
	// Position of RMT_INTR_MAP field.
	INTMTX_CORE0_RMT_INTR_MAP_RMT_INTR_MAP_Pos = 0x0
	// Bit mask of RMT_INTR_MAP field.
	INTMTX_CORE0_RMT_INTR_MAP_RMT_INTR_MAP_Msk = 0x1f

	// I2C_EXT0_INTR_MAP: register description
	// Position of I2C_EXT0_INTR_MAP field.
	INTMTX_CORE0_I2C_EXT0_INTR_MAP_I2C_EXT0_INTR_MAP_Pos = 0x0
	// Bit mask of I2C_EXT0_INTR_MAP field.
	INTMTX_CORE0_I2C_EXT0_INTR_MAP_I2C_EXT0_INTR_MAP_Msk = 0x1f

	// I2C_EXT1_INTR_MAP: register description
	// Position of I2C_EXT1_INTR_MAP field.
	INTMTX_CORE0_I2C_EXT1_INTR_MAP_I2C_EXT1_INTR_MAP_Pos = 0x0
	// Bit mask of I2C_EXT1_INTR_MAP field.
	INTMTX_CORE0_I2C_EXT1_INTR_MAP_I2C_EXT1_INTR_MAP_Msk = 0x1f

	// TG0_T0_INTR_MAP: register description
	// Position of TG0_T0_INTR_MAP field.
	INTMTX_CORE0_TG0_T0_INTR_MAP_TG0_T0_INTR_MAP_Pos = 0x0
	// Bit mask of TG0_T0_INTR_MAP field.
	INTMTX_CORE0_TG0_T0_INTR_MAP_TG0_T0_INTR_MAP_Msk = 0x1f

	// TG0_WDT_INTR_MAP: register description
	// Position of TG0_WDT_INTR_MAP field.
	INTMTX_CORE0_TG0_WDT_INTR_MAP_TG0_WDT_INTR_MAP_Pos = 0x0
	// Bit mask of TG0_WDT_INTR_MAP field.
	INTMTX_CORE0_TG0_WDT_INTR_MAP_TG0_WDT_INTR_MAP_Msk = 0x1f

	// TG1_T0_INTR_MAP: register description
	// Position of TG1_T0_INTR_MAP field.
	INTMTX_CORE0_TG1_T0_INTR_MAP_TG1_T0_INTR_MAP_Pos = 0x0
	// Bit mask of TG1_T0_INTR_MAP field.
	INTMTX_CORE0_TG1_T0_INTR_MAP_TG1_T0_INTR_MAP_Msk = 0x1f

	// TG1_WDT_INTR_MAP: register description
	// Position of TG1_WDT_INTR_MAP field.
	INTMTX_CORE0_TG1_WDT_INTR_MAP_TG1_WDT_INTR_MAP_Pos = 0x0
	// Bit mask of TG1_WDT_INTR_MAP field.
	INTMTX_CORE0_TG1_WDT_INTR_MAP_TG1_WDT_INTR_MAP_Msk = 0x1f

	// SYSTIMER_TARGET0_INTR_MAP: register description
	// Position of SYSTIMER_TARGET0_INTR_MAP field.
	INTMTX_CORE0_SYSTIMER_TARGET0_INTR_MAP_SYSTIMER_TARGET0_INTR_MAP_Pos = 0x0
	// Bit mask of SYSTIMER_TARGET0_INTR_MAP field.
	INTMTX_CORE0_SYSTIMER_TARGET0_INTR_MAP_SYSTIMER_TARGET0_INTR_MAP_Msk = 0x1f

	// SYSTIMER_TARGET1_INTR_MAP: register description
	// Position of SYSTIMER_TARGET1_INTR_MAP field.
	INTMTX_CORE0_SYSTIMER_TARGET1_INTR_MAP_SYSTIMER_TARGET1_INTR_MAP_Pos = 0x0
	// Bit mask of SYSTIMER_TARGET1_INTR_MAP field.
	INTMTX_CORE0_SYSTIMER_TARGET1_INTR_MAP_SYSTIMER_TARGET1_INTR_MAP_Msk = 0x1f

	// SYSTIMER_TARGET2_INTR_MAP: register description
	// Position of SYSTIMER_TARGET2_INTR_MAP field.
	INTMTX_CORE0_SYSTIMER_TARGET2_INTR_MAP_SYSTIMER_TARGET2_INTR_MAP_Pos = 0x0
	// Bit mask of SYSTIMER_TARGET2_INTR_MAP field.
	INTMTX_CORE0_SYSTIMER_TARGET2_INTR_MAP_SYSTIMER_TARGET2_INTR_MAP_Msk = 0x1f

	// APB_ADC_INTR_MAP: register description
	// Position of APB_ADC_INTR_MAP field.
	INTMTX_CORE0_APB_ADC_INTR_MAP_APB_ADC_INTR_MAP_Pos = 0x0
	// Bit mask of APB_ADC_INTR_MAP field.
	INTMTX_CORE0_APB_ADC_INTR_MAP_APB_ADC_INTR_MAP_Msk = 0x1f

	// PWM_INTR_MAP: register description
	// Position of PWM_INTR_MAP field.
	INTMTX_CORE0_PWM_INTR_MAP_PWM_INTR_MAP_Pos = 0x0
	// Bit mask of PWM_INTR_MAP field.
	INTMTX_CORE0_PWM_INTR_MAP_PWM_INTR_MAP_Msk = 0x1f

	// PCNT_INTR_MAP: register description
	// Position of PCNT_INTR_MAP field.
	INTMTX_CORE0_PCNT_INTR_MAP_PCNT_INTR_MAP_Pos = 0x0
	// Bit mask of PCNT_INTR_MAP field.
	INTMTX_CORE0_PCNT_INTR_MAP_PCNT_INTR_MAP_Msk = 0x1f

	// PARL_IO_TX_INTR_MAP: register description
	// Position of PARL_IO_TX_INTR_MAP field.
	INTMTX_CORE0_PARL_IO_TX_INTR_MAP_PARL_IO_TX_INTR_MAP_Pos = 0x0
	// Bit mask of PARL_IO_TX_INTR_MAP field.
	INTMTX_CORE0_PARL_IO_TX_INTR_MAP_PARL_IO_TX_INTR_MAP_Msk = 0x1f

	// PARL_IO_RX_INTR_MAP: register description
	// Position of PARL_IO_RX_INTR_MAP field.
	INTMTX_CORE0_PARL_IO_RX_INTR_MAP_PARL_IO_RX_INTR_MAP_Pos = 0x0
	// Bit mask of PARL_IO_RX_INTR_MAP field.
	INTMTX_CORE0_PARL_IO_RX_INTR_MAP_PARL_IO_RX_INTR_MAP_Msk = 0x1f

	// DMA_IN_CH0_INTR_MAP: register description
	// Position of DMA_IN_CH0_INTR_MAP field.
	INTMTX_CORE0_DMA_IN_CH0_INTR_MAP_DMA_IN_CH0_INTR_MAP_Pos = 0x0
	// Bit mask of DMA_IN_CH0_INTR_MAP field.
	INTMTX_CORE0_DMA_IN_CH0_INTR_MAP_DMA_IN_CH0_INTR_MAP_Msk = 0x1f

	// DMA_IN_CH1_INTR_MAP: register description
	// Position of DMA_IN_CH1_INTR_MAP field.
	INTMTX_CORE0_DMA_IN_CH1_INTR_MAP_DMA_IN_CH1_INTR_MAP_Pos = 0x0
	// Bit mask of DMA_IN_CH1_INTR_MAP field.
	INTMTX_CORE0_DMA_IN_CH1_INTR_MAP_DMA_IN_CH1_INTR_MAP_Msk = 0x1f

	// DMA_IN_CH2_INTR_MAP: register description
	// Position of DMA_IN_CH2_INTR_MAP field.
	INTMTX_CORE0_DMA_IN_CH2_INTR_MAP_DMA_IN_CH2_INTR_MAP_Pos = 0x0
	// Bit mask of DMA_IN_CH2_INTR_MAP field.
	INTMTX_CORE0_DMA_IN_CH2_INTR_MAP_DMA_IN_CH2_INTR_MAP_Msk = 0x1f

	// DMA_OUT_CH0_INTR_MAP: register description
	// Position of DMA_OUT_CH0_INTR_MAP field.
	INTMTX_CORE0_DMA_OUT_CH0_INTR_MAP_DMA_OUT_CH0_INTR_MAP_Pos = 0x0
	// Bit mask of DMA_OUT_CH0_INTR_MAP field.
	INTMTX_CORE0_DMA_OUT_CH0_INTR_MAP_DMA_OUT_CH0_INTR_MAP_Msk = 0x1f

	// DMA_OUT_CH1_INTR_MAP: register description
	// Position of DMA_OUT_CH1_INTR_MAP field.
	INTMTX_CORE0_DMA_OUT_CH1_INTR_MAP_DMA_OUT_CH1_INTR_MAP_Pos = 0x0
	// Bit mask of DMA_OUT_CH1_INTR_MAP field.
	INTMTX_CORE0_DMA_OUT_CH1_INTR_MAP_DMA_OUT_CH1_INTR_MAP_Msk = 0x1f

	// DMA_OUT_CH2_INTR_MAP: register description
	// Position of DMA_OUT_CH2_INTR_MAP field.
	INTMTX_CORE0_DMA_OUT_CH2_INTR_MAP_DMA_OUT_CH2_INTR_MAP_Pos = 0x0
	// Bit mask of DMA_OUT_CH2_INTR_MAP field.
	INTMTX_CORE0_DMA_OUT_CH2_INTR_MAP_DMA_OUT_CH2_INTR_MAP_Msk = 0x1f

	// GPSPI2_INTR_MAP: register description
	// Position of GPSPI2_INTR_MAP field.
	INTMTX_CORE0_GPSPI2_INTR_MAP_GPSPI2_INTR_MAP_Pos = 0x0
	// Bit mask of GPSPI2_INTR_MAP field.
	INTMTX_CORE0_GPSPI2_INTR_MAP_GPSPI2_INTR_MAP_Msk = 0x1f

	// AES_INTR_MAP: register description
	// Position of AES_INTR_MAP field.
	INTMTX_CORE0_AES_INTR_MAP_AES_INTR_MAP_Pos = 0x0
	// Bit mask of AES_INTR_MAP field.
	INTMTX_CORE0_AES_INTR_MAP_AES_INTR_MAP_Msk = 0x1f

	// SHA_INTR_MAP: register description
	// Position of SHA_INTR_MAP field.
	INTMTX_CORE0_SHA_INTR_MAP_SHA_INTR_MAP_Pos = 0x0
	// Bit mask of SHA_INTR_MAP field.
	INTMTX_CORE0_SHA_INTR_MAP_SHA_INTR_MAP_Msk = 0x1f

	// RSA_INTR_MAP: register description
	// Position of RSA_INTR_MAP field.
	INTMTX_CORE0_RSA_INTR_MAP_RSA_INTR_MAP_Pos = 0x0
	// Bit mask of RSA_INTR_MAP field.
	INTMTX_CORE0_RSA_INTR_MAP_RSA_INTR_MAP_Msk = 0x1f

	// ECC_INTR_MAP: register description
	// Position of ECC_INTR_MAP field.
	INTMTX_CORE0_ECC_INTR_MAP_ECC_INTR_MAP_Pos = 0x0
	// Bit mask of ECC_INTR_MAP field.
	INTMTX_CORE0_ECC_INTR_MAP_ECC_INTR_MAP_Msk = 0x1f

	// ECDSA_INTR_MAP: register description
	// Position of ECDSA_INTR_MAP field.
	INTMTX_CORE0_ECDSA_INTR_MAP_ECDSA_INTR_MAP_Pos = 0x0
	// Bit mask of ECDSA_INTR_MAP field.
	INTMTX_CORE0_ECDSA_INTR_MAP_ECDSA_INTR_MAP_Msk = 0x1f

	// INTR_STATUS_REG_0: register description
	// Position of INTR_STATUS_0 field.
	INTMTX_CORE0_INTR_STATUS_REG_0_INTR_STATUS_0_Pos = 0x0
	// Bit mask of INTR_STATUS_0 field.
	INTMTX_CORE0_INTR_STATUS_REG_0_INTR_STATUS_0_Msk = 0xffffffff

	// INTR_STATUS_REG_1: register description
	// Position of INTR_STATUS_1 field.
	INTMTX_CORE0_INTR_STATUS_REG_1_INTR_STATUS_1_Pos = 0x0
	// Bit mask of INTR_STATUS_1 field.
	INTMTX_CORE0_INTR_STATUS_REG_1_INTR_STATUS_1_Msk = 0xffffffff

	// INT_STATUS_REG_2: register description
	// Position of INT_STATUS_2 field.
	INTMTX_CORE0_INT_STATUS_REG_2_INT_STATUS_2_Pos = 0x0
	// Bit mask of INT_STATUS_2 field.
	INTMTX_CORE0_INT_STATUS_REG_2_INT_STATUS_2_Msk = 0xffffffff

	// CLOCK_GATE: register description
	// Position of REG_CLK_EN field.
	INTMTX_CORE0_CLOCK_GATE_REG_CLK_EN_Pos = 0x0
	// Bit mask of REG_CLK_EN field.
	INTMTX_CORE0_CLOCK_GATE_REG_CLK_EN_Msk = 0x1
	// Bit REG_CLK_EN.
	INTMTX_CORE0_CLOCK_GATE_REG_CLK_EN = 0x1

	// INTERRUPT_REG_DATE: register description
	// Position of INTERRUPT_REG_DATE field.
	INTMTX_CORE0_INTERRUPT_REG_DATE_INTERRUPT_REG_DATE_Pos = 0x0
	// Bit mask of INTERRUPT_REG_DATE field.
	INTMTX_CORE0_INTERRUPT_REG_DATE_INTERRUPT_REG_DATE_Msk = 0xfffffff
)

// Constants for INTPRI: INTPRI Peripheral
const (
	// CPU_INT_ENABLE: register description
	// Position of CPU_INT_ENABLE field.
	INTPRI_CPU_INT_ENABLE_CPU_INT_ENABLE_Pos = 0x0
	// Bit mask of CPU_INT_ENABLE field.
	INTPRI_CPU_INT_ENABLE_CPU_INT_ENABLE_Msk = 0xffffffff

	// CPU_INT_TYPE: register description
	// Position of CPU_INT_TYPE field.
	INTPRI_CPU_INT_TYPE_CPU_INT_TYPE_Pos = 0x0
	// Bit mask of CPU_INT_TYPE field.
	INTPRI_CPU_INT_TYPE_CPU_INT_TYPE_Msk = 0xffffffff

	// CPU_INT_EIP_STATUS: register description
	// Position of CPU_INT_EIP_STATUS field.
	INTPRI_CPU_INT_EIP_STATUS_CPU_INT_EIP_STATUS_Pos = 0x0
	// Bit mask of CPU_INT_EIP_STATUS field.
	INTPRI_CPU_INT_EIP_STATUS_CPU_INT_EIP_STATUS_Msk = 0xffffffff

	// CPU_INT_PRI_0: register description
	// Position of CPU_PRI_0_MAP field.
	INTPRI_CPU_INT_PRI_0_CPU_PRI_0_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_0_MAP field.
	INTPRI_CPU_INT_PRI_0_CPU_PRI_0_MAP_Msk = 0xf

	// CPU_INT_PRI_1: register description
	// Position of CPU_PRI_1_MAP field.
	INTPRI_CPU_INT_PRI_1_CPU_PRI_1_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_1_MAP field.
	INTPRI_CPU_INT_PRI_1_CPU_PRI_1_MAP_Msk = 0xf

	// CPU_INT_PRI_2: register description
	// Position of CPU_PRI_2_MAP field.
	INTPRI_CPU_INT_PRI_2_CPU_PRI_2_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_2_MAP field.
	INTPRI_CPU_INT_PRI_2_CPU_PRI_2_MAP_Msk = 0xf

	// CPU_INT_PRI_3: register description
	// Position of CPU_PRI_3_MAP field.
	INTPRI_CPU_INT_PRI_3_CPU_PRI_3_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_3_MAP field.
	INTPRI_CPU_INT_PRI_3_CPU_PRI_3_MAP_Msk = 0xf

	// CPU_INT_PRI_4: register description
	// Position of CPU_PRI_4_MAP field.
	INTPRI_CPU_INT_PRI_4_CPU_PRI_4_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_4_MAP field.
	INTPRI_CPU_INT_PRI_4_CPU_PRI_4_MAP_Msk = 0xf

	// CPU_INT_PRI_5: register description
	// Position of CPU_PRI_5_MAP field.
	INTPRI_CPU_INT_PRI_5_CPU_PRI_5_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_5_MAP field.
	INTPRI_CPU_INT_PRI_5_CPU_PRI_5_MAP_Msk = 0xf

	// CPU_INT_PRI_6: register description
	// Position of CPU_PRI_6_MAP field.
	INTPRI_CPU_INT_PRI_6_CPU_PRI_6_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_6_MAP field.
	INTPRI_CPU_INT_PRI_6_CPU_PRI_6_MAP_Msk = 0xf

	// CPU_INT_PRI_7: register description
	// Position of CPU_PRI_7_MAP field.
	INTPRI_CPU_INT_PRI_7_CPU_PRI_7_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_7_MAP field.
	INTPRI_CPU_INT_PRI_7_CPU_PRI_7_MAP_Msk = 0xf

	// CPU_INT_PRI_8: register description
	// Position of CPU_PRI_8_MAP field.
	INTPRI_CPU_INT_PRI_8_CPU_PRI_8_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_8_MAP field.
	INTPRI_CPU_INT_PRI_8_CPU_PRI_8_MAP_Msk = 0xf

	// CPU_INT_PRI_9: register description
	// Position of CPU_PRI_9_MAP field.
	INTPRI_CPU_INT_PRI_9_CPU_PRI_9_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_9_MAP field.
	INTPRI_CPU_INT_PRI_9_CPU_PRI_9_MAP_Msk = 0xf

	// CPU_INT_PRI_10: register description
	// Position of CPU_PRI_10_MAP field.
	INTPRI_CPU_INT_PRI_10_CPU_PRI_10_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_10_MAP field.
	INTPRI_CPU_INT_PRI_10_CPU_PRI_10_MAP_Msk = 0xf

	// CPU_INT_PRI_11: register description
	// Position of CPU_PRI_11_MAP field.
	INTPRI_CPU_INT_PRI_11_CPU_PRI_11_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_11_MAP field.
	INTPRI_CPU_INT_PRI_11_CPU_PRI_11_MAP_Msk = 0xf

	// CPU_INT_PRI_12: register description
	// Position of CPU_PRI_12_MAP field.
	INTPRI_CPU_INT_PRI_12_CPU_PRI_12_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_12_MAP field.
	INTPRI_CPU_INT_PRI_12_CPU_PRI_12_MAP_Msk = 0xf

	// CPU_INT_PRI_13: register description
	// Position of CPU_PRI_13_MAP field.
	INTPRI_CPU_INT_PRI_13_CPU_PRI_13_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_13_MAP field.
	INTPRI_CPU_INT_PRI_13_CPU_PRI_13_MAP_Msk = 0xf

	// CPU_INT_PRI_14: register description
	// Position of CPU_PRI_14_MAP field.
	INTPRI_CPU_INT_PRI_14_CPU_PRI_14_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_14_MAP field.
	INTPRI_CPU_INT_PRI_14_CPU_PRI_14_MAP_Msk = 0xf

	// CPU_INT_PRI_15: register description
	// Position of CPU_PRI_15_MAP field.
	INTPRI_CPU_INT_PRI_15_CPU_PRI_15_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_15_MAP field.
	INTPRI_CPU_INT_PRI_15_CPU_PRI_15_MAP_Msk = 0xf

	// CPU_INT_PRI_16: register description
	// Position of CPU_PRI_16_MAP field.
	INTPRI_CPU_INT_PRI_16_CPU_PRI_16_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_16_MAP field.
	INTPRI_CPU_INT_PRI_16_CPU_PRI_16_MAP_Msk = 0xf

	// CPU_INT_PRI_17: register description
	// Position of CPU_PRI_17_MAP field.
	INTPRI_CPU_INT_PRI_17_CPU_PRI_17_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_17_MAP field.
	INTPRI_CPU_INT_PRI_17_CPU_PRI_17_MAP_Msk = 0xf

	// CPU_INT_PRI_18: register description
	// Position of CPU_PRI_18_MAP field.
	INTPRI_CPU_INT_PRI_18_CPU_PRI_18_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_18_MAP field.
	INTPRI_CPU_INT_PRI_18_CPU_PRI_18_MAP_Msk = 0xf

	// CPU_INT_PRI_19: register description
	// Position of CPU_PRI_19_MAP field.
	INTPRI_CPU_INT_PRI_19_CPU_PRI_19_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_19_MAP field.
	INTPRI_CPU_INT_PRI_19_CPU_PRI_19_MAP_Msk = 0xf

	// CPU_INT_PRI_20: register description
	// Position of CPU_PRI_20_MAP field.
	INTPRI_CPU_INT_PRI_20_CPU_PRI_20_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_20_MAP field.
	INTPRI_CPU_INT_PRI_20_CPU_PRI_20_MAP_Msk = 0xf

	// CPU_INT_PRI_21: register description
	// Position of CPU_PRI_21_MAP field.
	INTPRI_CPU_INT_PRI_21_CPU_PRI_21_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_21_MAP field.
	INTPRI_CPU_INT_PRI_21_CPU_PRI_21_MAP_Msk = 0xf

	// CPU_INT_PRI_22: register description
	// Position of CPU_PRI_22_MAP field.
	INTPRI_CPU_INT_PRI_22_CPU_PRI_22_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_22_MAP field.
	INTPRI_CPU_INT_PRI_22_CPU_PRI_22_MAP_Msk = 0xf

	// CPU_INT_PRI_23: register description
	// Position of CPU_PRI_23_MAP field.
	INTPRI_CPU_INT_PRI_23_CPU_PRI_23_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_23_MAP field.
	INTPRI_CPU_INT_PRI_23_CPU_PRI_23_MAP_Msk = 0xf

	// CPU_INT_PRI_24: register description
	// Position of CPU_PRI_24_MAP field.
	INTPRI_CPU_INT_PRI_24_CPU_PRI_24_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_24_MAP field.
	INTPRI_CPU_INT_PRI_24_CPU_PRI_24_MAP_Msk = 0xf

	// CPU_INT_PRI_25: register description
	// Position of CPU_PRI_25_MAP field.
	INTPRI_CPU_INT_PRI_25_CPU_PRI_25_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_25_MAP field.
	INTPRI_CPU_INT_PRI_25_CPU_PRI_25_MAP_Msk = 0xf

	// CPU_INT_PRI_26: register description
	// Position of CPU_PRI_26_MAP field.
	INTPRI_CPU_INT_PRI_26_CPU_PRI_26_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_26_MAP field.
	INTPRI_CPU_INT_PRI_26_CPU_PRI_26_MAP_Msk = 0xf

	// CPU_INT_PRI_27: register description
	// Position of CPU_PRI_27_MAP field.
	INTPRI_CPU_INT_PRI_27_CPU_PRI_27_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_27_MAP field.
	INTPRI_CPU_INT_PRI_27_CPU_PRI_27_MAP_Msk = 0xf

	// CPU_INT_PRI_28: register description
	// Position of CPU_PRI_28_MAP field.
	INTPRI_CPU_INT_PRI_28_CPU_PRI_28_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_28_MAP field.
	INTPRI_CPU_INT_PRI_28_CPU_PRI_28_MAP_Msk = 0xf

	// CPU_INT_PRI_29: register description
	// Position of CPU_PRI_29_MAP field.
	INTPRI_CPU_INT_PRI_29_CPU_PRI_29_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_29_MAP field.
	INTPRI_CPU_INT_PRI_29_CPU_PRI_29_MAP_Msk = 0xf

	// CPU_INT_PRI_30: register description
	// Position of CPU_PRI_30_MAP field.
	INTPRI_CPU_INT_PRI_30_CPU_PRI_30_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_30_MAP field.
	INTPRI_CPU_INT_PRI_30_CPU_PRI_30_MAP_Msk = 0xf

	// CPU_INT_PRI_31: register description
	// Position of CPU_PRI_31_MAP field.
	INTPRI_CPU_INT_PRI_31_CPU_PRI_31_MAP_Pos = 0x0
	// Bit mask of CPU_PRI_31_MAP field.
	INTPRI_CPU_INT_PRI_31_CPU_PRI_31_MAP_Msk = 0xf

	// CPU_INT_THRESH: register description
	// Position of CPU_INT_THRESH field.
	INTPRI_CPU_INT_THRESH_CPU_INT_THRESH_Pos = 0x0
	// Bit mask of CPU_INT_THRESH field.
	INTPRI_CPU_INT_THRESH_CPU_INT_THRESH_Msk = 0xff

	// CPU_INTR_FROM_CPU_0: register description
	// Position of CPU_INTR_FROM_CPU_0 field.
	INTPRI_CPU_INTR_FROM_CPU_0_CPU_INTR_FROM_CPU_0_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_0 field.
	INTPRI_CPU_INTR_FROM_CPU_0_CPU_INTR_FROM_CPU_0_Msk = 0x1
	// Bit CPU_INTR_FROM_CPU_0.
	INTPRI_CPU_INTR_FROM_CPU_0_CPU_INTR_FROM_CPU_0 = 0x1

	// CPU_INTR_FROM_CPU_1: register description
	// Position of CPU_INTR_FROM_CPU_1 field.
	INTPRI_CPU_INTR_FROM_CPU_1_CPU_INTR_FROM_CPU_1_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_1 field.
	INTPRI_CPU_INTR_FROM_CPU_1_CPU_INTR_FROM_CPU_1_Msk = 0x1
	// Bit CPU_INTR_FROM_CPU_1.
	INTPRI_CPU_INTR_FROM_CPU_1_CPU_INTR_FROM_CPU_1 = 0x1

	// CPU_INTR_FROM_CPU_2: register description
	// Position of CPU_INTR_FROM_CPU_2 field.
	INTPRI_CPU_INTR_FROM_CPU_2_CPU_INTR_FROM_CPU_2_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_2 field.
	INTPRI_CPU_INTR_FROM_CPU_2_CPU_INTR_FROM_CPU_2_Msk = 0x1
	// Bit CPU_INTR_FROM_CPU_2.
	INTPRI_CPU_INTR_FROM_CPU_2_CPU_INTR_FROM_CPU_2 = 0x1

	// CPU_INTR_FROM_CPU_3: register description
	// Position of CPU_INTR_FROM_CPU_3 field.
	INTPRI_CPU_INTR_FROM_CPU_3_CPU_INTR_FROM_CPU_3_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_3 field.
	INTPRI_CPU_INTR_FROM_CPU_3_CPU_INTR_FROM_CPU_3_Msk = 0x1
	// Bit CPU_INTR_FROM_CPU_3.
	INTPRI_CPU_INTR_FROM_CPU_3_CPU_INTR_FROM_CPU_3 = 0x1

	// DATE: register description
	// Position of DATE field.
	INTPRI_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	INTPRI_DATE_DATE_Msk = 0xfffffff

	// CLOCK_GATE: register description
	// Position of CLK_EN field.
	INTPRI_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	INTPRI_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	INTPRI_CLOCK_GATE_CLK_EN = 0x1

	// CPU_INT_CLEAR: register description
	// Position of CPU_INT_CLEAR field.
	INTPRI_CPU_INT_CLEAR_CPU_INT_CLEAR_Pos = 0x0
	// Bit mask of CPU_INT_CLEAR field.
	INTPRI_CPU_INT_CLEAR_CPU_INT_CLEAR_Msk = 0xffffffff

	// RND_ECO: redcy eco register.
	// Position of REDCY_ENA field.
	INTPRI_RND_ECO_REDCY_ENA_Pos = 0x0
	// Bit mask of REDCY_ENA field.
	INTPRI_RND_ECO_REDCY_ENA_Msk = 0x1
	// Bit REDCY_ENA.
	INTPRI_RND_ECO_REDCY_ENA = 0x1
	// Position of REDCY_RESULT field.
	INTPRI_RND_ECO_REDCY_RESULT_Pos = 0x1
	// Bit mask of REDCY_RESULT field.
	INTPRI_RND_ECO_REDCY_RESULT_Msk = 0x2
	// Bit REDCY_RESULT.
	INTPRI_RND_ECO_REDCY_RESULT = 0x2

	// RND_ECO_LOW: redcy eco low register.
	// Position of REDCY_LOW field.
	INTPRI_RND_ECO_LOW_REDCY_LOW_Pos = 0x0
	// Bit mask of REDCY_LOW field.
	INTPRI_RND_ECO_LOW_REDCY_LOW_Msk = 0xffffffff

	// RND_ECO_HIGH: redcy eco high register.
	// Position of REDCY_HIGH field.
	INTPRI_RND_ECO_HIGH_REDCY_HIGH_Pos = 0x0
	// Bit mask of REDCY_HIGH field.
	INTPRI_RND_ECO_HIGH_REDCY_HIGH_Msk = 0xffffffff
)

// Constants for IO_MUX: Input/Output Multiplexer
const (
	// PIN_CTRL: Clock Output Configuration Register
	// Position of CLK_OUT1 field.
	IO_MUX_PIN_CTRL_CLK_OUT1_Pos = 0x0
	// Bit mask of CLK_OUT1 field.
	IO_MUX_PIN_CTRL_CLK_OUT1_Msk = 0x1f
	// Position of CLK_OUT2 field.
	IO_MUX_PIN_CTRL_CLK_OUT2_Pos = 0x5
	// Bit mask of CLK_OUT2 field.
	IO_MUX_PIN_CTRL_CLK_OUT2_Msk = 0x3e0
	// Position of CLK_OUT3 field.
	IO_MUX_PIN_CTRL_CLK_OUT3_Pos = 0xa
	// Bit mask of CLK_OUT3 field.
	IO_MUX_PIN_CTRL_CLK_OUT3_Msk = 0x7c00

	// GPIO0: IO MUX Configure Register for pad GPIO0
	// Position of MCU_OE field.
	IO_MUX_GPIO_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO_MCU_IE = 0x10
	// Position of MCU_DRV field.
	IO_MUX_GPIO_MCU_DRV_Pos = 0x5
	// Bit mask of MCU_DRV field.
	IO_MUX_GPIO_MCU_DRV_Msk = 0x60
	// Position of FUN_WPD field.
	IO_MUX_GPIO_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO_FILTER_EN = 0x8000
	// Position of HYS_EN field.
	IO_MUX_GPIO_HYS_EN_Pos = 0x10
	// Bit mask of HYS_EN field.
	IO_MUX_GPIO_HYS_EN_Msk = 0x10000
	// Bit HYS_EN.
	IO_MUX_GPIO_HYS_EN = 0x10000
	// Position of HYS_SEL field.
	IO_MUX_GPIO_HYS_SEL_Pos = 0x11
	// Bit mask of HYS_SEL field.
	IO_MUX_GPIO_HYS_SEL_Msk = 0x20000
	// Bit HYS_SEL.
	IO_MUX_GPIO_HYS_SEL = 0x20000

	// MODEM_DIAG_EN: GPIO MATRIX Configure Register for modem diag
	// Position of MODEM_DIAG_EN field.
	IO_MUX_MODEM_DIAG_EN_MODEM_DIAG_EN_Pos = 0x0
	// Bit mask of MODEM_DIAG_EN field.
	IO_MUX_MODEM_DIAG_EN_MODEM_DIAG_EN_Msk = 0xffffffff

	// DATE: IO MUX Version Control Register
	// Position of REG_DATE field.
	IO_MUX_DATE_REG_DATE_Pos = 0x0
	// Bit mask of REG_DATE field.
	IO_MUX_DATE_REG_DATE_Msk = 0xfffffff
)

// Constants for LEDC: LED Control PWM (Pulse Width Modulation)
const (
	// CH0_CONF0: Configuration register 0 for channel %s
	// Position of TIMER_SEL field.
	LEDC_CH_CONF0_TIMER_SEL_Pos = 0x0
	// Bit mask of TIMER_SEL field.
	LEDC_CH_CONF0_TIMER_SEL_Msk = 0x3
	// Position of SIG_OUT_EN field.
	LEDC_CH_CONF0_SIG_OUT_EN_Pos = 0x2
	// Bit mask of SIG_OUT_EN field.
	LEDC_CH_CONF0_SIG_OUT_EN_Msk = 0x4
	// Bit SIG_OUT_EN.
	LEDC_CH_CONF0_SIG_OUT_EN = 0x4
	// Position of IDLE_LV field.
	LEDC_CH_CONF0_IDLE_LV_Pos = 0x3
	// Bit mask of IDLE_LV field.
	LEDC_CH_CONF0_IDLE_LV_Msk = 0x8
	// Bit IDLE_LV.
	LEDC_CH_CONF0_IDLE_LV = 0x8
	// Position of PARA_UP field.
	LEDC_CH_CONF0_PARA_UP_Pos = 0x4
	// Bit mask of PARA_UP field.
	LEDC_CH_CONF0_PARA_UP_Msk = 0x10
	// Bit PARA_UP.
	LEDC_CH_CONF0_PARA_UP = 0x10
	// Position of OVF_NUM field.
	LEDC_CH_CONF0_OVF_NUM_Pos = 0x5
	// Bit mask of OVF_NUM field.
	LEDC_CH_CONF0_OVF_NUM_Msk = 0x7fe0
	// Position of OVF_CNT_EN field.
	LEDC_CH_CONF0_OVF_CNT_EN_Pos = 0xf
	// Bit mask of OVF_CNT_EN field.
	LEDC_CH_CONF0_OVF_CNT_EN_Msk = 0x8000
	// Bit OVF_CNT_EN.
	LEDC_CH_CONF0_OVF_CNT_EN = 0x8000
	// Position of OVF_CNT_RESET field.
	LEDC_CH_CONF0_OVF_CNT_RESET_Pos = 0x10
	// Bit mask of OVF_CNT_RESET field.
	LEDC_CH_CONF0_OVF_CNT_RESET_Msk = 0x10000
	// Bit OVF_CNT_RESET.
	LEDC_CH_CONF0_OVF_CNT_RESET = 0x10000

	// CH0_HPOINT: High point register for channel %s
	// Position of HPOINT field.
	LEDC_CH_HPOINT_HPOINT_Pos = 0x0
	// Bit mask of HPOINT field.
	LEDC_CH_HPOINT_HPOINT_Msk = 0xfffff

	// CH0_DUTY: Initial duty cycle for channel %s
	// Position of DUTY field.
	LEDC_CH_DUTY_DUTY_Pos = 0x0
	// Bit mask of DUTY field.
	LEDC_CH_DUTY_DUTY_Msk = 0x1ffffff

	// CH0_CONF1: Configuration register 1 for channel %s
	// Position of DUTY_START field.
	LEDC_CH_CONF1_DUTY_START_Pos = 0x1f
	// Bit mask of DUTY_START field.
	LEDC_CH_CONF1_DUTY_START_Msk = 0x80000000
	// Bit DUTY_START.
	LEDC_CH_CONF1_DUTY_START = 0x80000000

	// CH0_DUTY_R: Current duty cycle for channel %s
	// Position of DUTY_CH_R field.
	LEDC_CH_DUTY_R_DUTY_CH_R_Pos = 0x0
	// Bit mask of DUTY_CH_R field.
	LEDC_CH_DUTY_R_DUTY_CH_R_Msk = 0x1ffffff

	// TIMER0_CONF: Timer %s configuration
	// Position of DUTY_RES field.
	LEDC_TIMER_CONF_DUTY_RES_Pos = 0x0
	// Bit mask of DUTY_RES field.
	LEDC_TIMER_CONF_DUTY_RES_Msk = 0x1f
	// Position of CLK_DIV field.
	LEDC_TIMER_CONF_CLK_DIV_Pos = 0x5
	// Bit mask of CLK_DIV field.
	LEDC_TIMER_CONF_CLK_DIV_Msk = 0x7fffe0
	// Position of PAUSE field.
	LEDC_TIMER_CONF_PAUSE_Pos = 0x17
	// Bit mask of PAUSE field.
	LEDC_TIMER_CONF_PAUSE_Msk = 0x800000
	// Bit PAUSE.
	LEDC_TIMER_CONF_PAUSE = 0x800000
	// Position of RST field.
	LEDC_TIMER_CONF_RST_Pos = 0x18
	// Bit mask of RST field.
	LEDC_TIMER_CONF_RST_Msk = 0x1000000
	// Bit RST.
	LEDC_TIMER_CONF_RST = 0x1000000
	// Position of TICK_SEL field.
	LEDC_TIMER_CONF_TICK_SEL_Pos = 0x19
	// Bit mask of TICK_SEL field.
	LEDC_TIMER_CONF_TICK_SEL_Msk = 0x2000000
	// Bit TICK_SEL.
	LEDC_TIMER_CONF_TICK_SEL = 0x2000000
	// Position of PARA_UP field.
	LEDC_TIMER_CONF_PARA_UP_Pos = 0x1a
	// Bit mask of PARA_UP field.
	LEDC_TIMER_CONF_PARA_UP_Msk = 0x4000000
	// Bit PARA_UP.
	LEDC_TIMER_CONF_PARA_UP = 0x4000000

	// TIMER0_VALUE: Timer %s current counter value
	// Position of TIMER_CNT field.
	LEDC_TIMER_VALUE_TIMER_CNT_Pos = 0x0
	// Bit mask of TIMER_CNT field.
	LEDC_TIMER_VALUE_TIMER_CNT_Msk = 0xfffff

	// INT_RAW: Raw interrupt status
	// Position of TIMER0_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER0_OVF_INT_RAW_Pos = 0x0
	// Bit mask of TIMER0_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER0_OVF_INT_RAW_Msk = 0x1
	// Bit TIMER0_OVF_INT_RAW.
	LEDC_INT_RAW_TIMER0_OVF_INT_RAW = 0x1
	// Position of TIMER1_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER1_OVF_INT_RAW_Pos = 0x1
	// Bit mask of TIMER1_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER1_OVF_INT_RAW_Msk = 0x2
	// Bit TIMER1_OVF_INT_RAW.
	LEDC_INT_RAW_TIMER1_OVF_INT_RAW = 0x2
	// Position of TIMER2_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER2_OVF_INT_RAW_Pos = 0x2
	// Bit mask of TIMER2_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER2_OVF_INT_RAW_Msk = 0x4
	// Bit TIMER2_OVF_INT_RAW.
	LEDC_INT_RAW_TIMER2_OVF_INT_RAW = 0x4
	// Position of TIMER3_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER3_OVF_INT_RAW_Pos = 0x3
	// Bit mask of TIMER3_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER3_OVF_INT_RAW_Msk = 0x8
	// Bit TIMER3_OVF_INT_RAW.
	LEDC_INT_RAW_TIMER3_OVF_INT_RAW = 0x8
	// Position of DUTY_CHNG_END_CH0_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH0_INT_RAW_Pos = 0x4
	// Bit mask of DUTY_CHNG_END_CH0_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH0_INT_RAW_Msk = 0x10
	// Bit DUTY_CHNG_END_CH0_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH0_INT_RAW = 0x10
	// Position of DUTY_CHNG_END_CH1_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH1_INT_RAW_Pos = 0x5
	// Bit mask of DUTY_CHNG_END_CH1_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH1_INT_RAW_Msk = 0x20
	// Bit DUTY_CHNG_END_CH1_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH1_INT_RAW = 0x20
	// Position of DUTY_CHNG_END_CH2_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH2_INT_RAW_Pos = 0x6
	// Bit mask of DUTY_CHNG_END_CH2_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH2_INT_RAW_Msk = 0x40
	// Bit DUTY_CHNG_END_CH2_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH2_INT_RAW = 0x40
	// Position of DUTY_CHNG_END_CH3_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH3_INT_RAW_Pos = 0x7
	// Bit mask of DUTY_CHNG_END_CH3_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH3_INT_RAW_Msk = 0x80
	// Bit DUTY_CHNG_END_CH3_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH3_INT_RAW = 0x80
	// Position of DUTY_CHNG_END_CH4_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH4_INT_RAW_Pos = 0x8
	// Bit mask of DUTY_CHNG_END_CH4_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH4_INT_RAW_Msk = 0x100
	// Bit DUTY_CHNG_END_CH4_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH4_INT_RAW = 0x100
	// Position of DUTY_CHNG_END_CH5_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH5_INT_RAW_Pos = 0x9
	// Bit mask of DUTY_CHNG_END_CH5_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH5_INT_RAW_Msk = 0x200
	// Bit DUTY_CHNG_END_CH5_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH5_INT_RAW = 0x200
	// Position of OVF_CNT_CH0_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH0_INT_RAW_Pos = 0xc
	// Bit mask of OVF_CNT_CH0_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH0_INT_RAW_Msk = 0x1000
	// Bit OVF_CNT_CH0_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH0_INT_RAW = 0x1000
	// Position of OVF_CNT_CH1_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH1_INT_RAW_Pos = 0xd
	// Bit mask of OVF_CNT_CH1_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH1_INT_RAW_Msk = 0x2000
	// Bit OVF_CNT_CH1_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH1_INT_RAW = 0x2000
	// Position of OVF_CNT_CH2_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH2_INT_RAW_Pos = 0xe
	// Bit mask of OVF_CNT_CH2_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH2_INT_RAW_Msk = 0x4000
	// Bit OVF_CNT_CH2_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH2_INT_RAW = 0x4000
	// Position of OVF_CNT_CH3_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH3_INT_RAW_Pos = 0xf
	// Bit mask of OVF_CNT_CH3_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH3_INT_RAW_Msk = 0x8000
	// Bit OVF_CNT_CH3_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH3_INT_RAW = 0x8000
	// Position of OVF_CNT_CH4_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH4_INT_RAW_Pos = 0x10
	// Bit mask of OVF_CNT_CH4_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH4_INT_RAW_Msk = 0x10000
	// Bit OVF_CNT_CH4_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH4_INT_RAW = 0x10000
	// Position of OVF_CNT_CH5_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH5_INT_RAW_Pos = 0x11
	// Bit mask of OVF_CNT_CH5_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH5_INT_RAW_Msk = 0x20000
	// Bit OVF_CNT_CH5_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH5_INT_RAW = 0x20000

	// INT_ST: Masked interrupt status
	// Position of TIMER0_OVF_INT_ST field.
	LEDC_INT_ST_TIMER0_OVF_INT_ST_Pos = 0x0
	// Bit mask of TIMER0_OVF_INT_ST field.
	LEDC_INT_ST_TIMER0_OVF_INT_ST_Msk = 0x1
	// Bit TIMER0_OVF_INT_ST.
	LEDC_INT_ST_TIMER0_OVF_INT_ST = 0x1
	// Position of TIMER1_OVF_INT_ST field.
	LEDC_INT_ST_TIMER1_OVF_INT_ST_Pos = 0x1
	// Bit mask of TIMER1_OVF_INT_ST field.
	LEDC_INT_ST_TIMER1_OVF_INT_ST_Msk = 0x2
	// Bit TIMER1_OVF_INT_ST.
	LEDC_INT_ST_TIMER1_OVF_INT_ST = 0x2
	// Position of TIMER2_OVF_INT_ST field.
	LEDC_INT_ST_TIMER2_OVF_INT_ST_Pos = 0x2
	// Bit mask of TIMER2_OVF_INT_ST field.
	LEDC_INT_ST_TIMER2_OVF_INT_ST_Msk = 0x4
	// Bit TIMER2_OVF_INT_ST.
	LEDC_INT_ST_TIMER2_OVF_INT_ST = 0x4
	// Position of TIMER3_OVF_INT_ST field.
	LEDC_INT_ST_TIMER3_OVF_INT_ST_Pos = 0x3
	// Bit mask of TIMER3_OVF_INT_ST field.
	LEDC_INT_ST_TIMER3_OVF_INT_ST_Msk = 0x8
	// Bit TIMER3_OVF_INT_ST.
	LEDC_INT_ST_TIMER3_OVF_INT_ST = 0x8
	// Position of DUTY_CHNG_END_CH0_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH0_INT_ST_Pos = 0x4
	// Bit mask of DUTY_CHNG_END_CH0_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH0_INT_ST_Msk = 0x10
	// Bit DUTY_CHNG_END_CH0_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH0_INT_ST = 0x10
	// Position of DUTY_CHNG_END_CH1_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH1_INT_ST_Pos = 0x5
	// Bit mask of DUTY_CHNG_END_CH1_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH1_INT_ST_Msk = 0x20
	// Bit DUTY_CHNG_END_CH1_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH1_INT_ST = 0x20
	// Position of DUTY_CHNG_END_CH2_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH2_INT_ST_Pos = 0x6
	// Bit mask of DUTY_CHNG_END_CH2_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH2_INT_ST_Msk = 0x40
	// Bit DUTY_CHNG_END_CH2_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH2_INT_ST = 0x40
	// Position of DUTY_CHNG_END_CH3_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH3_INT_ST_Pos = 0x7
	// Bit mask of DUTY_CHNG_END_CH3_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH3_INT_ST_Msk = 0x80
	// Bit DUTY_CHNG_END_CH3_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH3_INT_ST = 0x80
	// Position of DUTY_CHNG_END_CH4_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH4_INT_ST_Pos = 0x8
	// Bit mask of DUTY_CHNG_END_CH4_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH4_INT_ST_Msk = 0x100
	// Bit DUTY_CHNG_END_CH4_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH4_INT_ST = 0x100
	// Position of DUTY_CHNG_END_CH5_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH5_INT_ST_Pos = 0x9
	// Bit mask of DUTY_CHNG_END_CH5_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH5_INT_ST_Msk = 0x200
	// Bit DUTY_CHNG_END_CH5_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH5_INT_ST = 0x200
	// Position of OVF_CNT_CH0_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH0_INT_ST_Pos = 0xc
	// Bit mask of OVF_CNT_CH0_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH0_INT_ST_Msk = 0x1000
	// Bit OVF_CNT_CH0_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH0_INT_ST = 0x1000
	// Position of OVF_CNT_CH1_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH1_INT_ST_Pos = 0xd
	// Bit mask of OVF_CNT_CH1_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH1_INT_ST_Msk = 0x2000
	// Bit OVF_CNT_CH1_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH1_INT_ST = 0x2000
	// Position of OVF_CNT_CH2_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH2_INT_ST_Pos = 0xe
	// Bit mask of OVF_CNT_CH2_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH2_INT_ST_Msk = 0x4000
	// Bit OVF_CNT_CH2_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH2_INT_ST = 0x4000
	// Position of OVF_CNT_CH3_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH3_INT_ST_Pos = 0xf
	// Bit mask of OVF_CNT_CH3_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH3_INT_ST_Msk = 0x8000
	// Bit OVF_CNT_CH3_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH3_INT_ST = 0x8000
	// Position of OVF_CNT_CH4_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH4_INT_ST_Pos = 0x10
	// Bit mask of OVF_CNT_CH4_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH4_INT_ST_Msk = 0x10000
	// Bit OVF_CNT_CH4_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH4_INT_ST = 0x10000
	// Position of OVF_CNT_CH5_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH5_INT_ST_Pos = 0x11
	// Bit mask of OVF_CNT_CH5_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH5_INT_ST_Msk = 0x20000
	// Bit OVF_CNT_CH5_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH5_INT_ST = 0x20000

	// INT_ENA: Interrupt enable bits
	// Position of TIMER0_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER0_OVF_INT_ENA_Pos = 0x0
	// Bit mask of TIMER0_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER0_OVF_INT_ENA_Msk = 0x1
	// Bit TIMER0_OVF_INT_ENA.
	LEDC_INT_ENA_TIMER0_OVF_INT_ENA = 0x1
	// Position of TIMER1_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER1_OVF_INT_ENA_Pos = 0x1
	// Bit mask of TIMER1_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER1_OVF_INT_ENA_Msk = 0x2
	// Bit TIMER1_OVF_INT_ENA.
	LEDC_INT_ENA_TIMER1_OVF_INT_ENA = 0x2
	// Position of TIMER2_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER2_OVF_INT_ENA_Pos = 0x2
	// Bit mask of TIMER2_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER2_OVF_INT_ENA_Msk = 0x4
	// Bit TIMER2_OVF_INT_ENA.
	LEDC_INT_ENA_TIMER2_OVF_INT_ENA = 0x4
	// Position of TIMER3_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER3_OVF_INT_ENA_Pos = 0x3
	// Bit mask of TIMER3_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER3_OVF_INT_ENA_Msk = 0x8
	// Bit TIMER3_OVF_INT_ENA.
	LEDC_INT_ENA_TIMER3_OVF_INT_ENA = 0x8
	// Position of DUTY_CHNG_END_CH0_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH0_INT_ENA_Pos = 0x4
	// Bit mask of DUTY_CHNG_END_CH0_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH0_INT_ENA_Msk = 0x10
	// Bit DUTY_CHNG_END_CH0_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH0_INT_ENA = 0x10
	// Position of DUTY_CHNG_END_CH1_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH1_INT_ENA_Pos = 0x5
	// Bit mask of DUTY_CHNG_END_CH1_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH1_INT_ENA_Msk = 0x20
	// Bit DUTY_CHNG_END_CH1_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH1_INT_ENA = 0x20
	// Position of DUTY_CHNG_END_CH2_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH2_INT_ENA_Pos = 0x6
	// Bit mask of DUTY_CHNG_END_CH2_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH2_INT_ENA_Msk = 0x40
	// Bit DUTY_CHNG_END_CH2_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH2_INT_ENA = 0x40
	// Position of DUTY_CHNG_END_CH3_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH3_INT_ENA_Pos = 0x7
	// Bit mask of DUTY_CHNG_END_CH3_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH3_INT_ENA_Msk = 0x80
	// Bit DUTY_CHNG_END_CH3_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH3_INT_ENA = 0x80
	// Position of DUTY_CHNG_END_CH4_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH4_INT_ENA_Pos = 0x8
	// Bit mask of DUTY_CHNG_END_CH4_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH4_INT_ENA_Msk = 0x100
	// Bit DUTY_CHNG_END_CH4_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH4_INT_ENA = 0x100
	// Position of DUTY_CHNG_END_CH5_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH5_INT_ENA_Pos = 0x9
	// Bit mask of DUTY_CHNG_END_CH5_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH5_INT_ENA_Msk = 0x200
	// Bit DUTY_CHNG_END_CH5_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH5_INT_ENA = 0x200
	// Position of OVF_CNT_CH0_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH0_INT_ENA_Pos = 0xc
	// Bit mask of OVF_CNT_CH0_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH0_INT_ENA_Msk = 0x1000
	// Bit OVF_CNT_CH0_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH0_INT_ENA = 0x1000
	// Position of OVF_CNT_CH1_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH1_INT_ENA_Pos = 0xd
	// Bit mask of OVF_CNT_CH1_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH1_INT_ENA_Msk = 0x2000
	// Bit OVF_CNT_CH1_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH1_INT_ENA = 0x2000
	// Position of OVF_CNT_CH2_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH2_INT_ENA_Pos = 0xe
	// Bit mask of OVF_CNT_CH2_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH2_INT_ENA_Msk = 0x4000
	// Bit OVF_CNT_CH2_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH2_INT_ENA = 0x4000
	// Position of OVF_CNT_CH3_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH3_INT_ENA_Pos = 0xf
	// Bit mask of OVF_CNT_CH3_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH3_INT_ENA_Msk = 0x8000
	// Bit OVF_CNT_CH3_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH3_INT_ENA = 0x8000
	// Position of OVF_CNT_CH4_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH4_INT_ENA_Pos = 0x10
	// Bit mask of OVF_CNT_CH4_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH4_INT_ENA_Msk = 0x10000
	// Bit OVF_CNT_CH4_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH4_INT_ENA = 0x10000
	// Position of OVF_CNT_CH5_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH5_INT_ENA_Pos = 0x11
	// Bit mask of OVF_CNT_CH5_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH5_INT_ENA_Msk = 0x20000
	// Bit OVF_CNT_CH5_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH5_INT_ENA = 0x20000

	// INT_CLR: Interrupt clear bits
	// Position of TIMER0_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER0_OVF_INT_CLR_Pos = 0x0
	// Bit mask of TIMER0_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER0_OVF_INT_CLR_Msk = 0x1
	// Bit TIMER0_OVF_INT_CLR.
	LEDC_INT_CLR_TIMER0_OVF_INT_CLR = 0x1
	// Position of TIMER1_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER1_OVF_INT_CLR_Pos = 0x1
	// Bit mask of TIMER1_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER1_OVF_INT_CLR_Msk = 0x2
	// Bit TIMER1_OVF_INT_CLR.
	LEDC_INT_CLR_TIMER1_OVF_INT_CLR = 0x2
	// Position of TIMER2_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER2_OVF_INT_CLR_Pos = 0x2
	// Bit mask of TIMER2_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER2_OVF_INT_CLR_Msk = 0x4
	// Bit TIMER2_OVF_INT_CLR.
	LEDC_INT_CLR_TIMER2_OVF_INT_CLR = 0x4
	// Position of TIMER3_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER3_OVF_INT_CLR_Pos = 0x3
	// Bit mask of TIMER3_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER3_OVF_INT_CLR_Msk = 0x8
	// Bit TIMER3_OVF_INT_CLR.
	LEDC_INT_CLR_TIMER3_OVF_INT_CLR = 0x8
	// Position of DUTY_CHNG_END_CH0_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH0_INT_CLR_Pos = 0x4
	// Bit mask of DUTY_CHNG_END_CH0_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH0_INT_CLR_Msk = 0x10
	// Bit DUTY_CHNG_END_CH0_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH0_INT_CLR = 0x10
	// Position of DUTY_CHNG_END_CH1_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH1_INT_CLR_Pos = 0x5
	// Bit mask of DUTY_CHNG_END_CH1_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH1_INT_CLR_Msk = 0x20
	// Bit DUTY_CHNG_END_CH1_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH1_INT_CLR = 0x20
	// Position of DUTY_CHNG_END_CH2_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH2_INT_CLR_Pos = 0x6
	// Bit mask of DUTY_CHNG_END_CH2_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH2_INT_CLR_Msk = 0x40
	// Bit DUTY_CHNG_END_CH2_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH2_INT_CLR = 0x40
	// Position of DUTY_CHNG_END_CH3_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH3_INT_CLR_Pos = 0x7
	// Bit mask of DUTY_CHNG_END_CH3_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH3_INT_CLR_Msk = 0x80
	// Bit DUTY_CHNG_END_CH3_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH3_INT_CLR = 0x80
	// Position of DUTY_CHNG_END_CH4_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH4_INT_CLR_Pos = 0x8
	// Bit mask of DUTY_CHNG_END_CH4_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH4_INT_CLR_Msk = 0x100
	// Bit DUTY_CHNG_END_CH4_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH4_INT_CLR = 0x100
	// Position of DUTY_CHNG_END_CH5_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH5_INT_CLR_Pos = 0x9
	// Bit mask of DUTY_CHNG_END_CH5_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH5_INT_CLR_Msk = 0x200
	// Bit DUTY_CHNG_END_CH5_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH5_INT_CLR = 0x200
	// Position of OVF_CNT_CH0_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH0_INT_CLR_Pos = 0xc
	// Bit mask of OVF_CNT_CH0_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH0_INT_CLR_Msk = 0x1000
	// Bit OVF_CNT_CH0_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH0_INT_CLR = 0x1000
	// Position of OVF_CNT_CH1_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH1_INT_CLR_Pos = 0xd
	// Bit mask of OVF_CNT_CH1_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH1_INT_CLR_Msk = 0x2000
	// Bit OVF_CNT_CH1_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH1_INT_CLR = 0x2000
	// Position of OVF_CNT_CH2_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH2_INT_CLR_Pos = 0xe
	// Bit mask of OVF_CNT_CH2_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH2_INT_CLR_Msk = 0x4000
	// Bit OVF_CNT_CH2_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH2_INT_CLR = 0x4000
	// Position of OVF_CNT_CH3_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH3_INT_CLR_Pos = 0xf
	// Bit mask of OVF_CNT_CH3_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH3_INT_CLR_Msk = 0x8000
	// Bit OVF_CNT_CH3_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH3_INT_CLR = 0x8000
	// Position of OVF_CNT_CH4_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH4_INT_CLR_Pos = 0x10
	// Bit mask of OVF_CNT_CH4_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH4_INT_CLR_Msk = 0x10000
	// Bit OVF_CNT_CH4_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH4_INT_CLR = 0x10000
	// Position of OVF_CNT_CH5_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH5_INT_CLR_Pos = 0x11
	// Bit mask of OVF_CNT_CH5_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH5_INT_CLR_Msk = 0x20000
	// Bit OVF_CNT_CH5_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH5_INT_CLR = 0x20000

	// CH0_GAMMA_WR: Ledc ch%s gamma ram write register.
	// Position of CH_GAMMA_DUTY_INC field.
	LEDC_CH_GAMMA_WR_CH_GAMMA_DUTY_INC_Pos = 0x0
	// Bit mask of CH_GAMMA_DUTY_INC field.
	LEDC_CH_GAMMA_WR_CH_GAMMA_DUTY_INC_Msk = 0x1
	// Bit CH_GAMMA_DUTY_INC.
	LEDC_CH_GAMMA_WR_CH_GAMMA_DUTY_INC = 0x1
	// Position of CH_GAMMA_DUTY_CYCLE field.
	LEDC_CH_GAMMA_WR_CH_GAMMA_DUTY_CYCLE_Pos = 0x1
	// Bit mask of CH_GAMMA_DUTY_CYCLE field.
	LEDC_CH_GAMMA_WR_CH_GAMMA_DUTY_CYCLE_Msk = 0x7fe
	// Position of CH_GAMMA_SCALE field.
	LEDC_CH_GAMMA_WR_CH_GAMMA_SCALE_Pos = 0xb
	// Bit mask of CH_GAMMA_SCALE field.
	LEDC_CH_GAMMA_WR_CH_GAMMA_SCALE_Msk = 0x1ff800
	// Position of CH_GAMMA_DUTY_NUM field.
	LEDC_CH_GAMMA_WR_CH_GAMMA_DUTY_NUM_Pos = 0x15
	// Bit mask of CH_GAMMA_DUTY_NUM field.
	LEDC_CH_GAMMA_WR_CH_GAMMA_DUTY_NUM_Msk = 0x7fe00000

	// CH0_GAMMA_WR_ADDR: Ledc ch%s gamma ram write address register.
	// Position of CH_GAMMA_WR_ADDR field.
	LEDC_CH_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR_Pos = 0x0
	// Bit mask of CH_GAMMA_WR_ADDR field.
	LEDC_CH_GAMMA_WR_ADDR_CH_GAMMA_WR_ADDR_Msk = 0xf

	// CH0_GAMMA_RD_ADDR: Ledc ch%s gamma ram read address register.
	// Position of CH_GAMMA_RD_ADDR field.
	LEDC_CH_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR_Pos = 0x0
	// Bit mask of CH_GAMMA_RD_ADDR field.
	LEDC_CH_GAMMA_RD_ADDR_CH_GAMMA_RD_ADDR_Msk = 0xf

	// CH0_GAMMA_RD_DATA: Ledc ch%s gamma ram read data register.
	// Position of CH_GAMMA_RD_DATA field.
	LEDC_CH_GAMMA_RD_DATA_CH_GAMMA_RD_DATA_Pos = 0x0
	// Bit mask of CH_GAMMA_RD_DATA field.
	LEDC_CH_GAMMA_RD_DATA_CH_GAMMA_RD_DATA_Msk = 0x7fffffff

	// CH0_GAMMA_CONF: Ledc ch%s gamma config register.
	// Position of CH_GAMMA_ENTRY_NUM field.
	LEDC_CH_GAMMA_CONF_CH_GAMMA_ENTRY_NUM_Pos = 0x0
	// Bit mask of CH_GAMMA_ENTRY_NUM field.
	LEDC_CH_GAMMA_CONF_CH_GAMMA_ENTRY_NUM_Msk = 0x1f
	// Position of CH_GAMMA_PAUSE field.
	LEDC_CH_GAMMA_CONF_CH_GAMMA_PAUSE_Pos = 0x5
	// Bit mask of CH_GAMMA_PAUSE field.
	LEDC_CH_GAMMA_CONF_CH_GAMMA_PAUSE_Msk = 0x20
	// Bit CH_GAMMA_PAUSE.
	LEDC_CH_GAMMA_CONF_CH_GAMMA_PAUSE = 0x20
	// Position of CH_GAMMA_RESUME field.
	LEDC_CH_GAMMA_CONF_CH_GAMMA_RESUME_Pos = 0x6
	// Bit mask of CH_GAMMA_RESUME field.
	LEDC_CH_GAMMA_CONF_CH_GAMMA_RESUME_Msk = 0x40
	// Bit CH_GAMMA_RESUME.
	LEDC_CH_GAMMA_CONF_CH_GAMMA_RESUME = 0x40

	// EVT_TASK_EN0: Ledc event task enable bit register0.
	// Position of EVT_DUTY_CHNG_END_CH0_EN field.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH0_EN_Pos = 0x0
	// Bit mask of EVT_DUTY_CHNG_END_CH0_EN field.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH0_EN_Msk = 0x1
	// Bit EVT_DUTY_CHNG_END_CH0_EN.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH0_EN = 0x1
	// Position of EVT_DUTY_CHNG_END_CH1_EN field.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH1_EN_Pos = 0x1
	// Bit mask of EVT_DUTY_CHNG_END_CH1_EN field.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH1_EN_Msk = 0x2
	// Bit EVT_DUTY_CHNG_END_CH1_EN.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH1_EN = 0x2
	// Position of EVT_DUTY_CHNG_END_CH2_EN field.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH2_EN_Pos = 0x2
	// Bit mask of EVT_DUTY_CHNG_END_CH2_EN field.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH2_EN_Msk = 0x4
	// Bit EVT_DUTY_CHNG_END_CH2_EN.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH2_EN = 0x4
	// Position of EVT_DUTY_CHNG_END_CH3_EN field.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH3_EN_Pos = 0x3
	// Bit mask of EVT_DUTY_CHNG_END_CH3_EN field.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH3_EN_Msk = 0x8
	// Bit EVT_DUTY_CHNG_END_CH3_EN.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH3_EN = 0x8
	// Position of EVT_DUTY_CHNG_END_CH4_EN field.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH4_EN_Pos = 0x4
	// Bit mask of EVT_DUTY_CHNG_END_CH4_EN field.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH4_EN_Msk = 0x10
	// Bit EVT_DUTY_CHNG_END_CH4_EN.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH4_EN = 0x10
	// Position of EVT_DUTY_CHNG_END_CH5_EN field.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH5_EN_Pos = 0x5
	// Bit mask of EVT_DUTY_CHNG_END_CH5_EN field.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH5_EN_Msk = 0x20
	// Bit EVT_DUTY_CHNG_END_CH5_EN.
	LEDC_EVT_TASK_EN0_EVT_DUTY_CHNG_END_CH5_EN = 0x20
	// Position of EVT_OVF_CNT_PLS_CH0_EN field.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH0_EN_Pos = 0x8
	// Bit mask of EVT_OVF_CNT_PLS_CH0_EN field.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH0_EN_Msk = 0x100
	// Bit EVT_OVF_CNT_PLS_CH0_EN.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH0_EN = 0x100
	// Position of EVT_OVF_CNT_PLS_CH1_EN field.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH1_EN_Pos = 0x9
	// Bit mask of EVT_OVF_CNT_PLS_CH1_EN field.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH1_EN_Msk = 0x200
	// Bit EVT_OVF_CNT_PLS_CH1_EN.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH1_EN = 0x200
	// Position of EVT_OVF_CNT_PLS_CH2_EN field.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH2_EN_Pos = 0xa
	// Bit mask of EVT_OVF_CNT_PLS_CH2_EN field.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH2_EN_Msk = 0x400
	// Bit EVT_OVF_CNT_PLS_CH2_EN.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH2_EN = 0x400
	// Position of EVT_OVF_CNT_PLS_CH3_EN field.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH3_EN_Pos = 0xb
	// Bit mask of EVT_OVF_CNT_PLS_CH3_EN field.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH3_EN_Msk = 0x800
	// Bit EVT_OVF_CNT_PLS_CH3_EN.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH3_EN = 0x800
	// Position of EVT_OVF_CNT_PLS_CH4_EN field.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH4_EN_Pos = 0xc
	// Bit mask of EVT_OVF_CNT_PLS_CH4_EN field.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH4_EN_Msk = 0x1000
	// Bit EVT_OVF_CNT_PLS_CH4_EN.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH4_EN = 0x1000
	// Position of EVT_OVF_CNT_PLS_CH5_EN field.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH5_EN_Pos = 0xd
	// Bit mask of EVT_OVF_CNT_PLS_CH5_EN field.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH5_EN_Msk = 0x2000
	// Bit EVT_OVF_CNT_PLS_CH5_EN.
	LEDC_EVT_TASK_EN0_EVT_OVF_CNT_PLS_CH5_EN = 0x2000
	// Position of EVT_TIME_OVF_TIMER0_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME_OVF_TIMER0_EN_Pos = 0x10
	// Bit mask of EVT_TIME_OVF_TIMER0_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME_OVF_TIMER0_EN_Msk = 0x10000
	// Bit EVT_TIME_OVF_TIMER0_EN.
	LEDC_EVT_TASK_EN0_EVT_TIME_OVF_TIMER0_EN = 0x10000
	// Position of EVT_TIME_OVF_TIMER1_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME_OVF_TIMER1_EN_Pos = 0x11
	// Bit mask of EVT_TIME_OVF_TIMER1_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME_OVF_TIMER1_EN_Msk = 0x20000
	// Bit EVT_TIME_OVF_TIMER1_EN.
	LEDC_EVT_TASK_EN0_EVT_TIME_OVF_TIMER1_EN = 0x20000
	// Position of EVT_TIME_OVF_TIMER2_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME_OVF_TIMER2_EN_Pos = 0x12
	// Bit mask of EVT_TIME_OVF_TIMER2_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME_OVF_TIMER2_EN_Msk = 0x40000
	// Bit EVT_TIME_OVF_TIMER2_EN.
	LEDC_EVT_TASK_EN0_EVT_TIME_OVF_TIMER2_EN = 0x40000
	// Position of EVT_TIME_OVF_TIMER3_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME_OVF_TIMER3_EN_Pos = 0x13
	// Bit mask of EVT_TIME_OVF_TIMER3_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME_OVF_TIMER3_EN_Msk = 0x80000
	// Bit EVT_TIME_OVF_TIMER3_EN.
	LEDC_EVT_TASK_EN0_EVT_TIME_OVF_TIMER3_EN = 0x80000
	// Position of EVT_TIME0_CMP_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME0_CMP_EN_Pos = 0x14
	// Bit mask of EVT_TIME0_CMP_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME0_CMP_EN_Msk = 0x100000
	// Bit EVT_TIME0_CMP_EN.
	LEDC_EVT_TASK_EN0_EVT_TIME0_CMP_EN = 0x100000
	// Position of EVT_TIME1_CMP_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME1_CMP_EN_Pos = 0x15
	// Bit mask of EVT_TIME1_CMP_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME1_CMP_EN_Msk = 0x200000
	// Bit EVT_TIME1_CMP_EN.
	LEDC_EVT_TASK_EN0_EVT_TIME1_CMP_EN = 0x200000
	// Position of EVT_TIME2_CMP_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME2_CMP_EN_Pos = 0x16
	// Bit mask of EVT_TIME2_CMP_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME2_CMP_EN_Msk = 0x400000
	// Bit EVT_TIME2_CMP_EN.
	LEDC_EVT_TASK_EN0_EVT_TIME2_CMP_EN = 0x400000
	// Position of EVT_TIME3_CMP_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME3_CMP_EN_Pos = 0x17
	// Bit mask of EVT_TIME3_CMP_EN field.
	LEDC_EVT_TASK_EN0_EVT_TIME3_CMP_EN_Msk = 0x800000
	// Bit EVT_TIME3_CMP_EN.
	LEDC_EVT_TASK_EN0_EVT_TIME3_CMP_EN = 0x800000
	// Position of TASK_DUTY_SCALE_UPDATE_CH0_EN field.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH0_EN_Pos = 0x18
	// Bit mask of TASK_DUTY_SCALE_UPDATE_CH0_EN field.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH0_EN_Msk = 0x1000000
	// Bit TASK_DUTY_SCALE_UPDATE_CH0_EN.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH0_EN = 0x1000000
	// Position of TASK_DUTY_SCALE_UPDATE_CH1_EN field.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH1_EN_Pos = 0x19
	// Bit mask of TASK_DUTY_SCALE_UPDATE_CH1_EN field.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH1_EN_Msk = 0x2000000
	// Bit TASK_DUTY_SCALE_UPDATE_CH1_EN.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH1_EN = 0x2000000
	// Position of TASK_DUTY_SCALE_UPDATE_CH2_EN field.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH2_EN_Pos = 0x1a
	// Bit mask of TASK_DUTY_SCALE_UPDATE_CH2_EN field.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH2_EN_Msk = 0x4000000
	// Bit TASK_DUTY_SCALE_UPDATE_CH2_EN.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH2_EN = 0x4000000
	// Position of TASK_DUTY_SCALE_UPDATE_CH3_EN field.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH3_EN_Pos = 0x1b
	// Bit mask of TASK_DUTY_SCALE_UPDATE_CH3_EN field.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH3_EN_Msk = 0x8000000
	// Bit TASK_DUTY_SCALE_UPDATE_CH3_EN.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH3_EN = 0x8000000
	// Position of TASK_DUTY_SCALE_UPDATE_CH4_EN field.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH4_EN_Pos = 0x1c
	// Bit mask of TASK_DUTY_SCALE_UPDATE_CH4_EN field.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH4_EN_Msk = 0x10000000
	// Bit TASK_DUTY_SCALE_UPDATE_CH4_EN.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH4_EN = 0x10000000
	// Position of TASK_DUTY_SCALE_UPDATE_CH5_EN field.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH5_EN_Pos = 0x1d
	// Bit mask of TASK_DUTY_SCALE_UPDATE_CH5_EN field.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH5_EN_Msk = 0x20000000
	// Bit TASK_DUTY_SCALE_UPDATE_CH5_EN.
	LEDC_EVT_TASK_EN0_TASK_DUTY_SCALE_UPDATE_CH5_EN = 0x20000000

	// EVT_TASK_EN1: Ledc event task enable bit register1.
	// Position of TASK_TIMER0_RES_UPDATE_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER0_RES_UPDATE_EN_Pos = 0x0
	// Bit mask of TASK_TIMER0_RES_UPDATE_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER0_RES_UPDATE_EN_Msk = 0x1
	// Bit TASK_TIMER0_RES_UPDATE_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER0_RES_UPDATE_EN = 0x1
	// Position of TASK_TIMER1_RES_UPDATE_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER1_RES_UPDATE_EN_Pos = 0x1
	// Bit mask of TASK_TIMER1_RES_UPDATE_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER1_RES_UPDATE_EN_Msk = 0x2
	// Bit TASK_TIMER1_RES_UPDATE_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER1_RES_UPDATE_EN = 0x2
	// Position of TASK_TIMER2_RES_UPDATE_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER2_RES_UPDATE_EN_Pos = 0x2
	// Bit mask of TASK_TIMER2_RES_UPDATE_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER2_RES_UPDATE_EN_Msk = 0x4
	// Bit TASK_TIMER2_RES_UPDATE_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER2_RES_UPDATE_EN = 0x4
	// Position of TASK_TIMER3_RES_UPDATE_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER3_RES_UPDATE_EN_Pos = 0x3
	// Bit mask of TASK_TIMER3_RES_UPDATE_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER3_RES_UPDATE_EN_Msk = 0x8
	// Bit TASK_TIMER3_RES_UPDATE_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER3_RES_UPDATE_EN = 0x8
	// Position of TASK_TIMER0_CAP_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER0_CAP_EN_Pos = 0x4
	// Bit mask of TASK_TIMER0_CAP_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER0_CAP_EN_Msk = 0x10
	// Bit TASK_TIMER0_CAP_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER0_CAP_EN = 0x10
	// Position of TASK_TIMER1_CAP_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER1_CAP_EN_Pos = 0x5
	// Bit mask of TASK_TIMER1_CAP_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER1_CAP_EN_Msk = 0x20
	// Bit TASK_TIMER1_CAP_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER1_CAP_EN = 0x20
	// Position of TASK_TIMER2_CAP_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER2_CAP_EN_Pos = 0x6
	// Bit mask of TASK_TIMER2_CAP_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER2_CAP_EN_Msk = 0x40
	// Bit TASK_TIMER2_CAP_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER2_CAP_EN = 0x40
	// Position of TASK_TIMER3_CAP_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER3_CAP_EN_Pos = 0x7
	// Bit mask of TASK_TIMER3_CAP_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER3_CAP_EN_Msk = 0x80
	// Bit TASK_TIMER3_CAP_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER3_CAP_EN = 0x80
	// Position of TASK_SIG_OUT_DIS_CH0_EN field.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH0_EN_Pos = 0x8
	// Bit mask of TASK_SIG_OUT_DIS_CH0_EN field.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH0_EN_Msk = 0x100
	// Bit TASK_SIG_OUT_DIS_CH0_EN.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH0_EN = 0x100
	// Position of TASK_SIG_OUT_DIS_CH1_EN field.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH1_EN_Pos = 0x9
	// Bit mask of TASK_SIG_OUT_DIS_CH1_EN field.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH1_EN_Msk = 0x200
	// Bit TASK_SIG_OUT_DIS_CH1_EN.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH1_EN = 0x200
	// Position of TASK_SIG_OUT_DIS_CH2_EN field.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH2_EN_Pos = 0xa
	// Bit mask of TASK_SIG_OUT_DIS_CH2_EN field.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH2_EN_Msk = 0x400
	// Bit TASK_SIG_OUT_DIS_CH2_EN.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH2_EN = 0x400
	// Position of TASK_SIG_OUT_DIS_CH3_EN field.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH3_EN_Pos = 0xb
	// Bit mask of TASK_SIG_OUT_DIS_CH3_EN field.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH3_EN_Msk = 0x800
	// Bit TASK_SIG_OUT_DIS_CH3_EN.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH3_EN = 0x800
	// Position of TASK_SIG_OUT_DIS_CH4_EN field.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH4_EN_Pos = 0xc
	// Bit mask of TASK_SIG_OUT_DIS_CH4_EN field.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH4_EN_Msk = 0x1000
	// Bit TASK_SIG_OUT_DIS_CH4_EN.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH4_EN = 0x1000
	// Position of TASK_SIG_OUT_DIS_CH5_EN field.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH5_EN_Pos = 0xd
	// Bit mask of TASK_SIG_OUT_DIS_CH5_EN field.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH5_EN_Msk = 0x2000
	// Bit TASK_SIG_OUT_DIS_CH5_EN.
	LEDC_EVT_TASK_EN1_TASK_SIG_OUT_DIS_CH5_EN = 0x2000
	// Position of TASK_OVF_CNT_RST_CH0_EN field.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH0_EN_Pos = 0x10
	// Bit mask of TASK_OVF_CNT_RST_CH0_EN field.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH0_EN_Msk = 0x10000
	// Bit TASK_OVF_CNT_RST_CH0_EN.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH0_EN = 0x10000
	// Position of TASK_OVF_CNT_RST_CH1_EN field.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH1_EN_Pos = 0x11
	// Bit mask of TASK_OVF_CNT_RST_CH1_EN field.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH1_EN_Msk = 0x20000
	// Bit TASK_OVF_CNT_RST_CH1_EN.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH1_EN = 0x20000
	// Position of TASK_OVF_CNT_RST_CH2_EN field.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH2_EN_Pos = 0x12
	// Bit mask of TASK_OVF_CNT_RST_CH2_EN field.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH2_EN_Msk = 0x40000
	// Bit TASK_OVF_CNT_RST_CH2_EN.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH2_EN = 0x40000
	// Position of TASK_OVF_CNT_RST_CH3_EN field.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH3_EN_Pos = 0x13
	// Bit mask of TASK_OVF_CNT_RST_CH3_EN field.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH3_EN_Msk = 0x80000
	// Bit TASK_OVF_CNT_RST_CH3_EN.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH3_EN = 0x80000
	// Position of TASK_OVF_CNT_RST_CH4_EN field.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH4_EN_Pos = 0x14
	// Bit mask of TASK_OVF_CNT_RST_CH4_EN field.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH4_EN_Msk = 0x100000
	// Bit TASK_OVF_CNT_RST_CH4_EN.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH4_EN = 0x100000
	// Position of TASK_OVF_CNT_RST_CH5_EN field.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH5_EN_Pos = 0x15
	// Bit mask of TASK_OVF_CNT_RST_CH5_EN field.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH5_EN_Msk = 0x200000
	// Bit TASK_OVF_CNT_RST_CH5_EN.
	LEDC_EVT_TASK_EN1_TASK_OVF_CNT_RST_CH5_EN = 0x200000
	// Position of TASK_TIMER0_RST_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER0_RST_EN_Pos = 0x18
	// Bit mask of TASK_TIMER0_RST_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER0_RST_EN_Msk = 0x1000000
	// Bit TASK_TIMER0_RST_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER0_RST_EN = 0x1000000
	// Position of TASK_TIMER1_RST_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER1_RST_EN_Pos = 0x19
	// Bit mask of TASK_TIMER1_RST_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER1_RST_EN_Msk = 0x2000000
	// Bit TASK_TIMER1_RST_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER1_RST_EN = 0x2000000
	// Position of TASK_TIMER2_RST_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER2_RST_EN_Pos = 0x1a
	// Bit mask of TASK_TIMER2_RST_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER2_RST_EN_Msk = 0x4000000
	// Bit TASK_TIMER2_RST_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER2_RST_EN = 0x4000000
	// Position of TASK_TIMER3_RST_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER3_RST_EN_Pos = 0x1b
	// Bit mask of TASK_TIMER3_RST_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER3_RST_EN_Msk = 0x8000000
	// Bit TASK_TIMER3_RST_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER3_RST_EN = 0x8000000
	// Position of TASK_TIMER0_PAUSE_RESUME_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER0_PAUSE_RESUME_EN_Pos = 0x1c
	// Bit mask of TASK_TIMER0_PAUSE_RESUME_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER0_PAUSE_RESUME_EN_Msk = 0x10000000
	// Bit TASK_TIMER0_PAUSE_RESUME_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER0_PAUSE_RESUME_EN = 0x10000000
	// Position of TASK_TIMER1_PAUSE_RESUME_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER1_PAUSE_RESUME_EN_Pos = 0x1d
	// Bit mask of TASK_TIMER1_PAUSE_RESUME_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER1_PAUSE_RESUME_EN_Msk = 0x20000000
	// Bit TASK_TIMER1_PAUSE_RESUME_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER1_PAUSE_RESUME_EN = 0x20000000
	// Position of TASK_TIMER2_PAUSE_RESUME_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER2_PAUSE_RESUME_EN_Pos = 0x1e
	// Bit mask of TASK_TIMER2_PAUSE_RESUME_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER2_PAUSE_RESUME_EN_Msk = 0x40000000
	// Bit TASK_TIMER2_PAUSE_RESUME_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER2_PAUSE_RESUME_EN = 0x40000000
	// Position of TASK_TIMER3_PAUSE_RESUME_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER3_PAUSE_RESUME_EN_Pos = 0x1f
	// Bit mask of TASK_TIMER3_PAUSE_RESUME_EN field.
	LEDC_EVT_TASK_EN1_TASK_TIMER3_PAUSE_RESUME_EN_Msk = 0x80000000
	// Bit TASK_TIMER3_PAUSE_RESUME_EN.
	LEDC_EVT_TASK_EN1_TASK_TIMER3_PAUSE_RESUME_EN = 0x80000000

	// EVT_TASK_EN2: Ledc event task enable bit register2.
	// Position of TASK_GAMMA_RESTART_CH0_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH0_EN_Pos = 0x0
	// Bit mask of TASK_GAMMA_RESTART_CH0_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH0_EN_Msk = 0x1
	// Bit TASK_GAMMA_RESTART_CH0_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH0_EN = 0x1
	// Position of TASK_GAMMA_RESTART_CH1_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH1_EN_Pos = 0x1
	// Bit mask of TASK_GAMMA_RESTART_CH1_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH1_EN_Msk = 0x2
	// Bit TASK_GAMMA_RESTART_CH1_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH1_EN = 0x2
	// Position of TASK_GAMMA_RESTART_CH2_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH2_EN_Pos = 0x2
	// Bit mask of TASK_GAMMA_RESTART_CH2_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH2_EN_Msk = 0x4
	// Bit TASK_GAMMA_RESTART_CH2_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH2_EN = 0x4
	// Position of TASK_GAMMA_RESTART_CH3_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH3_EN_Pos = 0x3
	// Bit mask of TASK_GAMMA_RESTART_CH3_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH3_EN_Msk = 0x8
	// Bit TASK_GAMMA_RESTART_CH3_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH3_EN = 0x8
	// Position of TASK_GAMMA_RESTART_CH4_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH4_EN_Pos = 0x4
	// Bit mask of TASK_GAMMA_RESTART_CH4_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH4_EN_Msk = 0x10
	// Bit TASK_GAMMA_RESTART_CH4_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH4_EN = 0x10
	// Position of TASK_GAMMA_RESTART_CH5_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH5_EN_Pos = 0x5
	// Bit mask of TASK_GAMMA_RESTART_CH5_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH5_EN_Msk = 0x20
	// Bit TASK_GAMMA_RESTART_CH5_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESTART_CH5_EN = 0x20
	// Position of TASK_GAMMA_PAUSE_CH0_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH0_EN_Pos = 0x8
	// Bit mask of TASK_GAMMA_PAUSE_CH0_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH0_EN_Msk = 0x100
	// Bit TASK_GAMMA_PAUSE_CH0_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH0_EN = 0x100
	// Position of TASK_GAMMA_PAUSE_CH1_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH1_EN_Pos = 0x9
	// Bit mask of TASK_GAMMA_PAUSE_CH1_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH1_EN_Msk = 0x200
	// Bit TASK_GAMMA_PAUSE_CH1_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH1_EN = 0x200
	// Position of TASK_GAMMA_PAUSE_CH2_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH2_EN_Pos = 0xa
	// Bit mask of TASK_GAMMA_PAUSE_CH2_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH2_EN_Msk = 0x400
	// Bit TASK_GAMMA_PAUSE_CH2_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH2_EN = 0x400
	// Position of TASK_GAMMA_PAUSE_CH3_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH3_EN_Pos = 0xb
	// Bit mask of TASK_GAMMA_PAUSE_CH3_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH3_EN_Msk = 0x800
	// Bit TASK_GAMMA_PAUSE_CH3_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH3_EN = 0x800
	// Position of TASK_GAMMA_PAUSE_CH4_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH4_EN_Pos = 0xc
	// Bit mask of TASK_GAMMA_PAUSE_CH4_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH4_EN_Msk = 0x1000
	// Bit TASK_GAMMA_PAUSE_CH4_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH4_EN = 0x1000
	// Position of TASK_GAMMA_PAUSE_CH5_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH5_EN_Pos = 0xd
	// Bit mask of TASK_GAMMA_PAUSE_CH5_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH5_EN_Msk = 0x2000
	// Bit TASK_GAMMA_PAUSE_CH5_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_PAUSE_CH5_EN = 0x2000
	// Position of TASK_GAMMA_RESUME_CH0_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH0_EN_Pos = 0x10
	// Bit mask of TASK_GAMMA_RESUME_CH0_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH0_EN_Msk = 0x10000
	// Bit TASK_GAMMA_RESUME_CH0_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH0_EN = 0x10000
	// Position of TASK_GAMMA_RESUME_CH1_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH1_EN_Pos = 0x11
	// Bit mask of TASK_GAMMA_RESUME_CH1_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH1_EN_Msk = 0x20000
	// Bit TASK_GAMMA_RESUME_CH1_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH1_EN = 0x20000
	// Position of TASK_GAMMA_RESUME_CH2_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH2_EN_Pos = 0x12
	// Bit mask of TASK_GAMMA_RESUME_CH2_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH2_EN_Msk = 0x40000
	// Bit TASK_GAMMA_RESUME_CH2_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH2_EN = 0x40000
	// Position of TASK_GAMMA_RESUME_CH3_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH3_EN_Pos = 0x13
	// Bit mask of TASK_GAMMA_RESUME_CH3_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH3_EN_Msk = 0x80000
	// Bit TASK_GAMMA_RESUME_CH3_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH3_EN = 0x80000
	// Position of TASK_GAMMA_RESUME_CH4_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH4_EN_Pos = 0x14
	// Bit mask of TASK_GAMMA_RESUME_CH4_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH4_EN_Msk = 0x100000
	// Bit TASK_GAMMA_RESUME_CH4_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH4_EN = 0x100000
	// Position of TASK_GAMMA_RESUME_CH5_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH5_EN_Pos = 0x15
	// Bit mask of TASK_GAMMA_RESUME_CH5_EN field.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH5_EN_Msk = 0x200000
	// Bit TASK_GAMMA_RESUME_CH5_EN.
	LEDC_EVT_TASK_EN2_TASK_GAMMA_RESUME_CH5_EN = 0x200000

	// TIMER0_CMP: Ledc timer%s compare value register.
	// Position of TIMER_CMP field.
	LEDC_TIMER_CMP_TIMER_CMP_Pos = 0x0
	// Bit mask of TIMER_CMP field.
	LEDC_TIMER_CMP_TIMER_CMP_Msk = 0xfffff

	// TIMER0_CNT_CAP: Ledc timer%s count value capture register.
	// Position of TIMER_CNT_CAP field.
	LEDC_TIMER_CNT_CAP_TIMER_CNT_CAP_Pos = 0x0
	// Bit mask of TIMER_CNT_CAP field.
	LEDC_TIMER_CNT_CAP_TIMER_CNT_CAP_Msk = 0xfffff

	// CONF: Global ledc configuration register
	// Position of APB_CLK_SEL field.
	LEDC_CONF_APB_CLK_SEL_Pos = 0x0
	// Bit mask of APB_CLK_SEL field.
	LEDC_CONF_APB_CLK_SEL_Msk = 0x3
	// Position of GAMMA_RAM_CLK_EN_CH0 field.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH0_Pos = 0x2
	// Bit mask of GAMMA_RAM_CLK_EN_CH0 field.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH0_Msk = 0x4
	// Bit GAMMA_RAM_CLK_EN_CH0.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH0 = 0x4
	// Position of GAMMA_RAM_CLK_EN_CH1 field.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH1_Pos = 0x3
	// Bit mask of GAMMA_RAM_CLK_EN_CH1 field.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH1_Msk = 0x8
	// Bit GAMMA_RAM_CLK_EN_CH1.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH1 = 0x8
	// Position of GAMMA_RAM_CLK_EN_CH2 field.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH2_Pos = 0x4
	// Bit mask of GAMMA_RAM_CLK_EN_CH2 field.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH2_Msk = 0x10
	// Bit GAMMA_RAM_CLK_EN_CH2.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH2 = 0x10
	// Position of GAMMA_RAM_CLK_EN_CH3 field.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH3_Pos = 0x5
	// Bit mask of GAMMA_RAM_CLK_EN_CH3 field.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH3_Msk = 0x20
	// Bit GAMMA_RAM_CLK_EN_CH3.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH3 = 0x20
	// Position of GAMMA_RAM_CLK_EN_CH4 field.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH4_Pos = 0x6
	// Bit mask of GAMMA_RAM_CLK_EN_CH4 field.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH4_Msk = 0x40
	// Bit GAMMA_RAM_CLK_EN_CH4.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH4 = 0x40
	// Position of GAMMA_RAM_CLK_EN_CH5 field.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH5_Pos = 0x7
	// Bit mask of GAMMA_RAM_CLK_EN_CH5 field.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH5_Msk = 0x80
	// Bit GAMMA_RAM_CLK_EN_CH5.
	LEDC_CONF_GAMMA_RAM_CLK_EN_CH5 = 0x80
	// Position of CLK_EN field.
	LEDC_CONF_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	LEDC_CONF_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	LEDC_CONF_CLK_EN = 0x80000000

	// DATE: Version control register
	// Position of LEDC_DATE field.
	LEDC_DATE_LEDC_DATE_Pos = 0x0
	// Bit mask of LEDC_DATE field.
	LEDC_DATE_LEDC_DATE_Msk = 0xfffffff
)

// Constants for LP_PERI: LP_PERI Peripheral
const (
	// CLK_EN: need_des
	// Position of RNG_CK_EN field.
	LPPERI_CLK_EN_RNG_CK_EN_Pos = 0x18
	// Bit mask of RNG_CK_EN field.
	LPPERI_CLK_EN_RNG_CK_EN_Msk = 0x1000000
	// Bit RNG_CK_EN.
	LPPERI_CLK_EN_RNG_CK_EN = 0x1000000
	// Position of OTP_DBG_CK_EN field.
	LPPERI_CLK_EN_OTP_DBG_CK_EN_Pos = 0x19
	// Bit mask of OTP_DBG_CK_EN field.
	LPPERI_CLK_EN_OTP_DBG_CK_EN_Msk = 0x2000000
	// Bit OTP_DBG_CK_EN.
	LPPERI_CLK_EN_OTP_DBG_CK_EN = 0x2000000
	// Position of LP_UART_CK_EN field.
	LPPERI_CLK_EN_LP_UART_CK_EN_Pos = 0x1a
	// Bit mask of LP_UART_CK_EN field.
	LPPERI_CLK_EN_LP_UART_CK_EN_Msk = 0x4000000
	// Bit LP_UART_CK_EN.
	LPPERI_CLK_EN_LP_UART_CK_EN = 0x4000000
	// Position of LP_IO_CK_EN field.
	LPPERI_CLK_EN_LP_IO_CK_EN_Pos = 0x1b
	// Bit mask of LP_IO_CK_EN field.
	LPPERI_CLK_EN_LP_IO_CK_EN_Msk = 0x8000000
	// Bit LP_IO_CK_EN.
	LPPERI_CLK_EN_LP_IO_CK_EN = 0x8000000
	// Position of LP_EXT_I2C_CK_EN field.
	LPPERI_CLK_EN_LP_EXT_I2C_CK_EN_Pos = 0x1c
	// Bit mask of LP_EXT_I2C_CK_EN field.
	LPPERI_CLK_EN_LP_EXT_I2C_CK_EN_Msk = 0x10000000
	// Bit LP_EXT_I2C_CK_EN.
	LPPERI_CLK_EN_LP_EXT_I2C_CK_EN = 0x10000000
	// Position of LP_ANA_I2C_CK_EN field.
	LPPERI_CLK_EN_LP_ANA_I2C_CK_EN_Pos = 0x1d
	// Bit mask of LP_ANA_I2C_CK_EN field.
	LPPERI_CLK_EN_LP_ANA_I2C_CK_EN_Msk = 0x20000000
	// Bit LP_ANA_I2C_CK_EN.
	LPPERI_CLK_EN_LP_ANA_I2C_CK_EN = 0x20000000
	// Position of EFUSE_CK_EN field.
	LPPERI_CLK_EN_EFUSE_CK_EN_Pos = 0x1e
	// Bit mask of EFUSE_CK_EN field.
	LPPERI_CLK_EN_EFUSE_CK_EN_Msk = 0x40000000
	// Bit EFUSE_CK_EN.
	LPPERI_CLK_EN_EFUSE_CK_EN = 0x40000000
	// Position of LP_CPU_CK_EN field.
	LPPERI_CLK_EN_LP_CPU_CK_EN_Pos = 0x1f
	// Bit mask of LP_CPU_CK_EN field.
	LPPERI_CLK_EN_LP_CPU_CK_EN_Msk = 0x80000000
	// Bit LP_CPU_CK_EN.
	LPPERI_CLK_EN_LP_CPU_CK_EN = 0x80000000

	// RESET_EN: need_des
	// Position of BUS_RESET_EN field.
	LPPERI_RESET_EN_BUS_RESET_EN_Pos = 0x17
	// Bit mask of BUS_RESET_EN field.
	LPPERI_RESET_EN_BUS_RESET_EN_Msk = 0x800000
	// Bit BUS_RESET_EN.
	LPPERI_RESET_EN_BUS_RESET_EN = 0x800000
	// Position of LP_BLE_TIMER_RESET_EN field.
	LPPERI_RESET_EN_LP_BLE_TIMER_RESET_EN_Pos = 0x18
	// Bit mask of LP_BLE_TIMER_RESET_EN field.
	LPPERI_RESET_EN_LP_BLE_TIMER_RESET_EN_Msk = 0x1000000
	// Bit LP_BLE_TIMER_RESET_EN.
	LPPERI_RESET_EN_LP_BLE_TIMER_RESET_EN = 0x1000000
	// Position of OTP_DBG_RESET_EN field.
	LPPERI_RESET_EN_OTP_DBG_RESET_EN_Pos = 0x19
	// Bit mask of OTP_DBG_RESET_EN field.
	LPPERI_RESET_EN_OTP_DBG_RESET_EN_Msk = 0x2000000
	// Bit OTP_DBG_RESET_EN.
	LPPERI_RESET_EN_OTP_DBG_RESET_EN = 0x2000000
	// Position of LP_UART_RESET_EN field.
	LPPERI_RESET_EN_LP_UART_RESET_EN_Pos = 0x1a
	// Bit mask of LP_UART_RESET_EN field.
	LPPERI_RESET_EN_LP_UART_RESET_EN_Msk = 0x4000000
	// Bit LP_UART_RESET_EN.
	LPPERI_RESET_EN_LP_UART_RESET_EN = 0x4000000
	// Position of LP_IO_RESET_EN field.
	LPPERI_RESET_EN_LP_IO_RESET_EN_Pos = 0x1b
	// Bit mask of LP_IO_RESET_EN field.
	LPPERI_RESET_EN_LP_IO_RESET_EN_Msk = 0x8000000
	// Bit LP_IO_RESET_EN.
	LPPERI_RESET_EN_LP_IO_RESET_EN = 0x8000000
	// Position of LP_EXT_I2C_RESET_EN field.
	LPPERI_RESET_EN_LP_EXT_I2C_RESET_EN_Pos = 0x1c
	// Bit mask of LP_EXT_I2C_RESET_EN field.
	LPPERI_RESET_EN_LP_EXT_I2C_RESET_EN_Msk = 0x10000000
	// Bit LP_EXT_I2C_RESET_EN.
	LPPERI_RESET_EN_LP_EXT_I2C_RESET_EN = 0x10000000
	// Position of LP_ANA_I2C_RESET_EN field.
	LPPERI_RESET_EN_LP_ANA_I2C_RESET_EN_Pos = 0x1d
	// Bit mask of LP_ANA_I2C_RESET_EN field.
	LPPERI_RESET_EN_LP_ANA_I2C_RESET_EN_Msk = 0x20000000
	// Bit LP_ANA_I2C_RESET_EN.
	LPPERI_RESET_EN_LP_ANA_I2C_RESET_EN = 0x20000000
	// Position of EFUSE_RESET_EN field.
	LPPERI_RESET_EN_EFUSE_RESET_EN_Pos = 0x1e
	// Bit mask of EFUSE_RESET_EN field.
	LPPERI_RESET_EN_EFUSE_RESET_EN_Msk = 0x40000000
	// Bit EFUSE_RESET_EN.
	LPPERI_RESET_EN_EFUSE_RESET_EN = 0x40000000
	// Position of LP_CPU_RESET_EN field.
	LPPERI_RESET_EN_LP_CPU_RESET_EN_Pos = 0x1f
	// Bit mask of LP_CPU_RESET_EN field.
	LPPERI_RESET_EN_LP_CPU_RESET_EN_Msk = 0x80000000
	// Bit LP_CPU_RESET_EN.
	LPPERI_RESET_EN_LP_CPU_RESET_EN = 0x80000000

	// RNG_DATA: need_des
	// Position of RND_DATA field.
	LPPERI_RNG_DATA_RND_DATA_Pos = 0x0
	// Bit mask of RND_DATA field.
	LPPERI_RNG_DATA_RND_DATA_Msk = 0xffffffff

	// CPU: need_des
	// Position of LPCORE_DBGM_UNAVALIABLE field.
	LPPERI_CPU_LPCORE_DBGM_UNAVALIABLE_Pos = 0x1f
	// Bit mask of LPCORE_DBGM_UNAVALIABLE field.
	LPPERI_CPU_LPCORE_DBGM_UNAVALIABLE_Msk = 0x80000000
	// Bit LPCORE_DBGM_UNAVALIABLE.
	LPPERI_CPU_LPCORE_DBGM_UNAVALIABLE = 0x80000000

	// BUS_TIMEOUT: need_des
	// Position of LP_PERI_TIMEOUT_THRES field.
	LPPERI_BUS_TIMEOUT_LP_PERI_TIMEOUT_THRES_Pos = 0xe
	// Bit mask of LP_PERI_TIMEOUT_THRES field.
	LPPERI_BUS_TIMEOUT_LP_PERI_TIMEOUT_THRES_Msk = 0x3fffc000
	// Position of LP_PERI_TIMEOUT_INT_CLEAR field.
	LPPERI_BUS_TIMEOUT_LP_PERI_TIMEOUT_INT_CLEAR_Pos = 0x1e
	// Bit mask of LP_PERI_TIMEOUT_INT_CLEAR field.
	LPPERI_BUS_TIMEOUT_LP_PERI_TIMEOUT_INT_CLEAR_Msk = 0x40000000
	// Bit LP_PERI_TIMEOUT_INT_CLEAR.
	LPPERI_BUS_TIMEOUT_LP_PERI_TIMEOUT_INT_CLEAR = 0x40000000
	// Position of LP_PERI_TIMEOUT_PROTECT_EN field.
	LPPERI_BUS_TIMEOUT_LP_PERI_TIMEOUT_PROTECT_EN_Pos = 0x1f
	// Bit mask of LP_PERI_TIMEOUT_PROTECT_EN field.
	LPPERI_BUS_TIMEOUT_LP_PERI_TIMEOUT_PROTECT_EN_Msk = 0x80000000
	// Bit LP_PERI_TIMEOUT_PROTECT_EN.
	LPPERI_BUS_TIMEOUT_LP_PERI_TIMEOUT_PROTECT_EN = 0x80000000

	// BUS_TIMEOUT_ADDR: need_des
	// Position of LP_PERI_TIMEOUT_ADDR field.
	LPPERI_BUS_TIMEOUT_ADDR_LP_PERI_TIMEOUT_ADDR_Pos = 0x0
	// Bit mask of LP_PERI_TIMEOUT_ADDR field.
	LPPERI_BUS_TIMEOUT_ADDR_LP_PERI_TIMEOUT_ADDR_Msk = 0xffffffff

	// BUS_TIMEOUT_UID: need_des
	// Position of LP_PERI_TIMEOUT_UID field.
	LPPERI_BUS_TIMEOUT_UID_LP_PERI_TIMEOUT_UID_Pos = 0x0
	// Bit mask of LP_PERI_TIMEOUT_UID field.
	LPPERI_BUS_TIMEOUT_UID_LP_PERI_TIMEOUT_UID_Msk = 0x7f

	// MEM_CTRL: need_des
	// Position of UART_WAKEUP_FLAG_CLR field.
	LPPERI_MEM_CTRL_UART_WAKEUP_FLAG_CLR_Pos = 0x0
	// Bit mask of UART_WAKEUP_FLAG_CLR field.
	LPPERI_MEM_CTRL_UART_WAKEUP_FLAG_CLR_Msk = 0x1
	// Bit UART_WAKEUP_FLAG_CLR.
	LPPERI_MEM_CTRL_UART_WAKEUP_FLAG_CLR = 0x1
	// Position of UART_WAKEUP_FLAG field.
	LPPERI_MEM_CTRL_UART_WAKEUP_FLAG_Pos = 0x1
	// Bit mask of UART_WAKEUP_FLAG field.
	LPPERI_MEM_CTRL_UART_WAKEUP_FLAG_Msk = 0x2
	// Bit UART_WAKEUP_FLAG.
	LPPERI_MEM_CTRL_UART_WAKEUP_FLAG = 0x2
	// Position of UART_WAKEUP_EN field.
	LPPERI_MEM_CTRL_UART_WAKEUP_EN_Pos = 0x1d
	// Bit mask of UART_WAKEUP_EN field.
	LPPERI_MEM_CTRL_UART_WAKEUP_EN_Msk = 0x20000000
	// Bit UART_WAKEUP_EN.
	LPPERI_MEM_CTRL_UART_WAKEUP_EN = 0x20000000
	// Position of UART_MEM_FORCE_PD field.
	LPPERI_MEM_CTRL_UART_MEM_FORCE_PD_Pos = 0x1e
	// Bit mask of UART_MEM_FORCE_PD field.
	LPPERI_MEM_CTRL_UART_MEM_FORCE_PD_Msk = 0x40000000
	// Bit UART_MEM_FORCE_PD.
	LPPERI_MEM_CTRL_UART_MEM_FORCE_PD = 0x40000000
	// Position of UART_MEM_FORCE_PU field.
	LPPERI_MEM_CTRL_UART_MEM_FORCE_PU_Pos = 0x1f
	// Bit mask of UART_MEM_FORCE_PU field.
	LPPERI_MEM_CTRL_UART_MEM_FORCE_PU_Msk = 0x80000000
	// Bit UART_MEM_FORCE_PU.
	LPPERI_MEM_CTRL_UART_MEM_FORCE_PU = 0x80000000

	// INTERRUPT_SOURCE: need_des
	// Position of LP_INTERRUPT_SOURCE field.
	LPPERI_INTERRUPT_SOURCE_LP_INTERRUPT_SOURCE_Pos = 0x0
	// Bit mask of LP_INTERRUPT_SOURCE field.
	LPPERI_INTERRUPT_SOURCE_LP_INTERRUPT_SOURCE_Msk = 0x3f

	// DEBUG_SEL0: need des
	// Position of DEBUG_SEL0 field.
	LPPERI_DEBUG_SEL0_DEBUG_SEL0_Pos = 0x0
	// Bit mask of DEBUG_SEL0 field.
	LPPERI_DEBUG_SEL0_DEBUG_SEL0_Msk = 0x7f
	// Position of DEBUG_SEL1 field.
	LPPERI_DEBUG_SEL0_DEBUG_SEL1_Pos = 0x7
	// Bit mask of DEBUG_SEL1 field.
	LPPERI_DEBUG_SEL0_DEBUG_SEL1_Msk = 0x3f80
	// Position of DEBUG_SEL2 field.
	LPPERI_DEBUG_SEL0_DEBUG_SEL2_Pos = 0xe
	// Bit mask of DEBUG_SEL2 field.
	LPPERI_DEBUG_SEL0_DEBUG_SEL2_Msk = 0x1fc000
	// Position of DEBUG_SEL3 field.
	LPPERI_DEBUG_SEL0_DEBUG_SEL3_Pos = 0x15
	// Bit mask of DEBUG_SEL3 field.
	LPPERI_DEBUG_SEL0_DEBUG_SEL3_Msk = 0xfe00000

	// DEBUG_SEL1: need des
	// Position of DEBUG_SEL4 field.
	LPPERI_DEBUG_SEL1_DEBUG_SEL4_Pos = 0x0
	// Bit mask of DEBUG_SEL4 field.
	LPPERI_DEBUG_SEL1_DEBUG_SEL4_Msk = 0x7f

	// DATE: need_des
	// Position of LPPERI_DATE field.
	LPPERI_DATE_LPPERI_DATE_Pos = 0x0
	// Bit mask of LPPERI_DATE field.
	LPPERI_DATE_LPPERI_DATE_Msk = 0x7fffffff
	// Position of CLK_EN field.
	LPPERI_DATE_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	LPPERI_DATE_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	LPPERI_DATE_CLK_EN = 0x80000000
)

// Constants for LP_ANA: LP_ANA Peripheral
const (
	// BOD_MODE0_CNTL: need_des
	// Position of BOD_MODE0_CLOSE_FLASH_ENA field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_CLOSE_FLASH_ENA_Pos = 0x6
	// Bit mask of BOD_MODE0_CLOSE_FLASH_ENA field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_CLOSE_FLASH_ENA_Msk = 0x40
	// Bit BOD_MODE0_CLOSE_FLASH_ENA.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_CLOSE_FLASH_ENA = 0x40
	// Position of BOD_MODE0_PD_RF_ENA field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_PD_RF_ENA_Pos = 0x7
	// Bit mask of BOD_MODE0_PD_RF_ENA field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_PD_RF_ENA_Msk = 0x80
	// Bit BOD_MODE0_PD_RF_ENA.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_PD_RF_ENA = 0x80
	// Position of BOD_MODE0_INTR_WAIT field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_INTR_WAIT_Pos = 0x8
	// Bit mask of BOD_MODE0_INTR_WAIT field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_INTR_WAIT_Msk = 0x3ff00
	// Position of BOD_MODE0_RESET_WAIT field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_RESET_WAIT_Pos = 0x12
	// Bit mask of BOD_MODE0_RESET_WAIT field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_RESET_WAIT_Msk = 0xffc0000
	// Position of BOD_MODE0_CNT_CLR field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_CNT_CLR_Pos = 0x1c
	// Bit mask of BOD_MODE0_CNT_CLR field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_CNT_CLR_Msk = 0x10000000
	// Bit BOD_MODE0_CNT_CLR.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_CNT_CLR = 0x10000000
	// Position of BOD_MODE0_INTR_ENA field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_INTR_ENA_Pos = 0x1d
	// Bit mask of BOD_MODE0_INTR_ENA field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_INTR_ENA_Msk = 0x20000000
	// Bit BOD_MODE0_INTR_ENA.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_INTR_ENA = 0x20000000
	// Position of BOD_MODE0_RESET_SEL field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_RESET_SEL_Pos = 0x1e
	// Bit mask of BOD_MODE0_RESET_SEL field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_RESET_SEL_Msk = 0x40000000
	// Bit BOD_MODE0_RESET_SEL.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_RESET_SEL = 0x40000000
	// Position of BOD_MODE0_RESET_ENA field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_RESET_ENA_Pos = 0x1f
	// Bit mask of BOD_MODE0_RESET_ENA field.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_RESET_ENA_Msk = 0x80000000
	// Bit BOD_MODE0_RESET_ENA.
	LP_ANA_BOD_MODE0_CNTL_BOD_MODE0_RESET_ENA = 0x80000000

	// BOD_MODE1_CNTL: need_des
	// Position of BOD_MODE1_RESET_ENA field.
	LP_ANA_BOD_MODE1_CNTL_BOD_MODE1_RESET_ENA_Pos = 0x1f
	// Bit mask of BOD_MODE1_RESET_ENA field.
	LP_ANA_BOD_MODE1_CNTL_BOD_MODE1_RESET_ENA_Msk = 0x80000000
	// Bit BOD_MODE1_RESET_ENA.
	LP_ANA_BOD_MODE1_CNTL_BOD_MODE1_RESET_ENA = 0x80000000

	// VDD_SOURCE_CNTL: need_des
	// Position of DETMODE_SEL field.
	LP_ANA_VDD_SOURCE_CNTL_DETMODE_SEL_Pos = 0x0
	// Bit mask of DETMODE_SEL field.
	LP_ANA_VDD_SOURCE_CNTL_DETMODE_SEL_Msk = 0xff
	// Position of VGOOD_EVENT_RECORD field.
	LP_ANA_VDD_SOURCE_CNTL_VGOOD_EVENT_RECORD_Pos = 0x8
	// Bit mask of VGOOD_EVENT_RECORD field.
	LP_ANA_VDD_SOURCE_CNTL_VGOOD_EVENT_RECORD_Msk = 0xff00
	// Position of VBAT_EVENT_RECORD_CLR field.
	LP_ANA_VDD_SOURCE_CNTL_VBAT_EVENT_RECORD_CLR_Pos = 0x10
	// Bit mask of VBAT_EVENT_RECORD_CLR field.
	LP_ANA_VDD_SOURCE_CNTL_VBAT_EVENT_RECORD_CLR_Msk = 0xff0000
	// Position of BOD_SOURCE_ENA field.
	LP_ANA_VDD_SOURCE_CNTL_BOD_SOURCE_ENA_Pos = 0x18
	// Bit mask of BOD_SOURCE_ENA field.
	LP_ANA_VDD_SOURCE_CNTL_BOD_SOURCE_ENA_Msk = 0xff000000

	// VDDBAT_BOD_CNTL: need_des
	// Position of VDDBAT_UNDERVOLTAGE_FLAG field.
	LP_ANA_VDDBAT_BOD_CNTL_VDDBAT_UNDERVOLTAGE_FLAG_Pos = 0x0
	// Bit mask of VDDBAT_UNDERVOLTAGE_FLAG field.
	LP_ANA_VDDBAT_BOD_CNTL_VDDBAT_UNDERVOLTAGE_FLAG_Msk = 0x1
	// Bit VDDBAT_UNDERVOLTAGE_FLAG.
	LP_ANA_VDDBAT_BOD_CNTL_VDDBAT_UNDERVOLTAGE_FLAG = 0x1
	// Position of VDDBAT_CHARGER field.
	LP_ANA_VDDBAT_BOD_CNTL_VDDBAT_CHARGER_Pos = 0xa
	// Bit mask of VDDBAT_CHARGER field.
	LP_ANA_VDDBAT_BOD_CNTL_VDDBAT_CHARGER_Msk = 0x400
	// Bit VDDBAT_CHARGER.
	LP_ANA_VDDBAT_BOD_CNTL_VDDBAT_CHARGER = 0x400
	// Position of VDDBAT_CNT_CLR field.
	LP_ANA_VDDBAT_BOD_CNTL_VDDBAT_CNT_CLR_Pos = 0xb
	// Bit mask of VDDBAT_CNT_CLR field.
	LP_ANA_VDDBAT_BOD_CNTL_VDDBAT_CNT_CLR_Msk = 0x800
	// Bit VDDBAT_CNT_CLR.
	LP_ANA_VDDBAT_BOD_CNTL_VDDBAT_CNT_CLR = 0x800
	// Position of VDDBAT_UPVOLTAGE_TARGET field.
	LP_ANA_VDDBAT_BOD_CNTL_VDDBAT_UPVOLTAGE_TARGET_Pos = 0xc
	// Bit mask of VDDBAT_UPVOLTAGE_TARGET field.
	LP_ANA_VDDBAT_BOD_CNTL_VDDBAT_UPVOLTAGE_TARGET_Msk = 0x3ff000
	// Position of VDDBAT_UNDERVOLTAGE_TARGET field.
	LP_ANA_VDDBAT_BOD_CNTL_VDDBAT_UNDERVOLTAGE_TARGET_Pos = 0x16
	// Bit mask of VDDBAT_UNDERVOLTAGE_TARGET field.
	LP_ANA_VDDBAT_BOD_CNTL_VDDBAT_UNDERVOLTAGE_TARGET_Msk = 0xffc00000

	// VDDBAT_CHARGE_CNTL: need_des
	// Position of VDDBAT_CHARGE_UNDERVOLTAGE_FLAG field.
	LP_ANA_VDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_UNDERVOLTAGE_FLAG_Pos = 0x0
	// Bit mask of VDDBAT_CHARGE_UNDERVOLTAGE_FLAG field.
	LP_ANA_VDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_UNDERVOLTAGE_FLAG_Msk = 0x1
	// Bit VDDBAT_CHARGE_UNDERVOLTAGE_FLAG.
	LP_ANA_VDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_UNDERVOLTAGE_FLAG = 0x1
	// Position of VDDBAT_CHARGE_CHARGER field.
	LP_ANA_VDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_CHARGER_Pos = 0xa
	// Bit mask of VDDBAT_CHARGE_CHARGER field.
	LP_ANA_VDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_CHARGER_Msk = 0x400
	// Bit VDDBAT_CHARGE_CHARGER.
	LP_ANA_VDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_CHARGER = 0x400
	// Position of VDDBAT_CHARGE_CNT_CLR field.
	LP_ANA_VDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_CNT_CLR_Pos = 0xb
	// Bit mask of VDDBAT_CHARGE_CNT_CLR field.
	LP_ANA_VDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_CNT_CLR_Msk = 0x800
	// Bit VDDBAT_CHARGE_CNT_CLR.
	LP_ANA_VDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_CNT_CLR = 0x800
	// Position of VDDBAT_CHARGE_UPVOLTAGE_TARGET field.
	LP_ANA_VDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_UPVOLTAGE_TARGET_Pos = 0xc
	// Bit mask of VDDBAT_CHARGE_UPVOLTAGE_TARGET field.
	LP_ANA_VDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_UPVOLTAGE_TARGET_Msk = 0x3ff000
	// Position of VDDBAT_CHARGE_UNDERVOLTAGE_TARGET field.
	LP_ANA_VDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_UNDERVOLTAGE_TARGET_Pos = 0x16
	// Bit mask of VDDBAT_CHARGE_UNDERVOLTAGE_TARGET field.
	LP_ANA_VDDBAT_CHARGE_CNTL_VDDBAT_CHARGE_UNDERVOLTAGE_TARGET_Msk = 0xffc00000

	// CK_GLITCH_CNTL: need_des
	// Position of CK_GLITCH_RESET_ENA field.
	LP_ANA_CK_GLITCH_CNTL_CK_GLITCH_RESET_ENA_Pos = 0x1f
	// Bit mask of CK_GLITCH_RESET_ENA field.
	LP_ANA_CK_GLITCH_CNTL_CK_GLITCH_RESET_ENA_Msk = 0x80000000
	// Bit CK_GLITCH_RESET_ENA.
	LP_ANA_CK_GLITCH_CNTL_CK_GLITCH_RESET_ENA = 0x80000000

	// PG_GLITCH_CNTL: need_des
	// Position of POWER_GLITCH_RESET_ENA field.
	LP_ANA_PG_GLITCH_CNTL_POWER_GLITCH_RESET_ENA_Pos = 0x1f
	// Bit mask of POWER_GLITCH_RESET_ENA field.
	LP_ANA_PG_GLITCH_CNTL_POWER_GLITCH_RESET_ENA_Msk = 0x80000000
	// Bit POWER_GLITCH_RESET_ENA.
	LP_ANA_PG_GLITCH_CNTL_POWER_GLITCH_RESET_ENA = 0x80000000

	// FIB_ENABLE: need_des
	// Position of ANA_FIB_ENA field.
	LP_ANA_FIB_ENABLE_ANA_FIB_ENA_Pos = 0x0
	// Bit mask of ANA_FIB_ENA field.
	LP_ANA_FIB_ENABLE_ANA_FIB_ENA_Msk = 0xffffffff

	// INT_RAW: need_des
	// Position of VDDBAT_CHARGE_UPVOLTAGE_INT_RAW field.
	LP_ANA_INT_RAW_VDDBAT_CHARGE_UPVOLTAGE_INT_RAW_Pos = 0x1b
	// Bit mask of VDDBAT_CHARGE_UPVOLTAGE_INT_RAW field.
	LP_ANA_INT_RAW_VDDBAT_CHARGE_UPVOLTAGE_INT_RAW_Msk = 0x8000000
	// Bit VDDBAT_CHARGE_UPVOLTAGE_INT_RAW.
	LP_ANA_INT_RAW_VDDBAT_CHARGE_UPVOLTAGE_INT_RAW = 0x8000000
	// Position of VDDBAT_CHARGE_UNDERVOLTAGE_INT_RAW field.
	LP_ANA_INT_RAW_VDDBAT_CHARGE_UNDERVOLTAGE_INT_RAW_Pos = 0x1c
	// Bit mask of VDDBAT_CHARGE_UNDERVOLTAGE_INT_RAW field.
	LP_ANA_INT_RAW_VDDBAT_CHARGE_UNDERVOLTAGE_INT_RAW_Msk = 0x10000000
	// Bit VDDBAT_CHARGE_UNDERVOLTAGE_INT_RAW.
	LP_ANA_INT_RAW_VDDBAT_CHARGE_UNDERVOLTAGE_INT_RAW = 0x10000000
	// Position of VDDBAT_UPVOLTAGE_INT_RAW field.
	LP_ANA_INT_RAW_VDDBAT_UPVOLTAGE_INT_RAW_Pos = 0x1d
	// Bit mask of VDDBAT_UPVOLTAGE_INT_RAW field.
	LP_ANA_INT_RAW_VDDBAT_UPVOLTAGE_INT_RAW_Msk = 0x20000000
	// Bit VDDBAT_UPVOLTAGE_INT_RAW.
	LP_ANA_INT_RAW_VDDBAT_UPVOLTAGE_INT_RAW = 0x20000000
	// Position of VDDBAT_UNDERVOLTAGE_INT_RAW field.
	LP_ANA_INT_RAW_VDDBAT_UNDERVOLTAGE_INT_RAW_Pos = 0x1e
	// Bit mask of VDDBAT_UNDERVOLTAGE_INT_RAW field.
	LP_ANA_INT_RAW_VDDBAT_UNDERVOLTAGE_INT_RAW_Msk = 0x40000000
	// Bit VDDBAT_UNDERVOLTAGE_INT_RAW.
	LP_ANA_INT_RAW_VDDBAT_UNDERVOLTAGE_INT_RAW = 0x40000000
	// Position of BOD_MODE0_INT_RAW field.
	LP_ANA_INT_RAW_BOD_MODE0_INT_RAW_Pos = 0x1f
	// Bit mask of BOD_MODE0_INT_RAW field.
	LP_ANA_INT_RAW_BOD_MODE0_INT_RAW_Msk = 0x80000000
	// Bit BOD_MODE0_INT_RAW.
	LP_ANA_INT_RAW_BOD_MODE0_INT_RAW = 0x80000000

	// INT_ST: need_des
	// Position of VDDBAT_CHARGE_UPVOLTAGE_INT_ST field.
	LP_ANA_INT_ST_VDDBAT_CHARGE_UPVOLTAGE_INT_ST_Pos = 0x1b
	// Bit mask of VDDBAT_CHARGE_UPVOLTAGE_INT_ST field.
	LP_ANA_INT_ST_VDDBAT_CHARGE_UPVOLTAGE_INT_ST_Msk = 0x8000000
	// Bit VDDBAT_CHARGE_UPVOLTAGE_INT_ST.
	LP_ANA_INT_ST_VDDBAT_CHARGE_UPVOLTAGE_INT_ST = 0x8000000
	// Position of VDDBAT_CHARGE_UNDERVOLTAGE_INT_ST field.
	LP_ANA_INT_ST_VDDBAT_CHARGE_UNDERVOLTAGE_INT_ST_Pos = 0x1c
	// Bit mask of VDDBAT_CHARGE_UNDERVOLTAGE_INT_ST field.
	LP_ANA_INT_ST_VDDBAT_CHARGE_UNDERVOLTAGE_INT_ST_Msk = 0x10000000
	// Bit VDDBAT_CHARGE_UNDERVOLTAGE_INT_ST.
	LP_ANA_INT_ST_VDDBAT_CHARGE_UNDERVOLTAGE_INT_ST = 0x10000000
	// Position of VDDBAT_UPVOLTAGE_INT_ST field.
	LP_ANA_INT_ST_VDDBAT_UPVOLTAGE_INT_ST_Pos = 0x1d
	// Bit mask of VDDBAT_UPVOLTAGE_INT_ST field.
	LP_ANA_INT_ST_VDDBAT_UPVOLTAGE_INT_ST_Msk = 0x20000000
	// Bit VDDBAT_UPVOLTAGE_INT_ST.
	LP_ANA_INT_ST_VDDBAT_UPVOLTAGE_INT_ST = 0x20000000
	// Position of VDDBAT_UNDERVOLTAGE_INT_ST field.
	LP_ANA_INT_ST_VDDBAT_UNDERVOLTAGE_INT_ST_Pos = 0x1e
	// Bit mask of VDDBAT_UNDERVOLTAGE_INT_ST field.
	LP_ANA_INT_ST_VDDBAT_UNDERVOLTAGE_INT_ST_Msk = 0x40000000
	// Bit VDDBAT_UNDERVOLTAGE_INT_ST.
	LP_ANA_INT_ST_VDDBAT_UNDERVOLTAGE_INT_ST = 0x40000000
	// Position of BOD_MODE0_INT_ST field.
	LP_ANA_INT_ST_BOD_MODE0_INT_ST_Pos = 0x1f
	// Bit mask of BOD_MODE0_INT_ST field.
	LP_ANA_INT_ST_BOD_MODE0_INT_ST_Msk = 0x80000000
	// Bit BOD_MODE0_INT_ST.
	LP_ANA_INT_ST_BOD_MODE0_INT_ST = 0x80000000

	// INT_ENA: need_des
	// Position of VDDBAT_CHARGE_UPVOLTAGE_INT_ENA field.
	LP_ANA_INT_ENA_VDDBAT_CHARGE_UPVOLTAGE_INT_ENA_Pos = 0x1b
	// Bit mask of VDDBAT_CHARGE_UPVOLTAGE_INT_ENA field.
	LP_ANA_INT_ENA_VDDBAT_CHARGE_UPVOLTAGE_INT_ENA_Msk = 0x8000000
	// Bit VDDBAT_CHARGE_UPVOLTAGE_INT_ENA.
	LP_ANA_INT_ENA_VDDBAT_CHARGE_UPVOLTAGE_INT_ENA = 0x8000000
	// Position of VDDBAT_CHARGE_UNDERVOLTAGE_INT_ENA field.
	LP_ANA_INT_ENA_VDDBAT_CHARGE_UNDERVOLTAGE_INT_ENA_Pos = 0x1c
	// Bit mask of VDDBAT_CHARGE_UNDERVOLTAGE_INT_ENA field.
	LP_ANA_INT_ENA_VDDBAT_CHARGE_UNDERVOLTAGE_INT_ENA_Msk = 0x10000000
	// Bit VDDBAT_CHARGE_UNDERVOLTAGE_INT_ENA.
	LP_ANA_INT_ENA_VDDBAT_CHARGE_UNDERVOLTAGE_INT_ENA = 0x10000000
	// Position of VDDBAT_UPVOLTAGE_INT_ENA field.
	LP_ANA_INT_ENA_VDDBAT_UPVOLTAGE_INT_ENA_Pos = 0x1d
	// Bit mask of VDDBAT_UPVOLTAGE_INT_ENA field.
	LP_ANA_INT_ENA_VDDBAT_UPVOLTAGE_INT_ENA_Msk = 0x20000000
	// Bit VDDBAT_UPVOLTAGE_INT_ENA.
	LP_ANA_INT_ENA_VDDBAT_UPVOLTAGE_INT_ENA = 0x20000000
	// Position of VDDBAT_UNDERVOLTAGE_INT_ENA field.
	LP_ANA_INT_ENA_VDDBAT_UNDERVOLTAGE_INT_ENA_Pos = 0x1e
	// Bit mask of VDDBAT_UNDERVOLTAGE_INT_ENA field.
	LP_ANA_INT_ENA_VDDBAT_UNDERVOLTAGE_INT_ENA_Msk = 0x40000000
	// Bit VDDBAT_UNDERVOLTAGE_INT_ENA.
	LP_ANA_INT_ENA_VDDBAT_UNDERVOLTAGE_INT_ENA = 0x40000000
	// Position of BOD_MODE0_INT_ENA field.
	LP_ANA_INT_ENA_BOD_MODE0_INT_ENA_Pos = 0x1f
	// Bit mask of BOD_MODE0_INT_ENA field.
	LP_ANA_INT_ENA_BOD_MODE0_INT_ENA_Msk = 0x80000000
	// Bit BOD_MODE0_INT_ENA.
	LP_ANA_INT_ENA_BOD_MODE0_INT_ENA = 0x80000000

	// INT_CLR: need_des
	// Position of VDDBAT_CHARGE_UPVOLTAGE_INT_CLR field.
	LP_ANA_INT_CLR_VDDBAT_CHARGE_UPVOLTAGE_INT_CLR_Pos = 0x1b
	// Bit mask of VDDBAT_CHARGE_UPVOLTAGE_INT_CLR field.
	LP_ANA_INT_CLR_VDDBAT_CHARGE_UPVOLTAGE_INT_CLR_Msk = 0x8000000
	// Bit VDDBAT_CHARGE_UPVOLTAGE_INT_CLR.
	LP_ANA_INT_CLR_VDDBAT_CHARGE_UPVOLTAGE_INT_CLR = 0x8000000
	// Position of VDDBAT_CHARGE_UNDERVOLTAGE_INT_CLR field.
	LP_ANA_INT_CLR_VDDBAT_CHARGE_UNDERVOLTAGE_INT_CLR_Pos = 0x1c
	// Bit mask of VDDBAT_CHARGE_UNDERVOLTAGE_INT_CLR field.
	LP_ANA_INT_CLR_VDDBAT_CHARGE_UNDERVOLTAGE_INT_CLR_Msk = 0x10000000
	// Bit VDDBAT_CHARGE_UNDERVOLTAGE_INT_CLR.
	LP_ANA_INT_CLR_VDDBAT_CHARGE_UNDERVOLTAGE_INT_CLR = 0x10000000
	// Position of VDDBAT_UPVOLTAGE_INT_CLR field.
	LP_ANA_INT_CLR_VDDBAT_UPVOLTAGE_INT_CLR_Pos = 0x1d
	// Bit mask of VDDBAT_UPVOLTAGE_INT_CLR field.
	LP_ANA_INT_CLR_VDDBAT_UPVOLTAGE_INT_CLR_Msk = 0x20000000
	// Bit VDDBAT_UPVOLTAGE_INT_CLR.
	LP_ANA_INT_CLR_VDDBAT_UPVOLTAGE_INT_CLR = 0x20000000
	// Position of VDDBAT_UNDERVOLTAGE_INT_CLR field.
	LP_ANA_INT_CLR_VDDBAT_UNDERVOLTAGE_INT_CLR_Pos = 0x1e
	// Bit mask of VDDBAT_UNDERVOLTAGE_INT_CLR field.
	LP_ANA_INT_CLR_VDDBAT_UNDERVOLTAGE_INT_CLR_Msk = 0x40000000
	// Bit VDDBAT_UNDERVOLTAGE_INT_CLR.
	LP_ANA_INT_CLR_VDDBAT_UNDERVOLTAGE_INT_CLR = 0x40000000
	// Position of BOD_MODE0_INT_CLR field.
	LP_ANA_INT_CLR_BOD_MODE0_INT_CLR_Pos = 0x1f
	// Bit mask of BOD_MODE0_INT_CLR field.
	LP_ANA_INT_CLR_BOD_MODE0_INT_CLR_Msk = 0x80000000
	// Bit BOD_MODE0_INT_CLR.
	LP_ANA_INT_CLR_BOD_MODE0_INT_CLR = 0x80000000

	// LP_INT_RAW: need_des
	// Position of BOD_MODE0_LP_INT_RAW field.
	LP_ANA_LP_INT_RAW_BOD_MODE0_LP_INT_RAW_Pos = 0x1f
	// Bit mask of BOD_MODE0_LP_INT_RAW field.
	LP_ANA_LP_INT_RAW_BOD_MODE0_LP_INT_RAW_Msk = 0x80000000
	// Bit BOD_MODE0_LP_INT_RAW.
	LP_ANA_LP_INT_RAW_BOD_MODE0_LP_INT_RAW = 0x80000000

	// LP_INT_ST: need_des
	// Position of BOD_MODE0_LP_INT_ST field.
	LP_ANA_LP_INT_ST_BOD_MODE0_LP_INT_ST_Pos = 0x1f
	// Bit mask of BOD_MODE0_LP_INT_ST field.
	LP_ANA_LP_INT_ST_BOD_MODE0_LP_INT_ST_Msk = 0x80000000
	// Bit BOD_MODE0_LP_INT_ST.
	LP_ANA_LP_INT_ST_BOD_MODE0_LP_INT_ST = 0x80000000

	// LP_INT_ENA: need_des
	// Position of BOD_MODE0_LP_INT_ENA field.
	LP_ANA_LP_INT_ENA_BOD_MODE0_LP_INT_ENA_Pos = 0x1f
	// Bit mask of BOD_MODE0_LP_INT_ENA field.
	LP_ANA_LP_INT_ENA_BOD_MODE0_LP_INT_ENA_Msk = 0x80000000
	// Bit BOD_MODE0_LP_INT_ENA.
	LP_ANA_LP_INT_ENA_BOD_MODE0_LP_INT_ENA = 0x80000000

	// LP_INT_CLR: need_des
	// Position of BOD_MODE0_LP_INT_CLR field.
	LP_ANA_LP_INT_CLR_BOD_MODE0_LP_INT_CLR_Pos = 0x1f
	// Bit mask of BOD_MODE0_LP_INT_CLR field.
	LP_ANA_LP_INT_CLR_BOD_MODE0_LP_INT_CLR_Msk = 0x80000000
	// Bit BOD_MODE0_LP_INT_CLR.
	LP_ANA_LP_INT_CLR_BOD_MODE0_LP_INT_CLR = 0x80000000

	// DATE: need_des
	// Position of LP_ANA_DATE field.
	LP_ANA_DATE_LP_ANA_DATE_Pos = 0x0
	// Bit mask of LP_ANA_DATE field.
	LP_ANA_DATE_LP_ANA_DATE_Msk = 0x7fffffff
	// Position of CLK_EN field.
	LP_ANA_DATE_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	LP_ANA_DATE_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	LP_ANA_DATE_CLK_EN = 0x80000000
)

// Constants for LP_AON: LP_AON Peripheral
const (
	// STORE0: need_des
	// Position of LP_AON_STORE0 field.
	LP_AON_STORE0_LP_AON_STORE0_Pos = 0x0
	// Bit mask of LP_AON_STORE0 field.
	LP_AON_STORE0_LP_AON_STORE0_Msk = 0xffffffff

	// STORE1: need_des
	// Position of LP_AON_STORE1 field.
	LP_AON_STORE1_LP_AON_STORE1_Pos = 0x0
	// Bit mask of LP_AON_STORE1 field.
	LP_AON_STORE1_LP_AON_STORE1_Msk = 0xffffffff

	// STORE2: need_des
	// Position of LP_AON_STORE2 field.
	LP_AON_STORE2_LP_AON_STORE2_Pos = 0x0
	// Bit mask of LP_AON_STORE2 field.
	LP_AON_STORE2_LP_AON_STORE2_Msk = 0xffffffff

	// STORE3: need_des
	// Position of LP_AON_STORE3 field.
	LP_AON_STORE3_LP_AON_STORE3_Pos = 0x0
	// Bit mask of LP_AON_STORE3 field.
	LP_AON_STORE3_LP_AON_STORE3_Msk = 0xffffffff

	// STORE4: need_des
	// Position of LP_AON_STORE4 field.
	LP_AON_STORE4_LP_AON_STORE4_Pos = 0x0
	// Bit mask of LP_AON_STORE4 field.
	LP_AON_STORE4_LP_AON_STORE4_Msk = 0xffffffff

	// STORE5: need_des
	// Position of LP_AON_STORE5 field.
	LP_AON_STORE5_LP_AON_STORE5_Pos = 0x0
	// Bit mask of LP_AON_STORE5 field.
	LP_AON_STORE5_LP_AON_STORE5_Msk = 0xffffffff

	// STORE6: need_des
	// Position of LP_AON_STORE6 field.
	LP_AON_STORE6_LP_AON_STORE6_Pos = 0x0
	// Bit mask of LP_AON_STORE6 field.
	LP_AON_STORE6_LP_AON_STORE6_Msk = 0xffffffff

	// STORE7: need_des
	// Position of LP_AON_STORE7 field.
	LP_AON_STORE7_LP_AON_STORE7_Pos = 0x0
	// Bit mask of LP_AON_STORE7 field.
	LP_AON_STORE7_LP_AON_STORE7_Msk = 0xffffffff

	// STORE8: need_des
	// Position of LP_AON_STORE8 field.
	LP_AON_STORE8_LP_AON_STORE8_Pos = 0x0
	// Bit mask of LP_AON_STORE8 field.
	LP_AON_STORE8_LP_AON_STORE8_Msk = 0xffffffff

	// STORE9: need_des
	// Position of LP_AON_STORE9 field.
	LP_AON_STORE9_LP_AON_STORE9_Pos = 0x0
	// Bit mask of LP_AON_STORE9 field.
	LP_AON_STORE9_LP_AON_STORE9_Msk = 0xffffffff

	// GPIO_MUX: need_des
	// Position of SEL field.
	LP_AON_GPIO_MUX_SEL_Pos = 0x0
	// Bit mask of SEL field.
	LP_AON_GPIO_MUX_SEL_Msk = 0xff

	// GPIO_HOLD0: need_des
	// Position of GPIO_HOLD0 field.
	LP_AON_GPIO_HOLD0_GPIO_HOLD0_Pos = 0x0
	// Bit mask of GPIO_HOLD0 field.
	LP_AON_GPIO_HOLD0_GPIO_HOLD0_Msk = 0xffffffff

	// GPIO_HOLD1: need_des
	// Position of GPIO_HOLD1 field.
	LP_AON_GPIO_HOLD1_GPIO_HOLD1_Pos = 0x0
	// Bit mask of GPIO_HOLD1 field.
	LP_AON_GPIO_HOLD1_GPIO_HOLD1_Msk = 0xffffffff

	// SYS_CFG: need_des
	// Position of ANA_FIB_SWD_ENABLE field.
	LP_AON_SYS_CFG_ANA_FIB_SWD_ENABLE_Pos = 0x0
	// Bit mask of ANA_FIB_SWD_ENABLE field.
	LP_AON_SYS_CFG_ANA_FIB_SWD_ENABLE_Msk = 0x1
	// Bit ANA_FIB_SWD_ENABLE.
	LP_AON_SYS_CFG_ANA_FIB_SWD_ENABLE = 0x1
	// Position of ANA_FIB_CK_GLITCH_ENABLE field.
	LP_AON_SYS_CFG_ANA_FIB_CK_GLITCH_ENABLE_Pos = 0x1
	// Bit mask of ANA_FIB_CK_GLITCH_ENABLE field.
	LP_AON_SYS_CFG_ANA_FIB_CK_GLITCH_ENABLE_Msk = 0x2
	// Bit ANA_FIB_CK_GLITCH_ENABLE.
	LP_AON_SYS_CFG_ANA_FIB_CK_GLITCH_ENABLE = 0x2
	// Position of ANA_FIB_BOD_ENABLE field.
	LP_AON_SYS_CFG_ANA_FIB_BOD_ENABLE_Pos = 0x2
	// Bit mask of ANA_FIB_BOD_ENABLE field.
	LP_AON_SYS_CFG_ANA_FIB_BOD_ENABLE_Msk = 0x4
	// Bit ANA_FIB_BOD_ENABLE.
	LP_AON_SYS_CFG_ANA_FIB_BOD_ENABLE = 0x4
	// Position of FORCE_DOWNLOAD_BOOT field.
	LP_AON_SYS_CFG_FORCE_DOWNLOAD_BOOT_Pos = 0x1e
	// Bit mask of FORCE_DOWNLOAD_BOOT field.
	LP_AON_SYS_CFG_FORCE_DOWNLOAD_BOOT_Msk = 0x40000000
	// Bit FORCE_DOWNLOAD_BOOT.
	LP_AON_SYS_CFG_FORCE_DOWNLOAD_BOOT = 0x40000000
	// Position of HPSYS_SW_RESET field.
	LP_AON_SYS_CFG_HPSYS_SW_RESET_Pos = 0x1f
	// Bit mask of HPSYS_SW_RESET field.
	LP_AON_SYS_CFG_HPSYS_SW_RESET_Msk = 0x80000000
	// Bit HPSYS_SW_RESET.
	LP_AON_SYS_CFG_HPSYS_SW_RESET = 0x80000000

	// CPUCORE0_CFG: need_des
	// Position of CPU_CORE0_SW_STALL field.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_SW_STALL_Pos = 0x0
	// Bit mask of CPU_CORE0_SW_STALL field.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_SW_STALL_Msk = 0xff
	// Position of CPU_CORE0_SW_RESET field.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_SW_RESET_Pos = 0x1c
	// Bit mask of CPU_CORE0_SW_RESET field.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_SW_RESET_Msk = 0x10000000
	// Bit CPU_CORE0_SW_RESET.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_SW_RESET = 0x10000000
	// Position of CPU_CORE0_OCD_HALT_ON_RESET field.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_OCD_HALT_ON_RESET_Pos = 0x1d
	// Bit mask of CPU_CORE0_OCD_HALT_ON_RESET field.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_OCD_HALT_ON_RESET_Msk = 0x20000000
	// Bit CPU_CORE0_OCD_HALT_ON_RESET.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_OCD_HALT_ON_RESET = 0x20000000
	// Position of CPU_CORE0_STAT_VECTOR_SEL field.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_STAT_VECTOR_SEL_Pos = 0x1e
	// Bit mask of CPU_CORE0_STAT_VECTOR_SEL field.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_STAT_VECTOR_SEL_Msk = 0x40000000
	// Bit CPU_CORE0_STAT_VECTOR_SEL.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_STAT_VECTOR_SEL = 0x40000000
	// Position of CPU_CORE0_DRESET_MASK field.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_DRESET_MASK_Pos = 0x1f
	// Bit mask of CPU_CORE0_DRESET_MASK field.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_DRESET_MASK_Msk = 0x80000000
	// Bit CPU_CORE0_DRESET_MASK.
	LP_AON_CPUCORE0_CFG_CPU_CORE0_DRESET_MASK = 0x80000000

	// IO_MUX: need_des
	// Position of PULL_LDO field.
	LP_AON_IO_MUX_PULL_LDO_Pos = 0x1c
	// Bit mask of PULL_LDO field.
	LP_AON_IO_MUX_PULL_LDO_Msk = 0x70000000
	// Position of RESET_DISABLE field.
	LP_AON_IO_MUX_RESET_DISABLE_Pos = 0x1f
	// Bit mask of RESET_DISABLE field.
	LP_AON_IO_MUX_RESET_DISABLE_Msk = 0x80000000
	// Bit RESET_DISABLE.
	LP_AON_IO_MUX_RESET_DISABLE = 0x80000000

	// EXT_WAKEUP_CNTL: need_des
	// Position of EXT_WAKEUP_STATUS field.
	LP_AON_EXT_WAKEUP_CNTL_EXT_WAKEUP_STATUS_Pos = 0x0
	// Bit mask of EXT_WAKEUP_STATUS field.
	LP_AON_EXT_WAKEUP_CNTL_EXT_WAKEUP_STATUS_Msk = 0xff
	// Position of EXT_WAKEUP_STATUS_CLR field.
	LP_AON_EXT_WAKEUP_CNTL_EXT_WAKEUP_STATUS_CLR_Pos = 0xe
	// Bit mask of EXT_WAKEUP_STATUS_CLR field.
	LP_AON_EXT_WAKEUP_CNTL_EXT_WAKEUP_STATUS_CLR_Msk = 0x4000
	// Bit EXT_WAKEUP_STATUS_CLR.
	LP_AON_EXT_WAKEUP_CNTL_EXT_WAKEUP_STATUS_CLR = 0x4000
	// Position of EXT_WAKEUP_SEL field.
	LP_AON_EXT_WAKEUP_CNTL_EXT_WAKEUP_SEL_Pos = 0xf
	// Bit mask of EXT_WAKEUP_SEL field.
	LP_AON_EXT_WAKEUP_CNTL_EXT_WAKEUP_SEL_Msk = 0x7f8000
	// Position of EXT_WAKEUP_LV field.
	LP_AON_EXT_WAKEUP_CNTL_EXT_WAKEUP_LV_Pos = 0x17
	// Bit mask of EXT_WAKEUP_LV field.
	LP_AON_EXT_WAKEUP_CNTL_EXT_WAKEUP_LV_Msk = 0x7f800000
	// Position of EXT_WAKEUP_FILTER field.
	LP_AON_EXT_WAKEUP_CNTL_EXT_WAKEUP_FILTER_Pos = 0x1f
	// Bit mask of EXT_WAKEUP_FILTER field.
	LP_AON_EXT_WAKEUP_CNTL_EXT_WAKEUP_FILTER_Msk = 0x80000000
	// Bit EXT_WAKEUP_FILTER.
	LP_AON_EXT_WAKEUP_CNTL_EXT_WAKEUP_FILTER = 0x80000000

	// USB: need_des
	// Position of RESET_DISABLE field.
	LP_AON_USB_RESET_DISABLE_Pos = 0x1f
	// Bit mask of RESET_DISABLE field.
	LP_AON_USB_RESET_DISABLE_Msk = 0x80000000
	// Bit RESET_DISABLE.
	LP_AON_USB_RESET_DISABLE = 0x80000000

	// LPBUS: need_des
	// Position of FAST_MEM_WPULSE field.
	LP_AON_LPBUS_FAST_MEM_WPULSE_Pos = 0x10
	// Bit mask of FAST_MEM_WPULSE field.
	LP_AON_LPBUS_FAST_MEM_WPULSE_Msk = 0x70000
	// Position of FAST_MEM_WA field.
	LP_AON_LPBUS_FAST_MEM_WA_Pos = 0x13
	// Bit mask of FAST_MEM_WA field.
	LP_AON_LPBUS_FAST_MEM_WA_Msk = 0x380000
	// Position of FAST_MEM_RA field.
	LP_AON_LPBUS_FAST_MEM_RA_Pos = 0x16
	// Bit mask of FAST_MEM_RA field.
	LP_AON_LPBUS_FAST_MEM_RA_Msk = 0xc00000
	// Position of FAST_MEM_RM field.
	LP_AON_LPBUS_FAST_MEM_RM_Pos = 0x18
	// Bit mask of FAST_MEM_RM field.
	LP_AON_LPBUS_FAST_MEM_RM_Msk = 0xf000000
	// Position of FAST_MEM_MUX_FSM_IDLE field.
	LP_AON_LPBUS_FAST_MEM_MUX_FSM_IDLE_Pos = 0x1c
	// Bit mask of FAST_MEM_MUX_FSM_IDLE field.
	LP_AON_LPBUS_FAST_MEM_MUX_FSM_IDLE_Msk = 0x10000000
	// Bit FAST_MEM_MUX_FSM_IDLE.
	LP_AON_LPBUS_FAST_MEM_MUX_FSM_IDLE = 0x10000000
	// Position of FAST_MEM_MUX_SEL_STATUS field.
	LP_AON_LPBUS_FAST_MEM_MUX_SEL_STATUS_Pos = 0x1d
	// Bit mask of FAST_MEM_MUX_SEL_STATUS field.
	LP_AON_LPBUS_FAST_MEM_MUX_SEL_STATUS_Msk = 0x20000000
	// Bit FAST_MEM_MUX_SEL_STATUS.
	LP_AON_LPBUS_FAST_MEM_MUX_SEL_STATUS = 0x20000000
	// Position of FAST_MEM_MUX_SEL_UPDATE field.
	LP_AON_LPBUS_FAST_MEM_MUX_SEL_UPDATE_Pos = 0x1e
	// Bit mask of FAST_MEM_MUX_SEL_UPDATE field.
	LP_AON_LPBUS_FAST_MEM_MUX_SEL_UPDATE_Msk = 0x40000000
	// Bit FAST_MEM_MUX_SEL_UPDATE.
	LP_AON_LPBUS_FAST_MEM_MUX_SEL_UPDATE = 0x40000000
	// Position of FAST_MEM_MUX_SEL field.
	LP_AON_LPBUS_FAST_MEM_MUX_SEL_Pos = 0x1f
	// Bit mask of FAST_MEM_MUX_SEL field.
	LP_AON_LPBUS_FAST_MEM_MUX_SEL_Msk = 0x80000000
	// Bit FAST_MEM_MUX_SEL.
	LP_AON_LPBUS_FAST_MEM_MUX_SEL = 0x80000000

	// SDIO_ACTIVE: need_des
	// Position of SDIO_ACT_DNUM field.
	LP_AON_SDIO_ACTIVE_SDIO_ACT_DNUM_Pos = 0x16
	// Bit mask of SDIO_ACT_DNUM field.
	LP_AON_SDIO_ACTIVE_SDIO_ACT_DNUM_Msk = 0xffc00000

	// LPCORE: need_des
	// Position of ETM_WAKEUP_FLAG_CLR field.
	LP_AON_LPCORE_ETM_WAKEUP_FLAG_CLR_Pos = 0x0
	// Bit mask of ETM_WAKEUP_FLAG_CLR field.
	LP_AON_LPCORE_ETM_WAKEUP_FLAG_CLR_Msk = 0x1
	// Bit ETM_WAKEUP_FLAG_CLR.
	LP_AON_LPCORE_ETM_WAKEUP_FLAG_CLR = 0x1
	// Position of ETM_WAKEUP_FLAG field.
	LP_AON_LPCORE_ETM_WAKEUP_FLAG_Pos = 0x1
	// Bit mask of ETM_WAKEUP_FLAG field.
	LP_AON_LPCORE_ETM_WAKEUP_FLAG_Msk = 0x2
	// Bit ETM_WAKEUP_FLAG.
	LP_AON_LPCORE_ETM_WAKEUP_FLAG = 0x2
	// Position of DISABLE field.
	LP_AON_LPCORE_DISABLE_Pos = 0x1f
	// Bit mask of DISABLE field.
	LP_AON_LPCORE_DISABLE_Msk = 0x80000000
	// Bit DISABLE.
	LP_AON_LPCORE_DISABLE = 0x80000000

	// SAR_CCT: need_des
	// Position of SAR2_PWDET_CCT field.
	LP_AON_SAR_CCT_SAR2_PWDET_CCT_Pos = 0x1d
	// Bit mask of SAR2_PWDET_CCT field.
	LP_AON_SAR_CCT_SAR2_PWDET_CCT_Msk = 0xe0000000

	// JTAG_SEL: need_des
	// Position of SOFT field.
	LP_AON_JTAG_SEL_SOFT_Pos = 0x1f
	// Bit mask of SOFT field.
	LP_AON_JTAG_SEL_SOFT_Msk = 0x80000000
	// Bit SOFT.
	LP_AON_JTAG_SEL_SOFT = 0x80000000

	// DATE: need_des
	// Position of DATE field.
	LP_AON_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	LP_AON_DATE_DATE_Msk = 0x7fffffff
	// Position of CLK_EN field.
	LP_AON_DATE_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	LP_AON_DATE_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	LP_AON_DATE_CLK_EN = 0x80000000
)

// Constants for LP_APM: Low-power Access Permission Management Controller
const (
	// REGION_FILTER_EN: Region filter enable register
	// Position of REGION_FILTER_EN field.
	LP_APM_REGION_FILTER_EN_REGION_FILTER_EN_Pos = 0x0
	// Bit mask of REGION_FILTER_EN field.
	LP_APM_REGION_FILTER_EN_REGION_FILTER_EN_Msk = 0x3

	// REGION0_ADDR_START: Region address register
	// Position of REGION0_ADDR_START field.
	LP_APM_REGION0_ADDR_START_REGION0_ADDR_START_Pos = 0x0
	// Bit mask of REGION0_ADDR_START field.
	LP_APM_REGION0_ADDR_START_REGION0_ADDR_START_Msk = 0xffffffff

	// REGION0_ADDR_END: Region address register
	// Position of REGION0_ADDR_END field.
	LP_APM_REGION0_ADDR_END_REGION0_ADDR_END_Pos = 0x0
	// Bit mask of REGION0_ADDR_END field.
	LP_APM_REGION0_ADDR_END_REGION0_ADDR_END_Msk = 0xffffffff

	// REGION0_PMS_ATTR: Region access authority attribute register
	// Position of REGION0_R0_PMS_X field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION0_R0_PMS_X field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_X_Msk = 0x1
	// Bit REGION0_R0_PMS_X.
	LP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_X = 0x1
	// Position of REGION0_R0_PMS_W field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION0_R0_PMS_W field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_W_Msk = 0x2
	// Bit REGION0_R0_PMS_W.
	LP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_W = 0x2
	// Position of REGION0_R0_PMS_R field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION0_R0_PMS_R field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_R_Msk = 0x4
	// Bit REGION0_R0_PMS_R.
	LP_APM_REGION0_PMS_ATTR_REGION0_R0_PMS_R = 0x4
	// Position of REGION0_R1_PMS_X field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION0_R1_PMS_X field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_X_Msk = 0x10
	// Bit REGION0_R1_PMS_X.
	LP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_X = 0x10
	// Position of REGION0_R1_PMS_W field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION0_R1_PMS_W field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_W_Msk = 0x20
	// Bit REGION0_R1_PMS_W.
	LP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_W = 0x20
	// Position of REGION0_R1_PMS_R field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION0_R1_PMS_R field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_R_Msk = 0x40
	// Bit REGION0_R1_PMS_R.
	LP_APM_REGION0_PMS_ATTR_REGION0_R1_PMS_R = 0x40
	// Position of REGION0_R2_PMS_X field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION0_R2_PMS_X field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_X_Msk = 0x100
	// Bit REGION0_R2_PMS_X.
	LP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_X = 0x100
	// Position of REGION0_R2_PMS_W field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION0_R2_PMS_W field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_W_Msk = 0x200
	// Bit REGION0_R2_PMS_W.
	LP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_W = 0x200
	// Position of REGION0_R2_PMS_R field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION0_R2_PMS_R field.
	LP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_R_Msk = 0x400
	// Bit REGION0_R2_PMS_R.
	LP_APM_REGION0_PMS_ATTR_REGION0_R2_PMS_R = 0x400

	// REGION1_ADDR_START: Region address register
	// Position of REGION1_ADDR_START field.
	LP_APM_REGION1_ADDR_START_REGION1_ADDR_START_Pos = 0x0
	// Bit mask of REGION1_ADDR_START field.
	LP_APM_REGION1_ADDR_START_REGION1_ADDR_START_Msk = 0xffffffff

	// REGION1_ADDR_END: Region address register
	// Position of REGION1_ADDR_END field.
	LP_APM_REGION1_ADDR_END_REGION1_ADDR_END_Pos = 0x0
	// Bit mask of REGION1_ADDR_END field.
	LP_APM_REGION1_ADDR_END_REGION1_ADDR_END_Msk = 0xffffffff

	// REGION1_PMS_ATTR: Region access authority attribute register
	// Position of REGION1_R0_PMS_X field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_X_Pos = 0x0
	// Bit mask of REGION1_R0_PMS_X field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_X_Msk = 0x1
	// Bit REGION1_R0_PMS_X.
	LP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_X = 0x1
	// Position of REGION1_R0_PMS_W field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_W_Pos = 0x1
	// Bit mask of REGION1_R0_PMS_W field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_W_Msk = 0x2
	// Bit REGION1_R0_PMS_W.
	LP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_W = 0x2
	// Position of REGION1_R0_PMS_R field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_R_Pos = 0x2
	// Bit mask of REGION1_R0_PMS_R field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_R_Msk = 0x4
	// Bit REGION1_R0_PMS_R.
	LP_APM_REGION1_PMS_ATTR_REGION1_R0_PMS_R = 0x4
	// Position of REGION1_R1_PMS_X field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_X_Pos = 0x4
	// Bit mask of REGION1_R1_PMS_X field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_X_Msk = 0x10
	// Bit REGION1_R1_PMS_X.
	LP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_X = 0x10
	// Position of REGION1_R1_PMS_W field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_W_Pos = 0x5
	// Bit mask of REGION1_R1_PMS_W field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_W_Msk = 0x20
	// Bit REGION1_R1_PMS_W.
	LP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_W = 0x20
	// Position of REGION1_R1_PMS_R field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_R_Pos = 0x6
	// Bit mask of REGION1_R1_PMS_R field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_R_Msk = 0x40
	// Bit REGION1_R1_PMS_R.
	LP_APM_REGION1_PMS_ATTR_REGION1_R1_PMS_R = 0x40
	// Position of REGION1_R2_PMS_X field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_X_Pos = 0x8
	// Bit mask of REGION1_R2_PMS_X field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_X_Msk = 0x100
	// Bit REGION1_R2_PMS_X.
	LP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_X = 0x100
	// Position of REGION1_R2_PMS_W field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_W_Pos = 0x9
	// Bit mask of REGION1_R2_PMS_W field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_W_Msk = 0x200
	// Bit REGION1_R2_PMS_W.
	LP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_W = 0x200
	// Position of REGION1_R2_PMS_R field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_R_Pos = 0xa
	// Bit mask of REGION1_R2_PMS_R field.
	LP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_R_Msk = 0x400
	// Bit REGION1_R2_PMS_R.
	LP_APM_REGION1_PMS_ATTR_REGION1_R2_PMS_R = 0x400

	// FUNC_CTRL: PMS function control register
	// Position of M0_PMS_FUNC_EN field.
	LP_APM_FUNC_CTRL_M0_PMS_FUNC_EN_Pos = 0x0
	// Bit mask of M0_PMS_FUNC_EN field.
	LP_APM_FUNC_CTRL_M0_PMS_FUNC_EN_Msk = 0x1
	// Bit M0_PMS_FUNC_EN.
	LP_APM_FUNC_CTRL_M0_PMS_FUNC_EN = 0x1

	// M0_STATUS: M0 status register
	// Position of M0_EXCEPTION_STATUS field.
	LP_APM_M0_STATUS_M0_EXCEPTION_STATUS_Pos = 0x0
	// Bit mask of M0_EXCEPTION_STATUS field.
	LP_APM_M0_STATUS_M0_EXCEPTION_STATUS_Msk = 0x3

	// M0_STATUS_CLR: M0 status clear register
	// Position of M0_REGION_STATUS_CLR field.
	LP_APM_M0_STATUS_CLR_M0_REGION_STATUS_CLR_Pos = 0x0
	// Bit mask of M0_REGION_STATUS_CLR field.
	LP_APM_M0_STATUS_CLR_M0_REGION_STATUS_CLR_Msk = 0x1
	// Bit M0_REGION_STATUS_CLR.
	LP_APM_M0_STATUS_CLR_M0_REGION_STATUS_CLR = 0x1

	// M0_EXCEPTION_INFO0: M0 exception_info0 register
	// Position of M0_EXCEPTION_REGION field.
	LP_APM_M0_EXCEPTION_INFO0_M0_EXCEPTION_REGION_Pos = 0x0
	// Bit mask of M0_EXCEPTION_REGION field.
	LP_APM_M0_EXCEPTION_INFO0_M0_EXCEPTION_REGION_Msk = 0x3
	// Position of M0_EXCEPTION_MODE field.
	LP_APM_M0_EXCEPTION_INFO0_M0_EXCEPTION_MODE_Pos = 0x10
	// Bit mask of M0_EXCEPTION_MODE field.
	LP_APM_M0_EXCEPTION_INFO0_M0_EXCEPTION_MODE_Msk = 0x30000
	// Position of M0_EXCEPTION_ID field.
	LP_APM_M0_EXCEPTION_INFO0_M0_EXCEPTION_ID_Pos = 0x12
	// Bit mask of M0_EXCEPTION_ID field.
	LP_APM_M0_EXCEPTION_INFO0_M0_EXCEPTION_ID_Msk = 0x7c0000

	// M0_EXCEPTION_INFO1: M0 exception_info1 register
	// Position of M0_EXCEPTION_ADDR field.
	LP_APM_M0_EXCEPTION_INFO1_M0_EXCEPTION_ADDR_Pos = 0x0
	// Bit mask of M0_EXCEPTION_ADDR field.
	LP_APM_M0_EXCEPTION_INFO1_M0_EXCEPTION_ADDR_Msk = 0xffffffff

	// INT_EN: APM interrupt enable register
	// Position of M0_APM_INT_EN field.
	LP_APM_INT_EN_M0_APM_INT_EN_Pos = 0x0
	// Bit mask of M0_APM_INT_EN field.
	LP_APM_INT_EN_M0_APM_INT_EN_Msk = 0x1
	// Bit M0_APM_INT_EN.
	LP_APM_INT_EN_M0_APM_INT_EN = 0x1

	// CLOCK_GATE: clock gating register
	// Position of CLK_EN field.
	LP_APM_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	LP_APM_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	LP_APM_CLOCK_GATE_CLK_EN = 0x1

	// DATE: Version register
	// Position of DATE field.
	LP_APM_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	LP_APM_DATE_DATE_Msk = 0xfffffff
)

// Constants for LP_CLKRST: LP_CLKRST Peripheral
const (
	// LP_CLK_CONF: need_des
	// Position of SLOW_CLK_SEL field.
	LP_CLKRST_LP_CLK_CONF_SLOW_CLK_SEL_Pos = 0x0
	// Bit mask of SLOW_CLK_SEL field.
	LP_CLKRST_LP_CLK_CONF_SLOW_CLK_SEL_Msk = 0x3
	// Position of FAST_CLK_SEL field.
	LP_CLKRST_LP_CLK_CONF_FAST_CLK_SEL_Pos = 0x2
	// Bit mask of FAST_CLK_SEL field.
	LP_CLKRST_LP_CLK_CONF_FAST_CLK_SEL_Msk = 0xc
	// Position of LP_PERI_DIV_NUM field.
	LP_CLKRST_LP_CLK_CONF_LP_PERI_DIV_NUM_Pos = 0x4
	// Bit mask of LP_PERI_DIV_NUM field.
	LP_CLKRST_LP_CLK_CONF_LP_PERI_DIV_NUM_Msk = 0xff0

	// LP_CLK_PO_EN: need_des
	// Position of AON_SLOW_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_AON_SLOW_OEN_Pos = 0x0
	// Bit mask of AON_SLOW_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_AON_SLOW_OEN_Msk = 0x1
	// Bit AON_SLOW_OEN.
	LP_CLKRST_LP_CLK_PO_EN_AON_SLOW_OEN = 0x1
	// Position of AON_FAST_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_AON_FAST_OEN_Pos = 0x1
	// Bit mask of AON_FAST_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_AON_FAST_OEN_Msk = 0x2
	// Bit AON_FAST_OEN.
	LP_CLKRST_LP_CLK_PO_EN_AON_FAST_OEN = 0x2
	// Position of SOSC_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_SOSC_OEN_Pos = 0x2
	// Bit mask of SOSC_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_SOSC_OEN_Msk = 0x4
	// Bit SOSC_OEN.
	LP_CLKRST_LP_CLK_PO_EN_SOSC_OEN = 0x4
	// Position of FOSC_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_FOSC_OEN_Pos = 0x3
	// Bit mask of FOSC_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_FOSC_OEN_Msk = 0x8
	// Bit FOSC_OEN.
	LP_CLKRST_LP_CLK_PO_EN_FOSC_OEN = 0x8
	// Position of OSC32K_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_OSC32K_OEN_Pos = 0x4
	// Bit mask of OSC32K_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_OSC32K_OEN_Msk = 0x10
	// Bit OSC32K_OEN.
	LP_CLKRST_LP_CLK_PO_EN_OSC32K_OEN = 0x10
	// Position of XTAL32K_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_XTAL32K_OEN_Pos = 0x5
	// Bit mask of XTAL32K_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_XTAL32K_OEN_Msk = 0x20
	// Bit XTAL32K_OEN.
	LP_CLKRST_LP_CLK_PO_EN_XTAL32K_OEN = 0x20
	// Position of CORE_EFUSE_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_CORE_EFUSE_OEN_Pos = 0x6
	// Bit mask of CORE_EFUSE_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_CORE_EFUSE_OEN_Msk = 0x40
	// Bit CORE_EFUSE_OEN.
	LP_CLKRST_LP_CLK_PO_EN_CORE_EFUSE_OEN = 0x40
	// Position of SLOW_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_SLOW_OEN_Pos = 0x7
	// Bit mask of SLOW_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_SLOW_OEN_Msk = 0x80
	// Bit SLOW_OEN.
	LP_CLKRST_LP_CLK_PO_EN_SLOW_OEN = 0x80
	// Position of FAST_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_FAST_OEN_Pos = 0x8
	// Bit mask of FAST_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_FAST_OEN_Msk = 0x100
	// Bit FAST_OEN.
	LP_CLKRST_LP_CLK_PO_EN_FAST_OEN = 0x100
	// Position of RNG_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_RNG_OEN_Pos = 0x9
	// Bit mask of RNG_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_RNG_OEN_Msk = 0x200
	// Bit RNG_OEN.
	LP_CLKRST_LP_CLK_PO_EN_RNG_OEN = 0x200
	// Position of LPBUS_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_LPBUS_OEN_Pos = 0xa
	// Bit mask of LPBUS_OEN field.
	LP_CLKRST_LP_CLK_PO_EN_LPBUS_OEN_Msk = 0x400
	// Bit LPBUS_OEN.
	LP_CLKRST_LP_CLK_PO_EN_LPBUS_OEN = 0x400

	// LP_CLK_EN: need_des
	// Position of FAST_ORI_GATE field.
	LP_CLKRST_LP_CLK_EN_FAST_ORI_GATE_Pos = 0x1f
	// Bit mask of FAST_ORI_GATE field.
	LP_CLKRST_LP_CLK_EN_FAST_ORI_GATE_Msk = 0x80000000
	// Bit FAST_ORI_GATE.
	LP_CLKRST_LP_CLK_EN_FAST_ORI_GATE = 0x80000000

	// LP_RST_EN: need_des
	// Position of AON_EFUSE_CORE_RESET_EN field.
	LP_CLKRST_LP_RST_EN_AON_EFUSE_CORE_RESET_EN_Pos = 0x1c
	// Bit mask of AON_EFUSE_CORE_RESET_EN field.
	LP_CLKRST_LP_RST_EN_AON_EFUSE_CORE_RESET_EN_Msk = 0x10000000
	// Bit AON_EFUSE_CORE_RESET_EN.
	LP_CLKRST_LP_RST_EN_AON_EFUSE_CORE_RESET_EN = 0x10000000
	// Position of LP_TIMER_RESET_EN field.
	LP_CLKRST_LP_RST_EN_LP_TIMER_RESET_EN_Pos = 0x1d
	// Bit mask of LP_TIMER_RESET_EN field.
	LP_CLKRST_LP_RST_EN_LP_TIMER_RESET_EN_Msk = 0x20000000
	// Bit LP_TIMER_RESET_EN.
	LP_CLKRST_LP_RST_EN_LP_TIMER_RESET_EN = 0x20000000
	// Position of WDT_RESET_EN field.
	LP_CLKRST_LP_RST_EN_WDT_RESET_EN_Pos = 0x1e
	// Bit mask of WDT_RESET_EN field.
	LP_CLKRST_LP_RST_EN_WDT_RESET_EN_Msk = 0x40000000
	// Bit WDT_RESET_EN.
	LP_CLKRST_LP_RST_EN_WDT_RESET_EN = 0x40000000
	// Position of ANA_PERI_RESET_EN field.
	LP_CLKRST_LP_RST_EN_ANA_PERI_RESET_EN_Pos = 0x1f
	// Bit mask of ANA_PERI_RESET_EN field.
	LP_CLKRST_LP_RST_EN_ANA_PERI_RESET_EN_Msk = 0x80000000
	// Bit ANA_PERI_RESET_EN.
	LP_CLKRST_LP_RST_EN_ANA_PERI_RESET_EN = 0x80000000

	// RESET_CAUSE: need_des
	// Position of RESET_CAUSE field.
	LP_CLKRST_RESET_CAUSE_RESET_CAUSE_Pos = 0x0
	// Bit mask of RESET_CAUSE field.
	LP_CLKRST_RESET_CAUSE_RESET_CAUSE_Msk = 0x1f
	// Position of CORE0_RESET_FLAG field.
	LP_CLKRST_RESET_CAUSE_CORE0_RESET_FLAG_Pos = 0x5
	// Bit mask of CORE0_RESET_FLAG field.
	LP_CLKRST_RESET_CAUSE_CORE0_RESET_FLAG_Msk = 0x20
	// Bit CORE0_RESET_FLAG.
	LP_CLKRST_RESET_CAUSE_CORE0_RESET_FLAG = 0x20
	// Position of CORE0_RESET_CAUSE_CLR field.
	LP_CLKRST_RESET_CAUSE_CORE0_RESET_CAUSE_CLR_Pos = 0x1d
	// Bit mask of CORE0_RESET_CAUSE_CLR field.
	LP_CLKRST_RESET_CAUSE_CORE0_RESET_CAUSE_CLR_Msk = 0x20000000
	// Bit CORE0_RESET_CAUSE_CLR.
	LP_CLKRST_RESET_CAUSE_CORE0_RESET_CAUSE_CLR = 0x20000000
	// Position of CORE0_RESET_FLAG_SET field.
	LP_CLKRST_RESET_CAUSE_CORE0_RESET_FLAG_SET_Pos = 0x1e
	// Bit mask of CORE0_RESET_FLAG_SET field.
	LP_CLKRST_RESET_CAUSE_CORE0_RESET_FLAG_SET_Msk = 0x40000000
	// Bit CORE0_RESET_FLAG_SET.
	LP_CLKRST_RESET_CAUSE_CORE0_RESET_FLAG_SET = 0x40000000
	// Position of CORE0_RESET_FLAG_CLR field.
	LP_CLKRST_RESET_CAUSE_CORE0_RESET_FLAG_CLR_Pos = 0x1f
	// Bit mask of CORE0_RESET_FLAG_CLR field.
	LP_CLKRST_RESET_CAUSE_CORE0_RESET_FLAG_CLR_Msk = 0x80000000
	// Bit CORE0_RESET_FLAG_CLR.
	LP_CLKRST_RESET_CAUSE_CORE0_RESET_FLAG_CLR = 0x80000000

	// CPU_RESET: need_des
	// Position of RTC_WDT_CPU_RESET_LENGTH field.
	LP_CLKRST_CPU_RESET_RTC_WDT_CPU_RESET_LENGTH_Pos = 0x16
	// Bit mask of RTC_WDT_CPU_RESET_LENGTH field.
	LP_CLKRST_CPU_RESET_RTC_WDT_CPU_RESET_LENGTH_Msk = 0x1c00000
	// Position of RTC_WDT_CPU_RESET_EN field.
	LP_CLKRST_CPU_RESET_RTC_WDT_CPU_RESET_EN_Pos = 0x19
	// Bit mask of RTC_WDT_CPU_RESET_EN field.
	LP_CLKRST_CPU_RESET_RTC_WDT_CPU_RESET_EN_Msk = 0x2000000
	// Bit RTC_WDT_CPU_RESET_EN.
	LP_CLKRST_CPU_RESET_RTC_WDT_CPU_RESET_EN = 0x2000000
	// Position of CPU_STALL_WAIT field.
	LP_CLKRST_CPU_RESET_CPU_STALL_WAIT_Pos = 0x1a
	// Bit mask of CPU_STALL_WAIT field.
	LP_CLKRST_CPU_RESET_CPU_STALL_WAIT_Msk = 0x7c000000
	// Position of CPU_STALL_EN field.
	LP_CLKRST_CPU_RESET_CPU_STALL_EN_Pos = 0x1f
	// Bit mask of CPU_STALL_EN field.
	LP_CLKRST_CPU_RESET_CPU_STALL_EN_Msk = 0x80000000
	// Bit CPU_STALL_EN.
	LP_CLKRST_CPU_RESET_CPU_STALL_EN = 0x80000000

	// FOSC_CNTL: need_des
	// Position of FOSC_DFREQ field.
	LP_CLKRST_FOSC_CNTL_FOSC_DFREQ_Pos = 0x16
	// Bit mask of FOSC_DFREQ field.
	LP_CLKRST_FOSC_CNTL_FOSC_DFREQ_Msk = 0xffc00000

	// RC32K_CNTL: need_des
	// Position of RC32K_DFREQ field.
	LP_CLKRST_RC32K_CNTL_RC32K_DFREQ_Pos = 0x16
	// Bit mask of RC32K_DFREQ field.
	LP_CLKRST_RC32K_CNTL_RC32K_DFREQ_Msk = 0xffc00000

	// CLK_TO_HP: need_des
	// Position of ICG_HP_XTAL32K field.
	LP_CLKRST_CLK_TO_HP_ICG_HP_XTAL32K_Pos = 0x1c
	// Bit mask of ICG_HP_XTAL32K field.
	LP_CLKRST_CLK_TO_HP_ICG_HP_XTAL32K_Msk = 0x10000000
	// Bit ICG_HP_XTAL32K.
	LP_CLKRST_CLK_TO_HP_ICG_HP_XTAL32K = 0x10000000
	// Position of ICG_HP_SOSC field.
	LP_CLKRST_CLK_TO_HP_ICG_HP_SOSC_Pos = 0x1d
	// Bit mask of ICG_HP_SOSC field.
	LP_CLKRST_CLK_TO_HP_ICG_HP_SOSC_Msk = 0x20000000
	// Bit ICG_HP_SOSC.
	LP_CLKRST_CLK_TO_HP_ICG_HP_SOSC = 0x20000000
	// Position of ICG_HP_OSC32K field.
	LP_CLKRST_CLK_TO_HP_ICG_HP_OSC32K_Pos = 0x1e
	// Bit mask of ICG_HP_OSC32K field.
	LP_CLKRST_CLK_TO_HP_ICG_HP_OSC32K_Msk = 0x40000000
	// Bit ICG_HP_OSC32K.
	LP_CLKRST_CLK_TO_HP_ICG_HP_OSC32K = 0x40000000
	// Position of ICG_HP_FOSC field.
	LP_CLKRST_CLK_TO_HP_ICG_HP_FOSC_Pos = 0x1f
	// Bit mask of ICG_HP_FOSC field.
	LP_CLKRST_CLK_TO_HP_ICG_HP_FOSC_Msk = 0x80000000
	// Bit ICG_HP_FOSC.
	LP_CLKRST_CLK_TO_HP_ICG_HP_FOSC = 0x80000000

	// LPMEM_FORCE: need_des
	// Position of LPMEM_CLK_FORCE_ON field.
	LP_CLKRST_LPMEM_FORCE_LPMEM_CLK_FORCE_ON_Pos = 0x1f
	// Bit mask of LPMEM_CLK_FORCE_ON field.
	LP_CLKRST_LPMEM_FORCE_LPMEM_CLK_FORCE_ON_Msk = 0x80000000
	// Bit LPMEM_CLK_FORCE_ON.
	LP_CLKRST_LPMEM_FORCE_LPMEM_CLK_FORCE_ON = 0x80000000

	// LPPERI: need_des
	// Position of LP_BLETIMER_DIV_NUM field.
	LP_CLKRST_LPPERI_LP_BLETIMER_DIV_NUM_Pos = 0xc
	// Bit mask of LP_BLETIMER_DIV_NUM field.
	LP_CLKRST_LPPERI_LP_BLETIMER_DIV_NUM_Msk = 0xfff000
	// Position of LP_BLETIMER_32K_SEL field.
	LP_CLKRST_LPPERI_LP_BLETIMER_32K_SEL_Pos = 0x18
	// Bit mask of LP_BLETIMER_32K_SEL field.
	LP_CLKRST_LPPERI_LP_BLETIMER_32K_SEL_Msk = 0x3000000
	// Position of LP_SEL_OSC_SLOW field.
	LP_CLKRST_LPPERI_LP_SEL_OSC_SLOW_Pos = 0x1a
	// Bit mask of LP_SEL_OSC_SLOW field.
	LP_CLKRST_LPPERI_LP_SEL_OSC_SLOW_Msk = 0x4000000
	// Bit LP_SEL_OSC_SLOW.
	LP_CLKRST_LPPERI_LP_SEL_OSC_SLOW = 0x4000000
	// Position of LP_SEL_OSC_FAST field.
	LP_CLKRST_LPPERI_LP_SEL_OSC_FAST_Pos = 0x1b
	// Bit mask of LP_SEL_OSC_FAST field.
	LP_CLKRST_LPPERI_LP_SEL_OSC_FAST_Msk = 0x8000000
	// Bit LP_SEL_OSC_FAST.
	LP_CLKRST_LPPERI_LP_SEL_OSC_FAST = 0x8000000
	// Position of LP_SEL_XTAL field.
	LP_CLKRST_LPPERI_LP_SEL_XTAL_Pos = 0x1c
	// Bit mask of LP_SEL_XTAL field.
	LP_CLKRST_LPPERI_LP_SEL_XTAL_Msk = 0x10000000
	// Bit LP_SEL_XTAL.
	LP_CLKRST_LPPERI_LP_SEL_XTAL = 0x10000000
	// Position of LP_SEL_XTAL32K field.
	LP_CLKRST_LPPERI_LP_SEL_XTAL32K_Pos = 0x1d
	// Bit mask of LP_SEL_XTAL32K field.
	LP_CLKRST_LPPERI_LP_SEL_XTAL32K_Msk = 0x20000000
	// Bit LP_SEL_XTAL32K.
	LP_CLKRST_LPPERI_LP_SEL_XTAL32K = 0x20000000
	// Position of LP_I2C_CLK_SEL field.
	LP_CLKRST_LPPERI_LP_I2C_CLK_SEL_Pos = 0x1e
	// Bit mask of LP_I2C_CLK_SEL field.
	LP_CLKRST_LPPERI_LP_I2C_CLK_SEL_Msk = 0x40000000
	// Bit LP_I2C_CLK_SEL.
	LP_CLKRST_LPPERI_LP_I2C_CLK_SEL = 0x40000000
	// Position of LP_UART_CLK_SEL field.
	LP_CLKRST_LPPERI_LP_UART_CLK_SEL_Pos = 0x1f
	// Bit mask of LP_UART_CLK_SEL field.
	LP_CLKRST_LPPERI_LP_UART_CLK_SEL_Msk = 0x80000000
	// Bit LP_UART_CLK_SEL.
	LP_CLKRST_LPPERI_LP_UART_CLK_SEL = 0x80000000

	// XTAL32K: need_des
	// Position of DRES_XTAL32K field.
	LP_CLKRST_XTAL32K_DRES_XTAL32K_Pos = 0x16
	// Bit mask of DRES_XTAL32K field.
	LP_CLKRST_XTAL32K_DRES_XTAL32K_Msk = 0x1c00000
	// Position of DGM_XTAL32K field.
	LP_CLKRST_XTAL32K_DGM_XTAL32K_Pos = 0x19
	// Bit mask of DGM_XTAL32K field.
	LP_CLKRST_XTAL32K_DGM_XTAL32K_Msk = 0xe000000
	// Position of DBUF_XTAL32K field.
	LP_CLKRST_XTAL32K_DBUF_XTAL32K_Pos = 0x1c
	// Bit mask of DBUF_XTAL32K field.
	LP_CLKRST_XTAL32K_DBUF_XTAL32K_Msk = 0x10000000
	// Bit DBUF_XTAL32K.
	LP_CLKRST_XTAL32K_DBUF_XTAL32K = 0x10000000
	// Position of DAC_XTAL32K field.
	LP_CLKRST_XTAL32K_DAC_XTAL32K_Pos = 0x1d
	// Bit mask of DAC_XTAL32K field.
	LP_CLKRST_XTAL32K_DAC_XTAL32K_Msk = 0xe0000000

	// DATE: need_des
	// Position of CLKRST_DATE field.
	LP_CLKRST_DATE_CLKRST_DATE_Pos = 0x0
	// Bit mask of CLKRST_DATE field.
	LP_CLKRST_DATE_CLKRST_DATE_Msk = 0x7fffffff
	// Position of CLK_EN field.
	LP_CLKRST_DATE_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	LP_CLKRST_DATE_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	LP_CLKRST_DATE_CLK_EN = 0x80000000
)

// Constants for LP_TIMER: Low-power Timer
const (
	// TAR0_LOW: need_des
	// Position of MAIN_TIMER_TAR_LOW0 field.
	LP_TIMER_TAR0_LOW_MAIN_TIMER_TAR_LOW0_Pos = 0x0
	// Bit mask of MAIN_TIMER_TAR_LOW0 field.
	LP_TIMER_TAR0_LOW_MAIN_TIMER_TAR_LOW0_Msk = 0xffffffff

	// TAR0_HIGH: need_des
	// Position of MAIN_TIMER_TAR_HIGH0 field.
	LP_TIMER_TAR0_HIGH_MAIN_TIMER_TAR_HIGH0_Pos = 0x0
	// Bit mask of MAIN_TIMER_TAR_HIGH0 field.
	LP_TIMER_TAR0_HIGH_MAIN_TIMER_TAR_HIGH0_Msk = 0xffff
	// Position of MAIN_TIMER_TAR_EN0 field.
	LP_TIMER_TAR0_HIGH_MAIN_TIMER_TAR_EN0_Pos = 0x1f
	// Bit mask of MAIN_TIMER_TAR_EN0 field.
	LP_TIMER_TAR0_HIGH_MAIN_TIMER_TAR_EN0_Msk = 0x80000000
	// Bit MAIN_TIMER_TAR_EN0.
	LP_TIMER_TAR0_HIGH_MAIN_TIMER_TAR_EN0 = 0x80000000

	// UPDATE: need_des
	// Position of MAIN_TIMER_UPDATE field.
	LP_TIMER_UPDATE_MAIN_TIMER_UPDATE_Pos = 0x1c
	// Bit mask of MAIN_TIMER_UPDATE field.
	LP_TIMER_UPDATE_MAIN_TIMER_UPDATE_Msk = 0x10000000
	// Bit MAIN_TIMER_UPDATE.
	LP_TIMER_UPDATE_MAIN_TIMER_UPDATE = 0x10000000
	// Position of MAIN_TIMER_XTAL_OFF field.
	LP_TIMER_UPDATE_MAIN_TIMER_XTAL_OFF_Pos = 0x1d
	// Bit mask of MAIN_TIMER_XTAL_OFF field.
	LP_TIMER_UPDATE_MAIN_TIMER_XTAL_OFF_Msk = 0x20000000
	// Bit MAIN_TIMER_XTAL_OFF.
	LP_TIMER_UPDATE_MAIN_TIMER_XTAL_OFF = 0x20000000
	// Position of MAIN_TIMER_SYS_STALL field.
	LP_TIMER_UPDATE_MAIN_TIMER_SYS_STALL_Pos = 0x1e
	// Bit mask of MAIN_TIMER_SYS_STALL field.
	LP_TIMER_UPDATE_MAIN_TIMER_SYS_STALL_Msk = 0x40000000
	// Bit MAIN_TIMER_SYS_STALL.
	LP_TIMER_UPDATE_MAIN_TIMER_SYS_STALL = 0x40000000
	// Position of MAIN_TIMER_SYS_RST field.
	LP_TIMER_UPDATE_MAIN_TIMER_SYS_RST_Pos = 0x1f
	// Bit mask of MAIN_TIMER_SYS_RST field.
	LP_TIMER_UPDATE_MAIN_TIMER_SYS_RST_Msk = 0x80000000
	// Bit MAIN_TIMER_SYS_RST.
	LP_TIMER_UPDATE_MAIN_TIMER_SYS_RST = 0x80000000

	// MAIN_BUF0_LOW: need_des
	// Position of MAIN_TIMER_BUF0_LOW field.
	LP_TIMER_MAIN_BUF0_LOW_MAIN_TIMER_BUF0_LOW_Pos = 0x0
	// Bit mask of MAIN_TIMER_BUF0_LOW field.
	LP_TIMER_MAIN_BUF0_LOW_MAIN_TIMER_BUF0_LOW_Msk = 0xffffffff

	// MAIN_BUF0_HIGH: need_des
	// Position of MAIN_TIMER_BUF0_HIGH field.
	LP_TIMER_MAIN_BUF0_HIGH_MAIN_TIMER_BUF0_HIGH_Pos = 0x0
	// Bit mask of MAIN_TIMER_BUF0_HIGH field.
	LP_TIMER_MAIN_BUF0_HIGH_MAIN_TIMER_BUF0_HIGH_Msk = 0xffff

	// MAIN_BUF1_LOW: need_des
	// Position of MAIN_TIMER_BUF1_LOW field.
	LP_TIMER_MAIN_BUF1_LOW_MAIN_TIMER_BUF1_LOW_Pos = 0x0
	// Bit mask of MAIN_TIMER_BUF1_LOW field.
	LP_TIMER_MAIN_BUF1_LOW_MAIN_TIMER_BUF1_LOW_Msk = 0xffffffff

	// MAIN_BUF1_HIGH: need_des
	// Position of MAIN_TIMER_BUF1_HIGH field.
	LP_TIMER_MAIN_BUF1_HIGH_MAIN_TIMER_BUF1_HIGH_Pos = 0x0
	// Bit mask of MAIN_TIMER_BUF1_HIGH field.
	LP_TIMER_MAIN_BUF1_HIGH_MAIN_TIMER_BUF1_HIGH_Msk = 0xffff

	// MAIN_OVERFLOW: need_des
	// Position of MAIN_TIMER_ALARM_LOAD field.
	LP_TIMER_MAIN_OVERFLOW_MAIN_TIMER_ALARM_LOAD_Pos = 0x1f
	// Bit mask of MAIN_TIMER_ALARM_LOAD field.
	LP_TIMER_MAIN_OVERFLOW_MAIN_TIMER_ALARM_LOAD_Msk = 0x80000000
	// Bit MAIN_TIMER_ALARM_LOAD.
	LP_TIMER_MAIN_OVERFLOW_MAIN_TIMER_ALARM_LOAD = 0x80000000

	// INT_RAW: need_des
	// Position of OVERFLOW_RAW field.
	LP_TIMER_INT_RAW_OVERFLOW_RAW_Pos = 0x1e
	// Bit mask of OVERFLOW_RAW field.
	LP_TIMER_INT_RAW_OVERFLOW_RAW_Msk = 0x40000000
	// Bit OVERFLOW_RAW.
	LP_TIMER_INT_RAW_OVERFLOW_RAW = 0x40000000
	// Position of SOC_WAKEUP_INT_RAW field.
	LP_TIMER_INT_RAW_SOC_WAKEUP_INT_RAW_Pos = 0x1f
	// Bit mask of SOC_WAKEUP_INT_RAW field.
	LP_TIMER_INT_RAW_SOC_WAKEUP_INT_RAW_Msk = 0x80000000
	// Bit SOC_WAKEUP_INT_RAW.
	LP_TIMER_INT_RAW_SOC_WAKEUP_INT_RAW = 0x80000000

	// INT_ST: need_des
	// Position of OVERFLOW_ST field.
	LP_TIMER_INT_ST_OVERFLOW_ST_Pos = 0x1e
	// Bit mask of OVERFLOW_ST field.
	LP_TIMER_INT_ST_OVERFLOW_ST_Msk = 0x40000000
	// Bit OVERFLOW_ST.
	LP_TIMER_INT_ST_OVERFLOW_ST = 0x40000000
	// Position of SOC_WAKEUP_INT_ST field.
	LP_TIMER_INT_ST_SOC_WAKEUP_INT_ST_Pos = 0x1f
	// Bit mask of SOC_WAKEUP_INT_ST field.
	LP_TIMER_INT_ST_SOC_WAKEUP_INT_ST_Msk = 0x80000000
	// Bit SOC_WAKEUP_INT_ST.
	LP_TIMER_INT_ST_SOC_WAKEUP_INT_ST = 0x80000000

	// INT_ENA: need_des
	// Position of OVERFLOW_ENA field.
	LP_TIMER_INT_ENA_OVERFLOW_ENA_Pos = 0x1e
	// Bit mask of OVERFLOW_ENA field.
	LP_TIMER_INT_ENA_OVERFLOW_ENA_Msk = 0x40000000
	// Bit OVERFLOW_ENA.
	LP_TIMER_INT_ENA_OVERFLOW_ENA = 0x40000000
	// Position of SOC_WAKEUP_INT_ENA field.
	LP_TIMER_INT_ENA_SOC_WAKEUP_INT_ENA_Pos = 0x1f
	// Bit mask of SOC_WAKEUP_INT_ENA field.
	LP_TIMER_INT_ENA_SOC_WAKEUP_INT_ENA_Msk = 0x80000000
	// Bit SOC_WAKEUP_INT_ENA.
	LP_TIMER_INT_ENA_SOC_WAKEUP_INT_ENA = 0x80000000

	// INT_CLR: need_des
	// Position of OVERFLOW_CLR field.
	LP_TIMER_INT_CLR_OVERFLOW_CLR_Pos = 0x1e
	// Bit mask of OVERFLOW_CLR field.
	LP_TIMER_INT_CLR_OVERFLOW_CLR_Msk = 0x40000000
	// Bit OVERFLOW_CLR.
	LP_TIMER_INT_CLR_OVERFLOW_CLR = 0x40000000
	// Position of SOC_WAKEUP_INT_CLR field.
	LP_TIMER_INT_CLR_SOC_WAKEUP_INT_CLR_Pos = 0x1f
	// Bit mask of SOC_WAKEUP_INT_CLR field.
	LP_TIMER_INT_CLR_SOC_WAKEUP_INT_CLR_Msk = 0x80000000
	// Bit SOC_WAKEUP_INT_CLR.
	LP_TIMER_INT_CLR_SOC_WAKEUP_INT_CLR = 0x80000000

	// DATE: need_des
	// Position of DATE field.
	LP_TIMER_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	LP_TIMER_DATE_DATE_Msk = 0x7fffffff
	// Position of CLK_EN field.
	LP_TIMER_DATE_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	LP_TIMER_DATE_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	LP_TIMER_DATE_CLK_EN = 0x80000000
)

// Constants for LP_WDT: Low-power Watchdog Timer
const (
	// WDTCONFIG0: need_des
	// Position of WDT_PAUSE_IN_SLP field.
	LP_WDT_WDTCONFIG0_WDT_PAUSE_IN_SLP_Pos = 0x9
	// Bit mask of WDT_PAUSE_IN_SLP field.
	LP_WDT_WDTCONFIG0_WDT_PAUSE_IN_SLP_Msk = 0x200
	// Bit WDT_PAUSE_IN_SLP.
	LP_WDT_WDTCONFIG0_WDT_PAUSE_IN_SLP = 0x200
	// Position of WDT_APPCPU_RESET_EN field.
	LP_WDT_WDTCONFIG0_WDT_APPCPU_RESET_EN_Pos = 0xa
	// Bit mask of WDT_APPCPU_RESET_EN field.
	LP_WDT_WDTCONFIG0_WDT_APPCPU_RESET_EN_Msk = 0x400
	// Bit WDT_APPCPU_RESET_EN.
	LP_WDT_WDTCONFIG0_WDT_APPCPU_RESET_EN = 0x400
	// Position of WDT_PROCPU_RESET_EN field.
	LP_WDT_WDTCONFIG0_WDT_PROCPU_RESET_EN_Pos = 0xb
	// Bit mask of WDT_PROCPU_RESET_EN field.
	LP_WDT_WDTCONFIG0_WDT_PROCPU_RESET_EN_Msk = 0x800
	// Bit WDT_PROCPU_RESET_EN.
	LP_WDT_WDTCONFIG0_WDT_PROCPU_RESET_EN = 0x800
	// Position of WDT_FLASHBOOT_MOD_EN field.
	LP_WDT_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Pos = 0xc
	// Bit mask of WDT_FLASHBOOT_MOD_EN field.
	LP_WDT_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Msk = 0x1000
	// Bit WDT_FLASHBOOT_MOD_EN.
	LP_WDT_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN = 0x1000
	// Position of WDT_SYS_RESET_LENGTH field.
	LP_WDT_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Pos = 0xd
	// Bit mask of WDT_SYS_RESET_LENGTH field.
	LP_WDT_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Msk = 0xe000
	// Position of WDT_CPU_RESET_LENGTH field.
	LP_WDT_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Pos = 0x10
	// Bit mask of WDT_CPU_RESET_LENGTH field.
	LP_WDT_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Msk = 0x70000
	// Position of WDT_STG3 field.
	LP_WDT_WDTCONFIG0_WDT_STG3_Pos = 0x13
	// Bit mask of WDT_STG3 field.
	LP_WDT_WDTCONFIG0_WDT_STG3_Msk = 0x380000
	// Position of WDT_STG2 field.
	LP_WDT_WDTCONFIG0_WDT_STG2_Pos = 0x16
	// Bit mask of WDT_STG2 field.
	LP_WDT_WDTCONFIG0_WDT_STG2_Msk = 0x1c00000
	// Position of WDT_STG1 field.
	LP_WDT_WDTCONFIG0_WDT_STG1_Pos = 0x19
	// Bit mask of WDT_STG1 field.
	LP_WDT_WDTCONFIG0_WDT_STG1_Msk = 0xe000000
	// Position of WDT_STG0 field.
	LP_WDT_WDTCONFIG0_WDT_STG0_Pos = 0x1c
	// Bit mask of WDT_STG0 field.
	LP_WDT_WDTCONFIG0_WDT_STG0_Msk = 0x70000000
	// Position of WDT_EN field.
	LP_WDT_WDTCONFIG0_WDT_EN_Pos = 0x1f
	// Bit mask of WDT_EN field.
	LP_WDT_WDTCONFIG0_WDT_EN_Msk = 0x80000000
	// Bit WDT_EN.
	LP_WDT_WDTCONFIG0_WDT_EN = 0x80000000

	// CONFIG1: need_des
	// Position of WDT_STG0_HOLD field.
	LP_WDT_CONFIG1_WDT_STG0_HOLD_Pos = 0x0
	// Bit mask of WDT_STG0_HOLD field.
	LP_WDT_CONFIG1_WDT_STG0_HOLD_Msk = 0xffffffff

	// CONFIG2: need_des
	// Position of WDT_STG1_HOLD field.
	LP_WDT_CONFIG2_WDT_STG1_HOLD_Pos = 0x0
	// Bit mask of WDT_STG1_HOLD field.
	LP_WDT_CONFIG2_WDT_STG1_HOLD_Msk = 0xffffffff

	// CONFIG3: need_des
	// Position of WDT_STG2_HOLD field.
	LP_WDT_CONFIG3_WDT_STG2_HOLD_Pos = 0x0
	// Bit mask of WDT_STG2_HOLD field.
	LP_WDT_CONFIG3_WDT_STG2_HOLD_Msk = 0xffffffff

	// CONFIG4: need_des
	// Position of WDT_STG3_HOLD field.
	LP_WDT_CONFIG4_WDT_STG3_HOLD_Pos = 0x0
	// Bit mask of WDT_STG3_HOLD field.
	LP_WDT_CONFIG4_WDT_STG3_HOLD_Msk = 0xffffffff

	// CONFIG5: need_des
	// Position of CHIP_RESET_TARGET field.
	LP_WDT_CONFIG5_CHIP_RESET_TARGET_Pos = 0x0
	// Bit mask of CHIP_RESET_TARGET field.
	LP_WDT_CONFIG5_CHIP_RESET_TARGET_Msk = 0xff
	// Position of CHIP_RESET_EN field.
	LP_WDT_CONFIG5_CHIP_RESET_EN_Pos = 0x8
	// Bit mask of CHIP_RESET_EN field.
	LP_WDT_CONFIG5_CHIP_RESET_EN_Msk = 0x100
	// Bit CHIP_RESET_EN.
	LP_WDT_CONFIG5_CHIP_RESET_EN = 0x100
	// Position of CHIP_RESET_KEY field.
	LP_WDT_CONFIG5_CHIP_RESET_KEY_Pos = 0x9
	// Bit mask of CHIP_RESET_KEY field.
	LP_WDT_CONFIG5_CHIP_RESET_KEY_Msk = 0x1fe00

	// WDTFEED: need_des
	// Position of RTC_WDT_FEED field.
	LP_WDT_WDTFEED_RTC_WDT_FEED_Pos = 0x1f
	// Bit mask of RTC_WDT_FEED field.
	LP_WDT_WDTFEED_RTC_WDT_FEED_Msk = 0x80000000
	// Bit RTC_WDT_FEED.
	LP_WDT_WDTFEED_RTC_WDT_FEED = 0x80000000

	// WDTWPROTECT: need_des
	// Position of WDT_WKEY field.
	LP_WDT_WDTWPROTECT_WDT_WKEY_Pos = 0x0
	// Bit mask of WDT_WKEY field.
	LP_WDT_WDTWPROTECT_WDT_WKEY_Msk = 0xffffffff

	// SWD_CONF: need_des
	// Position of SWD_RESET_FLAG field.
	LP_WDT_SWD_CONF_SWD_RESET_FLAG_Pos = 0x0
	// Bit mask of SWD_RESET_FLAG field.
	LP_WDT_SWD_CONF_SWD_RESET_FLAG_Msk = 0x1
	// Bit SWD_RESET_FLAG.
	LP_WDT_SWD_CONF_SWD_RESET_FLAG = 0x1
	// Position of SWD_AUTO_FEED_EN field.
	LP_WDT_SWD_CONF_SWD_AUTO_FEED_EN_Pos = 0x12
	// Bit mask of SWD_AUTO_FEED_EN field.
	LP_WDT_SWD_CONF_SWD_AUTO_FEED_EN_Msk = 0x40000
	// Bit SWD_AUTO_FEED_EN.
	LP_WDT_SWD_CONF_SWD_AUTO_FEED_EN = 0x40000
	// Position of SWD_RST_FLAG_CLR field.
	LP_WDT_SWD_CONF_SWD_RST_FLAG_CLR_Pos = 0x13
	// Bit mask of SWD_RST_FLAG_CLR field.
	LP_WDT_SWD_CONF_SWD_RST_FLAG_CLR_Msk = 0x80000
	// Bit SWD_RST_FLAG_CLR.
	LP_WDT_SWD_CONF_SWD_RST_FLAG_CLR = 0x80000
	// Position of SWD_SIGNAL_WIDTH field.
	LP_WDT_SWD_CONF_SWD_SIGNAL_WIDTH_Pos = 0x14
	// Bit mask of SWD_SIGNAL_WIDTH field.
	LP_WDT_SWD_CONF_SWD_SIGNAL_WIDTH_Msk = 0x3ff00000
	// Position of SWD_DISABLE field.
	LP_WDT_SWD_CONF_SWD_DISABLE_Pos = 0x1e
	// Bit mask of SWD_DISABLE field.
	LP_WDT_SWD_CONF_SWD_DISABLE_Msk = 0x40000000
	// Bit SWD_DISABLE.
	LP_WDT_SWD_CONF_SWD_DISABLE = 0x40000000
	// Position of SWD_FEED field.
	LP_WDT_SWD_CONF_SWD_FEED_Pos = 0x1f
	// Bit mask of SWD_FEED field.
	LP_WDT_SWD_CONF_SWD_FEED_Msk = 0x80000000
	// Bit SWD_FEED.
	LP_WDT_SWD_CONF_SWD_FEED = 0x80000000

	// SWD_WPROTECT: need_des
	// Position of SWD_WKEY field.
	LP_WDT_SWD_WPROTECT_SWD_WKEY_Pos = 0x0
	// Bit mask of SWD_WKEY field.
	LP_WDT_SWD_WPROTECT_SWD_WKEY_Msk = 0xffffffff

	// INT_RAW: need_des
	// Position of SUPER_WDT_INT_RAW field.
	LP_WDT_INT_RAW_SUPER_WDT_INT_RAW_Pos = 0x1e
	// Bit mask of SUPER_WDT_INT_RAW field.
	LP_WDT_INT_RAW_SUPER_WDT_INT_RAW_Msk = 0x40000000
	// Bit SUPER_WDT_INT_RAW.
	LP_WDT_INT_RAW_SUPER_WDT_INT_RAW = 0x40000000
	// Position of LP_WDT_INT_RAW field.
	LP_WDT_INT_RAW_LP_WDT_INT_RAW_Pos = 0x1f
	// Bit mask of LP_WDT_INT_RAW field.
	LP_WDT_INT_RAW_LP_WDT_INT_RAW_Msk = 0x80000000
	// Bit LP_WDT_INT_RAW.
	LP_WDT_INT_RAW_LP_WDT_INT_RAW = 0x80000000

	// INT_ST_RTC: need_des
	// Position of SUPER_WDT_INT_ST field.
	LP_WDT_INT_ST_RTC_SUPER_WDT_INT_ST_Pos = 0x1e
	// Bit mask of SUPER_WDT_INT_ST field.
	LP_WDT_INT_ST_RTC_SUPER_WDT_INT_ST_Msk = 0x40000000
	// Bit SUPER_WDT_INT_ST.
	LP_WDT_INT_ST_RTC_SUPER_WDT_INT_ST = 0x40000000
	// Position of WDT_INT_ST field.
	LP_WDT_INT_ST_RTC_WDT_INT_ST_Pos = 0x1f
	// Bit mask of WDT_INT_ST field.
	LP_WDT_INT_ST_RTC_WDT_INT_ST_Msk = 0x80000000
	// Bit WDT_INT_ST.
	LP_WDT_INT_ST_RTC_WDT_INT_ST = 0x80000000

	// INT_ENA_RTC: need_des
	// Position of SUPER_WDT_INT_ENA field.
	LP_WDT_INT_ENA_RTC_SUPER_WDT_INT_ENA_Pos = 0x1e
	// Bit mask of SUPER_WDT_INT_ENA field.
	LP_WDT_INT_ENA_RTC_SUPER_WDT_INT_ENA_Msk = 0x40000000
	// Bit SUPER_WDT_INT_ENA.
	LP_WDT_INT_ENA_RTC_SUPER_WDT_INT_ENA = 0x40000000
	// Position of WDT_INT_ENA field.
	LP_WDT_INT_ENA_RTC_WDT_INT_ENA_Pos = 0x1f
	// Bit mask of WDT_INT_ENA field.
	LP_WDT_INT_ENA_RTC_WDT_INT_ENA_Msk = 0x80000000
	// Bit WDT_INT_ENA.
	LP_WDT_INT_ENA_RTC_WDT_INT_ENA = 0x80000000

	// INT_CLR_RTC: need_des
	// Position of SUPER_WDT_INT_CLR field.
	LP_WDT_INT_CLR_RTC_SUPER_WDT_INT_CLR_Pos = 0x1e
	// Bit mask of SUPER_WDT_INT_CLR field.
	LP_WDT_INT_CLR_RTC_SUPER_WDT_INT_CLR_Msk = 0x40000000
	// Bit SUPER_WDT_INT_CLR.
	LP_WDT_INT_CLR_RTC_SUPER_WDT_INT_CLR = 0x40000000
	// Position of WDT_INT_CLR field.
	LP_WDT_INT_CLR_RTC_WDT_INT_CLR_Pos = 0x1f
	// Bit mask of WDT_INT_CLR field.
	LP_WDT_INT_CLR_RTC_WDT_INT_CLR_Msk = 0x80000000
	// Bit WDT_INT_CLR.
	LP_WDT_INT_CLR_RTC_WDT_INT_CLR = 0x80000000

	// DATE: need_des
	// Position of LP_WDT_DATE field.
	LP_WDT_DATE_LP_WDT_DATE_Pos = 0x0
	// Bit mask of LP_WDT_DATE field.
	LP_WDT_DATE_LP_WDT_DATE_Msk = 0x7fffffff
	// Position of CLK_EN field.
	LP_WDT_DATE_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	LP_WDT_DATE_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	LP_WDT_DATE_CLK_EN = 0x80000000
)

// Constants for MCPWM0: Motor Control Pulse-Width Modulation 0
const (
	// CLK_CFG: PWM clock prescaler register.
	// Position of CLK_PRESCALE field.
	MCPWM_CLK_CFG_CLK_PRESCALE_Pos = 0x0
	// Bit mask of CLK_PRESCALE field.
	MCPWM_CLK_CFG_CLK_PRESCALE_Msk = 0xff

	// TIMER0_CFG0: PWM timer0 period and update method configuration register.
	// Position of TIMER0_PRESCALE field.
	MCPWM_TIMER0_CFG0_TIMER0_PRESCALE_Pos = 0x0
	// Bit mask of TIMER0_PRESCALE field.
	MCPWM_TIMER0_CFG0_TIMER0_PRESCALE_Msk = 0xff
	// Position of TIMER0_PERIOD field.
	MCPWM_TIMER0_CFG0_TIMER0_PERIOD_Pos = 0x8
	// Bit mask of TIMER0_PERIOD field.
	MCPWM_TIMER0_CFG0_TIMER0_PERIOD_Msk = 0xffff00
	// Position of TIMER0_PERIOD_UPMETHOD field.
	MCPWM_TIMER0_CFG0_TIMER0_PERIOD_UPMETHOD_Pos = 0x18
	// Bit mask of TIMER0_PERIOD_UPMETHOD field.
	MCPWM_TIMER0_CFG0_TIMER0_PERIOD_UPMETHOD_Msk = 0x3000000

	// TIMER0_CFG1: PWM timer0 working mode and start/stop control configuration register.
	// Position of TIMER0_START field.
	MCPWM_TIMER0_CFG1_TIMER0_START_Pos = 0x0
	// Bit mask of TIMER0_START field.
	MCPWM_TIMER0_CFG1_TIMER0_START_Msk = 0x7
	// Position of TIMER0_MOD field.
	MCPWM_TIMER0_CFG1_TIMER0_MOD_Pos = 0x3
	// Bit mask of TIMER0_MOD field.
	MCPWM_TIMER0_CFG1_TIMER0_MOD_Msk = 0x18

	// TIMER0_SYNC: PWM timer0 sync function configuration register.
	// Position of TIMER0_SYNCI_EN field.
	MCPWM_TIMER0_SYNC_TIMER0_SYNCI_EN_Pos = 0x0
	// Bit mask of TIMER0_SYNCI_EN field.
	MCPWM_TIMER0_SYNC_TIMER0_SYNCI_EN_Msk = 0x1
	// Bit TIMER0_SYNCI_EN.
	MCPWM_TIMER0_SYNC_TIMER0_SYNCI_EN = 0x1
	// Position of SW field.
	MCPWM_TIMER0_SYNC_SW_Pos = 0x1
	// Bit mask of SW field.
	MCPWM_TIMER0_SYNC_SW_Msk = 0x2
	// Bit SW.
	MCPWM_TIMER0_SYNC_SW = 0x2
	// Position of TIMER0_SYNCO_SEL field.
	MCPWM_TIMER0_SYNC_TIMER0_SYNCO_SEL_Pos = 0x2
	// Bit mask of TIMER0_SYNCO_SEL field.
	MCPWM_TIMER0_SYNC_TIMER0_SYNCO_SEL_Msk = 0xc
	// Position of TIMER0_PHASE field.
	MCPWM_TIMER0_SYNC_TIMER0_PHASE_Pos = 0x4
	// Bit mask of TIMER0_PHASE field.
	MCPWM_TIMER0_SYNC_TIMER0_PHASE_Msk = 0xffff0
	// Position of TIMER0_PHASE_DIRECTION field.
	MCPWM_TIMER0_SYNC_TIMER0_PHASE_DIRECTION_Pos = 0x14
	// Bit mask of TIMER0_PHASE_DIRECTION field.
	MCPWM_TIMER0_SYNC_TIMER0_PHASE_DIRECTION_Msk = 0x100000
	// Bit TIMER0_PHASE_DIRECTION.
	MCPWM_TIMER0_SYNC_TIMER0_PHASE_DIRECTION = 0x100000

	// TIMER0_STATUS: PWM timer0 status register.
	// Position of TIMER0_VALUE field.
	MCPWM_TIMER0_STATUS_TIMER0_VALUE_Pos = 0x0
	// Bit mask of TIMER0_VALUE field.
	MCPWM_TIMER0_STATUS_TIMER0_VALUE_Msk = 0xffff
	// Position of TIMER0_DIRECTION field.
	MCPWM_TIMER0_STATUS_TIMER0_DIRECTION_Pos = 0x10
	// Bit mask of TIMER0_DIRECTION field.
	MCPWM_TIMER0_STATUS_TIMER0_DIRECTION_Msk = 0x10000
	// Bit TIMER0_DIRECTION.
	MCPWM_TIMER0_STATUS_TIMER0_DIRECTION = 0x10000

	// TIMER1_CFG0: PWM timer1 period and update method configuration register.
	// Position of TIMER1_PRESCALE field.
	MCPWM_TIMER1_CFG0_TIMER1_PRESCALE_Pos = 0x0
	// Bit mask of TIMER1_PRESCALE field.
	MCPWM_TIMER1_CFG0_TIMER1_PRESCALE_Msk = 0xff
	// Position of TIMER1_PERIOD field.
	MCPWM_TIMER1_CFG0_TIMER1_PERIOD_Pos = 0x8
	// Bit mask of TIMER1_PERIOD field.
	MCPWM_TIMER1_CFG0_TIMER1_PERIOD_Msk = 0xffff00
	// Position of TIMER1_PERIOD_UPMETHOD field.
	MCPWM_TIMER1_CFG0_TIMER1_PERIOD_UPMETHOD_Pos = 0x18
	// Bit mask of TIMER1_PERIOD_UPMETHOD field.
	MCPWM_TIMER1_CFG0_TIMER1_PERIOD_UPMETHOD_Msk = 0x3000000

	// TIMER1_CFG1: PWM timer1 working mode and start/stop control configuration register.
	// Position of TIMER1_START field.
	MCPWM_TIMER1_CFG1_TIMER1_START_Pos = 0x0
	// Bit mask of TIMER1_START field.
	MCPWM_TIMER1_CFG1_TIMER1_START_Msk = 0x7
	// Position of TIMER1_MOD field.
	MCPWM_TIMER1_CFG1_TIMER1_MOD_Pos = 0x3
	// Bit mask of TIMER1_MOD field.
	MCPWM_TIMER1_CFG1_TIMER1_MOD_Msk = 0x18

	// TIMER1_SYNC: PWM timer1 sync function configuration register.
	// Position of TIMER1_SYNCI_EN field.
	MCPWM_TIMER1_SYNC_TIMER1_SYNCI_EN_Pos = 0x0
	// Bit mask of TIMER1_SYNCI_EN field.
	MCPWM_TIMER1_SYNC_TIMER1_SYNCI_EN_Msk = 0x1
	// Bit TIMER1_SYNCI_EN.
	MCPWM_TIMER1_SYNC_TIMER1_SYNCI_EN = 0x1
	// Position of SW field.
	MCPWM_TIMER1_SYNC_SW_Pos = 0x1
	// Bit mask of SW field.
	MCPWM_TIMER1_SYNC_SW_Msk = 0x2
	// Bit SW.
	MCPWM_TIMER1_SYNC_SW = 0x2
	// Position of TIMER1_SYNCO_SEL field.
	MCPWM_TIMER1_SYNC_TIMER1_SYNCO_SEL_Pos = 0x2
	// Bit mask of TIMER1_SYNCO_SEL field.
	MCPWM_TIMER1_SYNC_TIMER1_SYNCO_SEL_Msk = 0xc
	// Position of TIMER1_PHASE field.
	MCPWM_TIMER1_SYNC_TIMER1_PHASE_Pos = 0x4
	// Bit mask of TIMER1_PHASE field.
	MCPWM_TIMER1_SYNC_TIMER1_PHASE_Msk = 0xffff0
	// Position of TIMER1_PHASE_DIRECTION field.
	MCPWM_TIMER1_SYNC_TIMER1_PHASE_DIRECTION_Pos = 0x14
	// Bit mask of TIMER1_PHASE_DIRECTION field.
	MCPWM_TIMER1_SYNC_TIMER1_PHASE_DIRECTION_Msk = 0x100000
	// Bit TIMER1_PHASE_DIRECTION.
	MCPWM_TIMER1_SYNC_TIMER1_PHASE_DIRECTION = 0x100000

	// TIMER1_STATUS: PWM timer1 status register.
	// Position of TIMER1_VALUE field.
	MCPWM_TIMER1_STATUS_TIMER1_VALUE_Pos = 0x0
	// Bit mask of TIMER1_VALUE field.
	MCPWM_TIMER1_STATUS_TIMER1_VALUE_Msk = 0xffff
	// Position of TIMER1_DIRECTION field.
	MCPWM_TIMER1_STATUS_TIMER1_DIRECTION_Pos = 0x10
	// Bit mask of TIMER1_DIRECTION field.
	MCPWM_TIMER1_STATUS_TIMER1_DIRECTION_Msk = 0x10000
	// Bit TIMER1_DIRECTION.
	MCPWM_TIMER1_STATUS_TIMER1_DIRECTION = 0x10000

	// TIMER2_CFG0: PWM timer2 period and update method configuration register.
	// Position of TIMER2_PRESCALE field.
	MCPWM_TIMER2_CFG0_TIMER2_PRESCALE_Pos = 0x0
	// Bit mask of TIMER2_PRESCALE field.
	MCPWM_TIMER2_CFG0_TIMER2_PRESCALE_Msk = 0xff
	// Position of TIMER2_PERIOD field.
	MCPWM_TIMER2_CFG0_TIMER2_PERIOD_Pos = 0x8
	// Bit mask of TIMER2_PERIOD field.
	MCPWM_TIMER2_CFG0_TIMER2_PERIOD_Msk = 0xffff00
	// Position of TIMER2_PERIOD_UPMETHOD field.
	MCPWM_TIMER2_CFG0_TIMER2_PERIOD_UPMETHOD_Pos = 0x18
	// Bit mask of TIMER2_PERIOD_UPMETHOD field.
	MCPWM_TIMER2_CFG0_TIMER2_PERIOD_UPMETHOD_Msk = 0x3000000

	// TIMER2_CFG1: PWM timer2 working mode and start/stop control configuration register.
	// Position of TIMER2_START field.
	MCPWM_TIMER2_CFG1_TIMER2_START_Pos = 0x0
	// Bit mask of TIMER2_START field.
	MCPWM_TIMER2_CFG1_TIMER2_START_Msk = 0x7
	// Position of TIMER2_MOD field.
	MCPWM_TIMER2_CFG1_TIMER2_MOD_Pos = 0x3
	// Bit mask of TIMER2_MOD field.
	MCPWM_TIMER2_CFG1_TIMER2_MOD_Msk = 0x18

	// TIMER2_SYNC: PWM timer2 sync function configuration register.
	// Position of TIMER2_SYNCI_EN field.
	MCPWM_TIMER2_SYNC_TIMER2_SYNCI_EN_Pos = 0x0
	// Bit mask of TIMER2_SYNCI_EN field.
	MCPWM_TIMER2_SYNC_TIMER2_SYNCI_EN_Msk = 0x1
	// Bit TIMER2_SYNCI_EN.
	MCPWM_TIMER2_SYNC_TIMER2_SYNCI_EN = 0x1
	// Position of SW field.
	MCPWM_TIMER2_SYNC_SW_Pos = 0x1
	// Bit mask of SW field.
	MCPWM_TIMER2_SYNC_SW_Msk = 0x2
	// Bit SW.
	MCPWM_TIMER2_SYNC_SW = 0x2
	// Position of TIMER2_SYNCO_SEL field.
	MCPWM_TIMER2_SYNC_TIMER2_SYNCO_SEL_Pos = 0x2
	// Bit mask of TIMER2_SYNCO_SEL field.
	MCPWM_TIMER2_SYNC_TIMER2_SYNCO_SEL_Msk = 0xc
	// Position of TIMER2_PHASE field.
	MCPWM_TIMER2_SYNC_TIMER2_PHASE_Pos = 0x4
	// Bit mask of TIMER2_PHASE field.
	MCPWM_TIMER2_SYNC_TIMER2_PHASE_Msk = 0xffff0
	// Position of TIMER2_PHASE_DIRECTION field.
	MCPWM_TIMER2_SYNC_TIMER2_PHASE_DIRECTION_Pos = 0x14
	// Bit mask of TIMER2_PHASE_DIRECTION field.
	MCPWM_TIMER2_SYNC_TIMER2_PHASE_DIRECTION_Msk = 0x100000
	// Bit TIMER2_PHASE_DIRECTION.
	MCPWM_TIMER2_SYNC_TIMER2_PHASE_DIRECTION = 0x100000

	// TIMER2_STATUS: PWM timer2 status register.
	// Position of TIMER2_VALUE field.
	MCPWM_TIMER2_STATUS_TIMER2_VALUE_Pos = 0x0
	// Bit mask of TIMER2_VALUE field.
	MCPWM_TIMER2_STATUS_TIMER2_VALUE_Msk = 0xffff
	// Position of TIMER2_DIRECTION field.
	MCPWM_TIMER2_STATUS_TIMER2_DIRECTION_Pos = 0x10
	// Bit mask of TIMER2_DIRECTION field.
	MCPWM_TIMER2_STATUS_TIMER2_DIRECTION_Msk = 0x10000
	// Bit TIMER2_DIRECTION.
	MCPWM_TIMER2_STATUS_TIMER2_DIRECTION = 0x10000

	// TIMER_SYNCI_CFG: Synchronization input selection for three PWM timers.
	// Position of TIMER0_SYNCISEL field.
	MCPWM_TIMER_SYNCI_CFG_TIMER0_SYNCISEL_Pos = 0x0
	// Bit mask of TIMER0_SYNCISEL field.
	MCPWM_TIMER_SYNCI_CFG_TIMER0_SYNCISEL_Msk = 0x7
	// Position of TIMER1_SYNCISEL field.
	MCPWM_TIMER_SYNCI_CFG_TIMER1_SYNCISEL_Pos = 0x3
	// Bit mask of TIMER1_SYNCISEL field.
	MCPWM_TIMER_SYNCI_CFG_TIMER1_SYNCISEL_Msk = 0x38
	// Position of TIMER2_SYNCISEL field.
	MCPWM_TIMER_SYNCI_CFG_TIMER2_SYNCISEL_Pos = 0x6
	// Bit mask of TIMER2_SYNCISEL field.
	MCPWM_TIMER_SYNCI_CFG_TIMER2_SYNCISEL_Msk = 0x1c0
	// Position of EXTERNAL_SYNCI0_INVERT field.
	MCPWM_TIMER_SYNCI_CFG_EXTERNAL_SYNCI0_INVERT_Pos = 0x9
	// Bit mask of EXTERNAL_SYNCI0_INVERT field.
	MCPWM_TIMER_SYNCI_CFG_EXTERNAL_SYNCI0_INVERT_Msk = 0x200
	// Bit EXTERNAL_SYNCI0_INVERT.
	MCPWM_TIMER_SYNCI_CFG_EXTERNAL_SYNCI0_INVERT = 0x200
	// Position of EXTERNAL_SYNCI1_INVERT field.
	MCPWM_TIMER_SYNCI_CFG_EXTERNAL_SYNCI1_INVERT_Pos = 0xa
	// Bit mask of EXTERNAL_SYNCI1_INVERT field.
	MCPWM_TIMER_SYNCI_CFG_EXTERNAL_SYNCI1_INVERT_Msk = 0x400
	// Bit EXTERNAL_SYNCI1_INVERT.
	MCPWM_TIMER_SYNCI_CFG_EXTERNAL_SYNCI1_INVERT = 0x400
	// Position of EXTERNAL_SYNCI2_INVERT field.
	MCPWM_TIMER_SYNCI_CFG_EXTERNAL_SYNCI2_INVERT_Pos = 0xb
	// Bit mask of EXTERNAL_SYNCI2_INVERT field.
	MCPWM_TIMER_SYNCI_CFG_EXTERNAL_SYNCI2_INVERT_Msk = 0x800
	// Bit EXTERNAL_SYNCI2_INVERT.
	MCPWM_TIMER_SYNCI_CFG_EXTERNAL_SYNCI2_INVERT = 0x800

	// OPERATOR_TIMERSEL: Select specific timer for PWM operators.
	// Position of OPERATOR0_TIMERSEL field.
	MCPWM_OPERATOR_TIMERSEL_OPERATOR0_TIMERSEL_Pos = 0x0
	// Bit mask of OPERATOR0_TIMERSEL field.
	MCPWM_OPERATOR_TIMERSEL_OPERATOR0_TIMERSEL_Msk = 0x3
	// Position of OPERATOR1_TIMERSEL field.
	MCPWM_OPERATOR_TIMERSEL_OPERATOR1_TIMERSEL_Pos = 0x2
	// Bit mask of OPERATOR1_TIMERSEL field.
	MCPWM_OPERATOR_TIMERSEL_OPERATOR1_TIMERSEL_Msk = 0xc
	// Position of OPERATOR2_TIMERSEL field.
	MCPWM_OPERATOR_TIMERSEL_OPERATOR2_TIMERSEL_Pos = 0x4
	// Bit mask of OPERATOR2_TIMERSEL field.
	MCPWM_OPERATOR_TIMERSEL_OPERATOR2_TIMERSEL_Msk = 0x30

	// GEN0_STMP_CFG: Transfer status and update method for time stamp registers A and B
	// Position of CMPR0_A_UPMETHOD field.
	MCPWM_GEN0_STMP_CFG_CMPR0_A_UPMETHOD_Pos = 0x0
	// Bit mask of CMPR0_A_UPMETHOD field.
	MCPWM_GEN0_STMP_CFG_CMPR0_A_UPMETHOD_Msk = 0xf
	// Position of CMPR0_B_UPMETHOD field.
	MCPWM_GEN0_STMP_CFG_CMPR0_B_UPMETHOD_Pos = 0x4
	// Bit mask of CMPR0_B_UPMETHOD field.
	MCPWM_GEN0_STMP_CFG_CMPR0_B_UPMETHOD_Msk = 0xf0
	// Position of CMPR0_A_SHDW_FULL field.
	MCPWM_GEN0_STMP_CFG_CMPR0_A_SHDW_FULL_Pos = 0x8
	// Bit mask of CMPR0_A_SHDW_FULL field.
	MCPWM_GEN0_STMP_CFG_CMPR0_A_SHDW_FULL_Msk = 0x100
	// Bit CMPR0_A_SHDW_FULL.
	MCPWM_GEN0_STMP_CFG_CMPR0_A_SHDW_FULL = 0x100
	// Position of CMPR0_B_SHDW_FULL field.
	MCPWM_GEN0_STMP_CFG_CMPR0_B_SHDW_FULL_Pos = 0x9
	// Bit mask of CMPR0_B_SHDW_FULL field.
	MCPWM_GEN0_STMP_CFG_CMPR0_B_SHDW_FULL_Msk = 0x200
	// Bit CMPR0_B_SHDW_FULL.
	MCPWM_GEN0_STMP_CFG_CMPR0_B_SHDW_FULL = 0x200

	// GEN0_TSTMP_A: Shadow register for register A.
	// Position of CMPR0_A field.
	MCPWM_GEN0_TSTMP_A_CMPR0_A_Pos = 0x0
	// Bit mask of CMPR0_A field.
	MCPWM_GEN0_TSTMP_A_CMPR0_A_Msk = 0xffff

	// GEN0_TSTMP_B: Shadow register for register B.
	// Position of CMPR0_B field.
	MCPWM_GEN0_TSTMP_B_CMPR0_B_Pos = 0x0
	// Bit mask of CMPR0_B field.
	MCPWM_GEN0_TSTMP_B_CMPR0_B_Msk = 0xffff

	// GEN0_CFG0: Fault event T0 and T1 handling
	// Position of GEN0_CFG_UPMETHOD field.
	MCPWM_GEN0_CFG0_GEN0_CFG_UPMETHOD_Pos = 0x0
	// Bit mask of GEN0_CFG_UPMETHOD field.
	MCPWM_GEN0_CFG0_GEN0_CFG_UPMETHOD_Msk = 0xf
	// Position of GEN0_T0_SEL field.
	MCPWM_GEN0_CFG0_GEN0_T0_SEL_Pos = 0x4
	// Bit mask of GEN0_T0_SEL field.
	MCPWM_GEN0_CFG0_GEN0_T0_SEL_Msk = 0x70
	// Position of GEN0_T1_SEL field.
	MCPWM_GEN0_CFG0_GEN0_T1_SEL_Pos = 0x7
	// Bit mask of GEN0_T1_SEL field.
	MCPWM_GEN0_CFG0_GEN0_T1_SEL_Msk = 0x380

	// GEN0_FORCE: Permissives to force PWM0A and PWM0B outputs by software
	// Position of GEN0_CNTUFORCE_UPMETHOD field.
	MCPWM_GEN0_FORCE_GEN0_CNTUFORCE_UPMETHOD_Pos = 0x0
	// Bit mask of GEN0_CNTUFORCE_UPMETHOD field.
	MCPWM_GEN0_FORCE_GEN0_CNTUFORCE_UPMETHOD_Msk = 0x3f
	// Position of GEN0_A_CNTUFORCE_MODE field.
	MCPWM_GEN0_FORCE_GEN0_A_CNTUFORCE_MODE_Pos = 0x6
	// Bit mask of GEN0_A_CNTUFORCE_MODE field.
	MCPWM_GEN0_FORCE_GEN0_A_CNTUFORCE_MODE_Msk = 0xc0
	// Position of GEN0_B_CNTUFORCE_MODE field.
	MCPWM_GEN0_FORCE_GEN0_B_CNTUFORCE_MODE_Pos = 0x8
	// Bit mask of GEN0_B_CNTUFORCE_MODE field.
	MCPWM_GEN0_FORCE_GEN0_B_CNTUFORCE_MODE_Msk = 0x300
	// Position of GEN0_A_NCIFORCE field.
	MCPWM_GEN0_FORCE_GEN0_A_NCIFORCE_Pos = 0xa
	// Bit mask of GEN0_A_NCIFORCE field.
	MCPWM_GEN0_FORCE_GEN0_A_NCIFORCE_Msk = 0x400
	// Bit GEN0_A_NCIFORCE.
	MCPWM_GEN0_FORCE_GEN0_A_NCIFORCE = 0x400
	// Position of GEN0_A_NCIFORCE_MODE field.
	MCPWM_GEN0_FORCE_GEN0_A_NCIFORCE_MODE_Pos = 0xb
	// Bit mask of GEN0_A_NCIFORCE_MODE field.
	MCPWM_GEN0_FORCE_GEN0_A_NCIFORCE_MODE_Msk = 0x1800
	// Position of GEN0_B_NCIFORCE field.
	MCPWM_GEN0_FORCE_GEN0_B_NCIFORCE_Pos = 0xd
	// Bit mask of GEN0_B_NCIFORCE field.
	MCPWM_GEN0_FORCE_GEN0_B_NCIFORCE_Msk = 0x2000
	// Bit GEN0_B_NCIFORCE.
	MCPWM_GEN0_FORCE_GEN0_B_NCIFORCE = 0x2000
	// Position of GEN0_B_NCIFORCE_MODE field.
	MCPWM_GEN0_FORCE_GEN0_B_NCIFORCE_MODE_Pos = 0xe
	// Bit mask of GEN0_B_NCIFORCE_MODE field.
	MCPWM_GEN0_FORCE_GEN0_B_NCIFORCE_MODE_Msk = 0xc000

	// GEN0_A: Actions triggered by events on PWM0A
	// Position of UTEZ field.
	MCPWM_GEN0_A_UTEZ_Pos = 0x0
	// Bit mask of UTEZ field.
	MCPWM_GEN0_A_UTEZ_Msk = 0x3
	// Position of UTEP field.
	MCPWM_GEN0_A_UTEP_Pos = 0x2
	// Bit mask of UTEP field.
	MCPWM_GEN0_A_UTEP_Msk = 0xc
	// Position of UTEA field.
	MCPWM_GEN0_A_UTEA_Pos = 0x4
	// Bit mask of UTEA field.
	MCPWM_GEN0_A_UTEA_Msk = 0x30
	// Position of UTEB field.
	MCPWM_GEN0_A_UTEB_Pos = 0x6
	// Bit mask of UTEB field.
	MCPWM_GEN0_A_UTEB_Msk = 0xc0
	// Position of UT0 field.
	MCPWM_GEN0_A_UT0_Pos = 0x8
	// Bit mask of UT0 field.
	MCPWM_GEN0_A_UT0_Msk = 0x300
	// Position of UT1 field.
	MCPWM_GEN0_A_UT1_Pos = 0xa
	// Bit mask of UT1 field.
	MCPWM_GEN0_A_UT1_Msk = 0xc00
	// Position of DTEZ field.
	MCPWM_GEN0_A_DTEZ_Pos = 0xc
	// Bit mask of DTEZ field.
	MCPWM_GEN0_A_DTEZ_Msk = 0x3000
	// Position of DTEP field.
	MCPWM_GEN0_A_DTEP_Pos = 0xe
	// Bit mask of DTEP field.
	MCPWM_GEN0_A_DTEP_Msk = 0xc000
	// Position of DTEA field.
	MCPWM_GEN0_A_DTEA_Pos = 0x10
	// Bit mask of DTEA field.
	MCPWM_GEN0_A_DTEA_Msk = 0x30000
	// Position of DTEB field.
	MCPWM_GEN0_A_DTEB_Pos = 0x12
	// Bit mask of DTEB field.
	MCPWM_GEN0_A_DTEB_Msk = 0xc0000
	// Position of DT0 field.
	MCPWM_GEN0_A_DT0_Pos = 0x14
	// Bit mask of DT0 field.
	MCPWM_GEN0_A_DT0_Msk = 0x300000
	// Position of DT1 field.
	MCPWM_GEN0_A_DT1_Pos = 0x16
	// Bit mask of DT1 field.
	MCPWM_GEN0_A_DT1_Msk = 0xc00000

	// GEN0_B: Actions triggered by events on PWM0B
	// Position of UTEZ field.
	MCPWM_GEN0_B_UTEZ_Pos = 0x0
	// Bit mask of UTEZ field.
	MCPWM_GEN0_B_UTEZ_Msk = 0x3
	// Position of UTEP field.
	MCPWM_GEN0_B_UTEP_Pos = 0x2
	// Bit mask of UTEP field.
	MCPWM_GEN0_B_UTEP_Msk = 0xc
	// Position of UTEA field.
	MCPWM_GEN0_B_UTEA_Pos = 0x4
	// Bit mask of UTEA field.
	MCPWM_GEN0_B_UTEA_Msk = 0x30
	// Position of UTEB field.
	MCPWM_GEN0_B_UTEB_Pos = 0x6
	// Bit mask of UTEB field.
	MCPWM_GEN0_B_UTEB_Msk = 0xc0
	// Position of UT0 field.
	MCPWM_GEN0_B_UT0_Pos = 0x8
	// Bit mask of UT0 field.
	MCPWM_GEN0_B_UT0_Msk = 0x300
	// Position of UT1 field.
	MCPWM_GEN0_B_UT1_Pos = 0xa
	// Bit mask of UT1 field.
	MCPWM_GEN0_B_UT1_Msk = 0xc00
	// Position of DTEZ field.
	MCPWM_GEN0_B_DTEZ_Pos = 0xc
	// Bit mask of DTEZ field.
	MCPWM_GEN0_B_DTEZ_Msk = 0x3000
	// Position of DTEP field.
	MCPWM_GEN0_B_DTEP_Pos = 0xe
	// Bit mask of DTEP field.
	MCPWM_GEN0_B_DTEP_Msk = 0xc000
	// Position of DTEA field.
	MCPWM_GEN0_B_DTEA_Pos = 0x10
	// Bit mask of DTEA field.
	MCPWM_GEN0_B_DTEA_Msk = 0x30000
	// Position of DTEB field.
	MCPWM_GEN0_B_DTEB_Pos = 0x12
	// Bit mask of DTEB field.
	MCPWM_GEN0_B_DTEB_Msk = 0xc0000
	// Position of DT0 field.
	MCPWM_GEN0_B_DT0_Pos = 0x14
	// Bit mask of DT0 field.
	MCPWM_GEN0_B_DT0_Msk = 0x300000
	// Position of DT1 field.
	MCPWM_GEN0_B_DT1_Pos = 0x16
	// Bit mask of DT1 field.
	MCPWM_GEN0_B_DT1_Msk = 0xc00000

	// DT0_CFG: dead time type selection and configuration
	// Position of DB0_FED_UPMETHOD field.
	MCPWM_DT0_CFG_DB0_FED_UPMETHOD_Pos = 0x0
	// Bit mask of DB0_FED_UPMETHOD field.
	MCPWM_DT0_CFG_DB0_FED_UPMETHOD_Msk = 0xf
	// Position of DB0_RED_UPMETHOD field.
	MCPWM_DT0_CFG_DB0_RED_UPMETHOD_Pos = 0x4
	// Bit mask of DB0_RED_UPMETHOD field.
	MCPWM_DT0_CFG_DB0_RED_UPMETHOD_Msk = 0xf0
	// Position of DB0_DEB_MODE field.
	MCPWM_DT0_CFG_DB0_DEB_MODE_Pos = 0x8
	// Bit mask of DB0_DEB_MODE field.
	MCPWM_DT0_CFG_DB0_DEB_MODE_Msk = 0x100
	// Bit DB0_DEB_MODE.
	MCPWM_DT0_CFG_DB0_DEB_MODE = 0x100
	// Position of DB0_A_OUTSWAP field.
	MCPWM_DT0_CFG_DB0_A_OUTSWAP_Pos = 0x9
	// Bit mask of DB0_A_OUTSWAP field.
	MCPWM_DT0_CFG_DB0_A_OUTSWAP_Msk = 0x200
	// Bit DB0_A_OUTSWAP.
	MCPWM_DT0_CFG_DB0_A_OUTSWAP = 0x200
	// Position of DB0_B_OUTSWAP field.
	MCPWM_DT0_CFG_DB0_B_OUTSWAP_Pos = 0xa
	// Bit mask of DB0_B_OUTSWAP field.
	MCPWM_DT0_CFG_DB0_B_OUTSWAP_Msk = 0x400
	// Bit DB0_B_OUTSWAP.
	MCPWM_DT0_CFG_DB0_B_OUTSWAP = 0x400
	// Position of DB0_RED_INSEL field.
	MCPWM_DT0_CFG_DB0_RED_INSEL_Pos = 0xb
	// Bit mask of DB0_RED_INSEL field.
	MCPWM_DT0_CFG_DB0_RED_INSEL_Msk = 0x800
	// Bit DB0_RED_INSEL.
	MCPWM_DT0_CFG_DB0_RED_INSEL = 0x800
	// Position of DB0_FED_INSEL field.
	MCPWM_DT0_CFG_DB0_FED_INSEL_Pos = 0xc
	// Bit mask of DB0_FED_INSEL field.
	MCPWM_DT0_CFG_DB0_FED_INSEL_Msk = 0x1000
	// Bit DB0_FED_INSEL.
	MCPWM_DT0_CFG_DB0_FED_INSEL = 0x1000
	// Position of DB0_RED_OUTINVERT field.
	MCPWM_DT0_CFG_DB0_RED_OUTINVERT_Pos = 0xd
	// Bit mask of DB0_RED_OUTINVERT field.
	MCPWM_DT0_CFG_DB0_RED_OUTINVERT_Msk = 0x2000
	// Bit DB0_RED_OUTINVERT.
	MCPWM_DT0_CFG_DB0_RED_OUTINVERT = 0x2000
	// Position of DB0_FED_OUTINVERT field.
	MCPWM_DT0_CFG_DB0_FED_OUTINVERT_Pos = 0xe
	// Bit mask of DB0_FED_OUTINVERT field.
	MCPWM_DT0_CFG_DB0_FED_OUTINVERT_Msk = 0x4000
	// Bit DB0_FED_OUTINVERT.
	MCPWM_DT0_CFG_DB0_FED_OUTINVERT = 0x4000
	// Position of DB0_A_OUTBYPASS field.
	MCPWM_DT0_CFG_DB0_A_OUTBYPASS_Pos = 0xf
	// Bit mask of DB0_A_OUTBYPASS field.
	MCPWM_DT0_CFG_DB0_A_OUTBYPASS_Msk = 0x8000
	// Bit DB0_A_OUTBYPASS.
	MCPWM_DT0_CFG_DB0_A_OUTBYPASS = 0x8000
	// Position of DB0_B_OUTBYPASS field.
	MCPWM_DT0_CFG_DB0_B_OUTBYPASS_Pos = 0x10
	// Bit mask of DB0_B_OUTBYPASS field.
	MCPWM_DT0_CFG_DB0_B_OUTBYPASS_Msk = 0x10000
	// Bit DB0_B_OUTBYPASS.
	MCPWM_DT0_CFG_DB0_B_OUTBYPASS = 0x10000
	// Position of DB0_CLK_SEL field.
	MCPWM_DT0_CFG_DB0_CLK_SEL_Pos = 0x11
	// Bit mask of DB0_CLK_SEL field.
	MCPWM_DT0_CFG_DB0_CLK_SEL_Msk = 0x20000
	// Bit DB0_CLK_SEL.
	MCPWM_DT0_CFG_DB0_CLK_SEL = 0x20000

	// DT0_FED_CFG: Shadow register for falling edge delay (FED).
	// Position of DB0_FED field.
	MCPWM_DT0_FED_CFG_DB0_FED_Pos = 0x0
	// Bit mask of DB0_FED field.
	MCPWM_DT0_FED_CFG_DB0_FED_Msk = 0xffff

	// DT0_RED_CFG: Shadow register for rising edge delay (RED).
	// Position of DB0_RED field.
	MCPWM_DT0_RED_CFG_DB0_RED_Pos = 0x0
	// Bit mask of DB0_RED field.
	MCPWM_DT0_RED_CFG_DB0_RED_Msk = 0xffff

	// CARRIER0_CFG: Carrier enable and configuratoin
	// Position of CHOPPER0_EN field.
	MCPWM_CARRIER0_CFG_CHOPPER0_EN_Pos = 0x0
	// Bit mask of CHOPPER0_EN field.
	MCPWM_CARRIER0_CFG_CHOPPER0_EN_Msk = 0x1
	// Bit CHOPPER0_EN.
	MCPWM_CARRIER0_CFG_CHOPPER0_EN = 0x1
	// Position of CHOPPER0_PRESCALE field.
	MCPWM_CARRIER0_CFG_CHOPPER0_PRESCALE_Pos = 0x1
	// Bit mask of CHOPPER0_PRESCALE field.
	MCPWM_CARRIER0_CFG_CHOPPER0_PRESCALE_Msk = 0x1e
	// Position of CHOPPER0_DUTY field.
	MCPWM_CARRIER0_CFG_CHOPPER0_DUTY_Pos = 0x5
	// Bit mask of CHOPPER0_DUTY field.
	MCPWM_CARRIER0_CFG_CHOPPER0_DUTY_Msk = 0xe0
	// Position of CHOPPER0_OSHTWTH field.
	MCPWM_CARRIER0_CFG_CHOPPER0_OSHTWTH_Pos = 0x8
	// Bit mask of CHOPPER0_OSHTWTH field.
	MCPWM_CARRIER0_CFG_CHOPPER0_OSHTWTH_Msk = 0xf00
	// Position of CHOPPER0_OUT_INVERT field.
	MCPWM_CARRIER0_CFG_CHOPPER0_OUT_INVERT_Pos = 0xc
	// Bit mask of CHOPPER0_OUT_INVERT field.
	MCPWM_CARRIER0_CFG_CHOPPER0_OUT_INVERT_Msk = 0x1000
	// Bit CHOPPER0_OUT_INVERT.
	MCPWM_CARRIER0_CFG_CHOPPER0_OUT_INVERT = 0x1000
	// Position of CHOPPER0_IN_INVERT field.
	MCPWM_CARRIER0_CFG_CHOPPER0_IN_INVERT_Pos = 0xd
	// Bit mask of CHOPPER0_IN_INVERT field.
	MCPWM_CARRIER0_CFG_CHOPPER0_IN_INVERT_Msk = 0x2000
	// Bit CHOPPER0_IN_INVERT.
	MCPWM_CARRIER0_CFG_CHOPPER0_IN_INVERT = 0x2000

	// FH0_CFG0: Actions on PWM0A and PWM0B trip events
	// Position of TZ0_SW_CBC field.
	MCPWM_FH0_CFG0_TZ0_SW_CBC_Pos = 0x0
	// Bit mask of TZ0_SW_CBC field.
	MCPWM_FH0_CFG0_TZ0_SW_CBC_Msk = 0x1
	// Bit TZ0_SW_CBC.
	MCPWM_FH0_CFG0_TZ0_SW_CBC = 0x1
	// Position of TZ0_F2_CBC field.
	MCPWM_FH0_CFG0_TZ0_F2_CBC_Pos = 0x1
	// Bit mask of TZ0_F2_CBC field.
	MCPWM_FH0_CFG0_TZ0_F2_CBC_Msk = 0x2
	// Bit TZ0_F2_CBC.
	MCPWM_FH0_CFG0_TZ0_F2_CBC = 0x2
	// Position of TZ0_F1_CBC field.
	MCPWM_FH0_CFG0_TZ0_F1_CBC_Pos = 0x2
	// Bit mask of TZ0_F1_CBC field.
	MCPWM_FH0_CFG0_TZ0_F1_CBC_Msk = 0x4
	// Bit TZ0_F1_CBC.
	MCPWM_FH0_CFG0_TZ0_F1_CBC = 0x4
	// Position of TZ0_F0_CBC field.
	MCPWM_FH0_CFG0_TZ0_F0_CBC_Pos = 0x3
	// Bit mask of TZ0_F0_CBC field.
	MCPWM_FH0_CFG0_TZ0_F0_CBC_Msk = 0x8
	// Bit TZ0_F0_CBC.
	MCPWM_FH0_CFG0_TZ0_F0_CBC = 0x8
	// Position of TZ0_SW_OST field.
	MCPWM_FH0_CFG0_TZ0_SW_OST_Pos = 0x4
	// Bit mask of TZ0_SW_OST field.
	MCPWM_FH0_CFG0_TZ0_SW_OST_Msk = 0x10
	// Bit TZ0_SW_OST.
	MCPWM_FH0_CFG0_TZ0_SW_OST = 0x10
	// Position of TZ0_F2_OST field.
	MCPWM_FH0_CFG0_TZ0_F2_OST_Pos = 0x5
	// Bit mask of TZ0_F2_OST field.
	MCPWM_FH0_CFG0_TZ0_F2_OST_Msk = 0x20
	// Bit TZ0_F2_OST.
	MCPWM_FH0_CFG0_TZ0_F2_OST = 0x20
	// Position of TZ0_F1_OST field.
	MCPWM_FH0_CFG0_TZ0_F1_OST_Pos = 0x6
	// Bit mask of TZ0_F1_OST field.
	MCPWM_FH0_CFG0_TZ0_F1_OST_Msk = 0x40
	// Bit TZ0_F1_OST.
	MCPWM_FH0_CFG0_TZ0_F1_OST = 0x40
	// Position of TZ0_F0_OST field.
	MCPWM_FH0_CFG0_TZ0_F0_OST_Pos = 0x7
	// Bit mask of TZ0_F0_OST field.
	MCPWM_FH0_CFG0_TZ0_F0_OST_Msk = 0x80
	// Bit TZ0_F0_OST.
	MCPWM_FH0_CFG0_TZ0_F0_OST = 0x80
	// Position of TZ0_A_CBC_D field.
	MCPWM_FH0_CFG0_TZ0_A_CBC_D_Pos = 0x8
	// Bit mask of TZ0_A_CBC_D field.
	MCPWM_FH0_CFG0_TZ0_A_CBC_D_Msk = 0x300
	// Position of TZ0_A_CBC_U field.
	MCPWM_FH0_CFG0_TZ0_A_CBC_U_Pos = 0xa
	// Bit mask of TZ0_A_CBC_U field.
	MCPWM_FH0_CFG0_TZ0_A_CBC_U_Msk = 0xc00
	// Position of TZ0_A_OST_D field.
	MCPWM_FH0_CFG0_TZ0_A_OST_D_Pos = 0xc
	// Bit mask of TZ0_A_OST_D field.
	MCPWM_FH0_CFG0_TZ0_A_OST_D_Msk = 0x3000
	// Position of TZ0_A_OST_U field.
	MCPWM_FH0_CFG0_TZ0_A_OST_U_Pos = 0xe
	// Bit mask of TZ0_A_OST_U field.
	MCPWM_FH0_CFG0_TZ0_A_OST_U_Msk = 0xc000
	// Position of TZ0_B_CBC_D field.
	MCPWM_FH0_CFG0_TZ0_B_CBC_D_Pos = 0x10
	// Bit mask of TZ0_B_CBC_D field.
	MCPWM_FH0_CFG0_TZ0_B_CBC_D_Msk = 0x30000
	// Position of TZ0_B_CBC_U field.
	MCPWM_FH0_CFG0_TZ0_B_CBC_U_Pos = 0x12
	// Bit mask of TZ0_B_CBC_U field.
	MCPWM_FH0_CFG0_TZ0_B_CBC_U_Msk = 0xc0000
	// Position of TZ0_B_OST_D field.
	MCPWM_FH0_CFG0_TZ0_B_OST_D_Pos = 0x14
	// Bit mask of TZ0_B_OST_D field.
	MCPWM_FH0_CFG0_TZ0_B_OST_D_Msk = 0x300000
	// Position of TZ0_B_OST_U field.
	MCPWM_FH0_CFG0_TZ0_B_OST_U_Pos = 0x16
	// Bit mask of TZ0_B_OST_U field.
	MCPWM_FH0_CFG0_TZ0_B_OST_U_Msk = 0xc00000

	// FH0_CFG1: Software triggers for fault handler actions
	// Position of TZ0_CLR_OST field.
	MCPWM_FH0_CFG1_TZ0_CLR_OST_Pos = 0x0
	// Bit mask of TZ0_CLR_OST field.
	MCPWM_FH0_CFG1_TZ0_CLR_OST_Msk = 0x1
	// Bit TZ0_CLR_OST.
	MCPWM_FH0_CFG1_TZ0_CLR_OST = 0x1
	// Position of TZ0_CBCPULSE field.
	MCPWM_FH0_CFG1_TZ0_CBCPULSE_Pos = 0x1
	// Bit mask of TZ0_CBCPULSE field.
	MCPWM_FH0_CFG1_TZ0_CBCPULSE_Msk = 0x6
	// Position of TZ0_FORCE_CBC field.
	MCPWM_FH0_CFG1_TZ0_FORCE_CBC_Pos = 0x3
	// Bit mask of TZ0_FORCE_CBC field.
	MCPWM_FH0_CFG1_TZ0_FORCE_CBC_Msk = 0x8
	// Bit TZ0_FORCE_CBC.
	MCPWM_FH0_CFG1_TZ0_FORCE_CBC = 0x8
	// Position of TZ0_FORCE_OST field.
	MCPWM_FH0_CFG1_TZ0_FORCE_OST_Pos = 0x4
	// Bit mask of TZ0_FORCE_OST field.
	MCPWM_FH0_CFG1_TZ0_FORCE_OST_Msk = 0x10
	// Bit TZ0_FORCE_OST.
	MCPWM_FH0_CFG1_TZ0_FORCE_OST = 0x10

	// FH0_STATUS: Status of fault events.
	// Position of TZ0_CBC_ON field.
	MCPWM_FH0_STATUS_TZ0_CBC_ON_Pos = 0x0
	// Bit mask of TZ0_CBC_ON field.
	MCPWM_FH0_STATUS_TZ0_CBC_ON_Msk = 0x1
	// Bit TZ0_CBC_ON.
	MCPWM_FH0_STATUS_TZ0_CBC_ON = 0x1
	// Position of TZ0_OST_ON field.
	MCPWM_FH0_STATUS_TZ0_OST_ON_Pos = 0x1
	// Bit mask of TZ0_OST_ON field.
	MCPWM_FH0_STATUS_TZ0_OST_ON_Msk = 0x2
	// Bit TZ0_OST_ON.
	MCPWM_FH0_STATUS_TZ0_OST_ON = 0x2

	// GEN1_STMP_CFG: Transfer status and update method for time stamp registers A and B
	// Position of CMPR1_A_UPMETHOD field.
	MCPWM_GEN1_STMP_CFG_CMPR1_A_UPMETHOD_Pos = 0x0
	// Bit mask of CMPR1_A_UPMETHOD field.
	MCPWM_GEN1_STMP_CFG_CMPR1_A_UPMETHOD_Msk = 0xf
	// Position of CMPR1_B_UPMETHOD field.
	MCPWM_GEN1_STMP_CFG_CMPR1_B_UPMETHOD_Pos = 0x4
	// Bit mask of CMPR1_B_UPMETHOD field.
	MCPWM_GEN1_STMP_CFG_CMPR1_B_UPMETHOD_Msk = 0xf0
	// Position of CMPR1_A_SHDW_FULL field.
	MCPWM_GEN1_STMP_CFG_CMPR1_A_SHDW_FULL_Pos = 0x8
	// Bit mask of CMPR1_A_SHDW_FULL field.
	MCPWM_GEN1_STMP_CFG_CMPR1_A_SHDW_FULL_Msk = 0x100
	// Bit CMPR1_A_SHDW_FULL.
	MCPWM_GEN1_STMP_CFG_CMPR1_A_SHDW_FULL = 0x100
	// Position of CMPR1_B_SHDW_FULL field.
	MCPWM_GEN1_STMP_CFG_CMPR1_B_SHDW_FULL_Pos = 0x9
	// Bit mask of CMPR1_B_SHDW_FULL field.
	MCPWM_GEN1_STMP_CFG_CMPR1_B_SHDW_FULL_Msk = 0x200
	// Bit CMPR1_B_SHDW_FULL.
	MCPWM_GEN1_STMP_CFG_CMPR1_B_SHDW_FULL = 0x200

	// GEN1_TSTMP_A: Shadow register for register A.
	// Position of CMPR1_A field.
	MCPWM_GEN1_TSTMP_A_CMPR1_A_Pos = 0x0
	// Bit mask of CMPR1_A field.
	MCPWM_GEN1_TSTMP_A_CMPR1_A_Msk = 0xffff

	// GEN1_TSTMP_B: Shadow register for register B.
	// Position of CMPR1_B field.
	MCPWM_GEN1_TSTMP_B_CMPR1_B_Pos = 0x0
	// Bit mask of CMPR1_B field.
	MCPWM_GEN1_TSTMP_B_CMPR1_B_Msk = 0xffff

	// GEN1_CFG0: Fault event T0 and T1 handling
	// Position of GEN1_CFG_UPMETHOD field.
	MCPWM_GEN1_CFG0_GEN1_CFG_UPMETHOD_Pos = 0x0
	// Bit mask of GEN1_CFG_UPMETHOD field.
	MCPWM_GEN1_CFG0_GEN1_CFG_UPMETHOD_Msk = 0xf
	// Position of GEN1_T0_SEL field.
	MCPWM_GEN1_CFG0_GEN1_T0_SEL_Pos = 0x4
	// Bit mask of GEN1_T0_SEL field.
	MCPWM_GEN1_CFG0_GEN1_T0_SEL_Msk = 0x70
	// Position of GEN1_T1_SEL field.
	MCPWM_GEN1_CFG0_GEN1_T1_SEL_Pos = 0x7
	// Bit mask of GEN1_T1_SEL field.
	MCPWM_GEN1_CFG0_GEN1_T1_SEL_Msk = 0x380

	// GEN1_FORCE: Permissives to force PWM1A and PWM1B outputs by software
	// Position of GEN1_CNTUFORCE_UPMETHOD field.
	MCPWM_GEN1_FORCE_GEN1_CNTUFORCE_UPMETHOD_Pos = 0x0
	// Bit mask of GEN1_CNTUFORCE_UPMETHOD field.
	MCPWM_GEN1_FORCE_GEN1_CNTUFORCE_UPMETHOD_Msk = 0x3f
	// Position of GEN1_A_CNTUFORCE_MODE field.
	MCPWM_GEN1_FORCE_GEN1_A_CNTUFORCE_MODE_Pos = 0x6
	// Bit mask of GEN1_A_CNTUFORCE_MODE field.
	MCPWM_GEN1_FORCE_GEN1_A_CNTUFORCE_MODE_Msk = 0xc0
	// Position of GEN1_B_CNTUFORCE_MODE field.
	MCPWM_GEN1_FORCE_GEN1_B_CNTUFORCE_MODE_Pos = 0x8
	// Bit mask of GEN1_B_CNTUFORCE_MODE field.
	MCPWM_GEN1_FORCE_GEN1_B_CNTUFORCE_MODE_Msk = 0x300
	// Position of GEN1_A_NCIFORCE field.
	MCPWM_GEN1_FORCE_GEN1_A_NCIFORCE_Pos = 0xa
	// Bit mask of GEN1_A_NCIFORCE field.
	MCPWM_GEN1_FORCE_GEN1_A_NCIFORCE_Msk = 0x400
	// Bit GEN1_A_NCIFORCE.
	MCPWM_GEN1_FORCE_GEN1_A_NCIFORCE = 0x400
	// Position of GEN1_A_NCIFORCE_MODE field.
	MCPWM_GEN1_FORCE_GEN1_A_NCIFORCE_MODE_Pos = 0xb
	// Bit mask of GEN1_A_NCIFORCE_MODE field.
	MCPWM_GEN1_FORCE_GEN1_A_NCIFORCE_MODE_Msk = 0x1800
	// Position of GEN1_B_NCIFORCE field.
	MCPWM_GEN1_FORCE_GEN1_B_NCIFORCE_Pos = 0xd
	// Bit mask of GEN1_B_NCIFORCE field.
	MCPWM_GEN1_FORCE_GEN1_B_NCIFORCE_Msk = 0x2000
	// Bit GEN1_B_NCIFORCE.
	MCPWM_GEN1_FORCE_GEN1_B_NCIFORCE = 0x2000
	// Position of GEN1_B_NCIFORCE_MODE field.
	MCPWM_GEN1_FORCE_GEN1_B_NCIFORCE_MODE_Pos = 0xe
	// Bit mask of GEN1_B_NCIFORCE_MODE field.
	MCPWM_GEN1_FORCE_GEN1_B_NCIFORCE_MODE_Msk = 0xc000

	// GEN1_A: Actions triggered by events on PWM1A
	// Position of UTEZ field.
	MCPWM_GEN1_A_UTEZ_Pos = 0x0
	// Bit mask of UTEZ field.
	MCPWM_GEN1_A_UTEZ_Msk = 0x3
	// Position of UTEP field.
	MCPWM_GEN1_A_UTEP_Pos = 0x2
	// Bit mask of UTEP field.
	MCPWM_GEN1_A_UTEP_Msk = 0xc
	// Position of UTEA field.
	MCPWM_GEN1_A_UTEA_Pos = 0x4
	// Bit mask of UTEA field.
	MCPWM_GEN1_A_UTEA_Msk = 0x30
	// Position of UTEB field.
	MCPWM_GEN1_A_UTEB_Pos = 0x6
	// Bit mask of UTEB field.
	MCPWM_GEN1_A_UTEB_Msk = 0xc0
	// Position of UT0 field.
	MCPWM_GEN1_A_UT0_Pos = 0x8
	// Bit mask of UT0 field.
	MCPWM_GEN1_A_UT0_Msk = 0x300
	// Position of UT1 field.
	MCPWM_GEN1_A_UT1_Pos = 0xa
	// Bit mask of UT1 field.
	MCPWM_GEN1_A_UT1_Msk = 0xc00
	// Position of DTEZ field.
	MCPWM_GEN1_A_DTEZ_Pos = 0xc
	// Bit mask of DTEZ field.
	MCPWM_GEN1_A_DTEZ_Msk = 0x3000
	// Position of DTEP field.
	MCPWM_GEN1_A_DTEP_Pos = 0xe
	// Bit mask of DTEP field.
	MCPWM_GEN1_A_DTEP_Msk = 0xc000
	// Position of DTEA field.
	MCPWM_GEN1_A_DTEA_Pos = 0x10
	// Bit mask of DTEA field.
	MCPWM_GEN1_A_DTEA_Msk = 0x30000
	// Position of DTEB field.
	MCPWM_GEN1_A_DTEB_Pos = 0x12
	// Bit mask of DTEB field.
	MCPWM_GEN1_A_DTEB_Msk = 0xc0000
	// Position of DT0 field.
	MCPWM_GEN1_A_DT0_Pos = 0x14
	// Bit mask of DT0 field.
	MCPWM_GEN1_A_DT0_Msk = 0x300000
	// Position of DT1 field.
	MCPWM_GEN1_A_DT1_Pos = 0x16
	// Bit mask of DT1 field.
	MCPWM_GEN1_A_DT1_Msk = 0xc00000

	// GEN1_B: Actions triggered by events on PWM1B
	// Position of UTEZ field.
	MCPWM_GEN1_B_UTEZ_Pos = 0x0
	// Bit mask of UTEZ field.
	MCPWM_GEN1_B_UTEZ_Msk = 0x3
	// Position of UTEP field.
	MCPWM_GEN1_B_UTEP_Pos = 0x2
	// Bit mask of UTEP field.
	MCPWM_GEN1_B_UTEP_Msk = 0xc
	// Position of UTEA field.
	MCPWM_GEN1_B_UTEA_Pos = 0x4
	// Bit mask of UTEA field.
	MCPWM_GEN1_B_UTEA_Msk = 0x30
	// Position of UTEB field.
	MCPWM_GEN1_B_UTEB_Pos = 0x6
	// Bit mask of UTEB field.
	MCPWM_GEN1_B_UTEB_Msk = 0xc0
	// Position of UT0 field.
	MCPWM_GEN1_B_UT0_Pos = 0x8
	// Bit mask of UT0 field.
	MCPWM_GEN1_B_UT0_Msk = 0x300
	// Position of UT1 field.
	MCPWM_GEN1_B_UT1_Pos = 0xa
	// Bit mask of UT1 field.
	MCPWM_GEN1_B_UT1_Msk = 0xc00
	// Position of DTEZ field.
	MCPWM_GEN1_B_DTEZ_Pos = 0xc
	// Bit mask of DTEZ field.
	MCPWM_GEN1_B_DTEZ_Msk = 0x3000
	// Position of DTEP field.
	MCPWM_GEN1_B_DTEP_Pos = 0xe
	// Bit mask of DTEP field.
	MCPWM_GEN1_B_DTEP_Msk = 0xc000
	// Position of DTEA field.
	MCPWM_GEN1_B_DTEA_Pos = 0x10
	// Bit mask of DTEA field.
	MCPWM_GEN1_B_DTEA_Msk = 0x30000
	// Position of DTEB field.
	MCPWM_GEN1_B_DTEB_Pos = 0x12
	// Bit mask of DTEB field.
	MCPWM_GEN1_B_DTEB_Msk = 0xc0000
	// Position of DT0 field.
	MCPWM_GEN1_B_DT0_Pos = 0x14
	// Bit mask of DT0 field.
	MCPWM_GEN1_B_DT0_Msk = 0x300000
	// Position of DT1 field.
	MCPWM_GEN1_B_DT1_Pos = 0x16
	// Bit mask of DT1 field.
	MCPWM_GEN1_B_DT1_Msk = 0xc00000

	// DT1_CFG: dead time type selection and configuration
	// Position of DB1_FED_UPMETHOD field.
	MCPWM_DT1_CFG_DB1_FED_UPMETHOD_Pos = 0x0
	// Bit mask of DB1_FED_UPMETHOD field.
	MCPWM_DT1_CFG_DB1_FED_UPMETHOD_Msk = 0xf
	// Position of DB1_RED_UPMETHOD field.
	MCPWM_DT1_CFG_DB1_RED_UPMETHOD_Pos = 0x4
	// Bit mask of DB1_RED_UPMETHOD field.
	MCPWM_DT1_CFG_DB1_RED_UPMETHOD_Msk = 0xf0
	// Position of DB1_DEB_MODE field.
	MCPWM_DT1_CFG_DB1_DEB_MODE_Pos = 0x8
	// Bit mask of DB1_DEB_MODE field.
	MCPWM_DT1_CFG_DB1_DEB_MODE_Msk = 0x100
	// Bit DB1_DEB_MODE.
	MCPWM_DT1_CFG_DB1_DEB_MODE = 0x100
	// Position of DB1_A_OUTSWAP field.
	MCPWM_DT1_CFG_DB1_A_OUTSWAP_Pos = 0x9
	// Bit mask of DB1_A_OUTSWAP field.
	MCPWM_DT1_CFG_DB1_A_OUTSWAP_Msk = 0x200
	// Bit DB1_A_OUTSWAP.
	MCPWM_DT1_CFG_DB1_A_OUTSWAP = 0x200
	// Position of DB1_B_OUTSWAP field.
	MCPWM_DT1_CFG_DB1_B_OUTSWAP_Pos = 0xa
	// Bit mask of DB1_B_OUTSWAP field.
	MCPWM_DT1_CFG_DB1_B_OUTSWAP_Msk = 0x400
	// Bit DB1_B_OUTSWAP.
	MCPWM_DT1_CFG_DB1_B_OUTSWAP = 0x400
	// Position of DB1_RED_INSEL field.
	MCPWM_DT1_CFG_DB1_RED_INSEL_Pos = 0xb
	// Bit mask of DB1_RED_INSEL field.
	MCPWM_DT1_CFG_DB1_RED_INSEL_Msk = 0x800
	// Bit DB1_RED_INSEL.
	MCPWM_DT1_CFG_DB1_RED_INSEL = 0x800
	// Position of DB1_FED_INSEL field.
	MCPWM_DT1_CFG_DB1_FED_INSEL_Pos = 0xc
	// Bit mask of DB1_FED_INSEL field.
	MCPWM_DT1_CFG_DB1_FED_INSEL_Msk = 0x1000
	// Bit DB1_FED_INSEL.
	MCPWM_DT1_CFG_DB1_FED_INSEL = 0x1000
	// Position of DB1_RED_OUTINVERT field.
	MCPWM_DT1_CFG_DB1_RED_OUTINVERT_Pos = 0xd
	// Bit mask of DB1_RED_OUTINVERT field.
	MCPWM_DT1_CFG_DB1_RED_OUTINVERT_Msk = 0x2000
	// Bit DB1_RED_OUTINVERT.
	MCPWM_DT1_CFG_DB1_RED_OUTINVERT = 0x2000
	// Position of DB1_FED_OUTINVERT field.
	MCPWM_DT1_CFG_DB1_FED_OUTINVERT_Pos = 0xe
	// Bit mask of DB1_FED_OUTINVERT field.
	MCPWM_DT1_CFG_DB1_FED_OUTINVERT_Msk = 0x4000
	// Bit DB1_FED_OUTINVERT.
	MCPWM_DT1_CFG_DB1_FED_OUTINVERT = 0x4000
	// Position of DB1_A_OUTBYPASS field.
	MCPWM_DT1_CFG_DB1_A_OUTBYPASS_Pos = 0xf
	// Bit mask of DB1_A_OUTBYPASS field.
	MCPWM_DT1_CFG_DB1_A_OUTBYPASS_Msk = 0x8000
	// Bit DB1_A_OUTBYPASS.
	MCPWM_DT1_CFG_DB1_A_OUTBYPASS = 0x8000
	// Position of DB1_B_OUTBYPASS field.
	MCPWM_DT1_CFG_DB1_B_OUTBYPASS_Pos = 0x10
	// Bit mask of DB1_B_OUTBYPASS field.
	MCPWM_DT1_CFG_DB1_B_OUTBYPASS_Msk = 0x10000
	// Bit DB1_B_OUTBYPASS.
	MCPWM_DT1_CFG_DB1_B_OUTBYPASS = 0x10000
	// Position of DB1_CLK_SEL field.
	MCPWM_DT1_CFG_DB1_CLK_SEL_Pos = 0x11
	// Bit mask of DB1_CLK_SEL field.
	MCPWM_DT1_CFG_DB1_CLK_SEL_Msk = 0x20000
	// Bit DB1_CLK_SEL.
	MCPWM_DT1_CFG_DB1_CLK_SEL = 0x20000

	// DT1_FED_CFG: Shadow register for falling edge delay (FED).
	// Position of DB1_FED field.
	MCPWM_DT1_FED_CFG_DB1_FED_Pos = 0x0
	// Bit mask of DB1_FED field.
	MCPWM_DT1_FED_CFG_DB1_FED_Msk = 0xffff

	// DT1_RED_CFG: Shadow register for rising edge delay (RED).
	// Position of DB1_RED field.
	MCPWM_DT1_RED_CFG_DB1_RED_Pos = 0x0
	// Bit mask of DB1_RED field.
	MCPWM_DT1_RED_CFG_DB1_RED_Msk = 0xffff

	// CARRIER1_CFG: Carrier enable and configuratoin
	// Position of CHOPPER1_EN field.
	MCPWM_CARRIER1_CFG_CHOPPER1_EN_Pos = 0x0
	// Bit mask of CHOPPER1_EN field.
	MCPWM_CARRIER1_CFG_CHOPPER1_EN_Msk = 0x1
	// Bit CHOPPER1_EN.
	MCPWM_CARRIER1_CFG_CHOPPER1_EN = 0x1
	// Position of CHOPPER1_PRESCALE field.
	MCPWM_CARRIER1_CFG_CHOPPER1_PRESCALE_Pos = 0x1
	// Bit mask of CHOPPER1_PRESCALE field.
	MCPWM_CARRIER1_CFG_CHOPPER1_PRESCALE_Msk = 0x1e
	// Position of CHOPPER1_DUTY field.
	MCPWM_CARRIER1_CFG_CHOPPER1_DUTY_Pos = 0x5
	// Bit mask of CHOPPER1_DUTY field.
	MCPWM_CARRIER1_CFG_CHOPPER1_DUTY_Msk = 0xe0
	// Position of CHOPPER1_OSHTWTH field.
	MCPWM_CARRIER1_CFG_CHOPPER1_OSHTWTH_Pos = 0x8
	// Bit mask of CHOPPER1_OSHTWTH field.
	MCPWM_CARRIER1_CFG_CHOPPER1_OSHTWTH_Msk = 0xf00
	// Position of CHOPPER1_OUT_INVERT field.
	MCPWM_CARRIER1_CFG_CHOPPER1_OUT_INVERT_Pos = 0xc
	// Bit mask of CHOPPER1_OUT_INVERT field.
	MCPWM_CARRIER1_CFG_CHOPPER1_OUT_INVERT_Msk = 0x1000
	// Bit CHOPPER1_OUT_INVERT.
	MCPWM_CARRIER1_CFG_CHOPPER1_OUT_INVERT = 0x1000
	// Position of CHOPPER1_IN_INVERT field.
	MCPWM_CARRIER1_CFG_CHOPPER1_IN_INVERT_Pos = 0xd
	// Bit mask of CHOPPER1_IN_INVERT field.
	MCPWM_CARRIER1_CFG_CHOPPER1_IN_INVERT_Msk = 0x2000
	// Bit CHOPPER1_IN_INVERT.
	MCPWM_CARRIER1_CFG_CHOPPER1_IN_INVERT = 0x2000

	// FH1_CFG0: Actions on PWM1A and PWM1B trip events
	// Position of TZ1_SW_CBC field.
	MCPWM_FH1_CFG0_TZ1_SW_CBC_Pos = 0x0
	// Bit mask of TZ1_SW_CBC field.
	MCPWM_FH1_CFG0_TZ1_SW_CBC_Msk = 0x1
	// Bit TZ1_SW_CBC.
	MCPWM_FH1_CFG0_TZ1_SW_CBC = 0x1
	// Position of TZ1_F2_CBC field.
	MCPWM_FH1_CFG0_TZ1_F2_CBC_Pos = 0x1
	// Bit mask of TZ1_F2_CBC field.
	MCPWM_FH1_CFG0_TZ1_F2_CBC_Msk = 0x2
	// Bit TZ1_F2_CBC.
	MCPWM_FH1_CFG0_TZ1_F2_CBC = 0x2
	// Position of TZ1_F1_CBC field.
	MCPWM_FH1_CFG0_TZ1_F1_CBC_Pos = 0x2
	// Bit mask of TZ1_F1_CBC field.
	MCPWM_FH1_CFG0_TZ1_F1_CBC_Msk = 0x4
	// Bit TZ1_F1_CBC.
	MCPWM_FH1_CFG0_TZ1_F1_CBC = 0x4
	// Position of TZ1_F0_CBC field.
	MCPWM_FH1_CFG0_TZ1_F0_CBC_Pos = 0x3
	// Bit mask of TZ1_F0_CBC field.
	MCPWM_FH1_CFG0_TZ1_F0_CBC_Msk = 0x8
	// Bit TZ1_F0_CBC.
	MCPWM_FH1_CFG0_TZ1_F0_CBC = 0x8
	// Position of TZ1_SW_OST field.
	MCPWM_FH1_CFG0_TZ1_SW_OST_Pos = 0x4
	// Bit mask of TZ1_SW_OST field.
	MCPWM_FH1_CFG0_TZ1_SW_OST_Msk = 0x10
	// Bit TZ1_SW_OST.
	MCPWM_FH1_CFG0_TZ1_SW_OST = 0x10
	// Position of TZ1_F2_OST field.
	MCPWM_FH1_CFG0_TZ1_F2_OST_Pos = 0x5
	// Bit mask of TZ1_F2_OST field.
	MCPWM_FH1_CFG0_TZ1_F2_OST_Msk = 0x20
	// Bit TZ1_F2_OST.
	MCPWM_FH1_CFG0_TZ1_F2_OST = 0x20
	// Position of TZ1_F1_OST field.
	MCPWM_FH1_CFG0_TZ1_F1_OST_Pos = 0x6
	// Bit mask of TZ1_F1_OST field.
	MCPWM_FH1_CFG0_TZ1_F1_OST_Msk = 0x40
	// Bit TZ1_F1_OST.
	MCPWM_FH1_CFG0_TZ1_F1_OST = 0x40
	// Position of TZ1_F0_OST field.
	MCPWM_FH1_CFG0_TZ1_F0_OST_Pos = 0x7
	// Bit mask of TZ1_F0_OST field.
	MCPWM_FH1_CFG0_TZ1_F0_OST_Msk = 0x80
	// Bit TZ1_F0_OST.
	MCPWM_FH1_CFG0_TZ1_F0_OST = 0x80
	// Position of TZ1_A_CBC_D field.
	MCPWM_FH1_CFG0_TZ1_A_CBC_D_Pos = 0x8
	// Bit mask of TZ1_A_CBC_D field.
	MCPWM_FH1_CFG0_TZ1_A_CBC_D_Msk = 0x300
	// Position of TZ1_A_CBC_U field.
	MCPWM_FH1_CFG0_TZ1_A_CBC_U_Pos = 0xa
	// Bit mask of TZ1_A_CBC_U field.
	MCPWM_FH1_CFG0_TZ1_A_CBC_U_Msk = 0xc00
	// Position of TZ1_A_OST_D field.
	MCPWM_FH1_CFG0_TZ1_A_OST_D_Pos = 0xc
	// Bit mask of TZ1_A_OST_D field.
	MCPWM_FH1_CFG0_TZ1_A_OST_D_Msk = 0x3000
	// Position of TZ1_A_OST_U field.
	MCPWM_FH1_CFG0_TZ1_A_OST_U_Pos = 0xe
	// Bit mask of TZ1_A_OST_U field.
	MCPWM_FH1_CFG0_TZ1_A_OST_U_Msk = 0xc000
	// Position of TZ1_B_CBC_D field.
	MCPWM_FH1_CFG0_TZ1_B_CBC_D_Pos = 0x10
	// Bit mask of TZ1_B_CBC_D field.
	MCPWM_FH1_CFG0_TZ1_B_CBC_D_Msk = 0x30000
	// Position of TZ1_B_CBC_U field.
	MCPWM_FH1_CFG0_TZ1_B_CBC_U_Pos = 0x12
	// Bit mask of TZ1_B_CBC_U field.
	MCPWM_FH1_CFG0_TZ1_B_CBC_U_Msk = 0xc0000
	// Position of TZ1_B_OST_D field.
	MCPWM_FH1_CFG0_TZ1_B_OST_D_Pos = 0x14
	// Bit mask of TZ1_B_OST_D field.
	MCPWM_FH1_CFG0_TZ1_B_OST_D_Msk = 0x300000
	// Position of TZ1_B_OST_U field.
	MCPWM_FH1_CFG0_TZ1_B_OST_U_Pos = 0x16
	// Bit mask of TZ1_B_OST_U field.
	MCPWM_FH1_CFG0_TZ1_B_OST_U_Msk = 0xc00000

	// FH1_CFG1: Software triggers for fault handler actions
	// Position of TZ1_CLR_OST field.
	MCPWM_FH1_CFG1_TZ1_CLR_OST_Pos = 0x0
	// Bit mask of TZ1_CLR_OST field.
	MCPWM_FH1_CFG1_TZ1_CLR_OST_Msk = 0x1
	// Bit TZ1_CLR_OST.
	MCPWM_FH1_CFG1_TZ1_CLR_OST = 0x1
	// Position of TZ1_CBCPULSE field.
	MCPWM_FH1_CFG1_TZ1_CBCPULSE_Pos = 0x1
	// Bit mask of TZ1_CBCPULSE field.
	MCPWM_FH1_CFG1_TZ1_CBCPULSE_Msk = 0x6
	// Position of TZ1_FORCE_CBC field.
	MCPWM_FH1_CFG1_TZ1_FORCE_CBC_Pos = 0x3
	// Bit mask of TZ1_FORCE_CBC field.
	MCPWM_FH1_CFG1_TZ1_FORCE_CBC_Msk = 0x8
	// Bit TZ1_FORCE_CBC.
	MCPWM_FH1_CFG1_TZ1_FORCE_CBC = 0x8
	// Position of TZ1_FORCE_OST field.
	MCPWM_FH1_CFG1_TZ1_FORCE_OST_Pos = 0x4
	// Bit mask of TZ1_FORCE_OST field.
	MCPWM_FH1_CFG1_TZ1_FORCE_OST_Msk = 0x10
	// Bit TZ1_FORCE_OST.
	MCPWM_FH1_CFG1_TZ1_FORCE_OST = 0x10

	// FH1_STATUS: Status of fault events.
	// Position of TZ1_CBC_ON field.
	MCPWM_FH1_STATUS_TZ1_CBC_ON_Pos = 0x0
	// Bit mask of TZ1_CBC_ON field.
	MCPWM_FH1_STATUS_TZ1_CBC_ON_Msk = 0x1
	// Bit TZ1_CBC_ON.
	MCPWM_FH1_STATUS_TZ1_CBC_ON = 0x1
	// Position of TZ1_OST_ON field.
	MCPWM_FH1_STATUS_TZ1_OST_ON_Pos = 0x1
	// Bit mask of TZ1_OST_ON field.
	MCPWM_FH1_STATUS_TZ1_OST_ON_Msk = 0x2
	// Bit TZ1_OST_ON.
	MCPWM_FH1_STATUS_TZ1_OST_ON = 0x2

	// GEN2_STMP_CFG: Transfer status and update method for time stamp registers A and B
	// Position of CMPR2_A_UPMETHOD field.
	MCPWM_GEN2_STMP_CFG_CMPR2_A_UPMETHOD_Pos = 0x0
	// Bit mask of CMPR2_A_UPMETHOD field.
	MCPWM_GEN2_STMP_CFG_CMPR2_A_UPMETHOD_Msk = 0xf
	// Position of CMPR2_B_UPMETHOD field.
	MCPWM_GEN2_STMP_CFG_CMPR2_B_UPMETHOD_Pos = 0x4
	// Bit mask of CMPR2_B_UPMETHOD field.
	MCPWM_GEN2_STMP_CFG_CMPR2_B_UPMETHOD_Msk = 0xf0
	// Position of CMPR2_A_SHDW_FULL field.
	MCPWM_GEN2_STMP_CFG_CMPR2_A_SHDW_FULL_Pos = 0x8
	// Bit mask of CMPR2_A_SHDW_FULL field.
	MCPWM_GEN2_STMP_CFG_CMPR2_A_SHDW_FULL_Msk = 0x100
	// Bit CMPR2_A_SHDW_FULL.
	MCPWM_GEN2_STMP_CFG_CMPR2_A_SHDW_FULL = 0x100
	// Position of CMPR2_B_SHDW_FULL field.
	MCPWM_GEN2_STMP_CFG_CMPR2_B_SHDW_FULL_Pos = 0x9
	// Bit mask of CMPR2_B_SHDW_FULL field.
	MCPWM_GEN2_STMP_CFG_CMPR2_B_SHDW_FULL_Msk = 0x200
	// Bit CMPR2_B_SHDW_FULL.
	MCPWM_GEN2_STMP_CFG_CMPR2_B_SHDW_FULL = 0x200

	// GEN2_TSTMP_A: Shadow register for register A.
	// Position of CMPR2_A field.
	MCPWM_GEN2_TSTMP_A_CMPR2_A_Pos = 0x0
	// Bit mask of CMPR2_A field.
	MCPWM_GEN2_TSTMP_A_CMPR2_A_Msk = 0xffff

	// GEN2_TSTMP_B: Shadow register for register B.
	// Position of CMPR2_B field.
	MCPWM_GEN2_TSTMP_B_CMPR2_B_Pos = 0x0
	// Bit mask of CMPR2_B field.
	MCPWM_GEN2_TSTMP_B_CMPR2_B_Msk = 0xffff

	// GEN2_CFG0: Fault event T0 and T1 handling
	// Position of GEN2_CFG_UPMETHOD field.
	MCPWM_GEN2_CFG0_GEN2_CFG_UPMETHOD_Pos = 0x0
	// Bit mask of GEN2_CFG_UPMETHOD field.
	MCPWM_GEN2_CFG0_GEN2_CFG_UPMETHOD_Msk = 0xf
	// Position of GEN2_T0_SEL field.
	MCPWM_GEN2_CFG0_GEN2_T0_SEL_Pos = 0x4
	// Bit mask of GEN2_T0_SEL field.
	MCPWM_GEN2_CFG0_GEN2_T0_SEL_Msk = 0x70
	// Position of GEN2_T1_SEL field.
	MCPWM_GEN2_CFG0_GEN2_T1_SEL_Pos = 0x7
	// Bit mask of GEN2_T1_SEL field.
	MCPWM_GEN2_CFG0_GEN2_T1_SEL_Msk = 0x380

	// GEN2_FORCE: Permissives to force PWM2A and PWM2B outputs by software
	// Position of GEN2_CNTUFORCE_UPMETHOD field.
	MCPWM_GEN2_FORCE_GEN2_CNTUFORCE_UPMETHOD_Pos = 0x0
	// Bit mask of GEN2_CNTUFORCE_UPMETHOD field.
	MCPWM_GEN2_FORCE_GEN2_CNTUFORCE_UPMETHOD_Msk = 0x3f
	// Position of GEN2_A_CNTUFORCE_MODE field.
	MCPWM_GEN2_FORCE_GEN2_A_CNTUFORCE_MODE_Pos = 0x6
	// Bit mask of GEN2_A_CNTUFORCE_MODE field.
	MCPWM_GEN2_FORCE_GEN2_A_CNTUFORCE_MODE_Msk = 0xc0
	// Position of GEN2_B_CNTUFORCE_MODE field.
	MCPWM_GEN2_FORCE_GEN2_B_CNTUFORCE_MODE_Pos = 0x8
	// Bit mask of GEN2_B_CNTUFORCE_MODE field.
	MCPWM_GEN2_FORCE_GEN2_B_CNTUFORCE_MODE_Msk = 0x300
	// Position of GEN2_A_NCIFORCE field.
	MCPWM_GEN2_FORCE_GEN2_A_NCIFORCE_Pos = 0xa
	// Bit mask of GEN2_A_NCIFORCE field.
	MCPWM_GEN2_FORCE_GEN2_A_NCIFORCE_Msk = 0x400
	// Bit GEN2_A_NCIFORCE.
	MCPWM_GEN2_FORCE_GEN2_A_NCIFORCE = 0x400
	// Position of GEN2_A_NCIFORCE_MODE field.
	MCPWM_GEN2_FORCE_GEN2_A_NCIFORCE_MODE_Pos = 0xb
	// Bit mask of GEN2_A_NCIFORCE_MODE field.
	MCPWM_GEN2_FORCE_GEN2_A_NCIFORCE_MODE_Msk = 0x1800
	// Position of GEN2_B_NCIFORCE field.
	MCPWM_GEN2_FORCE_GEN2_B_NCIFORCE_Pos = 0xd
	// Bit mask of GEN2_B_NCIFORCE field.
	MCPWM_GEN2_FORCE_GEN2_B_NCIFORCE_Msk = 0x2000
	// Bit GEN2_B_NCIFORCE.
	MCPWM_GEN2_FORCE_GEN2_B_NCIFORCE = 0x2000
	// Position of GEN2_B_NCIFORCE_MODE field.
	MCPWM_GEN2_FORCE_GEN2_B_NCIFORCE_MODE_Pos = 0xe
	// Bit mask of GEN2_B_NCIFORCE_MODE field.
	MCPWM_GEN2_FORCE_GEN2_B_NCIFORCE_MODE_Msk = 0xc000

	// GEN2_A: Actions triggered by events on PWM2A
	// Position of UTEZ field.
	MCPWM_GEN2_A_UTEZ_Pos = 0x0
	// Bit mask of UTEZ field.
	MCPWM_GEN2_A_UTEZ_Msk = 0x3
	// Position of UTEP field.
	MCPWM_GEN2_A_UTEP_Pos = 0x2
	// Bit mask of UTEP field.
	MCPWM_GEN2_A_UTEP_Msk = 0xc
	// Position of UTEA field.
	MCPWM_GEN2_A_UTEA_Pos = 0x4
	// Bit mask of UTEA field.
	MCPWM_GEN2_A_UTEA_Msk = 0x30
	// Position of UTEB field.
	MCPWM_GEN2_A_UTEB_Pos = 0x6
	// Bit mask of UTEB field.
	MCPWM_GEN2_A_UTEB_Msk = 0xc0
	// Position of UT0 field.
	MCPWM_GEN2_A_UT0_Pos = 0x8
	// Bit mask of UT0 field.
	MCPWM_GEN2_A_UT0_Msk = 0x300
	// Position of UT1 field.
	MCPWM_GEN2_A_UT1_Pos = 0xa
	// Bit mask of UT1 field.
	MCPWM_GEN2_A_UT1_Msk = 0xc00
	// Position of DTEZ field.
	MCPWM_GEN2_A_DTEZ_Pos = 0xc
	// Bit mask of DTEZ field.
	MCPWM_GEN2_A_DTEZ_Msk = 0x3000
	// Position of DTEP field.
	MCPWM_GEN2_A_DTEP_Pos = 0xe
	// Bit mask of DTEP field.
	MCPWM_GEN2_A_DTEP_Msk = 0xc000
	// Position of DTEA field.
	MCPWM_GEN2_A_DTEA_Pos = 0x10
	// Bit mask of DTEA field.
	MCPWM_GEN2_A_DTEA_Msk = 0x30000
	// Position of DTEB field.
	MCPWM_GEN2_A_DTEB_Pos = 0x12
	// Bit mask of DTEB field.
	MCPWM_GEN2_A_DTEB_Msk = 0xc0000
	// Position of DT0 field.
	MCPWM_GEN2_A_DT0_Pos = 0x14
	// Bit mask of DT0 field.
	MCPWM_GEN2_A_DT0_Msk = 0x300000
	// Position of DT1 field.
	MCPWM_GEN2_A_DT1_Pos = 0x16
	// Bit mask of DT1 field.
	MCPWM_GEN2_A_DT1_Msk = 0xc00000

	// GEN2_B: Actions triggered by events on PWM2B
	// Position of UTEZ field.
	MCPWM_GEN2_B_UTEZ_Pos = 0x0
	// Bit mask of UTEZ field.
	MCPWM_GEN2_B_UTEZ_Msk = 0x3
	// Position of UTEP field.
	MCPWM_GEN2_B_UTEP_Pos = 0x2
	// Bit mask of UTEP field.
	MCPWM_GEN2_B_UTEP_Msk = 0xc
	// Position of UTEA field.
	MCPWM_GEN2_B_UTEA_Pos = 0x4
	// Bit mask of UTEA field.
	MCPWM_GEN2_B_UTEA_Msk = 0x30
	// Position of UTEB field.
	MCPWM_GEN2_B_UTEB_Pos = 0x6
	// Bit mask of UTEB field.
	MCPWM_GEN2_B_UTEB_Msk = 0xc0
	// Position of UT0 field.
	MCPWM_GEN2_B_UT0_Pos = 0x8
	// Bit mask of UT0 field.
	MCPWM_GEN2_B_UT0_Msk = 0x300
	// Position of UT1 field.
	MCPWM_GEN2_B_UT1_Pos = 0xa
	// Bit mask of UT1 field.
	MCPWM_GEN2_B_UT1_Msk = 0xc00
	// Position of DTEZ field.
	MCPWM_GEN2_B_DTEZ_Pos = 0xc
	// Bit mask of DTEZ field.
	MCPWM_GEN2_B_DTEZ_Msk = 0x3000
	// Position of DTEP field.
	MCPWM_GEN2_B_DTEP_Pos = 0xe
	// Bit mask of DTEP field.
	MCPWM_GEN2_B_DTEP_Msk = 0xc000
	// Position of DTEA field.
	MCPWM_GEN2_B_DTEA_Pos = 0x10
	// Bit mask of DTEA field.
	MCPWM_GEN2_B_DTEA_Msk = 0x30000
	// Position of DTEB field.
	MCPWM_GEN2_B_DTEB_Pos = 0x12
	// Bit mask of DTEB field.
	MCPWM_GEN2_B_DTEB_Msk = 0xc0000
	// Position of DT0 field.
	MCPWM_GEN2_B_DT0_Pos = 0x14
	// Bit mask of DT0 field.
	MCPWM_GEN2_B_DT0_Msk = 0x300000
	// Position of DT1 field.
	MCPWM_GEN2_B_DT1_Pos = 0x16
	// Bit mask of DT1 field.
	MCPWM_GEN2_B_DT1_Msk = 0xc00000

	// DT2_CFG: dead time type selection and configuration
	// Position of DB2_FED_UPMETHOD field.
	MCPWM_DT2_CFG_DB2_FED_UPMETHOD_Pos = 0x0
	// Bit mask of DB2_FED_UPMETHOD field.
	MCPWM_DT2_CFG_DB2_FED_UPMETHOD_Msk = 0xf
	// Position of DB2_RED_UPMETHOD field.
	MCPWM_DT2_CFG_DB2_RED_UPMETHOD_Pos = 0x4
	// Bit mask of DB2_RED_UPMETHOD field.
	MCPWM_DT2_CFG_DB2_RED_UPMETHOD_Msk = 0xf0
	// Position of DB2_DEB_MODE field.
	MCPWM_DT2_CFG_DB2_DEB_MODE_Pos = 0x8
	// Bit mask of DB2_DEB_MODE field.
	MCPWM_DT2_CFG_DB2_DEB_MODE_Msk = 0x100
	// Bit DB2_DEB_MODE.
	MCPWM_DT2_CFG_DB2_DEB_MODE = 0x100
	// Position of DB2_A_OUTSWAP field.
	MCPWM_DT2_CFG_DB2_A_OUTSWAP_Pos = 0x9
	// Bit mask of DB2_A_OUTSWAP field.
	MCPWM_DT2_CFG_DB2_A_OUTSWAP_Msk = 0x200
	// Bit DB2_A_OUTSWAP.
	MCPWM_DT2_CFG_DB2_A_OUTSWAP = 0x200
	// Position of DB2_B_OUTSWAP field.
	MCPWM_DT2_CFG_DB2_B_OUTSWAP_Pos = 0xa
	// Bit mask of DB2_B_OUTSWAP field.
	MCPWM_DT2_CFG_DB2_B_OUTSWAP_Msk = 0x400
	// Bit DB2_B_OUTSWAP.
	MCPWM_DT2_CFG_DB2_B_OUTSWAP = 0x400
	// Position of DB2_RED_INSEL field.
	MCPWM_DT2_CFG_DB2_RED_INSEL_Pos = 0xb
	// Bit mask of DB2_RED_INSEL field.
	MCPWM_DT2_CFG_DB2_RED_INSEL_Msk = 0x800
	// Bit DB2_RED_INSEL.
	MCPWM_DT2_CFG_DB2_RED_INSEL = 0x800
	// Position of DB2_FED_INSEL field.
	MCPWM_DT2_CFG_DB2_FED_INSEL_Pos = 0xc
	// Bit mask of DB2_FED_INSEL field.
	MCPWM_DT2_CFG_DB2_FED_INSEL_Msk = 0x1000
	// Bit DB2_FED_INSEL.
	MCPWM_DT2_CFG_DB2_FED_INSEL = 0x1000
	// Position of DB2_RED_OUTINVERT field.
	MCPWM_DT2_CFG_DB2_RED_OUTINVERT_Pos = 0xd
	// Bit mask of DB2_RED_OUTINVERT field.
	MCPWM_DT2_CFG_DB2_RED_OUTINVERT_Msk = 0x2000
	// Bit DB2_RED_OUTINVERT.
	MCPWM_DT2_CFG_DB2_RED_OUTINVERT = 0x2000
	// Position of DB2_FED_OUTINVERT field.
	MCPWM_DT2_CFG_DB2_FED_OUTINVERT_Pos = 0xe
	// Bit mask of DB2_FED_OUTINVERT field.
	MCPWM_DT2_CFG_DB2_FED_OUTINVERT_Msk = 0x4000
	// Bit DB2_FED_OUTINVERT.
	MCPWM_DT2_CFG_DB2_FED_OUTINVERT = 0x4000
	// Position of DB2_A_OUTBYPASS field.
	MCPWM_DT2_CFG_DB2_A_OUTBYPASS_Pos = 0xf
	// Bit mask of DB2_A_OUTBYPASS field.
	MCPWM_DT2_CFG_DB2_A_OUTBYPASS_Msk = 0x8000
	// Bit DB2_A_OUTBYPASS.
	MCPWM_DT2_CFG_DB2_A_OUTBYPASS = 0x8000
	// Position of DB2_B_OUTBYPASS field.
	MCPWM_DT2_CFG_DB2_B_OUTBYPASS_Pos = 0x10
	// Bit mask of DB2_B_OUTBYPASS field.
	MCPWM_DT2_CFG_DB2_B_OUTBYPASS_Msk = 0x10000
	// Bit DB2_B_OUTBYPASS.
	MCPWM_DT2_CFG_DB2_B_OUTBYPASS = 0x10000
	// Position of DB2_CLK_SEL field.
	MCPWM_DT2_CFG_DB2_CLK_SEL_Pos = 0x11
	// Bit mask of DB2_CLK_SEL field.
	MCPWM_DT2_CFG_DB2_CLK_SEL_Msk = 0x20000
	// Bit DB2_CLK_SEL.
	MCPWM_DT2_CFG_DB2_CLK_SEL = 0x20000

	// DT2_FED_CFG: Shadow register for falling edge delay (FED).
	// Position of DB2_FED field.
	MCPWM_DT2_FED_CFG_DB2_FED_Pos = 0x0
	// Bit mask of DB2_FED field.
	MCPWM_DT2_FED_CFG_DB2_FED_Msk = 0xffff

	// DT2_RED_CFG: Shadow register for rising edge delay (RED).
	// Position of DB2_RED field.
	MCPWM_DT2_RED_CFG_DB2_RED_Pos = 0x0
	// Bit mask of DB2_RED field.
	MCPWM_DT2_RED_CFG_DB2_RED_Msk = 0xffff

	// CARRIER2_CFG: Carrier enable and configuratoin
	// Position of CHOPPER2_EN field.
	MCPWM_CARRIER2_CFG_CHOPPER2_EN_Pos = 0x0
	// Bit mask of CHOPPER2_EN field.
	MCPWM_CARRIER2_CFG_CHOPPER2_EN_Msk = 0x1
	// Bit CHOPPER2_EN.
	MCPWM_CARRIER2_CFG_CHOPPER2_EN = 0x1
	// Position of CHOPPER2_PRESCALE field.
	MCPWM_CARRIER2_CFG_CHOPPER2_PRESCALE_Pos = 0x1
	// Bit mask of CHOPPER2_PRESCALE field.
	MCPWM_CARRIER2_CFG_CHOPPER2_PRESCALE_Msk = 0x1e
	// Position of CHOPPER2_DUTY field.
	MCPWM_CARRIER2_CFG_CHOPPER2_DUTY_Pos = 0x5
	// Bit mask of CHOPPER2_DUTY field.
	MCPWM_CARRIER2_CFG_CHOPPER2_DUTY_Msk = 0xe0
	// Position of CHOPPER2_OSHTWTH field.
	MCPWM_CARRIER2_CFG_CHOPPER2_OSHTWTH_Pos = 0x8
	// Bit mask of CHOPPER2_OSHTWTH field.
	MCPWM_CARRIER2_CFG_CHOPPER2_OSHTWTH_Msk = 0xf00
	// Position of CHOPPER2_OUT_INVERT field.
	MCPWM_CARRIER2_CFG_CHOPPER2_OUT_INVERT_Pos = 0xc
	// Bit mask of CHOPPER2_OUT_INVERT field.
	MCPWM_CARRIER2_CFG_CHOPPER2_OUT_INVERT_Msk = 0x1000
	// Bit CHOPPER2_OUT_INVERT.
	MCPWM_CARRIER2_CFG_CHOPPER2_OUT_INVERT = 0x1000
	// Position of CHOPPER2_IN_INVERT field.
	MCPWM_CARRIER2_CFG_CHOPPER2_IN_INVERT_Pos = 0xd
	// Bit mask of CHOPPER2_IN_INVERT field.
	MCPWM_CARRIER2_CFG_CHOPPER2_IN_INVERT_Msk = 0x2000
	// Bit CHOPPER2_IN_INVERT.
	MCPWM_CARRIER2_CFG_CHOPPER2_IN_INVERT = 0x2000

	// FH2_CFG0: Actions on PWM2A and PWM2B trip events
	// Position of TZ2_SW_CBC field.
	MCPWM_FH2_CFG0_TZ2_SW_CBC_Pos = 0x0
	// Bit mask of TZ2_SW_CBC field.
	MCPWM_FH2_CFG0_TZ2_SW_CBC_Msk = 0x1
	// Bit TZ2_SW_CBC.
	MCPWM_FH2_CFG0_TZ2_SW_CBC = 0x1
	// Position of TZ2_F2_CBC field.
	MCPWM_FH2_CFG0_TZ2_F2_CBC_Pos = 0x1
	// Bit mask of TZ2_F2_CBC field.
	MCPWM_FH2_CFG0_TZ2_F2_CBC_Msk = 0x2
	// Bit TZ2_F2_CBC.
	MCPWM_FH2_CFG0_TZ2_F2_CBC = 0x2
	// Position of TZ2_F1_CBC field.
	MCPWM_FH2_CFG0_TZ2_F1_CBC_Pos = 0x2
	// Bit mask of TZ2_F1_CBC field.
	MCPWM_FH2_CFG0_TZ2_F1_CBC_Msk = 0x4
	// Bit TZ2_F1_CBC.
	MCPWM_FH2_CFG0_TZ2_F1_CBC = 0x4
	// Position of TZ2_F0_CBC field.
	MCPWM_FH2_CFG0_TZ2_F0_CBC_Pos = 0x3
	// Bit mask of TZ2_F0_CBC field.
	MCPWM_FH2_CFG0_TZ2_F0_CBC_Msk = 0x8
	// Bit TZ2_F0_CBC.
	MCPWM_FH2_CFG0_TZ2_F0_CBC = 0x8
	// Position of TZ2_SW_OST field.
	MCPWM_FH2_CFG0_TZ2_SW_OST_Pos = 0x4
	// Bit mask of TZ2_SW_OST field.
	MCPWM_FH2_CFG0_TZ2_SW_OST_Msk = 0x10
	// Bit TZ2_SW_OST.
	MCPWM_FH2_CFG0_TZ2_SW_OST = 0x10
	// Position of TZ2_F2_OST field.
	MCPWM_FH2_CFG0_TZ2_F2_OST_Pos = 0x5
	// Bit mask of TZ2_F2_OST field.
	MCPWM_FH2_CFG0_TZ2_F2_OST_Msk = 0x20
	// Bit TZ2_F2_OST.
	MCPWM_FH2_CFG0_TZ2_F2_OST = 0x20
	// Position of TZ2_F1_OST field.
	MCPWM_FH2_CFG0_TZ2_F1_OST_Pos = 0x6
	// Bit mask of TZ2_F1_OST field.
	MCPWM_FH2_CFG0_TZ2_F1_OST_Msk = 0x40
	// Bit TZ2_F1_OST.
	MCPWM_FH2_CFG0_TZ2_F1_OST = 0x40
	// Position of TZ2_F0_OST field.
	MCPWM_FH2_CFG0_TZ2_F0_OST_Pos = 0x7
	// Bit mask of TZ2_F0_OST field.
	MCPWM_FH2_CFG0_TZ2_F0_OST_Msk = 0x80
	// Bit TZ2_F0_OST.
	MCPWM_FH2_CFG0_TZ2_F0_OST = 0x80
	// Position of TZ2_A_CBC_D field.
	MCPWM_FH2_CFG0_TZ2_A_CBC_D_Pos = 0x8
	// Bit mask of TZ2_A_CBC_D field.
	MCPWM_FH2_CFG0_TZ2_A_CBC_D_Msk = 0x300
	// Position of TZ2_A_CBC_U field.
	MCPWM_FH2_CFG0_TZ2_A_CBC_U_Pos = 0xa
	// Bit mask of TZ2_A_CBC_U field.
	MCPWM_FH2_CFG0_TZ2_A_CBC_U_Msk = 0xc00
	// Position of TZ2_A_OST_D field.
	MCPWM_FH2_CFG0_TZ2_A_OST_D_Pos = 0xc
	// Bit mask of TZ2_A_OST_D field.
	MCPWM_FH2_CFG0_TZ2_A_OST_D_Msk = 0x3000
	// Position of TZ2_A_OST_U field.
	MCPWM_FH2_CFG0_TZ2_A_OST_U_Pos = 0xe
	// Bit mask of TZ2_A_OST_U field.
	MCPWM_FH2_CFG0_TZ2_A_OST_U_Msk = 0xc000
	// Position of TZ2_B_CBC_D field.
	MCPWM_FH2_CFG0_TZ2_B_CBC_D_Pos = 0x10
	// Bit mask of TZ2_B_CBC_D field.
	MCPWM_FH2_CFG0_TZ2_B_CBC_D_Msk = 0x30000
	// Position of TZ2_B_CBC_U field.
	MCPWM_FH2_CFG0_TZ2_B_CBC_U_Pos = 0x12
	// Bit mask of TZ2_B_CBC_U field.
	MCPWM_FH2_CFG0_TZ2_B_CBC_U_Msk = 0xc0000
	// Position of TZ2_B_OST_D field.
	MCPWM_FH2_CFG0_TZ2_B_OST_D_Pos = 0x14
	// Bit mask of TZ2_B_OST_D field.
	MCPWM_FH2_CFG0_TZ2_B_OST_D_Msk = 0x300000
	// Position of TZ2_B_OST_U field.
	MCPWM_FH2_CFG0_TZ2_B_OST_U_Pos = 0x16
	// Bit mask of TZ2_B_OST_U field.
	MCPWM_FH2_CFG0_TZ2_B_OST_U_Msk = 0xc00000

	// FH2_CFG1: Software triggers for fault handler actions
	// Position of TZ2_CLR_OST field.
	MCPWM_FH2_CFG1_TZ2_CLR_OST_Pos = 0x0
	// Bit mask of TZ2_CLR_OST field.
	MCPWM_FH2_CFG1_TZ2_CLR_OST_Msk = 0x1
	// Bit TZ2_CLR_OST.
	MCPWM_FH2_CFG1_TZ2_CLR_OST = 0x1
	// Position of TZ2_CBCPULSE field.
	MCPWM_FH2_CFG1_TZ2_CBCPULSE_Pos = 0x1
	// Bit mask of TZ2_CBCPULSE field.
	MCPWM_FH2_CFG1_TZ2_CBCPULSE_Msk = 0x6
	// Position of TZ2_FORCE_CBC field.
	MCPWM_FH2_CFG1_TZ2_FORCE_CBC_Pos = 0x3
	// Bit mask of TZ2_FORCE_CBC field.
	MCPWM_FH2_CFG1_TZ2_FORCE_CBC_Msk = 0x8
	// Bit TZ2_FORCE_CBC.
	MCPWM_FH2_CFG1_TZ2_FORCE_CBC = 0x8
	// Position of TZ2_FORCE_OST field.
	MCPWM_FH2_CFG1_TZ2_FORCE_OST_Pos = 0x4
	// Bit mask of TZ2_FORCE_OST field.
	MCPWM_FH2_CFG1_TZ2_FORCE_OST_Msk = 0x10
	// Bit TZ2_FORCE_OST.
	MCPWM_FH2_CFG1_TZ2_FORCE_OST = 0x10

	// FH2_STATUS: Status of fault events.
	// Position of TZ2_CBC_ON field.
	MCPWM_FH2_STATUS_TZ2_CBC_ON_Pos = 0x0
	// Bit mask of TZ2_CBC_ON field.
	MCPWM_FH2_STATUS_TZ2_CBC_ON_Msk = 0x1
	// Bit TZ2_CBC_ON.
	MCPWM_FH2_STATUS_TZ2_CBC_ON = 0x1
	// Position of TZ2_OST_ON field.
	MCPWM_FH2_STATUS_TZ2_OST_ON_Pos = 0x1
	// Bit mask of TZ2_OST_ON field.
	MCPWM_FH2_STATUS_TZ2_OST_ON_Msk = 0x2
	// Bit TZ2_OST_ON.
	MCPWM_FH2_STATUS_TZ2_OST_ON = 0x2

	// FAULT_DETECT: Fault detection configuration and status
	// Position of F0_EN field.
	MCPWM_FAULT_DETECT_F0_EN_Pos = 0x0
	// Bit mask of F0_EN field.
	MCPWM_FAULT_DETECT_F0_EN_Msk = 0x1
	// Bit F0_EN.
	MCPWM_FAULT_DETECT_F0_EN = 0x1
	// Position of F1_EN field.
	MCPWM_FAULT_DETECT_F1_EN_Pos = 0x1
	// Bit mask of F1_EN field.
	MCPWM_FAULT_DETECT_F1_EN_Msk = 0x2
	// Bit F1_EN.
	MCPWM_FAULT_DETECT_F1_EN = 0x2
	// Position of F2_EN field.
	MCPWM_FAULT_DETECT_F2_EN_Pos = 0x2
	// Bit mask of F2_EN field.
	MCPWM_FAULT_DETECT_F2_EN_Msk = 0x4
	// Bit F2_EN.
	MCPWM_FAULT_DETECT_F2_EN = 0x4
	// Position of F0_POLE field.
	MCPWM_FAULT_DETECT_F0_POLE_Pos = 0x3
	// Bit mask of F0_POLE field.
	MCPWM_FAULT_DETECT_F0_POLE_Msk = 0x8
	// Bit F0_POLE.
	MCPWM_FAULT_DETECT_F0_POLE = 0x8
	// Position of F1_POLE field.
	MCPWM_FAULT_DETECT_F1_POLE_Pos = 0x4
	// Bit mask of F1_POLE field.
	MCPWM_FAULT_DETECT_F1_POLE_Msk = 0x10
	// Bit F1_POLE.
	MCPWM_FAULT_DETECT_F1_POLE = 0x10
	// Position of F2_POLE field.
	MCPWM_FAULT_DETECT_F2_POLE_Pos = 0x5
	// Bit mask of F2_POLE field.
	MCPWM_FAULT_DETECT_F2_POLE_Msk = 0x20
	// Bit F2_POLE.
	MCPWM_FAULT_DETECT_F2_POLE = 0x20
	// Position of EVENT_F0 field.
	MCPWM_FAULT_DETECT_EVENT_F0_Pos = 0x6
	// Bit mask of EVENT_F0 field.
	MCPWM_FAULT_DETECT_EVENT_F0_Msk = 0x40
	// Bit EVENT_F0.
	MCPWM_FAULT_DETECT_EVENT_F0 = 0x40
	// Position of EVENT_F1 field.
	MCPWM_FAULT_DETECT_EVENT_F1_Pos = 0x7
	// Bit mask of EVENT_F1 field.
	MCPWM_FAULT_DETECT_EVENT_F1_Msk = 0x80
	// Bit EVENT_F1.
	MCPWM_FAULT_DETECT_EVENT_F1 = 0x80
	// Position of EVENT_F2 field.
	MCPWM_FAULT_DETECT_EVENT_F2_Pos = 0x8
	// Bit mask of EVENT_F2 field.
	MCPWM_FAULT_DETECT_EVENT_F2_Msk = 0x100
	// Bit EVENT_F2.
	MCPWM_FAULT_DETECT_EVENT_F2 = 0x100

	// CAP_TIMER_CFG: Configure capture timer
	// Position of CAP_TIMER_EN field.
	MCPWM_CAP_TIMER_CFG_CAP_TIMER_EN_Pos = 0x0
	// Bit mask of CAP_TIMER_EN field.
	MCPWM_CAP_TIMER_CFG_CAP_TIMER_EN_Msk = 0x1
	// Bit CAP_TIMER_EN.
	MCPWM_CAP_TIMER_CFG_CAP_TIMER_EN = 0x1
	// Position of CAP_SYNCI_EN field.
	MCPWM_CAP_TIMER_CFG_CAP_SYNCI_EN_Pos = 0x1
	// Bit mask of CAP_SYNCI_EN field.
	MCPWM_CAP_TIMER_CFG_CAP_SYNCI_EN_Msk = 0x2
	// Bit CAP_SYNCI_EN.
	MCPWM_CAP_TIMER_CFG_CAP_SYNCI_EN = 0x2
	// Position of CAP_SYNCI_SEL field.
	MCPWM_CAP_TIMER_CFG_CAP_SYNCI_SEL_Pos = 0x2
	// Bit mask of CAP_SYNCI_SEL field.
	MCPWM_CAP_TIMER_CFG_CAP_SYNCI_SEL_Msk = 0x1c
	// Position of CAP_SYNC_SW field.
	MCPWM_CAP_TIMER_CFG_CAP_SYNC_SW_Pos = 0x5
	// Bit mask of CAP_SYNC_SW field.
	MCPWM_CAP_TIMER_CFG_CAP_SYNC_SW_Msk = 0x20
	// Bit CAP_SYNC_SW.
	MCPWM_CAP_TIMER_CFG_CAP_SYNC_SW = 0x20

	// CAP_TIMER_PHASE: Phase for capture timer sync
	// Position of CAP_PHASE field.
	MCPWM_CAP_TIMER_PHASE_CAP_PHASE_Pos = 0x0
	// Bit mask of CAP_PHASE field.
	MCPWM_CAP_TIMER_PHASE_CAP_PHASE_Msk = 0xffffffff

	// CAP_CH0_CFG: Capture channel 0 configuration and enable
	// Position of CAP0_EN field.
	MCPWM_CAP_CH0_CFG_CAP0_EN_Pos = 0x0
	// Bit mask of CAP0_EN field.
	MCPWM_CAP_CH0_CFG_CAP0_EN_Msk = 0x1
	// Bit CAP0_EN.
	MCPWM_CAP_CH0_CFG_CAP0_EN = 0x1
	// Position of CAP0_MODE field.
	MCPWM_CAP_CH0_CFG_CAP0_MODE_Pos = 0x1
	// Bit mask of CAP0_MODE field.
	MCPWM_CAP_CH0_CFG_CAP0_MODE_Msk = 0x6
	// Position of CAP0_PRESCALE field.
	MCPWM_CAP_CH0_CFG_CAP0_PRESCALE_Pos = 0x3
	// Bit mask of CAP0_PRESCALE field.
	MCPWM_CAP_CH0_CFG_CAP0_PRESCALE_Msk = 0x7f8
	// Position of CAP0_IN_INVERT field.
	MCPWM_CAP_CH0_CFG_CAP0_IN_INVERT_Pos = 0xb
	// Bit mask of CAP0_IN_INVERT field.
	MCPWM_CAP_CH0_CFG_CAP0_IN_INVERT_Msk = 0x800
	// Bit CAP0_IN_INVERT.
	MCPWM_CAP_CH0_CFG_CAP0_IN_INVERT = 0x800
	// Position of CAP0_SW field.
	MCPWM_CAP_CH0_CFG_CAP0_SW_Pos = 0xc
	// Bit mask of CAP0_SW field.
	MCPWM_CAP_CH0_CFG_CAP0_SW_Msk = 0x1000
	// Bit CAP0_SW.
	MCPWM_CAP_CH0_CFG_CAP0_SW = 0x1000

	// CAP_CH1_CFG: Capture channel 1 configuration and enable
	// Position of CAP1_EN field.
	MCPWM_CAP_CH1_CFG_CAP1_EN_Pos = 0x0
	// Bit mask of CAP1_EN field.
	MCPWM_CAP_CH1_CFG_CAP1_EN_Msk = 0x1
	// Bit CAP1_EN.
	MCPWM_CAP_CH1_CFG_CAP1_EN = 0x1
	// Position of CAP1_MODE field.
	MCPWM_CAP_CH1_CFG_CAP1_MODE_Pos = 0x1
	// Bit mask of CAP1_MODE field.
	MCPWM_CAP_CH1_CFG_CAP1_MODE_Msk = 0x6
	// Position of CAP1_PRESCALE field.
	MCPWM_CAP_CH1_CFG_CAP1_PRESCALE_Pos = 0x3
	// Bit mask of CAP1_PRESCALE field.
	MCPWM_CAP_CH1_CFG_CAP1_PRESCALE_Msk = 0x7f8
	// Position of CAP1_IN_INVERT field.
	MCPWM_CAP_CH1_CFG_CAP1_IN_INVERT_Pos = 0xb
	// Bit mask of CAP1_IN_INVERT field.
	MCPWM_CAP_CH1_CFG_CAP1_IN_INVERT_Msk = 0x800
	// Bit CAP1_IN_INVERT.
	MCPWM_CAP_CH1_CFG_CAP1_IN_INVERT = 0x800
	// Position of CAP1_SW field.
	MCPWM_CAP_CH1_CFG_CAP1_SW_Pos = 0xc
	// Bit mask of CAP1_SW field.
	MCPWM_CAP_CH1_CFG_CAP1_SW_Msk = 0x1000
	// Bit CAP1_SW.
	MCPWM_CAP_CH1_CFG_CAP1_SW = 0x1000

	// CAP_CH2_CFG: Capture channel 2 configuration and enable
	// Position of CAP2_EN field.
	MCPWM_CAP_CH2_CFG_CAP2_EN_Pos = 0x0
	// Bit mask of CAP2_EN field.
	MCPWM_CAP_CH2_CFG_CAP2_EN_Msk = 0x1
	// Bit CAP2_EN.
	MCPWM_CAP_CH2_CFG_CAP2_EN = 0x1
	// Position of CAP2_MODE field.
	MCPWM_CAP_CH2_CFG_CAP2_MODE_Pos = 0x1
	// Bit mask of CAP2_MODE field.
	MCPWM_CAP_CH2_CFG_CAP2_MODE_Msk = 0x6
	// Position of CAP2_PRESCALE field.
	MCPWM_CAP_CH2_CFG_CAP2_PRESCALE_Pos = 0x3
	// Bit mask of CAP2_PRESCALE field.
	MCPWM_CAP_CH2_CFG_CAP2_PRESCALE_Msk = 0x7f8
	// Position of CAP2_IN_INVERT field.
	MCPWM_CAP_CH2_CFG_CAP2_IN_INVERT_Pos = 0xb
	// Bit mask of CAP2_IN_INVERT field.
	MCPWM_CAP_CH2_CFG_CAP2_IN_INVERT_Msk = 0x800
	// Bit CAP2_IN_INVERT.
	MCPWM_CAP_CH2_CFG_CAP2_IN_INVERT = 0x800
	// Position of CAP2_SW field.
	MCPWM_CAP_CH2_CFG_CAP2_SW_Pos = 0xc
	// Bit mask of CAP2_SW field.
	MCPWM_CAP_CH2_CFG_CAP2_SW_Msk = 0x1000
	// Bit CAP2_SW.
	MCPWM_CAP_CH2_CFG_CAP2_SW = 0x1000

	// CAP_CH0: ch0 capture value status register
	// Position of CAP0_VALUE field.
	MCPWM_CAP_CH0_CAP0_VALUE_Pos = 0x0
	// Bit mask of CAP0_VALUE field.
	MCPWM_CAP_CH0_CAP0_VALUE_Msk = 0xffffffff

	// CAP_CH1: ch1 capture value status register
	// Position of CAP1_VALUE field.
	MCPWM_CAP_CH1_CAP1_VALUE_Pos = 0x0
	// Bit mask of CAP1_VALUE field.
	MCPWM_CAP_CH1_CAP1_VALUE_Msk = 0xffffffff

	// CAP_CH2: ch2 capture value status register
	// Position of CAP2_VALUE field.
	MCPWM_CAP_CH2_CAP2_VALUE_Pos = 0x0
	// Bit mask of CAP2_VALUE field.
	MCPWM_CAP_CH2_CAP2_VALUE_Msk = 0xffffffff

	// CAP_STATUS: Edge of last capture trigger
	// Position of CAP0_EDGE field.
	MCPWM_CAP_STATUS_CAP0_EDGE_Pos = 0x0
	// Bit mask of CAP0_EDGE field.
	MCPWM_CAP_STATUS_CAP0_EDGE_Msk = 0x1
	// Bit CAP0_EDGE.
	MCPWM_CAP_STATUS_CAP0_EDGE = 0x1
	// Position of CAP1_EDGE field.
	MCPWM_CAP_STATUS_CAP1_EDGE_Pos = 0x1
	// Bit mask of CAP1_EDGE field.
	MCPWM_CAP_STATUS_CAP1_EDGE_Msk = 0x2
	// Bit CAP1_EDGE.
	MCPWM_CAP_STATUS_CAP1_EDGE = 0x2
	// Position of CAP2_EDGE field.
	MCPWM_CAP_STATUS_CAP2_EDGE_Pos = 0x2
	// Bit mask of CAP2_EDGE field.
	MCPWM_CAP_STATUS_CAP2_EDGE_Msk = 0x4
	// Bit CAP2_EDGE.
	MCPWM_CAP_STATUS_CAP2_EDGE = 0x4

	// UPDATE_CFG: Enable update.
	// Position of GLOBAL_UP_EN field.
	MCPWM_UPDATE_CFG_GLOBAL_UP_EN_Pos = 0x0
	// Bit mask of GLOBAL_UP_EN field.
	MCPWM_UPDATE_CFG_GLOBAL_UP_EN_Msk = 0x1
	// Bit GLOBAL_UP_EN.
	MCPWM_UPDATE_CFG_GLOBAL_UP_EN = 0x1
	// Position of GLOBAL_FORCE_UP field.
	MCPWM_UPDATE_CFG_GLOBAL_FORCE_UP_Pos = 0x1
	// Bit mask of GLOBAL_FORCE_UP field.
	MCPWM_UPDATE_CFG_GLOBAL_FORCE_UP_Msk = 0x2
	// Bit GLOBAL_FORCE_UP.
	MCPWM_UPDATE_CFG_GLOBAL_FORCE_UP = 0x2
	// Position of OP0_UP_EN field.
	MCPWM_UPDATE_CFG_OP0_UP_EN_Pos = 0x2
	// Bit mask of OP0_UP_EN field.
	MCPWM_UPDATE_CFG_OP0_UP_EN_Msk = 0x4
	// Bit OP0_UP_EN.
	MCPWM_UPDATE_CFG_OP0_UP_EN = 0x4
	// Position of OP0_FORCE_UP field.
	MCPWM_UPDATE_CFG_OP0_FORCE_UP_Pos = 0x3
	// Bit mask of OP0_FORCE_UP field.
	MCPWM_UPDATE_CFG_OP0_FORCE_UP_Msk = 0x8
	// Bit OP0_FORCE_UP.
	MCPWM_UPDATE_CFG_OP0_FORCE_UP = 0x8
	// Position of OP1_UP_EN field.
	MCPWM_UPDATE_CFG_OP1_UP_EN_Pos = 0x4
	// Bit mask of OP1_UP_EN field.
	MCPWM_UPDATE_CFG_OP1_UP_EN_Msk = 0x10
	// Bit OP1_UP_EN.
	MCPWM_UPDATE_CFG_OP1_UP_EN = 0x10
	// Position of OP1_FORCE_UP field.
	MCPWM_UPDATE_CFG_OP1_FORCE_UP_Pos = 0x5
	// Bit mask of OP1_FORCE_UP field.
	MCPWM_UPDATE_CFG_OP1_FORCE_UP_Msk = 0x20
	// Bit OP1_FORCE_UP.
	MCPWM_UPDATE_CFG_OP1_FORCE_UP = 0x20
	// Position of OP2_UP_EN field.
	MCPWM_UPDATE_CFG_OP2_UP_EN_Pos = 0x6
	// Bit mask of OP2_UP_EN field.
	MCPWM_UPDATE_CFG_OP2_UP_EN_Msk = 0x40
	// Bit OP2_UP_EN.
	MCPWM_UPDATE_CFG_OP2_UP_EN = 0x40
	// Position of OP2_FORCE_UP field.
	MCPWM_UPDATE_CFG_OP2_FORCE_UP_Pos = 0x7
	// Bit mask of OP2_FORCE_UP field.
	MCPWM_UPDATE_CFG_OP2_FORCE_UP_Msk = 0x80
	// Bit OP2_FORCE_UP.
	MCPWM_UPDATE_CFG_OP2_FORCE_UP = 0x80

	// INT_ENA: Interrupt enable bits
	// Position of TIMER0_STOP_INT_ENA field.
	MCPWM_INT_ENA_TIMER0_STOP_INT_ENA_Pos = 0x0
	// Bit mask of TIMER0_STOP_INT_ENA field.
	MCPWM_INT_ENA_TIMER0_STOP_INT_ENA_Msk = 0x1
	// Bit TIMER0_STOP_INT_ENA.
	MCPWM_INT_ENA_TIMER0_STOP_INT_ENA = 0x1
	// Position of TIMER1_STOP_INT_ENA field.
	MCPWM_INT_ENA_TIMER1_STOP_INT_ENA_Pos = 0x1
	// Bit mask of TIMER1_STOP_INT_ENA field.
	MCPWM_INT_ENA_TIMER1_STOP_INT_ENA_Msk = 0x2
	// Bit TIMER1_STOP_INT_ENA.
	MCPWM_INT_ENA_TIMER1_STOP_INT_ENA = 0x2
	// Position of TIMER2_STOP_INT_ENA field.
	MCPWM_INT_ENA_TIMER2_STOP_INT_ENA_Pos = 0x2
	// Bit mask of TIMER2_STOP_INT_ENA field.
	MCPWM_INT_ENA_TIMER2_STOP_INT_ENA_Msk = 0x4
	// Bit TIMER2_STOP_INT_ENA.
	MCPWM_INT_ENA_TIMER2_STOP_INT_ENA = 0x4
	// Position of TIMER0_TEZ_INT_ENA field.
	MCPWM_INT_ENA_TIMER0_TEZ_INT_ENA_Pos = 0x3
	// Bit mask of TIMER0_TEZ_INT_ENA field.
	MCPWM_INT_ENA_TIMER0_TEZ_INT_ENA_Msk = 0x8
	// Bit TIMER0_TEZ_INT_ENA.
	MCPWM_INT_ENA_TIMER0_TEZ_INT_ENA = 0x8
	// Position of TIMER1_TEZ_INT_ENA field.
	MCPWM_INT_ENA_TIMER1_TEZ_INT_ENA_Pos = 0x4
	// Bit mask of TIMER1_TEZ_INT_ENA field.
	MCPWM_INT_ENA_TIMER1_TEZ_INT_ENA_Msk = 0x10
	// Bit TIMER1_TEZ_INT_ENA.
	MCPWM_INT_ENA_TIMER1_TEZ_INT_ENA = 0x10
	// Position of TIMER2_TEZ_INT_ENA field.
	MCPWM_INT_ENA_TIMER2_TEZ_INT_ENA_Pos = 0x5
	// Bit mask of TIMER2_TEZ_INT_ENA field.
	MCPWM_INT_ENA_TIMER2_TEZ_INT_ENA_Msk = 0x20
	// Bit TIMER2_TEZ_INT_ENA.
	MCPWM_INT_ENA_TIMER2_TEZ_INT_ENA = 0x20
	// Position of TIMER0_TEP_INT_ENA field.
	MCPWM_INT_ENA_TIMER0_TEP_INT_ENA_Pos = 0x6
	// Bit mask of TIMER0_TEP_INT_ENA field.
	MCPWM_INT_ENA_TIMER0_TEP_INT_ENA_Msk = 0x40
	// Bit TIMER0_TEP_INT_ENA.
	MCPWM_INT_ENA_TIMER0_TEP_INT_ENA = 0x40
	// Position of TIMER1_TEP_INT_ENA field.
	MCPWM_INT_ENA_TIMER1_TEP_INT_ENA_Pos = 0x7
	// Bit mask of TIMER1_TEP_INT_ENA field.
	MCPWM_INT_ENA_TIMER1_TEP_INT_ENA_Msk = 0x80
	// Bit TIMER1_TEP_INT_ENA.
	MCPWM_INT_ENA_TIMER1_TEP_INT_ENA = 0x80
	// Position of TIMER2_TEP_INT_ENA field.
	MCPWM_INT_ENA_TIMER2_TEP_INT_ENA_Pos = 0x8
	// Bit mask of TIMER2_TEP_INT_ENA field.
	MCPWM_INT_ENA_TIMER2_TEP_INT_ENA_Msk = 0x100
	// Bit TIMER2_TEP_INT_ENA.
	MCPWM_INT_ENA_TIMER2_TEP_INT_ENA = 0x100
	// Position of FAULT0_INT_ENA field.
	MCPWM_INT_ENA_FAULT0_INT_ENA_Pos = 0x9
	// Bit mask of FAULT0_INT_ENA field.
	MCPWM_INT_ENA_FAULT0_INT_ENA_Msk = 0x200
	// Bit FAULT0_INT_ENA.
	MCPWM_INT_ENA_FAULT0_INT_ENA = 0x200
	// Position of FAULT1_INT_ENA field.
	MCPWM_INT_ENA_FAULT1_INT_ENA_Pos = 0xa
	// Bit mask of FAULT1_INT_ENA field.
	MCPWM_INT_ENA_FAULT1_INT_ENA_Msk = 0x400
	// Bit FAULT1_INT_ENA.
	MCPWM_INT_ENA_FAULT1_INT_ENA = 0x400
	// Position of FAULT2_INT_ENA field.
	MCPWM_INT_ENA_FAULT2_INT_ENA_Pos = 0xb
	// Bit mask of FAULT2_INT_ENA field.
	MCPWM_INT_ENA_FAULT2_INT_ENA_Msk = 0x800
	// Bit FAULT2_INT_ENA.
	MCPWM_INT_ENA_FAULT2_INT_ENA = 0x800
	// Position of FAULT0_CLR_INT_ENA field.
	MCPWM_INT_ENA_FAULT0_CLR_INT_ENA_Pos = 0xc
	// Bit mask of FAULT0_CLR_INT_ENA field.
	MCPWM_INT_ENA_FAULT0_CLR_INT_ENA_Msk = 0x1000
	// Bit FAULT0_CLR_INT_ENA.
	MCPWM_INT_ENA_FAULT0_CLR_INT_ENA = 0x1000
	// Position of FAULT1_CLR_INT_ENA field.
	MCPWM_INT_ENA_FAULT1_CLR_INT_ENA_Pos = 0xd
	// Bit mask of FAULT1_CLR_INT_ENA field.
	MCPWM_INT_ENA_FAULT1_CLR_INT_ENA_Msk = 0x2000
	// Bit FAULT1_CLR_INT_ENA.
	MCPWM_INT_ENA_FAULT1_CLR_INT_ENA = 0x2000
	// Position of FAULT2_CLR_INT_ENA field.
	MCPWM_INT_ENA_FAULT2_CLR_INT_ENA_Pos = 0xe
	// Bit mask of FAULT2_CLR_INT_ENA field.
	MCPWM_INT_ENA_FAULT2_CLR_INT_ENA_Msk = 0x4000
	// Bit FAULT2_CLR_INT_ENA.
	MCPWM_INT_ENA_FAULT2_CLR_INT_ENA = 0x4000
	// Position of CMPR0_TEA_INT_ENA field.
	MCPWM_INT_ENA_CMPR0_TEA_INT_ENA_Pos = 0xf
	// Bit mask of CMPR0_TEA_INT_ENA field.
	MCPWM_INT_ENA_CMPR0_TEA_INT_ENA_Msk = 0x8000
	// Bit CMPR0_TEA_INT_ENA.
	MCPWM_INT_ENA_CMPR0_TEA_INT_ENA = 0x8000
	// Position of CMPR1_TEA_INT_ENA field.
	MCPWM_INT_ENA_CMPR1_TEA_INT_ENA_Pos = 0x10
	// Bit mask of CMPR1_TEA_INT_ENA field.
	MCPWM_INT_ENA_CMPR1_TEA_INT_ENA_Msk = 0x10000
	// Bit CMPR1_TEA_INT_ENA.
	MCPWM_INT_ENA_CMPR1_TEA_INT_ENA = 0x10000
	// Position of CMPR2_TEA_INT_ENA field.
	MCPWM_INT_ENA_CMPR2_TEA_INT_ENA_Pos = 0x11
	// Bit mask of CMPR2_TEA_INT_ENA field.
	MCPWM_INT_ENA_CMPR2_TEA_INT_ENA_Msk = 0x20000
	// Bit CMPR2_TEA_INT_ENA.
	MCPWM_INT_ENA_CMPR2_TEA_INT_ENA = 0x20000
	// Position of CMPR0_TEB_INT_ENA field.
	MCPWM_INT_ENA_CMPR0_TEB_INT_ENA_Pos = 0x12
	// Bit mask of CMPR0_TEB_INT_ENA field.
	MCPWM_INT_ENA_CMPR0_TEB_INT_ENA_Msk = 0x40000
	// Bit CMPR0_TEB_INT_ENA.
	MCPWM_INT_ENA_CMPR0_TEB_INT_ENA = 0x40000
	// Position of CMPR1_TEB_INT_ENA field.
	MCPWM_INT_ENA_CMPR1_TEB_INT_ENA_Pos = 0x13
	// Bit mask of CMPR1_TEB_INT_ENA field.
	MCPWM_INT_ENA_CMPR1_TEB_INT_ENA_Msk = 0x80000
	// Bit CMPR1_TEB_INT_ENA.
	MCPWM_INT_ENA_CMPR1_TEB_INT_ENA = 0x80000
	// Position of CMPR2_TEB_INT_ENA field.
	MCPWM_INT_ENA_CMPR2_TEB_INT_ENA_Pos = 0x14
	// Bit mask of CMPR2_TEB_INT_ENA field.
	MCPWM_INT_ENA_CMPR2_TEB_INT_ENA_Msk = 0x100000
	// Bit CMPR2_TEB_INT_ENA.
	MCPWM_INT_ENA_CMPR2_TEB_INT_ENA = 0x100000
	// Position of TZ0_CBC_INT_ENA field.
	MCPWM_INT_ENA_TZ0_CBC_INT_ENA_Pos = 0x15
	// Bit mask of TZ0_CBC_INT_ENA field.
	MCPWM_INT_ENA_TZ0_CBC_INT_ENA_Msk = 0x200000
	// Bit TZ0_CBC_INT_ENA.
	MCPWM_INT_ENA_TZ0_CBC_INT_ENA = 0x200000
	// Position of TZ1_CBC_INT_ENA field.
	MCPWM_INT_ENA_TZ1_CBC_INT_ENA_Pos = 0x16
	// Bit mask of TZ1_CBC_INT_ENA field.
	MCPWM_INT_ENA_TZ1_CBC_INT_ENA_Msk = 0x400000
	// Bit TZ1_CBC_INT_ENA.
	MCPWM_INT_ENA_TZ1_CBC_INT_ENA = 0x400000
	// Position of TZ2_CBC_INT_ENA field.
	MCPWM_INT_ENA_TZ2_CBC_INT_ENA_Pos = 0x17
	// Bit mask of TZ2_CBC_INT_ENA field.
	MCPWM_INT_ENA_TZ2_CBC_INT_ENA_Msk = 0x800000
	// Bit TZ2_CBC_INT_ENA.
	MCPWM_INT_ENA_TZ2_CBC_INT_ENA = 0x800000
	// Position of TZ0_OST_INT_ENA field.
	MCPWM_INT_ENA_TZ0_OST_INT_ENA_Pos = 0x18
	// Bit mask of TZ0_OST_INT_ENA field.
	MCPWM_INT_ENA_TZ0_OST_INT_ENA_Msk = 0x1000000
	// Bit TZ0_OST_INT_ENA.
	MCPWM_INT_ENA_TZ0_OST_INT_ENA = 0x1000000
	// Position of TZ1_OST_INT_ENA field.
	MCPWM_INT_ENA_TZ1_OST_INT_ENA_Pos = 0x19
	// Bit mask of TZ1_OST_INT_ENA field.
	MCPWM_INT_ENA_TZ1_OST_INT_ENA_Msk = 0x2000000
	// Bit TZ1_OST_INT_ENA.
	MCPWM_INT_ENA_TZ1_OST_INT_ENA = 0x2000000
	// Position of TZ2_OST_INT_ENA field.
	MCPWM_INT_ENA_TZ2_OST_INT_ENA_Pos = 0x1a
	// Bit mask of TZ2_OST_INT_ENA field.
	MCPWM_INT_ENA_TZ2_OST_INT_ENA_Msk = 0x4000000
	// Bit TZ2_OST_INT_ENA.
	MCPWM_INT_ENA_TZ2_OST_INT_ENA = 0x4000000
	// Position of CAP0_INT_ENA field.
	MCPWM_INT_ENA_CAP0_INT_ENA_Pos = 0x1b
	// Bit mask of CAP0_INT_ENA field.
	MCPWM_INT_ENA_CAP0_INT_ENA_Msk = 0x8000000
	// Bit CAP0_INT_ENA.
	MCPWM_INT_ENA_CAP0_INT_ENA = 0x8000000
	// Position of CAP1_INT_ENA field.
	MCPWM_INT_ENA_CAP1_INT_ENA_Pos = 0x1c
	// Bit mask of CAP1_INT_ENA field.
	MCPWM_INT_ENA_CAP1_INT_ENA_Msk = 0x10000000
	// Bit CAP1_INT_ENA.
	MCPWM_INT_ENA_CAP1_INT_ENA = 0x10000000
	// Position of CAP2_INT_ENA field.
	MCPWM_INT_ENA_CAP2_INT_ENA_Pos = 0x1d
	// Bit mask of CAP2_INT_ENA field.
	MCPWM_INT_ENA_CAP2_INT_ENA_Msk = 0x20000000
	// Bit CAP2_INT_ENA.
	MCPWM_INT_ENA_CAP2_INT_ENA = 0x20000000

	// INT_RAW: Raw interrupt status
	// Position of TIMER0_STOP_INT_RAW field.
	MCPWM_INT_RAW_TIMER0_STOP_INT_RAW_Pos = 0x0
	// Bit mask of TIMER0_STOP_INT_RAW field.
	MCPWM_INT_RAW_TIMER0_STOP_INT_RAW_Msk = 0x1
	// Bit TIMER0_STOP_INT_RAW.
	MCPWM_INT_RAW_TIMER0_STOP_INT_RAW = 0x1
	// Position of TIMER1_STOP_INT_RAW field.
	MCPWM_INT_RAW_TIMER1_STOP_INT_RAW_Pos = 0x1
	// Bit mask of TIMER1_STOP_INT_RAW field.
	MCPWM_INT_RAW_TIMER1_STOP_INT_RAW_Msk = 0x2
	// Bit TIMER1_STOP_INT_RAW.
	MCPWM_INT_RAW_TIMER1_STOP_INT_RAW = 0x2
	// Position of TIMER2_STOP_INT_RAW field.
	MCPWM_INT_RAW_TIMER2_STOP_INT_RAW_Pos = 0x2
	// Bit mask of TIMER2_STOP_INT_RAW field.
	MCPWM_INT_RAW_TIMER2_STOP_INT_RAW_Msk = 0x4
	// Bit TIMER2_STOP_INT_RAW.
	MCPWM_INT_RAW_TIMER2_STOP_INT_RAW = 0x4
	// Position of TIMER0_TEZ_INT_RAW field.
	MCPWM_INT_RAW_TIMER0_TEZ_INT_RAW_Pos = 0x3
	// Bit mask of TIMER0_TEZ_INT_RAW field.
	MCPWM_INT_RAW_TIMER0_TEZ_INT_RAW_Msk = 0x8
	// Bit TIMER0_TEZ_INT_RAW.
	MCPWM_INT_RAW_TIMER0_TEZ_INT_RAW = 0x8
	// Position of TIMER1_TEZ_INT_RAW field.
	MCPWM_INT_RAW_TIMER1_TEZ_INT_RAW_Pos = 0x4
	// Bit mask of TIMER1_TEZ_INT_RAW field.
	MCPWM_INT_RAW_TIMER1_TEZ_INT_RAW_Msk = 0x10
	// Bit TIMER1_TEZ_INT_RAW.
	MCPWM_INT_RAW_TIMER1_TEZ_INT_RAW = 0x10
	// Position of TIMER2_TEZ_INT_RAW field.
	MCPWM_INT_RAW_TIMER2_TEZ_INT_RAW_Pos = 0x5
	// Bit mask of TIMER2_TEZ_INT_RAW field.
	MCPWM_INT_RAW_TIMER2_TEZ_INT_RAW_Msk = 0x20
	// Bit TIMER2_TEZ_INT_RAW.
	MCPWM_INT_RAW_TIMER2_TEZ_INT_RAW = 0x20
	// Position of TIMER0_TEP_INT_RAW field.
	MCPWM_INT_RAW_TIMER0_TEP_INT_RAW_Pos = 0x6
	// Bit mask of TIMER0_TEP_INT_RAW field.
	MCPWM_INT_RAW_TIMER0_TEP_INT_RAW_Msk = 0x40
	// Bit TIMER0_TEP_INT_RAW.
	MCPWM_INT_RAW_TIMER0_TEP_INT_RAW = 0x40
	// Position of TIMER1_TEP_INT_RAW field.
	MCPWM_INT_RAW_TIMER1_TEP_INT_RAW_Pos = 0x7
	// Bit mask of TIMER1_TEP_INT_RAW field.
	MCPWM_INT_RAW_TIMER1_TEP_INT_RAW_Msk = 0x80
	// Bit TIMER1_TEP_INT_RAW.
	MCPWM_INT_RAW_TIMER1_TEP_INT_RAW = 0x80
	// Position of TIMER2_TEP_INT_RAW field.
	MCPWM_INT_RAW_TIMER2_TEP_INT_RAW_Pos = 0x8
	// Bit mask of TIMER2_TEP_INT_RAW field.
	MCPWM_INT_RAW_TIMER2_TEP_INT_RAW_Msk = 0x100
	// Bit TIMER2_TEP_INT_RAW.
	MCPWM_INT_RAW_TIMER2_TEP_INT_RAW = 0x100
	// Position of FAULT0_INT_RAW field.
	MCPWM_INT_RAW_FAULT0_INT_RAW_Pos = 0x9
	// Bit mask of FAULT0_INT_RAW field.
	MCPWM_INT_RAW_FAULT0_INT_RAW_Msk = 0x200
	// Bit FAULT0_INT_RAW.
	MCPWM_INT_RAW_FAULT0_INT_RAW = 0x200
	// Position of FAULT1_INT_RAW field.
	MCPWM_INT_RAW_FAULT1_INT_RAW_Pos = 0xa
	// Bit mask of FAULT1_INT_RAW field.
	MCPWM_INT_RAW_FAULT1_INT_RAW_Msk = 0x400
	// Bit FAULT1_INT_RAW.
	MCPWM_INT_RAW_FAULT1_INT_RAW = 0x400
	// Position of FAULT2_INT_RAW field.
	MCPWM_INT_RAW_FAULT2_INT_RAW_Pos = 0xb
	// Bit mask of FAULT2_INT_RAW field.
	MCPWM_INT_RAW_FAULT2_INT_RAW_Msk = 0x800
	// Bit FAULT2_INT_RAW.
	MCPWM_INT_RAW_FAULT2_INT_RAW = 0x800
	// Position of FAULT0_CLR_INT_RAW field.
	MCPWM_INT_RAW_FAULT0_CLR_INT_RAW_Pos = 0xc
	// Bit mask of FAULT0_CLR_INT_RAW field.
	MCPWM_INT_RAW_FAULT0_CLR_INT_RAW_Msk = 0x1000
	// Bit FAULT0_CLR_INT_RAW.
	MCPWM_INT_RAW_FAULT0_CLR_INT_RAW = 0x1000
	// Position of FAULT1_CLR_INT_RAW field.
	MCPWM_INT_RAW_FAULT1_CLR_INT_RAW_Pos = 0xd
	// Bit mask of FAULT1_CLR_INT_RAW field.
	MCPWM_INT_RAW_FAULT1_CLR_INT_RAW_Msk = 0x2000
	// Bit FAULT1_CLR_INT_RAW.
	MCPWM_INT_RAW_FAULT1_CLR_INT_RAW = 0x2000
	// Position of FAULT2_CLR_INT_RAW field.
	MCPWM_INT_RAW_FAULT2_CLR_INT_RAW_Pos = 0xe
	// Bit mask of FAULT2_CLR_INT_RAW field.
	MCPWM_INT_RAW_FAULT2_CLR_INT_RAW_Msk = 0x4000
	// Bit FAULT2_CLR_INT_RAW.
	MCPWM_INT_RAW_FAULT2_CLR_INT_RAW = 0x4000
	// Position of CMPR0_TEA_INT_RAW field.
	MCPWM_INT_RAW_CMPR0_TEA_INT_RAW_Pos = 0xf
	// Bit mask of CMPR0_TEA_INT_RAW field.
	MCPWM_INT_RAW_CMPR0_TEA_INT_RAW_Msk = 0x8000
	// Bit CMPR0_TEA_INT_RAW.
	MCPWM_INT_RAW_CMPR0_TEA_INT_RAW = 0x8000
	// Position of CMPR1_TEA_INT_RAW field.
	MCPWM_INT_RAW_CMPR1_TEA_INT_RAW_Pos = 0x10
	// Bit mask of CMPR1_TEA_INT_RAW field.
	MCPWM_INT_RAW_CMPR1_TEA_INT_RAW_Msk = 0x10000
	// Bit CMPR1_TEA_INT_RAW.
	MCPWM_INT_RAW_CMPR1_TEA_INT_RAW = 0x10000
	// Position of CMPR2_TEA_INT_RAW field.
	MCPWM_INT_RAW_CMPR2_TEA_INT_RAW_Pos = 0x11
	// Bit mask of CMPR2_TEA_INT_RAW field.
	MCPWM_INT_RAW_CMPR2_TEA_INT_RAW_Msk = 0x20000
	// Bit CMPR2_TEA_INT_RAW.
	MCPWM_INT_RAW_CMPR2_TEA_INT_RAW = 0x20000
	// Position of CMPR0_TEB_INT_RAW field.
	MCPWM_INT_RAW_CMPR0_TEB_INT_RAW_Pos = 0x12
	// Bit mask of CMPR0_TEB_INT_RAW field.
	MCPWM_INT_RAW_CMPR0_TEB_INT_RAW_Msk = 0x40000
	// Bit CMPR0_TEB_INT_RAW.
	MCPWM_INT_RAW_CMPR0_TEB_INT_RAW = 0x40000
	// Position of CMPR1_TEB_INT_RAW field.
	MCPWM_INT_RAW_CMPR1_TEB_INT_RAW_Pos = 0x13
	// Bit mask of CMPR1_TEB_INT_RAW field.
	MCPWM_INT_RAW_CMPR1_TEB_INT_RAW_Msk = 0x80000
	// Bit CMPR1_TEB_INT_RAW.
	MCPWM_INT_RAW_CMPR1_TEB_INT_RAW = 0x80000
	// Position of CMPR2_TEB_INT_RAW field.
	MCPWM_INT_RAW_CMPR2_TEB_INT_RAW_Pos = 0x14
	// Bit mask of CMPR2_TEB_INT_RAW field.
	MCPWM_INT_RAW_CMPR2_TEB_INT_RAW_Msk = 0x100000
	// Bit CMPR2_TEB_INT_RAW.
	MCPWM_INT_RAW_CMPR2_TEB_INT_RAW = 0x100000
	// Position of TZ0_CBC_INT_RAW field.
	MCPWM_INT_RAW_TZ0_CBC_INT_RAW_Pos = 0x15
	// Bit mask of TZ0_CBC_INT_RAW field.
	MCPWM_INT_RAW_TZ0_CBC_INT_RAW_Msk = 0x200000
	// Bit TZ0_CBC_INT_RAW.
	MCPWM_INT_RAW_TZ0_CBC_INT_RAW = 0x200000
	// Position of TZ1_CBC_INT_RAW field.
	MCPWM_INT_RAW_TZ1_CBC_INT_RAW_Pos = 0x16
	// Bit mask of TZ1_CBC_INT_RAW field.
	MCPWM_INT_RAW_TZ1_CBC_INT_RAW_Msk = 0x400000
	// Bit TZ1_CBC_INT_RAW.
	MCPWM_INT_RAW_TZ1_CBC_INT_RAW = 0x400000
	// Position of TZ2_CBC_INT_RAW field.
	MCPWM_INT_RAW_TZ2_CBC_INT_RAW_Pos = 0x17
	// Bit mask of TZ2_CBC_INT_RAW field.
	MCPWM_INT_RAW_TZ2_CBC_INT_RAW_Msk = 0x800000
	// Bit TZ2_CBC_INT_RAW.
	MCPWM_INT_RAW_TZ2_CBC_INT_RAW = 0x800000
	// Position of TZ0_OST_INT_RAW field.
	MCPWM_INT_RAW_TZ0_OST_INT_RAW_Pos = 0x18
	// Bit mask of TZ0_OST_INT_RAW field.
	MCPWM_INT_RAW_TZ0_OST_INT_RAW_Msk = 0x1000000
	// Bit TZ0_OST_INT_RAW.
	MCPWM_INT_RAW_TZ0_OST_INT_RAW = 0x1000000
	// Position of TZ1_OST_INT_RAW field.
	MCPWM_INT_RAW_TZ1_OST_INT_RAW_Pos = 0x19
	// Bit mask of TZ1_OST_INT_RAW field.
	MCPWM_INT_RAW_TZ1_OST_INT_RAW_Msk = 0x2000000
	// Bit TZ1_OST_INT_RAW.
	MCPWM_INT_RAW_TZ1_OST_INT_RAW = 0x2000000
	// Position of TZ2_OST_INT_RAW field.
	MCPWM_INT_RAW_TZ2_OST_INT_RAW_Pos = 0x1a
	// Bit mask of TZ2_OST_INT_RAW field.
	MCPWM_INT_RAW_TZ2_OST_INT_RAW_Msk = 0x4000000
	// Bit TZ2_OST_INT_RAW.
	MCPWM_INT_RAW_TZ2_OST_INT_RAW = 0x4000000
	// Position of CAP0_INT_RAW field.
	MCPWM_INT_RAW_CAP0_INT_RAW_Pos = 0x1b
	// Bit mask of CAP0_INT_RAW field.
	MCPWM_INT_RAW_CAP0_INT_RAW_Msk = 0x8000000
	// Bit CAP0_INT_RAW.
	MCPWM_INT_RAW_CAP0_INT_RAW = 0x8000000
	// Position of CAP1_INT_RAW field.
	MCPWM_INT_RAW_CAP1_INT_RAW_Pos = 0x1c
	// Bit mask of CAP1_INT_RAW field.
	MCPWM_INT_RAW_CAP1_INT_RAW_Msk = 0x10000000
	// Bit CAP1_INT_RAW.
	MCPWM_INT_RAW_CAP1_INT_RAW = 0x10000000
	// Position of CAP2_INT_RAW field.
	MCPWM_INT_RAW_CAP2_INT_RAW_Pos = 0x1d
	// Bit mask of CAP2_INT_RAW field.
	MCPWM_INT_RAW_CAP2_INT_RAW_Msk = 0x20000000
	// Bit CAP2_INT_RAW.
	MCPWM_INT_RAW_CAP2_INT_RAW = 0x20000000

	// INT_ST: Masked interrupt status
	// Position of TIMER0_STOP_INT_ST field.
	MCPWM_INT_ST_TIMER0_STOP_INT_ST_Pos = 0x0
	// Bit mask of TIMER0_STOP_INT_ST field.
	MCPWM_INT_ST_TIMER0_STOP_INT_ST_Msk = 0x1
	// Bit TIMER0_STOP_INT_ST.
	MCPWM_INT_ST_TIMER0_STOP_INT_ST = 0x1
	// Position of TIMER1_STOP_INT_ST field.
	MCPWM_INT_ST_TIMER1_STOP_INT_ST_Pos = 0x1
	// Bit mask of TIMER1_STOP_INT_ST field.
	MCPWM_INT_ST_TIMER1_STOP_INT_ST_Msk = 0x2
	// Bit TIMER1_STOP_INT_ST.
	MCPWM_INT_ST_TIMER1_STOP_INT_ST = 0x2
	// Position of TIMER2_STOP_INT_ST field.
	MCPWM_INT_ST_TIMER2_STOP_INT_ST_Pos = 0x2
	// Bit mask of TIMER2_STOP_INT_ST field.
	MCPWM_INT_ST_TIMER2_STOP_INT_ST_Msk = 0x4
	// Bit TIMER2_STOP_INT_ST.
	MCPWM_INT_ST_TIMER2_STOP_INT_ST = 0x4
	// Position of TIMER0_TEZ_INT_ST field.
	MCPWM_INT_ST_TIMER0_TEZ_INT_ST_Pos = 0x3
	// Bit mask of TIMER0_TEZ_INT_ST field.
	MCPWM_INT_ST_TIMER0_TEZ_INT_ST_Msk = 0x8
	// Bit TIMER0_TEZ_INT_ST.
	MCPWM_INT_ST_TIMER0_TEZ_INT_ST = 0x8
	// Position of TIMER1_TEZ_INT_ST field.
	MCPWM_INT_ST_TIMER1_TEZ_INT_ST_Pos = 0x4
	// Bit mask of TIMER1_TEZ_INT_ST field.
	MCPWM_INT_ST_TIMER1_TEZ_INT_ST_Msk = 0x10
	// Bit TIMER1_TEZ_INT_ST.
	MCPWM_INT_ST_TIMER1_TEZ_INT_ST = 0x10
	// Position of TIMER2_TEZ_INT_ST field.
	MCPWM_INT_ST_TIMER2_TEZ_INT_ST_Pos = 0x5
	// Bit mask of TIMER2_TEZ_INT_ST field.
	MCPWM_INT_ST_TIMER2_TEZ_INT_ST_Msk = 0x20
	// Bit TIMER2_TEZ_INT_ST.
	MCPWM_INT_ST_TIMER2_TEZ_INT_ST = 0x20
	// Position of TIMER0_TEP_INT_ST field.
	MCPWM_INT_ST_TIMER0_TEP_INT_ST_Pos = 0x6
	// Bit mask of TIMER0_TEP_INT_ST field.
	MCPWM_INT_ST_TIMER0_TEP_INT_ST_Msk = 0x40
	// Bit TIMER0_TEP_INT_ST.
	MCPWM_INT_ST_TIMER0_TEP_INT_ST = 0x40
	// Position of TIMER1_TEP_INT_ST field.
	MCPWM_INT_ST_TIMER1_TEP_INT_ST_Pos = 0x7
	// Bit mask of TIMER1_TEP_INT_ST field.
	MCPWM_INT_ST_TIMER1_TEP_INT_ST_Msk = 0x80
	// Bit TIMER1_TEP_INT_ST.
	MCPWM_INT_ST_TIMER1_TEP_INT_ST = 0x80
	// Position of TIMER2_TEP_INT_ST field.
	MCPWM_INT_ST_TIMER2_TEP_INT_ST_Pos = 0x8
	// Bit mask of TIMER2_TEP_INT_ST field.
	MCPWM_INT_ST_TIMER2_TEP_INT_ST_Msk = 0x100
	// Bit TIMER2_TEP_INT_ST.
	MCPWM_INT_ST_TIMER2_TEP_INT_ST = 0x100
	// Position of FAULT0_INT_ST field.
	MCPWM_INT_ST_FAULT0_INT_ST_Pos = 0x9
	// Bit mask of FAULT0_INT_ST field.
	MCPWM_INT_ST_FAULT0_INT_ST_Msk = 0x200
	// Bit FAULT0_INT_ST.
	MCPWM_INT_ST_FAULT0_INT_ST = 0x200
	// Position of FAULT1_INT_ST field.
	MCPWM_INT_ST_FAULT1_INT_ST_Pos = 0xa
	// Bit mask of FAULT1_INT_ST field.
	MCPWM_INT_ST_FAULT1_INT_ST_Msk = 0x400
	// Bit FAULT1_INT_ST.
	MCPWM_INT_ST_FAULT1_INT_ST = 0x400
	// Position of FAULT2_INT_ST field.
	MCPWM_INT_ST_FAULT2_INT_ST_Pos = 0xb
	// Bit mask of FAULT2_INT_ST field.
	MCPWM_INT_ST_FAULT2_INT_ST_Msk = 0x800
	// Bit FAULT2_INT_ST.
	MCPWM_INT_ST_FAULT2_INT_ST = 0x800
	// Position of FAULT0_CLR_INT_ST field.
	MCPWM_INT_ST_FAULT0_CLR_INT_ST_Pos = 0xc
	// Bit mask of FAULT0_CLR_INT_ST field.
	MCPWM_INT_ST_FAULT0_CLR_INT_ST_Msk = 0x1000
	// Bit FAULT0_CLR_INT_ST.
	MCPWM_INT_ST_FAULT0_CLR_INT_ST = 0x1000
	// Position of FAULT1_CLR_INT_ST field.
	MCPWM_INT_ST_FAULT1_CLR_INT_ST_Pos = 0xd
	// Bit mask of FAULT1_CLR_INT_ST field.
	MCPWM_INT_ST_FAULT1_CLR_INT_ST_Msk = 0x2000
	// Bit FAULT1_CLR_INT_ST.
	MCPWM_INT_ST_FAULT1_CLR_INT_ST = 0x2000
	// Position of FAULT2_CLR_INT_ST field.
	MCPWM_INT_ST_FAULT2_CLR_INT_ST_Pos = 0xe
	// Bit mask of FAULT2_CLR_INT_ST field.
	MCPWM_INT_ST_FAULT2_CLR_INT_ST_Msk = 0x4000
	// Bit FAULT2_CLR_INT_ST.
	MCPWM_INT_ST_FAULT2_CLR_INT_ST = 0x4000
	// Position of CMPR0_TEA_INT_ST field.
	MCPWM_INT_ST_CMPR0_TEA_INT_ST_Pos = 0xf
	// Bit mask of CMPR0_TEA_INT_ST field.
	MCPWM_INT_ST_CMPR0_TEA_INT_ST_Msk = 0x8000
	// Bit CMPR0_TEA_INT_ST.
	MCPWM_INT_ST_CMPR0_TEA_INT_ST = 0x8000
	// Position of CMPR1_TEA_INT_ST field.
	MCPWM_INT_ST_CMPR1_TEA_INT_ST_Pos = 0x10
	// Bit mask of CMPR1_TEA_INT_ST field.
	MCPWM_INT_ST_CMPR1_TEA_INT_ST_Msk = 0x10000
	// Bit CMPR1_TEA_INT_ST.
	MCPWM_INT_ST_CMPR1_TEA_INT_ST = 0x10000
	// Position of CMPR2_TEA_INT_ST field.
	MCPWM_INT_ST_CMPR2_TEA_INT_ST_Pos = 0x11
	// Bit mask of CMPR2_TEA_INT_ST field.
	MCPWM_INT_ST_CMPR2_TEA_INT_ST_Msk = 0x20000
	// Bit CMPR2_TEA_INT_ST.
	MCPWM_INT_ST_CMPR2_TEA_INT_ST = 0x20000
	// Position of CMPR0_TEB_INT_ST field.
	MCPWM_INT_ST_CMPR0_TEB_INT_ST_Pos = 0x12
	// Bit mask of CMPR0_TEB_INT_ST field.
	MCPWM_INT_ST_CMPR0_TEB_INT_ST_Msk = 0x40000
	// Bit CMPR0_TEB_INT_ST.
	MCPWM_INT_ST_CMPR0_TEB_INT_ST = 0x40000
	// Position of CMPR1_TEB_INT_ST field.
	MCPWM_INT_ST_CMPR1_TEB_INT_ST_Pos = 0x13
	// Bit mask of CMPR1_TEB_INT_ST field.
	MCPWM_INT_ST_CMPR1_TEB_INT_ST_Msk = 0x80000
	// Bit CMPR1_TEB_INT_ST.
	MCPWM_INT_ST_CMPR1_TEB_INT_ST = 0x80000
	// Position of CMPR2_TEB_INT_ST field.
	MCPWM_INT_ST_CMPR2_TEB_INT_ST_Pos = 0x14
	// Bit mask of CMPR2_TEB_INT_ST field.
	MCPWM_INT_ST_CMPR2_TEB_INT_ST_Msk = 0x100000
	// Bit CMPR2_TEB_INT_ST.
	MCPWM_INT_ST_CMPR2_TEB_INT_ST = 0x100000
	// Position of TZ0_CBC_INT_ST field.
	MCPWM_INT_ST_TZ0_CBC_INT_ST_Pos = 0x15
	// Bit mask of TZ0_CBC_INT_ST field.
	MCPWM_INT_ST_TZ0_CBC_INT_ST_Msk = 0x200000
	// Bit TZ0_CBC_INT_ST.
	MCPWM_INT_ST_TZ0_CBC_INT_ST = 0x200000
	// Position of TZ1_CBC_INT_ST field.
	MCPWM_INT_ST_TZ1_CBC_INT_ST_Pos = 0x16
	// Bit mask of TZ1_CBC_INT_ST field.
	MCPWM_INT_ST_TZ1_CBC_INT_ST_Msk = 0x400000
	// Bit TZ1_CBC_INT_ST.
	MCPWM_INT_ST_TZ1_CBC_INT_ST = 0x400000
	// Position of TZ2_CBC_INT_ST field.
	MCPWM_INT_ST_TZ2_CBC_INT_ST_Pos = 0x17
	// Bit mask of TZ2_CBC_INT_ST field.
	MCPWM_INT_ST_TZ2_CBC_INT_ST_Msk = 0x800000
	// Bit TZ2_CBC_INT_ST.
	MCPWM_INT_ST_TZ2_CBC_INT_ST = 0x800000
	// Position of TZ0_OST_INT_ST field.
	MCPWM_INT_ST_TZ0_OST_INT_ST_Pos = 0x18
	// Bit mask of TZ0_OST_INT_ST field.
	MCPWM_INT_ST_TZ0_OST_INT_ST_Msk = 0x1000000
	// Bit TZ0_OST_INT_ST.
	MCPWM_INT_ST_TZ0_OST_INT_ST = 0x1000000
	// Position of TZ1_OST_INT_ST field.
	MCPWM_INT_ST_TZ1_OST_INT_ST_Pos = 0x19
	// Bit mask of TZ1_OST_INT_ST field.
	MCPWM_INT_ST_TZ1_OST_INT_ST_Msk = 0x2000000
	// Bit TZ1_OST_INT_ST.
	MCPWM_INT_ST_TZ1_OST_INT_ST = 0x2000000
	// Position of TZ2_OST_INT_ST field.
	MCPWM_INT_ST_TZ2_OST_INT_ST_Pos = 0x1a
	// Bit mask of TZ2_OST_INT_ST field.
	MCPWM_INT_ST_TZ2_OST_INT_ST_Msk = 0x4000000
	// Bit TZ2_OST_INT_ST.
	MCPWM_INT_ST_TZ2_OST_INT_ST = 0x4000000
	// Position of CAP0_INT_ST field.
	MCPWM_INT_ST_CAP0_INT_ST_Pos = 0x1b
	// Bit mask of CAP0_INT_ST field.
	MCPWM_INT_ST_CAP0_INT_ST_Msk = 0x8000000
	// Bit CAP0_INT_ST.
	MCPWM_INT_ST_CAP0_INT_ST = 0x8000000
	// Position of CAP1_INT_ST field.
	MCPWM_INT_ST_CAP1_INT_ST_Pos = 0x1c
	// Bit mask of CAP1_INT_ST field.
	MCPWM_INT_ST_CAP1_INT_ST_Msk = 0x10000000
	// Bit CAP1_INT_ST.
	MCPWM_INT_ST_CAP1_INT_ST = 0x10000000
	// Position of CAP2_INT_ST field.
	MCPWM_INT_ST_CAP2_INT_ST_Pos = 0x1d
	// Bit mask of CAP2_INT_ST field.
	MCPWM_INT_ST_CAP2_INT_ST_Msk = 0x20000000
	// Bit CAP2_INT_ST.
	MCPWM_INT_ST_CAP2_INT_ST = 0x20000000

	// INT_CLR: Interrupt clear bits
	// Position of TIMER0_STOP_INT_CLR field.
	MCPWM_INT_CLR_TIMER0_STOP_INT_CLR_Pos = 0x0
	// Bit mask of TIMER0_STOP_INT_CLR field.
	MCPWM_INT_CLR_TIMER0_STOP_INT_CLR_Msk = 0x1
	// Bit TIMER0_STOP_INT_CLR.
	MCPWM_INT_CLR_TIMER0_STOP_INT_CLR = 0x1
	// Position of TIMER1_STOP_INT_CLR field.
	MCPWM_INT_CLR_TIMER1_STOP_INT_CLR_Pos = 0x1
	// Bit mask of TIMER1_STOP_INT_CLR field.
	MCPWM_INT_CLR_TIMER1_STOP_INT_CLR_Msk = 0x2
	// Bit TIMER1_STOP_INT_CLR.
	MCPWM_INT_CLR_TIMER1_STOP_INT_CLR = 0x2
	// Position of TIMER2_STOP_INT_CLR field.
	MCPWM_INT_CLR_TIMER2_STOP_INT_CLR_Pos = 0x2
	// Bit mask of TIMER2_STOP_INT_CLR field.
	MCPWM_INT_CLR_TIMER2_STOP_INT_CLR_Msk = 0x4
	// Bit TIMER2_STOP_INT_CLR.
	MCPWM_INT_CLR_TIMER2_STOP_INT_CLR = 0x4
	// Position of TIMER0_TEZ_INT_CLR field.
	MCPWM_INT_CLR_TIMER0_TEZ_INT_CLR_Pos = 0x3
	// Bit mask of TIMER0_TEZ_INT_CLR field.
	MCPWM_INT_CLR_TIMER0_TEZ_INT_CLR_Msk = 0x8
	// Bit TIMER0_TEZ_INT_CLR.
	MCPWM_INT_CLR_TIMER0_TEZ_INT_CLR = 0x8
	// Position of TIMER1_TEZ_INT_CLR field.
	MCPWM_INT_CLR_TIMER1_TEZ_INT_CLR_Pos = 0x4
	// Bit mask of TIMER1_TEZ_INT_CLR field.
	MCPWM_INT_CLR_TIMER1_TEZ_INT_CLR_Msk = 0x10
	// Bit TIMER1_TEZ_INT_CLR.
	MCPWM_INT_CLR_TIMER1_TEZ_INT_CLR = 0x10
	// Position of TIMER2_TEZ_INT_CLR field.
	MCPWM_INT_CLR_TIMER2_TEZ_INT_CLR_Pos = 0x5
	// Bit mask of TIMER2_TEZ_INT_CLR field.
	MCPWM_INT_CLR_TIMER2_TEZ_INT_CLR_Msk = 0x20
	// Bit TIMER2_TEZ_INT_CLR.
	MCPWM_INT_CLR_TIMER2_TEZ_INT_CLR = 0x20
	// Position of TIMER0_TEP_INT_CLR field.
	MCPWM_INT_CLR_TIMER0_TEP_INT_CLR_Pos = 0x6
	// Bit mask of TIMER0_TEP_INT_CLR field.
	MCPWM_INT_CLR_TIMER0_TEP_INT_CLR_Msk = 0x40
	// Bit TIMER0_TEP_INT_CLR.
	MCPWM_INT_CLR_TIMER0_TEP_INT_CLR = 0x40
	// Position of TIMER1_TEP_INT_CLR field.
	MCPWM_INT_CLR_TIMER1_TEP_INT_CLR_Pos = 0x7
	// Bit mask of TIMER1_TEP_INT_CLR field.
	MCPWM_INT_CLR_TIMER1_TEP_INT_CLR_Msk = 0x80
	// Bit TIMER1_TEP_INT_CLR.
	MCPWM_INT_CLR_TIMER1_TEP_INT_CLR = 0x80
	// Position of TIMER2_TEP_INT_CLR field.
	MCPWM_INT_CLR_TIMER2_TEP_INT_CLR_Pos = 0x8
	// Bit mask of TIMER2_TEP_INT_CLR field.
	MCPWM_INT_CLR_TIMER2_TEP_INT_CLR_Msk = 0x100
	// Bit TIMER2_TEP_INT_CLR.
	MCPWM_INT_CLR_TIMER2_TEP_INT_CLR = 0x100
	// Position of FAULT0_INT_CLR field.
	MCPWM_INT_CLR_FAULT0_INT_CLR_Pos = 0x9
	// Bit mask of FAULT0_INT_CLR field.
	MCPWM_INT_CLR_FAULT0_INT_CLR_Msk = 0x200
	// Bit FAULT0_INT_CLR.
	MCPWM_INT_CLR_FAULT0_INT_CLR = 0x200
	// Position of FAULT1_INT_CLR field.
	MCPWM_INT_CLR_FAULT1_INT_CLR_Pos = 0xa
	// Bit mask of FAULT1_INT_CLR field.
	MCPWM_INT_CLR_FAULT1_INT_CLR_Msk = 0x400
	// Bit FAULT1_INT_CLR.
	MCPWM_INT_CLR_FAULT1_INT_CLR = 0x400
	// Position of FAULT2_INT_CLR field.
	MCPWM_INT_CLR_FAULT2_INT_CLR_Pos = 0xb
	// Bit mask of FAULT2_INT_CLR field.
	MCPWM_INT_CLR_FAULT2_INT_CLR_Msk = 0x800
	// Bit FAULT2_INT_CLR.
	MCPWM_INT_CLR_FAULT2_INT_CLR = 0x800
	// Position of FAULT0_CLR_INT_CLR field.
	MCPWM_INT_CLR_FAULT0_CLR_INT_CLR_Pos = 0xc
	// Bit mask of FAULT0_CLR_INT_CLR field.
	MCPWM_INT_CLR_FAULT0_CLR_INT_CLR_Msk = 0x1000
	// Bit FAULT0_CLR_INT_CLR.
	MCPWM_INT_CLR_FAULT0_CLR_INT_CLR = 0x1000
	// Position of FAULT1_CLR_INT_CLR field.
	MCPWM_INT_CLR_FAULT1_CLR_INT_CLR_Pos = 0xd
	// Bit mask of FAULT1_CLR_INT_CLR field.
	MCPWM_INT_CLR_FAULT1_CLR_INT_CLR_Msk = 0x2000
	// Bit FAULT1_CLR_INT_CLR.
	MCPWM_INT_CLR_FAULT1_CLR_INT_CLR = 0x2000
	// Position of FAULT2_CLR_INT_CLR field.
	MCPWM_INT_CLR_FAULT2_CLR_INT_CLR_Pos = 0xe
	// Bit mask of FAULT2_CLR_INT_CLR field.
	MCPWM_INT_CLR_FAULT2_CLR_INT_CLR_Msk = 0x4000
	// Bit FAULT2_CLR_INT_CLR.
	MCPWM_INT_CLR_FAULT2_CLR_INT_CLR = 0x4000
	// Position of CMPR0_TEA_INT_CLR field.
	MCPWM_INT_CLR_CMPR0_TEA_INT_CLR_Pos = 0xf
	// Bit mask of CMPR0_TEA_INT_CLR field.
	MCPWM_INT_CLR_CMPR0_TEA_INT_CLR_Msk = 0x8000
	// Bit CMPR0_TEA_INT_CLR.
	MCPWM_INT_CLR_CMPR0_TEA_INT_CLR = 0x8000
	// Position of CMPR1_TEA_INT_CLR field.
	MCPWM_INT_CLR_CMPR1_TEA_INT_CLR_Pos = 0x10
	// Bit mask of CMPR1_TEA_INT_CLR field.
	MCPWM_INT_CLR_CMPR1_TEA_INT_CLR_Msk = 0x10000
	// Bit CMPR1_TEA_INT_CLR.
	MCPWM_INT_CLR_CMPR1_TEA_INT_CLR = 0x10000
	// Position of CMPR2_TEA_INT_CLR field.
	MCPWM_INT_CLR_CMPR2_TEA_INT_CLR_Pos = 0x11
	// Bit mask of CMPR2_TEA_INT_CLR field.
	MCPWM_INT_CLR_CMPR2_TEA_INT_CLR_Msk = 0x20000
	// Bit CMPR2_TEA_INT_CLR.
	MCPWM_INT_CLR_CMPR2_TEA_INT_CLR = 0x20000
	// Position of CMPR0_TEB_INT_CLR field.
	MCPWM_INT_CLR_CMPR0_TEB_INT_CLR_Pos = 0x12
	// Bit mask of CMPR0_TEB_INT_CLR field.
	MCPWM_INT_CLR_CMPR0_TEB_INT_CLR_Msk = 0x40000
	// Bit CMPR0_TEB_INT_CLR.
	MCPWM_INT_CLR_CMPR0_TEB_INT_CLR = 0x40000
	// Position of CMPR1_TEB_INT_CLR field.
	MCPWM_INT_CLR_CMPR1_TEB_INT_CLR_Pos = 0x13
	// Bit mask of CMPR1_TEB_INT_CLR field.
	MCPWM_INT_CLR_CMPR1_TEB_INT_CLR_Msk = 0x80000
	// Bit CMPR1_TEB_INT_CLR.
	MCPWM_INT_CLR_CMPR1_TEB_INT_CLR = 0x80000
	// Position of CMPR2_TEB_INT_CLR field.
	MCPWM_INT_CLR_CMPR2_TEB_INT_CLR_Pos = 0x14
	// Bit mask of CMPR2_TEB_INT_CLR field.
	MCPWM_INT_CLR_CMPR2_TEB_INT_CLR_Msk = 0x100000
	// Bit CMPR2_TEB_INT_CLR.
	MCPWM_INT_CLR_CMPR2_TEB_INT_CLR = 0x100000
	// Position of TZ0_CBC_INT_CLR field.
	MCPWM_INT_CLR_TZ0_CBC_INT_CLR_Pos = 0x15
	// Bit mask of TZ0_CBC_INT_CLR field.
	MCPWM_INT_CLR_TZ0_CBC_INT_CLR_Msk = 0x200000
	// Bit TZ0_CBC_INT_CLR.
	MCPWM_INT_CLR_TZ0_CBC_INT_CLR = 0x200000
	// Position of TZ1_CBC_INT_CLR field.
	MCPWM_INT_CLR_TZ1_CBC_INT_CLR_Pos = 0x16
	// Bit mask of TZ1_CBC_INT_CLR field.
	MCPWM_INT_CLR_TZ1_CBC_INT_CLR_Msk = 0x400000
	// Bit TZ1_CBC_INT_CLR.
	MCPWM_INT_CLR_TZ1_CBC_INT_CLR = 0x400000
	// Position of TZ2_CBC_INT_CLR field.
	MCPWM_INT_CLR_TZ2_CBC_INT_CLR_Pos = 0x17
	// Bit mask of TZ2_CBC_INT_CLR field.
	MCPWM_INT_CLR_TZ2_CBC_INT_CLR_Msk = 0x800000
	// Bit TZ2_CBC_INT_CLR.
	MCPWM_INT_CLR_TZ2_CBC_INT_CLR = 0x800000
	// Position of TZ0_OST_INT_CLR field.
	MCPWM_INT_CLR_TZ0_OST_INT_CLR_Pos = 0x18
	// Bit mask of TZ0_OST_INT_CLR field.
	MCPWM_INT_CLR_TZ0_OST_INT_CLR_Msk = 0x1000000
	// Bit TZ0_OST_INT_CLR.
	MCPWM_INT_CLR_TZ0_OST_INT_CLR = 0x1000000
	// Position of TZ1_OST_INT_CLR field.
	MCPWM_INT_CLR_TZ1_OST_INT_CLR_Pos = 0x19
	// Bit mask of TZ1_OST_INT_CLR field.
	MCPWM_INT_CLR_TZ1_OST_INT_CLR_Msk = 0x2000000
	// Bit TZ1_OST_INT_CLR.
	MCPWM_INT_CLR_TZ1_OST_INT_CLR = 0x2000000
	// Position of TZ2_OST_INT_CLR field.
	MCPWM_INT_CLR_TZ2_OST_INT_CLR_Pos = 0x1a
	// Bit mask of TZ2_OST_INT_CLR field.
	MCPWM_INT_CLR_TZ2_OST_INT_CLR_Msk = 0x4000000
	// Bit TZ2_OST_INT_CLR.
	MCPWM_INT_CLR_TZ2_OST_INT_CLR = 0x4000000
	// Position of CAP0_INT_CLR field.
	MCPWM_INT_CLR_CAP0_INT_CLR_Pos = 0x1b
	// Bit mask of CAP0_INT_CLR field.
	MCPWM_INT_CLR_CAP0_INT_CLR_Msk = 0x8000000
	// Bit CAP0_INT_CLR.
	MCPWM_INT_CLR_CAP0_INT_CLR = 0x8000000
	// Position of CAP1_INT_CLR field.
	MCPWM_INT_CLR_CAP1_INT_CLR_Pos = 0x1c
	// Bit mask of CAP1_INT_CLR field.
	MCPWM_INT_CLR_CAP1_INT_CLR_Msk = 0x10000000
	// Bit CAP1_INT_CLR.
	MCPWM_INT_CLR_CAP1_INT_CLR = 0x10000000
	// Position of CAP2_INT_CLR field.
	MCPWM_INT_CLR_CAP2_INT_CLR_Pos = 0x1d
	// Bit mask of CAP2_INT_CLR field.
	MCPWM_INT_CLR_CAP2_INT_CLR_Msk = 0x20000000
	// Bit CAP2_INT_CLR.
	MCPWM_INT_CLR_CAP2_INT_CLR = 0x20000000

	// EVT_EN: MCPWM event enable register
	// Position of EVT_TIMER0_STOP_EN field.
	MCPWM_EVT_EN_EVT_TIMER0_STOP_EN_Pos = 0x0
	// Bit mask of EVT_TIMER0_STOP_EN field.
	MCPWM_EVT_EN_EVT_TIMER0_STOP_EN_Msk = 0x1
	// Bit EVT_TIMER0_STOP_EN.
	MCPWM_EVT_EN_EVT_TIMER0_STOP_EN = 0x1
	// Position of EVT_TIMER1_STOP_EN field.
	MCPWM_EVT_EN_EVT_TIMER1_STOP_EN_Pos = 0x1
	// Bit mask of EVT_TIMER1_STOP_EN field.
	MCPWM_EVT_EN_EVT_TIMER1_STOP_EN_Msk = 0x2
	// Bit EVT_TIMER1_STOP_EN.
	MCPWM_EVT_EN_EVT_TIMER1_STOP_EN = 0x2
	// Position of EVT_TIMER2_STOP_EN field.
	MCPWM_EVT_EN_EVT_TIMER2_STOP_EN_Pos = 0x2
	// Bit mask of EVT_TIMER2_STOP_EN field.
	MCPWM_EVT_EN_EVT_TIMER2_STOP_EN_Msk = 0x4
	// Bit EVT_TIMER2_STOP_EN.
	MCPWM_EVT_EN_EVT_TIMER2_STOP_EN = 0x4
	// Position of EVT_TIMER0_TEZ_EN field.
	MCPWM_EVT_EN_EVT_TIMER0_TEZ_EN_Pos = 0x3
	// Bit mask of EVT_TIMER0_TEZ_EN field.
	MCPWM_EVT_EN_EVT_TIMER0_TEZ_EN_Msk = 0x8
	// Bit EVT_TIMER0_TEZ_EN.
	MCPWM_EVT_EN_EVT_TIMER0_TEZ_EN = 0x8
	// Position of EVT_TIMER1_TEZ_EN field.
	MCPWM_EVT_EN_EVT_TIMER1_TEZ_EN_Pos = 0x4
	// Bit mask of EVT_TIMER1_TEZ_EN field.
	MCPWM_EVT_EN_EVT_TIMER1_TEZ_EN_Msk = 0x10
	// Bit EVT_TIMER1_TEZ_EN.
	MCPWM_EVT_EN_EVT_TIMER1_TEZ_EN = 0x10
	// Position of EVT_TIMER2_TEZ_EN field.
	MCPWM_EVT_EN_EVT_TIMER2_TEZ_EN_Pos = 0x5
	// Bit mask of EVT_TIMER2_TEZ_EN field.
	MCPWM_EVT_EN_EVT_TIMER2_TEZ_EN_Msk = 0x20
	// Bit EVT_TIMER2_TEZ_EN.
	MCPWM_EVT_EN_EVT_TIMER2_TEZ_EN = 0x20
	// Position of EVT_TIMER0_TEP_EN field.
	MCPWM_EVT_EN_EVT_TIMER0_TEP_EN_Pos = 0x6
	// Bit mask of EVT_TIMER0_TEP_EN field.
	MCPWM_EVT_EN_EVT_TIMER0_TEP_EN_Msk = 0x40
	// Bit EVT_TIMER0_TEP_EN.
	MCPWM_EVT_EN_EVT_TIMER0_TEP_EN = 0x40
	// Position of EVT_TIMER1_TEP_EN field.
	MCPWM_EVT_EN_EVT_TIMER1_TEP_EN_Pos = 0x7
	// Bit mask of EVT_TIMER1_TEP_EN field.
	MCPWM_EVT_EN_EVT_TIMER1_TEP_EN_Msk = 0x80
	// Bit EVT_TIMER1_TEP_EN.
	MCPWM_EVT_EN_EVT_TIMER1_TEP_EN = 0x80
	// Position of EVT_TIMER2_TEP_EN field.
	MCPWM_EVT_EN_EVT_TIMER2_TEP_EN_Pos = 0x8
	// Bit mask of EVT_TIMER2_TEP_EN field.
	MCPWM_EVT_EN_EVT_TIMER2_TEP_EN_Msk = 0x100
	// Bit EVT_TIMER2_TEP_EN.
	MCPWM_EVT_EN_EVT_TIMER2_TEP_EN = 0x100
	// Position of EVT_OP0_TEA_EN field.
	MCPWM_EVT_EN_EVT_OP0_TEA_EN_Pos = 0x9
	// Bit mask of EVT_OP0_TEA_EN field.
	MCPWM_EVT_EN_EVT_OP0_TEA_EN_Msk = 0x200
	// Bit EVT_OP0_TEA_EN.
	MCPWM_EVT_EN_EVT_OP0_TEA_EN = 0x200
	// Position of EVT_OP1_TEA_EN field.
	MCPWM_EVT_EN_EVT_OP1_TEA_EN_Pos = 0xa
	// Bit mask of EVT_OP1_TEA_EN field.
	MCPWM_EVT_EN_EVT_OP1_TEA_EN_Msk = 0x400
	// Bit EVT_OP1_TEA_EN.
	MCPWM_EVT_EN_EVT_OP1_TEA_EN = 0x400
	// Position of EVT_OP2_TEA_EN field.
	MCPWM_EVT_EN_EVT_OP2_TEA_EN_Pos = 0xb
	// Bit mask of EVT_OP2_TEA_EN field.
	MCPWM_EVT_EN_EVT_OP2_TEA_EN_Msk = 0x800
	// Bit EVT_OP2_TEA_EN.
	MCPWM_EVT_EN_EVT_OP2_TEA_EN = 0x800
	// Position of EVT_OP0_TEB_EN field.
	MCPWM_EVT_EN_EVT_OP0_TEB_EN_Pos = 0xc
	// Bit mask of EVT_OP0_TEB_EN field.
	MCPWM_EVT_EN_EVT_OP0_TEB_EN_Msk = 0x1000
	// Bit EVT_OP0_TEB_EN.
	MCPWM_EVT_EN_EVT_OP0_TEB_EN = 0x1000
	// Position of EVT_OP1_TEB_EN field.
	MCPWM_EVT_EN_EVT_OP1_TEB_EN_Pos = 0xd
	// Bit mask of EVT_OP1_TEB_EN field.
	MCPWM_EVT_EN_EVT_OP1_TEB_EN_Msk = 0x2000
	// Bit EVT_OP1_TEB_EN.
	MCPWM_EVT_EN_EVT_OP1_TEB_EN = 0x2000
	// Position of EVT_OP2_TEB_EN field.
	MCPWM_EVT_EN_EVT_OP2_TEB_EN_Pos = 0xe
	// Bit mask of EVT_OP2_TEB_EN field.
	MCPWM_EVT_EN_EVT_OP2_TEB_EN_Msk = 0x4000
	// Bit EVT_OP2_TEB_EN.
	MCPWM_EVT_EN_EVT_OP2_TEB_EN = 0x4000
	// Position of EVT_F0_EN field.
	MCPWM_EVT_EN_EVT_F0_EN_Pos = 0xf
	// Bit mask of EVT_F0_EN field.
	MCPWM_EVT_EN_EVT_F0_EN_Msk = 0x8000
	// Bit EVT_F0_EN.
	MCPWM_EVT_EN_EVT_F0_EN = 0x8000
	// Position of EVT_F1_EN field.
	MCPWM_EVT_EN_EVT_F1_EN_Pos = 0x10
	// Bit mask of EVT_F1_EN field.
	MCPWM_EVT_EN_EVT_F1_EN_Msk = 0x10000
	// Bit EVT_F1_EN.
	MCPWM_EVT_EN_EVT_F1_EN = 0x10000
	// Position of EVT_F2_EN field.
	MCPWM_EVT_EN_EVT_F2_EN_Pos = 0x11
	// Bit mask of EVT_F2_EN field.
	MCPWM_EVT_EN_EVT_F2_EN_Msk = 0x20000
	// Bit EVT_F2_EN.
	MCPWM_EVT_EN_EVT_F2_EN = 0x20000
	// Position of EVT_F0_CLR_EN field.
	MCPWM_EVT_EN_EVT_F0_CLR_EN_Pos = 0x12
	// Bit mask of EVT_F0_CLR_EN field.
	MCPWM_EVT_EN_EVT_F0_CLR_EN_Msk = 0x40000
	// Bit EVT_F0_CLR_EN.
	MCPWM_EVT_EN_EVT_F0_CLR_EN = 0x40000
	// Position of EVT_F1_CLR_EN field.
	MCPWM_EVT_EN_EVT_F1_CLR_EN_Pos = 0x13
	// Bit mask of EVT_F1_CLR_EN field.
	MCPWM_EVT_EN_EVT_F1_CLR_EN_Msk = 0x80000
	// Bit EVT_F1_CLR_EN.
	MCPWM_EVT_EN_EVT_F1_CLR_EN = 0x80000
	// Position of EVT_F2_CLR_EN field.
	MCPWM_EVT_EN_EVT_F2_CLR_EN_Pos = 0x14
	// Bit mask of EVT_F2_CLR_EN field.
	MCPWM_EVT_EN_EVT_F2_CLR_EN_Msk = 0x100000
	// Bit EVT_F2_CLR_EN.
	MCPWM_EVT_EN_EVT_F2_CLR_EN = 0x100000
	// Position of EVT_TZ0_CBC_EN field.
	MCPWM_EVT_EN_EVT_TZ0_CBC_EN_Pos = 0x15
	// Bit mask of EVT_TZ0_CBC_EN field.
	MCPWM_EVT_EN_EVT_TZ0_CBC_EN_Msk = 0x200000
	// Bit EVT_TZ0_CBC_EN.
	MCPWM_EVT_EN_EVT_TZ0_CBC_EN = 0x200000
	// Position of EVT_TZ1_CBC_EN field.
	MCPWM_EVT_EN_EVT_TZ1_CBC_EN_Pos = 0x16
	// Bit mask of EVT_TZ1_CBC_EN field.
	MCPWM_EVT_EN_EVT_TZ1_CBC_EN_Msk = 0x400000
	// Bit EVT_TZ1_CBC_EN.
	MCPWM_EVT_EN_EVT_TZ1_CBC_EN = 0x400000
	// Position of EVT_TZ2_CBC_EN field.
	MCPWM_EVT_EN_EVT_TZ2_CBC_EN_Pos = 0x17
	// Bit mask of EVT_TZ2_CBC_EN field.
	MCPWM_EVT_EN_EVT_TZ2_CBC_EN_Msk = 0x800000
	// Bit EVT_TZ2_CBC_EN.
	MCPWM_EVT_EN_EVT_TZ2_CBC_EN = 0x800000
	// Position of EVT_TZ0_OST_EN field.
	MCPWM_EVT_EN_EVT_TZ0_OST_EN_Pos = 0x18
	// Bit mask of EVT_TZ0_OST_EN field.
	MCPWM_EVT_EN_EVT_TZ0_OST_EN_Msk = 0x1000000
	// Bit EVT_TZ0_OST_EN.
	MCPWM_EVT_EN_EVT_TZ0_OST_EN = 0x1000000
	// Position of EVT_TZ1_OST_EN field.
	MCPWM_EVT_EN_EVT_TZ1_OST_EN_Pos = 0x19
	// Bit mask of EVT_TZ1_OST_EN field.
	MCPWM_EVT_EN_EVT_TZ1_OST_EN_Msk = 0x2000000
	// Bit EVT_TZ1_OST_EN.
	MCPWM_EVT_EN_EVT_TZ1_OST_EN = 0x2000000
	// Position of EVT_TZ2_OST_EN field.
	MCPWM_EVT_EN_EVT_TZ2_OST_EN_Pos = 0x1a
	// Bit mask of EVT_TZ2_OST_EN field.
	MCPWM_EVT_EN_EVT_TZ2_OST_EN_Msk = 0x4000000
	// Bit EVT_TZ2_OST_EN.
	MCPWM_EVT_EN_EVT_TZ2_OST_EN = 0x4000000
	// Position of EVT_CAP0_EN field.
	MCPWM_EVT_EN_EVT_CAP0_EN_Pos = 0x1b
	// Bit mask of EVT_CAP0_EN field.
	MCPWM_EVT_EN_EVT_CAP0_EN_Msk = 0x8000000
	// Bit EVT_CAP0_EN.
	MCPWM_EVT_EN_EVT_CAP0_EN = 0x8000000
	// Position of EVT_CAP1_EN field.
	MCPWM_EVT_EN_EVT_CAP1_EN_Pos = 0x1c
	// Bit mask of EVT_CAP1_EN field.
	MCPWM_EVT_EN_EVT_CAP1_EN_Msk = 0x10000000
	// Bit EVT_CAP1_EN.
	MCPWM_EVT_EN_EVT_CAP1_EN = 0x10000000
	// Position of EVT_CAP2_EN field.
	MCPWM_EVT_EN_EVT_CAP2_EN_Pos = 0x1d
	// Bit mask of EVT_CAP2_EN field.
	MCPWM_EVT_EN_EVT_CAP2_EN_Msk = 0x20000000
	// Bit EVT_CAP2_EN.
	MCPWM_EVT_EN_EVT_CAP2_EN = 0x20000000

	// TASK_EN: MCPWM task enable register
	// Position of TASK_CMPR0_A_UP_EN field.
	MCPWM_TASK_EN_TASK_CMPR0_A_UP_EN_Pos = 0x0
	// Bit mask of TASK_CMPR0_A_UP_EN field.
	MCPWM_TASK_EN_TASK_CMPR0_A_UP_EN_Msk = 0x1
	// Bit TASK_CMPR0_A_UP_EN.
	MCPWM_TASK_EN_TASK_CMPR0_A_UP_EN = 0x1
	// Position of TASK_CMPR1_A_UP_EN field.
	MCPWM_TASK_EN_TASK_CMPR1_A_UP_EN_Pos = 0x1
	// Bit mask of TASK_CMPR1_A_UP_EN field.
	MCPWM_TASK_EN_TASK_CMPR1_A_UP_EN_Msk = 0x2
	// Bit TASK_CMPR1_A_UP_EN.
	MCPWM_TASK_EN_TASK_CMPR1_A_UP_EN = 0x2
	// Position of TASK_CMPR2_A_UP_EN field.
	MCPWM_TASK_EN_TASK_CMPR2_A_UP_EN_Pos = 0x2
	// Bit mask of TASK_CMPR2_A_UP_EN field.
	MCPWM_TASK_EN_TASK_CMPR2_A_UP_EN_Msk = 0x4
	// Bit TASK_CMPR2_A_UP_EN.
	MCPWM_TASK_EN_TASK_CMPR2_A_UP_EN = 0x4
	// Position of TASK_CMPR0_B_UP_EN field.
	MCPWM_TASK_EN_TASK_CMPR0_B_UP_EN_Pos = 0x3
	// Bit mask of TASK_CMPR0_B_UP_EN field.
	MCPWM_TASK_EN_TASK_CMPR0_B_UP_EN_Msk = 0x8
	// Bit TASK_CMPR0_B_UP_EN.
	MCPWM_TASK_EN_TASK_CMPR0_B_UP_EN = 0x8
	// Position of TASK_CMPR1_B_UP_EN field.
	MCPWM_TASK_EN_TASK_CMPR1_B_UP_EN_Pos = 0x4
	// Bit mask of TASK_CMPR1_B_UP_EN field.
	MCPWM_TASK_EN_TASK_CMPR1_B_UP_EN_Msk = 0x10
	// Bit TASK_CMPR1_B_UP_EN.
	MCPWM_TASK_EN_TASK_CMPR1_B_UP_EN = 0x10
	// Position of TASK_CMPR2_B_UP_EN field.
	MCPWM_TASK_EN_TASK_CMPR2_B_UP_EN_Pos = 0x5
	// Bit mask of TASK_CMPR2_B_UP_EN field.
	MCPWM_TASK_EN_TASK_CMPR2_B_UP_EN_Msk = 0x20
	// Bit TASK_CMPR2_B_UP_EN.
	MCPWM_TASK_EN_TASK_CMPR2_B_UP_EN = 0x20
	// Position of TASK_GEN_STOP_EN field.
	MCPWM_TASK_EN_TASK_GEN_STOP_EN_Pos = 0x6
	// Bit mask of TASK_GEN_STOP_EN field.
	MCPWM_TASK_EN_TASK_GEN_STOP_EN_Msk = 0x40
	// Bit TASK_GEN_STOP_EN.
	MCPWM_TASK_EN_TASK_GEN_STOP_EN = 0x40
	// Position of TASK_TIMER0_SYNC_EN field.
	MCPWM_TASK_EN_TASK_TIMER0_SYNC_EN_Pos = 0x7
	// Bit mask of TASK_TIMER0_SYNC_EN field.
	MCPWM_TASK_EN_TASK_TIMER0_SYNC_EN_Msk = 0x80
	// Bit TASK_TIMER0_SYNC_EN.
	MCPWM_TASK_EN_TASK_TIMER0_SYNC_EN = 0x80
	// Position of TASK_TIMER1_SYNC_EN field.
	MCPWM_TASK_EN_TASK_TIMER1_SYNC_EN_Pos = 0x8
	// Bit mask of TASK_TIMER1_SYNC_EN field.
	MCPWM_TASK_EN_TASK_TIMER1_SYNC_EN_Msk = 0x100
	// Bit TASK_TIMER1_SYNC_EN.
	MCPWM_TASK_EN_TASK_TIMER1_SYNC_EN = 0x100
	// Position of TASK_TIMER2_SYNC_EN field.
	MCPWM_TASK_EN_TASK_TIMER2_SYNC_EN_Pos = 0x9
	// Bit mask of TASK_TIMER2_SYNC_EN field.
	MCPWM_TASK_EN_TASK_TIMER2_SYNC_EN_Msk = 0x200
	// Bit TASK_TIMER2_SYNC_EN.
	MCPWM_TASK_EN_TASK_TIMER2_SYNC_EN = 0x200
	// Position of TASK_TIMER0_PERIOD_UP_EN field.
	MCPWM_TASK_EN_TASK_TIMER0_PERIOD_UP_EN_Pos = 0xa
	// Bit mask of TASK_TIMER0_PERIOD_UP_EN field.
	MCPWM_TASK_EN_TASK_TIMER0_PERIOD_UP_EN_Msk = 0x400
	// Bit TASK_TIMER0_PERIOD_UP_EN.
	MCPWM_TASK_EN_TASK_TIMER0_PERIOD_UP_EN = 0x400
	// Position of TASK_TIMER1_PERIOD_UP_EN field.
	MCPWM_TASK_EN_TASK_TIMER1_PERIOD_UP_EN_Pos = 0xb
	// Bit mask of TASK_TIMER1_PERIOD_UP_EN field.
	MCPWM_TASK_EN_TASK_TIMER1_PERIOD_UP_EN_Msk = 0x800
	// Bit TASK_TIMER1_PERIOD_UP_EN.
	MCPWM_TASK_EN_TASK_TIMER1_PERIOD_UP_EN = 0x800
	// Position of TASK_TIMER2_PERIOD_UP_EN field.
	MCPWM_TASK_EN_TASK_TIMER2_PERIOD_UP_EN_Pos = 0xc
	// Bit mask of TASK_TIMER2_PERIOD_UP_EN field.
	MCPWM_TASK_EN_TASK_TIMER2_PERIOD_UP_EN_Msk = 0x1000
	// Bit TASK_TIMER2_PERIOD_UP_EN.
	MCPWM_TASK_EN_TASK_TIMER2_PERIOD_UP_EN = 0x1000
	// Position of TASK_TZ0_OST_EN field.
	MCPWM_TASK_EN_TASK_TZ0_OST_EN_Pos = 0xd
	// Bit mask of TASK_TZ0_OST_EN field.
	MCPWM_TASK_EN_TASK_TZ0_OST_EN_Msk = 0x2000
	// Bit TASK_TZ0_OST_EN.
	MCPWM_TASK_EN_TASK_TZ0_OST_EN = 0x2000
	// Position of TASK_TZ1_OST_EN field.
	MCPWM_TASK_EN_TASK_TZ1_OST_EN_Pos = 0xe
	// Bit mask of TASK_TZ1_OST_EN field.
	MCPWM_TASK_EN_TASK_TZ1_OST_EN_Msk = 0x4000
	// Bit TASK_TZ1_OST_EN.
	MCPWM_TASK_EN_TASK_TZ1_OST_EN = 0x4000
	// Position of TASK_TZ2_OST_EN field.
	MCPWM_TASK_EN_TASK_TZ2_OST_EN_Pos = 0xf
	// Bit mask of TASK_TZ2_OST_EN field.
	MCPWM_TASK_EN_TASK_TZ2_OST_EN_Msk = 0x8000
	// Bit TASK_TZ2_OST_EN.
	MCPWM_TASK_EN_TASK_TZ2_OST_EN = 0x8000
	// Position of TASK_CLR0_OST_EN field.
	MCPWM_TASK_EN_TASK_CLR0_OST_EN_Pos = 0x10
	// Bit mask of TASK_CLR0_OST_EN field.
	MCPWM_TASK_EN_TASK_CLR0_OST_EN_Msk = 0x10000
	// Bit TASK_CLR0_OST_EN.
	MCPWM_TASK_EN_TASK_CLR0_OST_EN = 0x10000
	// Position of TASK_CLR1_OST_EN field.
	MCPWM_TASK_EN_TASK_CLR1_OST_EN_Pos = 0x11
	// Bit mask of TASK_CLR1_OST_EN field.
	MCPWM_TASK_EN_TASK_CLR1_OST_EN_Msk = 0x20000
	// Bit TASK_CLR1_OST_EN.
	MCPWM_TASK_EN_TASK_CLR1_OST_EN = 0x20000
	// Position of TASK_CLR2_OST_EN field.
	MCPWM_TASK_EN_TASK_CLR2_OST_EN_Pos = 0x12
	// Bit mask of TASK_CLR2_OST_EN field.
	MCPWM_TASK_EN_TASK_CLR2_OST_EN_Msk = 0x40000
	// Bit TASK_CLR2_OST_EN.
	MCPWM_TASK_EN_TASK_CLR2_OST_EN = 0x40000
	// Position of TASK_CAP0_EN field.
	MCPWM_TASK_EN_TASK_CAP0_EN_Pos = 0x13
	// Bit mask of TASK_CAP0_EN field.
	MCPWM_TASK_EN_TASK_CAP0_EN_Msk = 0x80000
	// Bit TASK_CAP0_EN.
	MCPWM_TASK_EN_TASK_CAP0_EN = 0x80000
	// Position of TASK_CAP1_EN field.
	MCPWM_TASK_EN_TASK_CAP1_EN_Pos = 0x14
	// Bit mask of TASK_CAP1_EN field.
	MCPWM_TASK_EN_TASK_CAP1_EN_Msk = 0x100000
	// Bit TASK_CAP1_EN.
	MCPWM_TASK_EN_TASK_CAP1_EN = 0x100000
	// Position of TASK_CAP2_EN field.
	MCPWM_TASK_EN_TASK_CAP2_EN_Pos = 0x15
	// Bit mask of TASK_CAP2_EN field.
	MCPWM_TASK_EN_TASK_CAP2_EN_Msk = 0x200000
	// Bit TASK_CAP2_EN.
	MCPWM_TASK_EN_TASK_CAP2_EN = 0x200000

	// CLK: MCPWM APB configuration register
	// Position of EN field.
	MCPWM_CLK_EN_Pos = 0x0
	// Bit mask of EN field.
	MCPWM_CLK_EN_Msk = 0x1
	// Bit EN.
	MCPWM_CLK_EN = 0x1

	// VERSION: Version register.
	// Position of DATE field.
	MCPWM_VERSION_DATE_Pos = 0x0
	// Bit mask of DATE field.
	MCPWM_VERSION_DATE_Msk = 0xfffffff
)

// Constants for MEM_MONITOR: MEM_MONITOR Peripheral
const (
	// LOG_SETTING: log config regsiter
	// Position of LOG_ENA field.
	MEM_MONITOR_LOG_SETTING_LOG_ENA_Pos = 0x0
	// Bit mask of LOG_ENA field.
	MEM_MONITOR_LOG_SETTING_LOG_ENA_Msk = 0x7
	// Position of LOG_MODE field.
	MEM_MONITOR_LOG_SETTING_LOG_MODE_Pos = 0x3
	// Bit mask of LOG_MODE field.
	MEM_MONITOR_LOG_SETTING_LOG_MODE_Msk = 0x78
	// Position of LOG_MEM_LOOP_ENABLE field.
	MEM_MONITOR_LOG_SETTING_LOG_MEM_LOOP_ENABLE_Pos = 0x7
	// Bit mask of LOG_MEM_LOOP_ENABLE field.
	MEM_MONITOR_LOG_SETTING_LOG_MEM_LOOP_ENABLE_Msk = 0x80
	// Bit LOG_MEM_LOOP_ENABLE.
	MEM_MONITOR_LOG_SETTING_LOG_MEM_LOOP_ENABLE = 0x80

	// LOG_CHECK_DATA: check data regsiter
	// Position of LOG_CHECK_DATA field.
	MEM_MONITOR_LOG_CHECK_DATA_LOG_CHECK_DATA_Pos = 0x0
	// Bit mask of LOG_CHECK_DATA field.
	MEM_MONITOR_LOG_CHECK_DATA_LOG_CHECK_DATA_Msk = 0xffffffff

	// LOG_DATA_MASK: check data mask register
	// Position of LOG_DATA_MASK field.
	MEM_MONITOR_LOG_DATA_MASK_LOG_DATA_MASK_Pos = 0x0
	// Bit mask of LOG_DATA_MASK field.
	MEM_MONITOR_LOG_DATA_MASK_LOG_DATA_MASK_Msk = 0xf

	// LOG_MIN: log boundary regsiter
	// Position of LOG_MIN field.
	MEM_MONITOR_LOG_MIN_LOG_MIN_Pos = 0x0
	// Bit mask of LOG_MIN field.
	MEM_MONITOR_LOG_MIN_LOG_MIN_Msk = 0xffffffff

	// LOG_MAX: log boundary regsiter
	// Position of LOG_MAX field.
	MEM_MONITOR_LOG_MAX_LOG_MAX_Pos = 0x0
	// Bit mask of LOG_MAX field.
	MEM_MONITOR_LOG_MAX_LOG_MAX_Msk = 0xffffffff

	// LOG_MEM_START: log message store range register
	// Position of LOG_MEM_START field.
	MEM_MONITOR_LOG_MEM_START_LOG_MEM_START_Pos = 0x0
	// Bit mask of LOG_MEM_START field.
	MEM_MONITOR_LOG_MEM_START_LOG_MEM_START_Msk = 0xffffffff

	// LOG_MEM_END: log message store range register
	// Position of LOG_MEM_END field.
	MEM_MONITOR_LOG_MEM_END_LOG_MEM_END_Pos = 0x0
	// Bit mask of LOG_MEM_END field.
	MEM_MONITOR_LOG_MEM_END_LOG_MEM_END_Msk = 0xffffffff

	// LOG_MEM_CURRENT_ADDR: current writing address.
	// Position of LOG_MEM_CURRENT_ADDR field.
	MEM_MONITOR_LOG_MEM_CURRENT_ADDR_LOG_MEM_CURRENT_ADDR_Pos = 0x0
	// Bit mask of LOG_MEM_CURRENT_ADDR field.
	MEM_MONITOR_LOG_MEM_CURRENT_ADDR_LOG_MEM_CURRENT_ADDR_Msk = 0xffffffff

	// LOG_MEM_ADDR_UPDATE: writing address update
	// Position of LOG_MEM_ADDR_UPDATE field.
	MEM_MONITOR_LOG_MEM_ADDR_UPDATE_LOG_MEM_ADDR_UPDATE_Pos = 0x0
	// Bit mask of LOG_MEM_ADDR_UPDATE field.
	MEM_MONITOR_LOG_MEM_ADDR_UPDATE_LOG_MEM_ADDR_UPDATE_Msk = 0x1
	// Bit LOG_MEM_ADDR_UPDATE.
	MEM_MONITOR_LOG_MEM_ADDR_UPDATE_LOG_MEM_ADDR_UPDATE = 0x1

	// LOG_MEM_FULL_FLAG: full flag status register
	// Position of LOG_MEM_FULL_FLAG field.
	MEM_MONITOR_LOG_MEM_FULL_FLAG_LOG_MEM_FULL_FLAG_Pos = 0x0
	// Bit mask of LOG_MEM_FULL_FLAG field.
	MEM_MONITOR_LOG_MEM_FULL_FLAG_LOG_MEM_FULL_FLAG_Msk = 0x1
	// Bit LOG_MEM_FULL_FLAG.
	MEM_MONITOR_LOG_MEM_FULL_FLAG_LOG_MEM_FULL_FLAG = 0x1
	// Position of CLR_LOG_MEM_FULL_FLAG field.
	MEM_MONITOR_LOG_MEM_FULL_FLAG_CLR_LOG_MEM_FULL_FLAG_Pos = 0x1
	// Bit mask of CLR_LOG_MEM_FULL_FLAG field.
	MEM_MONITOR_LOG_MEM_FULL_FLAG_CLR_LOG_MEM_FULL_FLAG_Msk = 0x2
	// Bit CLR_LOG_MEM_FULL_FLAG.
	MEM_MONITOR_LOG_MEM_FULL_FLAG_CLR_LOG_MEM_FULL_FLAG = 0x2

	// CLOCK_GATE: clock gate force on register
	// Position of CLK_EN field.
	MEM_MONITOR_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	MEM_MONITOR_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	MEM_MONITOR_CLOCK_GATE_CLK_EN = 0x1

	// DATE: version register
	// Position of DATE field.
	MEM_MONITOR_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	MEM_MONITOR_DATE_DATE_Msk = 0xfffffff
)

// Constants for MODEM_LPCON: MODEM_LPCON Peripheral
const (
	// TEST_CONF
	// Position of CLK_EN field.
	MODEM_LPCON_TEST_CONF_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	MODEM_LPCON_TEST_CONF_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	MODEM_LPCON_TEST_CONF_CLK_EN = 0x1

	// COEX_LP_CLK_CONF
	// Position of CLK_COEX_LP_SEL_OSC_SLOW field.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_SEL_OSC_SLOW_Pos = 0x0
	// Bit mask of CLK_COEX_LP_SEL_OSC_SLOW field.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_SEL_OSC_SLOW_Msk = 0x1
	// Bit CLK_COEX_LP_SEL_OSC_SLOW.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_SEL_OSC_SLOW = 0x1
	// Position of CLK_COEX_LP_SEL_OSC_FAST field.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_SEL_OSC_FAST_Pos = 0x1
	// Bit mask of CLK_COEX_LP_SEL_OSC_FAST field.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_SEL_OSC_FAST_Msk = 0x2
	// Bit CLK_COEX_LP_SEL_OSC_FAST.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_SEL_OSC_FAST = 0x2
	// Position of CLK_COEX_LP_SEL_XTAL field.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_SEL_XTAL_Pos = 0x2
	// Bit mask of CLK_COEX_LP_SEL_XTAL field.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_SEL_XTAL_Msk = 0x4
	// Bit CLK_COEX_LP_SEL_XTAL.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_SEL_XTAL = 0x4
	// Position of CLK_COEX_LP_SEL_XTAL32K field.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_SEL_XTAL32K_Pos = 0x3
	// Bit mask of CLK_COEX_LP_SEL_XTAL32K field.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_SEL_XTAL32K_Msk = 0x8
	// Bit CLK_COEX_LP_SEL_XTAL32K.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_SEL_XTAL32K = 0x8
	// Position of CLK_COEX_LP_DIV_NUM field.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_DIV_NUM_Pos = 0x4
	// Bit mask of CLK_COEX_LP_DIV_NUM field.
	MODEM_LPCON_COEX_LP_CLK_CONF_CLK_COEX_LP_DIV_NUM_Msk = 0xfff0

	// CLK_CONF
	// Position of CLK_COEX_EN field.
	MODEM_LPCON_CLK_CONF_CLK_COEX_EN_Pos = 0x1
	// Bit mask of CLK_COEX_EN field.
	MODEM_LPCON_CLK_CONF_CLK_COEX_EN_Msk = 0x2
	// Bit CLK_COEX_EN.
	MODEM_LPCON_CLK_CONF_CLK_COEX_EN = 0x2
	// Position of CLK_I2C_MST_EN field.
	MODEM_LPCON_CLK_CONF_CLK_I2C_MST_EN_Pos = 0x2
	// Bit mask of CLK_I2C_MST_EN field.
	MODEM_LPCON_CLK_CONF_CLK_I2C_MST_EN_Msk = 0x4
	// Bit CLK_I2C_MST_EN.
	MODEM_LPCON_CLK_CONF_CLK_I2C_MST_EN = 0x4
	// Position of CLK_FE_MEM_EN field.
	MODEM_LPCON_CLK_CONF_CLK_FE_MEM_EN_Pos = 0x5
	// Bit mask of CLK_FE_MEM_EN field.
	MODEM_LPCON_CLK_CONF_CLK_FE_MEM_EN_Msk = 0x20
	// Bit CLK_FE_MEM_EN.
	MODEM_LPCON_CLK_CONF_CLK_FE_MEM_EN = 0x20

	// CLK_CONF_FORCE_ON
	// Position of CLK_COEX_FO field.
	MODEM_LPCON_CLK_CONF_FORCE_ON_CLK_COEX_FO_Pos = 0x1
	// Bit mask of CLK_COEX_FO field.
	MODEM_LPCON_CLK_CONF_FORCE_ON_CLK_COEX_FO_Msk = 0x2
	// Bit CLK_COEX_FO.
	MODEM_LPCON_CLK_CONF_FORCE_ON_CLK_COEX_FO = 0x2
	// Position of CLK_I2C_MST_FO field.
	MODEM_LPCON_CLK_CONF_FORCE_ON_CLK_I2C_MST_FO_Pos = 0x2
	// Bit mask of CLK_I2C_MST_FO field.
	MODEM_LPCON_CLK_CONF_FORCE_ON_CLK_I2C_MST_FO_Msk = 0x4
	// Bit CLK_I2C_MST_FO.
	MODEM_LPCON_CLK_CONF_FORCE_ON_CLK_I2C_MST_FO = 0x4
	// Position of CLK_FE_MEM_FO field.
	MODEM_LPCON_CLK_CONF_FORCE_ON_CLK_FE_MEM_FO_Pos = 0x5
	// Bit mask of CLK_FE_MEM_FO field.
	MODEM_LPCON_CLK_CONF_FORCE_ON_CLK_FE_MEM_FO_Msk = 0x20
	// Bit CLK_FE_MEM_FO.
	MODEM_LPCON_CLK_CONF_FORCE_ON_CLK_FE_MEM_FO = 0x20

	// TICK_CONF
	// Position of PWR_TICK_TARGET field.
	MODEM_LPCON_TICK_CONF_PWR_TICK_TARGET_Pos = 0x0
	// Bit mask of PWR_TICK_TARGET field.
	MODEM_LPCON_TICK_CONF_PWR_TICK_TARGET_Msk = 0x3f

	// RST_CONF
	// Position of RST_COEX field.
	MODEM_LPCON_RST_CONF_RST_COEX_Pos = 0x1
	// Bit mask of RST_COEX field.
	MODEM_LPCON_RST_CONF_RST_COEX_Msk = 0x2
	// Bit RST_COEX.
	MODEM_LPCON_RST_CONF_RST_COEX = 0x2
	// Position of RST_I2C_MST field.
	MODEM_LPCON_RST_CONF_RST_I2C_MST_Pos = 0x2
	// Bit mask of RST_I2C_MST field.
	MODEM_LPCON_RST_CONF_RST_I2C_MST_Msk = 0x4
	// Bit RST_I2C_MST.
	MODEM_LPCON_RST_CONF_RST_I2C_MST = 0x4

	// MEM_CONF
	// Position of AGC_MEM_FORCE_PU field.
	MODEM_LPCON_MEM_CONF_AGC_MEM_FORCE_PU_Pos = 0x2
	// Bit mask of AGC_MEM_FORCE_PU field.
	MODEM_LPCON_MEM_CONF_AGC_MEM_FORCE_PU_Msk = 0x4
	// Bit AGC_MEM_FORCE_PU.
	MODEM_LPCON_MEM_CONF_AGC_MEM_FORCE_PU = 0x4
	// Position of AGC_MEM_FORCE_PD field.
	MODEM_LPCON_MEM_CONF_AGC_MEM_FORCE_PD_Pos = 0x3
	// Bit mask of AGC_MEM_FORCE_PD field.
	MODEM_LPCON_MEM_CONF_AGC_MEM_FORCE_PD_Msk = 0x8
	// Bit AGC_MEM_FORCE_PD.
	MODEM_LPCON_MEM_CONF_AGC_MEM_FORCE_PD = 0x8
	// Position of PBUS_MEM_FORCE_PU field.
	MODEM_LPCON_MEM_CONF_PBUS_MEM_FORCE_PU_Pos = 0x4
	// Bit mask of PBUS_MEM_FORCE_PU field.
	MODEM_LPCON_MEM_CONF_PBUS_MEM_FORCE_PU_Msk = 0x10
	// Bit PBUS_MEM_FORCE_PU.
	MODEM_LPCON_MEM_CONF_PBUS_MEM_FORCE_PU = 0x10
	// Position of PBUS_MEM_FORCE_PD field.
	MODEM_LPCON_MEM_CONF_PBUS_MEM_FORCE_PD_Pos = 0x5
	// Bit mask of PBUS_MEM_FORCE_PD field.
	MODEM_LPCON_MEM_CONF_PBUS_MEM_FORCE_PD_Msk = 0x20
	// Bit PBUS_MEM_FORCE_PD.
	MODEM_LPCON_MEM_CONF_PBUS_MEM_FORCE_PD = 0x20
	// Position of I2C_MST_MEM_FORCE_PU field.
	MODEM_LPCON_MEM_CONF_I2C_MST_MEM_FORCE_PU_Pos = 0x8
	// Bit mask of I2C_MST_MEM_FORCE_PU field.
	MODEM_LPCON_MEM_CONF_I2C_MST_MEM_FORCE_PU_Msk = 0x100
	// Bit I2C_MST_MEM_FORCE_PU.
	MODEM_LPCON_MEM_CONF_I2C_MST_MEM_FORCE_PU = 0x100
	// Position of I2C_MST_MEM_FORCE_PD field.
	MODEM_LPCON_MEM_CONF_I2C_MST_MEM_FORCE_PD_Pos = 0x9
	// Bit mask of I2C_MST_MEM_FORCE_PD field.
	MODEM_LPCON_MEM_CONF_I2C_MST_MEM_FORCE_PD_Msk = 0x200
	// Bit I2C_MST_MEM_FORCE_PD.
	MODEM_LPCON_MEM_CONF_I2C_MST_MEM_FORCE_PD = 0x200
	// Position of CHAN_FREQ_MEM_FORCE_PU field.
	MODEM_LPCON_MEM_CONF_CHAN_FREQ_MEM_FORCE_PU_Pos = 0xa
	// Bit mask of CHAN_FREQ_MEM_FORCE_PU field.
	MODEM_LPCON_MEM_CONF_CHAN_FREQ_MEM_FORCE_PU_Msk = 0x400
	// Bit CHAN_FREQ_MEM_FORCE_PU.
	MODEM_LPCON_MEM_CONF_CHAN_FREQ_MEM_FORCE_PU = 0x400
	// Position of CHAN_FREQ_MEM_FORCE_PD field.
	MODEM_LPCON_MEM_CONF_CHAN_FREQ_MEM_FORCE_PD_Pos = 0xb
	// Bit mask of CHAN_FREQ_MEM_FORCE_PD field.
	MODEM_LPCON_MEM_CONF_CHAN_FREQ_MEM_FORCE_PD_Msk = 0x800
	// Bit CHAN_FREQ_MEM_FORCE_PD.
	MODEM_LPCON_MEM_CONF_CHAN_FREQ_MEM_FORCE_PD = 0x800
	// Position of MODEM_PWR_MEM_WP field.
	MODEM_LPCON_MEM_CONF_MODEM_PWR_MEM_WP_Pos = 0xc
	// Bit mask of MODEM_PWR_MEM_WP field.
	MODEM_LPCON_MEM_CONF_MODEM_PWR_MEM_WP_Msk = 0x7000
	// Position of MODEM_PWR_MEM_WA field.
	MODEM_LPCON_MEM_CONF_MODEM_PWR_MEM_WA_Pos = 0xf
	// Bit mask of MODEM_PWR_MEM_WA field.
	MODEM_LPCON_MEM_CONF_MODEM_PWR_MEM_WA_Msk = 0x38000
	// Position of MODEM_PWR_MEM_RA field.
	MODEM_LPCON_MEM_CONF_MODEM_PWR_MEM_RA_Pos = 0x12
	// Bit mask of MODEM_PWR_MEM_RA field.
	MODEM_LPCON_MEM_CONF_MODEM_PWR_MEM_RA_Msk = 0xc0000
	// Position of MODEM_PWR_MEM_RM field.
	MODEM_LPCON_MEM_CONF_MODEM_PWR_MEM_RM_Pos = 0x14
	// Bit mask of MODEM_PWR_MEM_RM field.
	MODEM_LPCON_MEM_CONF_MODEM_PWR_MEM_RM_Msk = 0xf00000

	// DATE
	// Position of DATE field.
	MODEM_LPCON_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	MODEM_LPCON_DATE_DATE_Msk = 0xfffffff
)

// Constants for MODEM_SYSCON: MODEM_SYSCON Peripheral
const (
	// TEST_CONF
	// Position of CLK_EN field.
	MODEM_SYSCON_TEST_CONF_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	MODEM_SYSCON_TEST_CONF_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	MODEM_SYSCON_TEST_CONF_CLK_EN = 0x1

	// CLK_CONF
	// Position of CLK_ETM_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_ETM_EN_Pos = 0x15
	// Bit mask of CLK_ETM_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_ETM_EN_Msk = 0x200000
	// Bit CLK_ETM_EN.
	MODEM_SYSCON_CLK_CONF_CLK_ETM_EN = 0x200000
	// Position of CLK_ZB_APB_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_ZB_APB_EN_Pos = 0x16
	// Bit mask of CLK_ZB_APB_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_ZB_APB_EN_Msk = 0x400000
	// Bit CLK_ZB_APB_EN.
	MODEM_SYSCON_CLK_CONF_CLK_ZB_APB_EN = 0x400000
	// Position of CLK_ZB_MAC_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_ZB_MAC_EN_Pos = 0x17
	// Bit mask of CLK_ZB_MAC_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_ZB_MAC_EN_Msk = 0x800000
	// Bit CLK_ZB_MAC_EN.
	MODEM_SYSCON_CLK_CONF_CLK_ZB_MAC_EN = 0x800000
	// Position of CLK_MODEM_SEC_ECB_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_ECB_EN_Pos = 0x18
	// Bit mask of CLK_MODEM_SEC_ECB_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_ECB_EN_Msk = 0x1000000
	// Bit CLK_MODEM_SEC_ECB_EN.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_ECB_EN = 0x1000000
	// Position of CLK_MODEM_SEC_CCM_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_CCM_EN_Pos = 0x19
	// Bit mask of CLK_MODEM_SEC_CCM_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_CCM_EN_Msk = 0x2000000
	// Bit CLK_MODEM_SEC_CCM_EN.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_CCM_EN = 0x2000000
	// Position of CLK_MODEM_SEC_BAH_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_BAH_EN_Pos = 0x1a
	// Bit mask of CLK_MODEM_SEC_BAH_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_BAH_EN_Msk = 0x4000000
	// Bit CLK_MODEM_SEC_BAH_EN.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_BAH_EN = 0x4000000
	// Position of CLK_MODEM_SEC_APB_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_APB_EN_Pos = 0x1b
	// Bit mask of CLK_MODEM_SEC_APB_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_APB_EN_Msk = 0x8000000
	// Bit CLK_MODEM_SEC_APB_EN.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_APB_EN = 0x8000000
	// Position of CLK_MODEM_SEC_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_EN_Pos = 0x1c
	// Bit mask of CLK_MODEM_SEC_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_EN_Msk = 0x10000000
	// Bit CLK_MODEM_SEC_EN.
	MODEM_SYSCON_CLK_CONF_CLK_MODEM_SEC_EN = 0x10000000
	// Position of CLK_BLE_TIMER_APB_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_BLE_TIMER_APB_EN_Pos = 0x1d
	// Bit mask of CLK_BLE_TIMER_APB_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_BLE_TIMER_APB_EN_Msk = 0x20000000
	// Bit CLK_BLE_TIMER_APB_EN.
	MODEM_SYSCON_CLK_CONF_CLK_BLE_TIMER_APB_EN = 0x20000000
	// Position of CLK_BLE_TIMER_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_BLE_TIMER_EN_Pos = 0x1e
	// Bit mask of CLK_BLE_TIMER_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_BLE_TIMER_EN_Msk = 0x40000000
	// Bit CLK_BLE_TIMER_EN.
	MODEM_SYSCON_CLK_CONF_CLK_BLE_TIMER_EN = 0x40000000
	// Position of CLK_DATA_DUMP_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_DATA_DUMP_EN_Pos = 0x1f
	// Bit mask of CLK_DATA_DUMP_EN field.
	MODEM_SYSCON_CLK_CONF_CLK_DATA_DUMP_EN_Msk = 0x80000000
	// Bit CLK_DATA_DUMP_EN.
	MODEM_SYSCON_CLK_CONF_CLK_DATA_DUMP_EN = 0x80000000

	// CLK_CONF_FORCE_ON
	// Position of CLK_ETM_FO field.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_ETM_FO_Pos = 0x16
	// Bit mask of CLK_ETM_FO field.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_ETM_FO_Msk = 0x400000
	// Bit CLK_ETM_FO.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_ETM_FO = 0x400000
	// Position of CLK_ZB_FO field.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_ZB_FO_Pos = 0x18
	// Bit mask of CLK_ZB_FO field.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_ZB_FO_Msk = 0x1000000
	// Bit CLK_ZB_FO.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_ZB_FO = 0x1000000
	// Position of CLK_MODEM_SEC_FO field.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_MODEM_SEC_FO_Pos = 0x1d
	// Bit mask of CLK_MODEM_SEC_FO field.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_MODEM_SEC_FO_Msk = 0x20000000
	// Bit CLK_MODEM_SEC_FO.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_MODEM_SEC_FO = 0x20000000
	// Position of CLK_BLE_TIMER_FO field.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_BLE_TIMER_FO_Pos = 0x1e
	// Bit mask of CLK_BLE_TIMER_FO field.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_BLE_TIMER_FO_Msk = 0x40000000
	// Bit CLK_BLE_TIMER_FO.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_BLE_TIMER_FO = 0x40000000
	// Position of CLK_DATA_DUMP_FO field.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_DATA_DUMP_FO_Pos = 0x1f
	// Bit mask of CLK_DATA_DUMP_FO field.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_DATA_DUMP_FO_Msk = 0x80000000
	// Bit CLK_DATA_DUMP_FO.
	MODEM_SYSCON_CLK_CONF_FORCE_ON_CLK_DATA_DUMP_FO = 0x80000000

	// MODEM_RST_CONF
	// Position of RST_FE field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_FE_Pos = 0xe
	// Bit mask of RST_FE field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_FE_Msk = 0x4000
	// Bit RST_FE.
	MODEM_SYSCON_MODEM_RST_CONF_RST_FE = 0x4000
	// Position of RST_BTMAC_APB field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BTMAC_APB_Pos = 0xf
	// Bit mask of RST_BTMAC_APB field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BTMAC_APB_Msk = 0x8000
	// Bit RST_BTMAC_APB.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BTMAC_APB = 0x8000
	// Position of RST_BTMAC field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BTMAC_Pos = 0x10
	// Bit mask of RST_BTMAC field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BTMAC_Msk = 0x10000
	// Bit RST_BTMAC.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BTMAC = 0x10000
	// Position of RST_BTBB_APB field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BTBB_APB_Pos = 0x11
	// Bit mask of RST_BTBB_APB field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BTBB_APB_Msk = 0x20000
	// Bit RST_BTBB_APB.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BTBB_APB = 0x20000
	// Position of RST_BTBB field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BTBB_Pos = 0x12
	// Bit mask of RST_BTBB field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BTBB_Msk = 0x40000
	// Bit RST_BTBB.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BTBB = 0x40000
	// Position of RST_ETM field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_ETM_Pos = 0x16
	// Bit mask of RST_ETM field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_ETM_Msk = 0x400000
	// Bit RST_ETM.
	MODEM_SYSCON_MODEM_RST_CONF_RST_ETM = 0x400000
	// Position of RST_ZBMAC field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_ZBMAC_Pos = 0x18
	// Bit mask of RST_ZBMAC field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_ZBMAC_Msk = 0x1000000
	// Bit RST_ZBMAC.
	MODEM_SYSCON_MODEM_RST_CONF_RST_ZBMAC = 0x1000000
	// Position of RST_MODEM_ECB field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_MODEM_ECB_Pos = 0x19
	// Bit mask of RST_MODEM_ECB field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_MODEM_ECB_Msk = 0x2000000
	// Bit RST_MODEM_ECB.
	MODEM_SYSCON_MODEM_RST_CONF_RST_MODEM_ECB = 0x2000000
	// Position of RST_MODEM_CCM field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_MODEM_CCM_Pos = 0x1a
	// Bit mask of RST_MODEM_CCM field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_MODEM_CCM_Msk = 0x4000000
	// Bit RST_MODEM_CCM.
	MODEM_SYSCON_MODEM_RST_CONF_RST_MODEM_CCM = 0x4000000
	// Position of RST_MODEM_BAH field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_MODEM_BAH_Pos = 0x1b
	// Bit mask of RST_MODEM_BAH field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_MODEM_BAH_Msk = 0x8000000
	// Bit RST_MODEM_BAH.
	MODEM_SYSCON_MODEM_RST_CONF_RST_MODEM_BAH = 0x8000000
	// Position of RST_MODEM_SEC field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_MODEM_SEC_Pos = 0x1d
	// Bit mask of RST_MODEM_SEC field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_MODEM_SEC_Msk = 0x20000000
	// Bit RST_MODEM_SEC.
	MODEM_SYSCON_MODEM_RST_CONF_RST_MODEM_SEC = 0x20000000
	// Position of RST_BLE_TIMER field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BLE_TIMER_Pos = 0x1e
	// Bit mask of RST_BLE_TIMER field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BLE_TIMER_Msk = 0x40000000
	// Bit RST_BLE_TIMER.
	MODEM_SYSCON_MODEM_RST_CONF_RST_BLE_TIMER = 0x40000000
	// Position of RST_DATA_DUMP field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_DATA_DUMP_Pos = 0x1f
	// Bit mask of RST_DATA_DUMP field.
	MODEM_SYSCON_MODEM_RST_CONF_RST_DATA_DUMP_Msk = 0x80000000
	// Bit RST_DATA_DUMP.
	MODEM_SYSCON_MODEM_RST_CONF_RST_DATA_DUMP = 0x80000000

	// CLK_CONF1
	// Position of CLK_FE_16M_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_16M_EN_Pos = 0xc
	// Bit mask of CLK_FE_16M_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_16M_EN_Msk = 0x1000
	// Bit CLK_FE_16M_EN.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_16M_EN = 0x1000
	// Position of CLK_FE_32M_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_32M_EN_Pos = 0xd
	// Bit mask of CLK_FE_32M_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_32M_EN_Msk = 0x2000
	// Bit CLK_FE_32M_EN.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_32M_EN = 0x2000
	// Position of CLK_FE_SDM_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_SDM_EN_Pos = 0xe
	// Bit mask of CLK_FE_SDM_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_SDM_EN_Msk = 0x4000
	// Bit CLK_FE_SDM_EN.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_SDM_EN = 0x4000
	// Position of CLK_FE_ADC_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_ADC_EN_Pos = 0xf
	// Bit mask of CLK_FE_ADC_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_ADC_EN_Msk = 0x8000
	// Bit CLK_FE_ADC_EN.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_ADC_EN = 0x8000
	// Position of CLK_FE_APB_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_APB_EN_Pos = 0x10
	// Bit mask of CLK_FE_APB_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_APB_EN_Msk = 0x10000
	// Bit CLK_FE_APB_EN.
	MODEM_SYSCON_CLK_CONF1_CLK_FE_APB_EN = 0x10000
	// Position of CLK_BT_APB_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_BT_APB_EN_Pos = 0x11
	// Bit mask of CLK_BT_APB_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_BT_APB_EN_Msk = 0x20000
	// Bit CLK_BT_APB_EN.
	MODEM_SYSCON_CLK_CONF1_CLK_BT_APB_EN = 0x20000
	// Position of CLK_BT_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_BT_EN_Pos = 0x12
	// Bit mask of CLK_BT_EN field.
	MODEM_SYSCON_CLK_CONF1_CLK_BT_EN_Msk = 0x40000
	// Bit CLK_BT_EN.
	MODEM_SYSCON_CLK_CONF1_CLK_BT_EN = 0x40000

	// CLK_CONF1_FORCE_ON
	// Position of CLK_FE_FO field.
	MODEM_SYSCON_CLK_CONF1_FORCE_ON_CLK_FE_FO_Pos = 0x10
	// Bit mask of CLK_FE_FO field.
	MODEM_SYSCON_CLK_CONF1_FORCE_ON_CLK_FE_FO_Msk = 0x10000
	// Bit CLK_FE_FO.
	MODEM_SYSCON_CLK_CONF1_FORCE_ON_CLK_FE_FO = 0x10000
	// Position of CLK_BT_FO field.
	MODEM_SYSCON_CLK_CONF1_FORCE_ON_CLK_BT_FO_Pos = 0x12
	// Bit mask of CLK_BT_FO field.
	MODEM_SYSCON_CLK_CONF1_FORCE_ON_CLK_BT_FO_Msk = 0x40000
	// Bit CLK_BT_FO.
	MODEM_SYSCON_CLK_CONF1_FORCE_ON_CLK_BT_FO = 0x40000

	// MEM_CONF
	// Position of MODEM_MEM_WP field.
	MODEM_SYSCON_MEM_CONF_MODEM_MEM_WP_Pos = 0x0
	// Bit mask of MODEM_MEM_WP field.
	MODEM_SYSCON_MEM_CONF_MODEM_MEM_WP_Msk = 0x7
	// Position of MODEM_MEM_WA field.
	MODEM_SYSCON_MEM_CONF_MODEM_MEM_WA_Pos = 0x3
	// Bit mask of MODEM_MEM_WA field.
	MODEM_SYSCON_MEM_CONF_MODEM_MEM_WA_Msk = 0x38
	// Position of MODEM_MEM_RA field.
	MODEM_SYSCON_MEM_CONF_MODEM_MEM_RA_Pos = 0x6
	// Bit mask of MODEM_MEM_RA field.
	MODEM_SYSCON_MEM_CONF_MODEM_MEM_RA_Msk = 0xc0

	// DATE
	// Position of DATE field.
	MODEM_SYSCON_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	MODEM_SYSCON_DATE_DATE_Msk = 0xfffffff
)

// Constants for OTP_DEBUG: OTP_DEBUG Peripheral
const (
	// WR_DIS: Otp debuger block0 data register1.
	// Position of BLOCK0_WR_DIS field.
	OTP_DEBUG_WR_DIS_BLOCK0_WR_DIS_Pos = 0x0
	// Bit mask of BLOCK0_WR_DIS field.
	OTP_DEBUG_WR_DIS_BLOCK0_WR_DIS_Msk = 0xffffffff

	// BLK0_BACKUP1_W1: Otp debuger block0 data register2.
	// Position of OTP_BEBUG_BLOCK0_BACKUP1_W1 field.
	OTP_DEBUG_BLK0_BACKUP1_W1_OTP_BEBUG_BLOCK0_BACKUP1_W1_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP1_W1 field.
	OTP_DEBUG_BLK0_BACKUP1_W1_OTP_BEBUG_BLOCK0_BACKUP1_W1_Msk = 0xffffffff

	// BLK0_BACKUP1_W2: Otp debuger block0 data register3.
	// Position of OTP_BEBUG_BLOCK0_BACKUP1_W2 field.
	OTP_DEBUG_BLK0_BACKUP1_W2_OTP_BEBUG_BLOCK0_BACKUP1_W2_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP1_W2 field.
	OTP_DEBUG_BLK0_BACKUP1_W2_OTP_BEBUG_BLOCK0_BACKUP1_W2_Msk = 0xffffffff

	// BLK0_BACKUP1_W3: Otp debuger block0 data register4.
	// Position of OTP_BEBUG_BLOCK0_BACKUP1_W3 field.
	OTP_DEBUG_BLK0_BACKUP1_W3_OTP_BEBUG_BLOCK0_BACKUP1_W3_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP1_W3 field.
	OTP_DEBUG_BLK0_BACKUP1_W3_OTP_BEBUG_BLOCK0_BACKUP1_W3_Msk = 0xffffffff

	// BLK0_BACKUP1_W4: Otp debuger block0 data register5.
	// Position of OTP_BEBUG_BLOCK0_BACKUP1_W4 field.
	OTP_DEBUG_BLK0_BACKUP1_W4_OTP_BEBUG_BLOCK0_BACKUP1_W4_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP1_W4 field.
	OTP_DEBUG_BLK0_BACKUP1_W4_OTP_BEBUG_BLOCK0_BACKUP1_W4_Msk = 0xffffffff

	// BLK0_BACKUP1_W5: Otp debuger block0 data register6.
	// Position of OTP_BEBUG_BLOCK0_BACKUP1_W5 field.
	OTP_DEBUG_BLK0_BACKUP1_W5_OTP_BEBUG_BLOCK0_BACKUP1_W5_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP1_W5 field.
	OTP_DEBUG_BLK0_BACKUP1_W5_OTP_BEBUG_BLOCK0_BACKUP1_W5_Msk = 0xffffffff

	// BLK0_BACKUP2_W1: Otp debuger block0 data register7.
	// Position of OTP_BEBUG_BLOCK0_BACKUP2_W1 field.
	OTP_DEBUG_BLK0_BACKUP2_W1_OTP_BEBUG_BLOCK0_BACKUP2_W1_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP2_W1 field.
	OTP_DEBUG_BLK0_BACKUP2_W1_OTP_BEBUG_BLOCK0_BACKUP2_W1_Msk = 0xffffffff

	// BLK0_BACKUP2_W2: Otp debuger block0 data register8.
	// Position of OTP_BEBUG_BLOCK0_BACKUP2_W2 field.
	OTP_DEBUG_BLK0_BACKUP2_W2_OTP_BEBUG_BLOCK0_BACKUP2_W2_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP2_W2 field.
	OTP_DEBUG_BLK0_BACKUP2_W2_OTP_BEBUG_BLOCK0_BACKUP2_W2_Msk = 0xffffffff

	// BLK0_BACKUP2_W3: Otp debuger block0 data register9.
	// Position of OTP_BEBUG_BLOCK0_BACKUP2_W3 field.
	OTP_DEBUG_BLK0_BACKUP2_W3_OTP_BEBUG_BLOCK0_BACKUP2_W3_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP2_W3 field.
	OTP_DEBUG_BLK0_BACKUP2_W3_OTP_BEBUG_BLOCK0_BACKUP2_W3_Msk = 0xffffffff

	// BLK0_BACKUP2_W4: Otp debuger block0 data register10.
	// Position of OTP_BEBUG_BLOCK0_BACKUP2_W4 field.
	OTP_DEBUG_BLK0_BACKUP2_W4_OTP_BEBUG_BLOCK0_BACKUP2_W4_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP2_W4 field.
	OTP_DEBUG_BLK0_BACKUP2_W4_OTP_BEBUG_BLOCK0_BACKUP2_W4_Msk = 0xffffffff

	// BLK0_BACKUP2_W5: Otp debuger block0 data register11.
	// Position of OTP_BEBUG_BLOCK0_BACKUP2_W5 field.
	OTP_DEBUG_BLK0_BACKUP2_W5_OTP_BEBUG_BLOCK0_BACKUP2_W5_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP2_W5 field.
	OTP_DEBUG_BLK0_BACKUP2_W5_OTP_BEBUG_BLOCK0_BACKUP2_W5_Msk = 0xffffffff

	// BLK0_BACKUP3_W1: Otp debuger block0 data register12.
	// Position of OTP_BEBUG_BLOCK0_BACKUP3_W1 field.
	OTP_DEBUG_BLK0_BACKUP3_W1_OTP_BEBUG_BLOCK0_BACKUP3_W1_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP3_W1 field.
	OTP_DEBUG_BLK0_BACKUP3_W1_OTP_BEBUG_BLOCK0_BACKUP3_W1_Msk = 0xffffffff

	// BLK0_BACKUP3_W2: Otp debuger block0 data register13.
	// Position of OTP_BEBUG_BLOCK0_BACKUP3_W2 field.
	OTP_DEBUG_BLK0_BACKUP3_W2_OTP_BEBUG_BLOCK0_BACKUP3_W2_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP3_W2 field.
	OTP_DEBUG_BLK0_BACKUP3_W2_OTP_BEBUG_BLOCK0_BACKUP3_W2_Msk = 0xffffffff

	// BLK0_BACKUP3_W3: Otp debuger block0 data register14.
	// Position of OTP_BEBUG_BLOCK0_BACKUP3_W3 field.
	OTP_DEBUG_BLK0_BACKUP3_W3_OTP_BEBUG_BLOCK0_BACKUP3_W3_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP3_W3 field.
	OTP_DEBUG_BLK0_BACKUP3_W3_OTP_BEBUG_BLOCK0_BACKUP3_W3_Msk = 0xffffffff

	// BLK0_BACKUP3_W4: Otp debuger block0 data register15.
	// Position of OTP_BEBUG_BLOCK0_BACKUP3_W4 field.
	OTP_DEBUG_BLK0_BACKUP3_W4_OTP_BEBUG_BLOCK0_BACKUP3_W4_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP3_W4 field.
	OTP_DEBUG_BLK0_BACKUP3_W4_OTP_BEBUG_BLOCK0_BACKUP3_W4_Msk = 0xffffffff

	// BLK0_BACKUP3_W5: Otp debuger block0 data register16.
	// Position of OTP_BEBUG_BLOCK0_BACKUP3_W5 field.
	OTP_DEBUG_BLK0_BACKUP3_W5_OTP_BEBUG_BLOCK0_BACKUP3_W5_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP3_W5 field.
	OTP_DEBUG_BLK0_BACKUP3_W5_OTP_BEBUG_BLOCK0_BACKUP3_W5_Msk = 0xffffffff

	// BLK0_BACKUP4_W1: Otp debuger block0 data register17.
	// Position of OTP_BEBUG_BLOCK0_BACKUP4_W1 field.
	OTP_DEBUG_BLK0_BACKUP4_W1_OTP_BEBUG_BLOCK0_BACKUP4_W1_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP4_W1 field.
	OTP_DEBUG_BLK0_BACKUP4_W1_OTP_BEBUG_BLOCK0_BACKUP4_W1_Msk = 0xffffffff

	// BLK0_BACKUP4_W2: Otp debuger block0 data register18.
	// Position of OTP_BEBUG_BLOCK0_BACKUP4_W2 field.
	OTP_DEBUG_BLK0_BACKUP4_W2_OTP_BEBUG_BLOCK0_BACKUP4_W2_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP4_W2 field.
	OTP_DEBUG_BLK0_BACKUP4_W2_OTP_BEBUG_BLOCK0_BACKUP4_W2_Msk = 0xffffffff

	// BLK0_BACKUP4_W3: Otp debuger block0 data register19.
	// Position of OTP_BEBUG_BLOCK0_BACKUP4_W3 field.
	OTP_DEBUG_BLK0_BACKUP4_W3_OTP_BEBUG_BLOCK0_BACKUP4_W3_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP4_W3 field.
	OTP_DEBUG_BLK0_BACKUP4_W3_OTP_BEBUG_BLOCK0_BACKUP4_W3_Msk = 0xffffffff

	// BLK0_BACKUP4_W4: Otp debuger block0 data register20.
	// Position of OTP_BEBUG_BLOCK0_BACKUP4_W4 field.
	OTP_DEBUG_BLK0_BACKUP4_W4_OTP_BEBUG_BLOCK0_BACKUP4_W4_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP4_W4 field.
	OTP_DEBUG_BLK0_BACKUP4_W4_OTP_BEBUG_BLOCK0_BACKUP4_W4_Msk = 0xffffffff

	// BLK0_BACKUP4_W5: Otp debuger block0 data register21.
	// Position of OTP_BEBUG_BLOCK0_BACKUP4_W5 field.
	OTP_DEBUG_BLK0_BACKUP4_W5_OTP_BEBUG_BLOCK0_BACKUP4_W5_Pos = 0x0
	// Bit mask of OTP_BEBUG_BLOCK0_BACKUP4_W5 field.
	OTP_DEBUG_BLK0_BACKUP4_W5_OTP_BEBUG_BLOCK0_BACKUP4_W5_Msk = 0xffffffff

	// BLK1_W1: Otp debuger block1 data register1.
	// Position of BLOCK1_W1 field.
	OTP_DEBUG_BLK1_W1_BLOCK1_W1_Pos = 0x0
	// Bit mask of BLOCK1_W1 field.
	OTP_DEBUG_BLK1_W1_BLOCK1_W1_Msk = 0xffffffff

	// BLK1_W2: Otp debuger block1 data register2.
	// Position of BLOCK1_W2 field.
	OTP_DEBUG_BLK1_W2_BLOCK1_W2_Pos = 0x0
	// Bit mask of BLOCK1_W2 field.
	OTP_DEBUG_BLK1_W2_BLOCK1_W2_Msk = 0xffffffff

	// BLK1_W3: Otp debuger block1 data register3.
	// Position of BLOCK1_W3 field.
	OTP_DEBUG_BLK1_W3_BLOCK1_W3_Pos = 0x0
	// Bit mask of BLOCK1_W3 field.
	OTP_DEBUG_BLK1_W3_BLOCK1_W3_Msk = 0xffffffff

	// BLK1_W4: Otp debuger block1 data register4.
	// Position of BLOCK1_W4 field.
	OTP_DEBUG_BLK1_W4_BLOCK1_W4_Pos = 0x0
	// Bit mask of BLOCK1_W4 field.
	OTP_DEBUG_BLK1_W4_BLOCK1_W4_Msk = 0xffffffff

	// BLK1_W5: Otp debuger block1 data register5.
	// Position of BLOCK1_W5 field.
	OTP_DEBUG_BLK1_W5_BLOCK1_W5_Pos = 0x0
	// Bit mask of BLOCK1_W5 field.
	OTP_DEBUG_BLK1_W5_BLOCK1_W5_Msk = 0xffffffff

	// BLK1_W6: Otp debuger block1 data register6.
	// Position of BLOCK1_W6 field.
	OTP_DEBUG_BLK1_W6_BLOCK1_W6_Pos = 0x0
	// Bit mask of BLOCK1_W6 field.
	OTP_DEBUG_BLK1_W6_BLOCK1_W6_Msk = 0xffffffff

	// BLK1_W7: Otp debuger block1 data register7.
	// Position of BLOCK1_W7 field.
	OTP_DEBUG_BLK1_W7_BLOCK1_W7_Pos = 0x0
	// Bit mask of BLOCK1_W7 field.
	OTP_DEBUG_BLK1_W7_BLOCK1_W7_Msk = 0xffffffff

	// BLK1_W8: Otp debuger block1 data register8.
	// Position of BLOCK1_W8 field.
	OTP_DEBUG_BLK1_W8_BLOCK1_W8_Pos = 0x0
	// Bit mask of BLOCK1_W8 field.
	OTP_DEBUG_BLK1_W8_BLOCK1_W8_Msk = 0xffffffff

	// BLK1_W9: Otp debuger block1 data register9.
	// Position of BLOCK1_W9 field.
	OTP_DEBUG_BLK1_W9_BLOCK1_W9_Pos = 0x0
	// Bit mask of BLOCK1_W9 field.
	OTP_DEBUG_BLK1_W9_BLOCK1_W9_Msk = 0xffffffff

	// BLK2_W1: Otp debuger block2 data register1.
	// Position of BLOCK2_W1 field.
	OTP_DEBUG_BLK2_W1_BLOCK2_W1_Pos = 0x0
	// Bit mask of BLOCK2_W1 field.
	OTP_DEBUG_BLK2_W1_BLOCK2_W1_Msk = 0xffffffff

	// BLK2_W2: Otp debuger block2 data register2.
	// Position of BLOCK2_W2 field.
	OTP_DEBUG_BLK2_W2_BLOCK2_W2_Pos = 0x0
	// Bit mask of BLOCK2_W2 field.
	OTP_DEBUG_BLK2_W2_BLOCK2_W2_Msk = 0xffffffff

	// BLK2_W3: Otp debuger block2 data register3.
	// Position of BLOCK2_W3 field.
	OTP_DEBUG_BLK2_W3_BLOCK2_W3_Pos = 0x0
	// Bit mask of BLOCK2_W3 field.
	OTP_DEBUG_BLK2_W3_BLOCK2_W3_Msk = 0xffffffff

	// BLK2_W4: Otp debuger block2 data register4.
	// Position of BLOCK2_W4 field.
	OTP_DEBUG_BLK2_W4_BLOCK2_W4_Pos = 0x0
	// Bit mask of BLOCK2_W4 field.
	OTP_DEBUG_BLK2_W4_BLOCK2_W4_Msk = 0xffffffff

	// BLK2_W5: Otp debuger block2 data register5.
	// Position of BLOCK2_W5 field.
	OTP_DEBUG_BLK2_W5_BLOCK2_W5_Pos = 0x0
	// Bit mask of BLOCK2_W5 field.
	OTP_DEBUG_BLK2_W5_BLOCK2_W5_Msk = 0xffffffff

	// BLK2_W6: Otp debuger block2 data register6.
	// Position of BLOCK2_W6 field.
	OTP_DEBUG_BLK2_W6_BLOCK2_W6_Pos = 0x0
	// Bit mask of BLOCK2_W6 field.
	OTP_DEBUG_BLK2_W6_BLOCK2_W6_Msk = 0xffffffff

	// BLK2_W7: Otp debuger block2 data register7.
	// Position of BLOCK2_W7 field.
	OTP_DEBUG_BLK2_W7_BLOCK2_W7_Pos = 0x0
	// Bit mask of BLOCK2_W7 field.
	OTP_DEBUG_BLK2_W7_BLOCK2_W7_Msk = 0xffffffff

	// BLK2_W8: Otp debuger block2 data register8.
	// Position of BLOCK2_W8 field.
	OTP_DEBUG_BLK2_W8_BLOCK2_W8_Pos = 0x0
	// Bit mask of BLOCK2_W8 field.
	OTP_DEBUG_BLK2_W8_BLOCK2_W8_Msk = 0xffffffff

	// BLK2_W9: Otp debuger block2 data register9.
	// Position of BLOCK2_W9 field.
	OTP_DEBUG_BLK2_W9_BLOCK2_W9_Pos = 0x0
	// Bit mask of BLOCK2_W9 field.
	OTP_DEBUG_BLK2_W9_BLOCK2_W9_Msk = 0xffffffff

	// BLK2_W10: Otp debuger block2 data register10.
	// Position of BLOCK2_W10 field.
	OTP_DEBUG_BLK2_W10_BLOCK2_W10_Pos = 0x0
	// Bit mask of BLOCK2_W10 field.
	OTP_DEBUG_BLK2_W10_BLOCK2_W10_Msk = 0xffffffff

	// BLK2_W11: Otp debuger block2 data register11.
	// Position of BLOCK2_W11 field.
	OTP_DEBUG_BLK2_W11_BLOCK2_W11_Pos = 0x0
	// Bit mask of BLOCK2_W11 field.
	OTP_DEBUG_BLK2_W11_BLOCK2_W11_Msk = 0xffffffff

	// BLK3_W1: Otp debuger block3 data register1.
	// Position of BLOCK3_W1 field.
	OTP_DEBUG_BLK3_W1_BLOCK3_W1_Pos = 0x0
	// Bit mask of BLOCK3_W1 field.
	OTP_DEBUG_BLK3_W1_BLOCK3_W1_Msk = 0xffffffff

	// BLK3_W2: Otp debuger block3 data register2.
	// Position of BLOCK3_W2 field.
	OTP_DEBUG_BLK3_W2_BLOCK3_W2_Pos = 0x0
	// Bit mask of BLOCK3_W2 field.
	OTP_DEBUG_BLK3_W2_BLOCK3_W2_Msk = 0xffffffff

	// BLK3_W3: Otp debuger block3 data register3.
	// Position of BLOCK3_W3 field.
	OTP_DEBUG_BLK3_W3_BLOCK3_W3_Pos = 0x0
	// Bit mask of BLOCK3_W3 field.
	OTP_DEBUG_BLK3_W3_BLOCK3_W3_Msk = 0xffffffff

	// BLK3_W4: Otp debuger block3 data register4.
	// Position of BLOCK3_W4 field.
	OTP_DEBUG_BLK3_W4_BLOCK3_W4_Pos = 0x0
	// Bit mask of BLOCK3_W4 field.
	OTP_DEBUG_BLK3_W4_BLOCK3_W4_Msk = 0xffffffff

	// BLK3_W5: Otp debuger block3 data register5.
	// Position of BLOCK3_W5 field.
	OTP_DEBUG_BLK3_W5_BLOCK3_W5_Pos = 0x0
	// Bit mask of BLOCK3_W5 field.
	OTP_DEBUG_BLK3_W5_BLOCK3_W5_Msk = 0xffffffff

	// BLK3_W6: Otp debuger block3 data register6.
	// Position of BLOCK3_W6 field.
	OTP_DEBUG_BLK3_W6_BLOCK3_W6_Pos = 0x0
	// Bit mask of BLOCK3_W6 field.
	OTP_DEBUG_BLK3_W6_BLOCK3_W6_Msk = 0xffffffff

	// BLK3_W7: Otp debuger block3 data register7.
	// Position of BLOCK3_W7 field.
	OTP_DEBUG_BLK3_W7_BLOCK3_W7_Pos = 0x0
	// Bit mask of BLOCK3_W7 field.
	OTP_DEBUG_BLK3_W7_BLOCK3_W7_Msk = 0xffffffff

	// BLK3_W8: Otp debuger block3 data register8.
	// Position of BLOCK3_W8 field.
	OTP_DEBUG_BLK3_W8_BLOCK3_W8_Pos = 0x0
	// Bit mask of BLOCK3_W8 field.
	OTP_DEBUG_BLK3_W8_BLOCK3_W8_Msk = 0xffffffff

	// BLK3_W9: Otp debuger block3 data register9.
	// Position of BLOCK3_W9 field.
	OTP_DEBUG_BLK3_W9_BLOCK3_W9_Pos = 0x0
	// Bit mask of BLOCK3_W9 field.
	OTP_DEBUG_BLK3_W9_BLOCK3_W9_Msk = 0xffffffff

	// BLK3_W10: Otp debuger block3 data register10.
	// Position of BLOCK3_W10 field.
	OTP_DEBUG_BLK3_W10_BLOCK3_W10_Pos = 0x0
	// Bit mask of BLOCK3_W10 field.
	OTP_DEBUG_BLK3_W10_BLOCK3_W10_Msk = 0xffffffff

	// BLK3_W11: Otp debuger block3 data register11.
	// Position of BLOCK3_W11 field.
	OTP_DEBUG_BLK3_W11_BLOCK3_W11_Pos = 0x0
	// Bit mask of BLOCK3_W11 field.
	OTP_DEBUG_BLK3_W11_BLOCK3_W11_Msk = 0xffffffff

	// BLK4_W1: Otp debuger block4 data register1.
	// Position of BLOCK4_W1 field.
	OTP_DEBUG_BLK4_W1_BLOCK4_W1_Pos = 0x0
	// Bit mask of BLOCK4_W1 field.
	OTP_DEBUG_BLK4_W1_BLOCK4_W1_Msk = 0xffffffff

	// BLK4_W2: Otp debuger block4 data register2.
	// Position of BLOCK4_W2 field.
	OTP_DEBUG_BLK4_W2_BLOCK4_W2_Pos = 0x0
	// Bit mask of BLOCK4_W2 field.
	OTP_DEBUG_BLK4_W2_BLOCK4_W2_Msk = 0xffffffff

	// BLK4_W3: Otp debuger block4 data register3.
	// Position of BLOCK4_W3 field.
	OTP_DEBUG_BLK4_W3_BLOCK4_W3_Pos = 0x0
	// Bit mask of BLOCK4_W3 field.
	OTP_DEBUG_BLK4_W3_BLOCK4_W3_Msk = 0xffffffff

	// BLK4_W4: Otp debuger block4 data register4.
	// Position of BLOCK4_W4 field.
	OTP_DEBUG_BLK4_W4_BLOCK4_W4_Pos = 0x0
	// Bit mask of BLOCK4_W4 field.
	OTP_DEBUG_BLK4_W4_BLOCK4_W4_Msk = 0xffffffff

	// BLK4_W5: Otp debuger block4 data register5.
	// Position of BLOCK4_W5 field.
	OTP_DEBUG_BLK4_W5_BLOCK4_W5_Pos = 0x0
	// Bit mask of BLOCK4_W5 field.
	OTP_DEBUG_BLK4_W5_BLOCK4_W5_Msk = 0xffffffff

	// BLK4_W6: Otp debuger block4 data register6.
	// Position of BLOCK4_W6 field.
	OTP_DEBUG_BLK4_W6_BLOCK4_W6_Pos = 0x0
	// Bit mask of BLOCK4_W6 field.
	OTP_DEBUG_BLK4_W6_BLOCK4_W6_Msk = 0xffffffff

	// BLK4_W7: Otp debuger block4 data register7.
	// Position of BLOCK4_W7 field.
	OTP_DEBUG_BLK4_W7_BLOCK4_W7_Pos = 0x0
	// Bit mask of BLOCK4_W7 field.
	OTP_DEBUG_BLK4_W7_BLOCK4_W7_Msk = 0xffffffff

	// BLK4_W8: Otp debuger block4 data register8.
	// Position of BLOCK4_W8 field.
	OTP_DEBUG_BLK4_W8_BLOCK4_W8_Pos = 0x0
	// Bit mask of BLOCK4_W8 field.
	OTP_DEBUG_BLK4_W8_BLOCK4_W8_Msk = 0xffffffff

	// BLK4_W9: Otp debuger block4 data register9.
	// Position of BLOCK4_W9 field.
	OTP_DEBUG_BLK4_W9_BLOCK4_W9_Pos = 0x0
	// Bit mask of BLOCK4_W9 field.
	OTP_DEBUG_BLK4_W9_BLOCK4_W9_Msk = 0xffffffff

	// BLK4_W10: Otp debuger block4 data registe10.
	// Position of BLOCK4_W10 field.
	OTP_DEBUG_BLK4_W10_BLOCK4_W10_Pos = 0x0
	// Bit mask of BLOCK4_W10 field.
	OTP_DEBUG_BLK4_W10_BLOCK4_W10_Msk = 0xffffffff

	// BLK4_W11: Otp debuger block4 data register11.
	// Position of BLOCK4_W11 field.
	OTP_DEBUG_BLK4_W11_BLOCK4_W11_Pos = 0x0
	// Bit mask of BLOCK4_W11 field.
	OTP_DEBUG_BLK4_W11_BLOCK4_W11_Msk = 0xffffffff

	// BLK5_W1: Otp debuger block5 data register1.
	// Position of BLOCK5_W1 field.
	OTP_DEBUG_BLK5_W1_BLOCK5_W1_Pos = 0x0
	// Bit mask of BLOCK5_W1 field.
	OTP_DEBUG_BLK5_W1_BLOCK5_W1_Msk = 0xffffffff

	// BLK5_W2: Otp debuger block5 data register2.
	// Position of BLOCK5_W2 field.
	OTP_DEBUG_BLK5_W2_BLOCK5_W2_Pos = 0x0
	// Bit mask of BLOCK5_W2 field.
	OTP_DEBUG_BLK5_W2_BLOCK5_W2_Msk = 0xffffffff

	// BLK5_W3: Otp debuger block5 data register3.
	// Position of BLOCK5_W3 field.
	OTP_DEBUG_BLK5_W3_BLOCK5_W3_Pos = 0x0
	// Bit mask of BLOCK5_W3 field.
	OTP_DEBUG_BLK5_W3_BLOCK5_W3_Msk = 0xffffffff

	// BLK5_W4: Otp debuger block5 data register4.
	// Position of BLOCK5_W4 field.
	OTP_DEBUG_BLK5_W4_BLOCK5_W4_Pos = 0x0
	// Bit mask of BLOCK5_W4 field.
	OTP_DEBUG_BLK5_W4_BLOCK5_W4_Msk = 0xffffffff

	// BLK5_W5: Otp debuger block5 data register5.
	// Position of BLOCK5_W5 field.
	OTP_DEBUG_BLK5_W5_BLOCK5_W5_Pos = 0x0
	// Bit mask of BLOCK5_W5 field.
	OTP_DEBUG_BLK5_W5_BLOCK5_W5_Msk = 0xffffffff

	// BLK5_W6: Otp debuger block5 data register6.
	// Position of BLOCK5_W6 field.
	OTP_DEBUG_BLK5_W6_BLOCK5_W6_Pos = 0x0
	// Bit mask of BLOCK5_W6 field.
	OTP_DEBUG_BLK5_W6_BLOCK5_W6_Msk = 0xffffffff

	// BLK5_W7: Otp debuger block5 data register7.
	// Position of BLOCK5_W7 field.
	OTP_DEBUG_BLK5_W7_BLOCK5_W7_Pos = 0x0
	// Bit mask of BLOCK5_W7 field.
	OTP_DEBUG_BLK5_W7_BLOCK5_W7_Msk = 0xffffffff

	// BLK5_W8: Otp debuger block5 data register8.
	// Position of BLOCK5_W8 field.
	OTP_DEBUG_BLK5_W8_BLOCK5_W8_Pos = 0x0
	// Bit mask of BLOCK5_W8 field.
	OTP_DEBUG_BLK5_W8_BLOCK5_W8_Msk = 0xffffffff

	// BLK5_W9: Otp debuger block5 data register9.
	// Position of BLOCK5_W9 field.
	OTP_DEBUG_BLK5_W9_BLOCK5_W9_Pos = 0x0
	// Bit mask of BLOCK5_W9 field.
	OTP_DEBUG_BLK5_W9_BLOCK5_W9_Msk = 0xffffffff

	// BLK5_W10: Otp debuger block5 data register10.
	// Position of BLOCK5_W10 field.
	OTP_DEBUG_BLK5_W10_BLOCK5_W10_Pos = 0x0
	// Bit mask of BLOCK5_W10 field.
	OTP_DEBUG_BLK5_W10_BLOCK5_W10_Msk = 0xffffffff

	// BLK5_W11: Otp debuger block5 data register11.
	// Position of BLOCK5_W11 field.
	OTP_DEBUG_BLK5_W11_BLOCK5_W11_Pos = 0x0
	// Bit mask of BLOCK5_W11 field.
	OTP_DEBUG_BLK5_W11_BLOCK5_W11_Msk = 0xffffffff

	// BLK6_W1: Otp debuger block6 data register1.
	// Position of BLOCK6_W1 field.
	OTP_DEBUG_BLK6_W1_BLOCK6_W1_Pos = 0x0
	// Bit mask of BLOCK6_W1 field.
	OTP_DEBUG_BLK6_W1_BLOCK6_W1_Msk = 0xffffffff

	// BLK6_W2: Otp debuger block6 data register2.
	// Position of BLOCK6_W2 field.
	OTP_DEBUG_BLK6_W2_BLOCK6_W2_Pos = 0x0
	// Bit mask of BLOCK6_W2 field.
	OTP_DEBUG_BLK6_W2_BLOCK6_W2_Msk = 0xffffffff

	// BLK6_W3: Otp debuger block6 data register3.
	// Position of BLOCK6_W3 field.
	OTP_DEBUG_BLK6_W3_BLOCK6_W3_Pos = 0x0
	// Bit mask of BLOCK6_W3 field.
	OTP_DEBUG_BLK6_W3_BLOCK6_W3_Msk = 0xffffffff

	// BLK6_W4: Otp debuger block6 data register4.
	// Position of BLOCK6_W4 field.
	OTP_DEBUG_BLK6_W4_BLOCK6_W4_Pos = 0x0
	// Bit mask of BLOCK6_W4 field.
	OTP_DEBUG_BLK6_W4_BLOCK6_W4_Msk = 0xffffffff

	// BLK6_W5: Otp debuger block6 data register5.
	// Position of BLOCK6_W5 field.
	OTP_DEBUG_BLK6_W5_BLOCK6_W5_Pos = 0x0
	// Bit mask of BLOCK6_W5 field.
	OTP_DEBUG_BLK6_W5_BLOCK6_W5_Msk = 0xffffffff

	// BLK6_W6: Otp debuger block6 data register6.
	// Position of BLOCK6_W6 field.
	OTP_DEBUG_BLK6_W6_BLOCK6_W6_Pos = 0x0
	// Bit mask of BLOCK6_W6 field.
	OTP_DEBUG_BLK6_W6_BLOCK6_W6_Msk = 0xffffffff

	// BLK6_W7: Otp debuger block6 data register7.
	// Position of BLOCK6_W7 field.
	OTP_DEBUG_BLK6_W7_BLOCK6_W7_Pos = 0x0
	// Bit mask of BLOCK6_W7 field.
	OTP_DEBUG_BLK6_W7_BLOCK6_W7_Msk = 0xffffffff

	// BLK6_W8: Otp debuger block6 data register8.
	// Position of BLOCK6_W8 field.
	OTP_DEBUG_BLK6_W8_BLOCK6_W8_Pos = 0x0
	// Bit mask of BLOCK6_W8 field.
	OTP_DEBUG_BLK6_W8_BLOCK6_W8_Msk = 0xffffffff

	// BLK6_W9: Otp debuger block6 data register9.
	// Position of BLOCK6_W9 field.
	OTP_DEBUG_BLK6_W9_BLOCK6_W9_Pos = 0x0
	// Bit mask of BLOCK6_W9 field.
	OTP_DEBUG_BLK6_W9_BLOCK6_W9_Msk = 0xffffffff

	// BLK6_W10: Otp debuger block6 data register10.
	// Position of BLOCK6_W10 field.
	OTP_DEBUG_BLK6_W10_BLOCK6_W10_Pos = 0x0
	// Bit mask of BLOCK6_W10 field.
	OTP_DEBUG_BLK6_W10_BLOCK6_W10_Msk = 0xffffffff

	// BLK6_W11: Otp debuger block6 data register11.
	// Position of BLOCK6_W11 field.
	OTP_DEBUG_BLK6_W11_BLOCK6_W11_Pos = 0x0
	// Bit mask of BLOCK6_W11 field.
	OTP_DEBUG_BLK6_W11_BLOCK6_W11_Msk = 0xffffffff

	// BLK7_W1: Otp debuger block7 data register1.
	// Position of BLOCK7_W1 field.
	OTP_DEBUG_BLK7_W1_BLOCK7_W1_Pos = 0x0
	// Bit mask of BLOCK7_W1 field.
	OTP_DEBUG_BLK7_W1_BLOCK7_W1_Msk = 0xffffffff

	// BLK7_W2: Otp debuger block7 data register2.
	// Position of BLOCK7_W2 field.
	OTP_DEBUG_BLK7_W2_BLOCK7_W2_Pos = 0x0
	// Bit mask of BLOCK7_W2 field.
	OTP_DEBUG_BLK7_W2_BLOCK7_W2_Msk = 0xffffffff

	// BLK7_W3: Otp debuger block7 data register3.
	// Position of BLOCK7_W3 field.
	OTP_DEBUG_BLK7_W3_BLOCK7_W3_Pos = 0x0
	// Bit mask of BLOCK7_W3 field.
	OTP_DEBUG_BLK7_W3_BLOCK7_W3_Msk = 0xffffffff

	// BLK7_W4: Otp debuger block7 data register4.
	// Position of BLOCK7_W4 field.
	OTP_DEBUG_BLK7_W4_BLOCK7_W4_Pos = 0x0
	// Bit mask of BLOCK7_W4 field.
	OTP_DEBUG_BLK7_W4_BLOCK7_W4_Msk = 0xffffffff

	// BLK7_W5: Otp debuger block7 data register5.
	// Position of BLOCK7_W5 field.
	OTP_DEBUG_BLK7_W5_BLOCK7_W5_Pos = 0x0
	// Bit mask of BLOCK7_W5 field.
	OTP_DEBUG_BLK7_W5_BLOCK7_W5_Msk = 0xffffffff

	// BLK7_W6: Otp debuger block7 data register6.
	// Position of BLOCK7_W6 field.
	OTP_DEBUG_BLK7_W6_BLOCK7_W6_Pos = 0x0
	// Bit mask of BLOCK7_W6 field.
	OTP_DEBUG_BLK7_W6_BLOCK7_W6_Msk = 0xffffffff

	// BLK7_W7: Otp debuger block7 data register7.
	// Position of BLOCK7_W7 field.
	OTP_DEBUG_BLK7_W7_BLOCK7_W7_Pos = 0x0
	// Bit mask of BLOCK7_W7 field.
	OTP_DEBUG_BLK7_W7_BLOCK7_W7_Msk = 0xffffffff

	// BLK7_W8: Otp debuger block7 data register8.
	// Position of BLOCK7_W8 field.
	OTP_DEBUG_BLK7_W8_BLOCK7_W8_Pos = 0x0
	// Bit mask of BLOCK7_W8 field.
	OTP_DEBUG_BLK7_W8_BLOCK7_W8_Msk = 0xffffffff

	// BLK7_W9: Otp debuger block7 data register9.
	// Position of BLOCK7_W9 field.
	OTP_DEBUG_BLK7_W9_BLOCK7_W9_Pos = 0x0
	// Bit mask of BLOCK7_W9 field.
	OTP_DEBUG_BLK7_W9_BLOCK7_W9_Msk = 0xffffffff

	// BLK7_W10: Otp debuger block7 data register10.
	// Position of BLOCK7_W10 field.
	OTP_DEBUG_BLK7_W10_BLOCK7_W10_Pos = 0x0
	// Bit mask of BLOCK7_W10 field.
	OTP_DEBUG_BLK7_W10_BLOCK7_W10_Msk = 0xffffffff

	// BLK7_W11: Otp debuger block7 data register11.
	// Position of BLOCK7_W11 field.
	OTP_DEBUG_BLK7_W11_BLOCK7_W11_Pos = 0x0
	// Bit mask of BLOCK7_W11 field.
	OTP_DEBUG_BLK7_W11_BLOCK7_W11_Msk = 0xffffffff

	// BLK8_W1: Otp debuger block8 data register1.
	// Position of BLOCK8_W1 field.
	OTP_DEBUG_BLK8_W1_BLOCK8_W1_Pos = 0x0
	// Bit mask of BLOCK8_W1 field.
	OTP_DEBUG_BLK8_W1_BLOCK8_W1_Msk = 0xffffffff

	// BLK8_W2: Otp debuger block8 data register2.
	// Position of BLOCK8_W2 field.
	OTP_DEBUG_BLK8_W2_BLOCK8_W2_Pos = 0x0
	// Bit mask of BLOCK8_W2 field.
	OTP_DEBUG_BLK8_W2_BLOCK8_W2_Msk = 0xffffffff

	// BLK8_W3: Otp debuger block8 data register3.
	// Position of BLOCK8_W3 field.
	OTP_DEBUG_BLK8_W3_BLOCK8_W3_Pos = 0x0
	// Bit mask of BLOCK8_W3 field.
	OTP_DEBUG_BLK8_W3_BLOCK8_W3_Msk = 0xffffffff

	// BLK8_W4: Otp debuger block8 data register4.
	// Position of BLOCK8_W4 field.
	OTP_DEBUG_BLK8_W4_BLOCK8_W4_Pos = 0x0
	// Bit mask of BLOCK8_W4 field.
	OTP_DEBUG_BLK8_W4_BLOCK8_W4_Msk = 0xffffffff

	// BLK8_W5: Otp debuger block8 data register5.
	// Position of BLOCK8_W5 field.
	OTP_DEBUG_BLK8_W5_BLOCK8_W5_Pos = 0x0
	// Bit mask of BLOCK8_W5 field.
	OTP_DEBUG_BLK8_W5_BLOCK8_W5_Msk = 0xffffffff

	// BLK8_W6: Otp debuger block8 data register6.
	// Position of BLOCK8_W6 field.
	OTP_DEBUG_BLK8_W6_BLOCK8_W6_Pos = 0x0
	// Bit mask of BLOCK8_W6 field.
	OTP_DEBUG_BLK8_W6_BLOCK8_W6_Msk = 0xffffffff

	// BLK8_W7: Otp debuger block8 data register7.
	// Position of BLOCK8_W7 field.
	OTP_DEBUG_BLK8_W7_BLOCK8_W7_Pos = 0x0
	// Bit mask of BLOCK8_W7 field.
	OTP_DEBUG_BLK8_W7_BLOCK8_W7_Msk = 0xffffffff

	// BLK8_W8: Otp debuger block8 data register8.
	// Position of BLOCK8_W8 field.
	OTP_DEBUG_BLK8_W8_BLOCK8_W8_Pos = 0x0
	// Bit mask of BLOCK8_W8 field.
	OTP_DEBUG_BLK8_W8_BLOCK8_W8_Msk = 0xffffffff

	// BLK8_W9: Otp debuger block8 data register9.
	// Position of BLOCK8_W9 field.
	OTP_DEBUG_BLK8_W9_BLOCK8_W9_Pos = 0x0
	// Bit mask of BLOCK8_W9 field.
	OTP_DEBUG_BLK8_W9_BLOCK8_W9_Msk = 0xffffffff

	// BLK8_W10: Otp debuger block8 data register10.
	// Position of BLOCK8_W10 field.
	OTP_DEBUG_BLK8_W10_BLOCK8_W10_Pos = 0x0
	// Bit mask of BLOCK8_W10 field.
	OTP_DEBUG_BLK8_W10_BLOCK8_W10_Msk = 0xffffffff

	// BLK8_W11: Otp debuger block8 data register11.
	// Position of BLOCK8_W11 field.
	OTP_DEBUG_BLK8_W11_BLOCK8_W11_Pos = 0x0
	// Bit mask of BLOCK8_W11 field.
	OTP_DEBUG_BLK8_W11_BLOCK8_W11_Msk = 0xffffffff

	// BLK9_W1: Otp debuger block9 data register1.
	// Position of BLOCK9_W1 field.
	OTP_DEBUG_BLK9_W1_BLOCK9_W1_Pos = 0x0
	// Bit mask of BLOCK9_W1 field.
	OTP_DEBUG_BLK9_W1_BLOCK9_W1_Msk = 0xffffffff

	// BLK9_W2: Otp debuger block9 data register2.
	// Position of BLOCK9_W2 field.
	OTP_DEBUG_BLK9_W2_BLOCK9_W2_Pos = 0x0
	// Bit mask of BLOCK9_W2 field.
	OTP_DEBUG_BLK9_W2_BLOCK9_W2_Msk = 0xffffffff

	// BLK9_W3: Otp debuger block9 data register3.
	// Position of BLOCK9_W3 field.
	OTP_DEBUG_BLK9_W3_BLOCK9_W3_Pos = 0x0
	// Bit mask of BLOCK9_W3 field.
	OTP_DEBUG_BLK9_W3_BLOCK9_W3_Msk = 0xffffffff

	// BLK9_W4: Otp debuger block9 data register4.
	// Position of BLOCK9_W4 field.
	OTP_DEBUG_BLK9_W4_BLOCK9_W4_Pos = 0x0
	// Bit mask of BLOCK9_W4 field.
	OTP_DEBUG_BLK9_W4_BLOCK9_W4_Msk = 0xffffffff

	// BLK9_W5: Otp debuger block9 data register5.
	// Position of BLOCK9_W5 field.
	OTP_DEBUG_BLK9_W5_BLOCK9_W5_Pos = 0x0
	// Bit mask of BLOCK9_W5 field.
	OTP_DEBUG_BLK9_W5_BLOCK9_W5_Msk = 0xffffffff

	// BLK9_W6: Otp debuger block9 data register6.
	// Position of BLOCK9_W6 field.
	OTP_DEBUG_BLK9_W6_BLOCK9_W6_Pos = 0x0
	// Bit mask of BLOCK9_W6 field.
	OTP_DEBUG_BLK9_W6_BLOCK9_W6_Msk = 0xffffffff

	// BLK9_W7: Otp debuger block9 data register7.
	// Position of BLOCK9_W7 field.
	OTP_DEBUG_BLK9_W7_BLOCK9_W7_Pos = 0x0
	// Bit mask of BLOCK9_W7 field.
	OTP_DEBUG_BLK9_W7_BLOCK9_W7_Msk = 0xffffffff

	// BLK9_W8: Otp debuger block9 data register8.
	// Position of BLOCK9_W8 field.
	OTP_DEBUG_BLK9_W8_BLOCK9_W8_Pos = 0x0
	// Bit mask of BLOCK9_W8 field.
	OTP_DEBUG_BLK9_W8_BLOCK9_W8_Msk = 0xffffffff

	// BLK9_W9: Otp debuger block9 data register9.
	// Position of BLOCK9_W9 field.
	OTP_DEBUG_BLK9_W9_BLOCK9_W9_Pos = 0x0
	// Bit mask of BLOCK9_W9 field.
	OTP_DEBUG_BLK9_W9_BLOCK9_W9_Msk = 0xffffffff

	// BLK9_W10: Otp debuger block9 data register10.
	// Position of BLOCK9_W10 field.
	OTP_DEBUG_BLK9_W10_BLOCK9_W10_Pos = 0x0
	// Bit mask of BLOCK9_W10 field.
	OTP_DEBUG_BLK9_W10_BLOCK9_W10_Msk = 0xffffffff

	// BLK9_W11: Otp debuger block9 data register11.
	// Position of BLOCK9_W11 field.
	OTP_DEBUG_BLK9_W11_BLOCK9_W11_Pos = 0x0
	// Bit mask of BLOCK9_W11 field.
	OTP_DEBUG_BLK9_W11_BLOCK9_W11_Msk = 0xffffffff

	// BLK10_W1: Otp debuger block10 data register1.
	// Position of BLOCK10_W1 field.
	OTP_DEBUG_BLK10_W1_BLOCK10_W1_Pos = 0x0
	// Bit mask of BLOCK10_W1 field.
	OTP_DEBUG_BLK10_W1_BLOCK10_W1_Msk = 0xffffffff

	// BLK10_W2: Otp debuger block10 data register2.
	// Position of BLOCK10_W2 field.
	OTP_DEBUG_BLK10_W2_BLOCK10_W2_Pos = 0x0
	// Bit mask of BLOCK10_W2 field.
	OTP_DEBUG_BLK10_W2_BLOCK10_W2_Msk = 0xffffffff

	// BLK10_W3: Otp debuger block10 data register3.
	// Position of BLOCK10_W3 field.
	OTP_DEBUG_BLK10_W3_BLOCK10_W3_Pos = 0x0
	// Bit mask of BLOCK10_W3 field.
	OTP_DEBUG_BLK10_W3_BLOCK10_W3_Msk = 0xffffffff

	// BLK10_W4: Otp debuger block10 data register4.
	// Position of BLOCK10_W4 field.
	OTP_DEBUG_BLK10_W4_BLOCK10_W4_Pos = 0x0
	// Bit mask of BLOCK10_W4 field.
	OTP_DEBUG_BLK10_W4_BLOCK10_W4_Msk = 0xffffffff

	// BLK10_W5: Otp debuger block10 data register5.
	// Position of BLOCK10_W5 field.
	OTP_DEBUG_BLK10_W5_BLOCK10_W5_Pos = 0x0
	// Bit mask of BLOCK10_W5 field.
	OTP_DEBUG_BLK10_W5_BLOCK10_W5_Msk = 0xffffffff

	// BLK10_W6: Otp debuger block10 data register6.
	// Position of BLOCK10_W6 field.
	OTP_DEBUG_BLK10_W6_BLOCK10_W6_Pos = 0x0
	// Bit mask of BLOCK10_W6 field.
	OTP_DEBUG_BLK10_W6_BLOCK10_W6_Msk = 0xffffffff

	// BLK10_W7: Otp debuger block10 data register7.
	// Position of BLOCK10_W7 field.
	OTP_DEBUG_BLK10_W7_BLOCK10_W7_Pos = 0x0
	// Bit mask of BLOCK10_W7 field.
	OTP_DEBUG_BLK10_W7_BLOCK10_W7_Msk = 0xffffffff

	// BLK10_W8: Otp debuger block10 data register8.
	// Position of BLOCK10_W8 field.
	OTP_DEBUG_BLK10_W8_BLOCK10_W8_Pos = 0x0
	// Bit mask of BLOCK10_W8 field.
	OTP_DEBUG_BLK10_W8_BLOCK10_W8_Msk = 0xffffffff

	// BLK10_W9: Otp debuger block10 data register9.
	// Position of BLOCK10_W9 field.
	OTP_DEBUG_BLK10_W9_BLOCK10_W9_Pos = 0x0
	// Bit mask of BLOCK10_W9 field.
	OTP_DEBUG_BLK10_W9_BLOCK10_W9_Msk = 0xffffffff

	// BLK10_W10: Otp debuger block10 data register10.
	// Position of BLOCK19_W10 field.
	OTP_DEBUG_BLK10_W10_BLOCK19_W10_Pos = 0x0
	// Bit mask of BLOCK19_W10 field.
	OTP_DEBUG_BLK10_W10_BLOCK19_W10_Msk = 0xffffffff

	// BLK10_W11: Otp debuger block10 data register11.
	// Position of BLOCK10_W11 field.
	OTP_DEBUG_BLK10_W11_BLOCK10_W11_Pos = 0x0
	// Bit mask of BLOCK10_W11 field.
	OTP_DEBUG_BLK10_W11_BLOCK10_W11_Msk = 0xffffffff

	// CLK: Otp debuger clk_en configuration register.
	// Position of EN field.
	OTP_DEBUG_CLK_EN_Pos = 0x0
	// Bit mask of EN field.
	OTP_DEBUG_CLK_EN_Msk = 0x1
	// Bit EN.
	OTP_DEBUG_CLK_EN = 0x1

	// APB2OTP_EN: Otp_debuger apb2otp enable configuration register.
	// Position of APB2OTP_EN field.
	OTP_DEBUG_APB2OTP_EN_APB2OTP_EN_Pos = 0x0
	// Bit mask of APB2OTP_EN field.
	OTP_DEBUG_APB2OTP_EN_APB2OTP_EN_Msk = 0x1
	// Bit APB2OTP_EN.
	OTP_DEBUG_APB2OTP_EN_APB2OTP_EN = 0x1

	// DATE: eFuse version register.
	// Position of DATE field.
	OTP_DEBUG_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	OTP_DEBUG_DATE_DATE_Msk = 0xfffffff
)

// Constants for PARL_IO: Parallel IO Controller
const (
	// RX_MODE_CFG: Parallel RX Sampling mode configuration register.
	// Position of RX_EXT_EN_SEL field.
	PARL_IO_RX_MODE_CFG_RX_EXT_EN_SEL_Pos = 0x15
	// Bit mask of RX_EXT_EN_SEL field.
	PARL_IO_RX_MODE_CFG_RX_EXT_EN_SEL_Msk = 0x1e00000
	// Position of RX_SW_EN field.
	PARL_IO_RX_MODE_CFG_RX_SW_EN_Pos = 0x19
	// Bit mask of RX_SW_EN field.
	PARL_IO_RX_MODE_CFG_RX_SW_EN_Msk = 0x2000000
	// Bit RX_SW_EN.
	PARL_IO_RX_MODE_CFG_RX_SW_EN = 0x2000000
	// Position of RX_EXT_EN_INV field.
	PARL_IO_RX_MODE_CFG_RX_EXT_EN_INV_Pos = 0x1a
	// Bit mask of RX_EXT_EN_INV field.
	PARL_IO_RX_MODE_CFG_RX_EXT_EN_INV_Msk = 0x4000000
	// Bit RX_EXT_EN_INV.
	PARL_IO_RX_MODE_CFG_RX_EXT_EN_INV = 0x4000000
	// Position of RX_PULSE_SUBMODE_SEL field.
	PARL_IO_RX_MODE_CFG_RX_PULSE_SUBMODE_SEL_Pos = 0x1b
	// Bit mask of RX_PULSE_SUBMODE_SEL field.
	PARL_IO_RX_MODE_CFG_RX_PULSE_SUBMODE_SEL_Msk = 0x38000000
	// Position of RX_SMP_MODE_SEL field.
	PARL_IO_RX_MODE_CFG_RX_SMP_MODE_SEL_Pos = 0x1e
	// Bit mask of RX_SMP_MODE_SEL field.
	PARL_IO_RX_MODE_CFG_RX_SMP_MODE_SEL_Msk = 0xc0000000

	// RX_DATA_CFG: Parallel RX data configuration register.
	// Position of RX_BITLEN field.
	PARL_IO_RX_DATA_CFG_RX_BITLEN_Pos = 0x9
	// Bit mask of RX_BITLEN field.
	PARL_IO_RX_DATA_CFG_RX_BITLEN_Msk = 0xffffe00
	// Position of RX_DATA_ORDER_INV field.
	PARL_IO_RX_DATA_CFG_RX_DATA_ORDER_INV_Pos = 0x1c
	// Bit mask of RX_DATA_ORDER_INV field.
	PARL_IO_RX_DATA_CFG_RX_DATA_ORDER_INV_Msk = 0x10000000
	// Bit RX_DATA_ORDER_INV.
	PARL_IO_RX_DATA_CFG_RX_DATA_ORDER_INV = 0x10000000
	// Position of RX_BUS_WID_SEL field.
	PARL_IO_RX_DATA_CFG_RX_BUS_WID_SEL_Pos = 0x1d
	// Bit mask of RX_BUS_WID_SEL field.
	PARL_IO_RX_DATA_CFG_RX_BUS_WID_SEL_Msk = 0xe0000000

	// RX_GENRL_CFG: Parallel RX general configuration register.
	// Position of RX_GATING_EN field.
	PARL_IO_RX_GENRL_CFG_RX_GATING_EN_Pos = 0xc
	// Bit mask of RX_GATING_EN field.
	PARL_IO_RX_GENRL_CFG_RX_GATING_EN_Msk = 0x1000
	// Bit RX_GATING_EN.
	PARL_IO_RX_GENRL_CFG_RX_GATING_EN = 0x1000
	// Position of RX_TIMEOUT_THRES field.
	PARL_IO_RX_GENRL_CFG_RX_TIMEOUT_THRES_Pos = 0xd
	// Bit mask of RX_TIMEOUT_THRES field.
	PARL_IO_RX_GENRL_CFG_RX_TIMEOUT_THRES_Msk = 0x1fffe000
	// Position of RX_TIMEOUT_EN field.
	PARL_IO_RX_GENRL_CFG_RX_TIMEOUT_EN_Pos = 0x1d
	// Bit mask of RX_TIMEOUT_EN field.
	PARL_IO_RX_GENRL_CFG_RX_TIMEOUT_EN_Msk = 0x20000000
	// Bit RX_TIMEOUT_EN.
	PARL_IO_RX_GENRL_CFG_RX_TIMEOUT_EN = 0x20000000
	// Position of RX_EOF_GEN_SEL field.
	PARL_IO_RX_GENRL_CFG_RX_EOF_GEN_SEL_Pos = 0x1e
	// Bit mask of RX_EOF_GEN_SEL field.
	PARL_IO_RX_GENRL_CFG_RX_EOF_GEN_SEL_Msk = 0x40000000
	// Bit RX_EOF_GEN_SEL.
	PARL_IO_RX_GENRL_CFG_RX_EOF_GEN_SEL = 0x40000000

	// RX_START_CFG: Parallel RX Start configuration register.
	// Position of RX_START field.
	PARL_IO_RX_START_CFG_RX_START_Pos = 0x1f
	// Bit mask of RX_START field.
	PARL_IO_RX_START_CFG_RX_START_Msk = 0x80000000
	// Bit RX_START.
	PARL_IO_RX_START_CFG_RX_START = 0x80000000

	// TX_DATA_CFG: Parallel TX data configuration register.
	// Position of TX_BITLEN field.
	PARL_IO_TX_DATA_CFG_TX_BITLEN_Pos = 0x9
	// Bit mask of TX_BITLEN field.
	PARL_IO_TX_DATA_CFG_TX_BITLEN_Msk = 0xffffe00
	// Position of TX_DATA_ORDER_INV field.
	PARL_IO_TX_DATA_CFG_TX_DATA_ORDER_INV_Pos = 0x1c
	// Bit mask of TX_DATA_ORDER_INV field.
	PARL_IO_TX_DATA_CFG_TX_DATA_ORDER_INV_Msk = 0x10000000
	// Bit TX_DATA_ORDER_INV.
	PARL_IO_TX_DATA_CFG_TX_DATA_ORDER_INV = 0x10000000
	// Position of TX_BUS_WID_SEL field.
	PARL_IO_TX_DATA_CFG_TX_BUS_WID_SEL_Pos = 0x1d
	// Bit mask of TX_BUS_WID_SEL field.
	PARL_IO_TX_DATA_CFG_TX_BUS_WID_SEL_Msk = 0xe0000000

	// TX_START_CFG: Parallel TX Start configuration register.
	// Position of TX_START field.
	PARL_IO_TX_START_CFG_TX_START_Pos = 0x1f
	// Bit mask of TX_START field.
	PARL_IO_TX_START_CFG_TX_START_Msk = 0x80000000
	// Bit TX_START.
	PARL_IO_TX_START_CFG_TX_START = 0x80000000

	// TX_GENRL_CFG: Parallel TX general configuration register.
	// Position of TX_IDLE_VALUE field.
	PARL_IO_TX_GENRL_CFG_TX_IDLE_VALUE_Pos = 0xe
	// Bit mask of TX_IDLE_VALUE field.
	PARL_IO_TX_GENRL_CFG_TX_IDLE_VALUE_Msk = 0x3fffc000
	// Position of TX_GATING_EN field.
	PARL_IO_TX_GENRL_CFG_TX_GATING_EN_Pos = 0x1e
	// Bit mask of TX_GATING_EN field.
	PARL_IO_TX_GENRL_CFG_TX_GATING_EN_Msk = 0x40000000
	// Bit TX_GATING_EN.
	PARL_IO_TX_GENRL_CFG_TX_GATING_EN = 0x40000000
	// Position of TX_VALID_OUTPUT_EN field.
	PARL_IO_TX_GENRL_CFG_TX_VALID_OUTPUT_EN_Pos = 0x1f
	// Bit mask of TX_VALID_OUTPUT_EN field.
	PARL_IO_TX_GENRL_CFG_TX_VALID_OUTPUT_EN_Msk = 0x80000000
	// Bit TX_VALID_OUTPUT_EN.
	PARL_IO_TX_GENRL_CFG_TX_VALID_OUTPUT_EN = 0x80000000

	// FIFO_CFG: Parallel IO FIFO configuration register.
	// Position of TX_FIFO_SRST field.
	PARL_IO_FIFO_CFG_TX_FIFO_SRST_Pos = 0x1e
	// Bit mask of TX_FIFO_SRST field.
	PARL_IO_FIFO_CFG_TX_FIFO_SRST_Msk = 0x40000000
	// Bit TX_FIFO_SRST.
	PARL_IO_FIFO_CFG_TX_FIFO_SRST = 0x40000000
	// Position of RX_FIFO_SRST field.
	PARL_IO_FIFO_CFG_RX_FIFO_SRST_Pos = 0x1f
	// Bit mask of RX_FIFO_SRST field.
	PARL_IO_FIFO_CFG_RX_FIFO_SRST_Msk = 0x80000000
	// Bit RX_FIFO_SRST.
	PARL_IO_FIFO_CFG_RX_FIFO_SRST = 0x80000000

	// REG_UPDATE: Parallel IO FIFO configuration register.
	// Position of RX_REG_UPDATE field.
	PARL_IO_REG_UPDATE_RX_REG_UPDATE_Pos = 0x1f
	// Bit mask of RX_REG_UPDATE field.
	PARL_IO_REG_UPDATE_RX_REG_UPDATE_Msk = 0x80000000
	// Bit RX_REG_UPDATE.
	PARL_IO_REG_UPDATE_RX_REG_UPDATE = 0x80000000

	// ST: Parallel IO module status register0.
	// Position of TX_READY field.
	PARL_IO_ST_TX_READY_Pos = 0x1f
	// Bit mask of TX_READY field.
	PARL_IO_ST_TX_READY_Msk = 0x80000000
	// Bit TX_READY.
	PARL_IO_ST_TX_READY = 0x80000000

	// INT_ENA: Parallel IO interrupt enable singal configuration register.
	// Position of TX_FIFO_REMPTY_INT_ENA field.
	PARL_IO_INT_ENA_TX_FIFO_REMPTY_INT_ENA_Pos = 0x0
	// Bit mask of TX_FIFO_REMPTY_INT_ENA field.
	PARL_IO_INT_ENA_TX_FIFO_REMPTY_INT_ENA_Msk = 0x1
	// Bit TX_FIFO_REMPTY_INT_ENA.
	PARL_IO_INT_ENA_TX_FIFO_REMPTY_INT_ENA = 0x1
	// Position of RX_FIFO_WOVF_INT_ENA field.
	PARL_IO_INT_ENA_RX_FIFO_WOVF_INT_ENA_Pos = 0x1
	// Bit mask of RX_FIFO_WOVF_INT_ENA field.
	PARL_IO_INT_ENA_RX_FIFO_WOVF_INT_ENA_Msk = 0x2
	// Bit RX_FIFO_WOVF_INT_ENA.
	PARL_IO_INT_ENA_RX_FIFO_WOVF_INT_ENA = 0x2
	// Position of TX_EOF_INT_ENA field.
	PARL_IO_INT_ENA_TX_EOF_INT_ENA_Pos = 0x2
	// Bit mask of TX_EOF_INT_ENA field.
	PARL_IO_INT_ENA_TX_EOF_INT_ENA_Msk = 0x4
	// Bit TX_EOF_INT_ENA.
	PARL_IO_INT_ENA_TX_EOF_INT_ENA = 0x4

	// INT_RAW: Parallel IO interrupt raw singal status register.
	// Position of TX_FIFO_REMPTY_INT_RAW field.
	PARL_IO_INT_RAW_TX_FIFO_REMPTY_INT_RAW_Pos = 0x0
	// Bit mask of TX_FIFO_REMPTY_INT_RAW field.
	PARL_IO_INT_RAW_TX_FIFO_REMPTY_INT_RAW_Msk = 0x1
	// Bit TX_FIFO_REMPTY_INT_RAW.
	PARL_IO_INT_RAW_TX_FIFO_REMPTY_INT_RAW = 0x1
	// Position of RX_FIFO_WOVF_INT_RAW field.
	PARL_IO_INT_RAW_RX_FIFO_WOVF_INT_RAW_Pos = 0x1
	// Bit mask of RX_FIFO_WOVF_INT_RAW field.
	PARL_IO_INT_RAW_RX_FIFO_WOVF_INT_RAW_Msk = 0x2
	// Bit RX_FIFO_WOVF_INT_RAW.
	PARL_IO_INT_RAW_RX_FIFO_WOVF_INT_RAW = 0x2
	// Position of TX_EOF_INT_RAW field.
	PARL_IO_INT_RAW_TX_EOF_INT_RAW_Pos = 0x2
	// Bit mask of TX_EOF_INT_RAW field.
	PARL_IO_INT_RAW_TX_EOF_INT_RAW_Msk = 0x4
	// Bit TX_EOF_INT_RAW.
	PARL_IO_INT_RAW_TX_EOF_INT_RAW = 0x4

	// INT_ST: Parallel IO interrupt singal status register.
	// Position of TX_FIFO_REMPTY_INT_ST field.
	PARL_IO_INT_ST_TX_FIFO_REMPTY_INT_ST_Pos = 0x0
	// Bit mask of TX_FIFO_REMPTY_INT_ST field.
	PARL_IO_INT_ST_TX_FIFO_REMPTY_INT_ST_Msk = 0x1
	// Bit TX_FIFO_REMPTY_INT_ST.
	PARL_IO_INT_ST_TX_FIFO_REMPTY_INT_ST = 0x1
	// Position of RX_FIFO_WOVF_INT_ST field.
	PARL_IO_INT_ST_RX_FIFO_WOVF_INT_ST_Pos = 0x1
	// Bit mask of RX_FIFO_WOVF_INT_ST field.
	PARL_IO_INT_ST_RX_FIFO_WOVF_INT_ST_Msk = 0x2
	// Bit RX_FIFO_WOVF_INT_ST.
	PARL_IO_INT_ST_RX_FIFO_WOVF_INT_ST = 0x2
	// Position of TX_EOF_INT_ST field.
	PARL_IO_INT_ST_TX_EOF_INT_ST_Pos = 0x2
	// Bit mask of TX_EOF_INT_ST field.
	PARL_IO_INT_ST_TX_EOF_INT_ST_Msk = 0x4
	// Bit TX_EOF_INT_ST.
	PARL_IO_INT_ST_TX_EOF_INT_ST = 0x4

	// INT_CLR: Parallel IO interrupt clear singal configuration register.
	// Position of TX_FIFO_REMPTY_INT_CLR field.
	PARL_IO_INT_CLR_TX_FIFO_REMPTY_INT_CLR_Pos = 0x0
	// Bit mask of TX_FIFO_REMPTY_INT_CLR field.
	PARL_IO_INT_CLR_TX_FIFO_REMPTY_INT_CLR_Msk = 0x1
	// Bit TX_FIFO_REMPTY_INT_CLR.
	PARL_IO_INT_CLR_TX_FIFO_REMPTY_INT_CLR = 0x1
	// Position of RX_FIFO_WOVF_INT_CLR field.
	PARL_IO_INT_CLR_RX_FIFO_WOVF_INT_CLR_Pos = 0x1
	// Bit mask of RX_FIFO_WOVF_INT_CLR field.
	PARL_IO_INT_CLR_RX_FIFO_WOVF_INT_CLR_Msk = 0x2
	// Bit RX_FIFO_WOVF_INT_CLR.
	PARL_IO_INT_CLR_RX_FIFO_WOVF_INT_CLR = 0x2
	// Position of TX_EOF_INT_CLR field.
	PARL_IO_INT_CLR_TX_EOF_INT_CLR_Pos = 0x2
	// Bit mask of TX_EOF_INT_CLR field.
	PARL_IO_INT_CLR_TX_EOF_INT_CLR_Msk = 0x4
	// Bit TX_EOF_INT_CLR.
	PARL_IO_INT_CLR_TX_EOF_INT_CLR = 0x4

	// RX_ST0: Parallel IO RX status register0
	// Position of RX_CNT field.
	PARL_IO_RX_ST0_RX_CNT_Pos = 0x9
	// Bit mask of RX_CNT field.
	PARL_IO_RX_ST0_RX_CNT_Msk = 0x1e00
	// Position of RX_FIFO_WR_BIT_CNT field.
	PARL_IO_RX_ST0_RX_FIFO_WR_BIT_CNT_Pos = 0xd
	// Bit mask of RX_FIFO_WR_BIT_CNT field.
	PARL_IO_RX_ST0_RX_FIFO_WR_BIT_CNT_Msk = 0xffffe000

	// RX_ST1: Parallel IO RX status register1
	// Position of RX_FIFO_RD_BIT_CNT field.
	PARL_IO_RX_ST1_RX_FIFO_RD_BIT_CNT_Pos = 0xd
	// Bit mask of RX_FIFO_RD_BIT_CNT field.
	PARL_IO_RX_ST1_RX_FIFO_RD_BIT_CNT_Msk = 0xffffe000

	// TX_ST0: Parallel IO TX status register0
	// Position of TX_CNT field.
	PARL_IO_TX_ST0_TX_CNT_Pos = 0x6
	// Bit mask of TX_CNT field.
	PARL_IO_TX_ST0_TX_CNT_Msk = 0x1fc0
	// Position of TX_FIFO_RD_BIT_CNT field.
	PARL_IO_TX_ST0_TX_FIFO_RD_BIT_CNT_Pos = 0xd
	// Bit mask of TX_FIFO_RD_BIT_CNT field.
	PARL_IO_TX_ST0_TX_FIFO_RD_BIT_CNT_Msk = 0xffffe000

	// RX_CLK_CFG: Parallel IO RX clk configuration register
	// Position of RX_CLK_I_INV field.
	PARL_IO_RX_CLK_CFG_RX_CLK_I_INV_Pos = 0x1e
	// Bit mask of RX_CLK_I_INV field.
	PARL_IO_RX_CLK_CFG_RX_CLK_I_INV_Msk = 0x40000000
	// Bit RX_CLK_I_INV.
	PARL_IO_RX_CLK_CFG_RX_CLK_I_INV = 0x40000000
	// Position of RX_CLK_O_INV field.
	PARL_IO_RX_CLK_CFG_RX_CLK_O_INV_Pos = 0x1f
	// Bit mask of RX_CLK_O_INV field.
	PARL_IO_RX_CLK_CFG_RX_CLK_O_INV_Msk = 0x80000000
	// Bit RX_CLK_O_INV.
	PARL_IO_RX_CLK_CFG_RX_CLK_O_INV = 0x80000000

	// TX_CLK_CFG: Parallel IO TX clk configuration register
	// Position of TX_CLK_I_INV field.
	PARL_IO_TX_CLK_CFG_TX_CLK_I_INV_Pos = 0x1e
	// Bit mask of TX_CLK_I_INV field.
	PARL_IO_TX_CLK_CFG_TX_CLK_I_INV_Msk = 0x40000000
	// Bit TX_CLK_I_INV.
	PARL_IO_TX_CLK_CFG_TX_CLK_I_INV = 0x40000000
	// Position of TX_CLK_O_INV field.
	PARL_IO_TX_CLK_CFG_TX_CLK_O_INV_Pos = 0x1f
	// Bit mask of TX_CLK_O_INV field.
	PARL_IO_TX_CLK_CFG_TX_CLK_O_INV_Msk = 0x80000000
	// Bit TX_CLK_O_INV.
	PARL_IO_TX_CLK_CFG_TX_CLK_O_INV = 0x80000000

	// CLK: Parallel IO clk configuration register
	// Position of EN field.
	PARL_IO_CLK_EN_Pos = 0x1f
	// Bit mask of EN field.
	PARL_IO_CLK_EN_Msk = 0x80000000
	// Bit EN.
	PARL_IO_CLK_EN = 0x80000000

	// VERSION: Version register.
	// Position of DATE field.
	PARL_IO_VERSION_DATE_Pos = 0x0
	// Bit mask of DATE field.
	PARL_IO_VERSION_DATE_Msk = 0xfffffff
)

// Constants for PAU: PAU Peripheral
const (
	// REGDMA_CONF: Peri backup control register
	// Position of FLOW_ERR field.
	PAU_REGDMA_CONF_FLOW_ERR_Pos = 0x0
	// Bit mask of FLOW_ERR field.
	PAU_REGDMA_CONF_FLOW_ERR_Msk = 0x7
	// Position of START field.
	PAU_REGDMA_CONF_START_Pos = 0x3
	// Bit mask of START field.
	PAU_REGDMA_CONF_START_Msk = 0x8
	// Bit START.
	PAU_REGDMA_CONF_START = 0x8
	// Position of TO_MEM field.
	PAU_REGDMA_CONF_TO_MEM_Pos = 0x4
	// Bit mask of TO_MEM field.
	PAU_REGDMA_CONF_TO_MEM_Msk = 0x10
	// Bit TO_MEM.
	PAU_REGDMA_CONF_TO_MEM = 0x10
	// Position of LINK_SEL field.
	PAU_REGDMA_CONF_LINK_SEL_Pos = 0x5
	// Bit mask of LINK_SEL field.
	PAU_REGDMA_CONF_LINK_SEL_Msk = 0x60
	// Position of START_MAC field.
	PAU_REGDMA_CONF_START_MAC_Pos = 0x7
	// Bit mask of START_MAC field.
	PAU_REGDMA_CONF_START_MAC_Msk = 0x80
	// Bit START_MAC.
	PAU_REGDMA_CONF_START_MAC = 0x80
	// Position of TO_MEM_MAC field.
	PAU_REGDMA_CONF_TO_MEM_MAC_Pos = 0x8
	// Bit mask of TO_MEM_MAC field.
	PAU_REGDMA_CONF_TO_MEM_MAC_Msk = 0x100
	// Bit TO_MEM_MAC.
	PAU_REGDMA_CONF_TO_MEM_MAC = 0x100
	// Position of SEL_MAC field.
	PAU_REGDMA_CONF_SEL_MAC_Pos = 0x9
	// Bit mask of SEL_MAC field.
	PAU_REGDMA_CONF_SEL_MAC_Msk = 0x200
	// Bit SEL_MAC.
	PAU_REGDMA_CONF_SEL_MAC = 0x200

	// REGDMA_CLK_CONF: Clock control register
	// Position of CLK_EN field.
	PAU_REGDMA_CLK_CONF_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	PAU_REGDMA_CLK_CONF_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	PAU_REGDMA_CLK_CONF_CLK_EN = 0x1

	// REGDMA_ETM_CTRL: ETM start ctrl reg
	// Position of ETM_START_0 field.
	PAU_REGDMA_ETM_CTRL_ETM_START_0_Pos = 0x0
	// Bit mask of ETM_START_0 field.
	PAU_REGDMA_ETM_CTRL_ETM_START_0_Msk = 0x1
	// Bit ETM_START_0.
	PAU_REGDMA_ETM_CTRL_ETM_START_0 = 0x1
	// Position of ETM_START_1 field.
	PAU_REGDMA_ETM_CTRL_ETM_START_1_Pos = 0x1
	// Bit mask of ETM_START_1 field.
	PAU_REGDMA_ETM_CTRL_ETM_START_1_Msk = 0x2
	// Bit ETM_START_1.
	PAU_REGDMA_ETM_CTRL_ETM_START_1 = 0x2
	// Position of ETM_START_2 field.
	PAU_REGDMA_ETM_CTRL_ETM_START_2_Pos = 0x2
	// Bit mask of ETM_START_2 field.
	PAU_REGDMA_ETM_CTRL_ETM_START_2_Msk = 0x4
	// Bit ETM_START_2.
	PAU_REGDMA_ETM_CTRL_ETM_START_2 = 0x4
	// Position of ETM_START_3 field.
	PAU_REGDMA_ETM_CTRL_ETM_START_3_Pos = 0x3
	// Bit mask of ETM_START_3 field.
	PAU_REGDMA_ETM_CTRL_ETM_START_3_Msk = 0x8
	// Bit ETM_START_3.
	PAU_REGDMA_ETM_CTRL_ETM_START_3 = 0x8

	// REGDMA_LINK_0_ADDR: link_0_addr
	// Position of LINK_ADDR_0 field.
	PAU_REGDMA_LINK_0_ADDR_LINK_ADDR_0_Pos = 0x0
	// Bit mask of LINK_ADDR_0 field.
	PAU_REGDMA_LINK_0_ADDR_LINK_ADDR_0_Msk = 0xffffffff

	// REGDMA_LINK_1_ADDR: Link_1_addr
	// Position of LINK_ADDR_1 field.
	PAU_REGDMA_LINK_1_ADDR_LINK_ADDR_1_Pos = 0x0
	// Bit mask of LINK_ADDR_1 field.
	PAU_REGDMA_LINK_1_ADDR_LINK_ADDR_1_Msk = 0xffffffff

	// REGDMA_LINK_2_ADDR: Link_2_addr
	// Position of LINK_ADDR_2 field.
	PAU_REGDMA_LINK_2_ADDR_LINK_ADDR_2_Pos = 0x0
	// Bit mask of LINK_ADDR_2 field.
	PAU_REGDMA_LINK_2_ADDR_LINK_ADDR_2_Msk = 0xffffffff

	// REGDMA_LINK_3_ADDR: Link_3_addr
	// Position of LINK_ADDR_3 field.
	PAU_REGDMA_LINK_3_ADDR_LINK_ADDR_3_Pos = 0x0
	// Bit mask of LINK_ADDR_3 field.
	PAU_REGDMA_LINK_3_ADDR_LINK_ADDR_3_Msk = 0xffffffff

	// REGDMA_LINK_MAC_ADDR: Link_mac_addr
	// Position of LINK_ADDR_MAC field.
	PAU_REGDMA_LINK_MAC_ADDR_LINK_ADDR_MAC_Pos = 0x0
	// Bit mask of LINK_ADDR_MAC field.
	PAU_REGDMA_LINK_MAC_ADDR_LINK_ADDR_MAC_Msk = 0xffffffff

	// REGDMA_CURRENT_LINK_ADDR: current link addr
	// Position of CURRENT_LINK_ADDR field.
	PAU_REGDMA_CURRENT_LINK_ADDR_CURRENT_LINK_ADDR_Pos = 0x0
	// Bit mask of CURRENT_LINK_ADDR field.
	PAU_REGDMA_CURRENT_LINK_ADDR_CURRENT_LINK_ADDR_Msk = 0xffffffff

	// REGDMA_BACKUP_ADDR: Backup addr
	// Position of BACKUP_ADDR field.
	PAU_REGDMA_BACKUP_ADDR_BACKUP_ADDR_Pos = 0x0
	// Bit mask of BACKUP_ADDR field.
	PAU_REGDMA_BACKUP_ADDR_BACKUP_ADDR_Msk = 0xffffffff

	// REGDMA_MEM_ADDR: mem addr
	// Position of MEM_ADDR field.
	PAU_REGDMA_MEM_ADDR_MEM_ADDR_Pos = 0x0
	// Bit mask of MEM_ADDR field.
	PAU_REGDMA_MEM_ADDR_MEM_ADDR_Msk = 0xffffffff

	// REGDMA_BKP_CONF: backup config
	// Position of READ_INTERVAL field.
	PAU_REGDMA_BKP_CONF_READ_INTERVAL_Pos = 0x0
	// Bit mask of READ_INTERVAL field.
	PAU_REGDMA_BKP_CONF_READ_INTERVAL_Msk = 0x7f
	// Position of LINK_TOUT_THRES field.
	PAU_REGDMA_BKP_CONF_LINK_TOUT_THRES_Pos = 0x7
	// Bit mask of LINK_TOUT_THRES field.
	PAU_REGDMA_BKP_CONF_LINK_TOUT_THRES_Msk = 0x1ff80
	// Position of BURST_LIMIT field.
	PAU_REGDMA_BKP_CONF_BURST_LIMIT_Pos = 0x11
	// Bit mask of BURST_LIMIT field.
	PAU_REGDMA_BKP_CONF_BURST_LIMIT_Msk = 0x3e0000
	// Position of BACKUP_TOUT_THRES field.
	PAU_REGDMA_BKP_CONF_BACKUP_TOUT_THRES_Pos = 0x16
	// Bit mask of BACKUP_TOUT_THRES field.
	PAU_REGDMA_BKP_CONF_BACKUP_TOUT_THRES_Msk = 0xffc00000

	// RETENTION_LINK_BASE: retention dma link base
	// Position of LINK_BASE_ADDR field.
	PAU_RETENTION_LINK_BASE_LINK_BASE_ADDR_Pos = 0x0
	// Bit mask of LINK_BASE_ADDR field.
	PAU_RETENTION_LINK_BASE_LINK_BASE_ADDR_Msk = 0x7ffffff

	// RETENTION_CFG: retention_cfg
	// Position of RET_INV_CFG field.
	PAU_RETENTION_CFG_RET_INV_CFG_Pos = 0x0
	// Bit mask of RET_INV_CFG field.
	PAU_RETENTION_CFG_RET_INV_CFG_Msk = 0xffffffff

	// INT_ENA: Read only register for error and done
	// Position of DONE_INT_ENA field.
	PAU_INT_ENA_DONE_INT_ENA_Pos = 0x0
	// Bit mask of DONE_INT_ENA field.
	PAU_INT_ENA_DONE_INT_ENA_Msk = 0x1
	// Bit DONE_INT_ENA.
	PAU_INT_ENA_DONE_INT_ENA = 0x1
	// Position of ERROR_INT_ENA field.
	PAU_INT_ENA_ERROR_INT_ENA_Pos = 0x1
	// Bit mask of ERROR_INT_ENA field.
	PAU_INT_ENA_ERROR_INT_ENA_Msk = 0x2
	// Bit ERROR_INT_ENA.
	PAU_INT_ENA_ERROR_INT_ENA = 0x2

	// INT_RAW: Read only register for error and done
	// Position of DONE_INT_RAW field.
	PAU_INT_RAW_DONE_INT_RAW_Pos = 0x0
	// Bit mask of DONE_INT_RAW field.
	PAU_INT_RAW_DONE_INT_RAW_Msk = 0x1
	// Bit DONE_INT_RAW.
	PAU_INT_RAW_DONE_INT_RAW = 0x1
	// Position of ERROR_INT_RAW field.
	PAU_INT_RAW_ERROR_INT_RAW_Pos = 0x1
	// Bit mask of ERROR_INT_RAW field.
	PAU_INT_RAW_ERROR_INT_RAW_Msk = 0x2
	// Bit ERROR_INT_RAW.
	PAU_INT_RAW_ERROR_INT_RAW = 0x2

	// INT_CLR: Read only register for error and done
	// Position of DONE_INT_CLR field.
	PAU_INT_CLR_DONE_INT_CLR_Pos = 0x0
	// Bit mask of DONE_INT_CLR field.
	PAU_INT_CLR_DONE_INT_CLR_Msk = 0x1
	// Bit DONE_INT_CLR.
	PAU_INT_CLR_DONE_INT_CLR = 0x1
	// Position of ERROR_INT_CLR field.
	PAU_INT_CLR_ERROR_INT_CLR_Pos = 0x1
	// Bit mask of ERROR_INT_CLR field.
	PAU_INT_CLR_ERROR_INT_CLR_Msk = 0x2
	// Bit ERROR_INT_CLR.
	PAU_INT_CLR_ERROR_INT_CLR = 0x2

	// INT_ST: Read only register for error and done
	// Position of DONE_INT_ST field.
	PAU_INT_ST_DONE_INT_ST_Pos = 0x0
	// Bit mask of DONE_INT_ST field.
	PAU_INT_ST_DONE_INT_ST_Msk = 0x1
	// Bit DONE_INT_ST.
	PAU_INT_ST_DONE_INT_ST = 0x1
	// Position of ERROR_INT_ST field.
	PAU_INT_ST_ERROR_INT_ST_Pos = 0x1
	// Bit mask of ERROR_INT_ST field.
	PAU_INT_ST_ERROR_INT_ST_Msk = 0x2
	// Bit ERROR_INT_ST.
	PAU_INT_ST_ERROR_INT_ST = 0x2

	// DATE: Date register.
	// Position of DATE field.
	PAU_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	PAU_DATE_DATE_Msk = 0xfffffff
)

// Constants for PCNT: Pulse Count Controller
const (
	// U0_CONF0: Configuration register 0 for unit %s
	// Position of FILTER_THRES field.
	PCNT_U_CONF0_FILTER_THRES_Pos = 0x0
	// Bit mask of FILTER_THRES field.
	PCNT_U_CONF0_FILTER_THRES_Msk = 0x3ff
	// Position of FILTER_EN field.
	PCNT_U_CONF0_FILTER_EN_Pos = 0xa
	// Bit mask of FILTER_EN field.
	PCNT_U_CONF0_FILTER_EN_Msk = 0x400
	// Bit FILTER_EN.
	PCNT_U_CONF0_FILTER_EN = 0x400
	// Position of THR_ZERO_EN field.
	PCNT_U_CONF0_THR_ZERO_EN_Pos = 0xb
	// Bit mask of THR_ZERO_EN field.
	PCNT_U_CONF0_THR_ZERO_EN_Msk = 0x800
	// Bit THR_ZERO_EN.
	PCNT_U_CONF0_THR_ZERO_EN = 0x800
	// Position of THR_H_LIM_EN field.
	PCNT_U_CONF0_THR_H_LIM_EN_Pos = 0xc
	// Bit mask of THR_H_LIM_EN field.
	PCNT_U_CONF0_THR_H_LIM_EN_Msk = 0x1000
	// Bit THR_H_LIM_EN.
	PCNT_U_CONF0_THR_H_LIM_EN = 0x1000
	// Position of THR_L_LIM_EN field.
	PCNT_U_CONF0_THR_L_LIM_EN_Pos = 0xd
	// Bit mask of THR_L_LIM_EN field.
	PCNT_U_CONF0_THR_L_LIM_EN_Msk = 0x2000
	// Bit THR_L_LIM_EN.
	PCNT_U_CONF0_THR_L_LIM_EN = 0x2000
	// Position of THR_THRES0_EN field.
	PCNT_U_CONF0_THR_THRES0_EN_Pos = 0xe
	// Bit mask of THR_THRES0_EN field.
	PCNT_U_CONF0_THR_THRES0_EN_Msk = 0x4000
	// Bit THR_THRES0_EN.
	PCNT_U_CONF0_THR_THRES0_EN = 0x4000
	// Position of THR_THRES1_EN field.
	PCNT_U_CONF0_THR_THRES1_EN_Pos = 0xf
	// Bit mask of THR_THRES1_EN field.
	PCNT_U_CONF0_THR_THRES1_EN_Msk = 0x8000
	// Bit THR_THRES1_EN.
	PCNT_U_CONF0_THR_THRES1_EN = 0x8000
	// Position of CH0_NEG_MODE field.
	PCNT_U_CONF0_CH0_NEG_MODE_Pos = 0x10
	// Bit mask of CH0_NEG_MODE field.
	PCNT_U_CONF0_CH0_NEG_MODE_Msk = 0x30000
	// Position of CH0_POS_MODE field.
	PCNT_U_CONF0_CH0_POS_MODE_Pos = 0x12
	// Bit mask of CH0_POS_MODE field.
	PCNT_U_CONF0_CH0_POS_MODE_Msk = 0xc0000
	// Position of CH0_HCTRL_MODE field.
	PCNT_U_CONF0_CH0_HCTRL_MODE_Pos = 0x14
	// Bit mask of CH0_HCTRL_MODE field.
	PCNT_U_CONF0_CH0_HCTRL_MODE_Msk = 0x300000
	// Position of CH0_LCTRL_MODE field.
	PCNT_U_CONF0_CH0_LCTRL_MODE_Pos = 0x16
	// Bit mask of CH0_LCTRL_MODE field.
	PCNT_U_CONF0_CH0_LCTRL_MODE_Msk = 0xc00000
	// Position of CH1_NEG_MODE field.
	PCNT_U_CONF0_CH1_NEG_MODE_Pos = 0x18
	// Bit mask of CH1_NEG_MODE field.
	PCNT_U_CONF0_CH1_NEG_MODE_Msk = 0x3000000
	// Position of CH1_POS_MODE field.
	PCNT_U_CONF0_CH1_POS_MODE_Pos = 0x1a
	// Bit mask of CH1_POS_MODE field.
	PCNT_U_CONF0_CH1_POS_MODE_Msk = 0xc000000
	// Position of CH1_HCTRL_MODE field.
	PCNT_U_CONF0_CH1_HCTRL_MODE_Pos = 0x1c
	// Bit mask of CH1_HCTRL_MODE field.
	PCNT_U_CONF0_CH1_HCTRL_MODE_Msk = 0x30000000
	// Position of CH1_LCTRL_MODE field.
	PCNT_U_CONF0_CH1_LCTRL_MODE_Pos = 0x1e
	// Bit mask of CH1_LCTRL_MODE field.
	PCNT_U_CONF0_CH1_LCTRL_MODE_Msk = 0xc0000000

	// U0_CONF1: Configuration register 1 for unit %s
	// Position of CNT_THRES0 field.
	PCNT_U_CONF1_CNT_THRES0_Pos = 0x0
	// Bit mask of CNT_THRES0 field.
	PCNT_U_CONF1_CNT_THRES0_Msk = 0xffff
	// Position of CNT_THRES1 field.
	PCNT_U_CONF1_CNT_THRES1_Pos = 0x10
	// Bit mask of CNT_THRES1 field.
	PCNT_U_CONF1_CNT_THRES1_Msk = 0xffff0000

	// U0_CONF2: Configuration register 2 for unit %s
	// Position of CNT_H_LIM field.
	PCNT_U_CONF2_CNT_H_LIM_Pos = 0x0
	// Bit mask of CNT_H_LIM field.
	PCNT_U_CONF2_CNT_H_LIM_Msk = 0xffff
	// Position of CNT_L_LIM field.
	PCNT_U_CONF2_CNT_L_LIM_Pos = 0x10
	// Bit mask of CNT_L_LIM field.
	PCNT_U_CONF2_CNT_L_LIM_Msk = 0xffff0000

	// U0_CNT: Counter value for unit %s
	// Position of CNT field.
	PCNT_U_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PCNT_U_CNT_CNT_Msk = 0xffff

	// INT_RAW: Interrupt raw status register
	// Position of CNT_THR_EVENT_U0 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U0_Pos = 0x0
	// Bit mask of CNT_THR_EVENT_U0 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U0_Msk = 0x1
	// Bit CNT_THR_EVENT_U0.
	PCNT_INT_RAW_CNT_THR_EVENT_U0 = 0x1
	// Position of CNT_THR_EVENT_U1 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U1_Pos = 0x1
	// Bit mask of CNT_THR_EVENT_U1 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U1_Msk = 0x2
	// Bit CNT_THR_EVENT_U1.
	PCNT_INT_RAW_CNT_THR_EVENT_U1 = 0x2
	// Position of CNT_THR_EVENT_U2 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U2_Pos = 0x2
	// Bit mask of CNT_THR_EVENT_U2 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U2_Msk = 0x4
	// Bit CNT_THR_EVENT_U2.
	PCNT_INT_RAW_CNT_THR_EVENT_U2 = 0x4
	// Position of CNT_THR_EVENT_U3 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U3_Pos = 0x3
	// Bit mask of CNT_THR_EVENT_U3 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U3_Msk = 0x8
	// Bit CNT_THR_EVENT_U3.
	PCNT_INT_RAW_CNT_THR_EVENT_U3 = 0x8

	// INT_ST: Interrupt status register
	// Position of CNT_THR_EVENT_U0 field.
	PCNT_INT_ST_CNT_THR_EVENT_U0_Pos = 0x0
	// Bit mask of CNT_THR_EVENT_U0 field.
	PCNT_INT_ST_CNT_THR_EVENT_U0_Msk = 0x1
	// Bit CNT_THR_EVENT_U0.
	PCNT_INT_ST_CNT_THR_EVENT_U0 = 0x1
	// Position of CNT_THR_EVENT_U1 field.
	PCNT_INT_ST_CNT_THR_EVENT_U1_Pos = 0x1
	// Bit mask of CNT_THR_EVENT_U1 field.
	PCNT_INT_ST_CNT_THR_EVENT_U1_Msk = 0x2
	// Bit CNT_THR_EVENT_U1.
	PCNT_INT_ST_CNT_THR_EVENT_U1 = 0x2
	// Position of CNT_THR_EVENT_U2 field.
	PCNT_INT_ST_CNT_THR_EVENT_U2_Pos = 0x2
	// Bit mask of CNT_THR_EVENT_U2 field.
	PCNT_INT_ST_CNT_THR_EVENT_U2_Msk = 0x4
	// Bit CNT_THR_EVENT_U2.
	PCNT_INT_ST_CNT_THR_EVENT_U2 = 0x4
	// Position of CNT_THR_EVENT_U3 field.
	PCNT_INT_ST_CNT_THR_EVENT_U3_Pos = 0x3
	// Bit mask of CNT_THR_EVENT_U3 field.
	PCNT_INT_ST_CNT_THR_EVENT_U3_Msk = 0x8
	// Bit CNT_THR_EVENT_U3.
	PCNT_INT_ST_CNT_THR_EVENT_U3 = 0x8

	// INT_ENA: Interrupt enable register
	// Position of CNT_THR_EVENT_U0 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U0_Pos = 0x0
	// Bit mask of CNT_THR_EVENT_U0 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U0_Msk = 0x1
	// Bit CNT_THR_EVENT_U0.
	PCNT_INT_ENA_CNT_THR_EVENT_U0 = 0x1
	// Position of CNT_THR_EVENT_U1 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U1_Pos = 0x1
	// Bit mask of CNT_THR_EVENT_U1 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U1_Msk = 0x2
	// Bit CNT_THR_EVENT_U1.
	PCNT_INT_ENA_CNT_THR_EVENT_U1 = 0x2
	// Position of CNT_THR_EVENT_U2 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U2_Pos = 0x2
	// Bit mask of CNT_THR_EVENT_U2 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U2_Msk = 0x4
	// Bit CNT_THR_EVENT_U2.
	PCNT_INT_ENA_CNT_THR_EVENT_U2 = 0x4
	// Position of CNT_THR_EVENT_U3 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U3_Pos = 0x3
	// Bit mask of CNT_THR_EVENT_U3 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U3_Msk = 0x8
	// Bit CNT_THR_EVENT_U3.
	PCNT_INT_ENA_CNT_THR_EVENT_U3 = 0x8

	// INT_CLR: Interrupt clear register
	// Position of CNT_THR_EVENT_U0 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U0_Pos = 0x0
	// Bit mask of CNT_THR_EVENT_U0 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U0_Msk = 0x1
	// Bit CNT_THR_EVENT_U0.
	PCNT_INT_CLR_CNT_THR_EVENT_U0 = 0x1
	// Position of CNT_THR_EVENT_U1 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U1_Pos = 0x1
	// Bit mask of CNT_THR_EVENT_U1 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U1_Msk = 0x2
	// Bit CNT_THR_EVENT_U1.
	PCNT_INT_CLR_CNT_THR_EVENT_U1 = 0x2
	// Position of CNT_THR_EVENT_U2 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U2_Pos = 0x2
	// Bit mask of CNT_THR_EVENT_U2 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U2_Msk = 0x4
	// Bit CNT_THR_EVENT_U2.
	PCNT_INT_CLR_CNT_THR_EVENT_U2 = 0x4
	// Position of CNT_THR_EVENT_U3 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U3_Pos = 0x3
	// Bit mask of CNT_THR_EVENT_U3 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U3_Msk = 0x8
	// Bit CNT_THR_EVENT_U3.
	PCNT_INT_CLR_CNT_THR_EVENT_U3 = 0x8

	// U0_STATUS: PNCT UNIT%s status register
	// Position of ZERO_MODE field.
	PCNT_U_STATUS_ZERO_MODE_Pos = 0x0
	// Bit mask of ZERO_MODE field.
	PCNT_U_STATUS_ZERO_MODE_Msk = 0x3
	// Position of THRES1 field.
	PCNT_U_STATUS_THRES1_Pos = 0x2
	// Bit mask of THRES1 field.
	PCNT_U_STATUS_THRES1_Msk = 0x4
	// Bit THRES1.
	PCNT_U_STATUS_THRES1 = 0x4
	// Position of THRES0 field.
	PCNT_U_STATUS_THRES0_Pos = 0x3
	// Bit mask of THRES0 field.
	PCNT_U_STATUS_THRES0_Msk = 0x8
	// Bit THRES0.
	PCNT_U_STATUS_THRES0 = 0x8
	// Position of L_LIM field.
	PCNT_U_STATUS_L_LIM_Pos = 0x4
	// Bit mask of L_LIM field.
	PCNT_U_STATUS_L_LIM_Msk = 0x10
	// Bit L_LIM.
	PCNT_U_STATUS_L_LIM = 0x10
	// Position of H_LIM field.
	PCNT_U_STATUS_H_LIM_Pos = 0x5
	// Bit mask of H_LIM field.
	PCNT_U_STATUS_H_LIM_Msk = 0x20
	// Bit H_LIM.
	PCNT_U_STATUS_H_LIM = 0x20
	// Position of ZERO field.
	PCNT_U_STATUS_ZERO_Pos = 0x6
	// Bit mask of ZERO field.
	PCNT_U_STATUS_ZERO_Msk = 0x40
	// Bit ZERO.
	PCNT_U_STATUS_ZERO = 0x40

	// CTRL: Control register for all counters
	// Position of CNT_RST_U0 field.
	PCNT_CTRL_CNT_RST_U0_Pos = 0x0
	// Bit mask of CNT_RST_U0 field.
	PCNT_CTRL_CNT_RST_U0_Msk = 0x1
	// Bit CNT_RST_U0.
	PCNT_CTRL_CNT_RST_U0 = 0x1
	// Position of CNT_PAUSE_U0 field.
	PCNT_CTRL_CNT_PAUSE_U0_Pos = 0x1
	// Bit mask of CNT_PAUSE_U0 field.
	PCNT_CTRL_CNT_PAUSE_U0_Msk = 0x2
	// Bit CNT_PAUSE_U0.
	PCNT_CTRL_CNT_PAUSE_U0 = 0x2
	// Position of CNT_RST_U1 field.
	PCNT_CTRL_CNT_RST_U1_Pos = 0x2
	// Bit mask of CNT_RST_U1 field.
	PCNT_CTRL_CNT_RST_U1_Msk = 0x4
	// Bit CNT_RST_U1.
	PCNT_CTRL_CNT_RST_U1 = 0x4
	// Position of CNT_PAUSE_U1 field.
	PCNT_CTRL_CNT_PAUSE_U1_Pos = 0x3
	// Bit mask of CNT_PAUSE_U1 field.
	PCNT_CTRL_CNT_PAUSE_U1_Msk = 0x8
	// Bit CNT_PAUSE_U1.
	PCNT_CTRL_CNT_PAUSE_U1 = 0x8
	// Position of CNT_RST_U2 field.
	PCNT_CTRL_CNT_RST_U2_Pos = 0x4
	// Bit mask of CNT_RST_U2 field.
	PCNT_CTRL_CNT_RST_U2_Msk = 0x10
	// Bit CNT_RST_U2.
	PCNT_CTRL_CNT_RST_U2 = 0x10
	// Position of CNT_PAUSE_U2 field.
	PCNT_CTRL_CNT_PAUSE_U2_Pos = 0x5
	// Bit mask of CNT_PAUSE_U2 field.
	PCNT_CTRL_CNT_PAUSE_U2_Msk = 0x20
	// Bit CNT_PAUSE_U2.
	PCNT_CTRL_CNT_PAUSE_U2 = 0x20
	// Position of CNT_RST_U3 field.
	PCNT_CTRL_CNT_RST_U3_Pos = 0x6
	// Bit mask of CNT_RST_U3 field.
	PCNT_CTRL_CNT_RST_U3_Msk = 0x40
	// Bit CNT_RST_U3.
	PCNT_CTRL_CNT_RST_U3 = 0x40
	// Position of CNT_PAUSE_U3 field.
	PCNT_CTRL_CNT_PAUSE_U3_Pos = 0x7
	// Bit mask of CNT_PAUSE_U3 field.
	PCNT_CTRL_CNT_PAUSE_U3_Msk = 0x80
	// Bit CNT_PAUSE_U3.
	PCNT_CTRL_CNT_PAUSE_U3 = 0x80
	// Position of CLK_EN field.
	PCNT_CTRL_CLK_EN_Pos = 0x10
	// Bit mask of CLK_EN field.
	PCNT_CTRL_CLK_EN_Msk = 0x10000
	// Bit CLK_EN.
	PCNT_CTRL_CLK_EN = 0x10000

	// DATE: PCNT version control register
	// Position of DATE field.
	PCNT_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	PCNT_DATE_DATE_Msk = 0xffffffff
)

// Constants for PCR: PCR Peripheral
const (
	// UART0_CONF: UART0 configuration register
	// Position of UART0_CLK_EN field.
	PCR_UART0_CONF_UART0_CLK_EN_Pos = 0x0
	// Bit mask of UART0_CLK_EN field.
	PCR_UART0_CONF_UART0_CLK_EN_Msk = 0x1
	// Bit UART0_CLK_EN.
	PCR_UART0_CONF_UART0_CLK_EN = 0x1
	// Position of UART0_RST_EN field.
	PCR_UART0_CONF_UART0_RST_EN_Pos = 0x1
	// Bit mask of UART0_RST_EN field.
	PCR_UART0_CONF_UART0_RST_EN_Msk = 0x2
	// Bit UART0_RST_EN.
	PCR_UART0_CONF_UART0_RST_EN = 0x2
	// Position of UART0_READY field.
	PCR_UART0_CONF_UART0_READY_Pos = 0x2
	// Bit mask of UART0_READY field.
	PCR_UART0_CONF_UART0_READY_Msk = 0x4
	// Bit UART0_READY.
	PCR_UART0_CONF_UART0_READY = 0x4

	// UART0_SCLK_CONF: UART0_SCLK configuration register
	// Position of UART0_SCLK_DIV_A field.
	PCR_UART0_SCLK_CONF_UART0_SCLK_DIV_A_Pos = 0x0
	// Bit mask of UART0_SCLK_DIV_A field.
	PCR_UART0_SCLK_CONF_UART0_SCLK_DIV_A_Msk = 0x3f
	// Position of UART0_SCLK_DIV_B field.
	PCR_UART0_SCLK_CONF_UART0_SCLK_DIV_B_Pos = 0x6
	// Bit mask of UART0_SCLK_DIV_B field.
	PCR_UART0_SCLK_CONF_UART0_SCLK_DIV_B_Msk = 0xfc0
	// Position of UART0_SCLK_DIV_NUM field.
	PCR_UART0_SCLK_CONF_UART0_SCLK_DIV_NUM_Pos = 0xc
	// Bit mask of UART0_SCLK_DIV_NUM field.
	PCR_UART0_SCLK_CONF_UART0_SCLK_DIV_NUM_Msk = 0xff000
	// Position of UART0_SCLK_SEL field.
	PCR_UART0_SCLK_CONF_UART0_SCLK_SEL_Pos = 0x14
	// Bit mask of UART0_SCLK_SEL field.
	PCR_UART0_SCLK_CONF_UART0_SCLK_SEL_Msk = 0x300000
	// Position of UART0_SCLK_EN field.
	PCR_UART0_SCLK_CONF_UART0_SCLK_EN_Pos = 0x16
	// Bit mask of UART0_SCLK_EN field.
	PCR_UART0_SCLK_CONF_UART0_SCLK_EN_Msk = 0x400000
	// Bit UART0_SCLK_EN.
	PCR_UART0_SCLK_CONF_UART0_SCLK_EN = 0x400000

	// UART0_PD_CTRL: UART0 power control register
	// Position of UART0_MEM_FORCE_PU field.
	PCR_UART0_PD_CTRL_UART0_MEM_FORCE_PU_Pos = 0x1
	// Bit mask of UART0_MEM_FORCE_PU field.
	PCR_UART0_PD_CTRL_UART0_MEM_FORCE_PU_Msk = 0x2
	// Bit UART0_MEM_FORCE_PU.
	PCR_UART0_PD_CTRL_UART0_MEM_FORCE_PU = 0x2
	// Position of UART0_MEM_FORCE_PD field.
	PCR_UART0_PD_CTRL_UART0_MEM_FORCE_PD_Pos = 0x2
	// Bit mask of UART0_MEM_FORCE_PD field.
	PCR_UART0_PD_CTRL_UART0_MEM_FORCE_PD_Msk = 0x4
	// Bit UART0_MEM_FORCE_PD.
	PCR_UART0_PD_CTRL_UART0_MEM_FORCE_PD = 0x4

	// UART1_CONF: UART1 configuration register
	// Position of UART1_CLK_EN field.
	PCR_UART1_CONF_UART1_CLK_EN_Pos = 0x0
	// Bit mask of UART1_CLK_EN field.
	PCR_UART1_CONF_UART1_CLK_EN_Msk = 0x1
	// Bit UART1_CLK_EN.
	PCR_UART1_CONF_UART1_CLK_EN = 0x1
	// Position of UART1_RST_EN field.
	PCR_UART1_CONF_UART1_RST_EN_Pos = 0x1
	// Bit mask of UART1_RST_EN field.
	PCR_UART1_CONF_UART1_RST_EN_Msk = 0x2
	// Bit UART1_RST_EN.
	PCR_UART1_CONF_UART1_RST_EN = 0x2
	// Position of UART1_READY field.
	PCR_UART1_CONF_UART1_READY_Pos = 0x2
	// Bit mask of UART1_READY field.
	PCR_UART1_CONF_UART1_READY_Msk = 0x4
	// Bit UART1_READY.
	PCR_UART1_CONF_UART1_READY = 0x4

	// UART1_SCLK_CONF: UART1_SCLK configuration register
	// Position of UART1_SCLK_DIV_A field.
	PCR_UART1_SCLK_CONF_UART1_SCLK_DIV_A_Pos = 0x0
	// Bit mask of UART1_SCLK_DIV_A field.
	PCR_UART1_SCLK_CONF_UART1_SCLK_DIV_A_Msk = 0x3f
	// Position of UART1_SCLK_DIV_B field.
	PCR_UART1_SCLK_CONF_UART1_SCLK_DIV_B_Pos = 0x6
	// Bit mask of UART1_SCLK_DIV_B field.
	PCR_UART1_SCLK_CONF_UART1_SCLK_DIV_B_Msk = 0xfc0
	// Position of UART1_SCLK_DIV_NUM field.
	PCR_UART1_SCLK_CONF_UART1_SCLK_DIV_NUM_Pos = 0xc
	// Bit mask of UART1_SCLK_DIV_NUM field.
	PCR_UART1_SCLK_CONF_UART1_SCLK_DIV_NUM_Msk = 0xff000
	// Position of UART1_SCLK_SEL field.
	PCR_UART1_SCLK_CONF_UART1_SCLK_SEL_Pos = 0x14
	// Bit mask of UART1_SCLK_SEL field.
	PCR_UART1_SCLK_CONF_UART1_SCLK_SEL_Msk = 0x300000
	// Position of UART1_SCLK_EN field.
	PCR_UART1_SCLK_CONF_UART1_SCLK_EN_Pos = 0x16
	// Bit mask of UART1_SCLK_EN field.
	PCR_UART1_SCLK_CONF_UART1_SCLK_EN_Msk = 0x400000
	// Bit UART1_SCLK_EN.
	PCR_UART1_SCLK_CONF_UART1_SCLK_EN = 0x400000

	// UART1_PD_CTRL: UART1 power control register
	// Position of UART1_MEM_FORCE_PU field.
	PCR_UART1_PD_CTRL_UART1_MEM_FORCE_PU_Pos = 0x1
	// Bit mask of UART1_MEM_FORCE_PU field.
	PCR_UART1_PD_CTRL_UART1_MEM_FORCE_PU_Msk = 0x2
	// Bit UART1_MEM_FORCE_PU.
	PCR_UART1_PD_CTRL_UART1_MEM_FORCE_PU = 0x2
	// Position of UART1_MEM_FORCE_PD field.
	PCR_UART1_PD_CTRL_UART1_MEM_FORCE_PD_Pos = 0x2
	// Bit mask of UART1_MEM_FORCE_PD field.
	PCR_UART1_PD_CTRL_UART1_MEM_FORCE_PD_Msk = 0x4
	// Bit UART1_MEM_FORCE_PD.
	PCR_UART1_PD_CTRL_UART1_MEM_FORCE_PD = 0x4

	// MSPI_CONF: MSPI configuration register
	// Position of MSPI_CLK_EN field.
	PCR_MSPI_CONF_MSPI_CLK_EN_Pos = 0x0
	// Bit mask of MSPI_CLK_EN field.
	PCR_MSPI_CONF_MSPI_CLK_EN_Msk = 0x1
	// Bit MSPI_CLK_EN.
	PCR_MSPI_CONF_MSPI_CLK_EN = 0x1
	// Position of MSPI_RST_EN field.
	PCR_MSPI_CONF_MSPI_RST_EN_Pos = 0x1
	// Bit mask of MSPI_RST_EN field.
	PCR_MSPI_CONF_MSPI_RST_EN_Msk = 0x2
	// Bit MSPI_RST_EN.
	PCR_MSPI_CONF_MSPI_RST_EN = 0x2
	// Position of MSPI_PLL_CLK_EN field.
	PCR_MSPI_CONF_MSPI_PLL_CLK_EN_Pos = 0x2
	// Bit mask of MSPI_PLL_CLK_EN field.
	PCR_MSPI_CONF_MSPI_PLL_CLK_EN_Msk = 0x4
	// Bit MSPI_PLL_CLK_EN.
	PCR_MSPI_CONF_MSPI_PLL_CLK_EN = 0x4
	// Position of MSPI_CLK_SEL field.
	PCR_MSPI_CONF_MSPI_CLK_SEL_Pos = 0x3
	// Bit mask of MSPI_CLK_SEL field.
	PCR_MSPI_CONF_MSPI_CLK_SEL_Msk = 0x18
	// Position of MSPI_READY field.
	PCR_MSPI_CONF_MSPI_READY_Pos = 0x5
	// Bit mask of MSPI_READY field.
	PCR_MSPI_CONF_MSPI_READY_Msk = 0x20
	// Bit MSPI_READY.
	PCR_MSPI_CONF_MSPI_READY = 0x20

	// MSPI_CLK_CONF: MSPI_CLK configuration register
	// Position of MSPI_FAST_DIV_NUM field.
	PCR_MSPI_CLK_CONF_MSPI_FAST_DIV_NUM_Pos = 0x0
	// Bit mask of MSPI_FAST_DIV_NUM field.
	PCR_MSPI_CLK_CONF_MSPI_FAST_DIV_NUM_Msk = 0xff

	// I2C0_CONF: I2C configuration register
	// Position of I2C0_CLK_EN field.
	PCR_I2C0_CONF_I2C0_CLK_EN_Pos = 0x0
	// Bit mask of I2C0_CLK_EN field.
	PCR_I2C0_CONF_I2C0_CLK_EN_Msk = 0x1
	// Bit I2C0_CLK_EN.
	PCR_I2C0_CONF_I2C0_CLK_EN = 0x1
	// Position of I2C0_RST_EN field.
	PCR_I2C0_CONF_I2C0_RST_EN_Pos = 0x1
	// Bit mask of I2C0_RST_EN field.
	PCR_I2C0_CONF_I2C0_RST_EN_Msk = 0x2
	// Bit I2C0_RST_EN.
	PCR_I2C0_CONF_I2C0_RST_EN = 0x2
	// Position of I2C0_READY field.
	PCR_I2C0_CONF_I2C0_READY_Pos = 0x2
	// Bit mask of I2C0_READY field.
	PCR_I2C0_CONF_I2C0_READY_Msk = 0x4
	// Bit I2C0_READY.
	PCR_I2C0_CONF_I2C0_READY = 0x4

	// I2C0_SCLK_CONF: I2C_SCLK configuration register
	// Position of I2C0_SCLK_DIV_A field.
	PCR_I2C0_SCLK_CONF_I2C0_SCLK_DIV_A_Pos = 0x0
	// Bit mask of I2C0_SCLK_DIV_A field.
	PCR_I2C0_SCLK_CONF_I2C0_SCLK_DIV_A_Msk = 0x3f
	// Position of I2C0_SCLK_DIV_B field.
	PCR_I2C0_SCLK_CONF_I2C0_SCLK_DIV_B_Pos = 0x6
	// Bit mask of I2C0_SCLK_DIV_B field.
	PCR_I2C0_SCLK_CONF_I2C0_SCLK_DIV_B_Msk = 0xfc0
	// Position of I2C0_SCLK_DIV_NUM field.
	PCR_I2C0_SCLK_CONF_I2C0_SCLK_DIV_NUM_Pos = 0xc
	// Bit mask of I2C0_SCLK_DIV_NUM field.
	PCR_I2C0_SCLK_CONF_I2C0_SCLK_DIV_NUM_Msk = 0xff000
	// Position of I2C0_SCLK_SEL field.
	PCR_I2C0_SCLK_CONF_I2C0_SCLK_SEL_Pos = 0x14
	// Bit mask of I2C0_SCLK_SEL field.
	PCR_I2C0_SCLK_CONF_I2C0_SCLK_SEL_Msk = 0x100000
	// Bit I2C0_SCLK_SEL.
	PCR_I2C0_SCLK_CONF_I2C0_SCLK_SEL = 0x100000
	// Position of I2C0_SCLK_EN field.
	PCR_I2C0_SCLK_CONF_I2C0_SCLK_EN_Pos = 0x16
	// Bit mask of I2C0_SCLK_EN field.
	PCR_I2C0_SCLK_CONF_I2C0_SCLK_EN_Msk = 0x400000
	// Bit I2C0_SCLK_EN.
	PCR_I2C0_SCLK_CONF_I2C0_SCLK_EN = 0x400000

	// I2C1_CONF: I2C configuration register
	// Position of I2C1_CLK_EN field.
	PCR_I2C1_CONF_I2C1_CLK_EN_Pos = 0x0
	// Bit mask of I2C1_CLK_EN field.
	PCR_I2C1_CONF_I2C1_CLK_EN_Msk = 0x1
	// Bit I2C1_CLK_EN.
	PCR_I2C1_CONF_I2C1_CLK_EN = 0x1
	// Position of I2C1_RST_EN field.
	PCR_I2C1_CONF_I2C1_RST_EN_Pos = 0x1
	// Bit mask of I2C1_RST_EN field.
	PCR_I2C1_CONF_I2C1_RST_EN_Msk = 0x2
	// Bit I2C1_RST_EN.
	PCR_I2C1_CONF_I2C1_RST_EN = 0x2
	// Position of I2C1_READY field.
	PCR_I2C1_CONF_I2C1_READY_Pos = 0x2
	// Bit mask of I2C1_READY field.
	PCR_I2C1_CONF_I2C1_READY_Msk = 0x4
	// Bit I2C1_READY.
	PCR_I2C1_CONF_I2C1_READY = 0x4

	// I2C1_SCLK_CONF: I2C_SCLK configuration register
	// Position of I2C1_SCLK_DIV_A field.
	PCR_I2C1_SCLK_CONF_I2C1_SCLK_DIV_A_Pos = 0x0
	// Bit mask of I2C1_SCLK_DIV_A field.
	PCR_I2C1_SCLK_CONF_I2C1_SCLK_DIV_A_Msk = 0x3f
	// Position of I2C1_SCLK_DIV_B field.
	PCR_I2C1_SCLK_CONF_I2C1_SCLK_DIV_B_Pos = 0x6
	// Bit mask of I2C1_SCLK_DIV_B field.
	PCR_I2C1_SCLK_CONF_I2C1_SCLK_DIV_B_Msk = 0xfc0
	// Position of I2C1_SCLK_DIV_NUM field.
	PCR_I2C1_SCLK_CONF_I2C1_SCLK_DIV_NUM_Pos = 0xc
	// Bit mask of I2C1_SCLK_DIV_NUM field.
	PCR_I2C1_SCLK_CONF_I2C1_SCLK_DIV_NUM_Msk = 0xff000
	// Position of I2C1_SCLK_SEL field.
	PCR_I2C1_SCLK_CONF_I2C1_SCLK_SEL_Pos = 0x14
	// Bit mask of I2C1_SCLK_SEL field.
	PCR_I2C1_SCLK_CONF_I2C1_SCLK_SEL_Msk = 0x100000
	// Bit I2C1_SCLK_SEL.
	PCR_I2C1_SCLK_CONF_I2C1_SCLK_SEL = 0x100000
	// Position of I2C1_SCLK_EN field.
	PCR_I2C1_SCLK_CONF_I2C1_SCLK_EN_Pos = 0x16
	// Bit mask of I2C1_SCLK_EN field.
	PCR_I2C1_SCLK_CONF_I2C1_SCLK_EN_Msk = 0x400000
	// Bit I2C1_SCLK_EN.
	PCR_I2C1_SCLK_CONF_I2C1_SCLK_EN = 0x400000

	// UHCI_CONF: UHCI configuration register
	// Position of UHCI_CLK_EN field.
	PCR_UHCI_CONF_UHCI_CLK_EN_Pos = 0x0
	// Bit mask of UHCI_CLK_EN field.
	PCR_UHCI_CONF_UHCI_CLK_EN_Msk = 0x1
	// Bit UHCI_CLK_EN.
	PCR_UHCI_CONF_UHCI_CLK_EN = 0x1
	// Position of UHCI_RST_EN field.
	PCR_UHCI_CONF_UHCI_RST_EN_Pos = 0x1
	// Bit mask of UHCI_RST_EN field.
	PCR_UHCI_CONF_UHCI_RST_EN_Msk = 0x2
	// Bit UHCI_RST_EN.
	PCR_UHCI_CONF_UHCI_RST_EN = 0x2
	// Position of UHCI_READY field.
	PCR_UHCI_CONF_UHCI_READY_Pos = 0x2
	// Bit mask of UHCI_READY field.
	PCR_UHCI_CONF_UHCI_READY_Msk = 0x4
	// Bit UHCI_READY.
	PCR_UHCI_CONF_UHCI_READY = 0x4

	// RMT_CONF: RMT configuration register
	// Position of RMT_CLK_EN field.
	PCR_RMT_CONF_RMT_CLK_EN_Pos = 0x0
	// Bit mask of RMT_CLK_EN field.
	PCR_RMT_CONF_RMT_CLK_EN_Msk = 0x1
	// Bit RMT_CLK_EN.
	PCR_RMT_CONF_RMT_CLK_EN = 0x1
	// Position of RMT_RST_EN field.
	PCR_RMT_CONF_RMT_RST_EN_Pos = 0x1
	// Bit mask of RMT_RST_EN field.
	PCR_RMT_CONF_RMT_RST_EN_Msk = 0x2
	// Bit RMT_RST_EN.
	PCR_RMT_CONF_RMT_RST_EN = 0x2
	// Position of RMT_READY field.
	PCR_RMT_CONF_RMT_READY_Pos = 0x2
	// Bit mask of RMT_READY field.
	PCR_RMT_CONF_RMT_READY_Msk = 0x4
	// Bit RMT_READY.
	PCR_RMT_CONF_RMT_READY = 0x4

	// RMT_SCLK_CONF: RMT_SCLK configuration register
	// Position of SCLK_DIV_A field.
	PCR_RMT_SCLK_CONF_SCLK_DIV_A_Pos = 0x0
	// Bit mask of SCLK_DIV_A field.
	PCR_RMT_SCLK_CONF_SCLK_DIV_A_Msk = 0x3f
	// Position of SCLK_DIV_B field.
	PCR_RMT_SCLK_CONF_SCLK_DIV_B_Pos = 0x6
	// Bit mask of SCLK_DIV_B field.
	PCR_RMT_SCLK_CONF_SCLK_DIV_B_Msk = 0xfc0
	// Position of SCLK_DIV_NUM field.
	PCR_RMT_SCLK_CONF_SCLK_DIV_NUM_Pos = 0xc
	// Bit mask of SCLK_DIV_NUM field.
	PCR_RMT_SCLK_CONF_SCLK_DIV_NUM_Msk = 0xff000
	// Position of SCLK_SEL field.
	PCR_RMT_SCLK_CONF_SCLK_SEL_Pos = 0x14
	// Bit mask of SCLK_SEL field.
	PCR_RMT_SCLK_CONF_SCLK_SEL_Msk = 0x100000
	// Bit SCLK_SEL.
	PCR_RMT_SCLK_CONF_SCLK_SEL = 0x100000
	// Position of SCLK_EN field.
	PCR_RMT_SCLK_CONF_SCLK_EN_Pos = 0x15
	// Bit mask of SCLK_EN field.
	PCR_RMT_SCLK_CONF_SCLK_EN_Msk = 0x200000
	// Bit SCLK_EN.
	PCR_RMT_SCLK_CONF_SCLK_EN = 0x200000

	// LEDC_CONF: LEDC configuration register
	// Position of LEDC_CLK_EN field.
	PCR_LEDC_CONF_LEDC_CLK_EN_Pos = 0x0
	// Bit mask of LEDC_CLK_EN field.
	PCR_LEDC_CONF_LEDC_CLK_EN_Msk = 0x1
	// Bit LEDC_CLK_EN.
	PCR_LEDC_CONF_LEDC_CLK_EN = 0x1
	// Position of LEDC_RST_EN field.
	PCR_LEDC_CONF_LEDC_RST_EN_Pos = 0x1
	// Bit mask of LEDC_RST_EN field.
	PCR_LEDC_CONF_LEDC_RST_EN_Msk = 0x2
	// Bit LEDC_RST_EN.
	PCR_LEDC_CONF_LEDC_RST_EN = 0x2
	// Position of LEDC_READY field.
	PCR_LEDC_CONF_LEDC_READY_Pos = 0x2
	// Bit mask of LEDC_READY field.
	PCR_LEDC_CONF_LEDC_READY_Msk = 0x4
	// Bit LEDC_READY.
	PCR_LEDC_CONF_LEDC_READY = 0x4

	// LEDC_SCLK_CONF: LEDC_SCLK configuration register
	// Position of LEDC_SCLK_SEL field.
	PCR_LEDC_SCLK_CONF_LEDC_SCLK_SEL_Pos = 0x14
	// Bit mask of LEDC_SCLK_SEL field.
	PCR_LEDC_SCLK_CONF_LEDC_SCLK_SEL_Msk = 0x300000
	// Position of LEDC_SCLK_EN field.
	PCR_LEDC_SCLK_CONF_LEDC_SCLK_EN_Pos = 0x16
	// Bit mask of LEDC_SCLK_EN field.
	PCR_LEDC_SCLK_CONF_LEDC_SCLK_EN_Msk = 0x400000
	// Bit LEDC_SCLK_EN.
	PCR_LEDC_SCLK_CONF_LEDC_SCLK_EN = 0x400000

	// TIMERGROUP0_CONF: TIMERGROUP0 configuration register
	// Position of TG0_CLK_EN field.
	PCR_TIMERGROUP0_CONF_TG0_CLK_EN_Pos = 0x0
	// Bit mask of TG0_CLK_EN field.
	PCR_TIMERGROUP0_CONF_TG0_CLK_EN_Msk = 0x1
	// Bit TG0_CLK_EN.
	PCR_TIMERGROUP0_CONF_TG0_CLK_EN = 0x1
	// Position of TG0_RST_EN field.
	PCR_TIMERGROUP0_CONF_TG0_RST_EN_Pos = 0x1
	// Bit mask of TG0_RST_EN field.
	PCR_TIMERGROUP0_CONF_TG0_RST_EN_Msk = 0x2
	// Bit TG0_RST_EN.
	PCR_TIMERGROUP0_CONF_TG0_RST_EN = 0x2
	// Position of TG0_WDT_READY field.
	PCR_TIMERGROUP0_CONF_TG0_WDT_READY_Pos = 0x2
	// Bit mask of TG0_WDT_READY field.
	PCR_TIMERGROUP0_CONF_TG0_WDT_READY_Msk = 0x4
	// Bit TG0_WDT_READY.
	PCR_TIMERGROUP0_CONF_TG0_WDT_READY = 0x4
	// Position of TG0_TIMER0_READY field.
	PCR_TIMERGROUP0_CONF_TG0_TIMER0_READY_Pos = 0x3
	// Bit mask of TG0_TIMER0_READY field.
	PCR_TIMERGROUP0_CONF_TG0_TIMER0_READY_Msk = 0x8
	// Bit TG0_TIMER0_READY.
	PCR_TIMERGROUP0_CONF_TG0_TIMER0_READY = 0x8
	// Position of TG0_TIMER1_READY field.
	PCR_TIMERGROUP0_CONF_TG0_TIMER1_READY_Pos = 0x4
	// Bit mask of TG0_TIMER1_READY field.
	PCR_TIMERGROUP0_CONF_TG0_TIMER1_READY_Msk = 0x10
	// Bit TG0_TIMER1_READY.
	PCR_TIMERGROUP0_CONF_TG0_TIMER1_READY = 0x10

	// TIMERGROUP0_TIMER_CLK_CONF: TIMERGROUP0_TIMER_CLK configuration register
	// Position of TG0_TIMER_CLK_SEL field.
	PCR_TIMERGROUP0_TIMER_CLK_CONF_TG0_TIMER_CLK_SEL_Pos = 0x14
	// Bit mask of TG0_TIMER_CLK_SEL field.
	PCR_TIMERGROUP0_TIMER_CLK_CONF_TG0_TIMER_CLK_SEL_Msk = 0x300000
	// Position of TG0_TIMER_CLK_EN field.
	PCR_TIMERGROUP0_TIMER_CLK_CONF_TG0_TIMER_CLK_EN_Pos = 0x16
	// Bit mask of TG0_TIMER_CLK_EN field.
	PCR_TIMERGROUP0_TIMER_CLK_CONF_TG0_TIMER_CLK_EN_Msk = 0x400000
	// Bit TG0_TIMER_CLK_EN.
	PCR_TIMERGROUP0_TIMER_CLK_CONF_TG0_TIMER_CLK_EN = 0x400000

	// TIMERGROUP0_WDT_CLK_CONF: TIMERGROUP0_WDT_CLK configuration register
	// Position of TG0_WDT_CLK_SEL field.
	PCR_TIMERGROUP0_WDT_CLK_CONF_TG0_WDT_CLK_SEL_Pos = 0x14
	// Bit mask of TG0_WDT_CLK_SEL field.
	PCR_TIMERGROUP0_WDT_CLK_CONF_TG0_WDT_CLK_SEL_Msk = 0x300000
	// Position of TG0_WDT_CLK_EN field.
	PCR_TIMERGROUP0_WDT_CLK_CONF_TG0_WDT_CLK_EN_Pos = 0x16
	// Bit mask of TG0_WDT_CLK_EN field.
	PCR_TIMERGROUP0_WDT_CLK_CONF_TG0_WDT_CLK_EN_Msk = 0x400000
	// Bit TG0_WDT_CLK_EN.
	PCR_TIMERGROUP0_WDT_CLK_CONF_TG0_WDT_CLK_EN = 0x400000

	// TIMERGROUP1_CONF: TIMERGROUP1 configuration register
	// Position of TG1_CLK_EN field.
	PCR_TIMERGROUP1_CONF_TG1_CLK_EN_Pos = 0x0
	// Bit mask of TG1_CLK_EN field.
	PCR_TIMERGROUP1_CONF_TG1_CLK_EN_Msk = 0x1
	// Bit TG1_CLK_EN.
	PCR_TIMERGROUP1_CONF_TG1_CLK_EN = 0x1
	// Position of TG1_RST_EN field.
	PCR_TIMERGROUP1_CONF_TG1_RST_EN_Pos = 0x1
	// Bit mask of TG1_RST_EN field.
	PCR_TIMERGROUP1_CONF_TG1_RST_EN_Msk = 0x2
	// Bit TG1_RST_EN.
	PCR_TIMERGROUP1_CONF_TG1_RST_EN = 0x2
	// Position of TG1_WDT_READY field.
	PCR_TIMERGROUP1_CONF_TG1_WDT_READY_Pos = 0x2
	// Bit mask of TG1_WDT_READY field.
	PCR_TIMERGROUP1_CONF_TG1_WDT_READY_Msk = 0x4
	// Bit TG1_WDT_READY.
	PCR_TIMERGROUP1_CONF_TG1_WDT_READY = 0x4
	// Position of TG1_TIMER0_READY field.
	PCR_TIMERGROUP1_CONF_TG1_TIMER0_READY_Pos = 0x3
	// Bit mask of TG1_TIMER0_READY field.
	PCR_TIMERGROUP1_CONF_TG1_TIMER0_READY_Msk = 0x8
	// Bit TG1_TIMER0_READY.
	PCR_TIMERGROUP1_CONF_TG1_TIMER0_READY = 0x8
	// Position of TG1_TIMER1_READY field.
	PCR_TIMERGROUP1_CONF_TG1_TIMER1_READY_Pos = 0x4
	// Bit mask of TG1_TIMER1_READY field.
	PCR_TIMERGROUP1_CONF_TG1_TIMER1_READY_Msk = 0x10
	// Bit TG1_TIMER1_READY.
	PCR_TIMERGROUP1_CONF_TG1_TIMER1_READY = 0x10

	// TIMERGROUP1_TIMER_CLK_CONF: TIMERGROUP1_TIMER_CLK configuration register
	// Position of TG1_TIMER_CLK_SEL field.
	PCR_TIMERGROUP1_TIMER_CLK_CONF_TG1_TIMER_CLK_SEL_Pos = 0x14
	// Bit mask of TG1_TIMER_CLK_SEL field.
	PCR_TIMERGROUP1_TIMER_CLK_CONF_TG1_TIMER_CLK_SEL_Msk = 0x300000
	// Position of TG1_TIMER_CLK_EN field.
	PCR_TIMERGROUP1_TIMER_CLK_CONF_TG1_TIMER_CLK_EN_Pos = 0x16
	// Bit mask of TG1_TIMER_CLK_EN field.
	PCR_TIMERGROUP1_TIMER_CLK_CONF_TG1_TIMER_CLK_EN_Msk = 0x400000
	// Bit TG1_TIMER_CLK_EN.
	PCR_TIMERGROUP1_TIMER_CLK_CONF_TG1_TIMER_CLK_EN = 0x400000

	// TIMERGROUP1_WDT_CLK_CONF: TIMERGROUP1_WDT_CLK configuration register
	// Position of TG1_WDT_CLK_SEL field.
	PCR_TIMERGROUP1_WDT_CLK_CONF_TG1_WDT_CLK_SEL_Pos = 0x14
	// Bit mask of TG1_WDT_CLK_SEL field.
	PCR_TIMERGROUP1_WDT_CLK_CONF_TG1_WDT_CLK_SEL_Msk = 0x300000
	// Position of TG1_WDT_CLK_EN field.
	PCR_TIMERGROUP1_WDT_CLK_CONF_TG1_WDT_CLK_EN_Pos = 0x16
	// Bit mask of TG1_WDT_CLK_EN field.
	PCR_TIMERGROUP1_WDT_CLK_CONF_TG1_WDT_CLK_EN_Msk = 0x400000
	// Bit TG1_WDT_CLK_EN.
	PCR_TIMERGROUP1_WDT_CLK_CONF_TG1_WDT_CLK_EN = 0x400000

	// SYSTIMER_CONF: SYSTIMER configuration register
	// Position of SYSTIMER_CLK_EN field.
	PCR_SYSTIMER_CONF_SYSTIMER_CLK_EN_Pos = 0x0
	// Bit mask of SYSTIMER_CLK_EN field.
	PCR_SYSTIMER_CONF_SYSTIMER_CLK_EN_Msk = 0x1
	// Bit SYSTIMER_CLK_EN.
	PCR_SYSTIMER_CONF_SYSTIMER_CLK_EN = 0x1
	// Position of SYSTIMER_RST_EN field.
	PCR_SYSTIMER_CONF_SYSTIMER_RST_EN_Pos = 0x1
	// Bit mask of SYSTIMER_RST_EN field.
	PCR_SYSTIMER_CONF_SYSTIMER_RST_EN_Msk = 0x2
	// Bit SYSTIMER_RST_EN.
	PCR_SYSTIMER_CONF_SYSTIMER_RST_EN = 0x2
	// Position of SYSTIMER_READY field.
	PCR_SYSTIMER_CONF_SYSTIMER_READY_Pos = 0x2
	// Bit mask of SYSTIMER_READY field.
	PCR_SYSTIMER_CONF_SYSTIMER_READY_Msk = 0x4
	// Bit SYSTIMER_READY.
	PCR_SYSTIMER_CONF_SYSTIMER_READY = 0x4

	// SYSTIMER_FUNC_CLK_CONF: SYSTIMER_FUNC_CLK configuration register
	// Position of SYSTIMER_FUNC_CLK_SEL field.
	PCR_SYSTIMER_FUNC_CLK_CONF_SYSTIMER_FUNC_CLK_SEL_Pos = 0x14
	// Bit mask of SYSTIMER_FUNC_CLK_SEL field.
	PCR_SYSTIMER_FUNC_CLK_CONF_SYSTIMER_FUNC_CLK_SEL_Msk = 0x100000
	// Bit SYSTIMER_FUNC_CLK_SEL.
	PCR_SYSTIMER_FUNC_CLK_CONF_SYSTIMER_FUNC_CLK_SEL = 0x100000
	// Position of SYSTIMER_FUNC_CLK_EN field.
	PCR_SYSTIMER_FUNC_CLK_CONF_SYSTIMER_FUNC_CLK_EN_Pos = 0x16
	// Bit mask of SYSTIMER_FUNC_CLK_EN field.
	PCR_SYSTIMER_FUNC_CLK_CONF_SYSTIMER_FUNC_CLK_EN_Msk = 0x400000
	// Bit SYSTIMER_FUNC_CLK_EN.
	PCR_SYSTIMER_FUNC_CLK_CONF_SYSTIMER_FUNC_CLK_EN = 0x400000

	// TWAI0_CONF: TWAI0 configuration register
	// Position of TWAI0_CLK_EN field.
	PCR_TWAI0_CONF_TWAI0_CLK_EN_Pos = 0x0
	// Bit mask of TWAI0_CLK_EN field.
	PCR_TWAI0_CONF_TWAI0_CLK_EN_Msk = 0x1
	// Bit TWAI0_CLK_EN.
	PCR_TWAI0_CONF_TWAI0_CLK_EN = 0x1
	// Position of TWAI0_RST_EN field.
	PCR_TWAI0_CONF_TWAI0_RST_EN_Pos = 0x1
	// Bit mask of TWAI0_RST_EN field.
	PCR_TWAI0_CONF_TWAI0_RST_EN_Msk = 0x2
	// Bit TWAI0_RST_EN.
	PCR_TWAI0_CONF_TWAI0_RST_EN = 0x2
	// Position of TWAI0_READY field.
	PCR_TWAI0_CONF_TWAI0_READY_Pos = 0x2
	// Bit mask of TWAI0_READY field.
	PCR_TWAI0_CONF_TWAI0_READY_Msk = 0x4
	// Bit TWAI0_READY.
	PCR_TWAI0_CONF_TWAI0_READY = 0x4

	// TWAI0_FUNC_CLK_CONF: TWAI0_FUNC_CLK configuration register
	// Position of TWAI0_FUNC_CLK_SEL field.
	PCR_TWAI0_FUNC_CLK_CONF_TWAI0_FUNC_CLK_SEL_Pos = 0x14
	// Bit mask of TWAI0_FUNC_CLK_SEL field.
	PCR_TWAI0_FUNC_CLK_CONF_TWAI0_FUNC_CLK_SEL_Msk = 0x100000
	// Bit TWAI0_FUNC_CLK_SEL.
	PCR_TWAI0_FUNC_CLK_CONF_TWAI0_FUNC_CLK_SEL = 0x100000
	// Position of TWAI0_FUNC_CLK_EN field.
	PCR_TWAI0_FUNC_CLK_CONF_TWAI0_FUNC_CLK_EN_Pos = 0x16
	// Bit mask of TWAI0_FUNC_CLK_EN field.
	PCR_TWAI0_FUNC_CLK_CONF_TWAI0_FUNC_CLK_EN_Msk = 0x400000
	// Bit TWAI0_FUNC_CLK_EN.
	PCR_TWAI0_FUNC_CLK_CONF_TWAI0_FUNC_CLK_EN = 0x400000

	// I2S_CONF: I2S configuration register
	// Position of I2S_CLK_EN field.
	PCR_I2S_CONF_I2S_CLK_EN_Pos = 0x0
	// Bit mask of I2S_CLK_EN field.
	PCR_I2S_CONF_I2S_CLK_EN_Msk = 0x1
	// Bit I2S_CLK_EN.
	PCR_I2S_CONF_I2S_CLK_EN = 0x1
	// Position of I2S_RST_EN field.
	PCR_I2S_CONF_I2S_RST_EN_Pos = 0x1
	// Bit mask of I2S_RST_EN field.
	PCR_I2S_CONF_I2S_RST_EN_Msk = 0x2
	// Bit I2S_RST_EN.
	PCR_I2S_CONF_I2S_RST_EN = 0x2
	// Position of I2S_RX_READY field.
	PCR_I2S_CONF_I2S_RX_READY_Pos = 0x2
	// Bit mask of I2S_RX_READY field.
	PCR_I2S_CONF_I2S_RX_READY_Msk = 0x4
	// Bit I2S_RX_READY.
	PCR_I2S_CONF_I2S_RX_READY = 0x4
	// Position of I2S_TX_READY field.
	PCR_I2S_CONF_I2S_TX_READY_Pos = 0x3
	// Bit mask of I2S_TX_READY field.
	PCR_I2S_CONF_I2S_TX_READY_Msk = 0x8
	// Bit I2S_TX_READY.
	PCR_I2S_CONF_I2S_TX_READY = 0x8

	// I2S_TX_CLKM_CONF: I2S_TX_CLKM configuration register
	// Position of I2S_TX_CLKM_DIV_NUM field.
	PCR_I2S_TX_CLKM_CONF_I2S_TX_CLKM_DIV_NUM_Pos = 0xc
	// Bit mask of I2S_TX_CLKM_DIV_NUM field.
	PCR_I2S_TX_CLKM_CONF_I2S_TX_CLKM_DIV_NUM_Msk = 0xff000
	// Position of I2S_TX_CLKM_SEL field.
	PCR_I2S_TX_CLKM_CONF_I2S_TX_CLKM_SEL_Pos = 0x14
	// Bit mask of I2S_TX_CLKM_SEL field.
	PCR_I2S_TX_CLKM_CONF_I2S_TX_CLKM_SEL_Msk = 0x300000
	// Position of I2S_TX_CLKM_EN field.
	PCR_I2S_TX_CLKM_CONF_I2S_TX_CLKM_EN_Pos = 0x16
	// Bit mask of I2S_TX_CLKM_EN field.
	PCR_I2S_TX_CLKM_CONF_I2S_TX_CLKM_EN_Msk = 0x400000
	// Bit I2S_TX_CLKM_EN.
	PCR_I2S_TX_CLKM_CONF_I2S_TX_CLKM_EN = 0x400000

	// I2S_TX_CLKM_DIV_CONF: I2S_TX_CLKM_DIV configuration register
	// Position of I2S_TX_CLKM_DIV_Z field.
	PCR_I2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_Z_Pos = 0x0
	// Bit mask of I2S_TX_CLKM_DIV_Z field.
	PCR_I2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_Z_Msk = 0x1ff
	// Position of I2S_TX_CLKM_DIV_Y field.
	PCR_I2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_Y_Pos = 0x9
	// Bit mask of I2S_TX_CLKM_DIV_Y field.
	PCR_I2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_Y_Msk = 0x3fe00
	// Position of I2S_TX_CLKM_DIV_X field.
	PCR_I2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_X_Pos = 0x12
	// Bit mask of I2S_TX_CLKM_DIV_X field.
	PCR_I2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_X_Msk = 0x7fc0000
	// Position of I2S_TX_CLKM_DIV_YN1 field.
	PCR_I2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_YN1_Pos = 0x1b
	// Bit mask of I2S_TX_CLKM_DIV_YN1 field.
	PCR_I2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_YN1_Msk = 0x8000000
	// Bit I2S_TX_CLKM_DIV_YN1.
	PCR_I2S_TX_CLKM_DIV_CONF_I2S_TX_CLKM_DIV_YN1 = 0x8000000

	// I2S_RX_CLKM_CONF: I2S_RX_CLKM configuration register
	// Position of I2S_RX_CLKM_DIV_NUM field.
	PCR_I2S_RX_CLKM_CONF_I2S_RX_CLKM_DIV_NUM_Pos = 0xc
	// Bit mask of I2S_RX_CLKM_DIV_NUM field.
	PCR_I2S_RX_CLKM_CONF_I2S_RX_CLKM_DIV_NUM_Msk = 0xff000
	// Position of I2S_RX_CLKM_SEL field.
	PCR_I2S_RX_CLKM_CONF_I2S_RX_CLKM_SEL_Pos = 0x14
	// Bit mask of I2S_RX_CLKM_SEL field.
	PCR_I2S_RX_CLKM_CONF_I2S_RX_CLKM_SEL_Msk = 0x300000
	// Position of I2S_RX_CLKM_EN field.
	PCR_I2S_RX_CLKM_CONF_I2S_RX_CLKM_EN_Pos = 0x16
	// Bit mask of I2S_RX_CLKM_EN field.
	PCR_I2S_RX_CLKM_CONF_I2S_RX_CLKM_EN_Msk = 0x400000
	// Bit I2S_RX_CLKM_EN.
	PCR_I2S_RX_CLKM_CONF_I2S_RX_CLKM_EN = 0x400000
	// Position of I2S_MCLK_SEL field.
	PCR_I2S_RX_CLKM_CONF_I2S_MCLK_SEL_Pos = 0x17
	// Bit mask of I2S_MCLK_SEL field.
	PCR_I2S_RX_CLKM_CONF_I2S_MCLK_SEL_Msk = 0x800000
	// Bit I2S_MCLK_SEL.
	PCR_I2S_RX_CLKM_CONF_I2S_MCLK_SEL = 0x800000

	// I2S_RX_CLKM_DIV_CONF: I2S_RX_CLKM_DIV configuration register
	// Position of I2S_RX_CLKM_DIV_Z field.
	PCR_I2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_Z_Pos = 0x0
	// Bit mask of I2S_RX_CLKM_DIV_Z field.
	PCR_I2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_Z_Msk = 0x1ff
	// Position of I2S_RX_CLKM_DIV_Y field.
	PCR_I2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_Y_Pos = 0x9
	// Bit mask of I2S_RX_CLKM_DIV_Y field.
	PCR_I2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_Y_Msk = 0x3fe00
	// Position of I2S_RX_CLKM_DIV_X field.
	PCR_I2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_X_Pos = 0x12
	// Bit mask of I2S_RX_CLKM_DIV_X field.
	PCR_I2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_X_Msk = 0x7fc0000
	// Position of I2S_RX_CLKM_DIV_YN1 field.
	PCR_I2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_YN1_Pos = 0x1b
	// Bit mask of I2S_RX_CLKM_DIV_YN1 field.
	PCR_I2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_YN1_Msk = 0x8000000
	// Bit I2S_RX_CLKM_DIV_YN1.
	PCR_I2S_RX_CLKM_DIV_CONF_I2S_RX_CLKM_DIV_YN1 = 0x8000000

	// SARADC_CONF: SARADC configuration register
	// Position of SARADC_CLK_EN field.
	PCR_SARADC_CONF_SARADC_CLK_EN_Pos = 0x0
	// Bit mask of SARADC_CLK_EN field.
	PCR_SARADC_CONF_SARADC_CLK_EN_Msk = 0x1
	// Bit SARADC_CLK_EN.
	PCR_SARADC_CONF_SARADC_CLK_EN = 0x1
	// Position of SARADC_RST_EN field.
	PCR_SARADC_CONF_SARADC_RST_EN_Pos = 0x1
	// Bit mask of SARADC_RST_EN field.
	PCR_SARADC_CONF_SARADC_RST_EN_Msk = 0x2
	// Bit SARADC_RST_EN.
	PCR_SARADC_CONF_SARADC_RST_EN = 0x2
	// Position of SARADC_REG_CLK_EN field.
	PCR_SARADC_CONF_SARADC_REG_CLK_EN_Pos = 0x2
	// Bit mask of SARADC_REG_CLK_EN field.
	PCR_SARADC_CONF_SARADC_REG_CLK_EN_Msk = 0x4
	// Bit SARADC_REG_CLK_EN.
	PCR_SARADC_CONF_SARADC_REG_CLK_EN = 0x4
	// Position of SARADC_REG_RST_EN field.
	PCR_SARADC_CONF_SARADC_REG_RST_EN_Pos = 0x3
	// Bit mask of SARADC_REG_RST_EN field.
	PCR_SARADC_CONF_SARADC_REG_RST_EN_Msk = 0x8
	// Bit SARADC_REG_RST_EN.
	PCR_SARADC_CONF_SARADC_REG_RST_EN = 0x8

	// SARADC_CLKM_CONF: SARADC_CLKM configuration register
	// Position of SARADC_CLKM_DIV_A field.
	PCR_SARADC_CLKM_CONF_SARADC_CLKM_DIV_A_Pos = 0x0
	// Bit mask of SARADC_CLKM_DIV_A field.
	PCR_SARADC_CLKM_CONF_SARADC_CLKM_DIV_A_Msk = 0x3f
	// Position of SARADC_CLKM_DIV_B field.
	PCR_SARADC_CLKM_CONF_SARADC_CLKM_DIV_B_Pos = 0x6
	// Bit mask of SARADC_CLKM_DIV_B field.
	PCR_SARADC_CLKM_CONF_SARADC_CLKM_DIV_B_Msk = 0xfc0
	// Position of SARADC_CLKM_DIV_NUM field.
	PCR_SARADC_CLKM_CONF_SARADC_CLKM_DIV_NUM_Pos = 0xc
	// Bit mask of SARADC_CLKM_DIV_NUM field.
	PCR_SARADC_CLKM_CONF_SARADC_CLKM_DIV_NUM_Msk = 0xff000
	// Position of SARADC_CLKM_SEL field.
	PCR_SARADC_CLKM_CONF_SARADC_CLKM_SEL_Pos = 0x14
	// Bit mask of SARADC_CLKM_SEL field.
	PCR_SARADC_CLKM_CONF_SARADC_CLKM_SEL_Msk = 0x300000
	// Position of SARADC_CLKM_EN field.
	PCR_SARADC_CLKM_CONF_SARADC_CLKM_EN_Pos = 0x16
	// Bit mask of SARADC_CLKM_EN field.
	PCR_SARADC_CLKM_CONF_SARADC_CLKM_EN_Msk = 0x400000
	// Bit SARADC_CLKM_EN.
	PCR_SARADC_CLKM_CONF_SARADC_CLKM_EN = 0x400000

	// TSENS_CLK_CONF: TSENS_CLK configuration register
	// Position of TSENS_CLK_SEL field.
	PCR_TSENS_CLK_CONF_TSENS_CLK_SEL_Pos = 0x14
	// Bit mask of TSENS_CLK_SEL field.
	PCR_TSENS_CLK_CONF_TSENS_CLK_SEL_Msk = 0x100000
	// Bit TSENS_CLK_SEL.
	PCR_TSENS_CLK_CONF_TSENS_CLK_SEL = 0x100000
	// Position of TSENS_CLK_EN field.
	PCR_TSENS_CLK_CONF_TSENS_CLK_EN_Pos = 0x16
	// Bit mask of TSENS_CLK_EN field.
	PCR_TSENS_CLK_CONF_TSENS_CLK_EN_Msk = 0x400000
	// Bit TSENS_CLK_EN.
	PCR_TSENS_CLK_CONF_TSENS_CLK_EN = 0x400000
	// Position of TSENS_RST_EN field.
	PCR_TSENS_CLK_CONF_TSENS_RST_EN_Pos = 0x17
	// Bit mask of TSENS_RST_EN field.
	PCR_TSENS_CLK_CONF_TSENS_RST_EN_Msk = 0x800000
	// Bit TSENS_RST_EN.
	PCR_TSENS_CLK_CONF_TSENS_RST_EN = 0x800000

	// USB_DEVICE_CONF: USB_DEVICE configuration register
	// Position of USB_DEVICE_CLK_EN field.
	PCR_USB_DEVICE_CONF_USB_DEVICE_CLK_EN_Pos = 0x0
	// Bit mask of USB_DEVICE_CLK_EN field.
	PCR_USB_DEVICE_CONF_USB_DEVICE_CLK_EN_Msk = 0x1
	// Bit USB_DEVICE_CLK_EN.
	PCR_USB_DEVICE_CONF_USB_DEVICE_CLK_EN = 0x1
	// Position of USB_DEVICE_RST_EN field.
	PCR_USB_DEVICE_CONF_USB_DEVICE_RST_EN_Pos = 0x1
	// Bit mask of USB_DEVICE_RST_EN field.
	PCR_USB_DEVICE_CONF_USB_DEVICE_RST_EN_Msk = 0x2
	// Bit USB_DEVICE_RST_EN.
	PCR_USB_DEVICE_CONF_USB_DEVICE_RST_EN = 0x2
	// Position of USB_DEVICE_READY field.
	PCR_USB_DEVICE_CONF_USB_DEVICE_READY_Pos = 0x2
	// Bit mask of USB_DEVICE_READY field.
	PCR_USB_DEVICE_CONF_USB_DEVICE_READY_Msk = 0x4
	// Bit USB_DEVICE_READY.
	PCR_USB_DEVICE_CONF_USB_DEVICE_READY = 0x4

	// INTMTX_CONF: INTMTX configuration register
	// Position of INTMTX_CLK_EN field.
	PCR_INTMTX_CONF_INTMTX_CLK_EN_Pos = 0x0
	// Bit mask of INTMTX_CLK_EN field.
	PCR_INTMTX_CONF_INTMTX_CLK_EN_Msk = 0x1
	// Bit INTMTX_CLK_EN.
	PCR_INTMTX_CONF_INTMTX_CLK_EN = 0x1
	// Position of INTMTX_RST_EN field.
	PCR_INTMTX_CONF_INTMTX_RST_EN_Pos = 0x1
	// Bit mask of INTMTX_RST_EN field.
	PCR_INTMTX_CONF_INTMTX_RST_EN_Msk = 0x2
	// Bit INTMTX_RST_EN.
	PCR_INTMTX_CONF_INTMTX_RST_EN = 0x2
	// Position of INTMTX_READY field.
	PCR_INTMTX_CONF_INTMTX_READY_Pos = 0x2
	// Bit mask of INTMTX_READY field.
	PCR_INTMTX_CONF_INTMTX_READY_Msk = 0x4
	// Bit INTMTX_READY.
	PCR_INTMTX_CONF_INTMTX_READY = 0x4

	// PCNT_CONF: PCNT configuration register
	// Position of PCNT_CLK_EN field.
	PCR_PCNT_CONF_PCNT_CLK_EN_Pos = 0x0
	// Bit mask of PCNT_CLK_EN field.
	PCR_PCNT_CONF_PCNT_CLK_EN_Msk = 0x1
	// Bit PCNT_CLK_EN.
	PCR_PCNT_CONF_PCNT_CLK_EN = 0x1
	// Position of PCNT_RST_EN field.
	PCR_PCNT_CONF_PCNT_RST_EN_Pos = 0x1
	// Bit mask of PCNT_RST_EN field.
	PCR_PCNT_CONF_PCNT_RST_EN_Msk = 0x2
	// Bit PCNT_RST_EN.
	PCR_PCNT_CONF_PCNT_RST_EN = 0x2
	// Position of PCNT_READY field.
	PCR_PCNT_CONF_PCNT_READY_Pos = 0x2
	// Bit mask of PCNT_READY field.
	PCR_PCNT_CONF_PCNT_READY_Msk = 0x4
	// Bit PCNT_READY.
	PCR_PCNT_CONF_PCNT_READY = 0x4

	// ETM_CONF: ETM configuration register
	// Position of ETM_CLK_EN field.
	PCR_ETM_CONF_ETM_CLK_EN_Pos = 0x0
	// Bit mask of ETM_CLK_EN field.
	PCR_ETM_CONF_ETM_CLK_EN_Msk = 0x1
	// Bit ETM_CLK_EN.
	PCR_ETM_CONF_ETM_CLK_EN = 0x1
	// Position of ETM_RST_EN field.
	PCR_ETM_CONF_ETM_RST_EN_Pos = 0x1
	// Bit mask of ETM_RST_EN field.
	PCR_ETM_CONF_ETM_RST_EN_Msk = 0x2
	// Bit ETM_RST_EN.
	PCR_ETM_CONF_ETM_RST_EN = 0x2
	// Position of ETM_READY field.
	PCR_ETM_CONF_ETM_READY_Pos = 0x2
	// Bit mask of ETM_READY field.
	PCR_ETM_CONF_ETM_READY_Msk = 0x4
	// Bit ETM_READY.
	PCR_ETM_CONF_ETM_READY = 0x4

	// PWM_CONF: PWM configuration register
	// Position of PWM_CLK_EN field.
	PCR_PWM_CONF_PWM_CLK_EN_Pos = 0x0
	// Bit mask of PWM_CLK_EN field.
	PCR_PWM_CONF_PWM_CLK_EN_Msk = 0x1
	// Bit PWM_CLK_EN.
	PCR_PWM_CONF_PWM_CLK_EN = 0x1
	// Position of PWM_RST_EN field.
	PCR_PWM_CONF_PWM_RST_EN_Pos = 0x1
	// Bit mask of PWM_RST_EN field.
	PCR_PWM_CONF_PWM_RST_EN_Msk = 0x2
	// Bit PWM_RST_EN.
	PCR_PWM_CONF_PWM_RST_EN = 0x2
	// Position of PWM_READY field.
	PCR_PWM_CONF_PWM_READY_Pos = 0x2
	// Bit mask of PWM_READY field.
	PCR_PWM_CONF_PWM_READY_Msk = 0x4
	// Bit PWM_READY.
	PCR_PWM_CONF_PWM_READY = 0x4

	// PWM_CLK_CONF: PWM_CLK configuration register
	// Position of PWM_DIV_NUM field.
	PCR_PWM_CLK_CONF_PWM_DIV_NUM_Pos = 0xc
	// Bit mask of PWM_DIV_NUM field.
	PCR_PWM_CLK_CONF_PWM_DIV_NUM_Msk = 0xff000
	// Position of PWM_CLKM_SEL field.
	PCR_PWM_CLK_CONF_PWM_CLKM_SEL_Pos = 0x14
	// Bit mask of PWM_CLKM_SEL field.
	PCR_PWM_CLK_CONF_PWM_CLKM_SEL_Msk = 0x300000
	// Position of PWM_CLKM_EN field.
	PCR_PWM_CLK_CONF_PWM_CLKM_EN_Pos = 0x16
	// Bit mask of PWM_CLKM_EN field.
	PCR_PWM_CLK_CONF_PWM_CLKM_EN_Msk = 0x400000
	// Bit PWM_CLKM_EN.
	PCR_PWM_CLK_CONF_PWM_CLKM_EN = 0x400000

	// PARL_IO_CONF: PARL_IO configuration register
	// Position of PARL_CLK_EN field.
	PCR_PARL_IO_CONF_PARL_CLK_EN_Pos = 0x0
	// Bit mask of PARL_CLK_EN field.
	PCR_PARL_IO_CONF_PARL_CLK_EN_Msk = 0x1
	// Bit PARL_CLK_EN.
	PCR_PARL_IO_CONF_PARL_CLK_EN = 0x1
	// Position of PARL_RST_EN field.
	PCR_PARL_IO_CONF_PARL_RST_EN_Pos = 0x1
	// Bit mask of PARL_RST_EN field.
	PCR_PARL_IO_CONF_PARL_RST_EN_Msk = 0x2
	// Bit PARL_RST_EN.
	PCR_PARL_IO_CONF_PARL_RST_EN = 0x2
	// Position of PARL_READY field.
	PCR_PARL_IO_CONF_PARL_READY_Pos = 0x2
	// Bit mask of PARL_READY field.
	PCR_PARL_IO_CONF_PARL_READY_Msk = 0x4
	// Bit PARL_READY.
	PCR_PARL_IO_CONF_PARL_READY = 0x4

	// PARL_CLK_RX_CONF: PARL_CLK_RX configuration register
	// Position of PARL_CLK_RX_DIV_NUM field.
	PCR_PARL_CLK_RX_CONF_PARL_CLK_RX_DIV_NUM_Pos = 0x0
	// Bit mask of PARL_CLK_RX_DIV_NUM field.
	PCR_PARL_CLK_RX_CONF_PARL_CLK_RX_DIV_NUM_Msk = 0xffff
	// Position of PARL_CLK_RX_SEL field.
	PCR_PARL_CLK_RX_CONF_PARL_CLK_RX_SEL_Pos = 0x10
	// Bit mask of PARL_CLK_RX_SEL field.
	PCR_PARL_CLK_RX_CONF_PARL_CLK_RX_SEL_Msk = 0x30000
	// Position of PARL_CLK_RX_EN field.
	PCR_PARL_CLK_RX_CONF_PARL_CLK_RX_EN_Pos = 0x12
	// Bit mask of PARL_CLK_RX_EN field.
	PCR_PARL_CLK_RX_CONF_PARL_CLK_RX_EN_Msk = 0x40000
	// Bit PARL_CLK_RX_EN.
	PCR_PARL_CLK_RX_CONF_PARL_CLK_RX_EN = 0x40000
	// Position of PARL_RX_RST_EN field.
	PCR_PARL_CLK_RX_CONF_PARL_RX_RST_EN_Pos = 0x13
	// Bit mask of PARL_RX_RST_EN field.
	PCR_PARL_CLK_RX_CONF_PARL_RX_RST_EN_Msk = 0x80000
	// Bit PARL_RX_RST_EN.
	PCR_PARL_CLK_RX_CONF_PARL_RX_RST_EN = 0x80000

	// PARL_CLK_TX_CONF: PARL_CLK_TX configuration register
	// Position of PARL_CLK_TX_DIV_NUM field.
	PCR_PARL_CLK_TX_CONF_PARL_CLK_TX_DIV_NUM_Pos = 0x0
	// Bit mask of PARL_CLK_TX_DIV_NUM field.
	PCR_PARL_CLK_TX_CONF_PARL_CLK_TX_DIV_NUM_Msk = 0xffff
	// Position of PARL_CLK_TX_SEL field.
	PCR_PARL_CLK_TX_CONF_PARL_CLK_TX_SEL_Pos = 0x10
	// Bit mask of PARL_CLK_TX_SEL field.
	PCR_PARL_CLK_TX_CONF_PARL_CLK_TX_SEL_Msk = 0x30000
	// Position of PARL_CLK_TX_EN field.
	PCR_PARL_CLK_TX_CONF_PARL_CLK_TX_EN_Pos = 0x12
	// Bit mask of PARL_CLK_TX_EN field.
	PCR_PARL_CLK_TX_CONF_PARL_CLK_TX_EN_Msk = 0x40000
	// Bit PARL_CLK_TX_EN.
	PCR_PARL_CLK_TX_CONF_PARL_CLK_TX_EN = 0x40000
	// Position of PARL_TX_RST_EN field.
	PCR_PARL_CLK_TX_CONF_PARL_TX_RST_EN_Pos = 0x13
	// Bit mask of PARL_TX_RST_EN field.
	PCR_PARL_CLK_TX_CONF_PARL_TX_RST_EN_Msk = 0x80000
	// Bit PARL_TX_RST_EN.
	PCR_PARL_CLK_TX_CONF_PARL_TX_RST_EN = 0x80000

	// PVT_MONITOR_CONF: PVT_MONITOR configuration register
	// Position of PVT_MONITOR_CLK_EN field.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_CLK_EN_Pos = 0x0
	// Bit mask of PVT_MONITOR_CLK_EN field.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_CLK_EN_Msk = 0x1
	// Bit PVT_MONITOR_CLK_EN.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_CLK_EN = 0x1
	// Position of PVT_MONITOR_RST_EN field.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_RST_EN_Pos = 0x1
	// Bit mask of PVT_MONITOR_RST_EN field.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_RST_EN_Msk = 0x2
	// Bit PVT_MONITOR_RST_EN.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_RST_EN = 0x2
	// Position of PVT_MONITOR_SITE1_CLK_EN field.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_SITE1_CLK_EN_Pos = 0x2
	// Bit mask of PVT_MONITOR_SITE1_CLK_EN field.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_SITE1_CLK_EN_Msk = 0x4
	// Bit PVT_MONITOR_SITE1_CLK_EN.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_SITE1_CLK_EN = 0x4
	// Position of PVT_MONITOR_SITE2_CLK_EN field.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_SITE2_CLK_EN_Pos = 0x3
	// Bit mask of PVT_MONITOR_SITE2_CLK_EN field.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_SITE2_CLK_EN_Msk = 0x8
	// Bit PVT_MONITOR_SITE2_CLK_EN.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_SITE2_CLK_EN = 0x8
	// Position of PVT_MONITOR_SITE3_CLK_EN field.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_SITE3_CLK_EN_Pos = 0x4
	// Bit mask of PVT_MONITOR_SITE3_CLK_EN field.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_SITE3_CLK_EN_Msk = 0x10
	// Bit PVT_MONITOR_SITE3_CLK_EN.
	PCR_PVT_MONITOR_CONF_PVT_MONITOR_SITE3_CLK_EN = 0x10

	// PVT_MONITOR_FUNC_CLK_CONF: PVT_MONITOR function clock configuration register
	// Position of PVT_MONITOR_FUNC_CLK_DIV_NUM field.
	PCR_PVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_DIV_NUM_Pos = 0x0
	// Bit mask of PVT_MONITOR_FUNC_CLK_DIV_NUM field.
	PCR_PVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_DIV_NUM_Msk = 0xf
	// Position of PVT_MONITOR_FUNC_CLK_SEL field.
	PCR_PVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_SEL_Pos = 0x14
	// Bit mask of PVT_MONITOR_FUNC_CLK_SEL field.
	PCR_PVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_SEL_Msk = 0x100000
	// Bit PVT_MONITOR_FUNC_CLK_SEL.
	PCR_PVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_SEL = 0x100000
	// Position of PVT_MONITOR_FUNC_CLK_EN field.
	PCR_PVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_EN_Pos = 0x16
	// Bit mask of PVT_MONITOR_FUNC_CLK_EN field.
	PCR_PVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_EN_Msk = 0x400000
	// Bit PVT_MONITOR_FUNC_CLK_EN.
	PCR_PVT_MONITOR_FUNC_CLK_CONF_PVT_MONITOR_FUNC_CLK_EN = 0x400000

	// GDMA_CONF: GDMA configuration register
	// Position of GDMA_CLK_EN field.
	PCR_GDMA_CONF_GDMA_CLK_EN_Pos = 0x0
	// Bit mask of GDMA_CLK_EN field.
	PCR_GDMA_CONF_GDMA_CLK_EN_Msk = 0x1
	// Bit GDMA_CLK_EN.
	PCR_GDMA_CONF_GDMA_CLK_EN = 0x1
	// Position of GDMA_RST_EN field.
	PCR_GDMA_CONF_GDMA_RST_EN_Pos = 0x1
	// Bit mask of GDMA_RST_EN field.
	PCR_GDMA_CONF_GDMA_RST_EN_Msk = 0x2
	// Bit GDMA_RST_EN.
	PCR_GDMA_CONF_GDMA_RST_EN = 0x2

	// SPI2_CONF: SPI2 configuration register
	// Position of SPI2_CLK_EN field.
	PCR_SPI2_CONF_SPI2_CLK_EN_Pos = 0x0
	// Bit mask of SPI2_CLK_EN field.
	PCR_SPI2_CONF_SPI2_CLK_EN_Msk = 0x1
	// Bit SPI2_CLK_EN.
	PCR_SPI2_CONF_SPI2_CLK_EN = 0x1
	// Position of SPI2_RST_EN field.
	PCR_SPI2_CONF_SPI2_RST_EN_Pos = 0x1
	// Bit mask of SPI2_RST_EN field.
	PCR_SPI2_CONF_SPI2_RST_EN_Msk = 0x2
	// Bit SPI2_RST_EN.
	PCR_SPI2_CONF_SPI2_RST_EN = 0x2
	// Position of SPI2_READY field.
	PCR_SPI2_CONF_SPI2_READY_Pos = 0x2
	// Bit mask of SPI2_READY field.
	PCR_SPI2_CONF_SPI2_READY_Msk = 0x4
	// Bit SPI2_READY.
	PCR_SPI2_CONF_SPI2_READY = 0x4

	// SPI2_CLKM_CONF: SPI2_CLKM configuration register
	// Position of SPI2_CLKM_SEL field.
	PCR_SPI2_CLKM_CONF_SPI2_CLKM_SEL_Pos = 0x14
	// Bit mask of SPI2_CLKM_SEL field.
	PCR_SPI2_CLKM_CONF_SPI2_CLKM_SEL_Msk = 0x300000
	// Position of SPI2_CLKM_EN field.
	PCR_SPI2_CLKM_CONF_SPI2_CLKM_EN_Pos = 0x16
	// Bit mask of SPI2_CLKM_EN field.
	PCR_SPI2_CLKM_CONF_SPI2_CLKM_EN_Msk = 0x400000
	// Bit SPI2_CLKM_EN.
	PCR_SPI2_CLKM_CONF_SPI2_CLKM_EN = 0x400000

	// AES_CONF: AES configuration register
	// Position of AES_CLK_EN field.
	PCR_AES_CONF_AES_CLK_EN_Pos = 0x0
	// Bit mask of AES_CLK_EN field.
	PCR_AES_CONF_AES_CLK_EN_Msk = 0x1
	// Bit AES_CLK_EN.
	PCR_AES_CONF_AES_CLK_EN = 0x1
	// Position of AES_RST_EN field.
	PCR_AES_CONF_AES_RST_EN_Pos = 0x1
	// Bit mask of AES_RST_EN field.
	PCR_AES_CONF_AES_RST_EN_Msk = 0x2
	// Bit AES_RST_EN.
	PCR_AES_CONF_AES_RST_EN = 0x2
	// Position of AES_READY field.
	PCR_AES_CONF_AES_READY_Pos = 0x2
	// Bit mask of AES_READY field.
	PCR_AES_CONF_AES_READY_Msk = 0x4
	// Bit AES_READY.
	PCR_AES_CONF_AES_READY = 0x4

	// SHA_CONF: SHA configuration register
	// Position of SHA_CLK_EN field.
	PCR_SHA_CONF_SHA_CLK_EN_Pos = 0x0
	// Bit mask of SHA_CLK_EN field.
	PCR_SHA_CONF_SHA_CLK_EN_Msk = 0x1
	// Bit SHA_CLK_EN.
	PCR_SHA_CONF_SHA_CLK_EN = 0x1
	// Position of SHA_RST_EN field.
	PCR_SHA_CONF_SHA_RST_EN_Pos = 0x1
	// Bit mask of SHA_RST_EN field.
	PCR_SHA_CONF_SHA_RST_EN_Msk = 0x2
	// Bit SHA_RST_EN.
	PCR_SHA_CONF_SHA_RST_EN = 0x2
	// Position of SHA_READY field.
	PCR_SHA_CONF_SHA_READY_Pos = 0x2
	// Bit mask of SHA_READY field.
	PCR_SHA_CONF_SHA_READY_Msk = 0x4
	// Bit SHA_READY.
	PCR_SHA_CONF_SHA_READY = 0x4

	// RSA_CONF: RSA configuration register
	// Position of RSA_CLK_EN field.
	PCR_RSA_CONF_RSA_CLK_EN_Pos = 0x0
	// Bit mask of RSA_CLK_EN field.
	PCR_RSA_CONF_RSA_CLK_EN_Msk = 0x1
	// Bit RSA_CLK_EN.
	PCR_RSA_CONF_RSA_CLK_EN = 0x1
	// Position of RSA_RST_EN field.
	PCR_RSA_CONF_RSA_RST_EN_Pos = 0x1
	// Bit mask of RSA_RST_EN field.
	PCR_RSA_CONF_RSA_RST_EN_Msk = 0x2
	// Bit RSA_RST_EN.
	PCR_RSA_CONF_RSA_RST_EN = 0x2
	// Position of RSA_READY field.
	PCR_RSA_CONF_RSA_READY_Pos = 0x2
	// Bit mask of RSA_READY field.
	PCR_RSA_CONF_RSA_READY_Msk = 0x4
	// Bit RSA_READY.
	PCR_RSA_CONF_RSA_READY = 0x4

	// RSA_PD_CTRL: RSA power control register
	// Position of RSA_MEM_PD field.
	PCR_RSA_PD_CTRL_RSA_MEM_PD_Pos = 0x0
	// Bit mask of RSA_MEM_PD field.
	PCR_RSA_PD_CTRL_RSA_MEM_PD_Msk = 0x1
	// Bit RSA_MEM_PD.
	PCR_RSA_PD_CTRL_RSA_MEM_PD = 0x1
	// Position of RSA_MEM_FORCE_PU field.
	PCR_RSA_PD_CTRL_RSA_MEM_FORCE_PU_Pos = 0x1
	// Bit mask of RSA_MEM_FORCE_PU field.
	PCR_RSA_PD_CTRL_RSA_MEM_FORCE_PU_Msk = 0x2
	// Bit RSA_MEM_FORCE_PU.
	PCR_RSA_PD_CTRL_RSA_MEM_FORCE_PU = 0x2
	// Position of RSA_MEM_FORCE_PD field.
	PCR_RSA_PD_CTRL_RSA_MEM_FORCE_PD_Pos = 0x2
	// Bit mask of RSA_MEM_FORCE_PD field.
	PCR_RSA_PD_CTRL_RSA_MEM_FORCE_PD_Msk = 0x4
	// Bit RSA_MEM_FORCE_PD.
	PCR_RSA_PD_CTRL_RSA_MEM_FORCE_PD = 0x4

	// ECC_CONF: ECC configuration register
	// Position of ECC_CLK_EN field.
	PCR_ECC_CONF_ECC_CLK_EN_Pos = 0x0
	// Bit mask of ECC_CLK_EN field.
	PCR_ECC_CONF_ECC_CLK_EN_Msk = 0x1
	// Bit ECC_CLK_EN.
	PCR_ECC_CONF_ECC_CLK_EN = 0x1
	// Position of ECC_RST_EN field.
	PCR_ECC_CONF_ECC_RST_EN_Pos = 0x1
	// Bit mask of ECC_RST_EN field.
	PCR_ECC_CONF_ECC_RST_EN_Msk = 0x2
	// Bit ECC_RST_EN.
	PCR_ECC_CONF_ECC_RST_EN = 0x2
	// Position of ECC_READY field.
	PCR_ECC_CONF_ECC_READY_Pos = 0x2
	// Bit mask of ECC_READY field.
	PCR_ECC_CONF_ECC_READY_Msk = 0x4
	// Bit ECC_READY.
	PCR_ECC_CONF_ECC_READY = 0x4

	// ECC_PD_CTRL: ECC power control register
	// Position of ECC_MEM_PD field.
	PCR_ECC_PD_CTRL_ECC_MEM_PD_Pos = 0x0
	// Bit mask of ECC_MEM_PD field.
	PCR_ECC_PD_CTRL_ECC_MEM_PD_Msk = 0x1
	// Bit ECC_MEM_PD.
	PCR_ECC_PD_CTRL_ECC_MEM_PD = 0x1
	// Position of ECC_MEM_FORCE_PU field.
	PCR_ECC_PD_CTRL_ECC_MEM_FORCE_PU_Pos = 0x1
	// Bit mask of ECC_MEM_FORCE_PU field.
	PCR_ECC_PD_CTRL_ECC_MEM_FORCE_PU_Msk = 0x2
	// Bit ECC_MEM_FORCE_PU.
	PCR_ECC_PD_CTRL_ECC_MEM_FORCE_PU = 0x2
	// Position of ECC_MEM_FORCE_PD field.
	PCR_ECC_PD_CTRL_ECC_MEM_FORCE_PD_Pos = 0x2
	// Bit mask of ECC_MEM_FORCE_PD field.
	PCR_ECC_PD_CTRL_ECC_MEM_FORCE_PD_Msk = 0x4
	// Bit ECC_MEM_FORCE_PD.
	PCR_ECC_PD_CTRL_ECC_MEM_FORCE_PD = 0x4

	// DS_CONF: DS configuration register
	// Position of DS_CLK_EN field.
	PCR_DS_CONF_DS_CLK_EN_Pos = 0x0
	// Bit mask of DS_CLK_EN field.
	PCR_DS_CONF_DS_CLK_EN_Msk = 0x1
	// Bit DS_CLK_EN.
	PCR_DS_CONF_DS_CLK_EN = 0x1
	// Position of DS_RST_EN field.
	PCR_DS_CONF_DS_RST_EN_Pos = 0x1
	// Bit mask of DS_RST_EN field.
	PCR_DS_CONF_DS_RST_EN_Msk = 0x2
	// Bit DS_RST_EN.
	PCR_DS_CONF_DS_RST_EN = 0x2
	// Position of DS_READY field.
	PCR_DS_CONF_DS_READY_Pos = 0x2
	// Bit mask of DS_READY field.
	PCR_DS_CONF_DS_READY_Msk = 0x4
	// Bit DS_READY.
	PCR_DS_CONF_DS_READY = 0x4

	// HMAC_CONF: HMAC configuration register
	// Position of HMAC_CLK_EN field.
	PCR_HMAC_CONF_HMAC_CLK_EN_Pos = 0x0
	// Bit mask of HMAC_CLK_EN field.
	PCR_HMAC_CONF_HMAC_CLK_EN_Msk = 0x1
	// Bit HMAC_CLK_EN.
	PCR_HMAC_CONF_HMAC_CLK_EN = 0x1
	// Position of HMAC_RST_EN field.
	PCR_HMAC_CONF_HMAC_RST_EN_Pos = 0x1
	// Bit mask of HMAC_RST_EN field.
	PCR_HMAC_CONF_HMAC_RST_EN_Msk = 0x2
	// Bit HMAC_RST_EN.
	PCR_HMAC_CONF_HMAC_RST_EN = 0x2
	// Position of HMAC_READY field.
	PCR_HMAC_CONF_HMAC_READY_Pos = 0x2
	// Bit mask of HMAC_READY field.
	PCR_HMAC_CONF_HMAC_READY_Msk = 0x4
	// Bit HMAC_READY.
	PCR_HMAC_CONF_HMAC_READY = 0x4

	// ECDSA_CONF: ECDSA configuration register
	// Position of ECDSA_CLK_EN field.
	PCR_ECDSA_CONF_ECDSA_CLK_EN_Pos = 0x0
	// Bit mask of ECDSA_CLK_EN field.
	PCR_ECDSA_CONF_ECDSA_CLK_EN_Msk = 0x1
	// Bit ECDSA_CLK_EN.
	PCR_ECDSA_CONF_ECDSA_CLK_EN = 0x1
	// Position of ECDSA_RST_EN field.
	PCR_ECDSA_CONF_ECDSA_RST_EN_Pos = 0x1
	// Bit mask of ECDSA_RST_EN field.
	PCR_ECDSA_CONF_ECDSA_RST_EN_Msk = 0x2
	// Bit ECDSA_RST_EN.
	PCR_ECDSA_CONF_ECDSA_RST_EN = 0x2
	// Position of ECDSA_READY field.
	PCR_ECDSA_CONF_ECDSA_READY_Pos = 0x2
	// Bit mask of ECDSA_READY field.
	PCR_ECDSA_CONF_ECDSA_READY_Msk = 0x4
	// Bit ECDSA_READY.
	PCR_ECDSA_CONF_ECDSA_READY = 0x4

	// IOMUX_CONF: IOMUX configuration register
	// Position of IOMUX_CLK_EN field.
	PCR_IOMUX_CONF_IOMUX_CLK_EN_Pos = 0x0
	// Bit mask of IOMUX_CLK_EN field.
	PCR_IOMUX_CONF_IOMUX_CLK_EN_Msk = 0x1
	// Bit IOMUX_CLK_EN.
	PCR_IOMUX_CONF_IOMUX_CLK_EN = 0x1
	// Position of IOMUX_RST_EN field.
	PCR_IOMUX_CONF_IOMUX_RST_EN_Pos = 0x1
	// Bit mask of IOMUX_RST_EN field.
	PCR_IOMUX_CONF_IOMUX_RST_EN_Msk = 0x2
	// Bit IOMUX_RST_EN.
	PCR_IOMUX_CONF_IOMUX_RST_EN = 0x2

	// IOMUX_CLK_CONF: IOMUX_CLK configuration register
	// Position of IOMUX_FUNC_CLK_SEL field.
	PCR_IOMUX_CLK_CONF_IOMUX_FUNC_CLK_SEL_Pos = 0x14
	// Bit mask of IOMUX_FUNC_CLK_SEL field.
	PCR_IOMUX_CLK_CONF_IOMUX_FUNC_CLK_SEL_Msk = 0x300000
	// Position of IOMUX_FUNC_CLK_EN field.
	PCR_IOMUX_CLK_CONF_IOMUX_FUNC_CLK_EN_Pos = 0x16
	// Bit mask of IOMUX_FUNC_CLK_EN field.
	PCR_IOMUX_CLK_CONF_IOMUX_FUNC_CLK_EN_Msk = 0x400000
	// Bit IOMUX_FUNC_CLK_EN.
	PCR_IOMUX_CLK_CONF_IOMUX_FUNC_CLK_EN = 0x400000

	// MEM_MONITOR_CONF: MEM_MONITOR configuration register
	// Position of MEM_MONITOR_CLK_EN field.
	PCR_MEM_MONITOR_CONF_MEM_MONITOR_CLK_EN_Pos = 0x0
	// Bit mask of MEM_MONITOR_CLK_EN field.
	PCR_MEM_MONITOR_CONF_MEM_MONITOR_CLK_EN_Msk = 0x1
	// Bit MEM_MONITOR_CLK_EN.
	PCR_MEM_MONITOR_CONF_MEM_MONITOR_CLK_EN = 0x1
	// Position of MEM_MONITOR_RST_EN field.
	PCR_MEM_MONITOR_CONF_MEM_MONITOR_RST_EN_Pos = 0x1
	// Bit mask of MEM_MONITOR_RST_EN field.
	PCR_MEM_MONITOR_CONF_MEM_MONITOR_RST_EN_Msk = 0x2
	// Bit MEM_MONITOR_RST_EN.
	PCR_MEM_MONITOR_CONF_MEM_MONITOR_RST_EN = 0x2
	// Position of MEM_MONITOR_READY field.
	PCR_MEM_MONITOR_CONF_MEM_MONITOR_READY_Pos = 0x2
	// Bit mask of MEM_MONITOR_READY field.
	PCR_MEM_MONITOR_CONF_MEM_MONITOR_READY_Msk = 0x4
	// Bit MEM_MONITOR_READY.
	PCR_MEM_MONITOR_CONF_MEM_MONITOR_READY = 0x4

	// REGDMA_CONF: REGDMA configuration register
	// Position of REGDMA_CLK_EN field.
	PCR_REGDMA_CONF_REGDMA_CLK_EN_Pos = 0x0
	// Bit mask of REGDMA_CLK_EN field.
	PCR_REGDMA_CONF_REGDMA_CLK_EN_Msk = 0x1
	// Bit REGDMA_CLK_EN.
	PCR_REGDMA_CONF_REGDMA_CLK_EN = 0x1
	// Position of REGDMA_RST_EN field.
	PCR_REGDMA_CONF_REGDMA_RST_EN_Pos = 0x1
	// Bit mask of REGDMA_RST_EN field.
	PCR_REGDMA_CONF_REGDMA_RST_EN_Msk = 0x2
	// Bit REGDMA_RST_EN.
	PCR_REGDMA_CONF_REGDMA_RST_EN = 0x2

	// TRACE_CONF: TRACE configuration register
	// Position of TRACE_CLK_EN field.
	PCR_TRACE_CONF_TRACE_CLK_EN_Pos = 0x0
	// Bit mask of TRACE_CLK_EN field.
	PCR_TRACE_CONF_TRACE_CLK_EN_Msk = 0x1
	// Bit TRACE_CLK_EN.
	PCR_TRACE_CONF_TRACE_CLK_EN = 0x1
	// Position of TRACE_RST_EN field.
	PCR_TRACE_CONF_TRACE_RST_EN_Pos = 0x1
	// Bit mask of TRACE_RST_EN field.
	PCR_TRACE_CONF_TRACE_RST_EN_Msk = 0x2
	// Bit TRACE_RST_EN.
	PCR_TRACE_CONF_TRACE_RST_EN = 0x2

	// ASSIST_CONF: ASSIST configuration register
	// Position of ASSIST_CLK_EN field.
	PCR_ASSIST_CONF_ASSIST_CLK_EN_Pos = 0x0
	// Bit mask of ASSIST_CLK_EN field.
	PCR_ASSIST_CONF_ASSIST_CLK_EN_Msk = 0x1
	// Bit ASSIST_CLK_EN.
	PCR_ASSIST_CONF_ASSIST_CLK_EN = 0x1
	// Position of ASSIST_RST_EN field.
	PCR_ASSIST_CONF_ASSIST_RST_EN_Pos = 0x1
	// Bit mask of ASSIST_RST_EN field.
	PCR_ASSIST_CONF_ASSIST_RST_EN_Msk = 0x2
	// Bit ASSIST_RST_EN.
	PCR_ASSIST_CONF_ASSIST_RST_EN = 0x2

	// CACHE_CONF: CACHE configuration register
	// Position of CACHE_CLK_EN field.
	PCR_CACHE_CONF_CACHE_CLK_EN_Pos = 0x0
	// Bit mask of CACHE_CLK_EN field.
	PCR_CACHE_CONF_CACHE_CLK_EN_Msk = 0x1
	// Bit CACHE_CLK_EN.
	PCR_CACHE_CONF_CACHE_CLK_EN = 0x1
	// Position of CACHE_RST_EN field.
	PCR_CACHE_CONF_CACHE_RST_EN_Pos = 0x1
	// Bit mask of CACHE_RST_EN field.
	PCR_CACHE_CONF_CACHE_RST_EN_Msk = 0x2
	// Bit CACHE_RST_EN.
	PCR_CACHE_CONF_CACHE_RST_EN = 0x2

	// MODEM_CONF: MODEM_APB configuration register
	// Position of MODEM_CLK_SEL field.
	PCR_MODEM_CONF_MODEM_CLK_SEL_Pos = 0x0
	// Bit mask of MODEM_CLK_SEL field.
	PCR_MODEM_CONF_MODEM_CLK_SEL_Msk = 0x1
	// Bit MODEM_CLK_SEL.
	PCR_MODEM_CONF_MODEM_CLK_SEL = 0x1
	// Position of MODEM_CLK_EN field.
	PCR_MODEM_CONF_MODEM_CLK_EN_Pos = 0x1
	// Bit mask of MODEM_CLK_EN field.
	PCR_MODEM_CONF_MODEM_CLK_EN_Msk = 0x2
	// Bit MODEM_CLK_EN.
	PCR_MODEM_CONF_MODEM_CLK_EN = 0x2
	// Position of MODEM_RST_EN field.
	PCR_MODEM_CONF_MODEM_RST_EN_Pos = 0x2
	// Bit mask of MODEM_RST_EN field.
	PCR_MODEM_CONF_MODEM_RST_EN_Msk = 0x4
	// Bit MODEM_RST_EN.
	PCR_MODEM_CONF_MODEM_RST_EN = 0x4

	// TIMEOUT_CONF: TIMEOUT configuration register
	// Position of CPU_TIMEOUT_RST_EN field.
	PCR_TIMEOUT_CONF_CPU_TIMEOUT_RST_EN_Pos = 0x1
	// Bit mask of CPU_TIMEOUT_RST_EN field.
	PCR_TIMEOUT_CONF_CPU_TIMEOUT_RST_EN_Msk = 0x2
	// Bit CPU_TIMEOUT_RST_EN.
	PCR_TIMEOUT_CONF_CPU_TIMEOUT_RST_EN = 0x2
	// Position of HP_TIMEOUT_RST_EN field.
	PCR_TIMEOUT_CONF_HP_TIMEOUT_RST_EN_Pos = 0x2
	// Bit mask of HP_TIMEOUT_RST_EN field.
	PCR_TIMEOUT_CONF_HP_TIMEOUT_RST_EN_Msk = 0x4
	// Bit HP_TIMEOUT_RST_EN.
	PCR_TIMEOUT_CONF_HP_TIMEOUT_RST_EN = 0x4

	// SYSCLK_CONF: SYSCLK configuration register
	// Position of LS_DIV_NUM field.
	PCR_SYSCLK_CONF_LS_DIV_NUM_Pos = 0x0
	// Bit mask of LS_DIV_NUM field.
	PCR_SYSCLK_CONF_LS_DIV_NUM_Msk = 0xff
	// Position of HS_DIV_NUM field.
	PCR_SYSCLK_CONF_HS_DIV_NUM_Pos = 0x8
	// Bit mask of HS_DIV_NUM field.
	PCR_SYSCLK_CONF_HS_DIV_NUM_Msk = 0xff00
	// Position of SOC_CLK_SEL field.
	PCR_SYSCLK_CONF_SOC_CLK_SEL_Pos = 0x10
	// Bit mask of SOC_CLK_SEL field.
	PCR_SYSCLK_CONF_SOC_CLK_SEL_Msk = 0x30000
	// Position of CLK_XTAL_FREQ field.
	PCR_SYSCLK_CONF_CLK_XTAL_FREQ_Pos = 0x18
	// Bit mask of CLK_XTAL_FREQ field.
	PCR_SYSCLK_CONF_CLK_XTAL_FREQ_Msk = 0x7f000000

	// CPU_WAITI_CONF: CPU_WAITI configuration register
	// Position of CPUPERIOD_SEL field.
	PCR_CPU_WAITI_CONF_CPUPERIOD_SEL_Pos = 0x0
	// Bit mask of CPUPERIOD_SEL field.
	PCR_CPU_WAITI_CONF_CPUPERIOD_SEL_Msk = 0x3
	// Position of PLL_FREQ_SEL field.
	PCR_CPU_WAITI_CONF_PLL_FREQ_SEL_Pos = 0x2
	// Bit mask of PLL_FREQ_SEL field.
	PCR_CPU_WAITI_CONF_PLL_FREQ_SEL_Msk = 0x4
	// Bit PLL_FREQ_SEL.
	PCR_CPU_WAITI_CONF_PLL_FREQ_SEL = 0x4
	// Position of CPU_WAIT_MODE_FORCE_ON field.
	PCR_CPU_WAITI_CONF_CPU_WAIT_MODE_FORCE_ON_Pos = 0x3
	// Bit mask of CPU_WAIT_MODE_FORCE_ON field.
	PCR_CPU_WAITI_CONF_CPU_WAIT_MODE_FORCE_ON_Msk = 0x8
	// Bit CPU_WAIT_MODE_FORCE_ON.
	PCR_CPU_WAITI_CONF_CPU_WAIT_MODE_FORCE_ON = 0x8
	// Position of CPU_WAITI_DELAY_NUM field.
	PCR_CPU_WAITI_CONF_CPU_WAITI_DELAY_NUM_Pos = 0x4
	// Bit mask of CPU_WAITI_DELAY_NUM field.
	PCR_CPU_WAITI_CONF_CPU_WAITI_DELAY_NUM_Msk = 0xf0

	// CPU_FREQ_CONF: CPU_FREQ configuration register
	// Position of CPU_DIV_NUM field.
	PCR_CPU_FREQ_CONF_CPU_DIV_NUM_Pos = 0x0
	// Bit mask of CPU_DIV_NUM field.
	PCR_CPU_FREQ_CONF_CPU_DIV_NUM_Msk = 0xff

	// AHB_FREQ_CONF: AHB_FREQ configuration register
	// Position of AHB_DIV_NUM field.
	PCR_AHB_FREQ_CONF_AHB_DIV_NUM_Pos = 0x0
	// Bit mask of AHB_DIV_NUM field.
	PCR_AHB_FREQ_CONF_AHB_DIV_NUM_Msk = 0xff

	// APB_FREQ_CONF: APB_FREQ configuration register
	// Position of APB_DECREASE_DIV_NUM field.
	PCR_APB_FREQ_CONF_APB_DECREASE_DIV_NUM_Pos = 0x0
	// Bit mask of APB_DECREASE_DIV_NUM field.
	PCR_APB_FREQ_CONF_APB_DECREASE_DIV_NUM_Msk = 0xff
	// Position of APB_DIV_NUM field.
	PCR_APB_FREQ_CONF_APB_DIV_NUM_Pos = 0x8
	// Bit mask of APB_DIV_NUM field.
	PCR_APB_FREQ_CONF_APB_DIV_NUM_Msk = 0xff00

	// SYSCLK_FREQ_QUERY_0: SYSCLK frequency query 0 register
	// Position of FOSC_FREQ field.
	PCR_SYSCLK_FREQ_QUERY_0_FOSC_FREQ_Pos = 0x0
	// Bit mask of FOSC_FREQ field.
	PCR_SYSCLK_FREQ_QUERY_0_FOSC_FREQ_Msk = 0xff
	// Position of PLL_FREQ field.
	PCR_SYSCLK_FREQ_QUERY_0_PLL_FREQ_Pos = 0x8
	// Bit mask of PLL_FREQ field.
	PCR_SYSCLK_FREQ_QUERY_0_PLL_FREQ_Msk = 0x3ff00

	// PLL_DIV_CLK_EN: SPLL DIV clock-gating configuration register
	// Position of PLL_240M_CLK_EN field.
	PCR_PLL_DIV_CLK_EN_PLL_240M_CLK_EN_Pos = 0x0
	// Bit mask of PLL_240M_CLK_EN field.
	PCR_PLL_DIV_CLK_EN_PLL_240M_CLK_EN_Msk = 0x1
	// Bit PLL_240M_CLK_EN.
	PCR_PLL_DIV_CLK_EN_PLL_240M_CLK_EN = 0x1
	// Position of PLL_160M_CLK_EN field.
	PCR_PLL_DIV_CLK_EN_PLL_160M_CLK_EN_Pos = 0x1
	// Bit mask of PLL_160M_CLK_EN field.
	PCR_PLL_DIV_CLK_EN_PLL_160M_CLK_EN_Msk = 0x2
	// Bit PLL_160M_CLK_EN.
	PCR_PLL_DIV_CLK_EN_PLL_160M_CLK_EN = 0x2
	// Position of PLL_120M_CLK_EN field.
	PCR_PLL_DIV_CLK_EN_PLL_120M_CLK_EN_Pos = 0x2
	// Bit mask of PLL_120M_CLK_EN field.
	PCR_PLL_DIV_CLK_EN_PLL_120M_CLK_EN_Msk = 0x4
	// Bit PLL_120M_CLK_EN.
	PCR_PLL_DIV_CLK_EN_PLL_120M_CLK_EN = 0x4
	// Position of PLL_80M_CLK_EN field.
	PCR_PLL_DIV_CLK_EN_PLL_80M_CLK_EN_Pos = 0x3
	// Bit mask of PLL_80M_CLK_EN field.
	PCR_PLL_DIV_CLK_EN_PLL_80M_CLK_EN_Msk = 0x8
	// Bit PLL_80M_CLK_EN.
	PCR_PLL_DIV_CLK_EN_PLL_80M_CLK_EN = 0x8
	// Position of PLL_48M_CLK_EN field.
	PCR_PLL_DIV_CLK_EN_PLL_48M_CLK_EN_Pos = 0x4
	// Bit mask of PLL_48M_CLK_EN field.
	PCR_PLL_DIV_CLK_EN_PLL_48M_CLK_EN_Msk = 0x10
	// Bit PLL_48M_CLK_EN.
	PCR_PLL_DIV_CLK_EN_PLL_48M_CLK_EN = 0x10
	// Position of PLL_40M_CLK_EN field.
	PCR_PLL_DIV_CLK_EN_PLL_40M_CLK_EN_Pos = 0x5
	// Bit mask of PLL_40M_CLK_EN field.
	PCR_PLL_DIV_CLK_EN_PLL_40M_CLK_EN_Msk = 0x20
	// Bit PLL_40M_CLK_EN.
	PCR_PLL_DIV_CLK_EN_PLL_40M_CLK_EN = 0x20

	// CTRL_CLK_OUT_EN: CLK_OUT_EN configuration register
	// Position of CLK8_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK8_OEN_Pos = 0x0
	// Bit mask of CLK8_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK8_OEN_Msk = 0x1
	// Bit CLK8_OEN.
	PCR_CTRL_CLK_OUT_EN_CLK8_OEN = 0x1
	// Position of CLK16_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK16_OEN_Pos = 0x1
	// Bit mask of CLK16_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK16_OEN_Msk = 0x2
	// Bit CLK16_OEN.
	PCR_CTRL_CLK_OUT_EN_CLK16_OEN = 0x2
	// Position of CLK32_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK32_OEN_Pos = 0x2
	// Bit mask of CLK32_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK32_OEN_Msk = 0x4
	// Bit CLK32_OEN.
	PCR_CTRL_CLK_OUT_EN_CLK32_OEN = 0x4
	// Position of CLK_ADC_INF_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK_ADC_INF_OEN_Pos = 0x3
	// Bit mask of CLK_ADC_INF_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK_ADC_INF_OEN_Msk = 0x8
	// Bit CLK_ADC_INF_OEN.
	PCR_CTRL_CLK_OUT_EN_CLK_ADC_INF_OEN = 0x8
	// Position of CLK_DFM_INF_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK_DFM_INF_OEN_Pos = 0x4
	// Bit mask of CLK_DFM_INF_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK_DFM_INF_OEN_Msk = 0x10
	// Bit CLK_DFM_INF_OEN.
	PCR_CTRL_CLK_OUT_EN_CLK_DFM_INF_OEN = 0x10
	// Position of CLK_SDM_MOD_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK_SDM_MOD_OEN_Pos = 0x5
	// Bit mask of CLK_SDM_MOD_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK_SDM_MOD_OEN_Msk = 0x20
	// Bit CLK_SDM_MOD_OEN.
	PCR_CTRL_CLK_OUT_EN_CLK_SDM_MOD_OEN = 0x20
	// Position of CLK_XTAL_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK_XTAL_OEN_Pos = 0x6
	// Bit mask of CLK_XTAL_OEN field.
	PCR_CTRL_CLK_OUT_EN_CLK_XTAL_OEN_Msk = 0x40
	// Bit CLK_XTAL_OEN.
	PCR_CTRL_CLK_OUT_EN_CLK_XTAL_OEN = 0x40

	// CTRL_TICK_CONF: TICK configuration register
	// Position of XTAL_TICK_NUM field.
	PCR_CTRL_TICK_CONF_XTAL_TICK_NUM_Pos = 0x0
	// Bit mask of XTAL_TICK_NUM field.
	PCR_CTRL_TICK_CONF_XTAL_TICK_NUM_Msk = 0xff
	// Position of FOSC_TICK_NUM field.
	PCR_CTRL_TICK_CONF_FOSC_TICK_NUM_Pos = 0x8
	// Bit mask of FOSC_TICK_NUM field.
	PCR_CTRL_TICK_CONF_FOSC_TICK_NUM_Msk = 0xff00
	// Position of TICK_ENABLE field.
	PCR_CTRL_TICK_CONF_TICK_ENABLE_Pos = 0x10
	// Bit mask of TICK_ENABLE field.
	PCR_CTRL_TICK_CONF_TICK_ENABLE_Msk = 0x10000
	// Bit TICK_ENABLE.
	PCR_CTRL_TICK_CONF_TICK_ENABLE = 0x10000
	// Position of RST_TICK_CNT field.
	PCR_CTRL_TICK_CONF_RST_TICK_CNT_Pos = 0x11
	// Bit mask of RST_TICK_CNT field.
	PCR_CTRL_TICK_CONF_RST_TICK_CNT_Msk = 0x20000
	// Bit RST_TICK_CNT.
	PCR_CTRL_TICK_CONF_RST_TICK_CNT = 0x20000

	// CTRL_32K_CONF: 32KHz clock configuration register
	// Position of CLK_32K_SEL field.
	PCR_CTRL_32K_CONF_CLK_32K_SEL_Pos = 0x0
	// Bit mask of CLK_32K_SEL field.
	PCR_CTRL_32K_CONF_CLK_32K_SEL_Msk = 0x3
	// Position of _32K_MODEM_SEL field.
	PCR_CTRL_32K_CONF__32K_MODEM_SEL_Pos = 0x2
	// Bit mask of _32K_MODEM_SEL field.
	PCR_CTRL_32K_CONF__32K_MODEM_SEL_Msk = 0xc

	// SRAM_POWER_CONF_0: HP SRAM/ROM configuration register
	// Position of ROM_FORCE_PU field.
	PCR_SRAM_POWER_CONF_0_ROM_FORCE_PU_Pos = 0xd
	// Bit mask of ROM_FORCE_PU field.
	PCR_SRAM_POWER_CONF_0_ROM_FORCE_PU_Msk = 0x6000
	// Position of ROM_FORCE_PD field.
	PCR_SRAM_POWER_CONF_0_ROM_FORCE_PD_Pos = 0xf
	// Bit mask of ROM_FORCE_PD field.
	PCR_SRAM_POWER_CONF_0_ROM_FORCE_PD_Msk = 0x18000
	// Position of ROM_CLKGATE_FORCE_ON field.
	PCR_SRAM_POWER_CONF_0_ROM_CLKGATE_FORCE_ON_Pos = 0x11
	// Bit mask of ROM_CLKGATE_FORCE_ON field.
	PCR_SRAM_POWER_CONF_0_ROM_CLKGATE_FORCE_ON_Msk = 0x60000

	// SRAM_POWER_CONF_1: HP SRAM/ROM configuration register
	// Position of SRAM_FORCE_PU field.
	PCR_SRAM_POWER_CONF_1_SRAM_FORCE_PU_Pos = 0x0
	// Bit mask of SRAM_FORCE_PU field.
	PCR_SRAM_POWER_CONF_1_SRAM_FORCE_PU_Msk = 0x1f
	// Position of SRAM_FORCE_PD field.
	PCR_SRAM_POWER_CONF_1_SRAM_FORCE_PD_Pos = 0xa
	// Bit mask of SRAM_FORCE_PD field.
	PCR_SRAM_POWER_CONF_1_SRAM_FORCE_PD_Msk = 0x7c00
	// Position of SRAM_CLKGATE_FORCE_ON field.
	PCR_SRAM_POWER_CONF_1_SRAM_CLKGATE_FORCE_ON_Pos = 0x19
	// Bit mask of SRAM_CLKGATE_FORCE_ON field.
	PCR_SRAM_POWER_CONF_1_SRAM_CLKGATE_FORCE_ON_Msk = 0x3e000000

	// SEC_CONF: xxxx
	// Position of SEC_CLK_SEL field.
	PCR_SEC_CONF_SEC_CLK_SEL_Pos = 0x0
	// Bit mask of SEC_CLK_SEL field.
	PCR_SEC_CONF_SEC_CLK_SEL_Msk = 0x3

	// ADC_INV_PHASE_CONF: xxxx
	// Position of CLK_ADC_INV_PHASE_ENA field.
	PCR_ADC_INV_PHASE_CONF_CLK_ADC_INV_PHASE_ENA_Pos = 0x0
	// Bit mask of CLK_ADC_INV_PHASE_ENA field.
	PCR_ADC_INV_PHASE_CONF_CLK_ADC_INV_PHASE_ENA_Msk = 0x1
	// Bit CLK_ADC_INV_PHASE_ENA.
	PCR_ADC_INV_PHASE_CONF_CLK_ADC_INV_PHASE_ENA = 0x1

	// SDM_INV_PHASE_CONF: xxxx
	// Position of CLK_SDM_INV_PHASE_ENA field.
	PCR_SDM_INV_PHASE_CONF_CLK_SDM_INV_PHASE_ENA_Pos = 0x0
	// Bit mask of CLK_SDM_INV_PHASE_ENA field.
	PCR_SDM_INV_PHASE_CONF_CLK_SDM_INV_PHASE_ENA_Msk = 0x1
	// Bit CLK_SDM_INV_PHASE_ENA.
	PCR_SDM_INV_PHASE_CONF_CLK_SDM_INV_PHASE_ENA = 0x1
	// Position of CLK_SDM_INV_PHASE_SEL field.
	PCR_SDM_INV_PHASE_CONF_CLK_SDM_INV_PHASE_SEL_Pos = 0x1
	// Bit mask of CLK_SDM_INV_PHASE_SEL field.
	PCR_SDM_INV_PHASE_CONF_CLK_SDM_INV_PHASE_SEL_Msk = 0xe

	// BUS_CLK_UPDATE: xxxx
	// Position of BUS_CLOCK_UPDATE field.
	PCR_BUS_CLK_UPDATE_BUS_CLOCK_UPDATE_Pos = 0x0
	// Bit mask of BUS_CLOCK_UPDATE field.
	PCR_BUS_CLK_UPDATE_BUS_CLOCK_UPDATE_Msk = 0x1
	// Bit BUS_CLOCK_UPDATE.
	PCR_BUS_CLK_UPDATE_BUS_CLOCK_UPDATE = 0x1

	// SAR_CLK_DIV: xxxx
	// Position of SAR2_CLK_DIV_NUM field.
	PCR_SAR_CLK_DIV_SAR2_CLK_DIV_NUM_Pos = 0x0
	// Bit mask of SAR2_CLK_DIV_NUM field.
	PCR_SAR_CLK_DIV_SAR2_CLK_DIV_NUM_Msk = 0xff
	// Position of SAR1_CLK_DIV_NUM field.
	PCR_SAR_CLK_DIV_SAR1_CLK_DIV_NUM_Pos = 0x8
	// Bit mask of SAR1_CLK_DIV_NUM field.
	PCR_SAR_CLK_DIV_SAR1_CLK_DIV_NUM_Msk = 0xff00

	// PWDET_SAR_CLK_CONF: xxxx
	// Position of PWDET_SAR_CLK_DIV_NUM field.
	PCR_PWDET_SAR_CLK_CONF_PWDET_SAR_CLK_DIV_NUM_Pos = 0x0
	// Bit mask of PWDET_SAR_CLK_DIV_NUM field.
	PCR_PWDET_SAR_CLK_CONF_PWDET_SAR_CLK_DIV_NUM_Msk = 0xff
	// Position of PWDET_SAR_READER_EN field.
	PCR_PWDET_SAR_CLK_CONF_PWDET_SAR_READER_EN_Pos = 0x8
	// Bit mask of PWDET_SAR_READER_EN field.
	PCR_PWDET_SAR_CLK_CONF_PWDET_SAR_READER_EN_Msk = 0x100
	// Bit PWDET_SAR_READER_EN.
	PCR_PWDET_SAR_CLK_CONF_PWDET_SAR_READER_EN = 0x100

	// RESET_EVENT_BYPASS: reset event bypass backdoor configuration register
	// Position of APM field.
	PCR_RESET_EVENT_BYPASS_APM_Pos = 0x0
	// Bit mask of APM field.
	PCR_RESET_EVENT_BYPASS_APM_Msk = 0x1
	// Bit APM.
	PCR_RESET_EVENT_BYPASS_APM = 0x1
	// Position of RESET_EVENT_BYPASS field.
	PCR_RESET_EVENT_BYPASS_RESET_EVENT_BYPASS_Pos = 0x1
	// Bit mask of RESET_EVENT_BYPASS field.
	PCR_RESET_EVENT_BYPASS_RESET_EVENT_BYPASS_Msk = 0x2
	// Bit RESET_EVENT_BYPASS.
	PCR_RESET_EVENT_BYPASS_RESET_EVENT_BYPASS = 0x2

	// FPGA_DEBUG: fpga debug register
	// Position of FPGA_DEBUG field.
	PCR_FPGA_DEBUG_FPGA_DEBUG_Pos = 0x0
	// Bit mask of FPGA_DEBUG field.
	PCR_FPGA_DEBUG_FPGA_DEBUG_Msk = 0xffffffff

	// CLOCK_GATE: PCR clock gating configure register
	// Position of CLK_EN field.
	PCR_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	PCR_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	PCR_CLOCK_GATE_CLK_EN = 0x1

	// DATE: Date register.
	// Position of DATE field.
	PCR_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	PCR_DATE_DATE_Msk = 0xfffffff
)

// Constants for PMU: PMU Peripheral
const (
	// HP_ACTIVE_DIG_POWER: need_des
	// Position of HP_ACTIVE_VDD_SPI_PD_EN field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_VDD_SPI_PD_EN_Pos = 0x15
	// Bit mask of HP_ACTIVE_VDD_SPI_PD_EN field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_VDD_SPI_PD_EN_Msk = 0x200000
	// Bit HP_ACTIVE_VDD_SPI_PD_EN.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_VDD_SPI_PD_EN = 0x200000
	// Position of HP_ACTIVE_HP_MEM_DSLP field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_HP_MEM_DSLP_Pos = 0x16
	// Bit mask of HP_ACTIVE_HP_MEM_DSLP field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_HP_MEM_DSLP_Msk = 0x400000
	// Bit HP_ACTIVE_HP_MEM_DSLP.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_HP_MEM_DSLP = 0x400000
	// Position of HP_ACTIVE_PD_HP_MEM_PD_EN field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_MEM_PD_EN_Pos = 0x17
	// Bit mask of HP_ACTIVE_PD_HP_MEM_PD_EN field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_MEM_PD_EN_Msk = 0x7800000
	// Position of HP_ACTIVE_PD_HP_WIFI_PD_EN field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_WIFI_PD_EN_Pos = 0x1b
	// Bit mask of HP_ACTIVE_PD_HP_WIFI_PD_EN field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_WIFI_PD_EN_Msk = 0x8000000
	// Bit HP_ACTIVE_PD_HP_WIFI_PD_EN.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_WIFI_PD_EN = 0x8000000
	// Position of HP_ACTIVE_PD_HP_CPU_PD_EN field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_CPU_PD_EN_Pos = 0x1d
	// Bit mask of HP_ACTIVE_PD_HP_CPU_PD_EN field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_CPU_PD_EN_Msk = 0x20000000
	// Bit HP_ACTIVE_PD_HP_CPU_PD_EN.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_CPU_PD_EN = 0x20000000
	// Position of HP_ACTIVE_PD_HP_AON_PD_EN field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_AON_PD_EN_Pos = 0x1e
	// Bit mask of HP_ACTIVE_PD_HP_AON_PD_EN field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_AON_PD_EN_Msk = 0x40000000
	// Bit HP_ACTIVE_PD_HP_AON_PD_EN.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_HP_AON_PD_EN = 0x40000000
	// Position of HP_ACTIVE_PD_TOP_PD_EN field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_TOP_PD_EN_Pos = 0x1f
	// Bit mask of HP_ACTIVE_PD_TOP_PD_EN field.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_TOP_PD_EN_Msk = 0x80000000
	// Bit HP_ACTIVE_PD_TOP_PD_EN.
	PMU_HP_ACTIVE_DIG_POWER_HP_ACTIVE_PD_TOP_PD_EN = 0x80000000

	// HP_ACTIVE_ICG_HP_FUNC: need_des
	// Position of HP_ACTIVE_DIG_ICG_FUNC_EN field.
	PMU_HP_ACTIVE_ICG_HP_FUNC_HP_ACTIVE_DIG_ICG_FUNC_EN_Pos = 0x0
	// Bit mask of HP_ACTIVE_DIG_ICG_FUNC_EN field.
	PMU_HP_ACTIVE_ICG_HP_FUNC_HP_ACTIVE_DIG_ICG_FUNC_EN_Msk = 0xffffffff

	// HP_ACTIVE_ICG_HP_APB: need_des
	// Position of HP_ACTIVE_DIG_ICG_APB_EN field.
	PMU_HP_ACTIVE_ICG_HP_APB_HP_ACTIVE_DIG_ICG_APB_EN_Pos = 0x0
	// Bit mask of HP_ACTIVE_DIG_ICG_APB_EN field.
	PMU_HP_ACTIVE_ICG_HP_APB_HP_ACTIVE_DIG_ICG_APB_EN_Msk = 0xffffffff

	// HP_ACTIVE_ICG_MODEM: need_des
	// Position of HP_ACTIVE_DIG_ICG_MODEM_CODE field.
	PMU_HP_ACTIVE_ICG_MODEM_HP_ACTIVE_DIG_ICG_MODEM_CODE_Pos = 0x1e
	// Bit mask of HP_ACTIVE_DIG_ICG_MODEM_CODE field.
	PMU_HP_ACTIVE_ICG_MODEM_HP_ACTIVE_DIG_ICG_MODEM_CODE_Msk = 0xc0000000

	// HP_ACTIVE_HP_SYS_CNTL: need_des
	// Position of HP_ACTIVE_UART_WAKEUP_EN field.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_UART_WAKEUP_EN_Pos = 0x18
	// Bit mask of HP_ACTIVE_UART_WAKEUP_EN field.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_UART_WAKEUP_EN_Msk = 0x1000000
	// Bit HP_ACTIVE_UART_WAKEUP_EN.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_UART_WAKEUP_EN = 0x1000000
	// Position of HP_ACTIVE_LP_PAD_HOLD_ALL field.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_LP_PAD_HOLD_ALL_Pos = 0x19
	// Bit mask of HP_ACTIVE_LP_PAD_HOLD_ALL field.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_LP_PAD_HOLD_ALL_Msk = 0x2000000
	// Bit HP_ACTIVE_LP_PAD_HOLD_ALL.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_LP_PAD_HOLD_ALL = 0x2000000
	// Position of HP_ACTIVE_HP_PAD_HOLD_ALL field.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_HP_PAD_HOLD_ALL_Pos = 0x1a
	// Bit mask of HP_ACTIVE_HP_PAD_HOLD_ALL field.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_HP_PAD_HOLD_ALL_Msk = 0x4000000
	// Bit HP_ACTIVE_HP_PAD_HOLD_ALL.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_HP_PAD_HOLD_ALL = 0x4000000
	// Position of HP_ACTIVE_DIG_PAD_SLP_SEL field.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_PAD_SLP_SEL_Pos = 0x1b
	// Bit mask of HP_ACTIVE_DIG_PAD_SLP_SEL field.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_PAD_SLP_SEL_Msk = 0x8000000
	// Bit HP_ACTIVE_DIG_PAD_SLP_SEL.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_PAD_SLP_SEL = 0x8000000
	// Position of HP_ACTIVE_DIG_PAUSE_WDT field.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_PAUSE_WDT_Pos = 0x1c
	// Bit mask of HP_ACTIVE_DIG_PAUSE_WDT field.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_PAUSE_WDT_Msk = 0x10000000
	// Bit HP_ACTIVE_DIG_PAUSE_WDT.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_PAUSE_WDT = 0x10000000
	// Position of HP_ACTIVE_DIG_CPU_STALL field.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_CPU_STALL_Pos = 0x1d
	// Bit mask of HP_ACTIVE_DIG_CPU_STALL field.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_CPU_STALL_Msk = 0x20000000
	// Bit HP_ACTIVE_DIG_CPU_STALL.
	PMU_HP_ACTIVE_HP_SYS_CNTL_HP_ACTIVE_DIG_CPU_STALL = 0x20000000

	// HP_ACTIVE_HP_CK_POWER: need_des
	// Position of HP_ACTIVE_I2C_ISO_EN field.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_I2C_ISO_EN_Pos = 0x1a
	// Bit mask of HP_ACTIVE_I2C_ISO_EN field.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_I2C_ISO_EN_Msk = 0x4000000
	// Bit HP_ACTIVE_I2C_ISO_EN.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_I2C_ISO_EN = 0x4000000
	// Position of HP_ACTIVE_I2C_RETENTION field.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_I2C_RETENTION_Pos = 0x1b
	// Bit mask of HP_ACTIVE_I2C_RETENTION field.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_I2C_RETENTION_Msk = 0x8000000
	// Bit HP_ACTIVE_I2C_RETENTION.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_I2C_RETENTION = 0x8000000
	// Position of HP_ACTIVE_XPD_BB_I2C field.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BB_I2C_Pos = 0x1c
	// Bit mask of HP_ACTIVE_XPD_BB_I2C field.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BB_I2C_Msk = 0x10000000
	// Bit HP_ACTIVE_XPD_BB_I2C.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BB_I2C = 0x10000000
	// Position of HP_ACTIVE_XPD_BBPLL_I2C field.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BBPLL_I2C_Pos = 0x1d
	// Bit mask of HP_ACTIVE_XPD_BBPLL_I2C field.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BBPLL_I2C_Msk = 0x20000000
	// Bit HP_ACTIVE_XPD_BBPLL_I2C.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BBPLL_I2C = 0x20000000
	// Position of HP_ACTIVE_XPD_BBPLL field.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BBPLL_Pos = 0x1e
	// Bit mask of HP_ACTIVE_XPD_BBPLL field.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BBPLL_Msk = 0x40000000
	// Bit HP_ACTIVE_XPD_BBPLL.
	PMU_HP_ACTIVE_HP_CK_POWER_HP_ACTIVE_XPD_BBPLL = 0x40000000

	// HP_ACTIVE_BIAS: need_des
	// Position of HP_ACTIVE_XPD_TRX field.
	PMU_HP_ACTIVE_BIAS_HP_ACTIVE_XPD_TRX_Pos = 0x18
	// Bit mask of HP_ACTIVE_XPD_TRX field.
	PMU_HP_ACTIVE_BIAS_HP_ACTIVE_XPD_TRX_Msk = 0x1000000
	// Bit HP_ACTIVE_XPD_TRX.
	PMU_HP_ACTIVE_BIAS_HP_ACTIVE_XPD_TRX = 0x1000000
	// Position of HP_ACTIVE_XPD_BIAS field.
	PMU_HP_ACTIVE_BIAS_HP_ACTIVE_XPD_BIAS_Pos = 0x19
	// Bit mask of HP_ACTIVE_XPD_BIAS field.
	PMU_HP_ACTIVE_BIAS_HP_ACTIVE_XPD_BIAS_Msk = 0x2000000
	// Bit HP_ACTIVE_XPD_BIAS.
	PMU_HP_ACTIVE_BIAS_HP_ACTIVE_XPD_BIAS = 0x2000000
	// Position of HP_ACTIVE_PD_CUR field.
	PMU_HP_ACTIVE_BIAS_HP_ACTIVE_PD_CUR_Pos = 0x1e
	// Bit mask of HP_ACTIVE_PD_CUR field.
	PMU_HP_ACTIVE_BIAS_HP_ACTIVE_PD_CUR_Msk = 0x40000000
	// Bit HP_ACTIVE_PD_CUR.
	PMU_HP_ACTIVE_BIAS_HP_ACTIVE_PD_CUR = 0x40000000
	// Position of SLEEP field.
	PMU_HP_ACTIVE_BIAS_SLEEP_Pos = 0x1f
	// Bit mask of SLEEP field.
	PMU_HP_ACTIVE_BIAS_SLEEP_Msk = 0x80000000
	// Bit SLEEP.
	PMU_HP_ACTIVE_BIAS_SLEEP = 0x80000000

	// HP_ACTIVE_BACKUP: need_des
	// Position of HP_SLEEP2ACTIVE_BACKUP_MODEM_CLK_CODE field.
	PMU_HP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_MODEM_CLK_CODE_Pos = 0x4
	// Bit mask of HP_SLEEP2ACTIVE_BACKUP_MODEM_CLK_CODE field.
	PMU_HP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_MODEM_CLK_CODE_Msk = 0x30
	// Position of HP_MODEM2ACTIVE_BACKUP_MODEM_CLK_CODE field.
	PMU_HP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_MODEM_CLK_CODE_Pos = 0x6
	// Bit mask of HP_MODEM2ACTIVE_BACKUP_MODEM_CLK_CODE field.
	PMU_HP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_MODEM_CLK_CODE_Msk = 0xc0
	// Position of HP_ACTIVE_RETENTION_MODE field.
	PMU_HP_ACTIVE_BACKUP_HP_ACTIVE_RETENTION_MODE_Pos = 0xa
	// Bit mask of HP_ACTIVE_RETENTION_MODE field.
	PMU_HP_ACTIVE_BACKUP_HP_ACTIVE_RETENTION_MODE_Msk = 0x400
	// Bit HP_ACTIVE_RETENTION_MODE.
	PMU_HP_ACTIVE_BACKUP_HP_ACTIVE_RETENTION_MODE = 0x400
	// Position of HP_SLEEP2ACTIVE_RETENTION_EN field.
	PMU_HP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_RETENTION_EN_Pos = 0xb
	// Bit mask of HP_SLEEP2ACTIVE_RETENTION_EN field.
	PMU_HP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_RETENTION_EN_Msk = 0x800
	// Bit HP_SLEEP2ACTIVE_RETENTION_EN.
	PMU_HP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_RETENTION_EN = 0x800
	// Position of HP_MODEM2ACTIVE_RETENTION_EN field.
	PMU_HP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_RETENTION_EN_Pos = 0xc
	// Bit mask of HP_MODEM2ACTIVE_RETENTION_EN field.
	PMU_HP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_RETENTION_EN_Msk = 0x1000
	// Bit HP_MODEM2ACTIVE_RETENTION_EN.
	PMU_HP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_RETENTION_EN = 0x1000
	// Position of HP_SLEEP2ACTIVE_BACKUP_CLK_SEL field.
	PMU_HP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_CLK_SEL_Pos = 0xe
	// Bit mask of HP_SLEEP2ACTIVE_BACKUP_CLK_SEL field.
	PMU_HP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_CLK_SEL_Msk = 0xc000
	// Position of HP_MODEM2ACTIVE_BACKUP_CLK_SEL field.
	PMU_HP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_CLK_SEL_Pos = 0x10
	// Bit mask of HP_MODEM2ACTIVE_BACKUP_CLK_SEL field.
	PMU_HP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_CLK_SEL_Msk = 0x30000
	// Position of HP_SLEEP2ACTIVE_BACKUP_MODE field.
	PMU_HP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_MODE_Pos = 0x14
	// Bit mask of HP_SLEEP2ACTIVE_BACKUP_MODE field.
	PMU_HP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_MODE_Msk = 0x700000
	// Position of HP_MODEM2ACTIVE_BACKUP_MODE field.
	PMU_HP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_MODE_Pos = 0x17
	// Bit mask of HP_MODEM2ACTIVE_BACKUP_MODE field.
	PMU_HP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_MODE_Msk = 0x3800000
	// Position of HP_SLEEP2ACTIVE_BACKUP_EN field.
	PMU_HP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_EN_Pos = 0x1d
	// Bit mask of HP_SLEEP2ACTIVE_BACKUP_EN field.
	PMU_HP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_EN_Msk = 0x20000000
	// Bit HP_SLEEP2ACTIVE_BACKUP_EN.
	PMU_HP_ACTIVE_BACKUP_HP_SLEEP2ACTIVE_BACKUP_EN = 0x20000000
	// Position of HP_MODEM2ACTIVE_BACKUP_EN field.
	PMU_HP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_EN_Pos = 0x1e
	// Bit mask of HP_MODEM2ACTIVE_BACKUP_EN field.
	PMU_HP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_EN_Msk = 0x40000000
	// Bit HP_MODEM2ACTIVE_BACKUP_EN.
	PMU_HP_ACTIVE_BACKUP_HP_MODEM2ACTIVE_BACKUP_EN = 0x40000000

	// HP_ACTIVE_BACKUP_CLK: need_des
	// Position of HP_ACTIVE_BACKUP_ICG_FUNC_EN field.
	PMU_HP_ACTIVE_BACKUP_CLK_HP_ACTIVE_BACKUP_ICG_FUNC_EN_Pos = 0x0
	// Bit mask of HP_ACTIVE_BACKUP_ICG_FUNC_EN field.
	PMU_HP_ACTIVE_BACKUP_CLK_HP_ACTIVE_BACKUP_ICG_FUNC_EN_Msk = 0xffffffff

	// HP_ACTIVE_SYSCLK: need_des
	// Position of HP_ACTIVE_DIG_SYS_CLK_NO_DIV field.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_DIG_SYS_CLK_NO_DIV_Pos = 0x1a
	// Bit mask of HP_ACTIVE_DIG_SYS_CLK_NO_DIV field.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_DIG_SYS_CLK_NO_DIV_Msk = 0x4000000
	// Bit HP_ACTIVE_DIG_SYS_CLK_NO_DIV.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_DIG_SYS_CLK_NO_DIV = 0x4000000
	// Position of HP_ACTIVE_ICG_SYS_CLOCK_EN field.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_ICG_SYS_CLOCK_EN_Pos = 0x1b
	// Bit mask of HP_ACTIVE_ICG_SYS_CLOCK_EN field.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_ICG_SYS_CLOCK_EN_Msk = 0x8000000
	// Bit HP_ACTIVE_ICG_SYS_CLOCK_EN.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_ICG_SYS_CLOCK_EN = 0x8000000
	// Position of HP_ACTIVE_SYS_CLK_SLP_SEL field.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_SYS_CLK_SLP_SEL_Pos = 0x1c
	// Bit mask of HP_ACTIVE_SYS_CLK_SLP_SEL field.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_SYS_CLK_SLP_SEL_Msk = 0x10000000
	// Bit HP_ACTIVE_SYS_CLK_SLP_SEL.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_SYS_CLK_SLP_SEL = 0x10000000
	// Position of HP_ACTIVE_ICG_SLP_SEL field.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_ICG_SLP_SEL_Pos = 0x1d
	// Bit mask of HP_ACTIVE_ICG_SLP_SEL field.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_ICG_SLP_SEL_Msk = 0x20000000
	// Bit HP_ACTIVE_ICG_SLP_SEL.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_ICG_SLP_SEL = 0x20000000
	// Position of HP_ACTIVE_DIG_SYS_CLK_SEL field.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_DIG_SYS_CLK_SEL_Pos = 0x1e
	// Bit mask of HP_ACTIVE_DIG_SYS_CLK_SEL field.
	PMU_HP_ACTIVE_SYSCLK_HP_ACTIVE_DIG_SYS_CLK_SEL_Msk = 0xc0000000

	// HP_ACTIVE_HP_REGULATOR0: need_des
	// Position of HP_ACTIVE_HP_POWER_DET_BYPASS field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_POWER_DET_BYPASS_Pos = 0x0
	// Bit mask of HP_ACTIVE_HP_POWER_DET_BYPASS field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_POWER_DET_BYPASS_Msk = 0x1
	// Bit HP_ACTIVE_HP_POWER_DET_BYPASS.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_POWER_DET_BYPASS = 0x1
	// Position of LP_DBIAS_VOL field.
	PMU_HP_ACTIVE_HP_REGULATOR0_LP_DBIAS_VOL_Pos = 0x4
	// Bit mask of LP_DBIAS_VOL field.
	PMU_HP_ACTIVE_HP_REGULATOR0_LP_DBIAS_VOL_Msk = 0x1f0
	// Position of HP_DBIAS_VOL field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_DBIAS_VOL_Pos = 0x9
	// Bit mask of HP_DBIAS_VOL field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_DBIAS_VOL_Msk = 0x3e00
	// Position of DIG_REGULATOR0_DBIAS_SEL field.
	PMU_HP_ACTIVE_HP_REGULATOR0_DIG_REGULATOR0_DBIAS_SEL_Pos = 0xe
	// Bit mask of DIG_REGULATOR0_DBIAS_SEL field.
	PMU_HP_ACTIVE_HP_REGULATOR0_DIG_REGULATOR0_DBIAS_SEL_Msk = 0x4000
	// Bit DIG_REGULATOR0_DBIAS_SEL.
	PMU_HP_ACTIVE_HP_REGULATOR0_DIG_REGULATOR0_DBIAS_SEL = 0x4000
	// Position of DIG_DBIAS_INIT field.
	PMU_HP_ACTIVE_HP_REGULATOR0_DIG_DBIAS_INIT_Pos = 0xf
	// Bit mask of DIG_DBIAS_INIT field.
	PMU_HP_ACTIVE_HP_REGULATOR0_DIG_DBIAS_INIT_Msk = 0x8000
	// Bit DIG_DBIAS_INIT.
	PMU_HP_ACTIVE_HP_REGULATOR0_DIG_DBIAS_INIT = 0x8000
	// Position of HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD_Pos = 0x10
	// Bit mask of HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD_Msk = 0x10000
	// Bit HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD = 0x10000
	// Position of HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD_Pos = 0x11
	// Bit mask of HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD_Msk = 0x20000
	// Bit HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD = 0x20000
	// Position of HP_ACTIVE_HP_REGULATOR_XPD field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_XPD_Pos = 0x12
	// Bit mask of HP_ACTIVE_HP_REGULATOR_XPD field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_XPD_Msk = 0x40000
	// Bit HP_ACTIVE_HP_REGULATOR_XPD.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_XPD = 0x40000
	// Position of HP_ACTIVE_HP_REGULATOR_SLP_MEM_DBIAS field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_MEM_DBIAS_Pos = 0x13
	// Bit mask of HP_ACTIVE_HP_REGULATOR_SLP_MEM_DBIAS field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_MEM_DBIAS_Msk = 0x780000
	// Position of HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_DBIAS field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_DBIAS_Pos = 0x17
	// Bit mask of HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_DBIAS field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_DBIAS_Msk = 0x7800000
	// Position of HP_ACTIVE_HP_REGULATOR_DBIAS field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_DBIAS_Pos = 0x1b
	// Bit mask of HP_ACTIVE_HP_REGULATOR_DBIAS field.
	PMU_HP_ACTIVE_HP_REGULATOR0_HP_ACTIVE_HP_REGULATOR_DBIAS_Msk = 0xf8000000

	// HP_ACTIVE_HP_REGULATOR1: need_des
	// Position of HP_ACTIVE_HP_REGULATOR_DRV_B field.
	PMU_HP_ACTIVE_HP_REGULATOR1_HP_ACTIVE_HP_REGULATOR_DRV_B_Pos = 0x8
	// Bit mask of HP_ACTIVE_HP_REGULATOR_DRV_B field.
	PMU_HP_ACTIVE_HP_REGULATOR1_HP_ACTIVE_HP_REGULATOR_DRV_B_Msk = 0xffffff00

	// HP_ACTIVE_XTAL: need_des
	// Position of HP_ACTIVE_XPD_XTAL field.
	PMU_HP_ACTIVE_XTAL_HP_ACTIVE_XPD_XTAL_Pos = 0x1f
	// Bit mask of HP_ACTIVE_XPD_XTAL field.
	PMU_HP_ACTIVE_XTAL_HP_ACTIVE_XPD_XTAL_Msk = 0x80000000
	// Bit HP_ACTIVE_XPD_XTAL.
	PMU_HP_ACTIVE_XTAL_HP_ACTIVE_XPD_XTAL = 0x80000000

	// HP_MODEM_DIG_POWER: need_des
	// Position of HP_MODEM_VDD_SPI_PD_EN field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_VDD_SPI_PD_EN_Pos = 0x15
	// Bit mask of HP_MODEM_VDD_SPI_PD_EN field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_VDD_SPI_PD_EN_Msk = 0x200000
	// Bit HP_MODEM_VDD_SPI_PD_EN.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_VDD_SPI_PD_EN = 0x200000
	// Position of HP_MODEM_HP_MEM_DSLP field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_HP_MEM_DSLP_Pos = 0x16
	// Bit mask of HP_MODEM_HP_MEM_DSLP field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_HP_MEM_DSLP_Msk = 0x400000
	// Bit HP_MODEM_HP_MEM_DSLP.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_HP_MEM_DSLP = 0x400000
	// Position of HP_MODEM_PD_HP_MEM_PD_EN field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_HP_MEM_PD_EN_Pos = 0x17
	// Bit mask of HP_MODEM_PD_HP_MEM_PD_EN field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_HP_MEM_PD_EN_Msk = 0x7800000
	// Position of HP_MODEM_PD_HP_WIFI_PD_EN field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_HP_WIFI_PD_EN_Pos = 0x1b
	// Bit mask of HP_MODEM_PD_HP_WIFI_PD_EN field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_HP_WIFI_PD_EN_Msk = 0x8000000
	// Bit HP_MODEM_PD_HP_WIFI_PD_EN.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_HP_WIFI_PD_EN = 0x8000000
	// Position of HP_MODEM_PD_HP_CPU_PD_EN field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_HP_CPU_PD_EN_Pos = 0x1d
	// Bit mask of HP_MODEM_PD_HP_CPU_PD_EN field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_HP_CPU_PD_EN_Msk = 0x20000000
	// Bit HP_MODEM_PD_HP_CPU_PD_EN.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_HP_CPU_PD_EN = 0x20000000
	// Position of HP_MODEM_PD_HP_AON_PD_EN field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_HP_AON_PD_EN_Pos = 0x1e
	// Bit mask of HP_MODEM_PD_HP_AON_PD_EN field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_HP_AON_PD_EN_Msk = 0x40000000
	// Bit HP_MODEM_PD_HP_AON_PD_EN.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_HP_AON_PD_EN = 0x40000000
	// Position of HP_MODEM_PD_TOP_PD_EN field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_TOP_PD_EN_Pos = 0x1f
	// Bit mask of HP_MODEM_PD_TOP_PD_EN field.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_TOP_PD_EN_Msk = 0x80000000
	// Bit HP_MODEM_PD_TOP_PD_EN.
	PMU_HP_MODEM_DIG_POWER_HP_MODEM_PD_TOP_PD_EN = 0x80000000

	// HP_MODEM_ICG_HP_FUNC: need_des
	// Position of HP_MODEM_DIG_ICG_FUNC_EN field.
	PMU_HP_MODEM_ICG_HP_FUNC_HP_MODEM_DIG_ICG_FUNC_EN_Pos = 0x0
	// Bit mask of HP_MODEM_DIG_ICG_FUNC_EN field.
	PMU_HP_MODEM_ICG_HP_FUNC_HP_MODEM_DIG_ICG_FUNC_EN_Msk = 0xffffffff

	// HP_MODEM_ICG_HP_APB: need_des
	// Position of HP_MODEM_DIG_ICG_APB_EN field.
	PMU_HP_MODEM_ICG_HP_APB_HP_MODEM_DIG_ICG_APB_EN_Pos = 0x0
	// Bit mask of HP_MODEM_DIG_ICG_APB_EN field.
	PMU_HP_MODEM_ICG_HP_APB_HP_MODEM_DIG_ICG_APB_EN_Msk = 0xffffffff

	// HP_MODEM_ICG_MODEM: need_des
	// Position of HP_MODEM_DIG_ICG_MODEM_CODE field.
	PMU_HP_MODEM_ICG_MODEM_HP_MODEM_DIG_ICG_MODEM_CODE_Pos = 0x1e
	// Bit mask of HP_MODEM_DIG_ICG_MODEM_CODE field.
	PMU_HP_MODEM_ICG_MODEM_HP_MODEM_DIG_ICG_MODEM_CODE_Msk = 0xc0000000

	// HP_MODEM_HP_SYS_CNTL: need_des
	// Position of HP_MODEM_UART_WAKEUP_EN field.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_UART_WAKEUP_EN_Pos = 0x18
	// Bit mask of HP_MODEM_UART_WAKEUP_EN field.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_UART_WAKEUP_EN_Msk = 0x1000000
	// Bit HP_MODEM_UART_WAKEUP_EN.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_UART_WAKEUP_EN = 0x1000000
	// Position of HP_MODEM_LP_PAD_HOLD_ALL field.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_LP_PAD_HOLD_ALL_Pos = 0x19
	// Bit mask of HP_MODEM_LP_PAD_HOLD_ALL field.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_LP_PAD_HOLD_ALL_Msk = 0x2000000
	// Bit HP_MODEM_LP_PAD_HOLD_ALL.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_LP_PAD_HOLD_ALL = 0x2000000
	// Position of HP_MODEM_HP_PAD_HOLD_ALL field.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_HP_PAD_HOLD_ALL_Pos = 0x1a
	// Bit mask of HP_MODEM_HP_PAD_HOLD_ALL field.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_HP_PAD_HOLD_ALL_Msk = 0x4000000
	// Bit HP_MODEM_HP_PAD_HOLD_ALL.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_HP_PAD_HOLD_ALL = 0x4000000
	// Position of HP_MODEM_DIG_PAD_SLP_SEL field.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_PAD_SLP_SEL_Pos = 0x1b
	// Bit mask of HP_MODEM_DIG_PAD_SLP_SEL field.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_PAD_SLP_SEL_Msk = 0x8000000
	// Bit HP_MODEM_DIG_PAD_SLP_SEL.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_PAD_SLP_SEL = 0x8000000
	// Position of HP_MODEM_DIG_PAUSE_WDT field.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_PAUSE_WDT_Pos = 0x1c
	// Bit mask of HP_MODEM_DIG_PAUSE_WDT field.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_PAUSE_WDT_Msk = 0x10000000
	// Bit HP_MODEM_DIG_PAUSE_WDT.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_PAUSE_WDT = 0x10000000
	// Position of HP_MODEM_DIG_CPU_STALL field.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_CPU_STALL_Pos = 0x1d
	// Bit mask of HP_MODEM_DIG_CPU_STALL field.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_CPU_STALL_Msk = 0x20000000
	// Bit HP_MODEM_DIG_CPU_STALL.
	PMU_HP_MODEM_HP_SYS_CNTL_HP_MODEM_DIG_CPU_STALL = 0x20000000

	// HP_MODEM_HP_CK_POWER: need_des
	// Position of HP_MODEM_I2C_ISO_EN field.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_I2C_ISO_EN_Pos = 0x1a
	// Bit mask of HP_MODEM_I2C_ISO_EN field.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_I2C_ISO_EN_Msk = 0x4000000
	// Bit HP_MODEM_I2C_ISO_EN.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_I2C_ISO_EN = 0x4000000
	// Position of HP_MODEM_I2C_RETENTION field.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_I2C_RETENTION_Pos = 0x1b
	// Bit mask of HP_MODEM_I2C_RETENTION field.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_I2C_RETENTION_Msk = 0x8000000
	// Bit HP_MODEM_I2C_RETENTION.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_I2C_RETENTION = 0x8000000
	// Position of HP_MODEM_XPD_BB_I2C field.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BB_I2C_Pos = 0x1c
	// Bit mask of HP_MODEM_XPD_BB_I2C field.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BB_I2C_Msk = 0x10000000
	// Bit HP_MODEM_XPD_BB_I2C.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BB_I2C = 0x10000000
	// Position of HP_MODEM_XPD_BBPLL_I2C field.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BBPLL_I2C_Pos = 0x1d
	// Bit mask of HP_MODEM_XPD_BBPLL_I2C field.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BBPLL_I2C_Msk = 0x20000000
	// Bit HP_MODEM_XPD_BBPLL_I2C.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BBPLL_I2C = 0x20000000
	// Position of HP_MODEM_XPD_BBPLL field.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BBPLL_Pos = 0x1e
	// Bit mask of HP_MODEM_XPD_BBPLL field.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BBPLL_Msk = 0x40000000
	// Bit HP_MODEM_XPD_BBPLL.
	PMU_HP_MODEM_HP_CK_POWER_HP_MODEM_XPD_BBPLL = 0x40000000

	// HP_MODEM_BIAS: need_des
	// Position of HP_MODEM_XPD_TRX field.
	PMU_HP_MODEM_BIAS_HP_MODEM_XPD_TRX_Pos = 0x18
	// Bit mask of HP_MODEM_XPD_TRX field.
	PMU_HP_MODEM_BIAS_HP_MODEM_XPD_TRX_Msk = 0x1000000
	// Bit HP_MODEM_XPD_TRX.
	PMU_HP_MODEM_BIAS_HP_MODEM_XPD_TRX = 0x1000000
	// Position of HP_MODEM_XPD_BIAS field.
	PMU_HP_MODEM_BIAS_HP_MODEM_XPD_BIAS_Pos = 0x19
	// Bit mask of HP_MODEM_XPD_BIAS field.
	PMU_HP_MODEM_BIAS_HP_MODEM_XPD_BIAS_Msk = 0x2000000
	// Bit HP_MODEM_XPD_BIAS.
	PMU_HP_MODEM_BIAS_HP_MODEM_XPD_BIAS = 0x2000000
	// Position of HP_MODEM_PD_CUR field.
	PMU_HP_MODEM_BIAS_HP_MODEM_PD_CUR_Pos = 0x1e
	// Bit mask of HP_MODEM_PD_CUR field.
	PMU_HP_MODEM_BIAS_HP_MODEM_PD_CUR_Msk = 0x40000000
	// Bit HP_MODEM_PD_CUR.
	PMU_HP_MODEM_BIAS_HP_MODEM_PD_CUR = 0x40000000
	// Position of SLEEP field.
	PMU_HP_MODEM_BIAS_SLEEP_Pos = 0x1f
	// Bit mask of SLEEP field.
	PMU_HP_MODEM_BIAS_SLEEP_Msk = 0x80000000
	// Bit SLEEP.
	PMU_HP_MODEM_BIAS_SLEEP = 0x80000000

	// HP_MODEM_BACKUP: need_des
	// Position of HP_SLEEP2MODEM_BACKUP_MODEM_CLK_CODE field.
	PMU_HP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_MODEM_CLK_CODE_Pos = 0x4
	// Bit mask of HP_SLEEP2MODEM_BACKUP_MODEM_CLK_CODE field.
	PMU_HP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_MODEM_CLK_CODE_Msk = 0x30
	// Position of HP_MODEM_RETENTION_MODE field.
	PMU_HP_MODEM_BACKUP_HP_MODEM_RETENTION_MODE_Pos = 0xa
	// Bit mask of HP_MODEM_RETENTION_MODE field.
	PMU_HP_MODEM_BACKUP_HP_MODEM_RETENTION_MODE_Msk = 0x400
	// Bit HP_MODEM_RETENTION_MODE.
	PMU_HP_MODEM_BACKUP_HP_MODEM_RETENTION_MODE = 0x400
	// Position of HP_SLEEP2MODEM_RETENTION_EN field.
	PMU_HP_MODEM_BACKUP_HP_SLEEP2MODEM_RETENTION_EN_Pos = 0xb
	// Bit mask of HP_SLEEP2MODEM_RETENTION_EN field.
	PMU_HP_MODEM_BACKUP_HP_SLEEP2MODEM_RETENTION_EN_Msk = 0x800
	// Bit HP_SLEEP2MODEM_RETENTION_EN.
	PMU_HP_MODEM_BACKUP_HP_SLEEP2MODEM_RETENTION_EN = 0x800
	// Position of HP_SLEEP2MODEM_BACKUP_CLK_SEL field.
	PMU_HP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_CLK_SEL_Pos = 0xe
	// Bit mask of HP_SLEEP2MODEM_BACKUP_CLK_SEL field.
	PMU_HP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_CLK_SEL_Msk = 0xc000
	// Position of HP_SLEEP2MODEM_BACKUP_MODE field.
	PMU_HP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_MODE_Pos = 0x14
	// Bit mask of HP_SLEEP2MODEM_BACKUP_MODE field.
	PMU_HP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_MODE_Msk = 0x700000
	// Position of HP_SLEEP2MODEM_BACKUP_EN field.
	PMU_HP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_EN_Pos = 0x1d
	// Bit mask of HP_SLEEP2MODEM_BACKUP_EN field.
	PMU_HP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_EN_Msk = 0x20000000
	// Bit HP_SLEEP2MODEM_BACKUP_EN.
	PMU_HP_MODEM_BACKUP_HP_SLEEP2MODEM_BACKUP_EN = 0x20000000

	// HP_MODEM_BACKUP_CLK: need_des
	// Position of HP_MODEM_BACKUP_ICG_FUNC_EN field.
	PMU_HP_MODEM_BACKUP_CLK_HP_MODEM_BACKUP_ICG_FUNC_EN_Pos = 0x0
	// Bit mask of HP_MODEM_BACKUP_ICG_FUNC_EN field.
	PMU_HP_MODEM_BACKUP_CLK_HP_MODEM_BACKUP_ICG_FUNC_EN_Msk = 0xffffffff

	// HP_MODEM_SYSCLK: need_des
	// Position of HP_MODEM_DIG_SYS_CLK_NO_DIV field.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_DIG_SYS_CLK_NO_DIV_Pos = 0x1a
	// Bit mask of HP_MODEM_DIG_SYS_CLK_NO_DIV field.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_DIG_SYS_CLK_NO_DIV_Msk = 0x4000000
	// Bit HP_MODEM_DIG_SYS_CLK_NO_DIV.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_DIG_SYS_CLK_NO_DIV = 0x4000000
	// Position of HP_MODEM_ICG_SYS_CLOCK_EN field.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_ICG_SYS_CLOCK_EN_Pos = 0x1b
	// Bit mask of HP_MODEM_ICG_SYS_CLOCK_EN field.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_ICG_SYS_CLOCK_EN_Msk = 0x8000000
	// Bit HP_MODEM_ICG_SYS_CLOCK_EN.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_ICG_SYS_CLOCK_EN = 0x8000000
	// Position of HP_MODEM_SYS_CLK_SLP_SEL field.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_SYS_CLK_SLP_SEL_Pos = 0x1c
	// Bit mask of HP_MODEM_SYS_CLK_SLP_SEL field.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_SYS_CLK_SLP_SEL_Msk = 0x10000000
	// Bit HP_MODEM_SYS_CLK_SLP_SEL.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_SYS_CLK_SLP_SEL = 0x10000000
	// Position of HP_MODEM_ICG_SLP_SEL field.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_ICG_SLP_SEL_Pos = 0x1d
	// Bit mask of HP_MODEM_ICG_SLP_SEL field.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_ICG_SLP_SEL_Msk = 0x20000000
	// Bit HP_MODEM_ICG_SLP_SEL.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_ICG_SLP_SEL = 0x20000000
	// Position of HP_MODEM_DIG_SYS_CLK_SEL field.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_DIG_SYS_CLK_SEL_Pos = 0x1e
	// Bit mask of HP_MODEM_DIG_SYS_CLK_SEL field.
	PMU_HP_MODEM_SYSCLK_HP_MODEM_DIG_SYS_CLK_SEL_Msk = 0xc0000000

	// HP_MODEM_HP_REGULATOR0: need_des
	// Position of HP_MODEM_HP_POWER_DET_BYPASS field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_POWER_DET_BYPASS_Pos = 0x0
	// Bit mask of HP_MODEM_HP_POWER_DET_BYPASS field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_POWER_DET_BYPASS_Msk = 0x1
	// Bit HP_MODEM_HP_POWER_DET_BYPASS.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_POWER_DET_BYPASS = 0x1
	// Position of HP_MODEM_HP_REGULATOR_SLP_MEM_XPD field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_MEM_XPD_Pos = 0x10
	// Bit mask of HP_MODEM_HP_REGULATOR_SLP_MEM_XPD field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_MEM_XPD_Msk = 0x10000
	// Bit HP_MODEM_HP_REGULATOR_SLP_MEM_XPD.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_MEM_XPD = 0x10000
	// Position of HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD_Pos = 0x11
	// Bit mask of HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD_Msk = 0x20000
	// Bit HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD = 0x20000
	// Position of HP_MODEM_HP_REGULATOR_XPD field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_XPD_Pos = 0x12
	// Bit mask of HP_MODEM_HP_REGULATOR_XPD field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_XPD_Msk = 0x40000
	// Bit HP_MODEM_HP_REGULATOR_XPD.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_XPD = 0x40000
	// Position of HP_MODEM_HP_REGULATOR_SLP_MEM_DBIAS field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_MEM_DBIAS_Pos = 0x13
	// Bit mask of HP_MODEM_HP_REGULATOR_SLP_MEM_DBIAS field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_MEM_DBIAS_Msk = 0x780000
	// Position of HP_MODEM_HP_REGULATOR_SLP_LOGIC_DBIAS field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_LOGIC_DBIAS_Pos = 0x17
	// Bit mask of HP_MODEM_HP_REGULATOR_SLP_LOGIC_DBIAS field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_SLP_LOGIC_DBIAS_Msk = 0x7800000
	// Position of HP_MODEM_HP_REGULATOR_DBIAS field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_DBIAS_Pos = 0x1b
	// Bit mask of HP_MODEM_HP_REGULATOR_DBIAS field.
	PMU_HP_MODEM_HP_REGULATOR0_HP_MODEM_HP_REGULATOR_DBIAS_Msk = 0xf8000000

	// HP_MODEM_HP_REGULATOR1: need_des
	// Position of HP_MODEM_HP_REGULATOR_DRV_B field.
	PMU_HP_MODEM_HP_REGULATOR1_HP_MODEM_HP_REGULATOR_DRV_B_Pos = 0x8
	// Bit mask of HP_MODEM_HP_REGULATOR_DRV_B field.
	PMU_HP_MODEM_HP_REGULATOR1_HP_MODEM_HP_REGULATOR_DRV_B_Msk = 0xffffff00

	// HP_MODEM_XTAL: need_des
	// Position of HP_MODEM_XPD_XTAL field.
	PMU_HP_MODEM_XTAL_HP_MODEM_XPD_XTAL_Pos = 0x1f
	// Bit mask of HP_MODEM_XPD_XTAL field.
	PMU_HP_MODEM_XTAL_HP_MODEM_XPD_XTAL_Msk = 0x80000000
	// Bit HP_MODEM_XPD_XTAL.
	PMU_HP_MODEM_XTAL_HP_MODEM_XPD_XTAL = 0x80000000

	// HP_SLEEP_DIG_POWER: need_des
	// Position of HP_SLEEP_VDD_SPI_PD_EN field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_VDD_SPI_PD_EN_Pos = 0x15
	// Bit mask of HP_SLEEP_VDD_SPI_PD_EN field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_VDD_SPI_PD_EN_Msk = 0x200000
	// Bit HP_SLEEP_VDD_SPI_PD_EN.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_VDD_SPI_PD_EN = 0x200000
	// Position of HP_SLEEP_HP_MEM_DSLP field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_HP_MEM_DSLP_Pos = 0x16
	// Bit mask of HP_SLEEP_HP_MEM_DSLP field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_HP_MEM_DSLP_Msk = 0x400000
	// Bit HP_SLEEP_HP_MEM_DSLP.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_HP_MEM_DSLP = 0x400000
	// Position of HP_SLEEP_PD_HP_MEM_PD_EN field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_MEM_PD_EN_Pos = 0x17
	// Bit mask of HP_SLEEP_PD_HP_MEM_PD_EN field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_MEM_PD_EN_Msk = 0x7800000
	// Position of HP_SLEEP_PD_HP_WIFI_PD_EN field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_WIFI_PD_EN_Pos = 0x1b
	// Bit mask of HP_SLEEP_PD_HP_WIFI_PD_EN field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_WIFI_PD_EN_Msk = 0x8000000
	// Bit HP_SLEEP_PD_HP_WIFI_PD_EN.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_WIFI_PD_EN = 0x8000000
	// Position of HP_SLEEP_PD_HP_CPU_PD_EN field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_CPU_PD_EN_Pos = 0x1d
	// Bit mask of HP_SLEEP_PD_HP_CPU_PD_EN field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_CPU_PD_EN_Msk = 0x20000000
	// Bit HP_SLEEP_PD_HP_CPU_PD_EN.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_CPU_PD_EN = 0x20000000
	// Position of HP_SLEEP_PD_HP_AON_PD_EN field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_AON_PD_EN_Pos = 0x1e
	// Bit mask of HP_SLEEP_PD_HP_AON_PD_EN field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_AON_PD_EN_Msk = 0x40000000
	// Bit HP_SLEEP_PD_HP_AON_PD_EN.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_HP_AON_PD_EN = 0x40000000
	// Position of HP_SLEEP_PD_TOP_PD_EN field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_TOP_PD_EN_Pos = 0x1f
	// Bit mask of HP_SLEEP_PD_TOP_PD_EN field.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_TOP_PD_EN_Msk = 0x80000000
	// Bit HP_SLEEP_PD_TOP_PD_EN.
	PMU_HP_SLEEP_DIG_POWER_HP_SLEEP_PD_TOP_PD_EN = 0x80000000

	// HP_SLEEP_ICG_HP_FUNC: need_des
	// Position of HP_SLEEP_DIG_ICG_FUNC_EN field.
	PMU_HP_SLEEP_ICG_HP_FUNC_HP_SLEEP_DIG_ICG_FUNC_EN_Pos = 0x0
	// Bit mask of HP_SLEEP_DIG_ICG_FUNC_EN field.
	PMU_HP_SLEEP_ICG_HP_FUNC_HP_SLEEP_DIG_ICG_FUNC_EN_Msk = 0xffffffff

	// HP_SLEEP_ICG_HP_APB: need_des
	// Position of HP_SLEEP_DIG_ICG_APB_EN field.
	PMU_HP_SLEEP_ICG_HP_APB_HP_SLEEP_DIG_ICG_APB_EN_Pos = 0x0
	// Bit mask of HP_SLEEP_DIG_ICG_APB_EN field.
	PMU_HP_SLEEP_ICG_HP_APB_HP_SLEEP_DIG_ICG_APB_EN_Msk = 0xffffffff

	// HP_SLEEP_ICG_MODEM: need_des
	// Position of HP_SLEEP_DIG_ICG_MODEM_CODE field.
	PMU_HP_SLEEP_ICG_MODEM_HP_SLEEP_DIG_ICG_MODEM_CODE_Pos = 0x1e
	// Bit mask of HP_SLEEP_DIG_ICG_MODEM_CODE field.
	PMU_HP_SLEEP_ICG_MODEM_HP_SLEEP_DIG_ICG_MODEM_CODE_Msk = 0xc0000000

	// HP_SLEEP_HP_SYS_CNTL: need_des
	// Position of HP_SLEEP_UART_WAKEUP_EN field.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_UART_WAKEUP_EN_Pos = 0x18
	// Bit mask of HP_SLEEP_UART_WAKEUP_EN field.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_UART_WAKEUP_EN_Msk = 0x1000000
	// Bit HP_SLEEP_UART_WAKEUP_EN.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_UART_WAKEUP_EN = 0x1000000
	// Position of HP_SLEEP_LP_PAD_HOLD_ALL field.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_LP_PAD_HOLD_ALL_Pos = 0x19
	// Bit mask of HP_SLEEP_LP_PAD_HOLD_ALL field.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_LP_PAD_HOLD_ALL_Msk = 0x2000000
	// Bit HP_SLEEP_LP_PAD_HOLD_ALL.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_LP_PAD_HOLD_ALL = 0x2000000
	// Position of HP_SLEEP_HP_PAD_HOLD_ALL field.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_HP_PAD_HOLD_ALL_Pos = 0x1a
	// Bit mask of HP_SLEEP_HP_PAD_HOLD_ALL field.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_HP_PAD_HOLD_ALL_Msk = 0x4000000
	// Bit HP_SLEEP_HP_PAD_HOLD_ALL.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_HP_PAD_HOLD_ALL = 0x4000000
	// Position of HP_SLEEP_DIG_PAD_SLP_SEL field.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_PAD_SLP_SEL_Pos = 0x1b
	// Bit mask of HP_SLEEP_DIG_PAD_SLP_SEL field.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_PAD_SLP_SEL_Msk = 0x8000000
	// Bit HP_SLEEP_DIG_PAD_SLP_SEL.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_PAD_SLP_SEL = 0x8000000
	// Position of HP_SLEEP_DIG_PAUSE_WDT field.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_PAUSE_WDT_Pos = 0x1c
	// Bit mask of HP_SLEEP_DIG_PAUSE_WDT field.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_PAUSE_WDT_Msk = 0x10000000
	// Bit HP_SLEEP_DIG_PAUSE_WDT.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_PAUSE_WDT = 0x10000000
	// Position of HP_SLEEP_DIG_CPU_STALL field.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_CPU_STALL_Pos = 0x1d
	// Bit mask of HP_SLEEP_DIG_CPU_STALL field.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_CPU_STALL_Msk = 0x20000000
	// Bit HP_SLEEP_DIG_CPU_STALL.
	PMU_HP_SLEEP_HP_SYS_CNTL_HP_SLEEP_DIG_CPU_STALL = 0x20000000

	// HP_SLEEP_HP_CK_POWER: need_des
	// Position of HP_SLEEP_I2C_ISO_EN field.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_I2C_ISO_EN_Pos = 0x1a
	// Bit mask of HP_SLEEP_I2C_ISO_EN field.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_I2C_ISO_EN_Msk = 0x4000000
	// Bit HP_SLEEP_I2C_ISO_EN.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_I2C_ISO_EN = 0x4000000
	// Position of HP_SLEEP_I2C_RETENTION field.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_I2C_RETENTION_Pos = 0x1b
	// Bit mask of HP_SLEEP_I2C_RETENTION field.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_I2C_RETENTION_Msk = 0x8000000
	// Bit HP_SLEEP_I2C_RETENTION.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_I2C_RETENTION = 0x8000000
	// Position of HP_SLEEP_XPD_BB_I2C field.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BB_I2C_Pos = 0x1c
	// Bit mask of HP_SLEEP_XPD_BB_I2C field.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BB_I2C_Msk = 0x10000000
	// Bit HP_SLEEP_XPD_BB_I2C.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BB_I2C = 0x10000000
	// Position of HP_SLEEP_XPD_BBPLL_I2C field.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BBPLL_I2C_Pos = 0x1d
	// Bit mask of HP_SLEEP_XPD_BBPLL_I2C field.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BBPLL_I2C_Msk = 0x20000000
	// Bit HP_SLEEP_XPD_BBPLL_I2C.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BBPLL_I2C = 0x20000000
	// Position of HP_SLEEP_XPD_BBPLL field.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BBPLL_Pos = 0x1e
	// Bit mask of HP_SLEEP_XPD_BBPLL field.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BBPLL_Msk = 0x40000000
	// Bit HP_SLEEP_XPD_BBPLL.
	PMU_HP_SLEEP_HP_CK_POWER_HP_SLEEP_XPD_BBPLL = 0x40000000

	// HP_SLEEP_BIAS: need_des
	// Position of HP_SLEEP_XPD_TRX field.
	PMU_HP_SLEEP_BIAS_HP_SLEEP_XPD_TRX_Pos = 0x18
	// Bit mask of HP_SLEEP_XPD_TRX field.
	PMU_HP_SLEEP_BIAS_HP_SLEEP_XPD_TRX_Msk = 0x1000000
	// Bit HP_SLEEP_XPD_TRX.
	PMU_HP_SLEEP_BIAS_HP_SLEEP_XPD_TRX = 0x1000000
	// Position of HP_SLEEP_XPD_BIAS field.
	PMU_HP_SLEEP_BIAS_HP_SLEEP_XPD_BIAS_Pos = 0x19
	// Bit mask of HP_SLEEP_XPD_BIAS field.
	PMU_HP_SLEEP_BIAS_HP_SLEEP_XPD_BIAS_Msk = 0x2000000
	// Bit HP_SLEEP_XPD_BIAS.
	PMU_HP_SLEEP_BIAS_HP_SLEEP_XPD_BIAS = 0x2000000
	// Position of HP_SLEEP_PD_CUR field.
	PMU_HP_SLEEP_BIAS_HP_SLEEP_PD_CUR_Pos = 0x1e
	// Bit mask of HP_SLEEP_PD_CUR field.
	PMU_HP_SLEEP_BIAS_HP_SLEEP_PD_CUR_Msk = 0x40000000
	// Bit HP_SLEEP_PD_CUR.
	PMU_HP_SLEEP_BIAS_HP_SLEEP_PD_CUR = 0x40000000
	// Position of SLEEP field.
	PMU_HP_SLEEP_BIAS_SLEEP_Pos = 0x1f
	// Bit mask of SLEEP field.
	PMU_HP_SLEEP_BIAS_SLEEP_Msk = 0x80000000
	// Bit SLEEP.
	PMU_HP_SLEEP_BIAS_SLEEP = 0x80000000

	// HP_SLEEP_BACKUP: need_des
	// Position of HP_MODEM2SLEEP_BACKUP_MODEM_CLK_CODE field.
	PMU_HP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_MODEM_CLK_CODE_Pos = 0x6
	// Bit mask of HP_MODEM2SLEEP_BACKUP_MODEM_CLK_CODE field.
	PMU_HP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_MODEM_CLK_CODE_Msk = 0xc0
	// Position of HP_ACTIVE2SLEEP_BACKUP_MODEM_CLK_CODE field.
	PMU_HP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_MODEM_CLK_CODE_Pos = 0x8
	// Bit mask of HP_ACTIVE2SLEEP_BACKUP_MODEM_CLK_CODE field.
	PMU_HP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_MODEM_CLK_CODE_Msk = 0x300
	// Position of HP_SLEEP_RETENTION_MODE field.
	PMU_HP_SLEEP_BACKUP_HP_SLEEP_RETENTION_MODE_Pos = 0xa
	// Bit mask of HP_SLEEP_RETENTION_MODE field.
	PMU_HP_SLEEP_BACKUP_HP_SLEEP_RETENTION_MODE_Msk = 0x400
	// Bit HP_SLEEP_RETENTION_MODE.
	PMU_HP_SLEEP_BACKUP_HP_SLEEP_RETENTION_MODE = 0x400
	// Position of HP_MODEM2SLEEP_RETENTION_EN field.
	PMU_HP_SLEEP_BACKUP_HP_MODEM2SLEEP_RETENTION_EN_Pos = 0xc
	// Bit mask of HP_MODEM2SLEEP_RETENTION_EN field.
	PMU_HP_SLEEP_BACKUP_HP_MODEM2SLEEP_RETENTION_EN_Msk = 0x1000
	// Bit HP_MODEM2SLEEP_RETENTION_EN.
	PMU_HP_SLEEP_BACKUP_HP_MODEM2SLEEP_RETENTION_EN = 0x1000
	// Position of HP_ACTIVE2SLEEP_RETENTION_EN field.
	PMU_HP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_RETENTION_EN_Pos = 0xd
	// Bit mask of HP_ACTIVE2SLEEP_RETENTION_EN field.
	PMU_HP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_RETENTION_EN_Msk = 0x2000
	// Bit HP_ACTIVE2SLEEP_RETENTION_EN.
	PMU_HP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_RETENTION_EN = 0x2000
	// Position of HP_MODEM2SLEEP_BACKUP_CLK_SEL field.
	PMU_HP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_CLK_SEL_Pos = 0x10
	// Bit mask of HP_MODEM2SLEEP_BACKUP_CLK_SEL field.
	PMU_HP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_CLK_SEL_Msk = 0x30000
	// Position of HP_ACTIVE2SLEEP_BACKUP_CLK_SEL field.
	PMU_HP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_CLK_SEL_Pos = 0x12
	// Bit mask of HP_ACTIVE2SLEEP_BACKUP_CLK_SEL field.
	PMU_HP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_CLK_SEL_Msk = 0xc0000
	// Position of HP_MODEM2SLEEP_BACKUP_MODE field.
	PMU_HP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_MODE_Pos = 0x17
	// Bit mask of HP_MODEM2SLEEP_BACKUP_MODE field.
	PMU_HP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_MODE_Msk = 0x3800000
	// Position of HP_ACTIVE2SLEEP_BACKUP_MODE field.
	PMU_HP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_MODE_Pos = 0x1a
	// Bit mask of HP_ACTIVE2SLEEP_BACKUP_MODE field.
	PMU_HP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_MODE_Msk = 0x1c000000
	// Position of HP_MODEM2SLEEP_BACKUP_EN field.
	PMU_HP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_EN_Pos = 0x1e
	// Bit mask of HP_MODEM2SLEEP_BACKUP_EN field.
	PMU_HP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_EN_Msk = 0x40000000
	// Bit HP_MODEM2SLEEP_BACKUP_EN.
	PMU_HP_SLEEP_BACKUP_HP_MODEM2SLEEP_BACKUP_EN = 0x40000000
	// Position of HP_ACTIVE2SLEEP_BACKUP_EN field.
	PMU_HP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_EN_Pos = 0x1f
	// Bit mask of HP_ACTIVE2SLEEP_BACKUP_EN field.
	PMU_HP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_EN_Msk = 0x80000000
	// Bit HP_ACTIVE2SLEEP_BACKUP_EN.
	PMU_HP_SLEEP_BACKUP_HP_ACTIVE2SLEEP_BACKUP_EN = 0x80000000

	// HP_SLEEP_BACKUP_CLK: need_des
	// Position of HP_SLEEP_BACKUP_ICG_FUNC_EN field.
	PMU_HP_SLEEP_BACKUP_CLK_HP_SLEEP_BACKUP_ICG_FUNC_EN_Pos = 0x0
	// Bit mask of HP_SLEEP_BACKUP_ICG_FUNC_EN field.
	PMU_HP_SLEEP_BACKUP_CLK_HP_SLEEP_BACKUP_ICG_FUNC_EN_Msk = 0xffffffff

	// HP_SLEEP_SYSCLK: need_des
	// Position of HP_SLEEP_DIG_SYS_CLK_NO_DIV field.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_DIG_SYS_CLK_NO_DIV_Pos = 0x1a
	// Bit mask of HP_SLEEP_DIG_SYS_CLK_NO_DIV field.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_DIG_SYS_CLK_NO_DIV_Msk = 0x4000000
	// Bit HP_SLEEP_DIG_SYS_CLK_NO_DIV.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_DIG_SYS_CLK_NO_DIV = 0x4000000
	// Position of HP_SLEEP_ICG_SYS_CLOCK_EN field.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_ICG_SYS_CLOCK_EN_Pos = 0x1b
	// Bit mask of HP_SLEEP_ICG_SYS_CLOCK_EN field.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_ICG_SYS_CLOCK_EN_Msk = 0x8000000
	// Bit HP_SLEEP_ICG_SYS_CLOCK_EN.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_ICG_SYS_CLOCK_EN = 0x8000000
	// Position of HP_SLEEP_SYS_CLK_SLP_SEL field.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_SYS_CLK_SLP_SEL_Pos = 0x1c
	// Bit mask of HP_SLEEP_SYS_CLK_SLP_SEL field.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_SYS_CLK_SLP_SEL_Msk = 0x10000000
	// Bit HP_SLEEP_SYS_CLK_SLP_SEL.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_SYS_CLK_SLP_SEL = 0x10000000
	// Position of HP_SLEEP_ICG_SLP_SEL field.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_ICG_SLP_SEL_Pos = 0x1d
	// Bit mask of HP_SLEEP_ICG_SLP_SEL field.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_ICG_SLP_SEL_Msk = 0x20000000
	// Bit HP_SLEEP_ICG_SLP_SEL.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_ICG_SLP_SEL = 0x20000000
	// Position of HP_SLEEP_DIG_SYS_CLK_SEL field.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_DIG_SYS_CLK_SEL_Pos = 0x1e
	// Bit mask of HP_SLEEP_DIG_SYS_CLK_SEL field.
	PMU_HP_SLEEP_SYSCLK_HP_SLEEP_DIG_SYS_CLK_SEL_Msk = 0xc0000000

	// HP_SLEEP_HP_REGULATOR0: need_des
	// Position of HP_SLEEP_HP_POWER_DET_BYPASS field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_POWER_DET_BYPASS_Pos = 0x0
	// Bit mask of HP_SLEEP_HP_POWER_DET_BYPASS field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_POWER_DET_BYPASS_Msk = 0x1
	// Bit HP_SLEEP_HP_POWER_DET_BYPASS.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_POWER_DET_BYPASS = 0x1
	// Position of HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD_Pos = 0x10
	// Bit mask of HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD_Msk = 0x10000
	// Bit HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD = 0x10000
	// Position of HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD_Pos = 0x11
	// Bit mask of HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD_Msk = 0x20000
	// Bit HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD = 0x20000
	// Position of HP_SLEEP_HP_REGULATOR_XPD field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_XPD_Pos = 0x12
	// Bit mask of HP_SLEEP_HP_REGULATOR_XPD field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_XPD_Msk = 0x40000
	// Bit HP_SLEEP_HP_REGULATOR_XPD.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_XPD = 0x40000
	// Position of HP_SLEEP_HP_REGULATOR_SLP_MEM_DBIAS field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_MEM_DBIAS_Pos = 0x13
	// Bit mask of HP_SLEEP_HP_REGULATOR_SLP_MEM_DBIAS field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_MEM_DBIAS_Msk = 0x780000
	// Position of HP_SLEEP_HP_REGULATOR_SLP_LOGIC_DBIAS field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_DBIAS_Pos = 0x17
	// Bit mask of HP_SLEEP_HP_REGULATOR_SLP_LOGIC_DBIAS field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_DBIAS_Msk = 0x7800000
	// Position of HP_SLEEP_HP_REGULATOR_DBIAS field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_DBIAS_Pos = 0x1b
	// Bit mask of HP_SLEEP_HP_REGULATOR_DBIAS field.
	PMU_HP_SLEEP_HP_REGULATOR0_HP_SLEEP_HP_REGULATOR_DBIAS_Msk = 0xf8000000

	// HP_SLEEP_HP_REGULATOR1: need_des
	// Position of HP_SLEEP_HP_REGULATOR_DRV_B field.
	PMU_HP_SLEEP_HP_REGULATOR1_HP_SLEEP_HP_REGULATOR_DRV_B_Pos = 0x8
	// Bit mask of HP_SLEEP_HP_REGULATOR_DRV_B field.
	PMU_HP_SLEEP_HP_REGULATOR1_HP_SLEEP_HP_REGULATOR_DRV_B_Msk = 0xffffff00

	// HP_SLEEP_XTAL: need_des
	// Position of HP_SLEEP_XPD_XTAL field.
	PMU_HP_SLEEP_XTAL_HP_SLEEP_XPD_XTAL_Pos = 0x1f
	// Bit mask of HP_SLEEP_XPD_XTAL field.
	PMU_HP_SLEEP_XTAL_HP_SLEEP_XPD_XTAL_Msk = 0x80000000
	// Bit HP_SLEEP_XPD_XTAL.
	PMU_HP_SLEEP_XTAL_HP_SLEEP_XPD_XTAL = 0x80000000

	// HP_SLEEP_LP_REGULATOR0: need_des
	// Position of HP_SLEEP_LP_REGULATOR_SLP_XPD field.
	PMU_HP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_SLP_XPD_Pos = 0x15
	// Bit mask of HP_SLEEP_LP_REGULATOR_SLP_XPD field.
	PMU_HP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_SLP_XPD_Msk = 0x200000
	// Bit HP_SLEEP_LP_REGULATOR_SLP_XPD.
	PMU_HP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_SLP_XPD = 0x200000
	// Position of HP_SLEEP_LP_REGULATOR_XPD field.
	PMU_HP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_XPD_Pos = 0x16
	// Bit mask of HP_SLEEP_LP_REGULATOR_XPD field.
	PMU_HP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_XPD_Msk = 0x400000
	// Bit HP_SLEEP_LP_REGULATOR_XPD.
	PMU_HP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_XPD = 0x400000
	// Position of HP_SLEEP_LP_REGULATOR_SLP_DBIAS field.
	PMU_HP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_SLP_DBIAS_Pos = 0x17
	// Bit mask of HP_SLEEP_LP_REGULATOR_SLP_DBIAS field.
	PMU_HP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_SLP_DBIAS_Msk = 0x7800000
	// Position of HP_SLEEP_LP_REGULATOR_DBIAS field.
	PMU_HP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_DBIAS_Pos = 0x1b
	// Bit mask of HP_SLEEP_LP_REGULATOR_DBIAS field.
	PMU_HP_SLEEP_LP_REGULATOR0_HP_SLEEP_LP_REGULATOR_DBIAS_Msk = 0xf8000000

	// HP_SLEEP_LP_REGULATOR1: need_des
	// Position of HP_SLEEP_LP_REGULATOR_DRV_B field.
	PMU_HP_SLEEP_LP_REGULATOR1_HP_SLEEP_LP_REGULATOR_DRV_B_Pos = 0x1c
	// Bit mask of HP_SLEEP_LP_REGULATOR_DRV_B field.
	PMU_HP_SLEEP_LP_REGULATOR1_HP_SLEEP_LP_REGULATOR_DRV_B_Msk = 0xf0000000

	// HP_SLEEP_LP_DCDC_RESERVE: need_des
	// Position of HP_SLEEP_LP_DCDC_RESERVE field.
	PMU_HP_SLEEP_LP_DCDC_RESERVE_HP_SLEEP_LP_DCDC_RESERVE_Pos = 0x0
	// Bit mask of HP_SLEEP_LP_DCDC_RESERVE field.
	PMU_HP_SLEEP_LP_DCDC_RESERVE_HP_SLEEP_LP_DCDC_RESERVE_Msk = 0xffffffff

	// HP_SLEEP_LP_DIG_POWER: need_des
	// Position of HP_SLEEP_BOD_SOURCE_SEL field.
	PMU_HP_SLEEP_LP_DIG_POWER_HP_SLEEP_BOD_SOURCE_SEL_Pos = 0x1b
	// Bit mask of HP_SLEEP_BOD_SOURCE_SEL field.
	PMU_HP_SLEEP_LP_DIG_POWER_HP_SLEEP_BOD_SOURCE_SEL_Msk = 0x8000000
	// Bit HP_SLEEP_BOD_SOURCE_SEL.
	PMU_HP_SLEEP_LP_DIG_POWER_HP_SLEEP_BOD_SOURCE_SEL = 0x8000000
	// Position of HP_SLEEP_VDDBAT_MODE field.
	PMU_HP_SLEEP_LP_DIG_POWER_HP_SLEEP_VDDBAT_MODE_Pos = 0x1c
	// Bit mask of HP_SLEEP_VDDBAT_MODE field.
	PMU_HP_SLEEP_LP_DIG_POWER_HP_SLEEP_VDDBAT_MODE_Msk = 0x30000000
	// Position of HP_SLEEP_LP_MEM_DSLP field.
	PMU_HP_SLEEP_LP_DIG_POWER_HP_SLEEP_LP_MEM_DSLP_Pos = 0x1e
	// Bit mask of HP_SLEEP_LP_MEM_DSLP field.
	PMU_HP_SLEEP_LP_DIG_POWER_HP_SLEEP_LP_MEM_DSLP_Msk = 0x40000000
	// Bit HP_SLEEP_LP_MEM_DSLP.
	PMU_HP_SLEEP_LP_DIG_POWER_HP_SLEEP_LP_MEM_DSLP = 0x40000000
	// Position of HP_SLEEP_PD_LP_PERI_PD_EN field.
	PMU_HP_SLEEP_LP_DIG_POWER_HP_SLEEP_PD_LP_PERI_PD_EN_Pos = 0x1f
	// Bit mask of HP_SLEEP_PD_LP_PERI_PD_EN field.
	PMU_HP_SLEEP_LP_DIG_POWER_HP_SLEEP_PD_LP_PERI_PD_EN_Msk = 0x80000000
	// Bit HP_SLEEP_PD_LP_PERI_PD_EN.
	PMU_HP_SLEEP_LP_DIG_POWER_HP_SLEEP_PD_LP_PERI_PD_EN = 0x80000000

	// HP_SLEEP_LP_CK_POWER: need_des
	// Position of HP_SLEEP_XPD_LPPLL field.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_LPPLL_Pos = 0x1b
	// Bit mask of HP_SLEEP_XPD_LPPLL field.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_LPPLL_Msk = 0x8000000
	// Bit HP_SLEEP_XPD_LPPLL.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_LPPLL = 0x8000000
	// Position of HP_SLEEP_XPD_XTAL32K field.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_XTAL32K_Pos = 0x1c
	// Bit mask of HP_SLEEP_XPD_XTAL32K field.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_XTAL32K_Msk = 0x10000000
	// Bit HP_SLEEP_XPD_XTAL32K.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_XTAL32K = 0x10000000
	// Position of HP_SLEEP_XPD_RC32K field.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_RC32K_Pos = 0x1d
	// Bit mask of HP_SLEEP_XPD_RC32K field.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_RC32K_Msk = 0x20000000
	// Bit HP_SLEEP_XPD_RC32K.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_RC32K = 0x20000000
	// Position of HP_SLEEP_XPD_FOSC_CLK field.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_FOSC_CLK_Pos = 0x1e
	// Bit mask of HP_SLEEP_XPD_FOSC_CLK field.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_FOSC_CLK_Msk = 0x40000000
	// Bit HP_SLEEP_XPD_FOSC_CLK.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_XPD_FOSC_CLK = 0x40000000
	// Position of HP_SLEEP_PD_OSC_CLK field.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_PD_OSC_CLK_Pos = 0x1f
	// Bit mask of HP_SLEEP_PD_OSC_CLK field.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_PD_OSC_CLK_Msk = 0x80000000
	// Bit HP_SLEEP_PD_OSC_CLK.
	PMU_HP_SLEEP_LP_CK_POWER_HP_SLEEP_PD_OSC_CLK = 0x80000000

	// LP_SLEEP_LP_BIAS_RESERVE: need_des
	// Position of LP_SLEEP_LP_BIAS_RESERVE field.
	PMU_LP_SLEEP_LP_BIAS_RESERVE_LP_SLEEP_LP_BIAS_RESERVE_Pos = 0x0
	// Bit mask of LP_SLEEP_LP_BIAS_RESERVE field.
	PMU_LP_SLEEP_LP_BIAS_RESERVE_LP_SLEEP_LP_BIAS_RESERVE_Msk = 0xffffffff

	// LP_SLEEP_LP_REGULATOR0: need_des
	// Position of LP_SLEEP_LP_REGULATOR_SLP_XPD field.
	PMU_LP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_SLP_XPD_Pos = 0x15
	// Bit mask of LP_SLEEP_LP_REGULATOR_SLP_XPD field.
	PMU_LP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_SLP_XPD_Msk = 0x200000
	// Bit LP_SLEEP_LP_REGULATOR_SLP_XPD.
	PMU_LP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_SLP_XPD = 0x200000
	// Position of LP_SLEEP_LP_REGULATOR_XPD field.
	PMU_LP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_XPD_Pos = 0x16
	// Bit mask of LP_SLEEP_LP_REGULATOR_XPD field.
	PMU_LP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_XPD_Msk = 0x400000
	// Bit LP_SLEEP_LP_REGULATOR_XPD.
	PMU_LP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_XPD = 0x400000
	// Position of LP_SLEEP_LP_REGULATOR_SLP_DBIAS field.
	PMU_LP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_SLP_DBIAS_Pos = 0x17
	// Bit mask of LP_SLEEP_LP_REGULATOR_SLP_DBIAS field.
	PMU_LP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_SLP_DBIAS_Msk = 0x7800000
	// Position of LP_SLEEP_LP_REGULATOR_DBIAS field.
	PMU_LP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_DBIAS_Pos = 0x1b
	// Bit mask of LP_SLEEP_LP_REGULATOR_DBIAS field.
	PMU_LP_SLEEP_LP_REGULATOR0_LP_SLEEP_LP_REGULATOR_DBIAS_Msk = 0xf8000000

	// LP_SLEEP_LP_REGULATOR1: need_des
	// Position of LP_SLEEP_LP_REGULATOR_DRV_B field.
	PMU_LP_SLEEP_LP_REGULATOR1_LP_SLEEP_LP_REGULATOR_DRV_B_Pos = 0x1c
	// Bit mask of LP_SLEEP_LP_REGULATOR_DRV_B field.
	PMU_LP_SLEEP_LP_REGULATOR1_LP_SLEEP_LP_REGULATOR_DRV_B_Msk = 0xf0000000

	// LP_SLEEP_XTAL: need_des
	// Position of LP_SLEEP_XPD_XTAL field.
	PMU_LP_SLEEP_XTAL_LP_SLEEP_XPD_XTAL_Pos = 0x1f
	// Bit mask of LP_SLEEP_XPD_XTAL field.
	PMU_LP_SLEEP_XTAL_LP_SLEEP_XPD_XTAL_Msk = 0x80000000
	// Bit LP_SLEEP_XPD_XTAL.
	PMU_LP_SLEEP_XTAL_LP_SLEEP_XPD_XTAL = 0x80000000

	// LP_SLEEP_LP_DIG_POWER: need_des
	// Position of LP_SLEEP_BOD_SOURCE_SEL field.
	PMU_LP_SLEEP_LP_DIG_POWER_LP_SLEEP_BOD_SOURCE_SEL_Pos = 0x1b
	// Bit mask of LP_SLEEP_BOD_SOURCE_SEL field.
	PMU_LP_SLEEP_LP_DIG_POWER_LP_SLEEP_BOD_SOURCE_SEL_Msk = 0x8000000
	// Bit LP_SLEEP_BOD_SOURCE_SEL.
	PMU_LP_SLEEP_LP_DIG_POWER_LP_SLEEP_BOD_SOURCE_SEL = 0x8000000
	// Position of LP_SLEEP_VDDBAT_MODE field.
	PMU_LP_SLEEP_LP_DIG_POWER_LP_SLEEP_VDDBAT_MODE_Pos = 0x1c
	// Bit mask of LP_SLEEP_VDDBAT_MODE field.
	PMU_LP_SLEEP_LP_DIG_POWER_LP_SLEEP_VDDBAT_MODE_Msk = 0x30000000
	// Position of LP_SLEEP_LP_MEM_DSLP field.
	PMU_LP_SLEEP_LP_DIG_POWER_LP_SLEEP_LP_MEM_DSLP_Pos = 0x1e
	// Bit mask of LP_SLEEP_LP_MEM_DSLP field.
	PMU_LP_SLEEP_LP_DIG_POWER_LP_SLEEP_LP_MEM_DSLP_Msk = 0x40000000
	// Bit LP_SLEEP_LP_MEM_DSLP.
	PMU_LP_SLEEP_LP_DIG_POWER_LP_SLEEP_LP_MEM_DSLP = 0x40000000
	// Position of LP_SLEEP_PD_LP_PERI_PD_EN field.
	PMU_LP_SLEEP_LP_DIG_POWER_LP_SLEEP_PD_LP_PERI_PD_EN_Pos = 0x1f
	// Bit mask of LP_SLEEP_PD_LP_PERI_PD_EN field.
	PMU_LP_SLEEP_LP_DIG_POWER_LP_SLEEP_PD_LP_PERI_PD_EN_Msk = 0x80000000
	// Bit LP_SLEEP_PD_LP_PERI_PD_EN.
	PMU_LP_SLEEP_LP_DIG_POWER_LP_SLEEP_PD_LP_PERI_PD_EN = 0x80000000

	// LP_SLEEP_LP_CK_POWER: need_des
	// Position of LP_SLEEP_XPD_LPPLL field.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_LPPLL_Pos = 0x1b
	// Bit mask of LP_SLEEP_XPD_LPPLL field.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_LPPLL_Msk = 0x8000000
	// Bit LP_SLEEP_XPD_LPPLL.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_LPPLL = 0x8000000
	// Position of LP_SLEEP_XPD_XTAL32K field.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_XTAL32K_Pos = 0x1c
	// Bit mask of LP_SLEEP_XPD_XTAL32K field.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_XTAL32K_Msk = 0x10000000
	// Bit LP_SLEEP_XPD_XTAL32K.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_XTAL32K = 0x10000000
	// Position of LP_SLEEP_XPD_RC32K field.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_RC32K_Pos = 0x1d
	// Bit mask of LP_SLEEP_XPD_RC32K field.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_RC32K_Msk = 0x20000000
	// Bit LP_SLEEP_XPD_RC32K.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_RC32K = 0x20000000
	// Position of LP_SLEEP_XPD_FOSC_CLK field.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_FOSC_CLK_Pos = 0x1e
	// Bit mask of LP_SLEEP_XPD_FOSC_CLK field.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_FOSC_CLK_Msk = 0x40000000
	// Bit LP_SLEEP_XPD_FOSC_CLK.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_XPD_FOSC_CLK = 0x40000000
	// Position of LP_SLEEP_PD_OSC_CLK field.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_PD_OSC_CLK_Pos = 0x1f
	// Bit mask of LP_SLEEP_PD_OSC_CLK field.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_PD_OSC_CLK_Msk = 0x80000000
	// Bit LP_SLEEP_PD_OSC_CLK.
	PMU_LP_SLEEP_LP_CK_POWER_LP_SLEEP_PD_OSC_CLK = 0x80000000

	// LP_SLEEP_BIAS: need_des
	// Position of LP_SLEEP_XPD_BIAS field.
	PMU_LP_SLEEP_BIAS_LP_SLEEP_XPD_BIAS_Pos = 0x19
	// Bit mask of LP_SLEEP_XPD_BIAS field.
	PMU_LP_SLEEP_BIAS_LP_SLEEP_XPD_BIAS_Msk = 0x2000000
	// Bit LP_SLEEP_XPD_BIAS.
	PMU_LP_SLEEP_BIAS_LP_SLEEP_XPD_BIAS = 0x2000000
	// Position of LP_SLEEP_PD_CUR field.
	PMU_LP_SLEEP_BIAS_LP_SLEEP_PD_CUR_Pos = 0x1e
	// Bit mask of LP_SLEEP_PD_CUR field.
	PMU_LP_SLEEP_BIAS_LP_SLEEP_PD_CUR_Msk = 0x40000000
	// Bit LP_SLEEP_PD_CUR.
	PMU_LP_SLEEP_BIAS_LP_SLEEP_PD_CUR = 0x40000000
	// Position of SLEEP field.
	PMU_LP_SLEEP_BIAS_SLEEP_Pos = 0x1f
	// Bit mask of SLEEP field.
	PMU_LP_SLEEP_BIAS_SLEEP_Msk = 0x80000000
	// Bit SLEEP.
	PMU_LP_SLEEP_BIAS_SLEEP = 0x80000000

	// IMM_HP_CK_POWER: need_des
	// Position of TIE_LOW_GLOBAL_BBPLL_ICG field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_GLOBAL_BBPLL_ICG_Pos = 0x0
	// Bit mask of TIE_LOW_GLOBAL_BBPLL_ICG field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_GLOBAL_BBPLL_ICG_Msk = 0x1
	// Bit TIE_LOW_GLOBAL_BBPLL_ICG.
	PMU_IMM_HP_CK_POWER_TIE_LOW_GLOBAL_BBPLL_ICG = 0x1
	// Position of TIE_LOW_GLOBAL_XTAL_ICG field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_GLOBAL_XTAL_ICG_Pos = 0x1
	// Bit mask of TIE_LOW_GLOBAL_XTAL_ICG field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_GLOBAL_XTAL_ICG_Msk = 0x2
	// Bit TIE_LOW_GLOBAL_XTAL_ICG.
	PMU_IMM_HP_CK_POWER_TIE_LOW_GLOBAL_XTAL_ICG = 0x2
	// Position of TIE_LOW_I2C_RETENTION field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_I2C_RETENTION_Pos = 0x2
	// Bit mask of TIE_LOW_I2C_RETENTION field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_I2C_RETENTION_Msk = 0x4
	// Bit TIE_LOW_I2C_RETENTION.
	PMU_IMM_HP_CK_POWER_TIE_LOW_I2C_RETENTION = 0x4
	// Position of TIE_LOW_XPD_BB_I2C field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_XPD_BB_I2C_Pos = 0x3
	// Bit mask of TIE_LOW_XPD_BB_I2C field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_XPD_BB_I2C_Msk = 0x8
	// Bit TIE_LOW_XPD_BB_I2C.
	PMU_IMM_HP_CK_POWER_TIE_LOW_XPD_BB_I2C = 0x8
	// Position of TIE_LOW_XPD_BBPLL_I2C field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_XPD_BBPLL_I2C_Pos = 0x4
	// Bit mask of TIE_LOW_XPD_BBPLL_I2C field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_XPD_BBPLL_I2C_Msk = 0x10
	// Bit TIE_LOW_XPD_BBPLL_I2C.
	PMU_IMM_HP_CK_POWER_TIE_LOW_XPD_BBPLL_I2C = 0x10
	// Position of TIE_LOW_XPD_BBPLL field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_XPD_BBPLL_Pos = 0x5
	// Bit mask of TIE_LOW_XPD_BBPLL field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_XPD_BBPLL_Msk = 0x20
	// Bit TIE_LOW_XPD_BBPLL.
	PMU_IMM_HP_CK_POWER_TIE_LOW_XPD_BBPLL = 0x20
	// Position of TIE_LOW_XPD_XTAL field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_XPD_XTAL_Pos = 0x6
	// Bit mask of TIE_LOW_XPD_XTAL field.
	PMU_IMM_HP_CK_POWER_TIE_LOW_XPD_XTAL_Msk = 0x40
	// Bit TIE_LOW_XPD_XTAL.
	PMU_IMM_HP_CK_POWER_TIE_LOW_XPD_XTAL = 0x40
	// Position of TIE_HIGH_GLOBAL_BBPLL_ICG field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_GLOBAL_BBPLL_ICG_Pos = 0x19
	// Bit mask of TIE_HIGH_GLOBAL_BBPLL_ICG field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_GLOBAL_BBPLL_ICG_Msk = 0x2000000
	// Bit TIE_HIGH_GLOBAL_BBPLL_ICG.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_GLOBAL_BBPLL_ICG = 0x2000000
	// Position of TIE_HIGH_GLOBAL_XTAL_ICG field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_GLOBAL_XTAL_ICG_Pos = 0x1a
	// Bit mask of TIE_HIGH_GLOBAL_XTAL_ICG field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_GLOBAL_XTAL_ICG_Msk = 0x4000000
	// Bit TIE_HIGH_GLOBAL_XTAL_ICG.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_GLOBAL_XTAL_ICG = 0x4000000
	// Position of TIE_HIGH_I2C_RETENTION field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_I2C_RETENTION_Pos = 0x1b
	// Bit mask of TIE_HIGH_I2C_RETENTION field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_I2C_RETENTION_Msk = 0x8000000
	// Bit TIE_HIGH_I2C_RETENTION.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_I2C_RETENTION = 0x8000000
	// Position of TIE_HIGH_XPD_BB_I2C field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_XPD_BB_I2C_Pos = 0x1c
	// Bit mask of TIE_HIGH_XPD_BB_I2C field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_XPD_BB_I2C_Msk = 0x10000000
	// Bit TIE_HIGH_XPD_BB_I2C.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_XPD_BB_I2C = 0x10000000
	// Position of TIE_HIGH_XPD_BBPLL_I2C field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_XPD_BBPLL_I2C_Pos = 0x1d
	// Bit mask of TIE_HIGH_XPD_BBPLL_I2C field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_XPD_BBPLL_I2C_Msk = 0x20000000
	// Bit TIE_HIGH_XPD_BBPLL_I2C.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_XPD_BBPLL_I2C = 0x20000000
	// Position of TIE_HIGH_XPD_BBPLL field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_XPD_BBPLL_Pos = 0x1e
	// Bit mask of TIE_HIGH_XPD_BBPLL field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_XPD_BBPLL_Msk = 0x40000000
	// Bit TIE_HIGH_XPD_BBPLL.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_XPD_BBPLL = 0x40000000
	// Position of TIE_HIGH_XPD_XTAL field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_XPD_XTAL_Pos = 0x1f
	// Bit mask of TIE_HIGH_XPD_XTAL field.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_XPD_XTAL_Msk = 0x80000000
	// Bit TIE_HIGH_XPD_XTAL.
	PMU_IMM_HP_CK_POWER_TIE_HIGH_XPD_XTAL = 0x80000000

	// IMM_SLEEP_SYSCLK: need_des
	// Position of UPDATE_DIG_ICG_SWITCH field.
	PMU_IMM_SLEEP_SYSCLK_UPDATE_DIG_ICG_SWITCH_Pos = 0x1c
	// Bit mask of UPDATE_DIG_ICG_SWITCH field.
	PMU_IMM_SLEEP_SYSCLK_UPDATE_DIG_ICG_SWITCH_Msk = 0x10000000
	// Bit UPDATE_DIG_ICG_SWITCH.
	PMU_IMM_SLEEP_SYSCLK_UPDATE_DIG_ICG_SWITCH = 0x10000000
	// Position of TIE_LOW_ICG_SLP_SEL field.
	PMU_IMM_SLEEP_SYSCLK_TIE_LOW_ICG_SLP_SEL_Pos = 0x1d
	// Bit mask of TIE_LOW_ICG_SLP_SEL field.
	PMU_IMM_SLEEP_SYSCLK_TIE_LOW_ICG_SLP_SEL_Msk = 0x20000000
	// Bit TIE_LOW_ICG_SLP_SEL.
	PMU_IMM_SLEEP_SYSCLK_TIE_LOW_ICG_SLP_SEL = 0x20000000
	// Position of TIE_HIGH_ICG_SLP_SEL field.
	PMU_IMM_SLEEP_SYSCLK_TIE_HIGH_ICG_SLP_SEL_Pos = 0x1e
	// Bit mask of TIE_HIGH_ICG_SLP_SEL field.
	PMU_IMM_SLEEP_SYSCLK_TIE_HIGH_ICG_SLP_SEL_Msk = 0x40000000
	// Bit TIE_HIGH_ICG_SLP_SEL.
	PMU_IMM_SLEEP_SYSCLK_TIE_HIGH_ICG_SLP_SEL = 0x40000000
	// Position of UPDATE_DIG_SYS_CLK_SEL field.
	PMU_IMM_SLEEP_SYSCLK_UPDATE_DIG_SYS_CLK_SEL_Pos = 0x1f
	// Bit mask of UPDATE_DIG_SYS_CLK_SEL field.
	PMU_IMM_SLEEP_SYSCLK_UPDATE_DIG_SYS_CLK_SEL_Msk = 0x80000000
	// Bit UPDATE_DIG_SYS_CLK_SEL.
	PMU_IMM_SLEEP_SYSCLK_UPDATE_DIG_SYS_CLK_SEL = 0x80000000

	// IMM_HP_FUNC_ICG: need_des
	// Position of UPDATE_DIG_ICG_FUNC_EN field.
	PMU_IMM_HP_FUNC_ICG_UPDATE_DIG_ICG_FUNC_EN_Pos = 0x1f
	// Bit mask of UPDATE_DIG_ICG_FUNC_EN field.
	PMU_IMM_HP_FUNC_ICG_UPDATE_DIG_ICG_FUNC_EN_Msk = 0x80000000
	// Bit UPDATE_DIG_ICG_FUNC_EN.
	PMU_IMM_HP_FUNC_ICG_UPDATE_DIG_ICG_FUNC_EN = 0x80000000

	// IMM_HP_APB_ICG: need_des
	// Position of UPDATE_DIG_ICG_APB_EN field.
	PMU_IMM_HP_APB_ICG_UPDATE_DIG_ICG_APB_EN_Pos = 0x1f
	// Bit mask of UPDATE_DIG_ICG_APB_EN field.
	PMU_IMM_HP_APB_ICG_UPDATE_DIG_ICG_APB_EN_Msk = 0x80000000
	// Bit UPDATE_DIG_ICG_APB_EN.
	PMU_IMM_HP_APB_ICG_UPDATE_DIG_ICG_APB_EN = 0x80000000

	// IMM_MODEM_ICG: need_des
	// Position of UPDATE_DIG_ICG_MODEM_EN field.
	PMU_IMM_MODEM_ICG_UPDATE_DIG_ICG_MODEM_EN_Pos = 0x1f
	// Bit mask of UPDATE_DIG_ICG_MODEM_EN field.
	PMU_IMM_MODEM_ICG_UPDATE_DIG_ICG_MODEM_EN_Msk = 0x80000000
	// Bit UPDATE_DIG_ICG_MODEM_EN.
	PMU_IMM_MODEM_ICG_UPDATE_DIG_ICG_MODEM_EN = 0x80000000

	// IMM_LP_ICG: need_des
	// Position of TIE_LOW_LP_ROOTCLK_SEL field.
	PMU_IMM_LP_ICG_TIE_LOW_LP_ROOTCLK_SEL_Pos = 0x1e
	// Bit mask of TIE_LOW_LP_ROOTCLK_SEL field.
	PMU_IMM_LP_ICG_TIE_LOW_LP_ROOTCLK_SEL_Msk = 0x40000000
	// Bit TIE_LOW_LP_ROOTCLK_SEL.
	PMU_IMM_LP_ICG_TIE_LOW_LP_ROOTCLK_SEL = 0x40000000
	// Position of TIE_HIGH_LP_ROOTCLK_SEL field.
	PMU_IMM_LP_ICG_TIE_HIGH_LP_ROOTCLK_SEL_Pos = 0x1f
	// Bit mask of TIE_HIGH_LP_ROOTCLK_SEL field.
	PMU_IMM_LP_ICG_TIE_HIGH_LP_ROOTCLK_SEL_Msk = 0x80000000
	// Bit TIE_HIGH_LP_ROOTCLK_SEL.
	PMU_IMM_LP_ICG_TIE_HIGH_LP_ROOTCLK_SEL = 0x80000000

	// IMM_PAD_HOLD_ALL: need_des
	// Position of TIE_HIGH_LP_PAD_HOLD_ALL field.
	PMU_IMM_PAD_HOLD_ALL_TIE_HIGH_LP_PAD_HOLD_ALL_Pos = 0x1c
	// Bit mask of TIE_HIGH_LP_PAD_HOLD_ALL field.
	PMU_IMM_PAD_HOLD_ALL_TIE_HIGH_LP_PAD_HOLD_ALL_Msk = 0x10000000
	// Bit TIE_HIGH_LP_PAD_HOLD_ALL.
	PMU_IMM_PAD_HOLD_ALL_TIE_HIGH_LP_PAD_HOLD_ALL = 0x10000000
	// Position of TIE_LOW_LP_PAD_HOLD_ALL field.
	PMU_IMM_PAD_HOLD_ALL_TIE_LOW_LP_PAD_HOLD_ALL_Pos = 0x1d
	// Bit mask of TIE_LOW_LP_PAD_HOLD_ALL field.
	PMU_IMM_PAD_HOLD_ALL_TIE_LOW_LP_PAD_HOLD_ALL_Msk = 0x20000000
	// Bit TIE_LOW_LP_PAD_HOLD_ALL.
	PMU_IMM_PAD_HOLD_ALL_TIE_LOW_LP_PAD_HOLD_ALL = 0x20000000
	// Position of TIE_HIGH_HP_PAD_HOLD_ALL field.
	PMU_IMM_PAD_HOLD_ALL_TIE_HIGH_HP_PAD_HOLD_ALL_Pos = 0x1e
	// Bit mask of TIE_HIGH_HP_PAD_HOLD_ALL field.
	PMU_IMM_PAD_HOLD_ALL_TIE_HIGH_HP_PAD_HOLD_ALL_Msk = 0x40000000
	// Bit TIE_HIGH_HP_PAD_HOLD_ALL.
	PMU_IMM_PAD_HOLD_ALL_TIE_HIGH_HP_PAD_HOLD_ALL = 0x40000000
	// Position of TIE_LOW_HP_PAD_HOLD_ALL field.
	PMU_IMM_PAD_HOLD_ALL_TIE_LOW_HP_PAD_HOLD_ALL_Pos = 0x1f
	// Bit mask of TIE_LOW_HP_PAD_HOLD_ALL field.
	PMU_IMM_PAD_HOLD_ALL_TIE_LOW_HP_PAD_HOLD_ALL_Msk = 0x80000000
	// Bit TIE_LOW_HP_PAD_HOLD_ALL.
	PMU_IMM_PAD_HOLD_ALL_TIE_LOW_HP_PAD_HOLD_ALL = 0x80000000

	// IMM_I2C_ISO: need_des
	// Position of TIE_HIGH_I2C_ISO_EN field.
	PMU_IMM_I2C_ISO_TIE_HIGH_I2C_ISO_EN_Pos = 0x1e
	// Bit mask of TIE_HIGH_I2C_ISO_EN field.
	PMU_IMM_I2C_ISO_TIE_HIGH_I2C_ISO_EN_Msk = 0x40000000
	// Bit TIE_HIGH_I2C_ISO_EN.
	PMU_IMM_I2C_ISO_TIE_HIGH_I2C_ISO_EN = 0x40000000
	// Position of TIE_LOW_I2C_ISO_EN field.
	PMU_IMM_I2C_ISO_TIE_LOW_I2C_ISO_EN_Pos = 0x1f
	// Bit mask of TIE_LOW_I2C_ISO_EN field.
	PMU_IMM_I2C_ISO_TIE_LOW_I2C_ISO_EN_Msk = 0x80000000
	// Bit TIE_LOW_I2C_ISO_EN.
	PMU_IMM_I2C_ISO_TIE_LOW_I2C_ISO_EN = 0x80000000

	// POWER_WAIT_TIMER0: need_des
	// Position of DG_HP_POWERDOWN_TIMER field.
	PMU_POWER_WAIT_TIMER0_DG_HP_POWERDOWN_TIMER_Pos = 0x5
	// Bit mask of DG_HP_POWERDOWN_TIMER field.
	PMU_POWER_WAIT_TIMER0_DG_HP_POWERDOWN_TIMER_Msk = 0x3fe0
	// Position of DG_HP_POWERUP_TIMER field.
	PMU_POWER_WAIT_TIMER0_DG_HP_POWERUP_TIMER_Pos = 0xe
	// Bit mask of DG_HP_POWERUP_TIMER field.
	PMU_POWER_WAIT_TIMER0_DG_HP_POWERUP_TIMER_Msk = 0x7fc000
	// Position of DG_HP_WAIT_TIMER field.
	PMU_POWER_WAIT_TIMER0_DG_HP_WAIT_TIMER_Pos = 0x17
	// Bit mask of DG_HP_WAIT_TIMER field.
	PMU_POWER_WAIT_TIMER0_DG_HP_WAIT_TIMER_Msk = 0xff800000

	// POWER_WAIT_TIMER1: need_des
	// Position of DG_LP_POWERDOWN_TIMER field.
	PMU_POWER_WAIT_TIMER1_DG_LP_POWERDOWN_TIMER_Pos = 0x9
	// Bit mask of DG_LP_POWERDOWN_TIMER field.
	PMU_POWER_WAIT_TIMER1_DG_LP_POWERDOWN_TIMER_Msk = 0xfe00
	// Position of DG_LP_POWERUP_TIMER field.
	PMU_POWER_WAIT_TIMER1_DG_LP_POWERUP_TIMER_Pos = 0x10
	// Bit mask of DG_LP_POWERUP_TIMER field.
	PMU_POWER_WAIT_TIMER1_DG_LP_POWERUP_TIMER_Msk = 0x7f0000
	// Position of DG_LP_WAIT_TIMER field.
	PMU_POWER_WAIT_TIMER1_DG_LP_WAIT_TIMER_Pos = 0x17
	// Bit mask of DG_LP_WAIT_TIMER field.
	PMU_POWER_WAIT_TIMER1_DG_LP_WAIT_TIMER_Msk = 0xff800000

	// POWER_PD_TOP_CNTL: need_des
	// Position of FORCE_TOP_RESET field.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_RESET_Pos = 0x0
	// Bit mask of FORCE_TOP_RESET field.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_RESET_Msk = 0x1
	// Bit FORCE_TOP_RESET.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_RESET = 0x1
	// Position of FORCE_TOP_ISO field.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_ISO_Pos = 0x1
	// Bit mask of FORCE_TOP_ISO field.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_ISO_Msk = 0x2
	// Bit FORCE_TOP_ISO.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_ISO = 0x2
	// Position of FORCE_TOP_PU field.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_PU_Pos = 0x2
	// Bit mask of FORCE_TOP_PU field.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_PU_Msk = 0x4
	// Bit FORCE_TOP_PU.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_PU = 0x4
	// Position of FORCE_TOP_NO_RESET field.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_NO_RESET_Pos = 0x3
	// Bit mask of FORCE_TOP_NO_RESET field.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_NO_RESET_Msk = 0x8
	// Bit FORCE_TOP_NO_RESET.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_NO_RESET = 0x8
	// Position of FORCE_TOP_NO_ISO field.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_NO_ISO_Pos = 0x4
	// Bit mask of FORCE_TOP_NO_ISO field.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_NO_ISO_Msk = 0x10
	// Bit FORCE_TOP_NO_ISO.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_NO_ISO = 0x10
	// Position of FORCE_TOP_PD field.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_PD_Pos = 0x5
	// Bit mask of FORCE_TOP_PD field.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_PD_Msk = 0x20
	// Bit FORCE_TOP_PD.
	PMU_POWER_PD_TOP_CNTL_FORCE_TOP_PD = 0x20
	// Position of PD_TOP_MASK field.
	PMU_POWER_PD_TOP_CNTL_PD_TOP_MASK_Pos = 0x6
	// Bit mask of PD_TOP_MASK field.
	PMU_POWER_PD_TOP_CNTL_PD_TOP_MASK_Msk = 0x7c0
	// Position of PD_TOP_PD_MASK field.
	PMU_POWER_PD_TOP_CNTL_PD_TOP_PD_MASK_Pos = 0x1b
	// Bit mask of PD_TOP_PD_MASK field.
	PMU_POWER_PD_TOP_CNTL_PD_TOP_PD_MASK_Msk = 0xf8000000

	// POWER_PD_HPAON_CNTL: need_des
	// Position of FORCE_HP_AON_RESET field.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_RESET_Pos = 0x0
	// Bit mask of FORCE_HP_AON_RESET field.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_RESET_Msk = 0x1
	// Bit FORCE_HP_AON_RESET.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_RESET = 0x1
	// Position of FORCE_HP_AON_ISO field.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_ISO_Pos = 0x1
	// Bit mask of FORCE_HP_AON_ISO field.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_ISO_Msk = 0x2
	// Bit FORCE_HP_AON_ISO.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_ISO = 0x2
	// Position of FORCE_HP_AON_PU field.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_PU_Pos = 0x2
	// Bit mask of FORCE_HP_AON_PU field.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_PU_Msk = 0x4
	// Bit FORCE_HP_AON_PU.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_PU = 0x4
	// Position of FORCE_HP_AON_NO_RESET field.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_NO_RESET_Pos = 0x3
	// Bit mask of FORCE_HP_AON_NO_RESET field.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_NO_RESET_Msk = 0x8
	// Bit FORCE_HP_AON_NO_RESET.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_NO_RESET = 0x8
	// Position of FORCE_HP_AON_NO_ISO field.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_NO_ISO_Pos = 0x4
	// Bit mask of FORCE_HP_AON_NO_ISO field.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_NO_ISO_Msk = 0x10
	// Bit FORCE_HP_AON_NO_ISO.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_NO_ISO = 0x10
	// Position of FORCE_HP_AON_PD field.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_PD_Pos = 0x5
	// Bit mask of FORCE_HP_AON_PD field.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_PD_Msk = 0x20
	// Bit FORCE_HP_AON_PD.
	PMU_POWER_PD_HPAON_CNTL_FORCE_HP_AON_PD = 0x20
	// Position of PD_HP_AON_MASK field.
	PMU_POWER_PD_HPAON_CNTL_PD_HP_AON_MASK_Pos = 0x6
	// Bit mask of PD_HP_AON_MASK field.
	PMU_POWER_PD_HPAON_CNTL_PD_HP_AON_MASK_Msk = 0x7c0
	// Position of PD_HP_AON_PD_MASK field.
	PMU_POWER_PD_HPAON_CNTL_PD_HP_AON_PD_MASK_Pos = 0x1b
	// Bit mask of PD_HP_AON_PD_MASK field.
	PMU_POWER_PD_HPAON_CNTL_PD_HP_AON_PD_MASK_Msk = 0xf8000000

	// POWER_PD_HPCPU_CNTL: need_des
	// Position of FORCE_HP_CPU_RESET field.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_RESET_Pos = 0x0
	// Bit mask of FORCE_HP_CPU_RESET field.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_RESET_Msk = 0x1
	// Bit FORCE_HP_CPU_RESET.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_RESET = 0x1
	// Position of FORCE_HP_CPU_ISO field.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_ISO_Pos = 0x1
	// Bit mask of FORCE_HP_CPU_ISO field.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_ISO_Msk = 0x2
	// Bit FORCE_HP_CPU_ISO.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_ISO = 0x2
	// Position of FORCE_HP_CPU_PU field.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_PU_Pos = 0x2
	// Bit mask of FORCE_HP_CPU_PU field.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_PU_Msk = 0x4
	// Bit FORCE_HP_CPU_PU.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_PU = 0x4
	// Position of FORCE_HP_CPU_NO_RESET field.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_NO_RESET_Pos = 0x3
	// Bit mask of FORCE_HP_CPU_NO_RESET field.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_NO_RESET_Msk = 0x8
	// Bit FORCE_HP_CPU_NO_RESET.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_NO_RESET = 0x8
	// Position of FORCE_HP_CPU_NO_ISO field.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_NO_ISO_Pos = 0x4
	// Bit mask of FORCE_HP_CPU_NO_ISO field.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_NO_ISO_Msk = 0x10
	// Bit FORCE_HP_CPU_NO_ISO.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_NO_ISO = 0x10
	// Position of FORCE_HP_CPU_PD field.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_PD_Pos = 0x5
	// Bit mask of FORCE_HP_CPU_PD field.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_PD_Msk = 0x20
	// Bit FORCE_HP_CPU_PD.
	PMU_POWER_PD_HPCPU_CNTL_FORCE_HP_CPU_PD = 0x20
	// Position of PD_HP_CPU_MASK field.
	PMU_POWER_PD_HPCPU_CNTL_PD_HP_CPU_MASK_Pos = 0x6
	// Bit mask of PD_HP_CPU_MASK field.
	PMU_POWER_PD_HPCPU_CNTL_PD_HP_CPU_MASK_Msk = 0x7c0
	// Position of PD_HP_CPU_PD_MASK field.
	PMU_POWER_PD_HPCPU_CNTL_PD_HP_CPU_PD_MASK_Pos = 0x1b
	// Bit mask of PD_HP_CPU_PD_MASK field.
	PMU_POWER_PD_HPCPU_CNTL_PD_HP_CPU_PD_MASK_Msk = 0xf8000000

	// POWER_PD_HPPERI_RESERVE: need_des
	// Position of HP_PERI_RESERVE field.
	PMU_POWER_PD_HPPERI_RESERVE_HP_PERI_RESERVE_Pos = 0x0
	// Bit mask of HP_PERI_RESERVE field.
	PMU_POWER_PD_HPPERI_RESERVE_HP_PERI_RESERVE_Msk = 0xffffffff

	// POWER_PD_HPWIFI_CNTL: need_des
	// Position of FORCE_HP_WIFI_RESET field.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_RESET_Pos = 0x0
	// Bit mask of FORCE_HP_WIFI_RESET field.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_RESET_Msk = 0x1
	// Bit FORCE_HP_WIFI_RESET.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_RESET = 0x1
	// Position of FORCE_HP_WIFI_ISO field.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_ISO_Pos = 0x1
	// Bit mask of FORCE_HP_WIFI_ISO field.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_ISO_Msk = 0x2
	// Bit FORCE_HP_WIFI_ISO.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_ISO = 0x2
	// Position of FORCE_HP_WIFI_PU field.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_PU_Pos = 0x2
	// Bit mask of FORCE_HP_WIFI_PU field.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_PU_Msk = 0x4
	// Bit FORCE_HP_WIFI_PU.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_PU = 0x4
	// Position of FORCE_HP_WIFI_NO_RESET field.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_NO_RESET_Pos = 0x3
	// Bit mask of FORCE_HP_WIFI_NO_RESET field.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_NO_RESET_Msk = 0x8
	// Bit FORCE_HP_WIFI_NO_RESET.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_NO_RESET = 0x8
	// Position of FORCE_HP_WIFI_NO_ISO field.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_NO_ISO_Pos = 0x4
	// Bit mask of FORCE_HP_WIFI_NO_ISO field.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_NO_ISO_Msk = 0x10
	// Bit FORCE_HP_WIFI_NO_ISO.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_NO_ISO = 0x10
	// Position of FORCE_HP_WIFI_PD field.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_PD_Pos = 0x5
	// Bit mask of FORCE_HP_WIFI_PD field.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_PD_Msk = 0x20
	// Bit FORCE_HP_WIFI_PD.
	PMU_POWER_PD_HPWIFI_CNTL_FORCE_HP_WIFI_PD = 0x20
	// Position of PD_HP_WIFI_MASK field.
	PMU_POWER_PD_HPWIFI_CNTL_PD_HP_WIFI_MASK_Pos = 0x6
	// Bit mask of PD_HP_WIFI_MASK field.
	PMU_POWER_PD_HPWIFI_CNTL_PD_HP_WIFI_MASK_Msk = 0x7c0
	// Position of PD_HP_WIFI_PD_MASK field.
	PMU_POWER_PD_HPWIFI_CNTL_PD_HP_WIFI_PD_MASK_Pos = 0x1b
	// Bit mask of PD_HP_WIFI_PD_MASK field.
	PMU_POWER_PD_HPWIFI_CNTL_PD_HP_WIFI_PD_MASK_Msk = 0xf8000000

	// POWER_PD_LPPERI_CNTL: need_des
	// Position of FORCE_LP_PERI_RESET field.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_RESET_Pos = 0x0
	// Bit mask of FORCE_LP_PERI_RESET field.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_RESET_Msk = 0x1
	// Bit FORCE_LP_PERI_RESET.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_RESET = 0x1
	// Position of FORCE_LP_PERI_ISO field.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_ISO_Pos = 0x1
	// Bit mask of FORCE_LP_PERI_ISO field.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_ISO_Msk = 0x2
	// Bit FORCE_LP_PERI_ISO.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_ISO = 0x2
	// Position of FORCE_LP_PERI_PU field.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_PU_Pos = 0x2
	// Bit mask of FORCE_LP_PERI_PU field.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_PU_Msk = 0x4
	// Bit FORCE_LP_PERI_PU.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_PU = 0x4
	// Position of FORCE_LP_PERI_NO_RESET field.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_NO_RESET_Pos = 0x3
	// Bit mask of FORCE_LP_PERI_NO_RESET field.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_NO_RESET_Msk = 0x8
	// Bit FORCE_LP_PERI_NO_RESET.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_NO_RESET = 0x8
	// Position of FORCE_LP_PERI_NO_ISO field.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_NO_ISO_Pos = 0x4
	// Bit mask of FORCE_LP_PERI_NO_ISO field.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_NO_ISO_Msk = 0x10
	// Bit FORCE_LP_PERI_NO_ISO.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_NO_ISO = 0x10
	// Position of FORCE_LP_PERI_PD field.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_PD_Pos = 0x5
	// Bit mask of FORCE_LP_PERI_PD field.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_PD_Msk = 0x20
	// Bit FORCE_LP_PERI_PD.
	PMU_POWER_PD_LPPERI_CNTL_FORCE_LP_PERI_PD = 0x20

	// POWER_PD_MEM_CNTL: need_des
	// Position of FORCE_HP_MEM_ISO field.
	PMU_POWER_PD_MEM_CNTL_FORCE_HP_MEM_ISO_Pos = 0x0
	// Bit mask of FORCE_HP_MEM_ISO field.
	PMU_POWER_PD_MEM_CNTL_FORCE_HP_MEM_ISO_Msk = 0xf
	// Position of FORCE_HP_MEM_PD field.
	PMU_POWER_PD_MEM_CNTL_FORCE_HP_MEM_PD_Pos = 0x4
	// Bit mask of FORCE_HP_MEM_PD field.
	PMU_POWER_PD_MEM_CNTL_FORCE_HP_MEM_PD_Msk = 0xf0
	// Position of FORCE_HP_MEM_NO_ISO field.
	PMU_POWER_PD_MEM_CNTL_FORCE_HP_MEM_NO_ISO_Pos = 0x18
	// Bit mask of FORCE_HP_MEM_NO_ISO field.
	PMU_POWER_PD_MEM_CNTL_FORCE_HP_MEM_NO_ISO_Msk = 0xf000000
	// Position of FORCE_HP_MEM_PU field.
	PMU_POWER_PD_MEM_CNTL_FORCE_HP_MEM_PU_Pos = 0x1c
	// Bit mask of FORCE_HP_MEM_PU field.
	PMU_POWER_PD_MEM_CNTL_FORCE_HP_MEM_PU_Msk = 0xf0000000

	// POWER_PD_MEM_MASK: need_des
	// Position of PD_HP_MEM2_PD_MASK field.
	PMU_POWER_PD_MEM_MASK_PD_HP_MEM2_PD_MASK_Pos = 0x0
	// Bit mask of PD_HP_MEM2_PD_MASK field.
	PMU_POWER_PD_MEM_MASK_PD_HP_MEM2_PD_MASK_Msk = 0x1f
	// Position of PD_HP_MEM1_PD_MASK field.
	PMU_POWER_PD_MEM_MASK_PD_HP_MEM1_PD_MASK_Pos = 0x5
	// Bit mask of PD_HP_MEM1_PD_MASK field.
	PMU_POWER_PD_MEM_MASK_PD_HP_MEM1_PD_MASK_Msk = 0x3e0
	// Position of PD_HP_MEM0_PD_MASK field.
	PMU_POWER_PD_MEM_MASK_PD_HP_MEM0_PD_MASK_Pos = 0xa
	// Bit mask of PD_HP_MEM0_PD_MASK field.
	PMU_POWER_PD_MEM_MASK_PD_HP_MEM0_PD_MASK_Msk = 0x7c00
	// Position of PD_HP_MEM2_MASK field.
	PMU_POWER_PD_MEM_MASK_PD_HP_MEM2_MASK_Pos = 0x11
	// Bit mask of PD_HP_MEM2_MASK field.
	PMU_POWER_PD_MEM_MASK_PD_HP_MEM2_MASK_Msk = 0x3e0000
	// Position of PD_HP_MEM1_MASK field.
	PMU_POWER_PD_MEM_MASK_PD_HP_MEM1_MASK_Pos = 0x16
	// Bit mask of PD_HP_MEM1_MASK field.
	PMU_POWER_PD_MEM_MASK_PD_HP_MEM1_MASK_Msk = 0x7c00000
	// Position of PD_HP_MEM0_MASK field.
	PMU_POWER_PD_MEM_MASK_PD_HP_MEM0_MASK_Pos = 0x1b
	// Bit mask of PD_HP_MEM0_MASK field.
	PMU_POWER_PD_MEM_MASK_PD_HP_MEM0_MASK_Msk = 0xf8000000

	// POWER_HP_PAD: need_des
	// Position of FORCE_HP_PAD_NO_ISO_ALL field.
	PMU_POWER_HP_PAD_FORCE_HP_PAD_NO_ISO_ALL_Pos = 0x0
	// Bit mask of FORCE_HP_PAD_NO_ISO_ALL field.
	PMU_POWER_HP_PAD_FORCE_HP_PAD_NO_ISO_ALL_Msk = 0x1
	// Bit FORCE_HP_PAD_NO_ISO_ALL.
	PMU_POWER_HP_PAD_FORCE_HP_PAD_NO_ISO_ALL = 0x1
	// Position of FORCE_HP_PAD_ISO_ALL field.
	PMU_POWER_HP_PAD_FORCE_HP_PAD_ISO_ALL_Pos = 0x1
	// Bit mask of FORCE_HP_PAD_ISO_ALL field.
	PMU_POWER_HP_PAD_FORCE_HP_PAD_ISO_ALL_Msk = 0x2
	// Bit FORCE_HP_PAD_ISO_ALL.
	PMU_POWER_HP_PAD_FORCE_HP_PAD_ISO_ALL = 0x2

	// POWER_VDD_SPI_CNTL: need_des
	// Position of VDD_SPI_PWR_WAIT field.
	PMU_POWER_VDD_SPI_CNTL_VDD_SPI_PWR_WAIT_Pos = 0x12
	// Bit mask of VDD_SPI_PWR_WAIT field.
	PMU_POWER_VDD_SPI_CNTL_VDD_SPI_PWR_WAIT_Msk = 0x1ffc0000
	// Position of VDD_SPI_PWR_SW field.
	PMU_POWER_VDD_SPI_CNTL_VDD_SPI_PWR_SW_Pos = 0x1d
	// Bit mask of VDD_SPI_PWR_SW field.
	PMU_POWER_VDD_SPI_CNTL_VDD_SPI_PWR_SW_Msk = 0x60000000
	// Position of VDD_SPI_PWR_SEL_SW field.
	PMU_POWER_VDD_SPI_CNTL_VDD_SPI_PWR_SEL_SW_Pos = 0x1f
	// Bit mask of VDD_SPI_PWR_SEL_SW field.
	PMU_POWER_VDD_SPI_CNTL_VDD_SPI_PWR_SEL_SW_Msk = 0x80000000
	// Bit VDD_SPI_PWR_SEL_SW.
	PMU_POWER_VDD_SPI_CNTL_VDD_SPI_PWR_SEL_SW = 0x80000000

	// POWER_CK_WAIT_CNTL: need_des
	// Position of WAIT_XTL_STABLE field.
	PMU_POWER_CK_WAIT_CNTL_WAIT_XTL_STABLE_Pos = 0x0
	// Bit mask of WAIT_XTL_STABLE field.
	PMU_POWER_CK_WAIT_CNTL_WAIT_XTL_STABLE_Msk = 0xffff
	// Position of WAIT_PLL_STABLE field.
	PMU_POWER_CK_WAIT_CNTL_WAIT_PLL_STABLE_Pos = 0x10
	// Bit mask of WAIT_PLL_STABLE field.
	PMU_POWER_CK_WAIT_CNTL_WAIT_PLL_STABLE_Msk = 0xffff0000

	// SLP_WAKEUP_CNTL0: need_des
	// Position of SLEEP_REQ field.
	PMU_SLP_WAKEUP_CNTL0_SLEEP_REQ_Pos = 0x1f
	// Bit mask of SLEEP_REQ field.
	PMU_SLP_WAKEUP_CNTL0_SLEEP_REQ_Msk = 0x80000000
	// Bit SLEEP_REQ.
	PMU_SLP_WAKEUP_CNTL0_SLEEP_REQ = 0x80000000

	// SLP_WAKEUP_CNTL1: need_des
	// Position of SLEEP_REJECT_ENA field.
	PMU_SLP_WAKEUP_CNTL1_SLEEP_REJECT_ENA_Pos = 0x0
	// Bit mask of SLEEP_REJECT_ENA field.
	PMU_SLP_WAKEUP_CNTL1_SLEEP_REJECT_ENA_Msk = 0x7fffffff
	// Position of SLP_REJECT_EN field.
	PMU_SLP_WAKEUP_CNTL1_SLP_REJECT_EN_Pos = 0x1f
	// Bit mask of SLP_REJECT_EN field.
	PMU_SLP_WAKEUP_CNTL1_SLP_REJECT_EN_Msk = 0x80000000
	// Bit SLP_REJECT_EN.
	PMU_SLP_WAKEUP_CNTL1_SLP_REJECT_EN = 0x80000000

	// SLP_WAKEUP_CNTL2: need_des
	// Position of WAKEUP_ENA field.
	PMU_SLP_WAKEUP_CNTL2_WAKEUP_ENA_Pos = 0x0
	// Bit mask of WAKEUP_ENA field.
	PMU_SLP_WAKEUP_CNTL2_WAKEUP_ENA_Msk = 0xffffffff

	// SLP_WAKEUP_CNTL3: need_des
	// Position of LP_MIN_SLP_VAL field.
	PMU_SLP_WAKEUP_CNTL3_LP_MIN_SLP_VAL_Pos = 0x0
	// Bit mask of LP_MIN_SLP_VAL field.
	PMU_SLP_WAKEUP_CNTL3_LP_MIN_SLP_VAL_Msk = 0xff
	// Position of HP_MIN_SLP_VAL field.
	PMU_SLP_WAKEUP_CNTL3_HP_MIN_SLP_VAL_Pos = 0x8
	// Bit mask of HP_MIN_SLP_VAL field.
	PMU_SLP_WAKEUP_CNTL3_HP_MIN_SLP_VAL_Msk = 0xff00
	// Position of SLEEP_PRT_SEL field.
	PMU_SLP_WAKEUP_CNTL3_SLEEP_PRT_SEL_Pos = 0x10
	// Bit mask of SLEEP_PRT_SEL field.
	PMU_SLP_WAKEUP_CNTL3_SLEEP_PRT_SEL_Msk = 0x30000

	// SLP_WAKEUP_CNTL4: need_des
	// Position of SLP_REJECT_CAUSE_CLR field.
	PMU_SLP_WAKEUP_CNTL4_SLP_REJECT_CAUSE_CLR_Pos = 0x1f
	// Bit mask of SLP_REJECT_CAUSE_CLR field.
	PMU_SLP_WAKEUP_CNTL4_SLP_REJECT_CAUSE_CLR_Msk = 0x80000000
	// Bit SLP_REJECT_CAUSE_CLR.
	PMU_SLP_WAKEUP_CNTL4_SLP_REJECT_CAUSE_CLR = 0x80000000

	// SLP_WAKEUP_CNTL5: need_des
	// Position of MODEM_WAIT_TARGET field.
	PMU_SLP_WAKEUP_CNTL5_MODEM_WAIT_TARGET_Pos = 0x0
	// Bit mask of MODEM_WAIT_TARGET field.
	PMU_SLP_WAKEUP_CNTL5_MODEM_WAIT_TARGET_Msk = 0xfffff
	// Position of LP_ANA_WAIT_TARGET field.
	PMU_SLP_WAKEUP_CNTL5_LP_ANA_WAIT_TARGET_Pos = 0x18
	// Bit mask of LP_ANA_WAIT_TARGET field.
	PMU_SLP_WAKEUP_CNTL5_LP_ANA_WAIT_TARGET_Msk = 0xff000000

	// SLP_WAKEUP_CNTL6: need_des
	// Position of SOC_WAKEUP_WAIT field.
	PMU_SLP_WAKEUP_CNTL6_SOC_WAKEUP_WAIT_Pos = 0x0
	// Bit mask of SOC_WAKEUP_WAIT field.
	PMU_SLP_WAKEUP_CNTL6_SOC_WAKEUP_WAIT_Msk = 0xfffff
	// Position of SOC_WAKEUP_WAIT_CFG field.
	PMU_SLP_WAKEUP_CNTL6_SOC_WAKEUP_WAIT_CFG_Pos = 0x1e
	// Bit mask of SOC_WAKEUP_WAIT_CFG field.
	PMU_SLP_WAKEUP_CNTL6_SOC_WAKEUP_WAIT_CFG_Msk = 0xc0000000

	// SLP_WAKEUP_CNTL7: need_des
	// Position of ANA_WAIT_TARGET field.
	PMU_SLP_WAKEUP_CNTL7_ANA_WAIT_TARGET_Pos = 0x10
	// Bit mask of ANA_WAIT_TARGET field.
	PMU_SLP_WAKEUP_CNTL7_ANA_WAIT_TARGET_Msk = 0xffff0000

	// SLP_WAKEUP_STATUS0: need_des
	// Position of WAKEUP_CAUSE field.
	PMU_SLP_WAKEUP_STATUS0_WAKEUP_CAUSE_Pos = 0x0
	// Bit mask of WAKEUP_CAUSE field.
	PMU_SLP_WAKEUP_STATUS0_WAKEUP_CAUSE_Msk = 0xffffffff

	// SLP_WAKEUP_STATUS1: need_des
	// Position of REJECT_CAUSE field.
	PMU_SLP_WAKEUP_STATUS1_REJECT_CAUSE_Pos = 0x0
	// Bit mask of REJECT_CAUSE field.
	PMU_SLP_WAKEUP_STATUS1_REJECT_CAUSE_Msk = 0xffffffff

	// HP_CK_POWERON: need_des
	// Position of I2C_POR_WAIT_TARGET field.
	PMU_HP_CK_POWERON_I2C_POR_WAIT_TARGET_Pos = 0x0
	// Bit mask of I2C_POR_WAIT_TARGET field.
	PMU_HP_CK_POWERON_I2C_POR_WAIT_TARGET_Msk = 0xff

	// HP_CK_CNTL: need_des
	// Position of MODIFY_ICG_CNTL_WAIT field.
	PMU_HP_CK_CNTL_MODIFY_ICG_CNTL_WAIT_Pos = 0x0
	// Bit mask of MODIFY_ICG_CNTL_WAIT field.
	PMU_HP_CK_CNTL_MODIFY_ICG_CNTL_WAIT_Msk = 0xff
	// Position of SWITCH_ICG_CNTL_WAIT field.
	PMU_HP_CK_CNTL_SWITCH_ICG_CNTL_WAIT_Pos = 0x8
	// Bit mask of SWITCH_ICG_CNTL_WAIT field.
	PMU_HP_CK_CNTL_SWITCH_ICG_CNTL_WAIT_Msk = 0xff00

	// POR_STATUS: need_des
	// Position of POR_DONE field.
	PMU_POR_STATUS_POR_DONE_Pos = 0x1f
	// Bit mask of POR_DONE field.
	PMU_POR_STATUS_POR_DONE_Msk = 0x80000000
	// Bit POR_DONE.
	PMU_POR_STATUS_POR_DONE = 0x80000000

	// RF_PWC: need_des
	// Position of XPD_PERIF_I2C field.
	PMU_RF_PWC_XPD_PERIF_I2C_Pos = 0x1b
	// Bit mask of XPD_PERIF_I2C field.
	PMU_RF_PWC_XPD_PERIF_I2C_Msk = 0x8000000
	// Bit XPD_PERIF_I2C.
	PMU_RF_PWC_XPD_PERIF_I2C = 0x8000000
	// Position of XPD_RFTX_I2C field.
	PMU_RF_PWC_XPD_RFTX_I2C_Pos = 0x1c
	// Bit mask of XPD_RFTX_I2C field.
	PMU_RF_PWC_XPD_RFTX_I2C_Msk = 0x10000000
	// Bit XPD_RFTX_I2C.
	PMU_RF_PWC_XPD_RFTX_I2C = 0x10000000
	// Position of XPD_RFRX_I2C field.
	PMU_RF_PWC_XPD_RFRX_I2C_Pos = 0x1d
	// Bit mask of XPD_RFRX_I2C field.
	PMU_RF_PWC_XPD_RFRX_I2C_Msk = 0x20000000
	// Bit XPD_RFRX_I2C.
	PMU_RF_PWC_XPD_RFRX_I2C = 0x20000000
	// Position of XPD_RFPLL field.
	PMU_RF_PWC_XPD_RFPLL_Pos = 0x1e
	// Bit mask of XPD_RFPLL field.
	PMU_RF_PWC_XPD_RFPLL_Msk = 0x40000000
	// Bit XPD_RFPLL.
	PMU_RF_PWC_XPD_RFPLL = 0x40000000
	// Position of XPD_FORCE_RFPLL field.
	PMU_RF_PWC_XPD_FORCE_RFPLL_Pos = 0x1f
	// Bit mask of XPD_FORCE_RFPLL field.
	PMU_RF_PWC_XPD_FORCE_RFPLL_Msk = 0x80000000
	// Bit XPD_FORCE_RFPLL.
	PMU_RF_PWC_XPD_FORCE_RFPLL = 0x80000000

	// VDDBAT_CFG: need_des
	// Position of VDDBAT_MODE field.
	PMU_VDDBAT_CFG_VDDBAT_MODE_Pos = 0x0
	// Bit mask of VDDBAT_MODE field.
	PMU_VDDBAT_CFG_VDDBAT_MODE_Msk = 0x3
	// Position of VDDBAT_SW_UPDATE field.
	PMU_VDDBAT_CFG_VDDBAT_SW_UPDATE_Pos = 0x1f
	// Bit mask of VDDBAT_SW_UPDATE field.
	PMU_VDDBAT_CFG_VDDBAT_SW_UPDATE_Msk = 0x80000000
	// Bit VDDBAT_SW_UPDATE.
	PMU_VDDBAT_CFG_VDDBAT_SW_UPDATE = 0x80000000

	// BACKUP_CFG: need_des
	// Position of BACKUP_SYS_CLK_NO_DIV field.
	PMU_BACKUP_CFG_BACKUP_SYS_CLK_NO_DIV_Pos = 0x1f
	// Bit mask of BACKUP_SYS_CLK_NO_DIV field.
	PMU_BACKUP_CFG_BACKUP_SYS_CLK_NO_DIV_Msk = 0x80000000
	// Bit BACKUP_SYS_CLK_NO_DIV.
	PMU_BACKUP_CFG_BACKUP_SYS_CLK_NO_DIV = 0x80000000

	// INT_RAW: need_des
	// Position of LP_CPU_EXC_INT_RAW field.
	PMU_INT_RAW_LP_CPU_EXC_INT_RAW_Pos = 0x1b
	// Bit mask of LP_CPU_EXC_INT_RAW field.
	PMU_INT_RAW_LP_CPU_EXC_INT_RAW_Msk = 0x8000000
	// Bit LP_CPU_EXC_INT_RAW.
	PMU_INT_RAW_LP_CPU_EXC_INT_RAW = 0x8000000
	// Position of SDIO_IDLE_INT_RAW field.
	PMU_INT_RAW_SDIO_IDLE_INT_RAW_Pos = 0x1c
	// Bit mask of SDIO_IDLE_INT_RAW field.
	PMU_INT_RAW_SDIO_IDLE_INT_RAW_Msk = 0x10000000
	// Bit SDIO_IDLE_INT_RAW.
	PMU_INT_RAW_SDIO_IDLE_INT_RAW = 0x10000000
	// Position of SW_INT_RAW field.
	PMU_INT_RAW_SW_INT_RAW_Pos = 0x1d
	// Bit mask of SW_INT_RAW field.
	PMU_INT_RAW_SW_INT_RAW_Msk = 0x20000000
	// Bit SW_INT_RAW.
	PMU_INT_RAW_SW_INT_RAW = 0x20000000
	// Position of SOC_SLEEP_REJECT_INT_RAW field.
	PMU_INT_RAW_SOC_SLEEP_REJECT_INT_RAW_Pos = 0x1e
	// Bit mask of SOC_SLEEP_REJECT_INT_RAW field.
	PMU_INT_RAW_SOC_SLEEP_REJECT_INT_RAW_Msk = 0x40000000
	// Bit SOC_SLEEP_REJECT_INT_RAW.
	PMU_INT_RAW_SOC_SLEEP_REJECT_INT_RAW = 0x40000000
	// Position of SOC_WAKEUP_INT_RAW field.
	PMU_INT_RAW_SOC_WAKEUP_INT_RAW_Pos = 0x1f
	// Bit mask of SOC_WAKEUP_INT_RAW field.
	PMU_INT_RAW_SOC_WAKEUP_INT_RAW_Msk = 0x80000000
	// Bit SOC_WAKEUP_INT_RAW.
	PMU_INT_RAW_SOC_WAKEUP_INT_RAW = 0x80000000

	// HP_INT_ST: need_des
	// Position of LP_CPU_EXC_INT_ST field.
	PMU_HP_INT_ST_LP_CPU_EXC_INT_ST_Pos = 0x1b
	// Bit mask of LP_CPU_EXC_INT_ST field.
	PMU_HP_INT_ST_LP_CPU_EXC_INT_ST_Msk = 0x8000000
	// Bit LP_CPU_EXC_INT_ST.
	PMU_HP_INT_ST_LP_CPU_EXC_INT_ST = 0x8000000
	// Position of SDIO_IDLE_INT_ST field.
	PMU_HP_INT_ST_SDIO_IDLE_INT_ST_Pos = 0x1c
	// Bit mask of SDIO_IDLE_INT_ST field.
	PMU_HP_INT_ST_SDIO_IDLE_INT_ST_Msk = 0x10000000
	// Bit SDIO_IDLE_INT_ST.
	PMU_HP_INT_ST_SDIO_IDLE_INT_ST = 0x10000000
	// Position of SW_INT_ST field.
	PMU_HP_INT_ST_SW_INT_ST_Pos = 0x1d
	// Bit mask of SW_INT_ST field.
	PMU_HP_INT_ST_SW_INT_ST_Msk = 0x20000000
	// Bit SW_INT_ST.
	PMU_HP_INT_ST_SW_INT_ST = 0x20000000
	// Position of SOC_SLEEP_REJECT_INT_ST field.
	PMU_HP_INT_ST_SOC_SLEEP_REJECT_INT_ST_Pos = 0x1e
	// Bit mask of SOC_SLEEP_REJECT_INT_ST field.
	PMU_HP_INT_ST_SOC_SLEEP_REJECT_INT_ST_Msk = 0x40000000
	// Bit SOC_SLEEP_REJECT_INT_ST.
	PMU_HP_INT_ST_SOC_SLEEP_REJECT_INT_ST = 0x40000000
	// Position of SOC_WAKEUP_INT_ST field.
	PMU_HP_INT_ST_SOC_WAKEUP_INT_ST_Pos = 0x1f
	// Bit mask of SOC_WAKEUP_INT_ST field.
	PMU_HP_INT_ST_SOC_WAKEUP_INT_ST_Msk = 0x80000000
	// Bit SOC_WAKEUP_INT_ST.
	PMU_HP_INT_ST_SOC_WAKEUP_INT_ST = 0x80000000

	// HP_INT_ENA: need_des
	// Position of LP_CPU_EXC_INT_ENA field.
	PMU_HP_INT_ENA_LP_CPU_EXC_INT_ENA_Pos = 0x1b
	// Bit mask of LP_CPU_EXC_INT_ENA field.
	PMU_HP_INT_ENA_LP_CPU_EXC_INT_ENA_Msk = 0x8000000
	// Bit LP_CPU_EXC_INT_ENA.
	PMU_HP_INT_ENA_LP_CPU_EXC_INT_ENA = 0x8000000
	// Position of SDIO_IDLE_INT_ENA field.
	PMU_HP_INT_ENA_SDIO_IDLE_INT_ENA_Pos = 0x1c
	// Bit mask of SDIO_IDLE_INT_ENA field.
	PMU_HP_INT_ENA_SDIO_IDLE_INT_ENA_Msk = 0x10000000
	// Bit SDIO_IDLE_INT_ENA.
	PMU_HP_INT_ENA_SDIO_IDLE_INT_ENA = 0x10000000
	// Position of SW_INT_ENA field.
	PMU_HP_INT_ENA_SW_INT_ENA_Pos = 0x1d
	// Bit mask of SW_INT_ENA field.
	PMU_HP_INT_ENA_SW_INT_ENA_Msk = 0x20000000
	// Bit SW_INT_ENA.
	PMU_HP_INT_ENA_SW_INT_ENA = 0x20000000
	// Position of SOC_SLEEP_REJECT_INT_ENA field.
	PMU_HP_INT_ENA_SOC_SLEEP_REJECT_INT_ENA_Pos = 0x1e
	// Bit mask of SOC_SLEEP_REJECT_INT_ENA field.
	PMU_HP_INT_ENA_SOC_SLEEP_REJECT_INT_ENA_Msk = 0x40000000
	// Bit SOC_SLEEP_REJECT_INT_ENA.
	PMU_HP_INT_ENA_SOC_SLEEP_REJECT_INT_ENA = 0x40000000
	// Position of SOC_WAKEUP_INT_ENA field.
	PMU_HP_INT_ENA_SOC_WAKEUP_INT_ENA_Pos = 0x1f
	// Bit mask of SOC_WAKEUP_INT_ENA field.
	PMU_HP_INT_ENA_SOC_WAKEUP_INT_ENA_Msk = 0x80000000
	// Bit SOC_WAKEUP_INT_ENA.
	PMU_HP_INT_ENA_SOC_WAKEUP_INT_ENA = 0x80000000

	// HP_INT_CLR: need_des
	// Position of LP_CPU_EXC_INT_CLR field.
	PMU_HP_INT_CLR_LP_CPU_EXC_INT_CLR_Pos = 0x1b
	// Bit mask of LP_CPU_EXC_INT_CLR field.
	PMU_HP_INT_CLR_LP_CPU_EXC_INT_CLR_Msk = 0x8000000
	// Bit LP_CPU_EXC_INT_CLR.
	PMU_HP_INT_CLR_LP_CPU_EXC_INT_CLR = 0x8000000
	// Position of SDIO_IDLE_INT_CLR field.
	PMU_HP_INT_CLR_SDIO_IDLE_INT_CLR_Pos = 0x1c
	// Bit mask of SDIO_IDLE_INT_CLR field.
	PMU_HP_INT_CLR_SDIO_IDLE_INT_CLR_Msk = 0x10000000
	// Bit SDIO_IDLE_INT_CLR.
	PMU_HP_INT_CLR_SDIO_IDLE_INT_CLR = 0x10000000
	// Position of SW_INT_CLR field.
	PMU_HP_INT_CLR_SW_INT_CLR_Pos = 0x1d
	// Bit mask of SW_INT_CLR field.
	PMU_HP_INT_CLR_SW_INT_CLR_Msk = 0x20000000
	// Bit SW_INT_CLR.
	PMU_HP_INT_CLR_SW_INT_CLR = 0x20000000
	// Position of SOC_SLEEP_REJECT_INT_CLR field.
	PMU_HP_INT_CLR_SOC_SLEEP_REJECT_INT_CLR_Pos = 0x1e
	// Bit mask of SOC_SLEEP_REJECT_INT_CLR field.
	PMU_HP_INT_CLR_SOC_SLEEP_REJECT_INT_CLR_Msk = 0x40000000
	// Bit SOC_SLEEP_REJECT_INT_CLR.
	PMU_HP_INT_CLR_SOC_SLEEP_REJECT_INT_CLR = 0x40000000
	// Position of SOC_WAKEUP_INT_CLR field.
	PMU_HP_INT_CLR_SOC_WAKEUP_INT_CLR_Pos = 0x1f
	// Bit mask of SOC_WAKEUP_INT_CLR field.
	PMU_HP_INT_CLR_SOC_WAKEUP_INT_CLR_Msk = 0x80000000
	// Bit SOC_WAKEUP_INT_CLR.
	PMU_HP_INT_CLR_SOC_WAKEUP_INT_CLR = 0x80000000

	// LP_INT_RAW: need_des
	// Position of LP_CPU_WAKEUP_INT_RAW field.
	PMU_LP_INT_RAW_LP_CPU_WAKEUP_INT_RAW_Pos = 0x14
	// Bit mask of LP_CPU_WAKEUP_INT_RAW field.
	PMU_LP_INT_RAW_LP_CPU_WAKEUP_INT_RAW_Msk = 0x100000
	// Bit LP_CPU_WAKEUP_INT_RAW.
	PMU_LP_INT_RAW_LP_CPU_WAKEUP_INT_RAW = 0x100000
	// Position of MODEM_SWITCH_ACTIVE_END_INT_RAW field.
	PMU_LP_INT_RAW_MODEM_SWITCH_ACTIVE_END_INT_RAW_Pos = 0x15
	// Bit mask of MODEM_SWITCH_ACTIVE_END_INT_RAW field.
	PMU_LP_INT_RAW_MODEM_SWITCH_ACTIVE_END_INT_RAW_Msk = 0x200000
	// Bit MODEM_SWITCH_ACTIVE_END_INT_RAW.
	PMU_LP_INT_RAW_MODEM_SWITCH_ACTIVE_END_INT_RAW = 0x200000
	// Position of SLEEP_SWITCH_ACTIVE_END_INT_RAW field.
	PMU_LP_INT_RAW_SLEEP_SWITCH_ACTIVE_END_INT_RAW_Pos = 0x16
	// Bit mask of SLEEP_SWITCH_ACTIVE_END_INT_RAW field.
	PMU_LP_INT_RAW_SLEEP_SWITCH_ACTIVE_END_INT_RAW_Msk = 0x400000
	// Bit SLEEP_SWITCH_ACTIVE_END_INT_RAW.
	PMU_LP_INT_RAW_SLEEP_SWITCH_ACTIVE_END_INT_RAW = 0x400000
	// Position of SLEEP_SWITCH_MODEM_END_INT_RAW field.
	PMU_LP_INT_RAW_SLEEP_SWITCH_MODEM_END_INT_RAW_Pos = 0x17
	// Bit mask of SLEEP_SWITCH_MODEM_END_INT_RAW field.
	PMU_LP_INT_RAW_SLEEP_SWITCH_MODEM_END_INT_RAW_Msk = 0x800000
	// Bit SLEEP_SWITCH_MODEM_END_INT_RAW.
	PMU_LP_INT_RAW_SLEEP_SWITCH_MODEM_END_INT_RAW = 0x800000
	// Position of MODEM_SWITCH_SLEEP_END_INT_RAW field.
	PMU_LP_INT_RAW_MODEM_SWITCH_SLEEP_END_INT_RAW_Pos = 0x18
	// Bit mask of MODEM_SWITCH_SLEEP_END_INT_RAW field.
	PMU_LP_INT_RAW_MODEM_SWITCH_SLEEP_END_INT_RAW_Msk = 0x1000000
	// Bit MODEM_SWITCH_SLEEP_END_INT_RAW.
	PMU_LP_INT_RAW_MODEM_SWITCH_SLEEP_END_INT_RAW = 0x1000000
	// Position of ACTIVE_SWITCH_SLEEP_END_INT_RAW field.
	PMU_LP_INT_RAW_ACTIVE_SWITCH_SLEEP_END_INT_RAW_Pos = 0x19
	// Bit mask of ACTIVE_SWITCH_SLEEP_END_INT_RAW field.
	PMU_LP_INT_RAW_ACTIVE_SWITCH_SLEEP_END_INT_RAW_Msk = 0x2000000
	// Bit ACTIVE_SWITCH_SLEEP_END_INT_RAW.
	PMU_LP_INT_RAW_ACTIVE_SWITCH_SLEEP_END_INT_RAW = 0x2000000
	// Position of MODEM_SWITCH_ACTIVE_START_INT_RAW field.
	PMU_LP_INT_RAW_MODEM_SWITCH_ACTIVE_START_INT_RAW_Pos = 0x1a
	// Bit mask of MODEM_SWITCH_ACTIVE_START_INT_RAW field.
	PMU_LP_INT_RAW_MODEM_SWITCH_ACTIVE_START_INT_RAW_Msk = 0x4000000
	// Bit MODEM_SWITCH_ACTIVE_START_INT_RAW.
	PMU_LP_INT_RAW_MODEM_SWITCH_ACTIVE_START_INT_RAW = 0x4000000
	// Position of SLEEP_SWITCH_ACTIVE_START_INT_RAW field.
	PMU_LP_INT_RAW_SLEEP_SWITCH_ACTIVE_START_INT_RAW_Pos = 0x1b
	// Bit mask of SLEEP_SWITCH_ACTIVE_START_INT_RAW field.
	PMU_LP_INT_RAW_SLEEP_SWITCH_ACTIVE_START_INT_RAW_Msk = 0x8000000
	// Bit SLEEP_SWITCH_ACTIVE_START_INT_RAW.
	PMU_LP_INT_RAW_SLEEP_SWITCH_ACTIVE_START_INT_RAW = 0x8000000
	// Position of SLEEP_SWITCH_MODEM_START_INT_RAW field.
	PMU_LP_INT_RAW_SLEEP_SWITCH_MODEM_START_INT_RAW_Pos = 0x1c
	// Bit mask of SLEEP_SWITCH_MODEM_START_INT_RAW field.
	PMU_LP_INT_RAW_SLEEP_SWITCH_MODEM_START_INT_RAW_Msk = 0x10000000
	// Bit SLEEP_SWITCH_MODEM_START_INT_RAW.
	PMU_LP_INT_RAW_SLEEP_SWITCH_MODEM_START_INT_RAW = 0x10000000
	// Position of MODEM_SWITCH_SLEEP_START_INT_RAW field.
	PMU_LP_INT_RAW_MODEM_SWITCH_SLEEP_START_INT_RAW_Pos = 0x1d
	// Bit mask of MODEM_SWITCH_SLEEP_START_INT_RAW field.
	PMU_LP_INT_RAW_MODEM_SWITCH_SLEEP_START_INT_RAW_Msk = 0x20000000
	// Bit MODEM_SWITCH_SLEEP_START_INT_RAW.
	PMU_LP_INT_RAW_MODEM_SWITCH_SLEEP_START_INT_RAW = 0x20000000
	// Position of ACTIVE_SWITCH_SLEEP_START_INT_RAW field.
	PMU_LP_INT_RAW_ACTIVE_SWITCH_SLEEP_START_INT_RAW_Pos = 0x1e
	// Bit mask of ACTIVE_SWITCH_SLEEP_START_INT_RAW field.
	PMU_LP_INT_RAW_ACTIVE_SWITCH_SLEEP_START_INT_RAW_Msk = 0x40000000
	// Bit ACTIVE_SWITCH_SLEEP_START_INT_RAW.
	PMU_LP_INT_RAW_ACTIVE_SWITCH_SLEEP_START_INT_RAW = 0x40000000
	// Position of HP_SW_TRIGGER_INT_RAW field.
	PMU_LP_INT_RAW_HP_SW_TRIGGER_INT_RAW_Pos = 0x1f
	// Bit mask of HP_SW_TRIGGER_INT_RAW field.
	PMU_LP_INT_RAW_HP_SW_TRIGGER_INT_RAW_Msk = 0x80000000
	// Bit HP_SW_TRIGGER_INT_RAW.
	PMU_LP_INT_RAW_HP_SW_TRIGGER_INT_RAW = 0x80000000

	// LP_INT_ST: need_des
	// Position of LP_CPU_WAKEUP_INT_ST field.
	PMU_LP_INT_ST_LP_CPU_WAKEUP_INT_ST_Pos = 0x14
	// Bit mask of LP_CPU_WAKEUP_INT_ST field.
	PMU_LP_INT_ST_LP_CPU_WAKEUP_INT_ST_Msk = 0x100000
	// Bit LP_CPU_WAKEUP_INT_ST.
	PMU_LP_INT_ST_LP_CPU_WAKEUP_INT_ST = 0x100000
	// Position of MODEM_SWITCH_ACTIVE_END_INT_ST field.
	PMU_LP_INT_ST_MODEM_SWITCH_ACTIVE_END_INT_ST_Pos = 0x15
	// Bit mask of MODEM_SWITCH_ACTIVE_END_INT_ST field.
	PMU_LP_INT_ST_MODEM_SWITCH_ACTIVE_END_INT_ST_Msk = 0x200000
	// Bit MODEM_SWITCH_ACTIVE_END_INT_ST.
	PMU_LP_INT_ST_MODEM_SWITCH_ACTIVE_END_INT_ST = 0x200000
	// Position of SLEEP_SWITCH_ACTIVE_END_INT_ST field.
	PMU_LP_INT_ST_SLEEP_SWITCH_ACTIVE_END_INT_ST_Pos = 0x16
	// Bit mask of SLEEP_SWITCH_ACTIVE_END_INT_ST field.
	PMU_LP_INT_ST_SLEEP_SWITCH_ACTIVE_END_INT_ST_Msk = 0x400000
	// Bit SLEEP_SWITCH_ACTIVE_END_INT_ST.
	PMU_LP_INT_ST_SLEEP_SWITCH_ACTIVE_END_INT_ST = 0x400000
	// Position of SLEEP_SWITCH_MODEM_END_INT_ST field.
	PMU_LP_INT_ST_SLEEP_SWITCH_MODEM_END_INT_ST_Pos = 0x17
	// Bit mask of SLEEP_SWITCH_MODEM_END_INT_ST field.
	PMU_LP_INT_ST_SLEEP_SWITCH_MODEM_END_INT_ST_Msk = 0x800000
	// Bit SLEEP_SWITCH_MODEM_END_INT_ST.
	PMU_LP_INT_ST_SLEEP_SWITCH_MODEM_END_INT_ST = 0x800000
	// Position of MODEM_SWITCH_SLEEP_END_INT_ST field.
	PMU_LP_INT_ST_MODEM_SWITCH_SLEEP_END_INT_ST_Pos = 0x18
	// Bit mask of MODEM_SWITCH_SLEEP_END_INT_ST field.
	PMU_LP_INT_ST_MODEM_SWITCH_SLEEP_END_INT_ST_Msk = 0x1000000
	// Bit MODEM_SWITCH_SLEEP_END_INT_ST.
	PMU_LP_INT_ST_MODEM_SWITCH_SLEEP_END_INT_ST = 0x1000000
	// Position of ACTIVE_SWITCH_SLEEP_END_INT_ST field.
	PMU_LP_INT_ST_ACTIVE_SWITCH_SLEEP_END_INT_ST_Pos = 0x19
	// Bit mask of ACTIVE_SWITCH_SLEEP_END_INT_ST field.
	PMU_LP_INT_ST_ACTIVE_SWITCH_SLEEP_END_INT_ST_Msk = 0x2000000
	// Bit ACTIVE_SWITCH_SLEEP_END_INT_ST.
	PMU_LP_INT_ST_ACTIVE_SWITCH_SLEEP_END_INT_ST = 0x2000000
	// Position of MODEM_SWITCH_ACTIVE_START_INT_ST field.
	PMU_LP_INT_ST_MODEM_SWITCH_ACTIVE_START_INT_ST_Pos = 0x1a
	// Bit mask of MODEM_SWITCH_ACTIVE_START_INT_ST field.
	PMU_LP_INT_ST_MODEM_SWITCH_ACTIVE_START_INT_ST_Msk = 0x4000000
	// Bit MODEM_SWITCH_ACTIVE_START_INT_ST.
	PMU_LP_INT_ST_MODEM_SWITCH_ACTIVE_START_INT_ST = 0x4000000
	// Position of SLEEP_SWITCH_ACTIVE_START_INT_ST field.
	PMU_LP_INT_ST_SLEEP_SWITCH_ACTIVE_START_INT_ST_Pos = 0x1b
	// Bit mask of SLEEP_SWITCH_ACTIVE_START_INT_ST field.
	PMU_LP_INT_ST_SLEEP_SWITCH_ACTIVE_START_INT_ST_Msk = 0x8000000
	// Bit SLEEP_SWITCH_ACTIVE_START_INT_ST.
	PMU_LP_INT_ST_SLEEP_SWITCH_ACTIVE_START_INT_ST = 0x8000000
	// Position of SLEEP_SWITCH_MODEM_START_INT_ST field.
	PMU_LP_INT_ST_SLEEP_SWITCH_MODEM_START_INT_ST_Pos = 0x1c
	// Bit mask of SLEEP_SWITCH_MODEM_START_INT_ST field.
	PMU_LP_INT_ST_SLEEP_SWITCH_MODEM_START_INT_ST_Msk = 0x10000000
	// Bit SLEEP_SWITCH_MODEM_START_INT_ST.
	PMU_LP_INT_ST_SLEEP_SWITCH_MODEM_START_INT_ST = 0x10000000
	// Position of MODEM_SWITCH_SLEEP_START_INT_ST field.
	PMU_LP_INT_ST_MODEM_SWITCH_SLEEP_START_INT_ST_Pos = 0x1d
	// Bit mask of MODEM_SWITCH_SLEEP_START_INT_ST field.
	PMU_LP_INT_ST_MODEM_SWITCH_SLEEP_START_INT_ST_Msk = 0x20000000
	// Bit MODEM_SWITCH_SLEEP_START_INT_ST.
	PMU_LP_INT_ST_MODEM_SWITCH_SLEEP_START_INT_ST = 0x20000000
	// Position of ACTIVE_SWITCH_SLEEP_START_INT_ST field.
	PMU_LP_INT_ST_ACTIVE_SWITCH_SLEEP_START_INT_ST_Pos = 0x1e
	// Bit mask of ACTIVE_SWITCH_SLEEP_START_INT_ST field.
	PMU_LP_INT_ST_ACTIVE_SWITCH_SLEEP_START_INT_ST_Msk = 0x40000000
	// Bit ACTIVE_SWITCH_SLEEP_START_INT_ST.
	PMU_LP_INT_ST_ACTIVE_SWITCH_SLEEP_START_INT_ST = 0x40000000
	// Position of HP_SW_TRIGGER_INT_ST field.
	PMU_LP_INT_ST_HP_SW_TRIGGER_INT_ST_Pos = 0x1f
	// Bit mask of HP_SW_TRIGGER_INT_ST field.
	PMU_LP_INT_ST_HP_SW_TRIGGER_INT_ST_Msk = 0x80000000
	// Bit HP_SW_TRIGGER_INT_ST.
	PMU_LP_INT_ST_HP_SW_TRIGGER_INT_ST = 0x80000000

	// LP_INT_ENA: need_des
	// Position of LP_CPU_WAKEUP_INT_ENA field.
	PMU_LP_INT_ENA_LP_CPU_WAKEUP_INT_ENA_Pos = 0x14
	// Bit mask of LP_CPU_WAKEUP_INT_ENA field.
	PMU_LP_INT_ENA_LP_CPU_WAKEUP_INT_ENA_Msk = 0x100000
	// Bit LP_CPU_WAKEUP_INT_ENA.
	PMU_LP_INT_ENA_LP_CPU_WAKEUP_INT_ENA = 0x100000
	// Position of MODEM_SWITCH_ACTIVE_END_INT_ENA field.
	PMU_LP_INT_ENA_MODEM_SWITCH_ACTIVE_END_INT_ENA_Pos = 0x15
	// Bit mask of MODEM_SWITCH_ACTIVE_END_INT_ENA field.
	PMU_LP_INT_ENA_MODEM_SWITCH_ACTIVE_END_INT_ENA_Msk = 0x200000
	// Bit MODEM_SWITCH_ACTIVE_END_INT_ENA.
	PMU_LP_INT_ENA_MODEM_SWITCH_ACTIVE_END_INT_ENA = 0x200000
	// Position of SLEEP_SWITCH_ACTIVE_END_INT_ENA field.
	PMU_LP_INT_ENA_SLEEP_SWITCH_ACTIVE_END_INT_ENA_Pos = 0x16
	// Bit mask of SLEEP_SWITCH_ACTIVE_END_INT_ENA field.
	PMU_LP_INT_ENA_SLEEP_SWITCH_ACTIVE_END_INT_ENA_Msk = 0x400000
	// Bit SLEEP_SWITCH_ACTIVE_END_INT_ENA.
	PMU_LP_INT_ENA_SLEEP_SWITCH_ACTIVE_END_INT_ENA = 0x400000
	// Position of SLEEP_SWITCH_MODEM_END_INT_ENA field.
	PMU_LP_INT_ENA_SLEEP_SWITCH_MODEM_END_INT_ENA_Pos = 0x17
	// Bit mask of SLEEP_SWITCH_MODEM_END_INT_ENA field.
	PMU_LP_INT_ENA_SLEEP_SWITCH_MODEM_END_INT_ENA_Msk = 0x800000
	// Bit SLEEP_SWITCH_MODEM_END_INT_ENA.
	PMU_LP_INT_ENA_SLEEP_SWITCH_MODEM_END_INT_ENA = 0x800000
	// Position of MODEM_SWITCH_SLEEP_END_INT_ENA field.
	PMU_LP_INT_ENA_MODEM_SWITCH_SLEEP_END_INT_ENA_Pos = 0x18
	// Bit mask of MODEM_SWITCH_SLEEP_END_INT_ENA field.
	PMU_LP_INT_ENA_MODEM_SWITCH_SLEEP_END_INT_ENA_Msk = 0x1000000
	// Bit MODEM_SWITCH_SLEEP_END_INT_ENA.
	PMU_LP_INT_ENA_MODEM_SWITCH_SLEEP_END_INT_ENA = 0x1000000
	// Position of ACTIVE_SWITCH_SLEEP_END_INT_ENA field.
	PMU_LP_INT_ENA_ACTIVE_SWITCH_SLEEP_END_INT_ENA_Pos = 0x19
	// Bit mask of ACTIVE_SWITCH_SLEEP_END_INT_ENA field.
	PMU_LP_INT_ENA_ACTIVE_SWITCH_SLEEP_END_INT_ENA_Msk = 0x2000000
	// Bit ACTIVE_SWITCH_SLEEP_END_INT_ENA.
	PMU_LP_INT_ENA_ACTIVE_SWITCH_SLEEP_END_INT_ENA = 0x2000000
	// Position of MODEM_SWITCH_ACTIVE_START_INT_ENA field.
	PMU_LP_INT_ENA_MODEM_SWITCH_ACTIVE_START_INT_ENA_Pos = 0x1a
	// Bit mask of MODEM_SWITCH_ACTIVE_START_INT_ENA field.
	PMU_LP_INT_ENA_MODEM_SWITCH_ACTIVE_START_INT_ENA_Msk = 0x4000000
	// Bit MODEM_SWITCH_ACTIVE_START_INT_ENA.
	PMU_LP_INT_ENA_MODEM_SWITCH_ACTIVE_START_INT_ENA = 0x4000000
	// Position of SLEEP_SWITCH_ACTIVE_START_INT_ENA field.
	PMU_LP_INT_ENA_SLEEP_SWITCH_ACTIVE_START_INT_ENA_Pos = 0x1b
	// Bit mask of SLEEP_SWITCH_ACTIVE_START_INT_ENA field.
	PMU_LP_INT_ENA_SLEEP_SWITCH_ACTIVE_START_INT_ENA_Msk = 0x8000000
	// Bit SLEEP_SWITCH_ACTIVE_START_INT_ENA.
	PMU_LP_INT_ENA_SLEEP_SWITCH_ACTIVE_START_INT_ENA = 0x8000000
	// Position of SLEEP_SWITCH_MODEM_START_INT_ENA field.
	PMU_LP_INT_ENA_SLEEP_SWITCH_MODEM_START_INT_ENA_Pos = 0x1c
	// Bit mask of SLEEP_SWITCH_MODEM_START_INT_ENA field.
	PMU_LP_INT_ENA_SLEEP_SWITCH_MODEM_START_INT_ENA_Msk = 0x10000000
	// Bit SLEEP_SWITCH_MODEM_START_INT_ENA.
	PMU_LP_INT_ENA_SLEEP_SWITCH_MODEM_START_INT_ENA = 0x10000000
	// Position of MODEM_SWITCH_SLEEP_START_INT_ENA field.
	PMU_LP_INT_ENA_MODEM_SWITCH_SLEEP_START_INT_ENA_Pos = 0x1d
	// Bit mask of MODEM_SWITCH_SLEEP_START_INT_ENA field.
	PMU_LP_INT_ENA_MODEM_SWITCH_SLEEP_START_INT_ENA_Msk = 0x20000000
	// Bit MODEM_SWITCH_SLEEP_START_INT_ENA.
	PMU_LP_INT_ENA_MODEM_SWITCH_SLEEP_START_INT_ENA = 0x20000000
	// Position of ACTIVE_SWITCH_SLEEP_START_INT_ENA field.
	PMU_LP_INT_ENA_ACTIVE_SWITCH_SLEEP_START_INT_ENA_Pos = 0x1e
	// Bit mask of ACTIVE_SWITCH_SLEEP_START_INT_ENA field.
	PMU_LP_INT_ENA_ACTIVE_SWITCH_SLEEP_START_INT_ENA_Msk = 0x40000000
	// Bit ACTIVE_SWITCH_SLEEP_START_INT_ENA.
	PMU_LP_INT_ENA_ACTIVE_SWITCH_SLEEP_START_INT_ENA = 0x40000000
	// Position of HP_SW_TRIGGER_INT_ENA field.
	PMU_LP_INT_ENA_HP_SW_TRIGGER_INT_ENA_Pos = 0x1f
	// Bit mask of HP_SW_TRIGGER_INT_ENA field.
	PMU_LP_INT_ENA_HP_SW_TRIGGER_INT_ENA_Msk = 0x80000000
	// Bit HP_SW_TRIGGER_INT_ENA.
	PMU_LP_INT_ENA_HP_SW_TRIGGER_INT_ENA = 0x80000000

	// LP_INT_CLR: need_des
	// Position of LP_CPU_WAKEUP_INT_CLR field.
	PMU_LP_INT_CLR_LP_CPU_WAKEUP_INT_CLR_Pos = 0x14
	// Bit mask of LP_CPU_WAKEUP_INT_CLR field.
	PMU_LP_INT_CLR_LP_CPU_WAKEUP_INT_CLR_Msk = 0x100000
	// Bit LP_CPU_WAKEUP_INT_CLR.
	PMU_LP_INT_CLR_LP_CPU_WAKEUP_INT_CLR = 0x100000
	// Position of MODEM_SWITCH_ACTIVE_END_INT_CLR field.
	PMU_LP_INT_CLR_MODEM_SWITCH_ACTIVE_END_INT_CLR_Pos = 0x15
	// Bit mask of MODEM_SWITCH_ACTIVE_END_INT_CLR field.
	PMU_LP_INT_CLR_MODEM_SWITCH_ACTIVE_END_INT_CLR_Msk = 0x200000
	// Bit MODEM_SWITCH_ACTIVE_END_INT_CLR.
	PMU_LP_INT_CLR_MODEM_SWITCH_ACTIVE_END_INT_CLR = 0x200000
	// Position of SLEEP_SWITCH_ACTIVE_END_INT_CLR field.
	PMU_LP_INT_CLR_SLEEP_SWITCH_ACTIVE_END_INT_CLR_Pos = 0x16
	// Bit mask of SLEEP_SWITCH_ACTIVE_END_INT_CLR field.
	PMU_LP_INT_CLR_SLEEP_SWITCH_ACTIVE_END_INT_CLR_Msk = 0x400000
	// Bit SLEEP_SWITCH_ACTIVE_END_INT_CLR.
	PMU_LP_INT_CLR_SLEEP_SWITCH_ACTIVE_END_INT_CLR = 0x400000
	// Position of SLEEP_SWITCH_MODEM_END_INT_CLR field.
	PMU_LP_INT_CLR_SLEEP_SWITCH_MODEM_END_INT_CLR_Pos = 0x17
	// Bit mask of SLEEP_SWITCH_MODEM_END_INT_CLR field.
	PMU_LP_INT_CLR_SLEEP_SWITCH_MODEM_END_INT_CLR_Msk = 0x800000
	// Bit SLEEP_SWITCH_MODEM_END_INT_CLR.
	PMU_LP_INT_CLR_SLEEP_SWITCH_MODEM_END_INT_CLR = 0x800000
	// Position of MODEM_SWITCH_SLEEP_END_INT_CLR field.
	PMU_LP_INT_CLR_MODEM_SWITCH_SLEEP_END_INT_CLR_Pos = 0x18
	// Bit mask of MODEM_SWITCH_SLEEP_END_INT_CLR field.
	PMU_LP_INT_CLR_MODEM_SWITCH_SLEEP_END_INT_CLR_Msk = 0x1000000
	// Bit MODEM_SWITCH_SLEEP_END_INT_CLR.
	PMU_LP_INT_CLR_MODEM_SWITCH_SLEEP_END_INT_CLR = 0x1000000
	// Position of ACTIVE_SWITCH_SLEEP_END_INT_CLR field.
	PMU_LP_INT_CLR_ACTIVE_SWITCH_SLEEP_END_INT_CLR_Pos = 0x19
	// Bit mask of ACTIVE_SWITCH_SLEEP_END_INT_CLR field.
	PMU_LP_INT_CLR_ACTIVE_SWITCH_SLEEP_END_INT_CLR_Msk = 0x2000000
	// Bit ACTIVE_SWITCH_SLEEP_END_INT_CLR.
	PMU_LP_INT_CLR_ACTIVE_SWITCH_SLEEP_END_INT_CLR = 0x2000000
	// Position of MODEM_SWITCH_ACTIVE_START_INT_CLR field.
	PMU_LP_INT_CLR_MODEM_SWITCH_ACTIVE_START_INT_CLR_Pos = 0x1a
	// Bit mask of MODEM_SWITCH_ACTIVE_START_INT_CLR field.
	PMU_LP_INT_CLR_MODEM_SWITCH_ACTIVE_START_INT_CLR_Msk = 0x4000000
	// Bit MODEM_SWITCH_ACTIVE_START_INT_CLR.
	PMU_LP_INT_CLR_MODEM_SWITCH_ACTIVE_START_INT_CLR = 0x4000000
	// Position of SLEEP_SWITCH_ACTIVE_START_INT_CLR field.
	PMU_LP_INT_CLR_SLEEP_SWITCH_ACTIVE_START_INT_CLR_Pos = 0x1b
	// Bit mask of SLEEP_SWITCH_ACTIVE_START_INT_CLR field.
	PMU_LP_INT_CLR_SLEEP_SWITCH_ACTIVE_START_INT_CLR_Msk = 0x8000000
	// Bit SLEEP_SWITCH_ACTIVE_START_INT_CLR.
	PMU_LP_INT_CLR_SLEEP_SWITCH_ACTIVE_START_INT_CLR = 0x8000000
	// Position of SLEEP_SWITCH_MODEM_START_INT_CLR field.
	PMU_LP_INT_CLR_SLEEP_SWITCH_MODEM_START_INT_CLR_Pos = 0x1c
	// Bit mask of SLEEP_SWITCH_MODEM_START_INT_CLR field.
	PMU_LP_INT_CLR_SLEEP_SWITCH_MODEM_START_INT_CLR_Msk = 0x10000000
	// Bit SLEEP_SWITCH_MODEM_START_INT_CLR.
	PMU_LP_INT_CLR_SLEEP_SWITCH_MODEM_START_INT_CLR = 0x10000000
	// Position of MODEM_SWITCH_SLEEP_START_INT_CLR field.
	PMU_LP_INT_CLR_MODEM_SWITCH_SLEEP_START_INT_CLR_Pos = 0x1d
	// Bit mask of MODEM_SWITCH_SLEEP_START_INT_CLR field.
	PMU_LP_INT_CLR_MODEM_SWITCH_SLEEP_START_INT_CLR_Msk = 0x20000000
	// Bit MODEM_SWITCH_SLEEP_START_INT_CLR.
	PMU_LP_INT_CLR_MODEM_SWITCH_SLEEP_START_INT_CLR = 0x20000000
	// Position of ACTIVE_SWITCH_SLEEP_START_INT_CLR field.
	PMU_LP_INT_CLR_ACTIVE_SWITCH_SLEEP_START_INT_CLR_Pos = 0x1e
	// Bit mask of ACTIVE_SWITCH_SLEEP_START_INT_CLR field.
	PMU_LP_INT_CLR_ACTIVE_SWITCH_SLEEP_START_INT_CLR_Msk = 0x40000000
	// Bit ACTIVE_SWITCH_SLEEP_START_INT_CLR.
	PMU_LP_INT_CLR_ACTIVE_SWITCH_SLEEP_START_INT_CLR = 0x40000000
	// Position of HP_SW_TRIGGER_INT_CLR field.
	PMU_LP_INT_CLR_HP_SW_TRIGGER_INT_CLR_Pos = 0x1f
	// Bit mask of HP_SW_TRIGGER_INT_CLR field.
	PMU_LP_INT_CLR_HP_SW_TRIGGER_INT_CLR_Msk = 0x80000000
	// Bit HP_SW_TRIGGER_INT_CLR.
	PMU_LP_INT_CLR_HP_SW_TRIGGER_INT_CLR = 0x80000000

	// LP_CPU_PWR0: need_des
	// Position of LP_CPU_WAITI_RDY field.
	PMU_LP_CPU_PWR0_LP_CPU_WAITI_RDY_Pos = 0x0
	// Bit mask of LP_CPU_WAITI_RDY field.
	PMU_LP_CPU_PWR0_LP_CPU_WAITI_RDY_Msk = 0x1
	// Bit LP_CPU_WAITI_RDY.
	PMU_LP_CPU_PWR0_LP_CPU_WAITI_RDY = 0x1
	// Position of LP_CPU_STALL_RDY field.
	PMU_LP_CPU_PWR0_LP_CPU_STALL_RDY_Pos = 0x1
	// Bit mask of LP_CPU_STALL_RDY field.
	PMU_LP_CPU_PWR0_LP_CPU_STALL_RDY_Msk = 0x2
	// Bit LP_CPU_STALL_RDY.
	PMU_LP_CPU_PWR0_LP_CPU_STALL_RDY = 0x2
	// Position of LP_CPU_FORCE_STALL field.
	PMU_LP_CPU_PWR0_LP_CPU_FORCE_STALL_Pos = 0x12
	// Bit mask of LP_CPU_FORCE_STALL field.
	PMU_LP_CPU_PWR0_LP_CPU_FORCE_STALL_Msk = 0x40000
	// Bit LP_CPU_FORCE_STALL.
	PMU_LP_CPU_PWR0_LP_CPU_FORCE_STALL = 0x40000
	// Position of LP_CPU_SLP_WAITI_FLAG_EN field.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_WAITI_FLAG_EN_Pos = 0x13
	// Bit mask of LP_CPU_SLP_WAITI_FLAG_EN field.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_WAITI_FLAG_EN_Msk = 0x80000
	// Bit LP_CPU_SLP_WAITI_FLAG_EN.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_WAITI_FLAG_EN = 0x80000
	// Position of LP_CPU_SLP_STALL_FLAG_EN field.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_STALL_FLAG_EN_Pos = 0x14
	// Bit mask of LP_CPU_SLP_STALL_FLAG_EN field.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_STALL_FLAG_EN_Msk = 0x100000
	// Bit LP_CPU_SLP_STALL_FLAG_EN.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_STALL_FLAG_EN = 0x100000
	// Position of LP_CPU_SLP_STALL_WAIT field.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_STALL_WAIT_Pos = 0x15
	// Bit mask of LP_CPU_SLP_STALL_WAIT field.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_STALL_WAIT_Msk = 0x1fe00000
	// Position of LP_CPU_SLP_STALL_EN field.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_STALL_EN_Pos = 0x1d
	// Bit mask of LP_CPU_SLP_STALL_EN field.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_STALL_EN_Msk = 0x20000000
	// Bit LP_CPU_SLP_STALL_EN.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_STALL_EN = 0x20000000
	// Position of LP_CPU_SLP_RESET_EN field.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_RESET_EN_Pos = 0x1e
	// Bit mask of LP_CPU_SLP_RESET_EN field.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_RESET_EN_Msk = 0x40000000
	// Bit LP_CPU_SLP_RESET_EN.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_RESET_EN = 0x40000000
	// Position of LP_CPU_SLP_BYPASS_INTR_EN field.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_BYPASS_INTR_EN_Pos = 0x1f
	// Bit mask of LP_CPU_SLP_BYPASS_INTR_EN field.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_BYPASS_INTR_EN_Msk = 0x80000000
	// Bit LP_CPU_SLP_BYPASS_INTR_EN.
	PMU_LP_CPU_PWR0_LP_CPU_SLP_BYPASS_INTR_EN = 0x80000000

	// LP_CPU_PWR1: need_des
	// Position of LP_CPU_WAKEUP_EN field.
	PMU_LP_CPU_PWR1_LP_CPU_WAKEUP_EN_Pos = 0x0
	// Bit mask of LP_CPU_WAKEUP_EN field.
	PMU_LP_CPU_PWR1_LP_CPU_WAKEUP_EN_Msk = 0xffff
	// Position of LP_CPU_SLEEP_REQ field.
	PMU_LP_CPU_PWR1_LP_CPU_SLEEP_REQ_Pos = 0x1f
	// Bit mask of LP_CPU_SLEEP_REQ field.
	PMU_LP_CPU_PWR1_LP_CPU_SLEEP_REQ_Msk = 0x80000000
	// Bit LP_CPU_SLEEP_REQ.
	PMU_LP_CPU_PWR1_LP_CPU_SLEEP_REQ = 0x80000000

	// HP_LP_CPU_COMM: need_des
	// Position of LP_TRIGGER_HP field.
	PMU_HP_LP_CPU_COMM_LP_TRIGGER_HP_Pos = 0x1e
	// Bit mask of LP_TRIGGER_HP field.
	PMU_HP_LP_CPU_COMM_LP_TRIGGER_HP_Msk = 0x40000000
	// Bit LP_TRIGGER_HP.
	PMU_HP_LP_CPU_COMM_LP_TRIGGER_HP = 0x40000000
	// Position of HP_TRIGGER_LP field.
	PMU_HP_LP_CPU_COMM_HP_TRIGGER_LP_Pos = 0x1f
	// Bit mask of HP_TRIGGER_LP field.
	PMU_HP_LP_CPU_COMM_HP_TRIGGER_LP_Msk = 0x80000000
	// Bit HP_TRIGGER_LP.
	PMU_HP_LP_CPU_COMM_HP_TRIGGER_LP = 0x80000000

	// HP_REGULATOR_CFG: need_des
	// Position of DIG_REGULATOR_EN_CAL field.
	PMU_HP_REGULATOR_CFG_DIG_REGULATOR_EN_CAL_Pos = 0x1f
	// Bit mask of DIG_REGULATOR_EN_CAL field.
	PMU_HP_REGULATOR_CFG_DIG_REGULATOR_EN_CAL_Msk = 0x80000000
	// Bit DIG_REGULATOR_EN_CAL.
	PMU_HP_REGULATOR_CFG_DIG_REGULATOR_EN_CAL = 0x80000000

	// MAIN_STATE: need_des
	// Position of MAIN_LAST_ST_STATE field.
	PMU_MAIN_STATE_MAIN_LAST_ST_STATE_Pos = 0xb
	// Bit mask of MAIN_LAST_ST_STATE field.
	PMU_MAIN_STATE_MAIN_LAST_ST_STATE_Msk = 0x3f800
	// Position of MAIN_TAR_ST_STATE field.
	PMU_MAIN_STATE_MAIN_TAR_ST_STATE_Pos = 0x12
	// Bit mask of MAIN_TAR_ST_STATE field.
	PMU_MAIN_STATE_MAIN_TAR_ST_STATE_Msk = 0x1fc0000
	// Position of MAIN_CUR_ST_STATE field.
	PMU_MAIN_STATE_MAIN_CUR_ST_STATE_Pos = 0x19
	// Bit mask of MAIN_CUR_ST_STATE field.
	PMU_MAIN_STATE_MAIN_CUR_ST_STATE_Msk = 0xfe000000

	// PWR_STATE: need_des
	// Position of BACKUP_ST_STATE field.
	PMU_PWR_STATE_BACKUP_ST_STATE_Pos = 0xd
	// Bit mask of BACKUP_ST_STATE field.
	PMU_PWR_STATE_BACKUP_ST_STATE_Msk = 0x3e000
	// Position of LP_PWR_ST_STATE field.
	PMU_PWR_STATE_LP_PWR_ST_STATE_Pos = 0x12
	// Bit mask of LP_PWR_ST_STATE field.
	PMU_PWR_STATE_LP_PWR_ST_STATE_Msk = 0x7c0000
	// Position of HP_PWR_ST_STATE field.
	PMU_PWR_STATE_HP_PWR_ST_STATE_Pos = 0x17
	// Bit mask of HP_PWR_ST_STATE field.
	PMU_PWR_STATE_HP_PWR_ST_STATE_Msk = 0xff800000

	// CLK_STATE0: need_des
	// Position of STABLE_XPD_BBPLL_STATE field.
	PMU_CLK_STATE0_STABLE_XPD_BBPLL_STATE_Pos = 0x0
	// Bit mask of STABLE_XPD_BBPLL_STATE field.
	PMU_CLK_STATE0_STABLE_XPD_BBPLL_STATE_Msk = 0x1
	// Bit STABLE_XPD_BBPLL_STATE.
	PMU_CLK_STATE0_STABLE_XPD_BBPLL_STATE = 0x1
	// Position of STABLE_XPD_XTAL_STATE field.
	PMU_CLK_STATE0_STABLE_XPD_XTAL_STATE_Pos = 0x1
	// Bit mask of STABLE_XPD_XTAL_STATE field.
	PMU_CLK_STATE0_STABLE_XPD_XTAL_STATE_Msk = 0x2
	// Bit STABLE_XPD_XTAL_STATE.
	PMU_CLK_STATE0_STABLE_XPD_XTAL_STATE = 0x2
	// Position of SYS_CLK_SLP_SEL_STATE field.
	PMU_CLK_STATE0_SYS_CLK_SLP_SEL_STATE_Pos = 0xf
	// Bit mask of SYS_CLK_SLP_SEL_STATE field.
	PMU_CLK_STATE0_SYS_CLK_SLP_SEL_STATE_Msk = 0x8000
	// Bit SYS_CLK_SLP_SEL_STATE.
	PMU_CLK_STATE0_SYS_CLK_SLP_SEL_STATE = 0x8000
	// Position of SYS_CLK_SEL_STATE field.
	PMU_CLK_STATE0_SYS_CLK_SEL_STATE_Pos = 0x10
	// Bit mask of SYS_CLK_SEL_STATE field.
	PMU_CLK_STATE0_SYS_CLK_SEL_STATE_Msk = 0x30000
	// Position of SYS_CLK_NO_DIV_STATE field.
	PMU_CLK_STATE0_SYS_CLK_NO_DIV_STATE_Pos = 0x12
	// Bit mask of SYS_CLK_NO_DIV_STATE field.
	PMU_CLK_STATE0_SYS_CLK_NO_DIV_STATE_Msk = 0x40000
	// Bit SYS_CLK_NO_DIV_STATE.
	PMU_CLK_STATE0_SYS_CLK_NO_DIV_STATE = 0x40000
	// Position of ICG_SYS_CLK_EN_STATE field.
	PMU_CLK_STATE0_ICG_SYS_CLK_EN_STATE_Pos = 0x13
	// Bit mask of ICG_SYS_CLK_EN_STATE field.
	PMU_CLK_STATE0_ICG_SYS_CLK_EN_STATE_Msk = 0x80000
	// Bit ICG_SYS_CLK_EN_STATE.
	PMU_CLK_STATE0_ICG_SYS_CLK_EN_STATE = 0x80000
	// Position of ICG_MODEM_SWITCH_STATE field.
	PMU_CLK_STATE0_ICG_MODEM_SWITCH_STATE_Pos = 0x14
	// Bit mask of ICG_MODEM_SWITCH_STATE field.
	PMU_CLK_STATE0_ICG_MODEM_SWITCH_STATE_Msk = 0x100000
	// Bit ICG_MODEM_SWITCH_STATE.
	PMU_CLK_STATE0_ICG_MODEM_SWITCH_STATE = 0x100000
	// Position of ICG_MODEM_CODE_STATE field.
	PMU_CLK_STATE0_ICG_MODEM_CODE_STATE_Pos = 0x15
	// Bit mask of ICG_MODEM_CODE_STATE field.
	PMU_CLK_STATE0_ICG_MODEM_CODE_STATE_Msk = 0x600000
	// Position of ICG_SLP_SEL_STATE field.
	PMU_CLK_STATE0_ICG_SLP_SEL_STATE_Pos = 0x17
	// Bit mask of ICG_SLP_SEL_STATE field.
	PMU_CLK_STATE0_ICG_SLP_SEL_STATE_Msk = 0x800000
	// Bit ICG_SLP_SEL_STATE.
	PMU_CLK_STATE0_ICG_SLP_SEL_STATE = 0x800000
	// Position of ICG_GLOBAL_XTAL_STATE field.
	PMU_CLK_STATE0_ICG_GLOBAL_XTAL_STATE_Pos = 0x18
	// Bit mask of ICG_GLOBAL_XTAL_STATE field.
	PMU_CLK_STATE0_ICG_GLOBAL_XTAL_STATE_Msk = 0x1000000
	// Bit ICG_GLOBAL_XTAL_STATE.
	PMU_CLK_STATE0_ICG_GLOBAL_XTAL_STATE = 0x1000000
	// Position of ICG_GLOBAL_PLL_STATE field.
	PMU_CLK_STATE0_ICG_GLOBAL_PLL_STATE_Pos = 0x19
	// Bit mask of ICG_GLOBAL_PLL_STATE field.
	PMU_CLK_STATE0_ICG_GLOBAL_PLL_STATE_Msk = 0x2000000
	// Bit ICG_GLOBAL_PLL_STATE.
	PMU_CLK_STATE0_ICG_GLOBAL_PLL_STATE = 0x2000000
	// Position of ANA_I2C_ISO_EN_STATE field.
	PMU_CLK_STATE0_ANA_I2C_ISO_EN_STATE_Pos = 0x1a
	// Bit mask of ANA_I2C_ISO_EN_STATE field.
	PMU_CLK_STATE0_ANA_I2C_ISO_EN_STATE_Msk = 0x4000000
	// Bit ANA_I2C_ISO_EN_STATE.
	PMU_CLK_STATE0_ANA_I2C_ISO_EN_STATE = 0x4000000
	// Position of ANA_I2C_RETENTION_STATE field.
	PMU_CLK_STATE0_ANA_I2C_RETENTION_STATE_Pos = 0x1b
	// Bit mask of ANA_I2C_RETENTION_STATE field.
	PMU_CLK_STATE0_ANA_I2C_RETENTION_STATE_Msk = 0x8000000
	// Bit ANA_I2C_RETENTION_STATE.
	PMU_CLK_STATE0_ANA_I2C_RETENTION_STATE = 0x8000000
	// Position of ANA_XPD_BB_I2C_STATE field.
	PMU_CLK_STATE0_ANA_XPD_BB_I2C_STATE_Pos = 0x1c
	// Bit mask of ANA_XPD_BB_I2C_STATE field.
	PMU_CLK_STATE0_ANA_XPD_BB_I2C_STATE_Msk = 0x10000000
	// Bit ANA_XPD_BB_I2C_STATE.
	PMU_CLK_STATE0_ANA_XPD_BB_I2C_STATE = 0x10000000
	// Position of ANA_XPD_BBPLL_I2C_STATE field.
	PMU_CLK_STATE0_ANA_XPD_BBPLL_I2C_STATE_Pos = 0x1d
	// Bit mask of ANA_XPD_BBPLL_I2C_STATE field.
	PMU_CLK_STATE0_ANA_XPD_BBPLL_I2C_STATE_Msk = 0x20000000
	// Bit ANA_XPD_BBPLL_I2C_STATE.
	PMU_CLK_STATE0_ANA_XPD_BBPLL_I2C_STATE = 0x20000000
	// Position of ANA_XPD_BBPLL_STATE field.
	PMU_CLK_STATE0_ANA_XPD_BBPLL_STATE_Pos = 0x1e
	// Bit mask of ANA_XPD_BBPLL_STATE field.
	PMU_CLK_STATE0_ANA_XPD_BBPLL_STATE_Msk = 0x40000000
	// Bit ANA_XPD_BBPLL_STATE.
	PMU_CLK_STATE0_ANA_XPD_BBPLL_STATE = 0x40000000
	// Position of ANA_XPD_XTAL_STATE field.
	PMU_CLK_STATE0_ANA_XPD_XTAL_STATE_Pos = 0x1f
	// Bit mask of ANA_XPD_XTAL_STATE field.
	PMU_CLK_STATE0_ANA_XPD_XTAL_STATE_Msk = 0x80000000
	// Bit ANA_XPD_XTAL_STATE.
	PMU_CLK_STATE0_ANA_XPD_XTAL_STATE = 0x80000000

	// CLK_STATE1: need_des
	// Position of ICG_FUNC_EN_STATE field.
	PMU_CLK_STATE1_ICG_FUNC_EN_STATE_Pos = 0x0
	// Bit mask of ICG_FUNC_EN_STATE field.
	PMU_CLK_STATE1_ICG_FUNC_EN_STATE_Msk = 0xffffffff

	// CLK_STATE2: need_des
	// Position of ICG_APB_EN_STATE field.
	PMU_CLK_STATE2_ICG_APB_EN_STATE_Pos = 0x0
	// Bit mask of ICG_APB_EN_STATE field.
	PMU_CLK_STATE2_ICG_APB_EN_STATE_Msk = 0xffffffff

	// VDD_SPI_STATUS: need_des
	// Position of STABLE_VDD_SPI_PWR_DRV field.
	PMU_VDD_SPI_STATUS_STABLE_VDD_SPI_PWR_DRV_Pos = 0x1f
	// Bit mask of STABLE_VDD_SPI_PWR_DRV field.
	PMU_VDD_SPI_STATUS_STABLE_VDD_SPI_PWR_DRV_Msk = 0x80000000
	// Bit STABLE_VDD_SPI_PWR_DRV.
	PMU_VDD_SPI_STATUS_STABLE_VDD_SPI_PWR_DRV = 0x80000000

	// DATE: need_des
	// Position of PMU_DATE field.
	PMU_DATE_PMU_DATE_Pos = 0x0
	// Bit mask of PMU_DATE field.
	PMU_DATE_PMU_DATE_Msk = 0x7fffffff
	// Position of CLK_EN field.
	PMU_DATE_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	PMU_DATE_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	PMU_DATE_CLK_EN = 0x80000000
)

// Constants for RMT: Remote Control
const (
	// CH0DATA: The read and write data register for CHANNEL%s by apb fifo access.
	// Position of DATA field.
	RMT_CHDATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	RMT_CHDATA_DATA_Msk = 0xffffffff

	// CH0_TX_CONF0: Channel %s configure register 0
	// Position of TX_START field.
	RMT_CH_TX_CONF0_TX_START_Pos = 0x0
	// Bit mask of TX_START field.
	RMT_CH_TX_CONF0_TX_START_Msk = 0x1
	// Bit TX_START.
	RMT_CH_TX_CONF0_TX_START = 0x1
	// Position of MEM_RD_RST field.
	RMT_CH_TX_CONF0_MEM_RD_RST_Pos = 0x1
	// Bit mask of MEM_RD_RST field.
	RMT_CH_TX_CONF0_MEM_RD_RST_Msk = 0x2
	// Bit MEM_RD_RST.
	RMT_CH_TX_CONF0_MEM_RD_RST = 0x2
	// Position of APB_MEM_RST field.
	RMT_CH_TX_CONF0_APB_MEM_RST_Pos = 0x2
	// Bit mask of APB_MEM_RST field.
	RMT_CH_TX_CONF0_APB_MEM_RST_Msk = 0x4
	// Bit APB_MEM_RST.
	RMT_CH_TX_CONF0_APB_MEM_RST = 0x4
	// Position of TX_CONTI_MODE field.
	RMT_CH_TX_CONF0_TX_CONTI_MODE_Pos = 0x3
	// Bit mask of TX_CONTI_MODE field.
	RMT_CH_TX_CONF0_TX_CONTI_MODE_Msk = 0x8
	// Bit TX_CONTI_MODE.
	RMT_CH_TX_CONF0_TX_CONTI_MODE = 0x8
	// Position of MEM_TX_WRAP_EN field.
	RMT_CH_TX_CONF0_MEM_TX_WRAP_EN_Pos = 0x4
	// Bit mask of MEM_TX_WRAP_EN field.
	RMT_CH_TX_CONF0_MEM_TX_WRAP_EN_Msk = 0x10
	// Bit MEM_TX_WRAP_EN.
	RMT_CH_TX_CONF0_MEM_TX_WRAP_EN = 0x10
	// Position of IDLE_OUT_LV field.
	RMT_CH_TX_CONF0_IDLE_OUT_LV_Pos = 0x5
	// Bit mask of IDLE_OUT_LV field.
	RMT_CH_TX_CONF0_IDLE_OUT_LV_Msk = 0x20
	// Bit IDLE_OUT_LV.
	RMT_CH_TX_CONF0_IDLE_OUT_LV = 0x20
	// Position of IDLE_OUT_EN field.
	RMT_CH_TX_CONF0_IDLE_OUT_EN_Pos = 0x6
	// Bit mask of IDLE_OUT_EN field.
	RMT_CH_TX_CONF0_IDLE_OUT_EN_Msk = 0x40
	// Bit IDLE_OUT_EN.
	RMT_CH_TX_CONF0_IDLE_OUT_EN = 0x40
	// Position of TX_STOP field.
	RMT_CH_TX_CONF0_TX_STOP_Pos = 0x7
	// Bit mask of TX_STOP field.
	RMT_CH_TX_CONF0_TX_STOP_Msk = 0x80
	// Bit TX_STOP.
	RMT_CH_TX_CONF0_TX_STOP = 0x80
	// Position of DIV_CNT field.
	RMT_CH_TX_CONF0_DIV_CNT_Pos = 0x8
	// Bit mask of DIV_CNT field.
	RMT_CH_TX_CONF0_DIV_CNT_Msk = 0xff00
	// Position of MEM_SIZE field.
	RMT_CH_TX_CONF0_MEM_SIZE_Pos = 0x10
	// Bit mask of MEM_SIZE field.
	RMT_CH_TX_CONF0_MEM_SIZE_Msk = 0x70000
	// Position of CARRIER_EFF_EN field.
	RMT_CH_TX_CONF0_CARRIER_EFF_EN_Pos = 0x14
	// Bit mask of CARRIER_EFF_EN field.
	RMT_CH_TX_CONF0_CARRIER_EFF_EN_Msk = 0x100000
	// Bit CARRIER_EFF_EN.
	RMT_CH_TX_CONF0_CARRIER_EFF_EN = 0x100000
	// Position of CARRIER_EN field.
	RMT_CH_TX_CONF0_CARRIER_EN_Pos = 0x15
	// Bit mask of CARRIER_EN field.
	RMT_CH_TX_CONF0_CARRIER_EN_Msk = 0x200000
	// Bit CARRIER_EN.
	RMT_CH_TX_CONF0_CARRIER_EN = 0x200000
	// Position of CARRIER_OUT_LV field.
	RMT_CH_TX_CONF0_CARRIER_OUT_LV_Pos = 0x16
	// Bit mask of CARRIER_OUT_LV field.
	RMT_CH_TX_CONF0_CARRIER_OUT_LV_Msk = 0x400000
	// Bit CARRIER_OUT_LV.
	RMT_CH_TX_CONF0_CARRIER_OUT_LV = 0x400000
	// Position of AFIFO_RST field.
	RMT_CH_TX_CONF0_AFIFO_RST_Pos = 0x17
	// Bit mask of AFIFO_RST field.
	RMT_CH_TX_CONF0_AFIFO_RST_Msk = 0x800000
	// Bit AFIFO_RST.
	RMT_CH_TX_CONF0_AFIFO_RST = 0x800000
	// Position of CONF_UPDATE field.
	RMT_CH_TX_CONF0_CONF_UPDATE_Pos = 0x18
	// Bit mask of CONF_UPDATE field.
	RMT_CH_TX_CONF0_CONF_UPDATE_Msk = 0x1000000
	// Bit CONF_UPDATE.
	RMT_CH_TX_CONF0_CONF_UPDATE = 0x1000000

	// CH2_RX_CONF0: Channel %s configure register 0
	// Position of DIV_CNT field.
	RMT_CH_RX_CONF0_DIV_CNT_Pos = 0x0
	// Bit mask of DIV_CNT field.
	RMT_CH_RX_CONF0_DIV_CNT_Msk = 0xff
	// Position of IDLE_THRES field.
	RMT_CH_RX_CONF0_IDLE_THRES_Pos = 0x8
	// Bit mask of IDLE_THRES field.
	RMT_CH_RX_CONF0_IDLE_THRES_Msk = 0x7fff00
	// Position of MEM_SIZE field.
	RMT_CH_RX_CONF0_MEM_SIZE_Pos = 0x17
	// Bit mask of MEM_SIZE field.
	RMT_CH_RX_CONF0_MEM_SIZE_Msk = 0x3800000
	// Position of CARRIER_EN field.
	RMT_CH_RX_CONF0_CARRIER_EN_Pos = 0x1c
	// Bit mask of CARRIER_EN field.
	RMT_CH_RX_CONF0_CARRIER_EN_Msk = 0x10000000
	// Bit CARRIER_EN.
	RMT_CH_RX_CONF0_CARRIER_EN = 0x10000000
	// Position of CARRIER_OUT_LV field.
	RMT_CH_RX_CONF0_CARRIER_OUT_LV_Pos = 0x1d
	// Bit mask of CARRIER_OUT_LV field.
	RMT_CH_RX_CONF0_CARRIER_OUT_LV_Msk = 0x20000000
	// Bit CARRIER_OUT_LV.
	RMT_CH_RX_CONF0_CARRIER_OUT_LV = 0x20000000

	// CH2_RX_CONF1: Channel %s configure register 1
	// Position of RX_EN field.
	RMT_CH_RX_CONF1_RX_EN_Pos = 0x0
	// Bit mask of RX_EN field.
	RMT_CH_RX_CONF1_RX_EN_Msk = 0x1
	// Bit RX_EN.
	RMT_CH_RX_CONF1_RX_EN = 0x1
	// Position of MEM_WR_RST field.
	RMT_CH_RX_CONF1_MEM_WR_RST_Pos = 0x1
	// Bit mask of MEM_WR_RST field.
	RMT_CH_RX_CONF1_MEM_WR_RST_Msk = 0x2
	// Bit MEM_WR_RST.
	RMT_CH_RX_CONF1_MEM_WR_RST = 0x2
	// Position of APB_MEM_RST field.
	RMT_CH_RX_CONF1_APB_MEM_RST_Pos = 0x2
	// Bit mask of APB_MEM_RST field.
	RMT_CH_RX_CONF1_APB_MEM_RST_Msk = 0x4
	// Bit APB_MEM_RST.
	RMT_CH_RX_CONF1_APB_MEM_RST = 0x4
	// Position of MEM_OWNER field.
	RMT_CH_RX_CONF1_MEM_OWNER_Pos = 0x3
	// Bit mask of MEM_OWNER field.
	RMT_CH_RX_CONF1_MEM_OWNER_Msk = 0x8
	// Bit MEM_OWNER.
	RMT_CH_RX_CONF1_MEM_OWNER = 0x8
	// Position of RX_FILTER_EN field.
	RMT_CH_RX_CONF1_RX_FILTER_EN_Pos = 0x4
	// Bit mask of RX_FILTER_EN field.
	RMT_CH_RX_CONF1_RX_FILTER_EN_Msk = 0x10
	// Bit RX_FILTER_EN.
	RMT_CH_RX_CONF1_RX_FILTER_EN = 0x10
	// Position of RX_FILTER_THRES field.
	RMT_CH_RX_CONF1_RX_FILTER_THRES_Pos = 0x5
	// Bit mask of RX_FILTER_THRES field.
	RMT_CH_RX_CONF1_RX_FILTER_THRES_Msk = 0x1fe0
	// Position of MEM_RX_WRAP_EN field.
	RMT_CH_RX_CONF1_MEM_RX_WRAP_EN_Pos = 0xd
	// Bit mask of MEM_RX_WRAP_EN field.
	RMT_CH_RX_CONF1_MEM_RX_WRAP_EN_Msk = 0x2000
	// Bit MEM_RX_WRAP_EN.
	RMT_CH_RX_CONF1_MEM_RX_WRAP_EN = 0x2000
	// Position of AFIFO_RST field.
	RMT_CH_RX_CONF1_AFIFO_RST_Pos = 0xe
	// Bit mask of AFIFO_RST field.
	RMT_CH_RX_CONF1_AFIFO_RST_Msk = 0x4000
	// Bit AFIFO_RST.
	RMT_CH_RX_CONF1_AFIFO_RST = 0x4000
	// Position of CONF_UPDATE field.
	RMT_CH_RX_CONF1_CONF_UPDATE_Pos = 0xf
	// Bit mask of CONF_UPDATE field.
	RMT_CH_RX_CONF1_CONF_UPDATE_Msk = 0x8000
	// Bit CONF_UPDATE.
	RMT_CH_RX_CONF1_CONF_UPDATE = 0x8000

	// CH0_TX_STATUS: Channel %s status register
	// Position of MEM_RADDR_EX field.
	RMT_CH_TX_STATUS_MEM_RADDR_EX_Pos = 0x0
	// Bit mask of MEM_RADDR_EX field.
	RMT_CH_TX_STATUS_MEM_RADDR_EX_Msk = 0x1ff
	// Position of STATE field.
	RMT_CH_TX_STATUS_STATE_Pos = 0x9
	// Bit mask of STATE field.
	RMT_CH_TX_STATUS_STATE_Msk = 0xe00
	// Position of APB_MEM_WADDR field.
	RMT_CH_TX_STATUS_APB_MEM_WADDR_Pos = 0xc
	// Bit mask of APB_MEM_WADDR field.
	RMT_CH_TX_STATUS_APB_MEM_WADDR_Msk = 0x1ff000
	// Position of APB_MEM_RD_ERR field.
	RMT_CH_TX_STATUS_APB_MEM_RD_ERR_Pos = 0x15
	// Bit mask of APB_MEM_RD_ERR field.
	RMT_CH_TX_STATUS_APB_MEM_RD_ERR_Msk = 0x200000
	// Bit APB_MEM_RD_ERR.
	RMT_CH_TX_STATUS_APB_MEM_RD_ERR = 0x200000
	// Position of MEM_EMPTY field.
	RMT_CH_TX_STATUS_MEM_EMPTY_Pos = 0x16
	// Bit mask of MEM_EMPTY field.
	RMT_CH_TX_STATUS_MEM_EMPTY_Msk = 0x400000
	// Bit MEM_EMPTY.
	RMT_CH_TX_STATUS_MEM_EMPTY = 0x400000
	// Position of APB_MEM_WR_ERR field.
	RMT_CH_TX_STATUS_APB_MEM_WR_ERR_Pos = 0x17
	// Bit mask of APB_MEM_WR_ERR field.
	RMT_CH_TX_STATUS_APB_MEM_WR_ERR_Msk = 0x800000
	// Bit APB_MEM_WR_ERR.
	RMT_CH_TX_STATUS_APB_MEM_WR_ERR = 0x800000
	// Position of APB_MEM_RADDR field.
	RMT_CH_TX_STATUS_APB_MEM_RADDR_Pos = 0x18
	// Bit mask of APB_MEM_RADDR field.
	RMT_CH_TX_STATUS_APB_MEM_RADDR_Msk = 0xff000000

	// CH0_RX_STATUS: Channel %s status register
	// Position of MEM_WADDR_EX field.
	RMT_CH_RX_STATUS_MEM_WADDR_EX_Pos = 0x0
	// Bit mask of MEM_WADDR_EX field.
	RMT_CH_RX_STATUS_MEM_WADDR_EX_Msk = 0x1ff
	// Position of APB_MEM_RADDR field.
	RMT_CH_RX_STATUS_APB_MEM_RADDR_Pos = 0xc
	// Bit mask of APB_MEM_RADDR field.
	RMT_CH_RX_STATUS_APB_MEM_RADDR_Msk = 0x1ff000
	// Position of STATE field.
	RMT_CH_RX_STATUS_STATE_Pos = 0x16
	// Bit mask of STATE field.
	RMT_CH_RX_STATUS_STATE_Msk = 0x1c00000
	// Position of MEM_OWNER_ERR field.
	RMT_CH_RX_STATUS_MEM_OWNER_ERR_Pos = 0x19
	// Bit mask of MEM_OWNER_ERR field.
	RMT_CH_RX_STATUS_MEM_OWNER_ERR_Msk = 0x2000000
	// Bit MEM_OWNER_ERR.
	RMT_CH_RX_STATUS_MEM_OWNER_ERR = 0x2000000
	// Position of MEM_FULL field.
	RMT_CH_RX_STATUS_MEM_FULL_Pos = 0x1a
	// Bit mask of MEM_FULL field.
	RMT_CH_RX_STATUS_MEM_FULL_Msk = 0x4000000
	// Bit MEM_FULL.
	RMT_CH_RX_STATUS_MEM_FULL = 0x4000000
	// Position of APB_MEM_RD_ERR field.
	RMT_CH_RX_STATUS_APB_MEM_RD_ERR_Pos = 0x1b
	// Bit mask of APB_MEM_RD_ERR field.
	RMT_CH_RX_STATUS_APB_MEM_RD_ERR_Msk = 0x8000000
	// Bit APB_MEM_RD_ERR.
	RMT_CH_RX_STATUS_APB_MEM_RD_ERR = 0x8000000

	// INT_RAW: Raw interrupt status
	// Position of CH_s_TX_END field.
	RMT_INT_RAW_CH_s_TX_END_Pos = 0x0
	// Bit mask of CH_s_TX_END field.
	RMT_INT_RAW_CH_s_TX_END_Msk = 0x1
	// Bit CH_s_TX_END.
	RMT_INT_RAW_CH_s_TX_END = 0x1
	// Position of CH_s_RX_END field.
	RMT_INT_RAW_CH_s_RX_END_Pos = 0x2
	// Bit mask of CH_s_RX_END field.
	RMT_INT_RAW_CH_s_RX_END_Msk = 0x4
	// Bit CH_s_RX_END.
	RMT_INT_RAW_CH_s_RX_END = 0x4
	// Position of CH_s_TX_ERR field.
	RMT_INT_RAW_CH_s_TX_ERR_Pos = 0x4
	// Bit mask of CH_s_TX_ERR field.
	RMT_INT_RAW_CH_s_TX_ERR_Msk = 0x10
	// Bit CH_s_TX_ERR.
	RMT_INT_RAW_CH_s_TX_ERR = 0x10
	// Position of CH_s_RX_ERR field.
	RMT_INT_RAW_CH_s_RX_ERR_Pos = 0x6
	// Bit mask of CH_s_RX_ERR field.
	RMT_INT_RAW_CH_s_RX_ERR_Msk = 0x40
	// Bit CH_s_RX_ERR.
	RMT_INT_RAW_CH_s_RX_ERR = 0x40
	// Position of CH_s_TX_THR_EVENT field.
	RMT_INT_RAW_CH_s_TX_THR_EVENT_Pos = 0x8
	// Bit mask of CH_s_TX_THR_EVENT field.
	RMT_INT_RAW_CH_s_TX_THR_EVENT_Msk = 0x100
	// Bit CH_s_TX_THR_EVENT.
	RMT_INT_RAW_CH_s_TX_THR_EVENT = 0x100
	// Position of CH_s_RX_THR_EVENT field.
	RMT_INT_RAW_CH_s_RX_THR_EVENT_Pos = 0xa
	// Bit mask of CH_s_RX_THR_EVENT field.
	RMT_INT_RAW_CH_s_RX_THR_EVENT_Msk = 0x400
	// Bit CH_s_RX_THR_EVENT.
	RMT_INT_RAW_CH_s_RX_THR_EVENT = 0x400
	// Position of CH_s_TX_LOOP field.
	RMT_INT_RAW_CH_s_TX_LOOP_Pos = 0xc
	// Bit mask of CH_s_TX_LOOP field.
	RMT_INT_RAW_CH_s_TX_LOOP_Msk = 0x1000
	// Bit CH_s_TX_LOOP.
	RMT_INT_RAW_CH_s_TX_LOOP = 0x1000

	// INT_ST: Masked interrupt status
	// Position of CH_s_TX_END field.
	RMT_INT_ST_CH_s_TX_END_Pos = 0x0
	// Bit mask of CH_s_TX_END field.
	RMT_INT_ST_CH_s_TX_END_Msk = 0x1
	// Bit CH_s_TX_END.
	RMT_INT_ST_CH_s_TX_END = 0x1
	// Position of CH_s_RX_END field.
	RMT_INT_ST_CH_s_RX_END_Pos = 0x2
	// Bit mask of CH_s_RX_END field.
	RMT_INT_ST_CH_s_RX_END_Msk = 0x4
	// Bit CH_s_RX_END.
	RMT_INT_ST_CH_s_RX_END = 0x4
	// Position of CH_s_TX_ERR field.
	RMT_INT_ST_CH_s_TX_ERR_Pos = 0x4
	// Bit mask of CH_s_TX_ERR field.
	RMT_INT_ST_CH_s_TX_ERR_Msk = 0x10
	// Bit CH_s_TX_ERR.
	RMT_INT_ST_CH_s_TX_ERR = 0x10
	// Position of CH_s_RX_ERR field.
	RMT_INT_ST_CH_s_RX_ERR_Pos = 0x6
	// Bit mask of CH_s_RX_ERR field.
	RMT_INT_ST_CH_s_RX_ERR_Msk = 0x40
	// Bit CH_s_RX_ERR.
	RMT_INT_ST_CH_s_RX_ERR = 0x40
	// Position of CH_s_TX_THR_EVENT field.
	RMT_INT_ST_CH_s_TX_THR_EVENT_Pos = 0x8
	// Bit mask of CH_s_TX_THR_EVENT field.
	RMT_INT_ST_CH_s_TX_THR_EVENT_Msk = 0x100
	// Bit CH_s_TX_THR_EVENT.
	RMT_INT_ST_CH_s_TX_THR_EVENT = 0x100
	// Position of CH_s_RX_THR_EVENT field.
	RMT_INT_ST_CH_s_RX_THR_EVENT_Pos = 0xa
	// Bit mask of CH_s_RX_THR_EVENT field.
	RMT_INT_ST_CH_s_RX_THR_EVENT_Msk = 0x400
	// Bit CH_s_RX_THR_EVENT.
	RMT_INT_ST_CH_s_RX_THR_EVENT = 0x400
	// Position of CH_s_X_LOOP field.
	RMT_INT_ST_CH_s_X_LOOP_Pos = 0xc
	// Bit mask of CH_s_X_LOOP field.
	RMT_INT_ST_CH_s_X_LOOP_Msk = 0x1000
	// Bit CH_s_X_LOOP.
	RMT_INT_ST_CH_s_X_LOOP = 0x1000

	// INT_ENA: Interrupt enable bits
	// Position of CH_s_TX_END field.
	RMT_INT_ENA_CH_s_TX_END_Pos = 0x0
	// Bit mask of CH_s_TX_END field.
	RMT_INT_ENA_CH_s_TX_END_Msk = 0x1
	// Bit CH_s_TX_END.
	RMT_INT_ENA_CH_s_TX_END = 0x1
	// Position of CH_s_RX_END field.
	RMT_INT_ENA_CH_s_RX_END_Pos = 0x2
	// Bit mask of CH_s_RX_END field.
	RMT_INT_ENA_CH_s_RX_END_Msk = 0x4
	// Bit CH_s_RX_END.
	RMT_INT_ENA_CH_s_RX_END = 0x4
	// Position of CH_s_TX_ERR field.
	RMT_INT_ENA_CH_s_TX_ERR_Pos = 0x4
	// Bit mask of CH_s_TX_ERR field.
	RMT_INT_ENA_CH_s_TX_ERR_Msk = 0x10
	// Bit CH_s_TX_ERR.
	RMT_INT_ENA_CH_s_TX_ERR = 0x10
	// Position of CH_s_RX_ERR field.
	RMT_INT_ENA_CH_s_RX_ERR_Pos = 0x6
	// Bit mask of CH_s_RX_ERR field.
	RMT_INT_ENA_CH_s_RX_ERR_Msk = 0x40
	// Bit CH_s_RX_ERR.
	RMT_INT_ENA_CH_s_RX_ERR = 0x40
	// Position of CH_s_TX_THR_EVENT field.
	RMT_INT_ENA_CH_s_TX_THR_EVENT_Pos = 0x8
	// Bit mask of CH_s_TX_THR_EVENT field.
	RMT_INT_ENA_CH_s_TX_THR_EVENT_Msk = 0x100
	// Bit CH_s_TX_THR_EVENT.
	RMT_INT_ENA_CH_s_TX_THR_EVENT = 0x100
	// Position of CH_s_RX_THR_EVENT field.
	RMT_INT_ENA_CH_s_RX_THR_EVENT_Pos = 0xa
	// Bit mask of CH_s_RX_THR_EVENT field.
	RMT_INT_ENA_CH_s_RX_THR_EVENT_Msk = 0x400
	// Bit CH_s_RX_THR_EVENT.
	RMT_INT_ENA_CH_s_RX_THR_EVENT = 0x400
	// Position of CH_s_X_LOOP field.
	RMT_INT_ENA_CH_s_X_LOOP_Pos = 0xc
	// Bit mask of CH_s_X_LOOP field.
	RMT_INT_ENA_CH_s_X_LOOP_Msk = 0x1000
	// Bit CH_s_X_LOOP.
	RMT_INT_ENA_CH_s_X_LOOP = 0x1000

	// INT_CLR: Interrupt clear bits
	// Position of CH_s_TX_END field.
	RMT_INT_CLR_CH_s_TX_END_Pos = 0x0
	// Bit mask of CH_s_TX_END field.
	RMT_INT_CLR_CH_s_TX_END_Msk = 0x1
	// Bit CH_s_TX_END.
	RMT_INT_CLR_CH_s_TX_END = 0x1
	// Position of CH_s_RX_END field.
	RMT_INT_CLR_CH_s_RX_END_Pos = 0x2
	// Bit mask of CH_s_RX_END field.
	RMT_INT_CLR_CH_s_RX_END_Msk = 0x4
	// Bit CH_s_RX_END.
	RMT_INT_CLR_CH_s_RX_END = 0x4
	// Position of CH_s_TX_ERR field.
	RMT_INT_CLR_CH_s_TX_ERR_Pos = 0x4
	// Bit mask of CH_s_TX_ERR field.
	RMT_INT_CLR_CH_s_TX_ERR_Msk = 0x10
	// Bit CH_s_TX_ERR.
	RMT_INT_CLR_CH_s_TX_ERR = 0x10
	// Position of CH_s_RX_ERR field.
	RMT_INT_CLR_CH_s_RX_ERR_Pos = 0x6
	// Bit mask of CH_s_RX_ERR field.
	RMT_INT_CLR_CH_s_RX_ERR_Msk = 0x40
	// Bit CH_s_RX_ERR.
	RMT_INT_CLR_CH_s_RX_ERR = 0x40
	// Position of CH_s_TX_THR_EVENT field.
	RMT_INT_CLR_CH_s_TX_THR_EVENT_Pos = 0x8
	// Bit mask of CH_s_TX_THR_EVENT field.
	RMT_INT_CLR_CH_s_TX_THR_EVENT_Msk = 0x100
	// Bit CH_s_TX_THR_EVENT.
	RMT_INT_CLR_CH_s_TX_THR_EVENT = 0x100
	// Position of CH_s_RX_THR_EVENT field.
	RMT_INT_CLR_CH_s_RX_THR_EVENT_Pos = 0xa
	// Bit mask of CH_s_RX_THR_EVENT field.
	RMT_INT_CLR_CH_s_RX_THR_EVENT_Msk = 0x400
	// Bit CH_s_RX_THR_EVENT.
	RMT_INT_CLR_CH_s_RX_THR_EVENT = 0x400
	// Position of CH_s_TX_LOOP field.
	RMT_INT_CLR_CH_s_TX_LOOP_Pos = 0xc
	// Bit mask of CH_s_TX_LOOP field.
	RMT_INT_CLR_CH_s_TX_LOOP_Msk = 0x1000
	// Bit CH_s_TX_LOOP.
	RMT_INT_CLR_CH_s_TX_LOOP = 0x1000

	// CH0CARRIER_DUTY: Channel %s duty cycle configuration register
	// Position of CARRIER_LOW field.
	RMT_CHCARRIER_DUTY_CARRIER_LOW_Pos = 0x0
	// Bit mask of CARRIER_LOW field.
	RMT_CHCARRIER_DUTY_CARRIER_LOW_Msk = 0xffff
	// Position of CARRIER_HIGH field.
	RMT_CHCARRIER_DUTY_CARRIER_HIGH_Pos = 0x10
	// Bit mask of CARRIER_HIGH field.
	RMT_CHCARRIER_DUTY_CARRIER_HIGH_Msk = 0xffff0000

	// CH0_RX_CARRIER_RM: Channel %s carrier remove register
	// Position of CARRIER_LOW_THRES field.
	RMT_CH_RX_CARRIER_RM_CARRIER_LOW_THRES_Pos = 0x0
	// Bit mask of CARRIER_LOW_THRES field.
	RMT_CH_RX_CARRIER_RM_CARRIER_LOW_THRES_Msk = 0xffff
	// Position of CARRIER_HIGH_THRES field.
	RMT_CH_RX_CARRIER_RM_CARRIER_HIGH_THRES_Pos = 0x10
	// Bit mask of CARRIER_HIGH_THRES field.
	RMT_CH_RX_CARRIER_RM_CARRIER_HIGH_THRES_Msk = 0xffff0000

	// CH0_TX_LIM: Channel %s Tx event configuration register
	// Position of TX_LIM field.
	RMT_CH_TX_LIM_TX_LIM_Pos = 0x0
	// Bit mask of TX_LIM field.
	RMT_CH_TX_LIM_TX_LIM_Msk = 0x1ff
	// Position of TX_LOOP_NUM field.
	RMT_CH_TX_LIM_TX_LOOP_NUM_Pos = 0x9
	// Bit mask of TX_LOOP_NUM field.
	RMT_CH_TX_LIM_TX_LOOP_NUM_Msk = 0x7fe00
	// Position of TX_LOOP_CNT_EN field.
	RMT_CH_TX_LIM_TX_LOOP_CNT_EN_Pos = 0x13
	// Bit mask of TX_LOOP_CNT_EN field.
	RMT_CH_TX_LIM_TX_LOOP_CNT_EN_Msk = 0x80000
	// Bit TX_LOOP_CNT_EN.
	RMT_CH_TX_LIM_TX_LOOP_CNT_EN = 0x80000
	// Position of LOOP_COUNT_RESET field.
	RMT_CH_TX_LIM_LOOP_COUNT_RESET_Pos = 0x14
	// Bit mask of LOOP_COUNT_RESET field.
	RMT_CH_TX_LIM_LOOP_COUNT_RESET_Msk = 0x100000
	// Bit LOOP_COUNT_RESET.
	RMT_CH_TX_LIM_LOOP_COUNT_RESET = 0x100000
	// Position of LOOP_STOP_EN field.
	RMT_CH_TX_LIM_LOOP_STOP_EN_Pos = 0x15
	// Bit mask of LOOP_STOP_EN field.
	RMT_CH_TX_LIM_LOOP_STOP_EN_Msk = 0x200000
	// Bit LOOP_STOP_EN.
	RMT_CH_TX_LIM_LOOP_STOP_EN = 0x200000

	// CH0_RX_LIM: Channel %s Rx event configuration register
	// Position of RMT_RX_LIM field.
	RMT_CH_RX_LIM_RMT_RX_LIM_Pos = 0x0
	// Bit mask of RMT_RX_LIM field.
	RMT_CH_RX_LIM_RMT_RX_LIM_Msk = 0x1ff

	// SYS_CONF: RMT apb configuration register
	// Position of APB_FIFO_MASK field.
	RMT_SYS_CONF_APB_FIFO_MASK_Pos = 0x0
	// Bit mask of APB_FIFO_MASK field.
	RMT_SYS_CONF_APB_FIFO_MASK_Msk = 0x1
	// Bit APB_FIFO_MASK.
	RMT_SYS_CONF_APB_FIFO_MASK = 0x1
	// Position of MEM_CLK_FORCE_ON field.
	RMT_SYS_CONF_MEM_CLK_FORCE_ON_Pos = 0x1
	// Bit mask of MEM_CLK_FORCE_ON field.
	RMT_SYS_CONF_MEM_CLK_FORCE_ON_Msk = 0x2
	// Bit MEM_CLK_FORCE_ON.
	RMT_SYS_CONF_MEM_CLK_FORCE_ON = 0x2
	// Position of MEM_FORCE_PD field.
	RMT_SYS_CONF_MEM_FORCE_PD_Pos = 0x2
	// Bit mask of MEM_FORCE_PD field.
	RMT_SYS_CONF_MEM_FORCE_PD_Msk = 0x4
	// Bit MEM_FORCE_PD.
	RMT_SYS_CONF_MEM_FORCE_PD = 0x4
	// Position of MEM_FORCE_PU field.
	RMT_SYS_CONF_MEM_FORCE_PU_Pos = 0x3
	// Bit mask of MEM_FORCE_PU field.
	RMT_SYS_CONF_MEM_FORCE_PU_Msk = 0x8
	// Bit MEM_FORCE_PU.
	RMT_SYS_CONF_MEM_FORCE_PU = 0x8
	// Position of SCLK_DIV_NUM field.
	RMT_SYS_CONF_SCLK_DIV_NUM_Pos = 0x4
	// Bit mask of SCLK_DIV_NUM field.
	RMT_SYS_CONF_SCLK_DIV_NUM_Msk = 0xff0
	// Position of SCLK_DIV_A field.
	RMT_SYS_CONF_SCLK_DIV_A_Pos = 0xc
	// Bit mask of SCLK_DIV_A field.
	RMT_SYS_CONF_SCLK_DIV_A_Msk = 0x3f000
	// Position of SCLK_DIV_B field.
	RMT_SYS_CONF_SCLK_DIV_B_Pos = 0x12
	// Bit mask of SCLK_DIV_B field.
	RMT_SYS_CONF_SCLK_DIV_B_Msk = 0xfc0000
	// Position of SCLK_SEL field.
	RMT_SYS_CONF_SCLK_SEL_Pos = 0x18
	// Bit mask of SCLK_SEL field.
	RMT_SYS_CONF_SCLK_SEL_Msk = 0x3000000
	// Position of SCLK_ACTIVE field.
	RMT_SYS_CONF_SCLK_ACTIVE_Pos = 0x1a
	// Bit mask of SCLK_ACTIVE field.
	RMT_SYS_CONF_SCLK_ACTIVE_Msk = 0x4000000
	// Bit SCLK_ACTIVE.
	RMT_SYS_CONF_SCLK_ACTIVE = 0x4000000
	// Position of CLK_EN field.
	RMT_SYS_CONF_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	RMT_SYS_CONF_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	RMT_SYS_CONF_CLK_EN = 0x80000000

	// TX_SIM: RMT TX synchronous register
	// Position of CH0 field.
	RMT_TX_SIM_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	RMT_TX_SIM_CH0_Msk = 0x1
	// Bit CH0.
	RMT_TX_SIM_CH0 = 0x1
	// Position of CH1 field.
	RMT_TX_SIM_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	RMT_TX_SIM_CH1_Msk = 0x2
	// Bit CH1.
	RMT_TX_SIM_CH1 = 0x2
	// Position of EN field.
	RMT_TX_SIM_EN_Pos = 0x2
	// Bit mask of EN field.
	RMT_TX_SIM_EN_Msk = 0x4
	// Bit EN.
	RMT_TX_SIM_EN = 0x4

	// REF_CNT_RST: RMT clock divider reset register
	// Position of TX_REF_CNT_RST field.
	RMT_REF_CNT_RST_TX_REF_CNT_RST_Pos = 0x0
	// Bit mask of TX_REF_CNT_RST field.
	RMT_REF_CNT_RST_TX_REF_CNT_RST_Msk = 0x1
	// Bit TX_REF_CNT_RST.
	RMT_REF_CNT_RST_TX_REF_CNT_RST = 0x1
	// Position of TX_REF_CNT_RST_CH1 field.
	RMT_REF_CNT_RST_TX_REF_CNT_RST_CH1_Pos = 0x1
	// Bit mask of TX_REF_CNT_RST_CH1 field.
	RMT_REF_CNT_RST_TX_REF_CNT_RST_CH1_Msk = 0x2
	// Bit TX_REF_CNT_RST_CH1.
	RMT_REF_CNT_RST_TX_REF_CNT_RST_CH1 = 0x2
	// Position of RX_REF_CNT_RST_CH2 field.
	RMT_REF_CNT_RST_RX_REF_CNT_RST_CH2_Pos = 0x2
	// Bit mask of RX_REF_CNT_RST_CH2 field.
	RMT_REF_CNT_RST_RX_REF_CNT_RST_CH2_Msk = 0x4
	// Bit RX_REF_CNT_RST_CH2.
	RMT_REF_CNT_RST_RX_REF_CNT_RST_CH2 = 0x4
	// Position of RX_REF_CNT_RST_CH3 field.
	RMT_REF_CNT_RST_RX_REF_CNT_RST_CH3_Pos = 0x3
	// Bit mask of RX_REF_CNT_RST_CH3 field.
	RMT_REF_CNT_RST_RX_REF_CNT_RST_CH3_Msk = 0x8
	// Bit RX_REF_CNT_RST_CH3.
	RMT_REF_CNT_RST_RX_REF_CNT_RST_CH3 = 0x8

	// DATE: RMT version register
	// Position of RMT_DATE field.
	RMT_DATE_RMT_DATE_Pos = 0x0
	// Bit mask of RMT_DATE field.
	RMT_DATE_RMT_DATE_Msk = 0xfffffff
)

// Constants for RNG: Hardware Random Number Generator
const ()

// Constants for RSA: RSA (Rivest Shamir Adleman) Accelerator
const (
	// M_PRIME: Represents M’
	// Position of M_PRIME field.
	RSA_M_PRIME_M_PRIME_Pos = 0x0
	// Bit mask of M_PRIME field.
	RSA_M_PRIME_M_PRIME_Msk = 0xffffffff

	// MODE: Configures RSA length
	// Position of MODE field.
	RSA_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	RSA_MODE_MODE_Msk = 0x7f

	// QUERY_CLEAN: RSA clean register
	// Position of QUERY_CLEAN field.
	RSA_QUERY_CLEAN_QUERY_CLEAN_Pos = 0x0
	// Bit mask of QUERY_CLEAN field.
	RSA_QUERY_CLEAN_QUERY_CLEAN_Msk = 0x1
	// Bit QUERY_CLEAN.
	RSA_QUERY_CLEAN_QUERY_CLEAN = 0x1

	// SET_START_MODEXP: Starts modular exponentiation
	// Position of SET_START_MODEXP field.
	RSA_SET_START_MODEXP_SET_START_MODEXP_Pos = 0x0
	// Bit mask of SET_START_MODEXP field.
	RSA_SET_START_MODEXP_SET_START_MODEXP_Msk = 0x1
	// Bit SET_START_MODEXP.
	RSA_SET_START_MODEXP_SET_START_MODEXP = 0x1

	// SET_START_MODMULT: Starts modular multiplication
	// Position of SET_START_MODMULT field.
	RSA_SET_START_MODMULT_SET_START_MODMULT_Pos = 0x0
	// Bit mask of SET_START_MODMULT field.
	RSA_SET_START_MODMULT_SET_START_MODMULT_Msk = 0x1
	// Bit SET_START_MODMULT.
	RSA_SET_START_MODMULT_SET_START_MODMULT = 0x1

	// SET_START_MULT: Starts multiplication
	// Position of SET_START_MULT field.
	RSA_SET_START_MULT_SET_START_MULT_Pos = 0x0
	// Bit mask of SET_START_MULT field.
	RSA_SET_START_MULT_SET_START_MULT_Msk = 0x1
	// Bit SET_START_MULT.
	RSA_SET_START_MULT_SET_START_MULT = 0x1

	// QUERY_IDLE: Represents the RSA status
	// Position of QUERY_IDLE field.
	RSA_QUERY_IDLE_QUERY_IDLE_Pos = 0x0
	// Bit mask of QUERY_IDLE field.
	RSA_QUERY_IDLE_QUERY_IDLE_Msk = 0x1
	// Bit QUERY_IDLE.
	RSA_QUERY_IDLE_QUERY_IDLE = 0x1

	// INT_CLR: Clears RSA interrupt
	// Position of CLEAR_INTERRUPT field.
	RSA_INT_CLR_CLEAR_INTERRUPT_Pos = 0x0
	// Bit mask of CLEAR_INTERRUPT field.
	RSA_INT_CLR_CLEAR_INTERRUPT_Msk = 0x1
	// Bit CLEAR_INTERRUPT.
	RSA_INT_CLR_CLEAR_INTERRUPT = 0x1

	// CONSTANT_TIME: Configures the constant_time option
	// Position of CONSTANT_TIME field.
	RSA_CONSTANT_TIME_CONSTANT_TIME_Pos = 0x0
	// Bit mask of CONSTANT_TIME field.
	RSA_CONSTANT_TIME_CONSTANT_TIME_Msk = 0x1
	// Bit CONSTANT_TIME.
	RSA_CONSTANT_TIME_CONSTANT_TIME = 0x1

	// SEARCH_ENABLE: Configures the search option
	// Position of SEARCH_ENABLE field.
	RSA_SEARCH_ENABLE_SEARCH_ENABLE_Pos = 0x0
	// Bit mask of SEARCH_ENABLE field.
	RSA_SEARCH_ENABLE_SEARCH_ENABLE_Msk = 0x1
	// Bit SEARCH_ENABLE.
	RSA_SEARCH_ENABLE_SEARCH_ENABLE = 0x1

	// SEARCH_POS: Configures the search position
	// Position of SEARCH_POS field.
	RSA_SEARCH_POS_SEARCH_POS_Pos = 0x0
	// Bit mask of SEARCH_POS field.
	RSA_SEARCH_POS_SEARCH_POS_Msk = 0xfff

	// INT_ENA: Enables the RSA interrupt
	// Position of INT_ENA field.
	RSA_INT_ENA_INT_ENA_Pos = 0x0
	// Bit mask of INT_ENA field.
	RSA_INT_ENA_INT_ENA_Msk = 0x1
	// Bit INT_ENA.
	RSA_INT_ENA_INT_ENA = 0x1

	// DATE: Version control register
	// Position of DATE field.
	RSA_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	RSA_DATE_DATE_Msk = 0x3fffffff
)

// Constants for SHA: SHA (Secure Hash Algorithm) Accelerator
const (
	// MODE: Initial configuration register.
	// Position of MODE field.
	SHA_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SHA_MODE_MODE_Msk = 0x7

	// T_STRING: SHA 512/t configuration register 0.
	// Position of T_STRING field.
	SHA_T_STRING_T_STRING_Pos = 0x0
	// Bit mask of T_STRING field.
	SHA_T_STRING_T_STRING_Msk = 0xffffffff

	// T_LENGTH: SHA 512/t configuration register 1.
	// Position of T_LENGTH field.
	SHA_T_LENGTH_T_LENGTH_Pos = 0x0
	// Bit mask of T_LENGTH field.
	SHA_T_LENGTH_T_LENGTH_Msk = 0x3f

	// DMA_BLOCK_NUM: DMA configuration register 0.
	// Position of DMA_BLOCK_NUM field.
	SHA_DMA_BLOCK_NUM_DMA_BLOCK_NUM_Pos = 0x0
	// Bit mask of DMA_BLOCK_NUM field.
	SHA_DMA_BLOCK_NUM_DMA_BLOCK_NUM_Msk = 0x3f

	// START: Typical SHA configuration register 0.
	// Position of START field.
	SHA_START_START_Pos = 0x1
	// Bit mask of START field.
	SHA_START_START_Msk = 0xfffffffe

	// CONTINUE: Typical SHA configuration register 1.
	// Position of CONTINUE field.
	SHA_CONTINUE_CONTINUE_Pos = 0x1
	// Bit mask of CONTINUE field.
	SHA_CONTINUE_CONTINUE_Msk = 0xfffffffe

	// BUSY: Busy register.
	// Position of STATE field.
	SHA_BUSY_STATE_Pos = 0x0
	// Bit mask of STATE field.
	SHA_BUSY_STATE_Msk = 0x1
	// Bit STATE.
	SHA_BUSY_STATE = 0x1

	// DMA_START: DMA configuration register 1.
	// Position of DMA_START field.
	SHA_DMA_START_DMA_START_Pos = 0x0
	// Bit mask of DMA_START field.
	SHA_DMA_START_DMA_START_Msk = 0x1
	// Bit DMA_START.
	SHA_DMA_START_DMA_START = 0x1

	// DMA_CONTINUE: DMA configuration register 2.
	// Position of DMA_CONTINUE field.
	SHA_DMA_CONTINUE_DMA_CONTINUE_Pos = 0x0
	// Bit mask of DMA_CONTINUE field.
	SHA_DMA_CONTINUE_DMA_CONTINUE_Msk = 0x1
	// Bit DMA_CONTINUE.
	SHA_DMA_CONTINUE_DMA_CONTINUE = 0x1

	// CLEAR_IRQ: Interrupt clear register.
	// Position of CLEAR_INTERRUPT field.
	SHA_CLEAR_IRQ_CLEAR_INTERRUPT_Pos = 0x0
	// Bit mask of CLEAR_INTERRUPT field.
	SHA_CLEAR_IRQ_CLEAR_INTERRUPT_Msk = 0x1
	// Bit CLEAR_INTERRUPT.
	SHA_CLEAR_IRQ_CLEAR_INTERRUPT = 0x1

	// IRQ_ENA: Interrupt enable register.
	// Position of INTERRUPT_ENA field.
	SHA_IRQ_ENA_INTERRUPT_ENA_Pos = 0x0
	// Bit mask of INTERRUPT_ENA field.
	SHA_IRQ_ENA_INTERRUPT_ENA_Msk = 0x1
	// Bit INTERRUPT_ENA.
	SHA_IRQ_ENA_INTERRUPT_ENA = 0x1

	// DATE: Date register.
	// Position of DATE field.
	SHA_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	SHA_DATE_DATE_Msk = 0x3fffffff
)

// Constants for SOC_ETM: Event Task Matrix
const (
	// CH_ENA_AD0: channel enable register
	// Position of CH_ENA0 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA0_Pos = 0x0
	// Bit mask of CH_ENA0 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA0_Msk = 0x1
	// Bit CH_ENA0.
	SOC_ETM_CH_ENA_AD0_CH_ENA0 = 0x1
	// Position of CH_ENA1 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA1_Pos = 0x1
	// Bit mask of CH_ENA1 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA1_Msk = 0x2
	// Bit CH_ENA1.
	SOC_ETM_CH_ENA_AD0_CH_ENA1 = 0x2
	// Position of CH_ENA2 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA2_Pos = 0x2
	// Bit mask of CH_ENA2 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA2_Msk = 0x4
	// Bit CH_ENA2.
	SOC_ETM_CH_ENA_AD0_CH_ENA2 = 0x4
	// Position of CH_ENA3 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA3_Pos = 0x3
	// Bit mask of CH_ENA3 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA3_Msk = 0x8
	// Bit CH_ENA3.
	SOC_ETM_CH_ENA_AD0_CH_ENA3 = 0x8
	// Position of CH_ENA4 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA4_Pos = 0x4
	// Bit mask of CH_ENA4 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA4_Msk = 0x10
	// Bit CH_ENA4.
	SOC_ETM_CH_ENA_AD0_CH_ENA4 = 0x10
	// Position of CH_ENA5 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA5_Pos = 0x5
	// Bit mask of CH_ENA5 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA5_Msk = 0x20
	// Bit CH_ENA5.
	SOC_ETM_CH_ENA_AD0_CH_ENA5 = 0x20
	// Position of CH_ENA6 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA6_Pos = 0x6
	// Bit mask of CH_ENA6 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA6_Msk = 0x40
	// Bit CH_ENA6.
	SOC_ETM_CH_ENA_AD0_CH_ENA6 = 0x40
	// Position of CH_ENA7 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA7_Pos = 0x7
	// Bit mask of CH_ENA7 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA7_Msk = 0x80
	// Bit CH_ENA7.
	SOC_ETM_CH_ENA_AD0_CH_ENA7 = 0x80
	// Position of CH_ENA8 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA8_Pos = 0x8
	// Bit mask of CH_ENA8 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA8_Msk = 0x100
	// Bit CH_ENA8.
	SOC_ETM_CH_ENA_AD0_CH_ENA8 = 0x100
	// Position of CH_ENA9 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA9_Pos = 0x9
	// Bit mask of CH_ENA9 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA9_Msk = 0x200
	// Bit CH_ENA9.
	SOC_ETM_CH_ENA_AD0_CH_ENA9 = 0x200
	// Position of CH_ENA10 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA10_Pos = 0xa
	// Bit mask of CH_ENA10 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA10_Msk = 0x400
	// Bit CH_ENA10.
	SOC_ETM_CH_ENA_AD0_CH_ENA10 = 0x400
	// Position of CH_ENA11 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA11_Pos = 0xb
	// Bit mask of CH_ENA11 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA11_Msk = 0x800
	// Bit CH_ENA11.
	SOC_ETM_CH_ENA_AD0_CH_ENA11 = 0x800
	// Position of CH_ENA12 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA12_Pos = 0xc
	// Bit mask of CH_ENA12 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA12_Msk = 0x1000
	// Bit CH_ENA12.
	SOC_ETM_CH_ENA_AD0_CH_ENA12 = 0x1000
	// Position of CH_ENA13 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA13_Pos = 0xd
	// Bit mask of CH_ENA13 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA13_Msk = 0x2000
	// Bit CH_ENA13.
	SOC_ETM_CH_ENA_AD0_CH_ENA13 = 0x2000
	// Position of CH_ENA14 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA14_Pos = 0xe
	// Bit mask of CH_ENA14 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA14_Msk = 0x4000
	// Bit CH_ENA14.
	SOC_ETM_CH_ENA_AD0_CH_ENA14 = 0x4000
	// Position of CH_ENA15 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA15_Pos = 0xf
	// Bit mask of CH_ENA15 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA15_Msk = 0x8000
	// Bit CH_ENA15.
	SOC_ETM_CH_ENA_AD0_CH_ENA15 = 0x8000
	// Position of CH_ENA16 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA16_Pos = 0x10
	// Bit mask of CH_ENA16 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA16_Msk = 0x10000
	// Bit CH_ENA16.
	SOC_ETM_CH_ENA_AD0_CH_ENA16 = 0x10000
	// Position of CH_ENA17 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA17_Pos = 0x11
	// Bit mask of CH_ENA17 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA17_Msk = 0x20000
	// Bit CH_ENA17.
	SOC_ETM_CH_ENA_AD0_CH_ENA17 = 0x20000
	// Position of CH_ENA18 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA18_Pos = 0x12
	// Bit mask of CH_ENA18 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA18_Msk = 0x40000
	// Bit CH_ENA18.
	SOC_ETM_CH_ENA_AD0_CH_ENA18 = 0x40000
	// Position of CH_ENA19 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA19_Pos = 0x13
	// Bit mask of CH_ENA19 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA19_Msk = 0x80000
	// Bit CH_ENA19.
	SOC_ETM_CH_ENA_AD0_CH_ENA19 = 0x80000
	// Position of CH_ENA20 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA20_Pos = 0x14
	// Bit mask of CH_ENA20 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA20_Msk = 0x100000
	// Bit CH_ENA20.
	SOC_ETM_CH_ENA_AD0_CH_ENA20 = 0x100000
	// Position of CH_ENA21 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA21_Pos = 0x15
	// Bit mask of CH_ENA21 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA21_Msk = 0x200000
	// Bit CH_ENA21.
	SOC_ETM_CH_ENA_AD0_CH_ENA21 = 0x200000
	// Position of CH_ENA22 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA22_Pos = 0x16
	// Bit mask of CH_ENA22 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA22_Msk = 0x400000
	// Bit CH_ENA22.
	SOC_ETM_CH_ENA_AD0_CH_ENA22 = 0x400000
	// Position of CH_ENA23 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA23_Pos = 0x17
	// Bit mask of CH_ENA23 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA23_Msk = 0x800000
	// Bit CH_ENA23.
	SOC_ETM_CH_ENA_AD0_CH_ENA23 = 0x800000
	// Position of CH_ENA24 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA24_Pos = 0x18
	// Bit mask of CH_ENA24 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA24_Msk = 0x1000000
	// Bit CH_ENA24.
	SOC_ETM_CH_ENA_AD0_CH_ENA24 = 0x1000000
	// Position of CH_ENA25 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA25_Pos = 0x19
	// Bit mask of CH_ENA25 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA25_Msk = 0x2000000
	// Bit CH_ENA25.
	SOC_ETM_CH_ENA_AD0_CH_ENA25 = 0x2000000
	// Position of CH_ENA26 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA26_Pos = 0x1a
	// Bit mask of CH_ENA26 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA26_Msk = 0x4000000
	// Bit CH_ENA26.
	SOC_ETM_CH_ENA_AD0_CH_ENA26 = 0x4000000
	// Position of CH_ENA27 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA27_Pos = 0x1b
	// Bit mask of CH_ENA27 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA27_Msk = 0x8000000
	// Bit CH_ENA27.
	SOC_ETM_CH_ENA_AD0_CH_ENA27 = 0x8000000
	// Position of CH_ENA28 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA28_Pos = 0x1c
	// Bit mask of CH_ENA28 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA28_Msk = 0x10000000
	// Bit CH_ENA28.
	SOC_ETM_CH_ENA_AD0_CH_ENA28 = 0x10000000
	// Position of CH_ENA29 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA29_Pos = 0x1d
	// Bit mask of CH_ENA29 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA29_Msk = 0x20000000
	// Bit CH_ENA29.
	SOC_ETM_CH_ENA_AD0_CH_ENA29 = 0x20000000
	// Position of CH_ENA30 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA30_Pos = 0x1e
	// Bit mask of CH_ENA30 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA30_Msk = 0x40000000
	// Bit CH_ENA30.
	SOC_ETM_CH_ENA_AD0_CH_ENA30 = 0x40000000
	// Position of CH_ENA31 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA31_Pos = 0x1f
	// Bit mask of CH_ENA31 field.
	SOC_ETM_CH_ENA_AD0_CH_ENA31_Msk = 0x80000000
	// Bit CH_ENA31.
	SOC_ETM_CH_ENA_AD0_CH_ENA31 = 0x80000000

	// CH_ENA_AD0_SET: channel enable set register
	// Position of CH_SET0 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET0_Pos = 0x0
	// Bit mask of CH_SET0 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET0_Msk = 0x1
	// Bit CH_SET0.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET0 = 0x1
	// Position of CH_SET1 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET1_Pos = 0x1
	// Bit mask of CH_SET1 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET1_Msk = 0x2
	// Bit CH_SET1.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET1 = 0x2
	// Position of CH_SET2 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET2_Pos = 0x2
	// Bit mask of CH_SET2 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET2_Msk = 0x4
	// Bit CH_SET2.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET2 = 0x4
	// Position of CH_SET3 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET3_Pos = 0x3
	// Bit mask of CH_SET3 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET3_Msk = 0x8
	// Bit CH_SET3.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET3 = 0x8
	// Position of CH_SET4 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET4_Pos = 0x4
	// Bit mask of CH_SET4 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET4_Msk = 0x10
	// Bit CH_SET4.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET4 = 0x10
	// Position of CH_SET5 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET5_Pos = 0x5
	// Bit mask of CH_SET5 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET5_Msk = 0x20
	// Bit CH_SET5.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET5 = 0x20
	// Position of CH_SET6 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET6_Pos = 0x6
	// Bit mask of CH_SET6 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET6_Msk = 0x40
	// Bit CH_SET6.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET6 = 0x40
	// Position of CH_SET7 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET7_Pos = 0x7
	// Bit mask of CH_SET7 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET7_Msk = 0x80
	// Bit CH_SET7.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET7 = 0x80
	// Position of CH_SET8 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET8_Pos = 0x8
	// Bit mask of CH_SET8 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET8_Msk = 0x100
	// Bit CH_SET8.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET8 = 0x100
	// Position of CH_SET9 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET9_Pos = 0x9
	// Bit mask of CH_SET9 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET9_Msk = 0x200
	// Bit CH_SET9.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET9 = 0x200
	// Position of CH_SET10 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET10_Pos = 0xa
	// Bit mask of CH_SET10 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET10_Msk = 0x400
	// Bit CH_SET10.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET10 = 0x400
	// Position of CH_SET11 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET11_Pos = 0xb
	// Bit mask of CH_SET11 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET11_Msk = 0x800
	// Bit CH_SET11.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET11 = 0x800
	// Position of CH_SET12 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET12_Pos = 0xc
	// Bit mask of CH_SET12 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET12_Msk = 0x1000
	// Bit CH_SET12.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET12 = 0x1000
	// Position of CH_SET13 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET13_Pos = 0xd
	// Bit mask of CH_SET13 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET13_Msk = 0x2000
	// Bit CH_SET13.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET13 = 0x2000
	// Position of CH_SET14 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET14_Pos = 0xe
	// Bit mask of CH_SET14 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET14_Msk = 0x4000
	// Bit CH_SET14.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET14 = 0x4000
	// Position of CH_SET15 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET15_Pos = 0xf
	// Bit mask of CH_SET15 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET15_Msk = 0x8000
	// Bit CH_SET15.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET15 = 0x8000
	// Position of CH_SET16 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET16_Pos = 0x10
	// Bit mask of CH_SET16 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET16_Msk = 0x10000
	// Bit CH_SET16.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET16 = 0x10000
	// Position of CH_SET17 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET17_Pos = 0x11
	// Bit mask of CH_SET17 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET17_Msk = 0x20000
	// Bit CH_SET17.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET17 = 0x20000
	// Position of CH_SET18 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET18_Pos = 0x12
	// Bit mask of CH_SET18 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET18_Msk = 0x40000
	// Bit CH_SET18.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET18 = 0x40000
	// Position of CH_SET19 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET19_Pos = 0x13
	// Bit mask of CH_SET19 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET19_Msk = 0x80000
	// Bit CH_SET19.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET19 = 0x80000
	// Position of CH_SET20 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET20_Pos = 0x14
	// Bit mask of CH_SET20 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET20_Msk = 0x100000
	// Bit CH_SET20.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET20 = 0x100000
	// Position of CH_SET21 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET21_Pos = 0x15
	// Bit mask of CH_SET21 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET21_Msk = 0x200000
	// Bit CH_SET21.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET21 = 0x200000
	// Position of CH_SET22 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET22_Pos = 0x16
	// Bit mask of CH_SET22 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET22_Msk = 0x400000
	// Bit CH_SET22.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET22 = 0x400000
	// Position of CH_SET23 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET23_Pos = 0x17
	// Bit mask of CH_SET23 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET23_Msk = 0x800000
	// Bit CH_SET23.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET23 = 0x800000
	// Position of CH_SET24 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET24_Pos = 0x18
	// Bit mask of CH_SET24 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET24_Msk = 0x1000000
	// Bit CH_SET24.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET24 = 0x1000000
	// Position of CH_SET25 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET25_Pos = 0x19
	// Bit mask of CH_SET25 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET25_Msk = 0x2000000
	// Bit CH_SET25.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET25 = 0x2000000
	// Position of CH_SET26 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET26_Pos = 0x1a
	// Bit mask of CH_SET26 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET26_Msk = 0x4000000
	// Bit CH_SET26.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET26 = 0x4000000
	// Position of CH_SET27 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET27_Pos = 0x1b
	// Bit mask of CH_SET27 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET27_Msk = 0x8000000
	// Bit CH_SET27.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET27 = 0x8000000
	// Position of CH_SET28 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET28_Pos = 0x1c
	// Bit mask of CH_SET28 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET28_Msk = 0x10000000
	// Bit CH_SET28.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET28 = 0x10000000
	// Position of CH_SET29 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET29_Pos = 0x1d
	// Bit mask of CH_SET29 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET29_Msk = 0x20000000
	// Bit CH_SET29.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET29 = 0x20000000
	// Position of CH_SET30 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET30_Pos = 0x1e
	// Bit mask of CH_SET30 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET30_Msk = 0x40000000
	// Bit CH_SET30.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET30 = 0x40000000
	// Position of CH_SET31 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET31_Pos = 0x1f
	// Bit mask of CH_SET31 field.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET31_Msk = 0x80000000
	// Bit CH_SET31.
	SOC_ETM_CH_ENA_AD0_SET_CH_SET31 = 0x80000000

	// CH_ENA_AD0_CLR: channel enable clear register
	// Position of CH_CLR0 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR0_Pos = 0x0
	// Bit mask of CH_CLR0 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR0_Msk = 0x1
	// Bit CH_CLR0.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR0 = 0x1
	// Position of CH_CLR1 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR1_Pos = 0x1
	// Bit mask of CH_CLR1 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR1_Msk = 0x2
	// Bit CH_CLR1.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR1 = 0x2
	// Position of CH_CLR2 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR2_Pos = 0x2
	// Bit mask of CH_CLR2 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR2_Msk = 0x4
	// Bit CH_CLR2.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR2 = 0x4
	// Position of CH_CLR3 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR3_Pos = 0x3
	// Bit mask of CH_CLR3 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR3_Msk = 0x8
	// Bit CH_CLR3.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR3 = 0x8
	// Position of CH_CLR4 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR4_Pos = 0x4
	// Bit mask of CH_CLR4 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR4_Msk = 0x10
	// Bit CH_CLR4.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR4 = 0x10
	// Position of CH_CLR5 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR5_Pos = 0x5
	// Bit mask of CH_CLR5 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR5_Msk = 0x20
	// Bit CH_CLR5.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR5 = 0x20
	// Position of CH_CLR6 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR6_Pos = 0x6
	// Bit mask of CH_CLR6 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR6_Msk = 0x40
	// Bit CH_CLR6.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR6 = 0x40
	// Position of CH_CLR7 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR7_Pos = 0x7
	// Bit mask of CH_CLR7 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR7_Msk = 0x80
	// Bit CH_CLR7.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR7 = 0x80
	// Position of CH_CLR8 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR8_Pos = 0x8
	// Bit mask of CH_CLR8 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR8_Msk = 0x100
	// Bit CH_CLR8.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR8 = 0x100
	// Position of CH_CLR9 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR9_Pos = 0x9
	// Bit mask of CH_CLR9 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR9_Msk = 0x200
	// Bit CH_CLR9.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR9 = 0x200
	// Position of CH_CLR10 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR10_Pos = 0xa
	// Bit mask of CH_CLR10 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR10_Msk = 0x400
	// Bit CH_CLR10.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR10 = 0x400
	// Position of CH_CLR11 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR11_Pos = 0xb
	// Bit mask of CH_CLR11 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR11_Msk = 0x800
	// Bit CH_CLR11.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR11 = 0x800
	// Position of CH_CLR12 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR12_Pos = 0xc
	// Bit mask of CH_CLR12 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR12_Msk = 0x1000
	// Bit CH_CLR12.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR12 = 0x1000
	// Position of CH_CLR13 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR13_Pos = 0xd
	// Bit mask of CH_CLR13 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR13_Msk = 0x2000
	// Bit CH_CLR13.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR13 = 0x2000
	// Position of CH_CLR14 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR14_Pos = 0xe
	// Bit mask of CH_CLR14 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR14_Msk = 0x4000
	// Bit CH_CLR14.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR14 = 0x4000
	// Position of CH_CLR15 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR15_Pos = 0xf
	// Bit mask of CH_CLR15 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR15_Msk = 0x8000
	// Bit CH_CLR15.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR15 = 0x8000
	// Position of CH_CLR16 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR16_Pos = 0x10
	// Bit mask of CH_CLR16 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR16_Msk = 0x10000
	// Bit CH_CLR16.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR16 = 0x10000
	// Position of CH_CLR17 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR17_Pos = 0x11
	// Bit mask of CH_CLR17 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR17_Msk = 0x20000
	// Bit CH_CLR17.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR17 = 0x20000
	// Position of CH_CLR18 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR18_Pos = 0x12
	// Bit mask of CH_CLR18 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR18_Msk = 0x40000
	// Bit CH_CLR18.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR18 = 0x40000
	// Position of CH_CLR19 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR19_Pos = 0x13
	// Bit mask of CH_CLR19 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR19_Msk = 0x80000
	// Bit CH_CLR19.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR19 = 0x80000
	// Position of CH_CLR20 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR20_Pos = 0x14
	// Bit mask of CH_CLR20 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR20_Msk = 0x100000
	// Bit CH_CLR20.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR20 = 0x100000
	// Position of CH_CLR21 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR21_Pos = 0x15
	// Bit mask of CH_CLR21 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR21_Msk = 0x200000
	// Bit CH_CLR21.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR21 = 0x200000
	// Position of CH_CLR22 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR22_Pos = 0x16
	// Bit mask of CH_CLR22 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR22_Msk = 0x400000
	// Bit CH_CLR22.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR22 = 0x400000
	// Position of CH_CLR23 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR23_Pos = 0x17
	// Bit mask of CH_CLR23 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR23_Msk = 0x800000
	// Bit CH_CLR23.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR23 = 0x800000
	// Position of CH_CLR24 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR24_Pos = 0x18
	// Bit mask of CH_CLR24 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR24_Msk = 0x1000000
	// Bit CH_CLR24.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR24 = 0x1000000
	// Position of CH_CLR25 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR25_Pos = 0x19
	// Bit mask of CH_CLR25 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR25_Msk = 0x2000000
	// Bit CH_CLR25.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR25 = 0x2000000
	// Position of CH_CLR26 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR26_Pos = 0x1a
	// Bit mask of CH_CLR26 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR26_Msk = 0x4000000
	// Bit CH_CLR26.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR26 = 0x4000000
	// Position of CH_CLR27 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR27_Pos = 0x1b
	// Bit mask of CH_CLR27 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR27_Msk = 0x8000000
	// Bit CH_CLR27.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR27 = 0x8000000
	// Position of CH_CLR28 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR28_Pos = 0x1c
	// Bit mask of CH_CLR28 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR28_Msk = 0x10000000
	// Bit CH_CLR28.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR28 = 0x10000000
	// Position of CH_CLR29 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR29_Pos = 0x1d
	// Bit mask of CH_CLR29 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR29_Msk = 0x20000000
	// Bit CH_CLR29.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR29 = 0x20000000
	// Position of CH_CLR30 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR30_Pos = 0x1e
	// Bit mask of CH_CLR30 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR30_Msk = 0x40000000
	// Bit CH_CLR30.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR30 = 0x40000000
	// Position of CH_CLR31 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR31_Pos = 0x1f
	// Bit mask of CH_CLR31 field.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR31_Msk = 0x80000000
	// Bit CH_CLR31.
	SOC_ETM_CH_ENA_AD0_CLR_CH_CLR31 = 0x80000000

	// CH_ENA_AD1: channel enable register
	// Position of CH_ENA32 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA32_Pos = 0x0
	// Bit mask of CH_ENA32 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA32_Msk = 0x1
	// Bit CH_ENA32.
	SOC_ETM_CH_ENA_AD1_CH_ENA32 = 0x1
	// Position of CH_ENA33 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA33_Pos = 0x1
	// Bit mask of CH_ENA33 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA33_Msk = 0x2
	// Bit CH_ENA33.
	SOC_ETM_CH_ENA_AD1_CH_ENA33 = 0x2
	// Position of CH_ENA34 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA34_Pos = 0x2
	// Bit mask of CH_ENA34 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA34_Msk = 0x4
	// Bit CH_ENA34.
	SOC_ETM_CH_ENA_AD1_CH_ENA34 = 0x4
	// Position of CH_ENA35 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA35_Pos = 0x3
	// Bit mask of CH_ENA35 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA35_Msk = 0x8
	// Bit CH_ENA35.
	SOC_ETM_CH_ENA_AD1_CH_ENA35 = 0x8
	// Position of CH_ENA36 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA36_Pos = 0x4
	// Bit mask of CH_ENA36 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA36_Msk = 0x10
	// Bit CH_ENA36.
	SOC_ETM_CH_ENA_AD1_CH_ENA36 = 0x10
	// Position of CH_ENA37 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA37_Pos = 0x5
	// Bit mask of CH_ENA37 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA37_Msk = 0x20
	// Bit CH_ENA37.
	SOC_ETM_CH_ENA_AD1_CH_ENA37 = 0x20
	// Position of CH_ENA38 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA38_Pos = 0x6
	// Bit mask of CH_ENA38 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA38_Msk = 0x40
	// Bit CH_ENA38.
	SOC_ETM_CH_ENA_AD1_CH_ENA38 = 0x40
	// Position of CH_ENA39 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA39_Pos = 0x7
	// Bit mask of CH_ENA39 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA39_Msk = 0x80
	// Bit CH_ENA39.
	SOC_ETM_CH_ENA_AD1_CH_ENA39 = 0x80
	// Position of CH_ENA40 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA40_Pos = 0x8
	// Bit mask of CH_ENA40 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA40_Msk = 0x100
	// Bit CH_ENA40.
	SOC_ETM_CH_ENA_AD1_CH_ENA40 = 0x100
	// Position of CH_ENA41 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA41_Pos = 0x9
	// Bit mask of CH_ENA41 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA41_Msk = 0x200
	// Bit CH_ENA41.
	SOC_ETM_CH_ENA_AD1_CH_ENA41 = 0x200
	// Position of CH_ENA42 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA42_Pos = 0xa
	// Bit mask of CH_ENA42 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA42_Msk = 0x400
	// Bit CH_ENA42.
	SOC_ETM_CH_ENA_AD1_CH_ENA42 = 0x400
	// Position of CH_ENA43 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA43_Pos = 0xb
	// Bit mask of CH_ENA43 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA43_Msk = 0x800
	// Bit CH_ENA43.
	SOC_ETM_CH_ENA_AD1_CH_ENA43 = 0x800
	// Position of CH_ENA44 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA44_Pos = 0xc
	// Bit mask of CH_ENA44 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA44_Msk = 0x1000
	// Bit CH_ENA44.
	SOC_ETM_CH_ENA_AD1_CH_ENA44 = 0x1000
	// Position of CH_ENA45 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA45_Pos = 0xd
	// Bit mask of CH_ENA45 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA45_Msk = 0x2000
	// Bit CH_ENA45.
	SOC_ETM_CH_ENA_AD1_CH_ENA45 = 0x2000
	// Position of CH_ENA46 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA46_Pos = 0xe
	// Bit mask of CH_ENA46 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA46_Msk = 0x4000
	// Bit CH_ENA46.
	SOC_ETM_CH_ENA_AD1_CH_ENA46 = 0x4000
	// Position of CH_ENA47 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA47_Pos = 0xf
	// Bit mask of CH_ENA47 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA47_Msk = 0x8000
	// Bit CH_ENA47.
	SOC_ETM_CH_ENA_AD1_CH_ENA47 = 0x8000
	// Position of CH_ENA48 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA48_Pos = 0x10
	// Bit mask of CH_ENA48 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA48_Msk = 0x10000
	// Bit CH_ENA48.
	SOC_ETM_CH_ENA_AD1_CH_ENA48 = 0x10000
	// Position of CH_ENA49 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA49_Pos = 0x11
	// Bit mask of CH_ENA49 field.
	SOC_ETM_CH_ENA_AD1_CH_ENA49_Msk = 0x20000
	// Bit CH_ENA49.
	SOC_ETM_CH_ENA_AD1_CH_ENA49 = 0x20000

	// CH_ENA_AD1_SET: channel enable set register
	// Position of CH_SET32 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET32_Pos = 0x0
	// Bit mask of CH_SET32 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET32_Msk = 0x1
	// Bit CH_SET32.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET32 = 0x1
	// Position of CH_SET33 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET33_Pos = 0x1
	// Bit mask of CH_SET33 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET33_Msk = 0x2
	// Bit CH_SET33.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET33 = 0x2
	// Position of CH_SET34 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET34_Pos = 0x2
	// Bit mask of CH_SET34 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET34_Msk = 0x4
	// Bit CH_SET34.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET34 = 0x4
	// Position of CH_SET35 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET35_Pos = 0x3
	// Bit mask of CH_SET35 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET35_Msk = 0x8
	// Bit CH_SET35.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET35 = 0x8
	// Position of CH_SET36 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET36_Pos = 0x4
	// Bit mask of CH_SET36 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET36_Msk = 0x10
	// Bit CH_SET36.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET36 = 0x10
	// Position of CH_SET37 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET37_Pos = 0x5
	// Bit mask of CH_SET37 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET37_Msk = 0x20
	// Bit CH_SET37.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET37 = 0x20
	// Position of CH_SET38 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET38_Pos = 0x6
	// Bit mask of CH_SET38 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET38_Msk = 0x40
	// Bit CH_SET38.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET38 = 0x40
	// Position of CH_SET39 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET39_Pos = 0x7
	// Bit mask of CH_SET39 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET39_Msk = 0x80
	// Bit CH_SET39.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET39 = 0x80
	// Position of CH_SET40 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET40_Pos = 0x8
	// Bit mask of CH_SET40 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET40_Msk = 0x100
	// Bit CH_SET40.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET40 = 0x100
	// Position of CH_SET41 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET41_Pos = 0x9
	// Bit mask of CH_SET41 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET41_Msk = 0x200
	// Bit CH_SET41.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET41 = 0x200
	// Position of CH_SET42 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET42_Pos = 0xa
	// Bit mask of CH_SET42 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET42_Msk = 0x400
	// Bit CH_SET42.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET42 = 0x400
	// Position of CH_SET43 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET43_Pos = 0xb
	// Bit mask of CH_SET43 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET43_Msk = 0x800
	// Bit CH_SET43.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET43 = 0x800
	// Position of CH_SET44 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET44_Pos = 0xc
	// Bit mask of CH_SET44 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET44_Msk = 0x1000
	// Bit CH_SET44.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET44 = 0x1000
	// Position of CH_SET45 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET45_Pos = 0xd
	// Bit mask of CH_SET45 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET45_Msk = 0x2000
	// Bit CH_SET45.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET45 = 0x2000
	// Position of CH_SET46 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET46_Pos = 0xe
	// Bit mask of CH_SET46 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET46_Msk = 0x4000
	// Bit CH_SET46.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET46 = 0x4000
	// Position of CH_SET47 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET47_Pos = 0xf
	// Bit mask of CH_SET47 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET47_Msk = 0x8000
	// Bit CH_SET47.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET47 = 0x8000
	// Position of CH_SET48 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET48_Pos = 0x10
	// Bit mask of CH_SET48 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET48_Msk = 0x10000
	// Bit CH_SET48.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET48 = 0x10000
	// Position of CH_SET49 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET49_Pos = 0x11
	// Bit mask of CH_SET49 field.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET49_Msk = 0x20000
	// Bit CH_SET49.
	SOC_ETM_CH_ENA_AD1_SET_CH_SET49 = 0x20000

	// CH_ENA_AD1_CLR: channel enable clear register
	// Position of CH_CLR32 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR32_Pos = 0x0
	// Bit mask of CH_CLR32 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR32_Msk = 0x1
	// Bit CH_CLR32.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR32 = 0x1
	// Position of CH_CLR33 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR33_Pos = 0x1
	// Bit mask of CH_CLR33 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR33_Msk = 0x2
	// Bit CH_CLR33.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR33 = 0x2
	// Position of CH_CLR34 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR34_Pos = 0x2
	// Bit mask of CH_CLR34 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR34_Msk = 0x4
	// Bit CH_CLR34.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR34 = 0x4
	// Position of CH_CLR35 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR35_Pos = 0x3
	// Bit mask of CH_CLR35 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR35_Msk = 0x8
	// Bit CH_CLR35.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR35 = 0x8
	// Position of CH_CLR36 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR36_Pos = 0x4
	// Bit mask of CH_CLR36 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR36_Msk = 0x10
	// Bit CH_CLR36.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR36 = 0x10
	// Position of CH_CLR37 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR37_Pos = 0x5
	// Bit mask of CH_CLR37 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR37_Msk = 0x20
	// Bit CH_CLR37.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR37 = 0x20
	// Position of CH_CLR38 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR38_Pos = 0x6
	// Bit mask of CH_CLR38 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR38_Msk = 0x40
	// Bit CH_CLR38.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR38 = 0x40
	// Position of CH_CLR39 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR39_Pos = 0x7
	// Bit mask of CH_CLR39 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR39_Msk = 0x80
	// Bit CH_CLR39.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR39 = 0x80
	// Position of CH_CLR40 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR40_Pos = 0x8
	// Bit mask of CH_CLR40 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR40_Msk = 0x100
	// Bit CH_CLR40.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR40 = 0x100
	// Position of CH_CLR41 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR41_Pos = 0x9
	// Bit mask of CH_CLR41 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR41_Msk = 0x200
	// Bit CH_CLR41.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR41 = 0x200
	// Position of CH_CLR42 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR42_Pos = 0xa
	// Bit mask of CH_CLR42 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR42_Msk = 0x400
	// Bit CH_CLR42.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR42 = 0x400
	// Position of CH_CLR43 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR43_Pos = 0xb
	// Bit mask of CH_CLR43 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR43_Msk = 0x800
	// Bit CH_CLR43.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR43 = 0x800
	// Position of CH_CLR44 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR44_Pos = 0xc
	// Bit mask of CH_CLR44 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR44_Msk = 0x1000
	// Bit CH_CLR44.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR44 = 0x1000
	// Position of CH_CLR45 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR45_Pos = 0xd
	// Bit mask of CH_CLR45 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR45_Msk = 0x2000
	// Bit CH_CLR45.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR45 = 0x2000
	// Position of CH_CLR46 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR46_Pos = 0xe
	// Bit mask of CH_CLR46 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR46_Msk = 0x4000
	// Bit CH_CLR46.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR46 = 0x4000
	// Position of CH_CLR47 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR47_Pos = 0xf
	// Bit mask of CH_CLR47 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR47_Msk = 0x8000
	// Bit CH_CLR47.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR47 = 0x8000
	// Position of CH_CLR48 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR48_Pos = 0x10
	// Bit mask of CH_CLR48 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR48_Msk = 0x10000
	// Bit CH_CLR48.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR48 = 0x10000
	// Position of CH_CLR49 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR49_Pos = 0x11
	// Bit mask of CH_CLR49 field.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR49_Msk = 0x20000
	// Bit CH_CLR49.
	SOC_ETM_CH_ENA_AD1_CLR_CH_CLR49 = 0x20000

	// CH0_EVT_ID: channel0 event id register
	// Position of CH0_EVT_ID field.
	SOC_ETM_CH0_EVT_ID_CH0_EVT_ID_Pos = 0x0
	// Bit mask of CH0_EVT_ID field.
	SOC_ETM_CH0_EVT_ID_CH0_EVT_ID_Msk = 0xff

	// CH0_TASK_ID: channel0 task id register
	// Position of CH0_TASK_ID field.
	SOC_ETM_CH0_TASK_ID_CH0_TASK_ID_Pos = 0x0
	// Bit mask of CH0_TASK_ID field.
	SOC_ETM_CH0_TASK_ID_CH0_TASK_ID_Msk = 0xff

	// CH1_EVT_ID: channel1 event id register
	// Position of CH1_EVT_ID field.
	SOC_ETM_CH1_EVT_ID_CH1_EVT_ID_Pos = 0x0
	// Bit mask of CH1_EVT_ID field.
	SOC_ETM_CH1_EVT_ID_CH1_EVT_ID_Msk = 0xff

	// CH1_TASK_ID: channel1 task id register
	// Position of CH1_TASK_ID field.
	SOC_ETM_CH1_TASK_ID_CH1_TASK_ID_Pos = 0x0
	// Bit mask of CH1_TASK_ID field.
	SOC_ETM_CH1_TASK_ID_CH1_TASK_ID_Msk = 0xff

	// CH2_EVT_ID: channel2 event id register
	// Position of CH2_EVT_ID field.
	SOC_ETM_CH2_EVT_ID_CH2_EVT_ID_Pos = 0x0
	// Bit mask of CH2_EVT_ID field.
	SOC_ETM_CH2_EVT_ID_CH2_EVT_ID_Msk = 0xff

	// CH2_TASK_ID: channel2 task id register
	// Position of CH2_TASK_ID field.
	SOC_ETM_CH2_TASK_ID_CH2_TASK_ID_Pos = 0x0
	// Bit mask of CH2_TASK_ID field.
	SOC_ETM_CH2_TASK_ID_CH2_TASK_ID_Msk = 0xff

	// CH3_EVT_ID: channel3 event id register
	// Position of CH3_EVT_ID field.
	SOC_ETM_CH3_EVT_ID_CH3_EVT_ID_Pos = 0x0
	// Bit mask of CH3_EVT_ID field.
	SOC_ETM_CH3_EVT_ID_CH3_EVT_ID_Msk = 0xff

	// CH3_TASK_ID: channel3 task id register
	// Position of CH3_TASK_ID field.
	SOC_ETM_CH3_TASK_ID_CH3_TASK_ID_Pos = 0x0
	// Bit mask of CH3_TASK_ID field.
	SOC_ETM_CH3_TASK_ID_CH3_TASK_ID_Msk = 0xff

	// CH4_EVT_ID: channel4 event id register
	// Position of CH4_EVT_ID field.
	SOC_ETM_CH4_EVT_ID_CH4_EVT_ID_Pos = 0x0
	// Bit mask of CH4_EVT_ID field.
	SOC_ETM_CH4_EVT_ID_CH4_EVT_ID_Msk = 0xff

	// CH4_TASK_ID: channel4 task id register
	// Position of CH4_TASK_ID field.
	SOC_ETM_CH4_TASK_ID_CH4_TASK_ID_Pos = 0x0
	// Bit mask of CH4_TASK_ID field.
	SOC_ETM_CH4_TASK_ID_CH4_TASK_ID_Msk = 0xff

	// CH5_EVT_ID: channel5 event id register
	// Position of CH5_EVT_ID field.
	SOC_ETM_CH5_EVT_ID_CH5_EVT_ID_Pos = 0x0
	// Bit mask of CH5_EVT_ID field.
	SOC_ETM_CH5_EVT_ID_CH5_EVT_ID_Msk = 0xff

	// CH5_TASK_ID: channel5 task id register
	// Position of CH5_TASK_ID field.
	SOC_ETM_CH5_TASK_ID_CH5_TASK_ID_Pos = 0x0
	// Bit mask of CH5_TASK_ID field.
	SOC_ETM_CH5_TASK_ID_CH5_TASK_ID_Msk = 0xff

	// CH6_EVT_ID: channel6 event id register
	// Position of CH6_EVT_ID field.
	SOC_ETM_CH6_EVT_ID_CH6_EVT_ID_Pos = 0x0
	// Bit mask of CH6_EVT_ID field.
	SOC_ETM_CH6_EVT_ID_CH6_EVT_ID_Msk = 0xff

	// CH6_TASK_ID: channel6 task id register
	// Position of CH6_TASK_ID field.
	SOC_ETM_CH6_TASK_ID_CH6_TASK_ID_Pos = 0x0
	// Bit mask of CH6_TASK_ID field.
	SOC_ETM_CH6_TASK_ID_CH6_TASK_ID_Msk = 0xff

	// CH7_EVT_ID: channel7 event id register
	// Position of CH7_EVT_ID field.
	SOC_ETM_CH7_EVT_ID_CH7_EVT_ID_Pos = 0x0
	// Bit mask of CH7_EVT_ID field.
	SOC_ETM_CH7_EVT_ID_CH7_EVT_ID_Msk = 0xff

	// CH7_TASK_ID: channel7 task id register
	// Position of CH7_TASK_ID field.
	SOC_ETM_CH7_TASK_ID_CH7_TASK_ID_Pos = 0x0
	// Bit mask of CH7_TASK_ID field.
	SOC_ETM_CH7_TASK_ID_CH7_TASK_ID_Msk = 0xff

	// CH8_EVT_ID: channel8 event id register
	// Position of CH8_EVT_ID field.
	SOC_ETM_CH8_EVT_ID_CH8_EVT_ID_Pos = 0x0
	// Bit mask of CH8_EVT_ID field.
	SOC_ETM_CH8_EVT_ID_CH8_EVT_ID_Msk = 0xff

	// CH8_TASK_ID: channel8 task id register
	// Position of CH8_TASK_ID field.
	SOC_ETM_CH8_TASK_ID_CH8_TASK_ID_Pos = 0x0
	// Bit mask of CH8_TASK_ID field.
	SOC_ETM_CH8_TASK_ID_CH8_TASK_ID_Msk = 0xff

	// CH9_EVT_ID: channel9 event id register
	// Position of CH9_EVT_ID field.
	SOC_ETM_CH9_EVT_ID_CH9_EVT_ID_Pos = 0x0
	// Bit mask of CH9_EVT_ID field.
	SOC_ETM_CH9_EVT_ID_CH9_EVT_ID_Msk = 0xff

	// CH9_TASK_ID: channel9 task id register
	// Position of CH9_TASK_ID field.
	SOC_ETM_CH9_TASK_ID_CH9_TASK_ID_Pos = 0x0
	// Bit mask of CH9_TASK_ID field.
	SOC_ETM_CH9_TASK_ID_CH9_TASK_ID_Msk = 0xff

	// CH10_EVT_ID: channel10 event id register
	// Position of CH10_EVT_ID field.
	SOC_ETM_CH10_EVT_ID_CH10_EVT_ID_Pos = 0x0
	// Bit mask of CH10_EVT_ID field.
	SOC_ETM_CH10_EVT_ID_CH10_EVT_ID_Msk = 0xff

	// CH10_TASK_ID: channel10 task id register
	// Position of CH10_TASK_ID field.
	SOC_ETM_CH10_TASK_ID_CH10_TASK_ID_Pos = 0x0
	// Bit mask of CH10_TASK_ID field.
	SOC_ETM_CH10_TASK_ID_CH10_TASK_ID_Msk = 0xff

	// CH11_EVT_ID: channel11 event id register
	// Position of CH11_EVT_ID field.
	SOC_ETM_CH11_EVT_ID_CH11_EVT_ID_Pos = 0x0
	// Bit mask of CH11_EVT_ID field.
	SOC_ETM_CH11_EVT_ID_CH11_EVT_ID_Msk = 0xff

	// CH11_TASK_ID: channel11 task id register
	// Position of CH11_TASK_ID field.
	SOC_ETM_CH11_TASK_ID_CH11_TASK_ID_Pos = 0x0
	// Bit mask of CH11_TASK_ID field.
	SOC_ETM_CH11_TASK_ID_CH11_TASK_ID_Msk = 0xff

	// CH12_EVT_ID: channel12 event id register
	// Position of CH12_EVT_ID field.
	SOC_ETM_CH12_EVT_ID_CH12_EVT_ID_Pos = 0x0
	// Bit mask of CH12_EVT_ID field.
	SOC_ETM_CH12_EVT_ID_CH12_EVT_ID_Msk = 0xff

	// CH12_TASK_ID: channel12 task id register
	// Position of CH12_TASK_ID field.
	SOC_ETM_CH12_TASK_ID_CH12_TASK_ID_Pos = 0x0
	// Bit mask of CH12_TASK_ID field.
	SOC_ETM_CH12_TASK_ID_CH12_TASK_ID_Msk = 0xff

	// CH13_EVT_ID: channel13 event id register
	// Position of CH13_EVT_ID field.
	SOC_ETM_CH13_EVT_ID_CH13_EVT_ID_Pos = 0x0
	// Bit mask of CH13_EVT_ID field.
	SOC_ETM_CH13_EVT_ID_CH13_EVT_ID_Msk = 0xff

	// CH13_TASK_ID: channel13 task id register
	// Position of CH13_TASK_ID field.
	SOC_ETM_CH13_TASK_ID_CH13_TASK_ID_Pos = 0x0
	// Bit mask of CH13_TASK_ID field.
	SOC_ETM_CH13_TASK_ID_CH13_TASK_ID_Msk = 0xff

	// CH14_EVT_ID: channel14 event id register
	// Position of CH14_EVT_ID field.
	SOC_ETM_CH14_EVT_ID_CH14_EVT_ID_Pos = 0x0
	// Bit mask of CH14_EVT_ID field.
	SOC_ETM_CH14_EVT_ID_CH14_EVT_ID_Msk = 0xff

	// CH14_TASK_ID: channel14 task id register
	// Position of CH14_TASK_ID field.
	SOC_ETM_CH14_TASK_ID_CH14_TASK_ID_Pos = 0x0
	// Bit mask of CH14_TASK_ID field.
	SOC_ETM_CH14_TASK_ID_CH14_TASK_ID_Msk = 0xff

	// CH15_EVT_ID: channel15 event id register
	// Position of CH15_EVT_ID field.
	SOC_ETM_CH15_EVT_ID_CH15_EVT_ID_Pos = 0x0
	// Bit mask of CH15_EVT_ID field.
	SOC_ETM_CH15_EVT_ID_CH15_EVT_ID_Msk = 0xff

	// CH15_TASK_ID: channel15 task id register
	// Position of CH15_TASK_ID field.
	SOC_ETM_CH15_TASK_ID_CH15_TASK_ID_Pos = 0x0
	// Bit mask of CH15_TASK_ID field.
	SOC_ETM_CH15_TASK_ID_CH15_TASK_ID_Msk = 0xff

	// CH16_EVT_ID: channel16 event id register
	// Position of CH16_EVT_ID field.
	SOC_ETM_CH16_EVT_ID_CH16_EVT_ID_Pos = 0x0
	// Bit mask of CH16_EVT_ID field.
	SOC_ETM_CH16_EVT_ID_CH16_EVT_ID_Msk = 0xff

	// CH16_TASK_ID: channel16 task id register
	// Position of CH16_TASK_ID field.
	SOC_ETM_CH16_TASK_ID_CH16_TASK_ID_Pos = 0x0
	// Bit mask of CH16_TASK_ID field.
	SOC_ETM_CH16_TASK_ID_CH16_TASK_ID_Msk = 0xff

	// CH17_EVT_ID: channel17 event id register
	// Position of CH17_EVT_ID field.
	SOC_ETM_CH17_EVT_ID_CH17_EVT_ID_Pos = 0x0
	// Bit mask of CH17_EVT_ID field.
	SOC_ETM_CH17_EVT_ID_CH17_EVT_ID_Msk = 0xff

	// CH17_TASK_ID: channel17 task id register
	// Position of CH17_TASK_ID field.
	SOC_ETM_CH17_TASK_ID_CH17_TASK_ID_Pos = 0x0
	// Bit mask of CH17_TASK_ID field.
	SOC_ETM_CH17_TASK_ID_CH17_TASK_ID_Msk = 0xff

	// CH18_EVT_ID: channel18 event id register
	// Position of CH18_EVT_ID field.
	SOC_ETM_CH18_EVT_ID_CH18_EVT_ID_Pos = 0x0
	// Bit mask of CH18_EVT_ID field.
	SOC_ETM_CH18_EVT_ID_CH18_EVT_ID_Msk = 0xff

	// CH18_TASK_ID: channel18 task id register
	// Position of CH18_TASK_ID field.
	SOC_ETM_CH18_TASK_ID_CH18_TASK_ID_Pos = 0x0
	// Bit mask of CH18_TASK_ID field.
	SOC_ETM_CH18_TASK_ID_CH18_TASK_ID_Msk = 0xff

	// CH19_EVT_ID: channel19 event id register
	// Position of CH19_EVT_ID field.
	SOC_ETM_CH19_EVT_ID_CH19_EVT_ID_Pos = 0x0
	// Bit mask of CH19_EVT_ID field.
	SOC_ETM_CH19_EVT_ID_CH19_EVT_ID_Msk = 0xff

	// CH19_TASK_ID: channel19 task id register
	// Position of CH19_TASK_ID field.
	SOC_ETM_CH19_TASK_ID_CH19_TASK_ID_Pos = 0x0
	// Bit mask of CH19_TASK_ID field.
	SOC_ETM_CH19_TASK_ID_CH19_TASK_ID_Msk = 0xff

	// CH20_EVT_ID: channel20 event id register
	// Position of CH20_EVT_ID field.
	SOC_ETM_CH20_EVT_ID_CH20_EVT_ID_Pos = 0x0
	// Bit mask of CH20_EVT_ID field.
	SOC_ETM_CH20_EVT_ID_CH20_EVT_ID_Msk = 0xff

	// CH20_TASK_ID: channel20 task id register
	// Position of CH20_TASK_ID field.
	SOC_ETM_CH20_TASK_ID_CH20_TASK_ID_Pos = 0x0
	// Bit mask of CH20_TASK_ID field.
	SOC_ETM_CH20_TASK_ID_CH20_TASK_ID_Msk = 0xff

	// CH21_EVT_ID: channel21 event id register
	// Position of CH21_EVT_ID field.
	SOC_ETM_CH21_EVT_ID_CH21_EVT_ID_Pos = 0x0
	// Bit mask of CH21_EVT_ID field.
	SOC_ETM_CH21_EVT_ID_CH21_EVT_ID_Msk = 0xff

	// CH21_TASK_ID: channel21 task id register
	// Position of CH21_TASK_ID field.
	SOC_ETM_CH21_TASK_ID_CH21_TASK_ID_Pos = 0x0
	// Bit mask of CH21_TASK_ID field.
	SOC_ETM_CH21_TASK_ID_CH21_TASK_ID_Msk = 0xff

	// CH22_EVT_ID: channel22 event id register
	// Position of CH22_EVT_ID field.
	SOC_ETM_CH22_EVT_ID_CH22_EVT_ID_Pos = 0x0
	// Bit mask of CH22_EVT_ID field.
	SOC_ETM_CH22_EVT_ID_CH22_EVT_ID_Msk = 0xff

	// CH22_TASK_ID: channel22 task id register
	// Position of CH22_TASK_ID field.
	SOC_ETM_CH22_TASK_ID_CH22_TASK_ID_Pos = 0x0
	// Bit mask of CH22_TASK_ID field.
	SOC_ETM_CH22_TASK_ID_CH22_TASK_ID_Msk = 0xff

	// CH23_EVT_ID: channel23 event id register
	// Position of CH23_EVT_ID field.
	SOC_ETM_CH23_EVT_ID_CH23_EVT_ID_Pos = 0x0
	// Bit mask of CH23_EVT_ID field.
	SOC_ETM_CH23_EVT_ID_CH23_EVT_ID_Msk = 0xff

	// CH23_TASK_ID: channel23 task id register
	// Position of CH23_TASK_ID field.
	SOC_ETM_CH23_TASK_ID_CH23_TASK_ID_Pos = 0x0
	// Bit mask of CH23_TASK_ID field.
	SOC_ETM_CH23_TASK_ID_CH23_TASK_ID_Msk = 0xff

	// CH24_EVT_ID: channel24 event id register
	// Position of CH24_EVT_ID field.
	SOC_ETM_CH24_EVT_ID_CH24_EVT_ID_Pos = 0x0
	// Bit mask of CH24_EVT_ID field.
	SOC_ETM_CH24_EVT_ID_CH24_EVT_ID_Msk = 0xff

	// CH24_TASK_ID: channel24 task id register
	// Position of CH24_TASK_ID field.
	SOC_ETM_CH24_TASK_ID_CH24_TASK_ID_Pos = 0x0
	// Bit mask of CH24_TASK_ID field.
	SOC_ETM_CH24_TASK_ID_CH24_TASK_ID_Msk = 0xff

	// CH25_EVT_ID: channel25 event id register
	// Position of CH25_EVT_ID field.
	SOC_ETM_CH25_EVT_ID_CH25_EVT_ID_Pos = 0x0
	// Bit mask of CH25_EVT_ID field.
	SOC_ETM_CH25_EVT_ID_CH25_EVT_ID_Msk = 0xff

	// CH25_TASK_ID: channel25 task id register
	// Position of CH25_TASK_ID field.
	SOC_ETM_CH25_TASK_ID_CH25_TASK_ID_Pos = 0x0
	// Bit mask of CH25_TASK_ID field.
	SOC_ETM_CH25_TASK_ID_CH25_TASK_ID_Msk = 0xff

	// CH26_EVT_ID: channel26 event id register
	// Position of CH26_EVT_ID field.
	SOC_ETM_CH26_EVT_ID_CH26_EVT_ID_Pos = 0x0
	// Bit mask of CH26_EVT_ID field.
	SOC_ETM_CH26_EVT_ID_CH26_EVT_ID_Msk = 0xff

	// CH26_TASK_ID: channel26 task id register
	// Position of CH26_TASK_ID field.
	SOC_ETM_CH26_TASK_ID_CH26_TASK_ID_Pos = 0x0
	// Bit mask of CH26_TASK_ID field.
	SOC_ETM_CH26_TASK_ID_CH26_TASK_ID_Msk = 0xff

	// CH27_EVT_ID: channel27 event id register
	// Position of CH27_EVT_ID field.
	SOC_ETM_CH27_EVT_ID_CH27_EVT_ID_Pos = 0x0
	// Bit mask of CH27_EVT_ID field.
	SOC_ETM_CH27_EVT_ID_CH27_EVT_ID_Msk = 0xff

	// CH27_TASK_ID: channel27 task id register
	// Position of CH27_TASK_ID field.
	SOC_ETM_CH27_TASK_ID_CH27_TASK_ID_Pos = 0x0
	// Bit mask of CH27_TASK_ID field.
	SOC_ETM_CH27_TASK_ID_CH27_TASK_ID_Msk = 0xff

	// CH28_EVT_ID: channel28 event id register
	// Position of CH28_EVT_ID field.
	SOC_ETM_CH28_EVT_ID_CH28_EVT_ID_Pos = 0x0
	// Bit mask of CH28_EVT_ID field.
	SOC_ETM_CH28_EVT_ID_CH28_EVT_ID_Msk = 0xff

	// CH28_TASK_ID: channel28 task id register
	// Position of CH28_TASK_ID field.
	SOC_ETM_CH28_TASK_ID_CH28_TASK_ID_Pos = 0x0
	// Bit mask of CH28_TASK_ID field.
	SOC_ETM_CH28_TASK_ID_CH28_TASK_ID_Msk = 0xff

	// CH29_EVT_ID: channel29 event id register
	// Position of CH29_EVT_ID field.
	SOC_ETM_CH29_EVT_ID_CH29_EVT_ID_Pos = 0x0
	// Bit mask of CH29_EVT_ID field.
	SOC_ETM_CH29_EVT_ID_CH29_EVT_ID_Msk = 0xff

	// CH29_TASK_ID: channel29 task id register
	// Position of CH29_TASK_ID field.
	SOC_ETM_CH29_TASK_ID_CH29_TASK_ID_Pos = 0x0
	// Bit mask of CH29_TASK_ID field.
	SOC_ETM_CH29_TASK_ID_CH29_TASK_ID_Msk = 0xff

	// CH30_EVT_ID: channel30 event id register
	// Position of CH30_EVT_ID field.
	SOC_ETM_CH30_EVT_ID_CH30_EVT_ID_Pos = 0x0
	// Bit mask of CH30_EVT_ID field.
	SOC_ETM_CH30_EVT_ID_CH30_EVT_ID_Msk = 0xff

	// CH30_TASK_ID: channel30 task id register
	// Position of CH30_TASK_ID field.
	SOC_ETM_CH30_TASK_ID_CH30_TASK_ID_Pos = 0x0
	// Bit mask of CH30_TASK_ID field.
	SOC_ETM_CH30_TASK_ID_CH30_TASK_ID_Msk = 0xff

	// CH31_EVT_ID: channel31 event id register
	// Position of CH31_EVT_ID field.
	SOC_ETM_CH31_EVT_ID_CH31_EVT_ID_Pos = 0x0
	// Bit mask of CH31_EVT_ID field.
	SOC_ETM_CH31_EVT_ID_CH31_EVT_ID_Msk = 0xff

	// CH31_TASK_ID: channel31 task id register
	// Position of CH31_TASK_ID field.
	SOC_ETM_CH31_TASK_ID_CH31_TASK_ID_Pos = 0x0
	// Bit mask of CH31_TASK_ID field.
	SOC_ETM_CH31_TASK_ID_CH31_TASK_ID_Msk = 0xff

	// CH32_EVT_ID: channel32 event id register
	// Position of CH32_EVT_ID field.
	SOC_ETM_CH32_EVT_ID_CH32_EVT_ID_Pos = 0x0
	// Bit mask of CH32_EVT_ID field.
	SOC_ETM_CH32_EVT_ID_CH32_EVT_ID_Msk = 0xff

	// CH32_TASK_ID: channel32 task id register
	// Position of CH32_TASK_ID field.
	SOC_ETM_CH32_TASK_ID_CH32_TASK_ID_Pos = 0x0
	// Bit mask of CH32_TASK_ID field.
	SOC_ETM_CH32_TASK_ID_CH32_TASK_ID_Msk = 0xff

	// CH33_EVT_ID: channel33 event id register
	// Position of CH33_EVT_ID field.
	SOC_ETM_CH33_EVT_ID_CH33_EVT_ID_Pos = 0x0
	// Bit mask of CH33_EVT_ID field.
	SOC_ETM_CH33_EVT_ID_CH33_EVT_ID_Msk = 0xff

	// CH33_TASK_ID: channel33 task id register
	// Position of CH33_TASK_ID field.
	SOC_ETM_CH33_TASK_ID_CH33_TASK_ID_Pos = 0x0
	// Bit mask of CH33_TASK_ID field.
	SOC_ETM_CH33_TASK_ID_CH33_TASK_ID_Msk = 0xff

	// CH34_EVT_ID: channel34 event id register
	// Position of CH34_EVT_ID field.
	SOC_ETM_CH34_EVT_ID_CH34_EVT_ID_Pos = 0x0
	// Bit mask of CH34_EVT_ID field.
	SOC_ETM_CH34_EVT_ID_CH34_EVT_ID_Msk = 0xff

	// CH34_TASK_ID: channel34 task id register
	// Position of CH34_TASK_ID field.
	SOC_ETM_CH34_TASK_ID_CH34_TASK_ID_Pos = 0x0
	// Bit mask of CH34_TASK_ID field.
	SOC_ETM_CH34_TASK_ID_CH34_TASK_ID_Msk = 0xff

	// CH35_EVT_ID: channel35 event id register
	// Position of CH35_EVT_ID field.
	SOC_ETM_CH35_EVT_ID_CH35_EVT_ID_Pos = 0x0
	// Bit mask of CH35_EVT_ID field.
	SOC_ETM_CH35_EVT_ID_CH35_EVT_ID_Msk = 0xff

	// CH35_TASK_ID: channel35 task id register
	// Position of CH35_TASK_ID field.
	SOC_ETM_CH35_TASK_ID_CH35_TASK_ID_Pos = 0x0
	// Bit mask of CH35_TASK_ID field.
	SOC_ETM_CH35_TASK_ID_CH35_TASK_ID_Msk = 0xff

	// CH36_EVT_ID: channel36 event id register
	// Position of CH36_EVT_ID field.
	SOC_ETM_CH36_EVT_ID_CH36_EVT_ID_Pos = 0x0
	// Bit mask of CH36_EVT_ID field.
	SOC_ETM_CH36_EVT_ID_CH36_EVT_ID_Msk = 0xff

	// CH36_TASK_ID: channel36 task id register
	// Position of CH36_TASK_ID field.
	SOC_ETM_CH36_TASK_ID_CH36_TASK_ID_Pos = 0x0
	// Bit mask of CH36_TASK_ID field.
	SOC_ETM_CH36_TASK_ID_CH36_TASK_ID_Msk = 0xff

	// CH37_EVT_ID: channel37 event id register
	// Position of CH37_EVT_ID field.
	SOC_ETM_CH37_EVT_ID_CH37_EVT_ID_Pos = 0x0
	// Bit mask of CH37_EVT_ID field.
	SOC_ETM_CH37_EVT_ID_CH37_EVT_ID_Msk = 0xff

	// CH37_TASK_ID: channel37 task id register
	// Position of CH37_TASK_ID field.
	SOC_ETM_CH37_TASK_ID_CH37_TASK_ID_Pos = 0x0
	// Bit mask of CH37_TASK_ID field.
	SOC_ETM_CH37_TASK_ID_CH37_TASK_ID_Msk = 0xff

	// CH38_EVT_ID: channel38 event id register
	// Position of CH38_EVT_ID field.
	SOC_ETM_CH38_EVT_ID_CH38_EVT_ID_Pos = 0x0
	// Bit mask of CH38_EVT_ID field.
	SOC_ETM_CH38_EVT_ID_CH38_EVT_ID_Msk = 0xff

	// CH38_TASK_ID: channel38 task id register
	// Position of CH38_TASK_ID field.
	SOC_ETM_CH38_TASK_ID_CH38_TASK_ID_Pos = 0x0
	// Bit mask of CH38_TASK_ID field.
	SOC_ETM_CH38_TASK_ID_CH38_TASK_ID_Msk = 0xff

	// CH39_EVT_ID: channel39 event id register
	// Position of CH39_EVT_ID field.
	SOC_ETM_CH39_EVT_ID_CH39_EVT_ID_Pos = 0x0
	// Bit mask of CH39_EVT_ID field.
	SOC_ETM_CH39_EVT_ID_CH39_EVT_ID_Msk = 0xff

	// CH39_TASK_ID: channel39 task id register
	// Position of CH39_TASK_ID field.
	SOC_ETM_CH39_TASK_ID_CH39_TASK_ID_Pos = 0x0
	// Bit mask of CH39_TASK_ID field.
	SOC_ETM_CH39_TASK_ID_CH39_TASK_ID_Msk = 0xff

	// CH40_EVT_ID: channel40 event id register
	// Position of CH40_EVT_ID field.
	SOC_ETM_CH40_EVT_ID_CH40_EVT_ID_Pos = 0x0
	// Bit mask of CH40_EVT_ID field.
	SOC_ETM_CH40_EVT_ID_CH40_EVT_ID_Msk = 0xff

	// CH40_TASK_ID: channel40 task id register
	// Position of CH40_TASK_ID field.
	SOC_ETM_CH40_TASK_ID_CH40_TASK_ID_Pos = 0x0
	// Bit mask of CH40_TASK_ID field.
	SOC_ETM_CH40_TASK_ID_CH40_TASK_ID_Msk = 0xff

	// CH41_EVT_ID: channel41 event id register
	// Position of CH41_EVT_ID field.
	SOC_ETM_CH41_EVT_ID_CH41_EVT_ID_Pos = 0x0
	// Bit mask of CH41_EVT_ID field.
	SOC_ETM_CH41_EVT_ID_CH41_EVT_ID_Msk = 0xff

	// CH41_TASK_ID: channel41 task id register
	// Position of CH41_TASK_ID field.
	SOC_ETM_CH41_TASK_ID_CH41_TASK_ID_Pos = 0x0
	// Bit mask of CH41_TASK_ID field.
	SOC_ETM_CH41_TASK_ID_CH41_TASK_ID_Msk = 0xff

	// CH42_EVT_ID: channel42 event id register
	// Position of CH42_EVT_ID field.
	SOC_ETM_CH42_EVT_ID_CH42_EVT_ID_Pos = 0x0
	// Bit mask of CH42_EVT_ID field.
	SOC_ETM_CH42_EVT_ID_CH42_EVT_ID_Msk = 0xff

	// CH42_TASK_ID: channel42 task id register
	// Position of CH42_TASK_ID field.
	SOC_ETM_CH42_TASK_ID_CH42_TASK_ID_Pos = 0x0
	// Bit mask of CH42_TASK_ID field.
	SOC_ETM_CH42_TASK_ID_CH42_TASK_ID_Msk = 0xff

	// CH43_EVT_ID: channel43 event id register
	// Position of CH43_EVT_ID field.
	SOC_ETM_CH43_EVT_ID_CH43_EVT_ID_Pos = 0x0
	// Bit mask of CH43_EVT_ID field.
	SOC_ETM_CH43_EVT_ID_CH43_EVT_ID_Msk = 0xff

	// CH43_TASK_ID: channel43 task id register
	// Position of CH43_TASK_ID field.
	SOC_ETM_CH43_TASK_ID_CH43_TASK_ID_Pos = 0x0
	// Bit mask of CH43_TASK_ID field.
	SOC_ETM_CH43_TASK_ID_CH43_TASK_ID_Msk = 0xff

	// CH44_EVT_ID: channel44 event id register
	// Position of CH44_EVT_ID field.
	SOC_ETM_CH44_EVT_ID_CH44_EVT_ID_Pos = 0x0
	// Bit mask of CH44_EVT_ID field.
	SOC_ETM_CH44_EVT_ID_CH44_EVT_ID_Msk = 0xff

	// CH44_TASK_ID: channel44 task id register
	// Position of CH44_TASK_ID field.
	SOC_ETM_CH44_TASK_ID_CH44_TASK_ID_Pos = 0x0
	// Bit mask of CH44_TASK_ID field.
	SOC_ETM_CH44_TASK_ID_CH44_TASK_ID_Msk = 0xff

	// CH45_EVT_ID: channel45 event id register
	// Position of CH45_EVT_ID field.
	SOC_ETM_CH45_EVT_ID_CH45_EVT_ID_Pos = 0x0
	// Bit mask of CH45_EVT_ID field.
	SOC_ETM_CH45_EVT_ID_CH45_EVT_ID_Msk = 0xff

	// CH45_TASK_ID: channel45 task id register
	// Position of CH45_TASK_ID field.
	SOC_ETM_CH45_TASK_ID_CH45_TASK_ID_Pos = 0x0
	// Bit mask of CH45_TASK_ID field.
	SOC_ETM_CH45_TASK_ID_CH45_TASK_ID_Msk = 0xff

	// CH46_EVT_ID: channel46 event id register
	// Position of CH46_EVT_ID field.
	SOC_ETM_CH46_EVT_ID_CH46_EVT_ID_Pos = 0x0
	// Bit mask of CH46_EVT_ID field.
	SOC_ETM_CH46_EVT_ID_CH46_EVT_ID_Msk = 0xff

	// CH46_TASK_ID: channel46 task id register
	// Position of CH46_TASK_ID field.
	SOC_ETM_CH46_TASK_ID_CH46_TASK_ID_Pos = 0x0
	// Bit mask of CH46_TASK_ID field.
	SOC_ETM_CH46_TASK_ID_CH46_TASK_ID_Msk = 0xff

	// CH47_EVT_ID: channel47 event id register
	// Position of CH47_EVT_ID field.
	SOC_ETM_CH47_EVT_ID_CH47_EVT_ID_Pos = 0x0
	// Bit mask of CH47_EVT_ID field.
	SOC_ETM_CH47_EVT_ID_CH47_EVT_ID_Msk = 0xff

	// CH47_TASK_ID: channel47 task id register
	// Position of CH47_TASK_ID field.
	SOC_ETM_CH47_TASK_ID_CH47_TASK_ID_Pos = 0x0
	// Bit mask of CH47_TASK_ID field.
	SOC_ETM_CH47_TASK_ID_CH47_TASK_ID_Msk = 0xff

	// CH48_EVT_ID: channel48 event id register
	// Position of CH48_EVT_ID field.
	SOC_ETM_CH48_EVT_ID_CH48_EVT_ID_Pos = 0x0
	// Bit mask of CH48_EVT_ID field.
	SOC_ETM_CH48_EVT_ID_CH48_EVT_ID_Msk = 0xff

	// CH48_TASK_ID: channel48 task id register
	// Position of CH48_TASK_ID field.
	SOC_ETM_CH48_TASK_ID_CH48_TASK_ID_Pos = 0x0
	// Bit mask of CH48_TASK_ID field.
	SOC_ETM_CH48_TASK_ID_CH48_TASK_ID_Msk = 0xff

	// CH49_EVT_ID: channel49 event id register
	// Position of CH49_EVT_ID field.
	SOC_ETM_CH49_EVT_ID_CH49_EVT_ID_Pos = 0x0
	// Bit mask of CH49_EVT_ID field.
	SOC_ETM_CH49_EVT_ID_CH49_EVT_ID_Msk = 0xff

	// CH49_TASK_ID: channel49 task id register
	// Position of CH49_TASK_ID field.
	SOC_ETM_CH49_TASK_ID_CH49_TASK_ID_Pos = 0x0
	// Bit mask of CH49_TASK_ID field.
	SOC_ETM_CH49_TASK_ID_CH49_TASK_ID_Msk = 0xff

	// CLK_EN: etm clock enable register
	// Position of CLK_EN field.
	SOC_ETM_CLK_EN_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	SOC_ETM_CLK_EN_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	SOC_ETM_CLK_EN_CLK_EN = 0x1

	// DATE: etm date register
	// Position of DATE field.
	SOC_ETM_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	SOC_ETM_DATE_DATE_Msk = 0xfffffff
)

// Constants for SPI0: SPI (Serial Peripheral Interface) Controller 0
const (
	// SPI_MEM_CMD: SPI0 FSM status register
	// Position of SPI_MEM_MST_ST field.
	SPI0_SPI_MEM_CMD_SPI_MEM_MST_ST_Pos = 0x0
	// Bit mask of SPI_MEM_MST_ST field.
	SPI0_SPI_MEM_CMD_SPI_MEM_MST_ST_Msk = 0xf
	// Position of SPI_MEM_SLV_ST field.
	SPI0_SPI_MEM_CMD_SPI_MEM_SLV_ST_Pos = 0x4
	// Bit mask of SPI_MEM_SLV_ST field.
	SPI0_SPI_MEM_CMD_SPI_MEM_SLV_ST_Msk = 0xf0
	// Position of SPI_MEM_USR field.
	SPI0_SPI_MEM_CMD_SPI_MEM_USR_Pos = 0x12
	// Bit mask of SPI_MEM_USR field.
	SPI0_SPI_MEM_CMD_SPI_MEM_USR_Msk = 0x40000
	// Bit SPI_MEM_USR.
	SPI0_SPI_MEM_CMD_SPI_MEM_USR = 0x40000

	// SPI_MEM_CTRL: SPI0 control register.
	// Position of SPI_MEM_WDUMMY_DQS_ALWAYS_OUT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_WDUMMY_DQS_ALWAYS_OUT_Pos = 0x0
	// Bit mask of SPI_MEM_WDUMMY_DQS_ALWAYS_OUT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_WDUMMY_DQS_ALWAYS_OUT_Msk = 0x1
	// Bit SPI_MEM_WDUMMY_DQS_ALWAYS_OUT.
	SPI0_SPI_MEM_CTRL_SPI_MEM_WDUMMY_DQS_ALWAYS_OUT = 0x1
	// Position of SPI_MEM_WDUMMY_ALWAYS_OUT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_WDUMMY_ALWAYS_OUT_Pos = 0x1
	// Bit mask of SPI_MEM_WDUMMY_ALWAYS_OUT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_WDUMMY_ALWAYS_OUT_Msk = 0x2
	// Bit SPI_MEM_WDUMMY_ALWAYS_OUT.
	SPI0_SPI_MEM_CTRL_SPI_MEM_WDUMMY_ALWAYS_OUT = 0x2
	// Position of SPI_MEM_FDUMMY_RIN field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FDUMMY_RIN_Pos = 0x2
	// Bit mask of SPI_MEM_FDUMMY_RIN field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FDUMMY_RIN_Msk = 0x4
	// Bit SPI_MEM_FDUMMY_RIN.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FDUMMY_RIN = 0x4
	// Position of SPI_MEM_FDUMMY_WOUT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FDUMMY_WOUT_Pos = 0x3
	// Bit mask of SPI_MEM_FDUMMY_WOUT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FDUMMY_WOUT_Msk = 0x8
	// Bit SPI_MEM_FDUMMY_WOUT.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FDUMMY_WOUT = 0x8
	// Position of SPI_MEM_FDOUT_OCT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FDOUT_OCT_Pos = 0x4
	// Bit mask of SPI_MEM_FDOUT_OCT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FDOUT_OCT_Msk = 0x10
	// Bit SPI_MEM_FDOUT_OCT.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FDOUT_OCT = 0x10
	// Position of SPI_MEM_FDIN_OCT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FDIN_OCT_Pos = 0x5
	// Bit mask of SPI_MEM_FDIN_OCT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FDIN_OCT_Msk = 0x20
	// Bit SPI_MEM_FDIN_OCT.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FDIN_OCT = 0x20
	// Position of SPI_MEM_FADDR_OCT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FADDR_OCT_Pos = 0x6
	// Bit mask of SPI_MEM_FADDR_OCT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FADDR_OCT_Msk = 0x40
	// Bit SPI_MEM_FADDR_OCT.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FADDR_OCT = 0x40
	// Position of SPI_MEM_FCMD_QUAD field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FCMD_QUAD_Pos = 0x8
	// Bit mask of SPI_MEM_FCMD_QUAD field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FCMD_QUAD_Msk = 0x100
	// Bit SPI_MEM_FCMD_QUAD.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FCMD_QUAD = 0x100
	// Position of SPI_MEM_FCMD_OCT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FCMD_OCT_Pos = 0x9
	// Bit mask of SPI_MEM_FCMD_OCT field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FCMD_OCT_Msk = 0x200
	// Bit SPI_MEM_FCMD_OCT.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FCMD_OCT = 0x200
	// Position of SPI_MEM_FASTRD_MODE field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FASTRD_MODE_Pos = 0xd
	// Bit mask of SPI_MEM_FASTRD_MODE field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FASTRD_MODE_Msk = 0x2000
	// Bit SPI_MEM_FASTRD_MODE.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FASTRD_MODE = 0x2000
	// Position of SPI_MEM_FREAD_DUAL field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FREAD_DUAL_Pos = 0xe
	// Bit mask of SPI_MEM_FREAD_DUAL field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FREAD_DUAL_Msk = 0x4000
	// Bit SPI_MEM_FREAD_DUAL.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FREAD_DUAL = 0x4000
	// Position of SPI_MEM_Q_POL field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_Q_POL_Pos = 0x12
	// Bit mask of SPI_MEM_Q_POL field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_Q_POL_Msk = 0x40000
	// Bit SPI_MEM_Q_POL.
	SPI0_SPI_MEM_CTRL_SPI_MEM_Q_POL = 0x40000
	// Position of SPI_MEM_D_POL field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_D_POL_Pos = 0x13
	// Bit mask of SPI_MEM_D_POL field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_D_POL_Msk = 0x80000
	// Bit SPI_MEM_D_POL.
	SPI0_SPI_MEM_CTRL_SPI_MEM_D_POL = 0x80000
	// Position of SPI_MEM_FREAD_QUAD field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FREAD_QUAD_Pos = 0x14
	// Bit mask of SPI_MEM_FREAD_QUAD field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FREAD_QUAD_Msk = 0x100000
	// Bit SPI_MEM_FREAD_QUAD.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FREAD_QUAD = 0x100000
	// Position of SPI_MEM_WP field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_WP_Pos = 0x15
	// Bit mask of SPI_MEM_WP field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_WP_Msk = 0x200000
	// Bit SPI_MEM_WP.
	SPI0_SPI_MEM_CTRL_SPI_MEM_WP = 0x200000
	// Position of SPI_MEM_FREAD_DIO field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FREAD_DIO_Pos = 0x17
	// Bit mask of SPI_MEM_FREAD_DIO field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FREAD_DIO_Msk = 0x800000
	// Bit SPI_MEM_FREAD_DIO.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FREAD_DIO = 0x800000
	// Position of SPI_MEM_FREAD_QIO field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FREAD_QIO_Pos = 0x18
	// Bit mask of SPI_MEM_FREAD_QIO field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FREAD_QIO_Msk = 0x1000000
	// Bit SPI_MEM_FREAD_QIO.
	SPI0_SPI_MEM_CTRL_SPI_MEM_FREAD_QIO = 0x1000000
	// Position of SPI_MEM_DQS_IE_ALWAYS_ON field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_DQS_IE_ALWAYS_ON_Pos = 0x1e
	// Bit mask of SPI_MEM_DQS_IE_ALWAYS_ON field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_DQS_IE_ALWAYS_ON_Msk = 0x40000000
	// Bit SPI_MEM_DQS_IE_ALWAYS_ON.
	SPI0_SPI_MEM_CTRL_SPI_MEM_DQS_IE_ALWAYS_ON = 0x40000000
	// Position of SPI_MEM_DATA_IE_ALWAYS_ON field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_DATA_IE_ALWAYS_ON_Pos = 0x1f
	// Bit mask of SPI_MEM_DATA_IE_ALWAYS_ON field.
	SPI0_SPI_MEM_CTRL_SPI_MEM_DATA_IE_ALWAYS_ON_Msk = 0x80000000
	// Bit SPI_MEM_DATA_IE_ALWAYS_ON.
	SPI0_SPI_MEM_CTRL_SPI_MEM_DATA_IE_ALWAYS_ON = 0x80000000

	// SPI_MEM_CTRL1: SPI0 control1 register.
	// Position of SPI_MEM_CLK_MODE field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_CLK_MODE_Pos = 0x0
	// Bit mask of SPI_MEM_CLK_MODE field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_CLK_MODE_Msk = 0x3
	// Position of SPI_AR_SIZE0_1_SUPPORT_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_AR_SIZE0_1_SUPPORT_EN_Pos = 0x15
	// Bit mask of SPI_AR_SIZE0_1_SUPPORT_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_AR_SIZE0_1_SUPPORT_EN_Msk = 0x200000
	// Bit SPI_AR_SIZE0_1_SUPPORT_EN.
	SPI0_SPI_MEM_CTRL1_SPI_AR_SIZE0_1_SUPPORT_EN = 0x200000
	// Position of SPI_AW_SIZE0_1_SUPPORT_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_AW_SIZE0_1_SUPPORT_EN_Pos = 0x16
	// Bit mask of SPI_AW_SIZE0_1_SUPPORT_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_AW_SIZE0_1_SUPPORT_EN_Msk = 0x400000
	// Bit SPI_AW_SIZE0_1_SUPPORT_EN.
	SPI0_SPI_MEM_CTRL1_SPI_AW_SIZE0_1_SUPPORT_EN = 0x400000
	// Position of SPI_AXI_RDATA_BACK_FAST field.
	SPI0_SPI_MEM_CTRL1_SPI_AXI_RDATA_BACK_FAST_Pos = 0x17
	// Bit mask of SPI_AXI_RDATA_BACK_FAST field.
	SPI0_SPI_MEM_CTRL1_SPI_AXI_RDATA_BACK_FAST_Msk = 0x800000
	// Bit SPI_AXI_RDATA_BACK_FAST.
	SPI0_SPI_MEM_CTRL1_SPI_AXI_RDATA_BACK_FAST = 0x800000
	// Position of SPI_MEM_RRESP_ECC_ERR_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_RRESP_ECC_ERR_EN_Pos = 0x18
	// Bit mask of SPI_MEM_RRESP_ECC_ERR_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_RRESP_ECC_ERR_EN_Msk = 0x1000000
	// Bit SPI_MEM_RRESP_ECC_ERR_EN.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_RRESP_ECC_ERR_EN = 0x1000000
	// Position of SPI_MEM_AR_SPLICE_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_AR_SPLICE_EN_Pos = 0x19
	// Bit mask of SPI_MEM_AR_SPLICE_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_AR_SPLICE_EN_Msk = 0x2000000
	// Bit SPI_MEM_AR_SPLICE_EN.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_AR_SPLICE_EN = 0x2000000
	// Position of SPI_MEM_AW_SPLICE_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_AW_SPLICE_EN_Pos = 0x1a
	// Bit mask of SPI_MEM_AW_SPLICE_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_AW_SPLICE_EN_Msk = 0x4000000
	// Bit SPI_MEM_AW_SPLICE_EN.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_AW_SPLICE_EN = 0x4000000
	// Position of SPI_MEM_RAM0_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_RAM0_EN_Pos = 0x1b
	// Bit mask of SPI_MEM_RAM0_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_RAM0_EN_Msk = 0x8000000
	// Bit SPI_MEM_RAM0_EN.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_RAM0_EN = 0x8000000
	// Position of SPI_MEM_DUAL_RAM_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_DUAL_RAM_EN_Pos = 0x1c
	// Bit mask of SPI_MEM_DUAL_RAM_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_DUAL_RAM_EN_Msk = 0x10000000
	// Bit SPI_MEM_DUAL_RAM_EN.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_DUAL_RAM_EN = 0x10000000
	// Position of SPI_MEM_FAST_WRITE_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_FAST_WRITE_EN_Pos = 0x1d
	// Bit mask of SPI_MEM_FAST_WRITE_EN field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_FAST_WRITE_EN_Msk = 0x20000000
	// Bit SPI_MEM_FAST_WRITE_EN.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_FAST_WRITE_EN = 0x20000000
	// Position of SPI_MEM_RXFIFO_RST field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_RXFIFO_RST_Pos = 0x1e
	// Bit mask of SPI_MEM_RXFIFO_RST field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_RXFIFO_RST_Msk = 0x40000000
	// Bit SPI_MEM_RXFIFO_RST.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_RXFIFO_RST = 0x40000000
	// Position of SPI_MEM_TXFIFO_RST field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_TXFIFO_RST_Pos = 0x1f
	// Bit mask of SPI_MEM_TXFIFO_RST field.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_TXFIFO_RST_Msk = 0x80000000
	// Bit SPI_MEM_TXFIFO_RST.
	SPI0_SPI_MEM_CTRL1_SPI_MEM_TXFIFO_RST = 0x80000000

	// SPI_MEM_CTRL2: SPI0 control2 register.
	// Position of SPI_MEM_CS_SETUP_TIME field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_CS_SETUP_TIME_Pos = 0x0
	// Bit mask of SPI_MEM_CS_SETUP_TIME field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_CS_SETUP_TIME_Msk = 0x1f
	// Position of SPI_MEM_CS_HOLD_TIME field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_CS_HOLD_TIME_Pos = 0x5
	// Bit mask of SPI_MEM_CS_HOLD_TIME field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_CS_HOLD_TIME_Msk = 0x3e0
	// Position of SPI_MEM_ECC_CS_HOLD_TIME field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_ECC_CS_HOLD_TIME_Pos = 0xa
	// Bit mask of SPI_MEM_ECC_CS_HOLD_TIME field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_ECC_CS_HOLD_TIME_Msk = 0x1c00
	// Position of SPI_MEM_ECC_SKIP_PAGE_CORNER field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_ECC_SKIP_PAGE_CORNER_Pos = 0xd
	// Bit mask of SPI_MEM_ECC_SKIP_PAGE_CORNER field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_ECC_SKIP_PAGE_CORNER_Msk = 0x2000
	// Bit SPI_MEM_ECC_SKIP_PAGE_CORNER.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_ECC_SKIP_PAGE_CORNER = 0x2000
	// Position of SPI_MEM_ECC_16TO18_BYTE_EN field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_ECC_16TO18_BYTE_EN_Pos = 0xe
	// Bit mask of SPI_MEM_ECC_16TO18_BYTE_EN field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_ECC_16TO18_BYTE_EN_Msk = 0x4000
	// Bit SPI_MEM_ECC_16TO18_BYTE_EN.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_ECC_16TO18_BYTE_EN = 0x4000
	// Position of SPI_MEM_SPLIT_TRANS_EN field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_SPLIT_TRANS_EN_Pos = 0x18
	// Bit mask of SPI_MEM_SPLIT_TRANS_EN field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_SPLIT_TRANS_EN_Msk = 0x1000000
	// Bit SPI_MEM_SPLIT_TRANS_EN.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_SPLIT_TRANS_EN = 0x1000000
	// Position of SPI_MEM_CS_HOLD_DELAY field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_CS_HOLD_DELAY_Pos = 0x19
	// Bit mask of SPI_MEM_CS_HOLD_DELAY field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_CS_HOLD_DELAY_Msk = 0x7e000000
	// Position of SPI_MEM_SYNC_RESET field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_SYNC_RESET_Pos = 0x1f
	// Bit mask of SPI_MEM_SYNC_RESET field.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_SYNC_RESET_Msk = 0x80000000
	// Bit SPI_MEM_SYNC_RESET.
	SPI0_SPI_MEM_CTRL2_SPI_MEM_SYNC_RESET = 0x80000000

	// SPI_MEM_CLOCK: SPI clock division control register.
	// Position of SPI_MEM_CLKCNT_L field.
	SPI0_SPI_MEM_CLOCK_SPI_MEM_CLKCNT_L_Pos = 0x0
	// Bit mask of SPI_MEM_CLKCNT_L field.
	SPI0_SPI_MEM_CLOCK_SPI_MEM_CLKCNT_L_Msk = 0xff
	// Position of SPI_MEM_CLKCNT_H field.
	SPI0_SPI_MEM_CLOCK_SPI_MEM_CLKCNT_H_Pos = 0x8
	// Bit mask of SPI_MEM_CLKCNT_H field.
	SPI0_SPI_MEM_CLOCK_SPI_MEM_CLKCNT_H_Msk = 0xff00
	// Position of SPI_MEM_CLKCNT_N field.
	SPI0_SPI_MEM_CLOCK_SPI_MEM_CLKCNT_N_Pos = 0x10
	// Bit mask of SPI_MEM_CLKCNT_N field.
	SPI0_SPI_MEM_CLOCK_SPI_MEM_CLKCNT_N_Msk = 0xff0000
	// Position of SPI_MEM_CLK_EQU_SYSCLK field.
	SPI0_SPI_MEM_CLOCK_SPI_MEM_CLK_EQU_SYSCLK_Pos = 0x1f
	// Bit mask of SPI_MEM_CLK_EQU_SYSCLK field.
	SPI0_SPI_MEM_CLOCK_SPI_MEM_CLK_EQU_SYSCLK_Msk = 0x80000000
	// Bit SPI_MEM_CLK_EQU_SYSCLK.
	SPI0_SPI_MEM_CLOCK_SPI_MEM_CLK_EQU_SYSCLK = 0x80000000

	// SPI_MEM_USER: SPI0 user register.
	// Position of SPI_MEM_CS_HOLD field.
	SPI0_SPI_MEM_USER_SPI_MEM_CS_HOLD_Pos = 0x6
	// Bit mask of SPI_MEM_CS_HOLD field.
	SPI0_SPI_MEM_USER_SPI_MEM_CS_HOLD_Msk = 0x40
	// Bit SPI_MEM_CS_HOLD.
	SPI0_SPI_MEM_USER_SPI_MEM_CS_HOLD = 0x40
	// Position of SPI_MEM_CS_SETUP field.
	SPI0_SPI_MEM_USER_SPI_MEM_CS_SETUP_Pos = 0x7
	// Bit mask of SPI_MEM_CS_SETUP field.
	SPI0_SPI_MEM_USER_SPI_MEM_CS_SETUP_Msk = 0x80
	// Bit SPI_MEM_CS_SETUP.
	SPI0_SPI_MEM_USER_SPI_MEM_CS_SETUP = 0x80
	// Position of SPI_MEM_CK_OUT_EDGE field.
	SPI0_SPI_MEM_USER_SPI_MEM_CK_OUT_EDGE_Pos = 0x9
	// Bit mask of SPI_MEM_CK_OUT_EDGE field.
	SPI0_SPI_MEM_USER_SPI_MEM_CK_OUT_EDGE_Msk = 0x200
	// Bit SPI_MEM_CK_OUT_EDGE.
	SPI0_SPI_MEM_USER_SPI_MEM_CK_OUT_EDGE = 0x200
	// Position of SPI_MEM_USR_DUMMY_IDLE field.
	SPI0_SPI_MEM_USER_SPI_MEM_USR_DUMMY_IDLE_Pos = 0x1a
	// Bit mask of SPI_MEM_USR_DUMMY_IDLE field.
	SPI0_SPI_MEM_USER_SPI_MEM_USR_DUMMY_IDLE_Msk = 0x4000000
	// Bit SPI_MEM_USR_DUMMY_IDLE.
	SPI0_SPI_MEM_USER_SPI_MEM_USR_DUMMY_IDLE = 0x4000000
	// Position of SPI_MEM_USR_DUMMY field.
	SPI0_SPI_MEM_USER_SPI_MEM_USR_DUMMY_Pos = 0x1d
	// Bit mask of SPI_MEM_USR_DUMMY field.
	SPI0_SPI_MEM_USER_SPI_MEM_USR_DUMMY_Msk = 0x20000000
	// Bit SPI_MEM_USR_DUMMY.
	SPI0_SPI_MEM_USER_SPI_MEM_USR_DUMMY = 0x20000000

	// SPI_MEM_USER1: SPI0 user1 register.
	// Position of SPI_MEM_USR_DUMMY_CYCLELEN field.
	SPI0_SPI_MEM_USER1_SPI_MEM_USR_DUMMY_CYCLELEN_Pos = 0x0
	// Bit mask of SPI_MEM_USR_DUMMY_CYCLELEN field.
	SPI0_SPI_MEM_USER1_SPI_MEM_USR_DUMMY_CYCLELEN_Msk = 0x3f
	// Position of SPI_MEM_USR_DBYTELEN field.
	SPI0_SPI_MEM_USER1_SPI_MEM_USR_DBYTELEN_Pos = 0x6
	// Bit mask of SPI_MEM_USR_DBYTELEN field.
	SPI0_SPI_MEM_USER1_SPI_MEM_USR_DBYTELEN_Msk = 0x1c0
	// Position of SPI_MEM_USR_ADDR_BITLEN field.
	SPI0_SPI_MEM_USER1_SPI_MEM_USR_ADDR_BITLEN_Pos = 0x1a
	// Bit mask of SPI_MEM_USR_ADDR_BITLEN field.
	SPI0_SPI_MEM_USER1_SPI_MEM_USR_ADDR_BITLEN_Msk = 0xfc000000

	// SPI_MEM_USER2: SPI0 user2 register.
	// Position of SPI_MEM_USR_COMMAND_VALUE field.
	SPI0_SPI_MEM_USER2_SPI_MEM_USR_COMMAND_VALUE_Pos = 0x0
	// Bit mask of SPI_MEM_USR_COMMAND_VALUE field.
	SPI0_SPI_MEM_USER2_SPI_MEM_USR_COMMAND_VALUE_Msk = 0xffff
	// Position of SPI_MEM_USR_COMMAND_BITLEN field.
	SPI0_SPI_MEM_USER2_SPI_MEM_USR_COMMAND_BITLEN_Pos = 0x1c
	// Bit mask of SPI_MEM_USR_COMMAND_BITLEN field.
	SPI0_SPI_MEM_USER2_SPI_MEM_USR_COMMAND_BITLEN_Msk = 0xf0000000

	// SPI_MEM_RD_STATUS: SPI0 read control register.
	// Position of SPI_MEM_WB_MODE field.
	SPI0_SPI_MEM_RD_STATUS_SPI_MEM_WB_MODE_Pos = 0x10
	// Bit mask of SPI_MEM_WB_MODE field.
	SPI0_SPI_MEM_RD_STATUS_SPI_MEM_WB_MODE_Msk = 0xff0000

	// SPI_MEM_MISC: SPI0 misc register
	// Position of SPI_MEM_FSUB_PIN field.
	SPI0_SPI_MEM_MISC_SPI_MEM_FSUB_PIN_Pos = 0x7
	// Bit mask of SPI_MEM_FSUB_PIN field.
	SPI0_SPI_MEM_MISC_SPI_MEM_FSUB_PIN_Msk = 0x80
	// Bit SPI_MEM_FSUB_PIN.
	SPI0_SPI_MEM_MISC_SPI_MEM_FSUB_PIN = 0x80
	// Position of SPI_MEM_SSUB_PIN field.
	SPI0_SPI_MEM_MISC_SPI_MEM_SSUB_PIN_Pos = 0x8
	// Bit mask of SPI_MEM_SSUB_PIN field.
	SPI0_SPI_MEM_MISC_SPI_MEM_SSUB_PIN_Msk = 0x100
	// Bit SPI_MEM_SSUB_PIN.
	SPI0_SPI_MEM_MISC_SPI_MEM_SSUB_PIN = 0x100
	// Position of SPI_MEM_CK_IDLE_EDGE field.
	SPI0_SPI_MEM_MISC_SPI_MEM_CK_IDLE_EDGE_Pos = 0x9
	// Bit mask of SPI_MEM_CK_IDLE_EDGE field.
	SPI0_SPI_MEM_MISC_SPI_MEM_CK_IDLE_EDGE_Msk = 0x200
	// Bit SPI_MEM_CK_IDLE_EDGE.
	SPI0_SPI_MEM_MISC_SPI_MEM_CK_IDLE_EDGE = 0x200
	// Position of SPI_MEM_CS_KEEP_ACTIVE field.
	SPI0_SPI_MEM_MISC_SPI_MEM_CS_KEEP_ACTIVE_Pos = 0xa
	// Bit mask of SPI_MEM_CS_KEEP_ACTIVE field.
	SPI0_SPI_MEM_MISC_SPI_MEM_CS_KEEP_ACTIVE_Msk = 0x400
	// Bit SPI_MEM_CS_KEEP_ACTIVE.
	SPI0_SPI_MEM_MISC_SPI_MEM_CS_KEEP_ACTIVE = 0x400

	// SPI_MEM_CACHE_FCTRL: SPI0 bit mode control register.
	// Position of SPI_MEM_AXI_REQ_EN field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_AXI_REQ_EN_Pos = 0x0
	// Bit mask of SPI_MEM_AXI_REQ_EN field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_AXI_REQ_EN_Msk = 0x1
	// Bit SPI_MEM_AXI_REQ_EN.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_AXI_REQ_EN = 0x1
	// Position of SPI_MEM_CACHE_USR_ADDR_4BYTE field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_USR_ADDR_4BYTE_Pos = 0x1
	// Bit mask of SPI_MEM_CACHE_USR_ADDR_4BYTE field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_USR_ADDR_4BYTE_Msk = 0x2
	// Bit SPI_MEM_CACHE_USR_ADDR_4BYTE.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_USR_ADDR_4BYTE = 0x2
	// Position of SPI_MEM_CACHE_FLASH_USR_CMD field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_FLASH_USR_CMD_Pos = 0x2
	// Bit mask of SPI_MEM_CACHE_FLASH_USR_CMD field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_FLASH_USR_CMD_Msk = 0x4
	// Bit SPI_MEM_CACHE_FLASH_USR_CMD.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_FLASH_USR_CMD = 0x4
	// Position of SPI_MEM_FDIN_DUAL field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_DUAL_Pos = 0x3
	// Bit mask of SPI_MEM_FDIN_DUAL field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_DUAL_Msk = 0x8
	// Bit SPI_MEM_FDIN_DUAL.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_DUAL = 0x8
	// Position of SPI_MEM_FDOUT_DUAL field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_DUAL_Pos = 0x4
	// Bit mask of SPI_MEM_FDOUT_DUAL field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_DUAL_Msk = 0x10
	// Bit SPI_MEM_FDOUT_DUAL.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_DUAL = 0x10
	// Position of SPI_MEM_FADDR_DUAL field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_DUAL_Pos = 0x5
	// Bit mask of SPI_MEM_FADDR_DUAL field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_DUAL_Msk = 0x20
	// Bit SPI_MEM_FADDR_DUAL.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_DUAL = 0x20
	// Position of SPI_MEM_FDIN_QUAD field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_QUAD_Pos = 0x6
	// Bit mask of SPI_MEM_FDIN_QUAD field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_QUAD_Msk = 0x40
	// Bit SPI_MEM_FDIN_QUAD.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_QUAD = 0x40
	// Position of SPI_MEM_FDOUT_QUAD field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_QUAD_Pos = 0x7
	// Bit mask of SPI_MEM_FDOUT_QUAD field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_QUAD_Msk = 0x80
	// Bit SPI_MEM_FDOUT_QUAD.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_QUAD = 0x80
	// Position of SPI_MEM_FADDR_QUAD field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_QUAD_Pos = 0x8
	// Bit mask of SPI_MEM_FADDR_QUAD field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_QUAD_Msk = 0x100
	// Bit SPI_MEM_FADDR_QUAD.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_QUAD = 0x100
	// Position of SPI_SAME_AW_AR_ADDR_CHK_EN field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_SAME_AW_AR_ADDR_CHK_EN_Pos = 0x1e
	// Bit mask of SPI_SAME_AW_AR_ADDR_CHK_EN field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_SAME_AW_AR_ADDR_CHK_EN_Msk = 0x40000000
	// Bit SPI_SAME_AW_AR_ADDR_CHK_EN.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_SAME_AW_AR_ADDR_CHK_EN = 0x40000000
	// Position of SPI_CLOSE_AXI_INF_EN field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_CLOSE_AXI_INF_EN_Pos = 0x1f
	// Bit mask of SPI_CLOSE_AXI_INF_EN field.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_CLOSE_AXI_INF_EN_Msk = 0x80000000
	// Bit SPI_CLOSE_AXI_INF_EN.
	SPI0_SPI_MEM_CACHE_FCTRL_SPI_CLOSE_AXI_INF_EN = 0x80000000

	// SPI_MEM_CACHE_SCTRL: SPI0 external RAM control register
	// Position of SPI_MEM_CACHE_USR_SADDR_4BYTE field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_USR_SADDR_4BYTE_Pos = 0x0
	// Bit mask of SPI_MEM_CACHE_USR_SADDR_4BYTE field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_USR_SADDR_4BYTE_Msk = 0x1
	// Bit SPI_MEM_CACHE_USR_SADDR_4BYTE.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_USR_SADDR_4BYTE = 0x1
	// Position of SPI_MEM_USR_SRAM_DIO field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_USR_SRAM_DIO_Pos = 0x1
	// Bit mask of SPI_MEM_USR_SRAM_DIO field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_USR_SRAM_DIO_Msk = 0x2
	// Bit SPI_MEM_USR_SRAM_DIO.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_USR_SRAM_DIO = 0x2
	// Position of SPI_MEM_USR_SRAM_QIO field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_USR_SRAM_QIO_Pos = 0x2
	// Bit mask of SPI_MEM_USR_SRAM_QIO field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_USR_SRAM_QIO_Msk = 0x4
	// Bit SPI_MEM_USR_SRAM_QIO.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_USR_SRAM_QIO = 0x4
	// Position of SPI_MEM_USR_WR_SRAM_DUMMY field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_USR_WR_SRAM_DUMMY_Pos = 0x3
	// Bit mask of SPI_MEM_USR_WR_SRAM_DUMMY field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_USR_WR_SRAM_DUMMY_Msk = 0x8
	// Bit SPI_MEM_USR_WR_SRAM_DUMMY.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_USR_WR_SRAM_DUMMY = 0x8
	// Position of SPI_MEM_USR_RD_SRAM_DUMMY field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_USR_RD_SRAM_DUMMY_Pos = 0x4
	// Bit mask of SPI_MEM_USR_RD_SRAM_DUMMY field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_USR_RD_SRAM_DUMMY_Msk = 0x10
	// Bit SPI_MEM_USR_RD_SRAM_DUMMY.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_USR_RD_SRAM_DUMMY = 0x10
	// Position of SPI_MEM_CACHE_SRAM_USR_RCMD field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_SRAM_USR_RCMD_Pos = 0x5
	// Bit mask of SPI_MEM_CACHE_SRAM_USR_RCMD field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_SRAM_USR_RCMD_Msk = 0x20
	// Bit SPI_MEM_CACHE_SRAM_USR_RCMD.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_SRAM_USR_RCMD = 0x20
	// Position of SPI_MEM_SRAM_RDUMMY_CYCLELEN field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_RDUMMY_CYCLELEN_Pos = 0x6
	// Bit mask of SPI_MEM_SRAM_RDUMMY_CYCLELEN field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_RDUMMY_CYCLELEN_Msk = 0xfc0
	// Position of SPI_MEM_SRAM_ADDR_BITLEN field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_ADDR_BITLEN_Pos = 0xe
	// Bit mask of SPI_MEM_SRAM_ADDR_BITLEN field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_ADDR_BITLEN_Msk = 0xfc000
	// Position of SPI_MEM_CACHE_SRAM_USR_WCMD field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_SRAM_USR_WCMD_Pos = 0x14
	// Bit mask of SPI_MEM_CACHE_SRAM_USR_WCMD field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_SRAM_USR_WCMD_Msk = 0x100000
	// Bit SPI_MEM_CACHE_SRAM_USR_WCMD.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_CACHE_SRAM_USR_WCMD = 0x100000
	// Position of SPI_MEM_SRAM_OCT field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_OCT_Pos = 0x15
	// Bit mask of SPI_MEM_SRAM_OCT field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_OCT_Msk = 0x200000
	// Bit SPI_MEM_SRAM_OCT.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_OCT = 0x200000
	// Position of SPI_MEM_SRAM_WDUMMY_CYCLELEN field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_WDUMMY_CYCLELEN_Pos = 0x16
	// Bit mask of SPI_MEM_SRAM_WDUMMY_CYCLELEN field.
	SPI0_SPI_MEM_CACHE_SCTRL_SPI_MEM_SRAM_WDUMMY_CYCLELEN_Msk = 0xfc00000

	// SPI_MEM_SRAM_CMD: SPI0 external RAM mode control register
	// Position of SPI_MEM_SCLK_MODE field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SCLK_MODE_Pos = 0x0
	// Bit mask of SPI_MEM_SCLK_MODE field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SCLK_MODE_Msk = 0x3
	// Position of SPI_MEM_SWB_MODE field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SWB_MODE_Pos = 0x2
	// Bit mask of SPI_MEM_SWB_MODE field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SWB_MODE_Msk = 0x3fc
	// Position of SPI_MEM_SDIN_DUAL field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDIN_DUAL_Pos = 0xa
	// Bit mask of SPI_MEM_SDIN_DUAL field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDIN_DUAL_Msk = 0x400
	// Bit SPI_MEM_SDIN_DUAL.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDIN_DUAL = 0x400
	// Position of SPI_MEM_SDOUT_DUAL field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_DUAL_Pos = 0xb
	// Bit mask of SPI_MEM_SDOUT_DUAL field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_DUAL_Msk = 0x800
	// Bit SPI_MEM_SDOUT_DUAL.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_DUAL = 0x800
	// Position of SPI_MEM_SADDR_DUAL field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SADDR_DUAL_Pos = 0xc
	// Bit mask of SPI_MEM_SADDR_DUAL field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SADDR_DUAL_Msk = 0x1000
	// Bit SPI_MEM_SADDR_DUAL.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SADDR_DUAL = 0x1000
	// Position of SPI_MEM_SDIN_QUAD field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDIN_QUAD_Pos = 0xe
	// Bit mask of SPI_MEM_SDIN_QUAD field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDIN_QUAD_Msk = 0x4000
	// Bit SPI_MEM_SDIN_QUAD.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDIN_QUAD = 0x4000
	// Position of SPI_MEM_SDOUT_QUAD field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_QUAD_Pos = 0xf
	// Bit mask of SPI_MEM_SDOUT_QUAD field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_QUAD_Msk = 0x8000
	// Bit SPI_MEM_SDOUT_QUAD.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_QUAD = 0x8000
	// Position of SPI_MEM_SADDR_QUAD field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SADDR_QUAD_Pos = 0x10
	// Bit mask of SPI_MEM_SADDR_QUAD field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SADDR_QUAD_Msk = 0x10000
	// Bit SPI_MEM_SADDR_QUAD.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SADDR_QUAD = 0x10000
	// Position of SPI_MEM_SCMD_QUAD field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SCMD_QUAD_Pos = 0x11
	// Bit mask of SPI_MEM_SCMD_QUAD field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SCMD_QUAD_Msk = 0x20000
	// Bit SPI_MEM_SCMD_QUAD.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SCMD_QUAD = 0x20000
	// Position of SPI_MEM_SDIN_OCT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDIN_OCT_Pos = 0x12
	// Bit mask of SPI_MEM_SDIN_OCT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDIN_OCT_Msk = 0x40000
	// Bit SPI_MEM_SDIN_OCT.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDIN_OCT = 0x40000
	// Position of SPI_MEM_SDOUT_OCT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_OCT_Pos = 0x13
	// Bit mask of SPI_MEM_SDOUT_OCT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_OCT_Msk = 0x80000
	// Bit SPI_MEM_SDOUT_OCT.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDOUT_OCT = 0x80000
	// Position of SPI_MEM_SADDR_OCT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SADDR_OCT_Pos = 0x14
	// Bit mask of SPI_MEM_SADDR_OCT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SADDR_OCT_Msk = 0x100000
	// Bit SPI_MEM_SADDR_OCT.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SADDR_OCT = 0x100000
	// Position of SPI_MEM_SCMD_OCT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SCMD_OCT_Pos = 0x15
	// Bit mask of SPI_MEM_SCMD_OCT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SCMD_OCT_Msk = 0x200000
	// Bit SPI_MEM_SCMD_OCT.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SCMD_OCT = 0x200000
	// Position of SPI_MEM_SDUMMY_RIN field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDUMMY_RIN_Pos = 0x16
	// Bit mask of SPI_MEM_SDUMMY_RIN field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDUMMY_RIN_Msk = 0x400000
	// Bit SPI_MEM_SDUMMY_RIN.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDUMMY_RIN = 0x400000
	// Position of SPI_MEM_SDUMMY_WOUT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDUMMY_WOUT_Pos = 0x17
	// Bit mask of SPI_MEM_SDUMMY_WOUT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDUMMY_WOUT_Msk = 0x800000
	// Bit SPI_MEM_SDUMMY_WOUT.
	SPI0_SPI_MEM_SRAM_CMD_SPI_MEM_SDUMMY_WOUT = 0x800000
	// Position of SPI_SMEM_WDUMMY_DQS_ALWAYS_OUT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_SMEM_WDUMMY_DQS_ALWAYS_OUT_Pos = 0x18
	// Bit mask of SPI_SMEM_WDUMMY_DQS_ALWAYS_OUT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_SMEM_WDUMMY_DQS_ALWAYS_OUT_Msk = 0x1000000
	// Bit SPI_SMEM_WDUMMY_DQS_ALWAYS_OUT.
	SPI0_SPI_MEM_SRAM_CMD_SPI_SMEM_WDUMMY_DQS_ALWAYS_OUT = 0x1000000
	// Position of SPI_SMEM_WDUMMY_ALWAYS_OUT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_SMEM_WDUMMY_ALWAYS_OUT_Pos = 0x19
	// Bit mask of SPI_SMEM_WDUMMY_ALWAYS_OUT field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_SMEM_WDUMMY_ALWAYS_OUT_Msk = 0x2000000
	// Bit SPI_SMEM_WDUMMY_ALWAYS_OUT.
	SPI0_SPI_MEM_SRAM_CMD_SPI_SMEM_WDUMMY_ALWAYS_OUT = 0x2000000
	// Position of SPI_SMEM_DQS_IE_ALWAYS_ON field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_SMEM_DQS_IE_ALWAYS_ON_Pos = 0x1e
	// Bit mask of SPI_SMEM_DQS_IE_ALWAYS_ON field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_SMEM_DQS_IE_ALWAYS_ON_Msk = 0x40000000
	// Bit SPI_SMEM_DQS_IE_ALWAYS_ON.
	SPI0_SPI_MEM_SRAM_CMD_SPI_SMEM_DQS_IE_ALWAYS_ON = 0x40000000
	// Position of SPI_SMEM_DATA_IE_ALWAYS_ON field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_SMEM_DATA_IE_ALWAYS_ON_Pos = 0x1f
	// Bit mask of SPI_SMEM_DATA_IE_ALWAYS_ON field.
	SPI0_SPI_MEM_SRAM_CMD_SPI_SMEM_DATA_IE_ALWAYS_ON_Msk = 0x80000000
	// Bit SPI_SMEM_DATA_IE_ALWAYS_ON.
	SPI0_SPI_MEM_SRAM_CMD_SPI_SMEM_DATA_IE_ALWAYS_ON = 0x80000000

	// SPI_MEM_SRAM_DRD_CMD: SPI0 external RAM DDR read command control register
	// Position of SPI_MEM_CACHE_SRAM_USR_RD_CMD_VALUE field.
	SPI0_SPI_MEM_SRAM_DRD_CMD_SPI_MEM_CACHE_SRAM_USR_RD_CMD_VALUE_Pos = 0x0
	// Bit mask of SPI_MEM_CACHE_SRAM_USR_RD_CMD_VALUE field.
	SPI0_SPI_MEM_SRAM_DRD_CMD_SPI_MEM_CACHE_SRAM_USR_RD_CMD_VALUE_Msk = 0xffff
	// Position of SPI_MEM_CACHE_SRAM_USR_RD_CMD_BITLEN field.
	SPI0_SPI_MEM_SRAM_DRD_CMD_SPI_MEM_CACHE_SRAM_USR_RD_CMD_BITLEN_Pos = 0x1c
	// Bit mask of SPI_MEM_CACHE_SRAM_USR_RD_CMD_BITLEN field.
	SPI0_SPI_MEM_SRAM_DRD_CMD_SPI_MEM_CACHE_SRAM_USR_RD_CMD_BITLEN_Msk = 0xf0000000

	// SPI_MEM_SRAM_DWR_CMD: SPI0 external RAM DDR write command control register
	// Position of SPI_MEM_CACHE_SRAM_USR_WR_CMD_VALUE field.
	SPI0_SPI_MEM_SRAM_DWR_CMD_SPI_MEM_CACHE_SRAM_USR_WR_CMD_VALUE_Pos = 0x0
	// Bit mask of SPI_MEM_CACHE_SRAM_USR_WR_CMD_VALUE field.
	SPI0_SPI_MEM_SRAM_DWR_CMD_SPI_MEM_CACHE_SRAM_USR_WR_CMD_VALUE_Msk = 0xffff
	// Position of SPI_MEM_CACHE_SRAM_USR_WR_CMD_BITLEN field.
	SPI0_SPI_MEM_SRAM_DWR_CMD_SPI_MEM_CACHE_SRAM_USR_WR_CMD_BITLEN_Pos = 0x1c
	// Bit mask of SPI_MEM_CACHE_SRAM_USR_WR_CMD_BITLEN field.
	SPI0_SPI_MEM_SRAM_DWR_CMD_SPI_MEM_CACHE_SRAM_USR_WR_CMD_BITLEN_Msk = 0xf0000000

	// SPI_MEM_SRAM_CLK: SPI0 external RAM clock control register
	// Position of SPI_MEM_SCLKCNT_L field.
	SPI0_SPI_MEM_SRAM_CLK_SPI_MEM_SCLKCNT_L_Pos = 0x0
	// Bit mask of SPI_MEM_SCLKCNT_L field.
	SPI0_SPI_MEM_SRAM_CLK_SPI_MEM_SCLKCNT_L_Msk = 0xff
	// Position of SPI_MEM_SCLKCNT_H field.
	SPI0_SPI_MEM_SRAM_CLK_SPI_MEM_SCLKCNT_H_Pos = 0x8
	// Bit mask of SPI_MEM_SCLKCNT_H field.
	SPI0_SPI_MEM_SRAM_CLK_SPI_MEM_SCLKCNT_H_Msk = 0xff00
	// Position of SPI_MEM_SCLKCNT_N field.
	SPI0_SPI_MEM_SRAM_CLK_SPI_MEM_SCLKCNT_N_Pos = 0x10
	// Bit mask of SPI_MEM_SCLKCNT_N field.
	SPI0_SPI_MEM_SRAM_CLK_SPI_MEM_SCLKCNT_N_Msk = 0xff0000
	// Position of SPI_MEM_SCLK_EQU_SYSCLK field.
	SPI0_SPI_MEM_SRAM_CLK_SPI_MEM_SCLK_EQU_SYSCLK_Pos = 0x1f
	// Bit mask of SPI_MEM_SCLK_EQU_SYSCLK field.
	SPI0_SPI_MEM_SRAM_CLK_SPI_MEM_SCLK_EQU_SYSCLK_Msk = 0x80000000
	// Bit SPI_MEM_SCLK_EQU_SYSCLK.
	SPI0_SPI_MEM_SRAM_CLK_SPI_MEM_SCLK_EQU_SYSCLK = 0x80000000

	// SPI_MEM_FSM: SPI0 FSM status register
	// Position of SPI_MEM_LOCK_DELAY_TIME field.
	SPI0_SPI_MEM_FSM_SPI_MEM_LOCK_DELAY_TIME_Pos = 0x7
	// Bit mask of SPI_MEM_LOCK_DELAY_TIME field.
	SPI0_SPI_MEM_FSM_SPI_MEM_LOCK_DELAY_TIME_Msk = 0xf80

	// SPI_MEM_INT_ENA: SPI0 interrupt enable register
	// Position of SPI_MEM_SLV_ST_END_INT_ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_SLV_ST_END_INT_ENA_Pos = 0x3
	// Bit mask of SPI_MEM_SLV_ST_END_INT_ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_SLV_ST_END_INT_ENA_Msk = 0x8
	// Bit SPI_MEM_SLV_ST_END_INT_ENA.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_SLV_ST_END_INT_ENA = 0x8
	// Position of SPI_MEM_MST_ST_END_INT_ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_MST_ST_END_INT_ENA_Pos = 0x4
	// Bit mask of SPI_MEM_MST_ST_END_INT_ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_MST_ST_END_INT_ENA_Msk = 0x10
	// Bit SPI_MEM_MST_ST_END_INT_ENA.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_MST_ST_END_INT_ENA = 0x10
	// Position of SPI_MEM_ECC_ERR_INT_ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_ECC_ERR_INT_ENA_Pos = 0x5
	// Bit mask of SPI_MEM_ECC_ERR_INT_ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_ECC_ERR_INT_ENA_Msk = 0x20
	// Bit SPI_MEM_ECC_ERR_INT_ENA.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_ECC_ERR_INT_ENA = 0x20
	// Position of SPI_MEM_PMS_REJECT_INT_ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_PMS_REJECT_INT_ENA_Pos = 0x6
	// Bit mask of SPI_MEM_PMS_REJECT_INT_ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_PMS_REJECT_INT_ENA_Msk = 0x40
	// Bit SPI_MEM_PMS_REJECT_INT_ENA.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_PMS_REJECT_INT_ENA = 0x40
	// Position of SPI_MEM_AXI_RADDR_ERR_INT_ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_AXI_RADDR_ERR_INT_ENA_Pos = 0x7
	// Bit mask of SPI_MEM_AXI_RADDR_ERR_INT_ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_AXI_RADDR_ERR_INT_ENA_Msk = 0x80
	// Bit SPI_MEM_AXI_RADDR_ERR_INT_ENA.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_AXI_RADDR_ERR_INT_ENA = 0x80
	// Position of SPI_MEM_AXI_WR_FLASH_ERR_INT_ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_AXI_WR_FLASH_ERR_INT_ENA_Pos = 0x8
	// Bit mask of SPI_MEM_AXI_WR_FLASH_ERR_INT_ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_AXI_WR_FLASH_ERR_INT_ENA_Msk = 0x100
	// Bit SPI_MEM_AXI_WR_FLASH_ERR_INT_ENA.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_AXI_WR_FLASH_ERR_INT_ENA = 0x100
	// Position of SPI_MEM_AXI_WADDR_ERR_INT__ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_AXI_WADDR_ERR_INT__ENA_Pos = 0x9
	// Bit mask of SPI_MEM_AXI_WADDR_ERR_INT__ENA field.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_AXI_WADDR_ERR_INT__ENA_Msk = 0x200
	// Bit SPI_MEM_AXI_WADDR_ERR_INT__ENA.
	SPI0_SPI_MEM_INT_ENA_SPI_MEM_AXI_WADDR_ERR_INT__ENA = 0x200

	// SPI_MEM_INT_CLR: SPI0 interrupt clear register
	// Position of SPI_MEM_SLV_ST_END_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_SLV_ST_END_INT_CLR_Pos = 0x3
	// Bit mask of SPI_MEM_SLV_ST_END_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_SLV_ST_END_INT_CLR_Msk = 0x8
	// Bit SPI_MEM_SLV_ST_END_INT_CLR.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_SLV_ST_END_INT_CLR = 0x8
	// Position of SPI_MEM_MST_ST_END_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_MST_ST_END_INT_CLR_Pos = 0x4
	// Bit mask of SPI_MEM_MST_ST_END_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_MST_ST_END_INT_CLR_Msk = 0x10
	// Bit SPI_MEM_MST_ST_END_INT_CLR.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_MST_ST_END_INT_CLR = 0x10
	// Position of SPI_MEM_ECC_ERR_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_ECC_ERR_INT_CLR_Pos = 0x5
	// Bit mask of SPI_MEM_ECC_ERR_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_ECC_ERR_INT_CLR_Msk = 0x20
	// Bit SPI_MEM_ECC_ERR_INT_CLR.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_ECC_ERR_INT_CLR = 0x20
	// Position of SPI_MEM_PMS_REJECT_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_PMS_REJECT_INT_CLR_Pos = 0x6
	// Bit mask of SPI_MEM_PMS_REJECT_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_PMS_REJECT_INT_CLR_Msk = 0x40
	// Bit SPI_MEM_PMS_REJECT_INT_CLR.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_PMS_REJECT_INT_CLR = 0x40
	// Position of SPI_MEM_AXI_RADDR_ERR_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_AXI_RADDR_ERR_INT_CLR_Pos = 0x7
	// Bit mask of SPI_MEM_AXI_RADDR_ERR_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_AXI_RADDR_ERR_INT_CLR_Msk = 0x80
	// Bit SPI_MEM_AXI_RADDR_ERR_INT_CLR.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_AXI_RADDR_ERR_INT_CLR = 0x80
	// Position of SPI_MEM_AXI_WR_FLASH_ERR_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_AXI_WR_FLASH_ERR_INT_CLR_Pos = 0x8
	// Bit mask of SPI_MEM_AXI_WR_FLASH_ERR_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_AXI_WR_FLASH_ERR_INT_CLR_Msk = 0x100
	// Bit SPI_MEM_AXI_WR_FLASH_ERR_INT_CLR.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_AXI_WR_FLASH_ERR_INT_CLR = 0x100
	// Position of SPI_MEM_AXI_WADDR_ERR_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_AXI_WADDR_ERR_INT_CLR_Pos = 0x9
	// Bit mask of SPI_MEM_AXI_WADDR_ERR_INT_CLR field.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_AXI_WADDR_ERR_INT_CLR_Msk = 0x200
	// Bit SPI_MEM_AXI_WADDR_ERR_INT_CLR.
	SPI0_SPI_MEM_INT_CLR_SPI_MEM_AXI_WADDR_ERR_INT_CLR = 0x200

	// SPI_MEM_INT_RAW: SPI0 interrupt raw register
	// Position of SPI_MEM_SLV_ST_END_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_SLV_ST_END_INT_RAW_Pos = 0x3
	// Bit mask of SPI_MEM_SLV_ST_END_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_SLV_ST_END_INT_RAW_Msk = 0x8
	// Bit SPI_MEM_SLV_ST_END_INT_RAW.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_SLV_ST_END_INT_RAW = 0x8
	// Position of SPI_MEM_MST_ST_END_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_MST_ST_END_INT_RAW_Pos = 0x4
	// Bit mask of SPI_MEM_MST_ST_END_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_MST_ST_END_INT_RAW_Msk = 0x10
	// Bit SPI_MEM_MST_ST_END_INT_RAW.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_MST_ST_END_INT_RAW = 0x10
	// Position of SPI_MEM_ECC_ERR_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_ECC_ERR_INT_RAW_Pos = 0x5
	// Bit mask of SPI_MEM_ECC_ERR_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_ECC_ERR_INT_RAW_Msk = 0x20
	// Bit SPI_MEM_ECC_ERR_INT_RAW.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_ECC_ERR_INT_RAW = 0x20
	// Position of SPI_MEM_PMS_REJECT_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_PMS_REJECT_INT_RAW_Pos = 0x6
	// Bit mask of SPI_MEM_PMS_REJECT_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_PMS_REJECT_INT_RAW_Msk = 0x40
	// Bit SPI_MEM_PMS_REJECT_INT_RAW.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_PMS_REJECT_INT_RAW = 0x40
	// Position of SPI_MEM_AXI_RADDR_ERR_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_AXI_RADDR_ERR_INT_RAW_Pos = 0x7
	// Bit mask of SPI_MEM_AXI_RADDR_ERR_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_AXI_RADDR_ERR_INT_RAW_Msk = 0x80
	// Bit SPI_MEM_AXI_RADDR_ERR_INT_RAW.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_AXI_RADDR_ERR_INT_RAW = 0x80
	// Position of SPI_MEM_AXI_WR_FLASH_ERR_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_AXI_WR_FLASH_ERR_INT_RAW_Pos = 0x8
	// Bit mask of SPI_MEM_AXI_WR_FLASH_ERR_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_AXI_WR_FLASH_ERR_INT_RAW_Msk = 0x100
	// Bit SPI_MEM_AXI_WR_FLASH_ERR_INT_RAW.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_AXI_WR_FLASH_ERR_INT_RAW = 0x100
	// Position of SPI_MEM_AXI_WADDR_ERR_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_AXI_WADDR_ERR_INT_RAW_Pos = 0x9
	// Bit mask of SPI_MEM_AXI_WADDR_ERR_INT_RAW field.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_AXI_WADDR_ERR_INT_RAW_Msk = 0x200
	// Bit SPI_MEM_AXI_WADDR_ERR_INT_RAW.
	SPI0_SPI_MEM_INT_RAW_SPI_MEM_AXI_WADDR_ERR_INT_RAW = 0x200

	// SPI_MEM_INT_ST: SPI0 interrupt status register
	// Position of SPI_MEM_SLV_ST_END_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_SLV_ST_END_INT_ST_Pos = 0x3
	// Bit mask of SPI_MEM_SLV_ST_END_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_SLV_ST_END_INT_ST_Msk = 0x8
	// Bit SPI_MEM_SLV_ST_END_INT_ST.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_SLV_ST_END_INT_ST = 0x8
	// Position of SPI_MEM_MST_ST_END_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_MST_ST_END_INT_ST_Pos = 0x4
	// Bit mask of SPI_MEM_MST_ST_END_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_MST_ST_END_INT_ST_Msk = 0x10
	// Bit SPI_MEM_MST_ST_END_INT_ST.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_MST_ST_END_INT_ST = 0x10
	// Position of SPI_MEM_ECC_ERR_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_ECC_ERR_INT_ST_Pos = 0x5
	// Bit mask of SPI_MEM_ECC_ERR_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_ECC_ERR_INT_ST_Msk = 0x20
	// Bit SPI_MEM_ECC_ERR_INT_ST.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_ECC_ERR_INT_ST = 0x20
	// Position of SPI_MEM_PMS_REJECT_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_PMS_REJECT_INT_ST_Pos = 0x6
	// Bit mask of SPI_MEM_PMS_REJECT_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_PMS_REJECT_INT_ST_Msk = 0x40
	// Bit SPI_MEM_PMS_REJECT_INT_ST.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_PMS_REJECT_INT_ST = 0x40
	// Position of SPI_MEM_AXI_RADDR_ERR_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_AXI_RADDR_ERR_INT_ST_Pos = 0x7
	// Bit mask of SPI_MEM_AXI_RADDR_ERR_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_AXI_RADDR_ERR_INT_ST_Msk = 0x80
	// Bit SPI_MEM_AXI_RADDR_ERR_INT_ST.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_AXI_RADDR_ERR_INT_ST = 0x80
	// Position of SPI_MEM_AXI_WR_FLASH_ERR_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_AXI_WR_FLASH_ERR_INT_ST_Pos = 0x8
	// Bit mask of SPI_MEM_AXI_WR_FLASH_ERR_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_AXI_WR_FLASH_ERR_INT_ST_Msk = 0x100
	// Bit SPI_MEM_AXI_WR_FLASH_ERR_INT_ST.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_AXI_WR_FLASH_ERR_INT_ST = 0x100
	// Position of SPI_MEM_AXI_WADDR_ERR_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_AXI_WADDR_ERR_INT_ST_Pos = 0x9
	// Bit mask of SPI_MEM_AXI_WADDR_ERR_INT_ST field.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_AXI_WADDR_ERR_INT_ST_Msk = 0x200
	// Bit SPI_MEM_AXI_WADDR_ERR_INT_ST.
	SPI0_SPI_MEM_INT_ST_SPI_MEM_AXI_WADDR_ERR_INT_ST = 0x200

	// SPI_MEM_DDR: SPI0 flash DDR mode control register
	// Position of SPI_FMEM_DDR_EN field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_EN_Pos = 0x0
	// Bit mask of SPI_FMEM_DDR_EN field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_EN_Msk = 0x1
	// Bit SPI_FMEM_DDR_EN.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_EN = 0x1
	// Position of SPI_FMEM_VAR_DUMMY field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_VAR_DUMMY_Pos = 0x1
	// Bit mask of SPI_FMEM_VAR_DUMMY field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_VAR_DUMMY_Msk = 0x2
	// Bit SPI_FMEM_VAR_DUMMY.
	SPI0_SPI_MEM_DDR_SPI_FMEM_VAR_DUMMY = 0x2
	// Position of SPI_FMEM_DDR_RDAT_SWP field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_RDAT_SWP_Pos = 0x2
	// Bit mask of SPI_FMEM_DDR_RDAT_SWP field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_RDAT_SWP_Msk = 0x4
	// Bit SPI_FMEM_DDR_RDAT_SWP.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_RDAT_SWP = 0x4
	// Position of SPI_FMEM_DDR_WDAT_SWP field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_WDAT_SWP_Pos = 0x3
	// Bit mask of SPI_FMEM_DDR_WDAT_SWP field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_WDAT_SWP_Msk = 0x8
	// Bit SPI_FMEM_DDR_WDAT_SWP.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_WDAT_SWP = 0x8
	// Position of SPI_FMEM_DDR_CMD_DIS field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_CMD_DIS_Pos = 0x4
	// Bit mask of SPI_FMEM_DDR_CMD_DIS field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_CMD_DIS_Msk = 0x10
	// Bit SPI_FMEM_DDR_CMD_DIS.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_CMD_DIS = 0x10
	// Position of SPI_FMEM_OUTMINBYTELEN field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_OUTMINBYTELEN_Pos = 0x5
	// Bit mask of SPI_FMEM_OUTMINBYTELEN field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_OUTMINBYTELEN_Msk = 0xfe0
	// Position of SPI_FMEM_TX_DDR_MSK_EN field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_TX_DDR_MSK_EN_Pos = 0xc
	// Bit mask of SPI_FMEM_TX_DDR_MSK_EN field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_TX_DDR_MSK_EN_Msk = 0x1000
	// Bit SPI_FMEM_TX_DDR_MSK_EN.
	SPI0_SPI_MEM_DDR_SPI_FMEM_TX_DDR_MSK_EN = 0x1000
	// Position of SPI_FMEM_RX_DDR_MSK_EN field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_RX_DDR_MSK_EN_Pos = 0xd
	// Bit mask of SPI_FMEM_RX_DDR_MSK_EN field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_RX_DDR_MSK_EN_Msk = 0x2000
	// Bit SPI_FMEM_RX_DDR_MSK_EN.
	SPI0_SPI_MEM_DDR_SPI_FMEM_RX_DDR_MSK_EN = 0x2000
	// Position of SPI_FMEM_USR_DDR_DQS_THD field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_USR_DDR_DQS_THD_Pos = 0xe
	// Bit mask of SPI_FMEM_USR_DDR_DQS_THD field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_USR_DDR_DQS_THD_Msk = 0x1fc000
	// Position of SPI_FMEM_DDR_DQS_LOOP field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_DQS_LOOP_Pos = 0x15
	// Bit mask of SPI_FMEM_DDR_DQS_LOOP field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_DQS_LOOP_Msk = 0x200000
	// Bit SPI_FMEM_DDR_DQS_LOOP.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DDR_DQS_LOOP = 0x200000
	// Position of SPI_FMEM_CLK_DIFF_EN field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_CLK_DIFF_EN_Pos = 0x18
	// Bit mask of SPI_FMEM_CLK_DIFF_EN field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_CLK_DIFF_EN_Msk = 0x1000000
	// Bit SPI_FMEM_CLK_DIFF_EN.
	SPI0_SPI_MEM_DDR_SPI_FMEM_CLK_DIFF_EN = 0x1000000
	// Position of SPI_FMEM_DQS_CA_IN field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DQS_CA_IN_Pos = 0x1a
	// Bit mask of SPI_FMEM_DQS_CA_IN field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DQS_CA_IN_Msk = 0x4000000
	// Bit SPI_FMEM_DQS_CA_IN.
	SPI0_SPI_MEM_DDR_SPI_FMEM_DQS_CA_IN = 0x4000000
	// Position of SPI_FMEM_HYPERBUS_DUMMY_2X field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_HYPERBUS_DUMMY_2X_Pos = 0x1b
	// Bit mask of SPI_FMEM_HYPERBUS_DUMMY_2X field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_HYPERBUS_DUMMY_2X_Msk = 0x8000000
	// Bit SPI_FMEM_HYPERBUS_DUMMY_2X.
	SPI0_SPI_MEM_DDR_SPI_FMEM_HYPERBUS_DUMMY_2X = 0x8000000
	// Position of SPI_FMEM_CLK_DIFF_INV field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_CLK_DIFF_INV_Pos = 0x1c
	// Bit mask of SPI_FMEM_CLK_DIFF_INV field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_CLK_DIFF_INV_Msk = 0x10000000
	// Bit SPI_FMEM_CLK_DIFF_INV.
	SPI0_SPI_MEM_DDR_SPI_FMEM_CLK_DIFF_INV = 0x10000000
	// Position of SPI_FMEM_OCTA_RAM_ADDR field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_OCTA_RAM_ADDR_Pos = 0x1d
	// Bit mask of SPI_FMEM_OCTA_RAM_ADDR field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_OCTA_RAM_ADDR_Msk = 0x20000000
	// Bit SPI_FMEM_OCTA_RAM_ADDR.
	SPI0_SPI_MEM_DDR_SPI_FMEM_OCTA_RAM_ADDR = 0x20000000
	// Position of SPI_FMEM_HYPERBUS_CA field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_HYPERBUS_CA_Pos = 0x1e
	// Bit mask of SPI_FMEM_HYPERBUS_CA field.
	SPI0_SPI_MEM_DDR_SPI_FMEM_HYPERBUS_CA_Msk = 0x40000000
	// Bit SPI_FMEM_HYPERBUS_CA.
	SPI0_SPI_MEM_DDR_SPI_FMEM_HYPERBUS_CA = 0x40000000

	// SPI_SMEM_DDR: SPI0 external RAM DDR mode control register
	// Position of EN field.
	SPI0_SPI_SMEM_DDR_EN_Pos = 0x0
	// Bit mask of EN field.
	SPI0_SPI_SMEM_DDR_EN_Msk = 0x1
	// Bit EN.
	SPI0_SPI_SMEM_DDR_EN = 0x1
	// Position of SPI_SMEM_VAR_DUMMY field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_VAR_DUMMY_Pos = 0x1
	// Bit mask of SPI_SMEM_VAR_DUMMY field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_VAR_DUMMY_Msk = 0x2
	// Bit SPI_SMEM_VAR_DUMMY.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_VAR_DUMMY = 0x2
	// Position of RDAT_SWP field.
	SPI0_SPI_SMEM_DDR_RDAT_SWP_Pos = 0x2
	// Bit mask of RDAT_SWP field.
	SPI0_SPI_SMEM_DDR_RDAT_SWP_Msk = 0x4
	// Bit RDAT_SWP.
	SPI0_SPI_SMEM_DDR_RDAT_SWP = 0x4
	// Position of WDAT_SWP field.
	SPI0_SPI_SMEM_DDR_WDAT_SWP_Pos = 0x3
	// Bit mask of WDAT_SWP field.
	SPI0_SPI_SMEM_DDR_WDAT_SWP_Msk = 0x8
	// Bit WDAT_SWP.
	SPI0_SPI_SMEM_DDR_WDAT_SWP = 0x8
	// Position of CMD_DIS field.
	SPI0_SPI_SMEM_DDR_CMD_DIS_Pos = 0x4
	// Bit mask of CMD_DIS field.
	SPI0_SPI_SMEM_DDR_CMD_DIS_Msk = 0x10
	// Bit CMD_DIS.
	SPI0_SPI_SMEM_DDR_CMD_DIS = 0x10
	// Position of SPI_SMEM_OUTMINBYTELEN field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_OUTMINBYTELEN_Pos = 0x5
	// Bit mask of SPI_SMEM_OUTMINBYTELEN field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_OUTMINBYTELEN_Msk = 0xfe0
	// Position of SPI_SMEM_TX_DDR_MSK_EN field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_TX_DDR_MSK_EN_Pos = 0xc
	// Bit mask of SPI_SMEM_TX_DDR_MSK_EN field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_TX_DDR_MSK_EN_Msk = 0x1000
	// Bit SPI_SMEM_TX_DDR_MSK_EN.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_TX_DDR_MSK_EN = 0x1000
	// Position of SPI_SMEM_RX_DDR_MSK_EN field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_RX_DDR_MSK_EN_Pos = 0xd
	// Bit mask of SPI_SMEM_RX_DDR_MSK_EN field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_RX_DDR_MSK_EN_Msk = 0x2000
	// Bit SPI_SMEM_RX_DDR_MSK_EN.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_RX_DDR_MSK_EN = 0x2000
	// Position of SPI_SMEM_USR_DDR_DQS_THD field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_USR_DDR_DQS_THD_Pos = 0xe
	// Bit mask of SPI_SMEM_USR_DDR_DQS_THD field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_USR_DDR_DQS_THD_Msk = 0x1fc000
	// Position of DQS_LOOP field.
	SPI0_SPI_SMEM_DDR_DQS_LOOP_Pos = 0x15
	// Bit mask of DQS_LOOP field.
	SPI0_SPI_SMEM_DDR_DQS_LOOP_Msk = 0x200000
	// Bit DQS_LOOP.
	SPI0_SPI_SMEM_DDR_DQS_LOOP = 0x200000
	// Position of SPI_SMEM_CLK_DIFF_EN field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_CLK_DIFF_EN_Pos = 0x18
	// Bit mask of SPI_SMEM_CLK_DIFF_EN field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_CLK_DIFF_EN_Msk = 0x1000000
	// Bit SPI_SMEM_CLK_DIFF_EN.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_CLK_DIFF_EN = 0x1000000
	// Position of SPI_SMEM_DQS_CA_IN field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_DQS_CA_IN_Pos = 0x1a
	// Bit mask of SPI_SMEM_DQS_CA_IN field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_DQS_CA_IN_Msk = 0x4000000
	// Bit SPI_SMEM_DQS_CA_IN.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_DQS_CA_IN = 0x4000000
	// Position of SPI_SMEM_HYPERBUS_DUMMY_2X field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_HYPERBUS_DUMMY_2X_Pos = 0x1b
	// Bit mask of SPI_SMEM_HYPERBUS_DUMMY_2X field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_HYPERBUS_DUMMY_2X_Msk = 0x8000000
	// Bit SPI_SMEM_HYPERBUS_DUMMY_2X.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_HYPERBUS_DUMMY_2X = 0x8000000
	// Position of SPI_SMEM_CLK_DIFF_INV field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_CLK_DIFF_INV_Pos = 0x1c
	// Bit mask of SPI_SMEM_CLK_DIFF_INV field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_CLK_DIFF_INV_Msk = 0x10000000
	// Bit SPI_SMEM_CLK_DIFF_INV.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_CLK_DIFF_INV = 0x10000000
	// Position of SPI_SMEM_OCTA_RAM_ADDR field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_OCTA_RAM_ADDR_Pos = 0x1d
	// Bit mask of SPI_SMEM_OCTA_RAM_ADDR field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_OCTA_RAM_ADDR_Msk = 0x20000000
	// Bit SPI_SMEM_OCTA_RAM_ADDR.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_OCTA_RAM_ADDR = 0x20000000
	// Position of SPI_SMEM_HYPERBUS_CA field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_HYPERBUS_CA_Pos = 0x1e
	// Bit mask of SPI_SMEM_HYPERBUS_CA field.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_HYPERBUS_CA_Msk = 0x40000000
	// Bit SPI_SMEM_HYPERBUS_CA.
	SPI0_SPI_SMEM_DDR_SPI_SMEM_HYPERBUS_CA = 0x40000000

	// SPI_FMEM_PMS0_ATTR: MSPI flash ACE section %s attribute register
	// Position of SPI_FMEM_PMS_RD_ATTR field.
	SPI0_SPI_FMEM_PMS_ATTR_SPI_FMEM_PMS_RD_ATTR_Pos = 0x0
	// Bit mask of SPI_FMEM_PMS_RD_ATTR field.
	SPI0_SPI_FMEM_PMS_ATTR_SPI_FMEM_PMS_RD_ATTR_Msk = 0x1
	// Bit SPI_FMEM_PMS_RD_ATTR.
	SPI0_SPI_FMEM_PMS_ATTR_SPI_FMEM_PMS_RD_ATTR = 0x1
	// Position of SPI_FMEM_PMS_WR_ATTR field.
	SPI0_SPI_FMEM_PMS_ATTR_SPI_FMEM_PMS_WR_ATTR_Pos = 0x1
	// Bit mask of SPI_FMEM_PMS_WR_ATTR field.
	SPI0_SPI_FMEM_PMS_ATTR_SPI_FMEM_PMS_WR_ATTR_Msk = 0x2
	// Bit SPI_FMEM_PMS_WR_ATTR.
	SPI0_SPI_FMEM_PMS_ATTR_SPI_FMEM_PMS_WR_ATTR = 0x2
	// Position of SPI_FMEM_PMS_ECC field.
	SPI0_SPI_FMEM_PMS_ATTR_SPI_FMEM_PMS_ECC_Pos = 0x2
	// Bit mask of SPI_FMEM_PMS_ECC field.
	SPI0_SPI_FMEM_PMS_ATTR_SPI_FMEM_PMS_ECC_Msk = 0x4
	// Bit SPI_FMEM_PMS_ECC.
	SPI0_SPI_FMEM_PMS_ATTR_SPI_FMEM_PMS_ECC = 0x4

	// SPI_FMEM_PMS0_ADDR: SPI1 flash ACE section %s start address register
	// Position of S field.
	SPI0_SPI_FMEM_PMS_ADDR_S_Pos = 0x0
	// Bit mask of S field.
	SPI0_SPI_FMEM_PMS_ADDR_S_Msk = 0x3ffffff

	// SPI_FMEM_PMS0_SIZE: SPI1 flash ACE section %s start address register
	// Position of SPI_FMEM_PMS_SIZE field.
	SPI0_SPI_FMEM_PMS_SIZE_SPI_FMEM_PMS_SIZE_Pos = 0x0
	// Bit mask of SPI_FMEM_PMS_SIZE field.
	SPI0_SPI_FMEM_PMS_SIZE_SPI_FMEM_PMS_SIZE_Msk = 0x3fff

	// SPI_SMEM_PMS0_ATTR: SPI1 flash ACE section %s start address register
	// Position of SPI_SMEM_PMS_RD_ATTR field.
	SPI0_SPI_SMEM_PMS_ATTR_SPI_SMEM_PMS_RD_ATTR_Pos = 0x0
	// Bit mask of SPI_SMEM_PMS_RD_ATTR field.
	SPI0_SPI_SMEM_PMS_ATTR_SPI_SMEM_PMS_RD_ATTR_Msk = 0x1
	// Bit SPI_SMEM_PMS_RD_ATTR.
	SPI0_SPI_SMEM_PMS_ATTR_SPI_SMEM_PMS_RD_ATTR = 0x1
	// Position of SPI_SMEM_PMS_WR_ATTR field.
	SPI0_SPI_SMEM_PMS_ATTR_SPI_SMEM_PMS_WR_ATTR_Pos = 0x1
	// Bit mask of SPI_SMEM_PMS_WR_ATTR field.
	SPI0_SPI_SMEM_PMS_ATTR_SPI_SMEM_PMS_WR_ATTR_Msk = 0x2
	// Bit SPI_SMEM_PMS_WR_ATTR.
	SPI0_SPI_SMEM_PMS_ATTR_SPI_SMEM_PMS_WR_ATTR = 0x2
	// Position of SPI_SMEM_PMS_ECC field.
	SPI0_SPI_SMEM_PMS_ATTR_SPI_SMEM_PMS_ECC_Pos = 0x2
	// Bit mask of SPI_SMEM_PMS_ECC field.
	SPI0_SPI_SMEM_PMS_ATTR_SPI_SMEM_PMS_ECC_Msk = 0x4
	// Bit SPI_SMEM_PMS_ECC.
	SPI0_SPI_SMEM_PMS_ATTR_SPI_SMEM_PMS_ECC = 0x4

	// SPI_SMEM_PMS0_ADDR: SPI1 external RAM ACE section %s start address register
	// Position of S field.
	SPI0_SPI_SMEM_PMS_ADDR_S_Pos = 0x0
	// Bit mask of S field.
	SPI0_SPI_SMEM_PMS_ADDR_S_Msk = 0x3ffffff

	// SPI_SMEM_PMS0_SIZE: SPI1 external RAM ACE section %s start address register
	// Position of SPI_SMEM_PMS_SIZE field.
	SPI0_SPI_SMEM_PMS_SIZE_SPI_SMEM_PMS_SIZE_Pos = 0x0
	// Bit mask of SPI_SMEM_PMS_SIZE field.
	SPI0_SPI_SMEM_PMS_SIZE_SPI_SMEM_PMS_SIZE_Msk = 0x3fff

	// SPI_MEM_PMS_REJECT: SPI1 access reject register
	// Position of SPI_MEM_REJECT_ADDR field.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_REJECT_ADDR_Pos = 0x0
	// Bit mask of SPI_MEM_REJECT_ADDR field.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_REJECT_ADDR_Msk = 0x3ffffff
	// Position of SPI_MEM_PM_EN field.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PM_EN_Pos = 0x1a
	// Bit mask of SPI_MEM_PM_EN field.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PM_EN_Msk = 0x4000000
	// Bit SPI_MEM_PM_EN.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PM_EN = 0x4000000
	// Position of SPI_MEM_PMS_LD field.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PMS_LD_Pos = 0x1c
	// Bit mask of SPI_MEM_PMS_LD field.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PMS_LD_Msk = 0x10000000
	// Bit SPI_MEM_PMS_LD.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PMS_LD = 0x10000000
	// Position of SPI_MEM_PMS_ST field.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PMS_ST_Pos = 0x1d
	// Bit mask of SPI_MEM_PMS_ST field.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PMS_ST_Msk = 0x20000000
	// Bit SPI_MEM_PMS_ST.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PMS_ST = 0x20000000
	// Position of SPI_MEM_PMS_MULTI_HIT field.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PMS_MULTI_HIT_Pos = 0x1e
	// Bit mask of SPI_MEM_PMS_MULTI_HIT field.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PMS_MULTI_HIT_Msk = 0x40000000
	// Bit SPI_MEM_PMS_MULTI_HIT.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PMS_MULTI_HIT = 0x40000000
	// Position of SPI_MEM_PMS_IVD field.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PMS_IVD_Pos = 0x1f
	// Bit mask of SPI_MEM_PMS_IVD field.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PMS_IVD_Msk = 0x80000000
	// Bit SPI_MEM_PMS_IVD.
	SPI0_SPI_MEM_PMS_REJECT_SPI_MEM_PMS_IVD = 0x80000000

	// SPI_MEM_ECC_CTRL: MSPI ECC control register
	// Position of SPI_FMEM_ECC_ERR_INT_NUM field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ERR_INT_NUM_Pos = 0xb
	// Bit mask of SPI_FMEM_ECC_ERR_INT_NUM field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ERR_INT_NUM_Msk = 0x1f800
	// Position of SPI_FMEM_ECC_ERR_INT_EN field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ERR_INT_EN_Pos = 0x11
	// Bit mask of SPI_FMEM_ECC_ERR_INT_EN field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ERR_INT_EN_Msk = 0x20000
	// Bit SPI_FMEM_ECC_ERR_INT_EN.
	SPI0_SPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ERR_INT_EN = 0x20000
	// Position of SPI_FMEM_PAGE_SIZE field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_FMEM_PAGE_SIZE_Pos = 0x12
	// Bit mask of SPI_FMEM_PAGE_SIZE field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_FMEM_PAGE_SIZE_Msk = 0xc0000
	// Position of SPI_FMEM_ECC_ADDR_EN field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ADDR_EN_Pos = 0x14
	// Bit mask of SPI_FMEM_ECC_ADDR_EN field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ADDR_EN_Msk = 0x100000
	// Bit SPI_FMEM_ECC_ADDR_EN.
	SPI0_SPI_MEM_ECC_CTRL_SPI_FMEM_ECC_ADDR_EN = 0x100000
	// Position of SPI_MEM_USR_ECC_ADDR_EN field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_MEM_USR_ECC_ADDR_EN_Pos = 0x15
	// Bit mask of SPI_MEM_USR_ECC_ADDR_EN field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_MEM_USR_ECC_ADDR_EN_Msk = 0x200000
	// Bit SPI_MEM_USR_ECC_ADDR_EN.
	SPI0_SPI_MEM_ECC_CTRL_SPI_MEM_USR_ECC_ADDR_EN = 0x200000
	// Position of SPI_MEM_ECC_CONTINUE_RECORD_ERR_EN field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_MEM_ECC_CONTINUE_RECORD_ERR_EN_Pos = 0x18
	// Bit mask of SPI_MEM_ECC_CONTINUE_RECORD_ERR_EN field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_MEM_ECC_CONTINUE_RECORD_ERR_EN_Msk = 0x1000000
	// Bit SPI_MEM_ECC_CONTINUE_RECORD_ERR_EN.
	SPI0_SPI_MEM_ECC_CTRL_SPI_MEM_ECC_CONTINUE_RECORD_ERR_EN = 0x1000000
	// Position of SPI_MEM_ECC_ERR_BITS field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_MEM_ECC_ERR_BITS_Pos = 0x19
	// Bit mask of SPI_MEM_ECC_ERR_BITS field.
	SPI0_SPI_MEM_ECC_CTRL_SPI_MEM_ECC_ERR_BITS_Msk = 0xfe000000

	// SPI_MEM_ECC_ERR_ADDR: MSPI ECC error address register
	// Position of SPI_MEM_ECC_ERR_ADDR field.
	SPI0_SPI_MEM_ECC_ERR_ADDR_SPI_MEM_ECC_ERR_ADDR_Pos = 0x0
	// Bit mask of SPI_MEM_ECC_ERR_ADDR field.
	SPI0_SPI_MEM_ECC_ERR_ADDR_SPI_MEM_ECC_ERR_ADDR_Msk = 0x3ffffff
	// Position of SPI_MEM_ECC_ERR_CNT field.
	SPI0_SPI_MEM_ECC_ERR_ADDR_SPI_MEM_ECC_ERR_CNT_Pos = 0x1a
	// Bit mask of SPI_MEM_ECC_ERR_CNT field.
	SPI0_SPI_MEM_ECC_ERR_ADDR_SPI_MEM_ECC_ERR_CNT_Msk = 0xfc000000

	// SPI_MEM_AXI_ERR_ADDR: SPI0 AXI request error address.
	// Position of SPI_MEM_AXI_ERR_ADDR field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_MEM_AXI_ERR_ADDR_Pos = 0x0
	// Bit mask of SPI_MEM_AXI_ERR_ADDR field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_MEM_AXI_ERR_ADDR_Msk = 0x3ffffff
	// Position of SPI_MEM_ALL_FIFO_EMPTY field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_MEM_ALL_FIFO_EMPTY_Pos = 0x1a
	// Bit mask of SPI_MEM_ALL_FIFO_EMPTY field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_MEM_ALL_FIFO_EMPTY_Msk = 0x4000000
	// Bit SPI_MEM_ALL_FIFO_EMPTY.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_MEM_ALL_FIFO_EMPTY = 0x4000000
	// Position of SPI_RDATA_AFIFO_REMPTY field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_RDATA_AFIFO_REMPTY_Pos = 0x1b
	// Bit mask of SPI_RDATA_AFIFO_REMPTY field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_RDATA_AFIFO_REMPTY_Msk = 0x8000000
	// Bit SPI_RDATA_AFIFO_REMPTY.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_RDATA_AFIFO_REMPTY = 0x8000000
	// Position of SPI_RADDR_AFIFO_REMPTY field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_RADDR_AFIFO_REMPTY_Pos = 0x1c
	// Bit mask of SPI_RADDR_AFIFO_REMPTY field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_RADDR_AFIFO_REMPTY_Msk = 0x10000000
	// Bit SPI_RADDR_AFIFO_REMPTY.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_RADDR_AFIFO_REMPTY = 0x10000000
	// Position of SPI_WDATA_AFIFO_REMPTY field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_WDATA_AFIFO_REMPTY_Pos = 0x1d
	// Bit mask of SPI_WDATA_AFIFO_REMPTY field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_WDATA_AFIFO_REMPTY_Msk = 0x20000000
	// Bit SPI_WDATA_AFIFO_REMPTY.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_WDATA_AFIFO_REMPTY = 0x20000000
	// Position of SPI_WBLEN_AFIFO_REMPTY field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_WBLEN_AFIFO_REMPTY_Pos = 0x1e
	// Bit mask of SPI_WBLEN_AFIFO_REMPTY field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_WBLEN_AFIFO_REMPTY_Msk = 0x40000000
	// Bit SPI_WBLEN_AFIFO_REMPTY.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_WBLEN_AFIFO_REMPTY = 0x40000000
	// Position of SPI_ALL_AXI_TRANS_AFIFO_EMPTY field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_ALL_AXI_TRANS_AFIFO_EMPTY_Pos = 0x1f
	// Bit mask of SPI_ALL_AXI_TRANS_AFIFO_EMPTY field.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_ALL_AXI_TRANS_AFIFO_EMPTY_Msk = 0x80000000
	// Bit SPI_ALL_AXI_TRANS_AFIFO_EMPTY.
	SPI0_SPI_MEM_AXI_ERR_ADDR_SPI_ALL_AXI_TRANS_AFIFO_EMPTY = 0x80000000

	// SPI_SMEM_ECC_CTRL: MSPI ECC control register
	// Position of SPI_SMEM_ECC_ERR_INT_EN field.
	SPI0_SPI_SMEM_ECC_CTRL_SPI_SMEM_ECC_ERR_INT_EN_Pos = 0x11
	// Bit mask of SPI_SMEM_ECC_ERR_INT_EN field.
	SPI0_SPI_SMEM_ECC_CTRL_SPI_SMEM_ECC_ERR_INT_EN_Msk = 0x20000
	// Bit SPI_SMEM_ECC_ERR_INT_EN.
	SPI0_SPI_SMEM_ECC_CTRL_SPI_SMEM_ECC_ERR_INT_EN = 0x20000
	// Position of SPI_SMEM_PAGE_SIZE field.
	SPI0_SPI_SMEM_ECC_CTRL_SPI_SMEM_PAGE_SIZE_Pos = 0x12
	// Bit mask of SPI_SMEM_PAGE_SIZE field.
	SPI0_SPI_SMEM_ECC_CTRL_SPI_SMEM_PAGE_SIZE_Msk = 0xc0000
	// Position of SPI_SMEM_ECC_ADDR_EN field.
	SPI0_SPI_SMEM_ECC_CTRL_SPI_SMEM_ECC_ADDR_EN_Pos = 0x14
	// Bit mask of SPI_SMEM_ECC_ADDR_EN field.
	SPI0_SPI_SMEM_ECC_CTRL_SPI_SMEM_ECC_ADDR_EN_Msk = 0x100000
	// Bit SPI_SMEM_ECC_ADDR_EN.
	SPI0_SPI_SMEM_ECC_CTRL_SPI_SMEM_ECC_ADDR_EN = 0x100000

	// SPI_MEM_TIMING_CALI: SPI0 flash timing calibration register
	// Position of SPI_MEM_TIMING_CLK_ENA field.
	SPI0_SPI_MEM_TIMING_CALI_SPI_MEM_TIMING_CLK_ENA_Pos = 0x0
	// Bit mask of SPI_MEM_TIMING_CLK_ENA field.
	SPI0_SPI_MEM_TIMING_CALI_SPI_MEM_TIMING_CLK_ENA_Msk = 0x1
	// Bit SPI_MEM_TIMING_CLK_ENA.
	SPI0_SPI_MEM_TIMING_CALI_SPI_MEM_TIMING_CLK_ENA = 0x1
	// Position of SPI_MEM_TIMING_CALI field.
	SPI0_SPI_MEM_TIMING_CALI_SPI_MEM_TIMING_CALI_Pos = 0x1
	// Bit mask of SPI_MEM_TIMING_CALI field.
	SPI0_SPI_MEM_TIMING_CALI_SPI_MEM_TIMING_CALI_Msk = 0x2
	// Bit SPI_MEM_TIMING_CALI.
	SPI0_SPI_MEM_TIMING_CALI_SPI_MEM_TIMING_CALI = 0x2
	// Position of SPI_MEM_EXTRA_DUMMY_CYCLELEN field.
	SPI0_SPI_MEM_TIMING_CALI_SPI_MEM_EXTRA_DUMMY_CYCLELEN_Pos = 0x2
	// Bit mask of SPI_MEM_EXTRA_DUMMY_CYCLELEN field.
	SPI0_SPI_MEM_TIMING_CALI_SPI_MEM_EXTRA_DUMMY_CYCLELEN_Msk = 0x1c
	// Position of SPI_MEM_DLL_TIMING_CALI field.
	SPI0_SPI_MEM_TIMING_CALI_SPI_MEM_DLL_TIMING_CALI_Pos = 0x5
	// Bit mask of SPI_MEM_DLL_TIMING_CALI field.
	SPI0_SPI_MEM_TIMING_CALI_SPI_MEM_DLL_TIMING_CALI_Msk = 0x20
	// Bit SPI_MEM_DLL_TIMING_CALI.
	SPI0_SPI_MEM_TIMING_CALI_SPI_MEM_DLL_TIMING_CALI = 0x20
	// Position of UPDATE field.
	SPI0_SPI_MEM_TIMING_CALI_UPDATE_Pos = 0x6
	// Bit mask of UPDATE field.
	SPI0_SPI_MEM_TIMING_CALI_UPDATE_Msk = 0x40
	// Bit UPDATE.
	SPI0_SPI_MEM_TIMING_CALI_UPDATE = 0x40

	// SPI_MEM_DIN_MODE: MSPI flash input timing delay mode control register
	// Position of SPI_MEM_DIN0_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN0_MODE_Pos = 0x0
	// Bit mask of SPI_MEM_DIN0_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN0_MODE_Msk = 0x7
	// Position of SPI_MEM_DIN1_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN1_MODE_Pos = 0x3
	// Bit mask of SPI_MEM_DIN1_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN1_MODE_Msk = 0x38
	// Position of SPI_MEM_DIN2_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN2_MODE_Pos = 0x6
	// Bit mask of SPI_MEM_DIN2_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN2_MODE_Msk = 0x1c0
	// Position of SPI_MEM_DIN3_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN3_MODE_Pos = 0x9
	// Bit mask of SPI_MEM_DIN3_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN3_MODE_Msk = 0xe00
	// Position of SPI_MEM_DIN4_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN4_MODE_Pos = 0xc
	// Bit mask of SPI_MEM_DIN4_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN4_MODE_Msk = 0x7000
	// Position of SPI_MEM_DIN5_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN5_MODE_Pos = 0xf
	// Bit mask of SPI_MEM_DIN5_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN5_MODE_Msk = 0x38000
	// Position of SPI_MEM_DIN6_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN6_MODE_Pos = 0x12
	// Bit mask of SPI_MEM_DIN6_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN6_MODE_Msk = 0x1c0000
	// Position of SPI_MEM_DIN7_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN7_MODE_Pos = 0x15
	// Bit mask of SPI_MEM_DIN7_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DIN7_MODE_Msk = 0xe00000
	// Position of SPI_MEM_DINS_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DINS_MODE_Pos = 0x18
	// Bit mask of SPI_MEM_DINS_MODE field.
	SPI0_SPI_MEM_DIN_MODE_SPI_MEM_DINS_MODE_Msk = 0x7000000

	// SPI_MEM_DIN_NUM: MSPI flash input timing delay number control register
	// Position of SPI_MEM_DIN0_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN0_NUM_Pos = 0x0
	// Bit mask of SPI_MEM_DIN0_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN0_NUM_Msk = 0x3
	// Position of SPI_MEM_DIN1_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN1_NUM_Pos = 0x2
	// Bit mask of SPI_MEM_DIN1_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN1_NUM_Msk = 0xc
	// Position of SPI_MEM_DIN2_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN2_NUM_Pos = 0x4
	// Bit mask of SPI_MEM_DIN2_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN2_NUM_Msk = 0x30
	// Position of SPI_MEM_DIN3_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN3_NUM_Pos = 0x6
	// Bit mask of SPI_MEM_DIN3_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN3_NUM_Msk = 0xc0
	// Position of SPI_MEM_DIN4_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN4_NUM_Pos = 0x8
	// Bit mask of SPI_MEM_DIN4_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN4_NUM_Msk = 0x300
	// Position of SPI_MEM_DIN5_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN5_NUM_Pos = 0xa
	// Bit mask of SPI_MEM_DIN5_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN5_NUM_Msk = 0xc00
	// Position of SPI_MEM_DIN6_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN6_NUM_Pos = 0xc
	// Bit mask of SPI_MEM_DIN6_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN6_NUM_Msk = 0x3000
	// Position of SPI_MEM_DIN7_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN7_NUM_Pos = 0xe
	// Bit mask of SPI_MEM_DIN7_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DIN7_NUM_Msk = 0xc000
	// Position of SPI_MEM_DINS_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DINS_NUM_Pos = 0x10
	// Bit mask of SPI_MEM_DINS_NUM field.
	SPI0_SPI_MEM_DIN_NUM_SPI_MEM_DINS_NUM_Msk = 0x30000

	// SPI_MEM_DOUT_MODE: MSPI flash output timing adjustment control register
	// Position of SPI_MEM_DOUT0_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT0_MODE_Pos = 0x0
	// Bit mask of SPI_MEM_DOUT0_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT0_MODE_Msk = 0x1
	// Bit SPI_MEM_DOUT0_MODE.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT0_MODE = 0x1
	// Position of SPI_MEM_DOUT1_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT1_MODE_Pos = 0x1
	// Bit mask of SPI_MEM_DOUT1_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT1_MODE_Msk = 0x2
	// Bit SPI_MEM_DOUT1_MODE.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT1_MODE = 0x2
	// Position of SPI_MEM_DOUT2_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT2_MODE_Pos = 0x2
	// Bit mask of SPI_MEM_DOUT2_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT2_MODE_Msk = 0x4
	// Bit SPI_MEM_DOUT2_MODE.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT2_MODE = 0x4
	// Position of SPI_MEM_DOUT3_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT3_MODE_Pos = 0x3
	// Bit mask of SPI_MEM_DOUT3_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT3_MODE_Msk = 0x8
	// Bit SPI_MEM_DOUT3_MODE.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT3_MODE = 0x8
	// Position of SPI_MEM_DOUT4_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT4_MODE_Pos = 0x4
	// Bit mask of SPI_MEM_DOUT4_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT4_MODE_Msk = 0x10
	// Bit SPI_MEM_DOUT4_MODE.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT4_MODE = 0x10
	// Position of SPI_MEM_DOUT5_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT5_MODE_Pos = 0x5
	// Bit mask of SPI_MEM_DOUT5_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT5_MODE_Msk = 0x20
	// Bit SPI_MEM_DOUT5_MODE.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT5_MODE = 0x20
	// Position of SPI_MEM_DOUT6_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT6_MODE_Pos = 0x6
	// Bit mask of SPI_MEM_DOUT6_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT6_MODE_Msk = 0x40
	// Bit SPI_MEM_DOUT6_MODE.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT6_MODE = 0x40
	// Position of SPI_MEM_DOUT7_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT7_MODE_Pos = 0x7
	// Bit mask of SPI_MEM_DOUT7_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT7_MODE_Msk = 0x80
	// Bit SPI_MEM_DOUT7_MODE.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUT7_MODE = 0x80
	// Position of SPI_MEM_DOUTS_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUTS_MODE_Pos = 0x8
	// Bit mask of SPI_MEM_DOUTS_MODE field.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUTS_MODE_Msk = 0x100
	// Bit SPI_MEM_DOUTS_MODE.
	SPI0_SPI_MEM_DOUT_MODE_SPI_MEM_DOUTS_MODE = 0x100

	// SPI_SMEM_TIMING_CALI: MSPI external RAM timing calibration register
	// Position of SPI_SMEM_TIMING_CLK_ENA field.
	SPI0_SPI_SMEM_TIMING_CALI_SPI_SMEM_TIMING_CLK_ENA_Pos = 0x0
	// Bit mask of SPI_SMEM_TIMING_CLK_ENA field.
	SPI0_SPI_SMEM_TIMING_CALI_SPI_SMEM_TIMING_CLK_ENA_Msk = 0x1
	// Bit SPI_SMEM_TIMING_CLK_ENA.
	SPI0_SPI_SMEM_TIMING_CALI_SPI_SMEM_TIMING_CLK_ENA = 0x1
	// Position of SPI_SMEM_TIMING_CALI field.
	SPI0_SPI_SMEM_TIMING_CALI_SPI_SMEM_TIMING_CALI_Pos = 0x1
	// Bit mask of SPI_SMEM_TIMING_CALI field.
	SPI0_SPI_SMEM_TIMING_CALI_SPI_SMEM_TIMING_CALI_Msk = 0x2
	// Bit SPI_SMEM_TIMING_CALI.
	SPI0_SPI_SMEM_TIMING_CALI_SPI_SMEM_TIMING_CALI = 0x2
	// Position of SPI_SMEM_EXTRA_DUMMY_CYCLELEN field.
	SPI0_SPI_SMEM_TIMING_CALI_SPI_SMEM_EXTRA_DUMMY_CYCLELEN_Pos = 0x2
	// Bit mask of SPI_SMEM_EXTRA_DUMMY_CYCLELEN field.
	SPI0_SPI_SMEM_TIMING_CALI_SPI_SMEM_EXTRA_DUMMY_CYCLELEN_Msk = 0x1c
	// Position of SPI_SMEM_DLL_TIMING_CALI field.
	SPI0_SPI_SMEM_TIMING_CALI_SPI_SMEM_DLL_TIMING_CALI_Pos = 0x5
	// Bit mask of SPI_SMEM_DLL_TIMING_CALI field.
	SPI0_SPI_SMEM_TIMING_CALI_SPI_SMEM_DLL_TIMING_CALI_Msk = 0x20
	// Bit SPI_SMEM_DLL_TIMING_CALI.
	SPI0_SPI_SMEM_TIMING_CALI_SPI_SMEM_DLL_TIMING_CALI = 0x20

	// SPI_SMEM_DIN_MODE: MSPI external RAM input timing delay mode control register
	// Position of SPI_SMEM_DIN0_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN0_MODE_Pos = 0x0
	// Bit mask of SPI_SMEM_DIN0_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN0_MODE_Msk = 0x7
	// Position of SPI_SMEM_DIN1_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN1_MODE_Pos = 0x3
	// Bit mask of SPI_SMEM_DIN1_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN1_MODE_Msk = 0x38
	// Position of SPI_SMEM_DIN2_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN2_MODE_Pos = 0x6
	// Bit mask of SPI_SMEM_DIN2_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN2_MODE_Msk = 0x1c0
	// Position of SPI_SMEM_DIN3_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN3_MODE_Pos = 0x9
	// Bit mask of SPI_SMEM_DIN3_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN3_MODE_Msk = 0xe00
	// Position of SPI_SMEM_DIN4_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN4_MODE_Pos = 0xc
	// Bit mask of SPI_SMEM_DIN4_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN4_MODE_Msk = 0x7000
	// Position of SPI_SMEM_DIN5_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN5_MODE_Pos = 0xf
	// Bit mask of SPI_SMEM_DIN5_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN5_MODE_Msk = 0x38000
	// Position of SPI_SMEM_DIN6_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN6_MODE_Pos = 0x12
	// Bit mask of SPI_SMEM_DIN6_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN6_MODE_Msk = 0x1c0000
	// Position of SPI_SMEM_DIN7_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN7_MODE_Pos = 0x15
	// Bit mask of SPI_SMEM_DIN7_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DIN7_MODE_Msk = 0xe00000
	// Position of SPI_SMEM_DINS_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DINS_MODE_Pos = 0x18
	// Bit mask of SPI_SMEM_DINS_MODE field.
	SPI0_SPI_SMEM_DIN_MODE_SPI_SMEM_DINS_MODE_Msk = 0x7000000

	// SPI_SMEM_DIN_NUM: MSPI external RAM input timing delay number control register
	// Position of SPI_SMEM_DIN0_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN0_NUM_Pos = 0x0
	// Bit mask of SPI_SMEM_DIN0_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN0_NUM_Msk = 0x3
	// Position of SPI_SMEM_DIN1_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN1_NUM_Pos = 0x2
	// Bit mask of SPI_SMEM_DIN1_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN1_NUM_Msk = 0xc
	// Position of SPI_SMEM_DIN2_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN2_NUM_Pos = 0x4
	// Bit mask of SPI_SMEM_DIN2_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN2_NUM_Msk = 0x30
	// Position of SPI_SMEM_DIN3_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN3_NUM_Pos = 0x6
	// Bit mask of SPI_SMEM_DIN3_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN3_NUM_Msk = 0xc0
	// Position of SPI_SMEM_DIN4_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN4_NUM_Pos = 0x8
	// Bit mask of SPI_SMEM_DIN4_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN4_NUM_Msk = 0x300
	// Position of SPI_SMEM_DIN5_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN5_NUM_Pos = 0xa
	// Bit mask of SPI_SMEM_DIN5_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN5_NUM_Msk = 0xc00
	// Position of SPI_SMEM_DIN6_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN6_NUM_Pos = 0xc
	// Bit mask of SPI_SMEM_DIN6_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN6_NUM_Msk = 0x3000
	// Position of SPI_SMEM_DIN7_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN7_NUM_Pos = 0xe
	// Bit mask of SPI_SMEM_DIN7_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DIN7_NUM_Msk = 0xc000
	// Position of SPI_SMEM_DINS_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DINS_NUM_Pos = 0x10
	// Bit mask of SPI_SMEM_DINS_NUM field.
	SPI0_SPI_SMEM_DIN_NUM_SPI_SMEM_DINS_NUM_Msk = 0x30000

	// SPI_SMEM_DOUT_MODE: MSPI external RAM output timing adjustment control register
	// Position of SPI_SMEM_DOUT0_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT0_MODE_Pos = 0x0
	// Bit mask of SPI_SMEM_DOUT0_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT0_MODE_Msk = 0x1
	// Bit SPI_SMEM_DOUT0_MODE.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT0_MODE = 0x1
	// Position of SPI_SMEM_DOUT1_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT1_MODE_Pos = 0x1
	// Bit mask of SPI_SMEM_DOUT1_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT1_MODE_Msk = 0x2
	// Bit SPI_SMEM_DOUT1_MODE.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT1_MODE = 0x2
	// Position of SPI_SMEM_DOUT2_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT2_MODE_Pos = 0x2
	// Bit mask of SPI_SMEM_DOUT2_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT2_MODE_Msk = 0x4
	// Bit SPI_SMEM_DOUT2_MODE.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT2_MODE = 0x4
	// Position of SPI_SMEM_DOUT3_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT3_MODE_Pos = 0x3
	// Bit mask of SPI_SMEM_DOUT3_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT3_MODE_Msk = 0x8
	// Bit SPI_SMEM_DOUT3_MODE.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT3_MODE = 0x8
	// Position of SPI_SMEM_DOUT4_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT4_MODE_Pos = 0x4
	// Bit mask of SPI_SMEM_DOUT4_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT4_MODE_Msk = 0x10
	// Bit SPI_SMEM_DOUT4_MODE.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT4_MODE = 0x10
	// Position of SPI_SMEM_DOUT5_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT5_MODE_Pos = 0x5
	// Bit mask of SPI_SMEM_DOUT5_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT5_MODE_Msk = 0x20
	// Bit SPI_SMEM_DOUT5_MODE.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT5_MODE = 0x20
	// Position of SPI_SMEM_DOUT6_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT6_MODE_Pos = 0x6
	// Bit mask of SPI_SMEM_DOUT6_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT6_MODE_Msk = 0x40
	// Bit SPI_SMEM_DOUT6_MODE.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT6_MODE = 0x40
	// Position of SPI_SMEM_DOUT7_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT7_MODE_Pos = 0x7
	// Bit mask of SPI_SMEM_DOUT7_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT7_MODE_Msk = 0x80
	// Bit SPI_SMEM_DOUT7_MODE.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUT7_MODE = 0x80
	// Position of SPI_SMEM_DOUTS_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUTS_MODE_Pos = 0x8
	// Bit mask of SPI_SMEM_DOUTS_MODE field.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUTS_MODE_Msk = 0x100
	// Bit SPI_SMEM_DOUTS_MODE.
	SPI0_SPI_SMEM_DOUT_MODE_SPI_SMEM_DOUTS_MODE = 0x100

	// SPI_SMEM_AC: MSPI external RAM ECC and SPI CS timing control register
	// Position of SPI_SMEM_CS_SETUP field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_CS_SETUP_Pos = 0x0
	// Bit mask of SPI_SMEM_CS_SETUP field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_CS_SETUP_Msk = 0x1
	// Bit SPI_SMEM_CS_SETUP.
	SPI0_SPI_SMEM_AC_SPI_SMEM_CS_SETUP = 0x1
	// Position of SPI_SMEM_CS_HOLD field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_CS_HOLD_Pos = 0x1
	// Bit mask of SPI_SMEM_CS_HOLD field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_CS_HOLD_Msk = 0x2
	// Bit SPI_SMEM_CS_HOLD.
	SPI0_SPI_SMEM_AC_SPI_SMEM_CS_HOLD = 0x2
	// Position of SPI_SMEM_CS_SETUP_TIME field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_CS_SETUP_TIME_Pos = 0x2
	// Bit mask of SPI_SMEM_CS_SETUP_TIME field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_CS_SETUP_TIME_Msk = 0x7c
	// Position of SPI_SMEM_CS_HOLD_TIME field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_CS_HOLD_TIME_Pos = 0x7
	// Bit mask of SPI_SMEM_CS_HOLD_TIME field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_CS_HOLD_TIME_Msk = 0xf80
	// Position of SPI_SMEM_ECC_CS_HOLD_TIME field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_ECC_CS_HOLD_TIME_Pos = 0xc
	// Bit mask of SPI_SMEM_ECC_CS_HOLD_TIME field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_ECC_CS_HOLD_TIME_Msk = 0x7000
	// Position of SPI_SMEM_ECC_SKIP_PAGE_CORNER field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_ECC_SKIP_PAGE_CORNER_Pos = 0xf
	// Bit mask of SPI_SMEM_ECC_SKIP_PAGE_CORNER field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_ECC_SKIP_PAGE_CORNER_Msk = 0x8000
	// Bit SPI_SMEM_ECC_SKIP_PAGE_CORNER.
	SPI0_SPI_SMEM_AC_SPI_SMEM_ECC_SKIP_PAGE_CORNER = 0x8000
	// Position of SPI_SMEM_ECC_16TO18_BYTE_EN field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_ECC_16TO18_BYTE_EN_Pos = 0x10
	// Bit mask of SPI_SMEM_ECC_16TO18_BYTE_EN field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_ECC_16TO18_BYTE_EN_Msk = 0x10000
	// Bit SPI_SMEM_ECC_16TO18_BYTE_EN.
	SPI0_SPI_SMEM_AC_SPI_SMEM_ECC_16TO18_BYTE_EN = 0x10000
	// Position of SPI_SMEM_CS_HOLD_DELAY field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_CS_HOLD_DELAY_Pos = 0x19
	// Bit mask of SPI_SMEM_CS_HOLD_DELAY field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_CS_HOLD_DELAY_Msk = 0x7e000000
	// Position of SPI_SMEM_SPLIT_TRANS_EN field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_SPLIT_TRANS_EN_Pos = 0x1f
	// Bit mask of SPI_SMEM_SPLIT_TRANS_EN field.
	SPI0_SPI_SMEM_AC_SPI_SMEM_SPLIT_TRANS_EN_Msk = 0x80000000
	// Bit SPI_SMEM_SPLIT_TRANS_EN.
	SPI0_SPI_SMEM_AC_SPI_SMEM_SPLIT_TRANS_EN = 0x80000000

	// SPI_MEM_CLOCK_GATE: SPI0 clock gate register
	// Position of SPI_CLK_EN field.
	SPI0_SPI_MEM_CLOCK_GATE_SPI_CLK_EN_Pos = 0x0
	// Bit mask of SPI_CLK_EN field.
	SPI0_SPI_MEM_CLOCK_GATE_SPI_CLK_EN_Msk = 0x1
	// Bit SPI_CLK_EN.
	SPI0_SPI_MEM_CLOCK_GATE_SPI_CLK_EN = 0x1

	// SPI_MEM_XTS_PLAIN_BASE: The base address of the memory that stores plaintext in Manual Encryption
	// Position of SPI_XTS_PLAIN field.
	SPI0_SPI_MEM_XTS_PLAIN_BASE_SPI_XTS_PLAIN_Pos = 0x0
	// Bit mask of SPI_XTS_PLAIN field.
	SPI0_SPI_MEM_XTS_PLAIN_BASE_SPI_XTS_PLAIN_Msk = 0xffffffff

	// SPI_MEM_XTS_LINESIZE: Manual Encryption Line-Size register
	// Position of SPI_XTS_LINESIZE field.
	SPI0_SPI_MEM_XTS_LINESIZE_SPI_XTS_LINESIZE_Pos = 0x0
	// Bit mask of SPI_XTS_LINESIZE field.
	SPI0_SPI_MEM_XTS_LINESIZE_SPI_XTS_LINESIZE_Msk = 0x3

	// SPI_MEM_XTS_DESTINATION: Manual Encryption destination register
	// Position of SPI_XTS_DESTINATION field.
	SPI0_SPI_MEM_XTS_DESTINATION_SPI_XTS_DESTINATION_Pos = 0x0
	// Bit mask of SPI_XTS_DESTINATION field.
	SPI0_SPI_MEM_XTS_DESTINATION_SPI_XTS_DESTINATION_Msk = 0x1
	// Bit SPI_XTS_DESTINATION.
	SPI0_SPI_MEM_XTS_DESTINATION_SPI_XTS_DESTINATION = 0x1

	// SPI_MEM_XTS_PHYSICAL_ADDRESS: Manual Encryption physical address register
	// Position of SPI_XTS_PHYSICAL_ADDRESS field.
	SPI0_SPI_MEM_XTS_PHYSICAL_ADDRESS_SPI_XTS_PHYSICAL_ADDRESS_Pos = 0x0
	// Bit mask of SPI_XTS_PHYSICAL_ADDRESS field.
	SPI0_SPI_MEM_XTS_PHYSICAL_ADDRESS_SPI_XTS_PHYSICAL_ADDRESS_Msk = 0x3ffffff

	// SPI_MEM_XTS_TRIGGER: Manual Encryption physical address register
	// Position of SPI_XTS_TRIGGER field.
	SPI0_SPI_MEM_XTS_TRIGGER_SPI_XTS_TRIGGER_Pos = 0x0
	// Bit mask of SPI_XTS_TRIGGER field.
	SPI0_SPI_MEM_XTS_TRIGGER_SPI_XTS_TRIGGER_Msk = 0x1
	// Bit SPI_XTS_TRIGGER.
	SPI0_SPI_MEM_XTS_TRIGGER_SPI_XTS_TRIGGER = 0x1

	// SPI_MEM_XTS_RELEASE: Manual Encryption physical address register
	// Position of SPI_XTS_RELEASE field.
	SPI0_SPI_MEM_XTS_RELEASE_SPI_XTS_RELEASE_Pos = 0x0
	// Bit mask of SPI_XTS_RELEASE field.
	SPI0_SPI_MEM_XTS_RELEASE_SPI_XTS_RELEASE_Msk = 0x1
	// Bit SPI_XTS_RELEASE.
	SPI0_SPI_MEM_XTS_RELEASE_SPI_XTS_RELEASE = 0x1

	// SPI_MEM_XTS_DESTROY: Manual Encryption physical address register
	// Position of SPI_XTS_DESTROY field.
	SPI0_SPI_MEM_XTS_DESTROY_SPI_XTS_DESTROY_Pos = 0x0
	// Bit mask of SPI_XTS_DESTROY field.
	SPI0_SPI_MEM_XTS_DESTROY_SPI_XTS_DESTROY_Msk = 0x1
	// Bit SPI_XTS_DESTROY.
	SPI0_SPI_MEM_XTS_DESTROY_SPI_XTS_DESTROY = 0x1

	// SPI_MEM_XTS_STATE: Manual Encryption physical address register
	// Position of SPI_XTS_STATE field.
	SPI0_SPI_MEM_XTS_STATE_SPI_XTS_STATE_Pos = 0x0
	// Bit mask of SPI_XTS_STATE field.
	SPI0_SPI_MEM_XTS_STATE_SPI_XTS_STATE_Msk = 0x3

	// SPI_MEM_XTS_DATE: Manual Encryption version register
	// Position of SPI_XTS_DATE field.
	SPI0_SPI_MEM_XTS_DATE_SPI_XTS_DATE_Pos = 0x0
	// Bit mask of SPI_XTS_DATE field.
	SPI0_SPI_MEM_XTS_DATE_SPI_XTS_DATE_Msk = 0x3fffffff

	// SPI_MEM_MMU_ITEM_CONTENT: MSPI-MMU item content register
	// Position of SPI_MMU_ITEM_CONTENT field.
	SPI0_SPI_MEM_MMU_ITEM_CONTENT_SPI_MMU_ITEM_CONTENT_Pos = 0x0
	// Bit mask of SPI_MMU_ITEM_CONTENT field.
	SPI0_SPI_MEM_MMU_ITEM_CONTENT_SPI_MMU_ITEM_CONTENT_Msk = 0xffffffff

	// SPI_MEM_MMU_ITEM_INDEX: MSPI-MMU item index register
	// Position of SPI_MMU_ITEM_INDEX field.
	SPI0_SPI_MEM_MMU_ITEM_INDEX_SPI_MMU_ITEM_INDEX_Pos = 0x0
	// Bit mask of SPI_MMU_ITEM_INDEX field.
	SPI0_SPI_MEM_MMU_ITEM_INDEX_SPI_MMU_ITEM_INDEX_Msk = 0xffffffff

	// SPI_MEM_MMU_POWER_CTRL: MSPI MMU power control register
	// Position of SPI_MMU_MEM_FORCE_ON field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_ON_Pos = 0x0
	// Bit mask of SPI_MMU_MEM_FORCE_ON field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_ON_Msk = 0x1
	// Bit SPI_MMU_MEM_FORCE_ON.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_ON = 0x1
	// Position of SPI_MMU_MEM_FORCE_PD field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_PD_Pos = 0x1
	// Bit mask of SPI_MMU_MEM_FORCE_PD field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_PD_Msk = 0x2
	// Bit SPI_MMU_MEM_FORCE_PD.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_PD = 0x2
	// Position of SPI_MMU_MEM_FORCE_PU field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_PU_Pos = 0x2
	// Bit mask of SPI_MMU_MEM_FORCE_PU field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_PU_Msk = 0x4
	// Bit SPI_MMU_MEM_FORCE_PU.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MMU_MEM_FORCE_PU = 0x4
	// Position of SPI_MMU_PAGE_SIZE field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MMU_PAGE_SIZE_Pos = 0x3
	// Bit mask of SPI_MMU_PAGE_SIZE field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MMU_PAGE_SIZE_Msk = 0x18
	// Position of SPI_MEM_AUX_CTRL field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MEM_AUX_CTRL_Pos = 0x10
	// Bit mask of SPI_MEM_AUX_CTRL field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MEM_AUX_CTRL_Msk = 0x3fff0000
	// Position of SPI_MEM_RDN_ENA field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MEM_RDN_ENA_Pos = 0x1e
	// Bit mask of SPI_MEM_RDN_ENA field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MEM_RDN_ENA_Msk = 0x40000000
	// Bit SPI_MEM_RDN_ENA.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MEM_RDN_ENA = 0x40000000
	// Position of SPI_MEM_RDN_RESULT field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MEM_RDN_RESULT_Pos = 0x1f
	// Bit mask of SPI_MEM_RDN_RESULT field.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MEM_RDN_RESULT_Msk = 0x80000000
	// Bit SPI_MEM_RDN_RESULT.
	SPI0_SPI_MEM_MMU_POWER_CTRL_SPI_MEM_RDN_RESULT = 0x80000000

	// SPI_MEM_DPA_CTRL: SPI memory cryption DPA register
	// Position of SPI_CRYPT_SECURITY_LEVEL field.
	SPI0_SPI_MEM_DPA_CTRL_SPI_CRYPT_SECURITY_LEVEL_Pos = 0x0
	// Bit mask of SPI_CRYPT_SECURITY_LEVEL field.
	SPI0_SPI_MEM_DPA_CTRL_SPI_CRYPT_SECURITY_LEVEL_Msk = 0x7
	// Position of SPI_CRYPT_CALC_D_DPA_EN field.
	SPI0_SPI_MEM_DPA_CTRL_SPI_CRYPT_CALC_D_DPA_EN_Pos = 0x3
	// Bit mask of SPI_CRYPT_CALC_D_DPA_EN field.
	SPI0_SPI_MEM_DPA_CTRL_SPI_CRYPT_CALC_D_DPA_EN_Msk = 0x8
	// Bit SPI_CRYPT_CALC_D_DPA_EN.
	SPI0_SPI_MEM_DPA_CTRL_SPI_CRYPT_CALC_D_DPA_EN = 0x8
	// Position of SPI_CRYPT_DPA_SELECT_REGISTER field.
	SPI0_SPI_MEM_DPA_CTRL_SPI_CRYPT_DPA_SELECT_REGISTER_Pos = 0x4
	// Bit mask of SPI_CRYPT_DPA_SELECT_REGISTER field.
	SPI0_SPI_MEM_DPA_CTRL_SPI_CRYPT_DPA_SELECT_REGISTER_Msk = 0x10
	// Bit SPI_CRYPT_DPA_SELECT_REGISTER.
	SPI0_SPI_MEM_DPA_CTRL_SPI_CRYPT_DPA_SELECT_REGISTER = 0x10

	// SPI_MEM_REGISTERRND_ECO_HIGH: MSPI ECO high register
	// Position of SPI_MEM_REGISTERRND_ECO_HIGH field.
	SPI0_SPI_MEM_REGISTERRND_ECO_HIGH_SPI_MEM_REGISTERRND_ECO_HIGH_Pos = 0x0
	// Bit mask of SPI_MEM_REGISTERRND_ECO_HIGH field.
	SPI0_SPI_MEM_REGISTERRND_ECO_HIGH_SPI_MEM_REGISTERRND_ECO_HIGH_Msk = 0xffffffff

	// SPI_MEM_REGISTERRND_ECO_LOW: MSPI ECO low register
	// Position of SPI_MEM_REGISTERRND_ECO_LOW field.
	SPI0_SPI_MEM_REGISTERRND_ECO_LOW_SPI_MEM_REGISTERRND_ECO_LOW_Pos = 0x0
	// Bit mask of SPI_MEM_REGISTERRND_ECO_LOW field.
	SPI0_SPI_MEM_REGISTERRND_ECO_LOW_SPI_MEM_REGISTERRND_ECO_LOW_Msk = 0xffffffff

	// SPI_MEM_DATE: SPI0 version control register
	// Position of SPI_MEM_DATE field.
	SPI0_SPI_MEM_DATE_SPI_MEM_DATE_Pos = 0x0
	// Bit mask of SPI_MEM_DATE field.
	SPI0_SPI_MEM_DATE_SPI_MEM_DATE_Msk = 0xfffffff
)

// Constants for SPI1: SPI (Serial Peripheral Interface) Controller 1
const (
	// SPI_MEM_CMD: SPI1 memory command register
	// Position of SPI_MEM_MST_ST field.
	SPI1_SPI_MEM_CMD_SPI_MEM_MST_ST_Pos = 0x0
	// Bit mask of SPI_MEM_MST_ST field.
	SPI1_SPI_MEM_CMD_SPI_MEM_MST_ST_Msk = 0xf
	// Position of SPI_MEM_SLV_ST field.
	SPI1_SPI_MEM_CMD_SPI_MEM_SLV_ST_Pos = 0x4
	// Bit mask of SPI_MEM_SLV_ST field.
	SPI1_SPI_MEM_CMD_SPI_MEM_SLV_ST_Msk = 0xf0
	// Position of SPI_MEM_FLASH_PE field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_PE_Pos = 0x11
	// Bit mask of SPI_MEM_FLASH_PE field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_PE_Msk = 0x20000
	// Bit SPI_MEM_FLASH_PE.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_PE = 0x20000
	// Position of SPI_MEM_USR field.
	SPI1_SPI_MEM_CMD_SPI_MEM_USR_Pos = 0x12
	// Bit mask of SPI_MEM_USR field.
	SPI1_SPI_MEM_CMD_SPI_MEM_USR_Msk = 0x40000
	// Bit SPI_MEM_USR.
	SPI1_SPI_MEM_CMD_SPI_MEM_USR = 0x40000
	// Position of SPI_MEM_FLASH_HPM field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_HPM_Pos = 0x13
	// Bit mask of SPI_MEM_FLASH_HPM field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_HPM_Msk = 0x80000
	// Bit SPI_MEM_FLASH_HPM.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_HPM = 0x80000
	// Position of SPI_MEM_FLASH_RES field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_RES_Pos = 0x14
	// Bit mask of SPI_MEM_FLASH_RES field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_RES_Msk = 0x100000
	// Bit SPI_MEM_FLASH_RES.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_RES = 0x100000
	// Position of SPI_MEM_FLASH_DP field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_DP_Pos = 0x15
	// Bit mask of SPI_MEM_FLASH_DP field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_DP_Msk = 0x200000
	// Bit SPI_MEM_FLASH_DP.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_DP = 0x200000
	// Position of SPI_MEM_FLASH_CE field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_CE_Pos = 0x16
	// Bit mask of SPI_MEM_FLASH_CE field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_CE_Msk = 0x400000
	// Bit SPI_MEM_FLASH_CE.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_CE = 0x400000
	// Position of SPI_MEM_FLASH_BE field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_BE_Pos = 0x17
	// Bit mask of SPI_MEM_FLASH_BE field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_BE_Msk = 0x800000
	// Bit SPI_MEM_FLASH_BE.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_BE = 0x800000
	// Position of SPI_MEM_FLASH_SE field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_SE_Pos = 0x18
	// Bit mask of SPI_MEM_FLASH_SE field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_SE_Msk = 0x1000000
	// Bit SPI_MEM_FLASH_SE.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_SE = 0x1000000
	// Position of SPI_MEM_FLASH_PP field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_PP_Pos = 0x19
	// Bit mask of SPI_MEM_FLASH_PP field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_PP_Msk = 0x2000000
	// Bit SPI_MEM_FLASH_PP.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_PP = 0x2000000
	// Position of SPI_MEM_FLASH_WRSR field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_WRSR_Pos = 0x1a
	// Bit mask of SPI_MEM_FLASH_WRSR field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_WRSR_Msk = 0x4000000
	// Bit SPI_MEM_FLASH_WRSR.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_WRSR = 0x4000000
	// Position of SPI_MEM_FLASH_RDSR field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_RDSR_Pos = 0x1b
	// Bit mask of SPI_MEM_FLASH_RDSR field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_RDSR_Msk = 0x8000000
	// Bit SPI_MEM_FLASH_RDSR.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_RDSR = 0x8000000
	// Position of SPI_MEM_FLASH_RDID field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_RDID_Pos = 0x1c
	// Bit mask of SPI_MEM_FLASH_RDID field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_RDID_Msk = 0x10000000
	// Bit SPI_MEM_FLASH_RDID.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_RDID = 0x10000000
	// Position of SPI_MEM_FLASH_WRDI field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_WRDI_Pos = 0x1d
	// Bit mask of SPI_MEM_FLASH_WRDI field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_WRDI_Msk = 0x20000000
	// Bit SPI_MEM_FLASH_WRDI.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_WRDI = 0x20000000
	// Position of SPI_MEM_FLASH_WREN field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_WREN_Pos = 0x1e
	// Bit mask of SPI_MEM_FLASH_WREN field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_WREN_Msk = 0x40000000
	// Bit SPI_MEM_FLASH_WREN.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_WREN = 0x40000000
	// Position of SPI_MEM_FLASH_READ field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_READ_Pos = 0x1f
	// Bit mask of SPI_MEM_FLASH_READ field.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_READ_Msk = 0x80000000
	// Bit SPI_MEM_FLASH_READ.
	SPI1_SPI_MEM_CMD_SPI_MEM_FLASH_READ = 0x80000000

	// SPI_MEM_ADDR: SPI1 address register
	// Position of SPI_MEM_USR_ADDR_VALUE field.
	SPI1_SPI_MEM_ADDR_SPI_MEM_USR_ADDR_VALUE_Pos = 0x0
	// Bit mask of SPI_MEM_USR_ADDR_VALUE field.
	SPI1_SPI_MEM_ADDR_SPI_MEM_USR_ADDR_VALUE_Msk = 0xffffffff

	// SPI_MEM_CTRL: SPI1 control register.
	// Position of SPI_MEM_FDUMMY_RIN field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FDUMMY_RIN_Pos = 0x2
	// Bit mask of SPI_MEM_FDUMMY_RIN field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FDUMMY_RIN_Msk = 0x4
	// Bit SPI_MEM_FDUMMY_RIN.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FDUMMY_RIN = 0x4
	// Position of SPI_MEM_FDUMMY_WOUT field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FDUMMY_WOUT_Pos = 0x3
	// Bit mask of SPI_MEM_FDUMMY_WOUT field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FDUMMY_WOUT_Msk = 0x8
	// Bit SPI_MEM_FDUMMY_WOUT.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FDUMMY_WOUT = 0x8
	// Position of SPI_MEM_FDOUT_OCT field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FDOUT_OCT_Pos = 0x4
	// Bit mask of SPI_MEM_FDOUT_OCT field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FDOUT_OCT_Msk = 0x10
	// Bit SPI_MEM_FDOUT_OCT.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FDOUT_OCT = 0x10
	// Position of SPI_MEM_FDIN_OCT field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FDIN_OCT_Pos = 0x5
	// Bit mask of SPI_MEM_FDIN_OCT field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FDIN_OCT_Msk = 0x20
	// Bit SPI_MEM_FDIN_OCT.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FDIN_OCT = 0x20
	// Position of SPI_MEM_FADDR_OCT field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FADDR_OCT_Pos = 0x6
	// Bit mask of SPI_MEM_FADDR_OCT field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FADDR_OCT_Msk = 0x40
	// Bit SPI_MEM_FADDR_OCT.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FADDR_OCT = 0x40
	// Position of SPI_MEM_FCMD_QUAD field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FCMD_QUAD_Pos = 0x8
	// Bit mask of SPI_MEM_FCMD_QUAD field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FCMD_QUAD_Msk = 0x100
	// Bit SPI_MEM_FCMD_QUAD.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FCMD_QUAD = 0x100
	// Position of SPI_MEM_FCMD_OCT field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FCMD_OCT_Pos = 0x9
	// Bit mask of SPI_MEM_FCMD_OCT field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FCMD_OCT_Msk = 0x200
	// Bit SPI_MEM_FCMD_OCT.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FCMD_OCT = 0x200
	// Position of SPI_MEM_FCS_CRC_EN field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FCS_CRC_EN_Pos = 0xa
	// Bit mask of SPI_MEM_FCS_CRC_EN field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FCS_CRC_EN_Msk = 0x400
	// Bit SPI_MEM_FCS_CRC_EN.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FCS_CRC_EN = 0x400
	// Position of SPI_MEM_TX_CRC_EN field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_TX_CRC_EN_Pos = 0xb
	// Bit mask of SPI_MEM_TX_CRC_EN field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_TX_CRC_EN_Msk = 0x800
	// Bit SPI_MEM_TX_CRC_EN.
	SPI1_SPI_MEM_CTRL_SPI_MEM_TX_CRC_EN = 0x800
	// Position of SPI_MEM_FASTRD_MODE field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FASTRD_MODE_Pos = 0xd
	// Bit mask of SPI_MEM_FASTRD_MODE field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FASTRD_MODE_Msk = 0x2000
	// Bit SPI_MEM_FASTRD_MODE.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FASTRD_MODE = 0x2000
	// Position of SPI_MEM_FREAD_DUAL field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FREAD_DUAL_Pos = 0xe
	// Bit mask of SPI_MEM_FREAD_DUAL field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FREAD_DUAL_Msk = 0x4000
	// Bit SPI_MEM_FREAD_DUAL.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FREAD_DUAL = 0x4000
	// Position of SPI_MEM_RESANDRES field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_RESANDRES_Pos = 0xf
	// Bit mask of SPI_MEM_RESANDRES field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_RESANDRES_Msk = 0x8000
	// Bit SPI_MEM_RESANDRES.
	SPI1_SPI_MEM_CTRL_SPI_MEM_RESANDRES = 0x8000
	// Position of SPI_MEM_Q_POL field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_Q_POL_Pos = 0x12
	// Bit mask of SPI_MEM_Q_POL field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_Q_POL_Msk = 0x40000
	// Bit SPI_MEM_Q_POL.
	SPI1_SPI_MEM_CTRL_SPI_MEM_Q_POL = 0x40000
	// Position of SPI_MEM_D_POL field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_D_POL_Pos = 0x13
	// Bit mask of SPI_MEM_D_POL field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_D_POL_Msk = 0x80000
	// Bit SPI_MEM_D_POL.
	SPI1_SPI_MEM_CTRL_SPI_MEM_D_POL = 0x80000
	// Position of SPI_MEM_FREAD_QUAD field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FREAD_QUAD_Pos = 0x14
	// Bit mask of SPI_MEM_FREAD_QUAD field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FREAD_QUAD_Msk = 0x100000
	// Bit SPI_MEM_FREAD_QUAD.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FREAD_QUAD = 0x100000
	// Position of SPI_MEM_WP field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_WP_Pos = 0x15
	// Bit mask of SPI_MEM_WP field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_WP_Msk = 0x200000
	// Bit SPI_MEM_WP.
	SPI1_SPI_MEM_CTRL_SPI_MEM_WP = 0x200000
	// Position of SPI_MEM_WRSR_2B field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_WRSR_2B_Pos = 0x16
	// Bit mask of SPI_MEM_WRSR_2B field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_WRSR_2B_Msk = 0x400000
	// Bit SPI_MEM_WRSR_2B.
	SPI1_SPI_MEM_CTRL_SPI_MEM_WRSR_2B = 0x400000
	// Position of SPI_MEM_FREAD_DIO field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FREAD_DIO_Pos = 0x17
	// Bit mask of SPI_MEM_FREAD_DIO field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FREAD_DIO_Msk = 0x800000
	// Bit SPI_MEM_FREAD_DIO.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FREAD_DIO = 0x800000
	// Position of SPI_MEM_FREAD_QIO field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FREAD_QIO_Pos = 0x18
	// Bit mask of SPI_MEM_FREAD_QIO field.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FREAD_QIO_Msk = 0x1000000
	// Bit SPI_MEM_FREAD_QIO.
	SPI1_SPI_MEM_CTRL_SPI_MEM_FREAD_QIO = 0x1000000

	// SPI_MEM_CTRL1: SPI1 control1 register.
	// Position of SPI_MEM_CLK_MODE field.
	SPI1_SPI_MEM_CTRL1_SPI_MEM_CLK_MODE_Pos = 0x0
	// Bit mask of SPI_MEM_CLK_MODE field.
	SPI1_SPI_MEM_CTRL1_SPI_MEM_CLK_MODE_Msk = 0x3
	// Position of SPI_MEM_CS_HOLD_DLY_RES field.
	SPI1_SPI_MEM_CTRL1_SPI_MEM_CS_HOLD_DLY_RES_Pos = 0x2
	// Bit mask of SPI_MEM_CS_HOLD_DLY_RES field.
	SPI1_SPI_MEM_CTRL1_SPI_MEM_CS_HOLD_DLY_RES_Msk = 0xffc

	// SPI_MEM_CTRL2: SPI1 control2 register.
	// Position of SPI_MEM_SYNC_RESET field.
	SPI1_SPI_MEM_CTRL2_SPI_MEM_SYNC_RESET_Pos = 0x1f
	// Bit mask of SPI_MEM_SYNC_RESET field.
	SPI1_SPI_MEM_CTRL2_SPI_MEM_SYNC_RESET_Msk = 0x80000000
	// Bit SPI_MEM_SYNC_RESET.
	SPI1_SPI_MEM_CTRL2_SPI_MEM_SYNC_RESET = 0x80000000

	// SPI_MEM_CLOCK: SPI1 clock division control register.
	// Position of SPI_MEM_CLKCNT_L field.
	SPI1_SPI_MEM_CLOCK_SPI_MEM_CLKCNT_L_Pos = 0x0
	// Bit mask of SPI_MEM_CLKCNT_L field.
	SPI1_SPI_MEM_CLOCK_SPI_MEM_CLKCNT_L_Msk = 0xff
	// Position of SPI_MEM_CLKCNT_H field.
	SPI1_SPI_MEM_CLOCK_SPI_MEM_CLKCNT_H_Pos = 0x8
	// Bit mask of SPI_MEM_CLKCNT_H field.
	SPI1_SPI_MEM_CLOCK_SPI_MEM_CLKCNT_H_Msk = 0xff00
	// Position of SPI_MEM_CLKCNT_N field.
	SPI1_SPI_MEM_CLOCK_SPI_MEM_CLKCNT_N_Pos = 0x10
	// Bit mask of SPI_MEM_CLKCNT_N field.
	SPI1_SPI_MEM_CLOCK_SPI_MEM_CLKCNT_N_Msk = 0xff0000
	// Position of SPI_MEM_CLK_EQU_SYSCLK field.
	SPI1_SPI_MEM_CLOCK_SPI_MEM_CLK_EQU_SYSCLK_Pos = 0x1f
	// Bit mask of SPI_MEM_CLK_EQU_SYSCLK field.
	SPI1_SPI_MEM_CLOCK_SPI_MEM_CLK_EQU_SYSCLK_Msk = 0x80000000
	// Bit SPI_MEM_CLK_EQU_SYSCLK.
	SPI1_SPI_MEM_CLOCK_SPI_MEM_CLK_EQU_SYSCLK = 0x80000000

	// SPI_MEM_USER: SPI1 user register.
	// Position of SPI_MEM_CK_OUT_EDGE field.
	SPI1_SPI_MEM_USER_SPI_MEM_CK_OUT_EDGE_Pos = 0x9
	// Bit mask of SPI_MEM_CK_OUT_EDGE field.
	SPI1_SPI_MEM_USER_SPI_MEM_CK_OUT_EDGE_Msk = 0x200
	// Bit SPI_MEM_CK_OUT_EDGE.
	SPI1_SPI_MEM_USER_SPI_MEM_CK_OUT_EDGE = 0x200
	// Position of SPI_MEM_FWRITE_DUAL field.
	SPI1_SPI_MEM_USER_SPI_MEM_FWRITE_DUAL_Pos = 0xc
	// Bit mask of SPI_MEM_FWRITE_DUAL field.
	SPI1_SPI_MEM_USER_SPI_MEM_FWRITE_DUAL_Msk = 0x1000
	// Bit SPI_MEM_FWRITE_DUAL.
	SPI1_SPI_MEM_USER_SPI_MEM_FWRITE_DUAL = 0x1000
	// Position of SPI_MEM_FWRITE_QUAD field.
	SPI1_SPI_MEM_USER_SPI_MEM_FWRITE_QUAD_Pos = 0xd
	// Bit mask of SPI_MEM_FWRITE_QUAD field.
	SPI1_SPI_MEM_USER_SPI_MEM_FWRITE_QUAD_Msk = 0x2000
	// Bit SPI_MEM_FWRITE_QUAD.
	SPI1_SPI_MEM_USER_SPI_MEM_FWRITE_QUAD = 0x2000
	// Position of SPI_MEM_FWRITE_DIO field.
	SPI1_SPI_MEM_USER_SPI_MEM_FWRITE_DIO_Pos = 0xe
	// Bit mask of SPI_MEM_FWRITE_DIO field.
	SPI1_SPI_MEM_USER_SPI_MEM_FWRITE_DIO_Msk = 0x4000
	// Bit SPI_MEM_FWRITE_DIO.
	SPI1_SPI_MEM_USER_SPI_MEM_FWRITE_DIO = 0x4000
	// Position of SPI_MEM_FWRITE_QIO field.
	SPI1_SPI_MEM_USER_SPI_MEM_FWRITE_QIO_Pos = 0xf
	// Bit mask of SPI_MEM_FWRITE_QIO field.
	SPI1_SPI_MEM_USER_SPI_MEM_FWRITE_QIO_Msk = 0x8000
	// Bit SPI_MEM_FWRITE_QIO.
	SPI1_SPI_MEM_USER_SPI_MEM_FWRITE_QIO = 0x8000
	// Position of SPI_MEM_USR_MISO_HIGHPART field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_MISO_HIGHPART_Pos = 0x18
	// Bit mask of SPI_MEM_USR_MISO_HIGHPART field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_MISO_HIGHPART_Msk = 0x1000000
	// Bit SPI_MEM_USR_MISO_HIGHPART.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_MISO_HIGHPART = 0x1000000
	// Position of SPI_MEM_USR_MOSI_HIGHPART field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_MOSI_HIGHPART_Pos = 0x19
	// Bit mask of SPI_MEM_USR_MOSI_HIGHPART field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_MOSI_HIGHPART_Msk = 0x2000000
	// Bit SPI_MEM_USR_MOSI_HIGHPART.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_MOSI_HIGHPART = 0x2000000
	// Position of SPI_MEM_USR_DUMMY_IDLE field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_DUMMY_IDLE_Pos = 0x1a
	// Bit mask of SPI_MEM_USR_DUMMY_IDLE field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_DUMMY_IDLE_Msk = 0x4000000
	// Bit SPI_MEM_USR_DUMMY_IDLE.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_DUMMY_IDLE = 0x4000000
	// Position of SPI_MEM_USR_MOSI field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_MOSI_Pos = 0x1b
	// Bit mask of SPI_MEM_USR_MOSI field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_MOSI_Msk = 0x8000000
	// Bit SPI_MEM_USR_MOSI.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_MOSI = 0x8000000
	// Position of SPI_MEM_USR_MISO field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_MISO_Pos = 0x1c
	// Bit mask of SPI_MEM_USR_MISO field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_MISO_Msk = 0x10000000
	// Bit SPI_MEM_USR_MISO.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_MISO = 0x10000000
	// Position of SPI_MEM_USR_DUMMY field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_DUMMY_Pos = 0x1d
	// Bit mask of SPI_MEM_USR_DUMMY field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_DUMMY_Msk = 0x20000000
	// Bit SPI_MEM_USR_DUMMY.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_DUMMY = 0x20000000
	// Position of SPI_MEM_USR_ADDR field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_ADDR_Pos = 0x1e
	// Bit mask of SPI_MEM_USR_ADDR field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_ADDR_Msk = 0x40000000
	// Bit SPI_MEM_USR_ADDR.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_ADDR = 0x40000000
	// Position of SPI_MEM_USR_COMMAND field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_COMMAND_Pos = 0x1f
	// Bit mask of SPI_MEM_USR_COMMAND field.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_COMMAND_Msk = 0x80000000
	// Bit SPI_MEM_USR_COMMAND.
	SPI1_SPI_MEM_USER_SPI_MEM_USR_COMMAND = 0x80000000

	// SPI_MEM_USER1: SPI1 user1 register.
	// Position of SPI_MEM_USR_DUMMY_CYCLELEN field.
	SPI1_SPI_MEM_USER1_SPI_MEM_USR_DUMMY_CYCLELEN_Pos = 0x0
	// Bit mask of SPI_MEM_USR_DUMMY_CYCLELEN field.
	SPI1_SPI_MEM_USER1_SPI_MEM_USR_DUMMY_CYCLELEN_Msk = 0x3f
	// Position of SPI_MEM_USR_ADDR_BITLEN field.
	SPI1_SPI_MEM_USER1_SPI_MEM_USR_ADDR_BITLEN_Pos = 0x1a
	// Bit mask of SPI_MEM_USR_ADDR_BITLEN field.
	SPI1_SPI_MEM_USER1_SPI_MEM_USR_ADDR_BITLEN_Msk = 0xfc000000

	// SPI_MEM_USER2: SPI1 user2 register.
	// Position of SPI_MEM_USR_COMMAND_VALUE field.
	SPI1_SPI_MEM_USER2_SPI_MEM_USR_COMMAND_VALUE_Pos = 0x0
	// Bit mask of SPI_MEM_USR_COMMAND_VALUE field.
	SPI1_SPI_MEM_USER2_SPI_MEM_USR_COMMAND_VALUE_Msk = 0xffff
	// Position of SPI_MEM_USR_COMMAND_BITLEN field.
	SPI1_SPI_MEM_USER2_SPI_MEM_USR_COMMAND_BITLEN_Pos = 0x1c
	// Bit mask of SPI_MEM_USR_COMMAND_BITLEN field.
	SPI1_SPI_MEM_USER2_SPI_MEM_USR_COMMAND_BITLEN_Msk = 0xf0000000

	// SPI_MEM_MOSI_DLEN: SPI1 send data bit length control register.
	// Position of SPI_MEM_USR_MOSI_DBITLEN field.
	SPI1_SPI_MEM_MOSI_DLEN_SPI_MEM_USR_MOSI_DBITLEN_Pos = 0x0
	// Bit mask of SPI_MEM_USR_MOSI_DBITLEN field.
	SPI1_SPI_MEM_MOSI_DLEN_SPI_MEM_USR_MOSI_DBITLEN_Msk = 0x3ff

	// SPI_MEM_MISO_DLEN: SPI1 receive data bit length control register.
	// Position of SPI_MEM_USR_MISO_DBITLEN field.
	SPI1_SPI_MEM_MISO_DLEN_SPI_MEM_USR_MISO_DBITLEN_Pos = 0x0
	// Bit mask of SPI_MEM_USR_MISO_DBITLEN field.
	SPI1_SPI_MEM_MISO_DLEN_SPI_MEM_USR_MISO_DBITLEN_Msk = 0x3ff

	// SPI_MEM_RD_STATUS: SPI1 status register.
	// Position of SPI_MEM_STATUS field.
	SPI1_SPI_MEM_RD_STATUS_SPI_MEM_STATUS_Pos = 0x0
	// Bit mask of SPI_MEM_STATUS field.
	SPI1_SPI_MEM_RD_STATUS_SPI_MEM_STATUS_Msk = 0xffff
	// Position of SPI_MEM_WB_MODE field.
	SPI1_SPI_MEM_RD_STATUS_SPI_MEM_WB_MODE_Pos = 0x10
	// Bit mask of SPI_MEM_WB_MODE field.
	SPI1_SPI_MEM_RD_STATUS_SPI_MEM_WB_MODE_Msk = 0xff0000

	// SPI_MEM_MISC: SPI1 misc register
	// Position of SPI_MEM_CS0_DIS field.
	SPI1_SPI_MEM_MISC_SPI_MEM_CS0_DIS_Pos = 0x0
	// Bit mask of SPI_MEM_CS0_DIS field.
	SPI1_SPI_MEM_MISC_SPI_MEM_CS0_DIS_Msk = 0x1
	// Bit SPI_MEM_CS0_DIS.
	SPI1_SPI_MEM_MISC_SPI_MEM_CS0_DIS = 0x1
	// Position of SPI_MEM_CS1_DIS field.
	SPI1_SPI_MEM_MISC_SPI_MEM_CS1_DIS_Pos = 0x1
	// Bit mask of SPI_MEM_CS1_DIS field.
	SPI1_SPI_MEM_MISC_SPI_MEM_CS1_DIS_Msk = 0x2
	// Bit SPI_MEM_CS1_DIS.
	SPI1_SPI_MEM_MISC_SPI_MEM_CS1_DIS = 0x2
	// Position of SPI_MEM_CK_IDLE_EDGE field.
	SPI1_SPI_MEM_MISC_SPI_MEM_CK_IDLE_EDGE_Pos = 0x9
	// Bit mask of SPI_MEM_CK_IDLE_EDGE field.
	SPI1_SPI_MEM_MISC_SPI_MEM_CK_IDLE_EDGE_Msk = 0x200
	// Bit SPI_MEM_CK_IDLE_EDGE.
	SPI1_SPI_MEM_MISC_SPI_MEM_CK_IDLE_EDGE = 0x200
	// Position of SPI_MEM_CS_KEEP_ACTIVE field.
	SPI1_SPI_MEM_MISC_SPI_MEM_CS_KEEP_ACTIVE_Pos = 0xa
	// Bit mask of SPI_MEM_CS_KEEP_ACTIVE field.
	SPI1_SPI_MEM_MISC_SPI_MEM_CS_KEEP_ACTIVE_Msk = 0x400
	// Bit SPI_MEM_CS_KEEP_ACTIVE.
	SPI1_SPI_MEM_MISC_SPI_MEM_CS_KEEP_ACTIVE = 0x400

	// SPI_MEM_TX_CRC: SPI1 TX CRC data register.
	// Position of DATA field.
	SPI1_SPI_MEM_TX_CRC_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SPI1_SPI_MEM_TX_CRC_DATA_Msk = 0xffffffff

	// SPI_MEM_CACHE_FCTRL: SPI1 bit mode control register.
	// Position of SPI_MEM_CACHE_USR_ADDR_4BYTE field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_USR_ADDR_4BYTE_Pos = 0x1
	// Bit mask of SPI_MEM_CACHE_USR_ADDR_4BYTE field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_USR_ADDR_4BYTE_Msk = 0x2
	// Bit SPI_MEM_CACHE_USR_ADDR_4BYTE.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_CACHE_USR_ADDR_4BYTE = 0x2
	// Position of SPI_MEM_FDIN_DUAL field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_DUAL_Pos = 0x3
	// Bit mask of SPI_MEM_FDIN_DUAL field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_DUAL_Msk = 0x8
	// Bit SPI_MEM_FDIN_DUAL.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_DUAL = 0x8
	// Position of SPI_MEM_FDOUT_DUAL field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_DUAL_Pos = 0x4
	// Bit mask of SPI_MEM_FDOUT_DUAL field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_DUAL_Msk = 0x10
	// Bit SPI_MEM_FDOUT_DUAL.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_DUAL = 0x10
	// Position of SPI_MEM_FADDR_DUAL field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_DUAL_Pos = 0x5
	// Bit mask of SPI_MEM_FADDR_DUAL field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_DUAL_Msk = 0x20
	// Bit SPI_MEM_FADDR_DUAL.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_DUAL = 0x20
	// Position of SPI_MEM_FDIN_QUAD field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_QUAD_Pos = 0x6
	// Bit mask of SPI_MEM_FDIN_QUAD field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_QUAD_Msk = 0x40
	// Bit SPI_MEM_FDIN_QUAD.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDIN_QUAD = 0x40
	// Position of SPI_MEM_FDOUT_QUAD field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_QUAD_Pos = 0x7
	// Bit mask of SPI_MEM_FDOUT_QUAD field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_QUAD_Msk = 0x80
	// Bit SPI_MEM_FDOUT_QUAD.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FDOUT_QUAD = 0x80
	// Position of SPI_MEM_FADDR_QUAD field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_QUAD_Pos = 0x8
	// Bit mask of SPI_MEM_FADDR_QUAD field.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_QUAD_Msk = 0x100
	// Bit SPI_MEM_FADDR_QUAD.
	SPI1_SPI_MEM_CACHE_FCTRL_SPI_MEM_FADDR_QUAD = 0x100

	// SPI_MEM_W0: SPI1 memory data buffer0
	// Position of SPI_MEM_BUF0 field.
	SPI1_SPI_MEM_W0_SPI_MEM_BUF0_Pos = 0x0
	// Bit mask of SPI_MEM_BUF0 field.
	SPI1_SPI_MEM_W0_SPI_MEM_BUF0_Msk = 0xffffffff

	// SPI_MEM_W1: SPI1 memory data buffer1
	// Position of SPI_MEM_BUF1 field.
	SPI1_SPI_MEM_W1_SPI_MEM_BUF1_Pos = 0x0
	// Bit mask of SPI_MEM_BUF1 field.
	SPI1_SPI_MEM_W1_SPI_MEM_BUF1_Msk = 0xffffffff

	// SPI_MEM_W2: SPI1 memory data buffer2
	// Position of SPI_MEM_BUF2 field.
	SPI1_SPI_MEM_W2_SPI_MEM_BUF2_Pos = 0x0
	// Bit mask of SPI_MEM_BUF2 field.
	SPI1_SPI_MEM_W2_SPI_MEM_BUF2_Msk = 0xffffffff

	// SPI_MEM_W3: SPI1 memory data buffer3
	// Position of SPI_MEM_BUF3 field.
	SPI1_SPI_MEM_W3_SPI_MEM_BUF3_Pos = 0x0
	// Bit mask of SPI_MEM_BUF3 field.
	SPI1_SPI_MEM_W3_SPI_MEM_BUF3_Msk = 0xffffffff

	// SPI_MEM_W4: SPI1 memory data buffer4
	// Position of SPI_MEM_BUF4 field.
	SPI1_SPI_MEM_W4_SPI_MEM_BUF4_Pos = 0x0
	// Bit mask of SPI_MEM_BUF4 field.
	SPI1_SPI_MEM_W4_SPI_MEM_BUF4_Msk = 0xffffffff

	// SPI_MEM_W5: SPI1 memory data buffer5
	// Position of SPI_MEM_BUF5 field.
	SPI1_SPI_MEM_W5_SPI_MEM_BUF5_Pos = 0x0
	// Bit mask of SPI_MEM_BUF5 field.
	SPI1_SPI_MEM_W5_SPI_MEM_BUF5_Msk = 0xffffffff

	// SPI_MEM_W6: SPI1 memory data buffer6
	// Position of SPI_MEM_BUF6 field.
	SPI1_SPI_MEM_W6_SPI_MEM_BUF6_Pos = 0x0
	// Bit mask of SPI_MEM_BUF6 field.
	SPI1_SPI_MEM_W6_SPI_MEM_BUF6_Msk = 0xffffffff

	// SPI_MEM_W7: SPI1 memory data buffer7
	// Position of SPI_MEM_BUF7 field.
	SPI1_SPI_MEM_W7_SPI_MEM_BUF7_Pos = 0x0
	// Bit mask of SPI_MEM_BUF7 field.
	SPI1_SPI_MEM_W7_SPI_MEM_BUF7_Msk = 0xffffffff

	// SPI_MEM_W8: SPI1 memory data buffer8
	// Position of SPI_MEM_BUF8 field.
	SPI1_SPI_MEM_W8_SPI_MEM_BUF8_Pos = 0x0
	// Bit mask of SPI_MEM_BUF8 field.
	SPI1_SPI_MEM_W8_SPI_MEM_BUF8_Msk = 0xffffffff

	// SPI_MEM_W9: SPI1 memory data buffer9
	// Position of SPI_MEM_BUF9 field.
	SPI1_SPI_MEM_W9_SPI_MEM_BUF9_Pos = 0x0
	// Bit mask of SPI_MEM_BUF9 field.
	SPI1_SPI_MEM_W9_SPI_MEM_BUF9_Msk = 0xffffffff

	// SPI_MEM_W10: SPI1 memory data buffer10
	// Position of SPI_MEM_BUF10 field.
	SPI1_SPI_MEM_W10_SPI_MEM_BUF10_Pos = 0x0
	// Bit mask of SPI_MEM_BUF10 field.
	SPI1_SPI_MEM_W10_SPI_MEM_BUF10_Msk = 0xffffffff

	// SPI_MEM_W11: SPI1 memory data buffer11
	// Position of SPI_MEM_BUF11 field.
	SPI1_SPI_MEM_W11_SPI_MEM_BUF11_Pos = 0x0
	// Bit mask of SPI_MEM_BUF11 field.
	SPI1_SPI_MEM_W11_SPI_MEM_BUF11_Msk = 0xffffffff

	// SPI_MEM_W12: SPI1 memory data buffer12
	// Position of SPI_MEM_BUF12 field.
	SPI1_SPI_MEM_W12_SPI_MEM_BUF12_Pos = 0x0
	// Bit mask of SPI_MEM_BUF12 field.
	SPI1_SPI_MEM_W12_SPI_MEM_BUF12_Msk = 0xffffffff

	// SPI_MEM_W13: SPI1 memory data buffer13
	// Position of SPI_MEM_BUF13 field.
	SPI1_SPI_MEM_W13_SPI_MEM_BUF13_Pos = 0x0
	// Bit mask of SPI_MEM_BUF13 field.
	SPI1_SPI_MEM_W13_SPI_MEM_BUF13_Msk = 0xffffffff

	// SPI_MEM_W14: SPI1 memory data buffer14
	// Position of SPI_MEM_BUF14 field.
	SPI1_SPI_MEM_W14_SPI_MEM_BUF14_Pos = 0x0
	// Bit mask of SPI_MEM_BUF14 field.
	SPI1_SPI_MEM_W14_SPI_MEM_BUF14_Msk = 0xffffffff

	// SPI_MEM_W15: SPI1 memory data buffer15
	// Position of SPI_MEM_BUF15 field.
	SPI1_SPI_MEM_W15_SPI_MEM_BUF15_Pos = 0x0
	// Bit mask of SPI_MEM_BUF15 field.
	SPI1_SPI_MEM_W15_SPI_MEM_BUF15_Msk = 0xffffffff

	// SPI_MEM_FLASH_WAITI_CTRL: SPI1 wait idle control register
	// Position of SPI_MEM_WAITI_EN field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_EN_Pos = 0x0
	// Bit mask of SPI_MEM_WAITI_EN field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_EN_Msk = 0x1
	// Bit SPI_MEM_WAITI_EN.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_EN = 0x1
	// Position of SPI_MEM_WAITI_DUMMY field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_DUMMY_Pos = 0x1
	// Bit mask of SPI_MEM_WAITI_DUMMY field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_DUMMY_Msk = 0x2
	// Bit SPI_MEM_WAITI_DUMMY.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_DUMMY = 0x2
	// Position of SPI_MEM_WAITI_ADDR_EN field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_ADDR_EN_Pos = 0x2
	// Bit mask of SPI_MEM_WAITI_ADDR_EN field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_ADDR_EN_Msk = 0x4
	// Bit SPI_MEM_WAITI_ADDR_EN.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_ADDR_EN = 0x4
	// Position of SPI_MEM_WAITI_ADDR_CYCLELEN field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_ADDR_CYCLELEN_Pos = 0x3
	// Bit mask of SPI_MEM_WAITI_ADDR_CYCLELEN field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_ADDR_CYCLELEN_Msk = 0x18
	// Position of SPI_MEM_WAITI_CMD_2B field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_CMD_2B_Pos = 0x9
	// Bit mask of SPI_MEM_WAITI_CMD_2B field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_CMD_2B_Msk = 0x200
	// Bit SPI_MEM_WAITI_CMD_2B.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_CMD_2B = 0x200
	// Position of SPI_MEM_WAITI_DUMMY_CYCLELEN field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_DUMMY_CYCLELEN_Pos = 0xa
	// Bit mask of SPI_MEM_WAITI_DUMMY_CYCLELEN field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_DUMMY_CYCLELEN_Msk = 0xfc00
	// Position of SPI_MEM_WAITI_CMD field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_CMD_Pos = 0x10
	// Bit mask of SPI_MEM_WAITI_CMD field.
	SPI1_SPI_MEM_FLASH_WAITI_CTRL_SPI_MEM_WAITI_CMD_Msk = 0xffff0000

	// SPI_MEM_FLASH_SUS_CTRL: SPI1 flash suspend control register
	// Position of SPI_MEM_FLASH_PER field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PER_Pos = 0x0
	// Bit mask of SPI_MEM_FLASH_PER field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PER_Msk = 0x1
	// Bit SPI_MEM_FLASH_PER.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PER = 0x1
	// Position of SPI_MEM_FLASH_PES field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES_Pos = 0x1
	// Bit mask of SPI_MEM_FLASH_PES field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES_Msk = 0x2
	// Bit SPI_MEM_FLASH_PES.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES = 0x2
	// Position of SPI_MEM_FLASH_PER_WAIT_EN field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PER_WAIT_EN_Pos = 0x2
	// Bit mask of SPI_MEM_FLASH_PER_WAIT_EN field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PER_WAIT_EN_Msk = 0x4
	// Bit SPI_MEM_FLASH_PER_WAIT_EN.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PER_WAIT_EN = 0x4
	// Position of SPI_MEM_FLASH_PES_WAIT_EN field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES_WAIT_EN_Pos = 0x3
	// Bit mask of SPI_MEM_FLASH_PES_WAIT_EN field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES_WAIT_EN_Msk = 0x8
	// Bit SPI_MEM_FLASH_PES_WAIT_EN.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES_WAIT_EN = 0x8
	// Position of SPI_MEM_PES_PER_EN field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PES_PER_EN_Pos = 0x4
	// Bit mask of SPI_MEM_PES_PER_EN field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PES_PER_EN_Msk = 0x10
	// Bit SPI_MEM_PES_PER_EN.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PES_PER_EN = 0x10
	// Position of SPI_MEM_FLASH_PES_EN field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES_EN_Pos = 0x5
	// Bit mask of SPI_MEM_FLASH_PES_EN field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES_EN_Msk = 0x20
	// Bit SPI_MEM_FLASH_PES_EN.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_FLASH_PES_EN = 0x20
	// Position of SPI_MEM_PESR_END_MSK field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PESR_END_MSK_Pos = 0x6
	// Bit mask of SPI_MEM_PESR_END_MSK field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PESR_END_MSK_Msk = 0x3fffc0
	// Position of SPI_FMEM_RD_SUS_2B field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_FMEM_RD_SUS_2B_Pos = 0x16
	// Bit mask of SPI_FMEM_RD_SUS_2B field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_FMEM_RD_SUS_2B_Msk = 0x400000
	// Bit SPI_FMEM_RD_SUS_2B.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_FMEM_RD_SUS_2B = 0x400000
	// Position of SPI_MEM_PER_END_EN field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PER_END_EN_Pos = 0x17
	// Bit mask of SPI_MEM_PER_END_EN field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PER_END_EN_Msk = 0x800000
	// Bit SPI_MEM_PER_END_EN.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PER_END_EN = 0x800000
	// Position of SPI_MEM_PES_END_EN field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PES_END_EN_Pos = 0x18
	// Bit mask of SPI_MEM_PES_END_EN field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PES_END_EN_Msk = 0x1000000
	// Bit SPI_MEM_PES_END_EN.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_PES_END_EN = 0x1000000
	// Position of SPI_MEM_SUS_TIMEOUT_CNT field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_SUS_TIMEOUT_CNT_Pos = 0x19
	// Bit mask of SPI_MEM_SUS_TIMEOUT_CNT field.
	SPI1_SPI_MEM_FLASH_SUS_CTRL_SPI_MEM_SUS_TIMEOUT_CNT_Msk = 0xfe000000

	// SPI_MEM_FLASH_SUS_CMD: SPI1 flash suspend command register
	// Position of SPI_MEM_FLASH_PES_COMMAND field.
	SPI1_SPI_MEM_FLASH_SUS_CMD_SPI_MEM_FLASH_PES_COMMAND_Pos = 0x0
	// Bit mask of SPI_MEM_FLASH_PES_COMMAND field.
	SPI1_SPI_MEM_FLASH_SUS_CMD_SPI_MEM_FLASH_PES_COMMAND_Msk = 0xffff
	// Position of SPI_MEM_WAIT_PESR_COMMAND field.
	SPI1_SPI_MEM_FLASH_SUS_CMD_SPI_MEM_WAIT_PESR_COMMAND_Pos = 0x10
	// Bit mask of SPI_MEM_WAIT_PESR_COMMAND field.
	SPI1_SPI_MEM_FLASH_SUS_CMD_SPI_MEM_WAIT_PESR_COMMAND_Msk = 0xffff0000

	// SPI_MEM_SUS_STATUS: SPI1 flash suspend status register
	// Position of SPI_MEM_FLASH_SUS field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_SUS_Pos = 0x0
	// Bit mask of SPI_MEM_FLASH_SUS field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_SUS_Msk = 0x1
	// Bit SPI_MEM_FLASH_SUS.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_SUS = 0x1
	// Position of SPI_MEM_WAIT_PESR_CMD_2B field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_WAIT_PESR_CMD_2B_Pos = 0x1
	// Bit mask of SPI_MEM_WAIT_PESR_CMD_2B field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_WAIT_PESR_CMD_2B_Msk = 0x2
	// Bit SPI_MEM_WAIT_PESR_CMD_2B.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_WAIT_PESR_CMD_2B = 0x2
	// Position of SPI_MEM_FLASH_HPM_DLY_128 field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_HPM_DLY_128_Pos = 0x2
	// Bit mask of SPI_MEM_FLASH_HPM_DLY_128 field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_HPM_DLY_128_Msk = 0x4
	// Bit SPI_MEM_FLASH_HPM_DLY_128.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_HPM_DLY_128 = 0x4
	// Position of SPI_MEM_FLASH_RES_DLY_128 field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_RES_DLY_128_Pos = 0x3
	// Bit mask of SPI_MEM_FLASH_RES_DLY_128 field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_RES_DLY_128_Msk = 0x8
	// Bit SPI_MEM_FLASH_RES_DLY_128.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_RES_DLY_128 = 0x8
	// Position of SPI_MEM_FLASH_DP_DLY_128 field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_DP_DLY_128_Pos = 0x4
	// Bit mask of SPI_MEM_FLASH_DP_DLY_128 field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_DP_DLY_128_Msk = 0x10
	// Bit SPI_MEM_FLASH_DP_DLY_128.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_DP_DLY_128 = 0x10
	// Position of SPI_MEM_FLASH_PER_DLY_128 field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PER_DLY_128_Pos = 0x5
	// Bit mask of SPI_MEM_FLASH_PER_DLY_128 field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PER_DLY_128_Msk = 0x20
	// Bit SPI_MEM_FLASH_PER_DLY_128.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PER_DLY_128 = 0x20
	// Position of SPI_MEM_FLASH_PES_DLY_128 field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PES_DLY_128_Pos = 0x6
	// Bit mask of SPI_MEM_FLASH_PES_DLY_128 field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PES_DLY_128_Msk = 0x40
	// Bit SPI_MEM_FLASH_PES_DLY_128.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PES_DLY_128 = 0x40
	// Position of SPI_MEM_SPI0_LOCK_EN field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_SPI0_LOCK_EN_Pos = 0x7
	// Bit mask of SPI_MEM_SPI0_LOCK_EN field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_SPI0_LOCK_EN_Msk = 0x80
	// Bit SPI_MEM_SPI0_LOCK_EN.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_SPI0_LOCK_EN = 0x80
	// Position of SPI_MEM_FLASH_PESR_CMD_2B field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PESR_CMD_2B_Pos = 0xf
	// Bit mask of SPI_MEM_FLASH_PESR_CMD_2B field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PESR_CMD_2B_Msk = 0x8000
	// Bit SPI_MEM_FLASH_PESR_CMD_2B.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PESR_CMD_2B = 0x8000
	// Position of SPI_MEM_FLASH_PER_COMMAND field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PER_COMMAND_Pos = 0x10
	// Bit mask of SPI_MEM_FLASH_PER_COMMAND field.
	SPI1_SPI_MEM_SUS_STATUS_SPI_MEM_FLASH_PER_COMMAND_Msk = 0xffff0000

	// SPI_MEM_INT_ENA: SPI1 interrupt enable register
	// Position of SPI_MEM_PER_END_INT_ENA field.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_PER_END_INT_ENA_Pos = 0x0
	// Bit mask of SPI_MEM_PER_END_INT_ENA field.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_PER_END_INT_ENA_Msk = 0x1
	// Bit SPI_MEM_PER_END_INT_ENA.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_PER_END_INT_ENA = 0x1
	// Position of SPI_MEM_PES_END_INT_ENA field.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_PES_END_INT_ENA_Pos = 0x1
	// Bit mask of SPI_MEM_PES_END_INT_ENA field.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_PES_END_INT_ENA_Msk = 0x2
	// Bit SPI_MEM_PES_END_INT_ENA.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_PES_END_INT_ENA = 0x2
	// Position of SPI_MEM_WPE_END_INT_ENA field.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_WPE_END_INT_ENA_Pos = 0x2
	// Bit mask of SPI_MEM_WPE_END_INT_ENA field.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_WPE_END_INT_ENA_Msk = 0x4
	// Bit SPI_MEM_WPE_END_INT_ENA.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_WPE_END_INT_ENA = 0x4
	// Position of SPI_MEM_SLV_ST_END_INT_ENA field.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_SLV_ST_END_INT_ENA_Pos = 0x3
	// Bit mask of SPI_MEM_SLV_ST_END_INT_ENA field.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_SLV_ST_END_INT_ENA_Msk = 0x8
	// Bit SPI_MEM_SLV_ST_END_INT_ENA.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_SLV_ST_END_INT_ENA = 0x8
	// Position of SPI_MEM_MST_ST_END_INT_ENA field.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_MST_ST_END_INT_ENA_Pos = 0x4
	// Bit mask of SPI_MEM_MST_ST_END_INT_ENA field.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_MST_ST_END_INT_ENA_Msk = 0x10
	// Bit SPI_MEM_MST_ST_END_INT_ENA.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_MST_ST_END_INT_ENA = 0x10
	// Position of SPI_MEM_BROWN_OUT_INT_ENA field.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_BROWN_OUT_INT_ENA_Pos = 0xa
	// Bit mask of SPI_MEM_BROWN_OUT_INT_ENA field.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_BROWN_OUT_INT_ENA_Msk = 0x400
	// Bit SPI_MEM_BROWN_OUT_INT_ENA.
	SPI1_SPI_MEM_INT_ENA_SPI_MEM_BROWN_OUT_INT_ENA = 0x400

	// SPI_MEM_INT_CLR: SPI1 interrupt clear register
	// Position of SPI_MEM_PER_END_INT_CLR field.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_PER_END_INT_CLR_Pos = 0x0
	// Bit mask of SPI_MEM_PER_END_INT_CLR field.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_PER_END_INT_CLR_Msk = 0x1
	// Bit SPI_MEM_PER_END_INT_CLR.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_PER_END_INT_CLR = 0x1
	// Position of SPI_MEM_PES_END_INT_CLR field.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_PES_END_INT_CLR_Pos = 0x1
	// Bit mask of SPI_MEM_PES_END_INT_CLR field.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_PES_END_INT_CLR_Msk = 0x2
	// Bit SPI_MEM_PES_END_INT_CLR.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_PES_END_INT_CLR = 0x2
	// Position of SPI_MEM_WPE_END_INT_CLR field.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_WPE_END_INT_CLR_Pos = 0x2
	// Bit mask of SPI_MEM_WPE_END_INT_CLR field.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_WPE_END_INT_CLR_Msk = 0x4
	// Bit SPI_MEM_WPE_END_INT_CLR.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_WPE_END_INT_CLR = 0x4
	// Position of SPI_MEM_SLV_ST_END_INT_CLR field.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_SLV_ST_END_INT_CLR_Pos = 0x3
	// Bit mask of SPI_MEM_SLV_ST_END_INT_CLR field.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_SLV_ST_END_INT_CLR_Msk = 0x8
	// Bit SPI_MEM_SLV_ST_END_INT_CLR.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_SLV_ST_END_INT_CLR = 0x8
	// Position of SPI_MEM_MST_ST_END_INT_CLR field.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_MST_ST_END_INT_CLR_Pos = 0x4
	// Bit mask of SPI_MEM_MST_ST_END_INT_CLR field.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_MST_ST_END_INT_CLR_Msk = 0x10
	// Bit SPI_MEM_MST_ST_END_INT_CLR.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_MST_ST_END_INT_CLR = 0x10
	// Position of SPI_MEM_BROWN_OUT_INT_CLR field.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_BROWN_OUT_INT_CLR_Pos = 0xa
	// Bit mask of SPI_MEM_BROWN_OUT_INT_CLR field.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_BROWN_OUT_INT_CLR_Msk = 0x400
	// Bit SPI_MEM_BROWN_OUT_INT_CLR.
	SPI1_SPI_MEM_INT_CLR_SPI_MEM_BROWN_OUT_INT_CLR = 0x400

	// SPI_MEM_INT_RAW: SPI1 interrupt raw register
	// Position of SPI_MEM_PER_END_INT_RAW field.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_PER_END_INT_RAW_Pos = 0x0
	// Bit mask of SPI_MEM_PER_END_INT_RAW field.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_PER_END_INT_RAW_Msk = 0x1
	// Bit SPI_MEM_PER_END_INT_RAW.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_PER_END_INT_RAW = 0x1
	// Position of SPI_MEM_PES_END_INT_RAW field.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_PES_END_INT_RAW_Pos = 0x1
	// Bit mask of SPI_MEM_PES_END_INT_RAW field.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_PES_END_INT_RAW_Msk = 0x2
	// Bit SPI_MEM_PES_END_INT_RAW.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_PES_END_INT_RAW = 0x2
	// Position of SPI_MEM_WPE_END_INT_RAW field.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_WPE_END_INT_RAW_Pos = 0x2
	// Bit mask of SPI_MEM_WPE_END_INT_RAW field.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_WPE_END_INT_RAW_Msk = 0x4
	// Bit SPI_MEM_WPE_END_INT_RAW.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_WPE_END_INT_RAW = 0x4
	// Position of SPI_MEM_SLV_ST_END_INT_RAW field.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_SLV_ST_END_INT_RAW_Pos = 0x3
	// Bit mask of SPI_MEM_SLV_ST_END_INT_RAW field.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_SLV_ST_END_INT_RAW_Msk = 0x8
	// Bit SPI_MEM_SLV_ST_END_INT_RAW.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_SLV_ST_END_INT_RAW = 0x8
	// Position of SPI_MEM_MST_ST_END_INT_RAW field.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_MST_ST_END_INT_RAW_Pos = 0x4
	// Bit mask of SPI_MEM_MST_ST_END_INT_RAW field.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_MST_ST_END_INT_RAW_Msk = 0x10
	// Bit SPI_MEM_MST_ST_END_INT_RAW.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_MST_ST_END_INT_RAW = 0x10
	// Position of SPI_MEM_BROWN_OUT_INT_RAW field.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_BROWN_OUT_INT_RAW_Pos = 0xa
	// Bit mask of SPI_MEM_BROWN_OUT_INT_RAW field.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_BROWN_OUT_INT_RAW_Msk = 0x400
	// Bit SPI_MEM_BROWN_OUT_INT_RAW.
	SPI1_SPI_MEM_INT_RAW_SPI_MEM_BROWN_OUT_INT_RAW = 0x400

	// SPI_MEM_INT_ST: SPI1 interrupt status register
	// Position of SPI_MEM_PER_END_INT_ST field.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_PER_END_INT_ST_Pos = 0x0
	// Bit mask of SPI_MEM_PER_END_INT_ST field.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_PER_END_INT_ST_Msk = 0x1
	// Bit SPI_MEM_PER_END_INT_ST.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_PER_END_INT_ST = 0x1
	// Position of SPI_MEM_PES_END_INT_ST field.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_PES_END_INT_ST_Pos = 0x1
	// Bit mask of SPI_MEM_PES_END_INT_ST field.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_PES_END_INT_ST_Msk = 0x2
	// Bit SPI_MEM_PES_END_INT_ST.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_PES_END_INT_ST = 0x2
	// Position of SPI_MEM_WPE_END_INT_ST field.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_WPE_END_INT_ST_Pos = 0x2
	// Bit mask of SPI_MEM_WPE_END_INT_ST field.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_WPE_END_INT_ST_Msk = 0x4
	// Bit SPI_MEM_WPE_END_INT_ST.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_WPE_END_INT_ST = 0x4
	// Position of SPI_MEM_SLV_ST_END_INT_ST field.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_SLV_ST_END_INT_ST_Pos = 0x3
	// Bit mask of SPI_MEM_SLV_ST_END_INT_ST field.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_SLV_ST_END_INT_ST_Msk = 0x8
	// Bit SPI_MEM_SLV_ST_END_INT_ST.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_SLV_ST_END_INT_ST = 0x8
	// Position of SPI_MEM_MST_ST_END_INT_ST field.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_MST_ST_END_INT_ST_Pos = 0x4
	// Bit mask of SPI_MEM_MST_ST_END_INT_ST field.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_MST_ST_END_INT_ST_Msk = 0x10
	// Bit SPI_MEM_MST_ST_END_INT_ST.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_MST_ST_END_INT_ST = 0x10
	// Position of SPI_MEM_BROWN_OUT_INT_ST field.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_BROWN_OUT_INT_ST_Pos = 0xa
	// Bit mask of SPI_MEM_BROWN_OUT_INT_ST field.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_BROWN_OUT_INT_ST_Msk = 0x400
	// Bit SPI_MEM_BROWN_OUT_INT_ST.
	SPI1_SPI_MEM_INT_ST_SPI_MEM_BROWN_OUT_INT_ST = 0x400

	// SPI_MEM_DDR: SPI1 DDR control register
	// Position of SPI_FMEM_DDR_EN field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_EN_Pos = 0x0
	// Bit mask of SPI_FMEM_DDR_EN field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_EN_Msk = 0x1
	// Bit SPI_FMEM_DDR_EN.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_EN = 0x1
	// Position of SPI_FMEM_VAR_DUMMY field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_VAR_DUMMY_Pos = 0x1
	// Bit mask of SPI_FMEM_VAR_DUMMY field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_VAR_DUMMY_Msk = 0x2
	// Bit SPI_FMEM_VAR_DUMMY.
	SPI1_SPI_MEM_DDR_SPI_FMEM_VAR_DUMMY = 0x2
	// Position of SPI_FMEM_DDR_RDAT_SWP field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_RDAT_SWP_Pos = 0x2
	// Bit mask of SPI_FMEM_DDR_RDAT_SWP field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_RDAT_SWP_Msk = 0x4
	// Bit SPI_FMEM_DDR_RDAT_SWP.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_RDAT_SWP = 0x4
	// Position of SPI_FMEM_DDR_WDAT_SWP field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_WDAT_SWP_Pos = 0x3
	// Bit mask of SPI_FMEM_DDR_WDAT_SWP field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_WDAT_SWP_Msk = 0x8
	// Bit SPI_FMEM_DDR_WDAT_SWP.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_WDAT_SWP = 0x8
	// Position of SPI_FMEM_DDR_CMD_DIS field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_CMD_DIS_Pos = 0x4
	// Bit mask of SPI_FMEM_DDR_CMD_DIS field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_CMD_DIS_Msk = 0x10
	// Bit SPI_FMEM_DDR_CMD_DIS.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_CMD_DIS = 0x10
	// Position of SPI_FMEM_OUTMINBYTELEN field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_OUTMINBYTELEN_Pos = 0x5
	// Bit mask of SPI_FMEM_OUTMINBYTELEN field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_OUTMINBYTELEN_Msk = 0xfe0
	// Position of SPI_FMEM_USR_DDR_DQS_THD field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_USR_DDR_DQS_THD_Pos = 0xe
	// Bit mask of SPI_FMEM_USR_DDR_DQS_THD field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_USR_DDR_DQS_THD_Msk = 0x1fc000
	// Position of SPI_FMEM_DDR_DQS_LOOP field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_DQS_LOOP_Pos = 0x15
	// Bit mask of SPI_FMEM_DDR_DQS_LOOP field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_DQS_LOOP_Msk = 0x200000
	// Bit SPI_FMEM_DDR_DQS_LOOP.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DDR_DQS_LOOP = 0x200000
	// Position of SPI_FMEM_CLK_DIFF_EN field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_CLK_DIFF_EN_Pos = 0x18
	// Bit mask of SPI_FMEM_CLK_DIFF_EN field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_CLK_DIFF_EN_Msk = 0x1000000
	// Bit SPI_FMEM_CLK_DIFF_EN.
	SPI1_SPI_MEM_DDR_SPI_FMEM_CLK_DIFF_EN = 0x1000000
	// Position of SPI_FMEM_DQS_CA_IN field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DQS_CA_IN_Pos = 0x1a
	// Bit mask of SPI_FMEM_DQS_CA_IN field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DQS_CA_IN_Msk = 0x4000000
	// Bit SPI_FMEM_DQS_CA_IN.
	SPI1_SPI_MEM_DDR_SPI_FMEM_DQS_CA_IN = 0x4000000
	// Position of SPI_FMEM_HYPERBUS_DUMMY_2X field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_HYPERBUS_DUMMY_2X_Pos = 0x1b
	// Bit mask of SPI_FMEM_HYPERBUS_DUMMY_2X field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_HYPERBUS_DUMMY_2X_Msk = 0x8000000
	// Bit SPI_FMEM_HYPERBUS_DUMMY_2X.
	SPI1_SPI_MEM_DDR_SPI_FMEM_HYPERBUS_DUMMY_2X = 0x8000000
	// Position of SPI_FMEM_CLK_DIFF_INV field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_CLK_DIFF_INV_Pos = 0x1c
	// Bit mask of SPI_FMEM_CLK_DIFF_INV field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_CLK_DIFF_INV_Msk = 0x10000000
	// Bit SPI_FMEM_CLK_DIFF_INV.
	SPI1_SPI_MEM_DDR_SPI_FMEM_CLK_DIFF_INV = 0x10000000
	// Position of SPI_FMEM_OCTA_RAM_ADDR field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_OCTA_RAM_ADDR_Pos = 0x1d
	// Bit mask of SPI_FMEM_OCTA_RAM_ADDR field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_OCTA_RAM_ADDR_Msk = 0x20000000
	// Bit SPI_FMEM_OCTA_RAM_ADDR.
	SPI1_SPI_MEM_DDR_SPI_FMEM_OCTA_RAM_ADDR = 0x20000000
	// Position of SPI_FMEM_HYPERBUS_CA field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_HYPERBUS_CA_Pos = 0x1e
	// Bit mask of SPI_FMEM_HYPERBUS_CA field.
	SPI1_SPI_MEM_DDR_SPI_FMEM_HYPERBUS_CA_Msk = 0x40000000
	// Bit SPI_FMEM_HYPERBUS_CA.
	SPI1_SPI_MEM_DDR_SPI_FMEM_HYPERBUS_CA = 0x40000000

	// SPI_MEM_TIMING_CALI: SPI1 timing control register
	// Position of SPI_MEM_TIMING_CALI field.
	SPI1_SPI_MEM_TIMING_CALI_SPI_MEM_TIMING_CALI_Pos = 0x1
	// Bit mask of SPI_MEM_TIMING_CALI field.
	SPI1_SPI_MEM_TIMING_CALI_SPI_MEM_TIMING_CALI_Msk = 0x2
	// Bit SPI_MEM_TIMING_CALI.
	SPI1_SPI_MEM_TIMING_CALI_SPI_MEM_TIMING_CALI = 0x2
	// Position of SPI_MEM_EXTRA_DUMMY_CYCLELEN field.
	SPI1_SPI_MEM_TIMING_CALI_SPI_MEM_EXTRA_DUMMY_CYCLELEN_Pos = 0x2
	// Bit mask of SPI_MEM_EXTRA_DUMMY_CYCLELEN field.
	SPI1_SPI_MEM_TIMING_CALI_SPI_MEM_EXTRA_DUMMY_CYCLELEN_Msk = 0x1c

	// SPI_MEM_CLOCK_GATE: SPI1 clk_gate register
	// Position of SPI_MEM_CLK_EN field.
	SPI1_SPI_MEM_CLOCK_GATE_SPI_MEM_CLK_EN_Pos = 0x0
	// Bit mask of SPI_MEM_CLK_EN field.
	SPI1_SPI_MEM_CLOCK_GATE_SPI_MEM_CLK_EN_Msk = 0x1
	// Bit SPI_MEM_CLK_EN.
	SPI1_SPI_MEM_CLOCK_GATE_SPI_MEM_CLK_EN = 0x1

	// SPI_MEM_DATE: Version control register
	// Position of SPI_MEM_DATE field.
	SPI1_SPI_MEM_DATE_SPI_MEM_DATE_Pos = 0x0
	// Bit mask of SPI_MEM_DATE field.
	SPI1_SPI_MEM_DATE_SPI_MEM_DATE_Msk = 0xfffffff
)

// Constants for SPI2: SPI (Serial Peripheral Interface) Controller 2
const (
	// CMD: Command control register
	// Position of CONF_BITLEN field.
	SPI2_CMD_CONF_BITLEN_Pos = 0x0
	// Bit mask of CONF_BITLEN field.
	SPI2_CMD_CONF_BITLEN_Msk = 0x3ffff
	// Position of UPDATE field.
	SPI2_CMD_UPDATE_Pos = 0x17
	// Bit mask of UPDATE field.
	SPI2_CMD_UPDATE_Msk = 0x800000
	// Bit UPDATE.
	SPI2_CMD_UPDATE = 0x800000
	// Position of USR field.
	SPI2_CMD_USR_Pos = 0x18
	// Bit mask of USR field.
	SPI2_CMD_USR_Msk = 0x1000000
	// Bit USR.
	SPI2_CMD_USR = 0x1000000

	// ADDR: Address value register
	// Position of USR_ADDR_VALUE field.
	SPI2_ADDR_USR_ADDR_VALUE_Pos = 0x0
	// Bit mask of USR_ADDR_VALUE field.
	SPI2_ADDR_USR_ADDR_VALUE_Msk = 0xffffffff

	// CTRL: SPI control register
	// Position of DUMMY_OUT field.
	SPI2_CTRL_DUMMY_OUT_Pos = 0x3
	// Bit mask of DUMMY_OUT field.
	SPI2_CTRL_DUMMY_OUT_Msk = 0x8
	// Bit DUMMY_OUT.
	SPI2_CTRL_DUMMY_OUT = 0x8
	// Position of FADDR_DUAL field.
	SPI2_CTRL_FADDR_DUAL_Pos = 0x5
	// Bit mask of FADDR_DUAL field.
	SPI2_CTRL_FADDR_DUAL_Msk = 0x20
	// Bit FADDR_DUAL.
	SPI2_CTRL_FADDR_DUAL = 0x20
	// Position of FADDR_QUAD field.
	SPI2_CTRL_FADDR_QUAD_Pos = 0x6
	// Bit mask of FADDR_QUAD field.
	SPI2_CTRL_FADDR_QUAD_Msk = 0x40
	// Bit FADDR_QUAD.
	SPI2_CTRL_FADDR_QUAD = 0x40
	// Position of FADDR_OCT field.
	SPI2_CTRL_FADDR_OCT_Pos = 0x7
	// Bit mask of FADDR_OCT field.
	SPI2_CTRL_FADDR_OCT_Msk = 0x80
	// Bit FADDR_OCT.
	SPI2_CTRL_FADDR_OCT = 0x80
	// Position of FCMD_DUAL field.
	SPI2_CTRL_FCMD_DUAL_Pos = 0x8
	// Bit mask of FCMD_DUAL field.
	SPI2_CTRL_FCMD_DUAL_Msk = 0x100
	// Bit FCMD_DUAL.
	SPI2_CTRL_FCMD_DUAL = 0x100
	// Position of FCMD_QUAD field.
	SPI2_CTRL_FCMD_QUAD_Pos = 0x9
	// Bit mask of FCMD_QUAD field.
	SPI2_CTRL_FCMD_QUAD_Msk = 0x200
	// Bit FCMD_QUAD.
	SPI2_CTRL_FCMD_QUAD = 0x200
	// Position of FCMD_OCT field.
	SPI2_CTRL_FCMD_OCT_Pos = 0xa
	// Bit mask of FCMD_OCT field.
	SPI2_CTRL_FCMD_OCT_Msk = 0x400
	// Bit FCMD_OCT.
	SPI2_CTRL_FCMD_OCT = 0x400
	// Position of FREAD_DUAL field.
	SPI2_CTRL_FREAD_DUAL_Pos = 0xe
	// Bit mask of FREAD_DUAL field.
	SPI2_CTRL_FREAD_DUAL_Msk = 0x4000
	// Bit FREAD_DUAL.
	SPI2_CTRL_FREAD_DUAL = 0x4000
	// Position of FREAD_QUAD field.
	SPI2_CTRL_FREAD_QUAD_Pos = 0xf
	// Bit mask of FREAD_QUAD field.
	SPI2_CTRL_FREAD_QUAD_Msk = 0x8000
	// Bit FREAD_QUAD.
	SPI2_CTRL_FREAD_QUAD = 0x8000
	// Position of FREAD_OCT field.
	SPI2_CTRL_FREAD_OCT_Pos = 0x10
	// Bit mask of FREAD_OCT field.
	SPI2_CTRL_FREAD_OCT_Msk = 0x10000
	// Bit FREAD_OCT.
	SPI2_CTRL_FREAD_OCT = 0x10000
	// Position of Q_POL field.
	SPI2_CTRL_Q_POL_Pos = 0x12
	// Bit mask of Q_POL field.
	SPI2_CTRL_Q_POL_Msk = 0x40000
	// Bit Q_POL.
	SPI2_CTRL_Q_POL = 0x40000
	// Position of D_POL field.
	SPI2_CTRL_D_POL_Pos = 0x13
	// Bit mask of D_POL field.
	SPI2_CTRL_D_POL_Msk = 0x80000
	// Bit D_POL.
	SPI2_CTRL_D_POL = 0x80000
	// Position of HOLD_POL field.
	SPI2_CTRL_HOLD_POL_Pos = 0x14
	// Bit mask of HOLD_POL field.
	SPI2_CTRL_HOLD_POL_Msk = 0x100000
	// Bit HOLD_POL.
	SPI2_CTRL_HOLD_POL = 0x100000
	// Position of WP_POL field.
	SPI2_CTRL_WP_POL_Pos = 0x15
	// Bit mask of WP_POL field.
	SPI2_CTRL_WP_POL_Msk = 0x200000
	// Bit WP_POL.
	SPI2_CTRL_WP_POL = 0x200000
	// Position of RD_BIT_ORDER field.
	SPI2_CTRL_RD_BIT_ORDER_Pos = 0x17
	// Bit mask of RD_BIT_ORDER field.
	SPI2_CTRL_RD_BIT_ORDER_Msk = 0x1800000
	// Position of WR_BIT_ORDER field.
	SPI2_CTRL_WR_BIT_ORDER_Pos = 0x19
	// Bit mask of WR_BIT_ORDER field.
	SPI2_CTRL_WR_BIT_ORDER_Msk = 0x6000000

	// CLOCK: SPI clock control register
	// Position of CLKCNT_L field.
	SPI2_CLOCK_CLKCNT_L_Pos = 0x0
	// Bit mask of CLKCNT_L field.
	SPI2_CLOCK_CLKCNT_L_Msk = 0x3f
	// Position of CLKCNT_H field.
	SPI2_CLOCK_CLKCNT_H_Pos = 0x6
	// Bit mask of CLKCNT_H field.
	SPI2_CLOCK_CLKCNT_H_Msk = 0xfc0
	// Position of CLKCNT_N field.
	SPI2_CLOCK_CLKCNT_N_Pos = 0xc
	// Bit mask of CLKCNT_N field.
	SPI2_CLOCK_CLKCNT_N_Msk = 0x3f000
	// Position of CLKDIV_PRE field.
	SPI2_CLOCK_CLKDIV_PRE_Pos = 0x12
	// Bit mask of CLKDIV_PRE field.
	SPI2_CLOCK_CLKDIV_PRE_Msk = 0x3c0000
	// Position of CLK_EQU_SYSCLK field.
	SPI2_CLOCK_CLK_EQU_SYSCLK_Pos = 0x1f
	// Bit mask of CLK_EQU_SYSCLK field.
	SPI2_CLOCK_CLK_EQU_SYSCLK_Msk = 0x80000000
	// Bit CLK_EQU_SYSCLK.
	SPI2_CLOCK_CLK_EQU_SYSCLK = 0x80000000

	// USER: SPI USER control register
	// Position of DOUTDIN field.
	SPI2_USER_DOUTDIN_Pos = 0x0
	// Bit mask of DOUTDIN field.
	SPI2_USER_DOUTDIN_Msk = 0x1
	// Bit DOUTDIN.
	SPI2_USER_DOUTDIN = 0x1
	// Position of QPI_MODE field.
	SPI2_USER_QPI_MODE_Pos = 0x3
	// Bit mask of QPI_MODE field.
	SPI2_USER_QPI_MODE_Msk = 0x8
	// Bit QPI_MODE.
	SPI2_USER_QPI_MODE = 0x8
	// Position of OPI_MODE field.
	SPI2_USER_OPI_MODE_Pos = 0x4
	// Bit mask of OPI_MODE field.
	SPI2_USER_OPI_MODE_Msk = 0x10
	// Bit OPI_MODE.
	SPI2_USER_OPI_MODE = 0x10
	// Position of TSCK_I_EDGE field.
	SPI2_USER_TSCK_I_EDGE_Pos = 0x5
	// Bit mask of TSCK_I_EDGE field.
	SPI2_USER_TSCK_I_EDGE_Msk = 0x20
	// Bit TSCK_I_EDGE.
	SPI2_USER_TSCK_I_EDGE = 0x20
	// Position of CS_HOLD field.
	SPI2_USER_CS_HOLD_Pos = 0x6
	// Bit mask of CS_HOLD field.
	SPI2_USER_CS_HOLD_Msk = 0x40
	// Bit CS_HOLD.
	SPI2_USER_CS_HOLD = 0x40
	// Position of CS_SETUP field.
	SPI2_USER_CS_SETUP_Pos = 0x7
	// Bit mask of CS_SETUP field.
	SPI2_USER_CS_SETUP_Msk = 0x80
	// Bit CS_SETUP.
	SPI2_USER_CS_SETUP = 0x80
	// Position of RSCK_I_EDGE field.
	SPI2_USER_RSCK_I_EDGE_Pos = 0x8
	// Bit mask of RSCK_I_EDGE field.
	SPI2_USER_RSCK_I_EDGE_Msk = 0x100
	// Bit RSCK_I_EDGE.
	SPI2_USER_RSCK_I_EDGE = 0x100
	// Position of CK_OUT_EDGE field.
	SPI2_USER_CK_OUT_EDGE_Pos = 0x9
	// Bit mask of CK_OUT_EDGE field.
	SPI2_USER_CK_OUT_EDGE_Msk = 0x200
	// Bit CK_OUT_EDGE.
	SPI2_USER_CK_OUT_EDGE = 0x200
	// Position of FWRITE_DUAL field.
	SPI2_USER_FWRITE_DUAL_Pos = 0xc
	// Bit mask of FWRITE_DUAL field.
	SPI2_USER_FWRITE_DUAL_Msk = 0x1000
	// Bit FWRITE_DUAL.
	SPI2_USER_FWRITE_DUAL = 0x1000
	// Position of FWRITE_QUAD field.
	SPI2_USER_FWRITE_QUAD_Pos = 0xd
	// Bit mask of FWRITE_QUAD field.
	SPI2_USER_FWRITE_QUAD_Msk = 0x2000
	// Bit FWRITE_QUAD.
	SPI2_USER_FWRITE_QUAD = 0x2000
	// Position of FWRITE_OCT field.
	SPI2_USER_FWRITE_OCT_Pos = 0xe
	// Bit mask of FWRITE_OCT field.
	SPI2_USER_FWRITE_OCT_Msk = 0x4000
	// Bit FWRITE_OCT.
	SPI2_USER_FWRITE_OCT = 0x4000
	// Position of USR_CONF_NXT field.
	SPI2_USER_USR_CONF_NXT_Pos = 0xf
	// Bit mask of USR_CONF_NXT field.
	SPI2_USER_USR_CONF_NXT_Msk = 0x8000
	// Bit USR_CONF_NXT.
	SPI2_USER_USR_CONF_NXT = 0x8000
	// Position of SIO field.
	SPI2_USER_SIO_Pos = 0x11
	// Bit mask of SIO field.
	SPI2_USER_SIO_Msk = 0x20000
	// Bit SIO.
	SPI2_USER_SIO = 0x20000
	// Position of USR_MISO_HIGHPART field.
	SPI2_USER_USR_MISO_HIGHPART_Pos = 0x18
	// Bit mask of USR_MISO_HIGHPART field.
	SPI2_USER_USR_MISO_HIGHPART_Msk = 0x1000000
	// Bit USR_MISO_HIGHPART.
	SPI2_USER_USR_MISO_HIGHPART = 0x1000000
	// Position of USR_MOSI_HIGHPART field.
	SPI2_USER_USR_MOSI_HIGHPART_Pos = 0x19
	// Bit mask of USR_MOSI_HIGHPART field.
	SPI2_USER_USR_MOSI_HIGHPART_Msk = 0x2000000
	// Bit USR_MOSI_HIGHPART.
	SPI2_USER_USR_MOSI_HIGHPART = 0x2000000
	// Position of USR_DUMMY_IDLE field.
	SPI2_USER_USR_DUMMY_IDLE_Pos = 0x1a
	// Bit mask of USR_DUMMY_IDLE field.
	SPI2_USER_USR_DUMMY_IDLE_Msk = 0x4000000
	// Bit USR_DUMMY_IDLE.
	SPI2_USER_USR_DUMMY_IDLE = 0x4000000
	// Position of USR_MOSI field.
	SPI2_USER_USR_MOSI_Pos = 0x1b
	// Bit mask of USR_MOSI field.
	SPI2_USER_USR_MOSI_Msk = 0x8000000
	// Bit USR_MOSI.
	SPI2_USER_USR_MOSI = 0x8000000
	// Position of USR_MISO field.
	SPI2_USER_USR_MISO_Pos = 0x1c
	// Bit mask of USR_MISO field.
	SPI2_USER_USR_MISO_Msk = 0x10000000
	// Bit USR_MISO.
	SPI2_USER_USR_MISO = 0x10000000
	// Position of USR_DUMMY field.
	SPI2_USER_USR_DUMMY_Pos = 0x1d
	// Bit mask of USR_DUMMY field.
	SPI2_USER_USR_DUMMY_Msk = 0x20000000
	// Bit USR_DUMMY.
	SPI2_USER_USR_DUMMY = 0x20000000
	// Position of USR_ADDR field.
	SPI2_USER_USR_ADDR_Pos = 0x1e
	// Bit mask of USR_ADDR field.
	SPI2_USER_USR_ADDR_Msk = 0x40000000
	// Bit USR_ADDR.
	SPI2_USER_USR_ADDR = 0x40000000
	// Position of USR_COMMAND field.
	SPI2_USER_USR_COMMAND_Pos = 0x1f
	// Bit mask of USR_COMMAND field.
	SPI2_USER_USR_COMMAND_Msk = 0x80000000
	// Bit USR_COMMAND.
	SPI2_USER_USR_COMMAND = 0x80000000

	// USER1: SPI USER control register 1
	// Position of USR_DUMMY_CYCLELEN field.
	SPI2_USER1_USR_DUMMY_CYCLELEN_Pos = 0x0
	// Bit mask of USR_DUMMY_CYCLELEN field.
	SPI2_USER1_USR_DUMMY_CYCLELEN_Msk = 0xff
	// Position of MST_WFULL_ERR_END_EN field.
	SPI2_USER1_MST_WFULL_ERR_END_EN_Pos = 0x10
	// Bit mask of MST_WFULL_ERR_END_EN field.
	SPI2_USER1_MST_WFULL_ERR_END_EN_Msk = 0x10000
	// Bit MST_WFULL_ERR_END_EN.
	SPI2_USER1_MST_WFULL_ERR_END_EN = 0x10000
	// Position of CS_SETUP_TIME field.
	SPI2_USER1_CS_SETUP_TIME_Pos = 0x11
	// Bit mask of CS_SETUP_TIME field.
	SPI2_USER1_CS_SETUP_TIME_Msk = 0x3e0000
	// Position of CS_HOLD_TIME field.
	SPI2_USER1_CS_HOLD_TIME_Pos = 0x16
	// Bit mask of CS_HOLD_TIME field.
	SPI2_USER1_CS_HOLD_TIME_Msk = 0x7c00000
	// Position of USR_ADDR_BITLEN field.
	SPI2_USER1_USR_ADDR_BITLEN_Pos = 0x1b
	// Bit mask of USR_ADDR_BITLEN field.
	SPI2_USER1_USR_ADDR_BITLEN_Msk = 0xf8000000

	// USER2: SPI USER control register 2
	// Position of USR_COMMAND_VALUE field.
	SPI2_USER2_USR_COMMAND_VALUE_Pos = 0x0
	// Bit mask of USR_COMMAND_VALUE field.
	SPI2_USER2_USR_COMMAND_VALUE_Msk = 0xffff
	// Position of MST_REMPTY_ERR_END_EN field.
	SPI2_USER2_MST_REMPTY_ERR_END_EN_Pos = 0x1b
	// Bit mask of MST_REMPTY_ERR_END_EN field.
	SPI2_USER2_MST_REMPTY_ERR_END_EN_Msk = 0x8000000
	// Bit MST_REMPTY_ERR_END_EN.
	SPI2_USER2_MST_REMPTY_ERR_END_EN = 0x8000000
	// Position of USR_COMMAND_BITLEN field.
	SPI2_USER2_USR_COMMAND_BITLEN_Pos = 0x1c
	// Bit mask of USR_COMMAND_BITLEN field.
	SPI2_USER2_USR_COMMAND_BITLEN_Msk = 0xf0000000

	// MS_DLEN: SPI data bit length control register
	// Position of MS_DATA_BITLEN field.
	SPI2_MS_DLEN_MS_DATA_BITLEN_Pos = 0x0
	// Bit mask of MS_DATA_BITLEN field.
	SPI2_MS_DLEN_MS_DATA_BITLEN_Msk = 0x3ffff

	// MISC: SPI misc register
	// Position of CS0_DIS field.
	SPI2_MISC_CS0_DIS_Pos = 0x0
	// Bit mask of CS0_DIS field.
	SPI2_MISC_CS0_DIS_Msk = 0x1
	// Bit CS0_DIS.
	SPI2_MISC_CS0_DIS = 0x1
	// Position of CS1_DIS field.
	SPI2_MISC_CS1_DIS_Pos = 0x1
	// Bit mask of CS1_DIS field.
	SPI2_MISC_CS1_DIS_Msk = 0x2
	// Bit CS1_DIS.
	SPI2_MISC_CS1_DIS = 0x2
	// Position of CS2_DIS field.
	SPI2_MISC_CS2_DIS_Pos = 0x2
	// Bit mask of CS2_DIS field.
	SPI2_MISC_CS2_DIS_Msk = 0x4
	// Bit CS2_DIS.
	SPI2_MISC_CS2_DIS = 0x4
	// Position of CS3_DIS field.
	SPI2_MISC_CS3_DIS_Pos = 0x3
	// Bit mask of CS3_DIS field.
	SPI2_MISC_CS3_DIS_Msk = 0x8
	// Bit CS3_DIS.
	SPI2_MISC_CS3_DIS = 0x8
	// Position of CS4_DIS field.
	SPI2_MISC_CS4_DIS_Pos = 0x4
	// Bit mask of CS4_DIS field.
	SPI2_MISC_CS4_DIS_Msk = 0x10
	// Bit CS4_DIS.
	SPI2_MISC_CS4_DIS = 0x10
	// Position of CS5_DIS field.
	SPI2_MISC_CS5_DIS_Pos = 0x5
	// Bit mask of CS5_DIS field.
	SPI2_MISC_CS5_DIS_Msk = 0x20
	// Bit CS5_DIS.
	SPI2_MISC_CS5_DIS = 0x20
	// Position of CK_DIS field.
	SPI2_MISC_CK_DIS_Pos = 0x6
	// Bit mask of CK_DIS field.
	SPI2_MISC_CK_DIS_Msk = 0x40
	// Bit CK_DIS.
	SPI2_MISC_CK_DIS = 0x40
	// Position of MASTER_CS_POL field.
	SPI2_MISC_MASTER_CS_POL_Pos = 0x7
	// Bit mask of MASTER_CS_POL field.
	SPI2_MISC_MASTER_CS_POL_Msk = 0x1f80
	// Position of CLK_DATA_DTR_EN field.
	SPI2_MISC_CLK_DATA_DTR_EN_Pos = 0x10
	// Bit mask of CLK_DATA_DTR_EN field.
	SPI2_MISC_CLK_DATA_DTR_EN_Msk = 0x10000
	// Bit CLK_DATA_DTR_EN.
	SPI2_MISC_CLK_DATA_DTR_EN = 0x10000
	// Position of DATA_DTR_EN field.
	SPI2_MISC_DATA_DTR_EN_Pos = 0x11
	// Bit mask of DATA_DTR_EN field.
	SPI2_MISC_DATA_DTR_EN_Msk = 0x20000
	// Bit DATA_DTR_EN.
	SPI2_MISC_DATA_DTR_EN = 0x20000
	// Position of ADDR_DTR_EN field.
	SPI2_MISC_ADDR_DTR_EN_Pos = 0x12
	// Bit mask of ADDR_DTR_EN field.
	SPI2_MISC_ADDR_DTR_EN_Msk = 0x40000
	// Bit ADDR_DTR_EN.
	SPI2_MISC_ADDR_DTR_EN = 0x40000
	// Position of CMD_DTR_EN field.
	SPI2_MISC_CMD_DTR_EN_Pos = 0x13
	// Bit mask of CMD_DTR_EN field.
	SPI2_MISC_CMD_DTR_EN_Msk = 0x80000
	// Bit CMD_DTR_EN.
	SPI2_MISC_CMD_DTR_EN = 0x80000
	// Position of SLAVE_CS_POL field.
	SPI2_MISC_SLAVE_CS_POL_Pos = 0x17
	// Bit mask of SLAVE_CS_POL field.
	SPI2_MISC_SLAVE_CS_POL_Msk = 0x800000
	// Bit SLAVE_CS_POL.
	SPI2_MISC_SLAVE_CS_POL = 0x800000
	// Position of DQS_IDLE_EDGE field.
	SPI2_MISC_DQS_IDLE_EDGE_Pos = 0x18
	// Bit mask of DQS_IDLE_EDGE field.
	SPI2_MISC_DQS_IDLE_EDGE_Msk = 0x1000000
	// Bit DQS_IDLE_EDGE.
	SPI2_MISC_DQS_IDLE_EDGE = 0x1000000
	// Position of CK_IDLE_EDGE field.
	SPI2_MISC_CK_IDLE_EDGE_Pos = 0x1d
	// Bit mask of CK_IDLE_EDGE field.
	SPI2_MISC_CK_IDLE_EDGE_Msk = 0x20000000
	// Bit CK_IDLE_EDGE.
	SPI2_MISC_CK_IDLE_EDGE = 0x20000000
	// Position of CS_KEEP_ACTIVE field.
	SPI2_MISC_CS_KEEP_ACTIVE_Pos = 0x1e
	// Bit mask of CS_KEEP_ACTIVE field.
	SPI2_MISC_CS_KEEP_ACTIVE_Msk = 0x40000000
	// Bit CS_KEEP_ACTIVE.
	SPI2_MISC_CS_KEEP_ACTIVE = 0x40000000
	// Position of QUAD_DIN_PIN_SWAP field.
	SPI2_MISC_QUAD_DIN_PIN_SWAP_Pos = 0x1f
	// Bit mask of QUAD_DIN_PIN_SWAP field.
	SPI2_MISC_QUAD_DIN_PIN_SWAP_Msk = 0x80000000
	// Bit QUAD_DIN_PIN_SWAP.
	SPI2_MISC_QUAD_DIN_PIN_SWAP = 0x80000000

	// DIN_MODE: SPI input delay mode configuration
	// Position of DIN0_MODE field.
	SPI2_DIN_MODE_DIN0_MODE_Pos = 0x0
	// Bit mask of DIN0_MODE field.
	SPI2_DIN_MODE_DIN0_MODE_Msk = 0x3
	// Position of DIN1_MODE field.
	SPI2_DIN_MODE_DIN1_MODE_Pos = 0x2
	// Bit mask of DIN1_MODE field.
	SPI2_DIN_MODE_DIN1_MODE_Msk = 0xc
	// Position of DIN2_MODE field.
	SPI2_DIN_MODE_DIN2_MODE_Pos = 0x4
	// Bit mask of DIN2_MODE field.
	SPI2_DIN_MODE_DIN2_MODE_Msk = 0x30
	// Position of DIN3_MODE field.
	SPI2_DIN_MODE_DIN3_MODE_Pos = 0x6
	// Bit mask of DIN3_MODE field.
	SPI2_DIN_MODE_DIN3_MODE_Msk = 0xc0
	// Position of DIN4_MODE field.
	SPI2_DIN_MODE_DIN4_MODE_Pos = 0x8
	// Bit mask of DIN4_MODE field.
	SPI2_DIN_MODE_DIN4_MODE_Msk = 0x300
	// Position of DIN5_MODE field.
	SPI2_DIN_MODE_DIN5_MODE_Pos = 0xa
	// Bit mask of DIN5_MODE field.
	SPI2_DIN_MODE_DIN5_MODE_Msk = 0xc00
	// Position of DIN6_MODE field.
	SPI2_DIN_MODE_DIN6_MODE_Pos = 0xc
	// Bit mask of DIN6_MODE field.
	SPI2_DIN_MODE_DIN6_MODE_Msk = 0x3000
	// Position of DIN7_MODE field.
	SPI2_DIN_MODE_DIN7_MODE_Pos = 0xe
	// Bit mask of DIN7_MODE field.
	SPI2_DIN_MODE_DIN7_MODE_Msk = 0xc000
	// Position of TIMING_HCLK_ACTIVE field.
	SPI2_DIN_MODE_TIMING_HCLK_ACTIVE_Pos = 0x10
	// Bit mask of TIMING_HCLK_ACTIVE field.
	SPI2_DIN_MODE_TIMING_HCLK_ACTIVE_Msk = 0x10000
	// Bit TIMING_HCLK_ACTIVE.
	SPI2_DIN_MODE_TIMING_HCLK_ACTIVE = 0x10000

	// DIN_NUM: SPI input delay number configuration
	// Position of DIN0_NUM field.
	SPI2_DIN_NUM_DIN0_NUM_Pos = 0x0
	// Bit mask of DIN0_NUM field.
	SPI2_DIN_NUM_DIN0_NUM_Msk = 0x3
	// Position of DIN1_NUM field.
	SPI2_DIN_NUM_DIN1_NUM_Pos = 0x2
	// Bit mask of DIN1_NUM field.
	SPI2_DIN_NUM_DIN1_NUM_Msk = 0xc
	// Position of DIN2_NUM field.
	SPI2_DIN_NUM_DIN2_NUM_Pos = 0x4
	// Bit mask of DIN2_NUM field.
	SPI2_DIN_NUM_DIN2_NUM_Msk = 0x30
	// Position of DIN3_NUM field.
	SPI2_DIN_NUM_DIN3_NUM_Pos = 0x6
	// Bit mask of DIN3_NUM field.
	SPI2_DIN_NUM_DIN3_NUM_Msk = 0xc0
	// Position of DIN4_NUM field.
	SPI2_DIN_NUM_DIN4_NUM_Pos = 0x8
	// Bit mask of DIN4_NUM field.
	SPI2_DIN_NUM_DIN4_NUM_Msk = 0x300
	// Position of DIN5_NUM field.
	SPI2_DIN_NUM_DIN5_NUM_Pos = 0xa
	// Bit mask of DIN5_NUM field.
	SPI2_DIN_NUM_DIN5_NUM_Msk = 0xc00
	// Position of DIN6_NUM field.
	SPI2_DIN_NUM_DIN6_NUM_Pos = 0xc
	// Bit mask of DIN6_NUM field.
	SPI2_DIN_NUM_DIN6_NUM_Msk = 0x3000
	// Position of DIN7_NUM field.
	SPI2_DIN_NUM_DIN7_NUM_Pos = 0xe
	// Bit mask of DIN7_NUM field.
	SPI2_DIN_NUM_DIN7_NUM_Msk = 0xc000

	// DOUT_MODE: SPI output delay mode configuration
	// Position of DOUT0_MODE field.
	SPI2_DOUT_MODE_DOUT0_MODE_Pos = 0x0
	// Bit mask of DOUT0_MODE field.
	SPI2_DOUT_MODE_DOUT0_MODE_Msk = 0x1
	// Bit DOUT0_MODE.
	SPI2_DOUT_MODE_DOUT0_MODE = 0x1
	// Position of DOUT1_MODE field.
	SPI2_DOUT_MODE_DOUT1_MODE_Pos = 0x1
	// Bit mask of DOUT1_MODE field.
	SPI2_DOUT_MODE_DOUT1_MODE_Msk = 0x2
	// Bit DOUT1_MODE.
	SPI2_DOUT_MODE_DOUT1_MODE = 0x2
	// Position of DOUT2_MODE field.
	SPI2_DOUT_MODE_DOUT2_MODE_Pos = 0x2
	// Bit mask of DOUT2_MODE field.
	SPI2_DOUT_MODE_DOUT2_MODE_Msk = 0x4
	// Bit DOUT2_MODE.
	SPI2_DOUT_MODE_DOUT2_MODE = 0x4
	// Position of DOUT3_MODE field.
	SPI2_DOUT_MODE_DOUT3_MODE_Pos = 0x3
	// Bit mask of DOUT3_MODE field.
	SPI2_DOUT_MODE_DOUT3_MODE_Msk = 0x8
	// Bit DOUT3_MODE.
	SPI2_DOUT_MODE_DOUT3_MODE = 0x8
	// Position of DOUT4_MODE field.
	SPI2_DOUT_MODE_DOUT4_MODE_Pos = 0x4
	// Bit mask of DOUT4_MODE field.
	SPI2_DOUT_MODE_DOUT4_MODE_Msk = 0x10
	// Bit DOUT4_MODE.
	SPI2_DOUT_MODE_DOUT4_MODE = 0x10
	// Position of DOUT5_MODE field.
	SPI2_DOUT_MODE_DOUT5_MODE_Pos = 0x5
	// Bit mask of DOUT5_MODE field.
	SPI2_DOUT_MODE_DOUT5_MODE_Msk = 0x20
	// Bit DOUT5_MODE.
	SPI2_DOUT_MODE_DOUT5_MODE = 0x20
	// Position of DOUT6_MODE field.
	SPI2_DOUT_MODE_DOUT6_MODE_Pos = 0x6
	// Bit mask of DOUT6_MODE field.
	SPI2_DOUT_MODE_DOUT6_MODE_Msk = 0x40
	// Bit DOUT6_MODE.
	SPI2_DOUT_MODE_DOUT6_MODE = 0x40
	// Position of DOUT7_MODE field.
	SPI2_DOUT_MODE_DOUT7_MODE_Pos = 0x7
	// Bit mask of DOUT7_MODE field.
	SPI2_DOUT_MODE_DOUT7_MODE_Msk = 0x80
	// Bit DOUT7_MODE.
	SPI2_DOUT_MODE_DOUT7_MODE = 0x80
	// Position of D_DQS_MODE field.
	SPI2_DOUT_MODE_D_DQS_MODE_Pos = 0x8
	// Bit mask of D_DQS_MODE field.
	SPI2_DOUT_MODE_D_DQS_MODE_Msk = 0x100
	// Bit D_DQS_MODE.
	SPI2_DOUT_MODE_D_DQS_MODE = 0x100

	// DMA_CONF: SPI DMA control register
	// Position of DMA_OUTFIFO_EMPTY field.
	SPI2_DMA_CONF_DMA_OUTFIFO_EMPTY_Pos = 0x0
	// Bit mask of DMA_OUTFIFO_EMPTY field.
	SPI2_DMA_CONF_DMA_OUTFIFO_EMPTY_Msk = 0x1
	// Bit DMA_OUTFIFO_EMPTY.
	SPI2_DMA_CONF_DMA_OUTFIFO_EMPTY = 0x1
	// Position of DMA_INFIFO_FULL field.
	SPI2_DMA_CONF_DMA_INFIFO_FULL_Pos = 0x1
	// Bit mask of DMA_INFIFO_FULL field.
	SPI2_DMA_CONF_DMA_INFIFO_FULL_Msk = 0x2
	// Bit DMA_INFIFO_FULL.
	SPI2_DMA_CONF_DMA_INFIFO_FULL = 0x2
	// Position of DMA_SLV_SEG_TRANS_EN field.
	SPI2_DMA_CONF_DMA_SLV_SEG_TRANS_EN_Pos = 0x12
	// Bit mask of DMA_SLV_SEG_TRANS_EN field.
	SPI2_DMA_CONF_DMA_SLV_SEG_TRANS_EN_Msk = 0x40000
	// Bit DMA_SLV_SEG_TRANS_EN.
	SPI2_DMA_CONF_DMA_SLV_SEG_TRANS_EN = 0x40000
	// Position of SLV_RX_SEG_TRANS_CLR_EN field.
	SPI2_DMA_CONF_SLV_RX_SEG_TRANS_CLR_EN_Pos = 0x13
	// Bit mask of SLV_RX_SEG_TRANS_CLR_EN field.
	SPI2_DMA_CONF_SLV_RX_SEG_TRANS_CLR_EN_Msk = 0x80000
	// Bit SLV_RX_SEG_TRANS_CLR_EN.
	SPI2_DMA_CONF_SLV_RX_SEG_TRANS_CLR_EN = 0x80000
	// Position of SLV_TX_SEG_TRANS_CLR_EN field.
	SPI2_DMA_CONF_SLV_TX_SEG_TRANS_CLR_EN_Pos = 0x14
	// Bit mask of SLV_TX_SEG_TRANS_CLR_EN field.
	SPI2_DMA_CONF_SLV_TX_SEG_TRANS_CLR_EN_Msk = 0x100000
	// Bit SLV_TX_SEG_TRANS_CLR_EN.
	SPI2_DMA_CONF_SLV_TX_SEG_TRANS_CLR_EN = 0x100000
	// Position of RX_EOF_EN field.
	SPI2_DMA_CONF_RX_EOF_EN_Pos = 0x15
	// Bit mask of RX_EOF_EN field.
	SPI2_DMA_CONF_RX_EOF_EN_Msk = 0x200000
	// Bit RX_EOF_EN.
	SPI2_DMA_CONF_RX_EOF_EN = 0x200000
	// Position of DMA_RX_ENA field.
	SPI2_DMA_CONF_DMA_RX_ENA_Pos = 0x1b
	// Bit mask of DMA_RX_ENA field.
	SPI2_DMA_CONF_DMA_RX_ENA_Msk = 0x8000000
	// Bit DMA_RX_ENA.
	SPI2_DMA_CONF_DMA_RX_ENA = 0x8000000
	// Position of DMA_TX_ENA field.
	SPI2_DMA_CONF_DMA_TX_ENA_Pos = 0x1c
	// Bit mask of DMA_TX_ENA field.
	SPI2_DMA_CONF_DMA_TX_ENA_Msk = 0x10000000
	// Bit DMA_TX_ENA.
	SPI2_DMA_CONF_DMA_TX_ENA = 0x10000000
	// Position of RX_AFIFO_RST field.
	SPI2_DMA_CONF_RX_AFIFO_RST_Pos = 0x1d
	// Bit mask of RX_AFIFO_RST field.
	SPI2_DMA_CONF_RX_AFIFO_RST_Msk = 0x20000000
	// Bit RX_AFIFO_RST.
	SPI2_DMA_CONF_RX_AFIFO_RST = 0x20000000
	// Position of BUF_AFIFO_RST field.
	SPI2_DMA_CONF_BUF_AFIFO_RST_Pos = 0x1e
	// Bit mask of BUF_AFIFO_RST field.
	SPI2_DMA_CONF_BUF_AFIFO_RST_Msk = 0x40000000
	// Bit BUF_AFIFO_RST.
	SPI2_DMA_CONF_BUF_AFIFO_RST = 0x40000000
	// Position of DMA_AFIFO_RST field.
	SPI2_DMA_CONF_DMA_AFIFO_RST_Pos = 0x1f
	// Bit mask of DMA_AFIFO_RST field.
	SPI2_DMA_CONF_DMA_AFIFO_RST_Msk = 0x80000000
	// Bit DMA_AFIFO_RST.
	SPI2_DMA_CONF_DMA_AFIFO_RST = 0x80000000

	// DMA_INT_ENA: SPI interrupt enable register
	// Position of DMA_INFIFO_FULL_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_DMA_INFIFO_FULL_ERR_INT_ENA_Pos = 0x0
	// Bit mask of DMA_INFIFO_FULL_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_DMA_INFIFO_FULL_ERR_INT_ENA_Msk = 0x1
	// Bit DMA_INFIFO_FULL_ERR_INT_ENA.
	SPI2_DMA_INT_ENA_DMA_INFIFO_FULL_ERR_INT_ENA = 0x1
	// Position of DMA_OUTFIFO_EMPTY_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_DMA_OUTFIFO_EMPTY_ERR_INT_ENA_Pos = 0x1
	// Bit mask of DMA_OUTFIFO_EMPTY_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_DMA_OUTFIFO_EMPTY_ERR_INT_ENA_Msk = 0x2
	// Bit DMA_OUTFIFO_EMPTY_ERR_INT_ENA.
	SPI2_DMA_INT_ENA_DMA_OUTFIFO_EMPTY_ERR_INT_ENA = 0x2
	// Position of SLV_EX_QPI_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_EX_QPI_INT_ENA_Pos = 0x2
	// Bit mask of SLV_EX_QPI_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_EX_QPI_INT_ENA_Msk = 0x4
	// Bit SLV_EX_QPI_INT_ENA.
	SPI2_DMA_INT_ENA_SLV_EX_QPI_INT_ENA = 0x4
	// Position of SLV_EN_QPI_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_EN_QPI_INT_ENA_Pos = 0x3
	// Bit mask of SLV_EN_QPI_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_EN_QPI_INT_ENA_Msk = 0x8
	// Bit SLV_EN_QPI_INT_ENA.
	SPI2_DMA_INT_ENA_SLV_EN_QPI_INT_ENA = 0x8
	// Position of SLV_CMD7_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_CMD7_INT_ENA_Pos = 0x4
	// Bit mask of SLV_CMD7_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_CMD7_INT_ENA_Msk = 0x10
	// Bit SLV_CMD7_INT_ENA.
	SPI2_DMA_INT_ENA_SLV_CMD7_INT_ENA = 0x10
	// Position of SLV_CMD8_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_CMD8_INT_ENA_Pos = 0x5
	// Bit mask of SLV_CMD8_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_CMD8_INT_ENA_Msk = 0x20
	// Bit SLV_CMD8_INT_ENA.
	SPI2_DMA_INT_ENA_SLV_CMD8_INT_ENA = 0x20
	// Position of SLV_CMD9_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_CMD9_INT_ENA_Pos = 0x6
	// Bit mask of SLV_CMD9_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_CMD9_INT_ENA_Msk = 0x40
	// Bit SLV_CMD9_INT_ENA.
	SPI2_DMA_INT_ENA_SLV_CMD9_INT_ENA = 0x40
	// Position of SLV_CMDA_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_CMDA_INT_ENA_Pos = 0x7
	// Bit mask of SLV_CMDA_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_CMDA_INT_ENA_Msk = 0x80
	// Bit SLV_CMDA_INT_ENA.
	SPI2_DMA_INT_ENA_SLV_CMDA_INT_ENA = 0x80
	// Position of SLV_RD_DMA_DONE_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_RD_DMA_DONE_INT_ENA_Pos = 0x8
	// Bit mask of SLV_RD_DMA_DONE_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_RD_DMA_DONE_INT_ENA_Msk = 0x100
	// Bit SLV_RD_DMA_DONE_INT_ENA.
	SPI2_DMA_INT_ENA_SLV_RD_DMA_DONE_INT_ENA = 0x100
	// Position of SLV_WR_DMA_DONE_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_WR_DMA_DONE_INT_ENA_Pos = 0x9
	// Bit mask of SLV_WR_DMA_DONE_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_WR_DMA_DONE_INT_ENA_Msk = 0x200
	// Bit SLV_WR_DMA_DONE_INT_ENA.
	SPI2_DMA_INT_ENA_SLV_WR_DMA_DONE_INT_ENA = 0x200
	// Position of SLV_RD_BUF_DONE_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_RD_BUF_DONE_INT_ENA_Pos = 0xa
	// Bit mask of SLV_RD_BUF_DONE_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_RD_BUF_DONE_INT_ENA_Msk = 0x400
	// Bit SLV_RD_BUF_DONE_INT_ENA.
	SPI2_DMA_INT_ENA_SLV_RD_BUF_DONE_INT_ENA = 0x400
	// Position of SLV_WR_BUF_DONE_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_WR_BUF_DONE_INT_ENA_Pos = 0xb
	// Bit mask of SLV_WR_BUF_DONE_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_WR_BUF_DONE_INT_ENA_Msk = 0x800
	// Bit SLV_WR_BUF_DONE_INT_ENA.
	SPI2_DMA_INT_ENA_SLV_WR_BUF_DONE_INT_ENA = 0x800
	// Position of TRANS_DONE_INT_ENA field.
	SPI2_DMA_INT_ENA_TRANS_DONE_INT_ENA_Pos = 0xc
	// Bit mask of TRANS_DONE_INT_ENA field.
	SPI2_DMA_INT_ENA_TRANS_DONE_INT_ENA_Msk = 0x1000
	// Bit TRANS_DONE_INT_ENA.
	SPI2_DMA_INT_ENA_TRANS_DONE_INT_ENA = 0x1000
	// Position of DMA_SEG_TRANS_DONE_INT_ENA field.
	SPI2_DMA_INT_ENA_DMA_SEG_TRANS_DONE_INT_ENA_Pos = 0xd
	// Bit mask of DMA_SEG_TRANS_DONE_INT_ENA field.
	SPI2_DMA_INT_ENA_DMA_SEG_TRANS_DONE_INT_ENA_Msk = 0x2000
	// Bit DMA_SEG_TRANS_DONE_INT_ENA.
	SPI2_DMA_INT_ENA_DMA_SEG_TRANS_DONE_INT_ENA = 0x2000
	// Position of SEG_MAGIC_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_SEG_MAGIC_ERR_INT_ENA_Pos = 0xe
	// Bit mask of SEG_MAGIC_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_SEG_MAGIC_ERR_INT_ENA_Msk = 0x4000
	// Bit SEG_MAGIC_ERR_INT_ENA.
	SPI2_DMA_INT_ENA_SEG_MAGIC_ERR_INT_ENA = 0x4000
	// Position of SLV_BUF_ADDR_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_BUF_ADDR_ERR_INT_ENA_Pos = 0xf
	// Bit mask of SLV_BUF_ADDR_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_BUF_ADDR_ERR_INT_ENA_Msk = 0x8000
	// Bit SLV_BUF_ADDR_ERR_INT_ENA.
	SPI2_DMA_INT_ENA_SLV_BUF_ADDR_ERR_INT_ENA = 0x8000
	// Position of SLV_CMD_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_CMD_ERR_INT_ENA_Pos = 0x10
	// Bit mask of SLV_CMD_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_SLV_CMD_ERR_INT_ENA_Msk = 0x10000
	// Bit SLV_CMD_ERR_INT_ENA.
	SPI2_DMA_INT_ENA_SLV_CMD_ERR_INT_ENA = 0x10000
	// Position of MST_RX_AFIFO_WFULL_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_MST_RX_AFIFO_WFULL_ERR_INT_ENA_Pos = 0x11
	// Bit mask of MST_RX_AFIFO_WFULL_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_MST_RX_AFIFO_WFULL_ERR_INT_ENA_Msk = 0x20000
	// Bit MST_RX_AFIFO_WFULL_ERR_INT_ENA.
	SPI2_DMA_INT_ENA_MST_RX_AFIFO_WFULL_ERR_INT_ENA = 0x20000
	// Position of MST_TX_AFIFO_REMPTY_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_MST_TX_AFIFO_REMPTY_ERR_INT_ENA_Pos = 0x12
	// Bit mask of MST_TX_AFIFO_REMPTY_ERR_INT_ENA field.
	SPI2_DMA_INT_ENA_MST_TX_AFIFO_REMPTY_ERR_INT_ENA_Msk = 0x40000
	// Bit MST_TX_AFIFO_REMPTY_ERR_INT_ENA.
	SPI2_DMA_INT_ENA_MST_TX_AFIFO_REMPTY_ERR_INT_ENA = 0x40000
	// Position of APP2_INT_ENA field.
	SPI2_DMA_INT_ENA_APP2_INT_ENA_Pos = 0x13
	// Bit mask of APP2_INT_ENA field.
	SPI2_DMA_INT_ENA_APP2_INT_ENA_Msk = 0x80000
	// Bit APP2_INT_ENA.
	SPI2_DMA_INT_ENA_APP2_INT_ENA = 0x80000
	// Position of APP1_INT_ENA field.
	SPI2_DMA_INT_ENA_APP1_INT_ENA_Pos = 0x14
	// Bit mask of APP1_INT_ENA field.
	SPI2_DMA_INT_ENA_APP1_INT_ENA_Msk = 0x100000
	// Bit APP1_INT_ENA.
	SPI2_DMA_INT_ENA_APP1_INT_ENA = 0x100000

	// DMA_INT_CLR: SPI interrupt clear register
	// Position of DMA_INFIFO_FULL_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_DMA_INFIFO_FULL_ERR_INT_CLR_Pos = 0x0
	// Bit mask of DMA_INFIFO_FULL_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_DMA_INFIFO_FULL_ERR_INT_CLR_Msk = 0x1
	// Bit DMA_INFIFO_FULL_ERR_INT_CLR.
	SPI2_DMA_INT_CLR_DMA_INFIFO_FULL_ERR_INT_CLR = 0x1
	// Position of DMA_OUTFIFO_EMPTY_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_DMA_OUTFIFO_EMPTY_ERR_INT_CLR_Pos = 0x1
	// Bit mask of DMA_OUTFIFO_EMPTY_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_DMA_OUTFIFO_EMPTY_ERR_INT_CLR_Msk = 0x2
	// Bit DMA_OUTFIFO_EMPTY_ERR_INT_CLR.
	SPI2_DMA_INT_CLR_DMA_OUTFIFO_EMPTY_ERR_INT_CLR = 0x2
	// Position of SLV_EX_QPI_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_EX_QPI_INT_CLR_Pos = 0x2
	// Bit mask of SLV_EX_QPI_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_EX_QPI_INT_CLR_Msk = 0x4
	// Bit SLV_EX_QPI_INT_CLR.
	SPI2_DMA_INT_CLR_SLV_EX_QPI_INT_CLR = 0x4
	// Position of SLV_EN_QPI_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_EN_QPI_INT_CLR_Pos = 0x3
	// Bit mask of SLV_EN_QPI_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_EN_QPI_INT_CLR_Msk = 0x8
	// Bit SLV_EN_QPI_INT_CLR.
	SPI2_DMA_INT_CLR_SLV_EN_QPI_INT_CLR = 0x8
	// Position of SLV_CMD7_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_CMD7_INT_CLR_Pos = 0x4
	// Bit mask of SLV_CMD7_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_CMD7_INT_CLR_Msk = 0x10
	// Bit SLV_CMD7_INT_CLR.
	SPI2_DMA_INT_CLR_SLV_CMD7_INT_CLR = 0x10
	// Position of SLV_CMD8_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_CMD8_INT_CLR_Pos = 0x5
	// Bit mask of SLV_CMD8_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_CMD8_INT_CLR_Msk = 0x20
	// Bit SLV_CMD8_INT_CLR.
	SPI2_DMA_INT_CLR_SLV_CMD8_INT_CLR = 0x20
	// Position of SLV_CMD9_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_CMD9_INT_CLR_Pos = 0x6
	// Bit mask of SLV_CMD9_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_CMD9_INT_CLR_Msk = 0x40
	// Bit SLV_CMD9_INT_CLR.
	SPI2_DMA_INT_CLR_SLV_CMD9_INT_CLR = 0x40
	// Position of SLV_CMDA_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_CMDA_INT_CLR_Pos = 0x7
	// Bit mask of SLV_CMDA_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_CMDA_INT_CLR_Msk = 0x80
	// Bit SLV_CMDA_INT_CLR.
	SPI2_DMA_INT_CLR_SLV_CMDA_INT_CLR = 0x80
	// Position of SLV_RD_DMA_DONE_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_RD_DMA_DONE_INT_CLR_Pos = 0x8
	// Bit mask of SLV_RD_DMA_DONE_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_RD_DMA_DONE_INT_CLR_Msk = 0x100
	// Bit SLV_RD_DMA_DONE_INT_CLR.
	SPI2_DMA_INT_CLR_SLV_RD_DMA_DONE_INT_CLR = 0x100
	// Position of SLV_WR_DMA_DONE_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_WR_DMA_DONE_INT_CLR_Pos = 0x9
	// Bit mask of SLV_WR_DMA_DONE_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_WR_DMA_DONE_INT_CLR_Msk = 0x200
	// Bit SLV_WR_DMA_DONE_INT_CLR.
	SPI2_DMA_INT_CLR_SLV_WR_DMA_DONE_INT_CLR = 0x200
	// Position of SLV_RD_BUF_DONE_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_RD_BUF_DONE_INT_CLR_Pos = 0xa
	// Bit mask of SLV_RD_BUF_DONE_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_RD_BUF_DONE_INT_CLR_Msk = 0x400
	// Bit SLV_RD_BUF_DONE_INT_CLR.
	SPI2_DMA_INT_CLR_SLV_RD_BUF_DONE_INT_CLR = 0x400
	// Position of SLV_WR_BUF_DONE_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_WR_BUF_DONE_INT_CLR_Pos = 0xb
	// Bit mask of SLV_WR_BUF_DONE_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_WR_BUF_DONE_INT_CLR_Msk = 0x800
	// Bit SLV_WR_BUF_DONE_INT_CLR.
	SPI2_DMA_INT_CLR_SLV_WR_BUF_DONE_INT_CLR = 0x800
	// Position of TRANS_DONE_INT_CLR field.
	SPI2_DMA_INT_CLR_TRANS_DONE_INT_CLR_Pos = 0xc
	// Bit mask of TRANS_DONE_INT_CLR field.
	SPI2_DMA_INT_CLR_TRANS_DONE_INT_CLR_Msk = 0x1000
	// Bit TRANS_DONE_INT_CLR.
	SPI2_DMA_INT_CLR_TRANS_DONE_INT_CLR = 0x1000
	// Position of DMA_SEG_TRANS_DONE_INT_CLR field.
	SPI2_DMA_INT_CLR_DMA_SEG_TRANS_DONE_INT_CLR_Pos = 0xd
	// Bit mask of DMA_SEG_TRANS_DONE_INT_CLR field.
	SPI2_DMA_INT_CLR_DMA_SEG_TRANS_DONE_INT_CLR_Msk = 0x2000
	// Bit DMA_SEG_TRANS_DONE_INT_CLR.
	SPI2_DMA_INT_CLR_DMA_SEG_TRANS_DONE_INT_CLR = 0x2000
	// Position of SEG_MAGIC_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_SEG_MAGIC_ERR_INT_CLR_Pos = 0xe
	// Bit mask of SEG_MAGIC_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_SEG_MAGIC_ERR_INT_CLR_Msk = 0x4000
	// Bit SEG_MAGIC_ERR_INT_CLR.
	SPI2_DMA_INT_CLR_SEG_MAGIC_ERR_INT_CLR = 0x4000
	// Position of SLV_BUF_ADDR_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_BUF_ADDR_ERR_INT_CLR_Pos = 0xf
	// Bit mask of SLV_BUF_ADDR_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_BUF_ADDR_ERR_INT_CLR_Msk = 0x8000
	// Bit SLV_BUF_ADDR_ERR_INT_CLR.
	SPI2_DMA_INT_CLR_SLV_BUF_ADDR_ERR_INT_CLR = 0x8000
	// Position of SLV_CMD_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_CMD_ERR_INT_CLR_Pos = 0x10
	// Bit mask of SLV_CMD_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_SLV_CMD_ERR_INT_CLR_Msk = 0x10000
	// Bit SLV_CMD_ERR_INT_CLR.
	SPI2_DMA_INT_CLR_SLV_CMD_ERR_INT_CLR = 0x10000
	// Position of MST_RX_AFIFO_WFULL_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_MST_RX_AFIFO_WFULL_ERR_INT_CLR_Pos = 0x11
	// Bit mask of MST_RX_AFIFO_WFULL_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_MST_RX_AFIFO_WFULL_ERR_INT_CLR_Msk = 0x20000
	// Bit MST_RX_AFIFO_WFULL_ERR_INT_CLR.
	SPI2_DMA_INT_CLR_MST_RX_AFIFO_WFULL_ERR_INT_CLR = 0x20000
	// Position of MST_TX_AFIFO_REMPTY_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_MST_TX_AFIFO_REMPTY_ERR_INT_CLR_Pos = 0x12
	// Bit mask of MST_TX_AFIFO_REMPTY_ERR_INT_CLR field.
	SPI2_DMA_INT_CLR_MST_TX_AFIFO_REMPTY_ERR_INT_CLR_Msk = 0x40000
	// Bit MST_TX_AFIFO_REMPTY_ERR_INT_CLR.
	SPI2_DMA_INT_CLR_MST_TX_AFIFO_REMPTY_ERR_INT_CLR = 0x40000
	// Position of APP2_INT_CLR field.
	SPI2_DMA_INT_CLR_APP2_INT_CLR_Pos = 0x13
	// Bit mask of APP2_INT_CLR field.
	SPI2_DMA_INT_CLR_APP2_INT_CLR_Msk = 0x80000
	// Bit APP2_INT_CLR.
	SPI2_DMA_INT_CLR_APP2_INT_CLR = 0x80000
	// Position of APP1_INT_CLR field.
	SPI2_DMA_INT_CLR_APP1_INT_CLR_Pos = 0x14
	// Bit mask of APP1_INT_CLR field.
	SPI2_DMA_INT_CLR_APP1_INT_CLR_Msk = 0x100000
	// Bit APP1_INT_CLR.
	SPI2_DMA_INT_CLR_APP1_INT_CLR = 0x100000

	// DMA_INT_RAW: SPI interrupt raw register
	// Position of DMA_INFIFO_FULL_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_DMA_INFIFO_FULL_ERR_INT_RAW_Pos = 0x0
	// Bit mask of DMA_INFIFO_FULL_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_DMA_INFIFO_FULL_ERR_INT_RAW_Msk = 0x1
	// Bit DMA_INFIFO_FULL_ERR_INT_RAW.
	SPI2_DMA_INT_RAW_DMA_INFIFO_FULL_ERR_INT_RAW = 0x1
	// Position of DMA_OUTFIFO_EMPTY_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_DMA_OUTFIFO_EMPTY_ERR_INT_RAW_Pos = 0x1
	// Bit mask of DMA_OUTFIFO_EMPTY_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_DMA_OUTFIFO_EMPTY_ERR_INT_RAW_Msk = 0x2
	// Bit DMA_OUTFIFO_EMPTY_ERR_INT_RAW.
	SPI2_DMA_INT_RAW_DMA_OUTFIFO_EMPTY_ERR_INT_RAW = 0x2
	// Position of SLV_EX_QPI_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_EX_QPI_INT_RAW_Pos = 0x2
	// Bit mask of SLV_EX_QPI_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_EX_QPI_INT_RAW_Msk = 0x4
	// Bit SLV_EX_QPI_INT_RAW.
	SPI2_DMA_INT_RAW_SLV_EX_QPI_INT_RAW = 0x4
	// Position of SLV_EN_QPI_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_EN_QPI_INT_RAW_Pos = 0x3
	// Bit mask of SLV_EN_QPI_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_EN_QPI_INT_RAW_Msk = 0x8
	// Bit SLV_EN_QPI_INT_RAW.
	SPI2_DMA_INT_RAW_SLV_EN_QPI_INT_RAW = 0x8
	// Position of SLV_CMD7_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_CMD7_INT_RAW_Pos = 0x4
	// Bit mask of SLV_CMD7_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_CMD7_INT_RAW_Msk = 0x10
	// Bit SLV_CMD7_INT_RAW.
	SPI2_DMA_INT_RAW_SLV_CMD7_INT_RAW = 0x10
	// Position of SLV_CMD8_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_CMD8_INT_RAW_Pos = 0x5
	// Bit mask of SLV_CMD8_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_CMD8_INT_RAW_Msk = 0x20
	// Bit SLV_CMD8_INT_RAW.
	SPI2_DMA_INT_RAW_SLV_CMD8_INT_RAW = 0x20
	// Position of SLV_CMD9_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_CMD9_INT_RAW_Pos = 0x6
	// Bit mask of SLV_CMD9_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_CMD9_INT_RAW_Msk = 0x40
	// Bit SLV_CMD9_INT_RAW.
	SPI2_DMA_INT_RAW_SLV_CMD9_INT_RAW = 0x40
	// Position of SLV_CMDA_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_CMDA_INT_RAW_Pos = 0x7
	// Bit mask of SLV_CMDA_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_CMDA_INT_RAW_Msk = 0x80
	// Bit SLV_CMDA_INT_RAW.
	SPI2_DMA_INT_RAW_SLV_CMDA_INT_RAW = 0x80
	// Position of SLV_RD_DMA_DONE_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_RD_DMA_DONE_INT_RAW_Pos = 0x8
	// Bit mask of SLV_RD_DMA_DONE_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_RD_DMA_DONE_INT_RAW_Msk = 0x100
	// Bit SLV_RD_DMA_DONE_INT_RAW.
	SPI2_DMA_INT_RAW_SLV_RD_DMA_DONE_INT_RAW = 0x100
	// Position of SLV_WR_DMA_DONE_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_WR_DMA_DONE_INT_RAW_Pos = 0x9
	// Bit mask of SLV_WR_DMA_DONE_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_WR_DMA_DONE_INT_RAW_Msk = 0x200
	// Bit SLV_WR_DMA_DONE_INT_RAW.
	SPI2_DMA_INT_RAW_SLV_WR_DMA_DONE_INT_RAW = 0x200
	// Position of SLV_RD_BUF_DONE_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_RD_BUF_DONE_INT_RAW_Pos = 0xa
	// Bit mask of SLV_RD_BUF_DONE_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_RD_BUF_DONE_INT_RAW_Msk = 0x400
	// Bit SLV_RD_BUF_DONE_INT_RAW.
	SPI2_DMA_INT_RAW_SLV_RD_BUF_DONE_INT_RAW = 0x400
	// Position of SLV_WR_BUF_DONE_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_WR_BUF_DONE_INT_RAW_Pos = 0xb
	// Bit mask of SLV_WR_BUF_DONE_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_WR_BUF_DONE_INT_RAW_Msk = 0x800
	// Bit SLV_WR_BUF_DONE_INT_RAW.
	SPI2_DMA_INT_RAW_SLV_WR_BUF_DONE_INT_RAW = 0x800
	// Position of TRANS_DONE_INT_RAW field.
	SPI2_DMA_INT_RAW_TRANS_DONE_INT_RAW_Pos = 0xc
	// Bit mask of TRANS_DONE_INT_RAW field.
	SPI2_DMA_INT_RAW_TRANS_DONE_INT_RAW_Msk = 0x1000
	// Bit TRANS_DONE_INT_RAW.
	SPI2_DMA_INT_RAW_TRANS_DONE_INT_RAW = 0x1000
	// Position of DMA_SEG_TRANS_DONE_INT_RAW field.
	SPI2_DMA_INT_RAW_DMA_SEG_TRANS_DONE_INT_RAW_Pos = 0xd
	// Bit mask of DMA_SEG_TRANS_DONE_INT_RAW field.
	SPI2_DMA_INT_RAW_DMA_SEG_TRANS_DONE_INT_RAW_Msk = 0x2000
	// Bit DMA_SEG_TRANS_DONE_INT_RAW.
	SPI2_DMA_INT_RAW_DMA_SEG_TRANS_DONE_INT_RAW = 0x2000
	// Position of SEG_MAGIC_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_SEG_MAGIC_ERR_INT_RAW_Pos = 0xe
	// Bit mask of SEG_MAGIC_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_SEG_MAGIC_ERR_INT_RAW_Msk = 0x4000
	// Bit SEG_MAGIC_ERR_INT_RAW.
	SPI2_DMA_INT_RAW_SEG_MAGIC_ERR_INT_RAW = 0x4000
	// Position of SLV_BUF_ADDR_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_BUF_ADDR_ERR_INT_RAW_Pos = 0xf
	// Bit mask of SLV_BUF_ADDR_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_BUF_ADDR_ERR_INT_RAW_Msk = 0x8000
	// Bit SLV_BUF_ADDR_ERR_INT_RAW.
	SPI2_DMA_INT_RAW_SLV_BUF_ADDR_ERR_INT_RAW = 0x8000
	// Position of SLV_CMD_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_CMD_ERR_INT_RAW_Pos = 0x10
	// Bit mask of SLV_CMD_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_SLV_CMD_ERR_INT_RAW_Msk = 0x10000
	// Bit SLV_CMD_ERR_INT_RAW.
	SPI2_DMA_INT_RAW_SLV_CMD_ERR_INT_RAW = 0x10000
	// Position of MST_RX_AFIFO_WFULL_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_MST_RX_AFIFO_WFULL_ERR_INT_RAW_Pos = 0x11
	// Bit mask of MST_RX_AFIFO_WFULL_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_MST_RX_AFIFO_WFULL_ERR_INT_RAW_Msk = 0x20000
	// Bit MST_RX_AFIFO_WFULL_ERR_INT_RAW.
	SPI2_DMA_INT_RAW_MST_RX_AFIFO_WFULL_ERR_INT_RAW = 0x20000
	// Position of MST_TX_AFIFO_REMPTY_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_MST_TX_AFIFO_REMPTY_ERR_INT_RAW_Pos = 0x12
	// Bit mask of MST_TX_AFIFO_REMPTY_ERR_INT_RAW field.
	SPI2_DMA_INT_RAW_MST_TX_AFIFO_REMPTY_ERR_INT_RAW_Msk = 0x40000
	// Bit MST_TX_AFIFO_REMPTY_ERR_INT_RAW.
	SPI2_DMA_INT_RAW_MST_TX_AFIFO_REMPTY_ERR_INT_RAW = 0x40000
	// Position of APP2_INT_RAW field.
	SPI2_DMA_INT_RAW_APP2_INT_RAW_Pos = 0x13
	// Bit mask of APP2_INT_RAW field.
	SPI2_DMA_INT_RAW_APP2_INT_RAW_Msk = 0x80000
	// Bit APP2_INT_RAW.
	SPI2_DMA_INT_RAW_APP2_INT_RAW = 0x80000
	// Position of APP1_INT_RAW field.
	SPI2_DMA_INT_RAW_APP1_INT_RAW_Pos = 0x14
	// Bit mask of APP1_INT_RAW field.
	SPI2_DMA_INT_RAW_APP1_INT_RAW_Msk = 0x100000
	// Bit APP1_INT_RAW.
	SPI2_DMA_INT_RAW_APP1_INT_RAW = 0x100000

	// DMA_INT_ST: SPI interrupt status register
	// Position of DMA_INFIFO_FULL_ERR_INT_ST field.
	SPI2_DMA_INT_ST_DMA_INFIFO_FULL_ERR_INT_ST_Pos = 0x0
	// Bit mask of DMA_INFIFO_FULL_ERR_INT_ST field.
	SPI2_DMA_INT_ST_DMA_INFIFO_FULL_ERR_INT_ST_Msk = 0x1
	// Bit DMA_INFIFO_FULL_ERR_INT_ST.
	SPI2_DMA_INT_ST_DMA_INFIFO_FULL_ERR_INT_ST = 0x1
	// Position of DMA_OUTFIFO_EMPTY_ERR_INT_ST field.
	SPI2_DMA_INT_ST_DMA_OUTFIFO_EMPTY_ERR_INT_ST_Pos = 0x1
	// Bit mask of DMA_OUTFIFO_EMPTY_ERR_INT_ST field.
	SPI2_DMA_INT_ST_DMA_OUTFIFO_EMPTY_ERR_INT_ST_Msk = 0x2
	// Bit DMA_OUTFIFO_EMPTY_ERR_INT_ST.
	SPI2_DMA_INT_ST_DMA_OUTFIFO_EMPTY_ERR_INT_ST = 0x2
	// Position of SLV_EX_QPI_INT_ST field.
	SPI2_DMA_INT_ST_SLV_EX_QPI_INT_ST_Pos = 0x2
	// Bit mask of SLV_EX_QPI_INT_ST field.
	SPI2_DMA_INT_ST_SLV_EX_QPI_INT_ST_Msk = 0x4
	// Bit SLV_EX_QPI_INT_ST.
	SPI2_DMA_INT_ST_SLV_EX_QPI_INT_ST = 0x4
	// Position of SLV_EN_QPI_INT_ST field.
	SPI2_DMA_INT_ST_SLV_EN_QPI_INT_ST_Pos = 0x3
	// Bit mask of SLV_EN_QPI_INT_ST field.
	SPI2_DMA_INT_ST_SLV_EN_QPI_INT_ST_Msk = 0x8
	// Bit SLV_EN_QPI_INT_ST.
	SPI2_DMA_INT_ST_SLV_EN_QPI_INT_ST = 0x8
	// Position of SLV_CMD7_INT_ST field.
	SPI2_DMA_INT_ST_SLV_CMD7_INT_ST_Pos = 0x4
	// Bit mask of SLV_CMD7_INT_ST field.
	SPI2_DMA_INT_ST_SLV_CMD7_INT_ST_Msk = 0x10
	// Bit SLV_CMD7_INT_ST.
	SPI2_DMA_INT_ST_SLV_CMD7_INT_ST = 0x10
	// Position of SLV_CMD8_INT_ST field.
	SPI2_DMA_INT_ST_SLV_CMD8_INT_ST_Pos = 0x5
	// Bit mask of SLV_CMD8_INT_ST field.
	SPI2_DMA_INT_ST_SLV_CMD8_INT_ST_Msk = 0x20
	// Bit SLV_CMD8_INT_ST.
	SPI2_DMA_INT_ST_SLV_CMD8_INT_ST = 0x20
	// Position of SLV_CMD9_INT_ST field.
	SPI2_DMA_INT_ST_SLV_CMD9_INT_ST_Pos = 0x6
	// Bit mask of SLV_CMD9_INT_ST field.
	SPI2_DMA_INT_ST_SLV_CMD9_INT_ST_Msk = 0x40
	// Bit SLV_CMD9_INT_ST.
	SPI2_DMA_INT_ST_SLV_CMD9_INT_ST = 0x40
	// Position of SLV_CMDA_INT_ST field.
	SPI2_DMA_INT_ST_SLV_CMDA_INT_ST_Pos = 0x7
	// Bit mask of SLV_CMDA_INT_ST field.
	SPI2_DMA_INT_ST_SLV_CMDA_INT_ST_Msk = 0x80
	// Bit SLV_CMDA_INT_ST.
	SPI2_DMA_INT_ST_SLV_CMDA_INT_ST = 0x80
	// Position of SLV_RD_DMA_DONE_INT_ST field.
	SPI2_DMA_INT_ST_SLV_RD_DMA_DONE_INT_ST_Pos = 0x8
	// Bit mask of SLV_RD_DMA_DONE_INT_ST field.
	SPI2_DMA_INT_ST_SLV_RD_DMA_DONE_INT_ST_Msk = 0x100
	// Bit SLV_RD_DMA_DONE_INT_ST.
	SPI2_DMA_INT_ST_SLV_RD_DMA_DONE_INT_ST = 0x100
	// Position of SLV_WR_DMA_DONE_INT_ST field.
	SPI2_DMA_INT_ST_SLV_WR_DMA_DONE_INT_ST_Pos = 0x9
	// Bit mask of SLV_WR_DMA_DONE_INT_ST field.
	SPI2_DMA_INT_ST_SLV_WR_DMA_DONE_INT_ST_Msk = 0x200
	// Bit SLV_WR_DMA_DONE_INT_ST.
	SPI2_DMA_INT_ST_SLV_WR_DMA_DONE_INT_ST = 0x200
	// Position of SLV_RD_BUF_DONE_INT_ST field.
	SPI2_DMA_INT_ST_SLV_RD_BUF_DONE_INT_ST_Pos = 0xa
	// Bit mask of SLV_RD_BUF_DONE_INT_ST field.
	SPI2_DMA_INT_ST_SLV_RD_BUF_DONE_INT_ST_Msk = 0x400
	// Bit SLV_RD_BUF_DONE_INT_ST.
	SPI2_DMA_INT_ST_SLV_RD_BUF_DONE_INT_ST = 0x400
	// Position of SLV_WR_BUF_DONE_INT_ST field.
	SPI2_DMA_INT_ST_SLV_WR_BUF_DONE_INT_ST_Pos = 0xb
	// Bit mask of SLV_WR_BUF_DONE_INT_ST field.
	SPI2_DMA_INT_ST_SLV_WR_BUF_DONE_INT_ST_Msk = 0x800
	// Bit SLV_WR_BUF_DONE_INT_ST.
	SPI2_DMA_INT_ST_SLV_WR_BUF_DONE_INT_ST = 0x800
	// Position of TRANS_DONE_INT_ST field.
	SPI2_DMA_INT_ST_TRANS_DONE_INT_ST_Pos = 0xc
	// Bit mask of TRANS_DONE_INT_ST field.
	SPI2_DMA_INT_ST_TRANS_DONE_INT_ST_Msk = 0x1000
	// Bit TRANS_DONE_INT_ST.
	SPI2_DMA_INT_ST_TRANS_DONE_INT_ST = 0x1000
	// Position of DMA_SEG_TRANS_DONE_INT_ST field.
	SPI2_DMA_INT_ST_DMA_SEG_TRANS_DONE_INT_ST_Pos = 0xd
	// Bit mask of DMA_SEG_TRANS_DONE_INT_ST field.
	SPI2_DMA_INT_ST_DMA_SEG_TRANS_DONE_INT_ST_Msk = 0x2000
	// Bit DMA_SEG_TRANS_DONE_INT_ST.
	SPI2_DMA_INT_ST_DMA_SEG_TRANS_DONE_INT_ST = 0x2000
	// Position of SEG_MAGIC_ERR_INT_ST field.
	SPI2_DMA_INT_ST_SEG_MAGIC_ERR_INT_ST_Pos = 0xe
	// Bit mask of SEG_MAGIC_ERR_INT_ST field.
	SPI2_DMA_INT_ST_SEG_MAGIC_ERR_INT_ST_Msk = 0x4000
	// Bit SEG_MAGIC_ERR_INT_ST.
	SPI2_DMA_INT_ST_SEG_MAGIC_ERR_INT_ST = 0x4000
	// Position of SLV_BUF_ADDR_ERR_INT_ST field.
	SPI2_DMA_INT_ST_SLV_BUF_ADDR_ERR_INT_ST_Pos = 0xf
	// Bit mask of SLV_BUF_ADDR_ERR_INT_ST field.
	SPI2_DMA_INT_ST_SLV_BUF_ADDR_ERR_INT_ST_Msk = 0x8000
	// Bit SLV_BUF_ADDR_ERR_INT_ST.
	SPI2_DMA_INT_ST_SLV_BUF_ADDR_ERR_INT_ST = 0x8000
	// Position of SLV_CMD_ERR_INT_ST field.
	SPI2_DMA_INT_ST_SLV_CMD_ERR_INT_ST_Pos = 0x10
	// Bit mask of SLV_CMD_ERR_INT_ST field.
	SPI2_DMA_INT_ST_SLV_CMD_ERR_INT_ST_Msk = 0x10000
	// Bit SLV_CMD_ERR_INT_ST.
	SPI2_DMA_INT_ST_SLV_CMD_ERR_INT_ST = 0x10000
	// Position of MST_RX_AFIFO_WFULL_ERR_INT_ST field.
	SPI2_DMA_INT_ST_MST_RX_AFIFO_WFULL_ERR_INT_ST_Pos = 0x11
	// Bit mask of MST_RX_AFIFO_WFULL_ERR_INT_ST field.
	SPI2_DMA_INT_ST_MST_RX_AFIFO_WFULL_ERR_INT_ST_Msk = 0x20000
	// Bit MST_RX_AFIFO_WFULL_ERR_INT_ST.
	SPI2_DMA_INT_ST_MST_RX_AFIFO_WFULL_ERR_INT_ST = 0x20000
	// Position of MST_TX_AFIFO_REMPTY_ERR_INT_ST field.
	SPI2_DMA_INT_ST_MST_TX_AFIFO_REMPTY_ERR_INT_ST_Pos = 0x12
	// Bit mask of MST_TX_AFIFO_REMPTY_ERR_INT_ST field.
	SPI2_DMA_INT_ST_MST_TX_AFIFO_REMPTY_ERR_INT_ST_Msk = 0x40000
	// Bit MST_TX_AFIFO_REMPTY_ERR_INT_ST.
	SPI2_DMA_INT_ST_MST_TX_AFIFO_REMPTY_ERR_INT_ST = 0x40000
	// Position of APP2_INT_ST field.
	SPI2_DMA_INT_ST_APP2_INT_ST_Pos = 0x13
	// Bit mask of APP2_INT_ST field.
	SPI2_DMA_INT_ST_APP2_INT_ST_Msk = 0x80000
	// Bit APP2_INT_ST.
	SPI2_DMA_INT_ST_APP2_INT_ST = 0x80000
	// Position of APP1_INT_ST field.
	SPI2_DMA_INT_ST_APP1_INT_ST_Pos = 0x14
	// Bit mask of APP1_INT_ST field.
	SPI2_DMA_INT_ST_APP1_INT_ST_Msk = 0x100000
	// Bit APP1_INT_ST.
	SPI2_DMA_INT_ST_APP1_INT_ST = 0x100000

	// DMA_INT_SET: SPI interrupt software set register
	// Position of DMA_INFIFO_FULL_ERR_INT_SET field.
	SPI2_DMA_INT_SET_DMA_INFIFO_FULL_ERR_INT_SET_Pos = 0x0
	// Bit mask of DMA_INFIFO_FULL_ERR_INT_SET field.
	SPI2_DMA_INT_SET_DMA_INFIFO_FULL_ERR_INT_SET_Msk = 0x1
	// Bit DMA_INFIFO_FULL_ERR_INT_SET.
	SPI2_DMA_INT_SET_DMA_INFIFO_FULL_ERR_INT_SET = 0x1
	// Position of DMA_OUTFIFO_EMPTY_ERR_INT_SET field.
	SPI2_DMA_INT_SET_DMA_OUTFIFO_EMPTY_ERR_INT_SET_Pos = 0x1
	// Bit mask of DMA_OUTFIFO_EMPTY_ERR_INT_SET field.
	SPI2_DMA_INT_SET_DMA_OUTFIFO_EMPTY_ERR_INT_SET_Msk = 0x2
	// Bit DMA_OUTFIFO_EMPTY_ERR_INT_SET.
	SPI2_DMA_INT_SET_DMA_OUTFIFO_EMPTY_ERR_INT_SET = 0x2
	// Position of SLV_EX_QPI_INT_SET field.
	SPI2_DMA_INT_SET_SLV_EX_QPI_INT_SET_Pos = 0x2
	// Bit mask of SLV_EX_QPI_INT_SET field.
	SPI2_DMA_INT_SET_SLV_EX_QPI_INT_SET_Msk = 0x4
	// Bit SLV_EX_QPI_INT_SET.
	SPI2_DMA_INT_SET_SLV_EX_QPI_INT_SET = 0x4
	// Position of SLV_EN_QPI_INT_SET field.
	SPI2_DMA_INT_SET_SLV_EN_QPI_INT_SET_Pos = 0x3
	// Bit mask of SLV_EN_QPI_INT_SET field.
	SPI2_DMA_INT_SET_SLV_EN_QPI_INT_SET_Msk = 0x8
	// Bit SLV_EN_QPI_INT_SET.
	SPI2_DMA_INT_SET_SLV_EN_QPI_INT_SET = 0x8
	// Position of SLV_CMD7_INT_SET field.
	SPI2_DMA_INT_SET_SLV_CMD7_INT_SET_Pos = 0x4
	// Bit mask of SLV_CMD7_INT_SET field.
	SPI2_DMA_INT_SET_SLV_CMD7_INT_SET_Msk = 0x10
	// Bit SLV_CMD7_INT_SET.
	SPI2_DMA_INT_SET_SLV_CMD7_INT_SET = 0x10
	// Position of SLV_CMD8_INT_SET field.
	SPI2_DMA_INT_SET_SLV_CMD8_INT_SET_Pos = 0x5
	// Bit mask of SLV_CMD8_INT_SET field.
	SPI2_DMA_INT_SET_SLV_CMD8_INT_SET_Msk = 0x20
	// Bit SLV_CMD8_INT_SET.
	SPI2_DMA_INT_SET_SLV_CMD8_INT_SET = 0x20
	// Position of SLV_CMD9_INT_SET field.
	SPI2_DMA_INT_SET_SLV_CMD9_INT_SET_Pos = 0x6
	// Bit mask of SLV_CMD9_INT_SET field.
	SPI2_DMA_INT_SET_SLV_CMD9_INT_SET_Msk = 0x40
	// Bit SLV_CMD9_INT_SET.
	SPI2_DMA_INT_SET_SLV_CMD9_INT_SET = 0x40
	// Position of SLV_CMDA_INT_SET field.
	SPI2_DMA_INT_SET_SLV_CMDA_INT_SET_Pos = 0x7
	// Bit mask of SLV_CMDA_INT_SET field.
	SPI2_DMA_INT_SET_SLV_CMDA_INT_SET_Msk = 0x80
	// Bit SLV_CMDA_INT_SET.
	SPI2_DMA_INT_SET_SLV_CMDA_INT_SET = 0x80
	// Position of SLV_RD_DMA_DONE_INT_SET field.
	SPI2_DMA_INT_SET_SLV_RD_DMA_DONE_INT_SET_Pos = 0x8
	// Bit mask of SLV_RD_DMA_DONE_INT_SET field.
	SPI2_DMA_INT_SET_SLV_RD_DMA_DONE_INT_SET_Msk = 0x100
	// Bit SLV_RD_DMA_DONE_INT_SET.
	SPI2_DMA_INT_SET_SLV_RD_DMA_DONE_INT_SET = 0x100
	// Position of SLV_WR_DMA_DONE_INT_SET field.
	SPI2_DMA_INT_SET_SLV_WR_DMA_DONE_INT_SET_Pos = 0x9
	// Bit mask of SLV_WR_DMA_DONE_INT_SET field.
	SPI2_DMA_INT_SET_SLV_WR_DMA_DONE_INT_SET_Msk = 0x200
	// Bit SLV_WR_DMA_DONE_INT_SET.
	SPI2_DMA_INT_SET_SLV_WR_DMA_DONE_INT_SET = 0x200
	// Position of SLV_RD_BUF_DONE_INT_SET field.
	SPI2_DMA_INT_SET_SLV_RD_BUF_DONE_INT_SET_Pos = 0xa
	// Bit mask of SLV_RD_BUF_DONE_INT_SET field.
	SPI2_DMA_INT_SET_SLV_RD_BUF_DONE_INT_SET_Msk = 0x400
	// Bit SLV_RD_BUF_DONE_INT_SET.
	SPI2_DMA_INT_SET_SLV_RD_BUF_DONE_INT_SET = 0x400
	// Position of SLV_WR_BUF_DONE_INT_SET field.
	SPI2_DMA_INT_SET_SLV_WR_BUF_DONE_INT_SET_Pos = 0xb
	// Bit mask of SLV_WR_BUF_DONE_INT_SET field.
	SPI2_DMA_INT_SET_SLV_WR_BUF_DONE_INT_SET_Msk = 0x800
	// Bit SLV_WR_BUF_DONE_INT_SET.
	SPI2_DMA_INT_SET_SLV_WR_BUF_DONE_INT_SET = 0x800
	// Position of TRANS_DONE_INT_SET field.
	SPI2_DMA_INT_SET_TRANS_DONE_INT_SET_Pos = 0xc
	// Bit mask of TRANS_DONE_INT_SET field.
	SPI2_DMA_INT_SET_TRANS_DONE_INT_SET_Msk = 0x1000
	// Bit TRANS_DONE_INT_SET.
	SPI2_DMA_INT_SET_TRANS_DONE_INT_SET = 0x1000
	// Position of DMA_SEG_TRANS_DONE_INT_SET field.
	SPI2_DMA_INT_SET_DMA_SEG_TRANS_DONE_INT_SET_Pos = 0xd
	// Bit mask of DMA_SEG_TRANS_DONE_INT_SET field.
	SPI2_DMA_INT_SET_DMA_SEG_TRANS_DONE_INT_SET_Msk = 0x2000
	// Bit DMA_SEG_TRANS_DONE_INT_SET.
	SPI2_DMA_INT_SET_DMA_SEG_TRANS_DONE_INT_SET = 0x2000
	// Position of SEG_MAGIC_ERR_INT_SET field.
	SPI2_DMA_INT_SET_SEG_MAGIC_ERR_INT_SET_Pos = 0xe
	// Bit mask of SEG_MAGIC_ERR_INT_SET field.
	SPI2_DMA_INT_SET_SEG_MAGIC_ERR_INT_SET_Msk = 0x4000
	// Bit SEG_MAGIC_ERR_INT_SET.
	SPI2_DMA_INT_SET_SEG_MAGIC_ERR_INT_SET = 0x4000
	// Position of SLV_BUF_ADDR_ERR_INT_SET field.
	SPI2_DMA_INT_SET_SLV_BUF_ADDR_ERR_INT_SET_Pos = 0xf
	// Bit mask of SLV_BUF_ADDR_ERR_INT_SET field.
	SPI2_DMA_INT_SET_SLV_BUF_ADDR_ERR_INT_SET_Msk = 0x8000
	// Bit SLV_BUF_ADDR_ERR_INT_SET.
	SPI2_DMA_INT_SET_SLV_BUF_ADDR_ERR_INT_SET = 0x8000
	// Position of SLV_CMD_ERR_INT_SET field.
	SPI2_DMA_INT_SET_SLV_CMD_ERR_INT_SET_Pos = 0x10
	// Bit mask of SLV_CMD_ERR_INT_SET field.
	SPI2_DMA_INT_SET_SLV_CMD_ERR_INT_SET_Msk = 0x10000
	// Bit SLV_CMD_ERR_INT_SET.
	SPI2_DMA_INT_SET_SLV_CMD_ERR_INT_SET = 0x10000
	// Position of MST_RX_AFIFO_WFULL_ERR_INT_SET field.
	SPI2_DMA_INT_SET_MST_RX_AFIFO_WFULL_ERR_INT_SET_Pos = 0x11
	// Bit mask of MST_RX_AFIFO_WFULL_ERR_INT_SET field.
	SPI2_DMA_INT_SET_MST_RX_AFIFO_WFULL_ERR_INT_SET_Msk = 0x20000
	// Bit MST_RX_AFIFO_WFULL_ERR_INT_SET.
	SPI2_DMA_INT_SET_MST_RX_AFIFO_WFULL_ERR_INT_SET = 0x20000
	// Position of MST_TX_AFIFO_REMPTY_ERR_INT_SET field.
	SPI2_DMA_INT_SET_MST_TX_AFIFO_REMPTY_ERR_INT_SET_Pos = 0x12
	// Bit mask of MST_TX_AFIFO_REMPTY_ERR_INT_SET field.
	SPI2_DMA_INT_SET_MST_TX_AFIFO_REMPTY_ERR_INT_SET_Msk = 0x40000
	// Bit MST_TX_AFIFO_REMPTY_ERR_INT_SET.
	SPI2_DMA_INT_SET_MST_TX_AFIFO_REMPTY_ERR_INT_SET = 0x40000
	// Position of APP2_INT_SET field.
	SPI2_DMA_INT_SET_APP2_INT_SET_Pos = 0x13
	// Bit mask of APP2_INT_SET field.
	SPI2_DMA_INT_SET_APP2_INT_SET_Msk = 0x80000
	// Bit APP2_INT_SET.
	SPI2_DMA_INT_SET_APP2_INT_SET = 0x80000
	// Position of APP1_INT_SET field.
	SPI2_DMA_INT_SET_APP1_INT_SET_Pos = 0x14
	// Bit mask of APP1_INT_SET field.
	SPI2_DMA_INT_SET_APP1_INT_SET_Msk = 0x100000
	// Bit APP1_INT_SET.
	SPI2_DMA_INT_SET_APP1_INT_SET = 0x100000

	// W0: SPI CPU-controlled buffer0
	// Position of BUF0 field.
	SPI2_W0_BUF0_Pos = 0x0
	// Bit mask of BUF0 field.
	SPI2_W0_BUF0_Msk = 0xffffffff

	// W1: SPI CPU-controlled buffer1
	// Position of BUF1 field.
	SPI2_W1_BUF1_Pos = 0x0
	// Bit mask of BUF1 field.
	SPI2_W1_BUF1_Msk = 0xffffffff

	// W2: SPI CPU-controlled buffer2
	// Position of BUF2 field.
	SPI2_W2_BUF2_Pos = 0x0
	// Bit mask of BUF2 field.
	SPI2_W2_BUF2_Msk = 0xffffffff

	// W3: SPI CPU-controlled buffer3
	// Position of BUF3 field.
	SPI2_W3_BUF3_Pos = 0x0
	// Bit mask of BUF3 field.
	SPI2_W3_BUF3_Msk = 0xffffffff

	// W4: SPI CPU-controlled buffer4
	// Position of BUF4 field.
	SPI2_W4_BUF4_Pos = 0x0
	// Bit mask of BUF4 field.
	SPI2_W4_BUF4_Msk = 0xffffffff

	// W5: SPI CPU-controlled buffer5
	// Position of BUF5 field.
	SPI2_W5_BUF5_Pos = 0x0
	// Bit mask of BUF5 field.
	SPI2_W5_BUF5_Msk = 0xffffffff

	// W6: SPI CPU-controlled buffer6
	// Position of BUF6 field.
	SPI2_W6_BUF6_Pos = 0x0
	// Bit mask of BUF6 field.
	SPI2_W6_BUF6_Msk = 0xffffffff

	// W7: SPI CPU-controlled buffer7
	// Position of BUF7 field.
	SPI2_W7_BUF7_Pos = 0x0
	// Bit mask of BUF7 field.
	SPI2_W7_BUF7_Msk = 0xffffffff

	// W8: SPI CPU-controlled buffer8
	// Position of BUF8 field.
	SPI2_W8_BUF8_Pos = 0x0
	// Bit mask of BUF8 field.
	SPI2_W8_BUF8_Msk = 0xffffffff

	// W9: SPI CPU-controlled buffer9
	// Position of BUF9 field.
	SPI2_W9_BUF9_Pos = 0x0
	// Bit mask of BUF9 field.
	SPI2_W9_BUF9_Msk = 0xffffffff

	// W10: SPI CPU-controlled buffer10
	// Position of BUF10 field.
	SPI2_W10_BUF10_Pos = 0x0
	// Bit mask of BUF10 field.
	SPI2_W10_BUF10_Msk = 0xffffffff

	// W11: SPI CPU-controlled buffer11
	// Position of BUF11 field.
	SPI2_W11_BUF11_Pos = 0x0
	// Bit mask of BUF11 field.
	SPI2_W11_BUF11_Msk = 0xffffffff

	// W12: SPI CPU-controlled buffer12
	// Position of BUF12 field.
	SPI2_W12_BUF12_Pos = 0x0
	// Bit mask of BUF12 field.
	SPI2_W12_BUF12_Msk = 0xffffffff

	// W13: SPI CPU-controlled buffer13
	// Position of BUF13 field.
	SPI2_W13_BUF13_Pos = 0x0
	// Bit mask of BUF13 field.
	SPI2_W13_BUF13_Msk = 0xffffffff

	// W14: SPI CPU-controlled buffer14
	// Position of BUF14 field.
	SPI2_W14_BUF14_Pos = 0x0
	// Bit mask of BUF14 field.
	SPI2_W14_BUF14_Msk = 0xffffffff

	// W15: SPI CPU-controlled buffer15
	// Position of BUF15 field.
	SPI2_W15_BUF15_Pos = 0x0
	// Bit mask of BUF15 field.
	SPI2_W15_BUF15_Msk = 0xffffffff

	// SLAVE: SPI slave control register
	// Position of CLK_MODE field.
	SPI2_SLAVE_CLK_MODE_Pos = 0x0
	// Bit mask of CLK_MODE field.
	SPI2_SLAVE_CLK_MODE_Msk = 0x3
	// Position of CLK_MODE_13 field.
	SPI2_SLAVE_CLK_MODE_13_Pos = 0x2
	// Bit mask of CLK_MODE_13 field.
	SPI2_SLAVE_CLK_MODE_13_Msk = 0x4
	// Bit CLK_MODE_13.
	SPI2_SLAVE_CLK_MODE_13 = 0x4
	// Position of RSCK_DATA_OUT field.
	SPI2_SLAVE_RSCK_DATA_OUT_Pos = 0x3
	// Bit mask of RSCK_DATA_OUT field.
	SPI2_SLAVE_RSCK_DATA_OUT_Msk = 0x8
	// Bit RSCK_DATA_OUT.
	SPI2_SLAVE_RSCK_DATA_OUT = 0x8
	// Position of SLV_RDDMA_BITLEN_EN field.
	SPI2_SLAVE_SLV_RDDMA_BITLEN_EN_Pos = 0x8
	// Bit mask of SLV_RDDMA_BITLEN_EN field.
	SPI2_SLAVE_SLV_RDDMA_BITLEN_EN_Msk = 0x100
	// Bit SLV_RDDMA_BITLEN_EN.
	SPI2_SLAVE_SLV_RDDMA_BITLEN_EN = 0x100
	// Position of SLV_WRDMA_BITLEN_EN field.
	SPI2_SLAVE_SLV_WRDMA_BITLEN_EN_Pos = 0x9
	// Bit mask of SLV_WRDMA_BITLEN_EN field.
	SPI2_SLAVE_SLV_WRDMA_BITLEN_EN_Msk = 0x200
	// Bit SLV_WRDMA_BITLEN_EN.
	SPI2_SLAVE_SLV_WRDMA_BITLEN_EN = 0x200
	// Position of SLV_RDBUF_BITLEN_EN field.
	SPI2_SLAVE_SLV_RDBUF_BITLEN_EN_Pos = 0xa
	// Bit mask of SLV_RDBUF_BITLEN_EN field.
	SPI2_SLAVE_SLV_RDBUF_BITLEN_EN_Msk = 0x400
	// Bit SLV_RDBUF_BITLEN_EN.
	SPI2_SLAVE_SLV_RDBUF_BITLEN_EN = 0x400
	// Position of SLV_WRBUF_BITLEN_EN field.
	SPI2_SLAVE_SLV_WRBUF_BITLEN_EN_Pos = 0xb
	// Bit mask of SLV_WRBUF_BITLEN_EN field.
	SPI2_SLAVE_SLV_WRBUF_BITLEN_EN_Msk = 0x800
	// Bit SLV_WRBUF_BITLEN_EN.
	SPI2_SLAVE_SLV_WRBUF_BITLEN_EN = 0x800
	// Position of DMA_SEG_MAGIC_VALUE field.
	SPI2_SLAVE_DMA_SEG_MAGIC_VALUE_Pos = 0x16
	// Bit mask of DMA_SEG_MAGIC_VALUE field.
	SPI2_SLAVE_DMA_SEG_MAGIC_VALUE_Msk = 0x3c00000
	// Position of MODE field.
	SPI2_SLAVE_MODE_Pos = 0x1a
	// Bit mask of MODE field.
	SPI2_SLAVE_MODE_Msk = 0x4000000
	// Bit MODE.
	SPI2_SLAVE_MODE = 0x4000000
	// Position of SOFT_RESET field.
	SPI2_SLAVE_SOFT_RESET_Pos = 0x1b
	// Bit mask of SOFT_RESET field.
	SPI2_SLAVE_SOFT_RESET_Msk = 0x8000000
	// Bit SOFT_RESET.
	SPI2_SLAVE_SOFT_RESET = 0x8000000
	// Position of USR_CONF field.
	SPI2_SLAVE_USR_CONF_Pos = 0x1c
	// Bit mask of USR_CONF field.
	SPI2_SLAVE_USR_CONF_Msk = 0x10000000
	// Bit USR_CONF.
	SPI2_SLAVE_USR_CONF = 0x10000000
	// Position of MST_FD_WAIT_DMA_TX_DATA field.
	SPI2_SLAVE_MST_FD_WAIT_DMA_TX_DATA_Pos = 0x1d
	// Bit mask of MST_FD_WAIT_DMA_TX_DATA field.
	SPI2_SLAVE_MST_FD_WAIT_DMA_TX_DATA_Msk = 0x20000000
	// Bit MST_FD_WAIT_DMA_TX_DATA.
	SPI2_SLAVE_MST_FD_WAIT_DMA_TX_DATA = 0x20000000

	// SLAVE1: SPI slave control register 1
	// Position of SLV_DATA_BITLEN field.
	SPI2_SLAVE1_SLV_DATA_BITLEN_Pos = 0x0
	// Bit mask of SLV_DATA_BITLEN field.
	SPI2_SLAVE1_SLV_DATA_BITLEN_Msk = 0x3ffff
	// Position of SLV_LAST_COMMAND field.
	SPI2_SLAVE1_SLV_LAST_COMMAND_Pos = 0x12
	// Bit mask of SLV_LAST_COMMAND field.
	SPI2_SLAVE1_SLV_LAST_COMMAND_Msk = 0x3fc0000
	// Position of SLV_LAST_ADDR field.
	SPI2_SLAVE1_SLV_LAST_ADDR_Pos = 0x1a
	// Bit mask of SLV_LAST_ADDR field.
	SPI2_SLAVE1_SLV_LAST_ADDR_Msk = 0xfc000000

	// CLK_GATE: SPI module clock and register clock control
	// Position of CLK_EN field.
	SPI2_CLK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	SPI2_CLK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	SPI2_CLK_GATE_CLK_EN = 0x1
	// Position of MST_CLK_ACTIVE field.
	SPI2_CLK_GATE_MST_CLK_ACTIVE_Pos = 0x1
	// Bit mask of MST_CLK_ACTIVE field.
	SPI2_CLK_GATE_MST_CLK_ACTIVE_Msk = 0x2
	// Bit MST_CLK_ACTIVE.
	SPI2_CLK_GATE_MST_CLK_ACTIVE = 0x2
	// Position of MST_CLK_SEL field.
	SPI2_CLK_GATE_MST_CLK_SEL_Pos = 0x2
	// Bit mask of MST_CLK_SEL field.
	SPI2_CLK_GATE_MST_CLK_SEL_Msk = 0x4
	// Bit MST_CLK_SEL.
	SPI2_CLK_GATE_MST_CLK_SEL = 0x4

	// DATE: Version control
	// Position of DATE field.
	SPI2_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	SPI2_DATE_DATE_Msk = 0xfffffff
)

// Constants for SYSTIMER: System Timer
const (
	// CONF: Configure system timer clock
	// Position of SYSTIMER_CLK_FO field.
	SYSTIMER_CONF_SYSTIMER_CLK_FO_Pos = 0x0
	// Bit mask of SYSTIMER_CLK_FO field.
	SYSTIMER_CONF_SYSTIMER_CLK_FO_Msk = 0x1
	// Bit SYSTIMER_CLK_FO.
	SYSTIMER_CONF_SYSTIMER_CLK_FO = 0x1
	// Position of ETM_EN field.
	SYSTIMER_CONF_ETM_EN_Pos = 0x1
	// Bit mask of ETM_EN field.
	SYSTIMER_CONF_ETM_EN_Msk = 0x2
	// Bit ETM_EN.
	SYSTIMER_CONF_ETM_EN = 0x2
	// Position of TARGET2_WORK_EN field.
	SYSTIMER_CONF_TARGET2_WORK_EN_Pos = 0x16
	// Bit mask of TARGET2_WORK_EN field.
	SYSTIMER_CONF_TARGET2_WORK_EN_Msk = 0x400000
	// Bit TARGET2_WORK_EN.
	SYSTIMER_CONF_TARGET2_WORK_EN = 0x400000
	// Position of TARGET1_WORK_EN field.
	SYSTIMER_CONF_TARGET1_WORK_EN_Pos = 0x17
	// Bit mask of TARGET1_WORK_EN field.
	SYSTIMER_CONF_TARGET1_WORK_EN_Msk = 0x800000
	// Bit TARGET1_WORK_EN.
	SYSTIMER_CONF_TARGET1_WORK_EN = 0x800000
	// Position of TARGET0_WORK_EN field.
	SYSTIMER_CONF_TARGET0_WORK_EN_Pos = 0x18
	// Bit mask of TARGET0_WORK_EN field.
	SYSTIMER_CONF_TARGET0_WORK_EN_Msk = 0x1000000
	// Bit TARGET0_WORK_EN.
	SYSTIMER_CONF_TARGET0_WORK_EN = 0x1000000
	// Position of TIMER_UNIT1_CORE1_STALL_EN field.
	SYSTIMER_CONF_TIMER_UNIT1_CORE1_STALL_EN_Pos = 0x19
	// Bit mask of TIMER_UNIT1_CORE1_STALL_EN field.
	SYSTIMER_CONF_TIMER_UNIT1_CORE1_STALL_EN_Msk = 0x2000000
	// Bit TIMER_UNIT1_CORE1_STALL_EN.
	SYSTIMER_CONF_TIMER_UNIT1_CORE1_STALL_EN = 0x2000000
	// Position of TIMER_UNIT1_CORE0_STALL_EN field.
	SYSTIMER_CONF_TIMER_UNIT1_CORE0_STALL_EN_Pos = 0x1a
	// Bit mask of TIMER_UNIT1_CORE0_STALL_EN field.
	SYSTIMER_CONF_TIMER_UNIT1_CORE0_STALL_EN_Msk = 0x4000000
	// Bit TIMER_UNIT1_CORE0_STALL_EN.
	SYSTIMER_CONF_TIMER_UNIT1_CORE0_STALL_EN = 0x4000000
	// Position of TIMER_UNIT0_CORE1_STALL_EN field.
	SYSTIMER_CONF_TIMER_UNIT0_CORE1_STALL_EN_Pos = 0x1b
	// Bit mask of TIMER_UNIT0_CORE1_STALL_EN field.
	SYSTIMER_CONF_TIMER_UNIT0_CORE1_STALL_EN_Msk = 0x8000000
	// Bit TIMER_UNIT0_CORE1_STALL_EN.
	SYSTIMER_CONF_TIMER_UNIT0_CORE1_STALL_EN = 0x8000000
	// Position of TIMER_UNIT0_CORE0_STALL_EN field.
	SYSTIMER_CONF_TIMER_UNIT0_CORE0_STALL_EN_Pos = 0x1c
	// Bit mask of TIMER_UNIT0_CORE0_STALL_EN field.
	SYSTIMER_CONF_TIMER_UNIT0_CORE0_STALL_EN_Msk = 0x10000000
	// Bit TIMER_UNIT0_CORE0_STALL_EN.
	SYSTIMER_CONF_TIMER_UNIT0_CORE0_STALL_EN = 0x10000000
	// Position of TIMER_UNIT1_WORK_EN field.
	SYSTIMER_CONF_TIMER_UNIT1_WORK_EN_Pos = 0x1d
	// Bit mask of TIMER_UNIT1_WORK_EN field.
	SYSTIMER_CONF_TIMER_UNIT1_WORK_EN_Msk = 0x20000000
	// Bit TIMER_UNIT1_WORK_EN.
	SYSTIMER_CONF_TIMER_UNIT1_WORK_EN = 0x20000000
	// Position of TIMER_UNIT0_WORK_EN field.
	SYSTIMER_CONF_TIMER_UNIT0_WORK_EN_Pos = 0x1e
	// Bit mask of TIMER_UNIT0_WORK_EN field.
	SYSTIMER_CONF_TIMER_UNIT0_WORK_EN_Msk = 0x40000000
	// Bit TIMER_UNIT0_WORK_EN.
	SYSTIMER_CONF_TIMER_UNIT0_WORK_EN = 0x40000000
	// Position of CLK_EN field.
	SYSTIMER_CONF_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	SYSTIMER_CONF_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	SYSTIMER_CONF_CLK_EN = 0x80000000

	// UNIT0_OP: system timer unit0 value update register
	// Position of TIMER_UNIT0_VALUE_VALID field.
	SYSTIMER_UNIT0_OP_TIMER_UNIT0_VALUE_VALID_Pos = 0x1d
	// Bit mask of TIMER_UNIT0_VALUE_VALID field.
	SYSTIMER_UNIT0_OP_TIMER_UNIT0_VALUE_VALID_Msk = 0x20000000
	// Bit TIMER_UNIT0_VALUE_VALID.
	SYSTIMER_UNIT0_OP_TIMER_UNIT0_VALUE_VALID = 0x20000000
	// Position of TIMER_UNIT0_UPDATE field.
	SYSTIMER_UNIT0_OP_TIMER_UNIT0_UPDATE_Pos = 0x1e
	// Bit mask of TIMER_UNIT0_UPDATE field.
	SYSTIMER_UNIT0_OP_TIMER_UNIT0_UPDATE_Msk = 0x40000000
	// Bit TIMER_UNIT0_UPDATE.
	SYSTIMER_UNIT0_OP_TIMER_UNIT0_UPDATE = 0x40000000

	// UNIT1_OP: system timer unit1 value update register
	// Position of TIMER_UNIT1_VALUE_VALID field.
	SYSTIMER_UNIT1_OP_TIMER_UNIT1_VALUE_VALID_Pos = 0x1d
	// Bit mask of TIMER_UNIT1_VALUE_VALID field.
	SYSTIMER_UNIT1_OP_TIMER_UNIT1_VALUE_VALID_Msk = 0x20000000
	// Bit TIMER_UNIT1_VALUE_VALID.
	SYSTIMER_UNIT1_OP_TIMER_UNIT1_VALUE_VALID = 0x20000000
	// Position of TIMER_UNIT1_UPDATE field.
	SYSTIMER_UNIT1_OP_TIMER_UNIT1_UPDATE_Pos = 0x1e
	// Bit mask of TIMER_UNIT1_UPDATE field.
	SYSTIMER_UNIT1_OP_TIMER_UNIT1_UPDATE_Msk = 0x40000000
	// Bit TIMER_UNIT1_UPDATE.
	SYSTIMER_UNIT1_OP_TIMER_UNIT1_UPDATE = 0x40000000

	// UNIT0_LOAD_HI: system timer unit0 value high load register
	// Position of TIMER_UNIT0_LOAD_HI field.
	SYSTIMER_UNIT0_LOAD_HI_TIMER_UNIT0_LOAD_HI_Pos = 0x0
	// Bit mask of TIMER_UNIT0_LOAD_HI field.
	SYSTIMER_UNIT0_LOAD_HI_TIMER_UNIT0_LOAD_HI_Msk = 0xfffff

	// UNIT0_LOAD_LO: system timer unit0 value low load register
	// Position of TIMER_UNIT0_LOAD_LO field.
	SYSTIMER_UNIT0_LOAD_LO_TIMER_UNIT0_LOAD_LO_Pos = 0x0
	// Bit mask of TIMER_UNIT0_LOAD_LO field.
	SYSTIMER_UNIT0_LOAD_LO_TIMER_UNIT0_LOAD_LO_Msk = 0xffffffff

	// UNIT1_LOAD_HI: system timer unit1 value high load register
	// Position of TIMER_UNIT1_LOAD_HI field.
	SYSTIMER_UNIT1_LOAD_HI_TIMER_UNIT1_LOAD_HI_Pos = 0x0
	// Bit mask of TIMER_UNIT1_LOAD_HI field.
	SYSTIMER_UNIT1_LOAD_HI_TIMER_UNIT1_LOAD_HI_Msk = 0xfffff

	// UNIT1_LOAD_LO: system timer unit1 value low load register
	// Position of TIMER_UNIT1_LOAD_LO field.
	SYSTIMER_UNIT1_LOAD_LO_TIMER_UNIT1_LOAD_LO_Pos = 0x0
	// Bit mask of TIMER_UNIT1_LOAD_LO field.
	SYSTIMER_UNIT1_LOAD_LO_TIMER_UNIT1_LOAD_LO_Msk = 0xffffffff

	// TARGET0_HI: system timer comp0 value high register
	// Position of TIMER_TARGET0_HI field.
	SYSTIMER_TARGET0_HI_TIMER_TARGET0_HI_Pos = 0x0
	// Bit mask of TIMER_TARGET0_HI field.
	SYSTIMER_TARGET0_HI_TIMER_TARGET0_HI_Msk = 0xfffff

	// TARGET0_LO: system timer comp0 value low register
	// Position of TIMER_TARGET0_LO field.
	SYSTIMER_TARGET0_LO_TIMER_TARGET0_LO_Pos = 0x0
	// Bit mask of TIMER_TARGET0_LO field.
	SYSTIMER_TARGET0_LO_TIMER_TARGET0_LO_Msk = 0xffffffff

	// TARGET1_HI: system timer comp1 value high register
	// Position of TIMER_TARGET1_HI field.
	SYSTIMER_TARGET1_HI_TIMER_TARGET1_HI_Pos = 0x0
	// Bit mask of TIMER_TARGET1_HI field.
	SYSTIMER_TARGET1_HI_TIMER_TARGET1_HI_Msk = 0xfffff

	// TARGET1_LO: system timer comp1 value low register
	// Position of TIMER_TARGET1_LO field.
	SYSTIMER_TARGET1_LO_TIMER_TARGET1_LO_Pos = 0x0
	// Bit mask of TIMER_TARGET1_LO field.
	SYSTIMER_TARGET1_LO_TIMER_TARGET1_LO_Msk = 0xffffffff

	// TARGET2_HI: system timer comp2 value high register
	// Position of TIMER_TARGET2_HI field.
	SYSTIMER_TARGET2_HI_TIMER_TARGET2_HI_Pos = 0x0
	// Bit mask of TIMER_TARGET2_HI field.
	SYSTIMER_TARGET2_HI_TIMER_TARGET2_HI_Msk = 0xfffff

	// TARGET2_LO: system timer comp2 value low register
	// Position of TIMER_TARGET2_LO field.
	SYSTIMER_TARGET2_LO_TIMER_TARGET2_LO_Pos = 0x0
	// Bit mask of TIMER_TARGET2_LO field.
	SYSTIMER_TARGET2_LO_TIMER_TARGET2_LO_Msk = 0xffffffff

	// TARGET0_CONF: system timer comp0 target mode register
	// Position of TARGET0_PERIOD field.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_Pos = 0x0
	// Bit mask of TARGET0_PERIOD field.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_Msk = 0x3ffffff
	// Position of TARGET0_PERIOD_MODE field.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_MODE_Pos = 0x1e
	// Bit mask of TARGET0_PERIOD_MODE field.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_MODE_Msk = 0x40000000
	// Bit TARGET0_PERIOD_MODE.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_MODE = 0x40000000
	// Position of TARGET0_TIMER_UNIT_SEL field.
	SYSTIMER_TARGET0_CONF_TARGET0_TIMER_UNIT_SEL_Pos = 0x1f
	// Bit mask of TARGET0_TIMER_UNIT_SEL field.
	SYSTIMER_TARGET0_CONF_TARGET0_TIMER_UNIT_SEL_Msk = 0x80000000
	// Bit TARGET0_TIMER_UNIT_SEL.
	SYSTIMER_TARGET0_CONF_TARGET0_TIMER_UNIT_SEL = 0x80000000

	// TARGET1_CONF: system timer comp1 target mode register
	// Position of TARGET1_PERIOD field.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_Pos = 0x0
	// Bit mask of TARGET1_PERIOD field.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_Msk = 0x3ffffff
	// Position of TARGET1_PERIOD_MODE field.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_MODE_Pos = 0x1e
	// Bit mask of TARGET1_PERIOD_MODE field.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_MODE_Msk = 0x40000000
	// Bit TARGET1_PERIOD_MODE.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_MODE = 0x40000000
	// Position of TARGET1_TIMER_UNIT_SEL field.
	SYSTIMER_TARGET1_CONF_TARGET1_TIMER_UNIT_SEL_Pos = 0x1f
	// Bit mask of TARGET1_TIMER_UNIT_SEL field.
	SYSTIMER_TARGET1_CONF_TARGET1_TIMER_UNIT_SEL_Msk = 0x80000000
	// Bit TARGET1_TIMER_UNIT_SEL.
	SYSTIMER_TARGET1_CONF_TARGET1_TIMER_UNIT_SEL = 0x80000000

	// TARGET2_CONF: system timer comp2 target mode register
	// Position of TARGET2_PERIOD field.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_Pos = 0x0
	// Bit mask of TARGET2_PERIOD field.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_Msk = 0x3ffffff
	// Position of TARGET2_PERIOD_MODE field.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_MODE_Pos = 0x1e
	// Bit mask of TARGET2_PERIOD_MODE field.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_MODE_Msk = 0x40000000
	// Bit TARGET2_PERIOD_MODE.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_MODE = 0x40000000
	// Position of TARGET2_TIMER_UNIT_SEL field.
	SYSTIMER_TARGET2_CONF_TARGET2_TIMER_UNIT_SEL_Pos = 0x1f
	// Bit mask of TARGET2_TIMER_UNIT_SEL field.
	SYSTIMER_TARGET2_CONF_TARGET2_TIMER_UNIT_SEL_Msk = 0x80000000
	// Bit TARGET2_TIMER_UNIT_SEL.
	SYSTIMER_TARGET2_CONF_TARGET2_TIMER_UNIT_SEL = 0x80000000

	// UNIT0_VALUE_HI: system timer unit0 value high register
	// Position of TIMER_UNIT0_VALUE_HI field.
	SYSTIMER_UNIT0_VALUE_HI_TIMER_UNIT0_VALUE_HI_Pos = 0x0
	// Bit mask of TIMER_UNIT0_VALUE_HI field.
	SYSTIMER_UNIT0_VALUE_HI_TIMER_UNIT0_VALUE_HI_Msk = 0xfffff

	// UNIT0_VALUE_LO: system timer unit0 value low register
	// Position of TIMER_UNIT0_VALUE_LO field.
	SYSTIMER_UNIT0_VALUE_LO_TIMER_UNIT0_VALUE_LO_Pos = 0x0
	// Bit mask of TIMER_UNIT0_VALUE_LO field.
	SYSTIMER_UNIT0_VALUE_LO_TIMER_UNIT0_VALUE_LO_Msk = 0xffffffff

	// UNIT1_VALUE_HI: system timer unit1 value high register
	// Position of TIMER_UNIT1_VALUE_HI field.
	SYSTIMER_UNIT1_VALUE_HI_TIMER_UNIT1_VALUE_HI_Pos = 0x0
	// Bit mask of TIMER_UNIT1_VALUE_HI field.
	SYSTIMER_UNIT1_VALUE_HI_TIMER_UNIT1_VALUE_HI_Msk = 0xfffff

	// UNIT1_VALUE_LO: system timer unit1 value low register
	// Position of TIMER_UNIT1_VALUE_LO field.
	SYSTIMER_UNIT1_VALUE_LO_TIMER_UNIT1_VALUE_LO_Pos = 0x0
	// Bit mask of TIMER_UNIT1_VALUE_LO field.
	SYSTIMER_UNIT1_VALUE_LO_TIMER_UNIT1_VALUE_LO_Msk = 0xffffffff

	// COMP0_LOAD: system timer comp0 conf sync register
	// Position of TIMER_COMP0_LOAD field.
	SYSTIMER_COMP0_LOAD_TIMER_COMP0_LOAD_Pos = 0x0
	// Bit mask of TIMER_COMP0_LOAD field.
	SYSTIMER_COMP0_LOAD_TIMER_COMP0_LOAD_Msk = 0x1
	// Bit TIMER_COMP0_LOAD.
	SYSTIMER_COMP0_LOAD_TIMER_COMP0_LOAD = 0x1

	// COMP1_LOAD: system timer comp1 conf sync register
	// Position of TIMER_COMP1_LOAD field.
	SYSTIMER_COMP1_LOAD_TIMER_COMP1_LOAD_Pos = 0x0
	// Bit mask of TIMER_COMP1_LOAD field.
	SYSTIMER_COMP1_LOAD_TIMER_COMP1_LOAD_Msk = 0x1
	// Bit TIMER_COMP1_LOAD.
	SYSTIMER_COMP1_LOAD_TIMER_COMP1_LOAD = 0x1

	// COMP2_LOAD: system timer comp2 conf sync register
	// Position of TIMER_COMP2_LOAD field.
	SYSTIMER_COMP2_LOAD_TIMER_COMP2_LOAD_Pos = 0x0
	// Bit mask of TIMER_COMP2_LOAD field.
	SYSTIMER_COMP2_LOAD_TIMER_COMP2_LOAD_Msk = 0x1
	// Bit TIMER_COMP2_LOAD.
	SYSTIMER_COMP2_LOAD_TIMER_COMP2_LOAD = 0x1

	// UNIT0_LOAD: system timer unit0 conf sync register
	// Position of TIMER_UNIT0_LOAD field.
	SYSTIMER_UNIT0_LOAD_TIMER_UNIT0_LOAD_Pos = 0x0
	// Bit mask of TIMER_UNIT0_LOAD field.
	SYSTIMER_UNIT0_LOAD_TIMER_UNIT0_LOAD_Msk = 0x1
	// Bit TIMER_UNIT0_LOAD.
	SYSTIMER_UNIT0_LOAD_TIMER_UNIT0_LOAD = 0x1

	// UNIT1_LOAD: system timer unit1 conf sync register
	// Position of TIMER_UNIT1_LOAD field.
	SYSTIMER_UNIT1_LOAD_TIMER_UNIT1_LOAD_Pos = 0x0
	// Bit mask of TIMER_UNIT1_LOAD field.
	SYSTIMER_UNIT1_LOAD_TIMER_UNIT1_LOAD_Msk = 0x1
	// Bit TIMER_UNIT1_LOAD.
	SYSTIMER_UNIT1_LOAD_TIMER_UNIT1_LOAD = 0x1

	// INT_ENA: systimer interrupt enable register
	// Position of TARGET0_INT_ENA field.
	SYSTIMER_INT_ENA_TARGET0_INT_ENA_Pos = 0x0
	// Bit mask of TARGET0_INT_ENA field.
	SYSTIMER_INT_ENA_TARGET0_INT_ENA_Msk = 0x1
	// Bit TARGET0_INT_ENA.
	SYSTIMER_INT_ENA_TARGET0_INT_ENA = 0x1
	// Position of TARGET1_INT_ENA field.
	SYSTIMER_INT_ENA_TARGET1_INT_ENA_Pos = 0x1
	// Bit mask of TARGET1_INT_ENA field.
	SYSTIMER_INT_ENA_TARGET1_INT_ENA_Msk = 0x2
	// Bit TARGET1_INT_ENA.
	SYSTIMER_INT_ENA_TARGET1_INT_ENA = 0x2
	// Position of TARGET2_INT_ENA field.
	SYSTIMER_INT_ENA_TARGET2_INT_ENA_Pos = 0x2
	// Bit mask of TARGET2_INT_ENA field.
	SYSTIMER_INT_ENA_TARGET2_INT_ENA_Msk = 0x4
	// Bit TARGET2_INT_ENA.
	SYSTIMER_INT_ENA_TARGET2_INT_ENA = 0x4

	// INT_RAW: systimer interrupt raw register
	// Position of TARGET0_INT_RAW field.
	SYSTIMER_INT_RAW_TARGET0_INT_RAW_Pos = 0x0
	// Bit mask of TARGET0_INT_RAW field.
	SYSTIMER_INT_RAW_TARGET0_INT_RAW_Msk = 0x1
	// Bit TARGET0_INT_RAW.
	SYSTIMER_INT_RAW_TARGET0_INT_RAW = 0x1
	// Position of TARGET1_INT_RAW field.
	SYSTIMER_INT_RAW_TARGET1_INT_RAW_Pos = 0x1
	// Bit mask of TARGET1_INT_RAW field.
	SYSTIMER_INT_RAW_TARGET1_INT_RAW_Msk = 0x2
	// Bit TARGET1_INT_RAW.
	SYSTIMER_INT_RAW_TARGET1_INT_RAW = 0x2
	// Position of TARGET2_INT_RAW field.
	SYSTIMER_INT_RAW_TARGET2_INT_RAW_Pos = 0x2
	// Bit mask of TARGET2_INT_RAW field.
	SYSTIMER_INT_RAW_TARGET2_INT_RAW_Msk = 0x4
	// Bit TARGET2_INT_RAW.
	SYSTIMER_INT_RAW_TARGET2_INT_RAW = 0x4

	// INT_CLR: systimer interrupt clear register
	// Position of TARGET0_INT_CLR field.
	SYSTIMER_INT_CLR_TARGET0_INT_CLR_Pos = 0x0
	// Bit mask of TARGET0_INT_CLR field.
	SYSTIMER_INT_CLR_TARGET0_INT_CLR_Msk = 0x1
	// Bit TARGET0_INT_CLR.
	SYSTIMER_INT_CLR_TARGET0_INT_CLR = 0x1
	// Position of TARGET1_INT_CLR field.
	SYSTIMER_INT_CLR_TARGET1_INT_CLR_Pos = 0x1
	// Bit mask of TARGET1_INT_CLR field.
	SYSTIMER_INT_CLR_TARGET1_INT_CLR_Msk = 0x2
	// Bit TARGET1_INT_CLR.
	SYSTIMER_INT_CLR_TARGET1_INT_CLR = 0x2
	// Position of TARGET2_INT_CLR field.
	SYSTIMER_INT_CLR_TARGET2_INT_CLR_Pos = 0x2
	// Bit mask of TARGET2_INT_CLR field.
	SYSTIMER_INT_CLR_TARGET2_INT_CLR_Msk = 0x4
	// Bit TARGET2_INT_CLR.
	SYSTIMER_INT_CLR_TARGET2_INT_CLR = 0x4

	// INT_ST: systimer interrupt status register
	// Position of TARGET0_INT_ST field.
	SYSTIMER_INT_ST_TARGET0_INT_ST_Pos = 0x0
	// Bit mask of TARGET0_INT_ST field.
	SYSTIMER_INT_ST_TARGET0_INT_ST_Msk = 0x1
	// Bit TARGET0_INT_ST.
	SYSTIMER_INT_ST_TARGET0_INT_ST = 0x1
	// Position of TARGET1_INT_ST field.
	SYSTIMER_INT_ST_TARGET1_INT_ST_Pos = 0x1
	// Bit mask of TARGET1_INT_ST field.
	SYSTIMER_INT_ST_TARGET1_INT_ST_Msk = 0x2
	// Bit TARGET1_INT_ST.
	SYSTIMER_INT_ST_TARGET1_INT_ST = 0x2
	// Position of TARGET2_INT_ST field.
	SYSTIMER_INT_ST_TARGET2_INT_ST_Pos = 0x2
	// Bit mask of TARGET2_INT_ST field.
	SYSTIMER_INT_ST_TARGET2_INT_ST_Msk = 0x4
	// Bit TARGET2_INT_ST.
	SYSTIMER_INT_ST_TARGET2_INT_ST = 0x4

	// REAL_TARGET0_LO: system timer comp0 actual target value low register
	// Position of TARGET0_LO_RO field.
	SYSTIMER_REAL_TARGET0_LO_TARGET0_LO_RO_Pos = 0x0
	// Bit mask of TARGET0_LO_RO field.
	SYSTIMER_REAL_TARGET0_LO_TARGET0_LO_RO_Msk = 0xffffffff

	// REAL_TARGET0_HI: system timer comp0 actual target value high register
	// Position of TARGET0_HI_RO field.
	SYSTIMER_REAL_TARGET0_HI_TARGET0_HI_RO_Pos = 0x0
	// Bit mask of TARGET0_HI_RO field.
	SYSTIMER_REAL_TARGET0_HI_TARGET0_HI_RO_Msk = 0xfffff

	// REAL_TARGET1_LO: system timer comp1 actual target value low register
	// Position of TARGET1_LO_RO field.
	SYSTIMER_REAL_TARGET1_LO_TARGET1_LO_RO_Pos = 0x0
	// Bit mask of TARGET1_LO_RO field.
	SYSTIMER_REAL_TARGET1_LO_TARGET1_LO_RO_Msk = 0xffffffff

	// REAL_TARGET1_HI: system timer comp1 actual target value high register
	// Position of TARGET1_HI_RO field.
	SYSTIMER_REAL_TARGET1_HI_TARGET1_HI_RO_Pos = 0x0
	// Bit mask of TARGET1_HI_RO field.
	SYSTIMER_REAL_TARGET1_HI_TARGET1_HI_RO_Msk = 0xfffff

	// REAL_TARGET2_LO: system timer comp2 actual target value low register
	// Position of TARGET2_LO_RO field.
	SYSTIMER_REAL_TARGET2_LO_TARGET2_LO_RO_Pos = 0x0
	// Bit mask of TARGET2_LO_RO field.
	SYSTIMER_REAL_TARGET2_LO_TARGET2_LO_RO_Msk = 0xffffffff

	// REAL_TARGET2_HI: system timer comp2 actual target value high register
	// Position of TARGET2_HI_RO field.
	SYSTIMER_REAL_TARGET2_HI_TARGET2_HI_RO_Pos = 0x0
	// Bit mask of TARGET2_HI_RO field.
	SYSTIMER_REAL_TARGET2_HI_TARGET2_HI_RO_Msk = 0xfffff

	// DATE: system timer version control register
	// Position of DATE field.
	SYSTIMER_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	SYSTIMER_DATE_DATE_Msk = 0xffffffff
)

// Constants for TEE: TEE Peripheral
const (
	// M0_MODE_CTRL: Tee mode control register
	// Position of M0_MODE field.
	TEE_M0_MODE_CTRL_M0_MODE_Pos = 0x0
	// Bit mask of M0_MODE field.
	TEE_M0_MODE_CTRL_M0_MODE_Msk = 0x3

	// M1_MODE_CTRL: Tee mode control register
	// Position of M1_MODE field.
	TEE_M1_MODE_CTRL_M1_MODE_Pos = 0x0
	// Bit mask of M1_MODE field.
	TEE_M1_MODE_CTRL_M1_MODE_Msk = 0x3

	// M2_MODE_CTRL: Tee mode control register
	// Position of M2_MODE field.
	TEE_M2_MODE_CTRL_M2_MODE_Pos = 0x0
	// Bit mask of M2_MODE field.
	TEE_M2_MODE_CTRL_M2_MODE_Msk = 0x3

	// M3_MODE_CTRL: Tee mode control register
	// Position of M3_MODE field.
	TEE_M3_MODE_CTRL_M3_MODE_Pos = 0x0
	// Bit mask of M3_MODE field.
	TEE_M3_MODE_CTRL_M3_MODE_Msk = 0x3

	// M4_MODE_CTRL: Tee mode control register
	// Position of M4_MODE field.
	TEE_M4_MODE_CTRL_M4_MODE_Pos = 0x0
	// Bit mask of M4_MODE field.
	TEE_M4_MODE_CTRL_M4_MODE_Msk = 0x3

	// M5_MODE_CTRL: Tee mode control register
	// Position of M5_MODE field.
	TEE_M5_MODE_CTRL_M5_MODE_Pos = 0x0
	// Bit mask of M5_MODE field.
	TEE_M5_MODE_CTRL_M5_MODE_Msk = 0x3

	// M6_MODE_CTRL: Tee mode control register
	// Position of M6_MODE field.
	TEE_M6_MODE_CTRL_M6_MODE_Pos = 0x0
	// Bit mask of M6_MODE field.
	TEE_M6_MODE_CTRL_M6_MODE_Msk = 0x3

	// M7_MODE_CTRL: Tee mode control register
	// Position of M7_MODE field.
	TEE_M7_MODE_CTRL_M7_MODE_Pos = 0x0
	// Bit mask of M7_MODE field.
	TEE_M7_MODE_CTRL_M7_MODE_Msk = 0x3

	// M8_MODE_CTRL: Tee mode control register
	// Position of M8_MODE field.
	TEE_M8_MODE_CTRL_M8_MODE_Pos = 0x0
	// Bit mask of M8_MODE field.
	TEE_M8_MODE_CTRL_M8_MODE_Msk = 0x3

	// M9_MODE_CTRL: Tee mode control register
	// Position of M9_MODE field.
	TEE_M9_MODE_CTRL_M9_MODE_Pos = 0x0
	// Bit mask of M9_MODE field.
	TEE_M9_MODE_CTRL_M9_MODE_Msk = 0x3

	// M10_MODE_CTRL: Tee mode control register
	// Position of M10_MODE field.
	TEE_M10_MODE_CTRL_M10_MODE_Pos = 0x0
	// Bit mask of M10_MODE field.
	TEE_M10_MODE_CTRL_M10_MODE_Msk = 0x3

	// M11_MODE_CTRL: Tee mode control register
	// Position of M11_MODE field.
	TEE_M11_MODE_CTRL_M11_MODE_Pos = 0x0
	// Bit mask of M11_MODE field.
	TEE_M11_MODE_CTRL_M11_MODE_Msk = 0x3

	// M12_MODE_CTRL: Tee mode control register
	// Position of M12_MODE field.
	TEE_M12_MODE_CTRL_M12_MODE_Pos = 0x0
	// Bit mask of M12_MODE field.
	TEE_M12_MODE_CTRL_M12_MODE_Msk = 0x3

	// M13_MODE_CTRL: Tee mode control register
	// Position of M13_MODE field.
	TEE_M13_MODE_CTRL_M13_MODE_Pos = 0x0
	// Bit mask of M13_MODE field.
	TEE_M13_MODE_CTRL_M13_MODE_Msk = 0x3

	// M14_MODE_CTRL: Tee mode control register
	// Position of M14_MODE field.
	TEE_M14_MODE_CTRL_M14_MODE_Pos = 0x0
	// Bit mask of M14_MODE field.
	TEE_M14_MODE_CTRL_M14_MODE_Msk = 0x3

	// M15_MODE_CTRL: Tee mode control register
	// Position of M15_MODE field.
	TEE_M15_MODE_CTRL_M15_MODE_Pos = 0x0
	// Bit mask of M15_MODE field.
	TEE_M15_MODE_CTRL_M15_MODE_Msk = 0x3

	// M16_MODE_CTRL: Tee mode control register
	// Position of M16_MODE field.
	TEE_M16_MODE_CTRL_M16_MODE_Pos = 0x0
	// Bit mask of M16_MODE field.
	TEE_M16_MODE_CTRL_M16_MODE_Msk = 0x3

	// M17_MODE_CTRL: Tee mode control register
	// Position of M17_MODE field.
	TEE_M17_MODE_CTRL_M17_MODE_Pos = 0x0
	// Bit mask of M17_MODE field.
	TEE_M17_MODE_CTRL_M17_MODE_Msk = 0x3

	// M18_MODE_CTRL: Tee mode control register
	// Position of M18_MODE field.
	TEE_M18_MODE_CTRL_M18_MODE_Pos = 0x0
	// Bit mask of M18_MODE field.
	TEE_M18_MODE_CTRL_M18_MODE_Msk = 0x3

	// M19_MODE_CTRL: Tee mode control register
	// Position of M19_MODE field.
	TEE_M19_MODE_CTRL_M19_MODE_Pos = 0x0
	// Bit mask of M19_MODE field.
	TEE_M19_MODE_CTRL_M19_MODE_Msk = 0x3

	// M20_MODE_CTRL: Tee mode control register
	// Position of M20_MODE field.
	TEE_M20_MODE_CTRL_M20_MODE_Pos = 0x0
	// Bit mask of M20_MODE field.
	TEE_M20_MODE_CTRL_M20_MODE_Msk = 0x3

	// M21_MODE_CTRL: Tee mode control register
	// Position of M21_MODE field.
	TEE_M21_MODE_CTRL_M21_MODE_Pos = 0x0
	// Bit mask of M21_MODE field.
	TEE_M21_MODE_CTRL_M21_MODE_Msk = 0x3

	// M22_MODE_CTRL: Tee mode control register
	// Position of M22_MODE field.
	TEE_M22_MODE_CTRL_M22_MODE_Pos = 0x0
	// Bit mask of M22_MODE field.
	TEE_M22_MODE_CTRL_M22_MODE_Msk = 0x3

	// M23_MODE_CTRL: Tee mode control register
	// Position of M23_MODE field.
	TEE_M23_MODE_CTRL_M23_MODE_Pos = 0x0
	// Bit mask of M23_MODE field.
	TEE_M23_MODE_CTRL_M23_MODE_Msk = 0x3

	// M24_MODE_CTRL: Tee mode control register
	// Position of M24_MODE field.
	TEE_M24_MODE_CTRL_M24_MODE_Pos = 0x0
	// Bit mask of M24_MODE field.
	TEE_M24_MODE_CTRL_M24_MODE_Msk = 0x3

	// M25_MODE_CTRL: Tee mode control register
	// Position of M25_MODE field.
	TEE_M25_MODE_CTRL_M25_MODE_Pos = 0x0
	// Bit mask of M25_MODE field.
	TEE_M25_MODE_CTRL_M25_MODE_Msk = 0x3

	// M26_MODE_CTRL: Tee mode control register
	// Position of M26_MODE field.
	TEE_M26_MODE_CTRL_M26_MODE_Pos = 0x0
	// Bit mask of M26_MODE field.
	TEE_M26_MODE_CTRL_M26_MODE_Msk = 0x3

	// M27_MODE_CTRL: Tee mode control register
	// Position of M27_MODE field.
	TEE_M27_MODE_CTRL_M27_MODE_Pos = 0x0
	// Bit mask of M27_MODE field.
	TEE_M27_MODE_CTRL_M27_MODE_Msk = 0x3

	// M28_MODE_CTRL: Tee mode control register
	// Position of M28_MODE field.
	TEE_M28_MODE_CTRL_M28_MODE_Pos = 0x0
	// Bit mask of M28_MODE field.
	TEE_M28_MODE_CTRL_M28_MODE_Msk = 0x3

	// M29_MODE_CTRL: Tee mode control register
	// Position of M29_MODE field.
	TEE_M29_MODE_CTRL_M29_MODE_Pos = 0x0
	// Bit mask of M29_MODE field.
	TEE_M29_MODE_CTRL_M29_MODE_Msk = 0x3

	// M30_MODE_CTRL: Tee mode control register
	// Position of M30_MODE field.
	TEE_M30_MODE_CTRL_M30_MODE_Pos = 0x0
	// Bit mask of M30_MODE field.
	TEE_M30_MODE_CTRL_M30_MODE_Msk = 0x3

	// M31_MODE_CTRL: Tee mode control register
	// Position of M31_MODE field.
	TEE_M31_MODE_CTRL_M31_MODE_Pos = 0x0
	// Bit mask of M31_MODE field.
	TEE_M31_MODE_CTRL_M31_MODE_Msk = 0x3

	// CLOCK_GATE: Clock gating register
	// Position of CLK_EN field.
	TEE_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	TEE_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	TEE_CLOCK_GATE_CLK_EN = 0x1

	// DATE: Version register
	// Position of DATE field.
	TEE_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	TEE_DATE_DATE_Msk = 0xfffffff
)

// Constants for TIMG0: Timer Group 0
const (
	// T0CONFIG: Timer %s configuration register
	// Position of USE_XTAL field.
	TIMG_T0CONFIG_USE_XTAL_Pos = 0x9
	// Bit mask of USE_XTAL field.
	TIMG_T0CONFIG_USE_XTAL_Msk = 0x200
	// Bit USE_XTAL.
	TIMG_T0CONFIG_USE_XTAL = 0x200
	// Position of ALARM_EN field.
	TIMG_T0CONFIG_ALARM_EN_Pos = 0xa
	// Bit mask of ALARM_EN field.
	TIMG_T0CONFIG_ALARM_EN_Msk = 0x400
	// Bit ALARM_EN.
	TIMG_T0CONFIG_ALARM_EN = 0x400
	// Position of DIVCNT_RST field.
	TIMG_T0CONFIG_DIVCNT_RST_Pos = 0xc
	// Bit mask of DIVCNT_RST field.
	TIMG_T0CONFIG_DIVCNT_RST_Msk = 0x1000
	// Bit DIVCNT_RST.
	TIMG_T0CONFIG_DIVCNT_RST = 0x1000
	// Position of DIVIDER field.
	TIMG_T0CONFIG_DIVIDER_Pos = 0xd
	// Bit mask of DIVIDER field.
	TIMG_T0CONFIG_DIVIDER_Msk = 0x1fffe000
	// Position of AUTORELOAD field.
	TIMG_T0CONFIG_AUTORELOAD_Pos = 0x1d
	// Bit mask of AUTORELOAD field.
	TIMG_T0CONFIG_AUTORELOAD_Msk = 0x20000000
	// Bit AUTORELOAD.
	TIMG_T0CONFIG_AUTORELOAD = 0x20000000
	// Position of INCREASE field.
	TIMG_T0CONFIG_INCREASE_Pos = 0x1e
	// Bit mask of INCREASE field.
	TIMG_T0CONFIG_INCREASE_Msk = 0x40000000
	// Bit INCREASE.
	TIMG_T0CONFIG_INCREASE = 0x40000000
	// Position of EN field.
	TIMG_T0CONFIG_EN_Pos = 0x1f
	// Bit mask of EN field.
	TIMG_T0CONFIG_EN_Msk = 0x80000000
	// Bit EN.
	TIMG_T0CONFIG_EN = 0x80000000

	// T0LO: Timer %s current value, low 32 bits
	// Position of LO field.
	TIMG_T0LO_LO_Pos = 0x0
	// Bit mask of LO field.
	TIMG_T0LO_LO_Msk = 0xffffffff

	// T0HI: Timer %s current value, high 22 bits
	// Position of HI field.
	TIMG_T0HI_HI_Pos = 0x0
	// Bit mask of HI field.
	TIMG_T0HI_HI_Msk = 0x3fffff

	// T0UPDATE: Write to copy current timer value to TIMGn_T%s_(LO/HI)_REG
	// Position of UPDATE field.
	TIMG_T0UPDATE_UPDATE_Pos = 0x1f
	// Bit mask of UPDATE field.
	TIMG_T0UPDATE_UPDATE_Msk = 0x80000000
	// Bit UPDATE.
	TIMG_T0UPDATE_UPDATE = 0x80000000

	// T0ALARMLO: Timer %s alarm value, low 32 bits
	// Position of ALARM_LO field.
	TIMG_T0ALARMLO_ALARM_LO_Pos = 0x0
	// Bit mask of ALARM_LO field.
	TIMG_T0ALARMLO_ALARM_LO_Msk = 0xffffffff

	// T0ALARMHI: Timer %s alarm value, high bits
	// Position of ALARM_HI field.
	TIMG_T0ALARMHI_ALARM_HI_Pos = 0x0
	// Bit mask of ALARM_HI field.
	TIMG_T0ALARMHI_ALARM_HI_Msk = 0x3fffff

	// T0LOADLO: Timer %s reload value, low 32 bits
	// Position of LOAD_LO field.
	TIMG_T0LOADLO_LOAD_LO_Pos = 0x0
	// Bit mask of LOAD_LO field.
	TIMG_T0LOADLO_LOAD_LO_Msk = 0xffffffff

	// T0LOADHI: Timer %s reload value, high 22 bits
	// Position of LOAD_HI field.
	TIMG_T0LOADHI_LOAD_HI_Pos = 0x0
	// Bit mask of LOAD_HI field.
	TIMG_T0LOADHI_LOAD_HI_Msk = 0x3fffff

	// T0LOAD: Write to reload timer from TIMG_T%s_(LOADLOLOADHI)_REG
	// Position of LOAD field.
	TIMG_T0LOAD_LOAD_Pos = 0x0
	// Bit mask of LOAD field.
	TIMG_T0LOAD_LOAD_Msk = 0xffffffff

	// WDTCONFIG0: Watchdog timer configuration register
	// Position of WDT_APPCPU_RESET_EN field.
	TIMG_WDTCONFIG0_WDT_APPCPU_RESET_EN_Pos = 0xc
	// Bit mask of WDT_APPCPU_RESET_EN field.
	TIMG_WDTCONFIG0_WDT_APPCPU_RESET_EN_Msk = 0x1000
	// Bit WDT_APPCPU_RESET_EN.
	TIMG_WDTCONFIG0_WDT_APPCPU_RESET_EN = 0x1000
	// Position of WDT_PROCPU_RESET_EN field.
	TIMG_WDTCONFIG0_WDT_PROCPU_RESET_EN_Pos = 0xd
	// Bit mask of WDT_PROCPU_RESET_EN field.
	TIMG_WDTCONFIG0_WDT_PROCPU_RESET_EN_Msk = 0x2000
	// Bit WDT_PROCPU_RESET_EN.
	TIMG_WDTCONFIG0_WDT_PROCPU_RESET_EN = 0x2000
	// Position of WDT_FLASHBOOT_MOD_EN field.
	TIMG_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Pos = 0xe
	// Bit mask of WDT_FLASHBOOT_MOD_EN field.
	TIMG_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Msk = 0x4000
	// Bit WDT_FLASHBOOT_MOD_EN.
	TIMG_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN = 0x4000
	// Position of WDT_SYS_RESET_LENGTH field.
	TIMG_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Pos = 0xf
	// Bit mask of WDT_SYS_RESET_LENGTH field.
	TIMG_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Msk = 0x38000
	// Position of WDT_CPU_RESET_LENGTH field.
	TIMG_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Pos = 0x12
	// Bit mask of WDT_CPU_RESET_LENGTH field.
	TIMG_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Msk = 0x1c0000
	// Position of WDT_USE_XTAL field.
	TIMG_WDTCONFIG0_WDT_USE_XTAL_Pos = 0x15
	// Bit mask of WDT_USE_XTAL field.
	TIMG_WDTCONFIG0_WDT_USE_XTAL_Msk = 0x200000
	// Bit WDT_USE_XTAL.
	TIMG_WDTCONFIG0_WDT_USE_XTAL = 0x200000
	// Position of WDT_CONF_UPDATE_EN field.
	TIMG_WDTCONFIG0_WDT_CONF_UPDATE_EN_Pos = 0x16
	// Bit mask of WDT_CONF_UPDATE_EN field.
	TIMG_WDTCONFIG0_WDT_CONF_UPDATE_EN_Msk = 0x400000
	// Bit WDT_CONF_UPDATE_EN.
	TIMG_WDTCONFIG0_WDT_CONF_UPDATE_EN = 0x400000
	// Position of WDT_STG3 field.
	TIMG_WDTCONFIG0_WDT_STG3_Pos = 0x17
	// Bit mask of WDT_STG3 field.
	TIMG_WDTCONFIG0_WDT_STG3_Msk = 0x1800000
	// Position of WDT_STG2 field.
	TIMG_WDTCONFIG0_WDT_STG2_Pos = 0x19
	// Bit mask of WDT_STG2 field.
	TIMG_WDTCONFIG0_WDT_STG2_Msk = 0x6000000
	// Position of WDT_STG1 field.
	TIMG_WDTCONFIG0_WDT_STG1_Pos = 0x1b
	// Bit mask of WDT_STG1 field.
	TIMG_WDTCONFIG0_WDT_STG1_Msk = 0x18000000
	// Position of WDT_STG0 field.
	TIMG_WDTCONFIG0_WDT_STG0_Pos = 0x1d
	// Bit mask of WDT_STG0 field.
	TIMG_WDTCONFIG0_WDT_STG0_Msk = 0x60000000
	// Position of WDT_EN field.
	TIMG_WDTCONFIG0_WDT_EN_Pos = 0x1f
	// Bit mask of WDT_EN field.
	TIMG_WDTCONFIG0_WDT_EN_Msk = 0x80000000
	// Bit WDT_EN.
	TIMG_WDTCONFIG0_WDT_EN = 0x80000000

	// WDTCONFIG1: Watchdog timer prescaler register
	// Position of WDT_DIVCNT_RST field.
	TIMG_WDTCONFIG1_WDT_DIVCNT_RST_Pos = 0x0
	// Bit mask of WDT_DIVCNT_RST field.
	TIMG_WDTCONFIG1_WDT_DIVCNT_RST_Msk = 0x1
	// Bit WDT_DIVCNT_RST.
	TIMG_WDTCONFIG1_WDT_DIVCNT_RST = 0x1
	// Position of WDT_CLK_PRESCALE field.
	TIMG_WDTCONFIG1_WDT_CLK_PRESCALE_Pos = 0x10
	// Bit mask of WDT_CLK_PRESCALE field.
	TIMG_WDTCONFIG1_WDT_CLK_PRESCALE_Msk = 0xffff0000

	// WDTCONFIG2: Watchdog timer stage 0 timeout value
	// Position of WDT_STG0_HOLD field.
	TIMG_WDTCONFIG2_WDT_STG0_HOLD_Pos = 0x0
	// Bit mask of WDT_STG0_HOLD field.
	TIMG_WDTCONFIG2_WDT_STG0_HOLD_Msk = 0xffffffff

	// WDTCONFIG3: Watchdog timer stage 1 timeout value
	// Position of WDT_STG1_HOLD field.
	TIMG_WDTCONFIG3_WDT_STG1_HOLD_Pos = 0x0
	// Bit mask of WDT_STG1_HOLD field.
	TIMG_WDTCONFIG3_WDT_STG1_HOLD_Msk = 0xffffffff

	// WDTCONFIG4: Watchdog timer stage 2 timeout value
	// Position of WDT_STG2_HOLD field.
	TIMG_WDTCONFIG4_WDT_STG2_HOLD_Pos = 0x0
	// Bit mask of WDT_STG2_HOLD field.
	TIMG_WDTCONFIG4_WDT_STG2_HOLD_Msk = 0xffffffff

	// WDTCONFIG5: Watchdog timer stage 3 timeout value
	// Position of WDT_STG3_HOLD field.
	TIMG_WDTCONFIG5_WDT_STG3_HOLD_Pos = 0x0
	// Bit mask of WDT_STG3_HOLD field.
	TIMG_WDTCONFIG5_WDT_STG3_HOLD_Msk = 0xffffffff

	// WDTFEED: Write to feed the watchdog timer
	// Position of WDT_FEED field.
	TIMG_WDTFEED_WDT_FEED_Pos = 0x0
	// Bit mask of WDT_FEED field.
	TIMG_WDTFEED_WDT_FEED_Msk = 0xffffffff

	// WDTWPROTECT: Watchdog write protect register
	// Position of WDT_WKEY field.
	TIMG_WDTWPROTECT_WDT_WKEY_Pos = 0x0
	// Bit mask of WDT_WKEY field.
	TIMG_WDTWPROTECT_WDT_WKEY_Msk = 0xffffffff

	// RTCCALICFG: RTC calibration configure register
	// Position of RTC_CALI_START_CYCLING field.
	TIMG_RTCCALICFG_RTC_CALI_START_CYCLING_Pos = 0xc
	// Bit mask of RTC_CALI_START_CYCLING field.
	TIMG_RTCCALICFG_RTC_CALI_START_CYCLING_Msk = 0x1000
	// Bit RTC_CALI_START_CYCLING.
	TIMG_RTCCALICFG_RTC_CALI_START_CYCLING = 0x1000
	// Position of RTC_CALI_CLK_SEL field.
	TIMG_RTCCALICFG_RTC_CALI_CLK_SEL_Pos = 0xd
	// Bit mask of RTC_CALI_CLK_SEL field.
	TIMG_RTCCALICFG_RTC_CALI_CLK_SEL_Msk = 0x6000
	// Position of RTC_CALI_RDY field.
	TIMG_RTCCALICFG_RTC_CALI_RDY_Pos = 0xf
	// Bit mask of RTC_CALI_RDY field.
	TIMG_RTCCALICFG_RTC_CALI_RDY_Msk = 0x8000
	// Bit RTC_CALI_RDY.
	TIMG_RTCCALICFG_RTC_CALI_RDY = 0x8000
	// Position of RTC_CALI_MAX field.
	TIMG_RTCCALICFG_RTC_CALI_MAX_Pos = 0x10
	// Bit mask of RTC_CALI_MAX field.
	TIMG_RTCCALICFG_RTC_CALI_MAX_Msk = 0x7fff0000
	// Position of RTC_CALI_START field.
	TIMG_RTCCALICFG_RTC_CALI_START_Pos = 0x1f
	// Bit mask of RTC_CALI_START field.
	TIMG_RTCCALICFG_RTC_CALI_START_Msk = 0x80000000
	// Bit RTC_CALI_START.
	TIMG_RTCCALICFG_RTC_CALI_START = 0x80000000

	// RTCCALICFG1: RTC calibration configure1 register
	// Position of RTC_CALI_CYCLING_DATA_VLD field.
	TIMG_RTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD_Pos = 0x0
	// Bit mask of RTC_CALI_CYCLING_DATA_VLD field.
	TIMG_RTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD_Msk = 0x1
	// Bit RTC_CALI_CYCLING_DATA_VLD.
	TIMG_RTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD = 0x1
	// Position of RTC_CALI_VALUE field.
	TIMG_RTCCALICFG1_RTC_CALI_VALUE_Pos = 0x7
	// Bit mask of RTC_CALI_VALUE field.
	TIMG_RTCCALICFG1_RTC_CALI_VALUE_Msk = 0xffffff80

	// INT_ENA_TIMERS: Interrupt enable bits
	// Position of T0_INT_ENA field.
	TIMG_INT_ENA_TIMERS_T0_INT_ENA_Pos = 0x0
	// Bit mask of T0_INT_ENA field.
	TIMG_INT_ENA_TIMERS_T0_INT_ENA_Msk = 0x1
	// Bit T0_INT_ENA.
	TIMG_INT_ENA_TIMERS_T0_INT_ENA = 0x1
	// Position of WDT_INT_ENA field.
	TIMG_INT_ENA_TIMERS_WDT_INT_ENA_Pos = 0x1
	// Bit mask of WDT_INT_ENA field.
	TIMG_INT_ENA_TIMERS_WDT_INT_ENA_Msk = 0x2
	// Bit WDT_INT_ENA.
	TIMG_INT_ENA_TIMERS_WDT_INT_ENA = 0x2

	// INT_RAW_TIMERS: Raw interrupt status
	// Position of T0_INT_RAW field.
	TIMG_INT_RAW_TIMERS_T0_INT_RAW_Pos = 0x0
	// Bit mask of T0_INT_RAW field.
	TIMG_INT_RAW_TIMERS_T0_INT_RAW_Msk = 0x1
	// Bit T0_INT_RAW.
	TIMG_INT_RAW_TIMERS_T0_INT_RAW = 0x1
	// Position of WDT_INT_RAW field.
	TIMG_INT_RAW_TIMERS_WDT_INT_RAW_Pos = 0x1
	// Bit mask of WDT_INT_RAW field.
	TIMG_INT_RAW_TIMERS_WDT_INT_RAW_Msk = 0x2
	// Bit WDT_INT_RAW.
	TIMG_INT_RAW_TIMERS_WDT_INT_RAW = 0x2

	// INT_ST_TIMERS: Masked interrupt status
	// Position of T0_INT_ST field.
	TIMG_INT_ST_TIMERS_T0_INT_ST_Pos = 0x0
	// Bit mask of T0_INT_ST field.
	TIMG_INT_ST_TIMERS_T0_INT_ST_Msk = 0x1
	// Bit T0_INT_ST.
	TIMG_INT_ST_TIMERS_T0_INT_ST = 0x1
	// Position of WDT_INT_ST field.
	TIMG_INT_ST_TIMERS_WDT_INT_ST_Pos = 0x1
	// Bit mask of WDT_INT_ST field.
	TIMG_INT_ST_TIMERS_WDT_INT_ST_Msk = 0x2
	// Bit WDT_INT_ST.
	TIMG_INT_ST_TIMERS_WDT_INT_ST = 0x2

	// INT_CLR_TIMERS: Interrupt clear bits
	// Position of T0_INT_CLR field.
	TIMG_INT_CLR_TIMERS_T0_INT_CLR_Pos = 0x0
	// Bit mask of T0_INT_CLR field.
	TIMG_INT_CLR_TIMERS_T0_INT_CLR_Msk = 0x1
	// Bit T0_INT_CLR.
	TIMG_INT_CLR_TIMERS_T0_INT_CLR = 0x1
	// Position of WDT_INT_CLR field.
	TIMG_INT_CLR_TIMERS_WDT_INT_CLR_Pos = 0x1
	// Bit mask of WDT_INT_CLR field.
	TIMG_INT_CLR_TIMERS_WDT_INT_CLR_Msk = 0x2
	// Bit WDT_INT_CLR.
	TIMG_INT_CLR_TIMERS_WDT_INT_CLR = 0x2

	// RTCCALICFG2: Timer group calibration register
	// Position of RTC_CALI_TIMEOUT field.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT_Pos = 0x0
	// Bit mask of RTC_CALI_TIMEOUT field.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT_Msk = 0x1
	// Bit RTC_CALI_TIMEOUT.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT = 0x1
	// Position of RTC_CALI_TIMEOUT_RST_CNT field.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT_RST_CNT_Pos = 0x3
	// Bit mask of RTC_CALI_TIMEOUT_RST_CNT field.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT_RST_CNT_Msk = 0x78
	// Position of RTC_CALI_TIMEOUT_THRES field.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT_THRES_Pos = 0x7
	// Bit mask of RTC_CALI_TIMEOUT_THRES field.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT_THRES_Msk = 0xffffff80

	// NTIMERS_DATE: Timer version control register
	// Position of NTIMGS_DATE field.
	TIMG_NTIMERS_DATE_NTIMGS_DATE_Pos = 0x0
	// Bit mask of NTIMGS_DATE field.
	TIMG_NTIMERS_DATE_NTIMGS_DATE_Msk = 0xfffffff

	// REGCLK: Timer group clock gate register
	// Position of ETM_EN field.
	TIMG_REGCLK_ETM_EN_Pos = 0x1c
	// Bit mask of ETM_EN field.
	TIMG_REGCLK_ETM_EN_Msk = 0x10000000
	// Bit ETM_EN.
	TIMG_REGCLK_ETM_EN = 0x10000000
	// Position of WDT_CLK_IS_ACTIVE field.
	TIMG_REGCLK_WDT_CLK_IS_ACTIVE_Pos = 0x1d
	// Bit mask of WDT_CLK_IS_ACTIVE field.
	TIMG_REGCLK_WDT_CLK_IS_ACTIVE_Msk = 0x20000000
	// Bit WDT_CLK_IS_ACTIVE.
	TIMG_REGCLK_WDT_CLK_IS_ACTIVE = 0x20000000
	// Position of TIMER_CLK_IS_ACTIVE field.
	TIMG_REGCLK_TIMER_CLK_IS_ACTIVE_Pos = 0x1e
	// Bit mask of TIMER_CLK_IS_ACTIVE field.
	TIMG_REGCLK_TIMER_CLK_IS_ACTIVE_Msk = 0x40000000
	// Bit TIMER_CLK_IS_ACTIVE.
	TIMG_REGCLK_TIMER_CLK_IS_ACTIVE = 0x40000000
	// Position of CLK_EN field.
	TIMG_REGCLK_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	TIMG_REGCLK_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	TIMG_REGCLK_CLK_EN = 0x80000000
)

// Constants for TRACE: RISC-V Trace Encoder
const (
	// MEM_START_ADDR: mem start addr
	// Position of MEM_STAET_ADDR field.
	TRACE_MEM_START_ADDR_MEM_STAET_ADDR_Pos = 0x0
	// Bit mask of MEM_STAET_ADDR field.
	TRACE_MEM_START_ADDR_MEM_STAET_ADDR_Msk = 0xffffffff

	// MEM_END_ADDR: mem end addr
	// Position of MEM_END_ADDR field.
	TRACE_MEM_END_ADDR_MEM_END_ADDR_Pos = 0x0
	// Bit mask of MEM_END_ADDR field.
	TRACE_MEM_END_ADDR_MEM_END_ADDR_Msk = 0xffffffff

	// MEM_CURRENT_ADDR: mem current addr
	// Position of MEM_CURRENT_ADDR field.
	TRACE_MEM_CURRENT_ADDR_MEM_CURRENT_ADDR_Pos = 0x0
	// Bit mask of MEM_CURRENT_ADDR field.
	TRACE_MEM_CURRENT_ADDR_MEM_CURRENT_ADDR_Msk = 0xffffffff

	// MEM_ADDR_UPDATE: mem addr update
	// Position of MEM_CURRENT_ADDR_UPDATE field.
	TRACE_MEM_ADDR_UPDATE_MEM_CURRENT_ADDR_UPDATE_Pos = 0x0
	// Bit mask of MEM_CURRENT_ADDR_UPDATE field.
	TRACE_MEM_ADDR_UPDATE_MEM_CURRENT_ADDR_UPDATE_Msk = 0x1
	// Bit MEM_CURRENT_ADDR_UPDATE.
	TRACE_MEM_ADDR_UPDATE_MEM_CURRENT_ADDR_UPDATE = 0x1

	// FIFO_STATUS: fifo status register
	// Position of FIFO_EMPTY field.
	TRACE_FIFO_STATUS_FIFO_EMPTY_Pos = 0x0
	// Bit mask of FIFO_EMPTY field.
	TRACE_FIFO_STATUS_FIFO_EMPTY_Msk = 0x1
	// Bit FIFO_EMPTY.
	TRACE_FIFO_STATUS_FIFO_EMPTY = 0x1
	// Position of WORK_STATUS field.
	TRACE_FIFO_STATUS_WORK_STATUS_Pos = 0x1
	// Bit mask of WORK_STATUS field.
	TRACE_FIFO_STATUS_WORK_STATUS_Msk = 0x2
	// Bit WORK_STATUS.
	TRACE_FIFO_STATUS_WORK_STATUS = 0x2

	// INTR_ENA: interrupt enable register
	// Position of FIFO_OVERFLOW_INTR_ENA field.
	TRACE_INTR_ENA_FIFO_OVERFLOW_INTR_ENA_Pos = 0x0
	// Bit mask of FIFO_OVERFLOW_INTR_ENA field.
	TRACE_INTR_ENA_FIFO_OVERFLOW_INTR_ENA_Msk = 0x1
	// Bit FIFO_OVERFLOW_INTR_ENA.
	TRACE_INTR_ENA_FIFO_OVERFLOW_INTR_ENA = 0x1
	// Position of MEM_FULL_INTR_ENA field.
	TRACE_INTR_ENA_MEM_FULL_INTR_ENA_Pos = 0x1
	// Bit mask of MEM_FULL_INTR_ENA field.
	TRACE_INTR_ENA_MEM_FULL_INTR_ENA_Msk = 0x2
	// Bit MEM_FULL_INTR_ENA.
	TRACE_INTR_ENA_MEM_FULL_INTR_ENA = 0x2

	// INTR_RAW: interrupt status register
	// Position of FIFO_OVERFLOW_INTR_RAW field.
	TRACE_INTR_RAW_FIFO_OVERFLOW_INTR_RAW_Pos = 0x0
	// Bit mask of FIFO_OVERFLOW_INTR_RAW field.
	TRACE_INTR_RAW_FIFO_OVERFLOW_INTR_RAW_Msk = 0x1
	// Bit FIFO_OVERFLOW_INTR_RAW.
	TRACE_INTR_RAW_FIFO_OVERFLOW_INTR_RAW = 0x1
	// Position of MEM_FULL_INTR_RAW field.
	TRACE_INTR_RAW_MEM_FULL_INTR_RAW_Pos = 0x1
	// Bit mask of MEM_FULL_INTR_RAW field.
	TRACE_INTR_RAW_MEM_FULL_INTR_RAW_Msk = 0x2
	// Bit MEM_FULL_INTR_RAW.
	TRACE_INTR_RAW_MEM_FULL_INTR_RAW = 0x2

	// INTR_CLR: interrupt clear register
	// Position of FIFO_OVERFLOW_INTR_CLR field.
	TRACE_INTR_CLR_FIFO_OVERFLOW_INTR_CLR_Pos = 0x0
	// Bit mask of FIFO_OVERFLOW_INTR_CLR field.
	TRACE_INTR_CLR_FIFO_OVERFLOW_INTR_CLR_Msk = 0x1
	// Bit FIFO_OVERFLOW_INTR_CLR.
	TRACE_INTR_CLR_FIFO_OVERFLOW_INTR_CLR = 0x1
	// Position of MEM_FULL_INTR_CLR field.
	TRACE_INTR_CLR_MEM_FULL_INTR_CLR_Pos = 0x1
	// Bit mask of MEM_FULL_INTR_CLR field.
	TRACE_INTR_CLR_MEM_FULL_INTR_CLR_Msk = 0x2
	// Bit MEM_FULL_INTR_CLR.
	TRACE_INTR_CLR_MEM_FULL_INTR_CLR = 0x2

	// TRIGGER: trigger register
	// Position of ON field.
	TRACE_TRIGGER_ON_Pos = 0x0
	// Bit mask of ON field.
	TRACE_TRIGGER_ON_Msk = 0x1
	// Bit ON.
	TRACE_TRIGGER_ON = 0x1
	// Position of OFF field.
	TRACE_TRIGGER_OFF_Pos = 0x1
	// Bit mask of OFF field.
	TRACE_TRIGGER_OFF_Msk = 0x2
	// Bit OFF.
	TRACE_TRIGGER_OFF = 0x2
	// Position of MEM_LOOP field.
	TRACE_TRIGGER_MEM_LOOP_Pos = 0x2
	// Bit mask of MEM_LOOP field.
	TRACE_TRIGGER_MEM_LOOP_Msk = 0x4
	// Bit MEM_LOOP.
	TRACE_TRIGGER_MEM_LOOP = 0x4
	// Position of RESTART_ENA field.
	TRACE_TRIGGER_RESTART_ENA_Pos = 0x3
	// Bit mask of RESTART_ENA field.
	TRACE_TRIGGER_RESTART_ENA_Msk = 0x8
	// Bit RESTART_ENA.
	TRACE_TRIGGER_RESTART_ENA = 0x8

	// RESYNC_PROLONGED: resync configuration register
	// Position of RESYNC_PROLONGED field.
	TRACE_RESYNC_PROLONGED_RESYNC_PROLONGED_Pos = 0x0
	// Bit mask of RESYNC_PROLONGED field.
	TRACE_RESYNC_PROLONGED_RESYNC_PROLONGED_Msk = 0xffffff
	// Position of RESYNC_MODE field.
	TRACE_RESYNC_PROLONGED_RESYNC_MODE_Pos = 0x18
	// Bit mask of RESYNC_MODE field.
	TRACE_RESYNC_PROLONGED_RESYNC_MODE_Msk = 0x1000000
	// Bit RESYNC_MODE.
	TRACE_RESYNC_PROLONGED_RESYNC_MODE = 0x1000000

	// CLOCK_GATE: Clock gate control register
	// Position of CLK_EN field.
	TRACE_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	TRACE_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	TRACE_CLOCK_GATE_CLK_EN = 0x1

	// DATE: Version control register
	// Position of DATE field.
	TRACE_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	TRACE_DATE_DATE_Msk = 0xfffffff
)

// Constants for TWAI0: Two-Wire Automotive Interface
const (
	// MODE: TWAI mode register.
	// Position of RESET_MODE field.
	TWAI_MODE_RESET_MODE_Pos = 0x0
	// Bit mask of RESET_MODE field.
	TWAI_MODE_RESET_MODE_Msk = 0x1
	// Bit RESET_MODE.
	TWAI_MODE_RESET_MODE = 0x1
	// Position of LISTEN_ONLY_MODE field.
	TWAI_MODE_LISTEN_ONLY_MODE_Pos = 0x1
	// Bit mask of LISTEN_ONLY_MODE field.
	TWAI_MODE_LISTEN_ONLY_MODE_Msk = 0x2
	// Bit LISTEN_ONLY_MODE.
	TWAI_MODE_LISTEN_ONLY_MODE = 0x2
	// Position of SELF_TEST_MODE field.
	TWAI_MODE_SELF_TEST_MODE_Pos = 0x2
	// Bit mask of SELF_TEST_MODE field.
	TWAI_MODE_SELF_TEST_MODE_Msk = 0x4
	// Bit SELF_TEST_MODE.
	TWAI_MODE_SELF_TEST_MODE = 0x4
	// Position of ACCEPTANCE_FILTER_MODE field.
	TWAI_MODE_ACCEPTANCE_FILTER_MODE_Pos = 0x3
	// Bit mask of ACCEPTANCE_FILTER_MODE field.
	TWAI_MODE_ACCEPTANCE_FILTER_MODE_Msk = 0x8
	// Bit ACCEPTANCE_FILTER_MODE.
	TWAI_MODE_ACCEPTANCE_FILTER_MODE = 0x8

	// CMD: TWAI command register.
	// Position of TX_REQUEST field.
	TWAI_CMD_TX_REQUEST_Pos = 0x0
	// Bit mask of TX_REQUEST field.
	TWAI_CMD_TX_REQUEST_Msk = 0x1
	// Bit TX_REQUEST.
	TWAI_CMD_TX_REQUEST = 0x1
	// Position of ABORT_TX field.
	TWAI_CMD_ABORT_TX_Pos = 0x1
	// Bit mask of ABORT_TX field.
	TWAI_CMD_ABORT_TX_Msk = 0x2
	// Bit ABORT_TX.
	TWAI_CMD_ABORT_TX = 0x2
	// Position of RELEASE_BUFFER field.
	TWAI_CMD_RELEASE_BUFFER_Pos = 0x2
	// Bit mask of RELEASE_BUFFER field.
	TWAI_CMD_RELEASE_BUFFER_Msk = 0x4
	// Bit RELEASE_BUFFER.
	TWAI_CMD_RELEASE_BUFFER = 0x4
	// Position of CLEAR_DATA_OVERRUN field.
	TWAI_CMD_CLEAR_DATA_OVERRUN_Pos = 0x3
	// Bit mask of CLEAR_DATA_OVERRUN field.
	TWAI_CMD_CLEAR_DATA_OVERRUN_Msk = 0x8
	// Bit CLEAR_DATA_OVERRUN.
	TWAI_CMD_CLEAR_DATA_OVERRUN = 0x8
	// Position of SELF_RX_REQUEST field.
	TWAI_CMD_SELF_RX_REQUEST_Pos = 0x4
	// Bit mask of SELF_RX_REQUEST field.
	TWAI_CMD_SELF_RX_REQUEST_Msk = 0x10
	// Bit SELF_RX_REQUEST.
	TWAI_CMD_SELF_RX_REQUEST = 0x10

	// STATUS: TWAI status register.
	// Position of RECEIVE_BUFFER field.
	TWAI_STATUS_RECEIVE_BUFFER_Pos = 0x0
	// Bit mask of RECEIVE_BUFFER field.
	TWAI_STATUS_RECEIVE_BUFFER_Msk = 0x1
	// Bit RECEIVE_BUFFER.
	TWAI_STATUS_RECEIVE_BUFFER = 0x1
	// Position of OVERRUN field.
	TWAI_STATUS_OVERRUN_Pos = 0x1
	// Bit mask of OVERRUN field.
	TWAI_STATUS_OVERRUN_Msk = 0x2
	// Bit OVERRUN.
	TWAI_STATUS_OVERRUN = 0x2
	// Position of TRANSMIT_BUFFER field.
	TWAI_STATUS_TRANSMIT_BUFFER_Pos = 0x2
	// Bit mask of TRANSMIT_BUFFER field.
	TWAI_STATUS_TRANSMIT_BUFFER_Msk = 0x4
	// Bit TRANSMIT_BUFFER.
	TWAI_STATUS_TRANSMIT_BUFFER = 0x4
	// Position of TRANSMISSION_COMPLETE field.
	TWAI_STATUS_TRANSMISSION_COMPLETE_Pos = 0x3
	// Bit mask of TRANSMISSION_COMPLETE field.
	TWAI_STATUS_TRANSMISSION_COMPLETE_Msk = 0x8
	// Bit TRANSMISSION_COMPLETE.
	TWAI_STATUS_TRANSMISSION_COMPLETE = 0x8
	// Position of RECEIVE field.
	TWAI_STATUS_RECEIVE_Pos = 0x4
	// Bit mask of RECEIVE field.
	TWAI_STATUS_RECEIVE_Msk = 0x10
	// Bit RECEIVE.
	TWAI_STATUS_RECEIVE = 0x10
	// Position of TRANSMIT field.
	TWAI_STATUS_TRANSMIT_Pos = 0x5
	// Bit mask of TRANSMIT field.
	TWAI_STATUS_TRANSMIT_Msk = 0x20
	// Bit TRANSMIT.
	TWAI_STATUS_TRANSMIT = 0x20
	// Position of ERR field.
	TWAI_STATUS_ERR_Pos = 0x6
	// Bit mask of ERR field.
	TWAI_STATUS_ERR_Msk = 0x40
	// Bit ERR.
	TWAI_STATUS_ERR = 0x40
	// Position of NODE_BUS_OFF field.
	TWAI_STATUS_NODE_BUS_OFF_Pos = 0x7
	// Bit mask of NODE_BUS_OFF field.
	TWAI_STATUS_NODE_BUS_OFF_Msk = 0x80
	// Bit NODE_BUS_OFF.
	TWAI_STATUS_NODE_BUS_OFF = 0x80
	// Position of MISS field.
	TWAI_STATUS_MISS_Pos = 0x8
	// Bit mask of MISS field.
	TWAI_STATUS_MISS_Msk = 0x100
	// Bit MISS.
	TWAI_STATUS_MISS = 0x100

	// INTERRUPT: Interrupt signals' register.
	// Position of RECEIVE_INT_ST field.
	TWAI_INTERRUPT_RECEIVE_INT_ST_Pos = 0x0
	// Bit mask of RECEIVE_INT_ST field.
	TWAI_INTERRUPT_RECEIVE_INT_ST_Msk = 0x1
	// Bit RECEIVE_INT_ST.
	TWAI_INTERRUPT_RECEIVE_INT_ST = 0x1
	// Position of TRANSMIT_INT_ST field.
	TWAI_INTERRUPT_TRANSMIT_INT_ST_Pos = 0x1
	// Bit mask of TRANSMIT_INT_ST field.
	TWAI_INTERRUPT_TRANSMIT_INT_ST_Msk = 0x2
	// Bit TRANSMIT_INT_ST.
	TWAI_INTERRUPT_TRANSMIT_INT_ST = 0x2
	// Position of ERR_WARNING_INT_ST field.
	TWAI_INTERRUPT_ERR_WARNING_INT_ST_Pos = 0x2
	// Bit mask of ERR_WARNING_INT_ST field.
	TWAI_INTERRUPT_ERR_WARNING_INT_ST_Msk = 0x4
	// Bit ERR_WARNING_INT_ST.
	TWAI_INTERRUPT_ERR_WARNING_INT_ST = 0x4
	// Position of DATA_OVERRUN_INT_ST field.
	TWAI_INTERRUPT_DATA_OVERRUN_INT_ST_Pos = 0x3
	// Bit mask of DATA_OVERRUN_INT_ST field.
	TWAI_INTERRUPT_DATA_OVERRUN_INT_ST_Msk = 0x8
	// Bit DATA_OVERRUN_INT_ST.
	TWAI_INTERRUPT_DATA_OVERRUN_INT_ST = 0x8
	// Position of ERR_PASSIVE_INT_ST field.
	TWAI_INTERRUPT_ERR_PASSIVE_INT_ST_Pos = 0x5
	// Bit mask of ERR_PASSIVE_INT_ST field.
	TWAI_INTERRUPT_ERR_PASSIVE_INT_ST_Msk = 0x20
	// Bit ERR_PASSIVE_INT_ST.
	TWAI_INTERRUPT_ERR_PASSIVE_INT_ST = 0x20
	// Position of ARBITRATION_LOST_INT_ST field.
	TWAI_INTERRUPT_ARBITRATION_LOST_INT_ST_Pos = 0x6
	// Bit mask of ARBITRATION_LOST_INT_ST field.
	TWAI_INTERRUPT_ARBITRATION_LOST_INT_ST_Msk = 0x40
	// Bit ARBITRATION_LOST_INT_ST.
	TWAI_INTERRUPT_ARBITRATION_LOST_INT_ST = 0x40
	// Position of BUS_ERR_INT_ST field.
	TWAI_INTERRUPT_BUS_ERR_INT_ST_Pos = 0x7
	// Bit mask of BUS_ERR_INT_ST field.
	TWAI_INTERRUPT_BUS_ERR_INT_ST_Msk = 0x80
	// Bit BUS_ERR_INT_ST.
	TWAI_INTERRUPT_BUS_ERR_INT_ST = 0x80
	// Position of IDLE_INT_ST field.
	TWAI_INTERRUPT_IDLE_INT_ST_Pos = 0x8
	// Bit mask of IDLE_INT_ST field.
	TWAI_INTERRUPT_IDLE_INT_ST_Msk = 0x100
	// Bit IDLE_INT_ST.
	TWAI_INTERRUPT_IDLE_INT_ST = 0x100

	// INTERRUPT_ENABLE: Interrupt enable register.
	// Position of EXT_RECEIVE_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_EXT_RECEIVE_INT_ENA_Pos = 0x0
	// Bit mask of EXT_RECEIVE_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_EXT_RECEIVE_INT_ENA_Msk = 0x1
	// Bit EXT_RECEIVE_INT_ENA.
	TWAI_INTERRUPT_ENABLE_EXT_RECEIVE_INT_ENA = 0x1
	// Position of EXT_TRANSMIT_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_EXT_TRANSMIT_INT_ENA_Pos = 0x1
	// Bit mask of EXT_TRANSMIT_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_EXT_TRANSMIT_INT_ENA_Msk = 0x2
	// Bit EXT_TRANSMIT_INT_ENA.
	TWAI_INTERRUPT_ENABLE_EXT_TRANSMIT_INT_ENA = 0x2
	// Position of EXT_ERR_WARNING_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_EXT_ERR_WARNING_INT_ENA_Pos = 0x2
	// Bit mask of EXT_ERR_WARNING_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_EXT_ERR_WARNING_INT_ENA_Msk = 0x4
	// Bit EXT_ERR_WARNING_INT_ENA.
	TWAI_INTERRUPT_ENABLE_EXT_ERR_WARNING_INT_ENA = 0x4
	// Position of EXT_DATA_OVERRUN_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_EXT_DATA_OVERRUN_INT_ENA_Pos = 0x3
	// Bit mask of EXT_DATA_OVERRUN_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_EXT_DATA_OVERRUN_INT_ENA_Msk = 0x8
	// Bit EXT_DATA_OVERRUN_INT_ENA.
	TWAI_INTERRUPT_ENABLE_EXT_DATA_OVERRUN_INT_ENA = 0x8
	// Position of ERR_PASSIVE_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_ERR_PASSIVE_INT_ENA_Pos = 0x5
	// Bit mask of ERR_PASSIVE_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_ERR_PASSIVE_INT_ENA_Msk = 0x20
	// Bit ERR_PASSIVE_INT_ENA.
	TWAI_INTERRUPT_ENABLE_ERR_PASSIVE_INT_ENA = 0x20
	// Position of ARBITRATION_LOST_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_ARBITRATION_LOST_INT_ENA_Pos = 0x6
	// Bit mask of ARBITRATION_LOST_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_ARBITRATION_LOST_INT_ENA_Msk = 0x40
	// Bit ARBITRATION_LOST_INT_ENA.
	TWAI_INTERRUPT_ENABLE_ARBITRATION_LOST_INT_ENA = 0x40
	// Position of BUS_ERR_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_BUS_ERR_INT_ENA_Pos = 0x7
	// Bit mask of BUS_ERR_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_BUS_ERR_INT_ENA_Msk = 0x80
	// Bit BUS_ERR_INT_ENA.
	TWAI_INTERRUPT_ENABLE_BUS_ERR_INT_ENA = 0x80
	// Position of IDLE_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_IDLE_INT_ENA_Pos = 0x8
	// Bit mask of IDLE_INT_ENA field.
	TWAI_INTERRUPT_ENABLE_IDLE_INT_ENA_Msk = 0x100
	// Bit IDLE_INT_ENA.
	TWAI_INTERRUPT_ENABLE_IDLE_INT_ENA = 0x100

	// BUS_TIMING_0: Bit timing configuration register 0.
	// Position of BAUD_PRESC field.
	TWAI_BUS_TIMING_0_BAUD_PRESC_Pos = 0x0
	// Bit mask of BAUD_PRESC field.
	TWAI_BUS_TIMING_0_BAUD_PRESC_Msk = 0x3fff
	// Position of SYNC_JUMP_WIDTH field.
	TWAI_BUS_TIMING_0_SYNC_JUMP_WIDTH_Pos = 0xe
	// Bit mask of SYNC_JUMP_WIDTH field.
	TWAI_BUS_TIMING_0_SYNC_JUMP_WIDTH_Msk = 0xc000

	// BUS_TIMING_1: Bit timing configuration register 1.
	// Position of TIME_SEGMENT1 field.
	TWAI_BUS_TIMING_1_TIME_SEGMENT1_Pos = 0x0
	// Bit mask of TIME_SEGMENT1 field.
	TWAI_BUS_TIMING_1_TIME_SEGMENT1_Msk = 0xf
	// Position of TIME_SEGMENT2 field.
	TWAI_BUS_TIMING_1_TIME_SEGMENT2_Pos = 0x4
	// Bit mask of TIME_SEGMENT2 field.
	TWAI_BUS_TIMING_1_TIME_SEGMENT2_Msk = 0x70
	// Position of TIME_SAMPLING field.
	TWAI_BUS_TIMING_1_TIME_SAMPLING_Pos = 0x7
	// Bit mask of TIME_SAMPLING field.
	TWAI_BUS_TIMING_1_TIME_SAMPLING_Msk = 0x80
	// Bit TIME_SAMPLING.
	TWAI_BUS_TIMING_1_TIME_SAMPLING = 0x80

	// ARB_LOST_CAP: TWAI arbiter lost capture register.
	// Position of ARBITRATION_LOST_CAPTURE field.
	TWAI_ARB_LOST_CAP_ARBITRATION_LOST_CAPTURE_Pos = 0x0
	// Bit mask of ARBITRATION_LOST_CAPTURE field.
	TWAI_ARB_LOST_CAP_ARBITRATION_LOST_CAPTURE_Msk = 0x1f

	// ERR_CODE_CAP: TWAI error info capture register.
	// Position of ERR_CAPTURE_CODE_SEGMENT field.
	TWAI_ERR_CODE_CAP_ERR_CAPTURE_CODE_SEGMENT_Pos = 0x0
	// Bit mask of ERR_CAPTURE_CODE_SEGMENT field.
	TWAI_ERR_CODE_CAP_ERR_CAPTURE_CODE_SEGMENT_Msk = 0x1f
	// Position of ERR_CAPTURE_CODE_DIRECTION field.
	TWAI_ERR_CODE_CAP_ERR_CAPTURE_CODE_DIRECTION_Pos = 0x5
	// Bit mask of ERR_CAPTURE_CODE_DIRECTION field.
	TWAI_ERR_CODE_CAP_ERR_CAPTURE_CODE_DIRECTION_Msk = 0x20
	// Bit ERR_CAPTURE_CODE_DIRECTION.
	TWAI_ERR_CODE_CAP_ERR_CAPTURE_CODE_DIRECTION = 0x20
	// Position of ERR_CAPTURE_CODE_TYPE field.
	TWAI_ERR_CODE_CAP_ERR_CAPTURE_CODE_TYPE_Pos = 0x6
	// Bit mask of ERR_CAPTURE_CODE_TYPE field.
	TWAI_ERR_CODE_CAP_ERR_CAPTURE_CODE_TYPE_Msk = 0xc0

	// ERR_WARNING_LIMIT: TWAI error threshold configuration register.
	// Position of ERR_WARNING_LIMIT field.
	TWAI_ERR_WARNING_LIMIT_ERR_WARNING_LIMIT_Pos = 0x0
	// Bit mask of ERR_WARNING_LIMIT field.
	TWAI_ERR_WARNING_LIMIT_ERR_WARNING_LIMIT_Msk = 0xff

	// RX_ERR_CNT: Rx error counter register.
	// Position of RX_ERR_CNT field.
	TWAI_RX_ERR_CNT_RX_ERR_CNT_Pos = 0x0
	// Bit mask of RX_ERR_CNT field.
	TWAI_RX_ERR_CNT_RX_ERR_CNT_Msk = 0xff

	// TX_ERR_CNT: Tx error counter register.
	// Position of TX_ERR_CNT field.
	TWAI_TX_ERR_CNT_TX_ERR_CNT_Pos = 0x0
	// Bit mask of TX_ERR_CNT field.
	TWAI_TX_ERR_CNT_TX_ERR_CNT_Msk = 0xff

	// DATA_0: Data register 0.
	// Position of DATA_0 field.
	TWAI_DATA_0_DATA_0_Pos = 0x0
	// Bit mask of DATA_0 field.
	TWAI_DATA_0_DATA_0_Msk = 0xff

	// DATA_1: Data register 1.
	// Position of DATA_1 field.
	TWAI_DATA_1_DATA_1_Pos = 0x0
	// Bit mask of DATA_1 field.
	TWAI_DATA_1_DATA_1_Msk = 0xff

	// DATA_2: Data register 2.
	// Position of DATA_2 field.
	TWAI_DATA_2_DATA_2_Pos = 0x0
	// Bit mask of DATA_2 field.
	TWAI_DATA_2_DATA_2_Msk = 0xff

	// DATA_3: Data register 3.
	// Position of DATA_3 field.
	TWAI_DATA_3_DATA_3_Pos = 0x0
	// Bit mask of DATA_3 field.
	TWAI_DATA_3_DATA_3_Msk = 0xff

	// DATA_4: Data register 4.
	// Position of DATA_4 field.
	TWAI_DATA_4_DATA_4_Pos = 0x0
	// Bit mask of DATA_4 field.
	TWAI_DATA_4_DATA_4_Msk = 0xff

	// DATA_5: Data register 5.
	// Position of DATA_5 field.
	TWAI_DATA_5_DATA_5_Pos = 0x0
	// Bit mask of DATA_5 field.
	TWAI_DATA_5_DATA_5_Msk = 0xff

	// DATA_6: Data register 6.
	// Position of DATA_6 field.
	TWAI_DATA_6_DATA_6_Pos = 0x0
	// Bit mask of DATA_6 field.
	TWAI_DATA_6_DATA_6_Msk = 0xff

	// DATA_7: Data register 7.
	// Position of DATA_7 field.
	TWAI_DATA_7_DATA_7_Pos = 0x0
	// Bit mask of DATA_7 field.
	TWAI_DATA_7_DATA_7_Msk = 0xff

	// DATA_8: Data register 8.
	// Position of DATA_8 field.
	TWAI_DATA_8_DATA_8_Pos = 0x0
	// Bit mask of DATA_8 field.
	TWAI_DATA_8_DATA_8_Msk = 0xff

	// DATA_9: Data register 9.
	// Position of DATA_9 field.
	TWAI_DATA_9_DATA_9_Pos = 0x0
	// Bit mask of DATA_9 field.
	TWAI_DATA_9_DATA_9_Msk = 0xff

	// DATA_10: Data register 10.
	// Position of DATA_10 field.
	TWAI_DATA_10_DATA_10_Pos = 0x0
	// Bit mask of DATA_10 field.
	TWAI_DATA_10_DATA_10_Msk = 0xff

	// DATA_11: Data register 11.
	// Position of DATA_11 field.
	TWAI_DATA_11_DATA_11_Pos = 0x0
	// Bit mask of DATA_11 field.
	TWAI_DATA_11_DATA_11_Msk = 0xff

	// DATA_12: Data register 12.
	// Position of DATA_12 field.
	TWAI_DATA_12_DATA_12_Pos = 0x0
	// Bit mask of DATA_12 field.
	TWAI_DATA_12_DATA_12_Msk = 0xff

	// RX_MESSAGE_COUNTER: Received message counter register.
	// Position of RX_MESSAGE_COUNTER field.
	TWAI_RX_MESSAGE_COUNTER_RX_MESSAGE_COUNTER_Pos = 0x0
	// Bit mask of RX_MESSAGE_COUNTER field.
	TWAI_RX_MESSAGE_COUNTER_RX_MESSAGE_COUNTER_Msk = 0x7f

	// CLOCK_DIVIDER: Clock divider register.
	// Position of CD field.
	TWAI_CLOCK_DIVIDER_CD_Pos = 0x0
	// Bit mask of CD field.
	TWAI_CLOCK_DIVIDER_CD_Msk = 0xff
	// Position of CLOCK_OFF field.
	TWAI_CLOCK_DIVIDER_CLOCK_OFF_Pos = 0x8
	// Bit mask of CLOCK_OFF field.
	TWAI_CLOCK_DIVIDER_CLOCK_OFF_Msk = 0x100
	// Bit CLOCK_OFF.
	TWAI_CLOCK_DIVIDER_CLOCK_OFF = 0x100

	// SW_STANDBY_CFG: Software configure standby pin directly.
	// Position of SW_STANDBY_EN field.
	TWAI_SW_STANDBY_CFG_SW_STANDBY_EN_Pos = 0x0
	// Bit mask of SW_STANDBY_EN field.
	TWAI_SW_STANDBY_CFG_SW_STANDBY_EN_Msk = 0x1
	// Bit SW_STANDBY_EN.
	TWAI_SW_STANDBY_CFG_SW_STANDBY_EN = 0x1
	// Position of SW_STANDBY_CLR field.
	TWAI_SW_STANDBY_CFG_SW_STANDBY_CLR_Pos = 0x1
	// Bit mask of SW_STANDBY_CLR field.
	TWAI_SW_STANDBY_CFG_SW_STANDBY_CLR_Msk = 0x2
	// Bit SW_STANDBY_CLR.
	TWAI_SW_STANDBY_CFG_SW_STANDBY_CLR = 0x2

	// HW_CFG: Hardware configure standby pin.
	// Position of HW_STANDBY_EN field.
	TWAI_HW_CFG_HW_STANDBY_EN_Pos = 0x0
	// Bit mask of HW_STANDBY_EN field.
	TWAI_HW_CFG_HW_STANDBY_EN_Msk = 0x1
	// Bit HW_STANDBY_EN.
	TWAI_HW_CFG_HW_STANDBY_EN = 0x1

	// HW_STANDBY_CNT: Configure standby counter.
	// Position of STANDBY_WAIT_CNT field.
	TWAI_HW_STANDBY_CNT_STANDBY_WAIT_CNT_Pos = 0x0
	// Bit mask of STANDBY_WAIT_CNT field.
	TWAI_HW_STANDBY_CNT_STANDBY_WAIT_CNT_Msk = 0xffffffff

	// IDLE_INTR_CNT: Configure idle interrupt counter.
	// Position of IDLE_INTR_CNT field.
	TWAI_IDLE_INTR_CNT_IDLE_INTR_CNT_Pos = 0x0
	// Bit mask of IDLE_INTR_CNT field.
	TWAI_IDLE_INTR_CNT_IDLE_INTR_CNT_Msk = 0xffffffff

	// ECO_CFG: ECO configuration register.
	// Position of RDN_ENA field.
	TWAI_ECO_CFG_RDN_ENA_Pos = 0x0
	// Bit mask of RDN_ENA field.
	TWAI_ECO_CFG_RDN_ENA_Msk = 0x1
	// Bit RDN_ENA.
	TWAI_ECO_CFG_RDN_ENA = 0x1
	// Position of RDN_RESULT field.
	TWAI_ECO_CFG_RDN_RESULT_Pos = 0x1
	// Bit mask of RDN_RESULT field.
	TWAI_ECO_CFG_RDN_RESULT_Msk = 0x2
	// Bit RDN_RESULT.
	TWAI_ECO_CFG_RDN_RESULT = 0x2
)

// Constants for UART0: UART (Universal Asynchronous Receiver-Transmitter) Controller 0
const (
	// FIFO: FIFO data register
	// Position of RXFIFO_RD_BYTE field.
	UART_FIFO_RXFIFO_RD_BYTE_Pos = 0x0
	// Bit mask of RXFIFO_RD_BYTE field.
	UART_FIFO_RXFIFO_RD_BYTE_Msk = 0xff

	// INT_RAW: Raw interrupt status
	// Position of RXFIFO_FULL_INT_RAW field.
	UART_INT_RAW_RXFIFO_FULL_INT_RAW_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_RAW field.
	UART_INT_RAW_RXFIFO_FULL_INT_RAW_Msk = 0x1
	// Bit RXFIFO_FULL_INT_RAW.
	UART_INT_RAW_RXFIFO_FULL_INT_RAW = 0x1
	// Position of TXFIFO_EMPTY_INT_RAW field.
	UART_INT_RAW_TXFIFO_EMPTY_INT_RAW_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_RAW field.
	UART_INT_RAW_TXFIFO_EMPTY_INT_RAW_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_RAW.
	UART_INT_RAW_TXFIFO_EMPTY_INT_RAW = 0x2
	// Position of PARITY_ERR_INT_RAW field.
	UART_INT_RAW_PARITY_ERR_INT_RAW_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_RAW field.
	UART_INT_RAW_PARITY_ERR_INT_RAW_Msk = 0x4
	// Bit PARITY_ERR_INT_RAW.
	UART_INT_RAW_PARITY_ERR_INT_RAW = 0x4
	// Position of FRM_ERR_INT_RAW field.
	UART_INT_RAW_FRM_ERR_INT_RAW_Pos = 0x3
	// Bit mask of FRM_ERR_INT_RAW field.
	UART_INT_RAW_FRM_ERR_INT_RAW_Msk = 0x8
	// Bit FRM_ERR_INT_RAW.
	UART_INT_RAW_FRM_ERR_INT_RAW = 0x8
	// Position of RXFIFO_OVF_INT_RAW field.
	UART_INT_RAW_RXFIFO_OVF_INT_RAW_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_RAW field.
	UART_INT_RAW_RXFIFO_OVF_INT_RAW_Msk = 0x10
	// Bit RXFIFO_OVF_INT_RAW.
	UART_INT_RAW_RXFIFO_OVF_INT_RAW = 0x10
	// Position of DSR_CHG_INT_RAW field.
	UART_INT_RAW_DSR_CHG_INT_RAW_Pos = 0x5
	// Bit mask of DSR_CHG_INT_RAW field.
	UART_INT_RAW_DSR_CHG_INT_RAW_Msk = 0x20
	// Bit DSR_CHG_INT_RAW.
	UART_INT_RAW_DSR_CHG_INT_RAW = 0x20
	// Position of CTS_CHG_INT_RAW field.
	UART_INT_RAW_CTS_CHG_INT_RAW_Pos = 0x6
	// Bit mask of CTS_CHG_INT_RAW field.
	UART_INT_RAW_CTS_CHG_INT_RAW_Msk = 0x40
	// Bit CTS_CHG_INT_RAW.
	UART_INT_RAW_CTS_CHG_INT_RAW = 0x40
	// Position of BRK_DET_INT_RAW field.
	UART_INT_RAW_BRK_DET_INT_RAW_Pos = 0x7
	// Bit mask of BRK_DET_INT_RAW field.
	UART_INT_RAW_BRK_DET_INT_RAW_Msk = 0x80
	// Bit BRK_DET_INT_RAW.
	UART_INT_RAW_BRK_DET_INT_RAW = 0x80
	// Position of RXFIFO_TOUT_INT_RAW field.
	UART_INT_RAW_RXFIFO_TOUT_INT_RAW_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_RAW field.
	UART_INT_RAW_RXFIFO_TOUT_INT_RAW_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_RAW.
	UART_INT_RAW_RXFIFO_TOUT_INT_RAW = 0x100
	// Position of SW_XON_INT_RAW field.
	UART_INT_RAW_SW_XON_INT_RAW_Pos = 0x9
	// Bit mask of SW_XON_INT_RAW field.
	UART_INT_RAW_SW_XON_INT_RAW_Msk = 0x200
	// Bit SW_XON_INT_RAW.
	UART_INT_RAW_SW_XON_INT_RAW = 0x200
	// Position of SW_XOFF_INT_RAW field.
	UART_INT_RAW_SW_XOFF_INT_RAW_Pos = 0xa
	// Bit mask of SW_XOFF_INT_RAW field.
	UART_INT_RAW_SW_XOFF_INT_RAW_Msk = 0x400
	// Bit SW_XOFF_INT_RAW.
	UART_INT_RAW_SW_XOFF_INT_RAW = 0x400
	// Position of GLITCH_DET_INT_RAW field.
	UART_INT_RAW_GLITCH_DET_INT_RAW_Pos = 0xb
	// Bit mask of GLITCH_DET_INT_RAW field.
	UART_INT_RAW_GLITCH_DET_INT_RAW_Msk = 0x800
	// Bit GLITCH_DET_INT_RAW.
	UART_INT_RAW_GLITCH_DET_INT_RAW = 0x800
	// Position of TX_BRK_DONE_INT_RAW field.
	UART_INT_RAW_TX_BRK_DONE_INT_RAW_Pos = 0xc
	// Bit mask of TX_BRK_DONE_INT_RAW field.
	UART_INT_RAW_TX_BRK_DONE_INT_RAW_Msk = 0x1000
	// Bit TX_BRK_DONE_INT_RAW.
	UART_INT_RAW_TX_BRK_DONE_INT_RAW = 0x1000
	// Position of TX_BRK_IDLE_DONE_INT_RAW field.
	UART_INT_RAW_TX_BRK_IDLE_DONE_INT_RAW_Pos = 0xd
	// Bit mask of TX_BRK_IDLE_DONE_INT_RAW field.
	UART_INT_RAW_TX_BRK_IDLE_DONE_INT_RAW_Msk = 0x2000
	// Bit TX_BRK_IDLE_DONE_INT_RAW.
	UART_INT_RAW_TX_BRK_IDLE_DONE_INT_RAW = 0x2000
	// Position of TX_DONE_INT_RAW field.
	UART_INT_RAW_TX_DONE_INT_RAW_Pos = 0xe
	// Bit mask of TX_DONE_INT_RAW field.
	UART_INT_RAW_TX_DONE_INT_RAW_Msk = 0x4000
	// Bit TX_DONE_INT_RAW.
	UART_INT_RAW_TX_DONE_INT_RAW = 0x4000
	// Position of RS485_PARITY_ERR_INT_RAW field.
	UART_INT_RAW_RS485_PARITY_ERR_INT_RAW_Pos = 0xf
	// Bit mask of RS485_PARITY_ERR_INT_RAW field.
	UART_INT_RAW_RS485_PARITY_ERR_INT_RAW_Msk = 0x8000
	// Bit RS485_PARITY_ERR_INT_RAW.
	UART_INT_RAW_RS485_PARITY_ERR_INT_RAW = 0x8000
	// Position of RS485_FRM_ERR_INT_RAW field.
	UART_INT_RAW_RS485_FRM_ERR_INT_RAW_Pos = 0x10
	// Bit mask of RS485_FRM_ERR_INT_RAW field.
	UART_INT_RAW_RS485_FRM_ERR_INT_RAW_Msk = 0x10000
	// Bit RS485_FRM_ERR_INT_RAW.
	UART_INT_RAW_RS485_FRM_ERR_INT_RAW = 0x10000
	// Position of RS485_CLASH_INT_RAW field.
	UART_INT_RAW_RS485_CLASH_INT_RAW_Pos = 0x11
	// Bit mask of RS485_CLASH_INT_RAW field.
	UART_INT_RAW_RS485_CLASH_INT_RAW_Msk = 0x20000
	// Bit RS485_CLASH_INT_RAW.
	UART_INT_RAW_RS485_CLASH_INT_RAW = 0x20000
	// Position of AT_CMD_CHAR_DET_INT_RAW field.
	UART_INT_RAW_AT_CMD_CHAR_DET_INT_RAW_Pos = 0x12
	// Bit mask of AT_CMD_CHAR_DET_INT_RAW field.
	UART_INT_RAW_AT_CMD_CHAR_DET_INT_RAW_Msk = 0x40000
	// Bit AT_CMD_CHAR_DET_INT_RAW.
	UART_INT_RAW_AT_CMD_CHAR_DET_INT_RAW = 0x40000
	// Position of WAKEUP_INT_RAW field.
	UART_INT_RAW_WAKEUP_INT_RAW_Pos = 0x13
	// Bit mask of WAKEUP_INT_RAW field.
	UART_INT_RAW_WAKEUP_INT_RAW_Msk = 0x80000
	// Bit WAKEUP_INT_RAW.
	UART_INT_RAW_WAKEUP_INT_RAW = 0x80000

	// INT_ST: Masked interrupt status
	// Position of RXFIFO_FULL_INT_ST field.
	UART_INT_ST_RXFIFO_FULL_INT_ST_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_ST field.
	UART_INT_ST_RXFIFO_FULL_INT_ST_Msk = 0x1
	// Bit RXFIFO_FULL_INT_ST.
	UART_INT_ST_RXFIFO_FULL_INT_ST = 0x1
	// Position of TXFIFO_EMPTY_INT_ST field.
	UART_INT_ST_TXFIFO_EMPTY_INT_ST_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_ST field.
	UART_INT_ST_TXFIFO_EMPTY_INT_ST_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_ST.
	UART_INT_ST_TXFIFO_EMPTY_INT_ST = 0x2
	// Position of PARITY_ERR_INT_ST field.
	UART_INT_ST_PARITY_ERR_INT_ST_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_ST field.
	UART_INT_ST_PARITY_ERR_INT_ST_Msk = 0x4
	// Bit PARITY_ERR_INT_ST.
	UART_INT_ST_PARITY_ERR_INT_ST = 0x4
	// Position of FRM_ERR_INT_ST field.
	UART_INT_ST_FRM_ERR_INT_ST_Pos = 0x3
	// Bit mask of FRM_ERR_INT_ST field.
	UART_INT_ST_FRM_ERR_INT_ST_Msk = 0x8
	// Bit FRM_ERR_INT_ST.
	UART_INT_ST_FRM_ERR_INT_ST = 0x8
	// Position of RXFIFO_OVF_INT_ST field.
	UART_INT_ST_RXFIFO_OVF_INT_ST_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_ST field.
	UART_INT_ST_RXFIFO_OVF_INT_ST_Msk = 0x10
	// Bit RXFIFO_OVF_INT_ST.
	UART_INT_ST_RXFIFO_OVF_INT_ST = 0x10
	// Position of DSR_CHG_INT_ST field.
	UART_INT_ST_DSR_CHG_INT_ST_Pos = 0x5
	// Bit mask of DSR_CHG_INT_ST field.
	UART_INT_ST_DSR_CHG_INT_ST_Msk = 0x20
	// Bit DSR_CHG_INT_ST.
	UART_INT_ST_DSR_CHG_INT_ST = 0x20
	// Position of CTS_CHG_INT_ST field.
	UART_INT_ST_CTS_CHG_INT_ST_Pos = 0x6
	// Bit mask of CTS_CHG_INT_ST field.
	UART_INT_ST_CTS_CHG_INT_ST_Msk = 0x40
	// Bit CTS_CHG_INT_ST.
	UART_INT_ST_CTS_CHG_INT_ST = 0x40
	// Position of BRK_DET_INT_ST field.
	UART_INT_ST_BRK_DET_INT_ST_Pos = 0x7
	// Bit mask of BRK_DET_INT_ST field.
	UART_INT_ST_BRK_DET_INT_ST_Msk = 0x80
	// Bit BRK_DET_INT_ST.
	UART_INT_ST_BRK_DET_INT_ST = 0x80
	// Position of RXFIFO_TOUT_INT_ST field.
	UART_INT_ST_RXFIFO_TOUT_INT_ST_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_ST field.
	UART_INT_ST_RXFIFO_TOUT_INT_ST_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_ST.
	UART_INT_ST_RXFIFO_TOUT_INT_ST = 0x100
	// Position of SW_XON_INT_ST field.
	UART_INT_ST_SW_XON_INT_ST_Pos = 0x9
	// Bit mask of SW_XON_INT_ST field.
	UART_INT_ST_SW_XON_INT_ST_Msk = 0x200
	// Bit SW_XON_INT_ST.
	UART_INT_ST_SW_XON_INT_ST = 0x200
	// Position of SW_XOFF_INT_ST field.
	UART_INT_ST_SW_XOFF_INT_ST_Pos = 0xa
	// Bit mask of SW_XOFF_INT_ST field.
	UART_INT_ST_SW_XOFF_INT_ST_Msk = 0x400
	// Bit SW_XOFF_INT_ST.
	UART_INT_ST_SW_XOFF_INT_ST = 0x400
	// Position of GLITCH_DET_INT_ST field.
	UART_INT_ST_GLITCH_DET_INT_ST_Pos = 0xb
	// Bit mask of GLITCH_DET_INT_ST field.
	UART_INT_ST_GLITCH_DET_INT_ST_Msk = 0x800
	// Bit GLITCH_DET_INT_ST.
	UART_INT_ST_GLITCH_DET_INT_ST = 0x800
	// Position of TX_BRK_DONE_INT_ST field.
	UART_INT_ST_TX_BRK_DONE_INT_ST_Pos = 0xc
	// Bit mask of TX_BRK_DONE_INT_ST field.
	UART_INT_ST_TX_BRK_DONE_INT_ST_Msk = 0x1000
	// Bit TX_BRK_DONE_INT_ST.
	UART_INT_ST_TX_BRK_DONE_INT_ST = 0x1000
	// Position of TX_BRK_IDLE_DONE_INT_ST field.
	UART_INT_ST_TX_BRK_IDLE_DONE_INT_ST_Pos = 0xd
	// Bit mask of TX_BRK_IDLE_DONE_INT_ST field.
	UART_INT_ST_TX_BRK_IDLE_DONE_INT_ST_Msk = 0x2000
	// Bit TX_BRK_IDLE_DONE_INT_ST.
	UART_INT_ST_TX_BRK_IDLE_DONE_INT_ST = 0x2000
	// Position of TX_DONE_INT_ST field.
	UART_INT_ST_TX_DONE_INT_ST_Pos = 0xe
	// Bit mask of TX_DONE_INT_ST field.
	UART_INT_ST_TX_DONE_INT_ST_Msk = 0x4000
	// Bit TX_DONE_INT_ST.
	UART_INT_ST_TX_DONE_INT_ST = 0x4000
	// Position of RS485_PARITY_ERR_INT_ST field.
	UART_INT_ST_RS485_PARITY_ERR_INT_ST_Pos = 0xf
	// Bit mask of RS485_PARITY_ERR_INT_ST field.
	UART_INT_ST_RS485_PARITY_ERR_INT_ST_Msk = 0x8000
	// Bit RS485_PARITY_ERR_INT_ST.
	UART_INT_ST_RS485_PARITY_ERR_INT_ST = 0x8000
	// Position of RS485_FRM_ERR_INT_ST field.
	UART_INT_ST_RS485_FRM_ERR_INT_ST_Pos = 0x10
	// Bit mask of RS485_FRM_ERR_INT_ST field.
	UART_INT_ST_RS485_FRM_ERR_INT_ST_Msk = 0x10000
	// Bit RS485_FRM_ERR_INT_ST.
	UART_INT_ST_RS485_FRM_ERR_INT_ST = 0x10000
	// Position of RS485_CLASH_INT_ST field.
	UART_INT_ST_RS485_CLASH_INT_ST_Pos = 0x11
	// Bit mask of RS485_CLASH_INT_ST field.
	UART_INT_ST_RS485_CLASH_INT_ST_Msk = 0x20000
	// Bit RS485_CLASH_INT_ST.
	UART_INT_ST_RS485_CLASH_INT_ST = 0x20000
	// Position of AT_CMD_CHAR_DET_INT_ST field.
	UART_INT_ST_AT_CMD_CHAR_DET_INT_ST_Pos = 0x12
	// Bit mask of AT_CMD_CHAR_DET_INT_ST field.
	UART_INT_ST_AT_CMD_CHAR_DET_INT_ST_Msk = 0x40000
	// Bit AT_CMD_CHAR_DET_INT_ST.
	UART_INT_ST_AT_CMD_CHAR_DET_INT_ST = 0x40000
	// Position of WAKEUP_INT_ST field.
	UART_INT_ST_WAKEUP_INT_ST_Pos = 0x13
	// Bit mask of WAKEUP_INT_ST field.
	UART_INT_ST_WAKEUP_INT_ST_Msk = 0x80000
	// Bit WAKEUP_INT_ST.
	UART_INT_ST_WAKEUP_INT_ST = 0x80000

	// INT_ENA: Interrupt enable bits
	// Position of RXFIFO_FULL_INT_ENA field.
	UART_INT_ENA_RXFIFO_FULL_INT_ENA_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_ENA field.
	UART_INT_ENA_RXFIFO_FULL_INT_ENA_Msk = 0x1
	// Bit RXFIFO_FULL_INT_ENA.
	UART_INT_ENA_RXFIFO_FULL_INT_ENA = 0x1
	// Position of TXFIFO_EMPTY_INT_ENA field.
	UART_INT_ENA_TXFIFO_EMPTY_INT_ENA_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_ENA field.
	UART_INT_ENA_TXFIFO_EMPTY_INT_ENA_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_ENA.
	UART_INT_ENA_TXFIFO_EMPTY_INT_ENA = 0x2
	// Position of PARITY_ERR_INT_ENA field.
	UART_INT_ENA_PARITY_ERR_INT_ENA_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_ENA field.
	UART_INT_ENA_PARITY_ERR_INT_ENA_Msk = 0x4
	// Bit PARITY_ERR_INT_ENA.
	UART_INT_ENA_PARITY_ERR_INT_ENA = 0x4
	// Position of FRM_ERR_INT_ENA field.
	UART_INT_ENA_FRM_ERR_INT_ENA_Pos = 0x3
	// Bit mask of FRM_ERR_INT_ENA field.
	UART_INT_ENA_FRM_ERR_INT_ENA_Msk = 0x8
	// Bit FRM_ERR_INT_ENA.
	UART_INT_ENA_FRM_ERR_INT_ENA = 0x8
	// Position of RXFIFO_OVF_INT_ENA field.
	UART_INT_ENA_RXFIFO_OVF_INT_ENA_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_ENA field.
	UART_INT_ENA_RXFIFO_OVF_INT_ENA_Msk = 0x10
	// Bit RXFIFO_OVF_INT_ENA.
	UART_INT_ENA_RXFIFO_OVF_INT_ENA = 0x10
	// Position of DSR_CHG_INT_ENA field.
	UART_INT_ENA_DSR_CHG_INT_ENA_Pos = 0x5
	// Bit mask of DSR_CHG_INT_ENA field.
	UART_INT_ENA_DSR_CHG_INT_ENA_Msk = 0x20
	// Bit DSR_CHG_INT_ENA.
	UART_INT_ENA_DSR_CHG_INT_ENA = 0x20
	// Position of CTS_CHG_INT_ENA field.
	UART_INT_ENA_CTS_CHG_INT_ENA_Pos = 0x6
	// Bit mask of CTS_CHG_INT_ENA field.
	UART_INT_ENA_CTS_CHG_INT_ENA_Msk = 0x40
	// Bit CTS_CHG_INT_ENA.
	UART_INT_ENA_CTS_CHG_INT_ENA = 0x40
	// Position of BRK_DET_INT_ENA field.
	UART_INT_ENA_BRK_DET_INT_ENA_Pos = 0x7
	// Bit mask of BRK_DET_INT_ENA field.
	UART_INT_ENA_BRK_DET_INT_ENA_Msk = 0x80
	// Bit BRK_DET_INT_ENA.
	UART_INT_ENA_BRK_DET_INT_ENA = 0x80
	// Position of RXFIFO_TOUT_INT_ENA field.
	UART_INT_ENA_RXFIFO_TOUT_INT_ENA_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_ENA field.
	UART_INT_ENA_RXFIFO_TOUT_INT_ENA_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_ENA.
	UART_INT_ENA_RXFIFO_TOUT_INT_ENA = 0x100
	// Position of SW_XON_INT_ENA field.
	UART_INT_ENA_SW_XON_INT_ENA_Pos = 0x9
	// Bit mask of SW_XON_INT_ENA field.
	UART_INT_ENA_SW_XON_INT_ENA_Msk = 0x200
	// Bit SW_XON_INT_ENA.
	UART_INT_ENA_SW_XON_INT_ENA = 0x200
	// Position of SW_XOFF_INT_ENA field.
	UART_INT_ENA_SW_XOFF_INT_ENA_Pos = 0xa
	// Bit mask of SW_XOFF_INT_ENA field.
	UART_INT_ENA_SW_XOFF_INT_ENA_Msk = 0x400
	// Bit SW_XOFF_INT_ENA.
	UART_INT_ENA_SW_XOFF_INT_ENA = 0x400
	// Position of GLITCH_DET_INT_ENA field.
	UART_INT_ENA_GLITCH_DET_INT_ENA_Pos = 0xb
	// Bit mask of GLITCH_DET_INT_ENA field.
	UART_INT_ENA_GLITCH_DET_INT_ENA_Msk = 0x800
	// Bit GLITCH_DET_INT_ENA.
	UART_INT_ENA_GLITCH_DET_INT_ENA = 0x800
	// Position of TX_BRK_DONE_INT_ENA field.
	UART_INT_ENA_TX_BRK_DONE_INT_ENA_Pos = 0xc
	// Bit mask of TX_BRK_DONE_INT_ENA field.
	UART_INT_ENA_TX_BRK_DONE_INT_ENA_Msk = 0x1000
	// Bit TX_BRK_DONE_INT_ENA.
	UART_INT_ENA_TX_BRK_DONE_INT_ENA = 0x1000
	// Position of TX_BRK_IDLE_DONE_INT_ENA field.
	UART_INT_ENA_TX_BRK_IDLE_DONE_INT_ENA_Pos = 0xd
	// Bit mask of TX_BRK_IDLE_DONE_INT_ENA field.
	UART_INT_ENA_TX_BRK_IDLE_DONE_INT_ENA_Msk = 0x2000
	// Bit TX_BRK_IDLE_DONE_INT_ENA.
	UART_INT_ENA_TX_BRK_IDLE_DONE_INT_ENA = 0x2000
	// Position of TX_DONE_INT_ENA field.
	UART_INT_ENA_TX_DONE_INT_ENA_Pos = 0xe
	// Bit mask of TX_DONE_INT_ENA field.
	UART_INT_ENA_TX_DONE_INT_ENA_Msk = 0x4000
	// Bit TX_DONE_INT_ENA.
	UART_INT_ENA_TX_DONE_INT_ENA = 0x4000
	// Position of RS485_PARITY_ERR_INT_ENA field.
	UART_INT_ENA_RS485_PARITY_ERR_INT_ENA_Pos = 0xf
	// Bit mask of RS485_PARITY_ERR_INT_ENA field.
	UART_INT_ENA_RS485_PARITY_ERR_INT_ENA_Msk = 0x8000
	// Bit RS485_PARITY_ERR_INT_ENA.
	UART_INT_ENA_RS485_PARITY_ERR_INT_ENA = 0x8000
	// Position of RS485_FRM_ERR_INT_ENA field.
	UART_INT_ENA_RS485_FRM_ERR_INT_ENA_Pos = 0x10
	// Bit mask of RS485_FRM_ERR_INT_ENA field.
	UART_INT_ENA_RS485_FRM_ERR_INT_ENA_Msk = 0x10000
	// Bit RS485_FRM_ERR_INT_ENA.
	UART_INT_ENA_RS485_FRM_ERR_INT_ENA = 0x10000
	// Position of RS485_CLASH_INT_ENA field.
	UART_INT_ENA_RS485_CLASH_INT_ENA_Pos = 0x11
	// Bit mask of RS485_CLASH_INT_ENA field.
	UART_INT_ENA_RS485_CLASH_INT_ENA_Msk = 0x20000
	// Bit RS485_CLASH_INT_ENA.
	UART_INT_ENA_RS485_CLASH_INT_ENA = 0x20000
	// Position of AT_CMD_CHAR_DET_INT_ENA field.
	UART_INT_ENA_AT_CMD_CHAR_DET_INT_ENA_Pos = 0x12
	// Bit mask of AT_CMD_CHAR_DET_INT_ENA field.
	UART_INT_ENA_AT_CMD_CHAR_DET_INT_ENA_Msk = 0x40000
	// Bit AT_CMD_CHAR_DET_INT_ENA.
	UART_INT_ENA_AT_CMD_CHAR_DET_INT_ENA = 0x40000
	// Position of WAKEUP_INT_ENA field.
	UART_INT_ENA_WAKEUP_INT_ENA_Pos = 0x13
	// Bit mask of WAKEUP_INT_ENA field.
	UART_INT_ENA_WAKEUP_INT_ENA_Msk = 0x80000
	// Bit WAKEUP_INT_ENA.
	UART_INT_ENA_WAKEUP_INT_ENA = 0x80000

	// INT_CLR: Interrupt clear bits
	// Position of RXFIFO_FULL_INT_CLR field.
	UART_INT_CLR_RXFIFO_FULL_INT_CLR_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_CLR field.
	UART_INT_CLR_RXFIFO_FULL_INT_CLR_Msk = 0x1
	// Bit RXFIFO_FULL_INT_CLR.
	UART_INT_CLR_RXFIFO_FULL_INT_CLR = 0x1
	// Position of TXFIFO_EMPTY_INT_CLR field.
	UART_INT_CLR_TXFIFO_EMPTY_INT_CLR_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_CLR field.
	UART_INT_CLR_TXFIFO_EMPTY_INT_CLR_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_CLR.
	UART_INT_CLR_TXFIFO_EMPTY_INT_CLR = 0x2
	// Position of PARITY_ERR_INT_CLR field.
	UART_INT_CLR_PARITY_ERR_INT_CLR_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_CLR field.
	UART_INT_CLR_PARITY_ERR_INT_CLR_Msk = 0x4
	// Bit PARITY_ERR_INT_CLR.
	UART_INT_CLR_PARITY_ERR_INT_CLR = 0x4
	// Position of FRM_ERR_INT_CLR field.
	UART_INT_CLR_FRM_ERR_INT_CLR_Pos = 0x3
	// Bit mask of FRM_ERR_INT_CLR field.
	UART_INT_CLR_FRM_ERR_INT_CLR_Msk = 0x8
	// Bit FRM_ERR_INT_CLR.
	UART_INT_CLR_FRM_ERR_INT_CLR = 0x8
	// Position of RXFIFO_OVF_INT_CLR field.
	UART_INT_CLR_RXFIFO_OVF_INT_CLR_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_CLR field.
	UART_INT_CLR_RXFIFO_OVF_INT_CLR_Msk = 0x10
	// Bit RXFIFO_OVF_INT_CLR.
	UART_INT_CLR_RXFIFO_OVF_INT_CLR = 0x10
	// Position of DSR_CHG_INT_CLR field.
	UART_INT_CLR_DSR_CHG_INT_CLR_Pos = 0x5
	// Bit mask of DSR_CHG_INT_CLR field.
	UART_INT_CLR_DSR_CHG_INT_CLR_Msk = 0x20
	// Bit DSR_CHG_INT_CLR.
	UART_INT_CLR_DSR_CHG_INT_CLR = 0x20
	// Position of CTS_CHG_INT_CLR field.
	UART_INT_CLR_CTS_CHG_INT_CLR_Pos = 0x6
	// Bit mask of CTS_CHG_INT_CLR field.
	UART_INT_CLR_CTS_CHG_INT_CLR_Msk = 0x40
	// Bit CTS_CHG_INT_CLR.
	UART_INT_CLR_CTS_CHG_INT_CLR = 0x40
	// Position of BRK_DET_INT_CLR field.
	UART_INT_CLR_BRK_DET_INT_CLR_Pos = 0x7
	// Bit mask of BRK_DET_INT_CLR field.
	UART_INT_CLR_BRK_DET_INT_CLR_Msk = 0x80
	// Bit BRK_DET_INT_CLR.
	UART_INT_CLR_BRK_DET_INT_CLR = 0x80
	// Position of RXFIFO_TOUT_INT_CLR field.
	UART_INT_CLR_RXFIFO_TOUT_INT_CLR_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_CLR field.
	UART_INT_CLR_RXFIFO_TOUT_INT_CLR_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_CLR.
	UART_INT_CLR_RXFIFO_TOUT_INT_CLR = 0x100
	// Position of SW_XON_INT_CLR field.
	UART_INT_CLR_SW_XON_INT_CLR_Pos = 0x9
	// Bit mask of SW_XON_INT_CLR field.
	UART_INT_CLR_SW_XON_INT_CLR_Msk = 0x200
	// Bit SW_XON_INT_CLR.
	UART_INT_CLR_SW_XON_INT_CLR = 0x200
	// Position of SW_XOFF_INT_CLR field.
	UART_INT_CLR_SW_XOFF_INT_CLR_Pos = 0xa
	// Bit mask of SW_XOFF_INT_CLR field.
	UART_INT_CLR_SW_XOFF_INT_CLR_Msk = 0x400
	// Bit SW_XOFF_INT_CLR.
	UART_INT_CLR_SW_XOFF_INT_CLR = 0x400
	// Position of GLITCH_DET_INT_CLR field.
	UART_INT_CLR_GLITCH_DET_INT_CLR_Pos = 0xb
	// Bit mask of GLITCH_DET_INT_CLR field.
	UART_INT_CLR_GLITCH_DET_INT_CLR_Msk = 0x800
	// Bit GLITCH_DET_INT_CLR.
	UART_INT_CLR_GLITCH_DET_INT_CLR = 0x800
	// Position of TX_BRK_DONE_INT_CLR field.
	UART_INT_CLR_TX_BRK_DONE_INT_CLR_Pos = 0xc
	// Bit mask of TX_BRK_DONE_INT_CLR field.
	UART_INT_CLR_TX_BRK_DONE_INT_CLR_Msk = 0x1000
	// Bit TX_BRK_DONE_INT_CLR.
	UART_INT_CLR_TX_BRK_DONE_INT_CLR = 0x1000
	// Position of TX_BRK_IDLE_DONE_INT_CLR field.
	UART_INT_CLR_TX_BRK_IDLE_DONE_INT_CLR_Pos = 0xd
	// Bit mask of TX_BRK_IDLE_DONE_INT_CLR field.
	UART_INT_CLR_TX_BRK_IDLE_DONE_INT_CLR_Msk = 0x2000
	// Bit TX_BRK_IDLE_DONE_INT_CLR.
	UART_INT_CLR_TX_BRK_IDLE_DONE_INT_CLR = 0x2000
	// Position of TX_DONE_INT_CLR field.
	UART_INT_CLR_TX_DONE_INT_CLR_Pos = 0xe
	// Bit mask of TX_DONE_INT_CLR field.
	UART_INT_CLR_TX_DONE_INT_CLR_Msk = 0x4000
	// Bit TX_DONE_INT_CLR.
	UART_INT_CLR_TX_DONE_INT_CLR = 0x4000
	// Position of RS485_PARITY_ERR_INT_CLR field.
	UART_INT_CLR_RS485_PARITY_ERR_INT_CLR_Pos = 0xf
	// Bit mask of RS485_PARITY_ERR_INT_CLR field.
	UART_INT_CLR_RS485_PARITY_ERR_INT_CLR_Msk = 0x8000
	// Bit RS485_PARITY_ERR_INT_CLR.
	UART_INT_CLR_RS485_PARITY_ERR_INT_CLR = 0x8000
	// Position of RS485_FRM_ERR_INT_CLR field.
	UART_INT_CLR_RS485_FRM_ERR_INT_CLR_Pos = 0x10
	// Bit mask of RS485_FRM_ERR_INT_CLR field.
	UART_INT_CLR_RS485_FRM_ERR_INT_CLR_Msk = 0x10000
	// Bit RS485_FRM_ERR_INT_CLR.
	UART_INT_CLR_RS485_FRM_ERR_INT_CLR = 0x10000
	// Position of RS485_CLASH_INT_CLR field.
	UART_INT_CLR_RS485_CLASH_INT_CLR_Pos = 0x11
	// Bit mask of RS485_CLASH_INT_CLR field.
	UART_INT_CLR_RS485_CLASH_INT_CLR_Msk = 0x20000
	// Bit RS485_CLASH_INT_CLR.
	UART_INT_CLR_RS485_CLASH_INT_CLR = 0x20000
	// Position of AT_CMD_CHAR_DET_INT_CLR field.
	UART_INT_CLR_AT_CMD_CHAR_DET_INT_CLR_Pos = 0x12
	// Bit mask of AT_CMD_CHAR_DET_INT_CLR field.
	UART_INT_CLR_AT_CMD_CHAR_DET_INT_CLR_Msk = 0x40000
	// Bit AT_CMD_CHAR_DET_INT_CLR.
	UART_INT_CLR_AT_CMD_CHAR_DET_INT_CLR = 0x40000
	// Position of WAKEUP_INT_CLR field.
	UART_INT_CLR_WAKEUP_INT_CLR_Pos = 0x13
	// Bit mask of WAKEUP_INT_CLR field.
	UART_INT_CLR_WAKEUP_INT_CLR_Msk = 0x80000
	// Bit WAKEUP_INT_CLR.
	UART_INT_CLR_WAKEUP_INT_CLR = 0x80000

	// CLKDIV: Clock divider configuration
	// Position of CLKDIV field.
	UART_CLKDIV_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	UART_CLKDIV_CLKDIV_Msk = 0xfff
	// Position of FRAG field.
	UART_CLKDIV_FRAG_Pos = 0x14
	// Bit mask of FRAG field.
	UART_CLKDIV_FRAG_Msk = 0xf00000

	// RX_FILT: Rx Filter configuration
	// Position of GLITCH_FILT field.
	UART_RX_FILT_GLITCH_FILT_Pos = 0x0
	// Bit mask of GLITCH_FILT field.
	UART_RX_FILT_GLITCH_FILT_Msk = 0xff
	// Position of GLITCH_FILT_EN field.
	UART_RX_FILT_GLITCH_FILT_EN_Pos = 0x8
	// Bit mask of GLITCH_FILT_EN field.
	UART_RX_FILT_GLITCH_FILT_EN_Msk = 0x100
	// Bit GLITCH_FILT_EN.
	UART_RX_FILT_GLITCH_FILT_EN = 0x100

	// STATUS: UART status register
	// Position of RXFIFO_CNT field.
	UART_STATUS_RXFIFO_CNT_Pos = 0x0
	// Bit mask of RXFIFO_CNT field.
	UART_STATUS_RXFIFO_CNT_Msk = 0xff
	// Position of DSRN field.
	UART_STATUS_DSRN_Pos = 0xd
	// Bit mask of DSRN field.
	UART_STATUS_DSRN_Msk = 0x2000
	// Bit DSRN.
	UART_STATUS_DSRN = 0x2000
	// Position of CTSN field.
	UART_STATUS_CTSN_Pos = 0xe
	// Bit mask of CTSN field.
	UART_STATUS_CTSN_Msk = 0x4000
	// Bit CTSN.
	UART_STATUS_CTSN = 0x4000
	// Position of RXD field.
	UART_STATUS_RXD_Pos = 0xf
	// Bit mask of RXD field.
	UART_STATUS_RXD_Msk = 0x8000
	// Bit RXD.
	UART_STATUS_RXD = 0x8000
	// Position of TXFIFO_CNT field.
	UART_STATUS_TXFIFO_CNT_Pos = 0x10
	// Bit mask of TXFIFO_CNT field.
	UART_STATUS_TXFIFO_CNT_Msk = 0xff0000
	// Position of DTRN field.
	UART_STATUS_DTRN_Pos = 0x1d
	// Bit mask of DTRN field.
	UART_STATUS_DTRN_Msk = 0x20000000
	// Bit DTRN.
	UART_STATUS_DTRN = 0x20000000
	// Position of RTSN field.
	UART_STATUS_RTSN_Pos = 0x1e
	// Bit mask of RTSN field.
	UART_STATUS_RTSN_Msk = 0x40000000
	// Bit RTSN.
	UART_STATUS_RTSN = 0x40000000
	// Position of TXD field.
	UART_STATUS_TXD_Pos = 0x1f
	// Bit mask of TXD field.
	UART_STATUS_TXD_Msk = 0x80000000
	// Bit TXD.
	UART_STATUS_TXD = 0x80000000

	// CONF0: a
	// Position of PARITY field.
	UART_CONF0_PARITY_Pos = 0x0
	// Bit mask of PARITY field.
	UART_CONF0_PARITY_Msk = 0x1
	// Bit PARITY.
	UART_CONF0_PARITY = 0x1
	// Position of PARITY_EN field.
	UART_CONF0_PARITY_EN_Pos = 0x1
	// Bit mask of PARITY_EN field.
	UART_CONF0_PARITY_EN_Msk = 0x2
	// Bit PARITY_EN.
	UART_CONF0_PARITY_EN = 0x2
	// Position of BIT_NUM field.
	UART_CONF0_BIT_NUM_Pos = 0x2
	// Bit mask of BIT_NUM field.
	UART_CONF0_BIT_NUM_Msk = 0xc
	// Position of STOP_BIT_NUM field.
	UART_CONF0_STOP_BIT_NUM_Pos = 0x4
	// Bit mask of STOP_BIT_NUM field.
	UART_CONF0_STOP_BIT_NUM_Msk = 0x30
	// Position of TXD_BRK field.
	UART_CONF0_TXD_BRK_Pos = 0x6
	// Bit mask of TXD_BRK field.
	UART_CONF0_TXD_BRK_Msk = 0x40
	// Bit TXD_BRK.
	UART_CONF0_TXD_BRK = 0x40
	// Position of IRDA_DPLX field.
	UART_CONF0_IRDA_DPLX_Pos = 0x7
	// Bit mask of IRDA_DPLX field.
	UART_CONF0_IRDA_DPLX_Msk = 0x80
	// Bit IRDA_DPLX.
	UART_CONF0_IRDA_DPLX = 0x80
	// Position of IRDA_TX_EN field.
	UART_CONF0_IRDA_TX_EN_Pos = 0x8
	// Bit mask of IRDA_TX_EN field.
	UART_CONF0_IRDA_TX_EN_Msk = 0x100
	// Bit IRDA_TX_EN.
	UART_CONF0_IRDA_TX_EN = 0x100
	// Position of IRDA_WCTL field.
	UART_CONF0_IRDA_WCTL_Pos = 0x9
	// Bit mask of IRDA_WCTL field.
	UART_CONF0_IRDA_WCTL_Msk = 0x200
	// Bit IRDA_WCTL.
	UART_CONF0_IRDA_WCTL = 0x200
	// Position of IRDA_TX_INV field.
	UART_CONF0_IRDA_TX_INV_Pos = 0xa
	// Bit mask of IRDA_TX_INV field.
	UART_CONF0_IRDA_TX_INV_Msk = 0x400
	// Bit IRDA_TX_INV.
	UART_CONF0_IRDA_TX_INV = 0x400
	// Position of IRDA_RX_INV field.
	UART_CONF0_IRDA_RX_INV_Pos = 0xb
	// Bit mask of IRDA_RX_INV field.
	UART_CONF0_IRDA_RX_INV_Msk = 0x800
	// Bit IRDA_RX_INV.
	UART_CONF0_IRDA_RX_INV = 0x800
	// Position of LOOPBACK field.
	UART_CONF0_LOOPBACK_Pos = 0xc
	// Bit mask of LOOPBACK field.
	UART_CONF0_LOOPBACK_Msk = 0x1000
	// Bit LOOPBACK.
	UART_CONF0_LOOPBACK = 0x1000
	// Position of TX_FLOW_EN field.
	UART_CONF0_TX_FLOW_EN_Pos = 0xd
	// Bit mask of TX_FLOW_EN field.
	UART_CONF0_TX_FLOW_EN_Msk = 0x2000
	// Bit TX_FLOW_EN.
	UART_CONF0_TX_FLOW_EN = 0x2000
	// Position of IRDA_EN field.
	UART_CONF0_IRDA_EN_Pos = 0xe
	// Bit mask of IRDA_EN field.
	UART_CONF0_IRDA_EN_Msk = 0x4000
	// Bit IRDA_EN.
	UART_CONF0_IRDA_EN = 0x4000
	// Position of RXD_INV field.
	UART_CONF0_RXD_INV_Pos = 0xf
	// Bit mask of RXD_INV field.
	UART_CONF0_RXD_INV_Msk = 0x8000
	// Bit RXD_INV.
	UART_CONF0_RXD_INV = 0x8000
	// Position of TXD_INV field.
	UART_CONF0_TXD_INV_Pos = 0x10
	// Bit mask of TXD_INV field.
	UART_CONF0_TXD_INV_Msk = 0x10000
	// Bit TXD_INV.
	UART_CONF0_TXD_INV = 0x10000
	// Position of DIS_RX_DAT_OVF field.
	UART_CONF0_DIS_RX_DAT_OVF_Pos = 0x11
	// Bit mask of DIS_RX_DAT_OVF field.
	UART_CONF0_DIS_RX_DAT_OVF_Msk = 0x20000
	// Bit DIS_RX_DAT_OVF.
	UART_CONF0_DIS_RX_DAT_OVF = 0x20000
	// Position of ERR_WR_MASK field.
	UART_CONF0_ERR_WR_MASK_Pos = 0x12
	// Bit mask of ERR_WR_MASK field.
	UART_CONF0_ERR_WR_MASK_Msk = 0x40000
	// Bit ERR_WR_MASK.
	UART_CONF0_ERR_WR_MASK = 0x40000
	// Position of AUTOBAUD_EN field.
	UART_CONF0_AUTOBAUD_EN_Pos = 0x13
	// Bit mask of AUTOBAUD_EN field.
	UART_CONF0_AUTOBAUD_EN_Msk = 0x80000
	// Bit AUTOBAUD_EN.
	UART_CONF0_AUTOBAUD_EN = 0x80000
	// Position of MEM_CLK_EN field.
	UART_CONF0_MEM_CLK_EN_Pos = 0x14
	// Bit mask of MEM_CLK_EN field.
	UART_CONF0_MEM_CLK_EN_Msk = 0x100000
	// Bit MEM_CLK_EN.
	UART_CONF0_MEM_CLK_EN = 0x100000
	// Position of SW_RTS field.
	UART_CONF0_SW_RTS_Pos = 0x15
	// Bit mask of SW_RTS field.
	UART_CONF0_SW_RTS_Msk = 0x200000
	// Bit SW_RTS.
	UART_CONF0_SW_RTS = 0x200000
	// Position of RXFIFO_RST field.
	UART_CONF0_RXFIFO_RST_Pos = 0x16
	// Bit mask of RXFIFO_RST field.
	UART_CONF0_RXFIFO_RST_Msk = 0x400000
	// Bit RXFIFO_RST.
	UART_CONF0_RXFIFO_RST = 0x400000
	// Position of TXFIFO_RST field.
	UART_CONF0_TXFIFO_RST_Pos = 0x17
	// Bit mask of TXFIFO_RST field.
	UART_CONF0_TXFIFO_RST_Msk = 0x800000
	// Bit TXFIFO_RST.
	UART_CONF0_TXFIFO_RST = 0x800000

	// CONF1: Configuration register 1
	// Position of RXFIFO_FULL_THRHD field.
	UART_CONF1_RXFIFO_FULL_THRHD_Pos = 0x0
	// Bit mask of RXFIFO_FULL_THRHD field.
	UART_CONF1_RXFIFO_FULL_THRHD_Msk = 0xff
	// Position of TXFIFO_EMPTY_THRHD field.
	UART_CONF1_TXFIFO_EMPTY_THRHD_Pos = 0x8
	// Bit mask of TXFIFO_EMPTY_THRHD field.
	UART_CONF1_TXFIFO_EMPTY_THRHD_Msk = 0xff00
	// Position of CTS_INV field.
	UART_CONF1_CTS_INV_Pos = 0x10
	// Bit mask of CTS_INV field.
	UART_CONF1_CTS_INV_Msk = 0x10000
	// Bit CTS_INV.
	UART_CONF1_CTS_INV = 0x10000
	// Position of DSR_INV field.
	UART_CONF1_DSR_INV_Pos = 0x11
	// Bit mask of DSR_INV field.
	UART_CONF1_DSR_INV_Msk = 0x20000
	// Bit DSR_INV.
	UART_CONF1_DSR_INV = 0x20000
	// Position of RTS_INV field.
	UART_CONF1_RTS_INV_Pos = 0x12
	// Bit mask of RTS_INV field.
	UART_CONF1_RTS_INV_Msk = 0x40000
	// Bit RTS_INV.
	UART_CONF1_RTS_INV = 0x40000
	// Position of DTR_INV field.
	UART_CONF1_DTR_INV_Pos = 0x13
	// Bit mask of DTR_INV field.
	UART_CONF1_DTR_INV_Msk = 0x80000
	// Bit DTR_INV.
	UART_CONF1_DTR_INV = 0x80000
	// Position of SW_DTR field.
	UART_CONF1_SW_DTR_Pos = 0x14
	// Bit mask of SW_DTR field.
	UART_CONF1_SW_DTR_Msk = 0x100000
	// Bit SW_DTR.
	UART_CONF1_SW_DTR = 0x100000
	// Position of CLK_EN field.
	UART_CONF1_CLK_EN_Pos = 0x15
	// Bit mask of CLK_EN field.
	UART_CONF1_CLK_EN_Msk = 0x200000
	// Bit CLK_EN.
	UART_CONF1_CLK_EN = 0x200000

	// HWFC_CONF: Hardware flow-control configuration
	// Position of RX_FLOW_THRHD field.
	UART_HWFC_CONF_RX_FLOW_THRHD_Pos = 0x0
	// Bit mask of RX_FLOW_THRHD field.
	UART_HWFC_CONF_RX_FLOW_THRHD_Msk = 0xff
	// Position of RX_FLOW_EN field.
	UART_HWFC_CONF_RX_FLOW_EN_Pos = 0x8
	// Bit mask of RX_FLOW_EN field.
	UART_HWFC_CONF_RX_FLOW_EN_Msk = 0x100
	// Bit RX_FLOW_EN.
	UART_HWFC_CONF_RX_FLOW_EN = 0x100

	// SLEEP_CONF0: UART sleep configure register 0
	// Position of WK_CHAR1 field.
	UART_SLEEP_CONF0_WK_CHAR1_Pos = 0x0
	// Bit mask of WK_CHAR1 field.
	UART_SLEEP_CONF0_WK_CHAR1_Msk = 0xff
	// Position of WK_CHAR2 field.
	UART_SLEEP_CONF0_WK_CHAR2_Pos = 0x8
	// Bit mask of WK_CHAR2 field.
	UART_SLEEP_CONF0_WK_CHAR2_Msk = 0xff00
	// Position of WK_CHAR3 field.
	UART_SLEEP_CONF0_WK_CHAR3_Pos = 0x10
	// Bit mask of WK_CHAR3 field.
	UART_SLEEP_CONF0_WK_CHAR3_Msk = 0xff0000
	// Position of WK_CHAR4 field.
	UART_SLEEP_CONF0_WK_CHAR4_Pos = 0x18
	// Bit mask of WK_CHAR4 field.
	UART_SLEEP_CONF0_WK_CHAR4_Msk = 0xff000000

	// SLEEP_CONF1: UART sleep configure register 1
	// Position of WK_CHAR0 field.
	UART_SLEEP_CONF1_WK_CHAR0_Pos = 0x0
	// Bit mask of WK_CHAR0 field.
	UART_SLEEP_CONF1_WK_CHAR0_Msk = 0xff

	// SLEEP_CONF2: UART sleep configure register 2
	// Position of ACTIVE_THRESHOLD field.
	UART_SLEEP_CONF2_ACTIVE_THRESHOLD_Pos = 0x0
	// Bit mask of ACTIVE_THRESHOLD field.
	UART_SLEEP_CONF2_ACTIVE_THRESHOLD_Msk = 0x3ff
	// Position of RX_WAKE_UP_THRHD field.
	UART_SLEEP_CONF2_RX_WAKE_UP_THRHD_Pos = 0xa
	// Bit mask of RX_WAKE_UP_THRHD field.
	UART_SLEEP_CONF2_RX_WAKE_UP_THRHD_Msk = 0x3fc00
	// Position of WK_CHAR_NUM field.
	UART_SLEEP_CONF2_WK_CHAR_NUM_Pos = 0x12
	// Bit mask of WK_CHAR_NUM field.
	UART_SLEEP_CONF2_WK_CHAR_NUM_Msk = 0x1c0000
	// Position of WK_CHAR_MASK field.
	UART_SLEEP_CONF2_WK_CHAR_MASK_Pos = 0x15
	// Bit mask of WK_CHAR_MASK field.
	UART_SLEEP_CONF2_WK_CHAR_MASK_Msk = 0x3e00000
	// Position of WK_MODE_SEL field.
	UART_SLEEP_CONF2_WK_MODE_SEL_Pos = 0x1a
	// Bit mask of WK_MODE_SEL field.
	UART_SLEEP_CONF2_WK_MODE_SEL_Msk = 0xc000000

	// SWFC_CONF0: Software flow-control character configuration
	// Position of XON_CHAR field.
	UART_SWFC_CONF0_XON_CHAR_Pos = 0x0
	// Bit mask of XON_CHAR field.
	UART_SWFC_CONF0_XON_CHAR_Msk = 0xff
	// Position of XOFF_CHAR field.
	UART_SWFC_CONF0_XOFF_CHAR_Pos = 0x8
	// Bit mask of XOFF_CHAR field.
	UART_SWFC_CONF0_XOFF_CHAR_Msk = 0xff00
	// Position of XON_XOFF_STILL_SEND field.
	UART_SWFC_CONF0_XON_XOFF_STILL_SEND_Pos = 0x10
	// Bit mask of XON_XOFF_STILL_SEND field.
	UART_SWFC_CONF0_XON_XOFF_STILL_SEND_Msk = 0x10000
	// Bit XON_XOFF_STILL_SEND.
	UART_SWFC_CONF0_XON_XOFF_STILL_SEND = 0x10000
	// Position of SW_FLOW_CON_EN field.
	UART_SWFC_CONF0_SW_FLOW_CON_EN_Pos = 0x11
	// Bit mask of SW_FLOW_CON_EN field.
	UART_SWFC_CONF0_SW_FLOW_CON_EN_Msk = 0x20000
	// Bit SW_FLOW_CON_EN.
	UART_SWFC_CONF0_SW_FLOW_CON_EN = 0x20000
	// Position of XONOFF_DEL field.
	UART_SWFC_CONF0_XONOFF_DEL_Pos = 0x12
	// Bit mask of XONOFF_DEL field.
	UART_SWFC_CONF0_XONOFF_DEL_Msk = 0x40000
	// Bit XONOFF_DEL.
	UART_SWFC_CONF0_XONOFF_DEL = 0x40000
	// Position of FORCE_XON field.
	UART_SWFC_CONF0_FORCE_XON_Pos = 0x13
	// Bit mask of FORCE_XON field.
	UART_SWFC_CONF0_FORCE_XON_Msk = 0x80000
	// Bit FORCE_XON.
	UART_SWFC_CONF0_FORCE_XON = 0x80000
	// Position of FORCE_XOFF field.
	UART_SWFC_CONF0_FORCE_XOFF_Pos = 0x14
	// Bit mask of FORCE_XOFF field.
	UART_SWFC_CONF0_FORCE_XOFF_Msk = 0x100000
	// Bit FORCE_XOFF.
	UART_SWFC_CONF0_FORCE_XOFF = 0x100000
	// Position of SEND_XON field.
	UART_SWFC_CONF0_SEND_XON_Pos = 0x15
	// Bit mask of SEND_XON field.
	UART_SWFC_CONF0_SEND_XON_Msk = 0x200000
	// Bit SEND_XON.
	UART_SWFC_CONF0_SEND_XON = 0x200000
	// Position of SEND_XOFF field.
	UART_SWFC_CONF0_SEND_XOFF_Pos = 0x16
	// Bit mask of SEND_XOFF field.
	UART_SWFC_CONF0_SEND_XOFF_Msk = 0x400000
	// Bit SEND_XOFF.
	UART_SWFC_CONF0_SEND_XOFF = 0x400000

	// SWFC_CONF1: Software flow-control character configuration
	// Position of XON_THRESHOLD field.
	UART_SWFC_CONF1_XON_THRESHOLD_Pos = 0x0
	// Bit mask of XON_THRESHOLD field.
	UART_SWFC_CONF1_XON_THRESHOLD_Msk = 0xff
	// Position of XOFF_THRESHOLD field.
	UART_SWFC_CONF1_XOFF_THRESHOLD_Pos = 0x8
	// Bit mask of XOFF_THRESHOLD field.
	UART_SWFC_CONF1_XOFF_THRESHOLD_Msk = 0xff00

	// TXBRK_CONF: Tx Break character configuration
	// Position of TX_BRK_NUM field.
	UART_TXBRK_CONF_TX_BRK_NUM_Pos = 0x0
	// Bit mask of TX_BRK_NUM field.
	UART_TXBRK_CONF_TX_BRK_NUM_Msk = 0xff

	// IDLE_CONF: Frame-end idle configuration
	// Position of RX_IDLE_THRHD field.
	UART_IDLE_CONF_RX_IDLE_THRHD_Pos = 0x0
	// Bit mask of RX_IDLE_THRHD field.
	UART_IDLE_CONF_RX_IDLE_THRHD_Msk = 0x3ff
	// Position of TX_IDLE_NUM field.
	UART_IDLE_CONF_TX_IDLE_NUM_Pos = 0xa
	// Bit mask of TX_IDLE_NUM field.
	UART_IDLE_CONF_TX_IDLE_NUM_Msk = 0xffc00

	// RS485_CONF: RS485 mode configuration
	// Position of RS485_EN field.
	UART_RS485_CONF_RS485_EN_Pos = 0x0
	// Bit mask of RS485_EN field.
	UART_RS485_CONF_RS485_EN_Msk = 0x1
	// Bit RS485_EN.
	UART_RS485_CONF_RS485_EN = 0x1
	// Position of DL0_EN field.
	UART_RS485_CONF_DL0_EN_Pos = 0x1
	// Bit mask of DL0_EN field.
	UART_RS485_CONF_DL0_EN_Msk = 0x2
	// Bit DL0_EN.
	UART_RS485_CONF_DL0_EN = 0x2
	// Position of DL1_EN field.
	UART_RS485_CONF_DL1_EN_Pos = 0x2
	// Bit mask of DL1_EN field.
	UART_RS485_CONF_DL1_EN_Msk = 0x4
	// Bit DL1_EN.
	UART_RS485_CONF_DL1_EN = 0x4
	// Position of RS485TX_RX_EN field.
	UART_RS485_CONF_RS485TX_RX_EN_Pos = 0x3
	// Bit mask of RS485TX_RX_EN field.
	UART_RS485_CONF_RS485TX_RX_EN_Msk = 0x8
	// Bit RS485TX_RX_EN.
	UART_RS485_CONF_RS485TX_RX_EN = 0x8
	// Position of RS485RXBY_TX_EN field.
	UART_RS485_CONF_RS485RXBY_TX_EN_Pos = 0x4
	// Bit mask of RS485RXBY_TX_EN field.
	UART_RS485_CONF_RS485RXBY_TX_EN_Msk = 0x10
	// Bit RS485RXBY_TX_EN.
	UART_RS485_CONF_RS485RXBY_TX_EN = 0x10
	// Position of RS485_RX_DLY_NUM field.
	UART_RS485_CONF_RS485_RX_DLY_NUM_Pos = 0x5
	// Bit mask of RS485_RX_DLY_NUM field.
	UART_RS485_CONF_RS485_RX_DLY_NUM_Msk = 0x20
	// Bit RS485_RX_DLY_NUM.
	UART_RS485_CONF_RS485_RX_DLY_NUM = 0x20
	// Position of RS485_TX_DLY_NUM field.
	UART_RS485_CONF_RS485_TX_DLY_NUM_Pos = 0x6
	// Bit mask of RS485_TX_DLY_NUM field.
	UART_RS485_CONF_RS485_TX_DLY_NUM_Msk = 0x3c0

	// AT_CMD_PRECNT: Pre-sequence timing configuration
	// Position of PRE_IDLE_NUM field.
	UART_AT_CMD_PRECNT_PRE_IDLE_NUM_Pos = 0x0
	// Bit mask of PRE_IDLE_NUM field.
	UART_AT_CMD_PRECNT_PRE_IDLE_NUM_Msk = 0xffff

	// AT_CMD_POSTCNT: Post-sequence timing configuration
	// Position of POST_IDLE_NUM field.
	UART_AT_CMD_POSTCNT_POST_IDLE_NUM_Pos = 0x0
	// Bit mask of POST_IDLE_NUM field.
	UART_AT_CMD_POSTCNT_POST_IDLE_NUM_Msk = 0xffff

	// AT_CMD_GAPTOUT: Timeout configuration
	// Position of RX_GAP_TOUT field.
	UART_AT_CMD_GAPTOUT_RX_GAP_TOUT_Pos = 0x0
	// Bit mask of RX_GAP_TOUT field.
	UART_AT_CMD_GAPTOUT_RX_GAP_TOUT_Msk = 0xffff

	// AT_CMD_CHAR: AT escape sequence detection configuration
	// Position of AT_CMD_CHAR field.
	UART_AT_CMD_CHAR_AT_CMD_CHAR_Pos = 0x0
	// Bit mask of AT_CMD_CHAR field.
	UART_AT_CMD_CHAR_AT_CMD_CHAR_Msk = 0xff
	// Position of CHAR_NUM field.
	UART_AT_CMD_CHAR_CHAR_NUM_Pos = 0x8
	// Bit mask of CHAR_NUM field.
	UART_AT_CMD_CHAR_CHAR_NUM_Msk = 0xff00

	// MEM_CONF: UART memory power configuration
	// Position of MEM_FORCE_PD field.
	UART_MEM_CONF_MEM_FORCE_PD_Pos = 0x19
	// Bit mask of MEM_FORCE_PD field.
	UART_MEM_CONF_MEM_FORCE_PD_Msk = 0x2000000
	// Bit MEM_FORCE_PD.
	UART_MEM_CONF_MEM_FORCE_PD = 0x2000000
	// Position of MEM_FORCE_PU field.
	UART_MEM_CONF_MEM_FORCE_PU_Pos = 0x1a
	// Bit mask of MEM_FORCE_PU field.
	UART_MEM_CONF_MEM_FORCE_PU_Msk = 0x4000000
	// Bit MEM_FORCE_PU.
	UART_MEM_CONF_MEM_FORCE_PU = 0x4000000

	// TOUT_CONF: UART threshold and allocation configuration
	// Position of RX_TOUT_EN field.
	UART_TOUT_CONF_RX_TOUT_EN_Pos = 0x0
	// Bit mask of RX_TOUT_EN field.
	UART_TOUT_CONF_RX_TOUT_EN_Msk = 0x1
	// Bit RX_TOUT_EN.
	UART_TOUT_CONF_RX_TOUT_EN = 0x1
	// Position of RX_TOUT_FLOW_DIS field.
	UART_TOUT_CONF_RX_TOUT_FLOW_DIS_Pos = 0x1
	// Bit mask of RX_TOUT_FLOW_DIS field.
	UART_TOUT_CONF_RX_TOUT_FLOW_DIS_Msk = 0x2
	// Bit RX_TOUT_FLOW_DIS.
	UART_TOUT_CONF_RX_TOUT_FLOW_DIS = 0x2
	// Position of RX_TOUT_THRHD field.
	UART_TOUT_CONF_RX_TOUT_THRHD_Pos = 0x2
	// Bit mask of RX_TOUT_THRHD field.
	UART_TOUT_CONF_RX_TOUT_THRHD_Msk = 0xffc

	// MEM_TX_STATUS: Tx-SRAM write and read offset address.
	// Position of TX_SRAM_WADDR field.
	UART_MEM_TX_STATUS_TX_SRAM_WADDR_Pos = 0x0
	// Bit mask of TX_SRAM_WADDR field.
	UART_MEM_TX_STATUS_TX_SRAM_WADDR_Msk = 0xff
	// Position of TX_SRAM_RADDR field.
	UART_MEM_TX_STATUS_TX_SRAM_RADDR_Pos = 0x9
	// Bit mask of TX_SRAM_RADDR field.
	UART_MEM_TX_STATUS_TX_SRAM_RADDR_Msk = 0x1fe00

	// MEM_RX_STATUS: Rx-SRAM write and read offset address.
	// Position of RX_SRAM_RADDR field.
	UART_MEM_RX_STATUS_RX_SRAM_RADDR_Pos = 0x0
	// Bit mask of RX_SRAM_RADDR field.
	UART_MEM_RX_STATUS_RX_SRAM_RADDR_Msk = 0xff
	// Position of RX_SRAM_WADDR field.
	UART_MEM_RX_STATUS_RX_SRAM_WADDR_Pos = 0x9
	// Bit mask of RX_SRAM_WADDR field.
	UART_MEM_RX_STATUS_RX_SRAM_WADDR_Msk = 0x1fe00

	// FSM_STATUS: UART transmit and receive status.
	// Position of ST_URX_OUT field.
	UART_FSM_STATUS_ST_URX_OUT_Pos = 0x0
	// Bit mask of ST_URX_OUT field.
	UART_FSM_STATUS_ST_URX_OUT_Msk = 0xf
	// Position of ST_UTX_OUT field.
	UART_FSM_STATUS_ST_UTX_OUT_Pos = 0x4
	// Bit mask of ST_UTX_OUT field.
	UART_FSM_STATUS_ST_UTX_OUT_Msk = 0xf0

	// POSPULSE: Autobaud high pulse register
	// Position of POSEDGE_MIN_CNT field.
	UART_POSPULSE_POSEDGE_MIN_CNT_Pos = 0x0
	// Bit mask of POSEDGE_MIN_CNT field.
	UART_POSPULSE_POSEDGE_MIN_CNT_Msk = 0xfff

	// NEGPULSE: Autobaud low pulse register
	// Position of NEGEDGE_MIN_CNT field.
	UART_NEGPULSE_NEGEDGE_MIN_CNT_Pos = 0x0
	// Bit mask of NEGEDGE_MIN_CNT field.
	UART_NEGPULSE_NEGEDGE_MIN_CNT_Msk = 0xfff

	// LOWPULSE: Autobaud minimum low pulse duration register
	// Position of MIN_CNT field.
	UART_LOWPULSE_MIN_CNT_Pos = 0x0
	// Bit mask of MIN_CNT field.
	UART_LOWPULSE_MIN_CNT_Msk = 0xfff

	// HIGHPULSE: Autobaud minimum high pulse duration register
	// Position of MIN_CNT field.
	UART_HIGHPULSE_MIN_CNT_Pos = 0x0
	// Bit mask of MIN_CNT field.
	UART_HIGHPULSE_MIN_CNT_Msk = 0xfff

	// RXD_CNT: Autobaud edge change count register
	// Position of RXD_EDGE_CNT field.
	UART_RXD_CNT_RXD_EDGE_CNT_Pos = 0x0
	// Bit mask of RXD_EDGE_CNT field.
	UART_RXD_CNT_RXD_EDGE_CNT_Msk = 0x3ff

	// CLK_CONF: UART core clock configuration
	// Position of TX_SCLK_EN field.
	UART_CLK_CONF_TX_SCLK_EN_Pos = 0x18
	// Bit mask of TX_SCLK_EN field.
	UART_CLK_CONF_TX_SCLK_EN_Msk = 0x1000000
	// Bit TX_SCLK_EN.
	UART_CLK_CONF_TX_SCLK_EN = 0x1000000
	// Position of SCLK_EN field.
	UART_CLK_CONF_SCLK_EN_Pos = 0x19
	// Bit mask of SCLK_EN field.
	UART_CLK_CONF_SCLK_EN_Msk = 0x2000000
	// Bit SCLK_EN.
	UART_CLK_CONF_SCLK_EN = 0x2000000
	// Position of TX_RST_CORE field.
	UART_CLK_CONF_TX_RST_CORE_Pos = 0x1a
	// Bit mask of TX_RST_CORE field.
	UART_CLK_CONF_TX_RST_CORE_Msk = 0x4000000
	// Bit TX_RST_CORE.
	UART_CLK_CONF_TX_RST_CORE = 0x4000000
	// Position of RST_CORE field.
	UART_CLK_CONF_RST_CORE_Pos = 0x1b
	// Bit mask of RST_CORE field.
	UART_CLK_CONF_RST_CORE_Msk = 0x8000000
	// Bit RST_CORE.
	UART_CLK_CONF_RST_CORE = 0x8000000

	// DATE: UART Version register
	// Position of DATE field.
	UART_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	UART_DATE_DATE_Msk = 0xffffffff

	// AFIFO_STATUS: UART AFIFO Status
	// Position of TX_AFIFO_FULL field.
	UART_AFIFO_STATUS_TX_AFIFO_FULL_Pos = 0x0
	// Bit mask of TX_AFIFO_FULL field.
	UART_AFIFO_STATUS_TX_AFIFO_FULL_Msk = 0x1
	// Bit TX_AFIFO_FULL.
	UART_AFIFO_STATUS_TX_AFIFO_FULL = 0x1
	// Position of TX_AFIFO_EMPTY field.
	UART_AFIFO_STATUS_TX_AFIFO_EMPTY_Pos = 0x1
	// Bit mask of TX_AFIFO_EMPTY field.
	UART_AFIFO_STATUS_TX_AFIFO_EMPTY_Msk = 0x2
	// Bit TX_AFIFO_EMPTY.
	UART_AFIFO_STATUS_TX_AFIFO_EMPTY = 0x2
	// Position of RX_AFIFO_FULL field.
	UART_AFIFO_STATUS_RX_AFIFO_FULL_Pos = 0x2
	// Bit mask of RX_AFIFO_FULL field.
	UART_AFIFO_STATUS_RX_AFIFO_FULL_Msk = 0x4
	// Bit RX_AFIFO_FULL.
	UART_AFIFO_STATUS_RX_AFIFO_FULL = 0x4
	// Position of RX_AFIFO_EMPTY field.
	UART_AFIFO_STATUS_RX_AFIFO_EMPTY_Pos = 0x3
	// Bit mask of RX_AFIFO_EMPTY field.
	UART_AFIFO_STATUS_RX_AFIFO_EMPTY_Msk = 0x8
	// Bit RX_AFIFO_EMPTY.
	UART_AFIFO_STATUS_RX_AFIFO_EMPTY = 0x8

	// REG_UPDATE: UART Registers Configuration Update register
	// Position of REG_UPDATE field.
	UART_REG_UPDATE_REG_UPDATE_Pos = 0x0
	// Bit mask of REG_UPDATE field.
	UART_REG_UPDATE_REG_UPDATE_Msk = 0x1
	// Bit REG_UPDATE.
	UART_REG_UPDATE_REG_UPDATE = 0x1

	// ID: UART ID register
	// Position of ID field.
	UART_ID_ID_Pos = 0x0
	// Bit mask of ID field.
	UART_ID_ID_Msk = 0xffffffff
)

// Constants for UHCI0: Universal Host Controller Interface 0
const (
	// CONF0: a
	// Position of TX_RST field.
	UHCI_CONF0_TX_RST_Pos = 0x0
	// Bit mask of TX_RST field.
	UHCI_CONF0_TX_RST_Msk = 0x1
	// Bit TX_RST.
	UHCI_CONF0_TX_RST = 0x1
	// Position of RX_RST field.
	UHCI_CONF0_RX_RST_Pos = 0x1
	// Bit mask of RX_RST field.
	UHCI_CONF0_RX_RST_Msk = 0x2
	// Bit RX_RST.
	UHCI_CONF0_RX_RST = 0x2
	// Position of UART0_CE field.
	UHCI_CONF0_UART0_CE_Pos = 0x2
	// Bit mask of UART0_CE field.
	UHCI_CONF0_UART0_CE_Msk = 0x4
	// Bit UART0_CE.
	UHCI_CONF0_UART0_CE = 0x4
	// Position of UART1_CE field.
	UHCI_CONF0_UART1_CE_Pos = 0x3
	// Bit mask of UART1_CE field.
	UHCI_CONF0_UART1_CE_Msk = 0x8
	// Bit UART1_CE.
	UHCI_CONF0_UART1_CE = 0x8
	// Position of SEPER_EN field.
	UHCI_CONF0_SEPER_EN_Pos = 0x5
	// Bit mask of SEPER_EN field.
	UHCI_CONF0_SEPER_EN_Msk = 0x20
	// Bit SEPER_EN.
	UHCI_CONF0_SEPER_EN = 0x20
	// Position of HEAD_EN field.
	UHCI_CONF0_HEAD_EN_Pos = 0x6
	// Bit mask of HEAD_EN field.
	UHCI_CONF0_HEAD_EN_Msk = 0x40
	// Bit HEAD_EN.
	UHCI_CONF0_HEAD_EN = 0x40
	// Position of CRC_REC_EN field.
	UHCI_CONF0_CRC_REC_EN_Pos = 0x7
	// Bit mask of CRC_REC_EN field.
	UHCI_CONF0_CRC_REC_EN_Msk = 0x80
	// Bit CRC_REC_EN.
	UHCI_CONF0_CRC_REC_EN = 0x80
	// Position of UART_IDLE_EOF_EN field.
	UHCI_CONF0_UART_IDLE_EOF_EN_Pos = 0x8
	// Bit mask of UART_IDLE_EOF_EN field.
	UHCI_CONF0_UART_IDLE_EOF_EN_Msk = 0x100
	// Bit UART_IDLE_EOF_EN.
	UHCI_CONF0_UART_IDLE_EOF_EN = 0x100
	// Position of LEN_EOF_EN field.
	UHCI_CONF0_LEN_EOF_EN_Pos = 0x9
	// Bit mask of LEN_EOF_EN field.
	UHCI_CONF0_LEN_EOF_EN_Msk = 0x200
	// Bit LEN_EOF_EN.
	UHCI_CONF0_LEN_EOF_EN = 0x200
	// Position of ENCODE_CRC_EN field.
	UHCI_CONF0_ENCODE_CRC_EN_Pos = 0xa
	// Bit mask of ENCODE_CRC_EN field.
	UHCI_CONF0_ENCODE_CRC_EN_Msk = 0x400
	// Bit ENCODE_CRC_EN.
	UHCI_CONF0_ENCODE_CRC_EN = 0x400
	// Position of CLK_EN field.
	UHCI_CONF0_CLK_EN_Pos = 0xb
	// Bit mask of CLK_EN field.
	UHCI_CONF0_CLK_EN_Msk = 0x800
	// Bit CLK_EN.
	UHCI_CONF0_CLK_EN = 0x800
	// Position of UART_RX_BRK_EOF_EN field.
	UHCI_CONF0_UART_RX_BRK_EOF_EN_Pos = 0xc
	// Bit mask of UART_RX_BRK_EOF_EN field.
	UHCI_CONF0_UART_RX_BRK_EOF_EN_Msk = 0x1000
	// Bit UART_RX_BRK_EOF_EN.
	UHCI_CONF0_UART_RX_BRK_EOF_EN = 0x1000

	// INT_RAW: a
	// Position of RX_START_INT_RAW field.
	UHCI_INT_RAW_RX_START_INT_RAW_Pos = 0x0
	// Bit mask of RX_START_INT_RAW field.
	UHCI_INT_RAW_RX_START_INT_RAW_Msk = 0x1
	// Bit RX_START_INT_RAW.
	UHCI_INT_RAW_RX_START_INT_RAW = 0x1
	// Position of TX_START_INT_RAW field.
	UHCI_INT_RAW_TX_START_INT_RAW_Pos = 0x1
	// Bit mask of TX_START_INT_RAW field.
	UHCI_INT_RAW_TX_START_INT_RAW_Msk = 0x2
	// Bit TX_START_INT_RAW.
	UHCI_INT_RAW_TX_START_INT_RAW = 0x2
	// Position of RX_HUNG_INT_RAW field.
	UHCI_INT_RAW_RX_HUNG_INT_RAW_Pos = 0x2
	// Bit mask of RX_HUNG_INT_RAW field.
	UHCI_INT_RAW_RX_HUNG_INT_RAW_Msk = 0x4
	// Bit RX_HUNG_INT_RAW.
	UHCI_INT_RAW_RX_HUNG_INT_RAW = 0x4
	// Position of TX_HUNG_INT_RAW field.
	UHCI_INT_RAW_TX_HUNG_INT_RAW_Pos = 0x3
	// Bit mask of TX_HUNG_INT_RAW field.
	UHCI_INT_RAW_TX_HUNG_INT_RAW_Msk = 0x8
	// Bit TX_HUNG_INT_RAW.
	UHCI_INT_RAW_TX_HUNG_INT_RAW = 0x8
	// Position of SEND_S_REG_Q_INT_RAW field.
	UHCI_INT_RAW_SEND_S_REG_Q_INT_RAW_Pos = 0x4
	// Bit mask of SEND_S_REG_Q_INT_RAW field.
	UHCI_INT_RAW_SEND_S_REG_Q_INT_RAW_Msk = 0x10
	// Bit SEND_S_REG_Q_INT_RAW.
	UHCI_INT_RAW_SEND_S_REG_Q_INT_RAW = 0x10
	// Position of SEND_A_REG_Q_INT_RAW field.
	UHCI_INT_RAW_SEND_A_REG_Q_INT_RAW_Pos = 0x5
	// Bit mask of SEND_A_REG_Q_INT_RAW field.
	UHCI_INT_RAW_SEND_A_REG_Q_INT_RAW_Msk = 0x20
	// Bit SEND_A_REG_Q_INT_RAW.
	UHCI_INT_RAW_SEND_A_REG_Q_INT_RAW = 0x20
	// Position of OUT_EOF_INT_RAW field.
	UHCI_INT_RAW_OUT_EOF_INT_RAW_Pos = 0x6
	// Bit mask of OUT_EOF_INT_RAW field.
	UHCI_INT_RAW_OUT_EOF_INT_RAW_Msk = 0x40
	// Bit OUT_EOF_INT_RAW.
	UHCI_INT_RAW_OUT_EOF_INT_RAW = 0x40
	// Position of APP_CTRL0_INT_RAW field.
	UHCI_INT_RAW_APP_CTRL0_INT_RAW_Pos = 0x7
	// Bit mask of APP_CTRL0_INT_RAW field.
	UHCI_INT_RAW_APP_CTRL0_INT_RAW_Msk = 0x80
	// Bit APP_CTRL0_INT_RAW.
	UHCI_INT_RAW_APP_CTRL0_INT_RAW = 0x80
	// Position of APP_CTRL1_INT_RAW field.
	UHCI_INT_RAW_APP_CTRL1_INT_RAW_Pos = 0x8
	// Bit mask of APP_CTRL1_INT_RAW field.
	UHCI_INT_RAW_APP_CTRL1_INT_RAW_Msk = 0x100
	// Bit APP_CTRL1_INT_RAW.
	UHCI_INT_RAW_APP_CTRL1_INT_RAW = 0x100

	// INT_ST: a
	// Position of RX_START_INT_ST field.
	UHCI_INT_ST_RX_START_INT_ST_Pos = 0x0
	// Bit mask of RX_START_INT_ST field.
	UHCI_INT_ST_RX_START_INT_ST_Msk = 0x1
	// Bit RX_START_INT_ST.
	UHCI_INT_ST_RX_START_INT_ST = 0x1
	// Position of TX_START_INT_ST field.
	UHCI_INT_ST_TX_START_INT_ST_Pos = 0x1
	// Bit mask of TX_START_INT_ST field.
	UHCI_INT_ST_TX_START_INT_ST_Msk = 0x2
	// Bit TX_START_INT_ST.
	UHCI_INT_ST_TX_START_INT_ST = 0x2
	// Position of RX_HUNG_INT_ST field.
	UHCI_INT_ST_RX_HUNG_INT_ST_Pos = 0x2
	// Bit mask of RX_HUNG_INT_ST field.
	UHCI_INT_ST_RX_HUNG_INT_ST_Msk = 0x4
	// Bit RX_HUNG_INT_ST.
	UHCI_INT_ST_RX_HUNG_INT_ST = 0x4
	// Position of TX_HUNG_INT_ST field.
	UHCI_INT_ST_TX_HUNG_INT_ST_Pos = 0x3
	// Bit mask of TX_HUNG_INT_ST field.
	UHCI_INT_ST_TX_HUNG_INT_ST_Msk = 0x8
	// Bit TX_HUNG_INT_ST.
	UHCI_INT_ST_TX_HUNG_INT_ST = 0x8
	// Position of SEND_S_REG_Q_INT_ST field.
	UHCI_INT_ST_SEND_S_REG_Q_INT_ST_Pos = 0x4
	// Bit mask of SEND_S_REG_Q_INT_ST field.
	UHCI_INT_ST_SEND_S_REG_Q_INT_ST_Msk = 0x10
	// Bit SEND_S_REG_Q_INT_ST.
	UHCI_INT_ST_SEND_S_REG_Q_INT_ST = 0x10
	// Position of SEND_A_REG_Q_INT_ST field.
	UHCI_INT_ST_SEND_A_REG_Q_INT_ST_Pos = 0x5
	// Bit mask of SEND_A_REG_Q_INT_ST field.
	UHCI_INT_ST_SEND_A_REG_Q_INT_ST_Msk = 0x20
	// Bit SEND_A_REG_Q_INT_ST.
	UHCI_INT_ST_SEND_A_REG_Q_INT_ST = 0x20
	// Position of OUTLINK_EOF_ERR_INT_ST field.
	UHCI_INT_ST_OUTLINK_EOF_ERR_INT_ST_Pos = 0x6
	// Bit mask of OUTLINK_EOF_ERR_INT_ST field.
	UHCI_INT_ST_OUTLINK_EOF_ERR_INT_ST_Msk = 0x40
	// Bit OUTLINK_EOF_ERR_INT_ST.
	UHCI_INT_ST_OUTLINK_EOF_ERR_INT_ST = 0x40
	// Position of APP_CTRL0_INT_ST field.
	UHCI_INT_ST_APP_CTRL0_INT_ST_Pos = 0x7
	// Bit mask of APP_CTRL0_INT_ST field.
	UHCI_INT_ST_APP_CTRL0_INT_ST_Msk = 0x80
	// Bit APP_CTRL0_INT_ST.
	UHCI_INT_ST_APP_CTRL0_INT_ST = 0x80
	// Position of APP_CTRL1_INT_ST field.
	UHCI_INT_ST_APP_CTRL1_INT_ST_Pos = 0x8
	// Bit mask of APP_CTRL1_INT_ST field.
	UHCI_INT_ST_APP_CTRL1_INT_ST_Msk = 0x100
	// Bit APP_CTRL1_INT_ST.
	UHCI_INT_ST_APP_CTRL1_INT_ST = 0x100

	// INT_ENA: a
	// Position of RX_START_INT_ENA field.
	UHCI_INT_ENA_RX_START_INT_ENA_Pos = 0x0
	// Bit mask of RX_START_INT_ENA field.
	UHCI_INT_ENA_RX_START_INT_ENA_Msk = 0x1
	// Bit RX_START_INT_ENA.
	UHCI_INT_ENA_RX_START_INT_ENA = 0x1
	// Position of TX_START_INT_ENA field.
	UHCI_INT_ENA_TX_START_INT_ENA_Pos = 0x1
	// Bit mask of TX_START_INT_ENA field.
	UHCI_INT_ENA_TX_START_INT_ENA_Msk = 0x2
	// Bit TX_START_INT_ENA.
	UHCI_INT_ENA_TX_START_INT_ENA = 0x2
	// Position of RX_HUNG_INT_ENA field.
	UHCI_INT_ENA_RX_HUNG_INT_ENA_Pos = 0x2
	// Bit mask of RX_HUNG_INT_ENA field.
	UHCI_INT_ENA_RX_HUNG_INT_ENA_Msk = 0x4
	// Bit RX_HUNG_INT_ENA.
	UHCI_INT_ENA_RX_HUNG_INT_ENA = 0x4
	// Position of TX_HUNG_INT_ENA field.
	UHCI_INT_ENA_TX_HUNG_INT_ENA_Pos = 0x3
	// Bit mask of TX_HUNG_INT_ENA field.
	UHCI_INT_ENA_TX_HUNG_INT_ENA_Msk = 0x8
	// Bit TX_HUNG_INT_ENA.
	UHCI_INT_ENA_TX_HUNG_INT_ENA = 0x8
	// Position of SEND_S_REG_Q_INT_ENA field.
	UHCI_INT_ENA_SEND_S_REG_Q_INT_ENA_Pos = 0x4
	// Bit mask of SEND_S_REG_Q_INT_ENA field.
	UHCI_INT_ENA_SEND_S_REG_Q_INT_ENA_Msk = 0x10
	// Bit SEND_S_REG_Q_INT_ENA.
	UHCI_INT_ENA_SEND_S_REG_Q_INT_ENA = 0x10
	// Position of SEND_A_REG_Q_INT_ENA field.
	UHCI_INT_ENA_SEND_A_REG_Q_INT_ENA_Pos = 0x5
	// Bit mask of SEND_A_REG_Q_INT_ENA field.
	UHCI_INT_ENA_SEND_A_REG_Q_INT_ENA_Msk = 0x20
	// Bit SEND_A_REG_Q_INT_ENA.
	UHCI_INT_ENA_SEND_A_REG_Q_INT_ENA = 0x20
	// Position of OUTLINK_EOF_ERR_INT_ENA field.
	UHCI_INT_ENA_OUTLINK_EOF_ERR_INT_ENA_Pos = 0x6
	// Bit mask of OUTLINK_EOF_ERR_INT_ENA field.
	UHCI_INT_ENA_OUTLINK_EOF_ERR_INT_ENA_Msk = 0x40
	// Bit OUTLINK_EOF_ERR_INT_ENA.
	UHCI_INT_ENA_OUTLINK_EOF_ERR_INT_ENA = 0x40
	// Position of APP_CTRL0_INT_ENA field.
	UHCI_INT_ENA_APP_CTRL0_INT_ENA_Pos = 0x7
	// Bit mask of APP_CTRL0_INT_ENA field.
	UHCI_INT_ENA_APP_CTRL0_INT_ENA_Msk = 0x80
	// Bit APP_CTRL0_INT_ENA.
	UHCI_INT_ENA_APP_CTRL0_INT_ENA = 0x80
	// Position of APP_CTRL1_INT_ENA field.
	UHCI_INT_ENA_APP_CTRL1_INT_ENA_Pos = 0x8
	// Bit mask of APP_CTRL1_INT_ENA field.
	UHCI_INT_ENA_APP_CTRL1_INT_ENA_Msk = 0x100
	// Bit APP_CTRL1_INT_ENA.
	UHCI_INT_ENA_APP_CTRL1_INT_ENA = 0x100

	// INT_CLR: a
	// Position of RX_START_INT_CLR field.
	UHCI_INT_CLR_RX_START_INT_CLR_Pos = 0x0
	// Bit mask of RX_START_INT_CLR field.
	UHCI_INT_CLR_RX_START_INT_CLR_Msk = 0x1
	// Bit RX_START_INT_CLR.
	UHCI_INT_CLR_RX_START_INT_CLR = 0x1
	// Position of TX_START_INT_CLR field.
	UHCI_INT_CLR_TX_START_INT_CLR_Pos = 0x1
	// Bit mask of TX_START_INT_CLR field.
	UHCI_INT_CLR_TX_START_INT_CLR_Msk = 0x2
	// Bit TX_START_INT_CLR.
	UHCI_INT_CLR_TX_START_INT_CLR = 0x2
	// Position of RX_HUNG_INT_CLR field.
	UHCI_INT_CLR_RX_HUNG_INT_CLR_Pos = 0x2
	// Bit mask of RX_HUNG_INT_CLR field.
	UHCI_INT_CLR_RX_HUNG_INT_CLR_Msk = 0x4
	// Bit RX_HUNG_INT_CLR.
	UHCI_INT_CLR_RX_HUNG_INT_CLR = 0x4
	// Position of TX_HUNG_INT_CLR field.
	UHCI_INT_CLR_TX_HUNG_INT_CLR_Pos = 0x3
	// Bit mask of TX_HUNG_INT_CLR field.
	UHCI_INT_CLR_TX_HUNG_INT_CLR_Msk = 0x8
	// Bit TX_HUNG_INT_CLR.
	UHCI_INT_CLR_TX_HUNG_INT_CLR = 0x8
	// Position of SEND_S_REG_Q_INT_CLR field.
	UHCI_INT_CLR_SEND_S_REG_Q_INT_CLR_Pos = 0x4
	// Bit mask of SEND_S_REG_Q_INT_CLR field.
	UHCI_INT_CLR_SEND_S_REG_Q_INT_CLR_Msk = 0x10
	// Bit SEND_S_REG_Q_INT_CLR.
	UHCI_INT_CLR_SEND_S_REG_Q_INT_CLR = 0x10
	// Position of SEND_A_REG_Q_INT_CLR field.
	UHCI_INT_CLR_SEND_A_REG_Q_INT_CLR_Pos = 0x5
	// Bit mask of SEND_A_REG_Q_INT_CLR field.
	UHCI_INT_CLR_SEND_A_REG_Q_INT_CLR_Msk = 0x20
	// Bit SEND_A_REG_Q_INT_CLR.
	UHCI_INT_CLR_SEND_A_REG_Q_INT_CLR = 0x20
	// Position of OUTLINK_EOF_ERR_INT_CLR field.
	UHCI_INT_CLR_OUTLINK_EOF_ERR_INT_CLR_Pos = 0x6
	// Bit mask of OUTLINK_EOF_ERR_INT_CLR field.
	UHCI_INT_CLR_OUTLINK_EOF_ERR_INT_CLR_Msk = 0x40
	// Bit OUTLINK_EOF_ERR_INT_CLR.
	UHCI_INT_CLR_OUTLINK_EOF_ERR_INT_CLR = 0x40
	// Position of APP_CTRL0_INT_CLR field.
	UHCI_INT_CLR_APP_CTRL0_INT_CLR_Pos = 0x7
	// Bit mask of APP_CTRL0_INT_CLR field.
	UHCI_INT_CLR_APP_CTRL0_INT_CLR_Msk = 0x80
	// Bit APP_CTRL0_INT_CLR.
	UHCI_INT_CLR_APP_CTRL0_INT_CLR = 0x80
	// Position of APP_CTRL1_INT_CLR field.
	UHCI_INT_CLR_APP_CTRL1_INT_CLR_Pos = 0x8
	// Bit mask of APP_CTRL1_INT_CLR field.
	UHCI_INT_CLR_APP_CTRL1_INT_CLR_Msk = 0x100
	// Bit APP_CTRL1_INT_CLR.
	UHCI_INT_CLR_APP_CTRL1_INT_CLR = 0x100

	// CONF1: a
	// Position of CHECK_SUM_EN field.
	UHCI_CONF1_CHECK_SUM_EN_Pos = 0x0
	// Bit mask of CHECK_SUM_EN field.
	UHCI_CONF1_CHECK_SUM_EN_Msk = 0x1
	// Bit CHECK_SUM_EN.
	UHCI_CONF1_CHECK_SUM_EN = 0x1
	// Position of CHECK_SEQ_EN field.
	UHCI_CONF1_CHECK_SEQ_EN_Pos = 0x1
	// Bit mask of CHECK_SEQ_EN field.
	UHCI_CONF1_CHECK_SEQ_EN_Msk = 0x2
	// Bit CHECK_SEQ_EN.
	UHCI_CONF1_CHECK_SEQ_EN = 0x2
	// Position of CRC_DISABLE field.
	UHCI_CONF1_CRC_DISABLE_Pos = 0x2
	// Bit mask of CRC_DISABLE field.
	UHCI_CONF1_CRC_DISABLE_Msk = 0x4
	// Bit CRC_DISABLE.
	UHCI_CONF1_CRC_DISABLE = 0x4
	// Position of SAVE_HEAD field.
	UHCI_CONF1_SAVE_HEAD_Pos = 0x3
	// Bit mask of SAVE_HEAD field.
	UHCI_CONF1_SAVE_HEAD_Msk = 0x8
	// Bit SAVE_HEAD.
	UHCI_CONF1_SAVE_HEAD = 0x8
	// Position of TX_CHECK_SUM_RE field.
	UHCI_CONF1_TX_CHECK_SUM_RE_Pos = 0x4
	// Bit mask of TX_CHECK_SUM_RE field.
	UHCI_CONF1_TX_CHECK_SUM_RE_Msk = 0x10
	// Bit TX_CHECK_SUM_RE.
	UHCI_CONF1_TX_CHECK_SUM_RE = 0x10
	// Position of TX_ACK_NUM_RE field.
	UHCI_CONF1_TX_ACK_NUM_RE_Pos = 0x5
	// Bit mask of TX_ACK_NUM_RE field.
	UHCI_CONF1_TX_ACK_NUM_RE_Msk = 0x20
	// Bit TX_ACK_NUM_RE.
	UHCI_CONF1_TX_ACK_NUM_RE = 0x20
	// Position of WAIT_SW_START field.
	UHCI_CONF1_WAIT_SW_START_Pos = 0x7
	// Bit mask of WAIT_SW_START field.
	UHCI_CONF1_WAIT_SW_START_Msk = 0x80
	// Bit WAIT_SW_START.
	UHCI_CONF1_WAIT_SW_START = 0x80
	// Position of SW_START field.
	UHCI_CONF1_SW_START_Pos = 0x8
	// Bit mask of SW_START field.
	UHCI_CONF1_SW_START_Msk = 0x100
	// Bit SW_START.
	UHCI_CONF1_SW_START = 0x100

	// STATE0: a
	// Position of RX_ERR_CAUSE field.
	UHCI_STATE0_RX_ERR_CAUSE_Pos = 0x0
	// Bit mask of RX_ERR_CAUSE field.
	UHCI_STATE0_RX_ERR_CAUSE_Msk = 0x7
	// Position of DECODE_STATE field.
	UHCI_STATE0_DECODE_STATE_Pos = 0x3
	// Bit mask of DECODE_STATE field.
	UHCI_STATE0_DECODE_STATE_Msk = 0x38

	// STATE1: a
	// Position of ENCODE_STATE field.
	UHCI_STATE1_ENCODE_STATE_Pos = 0x0
	// Bit mask of ENCODE_STATE field.
	UHCI_STATE1_ENCODE_STATE_Msk = 0x7

	// ESCAPE_CONF: a
	// Position of TX_C0_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_C0_ESC_EN_Pos = 0x0
	// Bit mask of TX_C0_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_C0_ESC_EN_Msk = 0x1
	// Bit TX_C0_ESC_EN.
	UHCI_ESCAPE_CONF_TX_C0_ESC_EN = 0x1
	// Position of TX_DB_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_DB_ESC_EN_Pos = 0x1
	// Bit mask of TX_DB_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_DB_ESC_EN_Msk = 0x2
	// Bit TX_DB_ESC_EN.
	UHCI_ESCAPE_CONF_TX_DB_ESC_EN = 0x2
	// Position of TX_11_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_11_ESC_EN_Pos = 0x2
	// Bit mask of TX_11_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_11_ESC_EN_Msk = 0x4
	// Bit TX_11_ESC_EN.
	UHCI_ESCAPE_CONF_TX_11_ESC_EN = 0x4
	// Position of TX_13_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_13_ESC_EN_Pos = 0x3
	// Bit mask of TX_13_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_13_ESC_EN_Msk = 0x8
	// Bit TX_13_ESC_EN.
	UHCI_ESCAPE_CONF_TX_13_ESC_EN = 0x8
	// Position of RX_C0_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_C0_ESC_EN_Pos = 0x4
	// Bit mask of RX_C0_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_C0_ESC_EN_Msk = 0x10
	// Bit RX_C0_ESC_EN.
	UHCI_ESCAPE_CONF_RX_C0_ESC_EN = 0x10
	// Position of RX_DB_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_DB_ESC_EN_Pos = 0x5
	// Bit mask of RX_DB_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_DB_ESC_EN_Msk = 0x20
	// Bit RX_DB_ESC_EN.
	UHCI_ESCAPE_CONF_RX_DB_ESC_EN = 0x20
	// Position of RX_11_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_11_ESC_EN_Pos = 0x6
	// Bit mask of RX_11_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_11_ESC_EN_Msk = 0x40
	// Bit RX_11_ESC_EN.
	UHCI_ESCAPE_CONF_RX_11_ESC_EN = 0x40
	// Position of RX_13_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_13_ESC_EN_Pos = 0x7
	// Bit mask of RX_13_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_13_ESC_EN_Msk = 0x80
	// Bit RX_13_ESC_EN.
	UHCI_ESCAPE_CONF_RX_13_ESC_EN = 0x80

	// HUNG_CONF: a
	// Position of TXFIFO_TIMEOUT field.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_Pos = 0x0
	// Bit mask of TXFIFO_TIMEOUT field.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_Msk = 0xff
	// Position of TXFIFO_TIMEOUT_SHIFT field.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_SHIFT_Pos = 0x8
	// Bit mask of TXFIFO_TIMEOUT_SHIFT field.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_SHIFT_Msk = 0x700
	// Position of TXFIFO_TIMEOUT_ENA field.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_ENA_Pos = 0xb
	// Bit mask of TXFIFO_TIMEOUT_ENA field.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_ENA_Msk = 0x800
	// Bit TXFIFO_TIMEOUT_ENA.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_ENA = 0x800
	// Position of RXFIFO_TIMEOUT field.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_Pos = 0xc
	// Bit mask of RXFIFO_TIMEOUT field.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_Msk = 0xff000
	// Position of RXFIFO_TIMEOUT_SHIFT field.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_SHIFT_Pos = 0x14
	// Bit mask of RXFIFO_TIMEOUT_SHIFT field.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_SHIFT_Msk = 0x700000
	// Position of RXFIFO_TIMEOUT_ENA field.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_ENA_Pos = 0x17
	// Bit mask of RXFIFO_TIMEOUT_ENA field.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_ENA_Msk = 0x800000
	// Bit RXFIFO_TIMEOUT_ENA.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_ENA = 0x800000

	// ACK_NUM: a
	// Position of ACK_NUM field.
	UHCI_ACK_NUM_ACK_NUM_Pos = 0x0
	// Bit mask of ACK_NUM field.
	UHCI_ACK_NUM_ACK_NUM_Msk = 0x7
	// Position of LOAD field.
	UHCI_ACK_NUM_LOAD_Pos = 0x3
	// Bit mask of LOAD field.
	UHCI_ACK_NUM_LOAD_Msk = 0x8
	// Bit LOAD.
	UHCI_ACK_NUM_LOAD = 0x8

	// RX_HEAD: a
	// Position of RX_HEAD field.
	UHCI_RX_HEAD_RX_HEAD_Pos = 0x0
	// Bit mask of RX_HEAD field.
	UHCI_RX_HEAD_RX_HEAD_Msk = 0xffffffff

	// QUICK_SENT: a
	// Position of SINGLE_SEND_NUM field.
	UHCI_QUICK_SENT_SINGLE_SEND_NUM_Pos = 0x0
	// Bit mask of SINGLE_SEND_NUM field.
	UHCI_QUICK_SENT_SINGLE_SEND_NUM_Msk = 0x7
	// Position of SINGLE_SEND_EN field.
	UHCI_QUICK_SENT_SINGLE_SEND_EN_Pos = 0x3
	// Bit mask of SINGLE_SEND_EN field.
	UHCI_QUICK_SENT_SINGLE_SEND_EN_Msk = 0x8
	// Bit SINGLE_SEND_EN.
	UHCI_QUICK_SENT_SINGLE_SEND_EN = 0x8
	// Position of ALWAYS_SEND_NUM field.
	UHCI_QUICK_SENT_ALWAYS_SEND_NUM_Pos = 0x4
	// Bit mask of ALWAYS_SEND_NUM field.
	UHCI_QUICK_SENT_ALWAYS_SEND_NUM_Msk = 0x70
	// Position of ALWAYS_SEND_EN field.
	UHCI_QUICK_SENT_ALWAYS_SEND_EN_Pos = 0x7
	// Bit mask of ALWAYS_SEND_EN field.
	UHCI_QUICK_SENT_ALWAYS_SEND_EN_Msk = 0x80
	// Bit ALWAYS_SEND_EN.
	UHCI_QUICK_SENT_ALWAYS_SEND_EN = 0x80

	// REG_Q0_WORD0: a
	// Position of SEND_Q0_WORD0 field.
	UHCI_REG_Q0_WORD0_SEND_Q0_WORD0_Pos = 0x0
	// Bit mask of SEND_Q0_WORD0 field.
	UHCI_REG_Q0_WORD0_SEND_Q0_WORD0_Msk = 0xffffffff

	// REG_Q0_WORD1: a
	// Position of SEND_Q0_WORD1 field.
	UHCI_REG_Q0_WORD1_SEND_Q0_WORD1_Pos = 0x0
	// Bit mask of SEND_Q0_WORD1 field.
	UHCI_REG_Q0_WORD1_SEND_Q0_WORD1_Msk = 0xffffffff

	// REG_Q1_WORD0: a
	// Position of SEND_Q1_WORD0 field.
	UHCI_REG_Q1_WORD0_SEND_Q1_WORD0_Pos = 0x0
	// Bit mask of SEND_Q1_WORD0 field.
	UHCI_REG_Q1_WORD0_SEND_Q1_WORD0_Msk = 0xffffffff

	// REG_Q1_WORD1: a
	// Position of SEND_Q1_WORD1 field.
	UHCI_REG_Q1_WORD1_SEND_Q1_WORD1_Pos = 0x0
	// Bit mask of SEND_Q1_WORD1 field.
	UHCI_REG_Q1_WORD1_SEND_Q1_WORD1_Msk = 0xffffffff

	// REG_Q2_WORD0: a
	// Position of SEND_Q2_WORD0 field.
	UHCI_REG_Q2_WORD0_SEND_Q2_WORD0_Pos = 0x0
	// Bit mask of SEND_Q2_WORD0 field.
	UHCI_REG_Q2_WORD0_SEND_Q2_WORD0_Msk = 0xffffffff

	// REG_Q2_WORD1: a
	// Position of SEND_Q2_WORD1 field.
	UHCI_REG_Q2_WORD1_SEND_Q2_WORD1_Pos = 0x0
	// Bit mask of SEND_Q2_WORD1 field.
	UHCI_REG_Q2_WORD1_SEND_Q2_WORD1_Msk = 0xffffffff

	// REG_Q3_WORD0: a
	// Position of SEND_Q3_WORD0 field.
	UHCI_REG_Q3_WORD0_SEND_Q3_WORD0_Pos = 0x0
	// Bit mask of SEND_Q3_WORD0 field.
	UHCI_REG_Q3_WORD0_SEND_Q3_WORD0_Msk = 0xffffffff

	// REG_Q3_WORD1: a
	// Position of SEND_Q3_WORD1 field.
	UHCI_REG_Q3_WORD1_SEND_Q3_WORD1_Pos = 0x0
	// Bit mask of SEND_Q3_WORD1 field.
	UHCI_REG_Q3_WORD1_SEND_Q3_WORD1_Msk = 0xffffffff

	// REG_Q4_WORD0: a
	// Position of SEND_Q4_WORD0 field.
	UHCI_REG_Q4_WORD0_SEND_Q4_WORD0_Pos = 0x0
	// Bit mask of SEND_Q4_WORD0 field.
	UHCI_REG_Q4_WORD0_SEND_Q4_WORD0_Msk = 0xffffffff

	// REG_Q4_WORD1: a
	// Position of SEND_Q4_WORD1 field.
	UHCI_REG_Q4_WORD1_SEND_Q4_WORD1_Pos = 0x0
	// Bit mask of SEND_Q4_WORD1 field.
	UHCI_REG_Q4_WORD1_SEND_Q4_WORD1_Msk = 0xffffffff

	// REG_Q5_WORD0: a
	// Position of SEND_Q5_WORD0 field.
	UHCI_REG_Q5_WORD0_SEND_Q5_WORD0_Pos = 0x0
	// Bit mask of SEND_Q5_WORD0 field.
	UHCI_REG_Q5_WORD0_SEND_Q5_WORD0_Msk = 0xffffffff

	// REG_Q5_WORD1: a
	// Position of SEND_Q5_WORD1 field.
	UHCI_REG_Q5_WORD1_SEND_Q5_WORD1_Pos = 0x0
	// Bit mask of SEND_Q5_WORD1 field.
	UHCI_REG_Q5_WORD1_SEND_Q5_WORD1_Msk = 0xffffffff

	// REG_Q6_WORD0: a
	// Position of SEND_Q6_WORD0 field.
	UHCI_REG_Q6_WORD0_SEND_Q6_WORD0_Pos = 0x0
	// Bit mask of SEND_Q6_WORD0 field.
	UHCI_REG_Q6_WORD0_SEND_Q6_WORD0_Msk = 0xffffffff

	// REG_Q6_WORD1: a
	// Position of SEND_Q6_WORD1 field.
	UHCI_REG_Q6_WORD1_SEND_Q6_WORD1_Pos = 0x0
	// Bit mask of SEND_Q6_WORD1 field.
	UHCI_REG_Q6_WORD1_SEND_Q6_WORD1_Msk = 0xffffffff

	// ESC_CONF0: a
	// Position of SEPER_CHAR field.
	UHCI_ESC_CONF0_SEPER_CHAR_Pos = 0x0
	// Bit mask of SEPER_CHAR field.
	UHCI_ESC_CONF0_SEPER_CHAR_Msk = 0xff
	// Position of SEPER_ESC_CHAR0 field.
	UHCI_ESC_CONF0_SEPER_ESC_CHAR0_Pos = 0x8
	// Bit mask of SEPER_ESC_CHAR0 field.
	UHCI_ESC_CONF0_SEPER_ESC_CHAR0_Msk = 0xff00
	// Position of SEPER_ESC_CHAR1 field.
	UHCI_ESC_CONF0_SEPER_ESC_CHAR1_Pos = 0x10
	// Bit mask of SEPER_ESC_CHAR1 field.
	UHCI_ESC_CONF0_SEPER_ESC_CHAR1_Msk = 0xff0000

	// ESC_CONF1: a
	// Position of ESC_SEQ0 field.
	UHCI_ESC_CONF1_ESC_SEQ0_Pos = 0x0
	// Bit mask of ESC_SEQ0 field.
	UHCI_ESC_CONF1_ESC_SEQ0_Msk = 0xff
	// Position of ESC_SEQ0_CHAR0 field.
	UHCI_ESC_CONF1_ESC_SEQ0_CHAR0_Pos = 0x8
	// Bit mask of ESC_SEQ0_CHAR0 field.
	UHCI_ESC_CONF1_ESC_SEQ0_CHAR0_Msk = 0xff00
	// Position of ESC_SEQ0_CHAR1 field.
	UHCI_ESC_CONF1_ESC_SEQ0_CHAR1_Pos = 0x10
	// Bit mask of ESC_SEQ0_CHAR1 field.
	UHCI_ESC_CONF1_ESC_SEQ0_CHAR1_Msk = 0xff0000

	// ESC_CONF2: a
	// Position of ESC_SEQ1 field.
	UHCI_ESC_CONF2_ESC_SEQ1_Pos = 0x0
	// Bit mask of ESC_SEQ1 field.
	UHCI_ESC_CONF2_ESC_SEQ1_Msk = 0xff
	// Position of ESC_SEQ1_CHAR0 field.
	UHCI_ESC_CONF2_ESC_SEQ1_CHAR0_Pos = 0x8
	// Bit mask of ESC_SEQ1_CHAR0 field.
	UHCI_ESC_CONF2_ESC_SEQ1_CHAR0_Msk = 0xff00
	// Position of ESC_SEQ1_CHAR1 field.
	UHCI_ESC_CONF2_ESC_SEQ1_CHAR1_Pos = 0x10
	// Bit mask of ESC_SEQ1_CHAR1 field.
	UHCI_ESC_CONF2_ESC_SEQ1_CHAR1_Msk = 0xff0000

	// ESC_CONF3: a
	// Position of ESC_SEQ2 field.
	UHCI_ESC_CONF3_ESC_SEQ2_Pos = 0x0
	// Bit mask of ESC_SEQ2 field.
	UHCI_ESC_CONF3_ESC_SEQ2_Msk = 0xff
	// Position of ESC_SEQ2_CHAR0 field.
	UHCI_ESC_CONF3_ESC_SEQ2_CHAR0_Pos = 0x8
	// Bit mask of ESC_SEQ2_CHAR0 field.
	UHCI_ESC_CONF3_ESC_SEQ2_CHAR0_Msk = 0xff00
	// Position of ESC_SEQ2_CHAR1 field.
	UHCI_ESC_CONF3_ESC_SEQ2_CHAR1_Pos = 0x10
	// Bit mask of ESC_SEQ2_CHAR1 field.
	UHCI_ESC_CONF3_ESC_SEQ2_CHAR1_Msk = 0xff0000

	// PKT_THRES: a
	// Position of PKT_THRS field.
	UHCI_PKT_THRES_PKT_THRS_Pos = 0x0
	// Bit mask of PKT_THRS field.
	UHCI_PKT_THRES_PKT_THRS_Msk = 0x1fff

	// DATE: a
	// Position of DATE field.
	UHCI_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	UHCI_DATE_DATE_Msk = 0xffffffff
)

// Constants for USB_DEVICE: Full-speed USB Serial/JTAG Controller
const (
	// EP1: FIFO access for the CDC-ACM data IN and OUT endpoints.
	// Position of RDWR_BYTE field.
	USB_DEVICE_EP1_RDWR_BYTE_Pos = 0x0
	// Bit mask of RDWR_BYTE field.
	USB_DEVICE_EP1_RDWR_BYTE_Msk = 0xff

	// EP1_CONF: Configuration and control registers for the CDC-ACM FIFOs.
	// Position of WR_DONE field.
	USB_DEVICE_EP1_CONF_WR_DONE_Pos = 0x0
	// Bit mask of WR_DONE field.
	USB_DEVICE_EP1_CONF_WR_DONE_Msk = 0x1
	// Bit WR_DONE.
	USB_DEVICE_EP1_CONF_WR_DONE = 0x1
	// Position of SERIAL_IN_EP_DATA_FREE field.
	USB_DEVICE_EP1_CONF_SERIAL_IN_EP_DATA_FREE_Pos = 0x1
	// Bit mask of SERIAL_IN_EP_DATA_FREE field.
	USB_DEVICE_EP1_CONF_SERIAL_IN_EP_DATA_FREE_Msk = 0x2
	// Bit SERIAL_IN_EP_DATA_FREE.
	USB_DEVICE_EP1_CONF_SERIAL_IN_EP_DATA_FREE = 0x2
	// Position of SERIAL_OUT_EP_DATA_AVAIL field.
	USB_DEVICE_EP1_CONF_SERIAL_OUT_EP_DATA_AVAIL_Pos = 0x2
	// Bit mask of SERIAL_OUT_EP_DATA_AVAIL field.
	USB_DEVICE_EP1_CONF_SERIAL_OUT_EP_DATA_AVAIL_Msk = 0x4
	// Bit SERIAL_OUT_EP_DATA_AVAIL.
	USB_DEVICE_EP1_CONF_SERIAL_OUT_EP_DATA_AVAIL = 0x4

	// INT_RAW: Interrupt raw status register.
	// Position of JTAG_IN_FLUSH_INT_RAW field.
	USB_DEVICE_INT_RAW_JTAG_IN_FLUSH_INT_RAW_Pos = 0x0
	// Bit mask of JTAG_IN_FLUSH_INT_RAW field.
	USB_DEVICE_INT_RAW_JTAG_IN_FLUSH_INT_RAW_Msk = 0x1
	// Bit JTAG_IN_FLUSH_INT_RAW.
	USB_DEVICE_INT_RAW_JTAG_IN_FLUSH_INT_RAW = 0x1
	// Position of SOF_INT_RAW field.
	USB_DEVICE_INT_RAW_SOF_INT_RAW_Pos = 0x1
	// Bit mask of SOF_INT_RAW field.
	USB_DEVICE_INT_RAW_SOF_INT_RAW_Msk = 0x2
	// Bit SOF_INT_RAW.
	USB_DEVICE_INT_RAW_SOF_INT_RAW = 0x2
	// Position of SERIAL_OUT_RECV_PKT_INT_RAW field.
	USB_DEVICE_INT_RAW_SERIAL_OUT_RECV_PKT_INT_RAW_Pos = 0x2
	// Bit mask of SERIAL_OUT_RECV_PKT_INT_RAW field.
	USB_DEVICE_INT_RAW_SERIAL_OUT_RECV_PKT_INT_RAW_Msk = 0x4
	// Bit SERIAL_OUT_RECV_PKT_INT_RAW.
	USB_DEVICE_INT_RAW_SERIAL_OUT_RECV_PKT_INT_RAW = 0x4
	// Position of SERIAL_IN_EMPTY_INT_RAW field.
	USB_DEVICE_INT_RAW_SERIAL_IN_EMPTY_INT_RAW_Pos = 0x3
	// Bit mask of SERIAL_IN_EMPTY_INT_RAW field.
	USB_DEVICE_INT_RAW_SERIAL_IN_EMPTY_INT_RAW_Msk = 0x8
	// Bit SERIAL_IN_EMPTY_INT_RAW.
	USB_DEVICE_INT_RAW_SERIAL_IN_EMPTY_INT_RAW = 0x8
	// Position of PID_ERR_INT_RAW field.
	USB_DEVICE_INT_RAW_PID_ERR_INT_RAW_Pos = 0x4
	// Bit mask of PID_ERR_INT_RAW field.
	USB_DEVICE_INT_RAW_PID_ERR_INT_RAW_Msk = 0x10
	// Bit PID_ERR_INT_RAW.
	USB_DEVICE_INT_RAW_PID_ERR_INT_RAW = 0x10
	// Position of CRC5_ERR_INT_RAW field.
	USB_DEVICE_INT_RAW_CRC5_ERR_INT_RAW_Pos = 0x5
	// Bit mask of CRC5_ERR_INT_RAW field.
	USB_DEVICE_INT_RAW_CRC5_ERR_INT_RAW_Msk = 0x20
	// Bit CRC5_ERR_INT_RAW.
	USB_DEVICE_INT_RAW_CRC5_ERR_INT_RAW = 0x20
	// Position of CRC16_ERR_INT_RAW field.
	USB_DEVICE_INT_RAW_CRC16_ERR_INT_RAW_Pos = 0x6
	// Bit mask of CRC16_ERR_INT_RAW field.
	USB_DEVICE_INT_RAW_CRC16_ERR_INT_RAW_Msk = 0x40
	// Bit CRC16_ERR_INT_RAW.
	USB_DEVICE_INT_RAW_CRC16_ERR_INT_RAW = 0x40
	// Position of STUFF_ERR_INT_RAW field.
	USB_DEVICE_INT_RAW_STUFF_ERR_INT_RAW_Pos = 0x7
	// Bit mask of STUFF_ERR_INT_RAW field.
	USB_DEVICE_INT_RAW_STUFF_ERR_INT_RAW_Msk = 0x80
	// Bit STUFF_ERR_INT_RAW.
	USB_DEVICE_INT_RAW_STUFF_ERR_INT_RAW = 0x80
	// Position of IN_TOKEN_REC_IN_EP1_INT_RAW field.
	USB_DEVICE_INT_RAW_IN_TOKEN_REC_IN_EP1_INT_RAW_Pos = 0x8
	// Bit mask of IN_TOKEN_REC_IN_EP1_INT_RAW field.
	USB_DEVICE_INT_RAW_IN_TOKEN_REC_IN_EP1_INT_RAW_Msk = 0x100
	// Bit IN_TOKEN_REC_IN_EP1_INT_RAW.
	USB_DEVICE_INT_RAW_IN_TOKEN_REC_IN_EP1_INT_RAW = 0x100
	// Position of USB_BUS_RESET_INT_RAW field.
	USB_DEVICE_INT_RAW_USB_BUS_RESET_INT_RAW_Pos = 0x9
	// Bit mask of USB_BUS_RESET_INT_RAW field.
	USB_DEVICE_INT_RAW_USB_BUS_RESET_INT_RAW_Msk = 0x200
	// Bit USB_BUS_RESET_INT_RAW.
	USB_DEVICE_INT_RAW_USB_BUS_RESET_INT_RAW = 0x200
	// Position of OUT_EP1_ZERO_PAYLOAD_INT_RAW field.
	USB_DEVICE_INT_RAW_OUT_EP1_ZERO_PAYLOAD_INT_RAW_Pos = 0xa
	// Bit mask of OUT_EP1_ZERO_PAYLOAD_INT_RAW field.
	USB_DEVICE_INT_RAW_OUT_EP1_ZERO_PAYLOAD_INT_RAW_Msk = 0x400
	// Bit OUT_EP1_ZERO_PAYLOAD_INT_RAW.
	USB_DEVICE_INT_RAW_OUT_EP1_ZERO_PAYLOAD_INT_RAW = 0x400
	// Position of OUT_EP2_ZERO_PAYLOAD_INT_RAW field.
	USB_DEVICE_INT_RAW_OUT_EP2_ZERO_PAYLOAD_INT_RAW_Pos = 0xb
	// Bit mask of OUT_EP2_ZERO_PAYLOAD_INT_RAW field.
	USB_DEVICE_INT_RAW_OUT_EP2_ZERO_PAYLOAD_INT_RAW_Msk = 0x800
	// Bit OUT_EP2_ZERO_PAYLOAD_INT_RAW.
	USB_DEVICE_INT_RAW_OUT_EP2_ZERO_PAYLOAD_INT_RAW = 0x800
	// Position of RTS_CHG_INT_RAW field.
	USB_DEVICE_INT_RAW_RTS_CHG_INT_RAW_Pos = 0xc
	// Bit mask of RTS_CHG_INT_RAW field.
	USB_DEVICE_INT_RAW_RTS_CHG_INT_RAW_Msk = 0x1000
	// Bit RTS_CHG_INT_RAW.
	USB_DEVICE_INT_RAW_RTS_CHG_INT_RAW = 0x1000
	// Position of DTR_CHG_INT_RAW field.
	USB_DEVICE_INT_RAW_DTR_CHG_INT_RAW_Pos = 0xd
	// Bit mask of DTR_CHG_INT_RAW field.
	USB_DEVICE_INT_RAW_DTR_CHG_INT_RAW_Msk = 0x2000
	// Bit DTR_CHG_INT_RAW.
	USB_DEVICE_INT_RAW_DTR_CHG_INT_RAW = 0x2000
	// Position of GET_LINE_CODE_INT_RAW field.
	USB_DEVICE_INT_RAW_GET_LINE_CODE_INT_RAW_Pos = 0xe
	// Bit mask of GET_LINE_CODE_INT_RAW field.
	USB_DEVICE_INT_RAW_GET_LINE_CODE_INT_RAW_Msk = 0x4000
	// Bit GET_LINE_CODE_INT_RAW.
	USB_DEVICE_INT_RAW_GET_LINE_CODE_INT_RAW = 0x4000
	// Position of SET_LINE_CODE_INT_RAW field.
	USB_DEVICE_INT_RAW_SET_LINE_CODE_INT_RAW_Pos = 0xf
	// Bit mask of SET_LINE_CODE_INT_RAW field.
	USB_DEVICE_INT_RAW_SET_LINE_CODE_INT_RAW_Msk = 0x8000
	// Bit SET_LINE_CODE_INT_RAW.
	USB_DEVICE_INT_RAW_SET_LINE_CODE_INT_RAW = 0x8000

	// INT_ST: Interrupt status register.
	// Position of JTAG_IN_FLUSH_INT_ST field.
	USB_DEVICE_INT_ST_JTAG_IN_FLUSH_INT_ST_Pos = 0x0
	// Bit mask of JTAG_IN_FLUSH_INT_ST field.
	USB_DEVICE_INT_ST_JTAG_IN_FLUSH_INT_ST_Msk = 0x1
	// Bit JTAG_IN_FLUSH_INT_ST.
	USB_DEVICE_INT_ST_JTAG_IN_FLUSH_INT_ST = 0x1
	// Position of SOF_INT_ST field.
	USB_DEVICE_INT_ST_SOF_INT_ST_Pos = 0x1
	// Bit mask of SOF_INT_ST field.
	USB_DEVICE_INT_ST_SOF_INT_ST_Msk = 0x2
	// Bit SOF_INT_ST.
	USB_DEVICE_INT_ST_SOF_INT_ST = 0x2
	// Position of SERIAL_OUT_RECV_PKT_INT_ST field.
	USB_DEVICE_INT_ST_SERIAL_OUT_RECV_PKT_INT_ST_Pos = 0x2
	// Bit mask of SERIAL_OUT_RECV_PKT_INT_ST field.
	USB_DEVICE_INT_ST_SERIAL_OUT_RECV_PKT_INT_ST_Msk = 0x4
	// Bit SERIAL_OUT_RECV_PKT_INT_ST.
	USB_DEVICE_INT_ST_SERIAL_OUT_RECV_PKT_INT_ST = 0x4
	// Position of SERIAL_IN_EMPTY_INT_ST field.
	USB_DEVICE_INT_ST_SERIAL_IN_EMPTY_INT_ST_Pos = 0x3
	// Bit mask of SERIAL_IN_EMPTY_INT_ST field.
	USB_DEVICE_INT_ST_SERIAL_IN_EMPTY_INT_ST_Msk = 0x8
	// Bit SERIAL_IN_EMPTY_INT_ST.
	USB_DEVICE_INT_ST_SERIAL_IN_EMPTY_INT_ST = 0x8
	// Position of PID_ERR_INT_ST field.
	USB_DEVICE_INT_ST_PID_ERR_INT_ST_Pos = 0x4
	// Bit mask of PID_ERR_INT_ST field.
	USB_DEVICE_INT_ST_PID_ERR_INT_ST_Msk = 0x10
	// Bit PID_ERR_INT_ST.
	USB_DEVICE_INT_ST_PID_ERR_INT_ST = 0x10
	// Position of CRC5_ERR_INT_ST field.
	USB_DEVICE_INT_ST_CRC5_ERR_INT_ST_Pos = 0x5
	// Bit mask of CRC5_ERR_INT_ST field.
	USB_DEVICE_INT_ST_CRC5_ERR_INT_ST_Msk = 0x20
	// Bit CRC5_ERR_INT_ST.
	USB_DEVICE_INT_ST_CRC5_ERR_INT_ST = 0x20
	// Position of CRC16_ERR_INT_ST field.
	USB_DEVICE_INT_ST_CRC16_ERR_INT_ST_Pos = 0x6
	// Bit mask of CRC16_ERR_INT_ST field.
	USB_DEVICE_INT_ST_CRC16_ERR_INT_ST_Msk = 0x40
	// Bit CRC16_ERR_INT_ST.
	USB_DEVICE_INT_ST_CRC16_ERR_INT_ST = 0x40
	// Position of STUFF_ERR_INT_ST field.
	USB_DEVICE_INT_ST_STUFF_ERR_INT_ST_Pos = 0x7
	// Bit mask of STUFF_ERR_INT_ST field.
	USB_DEVICE_INT_ST_STUFF_ERR_INT_ST_Msk = 0x80
	// Bit STUFF_ERR_INT_ST.
	USB_DEVICE_INT_ST_STUFF_ERR_INT_ST = 0x80
	// Position of IN_TOKEN_REC_IN_EP1_INT_ST field.
	USB_DEVICE_INT_ST_IN_TOKEN_REC_IN_EP1_INT_ST_Pos = 0x8
	// Bit mask of IN_TOKEN_REC_IN_EP1_INT_ST field.
	USB_DEVICE_INT_ST_IN_TOKEN_REC_IN_EP1_INT_ST_Msk = 0x100
	// Bit IN_TOKEN_REC_IN_EP1_INT_ST.
	USB_DEVICE_INT_ST_IN_TOKEN_REC_IN_EP1_INT_ST = 0x100
	// Position of USB_BUS_RESET_INT_ST field.
	USB_DEVICE_INT_ST_USB_BUS_RESET_INT_ST_Pos = 0x9
	// Bit mask of USB_BUS_RESET_INT_ST field.
	USB_DEVICE_INT_ST_USB_BUS_RESET_INT_ST_Msk = 0x200
	// Bit USB_BUS_RESET_INT_ST.
	USB_DEVICE_INT_ST_USB_BUS_RESET_INT_ST = 0x200
	// Position of OUT_EP1_ZERO_PAYLOAD_INT_ST field.
	USB_DEVICE_INT_ST_OUT_EP1_ZERO_PAYLOAD_INT_ST_Pos = 0xa
	// Bit mask of OUT_EP1_ZERO_PAYLOAD_INT_ST field.
	USB_DEVICE_INT_ST_OUT_EP1_ZERO_PAYLOAD_INT_ST_Msk = 0x400
	// Bit OUT_EP1_ZERO_PAYLOAD_INT_ST.
	USB_DEVICE_INT_ST_OUT_EP1_ZERO_PAYLOAD_INT_ST = 0x400
	// Position of OUT_EP2_ZERO_PAYLOAD_INT_ST field.
	USB_DEVICE_INT_ST_OUT_EP2_ZERO_PAYLOAD_INT_ST_Pos = 0xb
	// Bit mask of OUT_EP2_ZERO_PAYLOAD_INT_ST field.
	USB_DEVICE_INT_ST_OUT_EP2_ZERO_PAYLOAD_INT_ST_Msk = 0x800
	// Bit OUT_EP2_ZERO_PAYLOAD_INT_ST.
	USB_DEVICE_INT_ST_OUT_EP2_ZERO_PAYLOAD_INT_ST = 0x800
	// Position of RTS_CHG_INT_ST field.
	USB_DEVICE_INT_ST_RTS_CHG_INT_ST_Pos = 0xc
	// Bit mask of RTS_CHG_INT_ST field.
	USB_DEVICE_INT_ST_RTS_CHG_INT_ST_Msk = 0x1000
	// Bit RTS_CHG_INT_ST.
	USB_DEVICE_INT_ST_RTS_CHG_INT_ST = 0x1000
	// Position of DTR_CHG_INT_ST field.
	USB_DEVICE_INT_ST_DTR_CHG_INT_ST_Pos = 0xd
	// Bit mask of DTR_CHG_INT_ST field.
	USB_DEVICE_INT_ST_DTR_CHG_INT_ST_Msk = 0x2000
	// Bit DTR_CHG_INT_ST.
	USB_DEVICE_INT_ST_DTR_CHG_INT_ST = 0x2000
	// Position of GET_LINE_CODE_INT_ST field.
	USB_DEVICE_INT_ST_GET_LINE_CODE_INT_ST_Pos = 0xe
	// Bit mask of GET_LINE_CODE_INT_ST field.
	USB_DEVICE_INT_ST_GET_LINE_CODE_INT_ST_Msk = 0x4000
	// Bit GET_LINE_CODE_INT_ST.
	USB_DEVICE_INT_ST_GET_LINE_CODE_INT_ST = 0x4000
	// Position of SET_LINE_CODE_INT_ST field.
	USB_DEVICE_INT_ST_SET_LINE_CODE_INT_ST_Pos = 0xf
	// Bit mask of SET_LINE_CODE_INT_ST field.
	USB_DEVICE_INT_ST_SET_LINE_CODE_INT_ST_Msk = 0x8000
	// Bit SET_LINE_CODE_INT_ST.
	USB_DEVICE_INT_ST_SET_LINE_CODE_INT_ST = 0x8000

	// INT_ENA: Interrupt enable status register.
	// Position of JTAG_IN_FLUSH_INT_ENA field.
	USB_DEVICE_INT_ENA_JTAG_IN_FLUSH_INT_ENA_Pos = 0x0
	// Bit mask of JTAG_IN_FLUSH_INT_ENA field.
	USB_DEVICE_INT_ENA_JTAG_IN_FLUSH_INT_ENA_Msk = 0x1
	// Bit JTAG_IN_FLUSH_INT_ENA.
	USB_DEVICE_INT_ENA_JTAG_IN_FLUSH_INT_ENA = 0x1
	// Position of SOF_INT_ENA field.
	USB_DEVICE_INT_ENA_SOF_INT_ENA_Pos = 0x1
	// Bit mask of SOF_INT_ENA field.
	USB_DEVICE_INT_ENA_SOF_INT_ENA_Msk = 0x2
	// Bit SOF_INT_ENA.
	USB_DEVICE_INT_ENA_SOF_INT_ENA = 0x2
	// Position of SERIAL_OUT_RECV_PKT_INT_ENA field.
	USB_DEVICE_INT_ENA_SERIAL_OUT_RECV_PKT_INT_ENA_Pos = 0x2
	// Bit mask of SERIAL_OUT_RECV_PKT_INT_ENA field.
	USB_DEVICE_INT_ENA_SERIAL_OUT_RECV_PKT_INT_ENA_Msk = 0x4
	// Bit SERIAL_OUT_RECV_PKT_INT_ENA.
	USB_DEVICE_INT_ENA_SERIAL_OUT_RECV_PKT_INT_ENA = 0x4
	// Position of SERIAL_IN_EMPTY_INT_ENA field.
	USB_DEVICE_INT_ENA_SERIAL_IN_EMPTY_INT_ENA_Pos = 0x3
	// Bit mask of SERIAL_IN_EMPTY_INT_ENA field.
	USB_DEVICE_INT_ENA_SERIAL_IN_EMPTY_INT_ENA_Msk = 0x8
	// Bit SERIAL_IN_EMPTY_INT_ENA.
	USB_DEVICE_INT_ENA_SERIAL_IN_EMPTY_INT_ENA = 0x8
	// Position of PID_ERR_INT_ENA field.
	USB_DEVICE_INT_ENA_PID_ERR_INT_ENA_Pos = 0x4
	// Bit mask of PID_ERR_INT_ENA field.
	USB_DEVICE_INT_ENA_PID_ERR_INT_ENA_Msk = 0x10
	// Bit PID_ERR_INT_ENA.
	USB_DEVICE_INT_ENA_PID_ERR_INT_ENA = 0x10
	// Position of CRC5_ERR_INT_ENA field.
	USB_DEVICE_INT_ENA_CRC5_ERR_INT_ENA_Pos = 0x5
	// Bit mask of CRC5_ERR_INT_ENA field.
	USB_DEVICE_INT_ENA_CRC5_ERR_INT_ENA_Msk = 0x20
	// Bit CRC5_ERR_INT_ENA.
	USB_DEVICE_INT_ENA_CRC5_ERR_INT_ENA = 0x20
	// Position of CRC16_ERR_INT_ENA field.
	USB_DEVICE_INT_ENA_CRC16_ERR_INT_ENA_Pos = 0x6
	// Bit mask of CRC16_ERR_INT_ENA field.
	USB_DEVICE_INT_ENA_CRC16_ERR_INT_ENA_Msk = 0x40
	// Bit CRC16_ERR_INT_ENA.
	USB_DEVICE_INT_ENA_CRC16_ERR_INT_ENA = 0x40
	// Position of STUFF_ERR_INT_ENA field.
	USB_DEVICE_INT_ENA_STUFF_ERR_INT_ENA_Pos = 0x7
	// Bit mask of STUFF_ERR_INT_ENA field.
	USB_DEVICE_INT_ENA_STUFF_ERR_INT_ENA_Msk = 0x80
	// Bit STUFF_ERR_INT_ENA.
	USB_DEVICE_INT_ENA_STUFF_ERR_INT_ENA = 0x80
	// Position of IN_TOKEN_REC_IN_EP1_INT_ENA field.
	USB_DEVICE_INT_ENA_IN_TOKEN_REC_IN_EP1_INT_ENA_Pos = 0x8
	// Bit mask of IN_TOKEN_REC_IN_EP1_INT_ENA field.
	USB_DEVICE_INT_ENA_IN_TOKEN_REC_IN_EP1_INT_ENA_Msk = 0x100
	// Bit IN_TOKEN_REC_IN_EP1_INT_ENA.
	USB_DEVICE_INT_ENA_IN_TOKEN_REC_IN_EP1_INT_ENA = 0x100
	// Position of USB_BUS_RESET_INT_ENA field.
	USB_DEVICE_INT_ENA_USB_BUS_RESET_INT_ENA_Pos = 0x9
	// Bit mask of USB_BUS_RESET_INT_ENA field.
	USB_DEVICE_INT_ENA_USB_BUS_RESET_INT_ENA_Msk = 0x200
	// Bit USB_BUS_RESET_INT_ENA.
	USB_DEVICE_INT_ENA_USB_BUS_RESET_INT_ENA = 0x200
	// Position of OUT_EP1_ZERO_PAYLOAD_INT_ENA field.
	USB_DEVICE_INT_ENA_OUT_EP1_ZERO_PAYLOAD_INT_ENA_Pos = 0xa
	// Bit mask of OUT_EP1_ZERO_PAYLOAD_INT_ENA field.
	USB_DEVICE_INT_ENA_OUT_EP1_ZERO_PAYLOAD_INT_ENA_Msk = 0x400
	// Bit OUT_EP1_ZERO_PAYLOAD_INT_ENA.
	USB_DEVICE_INT_ENA_OUT_EP1_ZERO_PAYLOAD_INT_ENA = 0x400
	// Position of OUT_EP2_ZERO_PAYLOAD_INT_ENA field.
	USB_DEVICE_INT_ENA_OUT_EP2_ZERO_PAYLOAD_INT_ENA_Pos = 0xb
	// Bit mask of OUT_EP2_ZERO_PAYLOAD_INT_ENA field.
	USB_DEVICE_INT_ENA_OUT_EP2_ZERO_PAYLOAD_INT_ENA_Msk = 0x800
	// Bit OUT_EP2_ZERO_PAYLOAD_INT_ENA.
	USB_DEVICE_INT_ENA_OUT_EP2_ZERO_PAYLOAD_INT_ENA = 0x800
	// Position of RTS_CHG_INT_ENA field.
	USB_DEVICE_INT_ENA_RTS_CHG_INT_ENA_Pos = 0xc
	// Bit mask of RTS_CHG_INT_ENA field.
	USB_DEVICE_INT_ENA_RTS_CHG_INT_ENA_Msk = 0x1000
	// Bit RTS_CHG_INT_ENA.
	USB_DEVICE_INT_ENA_RTS_CHG_INT_ENA = 0x1000
	// Position of DTR_CHG_INT_ENA field.
	USB_DEVICE_INT_ENA_DTR_CHG_INT_ENA_Pos = 0xd
	// Bit mask of DTR_CHG_INT_ENA field.
	USB_DEVICE_INT_ENA_DTR_CHG_INT_ENA_Msk = 0x2000
	// Bit DTR_CHG_INT_ENA.
	USB_DEVICE_INT_ENA_DTR_CHG_INT_ENA = 0x2000
	// Position of GET_LINE_CODE_INT_ENA field.
	USB_DEVICE_INT_ENA_GET_LINE_CODE_INT_ENA_Pos = 0xe
	// Bit mask of GET_LINE_CODE_INT_ENA field.
	USB_DEVICE_INT_ENA_GET_LINE_CODE_INT_ENA_Msk = 0x4000
	// Bit GET_LINE_CODE_INT_ENA.
	USB_DEVICE_INT_ENA_GET_LINE_CODE_INT_ENA = 0x4000
	// Position of SET_LINE_CODE_INT_ENA field.
	USB_DEVICE_INT_ENA_SET_LINE_CODE_INT_ENA_Pos = 0xf
	// Bit mask of SET_LINE_CODE_INT_ENA field.
	USB_DEVICE_INT_ENA_SET_LINE_CODE_INT_ENA_Msk = 0x8000
	// Bit SET_LINE_CODE_INT_ENA.
	USB_DEVICE_INT_ENA_SET_LINE_CODE_INT_ENA = 0x8000

	// INT_CLR: Interrupt clear status register.
	// Position of JTAG_IN_FLUSH_INT_CLR field.
	USB_DEVICE_INT_CLR_JTAG_IN_FLUSH_INT_CLR_Pos = 0x0
	// Bit mask of JTAG_IN_FLUSH_INT_CLR field.
	USB_DEVICE_INT_CLR_JTAG_IN_FLUSH_INT_CLR_Msk = 0x1
	// Bit JTAG_IN_FLUSH_INT_CLR.
	USB_DEVICE_INT_CLR_JTAG_IN_FLUSH_INT_CLR = 0x1
	// Position of SOF_INT_CLR field.
	USB_DEVICE_INT_CLR_SOF_INT_CLR_Pos = 0x1
	// Bit mask of SOF_INT_CLR field.
	USB_DEVICE_INT_CLR_SOF_INT_CLR_Msk = 0x2
	// Bit SOF_INT_CLR.
	USB_DEVICE_INT_CLR_SOF_INT_CLR = 0x2
	// Position of SERIAL_OUT_RECV_PKT_INT_CLR field.
	USB_DEVICE_INT_CLR_SERIAL_OUT_RECV_PKT_INT_CLR_Pos = 0x2
	// Bit mask of SERIAL_OUT_RECV_PKT_INT_CLR field.
	USB_DEVICE_INT_CLR_SERIAL_OUT_RECV_PKT_INT_CLR_Msk = 0x4
	// Bit SERIAL_OUT_RECV_PKT_INT_CLR.
	USB_DEVICE_INT_CLR_SERIAL_OUT_RECV_PKT_INT_CLR = 0x4
	// Position of SERIAL_IN_EMPTY_INT_CLR field.
	USB_DEVICE_INT_CLR_SERIAL_IN_EMPTY_INT_CLR_Pos = 0x3
	// Bit mask of SERIAL_IN_EMPTY_INT_CLR field.
	USB_DEVICE_INT_CLR_SERIAL_IN_EMPTY_INT_CLR_Msk = 0x8
	// Bit SERIAL_IN_EMPTY_INT_CLR.
	USB_DEVICE_INT_CLR_SERIAL_IN_EMPTY_INT_CLR = 0x8
	// Position of PID_ERR_INT_CLR field.
	USB_DEVICE_INT_CLR_PID_ERR_INT_CLR_Pos = 0x4
	// Bit mask of PID_ERR_INT_CLR field.
	USB_DEVICE_INT_CLR_PID_ERR_INT_CLR_Msk = 0x10
	// Bit PID_ERR_INT_CLR.
	USB_DEVICE_INT_CLR_PID_ERR_INT_CLR = 0x10
	// Position of CRC5_ERR_INT_CLR field.
	USB_DEVICE_INT_CLR_CRC5_ERR_INT_CLR_Pos = 0x5
	// Bit mask of CRC5_ERR_INT_CLR field.
	USB_DEVICE_INT_CLR_CRC5_ERR_INT_CLR_Msk = 0x20
	// Bit CRC5_ERR_INT_CLR.
	USB_DEVICE_INT_CLR_CRC5_ERR_INT_CLR = 0x20
	// Position of CRC16_ERR_INT_CLR field.
	USB_DEVICE_INT_CLR_CRC16_ERR_INT_CLR_Pos = 0x6
	// Bit mask of CRC16_ERR_INT_CLR field.
	USB_DEVICE_INT_CLR_CRC16_ERR_INT_CLR_Msk = 0x40
	// Bit CRC16_ERR_INT_CLR.
	USB_DEVICE_INT_CLR_CRC16_ERR_INT_CLR = 0x40
	// Position of STUFF_ERR_INT_CLR field.
	USB_DEVICE_INT_CLR_STUFF_ERR_INT_CLR_Pos = 0x7
	// Bit mask of STUFF_ERR_INT_CLR field.
	USB_DEVICE_INT_CLR_STUFF_ERR_INT_CLR_Msk = 0x80
	// Bit STUFF_ERR_INT_CLR.
	USB_DEVICE_INT_CLR_STUFF_ERR_INT_CLR = 0x80
	// Position of IN_TOKEN_REC_IN_EP1_INT_CLR field.
	USB_DEVICE_INT_CLR_IN_TOKEN_REC_IN_EP1_INT_CLR_Pos = 0x8
	// Bit mask of IN_TOKEN_REC_IN_EP1_INT_CLR field.
	USB_DEVICE_INT_CLR_IN_TOKEN_REC_IN_EP1_INT_CLR_Msk = 0x100
	// Bit IN_TOKEN_REC_IN_EP1_INT_CLR.
	USB_DEVICE_INT_CLR_IN_TOKEN_REC_IN_EP1_INT_CLR = 0x100
	// Position of USB_BUS_RESET_INT_CLR field.
	USB_DEVICE_INT_CLR_USB_BUS_RESET_INT_CLR_Pos = 0x9
	// Bit mask of USB_BUS_RESET_INT_CLR field.
	USB_DEVICE_INT_CLR_USB_BUS_RESET_INT_CLR_Msk = 0x200
	// Bit USB_BUS_RESET_INT_CLR.
	USB_DEVICE_INT_CLR_USB_BUS_RESET_INT_CLR = 0x200
	// Position of OUT_EP1_ZERO_PAYLOAD_INT_CLR field.
	USB_DEVICE_INT_CLR_OUT_EP1_ZERO_PAYLOAD_INT_CLR_Pos = 0xa
	// Bit mask of OUT_EP1_ZERO_PAYLOAD_INT_CLR field.
	USB_DEVICE_INT_CLR_OUT_EP1_ZERO_PAYLOAD_INT_CLR_Msk = 0x400
	// Bit OUT_EP1_ZERO_PAYLOAD_INT_CLR.
	USB_DEVICE_INT_CLR_OUT_EP1_ZERO_PAYLOAD_INT_CLR = 0x400
	// Position of OUT_EP2_ZERO_PAYLOAD_INT_CLR field.
	USB_DEVICE_INT_CLR_OUT_EP2_ZERO_PAYLOAD_INT_CLR_Pos = 0xb
	// Bit mask of OUT_EP2_ZERO_PAYLOAD_INT_CLR field.
	USB_DEVICE_INT_CLR_OUT_EP2_ZERO_PAYLOAD_INT_CLR_Msk = 0x800
	// Bit OUT_EP2_ZERO_PAYLOAD_INT_CLR.
	USB_DEVICE_INT_CLR_OUT_EP2_ZERO_PAYLOAD_INT_CLR = 0x800
	// Position of RTS_CHG_INT_CLR field.
	USB_DEVICE_INT_CLR_RTS_CHG_INT_CLR_Pos = 0xc
	// Bit mask of RTS_CHG_INT_CLR field.
	USB_DEVICE_INT_CLR_RTS_CHG_INT_CLR_Msk = 0x1000
	// Bit RTS_CHG_INT_CLR.
	USB_DEVICE_INT_CLR_RTS_CHG_INT_CLR = 0x1000
	// Position of DTR_CHG_INT_CLR field.
	USB_DEVICE_INT_CLR_DTR_CHG_INT_CLR_Pos = 0xd
	// Bit mask of DTR_CHG_INT_CLR field.
	USB_DEVICE_INT_CLR_DTR_CHG_INT_CLR_Msk = 0x2000
	// Bit DTR_CHG_INT_CLR.
	USB_DEVICE_INT_CLR_DTR_CHG_INT_CLR = 0x2000
	// Position of GET_LINE_CODE_INT_CLR field.
	USB_DEVICE_INT_CLR_GET_LINE_CODE_INT_CLR_Pos = 0xe
	// Bit mask of GET_LINE_CODE_INT_CLR field.
	USB_DEVICE_INT_CLR_GET_LINE_CODE_INT_CLR_Msk = 0x4000
	// Bit GET_LINE_CODE_INT_CLR.
	USB_DEVICE_INT_CLR_GET_LINE_CODE_INT_CLR = 0x4000
	// Position of SET_LINE_CODE_INT_CLR field.
	USB_DEVICE_INT_CLR_SET_LINE_CODE_INT_CLR_Pos = 0xf
	// Bit mask of SET_LINE_CODE_INT_CLR field.
	USB_DEVICE_INT_CLR_SET_LINE_CODE_INT_CLR_Msk = 0x8000
	// Bit SET_LINE_CODE_INT_CLR.
	USB_DEVICE_INT_CLR_SET_LINE_CODE_INT_CLR = 0x8000

	// CONF0: PHY hardware configuration.
	// Position of PHY_SEL field.
	USB_DEVICE_CONF0_PHY_SEL_Pos = 0x0
	// Bit mask of PHY_SEL field.
	USB_DEVICE_CONF0_PHY_SEL_Msk = 0x1
	// Bit PHY_SEL.
	USB_DEVICE_CONF0_PHY_SEL = 0x1
	// Position of EXCHG_PINS_OVERRIDE field.
	USB_DEVICE_CONF0_EXCHG_PINS_OVERRIDE_Pos = 0x1
	// Bit mask of EXCHG_PINS_OVERRIDE field.
	USB_DEVICE_CONF0_EXCHG_PINS_OVERRIDE_Msk = 0x2
	// Bit EXCHG_PINS_OVERRIDE.
	USB_DEVICE_CONF0_EXCHG_PINS_OVERRIDE = 0x2
	// Position of EXCHG_PINS field.
	USB_DEVICE_CONF0_EXCHG_PINS_Pos = 0x2
	// Bit mask of EXCHG_PINS field.
	USB_DEVICE_CONF0_EXCHG_PINS_Msk = 0x4
	// Bit EXCHG_PINS.
	USB_DEVICE_CONF0_EXCHG_PINS = 0x4
	// Position of VREFH field.
	USB_DEVICE_CONF0_VREFH_Pos = 0x3
	// Bit mask of VREFH field.
	USB_DEVICE_CONF0_VREFH_Msk = 0x18
	// Position of VREFL field.
	USB_DEVICE_CONF0_VREFL_Pos = 0x5
	// Bit mask of VREFL field.
	USB_DEVICE_CONF0_VREFL_Msk = 0x60
	// Position of VREF_OVERRIDE field.
	USB_DEVICE_CONF0_VREF_OVERRIDE_Pos = 0x7
	// Bit mask of VREF_OVERRIDE field.
	USB_DEVICE_CONF0_VREF_OVERRIDE_Msk = 0x80
	// Bit VREF_OVERRIDE.
	USB_DEVICE_CONF0_VREF_OVERRIDE = 0x80
	// Position of PAD_PULL_OVERRIDE field.
	USB_DEVICE_CONF0_PAD_PULL_OVERRIDE_Pos = 0x8
	// Bit mask of PAD_PULL_OVERRIDE field.
	USB_DEVICE_CONF0_PAD_PULL_OVERRIDE_Msk = 0x100
	// Bit PAD_PULL_OVERRIDE.
	USB_DEVICE_CONF0_PAD_PULL_OVERRIDE = 0x100
	// Position of DP_PULLUP field.
	USB_DEVICE_CONF0_DP_PULLUP_Pos = 0x9
	// Bit mask of DP_PULLUP field.
	USB_DEVICE_CONF0_DP_PULLUP_Msk = 0x200
	// Bit DP_PULLUP.
	USB_DEVICE_CONF0_DP_PULLUP = 0x200
	// Position of DP_PULLDOWN field.
	USB_DEVICE_CONF0_DP_PULLDOWN_Pos = 0xa
	// Bit mask of DP_PULLDOWN field.
	USB_DEVICE_CONF0_DP_PULLDOWN_Msk = 0x400
	// Bit DP_PULLDOWN.
	USB_DEVICE_CONF0_DP_PULLDOWN = 0x400
	// Position of DM_PULLUP field.
	USB_DEVICE_CONF0_DM_PULLUP_Pos = 0xb
	// Bit mask of DM_PULLUP field.
	USB_DEVICE_CONF0_DM_PULLUP_Msk = 0x800
	// Bit DM_PULLUP.
	USB_DEVICE_CONF0_DM_PULLUP = 0x800
	// Position of DM_PULLDOWN field.
	USB_DEVICE_CONF0_DM_PULLDOWN_Pos = 0xc
	// Bit mask of DM_PULLDOWN field.
	USB_DEVICE_CONF0_DM_PULLDOWN_Msk = 0x1000
	// Bit DM_PULLDOWN.
	USB_DEVICE_CONF0_DM_PULLDOWN = 0x1000
	// Position of PULLUP_VALUE field.
	USB_DEVICE_CONF0_PULLUP_VALUE_Pos = 0xd
	// Bit mask of PULLUP_VALUE field.
	USB_DEVICE_CONF0_PULLUP_VALUE_Msk = 0x2000
	// Bit PULLUP_VALUE.
	USB_DEVICE_CONF0_PULLUP_VALUE = 0x2000
	// Position of USB_PAD_ENABLE field.
	USB_DEVICE_CONF0_USB_PAD_ENABLE_Pos = 0xe
	// Bit mask of USB_PAD_ENABLE field.
	USB_DEVICE_CONF0_USB_PAD_ENABLE_Msk = 0x4000
	// Bit USB_PAD_ENABLE.
	USB_DEVICE_CONF0_USB_PAD_ENABLE = 0x4000
	// Position of USB_JTAG_BRIDGE_EN field.
	USB_DEVICE_CONF0_USB_JTAG_BRIDGE_EN_Pos = 0xf
	// Bit mask of USB_JTAG_BRIDGE_EN field.
	USB_DEVICE_CONF0_USB_JTAG_BRIDGE_EN_Msk = 0x8000
	// Bit USB_JTAG_BRIDGE_EN.
	USB_DEVICE_CONF0_USB_JTAG_BRIDGE_EN = 0x8000

	// TEST: Registers used for debugging the PHY.
	// Position of TEST_ENABLE field.
	USB_DEVICE_TEST_TEST_ENABLE_Pos = 0x0
	// Bit mask of TEST_ENABLE field.
	USB_DEVICE_TEST_TEST_ENABLE_Msk = 0x1
	// Bit TEST_ENABLE.
	USB_DEVICE_TEST_TEST_ENABLE = 0x1
	// Position of TEST_USB_OE field.
	USB_DEVICE_TEST_TEST_USB_OE_Pos = 0x1
	// Bit mask of TEST_USB_OE field.
	USB_DEVICE_TEST_TEST_USB_OE_Msk = 0x2
	// Bit TEST_USB_OE.
	USB_DEVICE_TEST_TEST_USB_OE = 0x2
	// Position of TEST_TX_DP field.
	USB_DEVICE_TEST_TEST_TX_DP_Pos = 0x2
	// Bit mask of TEST_TX_DP field.
	USB_DEVICE_TEST_TEST_TX_DP_Msk = 0x4
	// Bit TEST_TX_DP.
	USB_DEVICE_TEST_TEST_TX_DP = 0x4
	// Position of TEST_TX_DM field.
	USB_DEVICE_TEST_TEST_TX_DM_Pos = 0x3
	// Bit mask of TEST_TX_DM field.
	USB_DEVICE_TEST_TEST_TX_DM_Msk = 0x8
	// Bit TEST_TX_DM.
	USB_DEVICE_TEST_TEST_TX_DM = 0x8
	// Position of TEST_RX_RCV field.
	USB_DEVICE_TEST_TEST_RX_RCV_Pos = 0x4
	// Bit mask of TEST_RX_RCV field.
	USB_DEVICE_TEST_TEST_RX_RCV_Msk = 0x10
	// Bit TEST_RX_RCV.
	USB_DEVICE_TEST_TEST_RX_RCV = 0x10
	// Position of TEST_RX_DP field.
	USB_DEVICE_TEST_TEST_RX_DP_Pos = 0x5
	// Bit mask of TEST_RX_DP field.
	USB_DEVICE_TEST_TEST_RX_DP_Msk = 0x20
	// Bit TEST_RX_DP.
	USB_DEVICE_TEST_TEST_RX_DP = 0x20
	// Position of TEST_RX_DM field.
	USB_DEVICE_TEST_TEST_RX_DM_Pos = 0x6
	// Bit mask of TEST_RX_DM field.
	USB_DEVICE_TEST_TEST_RX_DM_Msk = 0x40
	// Bit TEST_RX_DM.
	USB_DEVICE_TEST_TEST_RX_DM = 0x40

	// JFIFO_ST: JTAG FIFO status and control registers.
	// Position of IN_FIFO_CNT field.
	USB_DEVICE_JFIFO_ST_IN_FIFO_CNT_Pos = 0x0
	// Bit mask of IN_FIFO_CNT field.
	USB_DEVICE_JFIFO_ST_IN_FIFO_CNT_Msk = 0x3
	// Position of IN_FIFO_EMPTY field.
	USB_DEVICE_JFIFO_ST_IN_FIFO_EMPTY_Pos = 0x2
	// Bit mask of IN_FIFO_EMPTY field.
	USB_DEVICE_JFIFO_ST_IN_FIFO_EMPTY_Msk = 0x4
	// Bit IN_FIFO_EMPTY.
	USB_DEVICE_JFIFO_ST_IN_FIFO_EMPTY = 0x4
	// Position of IN_FIFO_FULL field.
	USB_DEVICE_JFIFO_ST_IN_FIFO_FULL_Pos = 0x3
	// Bit mask of IN_FIFO_FULL field.
	USB_DEVICE_JFIFO_ST_IN_FIFO_FULL_Msk = 0x8
	// Bit IN_FIFO_FULL.
	USB_DEVICE_JFIFO_ST_IN_FIFO_FULL = 0x8
	// Position of OUT_FIFO_CNT field.
	USB_DEVICE_JFIFO_ST_OUT_FIFO_CNT_Pos = 0x4
	// Bit mask of OUT_FIFO_CNT field.
	USB_DEVICE_JFIFO_ST_OUT_FIFO_CNT_Msk = 0x30
	// Position of OUT_FIFO_EMPTY field.
	USB_DEVICE_JFIFO_ST_OUT_FIFO_EMPTY_Pos = 0x6
	// Bit mask of OUT_FIFO_EMPTY field.
	USB_DEVICE_JFIFO_ST_OUT_FIFO_EMPTY_Msk = 0x40
	// Bit OUT_FIFO_EMPTY.
	USB_DEVICE_JFIFO_ST_OUT_FIFO_EMPTY = 0x40
	// Position of OUT_FIFO_FULL field.
	USB_DEVICE_JFIFO_ST_OUT_FIFO_FULL_Pos = 0x7
	// Bit mask of OUT_FIFO_FULL field.
	USB_DEVICE_JFIFO_ST_OUT_FIFO_FULL_Msk = 0x80
	// Bit OUT_FIFO_FULL.
	USB_DEVICE_JFIFO_ST_OUT_FIFO_FULL = 0x80
	// Position of IN_FIFO_RESET field.
	USB_DEVICE_JFIFO_ST_IN_FIFO_RESET_Pos = 0x8
	// Bit mask of IN_FIFO_RESET field.
	USB_DEVICE_JFIFO_ST_IN_FIFO_RESET_Msk = 0x100
	// Bit IN_FIFO_RESET.
	USB_DEVICE_JFIFO_ST_IN_FIFO_RESET = 0x100
	// Position of OUT_FIFO_RESET field.
	USB_DEVICE_JFIFO_ST_OUT_FIFO_RESET_Pos = 0x9
	// Bit mask of OUT_FIFO_RESET field.
	USB_DEVICE_JFIFO_ST_OUT_FIFO_RESET_Msk = 0x200
	// Bit OUT_FIFO_RESET.
	USB_DEVICE_JFIFO_ST_OUT_FIFO_RESET = 0x200

	// FRAM_NUM: Last received SOF frame index register.
	// Position of SOF_FRAME_INDEX field.
	USB_DEVICE_FRAM_NUM_SOF_FRAME_INDEX_Pos = 0x0
	// Bit mask of SOF_FRAME_INDEX field.
	USB_DEVICE_FRAM_NUM_SOF_FRAME_INDEX_Msk = 0x7ff

	// IN_EP0_ST: Control IN endpoint status information.
	// Position of IN_EP0_STATE field.
	USB_DEVICE_IN_EP0_ST_IN_EP0_STATE_Pos = 0x0
	// Bit mask of IN_EP0_STATE field.
	USB_DEVICE_IN_EP0_ST_IN_EP0_STATE_Msk = 0x3
	// Position of IN_EP0_WR_ADDR field.
	USB_DEVICE_IN_EP0_ST_IN_EP0_WR_ADDR_Pos = 0x2
	// Bit mask of IN_EP0_WR_ADDR field.
	USB_DEVICE_IN_EP0_ST_IN_EP0_WR_ADDR_Msk = 0x1fc
	// Position of IN_EP0_RD_ADDR field.
	USB_DEVICE_IN_EP0_ST_IN_EP0_RD_ADDR_Pos = 0x9
	// Bit mask of IN_EP0_RD_ADDR field.
	USB_DEVICE_IN_EP0_ST_IN_EP0_RD_ADDR_Msk = 0xfe00

	// IN_EP1_ST: CDC-ACM IN endpoint status information.
	// Position of IN_EP1_STATE field.
	USB_DEVICE_IN_EP1_ST_IN_EP1_STATE_Pos = 0x0
	// Bit mask of IN_EP1_STATE field.
	USB_DEVICE_IN_EP1_ST_IN_EP1_STATE_Msk = 0x3
	// Position of IN_EP1_WR_ADDR field.
	USB_DEVICE_IN_EP1_ST_IN_EP1_WR_ADDR_Pos = 0x2
	// Bit mask of IN_EP1_WR_ADDR field.
	USB_DEVICE_IN_EP1_ST_IN_EP1_WR_ADDR_Msk = 0x1fc
	// Position of IN_EP1_RD_ADDR field.
	USB_DEVICE_IN_EP1_ST_IN_EP1_RD_ADDR_Pos = 0x9
	// Bit mask of IN_EP1_RD_ADDR field.
	USB_DEVICE_IN_EP1_ST_IN_EP1_RD_ADDR_Msk = 0xfe00

	// IN_EP2_ST: CDC-ACM interrupt IN endpoint status information.
	// Position of IN_EP2_STATE field.
	USB_DEVICE_IN_EP2_ST_IN_EP2_STATE_Pos = 0x0
	// Bit mask of IN_EP2_STATE field.
	USB_DEVICE_IN_EP2_ST_IN_EP2_STATE_Msk = 0x3
	// Position of IN_EP2_WR_ADDR field.
	USB_DEVICE_IN_EP2_ST_IN_EP2_WR_ADDR_Pos = 0x2
	// Bit mask of IN_EP2_WR_ADDR field.
	USB_DEVICE_IN_EP2_ST_IN_EP2_WR_ADDR_Msk = 0x1fc
	// Position of IN_EP2_RD_ADDR field.
	USB_DEVICE_IN_EP2_ST_IN_EP2_RD_ADDR_Pos = 0x9
	// Bit mask of IN_EP2_RD_ADDR field.
	USB_DEVICE_IN_EP2_ST_IN_EP2_RD_ADDR_Msk = 0xfe00

	// IN_EP3_ST: JTAG IN endpoint status information.
	// Position of IN_EP3_STATE field.
	USB_DEVICE_IN_EP3_ST_IN_EP3_STATE_Pos = 0x0
	// Bit mask of IN_EP3_STATE field.
	USB_DEVICE_IN_EP3_ST_IN_EP3_STATE_Msk = 0x3
	// Position of IN_EP3_WR_ADDR field.
	USB_DEVICE_IN_EP3_ST_IN_EP3_WR_ADDR_Pos = 0x2
	// Bit mask of IN_EP3_WR_ADDR field.
	USB_DEVICE_IN_EP3_ST_IN_EP3_WR_ADDR_Msk = 0x1fc
	// Position of IN_EP3_RD_ADDR field.
	USB_DEVICE_IN_EP3_ST_IN_EP3_RD_ADDR_Pos = 0x9
	// Bit mask of IN_EP3_RD_ADDR field.
	USB_DEVICE_IN_EP3_ST_IN_EP3_RD_ADDR_Msk = 0xfe00

	// OUT_EP0_ST: Control OUT endpoint status information.
	// Position of OUT_EP0_STATE field.
	USB_DEVICE_OUT_EP0_ST_OUT_EP0_STATE_Pos = 0x0
	// Bit mask of OUT_EP0_STATE field.
	USB_DEVICE_OUT_EP0_ST_OUT_EP0_STATE_Msk = 0x3
	// Position of OUT_EP0_WR_ADDR field.
	USB_DEVICE_OUT_EP0_ST_OUT_EP0_WR_ADDR_Pos = 0x2
	// Bit mask of OUT_EP0_WR_ADDR field.
	USB_DEVICE_OUT_EP0_ST_OUT_EP0_WR_ADDR_Msk = 0x1fc
	// Position of OUT_EP0_RD_ADDR field.
	USB_DEVICE_OUT_EP0_ST_OUT_EP0_RD_ADDR_Pos = 0x9
	// Bit mask of OUT_EP0_RD_ADDR field.
	USB_DEVICE_OUT_EP0_ST_OUT_EP0_RD_ADDR_Msk = 0xfe00

	// OUT_EP1_ST: CDC-ACM OUT endpoint status information.
	// Position of OUT_EP1_STATE field.
	USB_DEVICE_OUT_EP1_ST_OUT_EP1_STATE_Pos = 0x0
	// Bit mask of OUT_EP1_STATE field.
	USB_DEVICE_OUT_EP1_ST_OUT_EP1_STATE_Msk = 0x3
	// Position of OUT_EP1_WR_ADDR field.
	USB_DEVICE_OUT_EP1_ST_OUT_EP1_WR_ADDR_Pos = 0x2
	// Bit mask of OUT_EP1_WR_ADDR field.
	USB_DEVICE_OUT_EP1_ST_OUT_EP1_WR_ADDR_Msk = 0x1fc
	// Position of OUT_EP1_RD_ADDR field.
	USB_DEVICE_OUT_EP1_ST_OUT_EP1_RD_ADDR_Pos = 0x9
	// Bit mask of OUT_EP1_RD_ADDR field.
	USB_DEVICE_OUT_EP1_ST_OUT_EP1_RD_ADDR_Msk = 0xfe00
	// Position of OUT_EP1_REC_DATA_CNT field.
	USB_DEVICE_OUT_EP1_ST_OUT_EP1_REC_DATA_CNT_Pos = 0x10
	// Bit mask of OUT_EP1_REC_DATA_CNT field.
	USB_DEVICE_OUT_EP1_ST_OUT_EP1_REC_DATA_CNT_Msk = 0x7f0000

	// OUT_EP2_ST: JTAG OUT endpoint status information.
	// Position of OUT_EP2_STATE field.
	USB_DEVICE_OUT_EP2_ST_OUT_EP2_STATE_Pos = 0x0
	// Bit mask of OUT_EP2_STATE field.
	USB_DEVICE_OUT_EP2_ST_OUT_EP2_STATE_Msk = 0x3
	// Position of OUT_EP2_WR_ADDR field.
	USB_DEVICE_OUT_EP2_ST_OUT_EP2_WR_ADDR_Pos = 0x2
	// Bit mask of OUT_EP2_WR_ADDR field.
	USB_DEVICE_OUT_EP2_ST_OUT_EP2_WR_ADDR_Msk = 0x1fc
	// Position of OUT_EP2_RD_ADDR field.
	USB_DEVICE_OUT_EP2_ST_OUT_EP2_RD_ADDR_Pos = 0x9
	// Bit mask of OUT_EP2_RD_ADDR field.
	USB_DEVICE_OUT_EP2_ST_OUT_EP2_RD_ADDR_Msk = 0xfe00

	// MISC_CONF: Clock enable control
	// Position of CLK_EN field.
	USB_DEVICE_MISC_CONF_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	USB_DEVICE_MISC_CONF_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	USB_DEVICE_MISC_CONF_CLK_EN = 0x1

	// MEM_CONF: Memory power control
	// Position of USB_MEM_PD field.
	USB_DEVICE_MEM_CONF_USB_MEM_PD_Pos = 0x0
	// Bit mask of USB_MEM_PD field.
	USB_DEVICE_MEM_CONF_USB_MEM_PD_Msk = 0x1
	// Bit USB_MEM_PD.
	USB_DEVICE_MEM_CONF_USB_MEM_PD = 0x1
	// Position of USB_MEM_CLK_EN field.
	USB_DEVICE_MEM_CONF_USB_MEM_CLK_EN_Pos = 0x1
	// Bit mask of USB_MEM_CLK_EN field.
	USB_DEVICE_MEM_CONF_USB_MEM_CLK_EN_Msk = 0x2
	// Bit USB_MEM_CLK_EN.
	USB_DEVICE_MEM_CONF_USB_MEM_CLK_EN = 0x2

	// CHIP_RST: CDC-ACM chip reset control.
	// Position of RTS field.
	USB_DEVICE_CHIP_RST_RTS_Pos = 0x0
	// Bit mask of RTS field.
	USB_DEVICE_CHIP_RST_RTS_Msk = 0x1
	// Bit RTS.
	USB_DEVICE_CHIP_RST_RTS = 0x1
	// Position of DTR field.
	USB_DEVICE_CHIP_RST_DTR_Pos = 0x1
	// Bit mask of DTR field.
	USB_DEVICE_CHIP_RST_DTR_Msk = 0x2
	// Bit DTR.
	USB_DEVICE_CHIP_RST_DTR = 0x2
	// Position of USB_UART_CHIP_RST_DIS field.
	USB_DEVICE_CHIP_RST_USB_UART_CHIP_RST_DIS_Pos = 0x2
	// Bit mask of USB_UART_CHIP_RST_DIS field.
	USB_DEVICE_CHIP_RST_USB_UART_CHIP_RST_DIS_Msk = 0x4
	// Bit USB_UART_CHIP_RST_DIS.
	USB_DEVICE_CHIP_RST_USB_UART_CHIP_RST_DIS = 0x4

	// SET_LINE_CODE_W0: W0 of SET_LINE_CODING command.
	// Position of DW_DTE_RATE field.
	USB_DEVICE_SET_LINE_CODE_W0_DW_DTE_RATE_Pos = 0x0
	// Bit mask of DW_DTE_RATE field.
	USB_DEVICE_SET_LINE_CODE_W0_DW_DTE_RATE_Msk = 0xffffffff

	// SET_LINE_CODE_W1: W1 of SET_LINE_CODING command.
	// Position of BCHAR_FORMAT field.
	USB_DEVICE_SET_LINE_CODE_W1_BCHAR_FORMAT_Pos = 0x0
	// Bit mask of BCHAR_FORMAT field.
	USB_DEVICE_SET_LINE_CODE_W1_BCHAR_FORMAT_Msk = 0xff
	// Position of BPARITY_TYPE field.
	USB_DEVICE_SET_LINE_CODE_W1_BPARITY_TYPE_Pos = 0x8
	// Bit mask of BPARITY_TYPE field.
	USB_DEVICE_SET_LINE_CODE_W1_BPARITY_TYPE_Msk = 0xff00
	// Position of BDATA_BITS field.
	USB_DEVICE_SET_LINE_CODE_W1_BDATA_BITS_Pos = 0x10
	// Bit mask of BDATA_BITS field.
	USB_DEVICE_SET_LINE_CODE_W1_BDATA_BITS_Msk = 0xff0000

	// GET_LINE_CODE_W0: W0 of GET_LINE_CODING command.
	// Position of GET_DW_DTE_RATE field.
	USB_DEVICE_GET_LINE_CODE_W0_GET_DW_DTE_RATE_Pos = 0x0
	// Bit mask of GET_DW_DTE_RATE field.
	USB_DEVICE_GET_LINE_CODE_W0_GET_DW_DTE_RATE_Msk = 0xffffffff

	// GET_LINE_CODE_W1: W1 of GET_LINE_CODING command.
	// Position of GET_BDATA_BITS field.
	USB_DEVICE_GET_LINE_CODE_W1_GET_BDATA_BITS_Pos = 0x0
	// Bit mask of GET_BDATA_BITS field.
	USB_DEVICE_GET_LINE_CODE_W1_GET_BDATA_BITS_Msk = 0xff
	// Position of GET_BPARITY_TYPE field.
	USB_DEVICE_GET_LINE_CODE_W1_GET_BPARITY_TYPE_Pos = 0x8
	// Bit mask of GET_BPARITY_TYPE field.
	USB_DEVICE_GET_LINE_CODE_W1_GET_BPARITY_TYPE_Msk = 0xff00
	// Position of GET_BCHAR_FORMAT field.
	USB_DEVICE_GET_LINE_CODE_W1_GET_BCHAR_FORMAT_Pos = 0x10
	// Bit mask of GET_BCHAR_FORMAT field.
	USB_DEVICE_GET_LINE_CODE_W1_GET_BCHAR_FORMAT_Msk = 0xff0000

	// CONFIG_UPDATE: Configuration registers' value update
	// Position of CONFIG_UPDATE field.
	USB_DEVICE_CONFIG_UPDATE_CONFIG_UPDATE_Pos = 0x0
	// Bit mask of CONFIG_UPDATE field.
	USB_DEVICE_CONFIG_UPDATE_CONFIG_UPDATE_Msk = 0x1
	// Bit CONFIG_UPDATE.
	USB_DEVICE_CONFIG_UPDATE_CONFIG_UPDATE = 0x1

	// SER_AFIFO_CONFIG: Serial AFIFO configure register
	// Position of SERIAL_IN_AFIFO_RESET_WR field.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_IN_AFIFO_RESET_WR_Pos = 0x0
	// Bit mask of SERIAL_IN_AFIFO_RESET_WR field.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_IN_AFIFO_RESET_WR_Msk = 0x1
	// Bit SERIAL_IN_AFIFO_RESET_WR.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_IN_AFIFO_RESET_WR = 0x1
	// Position of SERIAL_IN_AFIFO_RESET_RD field.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_IN_AFIFO_RESET_RD_Pos = 0x1
	// Bit mask of SERIAL_IN_AFIFO_RESET_RD field.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_IN_AFIFO_RESET_RD_Msk = 0x2
	// Bit SERIAL_IN_AFIFO_RESET_RD.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_IN_AFIFO_RESET_RD = 0x2
	// Position of SERIAL_OUT_AFIFO_RESET_WR field.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_RESET_WR_Pos = 0x2
	// Bit mask of SERIAL_OUT_AFIFO_RESET_WR field.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_RESET_WR_Msk = 0x4
	// Bit SERIAL_OUT_AFIFO_RESET_WR.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_RESET_WR = 0x4
	// Position of SERIAL_OUT_AFIFO_RESET_RD field.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_RESET_RD_Pos = 0x3
	// Bit mask of SERIAL_OUT_AFIFO_RESET_RD field.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_RESET_RD_Msk = 0x8
	// Bit SERIAL_OUT_AFIFO_RESET_RD.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_RESET_RD = 0x8
	// Position of SERIAL_OUT_AFIFO_REMPTY field.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_REMPTY_Pos = 0x4
	// Bit mask of SERIAL_OUT_AFIFO_REMPTY field.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_REMPTY_Msk = 0x10
	// Bit SERIAL_OUT_AFIFO_REMPTY.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_OUT_AFIFO_REMPTY = 0x10
	// Position of SERIAL_IN_AFIFO_WFULL field.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_IN_AFIFO_WFULL_Pos = 0x5
	// Bit mask of SERIAL_IN_AFIFO_WFULL field.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_IN_AFIFO_WFULL_Msk = 0x20
	// Bit SERIAL_IN_AFIFO_WFULL.
	USB_DEVICE_SER_AFIFO_CONFIG_SERIAL_IN_AFIFO_WFULL = 0x20

	// BUS_RESET_ST: USB Bus reset status register
	// Position of USB_BUS_RESET_ST field.
	USB_DEVICE_BUS_RESET_ST_USB_BUS_RESET_ST_Pos = 0x0
	// Bit mask of USB_BUS_RESET_ST field.
	USB_DEVICE_BUS_RESET_ST_USB_BUS_RESET_ST_Msk = 0x1
	// Bit USB_BUS_RESET_ST.
	USB_DEVICE_BUS_RESET_ST_USB_BUS_RESET_ST = 0x1

	// DATE: Date register
	// Position of DATE field.
	USB_DEVICE_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	USB_DEVICE_DATE_DATE_Msk = 0xffffffff
)
